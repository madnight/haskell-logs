00:05:35 <ski_> lambdawar : hm, do you have an example of 'inverse continuation' ?
00:17:07 <lambdawar> ski, when I think about it, Im not sure continuation was the good term for such stuff. I was referring to partial transfer functions of control that could be used for backward analysis. Those functions have the particularity to be different from the call point, unlike forward analysis function transfer which has always the same type for all the callee. In other words, you can be called with a different kind of control transfer
00:18:12 <lambdawar> which has an implication in analysis of backward contexts that are useful for counter-example generation, the goal of such problem.
00:19:07 <Oejet> lambdawar: You talk like a manager. :-P
00:19:20 <lambdawar> e.g. ?
00:19:26 <lambdawar> I take it as an insult
00:19:34 <Oejet> Just the last sentence. :-)
00:19:57 <lambdawar> ski, am I clear or should I give a concrete example ?
00:21:06 <Oejet> I missed everything but the last sentence, and out of context it sounded a bit management like.
00:22:19 <lambdawar> it has nothing to do with management
00:24:14 <lambdawar> ski, for instance, consider the first code bloc of a function, it can be called by othe function using a call instruction, or it can be called from within the function using a branch/jmp instruction
00:24:30 <lambdawar> so the way the environment is lifted in both cases is different
00:24:40 <lambdawar> if you reason in backward analysis.
00:24:52 <lambdawar> the problem does not arise in forward analysis
00:26:03 <lambdawar> similary, the code bloc starting at the return address of a function can be called from a ret instruction, or from a branch instruction if the function call was in a condition that was not taken
00:26:13 <lambdawar> if (cond) func(); otherthing;
00:27:06 <lambdawar> backward analysis for the bloc where "otherthing" stands, typically could represent the problem
00:27:44 <lambdawar> at least in machine programs, I have it atm.
00:29:42 <lambdawar> I guess other constructions of code make it appear as well
00:30:16 <lambdawar> Im sorry if I dont provide an example in haskell
00:30:31 <lambdawar> maybe the haskell grammar forbids this
00:31:40 <Oejet> Lemmih: Hello.
00:31:44 <Lemmih> Hiya.
00:35:09 <snowzz> hello, im trying to run gtk2hs demos but it doesnt work for me.
00:35:16 <snowzz> this shows up: /usr/bin/ld: cannot find -lXrandr
00:36:11 <snowzz> did i miss something?
00:37:38 <snowzz> i get undefined references everywhere when i do a -v on ghc
00:37:55 <snowzz> but i got gtk2hs to build from the debs
00:37:57 <snowzz> anyone?
00:39:51 <Itkovian> hmm
00:40:28 <Itkovian> -lXrandr seems to indicate that you need libXrandr.a somewhere
00:41:02 <Itkovian> if you've only got libXrandr.so.x, you might try to replace -lXrandr with /PATH/libXrandr.so.x
00:41:06 <Itkovian> gotta run.
00:41:20 <snowzz> Itkovian, thanks, will do that =)
01:23:56 * Speck read something interesting on some slides Sheard made about GADTs in Omega -- "typed self-describing databases" using GADTs?
01:24:16 <Speck> I'd like to see the code behind that
01:54:13 <shapr> skew: oh you're doing TaPL in Haskell?!
02:02:24 <skew> shapr: sure! I was reading Daan's recent papers on MLF and records
02:02:36 <araujo> Good morning!
02:02:39 <xerox> @wtf MLF
02:02:41 <lambdabot> No match for "MLF".
02:02:53 <sieni> wtf <3<3<3
02:03:01 <skew> I was trying to figure out how to combine his scoped labels and first class labels.
02:04:02 <xerox> sieni: cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix
02:06:48 <skew> After a while I sort of decided that the scoped label stuff isn't much good in the context of first class labels, because the most interesting examples of first class lables required row equality predicates, and a big point of scoped labels was to avoid qualified types entirely
02:09:42 <skew> shapr: I think autrijus also did TaPL in Haskell
02:10:08 <skew> autrijus has already done TaPL in Haskell, I mean. Isn't that how Pugs got started?
02:16:32 <xerox> Yup.
02:17:40 <shapr> skew: You have sources?
02:17:56 * shapr wants 0-d4y w4r3z
02:18:04 <skew> sources?
02:18:21 <shapr> I want to see your TaPL in Haskell sources.
02:18:26 <araujo> Hello shapr
02:18:42 <araujo> shapr, may i privmsg you?
02:18:44 <shapr> I'd like to make them available on a TaPL wiki.
02:18:50 <shapr> araujo: The answer is yes, but you have to give me an url.
02:18:58 <shapr> araujo: That is, the answer to your question.
02:19:08 <araujo> 0_0
02:19:29 <shapr> You're going to ask me if I can host your Haskell shell, right?
02:19:30 <xerox> shapr: radar!  Now ask me the right question.
02:19:40 <araujo> shapr, Thanks!
02:20:10 <shapr> xerox: When will you add fractals to Nymphaea?
02:20:30 <shapr> xerox: What's the generalization of L-Systems and Fractals?
02:20:38 <skew> I'm looking through "not a number", and thinking about how to implement unification
02:20:38 <xerox> IFS-es
02:20:56 <xerox> That is, Iterated Fractal System.  I'm working on them.
02:21:43 <shapr> Are there other little knows classes of IFSs?
02:22:10 <shapr> If IFS is the superset of Fractals and L-Systems, what are other visually pleasing subsets?
02:22:42 <reddi> can i write ordered pairs like (k,s)|k<-expression,s<-expression2)
02:22:51 <reddi> haskell dont likes my |
02:22:53 <xerox> Symbolic Dynamical Systems, Discrete-time Systems, Continuous-time Systems, Fractal-long-term systems.
02:23:15 <xerox> reddi: [(k,s) | k <- .., s <- ..]
02:23:38 <xerox> I don't know if they're visually pleasant, though.  I'm reading up on them these days :-)
02:23:44 <reddi> can i convert [] ->()?
02:23:54 <xerox> [] makes lists, () tuples.  So, not.
02:24:09 <reddi> if [] has the same cardinality of ()?
02:24:12 <xerox> It's not completely true that () makes tuples, but..
02:24:19 <xerox> reddi: what do you mean?
02:24:33 <reddi> what is if [] has the same number of elements like ()?
02:24:48 <araujo> They are still different types.
02:24:51 <xerox> Right.
02:25:03 <reddi> then i can throw away my algorithm ;-(
02:25:31 <reddi> is there a similar thing like [11:23] xerox: reddi: [(k,s) | k <- .., s <- ..] for lists?
02:25:36 <reddi> ups tuples
02:26:22 <xerox> They're called *list* comprehensions :-|
02:26:45 <shapr> reddi: Tuples aren't sequences, they're types.
02:26:54 <shapr> reddi: You could do it with Template Haskell though.
02:27:10 <shapr> xerox: Ok, now ask me the right question.
02:28:17 <skew> xerox: MLF is an impredicative higher-ranked type (inference) system
02:28:42 <xerox> shapr: are our margins near to become full of notes?
02:29:21 <skew> the rule is that you need to annotate function arguments that are used at more than one type, and if you do that, then everything else can be inferred
02:31:31 <shapr> xerox: Heh, yes :-)
02:31:48 <xerox> Ah-ha! :-D
02:32:20 <shapr> hei cooz
02:32:49 <cooz> hei
02:32:53 <shapr> Wassup?
02:32:59 <shapr> cooz: Is Erno ever going to show up here?
02:33:20 <xerox> Is it possible to create typeclasses' instances at runtime?
02:33:32 <shapr> You could run your app in the compile phase of TH.
02:33:48 * xerox is scared
02:35:04 <skew> how is ghc-api and hs-plugins doing at making Haskell a runtime-flexible language?
02:36:04 <cooz> shapr: Nothing special. I don't about erno, i told your greetings via irc, and I belive he noticed that, but now I'm not sure..
02:36:25 <shapr> cooz: I can send him email.
02:37:12 <cooz> and I can say him again tommorrow. irl this time :)
02:37:18 <shapr> heh, ok :-)
02:37:53 <reddi> why cant i use intersect?
02:37:58 <reddi> do i have to import something?
02:38:03 <shapr> @index intersect
02:38:04 <lambdabot> Data.List, Data.Set
02:38:16 <shapr> Looks like you need to import one of those.
02:40:26 <reddi> when i dont write a file
02:40:49 <shapr> ?
02:40:50 <reddi> i only want to test it out on command line ... how do i perform that?
02:40:54 <reddi> with import
02:41:11 <reddi> Prelude> import Data.Set
02:41:11 <reddi> ERROR - Syntax error in expression (unexpected keyword "import")
02:41:18 <shapr> oh, :m + Data.Set
02:42:25 <reddi> what is m?
02:42:28 <xerox> :module
02:42:29 <shapr> :module
02:42:32 <shapr> :-)
02:42:35 <xerox> (-:
02:42:53 <xerox> Like those two strange characters in Alice...
02:42:58 <reddi> Prelude> :module Data.Set
02:42:58 <reddi> ERROR - Cannot find module "Data.Set"
02:42:59 <reddi> e.g.?
02:43:07 <xerox> reddi: try :help
02:43:18 <shapr> hiya malcolm_
02:43:18 <xerox> But.. it seems you're using Hugs.
02:43:29 <xerox> reddi: where you have to do :also Data.Set if I remember correctly.
02:43:31 * malcolm_ waves
02:44:20 <xs> is there a way to make IO (Maybe a) computations chain together nicely?
02:44:32 <xerox> @type sequence_
02:44:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
02:44:43 <xerox> Hmm.
02:44:55 <xerox> ?
02:45:25 <reddi> yes i am using hugs... what do u mean with [11:43] xerox: reddi: where you have to do :also Data.Set if I remember correctly.
02:45:25 <reddi> [11:43] * malcolm_ waves
02:45:27 <xs> hm. i mean, i have a :: IO (Maybe a), b :: a -> IO (Maybe c), i want to feed a into b?
02:45:36 <xerox> reddi: try ":also Data.Set"
02:45:51 <reddi> i see, thx
02:45:58 <xerox> You're welcome.
02:46:06 <reddi> additional module ;-)
02:46:22 <wilx> xs, a >>= b?
02:46:37 <wilx> @type >>=
02:46:38 <lambdabot> parse error on input `>>='
02:46:44 <wilx> @type (>>=)
02:46:45 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
02:46:45 <xerox> do foo <- fromJust `fmap` a
02:46:45 <xerox>    bar <- fromJust `fmap` (b foo)
02:46:45 <xerox>    print bar
02:46:49 <xerox> xs something like that.
02:46:56 <wilx> Oh.
02:46:58 <wilx> Ah, I see.
02:47:14 <xs> hmm. ick.
02:47:39 <xerox> Maybe has a Monad instance, so maybe...
02:48:11 <xs> seems strange that you cannot a >>= b in some way, given that IO and Maybe are monads (and i want them to act that way..)
02:48:11 <xerox> Nah, I think I would do it that way.  Anyone has other thoughts?
02:48:32 <musasabi> A monad transformer
02:48:39 <xerox> Bling.
02:48:55 <xs> how?
02:49:11 <xerox> MaybeT IO a
02:49:17 <xerox> @kind MaybeT
02:49:18 <lambdabot> Not in scope: type constructor or class `MaybeT'
02:49:22 <xerox> Hm..
02:49:29 <shapr> Oh, extra spiffy blog post - http://nat.truemesh.com/archives/000555.html
02:49:50 <reddi> can i use an invertation in intersect or is that a problem with close world assumption in haskell? [e.g.: intersect [2,3,45] ![1]]
02:50:29 <xs> oh, pugs has one. great! thanks xerox and musasabi :)
02:50:38 <xerox> xs: you're welcome :-)
02:50:38 <musasabi> There is no MaybeT - but you can use ErrorT or define MaybeT
02:50:48 <xerox> xs: tell us the solution afterwards :-)
02:51:26 <xs> okiedokie :)
02:54:51 <malcolm_> shapr: scrapheap challenge programming sounds fun
02:57:24 * xerox hops
02:58:21 <shapr> malcolm_: Yes, especially the lessons learned.
02:58:45 <Speck> I'm looking for a practical introduction to GADTs -- any pointers?
02:59:13 <malcolm_> I think I generally agree, if the goal is to get something done quickly.  Apart from dynamic vs static typing, and maybe loosely structured data.
02:59:17 <shapr> This post also supports my idea that Code as Communication is important for Speed of Change.
02:59:33 <xerox> @kind ErrorT
02:59:34 <lambdabot> Not in scope: type constructor or class `ErrorT'
02:59:37 <malcolm_> The most important thing is cut-n-paste from examples, yes.
02:59:45 <shapr> I think there are some support for monads ideas in that blog post. Monads are like Unix shell pipes++
03:00:18 <shapr> I suspect their idea of static typing means C or Java
03:00:24 <shapr> hiya Calister! ltns!
03:00:25 <joelr> howdy
03:00:32 <Calister> heya shapr :D
03:00:34 <Calister> indeed
03:00:35 <shapr> hey joelr, how're the threads?
03:00:41 <joelr> do you you attach a string to a finalizer?
03:00:48 * shapr gets out the tape
03:00:51 <malcolm_> Yeah, when people complain about static typing it is usually a crippled monomorphic type system that is the real problem...
03:00:55 <Calister> its been a stressful last term.. and this one seems to be even worse
03:01:03 <joelr> shapr: no progress, gotta run stuff on windows now and profile it there
03:01:22 <shapr> malcolm_: Yup, I seriously doubt that type inferencing was used in the scrapheap challenge.
03:01:30 <shapr> Maybe we should make a team for next year.
03:02:07 <shapr> I think that type inferencing and dependent types are black magic to most programmers.
03:02:30 <shapr> Calister: Have you had any time to write code?
03:02:56 <Calister> shapr.. only java last term.. but this term i gotta code in java and haskell
03:03:09 <skew> do you have a link for this scrapheap stuff?
03:03:11 <shapr> Yay Haskell!
03:03:15 <Calister> lol
03:03:20 <shapr> skew: http://nat.truemesh.com/archives/000555.html
03:03:23 <Calister> im still pretty lost when it comes to haskell
03:03:37 <shapr> Don't worry, the magic will find you.
03:04:05 <Calister> it gotta search harder and quicker then!
03:04:11 * shapr grins
03:04:15 <Calister> ;d
03:04:47 <shapr> Calister: Do you know castaway?
03:05:27 <Calister> shapr: nopie
03:05:57 <shapr> Seems like the kind of person you'd enjoy talking to.
03:06:19 <Calister> ;o
03:06:34 <Calister> someone who wasnt found by the magic by now either?
03:06:49 <shapr> Er, I dunno about that, just seems like someone you'd enjoy talking to.
03:07:09 <Calister> ^_^
03:07:51 <xerox> Howdy xah.
03:09:02 <xah> xerox: g m xerox. my eyes are a slit.
03:09:31 <shapr> Too much sand blowing?
03:09:40 * shapr is confused
03:09:45 <Calister> okay.. prolly extreme stupid question.. but in a class the prof had written in some code "data StandardQueue t = Srep[t]"
03:09:50 <xerox> @babel en it slit
03:09:52 <lambdabot>  fessura
03:09:55 <Calister> what means what in there exactly?
03:09:58 <xerox> D'oh.  Poor xah.
03:10:05 <Calister> ello xah
03:10:14 <shapr> Calister: The square brackets [] mean a list.
03:10:26 <Calister> so Srep is simply a name for a list?
03:10:31 <xah> just woke up, my eyes can't open fully yet.
03:10:32 <xerox> Calister: data <TypeConstructor> <type parameters> = <DataConstructor> <params>
03:10:37 <shapr> Calister: And the the "data StandardQueue t" means that the list will be of type t
03:10:55 <xah> but 'm hugging haskell first.
03:11:09 * shapr hugs the Haskell effigy
03:11:21 * xerox takes a pic of shapr and the effigy in love
03:11:24 <xerox> Ah!
03:11:26 * Calister sits and ponders
03:11:29 * shapr hugs lambdabot
03:11:41 <shapr> @wiki HaskellDemo check this out, Calister.
03:11:41 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo check this out, Calister.
03:12:00 <xerox> shapr: do you think it should cut that out to the first word?
03:12:15 <shapr> I dunno
03:12:21 <shapr> I'd actually prefer an inline command syntax.
03:12:27 <shapr> Then I could say:
03:12:31 <xerox> Yeah, ala ,,fsbot.
03:12:35 <shapr> Calister: see @@wiki HaskellDemo for examples.
03:12:47 <xerox> @wiki HaskellDemo@
03:12:48 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo@
03:12:52 <xerox> Maybe?
03:13:01 <shapr> I dunno, what do you think?
03:13:02 <Calister> i always again find it difficult to understand haskell in english.. its generally hard for me to understand.. and then in english its even harder ^_^;
03:13:03 <xerox> But if one says an email address..
03:13:18 <xerox> Maybe we could import the ,, directly?
03:13:20 <shapr> Calister: Spreichen sie Deutsch?
03:13:30 <Calister> exactly ^_^
03:13:33 <shapr> xerox: Yeah, we could change the syntax to use comma.
03:13:40 <shapr> But @ is less often used.
03:13:41 <Calister> shapr: german is my mother tongue
03:13:55 <shapr> I know :-)
03:13:58 <xerox> shapr: but I think "foo ,,wiki HaskellDemo bar baz" will still use bar baz for the ,,wiki command.
03:14:00 <shapr> I don't know if there's a #haskell.de though.
03:14:08 <xerox> There is!  Basti_ opened it.
03:14:12 <skew> Ich kan ein bisschen Desutsch.
03:14:16 <Calister> basti_ is usually my haskell.de
03:14:29 <Calister> ^_^
03:14:45 <xerox> Maybe there should be a way, ala prolog, to tell how many params a function/1 should take.
03:15:20 <shapr> I don't know.
03:16:20 <skew> xerox: is that supposed to be syntax on the ,?
03:17:39 <Calister> May i mention that i still hate homework?
03:17:51 <shapr> It depends on the homework for me.
03:17:52 <xerox> skew: mmh?
03:18:33 <skew> why is that ,,wiki?
03:18:42 <skew> I'm thinking something like lisp reader macros here
03:18:49 <Calister> shapr: i will have to write an interface for umm.. well its bout memory.. allocate and deallocate
03:19:05 <Calister> and im somewhat confused and lost
03:19:13 <Calister> and i HATE being lost and feeling stupid
03:20:39 <shapr> My approach is to erode away the frontiers of my knowledge.
03:20:52 <shapr> I learn a little piece at a time, and make sure I understand those new pieces thoroughly.
03:21:04 <shapr> Then I know I'll never be lost again when looking at that idea.
03:21:30 <Calister> i wish i'd have the time for it ^_^ but i doubt my prof will wait for my answers till i really understood all
03:23:03 <xerox> Records on newtypes can only have 1 field?
03:24:22 <shapr> Calister: Well, learn what you can, and then you won't be lost!
03:25:21 <skew> xerox: that makes sense - newtypes are just a new name for an old type
03:25:41 <xerox> Yes :-|
03:26:03 <skew> the reason data is distinct from newtype is because newtypes can be totally erased at runtime
03:27:16 <Calister> shapr: im trying :) okay.. still not 100% sure i got it. so "data StandardQueue t" means that the list will be of type t... and what exactly is the "StandardQueue" doing in there? what is exactly meant with "typeconstructor"?
03:27:37 <shapr> Did you read the HaskellDemo? Did you see the part about Seasons?
03:28:13 <Calister> yep
03:28:15 <Calister> oh
03:28:18 <Calister> so its the name?
03:28:22 <Calister> *sorta*
03:29:03 <shapr> You saw that data Seasons = Winter | Summer | Spring | Fall
03:29:14 * Calister nods
03:29:24 <Calister> (i have seen something similar with colours yesterday)
03:29:51 <shapr> A concrete StandardQueue would be "data StandardQueue = Srep [Int]"
03:30:19 <shapr> You can get that same type from the code "Srep [1,2] :: StandardQueue Int"
03:30:59 <Calister> and the t is there cuz its a polymorph type?
03:31:03 <shapr> You got it.
03:31:13 <Calister> phew lol
03:31:28 <Calister> that was a hard one
03:38:17 <Calister> so if i want to make a datatype called FlMemory and its supposed to be a list of int tupels, would it be "data FlMemory = Frep [(Int,Int)]" ?
03:38:47 <Calister> (yep, on purpose not polymorph)
03:39:09 <skew> ok, chapter 11 down...
03:40:22 <shapr> skew: ?
03:40:41 <skew> simply typed lambda calculus
03:40:54 <shapr> Are you implementing these, or reading them?
03:40:59 <skew> augmented with booleans and conditionals because a simply typed lambda calculus is pointless without ground types
03:41:02 <skew> implementing
03:41:22 <shapr> I want to see!
03:41:36 <shapr> Do you have a darcs repo online?
03:41:39 <skew> no
03:41:50 <shapr> I'd be happy to host a darcs repo :-)
03:42:00 * shapr selfishly wants knowledge!
03:42:12 <skew> next time somebody knocks strong typing, ask them to implement the same after ingesting one margarita per 20kg body mass!
03:42:17 * Calister points up.. can anyone tell me if that was semiright at least XD
03:42:45 <shapr> Calister: You don't need an explicit param there, you can just use data FlMemory = Frep [(Int,Int)]
03:43:01 <shapr> Calister: The best way to find out if your ideas work is to throw them into a file and load it into GHCi.
03:43:21 <shapr> If you use emacs and haskell-mode you can do that with C-c C-l in the Haskell buffer.
03:43:48 <Calister> atm im still working with hugs ^_^
03:43:56 <shapr> Ok, try it there.
03:44:06 <Calister> but you know.. shocking enough.. with haskell i started to code on paper first
03:44:38 <Calister> its weird. and sort of disgusting.. but i really like coding with haskell on paper
03:45:01 <xerox> It's none of them, it's just good sign, imo :)
03:45:43 <Calister> xerox: you sure? XD most of my friends at university call me already a pervert for just thinking higher of haskell than of java lol
03:46:10 <xerox> At the Mandelbrot conference, paolino showed me a notebook sheet full of haskell code to proof-check, hehe.
03:46:17 <skew> pad	"SQL, Lisp, and Haskell are the only programming languages that I've seen where one spends more time thinking than typing."
03:46:20 <skew> - Philip Greenspun
03:46:32 <skew> Calister: I've found paper is good for thinking
03:46:45 <Calister> ^_^
03:46:59 <xerox> In fact I'm a bit lost without the computer.  I mean, I like asking GHC for check what I thought :)
03:47:00 <Calister> too bad my first prof teaching the basic was horrible bad with haskell
03:47:22 <Calister> some day i should get used to GHC
03:47:35 <skew> what's the problem with GHC?
03:47:44 <skew> GHCi is nicer than what I remember of hugs
03:47:48 <Calister> its not installed on my notebook ^___^
03:47:56 <skew> the :d directive from morrow would be nice, but that's about all that's missing
03:48:16 <skew> :d looks up the definition of the value you give it
03:48:20 <vegai> skew: I haven't figured out yet if that's a good thing (regarding Philip's quote)
03:48:28 <Calister> i dunno.. in beginning i chose hugs and so i stayed with it
03:48:46 <ndm> are you on windows or linux?
03:49:03 <Calister> on windows
03:49:09 <ndm> try the new version of winhugs!
03:49:24 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/winhugs.php
03:49:32 <ndm> its really nice :)
03:49:46 * Calister scribbles down the url.. i will download it on monday in university ^_^
03:49:54 <skew> can you make bindings for your session with let or <-?
03:49:55 <ndm> and has features that speed up productivity massively, that are not available on GHCi
03:50:01 <ndm> skew, no
03:50:03 <skew> the last time I looked at hugs I couldn't
03:50:05 <skew> which really sucks
03:50:08 <ndm> (i don't think...)
03:50:18 * xerox chews a liquorice stick
03:50:33 <ndm> but when you have an error, it gives you a hyperlink which will jump to that position in the source code
03:50:34 <skew> I can define some convenience function with let, or pull text out of a file with <- readFile, and work on it for a bit
03:50:49 <skew> error while loading a file?
03:51:09 <ndm> you type in: f x = [x
03:51:12 <skew> ghc(i) is good about line numbers and character offsets
03:51:23 <ndm> hugs makes a hyperlink, you click, you jump
03:51:34 <skew> I hate mice - I run ion, etc.
03:51:34 <ndm> so you don't need to worry about the line number, char pos etc.
03:51:38 <ndm> (although its there)
03:51:50 <ndm> you're probably not the target audience :)
03:51:51 <skew> still, kind of nice
03:52:02 <xerox> With emacs + haskell-mode it's automatic.
03:52:03 <ndm> in development, its a massive time saver i've found
03:52:09 <skew> If I could fine the inf-haskell mode for emacs, it should to the smae
03:52:37 <xerox> skew: eh?! :D
03:53:23 <skew> well, I've got the haskell-mode package for debian, which was supposed to come with some kind of inferior ghci thing
03:53:41 <xerox> YEs.
03:53:52 <xerox> Visit a .hs file, and type C-c C-l
03:54:20 <skew> oh, nice. Ok, how do I jump to the errors?
03:54:25 <xerox> Do an error :-)
03:54:41 <skew> got that
03:54:50 <xerox> :-)
03:54:54 <skew> ghci buffer has  anice error message, with a line number in it
03:55:01 <xerox> Exactly.
03:55:06 * Calister puts on her thinking cap again and tries to get her homework solved.. at least a part of it ^_^
03:57:36 <skew> xerox: but it's not linked back to the buffer like compilation output is
03:58:19 <dcoutts> @seen gour
03:58:19 <lambdabot> I saw gour leaving #haskell 4 hours, 41 minutes and 17 seconds ago.
03:58:21 <dcoutts> @seen goron
03:58:22 <lambdabot> I saw goron leaving #haskell 16 hours, 39 minutes and 52 seconds ago.
03:59:41 <xerox> skew: what do you mean?
04:01:16 <skew> xerox: if you run M-x compile, then pressing enter on the line of a compilation error in the output buffer takes you to the corresponding line in the source file
04:01:33 <xerox> skew: it does the same here for C-c C-l
04:01:57 <xerox> Maybe debian's haskell-mode is not 2.00 ?
04:01:57 <skew> hmm, if I hit enter it tries to run the line as a command to ghci
04:02:10 <xerox> Hmm no, sorry.
04:02:45 <xerox> If you are visiting a .hs file, and press C-c C-l, getting an interpretation error, the point is put at the line:column of the error.
04:03:08 <skew> hmm, possibly
04:03:18 <skew> I realized I've only got 6.2.2, which just has line numbers
04:03:37 <skew> it does seem to move point to the line of the error
04:03:40 <xerox> I never used M-x compile in fact...
04:04:06 <shapr> I use it all the time.
04:04:22 <shapr> Have you seen my one-button unit testing with haskell-mode ?
04:04:57 <xerox> Unfortunately haskell-mode-2.0 seem to have a the haskell-version variable set as "1.43" so we can't debug it that way.
04:05:12 <xerox> shapr: I recall I heard of it.  What does it do?  I never use unit testing :-|
04:05:39 <shapr> @wiki HaskellMode
04:05:39 <lambdabot> http://www.haskell.org/hawiki/HaskellMode
04:05:55 <xerox> Woot.
04:06:04 <xerox> This will be a very nice speed up.
04:07:42 <xerox> Those keybindings doesn't seem to work.
04:08:45 <shapr> xerox: (global-set-key [f12] 'compile)
04:10:06 <shapr> xerox: Which bindings don't work?
04:10:14 <xerox> The first ones.
04:12:45 <shapr> I dunno what happened to fume, but C-c C-= is the new binding for the second one.
04:12:48 * shapr updates the wiki page.
04:15:10 <xerox> They're C-c C-blah
04:15:11 <reddi> is there a way to subtract two lists? i only found delete which can only delete ONE element
04:15:15 <xerox> Not just C-c blah
04:15:18 <xerox> Okau, cool.
04:15:21 <xerox> Later, lunch!
04:15:49 <Calister> cya xerox
04:16:15 <reddi> eg. fctname  [6,8] [2,4,6,8,10] == [2,4,10]
04:16:22 <reddi> do i have to create that by myself?
04:16:27 <reddi> or is there a function which does that?
04:16:33 <shapr> There's a function.
04:16:42 <reddi> and what is her name?
04:16:46 <shapr> Look through the contents listing of Data.List, lotsa good stuff there.
04:16:54 <shapr> @docs Data.List
04:16:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
04:17:03 <reddi> hm i am already there
04:18:09 <Calister> shapr: got a good page bout tuples and lists and how to handle tuple lists?
04:18:57 <fworp> @type (\\)
04:18:58 <lambdabot> Not in scope: `\\'
04:19:03 <fworp> doh
04:19:25 <fworp> @type Data.List.(\\)
04:19:26 <lambdabot>   Failed to load interface for `Data':
04:19:26 <lambdabot>    Could not find module `Data':
04:19:33 <fworp> ook
04:20:25 <ndm> @hoogle \\
04:20:25 <lambdabot> Data.IntMap.(\\) :: IntMap a -> IntMap b -> IntMap a
04:20:25 <lambdabot> Data.IntSet.(\\) :: IntSet -> IntSet -> IntSet
04:20:25 <lambdabot> Data.List.(\\) :: Eq a => [a] -> [a] -> [a]
04:20:50 <fworp> ah
04:23:45 <yozora> @eval Data.List.(\\) [6,8] [2,4,6,8,10]
04:23:46 <lambdabot>  Not in scope: data constructor `Data.List'
04:23:58 <yozora> [6,8] \\ [2,4,6,8,10]
04:24:01 <yozora> @eval [6,8] \\ [2,4,6,8,10]
04:24:02 <lambdabot> []
04:24:15 <yozora> @eval [2,4,6,8,10] \\ [6,8]
04:24:16 <lambdabot> [2,4,10]
04:24:23 <shapr> hoi twanvl, learning Haskell?
04:24:47 <shapr> Guess not.
04:25:45 <yozora> @fact lambdabot
04:25:45 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
04:25:53 <yozora> @fact liqui
04:25:54 <lambdabot> I know nothing about liqui
04:26:43 <Calister> okay.. i made my data FlMemory but somehow i am stuck. how do i handle list of tuples correctly? i want to get the first element of the list.. aka the first tuple. how do i get it without getting myself a type error etc?
04:27:12 <yozora> @eval head [(1,2), (3,4), (5,6)]
04:27:13 <lambdabot> (1,2)
04:27:28 <yozora> is that what you're after?
04:27:34 <Calister> woups
04:27:40 <Calister> i hope it is ^_^
04:27:42 <Calister> thanks
04:28:08 <yozora> np
04:29:11 <Calister> hmm... and how do i get the two elements outta the tupel? if i wanna do with (1,2) => 2-1.. the first i would get with head and the second one? with last?
04:29:19 <Calister> but aint last only for lists?
04:29:54 <skew> fst/snd take apart pairs
04:30:07 <Calister> thanks :)
04:30:14 <skew> or just pattern match: \(x,y) -> x-y
04:30:20 <yozora> @eval (fst . head) [(x,y) | x<-[1..3] | y<-[3..5]]
04:30:21 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
04:30:23 <skew> also, uncurry f (x,y) = f x u
04:30:31 <skew> so you could use uncurry (-) if you want...
04:30:46 <skew> maybe a bit obscure
04:31:16 <Calister> for the beginning i need it as easy as possible for my brain
04:31:29 <Calister> its already about to make an emergency shut down
04:33:48 <astrolabe> Is there an integer division?   ie 5/2 = 2?
04:33:57 <fworp> div
04:34:04 <astrolabe> thanks :)
04:34:07 <fworp> @type div
04:34:08 <lambdabot> forall a. (Integral a) => a -> a -> a
04:34:19 <fworp> scary.
04:34:22 <astrolabe> @eval div 5 2
04:34:23 <lambdabot> 2
04:34:33 <astrolabe> cooo
04:38:07 <fworp> so does that type signature mean that a could represent different instances of Integral for each time its shown? like, maybe it could be Int -> Integer -> Integer?
04:38:31 <Igloo> aleator__: Yes?
04:39:18 <ndm> fworp: no
04:39:31 <ibid> fworp: the a is the same type in all three
04:39:33 <ndm> pick one a, it must be an integral
04:39:58 <ibid> fworp: what it means that the a can mean any integral type you choose, but once you choose, you must use the same type in all three
04:40:08 <ibid> ie. Int -> Int -> Int or Integer -> Integer -> Integer
04:40:09 <fworp> ibid; but what does the foral get you?
04:40:13 <fworp> forall*
04:40:21 <ibid> fworp: it's something you can ignore at this level
04:40:45 <fworp> at what level does it start to matter then?
04:40:48 <ibid> fworp: it's a technicality of the type system, as long as you're not doing existential typing, which you probably wont
04:40:51 <ibid> *won't
04:41:12 <fworp> ibid: i might, if i understood it though :P
04:41:21 <yozora> @type \x y -> toIntegral ((fromIntegral x) + (fromIntegral y))
04:41:22 <lambdabot> Not in scope: `toIntegral'
04:41:40 <yozora> @type \x y -> (fromIntegral x) + (fromIntegral y)
04:41:41 <lambdabot> forall a b a1. (Integral a, Num b, Integral a1) => a -> a1 -> b
04:42:25 <ibid> fworp: the forall basically means that the type variable in question is local to that type signature
04:45:55 <fworp> hm. and when are they not?
04:48:17 <amiddelk> fworp: suppose you have af function f :: a -> a. That's the same as writing f :: forall a . a -> a. So, in Haskell you don't see them, but...
04:49:28 <ibid> fworp: in haskell, the forall is usually implicit
04:49:40 <amiddelk> fworp: there is a difference between: f :: (a -> a) -> Int  (= forall a . (a -> a) -> Int)   and f :: (forall a . a -> a) -> Int      (higher ranked polymorphism)
04:49:50 <ibid> fworp: that's why i said you can ignore it
04:50:28 <amiddelk> fworp: so, as long as you don't have to know that, you can ignore it
04:50:38 <Calister> bleh
04:50:40 <ibid> fworp: as to when it's not, for example here: f x = g x where g = id, g's type is a -> a, but the a is *not* local to the type signature
04:50:54 <Calister> im completely lost again and even more confused in beginning
04:50:59 <ibid> fworp: because it is x's type in the toplevel function
04:51:14 <ibid> fworp: unfortu
04:51:57 <ibid> hmm, better example:
04:52:01 <ibid> f x = g where g = x
04:52:14 <ibid> g's type is a, which is not local to the (implicit) type signature
04:53:31 <joelr> gents, how do i print a string when a finalizer is triggered?
04:53:41 <astrolabe> There should be a standard function to construct Arrays from the bounds and a function giving values.
04:53:58 <ibid> joelr: why would you want to do that?
04:54:07 <skew> astrolabe: there is, more or less
04:54:15 <astrolabe> skew ?
04:54:22 <joelr> ibid: see the last couple of messages on haskell-cafe :-)
04:54:31 <joelr> ibid: i'm running out of memory on windows
04:54:40 <joelr> ibid: but not on the mac
04:54:42 <ibid> joelr: try Debug.Trace?
04:54:58 <joelr> ibid: trace where exactly?
04:55:32 <skew> between range and array, you can do that
04:55:46 <ibid> joelr: in the finalizer?
04:55:56 <franka> Hello.
04:56:01 <ibid> joelr: you wanted to get some signal out when it fired?
04:56:04 <astrolabe> skew: Ah, I see what you mean.  But I'm always repeating the same structure, and repitition is bad.
04:56:09 <franka> I have a question about -fallow-undecidable-instances.
04:56:20 <joelr> ibid: i don't install the finalizers myself, i'm using the FastPackedString library
04:56:51 <astrolabe> skew:  I think I'll right AstrolabesPrelude :)
04:56:56 <astrolabe> *wright
04:57:02 <skew> so let build f (low,up) = array (low,up) [(i,f i) | i <- range (low,up)]
04:57:11 <joelr> ibid: david roundy suggested attaching a print mesage to the finalizer so i thought there is a magic way of doing that to existing finalizers
04:57:17 <astrolabe> skew: exactly
04:57:18 <franka> I have a function which gives a type error when not supplied a signature; with a signature, no error occurs.  Is this to be expected with undecidable instances?
04:58:11 <ibid> joelr: ah, your question didn't reveal that. no idea.
04:58:20 <franka> The error I get is "missing instance".
05:00:08 <franka> Am I invisible or does no one have a clue about my question?
05:00:31 <astrolabe> I don't have a clue
05:00:38 <franka> OK, thanks.
05:01:13 <skew> Foreign.Concurrent let's you attach IO actions as finalizers to ForeignPtr s
05:01:21 <shapr> hiya franka
05:01:24 * shapr returns from shopping
05:01:28 <malcolm_> joelr: Foreign.addForeignFinalizer
05:01:28 <franka> Hello, shapr.
05:01:35 <Calister> wb
05:01:57 <xerox> @fact shapr
05:01:57 <lambdabot> I know nothing about shapr
05:02:03 <joelr> malcolm_: yes, i'm looking at that. i think addForeignPtrConcFinalizer is even more suitable
05:02:10 <shapr> franka: I'm not surprised by the error, but I don't have formal understandings to back it up.3
05:02:20 <franka> Thanks, shapr.
05:02:46 <joelr> malcolm_: the thing is that FPS hides the constructor
05:02:50 <shapr> franka: But if you describe how they overlap, I might be able to help.
05:02:50 <franka> I'm not surprised by it either, frankly.
05:02:58 <joelr> i guess i'll need to compile myself a special version
05:03:03 <franka> How what overlap?
05:03:23 <shapr> Er, how your instances are undecidable :-)
05:03:33 * shapr is sick today, brain working at 12% capacity.
05:03:47 <franka> I'm not using -fallow-overlapping-instances.
05:04:02 <franka> They're undecidable because the contexts include non-type-variables.
05:04:43 <franka> Well, "undecidable" in quotes; I happen to know reduction should converge.
05:06:15 <skew> Oh, then I'll guess that a polymorphic type would be inferred without the type annotation
05:06:51 <franka> Hm.
05:06:57 <skew> and polymorphic types can't be instances of type classes
05:07:44 <franka> You mean something like C (forall a. b) ?
05:08:29 <skew> yeah, that doesn't work
05:08:39 <franka> I don't have anything like that.
05:09:12 <franka> However, it might be related to the polymorphism.
05:09:29 <franka> My signature is (Norm a One c) => a -> c.
05:10:16 <skew> you don't have instances with foralls in the head, but if you want to come up with C a and a happens to be inferred as a polymorphic type, then you are out of luck
05:10:18 <franka> Which is kind of a funny type.  And underspecified.
05:10:50 <franka> Hm.
05:13:02 <skew> good night.
05:14:06 <franka> Get well, shapr.
05:14:56 <fworp> ibid: ok, i was probably thinking of locallity allot different than it was meant. so i guess ill ask the opposite question: when 'is' a type variable local to the signiature? something like, say foo :: (forall a. (Show a) => a) -> Bar? (not sure thats even a valid type signiature)
05:15:34 <ibid> fworp: not in that example
05:15:40 <xerox> fworp: it is if you enable -fglasgow-exts (universally quantified types?  or is it qualified?)
05:17:14 <shapr> franka: thanks, I'll do my best.
05:20:53 <Techniks> any prologgers in here?
05:21:43 <shapr> Tried #prolog ?
05:21:52 <Techniks> lots of idle ppl in there hehe
05:22:21 <xerox> prolog, woot.
05:22:27 <Calister> what is haskell trying to tell me with "type error in instance member binding"?
05:22:45 <xerox> @ghc
05:22:46 <lambdabot>  Illegal unboxed tuple type as function argument
05:23:27 <xerox> Calister: what does the line look like?
05:24:20 <Calister> it seems to be the "allocate((Frep x), c)"
05:24:33 <Calister> okay, from beginning...
05:24:42 <xerox> Which is equal to: allocate (Frep x, c)
05:24:42 <Calister> class Memory m where
05:24:58 <Calister> oh my god
05:25:00 <Calister> one moment
05:25:02 <Calister> i just got an idea
05:25:06 <xerox> Bling.
05:25:27 <Calister> nope
05:25:28 <Calister> okay
05:25:35 <Calister> didnt help it
05:25:48 <Calister> class Memory m where
05:26:18 <Calister>   allocate :: m -> Int -> (m,Int)
05:26:54 <Calister> now i dunno if that made sense at all but i made a data FlMemory
05:27:11 <Calister> data FlMemory = Frep[(Int,Int)]
05:27:27 <Calister> instance Memory FlMemory where
05:27:54 <Calister>   allocate (Frep x, c) = and so on
05:28:00 <Calister> there there it complains
05:28:19 <xerox> (doesn't solve it, but put a space between Frep an [..])
05:28:23 <Calister> bout "Type error in instance member binding"
05:28:40 <xerox> So...
05:28:50 <xerox> allocate takes an m and an Int.
05:29:08 <Calister> yep
05:29:08 <xerox> ...if m = FLMemory, the first argument of allocate isn't a tuple.
05:29:22 <Calister> why?
05:29:23 <xerox> It's a (Frep xs) where xs is a list of 2-tuples.
05:29:31 <Calister> oh
05:29:50 <xerox> @type [(1 :: Int ,2 :: Int),(3,4),(5,6)]
05:29:51 <lambdabot> [(Int, Int)]
05:30:30 <xerox> You can switch back an forth list of tuples, and tuples of lists with zip and unzip, if you want.
05:31:12 <Calister> so i should put (Frep xs) instead of x? or .. *confused*
05:31:29 <xerox> Calister: do you want 'c' to match the Int ?
05:31:55 <Calister> i want c to match snd Int - fst Int +1
05:32:03 <Calister> well actually <=
05:32:21 <xerox> instance Memory FlMemory where
05:32:21 <xerox>   allocate (Frep xs) c = ..
05:32:29 <xerox> Each param is whitespace-separated.
05:33:07 <Calister> oh gosh.. i hate tripping over so lil evil things
05:33:18 <Calister> thanks xerox
05:33:20 <joelr> @index performGC
05:33:20 <lambdabot> System.Mem
05:33:23 <xerox> (Frep xs) destructures the value of type FlMemory, but you could have done, for instance:
05:33:23 <xerox> instance Memory FlMemory where
05:33:23 <xerox>   allocate foo bar = ..
05:33:31 <xerox> Where foo :: FlMemory, and bar :: Int.
05:34:02 <xerox> It's just that the arguments of a function are *not* parens-enclosed, and comma-separated.
05:34:04 <Calister> hmm
05:34:17 <Calister> yeah
05:34:37 <xerox> In allocate (Frep xs) c = .., you have  xs :: [(Int,Int)].
05:34:47 <Calister> why didnt i see that? :x
05:36:22 <xs> isn't fmap f for any monad just liftM f?
05:37:00 <xerox> xs: yeah.  But Haskell doesn't force a Monad to have a Functor instance.
05:37:35 <xs> why not?
05:37:36 <xerox> Yes, today I said `fmap` in the snippet.  liftM would have worked too :-)
05:40:03 <Techniks> doubleList :: [Int] -> Int
05:40:03 <Techniks> doubleList [] = []
05:40:03 <Techniks> doubleList (a:x) = (2*a) : doubleList x
05:40:06 <Techniks> whats wrong with this
05:40:07 <Techniks> i want to make
05:40:11 <Techniks> [1,4,5]
05:40:14 <Techniks> turn into
05:40:18 <Techniks> [2,8,10]
05:40:21 <xs> it's curious. :)
05:40:25 <Techniks> im getting a type error
05:40:37 <Techniks> ahhh
05:40:38 <xerox> Techniks: the type is incorret
05:40:39 <Techniks> its gotta be
05:40:42 <Techniks> [Int]
05:40:43 <Techniks> yeah
05:40:45 <xerox> Thought you can use 'map'
05:40:47 * ValarQ would have used map (*2)
05:40:49 <xerox> Check this out:
05:40:51 <xerox> @type map
05:40:52 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
05:40:56 <xs> don't you mean :: [Int] -> [Int]?
05:41:04 <Techniks> thats what ive got now
05:41:04 <Techniks> works
05:41:06 <xerox> It takes a function from 'a' to 'b', and turns a list of 'a' in a list of 'b'.
05:41:09 <Techniks> yeah how do use map
05:41:15 <xerox> You see that?
05:41:31 <xerox> @eval let doubleList = map (*2) in doubleList [1,4,5]
05:41:32 <joelr> malcolm_: ping
05:41:33 <lambdabot> [2,8,10]
05:41:51 <Techniks> thats awesome
05:41:58 <xerox> Techniks: agreed.
05:42:04 <Techniks> how do i filter numbers from a list
05:42:11 <xerox> @type filter
05:42:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:42:18 <Techniks> hmm
05:42:23 <xerox> It takes a decision procedure on elements, and a list of elements.
05:42:36 <xerox> @eval filter (> 3) [1..10]
05:42:37 <lambdabot> [4,5,6,7,8,9,10]
05:42:52 <malcolm_> joelr: pong
05:43:19 <xerox> Techniks: it applies the function to each element, and keeps the elements for which the functions returns True.
05:43:29 <joelr> malcolm_: i think the finalizers for FPS are not running. check out http://wagerlabs.com/Bar.hs. i had to modify the fps export list to expose the constructor but that's the only change i made.
05:43:30 <Calister> if i wanted to use allocate, what would i have to type? something like "allocate [(1,2),(4,6),(7,7)] 1"?
05:43:39 <joelr> i saw the finalizer run once but that's it
05:43:54 <xerox> Calister: given that you have wrote a 'data'type, you must wrap it in the constructor.
05:44:11 <xerox> Calister: so that the function can de-construct it.
05:44:15 <Techniks> @eval filter (==3) [1..10]
05:44:16 <lambdabot> [3]
05:44:18 <Techniks> hehe
05:44:26 <xerox> That is, (Frap [..]).
05:44:31 <xerox> Techniks: right on!
05:44:41 <Calister> oh
05:44:45 <Techniks> @eval filter (`mod` 3) [1..10]
05:44:46 <lambdabot>  add an instance declaration for (Integral Bool)
05:44:55 <Techniks> @eval filter (`mod` 3 ==0) [1..10]
05:44:56 <lambdabot>   The operator `mod' [infixl 7] of a section
05:44:56 <lambdabot>    must have lower precedence than the operand `(==)' [infix 4]
05:44:56 <lambdabot>    in the section: `(`mod` (3 == 0))'
05:45:09 <Techniks> @eval filter (1,2,3) [1..10]
05:45:10 <lambdabot> Couldn't match `a -> Bool' against `(a1, b, c)'
05:45:17 <Techniks> @eval filter (1 | 2) [1..10]
05:45:18 <lambdabot>  parse error on input `|'
05:45:20 <xerox> Techniks: wait! :D
05:45:23 <Techniks> hehe
05:45:29 <Calister> cheers :) at least its only giving me a show function error now
05:45:35 <xerox> Techniks: filter (\x -> x `mod` 2 == 0) [1..20]
05:45:47 <malcolm_> joelr: I'm not sure your prog is doing enough work to trigger GC and thus run the finalizers
05:46:01 <xerox> Techniks: If you want the points-free form of that anonymous function, you can use TheHunter's @pl!
05:46:02 <joelr> malcolm_: i'm forcing GC at the end of main
05:46:09 <xerox> @pl \x -> x `mod` 2 == 0
05:46:10 <lambdabot> (0 ==) . (`mod` 2)
05:46:21 <joelr> malcolm_: do you see it?
05:46:22 * Calister makes an ugly part time fix for it
05:46:23 <xerox> @eval filter ((0 ==) . (`mod` 2)) [1..20]
05:46:24 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
05:46:34 <malcolm_> joelr: try forcing it at the end of every foo, before the recursive call
05:46:44 <joelr> malcolm_: hmm... let me try that
05:47:58 <joelr> malcolm_: it does not make a difference
05:48:00 <xerox> Calister: you can add 'deriving Show' to datatypes declaration and get Show instances for free.
05:48:18 <Calister> thats what i did
05:48:23 <Calister> ^_^
05:48:26 <xerox> :-)
05:48:34 <Calister> my prof called it sorta the brutal way to do it
05:48:39 <Calister> but its enough for testing
05:49:05 <xerox> It's kinda good way.
05:49:09 <malcolm_> joelr: maybe the win version of the RTS or libraries has some strange thing that stops the finalizers from running
05:49:20 <xerox> ..if you derive (Show,Read), you get serializability for free, in some sense.
05:49:24 <malcolm_> @seen JaffaCake
05:49:24 <joelr> malcolm_: this is mac osx :)
05:49:24 <lambdabot> Last time I saw JaffaCake was when I left #gentoo-haskell, #haskell, #
05:49:24 <lambdabot> haskell-blah, #haskell-overflow, #haskell.it and #webwitches 4 days, 13
05:49:24 <lambdabot> hours, 35 minutes and 35 seconds ago, and I have missed 4 hours, 55
05:49:25 <lambdabot> minutes and 47 seconds since then.
05:49:55 <Calister> he wants our stuff to implement Show XD
05:50:06 <Calister> so i suppose we aint allowed to do the brutal way
05:51:09 <joelr> @index mallocForeignPtr
05:51:10 <lambdabot> Foreign.ForeignPtr, Foreign
05:54:46 <malcolm_> joelr: hmm, I wonder if the finalizer is itself holding onto the data value, so it is never GC'd?  I can't remember whether GHC turns such pointers into weak pointers or not.
05:55:42 <joelr> malcolm_: it's not doing anything to the string itself if you notice, it converts it to a list and that's it. no, wait, it just prints it
05:56:00 <joelr> @type mallocForeignPtr
05:56:01 <lambdabot> Not in scope: `mallocForeignPtr'
05:56:22 <xerox> @type ForeignPtr.mallocForeignPtr
05:56:23 <lambdabot> forall a.
05:56:23 <lambdabot> (Foreign.Storable.Storable a) =>
05:56:23 <lambdabot> IO (GHC.ForeignPtr.ForeignPtr a)
05:58:42 <malcolm_> joelr: I think I would stick to the Foreign.ForeignPtr.addForeignPtrFinalizer variant, and write the debug printing routine in C.  That way, you avoid having to worry about circularity between the data value and the finalizer.
05:59:08 <joelr> malcolm_: well, i did see it run once when i was doing something else with the string apart from packing it
05:59:14 <joelr> malcolm_: but that was just once
05:59:58 <joelr> malcolm_: plus, my finalizer is supposed to run _before_ all other finalizers so the others should take care of things, right?
06:00:01 <joelr> xerox: thanks
06:00:07 <xerox> joelr: you're welcome.
06:02:01 <malcolm_> joelr: My point was that, if the finalizer routine contains a pointer to the data, then that data will never be marked as dead until after the finalizer has been run and deleted.  But the finalizer will never run, because the data is still live!
06:03:13 <joelr> malcolm_: hmm
06:03:45 <joelr> malcolm_: interesting point. i think i'll write the finalizer in c then
06:04:17 <musasabi> References from finalizers don't count for keeping data alive.
06:04:34 <musasabi> And that can cause lots of problems.
06:04:56 <joelr> musasabi: are you pro or contra writing the finalizer in c?
06:08:21 <reddi> i have a data type [[Int]] - with values like [[2,1,3],[3,2,1],[3,1,2],[1,2,3],[2,3,1],[1,5]] ! is it possible to compare the FIRST of the numbers - 2, 3, 3,1,2,1 with a value?
06:08:58 <musasabi> joelr: I ended up using my own reference counted pointers. Writing the finalizer in C could also work.
06:10:18 <joelr> musasabi: but you disagree with malcolm re: finalizers holding pointers to data and thus that data not being marked as deleted, right?
06:11:17 <malcolm_> joelr: finalizers are complicated, and I can't remember all the details.  musasabi might be right
06:11:31 <Cale> reddi: map head xs ?
06:11:38 <musasabi> joelr: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html has the discussion.
06:12:03 <Cale> reddi: or, well, I'm not quite sure what you mean by compare here -- do you want to filter the list?
06:12:17 <reddi> cale: yes i wanna do that
06:12:42 <joelr> musasabi: where's the discussion?
06:12:45 <reddi> seems to make me going one step forward ;-)
06:12:59 <Cale> @eval filter (\xs -> head xs <= 2) [[1,2,3],[2,3,1],[3,2,1]]
06:13:00 <lambdabot> [[1,2,3],[2,3,1]]
06:14:37 <Techniks> -- occursIn
06:14:37 <Techniks> occursIn :: a -> [a] -> Int
06:14:37 <Techniks> occursIn a [] = 0
06:14:37 <Techniks> occursIn a (x:xs)
06:14:37 <Techniks>    | (a==x) = 1 + occursIn a xs
06:14:38 <Techniks>    | otherwise = occursIn a xs
06:14:41 <Techniks> what i have done wrong here ;)
06:14:51 <Techniks> i wanna count the number of times an element in a list occurs
06:14:52 <Techniks> hehe
06:15:19 <xerox> howMany x = length . filter (== x)
06:15:19 <xerox> :-)
06:15:29 <Cale> Well, first of all, you'll need to add "(Eq a) =>" to your type signature
06:15:37 <Techniks> where abouts Cale?
06:15:41 <Techniks> and why, as i dont understnad
06:15:50 <Cale> occursIn :: (Eq a) => a -> [a] -> Int
06:16:03 <Techniks> what does that do?
06:16:05 <Cale> Eq a means that the values of type a are comparable for equality
06:16:16 <Techniks> ah so thats a constraint is it
06:16:16 <Techniks> ?
06:16:17 <Cale> that is, == and /= are applicable
06:16:19 <Cale> yeah
06:16:26 <musasabi> joelr: touchForeignPtr
06:16:35 <musasabi> contains it.
06:16:43 <Techniks> so the constraint goes before the type sig?
06:16:44 <Cale> because, say you had a list of functions, you're not going to be able to compare them for equality
06:17:12 <Calister> xerox, you still around?
06:17:24 <xerox> Yep.
06:17:33 <Calister> i got another question ;d
06:17:41 <Techniks> what is it Calister
06:17:41 <Techniks> ?
06:18:16 <Calister> my allocate works okayish now.. only prob is.. if i search rekrusiv through my tupel list for a big enough space
06:18:24 <joelr> musasabi: i don't see it stating that foreign finalizers don't hold to pointers. i suppose it implies that  you should call touch if you want to
06:18:27 <Calister> it drops off always first tupel
06:18:32 <Calister> tuple*
06:18:40 <xerox> Calister: hmm?
06:18:56 <Calister> well umm.. duh..*ponders how to say it*
06:19:46 <Calister> okay.. if i give in allocate (Frep [(1,2),(4,6),(7,7)]) 3
06:20:14 <Calister> my prog checks if (1,2) if big enough for 3 memory "cells".. but it aint
06:20:42 <Calister> so its calling itself again without head of list (without (1,2))
06:20:49 <joelr> malcolm_: i installed a C finalizer but it's still not running
06:21:36 <Calister> its supposed to return me a list with all free cell-blocks like before
06:21:49 <Calister> and just to take out the cells its using now
06:22:15 <Calister> but since i do it rekursive my prog "forgets" bout those cellblocks where it didnt fit before
06:22:34 <xerox> Calister: use an helper function.
06:22:45 <Calister> so it would just return me [(7,7)]
06:22:51 <Calister> an helper function?
06:23:05 <xerox> How is allocate defined now?
06:23:23 <Calister> umm
06:23:40 <Calister> one moment.. ima bring my lappy online.. dont wanna type all here word by word
06:23:41 <Calister> XD
06:23:49 <Techniks> firstDigit :: [Int] -> Int
06:23:49 <Techniks> firstDigit st
06:23:49 <Techniks>   = case (digits st) of
06:23:49 <Techniks>       [] -> 0
06:23:49 <Techniks>       (a:_) -> a
06:23:56 <Techniks> how do i find the first digit
06:24:07 <Techniks> i need to write a function called digits
06:24:07 <Techniks> hehe
06:24:15 <xerox> @type Char.isDigit
06:24:16 <lambdabot> Char -> Bool
06:24:21 <Techniks> aha
06:24:31 <Cale> @eval show 1462187
06:24:33 <lambdabot> "1462187"
06:24:40 <Techniks> so what about the Int class
06:24:47 <Cale> Int is a type
06:24:48 <Techniks> actually i should make it a string
06:24:55 <Techniks> if i want to check its a digit
06:24:56 <Techniks> haha
06:24:58 <Techniks> it has to be a digit
06:25:01 <Techniks> if its Int
06:25:01 <Techniks> hehe
06:25:06 <Cale> well, yeah
06:25:23 <Cale> though you might have to check if it's between 0 and 9
06:25:24 <DoubleCali> there we go
06:25:41 <DoubleCali> class Memory m where
06:25:42 <DoubleCali> 	allocate :: m -> Int -> (m, Int)
06:25:42 <DoubleCali> 	deallocate :: m -> Int -> Int -> m
06:25:42 <DoubleCali> data FlMemory = Frep [(Int,Int)] deriving Show
06:25:43 <Techniks> so whats a good way to write a function to return the first digit in a list
06:25:44 <Techniks> :)
06:25:51 <DoubleCali> instance Memory FlMemory where
06:25:51 <DoubleCali> 	allocate (Frep (x:s)) c
06:26:06 <DoubleCali> 		| (snd x - fst x + 1) == c		= (Frep s, fst x)
06:26:06 <DoubleCali> 		| (snd x - fst x + 1) > c		= (Frep ( changes ++ s), fst x)
06:26:06 <DoubleCali> 		| otherwise				=
06:26:09 <xerox> Woot
06:26:13 <DoubleCali> (then there is the prob)
06:26:13 <xerox> lisppaste2: url
06:26:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:26:20 <xerox> Go to that url please :-)
06:26:21 <DoubleCali> 			where	changes = [ ((fst x + c), snd x) ]
06:27:11 <DoubleCali> oOo
06:27:13 <DoubleCali> oki :)
06:27:57 <Techniks> can someone give me a good example of how to use case statements
06:27:59 <Techniks> a basic function
06:27:59 <Techniks> :p
06:28:17 <reddi> i need an function like elemindex, but elemindex  results with "just x" and i only need x as an output ...?
06:28:37 <Cale> case xs of [] -> 0; (x:xs) -> x
06:28:50 <xerox> reddi: there are different ways to unpack it.  (Just x) <- f;  fromJust;  ..
06:29:19 <lisppaste2> Calister pasted "allocate" at http://paste.lisp.org/display/13254
06:29:27 <Cale> case elemIndex ... of
06:29:33 <Cale>    Just x -> ...x...
06:29:37 <Cale>    Nothing -> ...
06:29:52 <joelr> dons: ping
06:29:54 <Cale> there's an answer to both recent questions :)
06:30:51 <DoubleCali> xerox.. i know its prolly not very sexy anyways.. but yeah.. and i know its still missing the error part when its not finding any cellblock of right size
06:31:49 <xerox> DoubleCali: what should it do in the last case?
06:32:02 <Techniks> i dont understand how the case function works
06:32:25 <DoubleCali> basically allocate (Frep x) c
06:32:26 <Cale> Techniks: it's not a function, it's syntax
06:32:37 <Techniks> can u illustrate it doing something useful
06:32:43 <DoubleCali> but it needs to be able to remember the s tuple
06:32:48 <xerox> DoubleCali: what should it return?
06:32:48 <Cale> sure
06:32:50 <Techniks> like returning the first number in a string
06:32:51 <Techniks> ?
06:32:57 <Techniks> first digit
06:32:58 <Techniks> hehe
06:33:25 <Cale> @eval case "123" of [] -> 0; (x:xs) -> x
06:33:26 <lambdabot>  add an instance declaration for (Num Char)
06:33:26 <lambdabot>   In a case alternative: [] -> 0
06:33:28 <lambdabot>   In the case expression:
06:33:33 <Cale> @eval case "123" of [] -> '0'; (x:xs) -> x
06:33:34 <lambdabot> '1'
06:33:42 <Cale> @eval case "123" of [] -> 0; (x:xs) -> read x
06:33:43 <lambdabot> Couldn't match `String' against `Char'
06:33:47 <Cale> @eval case "123" of [] -> 0; (x:xs) -> read [x]
06:33:48 <lambdabot> 1
06:33:49 <DoubleCali> a list of tuples (all those which are still free) and the cell index where umm now "reserved" cellblock starts
06:33:51 <Cale> there :)
06:34:02 <Cale> @eval case "" of [] -> 0; (x:xs) -> read [x]
06:34:03 <lambdabot> 0
06:34:22 <Techniks> where is it testing if its a digit?
06:34:24 <reddi> and which module do i have to insert to use fromJust and how to find out that?
06:34:28 <Cale> it doesn't
06:34:33 <Techniks> @eval case "hello3hello4" of [] -> 0; (x:xs) -> read [x]
06:34:34 <lambdabot> Prelude.read: no parse
06:34:41 <Techniks> i'd want to return 3
06:34:55 <Cale> ah, then you want to filter isDigit
06:34:59 <Techniks> yah
06:35:01 <Techniks> using case
06:35:01 <Techniks> hehe
06:35:09 <Cale> @eval filter isDigit "hello3hello4"
06:35:10 <lambdabot> "34"
06:35:23 <Techniks> i wanna get the first digit using the case syntax
06:35:24 <Techniks> hehe
06:35:31 <Cale> okay...
06:36:40 <Cale> @eval let f str = case str of [] -> 0; (x:xs) -> if isDigit x then read [x] else f xs in f "hello3world4"
06:36:41 <lambdabot> 3
06:36:54 <reddi> @hoogle fromJust
06:36:55 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
06:37:11 <Cale> fromJust will raise an error if the value is Nothing
06:37:19 <Cale> @eval fromJust Nothing
06:37:20 <lambdabot> Add a type signature
06:37:23 <Cale> @eval fromJust Nothing :: Int
06:37:24 <lambdabot> Maybe.fromJust: Nothing
06:37:31 <Cale> @eval fromJust (Just 4)
06:37:32 <lambdabot> 4
06:38:17 <Cale> Techniks: it's often clearer to write your function to pattern match in the first place
06:38:23 <Cale> (than using case explicitly)
06:38:28 <Techniks> yeah
06:38:31 <Techniks> i just want an understanding ofit
06:38:36 <Techniks> incase i am testing with it tomorrow hehe
06:38:46 <Cale> case just lets you do extra pattern matching
06:38:56 <Techniks> ill try not to use it for now hehe
06:38:59 <Cale> and deconstruct values
06:39:11 <reddi> http://pastebin.com/419312
06:39:13 <Cale> you're implicitly using it whenever you pattern match
06:39:15 <reddi> what is wrong here?
06:39:33 <Cale> hmm
06:39:34 <Oejet> Techniks: Hey, did you finish your pyramid program?
06:40:30 <Cale> hmm
06:40:38 <Cale> reddi: that works on my system
06:40:53 <reddi> just as i entered it?
06:41:26 <Cale> ah, you had list loaded
06:41:28 <Cale> one sec
06:41:58 <Cale> hugs is a bit strange with respect to modules
06:42:14 <reddi> hm .. on normal hugs it works
06:42:18 <reddi> on winhugs not ggg
06:43:06 <Cale> you can avoid having List loaded, and the expression you were trying to evaluate works
06:43:18 <Techniks> sumPairs :: [(Int, Int)] -> [Int]
06:43:21 <Techniks> sumPairs [] = [0]
06:43:21 <Techniks> sumpairs a:x  = (fst a + snd a) : sumPairs x
06:43:21 <Cale> hmm, where'd ndm go?
06:43:25 <reddi> hm i opened now another winhugs and it seems to work ;-)
06:43:25 <Techniks> what've i done here hehe
06:43:35 <Cale> Techniks: case sensitive
06:43:51 <Cale> reddi: okay :)
06:44:06 <Cale> Techniks: also, (a:x)
06:44:19 <Cale> (you need parens there)
06:44:28 <reddi> that is crazy, if i use data.maybe i cannot use elemIndex
06:44:41 <Cale> :|
06:44:56 <Cale> I never bothered to figure out how hugs deals with loading multiple modules
06:45:00 <Techniks> aja
06:45:00 <Cale> (I use ghci)
06:45:12 <Cale> let me see if I can figure it out :)
06:45:47 <reddi> hm i cannot write everything in the file cause it is not so easy to find mistakes as on command line hm
06:46:03 <Cale> ah
06:46:43 <Cale> Hugs.Base> :load Data.Maybe
06:46:43 <Cale> Data.Maybe> :also Data.List
06:46:43 <Cale> Data.List> fromJust $ elemIndex 3 [1,2,3,4,5]
06:46:43 <Cale> 2
06:47:00 <Cale> for some stupid reason, if I load them in the other order it fails
06:47:11 <Cale> hugs is written in C :)
06:48:33 <reddi> fctname ["John Smith","Judy Hall"]  ["John Smith","Judy Hall","John Doug"]
06:48:42 <reddi> is there a function which answers with 0,1?
06:48:57 <reddi> or do i have to use ElemIndex and iterate over it
06:49:59 <ulfdoz> I think it is in general not a good Idea to use indexes on lists.
06:50:23 <reddi> how would u do it?
06:51:08 <ulfdoz> reddi: Search your Element, apply the function to it. The index is normally uninteresting for any operation on the data a list contains.
06:52:00 <reddi> the problem is that i have inputs like this: ["John Smith","Judy Hall","John Doug"] [[2,1,3],[3,4,1],[2,1],[1,2,3],[2,3,1]] where the number refers to the string
06:52:49 <reddi> and maybe i am to stupid (that could be a reason ;-)) .....but i dont see any alternatives
06:53:50 * dcoutts curses ghc -split-objs
06:54:06 <dcoutts> ghc -split-objs curses dcoutts
06:54:13 <ulfdoz> can you construct an association list? It contains tuples (key, data). Key could be the name, data your index. Then you can search quite easy.
06:55:50 <dcoutts> ghc file size stats: helloworld-console 190K, helloworld-gtk2hs-before 2.7M, helloworld-gtk2hs-after 314K
06:56:05 <dcoutts> so that's a major improvement by using ghc -split-objs
06:56:09 <reddi> hm could be an idea hm...... but i cannot change the input so i have to use indexes once....
06:56:17 <dcoutts> however it's a pain to work into one's build system
06:56:46 <ulfdoz> reddi: It should be possible to construct it from input with zipWith and filter.
06:57:53 <malcolm_> dcoutts: file size with yhc : hello world = 130 bytes.
06:58:56 <dcoutts> malcolm_, heh, nice :-)
06:59:23 <dcoutts> malcolm_, but that's because much of the standard lib is in the runtime system
06:59:27 <dcoutts> eg the IO system
07:00:00 <dcoutts> malcolm_, though actually I'm looking forward to having gtk2hs work with yhc and getting nice portable gui progs.
07:00:17 <malcolm_> dcoutts: sure.  But I bet even if you count those, yhc will still be < 50kb.
07:00:26 <dcoutts> malcolm_, yes I'm sure
07:00:38 <dcoutts> ghc's rts is quite big in comprison
07:01:09 <ulfdoz> reddi: findIndices would return the indexes you want. Hopefully you don't want to access the elements by index as it is an quite expensive operation.
07:01:17 <malcolm_> I like jhc's design decision there there is no RTS at all. Everything needed is hauled in via the FFI.
07:01:26 <dcoutts> yeah it's nice
07:05:59 <Techniks> im starting to get the hang of this haskell shit hehe
07:06:18 <reddi> what does this error mean? http://pastebin.com/419335
07:07:34 <reddi> sry: http://pastebin.com/419336
07:08:36 <ulfdoz> reddi: You return a tripel, but typesignature enforces a pair.
07:08:52 <ulfdoz> the other way round, sry
07:09:42 <reddi> ulfdoz: (String,Int,Int) is a triple and (k,s,id) too?
07:10:32 <reddi> i dont see the pair, i only see triples ...
07:11:40 <reddi> maybe i am blind?
07:13:02 <cinema> :l
07:13:04 <cinema> *
07:13:08 <ulfdoz> reddi: But you return a pair.
07:13:15 <reddi> where?
07:14:11 <reddi> that is the return "value": (k,s,id) and that is the "return" signature [(String,Int,Int)]
07:14:15 <reddi> both are 3 values?
07:14:56 <ulfdoz> reddi: What is type of "kandidathaterststimmen"?
07:16:34 <reddi> there i return a pair hm ok then i have the error (but no solution gg)
07:16:53 <ulfdoz> reddi: [(k,s,id)|(k,s,id)<-kandidathaterststimmen wahlvorschlag stimmzettel,s == foldl1 min (auszaehlen wahlvorschlag stimmzettel),id<-fromJust(elemIndex k wahlvorschlag)]
07:16:57 <ulfdoz> sorry
07:17:02 <beelsebob_> @paste
07:17:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:17:37 <reddi> hm i thought that i can enter the id (with fromJust) manually hm
07:17:53 <ulfdoz> reddi: try (k, s) <- kandidathaterststimme ...
07:18:08 <beelsebob_> @paste ... WOOT!
07:18:09 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:18:09 * xerox stares blankly
07:18:18 <reddi> i wanna ad the id
07:18:29 <reddi> and i would need the triple
07:18:30 <reddi> hm
07:18:49 <reddi> it works if i delete id, (that was like i had it before ;-))
07:19:11 <ulfdoz> reddi: id should be bound by last part I think.
07:19:28 <reddi> yes
07:19:38 <reddi> by id<-fromJust
07:20:31 <Techniks> firstWord :: [[Char]] -> String
07:20:31 <Techniks> firstWord [] = ""
07:20:31 <Techniks> firstWord (x:xs)
07:20:31 <Techniks>   | (x==' ') = x
07:20:31 <Techniks>   | otherwise = x ++ firstWord xs
07:20:37 <Techniks> anyone know what im doing wrong her eheh
07:20:50 <Techniks> I wanna do
07:21:01 <Techniks> firstWord ["Hey this is a sentence"]
07:21:02 <Techniks> and get
07:21:04 <Techniks> "Hey"
07:21:05 <Techniks> heeh
07:21:33 <reddi> is it possible to bind the id to the "pair"?
07:21:36 <reddi> or not?
07:21:37 <Techniks> got it :p
07:24:00 <Techniks> firstWord :: [String] -> String
07:24:01 <Techniks> firstWord [] = ""
07:24:01 <Techniks> firstWord (x:xs)
07:24:01 <Techniks>   | (x==" ") = x
07:24:01 <Techniks>   | otherwise = x ++ firstWord xs
07:24:08 <Techniks> this returns the whole string not just the first word
07:24:08 <Techniks> why :P
07:24:09 <Techniks> hehe
07:24:53 <Techniks> anyone?
07:25:13 <joelr> dons: ping
07:25:40 <joelr> @localtime dons
07:25:41 <lambdabot> Local time for dons is Mon Nov  7 02:19:47 2005
07:25:47 <joelr> oops
07:28:21 <reddi> hm.....
07:31:58 * beelsebob_ does the *has a working interpreter* dance
07:32:10 <xerox> Woot!
07:32:18 <wilx> Of?
07:32:20 <xerox> Your nick being with or without the trailing '_' ?
07:33:08 <Beelsebob> wilx: Haskell
07:33:08 <xerox> @karma+ beelsebob -- interpreters rock!
07:33:09 <lambdabot> beelsebob's karma raised to 1.
07:33:17 <Beelsebob> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
07:33:22 <Beelsebob> why thank you xerox
07:33:53 <malcolm_> Beelsebob: what interpreter?  yhi?
07:33:59 <Beelsebob> malcolm_: yep :)
07:34:07 <Beelsebob> as the paste page shows :)
07:34:20 <xerox> Beelsebob: there is a command line tool to get the 'italics' bold-like / / words ;-)
07:34:33 <Beelsebob> xerox: what is it?
07:34:45 <xerox> Let me find it..
07:34:52 <Beelsebob> and I take it I need aalib installed
07:35:22 <xerox> Beelsebob: it is called 'figlet' !
07:36:18 * Beelsebob emerges it
07:37:54 <malcolm_> Beelsebob: is yhi calling out to an external compiler (a la hmake interactive), or using yhc internally like a library call (ghci-like)?
07:38:24 <Beelsebob> malcolm_: at the moment it calls out to yhcc and yhc, but I'm planning on making it call library calls instead
07:39:23 <Beelsebob> hmm... see if this makes sense malcolm... at the moment yhc has the problem that files need to be name <module>.hbc So if you want to move the module somewhere else, you're in trouble
07:40:22 <malcolm_> Beelsebob: so it needs all modules to hang off the current working directory?
07:40:34 <Beelsebob> so... plan I have... write yhar (York Haskell Archiver) that creates a file much like a jar, layed out as #!/usr/local/bin/yhr --har, then a header stating module names in the archive, and their byte offsets, then each module cated into the file
07:40:38 <ctrlsoft> any tips on a good FFI preprocessor? I'm a bit overwhelmed by the number of solutions available..
07:40:48 <Beelsebob> malcolm_: yes
07:41:12 <Beelsebob> so you could then produce a single file containing the program that can be moved about the place
07:41:26 <Beelsebob> obviously yhr would need to be updated to unpack them
07:41:30 <malcolm_> Beelsebob: Does "cat *.hbc >archive" not work then?  :-)
07:41:38 <Techniks> how do i do this
07:41:51 <Techniks> map (+) [3,4,5]
07:41:55 <Techniks> ?
07:42:15 <Beelsebob> malcolm_: no... because when yhr calls a function it goes "what module is this?" ah... it's in Jam... open Jam.hbc... find the function
07:42:15 <malcolm_> @eval map (+) [3,4,5]
07:42:15 <vegai> @eval map (+) [3,4,5]
07:42:16 <lambdabot>  add an instance declaration for (Show (a -> a))
07:42:16 <lambdabot>  add an instance declaration for (Show (a -> a))
07:42:18 <Beelsebob> etc
07:42:26 <vegai> :)
07:42:29 <Beelsebob> so if you just cat the .hbc files together bad things happen
07:42:52 <Techniks> @eval show(map (+) [3,4,5])
07:42:53 <lambdabot>  add an instance declaration for (Show (a -> a))
07:42:53 <lambdabot>   In the definition of `xxxx': xxxx = show (map (+) [3, 4, 5])
07:42:53 <lambdabot>   In the definition of `v':
07:42:58 <Techniks> :S
07:43:01 <xerox> @type (+)
07:43:02 <lambdabot> forall a. (Num a) => a -> a -> a
07:43:07 <xerox> @type map
07:43:08 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:43:11 <vegai> Techniks: what do you want, really?
07:43:18 <xerox> You see, it gets a (a -> a), not an (a -> a -> a).
07:43:19 <Techniks> tryintg to learn to use map
07:43:19 <Techniks> :p
07:43:20 <malcolm_> Beelsebob: I thought Tom had written mini runtime linker?  Maybe your har-creator could use that, but statically.
07:43:40 <vegai> ok, so this would work:
07:43:44 <Beelsebob> malcolm_: I didn't know that, I'll prod Tom about it... it sounds like a good plan
07:43:44 <vegai> @eval map (+1) [3,4,5]
07:43:46 <lambdabot> [4,5,6]
07:43:59 <Beelsebob> certainly at the moment it needs all the seperate files, appropriately named
07:44:02 <shapr> malcolm_: Speaking of JHC, after reading Henning's post, I realized that speculative evaluation could be implemented as a GRIN optimization.
07:44:12 <dcoutts> ctrlsoft, has anyone reccomeded c2hs to you yet?
07:44:14 <dcoutts> @where c2hs
07:44:15 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
07:44:26 * xerox recommends c2hs too!
07:44:29 <dcoutts> shapr, oh yeah? how?
07:44:37 <shapr> Thunks are just nodes.
07:44:40 <reddi> i have got a list e.g. ["abc","def","ghi"] and i have another list ["abc",def","km","ghi"]
07:44:57 <Beelsebob> malcolm_: the other advantage is of course that you get a tool called YHAR!
07:45:00 <Beelsebob> @yhar
07:45:01 <lambdabot>  @where <key>, return element associated with key
07:45:02 <reddi> how can i use elemindices to give me ALL the indices of the bigger list?
07:45:44 <reddi> i am helped if someone can tel me how to do something for every element in a list
07:45:45 <shapr> dcoutts: Makes sense?
07:45:51 <musasabi> reddi: map
07:45:53 <shapr> map
07:45:53 <musasabi> @type map
07:45:54 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:46:10 <kombinator> dcoutts: I have some doubts regarding the idea of arrow-based GUI :(
07:46:28 <kombinator> dcoutts: however, I don't see any alternative
07:46:29 <musasabi> kombinator: where did you get stuck?
07:46:44 <shapr> kombinator: It works as long as you don't try to lift functions into arrows.
07:46:51 <dcoutts> shapr, thunks are just nodes, yes. I don't see what you're getting at
07:47:09 <Techniks> whats an example of using map on this list
07:47:11 <Techniks> to double the numbers
07:47:14 <malcolm_> shapr: Does GRIN have threads?  I thought speculative evaluation required sparking off resource-limited threads.
07:47:15 <Techniks> [3,4,5]
07:47:16 <Techniks> to get
07:47:21 <Techniks> [6,8,10]
07:47:22 <musasabi> shapr: arrows cannot be used much if you cannot lift functions.
07:47:23 <Techniks> :)
07:47:30 <shapr> musasabi: true that
07:47:41 <shapr> malcolm_: Nah, but I think you can just strictify...
07:47:45 <musasabi> even the arrow syntax requires them.
07:47:46 <kombinator> dcoutts: The most important point for high-level gui is imo that layout of widgets should be independent from the logic
07:47:53 <dcoutts> Techniks, is this a homework question?
07:47:58 <Techniks> dcoutts no
07:47:59 <kombinator> and arrows provide that
07:47:59 <Techniks> hahaha
07:48:02 <Techniks> im trying to learn
07:48:03 <dcoutts> kombinator, yes absolutely
07:48:08 <Techniks> doing excercises in my text book
07:48:12 <Techniks> i have an exam very soon hehe
07:48:17 <malcolm_> shapr: strictification is not the same as speculation.
07:48:23 <musasabi> Techniks: how do you multiply a number by two?
07:48:29 <Techniks> n82
07:48:32 <Techniks> n*2
07:48:48 <musasabi> can you create a lambda expression that does the same?
07:48:53 <dcoutts> Techniks, that's if you've already got the variable n
07:48:53 <shapr> I think it can be when you unlazify a bunch of calculations.
07:49:00 <kombinator> however, it gets a little hairy if I want to have an explicit model of data showed on widgets (instead of models embedded in widgets)
07:49:04 <Techniks> @eval map (n*2) [3,4,5])
07:49:04 <lambdabot>  parse error on input `)'
07:49:04 <dcoutts> Techniks, what *function* doubles a number?
07:49:12 <Techniks> *
07:49:18 <musasabi> (\n -> ...) 6 == 12
07:49:20 <neologism> (*2)
07:49:31 <shapr> kombinator: Seen musasabi's PArr arrows?
07:49:43 <malcolm_> @eval map (*2) [3,4,5]
07:49:44 <kombinator> shapr: no
07:49:44 <lambdabot> [6,8,10]
07:50:04 <dcoutts> Techniks, so the * function multiples one number by another, you're looking for the special case of just doubling
07:50:04 <Techniks> @eval map (*2) [1,2,3,4,5,6]
07:50:06 <lambdabot> [2,4,6,8,10,12]
07:50:10 <Techniks> cool
07:50:20 <kombinator> If I want to have an explicit model I have to connect it both ways to the relevant widgets
07:50:21 <dcoutts> Techniks, so (\n -> n * 2) is what you want
07:50:22 <shapr> kombinator: Look at the image near the bottom of http://www.haskell.org/tmrwiki/ArrowsIntroduction
07:50:31 <Techniks> @eval map (filter 1) [1,2,3,4,5,6]
07:50:32 <lambdabot>  add an instance declaration for (Num [a])
07:50:32 <lambdabot>   In the list element: 6
07:50:36 <musasabi> parsers don't care much for identity which is the hardest thing with GUI arrows.
07:50:38 <dcoutts> Techniks, and (*2) is just short hand for (\n -> n * 2)
07:50:41 <Techniks> yeah
07:50:44 <shapr> malcolm_: Do you think unthunking at compile won't count as speculation?
07:50:47 <ctrlsoft> dcoutts: Thanks, I'll check it out!
07:50:56 <Techniks> now that i can map it, how do i filter these results hehe
07:50:56 <Techniks> :p
07:51:05 <shapr> You could use filter.
07:51:08 <joelr> malcolm_: why do you think the malloc finalizers would not be running?
07:51:18 * musasabi thinks attribute grammar like systems are the way to go.
07:51:37 <musasabi> maybe comonadic actually running inside monads..
07:51:43 <reddi> why does this:  map elemIndices ["John Smith"] ["John Smith","Judy Hall"]  not work?
07:51:46 <malcolm_> shapr: a good strictness analyser is a nice thing to have.  But speculation is when you can't /prove/ something is strict, but nevertheless you hope it is.
07:52:13 <fworp> reddi: because you are passing 3 arguments to map, and it only takes two
07:52:16 <Techniks> @type filter
07:52:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:52:34 <Techniks> hmmm
07:52:35 <musasabi> malcolm_: with JHC performing global analysis you can have much better strictness analysis (but no hs-plugins)
07:52:37 <fworp> use parenthesis
07:53:04 <Techniks> @eval filter ("x") ["Hello x world"]
07:53:04 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
07:53:09 <Techniks> :DS
07:53:10 <malcolm_> shapr: For speculation, it is important that the speculation can be killed if the assumption turned out wrong.  So you don't fall into an infinite loop, or waste vast amounts of time doing unnecessary computation
07:53:20 <fworp> ... (elemIndices ["John Smith"]) ...
07:53:22 <shapr> Hm, yeah
07:53:22 <reddi> but elemIndices needs 2 arguments?
07:53:23 <musasabi> @eval filter (=="x") ["Hello x world"]
07:53:24 <lambdabot> []
07:53:28 <dcoutts> hi gour
07:53:40 <Techniks> @eval filter ("x") ["Hello x world"]
07:53:41 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
07:53:44 <shapr> I think GRIN could do limited unthunking to emulate that, but it's not the same thing.
07:53:48 <Techniks> @eval filter (=="x") ["Hello x world"]
07:53:50 <lambdabot> []
07:53:50 <musasabi> @eval filter (=="x") ["Hello ","x"," world"]
07:53:51 <lambdabot> ["x"]
07:53:54 <shapr> reify == unthunk?
07:53:59 <malcolm_> musasabi: yeah, whole-program analysis is always going to be able to spot more opportunities than separate compilation.
07:54:23 <Techniks> how can i filter the x outta  ["Hello x world"]
07:54:26 <fworp> reddi, yes it does, and it gets the second when map applies the result of applying it to one, to each of the elements in the second list
07:54:28 <gour> dcouts: hi
07:54:32 <musasabi> @eval filter (/='x') "Hello x world"
07:54:33 <lambdabot> "Hello  world"
07:55:01 <gour> dcoutts: hi
07:55:24 <kombinator> shapr: maybe if you separated functions that just redirect value streams from the functions doing actual work the blackboxes would be hiding only pure functions
07:55:52 <dcoutts> musasabi, malcolm_, I'm not totaly convinced that whole-program strictness analysis can always do better than seperate analysis.
07:56:04 <gour> dcoutts: i just received mail from xchat-gnome devs that they implemented osd plugin (on my rfe :-)
07:56:13 <dcoutts> gour, osd?
07:56:16 <kombinator> shapr: but this is not a problem for me at the moment
07:56:29 <reddi> fworp: so i should use ap (elemIndices ["John Smith"]) ["John Smith","Judy Hall"]
07:56:35 <reddi> sry map
07:56:42 <reddi> but i get still an error ;-(
07:56:50 <gour> dcoutts: On Screen Display notification
07:56:51 <musasabi> kombinator: but blackboxes in cases like "pure fst" and "pure snd" are of the nastiest kind. And of course "pure id" vs "pure (const someValue)"
07:56:59 <fworp> @type elemIndices
07:57:00 <lambdabot> Not in scope: `elemIndices'
07:57:03 <kombinator> shapr: right
07:57:05 <fworp> doh.
07:57:10 <musasabi> dcoutts: e.g. the knowledge that all class instances are strict can be valueable.
07:57:21 <malcolm_> dcoutts: well, for trivial programs there may not be much to find, but in general, I would think that being able to specialise polymorphic functions for all their actual uses would enable other optimisations.
07:57:45 <kombinator> shapr: but all you need for redirecting data is arr id, arr fst and several more
07:57:58 * shapr points at musasabi
07:58:12 <shapr> My brain is reaching 0% usefulness. I hate having colds/flus.
07:58:17 <kombinator> shapr: so you could add them as constructors of Arrow class
07:58:23 * xerox hugs shapr
07:58:26 <reddi> so where is my thinking error?
07:58:32 <musasabi> kombinator: yes, those are the problem of arrows. It is impossible to follow the data-flow.
07:58:37 <dcoutts> musasabi, malcolm_, sure, when evaluating the strictness of a function you want to know the strictness of the functions it calls (including higher order ones). But I imagine building a data flow graph that just has holes for the higher order functions it calls and you can work out the complete graph later at the use sites.
07:58:43 <musasabi> shapr: welcome to the club ._.
07:58:50 <gour> dcoutts: have you noticed in the last-few-days logs goron's problem in building gtk2hs on bsd?
07:58:58 <shapr> kombinator: The metatheory here is that Categories are transparent to each other, but the Entsheidungssproblem(sp?) means that functions are not.
07:58:59 <fworp> reddi: try this 'map (`elemIndices` ["John Smith"]) ["John Smith","Someone Else"]'
07:59:04 <shapr> musasabi: Yeah, I caught your cold.
07:59:08 * musasabi gives shapr a cup of hot glgg
07:59:10 <dcoutts> musasabi, malcolm_, but yes a closed world could be helpful, just knowing that there will be no runtime code loading.
07:59:17 <kombinator> shapr: right
07:59:22 <shapr> Maybe I'll warm up some sake, that should knock me over.
07:59:41 <shapr> kombinator: So one approach (that's been tried in the 80s, I think) is to make a language based purely on categories.
07:59:41 <xerox> What taste does the sake have?
07:59:53 <reddi> that works... what was the error on the other combination?
07:59:56 <kombinator> shapr: aren't there any?
08:00:04 <dcoutts> musasabi, malcolm_, I suppose i'm imagining an analysis that is not strictly seperate but does most work seperately and then can collect things more globally at the end.
08:00:11 <shapr> I like that approach best, but I think it's not really the correct solution.
08:00:34 <shapr> I think the correct solution is to find some metatheory for combining Categories that you define yourself.
08:00:35 <lisppaste2> joelr pasted "Why aren't finalizers running?" at http://paste.lisp.org/display/13257
08:00:37 <dcoutts> gour, I noticed goron pinged me but I didn't know what it was about
08:00:43 <joelr> any ideas
08:00:48 <shapr> This may have already happened and no one told me :-)
08:00:49 <malcolm_> dcoutts: well, that's exactly what jhc does, (and Faxen's cheap eagerness too)
08:01:05 <shapr> Ah Faxn has written about cheap eagerness too?
08:01:07 * shapr googles
08:01:30 <shapr> malcolm_: You got all the academic goodies, I want your mental index ;-)
08:01:37 <kombinator> shapr: but my problem is a less fundamental one: I don't know how to make a not-ugly interface between a model and widgets displaying it
08:01:41 <musasabi> shapr: metatheory? (links apreciated)
08:01:49 <gour> dcoutts: some problem with macros in configure
08:02:03 <fworp> reddi: that version applies the infix version of elemIndices ["John Smith"], it makes more sense like this 'map (\x -> elemIndices x ["John Smith"]) ["John Smith","Foo Barison"]'
08:02:06 <shapr> musasabi: Just that the Yampa solution works fine because everything is defined inside Yampa, you can guarantee that the operations will work together nicely.
08:02:20 <shapr> musasabi: That's because arrows are pretty much pure categories.
08:02:21 <dcoutts> shapr, share the link if you find it, I'm interested in eagerness since it's related to binding time analysis
08:02:26 <shapr> dcoutts: ok, will do.
08:02:29 <fworp> the other version i showed was just less typing
08:02:57 <shapr> dcoutts: tada! http://citeseer.ist.psu.edu/faxen00cheap.html
08:03:07 <dcoutts> shapr, ah thanks
08:03:10 <shapr> malcolm_: good find
08:03:27 <musasabi> I think I should try to write a detailed proposal for the GUIs as AG->AG functions (where AG = attribute grammar)
08:03:51 <dcoutts> gour, you might be interested to know that I reduced the size of a gtk2hs hello world program to 11% of it's previous size by using ghc's -split-objs feature.
08:03:56 <fworp> (`elemIndices` q) == (\x -> elemIndices x q) /= (elemIndices q)
08:04:02 <shapr> musasabi: So the full approach (in my opinion) is to find some sensible way for Categories to interact, like monad transformers. Then you can just stick them on top of each other and it should all work.
08:04:06 <shapr> Are arrow transformers already this?
08:04:09 <joelr> is there a way to trace the garbage collector?
08:04:29 <dcoutts> gour, 314K rather than 2.7M
08:04:45 <shapr> Yes yes, this is exactly what I wanted for JHC/GRIN!
08:04:54 <reddi> and how do i perform something like  map [4,5] == 4 (compare each element of a list with a value)
08:05:02 * shapr boings cheerfully
08:05:15 <musasabi> @eval map (==4) [4,5]
08:05:16 <fworp> map (==4) [4,5]
08:05:16 <lambdabot> [True,False]
08:05:22 <fworp> yeah that
08:05:37 <dcoutts> joelr, must you use addForeignPtrConcFinalizer rather than addForeignPtrFinalizer? I have no experience with the concurrent versions.
08:05:54 <musasabi> shapr: that might work.
08:06:10 <joelr> dcoutts: it makes no difference, really. uncommenting the unsafeFinalize makes them run
08:06:13 <int-e> @type curry
08:06:14 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
08:06:18 <shapr> Bah, I'm always behind the times. That's probably because I don't do this for a living.
08:06:23 <joelr> dcoutts: plus, i tried the C finalizer and it still does not make a difference
08:06:26 <gour> dcoutts: 314k instead of 2.7M ?
08:06:36 <shapr> musasabi: Yeah, but it means you're not writing Haskell anymore, just layering categories.
08:06:49 <shapr> That's not necessarily a bad thing, but it's something totally different.
08:07:13 <Cale> @type uncurry
08:07:14 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
08:07:27 <dcoutts> gour, the size of a gtk2hs hello world program when using ghc's -split-objs feature.
08:07:31 <gour> dcoutts: well, it is too good to be be true :-)
08:07:52 <gour> dcoutts: have you tried with other demos?
08:07:52 <dcoutts> gour, but it's a real pain to fit into the build system.
08:08:39 <musasabi> Just adding it to Cabal would solve many problems.
08:08:57 <dcoutts> musasabi, yeah
08:09:15 <musasabi> As all large libraries would instantly benefit from that.
08:09:28 <gour> dcoutts: i think cabal should be enhanced to allow building of gtk2hs-sized projects
08:09:37 <dcoutts> gour, me too!
08:09:41 <chris2> anyone know where i can find slides called "Category Theory for Dummies"? they were on ltu in 2004, but the link is broken...
08:09:50 <gour> dcoutts: othewise, it won't (really) help much
08:10:06 <dcoutts> gour, for the profile viewer demo: 1.3M vs. 6.5M unstripped and 694K vs 3.6M stripped
08:10:08 <gour> dcoutts: half-baked solutions are not the best one
08:10:20 <joelr> dcoutts: any suggestions?
08:10:38 <gour> dcoutts: well, this sort of new wets my haskell apettite
08:10:44 <dcoutts> joelr, so you could not get the C finaliser to run?
08:10:55 <joelr> dcoutts: no, they do not run, period.
08:11:08 <gour> dcoutts: although, i am really busy those days and (still) didn't pass 14th chapter :-(
08:11:27 <dcoutts> joelr, then the thing was probably retained. We use ForeignPtrs with C finalisers in gtk2hs all the time and they work.
08:11:55 <joelr> dcoutts: well, the program is rather simple, http://wagerlabs.com/Bar.hs
08:12:15 <dcoutts> joelr, that's using addForeignPtrConcFinalizer
08:12:19 <joelr> i'm just going through a list of [Int], packing them into FastStrings and printing the result
08:12:33 <dcoutts> I don't understand the Conc versions sorry
08:12:43 <gour> dcoutts: do you have some concrete suggestions for cabal devs how to do it?
08:12:44 <joelr> dcoutts: so you think that my finalizer is retaining the pointers?
08:13:11 <dcoutts> gour, yeah, it's probably not that hard
08:13:57 <dcoutts> gour, if I find some spare time I might look at writing a patch for cabal
08:14:17 <dcoutts> one annoyance is how to use ar when you've got 1000's of .o files
08:14:25 <lisppaste2> joelr annotated #13257 with "c finalizer" at http://paste.lisp.org/display/13257#1
08:14:34 <joelr> dcoutts: am i doing this right?
08:15:17 * kombinator 's brain is being rotted by reading about AGs
08:15:52 <gour> dcoutts: that would be terrific, i.e. not to fiddle with that autoconf stuff
08:16:34 <musasabi> kombinator: I am thinking of using Uustalu's version of them.
08:17:23 <dcoutts> @index addForeignPtrConcFinalizer
08:17:24 <lambdabot> bzzt
08:18:05 <kombinator> musasabi: you mean that paper about dataflow langs and comonads?
08:19:24 <musasabi> yes.
08:20:09 <musasabi> kombinator: I am thinking of representing a GUI as an attribute grammar and GUI actions are functions from the AG (which may evaluate attributes) to a new AG (the new GUI)
08:20:45 <joelr> dcoutts: i'm using the C finalizer
08:21:07 <reddi> is there a function to remove empty lists e.g. [[],[],[0],[1]]  -> [[0],[1]] or better: [0,1] ?
08:21:08 <joelr> but it still does not run. now, if i force it to run then i get a bus error after the finalizer runs the first time
08:21:10 <musasabi> joelr: I tried Bar.hs but it just ran in 0.037 secs without any problems
08:21:27 <joelr> musasabi: did the finalizers run?
08:21:50 <musasabi> joelr: nope, but that is normal (they only run if there is enough memory pressure to trigger such a run)
08:21:52 <kombinator> musasabi: sorry, I don't know what AGs are, I can't really parse what you said
08:22:19 <lisppaste2> joelr annotated #13257 with "Bus error" at http://paste.lisp.org/display/13257#2
08:22:33 <joelr> musasabi: but i'm triggering garbage collection
08:22:42 <gour> dcoutts: do you have svn installed on your machine?
08:23:39 <musasabi> joelr: When I use 'main = do foo $ Prelude.concat $ replicate 100 data_' I do get the finalizers to run.
08:23:59 <joelr> musasabi: wierd
08:24:11 <joelr> i thought performGC would trigger the finalizers
08:24:17 <musasabi> joelr: a GC does not mean that all finalizers are run.
08:24:32 <kombinator> musasabi: but this sounds like modelling a GUI using continuations, which I do as well
08:24:38 <joelr> well, i guess i made a fool out of myself then
08:24:46 <musasabi> A finalizer means "this may be run at sometime in the future when there are no more references if it happens to be a sunny day"
08:25:26 <musasabi> kombinator: Think of an AG as a grammar (declaration of a GUI) together with rules how data will flow from one component to another.
08:25:28 <joelr> musasabi: that's too bad :( i'm still debugging my memory allocation issues (malloc running out of memory)
08:26:15 <joelr> running out of memory on windows that is
08:26:31 * kombinator is still reading WhyAGMatter
08:26:52 <musasabi> joelr: I would just use a dirty approach like using CPP and #define theMallocFunctionIUse SomethingPrintingDebugInfoAndThenMallocing
08:26:59 <dcoutts> gour, yes
08:27:22 <joelr> musasabi: i'm not doing any allocations myself, i'm using the fs library
08:28:02 <gour> dcoutts: i'd like to test osd plugin for xchat-gnome, but don't have svn emerged
08:28:28 <gour> dcoutts: so i thought if you could pull from svn repo and dcc me a tarball
08:28:49 <gour> dcoutts: but if you're too busy, i'm going to emerge svn and do the rest
08:30:34 <chris2> joelr: btw, what happened to the uptick blog?
08:30:36 <dcoutts> joelr, yeah when I use replicate it runs the finaliser but then segfaults :-)
08:30:44 <dcoutts> --- Finalized: 0
08:30:44 <dcoutts> Segmentation fault
08:30:45 <joelr> chris2: it's under trading
08:30:51 <dcoutts> that's a 0 pointer
08:31:11 <chris2> ah, merged. okay, thx. (btw, i think you have a <b> run havoc on the title page)
08:31:12 <joelr> dcoutts: you are talking about the foreign finalizer, right?
08:31:18 <dcoutts> gour, yeah just emerge svn, it's sometimes handy
08:31:21 <dcoutts> joelr, yep
08:31:25 <joelr> chris2: what do you mean?
08:31:33 <gour> dcoutts: yup
08:31:47 <joelr> dcoutts: musasabi reported that things run fine for him with replicate and everything
08:32:05 <joelr> dcoutts: but i believe he was using my code as posted, with the regular finalizer
08:32:12 <dcoutts> installFinalizer fps@(P.PS fp _ _) =
08:32:12 <dcoutts>     addForeignPtrFinalizer finalizer fp
08:32:12 <dcoutts> foreign import ccall unsafe "finalizer"
08:32:12 <dcoutts>   finalizer :: FinalizerPtr Word8
08:32:13 <chris2> joelr: it's all bold after the second post
08:33:22 <joelr> joelr: i'll fix, thanks
08:33:36 <joelr> chris2: that's a thanks to you
08:34:09 <chris2> yw
08:34:10 <reddi> in the following line i want to compare xs instead of 1 with EVERY element of a list...... stimmendrehen_knd wahlvorschlag stimmzettel = [x|x<-filter (\xs -> head xs ==1 ) stimmzettel]
08:34:13 <reddi> how do i perform this?
08:34:51 <joelr> chris2: fixed
08:34:59 <joelr> dcoutts: what do you make of that segfault?
08:35:08 <reddi> do i perform that simply with map?
08:35:10 <dcoutts> joelr, the ForeignPtr is null
08:35:10 <chris2> great
08:35:10 <Cale> any (==1) xs ?
08:35:22 <Cale> or perhaps all (==1) xs
08:35:26 <joelr> dcoutts: why would it be?
08:35:29 <dcoutts> joelr, perhaps I've got an old version of the FPS lib
08:35:42 <joelr> dcoutts: old version? hmm
08:35:49 <Cale> reddi: does either of those say what you want?
08:35:50 <joelr> dcoutts: then i've got he old version too?
08:36:13 <Cale> 1 `elem` xs
08:36:20 <reddi> cale: no, cause 1 is not fix.... instead of  1 shall be the list
08:36:57 <Cale> reddi: are you trying to check if two lists have a non-null intersection?
08:36:57 <joelr> dcoutts: i have the latest
08:37:16 <joelr> dcoutts: i just tried pulling the patches
08:38:04 <Cale> @eval any (`elem` [1,2,3,4,5]) [7,4,9,10,14]
08:38:05 <lambdabot> True
08:38:11 <Cale> @eval any (`elem` [1,2,3,4,5]) [7,8,9,10,14]
08:38:13 <lambdabot> False
08:38:46 <reddi> cale: let me think a bit ....
08:38:47 <Cale> @eval intersection [1,2,3,4,5] [7,4,9,10,3]
08:38:48 <lambdabot>  Not in scope: `intersection'
08:38:52 <Cale> @eval Data.List.intersection [1,2,3,4,5] [7,4,9,10,3]
08:38:53 <lambdabot>  Not in scope: `Data.List.intersection'
08:38:57 <Cale> @eval List.intersection [1,2,3,4,5] [7,4,9,10,3]
08:38:58 <lambdabot>  Not in scope: `List.intersection'
08:39:00 <Cale> hm
08:39:02 <Cale> oh
08:39:07 <Cale> @eval intersect [1,2,3,4,5] [7,4,9,10,3]
08:39:08 <lambdabot> [3,4]
08:39:17 <finnw> Anyone familiar with the book "Functional Programming & Parallel Graph Rewriting" ?  (ch4 in particular)
08:39:42 <kombinator> musasabi: you want to AGs, which I still don't understand, for your GUI, but let me ask you a question: Let's say you want to have two widgets that share the same model - thay may be two text entries that contain the same text, or two treeviews. How would you express that? In my case I have to connect the output of widgets to the model and the output of the model back to the widgets and send some ugly events back and forth.
08:40:17 <joelr> dcoutts: also, how would a null pointer matter if you are just printing it?
08:40:31 <kombinator> musasabi: 'you want to use AGs' of course
08:41:20 <lisppaste2> Calister annotated #13254 with "allocate 2" at http://paste.lisp.org/display/13254#1
08:43:23 <musasabi> kombinator: I would distinguish them by their position (and I can give names to positions).
08:44:29 <kombinator> musasabi: but how would you specify if they use the same model or not?
08:44:38 <reddi> the problem is that any needs two lists
08:45:00 <reddi> and i have to compare a number with a list of numbers
08:45:23 <Beelsebob> how does one deal with conflicts in files with darcs?
08:45:25 <reddi> if it is true in one or more than one cases (like the semantics of any) then it shall be true
08:46:10 <reddi> so i need the [ and the ] ;-)
08:46:31 <musasabi> kombinator: by their attributes?
08:48:01 <reddi> ok, i have done it, i dont need help for the moment ;-)
08:49:51 <dcoutts> joelr, the printing works ok of course. But the freeing will fail.
08:50:17 <joelr> dcoutts: you are not calling unsafeFinalize, are you?
08:50:22 <kombinator> musasabi: ok, this is beyond my understanding. Could you hand me some pointers about AGs you are talking about?
08:50:29 <joelr> dcoutts: you are forcing collection by replicating the list, right?
08:51:01 <dcoutts> joelr, I'm not calling unsafeFinalize
08:51:12 <dcoutts> joelr, I am  forcing collection by replicating the list
08:51:26 <joelr> dcoutts: then it sounds like a bug to me
08:51:40 <dcoutts> joelr, there is already a finaliser attached to each FPS which frees it
08:52:12 <joelr> dcoutts: are you freeing the pointer in your foreign finalizer? because i'm just printing it
08:52:26 <joelr> and haskell wouldn't be freeing the pointer twice, would it?
08:53:24 <Cale> reddi: any only needs one list, and a predicate
08:53:28 <Cale> @type any
08:53:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:53:46 <Cale> It tells you if that predicate holds for any of the values of the list.
08:53:55 <musasabi> kombinator: I will try to write something in the next week about my idea. (I don't know a paper using the technic for anything)
08:54:02 <joelr> dcoutts: i mean, the haskell finalizer prints just fine (i tried it the way musasabi did it) whereas the foreign finalizer fails
08:55:02 <musasabi> kombinator: I'll try to get something done and give you a link (feel free to bug me), but having been sick I have to work tonight and on monday.
08:56:04 <kombinator> musasabi: thanks, no prob
08:57:53 <paolino> can I avoid the indirerction in the instance here ? http://42.vg/85691
09:00:44 <Beelsebob> gyargh!
09:00:50 <Beelsebob> why doesn't darcs send work?
09:01:54 <dcoutts> Beelsebob, have you got local mail working? darcs send uses the sendmail command
09:02:16 <Beelsebob> dcoutts: it seems to work if I send to me, but if I send to shackell@cs.york.ac.uk he never gets it
09:08:47 <reddi> what does the \ mean in  filter (\xs -> head xs==1 ) [[1,2,3]]    and how do i give my own predicate in filter?
09:10:24 <neologism> thats lambda
09:11:57 <Korollary_> reddi: http://www.haskell.org/tutorial/functions.html
09:18:03 <dcoutts> Beelsebob, you're probably not got local mail forwarding to your smtp server
09:18:13 <Beelsebob> hmmm, possibly
09:18:13 <dcoutts> so you can deliver local mail but not non-local
09:18:24 <Beelsebob> how would I set that up?
09:18:24 <sh10151> has anyone considered cdecl for Haskell?
09:18:30 <dcoutts> Beelsebob, what local mail are you using?
09:18:38 <Beelsebob> dcoutts: buh?
09:18:40 <Beelsebob> OS X?
09:18:41 <Beelsebob> *g*
09:18:49 <Beelsebob> it's just a default setup
09:18:49 <dcoutts> oh, hmm
09:19:03 <dcoutts> what package is the sendmail command part of?
09:20:15 <Beelsebob> postfix
09:20:43 <dcoutts> ah ok, then you need to fiddle with the postifx config to specify a forwarding smtp server
09:20:51 <dcoutts> or perhaps OSX has a GUI for that
09:21:01 <reddi> how can i compare the head of the list with a list (like in ANY) in the following statement filter (\xs -> head xs==1 ) [[1,2,3]] (instead of 1 there should be a list....)
09:21:02 <neologism> should be trivial to set up postfix to relay all mails
09:21:27 <finnw> sh10151: cdecl the prototype translating tool, or cdecl the function calling convention?  or something else?
09:22:22 <Beelsebob> dcoutts: I don't think so... unless it's configured by the OS X mail client
09:22:47 <sh10151> finnw: cdecl the prototype translating tool
09:23:26 <sh10151> i think it'd be much more useful given the richer static analysis possible in Haskell
09:24:00 <sh10151> and I don't think I mean just translating the type signatures
09:24:18 <sh10151> since it's purely functional I think you could glean more from the definitions themselves
09:24:47 <sh10151> possibly related to haddock in some manner
09:25:18 <finnw> I doubt you'd get far analysing recursive definitions
09:26:13 <sh10151> ah, you mean in less trivial cases?
09:26:14 <Lemmih> Good morning, #haskell.
09:26:30 <sh10151> i think in easy ones you wouldn't need to actually recurse
09:26:47 <sh10151> plus who codes explicit recursions in haskell anyway? ;)
09:27:37 * waltz hides
09:27:39 <gour> Lemmih: morning or evening? how are you, Lemmih
09:27:39 <ValarQ> Lemmih: g'deve
09:30:52 <kombinator> anyone uses HSQL + sqlite3? My GHC can't link the resulting objects when I try to use it
09:31:14 <kombinator> it seams it tries to use -lsqlite instead of -lsqlite3
09:31:44 <Lemmih> gour: evening, and I'm great. you?
09:32:32 <finnw> sh10151: of course you need to be able to describe the type in english for that to be any help anyway :-)
09:33:08 <sh10151> finnw: well, hopefully many types are well-named
09:33:24 <sh10151> finnw: i also envision some kind of hyperlinking to human-generated documentation
09:34:06 <Korollary> wow, a lot of Knuth videos
09:34:21 <sh10151> just seems to me that it might be more effective to generate text prose from the PL, rather than to have a person write and rewrite it
09:34:34 <sh10151> or horror of horrors, design the PL to be "easy to read"
09:35:47 <sh10151> this thinking largely comes from the haddock output that consists of nothing more than hyperlinked type signatures :)
09:36:26 <gour> Lemmih: a little bit excited after I moved from kde to gnome :-)
09:36:27 <sh10151> in theory more analysis can be done on those functions
09:37:08 <gour> Lemmih: hoping there will be a bright future and haskell can catch much more with gtk2hs, hIDE, hs-plugins etc.
09:37:44 <gour> Lemmih: just my personal skills are still crippled, cannot find enough time to dive in and cover that craft book
09:39:42 <Lemmih> It sad that the hIDE development has stalled /-:
09:40:40 * dcoutts has finnished releaseing gtk2hs 0.9.10 so should be less busy
09:41:28 <sh10151> emacs 4ever :-P
09:41:38 <gour> Lemmih: it's ok while it's not abandoned
09:42:02 <resiak> dcoutts: Now make Debian packages!
09:42:04 * resiak hides.
09:45:41 <aleator__> speaking about .debs. Ubuntu ghc6-hpengl says version 6.4 but installs 6.2.2..
09:48:21 <finnw> Just noticed the channel topic (and the ICFP contest reference)
09:49:23 <finnw> (again) Anyone familiar with the book "Functional Programming & Parallel Graph Rewriting" ?  (ch4 in particular)
09:49:33 <joelr> i'm trying to build cabal under Windows and it barfs on preprocessor directives
09:49:47 <joelr> it does have CPP in extensions: , though
09:49:50 <joelr> any ideas?
09:51:15 <eivuokko> I think something like runghc -cpp Setup.lhs foo
09:52:20 <joelr> eivuokko: that worked, thhanks. i would have thought the CPP extension would do that automatically
09:52:42 <joelr> strangely, i don't think adding -cpp in the ghc-options in Cabal.cabal helped
09:52:58 <eivuokko> joelr, Uhm, the problem is that when you run Setup.lhs from Cabal root, it uses repo version, not installed CAbal.
09:53:17 <joelr> eivuokko: so what happens then?
09:53:22 <eivuokko> So, it barfs while compiling Setup.lhs
09:53:27 <joelr> ah
09:54:02 <eivuokko> There is a mention somewhere to move Distribution directory or something, but I just added -cpp to commandline opts
09:56:08 <joelr> eivuokko: so how do you install this beast?
09:56:26 <joelr> eivuokko: running runhaskell -cpp Setup.lhs configure built everything
09:57:11 <dcoutts> resiak, actually markcot is already making debian packages :-)
09:57:14 <eivuokko> Uhm, that is covered in readme/install or some such file.  If you have ghc (dunno about hugs) that has cabal installed you need to hide/remove old Cabal.
09:57:42 <resiak> Yay!
09:57:57 <joelr> eivuokko: my problem is that i don't have the packages but don't know how to update the package file
09:58:05 <joelr> maybe i just need to reinstall ghc
09:58:08 <eivuokko> Huh
09:58:14 <eivuokko> ghc-pkg works?
09:58:15 <joelr> eivuokko: i reinstalled windows
09:58:29 <joelr> eivuokko: it works and lists a bunch of packages that were in my old user directory
09:58:51 <joelr> eivuokko: it complains when i try to unregister cabal, says there's no such package. it does list it, though
09:59:08 <musasabi> Cabal vs cabal ?
09:59:13 <joelr> yeah
09:59:14 <joelr> stupid me
09:59:18 <joelr> case-sensitive
09:59:30 <eivuokko> Heh, I fell for that one, too.
10:01:47 <joelr> the docs say it should build like a regular cabalized packag
10:01:47 <shapr> finnw: Is that an online available book?
10:01:57 <shapr> finnw: Is that the one by Arvind et al?
10:02:23 <joelr> but when i run configure it says that the package does not export anything. maybe i need to rebuild setup since i just unregistered the old cabal?
10:02:38 <musasabi> joelr: yes.
10:02:50 <shapr> finnw: Hiya long time no see.
10:03:18 <musasabi> joelr: whenever you upgrade cabal: setup clean; del setup; ghc --make -package Cabal Setup.lhs -o setup.exe; setup configure; ...
10:03:33 <joelr> musasabi: ok, redoing
10:07:02 <joelr> i wish troubleshooting memory problems was this straightforward
10:08:33 <joelr> musasabi: i'm rebuilding cabal itself
10:08:51 <joelr> i created setup.exe for cabal which recompiled everything
10:09:08 <joelr> but now when i run setup configure it says that Cabal.cabal does not export any modules or executables
10:09:12 <joelr> how do i install this thing?
10:21:18 <dany2k> is there a possibility in haskell to overload data types?
10:22:33 <fworp> dany2k: what do you mean? give an example.
10:22:49 <finnw> hi shapr
10:23:23 <finnw> shapr: yes its online: http://www.cs.ru.nl/~clean/download/papers/1993/plaseek93/
10:24:56 <joelr> eivuokko: ping
10:25:01 <dany2k> i have an data type Foo in a different module, which i load into my program, but i want to modify this data type. is this possible?
10:26:40 <fworp> dany2k: nope
10:26:40 <shapr> finnw: I haven't read it, but, do you have a specific question/
10:26:41 <shapr> ?
10:26:59 <shapr> dany2k: Huh?
10:27:41 <dany2k> fworp, thx, that what i wanted to know...
10:27:58 <fworp> dany2k: what you probably want to do is make a typeclass, and rather than modify the original type, use the type classes interface, and use new instances
10:28:26 <finnw> shapr: I was trying to make sense of the "Discriminating Positions Strategy" (pp133-5)
10:28:34 <fworp> otherwise, changing the implementation of the type will likely break other code that uses it
10:28:46 <fworp> (which is probably why its not allowed)
10:29:15 <xerox> I saw you people talking about ACM a lot in the past.  I'm wondering what is about this, and if I could grab it in some way: http://portal.acm.org/citation.cfm?id=558859&dl=ACM&coll=portal
10:29:37 <dany2k> fworp, thx, thats a cool idea...
10:31:15 <shapr> finnw: Btw, have you seen Urban Boquist's GRIN ?
10:31:39 * xerox waves the hands in the air
10:31:46 <shapr> hi xerox
10:31:54 <xerox> shapr: tell me about ACM, please
10:32:42 <shapr> Many academic publishing companies require that the authors give their copyright to the publishing company in order to have a research paper published.
10:32:59 <shapr> Then the ACM puts those online and you can buy a subscription to read the published material.
10:33:23 <shapr> You can see the "Full Service" link at the top of the page.
10:33:33 <xerox> Right.
10:33:35 <finnw> shapr: no - will google now
10:33:52 <xerox> Do you think the "Limited Service" will let me read that fabulous thing?
10:34:22 <shapr> xerox: No clue. I stay away from companies that I have to pay to read research that I've already payed for.
10:34:31 <xerox> Sob.
10:34:40 <xerox> I really want to read it.
10:34:47 <shapr> I want to read lots of stuff at ACM also.
10:35:01 <shapr> But to me it's like paying Sony for their rootkit efforts.
10:35:16 <aleator__> ask some university student. They usually have access.
10:35:21 <xerox> :(
10:35:24 <kpreid_> somewhat silly question: is there a better way to write this?  nthIter n f x = iterate f x !! n
10:36:28 <shapr> @pl nthIter n f x = iterate f x !! n
10:36:29 <lambdabot> nthIter = flip (flip . ((!!) .) . iterate)
10:36:36 <shapr> Whoops, maybe not.
10:36:39 <kpreid_> :)
10:36:43 <kpreid_> already tried that
10:37:01 <{Arias}> @type flip
10:37:02 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
10:37:49 <shapr> finnw: You may also be interested in Attribute Grammars. - http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
10:40:40 <Techniks> @eval map length ["Clear", "Spot"]
10:40:41 <lambdabot> [5,4]
10:42:15 <lisppaste2> Calister annotated #13254 with "allocate 3" at http://paste.lisp.org/display/13254#2
10:43:22 <xerox> shapr: but in the end, the authors are cooperating with ACM, or are they strictly needed to do that, in order to get published?
10:44:11 <finnw> shapr: seems to be closely related to abstract reduction (described in the FP&PGR book)
10:51:55 <shapr> xerox: In many (most?) cases they are required to hand over their copyright.
10:52:46 <xerox> More sadness.
10:53:09 <shapr> finnw: Have you seen "Implicit Parallel programming with pH" by Arvind et al?
10:54:36 <shapr> finnw: Depending on what you're doing, nested data parallelism might be worth researching as well.
10:58:22 <finnw> shapr: I'm trying to transform an assembly-like language to a term or graph based language, so I can detect and optimise certain patterns.
10:59:11 <finnw> shapr: I did something similar for an undergrad project (translating from java bytecode) but without optimisation
10:59:22 <shapr> I don't know anything about that. But I would assume that gcc does something similar with its SSA intermediate format.
10:59:48 <shapr> Once you get an SSA-style format, GRIN and related research will work for you.
11:08:06 <xerox> Do you think having lambdabot answering "lambdabot: wiki HaskellDemo" with the appropriate @command, and "lambdabot: how are you" with vixen would be confusing?  I think I'd like it.
11:10:57 <Techniks> how do i get user input in haskell?
11:11:24 <xerox> @docs System.IO
11:11:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
11:11:27 <xerox> Look up there -^
11:12:36 <Techniks> n <- getLine
11:12:38 <Techniks> does that work?
11:13:41 <Lemmih> It's a valid Haskell statement, if that's what you meant.
11:16:23 <Techniks> yeah thats what i meant
11:16:26 <xerox> Not simple, now that lambdabot tries to guess.. mmh.
11:17:00 <xerox> @qwertyuiop
11:17:00 <lambdabot> Unknown command, try @listcommands.
11:17:20 <xerox> lambdabot: @elgoog
11:17:21 <lambdabot> Unknown command, try @listcommands.
11:18:40 <Techniks> printInput
11:18:41 <Techniks>  do =
11:18:41 <Techniks>    putStrln = "Enter your favourite number:"
11:18:41 <Techniks>    n <- getLine
11:18:41 <Techniks>    putStrln = "You entered " ++ n
11:18:42 <Techniks> ?
11:19:10 <basti_> Techniks: thats looking good.
11:19:22 <basti_> almost.
11:19:22 <xerox> printInput = do
11:19:23 <xerox>   putStrLn "Write: "
11:19:23 <xerox>   n <- getLine
11:19:23 <xerox>   putStrLn ("You entered " ++ n)
11:19:23 <basti_> ^^
11:23:24 <Techniks> it says unexpected =
11:23:25 <Techniks> hehe :p
11:23:35 <xerox> I gave you the correct one
11:26:48 <jumboi> hello
11:26:53 <xerox> Howdy.
11:27:11 <jumboi> is here someone wh could help privately :)?
11:27:24 <xerox> You can freely ask here, people is usually helpful :-)
11:27:55 <DoubleCali> (shh.. xerox is a good helper ^_^ )
11:29:10 <jumboi> well.. i have a little script. but i want it change a little.. you can find it here http://boro.ee/a.txt   ... The first line is working scripti. but i want it to change to bottom scripti.. :S can't explain it better
11:29:48 <jumboi> bottom script must work like first line :>
11:30:23 <Techniks> printInput = do
11:30:24 <Techniks>    putStr "Odd Number Checker 1.4 by Ben Smith (T/F) :"
11:30:24 <Techniks>    n <- getLine
11:30:24 <Techniks>    putStrLn isOdd(n)
11:30:24 <Techniks> isOdd :: Int -> Bool
11:30:24 <Techniks> isOdd n
11:30:26 <Techniks>    | ((n `mod` 2)==0) = False
11:30:28 <Techniks>    | otherwise = True
11:30:32 <Techniks> how do i fix this type error
11:30:34 <Techniks> as n is IO hehe
11:30:48 <jumboi> dropWhileRev (>3) [1,7,3,5,2,4,7,6]  ==>  [1,7,3,5,2]
11:30:55 <Lemmih> putStrLn (isOdd (read n))
11:31:01 <jumboi> xerox, can you help me ?
11:31:12 <xerox> jumboi: sure.  Well, b = [].
11:31:14 <Lemmih> Techniks: A haskell tutorial would tell you stuff like this.
11:31:31 <xerox> jumboi: also, f = (\x xs -> if p x && null xs then [] else x:xs), if you will.
11:31:36 <xerox> jumboi: but there are better ways to write it.
11:31:55 <jumboi> like ?:)
11:31:58 <Lemmih> Techniks: print (isOdd (read n)), actually.
11:32:08 <xerox> jumboi: like:
11:32:09 <xerox> f x xs | p x && null xs = []
11:32:09 <xerox>        | otherwise      = (x:xs)
11:34:06 <xerox> ...back to lambdabot hacking.
11:34:10 <jumboi> tanx xerox
11:34:16 <xerox> jumboi: you're welcome.
11:34:16 <jumboi> thanx :)
11:34:24 <xerox> 'Thanks' :-)
11:34:59 <Techniks> what is meant by this
11:35:00 <Techniks> lexical syntax, the context-free syntax or the semantics of the language.?
11:40:07 <DoubleCali> xerox.. my deallocate might be not pretty... but its nearly done ^_^ .. its just a lil bug still in it.. but i will get rid of that too
11:44:46 <Oejet> Does Gtk2HS work with Haskell scripts?  I'm too lazy to find out myself, I guess.
11:53:21 <Lemmih> Oejet: Yep.
11:54:29 <Oejet> Lemmih: Wow, so I could make an "interpreted" Gtk GUI in Haskell?
11:54:41 * Oejet knobs his eyes.
11:54:59 <Lemmih> Well, you interpret your Haskell program.
11:59:25 * Oejet is pondering making a GUI for the stupid tree content manager, Git.
12:00:14 <Korollary> aptly named
12:00:16 <Oejet> There is still a niche, since the one included in the distribution is Tcl/Tk, and the second one uses Qt.
12:04:53 <joelr_> i can't build wxHaskell on mac osx. has anyone here tried?
12:22:04 <ski_> Techniks : ping
12:38:34 <jumboi> need help http://boro.ee/b.txt  i must define  f and b, so that my "picture" will rotate 90' . anyone ? :)
12:39:08 <basti_> jumboi: that looks like a homework problem.
12:39:35 <jumboi> so it looks :S
12:39:42 <gour_> exercises from thompson's book
12:39:51 <jumboi> woot ?
12:40:16 <jumboi> who is thompson ?
12:40:21 <reddi> hi basti_ ;-)
12:40:31 <gour_> @where craft
12:40:31 <lambdabot> I know nothing about craft.
12:40:43 <Techniks> lexical syntax, the context-free syntax or  semantics of a language.?
12:40:47 <gour_> @where books
12:40:48 <lambdabot> I know nothing about books.
12:40:53 <Techniks> can anyone help me to understand better these terms
12:40:53 <Techniks> ?
12:41:15 <gour_> jumboi: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
12:41:58 <jumboi> first time seeing this book
12:42:51 <gour_> jumboi: there you have such exercises, this 'picture' stuff is going through the whole book
12:42:54 <Lemmih> jumboi: Have a look at Data.List.transpose
12:43:52 <reddi> can someone explain me how to write this statement filter (\xs -> head xs==1 ) [[1,2,3]] for comparing the head of the list with a list (and to be filtered if there is at least one true comparison -> e.g. compare the HEAD of the given list with [1,5,7] is FILTERED cause the head of [ [1,2,3]] (=1) is in [1,5,7]?
12:44:32 <reddi> i dont know why  i cannot use an any statement
12:44:39 <reddi> [maybe i am to stupid ;-(]
12:45:57 <Lemmih> Comparing a number with a list doesn't make sense.
12:46:47 <reddi> hm in my case it makes sense, maybe my "algorithm" is not the best one....
12:47:29 <Lemmih> reddi: When would a number be equal to a list?
12:47:49 <reddi> a number would be IN a list
12:47:58 <reddi> i will explain to you
12:48:09 <Lemmih> @eval 10 `elem` [1..20]
12:48:10 <lambdabot> True
12:48:14 <Lemmih> @eval 100 `elem` [1..20]
12:48:15 <lambdabot> False
12:48:36 <Lemmih> That doesn't mean that 10 is equal to [1..20]
12:48:47 <Lemmih> @filter (
12:48:47 <lambdabot> Unknown command, try @listcommands.
12:49:24 <Lemmih> @filter (\xs -> 1 `elem` xs) [[1,2,3]]
12:49:24 <lambdabot> Unknown command, try @listcommands.
12:49:30 <Lemmih> tsk.
12:49:37 <Lemmih> @eval filter (\xs -> 1 `elem` xs) [[1,2,3]]
12:49:38 <lambdabot> [[1,2,3]]
12:49:52 <Lemmih> @eval filter (\xs -> 1 `elem` xs) [[1,2,3],[2,3,4]]
12:49:54 <lambdabot> [[1,2,3]]
12:50:20 <Lemmih> Is that what you want?
12:50:31 <reddi> not really... i will explain!
12:51:37 <reddi> i have a list of lists [[2,1,3],[3,4,1],[2,1],[1,2,3],[2,3,1]] and i want to compare the head of each list with another list e.g. [1,2] - in every list of list, where the head is either 1 or 2 i want to make some modifications on the inner list..... in the other case i want to simply pass the list [e.g. if there is 3 as the head]
12:53:08 <Lemmih> @eval map (\xs -> if head xs `elem` [1,2] then 0:xs else xs) [[2,1,3],[3,4,1],[2,1],[1,2,3],[2,3,1]]
12:53:09 <lambdabot> [[0,2,1,3],[3,4,1],[0,2,1],[0,1,2,3],[0,2,3,1]]
12:53:51 <reddi> that is great ;-)
12:53:56 <reddi> i am not familar with the lambda
12:54:08 <reddi> what is the special on the symbol \?
12:54:21 <reddi> is that explainable in a few words
12:54:27 <reddi> or do i have to read documentation?
12:54:30 <Lemmih> @eval (\x -> x+1) 10
12:54:31 <lambdabot> 11
12:54:41 <Lemmih> It an unnamed function.
12:54:51 <SamB> reddi: it vaguely resembles a real lowercase lambda
12:55:54 <Lemmih> @eval let fn xs = if head xs `elem` [1,2] then 0:xs else xs in map fn [[2,1,3],[3,4,1],[2,1],[1,2,3],[2,3,1]]
12:55:55 <lambdabot> [[0,2,1,3],[3,4,1],[0,2,1],[0,1,2,3],[0,2,3,1]]
13:02:25 <ValarQ> @eval [(x,y) | x <- [1..5], y <- [1..5], (x `mod` y) > 0]
13:02:26 <lambdabot> [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,2),(3,4),(3,5),(4,3),(4,5),(
13:02:26 <lambdabot> 5,2),(5,3),(5,4)]
13:18:55 <ProfTeggy> G'Evening.
13:19:20 <skew> good afternoon
13:19:28 <neologism> its night in .de ;)
13:20:04 <skew> and noonish in .ca.us
13:20:25 <skew> are you up to anything interesting?
13:21:00 <skew> I'm coding up languages from TaPL, and trying to use McBride and McKinna's syntax technology along the way
13:22:04 <fnord123> studying finance
13:22:49 <ProfTeggy> Became a father the 2nd time today.
13:23:05 <ProfTeggy> Well, only once today, but twice overall
13:26:13 <Korollary> ProfTeggy: Congratulations dood !
13:26:49 <ProfTeggy> Thank you :-)
13:27:06 <Korollary> Girl/boy ? name ?
13:27:52 <ProfTeggy> A boy, Erik.
13:28:10 <Korollary> May he live long and well
13:28:18 * ProfTeggy smiles.
13:28:20 <cinema> skew, what precisely are you doing with TaPL ( I coded things too)
13:28:34 <skew> Congratulations
13:28:47 <ProfTeggy> Thank you, guys.
13:28:49 <skew> cinema: writing interpreters and typecheckers
13:28:56 * Speck got TaPL from his school's library and he doesn't know what to do with it.
13:29:03 <skew> put it in your head!
13:29:13 <Speck> reading it doesn't seem to be enough
13:29:26 <Speck> I should get lecture slides or something to go along with it
13:29:29 <cinema> skew, I have begun to translate some of Tapl's code
13:29:44 <pejo> Speck, the exercises are quite good. The recommended ones shouldn't take too long.
13:29:49 <skew> worked for me, but I had been using Haskell for a while, so I had some background
13:29:57 <skew> I think I was taking a class too
13:30:02 <Speck> pejo: thanks for the advice -- I guess I really do need to just sit down and try to understand it
13:30:15 <cinema> skew, precisely, the fullfomsubrec from ocaml to Haskell -- and it works
13:30:35 * Speck shuffles off to reheat food
13:30:51 <pejo> ProfT, grats!
13:31:05 <ProfTeggy> pejo :-)
13:31:09 <skew> I'm writing things from scratch
13:31:24 <cinema> good exercise !
13:31:42 <skew> I read Daan's papers on MLF and extensible records, but realized I don't know how to implement that stuff
13:31:47 <DoubleCali> grats ProfTeggy
13:31:48 <cinema> in fact the whole thing is constructed via the TinkerType system
13:31:48 <DoubleCali> :)
13:32:03 * DoubleCali just saw it after scrolling up
13:32:21 <cinema> skew, yes, MLF seems the right way to go -- once you understand it fully
13:32:55 <skew> I think I've read the rules right, I just don't know how to implement unification and the syntax manipulation
13:33:32 <cinema> I'll try to reread Daan's paper tomorrow
13:33:46 <skew> or, I can't start running into understanding problems until I can start implementing
13:34:20 <skew> I don't know how substitution should get along with DeBruijn indices
13:34:37 <cinema> This is hard stuff
13:35:22 <skew> I was trying to figure out how his first class and his scoped labels might get along
13:36:14 <skew> But I decided that most of the motivating examples of first class labels used row equality quantifiers, and most of the point of scoped labels was to do extensible records without quantified types
13:36:54 <skew> Speck: I'll see if I can find some slides
13:38:26 <Speck> skew: ack. thanks!
13:40:27 <skew> http://www.cs.caltech.edu/%7Ejyh/classes/cs101/cs101c/2002/index.html
13:42:05 <skew> wait, substitutions only affect free variables
13:42:17 <Speck> skew: that's a great link
13:42:29 <skew> That's the class I bought the book for
13:43:06 <Speck> looks fun -- I wish the cs dept. at jhu would be more into PLT
13:43:21 <skew> the one at Caltech wasn't particularly, just this one guy
13:45:40 <pejo> skew, seems the mojave project has a few postdocs though.
13:46:38 <cinema> Funny, I am precisely translating ocaml code from the Mojava project in Haskell
13:47:00 <cinema> It is a very insteresting project (mcc)
13:47:19 <cinema> But there is a lot of code
13:48:46 <skew> I thoght they had a new compiler which was supposed to be not very much code
13:49:30 <jumboi> @libsrc Data.List
13:49:31 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
13:49:45 <skew> A core of meaning-preserving transformations in a theorem prover, which needed to be verified, and then lots of tactics in terms of the primitive rules that were automatically safe because just use compositions of safe operations
13:49:47 <cinema> The version 0.5.3 includes many aspects of a full-blown compiler
13:50:21 <cinema> and the possibility to check some things with a theorem prover
13:51:10 <cinema> The code is at http://mojave.caltech.edu/download/mc/0.5.3/mcc-0.5.3.tar.gz
13:54:13 <reddi> can i set the recursion deep?
13:54:31 <skew> for type class resolution? GHC has some option
13:54:32 <reddi> e.g. if there are 10 rec. of the same function i give an default output?
13:54:49 <skew> oh, you need to do that yourself
13:55:23 <reddi> and how can i count the number of iterations? i have to put an additional parameter, do i see that right?
13:55:29 <skew> yes, that's right
13:56:10 <skew> you might want to make the definition with the extra parameter a local definition, and have the exposed version of the function start the parameter at 0
14:00:11 <reddi> http://pastebin.com/419854 i get ERROR "e:\uni\funktionale programmierung\3\Aufgabe3.hs":134 - Syntax error in expression (unexpected `)')   which is the las line with otherwise
14:00:34 <reddi> why do i get this error?
14:01:17 <skew> ++ is a binary operator
14:02:27 <skew> it+1 will work better
14:02:49 <skew> then I think you will have a problem with ((a,b),c) being distinct from (a,b,c)
14:02:58 <reddi> i know ;-)
14:03:01 <reddi> LOL
14:03:06 <reddi> and how do i get rid of that problem?
14:03:34 <skew> the easiest way is to make the argument type you expect also ((a,b),c)
14:03:55 <skew> neue_runde ((wahlvorsschlag,stimmzettel),it) = ...
14:04:28 <reddi> ok,  i will try
14:04:40 <xerox> |length "wahlvorsschlag"| is usually the sum of the length of all my variables in a program for me, hehe.
14:11:03 <DoubleCali> lol
14:12:00 * boegel|home pokes shapr
14:12:15 <joelr> Cale: ping
14:13:09 <boegel|home> shapr: I have an idea for a neat series of articles for TMR, ping me when you see me, ok ?:)
14:13:13 <vigen> hi all, beginners question: My tree is "data Tree a = Node (Maybe (Tree a)) a (Maybe (Tree a))
14:13:13 <vigen> "
14:13:46 * boegel|home poofs
14:13:48 <vigen> I want to show the tree, but cannot foind out how. Any idea?
14:13:58 <zacch> derive from Show
14:14:02 <skew> add "deriving Show" to the end of the definition
14:14:15 <vigen> I did:  showTree Nothing = "?"
14:14:27 <vigen> and showTree (Just (Node l a r )) = ...
14:14:50 <skew> try show (Node Nothing 12 Nothing)
14:14:58 <vigen> but this is not correct " Instance of Num [Char] required for definition of showTree"
14:15:38 <skew> put "deriving Show" on the end of the defintion line, and the compiler will make a function show :: Tree a -> String
14:15:58 <vigen> skew: thanks. I wil try
14:16:32 <xerox> Hey guys.  I'm missing how to do this: http://boro.ee/b.txt  if keera = transpose, the arrows get pointing the opposite, horizontal, direction.
14:20:04 <skew> that's why the skeleton uses foldl rather than foldr
14:22:02 <skew> if you want a hint, do some type checking and partial evalution
14:23:06 <skew> like, keera [" # ","###"] = f (f b " # ") "###" == ["# ","##","# "]
14:24:01 <skew> keera [" # "] == [" ","#"," "], so f [" ","#"," "] "###" = ["# ","##","# "]
14:24:03 <skew> etc
14:26:41 <skew> yay equational reasoning!
14:27:59 <skew> @pl (\x xs -> if p x && null xs then [] else x:xs)
14:28:00 <lambdabot> ap (ap . flip flip [] . (if' .) . (. null) . (&&) . p) (:)
14:29:15 <DoubleCali> ni ni all
14:31:06 <kpreid_> Is there a RealFloat version of Prelude.mod?
14:34:39 <skew> I'd like to get the derived Show function under a different name, and provide my own prettier output as Show
14:36:01 <skew> actually, I'm not sure I do - having the pretty output under a different name works fine
14:39:04 <joelr> what does this mean?
14:39:05 <joelr> Warning: orphan instances:
14:39:05 <joelr>   instance Script.Pickle.PU (Data.Maybe.Maybe a) = $fPUMaybe
14:41:19 <reddi> can someone tel me why i get an error only on one of the nearly ident lines? http://pastebin.com/419921
14:41:33 <skew> the user's guide describes that - I think an orphan instance is one that is in a different file from the class definition and the definitions of all the types the instance mentions
14:41:40 <araujo> What is a good way to work with regex in Haskell?
14:42:16 <araujo> So far i can see there exist regex libraries , i just was wondering if thre existed more haskellishs ways of doing it ;_)
14:43:05 <ustenzel> araujo: like a combinator library?  try ReadP, it's close enough.
14:43:14 <Cale> well, what are you using the regular expressions for?
14:43:20 <araujo> Thanks ustenzel
14:43:46 <Cale> There's also Parsec which is a pretty decent parsing library
14:44:12 <araujo> Cale, splitting strings like : " foo ; bar ; foo1" = ["foo" , "bar" , "foo1" ]
14:44:14 <Cale> both Parsec and ReadP will parse more than regular languages though
14:44:17 <Cale> ah
14:44:35 <araujo> simple estuff
14:44:40 <skew> http://repetae.net/john/computer/haskell/JRegex/
14:44:55 <Cale> For really simple things, you can usually just write appropriate list functions.
14:45:32 <ustenzel> there really ought to be a library of lexer combinators, like this: http://citeseer.ist.psu.edu/chakravarty99lazy.html, only more standard and more practical
14:45:58 <SamB> ustenzel: there is a library floating around
14:46:01 <skew> I think Yi uses a similar library
14:46:08 <SamB> yeah, Yi uses it
14:46:18 <SamB> in some version
14:46:22 <ProfTeggy> See you all, g'night.
14:46:45 <ustenzel> SamB: there is?  google wouldn't find it, it seems.
14:49:38 <SamB> @google site:www.cse.unsw.edu.au yi regex
14:49:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi/_darcs/patches/20041129005006-9c5c1-11046aeede30d3c4f1ced948a8569ad40243737f.gz
14:49:44 <SamB> nope
14:50:08 <SamB> anyway, grab Yi and look at Yi.Regex and Yi.Lexers
14:50:49 <ustenzel> hm, should have a look at Yi and hIDE anyway.
14:51:58 <ustenzel> in general terms, what would you guys use to parse a C-like language?  #include must be handled and useful error messages would be good.
14:52:21 <ustenzel> Parsec is close, but cannot do the #include
14:53:10 <SamB> ustenzel: well, I would use a C preprocessor for #include...
14:53:48 <ustenzel> after the pp, file names and line numbers are messed up.
14:53:49 <dbremner> ustenzel - there's always packrat parsing.
14:54:31 <ustenzel> unless you create a custom token type.  after that, Parsec.Token ceases to work, which is quite a loss.
14:56:03 <SamB> ustenzel: that is what #line is for
14:56:45 <SamB> and really I'm not so bothered by Parsec.Token's loss as by that of Parsec.Char
14:57:26 <SamB> though I do steal stuff from Token now and then
14:58:01 <ustenzel> somehow using a seperate preprocessor, then to parse #line annotations just to implement #include, feels Just Wrong.
14:58:26 <ustenzel> even more so than doing the include within parsec with a quick unsafePerformIO
15:01:35 <SamB> ustenzel: well, then do the latter...
15:01:55 <SamB> if thats even really necessary...
15:02:09 <ustenzel> I already did.  I just feel dirty now and wanted to know if there's a better way :)
15:02:20 <SamB> which it is, unless parsec has grown a ParserT interface...
15:02:30 <SamB> ustenzel: probably not really.
15:02:55 <SamB> I mean, you could do it safely but it would be even uglier
15:03:18 <SamB> just be glad you don't have to actually parse C!
15:03:42 <ustenzel> not really dirty?  well, I convinced myself that (unsafePerformIO . readFile) is reasonably pure, as I don't write to the file, and I can sleep again now.
15:03:51 <pesco> ustenzel: How do the directives tie into your intenal datastructures?
15:04:27 <ustenzel> case in point is Corba IDL
15:04:43 <pesco> You're parsing OMG IDL?
15:05:04 <pesco> Hm...
15:05:11 <ustenzel> the nutheads actually specified C preprocessing, and there are really interfaces out there that #include after declaring something.  stupid, really.
15:05:23 * pesco nods.
15:05:28 <ustenzel> so there's no way but parsing, including, parsing more.
15:05:50 <sh10151> OMG IDL!!!!1!
15:05:57 <sh10151> sorry, had to be done
15:06:20 <pesco> Ah, ok, I see your problem.
15:07:05 <ustenzel> actually the problem is that the creators of this f**ked up language has prior exposure to C.
15:08:08 <pesco> Actually, I don't find the "preprocess and parse #line" solution all that appaling.
15:09:01 <pesco> What are you doing with CORBA, BTW? Just OOI.
15:09:41 <ustenzel> I wan't to find out why all ORBs are so bloated out of shape.
15:10:09 <ustenzel> (...and I'm trying this to put off more important things.)
15:31:56 <Frederick> yo folks
15:32:14 <araujo> Hola Nomius
15:32:23 <araujo> Hola Frederick
15:32:29 <araujo> Hola CosmicRay
15:32:31 <araujo> :-)
15:32:35 <CosmicRay> hi araujo
15:37:10 * shapr boings
15:37:17 <dons> @yow!
15:37:19 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO
15:37:19 <lambdabot> he
15:37:19 <lambdabot> is ...
15:37:55 <shapr> yay, new hs-plugins integration!
15:38:24 <pesco> ustenzel: I'm afraid the ORBs are so bloated because the specifications are.
15:38:30 <dons> shapr?
15:38:37 <shapr> dons: Have you seen Peter Thiemann's hws+hs-plugins?
15:38:46 <dons> ah, no! maybe I should
15:38:54 <Frederick> hi folks
15:38:56 <dons> he must have solved the problem he had, when he visited us down under
15:39:00 <shapr> dons: http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/#wsp
15:39:11 <CosmicRay> shapr: oh, it's still based on wash?
15:39:14 <shapr> dons: I just got an email from Peter Thiemann about hws+hs-plugins
15:39:15 <ustenzel> pesco: definitely.  but nobody is using the newer features.
15:39:30 <pesco> ustenzel: You might have a point there.
15:39:30 <dons> cool :)
15:39:32 <shapr> CosmicRay: I don't know, but it's hws + hs-plugins.
15:39:38 <ustenzel> pesco: and MICO adds plenty of bloat to that already present.
15:39:50 <shapr> boegel: y0, tell me about your ideas!
15:39:51 <xerox> shapr: that seem very cool!
15:40:01 <CosmicRay> shapr: ahh, " An extended version of Simon Marlow's webserver (hws) that runs WASH modules as servlets."
15:40:20 <shapr> Yes, I'm looking into ajax hs-plugins.
15:40:25 * shapr cackles evilly
15:40:29 <CosmicRay> shapr: nifty
15:40:41 <CosmicRay> shapr: one of these days I will have to look at the non-wash web options
15:40:45 <shapr> Anyway, back to being social with the gorgeous woman behind me...
15:40:51 * shapr &
15:40:54 <xerox> I'm looking into tomorrow's math test... Goodnight, hs-folks!
15:41:08 <Frederick> xerox, good luck
15:41:13 * CosmicRay wonders if shapr's fiancee is reading what he types on irc
15:41:20 <dons> hehe
15:41:30 <xerox> Frederick: thanks!
15:41:31 <dons> he's just a charmer, isn't he
15:41:35 <pesco> I wish hs-plugins would allow saving the evaluator state to disk.
15:41:43 * pesco ponders.
15:41:44 <dons> !!?
15:41:49 <dons> the evaluator state?
15:41:56 <pesco> rts-dump, rts-restore
15:42:01 <dons> ah.
15:42:12 <dons> you mean, I wish ghc would allow a persistent rts
15:42:17 <pesco> Yes.
15:42:19 <SamB> pesco: it would, but GHCi provides no such service, nor can it
15:42:32 <dons> well, with unsafeCoerce# you could do it
15:42:33 <pesco> SamB: Why can't it?
15:42:44 <dons> but hacking the C code would be easier
15:42:50 <SamB> pesco: FFI
15:42:54 <ski_> some other lang implementations allow saving an image, and later loading it and continuing from where it was left ..
15:43:13 <ski_> e.g. SML/NJ
15:43:18 <SamB> well, I suppose it could give you a wholey inmplementation...
15:43:22 <dons> is this useful? what's the `use case', as they say?
15:43:46 <dons> besides skipping initialisation.
15:43:59 <dons> perl does something like this too, iirc
15:44:12 <pesco> I was imagining a monad or something to do what 'make' does. Load file, save derived file. Change original file, changes get propagated automatically.
15:44:23 <SamB> its usefull in smalltalk, but it doesn't seem like it would be too usefull in Haskell...
15:44:37 <dons> since we don't crash that often ;)
15:44:38 <ski_> it can be used to saving the state of the interactive toplevel (having loaded and possibly compiled a bunch of modules)
15:44:59 <dons> ski_, that's easier though. dump the abstract syntax
15:45:04 <dons> ghci could do it
15:45:13 <dons> kind of like our persistent @lambda
15:45:18 <ski_> it can also be used to make stand-alones, sortof, if the impl doesn't allow making normal executables
15:45:18 <dons> @lambda S K K
15:45:18 <lambdabot> Unknown command, try @listcommands.
15:45:28 <dons> oh, that's right, I switched it off
15:45:34 <pesco> dons: Now, obviously I want to keep the information as to how the files were derived between runs of the program.
15:45:36 <ski_> dons : abstract syntax of what ?
15:45:56 <SamB> dons: I'd be happy if GHCi would keep toplevel bindings and modules loaded across :r
15:45:57 <pesco> Basically, I want to save functions.
15:46:02 <dons> oh, sorry, maybe I misinterpreted the 'state of the toplevel'
15:46:14 <ski_> pesco : that sounds similar to adaptive/incremental computation
15:46:17 <dons> SamB, yeah, that would be good
15:46:37 <SamB> dons: even if it failed, though
15:46:40 <dons> but it seems that you could indeed dump the current set of bindings that had been entered at the ghci prompt
15:46:46 <dons> i.e. bytecode
15:46:51 <dons> or abssyntax of that code
15:46:56 <ski_> dons : state of toplevel would here be what modules are loaded (and possibly compiled .. + the compiled results .. byte-code)
15:47:09 <dons> riight. so you want the lot!
15:47:11 <SamB> dons: bytecode doesn't sound like a good idea
15:47:19 <lisppaste2> Frederick pasted "attempt" at http://paste.lisp.org/display/13280
15:47:22 <dons> ghci compiles to bytecode. it could be dumpted
15:47:24 <SamB> what if the modules changed?
15:47:34 <dons> hack
15:47:38 <SamB> then the bytecode might be mistyped, or worse!
15:47:48 <dons> you recheck the interface
15:47:54 <Frederick> huys I still trying to define my free context grammar witout much luck
15:48:13 <ski_> pesco : that saves how a result was computed from an input .. so e.g. if you have a sorting function .. you could later change one element of the input, and only the necessary recomputations would be redone (i.e not resorting other sublists that was not affected)
15:48:28 <ski_> pesco : some attribute grammar systems have theis feature, too
15:49:13 <dons> a persistent ghci would be a cool 4th honours project. hmm...
15:49:21 <ski_> dons : anyway, in the case i was talking about, it would save the entire internal state .. i.e. not reload modules from files when restoring state ..
15:49:24 <dons> s/4th/\& year/
15:49:33 <dons> yep.
15:49:40 <dons> the entire heap, right?
15:49:43 <ski_> yes
15:49:46 <dons> and registers, and threads and all rts state
15:49:54 <dons> sockets..
15:49:58 <ski_> possibly doing some GC to prune away parts that is not accessible
15:50:11 <dons> sockets were hard when making lambdabot persist
15:50:29 <ski_> yes, such resources are problematic, with this
15:50:45 <dons> threads you can stop and start, but not at the same spot, so you lose partially computed values.
15:50:47 <ski_> basically, this feature is like storing a continuation in a file
15:50:50 <Frederick> guys Im trying to use parsec to create a cfg parser can I have some help defining the types? Im having a hard time to code the grammar grammar
15:50:51 <dons> with a rts impl you could do it though
15:51:02 <pesco> ski_: Hm, ok. Well, I'm thinking about this for files a human user is creating. As in, here's the .lhs, make the documentation from it like so... - what make does.
15:51:19 <ski_> simplest way to handle resources would be to make next call to them throw an exception about expired resource
15:51:41 <ski_> one could of course try to reattain the resource first, if possible and reasonable
15:51:55 <ski_> pesco : yes
15:52:07 <ski_> s/reattain/retain/
15:52:51 <dons> @seen joelr
15:52:52 <lambdabot> I saw joelr leaving #haskell 11 minutes and 18 seconds ago.
15:53:02 <ski_> (i think several of the ML implementations as well as schemes and prologs has this feature)
15:53:03 <pesco> ski_: Some of these resource problems would go away if it was done in a complete system, e.g. House, where protocol stack states would be part of the saved image
15:53:07 <SamB> pesco: couldn't you just make the functions capable of writing equivalent information to a file?
15:53:11 <SamB> wouldn't that be easier?
15:53:14 <pesco> (Or all *g*)
15:53:43 <ski_> Frederick : 'cfg parser' ?
15:53:46 <dcoutts> evening dons, how're things?
15:53:53 <pesco> SamB: Possibly, but it would not be The True Way ;).
15:53:58 <ski_> Frederick : you want to parse CFG grammar specifications ?
15:54:58 <Frederick> ski, yup
15:55:08 <Frederick> btw hi ski long time since I saw you last time :)
15:55:32 <pesco> SamB: The problem is, when I introduce some scheme like that, I'm going to be implementing some poor variant of "save function to file", i.e. a bad LISP implementation. ;-)
15:55:41 <SamB> pesco: yes, but we Haskeller's were never too keen on The True Way to begin with
15:55:46 <fnord123> lambdabot: seen joelr?
15:56:21 <SamB> pesco: alternatively, you could use acyclic datastructures
15:56:23 <pesco> SamB: Note the difference between The One Way and The True Way!
15:56:47 <Frederick> ski, basically I need to define a grammar grammar and give input
15:56:50 <beelsebob_> @paste for anyone who didn't see earlier *g*
15:56:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:56:50 <ski_> pesco : see http://citeseer.ist.psu.edu/acar01adaptive.html and http://www.cse.ogi.edu/~magnus/Adaptive/  for adaptive/incremental computation in ML and Haskell
15:57:05 <pesco> ski_: Thanks.
15:57:31 <SamB> Frederick: why don't you just use hs-plugins to load grammars from Haskell modules?
15:57:48 <Frederick> SamB, cause I dont even know what are you talking about
15:57:53 <ski_> (in the latter link, there's a link to an ICFP iirc paper (functional pearl ?) that translates the ML solution into Haskell, as well as adding some ideas)
15:58:03 <SamB> Frederick: you could ask!
15:58:19 <pesco> ski_: Ah, these seem indeed very relevant.
15:58:24 <Speck> main = hGetContents stdin >>= sequence_ $ (map $ print . take 40 . drop 588) . lines
15:58:34 <skew> I'm thinking of handling substitutions by naming free variables with IORefs rather than strings
15:58:35 <Speck> shouldn't that work?
15:58:57 <Frederick> SamB, you know when you are new to someplace and all you can do is run around trying to find the door?
15:59:16 <SamB> Frederick: the door?
15:59:30 <Frederick> SamB, a way out
15:59:48 <ski_> Frederick : can you give some examples of how your CFG specifications can look like
15:59:50 <ski_> ?
15:59:56 <Frederick> ski, sure
16:00:35 <Frederick> 1 sec lemme slocate my book on my room
16:00:39 * Frederick slocates
16:00:48 <ski_> 'slocate' ? :)
16:00:59 * ski_ wonders if that is a unix command
16:01:04 <pesco> I'm off to bed.
16:01:04 <heatsink> XD
16:01:07 * pesco waves.
16:01:18 <heatsink> It means searching and indexing the object space.
16:01:27 <SamB> ski: I think its the GNU version of locate or something
16:01:31 <heatsink> oh wait, that's updatedb.
16:01:37 <ski_> pesco : i don't remmber any link for attribute grammars and incremental computation .. but it's also related
16:01:40 <heatsink> slocate is just searching the database.
16:01:51 <SamB> the command name is just locate anyhow
16:01:58 <ski_> (pesco : don't remember it right now, i mean)
16:02:20 <heatsink> `slocate' for `secure', because the database contains info about directories that non-root users don't have search permissions for.
16:02:27 <pesco> ski_: I don't see the link between grammars and computation...
16:03:01 <skew> it's "secure" as in "if it isn't secure, the machines security is compromised"
16:03:22 <ski_> pesco : not just any grammars .. but "attribute grammars" which could possibly be seen as a declarative programming paradigm
16:04:05 <franka> A grammar is a rewrite system.
16:04:27 <franka> Hence linked to computation.
16:04:32 <pesco> ski_: I see, I know next to nothing about attribute grammars, so I'll try to make a note about that in the back of my head.
16:04:33 <ski_> pesco : basically, an attribute grammar is a kind of modular fold over an algebraic datatype .. and one can automatically determine what to recompute if some part of the input datastructure is changed
16:04:42 <pesco> franka: That's a very general link.
16:05:07 <dons> @uptime
16:05:07 <lambdabot> uptime: 4 days, 18 hours, 55 minutes and 24 seconds
16:05:12 <franka> Yes, I guess so.
16:05:41 <franka> But I dunno why you asked, so...
16:06:11 <pesco> ski_: Okay, that sounds plausible to my uninitiated ears. :) So thanks again for the pointers.
16:06:19 <Frederick> ski, http://rafb.net/paste/results/ay5CrN39.html
16:06:30 <ski_> pesco : there was a 'The Monad Reader' issure on attribute grammars and haskell   (not that i thought it did a very good job of explaining why attribute grammars are cool and good and useful)
16:06:36 <pesco> I have to sleep now, need to learn some algebra tomorrow.
16:06:38 <Pseudonym> Does anyone here have a *nix shell handy?
16:06:43 <pesco> ski_: Right, I remember.
16:06:45 <Frederick> Pseudonym, I do
16:06:52 <Pseudonym> Could you please try: dig @203.30.75.12 lindor.alicorna.net. any
16:06:53 <franka> I'm going too.  Seeya.
16:07:09 <Pseudonym> Trying to debug my DNS server from behind a firewall.
16:07:21 <Frederick> Pseudonym, do you mean ping it?
16:07:27 <Pseudonym> I mean type that command.
16:07:48 <Frederick> Pseudonym, I dont have this programm 1 sec lemme see if I can install it
16:07:55 <Pseudonym> Ah.
16:08:01 <Pseudonym> DiG is part of BIND.
16:09:24 <Frederick> Pseudonym, nind tools for me
16:09:33 <Frederick> im emerging it
16:09:36 <Pseudonym> OK, thanks.
16:09:46 <Frederick> Pseudonym, np
16:09:56 <Frederick> ski_, did you understand my post?
16:11:43 <dcoutts> Woot! Gtk2Hs "Hello world" program is now only 30% bigger than a console "hello world" program
16:12:30 <fnord123> wow
16:12:42 <fnord123> although im sure it links to a showj gtk lib
16:13:00 <dcoutts> yes but that's dynamically linked
16:13:27 <fnord123> is this work for yi?
16:14:48 <dcoutts> no, for gtk2hs generally
16:15:26 <dcoutts> I'm adding support for ghc's -split-objs feature to the Gtk2Hs build system.
16:15:30 <ski_> Frederick : and you want a program to be able to parse this grammar specification (as opposed to parse *using* this grammar specification) ?
16:16:34 <Frederick> ski_, yes step 1 is a program to parse the grammar specification than I need to put it in Chomsky Normal Form ad Greibachs normal form
16:16:51 <dons> dcoutts, if only Cabal also built splitobjs
16:17:08 <heatsink> oh yea, I remember.
16:17:12 <dcoutts> dons, yes it should be possible to do that
16:17:20 <dcoutts> dons, it just needs us to send in the patch
16:17:36 <musasabi> dons: Did you see joelr's fps memory troubles?
16:17:55 <dons> yep. I've replied. not sure what's going on yet, but seems to be Windows-only.
16:18:00 <dons> which makes me highly suspicious
16:18:06 <musasabi> btw why does fps source use mallocArray and mallocForeignPtr (which has a nonstandard definition) - it is kind of confusing.
16:18:13 <dcoutts> dons, I got the same problems on linux
16:18:20 <dons> ah. hmm.
16:18:32 <dons> this code is in darcs too. sounds a bit worrying
16:18:51 <dons> dcoutts, do you have a link to the example?
16:18:55 <dcoutts> I wonder if it would be helpful to be able to specify an estimated size when allocating a ForeignPtr so that the GC can use that when calculating heap pressure
16:19:15 <dons> i've also had problems with use-after-unmap-finalisers on openbsd.
16:19:17 <Frederick> ski, I think I got a very good paper about it im reading it do you mind I mail it so you can check with me? it is not long but seems to give a more straight forward approach
16:19:27 <dcoutts> dons, actually I don't and I deleted my local copy of the code sorry :-(
16:19:35 <dcoutts> dons, but I can tell you what I was doing
16:19:35 <dons> ok. i'll check the logs :)
16:19:40 <ski_> Frederick : why does the specification mention 'G=(V,T,P,S)' twice ?
16:19:56 <dcoutts> dons, he posted some code and we modified it
16:20:30 <dcoutts> dons, we made it add an extra finaliser to the ForeignPtr inside the FPS
16:20:31 <Frederick> ski, the second G = (V,T,P,S) stands just because im defining a grammar there so it is like im initializing that if it wasa program
16:20:42 <dons> an extra finaliser?
16:20:45 <dcoutts> dons, the extra finaliser in C just printed the address of the char *
16:20:46 <dons> that's sounds a bit dodgy
16:20:50 <dons> ah, ok.
16:21:01 <dcoutts> and it printed 0 and then segfaulted :-)
16:21:10 <Frederick> Pseudonym, http://rafb.net/paste/results/4f0LpN29.html
16:21:18 <dons> hmm. this sounds like an rts issue
16:21:34 <dons> perhaps FPS is the first large library to really stress the finaliser system
16:21:48 <dcoutts> so it probably was not the C finaliser that was doing something odd since it dnever dereferenced the char *
16:22:01 <dons> dcoutts, what ghc did you use?
16:22:05 <dcoutts> but the ForeignPtr in the FPS was null. Which is very odd.
16:22:08 <dcoutts> ghc-6.4.1
16:22:37 <dcoutts> it took quite a bit of use of the FPSs to get any of the finalisers to run
16:22:58 <Frederick> ski, maybe something like this is more accutate than my first code http://rafb.net/paste/results/bolh5y63.html
16:23:19 <dcoutts> we had quite a few strings which we packed. But we had to do replicate 100 on it to generate enough GC pressure to get any of the finalisers to run.
16:23:26 <dons> right.
16:23:30 <dons> maybe that value should be tunable
16:23:30 <dcoutts> Restricting the heap size didn't seem to help much
16:23:32 <ski_> Frederick : i'm just thinking .. if you're going to parse grammar specifications, you need to have a clear idea of what form your grammar specifcations should have .. what sections, containing what code .. preferable unambiguous and nonredundant
16:23:57 <dcoutts> dons, +RTS -H${blah}k -RTS
16:24:06 <dons> ah, found the code.
16:24:26 <skew> is it important to do the union/find thing in unification implementations?
16:24:27 <ski_> Frederick : something like that looks usefule, yes
16:24:35 <dcoutts> dons, hence my suggestion that perhaps you should be able to tell the GC the approximate size of ForeignPtr's so that it collects more often
16:24:50 <musasabi> When playing with hsgnutls I found that ForeignPtr didn't help much and had to switch to custom reference counted pointers.
16:25:14 <dcoutts> dons, since at the moment ForeignPtrs do not contribute more that a few bytes to the GC pressure which is not really very helpful.
16:25:14 <dons> hmm. that's interesting musasabi
16:25:53 <dons> ah, this is a real problem
16:25:57 <musasabi> but I had finalizer order constraints which fps probably does not have.
16:27:32 <dcoutts> dons, well actually mallocForeignPtr contributes to GC pressure since it is allocated from the Haskell heap but ForeignPtrs attached to foreign allocations do not contribute anything (except the few bytes for the ForeignPtr itself).
16:28:12 <dcoutts> I've gotta go to bed now
16:28:16 <ski_> (s/pressure/temperature/ :)
16:28:21 <dcoutts> g'night fokes
16:28:51 <dons> hmm. though this is only mmap right? or explicit mallocs
16:29:02 <dons> the mallocForeignPtrs are most common though
16:30:04 <heatsink> How does Haskell's heap coexist with malloc?
16:30:47 <dons> @indexx performGC
16:30:48 <lambdabot> System.Mem
16:31:03 <dons> @index addForeignPtrConcFinalizer
16:31:04 <lambdabot> bzzt
16:31:05 <dons> ?
16:31:25 <lisppaste2> Frederick pasted "refination" at http://paste.lisp.org/display/13282
16:31:43 <Frederick> ski_, take a look on this paste please I think now Im getting pretty close from the right path
16:31:57 <ski_> Frederick : what's 'Symb t nt' ?
16:33:28 <ski_> mhm
16:33:45 <Frederick> ski_, according to the paper Im reading (Im not a haskell expert) it is supposed to mean that a Symbol can be a terminal or a non-terminal
16:33:55 <Frederick> in fact a member of one of that sets
16:34:01 <ski_> m, yes
16:34:08 <ski_> why do you have Root ?
16:34:19 <ski_> why not just use the Symbol that is the root symbol ?
16:34:27 <ski_> also,l what's TermSymb ?
16:34:32 <ski_> s/l//
16:34:53 <Frederick> ski_, root is a special symbol, is the frist production symbol, TermSymbol is my terminal symbol, in fact I dont need it I thin
16:35:36 <Frederick> ski_, the paper Im reading defines a symbol called Dollar (wich is the terminal symbol)
16:35:50 <ski_> what terminal symbol ?
16:36:01 <ski_> ther can be many terminals ..
16:36:42 <ski_> hm .. maybe one could have use of a special nonterminal Epsilon
16:36:51 <dons> hmm. seems quite tricky to get finalisers to run, indeed
16:36:52 <ski_> (empty word)
16:37:21 <Frederick> ski_, I cant use it cause when I start putting the grammar in normal form I will remove Epsilons
16:37:23 <ski_> though, that could actually be defined through a production, at least internally
16:37:29 <ski_> right, ok
16:38:06 <dons> ah, but once memory pressure goes up enough, things get finalised
16:38:08 <ski_> i still don't get why you don't use 'NT root' instead of 'Root'
16:38:42 <ski_> do you need to see that easily that a nonterminal is the root .. if so, why ?
16:38:44 <Frederick> ski, im following this paper -> http://wiki.di.uminho.pt/wiki/pub/PURe/PurePublications/PUReTR041101.pdf
16:38:53 <ski_> looking
16:40:30 <Frederick> ski_, if I get the path using this paper my work is pretty much done
16:40:52 <ski_> aha, it wants to use Dollar and Root, to be able to transform into "Generalized LR Parsing" (the topic of the paper)
16:41:32 <Frederick> hm
16:41:36 <Frederick> so in fact I dont need it
16:42:00 <ski_> so, whether you need Dollar and Root depends on whether you want to follow that paper closely and implement more or less the specific parsing idea there .. of if it just suffices to get some parsing done (not necessarily by the exactly same method as in that paper)
16:43:09 <Frederick> ski_, in fact I think I cant even use that parsing cause the algorithms they gave us in class are CYK and Early
16:43:28 <ski_> ok
16:43:52 <ski_> you just wanted to get some basic structure for your haskell program, i take it then ..
16:43:56 <ski_> (from that paper)
16:44:01 <Frederick> ski_, I want to use CYK if possible
16:44:22 <ski_> might be possible (don't know what CYK is :)
16:44:41 <Frederick> ski_, Cocker-Young-Kasami algorithm
16:44:48 <ski_> m-hm
16:45:24 <Frederick> ski_, http://en.wikipedia.org/wiki/CYK_algorithm
16:45:29 <ski_> so, i guess you should figure out (or be given) a format in which the individual grammar specifications to parse should be in
16:45:49 <ski_> and then you need to start coding some way of parsing that fomat into the Cfg datatype
16:46:16 <Frederick> ski_, I will need to figur out since my teachers never speficy stuff (they are freaking lazy)
16:46:26 <Frederick> ski_, I was looking to use BNF to express the grammars
16:46:44 <ski_> (aha, it's a dynamic programming algorithm .. this could be coded with memoing or with arrays, i think)
16:47:11 <ski_> yes, some BNF variant should prolly be good
16:47:16 <SamB> Frederick: BNF is a step backwards and maybe two steps left also
16:47:17 <ski_> not too hard to parse
16:47:24 <ski_> hm
16:47:35 <ski_> SamB : in what way ?
16:47:51 <SamB> ski_: well, it isn't fun to write!
16:48:01 <Frederick> ski_, but the dynamic programming algorithm is the last step
16:48:07 <Lemmih> Can anyone see why Skaller thinks that the wikipedia page for referential transparency is "totally wrong"?
16:48:09 * Frederick kicks SamB :p
16:48:14 <ski_> Frederick
16:48:16 <ski_> Frederick : ok
16:48:21 <Lemmih> @google wikipedia referential transparency
16:48:22 <lambdabot> http://en.wikipedia.org/wiki/Referential_transparency
16:48:49 <SamB> Frederick: you can't do that! you do not have the almighty +o!
16:49:15 <SamB> @wikipedia referential transparency
16:49:16 <lambdabot> http://en.wikipedia.org/wiki/Referential_transparency
16:51:25 <ski_> "In particular in Ocaml, there is no such thing as a function" is wrong, imo
16:51:51 <Frederick> ski_, Im also having some problems to understand how does he define the derive operator
16:51:52 <ski_> Frederick : ok
16:52:30 <Korollary> I dont see where ocaml is mentioned
16:53:47 <ski_> Korollary : discussion
16:54:25 <ski_> Frederick : i see no 'derive' operator .. which page ?
16:54:34 <Frederick> ski, page 8
16:54:56 * Frederick is looking on the character map for such symbol
16:55:03 <ski_> aha
16:55:45 <ski_> that is defined at page 8
16:56:42 <ski_> (|--->) :: Symb n nt -> [Symb n nt] -> [Symb n nt]
16:56:47 <ski_> l |---> r = l : r
16:57:22 <Frederick> ski_, wich of the 2 definitions?
16:57:33 <ski_> (don't recall if '|--->' can actually be used as a haskell operator .. depends on whether '|' is allowed in operators)
16:57:44 <ski_> 2 ?
16:57:56 <ski_> i see one definition at page 8
16:57:58 <ski_> l |---> r = l : r
16:58:11 <lisppaste2> Frederick pasted "draft" at http://paste.lisp.org/display/13285
16:58:12 <ski_> then i added a type signature above .. to explain it better
16:58:25 <Frederick> ski_, updated version
16:58:32 <ski_> m, saw that
16:59:35 <Frederick> btw I read (|--->) as a Symbol that thakes a nonterminal into a set of symbols?
17:00:29 <ski_> no, it's an infox operator, combining a rule/preoduction head symbol (should be nonterminal) with a corresponding body of symbols (i.e. list of symbols)
17:00:36 <ski_> s/infox/infix/
17:01:38 <Frederick> ski_, oki I got it
17:03:31 <lisppaste2> Frederick pasted "fixed" at http://paste.lisp.org/display/13286
17:07:55 <Frederick> ski_, what is he doing at the end of page 9?
17:09:05 <lambdawar> evening
17:09:44 <Korollary> evening
17:11:28 <Frederick> ski_, ?
17:13:23 <Frederick> Korollary, can you give me a hand from where ski_ stopped with me? I need to get the rythm
17:14:53 <Korollary> Frederick: With what ?
17:15:09 <Frederick> Korollary, trying to make a CFG grammar
17:15:24 <bosie> hello
17:15:33 <bosie> is there some thing like <> ... ?
17:15:49 <bosie> or is there a way to turn a false value into a true value ?
17:16:02 <dons> @eval not False
17:16:03 <lambdabot> True
17:16:10 <bosie> thx dons
17:16:14 <dons> @type readFile
17:16:14 <lambdabot> FilePath -> IO String
17:16:28 <Korollary> Frederick: do you happen to have a book on grammars ?
17:16:35 <Frederick> Korollary, yes
17:16:40 <bosie> dons so there is nothing like <> ?
17:16:45 <Frederick> Korollary, the problem is that im new to haskell
17:16:56 <Frederick> Korollary, the grammar part I know
17:16:59 <bosie> do i always have to compare like Int < IntA && Int > IntA ?
17:17:06 <resiak> bosie: foo /= bar
17:17:17 <Korollary> Frederick: oh ok
17:17:25 <bosie> resiak thank you
17:17:29 <dons> ah, I thought you mean <> as in perl
17:17:37 <Korollary> <> as in VB apparently
17:17:44 <dons> never seen it before :}
17:17:51 <Korollary> consider yourself lucky
17:17:59 * dons hides away in my ivory tower for a while longer
17:18:11 <bosie> dons what does <> do in perl ? i just know it from real languages
17:18:12 <bosie> ;))
17:18:19 * resiak hands dons the art of writing in the third person.
17:18:22 <fnord123_> its used as for each
17:18:26 <dons> hehe
17:18:41 <dons> it reads from a file handle
17:18:49 <Frederick> Korollary, does http://paste.lisp.org/display/13286 need something else to start reading the grammar?
17:18:56 <bosie> kk
17:18:56 <Korollary> Frederick: I am curious as to why nonterminal is not a type on its own
17:19:02 <dons> perl is a real language. certainly as real as VB, and more so
17:19:14 <dons> people actually use it for useful things ;)
17:19:26 <Korollary> perl is painfully real imho
17:19:36 <bosie> good point why i choosed <> over !=
17:19:40 <dons> quite so, but it is `real'
17:19:44 <bosie> maybe i did too much sql today :(
17:21:01 <Frederick> Korollary, , im following this paper -> http://wiki.di.uminho.pt/wiki/pub/PURe/PurePublications/PUReTR041101.pdf
17:22:09 <Frederick> Korollary, to be very specific following page 7 and further ones
17:23:28 <Korollary> Frederick: I see
17:26:06 <lisppaste2> bosie pasted "doesnt work" at http://paste.lisp.org/display/13288
17:26:21 <bosie> i get an exptected type [a] -> [a] but i pass [a] -> Int
17:26:28 <bosie> other way around
17:26:39 <bosie> exp: [a] -> Int
17:26:40 <bosie> inf: [a] -> [a]
17:27:41 <Korollary> Frederick: The reason I asked is that the production operator |---> can't be restricted to operate only on nonterminals as the left hand side without a separate NT type.
17:28:23 <Frederick> Korollary, can you please explain in other words? Im brazillian I couldnt get the whole Idea
17:28:46 <Frederick> are you saying something like a |---> a is invalid?
17:29:05 <bosie> why cant i do it the way i try to ?
17:30:12 <Korollary> Frederick: No, the comment says that the head should be a nonterminal, but the type says it can be a symbol, which is more general than just nonterminal.
17:31:34 <Frederick> (|--->) :: Symb nt -> [Symb nt] -> [Symb n nt] would it be better?
17:32:54 <bosie> anyone?
17:33:47 <resiak> bosie: You might want to tell us _what_ you're trying to _do_.
17:34:10 <resiak> Oh, sorry, I'm blind.
17:34:15 * resiak hides in a nearby dark corner.
17:34:33 <Korollary> Frederick: Well, to be honest, I don't understand why Cfg is a parameterized type (page 7).
17:34:53 <bosie> resiak right, i have a [[Int]] list and i want to filter the [Int]s out, which result in a false when i pass them to a
17:34:57 <Korollary> oops I should have read more
17:35:07 <Frederick> Korollary, :p
17:35:26 <Frederick> ski_, wb
17:36:17 <Frederick> Korollary, did you get the idea about why defining th type?
17:36:21 <ski_> (Frederick : net connection fucked itself up ..)
17:36:51 <Korollary> Frederick: Ok, now I understand
17:37:16 <ski_> the paper said it used that to make the notation look as similar to BNF as possibe  (maybe even just using this symbol in the paper ..)
17:37:20 <Korollary> Frederick: He wants to express the production as a single list with the nonterminal on the left as the head of the list.
17:38:18 <bosie> resiak any idea?
17:39:19 <Frederick> Korollary, sure cause lists are good to handle the productions algorithms
17:39:34 <Korollary> Frederick: On page 9, I see a data constructor named "T", which is not defined.
17:39:58 <Korollary> oh it is
17:40:00 <Korollary> p 8
17:41:27 <resiak> bosie: No. I can't see what those are _meant_ to do :)
17:41:37 <Frederick> Korollary, if I understood the paper T is defined as a member of t set
17:42:11 <bosie> resiak well, a: i pass a  [string] and an [Int] and i just check if the length of both are the same
17:42:17 * Frederick Just wants to have this part done in hope things will flow later
17:42:31 <resiak> bosie: I'm off; sorry.
17:42:36 <bosie> resiak now in b i pass [[Int]] and [[String]] and i want to get all [Int] which are the same size as string
17:42:38 <bosie> ok
17:42:48 <bosie> resiak thx for ur help :)
17:42:52 <bosie> anyone else maybe? ;)
17:43:03 <ski_> @eval let sameLength xs ys = length xs == length ys in sameLength [1,2,3] ["a","b","c"]
17:43:04 <lambdabot> True
17:43:07 <Korollary> Frederick: that much would work with the expression defined on page 9.
17:43:38 <bosie> ski_ how you compare [String] to [[Int]] ?
17:43:52 <bosie> ski_ the iteration is my problem so far
17:43:55 <ski_> @eval let sameLength xs ys = length xs == length ys in sameLength [[1,2,3],[4,5],[6]] ["a","b","c"]
17:43:56 <lambdabot> True
17:44:13 <bosie> ski_ the length of the "fields"
17:44:32 <ski_> bosie : what are those fields ?
17:44:43 <bosie> i wanna compare [1,2,3] and [4,5] and [6] to the string array
17:44:45 <ski_> do you mean  elements ?
17:44:49 <Korollary> bosie: if you compare the lengths of the sublists, you will get a list of greater than/less than info.
17:44:51 <bosie> yes exactly sorry
17:45:16 <Korollary> @type GT
17:45:16 <ski_> so, you want to compare [1,2,3] in [[1,2,3],[4,5],[6]] against what ?
17:45:17 <lambdabot> Ordering
17:45:25 <ski_> @type compare
17:45:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
17:45:30 <bosie> against the length of the string array ski_
17:45:33 <Frederick> Korollary, but how can I enter a grammar for my current program as he did with expr = ...
17:45:36 <ski_> array ?
17:45:39 <ski_> not list ?
17:45:43 <bosie> ski_ sorry list
17:45:53 <bosie> [String] -> [[Int]]
17:45:58 <Korollary> Frederick: You just insert the expression into your haskell program, and if it compiles that means it's correct.
17:46:09 <ski_> you want to check that each individual int list has same length as the whole string list ?
17:46:21 <bosie> yes
17:46:23 <Frederick> Korollary, just input the part after = on the expression?
17:47:01 <bosie> ski_ not just list actually, i already have a function which tells me if an [Int] list is true or false given a certain [String]
17:47:02 <Korollary> Frederick: no, the whole line.
17:47:02 <ski_> i.e comparing  [[1,2,3],[4,5],[6,7,8]] with ["a","b","c"] should give [True,False,True] ?
17:47:12 <ski_> hm, ok
17:47:41 <bosie> ski_ should give [True, False, False] since the maximum number of Int is the length of the String-List
17:47:59 <ski_> why false ?
17:48:01 <bosie> but the comparision between [Int] and [String] i have, but i dont know how to iterate an [[Int]] and call my comparision-function
17:48:05 <ski_> as last element ?
17:48:24 <bosie> because the max-int value is 3 since the string-list has 3 elements
17:49:07 <ski_> @eval let foo intLists strings = map (\intList -> length intList == length strings) intLists in foo [[1,2,3],[4,5],[6,7,8]] ["a","b","c"]
17:49:08 <lambdabot> [True,False,True]
17:49:22 <ski_> i don't understand what you want
17:49:27 <bosie> hang on i try that
17:49:44 <bosie> i want to iterate through an [[Int]] list and call a function for each [Int] element
17:49:58 <ski_> that loops though the list of int lists, checking whether each int list has same length as the whole string list
17:50:03 <ski_> ok
17:50:05 <ski_> that is map
17:50:08 <ski_> @type map
17:50:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
17:50:28 <ski_> @eval map (\xs -> (xs,length xs,sum xs)) [[1,2,3],[4,5],[6,7,8]]
17:50:29 <lambdabot> [([1,2,3],3,6),([4,5],2,9),([6,7,8],3,21)]
17:50:52 <ski_> you can transform each element in some way specified by the function argument of the map call
17:51:00 <bosie> ski_ yes but my function which checks if its true or false returns an boolean
17:51:04 <bosie> a boolean
17:51:28 <ski_> so, maybe you want to AND or maybe OR all the elements in the Bool list ?
17:51:31 <ski_> @type all
17:51:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:51:34 <ski_> @type any
17:51:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:51:53 <bosie> hmm
17:52:08 <ski_> first checks that all things in a list satisfies something
17:52:27 <ski_> second checks that at least onel thing in the list satisfies something
17:52:48 <bosie> wouldnt make filter() make more sense for that?
17:52:58 <Frederick> Korollary, it isnt working I think http://rafb.net/paste/results/PNzmzU96.html
17:53:24 <ski_> bosie : not if you want to check that all/some elements in the list satisies some test
17:53:55 <ski_> Frederick : put that line in your file, not in the interactive toplevel
17:54:03 <bosie> ski_  well i want a [[Int]] list as a result with all the elements of the [[Int]] list which actually satisfie my function
17:54:22 <ski_> bosie : aha, why didn't you say so, then :9
17:54:32 <ski_> bosie : then of course 'filter' is better
17:54:34 <bosie> ski_ well i thought my code made that clear :(
17:54:44 * ski_ came in late
17:54:51 <bosie> yes but filter has a weird type which doesnt accept [a] :(
17:54:57 <bosie> ski_ sorry didnt see that
17:54:57 <ski_> @type filter
17:54:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:55:17 <Frederick> ski_, can I put that in any place? What would be the expected output?
17:55:27 <ski_> @eval filter (\xs -> length xs == length ["a","b","c"]) [[1,2,3],[4,5],[6,7,8]]
17:55:28 <lambdabot> [[1,2,3],[6,7,8]]
17:56:27 <ski_> Frederick : that 'expr = ...' is a declaration .. defining a variable 'expr' .. declarations don't have output .. expressions have output values
17:56:46 <lisppaste2> bosie pasted "doesnt work" at http://paste.lisp.org/display/13289
17:56:59 <lisppaste2> bosie pasted "doesnt work" at http://paste.lisp.org/display/13290
17:57:07 <bosie> so, the second link is the correct one
17:57:12 <ski_> Frederick : after making such a declaraion, the expression 'expr' would be defined, though
17:57:34 <Frederick> ski_, what do you mean?
17:57:36 <bosie> damn sweet ski_
17:57:45 <ski_> bosie : you've got bad naming there :)
17:57:46 <bosie> ski_ i thought i already had that solution :(
17:57:54 <bosie> ski_ why ?
17:58:05 <ski_> well .. i guess s/bad/uninformative/
17:58:28 <bosie> ski_ yea but alot faster to type in the ghci-console then ichteileheutemeinebrute
17:58:30 <bosie> ;)
17:58:41 <bosie> ski_ as soon as my function works i rename it anyway
17:58:52 <ski_> you don't have history in your interactive toplevel ?
17:59:07 <bosie> i do but its kinda weird and i havent understand the system of it so far
17:59:13 <ski_> bosie : fair enough, i guess
17:59:18 <bosie> its not like a linux console
18:00:35 <ski_> Frederick : that 'expr = ...' is not an expression .. expression have values .. this is a declaraion, so it should be put in a source file, which then should be loaded, e.g. by ':r' command, if you already had the file loaded before
18:01:03 <Frederick> ski_, I dont get what you mean but the source seems to be working
18:01:31 <Korollary> yeehaa
18:01:45 <Frederick> Korollary, it complains of mal-formed production and stuff
18:01:51 <ski_> Frederick : right .. you should put that line in the source, as Korollary said
18:02:38 <ski_> Frederick : what is the error message ?
18:04:18 <Frederick> ski_, if I put construction out of the definitions (not a grammar) it complains (as expected) so I thing it is right
18:04:39 <Korollary> Frederick: it compiles here
18:05:12 <lisppaste2> Korollary annotated #13286 with "works" at http://paste.lisp.org/display/13286#1
18:06:57 <Frederick> Korollary, thx for cleaning my mess
18:07:14 <Korollary> Frederick: np
18:07:50 <Frederick> ski_, do you think I can use this structure to keepgoing, I need to put this grammars in normal form so I will need a NFmizator module
18:11:21 <Frederick> Korollary, same question I ask to you
18:11:58 <Korollary> Frederick: You can keep going as far as I can tell.
18:12:27 <Frederick> Korollary, how can I for example acess the productions structure
18:13:06 <Korollary> Frederick: use the 'prods' field
18:13:33 <Frederick> Korollary, well first of all I need to write the look ahead function
18:14:40 <bosie> hmm when i have this type ([[Int]],[[Int]]) how do i access the first [[Int]] ? obviously not with head ;)
18:15:16 <Korollary> bosie: fst (a,b) = a
18:15:33 <bosie> Korollary thank you
18:15:41 <dons> @eval fst (1,'x')
18:15:42 <lambdabot> 1
18:16:00 <dons> @eval fst (1,undefined)
18:16:01 <lambdabot> 1
18:16:28 <bosie> kk
18:16:34 <dons> in fact, you could have found this function with hoogle:
18:16:41 <bosie> hoogle ?
18:16:55 <dons> since you know the argument type ([[Int]],[[Int]]), and the result type is [[Int]]
18:16:57 <Korollary> @hoogle (a,b) -> a
18:16:58 <bosie> the search function for hugs ?
18:16:58 <lambdabot> Data.Tuple.fst :: (a, b) -> a
18:16:58 <lambdabot> Prelude.fst :: (a, b) -> a
18:16:58 <lambdabot> Data.Tuple.snd :: (a, b) -> b
18:17:01 <dons> then you want a function:
18:17:16 <dons> @hoogle ([[Int]],[[Int]]) -> [[Int]]
18:17:16 <lambdabot> No matches, try a more general search
18:17:20 <dons> bah
18:17:25 <Korollary> heh
18:17:27 <bosie> dons or maybei couldnt ;)
18:17:30 <dons> let's complain to ndm
18:17:39 <dons> @hoogle (a,b) -> a
18:17:40 <lambdabot> Data.Tuple.fst :: (a, b) -> a
18:17:40 <lambdabot> Prelude.fst :: (a, b) -> a
18:17:40 <lambdabot> Data.Tuple.snd :: (a, b) -> b
18:17:45 <dons> (you need to generalise in your head)
18:17:59 <heatsink> Hmm
18:18:04 <bosie> so much for computers beeing smarter than me ;))
18:18:09 <dons> so change any type to a fresh type variable, then pass it to hoogle
18:18:09 <heatsink> How come [(forall a b. (a, b) -> a)] is an illegal type?
18:18:28 <bosie> dons what does "fresh type" mean ?
18:18:29 <dons> that's a funny list
18:18:34 <heatsink> yea :)
18:18:36 <Frederick> Korollary, can you check the lookahead function with me?
18:18:41 * heatsink is just playing with the type system
18:18:42 <Frederick> end of pg 9
18:19:00 <dons> bosie, 'fresh type variable' means a new type variable name (like 'a')0 different from others in the type so far
18:19:09 <bosie> kk
18:19:10 <dons> so [[Int]] becomes 'a', for example
18:19:18 <bosie> ok thanks
18:19:19 <dons> hoogle then will find the type we need
18:19:50 <dons> maybe we should have a hoogle that finds more general functions for us sometimes
18:19:51 <bosie> @hoogle [String] -> [Int]
18:19:52 <lambdabot> No matches, try a more general search
18:20:01 <dons> @hoogle Int -> Int -> [Int]
18:20:01 <lambdabot> No matches, try a more general search
18:20:11 <dons> hmm. I think we should complain to ndm
18:20:14 <bosie> @hoogle String -> [Int]
18:20:16 <lambdabot> No matches, try a more general search
18:20:18 <dons> @hoogle a -> a -> [a]
18:20:18 <lambdabot> Data.List.repeat :: a -> [a]
18:20:18 <lambdabot> Prelude.repeat :: a -> [a]
18:20:18 <lambdabot> Data.List.replicate :: Int -> a -> [a]
18:20:32 <bosie> @hoogle a -> b
18:20:33 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
18:20:33 <lambdabot> Prelude.id :: a -> a
18:20:33 <lambdabot> Prelude.undefined :: a
18:21:01 <dons> so giving it a more general type works nicely, but it doesn't find the more general type when given a specialised type that produces no matches
18:21:09 <dons> when maybe it should
18:21:51 <dons> @seen ndm
18:21:51 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 hour,
18:21:51 <lambdabot> 21 minutes and 50 seconds ago.
18:22:11 <bosie> who is ndm anyway?
18:22:18 <dons> the author of @hoogle
18:22:25 <dons> @where hoogle
18:22:25 <lambdabot> http://www.haskell.org/hoogle
18:22:48 <bosie> lol cool
18:23:09 <Frederick> ski_, are you there?
18:24:44 <heatsink> @eval foldr1 (.) [fst, fst, fst]
18:24:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
18:24:44 <lambdabot>   Expected type: (a, b) -> (a, b)
18:24:44 <lambdabot>   Inferred type: (a, b) -> a
18:24:48 <ski_> no
18:24:56 * ski_ is busy atm
18:25:01 <Frederick> ski_, k
18:25:41 <dons> @type [(forall a b. (a, b) -> a)]
18:25:42 <lambdabot> parse error on input `->'
18:26:02 <dons> @type forall a b . [(a, b) -> a)]
18:26:02 <lambdabot> parse error on input `->'
18:26:12 <dons> @type [(a, b) -> a)]
18:26:13 <lambdabot> parse error on input `->'
18:26:17 <dons> huh?
18:26:25 <ski_> dons that is not expressions .. do you want @kind ?
18:26:26 * resiak hands dons another (
18:26:28 <dons> silly me
18:26:35 <dons> @kind [(a, b) -> a)]
18:26:35 <lambdabot> parse error on input `)'
18:26:43 <heatsink> @kind [(a, b) -> a]
18:26:43 <dons> @kind [((a, b) -> a)]
18:26:43 <lambdabot> Not in scope: type variable `a'
18:26:43 <lambdabot>  
18:26:43 <lambdabot> <interactive>:1:5: Not in scope: type variable `b'
18:26:44 <lambdabot> Not in scope: type variable `a'
18:26:44 <lambdabot>  
18:26:45 <lambdabot> <interactive>:1:6: Not in scope: type variable `b'
18:26:51 <dons> @kind [(forall a b . (a, b) -> a)]
18:26:52 <lambdabot> *
18:26:52 <heatsink> @kind forall a b. [(a, b) -> a]
18:26:53 <lambdabot> *
18:26:58 <dons> heatsink ...
18:27:07 <dons> maybe you just need -fglasgow-exts?
18:27:23 <dons> or perhaps your own quantified list constructor?
18:28:01 <heatsink> didn't work in hugs.  I think it's a good place to use TH.
18:28:05 <dons> but there's no way it would let you write:
18:28:30 <dons> @type [ (\(x,y) -> x), (\(x,y) -> y) ]
18:28:31 <lambdabot> forall b. [(b, b) -> b]
18:28:34 <dons> oh. hmm
18:28:38 <dons> ah, monomorphic
18:28:48 <dons> @type [ (\(x,y) -> x::Int), (\(x,y) -> y::Char) ]
18:28:48 <lambdabot>   Couldn't match `Int' against `Char'
18:28:48 <lambdabot>   Expected type: Int
18:28:53 <bosie> how do i sum up an [[Int]] and from each element i just wanna sum up the first element
18:29:02 <bosie> i really am bad with iterations in haskell :(
18:29:19 <heatsink> you want to take the first element of each inner list, and sum them?
18:29:29 <bosie> yea
18:29:33 <Korollary> bosie: you don't really iterate in haskell. The word is "fold".
18:29:40 <Korollary> @type foldl
18:29:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:29:57 <bosie> oh
18:30:07 <dons> @eval foldl (\x y -> x +  head y) 0 [[1..10],[1..9]]
18:30:08 <lambdabot> 2
18:30:10 <Korollary> @pl foldl (+) 0 [0..9]
18:30:11 <lambdabot> foldl (+) 0 [0..9]
18:30:16 <Korollary> ugh
18:30:22 <Korollary> @eval foldl (+) 0 [0..9]
18:30:23 <lambdabot> 45
18:30:42 <dons> we don't iterate, we fold  or map
18:30:51 <Korollary> I boogie
18:30:53 <dons> occasionally we recurse
18:31:23 <Frederick> Korollary, may I bug you a bit more?
18:31:33 <bosie> dons, Korollary i will try foldl then thx
18:31:40 <dons> @eval sum [ head x | x <- [[1..10],[1..9]] ]
18:31:41 <lambdabot> 2
18:31:41 <heatsink> bosie: First task is to take the first element of each list.  Second task is to sum the result.
18:31:42 <SamB> dons: on rare occassions, we DO iterate.
18:31:55 <dons> well, maybe we comprehend sometimes as well
18:32:01 <SamB> @type iterate
18:32:02 <lambdabot> forall a. (a -> a) -> a -> [a]
18:32:09 <dons> ah, we List.iterate ;)
18:32:31 <Korollary> Frederick: if you paste the definition of lookahead into your source, it will compile, but 'nullable' may need to be defined, and I don't know what it is per se.
18:32:37 <SamB> @iterate (+1) 0
18:32:37 <lambdabot> Unknown command, try @listcommands.
18:32:46 <bosie> heatsink double head and foldl (+) 0 but i figured thats not gonna fly ;)
18:33:17 <SamB> @eval iterate (+1) 0
18:33:18 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
18:33:18 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
18:33:18 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
18:33:18 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
18:33:18 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
18:33:20 <lambdabot> [24 @more lines]
18:33:25 <dons> hmm. *lots* of people mis-type @eval as SamB just did
18:33:30 <dons> 4 or 5 a day
18:33:40 <dons> maybe lambdabot should by default call @eval
18:34:05 <dons> so we'd have @map (+1) [1..10], for example
18:34:12 <dons> though that'd calsh
18:34:14 <dons> clash. hmm
18:34:26 <heatsink> makes sense to have a different first character for eval.
18:34:28 <Korollary> dons: how about just @e
18:34:34 <heatsink> =iterate (+1) 0
18:34:34 <dons> heatsink, ah!
18:34:39 <dons> > map (+1) ...
18:34:48 <dons> ! how's that then ?
18:34:58 <dons> looks fun actually, and would read nicely in the logs
18:35:01 <Korollary> @type !
18:35:02 <bosie> foldl (+) 0 head $ head $ fst $ [[Int]]
18:35:02 <bosie> shouldnt that work ?
18:35:03 <lambdabot> parse error on input `!'
18:35:20 <dons> bosie, that's a type you've got at the end. not a list value
18:35:23 <dons> @type (!)
18:35:24 <lambdabot> Not in scope: `!'
18:35:29 <dons> @type (List.!)
18:35:29 <Frederick> Korollary, I think nullable is a empty production maybe but how do I define the  symbol that is before gollow in line 3?
18:35:30 <lambdabot> Not in scope: `List.!'
18:35:38 <dons> @type (Data.Array.!)
18:35:38 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
18:35:51 <bosie> dons i have a [[Int] value there
18:35:58 <heatsink> bosie: remember, you have a list of lists, and you want to take the head of each value.
18:36:13 <heatsink> @type head
18:36:13 <lambdabot> forall a. [a] -> a
18:36:14 <dons> remember the type of foldl as well.
18:36:19 <dons> @type foldl
18:36:20 <heatsink> @type map head
18:36:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:36:21 <lambdabot> forall a. [[a]] -> [a]
18:36:24 <heatsink> oops
18:36:28 <bosie> heatsink exactly thats why i said head
18:36:37 * Frederick is liking haskell now
18:36:45 <dons> anyone have any objections to the @eval  ==  >  syntax?
18:37:06 <heatsink> bosie: head takes the head of one list, which is not what you are trying to do.
18:37:13 <heatsink> dons: sounds ok to me.
18:37:26 <Korollary> dons: > 1 > 2 ?
18:37:35 <bosie> heatsink hmm well if foldl iterates through the list and head takes it from each list
18:37:46 <dons> pasting from ghci could be a bit iffy.
18:37:54 <heatsink> bosie: remember how precedence works.
18:37:55 <dons> as it would possibly trigger an eval
18:38:12 <dons> > 1 > 2   ~>   @eval 1 > 2. so that would be ok K.
18:38:13 <heatsink> foldl (+) 0 head $ head $ fst $ x does: fst, then head, then head, then foldl (+) 0 head
18:38:16 <bosie> ah you mean i kill my list heatsink
18:38:22 <heatsink> what?
18:38:39 <bosie> heatsink with head i dont have an existing list when it comes to foldl
18:38:49 <heatsink> You do, but it's the wrong list :)
18:38:55 <bosie> k
18:39:04 <Frederick> Korollary, I think nullable is a empty production maybe but how do I define the  symbol that is before gollow in line 3?
18:39:13 <bosie> ah right, you mean i have to create my list with all the first elements first
18:39:16 <heatsink> @eval head [[1,1,1],[2,2,2],[3,3,3]]
18:39:17 <lambdabot> [1,1,1]
18:39:23 <heatsink> bosie: right.
18:39:31 <Korollary> Frederick: That is already defined
18:39:35 <Korollary> @type (++)
18:39:36 <lambdabot> forall a. [a] -> [a] -> [a]
18:39:40 <heatsink> bosie: do you know how to do that?
18:39:51 <Frederick> hm
18:40:00 <bosie> heatsink i guess mapping through the list and say something like (:) [] or so
18:40:23 <heatsink> bosie: it's easier than that.  Remember, head takes the first element of a list...
18:40:31 <heatsink> bosie: (map head) takes the first element of _each_ list
18:40:50 <heatsink> @eval map head [[1,1,1],[2,2,2],[3,3,3]]
18:40:51 <lambdabot> [1,2,3]
18:40:56 <bosie> that was easy
18:41:00 <Frederick> Korollary, is the first arrow a =>?
18:41:01 <bosie> z c d =  foldl (+) 0 (map head (fst $ teile c d))
18:41:10 <Korollary> Frederick: Yes
18:41:40 <Korollary> Frederick: You need to learn about type classes to understand this in general, though.
18:41:56 <heatsink> bosie: looks correct.
18:42:38 <dons> @quit test new code
18:42:50 <dons> > map (+1) [1..10]
18:42:57 <bosie> heatsink even works ;)
18:43:00 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
18:43:04 <Korollary> > let abt = ['a'..'z'] in take 10 [a,b,c,d | a <- abt, b <- abt, c <- abt, d <- abt ]
18:43:06 <lambdabot>  parse error on input `|'
18:43:20 <Korollary> > let abt = ['a'..'z'] in take 10 [a:b:c:d:[] | a <- abt, b <- abt, c <- abt, d <- abt ]
18:43:21 <lambdabot> ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj"]
18:43:24 <dons> :)
18:43:47 <dons> >1+2
18:43:48 <lambdabot> 3
18:44:01 <araujo> oh, new lambdabot syntax? :-)
18:44:16 <dons> yes, the > prefix is a synonym for @eval
18:44:22 <dons> as people kept forgetting the @eval anyway
18:44:26 <Korollary> dons, which modules are available for eval ?
18:44:43 <dons> check the runplugs script in the lambdabot repo
18:44:56 <heatsink> that was fast.
18:45:01 <dons> all pure code, and Map and Set are imported qualified as M and S
18:45:04 <Korollary> dons: no @listmodules ?
18:45:09 <Korollary> ah
18:45:13 <heatsink> >_<
18:45:14 <lambdabot>  parse error on input `}'
18:45:20 <Korollary> wow
18:45:23 <heatsink> huh?
18:45:26 <dons> > M.empty :: M.Map Int ()
18:45:26 <lambdabot> {}
18:45:29 <bosie> heatsink what if i want to count the positions of the 1 in an [[Int]] list... say [[1,2,3],[2,13]] the solution would be like [1,1,0].... wouldnt that work the same way
18:45:38 <dons> heatsink, oh. good point. maybe it should require a whitespace
18:45:42 <SamB> hmm, perhaps you should require the space?
18:45:48 <SamB> yes
18:45:48 <dons> yep. hacking...
18:46:03 <Frederick> Korollary, thx by the pointer ive added tyupe classes to my bookmarks
18:46:08 <heatsink> bosie: counting requires a fold.
18:46:24 <bosie> heatsink what you mean ?
18:46:25 <dons> @quit try again
18:46:31 <dons> >_<
18:46:34 <Frederick> guys thx A LOT for all the help I shall be back tommorow :p
18:46:36 <dons> > 1+ 2
18:46:45 <lambdabot> 3
18:46:48 <Korollary> >>
18:47:01 <ski_> >
18:47:06 <dons> it now checks for the "> " `isPrefixOf`
18:47:12 <dons> >
18:47:14 <Korollary> ah
18:47:17 <Korollary> >
18:47:18 <Lemmih> lambdabot doesn't like '>' in private chats.
18:47:22 <ski_> >
18:47:30 <dons> Lemmih, right. should fix that too then?
18:47:33 <Korollary> > "hello"
18:47:34 <heatsink> bosie: actually, I don't understand the example.  Why is the answer [1,1,0]?
18:47:34 <lambdabot> "hello"
18:48:01 <dons> @bot
18:48:02 <bosie> heatsink i count the appereances of the number 1 on each position
18:48:02 <lambdabot> :)
18:48:05 <dons> > 1 + 2
18:48:06 <lambdabot> 3
18:48:09 <dons> > "hello"
18:48:10 <lambdabot> "hello"
18:48:22 <bosie> heatsink each sublist is 3 elements long
18:48:35 <heatsink> bosie: should that be [[1,2,3],[2,1,3]]?
18:48:42 <bosie> yes
18:48:48 <heatsink> bosie: not [2,13]
18:48:54 <bosie> sorry
18:48:58 <bosie> heatsink sorry
18:49:13 <heatsink> would [1,1,1] produce 3?
18:49:27 <bosie> that would produce [1,1,1]
18:49:34 <Korollary> no
18:49:41 <bosie> since on each position of the list there is 1
18:49:50 <Korollary> maybe for [[0,1], [0,1], [0,1]]
18:50:10 <bosie> heatsink i just count how often on each position the number 1 appears
18:50:23 <heatsink> bosie: what do you mean by position?
18:50:26 <bosie> heatsink each sublist is 3 elements long, so my result list is 3 elements long too
18:50:29 * araujo picks the last chocolate of today
18:50:41 <bosie> [1,2,3] ... number 1 is on position 1, number 2 is on position 2,...
18:51:05 <heatsink> oh, okay.  It's the index in the inner list.
18:51:13 <heatsink> (plus one)
18:51:16 <bosie> heatsink yea
18:51:51 <heatsink> okay, this one is a little bit tricky.
18:52:03 <heatsink> Are all inner lists the same length?
18:52:07 <bosie> heatsink yes
18:52:49 <heatsink> okay.  Easier way to do it is to make a function that counts the elements in the n_th position, and use that function to get your answer.
18:53:20 <bosie> heatsink how do i get the n_th position ? i thought by cutting the list down each iteration
18:53:40 <heatsink> bosie: there's an operator to do that, it's called !!
18:53:54 <bosie> ok
18:53:55 <heatsink> oh, your approach is probably better actually :)
18:54:22 <dons> @quit again
18:54:34 <bosie> thats probably due to my long lasting haskell experience
18:54:37 <bosie> ;)
18:54:39 <heatsink> :)
18:54:59 <dons> > "fixed Lemmih"
18:55:00 <lambdabot> "fixed Lemmih"
18:55:10 <heatsink> So... how would you break this problem down into smaller pieces?
18:55:21 <bosie> trying to figure that out
18:55:34 <heatsink> > putStr "> print 3"
18:55:35 <lambdabot> No IO allowed
18:55:53 <dons> hmm..
18:55:59 <dons> yes, that might be a problem
18:56:06 <dons> > show "> 3"
18:56:07 <lambdabot> "\"> 3\""
18:56:10 <dons> ah
18:56:18 <dons> > "> 3"
18:56:19 <lambdabot> "> 3"
18:56:25 <dons> but it ignores itself anyway
18:56:31 <dons> another bot could do it
18:56:45 <heatsink> two lambdabots talking to each other :)
18:56:47 <dons> but there's other ways to force bot loops
18:56:56 <bosie> heatsink a function [[Int]] -> [[Int] with nothing but map tail List
18:57:10 <ski_> @type map tail
18:57:11 <lambdabot> forall a. [[a]] -> [[a]]
18:57:35 <heatsink> bosie: yes, that will remove the head from each list.
18:58:08 <heatsink> bosie: you can use that for your recursive step.
18:58:15 <araujo> Hola Nomius_
18:58:35 <bosie> heatsink so i actually have a [[Int]] list and i pass that to the function you gave me earlier
18:58:46 * araujo got a box full of chocolate
18:58:57 <bosie> heatsink the only thing i dont know is when i actually call my tailing function
18:59:01 <Nomius_> araujo, are you a bot or something?
18:59:03 <Nomius_> Yeap, you are :-D
18:59:31 <araujo> Nomius_, Invalid option, Please type @help
18:59:35 <araujo> :-)
18:59:37 <dons> araujo: @type map . map
18:59:50 <dons> araujo: @version
19:00:06 <araujo> forall . [[a]] -> [[a]] .....
19:00:08 <araujo> aaah bah
19:00:10 <araujo> haha
19:00:13 <dons> heheh
19:00:29 <dons> @type map
19:00:29 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:00:31 <dons> @type map.map
19:00:31 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
19:00:48 <araujo> Almos! :-)
19:00:56 <dons> not bad ;)
19:01:07 <dons> I like the ..... :)
19:01:16 <araujo> haha
19:01:25 <ski_> what if lambdabot were that good ..
19:01:40 <heatsink> bosie: you build a list with the function.
19:02:08 <dons> araujo, @vixen so how are you today?
19:02:12 <dons> hehe
19:02:15 <bosie> heatsink hang on i have an idea
19:02:35 * araujo wonders what he needs to do
19:02:41 <bosie> heatsink why not just tail it when i calculate it
19:02:49 <ski_> @vixen so how are you today?
19:02:49 <lambdabot> i am wonderful, thanks for asking!
19:02:54 <heatsink> bosie: dunno what you mean.
19:02:58 <araujo> h :-]
19:02:59 <SamB> araujo: remember, vixen thinks funtional programmers are HOT
19:03:06 <araujo> hahaha
19:03:08 <bosie> heatsink thats because i am too excited to talk ;)
19:03:14 <heatsink> yay
19:03:17 <araujo> Hey, i am not a bot!!!
19:03:17 <dons> @vixen Haskell is cool, don't you think?
19:03:18 <lambdabot> Ooh, functional programmers are so hot!
19:03:26 <araujo> haha
19:03:44 <SamB> @vixen so what do you think of Yi?
19:03:45 <lambdabot> maybe. do you?
19:03:48 <dons> araujo: @vixen Haskell is cool, don't you think?
19:04:01 * dons waits for araujo to incriminate himself..
19:04:32 <araujo> Ooh, Functional programmers girls are so HOT!
19:04:33 <dons> SamB, we really need megamonad to talk to @vixen some more
19:04:43 <dons> heh
19:05:15 * araujo saved this time
19:05:20 <SamB> we need a gender flag for IRC
19:05:32 <Speck> is that like the Evil Bit?
19:05:35 <SamB> so lambdabot can tell who's male and who isn't/might not be
19:05:59 <bosie> heatsink do you think that could work ?
19:06:14 <dons> @seen vegai
19:06:14 <lambdabot> vegai is in #haskell-overflow, #haskell-blah and #haskell. I don't know
19:06:14 <lambdabot> when vegai last spoke.
19:06:27 <heatsink> @paste
19:06:27 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:06:30 <dons> vegai, you might want to update lambdabot to get this '> ' @eval syntax
19:06:35 <heatsink> but the page is locked.
19:06:40 <dons> > map (+1) [1..2]
19:06:41 <lambdabot> [2,3]
19:06:46 <heatsink> bosie: maybe you can paste an example of what you mean in rafb.net/paste
19:06:49 <dons> heatsink, you need to login
19:06:50 <SamB> unless lambdabot is bi...
19:06:59 <heatsink> bi-endian?
19:07:03 <bosie> heatsink i pmsg you with the example
19:07:03 <araujo> haha
19:07:33 <bosie> heatsink but here we go: http://rafb.net/paste/results/nglWl254.html
19:09:37 <Korollary> bosie: you are defining your input argument in that where clause.
19:09:37 <heatsink> bosie: this will work, as long as you only need to compare with 1
19:09:51 <heatsink> oh
19:10:06 <heatsink> bosie: this will work, if you remove the where clause
19:10:36 <heatsink> why are there three parameters?
19:10:48 <bosie> for no reason at all
19:11:09 <heatsink> `c' is dead.
19:12:06 <bosie> http://rafb.net/paste/results/pTdCQ148.html
19:12:12 <bosie> but now everything should be fine
19:12:45 <Korollary> what is teile ?
19:13:15 <heatsink> bosie: this will only look at the second element of each list.
19:13:17 <bosie> http://rafb.net/paste/results/A0Ee4f58.html
19:14:13 <bosie> heatsink yes but if i use that in a function now which iterates it it could work
19:14:15 <heatsink> teile is the wrong type.  What is teile doing?
19:14:32 <heatsink> oh sorry, nevermind
19:14:46 <bosie> heatsink it filters it but that doesnt matter for calculate
19:17:36 <bosie> crap
19:17:54 <heatsink> bosie: (map tail g) has thrown away the heads of the lists, is that what you intended?
19:18:08 <bosie> heatsink no but i figured its a begin ;)
19:19:11 <heatsink> In a recursive or iterative solution, you will need to make a function that contains only the recursive or iterative part.  I don't see that function yet.
19:19:30 <bosie> for example if i do that:
19:19:30 <bosie>  c d= foldl ((calculate c d) :[]) d
19:19:37 <ton> can i programming haskell in gui ?
19:19:49 <ton> buttons forms etcc.. ?
19:20:01 <Korollary> ton: Yes, there is a gtk binding called gtk2hs
19:20:59 <bosie> so far  c d= foldl ((calculate c d) :[]) d doesnt cut it because it doesnt deliver an [Int] type
19:20:59 <heatsink> bosie: c is a function?
19:21:07 <bosie> x :: [String] -> [[Int]] -> [Int]
19:21:07 <bosie> x c d= foldl ((calculate c d) :[]) d
19:21:13 <bosie> c is a [String]
19:21:45 <heatsink> This function calls `calculate' exactly once.
19:21:55 <bosie> oh
19:22:12 <SamB> ton: there is even a GUI builder called glade
19:22:30 <bosie> heatsink this function is crap anyawy as it seems
19:34:08 <heatsink> bosie: I would take the recursive approach for this problem
19:34:32 <heatsink> bosie: first figure out what it should do when the inner lists have length zero
19:34:54 <heatsink> bosie: then figure out what it should do when the inner lists have length (n+1)
19:35:28 <heatsink> bosie: you know how to turn a length (n+1) problem into a length (n) problem, using (map tail)
19:35:52 <heatsink> bosie: and you know how to take the significant part of the length (n+1) problem, using (map head)
20:19:09 <aheller> is missingh hosted elsewhere from quux.org?
20:20:09 <SamB> @google missingh
20:20:11 <lambdabot> http://quux.org/devel/missingh
20:20:27 <SamB> @google missingh -quux
20:20:28 <lambdabot> http://packages.debian.org/unstable/doc/missingh-doc
20:20:32 <aheller> indeed, but it wasn't responding to me.
20:20:47 <SamB> huh
20:21:09 <aheller> thinking on it, I seem to recall not having been able to find it last time I looked, either.
20:22:28 <Korollary> when I downloaded it, it was pretty slow
20:22:55 <aheller> and the google cache is from october 30th; maybe it's just bad luck on my part that it doesn't come down for me.
20:23:03 <aheller> Just thought I'd ask.
20:23:34 <Korollary> We should ask him to put up some binary packages on sf.net
20:23:38 <SamB> maybe there is an unprecedented rise in the use of gopher and this is putting a strain on quux.org?
20:24:38 <SamB> well, if debian has a doc package, they probably have a source package you could download...
20:24:45 <aheller> no doubt.
20:25:02 <aheller> but quux definately doesn't like me.
20:33:04 <aheller> ``And, as Riccardo points out, the category of Sets is almost always not
20:33:05 <aheller> what you meant.''
20:41:29 <aheller> gah, so sorry, that was not meant for here.
21:25:50 <Korollary_> " Gmail is temporarily unavailable. Cross your fingers and try again in a few minutes. We're sorry for the inconvenience."
21:35:16 <joelr> dons: ping
21:59:21 <joelr> ping
22:52:58 <ski> aheller : interesting, nonetheless
23:00:26 <Itkovian> meuning
23:13:52 <dons> joelr, hey
23:30:27 <dons> hehe, more ICFP photos: David, Igloo and Heffalump: http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1528.JPG
23:30:50 <dons> autrijus and spj: http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1588.JPG
23:31:03 <ricebowl> anyone know of a Haskell implementation that runs on Windows for x86-64?
23:31:28 <ricebowl> GHCi apparently does not mark memory as executable
23:32:31 <dons> riicebowl, mmm. that should be fixed.
23:32:48 <dons> ask SimonM on glasgow-haskell-users@ please, it's a good question.
23:33:01 <dons> (I didn't even known Windows ran on amd64? does it run in 64 bit mode??)
23:33:55 <ricebowl> dons - the full release came out at the end of the summer
23:34:02 <ricebowl> and yes, I am referring to 64-bit mode
23:34:30 <ricebowl> XP SP2 which has been out since spring of this year has taken advantage of the no-execute protection and the endless opportunities for more marketting hype bullshit provided thereby
23:35:01 <ricebowl> dons - it was nice; I recompiled some code for 64-bit mode and got a 50% speed increase :/
23:35:40 <dons> there's a number of places in the rts that require memory to be executable. these should all be sorted out though, since we ported to other OS that have no-exec bits
23:35:59 <dons> however, i've not heard of ghc running in 64 bit windows. so you should ask on glasgow-haskell-users@
23:36:11 <dons> haskell HQ (at microsfot cambridge) will be interested
23:38:37 <ricebowl> dons - the problem seems to be when it runs on hardware with the no execute bit
23:38:43 <dons> what happens?
23:38:47 <ricebowl> it crashes. :p
23:38:57 <ricebowl> it tries to execute code off the heap, I presume, since that would be the natural thing to do
23:39:09 <dons> yes, but ghc first sets mprotect.
23:39:14 <dons> however, who knows what it does on windows
23:39:19 <ricebowl> I can't really tell you since the debugger I prefer (the one that I wrote) does not support 64-bit. Yet.
23:39:31 <dons> so it'll work on *unix* OS with no-exec memory. but windows probably is lagging
23:39:34 <ricebowl> well, whatever lib they were linking with apparently wasn't coded properly
23:39:45 <dons> why?
23:39:55 <ricebowl> because Windows has supported no execute for years? ;)
23:39:59 <ricebowl> at the API-level
23:40:13 <ricebowl> just not in the kernel, because until x86-64 chips there was no good way to implement it
23:40:19 <dons> no, I'm saying that the windows port may perhaps not yet even try to set the exec bit on
23:40:37 <ricebowl> that's possible. I just don't see why they wouldn't have done it unless they simply forgot.
23:40:53 <dons> no one has a windows 64 bit box with ghc on it yet (no developer)
23:41:13 <ricebowl> anyway, who should I mail about this?
23:41:29 <dons> here's some code for you:
23:41:36 <dons> #if defined(i386_HOST_ARCH) && defined(_WIN32)
23:41:36 <dons>   /* This could be necessary for processors which distinguish between READ and
23:41:36 <dons>      EXECUTE memory accesses, e.g. Itaniums. */
23:41:36 <dons>   DWORD dwOldProtect = 0;
23:41:36 <dons>   if (VirtualProtect (addr, len, PAGE_EXECUTE_READWRITE, &dwOldProtect) == 0) {
23:41:38 <dons>     barf("mallocBytesRWX: failed to protect 0x%p; error=%lu; old protection: %lu\n",
23:41:41 <dons>          addr, (unsigned long)GetLastError(), (unsigned long)dwOldProtect);
23:41:44 <dons> #if defined(i386_HOST_ARCH) && defined(_WIN32)
23:42:45 <dons> email glasgow-haskell-users@ or glasgow-haskell-bugs@ haskell.org
23:42:49 <Speck> http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html
23:42:52 <Speck> anyone seen that?
23:43:33 <dons> ricebowl, possibly you should in fact report a bug on the sourceforge bug tracker
23:43:34 <ski> not me, ty for sharing link ..
23:43:36 <dons> @where ghc
23:43:36 <lambdabot> http://haskell.org/ghc
23:44:09 <ricebowl> dons - weird, why would they #ifdef i386_HOST_ARCH?
23:44:16 <ricebowl> seems that _WIN32 should be enough.
23:44:31 <ricebowl> since you want execute enabled on all Windows archs, even if it is ignored on some
23:45:05 <ricebowl> dons - you seem to know a bit about ghc; you work on it? How is the Windows version built?
23:45:11 <ricebowl> perhaps I could simply fix this and submit a patch
23:45:25 <paolino> morning ,I'm still fighting with exception overflow
23:45:32 <ricebowl> in any case, reporting something besides "always fails on Windows/x86-64" would be helpful
23:45:46 <Lemmih> Exception overflow? Wow.
23:45:48 <paolino> @eval let i f x 0 = x;i f x n = i f (seq x (f x)) (n-1) in i f 0 1000000
23:45:49 <lambdabot>  Not in scope: `f'
23:46:36 <paolino> @eval let f x = x+1 ; i f x 0 = x;i f x n = i f (seq x (f x)) (n-1) in i f 0 1000000
23:46:37 <lambdabot> Stack overflow
23:46:56 <paolino> well stack I meant :/
23:47:43 <paolino> exception overflow is also happening often but that is another problem
23:48:09 <Cale> @eval let f x = x+1 ; i f x 0 = x; i f x n = seq x (i f (f x)) (n-1) in i f 0 1000000
23:48:10 <lambdabot> 1000000
23:48:31 <Korollary_> I think the author of that monads in ruby hangs out here
23:48:41 <Speck> seems like lots of ruby programmers are getting into haskell -- probably through pugs
23:48:54 <ricebowl> dons - actually, come to think of it, I have a dual-Opteron box at work which runs a 32-bit version of Windows. I can check and see if it bombs there, too
23:48:55 <Korollary_> what does ruby have to do with pugs ?
23:48:56 <Speck> also Matz apparently said that Haskell and io are two langauges to learn
23:49:01 <Speck> ruby and perl?
23:50:35 <Cale> @eval let f x = x+1 ; i f x 0 = x; i f x n = x `seq` i f (f x) (n-1) in i f 0 1000000
23:50:36 <lambdabot> 1000000
23:51:32 <Korollary_> Cale: shooting for a stack overflow ?
23:51:39 <Cale> paolino: the point is that expressions of the form f (f (f ... x)) were building up, and you have to use seq to kill them off
23:52:52 <Cale> this way, the x parameter gets evaluated before further evaluating i f x n, rather than after 1000000 iterations of f have built up on the stack
23:53:48 <paolino> mhh, looks like an important point in haskell programming
23:53:56 <basti_> yes
23:54:00 <Cale> well, it comes up from time to time
23:54:16 <Cale> if you put seq in the parameter like that, the seq's will build up along with the f's
23:54:39 <vegai> Speck: ruby monad thing looks good
23:54:41 <Cale> since nothing is forcing that evaluation to occur until the end when you try to print the result
23:55:22 <Cale> Hmm, I get a white page for that ruby monads thing.
23:55:27 <Speck> vegai: yeah, it'll be interesting to see if anyone can come up with a non-trivial use. I think that implementing a maybe monad + monadplus might yeild an idiom
23:55:51 <Cale> (looking at the source, it's not blank, but it's apparently not rendering for me in firefox)
23:56:07 <Speck> renders for me in safari, but it is a strange layout
23:56:24 <Cale> hmm... clearing my cache and reloading made it work
23:56:29 <ski> MenTaLguY seemed to work on those two parts (introduction, Identiy monad) in July ..
23:56:34 * ski wants more parts ! :)
23:56:43 <Cale> ah, it has something to do with privoxy
23:56:58 <Speck> Cale: it links to your hawiki page
23:57:12 <Cale> neat :)
23:57:20 <Speck> links to it poorly, however
23:57:31 <Cale> heh
23:59:22 <Speck> I might have to look into writing a simple maybe monad and monadplus in ruby to see if we can get a chaining-computations-that-can-fail idiom, but ruby doesn't have a lot of what makes that elegant in haskell (algebraic data types for one)
23:59:43 <Cale> The page seriously needs to be hit with Platypus to make the layout better. A "Relax" helps a good bit.
