00:00:05 <Cale> :)
00:00:18 <Cale> it's 3am here :)
00:00:30 <bosie> i was up at 3am too
00:00:42 <bosie> i prefer 3am ;)
00:01:28 <Akshaal> 3am == 15?
00:01:34 <bosie> no
00:01:36 <bosie> 0300
00:01:49 <skew> pm == "+12"
00:04:09 <kzm_> Good morning!
00:04:59 <skew> hello
00:05:00 <kzm_> Is there any reason function type declarations don't allow strictness annotations?  I.e. foo :: !Int -> String -> Int -- always strict in first argument?
00:05:15 <skew> not particularly
00:05:26 <skew> Core actually has strictness anotations
00:05:50 <skew> that's how seq is implemented - it's just const, but with a type signature like (in your notation) !a -> b -> b
00:06:04 <kzm_> I think it's fairly common to do this with foo x s = x `seq` ..., or similar, but I think it's cleaner to put it in the type decl.
00:06:14 <kzm_> (I think Clean allows it this way)
00:06:42 <kzm_> Okay.  But it's not perceived as much of a benefit, then?
00:06:55 <skew> yay, wxHaskell seems to like building against wx-2.4 (didn't like the 2.6 on my system). I'm trying to build Blobs, has anyone else looked at it?
00:07:17 <dons> we've got some half baked proposals for sstrictness annotations on function type signatures floating around somewhere
00:07:46 <skew> well, one question is what a ! means inside a type, if we want to do a thorough job of adding it to the language
00:08:59 <kzm_> skew, not sure what you mean ("inside a type").  Examples?
00:09:01 <skew> in my limited experience, it seems the strictness usually needs to go inside library functions rather than on your functions
00:09:13 <skew> like, foo :: (!Int, Bool) -> [!Char]
00:09:27 <kzm_> Heh, I see.
00:09:35 <skew> or, foo :: Ptr !Word8 -> IO ()
00:09:50 <skew> (the argument to Ptr is phantom)
00:10:37 <skew> like, you can add all the stricness you want to (+), but foldl (+) 0 list will still accumulate a big thunk
00:10:57 <kzm_> Well...is it difficult?  (!Int,Bool) -> Int is evaluated iff the surrounding pair is evaluated (WHNFed?)
00:11:15 <kzm_> (maybe not "iff" only "if")
00:11:52 <skew> for one, is !a an unlifted type, different from a, or just an annotation that you should evaluate that argument before the application?
00:12:16 <skew> what might be useful for situations like that, is some way to say you should never build a thunk for the application of your function
00:12:22 <kzm_> I tend to 1. write program, 2. heap profile, 3. sprinkle strictness 4. goto 2
00:13:02 <skew> maybe you would write something like fold ((+) :: Int -> Int -> !Int) 0 xs
00:13:21 <kzm_> :-)
00:14:05 <skew> That could be pretty useful - recently I couldn't really use Map.update because there was no strict version, so Ints would just pile up
00:14:09 <kzm_> Okay, I'm starting to see there's some food for thought here.
00:14:26 <kzm_> Yes, I know.
00:14:53 <skew> A quick hack that only lets ! go on arguments and only at the top level would probably be not too hard to implement
00:15:07 <kzm_> I don't think I've ever needed lazy collections.  (I'm not saying there is no use for them, just that I tend to want the whole collection or none of it)
00:15:44 <skew> adding unlifted types more generally would be interesting too, though
00:15:59 <kzm_> I think the (!Int,String) thing would be nice as well, if the semantics could be worked out.
00:16:03 <skew> a normalizing subset of the language would be useful if we want to add dependent types
00:18:30 <skew> what is the Text.ParserCombinators.TextParser module that the Blobs source mentions?
00:19:06 <sethk> Cale, down to 93 lines.  :)
00:19:40 <sethk> Cale, actually, 88 after removing commented out lines
00:22:03 <bosie> whats the best way to actually write a small pattern matcher like
00:22:03 <bosie> test = te?t and like tesat = te*t
00:24:55 <kzm_> bosie, do you mean regular expressions?
00:25:04 <bosie> kzm_ yes
00:25:10 <skew> the easiest is probably to use the regular expression library
00:25:20 <bosie> yea but i wouldnt learn anything if i use it
00:25:22 <kzm_> ("pattern matching" usually means matching values on their constructors)
00:25:34 <skew> one regex to turn glob syntax into a regular expression, then run that regular expression through the library
00:25:40 <bosie> kk sorry
00:26:21 <kzm_> Bascially, a regexp is run on a finite automaton.  Build the corresponding FSM from the regexp, and run it on the input? :-)
00:26:48 <bosie> fsm ?
00:26:59 <kzm_> You could look at John Meacham's regexp library (which I don't think is in the standard (yet)?)  Very cool
00:27:04 <kzm_> Finite State Machine (sorry)
00:27:47 <kzm_> If you aren't aiming for max perf, I don't think it is so hard (not that I've ever done it myself)
00:29:00 <kzm_> Perhaps it would work to convert regular expressions into Parsec parsers?
00:29:07 <bosie> well, i thought that i go through the string and replace every ? with the same char i have in the search text
00:30:05 <bosie> thats at least my plan for ?
00:30:43 <kzm_> I think it depends on the complexity of your patterns.  Regexps have a very solid theoretical foundation, and I think you should take a look if you want things to scale.
00:31:27 <bosie> hm actually i just wanna learn list manipulations and recursion, so i am not really aiming at anything. just learning haskell for the moment is enough ;)
00:32:30 <skew> oh, you can do that too
00:32:59 <skew> It's pretty easy if you use nondeterminism in list
00:33:12 <bosie> skew not sure what you mean, sorry
00:33:19 <kzm_> the list monad, I think.
00:34:01 <kzm_> I wouldn't start with that, if you're just learning.  Get a good grip on the non-monadic part first.
00:34:15 <bosie> kk
00:34:16 <kzm_> (but it *is* pretty cool)
00:34:29 <bosie> monads or regex?
00:34:59 <skew> just shell globs is a good start
00:35:03 <kzm_> well - both. (But I was thinking of the (non-determinism provided by the) list monad)
00:35:27 <skew> you don't want to do anything fancier if you are just writing recursive functions
00:35:49 <bosie> alright
00:44:01 <Lokadin> say in yet another haskell tutorial, should we be able to do the excersizes just from what we were taught in the lesson?
00:48:45 <Lokadin> wow haskell is soo much fun1! :D
00:49:00 <Lokadin> especially after the trauma of imperative programming
00:49:09 <bosie> lol
00:49:11 <bosie> yea right :D
00:49:22 <Lokadin> no really :P :D
00:49:42 <skew> I was depressing myself today by commenting page-long filters written in C++ with the one-line Haskell equivalent
00:49:47 <kzm_> I expect the answer is 'no', but is it possible to get different Int overflow handling?  Say, saturation (MAXINT+1==MAXINT), or exceptions?
00:49:59 <neologism> skew: show me the haskell code
00:50:02 <kzm_> Silent wraparound is usually *not* what I want :-)
00:50:16 <bosie> skew filters of what?
00:50:36 <kzm_> Heh.  I'm about to get a new job writing C++ code.  At least it's job security...
00:50:49 <kzm_> (maybe)
00:52:01 <skew> oh, things like map (\x -> (fst (head x), length x)) . groupBy ((==) `on` fst)
00:52:13 <bosie> might be a stupid question but how do i build something like if else in haskell ?
00:52:49 <skew> cond True thn els = thn; cont False thn els = els
00:52:52 <Heffalump> kzm_: do you care about performance?
00:53:37 <bosie> skew what ?
00:54:04 <skew> those are some standard list manipulation functions
00:54:34 <bosie> skew sorry i thought 09:52 was an answer to my question :)
00:54:59 <dons> > case 1 < 2 of True -> "yes" ; False -> "no"
00:55:01 <lambdabot> "yes"
00:55:06 <kzm_> heffalump - what kind of question is that? :-) You mean in general?  Or in C++? 
00:55:20 <kzm_> ...or related to regexps?  strictness?
00:55:43 <kzm_> ah, Ints of course.
00:55:51 <kzm_> Sorry, my mind drifted.
00:56:13 <bosie> oh nice thank you dons
00:56:21 <dons> bosie, but you should just use if then else
00:56:32 <dons> > if 1 < 2 then "yes" slse "no"
00:56:32 <lambdabot>  parse error on input `}'
00:56:35 <bosie> in the haskell prelude there is no else/if
00:56:41 <kzm_> Yes, in general.  I guess what you're saying is that CPUs only support fast integers without error checking.
00:56:51 <dons> > if 1 < 2 then "yes" else "no"
00:56:52 <lambdabot> "yes"
00:57:02 <skew> bosie: :52 is and answer for you
00:57:08 <boegel|home> @hoogle [a] -> Int
00:57:09 <lambdabot> Data.List.length :: [a] -> Int
00:57:09 <lambdabot> Prelude.length :: [a] -> Int
00:57:09 <lambdabot> Text.Regex.Posix.regExtended :: Int
00:57:14 <kzm_> I'm not quite sure it's entirely true, but if you insist it is, I'll take your word for it.
00:57:15 <boegel|home> @hoogle [a] -> a -> Int
00:57:16 <lambdabot> Data.List.length :: [a] -> Int
00:57:16 <lambdabot> Prelude.length :: [a] -> Int
00:57:16 <dons> bosie, if then else is sugar for case. almost everything is sugar for case ;)
00:57:27 <bosie> kk
00:57:31 <bosie> yea its working ;)
00:57:50 <skew> in Haskell, unlike most languages, you can just make a function that takes three arguments, returns the second if the first is true, and the third otherwise
00:57:54 <kzm_> However, it would still be tremendously useful to be able to debug programs using overflow checking Ints, almost regardless of perf penalties.
00:58:17 <Heffalump> kzm_: well, I was thinking you could just wrap Integer with something that checked for overflow.
00:58:50 <Heffalump> make a type alias that could either point to Int (for speed) or wrapped Integer (for error checking)
00:58:56 <kzm_> (s/Integer/Int?)  Yes, that is possible, but would be intrusive (wouldn't it?)
00:58:58 <dons> or even write your own Integer
00:59:05 <skew> or, you probably call the functions that work on the branch of Integer that's just single int, and fail instead of building a bignum on overflow
00:59:10 <bosie> skew in most languages i dont need that ;) i would just write 
00:59:10 <bosie> bosie = True ? "h" : "c";
00:59:10 <bosie> ;)
00:59:28 <skew> that's what Haskell's if is already
00:59:36 <skew> it's an expression
00:59:46 <dons> except with meaningful syntax :)
01:00:01 <o_Rocky> @type fmap
01:00:03 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
01:00:34 <kzm_> Heffalump - or just use Integer? :-)
01:00:42 <dons> oh it's so nice to see heap usage go *down* over time
01:01:17 <Heffalump> depends if you want to ever be able to run with Int :-)
01:01:29 <kzm_> (I generally care more about space than time performance, but of course I can wrap Int as well)
01:01:43 <Heffalump> I was thinking you could write a new Num instance.
01:01:52 <Heffalump> and then write your programs to be polymorphic in Nu,
01:01:57 <Heffalump> s/Nu,/Num/
01:02:01 <Heffalump> or make your own type class if necessary
01:02:09 <kzm_> Can I do that on a type alias?  I guess that's one of the GHC extensions?
01:02:14 <Heffalump> well, a newtype
01:02:25 <o_Rocky> bosie: in haskell i like to do (either f g) . (grd condition)
01:02:29 <Heffalump> anyway, Int already has a Num instance :-)
01:02:43 <Heffalump> type MyInt = Int -- or WrappedInteger
01:02:51 <Heffalump> instance Num WrappedInteger where ...
01:02:53 <kzm_> But I would need to ...oh, I guess, I could pack stuff with "fromIntegral"
01:03:10 <Heffalump> the reason to use Integer rather than Int is that it's easier to notice overflow when you can just compare the result with the Int bounds
01:03:31 <Heffalump> with Int, you have to do lots of annoying operation-specific things to check for overflow
01:03:32 <kzm_> Right.  (And pass the tea spoon, please :-)
01:03:46 <Heffalump> (e.g. a + b overflowed if a + b < a)
01:04:17 <xinming> lisppaste2: url
01:04:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:05:10 <lisppaste2> xinming pasted "how should I define the type for this?" at http://paste.lisp.org/display/13908
01:06:32 <boegel|home> @type elem
01:06:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:06:39 <Lokadin> : undefined reference to `__stginit_ZCMain'
01:06:41 <Lokadin> :|
01:07:05 <xinming> ERROR "asd.hs":13 - Type error in function binding
01:07:06 <xinming> *** Term           : askForWords
01:07:06 <xinming> *** Type           : IO [[Char]]
01:07:06 <xinming> *** Does not match : [[Char]]
01:07:10 <boegel|home> > elem ("blah",_) [("trala",0),("blah",3)]
01:07:10 <lambdabot>  Pattern syntax in expression context: _
01:07:17 <boegel|home> > elem ("blah",n) [("trala",0),("blah",3)]
01:07:17 <lambdabot>  Not in scope: `n'
01:07:19 <xinming> hmm, anyone here would help?
01:07:49 <Lokadin> xinming: change from IO [[Char]] to just [[Char]]
01:07:53 <Lokadin> wherever it is that you decalre it
01:09:19 <xinming> Lokadin: I didn't have a line which is like IO[[Char]]
01:09:24 <xinming> http://paste.lisp.org/display/13908
01:09:25 <Lokadin> say how do you make amulti line comment
01:09:33 <boegel|home> how can I check if the element ("foo",n) is a list list of type [(String,Int)], where it doesn't matter what n is ?
01:09:42 <skew> xinming: you need to run askForWords in the else branch to get more words, rather than sticking it in the list
01:10:06 <skew> likst else do moreWords <- astkForWords; return (word:moreWords)
01:10:35 <boegel|home> > [("blah",2)] == [("blah",2)]
01:10:36 <lambdabot> True
01:12:52 <kzm_> boegel|home, any (\(x,y)->x=="blah")?
01:13:16 <kzm_> @lambdabot any (\(x,y)->x=="blah) [("blah",4)]
01:13:16 <lambdabot> Unknown command, try @listcommands.
01:13:35 <skew> @pl (\(x,y) -> x == "blah")
01:13:36 <lambdabot> ("blah" ==) . fst
01:13:47 <kzm_> :-)
01:13:53 <Lokadin> i go sleep
01:13:54 <Lokadin> cya
01:13:56 <boegel|home> kzm_: kay, thanks
01:15:20 <xinming> skew: could u please give me an fixed example?
01:15:33 <kzm_> > any ((=="blah").fst) [("blah",4)]
01:15:34 <lambdabot> True
01:16:05 <skew> xinming: put that line I wrote in instead of the else clause you have
01:16:09 <kzm_> Sorry, that should of course be 'any ((=="blah") . fst) [("blah",4)]'
01:16:30 <xinming> skew: thanks
01:17:52 <xinming> asd.hs:15:8: Parse error in pattern
01:21:17 <xinming> and I can use the function askForWords
01:30:32 <ProfTeggy> Moin
01:31:19 <Itkovian> meuning
01:47:03 * boegel|home = off
01:52:04 <dons> oh, and now my old message gets through. old well
02:00:13 <luqui> Hi.  I'm looking for a function Monad a => (a -> m b) -> m (a -> b)
02:00:21 <luqui> does one exist? (hoogle returns nothing)
02:00:26 <luqui> can one even be made?
02:01:02 <o_Rocky> @listcommands
02:01:02 <lambdabot> use listcommands [module|command], please. Modules are:
02:01:02 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
02:01:02 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
02:01:02 <lambdabot> topic type version vixen where
02:01:24 <o_Rocky> i think yes
02:01:27 <o_Rocky> it can be done
02:03:32 <o_Rocky> @type return
02:03:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
02:03:40 <o_Rocky> @type >>=
02:03:40 <lambdabot> parse error on input `>>='
02:03:44 <o_Rocky> @type (>>=)
02:03:45 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
02:11:59 * luqui doesn't think it's possible
02:12:46 <o_Rocky> why not?
02:13:17 <o_Rocky> you just have to belive it to make it happen, just like in the matrix :P
02:15:09 <luqui> :-)
02:15:20 <luqui> I don't really want to set out on proving it, but I played with some monadic code
02:15:34 <luqui> and it almost seemed like a fixpoint...
02:15:51 <luqui> (requiring MonadFix, which I don't have the liberty of having)
02:16:25 <luqui> I ended up needing the function I was defining in its own definition
02:17:34 <o_Rocky> yes, you will have som problems if you try to do something polymorfic like the type signature you described
02:18:39 <o_Rocky> however you cold have Monad a => (a -> m b) -> m (a -> m b)
02:19:15 <o_Rocky> @type return
02:19:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
02:19:16 <luqui> which is what I settled on
02:19:42 <o_Rocky> your a here has the type a -> m b, do you understand?
02:20:43 <o_Rocky> if you had Monad a => (a -> m b) -> m (m b)
02:20:49 <o_Rocky> you cold do join
02:20:52 <o_Rocky> @type join
02:20:53 <lambdabot> Not in scope: `join'
02:21:06 <o_Rocky> @type Control.Monad.join
02:21:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
02:25:46 <o_Rocky> @type do {return readFile}
02:25:47 <lambdabot> forall (m :: * -> *). (Monad m) => m (FilePath -> IO String)
02:25:57 <o_Rocky> but you can't do:
02:25:59 <o_Rocky> @type Control.Monad.join (do {return readFile})
02:26:00 <lambdabot>   No instance for (Monad ((->) FilePath))
02:26:00 <lambdabot>   arising from use of `Control.Monad.join' at <interactive>:1:0-17
02:26:45 <araujo> Good morning!
02:27:39 <o_Rocky> araujo: are you portuguese?
02:29:51 <araujo> No.
02:31:54 <o_Rocky> araujo: whats you nacinality?
03:35:10 <marcot> dcoutts: Hello.
03:35:39 <marcot> dcoutts: The debian package for gtk2hs-0.9.10 is in mentors.debian.net
03:36:20 <triplah> eep
03:36:21 <triplah> minima xs = foldl min xs
03:36:21 <triplah>         deriving Show
03:36:25 <triplah> howcome i cant derive show?
03:38:05 <Saulzar> I thought deriving was something you can only use for a data type to provide a default instance, and that doesn't look like a data type
03:38:20 <triplah> ahh
03:38:22 <triplah> duh
03:38:25 <triplah> thanks
03:38:26 <triplah> <-- new
03:41:39 <triplah> sorry can someone tell me what foldl1 is as opposed to foldl ?
03:42:33 <ulfdoz> triplah: essentially the same except, that foldl takes some "start-value", while foldl1 takes the head of the list as such.
03:43:09 <ulfdoz> foldl f x xs == foldl1 f (x:xs)
03:43:43 <tic|school> eek, monad transformers make me go crazy.
03:43:43 <triplah> ahhh brilliant
03:43:49 <triplah> was wondering where the extra arg was
03:43:50 <triplah> :)
03:43:55 <tic|school> or rather, the operations I want to do with them.
03:44:58 <yozora> are monad transformers much different to nested monads?
03:45:21 <tic|school> not from what I've gathered. Just easier to use, it seems.
03:45:30 <tic|school> Oh well, it's not really the transformers that are causing the problem..
03:46:28 <yozora> cool thanks
04:19:13 <soysauce> @seen xerox
04:19:13 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #
04:19:13 <lambdabot> haskell 14 hours, 57 minutes and 57 seconds ago, and I have missed 6
04:19:13 <lambdabot> seconds since then.
04:19:34 <boegel> shapr: ping
04:46:19 <dons> @yow
04:46:19 <lambdabot> I feel like I'm in a Toilet Bowl with a thumbtack in my forehead!!
04:46:41 <boegel> yo dons 
04:47:53 <luqui> reader isn't a monadfix!?
04:49:47 <dons> yo boegel, just adding stuff to take 10
04:49:52 <dons> on the wiki atm.
04:54:05 <ricebowl> there's a foldl that is strict somewhere in the library, isn't there?
04:54:07 <ricebowl> @type foldl'
04:54:08 <lambdabot> Not in scope: `foldl''
04:54:44 <shapr> boegel: pong
04:54:50 <dons> @type List.foldl'
04:54:51 <lambdabot> Not in scope: `List.foldl''
04:54:52 <yozora> @type Prelude.foldl`
04:54:53 <lambdabot> parse error (possibly incorrect indentation)
04:54:56 <yozora> @type Prelude.foldl'
04:54:57 <dons> @index fold'
04:54:57 <lambdabot> Not in scope: `Prelude.foldl''
04:54:57 <lambdabot> bzzt
04:55:02 <dons> @index foldl'
04:55:02 <lambdabot> Data.List
04:55:12 <dons> @type Data.List.foldl'
04:55:13 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:55:19 <dons> gotcha!
04:55:21 <ricebowl> ah, Data.List, was looking in the wrong place
04:55:33 <shapr> @quote
04:55:34 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from
04:55:34 <lambdabot> England just to kill me if I did that
04:56:10 <dons> heya shapr
04:56:49 * ricebowl wonders why foldl itself isn't strict
04:57:30 <dcoutts> ricebowl, because then you couldn't short-circut foldl computations
04:57:46 <dcoutts> and you couldn't get lazy results
04:57:54 <dons> it would really suck :)
04:57:59 <ricebowl> how can you short-circuit the computation?
04:58:05 <ricebowl> you either get a result or you don't, no?
04:58:08 <dons> take 10 
04:58:11 <dcoutts> by not looking at the tail of the list
04:58:17 <ricebowl> foldl doesn't produce a list
04:58:23 <dons> sure it does
04:58:24 <ricebowl> it produces a "scalar" value
04:58:30 <ricebowl> ??
04:59:04 <dons> > take 10 $ foldl (x _ -> 1:x) [] [] 
04:59:04 <lambdabot>  parse error on input `->'
04:59:06 <dcoutts> > foldl (flip (:)) "" "foobar"
04:59:07 <lambdabot> "raboof"
04:59:12 <dons> > take 10 $ foldl (\x _ -> 1:x) [] [] 
04:59:13 <lambdabot> []
04:59:18 <ricebowl> does foldl' force complete evaluation of [b]? I just mean that once the computation starts, the entire computation should run to completion...
04:59:19 <dons> or something :S
04:59:25 <kombinator> dcoutts: could you give an example where foldl' fails and foldl works well?
05:00:02 <ricebowl> > take 5 (foldl (flip (:)) [] [1..])
05:00:07 <lambdabot> Terminated
05:00:20 <ricebowl> yeah, I don't see it.
05:01:11 <ricebowl> foldl either produces an answer or it doesn't, and laziness isn't going to do anything useful there, AFAICT :/
05:01:24 <ricebowl> with respect to all the a's in foldl's type
05:07:27 <dons> foldl requires a finite list, but doesn't need to force all the elements in the list it constructs, right?
05:07:38 <dons> if you lookk at foldl' : foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:08:00 <ricebowl> ah, I see
05:08:00 <dons> a lazy foldl isn't going to force evaluation of each element along the way
05:08:12 <ricebowl> > take 5 (foldl (flip (:)) [] (replicate 5 [1..]))
05:08:13 <lambdabot> [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
05:08:13 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
05:08:13 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
05:08:13 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
05:08:13 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
05:08:15 <lambdabot> [24 @more lines]
05:08:34 <ricebowl> > take 5 (List.foldl' (flip (:)) [] (replicate 5 [1..]))
05:08:34 <lambdabot>  Not in scope: `List.foldl''
05:08:35 <dons> which is what I was badly trying to explain earlier with the:
05:08:38 <dons> > take 10 $ foldl (\ls n -> n : ls) [] [1..100]
05:08:39 <lambdabot> [100,99,98,97,96,95,94,93,92,91]
05:08:47 <ricebowl> > take 5 (Data.List.foldl' (flip (:)) [] (replicate 5 [1..]))
05:08:48 <lambdabot> [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
05:08:48 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
05:08:48 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
05:08:48 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
05:08:48 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
05:08:50 <lambdabot> [24 @more lines]
05:09:01 <ricebowl> er, heh, that's getting annoying
05:09:02 <dons> but they produuce the same result, it's just when things are evaluated, if they need to be.
05:09:02 * ricebowl stops
05:09:13 <ricebowl> *nods*
05:09:25 <dcoutts> > length $ foldl (\ a b -> b:a) [] [undefined, undefined]
05:09:26 <lambdabot> 2
05:09:35 <dons> ah, very nice dcoutts, thankyou
05:09:50 <ricebowl> > length $ Data.List.foldl' (\ a b -> b:a) [] [undefined, undefined]
05:09:51 <lambdabot> 2
05:10:11 <dons> hmm.
05:10:28 <ricebowl> hmm... evaluation of the b's seems to purely depend on the function passed to fold
05:11:02 <dons> so each time the result of (\a b -> b: a) is forced
05:11:14 <ricebowl> it can't be :p
05:11:14 <kzm_> @pl (\ a b -> b:a)
05:11:15 <lambdabot> flip (:)
05:11:28 <ricebowl> > Data.List.foldl' (\ a b -> b:a) [] [undefined, undefined]
05:11:29 <lambdabot> Add a type signature
05:11:31 <dons> the cons is seq'ed in foldl', isn't it?
05:11:33 <ricebowl> oh, blah
05:11:43 <ricebowl> dons - yes, that is my understanding
05:12:23 <ricebowl> but fold' does something like this: foldl' f (x `seq` f x) xs
05:12:35 <dons> fold' ?
05:12:40 <ricebowl> foldl', sorry
05:12:52 <ricebowl> so it should only force the resulting list
05:12:58 <dons> -- | A strict version of 'foldl'.
05:12:58 <dons> foldl'           :: (a -> b -> a) -> a -> [b] -> a
05:12:58 <dons> foldl' f a []     = a
05:12:58 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:12:58 <ricebowl> not any of the elements inside it to which it is agnostic
05:13:15 <ricebowl> yeah
05:13:25 <ricebowl> oops, I meant f a x
05:13:41 * ricebowl blushes
05:13:45 <ricebowl> well, you know what I meant :)
05:13:48 <dons> but the function can be arbitrary, so you could pass a function that inspects the elements, rather than just building things with cons, couldn't you?
05:13:59 <ricebowl> you could
05:14:13 <dons> so that it could hit an undefined in a strict version, and not in a lazy version
05:14:16 <ricebowl> but if you did, wouldn't it have to inspect them regardless?
05:14:51 <dons> would it? or could it just leave it unevaluated, depending on how much output you consume
05:15:07 <ricebowl> hm, I see
05:15:52 * shapr hit an undefined with A STICK!
05:15:52 <ricebowl> > fst . foldl (\(x, y) z -> (x+z, y)) (0, undefined) [1..10]
05:15:53 <lambdabot> Couldn't match `a1 -> (a, b)' against `(a2, b1)'
05:16:04 <shapr> greetz dons 
05:16:32 <ricebowl> @pl \(x, y) z -> (x+z, y)
05:16:32 <lambdabot> uncurry (flip . ((,) .) . (+))
05:16:52 <ricebowl> heh curious!
05:16:58 <dcoutts> > foldl (\ a b -> b) 0 [undefined,2]
05:17:00 <lambdabot> 2
05:17:05 <CosmicRay> I'm trying to build GHC on AIX and am getting errors in AdjustorAsm.S.  Anybody know anything about this?  Can I disable it somehow?
05:17:07 <dcoutts> > Data.List.foldl' (\ a b -> b) 0 [undefined,2]
05:17:08 <lambdabot> Undefined
05:17:16 <ricebowl> *nods* I see
05:17:39 <dons> :)
05:17:43 * shapr yodels cheerfully
05:17:51 <dcoutts> last = foldl (\ a b -> b) (error "last []")
05:18:03 <waltz> well hello shapr
05:18:09 <shapr> hiya waltz 
05:18:22 <ricebowl> hm, I guess I usually don't take advantage of laziness
05:18:22 <shapr> dons: Hey, what do you think about @define support for plugs?
05:18:30 <dons> what does @define do shapr?
05:18:49 <shapr> In the original @eval lambda interpreter, you could make new definitions.
05:18:56 <shapr> @get-definition S
05:18:56 <lambdabot> Unknown command, try @listcommands.
05:19:02 <dons> ah, and you want it for @eval ?
05:19:06 <ricebowl> @pl \(s, ((x, ys), y)) -> (s, (x, y:ys))
05:19:08 <lambdabot> uncurry ((`ap` snd) . (. fst) . (`ap` snd) . (. fst) . (. ((. flip (:)) .
05:19:08 <lambdabot> (.) . (,))) . (.) . (.) . (,))
05:19:14 <dons> could be done
05:19:16 <ricebowl> ooh, that's just ugly.
05:20:13 <takuan> is there anybody who uses the numeric prelude?
05:20:33 <dons> import Numeric?
05:20:42 <ricebowl> does GHCi have anything like @pl?
05:21:15 <dons> nope. except for loading Pl in ghci, and calling it yourself ;)
05:21:16 <shapr> takuan: I've tried it once or twice, but don't really need it.
05:21:30 <ricebowl> is that a module?
05:21:43 <dons> part of lambdabot yep, but just a normal Haskell module
05:22:47 <shapr> Is there any sort of calendar module for Haskell? I have this urge to make a shared calendar thingy...
05:22:51 <boegel> shapr, dons: would you care to test out the Vote plugin I'm writing for lambdabot ? (join #boegelBotTesting)
05:23:07 <ricebowl> dons - what's the name of it?
05:30:25 <shapr> ricebowl: Pl.hs
05:30:59 <musasabi> @version
05:31:00 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
05:31:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
05:31:31 <ricebowl> awesome
05:31:43 <ricebowl> pl is really nice
05:37:32 <shapr> TheHunter wrote it.
05:38:25 <ricebowl> @pl \p f -> f p
05:38:25 <lambdabot> flip id
05:38:35 <ricebowl> um, that can't be right
05:38:38 <musasabi> Does lambdabot have a function for matching hostmasks?
05:38:52 <takuan> shapr: you know of anybody else using it?
05:38:59 <ricebowl> > (flip id) 1 (\x -> x+1)
05:39:00 <lambdabot> 2
05:39:16 <musasabi> e.g. is foo!~bar@abc-231.baz.com the same as foo!*@*.baz.com
05:39:25 <shapr> takuan: I've heard of a few people on #haskell using it, but I don't remember who. You could search the logs.
05:39:30 <ricebowl> > flip 1 (\x -> x+1)
05:39:31 <lambdabot>  add an instance declaration for (Show (a -> c))
05:39:35 <shapr> musasabi: It doesn't but it's been on the todo list for years.
05:39:43 <shapr> musasabi: All the info is available though:
05:39:49 <shapr> @echo fooby boo
05:39:50 <lambdabot> echo; msg:Message {msgPrefix = "shapr!n=user@h69n2fls35o817.telia.com",
05:39:50 <lambdabot> msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo fooby boo"]} rest:
05:39:50 <lambdabot> "fooby boo"
05:40:56 <musasabi> mmh, makes things simple.
05:41:17 <shapr> Has anyone investigated using darcs for http push according the email Juliusz sent?
05:42:01 <shapr> musasabi: Right now, lambdabot privileges are only based on nickname. That hasn't been a problem so far, so I guess we've been following the YAGNI principle.
05:42:09 <musasabi> mmh
05:42:14 <musasabi> I'll hack something
05:43:28 <flux__> uh, how would anyone ever make priviledges based on nick :-o
05:43:40 <dons> shapr, but also, freennode makes it a bit harder to fake privs now
05:43:43 <flux__> I suppose dynamic ip's are so common nowadays
05:44:05 <shapr> Cale: Want to write about laziness for TMR?
05:44:18 <dons> I think the point is that the privs are very low level anyway, it's not as if you get any major powers
05:44:28 <ulfdoz> ipv6 will probably fix this issue as soon as it is common for a larger amount of providers.
05:44:36 <shapr> Yeah, you can turn off lambdabot and ... ?
05:44:50 <dons> right, it just reconnects. so big deal :)
05:45:14 <shapr> ulfdoz: I can't easily purchase an IPv6 connection / address in Sweden.
05:46:26 <ulfdoz> shapr: At least here in germany I got my subnet for free and native out of the wall in my flat.
05:47:18 <shapr> Lucky you, I want to play with real multicast.
05:47:53 <shapr> All of the 6 on 4 wrappers rely on the multicast ability of the underlying IPv4 layer.
05:53:02 <kzm_> No way to :m Foo.Bar.Zot as Zot, I suppose?  (Save a bit of GHCI command line space)
05:53:11 * JKnecht is looking into IPV6/Bind9.3.1. Any known Haskell interfaces?
05:53:27 <kzm_> Hmm.. guess I can make a minimal module re-exporting the deeply buried one, and just import that instead.
05:56:42 <musasabi> How do I get a greedy "many" with ReadP ?
05:58:09 <xerox> Hey.
05:59:55 <kzm_> (I don't know ReadP, but how can "many" not be greedy?!  Always return the empty string as its parse? :-)
06:08:23 <soysauce> ack
06:08:28 <soysauce> I just got back, grr
06:08:38 <soysauce> and xerox has left already
06:10:51 <luqui> Hi, what's up with this:
06:10:52 <luqui> Illegal instance declaration for `Run (Val -> Val)'
06:11:21 <luqui> what's especially weird is that "instance Cast (Val -> Val)" is perfectly fine
06:11:30 <luqui> but it doesn't work with the Run class
06:12:52 <luqui> anyone?
06:14:15 <bringert> strange
06:14:32 <bringert> luqui: can you paste your code somewhere?
06:14:41 <SM_ax> @paste
06:14:41 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:14:57 <SM_ax> I think some code can help...
06:15:34 <luqui> well, it's a large project.  I'll include the relevant definitions from other files at the top of the paste
06:19:17 <luqui> pasted
06:21:32 <bojohan> bringert: how's gf mode?
06:21:34 <luqui> wait, hang on, that one works under  -fglasgow-exts
06:21:44 <luqui> here's the one that really doesn't work
06:21:48 <luqui> pasted
06:24:40 <SM_ax> you forgot to actually declare instance
06:25:11 <luqui> SM_ax, what?
06:25:26 <luqui> Cast has instances, if that's what you're asking...
06:25:36 <SM_ax> one sec
06:28:17 <SM_ax> you should do:
06:28:17 <SM_ax> class Cast a => Run a where
06:28:31 <SM_ax> I guess this is what you are trying to do
06:29:16 <luqui> but (Val -> Val) doesn't have a Cast instance..
06:29:30 <luqui> I'm saying "anything that is a Cast instance should also be a Run instance"
06:29:42 <musasabi> Adding the nicks was easy - next is executing events in the future (does any plugin do that yet?)
06:30:03 <SM_ax> Then:
06:30:04 <SM_ax> class Run a => Cast a where
06:30:20 <luqui> why do I have to add such dependencies?
06:30:46 <SM_ax> I don't know -- it is your program :)
06:31:12 <luqui> I've seen what I'm trying to do done before, eg.
06:31:20 <SM_ax> "anything that is a Cast instance should also be a Run instance" == class Run a => Cast a where
06:31:36 <luqui> instance (Ord a) => Ord (a,b) where ...
06:31:55 <luqui> Yes, but I don't want them to have to implement a run instance before they can implement the cast instance
06:32:07 <takuan> humz
06:32:08 <luqui> the run instance *depends* on the methods of cast
06:32:18 <takuan> is it normal the numeric prelude doesn't compile?
06:33:56 <SM_ax> what do you mean "depends"? In what way?
06:34:15 <Akshaal> what does 'Warning: orphan instances' mean?
06:35:03 <SM_ax> I though you were trying to do "inheritance"-like stuff
06:38:11 <luqui> SM_ax, no, no
06:38:24 <triplah> @pastebin
06:38:24 <lambdabot> Unknown command, try @listcommands.
06:38:33 <triplah> @listcommands
06:38:34 <lambdabot> use listcommands [module|command], please. Modules are:
06:38:34 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
06:38:34 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
06:38:34 <lambdabot> topic type version vixen where
06:38:36 <luqui> Run is things that you can get out fully evaluated (with the default setup)
06:38:44 <luqui> Cast is things you can get out an Eval monad for
06:38:53 <luqui> anything you can get an eval monad for, you can get fully evaluated
06:38:58 <luqui> it was a convenience class
06:39:13 <luqui> I wouldn't say there's any "traditional OO" relationship between the two
06:40:15 <triplah> http://pastebin.com/436873
06:40:20 <triplah> anyone care to looksie at that?
06:40:26 <triplah> i'll wager its a simple solution
06:42:00 <triplah> er sorry
06:42:01 <triplah> updated
06:42:19 <SM_ax> Hmm, I still feel that Run is just a more general case of Cast
06:42:30 <triplah> hmm nm
06:42:35 <triplah> got it to compile
06:42:40 <fworp> would something like this work? class Run a => Cast a where { ... } instance Run a => Cast a where { ... } 
06:43:03 <fworp> (i know thats valid in form, i just dont know if its applicable)
06:44:12 <SamB> hmm, is the font "tir" for pdfTeX in the tetex-extras package?
06:45:00 <SamB> hmm, probably not...
06:46:49 <fworp> valid with undecidable instances anyhow
06:47:10 <SM_ax> So, for every Cast instance there must be a Run instance anyway
06:48:15 <fworp> yeah, you constrain valid instances, and then you instantiate all of them in one go
06:49:16 <SM_ax> luqui, how there can be an instance of Cast that is not an instance of Run?
06:49:52 <SM_ax> If there is no way, that class Run a => Cast a where {...} is a way to go
06:50:03 <SM_ax> *than
06:51:29 <SM_ax> If there is some way, than don't make any dependencies and whenever you need both to be implemented, state that explicitly
06:52:20 <SM_ax> such as (for example) :  func :: (Cast a, Run a) => a -> a -> a 
06:53:02 <SamB> @help tell
06:53:02 <lambdabot>  @help <command> - ask for help for <command>
06:55:18 <SM_ax> triplan, did you mean _minimaBy there?
06:55:30 <SM_ax> triplah. sorry
06:57:00 <boegel> to Dusan Kolar on the Haskell mailing list: I'd say your first mistake is writing ugly code :|
06:57:09 <triplah> SM_ax: yep. i'm still having problems now though
06:58:53 <triplah> SM_ax: http://pastebin.com/436878
06:58:56 <triplah> brb smoke
06:59:15 <triplah> ergh, its updating
06:59:21 * triplah taps fingers
06:59:37 <triplah> connecion refused
06:59:38 <triplah> :(
07:00:01 <SM_ax> triplah, yep
07:00:03 <triplah> i'll bbs and try pastebin it again
07:00:09 <SM_ax> I can't get there too
07:00:14 <triplah> ahh damn
07:00:18 <SM_ax> @paste
07:00:18 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:00:54 <triplah> do i need to sign up?
07:01:25 <Lemmih> lisppaste2: url
07:01:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:02:31 <lisppaste2> triplah pasted "new haskeller" at http://paste.lisp.org/display/13915
07:02:38 <triplah> i'll be back in a tick
07:12:13 <SM_ax> _minimaBy f e (x:xs) = if (f e) = (f x) then e:(_minimaBy f e xs) else if (f e) < (f x) then (_minimaBy f e xs) else _minimaBy f x (x:xs)
07:12:21 <SM_ax> is that ok? :)
07:13:15 <triplah> hmm
07:15:46 <SM_ax> no, wrong too :)
07:16:03 <triplah> its throwing a parse error on the assignment =
07:16:07 <triplah> the first =
07:17:29 <shapr> musasabi: Future event is an oft-requested lambdabot feature, and would likely turn into an oft-used library.
07:18:53 <triplah> SM_ax: logically what you have said makes sense to me
07:18:57 <triplah> but it wont compile
07:19:05 <bringert> bojohan: I'm not writing any GF grammars ATM, so I haven't had much opporutunity to test the GF mode
07:19:43 <musasabi> so no luck there either.
07:20:23 <triplah> SM_ax: ignore me, rogue space at the start of the line
07:20:24 <triplah> :P
07:21:03 <triplah> SM_ax: ok thats a lot better
07:21:07 <triplah> almost there :D
07:21:08 <musasabi> shapr: I know of GPL code to do that, but no BSD licensed one.
07:21:24 <SM_ax> triplah, :)
07:22:58 <bojohan> ok
07:24:57 <shapr> musasabi: What's the GPL code?
07:25:01 * shapr prefers GPL anyway.
07:26:13 <musasabi> HAppS stuff, not yet in the tree I think.
07:26:33 <triplah> SM_ax: thanks for the hand
07:26:38 <triplah> time for me to go to bed
07:26:41 <bojohan> bringert: tools/mktoday.sh in the 20051118 snapshot doesn't have the execute bit set, btw
07:26:42 <triplah> nn all
07:27:06 <SM_ax> triplah, I didn't help :)
07:27:18 <musasabi> GPL just causes problems, personally I prefer licenses which don't force things on other files.
07:27:48 <Lemmih> > let _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) = if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy id [2,4,1,1,5] []
07:27:49 <lambdabot> [1,1]
07:28:37 <Lemmih> tsk
07:29:07 <shapr> musasabi: Did you see my blog post about the GPL?
07:29:29 <shapr> musasabi: I'd be happy to publish any feedback.
07:30:08 <bringert> bojohan: it seems like there is no --set-scripts-executable flag to darcs dist
07:30:45 <musasabi> reading it now.
07:31:04 <bringert> bojohan: BTW, GF is now in darcs, so you shouldn't need the snapshots
07:31:22 <bringert> darcs get http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/
07:31:41 <shapr> yay!
07:31:45 <shapr> GF in darcs, w00!
07:31:52 <xerox> What is GF?
07:32:00 <bringert> shapr: oh, yeah I should have told you
07:32:04 <shapr> Grammatical Framework
07:32:10 <bringert> @where gf
07:32:10 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
07:32:24 <shapr> bringert: Only because I'm the walking #haskell index ;-)
07:32:28 <shapr> chatting*
07:32:51 <shapr> CosmicRay: Hey, how do I contribute to HWN again?
07:34:12 <boegel> bringert: so desperately looking for a gf you need lambdabot for it ? tssk
07:34:31 <bringert> bojohan: thanks for reporting that, I've fixed the Makefile to do chmod a+x tools/mktoday.sh when making snapshots
07:35:08 <shapr> I know, lambdabot needs a @hwn plugin where people can do @hwn-add Bj√∂rn Bringert mentioned that the Grammatical Framework is now using darcs, darcs get http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/
07:35:11 <musasabi> shapr: The problem as I see it is that if I create GPL code and accept patches from other people - then it cannot be used after that in a free way. e.g. I had some code that would have solved some of joelr's problems, but since it was GPL he couldn't use it. Also if I would have rewritten the code I would have produced more or less the same - thus not safe.
07:36:16 <bringert> boegel: I don't need to ask lambdabot for a girlfriend, lambdabot is a girlfriend!
07:36:21 <shapr> musasabi: I criticise that software business model as well, from the viewpoint that source that will never be released serves no societal benefit.
07:36:23 <bringert> @vixen right?
07:36:24 <lambdabot> correct
07:36:47 <musasabi> shapr: it finances open source development on the other hand.
07:37:01 <shapr> I'm not convinced of that.
07:37:06 <bringert> @vixen do you want to be boegel's girlfriend?
07:37:06 <lambdabot> yes, and i always get what i want
07:37:11 <shapr> haha
07:37:16 <bringert> boegel: watch out
07:37:30 <shapr> musasabi: How do you see it financing OSS dev?
07:37:31 <xerox> shapr: like Google's SoC ?
07:37:37 * xerox boings
07:38:03 <shapr> xerox: Google's business model doesn't depend on closed source at all, it depends on a 'public utility' approach to searching.
07:38:22 <xerox> It does for sure, in some parts
07:38:24 <shapr> I mentioned that a few blog posts back.
07:38:27 <shapr> How so?
07:38:34 * shapr is happy to have nifty discussion!
07:38:42 <xerox> Gmail code?  His linux boxes kernels?
07:38:47 <SamB> xerox: maybe its just that they couldn't get all their code untangled from their own computers?
07:38:47 <xerox> etc etc
07:39:19 <shapr> xerox: Any custom kernel code that Google uses could happily be GPL, they're not redistributing it.
07:39:40 <shapr> Same for Gmail. Google uses software as service, not a product.
07:39:53 <SamB> anyway, linux is already GPL...
07:40:25 <musasabi> shapr: but they don't want people duplicating the services without the effort.
07:40:40 <shapr> musasabi: huh?
07:41:00 <SamB> musasabi: well, its hard to convince VCs that cloning google is a good idea
07:41:17 <shapr> Yahoo etc are already trying to clone Google?
07:41:27 <shapr> In fact, Google is an altavista clone, right?
07:41:29 <SamB> I thought Yahoo was older?
07:41:34 <musasabi> shapr: e.g. when google was rising it would have been easy to kill it by taking their (code if in open) and just get more resources.
07:41:44 <SamB> hmm
07:42:03 <musasabi> google had better web page classification things which were a factor to it rising.
07:42:06 <SamB> but who would maintain it if you killed google?
07:42:07 <shapr> Sure, but Google still benefits from GPL and BSD code equally, they're not selling a product.
07:42:37 <Akshaal> hrrrr
07:42:40 <Akshaal>     No instance for (GString Char)
07:42:40 <Akshaal>       arising from use of `Test.QuickCheck.vector' at src/Data/GString.hs:677:17-25
07:42:42 <Akshaal>     Probable fix: add an instance declaration for (GString Char)
07:42:43 <Akshaal>     In the expression: Test.QuickCheck.vector 4 :: Test.QuickCheck.Gen [Char]
07:42:59 <shapr> The GPL only requires someone to publish source code for a product they sell, not source code used for a service.
07:43:04 <Akshaal> why GString is there?
07:43:28 <shapr> That's why snort( or some other security tool?) went closed source recently
07:43:47 <musasabi> shapr: true, but if the code is not published then the license is not that important.
07:44:12 <musasabi> (except it cannot be shown to third parties in an easy way)
07:44:27 <soysauce> xerox - hey
07:44:32 <soysauce> I did that translation last night
07:44:40 <shapr> So my original point is that the GPL benefits society in the original spirit of the US Patent System.
07:44:50 <shapr> And that the BSD license does not.
07:45:05 <soysauce> GPL benefits assuming people make use of GPL'd code
07:45:21 <shapr> For those following along, this discussion started here - http://www.scannedinavian.com/2005-11-20.html
07:45:37 <shapr> soysauce: You surely can't make use of code you don't have.
07:45:38 <musasabi> shapr: except GPL does not benefit you if you are creating free software which does not happen to share the GPL license.
07:46:24 * musasabi wants an easy license like "keep this code free, but link to whatever you want"
07:46:28 <shapr> That depends, at least you have source you can read to learn stuff. Closed source wouldn't help you at all.
07:47:04 <SM_ax> musasabi, GPL is *THAT* easy in fact
07:47:13 <soysauce> shapr - Microsoft already does release code under a license similar to BSD
07:47:29 <SM_ax> The whole license text just defines the word "free" :)
07:47:34 <shapr> soysauce: Have they released all of their old software products?
07:47:45 <xerox> I don't understand why is it different to sell a software or a space on a webpage (in form of paid searches result)
07:47:50 <soysauce> no, since most of them are still in use?
07:47:50 <shapr> soysauce: Have they released everything that ever used a BSD license :-)
07:47:51 <xerox> Heya soysauce.
07:47:51 <musasabi> shapr: Actually usually one tries to avoid looking at the GPL source, so that one is not subject to claims having copied parts with alterations from it.
07:48:12 <soysauce> xerox - I rewrote using arrays instead of lists, it's actually a lot easier to read now
07:48:18 <shapr> soysauce: Windows 3.11? MSDOS?
07:48:19 <xerox> soysauce: heh.
07:48:20 <soysauce> although more verbose. But that's primarily because I added a shitload of comments.
07:48:29 <soysauce> shapr - yes, Windows 3.11 code is still in use.
07:48:59 <shapr> Do you think Windows 3.11 makes enough money for Microsoft that they need to keep it closed source?
07:49:00 <soysauce> shapr - I *have* the source to Windows Server 2003 pre-SP1 at work. This code is equivalent in the XP line of somewhere in between the original release and SP1.
07:49:10 <soysauce> and yes, there is code that is *older* than Windows 3.11 that is still in use
07:49:37 <soysauce> I'm not debating that it would be helpful to the rest of the world for MS to distribute the source to their OSes
07:49:54 <soysauce> just stating that that old code is still in use and is not "retired"
07:50:04 <shapr> The US Patent System gives a limited monopoly so that technical innovations will be invented, and then given to everyone after a certain amount of time. Closed source does not follow that pattern.
07:50:20 <soysauce> yes, sure
07:50:40 <shapr> In my experience, most companies will use BSD licensed code and never release anything back to the community.
07:50:57 <soysauce> there was some pro-Linux movie I watched with a friend that gave tremendous insight into MS's attitude toward closed/open source
07:51:08 <musasabi> shapr: How would you feel about a license with a "after five years the code must be given to public - before that you may use it like BSD"
07:51:10 <shapr> There are enough companies using GPL code as closed source...
07:51:12 <soysauce> they're not against open-source. However, they are completely contraposed against GPL.
07:51:15 <shapr> musasabi: I would LOVE it!
07:51:29 <shapr> BSD with timed GPL would kick ass!
07:51:36 <soysauce> shapr - businesses are out to make money
07:51:46 <shapr> soysauce: I'm out to make software.
07:51:49 <soysauce> they open source things when it benefits them
07:51:57 * soysauce shrugs
07:51:58 <musasabi> shapr: But the largest problem would be that it would be GPL incompatible (if one is not very cautious)... Thus no touching GPL code after that.
07:51:59 <shapr> Closed source does not benefit me.
07:52:07 <soysauce> some people "get it" and open source when it no longer has any value to them
07:52:31 <soysauce> but most don't because there has not been any particularly strong push on the business/management side of things
07:52:33 <musasabi> and that is one very nasty part of GPL
07:52:42 <shapr> For that matter, I don't think closed source benefits many companies either.
07:52:50 <soysauce> where I work, I asked about open-sourcing some code that I wrote. Ultimately it was painful to go through the red tape and just wasn't worth it.
07:52:54 <soysauce> I'm rewriting the code in the clean
07:52:58 <musasabi> Because it is incompatible with many licenses that even FSF considers free software licenses.
07:53:00 <shapr> musasabi: I would be *very* interested in a timed GPL license.
07:53:07 <pejo> shapr, I'll name a few: Oracle, Microsoft.
07:53:33 <shapr> pejo: You're naming those who benefit from closed source? If so, I agree with those two.
07:53:45 <soysauce> er, doesn't IBM benefit even more?
07:54:03 <pejo> soy, IBM is a service company, not a software one. 
07:54:05 <soysauce> well, I suppose IBM earns its money on raping you after you buy, not the purchase itself
07:54:08 <shapr> In general, hardware companies benefit more from open source.
07:54:15 <pejo> shapr, yeah, good that you agree. :-)
07:54:19 <shapr> soysauce: aka, service, not software.
07:55:09 <shapr> pejo: Yeah, but I could make a much longer list of companies who would benefit from open source, because they're selling services, not products.
07:55:17 <Frederick> yo folks
07:56:15 <shapr> musasabi: Until there is a BSD with timed GPL, I'll be in favor of GPL.
07:56:18 <eivuokko> I am not too sure about Oracle being clear cut for closed source.
07:56:25 <SamB> companies should open source things which they no longer wish to pay to maintain or support
07:56:35 <shapr> And yet, they almost never do...
07:56:45 <eivuokko> It is work, you know...and no income in it.
07:56:46 <flux__> 'bsd with timed gpl'?
07:56:50 <shapr> My last J2EE job wouldn't open source my cool Jython PowerPoint clone, for example.
07:56:52 <Frederick> yo SamB I will bug you today too =/
07:57:12 <flux__> and what's wrong with lgpl?
07:57:23 <CosmicRay> autrijus: ping
07:57:29 <shapr> flux__: Check the long scrollback :-)
07:57:33 <flux__> I mainly try to avoid gpl-stuff just in case I might want to make my own decisions of the license of my code
07:57:33 <CosmicRay> anyone familiar with the AdjustorAsm.S in ghc?
07:57:43 <flux__> shapr, how many hours?-)
07:57:56 <shapr> flux__: Last fifteen minutes I think
07:58:11 <flux__> of course, I could still later turn my code into non-gpl by rewriting the gpl parts
07:58:14 <soysauce> shapr - my personal thoughts are that GPL is sometimes appropriate and BSD is at other times appropriate. Circumstances depend on [whether the code is maintained, end user who borrows it, purpose of the code] and probably other things, too.
07:58:15 <shapr> flux__: starts with <shapr> musasabi: I'd be happy to publish any feedback.
07:58:29 <shapr> soysauce: When do you think BSD is appropriate?
07:59:17 <soysauce> shapr - I had an insightful conversation with a coworker/friend when I interned at Microsoft regarding GPL vs. BSD. This was during the big scandal where SCO was sueing everyone they could.
07:59:36 <shapr> j'ecoute, expliquez!
08:00:02 <flux__> shapr, where's the blog entry?
08:00:08 <soysauce> shapr - from his point of view, XFree (or do they call it XOrg now) makes it difficult for a *business* to compete in that sector of the market
08:00:14 <eivuokko> And for example Windows 3.11, how do you know that it is even nearly compilable without license to some closed source library or some such?  Is it worth to go through code and remove traces of possibly licensed code (cut and paste inlining) that can't be given out?
08:00:15 <shapr> flux__: http://www.scannedinavian.com/2005-11-20.html
08:00:27 <soysauce> because a business is naturally going to want to protect their invested code, and it's difficult to get people to buy open source
08:00:44 <eivuokko> It simply isn't tar cvfz and put up source on HTTP to open source.
08:00:45 <soysauce> so extending XFree is out of the question from the business perspective
08:01:01 <soysauce> which means that you have to write something *better* than XFree to sell your product
08:01:06 <shapr> eivuokko: And yet, if all the closed source libs used the timed GPL principle, it would be.
08:01:20 <CosmicRay> hmm..  how can I tell ghc to use particular args for the assembler?
08:01:21 <soysauce> whereas if the code were BSD, it could be extended to create a useful product
08:01:35 <pejo> soy, why is it impossible to extend Xorg? Isn't  that under the MIT license or whatever it is called? (Basically a BSD license).
08:01:35 <shapr> CosmicRay: Probably -opts $ARGS
08:01:42 <shapr> CosmicRay: I know that -optl is for the linker flags.
08:01:43 <soysauce> my attitude toward software is usually that I am happy if someone uses my code, so I generally slap a BSD license on my stuff
08:01:55 <soysauce> pejo - one of them is GPL. I don't remember.
08:02:16 <pejo> soy, ah, thats Xfree86. Do they still have any users? :-)
08:02:17 <shapr> As far as I know, XFree has always been MIT licensed, which is pretty much BSD.
08:02:22 <soysauce> lol
08:02:26 <shapr> Am I confused?
08:02:29 <CosmicRay> shapr: I mean, I want the ghc binary itself to automatically use this
08:02:45 <CosmicRay> shapr:  I'm in the process of building ghc right now and the stage1 compiler got this wrong
08:02:45 <shapr> CosmicRay: Add it to the pragma at the top of the .hs file?
08:02:46 <pejo> shapr, Xfree changed to GPL right before 4.4  (on some RC).
08:02:47 <soysauce> shapr - was referring to XFree86 ;)
08:02:54 <shapr> CosmicRay: oh, alter config.mk probably
08:02:54 <soysauce> I have always had them confused
08:02:56 * soysauce shrugs
08:03:00 * boegel leaves for today
08:03:07 <shapr> bye boegel!
08:03:08 <CosmicRay> shapr: that's what I thought first too, but I don't see it there
08:03:49 <shapr> soysauce: Ok, so... what's the BSD appropriate part?
08:04:12 <pejo> soy, the thing is that a lot of companies might just as well release the source to their Xorg extensions and put it in the tree. The talk about "all the IP" in the code is greatly exaggerated quite often. 
08:04:38 <soysauce> shapr - well, if I don't care to maintain a piece of code, I use a BSD license so that anyone can do anything they like with it
08:04:46 * soysauce switches to ricebowl persona
08:04:51 <shapr> Yeah, how long does a particular graphics board contribute value to a company? And how will keeping the specs secret remove value from the company?
08:04:58 <neologism> any skilled mathematician here?
08:05:03 <eivuokko> shapr, I doubt that companies would take the risk.  That is very unclear on how to link to non-GPL compatible proprietary APIs.  And a lot of programs do.
08:05:04 <shapr> soysauce: How is that different from GPL?
08:05:12 <ricebowl> shapr - sure, but at some point you have to be pragmatic
08:05:12 <neologism> skilled with proofs in formal languages
08:05:29 <shapr> ricebowl: Meaning what?
08:05:34 <ricebowl> shapr - because GPL implies that someone is going to do it (probably) for free, on their own time
08:06:01 <shapr> I don't get it?
08:06:05 <ricebowl> shapr - GPL is only compatible with a services-based offering, no?
08:06:14 <flux__> shapr, I like to see all kinds of software to be better, not only free :)
08:06:31 <shapr> It's compatible with a product-based offering as long as you release your changes to the customer.
08:06:42 <shapr> And they get those changes under the GPL license.
08:06:44 <neologism> noone is willing to help me with the proof? :)
08:06:53 <ricebowl> shapr - why should the customer buy a program that they can download?
08:06:57 <eivuokko> ricebowl, project-based (integration, customising) and services-based (dissemminate content etc)
08:07:21 <shapr> ricebowl: Why can they download the program?
08:07:56 <tuomov> there'a a rather good book on free software business models in finnish, itself also available freely from (www.avoinelema.fi)
08:07:57 <shapr> The customers are allowed to redistribute the sources, but that's their choice.
08:08:04 <eivuokko> Ehm.
08:08:15 <eivuokko> Doesn't GPL have "public written offer" for sourceS?
08:08:33 <flux__> obviously the customer will want to sell the sources if they get for example half the money they paid for the product in the first place
08:08:52 <flux__> I think gpl only requires the one who gets the binary to get the sources too
08:08:56 <flux__> which is imo sensible
08:09:16 <pejo> flux, so what prevents that customer from giving away the source, and binary?
08:09:30 <flux__> pejo, nothing
08:09:35 <ricebowl> eivuokko - yes
08:09:40 <ricebowl> I thought that was the point of the GPL...?
08:09:53 <shapr> ricebowl: Yeah, but only the one who gets the binary gets to request the sources.
08:10:14 <flux__> I was just saying to shapr's "it's their choice" that the client will want to give the sources almost always
08:10:39 <ricebowl> anyway, I have never heard of a successful commercial GPL project. I have heard of GPL projects off of which money was made in a different fashion, e.g. selling hardware or services
08:10:51 <shapr> Plone is quite successful.
08:11:00 <tuomov> what license is eclipse under?
08:11:03 <shapr> Shockingly successful in fact. I sort of wish it would die die die.
08:11:12 <tuomov> it became succesfull only after freed
08:11:24 <flux__> commercial success?
08:11:31 <cjb> ricebowl: emacs was a successful commercial GPL project, once upon a time.
08:11:35 <yaarg> Eclipse Public License
08:11:35 <shapr> Yeah, the Plone authors make lots of money off of Plone.
08:11:51 <cjb> RMS would charge $100 for a tape with emacs on, or something.  n/a now that we have good bandwidth.
08:11:53 <flux__> shapr, how?
08:12:03 <shapr> I think the difference is that businesses are convinced that the value is in the source. I am convinced that the value is in the people!
08:12:20 <flux__> well, there must be some value in the source, because without source there's no product
08:12:41 <tuomov> making money with code is extortion, selling services is honest business
08:13:03 <shapr> Yes, but, most products don't really do what the customer wants, it only does part of what they want.
08:13:06 <flux__> infact GPL-kind of business model has the selfdriving need of making imperfect software, because perfect software would need no support.
08:13:33 <ricebowl> cjb - hum, never knew it was commercial
08:13:34 <shapr> A GPL'd 'product' would sell existing value and inexpensive customizations as a service.
08:13:34 <tuomov> someone will perfect it anyway, who doesn't have a vested interest, fork if necessary
08:13:35 <ricebowl> interesting
08:13:43 <ricebowl> I see.
08:13:56 <flux__> well what if the product was dead simple to customize by the client himself?
08:14:11 <shapr> Then he'd be done with that need, and have something else for you to do :-)
08:14:14 <cjb> ricebowl: Well, it wasn't commercial in the sense that RMS wanted to make money for himself.  But he did charge more than it cost him, and used the profit to fund FSF.
08:14:15 <ricebowl> flux__ - support is more than bug fixing
08:14:27 <shapr> In my opinion, our job as programmers is to program ourselves right out of a job... and into a new job!
08:14:37 <tuomov> there's always customisations that need new programming
08:14:41 <shapr> I mean, c'mon, wouldn't you rather work on a whole new program every year or so?
08:14:42 <flux__> besides, someone else can pick the task of supporting the software, after you've spent much effort doing the tool creating the aftermarket ;)
08:14:42 <ricebowl> shapr - that is the ideal ;)
08:14:44 <sieni> flux__: so a ghc is not perfect, because using it usefully requires one to know Haskell?
08:15:04 <cjb> Yeah, most support is customisation.  RT (Request Tracker), for example, has a company around custom scripts, tuning for speed.
08:15:14 <eivuokko> Also, support, customisation and integration are not neccesarily what everyone wants to do.  I for one hate that part of doing software.
08:15:19 <tuomov> flux__: and that's a great thing since there's no monopoly supported by force
08:15:30 <flux__> sieni, well, I wouldn't say any compiler is perfect, they require ever so complicated instructions to function
08:15:33 <cjb> eivuokko: Don't, then.  :)
08:15:35 <tuomov> anyone can support the software... those who wrote it have a head start, though
08:15:44 <shapr> SleepyCat has been highly successful with the berkeley DB etc, for how many years?
08:15:50 <eivuokko> cjb, I don't, that is right.
08:15:54 <tuomov> and when others have catched up, they should've moved on to new things anyway, instead of milking a dead cow
08:16:11 <shapr> Even microsoft uses the BDB.
08:16:34 <pejo> shapr, but Berkeley DB is just open source, the license isn't free, is it?
08:16:52 <shapr> er, what do you mean?
08:17:00 <flux__> let's say one day one was to write a program that can understand phrases in english and rewrite itself to perform whatever task the client might want. well, maybe you'll start selling 'how to make a specification in plain english'-courses..
08:17:08 <ricebowl> SVN uses BDB too, and SVN is free
08:17:13 <ricebowl> so BDB would have to be free.
08:17:19 <pejo> shapr, are you allowed to just download bdb from their homepage and put it in your product which is under a commercial license?
08:17:19 <ricebowl> although SVN has another back-end now
08:17:58 <shapr> I doubt it. I suspect it's more likely you can purchase a BSD licensed version.
08:17:59 * shapr checks
08:18:08 <C-Keen> you could put a gpl program as well in your product and put your code (that does not alter the GPL program) under a commercial license as well
08:18:22 <shapr> This another aspect of GPL based profit... sell 'em a commercial version if they really want one. You have the copyright.
08:18:31 <ricebowl> shapr - BDB is used in SVN which itself has a BSD license; either they offer it free for free projects, or it's free for everyone
08:18:50 <shapr> In that case, it sounds like BDB is BSD.
08:18:53 <C-Keen> distributing the source applies only to modifications you make to an gpl'ed program
08:19:04 <eivuokko> C-Keen, that is grey area of derived program.  It isnt soemthing you can trust.
08:19:08 <C-Keen> merely using it does not suffice
08:19:15 <shapr> Anyway, the knowledge and understanding that comes from writing a program is much more valuable than the program itself.
08:19:17 <flux__> shapr, yeah, although you must acquire the copyrights for every patch provided by an outsider
08:19:26 <shapr> Client needs always change.
08:19:29 <flux__> or, just fork it
08:19:51 <ricebowl> shapr - sure. I don't think many people disagree with you that OSS is valuable.
08:19:57 <C-Keen> eivuokko: no derived is something different than "uses"
08:20:00 <ricebowl> I think we only disagree on how to get there ;)
08:20:32 <shapr> Aha, dual-licensed - http://www.sleepycat.com/company/licensing.html 
08:20:34 <tuomov> it'll happen in many ways
08:20:57 <shapr> ricebowl: My argument is that with BSD, we won't get there as quickly.
08:21:08 <shapr> Because companies just don't release their source.
08:21:23 <shapr> So I've decided that if they the benefits of using my code, I should get the benefits of using their code.
08:21:25 <pejo> shapr, and the obvious counter argument is that companies won't put GPL source in their products.
08:21:34 <shapr> That's fine with me.
08:21:56 <Spark> bsd if you want to spread a design, gpl if you want to spread an implementation
08:22:03 <pejo> shapr, sÂ svenskt. :-)
08:22:08 <shapr> I wonder how much of the BSD licensed version of Wine is still in TransGaming's commercial WineX/Cedega.
08:22:09 <Spark> and a design could be a protocol or a format or something
08:22:32 <flux__> I would _so_ much love if matlab used libreadline.. but even then, readline isn't a killer feature, or even anything that would sway your decision on which software you'll use
08:22:40 <Spark> that i think is the most fantastic failure of the bsd license
08:22:44 <flux__> (realistically I rarely use matlab these days though ;))
08:22:59 <shapr> pejo: I don't want to sell anything. I want to spread the ability for people to do things for themselves.
08:22:59 <ricebowl> pejo - lol
08:23:07 <tuomov> I'd rather have a decent free matlab clone, or even better, something better than matlab and free
08:23:17 <tuomov> octave is unfortunately still missing a lot
08:23:20 * shapr quotes from his blog
08:23:23 <C-Keen> I think there are two different point of views involved. If you don't care about the code in terms of what people might do with it "Maybe this will be useful to someone else too" then BSD license is choosen. If you want to make a statement like "I write free software and it must stay free" -> GPL
08:23:34 <tuomov> fortress (iirc) seems like something that could be the better matlab clone
08:23:46 <Spark> fortress the languge?
08:23:48 <Spark> language?
08:23:51 <tuomov> yeah
08:23:52 <shapr> yup
08:23:56 <ricebowl> shapr - you assume that a company picking up a piece of source and selling it is a bad thing; it's not ideal, but to me it doesn't seem so terrible
08:24:01 <ricebowl> I would rather my code be used than not
08:24:02 <Spark> hmm perhaps
08:24:08 <Spark> but its a long way in the future
08:24:10 <xerox> http://games.slashdot.org/article.pl?sid=05/11/23/138200&tid=128&tid=211&tid=10
08:24:49 <shapr> ricebowl: No, I have no problem with a companies selling source I wrote. I just have a problem with not getting to see any improvements or bugfixes.
08:24:55 <tuomov> in a sense, bsd is the anarchic way of reaching info-communism, and gpl the authoritarian-marxist
08:25:28 <ricebowl> tuomov - I was thinking of that analogy earlier ;)
08:25:29 <shapr> I'd just say the GPL is a legal klein bottle, it's a basilisk against the system.
08:25:34 <ricebowl> but I thought it might be offensive and so said nothing
08:25:59 <eivuokko> tuomov, yeah, I often feel like it was that kind of set up.
08:26:24 <shapr> I think this whole discussion boils down to where you see the value. Is software a product, or a service? I say it's a service, most companies say it's a product.
08:26:40 <Spark> s/product/asset/
08:26:57 <shapr> ?
08:27:07 <Spark> it doesnt have to be a product for it to be closed source
08:27:35 <Spark> if the company provides a service using some inhouse software, then their business model wont work if that software is open because other companies will undercut them
08:27:55 <ricebowl> Spark - that is true.
08:27:56 <shapr> Good point, but the GPL still works for that case.
08:28:06 <shapr> The GPL only affects software products.
08:28:13 <ricebowl> that is actually how the company I work for operates ;)
08:28:15 <ricebowl> to some extent.
08:28:28 <Spark> shapr: true, the gpl would allow them to keep their inhouse software closed
08:30:22 <shapr> So, in my opinion, the advantage of the BSD is that it appeals to selfish software companies because they get something for nothing.
08:30:26 <shapr> :-)
08:30:36 <tuomov> Spark: gpl3 may not
08:31:14 <Spark> still, i think bsd is appropriate for some software
08:31:25 <shapr> Can you explain which software?
08:31:32 <Spark> e.g. if you invent a new format for compressed video
08:31:37 <Spark> you'd bsd the encoding / decoding
08:31:43 <Spark> because the software itself is not what you want to spread
08:31:50 <neologism> bsdl is good when you dont care about the politics and just want to create good sw
08:31:56 <Spark> and if e.g. windows media player nicks it, then thats a good thing
08:32:09 <ricebowl> indeed, neologism said it better than I was able to
08:32:14 <C-Keen> Spark: if you want to spread something like this code is not what matters...more like wether the algorithm is open
08:32:26 <tuomov> neologism: there may be other kinds of politics involved
08:32:26 <shapr> How does the GPL keep you from creating good software?
08:32:27 <Spark> C-Keen: nothing like a reference implementation
08:32:29 <C-Keen> e.g. free to use
08:32:33 <ricebowl> more commercial software blows hard because they care nothing about quality, just about meaning some predetermined benchmark with no basis in reality
08:32:34 <Spark> C-Keen: you would explain the algorithm too of course
08:32:47 <Spark> C-Keen: but that explanation is illustrated by the implementation
08:32:53 <neologism> well... bsdl is for coders.. gpl for political fanatics :))))
08:32:56 <tuomov> neologism: e.g. with ion for me it is more important to smash WIMP than to ensure that my code stays free
08:32:59 <neologism> (sarcasm)
08:33:04 <Spark> ignoring the politics is a fast way to get ignored by the politics
08:33:07 <neologism> what is wimp?
08:33:10 <ricebowl> shapr - it doesn't. GPL just prevents your "good software" from finding use.
08:33:17 <shapr> ricebowl: I disagree completely.
08:33:26 <tuomov> neologism: windows, icons, menus and a pointing device or something like that.. the "modern" gui
08:33:27 <ricebowl> s/prevents/hinders/
08:33:41 <shapr> ricebowl: We just discussed a bunch of business models that work fine with the GPL.
08:33:43 <neologism> tuomov: I absolutely dont understand your point
08:33:54 <flux__> shapr, GPL excludes a certain group of software from using it, yes?
08:33:59 <neologism> how does licence affect user interface/
08:34:02 <ricebowl> tuomov - if the winamp guys hadn't been bought out by AOL, I don't think that would be a problem ;)
08:34:05 <ricebowl> WMP is horrible.
08:34:05 <Spark> there are some things for which open source is *completely* inappropriate
08:34:07 <Spark> e.g. defence apps
08:34:14 <Spark> because then the niggers will know our frequencies
08:34:17 <flux__> shapr, and it is perceivable that group might include some good software? ..
08:34:19 * SamB just BSDs everything so as to avoid trouble in the future
08:34:25 <shapr> And I hope I pointed out some cases where the choice of BSD over GPL hindered a software product (Wine and WineX).
08:34:30 <tuomov> neologism: that's it's great if someone decides to create something ion-derivative and better than ion, no matter whether it is free or not
08:34:40 <neologism> ion being what?
08:34:48 <Spark> people are often scared to use (not extend) software because of the gpl though
08:34:48 <ricebowl> SamB - you can always change the license later
08:34:52 <Spark> this is what my flat mate argues
08:34:58 <tuomov> neologism: http://iki.fi/tuomov/ion/ (it's lgpl these days, though, but it used to be artistic)
08:34:58 <flux__> has it really? would there exist a software like Cedega (?) had it been GPL?
08:35:09 <Spark> i think it might be down to lawyer paranoia or poor choice of gpl/lgpl
08:35:10 <shapr> Spark: Yeah, but microsoft advertising aside, there's no basis in reality for that.
08:35:12 <eivuokko> ricebowl, after you got contributions from others, it isn't so easy, neccesarily.
08:35:18 <cjb> SamB: "in the future"?  You're the copyright holder; you can change the license anytime you like.
08:35:29 <SamB> ricebowl: only if it is BSD today!
08:35:42 <neologism> tuomov: what does the short stand for?
08:35:44 <shapr> flux__: Cedega isn't Wine.
08:35:51 <tuomov> neologism: which?
08:35:55 <neologism> ion
08:35:59 <ricebowl> eivuokko - ah, that is true
08:35:59 <tuomov> nothing
08:36:01 <SamB> I don't want to have to ask for copyright assignment
08:36:03 <neologism> ah :)
08:36:15 <tuomov> neologism: but I do have another vapourware project called vis :)
08:36:21 <flux__> shapr, it's a derivative?
08:36:24 <neologism> ...
08:36:30 <eivuokko> Being GPL or BSD doesnt matter for relicensing.  You hold copyright, you have right to license parts you wrote.  If you have contributions from others, BSD or GPL, you cant relicense them always.  And even if you can BSD -> GPL, you can't neccesarily hold to that in court.
08:36:35 <flux__> isn't winex cedega's old name
08:36:38 * neologism wonder when this will turn into emacs vs vi :)))
08:36:42 <flux__> (I haven't been following that much the wine scene)
08:37:12 <C-Keen> eivuokko: in some parts of this world you can. At least in Germany you can. 
08:37:17 <shapr> flux__: WineX was a commercial derivative of the Wine project. TransGaming embraced and extended Wine. They claim to have rewritten WineX entirely for Cedega, but I wonder how much of the BSD Wine code is still in there.
08:37:21 <SamB> cjb: what about those patches?
08:37:22 <C-Keen> this has been approved
08:37:33 <tuomov> flux__: more of a beer drinker, eh?-)
08:37:41 <eivuokko> C-Keen, As I said, neccesarily.
08:37:48 <neologism> I think that so much license debate is true sign of GPLism :))
08:38:13 <shapr> neologism: Well, I'm interested. I was in favor of the BSD up until recently.
08:38:13 <ricebowl> eivuokko - actually IIRC the BSD license doesn't prohibit you from repackaging under a narrower license such as GPL
08:38:30 <neologism> shapr: when did you stop?
08:38:35 <ricebowl> heh sorry, I'm not paying close attention ;)
08:39:01 <eivuokko> ricebowl, Yes, but you cannot sue over that part on all part of world.  Know GNU copyright thingy form?  It is so that FSF can present you on license issues on their programs.
08:39:05 <neologism> and did it make your erection better? if not then it was a bad move :)
08:39:21 <ricebowl> *nods*
08:39:38 * eivuokko has to go
08:39:39 <shapr> neologism: On the twentieth of November. While writing this blog post, I realized that closed source works like trade secrets. Society does not benefit from research and development that is lost forever. How many pieces of abandonware have you wished were open source?
08:40:00 <neologism> well... I believe in market
08:40:05 <neologism> ie. no enforcing
08:40:19 <neologism> and I think that the best license will prevail
08:40:25 <tuomov> copyright is enforced
08:40:36 <ricebowl> shapr - I don't see what that epiphany has to do with BSD vs. GPL. :)
08:40:39 <tuomov> I believe in abolition of copyright (and ip, and property, and ..)
08:40:43 <neologism> you can always decide on your own what license you want
08:40:45 <neologism> so no enforcing
08:40:58 <neologism> ricebowl: nor me :)
08:41:00 * dcoutts_ believes in copyright for a limited term
08:41:13 <neologism> the code always stays X licensed.. whats the problem then?
08:41:21 * dcoutts_ believes in copyright for creative works
08:41:22 <ricebowl> yeh, heh, copyrights need to be severely curbed
08:41:35 * dcoutts_ wonders why binaries can be copyrighted
08:41:57 * SamB likes the BSD because it works with slightly non-free licenses
08:42:15 <ricebowl> copyrights on binaries makes sense, but not for the incredibly long term allowed under US law.
08:42:34 <shapr> ricebowl: South Africa has been breaking international patent law by producing anti-AIDS medicines that it cannot afford to license. If manufacture of those medicines were not patented, but instead kept completely secret...
08:42:44 <dcoutts_> ricebowl, not under the original idea of copyright it doesn't (I think)
08:43:01 <ricebowl> shapr - I know, I know. That's a different can of worms, though.
08:43:20 <ricebowl> dcoutts_ - hasn't it always been to protect the original author's interests for a limited term?
08:43:25 <tuomov> I'm not so sure it's such an issue... given the time, it's possible to reverse-engineer them
08:43:27 <flux__> shapr, often not having some software is a convenience issue, not a life-or-death one
08:43:29 <shapr> Not so much... one part of the hacker ethic is that no one should have to go throuh the drudgery of duplicating an existing solution.
08:43:42 <dcoutts_> ricebowl, no. It's to encourage progress in the creative arts.
08:44:11 <tuomov> ricebowl: it's been always about protecting the printing presses interests... authors had to go through them in the past
08:44:24 <dcoutts_> ricebowl, by giving the creator limited exclusive rights for a limited term.
08:44:32 <ricebowl> *nods*
08:44:50 <tuomov> in other words, interests of capital
08:44:56 <shapr> So, when will Microsoft's limited term expire? When do we see the source?
08:45:11 <ricebowl> another 50 years, IIRC
08:45:13 <ricebowl> ;)
08:45:24 <liyang> I think the source is trade secret..
08:45:26 <dcoutts_> suppose all software was distributed as source, then it would still be protected by copyright.
08:45:30 <shapr> How many companies have gone bankrupt, and now the source will never be released?
08:45:48 <dcoutts_> but one could fix it if it broke (though you still would not be able to re-sell it)
08:45:53 <ricebowl> shapr - I am not in disagreement that that is a travesty, but how is GPL going to fix that?
08:46:05 <ricebowl> those companies aren't going to OSS their code regardless of where they get it from
08:46:15 <tuomov> you can't resell in quantities even without copyright; someone will just duplicate your efforts in the free version
08:46:18 <tuomov> it doesn't pay to not cooperate
08:46:26 <shapr> Because companies will start basing their products on GPL, and then releasing the source to their customers.
08:46:35 <ricebowl> when?
08:46:39 <shapr> Then if a companies rolls over and dies, the advances won't be lost.
08:46:49 <shapr> ricebowl: As soon as they release it makes good business sense.
08:46:56 <shapr> realize*
08:47:01 <tuomov> and anyone can use the non-free version without paying you too
08:47:05 <ricebowl> I think that's already been considered and firmly rejected, whether true or not
08:47:12 <ricebowl> and I think the truthhood remains to be seen in either case
08:47:14 <tuomov> so it's just better to cooperate and release the source
08:47:18 <flux__> there exist some source escrow companies
08:47:43 <flux__> so you can make a deal so that they'll have a copy of the source code, and if you go under, they'll give the source to your clients
08:47:56 <ricebowl> shapr - my company has considered using OSS, though for what it's worth people were not planning on recontributing released changes
08:48:03 <ricebowl> and we're small, so not a big target for FSF
08:48:18 <ricebowl> I was less than impressed, but not surprised.
08:49:07 <ricebowl> GPL gives the FSF and others a legal leg to stand on, but if we were sure that we'd get caught, then we wouldn't think of using it
08:49:28 <ricebowl> s/of/about/
08:50:10 <ricebowl> shapr - from my experiences, I think it's unreasonable to think that GPL is somehow going to coerce businesses to change their practices
08:50:22 <tuomov> if I worked for a company that was going to do something like that, I'd inform against them
08:50:26 <ricebowl> though my experiences are limited <shrug> maybe I'm wrong
08:50:29 <tuomov> no matter ndas and what would happen to the job
08:50:45 <ricebowl> tuomov - fortunately I didn't have to make that decision
08:50:47 <dcoutts_> ricebowl, IBM has changed their practices. They now release lots of GPL software.
08:50:50 <shapr> ricebowl: It'll happen once GPL based companies make more money for less effort and kill off the purely closed source companies.
08:51:07 <shapr> ricebowl: Which as you said, is not the majority at the moment.
08:51:16 <ricebowl> dcoutts_ - true, but they are service-based, and it isn't going to change product-based companies
08:51:44 <dcoutts_> ricebowl, they're service based now because they saw that it was the future.
08:51:56 <dcoutts_> they wern't always that way
08:51:56 <shapr> Yeah, I agree.
08:52:38 <dcoutts_> and now they're using high-quality GPL software to their competitive advantage against product-based competitors
08:52:48 <shapr> Of course, I'd like to make their product a service as well.
08:53:32 * ricebowl shrugs
08:53:49 <musasabi> shapr: how do you envisage a one player game working for a company with open source? (not in five years, but right from the start)
08:53:51 <ricebowl> we'll see, but my personal thought is that GPL will always be a FOSS thing
08:54:01 <jlouis> Conjure updated again ;)
08:54:06 <jlouis> We are running steady
08:54:30 <shapr> musasabi: The media/content is the product there. Geeky users would end up contributing fixes, even.
08:54:59 <musasabi> shapr: but that should be open source too.
08:55:25 <musasabi> shapr: and selling the boxes is not going to make profit as your rivals can undercut you.
08:55:38 <shapr> Yeah, but I wouldn't sell boxes anyway...
08:55:45 <musasabi> so what would you sell?
08:56:12 <jlouis> Give up part of the game for free and provide additional content as long as the paypal keeps trickling in
08:56:17 <tuomov> one could do a preorder sort of thing; the full game will be release when enough has been collectively paid on an account
08:56:19 <shapr> The music industry has amply demonstrated that profit from creative works will come from a globally efficient distribution network.
08:56:26 <jlouis> tuomov: +1
08:56:52 <shapr> If you can walk to the corner and buy Doom 4 for ten euro, it's worthwhile.
08:57:26 <shapr> If you can sit in your chair and get Doom 4 delivered to your door in twenty minutes for twelve euro, that's even better.
08:57:58 <shapr> I'd set up a global akamai-style network that can print up most any sort of media.
08:58:04 <jlouis> In the world, people are working so much, that they will prefer to have it delivered by mail
08:58:12 <araujo> Hello Haskell'ers!
08:58:17 <jlouis> hey araujo 
08:58:20 <shapr> I'd prefer to have it arrive on my harddrive nearly instantly.
08:58:39 <araujo> Hello there jlouis 
08:58:42 <jlouis> We'll just have to distribute it by bittorrent then. Conjure will be the beginning
08:58:46 <jlouis> MUhahah1
08:59:20 <shapr> I could go on about this system in great detail, if you really want to hear about it :-)
09:00:05 <shapr> In my opinion, games, songs, etc should cost about one euro and arrive on your hard drive in less than ten minutes after purchase.
09:01:00 <shapr> I predict that the global distribution network will be one or more companies that sell bulk distribution, and the content providers buy a contract with those companies.
09:01:40 <shapr> Content providers will pay artists according to the predicted sales of a creation, probably using a long-tail sales model.
09:01:41 <jlouis> Heh, I should go home from work, but I feel like idling
09:01:57 <jlouis> I am searching job adverts like mad
09:02:20 <shapr> Right now, there's a whole lot of stupid between an artist recording a song and consumers being able to purchase the song.
09:03:04 <shapr> musasabi: What do you think? Might work, or am I smoking crack?
09:03:48 <musasabi> shapr: would work in a better world, hard to get to work in our world.
09:03:53 <jlouis> shapr: both.
09:03:56 <shapr> haha
09:03:59 <myrkraverk> shapr: maybe, but the game development is, afaik, slightly more complex than song recording
09:04:24 <shapr> musasabi: I think it'll work just fine, as soon as someone starts doing it.
09:04:31 <tuomov> I think people would pay either that or a monthly fee if they could get good fast downloads, and all that they want is available
09:04:33 <shapr> Now who would give me vulture capital for this? ;-)
09:04:47 <tuomov> personally I'd never pay 1e for a track in advance
09:04:53 <tuomov> but I could pay e.g. 20e/month
09:06:36 <myrkraverk> tuomov: I am, however, against all such "taxing"
09:06:38 <shapr> myrkraverk: It doesn't have to be that way. If commercial libraries become a commodity like songs, you could build a game for about the same effort that it takes to record a song.
09:06:57 <tuomov> myrkraverk: it wouldn't be taxing, but the payment for a good download service
09:07:04 <tuomov> post-copyright
09:07:21 <myrkraverk> tuomov: IMO, that's just taxing ;)
09:07:43 <shapr> Nah, you can quit paying a stupid ISP. :-/
09:07:44 <tuomov> no, you can still get the tracks from your friends or whoever, but it's a payment for convenient access
09:07:48 <myrkraverk> shapr: yes, and then we'd get the same crap for games we get for songs ;/
09:07:55 <tuomov> for service
09:08:05 <myrkraverk> shapr: I don't pay a stupid ISP ;P
09:08:19 <myrkraverk> shapr: I only pay for the ADSL hw part
09:08:30 <myrkraverk> shapr: that is, the physical line
09:08:32 <shapr> myrkraverk: Crappy songs is an artifact of the distribution network. Check out magnatune.com, legaltorrents.com, bt.etree.org, etc.
09:09:02 <myrkraverk> shapr: and the fact that the record companies want to control what songs are popular
09:09:26 <shapr> Yes, exactly. That same problem is happening with Activision and related.
09:09:33 <musasabi> shapr: the problem is that people already have that and it works for works of all authors. It is called pirating. Making a legal service that works better and is anonymous would be challenging.
09:10:06 <tuomov> warez isn't as convenient to access as things could be
09:10:16 <tuomov> not everything is always available, the quality is varied
09:10:23 <musasabi> depends on where one lives.
09:10:25 <myrkraverk> tuomov: or convenient to use, in many cases
09:10:33 <shapr> I don't think it would be that hard actually. The fact that free p2p services are beating the music industry supports my opinion that the music industry is doing a stupendously bad job.
09:10:39 <musasabi> and in some cases it has better quality than official releases.
09:10:49 <tuomov> otoh, warez is _much_ more convenient than the current alternatives :)
09:11:10 <myrkraverk> tuomov: depends on the ware in question ;)
09:11:40 <musasabi> first one would need an anonymous payment system and a very good distribution network - and get much content into the system.
09:11:50 <myrkraverk> tuomov: I've used stuff that I absolutely hate (pirated visual studio, ca. '97), and now I try to avoid all warez
09:12:13 <shapr> I think the very good distribution network would make a payment system much easier.
09:12:26 <tuomov> well, I don't use much software warez
09:12:31 <tuomov> only maple recently
09:12:37 <myrkraverk> tuomov: neither do I :)
09:13:44 <shapr> Anyway, I hope you've enjoyed this short tour of the alternate reality that I inhabit ;-)
09:14:01 <tuomov> (and I use maple just because I feel more comfortable with it than the mathematics the current uni provides, and which doesn't work over the network properly on my system)
09:14:07 <shapr> I'll write up this discussion in my next blog post if I have time.
09:14:10 <tuomov> s/mathematics/mathematica/
09:14:38 <musasabi> A good and cheap distribution service for alternative music could be a start.
09:14:55 <kosmikus> CosmicRay: I'm not sure what the default is at the moment, but with the current Cabal from darcs you at least have options --enable-library-for-ghci and --disable-library-for-ghci ...
09:15:04 <shapr> musasabi: Sadly, there are patent issues.
09:15:33 <musasabi> shapr: of course software patents don't hold their own yet in EU.
09:15:43 <shapr> musasabi: Patents for on-demand point-of-sale production of media are held by a German company last I checke.d
09:16:16 <musasabi> shapr: I was thinking of electronic distribution without the hasle of physical copies.
09:16:44 <shapr> Yeah, that would probably work.
09:17:34 <shapr> I'd set it up via IPv6 multicast to save bandwidth, and keep big honking stacks of harddrives at local hotspots.
09:18:29 <shapr> I'd probably aim for an mnesia-style 'private' p2p system that would migrate content to the area with the most requests.
09:18:51 <shapr> Then you could upload to any node and replication and migration would be automatic.
09:20:02 <shapr> musasabi: Hey, did you try ghc-smp yet?
09:31:59 <musasabi> shapr: I am still lacking memory for the machine (they are lying around somewhere safe from people like me)
09:34:20 <shapr> heh
09:37:31 <Frederick> is anyone here familiar with formal languages?
09:40:03 <Frederick> where is everybody
09:45:55 <Frederick> folks is anyone here familiar with formal languages?
09:46:19 <shapr> How do I derive Show on a GADT?
09:46:24 <shapr> Frederick: Like what?
09:47:34 <Frederick> shapr, SamB helped me with a CFG validator and handler but my teacher says a step in the algorithm is wrong now I have 2 problems 1¬∫ understand why it is wrong by geting a understandable copy of th algorithm 2 fixing that
09:47:56 <neologism> what is cfg validator?
09:48:01 <neologism> how does it validate the grammar?
09:48:10 <Heffalump> shapr: I believe the answer is that you don't
09:48:17 <Frederick> neologism, checks if the grammar is a context free grammar
09:48:27 <neologism> ah
09:48:33 <neologism> may I see it?
09:48:38 <shapr> Heffalump: I know it works, but I don't remember if only works in 6.5.
09:48:41 <Frederick> neologism, are you familiar with CFGs? suuuuuuuuuure
09:48:43 <Heffalump> I vaguely recall autrijus trying to make it work a while back
09:48:44 <neologism> I currently mess with such stuff so I might be helpfull
09:48:47 <Heffalump> so maybe it is only in 6.5
09:48:56 <neologism> Frederick: yes.. I am familiar with CFGs
09:49:04 <neologism> I spent whole day doing CFG related shit
09:49:16 <shapr> I thought it might be in 6.4.1 too.
09:49:22 <shapr> But I get a syntax error, so I'm not sure.
09:49:24 <Frederick> neologism, I will paste in a sec
09:49:45 <neologism> well.. checking if a grammar is CFG should be quite trivial
09:50:00 <lisppaste2> Lokadin pasted "Test.hs" at http://paste.lisp.org/display/13922
09:50:01 <lisppaste2> Frederick pasted "Wonrg implementation of remove replacers" at http://paste.lisp.org/display/13923
09:50:18 <Lokadin> say can anyone tell me why it is that line 8 give a parse error :(
09:50:19 <Lokadin> ?
09:50:23 <Lokadin> f 0 = 1
09:50:54 <neologism> Frederick: tell me the idea of checking
09:51:00 <Lokadin> says parse error at =
09:51:23 <Frederick> neologism, the only restriction over cfgs is that the left side of the rule of production must have a single variable
09:51:37 <fworp> Lokadin: you are using bracket notation, but not seperating definitions with ;'s
09:51:50 <Frederick> neologism, are you familiar with grammar simplification?
09:51:51 <Lokadin> fworp: o
09:51:57 <neologism> yes
09:52:05 <neologism> or.. what do you mean by simplification?
09:52:20 <neologism> I did all kinds of trasnformations but I wouldnt dare to call them simplificaiton ;)
09:52:46 <Frederick> neologism,steps you take in order to have a simpler grammar, like remove empty productions, symbols that substitute variables, useless productions
09:53:05 <neologism> ah.. yes I am familiar with that
09:53:15 <fworp> just remove the curly brackets, and it should work fine, or add the semicolons
09:53:28 <Frederick> my step that does productions that substitute variables is broken
09:53:29 <Lokadin> fworp: thanks :D
09:53:34 <fworp> no problem
09:53:37 <Frederick> let me get a cfg as sample and run
09:53:52 <neologism> what do you call "a production" ?
09:53:59 <neologism> a grammar rule?
09:54:36 <Frederick> neologism, given S -> a, "a" is what I call production
09:54:42 <neologism> ah
09:54:49 <neologism> the product of the derivation step
09:55:13 <neologism> where do you have that implemented?
09:55:39 <Frederick> neologism, remove repalcers
09:55:43 <Frederick> *replacers
09:56:30 <neologism> what is that function supposed to do?
09:56:41 <neologism> it takes grammar and removes what?
09:57:11 <neologism> (commenting the code wouldnt hurt)
09:57:56 <shapr> hey SyntaxNinja, ltns
09:58:12 <Frederick> neologism, I will make a kinda bigtext so wait a min please
09:58:24 <neologism> I am leaving in 15 minutes ;(
09:58:37 <neologism> and the code is quite difficult to read for me :(
09:58:56 <Frederick> neologism, it takes the transitive closure of a variable and removes variables in the form A -> B
09:59:30 <Frederick> I googled the whole net for a sample of this algorithm with a step by step approach
09:59:31 <neologism> ie. A->B, B->C, C->d you return A->d ?
09:59:39 <Frederick> neologism, yes
10:00:15 <neologism> so.. tyou want the algorithm for this?
10:00:18 <neologism> or just repair this one?
10:00:54 <Frederick> neologism, both
10:01:24 <neologism> I can give you the example I have in my scripts
10:01:39 <Frederick> neologism, I would be very gratefull
10:02:11 <neologism> ok.. found it
10:02:16 <neologism> now how to translate that for you :)
10:02:40 <Frederick> neologism, what do you mean when you say you have it on your scripts?
10:03:15 <neologism> scripts = text book
10:03:23 <Frederick> neologism, great
10:03:48 <Frederick> neologism, can you mail me this?
10:04:11 <neologism> yes
10:04:13 <neologism> I am just translating this
10:04:17 <Frederick> k
10:05:47 <neologism> hysteria.sk/~neologism/fred
10:05:52 <neologism> is this understandable?
10:06:11 <Frederick> lemmeread
10:06:24 * neologism leaving in 10 minutes
10:06:30 <neologism> si rush :)
10:06:32 <neologism> s/si/so
10:06:55 <neologism> =>* means 0..n deriving steps
10:07:33 <Frederick> neologism, I got the idea but it somehow doesnt matches with the implementation also I dont know here is my mistake
10:08:16 <neologism> thats the algorithm they teach us :)
10:09:39 <Frederick> neologism, you must agree with me this isnt trivial
10:09:45 <neologism> it is :)
10:10:01 <neologism> yes.. there are more trivial things but...
10:10:04 <neologism> its not that hard
10:10:37 <Frederick> =/
10:11:07 <neologism> ok.. I am about to leave
10:11:09 <neologism> good luck!
10:11:09 <SyntaxNinja> good morning
10:11:11 <Frederick> cya thx a lot
10:11:23 <neologism> no problem ;0
10:11:40 <maitrix_> anyone familiar with reading data from frame buffer?
10:11:41 <Frederick> SyntaxNinja, good morning
10:12:42 <shapr> maitrix_: Directly, or from the Linux kernel or so?
10:18:18 <maitrix_> shapr: with OpenGL function readPixels 
10:19:21 <maitrix_> the point is: I just need a screenshot, no matter how it's done
10:19:46 <maitrix_> if there is some other way to do this, it's also ok
10:20:22 <maitrix_> for example in HGL library something that does Graphic -> [RGB] or smth
10:22:42 <maitrix_> I wrote a module, but it doesn't work http://mait.ath.cx/~maitrix/Dump.hs
10:27:20 <shapr> What doesn't work about it?
10:28:22 <maitrix_> something is wrong in function dump. it just reads about 10-20 bytes of weird data and then only zeros
10:31:15 <shapr> Have you looked into the HGL library to see how it holds the image values?
10:31:25 <ricebowl> does GHC get angry if you specify a more general type than can be inferred? e.g. \f (x, y) -> (x, y) :: a -> a
10:31:52 <Igloo> Yes
10:31:53 <shapr> maitrix_: Are you using the HGL library from/for Hudak's "Haskell School of Expression" ?
10:32:05 <maitrix_> you mean SOE?
10:32:10 <shapr> Yup, SOE.
10:32:23 <maitrix_> I have the book, but I'm using HGL not SOE
10:32:39 <shapr> If so, maybe you could try dcoutts' gtk2hs reimplementation of SOEGraphics?
10:32:40 * dcoutts has a new implementation of the SOE api (based on Gtk2Hs and cairo)
10:32:46 <dcoutts> shapr, heh
10:32:57 <shapr> :-)
10:34:46 <dcoutts> @where soe
10:34:47 <lambdabot> I know nothing about soe.
10:34:53 * Frederick will give a candy to who discovers with him why the algorithm is working backwards
10:34:59 <ricebowl> lol
10:35:02 <ricebowl> what's your algorithm?
10:35:03 * ricebowl will look
10:35:11 * Frederick takes a candy bar
10:35:12 <dcoutts> @where+ soe http://haskell.org/soe/
10:35:13 <lambdabot> soe ~> http://haskell.org/soe/
10:35:37 <dcoutts> @where+ soegtk http://haskell.org/~duncan/soe/
10:35:37 <lambdabot> soegtk ~> http://haskell.org/~duncan/soe/
10:35:48 <Frederick> ricebowl, this is the right algorithm http://hysteria.sk/~neologism/fred
10:36:33 <ricebowl> which transformation is that?
10:36:47 <Frederick> ricebowl, this is supossed to remove useless productions
10:36:52 <ricebowl> ah, ok
10:37:40 <Frederick> ricebowl, but I got http://paste.lisp.org/display/13925
10:37:41 <ricebowl> am not following your steps, however
10:38:23 <Frederick> ricebowl, what do you mean?
10:38:55 <ricebowl> that is to say that I don't understand your paste on rafb
10:38:58 <ricebowl> er
10:39:05 <ricebowl> sorry, on hysteria.sk
10:39:10 * ricebowl is way out of it today
10:40:24 <ricebowl> "for every A of N compute set Na = {B | A =>* B}, let R'={}"
10:40:29 <Frederick> ricebowl, oki did you see my paste on paste.lisp?
10:40:31 <ricebowl> what does {B | A =>* B} represent?
10:40:33 <ricebowl> yes
10:40:41 <Frederick> ricebowl, it is a transitiver closure
10:40:45 <Frederick> lemme draw
10:40:49 <ricebowl> ok
10:41:26 <shapr> Nifty, Tom Duff posts about Duff's device on LtU: http://lambda-the-ultimate.org/node/view/1131#comment-12376
10:42:03 <ricebowl> does Duff's device work in Haskell?
10:43:00 <ricebowl> hm
10:43:34 <Frederick> ricebowl, http://paste.lisp.org/display/13927
10:48:15 <ricebowl> Frederick - I'll look when I get back in about 20 minutes or so; I need to have lunch
10:51:55 <Cale> ricebowl: Of course a direct translation (or even one which would be useful in the same way) isn't possible.
11:06:52 <kosmikus> SyntaxNinja: I've tried the Cabal program detection stuff ...
11:10:01 <Frederick> ricebowl, k
11:11:38 <ricebowl> mm
11:11:44 <ricebowl> I don't know why, but I love steamed broccoli
11:12:07 <Frederick> ricebowl, me tooo!
11:12:10 <ricebowl> :D
11:12:18 <Frederick> ricebowl, with rice and beans!]
11:12:41 * Frederick had steamed brocolli on the lunch
11:12:53 <ricebowl> :D :D me too
11:13:06 <ricebowl> rather, I am eating it *now* for lunch
11:13:30 <Frederick> ricebowl, Uve had lunch ~3 hours ago
11:13:38 <Frederick> @localtime ricebowl 
11:13:38 <palomer>  /whois Frederick 
11:13:39 <lambdabot> Local time for ricebowl is Wed Nov 23 14:15:19 2005
11:13:50 * ricebowl lives in the US
11:14:00 <palomer> @localtime palomer
11:14:01 <lambdabot> Local time for palomer is Wed Nov 23 14:16:53
11:14:01 <ricebowl> East-side represent!@#!...or something
11:14:05 <palomer> man, lambdabot rocks
11:14:09 * ricebowl <-- Floridian
11:14:18 <palomer> omg
11:14:20 * Frederick gaucho
11:14:21 <ricebowl> ?
11:14:25 <palomer> did lambdabot read my system time?
11:14:29 <ricebowl> indeed
11:14:32 <palomer> because he got it _exactly_ right
11:14:33 <ricebowl> TEH PSYCHIC
11:14:39 <ricebowl> /ctcp time
11:14:51 <palomer> xchat didn't signal a request
11:14:59 <ricebowl> oh, curious
11:15:09 <ricebowl> [14:15:19] [lambdabot TIME]
11:15:11 <palomer> oh wait, it did
11:15:18 <ricebowl> heh
11:15:26 <palomer> it would be better if lambdabot figured out where we lived and displayed  the time
11:15:33 <ricebowl> whereabouts on the Eastern seaboard?
11:15:40 <palomer> montreal
11:15:56 <palomer> man, there should be an application to automatically set up the system time correctly
11:16:00 <ricebowl> ah
11:16:08 <ricebowl> heh, isn't that called ntp? ;)
11:16:28 * Frederick uses ntp
11:17:31 <ricebowl> I have a Linux box running NTP, and all the other Windows/Linux boxen here SNTP to it
11:17:54 <ricebowl> it works well for the most part, except my desktop loses about 90 second off its clock per day
11:17:58 <Frederick> I got  single box
11:19:44 <CosmicRay> SyntaxNinja: HEY!
11:19:51 <CosmicRay> Just the man I want to see!
11:20:23 <CosmicRay> SyntaxNinja: do you have any idea on http://sourceforge.net/tracker/index.php?func=detail&aid=1364839&group_id=8032&atid=108032
11:20:28 <SyntaxNinja> hi CosmicRay
11:21:50 <CosmicRay> iow, am I doing something stupid?
11:22:29 <SyntaxNinja> CosmicRay: this is cabal 1.0?
11:22:43 <CosmicRay> SyntaxNinja: the cabal that comes with ghc 6.4.1... so, I think, yes.
11:23:24 <SyntaxNinja> I guess that if ghci is not supported on this platform, that probably has somethign to do w/ types of linking that ld on aix accepts?
11:23:35 <CosmicRay> it could be
11:23:43 <SyntaxNinja> you should build w/ -v4 and see what command gives the error
11:23:46 <CosmicRay> how do I make cabal not try to do any ghci stuff?
11:23:55 <CosmicRay> that's the output from install, but sure, one sec...
11:24:10 <SyntaxNinja> I'm sure cabal only sends --with-auto-ghci or whatever to ghc, so it's really a ghc bug, methinks.
11:24:21 <ricebowl> Frederick - I am looking at your paste again: http://paste.lisp.org/display/13925
11:24:22 <CosmicRay> indeed.
11:24:24 <CosmicRay> /usr/local/bin/ghc-pkg --auto-ghci-libs update .installed-pkg-config
11:24:24 <CosmicRay> Reading package info from ".installed-pkg-config" ... done.
11:24:24 <CosmicRay> building GHCi library /usr/local/lib/MissingH-0.12.0/HSMissingH-0.12.0.o...ld: 0706-027 The -x flag is ignored.
11:24:24 <CosmicRay> ld: 0706-012 The -- flag is not recognized.
11:24:24 <CosmicRay> ld: 0706-012 The -w flag is not recognized.
11:24:25 <CosmicRay> ld: 0706-012 The -h flag is not recognized.
11:24:26 <ricebowl> can you give the types?
11:24:38 <CosmicRay> I'll note this on the sf bug.
11:24:43 <SyntaxNinja> but newer versions of cabal don't do this; we build ghci stuff during build and we do it by hand.
11:24:45 <ricebowl> hat's the type of productions?
11:24:52 <ricebowl> s/hat/what/
11:25:02 <SyntaxNinja> and there are flags to turn off ghci stuff in cabal. maybe you could write a patch to make that the default on aix?
11:25:11 <CosmicRay> runtime flags?
11:25:15 <SyntaxNinja> configure flags
11:25:19 <CosmicRay> I looked quickly through --help and didn't see 'em
11:25:22 <SyntaxNinja> but that's only in newish cabal, not 1.0
11:25:34 <kosmikus> CosmicRay: I mentioned this a few hours ago
11:25:48 <kosmikus> 18:19 < kosmikus> CosmicRay: I'm not sure what the default is at the moment, but with the current Cabal from darcs you at least have options --enable-library-for-ghci and --disable-library-for-ghci ...
11:25:50 <Frederick> ricebowl, 1 sec
11:26:03 <CosmicRay> nice.
11:26:43 <kosmikus> SyntaxNinja: so why are there three hooks per phase, rather than just one?
11:26:49 <Frederick> ricebowl, http://paste.lisp.org/display/13923 productions is a list of terminals and nonterminals
11:27:25 <SyntaxNinja> erum. does anyone have any clue about the conversation at the bottom here: http://www.abridgegame.org/pipermail/darcs-users/2005-November/008913.html
11:27:42 <SyntaxNinja> kosmikus: before, during, and after :)
11:27:51 <SyntaxNinja> kosmikus: the "during" hook is new.
11:28:02 <kosmikus> during seems to be the only one you need
11:28:14 <SyntaxNinja> kosmikus: basically, you usually want to keep the default "during" behavior and add "before" and "after" hooks, as in Debian.
11:28:16 <Igloo> Does during mean replace-with?
11:28:22 <SyntaxNinja> Igloo: yeah
11:28:27 <Igloo> OK  :-)
11:28:34 <kosmikus> yes, but as long as you can access the default behaviour, you can add to it
11:28:39 * Igloo had visions of it forking off a second process to run in parallel or something  :-)
11:28:42 <kosmikus> seems much less complex to have only one hook
11:29:13 <SyntaxNinja> kosmikus: access the default behavior?
11:29:15 <Igloo> kosmikus: I think it'd be simpler for users to not have to call the standard function if they just want to add something before/after
11:29:35 <Igloo> And it also means you are less likely to /only/ do your extra bit by mistake
11:29:47 <karma__> Hello! Does transformation: A -> A[x], where A -- is algebraic domain and A[x] -- polynoms over A, is functor?
11:29:52 * Igloo disappears
11:29:52 <kosmikus> Igloo: I think we can assume that Haskell implementors who are using something beyond the plain Distribution.Simple are capable of handling a simple update
11:30:17 <SyntaxNinja> kosmikus: that's a good idea. I'll think about it.  the hooks aren't set in stone.
11:30:32 <SyntaxNinja> kosmikus: mind filing a bug report? :)
11:30:38 <kosmikus> SyntaxNinja: you can get hold of the defaultUserHook entry for each phase, that's what I mean
11:30:47 <SyntaxNinja> kosmikus: http://hackage.haskell.org/cgi-bin/trac/trac.cgi
11:30:50 <kosmikus> so you can update it, but still reuse it
11:31:05 <kosmikus> ok
11:31:09 <SyntaxNinja> right, so you could have "beforeBehavior >> defaultHook >> afterBehavior"
11:31:30 <kosmikus> one more thing, though: the reason for this suggestion is that the after-hook doesn't get the interesting parameters passed
11:31:49 <SyntaxNinja> kosmikus: sucks. which ones?
11:32:05 <Frederick> ricebowl, are you still on brocolli?
11:32:18 <kosmikus> SyntaxNinja: look at instHook and postInst
11:32:39 <kosmikus> SyntaxNinja: no, copyHook and postCopy
11:32:49 <SyntaxNinja> can't right now; file a bug, I'll look at it ASAP
11:33:00 <kosmikus> SyntaxNinja: copyHook gets CopyFlags, but postCopy doesn't
11:33:19 <kosmikus> I can't copy my own additional files in postCopy if I don't know where they should go to
11:33:33 <kosmikus> yes, sure, will file a bug
11:45:06 <kosmikus> SyntaxNinja: Actually, seems like I was wrong; the argument is there. must have overlooked it yesterday. But I still think it can be simplified.
11:52:21 <shapr> hoi franka!
11:52:29 <franka> Hello.
11:53:17 <shapr> karma__: See http://en.wikipedia.org/wiki/Functor 
11:53:31 <shapr> franka: Wazzup? How's code?
11:54:03 <franka> Not good.  I was trying to use Eclipse a few days ago to make a plug-in.
11:54:17 <shapr> It burnt down your house?
11:54:21 <franka> It's buggy.  Eclipse, I mean.
11:54:44 * Frederick is confuse
11:55:09 <shapr> franka: oh hey, maybe you can suggest a CS slanted introduction to Michael Dummet's work?
11:55:11 <franka> It creates an invalid workspace, and then it won't reload it if you quit.
11:55:11 <xerox> Did you see this one, the Amazon Turk?  http://www.mturk.com/mturk/help?helpPage=whatis
11:55:22 * sieni is almost surprised
11:55:38 <franka> I've never read Dummett.  Only know the name.
11:55:45 <Frederick> why sieni ?
11:55:55 <shapr> Yeah, but you still might know a CS slanted intro to his work...
11:56:19 <sieni> Frederick: I just read that Eclipse is buggy
11:56:25 <franka> Only the usual proof theory.
11:56:49 <franka> I'm not really sure what he is directly responsible for.
11:57:48 <shapr> He's responsible for a Curry-Howard style isomorphism that matches classical logic to lambda calculus.
11:59:05 <shapr> http://lambda-the-ultimate.org/node/view/1078
12:00:05 <franka> Yes, I perused that at one point.
12:00:41 <shapr> I'm just trying to understand it all...
12:00:45 <franka> I know about CH, of course, but I don't know Dummet's contribution.
12:02:29 <palomer> shapr: do you have  a direct link to the paper?
12:02:35 <franka> I think a good introduction to CH is Gallier's two papers.
12:02:45 <xeiro> for a data type size in wxhaskell ... would size.sizeH give me horizontal component of the size data type
12:03:29 <franka> ftp://ftp.cis.upenn.edu/pub/papers/gallier/conslog1.ps
12:03:33 <tic> I think you could apply sizeH to an object(?) though.
12:03:38 <tic> if it's a selector, that is.
12:03:39 <franka> ftp://ftp.cis.upenn.edu/pub/papers/gallier/conslog2.ps
12:03:43 <tic> otherwise, you'll have to pattern match on it.
12:03:57 <palomer> btw, there are a few proofs as types interpretations of classical logic floating around
12:04:02 <palomer> none of them are interesting though:(
12:04:39 <xeiro> tic: thanks .. will try that
12:10:54 <Frederick> folks I need help with 6 lines of code please a usage of map here http://paste.lisp.org/display/13925 Im doing the oposite I want
12:12:00 <shapr> palomer: check out the links in that LtU post.
12:12:05 <xeiro> tic: thanks .... it worked
12:12:17 <shapr> hoi swiert .... do you know where the UUAG Cabal package is?
12:12:36 <swiert> no. not yet
12:12:36 <shapr> swiert: Want to write about Epigram for TMR? :-)
12:13:02 <Frederick> hey folks I will give 2 candy bars if you help me out fixorating it :p
12:13:19 <shapr> #haskell: Any suggestions for advertising The Monad.Reader ? Maybe I should buy a Google text ad?
12:13:27 <kosmikus> swiert: hi
12:13:35 <kosmikus> shapr: so you haven't got a reply from Doaitse?
12:14:09 <shapr> No, but that might be because I was reconfiguring postfix at the time... 
12:14:10 * shapr checks
12:14:15 <kosmikus> shapr: when's the next issue of TMR planned?
12:14:38 <swiert> hi kosmikus
12:15:13 <kosmikus> swiert: seems like you're well-integrated already ;)
12:15:21 <shapr> kosmikus: December 1st if I get enough articles.
12:15:36 <kosmikus> oh no, no chance I could write anything until then
12:15:38 <shapr> I'm hoping Koen Claessen will let me write about QuickCheck2 :-)
12:15:49 <shapr> Write for the Xmas edition!
12:16:03 <kosmikus> "let you write"? do you need permission to advertise a library??
12:16:07 <shapr> I'm going to ask Fritz Ruehr to make a Christmasy Lambda
12:16:14 <shapr> Sort of, yeah...
12:16:27 <shapr> Since there's no official release yet.
12:16:39 <kosmikus> ok.
12:16:39 <swiert> kosmikus: based on the fact that I get to write the epigram hcar entry when Conor's too busy?
12:16:44 * shapr has 0-d4y w4r3z
12:17:00 <kosmikus> swiert: sort of. although it's a typical task for newbies, right? ;)
12:17:35 <swiert> exactly.
12:17:48 <swiert> how's Bonn?
12:17:52 <franka> Hi, Wouter.
12:18:22 <kosmikus> shapr: maybe. I'm currently planning to make a new lhs2TeX release within the next few weeks. I'm not sure if I could make a short TMR article out of it, too.
12:18:46 <swiert> hi franka.
12:19:01 <kosmikus> swiert: nice. Ralf is continuously pushing me to write papers ;)
12:20:52 <shapr> kosmikus: I'd like to switch TMR to lhs2TeX at least as an option, if not a default. Any thoughts on that?
12:21:25 <kosmikus> I think we discussed this a while ago. I still don't really know what "switching to lhs2TeX" implies.
12:21:43 <swiert> kosmikus: that's good. Any world shaking papers in the pipelines?
12:22:03 <astrolabe> shapr:  I guess only haskellers will be interested in TMR, and that most of them know about it.
12:22:43 <shapr> kosmikus: I'd like to use lhs2TeX as the primary syntax, instead of wiki syntax. What's the best way to display lhs2TeX on the web?
12:22:50 <kosmikus> swiert: we've finally "come to peace" with SYB. but you've probably seen that?
12:23:06 <kosmikus> swiert: nothing world-shaking, though.
12:23:43 <kosmikus> shapr: don't know. don't some of the Nottingham blogs have lhs2TeX support? swiert?
12:23:53 <swiert> yeah I saw the paper lying on colleague's desk.
12:23:53 <franka> kosmikus: SYB?
12:23:58 <franka> Shake Your Booty?
12:23:58 <liyang> swiert: !
12:24:16 <kosmikus> franka: scrap your boilerplate
12:24:20 <franka> Damn.  Close.
12:24:30 <kosmikus> :)
12:24:48 <shapr> I want to read "Boil Your Scratchpads, Genetic Frogging in Haskell"
12:24:49 <swiert> Yes - it's a combination of Wordpress blog software, a LaTeX plugin and a bit of a hack to add lhs2TeX.
12:25:01 <franka> Scratch Your Boils.
12:25:06 <swiert> hi liyang.
12:25:15 <franka> Oh, I could have made that funnier...
12:25:31 <franka> Damn.  Close.
12:25:32 * shapr is afraid
12:25:42 <liyang> swiert: visiting day after tomorrow. Don't know if GMH mentioned. :)
12:26:43 <swiert> Ah - be good to see you.
12:27:01 <swiert> There's been a bit of a row over your desk.
12:27:20 <shapr> swiert: How did you hack in lhs2TeX?
12:27:22 <liyang> . . .
12:27:35 <liyang> swiert: anything I'm not supposed to know about?
12:28:23 <franka> GMH?
12:28:28 <franka> Give Me Head?
12:28:36 <palomer> shapr: do you mean the links in the comments?
12:28:37 <shapr> Graham Hutton?
12:28:43 <liyang> franka: Graham Hutton. 
12:28:44 <shapr> palomer: yup
12:28:58 <swiert> shapr: the wordpress plugin feeds anything between <tex> and </teX> to latex and generates images. To use lhs2TeX you need insert an extra step.
12:29:04 <franka> I was close, though.
12:29:19 <swiert> not much work, though.
12:29:58 <palomer> shapr: there are tons of posts (and none seem to mention classical logic)
12:30:14 <shapr> palomer: Look for "Dummet"
12:30:31 <franka> Classical logic is passe.  These days it's all about ball bearings.
12:30:33 <swiert> liyang: yeah, apparently the webtech group gave your desk (in "our" office) to a random phd student. Graham sorted it out - he should be gone before january.
12:30:53 <swiert> liyang: you'll actually be sitting next to me, btw.
12:31:04 * palomer wonders what existential types represent
12:31:07 <liyang> swiert: hah! :)
12:31:10 <palomer> in the "real world"
12:31:32 <franka> palomer: I think Sartre would say your create your own type, existentially speaking.
12:31:59 <palomer> :o
12:32:04 <franka> I'm on a roll tonight, guys.
12:32:14 <liyang> swiert: Woo! We can IRC each other from the same room. Excellent.
12:32:19 * shapr grins
12:32:43 <shapr> That happened a lot at ICFP2003
12:33:03 <franka> shapr: I wasn't even there!
12:33:09 <franka> No, that was a joke.
12:33:12 <franka> Or was it?
12:33:17 <liyang> That happened all the time with my last flatmate. <g>
12:33:24 <shapr> franka: Were you at ICFP2003?
12:33:26 <shapr> I didn't see you there.
12:34:00 <franka> No, I was not in attendance.
12:34:32 <shapr> Will you be at ICFP2006 in Portland?
12:34:45 <franka> Nah.
12:35:02 <shapr> I'm tenatively planning to attend ICFP2006.
12:35:25 <shapr> Maybe we should start the IcfpMeeting wikipage now.
12:36:04 <kosmikus> shapr: nice. be sure to go to the Haskell Workshop, too ;)
12:36:29 <shapr> You think anyone I know will be there? :-)
12:37:32 <shapr> Are you one of the organizers?
12:38:28 <kosmikus> shapr: http://haskell.org/haskell-workshop/2006/
12:39:07 <shapr> Ah, I see. You are *the* organizer.
12:39:17 <franka> Hey, Andres is moving up in the world...!
12:43:33 <araujo> Whenever you do one in south-america , let me know :-P
12:44:06 <reddi> if i have the data structure [(Int,[Int])] -> how do i get best the Int ? a recursive function call with the head ?
12:44:14 <reddi> or does a better approach exist?
12:44:24 <xerox> So it will be in the US?
12:44:52 <araujo> reddi, pattern matching?
12:45:53 <xerox> > (\((x,_):_) -> x) [(0,[1,2,3])]
12:45:54 <lambdabot> 0
12:46:17 <reddi> THIS looks fine ;-)
12:47:28 <reddi> hm but i have to call that recursive to get all the first elements
12:47:46 <xerox> map it
12:48:25 <xerox> > map fst [(0,[0..]),(1,[1..]),(2,[2..])]
12:48:28 <lambdabot> [0,1,2]
12:48:56 <xerox> @type fst
12:48:58 <lambdabot> forall a b. (a, b) -> a
12:49:15 <xerox> @type snd
12:49:16 <lambdabot> forall b a. (a, b) -> b
12:49:54 <xeiro> anyone know where I can find some info on fonts and wxhaskell apart from http://wxhaskell.sourceforg.net/doc
12:52:10 <ricebowl> anyone want to look at a brain twister? Heh... :p
12:54:09 <lisppaste2> salsa de soja pasted "Guess the type!" at http://paste.lisp.org/display/13937
12:57:05 <Frederick> ricebowl, will you get your candybar?
12:57:18 <Frederick> :p
12:59:33 <kosmikus> ricebowl: I can see that there's a type error
13:00:52 <Frederick> folks Im trying to fix a map usage over a list that does the transitive closure of the productions of a grammar, it works oki for cases like S->B B->s but it flaws in cases like http://paste.lisp.org/display/13925 can anyone give me some hints?
13:02:05 <kosmikus> ricebowl: does it typecheck without the typesig?
13:02:17 <kosmikus> ricebowl: looks like only the 'd' is a problem.
13:04:08 * Frederick screams
13:04:15 <reddi> isWellformed [(1,[1,2,4,2]),(3,[2]),(4,[4]) == False
13:04:21 <reddi> can i test this out if ] is missing?
13:04:22 <SyntaxNinja> Heffalump: do you know anything about this? http://www.abridgegame.org/pipermail/darcs-users/2005-November/008913.html
13:04:27 <reddi> or is this an error?
13:04:32 <SyntaxNinja> hi sh10151. is that columbus, oh?
13:04:45 <reddi> in the testexample
13:05:05 <sh10151> SyntaxNinja: hah, yeah, we've met :)
13:05:21 <xerox> reddi: it is a syntax error
13:05:24 <shapr> Frederick: Can you break it down to a smaller example?
13:05:25 <sh10151> SyntaxNinja: Aetion interview at some point
13:05:34 <reddi> xerox: i thougt it, ok then this is not wanted ;-)
13:05:39 <reddi> i thought so gg
13:05:43 <sh10151> SyntaxNinja: It didn't seem like they had their funding in order at that time.
13:05:57 <Frederick> shapr, sure how like? I meant small example of what I need and what Ive gotten?
13:06:36 <shapr> Frederick: Can you show the smallest input that gives an incorrect output?
13:06:49 <Frederick> shapr, sure
13:07:13 <SyntaxNinja> sh10151: I can never remember your nick.
13:07:21 <sh10151> i changed it :)
13:07:23 <SyntaxNinja> sh10151: I always think it's like some random nick generated by an irc client.
13:07:26 <SyntaxNinja> ah ok.
13:07:29 <sh10151> quite some time ago though
13:07:40 <sh10151> used to be stevenh or something like that
13:07:56 <SyntaxNinja> sh10151: got it.
13:07:59 <sh10151> sh10151 is the number of our orbital gun
13:08:02 <SyntaxNinja> of course, I remember you well.
13:08:19 <sh10151> Whereas prophet 6 0091 is the number of our galactic sun
13:08:32 <sh10151> (silly song lyrics, Hooverphonic's "2Wicky")
13:10:11 <swiert> shapr: have you started studying btw?
13:10:53 <shapr> Still not, sadly.
13:11:32 <swiert> hmm, bad luck.
13:11:43 <boegel|home> shapr: how come ?
13:12:53 <shapr> Mostly disorganization on my part.
13:12:59 <boegel|home> shapr: tssk
13:13:16 <shapr> If I spent less time reading research papers, and less time on #haskell... 
13:14:05 <boegel|home> shapr: if you _really_ want it, that shouldn't be a problem
13:16:07 <shapr> true
13:17:31 <lisppaste2> Frederick pasted "Doesnt works for the root" at http://paste.lisp.org/display/13940
13:17:41 <Frederick> shapr, there is a sample
13:23:48 <Frederick> shapr, did you see what I mean?
13:26:43 <boegel|home> Itkovian: y0
13:26:54 <Itkovian> evening
13:27:03 <Itkovian> did you finish the vote plugin?
13:27:55 <boegel|home> Itkovian: err, yeah, but the pretty printing isn't working yet though
13:28:19 <astrolabe> that was quick
13:28:23 <boegel|home> I send the patch to dons, he said he'll look into it and do what's needed for saving state and such
13:29:13 <shapr> @listcommands vote
13:29:13 <lambdabot> No module "vote" loaded
13:29:19 <shapr> @dynamic-load vote
13:29:20 <lambdabot> module loaded
13:29:23 <shapr> ?
13:29:25 <shapr> @listcommands vote
13:29:26 <lambdabot> No module "vote" loaded
13:29:29 * shapr shrugs
13:30:49 <o_Rocky> heheehe
13:30:52 <o_Rocky> :P
13:30:52 <boegel|home> shapr: I guess dons didn't rebuild lamdabot yet
13:31:47 * boegel|home summons boegelBot
13:34:14 <shapr> Frederick: I haven't looked at your code before, so I don't really see the problem. Is the A missing?
13:38:58 <boegel|home> boegelBot: @yow !
13:38:58 <boegelBot> Couldn't find fortune file
13:39:08 <boegel|home> boegelBot: @vixen you should look better
13:39:09 <boegelBot> yes
13:39:19 <boegel|home> boegelBot: @vixen remember that for next time, mmkay ?
13:39:19 <boegelBot> nevermind about that
13:39:25 <shapr> boegelBot: @listcommands vote
13:39:25 <boegelBot> No module "vote" loaded
13:39:26 <boegel|home> boegelBot: @help vote
13:39:26 <boegelBot>  @help <command> - ask for help for <command>
13:39:36 <boegel|home> boegelBot: @dynamic-load vote
13:39:36 <boegelBot> Not enough privileges
13:39:38 <Frederick> shapr, for some simplifications it doesnt replaces well in fact if I have more than 2 viariables it seems to fail
13:39:40 <boegel|home> urgh :)
13:39:47 <boegel|home> shapr: you do a dynamic-load pls :)
13:39:52 <boegel|home> forgot the change that part
13:39:52 <shapr> Frederick: Have you manually traced though the code to see why?
13:39:57 <shapr> boegelBot: @dynamic-load vote
13:39:57 <boegelBot> module loaded
13:40:06 <boegel|home> boegelBot: @browse-polls
13:40:06 <boegelBot> []
13:40:23 <boegel|home> boegelBot: @add-poll #haskell stupid
13:40:24 <boegelBot> added new poll: #haskell.
13:40:30 <boegel|home> boegelBot: @add-choice #haskell cool
13:40:30 <boegelBot> new choice (cool) added to poll '#haskell'.
13:40:32 <Frederick> shapr, yes, but no luck
13:40:34 <boegel|home> boegelBot: @add-choice #haskell the_best
13:40:34 <boegelBot> new choice (the_best) added to poll '#haskell'.
13:40:38 <boegel|home> boegelBot: @add-choice #haskell w00!
13:40:38 <boegelBot> new choice (w00!) added to poll '#haskell'.
13:40:40 <Frederick> Im trying to find a pattern of failure
13:40:45 <boegel|home> boegelBot: @browse-polls
13:40:45 <boegelBot> ["#haskell"]
13:40:52 <boegel|home> boegelBot: @show-poll #haskell
13:40:52 <boegelBot> ["w00!","the_best","cool","stupid"]
13:41:00 <boegel|home> boegelBot: @vote #haskell w00!
13:41:00 <boegelBot> voted on w00!
13:41:07 <boegel|home> boegelBot: @show-result #haskell
13:41:07 <boegelBot> True[("w00!",1),("the_best",0),("cool",0),("stupid",0)]
13:41:11 <shapr> Frederick: One way I approach a problem is to find two inputs with only one difference where one fails, and one succeeds. Then I can usually trace through the code to see the problem.
13:41:26 <shapr> @vote #haskell cool
13:41:26 <boegelBot> voted on cool
13:41:26 <lambdabot> Maybe you meant: code more quote
13:42:12 <shapr> Frederick: Where should your code handle two variables?
13:42:16 <reddi> is there a function which says: [1,2,3] is a sublist of [1,2,3,4]
13:42:28 <fworp> lambdabot is jealous
13:42:28 <reddi> or do i have to map every element
13:43:07 <Frederick> shapr, what do you mean?
13:43:22 <boegel|home> @index sub
13:43:23 <boegelBot> Text.Html
13:43:23 <lambdabot> Text.Html
13:43:24 <boegel|home> @index part
13:43:25 <boegelBot> bzzt
13:43:25 <lambdabot> bzzt
13:44:00 <shapr> Frederick: I mean, what part of your code handles one variable, and what would handle two variables differently?
13:44:33 <Lemmih> > let sublist a b = all (flip elem b) a in sublist [1,2,3] [1,2,3,4]
13:44:34 <boegelBot> True
13:44:44 <boegel|home> > eval (\x y-> (intersect x y) ==x) [1,2,3] [1,2,3,4]
13:44:44 <boegelBot>  Not in scope: `eval'
13:44:50 <boegel|home> > (\x y-> (intersect x y) ==x) [1,2,3] [1,2,3,4]
13:44:52 <boegelBot> True
13:44:54 <boegel|home> > (\x y-> (intersect x y) ==x) [1,2,5] [1,2,3,4]
13:44:54 <boegelBot> False
13:44:55 <Frederick> shapr, replacers = Map.map (head . head) (Map.filter isReplacer prodssimp)    isReplacer [[x]] = True    isReplacer _     = False
13:45:01 <boegel|home> reddi:  ^
13:45:13 <lambdabot> True
13:45:15 <lambdabot>  Not in scope: `eval'
13:45:17 <lambdabot> True
13:45:19 <lambdabot> False
13:45:31 <boegel|home> heh, lambdabot is way slow today :) go boegelBot !
13:45:51 <shapr> Wow, it went.
13:45:56 <reddi> thx
13:46:24 <boegel|home> shapr: heh, oyu bastard :P
13:47:08 <fworp> @where foo
13:47:08 <lambdabot>  @yow
13:47:14 <fworp> doh!
13:47:41 * shapr grins evilly
13:49:08 <Frederick> shapr, it works for some samples for others not
13:49:34 <boegel|home> reddi: you can use isPrefixOf, but that's not a sublist function
13:49:44 <boegel|home> > isPrefixOf [1,2,3] [1,2,3,4]
13:49:45 <lambdabot> True
13:50:49 <boegel|home> @hoogle [a] -> [a] -> Bool
13:50:51 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
13:50:51 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
13:50:51 <lambdabot> Graphics.UI.ObjectIO.CommonDef.disjointLists :: Eq x => [x] -> [x] ->
13:50:51 <lambdabot> Bool
13:50:52 <boegelBot> An error occured.
13:51:37 <boegelBot> shapr: stop harassing me !
13:52:37 <reddi> boegel|home i cannot use it cause i have to use the sublist function, the [2,3] is also a sublist of [1,2,3] but not with ifPrefixOf
13:53:30 <boegel|home> reddi: I know, I was just making another suggestion :)
13:55:58 <Frederick> bah Im confuzzled
13:56:53 <shapr> Frederick: Can you figure out what's special about the samples that fail?
13:57:26 <Frederick> shapr, nope this is freaking me out
13:58:10 <shapr> Well, trace through the code step by step... if you know the correct output, you can trace backwards from the result and test the code piece by piece interactively.
13:59:24 <shapr> Can you find some two variable samples that succeed?
13:59:35 <shapr> Can you find some one variable samples that fail?
14:00:14 <MarcWeber> Can some one explain these two lines?
14:00:23 <MarcWeber> tail :: forall a. [a] -> [a]
14:00:31 <MarcWeber> tail (x:xs) = xs :: [a]
14:01:32 <MarcWeber> Get it. Thanks
14:02:22 <MarcWeber> But it dosn't make any sense here, does it?
14:02:32 <shapr> What doesn't make sense?
14:02:32 <Frederick> shapr, oki Ive found the bug I think it seems it is unable to replace when the root appears alone
14:02:44 <shapr> Frederick: So, can you fix it?
14:03:34 <Frederick> shapr, nope
14:04:45 <Frederick> shapr, SamB helped mu a LOT on this last part Ive almost freak trying to do it I have troubles when I need to manipulate the list with insertion and removal at the same time
14:04:48 <boegel|home> shapr: I also don't get why the ':: [a]' is needed... (x:xs) is of type [a], so is xs, so why the 'cast' (or whatever it's called)
14:05:22 <eivuokko> Type annotation.
14:05:22 <reddi> by for today, i have a full brain gg
14:05:24 <MarcWeber> boegel|home: That's my question.. But it's only an example from the Haskell Communities and Activities Report
14:05:26 <reddi> bye
14:05:27 <shapr> boegel|home: It's not needed, but you can do it. Haskell allows lots of extra explicit typing if you wish.
14:05:33 <reddi> thx 4 help
14:06:02 <shapr> er, explicit type signatures.
14:06:20 <shapr> Mostly they're just handy, but occasionally they're necessary.
14:06:28 <boegel|home> shapr: yeah, I know, but in this case, it's just bull, right ?
14:06:41 <Frederick> shapr, the case it fails is when the root must be replaced =/
14:07:10 <MarcWeber> boegel|home, shapr: Would there be any difference when omitting the forall in this particular case?
14:07:32 <eivuokko> Ah, yes, they are type signatures always.  Dunno why I always remember type annotation. :-(
14:07:34 <shapr> I don't think so.
14:07:47 <boegel|home> MarcWeber: I'm not following this, I'm sorry... and I'm off to bed now
14:08:39 <Frederick> shapr, I think it is 1 line of code to fix =/
14:13:09 <shapr> Frederick: So try to figure out how that line of code needs to be changed. You're learning fast, you can do it!
14:13:39 <astrolabe> ghci doesn't seem to recognise anything from the files that I've loaded
14:14:51 <astrolabe> :show modules claims it has Main and AstroPrelude
14:15:54 <shapr> astrolabe: Maybe the names you're calling aren't exported?
14:15:58 <astrolabe> but if I type 'cubeSz' which is an int I define in Main.hs, I get 'Not in scope: 'cubeSz' '.
14:16:23 <shapr> What if you only have Main loaded? Can you access them then?
14:18:31 <astrolabe> Main imports AstroPrelude
14:19:30 <astrolabe> names I've exported from AstroPrelude aren't 'in scope' either
14:22:21 <shapr> Have you tried exporting names from Main?
14:22:29 <shapr> I get this same problem sometimes, I forget how to fix it...
14:25:43 <astrolabe> shapr: Should I be worried if when I load the modules it says 'Skipping AstroPrelude'  ... 'Skipping Main' ?
14:25:57 <shapr> Nah, that just means they're already compiled to .o files.
14:26:31 <shapr> dons: Mind if I submit Frag to happypenguin.org?
14:27:25 <astrolabe> shapr: you could be on to something, if I just load AstroPrelude, which does export its functions, then I can see them
14:27:46 <astrolabe> But I don't really want to export stuff from Main.
14:28:03 <astrolabe> I'm debugging, and I want to see everything.
14:28:28 <shapr> iirc, if I only have one module listed in the prompt, like *Main> then I can see everything inside it.
14:28:34 <shapr> Otherwise, I only see exported names.
14:29:21 <astrolabe> My prompt is 'Prelude Main >'
14:29:41 <astrolabe> No '*'
14:30:01 * Frederick is freaking out
14:30:32 <astrolabe> The syntax *module indicates that it is the full top-level scope of module that is contributing to the scope for expressions typed at the prompt. Without the *, just the exports of the module are visible.
14:31:04 <astrolabe> So I just need to get a '*'
14:32:12 <dons> shapr, I don't see why not. Maybe CC mhch295 <AT> cse.unsw.edu.au
14:32:17 <dons> (Mun)
14:32:31 <Frederick> folks is anyone here familiar with Context Free Grammars Im freaking out here with a random error on an algorithm
14:32:58 <sh10151> no need to freak out
14:33:23 <Frederick> sh10151, Im confused very confused
14:33:46 <Frederick> sh10151, I couldnt identify if it is a algorithm, implementation or grammar error
14:35:32 <sh10151> i am impressed that it doesn't show up as a type error
14:35:42 <sh10151> by random do you mean periodic?
14:36:11 <Frederick> sh10151, non periodic, it happens sometimes others not I couldnt find a pattern
14:37:01 <Frederick> sh10151, in fact I need some context fre grammars simplification samples
14:37:07 <Frederick> but they dont seem to exist
14:37:20 <SyntaxNinja> don't panic!
14:37:25 <SyntaxNinja> who uses unsafePerformIO and why?
14:38:11 <dons> SyntaxNinja, is that an open question to all?
14:38:36 <dons> in which case, I sometimes use it in libraries in ffi bindings to pure foreign functions
14:38:48 <dons> and, in particular, the fast packed string library uses it
14:39:06 <sethk> I can't do if/then  without else?
14:39:15 <astrolabe> sethk: no
14:39:17 <dons> sethk, but you can do 'when'
14:39:23 <dons> @type Monad.when
14:39:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:39:47 <sethk> dons, ok, I'll try that, thanks.  That's hard to remember.  :)
14:40:08 <dons> not for pure code though
14:40:17 <sethk> dons, what do you mean?
14:40:25 <astrolabe> if then else is a bit different from in other languages, It is a bit like '? :' from C
14:40:29 <dons> when needs to be used in a monad
14:40:59 <soysauce> ?: owns
14:41:09 <sethk> dons, I'm getting "not in scope"  I have to import something?
14:41:17 <dons> import Control.Monad (when)
14:41:29 <sethk> dons, thanks.
14:41:30 <astrolabe> soysauce: sorry I don't understand what you said.
14:41:41 <soysauce> sorry, Internet slang
14:41:45 <Frederick> how do I know if my program is in a loop?
14:41:50 * soysauce likes the ?: operator very much
14:41:54 <astrolabe> Ah, ok I do understand.  I like it too :)
14:42:06 <soysauce> Frederick - it fails to terminate ;)
14:42:21 <Frederick> soysauce, Im very upset with that :(
14:42:27 <astrolabe> Isn't that the halting problem?
14:42:34 <soysauce> astrolabe - I was about to mention that
14:42:39 <sethk> hmm, obviously I'm using it wrong, it doesn't like   when (not b)    (b is a boolean)
14:42:40 <soysauce> there is no way to know, essentially
14:42:49 <soysauce> you can prove it in some cases, but there is no way to prove it generally
14:42:50 <liyang> soysauce: let (a ? b) c = if a then b else c , and use ? $ instead of ? :
14:43:00 <dons> when (not b) $ do something
14:43:12 <soysauce> liyang - :? is not Haskell; it is C.
14:43:22 <liyang> soysauce: ORLY?
14:44:07 <astrolabe> more internet slang?
14:44:22 <soysauce> nothing that I'm familiar with, heh
14:44:26 <liyang> http://images.google.co.uk/images?q=orly%20owl
14:44:47 <astrolabe> Sadly, I'm logging in from an analytical engine, and can't follow any of it.
14:45:07 * soysauce likes pro-drop language
14:45:11 <sethk> ok, I need a different syntax.  Here is what I have. 
14:45:14 <sethk> in putStrLn (if b then "OK" else "FAILURE") >> return b
14:45:21 <soysauce> I think you could call Haskell a pro-drop language
14:45:25 <liyang> soysauce: I meant, if you like the C trinary operator, you can define the (?) operator as above and get pretty much the same thing in Haskell.
14:45:41 <sethk> I moved the 'not' outside, obviously
14:45:41 <soysauce> liyang - ah, I see
14:45:54 <sethk> what I'm doing is to print nothing at all in the normal ("OK") case
14:45:54 <soysauce> liyang - if then else works fine
14:46:06 <soysauce> I just meant that I like using the ternary operator when using C
14:46:09 <liyang> (trinary? what's that... <_<)
14:46:11 <sethk> and avoid repeating the if b
14:46:16 <sethk> for the return
14:46:39 <dons> sethk, but the arg to putStrLn is pure, so you can't use when inside the putStr. Is that what you're trying to do?
14:46:48 <dons> you'd hvae to write: when (not b) $ putStr ...
14:47:02 <sethk> dons, yes, although more broadly what I'm trying to do is avoid having to do  If b   more than once
14:47:17 <sethk> dons, originally I have an if b for the putStrLn and another for the return
14:47:27 <sethk> dons, well, no
14:47:31 <sethk> dons, originally I didn't have b at all
14:47:44 <sethk> dons, and I had an if for the putStrLn and an if for return False or True
14:48:08 <SyntaxNinja> dons: yeah, it's open to all :)
14:48:30 <dons> other than in ffi, I don't use it then, SyntaxNinja
14:48:32 <sethk> dons, and someone here suggested this clever syntax
14:48:36 <SyntaxNinja> dons: :OK
14:48:39 <dons> it was invented for the ffi anyway
14:48:57 <sethk> which I like, but now I don't need if/then/else, just if
14:49:03 <sethk> let's see if I can make when do what I want
14:49:12 <dons> sethk, there's also 'unless'
14:49:14 * soysauce stops slacking and writes some Haskell code
14:49:17 <dons> @type Monad.unless
14:49:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:49:24 <sethk> dons, unless isn't monadic?
14:49:28 <sethk> dons, uh, never mind  :)
14:49:30 <dons> sure it is
14:49:36 <sethk> dons, yes, I see that.  :)
14:49:42 <dons> it doesn't make sense to have a pure when
14:49:57 <sethk> dons, yes, that's true.  and I'm in monadic code anyway 
14:50:28 <sethk> dons, ok, here is my naiive implementation of what I want to do:
14:50:48 <sethk> let me test it in ghci before I make myself look _too_ foolish
14:51:27 <ricebowl> heh what's wrong with this:
14:51:28 <ricebowl> newtype Parse a = (String, a)
14:51:34 <ricebowl> it says syntax error on (
14:51:55 <dons> no constructor
14:52:10 <ricebowl> oh, heh, I thought newtype didn't need one...
14:52:13 <ricebowl> I'll just use type then
14:52:23 <sethk> hmm, I came up with a trivial fix for my program, but I still want to know how to do the when, so let me construct a test
14:52:23 <dons> well, do you want a synonym, or a new type?
14:52:37 <ricebowl> new type is preferable, but it doesn't matter either way
14:52:46 <dons> more types, more types!
14:52:49 <ricebowl> the whole purpose of introducing it is to simplify these gargantuan types
14:52:56 <astrolabe> I typed ':module + *Main' into ghci, and it replied ''module 'Main' is not interpreted'.  Does anyone know how to fix it?
14:52:57 <ricebowl> parserep :: Int -> (((String, ([b], b)) -> d) -> (String, [b]) -> d) -> ((String, (a, [b])) -> c) -> (String, a) -> c
14:53:00 <ricebowl> :D
14:53:11 <ricebowl> if you can understand that, then you're doing better than I am, and I wrote it!
14:53:15 <dons> astrolab,e touch Main.hs
14:53:32 <dons> ricebowl, use type ;)
14:53:33 <sethk> ricebowl, how can it both be preferable and not matter?
14:54:11 <dons> I think he just wants to name some parts of that type def, in which case 'type' is good
14:54:24 <ricebowl> sethk - because creating separate types with identical representation is never *necessary*, only preferable
14:54:41 <ricebowl> well, these are functions which parse a string
14:54:49 <ricebowl> so I pass around a ton of (String, a) closures
14:54:50 <sethk> ricebowl, well then I'd argue that in some sense, it matters  :)  But I'm being pedantic rather than serious
14:54:52 <dons> well, sometimes it is necessary, when writing separatte instances 
14:55:01 <ricebowl> s/closures/tuples/ though they are closures too in a sense.
14:55:10 <ricebowl> sethk - I know
14:55:33 <ricebowl> I would prefer to use newtype, but it's a pain to decompose
14:55:34 <dons> for a pretty printer, I often need to introduce newtypes so that I can write an instance for some tuple
14:55:58 <sethk> here's another question.  Does using Trace give you a way to put in lots of tracing messages that can be turned on or off without modifying code?
14:56:25 <dons> in hmp3, the mp3 player, for example, each ui element is wrapped in a newtype, so that an instance of the rendering class can be written for that element
14:56:42 <ricebowl> that's pretty useful
14:56:45 <sethk> what I do in other languages by having a global "trace level" variable and having a function that prints (or doesn't) messages based on the level
14:57:02 <dons> sethk, ah, good question.
14:57:06 <dons> you can turn asserts on and off
14:57:11 <dons> but trace. hmm.
14:57:19 <dons> you could put the trace *inside* the assert!
14:57:25 <dons> then turn it off with -no-asserts
14:57:35 <sethk> dons, asserts are different, though, if they are like C asserts.  C asserts kill the program if they are true
14:57:36 <astrolabe> @karma+ dons
14:57:36 <lambdabot> dons's karma raised to 17.
14:57:39 <Heffalump> SyntaxNinja: errm, weird. no, I don't.
14:57:41 <astrolabe> thanks dons
14:58:13 <dons> sethk, soo you just have assert (trace (my value) $ True) $ ...
14:58:32 <dons> and then switch them on and off with -fignore-asserts
14:58:34 <dons> :)
14:58:37 <sethk> dons, I don't see assert in the library index.  Assertion in ControlException ...
14:58:50 <sethk> or is it a part of the language?
14:58:52 <dons> @index assert
14:58:52 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
14:58:55 <SyntaxNinja> yay, I just got TaPL in the mail!
14:59:04 <dons> :)
14:59:09 <SyntaxNinja> Heffalump: I don't recall having played any such joke on David, but I don't know anyone else who would write that.
14:59:40 <dons> sethk, but I don't reccomend this trick (which I just made up) ;)
14:59:40 <sethk> I see it.  should be in the index, the documenter thing goofed
14:59:48 <Heffalump> I'm a bit confused. It looks to me like he made up a hypothetical conversation that darcs-server should have been able to support.
14:59:53 <sethk> dons, yes, I got that, not terribly portable  :)
14:59:57 <dons> write your own wrapper for trace, that you can turn on and off with a falg
14:59:59 * ricebowl is confused by GHC
15:00:02 <sethk> dons, I guess I should write my own trace wrapper
15:00:20 <dons>  stefanw wrote a nice wrapper for his testing framework, lte me see...
15:00:36 <sethk> dons, ah, if it already exists, I'll gladly steal it  :)
15:01:03 <SyntaxNinja> Heffalump: oh, so it doesn't sound like this actually happened?
15:01:06 <Frederick> bah finally I got the problem, Ive tracked it finally
15:01:20 <sethk> dons, Use an IORef for the tracing state?
15:01:36 <Heffalump> errm, possibly.
15:01:41 <dons> sethk, http://www.cse.unsw.edu.au/~dons/code/icfp05/Logging.hs
15:01:43 <SyntaxNinja> well, I replied to him, we'll see.
15:01:52 <Heffalump> he does say "imagine using over the phone"
15:01:58 <Heffalump> but the conversation is a bit un-computer like
15:01:59 <sethk> dons, thanks, reading
15:02:03 <lisppaste2> Frederick pasted "how can I make it came back once evaluated?" at http://paste.lisp.org/display/13943
15:02:07 <lisppaste2> soysauce pasted "Type Confusion :(" at http://paste.lisp.org/display/13944
15:02:21 <SyntaxNinja> Heffalump: I think you're right. OK whew.
15:02:28 <Frederick> folks things that require that que algorithm recover a rule dont work.
15:03:01 <ricebowl> OK, I am still thoroughly confused as to why GHC requires me to unify r and [a]
15:03:13 <ricebowl> the function can have a more general type
15:03:22 <lisppaste2> Frederick pasted "Sample Error" at http://paste.lisp.org/display/13945
15:03:22 <SyntaxNinja> TaPL is way bigger and more dense than I expected! I see why it's $70
15:03:32 <ricebowl> or can a -> b match Int -> Char?
15:04:23 <Heffalump> SyntaxNinja: the other obvious suspect would be Igloo, but I don't remember him having an opportunity either.
15:04:39 <Heffalump> and it would seem a bit excessively destructive to do that
15:04:53 <Heffalump> (given the risk of it ending up in history like that)
15:05:30 <sethk> dons, everything get's too complicated.  I don't need, really, the line number in the source.  Plus, I have no idea how to code the current line number.  Is there a macro for it like in C with __LINE__?
15:05:52 <sethk> dons, I guess I can just put a zero there, but that's ugly  :)
15:06:27 <eivuokko> From TaPL ... I had a question, is chapter 24, existential types same stuff as existential stuff in Henk paper?  I don't understand either (yet).
15:07:09 <sethk> dons, is there an example on line that uses this library?
15:07:19 <dons> sethk, the line stuff gets inserted automagically with an m4 macro. let me find you an example
15:07:33 <dons> here's the macros: http://www.cse.unsw.edu.au/~dons/code/icfp05/pp/macros.m4
15:07:43 <dons> which expand to calls to the underlying haskell functions you just saw
15:08:21 <dons> and then here's some examples:        debug $ "State transition from " ++ show s ++ " to " ++ show s'
15:08:47 <sethk> dons, what do I do with the macro file?  Is there something like #include I can use within haskell source?
15:09:15 <SyntaxNinja> Heffalump: agreed.
15:09:17 <dons> nope, you specify the preprocessor on the command line to ghc, which runs the m4 over the src, expanding 'debug' into debug_ LINE_NOo
15:09:25 <SyntaxNinja> Heffalump: now, I might add a README that said that ;)
15:09:29 <dons> with: -pgmF "pp/logpp"
15:09:39 <sethk> dons, so I can't use it with ghci
15:09:39 <dons> look here: http://www.cse.unsw.edu.au/~dons/code/icfp05/pp/
15:09:47 <dons> sethk,nope, you sure can
15:09:59 <dons> ghci -pgmF "pp/logpp"
15:10:16 <dons> it's nice to have wrappers to this preprocessor : http://www.cse.unsw.edu.au/~dons/code/icfp05/ghci
15:10:19 <Frederick> folks can someone please take a look on my mistake and see if you can enlightenn me?
15:10:30 <sethk> ok, let me read all of that, and thanks again.
15:10:38 <dons> so, in summary sethk, you need the Logging.hs module, you need the pp/ dir to get the preprocessor
15:10:46 <dons> and then you need the -pgmF pp/logpp flag
15:10:59 <dons> and then you get as arbitrarily complex traces as you like
15:11:24 <dons> you can set the warning level in Main.main: initLogging Debug (Filename "cop.log")
15:11:40 <dons> for example, would set the strong Debug level, to go into "cop.log"
15:11:52 <sethk> dons, I'm not clear on what is in the pp directory or where the name logpp comes from, whether it's a file (the file with the macros?) but maybe the examples will clarify
15:12:13 <dons> so maybe just grab the source: http://www.cse.unsw.edu.au/~dons/code/icfp05/
15:12:31 <sethk> dons, will do, thanks, I'll study it
15:12:36 <dons> in the pp/ subdir lives: logpp.in, which is just a wrapper over m4
15:13:02 <dons> you can remove the .in part by manually inlining the path to m4 in that file yourself  (rather than letting configure do it)
15:13:09 <sethk> oh, and logpp.in I download your logpp.in
15:13:56 <dons> yep, so you need: pp/* , Logging.hs, and to call initLogging when your app starts up
15:14:27 <sethk> dons, right, initLogging I read out of the Logging.hs you showed me.  It was the line number macro that threw me.
15:14:27 <dons> and to compile/interpret with -pgmF pp/logpp
15:14:38 <dons> yeah, it's a tricksy trick.
15:14:52 <dons> I think stefanw has a new version which uses cpp line pragmmas instead
15:15:12 <dons> I wonder where that lives? (he's on a plane to .de atm, so not online I think)
15:16:00 <dons> sethk, anyway, all in all,  I think this is the most sophisticated tracing/logging facility I know of for Haskell, so for a big project, it's would be reasonable to use
15:16:09 <dons> we used it for the icfp contest, and it was really worth  it
15:16:26 <dons> particuarly the ease with which you can turn logging on and off
15:16:27 <kosmikus> SyntaxNinja, Heffalump: for what it's worth, the mail reads to me like a good joke, and I wouldn't have assumed that it has a background in reality ...
15:16:33 <sethk> dons, oh, yes, I can see that.  I do very similar things in my c++ projects.
15:16:58 <sethk> dons, having a less complex version, an info log without the line number, would be simpler for short programs
15:17:18 <sethk> dons, but once I get it set up to use the macros I'm sure I'll find other uses for macros
15:17:55 <dons> we did things such as timing computations with the traces, so it's flexible in that respection
15:18:13 <dons> in fact, in retrospect, we wasted time worrying about timeing computatoins ;)
15:18:46 <sethk> dons, it's a nice facility.  Looks like perhaps two, or three even, levels of complexity make sense.
15:18:47 <SyntaxNinja> kosmikus: OK. I didn't read the whole thread, so I didn't have the context.
15:19:05 <sethk> dons, perhaps a very simple one without macros
15:19:15 <sethk> dons, a "normal" one, and another with fancy things like timing.
15:19:31 <sethk> dons, or maybe the ability to choose the logging destination and such should be at level 3.
15:19:44 <dons> yeah, sounds reasonable
15:20:32 <sethk> dons, I think that, in general and not just in Haskell, we tend to overdo the capabilities of things to a level of generality that perhaps is never needed
15:20:58 <dons> hehe :) you're a very pragmatic kind of guy 
15:21:05 <dons> and I agree
15:21:26 <dons> I'm far more on the side of lets get things done quickly, than lets create a new tower of monad transformers
15:21:37 <dons> hehe, /me hopes Heffalump isn't looking
15:21:52 <eivuokko> I find that haskell is so easy to refactor that I am starting to care less about generalising as much as possible.
15:22:01 <lisppaste2> Frederick pasted "why it doesnt works for the first element?" at http://paste.lisp.org/display/13947
15:22:43 <dons> eivuokko, good point. with strong static typing kicking your butt if you get things wrong, you can refactor while half drunk
15:22:56 <dons> you could train a donkey to refactor haskell code
15:22:57 <sethk> dons, that's quite true
15:23:03 <eivuokko> dons, I have to try the drunk haskell coding, I have never tried it yet...
15:23:32 <dons> i'm a big fan of refactoring code whlie really sleepy, and just letting the type checker decide what's ok
15:23:42 <eivuokko> Heh.
15:25:30 * Frederick begs for help
15:26:02 <dons> sethk, how's the haskell on hardware going?
15:26:32 <sethk> dons, just getting back to it.  I got the hardware today.
15:26:36 <basti_> Frederick: ?
15:26:55 <Frederick> basti_, I know what is wrong but for me it doesnt makes sence the behavior of the code
15:27:11 <basti_> ah
15:27:11 <sethk> dons, Some of the earlier images have been done with eCos; I wonder if there anyone has ever tried to use ecos and haskell together.  Probably too far fetced.
15:27:15 <basti_> looking at your paste now Frederick 
15:27:37 <dons> what's eCos?
15:27:37 <Frederick> basti_, it is something about the list usage I maybe evaluating it worng
15:27:54 <basti_> Frederick: what is this supposed to do? why do you look up inside a map?
15:28:34 * dons always feels bad creating new orphan instances
15:29:15 <Frederick> basti_, this is the implementation of a transitive closure I check for where the production oftha side of the map can take me
15:29:26 <sethk> dons, a real time embedded mini-os
15:29:56 <basti_> Frederick: are you aware what map does on lists?
15:29:59 <eivuokko> Wow, eCos looks cool.  Makes me wish I had reason to play with it.
15:30:17 <eivuokko> (Assuming even some of the hw is easy to get)
15:30:33 <eivuokko> ..as embedded devices of course.
15:30:52 <Frederick> basti_, so for a production like S -> A I got ["S","A"] so I look up on A, map returns a list constructed by appling a function (the first argument) to all items in a list passed as the second argument doesnt it?
15:31:23 <basti_> Frederick: yes. But your function implies that the list elements are lists itself
15:31:27 <basti_> afaics
15:32:13 <Frederick> basti_, yes cause it is a list of lists where the lists are the productions of the variable contained on the list of productions beeing evaluated
15:32:21 <basti_> Frederick: hmm ok.
15:32:31 <basti_> and then "Map k k"?
15:32:46 <basti_> that sounds vague and not what you might want to say
15:32:53 <Frederick> like ["A","aB"] ["B","b"] I check the list be
15:33:13 <basti_> your (outer) map is from some type to the same type?
15:33:33 <Frederick> basti_, yes
15:33:43 <basti_> so inside are maps.
15:33:46 <basti_> then the keys are maps too?
15:33:57 <Frederick> basti_, yes
15:34:14 <basti_> oh
15:34:16 <basti_> thats wacko
15:34:41 <basti_> and i don't get the rest at all
15:34:42 <Frederick> basti_, I can run some samples than you might take the idea
15:35:42 <lisppaste2> Frederick pasted "look basti" at http://paste.lisp.org/display/13949
15:36:13 <basti_> :-o
15:36:33 <basti_> but why do you want maps to be keys of your map?
15:36:52 <Frederick> basti_, do you know what is a context free grammar?
15:37:04 <basti_> yes
15:37:11 <basti_> i would exect some parser to accept characters
15:37:12 <basti_> not rules
15:37:48 <Frederick> basti_, this is a parser for the context free grammar it self, it is a parser that teorically can take any grammar
15:38:39 <Frederick> basti_, when I want to simplificate productions that replace variables like S-> A , A -> a I want to end up with S -> a do you agree with me/
15:38:55 <basti_> uhmm
15:39:06 <basti_> thats a parser, then
15:39:08 <basti_> ?
15:39:13 <Frederick> basti_, yes
15:39:26 <basti_> you can do that as some sort of grammar exercise? 
15:39:31 <basti_> attribute whatever
15:39:48 <Frederick> basti_, Im not sure about what do you mean with your last question
15:39:55 <Frederick> may you please rephrase?
15:40:11 <basti_> well a parser for me is something that parses a grammar.
15:40:15 <basti_> not more and not less
15:40:20 <Frederick> yes
15:40:27 <basti_> and you want to optimize your grammar by parsing it?
15:40:46 <Frederick> basti_, yes, simplificate it, remove empty productions useless symbols and stuff
15:40:55 <basti_> you mean: you're parsing rules.
15:40:59 <basti_> and then, you're optimizing.
15:41:09 <Frederick> basti_, yes
15:41:17 <basti_> no need to mix them up then
15:41:19 <basti_> ^^
15:41:35 <Frederick> basti_, ?
15:41:37 <basti_> so the problem is in the parsing or in the (pre)optimizing?
15:41:43 <liyang> Is there a module that'll take a bytestream and let me read it as a stream of bits?
15:41:50 <Frederick> basti_, in the optimizing it self
15:42:06 <basti_> Frederick: "may you please rephrase?"
15:43:00 <Frederick> basti_, if I got a grammar like S -> aXa | bXb, X -> a | b | S | ¬£ do you agree with me that the production X -> S adds no info?
15:43:13 <basti_> yes
15:43:17 <Frederick> basti_, it i just renaming a variable, do you agree with me?
15:43:22 <basti_> yes.
15:43:52 <Frederick> oki so if we substitute that for X -> aXa | bXb we add the info we are looking for do ou agree with me?
15:44:13 <basti_> yes.
15:44:29 <Frederick> basti_, this is what I want to do but it fails for the root
15:44:54 <basti_> i don't have a clue how that would happen. I'm sorry.
15:45:17 <Frederick> basti_, now a sample If I got S -> A, A -> a it is a simplified case of the same situation right?
15:45:49 <basti_> ehhmm
15:46:17 <Frederick> bacam, I got a production S -> A that adss no real info right?
15:46:45 <basti_> yea
15:46:48 <basti_> kinda
15:47:10 <basti_> are you sure that kind of stuff is checkable?
15:47:11 <Frederick> basti_, well my program works in this case and fails in the former, so I believe it is all about fixing 1 or 2 lines
15:47:18 <Frederick> basti_, sure
15:47:21 <basti_> probably yes
15:47:32 <Frederick> I got pdf's and a book with algorithm drafts
15:47:48 <Frederick> http://hysteria.sk/~neologism/fred
15:48:04 <basti_> ok that should be enough ^^
15:48:24 <basti_> maybe you just add a "blind root"?
15:48:31 <basti_> thats a workaround though ^^
15:49:22 <Frederick> basti_,how would be that?
15:49:42 <Frederick> basti_, I got only 2 more hours, it is the time for work around code obfuscation and stuff
15:49:55 <basti_> :-o
15:50:04 <basti_> well just add a useless rule by purpose
15:50:08 <basti_> and delete it manually in the end
15:50:15 <basti_> then the root needs not to be touched
15:50:38 <Frederick> basti_, can you help me with that?
15:50:49 <basti_> i can't read your code in that much detail
15:50:59 <basti_> what would your code do if you added S' -> S as a rule?
15:51:10 <SyntaxNinja> Frederick: have you tried posting your questio to a mailing list?
15:51:33 <Frederick> SyntaxNinja, do they answer so fast?
15:51:43 <shapr> g'day Pseudonym 
15:51:58 <Pseudonym> G'day.
15:53:12 <Frederick> basti_, Ive just tried the false root with no succes =/
15:53:35 <SyntaxNinja> Frederick: often.  usually faster than flogging the channel ;)
15:53:42 <SyntaxNinja> since you'll get people who actually have time to answer.
15:53:54 <Frederick> SyntaxNinja, where do I post on the list?
15:54:09 <basti_> Frederick: then obviously your statement was not true
15:54:30 <Frederick> basti_, ?
15:54:41 <SyntaxNinja> Frederick: haskell-cafe probably
15:55:09 <basti_> Frederick: you said that only in the root your algorithm would fail
15:55:09 <Frederick> sylvan, there is no such chanell
15:55:23 <Frederick> basti_, it fails for the root
15:55:50 <basti_> yes
15:55:56 <Frederick> basti_, it seems to fail forthe first evaluated symbol I cant define perfet pattern for the problem
15:55:58 <basti_> so you add a fake root and drop it later again
15:56:02 <basti_> ah
15:56:02 <basti_> okay
15:56:07 <basti_> so it doesnt only fail for the root
15:56:10 <basti_> then i got no clue
15:56:44 <Frederick> SyntaxNinja, wich is the adress of haskell cafe?
15:57:09 <ndm> haskell-cafe@haskell.org
15:57:50 <Frederick> ndm, is it appropriate to ask for help there?
15:58:07 <ndm> Frederick: if its haskell related, yes
15:59:24 <SyntaxNinja> Frederick: you might want to sign on to the list first; it's moderated for non-list members, if I recall.
16:04:45 <Frederick> SyntaxNinja, Ive registered
16:04:45 <Frederick> SyntaxNinja, is this name suitable for the mail? Problem over Context Free Grammar Transitive Closure Algorithm I want to be as much specific as I can
16:04:47 <ndm> Frederick: its not particularly important, its a pretty easy going list :)
16:12:15 <Frederick> mailed
16:15:35 <SyntaxNinja> Frederick: good luck!
16:19:18 <Frederick> SyntaxNinja, now I sit down and wait
16:19:18 <dons> @dynamic-load poll
16:19:18 <dons> or maybe not.
16:19:18 <dons> try again.
16:19:18 <Frederick> dons, ?
16:19:18 <Frederick> what?
16:19:18 <Heffalump> ooh.
16:19:18 <Heffalump> that sounds exciting
16:19:18 <dons> just muttering to myself.
16:19:19 <dons> @quit lambdabot
16:19:19 * Frederick feels like a dog lost into a raining night
16:19:19 <dons> silly freenode doesn't realise lambdabot already left
16:19:19 <dons> i'll wait till it notices.
16:19:19 <dons> anyway, yeah, boegel wrote this cool voting pluing
16:19:20 <dons> plugin. you can add new polls, add candidates, vote, close polls =, view results
16:19:20 <dons> i think he's using it as a TMR article generator (?)
16:19:20 <dons> or some such
16:19:37 <dons> ah, there we go.
16:20:16 <dons> @help poll
16:20:23 <dons> @listcommands poll
16:20:29 <dons> @bot!
16:20:32 <lambdabot> poll provides: poll-browse poll-show poll-add choice-add vote poll-result
16:20:34 <lambdabot> poll-close poll-remove
16:20:42 <lambdabot> poll provides: poll-browse poll-show poll-add choice-add vote poll-result
16:20:44 <lambdabot> poll-close poll-remove
16:20:46 <lambdabot> Don't forget the parameters ! Check @help <vote-cmd> for info.
16:20:53 <Heffalump> yay!
16:21:05 <Lemmih> @poll-browse
16:21:06 <lambdabot> []
16:21:06 <Heffalump> @help poll-add
16:21:07 <lambdabot>  @poll-add <name> <choice>    adds a new poll with a single choice
16:21:15 <dons> where 'choice' == candidate
16:21:15 <Heffalump> @help choice-add
16:21:16 <lambdabot>  @choice-add <poll> <choice>  adds a new choice to the given poll
16:21:27 <Heffalump> can I quote arguments?
16:21:35 <dons> hmm, not sure. we'll see..
16:21:44 <dons> @version
16:21:45 <lambdabot> lambdabot 3p195, GHC 6.5.20050806 (Linux i686)
16:21:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:21:51 <Heffalump> @poll-add "The language of choice for discriminating hackers" Haskell
16:21:52 <lambdabot> added new poll: "The.
16:21:58 <Heffalump> apparently not :-)
16:21:58 <dons> wow. getting really close to 1000 patches in a calendar year!
16:21:59 <Lemmih> Urk.
16:22:17 <Heffalump> @poll-add TheLanguageOfChoiceForDiscriminatingHackers Haskell
16:22:18 <lambdabot> added new poll: TheLanguageOfChoiceForDiscriminatingHackers.
16:22:36 <Lemmih> @vote TheLanguageOfChoiceForDiscriminatingHackers Haskell
16:22:36 <lambdabot> voted on Haskell
16:22:52 <Lemmih> @vote TheLanguageOfChoiceForDiscriminatingHackers Haskell
16:22:52 <dons> ok, adding quotes..
16:22:52 <lambdabot> voted on Haskell
16:23:16 <dons> @votee TheLanguageOfChoiceForDiscriminatingHackers GNU make
16:23:17 <lambdabot> no such choice in this poll !
16:23:26 <dons> @vote TheLanguageOfChoiceForDiscriminatingHackers GNU make
16:23:27 <lambdabot> no such choice in this poll !
16:23:31 <dons> @vote TheLanguageOfChoiceForDiscriminatingHackers GNUmake
16:23:32 <lambdabot> no such choice in this poll !
16:23:58 <dons> @poll-result
16:24:00 <lambdabot> Don't forget the parameters ! Check @help <vote-cmd> for info.
16:24:05 <dons> @poll-result TheLanguageOfChoiceForDiscriminatingHackers
16:24:06 <lambdabot> True[("Haskell",2)]
16:24:09 <Heffalump> @poll-remove "The
16:24:10 <lambdabot> Poll should be closed before removing !
16:24:16 <Heffalump> @poll-close "The
16:24:17 <lambdabot> poll "The closed.
16:24:20 <Heffalump> @poll-remove "The
16:24:21 <lambdabot> poll "The removed.
16:24:34 <Heffalump> what's the True?
16:24:42 <dons> not sure. 
16:25:00 <eivuokko> Open status?
16:25:00 <dons> it's all in Plugins/Poll.hs 
16:25:19 <dons> now, what did we want to fix? quoting?
16:25:25 <Heffalump> yes
16:25:36 <Heffalump> either that, or remove the second argument to @poll-add
16:25:41 <dons> ah, I needed to add a candidate for GNU make
16:25:48 <shapr> Yeah, remove the second candidate.
16:25:51 <Heffalump> and just make it take the entire command-line as the poll name
16:26:01 <dons> yep.
16:28:00 <dons> I think maybe: @poll-open ?
16:28:15 <dons> or is @poll-add easier to remember?
16:29:15 <Heffalump> open is better if close will exist
16:29:18 <Heffalump> oh, hmm.
16:29:26 <Heffalump> actually, how about add and open.
16:29:30 <Heffalump> open stops more choices being added.
16:29:37 <Heffalump> then close and remove will be symmetric
16:29:53 <dons> and wht does add do?
16:30:00 <dons> ah, I see.
16:30:02 <Heffalump> creates a new poll
16:30:08 <Heffalump> then you add some choices, finally you open it
16:30:12 <dons> and open starts voting
16:30:15 <dons> yep
16:31:12 <dons> so @poll-add declares an election, and @poll-open starts voting day
16:31:19 <dons> :)
16:31:22 <Heffalump> right.
16:31:32 <Heffalump> and closes nominations simultaneously :-)
16:31:39 <dons> yep
16:31:51 <dons> @poll-browse
16:31:52 <lambdabot> ["TheLanguageOfChoiceForDiscriminatingHackers"]
16:31:57 <dons> @poll-show
16:31:58 <lambdabot> Don't forget the parameters ! Check @help <vote-cmd> for info.
16:32:17 <dons> @poll-show TheLanguageOfChoiceForDiscriminatingHackers
16:32:18 <lambdabot> ["Haskell"]
16:32:57 <Heffalump> I think anyone who tries to add another choice should be banned from the channel right away ;-)
16:33:10 <dons> hehe
16:33:18 <dons> unless it's an EDSL ;)
16:33:24 <dons> I think that would be ok.
16:33:48 <dons> or Hsakell98 versus Haskell'06
16:34:50 <palomer> is there going to be a haskell'06?
16:34:54 <palomer> it better rock the house
16:35:06 <dons> it better! or there'll be trouble!
16:35:33 <sethk> I thought this was #cobol
16:35:34 <Heffalump> I should read the Haskell mailing list.
16:35:39 <Heffalump> How is progress with H'06?
16:35:39 <palomer> has the commitee been formed yet?
16:35:51 <Igloo> I realised the other day I think I'm probably against it, as it probably won't do enough for tools that support H06 to actually be useful to me and it'll delay H2
16:35:59 <sethk> palomer, no, they can't find enough people who can spell committee
16:36:07 <palomer> shush you!
16:36:12 <palomer> H2 sounds groovy
16:36:36 <Heffalump> it's not obvious it'd delay H2.
16:37:20 <Igloo> IMO the best case is it'll make no difference, which is very unlikely
16:38:00 <palomer> will H2 have a revamped type system?
16:38:03 <palomer> dependent types!
16:38:05 <Heffalump> the existence of H'06 as the "stable track" might spur people into making a "devel track"
16:38:13 <Heffalump> I bloody hope it doesn't ahve dependent types!
16:38:20 <Heffalump> though Omega is interesting.
16:39:09 <dons> Igloo, going to package hmp3 for debian?
16:39:16 <Igloo> I suppose it's possible it might make people more willing to make backwards-incompatible changes for H2, which would probably be a good thing
16:39:17 <dons> it's just pure Cabal.
16:39:33 <dons> or does someone else handle the non-compiler stuff?
16:40:19 <Igloo> I probably won't package it as I have no intention of using it, but various other people (Isaac, Cosmic amongst them) might want to
16:40:29 <dons> Igloo, right. cool.
16:40:34 <Heffalump> hmp3?
16:40:58 <Heffalump> ah, right
16:41:05 <dons> I'm just happy my heap sits on around 2M, and think it's ready to sell :)
16:41:54 <dons> Igloo, how does minstrel go after long hours? any creeping space issues? I had to do some hard thinking to fix hmp3
16:42:20 <dons> s/fix/optimise, really/
16:42:30 <Igloo> I haven't seen any space issues, but I haven't been looking for them
16:42:38 <dons> ok.
16:42:42 <Igloo> What were the problems?
16:42:49 <kosmikus> I think that H2 will not happen.
16:42:54 <Igloo> I can't think of anywhere obvious it could have a space leak
16:43:13 <dons> after 20 or more hours the heap would be around double or triple what it started as.
16:43:41 <dons> mostly it seems the GC was just hanging on to old things, and setting +RTS -G1 solved the issue
16:43:48 <dons> which was a bit unusual, I think.
16:44:06 <dons> but then it sleeps most of the time, so maybe this is an unusual use case for the GC.
16:44:19 <dons> just little bursts of computation every second or so
16:44:29 <dons> and only one long lived value
16:44:56 <Igloo> A fresh minstrel seems to take more memory than one with 17:44 CPU time, which makes little sense to me
16:45:06 <Igloo> Oh, maybe the last played mp3 is being counted in that
16:45:07 <ricebowl> blah, Haskell screwed me. Now I can hardly bear to code C++. :(
16:45:19 <ricebowl> "oh shit, I can't code generically *bangs head against wall*"
16:46:15 <Igloo> No, that's not it
16:48:01 <dons> after around 10 hours now, I use around 1/8 heap as a fresh hmp3
16:48:05 <Saulzar> ricebowl, You can get a good approximation of it if you want to type 8 times as much text - the boost people seem to think so anyway :)
16:48:19 <ricebowl> haha
16:48:22 <ricebowl> indeed
16:48:23 <SyntaxNinja> do the haskell mailing lists usually include the [mailinglistname] at the beginning of each subject?
16:48:31 <ricebowl> I'm using templates, but it's a royal pain
16:48:38 <dons> I think on haskell-cafe and haskell, SyntaxNinja
16:49:04 <eivuokko> I wish they did...most don't seem to :-(
16:49:31 <Frederick> SyntaxNinja, the list is dead! =/
16:49:57 <ricebowl> Saulzar - tuples are sorely missed :(
16:50:24 <eivuokko> Boost has tuples, few times over ;)
16:50:26 <Saulzar> Hehe, well you can have tuples - but no pattern matching :)
16:50:29 * ricebowl lacks boost
16:50:34 <ricebowl> that's true too
16:50:52 * ricebowl pulls out hair
16:50:59 <ricebowl> what shall I name thee, oh my variable?!
16:51:08 <ricebowl> I cannot use the ' symbol
16:51:24 <Frederick> ricebowl, name it Frederick in my honor
16:51:28 <Saulzar> abcd1234
16:51:29 <ricebowl> haha
16:51:44 <Frederick> ricebowl, then you shall never forget its importance
16:51:54 <Saulzar> C++ could be so much simpler with some nicer syntax
16:52:01 <ricebowl> could be
16:52:12 <Frederick> Saulzar, that would be java
16:52:18 <ricebowl> well now I'm banging my head on the desk because I can't do nice things like I was doing earlier quite as easily
16:52:55 <ricebowl> something like case (parsedec getContents) >>= (parsedec getContents) of Nothing -> putStr "Syntax error" Just (...) -> ...
16:53:05 <ricebowl> chaining parsers together
16:53:23 <Saulzar> Had a look at spirit ? (Again it's boost...)
16:53:38 <ricebowl> no...I just want to solve this problem and be done with it
16:53:43 <Saulzar> It's designed for that kind of thing
16:53:48 <SyntaxNinja> Frederick: dead?
16:54:03 <Frederick> SyntaxNinja, no answer it
16:54:06 <Frederick> *yet
16:55:52 <sethk> ricebowl, you want to work on my device driver code in C?
16:55:56 <sethk> I have to read that haskell standalone image stuff tonight.
17:00:00 <shapr> sethk: House?
17:01:01 <ricebowl> sethk - heh, not particularly? ;)
17:01:05 <ricebowl> what kind of device driver?
17:14:25 <triplah> is there a debugging tool in ghc?
17:14:38 <triplah> i'm having trouble debugging a simple bit of recursive code :(
17:15:26 <palomer> I heard debugging in haskell is a bitch
17:15:30 <dons> ghci is the usual way
17:15:33 <dons> there are tools though
17:15:33 <palomer> triplah: considered using quickcheck?
17:15:36 <dons> buddha and hat
17:16:02 <triplah> i'm using ghci, i just cant figure out why my code isnt working
17:16:05 <triplah> :(
17:16:06 <dons> since you can just isolate your function in ghci and test it, we mostly do it that way.
17:16:23 <triplah> yeah the REPL is cool
17:16:29 <triplah> i mean this is a single function
17:16:32 <triplah> thats why i'm stumped
17:16:39 <triplah> <-- new to haskell
17:16:39 <dons> how is it broken?
17:16:51 <dons> wrong answers, or non-termination, or won't type chheck?
17:17:06 <triplah> wrong answers
17:17:08 <triplah> _minimaBy _ _ [] = []
17:17:15 <triplah> _minimaBy f e (x:xs)
17:17:15 <triplah>                 | f e == f x    = x:(_minimaBy f x xs)
17:17:15 <triplah>                 | otherwise     = _minimaBy f e xs
17:17:19 <palomer> it attacks its masters, thus breaking the second law
17:17:32 <dons> ah, that's another possibility, yes, palomer
17:17:38 <triplah> _minimaBy gets called with e = x
17:17:45 <Pseudonym> Saulzar: http://citeseer.ist.psu.edu/787.html
17:17:46 <Lemmih> triplah: Drop the 'e' and keep a list of the minimum values.
17:17:53 <ricebowl> what is that supposed to do? Find the smallest element?
17:18:13 <Lemmih> > let _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) = if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy id [2,4,1,1,5] []
17:18:14 <lambdabot> [1,1]
17:18:23 <ricebowl> > foldl min [3,8,9,1]
17:18:24 <lambdabot>  add an instance declaration for (Show ([[a]] -> [a]))
17:18:31 <triplah> ricebowl: somewhat. apply a function which associates an ordered value with each elemnt of the list. then return the ones that have the smallest value associated with them
17:18:31 <ricebowl> er, oops
17:18:35 <ricebowl> > foldl1 min [3,8,9,1]
17:18:37 <lambdabot> 1
17:19:28 <triplah> impressive :)
17:19:47 <ricebowl> well it looks like x:xs only has to be Eq, not Ord
17:20:09 <Lemmih> > let _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) = case compare (f x) (f v) of EQ -> _minimaBy f xs (x:v:vs); LT -> _minimaBy f xs [x]; GT -> _minimaBy f xs (v:vs) in _minimaBy id [2,4,1,1,5] []
17:20:10 <lambdabot> [1,1]
17:20:14 <ricebowl> hmm, I see
17:20:26 <triplah> if f = length
17:20:31 <triplah> and the list is a bunch of strings
17:20:36 <triplah> we can return the smllest strings
17:20:54 <palomer> doesn't that function just return all values which have the same images as e under f?
17:21:01 <ricebowl> > let minima xs = filter (== (foldl1 min xs)) xs in [3,8,1,9,1]
17:21:02 <lambdabot> [3,8,1,9,1]
17:21:04 <ricebowl> er
17:21:19 <palomer> s/image/images
17:21:19 <ricebowl> oh
17:21:24 <ricebowl> > let minima xs = filter (== (foldl1 min xs)) xs in minima [3,8,1,9,1]
17:21:26 <lambdabot> [1,1]
17:21:29 <ricebowl> wow, I should be shot for that mistake.
17:21:36 <triplah> in keyword is used exclusivly with filter ?
17:21:41 <triplah> "in"
17:21:46 <ricebowl> no
17:21:50 <ricebowl> just with the let expression
17:21:53 <triplah> ahh ok
17:22:04 <ricebowl> > (\xs = filter (== (foldl1 min xs)) xs) [3,8,1,9,1]
17:22:05 <lambdabot>  parse error on input `='
17:22:10 <ricebowl> > (\xs -> filter (== (foldl1 min xs)) xs) [3,8,1,9,1]
17:22:11 <lambdabot> [1,1]
17:22:37 <ricebowl> the foldl1 min xs finds the smallest value, then the filter finds all elements in the list equal to that value
17:22:52 <ricebowl> um, let's see about adding a function
17:23:05 <triplah> ricebowl: will that work for length of strings though?
17:23:14 <ricebowl> yes, but wait :p
17:23:15 <triplah> i want to return the strings of shortest length, not their lengths
17:23:18 <triplah> lol :D
17:23:39 <triplah> Lemmih: thanks for that too ;)
17:23:47 <palomer> quick, someone come out with a solution using callcc
17:24:05 <ricebowl> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima length ["hello", "world", "how", "are", "you?"]
17:24:06 <lambdabot> ["how","are"]
17:24:32 <ricebowl> better? :)
17:24:47 <ricebowl> watch this!
17:24:55 <ricebowl> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima head ["hello", "world", "how", "are", "you?"]
17:24:56 <lambdabot> ["are"]
17:24:59 <ricebowl> :D
17:25:16 <ricebowl> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima head ["hello", "world", "how", "are", "you?", "I", "am", "doing", "fine"]
17:25:17 <lambdabot> ["I"]
17:25:37 <ricebowl> d'oh
17:25:41 <ricebowl> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima head ["hello", "world", "how", "are", "you?", "am", "doing", "fine"]
17:25:43 <lambdabot> ["are","am"]
17:27:39 <triplah> hah!
17:27:44 <ricebowl> ;)
17:27:54 <triplah> wait
17:27:57 <ricebowl> ?
17:28:02 <triplah> are = len 3
17:28:05 <triplah> am = len 2
17:28:55 <triplah> hmm
17:29:16 <ricebowl> oh, in that example I'm using head
17:29:19 <ricebowl> comparing by the first letter
17:29:53 <ricebowl> > all (\xs -> (head xs) == 'a') ["are", "am"]
17:29:55 <lambdabot> True
17:30:00 <ricebowl> :)
17:30:45 <triplah> ahh
17:31:00 <ricebowl> I was just trying to demonstrate the flexibility
17:31:07 <triplah> yeah :D
17:31:11 <triplah> didnt see the head
17:31:18 <ricebowl> look at this:
17:31:28 <ricebowl> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima id [2,0,1,1,0,3,0,4]
17:31:30 <lambdabot> [0,0,0]
17:31:47 <ricebowl> minima id == foldl1 min
17:32:08 <ricebowl> if you look at the code, it's easy to see why that is, too
17:32:43 <triplah> yep
17:38:11 <triplah> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in length id ["hi"]
17:38:12 <lambdabot>   The function `length' is applied to two arguments,
17:38:12 <lambdabot>   but its type `[a] -> Int' has only one
17:38:12 <lambdabot>   In the definition of `xxxx':
17:38:13 <ricebowl> heh weird, CVS said it reverted this file, but it didn't modify it :/
17:38:21 <triplah> eep
17:38:33 <ricebowl> hehe length id? You could do length . id :p
17:38:40 <ricebowl> you might want to call minima too
17:38:50 <ricebowl> ah BBL
17:38:57 <triplah> yeah was just trying to figure out exactly what that bit of code did
17:39:05 <ricebowl> good luck ;)
17:39:08 <ricebowl> *nods*
17:39:18 <triplah> i dont unserstand the equality check between filter and the foldl1
17:39:27 <triplah> understand*
17:39:41 <triplah> ahh
17:39:43 <triplah> duh
17:39:44 <triplah> :)
17:40:49 <shapr> hiya wli, how's code?
17:41:23 <ricebowl> triplah - the foldl1 bit computes the minimum value, that was the code that I pasted first
17:41:35 <triplah> yep
17:41:44 * ricebowl is back for about 15 minutes or so
17:42:02 <triplah> that makes proper sense, fold over the mapped list
17:42:30 * dons wonders if shapr's post regarding forkOS will be to propose spoonOS
17:43:57 <dons> @quit some new tasty treats
17:44:08 <dons> @help poll
17:44:22 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
17:44:24 <lambdabot> poll-close poll-remove
17:44:45 <dons> @poll-add BestPlugin
17:44:46 <lambdabot> Added new poll: "BestPlugin"
17:45:03 <dons> @choice-add BestPlugin @eval
17:45:04 <lambdabot> New candidate "@eval", added to poll "BestPlugin".
17:45:15 <dons> @vote BestPlugin @eval
17:45:15 <triplah> unnsw?
17:45:16 <lambdabot> voted on "@eval"
17:45:18 <triplah> uni of nsw
17:45:23 <dons> triplah, yeah
17:45:30 <triplah> heh cool
17:45:36 <dons> @poll-show BestPlugin
17:45:37 <lambdabot> ["@eval"]
17:45:42 <dons> @version
17:45:42 <lambdabot> lambdabot 3p196, GHC 6.5.20050806 (Linux i686)
17:45:42 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
17:45:56 <shapr> dons: Maybe I should propose that :-)
17:45:59 <dons> @poll-result BestPlugin
17:45:59 <lambdabot> Poll results for BestPlugin (Open): @eval=1
17:46:15 <dons> @choice-add BestPlugin @moo
17:46:16 <lambdabot> New candidate "@moo", added to poll "BestPlugin".
17:46:23 <dons> @vote BestPlugin @moo
17:46:23 <lambdabot> voted on "@moo"
17:46:28 <dons> @poll-result BestPlugin
17:46:29 <lambdabot> Poll results for BestPlugin (Open): @moo=1, @eval=1
17:46:57 <shapr> Someone mentioned a dataflow processor to me... how is that different from the average CPU?
17:47:49 <triplah> many haskellers in aus?
17:47:49 <Frederick> I couldnt fix my bug :(
17:47:54 <triplah> I study on the gold coast
17:48:00 <triplah> doing a principles of programming subject
17:48:04 <dons> triplah, yeah, a few. check the map
17:48:05 <dons> @map
17:48:05 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:48:07 <triplah> done scheme, prolog and haskell
17:48:11 <dons> cool!
17:48:27 <dons> I tutor a principles of programming subject here at unsw
17:48:28 <triplah> haskell is by far the coolest
17:48:38 <dons> it is.
17:48:44 <triplah> lazy evaluation + list comprehension
17:48:53 <dons> and more!
17:48:56 <triplah> and monads (one day)
17:49:05 <triplah> gotta write this assignment first :)
17:49:08 <shapr> Monads are a great power tool.
17:49:23 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
17:49:28 <triplah> thats my current assignment
17:50:29 <dons> well, list comprehensions are basically monadic programming anyway
17:50:30 <dons> so you're almost there
17:50:30 <Frederick> folks I got 10 min to finish this cananyone give me a hint? http://paste.lisp.org/display/13947
17:50:55 <triplah> really?
17:50:57 <triplah> hmm cool
17:51:09 <triplah> my lecturer shoed me something with monads for user I/O
17:51:29 <triplah> cheaty imperative programming stuff without breaking paradigm
17:51:47 <dons> yeah, there's a paper on monad comprehensions that generalises list comprehensions to monadic ones, in is it P. L. Wadler. List comprehensions. (?)
17:52:13 <dons> yeah, just thread a world-state token around, easy!
17:52:23 <triplah> ehe
17:53:15 <triplah> dons: what languages do you look at in your subject?
17:53:19 <dons> ah, this one "Comprehending monads", http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.ps
17:53:28 <dons> we implement a mini haskell in haskell
17:53:43 <dons> and cover static typing, dynamic typing , formal statiic and dynamic semantics
17:53:43 <triplah> we do three languages, also, syntax and BNF's, attribute grammars, types
17:53:48 <triplah> algebraic types
17:53:52 <triplah> its been pretty interesting
17:53:58 <dons> also subtyping.
17:54:00 <triplah> and challenging
17:54:07 <dons> oh the syntax etc stuff sounds more like our classic compilre courrse
17:54:08 <triplah> ahh cool
17:54:17 <dons> whereas the one I do is the type theory side
17:54:22 <dons> and more FP.
17:54:37 <triplah> yeah this is meant to be a combination of "how compilers work" and "some programming paradigms"
17:54:55 <triplah> considering half the poeple in my class have only ever coded java
17:55:01 <dons> ah well.
17:55:02 <triplah> its been a bit of an eye opened
17:55:07 <triplah> opener*
17:56:35 <triplah> thanks for the link
17:56:39 <triplah> on a windows machine here in class
17:56:44 <triplah> i'll check it out when i get home
17:57:15 <dons> there's .pdf versions and others at the same place, if you can't read .ps
17:58:00 <triplah> ahh cool
17:58:02 <triplah> bbl
17:58:05 <triplah> class over
17:59:45 * shapr tries to figure out if GRIN is classical SSA.
18:01:50 <shapr> Silly question, is this the phi function stuff in SSA sort of like COME FROM in INTERCAL?
18:02:27 * shapr will continue reading ChilliX's paper and hope for enlightenment.
18:03:17 <shapr> Sure looks like COME FROM to me.
18:06:57 <SlowByte> shapr: have you read "SSA is Functional Programming" (title might be slightly wrong) from Appel?
18:07:49 <shapr> No, but I'm reading a follow up paper by ChilliX, though I've moved on to http://en.wikipedia.org/wiki/Static_single_assignment
18:08:45 <shapr> SlowByte: I'll see if it's freely available, thanks.
18:08:49 <shapr> SlowByte: Any other suggestions?
18:09:27 <Philippa> SlowByte: it won't be hugely useful for this if I remember it correctly
18:09:44 <SlowByte> true, but it's a classic ;)
18:09:45 <Philippa> it just points out that if you're only ever assigning once then everything's immutable so it looks suspiciously familiar
18:09:52 <shapr> Well I'll be, it *is* COME FROM.
18:10:02 <SlowByte> about other papers, can't remember, it's been a while since I dealt with SSA.. and yes, that paper should be freely available, http://citeseer.ist.psu.edu/appel98ssa.html
18:10:32 <shapr> I never thought I'd find knowledge of INTERCAL of any use in CS.
18:10:36 * Philippa laughs
18:10:38 <SlowByte> the paper describes an SSA -> lambdacalc transform and that's about it IIRC
18:15:05 <SlowByte> the usual phi-node notation isn't very clear, I agree... the registers aren't visibly coupled with the coupled to the control flow nodes they come from
18:15:40 <shapr> SlowByte: Are you Uustalo?
18:15:44 <SlowByte> aaand I should get some sleep now, as is obvious from my last sentence :)
18:16:12 <shapr> or Vene?
18:16:13 <SlowByte> hee, I wish, but I am Estonian, yes :)
18:16:17 <shapr> ok :-)
18:17:08 <SlowByte> 4AM isn't exactly the best time to talk about SSA... but I'
18:17:26 <SlowByte> ll return, I have "learn Haskell beyond the usual FP fluff" waiting on my todo list
18:17:28 <shapr> It's only 3am here.
18:17:45 <shapr> I have a whole hour to go before incoherence strikes.
18:18:04 <shapr> Truly, Haskell is worth learning.
18:18:37 <shapr> I'm learning SSA to see if Boquist's GRIN does support the phi function stuff.
18:19:02 <shapr> If it does, I think there may more optimizations available ...
18:19:34 <SlowByte> I'm doing some optimizations research myself
18:19:40 <shapr> What subject?
18:19:45 <SlowByte> in fun sense, not academic :)
18:20:00 <shapr> I'm a self-employed web developer...
18:20:20 <SlowByte> I'm an un-employed dreamer ;)
18:20:29 <shapr> You can become a starving artist like me!
18:21:04 <shapr> Self-employed sounds a lot better than unemployed, even during those times when means the same thing.
18:21:18 <shapr> Anyway, what subject?
18:21:22 <arjanb> i think a bind with a case expression is similar to the phi function
18:21:25 <SlowByte> true, being self-employed is the plan but right now it isn't a necessity
18:21:57 <SlowByte> partial evaluation, generalized partial computation and all the other "sound fancy, ooh" things
18:22:35 <shapr> dcoutts is working on some partial evaluation research. Sadly not published yet...
18:22:49 <shapr> I can point you to Dairus Bacon's Hackers Guide to Partial Evaluation...
18:22:51 <SlowByte> and supercompilation
18:22:52 <shapr> Darius*
18:23:04 * shapr tries to remember what supercompilation does...
18:23:20 <shapr> What's the name of that company doing the Java supercompiler for the last N years?
18:23:38 <SlowByte> Supercompilers LLC ;)
18:23:45 <shapr> Too easy!
18:24:22 <SlowByte> there was an interesting paper on Prolog optimization that claimed it performed even better than GPC IIRC
18:24:55 <SlowByte> can't remember really right now, but I think it could produce a deterministic KMP-style matcher from some random Prolog matching code
18:25:07 <ChilliX> Shapr: yes, it is kind of a come from (including merging)
18:25:44 <shapr> ChilliX: Thanks
18:27:17 <SlowByte> I'm particularly interested in insane things like doing typing based on optimization, with types being in the same language as the code itself
18:27:31 <SlowByte> but I have absolutely no coherent view of how that would work
18:27:36 <shapr> Do you know dependent types?
18:27:42 <SlowByte> yes
18:28:06 <shapr> What do you mean by typing based on optimization?
18:28:48 <shapr> arjanb: That sounds right so far.
18:28:55 <SlowByte> well, optimization would basically remove type-checks/predicates, so if none remain, the program is statically well-typed
18:29:08 <SlowByte> and you could even go half-way so that some run-time checks remain
18:30:21 <shapr> How would you handle polymorphic code paths? Would you build the cartesian product of type specialized paths?
18:31:16 <SlowByte> something like that probably... it would probably rely on some sort of closed-world assumption in the sense that code just doesn't float in space, it gets used somewhere
18:32:06 <SlowByte> statically compiling it would probably be out of the question
18:33:15 <shapr> Self keeps polymorphic paths and caches type specialized paths at runtime.
18:33:52 <SlowByte> yeah, the Self compiler has been one of my "inspirations", so to say
18:34:01 <shapr> It's definitely a cool tool.
18:35:18 <SlowByte> but I'm spewing almost random sentences here, better get some sleep before my brain stops working altogether ;)
18:36:32 <SlowByte> I have all these interesting ideas that probably aren't even remotely sensible.. but time will tell!
18:36:54 <shapr> SlowByte: Yeah, keep on dreaming
18:37:01 <shapr> That's what I do.
18:37:09 <shapr> Come up with a dream, try to make it a reality.
18:37:19 <shapr> As long as you enjoy what you're doing.
18:37:24 <SlowByte> I can still afford pondering about obscure CS stuff for the most of my days, and I certainly am going to enjoy it, and produce something in the process
18:39:58 <dons> stupid suspicious header
18:51:02 <shapr> dons: Oh, nice tactful response.
18:51:11 <Igloo> ?
18:51:23 <dons> ?
18:51:53 <dons> Igloo, minstrel doesn't happen to know how to detect if a file is .mp3 does it?
18:52:12 <dons> deconstructing the magic file format looks boring :S
18:52:20 <Igloo> It just throws whatever you give it at gstreamer
18:52:29 <dons> yeah, same with hmp3
18:52:39 <dons> hehe /bsd plays a merry tune
18:52:53 <Igloo> Why do you need to know?
18:53:11 <dons> oh, jens asked me to filter out non-.mp3s
18:53:28 <dons> (on haskell@, which of course blocked the mail due to the word "mp3")
18:53:37 <dons> and I replied, which also got blocked
18:53:39 <Igloo> :-)
18:53:51 <dons> so we're just not allowed to talk about this topic
18:53:56 <Igloo> I think John wrote libmagic bindings, which probably know
18:54:03 <dons> ah, interesting.
18:54:09 <Igloo> How did the announcement get through?
18:54:17 <dons> I rewrote it has "hm p3"
18:54:20 <dons> which is fine.
18:54:23 <Igloo> heh
18:54:32 <ChilliX> dons: just call it EmPeeThree ;)
18:54:32 <Igloo> You could just do it on extension too, of course
18:54:58 <dons> Igloo, ? .mp3 is also illegal. you can't have the letters "mp3" anywhere in the header
18:55:04 <dons> ChilliX, yeah!
18:55:16 <Igloo> I mean to do your filtering, not to escape the lists' filtering
18:55:19 <dons> Igloo, ah I see whta you mean.
18:55:23 <dons> yeah, maybe that is simplest
18:55:47 <Korollary> Call it MPEG2 Layer-3
18:56:20 <dons> I just can't refer to the name of my program ;)
18:56:27 <dons> it's the program whose name we cannot speak
18:56:54 <Igloo> Or jump into the C21 with hogg  :-)
18:56:58 <Korollary> hmm, maybe renaming is an option
18:57:09 <Korollary> considering you might play ogg's, mp4's one day
18:57:10 <dons> hehe
18:57:25 <dons> yeah Igloo, a binding to some other player is certainly on the cards
18:57:51 <dons> it's a pretty simple protocol to emulate. start/stop/play/skip
18:58:14 <Igloo> Oh, mpg(123|321) can't cope with oggs?
18:58:23 <dons> don't know.
18:58:35 <Korollary> I wouldn't know. But the program name is hmp3, which implies just mp3'
18:58:57 <dons> well, if I write a new backend, i'll rename it for you Korollary ;)
18:59:18 <Korollary> I am hHonored
18:59:32 <dons> I will call it hKorollaryPlayer
18:59:48 <Korollary> I wonder if an mp3 decoder written in haskell would blow hard or not...
19:00:52 <Igloo> I'd expect a well tuned Haskell implementation to be half the speed of a C one, or possibly even worse
19:02:06 <Korollary> I once looked into the id3v2 tag format, and just that was icky.
19:25:24 <Frederick> folks I give a candy bar for who discovers what is broken here -> http://paste.lisp.org/display/13947
19:27:30 <Frederick> if I got a grammar like S -> A, A -> B .... .... -> a it reduces fine to S-> a but if S is referenced like S->A , A -> BS | S it doesnt works
19:29:12 <lisppaste2> Lokadin pasted "Nums.hs" at http://paste.lisp.org/display/13954
19:29:25 <Frederick> I'm giving a Ecandy for who points me a way out
19:29:58 <Lokadin> say i was wondering how to fix the IO [a] problem it keeps giving me on compile, like ihave no idea what's wrong :(
19:32:46 <Lokadin> like am i just completly off target?
19:33:16 <Frederick> any ideas for me
19:33:17 <Frederick> ?
19:33:32 <Lokadin> me? well i don't have the slightest idea what it is that you are doingn
19:33:47 <Lokadin> so sorry :( can't help
19:34:20 <Lokadin> but i'm sure you'd understand w/e limited understanding went into writing the above ^
19:34:40 <Lokadin> like there is a problem on line ten
19:34:43 * Frederick sits and criesd
19:34:54 <Lokadin> says expecting [b] but only has IO [a]
19:35:05 <Lokadin> *pokes* havne't you done that program already?
19:35:40 <Frederick> Lokadin, are you talking with me?
19:35:43 <Lokadin> yep
19:35:46 <Lokadin> i am actually
19:35:49 <Lokadin> i don't see anyone else here
19:35:50 <Lokadin> lol
19:37:27 <Lokadin> Frederick: so what do you think?
19:38:09 <Frederick> Lokadin, I think that sometime we reach our limits so we need someone to give us a lift ahead for a little so we can recover and keep running
19:38:41 <Lokadin> i don't quite understand :|
19:39:03 <Frederick> Lokadin, I cant continue alone I dont know wha is wrong
19:39:08 <Frederick> I know no other approach
19:39:14 <Lokadin> same with me
19:39:33 <Lokadin> but i'm sure you know what is wrong with my code, as you seem to know stuff much more advanced then mine
19:39:46 <Frederick> Lokadin, gimme your code
19:39:55 <Frederick> 1 sec lemme see
19:40:01 <Lokadin> kk
19:40:03 <Lokadin> http://paste.lisp.org/display/13954
19:40:21 <Lokadin> thanks :D
19:41:00 <Frederick> what error do you get?
19:41:15 <Lokadin> Nums.hs:10:48: Couldn't match `[b]' against `IO [a]'
19:41:38 <Lokadin> er
19:41:47 <Lokadin>  In the third argument of `foldl', namely `list'
19:41:48 <Lokadin>     In the first argument of `show', namely `(foldl (+) 0 list)'
19:42:13 <Lokadin> expected [b] inferred IO [a]
19:42:42 <Frederick> Lokadin, is it a sample from the tutorial or what?
19:43:01 <Lokadin> nope, it was excersize from tutorial
19:43:09 <Frederick> hm...
19:43:14 <Lokadin> and i'm trying to write it, but i don't know what i got
19:43:56 <Korollary> fellas, askForNum has type IO [a] because of getLine. Try replacing the let list = askForNum with "list <- askForNum".
19:44:23 <Lokadin> kk
19:44:44 <Lokadin> oh wow! :D yay it fixed
19:44:53 <Lokadin> thanks!
19:45:01 <Korollary> you betcha
19:45:12 <Frederick> Korollary, thx a lot
19:45:13 <Lokadin> oh but i have one more problem with the factorialize part :(
19:45:24 <Lokadin> ums.hs:25:53: Couldn't match `[a]' against `[Char] -> [a1]'
19:45:43 <Lokadin>  In the first argument of `factor', namely `x'
19:45:44 <Lokadin>     In the first argument of `(++)', namely `factor x'
19:47:11 <Korollary> Lokadin: check the types. x is probably a number. Maybe you meant "(show x) ++ ...". Same goes for "factor x".
19:47:22 <Lokadin> o
19:47:27 <Lokadin> thanks :D
19:48:14 <Frederick> Korollary, any idea for me? :p
19:54:21 <lisppaste2> Lokadin annotated #13954 with "Nums.hs" at http://paste.lisp.org/display/13954#1
19:54:46 <Lokadin> hmmm, say now it complains of
19:54:53 <Lokadin> Nums.hs:25:31: Couldn't match `Char' against `[Char]'
19:55:33 <Lokadin> i don't know how to make it understand that it's supposed to be a string and not a char output
19:56:46 <Lokadin> to be honest i'm not even sure if i'm supposed to be able to do that :|?
19:57:42 <Korollary> Lokadin: What does <code>(x " factorial is "</code> mean ?
19:58:14 <Lokadin> er well i want to make a big string, that it will then output, cause i couldn't figure out how to do it otherwise
19:58:24 <Lokadin> supposed to do, factorial of a few numbers,
19:58:44 <Lokadin> and there are no for loops,,, so i decided to make a big string that it would return and then pring
19:58:47 <Lokadin> print*
19:58:57 <Korollary> It looks like x is supposed to be a function that expects a string as an argument.
19:59:38 <Lokadin> you mean factorialize?
19:59:44 <Korollary> no, "x".
19:59:47 <Lokadin> what's x?
19:59:55 <Lokadin> i don't have it declared anywhere
19:59:56 <Korollary> It's in your code. Line 25
20:00:16 <Lokadin> o wow, i was looking in the wrong place :|
20:00:38 <Lokadin> ummm
20:02:12 <Lokadin> well isn't list a list of numbers?
20:02:29 <Lokadin> and the first item would be an int, and i'd show it with show no?
20:03:38 <Lokadin> how could an Int be a function?
20:03:58 <Korollary> Lokadin: Int is a type
20:04:14 <Lokadin> well and x is an Int no?
20:04:59 <Korollary> Lokadin: Probably that's what you want. But your usage of x like a function confuses the compiler. That's why you are getting the error.
20:06:18 <Lokadin> but how is it that i'm using it like a function? aren't i just showing the Int in show(x) ?
20:07:12 <Korollary> Lokadin: In haskell, a function call is written as "f y", with f as the function and y as the argument. Since you have (x " factorial") in there, it looks like x is supposed to be a function.
20:08:19 <Korollary> observe
20:08:23 <Lokadin> kk
20:08:25 <Korollary> > let x = 5 in x "yadda"
20:08:26 <lambdabot>  add an instance declaration for (Num ([Char] -> a))
20:08:26 <lambdabot>   In the definition of `x': x = 5
20:08:26 <lambdabot>   In the definition of `xxxx': xxxx = let x = 5 in x "yadda"
20:08:50 <Korollary> you probably want this instead:
20:09:04 <Korollary> > let x = 5 in (show x) ++ " yadda"
20:09:06 <lambdabot> "5 yadda"
20:10:15 <Lokadin> but thats how i wrote it no? i mean i wrote show(x) ++ " factorial is"
20:10:31 <Lokadin> oh
20:10:34 <Lokadin> nm
20:10:58 <Lokadin> :| actually no i'm still confused
20:11:12 <Korollary> well, in the paste page you dont have a show
20:11:45 <Lokadin> well the new one
20:11:47 <Lokadin> i annotated it
20:11:53 <Lokadin> er
20:11:54 <Lokadin> here
20:11:58 <Lokadin> http://paste.lisp.org/display/13954#1
20:12:23 <Korollary> ah
20:12:29 <Lokadin> yep :)
20:12:45 <Korollary> ok, why did you put a return in factorialize ?
20:13:02 <Lokadin> er so it would return a string to the putstring at the top?
20:13:07 <Lokadin> can i do that?
20:13:30 <Korollary> You can do anything you want. It's just that you didn't need to do anything like that.
20:13:47 <Lokadin> so waht was i supposed to do?
20:13:55 <Cale> "return" turns a value into a computation returning that value
20:14:16 <Cale> you don't want factorialize to return a computation here
20:14:19 <Cale> just a value
20:14:22 <Lokadin> yea
20:14:23 <Cale> (the string)
20:14:25 <Lokadin> yep
20:14:29 <Cale> so you don't need "return"
20:14:58 <Lokadin> okay well i took out the return and it says
20:14:59 <Lokadin> Nums.hs:12:14: Couldn't match `[Char]' against `t -> t1'
20:15:23 <Lokadin> Expected type: [Char] Inferred type: t -> t1
20:15:29 <Lokadin>  Expected type: String
20:15:30 <Lokadin>       Inferred type: [a] -> [Char]
20:15:58 <Korollary> "putStrLn (factorialize)".
20:16:35 <Lokadin> ?
20:16:39 <Lokadin> yea that line
20:17:10 <Korollary> putStrLn expects a String. You are passing it a function.
20:17:27 <Lokadin> oh, so how do i resolve that?
20:17:31 <Korollary> probably you want "putStrLn (factorialize list)".
20:18:21 <Lokadin> Nums.hs:12:4: Couldn't match `IO' against `[]'
20:19:09 <Lokadin> o
20:19:11 <Lokadin> i get ya
20:19:26 <Lokadin> i'm sorry i'm blind
20:19:33 <Lokadin> thanks sooo much!!! :D
20:19:43 <Lokadin> o my,!! i though it would never work1 :D
20:19:48 * Lokadin hugs Korollary 
20:20:58 <Lokadin> :D
20:27:09 <Cale> Lokadin: are things starting to make sense? :)
20:27:23 <Lokadin> Cale: :D slowly but surely!:D
20:36:01 <wchogg> I have a bit more theoretic of a question: if lists are just an example of a monad, then wouldn't binary trees be just a monad as well?  You can map between them, so it'd imply they should somehow be the same.
20:37:29 <Cale> yeah, they are a monad
20:37:50 <ricebowl> isn't that not necessarily true? They *can* be a monad
20:37:59 <Korollary> Yes, they can be
20:38:07 <Korollary> You are not forced heh
20:38:36 <Cale> well, Tree is a functor, and there exists a definition of return and join such that it's a monad
20:38:45 <Cale> say, data Tree a = Leaf a | Branch (Tree a) (Tree a)
20:38:53 <Cale> then return x = Leaf x
20:39:12 <wchogg> Okay.  That's pretty much what I thought.
20:39:18 <Korollary> for instance, I've never used >>= or return with Just. So I don't really care if it is or not. 
20:39:25 <wchogg> I just hadn't really thought of it that way before.
20:39:29 <Cale> and join (Leaf t) = t, join (Branch t1 t2) = Branch (join t1) (join t2)
20:40:43 <Cale> Korollary: you don't use the Maybe monad?
20:41:06 <Korollary> Cale: I haven't used it as a monad.
20:42:02 <Korollary> like the regexp matches
20:42:48 <Korollary> I use a case statement and that's about it
20:43:10 <Cale> It's sometimes really convenient that it's a monad
20:43:29 <Cale> you can almost always compress case statements down to something succinct
20:43:39 <Korollary> yeah, the example in the All About Monads tutorial was very cute.
20:45:29 <Cale> I really wish there was at least a switch I could use to turn on monad comprehensions.
20:53:38 <Cale> oh neat, the next GHC will have associated types
20:54:32 <ChilliX> the next?
20:54:38 <dons> 6.6?
20:54:47 <dons> ChilliX, get hacking!!
20:55:26 <ChilliX> dons: You are not seeing this from the right perspective.  If the next GHC has it, I don't have to do it anymore.  I'll just wait!!
20:55:28 <Cale> (read that on the wiki)
20:55:36 <dons> ah, very true.
20:55:36 <Cale> hehe
20:55:40 <dons> the wiki knows all!
20:55:52 <ChilliX> Cale: which page?
20:56:15 <Cale> The one so aptly named GHC 6.6
20:56:23 <ChilliX> ah, cheers
20:56:24 <Cale> http://www.haskell.org/hawiki/GHC_206_2e6
20:57:54 <dons> @pl \p -> notEdge p && isMp3 p
20:57:54 <lambdabot> liftM2 (&&) notEdge isMp3
20:57:57 <dons> heh
20:57:58 <eivuokko> Assosiated types means data declaration (or similar) allowed as part of class/instance declaration?
20:58:16 <Cale> eivuokko: yeah
20:58:45 <ChilliX> Aha, the guy who wrote the page, saw the branch in CVS
20:58:55 <eivuokko> Ok, cool.  Thanks.  I have hard time keeping up with all the terms :-(
20:59:07 <ChilliX> but that's not a complete implemnentation
20:59:17 <Cale> eivuokko: there's a neat paper or two on them
20:59:59 <eivuokko> Cale, yes, I bet there is... ;)  I can't read papers fast enough...
21:15:25 <dons> @seen juhp
21:15:25 <lambdabot> juhp is in #haskell. I don't know when juhp last spoke.
21:16:26 <juhp> hello
21:17:01 <juhp> dons: 
21:17:24 <dons> you were asking about filtering out non mp3 files?
22:03:23 <Lokadin> how many hexes in a byte?
22:03:58 <Lokadin> *runs arouond in confusion*
22:04:25 <juhp> dons: yeah - the first dir I tried had a mixture of files in it and it just started "playing" the first one
22:04:33 <juhp> which was an rpm or something ;)
22:05:00 <juhp> well I'm surprised mpg321 didn't just give up but anyway :)
22:06:10 <dons> hehe. ok. well I've added a filter now, so it'll only populate the playlist with files that normalise to 'mp3' under map toLower
22:06:40 <Cale> Aren't you using an external program to play the music anyway? Why not support ogg too?
22:06:56 <dons> requires a binding to another player
22:07:08 <dons> possible, but i dont' have much of an incentive yet
22:07:22 <Cale> oh, is mpg321 a library too?
22:07:45 <dons> binding == read/write over a pipe some text protocol
22:07:55 <Cale> ah, okay
22:08:04 <ChilliX> dons: I rip all my stuff as ogg!
22:08:23 <dons> yeah, I know. a few have mentioned this now.
22:08:51 <dons> so I should find a simple, cross-format player, and add that as a backend at some point
22:17:09 <Korollary> dons: You should also set up a database and let users rate songs, and implement ipod style smart-playlists using hsplugins ! ;)
22:18:20 <dons> hehe
22:20:01 <Korollary> I just can't find any podcasts worth listening to
23:42:16 <tic|school> Can I map data constructors on lists?
23:45:50 <gzl> tic|school: like map Just [1..10]? yeah.
23:49:14 <tic|school> gzl, yup, exactly. Nice!
23:49:24 <tic|school> then I don't have to write wrapper functions for that.
23:50:14 <gzl> they're just functions
23:52:10 <tic|school> *nod*
