00:01:14 <dons> ah ha! it does dump asm on linux. bad ghc!
00:01:32 <dons> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~Compiling Binary           ( ./Binary.hs, dist/build/hmp3/hmp3-tmp/Binary.o )
00:01:32 <xinming> > foldr (-) 3 [10,5,4,8]
00:01:33 <lambdabot> 4
00:02:09 <xinming> @help
00:02:09 <lambdabot>  @help <command> - ask for help for <command>
00:02:21 <xinming> @command
00:02:22 <lambdabot> Unknown command, try @listcommands.
00:02:23 <xinming> @commands
00:02:24 <lambdabot> Unknown command, try @listcommands.
00:02:28 <xinming> @listcommands
00:02:29 <lambdabot> use listcommands [module|command], please. Modules are:
00:02:29 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
00:02:29 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
00:02:29 <lambdabot> topic type version vixen where
00:08:31 <stefanw> dons: ghc6.4.1, linux 2.6.10-5-386
00:08:58 <dons> yeah, i spotted it. fixed now.
00:09:13 <dons> well, i didn't fix the ghc mangler, I just compile Binary.hs with -fasm ;)
00:09:38 <dons> looks like my binary IO code scares the mangler a little
00:09:47 <sieni> @help karma
00:09:48 <lambdabot> return a person's karma value
00:10:02 <sieni> @karma dons
00:10:03 <lambdabot> dons has a karma of 16
00:10:08 <sieni> @karma musasabi
00:10:09 <lambdabot> musasabi has a karma of 5
00:10:20 <machack666> @karma lambdabot
00:10:21 <lambdabot> lambdabot has a karma of 6
00:10:22 <dons> stefanw, so now you can hit 'w' and hmp3 will save the playlist into ~/.hmp3db
00:10:29 <machack666> lambdabot++
00:10:30 <machack666> @karma lambdabot
00:10:31 <lambdabot> lambdabot has a karma of 6
00:10:33 <dons> then future invocations will read the db to populate the playlist
00:10:42 <xinming> > foldr (-) 3 [10,5,4,8]
00:10:43 <lambdabot> 4
00:10:43 <stefanw> cool!
00:10:52 <xinming> hmm, anyone here can tell me why this is 4 not 2?
00:11:15 <xinming> (3- (10 - ( 5 - ( 4 - 8))))
00:11:37 <machack666> you've got the 3 in the wrong place
00:11:53 <machack666> it'd be (10 - (5 - (4 - (8 -3))))
00:12:17 <xinming> thanks
00:12:18 <machack666> 3 is the starting element for the operation, not necessarily the "first" in the list
00:12:26 <palomer> eh?
00:12:37 <palomer> I don't get that
00:12:46 <machack666> @type foldr
00:12:47 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
00:12:49 <palomer> (other than the parens are mismatched)
00:14:05 <machack666> @haddock foldr
00:14:06 <lambdabot> Unknown command, try @listcommands.
00:14:37 <machack666> @listcommands haddock
00:14:37 <lambdabot> haddock provides: index
00:15:48 <palomer> oh, righto, it was a reference to the foldr
00:16:13 <palomer> in foldl, the initial element would be the leftmost element, right?
00:16:20 <machack666> yes
00:16:41 <machack666> @type foldl
00:16:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:17:26 <TFK> Are there any libraries to work with bitmap files?
00:18:03 <stefanw> dons, compiles fine now
00:18:21 <dons> good.
00:18:31 <sieni> palomer: no
00:18:57 <stefanw> nice that my mp3 player now looks like my mail client ;-)
00:18:58 <palomer> it would still be the rightmost element?
00:18:58 <sieni> palomer: foldl is left-associative
00:19:11 <palomer> sieni: yes
00:19:39 <sieni> hmm..
00:19:40 <dons> stefanw, :)
00:19:40 <sieni> .
00:19:42 <palomer> so foldl (-) 0 [1,2,3] is (((0-1)-2)-3)
00:19:47 <palomer> hence 0 is the leftmost element
00:19:52 <dons> stefanw, is that with the new colours you provided?
00:20:02 <stefanw> yes
00:20:11 <machack666> > foldl (-) 0 [1..3]
00:20:12 <lambdabot> -6
00:20:22 <machack666> > foldr (-) 0 [1..3]
00:20:24 <lambdabot> 2
00:21:11 <sieni> lambdabot: ((((3-10)-5)-4)-8)
00:21:44 <sieni> oops, it was foldr
00:21:59 <sieni> > ((((3-10)-5)-4)-8)
00:22:00 <lambdabot> -24
00:22:34 <machack666> > (10-(5-(4-(8-3))))
00:22:35 <lambdabot> 4
00:22:57 <machack666> > foldr (-) 3 [10,5,4,8]
00:22:58 <lambdabot> 4
00:25:07 <machack666> > foldr1 (-) [10,5,4,8,3]
00:25:08 <lambdabot> 4
00:26:26 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..])
00:26:26 <lambdabot>  parse error on input `}'
00:26:39 <sieni> thanks a lot stupid mac os x
00:27:11 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))"441"
00:27:12 <lambdabot> True
00:27:18 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))"aa1""
00:27:18 <lambdabot>  lexical error in string/character literal
00:27:22 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))"aa1"
00:27:23 <lambdabot> True
00:27:27 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))"132""
00:27:28 <lambdabot>  lexical error in string/character literal
00:27:30 <sieni> oops
00:27:32 <sieni> > (\x->(length x)==(length$nub$zipWith(\y z->(y+z)`mod`(length x))(map((`mod`39).ord)x)[1..]))"132"
00:27:33 <lambdabot> False
00:29:33 <flux__> 50% accuracy?-)
01:17:26 <ski> hehe
01:17:32 <ski> morning #haskell
01:32:28 <ski> @voj voj
01:32:29 <lambdabot> My mind is making ashtrays in Dayton ...
01:43:51 <xinming> instance Class a => Class [a] where
01:44:01 <xinming> what does `Class a => Class [a]`
01:44:24 <xinming> mean
01:47:07 <luqui> xinming, it means that a has to satisfy Class before [a] can
01:47:19 <luqui> for instance, you could say "instance Ord a => Ord [a]"
01:47:31 <luqui> which means that, if a is an ordered thing, then an array of a's is too
01:47:41 <luqui> or, more englishy, any array of ordered things is ordered
01:47:53 <xinming> :-S
02:23:54 <ski> luqui : s/array/list/
02:40:53 <o_Rocky> someone can help me?
02:41:12 <o_Rocky> if i have a function  _ :: IO a
02:41:29 <o_Rocky> like main = ... main
02:42:47 <o_Rocky> if i put inside a function :: ... -> Io (StateT ...)
02:44:18 <o_Rocky> AAARRRGGG
02:44:27 <Lemmih> eh?
02:44:48 <o_Rocky> the stateT passes through the function main?
02:45:24 <o_Rocky> or the recursive call of function main destroys the StateT?
02:45:39 <o_Rocky> in each call
02:47:27 <o_Rocky> can somebody HELP!!!!
02:48:49 <o_Rocky> why i don't have a clue about how to program with monads?
02:48:51 <Lemmih> Asking the right question is half the battle.
02:50:34 <o_Rocky> Lemmih: do you want to make a Hello World interactive program with StateT Monad for me?
02:50:39 <o_Rocky> maybe you can teach me
02:51:55 <Lemmih> @type Control.Monad.State.evalStateT (do Control.Monad.Trans.liftIO (putStrLn "Hello world")) ()
02:51:56 <lambdabot> forall (m :: * -> *).
02:51:56 <lambdabot> (Monad m,
02:51:56 <lambdabot> Control.Monad.Trans.MonadIO (Control.Monad.State.StateT () m)) =>
02:51:56 <lambdabot> m ()
02:52:27 <o_Rocky> you call that interactive?
02:52:33 <o_Rocky> ok
02:52:34 <o_Rocky> ...
02:52:56 <Lemmih> @type Control.Monad.State.evalStateT (do Control.Monad.Trans.liftIO (getLine >>= putStrLn)) ()
02:52:57 <lambdabot> forall (m :: * -> *).
02:52:57 <lambdabot> (Monad m,
02:52:57 <lambdabot> Control.Monad.Trans.MonadIO (Control.Monad.State.StateT () m)) =>
02:52:57 <lambdabot> m ()
02:52:59 <Lemmih> (:
02:53:14 <o_Rocky> lol
02:53:32 <o_Rocky> i dont funking understand
02:54:01 <Lemmih> @type Control.Monad.State.evalStateT
02:54:01 <lambdabot> forall a (m :: * -> *) s.
02:54:01 <lambdabot> (Monad m) =>
02:54:01 <lambdabot> Control.Monad.State.StateT s m a -> s -> m a
02:54:34 <Lemmih> Are you familiar with 'evalStateT'?
02:55:07 <Lemmih> Why do you want to use the StateT monad, btw?
02:55:25 <o_Rocky> say no more!
02:55:45 <o_Rocky> i got it all figured out!
02:55:58 <o_Rocky> ahahahahahahahahaha
02:56:07 <o_Rocky> i'm going to quit!
02:56:10 <o_Rocky> ahahahahaha
02:58:54 <o_Rocky> i'm going out of my mind...
02:58:55 <o_Rocky> sorry
02:59:20 <o_Rocky> it's driving me nuts
03:02:58 <ski> @type Control.Monad.State.evalStateT (do l <- Control.Monad.Trans.liftIO getLine; Control.Monad.Trans.liftIO (putStrLn (reverse l))) () :: IO ()
03:02:59 <lambdabot> IO () :: IO ()
03:03:19 <ski> weird answer
03:03:24 <ski> @type (Control.Monad.State.evalStateT (do l <- Control.Monad.Trans.liftIO getLine; Control.Monad.Trans.liftIO (putStrLn (reverse l))) () :: IO ())
03:03:25 <lambdabot> IO ()
03:03:35 <ski> dons : wasn't that fixed ?
03:17:29 <Lemmih> shapr: ping.
03:26:53 <o_Rocky> pong
03:26:55 <o_Rocky> :P
03:27:15 <araujo> Good morning!
03:27:53 <o_Rocky> ...vietnam!
03:29:13 <ski> albatross
03:29:48 <ski> o_Rocky : what did you want to do with StateT and IO ?
03:30:33 <o_Rocky> i wanted to shoot them... with a bazooka :P
03:30:48 <ski> @index bazooka
03:30:49 <lambdabot> bzzt
03:31:10 <ski> @google bazooka monad
03:31:11 <lambdabot> http://www.fortunecity.com/tattooine/sputnik/53/patmills.htm
03:31:14 <o_Rocky> @google bazzoka
03:31:15 <lambdabot> http://www.bazzoka.com/
03:31:15 <ski> hm
03:32:34 <o_Rocky> http://xataka.com/archivos/2005/07/30-bazoca-aniquila-insectos.php
03:33:08 <ski> "... they were sent to stop the monad from the destroying earth in ABC warriors story 'Black Hole' (Prog 555-581) ..."
03:33:56 <ski> http://www.fortunecity.com/tattooine/sputnik/53/monad.gif
03:33:59 <ski> hehe
03:34:54 <ski> "Too late to intercept the fledgling Warlock, they were forced to battle the Monad, a creature of pure evil created during a previous visit to the era by Torquemada."
03:35:12 <o_Rocky> lol
03:35:14 <o_Rocky> :D
03:35:23 <o_Rocky> battle the 
03:35:27 <o_Rocky> Monad
03:38:06 <o_Rocky> @type Error
03:38:14 <lambdabot> Not in scope: data constructor `Error'
03:38:36 <o_Rocky> @type fail
03:38:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
03:39:17 <o_Rocky> :r
03:39:35 * basti_ is back
03:40:57 <ski> @index Error
03:40:57 <lambdabot> Control.Monad.Error, Graphics.Rendering.OpenGL.GLU.Errors, Graphics.
03:40:57 <lambdabot> Rendering.OpenGL.GLU, Graphics.Rendering.OpenGL, Graphics.UI.GLUT,
03:40:57 <lambdabot> Graphics.Rendering.OpenGL.GLU.Errors, Graphics.Rendering.OpenGL.GLU,
03:40:57 <lambdabot> Graphics.Rendering.OpenGL, Graphics.UI.GLUT
03:41:09 <ski> @index MonadError
03:41:09 <lambdabot> Control.Monad.Error
03:43:21 <kombinator> how do I do binary IO in haskell, e.g. read a 32bit le integer from a handle?
04:07:36 * kombinator realises that there is no good lightweigt method of doing binary IO in haskell
04:10:13 <kombinator> I would like to have binary IO that I could mix with text IO, for instance hGetChar :: Handle -> IO Char, hGetWord8 :: Handle -> IO Word8 etc., what do you think?
04:14:38 <xs> it's all just bytes? unless you're using windows.
04:15:43 <xs> you've seen http://haskell.org/hawiki/BinaryIo ?
04:18:35 <kombinator> xs: yes
04:19:03 <kombinator> I would also like to have hGetWord16 etc.
04:19:48 <kombinator> and binary IO using Char will probably break when support for unicode will be included
04:20:34 <dons> well, Binary.hs is pretty good.
04:20:56 <kombinator> is it in standard ghc?
04:21:24 <dons> No. But it has a long history back to nhc. that's what I use for all binary IO tasks.
04:21:49 <dons> that's the one found in NewBinary.
04:21:58 <soysauce> isn't Int# supposed to be as fast or faster than Int?
04:22:01 <dons> lambdabot uses this as well.
04:22:06 * soysauce is measuring the opposite
04:22:19 <dons> soysauc, Int# is an unboxed integer.
04:22:30 <soysauce> I know what it is
04:22:46 <soysauce> but my question was about performance
04:22:49 <eivuokko> I'd guess it is very likely that some code and expression moving optimisations don't work around unboxed values.
04:22:59 <soysauce> hm
04:23:05 <eivuokko> (Explicitly unboxed)
04:23:08 * soysauce goes and looks at the core, then
04:23:13 <soysauce> brb
04:24:45 <kombinator> by the way, do I have to mark network handles as binary as well when I don't want Windows to mess with line endings?
04:35:53 <soysauce> kombinator - Windows never messes with line endings, that's purely a function of the C runtime library
04:36:29 <chris2> is there a haskell port something like xduce/cduce?
04:36:50 <joelr1> howdy
04:39:02 <kombinator> soysause: maybe, but does it happen in network streams as well?
04:39:16 <soysauce> kombinator - those are just files, aren't they?
04:39:40 <soysauce> there are like 50 different wrappers that you typically go through. Which one are you working with?
04:40:16 <kombinator> import Network in GHC
04:41:00 <soysauce> then that depends on the implementation of that which I don't know
04:41:11 <soysauce> I thought you were the one *implementing* that or something
04:41:13 <kombinator> soysause: I'm confused because there is openBinaryFile, but there is no equvalent for connectTo
04:41:21 <soysauce> *nods*
04:41:35 <soysauce> well, you could always test
04:41:44 <soysauce> my suspicion is that there is no newline translation on sockets
04:41:58 <kombinator> soysauce: no, I just want to use mixed (text-binary) IO
04:42:04 <soysauce> *nods*
04:42:47 <kombinator> soysause: I don't have ghc windows installation;) I wanted to be portable just in case
04:43:43 <soysauce> well, I have never heard of newline translation on a socket, but it depends on how Network is implemented. The C stdio or C++ iostream modules perform the actual translation
04:44:05 <soysauce> it is possible, though awkward, to bind a FILE "object" to a socket
04:44:18 <soysauce> I can test it for you, I guess
04:44:23 <soysauce> since I have a Windows/GHC box
04:44:49 <soysauce> however, that's way over my head since I'm relatively new to Haskell
04:48:10 <soysauce> hum
04:48:19 <soysauce> I'm having difficulty figuring out how to coerce an Int into an Int#
04:58:26 <Lemmih> soysauce: data Int = I# Int#
04:59:12 <soysauce> oh, thanks, I see
05:00:01 <soysauce> another silly question, if you will. I'm having trouble using the profiler. It gives me "parse error in pattern" when I write this:
05:00:02 <soysauce> {-# SCC "traverse1" #-}
05:00:02 <soysauce> traverse1 n (x:xs) = if n == 0 then x else traverse1 (n-1) xs
05:00:52 <soysauce> or does that have to be right of the =?
05:03:04 <takuan_> lol
05:03:23 <takuan_> programming in C++ for the first time in a while and typed ":l source.cpp" at the command prompt
05:04:55 <Cale> hehe
05:11:50 <dons> soysauce, has to be to the left of the expr you wish to profile
05:11:55 <dons> i.e. to the right of the =
05:12:39 <dons> but -prof -auto-all should give you a cost center for any top level bindings anyway.
05:13:46 <soysauce> yeah, I see
05:13:50 <soysauce> I know
05:13:55 <soysauce> but I wanted to strip out everything except for 3 functions
05:14:00 <soysauce> which means inserting them by hand
05:29:18 <ricebowl> #type (+)
05:29:23 <ricebowl> er, oops
05:29:24 <ricebowl> @type (+)
05:29:25 <lambdabot> forall a. (Num a) => a -> a -> a
05:33:09 <jlouis> hey guys
05:43:40 <bringert> working on misspelling module: ["britney sopears","britney spears","britney spears","britney spears","britney spears","britney spehrs","britney spears","britney spears","britneyt spears","oritney spears","britney spears","britney spears","britney spears","britney spears","britney spears","britney spears","britney spears","britney spears","britney spears","britney spears"]
05:44:04 <bringert> example of course inspired by http://www.google.com/jobs/britney.html
05:44:50 <bringert> cranking up the error frequency: ["britney spiars","britney separs","brtnoey spears","britoney spears","britney spears","britney spears","britney rspears","britney speaars","britney spears","britney spbar","briney spears","brtiney spears","britey sears","britney spears","britney spearso","britney spemrs","britney spears","obritney spearsi","britney spears","brrtney spears"]
05:45:28 <bringert> what do you think, are these realistic errors?
05:47:47 <ricebowl> how do you get "spemrs" from "spears"? :p
05:47:54 <ricebowl> those are all the way across the keyboard from each other
05:50:43 <kombinator> dons: is there any documentation for NewBinary?
05:55:39 <bringert> ricebowl: yeah, I haven't taken keyboard proximity into acount yet
05:56:06 <bringert> guess that should be the next thing
06:10:05 <kolmodin> jlouis: hi
06:25:48 <jlouis> kolmodin: hello.
06:26:06 <jlouis> Did you guys actually know that kolmodin is an extremely cool Haskell hacker?
06:26:20 <kolmodin> :)
06:35:10 <jlouis> (And Conjure has been updated with a couple of patches by me and a couple by kolmodin ;)
06:56:41 <jlouis> hey TheHunter 
07:08:02 <TheHunter> hey jlouis 
07:40:31 <Lemmih> @seen shapr
07:40:32 <lambdabot> shapr is in #webwitches, #haskell and #haskell-blah. Last spoke 18 hours,
07:40:32 <lambdabot> 58 minutes and 35 seconds ago.
07:41:45 <jlouis> #haskell-blah ?
07:41:52 <jlouis> heh
07:44:00 <kolmodin> Lemmih: sharpr went away for 36 hours
07:45:06 <Lemmih> oh
07:45:33 <vegai> #webwitches?
08:00:15 <Axioplase> Hi
08:02:34 <Axioplase> hum... how can I easily get min and max from a list ?
08:02:51 <malcolm> @type minimum
08:02:51 <lambdabot> forall a. (Ord a) => [a] -> a
08:03:07 <malcolm> @type maximum
08:03:08 <lambdabot> forall a. (Ord a) => [a] -> a
08:03:12 <Axioplase> ok. and then maximun is here too I guess
08:03:15 <Axioplase> yep. thanks
08:04:53 <malcolm> btw, try http://haskell.org/hoogle if you are looking for functions you reckon ought to be already in a library somewhere
08:07:11 <Axioplase> oh *that* is great.
08:07:49 <ski> @hoogle [a] -> a
08:07:50 <lambdabot> Data.List.head :: [a] -> a
08:07:50 <lambdabot> Data.List.last :: [a] -> a
08:07:50 <lambdabot> Prelude.head :: [a] -> a
08:07:56 <ski> @hoogle+
08:07:56 <lambdabot> Prelude.last :: [a] -> a
08:07:56 <lambdabot> Data.List.maximum :: Ord a => [a] -> a
08:07:56 <lambdabot> Data.List.minimum :: Ord a => [a] -> a
08:08:10 <ski> @hoogle Ord a => [a] -> a
08:08:11 <lambdabot> Data.List.maximum :: Ord a => [a] -> a
08:08:11 <lambdabot> Data.List.minimum :: Ord a => [a] -> a
08:08:11 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
08:08:26 <ski> @hoogle maximum
08:08:26 <lambdabot> Data.List.maximum :: Ord a => [a] -> a
08:08:26 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
08:08:26 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
08:09:44 <eivuokko> Uhm.  Is "Setup.lhs: Cannot find: sh" from Cabal error or not?
08:10:52 <Lemmih> Sounds like Cabal tried to run 'sh configure'.
08:10:58 <eivuokko> Yes, I know
08:11:07 <eivuokko> But does it do everything else required?
08:11:27 <eivuokko> Lemmih, I am btw just doing Setup.lhs for your SDL bindings, for Windows
08:11:32 <Lemmih> 'sh'? No.
08:11:45 <Lemmih> Cool.
08:11:49 <eivuokko> Well, there simply isn't sh in Windows.
08:12:04 <eivuokko> It is very uncool to have that as last line of Setup.lhs configure
08:12:35 <eivuokko> Do you have repo somewhere?
08:12:36 <Lemmih> How do you detect sdl-config on windows then?
08:12:43 <eivuokko> Ehm
08:12:47 <eivuokko> Well, you don't
08:13:03 <Lemmih> oh
08:13:06 <eivuokko> And even if you used the one that comes with it, and have msys to have sh, it returns wrong results.
08:14:12 <eivuokko> Like -lmingw32 which goes in to a wrong place in final ld command ghc generates, which means it won't ever manage to link with that config
08:15:48 <Lemmih> How do you compile a SDL program on windows?
08:16:04 <eivuokko> Well, you usually download binary distro...
08:16:15 <eivuokko> I have no idea how it is compiled
08:16:52 * dcoutts uses "inno setup" for building windows installers
08:17:33 * eivuokko doesn't build executable setups for devel-stuff
08:17:42 <dcoutts> oh sure
08:18:31 <eivuokko> I just found out how to make Lemmih's sdl bindings work in Windows, using cabal hooks can be enough.  I don't even really use those bindings myself...
08:21:16 <eivuokko> Just one more thing...how to stop it from running configure if the poor user runs setup from msys..
08:22:49 <Lemmih> What should it do instead?
08:22:57 <eivuokko> Nothing
08:23:08 <eivuokko> I take care of doing neccesary stuff already ;)
08:23:11 <o_Rocky> Maybe a
08:23:38 <ski> @type Nothing
08:23:39 <lambdabot> forall a. Maybe a
08:23:58 <Lemmih> eivuokko: Change 'defaultMainWithHooks ...' to 'defaultMain'.
08:24:14 <eivuokko> Huh
08:24:16 <eivuokko> But I have hooks
08:24:31 <Lemmih> Then use 'emptyUserHooks' instead of 'defaultUserHooks'.
08:24:48 <eivuokko> Hmm
08:24:56 <eivuokko> Ah, I am getting hang of this
08:25:03 <eivuokko> Thanks, testing a bit more
08:25:34 <Lemmih> What SDL flags are you using?
08:25:47 <eivuokko> Erm.  That one makes "no local build info..."
08:25:54 <eivuokko> Hm, need to read CAbal source
08:25:57 <eivuokko> What flags?
08:26:00 <eivuokko> ;)
08:26:13 <eivuokko> What do you mean with SDL flags?
08:26:43 <Axioplase> is there a function to get last element of a list? or should I parse the list myself ?
08:26:54 <eivuokko> Axio, last.
08:27:03 <Lemmih> eivuokko: The configure script queries 'sdl-config' for vital library and C flags.
08:27:09 <ski> @type last
08:27:10 <lambdabot> forall a. [a] -> a
08:27:22 <ski> > last [0..9]
08:27:22 <eivuokko> Lemmih, that vital stuff is wrong for ghc linked code, in Windows!
08:27:23 <lambdabot> 9
08:27:35 <Axioplase> eivuokko: thanks
08:27:38 <joelr1> howdy
08:27:58 <ski> > map ((\xs -> (xs,last xs)) . tails) [0..9]
08:27:58 <lambdabot>  add an instance declaration for (Num [a])
08:27:58 <lambdabot>   In an arithmetic sequence: [0 .. 9]
08:28:07 <Lemmih> eivuokko: Really? I was talking about linking with the SDL library. How do you avoid that?
08:28:30 <eivuokko> Lemmih, in total from ld and cc options, there is like *one* right option for ghc and using dll
08:28:30 <ski> > map (\xs -> (xs,last xs)) . tails $ [0..9]
08:28:31 <lambdabot> Prelude.last: empty list
08:28:52 <ski> > map (\xs -> (xs,last xs)) . take 10 . tails $ [0..9]
08:28:53 <lambdabot> [([0,1,2,3,4,5,6,7,8,9],9),([1,2,3,4,5,6,7,8,9],9),([2,3,4,5,6,7,8,9],9),(
08:28:53 <lambdabot> [3,4,5,6,7,8,9],9),([4,5,6,7,8,9],9),([5,6,7,8,9],9),([6,7,8,9],9),([7,8,
08:28:53 <lambdabot> 9],9),([8,9],9),([9],9)]
08:29:36 <eivuokko> Lemmih, I am talking about the same thing, but it really, really, is fucked up, and I suspect it's not meant to be used.  script is even named sdl-config-whatever-ming32
08:43:14 <Axioplase> I'm sorry to ask this again, but how do I create the type that contains pairs of any kind of numbers ?
08:43:57 <ski> data Foo a = F a a
08:43:57 <ski> ?
08:44:00 <Philippa> (Num a) => (a,a), assuming you want both numbers to be of the same type
08:44:06 <ski> with instance Num a => Num (Foo a)
08:44:23 <eivuokko> Lemmih, so do you have a repo, or should I just send my Setup.lhs to you?
08:44:34 <Philippa> ski: have you looked ahead to see further requirements here? :-)
08:45:03 <Lemmih> eivuokko: darcs repo: http://scannedinavian.com/~lemmih/SDLhead
08:45:05 <ski> Philippa : further requirements ?       :)
08:45:27 <Philippa> "I wanna treat this pair as a 2D vector" or similar
08:45:43 <Lemmih> eivuokko: Does it work?
08:46:52 * ski interpreted Philippa's comment as that he hadn't done it
08:47:08 <eivuokko> Lemmih, I tested it with two installation schemes.  I am fairly sure it works.
08:48:42 <o_Rocky> @mplus
08:48:42 <lambdabot> <stdin>: hGetLine: end of file
08:48:57 <o_Rocky> @type mplus
08:48:57 <lambdabot> Not in scope: `mplus'
08:49:00 <Lemmih> eivuokko: Did you test the binding in GHCi?
08:49:17 <o_Rocky> @type Control.Monad.State.mplus
08:49:18 <lambdabot> forall (m :: * -> *) a.
08:49:18 <lambdabot> (Control.Monad.MonadPlus m) =>
08:49:18 <lambdabot> m a -> m a -> m a
08:49:40 <eivuokko> Lemmih, nope.  My only test program was the Test.hs sdl-0.2.0 came with, and I have to remove bitmap loading
08:49:53 <o_Rocky> can anyon explain-me what does mplus?
08:50:15 <o_Rocky> explain me
08:50:36 <eivuokko> Lemmih, I am not sure...how do I get ghci to load dll's...no idea.
08:51:23 <Lemmih> o_Rocky: It returns the second argument if the first is mzero.
08:51:35 <o_Rocky> uhmmm
08:51:53 <o_Rocky> that's good for backtracking rigth?
08:52:10 <ski> yes
08:52:16 <Axioplase> ski: and then, how do I create a type of pairs of Foo I just created ?
08:53:59 <eivuokko> Uhm, man, this is so diffrent from SDL-0.2.0.
08:54:56 <kombinator> dons, xs: I've just included my comment on http://haskell.org/hawiki/BinaryIo , please take a look a it
08:55:36 <ski> Axioplase : sorry ? do you mean how to create a value of that type ?
08:56:09 <Axioplase> ski: yes.
08:56:30 <Axioplase> ski: to be precise, I want a type Plot of two numbers, and then a type Vector of two plots.
08:56:38 <ski> e.g.  'F 12 8' would be such a value
08:57:18 <ski> and, you don't want to commit to the specific kind of number ? (i.e. Int, Integer, Double, Rational,  ...)
08:57:29 <Axioplase> yep.
08:57:46 <chris2> i'm really new to haskell, but why not  data Foo = F Num Num  ?
08:58:18 <Axioplase> chris2: damn, I see you on every chan dealing with programming languages :)
08:58:21 <basti_> chris2: "Num" isn't a datatype
08:59:15 <eivuokko> Lemmih, In windows there is only one SDL.dll..is it diffrent in nixes or why diffrent setups?
08:59:39 <chris2> basti_: hmm, i wrote code like data Term = TmVar Integer Integer | TmAbs Term Term today, and nothing complained
08:59:59 <basti_> chris2: yes, but Num isn't a type, like Integer is
09:00:06 <chris2> ah, i see. thanks ;)
09:00:12 <chris2> Axioplase: i'm very curious =)
09:00:18 <basti_> chris2: it is a "class"
09:00:23 * basti_ plays a minor chord
09:00:33 <chris2> yeah, i need to dig deeper into that stuff
09:00:52 <basti_> its not that hard
09:01:06 <chris2> sure, you just need to find a good explanation
09:01:07 <basti_> classes work like "constraints"
09:01:17 <basti_> ^^
09:03:45 <qwerty-> hello guys, when defining a new type with data, is it possible to have a Constructor with the same name as the Typename? for example "data Something a = Something [a] | Somethingelse"
09:03:50 <chris2> so Integer is an instance of Num?
09:04:02 <basti_> chris2: yes
09:04:12 <basti_> qwerty-: yes.
09:04:13 <eivuokko> Lemmih, uhm, right, well..mixer doesn't have binary distro for mingw..dunno about others...annoyance.
09:04:14 <jlouis> qwerty-: yes
09:04:23 * basti_ .o° ( haskell is such a positive language )
09:04:31 <chris2> basti_: i'll consider the classes as traits then ;)
09:05:09 <basti_> yes
09:05:11 <qwerty-> ah thanks guys, i was confused by that because of the ability to recursively define a type 
09:05:12 <basti_> good idea
09:05:31 <basti_> qwerty-: you might observe that the both uses never collide.
09:05:50 <qwerty-> yes, because infix constructors begin with : , right?
09:05:57 <basti_> uhm
09:05:57 <basti_> no.
09:06:00 <basti_> wtf? ;)
09:06:02 <qwerty-> i mean
09:06:12 <qwerty-> type Command = Command :# Command
09:06:18 * basti_ .o° ( where did that come from? )
09:06:23 <qwerty-> the 2nd Command word is a typename
09:06:23 <basti_> uhh
09:06:27 <qwerty-> not a constructor
09:06:28 <qwerty-> right?
09:06:31 <basti_> no
09:06:43 <qwerty-> ok NOW i'm confused
09:06:53 <Cale> :# is the constructor there
09:07:04 <qwerty-> yes
09:07:08 <Cale> er, and you mean data, not type
09:07:17 <qwerty-> err yeah sorry
09:07:18 <basti_> yes
09:07:21 * basti_ nodnods
09:07:32 <basti_> i was referring to something else
09:07:44 <basti_> the "type" and the "constructor" words never collide
09:07:45 <qwerty-> data Command = Command :# Command <- the underlined part is a type name right?
09:07:51 <basti_> they're always in seperate contexts
09:09:10 <qwerty-> so the answer to my last question is "yes" ?
09:09:21 <basti_> uhm
09:09:23 <Lemmih> eivuokko: On a Linux box you can have many different versions of SDL installed at many different places.
09:09:34 <basti_> uhm
09:09:35 <basti_> no
09:09:47 <basti_> argh
09:09:53 <qwerty-> was that "no" for me? :)
09:10:01 <basti_> im thinking what this is
09:10:27 <basti_> i think thats both type "Command"
09:10:28 <eivuokko> Lemmih, I didn't mean that.  Obviously that is possible in Windows as well.  I meant that only Core has working minw32-port available.
09:10:31 <basti_> constructor is ":#"
09:10:43 <qwerty-> right, that's what i thought
09:11:01 <ski> that both uses never collide have nothing to do with how you make infix constructors
09:11:07 <basti_> yes
09:11:07 <Cale> underlined?
09:11:13 <basti_> we were talking about seperate stuff
09:11:16 <qwerty-> however in "data Command a = Command [a] | Blah", the 2nd "Command" is a constructor, right?
09:11:27 <basti_> yup
09:12:14 <qwerty-> ok... is it me or should the people who use constructor names which are the same as the type name be shot? :)
09:12:26 <basti_> hmm
09:12:29 <basti_> no not necissairly
09:12:30 <Cale> no, it's actually common to do that
09:12:43 <basti_> because the two uses can never be confused
09:13:01 <Cale> They're in completely separate namespaces
09:13:03 <basti_> in type statements, the word is a type thing, and in data statements, the word is a Constructor
09:13:07 <qwerty-> yeah i've noticed, our teachers do that a lot
09:13:16 <astrolabe> except by people :)
09:13:21 <basti_> ^^
09:13:31 <qwerty-> and it's all well if you know these things well, but i think for newbies it can be confusing
09:13:58 <qwerty-> <- newbie
09:14:04 <Cale> yeah, it can be
09:14:23 <Cale> The important thing to note is that there always has to be a data constructor there
09:14:32 <Cale> if it's not infix, then it will be the first thing
09:14:33 <qwerty-> right
09:14:36 * basti_ gives qwerty- a haskell n00b pak with a lambda sticker, a matching tie pin and a cute paper hat
09:14:37 <qwerty-> gotcha
09:14:39 * ski seldom use same name for a type and for a constructor
09:15:06 <qwerty-> thanks a lot for the clarification :)
09:15:16 <Cale> newtype State s a = State { runState :: s -> (a,s) }
09:15:27 <SamB> basti_: type constructor names and data constructor names cannot never be confused
09:15:43 <basti_> SamB: where can they?
09:15:45 <SamB> basti_: never underestimate the ability of a newbie to be confused!
09:15:50 <basti_> >.<
09:15:51 <qwerty-> Cale you lost me on that i'm afraid
09:15:58 <basti_> they cannot be confused by the compiler
09:16:08 <SamB> yeah, thats true enough.
09:16:37 <Cale> Just an example from the libraries where the data and type constructor's names are the same
09:16:46 <SamB> I seem to rembember being a bit confused by that once upon a time, though...
09:17:05 <qwerty-> oh i see that, i just don't know what "newtype" is
09:17:12 <qwerty-> and also what the { } and :: are doing there :)
09:17:19 <SamB> qwerty-: its almost the same as data
09:17:29 <qwerty-> i see
09:17:33 <SamB> and thats record notation
09:18:41 <SamB> newtype differs from data in that it may only have one constructor, which in turn can only have one field
09:19:13 <SamB> and the representation of that type is the same as the representation of the field
09:19:16 <qwerty-> i see
09:20:13 <SamB> basicly the point of using record notation there is that you don't need to then go and define runState on the next line
09:20:32 <SamB> the written-out version of runState would be
09:21:03 <SamB> runState :: State s a -> s -> (a,s)
09:21:15 <qwerty-> aha
09:21:17 <SamB> runState (State f) = f
09:22:15 <qwerty-> hmm that last one confused me... is it a partial application example?
09:22:36 <SamB> hmm, lets see...
09:22:42 <SamB> look at the type like this:
09:22:44 <qwerty-> runState seems to take two params
09:22:54 <ski> runState :: State s a -> (s -> (a,s))
09:22:54 <SamB> runState :: State s a -> (s -> (a,s))
09:23:02 <SamB> hehe
09:23:08 <qwerty-> ahh
09:23:26 <ski> it takes this state-record, and extracts the function that resides in it's sole field, returning that
09:23:31 <SamB> they are the same type, and yes you could say it was an example of partial application.
09:23:43 <ski> if you really wanted to, you could write this as
09:23:47 <Axioplase> How does instance work? I really don't understand it's meaning nor use..
09:23:49 <ski> runState (State f) s = f s
09:24:07 <qwerty-> i think i get it :)
09:24:40 <SamB> it certainly is an example of partial application
09:24:51 <ski> Axioplase : e.g., when you define a new type, you can say how you want things like (==) and (>) and (+) to work over it, using instance declarations for the appropriate type classes
09:24:56 <SamB> its also an example of how Haskell programmers take partial application for granted ;-)
09:25:06 <qwerty-> hehe 
09:26:08 <Axioplase> ski: then I can't do instance Num a => Num (Point a); data Point a = P a a; since there is no order on |R² ...
09:33:53 <Axioplase> well anyway. How do I print an own defined type/data ?
09:34:24 <ski> you define an instance of Show
09:34:28 <ski> that's the standard solution
09:34:36 <Axioplase> I wish I knew how.
09:34:51 <ski> (you can of course create other custom functions, giving back a String)
09:35:55 <Cale> try adding "deriving Show" on the end of your data declaration
09:36:06 <Cale> that'll give you something simple to start with
09:36:23 <Cale> if you want to get fancy, you'll have to define an instance of the Show class yourself
09:36:26 <Axioplase> Cale: oh greate. thanks. That will be enough.
09:36:53 <qwerty-> instance Show a => Show Point a
09:36:53 <qwerty->   show P a a = "(" ++ show a ++ "," ++ show a ++ ")" 
09:36:56 <qwerty-> would that work?
09:37:13 <qwerty-> (kinda practising here, testing what i know)
09:38:14 <qwerty-> the objective is that show (P 1 2) prints (1,2)
09:38:33 <eivuokko> Basically, looks right, missing where-keyword and pattern match needs braces.
09:38:39 <qwerty-> ah
09:38:48 <qwerty-> right
09:38:53 <Cale> parens
09:39:02 <Cale> rather than braces
09:39:08 <eivuokko> Hmmm.
09:39:14 <qwerty-> yup, got it
09:39:21 <eivuokko> Ah, well.  Always so confusing.
09:41:02 <Cale> also parens around (Point a)
09:41:24 <qwerty-> ah i was about to ask that 
09:42:09 <Cale> they're needed because typeclasses can have multiple parameters
09:43:12 <qwerty-> so Show Point a (without parens) would be like defining an instance for Point and an instance for a?
09:43:21 <Axioplase> so, what would it look like eventually ?
09:43:32 <Cale> no, just one instance, but Show would have to take two type parameters
09:43:37 <qwerty-> instance Show a => Show (Point a) where
09:43:37 <qwerty->   show (P a a) = "(" ++ show a ++ "," ++ show a ++ ")" 
09:43:47 <Cale> yeah, that looks good
09:43:48 <qwerty-> oh
09:44:04 <Cale> classes can relate types to one another
09:44:33 <chris2> does that work? it fails here
09:44:55 <Cale> oh, perhaps some parens around the shows
09:45:02 <chris2>     Kind error: `Foo' is applied to too many type arguments
09:45:03 <chris2>     When checking kinds in `Foo a'
09:45:04 <Cale> show (P a a) = "(" ++ (show a) ++ "," ++ (show a) ++ ")" 
09:45:11 <chris2> Foo is my Point
09:45:15 <qwerty-> hmm
09:45:39 <qwerty-> show a shouldn't need () since function application binds more tightly than operators right?
09:45:42 <chris2> aah
09:45:45 <qwerty-> or so i've been told
09:45:50 <chris2> dont use a twice, i think
09:45:55 <chris2> Point z works here
09:45:58 <Cale> oh
09:46:02 <Cale> dumb :)
09:46:06 <eivuokko> heh
09:46:06 <chris2> nasty
09:46:08 <Cale> show (P a b) = "(" ++ (show a) ++ "," ++ (show b) ++ ")" 
09:46:14 <Cale> yeah
09:46:17 <Cale> I was noticing that too
09:46:47 <chris2> hrm
09:46:49 <qwerty-> hmm
09:46:57 <qwerty-> why different types?
09:47:00 <Cale> and you don't need the extra parens
09:47:06 <Cale> different types?
09:47:11 <Cale> no, just different values
09:47:21 <qwerty-> doh!
09:47:29 <qwerty-> i'm stupid
09:47:56 <Cale> well, we all missed it -- ghc is pretty clear enough about what needs to be done though
09:48:07 <qwerty-> it is, isn't it
09:48:15 <qwerty-> i like that a lot
09:50:32 <chris2> instance Show a => Show (Point a) where show (Point i1 i2) = (show i1) ++ "/" ++ (show i2)  still doesnt work for me...
09:50:58 <Cale> what's your data declaration look like?
09:51:16 <chris2> data Point = Point Integer Integer deriving Show
09:51:27 <takuan_> are arrays really faster then dealing with lists?
09:51:37 <chris2>     Kind error: `Point' is applied to too many type arguments it says
09:51:49 <Cale> chris2: instance Show Point where ..
09:51:57 <Cale> your Point type isn't parametrised
09:52:04 <Cale> takuan: for some things
09:52:06 <SamB> takuan: it depends very much on what you are using them for and how you use arrays to replace lists
09:52:06 <chris2> aah
09:52:22 <SamB> also, there are many kinds of arrays these days
09:52:28 <Cale> takuan: You should use arrays when you want random access
09:52:30 <takuan> SamB: well, i'm dealing with an iterative algorithm
09:52:40 <takuan> it's not that random
09:52:49 <chris2> and then drop the deriving line?
09:52:50 <Cale> If you only want sequential access, generally use lists.
09:52:52 <Axioplase> eh? can't I write p=-1.0  when p is a Double ?
09:52:54 <SamB> takuan: what sort of algorithm?
09:52:58 <Cale> also, arrays are fixed size, usually
09:53:10 <takuan> SamB: simple 2d diffusionequation solver
09:53:28 <Axioplase> Oh got it. parens problem
09:53:47 <Cale> Axioplase: spacing
09:53:50 <Cale> p = -1.0
09:53:50 <SamB> takuan: does that involve calculating a whole new array from every old one?
09:54:05 <Cale> p=-1.0 parses as p =- 1.0
09:54:06 <takuan> well SamB, we'd rather not do that ;)
09:54:17 <takuan> that's how it's implemented right now
09:54:19 <qwerty-> p= -1.0 works too but i'd stick with two spaces
09:54:28 <takuan> and it's rather unefficient as you could guess
09:54:35 <SamB> I mean, if you did it in C, would you be updating in-place or would you use two arrays?
09:54:45 <Cale> which is an expression where you probably want a declaration, so you'll get a syntax error
09:54:46 <takuan> we'dd update in place
09:54:53 <SamB> anyway, you should try switching to unboxed arrays before you try changing algorithms...
09:54:56 <takuan> it makes the algorithm faster and easier
09:55:19 <SamB> then after that you could try STUArrays
09:55:22 <Cale> perhaps try a diff array, if not a full out mutable array
09:55:38 <takuan> well, the emphasis is mainly on ease of writing
09:55:42 <takuan> not so much speed
09:55:46 <SamB> oh
09:55:56 <Cale> then try the Diff array first certainly
09:56:00 <SamB> I thought you had already written it
09:56:10 <SamB> DiffUArrays probably would work best
09:56:11 <takuan> i wrote it using lists of lists SamB 
09:56:14 <SamB> takuan: oh
09:56:30 <SamB> well, yeah, then go ahead and try DiffUArrays
09:56:38 <takuan> it's not that difficult but i'm trying to do it as "nicely" as possible
09:56:45 <Cale> once you are using one immutable array type, they're all swappable for one another
09:56:56 <takuan> where do i find the beast?
09:57:03 <SamB> @index DiffUArrays
09:57:03 <lambdabot> bzzt
09:57:06 <SamB> @index DiffUArray
09:57:07 <lambdabot> Data.Array.Diff
09:57:07 <Cale> Diff arrays have an immutable interface, but they do some tricks :)
09:57:16 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
09:57:21 <Cale> ignore most of what's there
09:57:23 <takuan> kay
09:57:25 <SamB> Cale: use the lambdabot
09:57:27 <Cale> all you need is the type
09:57:30 <SamB> @doc Data.Array.Diff
09:57:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
09:57:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
09:57:46 <Cale> that has all the functions you'll want
09:57:51 <Cale> (IArray)
09:58:13 <Cale> the other stuff in Data.Array.Diff is the low-level interface, which you shouldn't need
09:58:54 <SamB> @type Data.Array.newArray
09:58:55 <lambdabot> Not in scope: `Data.Array.newArray'
09:58:57 <Cale> basically, Diff arrays are used the same way as ordinary haskell Arrays, but you change the type
09:58:59 <SamB> @type Data.Array.array
09:59:00 <lambdabot> forall e i.
09:59:00 <lambdabot> (GHC.Arr.Ix i) =>
09:59:00 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
09:59:14 <SamB> @type Data.Array.IArray.array
09:59:15 <lambdabot> forall e i (a :: * -> * -> *).
09:59:15 <lambdabot> (GHC.Arr.Ix i, Data.Array.Base.IArray a e) =>
09:59:15 <lambdabot> (i, i) -> [(i, e)] -> a i e
09:59:37 * SamB wonders why Data.Array uses the old Array interface
09:59:50 <Cale> Data.Array is outdated
09:59:58 <SamB> yeah. but why isn't it updated?
10:00:05 <SamB> its not like its in the standard or anything!
10:00:09 <takuan> mkay, thanks for the info
10:00:10 <Cale> Well, it should really be removed
10:00:13 <takuan> let's have a look
10:00:36 <Cale> takuan: Diff arrays are cool in that a // xs is still O(length xs)
10:00:45 <Cale> but they're referentially transparent
10:00:52 <SamB> I think it ought to export some stuff from Data.Array.*
10:01:19 <Cale> yeah, it probably should just reexport the IArray and MArray interfaces
10:01:22 <SamB> well, as long as you use single-threaded updates
10:01:25 <Cale> yes
10:01:36 <SamB> Cale: even just the IArray interface
10:01:49 <Cale> the evaluation of a // xs makes accesses to 'a' slower by a little bit
10:02:29 <Cale> but this is a pretty good deal, because normally with a mutable array, you wouldn't have 'a' anymore at all.
10:02:30 <takuan> mm
10:02:34 <takuan> what do I import?
10:02:44 * SamB wonders what happens to a if you then do a // []
10:02:47 <Cale> import Data.Array.Diff
10:02:52 <takuan> thanks
10:03:15 <Cale> a // [] will have the property that accesses to all its elements are fast
10:03:58 <Cale> Updating an array which isn't current makes a physical copy
10:04:10 <SamB> my Z-machine emulator uses DiffUArray for its memory, for easy implementation of undo, as well as efficient update
10:04:26 <SamB> I don't think I've actually implemented undo yet though
10:04:42 <Cale> ah, cool, yeah, that would make things easy :)
10:05:07 <SamB> doesn't seem like there is much point in it until after I implement decent IO
10:06:37 <Cale> have you thought of perhaps modifying yi into a frontend?
10:06:55 <SamB> yeah.
10:07:01 <SamB> but I have no idea how to do that
10:07:36 <Cale> dons could likely show you how -- he wrote an mp3 player which uses the yi code
10:08:17 <SamB> anyway, it just occurred to me the other day that using a seperate thread for IO would allow me to keep the rest of my code free from dealing with IO-related state
10:08:42 <SamB> hmm. and then I could have mysterious crashes!
10:09:00 <qwerty-> btw, is there an IDE for haskell? and what does one need to write GUI apps for Windows?
10:09:16 * SamB pulls latest hmp3 patches in hopes that dons fixed that
10:09:21 <Cale> There's going to eventually be hIDE
10:09:38 <qwerty-> beta yet?
10:09:46 <Cale> of which yi, a Haskell-extensible text editor is a major component
10:10:00 <Cale> there's a beta of yi, hIDE is alpha, I suppose
10:10:06 <Cale> it's not really usable
10:10:16 <Cale> at least, last time I tried it
10:10:28 <qwerty-> i see... so how do people do GUI apps so far?
10:10:31 <Cale> though there are some awesome screenshots :)
10:10:38 <Cale> Gtk2Hs is nice
10:10:44 <Cale> and WxHaskell
10:11:04 <Cale> there's also, I think, bindings to the Win32 API, if you're on windows
10:11:27 <Cale> And Xlib, if you're using X
10:11:40 <Cale> (though I wouldn't recommend that for anything but the simplest apps)
10:11:46 <SamB> he said windows ;-)
10:11:53 <qwerty-> mm i see
10:12:12 <qwerty-> that's alright, i wanted this info anyway :)
10:12:13 <qwerty-> thanks
10:12:30 <SamB> but yeah, you don't really want to use Xlib directly...
10:12:40 <Cale> I really like gtk2hs, not sure how well it works out on windows though
10:12:49 <Cale> being able to design your gui in glade is nice
10:13:18 <Cale> http://glade.gnome.org/screenshots.html -- glade screenshot, if you're unfamiliar
10:13:47 * SamB doesn't like glade very much
10:13:51 <Cale> no?
10:14:12 <SamB> it seems difficult to get things layed out nicely
10:14:21 <Cale> I think it's pretty cool. It's not perfect -- sort of backwards from how an ideal GUI design process would go, but it's okay
10:14:33 <Cale> Not that difficult once you're used to it
10:14:53 <Cale> have to play around with the various layout boxes
10:15:28 <SamB> maybe it just needs a decent tutorial or something...
10:15:50 <qwerty-> doesn't look bad indeed, i'll keep it in mind
10:17:09 <takuan> is there a show for these arrays?
10:17:34 <Cale> I think they ought to be showable... let me check
10:18:15 <Cale> yeah, they are
10:18:20 <takuan> mmm
10:18:20 <takuan> strange
10:18:21 <Cale> so long as their elements are
10:18:31 <takuan> if I do  listArray (1,10) [1,2,3,4,5,6,7,8,9,10]
10:18:47 <takuan> it says   No instance for (Show (a i e))
10:18:57 <Cale> listArray (1,10) [1..10] :: DiffUArray Int Int
10:19:01 <takuan> ah
10:19:04 <takuan> it needs a type
10:19:04 <Cale> give it a concrete type
10:19:06 <Cale> yeah
10:19:14 <Cale> listArray is polymorphic
10:19:19 <takuan> mkay
10:22:02 <Cale> hm, DiffUArrays don't throw exceptions when you access an undefined element.
10:23:06 <Cale> probably for speed
10:23:57 <Axioplase> How can I create a circular list from an exising list ?
10:24:05 <Cale> Axioplase: cycle
10:24:11 <Axioplase> ok thanks
10:24:25 <Cale> ah, of course, they're unboxed, so there's not much else it could do :)
10:25:02 <Cale> > take 20 $ cycle [1,2,3]
10:25:03 <lambdabot> [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2]
10:26:21 <Axioplase> and, to remove dups in a list ?
10:26:33 <basti_> thats O(n^2)
10:26:35 <Cale> > nub [1,1,2,3,2,1]
10:26:35 <basti_> ^^
10:26:36 <lambdabot> [1,2,3]
10:26:46 <Axioplase> thanks
10:27:17 <ski> > take 20 $ nub $ cycle [1,2,3]
10:27:21 <Cale> if you don't care about ordering, it might be better to use a Set, or to use map head . group . sort
10:27:21 <lambdabot> Terminated
10:27:31 <Axioplase> I care about it
10:27:41 <Cale> > nub $ take 20 $ cycle [1,2,3]
10:27:42 <lambdabot> [1,2,3]
10:28:08 * ski wonders if it'd be hard to make lambdabot print '[1,2,3,'
10:28:19 <basti_> > nub $ cycle [1,2,3]
10:28:20 <basti_> :D
10:28:24 <lambdabot> Terminated
10:28:29 <Axioplase> hum...  Not in scope: `nub'
10:28:35 <Cale> import List
10:28:36 <basti_> @index nub
10:28:36 <lambdabot> Data.List
10:28:41 <ski> import Data.List (nub)
10:28:51 <Axioplase> ha thks.
10:28:53 <takuan> Cale: can you show me some typical array code?
10:29:02 <takuan> that is functions with types and stuff
10:30:00 <kombinator> @eval let zonk = zonk in [1, 2, 3, zonk]
10:30:01 <lambdabot> Loop
10:30:50 <Cale> hmm, it would look like most other haskell code, only you use ! to get a value out of the array, and // to modify elements
10:31:01 <Cale> those are the two most common operations
10:31:10 <Cale> I don't have much array code handy
10:31:33 <Axioplase> hum... how do I  add an instance declaration for (Eq Foo) ?
10:31:49 <Cale> instance Eq Foo where x == y = ...
10:32:00 <Axioplase> thanks
10:32:02 <ski> did you have  data Foo a = F a a ?
10:32:12 <Axioplase> ski: yes roughly
10:32:37 <Axioplase> I just named the parameters though
10:32:39 <Cale> it might be quickest to just use deriving Eq
10:32:56 <Cale> if your type is parametric like that, then you'll need something like
10:33:05 <Cale> instance (Eq a) => Eq (Foo a) where
10:33:12 <Lemmih> Why not use a tuple?
10:33:53 <Cale> Lemmih: perhaps less type information?
10:34:17 <ski> (and maybe not Haskell98)
10:34:27 <Axioplase> Lemmih: beacause I didn't feel like writing scheme.
10:34:35 <Lemmih> Ah yes. The informative name 'Foo' is much better (:
10:34:52 <Cale> I'm assuming here that his actual type isn't called that :)
10:35:24 <Cale> at least, in actual code
10:37:13 <Axioplase> Of course not. Using more than one char for a constructor or a var/function name is a loss of time.
10:37:44 <Axioplase> (joking, eh)
10:38:56 <Axioplase> so, How do I then derive from two or more things?
10:39:30 <ski> sorry ?
10:39:53 <Axioplase> well, my data is deriving from Show. but one tells me to derive from Eq too.
10:39:57 <ski> ah
10:40:02 <ski> deriving (Show,Eq)
10:41:30 <Axioplase> thx
10:47:43 <kombinator> xs_: I've added my comment to http://haskell.org/hawiki/BinaryIo
10:48:17 <takuan> what the heck is a monomorphism?
10:49:16 <jlouis> takuan: it is a special arrow in Category theory IIRC
10:50:20 <franka> It's the categorical equivalent of an injection.
10:50:25 <jlouis> http://mathworld.wolfram.com/Monomorphism.html
10:50:57 <jlouis> franka: exactly ;)
10:51:27 <ski> hm .. monomorphism .. polymorphism ..
10:52:10 <franka> Yeah, but the dual of a monomorphism is an epimorphism, not a polymorphism. :)
10:52:22 <SamB> epimorphism?
10:52:34 <franka> A categorical surjection.
10:52:41 <jlouis> http://mathworld.wolfram.com/Epimorphism.html
10:52:46 <ski> also known as epi or epic
10:52:53 <franka> i.e., an onto arrow
10:53:26 <SamB> are you trying to break my head or something?
10:53:28 <ski> (hm, doen't onto/surj often more correspond to split epic, or something like that ?)
10:53:41 <franka> Yes, split epi is the preferred form.
10:53:43 * chris2 loves such stuff :P
10:53:55 <franka> But in category theory the weaker forms can be important too.
10:54:15 <franka> In the category of sets, every epi is split.
10:54:23 <franka> If you assume the Axiom of Choice.
10:54:57 <franka> Actually there is a great theorem which says that Choice is equivalent to all epis splitting.
10:55:30 * ski seems to remember something about that
10:56:39 <ski> ACC talks about strong and strict and swell and split and extremal epis (and monos) (and one more i don't remember)
10:56:50 <ski> (not that i remember definitions of most of those :)
10:56:56 <jlouis> franka: oh, cool theorem
10:57:13 <ski> (ACC = Abstract and Concrete Categories .. avail. online, now)
11:00:43 <basti_> :-o
11:01:11 <basti_> now whats a "split" morphism
11:01:39 <franka> One that is part of a retraction.
11:02:46 <franka> For example there is a retraction of the naturals from the integers.
11:03:00 <basti_> hmm
11:03:03 <franka> You can embed the naturals in the integers: that's a mono.
11:03:08 <ski> split_epi r <=> exists s. r o s = id
11:03:35 <basti_> phew
11:04:08 <basti_> but i believe that this is equivalent to choice
11:04:23 <franka> See above, basti_.
11:04:36 <basti_> franka: i mean, now that i see the definition, I can see the connection
11:04:41 <jlouis> ski: wheer, if one shall be pedantic, r must be epi
11:05:07 <basti_> now why is this called "split"?
11:05:10 <ski> jlouis : hm .. thought that was implied
11:05:27 <jlouis> ski: heh, more or less. 
11:05:30 * ski is too tired to verify whether that is the case
11:06:14 <franka> Because if you compose them in one direction you get an identity, and in the other you get an idempotent.
11:06:29 <franka> The idempotent "splits" into a mono and an epi.
11:06:49 <basti_> ahh
11:06:52 <basti_> wow
11:07:02 <jlouis> idempotent: x^2 = x
11:07:12 <jlouis> right?
11:07:28 <franka> Yes.
11:07:38 <franka> If x^2 means x composed with x.
11:07:48 <jlouis> yup
11:08:25 <jlouis> I fail to see how it is a split. r o s = id, and s o r is idempotent
11:08:39 <ski> wasn't it also something about a general morphism somewhere (from A to B if A is a retract of B ?) being splittable into this epi and some other morphism ?
11:08:40 <basti_> idempotent => (s,r)
11:08:55 <Cale> "monomorphism" used in the sense of "monomorphism restriction" is unnerving to me :)
11:09:30 * Cale peruses the current discussion
11:09:30 <jlouis> basti_: huh?
11:09:56 <jlouis> (s o r) o (s o r) = s o r surely, but..
11:10:20 <basti_> hmm
11:11:20 <aheller> has anyone tried to use mmm-mode in emacs (latex/haskell) and had a '$' in the haskell source put the latex source after \end{code} into math mode (and know how to fix it?)?
11:18:20 * ski leaves for zzz
11:19:58 <Axioplase> Is there a function that rotates a list ?
11:20:26 <jlouis> rotate? puts the head at the end of the tail?
11:20:30 <Axioplase> yep :)
11:20:30 <basti_> @pl \a->(tail a):(head a):[]
11:20:31 <lambdabot> liftM2 (:) tail (return . head)
11:20:35 <basti_> ^^
11:20:47 <basti_> > (\a->(tail a):(head a):[]) [1,2,3,4,5]
11:20:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:20:47 <lambdabot>   Expected type: [[a]]
11:20:47 <lambdabot>   Inferred type: [a]
11:20:50 <basti_> huh
11:20:53 <basti_> ah
11:20:59 <basti_> > (\a->(tail a) ++ ((head a):[])) [1,2,3,4,5]
11:21:01 <lambdabot> [2,3,4,5,1]
11:21:03 <basti_> there you go
11:21:09 <Axioplase> thanks
11:21:12 <basti_> @pl \a->(tail a)++((head a):[])
11:21:13 <lambdabot> liftM2 (++) tail (return . head)
11:21:53 <jlouis> (\x -> take (length x) $ tail $ cycle x) [1, 2, 3] :P
11:22:28 <basti_> ^^
11:34:39 <takuan> humz
11:34:48 <takuan> sequential access is indeed quicker with lists ;)
11:38:23 <takuan> but at least it's not eating 350 meg of mem while iterating
11:46:08 <takuan> Cale: which would be an efficient way of going through a NxN matrix element by element from upper left through down right
11:46:15 <takuan> is there an efficient way with arrays?
11:46:39 <Cale> well, with arrays, you'd just do an amap or something
11:46:51 <Cale> depends on what thay iteration is accomplishing really
11:46:55 <Cale> that*
11:47:43 <Cale> @type Data.Array.IArray.amap
11:47:45 <lambdabot> forall e i (a :: * -> * -> *) e'.
11:47:45 <lambdabot> (GHC.Arr.Ix i,
11:47:45 <lambdabot> Data.Array.Base.IArray a e,
11:47:45 <lambdabot> Data.Array.Base.IArray a e') =>
11:47:45 <lambdabot> (e' -> e) -> a i e' -> a i e
11:48:11 <Cale> applies a function to the array elements
11:48:39 <Cale> if you just want to extract the elements in the array, use something like elems
11:48:44 <takuan> mmm
11:48:45 <takuan> not really
11:48:54 <Cale> what are you doing exactly?
11:48:56 <takuan> i'm applying a stencil like operation
11:49:25 <takuan> so i'm calculating each element in function of that element, the one above and beneath, and the one to the right and the left
11:49:37 <Cale> ah, a convolution
11:49:42 <Cale> hmm...
11:49:51 <Cale> (well, sort of)
11:49:59 <takuan> yup
11:50:24 <takuan> the nice thing is that my new code is way shorter and readable than the C++ version or the list version
11:50:28 <takuan> but it's daaaaamn slow
11:51:53 <takuan> basically, one would want something like iterators for that
11:51:57 <Cale> ah, I know -- first write a function which figures out what the new array should be at a given index
11:52:03 <takuan> but that's a little too much C++ or haskell i'm afraid ;)
11:52:14 <takuan> i've done that
11:52:51 <Cale> then just map that over a list of indices, zipped against that list again, to get a list of updates
11:52:52 <takuan> and then you pass it to t//[((i,j),calculate i j)|i<-[0..n-1],j<-[0..n-1]]
11:53:07 <Cale> sure, that works :)
11:53:10 <takuan> sure
11:53:15 <takuan> but it's slow
11:53:30 <takuan> because of the elements that have to be accessed
11:53:37 <Cale> hmm, wonder if it's faster just to make a new array altogether
11:53:55 <Cale> rather than updating one
11:54:05 <takuan> well, i guess it's not the updating that is slow
11:54:14 <Cale> the calculate?
11:54:18 <takuan> but rather the calculate
11:54:25 <Cale> what does calculate do?
11:54:33 <takuan> the workhorse part there is
11:54:38 <takuan> |otherwise = t!(i,j) + c*(t!(i-1,j) -4*t!(i,j)+ t!(i+1,j) + t!(i,j-1) +t!(i,j+1))
11:55:00 <Cale> hmm
11:55:29 <Cale> oh, perhaps the problem is that you're modifying this array and reading an old version of it, and it's a Diff array
11:55:30 <takuan> i guess it's not very easy to make something like that quick
11:55:42 <takuan> aha
11:56:05 <Cale> so as it gets modified, the old version gets slower
11:56:26 <takuan> uhu
11:56:27 <Cale> still shouldn't be that much slower, but it might make a difference
11:56:36 <takuan> which kind would i use then?
11:57:11 <Cale> well, you can stick with Diff arrays if they're useful elsewhere, but don't phrase this as an update to your array, if you're applying the function to the whole thing
11:57:26 <Cale> just build a new array with those associations
11:57:32 <takuan> mmm
11:57:37 <Cale> (using array)
11:57:37 <takuan> that's an idea
11:58:10 <Cale> the old array will get GC'd if it's not needed anyway
11:59:02 <Cale> I suppose its elements will likely stick around for a while though, at least until the elements of the new array which use them get evaluated.
12:00:04 <takuan> get's 1/6 faster
12:00:08 <takuan> -'
12:00:18 <Cale> hmm...
12:00:50 <takuan> that's something
12:00:58 <Cale> is this a DiffUArray?
12:02:14 <takuan> yup
12:02:24 <takuan> should I use something else?
12:02:31 <Cale> okay, so the elements are unboxed, and should be strict...
12:02:52 <Cale> perhaps I'll do some testing :)
12:04:10 <takuan> no need to
12:04:18 <takuan> but it would be nice if I could speed the thing up
12:04:43 <Cale> okay, evaluating one of the elements of a DiffUArray forces the evaluation of all of them
12:05:32 <takuan> humz
12:05:40 <takuan> that's not nice
12:06:02 <Cale> If that's not what you'd like to have happen, try switching to a DiffArray
12:06:05 <Cale> which is lazier
12:06:56 <Cale> it just means that the results of all those computations will be cached, so there should be no difference if you use the whole array, but might be something worth trying
12:07:39 <Cale> you can see this in action by doing something like (in ghci):
12:07:48 <Cale> :m + Data.Array.Diff Debug.Trace
12:07:55 <Cale> let a = listArray (1,10) (map t [1..10]) :: DiffUArray Int Int
12:08:03 <Cale> a ! 1
12:08:07 <Cale> er
12:08:13 <Cale> before the listArray, put
12:08:18 <Cale> let t x = trace (show x) x
12:08:48 <Cale> you'll see that all 10 of the elements in the array get evaluated at once, and then the first is returned
12:08:57 <takuan> humz
12:09:03 <takuan> now it gets *really* slow
12:09:22 <Cale> (that only happens the first time an element is accessed, obviously)
12:10:06 <takuan> it's about 3 times as slow as the exact same version with DiffUArray
12:10:27 <takuan> but what i forgot to tell you is that i'm applying the operation 5000 times on the same element
12:10:45 <Cale> okay, I thought it would probably be slower, but it's worth a shot, because depending on your access pattern, laziness can sometimes make things a lot faster too :)
12:10:54 <takuan> i'm using a simple function for that
12:10:54 <takuan>  apply f a 1 = f a
12:10:54 <takuan>  apply f a nr =  apply f (f a) (nr-1)
12:11:08 <Cale> iterate f !! n
12:11:19 <takuan> well, we're using the entire matrix
12:11:23 <takuan> would that be faster?
12:11:43 <Cale> hmm
12:11:59 <takuan> doesn't iterate generate a list?
12:12:11 <Cale> yeah, but it doesn't matter if you never look at it
12:12:12 <Cale> :)
12:12:24 <takuan> well, we want the last element of that list ;)
12:12:33 <takuan> or at least the 5000th element
12:12:42 <Cale> :)
12:12:57 <Cale> still shouldn't be much worse than apply
12:13:01 <takuan> guess that won't make a differenc
12:13:08 <takuan> let's see
12:13:17 <takuan> but what does the !! do?
12:13:26 <Cale> extracts the nth element of a list
12:13:57 <Cale> > [0..] !! 5000
12:13:58 <lambdabot> 5000
12:14:25 <Cale> > ['a'..] !! 6
12:14:26 <lambdabot> 'g'
12:14:28 <takuan> ah
12:14:44 <Cale> now, hmm
12:14:57 <Cale> you may have a strictness problem with apply/iterate/!!
12:15:10 <takuan> because?
12:15:44 <Cale> you may wish to make those stricter, as what's going to happen is that apply f a 5000 will first get expanded 5000 times before any computation of f happens
12:16:17 <takuan> mmm
12:16:31 <takuan> I think I would see that in the memory usage of the program
12:16:35 <takuan> wouldn't i?
12:16:45 <Cale> you get a big expression like f (f (f (f ... (f a))...))
12:16:50 <Cale> and then that gets evaluated
12:16:53 <Cale> yeah, you might see it
12:18:20 <takuan> does that cause speed problems?
12:18:41 <Cale> it can, also, stack overflows
12:18:47 <Cale> apply (+1) 0 1000000
12:18:49 <Cale> try that :)
12:19:18 <takuan> iterate makes it a little slwer
12:19:37 <Cale> yeah, iterate isn't any better in that respect it seems
12:19:39 <takuan> eur, faster i mean
12:19:47 <takuan> 2 seconds on 26 seconds
12:19:55 <Cale> oh, good :)
12:20:04 <Cale> apply f x 0 = x
12:20:04 <Cale> apply f x n = let y = f x in y `seq` apply f y (n-1)
12:20:14 <Cale> try that version
12:22:58 <takuan> welp
12:23:10 <takuan> that's almost as fast as my list version
12:23:23 <takuan> which means that I would speed up my list version too ;)
12:25:07 <takuan> nope
12:25:17 <takuan> but that's a nice speed improvement
12:26:27 <xerox> Howdy, people.
12:26:41 <Lemmih> Hiya, xerox.
12:27:26 <xerox> How's code, Lemmih ?  What's the bleeding-edge hackup under your hands these days ?  :-)
12:28:01 <takuan> thanks Cale
12:28:10 <takuan> if any other good ideas prop up, hit me
12:28:57 <Lemmih> xerox: Haskell Server Pages. I'm working on a nice interface to CSS generation.
12:29:04 <Lemmih> You?
12:29:15 <xerox> CSS *generation*?  Woot.
12:29:53 <xerox> I was mainly mountain-biking, lately :-)
12:30:58 <xerox> The left knee isn't very happy about it, too.
12:32:02 <xerox> IRC is deadly silent today, what's up with it.
12:33:38 <Korollary> people exhausted themselves talking about CT
12:34:38 <xerox> I'm very happy to have exhausted myself in mountain :-)
12:35:48 <Lemmih> CT?
12:35:54 <xerox> Cathegory Theory ?
12:36:06 <Korollary> what else
12:48:18 <jlouis> mountain biking sounds fun
12:48:45 <xerox> Indeed!  It was planned for LONG ago to go there with two friends, but we're SO lazy.
12:48:55 <jlouis> take a bike, mud, a forest, brakes (hopefully), a helmet (hopefully), a cool sunset afternoon, a person or two
12:49:14 <jlouis> oh, it must be rather fun
12:50:28 <xerox> Geez.  Brakes were an optional on my bike today.
12:54:56 <jlouis> heh, interesting
13:19:14 <Axioplase> is "myfunc list = let (foo,bar)= (f list) in \n\t\t (qux foo bar)" illegal ? ti tells me the indentation might be wrong ("\n\t\t" means I indented the pair under the let)
13:21:03 <Lemmih> \t == 8 spaces.
13:22:39 <eivuokko> Lemmih, did you get my patch?  Was it ok?
13:25:56 <Axioplase> Lemmih: anyway. it's under the pair.
13:27:50 <Frederick> yo folks
13:28:01 <Lemmih> eivuokko: It looks good. Haven't had time to apply it yet.
13:28:18 <Heffalump> 'lo
13:28:19 <Frederick> SamB, Cale`` are you around?
13:28:29 <eivuokko> Cool.
13:28:37 <Heffalump> anyone know the current status of haxml debs?
13:40:25 <Axioplase> What should be a simple gfx library to draw stuff? something easy like ocaml's graphics. SDL is quite too much for my needs.
13:40:34 <malcolm>  Heffalump: nope
13:42:59 <Heffalump> I found them, anyway.
13:43:41 <Heffalump> I think Arjan Oosting is still in need of a sponsor to get them into Debian itself, or something.
13:53:04 <Frederick> yo, Cale can you help me over resizing the productions?
13:53:12 <Cale> resizing?
13:53:45 <Frederick> Cale, http://www.csee.umbc.edu/~squire/cs451_l16.html
13:53:52 <Cale> Axioplase: well, hmm... there's HGL which comes with GHC -- it's pretty simple, but limited.
13:54:05 <Cale> ah, right
13:54:06 <Frederick> CNF is basically resizing the right side
13:54:36 <Axioplase> Cale: ok thanks
13:55:09 <Frederick> Cale, Im looking for something like length or sizeof
13:55:12 <Cale> Axioplase: it'd be nice to have something as simple but written to use Cairo. I was thinking of writing it :)
13:55:25 <Cale> Frederick: how are your productions stored?
13:55:42 <Cale> > length "hello"
13:55:43 <lambdabot> 5
13:55:47 <Cale> > length [1,2,3]
13:55:48 <lambdabot> 3
13:56:31 <Frederick> if I have [[a,"aaaa"]] can I get the length of aaaa field?
13:56:50 <malcolm> Cale: what about hs-cairo then?
13:57:32 <Cale> malcolm: well, gtk2hs has a binding to cairo which is nice, all that'd be really needed is a thin candy coating around it :)
13:57:57 <Cale> (to handle the window setup, etc)
13:58:19 <Cale> Frederick: What would it do in general?
13:58:39 <Cale> and what's a?
13:59:37 <soysauce> is there a such thing as Int32# in GHC?
13:59:39 <Cale> > map (length . (!! 1)) [["hello", "world"], ["test", "case"]]
13:59:40 <lambdabot> [5,4]
13:59:49 <Cale> oh, that's a bad example :)
13:59:55 <Cale> > map (length . (!! 1)) [["hello", "world!!!"], ["test", "case??"]]
13:59:56 <lambdabot> [8,6]
14:00:18 <Cale> is that what you're looking for?
14:00:28 <Frederick> Cale, sorry my sample is missleading give S a variable and aaa its production stored in the ["A","aaa"] for I want to count the size of the second field, if it is > 2 I want to split it like A -> aS where S -> aa
14:00:54 <Cale> why are you using a list there?
14:01:18 <Cale> ["A", "aaa", "bbb"] -- does this ever come up?
14:01:23 <Frederick> dunno, Ive started this way SamB continued with me
14:01:50 <Cale> or are your lists always exactly 2 elements long?
14:02:17 <Cale> soysauce: that sounds plausible
14:03:19 <soysauce> Cale - I am not getting a syntax error, but I can't figure out *what* such a thing would be.
14:03:24 <soysauce> presumably the same thing as an Int#
14:03:33 <soysauce> but if so, then I don't know how to get an Int32#
14:04:06 <soysauce> I don't see anything in GHC.Exts about Int32#
14:04:07 <soysauce> er
14:04:30 <soysauce> s/GHC.Exts/Data.Int/
14:04:39 <Frederick> Cale, it can be "infitine"
14:04:45 <Oejet> Axioplase: I don't think there is anything like Swing.  My two best suggestions are Gtk2hs and Cairo or OpenGL.
14:04:49 <Cale> hmm, yeah, doesn't seem to exist
14:04:59 <Frederick> Cale, http://www.csee.umbc.edu/~squire/cs451_l16.html this is what I need
14:05:04 <Korollary> @index Int32#
14:05:05 <lambdabot> bzzt
14:05:26 <Cale> Frederick: um, that doesn't really answer my question...
14:05:45 <soysauce> @index Int#
14:05:45 <lambdabot> bzzt
14:05:50 <soysauce> that's not going to work.
14:05:52 <Frederick> Cale, sorry wich question
14:05:56 <soysauce> Int# is a GHC thing
14:06:19 <Cale> Say you have the productions: S -> Sa | aaa | Ba; B -> Bb
14:06:21 <Axioplase> Oejet: I don't need a toolkit in fact. Just some plotting functions and drawing ones. Swing is a bit too much. But hgl seems nice. However, something as simple but with Cairo would be great though.
14:06:26 <Cale> how would you represent that?
14:06:28 <soysauce> weird.
14:06:30 <Cale> can I see your code?
14:06:41 <soysauce> Int32# exists, but I can't figure out where, and I can't figure out how to operate on it.
14:06:44 <Cale> soysauce: Int# is an unboxed Int
14:06:51 <soysauce> Cale - I know what it is
14:06:53 <Cale> soysauce: How do you know it exists?
14:07:05 <soysauce> Cale - because the compiler is happy to compile it? ;)
14:07:22 <Korollary> soysauce: Int# is not documented, either.
14:07:33 <soysauce> Korollary - the GHC manual mentions Int#
14:07:48 <soysauce> also: http://support.informatik.uni-freiburg.de/manuals/ghc/libraries/base/GHC.Exts.html
14:08:03 <lisppaste2> Frederick pasted "code" at http://paste.lisp.org/display/13777
14:08:11 <Cale> It'll compile anything with # on the end if -fglasgow-exts is turned on
14:08:16 <Cale> data Foo# = Foo
14:08:18 <soysauce> ah
14:08:33 <soysauce> so it treats # as an identifier character in that case?
14:08:38 <Cale> yeah
14:08:48 <soysauce> ok, I see
14:09:12 <Cale> productions :: Map (Symb t nt) [[Symb t nt]] -- aha
14:09:44 <Frederick> yep
14:10:06 <soysauce> Int32 isn't an unboxed type, is it?
14:10:08 <Cale> okay, so there's nothing special about the second element of the list
14:10:27 <Cale> soysauce: I don't think it's unboxed, but it should be easy enough to find out
14:10:35 <soysauce> how?
14:11:17 <Cale> Prelude> :m + Data.Int
14:11:17 <Cale> Prelude Data.Int> :info Int32
14:11:17 <Cale> data Int32 = I32# GHC.Prim.Int#         -- Imported from GHC.Int
14:11:21 <dons> moin
14:11:26 <soysauce> ah
14:11:28 <Oejet> Axioplase: Perhaps the entry at http://haskell.org/gtk2hs/ will be interesting to you.
14:11:32 <soysauce> cool
14:11:38 <dons> ah, I see soysauce is still with the unboxed hacking! ;)
14:11:52 <soysauce> dons - yup
14:11:58 <soysauce> this is pretty neat
14:11:59 <Cale> why are you so obsessed with unboxed ints anyway?
14:12:07 <soysauce> Cale - because I want to know how it works
14:12:11 <Cale> ah, okay :)
14:12:22 <Cale> I pretty much always stick with Integer
14:12:23 <Korollary> obsession is good
14:12:25 <soysauce> well, that and to commit atrocities ;) but anyway
14:12:42 <soysauce> mostly I want to be able to explain some of the oddities that go on
14:12:54 <Korollary> soysauce: what oddities ?
14:12:57 <dons> there's a paper too, "Unboxed Values as First class citizens" , SPJ and Launcbury.
14:13:08 <soysauce> for example, some time ago I wrote a function that traversed a list and returned the nth element. Thereafter I learned about the (!!) operator
14:13:16 <Cale> Frederick: okay, so you want to look at the lengths of the productions, perhaps just  map length  over the list of right hand sides for the symbol?
14:13:27 <soysauce> (!!) was about twice as fast as my function, that was inexplicable
14:13:47 <dons> ah, but it used unboxed counters?
14:13:53 <Axioplase> Oejet: I was reading that thanks
14:13:53 <Korollary> soysauce: you can look at the ghc source code and see how they did it.
14:13:54 <soysauce> well, this morning I proved (technically I simply offered supporting evidence, but anyway) that the reason was because (!!) unboxes the index
14:13:59 <dons> usually ghc is clever enough to do the unboxing. with -O
14:14:07 <soysauce> dons - no, I didn't know anything about unboxing/boxing ;)
14:14:11 <Frederick> Cale, yes
14:14:14 <soysauce> well I used -O and it wasn;t
14:14:16 <soysauce> wasn't, rather
14:14:39 <Cale> Frederick: it might be useful to zip that back against the list again too
14:14:51 <soysauce> Korollary - I used the profiler and on a list of 20 million elements (640MB of memory) and my traversal function that unboxed the int had identical runtime to (!!)
14:14:52 <Cale> or use a filter
14:14:57 <Frederick> hm
14:15:21 <dons> soysauce, but that's not surprising, since there's only a few reasonable ways to write !!
14:15:24 <Cale> soysauce: didn't you see the implementation of !! in fptools?
14:15:35 <Cale> I thought I linked to it when you brought that up the first time
14:16:01 <dons> xs !! (I# n) | n <# 0#   =  error "Prelude.(!!): negative index\n"
14:16:01 <dons>          | otherwise =  sub xs n
14:16:01 <dons>                          where
14:16:02 <dons>                 sub :: [a] -> Int# -> a
14:16:02 <dons>                             sub []     _ = error "Prelude.(!!): index too large\n"
14:16:05 <dons>                             sub (y:ys) n = if n ==# 0#
14:16:08 <dons>                        then y
14:16:10 <dons>                        else sub ys (n -# 1#)
14:16:13 <dons> that's the evil ghc version.
14:16:29 <soysauce> Cale - maybe
14:16:53 <soysauce> Cale - I only started learning Haskell like 10 weeks ago ;)
14:17:11 <soysauce> and yes, that is a really complicated version
14:17:13 <Cale> http://darcs.complete.org/fptools/libraries/base/GHC/List.lhs
14:17:13 <soysauce> mine is like 2 lines
14:17:32 <Cale> you can see that code in there
14:17:52 <MarcWebe1> soysauce: I think you'll be learnling haskell the rest of your life ;-) I'm a beginner, too
14:17:55 <Cale> along with a bunch of other slightly evil stuff
14:18:10 <soysauce> Cale - yeah
14:18:19 <Cale> but stuff which makes lists fast :)
14:18:29 <soysauce> *nods* I noticed
14:18:30 <Cale> "foldr2/right"	forall k z xs (g::forall b.(a->b->b)->b->b) . 
14:18:30 <Cale> 		  foldr2 k z xs (build g) = g (foldr2_right k z) (\_ -> z) xs
14:18:36 <Korollary> soysauce: To look at unboxing and other advanced hackery is not the best thing to do for a beginner, imho.
14:18:40 <dons> rewrite rules for all!
14:18:44 <soysauce> the whole boxed/unboxed distinction is stupid, IMO
14:18:55 <soysauce> but oh well
14:19:10 <dons> read the paper. there are some good reasons.
14:19:10 <soysauce> I'm starting to suspect that GHC really doesn't do a very good job of optimizing Haskell
14:19:14 <MarcWebe1> Having this type: type State st a = st -> (st, a)
14:19:22 <Heffalump> it does a better job than any other compiler
14:19:33 <Heffalump> whether it's possible to do massively better is not entirely obvious
14:19:34 <Cale> soysauce: the problems are subtler than you think
14:19:37 <soysauce> dons - what paper?
14:19:45 <Korollary> soysauce: contribute to jhc !
14:19:48 <dons> the unboxed value sas first class citizens paper.
14:19:54 <soysauce> Korollary :) wish I had the time
14:20:08 <soysauce> dons - ah
14:20:13 <Cale> Unboxing things all over the place isn't always a good idea
14:20:13 <dons> and perhaps the various ghc optimisation papers 
14:20:22 <MarcWebe1> and returnState :: a -> State st a
14:20:27 <Cale> Unboxing values makes them stricter
14:20:31 <dons> you throw out the semantics for one.
14:20:55 <soysauce> Cale - I see, that's true.
14:21:11 <soysauce> sorry; I come at this from an imperative background, so I forgot the laziness aspect
14:21:41 <Cale> For example, looking at just one element of a DiffUArray will cause all the others to be evaluated.
14:21:52 <Cale> While DiffArray doesn't suffer from that
14:22:07 <Cale> However, DiffUArray is a lot faster if you're actually going to use all the elements.
14:22:12 <soysauce> yes, but for a lot of problems being strict is okay
14:22:16 <Cale> sure
14:22:28 <Cale> for a lot of problems it doesn't even matter at all :)
14:22:36 <MarcWebe1> Can I think of (returnState a) st beeing a function of type a -> st -> (a,st) ?
14:22:41 <dons> for really serious problems you don't use [a] anyway.
14:22:52 <dons> and generally strictness flags on data types are enough
14:23:02 <Cale> dons: I don't quite agree with that :)
14:23:13 <dons> serious IO, I should qualify
14:23:22 <soysauce> dons - strictness flags?
14:23:27 <Cale> lists are important, they're essentially loops
14:23:29 <soysauce> do tell
14:23:36 <soysauce> this is something I have not been able to understand.
14:23:45 <dons> Cale, true. ok. lists are everywhere. [Char] for IO is bad.
14:23:53 <Cale> yeah :)
14:24:02 <dons> soysauce, you can make a field of a data type strict. data Foo = Foo !Char
14:24:12 <soysauce> ah
14:24:19 <dons> then that field is strict. and it will even get unboxed automagically for youu if you use -funbox-strict-fields
14:24:22 <soysauce> can one write something like foo :: !Int -> !Int -> !Int
14:24:27 <dons> no
14:24:27 <soysauce> *nods*
14:24:31 <soysauce> ok, so just fields
14:24:38 <soysauce> interesting
14:24:40 <Cale> data Person = Person { name :: ![String], age :: !Integer }
14:25:01 <Cale> er
14:25:05 <Cale> data Person = Person { name :: !String, age :: !Integer }
14:25:08 <Cale> heh
14:25:19 <dons> sometimes crazy people write, eg. data Color
14:25:19 <dons>     = RGB {-# UNPACK #-} !Word8 !Word8 !Word8
14:25:19 <dons>     | Default
14:25:20 <Cale> Well, you might want it the other way actually :)
14:25:36 <dons> which really really hassles the compiler to unbox and cram the space
14:25:48 <soysauce> *nods*
14:26:00 <soysauce> this is very interesting
14:26:03 <dons> but be aware of the consequences. you can't stick 'error' in such a data type
14:26:09 <soysauce> oh, I remember now why I went on a quest to learn about unboxing
14:26:13 <Cale> but it means for example, that if in the end, you just project out the blue channel, you'll end up computing the red and green ones too
14:26:16 <soysauce> yeah I know
14:26:20 <soysauce> remember, I am accustomed to that
14:26:45 <soysauce> I was looking for something "larger than Int but smaller than Integer" ;)
14:26:50 <soysauce> AKA Int64
14:27:27 <Cale> I'm not sure that Int64 will generally do all that much better than Integer -- it would be nice to have some good benchmarks done
14:27:40 <Cale> (on a 32 bit arch, at least)
14:27:57 <soysauce> well, I would expect that GHC would use a long long for an Int64
14:28:00 <dons> Int64 is reputed to be slowish on 32 bit machines. not sure how slow
14:28:14 <dons> Integer, remember, just uses an Int until the size gets too big
14:28:17 <soysauce> which means that (+) and (-) and (=) cost 2 cycles, *much* cheaper than the same for Integer
14:28:30 <soysauce> I can test it though
14:28:37 <soysauce> I was trying to do that before
14:28:48 <Cale> soysauce: much more than 2 cycles is likely :)
14:28:54 <soysauce> oddly, BTW, Int32 is slower than Int. I presume GHC has some special optimization magic for Int.
14:29:05 <dons> likely, yes.
14:29:05 <soysauce> Cale - I'll go test :)
14:29:12 <Cale> data Int = I# GHC.Prim.Int#     -- <wired into compiler>
14:29:24 <soysauce> then we can stop speculating ;)
14:29:34 <Cale> data Int32 = I32# GHC.Prim.Int#         -- Imported from GHC.Int
14:29:35 <Frederick> Cale, so what do you suggest for me?
14:29:36 <dons> lists of small Int are unpacked into consecutive array elements, for one.
14:29:54 <Heffalump> dons: it'll still need a tag for whether it has overflowed yet or not
14:29:55 <Cale> Frederick: hmm, I'm not sure -- what's the problem?
14:29:56 <soysauce> *nods*
14:30:02 <Heffalump> and to check that on each side for each binary operation
14:30:09 <Heffalump> and probably a pointer dereference
14:30:23 <Heffalump> (re Integer being stored in Int until it overflows)
14:30:49 <Frederick> Cale, I dont know wich functions could I use, cause the basically is count, chop the list add in the back, I dont know if I can do it in run time
14:30:57 <Frederick> I mean in the same lop
14:31:14 <Cale> Frederick: check out partition
14:31:30 <Frederick> k
14:32:14 <Cale> > partition ((< 5) . length) (words "Hello, this is a sentence with long and short words.")
14:32:15 <lambdabot> (["this","is","a","with","long","and"],["Hello,","sentence","short","
14:32:15 <lambdabot> words."])
14:33:20 <Cale> neat, eh?
14:33:52 <Frederick> hm
14:34:12 <Frederick> Cale, Haskell is like a chainsaw if you are skilled
14:35:01 <soysauce> heh
14:35:04 <Cale> :)
14:35:14 <soysauce> why don't they do type Int32 = Int
14:35:15 <soysauce> :/
14:35:26 <Cale> they could
14:35:32 <soysauce> but they didn't
14:35:34 <Cale> it wouldn't be a distinct type then
14:35:47 <soysauce> newtype does that, doesn't it?
14:35:48 <Axioplase> Oejet: err.. I'm really new to Haskell. Do you understand what's on http://haskell.org/gtk2hs/ ? I have two lists of plots want to plot, one in black, and one in red. But it looks like the run function does everything, including the render of the window.. I'm a bit stuck..
14:35:49 <Cale> which you kind of want it to be
14:35:56 <Cale> yeah, newtype would be sensible
14:36:36 <soysauce> and as I understand, with newtype it could make the same optimizations
14:36:43 <soysauce> since the only distinction is in the type checker
14:37:02 <Cale> ah, it seems xerox did what I wanted to do already :)
14:37:10 <Cale> thanks xerox!
14:37:21 <soysauce> @type fromIntegral
14:37:22 <lambdabot> forall b a. (Num b, Integral a) => a -> b
14:37:31 <Cale> soysauce: yeah, might be an idea.
14:37:51 * soysauce smacks self
14:38:01 <Korollary> Axioplase: the run function seems to execute IO actions, like main in a console program.
14:38:02 <soysauce> I am so tired, I've spent the last 5 minutes trying to recall what I set out to do
14:38:10 <soysauce> haha
14:38:21 <Korollary> Eye of the tiger, soysauce !
14:38:31 <soysauce> hm? What's that mean?
14:38:38 <Cale> Axioplase: yeah, if you want them on the same plot, you have to pass everything you want to do to the run function, which converts the Render into an IO
14:38:40 <lisppaste2> Frederick pasted "how do i get a given field?" at http://paste.lisp.org/display/13779
14:38:43 <Korollary> you've never seen Rocky ?
14:38:46 <soysauce> nope
14:39:02 <Korollary> ow. ok. invalid movie reference then.
14:39:03 <Frederick> Cale, oki Ive started crafting that procedure but again how do I get the given field of the list?
14:39:11 <Cale> Frederick: pattern match?
14:39:13 <soysauce> oh well :)
14:39:14 <Frederick> kolmodin, Ive seen all :p
14:39:27 <Axioplase> Korollary: Cale but it takes a Render(), not a String or whatever else.. I don't know how to generate the Render from my data...
14:39:29 <Cale> (short, long) = partition ((<2) . length) blah
14:39:54 <Cale> Axioplase: well, you see those examples there?
14:39:56 <Frederick> brb
14:39:58 <Frederick> gotta t oeatr
14:40:32 <SamB> Frederick: already?
14:40:46 <soysauce> heh weird, why would they make shiftL# :: Word# -> Int# -> Word#
14:40:53 <soysauce> the second parameter has to be non-negative.
14:41:00 <soysauce> Word# -> Word# -> Word# would make a lot more sense
14:41:05 <SamB> dons: hmp3 doesn't seem to like getting files as arguments anymore in 0.0p154
14:41:08 <Axioplase> Cale: I do.
14:41:19 <Cale> First you generate a bunch of moveTo's and lineTo's from your data
14:41:24 <Oejet> Axioplase: I see.  I didn't know, you're new to Haskell.  Perhaps what you could do, is to pipe your data to an external plotting program like Gnuplot?
14:42:05 <dons> SamB, yep. on the todo list.
14:42:07 <Korollary> Axioplase: You could do it like you would a list of numbers to stdout one by one.
14:42:12 <Axioplase> Oejet: I could. But it ain't great learning to just print to stdout and pipe to gplot..
14:42:21 <dons> SamB, note that it now though has the nice ability to save the playlist
14:42:40 <dons> so you often don't need args anyway.
14:42:42 <SamB> dons: I wouldn't want to save a playlist in binary with so many non-mp3s in it
14:43:13 <SamB> such as files left by jack
14:43:13 <dons> ah, fair enough. 300 files use around 200k, but I've got a nicer scheme for shrinking that state.
14:43:38 <dons> maybe  hmp3 should filter out non-playable files, as it does already with non-r files
14:43:57 <SamB> it should probably also filter out MPEG video files
14:44:04 <Korollary> Axioplase: If you understand how this works, you can figure it out yourself: "sequence $ map (putStr . show) [1,2,3]"
14:44:08 <Cale> Axioplase: generate a list of moveTo's and lineTo's, say it's xs, then run (do sequence xs; stroke)
14:44:22 <dons> yeah. hmm. just have to work out how to identify if something is a  .mp3.
14:44:35 <SamB> because mpg321 makes HORRIBLE noises when it gets passed an MPEG video
14:44:41 <SamB> anyway, tried file?
14:44:48 <dons> yeah, no good
14:45:02 <Axioplase> well, I don't know the "$" word nor how the "do" works yet, but I'll try.
14:45:03 <MarcWebe1> dons: Perhaps the linux file executable can help you identifying mp3s?
14:45:14 <dons> doesn't work. not portable either.
14:45:23 <SamB> MarcWebe1: he uses OpenBSD
14:45:27 <dons> but there's almost certainly a magic byte or two in the file
14:45:37 <SamB> dons: file with other magic?
14:45:57 <Korollary> Axioplase: $ is the easy part, but it is imperative that you understand doing input/output with monads and the do syntax.
14:46:11 <Frederick> SamB, yo, already what?
14:46:23 <SamB> Frederick: did you say you were going to eat?
14:46:38 <Frederick> SamB, just had dinner
14:46:48 <SamB> @localtime Frederick 
14:46:50 <lambdabot> Local time for Frederick is Sat Nov 19 20:46:30
14:47:06 <Frederick> SamB, yep Ive eaten in 7 minutes, shrimp and rice
14:47:07 <SamB> hmm, I must be hungry
14:47:16 <SamB> got the time conversion backwards
14:47:20 <SamB> ;-)
14:47:35 <Frederick> :-)
14:47:44 <Frederick> SamB, Im playing with the CNF procedure
14:47:53 <SamB> dons: anyway, what was wrong with file exactly?
14:48:04 <dons> it didn't print anything useful for me.
14:48:08 <SamB> hmm.
14:48:10 <Frederick> SamB, Cale wasenlighting me about partition
14:48:19 <SamB> does it have the same magic format as mine?
14:48:30 <dons> but come on, .mp3 fils must have a magic byte in them that I can read directly
14:48:33 <SamB> file-4.09
14:48:50 <dons> file-4.09
14:48:56 <SamB> dons: would you like me to find the magic in my magic file, because mine works ;-)
14:49:09 <dons> ok. please do.
14:49:18 <SamB> you can use that either way
14:49:23 <dons> then I can perhaps use that magics
14:51:05 <MarcWebe1> dons: Mine work,too but I don't understand them, yet..
14:51:52 <soysauce> how do you convert from Int# to Word#? I saw a page about that earlier but can't find it now
14:52:06 <dons> ah, hmm. some files work, some don't. MP3, 128 kBits, 44.1 kHz, JStereo
14:53:03 <stepkut> dons: what is point of hmp3 ? I seemed to have missed that part ...
14:53:04 <dons> others just say: mp3/suzie/Portishead/Portishead - Biscuit.mp3: data
14:53:28 <dons> the playing of tunes
14:53:45 <ValarQ> dons: how is the hmpc project going?
14:54:03 <MarcWebe1> Can you help me understanding this two lines?
14:54:06 <MarcWebe1> type State st a = st -> (st, a) \n  returnState :: a -> State st a 
14:54:06 <stepkut> dons: is there something unique you are attempting to do ? Or is it just for fun ?
14:54:08 <dons> nowhere, as I don't have mpd installed.
14:54:30 <ValarQ> dons: apt-get install mpd # ;)
14:54:32 <dons> nothing terribly unique. basically a stable, simple mp3 ncurses player.
14:54:45 <dons> http://www.cse.unsw.edu.au/~dons/hmp3.html
14:54:58 <dons> ValarQ: $ which apt-get
14:54:58 <dons> apt-get not found
14:55:05 <dons> ;)
14:55:24 <stepkut> ah.. well I am going to setup and old busted up laptop (bad hard drive, case failing apart) into a wireless mp3 player soon -- so maybe I will give it a try
14:55:45 <dons> cool.
14:56:04 <SamB> dons: I sent it as a darcs patch
14:56:25 <ValarQ> dons: oh, a non debianuser :)
14:56:43 <MarcWebe1> What does returnState:: a -> State st a mean? Does it return another function for every a e.g  returnState 2 results in another function then returnState 3?
14:56:49 <SamB> ValarQ: well, OpenBSD doesn't come in Debian
14:57:16 <stepkut> dons: do you prescan the mp3 directories and collect meta-data for searching at stuff ? Or do you want to keep it simple ?
14:57:24 <ValarQ> SamB: didn't debian support some bsd base system?
14:57:41 <SamB> ValarQ: Debian GNU/FreeBSD, yeah
14:57:49 <dons> stepkut, simple. prescan dirs, but no metadata 
14:57:58 <SamB> but that isn't at all the same as an ordinary FreeBSD system
14:58:26 <Heffalump> ok, what is libgmp3c2, and why does upgrading to it want to upgrade half of my system?
14:58:30 <Heffalump> (in Debian)
14:58:31 <ValarQ> SamB: no, i guess not
14:58:32 <SamB> basicly the same as Linux, but with a BSD kernel, I guess...
14:58:53 <Korollary> MarcWebe1: returnState :: a -> State st a == a -> st -> (st, a)
14:58:54 <ValarQ> SamB: and why swap ports against apt? that doesn't make sense :)
14:59:11 <SamB> ValarQ: I know!
14:59:12 <stepkut> Heffalump: bignum library, and it wants to upgrade half your system because it has a C++ lib included and debian is switching to g++ 4.0 which is not binary compatible with g++ 3.x
14:59:29 <Frederick> @google libgmp3c2
14:59:30 <lambdabot> http://packages.debian.org/unstable/libs/libgmp3c2
14:59:36 <kombinator> Heffalump: it's a version of libgmp created because of C++ ABI change
14:59:37 <MarcWebe1> Korollary: Thanks. Then I got that right.
14:59:40 <SamB> what I want to know is why there is not a Linux distribution built around ports
14:59:48 <stepkut> Heffalump: so everything that depends on libgmp has to be upgraded when you upgrade libgmp -- sucks bigtime :)
14:59:49 <SamB> not portage, but ports
15:00:20 <Frederick> SamB, portage "is ports for linux"
15:00:20 <ValarQ> SamB: i wouldn't be surprised if there were
15:00:29 <SamB> Frederick: no it isn't
15:00:34 <Heffalump> ah, what I guessed then. Bah.
15:00:36 <ValarQ> Frederick: not exactly
15:00:41 <Heffalump> I guess I'd better bite the bullet and do it..
15:00:46 <SamB> Frederick: its inspired by ports
15:00:53 <Frederick> ValarQ, it is the same concpt
15:00:53 <Heffalump> (60MB download over 512K ADSL, fun..)
15:01:13 <Frederick> Heffalump, http://packages.debian.org/unstable/libs/libgmp3c2
15:01:21 <ValarQ> Frederick: yeah, but there is big differences
15:01:48 <stepkut> Heffalump: I have on my system (which also has a bunch of linspire packages mixed in) and nothing bad happened -- just watch if something is going to be uninstalled 
15:02:00 <Frederick> ValarQ, they are the same idea made in 2 different ways
15:02:02 <Heffalump> stepkut: yeah, I did. ghc5 and nhc are the main ones
15:02:05 <SamB> Heffalump: just think how much more fun it would be if you had nominally 56k dialup
15:02:11 <soysauce> @type int2Word#
15:02:13 <lambdabot> Not in scope: `int2Word#'
15:02:17 <Heffalump> :-)
15:02:23 <SamB> @index int2Word#
15:02:24 <lambdabot> bzzt
15:02:30 <SamB> right
15:02:36 <SamB> @type GHC.Exts.int2Word#
15:02:37 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Word#
15:02:44 <soysauce> huh, weird
15:02:58 <soysauce> @type GHC.Exts.int2Word# 0#
15:02:58 <lambdabot> GHC.Prim.Word#
15:03:01 <soysauce> ?!
15:03:12 <soysauce> oh, nevermind.
15:03:15 <SamB> soysauce: what is the matter?
15:03:23 <soysauce> the type checker was complaining
15:03:25 <soysauce> but I had the wrong side
15:03:31 <stepkut> Heffalump: If you need ghc5 and nhc you will either have to rebuild them against the new libraries or create a sarge or etch based chroot to run them in.. I have a tool that can do that if you need it
15:04:43 <Heffalump> I don't need them
15:04:51 <Heffalump> oh, it does want to remove haddock, though, that's more annoying
15:04:58 <SamB> soysauce: why are you messing with unboxed types, anyway?
15:05:04 <soysauce> for fun and profit.
15:05:23 <soysauce> I'm not sure where the "profit" part comes in.
15:05:26 <SamB> was the compiler not doing a good enough job with that?
15:05:27 <soysauce> but I'll be sure to mention it when I find it
15:05:40 <Korollary> 1. Haskell 2. Unboxed Types 3. ??? 4. Profit !!!
15:05:48 <soysauce> my experience has been that the compiler rarely does a good job with anything
15:05:49 <Heffalump> oh, haddock is being removed just cos of package pins
15:05:50 <stepkut> Heffalump: that may be because apt-get is stupid -- there is a version of haddock in sid that installs along side libgmpc2 (atleast it just did for me)
15:05:53 <SamB> generally you should only do that after profiling and examining the entrials of your code
15:05:58 <soysauce> I know
15:06:05 <Heffalump> stepkut: yeah, it's installing when I ask for the sid version explicitly.
15:06:07 <stepkut> Heffalump: or it could be because of pins ;)
15:06:16 <SamB> you have been compiling with -O2 or -O3?
15:06:17 <soysauce> right now I'm messing with unboxed types to 1. figure out how they work 2. understand how much one gains from using them
15:06:27 <soysauce> no, just -O, the GHC manual said that there is no difference
15:06:35 <soysauce> but I'll try it
15:06:35 <SamB> oh?
15:06:41 <Korollary> soysauce: would you like to get obsessed with these ? http://shootout.alioth.debian.org/benchmark.php?test=all&lang=ghc&lang2=ghc
15:07:00 <SamB> soysauce: well, my main point is that you at least have -O
15:07:18 <SamB> and what are you doing?
15:07:38 <soysauce> nothing interesting? I'm just trying to benchmark the different types to understand relationships
15:07:58 <soysauce> right now I'm not solving a problem
15:08:01 <soysauce> I'm learning
15:08:01 <SamB> you can't judge a compiler by benchmarks
15:08:17 <SamB> at least, not by boring benchmarks...
15:08:24 <soysauce> yes, of course
15:08:33 <stepkut> SamB: can you judge it by the posts on slashdot ?
15:08:44 <SamB> stepkut: no, of course not!
15:08:56 <SamB> aren't you usually spelled with a c?
15:09:12 <stepkut> SamB: yes, but there are lots of nicks now that use k instead of c, so I wanted to join in 
15:09:19 <Heffalump> he must be more German than usual today.
15:09:19 <stepkut> :p
15:09:23 * Korollary yells ow
15:09:26 <soysauce> k is more Scandinavian
15:09:28 <SamB> you look so strange and discolored!
15:09:28 <soysauce> or that
15:09:34 <Heffalump> (I have no idea how German he is in practice :-)
15:10:02 <dons> only a little, I think.
15:10:11 <stepcut> If I have any German in me -- its many generations ago
15:10:36 <soysauce> SamB - I am accustomed to writing C/C++ code. Instead of dropping to assembly when I need to make things fast, I try to understand the compiler and work around its defects.
15:10:42 <soysauce> so I'm doing the same thing in Haskell, for the most part.
15:10:53 * stepcut used to optimize is pascal code with bits of assembly ;)
15:10:57 <SamB> soysauce: well, first you should work on the "need to make things fast" part
15:11:11 <SamB> which is to say, do something interesting ;-)
15:11:11 <stepcut> s/is/his/
15:11:16 <soysauce> if I had a specific program that I wanted to make fast, then yes
15:11:25 <soysauce> but right now I want to understand what GHC is good at optimizing and what it isn't
15:11:37 <SamB> ...
15:11:43 <soysauce> what?
15:12:00 <SamB> that sounds like a silly thing to do.
15:12:03 <Korollary> soysauce: haskell is much farther away from a machine description than C++. It is pretty hard to judge what it is good at without knowing the language inside out, imho.
15:12:17 <soysauce> Korollary - one must start somewhere
15:12:18 <SamB> you could at least re-implement Prelude functions and wonder why they are slower or something!
15:12:21 <soysauce> and plus this is fun
15:12:28 <SamB> more fun is to DO things
15:12:32 <soysauce> SamB - have done that already ;)
15:12:39 <Korollary> ah let him be, SamB heh\
15:12:39 <SamB> Haskell supports that, you know, unlike C and C++
15:12:48 <soysauce> supports what?
15:13:04 <SamB> getting things done ;-)
15:13:09 <soysauce> oh, right
15:13:51 <soysauce> I have found writing Haskell to be very fun
15:14:00 * SamB returns to his efforts to re-implement Lout in Haskell
15:14:09 <soysauce> but I don't think I could embark on any serious personal projects, unfortunately
15:14:22 <SamB> try a funny project, then ;-)
15:14:27 <Cale> what is Lout currently implemented in?
15:14:29 <soysauce> pfft!
15:14:30 <SamB> Pugs started that way, you know!
15:14:32 <SamB> Cale: C
15:14:36 <Cale> Really?
15:14:48 <SamB> Cale: really
15:15:00 <Korollary> soysauce: I've been learning ocaml for some projects that may require more practicality.
15:15:06 <Cale> I'd think something as functional as that would be in an ML variant at least
15:15:33 <SamB> well, why do you think I am trying to re-implement it?
15:15:34 <soysauce> Korollary - I have done a *little* with SML. I presume that it's similar...
15:15:52 <soysauce> would be fun to mess with that, too
15:16:08 <Korollary> soysauce: ocaml is strict with side effects but no type classes (and butt ugly syntax)...
15:16:15 <stepcut> Korollary: I think we are about to switch from ocaml to haskell at work for our practical programs...
15:16:31 <Korollary> stepcut: where do you work ?
15:16:37 <stepcut> Korollary: linspire
15:16:43 <soysauce> weird
15:17:10 <dons> SamB, any other hmp3 issues?
15:17:17 <Korollary> stepcut: how much code is there ?
15:17:18 <dons> in the last 12 hours
15:17:23 <soysauce> I'm biased, but my professor wrote a Java program that ran circles around our Haskell programs. I presume some degree of slowness came from the fact that none of us are wizards with the language, but I suspect a larger portion came from the compiler/language itself...
15:17:50 <soysauce> it's a lot of fun, but just too slow
15:17:55 <SamB> dons: not in the last 4:30
15:18:05 <Cale> Languages aren't slow, but compilers might produce slow code
15:18:08 <dons> excellent, Sam.
15:18:13 <Korollary> soysauce : programs with heavy array usage are pretty slow in ghc.
15:18:18 <stepcut> Korollary: a fair bit -- the hardware detector, the iso build process, various web services, other stuff...
15:18:19 <dons> my neither in the last 18.
15:18:39 <soysauce> Cale - at some level the language dictates performance
15:18:59 <Korollary> stepcut: actually I was thinking that haskell would be good for iso and package build kind of stuff where correctness matters.
15:19:06 <SamB> soysauce: what did the programs do?
15:19:24 <SamB> and do you have any idea how long it takes to write programs in Java at all?
15:19:25 <stepcut> Korollary: yeah -- the iso stuff have gone from bash -> ocaml -> haskell (in progress)
15:19:27 <MarcWebe1> dons: I get this error during configure of hmp3: cannot satisfy dependency fps-any 
15:19:33 <soysauce> solved a problem: http://www.cs.fit.edu/~ryan/fun/ombrophobic.html
15:19:37 <soysauce> yes, I do
15:19:40 <soysauce> I hate writing Java
15:19:49 <soysauce> I would rather write C than Java. Any day.
15:19:49 <MarcWebe1> SamB: decades? :)
15:19:50 <dons> MarcWeber, chcek the README.
15:19:51 <dons> @where fps
15:19:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:19:56 <eivuokko> soysauce, Indeed! :)
15:20:02 <gzl> I'm the opposite. I'd rather write Java than C.
15:20:07 <SamB> MarcWebe1: has Java been around that long?
15:20:08 <soysauce> Java makes everything *horrifically* verbose.
15:20:08 <dons> bad gzl.
15:20:16 <gzl> :(
15:20:22 <soysauce> and the tools are terrible compared to what I have available for C/C++
15:20:23 <gzl> I just really don't like C.
15:20:38 <soysauce> C is not a good language. But there are worse ones out there.
15:20:57 <Cale> I think of writing C like C programmers think of writing assembler :)
15:21:02 <gzl> yes, but I so dislike it that I'm willing to put up with Java's verbosity
15:21:07 <SamB> C is a good language. If what you want is an assembly language where you can't be sure what anything does.
15:21:10 <gzl> I agree that it's absurdly verbose
15:21:23 <Cale> SamB: :)
15:21:25 <soysauce> in Haskell I can write an anonymous function. In C I can declare a new function in the same module. In Java I have to create a new module *and* a class.
15:21:29 <Korollary> stepcut: yeah, anything that's in bash or perl or python should be in ocaml or haskell.
15:21:40 <gzl> soysauce: ?
15:22:01 <stepcut> Korollary: pretty much -- we do GUI stuff in python right now because there are no ocaml or haskell bindings to KDE 
15:22:03 <soysauce> SamB - from that perspective, indeed, but as a language for application development it is really bad. A few *simple* changes would make it right decent.
15:22:09 <SamB> soysauce: couldn't you just use an anonymous class?
15:22:41 <SamB> simple changes would make C a good application development language?
15:22:45 <dons> @remember SamB C is a good language. If what you want is an assembly language where you can't be sure what anything does
15:22:55 <soysauce> decent, not particularly excellent
15:23:00 <soysauce> dons :)
15:23:40 <Korollary> stepcut: exactly why are you switching from ocaml to haskell btw ?
15:23:44 <soysauce> SamB - 3rd parties have created add-ins which implement features such as array bounds checking and garbage collection, but they aren't standard.
15:23:53 <SamB> ah
15:24:05 <eivuokko> Uh.  You call that making C better?
15:24:12 <soysauce> and there is a well-known hack garbage collector for C++. I forget the name.
15:24:13 <SamB> GHC's GC is faster than Boehm's
15:24:21 <soysauce> eivuokko - I call that making it reasonable.
15:24:28 <soysauce> not being able to trample over memory is reasonable.
15:24:36 <soysauce> yes, the Boehm GC, that's what I was referring to
15:24:42 <SamB> thats for C too
15:24:51 <soysauce> the Boehm GC, as I understand, simply traverses the raw memory and looks for things which "probably are pointers"
15:24:53 <SamB> well, maybe its not the GC that is faster
15:25:06 <Heffalump> soysauce: yes, but if your program follows the C standard then it will be successful
15:25:12 <soysauce> eivuokko - I am being terse here and saying C, but really I mean C++
15:25:12 <Heffalump> (IIRC)
15:25:25 <SamB> lets just say that the C implementation of Unlambda runs faster when translated into the obvious Haskell equivalent
15:25:26 <soysauce> Heffalump - what does "successful" have to do with "easy and efficient for development"?
15:25:28 <eivuokko> soysauce, the arrays are fine, but they give false security, because without extensive whole program analysis it is impossible.  Garbage collection I don't count as specially good thing.
15:25:52 <eivuokko> soysauce, C and C++ have nothing much in common in application real (quality) application developement imo.
15:25:59 <stepcut> Korollary: the ocaml libraries are pretty stagnated compared to haskell (especially in the last few years) and things like type classes are very useful
15:26:05 <soysauce> eivuokko - I'm not fond of garbage collection either, *but* it can be a lesser evil
15:26:16 <stepcut> Korollary: compare Data.List to the ocaml list module, for example
15:26:41 <stepcut> Korollary: and then new stuff like Data.Map 
15:27:07 <soysauce> eivuokko - in an ideal world where programmers were actually competant, I would be disdainful of garbage collection. However, time and time again I read about the latest buffer overflow exploits.
15:27:16 <Korollary> stepcut: It's a bit surprising actually, that the impure ml variant is lagging behind.
15:27:18 <soysauce> and it's usually something absurdly simple
15:27:19 <stepcut> Korollary: It's not a hard switch -- we are just going to develop new apps in haskell and the ocaml ones will eventually phase themselves out
15:27:56 <soysauce> eivuokko - FWIW it is computationally impossible to guarantee program correctness with respect to arrays, but I don't care. I would rather the program crash gracefully than do the wrong thing.
15:28:02 <eivuokko> soysauce, Yeah, that is one view.  I am not sure it is a good view to compare languages.  If you assume bad programmer, it is hard to assume success.  Languages don't program.
15:28:12 <soysauce> I know.
15:28:19 <Cale> I hope that GHC eventually gets as good as the ocaml compiler at producing efficient code
15:28:24 <soysauce> but the language should assist the programmert
15:28:26 <soysauce> -t
15:28:46 <soysauce> in C and C++ it is essentially impossible to implement things like garbage collection without compiler support
15:28:59 <stepcut> Cale: would be nice! Though it is a much hard problem
15:29:00 <Korollary> Cale: I don't think that the ocaml compiler is particularly good. It's just that the language allows side effects.
15:29:17 <soysauce> and, more importantly, C and C++ allow you to shoot yourself in the foot, hence why I think they make poor application development languages
15:29:32 <soysauce> I cannot count the number of times I have seen someone ask this:
15:29:35 <soysauce> char *p;
15:29:39 <SamB> if you assume mistake-prone programmer, that works better
15:29:42 <soysauce> cin >> p; // why does my program crash here?
15:29:43 <SamB> because most are
15:29:57 <stepcut> I sometimes feel like OCaml is just a better version of C...
15:30:02 <SamB> the problem isn't that C and C++ let you shoot yourself in the foot.
15:30:05 <Korollary> stepcut: so do I
15:30:07 <SamB> its that they make it so EASY
15:30:32 <MarcWebe1> SamB: I did a lot.. ;)
15:30:38 <soysauce> SamB - it's more that they permit a certain class of errors to go undetected which should have been made obsolete *years* ago
15:30:51 <Cale> Korollary: surely that's not an excuse :) It ought to be possible to compile away most of the extra junk involved in monadic IO.
15:31:01 <soysauce> I don't care so much that some guy can crash his program by accessing beyond the end of an array
15:31:05 <soysauce> I care that it goes undetected
15:31:11 <Korollary> SamB: no one points a gun at your head to write C code. The primary reason C exists is to be able to mess with data in memory for device drivers, etc.
15:31:20 <SamB> soysauce: well, you can do that with GHC too
15:31:43 <soysauce> SamB - and it can go undetected?
15:31:52 <SamB> but you need to use the word unsafe, unless you are using Ptrs
15:32:00 <Korollary> Cale: It's also about strictness. IO [Char] is pretty insane.
15:32:17 <Cale> Korollary: well, we do need proper Strings anyway
15:32:42 <dons> @where fps
15:32:42 <dons> ;)
15:32:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:32:49 <Korollary> hurray !
15:33:02 <Cale> I think that ++ should be part of a monoid class.
15:33:05 <soysauce> "proper Strings"?
15:33:12 <soysauce> I thought Haskell's implementation was rather elegant
15:33:14 <Cale> soysauce: not lists of Chars
15:33:26 <Cale> soysauce: it's elegant to an extent
15:33:35 <Cale> but it's hard to optimise
15:33:39 <Korollary> soysauce: it's elegant and expensive heh
15:33:55 <Cale> also, it has problems with things like Unicode
15:33:57 <Korollary> soysauce: akin to std::List<char>
15:34:01 * stepcut The fact that String = [Char] is one of the top 5 reasons why I like haskell better than ocaml
15:34:17 <Heffalump> it does make it pretty inefficient, though
15:34:44 <Cale> What we need is a library/language support that makes sequences which aren't lists as convenient as lists.
15:34:54 <soysauce> *nods*
15:34:57 <soysauce> Korollary - yes, I know
15:35:12 <soysauce> Cale - perhaps if you could do [Char#]
15:35:21 <soysauce> I understand why that doesn't work, though
15:35:21 <dons> we need a little rhyme about how [Char] is good for fun, but not for everyone
15:35:28 <Korollary> lol
15:35:49 <Cale> The other problem is that sometimes you really do want lazy strings
15:35:56 <stepcut> If next generation haskell strings where as convenient as [Char] *and* supported Unicode -- that would be sweet
15:35:59 <Korollary> is a string an array or a list ? it all depends on how you treat it.
15:36:20 <soysauce> is Char 8-bit?
15:36:29 <dons> unicode. 
15:36:30 <Cale> Char is unicode already
15:36:32 <dons> it's actually 32
15:36:38 <soysauce> ouch.
15:36:42 <dons> in ghc.
15:36:50 <soysauce> well, that should make it easy to deal with Unicode -- just use UCS-32
15:36:51 <SamB> Cale: the other problem is that decent sequence interfaces are a research problem
15:37:05 <SamB> soysauce: in Strings, yeah
15:37:06 <Cale> SamB: yeah
15:37:14 <SamB> in files, UGLY
15:37:35 <stepcut> hxt has a unicode library -- but I have only used it a tiny bit
15:37:43 <soysauce> how so?
15:37:45 <Frederick> Cale, I think I cant use the schema you gave me
15:37:48 <Cale> How about this: generalise the idea of a constructor -- allow custom constructors on a type, like views.
15:37:57 <stepcut> I have wondered if it would be useful to split that part of HXT out into a seperate library
15:38:03 <SamB> soysauce: well, do you really want to have endianness issues with textfiles?
15:38:12 <Cale> That would make writing recursive functions on sequences easier
15:38:13 <soysauce> *nods* I see
15:38:16 <SamB> anyways, utf-8 is the way to go for files
15:38:25 <soysauce> yeah
15:38:29 <SamB> Cale: this idea has been seen before
15:38:39 <SamB> Cale: no idea why it has not been implemented yet!
15:38:47 <Cale> Of course, if cons isn't efficient, it'll hurt
15:38:48 <SamB> or at least, not in mainline GHC
15:39:10 <stepcut> plus most archaic unix tools can sort of deal with utf-8 -- but nulls in the middle of the text file break them
15:39:19 <SamB> anyway, its SO hard to design a good set of collection interfaces that is also inclusive
15:39:21 <Cale> but perhaps there are good things which could be done...
15:39:26 <Cale> hmm
15:39:32 <Korollary> Cale: You mean making String a kind that has multiple types ?
15:39:39 <Frederick> SamB, Cale you folks showed me how to split the list using partition, is it a good idead to replace the productions in timeof evaluation in that grammar or shoukd I create a copy of it?
15:39:58 <Cale> Korollary: well, sure
15:40:10 <Cale> A class, say
15:40:15 <Cale> more generally, sequences
15:40:17 <soysauce> stepcut - so upgrade from archaic UNIX tools to a UTF-8 aware system
15:40:18 <soysauce> ;)
15:40:34 <stepcut> soysauce: GNU Hurd/l4 ?
15:40:38 <Cale> Arrays, lists, ordered trees
15:40:40 <soysauce> haha
15:40:47 <Korollary> Cale: have you read this paper ? http://lambda-the-ultimate.org/node/view/1115
15:40:48 <stepcut> GNU Hurd/l4 is going to be pretty sweet
15:40:50 <soysauce> IMO a functional shell would deprecate all of the UNIX tools anyway
15:41:01 <stepcut> soysauce: h4sh ?
15:41:01 <soysauce> stepcut - so when are they going to finish? ;)
15:41:02 <Korollary> soysauce: ask dons about h4sh
15:41:06 <dons> @where h4sh
15:41:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
15:41:07 <Cale> Korollary: partly
15:41:24 <gzl> I'm still not sure about typing pipelines
15:41:29 <dons> lazy lists.
15:41:35 <gzl> ?
15:41:37 <stepcut> soysauce: just in time for ghc 15.4
15:41:46 <dons> a pipe is a lazy list of 'a'
15:41:59 <dons> check out the Clean shell, on typed pipes and typed fs
15:42:06 <gzl> yeah, I've looked at that
15:42:10 <stepcut> I should write my damn unix pipes article for TMR
15:42:13 <gzl> the problem with that is that it doesn't run normal binaries
15:42:26 <SamB> the worst part is that it is a TYPE research problem
15:42:31 <gzl> it's just a Clean toplevel that can save snippets of Clean code as files
15:42:38 <gzl> which is kind of cool, but not at all practical
15:42:40 <soysauce> dons - incomplete...?
15:42:44 <Cale> Korollary: is there a particular section which you're pointing at?
15:42:55 <soysauce> it would make *more* sense for the shell to be a Haskell interpreter, i.e. GHCi
15:43:00 <soysauce> or Huge.
15:43:02 <soysauce> Hugs, rather
15:43:11 <soysauce> Hugs in the sense of really not needing to compile
15:43:25 <Korollary> Cale: No, I was just surprised by that paper and thought that maybe String could be abstracted farther into the kind land.. "Maybe".
15:43:27 <stepcut> soysauce: not neccesarily -- haskell is much more verbose than bash
15:43:46 <soysauce> stepcut - "much more" seems excessive, but yes, to some extent
15:43:49 <Cale> Korollary: I think a typeclass would be sufficient
15:44:00 <soysauce> it is also "much more" elegant than bash ;)
15:44:09 <stepcut> soysauce: doing 'ls -l *.mp3' is a fair bit easier to type than 'ls ["-l","*.mp3"]'
15:44:13 <soysauce> and probably, even when interpreted, "much more" faster
15:44:21 <Korollary> Cale: but, what type does hGetLine return ? the array or the list ?
15:44:34 <dons> SamB, just added regex searching of the playlist.
15:44:36 <soysauce> stepcut - filter (pat '*.mp3') dir
15:44:41 <soysauce> or something
15:44:59 <Cale> Korollary: hGetLine :: (Sequence s) => IO (s Char)
15:45:04 <stepcut> soysauce: I think it would be better to write a custom interactive haskell shell that can use hs-plugins to eval haskell code
15:45:16 <soysauce> actually just go all the way and put pattern-matching into the language as it is in perl
15:45:17 <Cale> or even further, hGetLine :: (String s) => IO s
15:45:29 <gzl> dons: does it really make sense to try to typecheck pipelines when most of the binaries people will have on their systems won't have any real type information?
15:45:47 <soysauce> stepcut - it would be more terse for sure.
15:45:53 <Korollary> Cale: that looks possible
15:45:54 <soysauce> but more elegant the way that I am proposing. ;)
15:45:55 <dons> gzl, not sure.
15:45:59 <Cale> Korollary: probably with some SPECIALISE pragmas
15:46:00 <dons> sounds like a good research projcet though.
15:46:11 <gzl> maybe. I can't make up my mind.
15:46:25 <soysauce> many of the things which happen "magically" behind your back such as expansion of *.mp3 into a list of files would simply no longer need to happen
15:46:27 <dons> or everthing is just [Char] that doesn't supply a type
15:46:55 * dons off to yum cha
15:47:01 <stepcut> gzl: It turns out that for most currently unix programs that type is [String] -> [String]
15:47:15 <soysauce> um... s/most/all/?
15:47:25 <soysauce> and s/[String]/String/
15:47:29 <Korollary> [String] -> ([String], [String])
15:47:34 <soysauce> yes
15:47:40 <soysauce> but it's not a list, it's a single String
15:47:48 <Korollary> wah
15:47:50 <Axioplase> Cale: Korollary : just to tell that I've managed to understand how to do my Render() with Cairo.
15:47:53 * Korollary loses the []
15:47:55 <stepcut> soysauce: no.. xmllint, for example, might be considered to have the type XML -> XML (for some combinations of command line options)
15:48:02 <Cale> Axioplase: :)
15:48:10 <Korollary> Axioplase: Nice going.
15:48:21 <soysauce> stepcut - yes, that is possible, but as of this very moment the type is still String -> String
15:48:26 <stepcut> soysauce: many things like sed, awk, grep, are line oriented -- so a I think the type [String] -> [String] is really more appropriate
15:48:26 * Cale tries desperately not to use his right thumb to type space
15:48:31 <soysauce> because that is how UNIX started, and nobody has improved upon that
15:48:52 <Cale> Programs should be typed :)
15:48:57 <soysauce> Cale - yes, I agree
15:49:01 <stepcut> soysauce: yes, technically the type is always String -> (String, String) since that is all you can send through pipes
15:49:08 <soysauce> but to this very moment they still are not
15:49:39 <Korollary> 'dynamic' typing sounds sooo cool, though. You can mutilate an object until it's not recognized by its mother.
15:49:47 <soysauce> haha
15:49:53 <stepcut> I wrote a library for doing unix like pipelines in haskell -- I used phantom types so that you could assign a 'type' to each end of the pipe -- but in practice I never found that useful
15:49:53 <Cale> It would take quite a lot of work to do that. Every program would have to be aware of this typesystem. Do we make it HM?
15:50:03 <soysauce> I want to better understand monads so that I can write a useful interpreter, heh
15:50:29 <stepcut> because things like 'awk, sed, ls, etc' are pretty much just line oriented filters
15:50:35 <Cale> soysauce: well, did you read my article? It's a good intro before "All About Monads"
15:50:42 <soysauce> Cale - it would require completely rethinking the system from the ground up since UNIX is already based on the whole concept of String -> (Int, String, String)
15:50:55 <Spark> Cale: which is your article?
15:51:01 <soysauce> Cale - yours was the one about "Monads are computation *and* containers"?
15:51:03 <Cale> Spark: MonadsAsContainers
15:51:08 <soysauce> yes, I read that
15:51:11 <Spark> ah right that wasnt the one i read
15:51:11 <soysauce> it was very helpful
15:51:22 <stepcut> soysauce: even worse, if you try to read Int before you consumed all the output of String -- you will deadlock
15:51:37 <soysauce> but now that I have a basic grasp of what a monad is, I need to understand the mechanics of implementing one, and that's totally separate.
15:51:38 <Cale> It's good to understand them as containers, and then extend that idea to computations :)
15:51:39 <Frederick> Cale, you mentioned it might be usefull to zip the productions against the list again, what would be the point of that?
15:51:50 <soysauce> stepcut - er? That's not even possible
15:52:08 <soysauce> stepcut - UNIX isn't lazy. ;)
15:52:19 <Cale> Frederick: I meant to tag each production with its length, but that actually seems unnecessary here
15:52:20 <stepcut> soysauce: sure it is, fork off the process, and do getpid on the pid 
15:52:25 <soysauce> but even in Haskell you can't read the return value from a function *before* it returns
15:52:26 <stepcut> s/getpid/waitpid 
15:52:34 <soysauce> stepcut - oh, I meant the return value, not the PID
15:53:03 <soysauce> the PID is neither input nor output
15:53:14 <stepcut> soysauce: right, but waitpid is how you get the return value
15:53:14 <Cale> I have the problem that I almost always type space with my right hand, and it's getting to me.
15:53:22 <Frederick> Cale, hm, so what sould I look for?
15:53:26 <soysauce> ah, okay, true
15:53:35 * soysauce is sleepy
15:53:49 <Cale> Frederick: well, you have the productions chopped up into two now -- do what you need to do to the long ones
15:53:51 <soysauce> need...caffeine...
15:54:05 <stepcut> soysauce: also, keep in mind that if the program is interactive -- you have to feed it stdin, then read some stdout, then feed it more stdin, then read stdout, or you can end up blocked
15:54:12 <gzl> stepcut: sure, but how do you know what the type of some random program is?
15:54:18 <Frederick> Cale, what do you mean?
15:54:31 <Frederick> Cale, I was unable to craft anything =/
15:54:36 <gzl> stepcut: if you go through and manually analyze each one and hardcode its type...
15:54:51 <soysauce> stepcut - monads? ;)
15:55:11 <soysauce> gzl - in the present system you simply *can't*.
15:55:12 <stepcut> gzl: right -- that is the problem with unix -- programs are untyped and can spit out anything they want at any time
15:55:17 <gzl> soysauce: right.
15:55:40 <gzl> yes, but that's my point. how are you going to reasonably typecheck untyped programs? and if you can't, why even typecheck that stuff?
15:55:59 <gzl> er, that second question doesn't make sense. ignore it.
15:56:04 <soysauce> gzl - one of the ideas that went into the design of Windows back in the late 80s, and I am referring to Windows NT rather than its bastard cousin, was similar.
15:56:17 <gzl> what idea?
15:56:33 <soysauce> that programs should communicate in raw bytes which can be type checked at compile-time rather than through strings
15:56:39 <stepcut> soysauce: what about monads? You as the programmer still have to make sure you are feeding the program with stdin at the right time, reading stdout at the right times, and not checking the return code before the program has exited -- and if you do anything wrong you will likely deadlock
15:57:02 <soysauce> not to mention is faster, reduces error cases, and tighter
15:57:08 <stepcut> soysauce: you said that we need to think the unix model -- and I am agreeing -- the unix model is *very* tricky and error prone
15:57:20 <soysauce> I didn't say the UNIX model, specifically
15:57:22 <stepcut> soysauce: it is a deadlock nightmare 
15:57:26 <soysauce> more like computing in general
15:57:40 <gzl> soysauce: if you do that, can you be sure that any two arbitrary programs can be piped together?
15:57:44 <soysauce> having typed programs would be really slick.
15:57:51 <soysauce> that would *imply* typing of the file system
15:58:00 <soysauce> gzl - I'm sure that they couldn't
15:58:23 <Cale> well, not necessarily, but basically
15:58:31 <gzl> then why's it worth doing?
15:58:39 <Cale> you'd definitely want the filesystem to be typed
15:58:41 <soysauce> stepcut - monads can sequence computation which means that you can partially evaluate the program and then provide more input
15:59:00 <soysauce> gzl - because it doesn't restrict you in any limiting way
15:59:08 <soysauce> and because strong typing is good
15:59:09 <Cale> soysauce: this is already done
15:59:12 <soysauce> and elegant
15:59:20 <soysauce> Cale - which exactly?
15:59:32 <Cale> unix already does partially evaluate the result of programs
15:59:39 <soysauce> oh, well of course
15:59:48 <soysauce> but we were talking about programs as functions
16:00:38 <stepcut> soysauce: you might find that arrows are a better mechanism than monads in this case
16:00:56 <soysauce> gzl - I'm having trouble coming up with something useful that wouldn't function in that system
16:01:14 <soysauce> stepcut - maybe, but I don't know anything about arrows... I'm still quite new to Haskell
16:01:55 <Cale> Well, if you had an OS with a full blown Haskell typesystem, then you'd have monads, arrows, whatever you liked.
16:02:12 <soysauce> yeah
16:02:30 <Cale> I wonder if house/hop have anything like that
16:02:53 <soysauce> I saw a Java OS project once. Initially I thought it was retarded, but I stopped to think about it and realized that it wasn't a half-bad idea after all.
16:02:56 <stepcut> soysauce: One model of computation is arrows and stream processors -- you could probably make the stream processors be dynamically loaded
16:03:32 <soysauce> the reason being that, since the kernel could make guarantees on a certain level of program correctness, there was no need to involve the hardware to verify programs
16:03:38 <Cale> soysauce: the first OS course at Waterloo uses Java
16:03:46 <Heffalump> soysauce: apart from the need for a JVM, of course..
16:03:47 <soysauce> which can make poorly written code significantly faster
16:03:54 <soysauce> Heffalump - the JVM becomes the OS
16:04:08 <soysauce> but in this particular case, the OS itself was written in Java and so *everything* ran inside the JVM
16:04:09 <Heffalump> ah, right.
16:04:10 <stepcut> soysauce: if you can find more information about that stuff -- that might interested -- you can not map the existing unix process model into the stream processor/arrows system -- but if you want to completely dump the unix model for something better...
16:04:15 <Cale> the second uses generally something lower level, as everyone writes a real-time OS
16:04:19 <Heffalump> so the idea is that you don't need an MMU
16:04:19 <soysauce> but it was vaporware. I don't think they ever wrote a line of code.
16:04:23 <Heffalump> if you trust your JVM
16:05:00 <soysauce> Heffalump - you do need an MMU if you want to implement virtual memory; there is no way around that
16:05:23 <Heffalump> what other hardware protection is there?
16:05:41 <soysauce> the distinction between user mode/kernel mode
16:05:57 <Heffalump> oh yeah :-)
16:06:18 <stepcut> Heffalump: brixOS (appears dead now) uses that security model -- all system software is distributed in safe byte-code form -- and the install process compiles it to native object code
16:06:20 <soysauce> on x86 there are 3 different mechanisms to cross that boundary. The most elegant one costs 150 cycles. The second costs 90 cycles. The third costs 40 cycles.
16:06:34 <Axioplase> hum.. How do I use randomIO? (or any random func that returns a Double without having to give it a seed)
16:06:40 <soysauce> on modern Athlon64/Opteron processors. Intel never documents their shit because it's so slow, so I don't know what figures are for them.
16:07:01 <soysauce> <sarcasm>multiply everything by 3 and you probably have a ballpark figure</sarcasm>
16:07:40 <soysauce> stepcut - not a bad idea, but makes assumptions that might not be so nice.
16:07:52 <stepcut> soysauce: such as ?
16:07:57 <soysauce> I could, for instance, pull your harddrive and load it full of virii
16:08:10 <rep> soysauce the number of cycles depends on the cpu.
16:08:10 <soysauce> from an OS that does not have such a restriction
16:08:16 <soysauce> rep - I am well aware of that
16:08:27 <rep> i don't doubt it
16:08:37 <stepcut> soysauce: sure -- that is true of all operating systems -- though encrypted drives can help prevent that
16:08:41 <Korollary> Axioplase: Check out System.Random.
16:08:58 <soysauce> rep - I've done a *lot* of assembly optimization. I can look at a piece of x86 code and analyze the execution time for 4 or 5 x86 CPUs. ;)
16:09:08 <rep> soysauce ok
16:09:12 <Korollary> soysauce: sorry to hear that :)
16:09:21 <soysauce> Korollary - actually assembly is a lot of fun
16:09:30 <Cale> Axioplase: you have to run it from the IO monad -- are you familiar with IO in Haskell?
16:09:50 <Korollary> soysauce: Not with the amount of detail to remember nowadays.
16:10:08 <Cale> Axioplase: n <- randomIO :: IO Integer
16:10:09 <soysauce> Korollary - it hasn't changed substantially in 20 years
16:10:28 <soysauce> there are maybe 5 or 6 new instructions worth knowing about.
16:10:38 <Axioplase> Cale: no I'm not at all :)
16:10:46 <Cale> you can forgo the typesig if the type of n is determined elsewhere
16:10:47 <Korollary> soysauce: ??? With the sophisticated caches, branch prediction, out of order execution, etc ?
16:11:00 <Cale> Axioplase: perhaps read...
16:11:06 <soysauce> Korollary - yes, I see... well, it's not that complicated
16:11:15 * stepcut had to write a text-based graphical quick-sort in asm for a class once...
16:11:25 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
16:11:27 <soysauce> it took me less than a year to become an "expert" about AMD K7, and it turns out that AMD K8 is approximately the same CPU.
16:11:28 <Axioplase> Cale: I've been reading for two days now. maybe not the right things though.
16:11:38 <Cale> Have you read that?
16:11:57 <soysauce> Korollary - the caches aren't very sophisticated; just big. And you don't really take them into account usually.
16:12:25 <soysauce> Korollary - as for branch prediction, that is probably 2/3 of the fun
16:12:39 <Korollary> soysauce: ugh. I don't have a year to spend on any arch :)
16:12:55 <soysauce> for most algorithms you can replace an unpredictable branch with computation. Sometimes it runs approximately as fast.
16:12:57 <SamB> soysauce: why, then, are Linux kernel structs organized to put frequently-accessed or accessed-together members in the same cache line?
16:13:28 <Axioplase> Cale: not yet. I am
16:13:47 <Cale> Axioplase: tweaked the working ever so slightly, so possibly reload :)
16:13:52 <Cale> wording*
16:14:00 <soysauce> Korollary - not a year dedicated to learning. It really isn't that complicated.
16:14:32 <soysauce> SamB - unless the structures are hundreds of bytes in size, they probably fit completely in a cache line already
16:14:43 <Korollary> soysauce: I know. I've done motorola 68k and 486 assembly back in the day. Just not interesting anymore.
16:14:44 <SamB> soysauce: how big is a cache line on K7?
16:14:59 <soysauce> SamB - 64 bytes. 128 bytes on Pentium-4.
16:15:28 <SamB> soysauce: oh, those are pretty nice sized
16:15:32 <soysauce> yes
16:15:45 <SamB> but still, there are probably some pretty big structs in the kernel...
16:16:05 <Korollary> SamB: They don't all have to fit in one line anyways.
16:16:14 <SamB> Korollary: no, of course not!
16:16:16 <soysauce> it does make sense to group frequently-accessed data together...
16:16:41 <Cale> Axioplase: I hope that's useful, if not, I might be able to provide more details :)
16:16:43 <soysauce> GCC is so bad that I don't know that it really makes a difference
16:16:45 <Korollary> soysauce: you should write a cminusminus compiler in haskell.
16:17:07 <soysauce> cminusminus? Is that a play on C++ or is there a language called that?
16:17:15 <Korollary> @google cminuminus
16:17:15 <lambdabot> No result found.
16:17:20 <Korollary> are you kidding me
16:17:24 <soysauce> @google cminusminus
16:17:25 <Korollary> @google cminusminus
16:17:26 <lambdabot> http://www.cminusminus.org/
16:17:26 <lambdabot> http://www.cminusminus.org/
16:17:27 <Heffalump> :-)
16:17:33 <soysauce> yes, I saw that :p
16:17:40 <Cale> It's a portable assembly language
16:17:41 <soysauce> so what is it? Something akin to D?
16:17:41 <Korollary> ah, it's the "did you mean <...>" 
16:17:42 <SamB> c--
16:17:46 <soysauce> haha I see
16:17:59 <SamB> anyway, there is already most of a compiler in Haskell ;-)
16:18:16 <Korollary> SamB: I think the existing compiler is in ocaml
16:18:26 <SamB> Korollary: you hadn't heard?
16:18:33 <Korollary> apparently not
16:18:39 <Korollary> whatd I miss ?
16:19:00 <SamB> some of GHC's RTL is written in C--, plus GHC uses a C-- variant as an IR for code generation
16:19:28 <Korollary> SamB: I know that ghc produces c--
16:19:44 <SamB> Korollary: does it have an option for that?
16:20:18 <SamB> but the point is, how do you suppose the RTL files written in C-- get compiled?
16:20:24 <SamB> er, RTS
16:20:42 <Korollary> SamB: During the ghc build ? I don't know 
16:21:19 <SamB> Korollary: well, if you were using C-- as an IR in your compiler and wanted to compile some C-- for its RTS, what would YOU do?
16:22:01 <Korollary> what is IR ?
16:22:12 <Cale> Intermediate representation?
16:22:53 <SamB> yeah
16:24:34 <Cale> Some of the ideas going into jhc seem really cool. I wonder if John has much else online about them... Last I heard, there was a neat use of carrying the monadic abstraction down to the code generation level which enabled some neat meaning-preserving transformations.
16:24:37 <Korollary> I'd suppose you'd need a c-- compiler somewhere. 
16:25:34 <SamB> Korollary: well, alls you gotta do is add a C-- parser to your compiler, and you've got a C-- compiler!
16:25:42 <SamB> (almost)
16:28:48 <soysauce> uh what the heck
16:28:54 <soysauce> I ran out of stack space on tail recursion?
16:29:02 <skew> I have a few questions about MLF, if anyone is familiar with the type system
16:29:09 <SamB> soysauce: maybe it wasn't the genuine article
16:29:12 <Cale> soysauce: yep
16:29:17 <Cale> let's see the code
16:29:21 <Cale> it can easily happen
16:29:25 <soysauce> ok, but it's ugly
16:29:37 <Cale> okay, then perhaps a simpler example will help
16:29:41 <soysauce> where do you usually paste?
16:29:49 <Korollary> @paste
16:29:49 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:29:50 <Cale> > foldl (+) 0 [1..1000000]
16:29:52 <lambdabot> Stack overflow
16:30:07 <soysauce> huh how do you get stack overflow there?
16:30:10 <Cale> This is because:
16:30:22 <soysauce> oh, add seq and it fixes it, doesn't it
16:30:25 <Cale> yes
16:30:51 <Cale> because you're getting a huge expression with lots of +'s which isn't being evaluated until the end
16:30:55 <soysauce> right
16:31:03 <soysauce> is there any way to force the parameters of a function to be evaluated completely?
16:31:05 <Cale> use foldl' or seq to fix it
16:31:26 <Cale> Control.Parallel.Strategies has a function called rnf
16:31:27 <skew> but seq only works to force some things to get evaulated when the whole thing is needed, right?
16:31:34 <Cale> which will fully evaluate some things
16:31:48 <soysauce> skew - it can evaluate sub-expressions
16:31:48 <Heffalump> look at DeepSeq
16:32:02 <Cale> rnf is DeepSeq and it's in the libraries already
16:32:15 <skew> like, (+) is already strict, and writing foldl (\x y -> (+) $! x $! y) 0 [1..1000000] doesn't help
16:32:22 <Cale> I only wish NFData were derivable
16:32:55 <skew> have you tried making one from Data, or with TH?
16:32:55 <soysauce> blah.
16:33:18 <soysauce> test1' x y = if x == 0 then y else test1' (seq x (x-1)) (seq y (x+y))
16:33:24 <soysauce> that would avoid the problem, no?
16:33:56 <Cale> you have to modify foldl
16:34:14 <Cale> It's a problem with foldl not evaluating its argument
16:34:23 <Cale> not with the parameter to foldl at all
16:34:34 <skew> testing x == 0 already makes sure that x is evaluated by the time you reach a branch
16:35:00 <Cale> the problem is that the foldl gets to the end and you have something which it's a stack overflow to evaluate
16:35:16 <skew> if a function is strict in the argument, that just means that evaluating (f x) with evaluate x
16:35:36 <soysauce> this is true. Blah.
16:35:39 <Cale> there's no problem creating the huge ((((((...(((0 + 1) + 2) + 3) + ... + 1000000)
16:35:46 <soysauce> is there somewhere where I can see foldl' vs. foldl?
16:35:50 <soysauce> I want to see how they fix this problem
16:35:53 <Cale> the problem is evaluating that expression once you have it
16:35:57 <Korollary> probably in the report
16:36:05 <skew> not that storing f x somewhere, like let y = f x, will actually do the reduction
16:36:29 <skew> I've found the lack of an update' in Data.Map pretty annoying
16:36:38 <Cale> foldl' f a []     = a
16:36:38 <Cale> foldl' f a (x:xs) = (foldl' f $! f a x) xs
16:37:04 <soysauce> wow, Int64 is grossly inefficient
16:37:10 <stepcut> :p
16:37:11 <Cale> I imagine it is
16:37:28 <Cale> Just use Integer
16:37:31 <skew> don't you want = fold' f (f $! a x) xs?
16:37:42 <soysauce> I'm computing (n+1)*(n/2) via an O(n) evaluation
16:37:42 <skew> oh, I guess that's the same
16:37:47 <soysauce> for the express purpose of being slow.
16:37:59 <soysauce> using Int or even Int32 takes negligible time
16:38:07 <soysauce> Int64 is about 2 times faster than Integer
16:38:15 <Cale> skew: no, I don't think so.
16:38:28 <Cale> skew: you'll still have a crash like that
16:38:30 <soysauce> @type $!
16:38:30 <lambdabot> parse error on input `$!'
16:38:32 <skew> oh, right
16:38:35 <soysauce> @type ($!)
16:38:35 <lambdabot> forall b a. (a -> b) -> a -> b
16:38:36 <Cale> @type ($!)
16:38:37 <lambdabot> forall b a. (a -> b) -> a -> b
16:38:45 <Cale> @type seq
16:38:46 <lambdabot> forall b a. a -> b -> b
16:38:53 <skew> f $! x = x `seq` f x
16:38:58 <Cale> seq is magical though :)
16:39:15 <skew> it's actually implemented as id
16:39:22 <Cale> and by "magical", I mean "broken, but what the heck"
16:39:31 <soysauce> lol
16:40:05 <skew> actually const, but it has a type annotation that claims it's strict in the first argument
16:40:11 <Cale> the evaluation of a `seq` b evaluates a up to determining the top-level data constructor before resulting in b.
16:40:26 <soysauce> well, I am lost, I'm having trouble understanding how the $! fixes the problem exactly there. I understand it conceptually but not how to apply it.
16:40:34 <Cale> soysauce: okay
16:40:41 <Cale> so let's do a small example
16:40:46 <Cale> here's foldl:
16:41:21 <Cale> foldl f a [] = a
16:41:44 <Cale> foldl f a (x:xs) = foldl f (f a x) xs
16:42:10 <Cale> foldl (+) 0 [1,2,3] = foldl (+) (0 + 1) [2,3]
16:42:22 <skew> soysauce: are you using a 32-bit system?
16:42:22 <soysauce> and changing the second to foldl (f $! a x) xs causes it to evaluate on the way down instead of on the way up?
16:42:26 <Cale> = foldl (+) ((0+1)+2) [3]
16:42:27 <soysauce> skew - yes
16:42:33 <skew> data Int64 = I64# Int64#
16:42:34 <Cale> = foldl (+) (((0+1)+2)+3) []
16:42:40 <Cale> = (((0+1)+2)+3)
16:42:44 <soysauce> skew - but I am using == and +, so 64-bit ops should only be twice as slow.
16:42:47 <Cale> = ((1+2)+3)
16:42:52 <Cale> = (3+3)
16:42:54 <Cale> = 6
16:42:59 <Cale> that's how the evaluation goes
16:43:06 <skew> so I'm guessing it turns into a gcc long long, or something like that
16:43:11 <soysauce> oh, right, I meant to test Int64# but forgot
16:43:19 <soysauce> skew - that was my guess as well
16:43:19 <Cale> soysauce: make sense?
16:43:30 <skew> worker-wrapper and stuff should give you very little difference between the two
16:43:34 <soysauce> Cale - let me think about it for a moment
16:43:35 <Cale> do you see that large expression getting built up and saved to the end?
16:43:40 <skew> (if not, file a bug)
16:43:41 <soysauce> Cale - yes, I know about that
16:43:50 <Cale> foldl' f a []     = a
16:44:00 <Cale> foldl' f a (x:xs) = (foldl' f $! f a x) xs
16:44:08 <Cale> let's try it with this:
16:44:15 <soysauce> Cale - I understand *why* it's a problem. I just don't understand what effect $! has on the computation.
16:44:24 <Cale> I'm about to show you :)
16:44:27 <soysauce> ok
16:44:31 <soysauce> go on then
16:44:59 <Cale> foldl' (+) 0 [1,2,3] = (foldl' (+) $! (0 + 1)) [2,3]
16:45:11 <Cale> = foldl' (+) 1 [2,3]
16:45:31 <Cale> = (foldl' (+) $! (1 + 2)) [3]
16:45:39 <soysauce> Cale - ok, so let me try
16:45:41 <Axioplase> I'm a bit stuck. I wanted to generate some random [Double], and I got some random IO [Double] which I don't know how to get back..
16:45:44 <soysauce> (original) test1' x y = if x == 0 then y else test1' (x-1) (x+y)
16:45:56 <soysauce> Axioplase - (>>=)
16:46:08 <soysauce> Axioplase - you don't get a double back, but you can translate IO a -> IO b
16:46:24 <soysauce> Axioplase - which you can (eventually) transform into IO ()
16:46:27 <Cale> Axioplase: use xs <- myRandomIOList in a do-block
16:46:50 <Cale> Axioplase: more generally, read about monads and IO in Haskell
16:46:59 <Axioplase> Cale: ok thanks.
16:47:02 <Cale> because it's really not a short explanation :)
16:47:04 <palomer> watch out, I'm dangerous
16:47:10 <soysauce> Cale - so to fix my bug, I would write: test1' x y = if x == 0 then y else test1' (x-1) (($!) (+) x y)
16:47:12 <soysauce> yes?
16:47:25 <soysauce> is $! considered an operator?
16:47:29 <Cale> I recommend perhaps starting out with my article, MonadsAsContainers, on the wiki
16:47:33 <Cale> yes
16:47:38 <soysauce> ah
16:47:38 <SamB> soysauce: its a strange function
16:47:45 <soysauce> @eval (+) $! 1 2
16:47:46 <lambdabot>  add an instance declaration for (Show (a -> a))
16:48:06 <soysauce> oh, d'oh
16:48:12 <SamB> @type (+) $! 1 2
16:48:13 <lambdabot> forall a. (Num a, Num (Integer -> a)) => a -> a
16:48:16 <Cale> > ((+) $! 1) 2
16:48:17 <soysauce> @eval (+ 1) $! 2
16:48:18 <lambdabot> 3
16:48:18 <lambdabot> 3
16:48:31 <Cale> hehe, opposite versions of it :)
16:48:40 <Cale> > ((+) $! 1) $! 2
16:48:41 <lambdabot> 3
16:48:57 <Cale> these are all stupid uses though :)
16:49:07 <Cale> since there's no evaluation to be done beforehand
16:49:12 <soysauce> yes
16:49:14 <skew> soysauce: where did you put your code?
16:49:22 <Cale> I suppose there's implicitly a fromInteger, but that's nothing
16:49:29 <soysauce> I was more interested in syntax than semantics since that's not going to show me *how* it works
16:49:38 <soysauce> skew - ?
16:49:40 <soysauce> oh
16:49:42 <soysauce> I didn't paste it
16:49:48 <stepcut> hrm, it looks like hurd/l4 may be dropping the l4 part in favor of a different kernel..
16:49:52 <Cale> maybe it's easier to understand seq first
16:49:55 <SamB> soysauce: $! works by magic
16:49:59 <skew> because I doubt that test1' can fix things
16:50:03 <Cale> $! is just a convenience wrapper around seq
16:50:15 <soysauce> http://www.rafb.net/paste/results/19RP2u85.html
16:50:20 <Cale> SamB: I think I've pointed out that magic :)
16:50:26 <soysauce> they're all the same function, just different types
16:50:48 <soysauce> Cale - yeah, I see... but how would I force it to eval both parameters?
16:51:03 <soysauce> Cale - or is that necessary?
16:51:24 <skew> the thing about seq is that using it in the definition of a function can only make some extra stuff get evaluated first when you require the result of the function
16:51:32 <SamB> okay, so seq is the one with the magic
16:51:32 <Cale> else let a = x - 1; b = x + y in a `seq` b `seq` test1' a b
16:51:33 <SamB> observe:
16:51:44 <SamB> *Lexer> :i seq 
16:51:44 <SamB> seq :: a -> b -> b      -- <wired into compiler>
16:51:45 <Cale> or:
16:51:46 <skew> iterate f 0 !! 1000000 will build up a chain of a million thunks however f is defined
16:51:57 <SamB> (*Lexer is irrelevant)
16:52:09 <Cale> else (test1' $! (x-1)) $! (x+y)
16:52:31 <soysauce> Cale - ah, ok
16:52:55 <soysauce> this is unnecessary for primitives, yes?
16:52:59 <soysauce> since they can't be thunked
16:53:07 <skew> what are you doing with these test functions?
16:53:10 <Cale> for unboxed types yeah
16:53:18 <SamB> soysauce: impossible too
16:53:26 <SamB> wrong shape
16:53:29 <soysauce> skew - comparing performance of trivial operations on different integers
16:53:36 <soysauce> to check the effects of unboxing and so forth
16:53:40 <skew> are you running these in foldl, or what?
16:53:41 <SamB> observe:
16:53:42 <soysauce> SamB - *nods* yes that's what I thought
16:53:45 <soysauce> skew - no
16:53:50 <Cale> the let is generally marginally faster for the reason that you don't get an extra thunk with $!'s definition which immediately goes away, but optimisation will mostly take care of that
16:53:52 <skew> oh, these things are recursive
16:53:57 <soysauce> skew - yes, right
16:54:06 <skew> ok, yeah, puting seq in them can fix it up
16:54:12 <soysauce> the point is to eat a large number of cycles doing nothing particularly useful ;)
16:54:19 <SamB> *Lexer> GHC.Exts.I# $! 1#
16:54:20 <SamB> <interactive>:1:0:
16:54:20 <SamB>     Couldn't match kind `#' against `*'
16:54:20 <SamB>     When matching the kinds of `GHC.Prim.Int# :: #' and `a :: *'
16:54:36 <Cale> yeah, you can't seq already unboxed things anyway
16:55:05 <soysauce> yes, I was just making sure that I understood correctly Ñ=
16:55:08 <soysauce> :) rather
16:55:16 <soysauce> stupid Spanish keyboard mapping
16:55:16 <SamB> useless, and impossible ;-)
16:56:55 <Cale> nice how they used the kind system to prevent that :)
16:57:04 <SamB> yeah ;-)
16:57:26 <soysauce> hm
16:57:55 <skew> does anyone know where I can get a nice copy of Botlan's MLF thesis? I've only found a scanned one
16:58:45 <SamB> is Botlan still around?
16:58:57 <skew> still around?
16:59:10 <SamB> as in not dead
16:59:16 <SamB> or anything like that
16:59:23 <skew> as far as I know, why?
16:59:36 <SamB> wouldn't he likely have a copy?
17:00:25 <skew> that's an idea - I found some broken links along the lines of "here's my new page at another school with my thesis", so I figure there are copies around the internet anyway
17:01:42 <SamB> hmm. I suppose if you got ahold of a current email address, you would be able to easily locate the current page...
17:02:05 <Axioplase> Cale: I jsut don't get it. Here's what I have: http://rafb.net/paste/results/R4GvHE71.html
17:05:39 <soysauce> @index Int#
17:05:40 <lambdabot> bzzt
17:05:53 <soysauce> @index GHC.Exts.Int#
17:05:53 <lambdabot> bzzt
17:06:07 <soysauce> @index Data.Int.Int#
17:06:07 <lambdabot> bzzt
17:06:13 * soysauce sighs
17:06:21 <luqui> Axioplase, what's the error?
17:07:38 <Cale> Axioplase: that works fine for me
17:07:49 <Axioplase> luqui: luqui when I do mesPoints = take 100 (map pairToPoint [getRandList 100 , getRandList 100] ) I get: Couldn't match `([Double], [Double])' against `IO [Double]'
17:08:00 <Cale> Axioplase: there's your problem
17:08:24 <Cale> getRandList :: Int -> IO Double
17:08:29 <Cale> er
17:08:31 <Cale> getRandList :: Int -> IO [Double]
17:08:42 <Cale> it's an IO action
17:08:50 <Cale> you have to execute it to get the list
17:09:00 <Cale> which can only be done from an IO action, not a pure function
17:09:17 <soysauce> @type getRandList
17:09:17 <lambdabot> Not in scope: `getRandList'
17:09:22 <soysauce> hm...
17:09:26 <Cale> soysauce: it's his own function
17:09:28 <luqui> it's a function he's writing
17:09:33 <soysauce> yeah I just realized that.
17:09:40 <soysauce> what's the function to get a random IO Double?
17:09:48 <Cale> random
17:09:51 <Cale> er
17:09:52 <Cale> randomIO
17:09:53 <Axioplase> Cale: so, I must run getRandList inside a do block ?
17:09:57 <Cale> yes
17:10:00 <soysauce> @type randomIO
17:10:00 <lambdabot> Not in scope: `randomIO'
17:10:01 <skew> what is _getRandList supposed to build up?
17:10:03 <Cale> xs <- getRandList 10
17:10:09 <skew> it looks like it's using l a bit oddly
17:10:09 <luqui> randomIO :: IO a
17:10:16 <soysauce> @type IO.randomIO
17:10:17 <lambdabot> Not in scope: `IO.randomIO'
17:10:24 <luqui> er, (Random a) => IO a
17:10:37 <soysauce> @type Random.randomIO
17:10:38 <lambdabot> forall a. (System.Random.Random a) => IO a
17:10:38 <luqui> @type System.Random.randomIO
17:10:39 <lambdabot> forall a. (System.Random.Random a) => IO a
17:11:07 <soysauce> @type repeat 8 Random.randomIO
17:11:07 <Axioplase> Cale: I'm completely lost...
17:11:07 <lambdabot>   The function `repeat' is applied to two arguments,
17:11:07 <lambdabot>   but its type `a -> [a]' has only one
17:11:16 <soysauce> er, d'oh :p
17:11:23 <soysauce> @type replicate 8 Random.randomIO
17:11:24 <lambdabot> forall a. (System.Random.Random a) => [IO a]
17:11:40 <soysauce> @type (>>=) (replicate 8 Random.randomIO)
17:11:41 <lambdabot> forall a b. (System.Random.Random a) => (IO a -> [b]) -> [b]
17:11:44 <Cale> getRandomList n = do g <- newStdGen; return (take n $ randoms g)
17:11:47 <Cale> this is better
17:12:22 <Cale> er, hmm
17:12:40 <Cale> is that even what your function does?
17:12:41 <Cale> no
17:13:03 <luqui> Am I correct that this function is roughly equivalent (except that it generates an infinite list):
17:13:06 <skew> your _getRandList function is equivalent to drawing a list of random values, and then running it through (x:xs) -> x:concat (tails xs)
17:13:14 <soysauce> @type sequence (replicate 8 Random.randomIO)
17:13:15 <Axioplase> Cale: I just want to get an array of size n with n pairs of random Doubles
17:13:15 <lambdabot> forall a. (System.Random.Random a) => IO [a]
17:13:18 <luqui> getRandomList = join (repeat randomIO)
17:13:19 <soysauce> there!
17:13:24 <soysauce> @type (sequence (replicate 8 Random.randomIO)) >>=
17:13:25 <lambdabot> parse error (possibly incorrect indentation)
17:13:30 <soysauce> @type (>>=) (sequence (replicate 8 Random.randomIO))
17:13:31 <lambdabot> forall a b. (System.Random.Random a) => ([a] -> IO b) -> IO b
17:13:39 <soysauce> @type (>>= . return) (sequence (replicate 8 Random.randomIO))
17:13:40 <lambdabot> parse error on input `.'
17:13:46 <soysauce> @type ((>>=) . return) (sequence (replicate 8 Random.randomIO))
17:13:46 <lambdabot> forall b (m :: * -> *) a.
17:13:46 <lambdabot> (Monad m, System.Random.Random a) =>
17:13:46 <lambdabot> (IO [a] -> m b) -> m b
17:14:00 <luqui> @type Monad.join (repeat Random.randomIO)
17:14:01 <lambdabot>   Couldn't match `[a]' against `IO a1'
17:14:01 <lambdabot>   Expected type: [a]
17:14:10 <luqui> oh, wrong join
17:14:14 <soysauce> @type \f -> (sequence (replicate 8 Random.randomIO)) >>= return . f
17:14:14 <lambdabot> forall a b. (System.Random.Random a) => ([a] -> b) -> IO b
17:14:16 <luqui> @type sequence (repeat Random.randomIO)
17:14:17 <lambdabot> forall a. (System.Random.Random a) => IO [a]
17:14:25 <luqui> that's the one
17:14:33 <soysauce> @type (sequence (replicate 8 Random.randomIO)) >>= return . map
17:14:34 <lambdabot>   Couldn't match `a -> b' against `[a1]'
17:14:34 <lambdabot>   Expected type: [a1] -> IO b1
17:14:40 <Cale> why the heck are there not standard instances of Random for tuples?
17:14:46 <soysauce> @type \f -> (sequence (replicate 8 Random.randomIO)) >>= return . map f
17:14:47 <lambdabot> forall a b. (System.Random.Random a) => (a -> b) -> IO [b]
17:14:52 <soysauce> there!
17:15:04 * soysauce stops spamming :p
17:15:17 <Cale> uh, why did you want the extra function parameter?
17:15:40 <Axioplase> Cale: me?
17:15:51 <Cale> no soysauce 
17:16:10 * soysauce scratches head
17:16:14 <soysauce> that's the same thing as fmap
17:16:26 <Cale> replicateM 10 (Random.randomRIO (10.0,500.0))
17:16:37 <soysauce> I don't know. I didn't want anything in particular. But it looked like it might be relevant in some backward way.
17:16:57 <skew> fmap (map f)
17:17:00 <Cale> (replicateM is in Control.Monad)
17:17:29 <Cale> xs <- replicateM 10 (Random.randomRIO (10.0,500.0))
17:17:49 <Cale> that'll get you a list of 10 random Doubles between 10.0 and 500.0
17:17:57 <Cale> (or Floats, if that's what you want0
17:17:59 <Cale> )
17:18:05 <skew> I kind of like getStdRandom (runState $ replicateM 10 $ State $ randomR (10.0,500))
17:18:18 <Axioplase> Cale: Thanks.
17:18:47 <Cale> skew: or you could use my Rand monad/transformer in a similar way
17:19:33 <Cale> there really ought to be an instance of Random for pairs at least
17:20:12 <soysauce> well wtf, Int64# is such a useful type since there are NO OPERATIONS DEFINED for it
17:20:33 <Cale> Int64# isn't a defined type
17:20:50 <Cale> nor is Int32#, I thought we determined that
17:20:51 <soysauce> data Int64 = I64# GHC.Prim.Int64#       -- Imported from GHC.Int
17:20:57 <skew> sure there are
17:21:00 <Cale> ah, that's in GHC.Prim though
17:21:07 <soysauce> data Int32 = I32# GHC.Prim.Int#         -- Imported from GHC.Int
17:21:12 <Cale> sorry, it's not an exposed type
17:21:16 <soysauce> there is no Int32#, but there *is* an Int64#
17:21:25 <skew> eqInt64#, neInt64#, plusInt64#, etc
17:21:34 <soysauce> skew - I can't find any reference to them
17:21:48 <Cale> Is GHC.Prim even an exposed module?
17:21:52 <Cale> I think it's internal
17:22:17 <skew> I don't know how to get at them
17:22:24 <Cale> I don't think you can
17:22:39 <Cale> You can be working on GHC, at which point you're allowed to use them
17:22:45 <skew> but I see lots of stuff like that in fptools/libraries/base/GHC
17:22:47 <soysauce> hmm, oh well
17:22:58 <soysauce> skew - I did a grep and found nothing, strange
17:23:00 <skew> fptools/libraries/base/GHC/Int.lhs
17:23:11 <soysauce> oh well, that's not very useful
17:23:12 <skew> just Int.lhs, I guess
17:23:15 <soysauce> and I'm rather disappointed
17:23:22 <Cale> why?
17:23:39 <Axioplase> Cale: so... let getRandN n = do xs <- replicateM 10 (Random.randomRIO (10.0,500.0)); return (xs)     foo = getRandN 10   and foo will contain 10 Doubles ? (and *not* 10 IO Doubles?)
17:23:40 <soysauce> because Int64 is horrifically slow
17:23:52 <Cale> Axioplase: no
17:23:57 <Axioplase> damn.
17:24:10 <soysauce> oh well, BBL.
17:24:10 <Cale> Axioplase: there's no function of type IO a -> a
17:24:13 <soysauce> time to take a break
17:24:29 <Axioplase> ha.
17:25:02 <Axioplase> That means that from the moment I use an IO type, I'll have to work with it till the end of the source ?
17:25:04 <Cale> such a function would be quite dangerous, and would break referential transparency
17:25:06 <skew> do foo <- getRandN10, and foo will have a list of 10 doubles
17:25:39 <Cale> let getRandN n = do xs <- replicateM n (Random.randomRIO (10.0,500.0)); no?
17:25:48 <Cale> er
17:25:54 <Cale> let getRandN n = replicateM n (Random.randomRIO (10.0,500.0)); no?
17:26:10 <skew> soysauce: I doubt the I64# wrapped around the Int64# to make Int64 really hurts performance that much
17:26:23 <skew> it should be optimized out, expecially if you are throwing around seq
17:26:35 <skew> and if you care enough you can try to compile to core and read that
17:27:13 <Cale> Axioplase: it means that you can only use results of executing IO actions inside IO actions
17:27:23 <Axioplase> Cale: ok then.
17:27:30 <Cale> (to compose larger IO actions)
17:27:32 <Axioplase> I'd say weird. but whatever..
17:27:41 <skew> in particular, look at (>>=) :: IO a -> (a -> IO b)
17:27:43 <Cale> of course, you can also use pure functions to define them
17:28:20 <Cale> the reason is that if there was a function of type IO a -> a, let's call it unsafePerformIO, what would it produce if applied to getLine?
17:28:23 <Axioplase> Cale:  ah? you mean I can have some random stuff without IO ?
17:28:33 <skew> it means you can use your functions expecting [Double] on that IO [Double] you get from getRandN
17:28:48 <Cale> Axioplase: I mean you can apply pure functions to your random values
17:29:02 <Axioplase> Ha. How do I do that then?
17:29:04 <Cale> but the results again have to be used from IO
17:29:18 <Axioplase> ah
17:29:21 <Korollary> Axioplase: like putStrLn ("hello" ++ " there"). ++ is pure still.
17:29:25 <Cale> do xs <- getRandomValues; print (f xs)
17:29:54 <Cale> where f :: [Double] -> whatever
17:30:00 <Cale> (not IO)
17:30:08 <Cale> where f :: [Double] -> [Double], say
17:30:24 <Cale> I suppose that technically, anything in Show will work there
17:30:37 <Cale> so f :: (Show s) => [Double] -> s
17:31:01 <Cale> because print :: (Show s) => s -> IO ()
17:31:26 <Cale> see how that works?
17:31:53 <skew> IO a says "I can produce an a by doing stuff with side effects"
17:32:13 <Cale> Generally in Haskell, you write a thin shell of IO handling stuff, and all the interesting bits get written as pure functions, which are then called from that IO shell.
17:32:23 <skew> and  action1 >>= action2 says "action2 happens after action1, so it can use the results from action1 freely (without IO on it)"
17:32:34 <Cale> main :: IO ()
17:33:16 <Cale> action1 >>= \result1 -> action2 result1 -- really it's more like this
17:33:25 <Axioplase> I know how that works. I've written a Caml typer last year. though we have a function 'a->'b (which use is forbidden), doing some IO is easy. Data from "outside" is trusted.
17:33:52 <Axioplase> But I think that I just hhave to get used to Haskell...
17:34:00 <skew> Axioplase: you know about writing a thin imperative shell around a functional code?
17:34:20 <skew> Axioplase: or what I was saying actually makes sense?
17:34:31 <Cale> to be honest, there is a function of type IO a -> a, but it's not to be used under ordinary circumstances.
17:35:06 <skew> there's a few more than that, actually...
17:35:37 <Axioplase> skew: yep. that made sense
17:35:42 <skew> the point of the IO monad is to require explicit sequencing of side effects, so we retain referential transparency
17:35:43 <Korollary> You could abuse Debug.trace heh
17:35:52 <Cale> heh
17:36:15 <Cale> Using Debug.trace is a good way to get a handle on when things are evaluated in Haskell
17:36:22 <Cale> and to understand seq
17:36:39 <skew> If some constant of type Int could consult a random number generator each time you refered to it, things could get confusing
17:37:36 <skew> what you pass around in Haskell are little sequences of actions you've put together, and build them up into big sequences
17:38:39 <Axioplase> so basically, all the stuff I did on hard coded values, is now inside a "do" since I use some IO to get those values ?
17:40:27 <Axioplase> big silence for big lack of comprehension of what you've been trying to explain for the last hours ?
17:40:36 <Cale> kind of, at least, you have to start from a "do"
17:40:48 <Cale> you can call pure functions all you want of course
17:40:49 <skew> I'm not qutie sure what you are saying, but probably all the code using those values just needs to happen after (bound with >>=) the action to read them
17:40:58 <Cale> and that do has to print your results or return them
17:41:07 <skew> not that you need to rewrite the all your code in monadic style
17:41:30 <Cale> "do" is really just syntax sugar for >>=
17:41:51 <skew> Axioplase: we've been trying to figure out how to explain this stuff for years!
17:42:17 <Cale> do {xs <- blah; return (f xs)} = blah >>= \xs -> return (f xs)
17:42:49 <Cale> but you can ignore that for now if you like and just pretend that do-notation works sanely :)
17:42:58 <skew> in that code, f can be a pure function, and it just gets xs like any other argument
17:43:01 <Cale> later, you'll really want to understand it
17:43:19 <skew> f doesn't know or care that xs was originally produced in by "
17:43:25 <skew> "blah" doing some IO
17:43:48 <Korollary> Existing tutorials are good enough, I think. It's just that people expect to understand it much quicker, and they don't, and then quit reading.
17:44:20 <skew> Korollary: a bit of both I think
17:44:43 <skew> monads are kind of a slipperey idea
17:45:10 <skew> saying "explict sequencing" and "referential transparency" is easy
17:45:13 <Korollary> skew: Yes, but if you're primarily interested in i/o, the load is much lighter.
17:45:26 <Axioplase> What's *wrong* with the explaination, is that "return". it doesn't return the value, otherwise I could the use it as usual somewhere else.
17:46:12 <skew> I think a big source of confusion is the way ">>=" lets you do pure functional computation "inside" the sequenced actions just like you can "outside"
17:46:13 <Korollary> Axioplase: correct. It is actually called "unit", not return.
17:46:40 <Korollary> Axioplase: It's just hard to pick good names.
17:46:45 <Axioplase> Korollary: but then, I've never seen unit applied to anything :/
17:47:16 <skew> people want to use values in pure code, and hear that they can only use the values inside the monad
17:48:05 <skew> and don't think that those cases are exclusive
17:48:17 <Korollary> also, none of the existing tutorials address potential confusions people may have.
17:48:42 <Korollary> I think a good tutorial should include broken code and explain why it is so
17:48:44 <Axioplase> here's my trouble code: http://rafb.net/paste/results/LzbYf258.html 31 lines, comments, empty lines, lots of doubts.
17:48:56 <skew> Axioplase: the name "return" makes more sense at the end of the definition
17:49:08 <skew> it means the value can be used by the next thing sequenced after the return
17:50:15 <Axioplase> skew: but that "next thing" too is weird. My code is always deterministic. (unless threading or else). so why bother about order things happen since they are definitely supposed to happen in the order I wrote them...
17:51:45 <skew> that's what do notation is for, when you write things in a do, then they are sequenced together
17:53:47 <Axioplase> so. I randN gives me some IODouble, I must use it inside a do. But then the value a get back from using it a math formula must be used again in a do ?
17:53:57 <SamB> skew: but there is no outside!
17:54:45 <Axioplase> I think I'm gonna write a Makefile that will write my haskell code and run it with those values hard coded...
17:54:52 <skew> SamB: there is the blessed realm of the pure lambda calculus, where the good functions get their denotations
17:54:59 <Axioplase> Taht's the best I can do tonigth..
17:55:13 <SamB> Axioplase: main is in IO too
17:55:17 <SamB> thats how all this can work
17:55:20 <skew> Axioplase: where is the stuff you want to use them in?
17:55:41 <Axioplase> skew: al the rest of the source.
17:55:54 <skew> ah, the problem is just in mesPoints
17:56:00 <Philippa> ah. You don't get bitten by that one twice, IME...
17:56:07 <SamB> Axioplase: so pass them into the rest of the source?
17:56:18 <Philippa> and yes, that generally works
17:56:31 <Philippa> do {value <- IOthingy; return (purefunc value)}
17:56:53 <skew> mesPoints xs ys = take 100 (map pairToPoint [xs,ys], I think
17:57:36 <Axioplase> skew: and then, mesPoints foo bar can be used *outside* a do ?
17:57:43 <skew> yes
17:58:07 <Axioplase> haaaaa... I think I'm getting it.
17:58:17 <skew> and you can write something like do xs <- getRandList 100; ys <- getRanList 100; let mypoints = mesPoints xs ys; ... do stuff with mypoints ...
17:59:30 <skew> I think this is another area that picks up a lot of confusion - a pure function can be used inside of *any* monad, not all monadic code can be used in pure code
17:59:56 <Korollary> the so-called one way monads
18:00:11 <Korollary> Maybe is not one-way
18:00:13 <luqui> which are, IO, and... that's it
18:00:41 <SamB> luqui: nah-uh!
18:00:46 <SamB> anything built on IO too
18:00:53 <luqui> oh.
18:00:57 <skew> or with STM
18:01:05 <luqui> the thing that does it is the lack of the function m a -> a
18:01:40 <SamB> or of any way to implement such
18:03:34 <Korollary> SamB: How does one go from IO Int to Maybe Int ?
18:03:54 <skew> Korollary: you don't, why?
18:04:14 <Axioplase> skew: so, I can do http://rafb.net/paste/results/TwgAyo18.html (3 lines) ?
18:04:17 <Korollary> skew: I am trying to understand a monad that is built on IO
18:04:31 <luqui> MaybeT IO
18:05:09 <luqui> Axioplase, the first thing I notice is that you have a function that starts with a capital letter
18:05:10 <luqui> that is not allowed
18:05:15 <Axioplase> luqui: I know
18:05:24 <Axioplase> I just realized it
18:05:41 <skew> do x <- m; return x is always equivalent to m
18:05:52 <luqui> that's one of the monad laws even :-)
18:05:54 <Korollary> luqui: What is MaybeT ?
18:06:01 <luqui> doesn't exist, but it should.
18:06:07 <skew> MaybeT m a = m (Maybe a), I think
18:06:18 <luqui> yeah, that's a reasonable way to implement it
18:07:23 <luqui> besides the fact that that code can be greatly simplified, Axioplase, are there any other issues?
18:07:41 <skew> factorial :: Int -> Int?
18:07:42 <Korollary> well, then you can take the IO Int out of the MaybeT. That doesn't seem to make a one way monad.
18:08:04 <skew> you can reduce back to IO, but not all the way
18:08:30 <luqui> oh, Axioplase, if factorial :: Int -> Int, then that won't work
18:08:35 <skew> Axioplase: factorial is implemented like one of these: http://www.willamette.edu/~fruehr/haskell/evolution.html
18:08:57 <luqui> since foo :: IO -> Double   (or so)
18:09:01 <skew> writing 10.0 means  you get Dobule, or something
18:09:03 <luqui> excuse me, foo :: IO Double
18:09:25 <luqui> but factorial can't be applied to an IO thing anyway
18:09:31 <luqui> it only knows how to work on numbers
18:09:31 <Axioplase> ha.
18:09:37 <skew> if the numeric types were the same
18:09:44 <skew> you could write your factorial :: Int -> Int
18:09:48 <skew> and your foo :: IO Int
18:09:57 <luqui> do num <- foo; return (factorial num)
18:10:12 <skew> and then write fmap factorial foo :: IO Int to get something that runs foo to get an int, and then does the factorial on it
18:10:18 <luqui> Axioplase, have you read "monads as containers"?
18:10:30 <Axioplase> so I can't use it outside a do. (whereas at 02:57 localtime, you said I could)
18:10:45 <haskellnewbie> ah, I see I'm not the only one wandering in the monad wilderness!
18:10:54 <Axioplase> luqui: I didn't.
18:11:02 <skew> Axioplase: I said you can call pure functions inside of a do
18:11:10 <luqui> http://haskell.org/hawiki/MonadsAsContainers
18:11:53 <haskellnewbie> heh, just googled that up!
18:14:53 <haskellnewbie> Just found some commentary on MonadsAsContainers that is helping me digest it's contents: http://cwilliams.textdriven.com/pages/monads
18:15:18 <skew> barr+wells, pg 97: "A triple T = (T,eta,mu) on a category C is an endofunctor T:C -> C together with two natural transformations eta:id_C -> T, mu:T T -> T subject to the condition that the following diagrams commute" mu . mu(T) == mu . T(mu), mu . T(eta) == mu . eta(T)
18:15:23 <haskellnewbie> the one thing I wish for is more examples of the use of existing monads (State, ST, etc.) and less documentation on their implementation!
18:16:20 <skew> that's pretty heavy, but the bit you care about is "endofuctor", which means it comes with an operation that lifts any f:: a-> b to a function T(f) :: T a -> T b
18:17:30 <Frederick> folks can I have some help with mapM? Ive google for it but I can only find its specification on the api that says almost nothing for me http://www.zvon.org/other/haskell/Outputprelude/mapM_f.html
18:18:23 <skew> mapM is just like map, except the function can have monadic effects
18:18:30 <Korollary> Frederick: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3AmapM
18:19:24 <Frederick> Korollary, this is just an API specification I was looking for some samples maybe a little explanation
18:19:32 <skew> I've got an example
18:20:22 <Frederick> skew, where?
18:20:44 <Korollary> Frederick: sequence . map putStr ["Hello", "world"]
18:21:29 <skew> let accAndInc x = do modify (+x); return (x+1)
18:21:40 <skew> runState (mapM accAndInc [1..5]) 0
18:21:43 <Frederick> Korollary, I was looking for something deepe I need to use it into a more complicated context
18:21:52 <skew> => ([2,3,4,5,6],15)
18:22:14 <Frederick> Im trying to do this -> http://www.csee.umbc.edu/~squire/cs451_l16.html
18:22:17 <Korollary> Frederick: It's not deeper than that.
18:22:23 <Frederick> on my source folks suggested map m
18:23:37 <skew> mapM is when you want to transform a list as by map, but the function you want to use lives in some monad
18:24:26 <skew> I hope my example shows that the list produced by mapM is the list of results from applying the function to the values, and that all the side effects happen too
18:25:39 <Frederick> skew, but I need to this types -> http://paste.lisp.org/display/13785
18:26:26 <Frederick> I need it fot the cfg type and more specifically forthe right side of the tuples [Name,Productiosn] 
18:27:36 <haskellnewbie> skew, how would one actually execute that accAndInc example you just gave? which bits go where (with main and all that jazz)
18:27:50 <skew> it's easiest to just do in in ghci
18:27:56 <skew> :m + Control.Monad.State
18:27:59 <haskellnewbie> I'm in ghci
18:28:14 <skew> to pull in the Control.Monad.State package, then just copy in those lines
18:29:26 <skew> the let and the runState line, that is
18:30:37 <haskellnewbie> ah, that's better!
18:31:08 <skew> probably the next thing do is play with :t on those expressions and various subexpressions
18:31:54 <haskellnewbie> yes...this week I've come to the conclusion that when I'm done with this program/paper I'm going to write a document called "Monads by Example" and include ZERO implementation code, just 100% examples of use!
18:33:42 <skew> that sounds quite traditional
18:34:59 <skew> just axioms and examples, like thing were before moggi ever heard the word
18:35:18 <haskellnewbie> well I think that all of the monad help pages I've seen are all like "here are the definitions of a gazillion monads, and maybe one example of each"
18:35:31 <haskellnewbie> more than one example of each is needed to see what bits fit where!
18:35:32 <Korollary> haskellnewbie: would IO examples do for you ?
18:35:55 <haskellnewbie> no, I understand THOSE...I need stuff with the State and ST monads (really, I do...)
18:36:16 <Korollary> haskellnewbie: Yeah, not so many ST examples
18:36:18 <haskellnewbie> I can do IO, those are no problem...I can do polymorphic functions over different types
18:36:51 <Korollary> haskellnewbie: btw, Control.Monad.State is not Haskell98. it uses extensions afaik.
18:37:21 <haskellnewbie> I'm all ghc over here, extensions don't bother me
18:37:58 <Korollary> haskellnewbie: of course. But there are no haskell extensions tutorial I know of
18:38:09 <skew> State is probably Haskell 1, ST uses all sorts of extensions
18:38:11 <haskellnewbie> but I will need to pull stuff out of State/ST back into IO
18:38:24 <haskellnewbie> ST is icky, but once I get State I'm sure I'll get it
18:39:27 <haskellnewbie> I suppose I should go to banging my head against StateT directly, since I'm always going to need to do IO at the end, and need to lift values up to IO??
18:40:45 <skew> no, it's easiest to used runState and get pure values back out
18:40:58 <haskellnewbie> ok, that's good to know
18:44:47 <haskellnewbie> ok, yeah, :t and those examples are starting to help, thanx skew!
18:54:08 <soysauce> ghc: panic! (the `impossible' happened, GHC version 6.4.1)
18:54:10 <soysauce> woohoo
19:04:29 <bobwhoops> I'm following this tutorial that wants me to use a function called ord, but hugs says that it's undefined. Did I do something wrong?
19:04:45 <dons> import Char
19:05:08 <dons> > Char.ord 'x'
19:05:08 <lambdabot> 120
19:05:33 <bobwhoops> dons: Where do I type that? It errors if I do it at the prompt
19:06:41 <dons> Hugs.Base> :l Char
19:06:41 <dons> Char> :t ord
19:06:41 <dons> ord :: Char -> Int
19:06:45 <dons> Char> ord 'x'
19:06:45 <dons> 120
19:06:52 <dons> :)
19:07:53 <bobwhoops> Ah, thank you :)
19:08:25 <ricebowl> dons - do you know offhand what information the GHC mailing list will want when I report this bug?
19:08:44 <ricebowl> er, whoops.
19:08:49 * ricebowl == soysauce
19:08:52 <ricebowl> anyway
19:09:01 <dons> @seen soysauce
19:09:02 <lambdabot> soysauce is in #haskell. Last spoke 14 minutes and 52 seconds ago.
19:09:06 <dons> @seen ricebowl
19:09:06 <lambdabot> ricebowl is in #haskell. Last spoke 14 seconds ago.
19:09:20 <dons> glasgow-haskell-bugs@
19:09:37 <ricebowl> dons - yes
19:09:41 <ricebowl> but what information will they want?
19:09:44 <ricebowl> just the code?
19:09:48 <Korollary> isnt there a sourceforge page for ghc ?
19:09:52 <ricebowl> yes, there is
19:10:00 <ricebowl> but I don't remember my SF account name ;)
19:10:04 <dons> ricebowl, all the information required to reproduce the bug
19:10:26 <dons> so certainly code. the smaller the code the better -- try to narrow it down to the smallest case
19:10:35 <ricebowl> *nods*
19:10:36 <dons> and any extra info. such as how you compiled it, what OS
19:10:38 <bobwhoops> dons: The import command is what I use if I want to put it in a program? 
19:10:39 <dons> which ghc versoin
19:10:43 <ricebowl> ok
19:10:59 <ricebowl> I'll try to narrow it down then, I suppose
19:11:14 <dons> bobwhoops, you import a module, yes. so: import Data.Char
19:11:18 <ricebowl> I micro-optimized the inner body of a O(n^3) loop and it blew up.
19:11:28 <ricebowl> switched to an unboxed tuple
19:11:28 <bobwhoops> ok
19:11:30 <dons> ricebowl, more karma for you if you make the bug small.
19:11:35 <ricebowl> heh yeah I know ;)
19:11:41 <ricebowl> I've got to play with it a while though
19:11:43 <dons> hmm... unboxed tuple eh?
19:11:47 <dons> in ghc or ghci?
19:11:51 <soysauce> both
19:12:26 <dons> expect to be told "not to do that" and "it's uneccessary" ;)
19:12:32 <soysauce> I'm sure
19:12:38 <bobwhoops> dons: import Char works as well as import Data.Char. Is one more proper?
19:12:53 <dons> the later is usual these days.
19:13:04 <bobwhoops> Alright, thanks
19:13:11 <dons> we use a hierarchical module system since the last, hmm, 8 years.
19:13:25 <dons> no, less than that. 5 years maybe.
19:13:48 <ricebowl> dons - I reported a bug to the GCC list where a minor error in inline assembly *syntax* caused the compiler to barf likewise
19:13:54 <ricebowl> and they were adamant that it should be fixed
19:14:04 <ricebowl> I will be surprised and saddened if GHC people react any differently
19:14:11 <dons> oh, the ghc people will want it fixed, certainly
19:14:32 <dons> but they'll also say that you probably don't need to do this in the first place, as many have pointed out. just warning you ;)
19:14:58 <dons> we're a friendly bunch, don't worry. and we like fixing bugs
19:15:18 <dons> bugs are our mortal enemies
19:15:23 <ricebowl> *nods*
19:15:52 <ricebowl> considering that it failed to optimize a number of base cases, I'd rather trust myself than the compiler :/
19:16:05 <ricebowl> but oh well
19:16:27 <ricebowl> it does get tiring, of course, to be told how to code
19:16:36 <ricebowl> I think that's probably the thing that pisses me off the most about Microsoft.
19:16:46 <Korollary> you mean, to be offered workarounds intead of fixes
19:16:54 <dons> don't say that in the bug report ;) criticising the compiler is a good way to annoy people who work on the compiler.
19:17:00 <ricebowl> no, not even workarounds.
19:17:06 <ricebowl> to be offered *nothing* but criticism.
19:17:17 <Korollary> you wont get that from the ghc folks
19:17:25 <ricebowl> usually when I ask a question on their newsgroups they say something like, "Don't do that." and that's the only reply I get.
19:17:34 <ricebowl> dons - heh ;) I'm not that tactless.
19:18:08 <Korollary> ricebowl: which newsgroup is that ?
19:18:32 <ricebowl> Korollary - erm, all of them? There were two where I was particularly active, both microsoft.public ones
19:18:41 <ricebowl> one driver-related, the other Win32-related
19:18:43 <Korollary> ah
19:19:07 <ricebowl> I asked a question once related to a project at work and had a guy sit there and criticize my design when he didn't even fully understand what we were doing
19:19:16 <Korollary> Well, the point of an MS OS is that you do market research for them, and then they develop their own version and bundle it with the OS.
19:19:39 <ricebowl> and he suggested alternate designs which would *not* work
19:19:40 <Korollary> Hello New York
19:19:44 <ricebowl> haha
19:19:47 <ricebowl> isn't that true.
19:20:15 <ricebowl> I interned there for 3 months. Some people are bright. Most are deadweight just like anywhere else.
19:20:21 <sethk> Korollary, 'evening.  :)
19:20:42 <Korollary> ricebowl: in redmond or california ?
19:20:57 <sethk> Korollary, I get here, and my $#@$# T1 carrier has switched my service from the old line to the new line, which was s planned.  They've also left the router programmed for the old line.  What fun
19:21:13 <sethk> Korollary, meanwhile I'm looking for a problem when there is none, at least on my side.  :)
19:21:25 <Korollary> sethk: heh
19:21:25 <ricebowl> Korollary - Redmond
19:21:57 <ricebowl> I would *never* want to work there.
19:22:17 <ricebowl> which is funny; in 4 years I've gone from wishing I'd have the opportunity to not caring one bit that I did.
19:22:26 <Korollary> ricebowl: nor would I. I had never gotten angry at an interview before
19:22:39 <sethk> Korollary, this sounds good, tell me about it.  :)
19:22:52 <Korollary> sethk: all this is #haskell-blah material :)
19:23:05 <ricebowl> sounds interesting for sure
19:23:27 <sethk> Korollary, ok, I'm in #haskell-blah also, if you feel like telling
19:23:32 <Korollary> ok I'll talk about it in #haskell-blah
19:28:48 <SamB> wow. Lout source is nasty!
19:29:17 <SamB> the files are named z01.c,z02.c..z52.c
19:29:34 <SamB> there is one header named externs.h
19:29:53 <SamB> there are some unions called FIRST_UNION, SECOND_UNION, THIRD_UNION
19:31:05 <Korollary> hah
19:37:33 <SamB> I have no idea why this guy feels the need for the GPL! BSD out to work just fine ;-)
19:38:12 <SamB> its not like anyone is going to get anything out of the code
19:39:52 <Korollary> except a lawsuit maybe. You can sue everybody.
19:40:02 <SamB> hmm?
19:40:05 <SamB> lawsuit?
19:40:24 <SamB> I don't see anything in the BSD about suing people
19:40:57 <sethk> SamB, don't give them any ideas.  :)
19:41:10 <SamB> give who any ideas?
19:42:14 <sethk> SamB, bsd
19:42:25 <SamB> BSD aren't a them
19:42:34 <sethk> SamB, ok, one of his instantiations, then  :)
19:42:35 <SamB> it isn't really the name of a license
19:43:33 <SamB> the only one I can imagine getting sued over this is the guy who wrote it, for using C and then for using such atrocious style
19:46:03 * SamB wonders what ever happened to Cale's name generator monad
19:57:30 <dons> name generation is easy: data TCState = TCState { unique :: Int }
19:57:43 <dons> runTC m = let (r, _) = unTC m (TCState 0) in r
19:57:48 <dons> freshName :: TC Id
19:57:48 <dons> freshName = TC $ \s ->
19:57:48 <dons>   let i     = unique s
19:57:48 <dons>       fresh = mkId $ if i < 26 then [chr (ord 'a' + i)] else 't' : show i
19:57:48 <dons>   in (fresh, s {unique = i + 1})
20:00:22 <xinming> instance Class a => Class [a] where ...
20:00:36 * xinming is still in confusion about the usage of this instance. :-/
20:03:17 <xinming> Does this mean this instance can be used on list?
20:07:37 <SamB> dons: I thought that was supposed to be done with a hidden State monad
20:09:48 <lisppaste2> fworp pasted "GHC type system extensions gymnastics" at http://paste.lisp.org/display/13786
20:09:51 <SamB> what is TC
20:16:20 * fworp just throws that out there
20:22:40 <fworp> it seems possible to infer the type of the list in (sFromList [1,2,3,4,5]) :: [Int], just curious why it isnt being infered (or if anyone has ever come across something like this before)
20:29:23 <fworp> i would really like to have a class like this. Maybe theres some other way of instantiating or declaring the class to get this behavior.
20:31:05 <unixgreybeard> lisppaste2, could that code be adapted to pack and unpack Word8's into Word32 and Word64? or is there already a good way to do that?
20:31:26 <unixgreybeard> which I need to do for my current project
20:33:00 <skew> well, lisppaste2 is a bot, and there are simpler ways of packing values, but there are nice tricks you can use for packing and unpacking stuff
20:33:09 <fworp> that code is just supposed to generalize sequence types, both polymorphic and monomorphic, and it works to some extent
20:33:25 <unixgreybeard> oh, I suppose I meant to address fworp! 
20:33:30 <fworp> :P
20:33:51 <unixgreybeard> you must excuse me, I'm old and feeble at 34! :-)
20:34:24 <Korollary> lambdabot, save us
20:35:57 <fworp> if only lambda bot had an @load urltohaskellmodule :P
20:36:58 <unixgreybeard> that would be kewl
20:37:21 <skew> fworp: the list argument to sFromList is the problem?
20:37:35 <skew> that's because numeric constants have the type forall n . (Num n) => n
20:38:28 <skew> and the type system doesn't let us write [forall n . (Num n) => n]
20:39:05 <skew> (not sure that would actually help with instance resolution)
20:40:19 <skew> sorry, that's an unrelated issue you sometimes run into
20:40:33 <fworp> skew: right, im thinking its probably possible for some imaginary compiler to beable to Infer that (sList (v :: forall a. Num a => [a])) :: [Int] is really (sList (v :: [Int]) :: [Int] based on the only applicable instance of sequence
20:41:03 <skew> that's a different problem
20:41:15 <skew> that's because Haskell doesn't make the closed-world assumption in the overloading
20:41:42 <skew> wait, better think more
20:42:11 <skew> yeah, because there's nothing to stop somebody from coming along and adding an instance Sequence [Int] Double
20:42:46 <skew> and if you used that instance, the argument should get the type [Double]
20:43:45 <unixgreybeard> I got a similar error the other day because I failed to tell it what type of Num I'd given it in a forall a. Num a => a type of situation, and it could take a Word32 or a Word64
20:44:01 <unixgreybeard> had to use (3 :: Word32) instead of 3
20:44:24 <xinming> instance Class a => Class [a] where ... anyone tells me what does this mean please? I was still in confusion after reading the book
20:46:51 <skew> fworp: if you had a functional dependency, like class Sequence s e | s -> e, then I think it would work
20:47:05 <skew> that says the sequence type uniquely determines the element type
20:52:24 <fworp> ok, great, thats exactly what i was looking for. I think i skipped over using a fundep because i 'thought' it would restrict it too much, but now that i think of it, it doesnt restrict it at all really, just gets rid of nonsense instance
20:52:39 <fworp> s
20:53:34 <skew> The only thing I've though of so far is maybe wanting to read from maps as containiers of keys, values, or pairs
21:01:30 <SamB> whoa. That CNF stuff is painful, at least the only way I tried...
21:02:00 <skew> it didn't look so bad to me, but I didn't try it yet
21:02:11 <SamB> yeah, me neither, until I tried it
21:02:16 <SamB> maybe I'm just too tired though
21:02:19 <skew> isn't is just a matter of folding/unfolding through lists of terms, maybe with some state?
21:02:28 <SamB> it definately seems to involve more than meets the eye!
21:02:36 <SamB> its all plumbing, but it still hurts!
21:02:43 <SamB> (well, almost)
21:03:07 <SamB> maybe you can figure out a better way to plumb it then I did
21:03:37 <SamB> you'll certainly want some sort of name generator, like the one Cale suggested
21:05:09 <SamB> (a monad based on State, with one function to return a name/number and another to run the computation)
21:06:21 <SamB> observe the complexity involved in dealing with the fact that a given nonterminal (in both CFG and CNF) may have multiple production rules
21:06:44 <SamB> well, I guess the only way to do that is first hand :-(
21:07:02 <fworp> it seems like it would be hard to define anything other than pairwise map sequences , for instance, how would you define sCons for Map sequences of keys? im not sure maps really qualify as sequences though, since (sTail . sCons x) /= id
21:07:44 <SamB> I ran into trouble with fundep and collections...
21:08:03 <SamB> I think it had to do with map
21:10:06 <SamB> I suppose you could let map map between arbitrary types of sequences...
21:10:11 <SamB> (or other collections)
21:10:38 <SamB> but that gets annoying because then you have to specify types everywhere
21:11:29 <skew> fworp: those interpretations would be only for destructuring
21:13:17 <SamB> its really, really a pain not to be able to do stuff like that without type sigs everywhere...
21:13:36 <SamB> solve that, and I'll send you $10.
21:13:40 * SamB is REAL cheap
21:14:27 <fworp> hehe, i just want to beable to have code that works on both strings and something like packedStrings, and take advantage of some of the efficiency/laziness advantages of them both
21:14:46 <SamB> but I bet there are a lot of other poeple who would also send you Â¤10
21:15:47 <SamB> the main trouble is that there aren't type functions, I guess...
21:16:33 <SamB> or something like that...
21:18:46 <unixgreybeard> isn't that what classes are for???
21:18:53 <SamB> I suppose it doesn't realy make all that much sense to have map :: Map k1 a -> Map k2 b
21:19:05 <SamB> unixgreybeard: classes only get you so far
21:19:32 <SamB> unixgreybeard: a decent, but inclusive, collections interface is VERY hard
21:19:54 <SamB> it is an open research problem, which will most likely require even MORE compiler extensions to complete
21:20:02 <unixgreybeard> oh yeah, in any language I think
21:20:13 <SamB> in other languages it might not be as hard
21:20:29 <SamB> certainly its not as hard if you don't have to typecheck...
21:20:42 <unixgreybeard> but at least once you've gotten something working in haskell, you REALLY have it working!
21:20:47 <skew> I think the hard part is the design
21:20:48 <SamB> well.
21:20:49 <SamB> maybe.
21:20:54 <SamB> skew: this is true
21:21:01 <unixgreybeard> skew: yes
21:21:21 <SamB> but I still think we might need more type-system extensions to complete it!
21:21:48 <skew> what did you want your map function to do?
21:23:27 <SamB> I wanted it to map within the same kind of collection
21:23:48 <SamB> unfortunately there was no way to give the compiler any clue I meant by that 
21:24:17 <SamB> s/clue I/clue what I/
21:24:17 <skew> map :: (a -> b) -> s a -> sb
21:24:36 <skew> hmm
21:24:54 <SamB> well, the trouble with that is that it assumes that there is a type constructor (s :: * -> *)
21:29:07 <fworp> mines type is (Sequence s e,Sequence s' e') => (e -> e') -> (s -> s'), though since the fundep is s -> e, (s -> s') is ambiguous
21:29:32 <fworp> and e -> s would defeat the purpose
21:29:46 <fworp> so.. crap
21:31:08 <skew> well, mappable sequences are more specific that general sequences
21:31:24 <skew> things like unboxed arrays and bitvectors can't contain every type
21:31:44 <skew> so the class providing map could have some more restrictive type
21:32:19 <fworp> ah
21:33:17 <skew> something like class MappableSequence s1 e1 s2 e2 where map :: (e1 -> e2) -> (s1 -> s2)
21:33:34 <fworp> yuck
21:33:38 <skew> and then maybe fundeps like s1 e2 -> s2, s2 e1 -> s1
21:34:01 <SamB> fworp: thats exactly what happened to me
21:34:24 <SamB> skew: that is absolutely disgusting
21:34:49 <SamB> well, maybe not quite absolutely
21:35:12 <SamB> it is better than nothing...
21:35:15 <skew> seems reasonable enough to me
21:35:26 <SamB> but so assymetrical...
21:35:31 <skew> how so?
21:35:45 <SamB> well, maybe not really.
21:35:50 <skew> each sequence is determined by it's element type and the other sequence
21:36:05 <SamB> skew: where were you when I asked about this on haskell-libraries?
21:36:21 <skew> not following the list.
21:36:31 <skew> I suppose I could again
21:36:39 <SamB> hehe.
21:36:54 <SamB> I think thats the only haskell.org list I'm on at the moment
21:36:57 * fworp crosses his eyes and stares at that fundep for a while
21:37:01 <SamB> at least, the only one that gets any traffic
21:37:11 <SamB> fworp: it does make sense
21:37:30 <SamB> it means that map f xs doesn't need a type signature
21:38:28 <SamB> it would be nicer, though, if you could teach GHC to make up nicer type names for it...
21:38:43 * SamB thinks that would be an interesting sort of PRAGMA
21:39:09 <skew> doesn't it use the names from the definition?
21:39:42 <SamB> skew: well, they would collide if you used map twice or anything like that...
21:40:02 <SamB> skew: remind me to send you $10
21:40:33 <skew> yeah, then you get the numbers
21:40:49 <skew> that was your problem?
21:40:59 <SamB> hmm. Maybe.
21:41:03 <skew> here I was thinking we would need to go to 
21:41:07 <skew> Oleg
21:41:09 <skew> for a solution
21:41:27 <SamB> I don't think I liked his answer very much
21:42:43 <skew> instance MapSequence [a] a [b] b where sMap = map
21:42:51 <skew> hmm, seems to be getting along ok
21:43:05 <skew> the instances for the unboxed arrays might explode a bit
21:47:58 * SamB even writes default implementation
21:53:22 * SamB records in his repos
21:53:28 <SamB> skew: I don't care about them
21:53:47 <SamB> they have their own interface anyways
21:53:58 <SamB> I mean, a common interface shared by all array types
21:54:11 <SamB> (that aren't mutable)
21:55:43 <SamB> hmm, my Mapping class needs work if I want it to support lists...
21:55:49 * SamB needs sleep, though
21:56:16 <skew> it does?
21:56:29 <skew> my instance above doesn't work?
21:56:37 <SamB> well, or maybe I just need to undo a change I made a while back.
21:56:45 <SamB> anyways, another day!
22:00:40 <fworp> so does the MapSequence class also get you folds some how?
22:00:56 <fworp> that would be convenient :)
22:03:44 <fworp> wait, thats probably already coved by Sequence
22:03:53 <fworp> covered*
22:07:25 <Cale> that looks an awful lot like functor
22:07:37 <fworp> i was thinking the same thing
22:07:38 <Cale> but perhaps a bit more general
22:07:54 <skew> the thing is, functor is parameterized
22:08:42 <fworp> MapSequences between parameterized sequence types smell like functors
22:10:46 <Cale> class Functor f where fmap :: (a -> b) -> (f a -> f b) -- you don't get control over the type of element separate from the type of sequence though.
22:11:05 <Cale> and the sequence type has to be completely parametric, yeah
22:11:06 <skew> yeah, you should have an instance (Functor f) => MapSequence (f a) a (f b) b 
22:11:52 <Cale> The real shame is that functors on subcategories of the Haskell type category can't be instances of Functor
22:18:12 <skew> that's where type system extensions come in
22:19:31 <Cale> yeah, I *think* that the kind system could be altered to allow for that, but it seems hard to prevent it from being a massive change.
22:19:50 <skew> it seems like there should be some way to let you push superclass constraints inward to the types of the methods
22:20:51 <Cale> it's odd though, since the changes propagate outward to everything that uses those class methods
22:22:05 <Cale> Really what you want is the ability to say that, for instance, if Set is applied to a type t, then we can infer the class constraint Ord t.
22:22:07 <skew> evidence translation can get tricky
22:23:17 <Cale> Which means in some sense that the kind of the type constructor Set is not Type -> Type
22:23:38 <Cale> but from a subkind of Type to Type
22:23:45 <unixgreybeard> later everybody!
22:23:50 <Cale> later!
22:24:34 <Cale> but I really need to read TaPL :)
22:24:55 <Cale> I don't really know anything really serious about type theory.
22:25:08 <Korollary> my copy is packed in a box somewhere
22:38:12 <skew> I don't know of any work adapting the simple objects-as-types interpretation of algebra we use to higher-order type systems like kinded ones, or dependent types
23:02:53 <fworp> my defintion of Sequence cannot be an instance of MapSequence, their fundeps clash... sooo close
23:18:46 <skew> fworp: what's the problem?
23:23:24 <skew> they get along together for me
23:24:21 <lisppaste2> fworp pasted "Sequence and MapSequence" at http://paste.lisp.org/display/13791
23:24:57 <fworp> maybe i fudged it up somewhere
23:26:07 <stefanw> I wrote a framework that makes testing Haskell code with HUnit and QuickCheck more convenient. Tests and properties are collecting using Template Haskell so that you don't have to write boring boilerplate code. Preprocessor macros are used to provide exact location information for failed tests and properties. Additionally, a facility is provided for testing programs by running them and comparing the actual output with the expected output. Get it
23:26:07 <stefanw>  at http://www.stefanwehr.de/darcs/HTF. dons, shapr, you might be interested
23:27:29 <vegai> sheet, everyone should be interested in that
23:28:15 <stefanw> I hope so
23:30:17 <skew> fworp: of course that instance doesn't work - the point of MapSequence is to be able to write a map that doesn't change the sequence
23:31:01 <skew> so I put fundeps that determine the result sequence type
23:31:19 <skew> but your function is a generic map for turning any sequence into any other
23:43:01 <sebell> (add-to-list 'load-path "~/.xemacs/ocaml")
23:43:01 <sebell> (setq auto-mode-alist
23:43:01 <sebell>       (cons '("\\.ml[iylp]?$" . caml-mode) auto-mode-alist))
23:43:01 <sebell> (autoload 'caml-mode "caml" "Major mode for editing Caml code." t)
23:43:01 <sebell> (autoload 'run-caml "inf-caml" "Run an inferior Caml process." t)
23:43:02 <sebell> (require 'caml-font)
23:43:14 <sebell> I hope I didn't just write that..
23:43:39 <sebell> Sorry guys, weird ssh session right-click.
23:45:12 <Korollary> to redeen yourself, paste the emacs haskell mode loader as well ;)
23:45:36 <fworp> i never actually 'got' the fundep, but that makes sense. I dont know how i could possibly constrain MapSequences to Sequences though, i was aiming for either all instances of MapSequence being constrained somehow by sequence, or having a general instance of MapSequence for Sequence
23:46:00 <skew> oh, you could add a constraint on the class if you like
23:46:48 <skew> but a general instance doesn't make sense the way I understand thing
23:47:18 <skew> the point of sequence is that you can have sequences which are not parametric in the element type,
23:47:36 <fworp> right
23:48:04 <skew> and then you want to define a map that works on two sequences with the same representation
23:48:23 <skew> presumably for efficiency, or else you could use sFromList . map f . sToList
23:49:36 <skew> but given that Sequence is designed for sequences which are not parametric in the element type, there is no generic way of deciding what sequence type "an s1, but holding elements of type e2" should be
23:51:05 <skew> you might be able to make an instance along the lines of
23:51:25 <skew> instance (Sequence (s e1) e1, Sequence (s e2) e2) => Mappable (s e1) e1 (s e2) e2
23:54:00 <skew> oh, but that overlaps with the functor instance, which I think is probably more useful
23:54:35 <skew> it works, anyway
23:57:04 <fworp> i think i see now, though the fundep still reads like greek to me
