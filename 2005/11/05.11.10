00:00:12 <ski> 'but you don't have any arrows!' means ?
00:01:48 <palomer> err
00:01:48 <palomer> I mean that forall x: A . B  is the SAME as writing forall x. Ax -> B
00:01:48 <palomer> but the second is clearer from a type theoretic point of view
00:06:28 <mysteriousentity> /away I'm not there
00:06:53 <C-Keen> moin
00:08:22 <Itkovian> meuning
00:09:07 * ski goes back to fight the comonads
00:28:36 <Itkovian> @seen boegel
00:28:37 <lambdabot> boegel is in #haskell-overflow, #haskell-blah and #haskell. Last spoke 16
00:28:37 <lambdabot> hours, 30 minutes and 33 seconds ago.
00:29:48 <kombinator> @seen CosmicRay
00:29:48 <lambdabot> I saw CosmicRay leaving #haskell 10 hours, 41 minutes and 10 seconds ago.
01:24:37 <basti_> @hoogle (Fractional b) => a->b
01:24:38 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
01:24:38 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
01:25:29 <ski> class constraints works now ?
01:25:47 <basti_> appears to huh
01:26:36 <basti_> @hoogle (Real b) => a->b
01:26:37 <lambdabot> No matches, try a more general search
01:30:57 <dblhelix> @hoogle (Eq a) => a -> [(a, b)] -> Maybe b
01:30:57 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
01:30:58 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
01:31:20 <dblhelix> yes, they seem to work just fine
01:33:11 <tessier> Are the haskell and haskell-cafe mailing lists subscription moderated? I sent off subscription requests via the web interface over 24 hours ago and have not received anything back
01:36:50 <basti_> hmm now I want to convert a Ratio to a Double.
01:37:03 <basti_> I don't find how to
01:37:10 <dblhelix> tessier: not that I know of
01:37:24 <dblhelix> basti_: I want a million dollars ;)
01:37:31 * basti_ sighs
01:37:55 <earthy> Ratio to a Double?
01:38:12 <basti_> yes
01:39:33 <earthy> fromRational?
01:40:09 <dblhelix> @hoogle fromRational
01:40:09 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
01:40:24 <basti_> excellent
01:40:28 <basti_> why didn't i see that?
01:40:47 <earthy> because you didn't think of the name first?
01:41:36 <basti_> hmm maybe.
01:41:42 <flux__> @hoogle Fractional -> Rational
01:41:42 <lambdabot> No matches, try a more general search
01:41:45 <flux__> ;(
01:41:50 <flux__> how should it be expressed?
01:41:52 <earthy> @hoogle Rational -> a
01:41:53 <lambdabot> Prelude.undefined :: a
01:41:53 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
01:41:53 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:42:07 <flux__> uh, obviously I gave the wrong query altogether ;)
01:42:15 <basti_> yes ^^
01:42:36 <tessier> How odd.
01:43:00 <tessier> When I subscribe from my own email account I never receive the subscription confirmation but when I subscribe from my gmail account I do get it
01:43:10 * tessier wonders how this can be
01:43:17 <tessier> I really don't want this email on my gmail account
01:43:35 <earthy> spam filters ?
01:43:43 <gus> Hello! I'm having troubles in installing wxHaskell. Anyone here that knows anything about installing it?
01:43:43 <tessier> Nope. Checked the Junk folder.
01:43:46 <tessier> It's not there.
01:45:04 <tessier> Haskell list run by simonmar at microsoft.com
01:45:08 <tessier> Interesting
01:45:40 * jlouis tesseracts into the channel
01:46:14 <musasabi> jlouis: Is anyone working on the peer-wireprotocol in Conjure?
01:46:26 * boegel boings
01:46:36 <jlouis> musasabi: yes, coordinate with SamB
01:46:47 <jlouis> I'll just publish his code, 2 secs
01:47:15 <jlouis> there
01:47:57 <musasabi> thanks
01:48:24 <jlouis> @where conjure
01:48:24 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
01:51:35 <earthy> @what conjure
01:51:36 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
01:51:45 <earthy> right. :)
01:51:56 <dons> @where hmp3
01:51:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
01:51:56 <earthy> @define conjure
01:51:57 <lambdabot> Unknown command, try @listcommands.
01:51:57 <dons> :)
01:53:22 <musasabi> SamB: ping.
01:54:16 <dons> @get-shhapr
01:54:16 <lambdabot> shapr!!
01:54:31 <dons> now, we start the clock, and so how long this takes... :D
01:55:46 <dons> @uptime
01:55:46 <lambdabot> uptime: 1 day, 11 hours, 22 minutes and 31 seconds
01:55:52 <jlouis> hehe dons
01:56:45 <shapr> yes?
01:57:03 <shapr> @uptime
01:57:03 <lambdabot> uptime: 1 day, 11 hours, 23 minutes and 48 seconds
01:57:28 <shapr> Seventeen seconds?
01:57:37 <dons> it works!
01:57:48 <dons> heya shapr. just testing the @get-shapr plugin
01:58:02 <shapr> Yay, it works!
01:58:09 <dblhelix> no, it took you at least a minute to get here
01:58:40 <dblhelix> shapr: this time it was just a drill---but what if there's a real emergency? ;)
01:58:47 <dons> hey, have you seen my new mp3 frontend? www.cse.unsw.edu.au/~dons/hmp3.png
01:58:55 <dons> colors and niceness coming soon..
01:59:06 <shapr> In case of a real emergency, break glass?
01:59:21 <dblhelix> something like that
01:59:22 <shapr> Not sure how that will help, but it seems to be a popular response to emergencies.
01:59:35 <dons> ah, maybe we need @break too
01:59:38 <dons>  @break glass
01:59:43 <dons>  @break umm .. wind?
01:59:47 <shapr> heh
01:59:50 <shapr> dons: looks nice!
02:00:25 <shapr> It's neat getting email from SPJ, even if the subject isn't overly exciting.
02:00:28 <dblhelix> dons: it rocks! (i'm sure of that ;))
02:00:47 <dons> @where hmp3
02:00:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
02:01:23 <dons> I think I want the slogan to be: "Finally, an mp3 player that doesn't crash!"
02:02:23 <dblhelix> dons: what backend's required?
02:02:41 <flux__> dons, btw, are you aware of mpd, music playing daemon? (being a replacement for the mpg321-component)
02:02:51 <dons> ah, haven't seen that.
02:02:53 <shapr> Yeah, I used mpd and mpc.
02:02:58 <shapr> use*
02:03:00 <dons> dblhelix, it uses mpg321
02:03:12 <dons> but should work with anything that speaks the mpg123 protocol
02:03:16 <dons> other backends would be doable
02:03:49 <flux__> dons, the advantage(/disadvantage?) would be that you could exit the player and the music would continue
02:03:58 <flux__> (player being just the interface)
02:04:06 <dons> that's possible here, but seems to be ugly.
02:04:16 <dons> you can quite easily fork mpg321 too.
02:04:28 <dons> maybe there should be a daemon mode. not sure.
02:04:36 * dblhelix will give it a try when he gets home
02:04:38 <shapr> mpd was designed for a media pc, so it runs on a P75 and speaks tcp/ip
02:05:21 <dons> cool. i'm trying to make sure hmp3 is very light weight. so far seems to have a tiny footprint.
02:05:46 <dons> it generates no obvious load even when i clock my cpu back to 0.6Ghz
02:05:49 <shapr> mpd is very playlist oriented though, and that goes against the listening style of some people.
02:06:46 <earthy> 'back to 0.6GHz'
02:06:50 * earthy sniggers
02:07:12 <dons> ? too fast?
02:07:18 <shapr> ScannedInAvian.com runs at 0.6 GHz normally.
02:07:22 <earthy> back in the day, when processors running at 6 MHz and were considered fast.... ;)
02:07:27 <dons> hehe
02:07:33 <shapr> earthy: 4.77MHz
02:07:40 <dons> i should try on my 33MHz netbsd box.
02:07:46 <dons> good test in fact.
02:07:49 <earthy> shapr: no, that was the default speed for the PC and the PC/XT
02:07:59 <earthy> shapr: the 6 MHz was the 'turbo' speed
02:08:04 <earthy> (with turbo buttons and such :))
02:08:11 <dons> ah, if only for the days of turbo buttons
02:08:18 <dons> where did they go??
02:08:19 <shapr> Yeah, I know. 4.77MHz was fast at the time. I later got an upgrade to a turbo XT.
02:08:44 <shapr> This reminds me of some great stories from when I had a job repairing computers.
02:08:50 <earthy> dons: they disappeared because they were cumbersome and better solutions were found
02:09:24 <dsge_> Behold, the software turbo.
02:09:26 <shapr> We had a few clients who showed up every few months and said "My computer is slow again!" So we'd reverently press the turbo button and they'd go away happy.
02:09:41 <dons> yes yes, but it was kind of kitch and silly fun :)
02:09:45 * tessier remembers this moon lander program that he had to slow his computer down by pressing the turbo button to play
02:09:59 <shapr> sopwith wouldn't run if turbo was on.
02:10:16 <boegel> shapr: yaay, someone added a suggestion for 'take 10 [1..]' : " the most common and typical mistakes and errors made by (non-)newbies"
02:10:28 <shapr> Procomm+ was great with the turbo on.
02:10:38 <tessier> shammah: It made your modem go faster? :)
02:10:40 <shapr> boegel: cool!
02:10:57 <shapr> Nah, but it loaded BBS listings faster and that sort of thing.
02:11:10 <boegel> and I got a very cool mail on HRay too, someone who is new to Haskell and was amazed by the simplicity of HRay :)
02:11:16 <shapr> awesome!
02:11:19 <tessier> Hray?
02:11:48 <boegel> tessier: yes, a raytracer in Haskell
02:11:48 <tessier> A haskell ray tracer.
02:11:49 <tessier> I see.
02:12:11 <shapr> I had free internet access in 1989. I dialed into UTK and then I could telnet anywhere.
02:12:26 <dons> cool :)
02:13:05 <tuomov> I used such internet access until 1998 :)
02:13:33 <tuomov> i.e. until moving to a student dorm
02:13:38 <shapr> I'd tell my friends "Man, I spent fourteen hours on the Internet yesterday, I'm tired." and they'd say "What's the internet?"
02:13:58 <tessier> "Some new kind of drug?"
02:13:59 <tessier> "Yes."
02:14:33 * earthy had dialback back in 1993
02:14:36 <earthy> that was cool :)
02:15:12 <earthy> I'd dial in to the uni, logged in, hung up, and then the uni'd dial back, thereby carrying virtually all of the costs.
02:15:54 <tuomov> (I mean, internet through free BBS)
02:15:56 <earthy> unfortunately that program was killed midway through 1994
02:17:17 <shapr> Ah, the bad old days when compilers cost a month's income, and so did hardware.
02:17:53 <earthy> no, I'm pretty sure I had linux and gcc back then.
02:17:57 <earthy> pretty *damn* sure. :)
02:18:09 <tuomov> the bad old days of banging BBSs for a free line..
02:18:11 <shapr> I didn't have them in 1989.
02:18:37 <shapr> I did pick up on Oberon though.
02:18:41 <earthy> no, not in 1989. that does sound like about the time Visual Basic 1.0 came out though...
02:18:45 <dons> would make it kind of hard for young hackers to get started
02:18:59 <dons> though there's basic I guess.
02:19:22 <earthy> there is. and assembler ofcourse. hand-assembled to binary code and entered through basic DATA statements. :P
02:19:53 <earthy> and we'd 'trade' turbo pascal
02:19:58 * boegel mentions this should be taken into #haskell-blah
02:20:02 <shapr> I do wish I'd grown up in these days when Haskell is available.
02:20:03 * earthy nods
02:20:06 * shapr quickly gets back on topic
02:20:25 <earthy> but, haskell was developed 'round that time as well, wasn't it?
02:20:40 <shapr> But then maybe I wouldn't have given up on programming for a few years and focussed on women :-)
02:20:58 * tessier is programming a woman
02:21:01 <tomaszz> in Poland in 1990 the cost of a PC was 18 times the average monthy income :-(
02:21:21 <dons> weren't we stuck with Miranda for a few years?
02:21:22 <shapr> tomaszz: That sucks.
02:21:51 <dons> though Gofer has been free since the early 90s. and LML before that.
02:21:53 <tomaszz> shapr: but in 1992 it was only 7x
02:22:00 <tomaszz> shapr: :-)
02:22:18 <earthy> and lisp even way before that
02:22:40 <ibid> istr haskell compilers were non-free still in the very late 90's
02:22:44 <earthy> 'The first version of Haskell (1.0) was defined in 1990.'
02:22:47 <ibid> ("academic use allowed")
02:22:57 <tessier> lithp
02:23:13 <tessier> What an unfortunate name. McCarthy couldn't have known back then though.
02:23:19 <araujo> Good morning!
02:23:37 <shapr> Well, it was short for list processing.
02:23:41 <tessier> At least he didn't call it FAG: Functional Algorithm Generator
02:23:42 <masm> What is the name of function (\f x -> f x)?
02:23:43 <tessier> or something like that
02:23:53 <dcoutts> morning araujo, gour
02:24:05 <earthy> and the idea was to have a nicer syntax on top of the semantic core
02:24:15 <ibid> masm: apply?
02:24:20 <earthy> that just never really materialized for lisp
02:24:44 <tessier> So many languages to choose from...
02:24:50 * tessier is still trying to figure out where to hang his hat
02:24:56 <masm> ibid, in haskell. Is there a name for it in haskell?
02:25:05 <earthy> ($)
02:25:10 <dons> > id $ 2
02:25:10 <lambdabot> 2
02:25:18 <masm> OK.
02:25:21 <earthy> *ooh* that's cool. :)
02:25:40 <earthy> > map (* 2) [1,2,3,4]
02:25:41 <lambdabot> [2,4,6,8]
02:25:50 <dons> just syntax, but something about it seems nice :)
02:25:58 <gour> dcoutts: early morning, ah?
02:26:05 <earthy> dons: it's *very* cool. :)
02:26:06 * gour joking
02:26:16 <earthy> even though it's simply a different syntax for @eval
02:27:10 <dons> yeah, feels much more lightweight and literate-ish. since we already have a common format for mixing text and code, may as well use it :)
02:29:21 <joelr> howdy
02:29:25 <joelr> shapr: ping
02:29:58 <shapr> pong
02:30:14 <joelr> shae can you give me a hand with something obvious?
02:30:16 <shapr> ¿hola, como est as?
02:30:23 <shapr> Maybe, what is it?
02:30:25 <joelr> shapr: my bien, gracias!
02:30:26 <joelr> bar :: forall e l.HCons e l -> e
02:30:26 <joelr> bar (HCons x HNil) = x
02:30:31 <joelr> this does not compile, why?
02:31:17 <dcoutts> gour, the new OpenGL code is now in the Gtk2Hs darcs mirror
02:31:22 <shapr> Have you tried flip HCons?
02:31:24 <joelr> actually, i see that the type signature for bar should be
02:31:32 <joelr> bar :: forall e.
02:31:32 <joelr>        HList.HListPrelude.HCons e HList.HListPrelude.HNil -> e
02:31:54 <joelr> but i want a universal function of sorts
02:32:06 <joelr> for any l as well
02:32:11 <joelr> shapr: flip HCons?
02:32:17 <joelr> what does that do?
02:32:25 <shapr> acrobatics!
02:32:32 <shapr> Ok, not really.
02:32:34 <joelr> shapr: doesn't seem to be in HListPrelude.hs
02:33:21 <shapr> @type flip
02:33:22 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
02:33:35 <gour> dcoutts: ohh, i have to test it to validate your work
02:33:42 <joelr> shapr: show me an example
02:33:44 <gour> dcoutts: may i ask you two questions?
02:33:46 <joelr> with bar
02:33:53 <joelr> i.e. how would i rewrite bar
02:34:46 <joelr> shapr: it seems like i need a class and then to make both HCons e l and HNil instances of that class
02:35:09 <shapr> I don't know anything more about OOHaskell than you taught me yesterday.
02:35:22 <joelr> shapr: so about that error... what would you do?
02:35:37 <joelr> to have a generic function that can take any HCons e l
02:35:45 <joelr> seems rather simple, right?
02:35:55 <shapr> What error do you get?
02:36:13 <joelr>     Couldn't match the rigid variable `l' against `HNil'
02:36:19 <joelr>       `l' is bound by the type signature for `bar'
02:36:25 <joelr> expected type l but got HNil
02:36:47 <shapr> Tried removing the type sig?
02:36:57 * gour discovers he did not sync gtk2hs repo since Oct 26th
02:37:15 <joelr> bar :: forall e.
02:37:15 <joelr>        HList.HListPrelude.HCons e HList.HListPrelude.HNil -> e
02:37:58 <shapr> Do you still get the error if you remove the typesig?
02:40:13 <tomaszz> > 2
02:40:14 <lambdabot> 2
02:40:24 <shapr> > 22222
02:40:25 <lambdabot> 22222
02:40:32 <tomaszz> id `id` 2
02:40:41 <tomaszz> > id `id` 2
02:40:42 <lambdabot> 2
02:40:49 <shapr> @type mfix
02:40:49 <lambdabot> Not in scope: `mfix'
02:40:58 <dcoutts> gour, sure, ask away
02:40:58 <shapr> > mfix (+ 1)
02:40:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
02:40:59 <lambdabot>   Expected type: a -> m a
02:40:59 <lambdabot>   Inferred type: a -> a
02:43:04 <gour> dcoutts: is the present ffi ready for C++ ? (i'm not asking for myself, but there is a discussion on lyx-users regarding the lyx's front-ends - see http://www.mail-archive.com/lyx-users@lists.lyx.org/msg43078.html)
02:43:05 <joelr> shapr: i got it to work by following the ShowComponents example from Record.hs
02:43:33 <dcoutts> gour, it's not very easy to use C++ with Haskell's FFI
02:43:48 <joelr> you need to create a class with a mathod that works for both HNil and the HCons cell and then instantiate it for HNil and HCons e l separately
02:43:50 <dcoutts> gour, it's mainly because of C++ name mangling being a right pain
02:44:32 <gour> dcoutts: yes, i was reading somethng about that mangling problems with c++ (in general)
02:44:37 <dcoutts> gour, eg wxHaskell uses wxWidgets which is a C++ lib. It have to build an intermediate C lib to export the names with C names rather than C++ names.
02:45:05 <gour> dcoutts: so, too much hassle, that's why gnome stays with C?
02:45:47 <shapr> joelr: You got what to work?
02:46:05 <joelr> shapr: that tihng that i was trying to do :-)
02:46:10 <gour> dcouts: but would any any value in providing liblyx?
02:46:35 <shapr> Instead of using deriving?
02:47:14 <joelr> no, using a 1-method class for that "generic" method and deriving it separately for HCons e HNil
02:47:22 <gour> dcoutts: i'd like to see more rapid development of such a nice tool (gtk port especially)
02:47:31 <dcoutts> gour, it used C originally because C++ was not very mature on linux at the time gtk/gnome started. Also it was well known then and now that all other high level language can bind to C but very few can bind to C++. The aim was always to allow people to use Gtk+ in other high level languages.
02:47:37 <joelr> you actually need 3 definitions: HNil, HCons e HNil and HCons e l
02:47:49 <dcoutts> gour, yeah, lyx is great. I've used it quite a bit.
02:48:30 <joelr> i.e. one for empty list, one for list of 1 item and one for a generic list. it looks like that is how it works
02:48:31 <gour> dcouts: i did two books with it (my mother's autobiography in tow parts), each part over 400p.
02:49:41 <shapr> Does anyone know Brianbec's email address?
02:50:38 * dcoutts has to go teach now
02:51:03 <gour> dcoutts: ok, next question later, good luck :-)
02:59:00 <masm> Is there a name in the prelude for (\n -> [1..n])?
03:00:07 <shapr> Enum ?
03:00:12 <ustenzel> masm: enumFrom 1
03:00:30 <ustenzel> masm: errn, enumFromTo 1
03:03:16 <boegel> @eval (enumFromTo 1) 10
03:03:17 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
03:06:10 <boegel> does anyone know a good statistics package for unix ?
03:07:19 <shapr> R
03:07:22 <jlouis> R
03:07:26 <jlouis> without doubt
03:11:27 <shapr> Being sick is no fun.
03:20:18 <gus> dons: I'm having troubles in installing hs-plugins together with haskell-src-exts. When I configure I get:  Couldn't match `IO GHC.IOBase.ExitCode' against `t -> t1'
03:20:18 <gus>  . Do you know what is wrong?
03:25:56 <dons> you don't need hsx anymore.. just grab hs-plugins from darcs.
03:26:17 <dons> or do you need hsx for a specific reason?
03:26:34 <gus> yes, I need it for Niklas Broberg's HSP
03:27:02 <dons> hmm. not sure what the problem is, but it doesn't sound too hard to fix.
03:27:03 <gus> I'm doing a project that intends to extend HSP
03:27:30 <gus> ok, do you think I can fix it myself, or is it a problem in the hs-plugin code?
03:27:50 <dons> nah, sounds like a simple type error. some interface has changed. see if you can fix it, then send me the patch.
03:28:18 <dons> hmm. or is this when running Setup.hs ?
03:28:39 <gus> yes, when running setup.hs configure
03:29:45 <dons> hmm. does the error mentCoin 'xxx' ?
03:30:12 <gus> what do you mean?
03:30:33 <dons> does it mention a variable named 'xxx'?
03:30:44 <gus> yes
03:30:48 <dons> ah!
03:30:54 <gus> ((postConf defaultUserHooks) args' flags lbi xxx)
03:31:04 <dons> then it is a Cabal issue. cdelete the variable 'xxx' from the Setup.hs file :)
03:31:21 <dons> I'm using a newer version of Cabal than you are.
03:31:54 <gus> Ok, I'll try that. Thanks!
03:32:26 <gus> But I think I've installed the newest version of cabal. Maybe I didn't get it right...
03:32:47 <dons> i'm using the darcs version of Cabal.
03:32:54 <dons> 1.1.4
03:33:37 <gus> Aha! I downloaded the tarball from the homepage
03:38:22 <neadjneki> hi
03:39:37 <gus> dons: I got another error now: dist/build/src/Language/Hi/hschooks.o  does not exists
03:41:03 <dons> hmm. possibly Cabal breaking the build?
03:41:26 <neadjneki> what is the right way of lifting if i want to use a monadic value in several nonmonadic functions? (so, is there a way to avoid the several liftM's?)
03:41:43 <dons> not sure, gus.
03:41:52 <shapr> dons: What do you think of SPJ's email to haskell@ ?
03:42:29 <dons> interesting, i'm in the middle of a hackathon, so I haven't considered it deeply. sounds a bit like an extensionn of the 'future of haskell' discussion from the HW
03:42:38 <gus> I'll try downloading cabal from darcs instead..  What is the adress to the repository?
03:43:17 <dons> it's http://cvs.haskell.org/darcs/cabal
03:43:21 <dons> @where cabal
03:43:21 <lambdabot> http://www.haskell.org/cabal
03:43:25 <dons>  hmm. we need @darcs
03:43:28 <dons> just for repos.
03:43:37 <shapr> yeah
03:43:56 <dons>  @karma points for anyone who wants to add @darcs to the @where plugin!!
03:44:01 <dons> easy hack,. good introductoin.
03:44:23 <dons> @version
03:44:23 <lambdabot> lambdabot 3p180, GHC 6.5.20050806 (Linux i686)
03:44:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:44:44 <dons> must be getting close to 1000 patches in a calendar year for lambdabot!1
03:45:01 <shapr> cool!
03:52:06 <gour> shapr: it is possible that trac+darcs patches get into trac, see http://projects.edgewall.com/trac/ticket/2148
03:52:53 <gour> shapr: although i do not know if trac can serve reqs of haskell.org (regarding SPJ's email)
03:58:56 <shapr> It doesn't have spam control.
03:59:17 <shapr> I'd be happiest installing Flippi and then getting the whole community to fix any problems :-)
04:00:47 <shapr> I'm thrilled that SPJ mentioned #haskell, TMR, and HaWiki as good things :-)
04:00:53 * shapr bounces cheerfully
04:02:02 <dons> :D
04:02:14 <Itkovian> is it possible to have parsec do something like this:
04:02:42 <Itkovian> parseMyKeywords = makeTryParser ["keyword1","keyword2","keyword3"]
04:02:48 <Itkovian> which should build
04:03:14 <shapr> All the cool new tools in lambdabot really help -Ofun for #haskell
04:03:52 <Itkovian> do { try ( myKeywordParser "keyword1") <|> try ( myKeywordParser "keyword2") <|> try (myKeyWordParser "keyword3") }
04:04:04 <SamB> musasabi: you want to play with the wire protocol?
04:04:13 <Itkovian> boegel: R
04:04:23 <musasabi> SamB: yes, it sounds like something fun to hack over the weekend.
04:04:30 <Itkovian> boegel: the only drawback being that the API somewhat sucks.
04:04:46 <dons> ah, that's a good point shapr. lambdabot is definitely about -Ofun
04:04:47 <boegel> Itkovian: any others ?
04:05:03 <Itkovian> boegel: maybe you could try the stuff in scilab
04:05:11 <Itkovian> but I don't think it's very complete
04:05:18 <Itkovian> boegel: or octave - matlab clone
04:05:24 <SamB> musasabi: how shall I remain aware of any changes you make?
04:05:36 <boegel> Itkovian: I think I'll stick to R and use your expertise ;)
04:05:39 <Itkovian> but I'd go with R
04:05:41 <Itkovian> haha
04:05:46 <SamB> I prefer something involving "darcs pull"
04:05:52 <boegel> since both shapr and jlouis mentioned it too...
04:05:58 <SamB> because I'm not too sure how to use "darcs apply" with gmail
04:06:10 <Itkovian> I've got a script that allows you to build yr R scripts and run them form the shell, with args and all
04:06:15 <shapr> SamB: Save the patch to a file, then darcs apply the file.
04:06:39 <shapr> But I agree, darcs pull is easier. Have you seen how CosmicRay does haskell-v8 ?
04:06:45 <SamB> shapr: I tried that before, but it didn't seem to be working. I think it might have been a line-end issue.
04:07:14 <boegel> shapr: SPJ mentioned TMR on the haskell mailing list ! w00 ! together with HWN
04:07:53 <shapr> SamB: weird, maybe ask for --sign and .. can --compress be used with darcs send?
04:09:04 <Itkovian> I see no sign of any SPJ mail ...
04:09:12 <shapr> Itkovian: on haskell@
04:09:15 <SamB> shapr: well, --sign would definately tell me if it got through intact at least...
04:09:18 <Itkovian> ah
04:09:18 <shapr> boegel: yeah, awesome!
04:09:33 <Itkovian> ok, I'm only subscribed to haskell-cafe and haskell-libraries
04:09:37 <SamB> dunno if it would keep gmail from mangling it or not...
04:10:17 <shapr> But you'd know whether it was gmangled then.
04:10:41 <SamB> shapr: yes, I said that already ;-)
04:11:34 <SamB> okay, what are the RTS flags for profiling?
04:11:58 <boegel> is haskell-libraries interesting ?
04:12:52 <dons> pretty quite. but there's much discussoin of APIs and such like
04:12:58 <dons> pretty quiet
04:13:54 <boegel> hmm, nothing for me then I guess
04:14:21 <gus> dons:  hs-plugins installation works for me now! Thanks for helping me!
04:15:19 <dons> cool!
04:17:53 <xinming> how to define a type variable please?
04:18:04 <boegel> xinming: ?
04:18:12 <xinming> 'test :: a -> a' doesn't work
04:18:33 <xinming> test :: a -> a "\n" test x = x * x
04:18:53 <xinming> I wish this can be used as Float.
04:19:13 <kosmikus> @type \x -> x * x
04:19:14 <lambdabot> forall a. (Num a) => a -> a
04:19:28 <kosmikus> xinming: try that as type
04:19:57 <xinming> kosmikus: thakn
04:19:59 <xinming> thanks,
04:20:18 <xinming> But I was reading art of functional programming. A bit confused. :-(
04:20:22 <xinming> I'll try that
04:20:34 <kosmikus> or better, use just "(Num a) => a -> a", because the "forall a." part is a Haskell extension
04:21:12 <kosmikus> but if you just omit the type signature, Haskell will derive the correct type for you
04:21:27 <kosmikus> so your "test" will work on Floats automatically if you don't write anything
04:21:50 <gour> shapr: suggestin for trac & spam which i got:  disable anonymous contributions
04:22:14 <shapr> Yeah, that might be the best approach.
04:22:29 <gour> it's reasonable too
04:23:43 <boegel> @type (>>=)
04:23:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
04:23:56 <gour> shapr: have you read: http://software.newsforge.com/article.pl?sid=05/10/12/1425223&from=rss
04:24:40 <boegel> @type flip (>>=) foldr
04:24:41 <lambdabot> forall a b. (Monad ((->) b)) => (b -> a -> b -> b) -> b -> [a] ->
04:24:41 <lambdabot> b
04:25:03 <boegel> @type flip (>>=) foldl
04:25:04 <lambdabot> forall a b. (Monad ((->) a)) => (a -> a -> b -> a) -> a -> [b] ->
04:25:04 <lambdabot> a
04:25:11 <boegel> Itkovian: ^?
04:25:33 <boegel> man, I really need to get myself into monads
04:28:40 <shapr> boegel: They're great, you'll love 'em
04:28:57 <shapr> gour: No, but I'll check it out when I get back from shopping.
04:29:30 <gour> shapr: i wish you nice unicyling ;)
04:31:40 <Itkovian> found it, I think : Prelude Text.ParserCombinators.Parsec> parse (foldl (<|>) (try (string "TT")) [try (string "rr"), try (string "gg")]) "" "gg"
04:31:43 <Itkovian> Right "gg"
04:35:26 <Itkovian> i.e. parse (let s = ["TT","rr","gg"] in let s' = map (\x -> try (string x)) s in foldl (<|>) (head s') (tail s')) "" "rr"
04:35:40 <Itkovian> I love first class functions
04:38:38 <eivuokko> foldl1 might be even nicer
04:39:16 <SamB> (let s = ["TT","rr","gg"]; s' = map (\x -> try (string x)) s in foldl (<|>) (head s') (tail s')) "" "rr"
04:39:48 <SamB> no need for multiple lets
04:40:20 <musasabi> SamB: I'll talk about them and you can discard them if you don't like them.
04:41:24 <SamB> musasabi: can you put them in a repo somewhere?
04:41:41 <SamB> (somewhere I can pull from, that is)
04:42:29 <Itkovian> eivuokko: right!
04:44:47 <musasabi> SamB: yes, that sounds like a good plan.
04:45:24 <SamB> I have a class to get to, I better go...
04:45:34 <Itkovian> SamB: thx
04:45:46 <Cale> @help get-shapr
04:45:47 <lambdabot> summon shapr instantly
04:45:57 <Cale> heh
04:46:22 <shapr> you called?
04:46:34 <shapr> False Alarm!
04:46:39 <Cale> hehe
04:46:43 <SamB> heh, I added that to the todo list awhile back... never thought it would be implemented!
04:46:55 <shapr> @get-shapr
04:46:55 <Cale> @get-shapr
04:46:55 <lambdabot> shapr!!
04:46:56 <lambdabot> shapr!!
04:46:59 <shapr> I'm here!
04:47:01 <Cale> hehe
04:47:22 <Cale> I saw it in the changes to the lambdabot darcs repo
04:47:46 <Cale> unfortunately, the first of 72 patches seems to take forever to merge
04:47:50 <shapr> If you want real functionality, you can use ctcp page. My emacs usually woofs when that happens.
04:50:05 <boegel> shapr: do you have people writing articles for TMR6 ? I just want to know when I should get started on my first 'take 10 [1..]' issue
04:51:06 <shapr> sort of
04:51:12 <shapr> humasect is working on one,
04:51:31 <shapr> And I think I'll get Dmitry to write an HsFFIg tutorial.
04:51:46 <shapr> And I want to steal roconnor's latest wiki content for the next part of my Software Testing series.
04:51:57 <shapr> With you that'd make four.
04:52:00 <shapr> Any suggestions for a fifth?
04:52:23 <boegel> dunno, maybe you could ask around again :) you're planning to release on in Dec then?
04:52:29 <shapr> I hope so.
04:52:45 <shapr> Whenever TMR has five more articles.
04:52:46 <shapr> hej bringert
04:52:50 <bringert> hej shapr
04:52:54 <shapr> wazzup?
04:52:59 <boegel> okay, fine, I'll make sure I have the first issue of 'take 10 [1..]' by then
04:54:27 <bringert> shapr: I'm gonna try to install some haskell libs for the project I'm supervising, so I figured this would be a good place to hang out right now
04:54:38 <bringert> shapr: what are you working on?
04:55:27 <shapr> The usual seven or twenty half finished projects :-)
04:55:50 <shapr> Including my plan of moving to Stockholm after the summer.
04:57:12 * shapr wanders away to purchase ritalin...
04:58:58 <dons> new hmp3 screenshot, now in technicolour: http://www.cse.unsw.edu.au/~dons/hmp3.png
04:59:38 <earthy> wat, you used vim's syntax coloring? :P
05:00:06 <earthy> ah, apparently not
05:00:13 <dons> you haven't seen my new mp3 frontend?
05:00:16 <dons> @where hmp3
05:00:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
05:00:22 <earthy> dons: I had. :)
05:00:24 <dons> it's now about 10 hrs old!
05:00:32 <earthy> it's cleaner like this
05:00:42 <dons> looks much nicer, I think
05:01:04 <dons> more like mutt, irssi, snownews etc.
05:01:16 <earthy> hm. right.
05:01:21 <earthy> my mutt and irssi are b/w
05:01:39 <earthy> but I'm oldskool like that
05:01:47 <dons> well, so would mp3 on an old terminal.
05:02:05 <dons> but, gee, i couldn't live w/o syntax highlighting in mutt at least.
05:02:11 <dons> irssi could work in b/w though
05:02:29 <bringert> dons: with hs-plugins from darcs, I get Setup.hs:8:19:
05:02:29 <bringert>     Couldn't match `IO GHC.IOBase.ExitCode' against `t -> t1' ...
05:02:37 <bringert> when running Setup.hs configure
05:02:57 <bringert> is it a Cabal version thing?
05:03:31 <bringert> ghc 6.4.1 on amd64 (ubuntu breezer), Cabal-1.0
05:03:42 <dons> yes. you either need darcs cabal, or remove the 'xxx' argument in Setup.hs
05:03:49 <dons> in fact, scroll up to see gus have the same problem
05:04:12 <bringert> ah, I just come here
05:04:30 <bringert> I believe gus might be the person who asked me to install it :-)
05:05:56 <bringert> gus: I'm building hs-plugins for you right now :-)
05:06:35 <dons> i think he got it built?
05:08:09 <bringert> thanks dons, it isntalled fine now
05:10:01 <dons> it's the cabal version thingy. maybe i was too keen to upgrade to the new cabal.
05:10:15 <dons> though breaking hs-plugins is an interesting way to find out how many people are using it :D
05:12:21 <dons> night all!
05:14:12 <dons> anyone who wants to play with hmp3, it lives at darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
05:14:17 <dons> ;)
05:17:08 <boegel> dons: what is it ? a Haskell mp3 player ?
05:19:23 <dons> yep.
05:19:41 <gour> dons: gour@gaura-nitai ~/repos/hmp3/dist/build/hmp3 $ ./hmp3 counsel.mp3
05:19:50 <gour> dons: hmp3: /usr/local/bin/mpg321: executeFile: does not exist (No such file or directory
05:19:56 <gour> dons: hardcore paths?
05:20:00 <dons> was it found a configure time?
05:20:08 <dons> it's found by configure.
05:20:19 <dons> (though it should use $PATH)
05:20:24 <gour> dons: checking for mpg321... /usr/local/bin/mpg321
05:20:41 <dons> oh, maybe my test is wrong.
05:20:47 <dons> sounds buggy .
05:21:01 <dons> yeah, I miswrote the test.
05:21:16 <gour> dons: although it's not installed :-)
05:21:26 <gour> dons: anyway, now i have to go
05:25:32 <dons> fixed.
05:27:12 <dons> really night now.
05:30:30 <boegel> g'night dons
05:34:10 <GustafN> Anyone that knows how to install Cabal as a user? I don't have root access..
05:34:20 <boegel> --prefix ?
05:35:29 <GustafN> as in: make install --prefix=$HOME    , or something like that?
05:37:28 <boegel> GustafN: no, as in ./configure --prefix=/path/where/you/want/it; make; make install
05:41:29 <boegel> yo b0gg1e
05:41:40 <GustafN> the file configure doesn't exists, but I did a  ./setup configure --prefix=$HOME --user    , that didn't work though
05:41:47 <b0gg1e> rehi.
05:42:00 <boegel> GustafN: hmm, is there a readme or something ?
05:42:36 <GustafN> yes, but it only mentions how to remove the "old" cabal from my ghc-pkg list
05:44:55 <Cale> heh, sorry about that :)
05:45:07 <Cale> forgot to config
06:05:50 <joelr_> folks, could someone please help me with @paste?
06:09:01 <boegel> @paste
06:09:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:09:04 <boegel> :)
06:09:09 <joelr_> mm
06:09:28 <boegel> just go there, click the little white balloon, paste your stuff and click save
06:09:35 <joelr_> i already did
06:09:48 <joelr_> would you kindly take a look?
06:09:52 <boegel> oh, that way :)
06:10:01 <joelr_> yeah, you thought it was simple? ;)
06:10:29 <boegel> heh
06:10:34 <boegel> the pickle thing again
06:10:35 <boegel> hmm
06:10:41 <boegel> what's wrong with it ?
06:10:54 <joelr_> below the code
06:10:57 <joelr_> there's an error message
06:11:08 <joelr_> Couldn't match the rigid variable e' against PU e'
06:11:57 <takuan> how do i pass arguments to main?
06:12:01 <boegel> hmm, can't help there, sorry
06:12:11 <joelr_> ok
06:12:15 <boegel> @index getArgs
06:12:16 <lambdabot> System.Environment
06:12:44 <boegel> do 'import System', and then use args <- getArgs in do notation, that gives you an array of the args
06:12:52 <takuan> aha
06:18:07 <takuan> now how do I convert a IO string into a double?
06:18:51 <mauke> do { str <- io_str; let x = read str; ... }
06:22:25 <ProfTeggy> Hi all.
06:22:29 <xerox> Howdy!
06:23:04 <ProfTeggy> We are pondering the idea of building a debugger for XQuery, using declarative debugging technology developed in the Haskell realm as a starting point.
06:23:17 <ProfTeggy> I know of Hood and buddha.  What else is out there?
06:23:22 <xerox> hat?
06:23:23 <ndm> ProfTeggy: Hat
06:23:37 <ProfTeggy> Ah, 'hat'... yes, how could that escape me. Thanks!
06:23:37 <ndm> see the Hat day report, that has some stuff on hat-delta
06:24:00 <ndm> http://www.cs.york.ac.uk/ftpdir/reports/YCS-2005-395.pdf
06:24:01 <ProfTeggy> ndm, will do
06:24:10 <ProfTeggy> :-)
06:24:12 <ProfTeggy> *click*
06:25:39 <eivuokko> What does tagless mean when used in context of programming language (evaluation).  Just that there is no runtime reflection-based capabilities?
06:30:25 <boegel> shapr: w00 ! FLM on haskell@ ! w00 !
06:31:23 <boegel> is Hat going to get integrated in hIDE ?
06:32:29 * xerox pats boegel's (_|_)
06:33:47 <joelr_> anyone can help me with paste?
06:35:21 <boegel> xerox: ? :)
06:35:36 <xerox> boegel: url? :-)
06:36:14 <boegel> xerox: for the FLM post?
06:36:33 <xerox> boegel: yeah!
06:36:54 <boegel> umh, it's on the Haskell mailing list, dunno where those logs are kept
06:36:56 <Itkovian> yeah!
06:37:06 <Itkovian> it may convince shapr to finish it.
06:37:13 <joelr_> @paste
06:37:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:37:20 <joelr_> help!
06:37:21 <dblhelix> we really need that "bug shapr for flm" command now :)
06:37:26 <boegel> http://www.haskell.org//pipermail/haskell/2005-November/016794.html
06:37:43 <xerox> unfortunately gmane appears to list only -cafe :-|
06:37:46 <xerox> Danke.
06:37:46 <boegel> is that readable for everyone, without logging in ?
06:37:52 <xerox> Yep.
06:37:57 <boegel> ok
06:38:36 <boegel> " guess that could be speeded up if there were a real customer..."
06:38:46 * boegel gives shapr a kick in the butt
06:42:00 <dcoutts> xerox!
06:42:08 <xerox> yo, duncan!
06:42:19 <dcoutts> xerox, I have students asking how you generated some particular image
06:42:26 <xerox> heh
06:42:29 <dcoutts> xerox, they want to reproduce it
06:42:36 <dcoutts> because it's so cool looking :-)
06:42:40 <xerox> :-)
06:42:54 * dcoutts finds the pic
06:43:00 <xerox> I should polish nymphaea, make the menus work, and add a series of grammars.
06:43:07 <dcoutts> @where nymphaea
06:43:08 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
06:43:18 <dcoutts> http://haskell.galois.com/~paolo/nymphaea/porn/musk.png
06:43:43 <xerox> Ah!
06:43:43 <dcoutts> xerox, yeah, so I included that image at the beginning of the practical description
06:43:50 <xerox> I recall :)
06:43:53 <dcoutts> as a kind of motivation :-)
06:44:13 <dcoutts> "look what kind of cool pictures you can make if you finnish this practical"
06:44:16 <dcoutts> sort of :-)
06:44:26 <xerox> Let's see.
06:44:40 <boegel> dcoutts: are you doing a raytracing practical too ? :P
06:44:45 <dcoutts> anyway, some of the studetns are doing the optional parts which involve allowing multiple rules and choosing them randomly
06:45:10 <xerox> dcoutts, check the grammars in these shots: http://www.haskell.org/gtk2hs/gallery/Cairo-demo?page=2
06:45:21 <dcoutts> boegel, well I just got OpenGL working with Gtk2Hs on Solaris, so we could do 3D LSystems like your HaskLS version
06:45:28 <xerox> dcoutts, I think one of them is actually the source of musk.png.
06:45:44 <dcoutts> xerox, oh right, great
06:45:52 <dcoutts> xerox, thanks a lot
06:45:59 <xerox> dcoutts, indeed, I didn't save them other ways :)
06:46:07 <dcoutts> xerox, heh
06:46:16 <xerox> dcoutts, thank YOU for that :-)
06:46:32 * dcoutts hugs xerox
06:46:36 * xerox hugs back
06:46:44 <joelr_> uh, anyone willing to help a newbie?
06:46:47 * boegel lacks hugging
06:46:57 <xerox> Ah!  You're not a newbie!
06:47:00 * joelr_ tries his best to look like one
06:47:00 * xerox blinks
06:47:21 <boegel> dcoutts: so you'll make them render 3D L-systems using my code ? or will they write it themselves ?
06:47:22 <joelr_> umm... at least i got attention...
06:47:24 <joelr_> hehe
06:47:49 <xerox> boegel: what approach would work best for them to learn from? ;)
06:48:15 <xerox> joelr_: OO Haskell ?!!?!?
06:48:23 <Cale> Why do I always forget that State/passwd has to have the password in quotes whenever setting up lambdabot?
06:48:28 <joelr_> xerox: HList, just simple HList
06:48:47 <joelr_> Cale: can you help me out?
06:48:55 <Cale> maybe
06:48:59 <xerox> Cale, oh, it does authenticate?
06:49:00 * joelr_ begs Cale to take a look at paste
06:49:01 <Cale> what's the problem?
06:49:13 <dcoutts> boegel, so for the existing LSystems practical we give them the GUI. They just write a function which generates lines in absolute coordinates.
06:49:18 <boegel> xerox: hmm, I don't think it'll be easy to let it write them themselves
06:49:29 <boegel> dcoutts: okay :)
06:49:32 <dcoutts> boegel, so it'd be easy to exted that to the 3D case and then use OpenGL rather than cairo
06:49:46 <xerox> I think so too!
06:50:00 <dcoutts> boegel, I expect that just drawing a bunch of lines in OpenGL is quite easy
06:50:16 <boegel> dcoutts: it is :)
06:50:33 <boegel> dcoutts: just don't mention my code then, or it'll be too easy :P
06:50:46 <dcoutts> boegel, so the nice thing about the way we're doing the program is that it seperates the GUI code from the code that generates the LSystem and the drawing commends.
06:50:51 <dcoutts> boegel, right :-)
06:51:25 <boegel> dcoutts: I think mine is seperated too... not sure though
06:51:28 <dcoutts> boegel, we can't expect beginner Haskell students to use Gtk2Hs/HOpenGL/cairo directly.
06:51:29 * boegel checks
06:51:37 <boegel> off course not :)
06:51:55 <shapr> ouch
06:52:10 <dcoutts> so in the end it makes it a nice practical, they write a couple pure functions and we provide the GUI and they get great looking results
06:52:10 * xerox throws honey lambdas to shapr
06:52:54 <boegel> it is
06:53:07 <boegel> dcoutts: that's how they like it :)
06:53:08 <xerox> dcoutts, and you assign them the types for the functions? :)
06:53:17 <dblhelix> shapr sees himself faced with the task of finishing up on fml :)
06:53:28 <dblhelix> flm that is
06:53:34 <shapr> truly
06:53:40 <dblhelix> :)
06:53:52 <boegel> shapr: cool isn't it, you're going to save the Haskell world !
06:53:57 <shapr> haha
06:54:11 <Cale> joelr_: let me get OOHaskell
06:54:12 <shapr> Malcolm surely aimed the spotlight my way :-)
06:54:12 <dblhelix> kind of superheroish
06:54:13 * boegel mentions he knows shapr from before FLM
06:54:17 * shapr laughs
06:54:25 <dcoutts> xerox, yes the type of the functions they must write is prescribed.
06:54:27 <joelr_> Cale: you can get it from here
06:54:37 <joelr_> @google OOHaskell_cabal
06:54:38 <boegel> and I can prove it, I have emails to prove it !!1!1!! w00 !!
06:54:38 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/
06:54:50 <dcoutts> xerox, it has to be the right type so that it will work with the GUI
06:54:51 <xerox> dcoutts, do they involve IO ?
06:54:51 <dblhelix> shapr: I think you need a cape
06:55:00 <dcoutts> xerox, nope, they're pure :-)
06:55:08 <xerox> dcoutts, how do they do randomness? :)
06:55:12 <shapr> dblhelix: Who will wear the horns then when I shout Olé?
06:55:31 * dblhelix grins
06:55:32 <dcoutts> xerox, they can use an infinite list of random numbers
06:55:53 <dcoutts> xerox, which can be initialised in the IO monad but then passed in
06:55:56 <xerox> dcoutts, oh - that's right.
06:56:06 <dcoutts> xerox, or they can use a constant RNG seed
06:56:27 <xerox> which isn't big fun
06:56:32 * dblhelix imagines horns, a tail, and a sulfid smell when malcolm was writing his post
06:56:49 <shapr> xerox: gmane.comp.lang.haskell.general
06:56:50 <dcoutts> xerox, we make the random bits optional extensions to the practical
06:57:04 <xerox> shapr: d'oh!
06:57:46 <Cale> joelr_: pair :: PU a -> PU b -> PU (a,b)
06:58:00 <joelr_> Cale: what about that?
06:58:23 <Cale> hmm
06:58:53 <Cale> no, that does look okay, since you're passing it pe, which is presumably a (PU a)
06:59:05 <Cale> er, (PU e)
06:59:17 <joelr_> Cale: that's right
06:59:31 <shapr> bmedwar: Are you related to lambdawar?
06:59:36 <Cale> and then (puHList something), which ought to be PU of some type
06:59:45 <shapr> puHLeeze?
07:00:19 <Cale> heh
07:00:27 <gour|away> dcoutts: my 2nd question is related to the separation of gui & core stuff..
07:02:13 <Cale> hmm
07:02:32 <Cale> but there's no assertion anywhere that says that the initial list is filled with PU's
07:02:35 <joelr_> Cale: that's what I have been saying for the past 3 hours or so :(
07:02:44 <xerox> Did you see the Haskell Survey, from Hughes?
07:03:09 <joelr_> Cale: it is, I think, puHList is supposed to take a HCons cell (list) which PUs in it
07:03:18 <joelr_>     puHList :: HCons (PU e) l -> PU (HCons e l)
07:03:19 <boegel> xerox: yeah we did
07:03:25 <xerox> Woot!
07:05:08 <Cale> joelr_: that's the assertion, but where's the proof :) What happens when we call puHList on something of type HCons (PU Int) (HCons String HNil)
07:05:13 <dcoutts> gour, what's the 2nd question?
07:05:19 <Cale> ?
07:05:45 <joelr_> Cale: oh, bad things surely happen. PU is not a class, though
07:05:52 <gour> dcoutts: with a proper design it should be possible to separate gui part & core part of app?
07:05:57 <joelr_> Cale: are you saying it needs to be made into one somehow?
07:06:02 <Cale> possibly
07:06:16 <Cale> you need to be able to assert that everything in the HList is a PU
07:06:37 <joelr_> Cale: i cannot change / don't want to change PU from being a data, though. that's a slippery road
07:06:39 <gour> dcoutts: and therefore switch (relatively) use from one gui toolkit to another?
07:07:00 <joelr_> Cale: everything is built around PU being a data instead of a calss
07:07:03 <joelr_> class
07:07:06 <Cale> okay
07:07:13 <joelr_> how do you add an assertion around a data, though?
07:07:36 <dcoutts> gour, ideally yes, but it gets harder in a more interactive app
07:07:54 <gour> dcoutts: so i'm thinking what is your estimation how difficult it would be to switch from a gtk2hs to e.g. gnome2hs for a general-purpose application?
07:08:03 <shapr> gour: You can also use the /away command to save a message. Then when people send you private messages or do /whois gour they'll see your away message.
07:08:51 <gour> shapr: i thought i was away
07:09:28 <gour> shapr: marked as such in the nick's lists
07:10:14 <gour> shapr: something went wrong or ..?
07:10:32 <dcoutts> gour, well the gnome things are just extras on the Gtk+ things. I guess you'd have to live without the extra features or implement them differently.
07:10:45 <Itkovian> my preliminary bibtex parser is available at http://www.elis.ugent.be/~ageorges/software/hbib/
07:11:00 <Itkovian> mind you, it's very preliminary, but suggestions are welcome
07:11:25 <joelr_> Cale: any suggestions on how to do this while preserving the pickling backend (data PU)?
07:11:38 <Cale> I'll try some stuff
07:11:54 <joelr_> Cale: actually... take a look at Record.hs
07:11:55 <gour> dcoutts: for the present time - yes. i'm thinking if i start with gtk+, will transition be hard/complicated ?
07:12:17 <gour> dcoutts: if/when we get more gnome-related bindings
07:12:24 <joelr_> Cale: they solved it already for Record where the list absolutely must contain labels in each HCons
07:12:46 <joelr_> Cale: i just realized this
07:12:57 <gour> dcoutts: it would be nice to have a (more) complete framework, like e.g. wxwidgets
07:13:04 <shapr> hiya tony2
07:13:16 <tony2> hi
07:13:43 <dblhelix> shapr disguises himself as the Your Guide Through the Haskell World
07:14:01 <shapr> They call me.... a bot?
07:14:16 <dblhelix> mmm... let's try:
07:14:21 <dblhelix> @finish flm
07:14:21 <lambdabot> Unknown command, try @listcommands.
07:14:26 <shapr> uh oh
07:14:43 <joelr_> Cale: the HRLabelSet seems to be what the doctor ordered. i'm trying to pair a HList of picklers with a HList of values for pickling
07:14:45 <shapr> dblhelix: I have a bunch of deadlines this month, so I'm not yet convinced.
07:14:58 <dblhelix> seriously, no need to rush: just take your time and enjoy
07:15:15 <shapr> I'd like to finish it though, especially if it'll get used on haskell.org. That would be *way* cool.
07:15:30 <dblhelix> that's true of course
07:16:53 <joelr_> Cale: sorry, HLabelSet since HRLabelSet enforces uniqueness of labels
07:17:01 <dcoutts> gour, there arn't really many extra gnome widgets. The other gnome libs provide other things, like a VFS, config, printing support. It's not like gnome libs replace Gtk+.
07:17:23 <shapr> I want a real clock widget where I can drag the hands around to set the time.
07:17:55 * xerox sees cairo
07:18:00 <boegel> shapr: the real time, or your system time
07:18:01 <shapr> I'd also like a grandfather clock widget where I can drag a day/night disc and a seasons disc.
07:18:10 <dcoutts> gour, all commonly used widgets get added to Gtk+ itself. See http://live.gnome.org/ProjectRidley and http://live.gnome.org/LibgnomeMustDie
07:18:28 <shapr> boegel: I'm not picky, it's a widget for both display and input.
07:18:48 <dcoutts> shapr, cairo would certainly be appropriate for that
07:19:02 <dcoutts> shapr, or rather gtk with cairo
07:19:12 <shapr> Sounds cool
07:19:13 <gour> dcoutts: yes, i'm happy to see that, it means that gtk2hs support coverage will drop below 90% :-)
07:19:42 <dcoutts> gour, we'll certainly add support for new widgets when they get added to Gtk+
07:20:01 <gour> dcoutts: and it means that with gnome-vfs, gnome-db...we will have a pretty good gnome framework, right?
07:20:27 <Cale> hmm
07:20:40 <Cale> joelr_: perhaps it should be:
07:20:45 <joelr_> class PicklerSet ps
07:20:45 <joelr_> instance PicklerSet HNil
07:20:45 <joelr_> instance (HMember x ps HFalse, PicklerSet ps)
07:20:45 <joelr_>       =>  PicklerSet (HCons (PU x) ps)
07:20:51 <Cale> class (HList l, AllPU l) => HLPU l where
07:20:51 <Cale>     puHList :: l -> PU l
07:20:58 <Cale> class AllPU l
07:20:58 <Cale> instance AllPU HNil
07:20:58 <Cale> instance (AllPU l, HList l) => AllPU (HCons (PU e) l)
07:21:04 <joelr_> does that work for you?
07:21:18 <gour> dcoutts: my news feeder (liferea) says that someone hacked our site and posted an article
07:21:21 <Cale> what should puHList do with HNil?
07:21:33 <joelr_> Cale: lift HNil
07:22:01 <shapr> gour: Which site?
07:22:04 <joelr_> Cale: well, lift HNil will return a PU HNil
07:22:26 <joelr_> Cale: which is what I need, I think
07:22:48 <gour> shapr: gtk2hs
07:23:01 <Cale> yeah
07:23:06 <joelr_> Cale: there's a small issue, though, if you noticed
07:23:22 <joelr_> Cale: i'm traversing a list of picklers but building a list of the types being pickled!
07:23:40 <joelr_> Cale: it doesn't look like your declaration preserves that
07:24:23 <Cale> ah, right
07:24:26 <Cale> yeah
07:24:27 <joelr_> Cale: I need to build a giant pickler of cons cells containing my types while traversing a list of picklers
07:24:51 <Cale> I think I know what we need, perhaps
07:25:55 <dcoutts> gour, I think it was jsut a mistake, I'm looking into it
07:26:13 <gour> dcoutts :-)
07:26:39 <Cale> class Picklers l p | l -> p, p -> l
07:26:39 <Cale> instance Picklers HNil HNil
07:26:39 <Cale> instance Picklers l' p' => Picklers (HCons e l') (HCons (PU e) p')
07:26:48 <Cale> perhaps? :)
07:27:00 <joelr_> fundeps :) i was looking at it earlier today
07:27:21 <dcoutts> gour, I think Axel posted it
07:27:32 <joelr_> Cale: i think you have it reversed, though. it's from PU e to e
07:27:45 <joelr_> Cale: does that compile for you, though?
07:27:49 <Cale> well, the class is two-way
07:27:50 <gour> dcoutts: np, it was just a joke, but this one is not:
07:28:11 <gour> ghc --make RotatingCube.hs -o cube
07:28:11 <gour> Chasing modules from: RotatingCube.hs
07:28:11 <gour> Could not find module `Graphics.UI.Gtk.OpenGL':
07:28:11 <gour>   use -v to see a list of the files searched for
07:28:11 <gour>   (imported from RotatingCube.hs)
07:28:13 <gour> make: *** [cube] Error 1
07:28:29 <gour> what do i miss?
07:28:36 <Cale> it's a bijection of types -- Picklers l p asserts that p is a list of picklers for the types in the list l
07:28:57 <joelr_> Cale: so how do i apply it then?
07:29:31 <joelr_> Cale: i.e. where does puHList go?
07:29:45 <Cale> class (HList l, Picklers l p) => HLPU p l where
07:29:46 <Cale>     puHList :: p -> PU l
07:29:47 <Cale> I think
07:30:04 <Cale> actually, HList p as well
07:30:11 <joelr_> let me try that
07:30:57 <gour> dcoutts: i notice: checking for GTKGLEXT... checking whether to build gtkglext package... no
07:31:05 <joelr_> Cale: sorry, one last bit to get me over the hill... how do i apply it to pickling of HNil?
07:31:20 <Cale> instance HLPU HNil HNil where
07:31:20 <Cale>     puHList HNil = lift HNil
07:31:24 <joelr_> Cale: instance HLPU Hnil Hnil
07:31:42 <gour> dcoutts: let me try again..
07:31:47 <Cale> so far, all that compiles...
07:31:54 <Cale> now, the hard part
07:31:56 <joelr_> Cale try the second bit
07:32:04 <joelr_> Cale: with the Cons cell :)
07:33:11 <joelr_> instance HLPU (HCons (PU x) l) (HCons x l')  where
07:33:14 <Cale> oh, hmm
07:33:16 <joelr_> Cale: right?
07:33:44 <joelr_> Cale: actually, the simpler case is a HCons x HNil
07:34:11 <Cale> but we don't really care about that case, do we?
07:34:22 <Cale> it should be covered by the cons case
07:34:33 <Cale> instance (HList l, HLPU p l) => HLPU (HCons (PU e) p) (HCons e l) where
07:34:33 <Cale>     puHList (HCons pe l) =
07:34:33 <Cale>         wrap (\(a, b) -> HCons a b,
07:34:33 <Cale>               \(HCons a b) -> (a, b))
07:34:33 <Cale>                    (pair pe (puHList l))
07:34:35 <joelr_> Cale: i think we do because a list of 1 item is HCons x HNil
07:34:37 <Cale> that compiled
07:35:02 <Cale> !
07:35:05 <joelr_> Cale: when does that terminate, though?
07:35:06 <joelr_> ah!
07:35:14 <joelr_> it will try to pickle HNil!
07:35:16 <joelr_> yahoo!
07:36:13 <Cale> now, just trying to decide if we need this Picklers class at all
07:36:16 <joelr_> Cale: let me try pickling a couple of combinations of TourType and AvgPot
07:36:29 <Cale> no, we don't
07:36:34 <Cale> class (HList l, HList p) => HLPU p l where
07:36:34 <Cale>     puHList :: p -> PU l
07:36:53 <Cale> just dropping the picklers class and doing that should be okay
07:36:59 <Cale> might still want the fundep though
07:37:06 <joelr_> let me see
07:37:10 <Cale> class (HList l, HList p) => HLPU p l | p -> l, l -> p where
07:37:10 <Cale>     puHList :: p -> PU l
07:37:44 <Cale> since that's basically asserting the same condition through its instances
07:40:02 <joelr_> foo = hEnd (hBuild (AvgPot 100) (TourType TourSingle)) -- data
07:40:02 <joelr_> bar = hEnd (hBuild puAvgPot puTourType)
07:42:11 <joelr_> Cale: awesome!
07:42:20 <ulfdoz> so, duschen.
07:42:25 <ulfdoz> ECHAN, sorry
07:42:36 <joelr_> Cale: u would have never been able to figure it out!
07:42:36 <earthy> kein problem
07:42:54 <joelr_> Cale: would you post the solution to haskell-cafe in reply to my message?
07:43:25 <Itkovian> joelr_: any luck with the pickling?
07:43:35 <joelr_> Itkovian: of course. thanks to cale!
07:43:50 <joelr_> Cale: can i ask you about that TH bit? that would really make my day!
07:44:10 * joelr_ thinks that HList + pickler combinators = something truly awesome
07:46:45 <Cale> Yeah, I found out how much I'd forgotten about TH the other night :)
07:46:58 <Cale> but sure :)
07:47:07 <joelr_> Cale: see, without this bit i would need to write about 250 picklers that all look the same
07:47:17 <Cale> hehe
07:47:35 <Cale> yeah, that sounds like a good use of type-directed programming :)
07:47:35 <joelr_> Cale: and getting rid of all the boilerplate that i had with class-based pickling wetted my apetite
07:47:48 <joelr_> Cale: what sounds like good use?
07:48:00 <joelr_> Cale: scrapping the boilerplate with TH?
07:48:05 <Cale> getting rid of 250 picklers
07:48:37 <joelr_> Cale: yeah
07:48:48 <joelr_> because all they do is just remove the constructor, etc.
07:49:01 <joelr_> i need to preserve the type, so doing it with unsafeCoerce does not work
07:49:03 <Cale> or are you saying that you'll still need to write lots of picklers even with this HList bit?
07:49:13 <joelr_> Cale: yes, indeed. to wit
07:49:23 <joelr_> puAvgPot = wrap (AvgPot, \(AvgPot x) -> x) endian
07:49:27 <joelr_> puTourType = wrap (TourType . fromByte, \(TourType x) -> toByte x) byte
07:49:47 <Cale> actually, Data.Generics might be the answer
07:49:50 <joelr_> Cale: see how they look the same,  basically
07:50:09 <joelr_> Cale: the avg pot is for all those numeric picklers, they would all look like that
07:50:24 <joelr_> the puTourType is for Enums that store as a byte
07:50:40 <ustenzel> Cale: do you mean :+:, :*: and Unit?
07:50:43 <joelr_> i would rather have a set of generic picklers for different classes of picklers
07:50:59 <joelr_> hi udo
07:51:07 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
07:51:40 <joelr_> btw, you can't build a HList with just .*., it's reserved for labels somehow.
07:51:58 <joelr_> Cale: i used this in the previous incarnation of picklers... i think... well, i did use to/fromDynamic
07:52:17 <joelr_> Cale: how would generics help? i also read the 3 papers on scrapping your boilerplate
07:52:38 <ustenzel> writing a generic pickler instance turned out to be frustrating.  GHC is continually complaining about too complicated types.
07:53:08 <joelr_> Cale: wouldn't TH be easier in this case? you could just pass in the type where the constructor name is the same as the type
07:53:46 <Cale> hmm, possibly
07:54:14 <joelr_> Cale: apart from the type/constructor i need to pass in the pickler name (endian, byte) but that is easy
07:54:18 <ustenzel> oh, and SYB didn't work for me either, no gmap* seems to fit and gfold/gunfold just look alien to me.
07:54:52 <joelr_> Cale: but i can't figure out how to parameterize on constructor and type
07:55:25 <gour> dcoutts: this opengl demo is cool
07:56:37 <dcoutts> gour, heh, glad you like it :-)
07:57:02 <dcoutts> gour, now you jsut have to modify boegel's HaskLS program to use it rather than GLUT :-)
07:57:07 <dcoutts> @where HaskLS
07:57:07 <lambdabot> http://scannedinavian.com/~boegel/HaskLS/
07:57:45 <dcoutts> HaskLS already uses Gtk2Hs for the main part of it's interface but at the moment it uses GLUT for the OpenGL part.
07:58:02 <dcoutts> now it can use just Gtk
07:58:05 <gour> dcoutts: well, i'm not into this graphical & LS stuff so much
07:59:54 <gour> dcoutts: but it's nice as haskell (gtk2hs) ad ;)
08:00:36 <gour> dcoutts: i'd probably need more astro charts drawn
08:04:23 <joelr_> ustenzel: do you know TH?
08:05:10 <ustenzel> I understand the idea, but I haven't written a single line of working code with it.
08:05:38 <joelr_> ustenzel: ok
08:05:50 <joelr_> TH makes lisp macros look simple
08:06:06 <flowolf> hi all
08:06:31 <Cale> hello
08:07:01 <shapr> joelr_: Lisp macros don't typecheck.
08:07:17 <joelr_> shapr: true, but i would have solved this issue long time ago :(
08:08:29 <joelr_> puPlayersFlop = wrap (PlayersFlop, \(PlayersFlop x) -> x) byte
08:08:33 <joelr_> puTableName = wrap (TableName, \(TableName x) -> x) wstring
08:08:49 <joelr_> these look the same, except for byte/wstring and the name of the type/constructor
08:09:49 <joelr_> just the constructor name needs to be given as argument and spliced in, the pickler itself can be passed in as an argument
08:10:36 <Cale> I get syntax errors whenever I try to use [d| ... |]
08:10:49 <joelr_> Cale: right. on the second argument?
08:11:04 <Cale> no, on the |]
08:11:33 <Cale> [d| |] works
08:11:34 <joelr_> Cale: are you doing it like this?
08:11:34 <joelr_> pickler pu con = [| wrap ($con, \($con x) -> x) pu |]
08:12:39 <Cale> hmm
08:14:15 <joelr_> http://www.haskell.org/pipermail/template-haskell/2003-August/000151.html
08:14:21 <joelr_> looks like someone tried something similar
08:16:15 <Cale> I was thinking you'd want to TH declarations, rather than expressions
08:16:38 <joelr_> Cale: not sure what the difference is but i think it should resolve at compile time
08:17:27 <Cale> that way you'd have some interface like splice (mkPicklers ["AvgPot", "TourType", ...])
08:17:42 <Cale> and that would build all the picklers for you
08:17:47 <joelr_> Cale: sure
08:17:52 <Cale> perhaps up to that last bit
08:18:00 <joelr_> Cale: but it doesn't need to build them automatically
08:18:08 <joelr_> Cale: i don't think there's even a way to do that
08:18:34 <joelr_> Cale: just a way to splice in the constructor name
08:18:37 <musasabi> Using the HaskellDB CVS on SourceForge seems to fail - has anyone a recent checkout?
08:18:40 <joelr_> Cale: all i need
08:21:39 <musasabi> "As of 2005-11-01 at 10:00 Pacific, project's whose name begins with e, h, i or j will not have access to anonymous CVS, tarballs and ViewCVS. We are currently looking into this issue and hope to have it resolved soon."
08:21:54 <joelr_> Cale: check this out www.cs.chalmers.se/~ulfn/talks/mpc04.pdf
08:22:03 <joelr_> Cale: page 8
08:22:11 <joelr_> Cale: seems to be what we are looking for
08:22:36 <dcoutts> musasabi, heh luck that Gtk2Hs is in the 'g' category and not the 'h' category then :-)
08:24:01 <shapr> unlike haskell-libs
08:24:07 <shapr> Where I've already gotten questions.
08:25:08 <joelr_> Cale: no, that's not it :(
08:27:50 <CosmicRay> can anyone think of why this might be insufficiently lazy?
08:27:58 <CosmicRay>     where splitRecs [] = []
08:27:58 <CosmicRay>           splitRecs x = (\(this, next) -> this : splitRecs next) .
08:27:58 <CosmicRay>                         splitAt 129 $ x
08:28:05 <CosmicRay> basically the input to this function is the string from readFile
08:28:07 <CosmicRay> which is quite large
08:28:22 <CosmicRay> and I'm just mapM_'ing putStrLn over the result, at the moment.
08:28:29 <CosmicRay> but it does all the reads first, then does all the writes.
08:28:35 <Cale> pickler :: Name -> Q Exp
08:28:36 <Cale> pickler con = do
08:28:36 <Cale>     x <- newName "x"
08:28:36 <Cale>     [| \pu -> wrap ($(conE con), $(lamE [conP con [varP x]] (varE x))) pu |]
08:28:52 <joelr_> Cale: does that work?
08:29:02 <Cale> joelr_: it compiles at least :)
08:29:20 <joelr_> Cale: does that resolve at compile time or runtime
08:29:39 <Cale> it builds the appropriate expression at compile time
08:29:43 <joelr_> Cale: also, how do you invoke it?
08:29:58 <Cale> well, I should have wrapped the making of the name
08:30:01 * joelr_ would hire Cale in a jiff
08:30:17 <Cale> oh? I could use a job :)
08:30:54 <Igloo> CosmicRay: that is lazy
08:31:03 <CosmicRay> hrm.
08:31:14 <joelr_> Cale: i can't offer you one yet but i'll positively keep you in mind
08:31:23 <Igloo> But oddly written, IMO. I'd have used a case.
08:31:41 <CosmicRay> yeah
08:31:54 <joelr_> Cale: with these two bits (HList picklers and TH) i stand a good chance of finally delivering my project tomorrow. then there are some possibilities :D
08:32:08 <joelr_> Cale: i'll keep you posted
08:32:16 <joelr_> Cale: so how do i run this generic pickler?
08:32:21 <CosmicRay> Igloo: would you mind taking a look at the full program at http://www.complete.org/~jgoerzen/addcounty.hs
08:32:42 <Cale> grr, stage restrictions
08:32:46 <CosmicRay> it's only 30 lines and should be nice and lazy, but isn't.
08:32:48 <Cale> one sec :)
08:34:29 <Igloo> I can't see anything obviously wrong
08:34:38 <CosmicRay> strace confirms that it's doing all the reads, then all the writes
08:34:49 <CosmicRay> as does actual experience, where it sits processing for a few seconds before writing anything out.
08:34:50 <CosmicRay> hm.
08:35:04 <Cale> okay, this seems to work, but due to restrictions on TH which I don't understand, you have to declare your picklers in a separate module from where the TH stuff is defined in the first place
08:35:22 <Cale> I'll paste
08:35:23 <joelr_> Cale: what does that mean exactly?
08:35:25 <Cale> @paste
08:35:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:35:29 <joelr_> Cale: i do that anyway
08:35:40 <Cale> okay, then you'll have no problems :)
08:35:49 <Cale> puAvgPot' = $(pickler "AvgPot") endian
08:35:53 <Cale> is that okay?
08:36:01 <joelr_> Cale: that's pretty darn awesome!
08:36:06 <dcoutts> xerox, you've enticed flowolf to build ghc just so he can try out nymphaea :-)
08:36:59 <joelr_> Cale: i don't see the paste for some reason
08:37:24 <Cale> not yet :)
08:37:26 <xerox> dcoutts: hehe, nymphaea is rocking the house!
08:37:39 <joelr_> what's nymphaea?
08:37:46 <dcoutts> xerox, now we need the 3D version :-)
08:37:50 <Cale> xerox: which house?
08:38:06 <dcoutts> @where nymphaea
08:38:07 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
08:38:11 <xerox> Cale: at least 4 different houses these days :-)
08:38:18 <joelr_> oh, that gtk thingi
08:38:27 <dcoutts> joelr_, yep
08:38:39 <xerox> What could be the 'Payment Site' ?
08:38:47 <xerox> (filling the 'pay me' google form)
08:39:10 <dcoutts> xerox, I don't understand
08:39:40 <xerox> There is this field labelled 'Payment Site', near to 'Partecipant Name', 'Email Address', and 'Currency'
08:40:13 <Cale> somehow I managed to edit conflict with myself on the wiki
08:40:21 <Cale> the paste should be there now :)
08:40:31 <joelr_> looking
08:41:08 <Cale> oops, somehow got 2 copies of that OPTIONS_GHC line
08:41:18 <xerox> Hmrm..
08:42:25 <Cale> joelr_: the trouble is that the name has to be used in two different ways
08:42:53 <joelr_> Cale: i thought as much. seems like a lot of trouble too
08:43:18 <joelr_> Cale: you should reply to haskell-cafe :-) see parameterizing on type
08:43:19 <Cale> I'm not an expert with TH at all, so there might be a far more elegant way
08:43:28 <joelr_> Cale: you are in my book ;)
08:49:37 <joelr_> Cale: can i ask you one last question?
08:49:43 <joelr_> Cale: re: .*. in HList
08:50:40 <joelr_> never mind, i think i understand what the issue is
08:52:36 <CosmicRay> is there a "uniq"-like function in the standard library?
08:52:53 <CosmicRay> that is, in a list, drop every element where the last non-dropped element was identical to it?
08:53:19 <Igloo> nub
08:53:27 <Igloo> Oh, sorry
08:53:28 <Igloo> No
08:53:44 <CosmicRay> nub looks like a slightly less optimized version of what I'm after.
08:53:45 <CosmicRay> it may do.
08:53:59 <Igloo> That doesn't require identical elements to be adjacent
08:54:20 <CosmicRay> it's not a requirement for me either, but my data happens to be that way, and it would permit an optimization.
08:54:27 <antonio_pp> do YOU WANT A GIFT FOR THESE CHRISTMASTIDE? REGISTRATE And BUY FOR 35 SOME AMPLIFIERS OF ANTENNA FOR YOUR MOTIVE, HE ELECTS A GIFT, ALONE Y TO DO SO, IN A FEW DAYS YOU HAVE YOUR GIFT, IT IS TRUE, HURRY UP THAN READY APPROXIMATELY EMPTY ESTAN is WEB NEW http://ganaregalosgratis.com/index.php?Ref 7501 INDEED, I RIGHT NOW HAVE MOTIVE And AM AWAITING NOT OUR OWN. AS SOON AS POSSIBLE DO IT BEFORE YOU HAVE THE GIFT. IF DESCONFIAIS the Y ENTERS does HE JUDG
08:55:17 <flux__> ok.
08:55:20 <dcoutts> who's chanop and can ban that ip address?
08:55:31 <dcoutts> shapr?
08:55:41 <flux__> I think an irc-op would be a better person to ban the ip..
08:55:44 <CosmicRay> it's probably a zombie pc, and freenode should get to it.
08:56:26 <dcoutts> it looks like a zombie 158.red-213-37-172.user.auna.net
08:56:42 <joelr_> spanish zombie
08:56:56 <flux__> hmm.. are there real time lists for known zombie pc's?
08:57:07 <flux__> or would any spam rbl be that
08:57:32 <tony2> has anyone got experiance of handling utf8 in haskell/ghc? I've found this http://www.haskell.org/pipermail/haskell-i18n/2004-February/000127.html, which looks like it will do the job, but if there is a more standard solution obviously I'd prefer that...
08:58:05 <dcoutts> CosmicRay, uniq = map head . group . sort
08:58:14 <dcoutts> CosmicRay, perhaps? if you don't mind reordering
08:59:11 <dcoutts> tony2, Gtk2Hs uses utf8 everywhere
08:59:27 <dcoutts> tony2, we've got some utf8 conversion code
08:59:59 <dcoutts> http://haskell.org/gtk2hs/darcs/gtk2hs/glib/System/Glib/UTFString.hs
09:00:00 <flux__> dcoutts, without the . sort I imagine
09:00:13 <flux__> (because cosmicray's data is already sorted)
09:00:19 <dcoutts> flux__, ok right
09:00:22 <tony2> dcoutts, thanks I'll check that out..
09:00:31 <flux__> but yeah, that's quite concise
09:02:49 <flux__> btw, how would you define that in ghci? let uniq = .. makes it [Integer] -> [Integer]
09:03:27 <joelr_> Cale: thanks again!
09:05:15 <shapr> mm, let's port GHC to the Cell CPU
09:06:59 <dcoutts> shapr, JaffaCake's concern with that was that the GHC rts is bigger than the Cell's SPU's local memory
09:07:24 <dcoutts> shapr, you'd need to do all/most of the rts stuff on the host cpu
09:07:43 <Philippa> in practice you don't want to be garbage collecting in SPUs anyway
09:08:04 <dcoutts> yes, that might be ok. Let the host cpu do all the GC and IO
09:08:23 <dcoutts> and FFI calls
09:09:26 <Philippa> no FFI calls = nobody who's really interested in working on Cell seriously touching GHC
09:09:38 <Philippa> you *will* need ways to play with bits of machine code
09:09:50 <Philippa> it's what the SPUs are /for/
09:10:11 <Philippa> that said, an SPU-IO monad might well be appropriate...
09:10:37 <vegai> interesting mail from spj
09:10:50 <vegai> Subject: [Haskell] Making Haskell more open
09:10:57 <dcoutts> vegai, yes it is
09:11:21 <dcoutts> Philippa, one might hope that the SPU could be transparent in the user's code
09:11:31 <SamB> @seen musasabi
09:11:31 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
09:11:31 <lambdabot> 49 minutes and 51 seconds ago.
09:11:58 <dcoutts> Philippa, that it'd be just rts changes and then tuning programs to use the SPUs effectively
09:12:36 <dcoutts> because what would be a real boost is the ability to program Cell-like cpus easily. Which is something you can't easily do in C.
09:13:23 <xerox> Howdy bojohan!
09:13:57 <bojohan> hi!
09:14:26 * bojohan is playing with cairo
09:14:56 <xerox> Cool!  What are you hacking up? :-)
09:15:27 <Philippa> dcoutts: to really program Cell-like CPUs easily, you need exposure of what things the SPUs actually do
09:15:40 <Philippa> even if it's just native types matching the things it manipulates and the relevant operations
09:15:50 <bojohan> http://www.dd.chalmers.se/~bojohan/tmp/Draw.png
09:16:01 <Philippa> now sure, a lot of that /is/ just RTS changes and tuning...
09:17:12 <dcoutts> Philippa, to make use of them effectively would probably be the same kind of changes that you'd do for making a Haskell program work well on an SMP machine
09:17:23 <xerox> bojohan: nifty!
09:17:46 <dcoutts> bojohan, is that using cairo?
09:17:53 <bojohan> yes
09:18:21 * xerox wonders about the bottom-right snake... :)
09:18:57 <dcoutts> bojohan, that's cool. I wonder if you would let us include that in the Gtk2Hs demo collection?
09:18:59 <SamB> musasabi: how goes it?
09:19:17 <dcoutts> bojohan, with attribution to you of course
09:19:34 <bojohan> xerox: i'm working on language to image translation, http://www.dd.chalmers.se/~bojohan/exjobb/concept/sample.html (hand made)
09:20:36 <xerox> bojohan: I thought of an higher-level image description cairo-backended too...
09:20:45 <xerox> I missed 'language' there.
09:21:35 <dcoutts> xerox, yes a pure declarative Haskell lib exposing the cairo feature set would be cool.
09:21:53 <bojohan> btw, why does `windowSetResizable window False' shrink the window to a 1x1 square?
09:22:28 <dcoutts> bojohan, try windowSetSizeRequest as well as windowSetResizable window False
09:22:40 <xerox> Right.
09:23:50 <dcoutts> bojohan, widgetSetSizeRequest I mean
09:24:41 <bojohan> thanks. that worked.
09:27:20 <dcoutts> bojohan, if you need a non-constant size you can use onSizeRequest
09:34:02 <joelr_> Cale: ping
09:34:44 <bojohan> the code is here, http://www.dd.chalmers.se/~bojohan/exjobb/src/Draw.hs
09:37:03 <shapr> Philippa: What about using Parr and array comps?
09:37:50 <shapr> There's nothing quite as distracting as a power drill being used on the wall behind you. It's unsettling.
09:38:08 <shapr> Ok major house damage would be more distracting.
09:39:33 <dcoutts> bojohan, can we get your permission to include that file the Gtk2Hs demo collection? If so would you mind adding your name to the top and a little note saying that people are free to copy from it.
09:39:51 <musasabi> SamB: Like I said earlier I will actually do the coding part on weekend (work stuff is keeping busy today and tomorrow - just looked at the code yesterday and got ideas how to implement stuff)
09:40:00 <dcoutts> bojohan, and/or modify it
09:40:05 <SamB> musasabi: oh yeah, I forgot sorry ;-)
09:40:32 <Cale> oops
09:40:36 <shapr> dcoutts: parallel arrays to program Cell cpus easily?
09:40:38 <SamB> note that the code probably changed since then
09:40:39 <Cale> just missed him
09:41:52 <dcoutts> shapr, yeah, I'm sure that'd help. I guess it depends on wether people think it's usable as a general purpose cpu or just for dsp/media type tasks.
09:42:18 <tic|school> 'elo.  How do I make use of a constructor "Right" in my application? import Data hiding (Either) doesn't seem to work..
09:42:33 <dcoutts> shapr, I suspect people think it's only good for that because it's too hard to program it for anything else :-)
09:42:43 <SamB> tic: try hiding (Either(..))
09:43:15 <SamB> also, say Prelude, not Data
09:43:24 <shapr> The boss cpu is a general purpose CPU, especially in the most recent flavor. It would be easier to treat the sidekick CPUs as a pipeline or SIMD setup.
09:43:35 <tic|school> SamB, so: import Prelude hiding (Either (...)) ?
09:43:45 <tic|school> or do I want to use Either (Right, Left) there?
09:43:47 <SamB> tic: only two dots
09:43:51 <tic|school> samb, aha, thanks.
09:44:01 <shapr> The sidekicks can send data to the sidekick next to them easily, so that's one pipeline resemblance.
09:44:18 <tic|school> SamB, worked fine. Thank you.
09:44:22 <shapr> There's also DMA calls to get data into and out of the local cache/ram.
09:44:46 <shapr> I just downloaded the simulator and SDK, I wonder if I'll have time to play with them.
09:44:50 <dcoutts> shapr, the boss cpu is general purpose except that it's got much less instruction level parallelism and higher stall costs than most other cpus
09:45:19 <shapr> higher stall?
09:46:21 <bojohan> is widgetDestroy the right way to quit the window?
09:47:53 <dcoutts> bojohan, yes
09:48:29 <dcoutts> bojohan, or just use G.mainQuit
09:50:16 <bojohan> `onKeyPress window (const $ do widgetDestroy window; return True)'
09:50:51 <bojohan> changing that to mainQuit leaves a non-responsive window
09:51:45 <dcoutts> bojohan, oh right, you can do G.flush after G.mainGUI
09:51:46 <Philippa> dcoutts: so it's a /slow/ CPU. Big deal.
09:53:15 <paolino_> good evening
09:53:21 <shapr> hiya
09:53:34 <dcoutts> bojohan, actually, yeah you'll have to destroy or hide the window first
09:53:38 <paolino_> I'm puzzling around a problem with classes
09:53:48 <shapr> dcoutts: You think the RTS would run on the boss cpu?
09:54:25 <paolino_> can someone have a look ? http://pastebin.com/424588
09:54:43 <shapr> Is ILP or low stall costs important to the GHC RTS?
09:54:51 <bojohan> i already use "onDestroy window mainQuit", so i guess "onKeyPress ... widgetDestroy" is fine.
09:55:02 <shapr> Hey, I bet House would be awesome on the Cell =)
09:55:23 <tic|school> Are there any good tutorials on Monads and deep embedding?
09:55:33 <shapr> tic|school: The nomaware tutorial.
09:55:39 <shapr> tic|school: What's deep embedding mean?
09:55:43 <bojohan> afp, eh?
09:55:47 <shapr> Like, sixteen levels of monad transformers?
09:55:57 <tic|school> shapr, reading it as we speak. Doesn't do me any good, really :-/
09:56:01 <tic|school> bojohan, indeed.
09:56:25 <shapr> tic|school: Work through it, write down all the code, wiggle it till it breaks. You'll get it.
09:56:29 <tic|school> shapr, sorry. making a language by deep embedding in a data type.
09:56:45 <tic|school> shapr, hrm.. I'll try again..
09:56:52 <tic|school> (making an embedded language here)
09:57:23 <shapr> Alternatively, try Steve Atkins monads tutorial. It's offline, but I have a copy of the Haskell files - http://www.scannedinavian.org/PRIVOXY-FORCE/~shae/atkinmonads/
09:57:46 <shapr> tic|school: Also see the various research papers on extensible monadic interpreters.
09:58:08 * paolino_ waves hands 
09:58:21 <tic|school> shapr, okay, thanks.
09:58:23 <shapr> tic|school: http://www.scannedinavian.org/~shae/monads.txt ?
09:58:31 <tic|school> *looking*
09:58:36 * shapr waves back at paolino_ 
09:59:07 <shapr> paolino_: Can you describe the problem or whatever?
09:59:37 <paolino_> I cannot make (Distribution a) an inszance of Groupable
09:59:49 <paolino_> I wish I could
10:00:12 <paolino_> I can make it of Float
10:00:29 <xerox> You need to specify an 'a' to get a type out of "Distribution a".
10:00:46 <paolino_> uei xerox
10:01:30 <paolino_> so Distribution is a subclass of Groupable ?
10:01:39 * paolino_ go nuts
10:04:07 <tic|school> shapr, okay, maybe it'll be easier if I give you more info about my problem.  I want do something like this: data Turtle = Right Double (Turtle) | Forward Double (Turtle) | Stop. Then, how I've seen bind being defined: Right n t >>= f = Right n (t >>= f).  Doesn't make much sense to me, though. :-/
10:08:02 <bojohan> dcoutts: so which license are the other demos under?
10:08:24 <paolino_> xerox : this is compiling ...
10:08:26 <paolino_> instance (Show a) => Show (Distribution a) where
10:08:27 <paolino_>   show (Distribution distribution) = show $ Map.toList distribution
10:08:42 <shapr> tic|school: If you're implementing Logo, why not use Turn instead?
10:08:55 <paolino_> and its valid which ever 'a' is showable
10:09:16 <tic|school> shapr, well, that's not the problem right now. :)
10:09:32 <tic|school> shapr, the problem is getting the instance of Turtle properly defined. :)
10:09:45 <shapr> What should the instance do?
10:10:19 <shapr> From one viewpoint, a monad is just the 'significance' of a type turned into an active pipeline that handles that same significance.
10:10:19 <tic|school> shapr, let me sequence the different turtle operations.
10:10:29 <shapr> And what does that mean?
10:11:03 <shapr> What's getting sequenced exactly?
10:11:35 <SamB> tic: whats being returned?
10:11:38 <tic|school> I've defined a couple of helper functions, like: forward d = Forward d Stop (I think that's correct)
10:11:49 <tic|school> samb, nothing.
10:12:08 <SamB> tic|school: how will you implement return then?
10:12:13 <shapr> In that case, why do you need to have one value of Turtle sequenced before another value?
10:12:45 <shapr> Why is the order important, is there some effect?
10:12:57 <psi> @pl f l = map ((!!) l) [0,2..length l - 1]
10:12:57 <lambdabot> f = liftM2 map (!!) (enumFromThenTo 0 2 . subtract 1 . length)
10:13:01 <tic|school> shapr, I'm not very good at this, so I'm not sure how to do it, and I just cannot find anything on the intarweb on how to make a linked list of statements.
10:13:08 <tic|school> shapr, side effect being drawing on the screen, obviously.
10:13:42 <shapr> Well, you didn't say that yet.
10:13:42 <tic|school> shapr, so I want do be able to write programs such as: do {forward 10; right 90; forward 5; stop}
10:13:59 <shapr> And how is the screen represented in your program?
10:14:21 <tic|school> Sorry, don't understand what you mean.
10:14:30 <xerox> How do you draw on the screen?
10:14:44 <tic|school> using WxHaskell or GTKHS. Is that even important?
10:14:53 <xerox> tic|school: it depends :-)
10:16:00 <tic|school> shapr, I just want to be able to build a program tree, like Forward 10 (Right 90 (Forward 5 ()).
10:16:02 <SamB> tic|school: well, if you want a linked list, there is always []
10:16:18 <shapr> tic|school: So why use a monad?
10:16:29 <tic|school> shapr, so I can use the do notation, again....
10:16:37 <shapr> why do you need the do notation?
10:16:41 <tic|school> because I do.
10:16:47 <shapr> why?
10:16:52 <SamB> @type compose
10:16:53 <lambdabot> Not in scope: `compose'
10:17:09 <SamB> @hoogle [a -> a] -> a -> a
10:17:10 <lambdabot> No matches, try a more general search
10:17:31 <SamB> @type foldr ($)
10:17:32 <lambdabot> forall b. b -> [b -> b] -> b
10:17:39 <shapr> tic|school: The solution to your problem is the state monad, but I don't think that answer will help you until you see why you need it.
10:17:52 <shapr> There may be other monadic solutions as well.
10:18:23 <SamB> shapr: well, what if he really just wants a nice way to build his turtle path, and doesn't really care about Monads here?
10:18:31 <shapr> Yeah, that's also possible.
10:18:59 <tic|school> I don't care much about that, I just have a vague notion of monads enabling me not to pass state around.
10:19:26 <tic|school> s/notion/feeling
10:19:46 <shapr> They just automate passing state, much like objects.
10:20:21 <tic|school> well, that's what I've been saying the entire time
10:20:30 <SamB> so, like, let path = foldr ($) Stop in path [forward 10, right 90, forward 5]
10:20:50 <tic|school> I want nicer syntax.
10:20:52 <shapr> Hm, I thought you said you wanted a monadic interpreter.
10:20:55 <SamB> tic|school: but what state do you have to pass?
10:21:29 <tic|school> Okay, guys. Have a peek here.  I'm not asking you to do my assignment, but I can't seem to express myself in a way you find acceptable:
10:21:32 <tic|school> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab1.html
10:21:36 <SamB> anyway, the relevant syntax is "path [forward 10, right 90, forward 5]"
10:21:57 <SamB> which really isn't that different from "do {forward 10; right 90; forward 5}"
10:24:38 <SyntaxNinja> hello all
10:24:47 <pesco> tic|school: I think the point of the exercise is to get you to think about how to represent your turtle program as a data structure in Haskell.
10:25:07 <shapr> hiya SyntaxNinja
10:25:08 <pesco> Perhaps you should put off the syntactic considerations until later.
10:25:44 <tic|school> oh well.
10:25:55 <tic|school> I'll have a look at it later. Time to go home.
10:25:58 <tic|school> bye.
10:26:05 <shapr> We can discuss it more later :-)
10:26:15 <shapr> It looks like fun homework.
10:27:03 <shapr> I agree with pesco, start out thinking of how to represent your program as a data structure.
10:28:08 <tic|school> Yes, I've realized that now. And then just provide a function that runs my program.  Will deal with how to store the program myself.
10:28:11 <tic|school> err, later.
10:28:14 <tic|school> and now, I'm really gone.
10:30:14 <shapr> Do you have Lennart Augustsson as a teacher??
10:31:11 <SamB> perhaps tic uses screen?
10:48:27 <perspectival> this is more of a Debian question than a haskell one, but i've started compiling gtk2hs on Ubuntu PPC with the command "apt-get source gtk2hs --compile" and it's still running. Unfortunately I've got to move to a location with internet access, and I'm wondering if anyone knows how to continue--or even restart the compile--with apt, but without internet access
10:50:14 <ustenzel> perspectival: dpkg-buildpackage inside the source directory restarts (there may be an option to continue somewhere)
10:50:46 <perspectival> aha
10:50:56 <perspectival> yeah, i'm just seeing this on the apt-get man page
10:51:01 <SyntaxNinja> perspectival: can't you just suspend it, and fg it?
10:51:22 <perspectival> no, i've got power issues on this laptop, and must shut down
10:51:40 <perspectival> the problem with using apt-get --compile is that it goes online when i try to restart the compile
10:51:47 <perspectival> even if it has the source
10:52:31 <perspectival> but i can try dpkg -buildpackaoge
10:52:59 <SyntaxNinja> that's one command
10:53:03 <SyntaxNinja> dpkg-buildpackage
10:53:07 <perspectival> ok
10:53:07 <SyntaxNinja> or use debuild
10:53:26 * SyntaxNinja usually just says "apt-get source foo" then "cd foo-version" and "debuild"
10:53:34 <perspectival> i'm more familiar with FreeBSD than with Debian, so I'm having to learn Apt quickly. Thx for the responses
10:53:35 <SyntaxNinja> then dpkg -i foo.deb
10:53:55 <SyntaxNinja> but debuild cleans it!
10:54:11 <perspectival> will that work with the patches that apt-get downloaded for gtk2hs-0.9.10 ?
10:54:13 <SyntaxNinja> so I guess that's not what you want, but if you're just concerned w/ not downloading, then debuild is good stuff.
10:54:26 <Cale> tic|school: Turtle as defined there can't be a monad.
10:54:26 <SyntaxNinja> debuild will apply the patches
10:54:29 <perspectival> ok
10:54:36 <Cale> but you're gone :)
10:55:00 <perspectival> thx Ninja ;-)
10:55:10 <dcoutts> bojohan, all our other demoes are public domain
10:55:12 <perspectival> and estenzel
10:55:19 <ustenzel> perspectival: power issues?  apm and acpi are broken?
10:55:20 <perspectival> or ustenzel
10:55:34 <dcoutts> bojohan, but if you don't like that then bsd or lgpl or gpl are ok
10:55:41 <perspectival> no, hardware issues... battery is completely unusable
10:56:20 <ustenzel> perspectival: try software suspend.  you can switch the damn thing off without losing your processes :)
10:56:46 <perspectival> i wish that software suspend worked, but as soon as the AC power connection goes, so does suspend-to-ram
10:56:55 <perspectival> i've got to get a new battery for an old Powerbook ;-)
10:57:04 <perspectival> oh--software suspend?
10:57:08 <perspectival> what's this?
10:57:33 <ksandstr> suspending compressed memory images to active swaps on linux. google for it.
10:57:50 <perspectival> right. never heard of it, but that would really be kick-ass on this machine
10:57:57 <tuomov> tried it. couldn't get it to work.
10:58:10 <ksandstr> required on recent laptops since ACPI BIOSes don't do that sort of thing for you anymore.
10:58:20 <perspectival> <nod>
10:58:38 <perspectival> Thanks for the tips, all, and peace.
10:58:42 <ustenzel> perspectival: www.suspend2.net
10:58:46 <perspectival> ok
10:58:50 <ksandstr> i suppose this sort of thing will be hit-and-miss for some years yet
10:59:01 <tuomov> does it support encrypted swap, btw?
10:59:32 <ksandstr> tuomov: requires unholy initrd twiddling, and i don't have the stomach for that.
10:59:48 <ksandstr> encrypted images are supported but ill-documented (i.e. good as useless)
11:15:48 <bojohan> dcoutts: ok, http://www.dd.chalmers.se/~bojohan/exjobb/src/Draw.hs
11:18:22 <SamB> hmm, looks like there is a bug in HaXml's lexer
11:22:59 <ksandstr> SamB: the one where it eliminates space characters that aren't in a <!CDATA[block]]>, right?
11:23:29 <SamB> ksandstr: no, the one where it thinks % in a string is a reference
11:23:42 <SamB> or rather, part of one
11:23:58 <ksandstr> SamB: what, any string? this could be a problem.
11:24:30 <SamB> like, try:
11:24:37 <SamB> xmlLex "foo" "<FOO FOO=\"90%\"></FOO>"
11:27:12 <ksandstr> this doesn't happen outside an attribute?
11:28:14 <SamB> nope
11:28:23 <SamB> the problem has something to do with textOrRefUntil
11:33:34 <SamB> it doesn't look like textOrRefUntil is used anywhere but quoted strings anyway, so it is probably okay to just comment out the "||s=='%'"
11:44:27 <shapr> SamB: Does it happen with 1.14 ?
11:44:51 <SamB> shapr: I don't even know how to get 1.14
11:45:04 <basti_> hmm btw, an aquaintance recently managed to segfault a ghc-compiled three-liner!
11:46:24 <basti_> I'll get hold of the program and show you, that seemed to be a compiler bug to me
11:49:14 <tessier> Anyone know who admins the haskell mailing list? Does he frequent this channel?
11:50:51 <SyntaxNinja> tessier: simon marlow
11:50:55 <SyntaxNinja> JaffaCake on this channel
11:51:02 <SyntaxNinja> tessier: why?
11:51:52 <SyntaxNinja> Lemmih: alive?
11:54:24 <shapr> tessier: Maybe it's something we can help with?
11:56:21 <tessier> Maybe. The problem is that when I try to subscribe to the mailing list (and a couple of others) I never receive the confirmation message.
11:56:30 <tessier> I was wondering if  he could look in the logs or something and find out why.
11:56:59 <tessier> My domain is ultraviolet.org and I am wondering if the site is simply caching old DNS data or if I have somethign messed up or what. I am on a couple dozen other mailing lists which I subscribed to with no problem.
11:58:43 <SamB> maybe what you really want to know is "who has root on haskell.org?"
11:59:51 <tessier> That would work also
12:02:35 <SyntaxNinja> tessier: what DNS do you want it to see?
12:02:53 <SyntaxNinja> host  ultraviolet.org
12:02:53 <SyntaxNinja> ultraviolet.org has address 68.15.4.13
12:03:23 <tessier> That is the correct. And what is the mx?
12:03:24 <SyntaxNinja> that's what I see on haskell.org and my own box; though the mail server may have something else cached, as you suggest
12:04:40 <SyntaxNinja> hm. no mx on that box. don't know.
12:06:16 <shapr> SamB: fptools cvs, or the matching haxml darcs repo
12:07:14 <shapr> tessier: your mx is home.copilotconsulting.com ?
12:07:20 <tessier> yes
12:07:33 <shapr> That's what haskell.org sees.
12:07:36 <tessier> hmm
12:07:50 <shapr> What's the username at the host you mentioned?
12:07:55 <shapr> I can send you an email from haskell.org to see if that'll work.
12:08:00 <tessier> treed@ultraviolet.org is the address I subscribed with
12:09:17 <shapr> Got anything?
12:09:40 <tessier> shapr: Yes, I got your test mail
12:10:16 <Frederick> yo folks
12:10:32 <shapr> tessier: Well, at least you know that part works.
12:11:01 <shapr> Can you send a reply?
12:12:54 <shapr> tessier: ok, got it.
12:12:59 <tessier> cool
12:13:12 <shapr> Hm, it went to haskell.cs.yale.edu, I wonder if that makes a difference.
12:13:37 <tessier> If I subscribe via the mailman web interface do you have any way of watching what is happening?
12:14:07 <shapr> I can check the error logs.
12:14:42 <xerox> Yawn!
12:15:05 <xerox> The HD is giving way too much Bus Errors lately :-(
12:16:09 <SyntaxNinja> xerox: back up!+
12:16:35 <xerox> I hope to get the powerbook before it dies :-| err.
12:16:58 <SyntaxNinja> xerox: with a name like xerox, I'd expect you to hav ea better backup strategy :P
12:17:23 <xerox> D'oh.  I have not enough funds to accomplish something foreseeable from the nick :-)
12:17:27 <tessier> That reminds me...it's time to take my USB2 HD off-site and plug in the second one
12:17:56 <tessier> I've got bacula saving everything that is precious to me.
12:17:59 <xerox> My problem is that the hd is full, and the USB2 HD has the OS on it, and it's BusErroring.
12:18:01 <tessier> Also have a copy on DVD
12:18:11 <tessier> Buy another USB2 HD. They're cheap.
12:18:16 <tessier> I got 80G for $80.
12:18:44 <tessier> I figure my data is worth $80.
12:18:47 <xerox> I hope to get some funds in days countable on the hand's fingers :)
12:21:25 <shapr> Hm, finnw isn't around..
12:24:17 <paolino_> something grreat about haskell is I never go to bed with broken code which often  happened in other languages for the day after nightmare
12:24:24 <shapr> :-)
12:24:43 <shapr> Something else great about Haskell, it's so much fun I almost never go to bed!
12:24:54 <eivuokko> lol
12:25:20 <paolino_> great => dangerous for someone :)
12:25:46 <shapr> True, I'm self-employed, and I don't often get paid for Haskell work.
12:26:38 <Frederick> guys Ive created a sample file with happy but when I compile it it says calcgrammar.hs:306: Variable not in scope: `isDigit' what do I need to import in order to have it working?
12:27:06 <eivuokko> Data.Char mayber
12:27:07 <xerox> import Char
12:27:10 <xerox> or Data.Char.
12:28:36 <Frederick> hm
12:28:46 <Frederick> now it complains it cant find show exp :p
12:28:56 <xerox> @index isDigit
12:28:57 <lambdabot> Data.Char
12:29:01 <xerox> This tells you where functions are.
12:29:19 <Frederick> @index ShowExp
12:29:19 <lambdabot> bzzt
12:29:30 <xerox> What is ShowExp ?
12:30:17 <Frederick> xerox, http://www.haskell.org/happy/doc/html/sec-using.html I was trying this
12:30:45 <xerox> Oh!  I don't know about happy, sorry.
12:31:22 <eivuokko> Maybe you mean Show instance for Exp?
12:31:32 <Frederick> yep
12:32:00 <{Arias}> @hoogle (a -> Bool) -> [a] -> Bool
12:32:00 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
12:32:00 <lambdabot> Data.List.all :: (a -> Bool) -> [a] -> Bool
12:32:00 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:32:01 <Frederick> calcgrammar.hs:325:
12:32:01 <Frederick>     No instance for (Show Exp)
12:32:02 <eivuokko> In that case, just add deriving (Show) after your data decl.  Like data Exp = ... | Exp1 Exp1 deriving (Show)
12:48:13 <palomer> monadic IO is continuation based IO in disguise!
12:48:50 * xerox sedates palomer
12:50:42 <palomer> seriously
12:50:46 <palomer> does everyone agree?
12:50:56 <SamB> why is it that I see these crazy ideas on the haskell list, think "what a crazy idea, that could never work!", and then it turns out to be by David Roundy and maybe wasn't so crazy after all?
12:50:56 <ndm> i agree
12:51:21 <SamB> palomer: I have thought perhaps so
12:51:29 <palomer> SamB: but no longer?
12:52:26 <SamB> palomer: no, its just I'm not sure
12:53:24 <palomer> anymore?
12:55:59 <eivuokko> Monadic bind seems like typical continuation to me, but I am not sure what continuation based IO is.
12:56:06 <Dibrom> can anyone who has worked with both happy and parsec give me an idea of just how much faster happy is for large parsing tasks?  Trying to decide which I should use before I get too far along with a current project
12:56:45 <palomer> eivuokko: you pass the functions which will deal with the result of the IO operation
12:57:46 <Dibrom> I plan on writing the lexer in alex probably even if I go with parsec, so that should possibly cut down on the difference between happy and parsec, but I don't have a good idea how much of a difference that is
12:57:54 <ndm> Dibrom, when a Parsec version of GHC was used
12:57:55 <eivuokko> palomer, does it implicate strict evaluation?
12:57:58 <ndm> it makes GHC 10% slower
12:58:24 <ndm> but parsing is only a small amount of ghc's compile time
12:58:53 <Dibrom> 10% may not be bad then for the advantages I'd get from parsec
12:59:14 <SamB> palomer: what constitutes a continuation?
12:59:18 <Dibrom> I would have thought the difference would be bigger
12:59:31 <palomer> SamB: any function can be  acontinuation
12:59:36 <ndm> Dibrom, total slowdown is 10%
12:59:39 <ndm> on the entire compilation
12:59:45 <ndm> so a lot more than 10% slower
12:59:53 <ndm> maybe even 100% slower or something
12:59:53 <Dibrom> oh, I see
13:00:15 <tessier> shapr: So nothing obviously wrong with email between me and haskell.org eh?
13:00:55 <Dibrom> well, maybe I will stick with happy then..
13:00:59 <palomer> SamB: do you know about CPS?
13:01:24 <palomer> hrm, noone has written a haskell plugin for sablecc
13:01:27 <palomer> I think I'm going to have to
13:02:05 <palomer> does anyone find changing operator precedence useful? like, has anyone here used this feature?
13:02:41 <SamB> palomer: yes, I know what CPS is
13:02:46 <Dibrom> palomer: yes
13:02:59 <Dibrom> I have used it for operators I have created myself, and it has been very useful in some cases for that
13:03:27 <SamB> palomer: its certainly annoying that <|> and >> have the same precedence
13:03:50 <palomer> SamB: so you know what continuations are, right?
13:04:13 <SamB> palomer: yes
13:04:37 <palomer> SamB: in continuations based IO, you pass the continuation which will deal with the input
13:04:42 <SamB> but it doesn't look like GHC's implementation of IO is exactly based on them
13:05:10 <SamB> sure, >>= takes one...
13:06:39 <palomer> yeah, and >>= is where the good stuff happens
13:09:49 <palomer> ie, if I had continuation based IO, I could write the IO monad
13:09:56 <palomer> (implement the IO monad)
13:12:12 <SamB> eh, isn't >>= for IO defined pretty much "IO p >>= g = IO (\s -> let (s', x) = p s; IO q = g x in q s'"?
13:12:25 <SamB> do I have my head too much in the words?
13:13:21 <reductor> looks like unix pipes is also good methaphor for monads
13:15:35 <palomer> SamB: it looks like you're binding IO in that let, but you aren't using it (unless I'm wrong?
13:17:06 <SamB> palomer: IO is a constructor
13:17:27 <SamB> in GHC's implementation, that is
13:17:30 <palomer> hrm, I don't know haskell syntax too well
13:17:46 <SamB> oh, and I forgot the #s inside the unboxed tuple...
13:18:12 <SamB> its totally implementation-specific and really quite a hack too
13:18:50 <SamB> does this have something to do with that "Monads vs. continuations" thread?
13:19:56 <palomer> is there such a thread?
13:20:14 <palomer> monads seem to be an elegant way to deal with continuations, imho
13:21:31 <SamB> yes, that is clear
13:22:07 <SamB> I mean, while IO's >>= may not do much with the continuation, you can obviously do more, e.g.
13:22:13 <SamB> @index callCC
13:22:14 <lambdabot> Control.Monad.Cont
13:23:39 <palomer> SamB: do you agree that if you had continuations based IO, it would be trivial to implement monadic IO?
13:23:45 <palomer> (and vice versa)
13:24:02 <SamB> palomer: well, what is continuation-based IO?
13:24:49 <SamB> give me some signatures ;-)
13:24:53 <palomer> getLine foo <-would pass the next line to foo
13:24:57 <palomer> so getLine would have
13:25:09 <SamB> oh sure
13:25:26 <palomer> forall a. (string -> a) -> ()
13:25:38 <palomer> man, I wish my keyboard had a forall symbol
13:25:43 <palomer> they should make keyboards for logicians
13:25:49 <eivuokko> Uhm, it implies that top level is imperative or atleast strict, eh?
13:26:15 <SamB> so something like getLine = (Prelude.getLine >>=)
13:26:22 <SamB> @type (Prelude.getLine >>=)
13:26:22 <lambdabot> forall b. (String -> IO b) -> IO b
13:27:07 <palomer> eivuokko: does it? you can force strictness in haskell with !, no?
13:27:46 <SamB> palomer: ah, but you can't use that typing
13:27:53 <eivuokko> Uhm
13:28:10 <SamB> because, you see, to do IO, you must thread your IO through IO
13:28:10 <antonio_pp> DO YOU WANT A GIFT FOR THESE CHRISTMASTIDE? REGISTRATE And BUY FOR 35 SOME AMPLIFIERS OF ANTENNA FOR YOUR MOTIVE, HE ELECTS A GIFT, ALONE Y TO DO SO, IN A FEW DAYS YOU HAVE YOUR GIFT, IT IS TRUE, HURRY UP THAN READY APPROXIMATELY EMPTY ESTAN is WEB NEW http://ganaregalosgratis.com/index.php?Ref 7501 INDEED, I RIGHT NOW HAVE MOTIVE And AM AWAITING NOT OUR OWN. AS SOON AS POSSIBLE DO IT BEFORE YOU HAVE THE GIFT. IF DESCONFIAIS the Y E
13:28:12 <eivuokko> I am asking because I don't understand how else it could work (starting point being haskell, that is)
13:28:54 <palomer> eivuokko: that is a very good question, and I'm wondering about it myself
13:29:18 <SamB> palomer: and () can't be hiding any IO values, because it is defined by
13:29:20 <palomer> eivuokko: you're basically asking when haskell knows to be strict
13:29:25 <SamB> data () = ()
13:29:45 <eivuokko> And, yeah, ! and seq are sort of strict, but they are not "deep", hence DeepSeq or such module.
13:30:25 <SamB> and so how would you set main to be the whole IO computation, if you don't have the whole IO computation?
13:30:36 <palomer> SamB: I don't see why it can't return ()
13:30:59 <eivuokko> And if my understanding is correct, using seq in conjuction with "naive" IO-type wouldn't make a diffrence.
13:31:06 <SamB> palomer: because that way there is no way to do anything
13:32:15 <SamB> palomer: show me your idea of how to implement that
13:32:25 <palomer> SamB: sure! getLine foo <-- foo would do something with the line
13:32:32 <SamB> palomer: no, I mean code
13:32:45 <palomer> getLine would have to be implemented in the target language
13:32:51 <SamB> target language?
13:33:17 <eivuokko> Asm or C etc
13:33:18 <SamB> Haskell has monadic IO; you said you could easily implement continuation-based IO in terms of monadic IO
13:33:29 <SamB> so, demonstrate this by implementing getLine!
13:33:52 <SyntaxNinja> did tessier get the mailman problems figured out?
13:34:05 <palomer> SamB: oh, I thought you asked me what would be the type of continuation based io function
13:34:12 <palomer> SamB: my bad
13:34:15 <SamB> palomer: I meant in Haskell
13:35:07 <tessier> SyntaxNinja: Not yet
13:35:17 <SamB> so, I think getLine = (Prelude.getLine >>=) would work nicely
13:35:32 <SamB> @type (Prelude.getLine >>=)
13:35:33 <lambdabot> forall b. (String -> IO b) -> IO b
13:35:38 <palomer> yeah, sure
13:35:55 <palomer> hrm, I'm going to have to read more about this before having a serious discussion
13:35:57 <SyntaxNinja> tessier: so you just don't get any reply from your subscribe messages?
13:36:08 <SamB> lets try putStr...
13:36:50 <SyntaxNinja> has anything come out of the mailing lists today?
13:37:34 <SamB> @pl putStr s = (Prelude.putStr s >>)
13:37:35 <lambdabot> putStr = fix (((>>) . (Prelude .)) .)
13:37:43 <SamB> ugly!
13:37:58 <SamB> oh well, you get what you ask for I guess
13:38:19 <SamB> @type \s -> (Prelude.putStr s >>)
13:38:20 <lambdabot> forall b. String -> IO b -> IO b
13:38:58 <eivuokko> Heh
13:39:28 <SamB> and I guess main would be something like
13:40:43 <SamB> main = contMain (return ())
13:40:51 <SamB> I dunno
13:42:10 <SamB> that would give contMain :: IO a -> IO a
13:43:13 <SyntaxNinja> tessier: I emailed an admin on that box.
13:44:44 <eivuokko> Wouldn't continuation based io work in haskell (somewhat as it is), if haskell had true way to force strictness with seq (ie seq being "deep")? It would just pretty much destroy usefullness of laziness in real-world programs.
13:46:26 <SamB> and you could write stuff like "contMain ret = putStr "What is your name?\n" $ getLine (\name -> putStr ("I think " ++ name ++ " is a very nice name.") ret)
13:47:47 <eivuokko> Hmmmm.  Does $ force evluation order there?
13:47:53 <SamB> no
13:51:38 <SamB> its surprising, but that actually works as-is
13:51:48 <SamB> if I put the defs all in a file
13:52:05 <eivuokko> Hmmm
13:52:06 <SamB> and "import Prelude hiding (getLine, putStr)"
13:52:13 <SamB> and "import qualified Prelude"
13:53:58 <SamB> oh, and add a \n at the end of " is a very nice name." ;-)
13:56:35 <tessier> SyntaxNinja: Thanks. I appreciate it.
13:56:58 <Cale> putStrLn adds the '\n' for you
13:58:45 <lisppaste2> SamB pasted "continuation-passing-style IO in Haskell" at http://paste.lisp.org/display/13421
13:59:51 <Cale> ah, wrappers :)
14:03:26 <Cale> btw, there's already a rather nice version of DeepSeq in the hierarchical libraries, it's called rnf, and it's in Control.Parallel.Strategies
14:04:48 <eivuokko> Uhhuh.
14:05:18 <Cale> The thing about monadic IO is that you don't have to force evaluation order. The combinators combine IO actions into new ones which represent that order internally.
14:05:44 <yaarg> @listcommands
14:05:45 <lambdabot> use listcommands [module|command], please. Modules are:
14:05:45 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
14:05:45 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
14:05:45 <lambdabot> topic type version vixen where
14:06:58 <Cale> (putStrLn "Hi, what's your name?" >> getLine >>= \x -> putStrLn ("Hello " ++ x)) could get evaluated in any order at all, and it wouldn't make a difference, because the result is just an IO action and no side effects have occurred
14:10:08 <yaarg> @libsrc Data.bits
14:10:09 <lambdabot> Data.bits not available
14:10:18 <SamB> @libsrc Data.Bits
14:10:18 <yaarg> @libsrc Data.Bits
14:10:19 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Bits.hs
14:10:19 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Bits.hs
14:12:13 <yaarg> :)
14:15:03 <int-e> Is there a way to give a type signature for y in 'let { t :: a -> a; t x = y where y :: a; y = x } in t ()'? I'd need to refer to the type variable from the signature of t somehow, can I?
14:15:55 <int-e> The line I quoted doesn't work because the a in the type signature is a new, fresh type variable.
14:16:53 <Cale> hmm
14:17:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables -- perhaps this?
14:17:49 <int-e> in this case I can just let Haskell derive the type and everything works out fine but this may not always be the case. I'll have a look at that.
14:18:30 <Cale> There are some valid types for things in Haskell 98 which one can't write type signatures for.
14:18:47 <SamB> yeah, scoped type variables should do what you need
14:18:55 <int-e> cheers, 'let { t :: a -> a; t (x::a) = y where y :: a; y = x } in t ()' works
14:19:21 <SamB> yeah, I know what you mean! I find it really annoying when I can't write a sig for something (valid type or no!) because of that...
14:19:47 <SamB> it really makes it harder to pin down where my types are diverging from my intentions
14:20:30 <palomer> Cale: that's _insane_
14:20:43 <int-e> thanks Cale and SamB
14:20:47 <palomer> Cale: do they intend to fix this?
14:21:01 <Cale> palomer: it's fixed by scoped type variables, I think
14:21:10 <palomer> ah.
14:21:41 <SamB> doh!
14:21:44 <SamB> I did it again
14:22:21 <Cale> But it's not that strange when you see what it is -- you can always write type signatures for top level functions, it's just that some subexpressions might have types which are constrained in a way not expressible in the language of type signatures.
14:24:12 <palomer> is there really any good reason for having a bottom type?
14:24:18 <palomer> err, value
14:24:23 <dons> yes!
14:24:26 <palomer> doesn't haskell have exceptions?
14:24:26 <Cale> representing nontermination
14:24:34 <SamB> for error messages!
14:24:49 <Cale> loop = loop
14:24:53 <SamB> or unlawful termination
14:24:55 <dons> for branching to typeclasses based on the type.
14:25:13 <dons> parseAll = parse (undefined :: Tag)
14:25:13 <dons>       >||< parse (undefined :: File)
14:25:14 <dons>       >||< parse (undefined :: Info)
14:25:37 <SamB> dons: that isn't what its for and you know it...
14:25:41 <Cale> and yeah, having an explicit representation of it about is handy :)
14:25:49 <SamB> though it is usefull ;-)
14:25:58 <dons> it's good having a bottom value when doing type hackery
14:26:03 <Cale> that is actually mostly what undefined is for
14:26:20 <SamB> well, okay, but bottom isn't for that is it?
14:26:40 * palomer is so not convinced
14:26:44 <Cale> I also use it when people ask me to help with problems during typechecking and don't give me their whole program.
14:26:57 <dons> yeah, me too.
14:27:03 <xerox> Agreed!
14:27:07 <Cale> undefined is bottom
14:27:22 <SamB> palomer: yes, haskell has exceptions
14:27:31 <SamB> @index throw
14:27:32 <lambdabot> Control.Exception
14:27:35 <palomer> why would anyone use bottom when you have exceptions?
14:27:41 <Cale> undefined actually throws an exception which you can catch in the IO monad
14:28:11 <SamB> palomer: exceptions ARE bottom
14:28:11 <SamB> sortof
14:28:12 <palomer> humph, so bottom is for hackery?
14:28:22 <SamB> well, and also
14:28:25 <palomer> SamB: yes, but at least you can identify them
14:28:26 <SamB> > tail []
14:28:27 <lambdabot> Add a type signature
14:28:33 <SamB> > tail [] :: [Int]
14:28:34 <lambdabot> Prelude.tail: empty list
14:28:35 <Cale> bottom is also part of the formal way that you reason about haskell expressions
14:29:09 <SamB> exceptions aren't, are they?
14:29:20 <Cale> (or program semantics in general)
14:29:41 <palomer> Cale: you could add bottom when reasoning, really
14:29:56 <palomer> and any theorems which don't contain bottom would be applicable
14:29:58 <palomer> which is fine
14:30:01 <Cale> well, the language can't stop you from writing bottom
14:30:13 <int-e> you can have bottom values in your data structures without any problems as long as you don't use them; in a lazy evaluation context that can be extremely useful.
14:30:18 <palomer> Cale: why not?
14:30:30 <Cale> because that would mean solving the halting problem
14:30:53 <palomer> solving the halting problem is equivalent to grepping _|_ ?
14:31:24 <Cale> yeah, testing equality with bottom is essentially asking if the program doesn't terminate
14:31:38 <dons> > undefined == undefined
14:31:39 <lambdabot> Add a type signature
14:31:43 <dons> > undefined == undefined :: ()
14:31:43 <lambdabot> Couldn't match `()' against `Bool'
14:31:47 <Cale> hehe
14:31:55 <dons> > undefined == (undefined :: ())
14:31:56 <lambdabot> Undefined
14:32:09 <palomer> I still think haskell could be cleaner (and maybe faster?) without bottom
14:32:18 <palomer> unless someone can give me an example where it's useful
14:32:32 <ndm_> palomer, head!
14:32:39 <int-e> only in strict contexts. If you need the extra performance, you can use unboxed types then *shrugs*
14:32:56 <ndm_> remember, every case statement can generate bottom - unless it is exhaustive
14:33:14 <int-e> If you have potentially unevaluated thunks, you can represent bottom essentially for free.
14:33:22 <palomer> ndm_: throw an exception
14:33:22 <Cale> palomer: bottom isn't something that you can avoid, and occurs as a value in any lazy language
14:33:41 <ndm_> palomer: in haskell, semantically thats _|_
14:33:54 <Cale> If you made Haskell strict, then you can avoid needing bottom to describe things
14:34:06 <Cale> but you're still going to run into nontermination
14:34:09 <ndm_> what about head?
14:34:16 <ndm_> what is the result of head [], without _|_
14:34:20 <int-e> (by making it a closure that throws an exception when evaluated - STG speak: entered)
14:34:24 <palomer> ndm_: an exception is thrown!
14:34:44 <shapr> There's also interesting stuff that comes from having bottom and top types.
14:34:58 <palomer> there's a top?
14:35:16 <dons> the type that has all values in its domain
14:35:33 <palomer> top is a type and bottom is a value?
14:35:43 <dons> oh, sorry ./me drifted again.
14:36:33 <SamB> palomer: how is throwing exception different from returning bottom?
14:36:46 <Cale> palomer: an exception being thrown is just a more specific version of bottom
14:36:52 <palomer> SamB: you can identify the exception
14:37:04 <Cale> _|_^e or something
14:37:12 <SamB> palomer: you can identify bottoms too
14:37:19 <palomer> there are different bottoms?
14:37:25 <Cale> you can identify the exception in the case of exceptions anyway, but only in the IO monad
14:37:27 <SamB> palomer: how do you think we get
14:37:34 <SamB> > tail [] :: [Int]
14:37:35 <lambdabot> Prelude.tail: empty list
14:37:39 <ndm_> palomer: yes, non-termination and case-completion errors
14:37:41 <Cale> you *can't* identify real nontermination
14:37:41 <SamB> instead of
14:37:47 <SamB> > error "bottom"
14:37:48 <lambdabot> Add a type signature
14:37:52 <SamB> > error "bottom" :: Int
14:37:53 <lambdabot> bottom
14:38:06 <SamB> ?
14:38:10 <shapr> dons: Cool, you study top types too?
14:38:12 <palomer> so exceptions are bottoms?
14:38:29 <SamB> palomer: yes
14:38:29 <int-e> palomer: bottom boils down to an unthrown exception
14:38:41 <ndm_> www.cs.york.ac.uk/~ndm/projects/catch.php
14:38:56 <ndm_> thats all about bottom's, and reviews some bottom based work - which might help you
14:38:58 <SamB> @hoogle Typeable a -> b
14:39:00 <lambdabot> Prelude.undefined :: a
14:39:00 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
14:39:00 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:39:39 <shapr> I especially like the intuitive representation of (_|_) bottom. It's obviously buttocks.
14:39:41 <palomer> ah, if exceptions are bottoms, then that's fine
14:39:52 <palomer> shapr: adequately named
14:40:23 <SamB> shapr: you wise-ass you!
14:40:41 <SamB> @type Control.Exception.throwDyn
14:40:42 <lambdabot> forall b exception.
14:40:42 <lambdabot> (Data.Typeable.Typeable exception) =>
14:40:42 <lambdabot> exception -> b
14:40:59 <SamB> > throwDyn (1 :: Integer)
14:41:00 <lambdabot>  Not in scope: `throwDyn'
14:41:09 <palomer> so exceptions are bottoms, and we really should only use bottoms as exceptions
14:41:09 <SamB> > Control.Exception.throwDyn (1 :: Integer)
14:41:10 <lambdabot>  Not in scope: `Control.Exception.throwDyn'
14:41:13 <SamB> arg
14:41:38 <SamB> too bad it can't show that kind
14:41:55 <palomer> so bottoms are useful inasmuch as they are used as exceptions
14:42:16 <SamB> palomer: also in as much as they allow partial functions to be defined
14:42:40 <palomer> SamB: hmm?
14:43:02 <palomer> what's a partial function?
14:43:08 <ndm_> palomer, head
14:43:16 <ndm_> its only defined for some inputs
14:43:20 <SamB> fromJust also
14:43:30 <palomer> oh, partial in that sense
14:43:33 <SamB> error is an extreme example
14:43:49 <palomer> but a partial function is simply one that can throw an exception, is it not?
14:44:23 <ndm_> what is this notion of exception?
14:44:34 <ndm_> its not really a haskell thing
14:45:18 <SamB> well, it is, but only when you want to catch them do you bother to think that way
14:45:48 <shapr> SamB: haha
14:45:59 <SamB> shapr: what?
14:46:07 <shapr> I just saw your wise-ass comment.
14:46:08 <ndm_> can you catch regular head style errors?
14:46:11 <SamB> ah
14:46:18 <SamB> ndm_: sure
14:46:26 <ndm_> example?
14:46:36 <ndm_> i've never used exceptions in haskell...
14:47:12 <xerox> Never did 'error "empty list"' ?
14:47:19 <SyntaxNinja> ndm_: I think you should release your darcs gui thing
14:47:24 <SamB> ndm_: well, the easiest way is to just catch anything
14:47:37 <SamB> or you could assume it calls error
14:47:48 <xerox> @index catch
14:47:49 <lambdabot> Control.Exception, System.IO.Error, Prelude
14:47:53 <ndm_> SyntaxNinja: i will do, hopefully tomorrow - depends if i get the time to figure out how to use darcs
14:47:53 <xerox> @type Control.Exception.catch
14:47:54 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
14:47:56 <xerox> @type Control.Exception.branch
14:47:57 <lambdabot> Not in scope: `Control.Exception.branch'
14:48:04 <xerox> @type System.IO.branch
14:48:05 <lambdabot> Not in scope: `System.IO.branch'
14:48:09 <dons> ndm_, catching exceptions generated by library code is a good idea sometimes..
14:48:13 <SamB> @type Control.Exception.ErrorCall
14:48:14 <lambdabot> String -> GHC.IOBase.Exception
14:48:40 <SamB> also, GHCi catches exceptions in the REPL so you can keep going
14:48:40 <dons> lambdabot has to catch 'error' for exmple, since it can't go down for some silly reason
14:48:58 <dons> > error "Yikes!" :: ()
14:48:59 <lambdabot> Yikes!
14:49:11 <dons> (I'm cheating here, but you get the idea :)
14:49:38 <int-e> hmmm.
14:49:40 <dons> hooray for tackling the awkward squad
14:49:49 <ndm_> can you do exception handling outside an IO monad?
14:50:02 <int-e> > error (error "Yikes!") :: ()
14:50:03 <lambdabot> Yikes!
14:50:28 <int-e> > error ("Oh crap!" ++ error "Yikes!") :: ()
14:50:29 <lambdabot> Yikes!
14:50:43 <dons> @type catch
14:50:44 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
14:50:45 <shapr> At one point there were two flavors of exceptions. I think you could catch one of them outside the IO monad.
14:50:59 <shapr> Am I wrong?
14:51:30 <Oejet> @eval take 6 ("Oh crap!" ++ error "Yikes!")
14:51:32 <lambdabot> "Oh cra"
14:51:47 <Oejet> Hurrah for lazy evaluation.
14:51:55 <dons> hey, anyone want to test my mp3 player? darcs get http://www.cse.unsw.edu.au/~dons/code/hmp3
14:52:14 <dons> screenshot: http://www.cse.unsw.edu.au/~dons/hmp3.png
14:52:50 <shapr> Has anyone tried to load House's TCP/IP stack into GHCi?
14:53:04 <shapr> Or must it be used inside House and/or ghc 6.2 ?
14:53:13 <SamB> shapr: um...
14:53:24 <SamB> isn't that a kernel-space thing?
14:53:27 * shapr has another one of those crazy ideas
14:53:32 <dons> but kernel space is just haskell code!
14:53:35 <shapr> Right
14:53:38 <dons> so it runs on the ghc rts..
14:53:45 <SamB> you'd have to do a user-mode port of the cbits
14:53:55 <dons> yeah, maybe
14:53:59 <SamB> right>?
14:54:05 <SamB> maybe even a few haskell bits
14:54:11 <dons> yeah, possibly.
14:54:35 <SamB> so, no, you can't just "load it in GHCi", I'm pretty sure...
14:54:35 <dons> as users can't usually write stuff onto wires without at least root access, right ;)
14:54:51 <psi> dons: what type of UI is that?
14:54:55 <dons> ncurses.
14:55:04 <dons> @seen araujo
14:55:04 <SamB> dons: and even if they have that, the wires must be opened differently
14:55:04 <lambdabot> I saw araujo leaving #gentoo-haskell and #haskell 12 hours, 27 minutes
14:55:04 <lambdabot> and 43 seconds ago.
14:55:05 <shapr> There are userspace network drivers.
14:55:27 <shapr> Like TUN/TAP, though I think that's the old way to do it.
14:55:28 <SyntaxNinja> shapr: are you going to combine the House TCP/IP stack with dons' mp3 player and ndm_'s darcs GUI to create something having to do with the ipod?
14:55:44 <shapr> SyntaxNinja: Nah, I'm in an evil mood...
14:55:47 <dons> oooh...
14:56:13 <SamB> darcs wouldn't be very good for version-controlling MP3s...
14:56:18 <dons> hmm. we could run hmp3 on one of the palms that use nhc
14:56:19 <shapr> But I need a copy of Windows to complete my evil plan.
14:56:23 <fanopnaic>  Can anyone tell me what this error message wants to tell me and what is wrong?:  http://phpfi.com/86314
14:56:28 <ndm_> dons, port to yhc
14:56:36 <SamB> shapr: you haven't got one?
14:56:40 <dons> yhc, will do :) but I want threads!
14:56:43 <shapr> dons: Is Anthony Sloane's PalmOS nhc98 runtime released?
14:56:47 <ndm_> does nhc have them?
14:56:49 <SamB> what do you need that trash for anyway?
14:57:16 * liyang waves at yaarg 
14:57:22 <shapr> SamB: I have an evil plan.
14:57:24 <dons> shapr, hmm. I think he's been convinced of darcs since he stayed with our group, so maybe.
14:57:30 <dons> should I ask him, shapr?
14:57:37 <shapr> Sure yeah!
14:57:44 <ndm_> dons, yhc is in darcs and publically available - feel free to hack threads  in :)
14:58:01 <dons> ndm :p
15:00:36 <SamB> dons: it doesn't want to build
15:00:55 <dons> ?
15:01:03 <dons> error msg please
15:01:05 <SamB> In file included from cbits/curses.h:16,
15:01:06 <SamB>                  from cbits/curses.h:16,
15:01:06 <SamB>                  from cbits/curses.h:16,
15:01:07 <SamB> ...
15:01:15 <SamB>                  from cbits/curses.h:16,
15:01:15 <SamB>                  from cbits/curses.h:16,
15:01:15 <SamB>                  from cbits/curses.h:16,
15:01:15 <SamB>                  fCurses.hsc: In function 'main':
15:01:25 <SamB> Curses.hsc:283: error: 'ERR' undeclared (first use in this function)
15:01:25 <SamB> Curses.hsc:283: error: (Each undeclared identifier is reported only once
15:01:25 <SamB> Curses.hsc:283: error: for each function it appears in.)
15:01:25 <SamB> Curses.hsc:406: error: 'bool' undeclared (first use in this function)
15:01:26 <dons> haskell-overflow ...
15:01:36 <dons> hmm.
15:01:39 <shapr> hmm.
15:01:42 <dons> what Cabal version?
15:01:52 <shapr> Hiya dsilva, are you new to #haskell?
15:02:02 <dsilva> shapr: yep
15:02:03 <SamB> Cabal-1.1.3
15:02:12 <SamB> or at least, thats what it calls itself
15:02:17 <dsilva> shapr: new to haskell as well
15:02:45 <shapr> dsilva: Cool, I can give you the short intro to both as soon as I'm done looking at fanopnaic's code.
15:02:55 <dsilva> shapr: thanks!
15:04:07 <shapr> fanopnaic: At first glance, I'd try changing (zaehle i+1 l) to (zaehle (i+1) l), but I'm not sure that's it.
15:04:47 <shapr> dsilva: Ok, I'll give you the short tour of #haskell
15:04:52 <dsilva> shapr: ok
15:05:04 <shapr> First on your left you have the famous lambdabot, everybody's favorite code toy.
15:05:23 <shapr> Next on your right is the channel topic, including such useful information as the link to the channel logs, going back several years.
15:05:53 <shapr> Right up ahead you'll see the famous Haskell Wiki http://www.haskell.org/hawiki/
15:06:03 <shapr> @learn and last but not least, there's the learning page.
15:06:04 <lambdabot> http://www.haskell.org/learning.html
15:06:09 <SamB> dsilva: you are advised not to attempt to read through the entire IRC logs, as they took many people 24 hours a day to make...
15:06:20 <dsilva> SamB: hehe
15:06:39 <dsilva> shapr: thanks
15:06:39 <shapr> For your first taste test of Haskell, I recommend the http://www.haskell.org/hawiki/HaskellDemo
15:06:48 <fanopnaic> amazing.
15:07:15 <shapr> After that, Hal Daume's Yet Another Haskell Tutorial is a good next step. You may also have a textbook since a university is mentioned in your hostname.
15:07:18 <shapr> fanopnaic: That fixed it?
15:07:35 <shapr> dsilva: So, do you have any questions before you dive in?
15:07:54 <dsilva> shapr: yes.. I am missing something from scheme & ml..
15:08:04 <shapr> What would that be?
15:08:06 <dsilva> shapr: set!/ref
15:08:16 <fanopnaic> mostly.
15:08:18 <dsilva> well, I've been looking at IORef
15:08:20 <shapr> Haskell is referentially transparent.
15:08:40 <shapr> In my opinion, it's best to learn to see things from that viewpoint first.
15:08:42 <dsilva> and inside ghci, whenever I think I modified an IORef, I seem to be wrong
15:08:51 <SamB> except when it isn't, in which case it is referentially opaque
15:08:55 <fanopnaic> The second time today I write int instead of Int :)
15:09:11 <shapr> fanopnaic: Glad I could help.
15:09:13 <SamB> which is much nicer than being referentially translucent throughout
15:09:19 <fanopnaic> thanks a lot.
15:09:25 <dsilva> shapr: oh, I usually stick with FP, but I'm trying to implement some event structures
15:09:41 <SamB> dsilva: chances are you don't need it yet...
15:10:03 <SamB> actually, I don't think I use it in my ZMachine emulator
15:10:11 <shapr> IORef is pretty much a variable.
15:10:17 <SamB> I think I use DiffArray
15:10:21 <shapr> You can also use mutable arrays if you're careful.
15:10:25 <SamB> DiffUArray, to be specific
15:10:26 <dsilva> hmm
15:10:38 <kosmikus> @seen JaffaCake
15:10:39 <lambdabot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
15:10:53 <SamB> though I still need to implement the IO proper-like
15:11:03 <SamB> I don't suppose anyone else would like a go at it?
15:11:10 <dons> SamB, which ghc?
15:11:27 <SamB> The Glorious Glasgow Haskell Compilation System, version 6.4
15:11:33 <dons> what OS?
15:11:41 <SamB> Linux hydrogen 2.6.8-2-686 #1 Thu May 19 17:53:30 JST 2005 i686 GNU/Linux
15:11:52 <SamB> thats on Debian
15:12:00 <dsilva> shapr: so how come I can write "let ref = newIORef 1", and "res <- (ref >>= readIORef)" followed by "res" will show me 1,
15:12:08 <dons> $ grep '#define ERR' /usr/include/ncurses.h
15:12:10 <dons> #define ERR     (-1)
15:12:11 <dons> ?
15:12:25 <SamB> % grep '#define ERR' /usr/include/ncurses.h
15:12:26 <SamB> #define ERR     (-1)
15:12:26 <dsilva> shapr: but then "forced <- (ref >>= \r -> (writeIORef r 2))" followed by another res<-... etc will show 1 again instead of 2?
15:12:28 <dons> though I think it's actually a cabal issue, not the curses binding.
15:12:50 <dons> I'm using 1.1.4, which might have some newer patches for buliding standalone executables
15:13:08 <dons> it sounds a bit like the #include isn't working
15:13:19 <SamB> yes, it does look a bit like that, doesn't it.
15:13:27 <SamB> what I want to know is why there isn't a stack overflow!
15:13:38 <dons> ghc --make -OO -cpp -fglasgow-exts Main.hs   should also work :)
15:14:00 <dons> once you've hsc2hs'd Curses.hsc into Curses.hs
15:14:02 <int-e> dsilva you're creating a new ioRef every time
15:14:13 <SamB> dons: don't cabalize such simple projects! its annoying!
15:14:32 <dsilva> int-e: how can that be? writeIORef returns IO()
15:14:34 <dons> I like getting the installation code for free
15:14:41 <dons> but your point is taken SamB.
15:14:48 <SamB> dons: but why would you want to install it?
15:14:50 <dons> also I like getting the dependencies checked.
15:14:57 <dons> SamB, umm, why not?
15:14:58 <SamB> oh, well.
15:14:59 <shapr> Yeah, the real solution is cabal-get.
15:15:08 <int-e> dsilva: newIORef 1  is an IO action that creates a new IO reference when it's run (which you do in do xxx <- ref)
15:15:19 <dsilva> ohh
15:15:32 <SamB> shapr: would Cabal get be able to fetch me newer versions of cabal and rebuild all the things that depend on it?
15:15:33 <int-e> dsilva: err, ref >>=  in your case.
15:15:39 <shapr> SamB: yes!
15:15:44 <SamB> s/Cabal/Cabal-get/
15:16:34 <shapr> SamB: http://www.haskell.org/hawiki/CabalGet
15:16:37 <dsilva> int-e: oh, I forgot about the laziness.. IO is always a thunk, then?
15:16:38 <SamB> dons: you mispelled 0
15:17:12 <int-e> dsilva: you really need something like   do ref <- newIORef 1; writeIORef ref 2; readIORef ref
15:17:17 <dons> -O I meant.
15:17:25 <shapr> SamB: "The install command resolves dependencies and subdependencies for a given package, downloads all these and installs them, if they were available from a currently selected server."
15:17:54 <SamB> shapr: but how would it know I needed a newer version of Cabal to build hmp3?
15:18:26 <int-e> dsilva: that's a good way to think about it. note that the RTS will 'evaluate' the IO 'thunk' that Main.main returns; this is where all side effects come from, conceptually.
15:18:29 <SyntaxNinja> we need to add a cabal-version field to the .cabal files.
15:18:42 <dons> SyntaxNinja, yep. I reckon so.
15:18:45 <SyntaxNinja> I need someone to take over the cabal-get stuff
15:18:53 <dsilva> int-e: hmm ok
15:18:54 <SyntaxNinja> I have too many things on my plate. Lemmih are you interested?
15:19:06 <dsilva> int-e: I assume this is bad style?  let ref = unsafePerformIO (newIORef 1)
15:19:52 <ndm_> SyntaxNinja: it looks like i won't be able to do cabal-make
15:20:04 <ndm_> yhc is going to have its own --make code
15:20:18 <ndm_> because it needs to do things that cabal can't possibly do
15:20:28 <ndm_> like solving the whole problem of recursively imported modules
15:20:55 <eivuokko> Hmmm.  Too much dependency analysis for haskell around.
15:21:10 <SamB> eivuokko: yes, we know :-(
15:21:23 <SyntaxNinja> ndm_: why couldn't cabal do that?
15:21:37 <ndm_> because it requires compiling many files at once
15:21:42 <ndm_> i.e. at the same time
15:21:43 <eivuokko> Why are recursive modules even allowed?
15:21:51 <ndm_> cabal will sbe heavily used for the preprocessing stuff
15:21:53 <SyntaxNinja> ndm_: you could stage it
15:21:56 <ndm_> but the actual make stuff will be in yhc
15:22:06 <SyntaxNinja> ndm_: like ghc does, kinda.
15:22:09 <ndm_> recursive modules can't be staged
15:22:17 <SyntaxNinja> eivuokko: I don't know, because they make tons of sense?
15:22:19 <ndm_> because ghc doesn't support recursive modules properly :)
15:22:46 <int-e> dsilva: I haven't made up my mind about that yet. It's unclean but it seems to save quite a bit of code that only passes around values in some cases...
15:22:46 <SyntaxNinja> ndm_: you can stage it by outputting forward references for certain stuff. I thought that this has been figured out by the programatica guys, maybe I'm wrong.
15:22:56 <ndm_> i don't think so
15:23:10 <eivuokko> SyntaxNinja, To me they don't particulary make sense and I don't immediately see forced need for them.
15:23:15 <int-e> dsilva: so I may easily be seduced into coding something like that.
15:23:19 <ndm_> anyway, the code will be very well done - so can be reused for cabal-make
15:23:25 <SyntaxNinja> eivuokko: do circular data structures make sense?
15:23:33 <dsilva> int-e: don't you have to always live inside a "do" bubble otherwise?
15:23:38 <SyntaxNinja> ndm_: ok
15:23:53 <eivuokko> SyntaxNinja, yeah, but why do you have to have them in more than one module?
15:24:07 <SamB> eivuokko: because GHC needs them in its implementation?
15:24:22 <int-e> dsilva: well, mostly, you do - but you could also live in an ST bubble that I can run with runST.
15:24:26 <int-e> @index runST
15:24:27 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
15:24:27 <eivuokko> Ah, I just add this to my check GHC sources list to understand...
15:24:35 <int-e> @type Control.Monad.ST.runST
15:24:36 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
15:24:42 <SyntaxNinja> eivuokko: in large systems, stuff tends to gravitate to a single module if you don' thave recursive modules. the hwole point of modules is to break up logically distinct sections.
15:25:11 <SamB> eivuokko: notice the {-# SOURCE #-} pragmas scattered about in imports
15:25:22 <SyntaxNinja> like, say you were implementing a filesystem; a directory is a kind of file, and directories contain files, but I want a module for directories and a module for files.
15:25:29 <dsilva> int-e: hmmm, so then what's the difference?
15:26:26 <int-e> dsilva: runST creates a bubble and runs code in it; it can be called from pure code, while you can't safely create IO bubbles.
15:27:06 <SamB> dons: maybe you just shouldn't call that file curses.h?
15:27:22 <SamB> I get the same problem the other way too, I think its a C-compiler-related issue
15:27:28 <dons> ah, SamB, good idea.
15:27:42 <SamB> because the same thing happens without cabal
15:27:45 * pesco drags himself to bed.
15:27:46 <eivuokko> SyntaxNinja, Yeah.  I never said it might not be convient.  It seems to me that it's just sot of feature that forces partial "global" compilation.  Which tends to be annoying to manage...so...I wouldn't count it as a win to have.
15:27:53 <pesco> Good night, #haskell.
15:27:59 <shapr> g'nite pesco
15:28:06 * pesco turns off the light.
15:28:10 <dons> SamB, hmm. no issue here either way. I'll test it on linux.
15:28:21 * pesco mumbles "tell me about your evil plan tomorrow..."
15:28:40 <SamB> dons: yeah, I'm pretty sure it has to do with -I and the include path...
15:29:00 <xerox> Goodnight folks!
15:29:24 <dons> oh, do you have -Icbits on the cmdline ?
15:29:29 <int-e> dsilva: well, doing it in the clean way you can never break out of the IO bubble, that's right. It's safe but possibly annoying.
15:29:40 <dsilva> int-e: hmm this last part I don't really understand... since IO computations can be forced with unsafePerformIO to get a value out, and ST bubbles can be forced with runST and an initial state, they look the same to me
15:29:42 <dons> SamB, you'll need any flags mentioned in the .cabal file
15:29:44 <SamB> dons: yes, to get that far
15:29:44 * int-e likes the term 'bubble' for monads btw.
15:30:00 <dons> right. ok. i'll do some more testing. cheers.
15:30:41 <pesco> (mmn mnm mm need cabal get mnm mm no time mmmrmm *snore*)
15:30:42 <int-e> dsilva: the difference is that the ST monad can not perform IO, only memory accesses inside it's own memory area (that's how I understand it), so it's safe.
15:30:43 <dsilva> int-e: I kind of cringed when I saw the term "computation" in the manual, as if the next page would attack me with denotational semantics
15:31:38 <int-e> dsilva: actually, the IO monad in ghc is a special ST instance, so the difference is indeed very small.
15:31:38 <SamB> oh, huh, why is it including curses.h anyway?
15:31:42 <SamB> I have ncurses!
15:31:45 <dsilva> int-e: oh, that works for me then, since I only need a ref cell
15:32:20 <dons> SamB, ah interesting.
15:33:28 <shapr> hiya hoopy, learning Haskell?
15:33:38 <hoopy> thinking about it
15:34:04 <shapr> hoopy: Have any questions, or want the short tour?
15:34:19 <hoopy> a short tour would be great
15:34:19 <SamB> shapr: what about the long tour?
15:34:31 <shapr> SamB: Even I haven't finished taking the long tour.
15:34:35 <SamB> oh
15:34:43 <SamB> that would explain why you don't offer it ;-)
15:34:52 <shapr> Right, I'm not done with it yet :-)
15:35:08 <shapr> There's still so much cool stuff to learn.
15:35:30 <SamB> like, tomorrows lambdabot features!
15:36:00 <Itkovian> hoopy: did you read the 'Yet Another Haskell Tutorial'?
15:36:06 <hoopy> nope
15:36:10 <Itkovian> @google yet another haskell tutorial
15:36:12 <lambdabot> http://www.isi.edu/~hdaume/htut/
15:36:21 <shapr> Ok, short tour...
15:36:26 <Itkovian> hehe
15:36:35 <shapr> First we have the lovely lambdabot, everbody's favorite code toy.
15:36:37 <shapr> @botsnack
15:36:38 <lambdabot> :)
15:36:39 <Itkovian> I knew we could count on our favorite explanator here
15:36:56 <int-e> @karma+ shapr
15:36:57 <hoopy> i see
15:36:57 <lambdabot> shapr's karma raised to 13.
15:36:58 <shapr> Next we have the channel topic, which includes useful links like the url for the channel logs.
15:37:11 * hoopy nods
15:37:14 <SamB> only 13?
15:37:19 <shapr> After that there's the Haskell wiki at http://www.haskell.org/hawiki/
15:37:21 <SamB> @karma+ shapr
15:37:22 <lambdabot> shapr's karma raised to 14.
15:37:22 <dons> > map (*2) [1..4]
15:37:23 <lambdabot> [2,4,6,8]
15:37:27 <shapr> @learn And last but not least, the Learning Haskell page!
15:37:28 <lambdabot> http://www.haskell.org/learning.html
15:37:43 <hoopy> map (+1) [1,2,3]
15:37:46 <hoopy> > map (+1) [1,2,3]
15:37:47 <lambdabot> [2,3,4]
15:37:52 <hoopy> neat
15:37:59 <SamB> hoopy: thats the new way
15:38:11 <SamB> if you had come a couple days back, it would have been
15:38:16 <SamB> @eval map (+1) [1,2,3]
15:38:17 <lambdabot> [2,3,4]
15:38:22 <SamB> but people kept doing
15:38:25 <SamB> @map (+1) [1,2,3]
15:38:25 <hoopy> eval eh
15:38:26 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:38:31 <SamB> which doesn't work
15:38:32 <hoopy> how do you stop people from doing evil things
15:38:33 <dons> SamB :)
15:38:39 <dons> with types!
15:38:54 <SamB> hoopy: types, and limited modules in scope
15:38:56 <dons> > readFile "/etc/password"
15:38:57 <lambdabot> No IO allowed
15:38:59 <shapr> hoopy: I'd suggest starting with the taste test at http://www.haskell.org/hawiki/HaskellDemo and continuing with Hal Daume's "Yet Another Haskell Tutorial"
15:39:08 <shapr> hoopy: and feel free to ask any questions here
15:39:10 <hoopy> > map (**2) [2,3,4,5,6]
15:39:12 <lambdabot> [4.0,9.0,16.0,25.0,36.0]
15:39:18 <dons> > last [1..]
15:39:23 <lambdabot> Terminated
15:39:24 <hoopy> ...
15:39:26 <hoopy> nice
15:39:43 <int-e> > map (^2) [2..6]
15:39:45 <lambdabot> [4,9,16,25,36]
15:39:50 <pesco> > unsafePerformIO (writeFile "/etc/passwd" "Midijunkies! Gonna fuck you up.")
15:39:51 <lambdabot>  Not in scope: `unsafePerformIO'
15:39:57 <dons> >  scanr (*) 1 [1..]
15:39:58 <hoopy> why does ** return floats?
15:39:59 <lambdabot> Stack overflow
15:40:07 <dons> @type (**)
15:40:08 <lambdabot> forall a. (Floating a) => a -> a -> a
15:40:14 <dons> @type (^)
15:40:15 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:40:20 <hoopy> aha
15:40:28 <int-e> hoopy: there are three exponentiation operators, ^, ^^ and **, all with different types.
15:40:31 <dons> >  Random.randomRs (0,747737437443734::Integer) (Random.mkStdGen 1122)
15:40:32 <lambdabot> [342078620969566,48308706877090,572179348270332,549093210652565,70427642691
15:40:32 <lambdabot> 0945,587942541619884,341430257819319,104095613367277,55087558676037,
15:40:32 <lambdabot> 184438269089968,685762763531656,246086558481717,396188596370292,34284624221
15:40:32 <lambdabot> 6622,300111653132464,285367607965339,86579547029816,605794293093320,
15:40:32 <lambdabot> 415091386176643,117193156303242,430540419691810,157346535699280,63228681915
15:40:34 <lambdabot> [24 @more lines]
15:40:36 <dons> hehe.
15:40:41 <int-e> @type (^^)
15:40:42 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:40:57 * hoopy doesn't understand that
15:41:18 <hoopy> i was reading about lambda calculus
15:41:27 <Dibrom> anyone here used happy for unicode lexing before?
15:41:29 * shapr tokes on a lambda
15:41:33 <int-e> hoopy: ^ works for nonnegative integer exponents. ^^ for integer exponents. ** for real exponents.
15:41:33 <yaarg> good stuff
15:41:37 <ndm_> Dibrom, GHC does
15:41:38 <yaarg> it's beautiful isn't it? :)
15:41:46 <yaarg> (the lambda calc)
15:41:50 * shapr passes a lambda to hoopy 
15:41:56 <shapr> The first lambda comes free, man.
15:41:58 * hoopy takes a few puffs
15:42:04 <dons> Dibrom, nope. don't think it will work will it?
15:42:08 <hoopy> @karma+ shapr
15:42:08 <lambdabot> shapr's karma raised to 15.
15:42:17 <dons> since it usees a byte array to represent the table
15:42:19 <shapr> Ah, the buzz of lambda karma
15:42:20 <edwinb> but the second lambda is bound...?
15:42:22 <Dibrom> dons: It works if I specify the regular expressions as a sequence of escape characters
15:42:29 <dons> ah, ok. cool.
15:42:33 <Dibrom> but my problem is that I need to specify a range of unicode characters as a character set
15:42:41 <shapr> edwinb: I've toked on so many lambdas I'm getting dependent types.
15:42:44 <Dibrom> but this is a problem since it's not a single character.. I can't do like a-z
15:42:46 <edwinb> hehe
15:42:56 <dons> @remember shapr I've toked on so many lambdas I'm getting dependent types
15:42:59 <Dibrom> it'd have to be like \x...\x...\x...-\x...\x...\x...
15:43:02 <Dibrom> but that wont work
15:43:07 * shapr is getting the DTs
15:43:24 <dons> hmm. not sure Dibrom. someone on haskell-cafe@ will know
15:43:58 <Dibrom> ok
15:44:18 <shapr> hoopy: So, got any lambda calculus questions?
15:44:29 <Dibrom> does anyone happen to know of a good lexer in any other languages with real strong support for unicode?
15:44:43 <Dibrom> (pref a language I can interface haskell with somehow)
15:44:54 <ndm_> Dibrom, i'm writing one...
15:45:18 <ndm_> but unfortunately it will probably take too long to be useful to you...
15:45:28 <Dibrom> ndm_:  ah.. darn :)
15:45:35 <dons> Dibrom, you could use CTK, that's a Haskell combinator-based lexer, a la parsec
15:45:43 <dons> that surely supports unicode
15:45:46 <dons> @where ctk
15:45:47 <lambdabot> I know nothing about ctk.
15:45:58 <Dibrom> never heard of that one.. I'll look at it
15:46:22 <Dibrom> speed is possibly an issue though
15:46:24 <dons> if you only want a lexer, have you looked at alex?
15:46:47 <dons> rather than the parser happy.
15:46:54 <Dibrom> yes, actually I meant to say alex earlier
15:46:57 <Dibrom> not happy ;)
15:47:03 <Dibrom> I'm using alex/happy right now for my problem
15:47:13 <hoopy> sigh
15:47:21 * hoopy has to go be the family tech guy
15:47:30 <hoopy> thanks a lot guys
15:47:33 <shapr> hoopy: come back soon.
15:47:36 <hoopy> i'll most likely be returning
15:47:38 <Dibrom> it is in alex that I need a way to specify unicode character ranges
15:47:40 <shapr> We'll leave a lambda lit for you.
15:47:44 <Dibrom> but can't figure out a way to do it
15:47:57 <dons> ctk lives http://www.cse.unsw.edu.au/~chak/haskell/ctk/index.html#CTKlight
15:48:14 <dons> @where+ ctk http://www.cse.unsw.edu.auc/~chak/haskell/ctk/index.html
15:48:14 <lambdabot> ctk ~> http://www.cse.unsw.edu.auc/~chak/haskell/ctk/index.html
15:49:11 <Dibrom> thanks
15:49:22 <shapr> It occurs to me that FLM would work better if it could annotate arbitrary XML trees.
15:49:44 <shapr> Then ps/pdf documents could be displayed as SVG via pstoedit, and it would allow annotation of any XHTML page as well.
15:49:50 <Dibrom> dons: how is the performance of CTK?
15:50:16 <shapr> And it would answer the question of how to annotate the GHC manual that SPJ raised.
15:50:39 <shapr> But I don't know a sensible way to do that, does anyone have ideas?
15:50:55 <dons> Dibrom, has been no problem in the 4 or 5 projects I've used it in. It was used in c2hs, but was replaced with alex/happy, to increase the speed.
15:51:18 <dons> if speed is really crucial, you'll need alex.
15:51:37 <Dibrom> speed is pretty critical, or at least will be later on
15:51:42 <dons> and ask on haskell-cafe@ about unicode support.
15:51:57 <dons> ok, then I'd try to get alex working.
15:54:45 <SamB> @quote shapr
15:54:45 <lambdabot>  I am hexed and vexed ;-)
15:54:49 <SamB> @quote shapr
15:54:49 <lambdabot>  I am hexed and vexed ;-)
15:54:51 <SamB> @quote shapr
15:54:52 <lambdabot>  GHC has more flags than the UN
15:55:03 <SamB> @quote shapr
15:55:04 <lambdabot>  I've toked on so many lambdas I'm getting dependent types
15:55:06 <SamB> @quote shapr
15:55:07 <lambdabot>  I encourage my competitors to use Windows.
15:55:21 <SamB> @quote JaffaCake
15:55:22 <lambdabot>  I'm afraid I'm completely IA64-ignorant (and hoping to remain that way
15:55:22 <lambdabot> until IA64 goes away :-)
15:55:32 <SamB> @quote SamB
15:55:33 <lambdabot>  Boy, point-free Arrows are worse than Forth...
15:55:57 * SamB stops @quoting
15:56:03 * SamB waits for someone to say something
15:56:17 <dons> @yow!
15:56:17 <lambdabot> My mind is a potato field ...
15:56:20 * int-e refuses to say 'something' or anything else.
15:56:38 <SamB> int-e: you a nobody or something?
15:56:46 <shapr> @quote dons
15:56:47 <lambdabot>  boegel, stop polluting the quote-space please
15:56:54 * shapr grins
15:57:03 <wilx> @quote wilx
15:57:03 <lambdabot>  I mean, besides the murders, it all looks so nice.
15:57:07 <wilx> lol
15:57:07 * edwinb mimes saying something
15:57:10 <shapr> @quote gahhh
15:57:10 <lambdabot> gahhh hasn't said anything memorable
15:57:13 <shapr> @quote Gahhh
15:57:14 <lambdabot>  monads are usually a personal experience.
15:57:25 <shapr> @quote darius
15:57:26 <lambdabot>  Well profiling does add a bit of reflection, but it should have the good
15:57:26 <lambdabot> sense not too go near the barbed wire fences and armed guards.
15:57:54 <int-e> SamB: last time I checked I was still somebody.
15:58:20 <SamB> int-e: ahah! you have said something!
15:58:58 * int-e pouts.
16:04:42 <Itkovian_> erm
16:07:13 <SamB> dons: whats with this:
16:07:39 <SamB> Compiling Config           ( ./Config.hs, dist/build/hmp3/hmp3-tmp/Config.o )
16:07:39 <SamB> ./Config.hs:41:48: Not in scope: data constructor `PATCH_COUNT'
16:07:39 <SamB> ./Config.hs:46:27: Not in scope: data constructor `REPO_PATH'
16:08:12 <SamB> @quote jlouis
16:08:12 <lambdabot>  Q: When does one know he has programmed too much Haskell? A: When he
16:08:12 <lambdabot> uses == and /= in everyday IRC chat or when he tries to fix a relationship
16:08:12 <lambdabot> by passing himself as a continuation
16:10:32 <dons> SamB, becaues you haven't run ./configure
16:10:51 <dons> it should set those values in cbits/config.h
16:11:15 <SamB> dons: that isn't in the README!
16:11:46 <dons> configure should be run automatically by ./Setup.hs configure
16:11:59 <dons> it is run automagically for you by Cabal
16:12:17 <SamB> let me try that again, then
16:12:32 <SamB> I just did that, though!
16:12:40 <dons> check cbits/config.h
16:13:53 <SamB> oh, it looks like you are getting /usr/lib/ghc-6.4/include/config.h instead
16:14:06 <SamB> or should I say GCC is picking it up?
16:15:13 <SamB> or am I just wrong...
16:15:28 <SamB> oh, cbits/config.h wasn't generated
16:15:54 <yaarg> @libsrc Prelude
16:15:54 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
16:15:56 <dons> it wasn't generated when you ran ./configure??
16:16:08 <dons> is configure executable?
16:16:27 <SamB> oh, I meant I would try the cabal way again.
16:16:44 <SamB> it wasn't
16:17:14 <SamB> I just tried chmod +x ing it and that seems to have worked, at least to some extent
16:19:02 <dons> it's a common issue, checking out from darcs leaves ./configure non-exec. ./Setup.hs configure then silently won't execute it
16:19:11 <dons> however, I think this is fixed in 1.1.4 of Cabal
16:19:17 <dons> SyntaxNinja, is that true ^^
16:23:16 <shapr> Hey bosie, mountain unicycling is a heavy duty sport.
16:23:37 <bosie> hehe ;)
16:25:01 <SamB> okay, now it builds but it claims there is a user error
16:25:30 <fanopnaic> is there a list of things lambdabot can do?
16:25:41 <SamB> in particular, it says: "user error (Curses[-1]:keypad)"
16:25:55 <shapr> bosie: Here's an example - http://www.krisholm.com/images/index-Pages/Image14.html
16:25:56 <ndm_> @listcommands
16:25:56 <lambdabot> use listcommands [module|command], please. Modules are:
16:25:56 <lambdabot> babel base code dice dict dummy dynamic elite fact haddock help hoogle
16:25:56 <lambdabot> karma localtime more pl plugs quote search seen spell state system todo
16:25:56 <lambdabot> topic type version vixen where
16:26:06 <bosie> shapr WOW
16:26:53 <shapr> Lots more good stuff in that gallery.
16:26:58 <fanopnaic> @listcommands code
16:26:59 <lambdabot> code provides: code
16:27:03 <bosie> shapr if thats u, dude, you have HUGE balls
16:27:31 <shapr> Nah, that's Kris Holm. This is me - http://www.scannedinavian.com/images/shae-sj.png
16:27:44 <dons> SamB, ah! now that's interesting
16:27:59 <shapr> Sadly, I don't have any pix of going down mountainsides, though I do go down some fun rocky hillsides around here.
16:28:04 <dons> so that's a bug. you just running this in an xterm?
16:28:16 <bosie> shapr ok that doesnt look as good as the first shot tbh ;)
16:28:17 <dons> hmm. you're using 6.4 right?
16:28:31 <shapr> bosie: Yeah, but my legs didn't get that size from unicycling on flat ground.
16:28:33 <dons> SamB: 6.4 has a ffi bug that breaks the ncurses library
16:28:40 <dons> SamB: you have to compile with -fasm to fix this.
16:28:47 <dons> it's fixed in 6.4.1
16:28:49 <SamB> dons: oh
16:29:06 <dons> I'd forgotten about this. the bug broke all ncurses apps :/
16:29:45 <bosie> shapr ;)
16:29:48 <shapr> bosie: You should try it sometime, it's fun.
16:30:25 <bosie> shapr i have troubles with my coordination, i doubt ur bike would help ;)
16:31:01 <dons> SamB, thanks for the patch.
16:31:12 <shapr> If you can ride a bike, you can ride a unicycle with a bit more practice.
16:31:21 <shapr> Anyway, enough proselytizing from me.
16:32:30 * dons likes using hmp3 
16:39:30 <SamB> shapr: but how do you get on the unicycle?
16:39:41 <bosie> SamB lol
16:40:07 <shapr> Freemounting is where you sit on the seat first, then you put one foot on a pedal and you step forward onto the other pedal.
16:41:26 <SamB> maybe the hall of a college dorm is not the proper place to learn to get on a unicycle?
16:42:09 <shapr> Actually, I've read about several people who learned in a college dorm hall.
16:42:19 <shapr> Here's a good freemounting tutorial - http://www.unicyclist.com/gallery/?g2_view=core.ShowItem&g2_itemId=104770&g2_GALLERYSID=815d1b754b75047f2b5201238693f429
16:42:24 <bosie> SamB depends on how much u already smoked i guess
16:42:25 <shapr> It worked for me, at least.
16:42:45 <SamB> well, I don't actually have a unicycle
16:43:19 <bosie> shapr how much for a unicycle ?
16:45:04 <shapr> My first one was a decent learning unicycle, it cost me about 100 euro. You can get them cheaper than that if you look around a bit.
16:45:19 <SamB> how much is a euro
16:45:21 <SamB> ?
16:45:32 <bosie> are you british ?
16:45:33 <shapr> SamB: You can probably get a training uni for a hundred bucks.
16:45:44 <SamB> hmm
16:46:03 <shapr> My most recent heavy duty rough terrain mountain unicycle cost me about a thousand euro, and I still want to upgrade some parts.
16:46:27 <yaarg> rough terrain?
16:46:33 <bosie> do you hae suspensions ?
16:46:33 <yaarg> lol
16:46:45 <yaarg> that's a hardcore unicycle
16:46:59 <shapr> Yeah, 3.7 inch wide tire and 65mm wide rim is overkill for pavement.
16:47:01 <SamB> dons: it won't play videos!
16:47:18 <SamB> of course, it doesn't sound very good in mpg123 anyway...
16:47:35 <shapr> bosie: No, that's not my style. You can buy titanium unicycles with flex suspension if you want.
16:47:42 * yaarg googles mountain unicycle :P
16:48:01 <shapr> There are some nice carbon fiber touring unicycles that are fast and smooth, but also not my style.
16:48:02 <SamB> now it just segfaults
16:48:09 <bosie> yaarg at least you cant fly over the handle bar :D
16:48:27 <shapr> Actually...
16:48:31 <yaarg> bosie: heh
16:48:54 <bosie> anyone by any chance got a nokia n6680 ?
16:49:31 <dons> SamB, mpg321 isn't very good? hmm, hadn't noticed
16:49:36 <SamB> #0  0x08062d11 in UI_refresh_info ()
16:49:36 <SamB> #1  0x00000009 in ?? ()
16:49:36 <SamB> #2  0x080e7e64 in GHCziBase_True_closure ()
16:49:55 <SamB> dons: I was just messing around and trying to get it to play a video file
16:50:09 <dons> what on earth did you think it would do? ;)
16:50:35 <dons> but that crash looks like it's on the haskell side, which isn't very nice
16:50:57 <dons> boy, SamB, you really know how to mash my code up :[
16:51:31 <dons> but, umm, it does actually work with normal .mp3 files, right??
16:52:18 <dons> and the arrow keys let you switch tracks and skip? q quits, and so on. ' ' pauses/unpauses?
16:54:41 <dcoutts> @seen bojohan
16:54:42 <lambdabot> I saw bojohan leaving #haskell 4 hours, 36 minutes and 56 seconds ago.
16:54:49 <bosie> cu
16:56:51 <Frederick> @seen ski
16:56:51 <lambdabot> I saw ski leaving #haskell-blah, #haskell-overflow and #haskell 5 hours,
16:56:51 <lambdabot> 1 minute and 1 second ago.
17:02:20 <dons> @pl map (\c -> A c hl)
17:02:21 <lambdabot> map (flip A hl)
17:04:14 * shapr cackles happily
17:06:32 <shapr> How do I tell a tun/tap device which of my physical devices to attach to?
17:10:50 <SamB> dons: actually, it crashes with normal ones two
17:11:12 * shapr figures it out
17:11:25 <SamB> its probably a build issue or something like that...
17:13:31 <SamB> dons: have you tried it on Linux?
17:13:52 <SamB> because it says that refresh is needed on Linux, implying that it isn't needed on BSD...
17:14:00 <beelsebob_> hehehee *just sent a fun message to the mailing list*
17:14:40 <SamB> how do I build with debug symbols? is it possible?
17:15:10 <rep> whoa yhc!
17:15:16 <dons> SamB, haven't tried on linux. but the code is out of yi, so I assumed there'dd be no issues.
17:15:22 <dons> i'll test today.
17:15:58 <SamB> UI.hs is out of Yi too?
17:16:09 <dons> nope.
17:16:13 <dons> but based on it
17:16:26 <dons> (I've completely rewritten the ui today, in fact. comitting soon)
17:18:54 <SamB> anyway, if you look carefully, you realize that UI_refresh_info refers to the code of UI.refresh
17:20:09 <dons> hehe
17:20:29 <dons> which ultimately ends up calling some C code, which might be bogus for some reason
17:25:47 * palomer wonders if anyone actually uses literate programming
17:27:20 <Cale> I've used it
17:27:25 <palomer> Cale: your thoughts?
17:27:28 <Cale> It's quite nice actually
17:27:36 <shapr> Yeah, it's nifty.
17:27:36 <palomer> why don't you use it all the time?
17:28:11 <beelsebob_> shapr: up late arent you?
17:28:33 <shapr> Yes, but I'm working on an evil project.
17:29:02 <Cale> It's nice for when the algorithms and methods that you're using wouldn't be entirely obvious to someone new to the code.
17:29:03 <SamB> shapr: you ought to fire yourself
17:29:03 <beelsebob_> oh, excellent, trying to take over the Haskell world like Tom and Neil and I?
17:29:04 <shapr> Xianianol: Learning Haskell?
17:29:14 <shapr> SamB: Then my company would be naked.
17:29:27 <SamB> naked?
17:29:34 <shapr> It would have no employees.
17:29:43 <SamB> you mean gone
17:29:49 <shapr> Right, that.
17:30:02 <Cale> Or if you want something that you can print out as LaTeX and provides its own documentation
17:30:23 <SamB> anyway, you'd have to come to your senses and re-hire yourself
17:30:28 <shapr> Exactly.
17:30:32 <Cale> Basically, if you were going to write about how you coded something anyway, it's nice to code it in the literate style.
17:31:02 <palomer> but, ugh, latex!
17:31:03 <shapr> Ok, so ... I want to route packets from my tun0 to eth1, can I assign tun0 an address just like everything else?
17:31:11 <Cale> latex is nice :)
17:31:14 <palomer> pfft
17:31:19 <shapr> Yeah, nothing else does category theory well.
17:31:20 <palomer> they could have made the syntax more intuitive
17:31:23 * int-e finds it hard to find the code in Latex style literate Haskell.
17:31:27 <Cale> more intuitive?
17:31:39 <int-e> (unless you're actually reading the file)
17:31:40 <palomer> yes!
17:31:46 <shapr> They? Wasn't it one guy who wrote LaTeX?
17:31:51 <yaarg> try tex
17:31:55 <shapr> ok
17:32:02 <palomer> wasn't latex standardized?
17:32:17 <Cale> TeX is simpler, I used plain TeX for a lot of my assignments
17:32:21 <yaarg> Knuth wrote TeX io think
17:32:31 <Spark> yes knuth wrote tex, other people wrote latex
17:32:34 <Cale> LaTeX is nicer for large documents though
17:32:41 <Spark> tex is good for things like cvs
17:32:44 <Cale> Leslie Lamport
17:32:48 <Cale> iirc
17:32:50 <palomer> you actually wrote latex for you assignments?
17:32:54 <Cale> yes
17:32:56 <palomer> a lot of extra work
17:32:58 * int-e has actually made a lhs version of his linear recurrence evaluator, http://web.inf.tu-dresden.de/~bf3/haskell/LinRec.lhs , that explains the math behind it.
17:33:04 <Spark> where you want control of the appearance rather than the content
17:33:08 <Cale> not once you're used to it
17:33:16 <Spark> i did a lot of assignments in latex
17:33:21 <Spark> much quicker than word
17:33:21 <Spark> less fiddly
17:33:32 <Spark> i also do slides and things with beamer
17:33:34 * yaarg has been writing stuff in latex since his first year at university so I'm ready to write papers eventually.. :P
17:33:34 <Cale> As a pure math student, it's good to get used to it anyway
17:33:36 <int-e> much better at formulas.
17:33:53 <palomer> I do mine with a dirty piece of paper and a pencil
17:34:19 <Cale> pen or pencil and paper are nice for scratch work
17:34:20 <palomer> seriously, though, xml is simpler
17:34:27 <palomer> the syntax is straightforward
17:34:29 <Cale> xml is not simpler at all
17:34:37 <palomer> you have tags, and that's it
17:34:37 <Cale> have you tried writing mathml
17:34:38 <Cale> ?
17:34:39 <int-e> xml is *not* human-readable.
17:34:39 <yaarg> xml lol
17:34:41 <palomer> how is that not simpler?
17:34:42 <shapr> Yay, ethereal likes packets from the House TCP/IP stack.
17:34:54 <Cale> xml is not one language
17:34:59 <yaarg> xml is fairly human friendly
17:35:05 <yaarg> i like how it ties in with xslt
17:35:10 <int-e> ok, most of the stuff that's being done with xml isn't.
17:35:10 <dsilva> how do you debug pieces of haskell code?
17:35:18 <palomer> Cale: I meant xml syntax
17:35:26 <shapr> dsilva: I use HUnit and QuickCheck.
17:35:27 <dsilva> insert  "unsafePerformIO print 'dbg message' >> return"  before some code?
17:35:28 <Cale> xml syntax alone is simple
17:35:43 <Cale> but the syntax of languages embedded in xml tends not to be
17:35:44 <shapr> dsilva: That's called Debug.Trace
17:35:52 <shapr> Or is it Test.Trace now?
17:35:52 <dsilva> shapr: oh
17:36:22 <Cale> and currently, there's only one thing which even comes close to doing what TeX does, and that's MathML.
17:36:51 <Cale> at least, on the input side of things
17:36:58 <int-e> dsilva: hmm, unsafePerformIO (print "debug message") `seq` expression  prints a message when the expression is first evaluated.
17:37:07 <int-e> @index seq
17:37:07 <lambdabot> Prelude, Control.Parallel
17:37:53 * int-e will have to look at Test.Trace, hmm.
17:38:17 <palomer> Cale: do we really need all of latex for literate programming?
17:39:01 <Cale> have you tried writing  ${-b \pm \sqrt{b^2 - 4ac} \over 2a}$ in mathml lately? :)
17:39:05 <int-e> Debug.Trace.trace ... ah. that does pretty much what dsilva wrote.
17:39:24 <Cale> well, for the sorts of things I've done, I've gotten use out of it
17:39:31 <Cale> it's a nice combination with Haskell
17:39:37 <int-e> trace string expr = unsafePerformIO $ do putTraceMsg string; return expr
17:39:38 <palomer> Cale: you are not going to tell me that that syntax is intuitive
17:39:41 <dsilva> hmm ok
17:39:50 <palomer> Cale: check #math
17:40:20 <Cale> It's not intuitive, but it's compact, and after learning a little, you can read it quite easily.
17:40:37 <palomer> right
17:40:45 <palomer> but then you don't use it for 2 months and then you have to relearn it
17:41:16 <shapr> I still remember how to use Windows 3.11
17:41:23 <Cale> nah, I haven't used latex in a serious way for 6 months, and I just tried that and it worked
17:41:23 <shapr> I *wish* I could get rid of that.
17:41:38 <Cale> hehehe
17:41:44 <Cale> you're not alone :)
17:41:48 <palomer> Cale:  you copied it off wikipedia!
17:42:00 * shapr sighs
17:42:07 <shapr> palomer: Give it up man.
17:42:16 <Cale> palomer: hm?
17:42:24 <Cale> wikipedia?
17:42:34 <shapr> Some people like some things, some people like others. It's just the way it is.
17:42:46 <Cale> Well, it's the quadratic formula, I suppose that I could have.
17:44:25 <dsilva> do newbies (like me) frequently throw haskell into an infinite loop...without recursion?
17:44:39 <palomer> shapr: give what up?
17:44:51 <palomer> Cale: http://en.wikipedia.org/wiki/MathML
17:45:07 <Cale> heh
17:45:13 <shapr> Can you do this with MathML? --> $$\xymatrix{{A}\ar[r]^{f}\ar[d]_{k}&{B}\ar[d]^{g}\\{C}\ar[r]_{h}&{D}}$$
17:45:19 <Cale> wow, they picked the same example as me
17:45:28 <palomer> shapr: I can't read that, nor would I be able to write it
17:45:49 <Cale> palomer: that generates a nicely laid out commutative diagram
17:46:01 <Cale> it's a commutative square, if I'm reading it correctly
17:46:09 <shapr> yup
17:46:09 <palomer> bah, I give up (if that's what you want)
17:46:18 <palomer> I still think latex could be more intuitive
17:46:24 <shapr> I agree with that.
17:46:37 <palomer> that's all I'm saying!
17:46:37 <shapr> But I'm not convinced that MathML or any XML will be an improvement.
17:46:48 <shapr> Everything could be more intuitive.
17:46:52 <Cale> A in the upper left corner, an arrow right labeled f, an arrow down labelled k, B in the upper right, an arrow down labelled g...
17:47:15 <palomer> <fraction> <top> ... </top> <bottom> ...  </bottom></fraction>
17:47:15 <thou> shapr: i'm not sure that palm reading could be more intuitive
17:47:33 <shapr> thou: It would be easier if someone wrote on the palms first :-)
17:47:48 <Cale> It's not always the best to go for the intuitive route. Sometimes you have to make concessions to make the things usable for people who are actually going to use it :)
17:48:17 <shapr> palomer: Look at the commutative square at the bottom of my wiki page - http://www.haskell.org/hawiki/ShaeErisson
17:48:35 <palomer> or have optionally named arguments!
17:48:38 <Cale> If I have to type 30 lines to get the quadratic formula, it's just not worth my time.
17:48:39 <palomer> best of both worlds
17:49:21 <palomer> Cale: MathML is very low level
17:49:30 <palomer> you could probably write LaMathMLex
17:49:41 <Cale> on the other hand, MathML would be good as a communication program between pieces of software
17:49:43 <Cale> er
17:49:45 <Cale> language*
17:49:56 <palomer> Cale: stop quoting the wikipedia page!
17:50:06 <Cale> I haven't read that page
17:50:09 <palomer> oh
17:50:24 <palomer> hrm, I'm going to finish this question
17:50:47 <shapr> I have successfully sent packets from the Haskell TCP/IP stack into my kernel. Sadly, I do not yet know how to route them to the internet proper.
17:55:03 <thou> Cale: don't be pedantic.  if you *wrote* the page in the first place, it counts as reading it!
17:55:15 <Cale> thou: I didn't write it either :)
17:55:20 <Cale> honest :)
17:55:20 <thou> ;)
17:58:55 <Cale> Now, one thing that I wish was done in XML is the libraries documentation.
18:01:41 <Cale> If Haddock could produce some nice abstract intermediate between the haskell source and the HTML, then it would be easier to set up a wikified version of the docs.
18:03:56 <thou> that would be nice to have
18:05:55 <Cale> Haddock should really be split into two parts -- the part that extracts what's essential for documentation from the source, and the part that writes HTML based on that. I'd hope that the current code at least kind of reflects that :)
18:25:04 <SamB> figures. I rebuild with assembler line numbers, and it works.
18:28:02 <thou> SamB: :(
18:28:09 <SamB> dons: a question: why don't you search for mpg123 before mpg321? do you absolutely require mpg321?
18:33:13 <lisppaste2> Frederick pasted "please advice" at http://paste.lisp.org/display/13433
18:33:38 <Frederick> folks Im back to my cfg validator, I would appreciate some help in how can I acess the stuctures im creating
18:34:46 <Frederick> Im creating that lists to recieve the cfg rules as input
18:35:13 <Frederick> and I want to store them in that production structure Ive created so I can simplify the grammar
18:35:14 <SamB> Frederick: um, it doesn't build
18:35:38 <Frederick> SamB, I know that is also a problem, ski gave me that last lines and Im kinda lost about how to continue
18:36:07 <SamB> Frederick: oh, replace Cfg with CFG everywhere then
18:36:57 <Frederick> SamB, every every?
18:37:05 <SamB> Frederick: yeah
18:38:00 <SamB> also, you'll notice that cfgParser isn't done yet ;-)
18:38:07 <Frederick> SamB, sure
18:38:19 <Frederick> SamB, and there is where Im kinda lost
18:39:00 <Frederick> the onli restriction about CFGs is that the left side of the productions must have only 1 simbol
18:39:39 <Frederick> like S can derive whatever as long all rules are in the form 1char -> whatever the grammar is fine
18:39:43 <SamB> Frederick: give me a sample of the input format for CFGs
18:40:39 <Frederick> SamB, 1 sec
18:41:10 <Frederick> A CFG is a set of variables, terminals, a starting symbol, and a set of productions
18:41:30 <SamB> Frederick: yes, but the syntax!
18:41:33 <Frederick> the only restriction is the one Ive mentioned that a production must have a single char
18:42:09 <Frederick> oh Ive imageine something like S->['Ab','c'] this means that S can generate Ab our c
18:42:48 <SamB> Frederick: and what would the corrosponding Prod be?
18:43:52 <Frederick> SamB, im not sure if Ive understood the question but assuming the question is what is a production, well a production is a non-terminal associated with a list of prossible replacers for it
18:44:20 <Frederick> SamB, there is a very good sample of the concept im trying to emulate here -> http://en.wikipedia.org/wiki/Context_free_grammar
18:44:26 <SamB> Frederick: no, I mean what data value do you want to parse that to?
18:45:29 <SamB> Frederick: you really should add "deriving (Show)" to each of those data types
18:45:37 <Frederick> SamB, oki
18:46:16 <Frederick> SamB, the syntax is | deriving (Show) right?
18:46:23 <SamB> Frederick: no |
18:46:33 <SamB> for example:
18:46:35 <SamB> data CFG t nt = CFG {terminals    :: [Symb t nt],
18:46:36 <SamB>                      nonterminals :: [Symb t nt],
18:46:36 <SamB>                      root         ::  Symb t nt ,
18:46:36 <SamB>                      prods        :: [Prod t nt]}
18:46:37 <SamB>                 deriving (Show)
18:47:54 <lisppaste2> Frederick pasted "is it oki now?" at http://paste.lisp.org/display/13435
18:48:17 <Frederick> SamB, I will be parsing strings
18:48:30 * Frederick is not sure if has really understood the question
18:48:51 <Frederick> ski, heya
18:49:36 <Cale>   Right CFG  -> Just CFG -- this seems to be missing a good bit
18:49:49 <Cale> perhaps you just want  Right x -> Just x
18:50:09 <Frederick> Cale, why would be that?
18:50:22 <Cale> CFG doesn't work as a pattern variable, because it's a data constructor
18:50:32 <Cale> it's going to want additional parameters
18:50:33 * Frederick asks for explanation to try to understand
18:50:59 <Frederick> Cale, so if I replace it for x would it check for the pattern?
18:51:02 * Frederick googles
18:51:04 <Cale> in particular, it needs the terminals, nonterminals, root, and prods for that cfg
18:51:23 <Cale> If you replace CFG with x there, or even cfg, then it will be a variable
18:51:30 <Cale> and will match anything
18:51:37 <Frederick> Cale, this is what I want
18:51:41 <Cale> (anything which typechecks)
18:52:06 <Frederick> Cale, in order to be a CFG the grammar must have terminals, nonterminals, root and prods
18:52:11 <Cale> otherwise, you could do something like
18:52:13 <ski> Right (CFG {terminals = ts,nonterminals = nts,root = r,productions = ps}) -> CFG {terminals = ts,nonterminals = nts,root = r,productions = ps}
18:52:15 <ski> would alsio work
18:52:30 <Cale> Right (CFG t n r p) = Just (CFG t n r p)
18:52:33 <Cale> er
18:52:36 <Cale> Right (CFG t n r p) -> Just (CFG t n r p)
18:52:44 <ski> and that, too
18:52:44 <Cale> or something like ski wrote
18:53:09 <Cale> but just putting CFG there isn't enough - that's not going to compile
18:53:23 <ski> (um, of course add an 'Just' to the right-hand-side)
18:53:45 <Cale> make sure that you try compiling your code often as you write it
18:53:57 <Cale> and test each function as much as possible
18:54:48 <SamB> oh, I wasn't looking that far down...
18:54:56 <Cale> I recommend loading it up in GHCi and reloading the file every time you add or change a definition, to make sure that everything works
18:55:15 <Cale> which can be accomplished by typing ":r"
18:55:24 <Cale> (without the quotes)
18:55:42 <ski> (Frederick : did you see http://rafb.net/paste/results/Mp0I8d32.html ?)
18:55:58 <Frederick> Cale, this is my approach
18:56:25 <Frederick> ski, yes, why?
18:56:52 <ski> (just since that uses 'Right cfg -> Just cfg')
18:57:54 <Frederick> ski, butthat wasnt compilling and Cale said (maybe I missunderstood) thatI cant check the cfg that way cause cfg was a constructor
18:58:06 <Cale> Haskell makes a distinction between identifiers which start with uppercase and lowercase letters
18:58:46 <Cale> If something starts with an uppercase letter, it is a data or type constructor (which are told apart by whether you're in a type signature or not)
18:59:06 <dons> SamB, mpg123 is supposed to work too, but not tested yet..
18:59:44 <Cale> If it starts with a lowercase letter then it is a variable, or the name of a function or value.
18:59:58 <Frederick> Cale, but SamB recommended me to modifing the CFG occurences around the file to match with uppercase
19:00:01 <Cale> Or a type variable.
19:00:06 <ski> (Frederick : 'cfg' is a varaible 'CFG' is nit)
19:00:14 <ski> s/nit/not/
19:00:16 <SamB> dons: on my system, mpg123 IS mpg321, actually. right now, that is.
19:00:16 <Cale> well, that one shouldn't be
19:00:26 <SamB> if I feel like it, I can say I want another as default
19:00:46 <Frederick> Cale, wich one?
19:00:51 <SamB> Frederick: I said "Cfg"
19:00:56 <SamB> not "cfg"
19:01:02 <SamB> sorry for any confusion!
19:01:11 <Frederick> noooooooooo
19:01:15 <Cale> Right CFG -> Just CFG  -- these two CFGs should be lowercased
19:01:15 <Frederick> lemme cry :p
19:01:41 <Cale> http://rafb.net/paste/results/Mp0I8d32.html -- basically, this version is right
19:02:19 <SamB> anyway, did you want something like:
19:02:19 <SamB> CFG {terminals = [T 'A',T 'b',T 'c'], nonterminals = [NT 'S'], root = NT 'S', prods = [("",[NT 'S',T 'A',T 'b']),("",[NT 'S',T 'c'])]}
19:02:28 <SamB> for the result of parsing that?
19:03:20 <ski> except i used 'CFG' in the types instead of 'Cfg' (apparentlt didn't look close enough on the type definition)
19:03:23 <Cale> sorry, where's the example CFG to be parsed?
19:04:07 <Frederick> Cale, the programm must accept any cfg as entry I would suggest something like S -> (S) | ? as an example to start
19:04:16 <SamB> "S->['Ab','c']"
19:04:53 <SamB> thats what he told me, anyhow
19:05:03 <Frederick> Cale, additionally with that thar SamB posted is right
19:05:16 <Frederick> also the input must have the terminals and nonterminals sets
19:05:32 <SamB> Frederick: why's that?
19:06:04 <SamB> (easier that way?)
19:06:09 <Cale> http://rafb.net/paste/results/RGaymi55.html -- this version compiles
19:06:13 <Frederick> SamB, a grammar can have nonterminals that are uselless I need to emulate it in the program so if the teacher inputs
19:06:22 <SamB> ah
19:07:23 <Frederick> a grammar wich has simbols thar are not reached throught the initial symbol I must be able to remove these symbols
19:08:16 <Frederick> folks I brb need to take a fast shower
19:09:47 <SamB> hmm, you might want to consider something like prods :: Map Symb (ProdName,[[Symb]])...
19:10:31 <choudesh> Hello all
19:10:35 <Cale> hello
19:10:56 <choudesh> I need some help. Yes it is HW, but I am a true C person and Haskell isn't comming easy to me.
19:11:07 <choudesh> Is there a paste for this channel?
19:11:21 <Cale> there are lots of things people use
19:11:39 <choudesh> Functional Languages isn't me. ;-)
19:11:46 <choudesh> Mind I pm you Cale?
19:12:05 <Lemmih> lisppaste2: url
19:12:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:12:07 <Cale> I don't mind, but there are other people here who'd probably like to help too
19:13:14 <Korollary> choudesh: there's a haskell intro for C programmers. I write c++ for a living.
19:13:24 <lisppaste2> choudesh pasted "Haskell" at http://paste.lisp.org/display/13437
19:13:32 <Korollary> http://www.haskell.org/~pairwise/intro/intro.html
19:13:35 <SamB> poor Korollary
19:13:52 <Korollary> SamB: what do you write in for a living ?
19:14:04 <SamB> Korollary: hmm, nothing yet.
19:14:13 <choudesh> I am stuck on the "is there a path"
19:14:26 <SamB> I'm a part-time student atm...
19:15:00 <Cale> choudesh: you should be aware that 'type' is more like 'typedef' than 'struct'. 'data' is closer to what 'struct' does, except that it's allowed to be recursive
19:15:15 <choudesh> Cale: ight.
19:15:28 <ski> choudesh : you need to put comment either after '--' or inside '{-' and '-}'
19:15:46 <choudesh> ski: I know how to do comments. ;-)
19:16:36 <choudesh> Cale: Any help?
19:16:52 <Cale> choudesh: well, the normal way to determine if there's a path involves storing which vertices you've visited
19:16:58 <ski> hm, i think you might want to do 'v/=u || v/=w' in the list comprehension
19:17:22 <ski> um, e.g. in 'detach'
19:17:53 <ski> hmm, no you don't
19:17:56 <ski> igonre me
19:17:57 <choudesh> Cale: That is what I have to work with. I can't be much help since I truly just start to learn.
19:18:00 <choudesh> ski: ;-)
19:18:10 <SamB> so, this is like an assignment?
19:18:30 <SamB> where by "like" I mean ""
19:18:32 <Cale> choudesh: have you implemented something like that in C before?
19:18:39 <choudesh> Cale: I understand that, but I can't fathon a way of doing this.
19:18:55 <choudesh> Cale: Yes, I've done many graphs, but I can't figure out how to do this in Haskell
19:19:15 <Cale> well, normally I'd recommend the use of a Set, but because you're new, it might be easiest to store the visited vertices in a list
19:19:28 <SamB> well, it looks like the person who wrote this assignment is not a great fan of type errors
19:19:34 <choudesh> Cale: May sound cheap, but some sample code?
19:19:42 <SamB> which is to say, the type erros from this would be abysmal
19:20:23 <SamB> I would suggest using newtype instead ;-)
19:21:57 <choudesh> Hopefully Cale with give me something to go off of.
19:22:13 <Frederick> back
19:22:22 <ski> choudesh : you need to make a helper function, that takes as argument a list of nodes that has been visited (so you don't get into a loop)
19:22:32 <Cale> path graph v w = path' graph [v] v w
19:22:48 <choudesh> Cale: Explain
19:23:02 <ski> path' graph visited v w = ...
19:23:03 <Cale> path' graph visited v w will look at the neighbours of v
19:23:06 <int-e> choudesh: I guess the hint asks for this algorithm: take the starting node v, find all children of v and look for paths from the children in the graph without v. That's potentially very inefficient, of course; Cale's algorithm will perform better.
19:23:13 <Cale> which are not in visited
19:23:27 <Cale> and figure out if there's a path from any one of them to w
19:24:02 <choudesh> Cale: I know we don't do HW, I don't do it in ##C,##C++, but help me out a bit?
19:24:13 <choudesh> I am really struggling with this.
19:24:32 <Cale> okay
19:24:41 <choudesh> Thank you.
19:24:43 <ski> choudesh : how do you get the children of v ?
19:24:44 <Cale> one thing you might be interested in knowing about is the function all
19:24:52 <ski> @type all
19:24:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:24:53 <Cale> > all (/= 7) [1,2,3,4,5]
19:24:54 <lambdabot> True
19:24:58 <Cale> > all (/= 7) [1,2,3,4,5,7]
19:24:59 <lambdabot> False
19:25:28 <Cale> it takes a predicate, and goes through the list determining if that predicate is true for all the elements of the list
19:25:28 <choudesh> Hmm, interesting.
19:25:51 <choudesh> Though I don't see how this will help
19:25:58 <Cale> or perhaps any
19:26:00 <choudesh> but like I said, I am struggling so. ;-)
19:26:03 <ski> how do you get the children of v ?
19:26:19 <Cale> > any (== 5) [1,2,3,4,5]
19:26:20 <lambdabot> True
19:26:37 <choudesh> ski: (sorry) adopt them? (sorry again)
19:26:51 <choudesh> any (==1) [1,1,2]
19:27:01 <choudesh> any (== 1) [1,1,2]
19:27:06 <thou> put > before it
19:27:10 <Cale> choudesh: if any neighbour of v is connected via a path to w, then w is connected via a path to w
19:27:12 <Cale> er
19:27:13 <choudesh> >any (== 1) [1,1,2]
19:27:13 <Cale> v
19:27:17 <Cale> choudesh: if any neighbour of v is connected via a path to w, then v is connected via a path to w
19:27:22 <ski> > any (== 1) [1,1,2]
19:27:23 <lambdabot> True
19:27:37 <choudesh> > any (==1) [1,1,2]
19:27:38 <lambdabot> True
19:27:43 <SamB> choudesh: lambdabot specifically checks for a space
19:27:52 <choudesh> ah
19:27:57 <SamB> after someone demonstrated the nasty error message from
19:27:58 <SamB> >_<
19:28:02 <Cale> hehe
19:28:07 <int-e> > _<
19:28:08 <lambdabot>  parse error on input `}'
19:28:19 <int-e> hehe
19:28:20 <Cale> heh
19:28:22 <SamB> heh
19:28:23 <choudesh> heh
19:28:39 <choudesh> Cale: I think I don't see the big picture.
19:29:03 <Cale> the idea is to determine if there's a path recursively
19:29:06 <choudesh> Cale: May I ask you to do the code and show me if won't take that long
19:29:20 <int-e> choudesh: there's a path from v to w if v and w are equal or if there's a path from any child of v to w.
19:29:23 <ski> for there to be a path from v to w, either v is w, or v has some neighbour v', from which there is a path to w
19:29:26 <Cale> if there's any path at all, it has to go through one of the vertices next to v
19:29:44 <Cale> ah, or the trivial case, yeah
19:29:45 <Cale> :)
19:29:49 <SamB> wouldn't reverse = map swap?
19:29:54 <SamB> @type map swap
19:29:55 <lambdabot> Not in scope: `swap'
19:29:55 <Frederick> SamB, but http://rafb.net/paste/results/UL8DxU72.html doens compiles cause it cant find the constructor or type of map so Ive checked http://www.zvon.org/other/haskell/Outputprelude/map_f.html and I think I dont need to import anything, am I missing something?
19:30:05 <choudesh> Cale: Thanks
19:30:07 <Cale> SamB: yeah
19:30:12 <SamB> Frederick: oh, sorry, thats in Data.Map
19:30:29 <choudesh> Cale: Just the trivial case? ;-) Remember I was looking at this for an hour and nothing was comming to me
19:30:41 <Cale> hehe
19:30:47 <SamB> @hoogle (a, b) -> (b, a)
19:30:48 <lambdabot> No matches, try a more general search
19:30:51 <Cale> the trivial case is when v == w
19:31:00 <SamB> hmm, I could have sworn there was a function for that
19:31:02 <int-e> > map (uncurry $ flip (,)) [(1,2),(3,4)]
19:31:03 <lambdabot> [(2,1),(4,3)]
19:31:05 <Cale> in which case there's obviously a way to get from v to w
19:31:06 <choudesh> Cale: I got that after I send my msg. ;-)
19:31:14 <SamB> int-e: thats not the one I meant!
19:31:22 <wchogg> I'm having some trouble with types:  I wrote a function that looks like it should work for all Num types, but the inferred type is Double
19:31:37 <SamB> @pl (\(x, y) -> (y, x))
19:31:37 <lambdabot> uncurry (flip (,))
19:31:47 <Frederick> SamB, ive imported data.map with no succes
19:32:00 <SamB> Frederick: Data.Map
19:32:01 <ski> Frederick : 'import Data.Map'
19:32:10 * ski leaves
19:32:14 <Frederick> SamB, http://rafb.net/paste/results/Vra1ge18.html
19:32:19 * Frederick waves to ski 
19:32:20 * Cale branches
19:33:04 <SamB> huh, and that didn't work?
19:33:08 <SamB> well, maybe not then
19:33:13 <choudesh> Cale: the difference between expierence and a noob, quick code. ;-)
19:33:13 <SamB> it was just a thought
19:33:51 <Frederick> SamB, when I considered doing the work in python Ive tought about the same kind of structutr to the productions
19:34:18 <choudesh> Most likely Cale will come up with about 5 lines of code...and that will make me cry.
19:34:33 <Cale> oh, I've written that function before and it was 2 lines
19:34:49 <SamB> Cale: strech it out to five, then, at least!
19:34:52 <Cale> hehe
19:34:55 <choudesh> Cale: Give me the 5 line one. Then I can learn. ;-)
19:35:13 <choudesh> Cale: What do I owe you in return for helping me at this graph?
19:35:16 <int-e> hmm. children, 1 line. pathFromTo, 2 lines.
19:35:24 <choudesh> Cale: I can show you how to do this in C++. ;-)
19:35:28 <Cale> hehe
19:35:35 <SamB> oh, the pain!
19:35:44 <Frederick> SamB,  map reverse ["abc","cda","1234"] works in Prelude
19:35:58 <sethk> hello, all, I actually found a hotel with a decent internet connection.  :)
19:36:11 <choudesh> Cale: Hard function isn't it? (I feel dumb)
19:36:25 <SamB> sethk: who cares? you don't need a decent connection for IRC anyway!
19:36:49 <Frederick> choudesh, where did he post the code?
19:36:51 <Cale> choudesh: it's is kind of tricky to be working with graphs right off the bat
19:36:57 <sethk> SamB, you at least need one that doesn't decide you aren't there any more.  :)
19:37:02 <choudesh> Frederick: It didn't give me any code yet
19:37:03 <Cale> It's much easier to work with tree-like structures in Haskell
19:37:11 <SamB> sethk: hmm, true ;-)
19:37:14 <choudesh> Frederick: My paste: http://paste.lisp.org/display/13437
19:37:18 <Cale> Graphs aren't impossible, but they're not quite as natural
19:37:39 <choudesh> Cale: I agree, but as a first program in Haskell? ;-)
19:37:46 <Cale> oh, my bad, that was testing if a graph was acyclic, but that's fairly similar
19:37:52 <SamB> choudesh: what do you think Cale is? a bot?
19:38:10 <Frederick> choudesh, Ive done similar homework but using C :p
19:38:17 <Cale> choudesh: yeah, you might be better off warming up with some different exercises
19:38:22 <choudesh> SamB: No, monkey. Eat bananas poop code. :-)
19:38:40 <choudesh> Cale: I've been, but this needs to be done, so I been try to work it out and I've been failing
19:38:42 <SamB> choudesh: thats C++ and PHP, silly!
19:38:58 <choudesh> SamB: VB should be in there. ;-)
19:39:13 <sethk> Cale, I certainly hope graphs aren't impossible.  My deadlock detection algorithm uses graphs and I really don't feel like ever proving out a deadlock detection algorithm ever again.  :)
19:39:26 <Cale> hehe
19:39:47 <choudesh> Cale: How is it going? Anything to teach me?
19:40:05 <int-e> choudesh: can you make a function that finds all children of a node v?
19:40:16 <lisppaste2> Frederick pasted "MapProblems" at http://paste.lisp.org/display/13438
19:40:28 <SamB> dons: it works fine except it doesn't deal very well with exceptions
19:40:41 <Cale> well, I don't quite want to give it away, perhaps I'll write you a function which does something different from that, but which is similar in nature
19:40:55 <choudesh> int-e: Hmm, probably would take me a few, but most likely.
19:40:58 <choudesh> Cale: Come on. ;-)
19:41:02 <wchogg> evalBreedingChance :: (Num a, Num b) => (a->b) -> [a] -> (a->b)
19:41:02 <wchogg> evalBreedingChance fitness pop = (\x -> x/total) . fitness
19:41:02 <wchogg> 			       where total = foldl (+) 0 pop
19:41:05 <choudesh> Cale: I lost a piece of my life. ;-)
19:41:12 <SamB> dons: so if I have a file that isn't recognized, it sorta messes up the display
19:41:13 <wchogg> I can't figure out why that function infers type double?
19:41:51 <Cale> choudesh: first of all, write a function which takes a graph, and a vertex, and returns a list of the neighbours to that vertex
19:41:59 <SamB> @type let evalBreedingChance fitness pop = (\x -> x/total) . fitness where total = foldl (+) 0 pop in evalBreedingChance
19:42:00 <lambdabot> forall a b. (Fractional b) => (a -> b) -> [b] -> a -> b
19:42:06 <Cale> (outward)
19:42:12 <SamB> wchogg: it doesn't!
19:42:20 <wchogg> It did when I loaded it into Hugs.
19:42:23 <choudesh> Cale: Seriously, I am loosing the battle.
19:42:30 <choudesh> Cale: I won't lie.
19:42:47 <SamB> its just that type vars constrained to Fractional default to Double
19:42:51 <sethk> wchogg, SamB, well, fractional, double, I think he means why isn't it integer.  ?  wchogg, is that what you mean?
19:42:57 <int-e> choudesh: hint, one of your functions almost does that job already.
19:43:06 <SamB> wchogg: well, the /
19:43:14 <SamB> @type (/)
19:43:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:43:18 <choudesh> int-e: the outdegree is it returned what it pointed to.
19:43:22 <Cale> Okay, I'll give you that one :)
19:43:37 <wchogg> Is Fractional the same as Double?  I guess I don't understand the the numeric types.
19:43:47 <SamB> wchogg: fractional is a type class
19:44:03 <choudesh> I understand the logic
19:44:05 <Cale> choudesh: yeah, if you just return the w's
19:44:07 <SamB> > 1 / 2 :: Double
19:44:09 <lambdabot> 0.5
19:44:10 <choudesh> I don't understand the language
19:44:13 <SamB> > 1 / 2 :: Float
19:44:15 <lambdabot> 0.5
19:44:36 <Cale> well, try and write it and I'll fix up your syntax then :)
19:44:46 <choudesh> Cale: The more code I have, the better I can learn.
19:44:47 <SamB> wchogg: try ":i Fractional"
19:44:55 <sethk> wchogg, fractional is a class, double is the type the compiler uses when it doesn't have anything more specific for fractional
19:44:58 <Frederick> choudesh, http://www.haskell.org/bookshelf/#data-structures
19:45:04 <int-e> 1 / 2 :: Data.Ratio Int
19:45:06 <int-e> > 1 / 2 :: Data.Ratio Int
19:45:07 <lambdabot>  Not in scope: type constructor or class `Data.Ratio'
19:45:11 <wchogg> Oh!  Double is an instance of Fractional?
19:45:14 <int-e> > 1 / 2 :: Data.Ratio.Ratio Int
19:45:15 <lambdabot> 1%2
19:45:16 <SamB> wchogg: yes!
19:45:22 <sethk> wchogg, right
19:45:28 <Frederick> int-e, SamB how can I load map?
19:45:38 <SamB> Frederick: what version of GHC do you have?
19:45:42 <wchogg> Ack!  Okay, now I get it.  Thanks guys.
19:45:49 <int-e> wchogg: there are default instances for some type classes; Double for Fractional, apparently.
19:46:00 <choudesh> Cale: I am not pulling this well.
19:46:39 <choudesh> Cale: Give me a the code just to list the children.
19:46:45 <choudesh> Cale: Let me see if I can pull something from there.
19:46:48 <Cale> neighbours :: Graph -> Node -> [Node]
19:46:48 <Cale> neighbours graph node = [w | w <- graph, node==u]
19:46:53 <Frederick> SamB, ghc-6.2.2
19:46:54 <choudesh> heh.
19:47:01 <choudesh> ok, nevermind, I guess I did have it
19:47:11 <SamB> Frederick: ah
19:47:18 <int-e> choudesh: you realize that in a list comprehension, you can put an arbitrary expression at the head? [2*n | n<-[1,2,3]] or even [42 | n<-[1,2,3]] are both valid and return [2,4,6] and [42,42,42], respectively.
19:47:22 <SamB> Frederick: You could use Data.FiniteMap and the FM type
19:47:26 <Cale> btw, it's better to make the graph the first parameter
19:47:37 <SamB> Frederick: or you could upgrade to 6.4
19:47:43 <choudesh> Cale: Ok
19:47:53 <Cale> because you're more likely to call a function with the same graph, but different vertices, say
19:47:57 <Frederick> SamB, not sure if it is avaliable for gentoo
19:48:04 <SamB> Frederick: oh?
19:48:04 <Cale> which lets you use currying more
19:48:13 <SamB> well than by all means use Data.FiniteMap
19:48:23 <int-e> Cale: you mean partial application :)
19:48:31 <Cale> well, yes
19:48:38 <SamB> int-e: they are so hard to distinguish!
19:48:48 <choudesh> Cale: Syntax error
19:49:03 <Cale> hm?
19:49:12 <int-e> choudesh: he means (u,w) <- graph
19:49:18 <Cale> oh
19:49:22 <choudesh> yea, I got that. :-)
19:49:27 <Cale> neighbours :: Graph -> Node -> [Node]
19:49:27 <Cale> neighbours graph node = [w | (u,w) <- graph, node==u]
19:49:28 <Cale> yes
19:49:30 <Cale> sorry :)
19:49:31 <choudesh> I should try, then open my mouth, not the other way around
19:50:04 <sethk> 6.4.1 is available for gentoo.  but...
19:50:13 <sethk> just download the source and use 6.2 to build 6.4
19:50:23 <SamB> boy, we have a lot of newbies today ;-)
19:50:23 <sethk> then you don't have to care about the distro, although building takes a while
19:50:44 <choudesh> Cale: Now since I know the neighbor.
19:50:44 <SamB> only download 6.4.1 because 6.4 has a bunch of annoying problems
19:50:51 <choudesh> Cale: Next step would be?
19:50:59 <SamB> and more that get blamed on it initially
19:51:03 <Cale> choudesh: we will try to be helpful, but there's a channel policy about homework you should know about :)
19:51:13 <choudesh> Cale: I understand.
19:51:18 <int-e> choudesh: find a proper type for the path check function, maybe?
19:51:20 <choudesh> Cale: That I why I stated at the beginning
19:51:23 <Cale> choudesh: well, that recursive thing we discussed
19:51:37 * int-e finds thinking about proper types first quite helpful
19:51:43 <Cale> do you know about adding elements to lists with (:) ?
19:52:00 <Frederick> SamB, I will update my ghc oki?
19:52:03 <Cale> and yeah, better types might help a bit
19:52:09 <SamB> Frederick: sure!
19:52:11 <Frederick> I will get 6.4.1
19:52:14 <choudesh> Cale: No, I don't.
19:52:17 <Frederick> hope it works
19:52:20 <choudesh> Cale: This is why I am so lost.
19:52:23 <SamB> Frederick: it ought to
19:52:29 <choudesh> Cale: I can write out the logic, but not the code
19:52:30 <SamB> I can at least build it from CVS, so...
19:52:41 <SamB> though the GHCi is broken in my tree right now
19:52:44 <Cale> The list [1,2,3] is actually syntax sugar for 1 : (2 : (3 : []))
19:52:54 <Cale> @type (:)
19:52:55 <lambdabot> forall a. a -> [a] -> [a]
19:53:01 <int-e> @type []
19:53:02 <lambdabot> forall a. [a]
19:53:11 <choudesh> Cale: I see.
19:53:13 <Cale> > 1 : (2 : (3 : []))
19:53:14 <lambdabot> [1,2,3]
19:53:23 <Cale> > 1 : [2,3]
19:53:25 <lambdabot> [1,2,3]
19:53:49 <Cale> you can also break down lists with (:) because it's not just a function, but a data constructor:
19:54:00 <choudesh> Cale: little help on the next function
19:54:09 <Cale> > let f [] = 0; f (x:xs) = x + f xs in f [1,2,3]
19:54:11 <lambdabot> 6
19:54:22 <Cale> can you read that?
19:54:26 <choudesh> Nope
19:54:38 <Frederick> SamB, Im emerging it, might take an ice age to build
19:54:40 <Cale> okay, then attempting this will be hard
19:54:42 <Cale> hehe
19:54:52 <choudesh> Cale: Hence why I need help.
19:54:53 <Cale> have you attended all the lectures?
19:55:04 <choudesh> Cale: Yep. All one of them on Haskell.
19:55:16 <Cale> oh, that sounds a little cruel perhaps
19:55:22 <hoopy> distcc is your friend
19:55:27 <Cale> Would you like me to point you at some resources?
19:55:36 <Cale> YAHT isn't too bad
19:55:41 <choudesh> Cale: I have the resources but I don't have time to read them at the moment.
19:55:42 <Frederick> hoopy, eager to share ticks?
19:55:52 <choudesh> Cale: This is due in a few minutes, 35 minutes.
19:55:55 <hoopy> overclock
19:56:01 <Cale> choudesh: you're going to have trouble doing it then :|
19:56:04 <hoopy> i ran gentoo at one point in time
19:56:13 <Frederick> choudesh, time is never an excuse
19:56:18 <choudesh> Cale: Hence why I wanted some code. I can learn faster from the code and see what it does
19:56:19 <hoopy> i cranked every bit of cpu power i could out of my system
19:56:21 <Frederick> hoopy, eager to share ticks?
19:56:23 <Cale> but if you want, ask me how to do the simple bits
19:56:46 <hoopy> i run OS X now
19:57:03 <Frederick> hoopy, use a crosscompiller :p
19:57:08 <Cale> and I'm more likely to answer questions like "how do I add an element to the start of a list?" then "how do I determine if a graph is acyclic?"
19:57:18 <Cale> than*
19:57:30 <Cale> :)
19:57:32 <hoopy> maybe there should be some kind of distributed compiling network
19:57:35 <hoopy> like seti at home
19:57:39 <hoopy> but for gentoo users
19:57:40 <choudesh> ok, after I know the neighbors, if I am looking to see if there is a path from 2 to 4 in [(1,2),(2,3),(3,4)]
19:58:00 <choudesh> I take the neighbors of 2, which is 3
19:58:02 <Frederick> hoopy, emerging out home
19:58:04 <Cale> yep
19:58:07 <sethk> hoopy, gentoo must be a distributed compiling network.  There isn't any other reason for anyone to use it.
19:58:10 <choudesh> then I look at the neighbors of 3 which is 4
19:58:16 <choudesh> so there is a path
19:58:20 <Cale> and then you notice that you're done
19:58:22 <Cale> right
19:59:17 <sethk> hoopy, I just started a new contract, but thankfully they let me switch from gentoo to a distribution
19:59:23 <Cale> so when you're finding a path from v to w, you check to see if the vertices v and w are equal, and if not, you look at the neighbours of v
19:59:35 * Frederick would love to have ssh to a machine with an updated ghc || a better machine
19:59:54 <hoopy> ever since i got this powerbook i've been addicted to OS X
20:00:09 <Cale> now, consider this graph: [(1,2),(2,3),(3,1),(3,4)], is there a path from 1 to 4?
20:00:23 <sethk> hoopy, I like OSX, although apple can't fix it for multiple processors so I gave up on it.
20:00:45 <hoopy> what OS do you run there sethk?
20:00:57 <Frederick> hoopy, ghc has the damm behavior of rebuilding it self on gentoo
20:01:06 <sethk> hoopy, on the g4?  At the moment it is gathering dust
20:01:34 <Frederick> SamB, you are allways around so I think I might go sleep and come back tommorow to bug you
20:01:37 <sethk> hoopy, I have to put a reasonably new version of linux on it at some point.
20:01:51 <Cale> sethk: my dual g5 seemed to work okay when I was at McMaster
20:01:58 <Frederick> 2 am here Im awake since yesterdays 6 am
20:02:09 <sethk> Cale, yes, I've talked to several people and they say the g5 doesn't show the problem.
20:02:23 <sethk> Cale, which is good to know, but I'm still annoyed about my expensive useless dual processor G4
20:02:24 <Cale> ah, so it's a g4 thing?
20:02:31 <choudesh> pathto :: Graph -> Node -> Node -> Bool
20:02:31 <choudesh> pathto graph node node2 =
20:02:31 <choudesh>    | node2 == head ( neighbours node ) == True
20:02:31 <choudesh>    | node2 /= head ( neighbours node ) = neighbours (tail ( neighbours node))
20:02:31 <Cale> what happens?
20:02:38 <choudesh> Cale: That is what I have.
20:02:40 <sethk> Cale, yes. G3 doesn't have the problem either
20:03:01 <Cale> choudesh: does it compile?
20:03:06 <SamB> Frederick: heh
20:03:13 <SamB> @localtime Frederick
20:03:13 <sethk> Cale, It crashes, more or less at random.  Behaves as if the memory has a problem.  But it isn't memory, because with only one processor it is ok
20:03:15 <lambdabot> Local time for Frederick is Fri Nov 11 02:02:56
20:03:21 <Frederick> :D
20:03:32 <sethk> @localtime sethk
20:03:33 <Cale> sethk: that's disappointing
20:03:37 <Frederick> @localtime SamB
20:03:38 <lambdabot> Local time for SamB is Thu Nov 10 23:03:19
20:03:39 <hoopy> that is dissapointing
20:03:42 <choudesh> Cale: No. :-(
20:03:46 <sethk> Cale, yes, rather.
20:03:51 <hoopy> i used to have a dual 533MHz G4, never had any problems with it
20:04:21 <sethk> hoopy, I talked to quite a few other people who have this problem.  It is only with the last, higher speed dual processor G4
20:04:24 <Cale> choudesh: right, because in that second case, pathto returns a list, whereas in the first case, it returns a Bool
20:04:32 <hoopy> 1.42GHz?
20:04:33 <sethk> hoopy, well, higher speed for apple.  I think 1.2 gig.
20:04:42 <SamB> sethk: some kind of coherence issue?
20:04:45 <choudesh> Cale: I see that.
20:04:48 <sethk> hoopy, might be 1.4.  I'm in Seattle and the machine is in NY
20:04:54 <Cale> also, you have == twice there, and I think you mean the second one to be just an =
20:05:02 <hoopy> was it a "firewire 800"?
20:05:02 <choudesh> Cale: Do I need a helper function?
20:05:08 <sethk> SamB, possibly.  Linux on the same hardware doesn't have the problem, which is pretty strong evidence that it is software.
20:05:09 <Korollary> sethk: I thought you were in NY ? Where in Seattle are you ?
20:05:09 <choudesh> Cale: Yeah, I fixed the syntax
20:05:24 <sethk> hoopy, I don't think so, but as I said I'm 2500 miles from the machine so I can't go check.  :)
20:05:29 <Cale> the important thing is to recurse :)
20:06:09 <choudesh> Cale: Little more help?
20:06:12 <Cale> choudesh: one function you might find it easier to write is the function which takes a graph and a vertex and produces the list of all vertices reachable from that vertex
20:06:38 <Cale> once you had that function, determining if there was a path would be easy: just search through that list
20:07:08 <int-e> Cale: what do you think of neighbours graph node = [w | (node, w) <- graph] ?
20:07:23 * SamB wonders why mpg321 does so badly on MPEG videos
20:07:33 <Korollary> use mplayer
20:08:03 <Cale> int-e: doesn't work
20:08:32 <Cale> int-e: node is a fresh variable in the list comprehension
20:08:35 <int-e> Cale: ah of course. it only works for constants. :/
20:08:53 <SamB> it turns out that mpg123 doesn't like ELF
20:09:27 <Frederick> @localtime Cale
20:09:29 <lambdabot> Local time for Cale is Thu Nov 10 23:08:53
20:09:34 <SamB> (accidentally ran it on the hmp3 binary)
20:09:54 <Frederick> bah ghc takes an ice age to build
20:10:01 <Korollary> yes it does
20:10:20 <Frederick> Korollary, do you have and idea of how long +-?
20:10:29 <SamB> Frederick: I thought you said you were going to sleep?
20:10:36 <SamB> Frederick: what kind of CPU do you have?
20:10:41 <SamB> how much RAM?
20:10:42 <Korollary> Frederick: on my athlon xp 1600, it was taking 8+ hours iirc
20:10:51 <Frederick> SamB, Athlon XP 2000+
20:10:54 <choudesh> Cale: I need some direction again.
20:10:57 <Frederick> 256 MB ram
20:11:01 <SamB> OMG
20:11:07 <Frederick> SamB, ?
20:11:08 <SamB> only 256 MB?
20:11:16 <choudesh> Cale: I can't figure out out to recursivly do this
20:11:22 <sethk> only 256 MB?
20:11:24 <sethk> only?
20:11:33 <Frederick> SamB, "only"? if you want I can give you a mail box and you can mil me some ram
20:11:47 <sethk> I was reading a spec today for an Intel chip set, and it said the _minimum_ supported ram is 128 MB
20:11:51 <sethk> amazing.
20:11:54 <SamB> thats how much *I* have, and it isn't enough!
20:11:56 <Korollary> sethk: I thought you were in NY ? Where in Seattle are you ?
20:12:16 <SamB> and I only have a PII 450
20:12:27 <sethk> Korollary, on a trip.  I just started a new contract for a company out here.
20:12:28 * Frederick wants to buy an Athlonx 64
20:12:37 <sethk> Korollary, I'm two blocks from the needle at the moment.
20:12:54 <SamB> Frederick: well, it might take forever to build the .a files, but it shouldn't take TOOO long...
20:13:00 <choudesh> > head [1,2]
20:13:01 <lambdabot> 1
20:13:03 <wchogg> Is there an efficient way to change just one element of a list?  It seems like putting together the pieces using ++ would be slow.
20:13:06 <choudesh> > head [1]
20:13:07 <Korollary> sethk: cool. good luck. I am by the museum.
20:13:07 <lambdabot> 1
20:13:09 <choudesh> > head []
20:13:10 <Frederick> SamB, forever :p
20:13:10 <lambdabot> Add a type signature
20:13:18 <sethk> Korollary, you live in Seattle?
20:13:20 <SamB> wchogg: yes, it would
20:13:25 <Korollary> sethk: I moved a month ago
20:13:30 <SamB> wchogg: which element do you want to change?
20:13:40 <Frederick> SamB, I will sleep
20:13:44 <wchogg> An arbitrary element that could be in the middle of the list.
20:13:50 <Frederick> better be rested tommorow and keep doing it
20:13:55 <sethk> Korollary, lots of rain.  The last few days have been better.
20:13:58 <Cale> > head [] :: Int
20:13:59 <lambdabot> Prelude.head: empty list
20:14:06 <Frederick> will you guys be around? (Kinda bumd question since I believe the answer is yes)
20:14:14 <Korollary> sethk: damn right. I moved from california heh.
20:14:17 <choudesh> Cale: I need to add a base case.
20:14:19 <SamB> someone will, don't worry!
20:14:25 <choudesh> Cale: Point me?
20:14:32 <int-e> gcd a b | a==0      = b
20:14:32 <int-e>         | otherwise = gcd (b`mod`a) a
20:14:41 <int-e> choudesh: for your inspiration
20:14:54 <Frederick> guys thx a lot for all tips of today patience and disposition
20:15:02 <SamB> with 169 users from all over the world, you should be covered ;-)
20:15:08 <SamB> well, thats with dupes and bots
20:15:09 <Cale> choudesh: well, your base cases are: either you've already visited all the neighbours, or you're at the vertex you were trying to reach
20:15:32 <choudesh> so, length ( neighbors graph node) == 0 = False
20:15:33 <SamB> and there are at least 3 bots
20:15:39 <int-e> @eval any []
20:15:40 <lambdabot>   Expecting a function type, but found `[a]'
20:15:40 <lambdabot>   Expected type: a -> Bool
20:15:40 <lambdabot>   Inferred type: [a1]
20:15:51 <Cale> choudesh: you really need to keep track of where you've been
20:15:53 <Frederick> SamB, the bots arent great help for me by now
20:15:54 <int-e> @eval any (const True) []
20:15:55 <lambdabot> False
20:16:01 <SamB> Frederick: well, yeah
20:16:04 <SamB> I realise.
20:16:18 <SamB> but have no way to calculate the number of real people here ;-)
20:16:19 <Cale> choudesh: or else you'll quite possibly wander around in the graph in circles
20:16:36 <Frederick> SamB, but the algorithms I need to implement once this structure is done are quite simple
20:16:49 <JohnMeacham> How does yhc handle arbitrary foreign C calls?
20:16:51 <SamB> Frederick: yes, they are!
20:17:03 <Korollary> JohnMeacham: what is yhc anyway ?
20:17:04 <Frederick> they are like 5 our 6 algorithms with at most 6 lines each of them and I know them
20:17:15 <Frederick> Im only having some problems with the structures
20:17:45 <Korollary> JohnMeacham: oh I just saw the announcement
20:17:50 <SamB> Frederick: in Haskell programming, that is the main trouble.
20:17:58 <SamB> which is nice!
20:18:19 <choudesh> pathto :: Graph -> Node -> Node -> Bool
20:18:19 <choudesh> pathto graph node node2
20:18:19 <choudesh>    | length ( neighbours graph node) == 0 = False
20:18:19 <choudesh>    | node2 == head ( neighbours graph node ) = True
20:18:19 <choudesh>    | otherwise = pathto graph (head(neighbours graph node)) node2
20:19:10 <Cale> the second case...
20:19:13 <Frederick> SamB, yeah and my dead line is in3 weeks so I think Im starting reasonably soon
20:19:15 <choudesh> ?
20:19:26 <Cale> perhaps node == node2 would be more appropriate?
20:19:34 <choudesh> ah
20:19:34 <SamB> Frederick: well, its nice that you have such a long time to do it
20:19:47 <Cale> also, you don't want to take the head of the list ever
20:19:52 <Frederick> SamB, that is not "such a long time" since I have other assigments
20:19:56 <Cale> (not explicitly)
20:20:01 <choudesh> Cale: Explain?
20:20:05 <SamB> Frederick: still, it allows you time to think
20:20:13 <Cale> well, that means you're throwing away the rest of the list
20:20:28 <Cale> what if the first route that you take is a dead end?
20:20:33 * Frederick 's to do list: air simulator for CG class, diagrams for Soft Engeneering Class
20:20:41 <choudesh> Cale: I see.
20:20:50 <SamB> air simulator?
20:20:50 <Frederick> SamB, I hope to have it done untill tuesday
20:20:52 <choudesh> Cale: Hmm...What would I need to change or is what I have useless?
20:20:53 <Cale> like in [(1,2),(2,3),(1,4),(4,5)], find your way from 1 to 5
20:20:55 <Frederick> SamB, yeah!
20:21:04 <SamB> what about air do you need to have to simulate?
20:21:10 <SamB> heat diffraction?
20:21:10 <choudesh> Cale: Yea.
20:21:15 <SamB> er, refraction?
20:21:20 <SamB> wind?
20:21:23 <Cale> you need to go down the paths and see if *any* of them leads to the end
20:21:31 <choudesh> Cale: How would I do this?
20:21:36 <int-e> @type any
20:21:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:21:41 <Frederick> SamB, nah, teacher gives us an image in bmp, we load it and generate a terrain map
20:21:56 <Frederick> than we need to fly over some checkpoints the program must load
20:22:01 <SamB> oh
20:22:27 <SamB> so a flyby demo type thing?
20:22:48 <Frederick> SamB, yup
20:22:54 <Cale> btw, instead of length xs == 0, write null xs
20:23:00 <sethk> Frederick, nothing personal, but I hope you are flying far away from me.  :)
20:23:03 <Cale> length xs == 0 takes O(n) time
20:23:11 <Cale> null xs takes constant time
20:23:12 <Frederick> sethk, Im an expert pilot
20:23:24 <sethk> Frederick, ok, I guess....  :)
20:23:30 <SamB> sethk: do you live near any heightfields?
20:23:37 <Cale> > length [1..] == 0
20:23:37 <int-e> choudesh: And actually you'll be able to remove that base case, because you get it for free once you use 'any'.
20:23:38 <Frederick> sethk, Ive played flight simulator so I think if you borrow me a jumbo I can take over
20:23:42 <lambdabot> Terminated
20:23:48 <Korollary> oops
20:23:49 <Cale> > null [1..]
20:23:50 <lambdabot> False
20:23:51 <choudesh> int-e: Need a little explaination
20:23:56 <Frederick> and as everybody knows landing is a matter of time
20:24:01 <choudesh> pathto :: Graph -> Node -> Node -> Bool
20:24:01 <choudesh> pathto graph node node2
20:24:01 <choudesh>    | node == node2 = True
20:24:01 <choudesh>    | length ( neighbours graph node) == 0 = False
20:24:01 <choudesh>    | node2 == head ( neighbours graph node ) = True
20:24:01 <sethk> SamB, I live about a mile from the (former) world trade center
20:24:02 <choudesh>    | otherwise = pathto graph (head(neighbours graph node)) node2
20:24:04 <int-e> > any odd []
20:24:05 <choudesh> This what what I have now.
20:24:05 <lambdabot> False
20:24:08 <sethk> SamB, although I'm not in NY at the moment
20:24:10 <int-e> > any odd [2,3,4]
20:24:11 <lambdabot> True
20:24:27 <choudesh> int-e: I see the syntax, but how will this help?
20:24:32 <SamB> sethk: well, he said he was flying over a terrain map, which I can only assume is a kind of hight field
20:24:49 <Frederick> SamB, yup
20:25:12 <SamB> sethk: so unless there are any of those near new york city, you should be fine
20:25:12 <int-e> choudesh: you want to test if there's a path from *any* of the *neighbours* to node2.
20:25:17 <Cale> well, choudesh, you have a perfectly good function to determine if a vertex leads to the end -- the one you're writing. So you want to see if any of the neighbours lead to the end
20:25:20 <choudesh> any int [2,3,4]
20:25:28 <sethk> SamB, I do orbit calculations for satellites, but they are high enough to not worry about terrain.  :)
20:25:29 <choudesh> > any int [2,3,4]
20:25:29 <lambdabot>  Not in scope: `int'
20:25:34 <choudesh> > any Int [2,3,4]
20:25:34 <lambdabot>  Not in scope: data constructor `Int'
20:25:40 <choudesh> > any [2,3,4] :: Int
20:25:41 <lambdabot>   Expecting a function type, but found `Int'
20:25:41 <lambdabot>   Expected type: Int
20:25:41 <lambdabot>   Inferred type: [a] -> Bool
20:25:52 <SamB> sethk: yeah, you'd have to be pretty suborbital to be worried about the terrain
20:25:56 <Cale> @type [2,3,4]
20:25:57 <lambdabot> forall a. (Num a) => [a]
20:26:00 <Frederick> SamB, it is a terrain map from NJ I think
20:26:05 <Cale> @type [2,3,4] :: [Int]
20:26:06 <lambdabot> [Int] :: [Int]
20:26:08 <Frederick> I must take off and land from alcatraz
20:26:12 <choudesh> otherwise = pathto graph (head(neighbours graph node)) node2
20:26:21 <choudesh> otherwise = pathto graph (any(neighbours graph node)) node2 ??
20:26:27 <SamB> Frederick: does it have to actually fly like an airplane?
20:26:33 <Frederick> SamB, sure
20:26:38 <Cale> otherwise = any ...
20:27:05 <choudesh> Cale: Little more?
20:27:07 <SamB> and this is CG class, not some kind of AI+physics/game design class??
20:27:21 <Cale> otherwise = any <some predicate> <some list>
20:27:35 * int-e wonders
20:27:38 <sethk> SamB, well, these are LEOs
20:27:40 <Frederick> SamB, nope
20:27:48 <choudesh> I see the syntax, but I can't seem to fix the pieces together
20:27:50 <Frederick> SamB, simple opengl class
20:27:52 <int-e> choudesh: can you read   \x -> x   ?
20:28:18 <choudesh> int-e: no
20:28:23 * choudesh feels dumb
20:28:32 * choudesh wants to cry
20:28:36 <Cale> > (\x -> x + 1) 5
20:28:37 <lambdabot> 6
20:28:44 <sethk> choudesh, might be easier to post what you've got on a postbot if you can't spot the problem with it.
20:28:46 <Cale> > (\x -> x + x) 5
20:28:47 <lambdabot> 10
20:28:54 <Cale> sethk: he did
20:29:03 <SamB> choudesh: (\x -> x) doesn't do a thing!
20:29:17 <Cale> > (\x -> x) 5
20:29:18 <lambdabot> 5
20:29:31 <SamB> > id 5
20:29:33 <lambdabot> 5
20:29:46 <SamB> > $ 5
20:29:46 <lambdabot>  parse error on input `$'
20:29:53 <Cale>  \ is supposed to look a bit like a lambda -- this is Haskell's way to denote anonymous functions
20:30:00 <int-e> this may be a little hard to do without lambda abstraction (which is denoted by  \<var> -> in Haskell)
20:30:01 <SamB> > ($) 5
20:30:02 <lambdabot>  add an instance declaration for (Num (a -> b))
20:30:17 <choudesh> Cale: I don't see where I use the any though.
20:30:29 <sethk> Cale, oh, sorry. I missed it.
20:30:37 <Cale> choudesh: well, what is it that you want the algorithm to do?
20:30:50 <choudesh> otherwise = pathto graph ((\x->x)(neighbours graph node))) node2 ??
20:31:11 <choudesh> Cale: Yes
20:31:24 <Cale> (\x -> x) is the identity function, it's not useful here -- he was showing it as an example of using a lambda
20:31:39 <choudesh> ah
20:31:51 <sethk> choudesh, if the lambda is confusing you, code it without using one
20:31:55 <choudesh> ok, neighbours returns a list so
20:32:04 <sethk> choudesh, you can always define a function and use it instead of using an anonymous one
20:32:16 <choudesh> any [num] (neighbours graph node)
20:32:27 <Cale> other way
20:32:32 <choudesh> ?
20:32:40 <Cale> @type any
20:32:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:32:48 <int-e> [num] ?!
20:32:49 <Cale> predicate, then list
20:32:50 * SamB hates when he does  that
20:32:59 <int-e> Cale: the list was correct though
20:33:13 <SamB> somebody write a decent IRC client sometime!
20:33:17 <choudesh> Cale: Not seeing it
20:33:20 <int-e> Cale: I don't know if that was an accident.
20:33:45 <Cale> hm?
20:33:54 <SamB> X-chat is a pain. I keep closing the #haskell tab by accident.
20:34:04 <choudesh> Cale: I believe int-e was making fun of my Haskell skills
20:34:04 <Cale> SamB: why is that?
20:34:35 <int-e> choudesh: what do you mean by [num] ?!
20:34:49 <choudesh> > any 5 [1,2,3]
20:34:50 <lambdabot>  add an instance declaration for (Num (a -> Bool))
20:35:06 <Cale> > any even [1,2,3]
20:35:07 <lambdabot> True
20:35:08 <SamB> Cale: it seems to have key bindings that aren't unbindable!
20:35:24 <choudesh>  > any `elem` [1,2,3]
20:35:28 <SamB> such C-w, apparantly
20:35:34 <SamB> s/such/such as/
20:35:40 <choudesh>  > any elem [1,2,3]
20:35:48 <choudesh> > any elem [1,2,3]
20:35:49 <lambdabot>   Expecting a function type, but found `Bool'
20:35:49 <lambdabot>   Expected type: a -> Bool
20:35:49 <lambdabot>   Inferred type: a -> [a] -> Bool
20:35:51 <Cale> > any (elem [2,4,6]) [1,2,3]
20:35:52 <lambdabot>  add an instance declaration for (Num [[a]])
20:35:52 <lambdabot>   In the list element: 3
20:36:14 <choudesh> Cale: I am lost and getting more confused
20:36:17 <int-e> choudesh: the first argument has to be a function. In your case a function of type Int -> Bool (because you're dealing with a list of Ints).
20:36:35 <SamB> > any (`elem` [2,4,6]) [1,2,3]
20:36:36 <lambdabot> True
20:36:43 <Cale> ah, right
20:37:11 <Cale> elem :: (Eq a) => a -> [a] -> Bool
20:37:31 <SamB> choudesh: do you know about sectioning?
20:37:40 <choudesh> int-e: So, any pathto (neighbours node2)?
20:37:55 <Cale> that's closer
20:38:06 <Cale> conceptually, that's what you want to do
20:38:33 <Cale> (modulo keeping track of where you've visited, and types/syntax)
20:38:53 <choudesh> Cale: serious, I am getting a bit fustrated.
20:38:58 <choudesh> Syntax please?
20:39:18 <choudesh>  otherwise = pathto graph (head(neighbours graph node)) node2
20:39:49 <choudesh> otherwise = any (pathto graph) (neighbours graph node) node2?
20:40:06 <choudesh> wait...
20:40:20 <choudesh> nope, not seeing it
20:40:29 <SamB> choudesh: your syntax is fine
20:40:32 <Cale> any (\u -> pathto graph u node2) (neighbours graph node) -- but this is still not quite right
20:40:46 <SamB> choudesh: however, if your graph is cyclic, that won't terminate
20:41:39 <int-e> SamB: it might
20:42:05 <SamB> well, okay, so it might
20:42:10 <SamB> it might not, though.
20:42:40 <choudesh> Cale: Why do you mean but not quite right?
20:42:47 <choudesh> Cale: with that code I get a seg fault in hugs
20:43:01 <Cale> after a long wait?
20:43:05 <choudesh> yes
20:43:05 <SamB> like, say the graph was [(1,2), (2,1), (1, 3)]
20:43:20 <SamB> choudesh: segfault?
20:43:25 <choudesh> I am using [(1,2),(2,3),(3,1),(3,4)] find is there is a path from 1 to 4
20:43:34 <SamB> tsk tsk!
20:43:39 <int-e> SamB: say the graph was [(1,1)] and you try to find a path from 1 to 2 :)
20:44:01 <SamB> int-e: well that is about minimal
20:44:21 <int-e> choudesh: you have a function in your original paste that can help here.
20:44:45 <Cale> ah, right :)
20:44:49 <choudesh> my indegree?
20:44:56 <SamB> anyway, the point is you keep going 1, 2, 3, 1, 2, 3...
20:45:08 <Cale> and never find 4
20:46:24 <SamB> so, if you, say, kept a list of nodes you had visited already, you could go
20:46:34 <choudesh> Why do I get a seg fault on pathto [(1,2),(2,3),(3,1),(3,4)] 1 4
20:47:07 <SamB> (1, []), (2, [1]), (3, [2, 1]), (4, [3, 2, 1])
20:47:13 <SamB> choudesh: stack overflow
20:47:32 <choudesh> so, there is nothing _wrong_?
20:47:43 <Cale> choudesh: no, there is something very wrong
20:47:49 <choudesh> Cale: Explain.
20:47:49 <Cale> you're in an infinite loop
20:47:56 <choudesh> Ok.
20:47:57 <Cale> you start out looking from 1
20:47:59 <choudesh> Why though
20:47:59 <int-e> choudesh: the function is partially correct; if it terminates, it produces the correct result.
20:48:00 <choudesh> tes
20:48:02 <Cale> you hop to 2
20:48:05 <choudesh> yes
20:48:06 <Cale> then to 3
20:48:08 <Cale> then back to 1
20:48:17 <Cale> and continue forever like that
20:49:02 <choudesh> ah, I see.
20:49:22 <SamB> and HUGS keeps track of the computations demanding the values it is attempting to calculate, and it keeps track of these in memory... eventually it runs out of space to keep track, and so you get a segfault...
20:49:24 <Cale> because you don't get rid of the possibility of returning to an already visited node
20:49:48 <choudesh> Cale: So I detach that node?
20:49:52 <Cale> yeah
20:49:54 <int-e> bingo
20:50:05 <choudesh> but how?
20:50:14 <Cale> you already have a function which does that
20:50:23 <SamB> detach :: Node -> Graph -> Graph
20:50:26 <choudesh> Yes, I know that
20:50:33 <choudesh> But where do I put this in pathto?
20:50:41 <Cale> so when you recurse, recurse on that graph
20:50:53 <choudesh> ?
20:50:56 <SamB> choudesh: you apply it to the graph
20:51:15 <choudesh> so I detach ever node I've been to in the graph.
20:52:13 <choudesh> once again I am lost on WHERE this all goes
20:52:17 <SamB> choudesh: yes, but only for the recursive call
20:52:33 <choudesh> pathto :: Graph -> Node -> Node -> Bool
20:52:33 <choudesh> pathto graph node node2
20:52:33 <choudesh>    | indegree node2 graph  == 0 = False
20:52:33 <choudesh>    | outdegree node graph == 0 = False
20:52:33 <choudesh>    | node == node2 = True
20:52:33 <choudesh>    | length ( neighbours graph node) == 0 = False
20:52:35 <choudesh>    | node2 == head ( neighbours graph node ) = True
20:52:37 <choudesh>    | otherwise = any (\u -> pathto graph u node2) (neighbours graph node)
20:53:13 <SamB> choudesh: aren't you supposed to find a Path?
20:53:19 <SamB> no?
20:53:21 <dons> SamB, regarding interfaces getting messed up, that's ok. it's known.
20:53:25 <Cale> you only need the 3rd and last cases
20:53:25 <choudesh> SamB: No, just is there a path
20:53:34 <dons> errors are just dumped to the screen atm,  not pretty printed. which confuses ncurses
20:53:35 <choudesh> Cale: which are?
20:53:48 <int-e> choudesh: the 3rd and the last.
20:53:50 <SamB> dons: it works nicely when I run it on good files only ;-)
20:53:54 <Cale>    | node == node2 = True
20:54:17 <Cale>    | otherwise = any (\u -> pathto graph u node2) (neighbours graph node) -- fix this one so it uses detach
20:54:17 <dons> SamB, yep. and so it should!  (but maybe i'll add some error handling, eh?)
20:54:25 <SamB> although I'm wondering why you don't seem to highlight the playing song in the playlist at all
20:54:35 <dons> that's coming in a patch later today..
20:54:48 <dons> remember: new, hot backed code, with ingredients still missing..
20:54:52 <dons> bakede
20:54:54 <SamB> even a * at the end of the line would be nice
20:54:55 <dons> s/.$//
20:55:18 <dons> oh, i've written the highlighting code, just needs to pass the type checker..
20:55:29 <SamB> hehe
20:55:37 <dons> i'm trying to do a mutt-style threading of directories, ultimately
20:55:42 <dons> so you say: hmp3 d/
20:55:44 <choudesh> Cale: Where would my detach go?
20:55:47 <dons> and it draws a nice tree
20:55:52 <SamB> well, I look forward to seeing it tomarrow
20:55:56 <dons> :)
20:56:10 <Cale> you want to detach the node from the graph you pass into the recursive call
20:56:46 <Cale> because you don't want to return to the current node ever again
20:56:58 <Cale> so just removing it from the graph will work
20:57:02 <SamB> dons: what I'm wondering is why pressing ^L doesn't eradicate the error messages
20:57:13 <SamB> it does in most things
20:57:22 <SamB> is that not a feature of curses?
20:57:28 <dons> probably SIGWINCH is not getting caught for some reason
20:57:31 <dons> i'll fix it.
20:57:43 <SamB> or do you do something that prevents it?
20:58:14 <sethk> I was going to eat a SIGWINCH for lunch but I thought better of it.
20:58:27 <choudesh> otherwise = any (\u -> pathto graph u node2) (neighbours graph node)
20:58:28 <SamB> is it possible that something prevents it from being sent?
20:59:11 <choudesh>  | otherwise = any (\u -> pathto (detach u graph) u node2) (neighbours graph node)
20:59:27 <Cale> not quite
20:59:35 <choudesh> ?
20:59:43 <SamB> where graph' = detach node graph?
20:59:49 <Cale> think about how that would run
20:59:52 <int-e> oops. that's a possibility I had not thought of.
21:00:30 <SamB> dons: also, it doesn't seem to display more than the first screenful of playlist ;-)
21:00:43 <Cale> you'll step to u, in a version of the graph where u doesn't exist anymore
21:00:45 <int-e> well at least this version will terminate quickly :-P
21:01:03 <Cale> (and so it doesn't have any neighbours)
21:01:22 <Cale> and the algorithm will stop
21:01:34 <Cale> so that's not quite what you want
21:01:44 <choudesh>  otherwise = any (\u -> pathto graph u node2) (neighbours (detach node2 graph) node)
21:02:02 <sethk> Does anyone know this?  With the rpm for fedora fc4 and 6.4.1, I need to install an rpm with an earlier version of readline.  What about tarball?  Does it have that issue?
21:02:08 <SamB> choudesh: isn't node2 the node you are looking for?
21:02:13 <choudesh> damn...
21:02:14 <choudesh> argh.
21:02:18 <int-e> ok. I expected this version.
21:02:24 <SamB> choudesh: are you a combinatorial algorithm?
21:02:37 <Cale> hehe
21:02:43 <choudesh> bruteforce. :-D
21:02:47 <int-e> hmm. genetic programming
21:03:16 <int-e> this would probably work now if you had a set of good testcases ...
21:03:29 <choudesh> Ok, all. Where does my detach go?
21:03:35 <SamB> dons: for a program you were looking for the other day, this is pretty good ;-)
21:03:55 <SamB> it certainly doesn't seem to crash
21:03:56 <Cale> choudesh: you want to remove the *current* node from the graph
21:04:05 <SamB> except when it isn't compiled right
21:04:13 <Cale> before recursing
21:04:23 <choudesh> which is u
21:04:27 <Cale> no
21:04:33 <Cale> u is the node you're moving to
21:04:34 <SamB> not even if I run it on itself!
21:04:46 <int-e> u is a neighbour
21:04:48 <SamB> though it sounds awful
21:04:52 <choudesh> so what is my current?
21:05:01 <Cale> well, node
21:05:20 <Cale> no?
21:05:24 <choudesh> yes
21:05:44 <SamB> dons: and nothing plays if I try to play the sourcecode
21:05:47 <choudesh> but _where_ do I detach my node?
21:05:52 <SamB> okay, for real this time, to bed!
21:05:56 <Cale> before the recursive call
21:06:03 <choudesh> SamB: g'night. thanks for your help
21:06:14 <SamB> you are welcome ;-)
21:06:16 <Cale> SamB: night
21:06:25 <SamB> I wish you success, and I think you will find it too ;-)
21:07:01 * int-e wonders if `or [pathto graph u node2 | u <- neighbours graph node]' is easier to understand for choudesh.
21:07:17 <int-e> @type or
21:07:18 <lambdabot> [Bool] -> Bool
21:07:25 * choudesh tells int-e, "Not really"
21:07:56 <choudesh>  | otherwise = any (\u -> pathto graph u node2) (neighbours graph node)
21:08:30 <choudesh>  | otherwise = any (\u -> pathto (detach node graph) u node2) (neighbours graph node)
21:08:42 <int-e> (it's the same calculation as the any (...) (...) thingy)
21:09:37 <Cale> choudesh: try that last one and see if it works
21:10:12 <choudesh> seg fault again
21:10:15 * choudesh sigh
21:11:02 <sethk> in case anyone was wondering  ( :)  ) you do need the readline library with the tarball for linux 86.
21:11:21 <Cale> choudesh: really?
21:11:24 <choudesh> what am I missing.
21:11:25 <choudesh> yea
21:11:36 <choudesh> Main>  pathto [(1,2),(2,3),(3,1),(3,4)] 1 4
21:11:36 <choudesh> Segmentation fault
21:11:38 <Cale> can I see the rest of your code? Paste the whole file somewhere
21:11:44 <sethk> it is interesting that it seg faults.
21:11:55 <sethk> choudesh, whatever it does, it shouldn't do that.  :)
21:12:12 * int-e thinks
21:12:16 <Cale> that's hugs though, I don't know how it responds to certain bad things
21:12:22 <int-e> save file, reload it in hugs?
21:12:33 <choudesh> hmm, now it seems to work
21:12:36 <sethk> Cale, ok.
21:12:39 <Cale> okay, good :)
21:12:45 <choudesh> omg, AM I DONE!?!?
21:12:52 <Cale> well, yeah
21:13:03 <Cale> might be good to prove that you're done :)
21:13:06 <Cale> hehe
21:13:08 <int-e> not really, you should take some time to understand that code.
21:13:14 <int-e> but the code is done.
21:13:18 * choudesh kisses Cales's, sethks's, int-e's, and #Haskell's feet.
21:13:46 <Frederick> bah Cale I give you an e-kiss if you do my homeword :p
21:13:50 <choudesh> Thanks boys
21:14:03 <choudesh> Now I need to spend a few hours rewritting this and trying to list the path
21:14:15 <sethk> hey, I didn't even give a single correct answer.  :)
21:15:04 <choudesh> lol, anyhow, you guys give a great name to the IRC Dev Cycle. ;-)
21:15:56 <Frederick> choudesh, we are all on the same boat I would say
21:17:18 <sethk> Cale, all my monad problems are gone.  Well, not gone, really, but understood.  I have to figure out how to handle the fact that I have both global state and thread specific state.
21:17:43 <Cale> :)
21:17:51 <int-e> choudesh: for example, why is pathto [(a,b) | a<-[1..12], b<-[1..12]] 1 13 so slow?
21:18:07 <sethk> Cale, but that's a good problem, that is, a design problem, not a what is this #@#$ language doing problem.  :)
21:18:14 <Cale> yeah
21:29:43 <vincenz> Anyone use cygwin?
21:31:30 <Korollary> I do
21:32:01 <vincenz> you have a better replacmenet for the dos window?
21:32:04 <vincenz> that eases copy pasting
21:32:13 <Korollary> I use rxvt
21:32:20 <vincenz> what is it?
21:32:34 <vincenz> I love the putty mouse interface
21:32:57 <Korollary> it's an xterm clone. It runs both under x and using native Win32 windowing.
21:33:07 <vincenz> thanks
21:33:12 <vincenz> how's the copy paste interface?
21:33:21 <vincenz> the dos prompt is HORRIBLE..
21:33:32 <vincenz> right click....select edit...select paste
21:33:36 <Korollary> marking copies. You can paste using middle mouse or with pressing both left and right.
21:33:46 <vincenz> nice
21:33:51 <vincenz> is it resource heavy?
21:33:55 <Korollary> no
21:33:56 <vincenz> I know some terminals have issues on windows due to fonts
21:34:00 <vincenz> (like when running xmanager)
21:34:08 <Korollary> this one can use windows' own ttf fonts
21:34:12 <Korollary> in native windows mode
21:34:29 <Korollary> under x, it uses X's fonts
21:34:42 <vincenz> and under cygwin?
21:34:49 <vincenz> I don't want to install x under cygwiin
21:35:04 <Korollary> you dont need X. It can "also" run under cygwin/x.
21:35:22 <vincenz> but you need x under cygwin
21:35:37 <Korollary> I don't understand what you are asking.
21:36:04 <vincenz> well... if you're running it under cywgin...you're running under a fake linux, not windows
21:36:08 <vincenz> so you'd need x in cygwiin
21:36:14 <vincenz> btw, how do you make it for windows?
21:36:30 <Korollary> ok, here's the deal
21:36:35 <sebell> vincenz: Cygwin is a compatibility library, and apps that link against it do not necessarily require X Windows
21:36:55 <sebell> vincenz: This is not emulation here
21:36:57 <vincenz> yeah but I figured it was a complete interface
21:37:05 <vincenz> not emlation but linking wise
21:37:08 <Korollary> you start rxvt. It's a cygwin binary. If it detects X, it launches an X window. If it doesn't, then it launches a win32 window.
21:37:16 <vincenz> ah nice :)
21:37:24 <vincenz> how do you build a  native windows version?
21:37:29 <Korollary> it's already built
21:37:35 <Korollary> the same binary does both
21:37:35 <vincenz> euhm
21:37:45 <vincenz> no...the binary would require cygwin.dll
21:37:50 <Korollary> it does
21:37:56 <vincenz> and the version on sourceforge is source
21:38:40 <Korollary> it's a cygwin binary, so it does require cygwin.dll. It just doesn't require X to be running.
21:40:01 <vincenz> oki
21:40:10 <vincenz> how about a fully native version?
21:40:16 <vincenz> cause I don'tw ant to launch cygwin in a dos prompt
21:40:19 <vincenz> just to start x
21:40:20 <vincenz> I mean
21:40:21 <vincenz> rxvt
21:43:12 <Korollary> rxvt does not run in the dos prompt. It launches a win32 window if X is not running.
21:44:55 <vincenz> k
21:46:34 <vincenz> wasn't thinking
21:55:42 <vincenz> how do you setup the colors and font of rxvt?
21:58:37 <Korollary> it has commandline options
21:59:25 <Korollary> I use "c:\cygwin\bin\rxvt.exe -fn "Lucida Console-14" -sl 10000 -bg olivedrab4 -fg white -tn rxvt-cygwin-native -e /usr/bin/bash -l"
21:59:52 <Korollary> -bg and -fg. They are defined as X colors.
21:59:58 <vincenz> thans
22:00:05 <vincenz> -l is?
22:00:09 <vincenz> and the -tn?
22:00:19 <Korollary> -l is an option to bash
22:00:38 <vincenz> ah ok
22:00:58 <Korollary> tn sets TERMCAP or something
22:02:11 <vincenz> th
22:02:14 <vincenz> sorry for all the questiions
22:02:36 <vincenz> hmm
22:02:40 <vincenz> seems not to like the font
22:04:16 <vincenz> nm
22:04:20 <vincenz> seems to work
22:04:23 <vincenz> just have to choose em bigger
22:04:27 <vincenz> some reason it makes 14 rather samll
22:25:47 <sethk> Korollary, still here?
22:28:03 <Korollary> Yessah
22:28:28 <sethk> Korollary, did you move here for a job?
22:28:30 <Korollary> cygwin now comes with ocaml gui bindings
22:28:39 <Korollary> sethk: Yes
22:28:57 <sethk> Korollary, how do you like it, so far?  The place, the job, etc.?
22:29:48 <Korollary> sethk: Well, I lived in the suburbs in CA, so smack in the middle of downtown is different for me. But I am ok with it so far.
22:30:11 <Korollary> sethk: The job is just picking up. I am still going through the learning curve.
22:30:21 <sethk> Korollary, I would have the opposite problem, sort of.  I live in Manhattan, so smack in the middle of downtown doesn't feel very downtown to me.  :)
22:30:39 <sethk> Korollary, it's always hard to tell about a new job for a while
22:31:06 <Korollary> sethk: I would be afraid to live in Manhattan
22:31:21 <sethk> Korollary, why?  Safer than Seattle, actually.
22:31:41 <Korollary> sethk: nah, I was going to make fun of the wall street sharks, etc.
22:32:37 <sethk> Korollary, I'm asking because I have this contract and they are asking me to consider hiring on permanently
22:32:42 <sethk> Korollary, which would mean moving, of course
22:32:53 <Korollary> sethk: I see. Yes, tricky question.
22:33:07 <sethk> Korollary, is the job you took very enticing?
22:33:25 <Korollary> sethk: Yes, it's much better than my previous job and the other offer.
22:34:12 <sethk> Korollary, better as in more interesting?
22:34:21 <Korollary> sethk: More interesting and with better people.
22:35:16 <sethk> Korollary, the people are very important.  I've only been here a week, but the people seem to be better than most jobs I've had in the past few years.
22:35:39 <Korollary> sethk: Do you mean technically or personally ?
22:35:52 <sethk> Korollary, both, actually
22:36:34 <Korollary> sethk: Well, I am not sure if it is specific to the area, but there is M$ here and a lot of ex-M$'ers, expedia, boeing, amazon, etc.
22:36:49 <sethk> Korollary, yes, well that can push both ways.
22:37:05 <sethk> Korollary, a lot of M$ people have never considered the fact that there are other ways of doing things.
22:37:32 <sethk> Korollary, as in "what's wrong with visual basic?"   :)
22:37:36 <Korollary> sethk: They still don't. But there's a lot of them. So the ones who quit are doing just fine outside.
22:38:02 <sethk> Korollary, I know, it's a stereotype and of course it isn't really true
22:38:12 <sethk> Korollary, but there is some truth to it.
22:38:31 <Korollary> sethk: It's partly true. They have a very isolated culture and they know it too. I interviewed for them, and it was exactly like I feared.
22:38:57 <sethk> Korollary, it can be fun to ask them why Microsoft is putting money into Haskell.  :)
22:39:12 <Korollary> sethk: not many know about it.
22:40:05 <sethk> Korollary, well, since their "official" position is that M$ has everything you need and only a fool would use anything else...
22:40:09 <Korollary> sethk: I think MS research is pretty independent. If I wasn't into haskell, I couldn't imagine freebsd licensed code coming out of MS-anything.
22:40:27 <sethk> Korollary, so they don't spread the word about other things they are interested in at the research level
22:41:03 <Korollary> sethk: MS research still contributes to the cause as well, as in F# and visual haskell, etc.
22:41:23 <sethk> Korollary, oh, yes, definitely, it just isn't well known.
22:41:48 <sethk> Korollary, one advantage here.  The admins where I am working are so petrified of UNIX that they let me do my own administration.  :)
22:42:04 <Korollary> sethk: I think MS is going to drop the bomb in a year or two when F# becomes an official VS product.
22:42:32 <sethk> Korollary, that soon, you think?  That would be interesting, definitely.
22:43:14 <Korollary> sethk: I haven't used it, but from what I read it's very well integrated with the CLR already. I don't see why not.
22:43:57 <sethk> Korollary, technically no reason, but their marketting people may have different ideas.  Not that I would know; I'm just speculating.
22:44:45 <sethk> Korollary, are you working downtown?
22:45:16 <Korollary> sethk: Yes. Do you know the Pac Med building ?
22:45:53 <sethk> Korollary, no.  So far I only know where I'm working and where I'm sleeping.  :)  I'm working at 5th and Jackson, near the stadiums
22:46:04 <Korollary> sethk: hah, union station.
22:46:33 <Korollary> sethk: I walk to jackson every morning to take the shuttle to Pac Med.
22:49:35 <sethk> Korollary, if you feel like it we could probably find each other.  I'm at seth.kurtzberg@watchguard.com
22:49:45 <sethk> Korollary, this week and next, and possibly one more (although I hope not  :)   )
22:50:27 <Korollary> sethk: I'll shoot you an email. This weekend I am looking for an apartment.
22:50:38 <Korollary> sethk: I am still in temporary corporate housing.
22:50:51 <sethk> Korollary, ok.  I'm working one of the two weekend days but I don't know which yet.
22:51:08 <sethk> Korollary, the guy who had my job before me is coming in one of the days to show me stuff.
22:51:25 <sethk> Korollary, then I can get all the gossip.  :)
22:51:44 <Korollary> sethk: are you some kinda database guru ?
22:51:55 <sethk> Korollary, well, among other things, yes.  :)
22:52:21 <Korollary> sethk: well, we have 200+ openings.
22:52:35 <sethk> Korollary, although the contract I'm working on at the moment isn't a database thing.
22:53:27 <Korollary> sethk: What is your primary expertise area ?
22:54:27 <sethk> Korollary, I've been doing this so long that it is hard to say.  I developed a database server, which is my database claim to fame.  I do ports of operating systems; the last few contracts I've had involve porting software to new embedded platforms.
22:56:40 <Korollary> sethk: 86 hits with "database" in the job description :)
22:56:57 <sethk> Korollary, yes, but not all of them will be interesting  :)
22:57:09 <Korollary> sethk: Of course not. It's the likelihood.
22:58:30 <sethk> Korollary, that's true of any other keyword, also, of course.
22:58:59 <Korollary> sethk: maybe not for "haskell"  ;)
22:59:03 <dons> @seen SamB
22:59:03 <lambdabot> SamB is in #haskell, #haskell-blah and #haskell-overflow. Last spoke 1
22:59:03 <lambdabot> hour, 52 minutes and 37 seconds ago.
22:59:12 <dons> SamB, any other remarks, comments on hmp3?
22:59:18 <dons> as my number 1 user :)
22:59:24 <dons> @localtime SamB
22:59:25 <lambdabot> Local time for SamB is Fri Nov 11 01:59:06
23:00:17 <sethk> Korollary, true, but you won't get _quite_ as many hits, unfortunately.
23:00:34 <Korollary> sethk: no hits at all the last time I hit monster, dice, careerbuilder, etc.
23:00:39 <sethk> Korollary, we'll just have to start a new company to sell my database server written in haskell.
23:00:49 <Korollary> sethk: 0 for scheme + ocaml + haskell combined, in fact.
23:01:19 <sethk> Korollary, well, obviously the market is not yet saturated.  :)
23:02:12 <Korollary> Andy Griffith ???
23:04:46 <sethk> Korollary, you lost me there.
23:04:58 <Korollary> sethk: watching the daily show.
23:05:14 <Korollary> sethk: A Griffith got a presidential medal of honor or something.
23:05:18 <dons> we used to get the Daily Show weekly in .au
23:05:26 <sethk> Korollary, that's why I never turn on my television
23:05:33 <sieni> ocaml might be nice, if there were any free implementations
23:05:58 <sieni> maybe doing a competing implementation would be a nice exercise in compiler technology
23:05:58 <Korollary> sieni: any problems with the existing license ?
23:06:38 <sieni> Korollary: not for the runtime or libraries, but the compiler (both native and byte-code) are licensed under QPL.
23:06:40 <sethk> sieni, if you are going to go to an effort of that magnitude, choose a language with different features, don't reinvent the wheel.
23:08:18 <sieni> well, that's a good point
23:10:29 <sethk> sieni, I may not be totally objective, though   :)   I'm not that fond of the o'caml syntax
23:10:49 <Korollary> sethk: ocaml syntax blows
23:11:17 <sieni> well... s-expression syntax would be optimal
23:11:29 <sethk> Korollary, that's more or less what I said.  :)
23:11:44 <Korollary> sieni: ugh. s-expressions are not that popular either.
23:12:09 <sieni> and of course one needs efficient call/cc ;-)
23:12:15 * aleator suggests postfix :)
23:12:20 <sieni> Korollary: I like them :-)
23:12:56 <sethk> sieni, at the very least, there are issues here.  :)
23:13:01 <rep> developers developers developers developers developers
23:13:26 * Korollary throws a chair at you and swears to f*&^&&& kill.
23:13:27 <aleator> sieni: Not to start an argument, but why do you like s-exprs? I mean I never got it why people like them.
23:14:58 <sieni> aleator: I don't know, maybe I have a parenthesis fetish
23:17:19 <sieni> there aren't any issues with precedence. I still get sometimes confused with C, like whether one should insert parentheses or not
23:17:39 <Korollary> It's because of C, though.
23:18:04 <sethk> sieni, I don't see the relevance of that.  You can always just be explicit, in any language, using parens
23:18:52 <aleator> sieni: Agree on that. I still parenthesise every math expression myself..
23:18:54 <sieni> sethk: yeah right, especially when trying to figure out, what somebody else has written
23:19:25 <sethk> sieni, you mean that you have difficulty figuring out what the compiler does with the expression?
23:19:39 <sethk> sieni, you don't know how it will be parsed?
23:19:51 <sethk> sieni, or you just don't like the defaults?  I'm not sure what you are driving at.
23:20:29 <Korollary> sieni: Since many people don't know the exact precedence list in C, they already over-parenthesize. Nothing to worry about.
23:20:43 <sieni> sethk: 2 of the first
23:20:53 <palomer> how do you get the precedence of an operator in haskell?
23:21:16 <Korollary> palomer: they are specified in the Report.
23:21:30 <sethk> palomer, I think :info in ghci will tell you, also
23:21:38 <palomer> can you ask hugs?
23:21:50 <Korollary> palomer: ask hugs if you can ask hugs :)
23:22:06 <palomer> ghci = interactive ghc, right?
23:22:12 <Korollary> yep
23:22:12 <Cale> yeah
23:22:21 <Korollary> @localtime Cale
23:22:22 <lambdabot> Local time for Cale is Fri Nov 11 02:21:46
23:22:29 <palomer> does anyone use hugs anymore?
23:22:35 <dons> yes. ndm!
23:22:37 <sethk> palomer, hugs may be able to tell you; I don't remember
23:22:38 <sieni> damn mack
23:22:40 <sieni> mac
23:22:43 <dons> it's a lot more portable
23:22:47 <sethk> palomer, sure, some people do.
23:22:55 <palomer> ghc is missing targets?
23:23:03 <dons> it's hard to port.
23:23:05 <Cale> Hugs.Base> :info *
23:23:05 <Cale> infixl 7 *
23:23:05 <Cale> (*) :: Num a => a -> a -> a  -- class member
23:23:05 <sieni> I wouldn't want to start kernel programming with mac os x, but soon I have to
23:23:12 <dons> it has a C backend, so targets isn't so much of an issue
23:23:45 <palomer> that's awesome you can ask the interpreter
23:23:53 <sethk> sieni, in OSX you can drop into the BSD UNIX level with zsh and have a perfectly good environment for kernel programming
23:24:00 <palomer> you don't know how many times I over parenthesized because I didn't know the precedence
23:24:45 <sethk> palomer, did you actually count?  :)
23:24:49 <sieni> this stupid wireless connection stops working except for example for existing tcp-connections
23:24:58 <palomer> count parenthesees? emacs does that for me
23:25:47 <sethk> palomer, no, I mean count how many times you over parenthesized.  :)
23:25:56 <sieni> like now I'm ircing, but can't get this machine, where I am ircing to respond to ping
23:26:07 <palomer> sethk: lots!
23:26:11 <palomer> lots is a number is lojban
23:26:23 <palomer> and I counted in lojban
23:27:39 <sethk> Korollary, DSL here is not fast.  :)
23:27:51 <Korollary> sethk: I have 3Mbps cable
23:28:56 <Korollary> anyone know any interesting podcasts ?
23:29:24 <sethk> Korollary, couldn't find a hotel with internet on a cable.  :)
23:29:37 <Korollary> sethk: ah
23:32:53 <sethk> Korollary, actually, this is my fourth hotel since I got here last week.  I never had so much trouble finding a decent place at a decent price.
23:33:03 <Korollary> wow
23:33:30 <palomer> holliday inn!
23:33:50 <sethk> palomer, do you know what the holiday inn costs in Seattle?  I nearly fainted.  :)
23:33:51 <Korollary> sethk: I stayed at "W Seattle" for the interview.
23:33:59 <palomer> Korollary: oh my.
23:34:10 <sethk> Korollary, I'm paying for the hotel.
23:34:21 <Korollary> sethk: oh come on. live a little ;)
23:34:45 <sethk> Korollary, I am living.  I'm just not paying $200 a day to live.  :)
23:34:47 <palomer> you can do like in cloudscape atlas
23:35:00 <palomer> escape through the bedroom window
23:38:16 <gaal> hello! does Parsec have a trace flag? It isn't going for a rule I thought it ought to.
23:50:34 <gaal> anyone familiar with Hat? I see it says it is intended for Haskell 98, but then it mentioned GHC. Is it worth my time to try it on pugs?
23:53:01 <sethk> pugs?
23:53:46 <Korollary> pugs is the perl6 implementation in haskell
