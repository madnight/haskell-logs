00:00:21 <mcnster> so i guess i can't declare a class A and then use "deriving A" in my code.  that sounds odd
00:00:42 <Korollary> mcnster: the standard says deriving A is valid only if A was defined in the prelude.
00:01:09 <mcnster> ahso
00:02:18 <mcnster> must have missed the fine print.  thanks.
00:02:22 <Korollary> np
00:03:06 <Korollary> it's basically a major convenience since these classes are used often, and the compiler knows about them and it can do it for you. For everything else, it's your job.
00:04:31 <mcnster> let me check an assumption:  is there such a thing as a "default method" for a class?
00:04:58 <mcnster> "default implementation of a method"
00:05:13 <Korollary> mcnster: yes
00:05:34 <Korollary> mcnster: see Eq, for example
00:06:12 <mcnster> further:  if there is a default method, then i need only say "instance A DataFoo"?
00:06:49 <Korollary> mcnster: you can define either ==, or /=. If you don't define /= for example, that one will be implemented with "not . (==)"
00:07:36 <Korollary> mcnster: no, default methods are not about instances.
00:07:54 <mcnster> oh dear
00:08:11 <mcnster> then what?
00:08:41 <Korollary> mcnster: the terminology is confusing you. it's not like base/derived methods.
00:09:49 <Korollary> mcnster: a method in a typeclass is a function for which there's an implementation for each instance.
00:10:20 <Korollary> mcnster: so, for (==) in Eq, there's a definition for Int's, Double's, Char's, etc.
00:11:28 <Korollary> mcnster: if the definition for Bool's doesn't exist, it's an error. There's no defaul, type-generic implementation we can fall to. It's missing.
00:12:45 <mcnster> so then a Default Method is then propagated to each instance as is /= in Eq?
00:14:03 <Korollary> mcnster: In the case of Eq, in the class declaration a default implementation of /= is specified in terms of ==. So for types that have (==) defined, but (/=) not defined, the compiler will automatically insert the default implementation.
00:14:36 <Korollary> mcnster: but an instance needs to implement at least the minimum implementation, which is (==).
00:16:47 <mcnster> so typically a default method is a different (and generic) way of phrasing the type-specific implementation?
00:17:52 <luqui> is there any way I can get around an "import" cycle
00:17:59 <luqui> without moving around my definitions?
00:18:24 <Korollary> mcnster: yes, you could say that.
00:19:15 <mcnster> cool
00:19:24 <Lemmih> luqui: Yes, you can write a boot file.
00:19:35 <luqui> which is...?
00:21:08 <Lemmih> luqui: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
00:21:32 <luqui> thanks
00:23:46 <mcnster> ok korollary, thanks much
00:24:05 <Korollary> mcnster: np
00:25:02 * mcnster disappears in a puff of logic
00:46:00 <soysauce> is there a simple way to do [a] -> Array b a?
00:46:25 <soysauce> Array.listArray is pretty close, but I have to do [a] -> [(b, a)]
00:46:31 <soysauce> and I'm not really sure how to do that
00:46:56 <triplah> whats a good ide to use for haskell? just started studying it today at uni
00:46:58 <soysauce> actually I suppose fold would do that...
00:47:11 <triplah> we are using ghc as an interpreter
00:47:37 <triplah> bbs
00:48:14 <luqui> soysauce, what type is b?
00:48:30 <luqui> I mean, what quantification?
00:48:32 <luqui> Ifx?
00:48:34 <luqui> er, Idx?
00:49:15 <luqui> er, Ix?  :-)
00:49:29 <soysauce> it would have to be Ix
00:49:35 <luqui> @type listArray
00:49:36 <lambdabot> Not in scope: `listArray'
00:49:41 <soysauce> @type Array.listArray
00:49:41 <luqui> @type Data.Array.listArray
00:49:42 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
00:49:42 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
00:49:53 <luqui> that doesn't look like [(i,e)] to me
00:49:55 <soysauce> I'm going to use Int, but the type really doesn't matter
00:50:08 <luqui> listArray (0, length list) list
00:50:16 <soysauce> oh, shit, I was looking at a different page in the manual
00:50:18 <soysauce> haha
00:50:20 <soysauce> thanks
00:51:19 <luqui> soysauce, listArray (0, length list - 1) list
00:51:25 <soysauce> yes, I have that already
00:51:30 <soysauce> thanks
00:51:39 <luqui> ahh, just making sure you didn't use my earlier conjecture
00:51:42 <soysauce> I was looking at the type for Array.array and thought I was looking at Array.listArray
00:51:49 <soysauce> @type Array.array
00:51:50 <lambdabot> forall e i.
00:51:50 <lambdabot> (GHC.Arr.Ix i) =>
00:51:50 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
00:52:08 <soysauce> oh well, that was a dumb mistake
00:52:19 * soysauce is implementing a binary search function
00:52:40 <luqui> oh, just do it on a list, and watch search go to O(n lg n) :-)
00:52:46 <soysauce> haha
00:53:03 <soysauce> if you do it right it's still O(n)
00:53:17 <soysauce> use List.splitAt and then select one of the two lists
00:53:17 <luqui> really, on a list?
00:53:20 <soysauce> of course
00:53:23 <luqui> oh, yeah, that works
00:53:26 <soysauce> a brute-force search is still O(n)
00:53:47 <luqui> incidentally, so is converting it to an array and doing an O(lg n) algorithm on it
00:54:04 <luqui> but I guess if you have an expensive compare, then it isn't
00:54:08 <soysauce> I *assume* splitAt is implemented "correctly" in that it takes O(1) time (depends on the point at which you want to split, *not* on the input data)
00:54:21 <soysauce> I suppose that's true
00:54:31 <soysauce> Haskell arrays annoy me :/
00:55:13 <luqui> hmmm, it probably has to copy the first half of the list
00:55:51 <luqui> eh, no worry, same time complexity
00:56:20 <Lemmih> How about using a Set or Map?
00:57:51 <soysauce> how would Set and Map help me search a list?
00:57:58 <soysauce> I'm not searching for a particular item
00:58:28 <soysauce> I have a list of possible answers to a problem and I'm doing a search
00:58:37 <soysauce> basically: find isSolvable [...]
00:58:52 <luqui> and those are sorted?
00:59:03 <soysauce> yes, I sorted them :p
00:59:13 <soysauce> the isSolvable function is very, very expensive, so the binary search is a huge win
00:59:34 <soysauce> it's like O(V*E^2) where V <= 200 and E <= 1500
00:59:45 <luqui> wowza
00:59:48 <soysauce> yeah
00:59:56 <luqui> er, how can you sort them?
00:59:58 <soysauce> better than O(2^E) though ;)
01:00:24 <luqui> you can ensure that everything before something unsolvable is also unsolvable, and vice versa?
01:00:26 <soysauce> well, it's weird, let me link you to the problem and then explain it
01:00:32 <soysauce> right, exactly
01:00:39 <luqui> huh..
01:00:45 <soysauce> hang on
01:01:23 <soysauce> http://www.cs.fit.edu/~ryan/fun/ombrophobic.html
01:01:27 <soysauce> 'tis my homework assignment
01:02:05 <soysauce> I guess it's not O(2^E), but it's really, *really* difficult to solve using the naive algorithm
01:02:20 <luqui> hmm... homework
01:02:25 * luqui thinks he should be doing that :-)
01:02:29 <soysauce> hehe
01:03:02 <soysauce> I use Floyd-Warshall's algorithm to compute distances between all nodes in the graph, and using the results I separate the graph into one or more well-connected subgraphs
01:03:32 <soysauce> since it's undirected, it's pretty easy to do, and it's O(n^2)
01:04:09 <soysauce> in this case, distance is the time to get from point A to point B
01:04:25 <soysauce> then take all possible times and use List.nub to work it into a list of all possible answers
01:04:47 <soysauce> then it's a binary search over the list
01:05:48 <soysauce> anyway, if they can't reach their destinations in time A[N], then they certainly can't reach their destinations in less time.
01:07:20 <ski> hi triplah
01:07:42 <ProfTeggy> G'day all.
01:08:07 <ski> morning #haskell
01:15:43 <boegel> hi ski 
01:15:45 <triplah> hey ski :)
01:15:59 <triplah> ski: started learning haskell today
01:16:09 <ski> ok, how do you find it, so far ?
01:16:19 <triplah> list comprehension + lazy evaluation = sexy
01:16:34 <ski> hehe
01:16:49 <triplah> just need a nifty ide
01:16:52 <triplah> i used jedit at uni
01:16:56 <triplah> it seemed ok.
01:17:41 <ski> m
01:18:07 <triplah> i guess vi has highlighting for hs files
01:28:45 <luqui> vim has highlighting for friggin everything
01:36:15 * svens_ uses emacs with haskell-mode
01:36:59 * boegel switched to (g)vim
01:48:18 <sieni> Is there a better way to generate a infinite list consisting of the same element besides map (\x -> 42) [0..]?
01:48:35 <ski> > take 10 (repeat 42)
01:48:36 <lambdabot> [42,42,42,42,42,42,42,42,42,42]
01:48:41 <sieni> ahh repeat
01:50:05 <ProfTeggy> By the way:  \x -> 42 = const 42
01:50:26 <boegel> @eval map (const 42) [0..0]
01:50:27 <lambdabot> [42]
01:50:33 <boegel> @eval map (const 42) [0..10]
01:50:34 <lambdabot> [42,42,42,42,42,42,42,42,42,42,42]
01:50:35 <boegel> sorry :)
01:51:05 <ski> replicate n = take n . repeat
01:51:31 <boegel> @eval replicate 2 42
01:51:32 <lambdabot> [42,42]
01:53:08 <ski> f =<< return a  =  f a
01:53:47 <ski> extract (f <<= wa)  =  f wa
01:53:50 <ski> hmm ..
01:53:52 <takuan> is there some place where ghc's error messages are explained?
01:56:15 * ski was about to say http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html, but he can't find errors explained there, atm ..
01:56:28 <ski> what is the error in question ?
01:57:36 <luqui> ski, extract?
01:58:01 <ski> luqui : sorry, .. i'm just rambling on comonads ..
01:58:02 <araujo> Good morning!!!
01:58:09 <ski> yes
01:58:40 <ski> (luqui : in case you wanna know, i could explain ..)
01:58:49 <luqui> noj, I remember comonads
01:59:10 <luqui> damnit, I'm going to go tell xchat not to autocomplete
01:59:38 <luqui> no, I remember comonads
01:59:40 <luqui> good :-)
02:00:06 * ski just pondered if the above forms of those laws is easier to grasp
02:00:51 <takuan> ski: solved it
02:00:55 <takuan> type ambiguity
02:01:01 <ski> k, fine
02:01:15 <ski> (type classes ?)
02:01:18 <takuan> yup
02:01:28 <takuan> implementing finite fields with Int
02:11:34 <ski> hm, which members should be in class Monad in Haskell 1.6 ?
02:12:09 <ski> join ?  (>>=) ?  (=<<) ?  extend ?
02:13:06 <ProfTeggy> What else but 'bind' and 
02:13:12 <ProfTeggy> 'return' do you need?
02:13:31 * ski is thinking more of convenience and elegance
02:13:45 <ProfTeggy> Oh.  Elegance. Yes! :-)
02:14:07 <ski> we could have multiple of these, and provide defaults
02:14:23 <ProfTeggy> What would be the def of 'extend'?
02:14:42 <ski> (and i think Functor should be a super-class, yes .. i don't know why it currently isn't)
02:14:43 <ski> extend = (=<<)
02:15:13 <ski> just different naming (and emphasis)
02:15:19 * ProfTeggy nods
02:15:29 <ski> extend :: Monad m => (a -> m b) -> (m a -> m b)
02:15:52 <ski> ('extend f' written like 'f^*' in some CT notation ..)
02:16:12 <gour> any haskeller using gvim here?
02:17:32 <luqui> yep
02:18:25 <gour> i can heartily recommend pida (until hIDE becomes more mature)
02:18:37 <gour> see http://pida.berlios.de/
02:18:52 <ProfTeggy> Pain In Da Ass?
02:18:56 <ProfTeggy> (sorry)
02:19:19 <gour> i uses gvim as editor and has darcs  plugin
02:19:42 <gour> 0.3 version will be language-independent and will have meld plugin
02:19:53 <gour> s/i/it
02:20:23 <araujo> :-)
02:20:37 * araujo flips over Category Theory
02:20:48 <araujo> This CT thingie is very interesting
02:20:59 <ski> yes
02:21:12 * gour hopes he won't need CT to use monads for mortal's tasks
02:22:03 <ski> gour : you don't .. (well, define 'need' ..)
02:22:08 <sieni> is there some standard function to return unique elements of a list?
02:22:46 <gour> sieni: it is one of the exercises in thompson's book :-)
02:22:53 <ProfTeggy> sieni, nub
02:23:04 <ski> sieni : remove duplicates ?
02:23:32 <kosmikus> gour: you need it as much as you need group theory to add integers
02:23:40 <sieni> ahh
02:23:43 <ProfTeggy> Andres ;-)
02:24:07 <sieni> thanks... justfuckinggoogleit.com didn't help much for some mysterious reason :-)
02:24:39 <gour> kosmikus: your words are real panacea for all the monad's fear present in the average-joe-programmers
02:28:45 <tomaszz> gour: I use gvim
02:29:04 <gour> tomaszz: then you can try pida as ide
02:30:05 <sieni> lambdabot: @pl (\x y -> (x + y) `mod` 4)
02:30:05 <lambdabot> flip flip 4 . (mod .) . (+)
02:30:50 <ski> @type curry ((`mod` 4) . uncurry (+))
02:30:51 <lambdabot> forall b. (Integral b) => b -> b -> b
02:31:11 <ski> @type let (.:) = (.) . (.) in (`mod` 4) .: (+)
02:31:12 <lambdabot> forall a. (Integral a) => a -> a -> a
02:31:13 <tomaszz> gour: does it have some support for haskell?
02:33:10 <gour> tomaszz: all what is present in gvim - syntax high., hare refactored (although i do not need it atm) + ability to pull/record from/to darcs repos (darcs goes well with haskell)
02:38:46 <ski> @arr
02:38:47 <lambdabot> Get out of me way, yeh landlubber
02:40:06 <tomaszz> gour: if all I get is gvim, then I don't understand how pida is better than gvim... ;-)
02:40:35 <gour> tomaszz: have you seen the pida's site?
02:40:45 <tomaszz> gour: a little...
02:41:34 <tomaszz> gour: I'm looking at the Features page now
02:42:09 <gour> tomaszz: it's a ide which uses external applications, so you have project management, rcs, (new version) will provide meld-diff tool, embedded glade-compatible designer (gazpacho)...
02:42:22 <tomaszz> gour: let me add that I don't like to use mouse ;->
02:43:15 <gour> tomaszz: so you <tab> to navigate around pida :-)
02:44:51 <tomaszz> gour: maybe I'll take a look, I just did 'apt-get install pida'
02:47:05 <dblhelix> could someone explain what's happening here (cabal): Could not find module: Foo. with any suffix: ["hi"]
02:47:10 <gour> i got a recent snapshot 'cause darcs record was not working properly, so if you have some issues tell me or join ask on #pida
02:47:46 <tomaszz> gour: are you a developer of pida?
02:48:12 <tomaszz> gour: I've got it running
02:48:39 <tomaszz> gour: and there's a problem
02:49:07 <tomaszz> gour: gvim's cursor doesn't blink ;-)
02:49:37 <triplah> haha
02:50:10 <tomaszz> gour: and I am unable to hide those panels on the right ;-)
02:51:58 <gour> tomaszz: no just user
02:52:15 <gour> tomaszz: about cursor i already reported to the main dev
02:53:14 <gour> tomaszz: but you can stretch you gvim pane to the right?
02:53:53 <phys_rules> dblhelix: well it just says it can't find Foo.hi
02:54:08 <tomaszz> gour: indeed, it works
02:54:10 <dblhelix> phys_rules: still, it's there
02:54:37 <phys_rules> phys_rules: what are you trying to do ?
02:54:40 <phys_rules> err
02:54:42 <phys_rules> dblhelix: =)
02:55:10 <tomaszz> gour: hey, the cursor blinks now :-)
02:55:14 <dblhelix> phys_rules:  just setup copy for a simple lib
02:55:42 <gour> tomaszz: dev is catching this bug 'cause it happens according to your experience - it comes & goes
02:55:58 <tomaszz> gour: embedding a shell is a nice feature
02:56:03 <gour> tomaszz: you can go to #pida and give him some positive feedback :-)
02:57:23 <phys_rules> dblhelix: did you make a .cabal & setup.lhs ?
02:57:30 <phys_rules> or setup.hs
02:57:36 <dblhelix> phys_rules: of course
02:58:52 <phys_rules> dblhelix: can you paste them somewhere ?
02:59:16 <tomaszz> got to get back to work now
02:59:29 <dblhelix> phys_rules: @paste
02:59:34 <dblhelix> @paste
02:59:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:00:56 <dblhelix> phys_rules: mmm, it seems i can't edit
03:01:13 <dblhelix> phys_rules: but still, there's nothing special going on there
03:04:51 <phys_rules> dblhelix: works just fine for me
03:05:25 <gour> tomaszz: happy pida-ing :-)
03:28:11 <Spark> if you have intersection(A->B,X->Y), is that union(A,X) -> intersection(B,Y) ?
03:29:59 <ski> Spark : i'd think so ..
03:30:56 <ski> hm
03:31:01 * ski thinks
03:32:18 <Spark> or union(A,X) -> union(B,Y)
03:33:35 <Spark> and what is union(A->B,X->Y)
03:34:19 <ski> hm, what do you mean here by intersection and union .. ?
03:34:20 <ski> hm
03:34:26 <Spark> the usual definitions
03:34:43 <ski> e : intersection(T0,T1)
03:34:45 <ski> ----------------------
03:34:49 <ski> e : T0
03:34:51 <ski> etc ?
03:34:52 <Spark> other way up
03:34:57 <Spark> but yeah
03:34:57 <Spark> B |- e : t   => B |- e : union(t,_)
03:34:59 <Spark> as well
03:35:28 <Spark> B |- e : t1 && B |- e : t2  => B |- e : union(t1,t2)
03:35:32 <Spark> oops
03:35:36 <Spark> B |- e : t1 && B |- e : t2  => B |- e : intersection(t1,t2)
03:35:56 <ski> hmhm
03:36:19 <ski> do you have any nontrivial example of such an introduction ?
03:37:00 <Spark> intersection is usually like a list of implemented interfaces or something like that
03:37:20 <Spark> intersection of functions is overloading
03:37:33 <ski> yes, but that doesn't use that last intro-rule
03:37:54 <ski> hm
03:38:05 <Spark> ok so if you have f: (int -> int) and f: (real -> real) then you have intsection(int->int,real->real)
03:38:58 <ski> left 'a' : char + int  &&  left 'a' : char + bool  =>  left 'a' ; intersection(char + int,char + bool)
03:39:29 <Spark> whats +?
03:39:32 <ski> hm, does (should)  left 'a' : char + intersection(int,bool)   follow ?
03:39:37 <ski> + is Either in haskell
03:39:44 <Spark> so thats union then
03:39:46 <ski> disjoint union
03:39:49 <ski> not union
03:39:58 <Spark> hmm
03:40:10 <Spark> i dont think its worth distinguishing them
03:40:15 <dblhelix> to make things worse: it's a *lifted* disjoint union
03:40:25 <ski> dblhelix : in haskell, yeah
03:40:33 <dblhelix> ski: yes
03:40:53 <Spark> intersection(union(char,int),union(char,bool))
03:41:13 <Spark> union(char,intersection(int,bool)) ?
03:41:35 <ski> Spark : even if a assume union is same as disjoint union, can you factor out in that way ?
03:41:41 <Spark> not sure
03:41:41 <ski> s/a/i/
03:42:06 <Spark> need to derive a rule in the system
03:42:09 <Spark> wheres my biro
03:42:17 * ski considers the case with intersection and disjoint union
03:42:20 <ski> (biro = ?)
03:42:23 <Spark> pen
03:43:24 <ski> hm, i don't see any harm in saying  left 'a' : char + intersection(char,int)  yet ..
03:45:55 <Spark> i seem to remember steffen van bakel wrote papers about why intersection(A->B,A->C) was the same as A->intersection(B,C)
03:46:17 <Spark> thus eliminating the second condition from the type syntax and getting a tighter but equivalent system
03:46:58 <ski> that sounds right ..
03:47:03 <ski> (second condition ?)
03:47:45 <Spark> second case sorry
03:48:26 <triplah> ouch
03:48:41 <triplah> im build ghc at the moment
03:48:48 <triplah> its reduced my system to a standstill
03:48:55 <triplah> doing some MAJOR io on my hdd
03:49:06 <triplah> /usr/bin/ar
03:49:31 <ski> Spark : which case ?
03:49:36 <Spark> A->intersection(B,C)
03:52:32 * ski ponders intersections and records
03:54:06 <Spark> intersection({name1: int}, {name2: char}) = {name1: int, name2: char}
03:54:10 <Spark> that ones easy enough
03:56:45 <ski> yes
03:56:56 <ski> but in the case above ..
03:57:28 <ski> btw, if you distinguing between records and intersections, why don't you distinguish between disjoint unions and unions
03:57:46 <ski> ?
03:58:07 * ski ponders whether Spark thinks multiplicatively about records
03:58:23 <Spark> yeah you dont need the latter case because it can be expressed with teh former
03:58:32 <Spark> thats what forsythe does, it just has a "naming" operator
03:58:36 <Spark> that types to name: t
03:58:55 <Spark> that just stops them clashing in the intersection rule
03:59:11 * ski tentatively answers his pondering with, 'yes'
03:59:31 <Spark> can you overload two methods A->B and X->Y ?
03:59:34 <Spark> it seems you should
03:59:45 <ski> methods ?
03:59:51 <Spark> functions
04:00:01 <dcoutts> ibid, pong (I think you pinged me first but I think we've both forgotten why)
04:00:01 <Spark> suppose you have f:A->B and f:X->Y
04:00:24 <Spark> you should then be able to call f(v)  where v:union(A,X)
04:00:27 <Spark> that much is clear
04:00:41 <Spark> but in that case, the return type should be union(B,Y) shouldnt it
04:00:47 <Spark> since you dont know which it is...
04:01:03 <Spark> but in the case of f(a) where a:A, you know the return type will be B
04:03:00 <ski> hm
04:03:19 * ski tries to recall the union rules, again ..
04:03:29 * shapr cackles happily
04:04:19 <ski> if the union was disjoint, this would express that it is a (bi)functor ..
04:04:39 <ski> so, union(A,X) -> union(B,Y)
04:04:46 <ski> i think
04:06:46 <Spark> mm
04:23:41 <dcoutts> anyone know what's happened to the log of this channel. The log stops two days ago.
04:24:02 <Philippa> which client keeps it?
04:24:10 <Philippa> it could've got disconnected
04:24:36 <dcoutts> I don't know which client I'm afraid
04:24:51 <Spark> heh
04:25:00 <Spark> someone explain to me the state monad
04:25:09 <Spark> i'm looking at nomaware
04:26:32 <Spark> firstly
04:26:33 <Spark> data MyType = MT Int Bool Char Int deriving Show
04:26:36 <Spark> why deriving Show ?
04:26:58 <Spark> and why not just a tuple
04:27:11 <Spark> data MyType = Int x Bool x Char x Int
04:27:39 <Spark> i assume StdGen is something to do with pseudorandom number generation
04:28:08 <Spark> and randomR (1,100) g is using g as the seed and giving a number between 1 and 100
04:28:44 <Spark> but i get the general idea from the top part
04:29:06 <Spark> newtype State s a = State { runState :: (s -> (a,s)) } 
04:29:10 <Spark> i dont get what that means though
04:29:37 <Spark> if its a record why does it have State { ... }
04:29:43 <Spark> instead of just { ... }
04:31:53 <Spark> also if its a record with only one element, is that not a bit pointless
04:32:36 <wolverian> I don't really know Haskell, but I'd think it needs state because it's not pure 
04:32:52 <wolverian> (otherwise you'd always get the same value.)
04:33:10 <Philippa> Spark: records're ordinary data constructors
04:33:28 <Philippa> they just have attached fields, and multiple constructors in the same type can use the same field name
04:33:46 <Spark> so what does { } mean
04:33:54 <Philippa> "fields go inside here"
04:33:56 <Spark> ah right
04:34:15 <Spark> so it oculd just be State s a = State s(s->(a,s))
04:34:51 <Spark> so newtype is like a tuple with a name, then?
04:35:06 <Spark> Coord t = Coord t t
04:35:31 <Spark> ah theyre distinct identifiers
04:35:45 <Spark> because you do "Coord t = Fish t t | Pain t"
04:37:23 <Spark>     return a        = State $ \s -> (a,s)
04:37:33 <Spark> is that not the same as State (\s -> (a,s)) 
04:37:49 <ski> it is
04:37:52 <Spark> ok
04:38:47 <ski> newtype records are isos
04:39:14 <ski> you get an extraction function, as well as a constructor function
04:39:30 <xinming> hmm, what does $ mean in haskell
04:39:41 <ski> f $ x = f x
04:39:52 <ski> '$' means function application
04:40:04 <ski> it's used to avoid writing so many parens
04:40:34 <xinming> f a b c = f $ a b c ?
04:40:34 <Spark> (f $ $) x
04:40:49 <Spark> @type $
04:40:50 <lambdabot> parse error on input `$'
04:40:53 <Spark> failure
04:41:07 <neologism> ($)
04:41:07 <boegel> @eval take 10 $ map (\x -> x +1) $ replicate 100 $ 2
04:41:09 <lambdabot> [3,3,3,3,3,3,3,3,3,3]
04:41:11 <ski> f x (g y (h a b (i c)) z (j w))   =   f x $ g y (h a b $ i c) z $ j w
04:41:19 <boegel> vs 
04:41:26 <ski> xinming : no
04:41:40 <boegel> @eval take 10 (map (\x -> x +1) (replicate 100 2))
04:41:41 <lambdabot> [3,3,3,3,3,3,3,3,3,3]
04:41:48 <ski> xinming : recall that 'f a b c' really means '((f a) b) c'
04:42:29 <Spark> usually you define application like (M.N) rather than (M N), in which case $ is like . only with lower precedence
04:42:33 <ski> @type ($)
04:42:33 <xinming> So, f a $ b $ c = ((f a) b) c?
04:42:34 <lambdabot> forall b a. (a -> b) -> a -> b
04:42:51 <ski> xinming : no
04:42:57 <xinming> oops... Thanks for your explaination, I need to learn more I think. :-/
04:42:59 <ski> $ associates to the right
04:43:05 <Spark> oh, that too
04:43:12 <ski> 'f a $ b $ c' means 'f a (b c)'
04:43:25 <ski> (which means '(f a) (b c)')
04:46:51 <Spark> in the sense of OOP
04:46:52 <Spark> newtype State s a = State { runState :: (s -> (a,s)) } 
04:46:52 <Spark>  
04:46:53 <Spark> instance Monad (State s) where 
04:46:58 <Spark> the first is fields, and the second is methods?
04:47:40 <Spark> actually the second is implementing the interface Monad, and thus method definitions are required
04:48:37 <ski> that is an analogy, yes
04:49:09 <ski> (but there is no implicit self/this in the methods ..)
04:49:20 <ski> (and no implementation inheritance)
04:49:34 <Spark> yes
04:49:50 <Spark> no implicit this allows you to have e.g. two this parameters
04:49:57 <Spark> which is much more sensible than java's o.equals(o)
04:50:17 <Spark> where one is implicit and the other is explicit
04:50:22 <ski> not fully comparable, i think
04:51:35 <Spark> class MonadState m s | m -> s where 
04:51:37 <Spark> what does that mean?
04:51:42 <Spark> where is the precedence in those constructs
04:52:00 <Spark> is it class MonadState (m s) | (m -> s) where
04:52:42 <ski> '| m -> s' is an additional, optional part
04:52:54 <ski> specifying functional dependencies
04:53:06 <Spark> oh right
04:53:15 <Spark> but m and s are just type varibles then
04:53:43 <ski> in this case, if you regard MonadState as a binary predicate on types, then   forall m. unique s. MonadState m s
04:54:34 <ski> (or, if you will, 'forall m. forall s0,s1. (MonadState m s0,MonadState m s1) => s0 = s1')
04:54:37 <musasabi> Released hsgnutls-0.2.2 which fixes some corner cases with Handles and buffering.
04:54:38 <Spark> is that the functional dependency?
04:55:19 <ski> yes
04:55:35 <Spark> ok i'm going to carefully ignore that for now :)
04:55:37 <ski> m uniquely determines s
04:55:54 <Spark> ah
04:55:59 <Spark> thats simple actually
04:56:23 <ski> used e.g. to avoid some ambiguity issues (so one doesn't need to add so many explicit type signatures and/or ascriptions)
04:56:28 <joelr1> howdy
04:58:24 <Spark> newtype State s a = State { runState :: (s -> (a,s)) } 
04:58:26 <Spark> instance Monad (State s) where 
04:58:40 <Spark> what does (State s) mean?
04:58:58 <shapr> The sun is down behind the hills already :-( I missed my chance to go outside today.
04:59:39 <ski> that newtype definition defines a type constructor State
04:59:41 <Spark> why not (State s a) or something
04:59:49 <ski> State :: * -> * -> *
05:00:07 <ski> since it takes two type parameters, each one being a regular type
05:00:13 <Spark> yep
05:00:19 <ski> class Monad (m :: * -> *)
05:00:35 <ski> Monad is a predicate over type constructors of kind '* -> *'
05:00:44 <ski> so, since
05:00:47 <ski> State :: * -> * -> *
05:00:49 <ski> if
05:00:51 <ski> s :: *
05:00:52 <ski> then
05:00:55 <Spark> ok so we're binding s
05:00:58 <Spark> and leaving a open?
05:00:58 <ski> State s :: * -> *
05:01:13 <ski> a isn't given here
05:01:22 <ski> the methods specialize from
05:01:28 <ski> return :: forall a. a -> m a
05:01:43 <ski> (>>=) :: forall a b. m a -> (a -> m b) -> m b
05:01:43 <ski> into
05:01:49 <ski> return :: forall a. a -> State s a
05:02:00 <ski> (>>=) :: forall a b. State s a -> (a -> State s b) -> State s b
05:02:23 <luqui> when I was learning about monads, I had to look at the signature of (>>=) about ten times a minute
05:02:45 <ski> so, we couldn't have given 'a' already, previously, since we need to apply 'm' to e.g. both (locally universally quantified) 'a' and 'b', in (>>=)
05:03:16 <Spark> ok
05:03:37 <Spark> so what are s and a in the definition of State
05:03:41 <Spark> one is the type of the encapsulated data?
05:03:43 <Spark> (a?)
05:03:46 <Spark> and the other is...
05:04:32 <ski> instance Monad (State s) where ...
05:04:44 <ski> that actually declares a family of instances
05:04:46 <Spark> ah
05:04:54 <Spark> yeah
05:04:55 <ski> one for each possibly type value of s
05:05:04 <Spark> so is s the type of the encapsulated data?
05:05:10 <Spark> that doesnt fit well with (s -> (a,s))
05:05:12 <ski> so, State Int is a different monad than State Bool
05:05:23 <Spark> so s = State a
05:05:30 <ski> s is the type of the hidden state in the state monad
05:05:34 <ski> Spark : no
05:05:50 <ski> State s a  ~=  s -> (a,s)
05:07:27 <luqui> Can I write a function: join :: [(forall a. Show a => a)] -> String
05:12:25 <ski> hi Buggaboo
05:12:38 <Buggaboo> heyhey
05:12:54 <shapr> shazam!
05:13:05 <ski> luqui : i think you want 'exists', and not 'forall'
05:13:13 <eivuokko> Hmmm.
05:13:58 <luqui> ski, does that, er, exist?
05:14:00 <ski> [(forall a. Show a => a)] means a list of things, where the user of the list gets to choose what type each element should have (prodived it's a Showable type)
05:14:24 <ski> luqui : no, but i think you neither can write that 'forall' like that
05:14:33 <ski> so you need an auxilary type anyway :)
05:14:39 <luqui> yeah, ghc was whining at me
05:14:45 <luqui> so I made my own polymorphic show list
05:14:54 <luqui> which is a pain, but it makes sense why I have to do that
05:15:16 <ski> newtype Showable = forall a. Show a => S a
05:15:28 <ski> that would be same as
05:15:43 <ski> newtype Showable = S (exists a. Show a *> a)
05:15:48 <ski> if one could type that ..
05:15:55 <ski> hm
05:16:10 <ski> right, you can't use newtype
05:16:13 <ski> use data, instead
05:16:50 <dblhelix> when does System.Console.Readline.readline produce Nothing?
05:17:45 <shapr> Cale: HaskellNewbie is really nice.
05:18:54 <neadjneki> shapr what is that?
05:19:50 <boegel> yo shapr
05:19:54 <shapr> @wiki HaskellNewbie
05:19:54 <lambdabot> http://www.haskell.org/hawiki/HaskellNewbie
05:22:19 <luqui> hm.  it whined at me when I tried to construct a list of Showables
05:22:47 <luqui> the only thing that's worked is:  data PolyList = forall a. Show a => Cons a PolyList | Nil
05:22:52 <joelr1> @paste
05:22:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:23:08 * luqui really really really needs some sleep
05:23:25 <boegel> luqui: just go to bed then ?
05:23:34 <luqui> that's what I'm doing
05:23:42 <luqui> night
05:23:49 <luqui> er, morning, I guess
05:25:23 <joelr1> folks, can someone please help me? problem pasted
05:27:07 <boegel> joelr1: what is the problem ?
05:27:21 <wilx> Hah! My Uni offers Quantum Computing course for next semester.
05:27:27 <wilx> I wonder if I should try it :)
05:27:53 <JKnecht> guesses not.
05:27:55 <boegel> wilx: why not ! live a little !
05:28:02 <joelr1> boegel: exception escapes
05:28:18 <wilx> I fear the physics.
05:28:32 <boegel> joelr1: 'escapes' ?
05:28:50 <joelr1> boegel: it's not being caught by the liftIOTrap function and converted into my ErrorT
05:29:34 <JKnecht> fear the math.
05:30:17 <JKnecht> except that it sounds like a "culture survey", so 2nd take: go ahead and live a little!
05:30:47 <boegel> joelr1: the 'do x <- ...       x' syntax is a bit strange to me... you bring something out the IO monad (using <-), but the result is still IO ?
05:30:59 <musasabi> joelr1: Usually you want to catch exceptions with Control.Exception and not IOErrors.
05:31:27 <joelr1> boegel: i just cobbled that together from advice given by various people
05:31:40 <joelr1> musasabi: i need to catch the IO errors, though
05:31:52 <joelr1> musasabi: as i believe these are the ones being thrown from the IO monad
05:31:52 <musasabi> just kill of the ErrorT from your stack and lift Exception.catch to the StateT IO
05:32:01 <boegel> joelr1: you should make sure you understand what you're doing, otherwise you'll just make the same mistake again
05:32:02 <joelr1> musasabi: huh?
05:32:12 <joelr1> musasabi: i need my state
05:32:15 <joelr1> though
05:32:15 <musasabi> Control.Exception catches both (IO and non-IO) exceptions.
05:32:29 <joelr1> boegel: that's why i'm asking for help
05:32:47 <joelr1> musasabi: looking into it
05:33:11 <joelr1> musasabi: so how would you rewrite this?
05:34:53 <joelr1> does timeout look ok? the function
05:35:52 <musasabi> basically you would have mcatch act hand = do s0 <- get; (x,s) <- liftIO ((runStateT act s0) `Exception.catch` (\e -> return (someThing, s0)); put s; return x
05:36:00 <musasabi> or something similar
05:36:34 <joelr1> musasabi: i don't want to restructure my monad ;) i just want to catch the io error and convert it to errorT
05:36:41 <musasabi> mmh
05:36:55 <joelr1> sounds like a nice small bit of a problem
05:37:36 <musasabi> I did that in the past (and it worked), but then killed of the ErrorT later and was happier.
05:37:57 <joelr1> also, catchError is from Control.Monad.Error, it does not have much to do with IOErrors per se
05:38:56 <joelr1> but i'll try catching the exception higher up
05:39:26 <dcoutts> boegel, I discovered the segfault when using HaskLS was a bug in xorg-x11, specifically the mesa dri code. It's fixed in a later version. The reason you didn't get that bug before is that you were never able to close the rendering window and re-opening it (without restarting the program) :-)
05:39:43 <musasabi> joelr1: at least your timeout function is broken.
05:39:50 <joelr1> musasabi: how so?
05:40:13 <musasabi> joelr1: in what thread do you throwError ;)
05:40:21 <joelr1> looking
05:40:44 <joelr1> musasabi: hmm, you are 100% right. in the wrong one
05:40:54 <boegel> dcoutts: oh cool :)
05:41:10 <dcoutts> boegel, so it wasn't our fault :-)
05:41:31 <musasabi> joelr1: e.g. http://happs.org/HAppS/Util/TimeOut.hs does timeouts right. (GPL warning though)
05:41:31 <dcoutts> boegel, I ran it on Solaris and it worked there so I suspected it was a lower level bug.
05:42:06 <dcoutts> boegel, so yeah, my Gtk2Hs port of your HaskeLS compiled and worked first time on Solaris.
05:42:13 <dcoutts> mmm portability
05:42:17 <joelr1> can't use GPL
05:42:40 <boegel> dcoutts: coolness !
05:43:13 <dcoutts> boegel, do you know if it's possible to rotate the tree without re-generating all the lines each time?
05:43:20 <musasabi> I think you can use at the code and gain insight and write your own.
05:43:25 <dcoutts> boegel, that's the limiting factor in the animation speed
05:43:26 <musasabi> *look at the
05:43:33 * boegel thinks
05:43:50 <dcoutts> boegel, can we generate the scene once and then just rotate it without re-generating the scene?
05:44:07 <boegel> I'm not sure, I'm not that familiar with OpenGL, but I'd guess it should be possible
05:44:21 <boegel> otherwise OpenGL would really be usefull :)
05:44:26 <musasabi> Basically timeouts are a little bit nontrivial and there were some issues with some implementations being inefficient. Also killThread may block in circumstances etc
05:45:30 <joelr1> musasabi: right
05:45:47 <dons> SamB: hmp3 has been running for 9hrs 3mins now and is on 0.98% cpu :D
05:45:56 <dcoutts> boegel, as it is, on my slow Solaris machines the animation is quite slow. The X server is doing 1% or 2% of the work (ie the GL graphics itself isn't very taxing) but the haskls process uses al the rest of the cpu time.
05:46:01 <musasabi> joelr1: except withTimeOut should have throwDynTo (there is a patch for that, but is not yet in there).
05:46:16 <joelr1> i see
05:46:23 <dcoutts> boegel, anyway something to think about later. I'm off now. Bye.
05:46:49 <dcoutts> boegel, oh, btw. You got my patch in the end?
05:47:30 <musasabi> Basically there are two things you should be wary 1) remember to kill the timeout thread, 2) remember that killThread may block
05:47:48 <boegel> dcoutts: yeah, three times, don't ask me why/how :) haven't found the time to add it though, I'll do that when I find the time :)
05:47:57 <joelr1> musasabi: right
05:48:20 <joelr1> musasabi: but you cannot do anything about killthread blocking, i think
05:48:39 <dcoutts> boegel, ok, cool.
05:50:26 <Philippa> joelr1: fork a thread to kill the other one
05:50:36 <joelr1> what's the difference between tryPutMVar and putMVar?
05:50:45 <joelr1> Philippa: thanks
05:51:25 <dons> -- |A non-blocking version of 'putMVar'.  The 'tryPutMVar' function
05:51:25 <dons> -- attempts to put the value @a@ into the 'MVar', returning 'True' if
05:51:25 <dons> -- it was successful, or 'False' otherwise.
05:51:45 <joelr1> interesting
05:52:07 <dons> ;) and I just got back from the pub. how's that for productivity? :)
05:52:16 <joelr1> :)
05:53:37 <musasabi> joelr1: yes, you can. 1) kill only threads you know are not blocking, or 2) kill it affer returning the result to the main thread.
05:53:45 <musasabi> forking a thread for the kill is slow.
05:54:15 * musasabi just spent half a day benchmarking various timeout implementations in the past week
05:54:23 <joelr1> so... any idea how to redo my paste?
05:55:32 <joelr1> musasabi: how do you kill a thread _after_ returning results... which thread would you do that from? the timeout thread?
05:56:16 <musasabi> joelr1: So you have threads 1) main thread, 2) thread doing calculation, 3) thread doing timeout.
05:56:54 <musasabi> joelr1: the trick is that 2) and 3) tryPutMVar and then kill the other.
05:56:59 <joelr1> musasabi: yes, and you need to kill the computation thread and i surmise you are suggesting doing it from the timeout thread after returning the calculation, i.e. putting it in the mvar
05:57:05 <joelr1> ok
05:57:07 <joelr1> gotcha
05:57:30 <ibid> dcoutts: ping
05:58:37 <joelr1> musasabi: i just pasted the new timeout version, does it look right to you?
05:59:45 <musasabi> "throwError $ userError" => fail
06:00:10 <musasabi> and you don't kill the timeout thread.
06:00:54 <joelr1> the timeout thread ... will timeout, why do i need to kill it?
06:01:06 <musasabi> which can cause a 10x performance slowdown if timeout computations (that are successfull) are common.
06:01:12 <joelr1> also, not sure i understood what you meant by throwError being a fail
06:01:33 <musasabi> "Left err -> fail err" just seems more pretty
06:01:49 <joelr1> ok, fixing
06:02:00 <joelr1> what about my liftIOTrap?
06:02:42 <musasabi> joelr1: if you do 10000 computations with a timeout n a second with the timeout 10 secs and they finish on average in 0.1s then before long you have 100000 timeout threads hanging around.
06:02:50 <musasabi> Thus killing them can be a good idea.
06:04:26 <joelr1> musasabi: check paste
06:04:28 <joelr1> like this?
06:06:08 <musasabi> joelr1: nope, that can block infidently.
06:06:51 <joelr1> well then?
06:06:53 <musasabi> joelr1: Think about it. tid1 blocks. The timeout fires and tid2 writes to the MVar and then blocks on killThread tid1. Now the main thread blocks indefinitely on killThread tid2.
06:07:27 <musasabi> joelr1: you need to killThread tid2 in tid1 after the putMVar.
06:07:30 <musasabi> mdo.
06:08:16 <joelr1> a cross-killing of threads, cool
06:08:28 <joelr1> so what about catching the fail?
06:08:54 <musasabi> well it is just an IOError.
06:09:00 <joelr1> hmm
06:09:00 <joelr1> btw
06:09:19 <joelr1> i cannot kill tid2 in thread 1 because it does not exist at that point
06:09:26 <joelr1> scope-wise
06:09:27 <musasabi> you could also lift the timeout into ErrorT if you are using that. (then fail will use ErrorT's errors)
06:09:36 <musasabi> joelr1: and that is why you need mdo.
06:09:50 <joelr1> musasabi: that's what i'm trying to do, lieft the timeout into ErrorT
06:10:12 <musasabi> Basically "mdo foo <- someThing bar; bar <- someThingElse foo; ..."
06:10:31 <joelr1> @index mdo
06:10:31 <lambdabot> bzzt
06:11:09 <joelr1> musasabi: so how do i lift the timeout into errort?
06:11:27 <joelr1> while lifting potential exceptions that are thrown by the computation as well
06:12:06 <joelr1> i was trying to do that by throwing an IOError from timeout and then catching IOErrors in liftIOTrap
06:12:12 <musasabi> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
06:12:16 <joelr1> because my timeout is used for IO actions
06:14:11 <musasabi> joelr1: well instead of "do x <- action; putMVar mv (Right x)" "do x <- try action; putMVar mv x" (thus you use "Either Exception a" instead of "Either String a")
06:15:20 <joelr1> what happens if a computation throws an exception? like IOError
06:15:44 <joelr1> musasabi: aha
06:15:46 <joelr1> i see now
06:16:08 <joelr1> but then it will not be compatible with my ErrorT which uses a string
06:16:15 <joelr1> so I would need to change my errorT then
06:16:46 <musasabi> wekk you can show your Exception.
06:17:13 <musasabi> @type either (Left . show) (Right . id)
06:17:14 <lambdabot> forall a b. (Show a) => Either a b -> Either String b
06:17:18 <joelr1> true. so putMVar $ show x
06:18:08 <musasabi> you only want to show the left not the right.
06:18:34 <joelr1> right, of course
06:19:20 <joelr1> musasabi: putMVar mv $ either ... ?
06:19:40 <shapr> basti_: hiya
06:19:41 <musasabi> should work.
06:20:46 <basti_> hi shapr 
06:20:51 <basti_> whats up?
06:21:09 <joelr1> musasabi: so then i'm basically rethrowing everything with a fail
06:21:17 <shapr> basti_: I'm just bouncy, how are you?
06:21:26 <basti_> at the phone :(
06:21:29 <joelr1> err, rethrowing the (show $ Exception) with a fail
06:22:12 <ibid> dcoutts: (i do remember why i pinged you:)
06:22:46 <musasabi> Depends on the monad you are in. In IO fail = throw an IO error. In ErrorT fail =  produce a Left value.
06:22:53 <musasabi> anyways I should be working.
06:24:02 <joelr1> musasabi: thanks!
06:30:18 <dons> has everyone filled out the haskell survey: http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
06:33:17 * boegel has
06:33:49 <ski> not yet
06:33:52 <sieni> /me too
06:34:56 <sieni> My siteswap validator in Haskell became quite short: http://www.hurmio.org/~ville/SiteswapValidator.hs
06:35:26 <sieni> at least better than the scheme one ;-) http://www.hurmio.org/~ville/siteswap-validator.scm
06:41:35 <ProfTeggy> sieni, please enlighten me: what's the use of a siteswap validator?
06:45:44 <sieni> ProfTeggy: so you can e.g. tell immediately, that 666617448844197531 is jugglable using 5 balls
06:46:19 <sieni> (input in this program as siteswapValidator [6,6,6,6,1,7,4,4,8,8,4,4,1,9,7,5,3,1])
06:46:55 <sieni> http://en.wikipedia.org/wiki/Siteswap
06:47:47 <ProfTeggy> sieni, thanks
06:48:31 <ProfTeggy> Amazing
06:49:10 * ProfTeggy bookmarks the page as a "cool" example of using DFAs for an upcoming Intro to CS course.
06:52:01 <shapr> sieni: Is there something like that for contact juggling? :-)
06:52:16 <sieni> shapr: probably not :-)
07:20:55 <shapr> Sure is quiet today.
07:21:29 <basti_> mmmh
07:22:20 <SamB> hello
07:23:26 <Saulzar> Hi, I'm having a small issue with an ambiguous operator trying to make a small vector type  "Ambiguous occurrence `+'" - declaring the function is ok, but then I try to add the components
07:23:43 <Saulzar> I am defining my vector as "data Vector4 = Vector4 Float Float Float Float"
07:24:13 <SamB> Saulzar: ah
07:24:17 <Saulzar> I would have thought it would be ok - since I have specified "Float" directly 
07:24:27 <SamB> so you are trying to define '+'?
07:24:31 <Saulzar> Right..
07:25:01 <SamB> well, the thing is + is defined in the Prelude, so when you try to use it, it isn't clear which + you mean
07:25:31 <SamB> you could make Vector4 an instance of Num
07:26:00 <Saulzar> Ahh.. hmm.
07:26:00 <SamB> and just leave the fromInteger method undefined
07:26:39 <SamB> and likely also the * method
07:27:03 <SamB> or you could use other names for addition and subtraction
07:27:16 <Saulzar> I guess one can always use another '+', but coming from OCaml I thought "Neat - maybe I don't have to use that odd "+>" operator"  :)
07:27:32 <SamB> what is +>?
07:27:35 <SamB> in this context?
07:27:50 <SamB> I think I saw something like that in a regex library ;-)
07:27:53 <Saulzar> A name for an unused operator
07:28:25 <SamB> do you understand type classes?
07:28:42 <SamB> @type 1
07:28:43 <lambdabot> forall t. (Num t) => t
07:28:45 <Saulzar> Yes, I have a fair idea
07:29:09 <SamB> so, I would suggest making Vector4 an instance of Num, personally.
07:29:31 <SamB> its perfectly okay to make things instances of Num that don't support all the methods
07:29:56 <Saulzar> They have a default implementation?
07:30:02 <SamB> no.
07:31:00 <SamB> you will get a runtime error if something tries to use an undefined method, is all
07:31:09 <SamB> well, GHC tends to give warnings also.
07:31:13 <Saulzar> Thanks a lot - it didn't occur to me, that will be a great help :)
07:31:45 <SamB> which is as it should be, because if you leave one undefined by accident, that is not good ;-)
07:34:01 <Saulzar> Hehe, I guess it can always be implemented as error "blah" 
07:34:42 <SamB> yes
07:35:12 <SamB> that is actually how I do it
07:37:39 <stefanpa_> Hi, Two questions sorry for their simplicity. But first is there a past board I can put my code?
07:37:50 <shapr> @paste
07:37:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:37:52 <SamB> hehe, nothing wrong with simple questions
07:38:02 * SamB likes lisppaste2 
07:38:06 <SamB> lisppaste2: help
07:38:06 <shapr> stefanpa_: But you need to login to the wiki to paste there. Happily, account creation is one click.
07:38:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:38:27 <shapr> SamB: I wish lambdabot did that, and that we had a better Haskell highlighter.
07:38:44 <SamB> shapr: would be nice
07:39:16 * SamB just likes not having to worry about edit locks and such
07:39:44 <shapr> Didn't someone create an HsColour hiliter?
07:41:23 <SamB> dunno
07:42:13 <lisppaste2> stefanpa_ pasted "Why doesn't this compile?" at http://paste.lisp.org/display/13661
07:43:43 <stefanpa_> I'm trying to compile that code with GHC and I'm having do issues
07:43:59 <stefanpa_> line 63 is there error
07:44:57 <stefanpa_> I'm not certain that a case is allowed like that. The other question is how should I do the mail function/modual to compile it to an executable
07:45:50 <SamB> stefanpa_: it looks rather as if the case may be indented too far
07:48:02 <SamB> also, you use -> in case, not =
07:48:17 <stefanpa_> I just noticed that
07:48:30 <stefanpa_> Now it's giving me pattern parsing errors
07:49:15 <shapr> I like google's RSS reader.
07:49:51 <lisppaste2> SamB annotated #13661 with "maybe this works?" at http://paste.lisp.org/display/13661#1
07:51:47 <lisppaste2> SamB annotated #13661 with "what I usually do" at http://paste.lisp.org/display/13661#2
07:51:50 <stefanpa_> SamB thanks
07:52:18 <stefanpa_> now the compiling to an executable?
07:52:32 <SamB> ghc --make usually works nicely
07:52:51 <stefanpa_> do I need to define this as the main module?
07:52:55 <SamB> probably you want to pass -o executableName...
07:53:05 <SamB> oh, wait.
07:53:15 <SamB> you have Main instead of main
07:53:20 <stefanpa_> I see thanks
07:53:31 <stefanpa_> Told you they where stupid questions
07:53:35 <SamB> hehe
07:53:38 <stefanpa_> and another question.
07:53:57 <SamB> yes?
07:54:09 <stefanpa_> I was hoping to put some kind of output which displayed it's progress
07:54:29 <stefanpa_> any suggestions?
07:54:48 <SamB> its progress in what?
07:54:53 <SamB> printToFile?
07:55:04 <stefanpa_> for example
07:55:49 <stefanpa_> or a better exxample would be makeTree
07:56:02 <stefanpa_> Actually never mind.
07:56:20 <SamB> thats tricky.
07:56:54 <stefanpa_> Good it wasn't just me
07:57:43 <stefanpa_> how does Haskell handle tabs? because that is where I'm going wrong I think with my does and cases most of the time
07:57:58 <SamB> let me see.
07:58:12 <SamB> @google haskell 98 report
07:58:13 <lambdabot> http://www.haskell.org/onlinereport/
07:58:55 <SamB> The "indentation" of a lexeme is the column number of the first character of that lexeme; the indentation of a line is the indentation of its leftmost lexeme. To determine the column number, assume a fixed-width font with the following conventions:
07:58:56 <SamB>     * The characters newline, return, linefeed, and formfeed, all start a new line.
07:58:56 <SamB>     * The first column is designated column 1, not 0.
07:58:56 <SamB>     * Tab stops are 8 characters apart.
07:58:56 <SamB>     * A tab character causes the insertion of enough spaces to align the current position with the next tab stop. 
08:00:03 <stefanpa_> and the last question if anyone develops on a mac what editor do you use?
08:00:11 <boegel> stefanpa_: vim !
08:00:19 <SamB> that was in http://www.haskell.org/onlinereport/syntax-iso.html#layout
08:00:24 <SamB> stefanpa_: Emacs!
08:00:29 <SamB> well, I don't actually use a Mac, but...
08:00:30 <stefanpa_> Thanks what I've been using
08:00:43 <boegel> neither do I, but it's unix-based, so...
08:02:13 * SamB wonders what this clrtoeol problem in hmp3 is all about
08:03:04 * SamB notes that it doesn't seem to be a particularly significant problem, at least now that that stuff is shown in a bar at the bottom of the screen, rather than spewed wherever
08:03:44 <SamB> oh?
08:03:52 <SamB> you can indent an entire module!
08:03:55 * boegel leaves for home
08:04:04 <SamB> that sounds rather odd
08:07:47 * SamB would like to do a prettyprinter just for Haskell code some time...
08:10:51 <SamB> I suppose the irregular thing is that you can *not* indent a module
08:11:04 <SamB> even when using the layout rule for it
08:11:52 * ski indents modules
08:12:42 <ski> (almost always, in fact)
08:13:39 <SamB> ski: you do?
08:13:46 <SamB> what do you write?
08:15:12 <SamB> now a truly bizzare way to write a module is *without* the layout rule...
08:15:40 <ski> module Foo
08:15:45 <ski>   ( blah
08:15:49 <ski>   , bleh
08:15:51 <ski>   ) where
08:15:55 <ski>  
08:15:59 <ski>   import ...
08:15:59 <ski>  
08:16:04 <ski>   foo :: ...
08:16:08 <ski>   foo = ...
08:16:09 <ski> etc
08:16:14 <SamB> interesting
08:16:15 <araujo> raining day!
08:16:24 * araujo back
08:16:30 <SamB> I bet nobody really writes:
08:16:35 <ski> when i comment out, i put -- or {- -} in zeroeth column, though
08:16:59 <PaulKing> hi there!
08:17:00 <SamB> module Foo (blah, bleh) where
08:17:02 <ski> (that way i can often put them at same line as code)
08:17:11 <ski> hi PaulKing
08:17:12 <PaulKing> is it possible to use mmap/munmap and ioctl in ghc?
08:17:12 <SamB> { import ...
08:17:17 <SamB>  
08:17:30 <SamB> ; foo ::
08:17:32 <SamB> ; foo = ...
08:17:34 <ski> (SamB : except code generators, possibly)
08:17:36 <SamB> ...
08:17:53 <SamB> PaulKing: yes!
08:18:05 <PaulKing> http://www.cs.mu.oz.au/~bjpop/code.html - this page suggests so
08:18:06 <SamB> ski: well, yeah, maybe those.
08:18:09 <PaulKing> SamB: how?!
08:18:19 <SamB> PaulKing: hmm.
08:18:26 <SamB> FFI, for sure.
08:18:35 <SamB> but is it done for you already or not?
08:18:39 <SamB> @index mmap
08:18:39 <lambdabot> bzzt
08:18:45 <SamB> probably not
08:19:57 <SamB> well, fps does it but thats GPL..
08:20:33 <PaulKing> fps?
08:20:56 <SamB> fast packed strings
08:21:03 <PaulKing> (...and what's wrong with GPL?)
08:21:20 <SamB> nothing, unless you wanted to write a proprietary program ;-)
08:21:30 <PaulKing> no I'm not
08:21:59 <SamB> anyway, it looks like it is fairly straightforward if you don't need to work on windows too
08:22:42 <SamB> just write a wrapper in C that takes care of the flags and stuff, and then foreign import it...
08:23:04 <PaulKing> personally, I want to interface with Video4Linux (or V4L2), all I need is open/close /dev/video0 file, mmap it and do some ioctls
08:23:43 <SamB> hmm
08:23:54 <PaulKing> I was wondering if it's possible to do that without messing with C
08:24:03 <SamB> probably!
08:24:08 <PaulKing> many POSIX functions are implemented in ghc
08:24:25 <SamB> however it would probably be unneccesarily complicated to do it without C...
08:24:28 <PaulKing> even threads are working (which surprises me)
08:24:43 <SamB> GHCs threads aren't native
08:25:00 <SamB> they are green or blue or something like that
08:25:46 <SamB> anyway, writing a couple of C functions is not going to kill you, and will probably make your code a LOT cleaner
08:26:24 <SamB> who knows, maybe someone has even written them already ;-)
08:27:04 <flux__> house is written mostly with haskell
08:27:09 <shapr> yup
08:27:13 <flux__> up to drivers etc
08:27:18 <flux__> so I doubt using v4l should be much of a problem
08:27:29 <flux__> assuming one can do any ioctl in haskell
08:27:38 <shapr> I've been using the pure Haskell TCP/IP stack. It talks to /dev/net/tun just fine.
08:28:09 <PaulKing> SamB: what would be the best way to pass big C array (i.e. 640*480*3) from C code to Haskell?
08:28:23 <SamB> flux__: thats the part where I'm thinking it is easier to do it in C
08:28:23 <SamB> flux__: because you need all those preprocessor macros
08:28:59 <flux__> I can't recall if v4l uses structs in its communication, but I guess it may..
08:29:00 <SamB> PaulKing: as a pointer
08:29:01 <PaulKing> SamB: these macros are easily explained in kernel headers
08:29:03 <earthy> paulking: simply pass the pointer as a ForeignPointer
08:29:08 <earthy> err. ForeignPtr
08:29:55 <SamB> PaulKing: I suppose you could define ASM and then include them in Haskell...
08:30:07 <PaulKing> ok, thx for your advices
08:30:11 <SamB> earthy: are you sure its ForeignPtr that is wanted?
08:30:24 <earthy> SamB: the array is allocated in C code, I presume
08:30:40 <earthy> and given the size I'd say it's a pointer to mmap'd data
08:30:43 <SamB> earthy: hmm.
08:30:53 <earthy> so yeah, I think he wants a ForeignPtr
08:31:00 <SamB> earthy: fps uses straight Ptr for importing "my_mmap"...
08:31:11 <PaulKing> the array is allocated in kernel :> and mmap maps it to user process area
08:31:18 <earthy> hm. right.
08:31:32 <earthy> well, it's either Foreign.Ptr or Foreign.ForeignPtr
08:31:39 <SamB> also malloc
08:32:13 <earthy> The type ForeignPtr represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between ForeignPtrs and vanilla memory references of type Ptr a is that the former may be associated with finalizers
08:32:41 <earthy> the finalizer may want to call a kernel function that frees the array. ;)
08:33:19 <SamB> earthy: how can something allocated and managed in C be associated with a finalizer?
08:33:43 <PaulKing> I assume that finalizer means munmap here
08:33:45 <earthy> for fps you'd want Haskell's storage manager to do all the management, in this case it's obvious you can't let Haskell's storage manager do all the stuff
08:33:57 <earthy> PaulKing: roughly, yeah
08:34:04 <PaulKing> what ta hell is that fps?
08:34:25 <PaulKing> is it part of ghc?
08:34:25 <earthy> possibly also do the ioctls to tell the driver to stop capturing
08:34:33 <earthy> nope, it's FastPackedString
08:34:46 <earthy> a somewhat quicker string handling lib ;)
08:34:51 <PaulKing> earthy: yep, ioctls that stop capturing are required
08:35:11 <PaulKing> earthy: so it implements mmap/munpam and ioctsl?
08:35:15 <earthy> nope
08:35:20 <earthy> you have to provide the finalizer yourself
08:35:55 <dcoutts> ibid, you do remember? oh good.
08:36:18 <dcoutts> ibid, then you can tell me :-)
08:36:30 <earthy> and FastPackedString does some mmap() itself to reach the speeds it reaches, so could be used as an example, but you're going to do other stuff basically :)
08:37:48 <SamB> ah, maybe you just can't import a C function as returning ForeignPtr?
08:38:15 <ibid> dcoutts: my students seem to have trouble installing gtk2hs on windows
08:38:30 <ibid> dcoutts: wanna come idle on the course channel? you might be able to help better than i
08:38:31 <PaulKing> who runs gtk on windows?!
08:39:31 <PaulKing> ibid: did u try wxhaskell on windows?
08:39:41 <ibid> PaulKing: why would i?
08:39:43 <SamB> ibid: how am I supposed to draw a binary tree with that library?
08:39:53 <SamB> ibid: it doesn't provide text measuring!
08:40:57 <dcoutts> ibid, sure, what's the course channel?
08:41:23 <jlouis> earthy: fps only mmap()s in one case, more or less and that is when it wants to read in a whole file
08:41:38 <ibid> dcoutts: ircnet, !jyu-fp. you probably need an invite
08:41:39 <dcoutts> PaulKing, gtk runs very well on windows. It's allows you to develop cross-paltform guis.
08:41:42 <ibid> SamB: hmm?
08:42:17 <SamB> ibid: well, okay, so its not really *my* homework
08:42:52 <ibid> dcoutts: msg me on ircnet when ready
08:43:15 <dcoutts> ibid, ok, I'm still trying to connect.
08:44:55 <jlouis> I am thinking of altering fps so I can mmap parts of files, but this is highly ineffective for many files (you eat at least a page per file)
08:45:31 <SamB> jlouis: for what purpose?
08:46:11 <jlouis> SamB: Conjure ;)
08:46:21 <SamB> jlouis: thought so
08:46:37 <ibid> SamB: yeah, that's an unfortunate omission in the SOE API, we noticed that
08:46:49 <SamB> @localtime musasabi 
08:46:51 <jlouis> I have a list of files and offset+size I need to read. Having that API directly into fps would be nice
08:46:51 <lambdabot> Local time for musasabi is Wed Nov 16 18:46:27 2005
08:46:52 <xinming> why doesn't the chat log be generated?
08:46:55 <dcoutts> ibid, fortunately we can extend it
08:47:06 <xinming> for Nov. 15
08:47:10 <ibid> dcoutts: yeah, but i didn't think of it soon enough
08:47:32 <dcoutts> ibid, well if you want a patch you know who to ask
08:47:45 <ibid> dcoutts: your SOE, does it come with .10, or is it separate?
08:48:59 <SamB> xinming: maybe there is a cron job that is running just a little to early and so it doesn't get the log till almost 24 hours after it is finished?
08:49:16 <SamB> xinming: who knows!
08:49:23 <SamB> ask tunes.org people or something...
08:52:26 <dcoutts> ibid, it is seperate. darcs get http://haskell.org/~duncan/soe/
08:53:00 <shapr> xinming: There are two chat logs. One is clog that logs to tunes.org/~nef/logs/haskell one is cmeme which is terribly unstable.
08:53:15 <shapr> Note that user clog is on the channel, but cmeme is not.
08:53:18 <CosmicRay> shapr: what are the newer web site design tools for haskell?
08:53:27 <shapr> er?
08:53:33 <CosmicRay> hwp or something?
08:53:41 <SamB> oh
08:53:46 <SamB> huh
08:53:52 <ValarQ> design tools?
08:54:02 <CosmicRay> no, tools for builting interactive sites
08:54:07 <CosmicRay> like wash
08:54:10 <shapr> You mean hsp?
08:54:15 <ibid> dcoutts: i probably can just send you a patch, if i find the time and energy to do it ;)
08:54:17 <CosmicRay> yes.  that's what I'm after.
08:54:48 <xinming> SamB: thanks, I've waited the log for one day. ;-)
08:54:50 <CosmicRay> what's the canonical homepage for it?
08:54:54 <xinming> shapr: thanks
08:55:10 <shapr> @where hsp
08:55:11 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
08:55:48 <CosmicRay> hmm.  this isn't going to work for me (no support for POST)
08:55:54 <CosmicRay> I guess it is time to look at one of the CGI libs
08:56:06 <shapr> Lemmih has an extended version of HSP.
08:56:15 <shapr> I dunno if it supports POST though.
08:56:15 <CosmicRay> is that the same as bringerts?
08:56:22 <Philippa> Network.CGI supports POST...
08:56:23 <shapr> bringerts?
08:56:28 <CosmicRay> http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/Network/NewCGI.hs
08:56:35 <CosmicRay> got a url for lemmih's?
08:56:43 <shapr> That's CGI, HSP is something else entirely.
08:57:21 <CosmicRay> right, I understand
08:57:31 <CosmicRay> oh I misparsed your sentence.
08:57:38 <CosmicRay> I thought you said lemmih had a version of cgi
08:59:40 <musasabi> Lemmih's HSP has many extensions, then there is HSP with basic POST support from me.
08:59:53 <musasabi> Haskell makes it too easy to fork projects...
09:00:21 <ValarQ> is there any xhtml templating system that works good with haskell?
09:00:26 <SamB> jlouis: hmm, how are the peer threads supposed to transfer blocks of data?
09:00:54 <Philippa> musasabi: easier to make sure they're not forked though
09:01:14 <shapr> ValarQ: several
09:02:25 <ValarQ> shapr: great
09:02:55 <ValarQ> hmm, that halipeto looks ok
09:03:23 <jlouis> SamB: send them via a channel to the FS
09:03:31 <jlouis> ehm, the StorageManager
09:03:37 <SamB> jlouis: what about those to be sent?
09:03:52 <jlouis> request them via a channel from the StorageManager
09:04:21 <jlouis> Over time, we'll have the StorageManager send something which allows sendfile() to work directly on the peer thread
09:04:35 <SamB> jlouis: hmm
09:04:42 <jlouis> Better idea?
09:04:46 <SamB> no
09:04:57 <SamB> where is this storage manager?
09:05:04 <jlouis> I am actually researching a bit into an event library at the moment
09:05:16 <SamB> that sounds pretty sane actually
09:05:34 <jlouis> FS.StorageManager or something is what can end up being the storage manager
09:05:37 <jlouis> it still needs work though
09:06:02 <dcoutts> ibid, I'll probably include the soe implementation in the next gtk2hs release, if we can get it well enough tested
09:06:10 <ibid> ok
09:06:26 <ibid> well, i'm putting one or two exercises every week
09:07:14 <dcoutts> ibid, oh you mean that should be good enough testing? :-)
09:07:20 <dcoutts> you're probably right
09:07:57 <ibid> i don't know if it's enough
09:08:03 <ibid> but it does get used
09:08:05 <SamB> hmm, how do you want to deal with the bitfield message potentially sent by the peer right after handshaking?
09:08:22 <ibid> had fun with the bintree viewing program
09:09:06 <dcoutts> ibid, cool, I'd like to see it
09:09:32 <dcoutts> ibid, I'd also want to better test conformance to the semantics of the original SOE
09:10:01 <ibid> see my msg to vegai on the other chan
09:11:02 <dcoutts> ibid, yep
09:11:16 <SamB> jlouis: there seems to be a lot of overlap between what the thread manager might tell the thread and what the thread might want to tell the manager...
09:15:52 <SamB> dcoutts: what should I do when peers choke, unchoke, become interested/bored?
09:15:56 <SamB> er, jlouis 
09:24:07 <SamB> @index Handle
09:24:07 <lambdabot> System.IO
09:24:16 <SamB> @type Control.Concurrent.forkIO
09:24:16 <lambdabot> IO () -> IO GHC.Conc.ThreadId
09:25:46 <ibid> dcoutts: another jyugraphics program. i blogged about this one: http://antti-juhani.kaijanaho.info/tmp/D7_8.hs
09:26:23 <dcoutts> ibid, it looks neat :-)
09:26:54 <ibid> dcoutts: code or result?
09:26:57 <ibid> :)
09:27:03 <dcoutts> both actually
09:27:41 <ibid> there's an expression in comments, replace the in-expression above it with it and it'll look even better
09:28:53 <dcoutts> ok
09:29:38 <ibid> dcoutts: (http://antti-juhani.kaijanaho.info/blog/en/programming/frakt.html)
09:31:42 <dcoutts> ibid, yes I saw that. (which is why I said the result is pretty too :-) )
09:31:53 <Frederick> yo folks
09:32:13 <ibid> heh
09:32:26 <dcoutts> ibid, would you mind if I included this demo (or the improved version) in the gtk2hs demo collection once the soe package goes in?
09:32:28 <ibid> dcoutts: that one is the "even better" result i referred to
09:32:35 <dcoutts> ibid, ok, right
09:32:42 <ibid> dcoutts: no problem
09:32:47 <dcoutts> ibid, cool
09:33:06 <dcoutts> ibid, I'll try running it now using the cairo version :-)
09:33:43 <ibid> show me the result ;)
09:34:01 <dcoutts> will do
09:34:26 <dcoutts> I just need to unbreak by gtk2hs build tree :-)
09:34:35 <ibid> heh
09:34:37 <jlouis> SamB: the bitfield should be queried from the FS. It knows exactly what we have. We might also cache this in another thread (peer manager) for efficiency
09:34:52 <SamB> jlouis: no, I meant for the other direction
09:35:12 <jlouis> ah
09:35:27 <SamB> also, what do we do about the fact that you don't actually send entire pieces but only parts of pieces?
09:35:38 <jlouis> Put it into a map. You should be able to supply a function, have :: PieceNum -> Bool
09:36:01 <SamB> oh, I wasn't doing the manager
09:36:14 <jlouis> the peer thread should supply it.
09:36:31 <SamB> how?
09:36:49 <jlouis> Its good questions, but I do not know how to answer them all
09:36:55 <SamB> hmm
09:37:05 <SamB> also I'm wondering what to do if the first message is something else...
09:37:48 <Frederick> folks have anyone here ever implemented somethign as a transitive closure?
09:37:51 <jlouis> well, the peer thread gets a BitField from the peer and forms have :: PieceNum -> Bool and updates it accordingly. It is used by the InterestThread 
09:38:10 <jlouis> for requesting the next piece (we want to request something the peer has)
09:38:30 <SamB> oh, good point...
09:38:33 <SamB> requests...
09:39:11 <jlouis> part of pieces: Sending/Recieving: We'll have to figure that out
09:39:30 <jlouis> it has to change some semantics in the FS.* in a bad way. So is the world of coding...
09:39:38 * joelr1 feels like a haskell guinea pig these days
09:40:10 <lisppaste2> joelr1 pasted "Spurious crash" at http://paste.lisp.org/display/13667
09:40:20 <joelr1> any ideas?
09:42:21 <shapr> joelr1: At least #haskell tech support is cheaper and more fruitful than the average Microsoft tech support interaction.
09:42:31 <joelr1> yeah
09:42:40 <JKnecht> isn't everybody (a haskell guinea pig)?
09:42:58 <joelr1> i'm starting to look like an ass for implementing things in haskell, though :(
09:43:02 <Frederick> folks how can I emulate an operation like list pushback in haskell?
09:43:17 <shapr> How do you pushback a list?
09:43:18 <joelr1> JKnecht: possibly but i seem to get more than a fair share of issues on my first project
09:43:36 <Frederick> shapr, abc pusbach d -> abcd
09:43:51 <eivuokko> Frederick, usual way is to construct list either using continuations or just making list wrong way around and using reverse on it at last.
09:43:53 <shapr> Isn't that like "abc" ++ "d" ?
09:44:14 <shapr> joelr1: Think it would have been easier if you'd known Haskell beforehand?
09:44:38 <joelr1> shapr: if i did i would not have chosen it for this application :P
09:44:39 <Frederick> shapr, yes that is it thx
09:44:52 <joelr1> different tools for different things
09:44:53 <shapr> joelr1: It's true though, you are definitely getting more than your fair share of problems.
09:45:12 <joelr1> shapr: any idea why that is?
09:45:20 <dcoutts> ibid, oh cool. It get's more complex the larger the you make the window
09:45:51 <ibid> :)
09:46:02 <SamB> Frederick: really, you probably just want to use a backwards list
09:46:05 <ibid> now, just add some interaction to control the cutoff length :)
09:46:33 <Frederick> SamB, why?
09:46:48 <shapr> joelr1: Other than the GHC bugs, I think you need to test things in isolation first.
09:46:59 <SamB> Frederick: because (:) is O(1) whereas (++) is O(n) in its first argument?
09:47:23 <joelr1> shapr: makes sense but i'm sort of isolating things already
09:47:29 <Frederick> SamB, I dont care about the program complexity :p
09:47:36 <SamB> Frederick: okay then ;-)
09:47:38 <joelr1> shapr: how more isolated can you get in an app that just sends and receives binary packets?
09:47:41 <shapr> joelr1: I use spike solutions and test-driven-development. I think that sort of thing will really speed up your development.
09:47:42 <joelr1> shapr: but i do see your point
09:48:15 <joelr1> shapr: i did that with erlang on the poker project. felt like i did not have time for it with haskell and it truly bit me in the ass
09:48:15 <dcoutts> ibid, http://haskell.org/~duncan/cairo/frakt.png
09:48:19 <Frederick> SamB, hm... should I create new list for each step of recursion?
09:48:28 <SamB> well, if you are using it as a stack it is also more convenient to pop a value off that way...
09:48:29 <shapr> joelr1: That sort of thing makes more time, it doesn't cost time.
09:48:31 <SamB> Frederick: in what?
09:48:38 <ibid> dcoutts: hmm, looks good
09:49:08 <dcoutts> ibid, yeah the lines are clearer with cairo because of the anti-alising
09:49:13 <Frederick> SamB, Im thinking about that algorithm lemme re-paste it
09:49:44 <ibid> dcoutts: try lowering the cutoff length, please
09:50:10 <shapr> joelr1: At least, in the term of a week or more of development, tests and spikes always save time. That's my experience at least.
09:50:15 <dcoutts> ibid, where do I set that?
09:50:26 <joelr1> shapr: i agree with you
09:50:30 <ibid> dcoutts: it's the number compared with the dist(...)
09:50:35 <ibid> dcoutts: in a guard
09:51:04 <dcoutts> ibid, oh I see, it's 10 now. What do you suggest? 5?
09:51:11 <ibid> try differemy
09:51:14 <ibid> nt values
09:51:37 <ibid> lower values created a mess with gdk, maybe cairo does better
09:53:03 * SamB goes to walk dog
09:53:53 <dcoutts> ibid, with 5: http://haskell.org/~duncan/cairo/frakt2.png
09:54:17 <ibid> yeah, much better than with gdk
09:54:20 <ibid> whaht about 1?
09:54:24 <dcoutts> ibid, with 5 it's pretty slow :-)
09:54:32 <dcoutts> I'll try 1
09:54:34 <ibid> heh
09:54:51 <lisppaste2> Frederick pasted "tricky recursion" at http://paste.lisp.org/display/13668
09:55:24 <dcoutts> ibid, I'll try with -O to see if it's faster :-)
09:56:20 <xerox> hey.
09:56:31 <ibid> it didn't feel too slow with 1 when i tried it
09:57:35 <ibid> ok, i now know why
09:57:46 <ibid> i never tried it with the prettier code
09:57:58 <ibid> the uglier is also simpler
10:00:07 <ibid> 3 is fairly fast
10:05:31 <dcoutts> ibid, well with 1 it took about 10 min cpu time :-)
10:05:54 <dcoutts> http://haskell.org/~duncan/cairo/frakt3.png
10:05:59 <ibid> that's strange
10:06:14 <ibid> with 1 it takes me less than a minute real time
10:06:41 <ibid> and it doesn't look much better with cairo
10:06:44 <ibid> 5 was good
10:07:49 <dcoutts> ibid, wow. cairo is pretty but slow.
10:07:59 <dcoutts> I just re-ran it using gdk
10:08:06 <dcoutts> it took 3 sec :-)
10:08:24 <dcoutts> err 4.5 sec
10:08:36 <dcoutts> but anyway, that's rather a big difference
10:08:57 <ibid> yeah
10:09:10 * dcoutts wonders at the optimisation of RENDER in my X server
10:10:56 <dcoutts> http://haskell.org/~duncan/cairo/frakt3-gdk.png
10:11:25 <ibid> anyway, it's too small
10:11:32 <ibid> 3 or 5 is good
10:12:12 <xerox> woot, what are you drawing this time?
10:12:28 <dcoutts> http://haskell.org/~duncan/cairo/frakt2.png
10:12:29 <dcoutts> http://haskell.org/~duncan/cairo/frakt2-gdk.png
10:12:35 <dcoutts> that's with 5
10:13:09 <dcoutts> xerox, the first one there is with cairo
10:13:17 <dcoutts> it looks nicer but is a lot slower :-)
10:13:24 <xerox> :-|
10:13:39 <ibid> how's 3 with cairo?
10:18:22 <dcoutts> 3 is not too bad
10:18:31 <dcoutts> oh wait a sec, that was 5
10:18:38 <xerox> Howdy pesco
10:19:30 <dcoutts> ibid, with 3 it's 5 seconds with cairo
10:19:30 <pesco> Howdy xerox, what's up?
10:19:56 <xerox> Tiredness inside, Kierkegaard outside.  Groan.
10:19:57 <ibid> and looks like?
10:21:14 <JKnecht> xerox sounds like a sick and tired sammich :)
10:24:22 <xerox> JKnecht: sammich ~= sandwich ‽
10:26:06 <dcoutts> ibid, http://haskell.org/~duncan/soe-demo/frakt4.png
10:26:53 <ibid> mm
10:26:55 <ibid> +h
10:27:07 <ibid> 4? ;)
10:28:51 <dcoutts> ibid, I've renamed them all so they make sense: http://haskell.org/~duncan/soe-demo/
10:29:23 <ibid> i mean, 3 is smudgy, 5 is perhaps too large, 4 might be good
10:30:01 <SamB> dcoutts: how would you implement something like a shell or a repl?
10:30:14 <dcoutts> SamB, huh?
10:30:59 <SamB> should I say like a terminal?
10:31:18 <SamB> its for that z-machine interpretr
10:31:25 <jlouis> dcoutts: the RENDER extension allows you to offload some parts of rendering to the GFX card. For instance, you can upload glyphs to the card and let it antialias part of them
10:35:04 <dcoutts> jlouis, well specificaly it offloads it to the X server which might be able to accelerate it by offloading it to the GFX card. Otherwise the X server does it in software.
10:35:16 <SamB> the reason I can't just use stdin/stdout is that I need to implement word wrap and a status area, and I want to do line editing
10:35:46 <jlouis> dcoutts: ah, thanks for the clarificatoin
10:35:49 <jlouis> ion*
10:35:54 <ibid> dcoutts: my X seems to implement RENDER only if hwaccel is enabled
10:36:44 <autrijus> @seen sons
10:36:45 <lambdabot> I haven't seen sons.
10:36:46 <autrijus> @seen dons
10:36:47 <lambdabot> dons is in #haskell-overflow and #haskell. Last spoke 4 hours, 6 minutes
10:36:47 <lambdabot> and 28 seconds ago.
10:37:06 <SamB> dcoutts: have you ever played an Infocom game?
10:37:13 <dcoutts> SamB, nope
10:37:56 <shapr> Be careful, they're addictive.
10:38:19 <SamB> anybody else have any idea how to implement a terminal-like interface?
10:38:36 <dcoutts> ibid, mine's got RENDER and dri and accel is working so I don't know why the cairo method is so slow.
10:38:55 <shapr> SamB: Look at the early Yi versions, and ginsu
10:39:19 <ibid> i don't have accel on because it breaks on suspend
10:39:19 * jlouis is pondering an Event library on Arrows
10:39:31 <jlouis> if it implements enough arrows, it might even be a monad
10:39:31 <SamB> basicly there is an unscrollable monospaced positionable-cursor area at the top
10:39:48 <SamB> and a scrollable area below that
10:39:59 <jlouis> it makes me wonder... does GHC has arrows in it by default, or do I have to download something?
10:40:07 <shapr> GHC has arrows by default.
10:40:44 <SamB> and the bottom line of the scrollable area accepts text from the user
10:40:54 <jlouis> shapr: ok, cool
10:40:58 <shapr> SamB: Do you want a gui?
10:41:05 <Cale> shapr: yeah, I spent a while working on it (HaskellNewbie) a while back.
10:41:10 <SamB> shapr: I honestly don't care that much.
10:41:13 <shapr> Or just multiple curses panes like ginsu?
10:41:25 <shapr> Cale: Hey, any idea who wrote QuickCheckExts?
10:41:30 <SamB> well, I want not to have to write all the nasty parts ;-)
10:41:45 <shapr> Oh, good news, QuickCheck 2 will be GPL, and released sometime soon.
10:41:50 <SamB> and I would like if you could scroll back up some
10:41:55 <shapr> SamB: Look at ginsu and its ncurses then.
10:42:01 <Cale> I'm not sure -- I was looking through OrphanedPages, and noticed that they were in a subpage of the IRC paste page
10:42:06 <shapr> You'd only have to do some of the nasty parts.
10:42:06 <SamB> @where ginsu
10:42:07 <lambdabot> http://repetae.net/john/computer/ginsu/
10:42:41 <SamB> well, yeah, I figured I'd have to do some...
10:43:08 <SamB> oh. did I mention that color is nice?
10:43:39 <shapr> You get color too from ncurses.
10:44:11 <SamB> yeah, but I have no idea how ginsu works so ;-)
10:44:30 <shapr> The first versions of Yi used the curses binding from ginsu, so you may want to look there.
10:49:19 <araujo> Hello!
10:49:21 * araujo in love
10:49:57 <SamB> shapr: so which code would I be wanting to steal?
10:50:25 <basti_> araujo: with whom?
10:50:46 <pesco> Wuh, so much to reeeaad.
10:51:00 <shapr> SamB: The ncurses binding that yi and ginsu have in common. That'll give you the text windows you want.
10:51:06 <shapr> pesco: reading what?
10:51:42 <pesco> shapr: Haskell-embedded Prolog.
10:51:54 <shapr> Where's that?
10:51:56 <araujo> basti_, with some nice girl from the univ. :-D
10:52:11 <basti_> araujo: thats offtopic then.
10:52:16 <basti_> ;)
10:52:23 <pesco> And I still need to read lots of stuff about continuations.
10:52:24 <araujo> basti_, I am also in love with Haskell 
10:52:28 <pesco> shapr: Want my link-list?
10:52:28 <araujo> :-]
10:52:37 <shapr> Sure
10:52:50 <shapr> Or just put it onto del.icio.us
10:52:53 * araujo throws sweet lambdas at everyone
10:53:09 <pesco> delicious?
10:53:10 * pesco looks.
10:53:27 <SamB> shapr: so should I steal the one from the initial import of ginsu, or what?
10:53:35 <basti_> we need jelly babys in lambda shape
10:53:56 <shapr> pesco: for example, http://del.icio.us/shapr
10:54:20 <pesco> Coohool.
10:54:39 <shapr> SamB: Nah, steal the one from the initial import of Yi, or see if the current Yi curses binding is easily hacked into what you want. It surely does windowing, right?
10:55:03 <SamB> isn't Yi GPL'd?
10:55:11 * shapr doesn't know
10:55:24 <SamB> yes
10:57:25 <SamB> nevermind that I already have the Yi curses bindings in my repo...
10:57:29 <SamB> I guess it doesn't really matter
10:57:48 <SamB> curses seems awful clumsy though
10:58:20 <shapr> Silly question... I like to send urls to firefox from emacs and the command line. I don't like popping up a new tab, and I don't like using an existing tab. I'd rather have a named tab popup if it doesn't exist, and have sent urls show up there if it does exist. Anyone know how to do this?
10:58:48 <jlouis> \x -> throwTo araujo x
10:58:57 <jlouis> ehm
10:59:06 <jlouis> throwTo araujo (\x -> sweet x)
10:59:08 <jlouis> rather
10:59:18 <shapr> I guess I could make an ajaxy local app that gets the send url events and reloads a single tab.
10:59:38 <shapr> What sort of interapp msging is in Linux? Can I send urls to firefox via dbus?
11:00:30 <dcoutts> shapr, firefox doesn't really integrate with gnome. I don't think it uses dbus.
11:00:49 <dcoutts> shapr, it has it's own solution for sending urls to it
11:01:06 <SamB> an ancient solution
11:01:58 <dcoutts> shapr, mozilla -remote <command>
11:02:05 <SamB> dcoutts: um.
11:02:11 <dcoutts> shapr, I think it can run any javascript thingy
11:02:15 <SamB> "mozilla"?
11:02:23 <dcoutts> same for firefox I expect
11:03:11 <SamB> % firefox -remote 'cmd'
11:03:11 <SamB> auto selected locale: en-US
11:03:11 <SamB> Error: Failed to send command: 500 command not parsable: cmd
11:03:44 <shapr> I'm using firefox -remote right now, but it doesn't do much.
11:04:15 <shapr> SamB: You need to send openUrl('http://www.haskell.org/')
11:04:42 <SamB>        -remote command
11:04:42 <SamB>               Execute command in an already running Mozilla process.  For more
11:04:42 <SamB>               info, see: http://www.mozilla.org/unix/remote.html
11:05:12 <xinming> @pase
11:05:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:05:35 <xinming> It's intelligent.
11:05:50 <SamB> no, not really
11:05:53 <xinming> @paste
11:05:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:05:56 <SamB> not too long ago
11:05:56 <SamB> @quat
11:05:56 <lambdabot> Not enough privileges
11:06:03 <SamB> actually worked
11:06:04 <xinming> @exit
11:06:04 <lambdabot> Maybe you meant: elite quit
11:06:10 <xinming> @elite quit
11:06:10 <lambdabot> qUi+
11:06:19 <psi> heh
11:06:22 <xinming> where is the paste page?
11:06:35 <SamB> though @quit gave the error
11:07:06 <SamB> lisppaste2: help
11:07:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:08:29 <lisppaste2> xinming pasted "can't parse :-/" at http://paste.lisp.org/display/13671
11:10:29 <xinming> > let tmp f xs = [ a | a <- xs, f a ] in (\x -> if x`mod`2 == 0 then x else 0 ) [1..100]
11:10:30 <lambdabot>  add an instance declaration for (Integral [a])
11:12:30 <Cale> are you sure you don't want to map that function over the list?
11:12:38 <Cale> > let tmp f xs = [ a | a <- xs, f a ] in map (\x -> if x`mod`2 == 0 then x else 0 ) [1..100]
11:12:39 <lambdabot> [0,2,0,4,0,6,0,8,0,10,0,12,0,14,0,16,0,18,0,20,0,22,0,24,0,26,0,28,0,30,0,
11:12:39 <lambdabot> 32,0,34,0,36,0,38,0,40,0,42,0,44,0,46,0,48,0,50,0,52,0,54,0,56,0,58,0,60,
11:12:39 <lambdabot> 0,62,0,64,0,66,0,68,0,70,0,72,0,74,0,76,0,78,0,80,0,82,0,84,0,86,0,88,0,
11:12:39 <lambdabot> 90,0,92,0,94,0,96,0,98,0,100]
11:12:58 <Cale> also, you're not using tmp at all
11:13:26 <Cale> > let tmp f xs = [ a | a <- xs, f a ] in tmp (\x -> if x`mod`2 == 0 then x else 0 ) [1..100]
11:13:26 <lambdabot>  add an instance declaration for (Integral Bool)
11:13:47 <Cale> > let tmp f xs = [ a | a <- xs, f a ] in tmp (\x -> if x`mod`2 == 0 then True else False ) [1..100]
11:13:48 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
11:13:48 <lambdabot> 52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
11:13:48 <lambdabot> 100]
11:13:53 <Cale> tmp = filter
11:14:17 <Cale> > filter (\x -> if x`mod`2 == 0 then True else False ) [1..100]
11:14:19 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
11:14:19 <lambdabot> 52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
11:14:19 <lambdabot> 100]
11:14:35 <Cale> of course, that's a silly if now
11:14:44 <xinming> Cale: thanks, I just wish to write some small function which will test my understanding of haskell. 
11:14:45 <Cale> > filter (\x -> x`mod`2 == 0 ) [1..100]
11:14:46 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
11:14:46 <lambdabot> 52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
11:14:46 <lambdabot> 100]
11:14:47 <ulfdoz> What's the difference to [2,4..100]?
11:15:05 <Cale> > filter (\x -> x`mod`2 == 0 ) [1..100] == [2,4..100]
11:15:07 <lambdabot> True
11:15:22 <int-e> > all even [2,4..100]
11:15:23 <lambdabot> True
11:15:40 <Cale> > filter even [1..100]
11:15:41 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
11:15:41 <lambdabot> 52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
11:15:41 <lambdabot> 100]
11:18:20 * xinming wonders why tmp is needed after 'in'
11:18:32 <Cale> needed?
11:18:47 <Cale> Well, you ought to do something with it, or the let is pointless
11:18:57 <Cale> you might as well not define it in the first place
11:19:08 <xinming> got it.
11:19:22 <Cale> the other reason is that the types won't match if you just try to apply that function to the list
11:19:47 <pesco> shapr: http://del.icio.us/pesko/haskell-prolog
11:20:37 <pesco> Ah, or
11:20:41 <pesco> http://del.icio.us/pesko/prolog+haskell
11:20:57 <SamB> oh great, routing problems between Europe and the US...
11:22:13 <jlouis> SamB: heh, where and who is it?
11:22:18 <jlouis> Cogent/Level3?
11:22:28 <SamB> jlouis: lilo didn't say!
11:22:33 <basti_> SamB: again?!
11:22:45 * jlouis you can now assess I work for an ISP ;)
11:23:02 <SamB> basti_: maybe not
11:23:08 <SamB> it was from an hour ago
11:23:24 <SamB> no wait.
11:23:25 <SamB> 13
11:23:30 <basti_> http://scoreboard.keynote.com/scoreboard/Main.aspx?Login=Y&Username=public&Password=public
11:23:33 <xinming> > filter (\x -> if x`mod`3 then True else False) [1..100]
11:23:34 <lambdabot>  add an instance declaration for (Integral Bool)
11:23:34 <lambdabot>   In the predicate expression: x `mod` 3
11:23:34 <lambdabot>   In a lambda abstraction: \ x -> if x `mod` 3 then True else False
11:23:41 <basti_> wah
11:23:43 * xinming scraches his head. :-/
11:24:19 <basti_> xinming: what type is x`mod`3?
11:24:21 <jlouis> x must be an integral value
11:24:35 <basti_> (use the facilities of interactive environments to find out)
11:24:36 <jlouis> ie, one where it makes sense to take `mod` on
11:24:41 <SamB> what is the if for?
11:25:03 <jlouis> SamB: heheh, the if is certainly superflous
11:25:12 <xinming> basti_: oops. thanks.
11:25:14 <xinming> :-)
11:25:16 <basti_> there is even something missing
11:25:31 <jlouis> > filter (\x -> x `mod` 3) [1..10]
11:25:31 <lambdabot>  add an instance declaration for (Integral Bool)
11:25:31 <lambdabot>   In a lambda abstraction: \ x -> x `mod` 3
11:25:36 <SamB> > filter (\x -> x`mod`3 == 0) [1..100]
11:25:37 <lambdabot> [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,
11:25:37 <lambdabot> 78,81,84,87,90,93,96,99]
11:25:49 <jlouis> argh!
11:25:51 <basti_> @pl x `mod` 3 == 0
11:25:52 <lambdabot> x `mod` 3 == 0
11:25:59 <basti_> @pl \x->x `mod` 3 == 0
11:25:59 <lambdabot> (0 ==) . (`mod` 3)
11:26:00 <xinming> It is strong type. :-/ won't help you make easy program. :'(
11:26:02 <basti_> ^^
11:26:16 <basti_> >filter ((0 ==) . (`mod` 3)) [1..100]
11:26:18 <xinming> make program easy. :-/
11:26:21 <basti_> > filter ((0 ==) . (`mod` 3)) [1..100]
11:26:23 <lambdabot> [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,
11:26:23 <lambdabot> 78,81,84,87,90,93,96,99]
11:26:29 <SamB> xinming: no, its just that you can't cheat like in C and Python
11:26:30 <basti_> but it IS easy, isn't it?
11:26:52 * jlouis mumbles something about unsafePerformIO
11:27:09 <SamB> jlouis: that is a different kind of cheating
11:27:22 <jlouis> SamB: ;)
11:27:52 <pesco> Haskell easily good, C easily bad.
11:27:52 <basti_> > filter ((0==).(flip mod 3)) [1..100]
11:27:53 <lambdabot> [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,
11:27:53 <lambdabot> 78,81,84,87,90,93,96,99]
11:27:59 <basti_> flip mo squad!
11:28:31 <SamB> > filter ((0==).(`mod`3)) [1..100]
11:28:32 <lambdabot> [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,
11:28:32 <lambdabot> 78,81,84,87,90,93,96,99]
11:28:47 <pesco> recip . exp . succ . negate
11:29:18 <SamB> pesco: what does that do
11:29:22 <SamB> ?
11:29:34 <pesco> SamB: I think it's an S-curve or something.
11:29:48 <basti_> > (recip . exp . succ . negate) 10
11:29:49 <lambdabot> 8103.083927575383
11:29:54 * basti_ shrugs
11:30:08 <ulfdoz> Is it easier. [3 * x| x <- [1..], 3*x < 100]
11:30:10 <pesco> > (recip.exp.succ.negate) 1
11:30:11 <lambdabot> 1.0
11:30:19 <pesco> > (recip.exp.succ.negate) 0
11:30:20 <lambdabot> 0.36787944117144233
11:30:49 <pesco> Well, not an S-curve.
11:30:53 <basti_> no
11:31:21 <SamB> map (recip.exp.succ.negate) [-1,-0.9..2]
11:31:25 <SamB> > map (recip.exp.succ.negate) [-1,-0.9..2]
11:31:27 <lambdabot> [0.1353352832366127,0.14956861922263506,0.16529888822158653,0.1826835240527
11:31:27 <lambdabot> 346,0.2018965179946554,0.22313016014842985,0.24659696394160643,0.2725317930
11:31:27 <lambdabot> 3401254,0.301194211912202,0.3328710836980795,0.3678794411714422,0.
11:31:27 <lambdabot> 406569659740599,0.44932896411722145,0.49658530379140936,0.5488116360940263,
11:31:27 <lambdabot> 0.6065306597126332,0.6703200460356391,0.7408182206817175,0.8187307530779816
11:31:28 <lambdabot> [4 @more lines]
11:31:42 <SamB> > map (recip.exp.succ.negate) [-1,-0.5..2]
11:31:44 <lambdabot> [0.1353352832366127,0.22313016014842985,0.36787944117144233,0.6065306597126
11:31:44 <lambdabot> 334,1.0,1.6487212707001282,2.718281828459045]
11:32:23 <danY2K> hey guys. im a complete noob to haskell, i love it already ;-). now im supposed to prog a function which looks like this: foo :: (a->Bool)->[a]->[a]. im not getting the hang of this (a -> Bool). what does this mean? a function? as parameter?
11:32:43 <Muad_Dib> danY2K: indeed :D
11:32:45 <basti_> danY2K: yes exactly.
11:33:01 <Muad_Dib> danY2K: you are already experiencing the powers of haskell :D
11:33:12 <pesco> Welcome to the functional land, where everyone is happy.
11:34:29 <Frederick> pesco, Im not :p
11:34:45 <pesco> danY2K: The distinctive trait of functional languages is exactly that they support functions as "first-class citizens", i.e. you can pass them around as ordinary values.
11:34:47 <basti_> Frederick: you know the HSU office?
11:34:56 <Frederick> basti_, HSU?
11:35:04 <basti_> @wtf hsu
11:35:06 <lambdabot> No match for "hsu".
11:35:06 <danY2K> Muad_Dib, thx. but one thing: i programmed a function bar:: a -> bool and then typed foo (bar a) [1..10] but it still gives me that error that my bar function doesnt go from a -> Bool... ;-)
11:35:12 <basti_> there is no HSU :(
11:35:25 <xinming> well, the language which will kick your brain into the hell... :-/  It's amazing few line can do many things, But the problem is, It might take more time to think to write it down. (maybe to a newbie like myself)
11:35:26 <Frederick> @google HSU
11:35:27 <lambdabot> http://www.hsuresearch.com/
11:35:41 <pesco> danY2K: And of course, you can construct functions as regular values. That's what lambda does.
11:35:54 <Frederick> xinming, yep this is the point :)
11:37:35 <basti_> xinming: so do you feel comfortable with higher order functions?
11:38:15 <dcoutts> boegel, I got the HaskLS running much faster.
11:38:15 <xinming> basti_: yes, I do, as It is a bit like a pointer to a function like c.
11:38:32 <basti_> xinming: it's more!
11:38:41 <dcoutts> boegel, http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-DisplayLists.html
11:38:42 <Frederick> xinming, fre your mind of c :p
11:38:43 <basti_> xinming: did you ever hear about currying?
11:38:43 <danY2K> yeah thats what i like in haskell - these language is made for lists in a syntax which is mostly intitive...
11:39:09 <basti_> @type (+)
11:39:11 <lambdabot> forall a. (Num a) => a -> a -> a
11:39:12 <basti_> @type (+) 1
11:39:13 <lambdabot> forall a. (Num a) => a -> a
11:39:14 <basti_> @type (+) 1 2
11:39:15 <lambdabot> forall a. (Num a) => a
11:39:15 <dcoutts> boegel, OpenGL display lists allow you to record a sequence of OpenGL calls and then play them back later.
11:39:23 <basti_> see whats going on?
11:39:58 <dcoutts> boegel, so we can record the tree vertex list as a display list. Then when we animate we can just call the dispaly list (though we still do the rotation first)
11:40:17 <dcoutts> boegel, cpu usage is about 1/2 of what it was.
11:40:17 <xinming> basti_: hmm, In my understanding, currying is a bit like make a function which needs 2 arguments with one of them initialized. :-)
11:40:34 <basti_> xinming: kinda, yes.
11:40:47 <danY2K> got it now pesco your explanation was the right thing i needed ;-)
11:40:51 <basti_> xinming: do you understand what's meant by "-> is right associative"?
11:40:52 <xinming> well, What I have to say, Is with the traditional mind filled with different names. :-)
11:41:20 <xinming> basti_: not exactly, But still need to learn.
11:41:39 <basti_> a->b->c = a->(b->c)  !=  (a->b)->c
11:42:05 <lisppaste2> Frederick pasted "Dumb Approach?" at http://paste.lisp.org/display/13672
11:42:06 <basti_> thats important to understand what's going on with these braces
11:42:07 <dcoutts> boegel, that's when using hardware acceleration of course :-). with software rendering X takes 90% cpu and haskels takes 2%. With direct accelerated rendering haskels takes 20% cpu.
11:42:47 <SamB> Frederick: but does it work?
11:44:17 <Frederick> SamB, the parts before the last function work but this last algorithm is wierd
11:44:53 <Frederick> SamB, the ways I think about it it heads to an infinite loop
11:45:39 <xinming> basti_: So, we can make a function with only one value "initialized" in above example?
11:46:06 <xinming> basti_: hmm, No, for returned function.
11:46:20 <basti_> xinming: read these type specifications like: "a -> b" = "function that gives me a 'b' for an 'a'"
11:46:33 <SamB> Frederick: hmm.
11:46:35 <Frederick> SamB, it I take the list head I cant recover it, so it is not practical, maybe I could try to use a treee
11:46:45 <basti_> then a->b->c is a function that gives you a function (b->c) when you give it an a
11:47:06 <basti_> see that?
11:47:09 <Frederick> SamB, but a tree has the infinite recursion problem, Ive wondered about a graph approach
11:48:13 <xinming> myadd a b = (+) then, we can use (myadd a) which will act like a function?
11:48:25 <xinming> basti_: Hope I am right. :-/
11:48:34 <basti_> yes right
11:48:43 <basti_> kinda
11:48:47 <xinming> :-)
11:48:53 <basti_> > let myadd a b = a + b in myadd 2 3
11:48:54 <lambdabot> 5
11:48:59 <basti_> or even:
11:49:11 <basti_> > let myadd a b = a + b; add2 = myadd 2 in add2 7
11:49:12 <lambdabot> 9
11:49:28 <basti_> > let myadd = (+); add2 = myadd 2 in add2 7
11:49:29 <lambdabot> 9
11:49:35 <mauke> f x y is parsed as ((f x) y)
11:49:40 <basti_> > let add2 = (+2) in add2 7
11:49:41 <lambdabot> 9
11:49:46 <basti_> > (+2) 7
11:49:47 <lambdabot> 9
11:49:48 <xinming> a bit hard to understand.
11:49:55 <xinming> > (-2) 7
11:49:55 <lambdabot>  add an instance declaration for (Num (t -> a))
11:49:55 <lambdabot>   In the definition of `xxxx': xxxx = (- 2) 7
11:49:55 <lambdabot>   In the definition of `v': v = let xxxx = (- 2) 7 in take 2048 (show
11:49:55 <lambdabot> xxxx)
11:50:06 <basti_> that doesnt work.
11:50:07 <mauke> - is weird
11:50:11 <basti_> because it is parsed as "unary -"
11:50:18 <basti_> > -7
11:50:18 <xinming> > ((-) 2) 7
11:50:19 <lambdabot> -7
11:50:20 <lambdabot> -5
11:50:31 <xinming> > ((-) 2) 7
11:50:31 <lambdabot> -5
11:50:40 <basti_> now you can't reach the second parameter of (-) directly
11:50:43 <mauke> > (flip (-) 2) 7
11:50:43 <basti_> but you could:
11:50:44 <lambdabot> 5
11:50:46 <basti_> yep
11:50:48 <Frederick> SamB, half of the problem is solved using a map concat but I need to know somehow, oki Ive searched the whole productions tree
11:51:06 <basti_> (/7) 1
11:51:09 <basti_> argh
11:51:10 <basti_> > (/7) 1
11:51:11 <SamB> Frederick: I'm doing the transitive closure now
11:51:12 <lambdabot> 0.14285714285714285
11:51:15 <basti_> > (7/) 1
11:51:16 <lambdabot> 7.0
11:51:18 <Frederick> hm
11:51:20 <basti_> works as expected though
11:51:30 <xinming> hmm, by the way, How to read haskell in English?
11:51:41 <basti_> uh?
11:52:10 <xinming> the a is pronounced like name or cap?
11:52:14 <xerox> > (subtract 2) 7
11:52:15 <lambdabot> 5
11:52:41 <basti_> hmm neither I'd say ^^
11:52:45 <shapr> jlouis: Did you send an entry for Conjure to HC&AR?
11:53:24 <xinming> if follow the rule which e after an 'a', we need to pronounce it heis kl
11:53:41 <SamB> huh, how in the world do you DO transitive closure?
11:53:54 <xinming> otherwise, we'll need to pronounce it 'has kel'
11:54:05 <basti_> xinming: i fear that english pronunciation isn't based on strict rules.
11:54:12 <Frederick> SamB,Ive implemented it once for graphs in C, you need a list of pendend evaluations
11:54:16 * xerox prefers 'has kel'
11:54:29 <SamB> I better try using this version before assuming it doesn't work...
11:54:57 <shapr> I heard SPJ say HASkl
11:55:26 <xinming> basti_: hmm, there are rules to many words, and my primary teacher told me for remember word more easily... But the problem is, I know that the some words won't obey the rule. :-/
11:55:26 <shapr> I have a great idea, let's get SPJ to pronounce Haskell for the next issue of The Monad.Reader.
11:55:32 <pesco> Yes!
11:55:55 <basti_> lol
11:56:01 <SamB> when I say Haskell, poeple think I say pascal
11:56:11 <xinming> :-)
11:56:13 <pesco> Hi, my name is SPJ and I pronounce Haskell as Haskell.
11:56:23 <xinming> heis cal, pas cal 
11:56:44 <pesco> I'd think heis cal  is wrong.
11:56:48 <xinming> SamB: they might say your not an English speaker :-P
11:57:14 <SamB> xinming: no, but they didn't say whether they thought I was mispronouncing Pascal or not
11:57:38 <SamB> I probably would though
11:59:28 <SamB> *CFG> transitiveClosure (Map.fromList [(1, 2), (2, 3)])
11:59:28 <SamB> {1:=3,2:=3}
11:59:33 <SamB> that is right, right?
12:00:10 <SamB> hullo?
12:00:11 <Frederick> hm
12:00:42 <Frederick> dont hink so
12:00:54 <SamB> I mean, thats what transitive closure is supposed to be, isn't it?
12:00:58 <shapr> pesco: Oh, good idea!
12:01:06 <Frederick> like transitive closure of a given relation as A->B B->C
12:02:24 <SamB> what is transitive closure?
12:02:42 <Frederick> the transitive closure of A is the set of all elements directly or indireclty related to A, transitive closure A1 = {all elements directly related to A + transitive closure of elements direclty related to elements related to elements related to elements related to A}
12:03:03 <Frederick> Ive reapeated some related to :p
12:05:45 <Frederick> SamB, http://www.cs.odu.edu/~toida/nerzic/content/relation/closure/closure.html
12:05:49 <SamB> hmm.
12:06:01 <SamB> somebody who knows more maths than me, what is that that I have there?
12:06:12 <SamB> transitiveClosure m = result
12:06:13 <SamB>     where 
12:06:13 <SamB>     result = Map.map (\x -> case Map.lookup x result of
12:06:13 <SamB>                             Nothing -> x
12:06:13 <SamB>                             Just y  -> y) m
12:07:07 <pesco> shapr: Hm, but better yet, we should hunt down a descendant of Haskell Curry himself and have him/her provide truly canonical information.
12:07:51 <SamB> pesco: but we want to know how to pronounce the name of the language, not the name of the guy
12:08:12 <pesco> SamB: Well, they should be pronounced the same.
12:08:27 <pesco> SamB: Because the language is named after the guy.
12:08:49 <SamB> pesco: anyway, what is this function that I have really calculating, now that I know it doesn't do transitive closure?
12:13:33 <Frederick> SamB, http://img210.imageshack.us/my.php?image=closure4ja.png
12:13:55 <Frederick> like a sample for transitive closure is ancestor-descendant
12:14:26 <Frederick> given your grandfather is related to you grandfather throught the family relation
12:14:47 <Frederick> woop your grandfather is relatd to your father
12:15:58 <Frederick> and you are related to your father throught the family relation, so the transitive closure of the family relation for your grandfather is your grandfather him self (since he is a member of his own family), your father, and you (through the transitive closure
12:18:12 <Frederick> pesco, is my definition at least understandable?
12:18:40 <SamB> Frederick: yes, it is understandable.
12:19:03 <SamB> I would just fix my implementation, except I don't know that we actually want the transitive closure...
12:19:57 <pesco> SamB: As far as I _read_ that function, for each point in the map, it takes one step along the relation.
12:20:11 <SamB> pesco: hmm.
12:20:31 <SamB> *CFG> transitiveClosure (Map.fromList [('A', 'B'), ('B', 'C'), ('C', 'D')])
12:20:31 <SamB> {'A':='D','B':='D','C':='D'}
12:20:40 <SamB> that doesn't look like one step to me
12:20:58 <Frederick> cause the set of all non-terminals and productions reached via a non terminal is its transitive closure, to remove a useless symbol like S -> A , A -> a we in fact need S-> a since A doesnt adds real info for the rule
12:21:03 <pesco> Frederick: I'm not sure if one ever talks about the transitive closure of elements. Does one?
12:21:28 <Frederick> but given the pairs (S,A), (A,a) we have the trasitive closure of A
12:21:37 <Frederick> pesco, what doyou mean?
12:22:37 <musasabi> SyntaxNinja: Is Cabal not reading buildinfo-files with the haddock command fixed?
12:23:41 <pesco> Er, let's just say, the transitive closure of a relation R is defined as the set {(a,b) | there is a path from a to b in R}.
12:27:57 <SamB> yes, but, what have I got there?
12:28:24 <Frederick> SamB, it is kind of a list of reachable elements
12:28:58 <pesco> The "edge" of the relation, I'd say.
12:29:50 * SamB just calls it "f"
12:33:45 <SamB> @hoogle k -> a -> Data.Map.Map k a -> a
12:33:47 <lambdabot> No matches, try a more general search
12:34:14 <SamB> @hoogle Data.Map.Map k a -> a
12:34:15 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
12:34:15 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:34:15 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
12:47:52 <Frederick> pesco, how do i read this definitions the boot gives
12:47:55 <Frederick> ?
12:49:13 <Frederick> bah moms is calling bb asap (may tke ~3 hours)
13:12:03 <swiert> /clear
13:13:39 <SamB> well, from what I can understand of the concept of removing replacers, I've got that done...
13:13:45 <boegel|home> \clear
13:13:48 <boegel|home> :)
13:17:47 <boegel|home> CosmicRay: no HWN this week ?
13:32:47 <shapr> malcolm: I ran up against the removal of Haskell2Xml and vice versa, the Haxr XmlRpc library still wants them.
13:33:14 <shapr> franka: Check out malcolm's XmlContent in HaXml 1.14
13:34:48 <malcolm> shapr: Well, the replacement of Haskell2Xml with XmlContent is experimental.  If you want stable code, stick with HaXml-1.13.  But I expect 1.14 will congeal into solidity by the end of the year or so.
13:36:40 <SamB> @random 10
13:36:40 <lambdabot> Unknown command, try @listcommands.
13:36:50 * Cale wonders why nobody seems to have done a captcha with simultaneous image and audio versions of the word.
13:36:51 <franka> Oh, OK.
13:37:12 <shapr> Cale: PayPal has those.
13:37:24 <Cale> oh, good :)
13:37:39 <Cale> Is there any free implementation of such a thing?
13:37:51 <shapr> I don't know.
13:39:55 <franka> malcolm, I didn't know JAXB was inspired by HaXML.
13:40:12 <malcolm> franka: hmm, I'm not sure it was...
13:40:35 <franka> On your page: "The Java world has adopted the ideas from DtdToHaskell into the Java Architecture for XML Binding (JAXB)."
13:40:49 <franka> Where do I read about this XmlContent?
13:40:56 <malcolm> franka: maybe not directly inspired (how would I find out?)
13:40:57 <SamB> what is a captcha
13:41:07 <franka> (that's what i wanted to know)
13:41:13 <Cale> http://en.wikipedia.org/wiki/Captcha
13:41:14 <shapr> @wikipedia captcha
13:41:16 <lambdabot> http://en.wikipedia.org/wiki/Captcha
13:41:19 <malcolm> franka: but they have certainly adopted the idea, whether it came from me or not
13:41:30 <Cale> completely automated public Turing test to tell computers and humans apart
13:41:31 <franka> A captcha is one of those crazy generated text things to guard against spambots.
13:42:13 <malcolm> franka: for XmlContent see my blog http://nhc98.blogspot.com/ 
13:43:27 <malcolm> franka: and development version of HaXml at http://www.cs.york.ac.uk/fp/HaXml-1.14/
13:44:31 <franka> XmlContent does not seem to be mentioned on your blog page.
13:45:37 <malcolm> franka: oh, errm "unifying Haskell2Xml and Xml2Haskell" covers it, but not explicitly by name
13:45:48 <franka> OK, was reading that.
13:48:47 <franka> Hm, I don't think I understand.
13:49:22 <franka> You want to parse it first as text, and then parse the Haskell tree to do validation?
13:49:59 <franka> That is, two parsing stages using the same combinators?
13:51:34 <malcolm> franka: yeah, more or less.
13:51:36 <dons> SamB, how's hmp3 running for you now? any cpu leaks?
13:51:54 <ValarQ> dons: hows the hmpc project going?
13:52:15 <dons> hmpc, the mpd binding?
13:52:36 <dons> it's not going yet. no time :)
13:53:20 <dons> SamB, hmp3 has now been running for 17 hrs 11mins :)0
13:53:28 <malcolm> franka: the XML file is stored as text, so it needs to be parsed to recover the tree structure.  But the generic tree structure is only the first step.  You then want a tree transformer to turn the generic tree into a fully typed tree.  It turns out that is just another parser really.
13:55:27 <franka> Hm, yeah, I think my UUXML thing did something similar.
13:55:55 <franka> Because we used an untyped representation as an intermediate normal form, and that had to be expanded to a typed form, which involved some parsing-like stuff.
13:56:44 <franka> In fact, I think Eelco Dolstra pointed it out to me once, but I didn't quite understand him, and the stuff in the paper doesn't look like a parser.
13:57:32 <malcolm> franka: well, it has taken me six years to realise it is just another parser...
13:58:28 <malcolm> franka: maybe what makes it non-obvious is that the input to the secondary parser is not a linear stream of tokens, but a tree.
13:58:57 <franka> Yeah.
13:59:37 <franka> Although when I wrote the parser for the pseudo-XML language in our paper, which is a tree language, I wrote it using Daan's combinators.
13:59:56 <franka> I just do some recursion in there which you don't have with text input.
13:59:57 <SamB> dons: mine keeps dying
14:00:47 <SamB> worse, it leaves mpg321 running
14:01:13 <franka> Though I didn't really think of it as a tree language.  Just kind of mostly-text-with-some-nested-bits.
14:01:17 <malcolm> franka: I was saying the other day, that once I'd developed my own set of parser combinators for HaXml, I realised it was just a poor imitation of Daan's parsec
14:01:53 <dons> SamB! oh no :/
14:02:01 <dons> bug report time.
14:02:07 <SamB> dons: I will shower while waiting for it to die again
14:02:27 <dons> ok. also i'll do some linux testing then
14:02:34 <franka> malcolm: Any plans to handle XML Schema or Relax NG?
14:02:56 <malcolm> franka: not until I find myself needing one or other of those
14:03:02 <franka> heh
14:03:20 <SamB> malcolm: is that why HXT uses Parsec?
14:03:24 <malcolm> franka: XML Schema is just horrible anyway
14:03:24 <franka> Lots of programs support one or the other nowadays.
14:03:37 <SamB> yeah, nobody uses XML Schema do they?
14:03:40 <SamB> except the W3C?
14:03:47 <franka> malcolm: I thought it was horrible too, at first, but in abstract form it's not as bad as it looks.
14:04:00 <SamB> well, what about concrete form?
14:04:06 <franka> Horrible.
14:04:09 <SamB> I like a concrete form that is usable ;-)
14:04:14 <SamB> RNC rules
14:04:36 <franka> That is the non-XML syntax for RNG, right?
14:04:50 <malcolm> Schema has these horrible iterator bounds things though, which seem completely non-orthogonal
14:04:52 <SamB> the XML syntax is probably just for abstraction/buzzword compliance
14:05:08 <SamB> franka: yeah
14:05:22 <SamB> the real name is Relax NG Compact, iirc
14:05:26 <franka> malcolm: Yeah, they are not orthogonal.  But there are lots of non-orthogonal things in there.  And that is also true of Haskell...
14:06:26 <franka> malcolm: I just expanded them out ordinary regular patterns.
14:06:32 <malcolm> I reckon Schema has the flavour of being designed by someone who knows only BASIC, but hasn't used it for ten years.
14:06:39 <franka> malcolm: However that's not really efficient.
14:07:28 <franka> It's part of the XML perspective on the world... in order for XML to be useful, they have to turn everything into XML.
14:07:49 <malcolm> franka: come to think of it, I might have a need for either schema or Relax NG in the new year
14:07:54 <franka> Which is ironic, considering it was introduced for the purpose of data interchange.
14:09:49 <malcolm> I was just looking at Daan's paper on extensible records, and thinking how great it would be if Haskell had them, because it would map onto XML attributes so much more nicely than Haskell's current record system.
14:09:52 <franka> But I always thought it was pretty impressive that they gave it a formal semantics.
14:10:13 <franka> (re: Schema)
14:10:27 <malcolm> franka: blame Wadler for enforcing the rigour there :-)
14:10:46 <franka> Yeah.  It is a beast, though.
14:10:48 <shapr> Wasn't Relax NG prototyped in Haskell?
14:10:58 <franka> I am not sure if I approve of semantics being abused in that way. :)
14:11:42 <franka> I dunno.  But I think James Clarke worked with Wadler to get the semantics right.
14:11:46 <franka> So maybe.
14:12:13 <franka> -e
14:12:40 <malcolm> shapr; a quick google puts James Clark and Relax NG and Haskell on the same page
14:13:20 <malcolm> shapr: looks like he wrote the RNG algorithm prototype in Haskell, as you say.
14:13:25 <franka> So are there any good Haskell programs for homepage generation?
14:14:44 <shapr> You could use Halipeto or one of its forks/extensions.
14:14:51 <shapr> That's what I used for scannedinavian.org
14:14:59 <shapr> I'm using Peter Gammie's PLog for scannedinavian.com
14:15:14 <franka> I think I looked at Halipeto once.
14:15:25 <shapr> Though it's pretty hard to hack on PLog, I'll probably switch to a hacked Flippi for my blog at some point.
14:15:31 <malcolm> I use Makefiles + sed scripts :-(
14:15:48 <franka> Eat your own dogfood, malcolm!
14:15:49 <franka> :)
14:15:55 <franka> (Look who's talking...)
14:16:13 <shapr> I've always wondered if Daan uses UU or Parsec.
14:16:26 <franka> Daan uses Parsec.
14:16:35 <malcolm> My sed scripts are written as a composition pipeline...
14:16:50 <franka> Though he did a comparison with UU a long time ago.
14:18:37 <franka> shapr: Your about page says you still use Halipeto, not PLog.
14:19:32 <shapr> Check www.scannedinavian.com
14:19:40 <shapr> .org is halipeto, .com is PLog
14:19:43 <franka> Is my impression that writing "financial stock trading software" is incredibly bording correct?
14:19:46 <franka> -d
14:20:02 <franka> Ah.
14:20:14 <shapr> It depends ... it'd be really cool to use the financial combinators.
14:20:19 <franka> BTW, I started an Audioscrobbler page.
14:20:23 <shapr> spiffy!
14:20:32 <shapr> Same username as irc nick?
14:20:35 <malcolm> I dogfood HaXml in the Blobs project (first actual personal use of HaXml since 1999)
14:20:43 <franka> No, Blackheart2
14:20:45 <SamB> dons: died
14:20:53 <shapr> There's a startup using SPJ's financial combinators, though they ported them to OCaml.
14:21:08 <malcolm> Lexifi
14:21:12 <shapr> Yup, that's it.
14:21:30 <franka> I mean my username there is Blackheart2.
14:21:37 <shapr> Right, I understand.
14:21:45 <shapr> Years of holding many concurrent IRC conversations helps :-)
14:21:58 <int80_h> greetings all
14:22:17 <shapr> Only rarely do I get a race condition and somehow think kosmikus is asking newbie questions.
14:22:21 * int80_h happily works through chapter 4 of Thompson
14:22:21 <franka> Hello, int80_h
14:26:53 <franka> Does PLog have a webpage?
14:26:56 <franka> I can't find it.
14:27:27 <shapr> Nah, Peter Gammie's site went down. I have 0.0.6 online though if you want to try it.
14:27:55 <franka> I'd like to have a gander at it, I guess.
14:28:05 <shapr> @elite shapr, master of the 0-day haskell warez
14:28:06 <lambdabot> 5|-|ApR, maz7eR oF the 0-dAy HA$k3L1 \/\/4ReZ
14:28:10 <shapr> Or something...
14:28:18 <franka> heh
14:28:33 <shapr> It's http://www.scannedinavian.org/~shae/plog-0.0.6.tar.gz and I can help you set it up if it's too much trouble.
14:28:44 <shapr> Though bringert's BLob is much nicer.
14:28:54 <shapr> er, BloB?
14:29:01 <bringert> hi shapr
14:29:10 <shapr> hej bringert 
14:29:48 <malcolm> Oh dear, is the name Blobs too similar to BloB that it might cause confusion?
14:30:27 <shapr> Sadly, HSQL and HaskellDB are difficult to upgrade. I'd be using BloB if it had a filesystem storage backend. Not that I've ever gotten motivated enough to fix it...
14:31:12 <shapr> franka: BloB is on http://www.bringert.net/projects.html
14:31:16 <shapr> bringert: How's code?
14:31:34 <bringert> I'm wrestling with moving GF to darcs
14:31:40 <bringert> see my message i #darcs
14:31:59 <shapr> Using tailor, I assume?
14:32:09 <bringert> cvs2darcs
14:33:40 <franka> Hm, actually I was thinking of static website generation.
15:03:25 <franka> What is the difference between Emacs' utf-8-unix and utf-8m-unix?
15:11:32 * shapr hOps cheerfully
15:19:46 <kosmikus> shapr: can you explain this IO thingy to me? how can I write a function IO String -> String?
15:20:02 * shapr snickers
15:20:03 <SamB> kosmikus: you can't
15:20:15 <SamB> thats like the classic example of what you can't do
15:20:21 <shapr> SamB: He's joking :-)
15:20:26 <SamB> oh.
15:20:29 <SamB> hehe
15:20:33 <shapr> He's referring to <shapr> Only rarely do I get a race condition and somehow think kosmikus is asking newbie questions.
15:20:43 * SamB thought kosmikus would know that kind of thing
15:20:52 <franka> kosmikus: counit io = ""
15:21:04 <shapr> Anybody who writes a thesis on Generic Haskell probably knows that.
15:21:08 <SamB> sometimes I think droundy is asking newbie questions
15:21:23 <SamB> before I notice who it is
15:21:26 <kosmikus> franka: thanks :)
15:21:29 <shapr> I think darcs was droundy's first Haskell project.
15:21:44 <SamB> well, I mean even after I started using it
15:21:52 <shapr> I'm looking forward to his second Haskell project :-)
15:21:58 <SamB> which must have been well into his understanding of haskell
15:22:06 <SamB> shapr: is he going to have time to do another?
15:22:11 <shapr> I don't know.
15:22:32 <SamB> or, rather, is darcs going to settle down and not demand his constant attention?
15:23:03 <shapr> Probably not.
15:24:15 <kosmikus> I hope not :)
15:24:17 <shapr> SyntaxNinja: climb faster!
15:34:38 * drrho is away: doing real work :-)
15:35:32 <franka> Does Eelco D. ever grace this channel with his presence?
15:36:43 <shapr> franka: Yup, he's here often. Try /whois visser
15:36:59 <shapr> Wait, Eelco who?
15:37:04 <franka> Eelco Dolstra.
15:37:21 <shapr> Oh, haven't seen him here.
15:37:22 <franka> I've seen Eelco V. before.
15:40:16 <kosmikus> franka: no, I've seen Eelco D. on irc only once, and that was during the icfp contest two years ago ...
15:40:49 <franka> Oh.  I always figured he was the type of person you would see on #haskell a lot.
15:43:02 * shapr finds a nice use for the swing combinator.
15:43:13 <SamB> shapr: oh?
15:43:29 <SamB> is it possibly useful in smalltalk-style environments?
15:44:15 <Greystripe> yo
15:44:16 <shapr> hi Greystripe, are you learning Haskell?
15:44:19 <Greystripe> yup
15:44:25 <shapr> Have any questions?
15:44:43 <Greystripe> not really, i was just curious if such a channel existed on freenode
15:44:47 <SamB> hehe
15:44:58 <SamB> the answer to that one is "yes"
15:45:07 <Greystripe> heh, good
15:45:16 <shapr> SamB: I'm using swing to implement Eq instances for large records, and $ swing map p [accessor1,accessor2,accessor3]
15:45:40 <shapr> I originally had a tuple, but I realized that may not take advantage of laziness.
15:46:00 <SamB> we are apparantly among the friendliest channels, possibly because our language is among the least irritating to use ;-)
15:46:02 <shapr> Greystripe: 175 clients on #haskell today, somedays we go over 200.
15:46:13 <Greystripe> cool
15:46:31 <shapr> If you do have questions, or want a short intro to the language or irc channel, feel free to ask.
15:46:40 <Greystripe> SamB: my gf would disagree with you quite a lot :P
15:46:49 <Greystripe> she's doing a computer science course
15:46:55 <Greystripe> that's why i'm learning haskell
15:46:59 <Greystripe> so i can help her with it
15:47:13 <shapr> Be careful, you may end up addicted to Haskell like me.
15:47:17 <franka> SamB: haha
15:47:21 * shapr tokes on a lambda
15:47:23 <bojohan> bringert: would you be interested in a gf mode for emacs?
15:47:23 <bojohan> http://www.dd.chalmers.se/~bojohan/exjobb/src/gf.el
15:47:27 <shapr> The first lambda comes free, man.
15:47:39 <SamB> well, I said use. not learn ;-)
15:48:01 <SamB> bojohan: what does that do?
15:48:03 <Greystripe> i'm finding myself incresingly addicted to haskell
15:48:09 <shapr> Greystripe: Just wait till you have to mainline the latest research paper.
15:48:14 <bringert> bojohan: yes! I was thinking yesterday that we should have that
15:48:17 <bringert> thanks!
15:48:18 <SamB> bojohan: is it extra friendly?
15:48:26 <shapr> I have a thousand dollar a month research journal habit.
15:48:46 <bojohan> SamB: "extra" in what way?
15:48:51 <bringert> SamB: not girlfriend, Grammatical Framework
15:49:03 <SamB> and it isn't terribly irritating if you learn it on your on volition
15:49:28 <shapr> I like GF, it's the ultimate nonsense sentence generator.
15:49:42 <SamB> shapr: whoa!
15:49:51 <SamB> how many journals is that?
15:49:59 <Greystripe> apparently i was mumbling list comprehensions in my sleep the other night
15:50:08 <SamB> (which ones?)
15:50:14 <shapr> Greystripe: I tried to tell my woman that salad :: [Lettuce]
15:50:14 <Greystripe> and i woke up shouting "alleq ns = and [x == y | (x, y) <- zip ns (tail ns)]"
15:50:21 <Greystripe> lol
15:50:49 <shapr> Greystripe: When I first learned monads I dreamed that I had restructured my brain into monadic form and was using unsafePerformIO to see five seconds into the future.
15:50:57 <heatsink> XD
15:51:06 <Greystripe> hehe
15:51:26 <SamB> Greystripe: I don't even know how to pronounce them properly, myself!
15:51:35 <shapr> SamB: happily, I'm getting substitute drugs, but I still obsessively browse LtU, arXiv, and Citeseer.
15:52:03 <Greystripe> my eventual aim is to be good enough at haskell to write an accessible book on it (ie. one my gf is likely to understand)
15:52:09 <shapr> Oh good idea.
15:52:19 <shapr> You could start with one of the existing free tutorials.
15:52:48 <Greystripe> where?
15:52:50 <bojohan> bringert: is there any way to "cd" in the GF shell, btw? i've been wanting to do that.
15:53:18 <SamB> You could call it "Haskell for my Girlfriend: A Belated Introduction"
15:53:23 <shapr> There's Hal Daume's Yet Another Haskell Tutorial, CosmicRay's haskell-v8, and my tiny HaskellDemo. There's lots more on the learning page.
15:53:24 <shapr> @learn
15:53:25 <lambdabot> http://www.haskell.org/learning.html
15:53:44 <bringert> bojohan: !cd
15:53:57 <bringert> ! escapes to the shell
15:54:21 <shapr> Greystripe: So, no questions yet?
15:54:22 * SamB implemented :cd and :pwd in his ~/.ghci
15:54:31 <bojohan> bringert: yes, so that can't change the directory of the gf shell
15:55:00 <bojohan> ghci has :cd out of the box
15:55:21 <shapr> Hey fworp, how's the Magic City?
15:55:29 <SamB> bojohan: are you sure?
15:55:42 <bringert> bojohan: ah, you're right, it runs a subshell of course
15:55:42 <fworp> cold
15:55:50 <fworp> and wet
15:55:54 * shapr DCCs snow to fworp 
15:55:57 <Greystripe> i'm off
15:56:02 <shapr> Greystripe: come back soon.
15:56:07 * fworp doesnt accept
15:56:18 * franka np: Strange Boutique - A Ballad for Morgaine
15:56:20 <bojohan> SamB: :cd <dir> change directory to <dir>
15:56:24 <Greystripe> i'm sure sooner or later i'll have a problem that i'll need you guys to help me with
15:56:34 <SamB> thats funny.
15:56:40 <SamB> it doesn't quite work for root here:
15:56:58 <SamB> wait. it does
15:57:29 <SamB> but their implementation is no better than mine
15:57:45 <bringert> bojohan: so I don't know how to change directory then. do e-mail aarne and ask. he's very happy to hear from anyone using GF. tell him about your gf emacs mode too. I'm going to start using it for sure.
15:58:39 <joelr1> folks, what options controls the context switching at runtime?
15:58:53 <bojohan> bringert: i'm doing my exjobb for aarne. i'm seeing him tomorrow.
16:00:06 <bringert> bojohan: ah, the grammars for pictures thing? or is it something else?
16:00:14 <bojohan> that's me :)
16:02:00 <shapr> joelr1: Like what?
16:02:28 <joelr1> shapr: in the high-performance web server paper they are saying they needed to adjust context switching
16:02:34 <joelr1> i think it's the -C option
16:03:32 * shapr has no clue
16:03:40 * JKnecht gets a queasy feeling about Haskell threads.
16:04:11 <SamB> JKnecht: don
16:04:14 <SamB> 't
16:04:34 <JKnecht> wheeeew! thanks.
16:04:43 <joelr1> JKnecht: i'm with you, specially if they are using FFI ;)
16:05:14 <dons> they have nice clean semantics. forkIO is beautiful.
16:05:22 <JKnecht> I'll take care of FFI just need ghc, cabal, et. al. TDTRT.
16:05:42 * dons loves haskell threads
16:05:42 <musasabi> dons: having an erlang like debugger would make it more beautiful.
16:05:49 <shapr> I don't know why the GHC team won't accept my spoonIO patch.
16:05:58 <dons> hehe
16:06:05 * joelr1 has had things crashing for him all over... with haskell threads
16:06:06 <dons> @remember shapr I don't know why the GHC team won't accept my spoonIO patch
16:06:12 <musasabi> "Why am I deadlocked" is nontrivial to solve with GHC.
16:06:29 <dons> joelr1 writes code with every nontrivial extensions interconnected, I think ;)
16:06:36 <musasabi> joelr1: most probably you are spawning them out of control somewhere.
16:06:58 <joelr1> dons: i'm simple these days
16:07:03 <joelr1> musasabi:  no way
16:07:07 <joelr1> want an example?
16:07:43 <joelr1> let me just have this thing crash on me so that i can post the stack trace
16:08:06 <musasabi> yes, an example would be nice.
16:08:24 <joelr1> musasabi: i'm launching something like 500 threads that do sockets
16:08:37 <joelr1> and i even removed all the "timeout" constructs that kill threads
16:08:41 <joelr1> that was giving me grief
16:08:57 <joelr1> i can't post examples, though
16:09:03 <joelr1> stack traces --- sure
16:09:30 <musasabi> joelr1: e.g. 20000 threads should work without any problems.
16:09:49 <musasabi> Are you using -threaded ?
16:10:08 <joelr1> musasabi: no, i'm not. i thought that was for bound threads
16:10:15 <joelr1> whereas i'm using the cooperative ones
16:10:40 <musasabi> joelr1: just making sure, because that can affect things (mostly the socket side)/
16:11:58 <musasabi> what OS?
16:13:46 <joelr1> osx
16:13:48 <joelr1> and windows
16:15:01 <musasabi> Last time I checked Network served (without -threaded) 600 http requests / sec. (You can get to 2000 / sec with some tricks). This was with 1000 concurrent connections + Linux.
16:15:29 <joelr1> what software is this?
16:17:37 <joelr1> meaning what haskell software
16:18:10 <dons> does anyone know if I can install as user a .deb? (/me has forgotten all my debian)
16:18:30 <joelr1> good night gents
16:18:50 <Igloo> Only by taking it apart and hoping it works
16:19:21 <dons> Igloo, taking it apart how? tar gz used to work, didn't it?
16:19:57 <Igloo> No
16:19:57 <dons> it's just a static binary, so should be ok.
16:19:58 <Igloo> ar -x foo.deb; tar -zxvf data.tar.gz
16:19:58 <musasabi> JKnecht: haskell threads are cheap.
16:19:58 <musasabi> Doing the IO is the more tricky part.
16:20:30 <shapr> bojohan: I think :info and hoogle are your only options, and they don't do apropos.
16:20:56 <bojohan> am i the only one missing it?
16:22:04 <dons> excellent Igloo!
16:22:07 <ndm_> bojohan: have you tried hoogle?
16:22:08 <dons> @karma+ Igloo
16:22:10 <ndm_> @where hoogle
16:22:15 <dons> @bot
16:22:44 <dons> @karma+ Igloo
16:22:51 <ndm_> lambdabot says: www.haskell.org/hoogle
16:22:52 <dons> hmm
16:22:55 <dons> @version
16:22:55 <lambdabot> Igloo's karma raised to 5.
16:23:04 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
16:23:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
16:23:16 <bojohan> ok, so does anyone have an emacs mode for hoogle?
16:23:37 <Igloo> My karma must be very heavy - it took a long time to raise it
16:23:39 <shapr> I just use erc and keep a query buffer open to lambdabot 
16:23:44 <shapr> @karma+ Igloo 
16:23:45 <lambdabot> Igloo's karma raised to 6.
16:24:15 <shapr> bojohan: lambdabot is sort of a shared collaborative collection of Haskell utilities.
16:25:50 <bojohan> yeah, and i keep a query buffer open to fsbot.
16:26:00 <shapr> I think several people keep lambdabot instances running on private networks for the same reason.
16:36:14 <musasabi> shapr: I actually ran a modified version of lambdabot for an rpg in an another network.
16:36:31 <shapr> cool!
16:36:41 <dons> musasabi, cool :)
16:37:12 <dons> and vegai and ibid are running it for an online haskell help forum for a class they teach
16:37:41 <shapr> hi CosmicRay 
16:38:12 <shapr> How's life?
16:38:35 <shapr> Is there a significant difference between -O and -O2 for GHC?
16:38:36 <fworp> does strictness annotation ensures evaluation when constructor is applied right? not when its deconstructed? or is there really even a difference?
16:38:46 <dons> don't think so shapr.
16:39:11 <dons> but I don't have hard figures.
16:39:15 <shapr> ok, thanks
16:40:05 <fworp> s/right//
16:43:19 <fworp> for instance, where the constructor is Foo !a, is 'a' evaluated at foo x = Foo x, or foo (Foo x) = x
16:44:28 <shapr> I think it's evaluated when constructed, but beware of 'strictness' in Haskell. It often means weak head normal form, as opposed to what you get from DeepSeq.
16:44:34 <dons> you can't put an unevaluated exppression into the strict field of a constructor
16:44:56 <dons> so don't stick 'error' or 'undefined' in a strict field ;)
16:45:20 <fworp> ok, so its evaluated 'before' construction, thanks
16:45:33 <Frederick> SamB, heya are you around?
16:46:56 <machack666> If I have `data StratA; data StratB; data Strategies = StratA | StratB' will this do what I expect for a typeclass which defines instances for StratA and StratB, while still keeping StratA and StratB unified with respect to the "parent" type Strategies?
16:48:16 <machack666> i.e., `class Strategy a where chooseValue :: a -> Data -> Val' can be defined for each of the Strategies subtypes to define a different strategy for a particular data constructor of the Strategies datatype
16:48:36 <machack666> or am I trying to make the solution fit the problem?
16:49:17 <machack666> (having nothing to do with Control.Paralell.Strategies)
16:51:05 <shapr> data StratA declares a type.
16:51:15 <shapr> data Foo = StratA declares a type constructor.
16:51:52 <shapr> Look at the GADT equivalent: data Strategies where StratA :: Strategies ; StratB :: Strategies
16:51:56 <machack666> never mind.  I think I can accomplish what I am trying to do simply by pattern matching
16:52:08 <machack666> trying to make it too hard on myself
16:52:33 <machack666> but please go on
16:52:39 <machack666> I like to learn more
16:53:05 <shapr> That was all I had to say :-)
16:53:11 <machack666> ok :D
16:53:57 <heisenbug> does yhc support GADTs?
16:54:09 <machack666> pattern match should work.  I was just trying to abstract out the `case-like' constructs for the different strategies
16:56:50 <shapr> heisenbug: I'd be surprised if it did. GADTs were just added to GHC.
16:57:17 <heisenbug> in 6.4, yes
16:57:40 <heisenbug> and the Omega interpreter uses them?
16:58:07 <musasabi> Getting a Haskell'06 (/ whatever) would open a standard for compiler authors to target to.
16:58:14 * heisenbug did not untar yet
16:58:38 <shapr> I don't think Omega requires GADTs, I'm pretty sure it's years older than GHC 6.4
16:58:38 <musasabi> e.g. MPTCs and fundeps are not specsed anywhere.
16:58:59 <shapr> If you mean Tim Sheard's dependently typed Omega.
16:59:07 <heisenbug> yes
16:59:15 <musasabi> GHC and Hugs implement them a little bit different.
16:59:35 <musasabi> (as one can see by some instances working in one but not the other)
17:00:45 <musasabi> And typeclasses vs GADT is not done even in GHC.
17:04:28 <eivuokko> It looks suspiciously easy....is ghc nowdays compiling easily out-of-the-box in Windows?  (given somewhat correct msys/mingw)
17:04:55 <shapr> hi sploo22, learning Haskell?
17:05:26 <sploo22> yeah, when I can find the time. why?
17:12:58 <shapr> sploo22: Just wondering if you had any questions.
17:14:31 <sploo22> not really, but thanks for asking :)
17:14:40 <shapr> ok, feel free to ask if you think of some.
17:24:24 <Frederick> SamB, heya are you around/
17:40:34 <Frederick> did a nuclear bom fall here?
17:40:41 <Frederick> everything seems to quite
17:40:47 * Frederick looks around
17:40:55 <heatsink> BOOM!
17:41:12 * Frederick ducks
17:41:15 <Frederick> netsplit
17:41:24 <heisenbug> netsplit
17:41:31 <musasabi> mmh
17:41:40 <heatsink> MOOB!
17:41:40 <heatsink> !MOOB
17:41:48 * Frederick fall hitten by the mob of people
17:41:54 * Frederick cant move
17:42:01 * Frederick pushes some corpses
17:42:22 * musasabi gives Frederick a lambda to make the work easier
17:42:39 <Frederick> thx thx
17:43:12 <Frederick> since ive installed linux in my box Ive nerver bought software again
17:43:12 <Frederick> this is amazing
17:43:29 <Frederick> games, encyclopies everything I use is free
17:44:57 <shapr> @quote shapr
17:44:58 <lambdabot>  GHC has more flags than the UN
17:45:00 <shapr> @quote shapr
17:45:01 <lambdabot>  I don't know why the GHC team won't accept my spoonIO patch
17:45:03 <shapr> @quote shapr
17:45:04 <lambdabot>  Anyway, I'm just a walking index into the Haskell world. I can tell you
17:45:04 <lambdabot> a little bit about many things, but I will quickly forward you to the
17:45:04 <lambdabot> experts for more detail.
17:45:16 <shapr> geez, where's my windows quote?
17:45:52 <Frederick> @shapr quote
17:45:53 <lambdabot> Unknown command, try @listcommands.
17:45:53 <Frederick> hm
17:45:59 <Frederick> lol
17:46:04 <Frederick> wrong pattern :p
17:46:09 <Frederick> @quote shapr
17:46:10 <lambdabot>  I don't know why the GHC team won't accept my spoonIO patch
17:46:28 <Frederick> shapr, how do the quotes ged added?
17:46:39 <shapr> You use @remember name quote
17:46:55 <heatsink> @quote dons
17:46:56 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
17:47:03 <shapr> @quote
17:47:03 <lambdabot> kolmodin says: i.e. I would rather lose my left arm than write it in
17:47:03 <lambdabot> Java
17:47:07 <shapr> @quote
17:47:07 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files
17:47:07 <lambdabot> in Different Directories!"
17:47:16 <shapr> Lots of fun stuff in the quotes.
17:47:19 <heatsink> :)
17:47:31 <Frederick> shapr like @remmember Frederick foo?
17:47:55 <shapr> Yeah, but it's best if you only save quotes from other people.
17:48:06 <Frederick> sure
17:48:41 <Frederick> bah, folks today Ive showed my teacher the part of the assigment you helped me in
17:48:49 <shapr> and?
17:48:51 <Frederick> ans she was like omfg where is your code?
17:49:01 <Frederick> Ive said eveything is there
17:49:27 <dons> oh, it was concise?
17:49:28 <Frederick> she tried to argue I was cheating because of some of haskell structures
17:49:45 <Frederick> yep
17:49:54 <dons> this is very common when people are confronted with haskell code :)
17:50:00 <dons> i've had the same thing happen.
17:50:11 <Frederick> there is a last algorithm to finish the deal
17:50:13 <dons> blackdog was banned from a programming contest for using haskell
17:50:17 <Frederick> and 1 aplication of a parsec tranformation
17:50:31 <dons> it's a secret weapon, and perhaps an unfair advantage -- at least the java/c/c++ guys think so
17:51:08 <Frederick> I really need some functional knowledge to open my minda
17:51:19 <Frederick> also need to programm in something with OO
17:51:22 <dons> i wanted to do a C++ compiler assignment in haskell once, and the lecturer was like: ok, but you have to implement 10 times as many features
17:51:34 <dons> otherwise it isn't fair on the C++ guys
17:51:46 <eivuokko> C++ compiler assignment?
17:51:56 <dons> yeah, a compiler for C written in C++
17:52:07 <dons> == segfault hell :)
17:52:13 <Saulzar> If you use Haskell libraries for algorithms in an algorithm assignment or something...
17:52:39 <Frederick> how long did you take +- to become haskell fluent?
17:53:25 <dons> i've been programming haskell full time for 3 years now. but after about 1 year I was pretty solid.
17:53:38 <Cale> Depends on what you mean by fluent :)
17:53:40 <eivuokko> dons, Ah, ok.  I thought building C++ compiler.    FWIW, doing compilers in C++ doesn't need to be that hard.
17:54:00 <Cale> 1 year is a pretty safe number
17:54:03 <dons> nah, but it still seems ludicrously hard compared to a haskell one
17:54:16 <Frederick> Cale, fluent might be a bad word, I mean like now Im not a great C programmer but I can check and see hm I need this so I read that I can do it
17:54:24 <Saulzar> What I want to know is - after you have used Haskell for a long time can you look at a piece of really really dense haskell code and figure it quickly?
17:54:25 <dons> no pattern matching on data structures. haskell was just born to write compilers in
17:54:38 <dons> Saulzar, sure.
17:54:40 <Cale> I could get things done after a couple of months.
17:55:04 <dons> Saulzar, I think now there's  not much haskell code I can't figure out. Except tricky type hackery
17:55:10 <dons> which takes more time.
17:55:23 <dons> but then there's only 10 people on the planet who understand some of the type tricks
17:55:38 <Cale> Saulzar: it's a lot easier in Haskell to figure out other people's code because the types help so much
17:55:51 <Frederick> Cale, during all my university life Ive wondered for a language I would really enjoy learning, for my own surprise haskell is amking the deal
17:56:01 <Saulzar> Hehe. Well... it seems that's half of it - trying to figure out what types are used in some dense line using 4 monads and god knows what else.
17:56:06 <machack666> is there a difference between a `func = let helper = [define helper] in [use helper]' and `func = [use helper] where helper = [define helper]'
17:56:08 <dons> Saulzar, Cale: and you don't have to worry about the code doing weird things behind your back
17:56:14 <Cale> dons: yes
17:56:21 <Cale> Frederick: yeah :)
17:56:35 <dons> often if the code doesn't have types, adding the type annotations is the first thing I do to understand it
17:56:53 * eivuokko always adds type annotations
17:56:55 <Cale> machack666: no. The only difference between let and where is what they are syntactically.
17:57:11 <Cale> where is part of the function declaration and scopes over guards
17:57:18 <Cale> let is part of the expression
17:57:27 <Frederick> Cale, and another thing ive liked is this support channel, most support channels are multiplayer notepads playing deatmatch
17:57:33 <Cale> Frederick: :)
17:57:36 <machack666> Cale: thanks for the info
17:57:45 <Cale> yeah, the Haskell community is small, but very helpful
17:58:01 <Frederick> here things are calm, I ask you help, provide code but mainly you are interested in the concepts not in the syntax
17:58:01 <dons> and a bit pointy headed
17:58:04 <machack666> not using guards currently, they are the same as far as I'm concerned.  :)
17:58:11 <cjs> "A bit"?
17:58:31 <dons> ok, pointy-headedness is a requirement for entry ;)
17:58:37 <dons> "you must be this pointy to enterR"
17:58:43 <cjs> I mean, "we don't have variables." How pointy-headed can you get?
17:59:05 <dons> variable variables are for suckers ;)
17:59:06 <Frederick> I wil watch Rome now, shall be back tommorow to keep discussing the transitive closure :p
17:59:11 <Frederick> cya folks
18:00:17 <cjs> I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
18:00:17 <musasabi> see you later
18:00:39 <musasabi> cjs: like joy?
18:00:47 <cjs> And then I'm like, "Well, look how much easier it makes it to write a debugger!" And then they run.
18:00:51 * musasabi would like to see pure joy someday
18:00:53 <heatsink> :)
18:02:23 <cjs> Hm. Never heard of Joy before, but looks interesting.
18:02:39 <cjs> Also looks like the bastard child of Haskell and FORTH, but never mind that. :-)
18:03:52 <musasabi> The only problems is that programs become quite unreadable in joy.
18:05:07 <musasabi> like filter:
18:05:09 <musasabi> filter == [] cons [dup [] cons] swap ++ [infra first [swons] [pop] branch] ++ [] swap foldl reverse .
18:05:47 <cjs> I'm not sure that that's the only problem. One of the first examples they give is the square of the sum of two integers, and they talk about making it more efficient by not doing the addition twice. "2 3 + dup *". But why should the programmer have to think about that? "(a + b) * (a + b)" is an easy algebraic transformation; computers ought to do that sort of thing for us.
18:06:41 <musasabi> 2 3 + 2 3 + *
18:06:46 <musasabi> is equally good.
18:06:48 <cjs> Which I guess does go back to readability; you want to express your intent in a readable way, but you want the compiler to convert that to the most efficient way to do things.
18:06:56 <cjs> will Joy do the addition only once in that case?
18:07:07 <musasabi> a joy compiler can do that.
18:07:14 <musasabi> with CSE
18:07:33 <musasabi> (not that such a thing exists)
18:26:26 <machack666> is the order of pattern matching alternative signficant; ie, is a particular "branch" of a function chosen based on the first match, or is it based on the most specific match?
18:26:49 <arjanb> first match
18:26:59 <machack666> thanks
18:27:37 <machack666> any reason why that is, other than ease of implementation?  it seems like position should be used only when breaking a tie for specificity of implementation
18:27:52 <machack666> and, I suppose convention
18:28:36 <Korollary> it's a convenience. Otherwise you'd have to be really explicit in every pattern so that none of them overlap.
18:28:43 <arjanb> i think most specific match may require more cases
18:32:19 <musasabi> machack666: most specific is ill defined with patterns.
18:32:53 <musasabi> foo x | cond1 x = ...; foo x | cond2 x = ...
18:33:19 <machack666> true; I'
18:33:41 <machack666> m only using th underscore to match whole chunks, but there are definitely more intricacies.
18:34:21 <musasabi> also consider bottoms as part of matches.
18:35:10 <machack666> do you match bottoms with a literal `_|_' in the pattern?
18:35:29 <machack666> or just implicitly in the `_'
18:35:32 <musasabi> _
18:35:38 <musasabi> matches anything.
18:36:06 <machack666> is there a strict _ ?  like !_ or something?
18:37:09 <musasabi> no.
18:38:19 <machack666> alright.  Thank you for the information.
18:38:30 <musasabi> Think about this: "foo _ 2 = 1; foo (x:xs) 1 = 1; foo _ _ = 0" If you move the second clause first then the semantics change.
18:39:11 <musasabi> > let foo _ 2 = 1; foo (x:xs) 1 = 1; foo _ _ = 0 in foo (error "") 2
18:39:12 <lambdabot> 1
18:39:37 <musasabi> > let foo (x:xs) 1 = 1; foo _ 2 = 1; foo _ _ = 0 in foo (error "") 2
18:39:38 <lambdabot> Terminated
18:39:47 <musasabi> as you can see.
18:42:58 <machack666> so pattern matching is done based only on types, whereas applying the found function evaluates the bound variables when used.  a consequence of lazy evaluation
18:54:41 <SamB> musasabi: got anything for me yet?
18:57:32 <Korollary> hmm. SPJ uses {} and ;.
18:57:51 <Frederick> yo folks
18:57:55 <SamB> Korollary: where?
18:58:03 <SamB> at the top level?
18:58:44 <eivuokko> I think he refers to an email on mailing list.
18:58:54 <Korollary> yes, he doesn't use the offset rules.
18:59:27 <SamB> oh. list. pan...
19:03:30 <SamB> shapr: any idea when I learned Haskell? no?
19:03:47 <SamB> I went and learned it before I came to the channel, didn't I?
19:04:28 <Frederick> folks I noticed that a good part of the channel is from ppl from countries like Sweden, Norge and stuff am I wrong?
19:04:39 * SamB puts down 2003
19:04:47 <SamB> Frederick: europe, yes
19:04:57 <SamB> @wiki HaskellUserLocations
19:04:58 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:05:04 <SamB> Frederick: fill out http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
19:05:44 <Frederick> hey syntax free is brazillian!
19:06:19 <SamB> what is "Monad foundation classes"?
19:08:41 <eivuokko> Uhm.
19:08:59 <SamB> never mind.
19:09:08 <eivuokko> I think there is a bug in libraries System.Process for windows.
19:09:22 <eivuokko> Or, well, misfeature
19:09:26 <SamB> eivuokko: maybe because windows does strange things with them?
19:09:38 <eivuokko> SamB, What a louse explanation
19:09:41 <eivuokko> *lousy
19:11:11 <eivuokko> Well, anyway, I'd like just to ask how mkWeakIORef works, because I think it's some sort of finaliser, and it doesn't get run fast enough, which makes hsc2hs fail because it deletes executable right after.
19:11:50 <eivuokko> ..keeping handle to process keeps executable file locked in Windows.
19:19:10 <SamB> executable?
19:19:40 <SamB> @index mkWeakIORef
19:19:41 <lambdabot> Data.IORef
19:19:57 <Frederick> SamB, just filled
19:20:20 <eivuokko> Executable as in runnable
19:20:49 <SamB> Frederick: you are who I thought of when I read this:
19:20:52 <SamB> I'm conducting a web-based survey of Haskell users to gather material for
19:20:52 <SamB> an article on the history of Haskell, and I need your help. I want to
19:20:52 <SamB> stress that I'm interested in responses from ALL users--if you're a
19:20:52 <SamB> complete beginner writing your first Haskell programs on a course, I'd
19:20:52 <SamB> like to know that, just as if you're one of the designers using it for
19:20:54 <SamB> your next POPL article.
19:21:31 <Frederick> huh?
19:21:51 <SamB> its on the Haskell mailing list
19:22:01 <Frederick> SamB, m not signed
19:22:09 <SamB> Frederick: neither am I
19:22:16 <eivuokko> Hmm
19:22:17 <SamB> I got there via gmane
19:22:49 <Frederick> SamB, I was discussing with some friend today about doing a little workshop about haskell on the beginning of the next semester
19:23:15 <Frederick> just to give people the basics
19:24:38 <eivuokko> I don't get this code at all.
19:25:06 * eivuokko just continues to ignore exceptions from removeFile
19:25:06 <Frederick> SamB, any idea came up of that transitive closure stuff?
19:25:52 <SamB> Frederick: well, I got something together that simplifies that example you gave
19:26:08 <Frederick> SamB, may I see it?
19:26:17 <SamB> first, a demo:
19:26:19 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> A","A -> B"])
19:26:19 <SamB> *CFG> removeReplacers cfg
19:26:19 <SamB> CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'A'], root = NT 'S', productions = {NT 'A':=[[NT 'B']],NT 'S':=[[NT 'B']]}}
19:26:25 * SamB had already copied it
19:27:02 <fworp> what kind of goodies are in ghc current (6.5.2)?
19:27:07 <Frederick> yep that is it
19:27:13 <Frederick> seems so at least
19:27:21 * Frederick double chacks
19:27:24 <Frederick> *checks
19:27:39 <Frederick> yep that is it
19:27:41 <SamB> lisppaste2: help
19:27:41 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:28:33 <lisppaste2> SamB pasted "remove replacers" at http://paste.lisp.org/display/13693
19:28:44 <Frederick> SamB, does B ecome []?
19:28:59 <SamB> hmm.
19:29:15 <SamB> Frederick: well, there was no B defined in that one
19:29:16 <eivuokko> Ummmm.  Where should I send mail discussing base/System/Process/Internal.hs?
19:29:23 <SamB> it wasn't actually valid ;-)
19:29:39 <Frederick> :p
19:29:45 <Frederick> lemme try
19:29:50 <SamB> the input wasn't, I mean
19:29:55 <Frederick> I know
19:30:01 * Frederick in fact Ive just realized
19:30:18 <SamB> I just used an example of yours ;-)
19:30:51 <SamB> that should not be a problem.
19:30:57 <Frederick> SamB, Ive saved some money for some months
19:31:08 <SamB> money?
19:31:12 <Frederick> and I will buy 3 books, I on C other in C++ and one in haskell
19:31:14 <Frederick> yep
19:32:06 <SamB> ah
19:32:30 <SamB> what C book?
19:32:35 <SamB> K&R, second edition?
19:32:37 <Frederick> SamB, I had very wrong concepts about functional languages
19:32:39 <Frederick> SamB, yes
19:32:42 <SamB> thats what I suggest ;-)
19:32:54 <SamB> its what they suggest in ##c as well
19:33:06 <Frederick> SamB, I have a copy of it here from the universitys library since it is in english no one likes to take it
19:33:09 <SamB> (why, I suggest it there myself ;-)
19:33:26 * Frederick looks at K&R over the table
19:33:34 <SamB> oh, does everyone else want books in...
19:33:45 <Frederick> I got stroutraps book too
19:34:03 <SamB> I bet K&R will be the most complete ;-)
19:34:24 <Frederick> SamB, K&R is the best book Ive ever read in programming
19:34:33 <Frederick> SamB, they teach you actually how to think in c
19:34:55 <SamB> its definately the nicest C book I've seen... which is not saying very much, really.
19:35:06 <SamB> the others weren't very good at all
19:35:26 <Frederick> Imho it misses some more discussion about pointers
19:35:38 <SamB> hmm, maybe.
19:35:52 <SamB> I haven't gotten too far in it, because I got it to teach my sister with ;-)
19:36:38 <SamB> but so far, it looks pretty nice. and it has a handy library reference in the back.
19:37:07 <SamB> at least, handy when you are stranded on Windows systems with no internet, no manpages, and no info files
19:37:12 <Frederick> the only use my sister givs to pc is msn
19:37:29 <Frederick> bah I cant use visual studio, it has no man
19:37:35 <Frederick> I want man foo
19:37:48 <Frederick> but they want me to ask msdn for foo
19:37:56 <SamB> my sister wanted to learn it to do robots with a team some of our friends are organizing
19:37:57 <Frederick> I want my ouwn foo :p
19:38:14 <Frederick> amazing
19:38:18 <SamB> yeah, I can't use visual C either
19:38:36 <SamB> even with that MSDN help file...
19:38:40 <Frederick> I had a class on opengl, Im making something like a flight simulator
19:39:15 <Frederick> and my classmates that refuse to use windows took like 1 hour to set glut and stuff in visual studio
19:39:18 <SamB> she hasn't gotten very far. I dunno if she'll be on the team or not.
19:39:30 <Frederick> ive asked the admin to apt-get install opengl and we were done
19:39:32 <SamB> Frederick: refuse to use linux, you mean?
19:39:49 <Frederick> SamB, woops yep, they simply refuse to use linux
19:40:11 <SamB> I woulda thought you would need a -dev package
19:40:46 <Frederick> Ive been using linux for few time in fact, Ive started 2 years ago
19:41:04 <Frederick> Ive "paid" a bottle of coke to a friend come to my house and set it up
19:41:33 <Frederick> but he left me without internet connection so Ive "paid" another friend some cookies and he set up my conection :p
19:43:25 <SamB> I paid for the computer.
19:43:45 <Frederick> huh?
19:43:52 <SamB> I didn't pay for the monitor or anything else, except some ethernet cable. Oh, and I had already purchased the three-button mouse...
19:44:02 <SamB> Oh. Except I paid for Linux, twice.
19:44:06 <SamB> I think.
19:44:32 <Frederick> SamB, how can you have a monitor and dont pay for it?
19:44:32 <SamB> three times if you count the copy that came in the book I started with ;-)
19:44:51 <SamB> Frederick: my dad found or bought me one...
19:45:15 <Frederick> SamB, found? is it true you can find good stuff ond the streets over there?
19:45:26 <SamB> Frederick: oh, he's a programmer.
19:45:29 <SamB> Probably bought.
19:45:39 <Frederick> family business
19:45:49 <SamB> no, not family business.
19:45:50 <Frederick> SamB, wich language does he program?
19:45:58 <SamB> He knows COBOL
19:46:07 <SamB> thats the only one I've really heard of.
19:46:35 * SamB hopes he hasn't scared anybody
19:47:09 <Frederick> SamB, you mean you think you father only knows cobol?
19:47:13 <Frederick> "only"
19:47:18 <SamB> Frederick: no.
19:47:27 <SamB> but I haven't heard of the other ones he knows
19:47:28 * Frederick adjusts his babel fish
19:47:48 <SamB> other than from him
19:47:52 <Frederick> my father is a retired physic
19:49:23 * SamB bets this is the only channel where people have trouble not doing other people's homework for them
19:49:37 <Cale> no, #math is like that too
19:49:57 <SamB> oh
19:50:27 <Frederick> yo Cale 
19:50:33 <Cale> Though if people start to expect it, I disappear :)
19:50:38 <Cale> hehe
19:50:57 <Frederick> #math saved my once
19:50:58 <SamB> Frederick: remind me to stop doing your homework for you ;-)
19:51:08 <Frederick> SamB, asap it is finished :p
19:51:10 <Cale> I'll usually help answer one question, and try to get some participation out of them while at it
19:51:25 <SamB> you are going to remind me AFTER it is finished, are you?
19:51:30 <SamB> that is TOO LATE!
19:51:40 <Frederick> SamB, I was talking about it before with the other guys
19:51:57 <Frederick> cause most channels like C
19:51:59 <Frederick> or java
19:52:16 <Frederick> someone writes the stuff you need but they actually dont even ask you if you know what you need
19:52:35 <Cale> heeh
19:52:40 <Cale> hehe*
19:52:48 <Frederick> I think it is cool discuss about transitive closure and stuff
19:52:48 <SamB> getting useful answers is like pulling teeth, right?
19:53:06 <SamB> and they treat you like an idiot, too
19:53:17 <Frederick> SamB, yes! this is the point
19:53:19 <SamB> well, probably because most of the people who go in there seem like idiots ;-)
19:53:35 <Frederick> it is like oh he isnt leeet so lets get the newbie
19:53:42 <SamB> and sometimes its hard to tell idiots from others
19:53:59 <SamB> maybe they are just bitter from dealing with C so much ;-)
19:54:18 <eivuokko> Hmmm
19:54:22 <SamB> maybe they are deliberately attempting to give C an unfriendly reputation
19:54:33 <SamB> because it isn't something you should use too casually
19:54:37 <Cale> hehe
19:54:46 <Cale> That's a good idea
19:55:05 <SamB> it probably works better than saying "Use Python"
19:55:08 <SamB> "use Haskell"
19:55:12 <SamB> "use Lisp"
19:55:15 <Cale> Give people subtly wrong and confusing answers.
19:55:15 <SamB> all the time
19:55:21 <SamB> nah.
19:55:27 <SamB> just answer the wrong question.
19:55:35 <Cale> Then they'll assume it's some problem with the language and try something else :)
19:55:39 <SamB> or be a smart aleck and answer the question as posed.
19:55:46 <Cale> :)
19:55:59 <SamB> anyway, guess who says "use Lisp"
19:56:35 <Cale> Paul Graham?
19:58:16 <SamB> Baughn
19:58:19 <SamB> IIRC
19:58:57 <Cale> who is Baughn?
19:59:21 <Frederick> SamB, how do you mark the replacers? I meant are they marked [] or just excluded?
19:59:50 <SamB> Frederick: they are just excluded if they aren't the root
20:01:08 <SamB> Cale: it does not say
20:01:57 <Frederick> hm
20:02:57 <Frederick> amazing
20:03:57 <Frederick> SamB, friday I will have tons of questions about thaty piece of code :p
20:04:44 <Frederick> I have a classmate
20:04:53 <Frederick> he deserves to die
20:05:00 <SamB> what does he do?
20:05:08 <Frederick> cause he can program in all freaking languages
20:05:20 <Frederick> he takes a book of something like ruby
20:05:31 <Frederick> and in 2 weeks he can program an os in ruby
20:05:39 <SamB> you can do that?
20:05:44 <SamB> OS? in Ruby?
20:05:44 <Cale> What's wrong with knowing how to program in a bunch of languages?
20:05:53 <SamB> I know you can do it Haskell, but Ruby?
20:06:00 <Cale> SamB: sure, at least, to some extent you could
20:06:06 <SamB> thats ALMOST as insane as doing an OS in python, as far as I can see!
20:06:10 <Frederick> Cale, the point is not knowing how to program, the point is learning a whole new language in like 1 week
20:06:15 <SamB> and thats not counting PyPy
20:06:31 <SamB> Frederick: well, tell him to try Haskell.
20:06:40 <Cale> Frederick: I can do that -- once you know a few imperative languages, they're all the same
20:06:44 <SamB> I guarentee he won't have it all learned in a week.
20:06:58 <SamB> Unless he is an FP freak too.
20:07:09 <SamB> where by FP I mean stuff like ML...
20:07:15 <Frederick> SamB, he doesnt leaves gome
20:07:23 <SamB> leaves gome?
20:07:38 <Frederick> home
20:07:53 <SamB> so?
20:07:55 <Cale> Ruby is relatively easy if you know Python and Objective C and Object Pascal and Java and Perl already.
20:08:19 <SamB> though the threading is simply abysmal
20:08:26 <Cale> You just figure out what's different about Ruby and what the syntax looks like.
20:08:34 <Frederick> I think that of these you mentioned the only one he may doesnt know  is objective c
20:08:35 <SamB> I don't know ruby, but I was looking at a threading tutorial and...
20:08:35 <Cale> and you can code in it with some documentation
20:08:42 <eivuokko> Argh.
20:08:43 <SamB> ... I was like:
20:08:45 <SamB> Wow.
20:09:02 <SamB> That is *so* *bad*.
20:09:13 <SamB> Now I remember why I don't do that in Python.
20:09:54 <SamB> That is what spawned the convoluted framework known only as "Twisted"
20:10:07 <eivuokko> I don't like haskell.org mailinglists, it appears I already am subscribed to glasgow-haskell-bugs, but I haven't got mail from there.  I hope answers CC me then..
20:10:07 <Frederick> I suck as a programmer
20:10:18 <SamB> That is *so much worse* than Haskell's threading model
20:10:30 <SamB> Frederick: nah.
20:10:51 <Frederick> SamB, I know only 1 paradigm
20:10:54 <SamB> You're just a newb ;-)
20:11:04 <SamB> which paradigm is that?
20:11:04 <Frederick> :D
20:11:49 <Frederick> imperative
20:11:52 <SamB> I was a newb like 5 years ago.
20:12:06 <SamB> Frederick: well if you put it that way, you have only one to go
20:12:20 <Frederick> what do you mean?
20:12:24 <SamB> because the only other paradigm I know than imperative is functional
20:12:38 <SamB> well, unless you count turing tarpit
20:12:49 <SamB> or esoteric
20:13:17 <SamB> which, really, don't count, because those aren't for getting jobs done, they are for proving points ;-)
20:13:36 <Frederick> SamB, my univerity has a great leak in its curriculum the only language they actually teach is pascal that is useless for practical reasons after the 1º semester is gone
20:14:13 <SamB> Frederick: well, just think of all the bad programming classes you don't have to sit through learning other languages badly ;-)
20:14:35 <SamB> though I admit that C would be more useful
20:14:36 <Frederick> SamB, yeah this is a point
20:14:41 <eivuokko> It might not be bad idea to teach programming in language that is useless.  First steps are more about thinking straight and doing the work.
20:14:53 <SamB> hmm, true
20:15:00 <Frederick> SamB, they clam that C is too hard for the first semester
20:15:04 <SamB> thinking straight is indeed nice ;-)
20:15:05 <fworp> though is pascal really that useless?
20:15:09 <SamB> Frederick: they are probably right
20:15:18 <SamB> Pascal really isn't THAT bad.
20:15:27 <SamB> if you learn a real Pascal, not the standard stuff.
20:15:31 <Frederick> but we have calculus, discrete math and classical logic in that semester so they have a contradiction
20:15:50 <SamB> maybe those aren't as hard as C
20:15:55 <SamB> to most students
20:16:12 <Frederick> SamB, discrete math has a failure avarage of like 50% of the class
20:16:14 <SamB> or maybe they shouldn't have all those in that semester ;-)
20:16:26 <Frederick> when I did logic 75% of the class failed
20:16:42 <Frederick> SamB, sure thet shouldnt
20:16:45 <eivuokko> Hmmm.
20:16:46 <SamB> what is classical logic, anyway?
20:17:14 <Frederick> http://plato.stanford.edu/entries/logic-classical/
20:19:42 <eivuokko> How can compiling ghc take this long -.-
20:19:43 <SamB> Frederick: is that actually what you were learning?
20:19:50 <SamB> because that sounds TOUGH
20:20:07 <eivuokko> I was thinking same
20:20:10 <SamB> reading GEB is one thing, but having to do a class in that kind of thing is totally another...
20:21:01 <Frederick> yep
20:21:03 <SamB> I mean, I'd want to make the computer do all the heavy lifting in that sorta thing ;-)
20:21:12 <Frederick> do you see the bunch of rules on the end of the page?
20:22:08 <SamB> bunch of rules?
20:22:09 <SamB> not exactly.
20:22:16 <SamB> I see that there are maths scattered throughout.
20:22:26 <Frederick> that thing of compound formulas
20:22:31 <Frederick> that was our first day of class
20:22:47 <SamB> huh
20:22:52 <SamB> TNT is complicated enough.
20:23:21 <SamB> then again, maybe I guess just that part is only a propositional calculus
20:23:35 <SamB> and there is no number theory in that class, presumably...
20:23:36 <Frederick> and my teachers never do the demonstrations they leave all "suggested as exercise"
20:23:42 <SamB> ouch
20:24:43 <Frederick> once 1 day before a test
20:25:15 <Frederick> we went to an extra class with a dude from master degrees to review some questions we had been unable to answer
20:25:50 <Frederick> and the mr master degrees look at one of them and says like omfg this is damm hard, you cant proof it
20:25:53 <SamB> and could he not answer them either?
20:26:37 <Frederick> and a dude who seats on the last classes say, hey dude it is here in the book it is trivial and suggested as exercise to the reader
20:26:46 <Frederick> so 1/2 of the guys gone away
20:26:55 <SamB> "trivial"
20:27:03 <SamB> hmm.
20:27:31 <SamB> you'd probably have more luck with open research problems ;-)
20:28:03 <Frederick> sure
20:28:05 <SamB> its surprising how much progress in mathematics is made by students who weren't paying attention in class ;-)
20:28:34 * SamB needs to go to bed
20:28:39 <Frederick> cya SamB 
20:28:43 <SamB> cya
20:28:49 <eivuokko> -.-
20:28:54 <SamB> but probably not be much help tomarrow.
20:29:01 <eivuokko> ghc compiled...and crashes if I run it from installed location
20:29:02 <SamB> eivuokko: no, the VCR says --:--
20:29:12 <SamB> eivuokko: ouch.
20:29:15 <Frederick> SamB, tommorow I have class 8~19 :(
20:29:25 <SamB> Frederick: ah
20:30:02 * SamB has class from his 9 to his 10:25, but has a meeting with his advisor at 11 and has ~1 hour trip to/from campus
20:30:25 <eivuokko> ghc is wierd, running it from stage2 complains about missing package-file (no matter arguments), and installed version just crashes no matter what.
20:30:26 <Frederick> SamB, are you graduating?
20:30:41 <SamB> Frederick: nah. I gotta sign up for some classes next semester.
20:31:04 <Frederick> SamB, here we dont have such things as advisors, just old and goodluck
20:31:28 <SamB> I'm just taking some stuff at community college right now (need to save my scholarships for stuff I can do as part of a full load...)
20:31:59 <Frederick> SamB, we go to sign up day with a paper like oh I wanna do this and this, and pray for the schedule fit
20:32:08 <SamB> was having trouble with english and stuff
20:32:48 <SamB> well, you still have to do most of that too...
20:33:02 * fworp had a similar problem on his shell account with the ghc5 fbsd binaries, it looked in a place that didnt exist, then when it did exist, it didnt care
20:33:05 <Frederick> most of what?
20:33:34 <SamB> well, you have say oh I wanna do this and this and this, and pray the schedule will fit.
20:33:43 <SamB> but sometimes you have to use computers
20:33:47 <SamB> and hurry and stuff
20:33:54 <Frederick> SamB, samething here
20:33:59 <SamB> ah
20:34:08 <SamB> it can really be a pain
20:34:52 <Frederick> SamB, I had never had real problems with schedule I allways magically end up with a good schedule, sometimes I have to beg for a place on a class but that is all
20:35:42 <Frederick> Ive begged for a place at COmputer Graphics Class and sleep 90% of the classes, I got a B+ in the first test and the teacher gave me the test like omfg how do you learn sleeping?
20:35:52 <dons> SamB, hmp3 on linux: is the terminal cursor visible? (it shouldn't be)
20:35:56 <SamB> at Lehigh University, the first semester schedule is basically done for you
20:36:05 <SamB> Frederick: did you put book under the pillow?
20:36:06 <dons> in my linux test set up, the cursor is still visible on linux. not on bsd.
20:36:21 <SamB> dons: it certainly isn't visible after hmp3 crashes for some reason or other
20:36:28 <dons> :p
20:36:35 <SamB> dons: I can't see it anywhere right now either
20:36:36 <Frederick> SamB, I have serious problems about sleeping in class
20:36:44 <Frederick> moslty I study at home on my own
20:36:53 <dons> i haven't been able to crash it on linux yet, btw. i'll keep trying.
20:36:59 <SamB> and it hasn't crashed in like 5 hours
20:37:07 <dons> ah. interesting.
20:37:09 <SamB> since you did that thing to make it more resilient
20:37:25 <SamB> it might have run into trouble, but no crashes
20:37:25 <dons> ok. hmm.
20:37:31 <Frederick> I would kill to study in a university like yours with sports and stuff
20:37:32 <SamB> I mean, wasn't that the idea?
20:38:03 <dons> yes, it should help. but i wasn't convinced i'd fixed the problem.
20:38:07 <SamB> Frederick: I need to get some stuff figured out before I go back there ;-)
20:38:15 <dons> thanks for all your testing SamB!
20:38:15 <SamB> dons: it probably hasn't.
20:38:19 <dons> @karma+ SamB
20:38:19 <lambdabot> SamB's karma raised to 5.
20:38:36 <SamB> dons: an MP3 player is like the easiest thing in the world to test ;-)
20:38:49 <dons> :) still, it takes time
20:38:53 <SamB> yeah
20:38:54 <dons> no cpu leaks?
20:39:01 <SamB> nope
20:39:04 <Frederick> SamB, but can you like leave the course and then take it back?
20:39:10 <dons> I really think I fixed that one. Really fixed it
20:39:13 <SamB> Frederick: course? no.
20:39:45 <SamB> I'll have to retake anything I left in the middle of, if I still need it for whatever major I pick...
20:40:19 <Frederick> SamB, like here I take and admission test with like 1300 for 100 vacancys
20:40:22 <sh10151> http://okmij.org/ftp/Computation/monadic-shell.html
20:40:43 <Frederick> SamB, so wich is the advantage of "dropping" it?
20:40:48 <SamB> Frederick: well, I don't need to be re accepted
20:41:02 <Frederick> SamB, features of a civilized country
20:41:41 <SamB> advantages of dropping a course in time are: more time for other courses, no bad grade on GPA
20:42:48 <SamB> advantages of withdrawing from everything: refunds for unconsumed tuition, room, board
20:43:10 <Frederick> my gpa sucks
20:43:12 <SamB> oh, and sanity ;-)
20:43:13 <Frederick> it is like B
20:43:17 <SamB> plenty of sanity
20:43:53 <SamB> well, at least, normal sanity as compared to being depressed and withdrawn and not getting to meals much.
20:44:06 <SamB> speaking of meals, I don't much like the breakfast they serve at Lehigh.
20:44:11 <SamB> its far too breakfasty.
20:44:33 <SamB> I prefer my breakfasts lunchy or dinner-y
20:44:54 * SamB really must be going
20:45:06 <Cale> I often wake up for dinner :)
20:45:11 <Cale> heh
20:45:15 <SamB> Cale: I did that once.
20:45:20 <SamB> I didn't feel so good.
20:45:27 <SamB> I felt like so tired!
20:45:29 <Frederick> cya
20:45:36 <SamB> it was an accident.
20:45:48 <SamB> I don't think I had any classes that day though
20:45:49 <eivuokko> Can I somehow trigger only one stage build for ghc?
20:45:49 <Cale> SamB: usually when I stay up until 9am or something
20:46:02 <SamB> eivuokko: make stage1
20:46:24 <Cale> It is kind of depressing to wake up to the sunset though.
20:47:23 <eivuokko> SamB, Thanks, gotta try, I guess.
20:52:21 * eivuokko starts adding putStrLns in ghc
20:52:38 <Cale> hmm, ~6% of the wiki pages are orphaned still.
21:27:21 <eivuokko> It seems *very* likely that ghc crashes inside happy-generated package.confg-parser. :-S
21:27:52 <eivuokko> Any ideas how to debug more?
21:28:13 <Korollary> which platform ?
21:28:18 <eivuokko> Windows.
21:28:35 <Korollary> oh, you're going for the cygwin target ?
21:28:42 <eivuokko> No..
21:28:53 <Korollary> ah ok
21:29:03 <Korollary> you're just writing something else that runs on windows
21:29:26 <eivuokko> I am compiling GHC, this is crash from ghc that I have compiled and installed :)
21:29:48 <Korollary> are you targetting cygwin or mingw ?
21:29:53 <eivuokko> Mingw.
21:30:08 <eivuokko> Hmmm, do I need specific gcc version?
21:30:22 <Korollary> well, given that there exists a binary already, you may be doing something wrong.
21:30:31 * eivuokko steals gcc from 6.4.1
21:30:53 <eivuokko> Yeah, might be
21:33:38 <eivuokko> Meh, same gcc
21:58:30 * araujo saluda a Nomius 
21:58:39 <araujo> Anyone good with CT awake? 
21:58:43 <machack666> any good examples of MonadReader in action?  I'm looking for something targetting not quite beginners, but not category theory experts either.
22:04:37 <araujo> mm...
22:07:40 <dons> bah, global scoped record selectors force an unnatural style, where you have to start managing your own sub-namespaces with hacks to the identifiers
22:07:50 <araujo> Hello dons 
22:08:06 <dons> hey araujo
22:46:46 <Korollary> meme last logged the channel on the 14th.
22:46:56 <araujo> monads: A way to structure computations using values and sequence of more computations.
22:46:57 <araujo> ?
22:55:37 <Korollary> araujo: have you read http://haskell.org/hawiki/MonadsAsContainers ?
22:57:08 <Korollary> hey sethk
22:57:25 <sethk> Korollary, evening.
22:57:31 <sethk> Korollary, how's everything?
22:57:39 <araujo> Korollary, http://www.nomaware.com/monads/html/introduction.html
22:57:42 <araujo> that's what i read
22:57:43 <sethk> Korollary, they are asking me about moving to Seattle again.  I'm stalling again.  :)
22:58:20 <Korollary> araujo: That's a good one as well. You should read both.
22:58:59 <Korollary> sethk: things are ok. I'm moving into my own apartment next week.
22:59:06 <sethk> Korollary, sounds good.
22:59:22 <sethk> Korollary, I'm going to do a linux reinstall on this laptop, so I'll be back, I hope, in about 1/2 an hour.
23:23:59 <boegel> CosmicRay: ping !
23:26:37 * ski wonders what araujo wonders about CT
23:32:18 <Korollary> @localtime ski
23:32:19 <lambdabot> Local time for ski is Thu Nov 17 08:33:58
23:32:26 <Korollary> nothing like CT in the morning, eh
23:33:08 <araujo> owo... ufff
23:34:16 * araujo getting out of a trying-to-understand-monad mental absortion
23:35:09 * ski winders what the type of costrength is ..
23:35:12 <araujo> ski, i only wanted to discuss about it :-)
23:35:23 <ski> discuss what about it ?
23:35:38 <araujo> I mean, a category is a collection of objects right?
23:35:47 <ski> not only
23:35:59 <araujo> Why not?
23:36:13 <araujo> I meanm, what else they could be
23:38:16 <ski> a category consists of : a) a collection of objects, b) for every pair of objects, a collection of morphisms, c) for every object an identity morphism, d) for every pair of morphisms, where codomain of one = domain of the other, a composition morphism, e) identity is left identity of compisition, f) identity is right identity of composition, g) composition is associative
23:38:25 <araujo> ski, I mean, as far as i understand, these objects can be any abstract entity
23:38:33 <ski> they can, yes
23:39:05 <ski> a,b) is the collection parts,  c,d) is the morphism parts,  e,f,g) is the laws parts
23:39:44 <araujo> mm.. right, a collection of morphism , hadn't seen it like that.....
23:40:26 <ski> (morphisms = arrows = maps)
23:40:30 <araujo> yeah
23:40:57 <araujo> ski, every object always need to have an identity right?
23:41:05 <ski> right
23:41:36 <araujo> So, in a category there is always gonna be at least one morphism?
23:41:52 <ski> nope
23:42:00 <ski> there doesn't have to be any objects
23:42:11 <araujo> Oh , didn't know that
23:42:16 <ski> Obj :: *   -- collection of objects
23:42:31 <araujo> You can have a category without objects?
23:43:01 <ski> Mor :: Obj -> Obj -> *   -- collection of morphisms, for each pair of objects
23:43:04 <ski> yes
23:43:08 <ski> Obj can be empty
23:43:25 <araujo> O, i see, an empty collection
23:43:31 <ski> right
23:43:41 <araujo> Good, didn't know that
23:43:44 <ski> but, each object still needs an identity
23:44:07 <ski> id :: forall a:: Obj. Mor a a
23:44:23 <araujo> I see.
23:44:37 <ski> (.) :: forall a,b,c :: Obj. Mor b c -> Mor a b -> Mor a c
23:44:41 <ski> etc
23:45:00 <araujo> I see :-)
23:45:33 <ski> forall a,b :: Obj. forall f :: Mor a b. id . f = f
23:45:39 <ski> forall a,b :: Obj. forall f :: Mor a b. f . id = f
23:46:23 <ski> forall a,b,c,d :: Obj. forall f :: Mor a b,g :: Mor b c, h :: Mor c d. (h . g) . f = h . (g . f)
23:46:28 <ski> this is all
23:46:42 <araujo> ski, but, if we don't have objects, i suppose we can't have id too?
23:47:32 <ski> sure we can
23:47:43 <ski> for each object, we should have an id
23:47:44 <araujo> Right, that's the identity and associativity properties.
23:48:16 <ski> if there's no object, we trivially have a general id .. it consists of 0 morphisms (because there are 0 objects)
23:48:24 <araujo> Aaaah!
23:48:31 <araujo> I see now
23:48:42 <ski> if we have 2 objects we need 2 parts of id, one for each object
23:48:48 <ski> right
23:50:47 <araujo> Nice, Thanks a lot ski 
23:51:11 <ski> yw
23:52:01 <araujo> ski, Do you recommend some book for CT?
23:53:42 <ski> hm
23:53:59 <ski> what kind of book ?
23:54:15 <ski> jus general CT ? or CS directed ?
23:54:21 <ski> s/jus/just/
23:54:23 <astrolabe> id normally refers to a morphism rather than a set of morphisms
23:54:50 <ski> id is a polymorphic morphism
23:55:01 <ski> id_A :: Mor A A
23:55:01 <araujo> ski, CS directed would be better (for me)
23:55:06 <astrolabe> So if there are no objects, I would say there are no ids.  ie no identity morphishms
23:55:20 <ski> but id still exists
23:55:44 <astrolabe> So why do you say 'for each object, we should have an id'?
23:56:25 <ski> Korollary mentioned http://www.amazon.com/exec/obidos/tg/detail/-/0262660717/ref=wl_it_dp/104-8766715-6253502?%5Fencoding=UTF8&coliid=ITLY2XI0CO1T5&v=glance&colid=1WW1C3M6AL0ZU previously
23:56:36 <ski> that is nice, and not very thick
23:59:08 <ski> this is also nice, and a little longer Asperti, Andrea, & Longo, Giuseppe (1991). Categories, Types and Structures, it is available online, now ftp://ftp.di.ens.fr/pub/users/longo/CategTypesStructures/book.pdf
