01:09:24 * boegel|home y0ws
01:10:49 <Oejet> boegel: Hey.
01:12:54 <ValarQ> g'day folks
01:20:22 <ski> @arr
01:20:22 <lambdabot> Ahoy mateys
01:21:26 <boegel|home> who didn't vote on the TopTenLibraries poll yet ?
01:21:38 * boegel|home brings out a big stick to whack people who didn't
01:21:45 * xerox hides
01:21:53 <xerox> Give me an url!
01:22:11 <boegel|home> @show-poll TopTenLibraries
01:22:12 <lambdabot> Unknown command, try @listcommands.
01:22:14 <boegel|home> no need for an url
01:22:19 <boegel|home> @poll-show TopTenLibraries
01:22:20 <lambdabot> ["stm","WASH","HOpenGL","Arrows","FastPackedString","FGL","wxHaskell","
01:22:20 <lambdabot> QuickCheck","Parsec","MissingH","HaXml","HList","hs-plugins","Yampa","
01:22:20 <lambdabot> Gtk2Hs","HTTP","NewBinary","XmlRpc"]
01:22:23 <xerox> Uh.
01:22:29 <xerox> How to vote?
01:22:31 <boegel|home> use @vote TopTenLibraries <choice> to vote
01:22:42 <boegel|home> you can add more libraries too if you want
01:22:53 <luqui> @vote Parsec
01:22:54 <lambdabot> usage: @vote <poll> <choice>
01:23:02 <luqui> @vote TopTenLibraries Parsec
01:23:03 <lambdabot> voted on "Parsec"
01:23:05 <xerox> @vote TopTenLibraries Gtk2Hs
01:23:06 <lambdabot> voted on "Gtk2Hs"
01:23:17 <xerox> Who wrote @vote ?
01:23:54 <boegel|home> xerox: I did, dons improved it (changed some stuff, made sure state doesn't get lost when lambdabot quits, ...)
01:24:06 <luqui> "The people who cast the votes decide nothing. The people who count the votes decide everything."
01:24:07 <xerox> Cool.
01:24:16 <boegel|home> luqui: heh :)
01:24:27 <boegel|home> it's only a guidance for choosing the top 10 libraries
01:25:03 <boegel|home> luqui: btw, I won't rank the entries, I'll just give 10 libraries, I won't choose the best one or so
01:25:12 * luqui feels dirty for quoting stalin now...
01:25:22 * boegel|home washes luqui 
01:25:31 * xerox tapes it
01:25:39 <luqui> haha
01:26:08 <boegel|home> :)
01:29:14 <musasabi> is that one vote / person?
01:29:59 <musasabi> Parsec, hs-plugins, haskelldb and STM.
01:33:15 <boegel|home> musasabi: just go and vote, you can vote multiple times
01:33:30 <boegel|home> and haskelldb isn't in there yet... should I add it ?
01:33:30 <luqui> for the same thing? ;-)
01:33:47 <boegel|home> luqui: well, prefarably not, but it won't help you, there's no ranking :)
01:38:54 <xerox> Hoy, basti_!
01:54:06 * ski wonders why one can vote multiple times, if there's no ranking
01:54:48 <boegel|home> ski: you can vote on several entries, and because there's no logging
01:54:58 <boegel|home> if you like several libraries, you shouldn't be limited to one
01:55:23 <ski> won't that skew the vote count ?
01:55:39 <flux__> condercet voting!
01:59:07 <maitscha> hello. I have a problem with data types. when i define >	data Tree = Leaf Int | 
01:59:08 <maitscha> >							Node Int Tree Tree
01:59:08 <maitscha> > data STree = SNil | 
01:59:08 <maitscha> >							 SLeaf Int | 
01:59:08 <maitscha> >							 SNode Int STree STree
01:59:08 <lambdabot>  parse error on input `data'
01:59:40 <maitscha> i get an error "syntax error in input", unexpected keyword "data". any ideas?
02:00:19 <boegel|home> ski: the poll is just an aid for me to choose 10 libraries, we will improve the vote plugin in a second stage
02:00:37 <boegel|home> ski: we just don't know yet if we'll use nickname logging, ip-logging or ...
02:00:50 <maitscha> why do i get an error?
02:01:01 <luqui> maitscha, looks okay to me... how's your indentation?
02:01:07 <malcolm_> maitscha: you can't define datatypes at the prompt in hugs or ghci
02:01:11 <luqui> are both "data"s in the first column?
02:01:14 <liyang> maitscha: Which line is the error on? Try getting rid of the hard tabs.
02:01:24 <luqui> oh... yeah, if you're doing that in ghci, you can't.
02:01:31 <maitscha> i get an error on the second data definition
02:02:11 <maitscha> when I put a function after the first data definition, i get the error in the line of the definition of the function
02:02:44 <malcolm_> @paste
02:02:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:02:54 <liyang> maitscha: have you set tabs in your editor to be 2 spaces wide?
02:02:55 <luqui> that is such a crappy paste page
02:03:22 <luqui> you have to sign up for an account or log in.  either way it takes like two or three minutes to paste.  it's easier to go watch TV.
02:03:31 <sieni> maitscha: Are the "data"s in the first column on a line?
02:04:09 <xinming> lisppaste2: url
02:04:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:05:11 <maitscha> liyang: yes, a tab is two spaces long
02:05:32 <luqui> try replacing your tabs with spaces
02:05:53 <liyang> maitscha: don't mix tabs and spaces...
02:06:22 <liyang> or if you do, remember the compiler treats tabs as 8 spaces wide.
02:06:29 <maitscha> hmm.... i have found the error.
02:06:40 <maitscha> i need a tab in front of my definitions and function declarations.
02:06:52 <luqui> uh... that seems wrong
02:07:00 <liyang> maitscha: use spaces instead. Really. :)
02:07:13 <luqui> do you have a "module" line at the top of your program?
02:07:25 <maitscha> ok. i will use spaces.
02:07:59 * sieni is still angry at the person who put whitespace sensitivity into haskell
02:08:21 <luqui> sieni, how would you prefer?
02:08:28 <luqui> you need a way to get that structure in there somehow
02:09:13 <luqui> (not that I'm arguing; to be fair, I agree, it seems to cause more headache than convenience)
02:10:14 <sieni> explicit grouping?
02:10:18 <sieni> semicolons?
02:10:34 <liyang> It looks rubbish. :)
02:10:35 <sieni> I find whitespace sensitive syntax hard to parse
02:13:03 <sieni> maitscha: But anyway, http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout might be helpful to understand the possible layout problems.
02:15:18 <luqui> sieni, by "hard to parse", you're referring to a Human's ability, not a computer's, right?
02:15:32 <sieni> luqui: human's, yes
02:17:18 <sieni> well, at least haskell doesn't suck otherwise, so it's tolerable ;-)
02:17:59 <sieni> unlike another language, whose name I won't dear to utter here
02:18:07 <sieni> dare
02:18:24 <sieni> goddammit, I'm getting the American Spelling Syndrome :-/
02:21:42 * luqui wonders what name sieni dared not utter
02:22:49 * luqui is intent on starting a flame war by having sieni say it
02:22:52 <luqui> :-)
02:24:50 <malcolm_> you don't have to use layout in haskell - braces and semicolons are available
02:26:00 <luqui> yeah, but that doesn't keep it from whining when you disagree with it
02:26:06 <luqui> well, maybe it does
02:26:13 <luqui> I've never used braces and semicolons
02:27:38 <luqui> okay, it does keep it from whining
02:27:40 <luqui> that's cool
02:30:30 <malcolm_> Once you start a block with a brace, it ignores layout altogether.  (At least until you start a nested block without braces, when layout can kick in again.)  So you can mix layout and non-layout pretty freely, and it always does pretty-much the right thing.
02:47:34 <benny> where can i find a changelog of ghc?
03:04:01 <triplah> is there a roblem with pattern matching more than 2 clauses?
03:04:05 <triplah> problem*
03:04:20 <xerox> triplah: what do you mean?
03:05:02 <triplah> hmm
03:05:07 <triplah> actually i might be ok
03:05:35 <triplah> Top level:
03:05:35 <triplah>     No instance for (Show ([a] -> [a]))
03:05:35 <triplah>       arising from use of `print' at Top level
03:05:35 <triplah>     Probable fix: add an instance declaration for (Show ([a] -> [a]))
03:05:35 <triplah>     In a 'do' expression: print it
03:05:58 <xerox> Are you missing a parameter?
03:06:11 <triplah> argh yes
03:06:15 <triplah> thats one error down
03:06:25 <triplah> thanks xerox  :)
03:06:31 <xerox> You're welcome!
03:06:35 <triplah>  No instance for (Ord (a -> a))
03:06:35 <triplah>       arising from use of `_minimaBy' at <interactive>:1:0-8
03:06:35 <triplah>     Probable fix: add an instance declaration for (Ord (a -> a))
03:06:35 <triplah>     In the definition of `it': it = _minimaBy min [4, 2, 5, 2, 3, 1] []
03:06:41 <triplah> thats my next one :)
03:06:47 <balls3> is haskell a form of lisp?
03:06:52 <triplah> balls3: nope
03:07:10 <triplah> balls3: haskell is purely functional, lisp has plenty of side effects
03:07:20 <xerox> triplah: what is `_minimaBy' ?
03:07:28 <triplah> syntactically they arent that similar either
03:07:42 <triplah> xerox: i'll pastebin it, its 5 lines
03:07:42 <xerox> balls3: Howdy, are you learning Haskell?
03:07:46 <balls3> what is a side effect
03:07:52 <balls3> well
03:07:59 <balls3> I dont know almost any programming
03:08:03 <triplah> eep :)
03:08:10 <balls3> but saw some essays about functional programming
03:08:10 <triplah> i'm learning haskell at the moment too
03:08:23 <triplah> lisppaste2: url
03:08:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:08:58 <triplah> i can say that haskell is VERY cool
03:09:02 <xerox> balls3: there are many kind of side effects, you can think of them in terms of a mutable state which value you can't rely on.
03:09:16 <triplah> but i guess i think that because it is expressivly a LOT more powerful than any other language i've seen
03:09:17 <xerox> balls3: that is, mutability is some kind of side effect.
03:09:24 <triplah> i havent mastered it yet though :)
03:09:59 <triplah> in C/Java a perfect example of that is using global variables
03:10:13 <triplah> any language actually
03:10:20 <ski> side-effects, are those effects of functions which are not : returning the result value
03:10:50 <lisppaste2> triplah pasted "_minimaBy" at http://paste.lisp.org/display/14022
03:10:53 <ski> if a function prints something on screen, or modifies a file, that's a side-effect, e.g.
03:10:57 <xerox> balls3: another kind of side effect could be interacting with the Real World.  That is, think of a piece of code getting 'a key pressed by the user'.  It potentially return different values every time.
03:11:30 <xerox> triplah: what is that code supposed to do?
03:12:08 <triplah> xerox: takes a list and makes the list of the smallest elements by "f" from the original list
03:12:26 <xerox> Why does it take two lists?
03:12:41 <triplah> ie, _minimaBy length ["cow","something"] -> ["cow"]
03:12:55 <triplah> one is the list of elements, another is the list to return
03:13:01 <ski> triplah : this isn't prolog :)
03:13:14 <xerox> So ski kicks in, I'll pass :-)
03:13:16 <triplah> ski: yeah, i start doing pattern matchin... then it seems like the logical way
03:13:22 <triplah> oh ho ho "logical"
03:13:29 <ski> hehe
03:13:30 <triplah> doh :)
03:14:05 <ski> functions return values (when passed arguments), predicates relates arguments
03:14:28 <ski> arguments of functions in functional programming languages are usually only input
03:14:34 <lisppaste2> triplah annotated #14022 with "minimaBy before i made 3 clauses" at http://paste.lisp.org/display/14022#1
03:14:39 <xerox> ski: what makes things 'move' in the logical world?
03:15:06 <ski> each argument of a predicate can be either input or output (or indeed both)
03:15:24 <triplah> ergh
03:15:34 <ski> xerox : predicates calls other predicates .. results are passed out from arguments
03:15:34 <triplah> the last two lines of the last annotation should be commented out
03:15:57 <balls3> so
03:16:00 <xerox> ski: is the whole thing lazy?
03:16:04 <balls3> what is the advantage of haskell
03:16:12 <balls3> over say clisp or squeak
03:16:12 <triplah> balls3: where to start :) ....
03:16:12 <xerox> balls3: the fun!
03:16:30 <balls3> cmon gime a few ez buzzword benefits
03:16:33 <balls3> the sizzle
03:16:33 <triplah> balls3: lazy evaluation, list comprehension 
03:16:39 <triplah> they are my two faves
03:16:47 <balls3> uh
03:16:49 <triplah> pattern matching is pretty powerful too
03:16:52 <balls3> i dont speak haskell
03:16:53 <xerox> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 13 fibs
03:16:54 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233]
03:16:59 <balls3> give me mroe english
03:17:12 <ski> xerox : e.g. '?- append([1],[2,3],Xs).' will give the single solution 'Xs = [1,2,3]' .. while '?- append(Xs,Ys,[1,2,3]).' will give four solutions, 'Xs = [],Ys = [1,2,3]', 'Xs = [1],Ys = [2,3]', 'Xs = [1,2],Ys = [3]', 'Xs = [1,2,3],Ys = []'
03:17:13 <xerox> > let fact n = product [1..n] in fact 10
03:17:14 <lambdabot> 3628800
03:17:21 <triplah> lazy evalution means that arguments to a function arent evaluated until they are needed
03:17:39 <triplah> so in some other language....
03:17:55 <ski> xerox : arguments aren't fixed to be input or output, they can be input in one call, and output in another call (this is one very cool thing about logic programming)
03:18:03 <triplah> somefunc(5,10/0) would throw a compile time error
03:18:08 <xerox> ski: hmm, okay.
03:18:10 <triplah> because of divide by 0
03:18:13 <balls3> ok
03:18:25 <triplah> but in haskell it'll throw the error when it runs 10/0
03:18:30 <triplah> this means we can do something like
03:18:34 <ski> xerox : predicate calls in prolog are strict, but backtracking could be said to be lazy (compare lazy lists and list monad)
03:18:34 <balls3> so how does haskell let me do less time effort or work to make my computer deprartment supoor tthe business?
03:18:45 <xerox> > let f x y = x in f "won!" (10 / 0)
03:18:47 <lambdabot> "won!"
03:18:49 <balls3> how does haskell save or maek me money
03:18:54 <triplah> we can pass a list of all possible integers like this
03:18:56 <triplah> [1..]
03:19:02 <triplah> haskell will run it
03:19:16 <xerox> ski: oh-uhm.
03:19:19 <triplah> and wont throw an error
03:19:31 <ski> > take 10 (map (* 3) [1..])
03:19:32 <lambdabot> [3,6,9,12,15,18,21,24,27,30]
03:20:00 * boegel|home leaves to have lunch and go and watch the new Harry Potter movie
03:20:03 <ski> > take 10 (filter even (map (* 3) [1..]))
03:20:05 <lambdabot> [6,12,18,24,30,36,42,48,54,60]
03:20:35 <triplah> lambdabot: will only throw an error after a while with something like this
03:20:46 <xerox> > let fnord = 1 : 0 : fnord in take 10 fnord
03:20:48 <lambdabot> [1,0,1,0,1,0,1,0,1,0]
03:21:06 <triplah> > map *1 [1..]
03:21:07 <lambdabot>   add an instance declaration for (Num ([a1] -> (a -> b) -> [a] -> [b]))
03:21:13 <triplah> woops
03:21:14 <triplah> :)
03:21:15 <ski> forgot parens ..
03:21:17 <triplah> <-- noob
03:21:19 <triplah> yep
03:21:30 <triplah> > map (* 1) [1..]
03:21:31 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
03:21:31 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
03:21:31 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
03:21:31 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
03:21:31 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
03:21:33 <lambdabot> [24 @more lines]
03:21:37 <triplah> heh :)
03:21:58 <ski> (that should say, "at least 24 ...")
03:21:58 <xerox> map (*1) == id :: Num a => [a] -> [a]
03:22:27 <triplah> balls3: haskell can make you money. but you will not understand that until you understand the language
03:22:42 <triplah> i know i'll get flamed for this, but it sounds like you want a more mainstream language :P
03:22:52 <xerox> That's untrue.
03:22:56 <triplah> see :)
03:23:04 <balls3> why
03:23:11 <ski> balls3 : with haskell, you don't have to retype many things over and over again ... you can make functions and higher-order functions, where in other languages one has to write the full loop each time
03:23:14 <balls3> Im not needin main steam
03:23:15 <xerox> I just made $4500 with a Google SoC project in Haskell.
03:23:25 <neologism> what project?
03:23:26 <triplah> SoC?
03:23:34 <triplah> summer of code?
03:23:34 <xerox> Summer of Code (code.google.com)
03:23:37 <triplah> yep
03:23:41 <neologism> what did you code?
03:23:46 <balls3> what does your code do?
03:23:47 <xerox> neologism: writing the Cairo bindings and integrating them in Gtk2Hs :-)
03:23:55 <triplah> ehe nice
03:23:57 <neologism> nice
03:23:58 <balls3> so haskell has good means of abstraction?
03:24:14 <triplah> very much so, it makes sense
03:24:20 <xerox> ...and then wrote an example application to show off their power.
03:24:24 <xerox> @where nymphaea
03:24:24 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
03:24:35 <triplah> why should i be able to do something to two numbers, and not care what i'm doing to them until i know what it is
03:24:36 <balls3> is it best to build websites with a database talking to haskell or with haskell alone?
03:24:41 <triplah> shouldnt*
03:25:02 <xerox> I can't say, in general.
03:25:24 <triplah> haha
03:25:26 <shapr> It depends on the website
03:25:28 <triplah> the images are in the porn dir
03:25:31 <triplah> i like it :)
03:26:07 <ski> (triplah : can you restate that question ?)
03:26:41 <triplah> ski: you mean the one i just asked?
03:26:47 <triplah> it was rhetoric :P
03:26:53 <xerox> @type Data.List.minimumBy
03:26:54 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:27:09 <triplah> xerox: i'm aware of that one, but that takes a comparison function
03:27:16 <triplah> i want to just pass a single function to it
03:27:28 <shapr> balls3: Haskell makes you money by requiring less developer time.
03:27:30 <triplah> like, length
03:27:59 <xerox> @type foldl (minimumBy)
03:28:00 <lambdabot> Not in scope: `minimumBy'
03:28:03 <xerox> @type foldl (List.minimumBy)
03:28:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a ->
03:28:05 <lambdabot> Ordering
03:28:05 <lambdabot>   Expected type: (a -> a -> Ordering) -> [a] -> a -> a -> Ordering
03:28:10 <xerox> Heh, let me play.
03:28:20 <triplah> ehe
03:28:33 <triplah> it'd have to be a function that compares two numbers
03:28:42 <triplah> i'm sort of doing the comparison in the function
03:28:43 <shapr> balls3: It also increases the amount of typechecking that is available to your developers.
03:29:00 <ski> @type \cmp -> foldl (List.minimumBy cmp)
03:29:00 <triplah> then i'd pass a function that returns a number as the arg
03:29:01 <lambdabot>   Occurs check: cannot construct the infinite type: t = [b -> t]
03:29:01 <lambdabot>   Expected type: [b -> t] -> b -> [b -> t]
03:29:25 <xerox> ski: ahah, just tried.
03:29:36 <triplah> > List.minimumBy (\x y -> length x `compare` length y) ["qre", "wfsdfs"]
03:29:37 <lambdabot> "qre"
03:29:53 <triplah> thats not what i want though :P
03:29:55 <shapr> My favorite feature of the moment is immutable values. It's irritating when object variables change unexpectedly in Python/Java.
03:29:56 <benny> which haskell sdl bindings are the best?
03:30:03 <xerox> triplah: why so?
03:30:03 <araujo> Good morning Haskell'ers!
03:30:09 <shapr> Hola araujo 
03:30:16 <triplah> i want to do this
03:30:23 <benny> shapr: is your binding the best?
03:30:30 <triplah> > List.minimumBy length  ["qre", "wfsdfs"]
03:30:31 <lambdabot>   Expecting a function type, but found `Int'
03:30:31 <lambdabot>   Expected type: [a] -> [a] -> Ordering
03:30:31 <lambdabot>   Inferred type: [a] -> Int
03:30:34 <shapr> benny: I haven't written one. 
03:30:48 <araujo> Hola shapr , what's up?
03:30:56 <benny> shapr: hm....
03:31:01 <shapr> benny: I think SDL bindings have been written by Lemmih, dark, Adrian Hey, and someone in France whose name I've forgotten.
03:31:25 <benny> oops sorry i meant lemmih's bindings... are his the best?
03:31:26 <xerox> > let quux f = List.minimumBy (\x y -> f x `compare` f y) in quux length ["qre", "wfsdfs"]
03:31:27 <lambdabot> "qre"
03:31:43 <shapr> benny: I'd suggest you choose between Lemmih and Adrian Hey's bindings, they're the most recent.
03:31:56 <xerox> If you need OpenGL, there is OpenGL support in the Gtk ones too.
03:32:05 <triplah> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima id ["dfsf","ewrwr"]
03:32:06 <lambdabot> ["dfsf"]
03:32:15 <triplah> still not what i want though :)
03:32:16 <benny> i'm more interested in plain sdl cause i just want to do 2d drawing
03:32:17 <shapr> Has anyone tried Sven Panne's OpenAL bindings?
03:32:23 <shapr> benny: Seen the cairo bindings?
03:32:26 <xerox> benny: uh.
03:32:30 * xerox pats shapr
03:32:38 <benny> shapr: i've read about them
03:32:41 * ski wonders what triplah wants
03:32:45 <benny> but i want to do pixel drawing, not vector
03:32:49 <benny> so cairo is not for me
03:32:53 <shapr> Ah, ok
03:33:02 <triplah> i want this :)
03:33:04 <triplah> > minimaBy length [ "cow", "moose", "llama" ]
03:33:05 <xerox> What are you doing pixel drawing for, if I could ask?
03:33:05 <lambdabot>  Not in scope: `minimaBy'
03:33:11 <triplah> > List.minimaBy length [ "cow", "moose", "llama" ]
03:33:11 <lambdabot>  Not in scope: `List.minimaBy'
03:33:15 <triplah> ergh
03:33:20 <triplah> > List.minimumBy length [ "cow", "moose", "llama" ]
03:33:20 <lambdabot>   Expecting a function type, but found `Int'
03:33:20 <lambdabot>   Expected type: [a] -> [a] -> Ordering
03:33:20 <lambdabot>   Inferred type: [a] -> Int
03:33:24 <benny> xerox: fractal renderer i think
03:33:26 <xerox> triplah: some wordy explanation would be nice.
03:33:32 <triplah> thats how i need to be able to call minimaBy
03:33:34 <shapr> maximaul!
03:33:34 <triplah> sorry :)
03:33:37 <xerox> benny: oh, sounds fun.
03:33:55 <shapr> benny: You could use OpenGL for extra fun :-)
03:34:12 <shapr> araujo: I'm up! just now! What's up with you?
03:34:23 <benny> shapr: unfortunately i only have a 9 year old laptop that doesn't have hardware opengl
03:34:32 <triplah> i want to basically change every value in the original list to an integer representation, then return the original values with the smallest integer representation
03:34:46 <araujo> shapr, haha, just getting up too, next to have some breakfast :-)
03:34:53 <benny> bbiab gotta go on a rl quest
03:34:54 <shapr> benny: oh
03:35:04 <triplah> so length returns an integer
03:35:04 <benny> shapr: yeah :( i need money :'(
03:35:05 <ski> triplah : (just looked at paste) .. ah you do an accumulator .. then i prolly misunderstood you before (about functions and predicates ..)
03:35:20 <triplah> ski: ehe :)
03:35:37 <xerox> > let triplah f = fst . head . sort . map (id &&& f) in triplah (length) ["a", "bc", "cd"]
03:35:38 <lambdabot> "a"
03:35:39 <xerox> Okay? :-)
03:35:56 <triplah> ahah
03:35:58 <triplah> cheats!
03:36:04 <xerox> Why!
03:36:29 <triplah> interesting take though :)
03:36:42 <triplah> can you tell me exactly what id does?
03:36:53 <xerox> Yep, it's the identity function.
03:37:05 <xerox> It just returns its argument.
03:37:06 <ski> triplah : are you shure xerox's 'quux' above doesn't do what you want, too ?
03:37:23 <ski> id a = a
03:37:35 <triplah> > let minima f xs = filter (\x -> (f x) == (foldl1 min (map f xs))) xs in minima id ["423","Ferfef","d"]
03:37:36 <lambdabot> ["423"]
03:37:41 <triplah> ahh
03:37:43 <triplah> :)
03:37:47 <triplah> broken!
03:37:52 <triplah> cant use that then
03:38:00 <ski> > let triplah f = fst . head . sort . map (id &&& f) in triplah (length) ["x", "bc", "cd"]
03:38:01 <lambdabot> "bc"
03:38:02 <xerox> > let quux f = List.minimumBy (\x y -> f x `compare` f y) in quux length ["423","Ferfef","d"]
03:38:04 <lambdabot> "d"
03:38:20 <ski> xerox : does 'triplah' really work ?
03:38:37 <xerox> > let triplah f = fst . head . sort . map (id &&& f) in triplah (length) ["423","Ferfef","d"]
03:38:39 <lambdabot> "423"
03:38:42 <xerox> Uh.
03:38:47 <xerox> Gotcha.
03:38:58 <xerox> > let triplah f = snd . head . sort . map (f &&& id) in triplah (length) ["423","Ferfef","d"]
03:38:59 <lambdabot> "d"
03:39:01 <xerox> :-)
03:39:04 <ski> > let triplah f = fst . head . sort . map (id &&& f) in triplah (length) ["x423","Ferfef","ddddddd"]
03:39:05 <lambdabot> "Ferfef"
03:39:12 <xerox> (Now it does)
03:39:14 <triplah> ehe
03:39:18 <ski> right :)
03:39:38 <ski> @type let triplah f = fst . head . sort . map (id &&& f) in triplah
03:39:39 <lambdabot> Not in scope: `sort'
03:39:39 <lambdabot>  
03:39:39 <lambdabot> <interactive>:1:44: Not in scope: `&&&'
03:39:48 <ski> @type let triplah f = fst . head . Data.List.sort . map (id &&& f) in triplah
03:39:49 <lambdabot> Not in scope: `&&&'
03:39:53 <xerox> Control.Arrow.&&&
03:40:02 <ski> @type let triplah f = fst . head . Data.List.sort . map (id Control.Arrow.&&& f) in triplah
03:40:03 <lambdabot> forall a c'. (Ord (a, c')) => (a -> c') -> [a] -> a
03:40:04 <triplah> sorry what is &&& doing?
03:40:10 <triplah> im very new to haskell
03:40:14 <xerox> @type (Control.Arrow.&&&)
03:40:15 <lambdabot> forall (a :: * -> * -> *) c' c b.
03:40:15 <lambdabot> (Control.Arrow.Arrow a) =>
03:40:15 <lambdabot> a b c -> a b c' -> a b (c, c')
03:40:21 <xerox> That thing :-I
03:40:25 <triplah> lol
03:40:27 <triplah> :O
03:40:29 <xerox> OK, I just wanted to scare you.
03:40:35 <xerox> It's rather simple, in fact!
03:40:42 <ski> in this case, it has type    (a -> b0) -> (a -> b1) -> (a -> (b0,b1))
03:41:08 <triplah> argh, i'm being pressured into going out for a smoke
03:41:10 <triplah> back in 5
03:41:11 <xerox> > (+2) &&& (subtract 2) $ 0
03:41:12 <lambdabot> (2,-2)
03:41:15 <ski> i.e. given two functions that both take an 'a' and give something, we make a function that take an 'a', pass it to both functions, and pair the results
03:41:26 <triplah> so much syntax i dont get! :P
03:41:28 <xerox> > let dup = id &&& id in dup 1
03:41:29 <lambdabot> (1,1)
03:41:32 <xerox> ^- you see?
03:41:45 <triplah> er sorta
03:41:48 * triplah squints
03:41:51 <triplah> brb :)
03:41:55 <xerox> Try writing &&& definition
03:42:12 <xerox> (f &&& g) x = (f x, g x)
03:42:16 <xerox> Oops, sorry.
03:42:23 <ski> @type let triplah f = fst . head . Data.List.sortBy (\x y -> fst x `compare` fst y)  . map (f Control.Arrow.&&& id) in triplah
03:42:25 <lambdabot> forall a c. (Ord c) => (a -> c) -> [a] -> c
03:42:45 <ski> @type let triplah f = fst . head . Data.List.sort  . map (f Control.Arrow.&&& id) in triplah
03:42:47 <lambdabot> forall a c. (Ord (c, a)) => (a -> c) -> [a] -> c
03:42:57 <xerox> ...chasing for efficiency?
03:42:59 <ski> xerox : isn't the former better ?
03:43:13 <ski> (no, for generality .. not having to assume 'Ord a')
03:43:25 <xerox> Hmm.
03:43:33 <xerox> Ord (c,a) doesn't imply Ord a, I think.
03:43:43 <ski> it does
03:44:00 <ski> > ('a',id) < ('b',id)
03:44:01 <lambdabot>  add an instance declaration for (Ord (a -> a))
03:44:01 <lambdabot>   In the definition of `xxxx': xxxx = ('a', id) < ('b', id)
03:44:01 <lambdabot>   In the definition of `v':
03:44:09 <ski> @type ('a',id) < ('b',id)
03:44:10 <lambdabot>   No instance for (Ord (a -> a))
03:44:10 <lambdabot>   arising from use of `<' at <interactive>:1:9
03:44:17 <xerox> Hmpf.
03:44:23 <xerox> Doesn't make sense, does it?
03:44:26 <ski> Ord (a,b)  implies  (Ord a,Ord b)
03:44:32 <ski> sure it does
03:44:35 <xerox> Why?
03:44:51 <ski> pairs are compares by comparing respective parts
03:45:06 <xerox> So before it wasn't ignoring the latter part, hmm, okay!
03:45:45 <ski> so, if we can compare pairs of type '(a,b)', then surely that implies we can already compare values of type 'a' as well as of type 'b' (otherwise we couldn't compare pairs of type '(a,b)' in the first place)
03:45:50 <ski> right
03:46:02 <xerox> I know what 'implies' mean :-P
03:46:15 * ski smiles
03:46:23 * ski goes to fetch laundry
03:46:27 <xerox> Have fun :-)
03:48:03 <triplah> lol
03:48:05 <triplah> hmm
03:49:18 <triplah> oh
03:49:24 <triplah> actually my one does work
03:50:39 <triplah> > _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) =     if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy length ["fg","trre"] []
03:50:39 <lambdabot>  parse error on input `='
03:50:44 <triplah> > let _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) =     if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy length ["fg","trre"] []
03:50:45 <lambdabot> ["fg"]
03:51:20 <triplah> > let _minimaBy f [] l = l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) =     if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy length [ "moose", "yak", "cow", "llama" ] []
03:51:22 <lambdabot> ["cow","yak"]
03:51:39 <xerox> Boom boom-cha.
03:51:55 <triplah> i hope for the sake of my assignment that the order isnt important :)
03:52:39 <xerox> I still don't get it, but hey.
03:53:17 <triplah> well my function needs to be called with this specific call  > minimaBy length [ "moose", "yak", "cow", "llama" ]
03:54:20 <triplah> @type reverse
03:54:21 <lambdabot> forall a. [a] -> [a]
03:55:35 <triplah> > let _minimaBy f [] l = reverse l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) =     if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy length ["fg","trre"] []
03:55:36 <lambdabot> ["fg"]
03:55:56 <triplah> > let _minimaBy f [] l = reverse l;_minimaBy f (x:xs) [] = _minimaBy f xs [x];_minimaBy f (x:xs) (v:vs) =     if (f x) == (f v) then (_minimaBy f xs (x:v:vs)) else if (f x) < (f v) then (_minimaBy f xs [x]) else _minimaBy f xs (v:vs) in _minimaBy length[ "moose", "yak", "cow", "llama" ] []
03:55:58 <lambdabot> ["yak","cow"]
03:56:14 <triplah> dammit this function is too big, no more in channel evals
03:56:16 <triplah> :)
03:59:01 <shapr> You can use private messages.
03:59:14 <triplah> shapr: with lambdabot ?
03:59:37 <xerox> Indeed.
04:00:02 <xerox> Or even with shapr, he's known to evaluate what people tell him.
04:00:16 <triplah> haha
04:00:36 <triplah> shapr> \x -> x
04:00:40 <triplah> awww :)
04:01:12 <sieni> shapr: [1..]
04:01:19 <triplah> aha
04:05:12 <shapr> id!
04:05:27 <shapr> triplah: \x -> x May I see your id please?
04:05:33 * shapr arrests triplah
04:05:36 <triplah> haha
04:05:39 * triplah ducks for cover
04:05:51 * shapr grins
04:06:15 <shapr> hiya maitscha, how's code?
04:07:33 <maitscha> shapr: fine, thx.
04:07:55 * shapr boings cheerfully
04:08:15 <maitscha> i have a litle problem. i have defined a recursiv data type, called Tree. Now i need a function for showing this datatype.
04:08:19 <basti_> what can i do to prevent existentially quantified typvars from "escaping" in runST contructs?
04:08:42 <xerox> maitscha: you can actually write it down, or try appending a 'deriving (Show)' clause to the datatype definition.
04:08:54 <basti_> I have two functions
04:09:12 <basti_> one runs, but only in (), not after $, the other doesn't run at all
04:09:30 <shapr> maitscha: http://www.ScannedInAvian.org/~shae/TreeTraverseDemo.hs ?
04:09:49 <basti_> mmm
04:10:07 * sieni thinks that shapr evaluated the infinite sequence pretty quickly
04:10:34 <xerox> He's just lazy.
04:10:38 <shapr> sieni: Nah, I'm lazy, I saved it as a thunk.
04:10:40 <shapr> doh
04:10:42 <xerox> Dang.
04:10:57 <shapr> xerox: Have you heard the expression 'great minds think alike'?
04:11:23 * xerox looks around for other people
04:11:28 <xerox> "Do you mean, me?"
04:11:57 <shapr> Stereo smartaleck comments, yeah.
04:12:27 * xerox hugs shapr and runs away to eat lunch
04:12:41 <shapr> :-)
04:12:53 <shapr> I wonder why Yahoo persists in crawling my website several times a day.
04:13:22 <shapr> I banned microsoft search once it went over ten full crawls a day.
04:13:43 <shapr> Anyway, has anyone used the Data.Traversable stuff?
04:13:45 <astrolabe> Why is Leaf :: a -> Tree a?
04:13:51 <ski> basti_ : more context ..
04:14:17 <shapr> astrolabe: (Leaf (1 :: Int) :: Tree Int
04:14:24 <shapr> er, I missed a paren, but you get the idea?
04:14:27 <ski> astrolabe : because it takes an element of type 'a', and packages up that in a tree of type 'Tree a' just containing that element
04:14:41 <astrolabe> Oh cool
04:14:43 <astrolabe> thanks
04:14:53 <shapr> GADTs make constructor types explicit.
04:15:41 <shapr> Oh hey, is there a way to automatically derive a zipper for a datatype?
04:15:51 <astrolabe> Your show function is slow for large trees :)
04:16:25 <shapr> astrolabe: I should be using ShowS
04:16:31 <astrolabe> shapr: right
04:16:46 <shapr> But it was a ten minute hack for a post to LtU, so...
04:16:52 <astrolabe> I seem to be performance obsessed.
04:17:02 <shapr> I'm okay with that. Want to fix it? :-)
04:17:13 <shapr> I never got around to learning how to use ShowS, do you know how it works?
04:17:34 <maitscha> ok. with deriving (Show) it works well.
04:17:41 <astrolabe> It is well described in 'The Haskell School of Expression'
04:18:12 <maitscha> I am using "The Craft of Functional Programming"
04:18:16 <astrolabe> But for an example, your definition is easier to understand
04:18:41 <shapr> maitscha: Good book
04:18:55 <maitscha> astrolabe: from where are you?
04:19:03 <astrolabe> maitscha: Unless you have big trees, and little time,  deriving show is fine
04:19:18 <ski> (shapr : where's Data.Traversable ?)
04:19:38 <shapr> ski: http://www.soi.city.ac.uk/~ross/traversals/
04:19:53 <shapr> @seen TheHunter
04:19:54 <lambdabot> I saw TheHunter leaving #haskell-overflow, #haskell-blah and #haskell 5
04:19:54 <lambdabot> hours, 15 minutes and 35 seconds ago.
04:20:12 <astrolabe> maitscha: http://www.haskell.org/hawiki/HaskellUserLocations
04:20:24 <shapr> maitscha: Yeah, add yourself!
04:20:36 <astrolabe> is there an @where for that page.  '@where where' perhaps :)
04:20:39 <shapr> @map
04:20:40 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:21:06 <ski> @map reverse [[42]]
04:21:07 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:21:36 <maitscha> cooool
04:22:07 <astrolabe> Europe need enlarging I think.
04:22:37 <shapr> I'm the northernmost Haskeller! w00!
04:22:58 <shapr> And Pseudonym is the southernmost, neat.
04:23:27 * ski wonders who's the haskeller at highest altitude
04:23:43 <triplah> i'm definatly the haskeller of least skill :)
04:24:01 * sieni has pretty bad haskell skills as well
04:24:03 <owb13> I can contest you on that one
04:24:07 <shapr> oh me me!
04:24:21 <triplah> heh :)
04:24:37 <astrolabe> Oh yeah, we all beleive that.
04:24:48 <shapr> Anyway, as long as you're having fun, that's what matters.
04:25:07 <triplah> i hate my assignment
04:25:13 <triplah> but i know i'l learn heaps by doing it
04:25:14 <triplah> :P
04:25:21 <shapr> What's your assignment?
04:25:32 <maitscha> i have another question: I have a list of integers and have to make a binary tree from it. I have written a function called search, which searches a Leaf where to insert the next Leaf and a function insert, which inserts the new Leaf on the found location. Now I have to create the whole tree. How should i make this?
04:25:43 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html
04:26:12 <ski> maitscha : loop through the list, inserting each element into the tree, starting with the empty tree ?
04:26:20 <triplah> i'm doing part 5 now :)
04:26:46 <astrolabe> maitscha: Suppose you know how to make the tree for the tail of the list, and work out how to do the whole list from that.
04:26:52 <shapr> triplah: Do you have Manuel Chakravarty as a teacher?
04:27:05 <triplah> shapr: nope, i dont know anyone by that name
04:27:11 <triplah> or is that a trick question? :P
04:27:17 <shapr> Nope, not a trick question.
04:27:32 <shapr> I know he teaches Haskell to several hundred students a year at unsw.
04:27:40 <triplah> ahh
04:27:41 <ulfdoz> maitscha: foldl insert EmptyTree int_list
04:27:56 <triplah> thats not the aussie guy who is in here too?
04:27:57 <shapr> I wonder if I ever ask trick questions....
04:27:58 <triplah> dan something?
04:28:12 <ski> (triplah : interesting .. iirc i did such an assignment in an algo course in haskell, using (immutable) arrays for the dynamic programming)
04:28:22 <shapr> There are lots of aussies here in #haskell, so ...
04:28:32 <triplah> ski: yeah we are using lists for the dunamic stuff
04:28:33 <ski> (i.e. i chose haskell to code it ..)
04:28:38 <triplah> ahh cool
04:29:06 <triplah> shapr: this subject is a general programming subject. we've done scheme, prolog and haskell
04:29:09 <maitscha> hmmm.m... never used the foldl function...
04:29:22 <ski> triplah : are you doing the dynamic programming from bottom-up ?
04:29:40 <triplah> ski: sorry I dont follow
04:29:40 <shapr> triplah: Do you get a dataflow language as well?
04:29:50 <triplah> shapr: like?
04:29:54 <ulfdoz> maitscha: You should lern to love it and also its derivates.
04:30:06 <shapr> Esterel, Synchrone?
04:30:18 <triplah> ahh no, whats the principle behind them?
04:30:24 * ski gotta look at those langs, soon
04:31:04 <triplah> my lectuer mentioned esterel once
04:31:30 <shapr> Lustre is another.
04:31:41 <araujo> userError throws an exception right?
04:31:48 <triplah> so wikipedia tells me :)
04:32:13 <shapr> Oh, what wikipedia page are you using?
04:32:14 <ulfdoz> araujo: it should throw the user? :)
04:32:31 <shapr> I know what dataflow languages do, but I'm not sure how to describe it.
04:32:32 <triplah> http://en.wikipedia.org/wiki/Esterel
04:32:41 <triplah> there is no page for data flow languages :(
04:32:45 * araujo wonders what ulfdoz means
04:32:57 <shapr> I guess I'd say, think of a powerful language that works like a spreadsheet.
04:33:06 <araujo> ulfdoz, it should be thrown by the user you mean?
04:33:19 <triplah> shapr: that sounds like logic programming
04:33:33 <triplah> http://en.wikipedia.org/wiki/Synchronous_programming_language
04:33:38 <shapr> Cell updates in a spreadsheet trigger updates for everything that depends on them.
04:33:45 <triplah> ahhh
04:33:58 * triplah 's mind boggles
04:34:27 <shapr> Dataflow languages are usually used for hardware simulation, but they're not limited to that, much like Haskell is not limited to compilers.
04:34:52 <triplah> i had no idea that was considered haskell's primary use
04:34:52 <shapr> triplah: Oh if you want to see other cool language viewpoints, I'd suggest Joy, and probably Self as well.
04:35:00 <astrolabe> http://en.wikipedia.org/wiki/Dataflow_language
04:35:14 <triplah> i always saw haskell as a great way to do programming more cloely aligned with maths
04:35:18 <triplah> closely*
04:35:19 <shapr> Some people consider Haskell an academic toy for building compilers.
04:35:30 <shapr> triplah: I agree with you, but I have heard differing opinions.
04:35:43 <zacch> hi shapr!
04:35:48 <shapr> astrolabe: aha, thanks!
04:35:55 <shapr> hey zacch, what's up?
04:35:57 * triplah reads astrolabe's link
04:36:03 <shapr> zacch: Everything natural? :-)
04:36:13 <zacch> I've a question about the relation between Haskell and typed LC:
04:36:48 <shapr> triplah: Check out my approximately equal function in Joy: DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
04:36:51 <zacch> typed LC is strongly normalizing (in contrast to untyped LC), but there are Haskell programs that don't terminate, although they are properly typed
04:37:00 <zacch> where does the analogy break?
04:37:29 <triplah> :O
04:37:37 <shapr> Strongly normalizing necessitates termination. For that you may want to look at Epigram.
04:38:15 <ski> haskell has general recursion
04:38:19 <shapr> I've never compared Haskell and typed LC, I don't know the differences. If you find out, I'd like to read about it.
04:38:40 <zacch> ski: yes, what exactly is it that typed LC lacks? that some combinators cannot be typed?
04:39:02 <ski> typed LC with a fixpoint-operator is not strongly normalizing, either
04:39:04 <shapr> triplah: In Joy, the space means the same thing as function composition in Haskell. The dot in Joy is the 'execute' command.
04:39:17 <shapr> zacch: Did you see the strongly normalizing post on LtU?
04:39:35 <zacch> ski: can the fixpoint-operater be typed? and second:
04:39:50 <ski> zacch : sure
04:39:59 <shapr> triplah: So Joy is like some sort of lovechild of Forth and Haskell.
04:40:02 <ski> zacch : fix :: (a -> a) -> a
04:40:14 <triplah> shapr: yeah i was gonna say it looks forthish
04:40:36 <zacch> ski: a yes, and is that all I need to add to LC to obtain turing completeness?
04:40:44 <ski> forth and joy are concatenative programming languages (as opposed to applicative, like haskell)
04:40:54 <zacch> shapr: no, do you have a link?
04:41:09 <ski> zacch : well, you need to handle it in your semantics, too, of course .. otherwise, yes
04:42:28 <shapr> zacch: http://lambda-the-ultimate.org/node/view/1120
04:43:14 <maitscha> hmmmm... the problem is, when I make a insert, e.a  insert (SNode 2 SNil (SLeaf 3)) 1, I get "Leaf 1" as result.
04:43:39 <ski> then you have buggy 'insert', i think
04:44:11 <zacch> shapr: thanks a lot!
04:44:36 <maitscha> but how can i insert it without losing my tree?
04:45:05 <maitscha> http://rafb.net/paste/results/U8yKUm89.html
04:45:08 <zacch> shapr: do you know "Maude"?
04:45:25 <zacch> shapr: I think it also goes in that direction in that it tries to orient rewrite rules
04:46:18 <shapr> I've heard of Maude, I haven't read anything about it though.
04:46:54 <triplah> > let sieve (p:lis) = p : sieve [ n | n <- lis, mod n p /= 0 ] in sieve [2..]
04:46:55 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
04:46:55 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
04:46:55 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
04:46:55 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
04:46:55 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
04:46:57 <lambdabot> [24 @more lines]
04:47:07 <triplah> man i love haskell
04:47:20 <chris2> maude is an impressive thing
04:47:26 <triplah> i wonder what prime would kill it
04:47:40 <triplah> ie, how far it'd get to evulating prime numbers to break encryption :P
04:47:58 <astrolabe> I have an idea to combine a functional programming language with an on-the-fly -reprogramable FPGA to get massive parallelism.
04:48:55 <astrolabe> let sieve (p:lis) = p : sieve [ n | n <- lis, mod n p /= 0 ] in sieve !! 1000
04:49:13 <astrolabe> > let sieve (p:lis) = p : sieve [ n | n <- lis, mod n p /= 0 ] in sieve !! 1000
04:49:14 <lambdabot>   Expecting a function type, but found `[a]'
04:49:14 <lambdabot>   Expected type: [a]
04:49:14 <lambdabot>   Inferred type: [a1] -> [a1]
04:49:14 <shapr> astrolabe: I've been thinking about that too. I've wanted to do that for years!
04:49:14 <ski> maitscha : your third clause for 'insert' is wrong
04:49:35 <astrolabe> shapr:  I should have known!  :)
04:49:37 <ski> > let sieve (p:lis) = p : sieve [ n | n <- lis, mod n p /= 0 ] in sieve [2..] !! 1000
04:49:39 <lambdabot> 7927
04:49:56 <ski> maitscha : see the problem there ?
04:49:59 <astrolabe> thanks ski
04:50:03 <shapr> astrolabe: The problem I had is that FPGA vendors only want EDIF inputs, they don't want to open up their specifications. I swapped some emails with Satnam Singh (one of the authors of Lava) long ago.
04:50:06 <triplah> > let sieve (p:lis) = p : sieve [ n | n <- lis, mod n p /= 0 ] in sieve [2..] !! 30000
04:50:11 <lambdabot> Terminated
04:50:15 <triplah> ahh :)
04:50:26 <ski> @help @eval
04:50:27 <lambdabot>  @help <command> - ask for help for <command>
04:50:29 <ski> @help eval
04:50:30 <lambdabot>  @eval <expr>
04:50:30 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
04:50:40 <triplah> ahh ok
04:50:58 <triplah> 98389
04:51:12 <maitscha> ski: what is wrong with it?
04:51:27 <JKnecht> Maudey is Haskell based on Rewrite logic instead of Hindley-Milner?
04:51:55 <triplah> is there a way to time the execution of a haskell function?
04:51:57 <chris2> JKnecht: that's an oversimplification, i think
04:52:09 <triplah> i could compile my function to C and run it i suppose
04:52:13 <JKnecht> no it's a question.
04:52:16 <astrolabe> shapr:  Maybe if you're clever, you would only need to programme the array once, analougous to a universal turing machine?
04:52:21 <JKnecht> thanks for the answerQ
04:52:29 <JKnecht> s/Q/!/
04:52:38 <chris2> JKnecht: i think maude was more made for model checking than for general programming
04:52:40 <shapr> astrolabe: I wrote a recent blog post comparing Google Maps and Xilinx as opposite ends of the 'innovation encouraging' scale.
04:52:54 <shapr> astrolabe: I want the array to reprogram itself.
04:53:16 <astrolabe> shapr:  baby steps!
04:53:38 <int-e> > let sieve (p:lis) = let (hd, tl) = span (<p*p) lis in p : hd ++ sieve [ n | n <- tl, mod n p /= 0 ] in sieve [2..] !! 30000
04:53:39 <lambdabot> 77857
04:54:04 <triplah> er?
04:54:19 <astrolabe> @type span
04:54:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:54:22 <int-e> hmm.
04:54:36 <int-e> not quite.
04:54:59 <triplah> well i checked it into ghci
04:55:01 <shapr> I was thinking about an FPGA processor design that took up less than half the gates, and included instrumentation/profiling and a genetic algorithm. That way you have two CPU 'instances' during normal operation, and during idle time you have space to find a more efficient CPU design.
04:55:08 <triplah> my machine is working away at the 30000th prime
04:55:48 <int-e> for some reason, 9 is in the result list.
04:56:09 <astrolabe> heh: you've found a new prime!
04:56:12 <int-e> ah!
04:56:24 <triplah> haha
04:56:57 <int-e> ok, that was stupid ... I still need to filter by those primes ... so I need a two argument function
04:58:12 <astrolabe> Isn't there a formula for the nth prime?
04:58:48 <triplah> um
04:59:01 <JKnecht> we're waiting ...
04:59:03 <triplah> i was under the impression that it was currently mathematically impossible
04:59:25 <int-e> let isprime p = all [p `mod` q /= 0 | q <- takeWhile (\q -> q*q<=p) primes]; primes = 2:filter isprime [3,5..] in primes !! 30000
04:59:28 <int-e> > let isprime p = all [p `mod` q /= 0 | q <- takeWhile (\q -> q*q<=p) primes]; primes = 2:filter isprime [3,5..] in primes !! 30000
04:59:28 <lambdabot> Couldn't match `a -> Bool' against `[a1]'
04:59:37 <int-e> > let isprime p = and [p `mod` q /= 0 | q <- takeWhile (\q -> q*q<=p) primes]; primes = 2:filter isprime [3,5..] in primes !! 30000
04:59:40 <int-e> stupid me :/
04:59:42 <lambdabot> Terminated
04:59:55 <maitscha> ski: ok. found the error
04:59:57 <JKnecht> but you could make inferences based on the current hardware support to get max couldn't you?
05:00:01 <astrolabe> triplah: what does 'currently mathematically impossible' mean?
05:00:08 <JKnecht> i.e. max computable.
05:00:14 <shapr> I'm thinking, CPU@Home/distributed.cpu, where CPUs use their idle time to find a better design for themselves, and any better designs are distributed to all the clients. If you had a few million of those, I suspect better designs would appear.
05:00:20 <JKnecht> or rather searchable.
05:00:21 <triplah> astrolabe: im not aware of a formula to calculate primt numbers
05:00:49 <triplah> prime*
05:01:11 <astrolabe> shapr:  Sounds good.  Maybe even for fixed design cpus
05:01:42 <chris2> triplah: well, you can make a formula that always returns a different prime number. but they will be rather sparse
05:02:10 <triplah> chris2: yep, but thats generate and test until you find the nth one
05:02:25 <shapr> astrolabe: But it's not really advantageous until someone sells an FPGA with fully open specifications. Xilinx seems to try hard to kill off FPGA innovation outside of their company.
05:02:31 <chris2> triplah: nope. eg. f(x) = x!+1
05:02:52 <chris2> you cant directly compute the nth one, yeah
05:03:13 <triplah> ahh, you could do it "smarter"
05:03:17 <shapr> astrolabe: Have you read Dead Reckoning by Doerfler?
05:03:18 <astrolabe> chris2: thats not a prime
05:03:28 <triplah> my pc still hasnt found the 30,000th
05:03:34 <chris2> astrolabe: why not?
05:03:48 <triplah> thats odd isnt it?
05:03:51 <zacch> primes is in P, just generate a number and test whether it's prime
05:03:52 <triplah> but not prime?
05:04:05 <astrolabe> 4!+1
05:04:26 <chris2> hrm
05:04:39 <zacch> with simple probabilistic tests, you can elimanate most number right away and be faster than sieving
05:04:57 <shapr> Yeah, didn't Fermat come up with a probabilistic prime test?
05:05:03 <astrolabe> Apparently the is an X such that floor X^(3^n) is prime
05:05:44 <chris2> astrolabe: i tried to reverse euklid's argument for infinite primes...
05:05:47 <zacch> shapr: don't think so, it's a relatively recent result (2002?), but maybe it was known to Fermat (don't think so though, because there are letters where he erred about primality)
05:05:58 <astrolabe> chris2: I could tell :)
05:06:14 <shapr> I should really learn some math...
05:06:17 <astrolabe> his argument is more subtle though
05:06:21 <chris2> but he only multiplies the primes up to n, right?
05:06:56 <astrolabe> chris: he only shows there is some prime above n, he doesn't find it, just a multiple of it.
05:07:26 <chris2> yeah
05:07:40 <astrolabe> shapr:  I think going to university and being made to things you find tedious would be really good for you :)
05:07:52 <triplah> haha
05:08:42 <int-e> hmm. I'd say the n-th prime can be found in O(n^(1/2+epsilon)) time using a binary search build on top of an efficient prime counting function implementation (http://mathworld.wolfram.com/PrimeCountingFunction.html mentions some methods and their complexity)
05:08:53 <tuomov> university wasn't/isn't like that... industry work was
05:09:18 <triplah> ok im killing this seive
05:09:23 <triplah> i need my ghci back :)
05:10:32 <int-e> triplah: my last version finished in 17 seconds here - of course that's still very, very slow.
05:10:44 <tuomov> in uni you're suggested to do tedious but rewarding stuff... at work you're told to do (or else..) tedious and unrewarding work
05:10:53 <astrolabe> If you are free to study on your own, you tend to just choose what looks coolest.  At university, you are made to learn the basics first.
05:11:08 <triplah> int-e: heh, nicer than my seive
05:11:23 <tuomov> unless you work for yourself anyway
05:11:27 <astrolabe> tuomov: I agree with your characterisation of work :)
05:11:49 <astrolabe> Although, there are better and worse jobs of course.
05:12:42 <triplah> whats where using lambda again?
05:12:54 <triplah> x where y   is?  \x -> y ?
05:13:49 <shapr> astrolabe: Probably so
05:15:47 <astrolabe> shapr: Did you read 1.1 of http://www.haskell.org/communities/11-2005/html/report.html ? I thought it might solve your server-cost problem.
05:16:16 <triplah> @type x where y
05:16:16 <lambdabot> parse error on input `where'
05:16:27 <triplah> @type x where x < y
05:16:28 <lambdabot> parse error on input `where'
05:16:57 <astrolabe> Although there exist explicit prime formulas (i.e., formulas which either generate primes for all values or else the nth prime as a function of n), they are contrived to such an extent that they are of little practical value.
05:17:03 <triplah> @type func x where x = x*x
05:17:04 <lambdabot> parse error on input `where'
05:17:09 <astrolabe> from http://mathworld.wolfram.com/PrimeNumber.html
05:17:26 <triplah> @type func x = y where y = x*x
05:17:26 <lambdabot> parse error on input `='
05:17:29 <triplah> argh :
05:17:31 <triplah> i give up
05:17:53 <triplah> astrolabe: hah, cool :)
05:18:04 <maitscha> with foldl I get an output of SNode 7 (SNode 2 (SLeaf 1) (SLeaf 6)) (SLeaf 12), but I would like to have the output in brackets.
05:18:45 <maitscha> ...means (SNode 7 (SNode 2 (SLeaf 1) (SLeaf 6)) (SLeaf 12)). any ideas?
05:19:29 <astrolabe> maitscha: I'm not sure having it in brackets means anything.  Why do you want it in brackets?
05:20:19 <maitscha> only for visibility
05:20:22 <ulfdoz> maitscha: Implement an instance Show Tree with a customized show-function.
05:20:29 <triplah> write your own show
05:20:33 <triplah> ack :)
05:20:43 <maitscha> ok.
05:21:02 <astrolabe> Ah it's a string.  I see now.
05:26:58 <maitscha> hmmm... I have derived the show function for the data type. Is is possible to something like overwrite the derived show-function?
05:27:20 <maitscha> i don't want to implement the whole show for the data type, but only to but the result in brackets.
05:27:53 <triplah> is space a keyword in haskell?
05:27:59 <ulfdoz> maitscha: Of course. instance Show Tree where show = <your_implementation> iirc.
05:28:15 <triplah> or a call for a methd that gives a list of one element [" "] ?
05:28:21 <triplah> or a call for a methd that gives a list of one element [""] ?
05:28:24 <triplah> or that even
05:28:53 <astrolabe> maitscha: Could you write a myShow using derived show?
05:29:46 <maitscha> astrolabe: yes
05:32:54 <triplah> http://www.it.bond.edu.au/inft313/053/assessment/a3.html <-- anyone know what the space variable in task 5 would mean?
05:33:00 <triplah> "space"
05:34:56 <basti_> triplah: it seems like some kind of weighting factor to me
05:35:11 <triplah> m mm and sp are all integers
05:35:28 <triplah> ys and xs are a list of chars (strings)
05:35:28 <basti_> yes
05:35:39 <basti_> and sp is just used in the recursion end
05:36:07 <triplah> yep, but i cant get the function to compile because it thinks that "space" is out of scope
05:36:12 <basti_> ah
05:36:19 <int-e> triplah: apparently, space = '-' ... judging by the definition of costChar
05:36:35 <triplah> int-e: ahh ok, i'll give it a whirl
05:37:10 <triplah> ahh
05:37:24 <triplah> replacing space with '_' got it compiling at least
05:37:25 <triplah> :)
05:37:28 <triplah> er
05:37:29 <triplah> '-'
05:37:38 <int-e> triplah: possibly someone decided mid-way that it'd be a good idea to make the character that represents space configurable
05:38:16 <triplah> int-e: yep :)
05:38:19 * triplah shakes fist
05:41:22 <maitscha> triplah: hmmm.... what was your idea with the method that gives a list of one elment?
05:41:56 <triplah> maitscha: sorry, what did i say?
05:42:08 <triplah> ahh i see
05:42:24 <araujo> Programms are like a painting , you never know if it is finished.
05:42:40 <triplah> pretty much what int-e was saying, but i have the wrong character. and i was passing it as a string
05:42:51 <triplah> had*
05:43:09 <xerox> araujo: I wonder if painters get bored of some paintings sometime, and don't finish it, then :-)
05:43:16 <xerox> s/it/them/1
05:43:24 <triplah> maitscha: i was also talking about my problem at hand, not yours :P
05:43:34 <triplah> xerox: all the time iirc :P
05:43:37 <maitscha> triplah: ok
05:43:47 <araujo> xerox, they definetly do. 
05:44:12 <araujo> xerox, they also sometimes are afraid of continuing painting , and they leave it as is
05:44:29 <xerox> No RCS for paints, doodle doodle.
05:44:37 <triplah> bah, thats also not a finished program
05:44:48 <araujo> The more you paint, the more likely you create/find bugs :-]
05:46:59 * araujo believes the closer analogy to a hacker is a painter
05:47:20 * xerox points at araujo ...
05:47:50 <araujo> :-]
05:48:23 <ski> (maitscha : sorry, was away)
05:48:27 <ski> (triplah : you *are* aware of a formula to calculate prime numbers .. you wrote it yourself, above)
05:49:56 <araujo> This winter is killing me
05:50:01 <araujo> I should gets ome hot tea with honey
05:50:52 <triplah> isp capped me :(
05:50:55 <triplah> went over my 15gb for the month
05:51:25 <astrolabe> giga bytes or giga bits?
05:52:37 <basti_> isnt there an instance Enum a => Enum (a,a) somwhere?
05:55:27 <triplah> whats the syntax for or?  || ?
05:55:36 <xerox> @type or
05:55:37 <lambdabot> [Bool] -> Bool
05:55:37 <triplah> astrolabe: gigabytes :P
05:55:38 <xerox> @type (||)
05:55:39 <lambdabot> Bool -> Bool -> Bool
05:55:43 <xerox> Choose.
05:55:43 <triplah> tanks
05:55:58 * xerox calls the navy
05:56:04 <triplah> haha
05:56:10 <int-e> no. Enums don't have to be bounded. There's an instance (Ix a, Ix b) => Ix (a,b) though
05:56:14 <triplah> boo!
05:56:20 <triplah> too late to correct typos
05:56:41 <xerox> (...and add subjects)
05:56:43 <astrolabe> triplah: wow, that's a lot.  I get 1GB per month as standard.
05:57:10 <triplah> astrolabe: where are you from?
05:57:17 * ski wonders why he can't log in to LtU
05:57:21 <astrolabe> triplah UK.
05:57:30 <triplah> astrolabe: compared to the states and scandinavian countries, 15gb is terrible
05:59:12 <ski> (basti_ : what was your prob with existential quantification ?)
05:59:50 <astrolabe> triplah: figures :(
06:00:26 <triplah> :\
06:00:27 <JKnecht> I get 500GB on this connection, but unlimited at home.
06:00:36 <triplah> what speed?
06:00:46 <triplah> 512 down 128 up for me :\
06:01:39 <astrolabe> hmmm I have a 2Mb connection, but I pay extra if I use more than a GB
06:02:07 <triplah> fwaor
06:02:15 <triplah> thats fast :)
06:02:17 <astrolabe> and that costs 15 a month, about $25 I reckon.
06:02:28 <triplah> more here
06:02:38 <triplah> closer to 35 - 40 i think
06:02:44 <JKnecht> last home bw test was 5MB+ up, .8 down. 
06:03:02 <triplah> cable?
06:03:12 <JKnecht> y
06:03:15 <triplah> ahh k
06:03:18 <triplah> adsl here :|
06:03:22 <astrolabe> ok we need a DNS attack on JKnecht :)
06:03:22 <maniacH> hi, how to make function split2 [1..10] ==> ([1,3,5,7,9],[2,4,6,8,10]) ?
06:04:10 <astrolabe> maniacH: Homework?
06:04:19 <maniacH> nope
06:04:27 <maniacH> this is test example question
06:04:40 <maniacH> and i want to know how to make it
06:05:11 <triplah> > let split2 ls = take (length ls)/2 ls in split2 [1..10]
06:05:12 <lambdabot>   add an instance declaration for (Fractional ([a1] -> [a1]),
06:05:12 <lambdabot>              Num ([a] -> [a1] -> [a1]))
06:05:12 <lambdabot>   In the definition of `xxxx':
06:05:21 * triplah guesses
06:05:28 <triplah> thats half of it sorta
06:06:00 <triplah> > let split2 ls = take (length ls) dev 2 ls in split2 [1..10]
06:06:01 <lambdabot>  Not in scope: `dev'
06:06:05 <triplah> bah
06:06:05 <maniacH> ok, thanks
06:06:09 <triplah> whats integer divide?
06:06:19 <triplah> @type divide
06:06:20 <lambdabot> Not in scope: `divide'
06:06:25 <triplah> @type div
06:06:27 <lambdabot> forall a. (Integral a) => a -> a -> a
06:06:32 <triplah> > let split2 ls = take (length ls) div 2 ls in split2 [1..10]
06:06:33 <lambdabot>   The function `take' is applied to four arguments,
06:06:33 <lambdabot>   but its type `Int -> [a] -> [a]' has only two
06:06:33 <lambdabot>   In the definition of `split2': split2 ls = take (length ls) div 2
06:06:33 <lambdabot> ls
06:06:45 <int-e> @hoogle (a->Bool) -> [a] -> [a] -> [a]
06:06:46 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
06:06:46 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
06:06:46 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
06:06:55 <xerox> > unzip $ (\xs -> xs >>= \x -> return (x-1,x+1)) [1..10]
06:06:56 <lambdabot> ([0,1,2,3,4,5,6,7,8,9],[2,3,4,5,6,7,8,9,10,11])
06:07:03 <xerox> Conquer.
06:07:38 <triplah> > let split2 ls = take ((length ls) div 2) ls in split2 [1..10]
06:07:38 <lambdabot>   The function `(length ls)' is applied to two arguments,
06:07:38 <lambdabot>   but its type `Int' has none
06:07:48 <triplah> argh!
06:07:50 <triplah> :)
06:07:51 <astrolabe> xerox: cool
06:08:15 <xerox> astrolabe: kinda.  Working to perfect it tough.
06:09:06 <triplah> > let split2 ls = take (div (length ls) 2) ls in split2 [1..10]
06:09:07 <lambdabot> [1,2,3,4,5]
06:09:10 <int-e> @hoogle [Either a b] -> ([a], [b])
06:09:11 <triplah> hmm
06:09:11 <lambdabot> No matches, try a more general search
06:09:16 <triplah> half of it :)
06:09:28 <int-e> @hoogle (a->Bool) -> [a] -> ([a], [a])
06:09:30 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
06:09:30 <lambdabot> Data.List.break :: (a -> Bool) -> [a] -> ([a], [a])
06:09:30 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
06:09:46 <triplah> @type drop
06:09:46 <lambdabot> forall a. Int -> [a] -> [a]
06:09:52 <int-e> > Data.list.partition even [1..10]
06:09:53 <lambdabot>  Not in scope: `Data.list'
06:10:01 <int-e> > partition even [1..10]
06:10:02 <lambdabot> ([2,4,6,8,10],[1,3,5,7,9])
06:10:06 <triplah> > drop 5 [1,2,3,4,5,6]
06:10:07 <lambdabot> [6]
06:10:38 <neologism> any AI expert here?
06:10:43 <triplah> int-e: impressive :P
06:10:54 <triplah> but not quite there
06:11:01 <int-e> > partition even [2,4..10]
06:11:02 <lambdabot> ([2,4,6,8,10],[])
06:12:05 <xerox> OK.
06:12:07 <triplah> > let split2 ls = (take (div (length ls) 2) ls in split2 [1..10]) : (drop 5 ls)
06:12:08 <lambdabot>  parse error on input `in'
06:12:25 <triplah> > let split2 ls = (take (div (length ls) 2) ls):drop 5 ls in split2 [1..10])
06:12:25 <lambdabot>  parse error on input `)'
06:12:37 <triplah> > let split2 ls = take (div (length ls) 2) ls:drop 5 ls in split2 [1..10])
06:12:38 <lambdabot>  parse error on input `)'
06:12:40 <triplah> man
06:12:41 <xerox> > let maniacH = (nub *** nub) . unzip . (\xs -> xs >>= \x -> return (((x `div` 2) * 2) + 1,(x `div` 2) * 2)) in maniacH [1..10]
06:12:42 <lambdabot> ([1,3,5,7,9,11],[0,2,4,6,8,10])
06:12:43 <triplah> what a newbie :)
06:13:05 <int-e> > (map snd *** map snd) $ partition (odd.fst) (zip [1..] [1..10])
06:13:06 <lambdabot> ([1,3,5,7,9],[2,4,6,8,10])
06:13:09 <xerox> (something unuseful in there, maybe)
06:13:20 <xerox> @karma+ int-e
06:13:21 <lambdabot> int-e's karma raised to 5.
06:13:23 <xerox> I'm loving it.
06:13:33 <int-e> @index nub
06:13:34 <lambdabot> Data.List
06:13:49 * xerox shakes int-e's hand
06:14:08 <xerox> @index partition
06:14:09 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
06:14:15 <xerox> @type Data.List.partition
06:14:17 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:14:31 <xerox> Woot.
06:15:29 <int-e> @pl foo l = (map snd *** map snd) $ partition (odd.fst) (zip [1..] l)
06:15:30 <lambdabot> foo = (map snd *** map snd) . partition (odd . fst) . zip [1..]
06:15:39 <xerox> > let foo = (map snd *** map snd) . partition (odd . fst) . zip [1..] in foo [1..10]
06:15:40 <lambdabot> ([1,3,5,7,9],[2,4,6,8,10])
06:15:50 <xerox> My job ;-)
06:16:14 <int-e> > let foo = (map snd *** map snd) . partition (odd . fst) . zip [1..] in foo [2..10]
06:16:15 <lambdabot> ([2,4,6,8,10],[3,5,7,9])
06:16:25 <astrolabe> @type ***
06:16:26 <lambdabot> parse error on input `***'
06:16:33 <int-e> @type (***)
06:16:34 <lambdabot> Not in scope: `***'
06:16:39 <xerox> @type (Control.Arrow.***)
06:16:40 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
06:16:40 <lambdabot> (Control.Arrow.Arrow a) =>
06:16:40 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
06:16:40 <int-e> @type (Data.Arrow.***)
06:16:41 <lambdabot> Couldn't find qualified module.
06:16:41 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:16:42 <lambdabot> \\)?
06:16:45 <int-e> argh.
06:16:52 <xerox> <blink>
06:17:42 <int-e> thanks lambdabot, no, I just messed up the module name.
06:18:07 <astrolabe> anyway, that function splits by  parity, not position, which is surely what is wanted.
06:18:15 <int-e> no it doesn't
06:18:35 <int-e> it splits by parity of an index that's temporarily added and then filtered out again
06:18:43 <astrolabe> oh, I'll look again.
06:18:56 <triplah> @type 888
06:18:57 <lambdabot> forall t. (Num t) => t
06:19:00 <triplah> @type ***
06:19:01 <lambdabot> parse error on input `***'
06:19:15 <triplah> :(
06:19:33 <int-e> > let foo = (map snd *** map snd) . partition fst . zip (cycle [True, False]) in foo [2..10]
06:19:34 <lambdabot> ([2,4,6,8,10],[3,5,7,9])
06:19:35 <arjanb> @type (Control.Arrow.***)
06:19:36 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
06:19:36 <lambdabot> (Control.Arrow.Arrow a) =>
06:19:36 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
06:19:47 <int-e> there, no parity checks anymore.
06:20:33 <triplah> argh, i didnt look at what they wanted
06:20:35 <astrolabe> > let foo = (map snd *** map snd) . partition fst . zip (cycle [True, False]) in foo "The quality of mercy is not strained"
06:20:36 <lambdabot> ("Teqaiyo ec sntsrie","h ult fmryi o tand")
06:20:45 <astrolabe> :)
06:20:59 <int-e> that's not very readable :)
06:21:20 <xerox> > partition (odd) [1..10]
06:21:21 <lambdabot> ([1,3,5,7,9],[2,4,6,8,10])
06:21:23 <xerox> uh.
06:22:14 <int-e> @pl 
06:22:14 <lambdabot> (line 1, column 1):
06:22:14 <lambdabot> unexpected end of input
06:22:14 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
06:22:14 <lambdabot> expression
06:22:25 <int-e> @pl \a b -> a:b:[]
06:22:26 <lambdabot> (. return) . (:)
06:22:43 <int-e> eek.
06:23:00 <xerox> @type \f g -> (. g) . f
06:23:01 <lambdabot> forall a b c a1. (a1 -> b -> c) -> (a -> b) -> a1 -> a -> c
06:23:12 <triplah> could yo0u do something like [x | x -> [1..] where mod x 2 ==0]
06:23:17 <triplah> and same again for y?
06:23:26 <triplah> er
06:23:31 <triplah> x <- [1..]
06:23:36 <int-e> > concatMap (\(a,b) -> [a,b]) $ uncurry zip ("Teqaiyo ec sntsrie","h ult fmryi o tand")
06:23:37 <lambdabot> "The quality of mercy is not strained"
06:23:51 <triplah> [1..(length ls)]
06:24:26 * int-e thinks
06:25:14 <xerox> What's bad about partition (odd) ?
06:25:36 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1..10]
06:25:36 <lambdabot> [[1,3,5,7,9],[2,4,6,8,10]]
06:25:36 <triplah> its too easy? :P
06:25:45 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1..11]
06:25:46 <xerox> My gosh.
06:25:46 <lambdabot> [[1,3,5,7,9,11],[2,4,6,8,10]]
06:26:09 <int-e> wow, it works for odd lengths, too.
06:26:11 <xerox> Somebody sedates int-e !
06:26:34 <triplah> lol
06:26:42 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) []
06:26:43 <lambdabot> Add a type signature
06:26:50 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [] :: [[Int]]
06:26:51 <lambdabot> []
06:26:58 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1] :: [[Int]]
06:26:59 <lambdabot> [[1]]
06:27:02 <int-e> > transpose $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1,2] :: [[Int]]
06:27:04 <lambdabot> [[1],[2]]
06:27:06 <xerox> Wow.
06:27:10 <int-e> so it has some disadvantages ;)
06:27:21 <xerox> Heh.
06:28:41 <triplah>  let split2 ls = [[x | x <- [1..(length ls), mod x 2 == 0],[y | y <- [1..(length ls), mod x 2 == 1]] in split2 [1..10]
06:28:45 <int-e> but the takeWhile, unfoldr part is a nifty way to split up lists into parts of equal length and a remainder.
06:28:57 <triplah> incomplete
06:29:37 <triplah> > let split2 ls = [[x | x <- [1..(length ls), mod x 2 == 0],[y | y <- [1..(length ls), mod y 2 == 1]] in split2 [1..10]
06:29:38 <lambdabot>  parse error on input `,'
06:29:43 <triplah> boo!
06:30:25 <triplah> > let split2 ls = [[x | x <- [1..(length ls)], mod x 2 == 0],[y | y <- [1..(length ls)], mod y 2 == 1]] in split2 [1..10]
06:30:26 <lambdabot> [[2,4,6,8,10],[1,3,5,7,9]]
06:30:30 <triplah> :D
06:30:43 <triplah> i wrote something that works
06:30:45 * triplah dances
06:30:52 <triplah> > let split2 ls = [[x | x <- [1..(length ls)], mod x 2 == 0],[y | y <- [1..(length ls)], mod y 2 == 1]] in split2 [1..15]
06:30:53 <xerox> Cool!
06:30:54 <lambdabot> [[2,4,6,8,10,12,14],[1,3,5,7,9,11,13,15]]
06:31:12 <dcoutts> hia xerox, how are things?
06:31:31 <xerox> dcoutts, howdy!  Quite sleepy.  Dark weather :-)
06:31:32 <dcoutts> Cale, btw, any luck with that c2hs issue?
06:31:59 <dcoutts> xerox, ah yes, winter is drawing in. People got trapped in snow in England yesterday!
06:32:18 <xerox> We got snow even here, the other day!
06:32:27 * dcoutts is hacking on Gtk2Hs TreeView stuff
06:32:39 * xerox si preparing to go to some friend's party
06:33:09 <dcoutts> to make it easy to define custom data models in Haskell and then connect them up to a TreeView/CellView/IconView etc
06:33:12 <int-e> > let foo ls = (\[a,b] -> (a,b)) $ map (map (flip (!!) ls)) [[1,3..length ls], [2,4..length ls]] in foo ['a'..'z']
06:33:12 <lambdabot> Couldn't match `[a]' against `Int'
06:33:31 <int-e> > let foo ls = (\[a,b] -> (a,b)) $ map (map (ls!!)) [[1,3..length ls], [2,4..length ls]] in foo ['a'..'z']
06:33:32 <lambdabot> Prelude.(!!): index too large
06:33:48 <int-e> > let foo ls = (\[a,b] -> (a,b)) $ map (map (ls!!)) [[0,2..length ls-1], [1,3..length ls-1]] in foo ['a'..'z']
06:33:49 <lambdabot> ("acegikmoqsuwy","bdfhjlnprtvxz")
06:33:58 <araujo> @karma+ dcoutts 
06:33:59 <lambdabot> dcoutts's karma raised to 7.
06:34:07 <dcoutts> :-)
06:34:21 <triplah> smart ass int-e :P
06:35:12 <int-e> well, that last one was an O(n^2) algorithm
06:35:33 <triplah> > let split2 ls = [[x | x <- [2,4..(length ls)]],[y | y <- [1,3..(length ls)]]] in split2 [1..15]
06:35:34 <int-e> I think that's a good place to stop.
06:35:34 <lambdabot> [[2,4,6,8,10,12,14],[1,3,5,7,9,11,13,15]]
06:35:43 <triplah> hah, cool :)
06:36:03 <triplah> is there a list of list comprehension patterms somewhere?
06:36:03 <int-e> triplah: uh. try that on another list ...
06:36:04 <jlouis> @hoogle partition
06:36:05 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
06:36:05 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
06:36:05 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
06:36:12 <jlouis> ;)
06:36:13 <triplah> i didnt know you could imply odd numbers with 1,2..
06:36:16 <triplah> er
06:36:20 <triplah> odd = 1,3..
06:36:49 <triplah> int-e: you mean a general list?
06:36:55 <astrolabe> I think maniacH would prefer an elementary solution though.
06:37:04 <triplah> int-e i'm totally noob, anything that works impresses me at the moment
06:37:16 <int-e> let split2 ls = [[x | x <- [2,4..(length ls)]],[y | y <- [1,3..(length ls)]]] in split2 "abcdef"
06:37:17 <triplah> ie, mine is an elementary solution :P
06:37:36 <int-e> will return [[2,4],[1,3,5]]
06:37:46 <triplah> yep
06:37:52 <jlouis> > Data.List.partition odd [1..15]
06:37:53 <lambdabot> ([1,3,5,7,9,11,13,15],[2,4,6,8,10,12,14])
06:38:42 <jlouis> redefine odd to your liking ;)
06:38:49 <triplah> :P
06:39:01 <int-e> triplah: it's all in the haskell report, see http://haskell.org/onlinereport/exps.html#arithmetic-sequences
06:39:11 <triplah> @type Data.List.partition
06:39:12 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:39:16 <triplah> int-e: thanks
06:39:32 <jlouis> and D.L.partition is O(n) IIRC
06:39:48 <int-e> triplah: I guess it's covered in some introductions, too, that are more accessible than the report.
06:39:49 <triplah> > Data.List.partition length ["asd"]
06:39:50 <lambdabot> Couldn't match `Bool' against `Int'
06:39:54 <triplah> ahh :)
06:39:56 <triplah> needs bool
06:40:13 <triplah> int-e: ok great
06:54:33 <tic> how come (fromIntegral anEpochTime) doesn't work?
06:56:51 <ski> let split2 ls = take (length ls `div` 2) ls : drop 5 ls in split2 [1..10]
06:56:56 <ski> > let split2 ls = take (length ls `div` 2) ls : drop 5 ls in split2 [1..10]
06:56:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:56:57 <lambdabot>   Expected type: [[a]]
06:56:57 <lambdabot>   Inferred type: [a]
06:57:21 <ski> > let split2 ls = take (length ls `div` 2) ls ++ drop 5 ls in split2 [1..10]
06:57:23 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
06:57:31 <ski> > let split2 ls = take (length ls `div` 2) ls ++ drop 5 ls in split2 [1..20]
06:57:32 <lambdabot> [1,2,3,4,5,6,7,8,9,10,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:01:50 <int-e> tic: what's anEpochTime?
07:02:16 <tic> int-e, EpochTime. I want want to convert it to ClockTime. It's from an external library. But it seems it wasn't used, so I just commented it out.
07:05:11 <int-e> tic: try fromReal
07:05:25 <astrolabe> I guess you need to make EpochTime and instance of Integral
07:05:33 <int-e> @index fromReal
07:05:34 <lambdabot> bzzt
07:05:37 <int-e> hmm.
07:05:39 * int-e thinks
07:05:48 <astrolabe> I mean 'anEpochTime' an instance
07:07:09 <int-e> toRational
07:08:01 <benny> @where haskell-plugins
07:08:01 <lambdabot> I know nothing about haskell-plugins.
07:08:08 <benny> @where hs-plugins
07:08:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:11:42 <int-e> tic: EpochTime is no Integral instance, only a Real instance.
07:12:43 <benny> @where gtk2hs
07:12:43 <lambdabot> http://haskell.org/gtk2hs/
07:13:27 <dcoutts> benny, learning GUIs?
07:14:45 <benny> dcoutts: not sure
07:15:00 * dcoutts reccomends Gtk2Hs of course
07:15:09 <benny> is gtk2hs ok if i only have gtk 2.4.0?
07:15:12 <dcoutts> yep
07:15:13 <jlouis> dons: awake?
07:15:23 <dcoutts> it even works with Gtk+ 2.0
07:15:27 <benny> ok cool
07:15:45 <dcoutts> you get the features of whichever version of Gtk+ you've got installed
07:16:09 <dcoutts> so with Gtk+ 2.8 you get the cool new cairo vector graphics stuff
07:16:23 <benny> nice but i don't want cairo since this is an old computer
07:16:27 <dcoutts> right
07:16:58 <dcoutts> the older Gdk graphics api is a tad harder to use but it is certainly fast.
07:18:41 * dcoutts has been running a class this term where studetns build simulators for the ICFP '04 ants task.
07:19:11 <dcoutts> They have to use Java. None of them can make their visualisers run nearly as fast as my one which used Haskell and Gtk2Hs.
07:19:28 <benny> dcoutts: you are a staff member of an academic institute?
07:19:29 <int-e> tic:  toClockTime :: EpochTime -> ClockTime; toClockTime t = let t' = toRational t; secs = truncate t'; pics = truncate $ (t' - fromIntegral secs)*10^12 in TOD secs pics
07:19:51 <ValarQ> dcoutts: they have to use java?
07:19:54 <dcoutts> benny, I'm a teaching assistant and a PhD student. So I help teach undergraduate students.
07:20:16 <dcoutts> ValarQ, it's an object oriented design course, with AspectJ.
07:20:26 <ValarQ> dcoutts: i see
07:21:06 <dcoutts> Gtk2Hs is so much easier to use than Swing, which is what we use in some of our OOP practicals.
07:22:14 <dcoutts> Java imposes so much syntactic overhead on what is just a simple closure in Haskell
07:22:39 <dcoutts> onClicked button $ do ...
07:23:14 <benny> dcoutts: what do you think of fudgets or fruit?
07:23:45 <dcoutts> benny, people don't seem to use fudgets much. I hear fruit is quite nice.
07:24:13 <dcoutts> We really need one of these high level apis implemented on top of a proper GUI lib like Gtk2Hs or wxHaskell.
07:24:35 <dcoutts> I am a bit sucpicious of some of the arrow based gui libs however
07:24:40 <benny> why?
07:24:49 <dcoutts> they don't seem very effecient
07:24:54 <Frederick> folks can anyone please give me an idea about why the hell this function fails in one specific case? http://paste.lisp.org/display/13988
07:24:59 <dcoutts> the have to traverse large graphs on each event
07:25:05 <int-e> dcoutts: oh, that's just *slightly* shorter than button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { ... } } );
07:25:22 <dcoutts> int-e, heh, yeah, exactly.
07:26:02 <int-e> Java would be a lot worse without those anonymous inner classes.
07:26:04 <benny> dcoutts: but it can be optimized
07:26:21 <dcoutts> benny, actaully it's not clear that it can.
07:26:32 <dcoutts> benny, it's still a difficult research topic.
07:26:45 <dcoutts> int-e, yes.
07:27:30 <dcoutts> int-e, just count how many concepts are used in the Java version compared to the Haskell version.
07:29:26 <araujo> wow!, compiled at once!
07:29:30 <dcoutts> int-e, a method that connects a listner object, an action interface, an instance of an anonymous class that implemnts that interface, a method of the anonymous class called something matching from the action interface, the body of which finally does the thing we want to do in response to the button being pressed.
07:29:33 * araujo makes the hulolambda dance
07:30:36 <dcoutts> int-e, syntactically and conceptually I'd say it's at least twice as complicated.
07:30:48 * dcoutts hugs Haskell
07:46:34 <xeiro> good day all
07:46:48 <ValarQ> g'day xeiro
07:47:58 <benny> good day sir
07:48:26 <xeiro> :)
07:48:51 <neologism> why expert systems examples are always written in prolog? :(
07:49:04 <xeiro> I need to know something....
07:51:06 <xeiro> http://rafb.net/paste/results/cguCqo40.html
07:51:20 <xeiro> I need to know how to set a global variable so to speak
07:52:26 <astrolabe> Does that code work?
07:53:10 <xeiro> lol ... I just wrote it ....
07:53:25 <xeiro> dont think so .. just want to know how to set a "global" variable ..
07:53:31 <astrolabe> haskell millitates against having 'variable' variables
07:53:47 <xeiro> so I can change a variable from anywhere
07:53:51 <xeiro> so that wont work then?
07:53:52 <astrolabe> but somevariable = "Hello" should work.
07:54:01 <astrolabe> But try not to change them.
07:54:23 <xeiro> lets see
07:54:38 <astrolabe> that code might work, but if it does, you are simply hiding the global value of somevariable
07:54:45 <xeiro> nope ... that gives syntax errors
07:55:55 <astrolabe> xeiro: my advice is to try to write what you want to do without changing the values of variables
07:56:34 <astrolabe> you have to think to do it at first.
07:56:58 <ski> (neologism : because they are a kind of inference engine, and prolog is too, and it's easy to construct custom inference engines in prolog ?)
07:56:58 <xeiro> I need to kinda set a flag :)
07:57:46 <astrolabe> xeiro: but that flag will be a function of something
07:58:36 <xeiro> I dont understand ... the flag will be a function of something
07:58:41 <astrolabe> if you must use imperitive style, you can do it inside a 'do', but that goes against the grain of haskell
07:58:51 <xerox> Oi!
07:58:59 <astrolabe> Hia xerox :)
07:59:04 <xeiro> yeah ... grasping this haskell is gonna take a while
08:00:01 <astrolabe> when you want to change the flag, what you change it to will depend on something.  Usually the best thing is to make that explicit
08:00:23 <xeiro> think I'm kinda getting it now
08:13:51 <benny> man gtk2hs is taking forever to build :=
08:15:56 <xerox> ...its compilation time is still a finite value.
08:16:49 * benny hopes so
08:19:12 <benny> "Haskell is not very practical."
08:26:39 <danY2K> hey guys. is it possible to map or overwrite equation operators onto an own datatype?
08:27:13 <benny> you mean like + ?
08:27:25 <danY2K> =>, == etc
08:27:45 <danY2K> adn _not_ by deriving from Eq
08:29:21 <danY2K> oops. i meant >=, ==, etc ;-9
08:30:29 <Saulzar> You can - but you run into the same issue I had, they are ambiguous with the Prelude module versions
08:31:02 <gus> I'm having problems installing HASP. I get " Could not find module `ErrUtils' " , when I try to build. Somebody here that knows if I have been doing somthing wrong, or if it's a bug?
08:31:48 <Saulzar> So the == from Eq will clash with your ==, so I guess realistically you have to use Eq or use another operator/function name
08:32:11 <jlouis> =.=
08:32:31 <danY2K> Saulzar, yeah. exactly. the same error is getting thrown at me, too
08:32:48 <pesco> danY2K: (>=) comes from class Ord, (==) from Eq. You can define them for your own data type by instantiating those classes for your type(s). If the classes don't fit your purpose, you have to define your own operations, which, in the case of (>=) and (==) will clash with the Prelude-defined ones. This effect obviously cannot be helped, but you can limit the Prelude imports by stating, for example, 'import Prelude hiding ((>=), (==))' in your program.
08:33:25 <jlouis> Beware though, that you make you program unintuitive by doing this
08:33:29 <ski> (Saulzar : you know you can hide imports from Prelude, right ?)
08:34:06 <danY2K> pesco, thanks. gonna try it out ;-)
08:34:34 <pesco> danY2K: Also respect what jlouis said, though. ;)
08:34:36 <benny> man that shit is still building...
08:34:57 <Saulzar> ski, Yeah - but I imagine you would have a lot of awkward situations where you want the normal == ...
08:35:27 <pesco> Saulzar: But what is wrong with class Eq in those situations?
08:36:03 <pesco> @info Eq
08:36:03 <lambdabot> Unknown command, try @listcommands.
08:36:53 <Saulzar> pesco, Nothing that I know of
08:37:19 <danY2K> pesco, yeah. seen that. already had this solution defining my own constructors. but i'd like to check out some different stuff... 
08:39:05 <Lemmih> @seen JaffaCake
08:39:06 <lambdabot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
08:41:53 * araujo drinks some hot tea with honey
08:42:14 <ski> (Saulzar : yes, you'd have to use it qualified (or renamed), of course)
08:44:25 <Saulzar> Is there anything actually wrong with using Eq (or Num) for that kind of thing at all? Slower than hardwired type or something?
08:45:18 <ski> gus : ErrUtils seems to be in fptools
08:45:58 <pesco> Saulzar: Implementation-dependent. GHC incurs a slight overhead for class methods, if I'm correct. Don't worry about it until it ever becomes a problem.
08:50:40 <soysauce> is there a good argument for not requiring a Haskell program to cover all cases? e.g. disallowing definitions like this:
08:50:50 <malcolm_> If GHC can work out that it is only being used monomorphically, it can specialise the dictionary away, so there is no extra overhead.
08:50:52 <soysauce> foo (x:xs) = xs -- oops, what happens when the argument is []?
08:50:52 <kolmodin> hot tea with honey? that's a great idea! :)
08:51:21 * kolmodin runs away to the kitchen
08:51:37 <malcolm_> soysauce: if you can prove that a certain case never happens, then writing a clause for it is redundant
08:51:55 <soysauce> malcolm_ - but usually it's too difficult to prove that
08:52:20 <soysauce> or else it would require rewriting the program in order to make it provable...
08:52:27 <soysauce> changing data structures and so forth
08:52:34 <malcolm_> soysauce: sure.  Turn on warnings in the compiler to see the missing cases.
08:52:37 <jlouis> I tend to guard impossible variants by foo .... = error "This is impossible"
08:52:45 <soysauce> malcolm_ - what does it do if you omit a case?
08:52:53 <soysauce> jlouis - I was thinking that
08:52:56 <jlouis> soysauce: raises an exception
08:52:58 <ski> soysauce : sometimes one have internal invariants that say that some combinations are impossible (you approcimate the real abstract type, with a representation type)
08:53:03 <soysauce> err
08:53:10 <soysauce> what code does it generate if omit a case, I mean
08:53:13 <soysauce> +you
08:53:15 <malcolm_> "pattern match error in Foo.bar at Blah.hs:35:17
08:53:28 * gour wonders why honey with hot tea.  honey used on a high temperature get poisonous
08:53:28 <soysauce> ski - I know that, but usually you can't *prove* that to the compiler
08:53:36 <ski> right
08:53:39 <soysauce> malcolm_ - "error 'pattern match error ...'"?
08:53:47 <ski> (with dependent types, it'd work, i think)
08:53:49 <malcolm_> soysauce: yeah
08:53:54 <soysauce> ok, I see
08:54:37 <ski> hm, can ghc tell when there's nonexhaustive patterns, if one passes some option ?
08:54:46 <jlouis> -Wall probably
08:54:50 <soysauce> ski - yes
08:54:59 <soysauce> because I have seen *many* of those when compiling GHC itself ;)
08:55:01 <malcolm_> -f
08:55:11 <malcolm_> warn-incomplete-patterns maybe
08:55:31 <soysauce> I wonder if you couldn't make assertions about the types of patterns that a function could accept
08:55:38 <soysauce> and handle such things purely at compile-time
08:56:37 <malcolm_> ndm is writing a case-checker for Haskell that should be able to prove whether your program will definitely avoid a pattern-match error
08:56:38 <ski> (warning for redundant and overlapping patterns could also be useful, at times)
08:56:52 <soysauce> malcolm_ - so it is provable?
08:57:07 <malcolm_> soysauce: semi-provable.
08:57:08 <soysauce> ski - overlapping patterns should always be a warning, heh, and I think it is
08:57:12 <soysauce> malcolm_ - "semi"?
08:57:28 <ski> hm, yes, you're right
08:57:34 <soysauce> malcolm_ - I am curious because I have for a long time been interested in provability
08:57:46 <malcolm_> soysauce: I think, if the prover says it will be OK, it will be.  But there are some cases where it will be OK and the prover cannot determine that.
08:57:47 <soysauce> ski - I remember getting those warnings when working on my first Haskell program, soooo... ;)
08:57:58 <soysauce> malcolm_ - ah, ok
08:58:04 <soysauce> malcolm_ - false negatives then.
08:58:18 <ski> (hm, SML has redundant pattern as an error .. would this be a good idea ?)
08:59:21 <soysauce> ski - I think so.
08:59:37 <soysauce> ski - you can always comment the second pattern if you *intend* to leave the code in-place.
08:59:40 <malcolm_> soysauce: conversely, I think the prover can be certain some programs definitely will fail.
08:59:57 <malcolm_> soysauce: so there are three outcomes - OK, Fail, and I Don't Know
09:00:15 <soysauce> *nods*
09:01:14 <araujo> gour, it is not that i am dinrking it on 100C :-P
09:02:41 <gour> araujo: that's fine, but everything above ~40 C produces the effect
09:04:00 <araujo> what effect?
09:05:11 <gour> araujo: it becomes poisonous, i.e it increases 'ama' (toxins) in the body (Ayurvedic principle)
09:06:04 <araujo> oh, ayurvedic principle?
09:06:10 <gour> araujo: otherwise, honey is considered healthy if taken in small doses
09:06:14 <soysauce> something Hindu I presume :p
09:06:22 <soysauce> vedas = truth IIRC
09:06:26 <araujo> yeah
09:06:32 <neologism> vedas = sciences
09:06:43 <gour> soysauce: much older, hindu does not exist in vedas :-)
09:06:44 <neologism> or crafts
09:06:47 <malcolm_> I thought Ayurvedic was Bajoran (ST:DS9)
09:07:01 <soysauce> lol
09:08:42 <soysauce> hmm... I suppose "vedas" descends from Indo-European
09:09:02 <soysauce> just struck me that Latin "veritas" means truth, too
09:09:17 <soysauce> and Spanish "verdad"
09:09:36 <araujo> yeah
09:09:57 <Lor> verily
09:10:03 <soysauce> nice
09:10:08 <gour> soysauce: we can say 'veda' means knowledge, while 'tattva' is a truth ;)
09:10:13 <ski> verify
09:10:15 <soysauce> ah, ok
09:10:17 <araujo> gour, that's good to know, though i wonder how many more things are poisons for ayurvedic :-P
09:10:18 <soysauce> knowledge, then :p
09:10:44 <araujo> isn't sattva?
09:10:55 <gour> soysauce: lot of things consumed by modern people :-)
09:11:12 <gour> araujo: sattva is 'goodness' - quality
09:11:52 <gour> araujo: in any case, health means balance of three doshas (vatta, pitta, kapha)...
09:12:32 <gour> and according to one's constitution one has to eat (& drink :-)
09:12:47 <gour> pretty individual
09:12:58 <araujo> Yeah, i agree with that :-P
09:13:37 <gour> araujo: therefore better to take a look what's your partner's constitution before it's too late ;)
09:14:17 <araujo> my partner? , well, ive been drinking hot honey for years now 
09:14:26 <araujo> I should already be death i suppose :-P
09:14:31 <araujo> dead*
09:14:50 <xeiro> hey ski...  wazzup? :)
09:16:23 <gour> araujo: not necessarily, but your doshas are getting out of balance and you'll have to pay later, maybe your digestion is not ok...
09:17:04 <kolmodin> I think it's more dangerous to cross the street than to drink hot tea with honey. I've been doing both for a long time and I'm still (relatively) fine :)
09:17:04 <araujo> gour, never suffered of it.
09:17:13 <araujo> kolmodin, hahaha
09:17:20 <araujo> kolmodin, how you doing bud?
09:17:29 <gour> araujo: then you (still) have good karma :-)
09:17:39 <araujo> gour, :-]
09:17:58 <araujo> gour, i live in a pretty hot place, would that affect?
09:17:59 <kolmodin> araujo: good. only hurts while training or lifting heavy stuff
09:18:30 <kolmodin> araujo: so it's almost over. another week or two and I'm back to normal
09:18:46 <araujo> kolmodin, glad to hear/read that.
09:19:12 <kolmodin> araujo: and you? take it easy with that tea :)
09:19:15 <tic> kolmodin!
09:19:20 <kolmodin> tic: hi!
09:19:25 <araujo> kolmodin, haha, OK :-]
09:19:32 <gour> araujo: in such place power of digestion is (naturally) less to keep the balance with the environment
09:20:09 <gour> araujo: that's why we can digest more heavy stuff during the winter time, and have less appetite during summer
09:20:22 <araujo> I see.
09:20:46 <gour> araujo: or in hot place onw has to use more spices (e.g. ginger, chilly) to make it easier..
09:20:49 <tic> kolmodin priv query!
09:21:05 <araujo> gour, yeah, i agree with that.
09:21:15 <kolmodin> tic: yeah.... didn't you get my reply?
09:21:42 <tic> No..
09:21:46 <kolmodin> tic: strange
09:21:47 <tic> you must be registered I think.
09:21:47 <gour> araujo: but maybe it is just that you're more fiery type and therefore have good power of digestion
09:21:51 <araujo> gour, you are hinduist?
09:21:53 <benny> hm.... wait a minute.... does gtk2hs have opengl support or not?
09:21:54 <tic> kolmodin, openprojects policy
09:22:03 <kolmodin> that's odd
09:22:11 <gour> araujo: no, born in croatia :-)
09:22:31 <araujo> gour, i eat little , my philosophy is to eat all i want, but never abuse it :-]
09:22:37 <gour> araujo: but try to follow teachings of vedas
09:22:43 <dcoutts> benny, yes it does, but only in the development version.
09:22:47 <araujo> Ok.
09:23:05 <dcoutts> benny, see: http://haskell.org/gtk2hs/archives/2005/11/11/more-opengl-goodness/
09:23:13 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/04/start-of-opengl-binding/
09:23:36 <benny> thanks
09:24:12 <gour> araujo: i have a friend who told me: "there was a time when i could eat anything, but then the time arrived when i could not not anything.."
09:24:20 <dcoutts> benny, it's realy cool actually. I'll be using it next year for a functional programming course. This year I did 2D graphics with Gtk2Hs.
09:24:38 <gour> araujo: so, take care
09:24:41 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/01/university-courses-using-gtk2hs-for-teaching/
09:26:21 <araujo> gour, hey, we always end up like that :-P
09:26:42 <gour> araujo: like what?
09:28:19 <kolmodin> I eat anything I want to, but not all the time :)
09:35:50 <danY2K> b
09:39:02 <xerox> Bye bye.
09:43:20 <benny> dcoutts: maybe someone should tell author of http://gtkglext.sourceforge.net/ website that there are haskell bindings :D
09:43:39 <dcoutts> benny, hmm, yes maybe so
09:48:55 <resiak> dcoutts: Was the L-Systems bit of the practical added this year?
09:48:59 <phys_rules> hey everyone ;)
09:49:11 <dcoutts> resiak, yes
09:49:20 <resiak> dcoutts: Bah, it looks cool and I missed it :(
09:49:47 <dcoutts> resiak, and for next year I want to add a optional exercise to extend it to 3D!
09:49:56 <phys_rules> dcoutts: I got to compile & link it, but it dumps core now ... :)) great =)
09:50:00 <resiak> dcoutts: Can I just like retake my degree in 2 years' time?
09:50:12 <dcoutts> phys_rules, sounds like progress :-)
09:50:30 <dcoutts> resiak, heh, you think it'd be more fun the second time round? :-)
09:51:06 <resiak> dcoutts: Yeah, because I'd have more time to play with cool things having learnt most of the stuff ;)
09:51:50 <dcoutts> resiak, though some stuff is not much clearer the second time round... I had to teach the compilers practical the other day. Static links. Grrr.
09:52:11 <resiak> dcoutts: Heh, heh.
09:53:55 <phys_rules> I haven't used gdb for about 7 years =)
09:54:29 <dcoutts> phys_rules, hah, yeah I've not used it since I ported it to the Cray X2 ...
09:55:43 <phys_rules> bummer, the stack trace doesn't tell me a lot =)
09:57:40 <ski> (xeiro : not much .. just trying out a few ideas i got ..)
09:59:43 <dcoutts> phys_rules, ghc doesn't use the C stack much.
10:00:05 <dcoutts> phys_rules, you've built the debugging version of the ghc rts?
10:00:18 <phys_rules> dcoutts: I'm affraid not :)
10:00:26 <phys_rules> not = no
10:00:35 <dcoutts> phys_rules, then do it! :-)
10:00:49 <Xianianol> Humm, what does it mean that "Last generator in do {...} must be an expression ?
10:00:54 <dcoutts> phys_rules, you don't need to rebuild the whole of ghc, rebuilding the rts is much easier
10:01:12 <dcoutts> phys_rules, in fact you might have built it anyway and not dealised
10:01:17 <dcoutts> dealised/realised
10:01:43 <dcoutts> phys_rules, I think it may be just a matter of linking using -debug
10:01:52 <dcoutts> to get the debug version of the rts
10:01:54 <superibor> Xianianol For me it always means that I forgot a 'return' at the end
10:01:57 <phys_rules> let me have a look at it
10:02:10 <Xianianol> Humm, I do have a return, that is the problem.
10:04:36 <Xianianol> Shouldn't be because of the indentation too...
10:05:15 <superibor> Xianianol check that you don't use tabs, just in case
10:05:36 <Xianianol> (erm, I use lots of tabs)
10:06:42 <superibor> Xianianol I'd try to reorder the expression using ';' and { } to see if it helps
10:07:11 <Xianianol> erm...removing the tabs fixed the problem...T_T
10:07:36 <Xianianol> Why Haskell doesn't like tabs ?
10:09:27 <Lemmih> Because tabs are evil?
10:10:12 <Xianianol> heh, it is just easier to do tabs than 5-8 spaces...
10:10:52 <jlouis> We have now officially deemed tabs to be evil. Come back next week when we select another symbol from the ASCII table
10:12:11 <phys_rules> tabs are evil indeed
10:13:05 <phys_rules> Xianianol: well, tab emulation is ok, as long as they get saved as spaces :)
10:14:10 <Xianianol> Heh, right now, just to be safe I am just using space.
10:14:30 <Xianianol> I rather concentrate fixing the code than fixing the indentation/tabs.
10:17:12 <Xianianol> Gah, can't believe that I got a cramp on my leg by just streching/yawning.
10:17:54 <RemiTurk> good afternoon
10:18:00 <Lemmih> Hi RemiTurk.
10:19:59 <RemiTurk> hi Lemmih
10:20:05 <Lemmih> What's up?
10:20:16 <RemiTurk> *thinks* nothing?
10:20:40 <RemiTurk> I'm just looking around whether #haskell still exists ;0
10:23:50 <phys_rules> hehe, java dethroned c++ on sourceforge :)
10:26:07 <Xianianol> Dethroned C++ in what aspect ?
10:26:53 <phys_rules> Xianianol: more java projects than c++
10:27:34 <phys_rules> now when is haskell going to dethrone all of them =)
10:27:57 <phys_rules> 16738 java projects vs 16731 c++ projects :)
10:28:05 <benny> i have ghc 6.4.1. is this correct: to install hs-plugins i must first install haskell-src-exts but to install that i must first install happy?
10:28:48 <Lemmih> The darcs version of hs-plugins doesn't depend on hsx anymore.
10:29:13 <benny> so should i get it?
10:29:41 <metaperl> wow almost 200 people here
10:30:13 <jose_da_bicla> i thought that ghc 6.4.1 had hs-plugins libraries included
10:30:22 <Lemmih> benny: I think you should.
10:30:33 <benny> hm... is jose_da_bicla correct?
10:30:56 <Lemmih> jose_da_bicla: hs-plugins is LGPL and well therefore never be including in the standard libraries.
10:31:51 <Lemmih> *will
10:32:00 <jose_da_bicla> sorry.. ur right :P
10:32:25 <benny> Lemmih: can i get the darcs vesion without installing darcs?
10:33:00 <Lemmih> I think dons has snapshots of the repo somewhere.
10:34:00 <benny> whoah shit my laptop mouse just broke :O
10:34:10 <eivuokko> Recursive http-get works for darcs repos on http-servers, as well.  You might want to not download _darcs, tho.
10:35:19 <phys_rules> Lemmih: what's GHC's license ? just GPL ?
10:35:31 <Lemmih> phys_rules: BSD3
10:35:55 <phys_rules> imho BSD and LGPL are not too far away, I might be totally wrong here ;)
10:36:53 <eivuokko> About ghc license..it is BSD, except GMP (ghc has it's own version), which is LGPL, and on Windows it comes with gcc bundled, which is GPL.
10:37:24 <eivuokko> Usually, system libgmp is used, tho.
10:38:22 <gour> phys_rules: this one worries me more http://programming.newsforge.com/article.pl?sid=05/11/23/1638201&from=rss
10:39:33 <gour> phys_rules: there is even special section on ltu -- http://lambda-the-ultimate.org/node/view/1135
10:39:45 <phys_rules> Am I the only one who doesn't think ruby is a cool language ?
10:39:47 <phys_rules> =)
10:39:50 <phys_rules> haskell is like way better
10:41:30 <jlouis> The point is that ruby is higher up the abstraction ladder than its competition (C, Java, C++, Python, Perl, TCL, etc)
10:41:36 <superibor> Ruby has it's good points, but I don't know neither Haskell or Ruby that much
10:41:47 <jlouis> So the ``masses'' see it as a new messiah
10:42:04 <jlouis> Haskell is even farther up the abstraction ladder I think
10:42:24 <araujo> ys it is, by far
10:42:24 <phys_rules> jlouis: yeah, the thing is ruby is closer to those old languages
10:42:26 <araujo> yes*
10:42:33 <phys_rules> so it's easier for people to switch to it
10:42:38 <araujo> ruby is "scripting smalltalk"
10:42:47 <gour> phys_rules: yes it is, but it would be nice to have haskellforge, more libs, projects, users, docs...
10:43:09 <araujo> gour, that'd be cool.. but isn't that the hackage project goal?
10:43:16 <phys_rules> yep
10:43:20 <phys_rules> hackage should be good =)
10:43:34 <phys_rules> there's one big issue though
10:43:37 <phys_rules> with the libraries
10:43:39 <gour> araujo: i'm not sure hackage will provide all the services for hosting a project
10:43:46 <phys_rules> they're not too helpful :)
10:43:50 <phys_rules> err
10:43:52 <phys_rules> the documentation
10:44:04 <phys_rules> Java's API documentation is wonderful
10:44:24 <araujo> gour, i doubt it will, but it will accoplish the main goal of distributing haskell software very good.
10:44:29 <jlouis> A language today is 20% syntax/semantics, 40% social user base and 40% librarry support
10:44:40 <jlouis> you simple have to support numerous stuff to kill
10:44:43 <araujo> oh well, off to eat
10:45:33 <jlouis> Which is why, in Haskell, you should always build upon what others have done rather than roll you own from scratch again. Or we will never reach critical mass in libs
10:46:24 <gour> jlouis: right, and more docs will bring more users == more libs == wider acceptance of haskell in general
10:46:37 <astrolabe> I think the hurdle for entry to haskell is higher.
10:46:39 <jlouis> I have seen a lot of rails and it is not that impressive in my eyes.
10:47:06 <jlouis> In half a year, PHP has a rails framework
10:47:07 <superibor> I agree with astrolabe. learning Ruby is a matter of days, and you can master it in weeks. Learning Haskell can take months, mastering it... well
10:47:38 <phys_rules> astrolabe: There should be good books (similar to Thinking in C++/Java), there is a good book though "Yet Another Haskell Tutorial"
10:47:48 <gour> superibor: sure, but more tutorial docs wouldn't harm, for other langs there are plenty of books
10:47:50 <jlouis> superibor: yes, but you don't have to be master
10:48:03 <superibor> I've not read YAHT. But I 've read several books on Haskell
10:48:13 <phys_rules> but it is essential to have good documentation IN the libraries
10:48:14 <superibor> And there is one difference with the Ruby pick Axe
10:48:24 <phys_rules> instead one should check out the sources, web to figure out how to use it :)
10:48:33 <astrolabe> phys_rules: I think there are good books about, but that the underlying subject matter is just more abstract and difficult.
10:48:36 <gour> otoh, wxhaskell & gtk2hs (main gui libs for haskell) have just a few devs working on them
10:48:52 <phys_rules> astrolabe: I should reformulate good books available on the net for free ;)
10:49:04 <phys_rules> Haskell books are way too expensive :(
10:49:30 <superibor> Haskell books deal mainly with functional rogramming and cool applications. They fail in that they don't deal with XML, documentation, Unit testing, and Web Applications
10:49:31 <gour> phys_rules: fortunately, not lot of them available, which cuts the cost :-)
10:49:40 <superibor> That said, I like Haskell books, I read them for fun
10:50:07 <phys_rules> gour: true =)
10:50:18 <astrolabe> Also, functional data structures are more complex.
10:50:21 <jlouis> We really need some XML library in the Base
10:50:25 <phys_rules> yeah
10:50:48 <astrolabe> I can't really grok the point of XML, but it seems to have caught on.
10:51:27 <superibor> Average Joe won't read a bunch of papers (Scrap your boilerplate) to understand the article on Web Services in the Monad Reader 1st issue...
10:51:30 <jlouis> the point of XML: Provide a uniform way to represent abstract syntax trees and provide a parser as well as a type checker for it. Then provide tools to cut, search and mangle the tree
10:52:11 <jlouis> the advantage is you don't have to go through the hassle of writing the AST parser and stuff later
10:52:16 <gour> jlouis: something like rexml in ruby?
10:53:16 <astrolabe> jlouis: You must be right, but to me, most of the parsing an manipulation will be application dependent, and there would be minimal advantage over an adhoc approach.
10:53:51 <jose_da_bicla> what reasons could leave eval_ on hs-plugins to give the result Left ?
10:56:39 <phys_rules> astrolabe: XML is sort of good and evil at the same time, good because it decouples data very nicely, evil because there always has to be a good backend for processing and sometimes the initial info takes too much space and is therefore very slow to process
10:56:59 <jlouis> astrolabe: we are talking medium/low level programmers here. They are able to use XML from almost day one. Its a hammer to them. For them, writing and defining ad-hoc ASTs means weeks of work. Weeks the management loves to see shaved off.
10:57:00 <phys_rules> I think having documents in xml is overkill :)
10:57:25 <jlouis> that is the tao of XML
10:58:08 <astrolabe> jlouis: I like that explanation, it means I can' understand because I'm too good :)  It must be right.
11:11:30 <phys_rules> If only I could get ghc to run on solaris x86.. =)
11:13:41 <ski> @remember astrolabe I like that explanation, it means I can' understand because I'm too good :)  It must be right.
11:15:10 <Frederick> ski, are you busy?
11:15:42 <ski> not right now ..
11:16:03 <ski> what was the trouble in http://paste.lisp.org/display/13988 ?
11:18:02 <Frederick> ski, the function works in all cases except one, if the transitive closure is like S -> A, A -> B, B -> c it simplifies correctly to S -> c, S -> aAa | bBb, A -> a, C -> c also works but if the root symbol must be replaced in the productions it fails
11:19:50 <ski> hm, you have an example of when it fails ?
11:20:07 <Frederick> ski, sure 1 sec lemem write it
11:20:44 <ski> hm, also, i forgot your exact type-definitions, and such, so maybe you could provide them, somewhere, too
11:21:41 <lisppaste2> Frederick pasted "the whole mess" at http://paste.lisp.org/display/14028
11:25:16 <Frederick> ski, but in a case like that http://paste.lisp.org/display/14029 it fails
11:26:07 <Frederick> it keeps a reference to S even it beeing useless
11:35:34 <ski> run grammar "" (unlines ["termchars ab","start S","S -> A | a","A -> B","B -> a | aS"]) = CFG {terminals = [T 'a',T 'b'],nonterminals = [NT 'A',NT 'B',NT 'S'],root = NT 'S',productions = {NT 'B':=[[T 'a'],[T 'a',NT 'S']],NT 'A':=[[NT 'B']],NT 'S':=[[NT 'A'],[T 'a']]}}
11:35:36 <ski> hm
11:37:22 <ski> are you expecting 'CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'B',NT 'S'], root = NT 'S', productions = {NT 'B':=[[T 'a'],[T 'a',NT 'B'],[T 'a',T 'a']],NT 'S':=[[NT 'B'],[T 'a']]}}' ??
11:37:42 <ski> i guess i don't understand what you mean by 'if the root symbol must be replaced in the productions it fails'
11:39:49 <Frederick> ski, sometimes if I have S -> A | a the combination where the a should appear that given combination of productions doesnt show up
11:43:52 <ski> as you have written it, it only seems to expand rules like A -> B
11:44:15 <ski> i.e. just one alternative, with just one thing (terminal or nonterminal)
11:44:24 <Frederick> hm...
11:45:01 <Frederick> how can I fix it? I mean I think it is dam confusing to come back to evaluate something to explore all possibilities
11:45:22 <ski> well
11:45:31 <ski> if you have
11:45:36 <ski> S -> A | a
11:45:40 <ski> A -> B
11:45:45 <ski> B -> a | a S
11:46:08 <ski> then your code now expands 'A', into 'B'
11:46:12 <ski> so you get
11:46:19 <ski> S -> B | a
11:46:23 <ski> B -> a | a S
11:46:46 <ski> then, i guess you could want to expand 'B' like
11:47:21 <ski> S -> (a | a S) | a
11:47:27 <ski> i.e. you want
11:47:35 <ski> (um, sorry)
11:47:46 <ski> (no, it's right)
11:47:49 <ski> i.e. you want
11:47:52 <Frederick> yes it is the problem
11:47:54 <ski> S -> a | a S | a
11:48:03 <ski> but, you are not doing that, currently
11:48:26 <Frederick> hm
11:48:32 <ski> isReplacer [[x]] = True
11:48:32 <ski> isReplacer _     = False
11:48:46 <ski> that checks for (bodies of) rules like
11:48:47 <ski> A -> B
11:49:01 <ski> i.e. where you have one alternative, and that alternative is just one thing
11:49:29 <ski> possibly you want to modify 'isReplacer' so it also accepts rules like
11:49:39 <ski> hm
11:49:44 * ski thinks
11:49:58 <Frederick> k so basically I need one or two more lines of code to handle the situation when I might need to evaluate a part of ah bigger production the probles is how to iterate there
11:51:00 <ski> i think,
11:51:03 <ski> say you have
11:51:33 <ski> X -> ... | Y | ...
11:51:43 <ski> Y -> .....
11:52:07 <ski> i.e. there's one alternative in X, that just consists of a nonterminal
11:52:14 <ski> then you want to expand this into
11:52:20 <ski> X -> ... | ..... | ...
11:52:39 <ski> (Y can have many alternatives here .. doesn't matter)
11:52:42 <ski> so, hm
11:53:38 <ski> assume you in your map associates NT 'X' with prods (which is an alternatives list, each alternative being a list of symbols)
11:54:27 <ski> then, you want to look at each alternative in prods .. and if it's a single nonterminal, you want to expand that alternative to 0 or more alternatives, taken from it's expansion
11:54:48 <ski> this is what i think you want, here
11:55:23 <Frederick> yes
11:57:09 <ski> so .. hm ..  assume we do something like   concatMap (\prod -> case prod of [nt@(NT _)] -> <lookup nt, to get a list of alternatives> ; _ -> [prod]) prods
11:57:30 <ski> and that would be the new list of prods
11:58:02 <Frederick> ski, so shouldI evaluated that again later until a condition like no chage?
11:58:03 <Xianianol> Does anyone know what does this mean?: Program error: {evalExpr emptyEnv (Expr_Nat (read instRead_v39 "2") Expr_:+ Expr_Nat (read instRead_v39 "3"))}
11:58:52 <ski> Frederick : i think you should be able to do it in one step, like you do with 'result' currently ..
11:59:24 <ski> (in 'replacements')
11:59:53 <Frederick> hm..
12:00:45 <ski> Xianianol : that means that you have no clause for 'evalExpr' which handles when the second argument is 'Nat 2 :+ Nat 3'
12:01:05 <ski> Xianianol : possibly you forgot to handle (:+) ?
12:01:37 <Xianianol> Humm...Hopefully it is not because of indentation again T_T
12:01:55 <Xianianol> Thanks, let me double check.
12:08:43 <Frederick> ski, I got no idea about what to do =/
12:10:59 <Cale> Xianianol: you might try running your program in ghci, it usually gives a better error message in those cases
12:15:16 <cinema> Anybody knows how to start frag ? I've tried every letters from the keyboard, but the game hasn't started
12:18:27 <Frederick> ski, any idea for me?
12:18:49 <ski> (hm, i'm looking at removeReplacers, to see what it does)
12:27:08 * ski has an idea ..
12:29:02 * Frederick paysattention
12:29:14 * ski writes and thinks ..
12:29:51 <ski> (i'm not fully sure this will take care of all you did before, but it should hopefully take care of the new issue, at least)
12:29:56 <Cale> cinema: read the readme?
12:31:47 <Cale> cinema: If the compilation works, I believe you just run it with ./frag leveleg
12:33:55 <cinema> Cale, yes but then the game does not start
12:34:17 <cinema> Cale, Have you tried it ?
12:34:38 <Cale> yeah, it works fine here
12:34:58 <Cale> takes a second or two to load everything at the beginning
12:35:19 <Cale> (during which time the window doesn't paint correctly)
12:35:39 <cinema> Yes, it loads everything, the image appears, but then I don't see any ennemy
12:35:51 <Cale> walk around
12:36:20 <cinema> Maybe I haven't the correct harware configuration
12:36:32 <cinema> Or my graphic card is too old
12:37:42 <Cale> well, if you see anything at all, it should be okay
12:37:47 <cinema> I'll try on my PC at office. Hope it does not make too much noise though
12:37:55 <Cale> There's no sound
12:38:11 <Cale> w,a,s,d should let you walk around, and the mouse looks around
12:38:11 <cinema> Ok then it's safe for my career
12:38:15 <Cale> hehe
12:38:46 <cinema> OK, I'll try again with w,a,s,d
12:39:01 <Cale> left mouse button should shoot
12:39:28 <Cale> It hasn't got too much gameplay yet. You can walk around and shoot at the AI bots, who are slow, but they do shoot back.
12:40:25 * Frederick still alive
12:42:15 <mwc> game? Haskell game?
12:42:54 <ski> @wiki Frag
12:42:55 <lambdabot> http://www.haskell.org/hawiki/Frag
12:43:55 <mwc> Cool
12:44:24 <phys_rules> mwc: you're here too ? =))
12:44:39 <mwc> course
12:45:05 <mwc> Lot's of physicists haskell. Like the guy who wrote darcs
12:45:20 <Cale> Frag is a nice proof of concept, I think
12:45:41 <Frederick> ski, any idea? brb I need to eat brb
12:45:51 <mwc> That Yampa stuff is neat
12:45:57 <mwc> way to use the DSL
12:46:28 <phys_rules> looks great =)
12:46:57 <phys_rules> mwc: yeah, physicists rock them all *stands proud* LOL :)
12:47:28 <mwc> Pah, physics is really just my area of specialization, I'm an applied mathematician
12:47:46 <phys_rules> I'm a theoretical physicist
12:47:52 <mwc> Usually my job is to sit in my undegrad lectures and cringe when my QM prof butchers linear algebra 2
12:47:55 <phys_rules> though always been into computer programming as well
12:48:30 <mwc> I'm interested in quantum time theory, personally
12:48:40 <mwc> I think that's a pretty much untapt area
12:50:14 <Korollary> we need some chemists & biologists in #haskell then
12:50:59 <superibor> & poets
12:51:28 <mwc> hahaha, good idea
12:51:34 <mwc> all the poets seem to be into Perl
12:51:36 <jlouis> What about MaD HaTtErS?
12:51:43 <jlouis> are they allowed?
12:51:45 <phys_rules> mwc: hehe, well, it's a nice topic since GR for example accept the reversability, and QM also, but there's thermodynamics  which  indicates reversability doesn't exist..
12:51:57 <phys_rules> so it's interesting to see where it arises..
12:52:06 <phys_rules> we have on prof that does QM time reversal thingie..
12:52:38 <Frederick> ski, im back
12:52:40 <phys_rules> jlouis: hehe =)
12:53:00 <phys_rules> on=one
12:53:10 <ski> m
12:53:59 <xinming1983> lisppaste2: 
12:54:01 * ski can't test the code here .. since only 6.2.2 installed, at it seems that doesn't contain Data.Map (prolly renamed from Data.FiniteMap or something ..)
12:54:02 <xinming1983> lisppaste2: url
12:54:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:54:21 <ski> (so i'm doing type-inference in head)
12:55:07 <lisppaste2> xinming pasted "Do I have to use function instead of class?" at http://paste.lisp.org/display/14030
12:56:07 <xinming1983> anyone here would give a clue?
12:56:45 <Cale> xinming: well, what is the problem?
12:57:20 <xinming1983> *Main> foo
12:57:20 <xinming1983> Top level:
12:57:20 <xinming1983>     No instance for (Show (a -> String))
12:57:20 <xinming1983>       arising from use of `print' at Top level
12:57:20 <xinming1983>     Probable fix: add an instance declaration for (Show (a -> String))
12:57:20 <xinming1983>     In a 'do' expression: print it
12:57:49 <Cale> huh, that code works for me
12:57:53 <Cale> oh
12:57:58 <Cale> you just typed "foo"
12:58:06 <Cale> that's a function a -> String
12:58:10 <xinming1983> Cale: sorry, I misunderstand what a class should be. :-)
12:58:14 <Cale> you have to give it a parameter
12:58:15 <lisppaste2> ski annotated #14028 with "something like this, i think" at http://paste.lisp.org/display/14028#1
12:58:30 <xinming1983> Cale: It works now, thanks
12:58:48 <ski> Frederick : see
13:01:19 <xinming1983> Cale: hmm, would you mind to explain what the differences between data and newtype are?
13:02:04 <Frederick> ski, I got a parser error here ->   prodssimp'' = Map.filterWithKey (\k _ -> ...)
13:08:05 <cinema> xinming1983, data implcitly contains the 'bottom' value, which newtype has not. So newtype is more efficient
13:09:27 <xinming1983> cinema: So, Do you mean we can always use data if we are not care about the efficiency?
13:09:38 <Cale> xinming: newtype creates a new type, but behind the scenes implements that type with the same memory representation
13:10:47 <Cale> with data, the data constructors are "lifted" which means that, say, if you have  data MyType = Foo Int
13:11:27 <Cale> then (Foo undefined) is different from undefined
13:11:38 <cinema> xinming, there are some good points to newtype if you use the deriving clause in extended form
13:11:40 <Cale> (the first will pattern match against (Foo x), the second won't
13:11:45 <Frederick> ski, what is ...?
13:11:48 <Cale> )
13:12:20 <Cale> However, if you use newtype MyType = Foo Int, then (Foo undefined) is exactly the same as undefined
13:12:40 <cinema> I think you can do a 'deriving Monad' with newtype. You can't do that with data
13:12:48 <Cale> sure you can
13:13:03 <Cale> you can derive Monad for any type constructor of the right kind
13:13:34 <Cale> er
13:13:39 <Cale> oh, I see what you mean
13:13:45 <Cale> using newtype deriving
13:13:48 <Cale> yeah
13:14:03 <Cale> you can't derive just any class through a data declaration
13:14:17 <Cale> but there's an extension to GHC which lets you do that with newtypes
13:14:28 <cinema> That's a recent extension of GHC
13:15:34 <musasabi> Is there any paper on the "data types as kinds" thing out there?
13:16:02 <cinema> musasabi, look at Omega (Tim Sheard's site)
13:16:41 <musasabi> cinema: Is the Haskell implementation going to look like that?
13:16:57 <cinema> musasabi, yes
13:17:01 <maniacH> wazzaaa
13:17:01 <Korollary> musasabi: for that you may have to check SPJ's papers.
13:17:16 <cinema> musasabi, you can play with omega already
13:17:46 <cinema> The classic example is static lists, where the lengh is known at compile time
13:17:47 <musasabi> cinema: does onema have typeclasses + fundeps (I am interested how it changes type-level computations in Haskell) 
13:18:23 <cinema> musasabi, omega has no typeclasses (and thus no fundeps)
13:19:43 <cinema> but it has 1) kinds 2) functions on types 3) types as properties
13:21:11 <musasabi> 2) is very nice
13:21:18 <musasabi> (and so is 3)
13:21:31 <phys_rules> musasabi: hey :)
13:21:34 * musasabi would rather have 2 than the fundep way
13:21:37 <musasabi> hello phys_rules 
13:21:39 <phys_rules> musasabi: got it to compuile AND link
13:21:45 <phys_rules> musasabi: but now it just dumps the core on me :)
13:22:15 <phys_rules> probably the effect of my "hope this work" patches :)
13:22:25 <phys_rules> s/work/works
13:23:45 <musasabi> mmh
13:24:08 <musasabi> debugger + backtrace may help if you are crashing inside the rts
13:24:22 <Frederick> folks why this doesnt compile? http://paste.lisp.org/display/14028#1
13:27:36 <lisppaste2> Frederick annotated #14028 with "broken piece" at http://paste.lisp.org/display/14028#2
13:41:16 <ski> Frederick : '...' should be replaced with something ..
13:42:09 <ski> (we should filter so that only nonterminals that are still "used" are kept)
13:42:48 <ski> (only, i'm not fully sure when it is "used", which is why i left that part out, there)
13:42:53 <Frederick> well a terminal that still used hm.. how can weconfigure this situation?
13:42:58 <Frederick> hm.....
13:43:49 <ski> maybe you just want to keep those nonterminals that are reachable from root, not sure ..
13:44:54 <ski> or, we could remove those that have no occurance at all, any longer (except root)
13:45:05 <Frederick> well a nonterminal is still used when: S -> S so it refers to hi self so he is still used, when he can be no further replaced.
13:45:07 <ski> (that may be what you did, before)
13:45:11 <Frederick> like
13:46:19 <ski> first variant is like, a) S is used, b) if X is used, and we have 'X -> .....', then all nonterminals in '.....' are used
13:46:49 <Frederick> like X -> XS and S -> .... right?
13:47:14 <ski> second variant is like, a nonterminal X is used if there is a production Y -> ...X...
13:48:03 <ski> Frederick : 'X' is not necessarily used, according to first variant, there
13:48:06 <Frederick> the second is solved by replacing the X in Y -> ...X... for a et of productions that ha all the combinatios of derivations from s
13:49:02 <ski> (hm .. thought of a thing, you might want to avoid expanding cycles, fully .. not sure how to fix that though .. hm)
13:49:08 <ski> hi SamB
13:49:17 <Frederick> heya SamB 
13:49:39 <Frederick> ski, what do you mean by expanding cycles?
13:50:14 <ski> like, assume you have
13:50:21 <ski> X -> a X
13:50:35 <ski> then you don't want to expand that into an infinite rule
13:50:43 <ski> X -> a a a a a a ....
13:50:54 <ski> or, say you have
13:50:59 <ski> X -> a Y
13:51:01 <Frederick> I got the concepr
13:51:03 <ski> Y -> b X
13:51:29 <ski> then you only want to expand that into a rule for X which uses X (or a rule for Y which uses Y)
13:51:53 <Frederick> in this case I will want X -> bX
13:52:29 <ski> i think if one does this lazy one-step resolving/replacing, then it's very easy to by mistake get an infinite replacing, in the case of cyclic rules
13:52:49 <ski> rather X -> a b X right ?
13:53:07 <Frederick> ski, yep your version is wring
13:53:11 <Frederick> *right
13:53:20 <Frederick> omfg wring I meant right
13:55:11 <Frederick> I thik the basicidea is replace until we have a rule where the only other symbol beeing refered is the symbol from the left side ofthe rule all the others must be expanded
13:55:23 <Frederick> @localtime SamB 
13:55:33 <lambdabot> Local time for SamB is Sat Nov 26 16:55:57
13:57:17 <ski> yes .. at least if you don't care about your grammar possibly getting quite big
13:57:33 <Frederick> ski, in fact the grammar will surelly get bigger
13:57:45 <ski> not allways
13:57:55 <ski> in your example with
13:57:57 <ski> A -> B
13:58:12 <ski> we can expand that into other rule, and then remove this rule for 'A'
13:58:29 <ski> but
13:59:13 <ski> i guess one solution is to do fix-point iteration
13:59:58 <Frederick> what is that?
13:59:59 <ski> (i.e. resolve (nonself) nonterminals in all rules, and do this again and again until nothing changes)
14:00:11 <Frederick> yep this is the idea
14:00:50 <ski> another is to fully resolve each rule, once, so we only map once over the rules (= productions)
14:01:26 <musasabi> ski: does that handle mutual recursion by default?
14:01:30 <Frederick> ski, I think fix point iteration is "better" do you agree?
14:02:01 <ski> i.e. for each rule, we resolve nonterminals, but then doesn't return that, instead we resolve the new nonterminals, and again, until no nonterminals except self
14:02:18 <ski> hm
14:02:49 <ski> btw, you shouldn't resolve all nonterminals here, right ? just those that are in an alternative on their own, correct ?
14:03:08 <ski> musasabi : how do you mean ?
14:03:17 <musasabi> A = AB; B = BA; A -> ABA, B -> BAB, ...
14:03:33 <ski> '=' ?
14:03:55 <musasabi> is defined as
14:04:10 <ski> you have both '='  and '->' ?
14:04:12 <musasabi> -> == becomes after aplying the transformation
14:04:22 <ski> oh
14:04:45 * ski (and Frederick, i think) was using '->' for rules
14:05:08 <musasabi> oh well
14:05:29 <ski> Frederick : exactly what kind of expansions are you supposed to do, here ?
14:05:36 <musasabi> A -> AB; B -> BA; and after transformation A -> ABA; B -> BAB; etc
14:05:44 <ski> (i assume you should not do any distribution, at least)
14:05:49 <musasabi> (with your notation)
14:06:41 <ski> previously, Frederick only expanded rules like X -> Y  (i.e. one alternative, being a nonterminal)
14:07:38 <musasabi> I think it might work then.
14:07:48 <Frederick> ski, a sample that failed was S -> XYZ, X-> AXA | BXB | Z, Y -> AYB | BYA | Z, A -> a, B -> b, Z -> Zu | Zv
14:08:18 <ski> Frederick then did an example
14:08:25 <ski> S -> A | a
14:08:28 <ski> A -> B
14:08:34 <ski> B -> a | a S
14:08:48 <ski> that got transformed into
14:08:59 <ski> S -> B | a
14:09:05 <ski> B -> a | a S
14:09:14 <ski> but, i think Frederick wanted
14:09:25 <ski> S -> a | a S | a
14:09:27 <Frederick> S -> a | aS
14:09:35 <ski> yes, after simplification
14:09:40 <Frederick> yep
14:10:15 <ski> so, this could be done with expanding singleton nonterminal alternatives (in this case 'B' in the 'S' rule)
14:10:33 <Frederick> ?
14:10:52 <ski> S -> B | a
14:11:01 <ski> 'B' is one alternative, there
14:11:23 <ski> note the alternative consists of exactly one thing, a nonterminal
14:11:44 <ski> that was what i was trying to do in the annotation of the paste
14:11:52 <ski> but then i though of cyclic rules ..
14:12:05 <ski> s/though/thought/
14:12:28 <ski> and this will infinitely expand those
14:12:37 <ski> (rather, it can do so)
14:15:36 <ski> hm, Frederick, i think you're right that doing fix-point iteration over whole map is better than doing it once, over each rule (latter will in general be more costly)
14:16:29 <Frederick> ski, and I think fix point avoind the case musasabi commented
14:16:31 * ski is still not sure though, that one cannot use some lazy trick to do it in one step ..
14:16:46 * SamB is back
14:16:56 <ski> yes .. i think it can, if you check for that
14:17:31 * ski *yawns*
14:17:46 <ski> (SamB : like to take over ? :)
14:19:29 <SamB> ski: what are you going over?
14:19:55 <SyntaxNinja> w00t
14:20:46 <ski> Frederick : anyway .. you need some way of noting whether the rules changes (or will change) .. so you know when to stop .. the loop should repeatedly map a transformation over each rule, which will then look up (some) nonterminals in current rules, expand them once, and also possibly note (somehow) whether there actually was any expansion
14:21:43 <ski> SamB : Frederick wants to expand nonterminals in rules .. (possibly not doing distributions, though not sure about that)
14:21:50 <Frederick> ski, but how? this is crazy I mean I see this algorithms and I cant figure out how to code them, they seems like need intuition for me wht is not prrsent in computers
14:22:11 <SamB> ski: that sounds like its going over my head
14:22:30 <SamB> Frederick: if you can't figure out how to program them, how do you know they are algorithms?
14:22:38 <Xianianol> Humm, need some help again :( I am doing an env where it allows arithmetic evaluation (like 2+3*2, etc), how can I make the function to do that ? Is just that I have made the parsers but I just can use them in the way as: parse parseExpr "2+3*2", instead of directly in the env.
14:22:41 <Frederick> SamB, Imho they arent
14:22:51 <ski> he wants to expand until it can't expand anymore (no recursive expansion allowed), and then he wants to keep "used" (not defined yet) nonterminals, throwing away the unused rules
14:23:27 <SamB> so we need a definition of used?
14:23:40 <SamB> well, I'd define it as anything reachable from the start symbol
14:23:51 <SamB> or symbols
14:23:54 <Frederick> used is the nonterminal that has productions
14:23:55 * ski thinks Frederick are not su used to think in terms of recursion, and pure transformations ..
14:23:59 <ski> s/su/so/
14:24:09 <Frederick> ski, my books sucks. as my teachers
14:24:12 * ski proposed two definitions of "used" above
14:24:23 <SamB> Frederick: pretend we are doing maths with sets and whatnot
14:24:59 <ski> 1) a) S is used b) if X is used and X -> ... | ..Y.. | ... then Y is used
14:25:06 <Frederick> so we raplaced until the generated set doesnt gets new elements
14:25:26 <ski> 2) if Y -> ... | ..X.. | ... then X is used
14:26:03 <ski> Xianianol : env ?
14:27:09 <Xianianol> Environment
14:27:22 <Xianianol> Well, in a way, I am just making something what "main" does
14:27:40 <SamB> Xianianol: doesn't ghci already provide all that?
14:27:46 <Xianianol> if you type directly 2+5, main would output 7
14:27:54 <ski> Xianianol : if you parse "2+3*2" into a parse tree, and want to interpret that, then you need to write an interpreter/eval function which will pattern-match over the parse-trees
14:28:16 <Xianianol> Well, I did write the parsers.
14:28:17 <SamB> alternatively you could use a parser which will parse the answer
14:28:44 <ski> hm, ah
14:28:45 <Xianianol> For example, right now if I type: parse parseExpr "2+5", I would get 7.
14:28:57 <Frederick> this paper hasome ideas http://www.cs.uiowa.edu/~hzhang/c135/contextfree-4p.pdf
14:29:01 <Xianianol> However, I want to just to type 2+5
14:29:10 <SamB> Xianianol: oh.
14:29:11 <ski> Xianianol : i think you can't "plug" in your parser into hugs or ghci, in that way ..
14:29:22 <SamB> you could use getLine in your main
14:29:50 <SamB> @type System.IO.getLine
14:29:50 <lambdabot> IO String
14:30:12 <Xianianol> Humm, I think that I should be able to if I am working on my own Env that I've made.
14:31:50 <SamB> dons: hmm, so I've had hmp3 running for 99:54
14:32:01 <SamB> 0.1p13
14:32:08 * ski thinks he should go to sleep, now
14:33:39 <Frederick> ski, SamB I brb
14:34:15 <Frederick> ski, I will talk with SamB and check for a real version ofthe algorithm (if SamB has still patience :p) good night ski
14:40:07 <SamB> hmm.
14:40:11 <SamB> @where missingH
14:40:12 <lambdabot> http://quux.org/devel/missingh
14:41:51 <SyntaxNinja> managing bug reports is the longest part of packaging darcs
14:42:56 <ngd> l
14:55:31 <SyntaxNinja> darcs 1.0.4 uploaded to debian
15:01:38 * SamB compiles missingH
15:25:24 <phys_rules> good night guys
15:25:56 <Frederick> SamB, me back
15:26:17 <SamB> ok
15:31:54 <Frederick> SamB, any idea about how to solve that problem? I mean can we use a boolean variable that says when we are adding no more derivation to the set?
15:32:28 <SamB> Frederick: I'm not sure I understand very well what you are trying to do
15:34:53 <Frederick> I was discussing with ski before that the current version of the algorithm only handles simplificatios of a single variable like S -> B -> C -> D -> E -> a but failsd for more complex grammars like S -> XYZ, X -> AXA | BXB | Z. Y -> AYB | BYA | Z, A -> a, B -> b, Z -> Zu |  Zv 
15:35:52 <SamB> uh huh?
15:36:35 <lisppaste2> Frederick pasted "incomplete solution" at http://paste.lisp.org/display/14036
15:36:43 <Frederick> so he suggested the apporach above
15:43:13 <Frederick> SamB, that was what ski was discussing to me to how discover when we can stop expanding a rule
15:44:07 * SamB thinks MissingH.Hsemail.Rfc2822 is tooo big
15:44:47 * SamB hopes cc1 finishes with it shortly
15:45:35 * Frederick cant understand
15:46:03 <SamB> Frederick: oh, I'm just complaining that MissingH.Hsemail.Rfc2822 is taking too much RAM
15:46:14 <Frederick> hm.
15:46:18 <SamB> its finished the cc1 phase, so its okay now
15:46:33 <Frederick> SamB, what are you compilling?
15:47:00 <SamB> Frederick: MissingH
15:47:07 <Frederick> what is that?
15:47:43 <tic> Stuff that should've been in the standard libraries?
15:47:57 <astrolabe> Frederick: When my code suprises me, I find it helpful to load it into ghci and test that the functions are doing what I want
15:49:04 <Frederick> astrolabe, we know wich function is broken but not how to fix
15:51:57 <SamB> basically, the most important thing is to figure out what you want the code to do
15:53:57 <SamB> forget about all the stuff you can find on the internet. just use the set-theoretical methods you already know.
15:56:08 <Frederick> SamB, I can do it visually but I cant seem to craft an algorithm for that
15:56:58 <astrolabe> Frederick: Try breaking the functions into simpler parts
15:57:28 <SamB> Frederick: doesn't your book have some nice set comprehensions you could hijack?
16:02:41 <Frederick> SamB, nope :( this is the problem my book REALLY sucks
16:03:32 <SamB> Frederick: ouch.
16:04:12 <Philippa> get another book from somewhere?
16:06:04 <Frederick> Philippa, as Ive said many times Im brazillian good books are all impoertan, expensive and basically inacessible forus
16:07:13 <SamB> huh
16:10:54 <Philippa> Frederick: OK, fine. What do you have, what do you know?
16:11:40 <Philippa> (it's been a while since I studied CFGs at all formally, the wikipedia article's good for a quick set-theoretic definition but it'll take me a while to dig up transformations)
16:12:22 <Frederick> 1 sec
16:12:28 <Frederick> lemme organize stuff
16:16:09 <wilx> CFG?
16:16:22 <wilx> Control flow graph?
16:16:33 <Philippa> wilx: Context-Free Grammar
16:16:43 <wilx> Ah :)
16:17:03 <wilx> Some abbrevs are too overloaded :)
16:17:26 <Philippa> yeah
16:17:28 <Frederick> Philippa, I have the idea, and basically we split the algorithm in 2 cases
16:17:28 <Philippa> though some I like
16:17:48 <Philippa> "WTF" is a nice english language example of the sort of overloading Haskell goes in for...
16:18:17 <Frederick> when we have a simple closure like A -> B -> C -> D -> e it works fine generating A -> e things get messy when we have more complex grammars that would need myltiple evaluations
16:18:29 <SamB> with control flow graphs, we could show how to translate them into functional programs ;-)
16:18:50 <Philippa> "closure" as in "transitive closure"?
16:19:12 <Philippa> SamB: continuations found confusing ;-)
16:19:15 <Frederick> I was discussing with ski before that the current version of the algorithm only handles simplificatios of a single variable like S -> B -> C -> D -> E -> a but failsd for more complex grammars like S -> XYZ, X -> AXA | BXB | Z. Y -> AYB | BYA | Z, A -> a, B -> b, Z -> Zu |  Zv 
16:19:57 <astrolabe> yeah Frederick: slow down.  Does A -> B -> C mean  A -> B and B -> C ?
16:20:45 <Philippa> astrolabe: I assume so. OTOH, I for one would appreciate it if we could describe the grammars in (E)BNF rather than overloading the -> operator further
16:20:58 <Frederick> astrolabe, yes
16:22:07 <Philippa> Frederick: it's probably a good idea if you define non-terminals thusly: S ::= a | SS. That is, using ::= for definitions
16:22:21 <Philippa> that way people don't get confused as to whether you're defining a grammar or making statements about it
16:22:26 <astrolabe> Frederick:  What do you want your code to do?
16:22:35 <Frederick> Philippa, oki I will take a BNF notation
16:22:58 <Frederick> astrolabe, remove productions that only substitute variables
16:23:52 <astrolabe> hmm.  'productions' are those substitution rules?
16:23:58 <Frederick> astrolabe, yes
16:24:24 <astrolabe> What are you going to remove them from?
16:25:01 <Frederick> astrolabe, Im afraid I didnt understand you question
16:25:04 <SamB> Philippa: you don't need to use CPS for that
16:25:34 <Philippa> SamB: I know
16:26:52 <SamB> I find I am at a loss for words.
16:27:07 <SamB> that is, we seem to be missing some
16:27:24 <Philippa> Frederick: you're trying to transform the grammar into a named normal form, right? Can you name it for us?
16:28:29 <Frederick> Philippa, Im not trying to transform the gramamr in a normal form the assigment defined I must reduce it (the problem Im stuck now is a part of reduction) and transform it for Chomsky and greibach normal forms chomsky works fine and I didnt do greibachs
16:29:19 <SamB> Frederick: well, did the assignment specify the reduction formally?
16:29:49 <astrolabe> Frederick: more punctuation please.
16:30:02 <Frederick> SamB, nope it only stated we should do the simplifications.
16:34:12 <SamB> too bad
16:34:20 <SamB> it sounds like you need to make stuff up
16:34:50 <Philippa> does it at least state what the simplifications are?
16:35:01 <Philippa> that is, reasonably formally?
16:35:22 <SamB> or mention names?
16:36:49 <Frederick> yes
16:37:08 <Frederick> I must remove productions that substitute ariables, remove empty productions and useless symbols
16:37:23 <SamB> Frederick: "reasonably formal"
16:37:23 <Philippa> "useless symbols" = unreachable ones?
16:37:46 <Frederick> Philippa, yes
16:37:58 <Philippa> "substitute variables" = productions with no non-terminals, or just A ::= B type ones?
16:38:24 <Frederick> Philippa, allways a variable substitutes another
16:39:02 <Frederick> I try to let only recursions like S -> aSa if I have other letter I create new rules with all possible combinations
16:39:43 <Philippa> so, you want to end up with all productions starting with a non-terminal?
16:41:57 <Frederick> nononno
16:42:23 <Frederick> I will write it 1 sec
16:43:10 <Frederick> a production that substitutes directly a variable by another, eg A -> B adds no info forthe generation of words
16:43:33 <Philippa> OK, you're just supposed to remove those ones?
16:44:00 <Philippa> replacing all incidences of A with B instead?
16:44:08 <Frederick> so if B -> @, were @ stands for a string of terminals and nonterminals.
16:44:51 <Frederick> Philippa, this case already works the problem is if I have a grammar like the one Ive posted before
16:45:17 <Frederick> S -> XYZ, X -> AXA | BXB | Z. Y -> AYB | BYA | Z, A -> a, B -> b, Z -> Zu |  Zv 
16:45:30 <dons> SamB, great. 99hrs eh?
16:45:36 <astrolabe> Introducing new rules A -> blah, where B -> Blah is a rule when you remove A -> B.
16:45:41 <Frederick> I have to compose many many variables from that
16:45:52 <dons> the longest I've had is 40 or so, but then I hack and paatch, and want to restart.
16:46:05 <SamB> dons: it wasn't playing anything like the whole time
16:46:17 <Philippa> Frederick: you misunderstood my question. I'm just asking if the ultimate objective is to remove *all* occurrances like that
16:46:27 <Frederick> Philippa, yes
16:46:28 <SamB> anyways, the reason it was running so long is that I was at my grandparents' house
16:47:06 <SamB> oh, and its 102 by now
16:47:33 <dons> it wasn't playing anything? it was in state=Stopped
16:47:47 <dons> ?
16:48:10 <SamB> for much of the time, yes
16:48:30 <SamB> oh, btw, "d" doesn't seem to do anything at the end of the playlist
16:48:40 <dons> it wouldn't would it? 
16:48:49 <dons> or do you expect it to loop?
16:48:54 <SamB> hmm.
16:49:12 <dons> d == down
16:49:13 <SamB> wait, it seems to with loop on
16:49:29 <SamB> okay, instead I will report that it goes down to the next file in random mode
16:50:11 <SamB> I was kinda expecting it to loop, yeah
16:51:01 <dons> hmm, so in random mmode it should pick the next random track, probably
16:51:46 <Philippa> Frederick: right, thank you. So, for each non-terminal that has exactly one production which does not recurse, remove it and substitute for it in the remaining productions?
16:52:15 <SamB> but then I had thought I was in loop mode...
16:52:24 <Frederick> Philippa, yes
16:52:33 * SamB would personally expect loop to be the second mode
16:53:07 <dons> good idea.
16:53:11 <dons> I think that too.
16:53:48 <dons> easy to make that so, just reorder the constructors for the Mode type
16:54:09 <dons> like so: data Mode = Normal | Loop | Random deriving (Eq,Bounded,Enum)
16:54:11 <dons> :)
16:54:54 <SamB> you have another user?
16:55:01 <dons> yeah!
16:55:22 <dons> so that's 3 + me :)
16:55:26 <dons> actually, 4
16:55:29 <dons> + me
16:55:34 <SamB> who all is that?
16:55:38 <astrolabe> that's 5
16:55:58 <astrolabe> :)
16:56:18 <Philippa> Frederick: Which part is hard? Checking when to do the substitution?
16:56:32 <Frederick> Philippa, yes
16:56:41 <Philippa> specifically the non-recursion check?
16:56:43 <Frederick> when to stop to do it in fact
16:56:52 <Frederick> yep
16:56:54 <dons>  I know of SamB, stefanw, me, Tomasz Zielonka, and Clemens Oertel
16:57:13 <musasabi> graph + is it cyclic.
16:57:28 <SamB> dons: did you add an -O2 flag?
16:57:31 <dons> yep
16:57:57 <SamB> does that actually do something different from -O
16:57:58 <SamB> ?
16:58:09 <dons> it cranks up a few things, doesn't seem to hurt
16:58:33 <dons> case-liberation, for one
16:58:38 <SamB> ah, okay ;-)
16:58:49 <SamB> someone else thought they did the same thing
16:58:51 <dons> grep for opt_level >= 2 in the src
16:58:59 <SamB> ho
17:00:24 * SamB wonders what case liberation does
17:00:44 * SamB imagines little cases flying off into other functions
17:02:28 <astrolabe> Frederick: so you need to list all the non-terminals that can occur in substitutions of the RHS of the rule.
17:03:22 <astrolabe> Do I have the right idea?
17:03:44 <Frederick> yes
17:04:33 * SamB laments that he isn't sure which Simon is associated with Simon-log
17:06:02 <Frederick> folks i gtg slepp I shall be back tommorow
17:06:09 <Frederick> cya
17:06:18 <astrolabe> ok byeeee
17:06:30 <Frederick> cya in 12 hours +-
17:06:39 <Frederick> for more 12 hours +- of trial by fire :p
17:06:53 <Frederick> astrolabe, do you have any clue about how to do that?
17:07:00 <astrolabe> I think so.
17:07:27 <Frederick> k we talk tommorow cya
17:10:06 <SamB> isn't trial by fire where you burn someone to see if they are a witch?
17:10:38 <astrolabe> There is one where you have to pick up a red hot iron
17:10:39 <liyang> no, that's where you see if they float in water.
17:10:51 <liyang> in which case they must be a duck.
17:11:03 <astrolabe> maybe he won't be able to type tomorrow :(
17:11:08 <SamB> liyang: what?
17:11:16 <SamB> must be a duck?
17:11:41 <liyang> (monty python. :p)
17:12:07 <SamB> oh
17:12:34 <yaarg> heh
17:13:20 <tic> ad-hoc polymorphism!
17:13:37 <SamB> tic: eh?
17:13:57 <tic> quacks like a duck, python, etc. 1+1=2
17:14:09 <wolverian> quacks like a python?
17:14:17 <tic> I should probably just go to sleep. :)
17:14:20 <fworp> ive never head a python quack.
17:14:26 <dons>  SamB, do you happen to have gnome-terminal installed?
17:14:44 <SamB> are you sure 1+1=2?
17:14:52 <dons> or anyone know anything about it? is it just a normal terminal emulator?
17:14:54 <SamB> dons: hmm.
17:15:11 <wolverian> I certainly have it installed, but I don't know that much about it.
17:15:16 <SamB> dons: doesn't look like I do anymore
17:15:26 <dons> ok, no worries.
17:15:45 <dons> Tomasz gets terminal corruption in gnome terminal when hmp3 exits
17:16:18 <dons> SamB, you're using ghc 6.4 right? not 6.4.1?
17:17:04 <SamB> yeah
17:17:41 <SamB> what kind of terminal corruption?
17:19:20 <dons> you know, curses messes up the screen and it needs a 'reset', also, he gets a msg: 
17:19:23 <dons>   (Array.!): undefined array element
17:19:23 <dons> :/
17:19:26 <dons>   user error (curses exception: keypad)
17:19:41 <dons> on debian too. which is weird, since I test on debian.
17:19:52 <dons> so maybe an issue with gnome-terminal.
17:20:36 <SamB> its just a terminal emulator, yeah. I mean, what more could it be?
17:20:57 <dons> i'm wondering if it's known to be flakey
17:21:23 <SamB> oh, I wouldn't know
17:24:55 <benny> gcc: unrecognized option `-rpath'
17:24:59 <benny> what does that ghc error mean?
17:25:25 * dons thinks using cpp in the std libs is sucky: INTEGRAL_TYPE(Fd,tyConFd,"Fd",CInt)
17:25:25 <SamB> benny: it means GCC didn't like an option it got
17:25:39 <benny> yeah but why am i getting it?
17:25:50 <SamB> benny: well, what was your GHC commandline?
17:26:11 <benny> ghc --make HaskellOpenGL.hs
17:29:41 <benny> any thoughts?
17:29:55 <SamB> I think maybe your GCC is too old?
17:30:31 <benny> gcc 3.3.6 and ghc 6.4.1
17:30:40 <SamB> no idea, then
17:30:53 <benny> the gcc version is ok then?
17:31:04 <dons> you can check the gcc command line by adding -v4 to the ghc line
17:31:34 <SamB> it sounds fine to me, that is, it doesn't sound too old...
17:31:55 <dons> no, not at all.
17:32:12 <dons> but maybe the opengl lib adds some weird rpath flags in its package.conf
17:32:17 <SamB> I mean, I don't keep up on all the latest versions of GCC to avoid or anything ;-)
17:32:36 <dons> benny, are there any pacckages you should be linking against?
17:32:42 <dons> -lgl or something?/
17:33:24 <benny> don't know
17:33:37 <benny> when i do runhaskell HaskellOpenGL.hs it works fine
17:33:55 <benny> i get the same results also with a small haskell program that uses only SDL without OpenGL
17:34:05 <dons> hmm.
17:34:29 <dons> oh, runhaskell works because it is run in ghci, so no gcc is called
17:34:43 <dons> but then that probably means it's not missing libs
17:34:43 <SamB> you could try -fasm ...
17:34:52 <dons> yeah, go for -fasm
17:35:08 <benny> in the command line it appears like this: -rpath /usr/lib
17:35:38 <dons> which looks ok
17:35:53 <dons> oh, hmm, but is that an arg to ld or gcc?
17:35:59 <benny> gcc
17:36:06 <dons> it should be an arg to ld
17:36:16 <dons> now, how do we pass it through to ld again?
17:36:23 <dons> -W.. something?
17:36:28 <SamB> -Wl
17:36:32 <SamB> I think
17:36:53 <dons> -Wl,-rpath   yeah
17:37:05 <benny> what should i be looking for?
17:37:29 <dons> does adding -fasm work ?
17:37:44 <SamB> wouldnt that be -Wl-rpath,/usr/lib ?
17:38:22 <dons> the man page sayys: -Wl,option
17:38:39 <dons> so -Wl,-rpath,/usr/lib I think (?)
17:39:03 <benny> dons: no
17:39:11 <SamB> or something like that?
17:42:11 <benny> hm.... is there anything i can do?
17:43:02 <SamB> dons: is that "meta" thing possibly why ^L doesn't work?
17:48:53 <dons> ^L should work ! Tell me if it doesn't.
17:49:09 <dons> it works here
17:50:07 <dons> it didn't work until: Sat Nov 19 19:57:37 EST 2005  Don Stewart <dons@cse.unsw.edu.au>
17:50:11 <dons>   * Refresh now works, on either sigwinch or ^L
17:50:26 <wilx> Hmm.
17:50:43 <SamB> oh, you fixed it?
17:50:55 <wilx> I have seen the -Wl,-rpath,/path/to/libs separated into two statements.
17:51:15 <wilx> -Wl,-rpath -Wl,/path/to/libs
17:51:26 <dons> SamB, test it. let me  know if it doesn't work. just try resizing, or hitting ^L.
17:51:30 <dons> both should be ok.
17:51:32 <wilx> I have never seen it together...
17:51:40 <dons> wilx, yeah, that rings a bell
17:51:57 <SamB> oh cool
17:52:22 <SamB> wow, neat, resizing
17:52:59 <dons> good good :)
17:54:06 <dons> there's just a signal handler tha calls refresh if SIGWINCH is delivered. easy.
17:54:46 <SamB> and what was the trouble?
17:55:16 <dons> I hadn't implemented this code.
17:55:26 <dons> oh, you mean with 'meta' ?
17:55:34 <SamB> oh
17:55:57 <dons> that's just a cosmetic change, to use a wrapper over c_meta :: CInt -> , to use meta :: Bool -> 
17:56:23 <SamB> and curses doesn't install a signal handler automatically?
17:57:02 <dons> nope, not sure how it could.
17:57:20 <dons> it doesn't really make sense to.
17:57:46 <SamB> well, I guess I didn't know ^L produced SIGWINCH
17:58:41 <dons> on some terms it does, depending on the value of keypad,  think
17:58:52 <Xianianol> Is there any way to convert a string into a list of char ?
17:59:02 <wilx> It is exactly that.
17:59:06 <Xianianol> That is, thru a function that is already defined.
17:59:17 <dons> the function is called 'id' ;)
18:00:02 <Xianianol> Doesn't that just outputs the string ?
18:00:19 <wilx> Xianianol, String is defined as type String = [Char]
18:01:02 <dons> @type "haskell"
18:01:03 <lambdabot> [Char]
18:01:22 <Xianianol> Humm...Then I wonder why it is not accepting...
18:01:30 * SamB laughs
18:02:07 <Xianianol> I've defined a Data as a String, using it as a input for another function it complaints that it is not in form [Char]
18:02:20 <SamB> Xianianol: hmm?
18:02:32 <dons> how have you defined 'Data' ?
18:02:33 <SamB> lisppaste2: help
18:02:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:02:50 <Xianianol> data Expr = Nat Int | Expr :+ Expr | Expr :* Expr | Var String
18:03:01 <SamB> ah
18:03:26 <SamB> you probably need to do a pattern match
18:03:41 <Xianianol> Humm, I am using parsers.
18:04:09 <SamB> not that kind
18:04:19 <Xianianol> My parsers accepts strings just fine, but it seems that somehow Expr is not [Char].
18:04:37 <SamB> well yeah
18:04:47 <SamB> its an algebraic data type
18:05:42 <Xianianol> humm..
18:05:52 <SamB> paste your code code somewhere?
18:06:25 <mentomorph> good day/night/morning! How can I convert from Integer to Int ?
18:06:29 <Xianianol> Well, it is waaaay too complicated to read it, and...I rather not ;) Thanks for the help anyway.
18:06:34 <SamB> fromIntegral
18:06:37 <SamB> or fromInteger
18:06:45 <mentomorph> k
18:06:46 <mentomorph> thx
18:08:04 <jeffno> Are there any IDEs that support stuff like code completion?  I tried the Eclipse plugin and its pretty primitive (though a good start).
18:08:16 <SamB> not really
18:08:25 <SamB> I mean, people are working on one
18:08:44 <SamB> but it doesn't hardly work yet
18:08:47 <jeffno> A separate IDE for Haskell, or do you mean the Eclipse plugin?
18:08:55 <SamB> hIDE
18:09:15 <SamB> a special IDE for Haskell, in Haskell
18:09:35 <SamB> maybe Visual Haskell does some of that, dunno
18:10:25 <jeffno> Seems like Eclipse is the way to go.
18:10:31 <mentomorph> uedit32 supports it provided that u expand wordfile.txt with haskell syntax, then u can do ctrl+space and u'll get all the functions and completitions for whatever u're entering
18:12:07 <jeffno> Is that a Windows-only editor?
18:12:27 <mentomorph> I dont know. 
18:12:33 <mentomorph> think so
18:35:39 <mentomorph> oh man I get so blind here when I try to scale a sinus x (Floating Int) to an Int, it just won't compile. (fromInteger(toInteger((sin angle)*fromInteger(toInteger(scaleInt)))) See anything ?
18:38:09 <dons> @type fromInteger
18:38:10 <lambdabot> forall a. (Num a) => Integer -> a
18:38:18 <dons> @type fromIntegral
18:38:19 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:40:40 <Cale> mentomorph: what are you trying to do there?
18:41:05 <Cale> maybe you want  (fromIntegral scaleInt) * (sin angle) ?
18:41:24 <mentomorph> scaleInt is an int
18:41:31 <mentomorph> then it's
18:41:51 <Cale> > (fromIntegral (5 :: Int)) * (sin 0.57)
18:41:53 <lambdabot> 2.6981602436698457
18:41:53 <mentomorph>  (fromIntegral(toInteger(scaleInt)) * (sin angle)) ?
18:41:58 <Cale> no
18:42:02 <Cale> just fromIntegral
18:42:08 <Cale> why toInteger?
18:42:25 <Cale> @type toInteger
18:42:27 <lambdabot> forall a. (Integral a) => a -> Integer
18:42:36 <Cale> @type fromIntegral
18:42:37 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:43:10 <mentomorph> ooooooooooooooooooh
18:43:14 <mentomorph> :D
18:43:19 <Cale> fromIntegral will convert any integral type (like Int, Integer, Word8, etc) to any numeric type (say Double)
18:43:41 <mentomorph> allright, thx for the enlightment
18:44:18 * Cale returns to working on his binding to the enlightenment foundation libraries :)
18:44:43 <mentomorph> :)
18:47:16 <Cale> I'm going to need one of those property list libraries.
18:48:52 <dons> I've put a link to Mun's thesis on the design and implementation of Frag on the Frag page on hawiki, for those interested in Frag.
18:49:40 <dons> how many times can I use the word `Frag' in a sentence?
18:50:02 <Cale> 3
19:03:39 <dash> man why can't haskell write my type declarations for me 
19:03:45 <dash> that would be totally sweet
19:04:23 <Cale> um, it can, sort of
19:04:44 <Cale> you can omit them, at least.
19:04:44 <dash> i mean the "type Foo = ..." and 'data Baz = ..." things
19:04:50 <Cale> ah, okay
19:04:57 <dash> type definitions, perhaps
19:04:58 <Cale> that seems impossible
19:05:18 <dash> aw why would that be impossible
19:05:40 <dash> i have a bunch of functions that return various instances of a type i haven't declared yet
19:05:55 <dash> all it's gotta do is notice that i put the results from all of them into a homogenous collection
19:06:00 <dash> and decide that they're the same type!
19:06:11 <dash> there's gotta be a thesis in there somewhere, or at least a conference paper
19:06:14 <dash> anyway i am trying to break free from my loop-based mentality! and I would like some advice on how to structure some code
19:06:26 <dash> i am parsing SIP messages
19:06:41 <dash> SIP messages have rfc822 style headers of the "Foo: thingies" variety
19:07:05 <Cale> Are you using Parsec?
19:07:11 <dash> indeed i am 
19:07:13 <dash> parsec is love
19:07:26 <dash> you can have two consecutive headers with the same name 
19:08:05 <dash> this is equivalent, for a certain set of headers, to comma separated values in a single header
19:08:06 <dash> so if I have "Foo: yay\r\nFoo: fun"
19:08:13 <dash> that is equivalent to "Foo: yay,fun"
19:08:18 <Cale> okay
19:08:53 <Cale> How are you representing the collection of headers?
19:09:04 <Cale> A map from strings to lists of strings or something?
19:09:20 <dash> given a list of headers (the relevant ones which contain lists of values), and a list of header names for which this property holds
19:09:29 <dash> how would I write a function to normalize this stuff
19:09:34 <Saulzar> Isn't that what tuples and lists are for? Fairly general data types...
19:09:36 <dash> mmm, not strings, they're record types
19:09:44 <Cale> ah, okay
19:09:56 <Cale> so it's more strongly typed
19:10:05 <dash> is that a thing?
19:10:09 <dash> anyway
19:10:22 <Cale> normalize?
19:10:39 <dash> if I have [(Contact ["foo"]), (Contact ["yay", "fun"])]
19:10:58 <dash> I want [(Contact ["yay", "fun", "foo"])]
19:11:21 <dash> the important thing is to preserve ordering and to not disturb the other headers in the list 
19:11:51 <dash> so, some sort of map and fold seems prescribed
19:12:58 <Cale> let (contacts, other) = partition isContact xs in (Contact (concatMap unContact contacts)) : others
19:13:13 <dons> @where SerTH
19:13:14 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/SerTH/
19:13:32 <Cale> where isContact (Contact {}) = True; isContact _ = False; unContact (Contact x) = x
19:15:23 <dash> aha, partition
21:03:10 <Cale> ah, binding marathons :)
21:04:32 <rep> :)
21:08:07 <dons> can you automate it? are you using c2hs?
21:08:18 <Cale> I'm using c2hs
21:08:59 <Cale> Not quite automatic. Currently I'm working on this api: http://enlightenment.sourceforge.net/doxy/imlib2/imlib2_8c.html -- that doesn't quite document everything, but most of it anyway
21:09:29 <Cale> I did an imlib2 binding before, but I'm not completely happy with it, so I'm redoing it with c2hs
21:11:14 <Cale> After that, I'll do a bit of ecore (which looks huge), and then evas, which is a really nice canvas library.
21:14:40 <Cale> actually, I wonder if I should go straight for evas, it would be more fun to play with :)
21:52:13 <palomer> until I got high
