00:00:00 <Speck> those ruby people are so flashy
00:00:14 <paolino> @eval let f (x,y) = (x+1,y+1) ;i f x 0 = x;i f x n = x `seq` i f (f x) (n-1) in i f (0,0) 1000000
00:00:15 <lambdabot> Stack overflow
00:00:22 * ski is interested in if/how various monads works out a little differently in other languages, because of strictness ..
00:00:35 <dons> Cale:
00:00:39 <dons> > map (+1) [1..10]
00:00:40 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
00:01:06 <Cale> dons: hm?
00:01:30 <ski> Cale : '> ' is synonym for '@eval '
00:01:36 <Cale> ah
00:01:42 <Cale> nice :)
00:02:47 <ski> > let f (x,y) = (x+1,y+1) ;i f x 0 = x;i f x n = fst x `seq` snd x `seq` i f (f x) (n-1) in i f (0,0) 1000000
00:02:49 <lambdabot> (1000000,1000000)
00:03:20 <ski> seq on a pair just forces the outer pair structure, not the contents of the pair (in this case integers)
00:03:32 <ski> paolino : ok ?
00:03:49 <paolino> ski it's ugly but yes
00:04:02 <ski> you could consider looking into deepSeq
00:04:28 <ski> that tries to seq all the structure of a value, instead of just the top-level one
00:04:38 <dons> ricebowl, yes I work on ghc. I maintain the OpenBSD ports, and have worked on the C-- backend, amongst other things
00:04:56 <Cale> or use the stuff from Control.Parallel.Strategies, which I think is underrated
00:05:07 <ski> > let f (x,y) = (x+1,y+1) ;i f p 0 = p;i f p@(x,y) n = x `seq` y `seq` i f (f p) (n-1) in i f (0,0) 1000000
00:05:10 <lambdabot> (1000000,1000000)
00:05:14 <ski> paolino : that works too
00:05:20 <dons> ricebowl, how is the windows version built? not sure. ask glasgow-haskell-users@haskell.org
00:05:44 <Cale> > let f (x,y) = (x+1,y+1); i f x 0 = x;i f x n = Control.Parallel.Strategies.rnf x `seq` i f (f x) (n-1) in i f (0,0) 1000000
00:05:45 <lambdabot>  Not in scope: `Control.Parallel.Strategies.rnf'
00:05:59 <dons> oh, maybe that should be in scope.
00:06:28 <Cale> NFData should be made derivable
00:06:57 <Cale> you can use the Data class from generics to do the same thing, but it seems to be many many times slower
00:08:41 <paolino> where is deepSeq ?
00:09:01 <Cale> deepSeq is a library that's floating around -- I could find you an instance of it :)
00:09:35 <dons> there's a copy in lambdabot
00:09:40 <dons> @where lambdabot
00:09:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:09:48 <Cale> It doesn't even seem to do as much as the stuff in Control.Parallel.Strategies does though
00:10:06 <Cale> http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs
00:10:43 <Cale> It's like NFData, where rnf has been renamed to deepSeq
00:11:14 <Cale> and without all the other handy strategy combinators
00:11:40 <Cale> That library seriously needs better documentation though
00:13:39 <paolino> there is where dynamic languages are good for ....
00:13:41 <Cale> also, the Assoc type should be removed from that (or at least not exported), as iirc, it was simply an example from the paper
00:13:53 <Cale> paolino: hm?
00:14:01 <Cale> dynamic in what sense?
00:14:59 <paolino> functions working on quack duck structures
00:15:04 <Cale> Control.Parallel.Strategies is well documented in the paper, but poorly documented in the hierarchical libraries docs.
00:15:18 <Cale> what?
00:16:04 <paolino> looks like deepSeq tries to be useful on all kinds of structures
00:16:15 <Cale> yeah
00:16:42 <Cale> You could write a general instance of that sort of thing with Data.Generics, but it's slower
00:16:43 <paolino> but I suppose I can invent one which doesn't fall in the contemplated cases
00:17:00 <Cale> NFData has more instances and does the same thing
00:17:25 <Cale> But I *really* think that NFData should be made derivable for a wide collection of types.
00:17:34 <Cale> (if not automatically derived)
00:17:55 <paolino> I'm just astonished python is as fast as haskell in my codings
00:18:12 <paolino> I was hoping to gain a lot switching
00:19:20 <vegai> CPUs are so fast these days that for many applications, you won't see any speed difference between languages
00:19:32 <Cale> and Haskell implementations aren't generally known for the speed of the code they generate.
00:19:39 <paolino> well it's more gain on the mental analysis anyway, which I'm pleased
00:19:46 <Cale> :)
00:20:09 <ricebowl> vegai - that's not really true, but with HLLs it's difficult to separate compiler deficiencies from programmer deficiencies
00:20:30 <paolino> I hope I can use Ocaml after learning some haskell
00:20:37 <ricebowl> Java people say they get to about 1/2 the speed of C/C++
00:20:41 <ricebowl> not that that means much.
00:20:46 <C-Keen> moin. timeforcoffee.
00:21:01 <ricebowl> and Python is renowned for being one of the slowest languages ever created, although presumably this is from deficiencies in the interpreter
00:21:14 <vegai> I get 0% the speed of C when I write Java
00:21:19 <basti_> ricebowl: i'm certain that matlab scripts are -way- slower
00:21:29 <ricebowl> haha that's probably true ;)
00:21:37 <vegai> ...because the environment makes me vomit and I go do something else instead
00:21:49 <ricebowl> only the environment?
00:22:00 <vegai> the whole shebang
00:22:05 <ricebowl> I end up getting pissed off that it takes 1,000 lines of Java to do the equivalent work of like 5 lines of Haskell and 50 lines of C.
00:22:09 <neologism> basti_: I think they've made some progress in matlab recently ;)
00:22:26 <paolino> ricebowl, i think the problem with python is the unboxing, which seems to happen here also
00:22:34 <Cale> If you can write your program in a week as opposed to a month, it can run for the rest of the month which you would have spent writing code in the other language.
00:22:38 <basti_> neologism: i don't really see that... ;)
00:22:47 <ricebowl> paolino - FWIW, I read that in certain cases CAML was faster than C.
00:23:05 <ricebowl> I'd like to know which cases since I suspect it has more to do with that good code/bad code thing.
00:23:16 <ricebowl> but it is said that ML can be very fast, at least.
00:23:35 <ricebowl> Cale - depends on how often you use the program
00:23:40 <ricebowl> there are no absolutes in engineering
00:23:42 <neologism> basti_: there's some JIT or something like that iirc
00:23:56 <basti_> i see
00:24:04 <basti_> it doesn't work on my version of matlab
00:24:06 <basti_> ^^
00:24:07 <ricebowl> if writing a program that is 2x slower requires you to double the number of servers you have, then spending another month optimizing it might save you $$
00:24:22 <ricebowl> but it depends entirely on the application and the userbase
00:24:53 <Cale> of course
00:25:17 <Speck> and how the programmer is paid
00:25:38 <Cale> At a certain point, high level languages become easier to optimise too. You have more semantic information about what the code is doing, and can apply stronger techniques to rewrite it in an appropriate way for the hardware. This hasn't been done too much yet, but I've worked on a project which is going to do it, and you can see examples in things like FFTW of the kind of optimisations that are possible.
00:25:42 <Speck> by the hour? java
00:25:47 <ricebowl> Cale - the perfect example that I can think of: if C/C++ compilers did not generate such poor code, the total amount of disk space on my system occupied by binaries could be cut to between 1/2 or 1/3 of what it is now saving me more than 1GB of disk space.
00:26:05 <ricebowl> Cale - yes, that is true *in theory*, but I have yet to see it be true in practice
00:26:39 <ricebowl> I think it quickly becomes a grossly complex problem, one of those NP Complete beasts.
00:26:49 <Cale> Have you looked at FFTW? Also, I worked on a project called Coconut at McMaster university which is designing a high level programming language for signal processing tasks
00:26:49 <ricebowl> but certainly you can optimize certain patterns
00:26:58 <ricebowl> nope, I haven't
00:28:03 <Cale> The compiler is being written in Haskell - I wrote a pipeline scheduler for PPC + Altivec. We scheduled some code for generating sine-cosine pairs, and got it to 2.7 clocks/float
00:28:15 <ricebowl> pretty cool
00:28:24 <ricebowl> but that's an easy-to-solve problem :p
00:28:43 <Cale> well, that's a component :)
00:29:17 <ricebowl> it's pretty basic. Any C/C++ compiler will do the same thing, albeit not necessarily optimally since people are in general more concerned with other factors.
00:30:52 <Cale> That was the lowest level part of the compiler of course. Higher up levels would have other mechanisms for rewriting code in terms of lower level parts. Really, it's a language at multiple levels. You might want to plug in some hand tuned assembly, specify what it computes, and let the compiler sort out when to apply it.
00:31:06 <ricebowl> solve the reference analysis problem for imperative languages and I'll be impressed ;)
00:31:09 <Cale> So it's like a stack of languages, with a searching algorithm
00:32:36 <ricebowl> well, I'll be honest: I don't see how that changes anything :/
00:32:58 <vegai> perhaps we should clone a huge pack of Alan Turings and others. One of them could come up with some kind of an ultimate optimization theory.
00:33:22 <ricebowl> low-level optimizations have been heavily researched, and the only research which really adds up to anything ends up being heuristical
00:33:42 <ricebowl> "We found that if we do X, Y, and Z, then on an average piece of C++ code the performance increases N%.
00:34:14 <ricebowl> they're all micro-optimizations which ultimately waste programmer time
00:34:17 <vegai> I'm thinking something along the lines of "by using this algorithm, every computer program can be optimized to its simplest form"
00:34:25 <ricebowl> at the high-level it's even more difficult.
00:34:42 <paolino> Cale seq 'ing makes code 1.3 faster
00:34:55 <Cale> paolino: great :)
00:34:57 <Cale> Well, I can make some guarantees about the kind of optimisations I was doing.
00:35:21 <paolino> 1.6 actually
00:35:40 <Cale> My program would eventually find an optimal schedule for the code (though it actually produced a lazy list of schedules from greedy to less greedy)
00:36:35 <Cale> and the way that we did it, I could even probably make some guarantees about the schedules found near the start of the list
00:36:53 <paolino> Cale :great ?
00:37:06 <Cale> well, it's a speedup at least :)
00:37:25 <paolino> It sounds bad to me, longer ==> faster :(
00:37:42 <Cale> 1.6 faster doesn't mean slower
00:38:14 <paolino> longer the code :)
00:38:23 <pejo> ricebowl, you want alias analysis problem solved. Why not design a reasonable language which avoids the problem instead?
00:38:25 <Cale> oh
00:38:44 <Speck> seq looks interesting... is a beginner's explaination available?
00:39:31 <paolino> seq is the stack sweeper
00:39:43 <Cale> the evaluation of (x `seq` y) forces the evaluation of x just far enough to determine the data constructor used in x, and then gives the result y (which is evaluated as much as it would be otherwise)
00:39:58 <Cale> so for example
00:40:07 <Cale> x `seq` f x
00:40:20 <Cale> this evaluates x a bit before passing it on to f
00:40:26 <pejo> ricebowl, as for NP-completeness - instruction scheduling and register allocation are NPC too, yet it seems rather practical of today if you just can use some (commercial) 3rd party software to solve the problems.
00:40:33 <Speck> Cale: ah i see
00:40:42 <neologism> Cale: how this speeds up the code?
00:40:56 <Cale> but that's not quite the same as a strict language, since it's just to the first constructor
00:41:04 <ricebowl> pejo - it isn't possible to avoid the problem unless you don't permit references/pointers
00:41:07 <Cale> neologism: better memory usage when folding usually
00:41:11 <ricebowl> which makes it difficult to program anything interesting
00:41:19 <Cale> say you have a list that you want to sum
00:41:23 <Cale> [1,2,3]
00:41:28 <ricebowl> also, it has a twin sister problem which involves avoiding copying.
00:41:37 <Speck> Cale: so f $! x is like strict evaluation? (and equivalent to the example you gave)
00:41:47 <Cale> Speck: almost like strict evaluation
00:41:49 <ricebowl> pejo - indeed, register allocators are heuristical
00:42:00 <Speck> call-by-value instead of call-by-need?
00:42:11 <ricebowl> except in the case that all actives can map onto registers, which is rare-to-never
00:42:12 <Cale> but not quite, since x won't necessarily be fully evaluated, only the top level data constructor in x will be
00:42:28 <Cale> for example, if x is a list
00:42:57 <Cale> then that means that whether x is of the form (x:xs) or [] will be determined
00:43:08 <ricebowl> pejo - the point is that low-level imperative languages can't even be optimally mapped onto the hardware. Compilers do a "good" job, but nobody has studied *exactly* how close they come to "optimal"
00:43:42 <ricebowl> and I am asserting, based on my experience and having seen a lot of really, really bad C++ code, that C/C++ compilers aren't really as close as we would hope.
00:43:58 <Speck> Cale: gotcha... but wouldn't the pattern match be reduced away anyway?
00:44:10 <ricebowl> the point in talking about them is that HLLs are *worse*, even though they shouldn't be.
00:44:18 <Cale> Speck: possibly, if f does pattern patching
00:44:26 <Cale> matching*
00:44:45 <Speck> I just don't know enough about how haskell manipulates programs to really see the benefit
00:44:47 <Cale> if x is an integer, then it's fully determined
00:44:58 <Cale> like strict evaluation
00:45:11 <Cale> also, consider this function:
00:45:22 <neologism> Cale: what did you want to say with the [1,2,3] sum?
00:45:30 <Cale> oh
00:45:31 <Cale> yeah
00:45:48 <Cale> say you write foldr (+) 0 [1,2,3]
00:45:58 <Cale> what happens?
00:46:10 <Speck> > foldr (+) 0 [1,2,3]
00:46:11 <lambdabot> 6
00:46:50 <pejo> ricebowl, copying might be a problem, yeah. But you slide over to products when talking c++-compilers, and for those "good enough" is more reasonable. Perfect is the enemy of good. (But I find optimal stuff intriguing, personally).
00:46:52 <Cale> well, when that's evaluated, foldr pushes its way through the list and you get a bunch of transformations like 1 + (foldr (+) 0 [2,3])
00:47:01 <Speck> right
00:47:05 <Cale> 1 + (2 + (foldr (+) 0 [3]))
00:47:14 <Cale> 1 + (2 + (3 + 0))
00:47:21 <ricebowl> pejo - as do I
00:47:21 <Cale> *then* the sum is evaluated
00:47:33 <ricebowl> pejo - compilers are the one piece of software that can never improve too much
00:47:34 <Cale> 1 + (2 + 3)
00:47:38 <Cale> 1 + 5
00:47:39 <Cale> 6
00:47:46 <Speck> I dig
00:47:47 <ricebowl> and the wonderful thing about compilers is that a small improvement in size or speed affects all other software...
00:47:54 <Cale> the intermediate expressions can take a lot of space
00:48:06 <ricebowl> @type seq
00:48:07 <lambdabot> forall b a. a -> b -> b
00:48:19 <Speck> assuming the compiler doesn't optimize it away
00:48:22 <ricebowl> hm, it throws away the result of the first expression?
00:48:23 <Cale> if the list was 1000000 elements long, you're going to get intermediate expressions 1000000 elements long too
00:48:47 <Cale> ricebowl: it forces the evaluation of the first expression, then returns the result of the second
00:48:50 <pejo> ricebowl, no, only software which fulfill the constraints imposed by the optimization. If you can guarantee there aren't any alias problems in your C software it's easy to make lots of optimizations.
00:49:07 <neologism> Cale: so how the seq optimizes this sum?
00:49:11 <ricebowl> Cale - example? I can't see how it would be useful like that.
00:49:16 <neologism> nor me ;)
00:49:17 <ricebowl> maybe something like seq x x*y?
00:49:24 <Cale> ricebowl: yeah
00:49:28 <ricebowl> basically where a is a sub-expression in b
00:49:40 <Cale> yeah
00:49:46 <Cale> generally :)
00:49:54 <Cale> also, x `seq` x has no effect
00:50:03 <neologism> show us the example
00:50:05 <ricebowl> (\x -> seq x x) would effectively evaluate its argument and return the evaluated result?
00:50:26 <Cale> (\x -> seq x x) is the same as id
00:50:26 <ricebowl> pejo - right, but that's what I was referring to when I said the "aliasing problem"
00:50:42 <ricebowl> Cale - except it should evaluate x, no?
00:50:52 <Cale> not until seq x x is evaluated
00:51:00 <ricebowl> bleh.
00:51:19 <Cale> so it's a relatively small amount of evaluation
00:51:31 <neologism> so.. how the sum looks like with the seq used?
00:51:34 <ricebowl> yeah, like 0.
00:51:44 <Cale> well, in that case, yes
00:53:05 <Cale> okay
00:53:38 <Cale> well, in a strict language, you normally get some benefit out of writing sum with foldl
00:53:47 <Cale> because foldl is tail recursive
00:54:04 <Cale> and thus can be implemented with a loop
00:54:30 <Cale> but here, the loop just builds a huge expression datastructure
00:54:36 <Cale> and we lose the benefit
00:54:58 <Cale> but if we make things a bit stricter with seq, it's all good again
00:55:56 <ricebowl> *nods*
00:57:16 <Cale> foldl' f a [] = a
00:58:04 <Cale> foldl' f a (x:xs) = (foldl' f $! f a x) xs
00:58:23 <Cale> where f $! x = x `seq` f x
00:58:52 <Cale> so
00:59:09 <Speck> so... the f a x part is evaluated partially
00:59:14 <Cale> right
00:59:19 <Cale> in this case, totally
00:59:24 <Cale> because they're just integers
01:00:41 <Cale> so you get  foldl' (+) 0 [1,2,3] = foldl' (+) (1) [2,3] = foldl' (+) 3 [3] = foldl' (+) 6 [] = 6
01:00:55 <Cale> no huge data structures getting built up
01:01:05 <Cale> the list just gets eaten
01:01:08 <Speck> neat
01:01:23 <Speck> now I just need to wait for a moment to useit
01:01:32 <Speck> maybe parsing something
01:01:43 <Speck> like this 3 gigs of census data I have on my hdd
01:02:08 <Cale> usually, you only use it when you're having trouble with code performance
01:02:23 <paolino> *Fern> foldl (+) 0 [1..1000000]
01:02:24 <paolino> *** Exception: stack overflow
01:02:24 <paolino> *Fern> foldl' (+) 0 [1..1000000]
01:02:24 <paolino> 500000500000
01:02:33 <Cale> yes :)
01:02:45 <Speck> the function application of (f a x) binds before the f $! ... part right?
01:02:49 <Cale> yeah
01:02:59 <Cale> $! has low precedence just like $
01:03:14 <Speck> right
01:03:22 <Cale> I'll show what happens with foldl
01:03:54 <dons> more icfp photos: WolfgangT winning : http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1634.JPG
01:04:17 <dons> and the award: http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1630.JPG
01:04:47 <Cale> foldl (+) 0 [1,2,3] = foldl (+) (0 + 1) [2,3] = foldl (+) ((0+1)+2) [3] = foldl (+) (((0+1)+2)+3) [] = (((0+1)+2)+3) = (1 + 2) + 3 = 3 + 3 = 6
01:04:55 <Speck> oh boy, pictures of discriminating programmers
01:05:10 <Speck> Cale: gotcha
01:05:37 <dons> hehe scroll up for links to spj and autrijus, and Igloo and David roundy
01:06:10 <Cale> yep, that's Wolfgang (in the green)
01:07:19 <paolino> foldl is a little faster than foldl'
01:07:36 <neologism> hm.. :set +s in hugs shows no improvement in use of foldl' over foldl
01:07:38 <Cale> Oh? It shouldn't be really.
01:07:52 <paolino> it is
01:08:00 <neologism> its worse in fact
01:08:07 <Cale> foldl' should produce much better results in terms of memory consumption at least
01:08:12 <neologism> X> f1 [1..10000]
01:08:12 <neologism> 50005000
01:08:12 <neologism> (160047 reductions, 245074 cells)
01:08:12 <neologism> X> f2 [1..10000]
01:08:12 <neologism> 50005000
01:08:14 <neologism> (180047 reductions, 275074 cells)
01:08:20 <neologism> f1 uses foldl f2 uses foldl'
01:08:30 <Cale> oh, yes, there will be more reductions
01:08:42 <neologism> it takes more cells as well
01:08:46 <paolino> sure foldl crashes
01:08:50 <Cale> and overall use of cells
01:08:59 <Cale> but at any one point in time, it will use fewer cells
01:09:05 <paolino> :P
01:09:09 <neologism> ah :)
01:09:43 <Cale> because you have those extra seq cells that need to be evaluated at some point, but they prevent things from exploding
01:09:58 <Cale> and allow old structures to get thrown away faster
01:11:00 <Cale> together with compiler optimisations, foldl' should be much faster than foldl
01:11:06 <paolino> thrown away . Foldl cannot
01:12:12 <neologism> Cale: so why not using only foldl' ?
01:12:16 <neologism> whats the disadvantage?
01:12:23 <Cale> neologism: because it breaks laziness
01:12:51 <Cale> also, left folds on lists are much less natural in a certain sense
01:13:18 <Cale> foldl' will force the whole list to be evaluated right away
01:13:25 <Cale> maybe you don't want to do that
01:13:49 <Cale> consider foldr (\x xs -> f x : xs) [] = map f
01:14:11 <Cale> if that was written with foldl', then any map over a list would force the evaluation of the whole list
01:14:31 <Cale> not to mention, it would be more awkward to write
01:15:22 <Cale> (there are plenty of times in idiomatic Haskell programming where you really don't want to force things to be strict
01:15:23 <Cale> )
01:15:49 <Cale> There are two ways to optimise a Haskell program: Make it stricter, or make it lazier.
01:16:02 <neologism> :)
01:16:34 <Cale> If you can reduce data dependencies, so that a smaller portion of the input needs to be observed in order to produce some of the output, this will help things a lot.
01:16:44 <Cale> (that's the make it lazier approach)
01:17:35 <Cale> When you absolutely can't do that, (you need to fold the whole thing down to a single value), you use seq and other strictness annotations.
01:19:03 <ricebowl> argh :|
01:19:05 <Cale> When seq is too small scale, you use Control.Parallel.Strategies (or lookalikes)
01:19:20 <ricebowl> I have IO (Int, Int) and IO [(Int, Int)] and I want to cons my first pair onto the list of pairs... :p
01:19:35 <Cale> liftM2 (:)
01:19:52 <Cale> or,
01:20:06 <ricebowl> hm
01:20:10 <Cale> do { x <- ioPair; xs <- ioPairs; return (x:xs)
01:20:11 <Cale> }
01:20:12 <dons> though another way can be to compres the data
01:20:13 <ricebowl> that makes sense
01:20:29 <ricebowl> working with monads is coming, though slowly :/
01:25:16 <ski> @type Control.Monad.liftM2 (:)
01:25:17 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
01:26:03 <Cale> I wonder if the efforts of genetic engineering will eventually generalise pears to tupples.
01:30:36 <Cale> http://vx.hn.org/autoshare/foldr.png -- a good reason to like foldr is expressed by this picture
01:33:24 <mauke> I have a question about http://rafb.net/paste/results/3HdX3b77.html
01:33:49 <mauke> this code comes from a C# program I converted to Haskell
01:34:11 <Cale> okay :)
01:34:22 <mauke> is xfold really a fold? or hmm, what's the definition of a fold?
01:34:28 <Cale> yes
01:35:00 <mauke> is there a better way of writing this?
01:35:03 <Cale> Well, it's a catamorphism for that type
01:35:20 <Cale> you could write it more directly just pattern matching
01:35:39 <earthy> actually, this is not ba
01:35:42 <earthy> +d
01:35:44 <Cale> yeah
01:35:50 <Cale> it's pretty well-written
01:36:14 <earthy> is that where style legal haskell?
01:36:27 <earthy> (probably :))
01:36:56 <earthy> but for style I'd put the where on the next line, as it makes quite clear that it is not part of the value
01:37:06 <earthy> anyway, what is the question, mauke?
01:37:17 <Cale> just about folding
01:37:59 <Cale> A catamorphism is generally a function which replaces each of the constructors in a data structure with a function
01:38:14 <earthy> i.e. a generalized fold. :)
01:38:15 <kosmikus> well, xfold does not capture the recursion
01:38:16 <Cale> (in a systematic way)
01:38:26 <Cale> oh
01:38:29 <Cale> yes, I missed that
01:39:01 <Cale> Sum a b -> fc (xfold fn fv fc a) (xfold fn fv fc b)
01:39:04 <earthy> yeah, it'd need to be fc (xfold fn fv fc a) (xfold fn fv fc a)
01:39:35 <mauke> ah
01:39:36 <Cale> this would save trouble in substVars
01:39:42 <earthy> otherwise the code is neat and tidy
01:39:49 <kosmikus> then you can remove the recursive calls from your "combine" definitions
01:39:53 <mauke> yeah
01:40:55 <Cale> and evalExpr = xfold id undefined (+)
01:42:15 <mauke> aw, wikipedia doesn't have an article on "Catamorphism"
01:42:20 <Cale> I wonder how hard it would be to write a TH program to generate the fold for a given type.
01:44:19 <mauke> Cale: wouldn't I have to duplicate the "fn fv fc" part with pattern matching?
01:44:41 <earthy> http://www.program-transformation.org/Transform/CataMorphism
01:44:55 <Cale> well, yeah -- you wouldn't get the nice concise definitions
01:46:52 <Cale> did the C# version of the program have a folding function?
01:47:13 <mauke> well, it was called ExecuteAlgorithm
01:47:38 <gour> dcoutts
01:47:40 <mauke> and it took an object, not a bunch of functions
01:47:46 <gour> dcoutts: ping
01:48:04 <Cale> how long was the C# code? :)
01:48:11 <basti_> Cale: why does gtk2hs crash when i setGCValues?
01:48:28 <Cale> basti_: no idea -- I'm just a gtk2hs user
01:48:51 <Cale> I'll have a look at what the docs say about that
01:48:52 <basti_> do you never use that function?
01:48:55 <mauke> Cale: hmm, 150 <= n <= 300 lines, I'd say
01:49:09 <Cale> basti_: I don't think I've ever used that function
01:49:12 <basti_> hmm
01:49:23 <basti_> so youre just using the existing widgets yes?
01:49:29 <Cale> yeah
01:49:38 <Cale> and Cairo
01:49:40 <basti_> i see
01:49:51 <basti_> hmmm
01:50:03 <basti_> maybe i'll use existing widgets too.
01:50:13 <basti_> Do you think it is ok to abuse widgets? ^^
01:50:23 <Cale> well, what are you going to do?
01:50:46 <basti_> well i'm trying to create a musical sequencer. Like "rosegarden" maybe, just not as brittle
01:50:57 <basti_> i'm looking for a possibility to make a "piano roll"
01:51:22 <basti_> http://www.all-day-breakfast.com/rosegarden/r21-seq-large.gif < like the window in the front here
01:51:36 <Cale> where in Gtk2Hs is setGCValues?
01:51:48 <basti_> Graphics.UI.Gtk.Gdk.GC
01:51:53 <basti_> oops its gcSetValues
01:52:27 <basti_> i can even try to set the old values, it breaks just in the moment i'm doing that. With an X error even!
01:52:41 <Cale> what's the X error?
01:52:48 <basti_> mm wait
01:53:44 <basti_> lisppaste2: @url
01:53:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:54:41 <lisppaste2> basti_ pasted "gcSetValue" at http://paste.lisp.org/display/13297
01:54:45 <basti_> there
01:55:08 <basti_> maybe gcNew is wrong?
01:55:30 <Cale> hmm
01:57:44 <basti_> castToGC could do what i want, but I don't see how to use it
02:00:06 <jlouis> morning
02:00:20 <Cale> ask dcoutts, as I'm not really sure
02:00:25 <basti_> ok
02:08:15 <ski> Cale : possibly ExecuteAlgorithm was a "Visitor pattern"
02:08:30 <Cale> ski: yeah, I was thinking that
02:09:37 <Cale> It's too bad that there's no way to type folds in general.
02:09:55 <ski> type ?
02:10:26 <ski> cata :: Functor f => (f r -> r) -> (Rec f -> r)
02:10:27 <ski> ?
02:10:34 <Cale> hmm
02:11:04 <Cale> I suppose that works, but it's not terribly elegant :)
02:11:07 <ski> data Rec f = In {out :: f (Rec f)}
02:11:12 <Cale> yeah
02:11:34 <Cale> hmm...
02:11:35 <ski> cata phi = phi . map (cata phi) . out
02:11:51 <ski> one could possibly have
02:11:56 <Cale> I wonder if you could rig up something more direct with functional dependencies.
02:12:17 <ski> class RecursiveWrap a f | f -> a
02:12:20 <ski>   where
02:12:28 <ski>   wrap :: f a -> a
02:12:35 <ski>   unwrap :: a -> f a
02:18:05 <ski> hm, possibly add 'Functor f =>' to that class
02:18:44 <ski> cata :: RecursiveWrap a f => (f r -> r) -> (a -> r)
02:18:56 <ski> cata phi = phi . map (cata phi) . unwrap
02:19:45 <ski> (in the class, f determines a up to isomorphism, but a does not determine f (not even upto iso))
02:28:09 <dcoutts> basti_, I can reproduce that bug. I'll look into it. However you can certainly use things like: gcSetValues gc newGCValues { forground = ... }
02:29:48 <pejo> dcoutts, ping! (You told me to ping you regarding PE a while ago).
02:30:50 <araujo> Morning!
02:31:03 <jlouis> SamB: all applied
02:31:06 * araujo reading about category theory
02:31:30 <jlouis> araujo: Cat. Theory is fun!
02:31:56 <araujo> jlouis, yeah,  i am realizing that :-)
02:32:17 <jlouis> And that Conjure repository is HOT! ... over the weekend we have more than 70 patches ;)
02:32:28 <araujo> It is also giving me the impression that for serious haskell hacking you also need to understand it.
02:33:11 <dcoutts> pejo, oh :-)
02:33:17 <dons> jlouis! cool :)
02:33:29 <dons> @karma+ jlouis
02:33:29 <lambdabot> jlouis's karma raised to 1.
02:33:40 <dons> jlouis, how many contributors?
02:34:08 * dons darcs pulls to check
02:34:17 <dcoutts> gour, pong
02:35:54 <gour> dcoutts: hi, i'm steadly finding gnome replacements for my kde apps :-)
02:36:04 <dcoutts> good good
02:36:21 <gour> dcoutts: latest is akregator --> lifearea
02:36:40 <jlouis> dons: about 3: xerox, SamB and shapr
02:36:46 <jlouis> beside the insanity thats me
02:36:49 <gour> dcoutts: i canvassed xchat-gnome devs to add notication (osd) and now it's there
02:36:51 <jlouis> @where conjure
02:36:52 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
02:37:04 <gour> dcoutts: have you read http://funkyshizzle.com/?q=node/117
02:37:33 <gour> dcouttss: good points which i experience myself
02:41:28 <gour> dcoutts: i was also thinking to make some intermediate release(s) for gtk2hs and have a cabal build ready for 1.0?
02:42:44 <ski> jlouis : Conjure ?
02:42:47 <ski> ah
02:43:05 * ski oughtta read faster than he types
02:45:19 <jlouis> ski: typing faster than you read is much more offending
02:45:24 <boegel> shapr: ping !
02:46:11 <gour> jlouis: well depends on reading too :-)
02:47:43 <dcoutts> gour, well that'll depend on getting gtk2hs to use the mainline c2hs and getting some improvements into Cabal
02:50:05 <gour> dcoutts: in any case it is, imho, worth route to explore
02:50:36 <gour> dcoutts: more easy to install - more users will atract
02:51:28 <gour> dcoutts: simplicity is very high (sublime) quality one can possess
02:52:49 <dcoutts> gour, certainly we want to move to use Cabal but it'll take some work. I'm not sure if it'll be part of the 1.0 schedule.
02:53:06 <dcoutts> also, I expect it'd be rather destabalising
02:53:22 <gour> dcoutts: that's why i'm thinking about some intermediate release
02:53:32 <dcoutts> it might be better to do a 1.0 release with the current build system which is well tested on many platforms
02:53:53 <dcoutts> and then move to a more experimental build system after 1.0
02:54:03 <gour> 2.0 branch ?
02:54:37 <dcoutts> gour, well intermediate releases is fine but there is quite a bit to do to get Cabal and gtk2hs/c2hs ready.
02:55:01 <dcoutts> yes, I imagine a new branch after 1.0
02:55:37 <gour> yes, then it is better to have 1.0 sooner
02:55:38 <dcoutts> we'd support 1.0 with bug fixes etc but there are some improvements we should make that would not be backwards compatible.
02:55:55 <gour> e.g. ?
02:56:01 <dcoutts> namespace issues
02:56:30 <dcoutts> we'd like Gtk.Widget.blah rather than Gtk.widgetBlah
02:56:49 <dcoutts> and I'd like uniform constructors with attributes
02:56:58 <gour> and what about ghc-namespaces support?
02:57:05 <gour> some change on horizon?
02:57:07 <dcoutts> eg Button.new [ label := "blah" ]
02:57:53 <dcoutts> not yet but we could bring the issue up again for the Haskell '06 discussions
03:00:53 <gour> dcoutts: wxhaskell is stalled a bit?
03:05:41 <araujo> lambdabot, help?
03:05:48 <araujo> lambdabot, @help
03:05:49 <lambdabot>  @help <command> - ask for help for <command>
03:05:55 <dcoutts> gour, yeah, it seems so
03:06:02 <araujo> lambdabot, @paste
03:06:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:07:06 <dcoutts> basti_, yeah, it was a bug. Fixed now in darcs. You can workaround it by useing "gcSetValues gc newGCValues { ... }" and only setting specific members. That's more effecient anyway.
03:07:16 <lisppaste2> araujo pasted "split" at http://paste.lisp.org/display/13302
03:07:25 <araujo> What's wrong with it'
03:08:08 <ski> Ord implies Eq, so you don
03:08:16 <ski> don't need to mention Eq
03:09:04 <araujo> ski, That's all?
03:09:11 <ski> prolly not :)
03:09:20 <ski> what is splitInto supposed to do ?
03:09:35 <ski> splitUpInto*
03:09:58 <araujo> "foo . bar" = ["foo" , "bar"]
03:10:17 <ski> @eval break odd [1,3,5,6,7,9]
03:10:18 <lambdabot> ([],[1,3,5,6,7,9])
03:10:23 <araujo> f '.' "foo . bar" = ["foo" , "bar"]
03:10:24 <ski> @eval break even [1,3,5,6,7,9]
03:10:25 <lambdabot> ([1,3,5],[6,7,9])
03:10:35 <eivuokko> a -> [a] -> [[a]] ?
03:11:09 <ski> yes, that seems like the right types
03:11:30 <araujo> eivuokko, That was it!
03:11:32 <araujo> Thanks
03:11:46 <ski> m, yes
03:11:48 <araujo> Geez... couldn't see that
03:20:51 <dcoutts> xerox, any suggestion on this? : https://sourceforge.net/tracker/?func=detail&atid=455426&aid=1350152&group_id=49207
03:21:01 <ricebowl> is there any way to construct a matrix besides an array of arrays?
03:21:16 <dcoutts> ricebowl, a 2D array
03:21:35 <dcoutts> Array (Int, Int) Double
03:21:36 <ricebowl> yes, and what's the syntax or module or whatever...?
03:21:39 <ricebowl> oh!
03:21:42 <ricebowl> I see. Thanks!
03:21:49 <dcoutts> yo just use a pair as the index type
03:21:55 <dcoutts> or a triple, etc
03:22:03 <dcoutts> you can define your own index types
03:22:15 <dcoutts> see the Ix class
03:33:04 <rafl> dons: ping
03:34:24 * ski wonders why that DeepSeq.hs does like "instance DeepSeq Bool where", etc
03:34:34 <ski> (i.e. why "where" ?)
03:35:11 <dcoutts> the where is superfluous in that case since there is no body the instance definition
03:35:52 <Igloo> It's not actually wrong, though
03:36:19 <ski> m, yes
03:36:36 <dons> rafl?
03:40:04 <rafl> dons: Could you please take a look at this? http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=337868
03:40:52 <dons> hmm. does ghci even work on alpha?
03:41:03 <dons> I doubt hs-plugins would work on alpha anyway
03:41:04 <Igloo> No
03:41:34 <dons> anyway, this bug would be fixed in the -current hs-plugins, as we just use Cabal now
03:42:03 <dons> so, in summary, fixed in darcs. and won't run on alpha anyway
03:43:24 <dons> rafl, perhaps try the darcs version on alpha, just so you can confirm that it won't work (it should fail at runtime)
03:43:51 <rafl> dons: OK. Will do that.
03:59:46 <ctrlsoft> Any c2hs experts here? I'm trying to get something like {#pointer *struct ldb_context as Context newtype#} to work, but it doesn't seem to like the 'struct' tag
04:02:22 <dcoutts> ctrlsoft, I don't think you say struct.
04:02:24 <dcoutts> check the docs
04:02:53 <dcoutts> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-3.html#ss3.10
04:03:27 <ctrlsoft> Yeah, tried that as well - removing the 'struct' tag doesn't fix it - only adding a typedef does
04:04:00 <dcoutts> right
04:04:04 <ctrlsoft> but unfortunately that requires me to change the headers to use a typedef
04:04:44 <ctrlsoft> and I'd rather use upstream rather then my own modified header
04:04:45 <dcoutts> well you can either do that inline in the .chs scritp with #c .. #endc bits or you can make your own header that #hincludes the other one
04:05:05 <dcoutts> so no need to modify the upstream header
04:05:46 <ctrlsoft> no, that doesn't work unfortunately - it doesn't recognize 'struct ldb_context' as being the same thing as my typedef so it doesn't use the {#pointer#} hook whenever 'struct ldb_context' is used
04:05:49 <dcoutts> you could mention on the c2hs mailing list that this is a limitation that it only works for typedefed struct types
04:06:21 <dcoutts> yeah, all the C libs I work with use typedefs consistently
04:06:39 <dcoutts> ask about it on the c2hs mailing list
04:06:45 <ctrlsoft> ok, thanks!
04:09:48 <dons> @where c2hs
04:09:48 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
04:49:17 * jlouis spanks perl
04:50:41 <vegai> jlouis: it likes that.
04:51:57 <frederik> i'm trying to work the exercises in Mac Lane, is there someone else who has done them or is doing them?
04:52:10 <Narrenschiff> Yes, you are merely encouraging it!
04:52:52 <frederik> i'm not sure what a universal arrow to the forgetful functor Rng->Ab (which forgets multiplication) should be
04:53:49 <vegai> Mac Lane?
04:54:56 <frederik> Saunders Mac Lane, "Categories for the Working Mathematician"
04:55:55 <jlouis> frederik: you know what the forgetful functor is, right?
04:56:05 <frederik> yeah
04:56:49 <frederik> of course
04:57:21 <Itkovian> is there a built-in function that yields (takeWhile f xs, dropWhile f xs)?
04:58:05 <jlouis> frederik: doh, I've forgot what an universal arrow is. But it is certainly a definition
05:01:17 <eivuokko> Itkovian, span or break.  They are in prelude.
05:02:08 <Itkovian> all rightie
05:05:12 <frederik> jlouis: the question isn't what the category-theoretic definition is, it's what it corresponds to in algebra. but thanks anyway
05:06:14 <araujo> @index split
05:06:14 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.
05:06:14 <lambdabot> TH.Ppr, System.Random
05:16:10 <shapr> boegel: pong
05:21:03 <jlouis> shapr: pong
05:21:22 <jlouis> Don't pull Conjure. You'll overload
05:21:53 <shapr> ?
05:22:29 <jlouis> Theres about 60 patches this weekend ;)
05:22:38 <shapr> wow
05:22:54 <shapr> I've been distracted by a flu and a gorgeous woman.
05:23:22 <jlouis> The gorgeous woman is ok. But you must postpone the flu. We need your hacking skills ;)
05:23:31 <boegel> shammah: y0w
05:23:44 <shapr> heh
05:24:00 <boegel> shapr: I have a cool (imho) idea for some TMR articles
05:24:11 <shapr> ok, tell me!
05:24:20 <boegel> okay, I meant 'shapr: y0w', sometimes tab completion is a bitch
05:24:41 <boegel> shapr: I was thinking about 'Top ten ******** in the world of Haskell'
05:24:52 <shapr> Like what?
05:25:21 <boegel> stuff like 'most popular applications', 'neatest language features', 'famous people', 'contributors', ...
05:25:46 <boegel> and maybe I could start a thread on haskell(-cafe) to ask people for contributing stuff
05:25:55 <dcoutts> boegel, heh, I like the idea
05:26:01 <boegel> once a month, for some subject
05:26:21 <boegel> and also for suggestions on future subjects
05:26:30 <shapr> Oh that's a neat idea.
05:26:35 <boegel> :)
05:26:37 <dcoutts> so long as it is not taken too seriously and avoids turning into an unpleasent popularity contest
05:26:50 <boegel> oh no, that would never be the intent
05:27:13 <dcoutts> sure, but it's always a danger that one should bear in mind
05:27:21 <dcoutts> just so it can be avoided
05:27:21 <boegel> that's why I'd use the mailing list for info, and then I'd look into it (if I have the time :) )
05:27:43 <boegel> I think it's a great way to get to know the Haskell world
05:27:45 <shapr> I like it!
05:28:06 <boegel> 'most interesting publications', 'funiest jokes', ... :)
05:28:57 <boegel> I also think it might help to make TMR more known... are you getting any feedback on when you release an issue ?
05:30:28 <shapr> I've gotten a few emails.
05:30:34 <shapr> But it doesn't feel like much.
05:30:49 <shapr> I wonder if the apache logs would be more motivational.
05:31:49 <shapr> jlouis: that's a lot of patches.
05:31:51 <boegel> what do you guys think ?
05:32:36 <shapr> boegel: I think it's good, do it!
05:34:36 <boegel> shapr: when are you planning to release a new issue ?
05:34:51 <shapr> As soon as there are enough articles, like always.
05:35:16 <ChrisBrownKent> hello all
05:35:24 <shapr> hiya ChrisBrownKent
05:35:37 <shapr> Are you learning Haskell?
05:35:44 <ChrisBrownKent> can anyone point me to some good tutorials on monads? i need more inetrmediate - advanged stuff
05:35:49 <ChrisBrownKent> I'm always learning haskell!
05:35:56 <dcoutts> ChrisBrownKent, are you the Pivotal chap?
05:36:08 <ChrisBrownKent> I've been on here before - Im researching refactoring functional programs down at kent
05:36:13 <shapr> Oh cool!
05:36:19 <shapr> You're working for Claus Reinke then?
05:36:28 <ChrisBrownKent> no - im working with him
05:36:41 <aheller> mwllllrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr0 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\
05:36:41 <shapr> ah cool
05:36:50 <shapr> aheller: cat on the keyboard?
05:36:51 <aheller> eep!  Cat!
05:36:53 <ChrisBrownKent> actually - he dosnt do much on the project anymore
05:36:53 <aheller> :)
05:37:07 <aheller> shapr: not at home, forgot to close it.
05:37:22 <shapr> I swapped some emails with Claus when the project started. Refactoring is an interest of mine.
05:37:32 <ChrisBrownKent> oh cool!
05:37:41 <shapr> ChrisBrownKent: Anyway, http://www.nomaware.com/monads/ is my favorite monads tutorial.
05:37:57 <ChrisBrownKent> perhaps we should talk! actually I'm more directed towards program slicing at the moment
05:38:02 <ChrisBrownKent> shapr: cheers
05:38:04 <shapr> You'll likely also want to see http://www.haskell.org/hawiki/MonadsAsContainers
05:38:11 <shapr> Like type error slicing?
05:38:32 <ChrisBrownKent> you mean slicing to help find a type error?
05:38:53 <shapr> ChrisBrownKent: http://www.cee.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
05:38:54 <dcoutts> ChrisBrownKent, oh refactoring. We're hoping that we'll be able to make hIDE into a platform that you can plug your refactoring techniques into.
05:38:58 <shapr> And related research
05:39:24 <boegel> shapr: 'Top Ten favourite tutorials'
05:39:33 <shapr> boegel: Oh good idea.
05:39:36 <boegel> shapr: :)
05:39:44 <ChrisBrownKent> yeah not really - its more in the field of program understanding
05:40:05 <dcoutts> ChrisBrownKent, oh and you've worked on syntax directed editing. Nice. That'd be a cool hIDE pluging too. :-)
05:40:21 <boegel> shapr: I neat a name for the series of articles though... and 'Top Ten' seems a bit stupid :) suggestions ?
05:40:23 <ChrisBrownKent> ha! my web page really really needs updating!
05:40:23 <dcoutts> pluging/plugin
05:40:31 <ChrisBrownKent> thanks for those links
05:41:30 <shapr> Have you read the refactoring browser thesis?
05:41:56 * shapr thinks
05:42:05 <ChrisBrownKent> which thesis?
05:43:09 <shapr> Don Roberts and John Brant
05:44:02 <boegel> @index top
05:44:02 <lambdabot> bzzt
05:44:05 <shapr> ChrisBrownKent: This one - http://st-www.cs.uiuc.edu/~droberts/thesis.pdf
05:44:10 <boegel> @index ten
05:44:10 <lambdabot> bzzt
05:44:38 <ChrisBrownKent> no - thats something I havnt read, cheers
05:44:47 <shapr> It's good stuff.
05:45:02 <ChrisBrownKent> i dont think i have anyway
05:45:46 <boegel> @index first
05:45:47 <lambdabot> Control.Arrow
05:45:55 <boegel> @type Control.Arrow.first
05:45:56 <lambdabot> forall (a :: * -> * -> *) d c b.
05:45:56 <lambdabot> (Control.Arrow.Arrow a) =>
05:45:56 <lambdabot> a b c -> a (b, d) (c, d)
05:46:34 <boegel> does anyone know what this does ? I'm not familiar with arrows, but I'm looking for a neat 'Top Ten' title
05:49:21 <boegel> @t lookup
05:49:21 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
05:49:21 <lambdabot> null topic-snoc topic-tail topic-tell type pl wn
05:49:25 <boegel> @type lookup
05:49:26 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
05:50:15 <jlouis> boegel: I think first takes the arrow from B to C into an arrow which takes the tuple (B, D) to (C, D), ie, it passes D through
05:50:44 <jlouis> (in parallel)
05:53:22 <wilx> Mhm..
05:53:35 <wilx> Seems like Darcs cannot handle the amount of patches.
05:54:09 <wilx> ..from the Conjure.
05:57:28 <jlouis> wilx: poor darcs ;)
05:57:52 <jlouis> wilx: why does it bork?
06:00:42 <ibid> afaik darcs doesn't have a particular difficulty with the *number* of patches being large
06:00:49 <wilx> Well, it is the dreaded using-hundred-percent-of-cpu-doing-nothing problem.
06:01:06 <ibid> yeah, and that has nothing to do with the number of patches :)
06:01:21 <ibid> you have two or more badly interacting patches there
06:01:58 <wilx> Hmm, the more patches are there bigger likelihood that you hit the problem :)
06:03:36 <ibid> are the patches generated from somewhere or darcs native?
06:04:14 <wilx> I was pulling the 63 weekend patches and I had some local changes in.
06:04:46 <ibid> do the local changes include changes you've sent upstream (excluding those you've sent as darcs patches)
06:05:05 <ibid> or do they include changes that are very similar to changes upstream has done?
06:05:16 <rep> i want to be a samurai when i grow up
06:05:18 <ibid> whatever, actually, the #darcs channel is better for this :)
06:05:34 <wilx> :)
06:05:41 <boegel> @eval take 10 [1..]
06:05:42 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
06:06:00 <wilx> The file, PiecePicker.hs with my local changes went away in the upstream repo.
06:06:31 <boegel> shapr: how about 'take 10 [1..]' with subtitle 'Top 10 in the world of Haskell'
06:23:28 <boegel> haskell.org is _really_ slow today
06:24:16 * shapr is also quite slow
06:24:31 <boegel> shapr: http://haskell.org/tmrwiki/TopTenHaskell
06:25:45 <shapr> Wow, haskell.org is really slow.
06:26:12 <jlouis> shapr: Gorgeous women makes men slow
06:28:33 <shapr> but happy
06:33:55 <basti_> dcoutts: are you here?
06:35:06 <xerox> Howdy!
06:35:13 <basti_> hi xerox
06:35:40 <boegel> shapr: did you have spam problems again ?
06:36:14 <shapr> Not on TmrWiki
06:36:24 <boegel> oh okay
06:36:53 <shapr> At least, not since 10-19
06:37:19 <xerox> Boing bo-boing bo-boing..
06:37:29 <boegel> xerox: yo ! check http://haskell.org/tmrwiki/TopTenHaskell
06:37:37 <xerox> Checked out!
06:38:47 <boegel> xerox: any idea's ?
06:39:55 <xerox> Hmhmmhmhhmm..
06:40:24 <xerox> There are many cool projects that one can think of, but I can't make a Top Ten :-)
06:40:52 <boegel> I don't need specific projects, I need overall subjects
06:41:20 <xerox> Graphics?! :-)
06:45:03 <boegel> xerox: yeah !
06:45:42 <xerox> boegel: I count HaskLS, Hray, Nymphaea, GtkGL (pretty new and shiny from dcoutts), etc.. :-)
06:46:54 <boegel> xerox: okay
06:56:19 * boegel wonders if he should start a thread on the mailing list now or wait until he has some more idea's
07:14:37 * SamB wonders why ghci says "No instance for (Show (a Char n))" instead of complaining that a is ambiguous...
07:15:06 <boegel> because ghci isn't as smart as ghc is ?
07:15:07 <araujo> There exist some "sub-string" regex matching function in the libraries?
07:15:31 <boegel> @index Regx
07:15:32 <lambdabot> bzzt
07:15:34 <boegel> @index Regex
07:15:35 <lambdabot> Text.Regex.Posix, Text.Regex
07:15:36 <araujo> know how to write my own, i just don't want to keep reinventing
07:15:48 <araujo> boegel, Oh, excluding those :-)
07:15:54 <boegel> araujo: heh :)
07:16:26 <SamB> araujo: for what kind of regex?
07:16:32 <SamB> that is, what library are you using?
07:16:41 <Igloo> If you exclude the regex modules then there aren't any regex modules...
07:17:32 <Cale> It would be kind of neat to have John's Regex library added to fptools
07:17:52 <Igloo> Nnnooooo, put it in hackage
07:17:53 <xerox> araujo: there are 'isPrefixOf' and some 'isBlah' functions, probably, in lambdabot's sources
07:18:03 <Cale> I suppose so
07:18:08 <SamB> Cale: is that the one that goes with Lexers?
07:18:31 <Igloo> What's an EDT, incidentaly?
07:18:39 <Cale> http://repetae.net/john/computer/haskell/JRegex/
07:19:08 <Cale> isPrefixOf is in the List library
07:19:19 <Cale> as well as isSuffixOf
07:19:39 <araujo> Thanks guys
07:19:56 <araujo> I just wrote a tiny one that seems to work
07:20:45 <Cale> > any (isPrefixOf "rld") (tails "Hello World!")
07:20:46 <lambdabot> True
07:21:01 <araujo> Thanks Cale
07:23:55 * SamB wishes darcs used HTTP pipelining
07:24:46 <xerox> Uh, lambdabot ?!
07:24:52 <xerox> > 2 + 2
07:24:53 <lambdabot> 4
07:24:57 <xerox> Whoa.
07:25:12 <kowey> would anyone happen to have an example of code that uses setInput/getInput in Parsec?
07:25:15 <xerox> Literate IRC :-D
07:25:30 <jlouis> SamB: would be cool, yeah
07:25:50 <jlouis> SamB: oh, by the way, fetching URLs on the tracker needs Gzip support
07:26:52 <jlouis> its irritating it should be like this, because it makes small hacks quite impossible regarding the tracker
07:34:24 <SamB> jlouis: oh? gzip, eh?
07:34:43 <SamB> how does that make small hacks quite impossible exactly?
07:39:39 <boegel> > take 10 [1..]
07:39:40 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
07:39:50 <boegel> that's what I'm talking about :)
07:39:58 <flux__> >> Quote
07:40:06 <SamB> jlouis: could you elaborate
07:40:10 <flux__> a-ha, I smell artificial intelligence, it doesn't evaluate >>'s ;)
07:40:28 <flux__> but I suppose quotes could be pasted with single >'s too
07:40:37 <flux__> > Foo
07:40:38 <lambdabot>  Not in scope: data constructor `Foo'
07:40:56 <SamB> >1
07:41:08 <araujo> Anybody knows a nice Category Theory paper?
07:41:15 <araujo> Related to Haskell if possible
07:41:54 <xerox> @wiki CategoryTheory
07:41:55 <lambdabot> http://www.haskell.org/hawiki/CategoryTheory
07:41:56 <xerox> :-D
07:42:54 <araujo> Hello xerox
07:44:35 <xerox> Yo.
08:03:54 <jlouis> SamB: hmmm, I am sleeping, sorry
08:04:27 <SamB> jlouis: oh, okay
08:04:36 <basti_> Cale: is there a glade user's guide available online?
08:04:43 * SamB wonders how jlouis apologizes while sleeping
08:04:50 * joelr_ waves
08:05:03 <lisppaste2> joelr_ pasted "help with a monad" at http://paste.lisp.org/display/13307
08:05:14 <joelr_> help! anyone?
08:05:44 <joelr_> i'm trying to monadify the code from Pickler Combinators
08:06:07 <boegel> bye everyone !
08:06:58 <Oejet> Bye, boegel.
08:08:02 <earthy> joelr: what is a PU a supposed to signify?
08:08:09 <joelr_> pickler/unpickler
08:08:24 <earthy> yeah, but what is the action denoted by  PU a  ?
08:08:36 <joelr_> earthy: http://research.microsoft.com/ ~akenn/fun/picklercombinators.pdf
08:08:58 <earthy> I have the article. :)
08:09:04 <joelr_> earthy: it's a computation that can either pickle or unpickle
08:09:17 <earthy> okay, I'll read a few pages first. just a sec ;)
08:09:47 <shapr> joelr_: How's the job? Did you get it working in time for you clients?
08:10:34 <joelr_> shapr: no, i'm going crazy over this. i'm just serializing and deserializng binary packets and the app spends 50% of the time collecting garbade. and moves something like 10Gb of stuff in a few minutes :(
08:11:04 <shapr> :-(
08:11:43 <paolino> how I "change" the  i-element  in a list ?
08:12:20 <joelr_> shapr: i'm trying to fix the craziness and pickler combinators looks good, specially if monadified
08:12:39 <shapr> hiya jose_da_biciclet, learning Haskell?
08:13:15 <jose_da_biciclet> sort of
08:13:40 <shapr> ok... do you have any questions?
08:13:44 <jose_da_biciclet> does anyone here uses hs-plugins?
08:14:02 <shapr> I've heard that dons uses it.
08:14:16 <jose_da_biciclet> I'm trying to use it with quickCheck
08:14:22 <shapr> Oh that sounds interesting.
08:14:32 <paolino> take i ++ new ++ drop (i+1) ?
08:14:39 <jose_da_biciclet> i'm finding some problems with that :\
08:15:02 <shapr> jose_da_biciclet: Like what?
08:15:30 <jose_da_biciclet> what i'm trying to do is to automatically load a program and check a few properties over some functions
08:15:50 <jose_da_biciclet> but suppose that a particular function it's not defined on the program that you have just loaded
08:16:02 <glasser> is there an easy way to download code samples from the hawiki properly other than copy-and-paste?
08:16:58 <shapr> glasser: There's an action=raw command.
08:17:04 <earthy> joelr: the sequ in that papers is your >>=
08:17:06 <glasser> cool
08:17:24 <joelr_> earthy: great :) lets be more precise. take a look at my paste, please
08:17:29 <earthy> however: this may not solve your problem.
08:17:38 <joelr_> earthy: they are pulling the b out of the hat
08:17:46 <joelr_> earthy: in appP of >=
08:17:50 <shapr> jose_da_biciclet: Can you give me a specific example?
08:17:58 <jose_da_biciclet> yes
08:17:58 <joelr_> earthy: by passing in (b -> a)
08:18:18 <joelr_> earthy: can't figure out how to do that without passing in (b -> a)
08:18:19 <jose_da_biciclet> suppose that you write a property to test a specific function called "lala"
08:18:20 <SamB> @index forkIO
08:18:21 <lambdabot> Control.Concurrent
08:18:29 <SamB> @index accept
08:18:30 <lambdabot> Network, Network.Socket
08:18:36 <SamB> @index hPutStr
08:18:37 <lambdabot> System.IO
08:19:00 <jose_da_biciclet> and that the file that will have that function defined is submitted and you don't know if that function is there or not
08:19:26 <jose_da_biciclet> when you call makeWith properties.hs program.hs
08:19:46 <jose_da_biciclet> you will end up with something like Properties.hs:20:14: Not in scope: `lala'
08:20:02 <shapr> Ok, what's the problem?
08:20:15 <jose_da_biciclet> i don't want this to happen :P
08:20:47 <shapr> How can you stop it?
08:21:18 <jose_da_biciclet> i'm trying to find out a way to prevent this from happening
08:21:28 <shapr> The best thing I can suggest is my test-driven-development extension to QuickCheck. That saves failing inputs for the next test run.
08:21:45 <shapr> Then you'll be able to use the failures to test your tests at least.
08:22:11 <jose_da_biciclet> i didn't understand
08:22:15 <earthy> joelr: that's just the issue: you need to chose which of the operations you want to keep working: pickling or unpickling
08:23:34 <glasser> hmm. is there a simple way to get haskell to memoize a function?
08:24:00 <shapr> glasser: memoize' f range = ((map f range) !!)
08:24:04 <glasser> (which I guess sort of doesn't make sense, since it could have decided to do that anyway)
08:24:19 <shapr> glasser: for more detail, memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
08:24:28 <shapr> Those definitions are both from Lor.
08:24:34 <joelr_> earthy: any pointers?
08:24:35 <glasser> Lor?
08:24:50 * shapr points to the user named Lor on this #haskell irc channel.
08:24:53 <glasser> oh :)
08:25:07 <joelr_> earthy: but don't i need to do both?
08:25:23 <glasser> Hmm. This only works for functions of integers, right?
08:25:24 <shapr> jose_da_biciclet: I don't think you can keep from having an error if the function isn't defined.
08:25:34 <joelr_> earthy: they manage to do both with sequ
08:25:40 <glasser> Is there a reasonable way to do this for, say, anything with Eq or Ord defined?
08:25:48 <glasser> (it's a very cute idiom though!)
08:26:05 <jose_da_biciclet> shapr: maybe my approach isn't correct
08:26:06 <shapr> glasser: I don't think memoize' has any limitation.
08:26:16 <shapr> jose_da_biciclet: I don't understand your problem enough.
08:26:37 <glasser> Ah, I guess I just need to come up with an appropriate value for range then
08:27:04 <glasser> !!'s going to want Int though, I thought
08:27:20 <shapr> Ah right
08:27:31 <jose_da_biciclet> what i'm trying to do is to create a web system capable of analyze works from haskell students.. simple problems at first
08:27:42 <glasser> hmm. and i don't *think* there's a lazy-Data.Map-from-function thing...
08:28:18 <joelr_> earthy: isn't there a =<<? could that be useful?
08:28:43 <glasser> You'd think there'd just be a way to tell GHC to memoize
08:28:56 <jose_da_biciclet> like: they should write a program to reverse lists then submit that program and i should be able to test it dynamically
08:28:58 <SamB> glasser: so, you could just use the array version, if you have something that could sensibly be in Ix...
08:29:31 <SamB> jose_da_biciclet: hs-plugins?
08:29:41 <jose_da_biciclet> yes
08:29:58 <lisppaste2> Earthy annotated #13307 with "dunno if this is what you want" at http://paste.lisp.org/display/13307#1
08:30:30 <earthy> (oh, you want to fix up the indentation on that one)
08:30:30 <jose_da_biciclet> another problem: if a student does is reverse function in a way that it never ends
08:30:30 <glasser> the objects are relatively complicated, Ix looks like it would be nontrivial
08:31:03 <Cale> jose_da_biciclet: you might be able to do something with Control.Concurrency
08:31:05 <SamB> jose_da_biciclet: you could look at plugs from lambdabot...
08:31:07 <earthy> joelr: =<< is normally defined in terms of >>=
08:31:23 <joelr_> earthy: ok, so what do you suggest?
08:31:37 <Cale> create a thread with the evaluation going on (see Control.Exception.evaluate) and kill it off after a given time frame
08:31:38 <shapr> glasser: GHC doesn't memoize because there are many expressions where it's faster to recompute than to keep and reload the result.
08:31:43 <earthy> joelr: read the annotation :)
08:32:44 <SamB> glasser: Maps aren't strict in their values, afaict
08:32:57 <joelr_> earthy: which one?
08:33:02 <SamB> glasser: how complicated are these keys?
08:33:04 <glasser> SamB: is that a good thing here?
08:33:23 <joelr_> earthy: what page?
08:33:34 <jose_da_biciclet> SamB and Cale: i'm kind a newbie isn't any documentation i can read?
08:33:36 <earthy> http://paste.lisp.org/display/13307#1
08:33:42 <glasser> SamB: well, ignoring for the second that it's a two-arg function, the complicated argument is a Map whose keys are more Maps
08:34:14 <joelr_> earthy: sorry, got confused. looking
08:34:21 <glasser> I mean, I can memoize by hand in a very procedural style with ifs and mutations and stuff, but that doesn't seem haskelly
08:35:14 <joelr_> earthy: hey, that's not fair! you are unpickling in the pickler!
08:36:22 <glasser> Oh, hmm, is what you meant before that Map.fromList isn't strict?
08:36:40 <Cale> jose_da_biciclet: one sec :)
08:36:53 <jose_da_biciclet> thanks Cale
08:36:56 <glasser> because then I bet I can do something with that
08:37:12 <joelr_> earthy: would that actually work? i would think that by that point a is not pickled yet
08:37:43 <glasser> so if the function I am memoizing is "domain v pf" then I do something like
08:37:47 <joelr_> earthy: or is it?
08:37:57 <glasser> domain v pf = domain' (Map.!) (v, pf)
08:37:58 <glasser> and
08:38:00 <earthy> joelr: any value of type PU a has an unpickler in it that will return a tuple of a value of type a and a string, right?
08:38:15 <joelr_> earthy: yes
08:38:21 <earthy> so, you can simply use that unpickler to retrieve that value
08:38:30 <glasser> domain' = Map.fromList [ ((v, pf), actualCode v pf) | v <- something, pf <- something ]
08:38:35 <glasser> ?
08:38:35 <earthy> and throw away the string
08:38:55 <joelr_> earthy: but if you look at the code the value is not there yet :-) you have a tuple (b) and a state
08:39:20 <earthy> come again? how is the value not there yet again? :)
08:39:41 <earthy> the value may not be useful, but it is valid and of the right type, right? :)
08:39:54 <Cale> jose_da_biciclet: I actually have a function which does what you want -- it appeared on the mailing lists
08:40:01 <Cale> let me paste it
08:40:20 <earthy> and due to the definition of return, anything you actually return into the monad does indeed have a value in the unpickler
08:40:24 <joelr_> earthy: well, if you look at the original code, at this point in time (appP in sequ) you are working with something of type b
08:40:39 <Cale> @paste
08:40:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:40:40 * earthy nods
08:40:50 <joelr_> earthy: say you have a pair, right? wouldn't b be a pair at that time?
08:40:59 <earthy> what the existing code does is subtly different
08:41:11 <earthy> ;)
08:41:40 <joelr_> earthy: that much i figured
08:42:01 <joelr_> earthy: i'm just trying to wrap my head around this. so suppose i'm pickling two ints
08:42:17 <joelr_> earthy: i would do something like int >= int, no?
08:42:21 <earthy> no
08:42:26 <earthy> that's just the thing
08:42:28 <joelr_> earthy: or am i confusing this with >>
08:42:34 <earthy> this monad will *only* unpickle
08:42:56 <joelr_> earthy: so i need two monads then?
08:43:04 <earthy> yeah, or an arrow.
08:43:17 <joelr_> earthy: the pickle part of a monad will be useless if the monad only unpickles :(
08:43:20 <earthy> the thing is, the PU a thingy is *not* a pickled a
08:43:26 <Cale> jose_da_biciclet: http://www.haskell.org/hawiki/HaskellIrcPastePage
08:43:31 <earthy> it is a pickler for things of type a
08:43:33 <joelr_> earthy: it's just a spec, right
08:43:38 <joelr_> earthy: a format
08:43:39 <earthy> or an unpickler for things of type a
08:43:58 <joelr_> well, so how do you make it do both pickle and unpickle from a single spec (computation)
08:44:00 <earthy> but the monadic view implies that the thing that is a monad is a somethinged a
08:44:16 <earthy> i.e.: the actual value is also encapsulated in the monad
08:44:46 <joelr_> earthy: but in this case you are encapsulating the actual methods, not values
08:45:07 <joelr_> earthy: and the idea is to chain them, i think
08:45:10 * earthy ndos
08:45:12 <earthy> nods even
08:45:28 <earthy> arrows would fit quite a bit better. ;)
08:45:46 <joelr_> earthy: let me look into arrows. do you know how to do it with arrows?
08:45:55 <earthy> no. I'm not that good with arrows.
08:46:00 <earthy> ask shae. :P
08:46:06 <joelr_> earthy: personally, i don't care if it's arrows or monads, so long as i can finish my project quickly
08:46:08 <earthy> he's the arrow-maven around here
08:46:18 <joelr_> shapr: ping
08:46:21 <earthy> joelr: then don't even try making the picklers into a monad
08:46:28 <earthy> but just use them
08:46:37 <joelr_> earthy: but the syntax is nicer
08:46:39 <earthy> the code is pretty useful as is
08:47:05 <earthy> ah, then go with arrowizing the picklers
08:47:08 <earthy> by all means
08:47:08 <joelr_> earthy: well, i could not figure out how to do a list, see
08:47:32 <earthy> how to pickle a list of arbitrary length you mean?
08:47:46 <joelr_> earthy: yes, one that stores the length before the list
08:47:54 <joelr_> earthy: i suppose it's a tuple
08:48:00 <joelr_> of length and the list itself
08:48:15 * earthy nods
08:48:39 <joelr_> so far so good but they build the pickler for list in recursively, seems like a potentially bad thing to do
08:48:39 <earthy> and then fixedList
08:48:59 <joelr_> earthy: take a look at fixedList
08:49:09 <earthy> I have it on my screen, yeah
08:49:10 <joelr_> they chain a bunch of closures, that's the way i understand it
08:50:28 <earthy> well, that's the entire idea behind this whole pickler code
08:50:34 <joelr_> come to think about it, i guess it would not matter
08:50:38 <joelr_> darn
08:50:46 <joelr_> earthy: how much effort to arrowize it?
08:51:05 <earthy> including learning arrows? 'bout an evening's worth of coding
08:51:40 <earthy> depending on talent, ofcourse. :)
08:51:47 <earthy> but you have enough of that ;)
08:51:56 <earthy> you're just slowly getting frustrated :P
08:52:04 <shapr> http://www.haskell.org/tmrwiki/ArrowsIntroduction
08:52:06 <joelr_> earthy: yeah, that's for sure
08:52:25 <joelr_> shapr: any suggestions on how to arrowize the pickler combinators?
08:52:36 * joelr_ is getting frustrated all right
08:52:55 <joelr_> reading shapr's intro
08:53:21 <vegai> shapr: oy! Excellent!
08:53:29 <vegai> has that been there for long?
08:53:49 <shapr> yup
08:53:52 <earthy> june ;)
08:53:53 <shapr> But it's also unfinished
08:54:19 <shapr> joelr_: I have a cold and massive headache right now, ask me tomorrow when I can focus.
08:54:42 <Itkovian> hmm, if I have a function that fills up a Data.Map, if I call it twice (it takes no args), is that alike to a g,lobal variable, or will the Map be rebuild each time?
08:55:06 <vegai> oh, right, I thought it was finished
08:55:09 <Itkovian> Otherwise it seems I must pass that map along through all my functions, whcih is not only tedious but plain ugly as well
08:55:58 <earthy> itkovian: I don't fully grasp what you're asking
08:56:11 <shapr> Common subexpression elimination can turn those into a single shared map.
08:56:14 <earthy> if you have a fucntion f :: (shit, stuff, and, a, Data.Map)
08:56:25 <earthy> then that function has 1 static value
08:56:34 <earthy> so if you call it twice, the same value will be returned
08:56:41 <earthy> including the exact same map
08:57:49 <Cale> jose_da_biciclet: also, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
08:58:09 <Cale> and from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html see evaluate
09:04:40 <jose_da_biciclet> thanks Cale
09:04:54 <Cale> jose_da_biciclet: just to make sure, you saw my paste?
09:05:05 <Cale> (on HaWiki)
09:05:08 <jose_da_biciclet> yes
09:05:26 <jose_da_biciclet> the watchdogIO function
09:05:39 <Cale> yeah
09:06:02 <jose_da_biciclet> where do you find that example?
09:06:59 <glasser> Cale: You wrote MonadRandom, right?
09:07:12 <Cale> jose_da_biciclet: on the mailing list
09:07:16 <Cale> glasser: yes
09:07:33 <glasser> I'm importing it, and defining a function of type
09:07:34 <glasser> sampleCPT :: ProbFunction -> Variable -> Assignment -> Rand Assignment
09:07:46 <glasser> but ghci claims that Rand is not in scope
09:08:10 <Cale> hmm
09:08:19 <Cale> I hope I at least exported the type constructor :)
09:08:34 <Itkovian> earthy: uhu, but I call it from different functions
09:08:59 <SyntaxNinja> 'morning
09:09:03 <glasser> aha!
09:09:09 <glasser> good thing it's a Wiki :) I'll fix it if you like
09:09:12 <Cale> okay
09:09:20 <Cale> don't export the data constructor though
09:09:30 <Cale> that's by design
09:09:41 <glasser> oh, hmm, I'm not sure how to differentiate
09:10:18 <Cale> Rand ()
09:10:30 <glasser> the parens are for the type, or the data?
09:10:49 <Cale> if we wanted to export data constructors, we'd list them in the parens
09:10:54 <Cale> oh
09:10:59 <Cale> you don't even need the parens
09:11:11 <glasser> hmm
09:11:16 <glasser> I'm modeling my code off of http://haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
09:11:20 <Cale> just export Rand, and RandomT
09:11:39 <glasser> It's now saying that
09:11:39 <glasser>     Kind error: `Rand DomainValue' is not applied to enough type arguments
09:11:39 <glasser>     In the type signature:
09:11:39 <glasser>       sampleCPT :: ProbFunction -> Variable -> Assignment -> Rand DomainValue
09:11:56 <Cale> oh
09:11:58 <Cale> hehe
09:12:04 <Cale> the library's been changed
09:12:05 <glasser> In the code you gave at that link though the type was Rand [a].  Maybe the lib has changed since you wrote that sample?
09:12:11 <Cale> Rand StdGen DomainValue
09:12:17 <glasser> yeah
09:13:16 <glasser> I am apparently not allowed to edit the MonadRandom page
09:13:48 <Cale> log in
09:13:57 <Cale> I edited it anyway
09:14:32 <glasser> thanks.
09:17:07 <fanopnaic> how do i convert a Maybe Int to Int?
09:17:37 <Itkovian> fanopnaic: fromJust?
09:17:41 <kosmikus> fanopnaic: what do you want to do in the case that the Maybe is "Nothing"?
09:17:48 <Itkovian> fanopnaic: _if_ you have Just x that is
09:17:59 <Cale> @type maybe
09:18:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:18:19 <fanopnaic> ah ok, will try
09:19:42 <fanopnaic> thank you!
09:21:00 <glasser> Cale: is there any particular reason that you're using Rational in fromList?
09:21:18 <Cale> not really
09:21:51 <glasser> like, if I changed the type declaration to a Num b, and got rid of the fromRational and liftM toRational, it ought to still work?
09:22:32 <Cale> hm, yes :)
09:22:32 <glasser> ah, Num isn't good enough to get Random
09:22:44 <Cale> well, (Num b, Random b)
09:24:23 <Cale> though it actually won't work with Rationals then
09:24:27 <glasser> yeah, and Ord, and change the 0 to a 0.0
09:24:28 <glasser> hmm
09:24:38 <glasser> well, I'll make my local modifications to make it to work at least
09:24:43 <Cale> (I needed it to work with rationals, and included it as an afterthought)
09:26:03 <SyntaxNinja> <--- uploaded a new cabal to debian Igloo, CosmicRay, shapr, etc
09:27:43 <Lemmih> Good morning, #haskell.
09:29:05 <SyntaxNinja> hiya Lemmih
09:29:30 <SyntaxNinja> CosmicRay: can you let me know if the new cabal plays nicely w/ dh_haskell, and your other packages?
09:33:28 <SamB> @hoogle Exception -> IO a
09:33:29 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
09:33:29 <lambdabot> System.Exit.exitFailure :: IO a
09:33:29 <lambdabot> Control.Exception.throw :: Exception -> a
09:34:16 <CosmicRay> SyntaxNinja: I saw that it's there.  I haven't had a chance to try it and I have to run to lunch now, but if you could drop me an e-mail reminder to test it, I'd be happy to.
09:35:33 <glasser> let's see.  Now I have a function that returns Rand Foo.  I'd like to make a new function that returns an infinite list that I can take N from.  So that'll return Rand [Foo]
09:35:43 <glasser> I was thinking just
09:35:44 <glasser> sampleCPTABunch :: ProbFunction -> Variable -> Assignment -> Rand StdGen [DomainValue]
09:35:47 <glasser> sampleCPTABunch pf v e =  mapM (\_ -> sampleCPT pf v e) (repeat 1)
09:35:52 <glasser> but that seems to hang when I evalRand it
09:36:06 <glasser> (well, when I take the "take" of its evalRand)
09:37:42 <SyntaxNinja> CosmicRay: cool
09:37:49 <SyntaxNinja> CosmicRay: have a good lunch.
09:39:18 <SamB> why doesn't hoogle look for all of my search terms?
09:39:34 * xerox waves
09:40:47 <SamB> @index getHostByName
09:40:47 <lambdabot> Network.BSD
09:40:50 <autrijus> glasser: that can happen when you have a strict monad.
09:41:04 <glasser> Is the list monad strict?
09:41:08 <autrijus> I don't quite know offhand how to lazify it, though
09:41:21 <autrijus> iirc it should be lazy.
09:41:23 <glasser> I can always push the "take" into the call (where the repeat 1 is)
09:41:27 <glasser> i'd hope so
09:41:32 <autrijus> (but I gotta run to the dinner.)
09:41:35 <glasser> eh, I was just using this for testing anyway
09:41:38 <glasser> eat up!
09:41:46 <autrijus> in IO monad that would call for a unsafeInterleaveIO
09:48:50 <glasser> Can I have if/then/else inside do-notation? it doesn't seem to work
09:51:09 <ndm> glasser, its a case of indentation
09:51:16 <ndm> you definately can
09:51:17 <glasser> that's certainly what it's telling me
09:51:26 <ndm> post your code, just a snippet
09:51:32 <ndm> with the if then else in it
09:51:38 <glasser> sure, what's a good pastebot?
09:51:45 <glasser> @paste
09:51:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:52:47 <glasser> ok, pasted
09:52:56 <glasser> (it's indented because it's in a where clause)
09:53:34 <ndm> glasser: put a space before then and before else
09:53:51 <glasser> oh, then and else get indented *below* if?
09:54:09 <ndm> yes
09:54:23 <ndm> then and else do not have to be indented at all
09:54:47 <ndm> but i still don't think it will work
09:54:51 <glasser> Now I get "Parse error in pattern"
09:54:52 <ndm> you need to put a do after else
09:55:02 <glasser> but the whole thing is in a do block?
09:55:13 <ndm> you can remove that do block
09:55:51 <glasser> Aha, so I shouldn't be trying to put my if/then/else inside the do. thanks
09:56:17 <ndm> i just pasted what it shuld be
09:56:24 <ndm> @paste
09:56:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:56:31 <glasser> now I'm at the problem I expected I'd have to ask, which is how to use an (a -> b -> SomeMonad a) function for foldl instead of a -> b -> a.  I bet it's some sort of lift function
09:57:33 <glasser> Hmm, but the lift function will put the arguments in the monad too
09:57:48 <ndm> now i have absolutely no idea how to use a monad!
09:57:57 <glasser> Oh, I just want foldM
09:58:08 <kosmikus> yes, probably
09:59:08 <glasser> Woo! It compiles!
10:02:42 <SyntaxNinja> ndm: I think you spend more time bragging about not knowing how to use a monad than you spend trying to use them ;)
10:02:42 <ndm> SyntaxNinja: its more fun :)
10:02:42 <ndm> although i have to rewrite a program tomorrow to use monads
10:02:42 <ndm> so i think i might spend all day crying...
10:04:59 <Spark> i'm reviewing a paper about monads in a few days
10:05:03 <Spark> when i get round to it
10:05:52 <gzl> so what's the deal with comonads?
10:05:59 <gzl> do people use them for anything interesting?
10:06:17 <SyntaxNinja> ndm: bring lots of tissues
10:06:55 <ndm> SyntaxNinja: i might just get drunk tonight and put it off for a few days
10:10:50 <SyntaxNinja> oh come on ;)
10:11:51 <shapr> gzl: dataflow
10:12:11 <gzl> dataflow?
10:12:35 <shapr> @google comonads dataflow
10:12:36 <lambdabot> http://lambda-the-ultimate.org/node/view/988
10:12:37 <gzl> I mean, what's the difference between the two? I know what the difference is categorically, but programmatically
10:12:59 <gzl> holy crap.
10:13:12 <gzl> that guy has 3 u's in his name. pretty good.
10:13:40 <shapr> And he took cool pix of autrijus, Igloo, and droundy
10:14:22 <SyntaxNinja> there's a cool pic of autrijus and spj hacking at a party
10:14:25 <shapr> http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1528.JPG
10:14:53 <gzl> shapr: I'm looking at your ArrowsIntroduction, and wondering about this:
10:14:54 <gzl> "The general pattern of monadic parsers is that each option must fail or one option must succeed.
10:14:58 <gzl> isn't that backwards?
10:15:18 <shapr> I don't think so. How do you mean?
10:15:46 <gzl> oh, you're talking about stuff like one <|> two <|> three
10:16:12 <gzl> I thought you were saying that with monadic parsers joined with (>>), either one must succeed or all must fail, which is backwards
10:16:19 <SyntaxNinja> I like this photo: http://cdc.ioc.ee/tfp-icfp-gpce05/photos-tarmo/IMG_1588.JPG
10:16:24 <gzl> (unless I'm *totally* confused.)
10:35:52 <vegai> SyntaxNinja: boy, that looks ergonomic :P
10:38:39 <glasser> For GHC 6.4.1 on OSX, which version of GCC do I want installed?
10:39:43 <glasser> Sometime between my laptop breaking last week and me reinstalling the OS, I seem to have gotten to "gcc: command not found", even though I thought I saved the XCode stuff. Eh, time to reinstall XCode
10:41:16 <dcoutts> basti_, pong!
10:41:57 <dcoutts> xerox, did you have an opinion on Axel's bug report?
10:42:07 <dcoutts> https://sourceforge.net/tracker/?func=detail&atid=455426&aid=1350152&group_id=49207
10:45:03 <basti_> dcoutts: ping-ping! why does gcSetValues crash gtk2hs?
10:47:40 <SyntaxNinja> vegai: heh yeah laptops are so good for us
10:48:31 <dcoutts> basti_, yes it is a bug. I fixed it this morning after you pointed it out.
10:48:37 <basti_> ah thanks
10:48:55 <dcoutts> basti_, you can work around it by using gcSetValues gc newGCValues { ... }
10:49:06 <dcoutts> and only setting the fields that you need
10:49:12 <dcoutts> rather than setting all of them
10:49:22 <dcoutts> this is more effecient anyway
10:49:25 <basti_> hmm i was using: gcv<-gcGetValues gc
10:49:31 <basti_> then gcSetValues gc {...}
10:49:44 <dcoutts> right, so that will get all the values and then set back the same ones
10:49:50 <dcoutts> doing gcSetValues gc newGCValues { ... }
10:50:09 <dcoutts> will *only change* the attributes that you speicfy
10:50:13 <basti_> ah
10:50:15 <basti_> thats cool.
10:50:23 <dcoutts> so it's more effecient anyway
10:50:36 <basti_> okay i didnt think it can work like that
10:50:53 <dcoutts> yeah it's a rather odd api (I didn't design it!)
10:51:01 <basti_> hehe
10:51:04 <dcoutts> the cairo stuff is much better
10:51:25 <dcoutts> but of course that's only good if you've got Gtk+ 2.8.x
10:51:26 <basti_> I'm trying to make a "piano roll display" for musical score
10:51:39 <dcoutts> if you can, use cairo
10:51:47 <dcoutts> it's seriously much better
10:51:54 <basti_> is it suitable for interactive stuff?
10:52:00 <dcoutts> it's easier to code and produces nicer output
10:52:06 <dcoutts> yes it is
10:52:10 <basti_> i know that it's looking better
10:52:16 <dcoutts> you can do animation and everything
10:52:21 <basti_> hmm
10:52:26 <basti_> i was talking like, a scroller of 100 virtual screens
10:52:56 <dcoutts> but how much is on-screen at once?
10:53:08 <basti_> one screen
10:53:09 <basti_> ^^
10:53:34 <dcoutts> obviously it'll clip to what is visible, but it's more effecient to only draw the bits that are (partially) visible
10:54:06 <dcoutts> Gtk+ 2.8.x does most of it's drawing using cairo now, so it's used quite a bit for interactive graphics
10:54:12 <basti_> oh okay.
10:54:20 <basti_> I'll give it a try
10:54:39 <dcoutts> it's a tad slower but it's much better looking and the api is much easier to use
10:54:45 <basti_> hehe ok
10:57:43 <xerox> dcoutts: yeah.  The Num instance does not define everything, just bits needed for cairo_matrix_* functions!
10:58:57 <Cale> xerox: need help defining the operations?
10:59:20 <xerox> Cale: dunno, I still have to finish Hegel, so I didn't look up the code now :)
10:59:26 <xerox> Cale: I'll tell you :)
11:02:53 <dcoutts> xerox, Cale, so how many of the other operations make sense?
11:03:15 <dcoutts> we should define the ones that make sense and define the otherse with error "...
11:04:35 <astrolabe> msg NickServ IDENTIFY michael
11:04:42 <astrolabe> oops
11:04:49 <xerox> Sob :-(
11:05:07 <dcoutts> xerox, ?
11:05:22 <astrolabe> None of you nice haskellers would pinch my password now wouldn you?
11:05:27 <Cale> dcoutts: basically all of them do
11:05:46 <xerox> dcoutts, it was for poor astrolabe.
11:06:04 <Cale> astrolabe: just change it
11:06:08 <xerox> dcoutts, I think Cale is right.  I just implemented the minimum necessary
11:06:18 <astrolabe> good plan
11:06:30 <SyntaxNinja> astrolabe: or we can change it for you if you want ;)
11:06:31 <Cale> (especially as the channel is logged)
11:13:07 <dcoutts> xerox, Cale, so (+) and (-) make sense do they?
11:13:34 <dcoutts> and the others? negate, abs, signum, fromInteger, fromInt
11:13:43 <dcoutts> do they all make sense?
11:13:52 <dcoutts> what's the interpretation?
11:15:00 <dcoutts> so (+) & (-) are just pointwise I suppose
11:15:40 <Spark> what is it called, in type theory, where e.g. in java the var gets .toString() called on it, to allow it to fit the rule for (+) "number: " + var
11:15:52 <Spark> i thought coercion, but thats more like casting isnt it
11:16:15 <dcoutts> Spark, ad-hoc polymorphism?
11:16:23 <Spark> thats sounds about right
11:16:41 <Spark> i read a site once with many different kinds of polymorphism defined, but i cant find it now
11:18:46 <dcoutts> xerox, Cale, feel free to join a gobby session on my machine to edit the cairo Matrix.hs, normal port, normal password
11:48:16 <glasser> Hmm.  I can only use ghc --make with a Main.hs, right?
11:48:31 <dcoutts> no, you can use it with any module
11:48:45 <dcoutts> but it'll only create an executable if you specify a main module
11:49:08 <glasser> hmm
11:49:20 <dcoutts> otherwise it just compiles that module (and all the other modules it depends upon)
11:49:26 <glasser> see, I have a project I need to be making a bunch of different executables from
11:49:42 <dcoutts> then invoke ghc --make once for each executable
11:50:08 <glasser> but there can only be one Main.hs around
11:50:17 <dcoutts> oh I see what you mean
11:50:36 <glasser> (this is a homework assignment and different parts of the assignment ask for different calculations; I'd kind of like a separate executable for each)
11:50:37 <dcoutts> yes there can only be a sigle "Main.hs" in any single directory, but...
11:50:54 <glasser> ... or can there be a Part1.hs with "module Main where" inside it?
11:51:09 <dcoutts> you can have more than one 'main' module. A 'main' module is just one which says "module Main where" inside it
11:51:12 <dcoutts> like you said
11:51:26 <glasser> aha!
11:51:35 <glasser> I thought you always had to have the pathname match the module name
11:51:45 <dcoutts> yes, except for the main module
11:51:53 <dcoutts> since nothing imports the main module
11:51:54 <SamB> Hmm, I notice jlouis would like patches to Conjure reviewed by at least two people, and am wondering about how to go about getting this done...
11:51:57 <glasser> I bet I can guess why :)
11:52:15 <dcoutts> you only need the names to match for when you need to import the module
11:52:35 <dcoutts> so it can find the file corresponding to the module you specify
11:52:41 <glasser> make sense
11:52:55 <SamB> dcoutts: or has no module declaration at all
11:53:19 <dcoutts> SamB, yes
11:56:25 <SamB> dcoutts: *I* import the main module!
11:56:50 <dcoutts> :-)
11:57:38 * SamB notes that to be compiled, a Main module needs to provide main :: IO ()
11:58:33 <glasser> yeah, got that; thanks
12:10:29 <dcoutts> anyone got a opinion on what (fromInt :: Int -> Matrix) should mean?
12:10:42 <glasser> 1x1 matrix?
12:11:05 <dcoutts> oh sorry, it's a fixed size 3x3 matrix
12:11:10 <dcoutts> I didn't specify, sorry
12:11:22 <glasser> diagonal then?
12:11:23 <dcoutts> should fromInt 1 be all 1's or 1's on the diagonal
12:12:06 <dcoutts> so that means m * 2 is scaling rather than a scalar multiply
12:12:19 <dcoutts> scalar multiply is different, it's jsut pointwise
12:12:40 <dcoutts> oh, it wouldn't mean scalar multiply anyway
12:12:56 <dcoutts> so yeah, I agree, it should be on the diagonal
12:13:04 <dcoutts> then 1 == identity
12:27:45 <marcot> dcoutts: hello there.
12:28:00 <marcot> Is a part of gtk2hs bsd-like or is it all lgpl?
12:28:13 <Ferret> hi duncan
12:28:22 <Ferret> Hehe...
12:29:08 <Ferret> Terry Pratchett/Frank Herbert hybrid.
12:29:38 * Ferret wonders why he never thought of coming here after going to #Gentoo-Haskell.
12:29:40 <Philippa> Ferret: eh?
12:29:50 <Ferret> Never mind, I'm random.
12:29:58 <dcoutts> marcot, well xerox put the cairo bit under BSD. The rest of it is LGPL 2.1
12:30:12 <dcoutts> marcot, and Gtk+ and cairo them selves are LGPL
12:30:12 <Philippa> no, random's on #afp elsewhere...
12:30:28 <Philippa> (I'm vaguely involved in Terry's fandom)
12:30:42 <Ferret> I was pointing at Muad_Dibler.
12:30:44 <dcoutts> hi Ferret
12:31:05 <Ferret> dcoutts: I nearly met you today.  But I guess you hear that a lot.
12:31:12 <dcoutts> heh, yeah
12:31:20 <marcot> dcoutts: hum... there's no cairo/COPYRIGHT.
12:31:25 <marcot> I sent a e-mail..
12:31:29 <dcoutts> marcot, oh
12:31:35 <Ferret> Although maybe not from other gentoo users
12:32:19 <dcoutts> Ferret, true, mostly from students
12:32:31 <Philippa> Ferret: ah, you should've said that straight away :-)
12:32:52 <dcoutts> marcot, oh, it's in cvs but I guess it's missing from the tarball
12:33:15 <dcoutts> marcot, http://haskell.org/gtk2hs/darcs/gtk2hs/cairo/COPYRIGHT
12:33:17 <marcot> dcoutts: hum.. ok.
12:33:29 <marcot> dcoutts: remember adding it in the next release.
12:33:31 <dcoutts> marcot, I'll make sure it gets into the tarball in future
12:33:36 <marcot> ok.
12:33:47 * dcoutts fixes Makefile.am
12:34:29 <SamB> dcoutts: but there isn't a temptation to copy and paste code from GTK or cairo themselves into your haskell program...
12:35:48 <dcoutts> SamB, heh, true :-)
12:36:20 <dcoutts> SamB, it's important to comercial developers however that the stack is LGPL or compatible all the way down
12:36:45 * SamB wonders why dcoutts is still using CVS
12:38:03 <dcoutts> SamB, http://haskell.org/gtk2hs/archives/2005/07/23/why-oh-why-is-gtk2hs-developed-using-cvs/
12:38:44 <SamB> dcoutts: I don't care how much they like LGPL, I like BSD better!
12:39:12 <neologism> sad0ur: hi dude ;)
12:40:04 <sad0ur> neologism: hi
12:41:19 <dcoutts> SamB, BSD <= LGPL, so that's ok
12:41:38 <ulfdoz> @paste
12:41:38 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:41:47 <basti_> xerox: so how does that gtk2hs/cairo thing work? how do i get a cairo drawing context? How do I make one in glade, how do i access it?
12:42:04 <Spark> surely BSD >= LGPL
12:42:30 <dcoutts> Spark, I mean as a subtype
12:42:30 <SamB> dcoutts: yeah, thats just what I like about BSD! BSD <= all!
12:42:41 <Spark> even then
12:42:43 <musasabi> LGPL is quite problematic in Haskell context as everything is statically linked.
12:42:50 <dcoutts> BSD = _|_  :-)
12:43:02 <Spark> nah, public domain is bottom
12:43:08 <Spark> bsd places some restrictions
12:43:11 <Spark> lgpl more
12:43:13 <dcoutts> true
12:43:43 <dcoutts> musasabi, yeah to be careful people using LGPL for Haskell packages ought to give an explicit exception for static linking.
12:44:20 <dcoutts> for linking Haskell paackages to LGPL C libs it's ok since that is dynamicaly linked (or can be)
12:44:22 <Spark> it depends how you interpret it as a type, whether or not its top or bottom :)
12:44:42 <musasabi> Does Gtk2Hs has a static linking exception?
12:44:42 <glasser> Hm. I want to lift Map.map.  Do I lose?
12:44:44 <SamB> dcoutts: how much of gtk2hs is dynamicly linked, anyway?
12:45:04 <dcoutts> SamB, it's dynamically linked to all the C libs
12:45:16 <dcoutts> basti_, use Gtk.renderWith
12:45:17 <glasser> (ie, I have a Map from A to B and a function from B to M C, where C is a monad.  Map.map will give me a Map A (M C); I want M (Map A C).)
12:45:30 <SamB> dcoutts: doesn't it have a .so of its own?
12:45:38 <basti_> hmm
12:45:43 <dcoutts> basti_, http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Cairo.html
12:46:05 <dcoutts> SamB, no, Haskell packages are libHS{pkg}.a
12:46:16 <basti_> ah
12:46:20 * basti_ trying to make sense of that
12:46:33 <ulfdoz> What's broken here? If I do it with let/in directly in ghci, it works fine. http://www.rafb.net/paste/results/Lh64Gh56.html
12:46:34 <dcoutts> basti_, see the gtk2hs/cairo demo code
12:46:42 <dcoutts> SamB, ghc doesn't make dynamic libs for haskell packages yet
12:46:52 <dcoutts> at least not on linux
12:47:11 <dcoutts> it can do on OSX so far, it should be able to do other platforms too eventually
12:47:30 <SamB> dcoutts: maybe I'm thinking of wxHaskell
12:47:50 <mauke> ulfdoz: are you sure that's the right code?
12:47:52 <basti_> I will
12:47:56 <dcoutts> SamB, it has an extra C++/C conversion lib which it dynamically links to
12:47:58 * basti_ is called away by stupid people again
12:48:08 <SamB> dcoutts: wxHaskell?
12:48:09 <mauke> it doesn't contain "listSum"?
12:48:31 <dcoutts> SamB, we don't need that since Gtk+ is C already so there's no C++/C conversion required
12:48:31 <ulfdoz> mauke: Nope.
12:48:48 <marcot> I'm packaging c2hs-0.9.10 without cairo compiled.
12:49:03 <marcot> But I must add the BSD in the license.
12:49:06 <dcoutts> marcot, huh? c2hs?
12:49:11 <SamB> dcoutts: ah
12:49:11 <marcot> dcoutts: gtk2hs hehehe
12:49:18 <dcoutts> SamB, interfacing C++ with Haskell is hard, you need to go via C first
12:49:30 <SamB> why doesn't wxBase already come with such a wrapper?
12:49:45 <dcoutts> SamB, they don't care about language bindings?
12:49:52 <dcoutts> I dunno really
12:50:22 <SamB> maybe they only care about Python bindings, which pretty much have to be in C/C++ anyway...
12:50:23 <dcoutts> the wxEifel people developed it and wxHaskell uses it too
12:50:37 <dcoutts> yeah, interfacing python and C++ is not too hard
12:51:04 <ulfdoz> Sorry, here the consistent paste: http://www.rafb.net/paste/results/qpfG7u34.html
12:51:09 <dcoutts> marcot, ok fair enough. I guess you don't have Gtk+ 2.8.x in debian yet.
12:51:31 <SamB> really, the python bindings seem to follow the C++ API into needless complexities...
12:51:42 <SamB> I mean, what in the world is the point of wxApp in python?
12:52:27 <dcoutts> SamB, the thing is each of these things ends up defining their own platform. Qt is a platform, wxWidgets is a platform. (sortof)
12:52:38 <SamB> dcoutts: if by "not too hard" you mean "no harder than interfacing Python to anything else"...
12:53:02 <dcoutts> SamB, there are C++ template libs which make interfacing with python easier
12:54:17 <Itkovian> @eval Text.Regex.subRegex (Text.Regex.mkRegex "as") "yyasjj" "rrr"
12:54:17 <lambdabot>  Not in scope: `Text.Regex.mkRegex'
12:54:23 <SamB> every "platform" type library should provide a backdoor to skip the platform stuff for foreign or non-app usage...
12:54:39 <SamB> dcoutts: does wxPython use boost?
12:55:13 <Itkovian> wtf?!
12:55:19 <marcot> dcoutts: you're right.
12:55:38 <SamB> > Text.Regex.subRegex (Text.Regex.MkRegex "as") "yyasjj" "rrr"
12:55:39 <lambdabot>  Not in scope: data constructor `Text.Regex.MkRegex'
12:56:00 <araujo> Hello!
12:56:11 * araujo trying to understandwhat this CT thingy is all abuot
12:57:09 <ulfdoz> arg, *head* -> *table*; Note to me: When in doubt, let the compiler infer types.
12:57:45 <SamB> @index mkRegex
12:57:46 <lambdabot> Text.Regex
12:57:48 <araujo> As far as i understand CT is an uniform way of relating diffferent groups of objects in a given universe?
12:58:19 <SamB> > Text.Regex.subRegex (Text.Regex.mkRegex "as") "yyasjj" "rrr"
12:58:20 <lambdabot>  Not in scope: `Text.Regex.mkRegex'
12:58:45 <SamB> @help eval
12:58:45 <lambdabot>  @eval <expr>
12:58:45 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
13:00:03 <{Arias}> lol
13:00:17 <SamB> dons: why is this not working, even though I know you are sleeping now!
13:01:37 <Itkovian> yeah yeah
13:01:56 * araujo wonders if anyone read his question
13:02:35 <ulfdoz> 12464 mary      25   0 1883m 1.6g 6880 R 99.0 81.5   1:17 0 ghc-6.4.1
13:02:43 <ulfdoz> Woah, it should be tailrecursive.
13:02:45 <Itkovian> araujo: clearly not :-)
13:03:15 <int-e> SamB: did you load the Text.Regex module? [in ghci:  :m +Text.Regex ]
13:03:16 <SamB> @plugs Text.Regex.subRegex (Text.Regex.mkRegex "as") "yyasjj" "rrr"
13:03:17 <lambdabot>  Not in scope: `Text.Regex.mkRegex'
13:03:21 <SamB> araujo: I don't understand it that well myself
13:03:27 <SamB> araujo: but that sounds plausible enough
13:03:46 <SamB> well, maybe not the given universe part
13:03:49 <Itkovian> araujo: I don't care yet ...
13:04:17 <SamB> int-e: @eval aka > doesn't support that, afaik
13:04:32 <SamB> > :m +Text.Regex
13:04:33 <lambdabot>  parse error on input `:'
13:04:46 <SamB> int-e: note that the error message was from lambdabot
13:04:46 <int-e> SamB: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs ... Text.Regex is not in the module list there
13:05:05 <Itkovian> int-e: aha!
13:05:26 <Itkovian> anyway ghci yields: "yy*** Exception: Text.Regex.Posix.regcomp: error in pattern
13:06:26 <int-e> hmm. works here. Prelude Text.Regex> subRegex (mkRegex "as") "yyasjj" "rrr" --> "yyrrrjj"
13:07:05 <SamB> Itkovian: what libc do you have?
13:07:15 <Itkovian> int-e: sub with an empty string works
13:07:26 <Itkovian> SamB: erm ... let me see, I'm on Tiger
13:07:49 <SamB> Itkovian: so probably a BSD-ish one?
13:07:56 <Itkovian> yeah
13:08:04 <Itkovian> but I cannot execute it to see its version.
13:08:05 <Itkovian> hmm
13:09:20 <SamB> Itkovian: maybe there is something wierd with their regex iplementation...
13:09:26 <Itkovian> hmm
13:09:30 <Itkovian> maybe
13:10:00 <Itkovian> I should prolly fire up gdb
13:10:02 <Itkovian> pfft
13:10:09 <Itkovian> I am not very proficient with that
13:10:20 <musasabi> My first attempt at the AG gui thing ended up with a need to rethink things. Types started to get huge...
13:10:41 <SamB> Itkovian: be sure to look at the Text.Regex.Posix source to see where to set your breakpoint
13:11:04 <Itkovian> uhu
13:11:38 <SamB> Itkovian: look in particular for foreign imports
13:11:54 <Itkovian> uhu
13:12:25 <araujo> SamB, Itkovian hah , ok
13:12:46 <Itkovian> SamB: first figure where Tiger has ditched my gear.
13:13:20 <SamB> Itkovian: ditched your gear?
13:13:29 <Itkovian> yeah, ghc and some such
13:13:45 <SamB> ghc is missing?
13:13:59 <Itkovian> doesn;t it normally install the .hs files too?
13:14:11 <SamB> oh, probably not.
13:14:14 <Itkovian> dang
13:14:22 <Itkovian> oh well.
13:14:25 <SamB> okay, I'll look ;-)
13:15:14 <SamB> oh, Text.Regex.Posix uses hsc...
13:17:31 <SamB> okay, so regcomp is the name of the C function too...
13:17:58 <SamB> (though it is imported as c_regcomp in Text.Regex.Posix)
13:19:27 <SamB> oh, and it looks like sometimes it comes from GHC's own RTS and sometimes it doesn't
13:19:52 <SamB> or is that just for HUGS?
13:20:43 <Itkovian> else error "Text.Regex.Posix.regcomp: error in pattern" -- ToDo
13:20:46 <Itkovian> haha
13:21:33 <SamB> Itkovian: presumably the thing ToDo is differentiate between different sorts of errors...
13:22:24 <Itkovian> heh
13:22:28 <Itkovian> whatever :-)
13:26:20 <SamB> anyways, if you want to do someting with regexes, you could steal Yi.Regex...
13:29:08 <Itkovian> SamB: nah, I just need to replace e.g. event 0x1234\t  93287 with the string for 0x1234 I stored in a hashtable, and ditch the rest of the string
13:29:19 <Itkovian> hmm
13:29:33 <Itkovian> come to think about it, I just need to match 0x[0-9]*, eh :-)
13:30:02 <SamB> you could use Parsec...
13:31:01 <SamB> "Remember, class: overkill is fun!"
13:33:21 <Itkovian> SamB: uhu
13:34:02 <{Arias}> 0x[0-9]+ i think...
13:37:51 <Itkovian> {Arias}: yes, indeed
13:38:10 <Itkovian> matchRegex is fubar too, it yields []
13:38:25 * basti_ will have to build the gtk by hand
13:38:33 <Itkovian> so I resorted to matchRegexAll and ditch everything except the second item in the tuple
13:38:56 * basti_ would have liked to know -before- finding that cairo doesn't work with gtk < 2.8
13:41:09 <Itkovian> I've got a Data.Map String String. When I perform Lookup, it return m String. What monad is the m?
13:41:59 <basti_> i would expect it to be Maybe
13:42:09 <basti_> i do not see why the compiler doesnt realize that, though
13:43:30 <Itkovian> basti_: nah, I haven't tried it yet.
13:43:37 <Itkovian> the API just says it returns m a
13:43:43 <basti_> strange
13:43:47 <Itkovian> but Maybe would be very nice.
13:44:05 <basti_> what else?
13:45:27 <Itkovian> ghci yiels no output
13:46:07 <musasabi> Having it in any Monad is very convenient.
13:46:28 <Itkovian> Prelude> :t let map = Data.Map.fromList [(1,2),(3,4),(5,6)] in Data.Map.lookup 1 map
13:46:31 <Itkovian> let map = Data.Map.fromList [(1,2),(3,4),(5,6)] in Data.Map.lookup 1 map :: (Num a,
13:46:35 <Itkovian>                                                                              Monad m) =>
13:46:38 <Itkovian>                                                                             m a
13:46:39 <Itkovian> musasabi: Yeah, but I want it out! :-)
13:47:04 <basti_> musasabi: uhm, why? I don't seem to get it
13:47:33 <musasabi> Try in ghci:
13:47:37 <musasabi>  Data.Map.lookup 0 (singleton 1 "1") :: Maybe String
13:47:41 <Itkovian> nah it's ok
13:47:43 <musasabi> Data.Map.lookup 0 (singleton 1 "1") :: [String]
13:47:50 <musasabi> Data.Map.lookup 0 (singleton 1 "1") >>= print
13:48:00 <basti_> but what if the monad is a bizarro one?
13:48:01 <musasabi> It just fails in the monad you are currently in.
13:48:11 <Itkovian> when I drop it inside a case distinguishing between Just x and Nothing it does the right thing
13:48:17 <Itkovian> very goof
13:48:18 <basti_> so all monads have a failure facility?
13:48:33 <basti_> what if i put it into Identity?
13:48:35 <musasabi> basti_: then use just use "case lookup key map of Nothing -> ...; Just x -> ..."
13:48:47 <basti_> hmm right.
13:49:03 <basti_> but lets say i use it in Identity and do not do case
13:49:07 <basti_> what would it do? ^^
13:49:24 <basti_> crash and burn?
13:49:41 <Itkovian> basti_: you know that Haskell doesn;t crash :-)
13:50:59 <musasabi> basti_: it uses error then.
13:51:09 <musasabi> @type error
13:51:09 <lambdabot> forall a. [Char] -> a
13:51:48 <basti_> hmm ok ^^ :)
13:52:01 <musasabi> basti_: all mathematical monads don't have failure, but do-notation requires failure.
13:52:43 <musasabi> basti_: think about "do (x,y) <- foobar; return x" when foobar fails the pattern match.
13:52:44 <basti_> because of error?
13:52:54 <basti_> hmm
13:52:58 <basti_> i see
13:53:06 <musasabi> because Haskell functions are partial not total.
13:53:17 <basti_> you certainly mean something like (x:y)?
13:53:22 <basti_> since tuples are types and checked?
13:53:41 <musasabi> yes (x:y) makes more sense :-)
13:53:44 <basti_> ^^
13:53:51 * basti_ was able to correct musasabi 
13:53:56 * basti_ does the happy dance
13:53:58 <basti_> ;)
13:54:03 <musasabi> thanks for pointing out when I was talking rubbish.
13:54:20 <basti_> youre welcome.
13:58:17 <astrolabe> @type all
13:58:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:33:20 <shapr> I can't belIEVE it's not butter!
14:35:35 <astrolabe> shapr:  It's not?!!!!
14:38:16 <Itkovian> hi shapr
14:38:51 <Itkovian> how would I go about to grouping e.g. [e,e,e,c,c,c,e,e,e,e,c,c,c,c] into [[e,e,e,c,c,c],[e,e,e,e,c,c,c,c]]
14:39:12 <Itkovian> there's as many c's as e's but the number isn't known in advance
14:40:50 <SamB> can someone darcs get http://naesten.dyndns.org:8080/repos/conjure-SamB and tell me why "make haddock" is giving me a parse error?
14:41:27 <Itkovian> I could do the first part of the and clause, but the second will fail in any case, so .. no
14:42:24 <astrolabe> Itkovian: maybe it would be easier to work out [[e,e,e],[c,c,c],[e,e,e,e],[c,c,c,c]] first
14:42:35 <Itkovian> astrolabe: of course!
14:42:41 <Itkovian> my brain is foggy
14:43:22 <SamB> shapr: you look full of exuberance!
14:44:14 * SyntaxNinja hands shapr not-butter
14:44:43 <basti_> that stupid autoconf
14:44:47 <basti_> configure: error: Package requirements (glib-2.0 >= 2.7.1    atk >= 1.0.1    pango >= 1.9.0    cairo >= 0.9.2) were not met.
14:44:52 <basti_> which one huh?
14:44:55 * basti_ kicks autoconf
14:45:44 <SamB> SyntaxNinja: perhaps you would be willing to be my lucky victim?
14:47:18 <Itkovian> basti_: isn't there a nice glib-config etc lying around?
14:47:28 <Itkovian> something you could, erm persuade, to lie :-)
14:47:38 <basti_> Itkovian: i don't even know what it'd want
14:48:03 <Itkovian> well, I presume it want glib-config --version to return e.g. 2.7.3
14:48:07 <Itkovian> or some such
14:48:20 <basti_> hmmmm
14:48:26 <SamB> Itkovian: how do you tell the es from the cs?
14:48:28 * basti_ sees something
14:48:43 <SamB> @type group
14:48:44 <lambdabot> Not in scope: `group'
14:48:45 <Itkovian> SamB: by prefix
14:48:47 <SyntaxNinja> SamB: I'll grab your repo and look
14:49:17 <Itkovian> SamB: e -> "event 0x004300c0 4857349857" , c -> "counters.ctrs[0] = 9873937927937"
14:49:20 <SamB> SyntaxNinja: be prepared for horrid latency!
14:49:32 <SyntaxNinja> SamB: yeah. I noticed
14:49:36 <SamB> I would suggest grabbing the mainline repo first
14:49:53 <SyntaxNinja> SamB: quick q. are you running cpp over the files first? what's the parse error?
14:50:06 <astrolabe> @paste
14:50:07 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:50:42 <SamB> SyntaxNinja: it doesn't elaborate, but there isn't any CPP stuff in that file, or afiak any of them...
14:51:00 <basti_> Itkovian: no, with glib-config moved out of the way it still gives the same result
14:51:26 <SyntaxNinja> SamB: probably easier if you paste the file someplace and tell us what line
14:51:34 <SyntaxNinja> are you using quotes or slashes? any other compiler extensions?
14:52:11 <Itkovian> basti_: check the other *-config stuff ?
14:52:29 <SamB> the errror is around here:
14:52:29 <SamB> queryTracker :: Torrent
14:52:29 <SamB>              -> String       -- | The 20-byte @peer_id@ to use
14:52:36 <dcoutts> SyntaxNinja, I was thinking about a Cabal patch for ghc's -split-objs
14:52:46 * basti_ shrugs :/
14:52:58 <SamB> it seems to be on the "--"
14:53:12 <dcoutts> SyntaxNinja, however I'm not sure if it's all going to change soon anyway.
14:53:13 <SamB> dcoutts: you scare me!
14:53:15 <SyntaxNinja> you should probably use -- ^ first?
14:53:29 <SyntaxNinja> if the comment is for the previous line, use "-- ^" if for the following line, use "-- |"
14:53:34 <dcoutts> SamB, me?
14:54:07 <dcoutts> SyntaxNinja, eg if ghc is going to make the combination of --make and -split-objs "Just Work"tm
14:54:08 <SyntaxNinja> dcoutts: care to enter info into the new cabal wiki, which I haven't told anyone about yet, as a bug?
14:54:09 <SamB> SyntaxNinja: oh
14:54:16 <SyntaxNinja> dcoutts: that would be nice
14:54:19 <SamB> SyntaxNinja: what if it is for THAT line?
14:54:38 <SamB> dcoutts: yes, you! -split-objs indeed!
14:54:43 <SyntaxNinja> SamB: -- ^
14:54:54 <dcoutts> SyntaxNinja, or if you're going to switch to not using ghc in --make mode but rather calcualte the deps some other way.
14:55:14 <SyntaxNinja> dcoutts: http://hackage.haskell.org/cgi-bin/trac/trac.cgi
14:55:20 <SyntaxNinja> (if you want)
14:55:32 <dcoutts> SamB, well I just added --enable-split-objs to Gtk2Hs's build system. Gtk2Hs helloworld shrank by 90% ! :-)
14:55:42 <dcoutts> SyntaxNinja, ok
14:55:46 <SyntaxNinja> dcoutts: I would like to do the calculations without GHC's help, but no one has volunteered to do the work yet.
14:55:48 <SyntaxNinja> :)
14:55:56 <SyntaxNinja> the work of building the module dependencies
14:55:58 <SamB> dcoutts: well, I guess that is pretty nice...
14:56:15 <SamB> but I wouldn't want to run ar...
14:56:31 <SyntaxNinja> so I don't know how soon that'll happen. probably the best thing is to get ghc to fix it, next best is to get a temp. cabal workaround, next best is to get a perminant cabal workaround (using the module dep. calculation)
14:56:32 <dcoutts> SamB, use xargs
14:56:39 * basti_ tries the swiss chainsaw strace
14:57:09 <SyntaxNinja> dcoutts: also you can tell me what you think of that setup for cabal.
14:57:13 <basti_> ahh
14:57:20 <basti_> atk package-cnf thing is missing
14:57:20 <SyntaxNinja> dcoutts: we can takl about it, bu I'm going to a meeting in a minute.
14:57:22 <SamB> dcoutts: is that what you do?
14:57:30 <dcoutts> SyntaxNinja, eek! Error 404
14:57:48 * astrolabe has posted a problem of his at @paste
14:57:51 <astrolabe> @paste
14:57:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:58:00 <dcoutts> SyntaxNinja, for the "report it here" on the wikiw page you reffered me to
14:58:35 <dcoutts> SamB, I use: cat ${lib}.list | xargs /usr/bin/ar q $lib
14:58:51 <SyntaxNinja> dcoutts: hohum
14:59:09 <SyntaxNinja> dcoutts: does this give you 404? http://hackage.haskell.org/cgi-bin/trac/trac.cgi/wiki
14:59:11 <dcoutts> SamB, interestignly one cannot use the normal ar flags "cur" since that breaks things when there are modules with the same name.
14:59:41 <dcoutts> SyntaxNinja, no, it's the newticket page that it links to that gives the 404
14:59:43 <dcoutts> http://hackage.haskell.org/cgi-bin/cabal/trac.cgi/newticket
14:59:59 <dcoutts> SyntaxNinja, the main page you gave is fine
15:00:20 <SyntaxNinja> dcoutts: what about the "new ticket" link?
15:00:28 <dcoutts> SyntaxNinja, it gives 404
15:01:29 * SyntaxNinja fixes link
15:01:38 <dcoutts> dcoutts, at least no the same name exactly but Foo1.Bar and Foo2.Bar would clash and only one would get into the libHSfoo.a file.
15:01:44 <SyntaxNinja> the "new ticket" link along the top gives a 404 too?
15:01:58 <dcoutts> SamB, err I meant that comment for you, not me :-)
15:02:15 <dcoutts> SyntaxNinja, oh, that one is fine
15:02:28 <SyntaxNinja> I'll be back in a bit. meeting. fixed the other link. we can chat when i get back if you want :)
15:03:37 <SamB> it looks my mom's computer is inexplicably downloading from a nameless site...
15:04:20 <astrolabe> Do you think she's some kind of virus writer?
15:05:42 <SamB> astrolabe: more like virus-catcher, but I have no proof
15:05:50 <bosie> good evening
15:06:00 <astrolabe> hi bosie
15:06:17 <SamB> hmm, what should I do about this lhs file I have?
15:06:24 <astrolabe> SamB: I use AVG anti-virus, which seems ok.
15:06:25 <SamB> haddock doesn't seem to like it...
15:06:41 <bosie> how do i iterate through an [[Int]] calculating the values of each index of the subelements toghether
15:07:51 <Itkovian> bosie: example?
15:08:15 <bosie> [[3,2,1],[1,2,3],[2,2,2]] => [6,6,6]
15:08:18 <bosie> ok sucks
15:08:21 <musasabi> @eval map sum [[1,2,4],[],[0,1],[5,7]]
15:08:22 <lambdabot> [7,0,1,12]
15:08:41 <bosie> musasabi doesnt really calculate the index
15:09:09 <Itkovian> bosie: what exactly doe you mean by index?
15:09:16 <musasabi> bosie: "[[3,2,1],[1,2,3],[2,2,2]] => [6,6,6]" looked like sum.
15:09:33 * basti_ now tricked fucking autoconf and hopes it helped
15:09:53 <basti_> that thing truly breaks more than it repairs
15:09:55 <bosie> Itkovian well, i want to have the sum of each subelement's index
15:10:15 <SamB> @hoogle [[a]] -> [[a]]
15:10:16 <lambdabot> Data.List.transpose :: [[a]] -> [[a]]
15:10:24 <Itkovian> as in [1,4,5,6] -> sum [1..4]
15:10:30 <bosie> [[1,2,1],[1,2,7],[2,2,2]] => [4,6,10]
15:10:48 <bosie> the sum of all integers of the first index of the sublements is 4
15:10:50 <bosie> 1+1+2
15:10:54 <astrolabe> Coo. it's like an iq test
15:11:07 <SamB> > map sum $ transpose [[1,2,1],[1,2,7],[2,2,2]]
15:11:09 <lambdabot> [4,6,10]
15:11:28 <bosie> sweet
15:11:31 <Itkovian> ok, now I get it
15:11:46 <Itkovian> man, what a difficult question for something simple
15:11:47 <astrolabe> 'index' was just there to throw us the wrong way
15:11:58 <bosie> astrolabe why? ;)
15:12:14 <Itkovian> because it means something else
15:12:27 <astrolabe> Well, the index is a number that gives the position of an element in a list for example.
15:12:33 <bosie> well or not, actually i want to count the appearances of one specific number on each index/position/field-element
15:12:42 <bosie> astrolabe so i stand corrected
15:13:59 <bosie> for example: [[1,2,3],[2,2,3],[3,4,5]] => [1,0,0] because 1 appreas just once at the first index(whatever you call it) and then it never does again
15:14:19 <palomer> mein gott
15:14:29 <bosie> palomer what ?
15:14:33 <palomer> nothing
15:14:37 <bosie> k
15:15:04 <bosie> i actually have a function for doing it, the problem is i dont understand how i can change the list i want to iterate in haskell
15:16:05 <astrolabe> bosie: I find it very difficult to understand what you say.
15:16:13 <bosie> ok
15:16:52 <bosie> i have a function which iterates through an [[Int]] and sums up the appereances of a certain number on the first element of each subelement
15:17:11 <astrolabe> bosie: good so far
15:17:15 <bosie> ok
15:17:42 <bosie> now the problem is, how do i kick the first element of each subelement of [[Int]], so i can re-use my function
15:18:00 <astrolabe> kick?
15:18:03 <bosie> remove
15:18:26 <bosie> since my function i have so far just sums the first element of each subelement.
15:18:28 <astrolabe> map tail [[2,3],[4,5]]
15:18:38 <astrolabe> @eval map tail [[2,3],[4,5]]
15:18:40 <lambdabot> [[3],[5]]
15:19:07 <bosie> [[1,2,3],[1,2,3]] ... it has to iterate 3 times to get me a result
15:19:28 <astrolabe> @eval map tail [[1,2,3],[1,2,3]]
15:19:29 <lambdabot> [[2,3],[2,3]]
15:19:31 <bosie> yes
15:19:35 <bosie> i know that
15:19:44 <bosie> but that doesnt iterate, it just removes it
15:20:06 <Itkovian> bosie: recurse!
15:20:40 <Itkovian> bosie: you need to re-apply your function on the (map tail list) thingie until you have an empty list in the list
15:21:09 <bosie> Itkovian i cant see that fly, cos how do you actually pass the result then ?
15:22:05 <Itkovian> bosie: if f is your fuinction, you do e.g. my_index_thingie list = f list : my_index_thingie (map tail list)
15:22:43 <Itkovian> in the end you'll have [f list , f list' , f list'' , ... ]
15:23:06 <Itkovian> @type iterate
15:23:06 <palomer> recursion is for chumps
15:23:07 <lambdabot> forall a. (a -> a) -> a -> [a]
15:23:08 <palomer> real men use for loops
15:23:17 <Itkovian> palomer: no, they don't
15:23:25 <bosie> Itkovian hmmm
15:23:37 <bosie> and f being my function or what?
15:23:45 <SamB> palomer: not in haskell they don't, not unless they just do a quick "let for = foldr in"...
15:23:51 <Itkovian> yes.
15:24:07 <bosie> being my functino which will get me the sum ?
15:25:17 <astrolabe> bosie: look at Itkovian's function, and try to work out what it does.
15:25:54 <bosie> astrolabe throwing an exception ;)
15:25:56 <Itkovian> bosie: if you call that the sum, yes :-)
15:26:15 <astrolabe> very nearly yes
15:26:25 <Itkovian> bosie: are all internal lists of equal length?
15:26:31 <bosie> Itkovian yes
15:26:35 <Itkovian> ok
15:30:13 <DukeDave> hi guys, what is the address of the pastebin used in this channel?
15:31:05 <bosie> so "f list" is an integer, since f returns an int, and then it calls my_index_thingie again, which a list which is actually shortened by the head. right ? so it creates a list with all the "f list" results ?
15:31:18 <Itkovian> yes
15:31:27 <Itkovian> it will build an [Int]
15:31:34 <bosie> the adding to the [Int] is done via the : ?
15:32:23 <astrolabe> @eval 3 : [4,5]
15:32:24 <lambdabot> [3,4,5]
15:32:26 <Itkovian> bosie: yes. the (:) is the list 'construction' operator
15:32:38 <bosie> astrolabe yes but actually you are building it from the bottom
15:32:42 <Itkovian> [1,2,3] == 1:2:3:[]
15:32:44 <bosie> astrolabe that kinda confuses me
15:32:55 <Itkovian> bosie: you append at the front
15:33:04 <Itkovian> bosie: i.e. you prepend
15:33:34 <Cale> every list of type [a] is one of two things: either [] or (x:xs) where x is of type a and xs is of type [a]
15:33:36 <bosie> Itkovian you have the my_index_thingie at the end, so actually it creates the list and just the first call (the starter call) of my_index_thingie gets appended ?
15:34:06 <bosie> the "starter call" gets prepended
15:34:34 <astrolabe> bosie: I think you've got it
15:34:49 <Itkovian> yeah
15:34:58 <bosie> sweet
15:36:00 <bosie> hm
15:36:21 <bosie> why do i get an exception "Prelude.tail: empty list"
15:36:21 <astrolabe> The trick is to suppose that my_index_thingie works properly for (map tail list), and then work out what it should be on list in terms of that.
15:36:24 <shapr> SamB: I'm definitely full of it. That's what they tell me at least.
15:36:31 <shapr> @past
15:36:31 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:36:32 <astrolabe> bosie: good question
15:36:43 <shapr> @paste DukeDave here's the pastebin
15:36:44 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:37:04 <bosie> you guys should put paste.lisp.org in the topic of the channel imo
15:37:18 <shapr> bosie: Why?
15:37:27 <shapr> It doesn't do Haskell highlighting.
15:37:28 <bosie> shapr so people know where to paste code?
15:37:33 <DukeDave> lol that's it!
15:38:07 <astrolabe> shapr: could you have a squint at my problem at the top of the paste page please?
15:38:25 <shapr> Sure, I'll take a moment.
15:38:29 <lisppaste2> bosie pasted "exception for no reason" at http://paste.lisp.org/display/13314
15:38:39 <bosie> shapr and you see how sweet it works ? ;)
15:39:12 <shapr> bosie: It doesn't have Haskell highlighting.
15:39:18 <bosie> shapr okok
15:39:24 <shapr> So sweet is subjective.
15:39:32 <shapr> astrolabe: Isn't where like let* in elisp?
15:39:33 <bosie> sweet is always subjective
15:39:44 <shapr> Can't you put longFunc into the where and it just works?
15:39:47 <astrolabe> bosie: what do you think itkovians function will do when it gets applied to [[],[],[]] ?
15:40:05 <bosie> astrolabe doesnt the null cover that ?
15:41:06 <astrolabe> @eval null [[],[],[]]
15:41:07 <lambdabot> False
15:41:11 <bosie> doh
15:41:23 <astrolabe> shapr: thanks, I'll think about that.
15:42:25 <Itkovian> bosie: make a difference between null $ head list and otherwise ...
15:43:09 <SamB> shapr: would you like to review my TrackerClient module?
15:43:25 <bosie> Itkovian yea did that now
15:44:42 <bosie> the only thing which doesntw ork is ... how do i return the built list when null $ head list is true?
15:45:06 <SamB> shapr: You can pull my patches from http://naesten.dyndns.org:8080/repos/conjure-SamB
15:45:48 <astrolabe> bosie: what list do you want to return when that's true?
15:46:24 <bosie> astrolabe i build a list of Ints
15:46:30 <bosie> : my_index_thingie (map tail list)
15:46:41 <bosie> so actually if its null i just wanna return kinda
15:46:56 <bosie> i must be brain dead
15:46:59 <bosie> solved
15:49:58 <SamB> bosie: that happens a lot when you learn haskell
15:50:41 <SamB> Haskell can be hard to fit your brain around, but at least you usually KNOW where your problem is
15:51:10 <bosie> i hope thats the case for me too ;)
15:54:10 <SamB> anyone else want to review my code?
15:54:25 <Itkovian> no, we trust you :-)
15:54:50 <SamB> for great Justice!
15:54:59 <SamB> actually, its for BitTorrent
15:55:40 <dcoutts> hi dons
15:56:00 * SamB shoves his code in dons' face
15:56:19 <dons> hey guys
15:56:30 <SamB> repo http://naesten.dyndns.org:8080/repos/conjure-SamB and module TrackerClient.hs
15:57:02 <Itkovian> night
15:57:28 <SamB> review! it must be reviewed!
15:57:41 <dons> hehe
16:00:26 <SamB> I just hope we can get it all done in 10000 lines, we are already at 1530
16:01:39 <dons> cool :)
16:01:46 <dons> 10k is a lot though
16:03:08 <bosie> is there a special IDE for haskell ?
16:03:12 * SamB tests it against a real torrent
16:03:19 <SamB> bosie: in production
16:03:26 <bosie> ok
16:04:13 <SamB> I overhauled MiniHTTP so the TrackerClient code wouldn't need to do all the work, too
16:05:26 <dons> bosie : emacs or vim. we're working on an ide
16:05:40 <dons> oh, Visual haskell on windows is a specialit ide
16:05:55 <dons> and Eclipse has good haskell support, I think.
16:06:01 <SyntaxNinja> back
16:06:20 <SamB> it supports virtual hosts, too
16:06:52 <SamB> I had to test it to make sure, but it does!
16:07:14 <dcoutts> dons, I need to get back to working on hIDE
16:07:22 <SyntaxNinja> dcoutts: thanks for the writeup
16:07:27 <dcoutts> SyntaxNinja, np
16:07:31 <SamB> you might also try running "make test" and then ./a.out
16:07:43 <SamB> oh, and pass it a torrent file ;-)
16:07:55 <dons> astrolabe, btw, you can use this syntax for @eval now:
16:07:57 <dons> > 1 + 2
16:07:58 <lambdabot> 3
16:08:10 <dcoutts> SyntaxNinja, btw I think the front page for that tracker could be rather simpler. It's got a lot of "stuff" on it.
16:08:23 <dcoutts> it's not immediately obvious what to do
16:13:20 <SyntaxNinja> dcoutts: you mean the wiki page itself, or the sorta template page that has the menus and such?
16:14:05 <SyntaxNinja> dcoutts: were you thinking of hacking together any of those items? have you talked to simon about making --make work w/ --split-objs?
16:18:01 <bosie> http://paste.lisp.org/display/13315
16:18:01 <bosie> how is it possible that i have an exception here, although the sigs are completely identical
16:19:00 <SyntaxNinja> bosie: what's the error?
16:19:18 <bosie>  Couldn't match `([[Int]], [[Int]])' against `t -> t1'
16:19:18 <bosie>    Expected type: ([[Int]], [[Int]])
16:19:18 <bosie>    Inferred type: t -> t1
16:19:18 <bosie>    Expected type: ([[Int]], [[Int]])
16:19:18 <bosie>    Inferred type: [[Int]] -> ([[Int]], [[Int]])
16:19:19 <bosie>  Probable cause: `teile' is applied to too few arguments in the call
16:19:21 <bosie>      (teile (strings ints))
16:19:52 <sh10151> this darcs thing looks pretty sweet
16:20:40 <sh10151> i notice it's latex .lhs, is the output available for download anywhere?
16:21:38 <SamB> bosie: why do you not write your code in English?
16:21:59 <SamB> sh10151: you mean the manual?
16:22:14 <bosie> we arent allowed fro muniversity to do so, so i code in german cos i dont want to write in english now and have to rethink at the exams
16:22:33 <SamB> bosie: ah. strange rules...
16:22:34 <SyntaxNinja> bosie: you are only passing one param to teile the wya you have it written
16:22:49 <SyntaxNinja> bosie: get rid of the parens around it, so it should be "teile strings ints"
16:22:59 <SyntaxNinja> bosie: you don't need / want parens like in some other languages.
16:23:04 <SamB> bosie: I bet american universities would never think to restrict the language used for identifiers ;-)
16:23:07 <bosie> dang thx
16:23:24 <bosie> SamB yea cos what language do you guys speak other than english? ;)
16:23:29 <SamB> then again, they don't usually teach Haskell either...
16:23:57 <sh10151> SamB: I don't think so, there's inline code in the darcs source.
16:23:59 <SyntaxNinja> bosie: function calls only need parens in certain cases, f (f1 2) (f2 3) is perfectly fine, but htat's a bit different.
16:24:23 <sh10151> maybe the .ps contains it, the HTML version doesn't
16:24:24 <SamB> bosie: well, there is gibberish
16:24:30 <SyntaxNinja> sh10151: it might be the appendix to the manual.
16:24:34 <bosie> SyntaxNinja so i tried fst teile strings ints and that doesnt work either
16:24:43 <SamB> sh10151: the code is specifically elided from the manual
16:24:59 <sh10151> yes, that makes sense but now I want to see it inline :)
16:25:03 <dons> we don't restrict language used for idents here, but sometimes it can be hard to mark such code
16:25:04 <dcoutts> SyntaxNinja, I was referring to the wiki page, but also the template with the big trac logo that links to the trac site is misleading.
16:25:10 <sh10151> it's ok, I needed tetex on this computer anyway
16:25:23 <SamB> believe me, I had to jump through hoops to get the code in the output, but I wasn't too thrilled when I got it to work
16:25:36 <SyntaxNinja> dcoutts: yeah, I can clean that up to have a different logo and such.
16:25:41 <sh10151> i am wanting to look at the code rather than learn use darcs at this moment
16:26:04 <SamB> maybe they've cleaned it up since, dunno
16:26:15 <dcoutts> SyntaxNinja, I was considering hacking together one of those systems however I'm not sure which would be appropriate. I've not asked JaffaCake about making --make work w/ --split-objs but he mentioned before that he wouldn't mind making -split-objs somewhat easier to use.
16:26:16 <SyntaxNinja> I'm guessing it's just the patch logic.
16:26:29 <SyntaxNinja> dcoutts: maybe he just needs some prodding
16:26:37 <dcoutts> SyntaxNinja, yeah, probably
16:26:38 <SyntaxNinja> (poor jaffacake)
16:26:43 <dcoutts> indeed
16:26:58 <SamB> use a low-sting prod
16:27:03 <dcoutts> SyntaxNinja, I implemented it for Gtk2Hs, but Gtk2Hs doesn't use ghc --make
16:27:24 <dcoutts> SyntaxNinja, so it'd be different for Cabal.
16:27:38 <ricebowl> does Prelude.lex parse out [a-zA-Z0-9_]?
16:27:46 <SyntaxNinja> dcoutts: what does it to for dependencies? use some ghc makefile output?
16:28:02 <dcoutts> SyntaxNinja, yeah we use ghc -M to generate the deps
16:28:22 <SyntaxNinja> yeah. makes sense.
16:28:34 <SyntaxNinja> how many times must dependency analysis code be written? ;)
16:28:39 <SamB> lex (['a'..'z']++['A'..'Z']++['0'..'9']++"_ f")
16:28:40 <dons> hehe
16:28:43 <dcoutts> SyntaxNinja, we need to use deps rather than just ghc --make since we've also got deps between .chs files!
16:28:44 <SamB> > lex (['a'..'z']++['A'..'Z']++['0'..'9']++"_ f")
16:28:46 <lambdabot> [("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"," f")]
16:28:46 <SyntaxNinja> I bet JohnMeacham wrote it from scratch too
16:29:01 <dons> and hmake too
16:29:03 <ricebowl> SamB - yes, but does it include other characters as well or not?
16:29:16 <SyntaxNinja> I'm hoping someone will help me steal it from hmake, with permission of course.
16:29:18 <dcoutts> SyntaxNinja, on, no, we're just using make (with automake+autoconf).
16:29:42 <dcoutts> SyntaxNinja, does Cabal deal with .chs deps? I bet not at the moment.
16:29:45 <SyntaxNinja> dcoutts: yeah, I understand.
16:30:02 <SyntaxNinja> what do you mean exactly?
16:30:07 <kpreid_> bosie: when using paste.lisp.org, don't forget to choose #haskell from the channel list
16:30:23 <dcoutts> SyntaxNinja, .chs files can depend on each other since they can import each other.
16:30:45 <dcoutts> SyntaxNinja, c2hs generates .chi files when it processes a .chs file to a .hs file.
16:30:58 <kpreid_> bosie: (your paste got announced in #lisp)
16:31:10 <SamB> > map fst $ filter ((==1). snd) [(c, length (lex ['a',c,'z']) | c <- ['\0'..'\255']]
16:31:11 <lambdabot>  parse error on input `|'
16:31:18 <SamB> > map fst $ filter ((==1). snd) [(c, length (lex ['a',c,'z'])) | c <- ['\0'..'\255']]
16:31:19 <dcoutts> SyntaxNinja, and processing a .chs file that imports another .chs module needs to read the .chi file for that other module.
16:31:19 <lambdabot> "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\
16:31:19 <lambdabot> SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@
16:31:19 <lambdabot> ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\
16:31:19 <lambdabot> 129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\144\145\146\
16:31:19 <lambdabot> 147\148\149\150\151\152\153\154\155\156\157\158\159\160\161\162\163\164\
16:31:21 <lambdabot> [6 @more lines]
16:31:38 <SyntaxNinja> SamB: can you take this interpreter conversation elsewhere? :)
16:31:49 <SamB> sorry.
16:32:01 <dcoutts> SyntaxNinja, so for the Gtk2Hs build system we wrote a little script that produces make-style deps for a .chs file.
16:32:14 <dcoutts> SamB, #haskell-overflow
16:32:45 <SyntaxNinja> dcoutts: for now, the user is required to list the modules by hand; for executables, we use ghc --make, so if --make is broken somewhere, then yeah, it won't work.
16:32:59 <dcoutts> SyntaxNinja, this is different.
16:33:31 <dcoutts> SyntaxNinja, it's not about discovering all the modules automatically. It's about doing the c2hs preprocessign in the right order.
16:33:50 <dcoutts> SyntaxNinja, just like we must compile modules in the right order.
16:33:52 <bosie> oki toki i am off to bed, thank you very much guys for helping me out
16:33:57 <SyntaxNinja> dcoutts: ahh. yeah, we're pretty dumb here right now. we just do all preprocessing first, in the order we come across it.
16:34:08 <SyntaxNinja> later bosie
16:34:22 <dcoutts> SyntaxNinja, right. That will not work for c2hs in any non-trivial package.
16:35:07 <dcoutts> SyntaxNinja, so that's another reason to use hmake-style deps, and with the ability to extend it for extra tools (like ch2s).
16:35:49 <dcoutts> SyntaxNinja, and what's worse is that you might not discover the deps until after processing some others!
16:35:51 <dcoutts> aaarg.
16:35:55 <dcoutts> for example...
16:36:09 <dcoutts> suppose you preprocess a .chs.cpp file to a .chs file
16:36:30 <dcoutts> you don't know the deps of the .chs file until you've done the preprocessing
16:37:13 <SyntaxNinja> dcoutts: yeah.  it would be nice to have a killer solution in cabal, although I don't know how many packages are as preverted as gtk2hs ;)
16:37:25 <dcoutts> heh :-)
16:37:32 <dcoutts> cairo?
16:38:07 <dcoutts> it'd be a nice stepping stone on the way to the full perversion of gtk2hs :-)
16:38:22 <dcoutts> it uses c2hs with deps but is otherwise quite sane
16:38:35 <dcoutts> not much cpp'ism
16:38:54 <SyntaxNinja> hehe
16:39:02 <SyntaxNinja> we can't even do .chs.cpp yet.
16:39:11 <dcoutts> right
16:39:26 <SyntaxNinja> I think I want to force ppl to name files based on the preprocessors they use, and in the order they want them preprocessed.
16:39:26 <dcoutts> we have to conditionally complie for different versions of Gtk+
16:39:49 <dcoutts> SyntaxNinja, yes, which is why Gtk2Hs already does that.
16:39:56 <SyntaxNinja> I wonder how many people get the Dr. Strangelove reference when I say "preversions"
16:40:11 * dcoutts doesn't get it
16:40:28 <dcoutts> though I havn't watched the film for a few years
16:40:45 <SyntaxNinja> eh, doesn't matter, but it's funny to me.
16:40:51 <sh10151> SyntaxNinja: you'll have to answer to the coca-cola company
16:40:55 <SyntaxNinja> hehe
16:41:17 <dcoutts> SyntaxNinja, our precious bodily fluids?
16:41:22 <dcoutts> and the commie preversions?
16:41:24 <SyntaxNinja> probably I just cause people to think I'm stupid / can't spell.  I guess they're not very wrong if they think so anyway ;)
16:42:00 <SamB> @hoogle (a -> Bool) -> [a] -> ([a], [a])
16:42:01 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
16:42:01 <lambdabot> Data.List.break :: (a -> Bool) -> [a] -> ([a], [a])
16:42:01 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
16:42:35 <SyntaxNinja> dcoutts: yeah, something like that. I think it's the guy who comes and "rescues" the brit.
16:45:26 <sh10151> it is, that's keenan wynn
16:45:45 <dcoutts> SyntaxNinja, perhaps it'd be easier to pinch the deps code out of ghc rather than hmake
16:46:05 <dcoutts> at least the license would be ok
16:46:50 <dcoutts> and then extend it to cope with other tools and discovering deps after each step rather than all at the beginning
16:47:35 <dcoutts> it'd be cool if one could add code via the hooks interface or something to add a custom processor
16:48:03 <dcoutts> eg register a tool that can find the deps for a ".xyz" extension
16:48:30 <dcoutts> or rather register a callback function that can find the deps
16:49:23 <dcoutts> and ideally these should be cached themselves so that cabal can be used for the normal build system and not just a distribution time build system
16:49:43 <dcoutts> that's make's great strength that you can do: $ make
16:49:59 <dcoutts> and it'll discover very quickly that there is nothing to do
16:50:22 <dcoutts> ghc --make is much less good at that because it doesn't cache anything and it must re-read all the files.
16:50:35 <dcoutts> (that's quite appart from the fact that it always relinks)
16:50:52 <SyntaxNinja> I wonder why it always relinks.
16:51:10 <SyntaxNinja> as for pinching the code from GHC, I'm all for it :)
16:51:22 <dcoutts> 'cos it never had any logic for deciding no to?
16:52:27 <SyntaxNinja> yeah, it would make perfect sense to add a function to the PreProcessor hooks to compute dependencies for that file; making the default "preprocess me, then run the normal dependency analysis on me"
16:53:35 <dcoutts> hmm, isn't it the other way around?
16:53:44 <dcoutts> eg for .chs
16:54:01 <dcoutts> you compute the deps, make sure they are satisifed and then run the preprocessor
16:57:13 <SyntaxNinja> I mean that you can't run a "normal" haskell dependency analysis on unpreprocessed source, like cpp'd source.
16:58:06 <SyntaxNinja> does anyone want to make a cabal logo?
16:59:07 <dcoutts> SyntaxNinja, right
16:59:21 <dons> SyntaxNinja, run a competition :) it worked for lambdabot
16:59:31 <dons> the winner gets the prize of winning
16:59:54 <SyntaxNinja> heh
17:00:05 <SyntaxNinja> lambdabot has a logo?
17:00:18 <dons> @where lambdabot
17:00:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:00:23 <dons> dcoutts won, in fact.
17:00:38 <SyntaxNinja> oh heh
17:00:47 <dcoutts> SyntaxNinja, so for example, with the gtk2hs build system, running make in a already-built build tree stats >250 files and takes .3 seconds to decide that there is nothing to do. That's pretty good I'd say.
17:01:10 <dcoutts> dons, oh yeah, so I did :-)
17:01:23 <SyntaxNinja> dcoutts: why does ghc read the .hi files instead of looking at stat time?
17:01:24 <dcoutts> dons, where is the logo on display? I never saw it up.
17:01:34 <dons> on the lambdabot site above ^^
17:01:42 <dcoutts> dons, oh :-)
17:01:51 <dons> @google lambdabot
17:01:51 <dcoutts> nice :-)
17:01:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:01:55 <dons> ^^ there
17:02:06 <SamB> lambdabot has a site?
17:02:11 <dons> why not?
17:02:23 <dons> it must be one of the more harder working haskell apps out there
17:02:27 <SamB> seems kinda superfluous
17:02:43 <SyntaxNinja> I always wanted an original logo for cabal that's something like this: http://www.haskell.org/hawiki/LibraryInfrastructure_2fComments#head-e04894881907f0472c2a7afd8c722d61000d4d2a
17:02:45 <dons> it's really just a pointer to the wiki and the darcs repo
17:03:25 <dcoutts> SyntaxNinja, not entirely sure. Ask JaffaCake for a definitive answer. However I think it might because tracking deps for Haskell is slightly more complex than just checking the modification times of imports. A module can be affected by indirect imports.
17:03:26 <SyntaxNinja> some day all web pages will just be pointers to wikis and darcs repos.
17:03:42 <dons> hehe
17:03:46 <SamB> lambdabot has a wiki?
17:03:57 <SamB> oh, no, just the haskell wiki
17:04:02 <dons> 11:56  SamB:: lambdabot has a site?
17:04:09 <dons> SamB is surprised today :)
17:04:17 <SamB> hehe
17:04:23 <SyntaxNinja> heh, I like the way this conversation has progressed, "Lambdabot has a logo? ... Lambdabot has a site? ... Lambdabot has a wiki?"
17:04:42 <dons> oh dear.
17:04:46 * dcoutts grins
17:04:48 <SyntaxNinja> I should run a contest to see who gets to run a contest to design a cabal logo
17:04:50 <dons> ok. I should put that on the site then.
17:05:01 <dons> good idea!1
17:07:29 <SamB> what I want to know is, how did lambdabot's website get to the #1 spot on google?
17:08:03 <dcoutts> SamB, know of any other lambdabot?
17:08:44 <SamB> as opposed to the wiki page, or IRC logs, or...
17:08:49 <dcoutts> SamB, actually I reckon it's simply by the frequent appearance in IRC logs of:
17:08:51 <dons> SamB, i'm surprised at your surprise.
17:08:51 <dcoutts> @version
17:08:51 <lambdabot> lambdabot 3p168, GHC 6.5.20050806 (Linux i686)
17:08:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:09:25 <dons> it's mentioned on the mailing lists, on the haskell site, on my (fairly well indexed) unsw.edu.au site, on a few darcs repos, and the irc logs
17:09:26 <SamB> but that isnt the same thing at all
17:09:38 <SamB> oh, okay, I give in, it isn't that hard
17:09:52 <dons> just ending up on a unsw.edu.au page is often enough
17:09:55 <dcoutts> oh yeah, going via unsw.edu.au will help its ranking a lot
17:10:56 * dcoutts became #1 hit on google for his name after starting a PhD and getting a personal page on the department web site
17:11:09 <dons> i wonder if my ipod page is indexed yet:
17:11:13 <dons> @google ipod openbsd
17:11:13 <lambdabot> http://archives.neohapsis.com/archives/openbsd/2005-10/1783.html
17:11:16 <dons> nope.
17:11:20 <dons> oh well, only 1 day old
17:11:32 <dons> @google thinkpad openbsd
17:11:33 <lambdabot> http://www.monkey.org/~dugsong/thinkpad-x20/
17:11:42 <dons> @google haskell openbsd
17:11:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
17:11:45 <dons> ah ha!
17:11:57 <SamB> @google SamB
17:11:58 <lambdabot> http://www.samb.co.uk/
17:12:03 <SamB> @google naesten
17:12:04 <lambdabot> http://www.festsange.dk/
17:12:06 <SamB> huh?
17:12:14 <SamB> is that a word in some language?
17:12:21 <dons> in .dk
17:12:22 <dcoutts> @google haskell gentoo
17:12:23 <dons> maybe ??
17:12:24 <lambdabot> http://gentoo.linuxhowtos.org/browseportage/browseportage.htm?portagecat=dev-lang/ghc
17:12:35 <SamB> @google "naesten@gmail.com"
17:12:37 <lambdabot> http://www.reactos.org/archives/public/ros-svn/2005-August/005037.html
17:13:17 <SamB> hmm, I probably shouldn't be mentioning my email in public like this...
17:14:02 <SyntaxNinja> you guys know... there are these things called "web browsers"
17:14:06 <SyntaxNinja> ;)
17:14:15 <dons> oh boo :p
17:15:43 <SamB> SyntaxNinja: they aren't shared!
17:16:07 <SamB> and they are big, memory hungry, slow creatures at that
17:17:31 <Cale> vx.hn.org/autoshare/Cabal1.png
17:17:39 <Cale> there's a simple first idea
17:18:35 <SyntaxNinja> Cale: it's cute! you could rotate the box to make it look more like a lambda :)
17:18:38 <Cale> :)
17:18:52 <SyntaxNinja> everything has to have a lambda
17:18:57 <Cale> heh
17:19:15 * SamB wishes he could strike out that line about jlouis having done all the bugs in Conjure, seeing as SamB put in some buggy code too
17:20:02 <SyntaxNinja> Cale: thanks for that! Are you going to keep refining it?
17:20:10 <Igloo> I'm sure you can get 10 lambdas into the pentagram if you tried hard enough
17:20:23 <dcoutts> SyntaxNinja, absolutely! Have you seen the Gtk2Hs logo?
17:20:23 <Cale> yeah
17:20:32 <dcoutts> see the 3rd entry on: http://planet.gnome.org/news/
17:20:34 <Cale> I'll put up a slightly rotated version right away :)
17:21:08 <dcoutts> http://planet.gnome.org/heads/logos/gtk2hs.png
17:21:45 <dcoutts> oh wait a sec! We ended up going with the version of the logo that doesn't use the lambda! Doh!
17:21:55 <Igloo> Heh
17:21:59 <SyntaxNinja> dcoutts: heh OK good. I thought I was nuts there for a sec
17:22:01 <dcoutts> originally one of the faces had a lambda
17:22:12 <dcoutts> oops :-)
17:22:38 <Igloo> No lambda on the wxhaskell logo either. Geez, are there no decent GUI libraries for Haskell?!
17:22:38 <Cale> http://vx.hn.org/autoshare/Cabal2.png -- slightly rotated
17:22:43 * dons thinks class Binary should be at least as derivable as Typeable
17:22:56 <SamB> Igloo: they are decent, they just have shameful logos!
17:22:59 <dons> it's a bit of a mystery that it isn't, I think. Binary rules!
17:23:24 <Cale> NFData should be as derivable as Data
17:23:34 <SamB> Cale: what is that?
17:23:44 <Cale> Control.Parallel.Strategies
17:24:10 <Cale> It defines rnf for reducing values to normal form.
17:24:20 <SamB> dons: well, Typeable doesn't require all of the subvalues to be Typeable...
17:24:21 <Cale> (basically like deepSeq)
17:24:25 <dcoutts> http://haskell.org/~duncan/gtk2hs/Gtk2Hs-logo-with-lambda-nobg.png
17:24:29 <SyntaxNinja> Cale: I like that; it suggests the lambda without beating you over the head with it.
17:24:30 <dcoutts> there!
17:24:37 <SyntaxNinja> dcoutts: cool.
17:24:58 <SyntaxNinja> it also suggests pac-man eating a star, which is also good
17:25:11 <SyntaxNinja> ahh pac man
17:25:25 <Cale> I suppose it would suggest the lambda more if it was flipped :)
17:25:47 <SyntaxNinja> oh yeah
17:25:59 <SyntaxNinja> <--- broke his brain looking for the lambda in the gtk2hs logo
17:26:10 <heatsink> dons: how would one put (repeat ()) ?
17:26:27 * dcoutts appologises to SyntaxNinja for breaking his brain
17:27:04 <SamB> I do not get the suggestion...
17:27:56 <Cale> http://vx.hn.org/autoshare/Cabal3.png
17:28:16 <SyntaxNinja> Cale: best yet! ;)
17:28:21 <SamB> ah, now I think I see one
17:28:23 <dcoutts> Cale, I preferred the original :-)
17:28:23 <SyntaxNinja> (17:24:09) SyntaxNinja: Cale: I like that; it suggests the lambda without beating you over the head with it.
17:28:28 <dcoutts> but with a lambda!
17:28:51 <SamB> between the star and the upper face of the cube?
17:28:51 <Cale> this one has a secret lambda which is implied by the angles :)
17:28:52 * heatsink thought Cabal2 had more lambda in it than Cabal3
17:29:01 <Cale> hmm :)
17:29:13 * dcoutts completely fails to spot the lambda
17:29:17 <SyntaxNinja> Cale: at least you're making everyone happy
17:29:31 <SamB> Cale: animate it!
17:29:35 <Cale> heh :)
17:29:45 <SyntaxNinja> dcoutts: cabal3 has a lambda, the light blue part is like part of the backslash
17:29:47 <SamB> then everyone can be happy with one version, but also hate it!
17:29:55 <SyntaxNinja> the dark blue part is the missing bit from the backslash
17:30:13 <dcoutts> SyntaxNinja, hmm, I suppose so
17:30:14 <Cale> λ
17:31:02 <Cale> perhaps it shouldn't be so horizontally aligned
17:31:05 <dons> heatsink? you mean how to serialise an infinite structure? how does one 'show' such a structure too?
17:31:14 <Igloo> Where's the lambda in 2 supposed to be?
17:31:31 <dons> don't write infinite data is the lesson.
17:31:59 <Cale> Igloo: well, I think it's backwards actually
17:32:41 <Cale> btw, inkscape rules :)
17:33:22 <palomer> writing infinite data?
17:33:24 <palomer> on an infinite disk?
17:33:33 <Igloo> There's a nice lambda hidden in 2's pentagram, actually. The 2 almost vertical lines on the left along with the continuation of one of them chopping off the bottom left point.
17:34:03 <heatsink> Igloo: But haskell doesn't have true continuations
17:34:12 <Cale> http://vx.hn.org/autoshare/Cabal4.png -- another rotation
17:34:21 <SamB> heatsink: what in the world can you mean?
17:34:26 <palomer> I always wondered why haskell didn't have true continuations
17:34:27 <palomer> why is this?
17:34:48 <Cale> palomer: you mean with call/cc ?
17:34:53 <palomer> yeah
17:34:54 <SamB> heatsink: just because we don't have stack-snapshots, doesn't mean there is something wrong with our continuations...
17:34:54 <SyntaxNinja> anyone else want to try a cabal logo?
17:34:57 <Cale> because call/cc isn't really a function
17:35:02 <heatsink> dons: In general, serializing N data can use 2^N disk space
17:35:03 <palomer> yeah
17:35:06 <palomer> it's an operator
17:35:10 <Cale> it's context sensitive
17:35:14 <palomer> righto
17:35:16 <heatsink> dons: at least.  I don't know if that's worst-case.
17:35:23 <Cale> and breaks referential transparency
17:35:26 <heatsink> dons: not couting the infinite thing :)
17:35:42 <heatsink> SamB: You can't implement coroutines with continuations.
17:35:42 <Cale> I think I like 4 the best so far myself :)
17:35:47 <heatsink> SamB: ... in haskell.
17:36:09 <SamB> heatsink: why would you want to?
17:36:20 <SyntaxNinja> Cale: don't suppose you could put together a cat-based logo? :)
17:36:25 <dons> heatsink, but Binary is still better than Read
17:36:27 <SamB> do you lack in exploded brains?
17:36:34 <Cale> though I'd have to remember to leave enough whitespace on the left edge that the implied box wouldn't smash into the side of the browser window like that
17:36:36 <dons> using Read is way worse than Binary. so we should have Binary
17:36:42 <heatsink> SamB: gord came here a while back with a parser problem, and the solution was to rewrite his parser in CPS.
17:37:11 <SamB> heatsink: and how would you do proper continuations in a pure language?
17:37:16 <heatsink> dons: Okay.
17:37:16 <Cale> SyntaxNinja: I could try, that's a bit more work than simple shapes :)
17:37:24 <heatsink> SamB: I haven't thought about that.
17:37:32 <Cale> CPS is best delegated to a monad
17:37:51 <SamB> Cale: unfortunately, there is no ParserT
17:37:58 <SamB> at least, not in Parsec
17:38:12 <SyntaxNinja> Cale: could ya? :)
17:38:16 <dcoutts> Cale, make sure you share the .svg file when you win the competition. :-)
17:38:17 <Cale> Someone should transformerify Parsec
17:38:22 <heatsink> dons: I haven't experienced Binary, really.
17:38:23 <Cale> dcoutts: yeah
17:38:29 <SamB> Cale: yes
17:39:08 <dons> it's to Read/Show as Packed Strings are to Strings
17:39:43 <dons> a minimal space implementation providing equivalent functionality, with improved performance. .hi files are put/get via the Binary class
17:39:49 <SamB> so clumsier and harder to use?
17:39:58 <dons> SamB :p
17:40:17 <SamB> the sword cuts both ways :P
17:40:25 <heatsink> int resting;
17:40:43 <dons> SamB, are FastStrings harder to use?
17:40:45 <Cale> heh, I think I'll try sketchifying that cat statue
17:40:53 <dons> Binary certainly is. not much harder, but a little
17:40:58 <dons> hence it should be deriivable
17:40:59 <SyntaxNinja> Cale: or you could carve a new statue and take a photo of it ;)
17:41:07 <SyntaxNinja> Cale: no idea on rights of that statue, btw.
17:41:32 <SamB> @index FastString
17:41:33 <lambdabot> bzzt
17:41:35 <SyntaxNinja> OK I gotta run. TTYL! Cale feel free to link any logos from new cabal wiki: http://hackage.haskell.org/cgi-bin/trac/trac.cgi/wiki
17:41:47 <SamB> well, we'd need Binary in the library before it could be derivable...
17:41:56 <dons> yes.
17:42:09 <dons> it's in NHC's libs. and ghc's utils.
17:42:21 <dons> and you can derive it with DrIFT
17:42:29 <dons> but it's so useful it should be derivable to all
17:42:39 <dons> SamB FastString from my packed string library.
17:42:46 <SamB> oh
17:42:48 <dons> you don't use it?? ;)
17:42:58 <dons> @where fps
17:42:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:43:54 <SamB> no, I haven't actually had issues with the regular strings yet...
17:44:56 <dons> ah, i've had a few for large applications doing lots of string work, and fast strings really kick butt. lambdabot had 90% less space usage once I switched to fast strings for persistent state
17:45:07 <dons> for the large data bases, like the @index db
17:45:32 <dons> similar speedups in h4sh. they're critical in darcs and yi too
17:45:38 <dons> also ghc uses them all over the place
17:46:02 <dons> fortunately, most apps get by without them.
17:47:46 <heatsink> ninety?!
17:48:16 <dons> of course. it's not that surprising I think.
17:48:32 <SamB> heatsink: think of all the thunks!
17:48:33 <dons> boxed strings are big and slow compared to packed unboxed byte arrays
17:48:45 <heatsink> Hmm, each character is a cons cell with a boxed machine-character...
17:48:48 <dons> where == becomes memcmp
17:49:30 <heatsink> That's four pointers and a unicode value.
17:49:33 <SamB> dons: how would you parse one?
17:50:00 <dons> complex parsing I use Binary. simple parsing, I use PackedString utils (lines/split/take/drop)
17:50:28 <dons> I'd like to be able to do Binary.get straight from a FastString. that would be nice
17:50:37 <SamB> dons: what would you do for, say, BT's B-coding?
17:50:39 <dons> so: Binary a => FastString -> a
17:50:55 <dons> don't know what that is.
17:51:22 <dons> check the api anyway. it's just a List api to a ppacked byte array. space and time savings ensue
17:51:29 <SamB> dons: look at BEncode.BEncode in conjure
17:51:39 <dons> often you can just dropp in FastStrings anywhere you normally use Strings
17:51:56 <dons> plus you get fast IO with mmapFile :: FilePath -> IO FastString
17:52:22 <SamB> oops
17:53:15 <dons> if it's complex to parse i'd use Binary perhaps. if it's simple enough that youuu could write use list functions to parse it, then you could also use packed strings fns to parse it.
17:54:18 * SamB wonders why x-chat seems to think his "start" key is alt
17:54:35 <Cale> well, here's an abstracted version of that statue cat :) http://vx.hn.org/autoshare/kitty.png
17:55:41 <heatsink> purrty
17:58:12 <SamB> well, its recursive...
17:58:40 <Cale> I'll be back in a little while
18:00:25 <rlaager> Is there a standard function for calculating the cubic root of an Integer?
18:01:14 * heatsink thinks there isn't
18:01:27 <SamB> when does jlouis get up?
18:02:11 <dons> @seen jlouis
18:02:11 <lambdabot> jlouis is in #haskell. Last spoke 9 hours, 58 minutes and 17 seconds ago.
18:02:16 <dons> soon?
18:02:20 <dons> morning TheHunter_
18:02:26 <dons> oh, late night
18:02:31 <dons> @localtime TheHunter_
18:02:32 <lambdabot> Local time for TheHunter_ is Mon Nov  7 21:01:59
18:08:42 <luqui> @pl \x -> concat . (intersperse x)
18:08:43 <lambdabot> (join .) . intersperse
18:10:12 <heatsink> @pl \x -> case x of Left y -> x
18:10:12 <lambdabot> (line 1, column 24):
18:10:12 <lambdabot> unexpected ">" or "-"
18:10:12 <lambdabot> expecting variable, "(", operator or end of input
18:10:20 <heatsink> @pl \x -> case x of {Left y -> x}
18:10:21 <lambdabot> (line 1, column 17):
18:10:21 <lambdabot> unexpected "{"
18:10:21 <lambdabot> expecting variable, "(", operator or end of input
18:10:32 <heatsink> @pl \x -> (case x of Left y -> x)
18:10:32 <lambdabot> (line 1, column 25):
18:10:32 <lambdabot> unexpected ">"
18:10:32 <lambdabot> expecting variable, "(", operator or ")"
18:10:40 <heatsink> @pl \x -> (case x of Left y - x)
18:10:41 <lambdabot> (-) =<< flip (flip (flip case of) Left) y
18:10:48 <heatsink> heh
18:14:26 <luqui> is there a way in ghci to have a function definition span multiple lines?
18:14:38 <luqui> just for visual appeal; I know how to use {;}
18:16:04 <dcoutts> luqui, not so far as I know
18:16:28 <luqui> darn
18:26:26 <fworp> liqui: how do you mean? with {;}?
18:30:01 <SamB> http://naesten.dyndns.org:8080/repos/conjure-SamB/pjlester-1.11.tar.Z.torrent
18:31:38 <SamB> for great testing!
18:32:41 <SamB> you can use it to test the changes in http://naesten.dyndns.org:8080/repos/conjure-SamB/ relative to http://j.mongers.org/pub/haskell/darcs/conjure/
18:33:03 <fworp> you can just use indentation if you are breaking some expression up, to let the compiler know that 'you arent done'
18:37:18 <fworp> oh... ghci... dog
18:37:20 <fworp> doh*
18:37:31 * fworp didnt see the i
18:38:48 * fworp moves for a motion to strike
18:45:45 <dons> cool. switching to a binary format for the @seen state halved memory usage in lambdabot :)
18:46:11 <dons> lesson: reads is slow!
18:46:12 * SamB wonders why the tracker on http://tracker.mugen-anime.net/announce gives peers to when event=stopped, but the bittornado tracker doesn't
18:47:13 <SamB> dons: you are confusing memory usage with time!
18:47:29 <SamB> dons: anyway, there ARE 171 people in here
18:49:08 <edrx> I think that several years ago I saw a paper that described how all the features of relational databases could be implemented easily on top of haskell
18:49:23 <edrx> anyone remembers which paper was that? any pointers?
18:51:17 <edrx> hmm. wiki
18:52:42 <SamB> @google lazy relational
18:52:43 <lambdabot> http://www.hibernate.org/hib_docs/reference/en/html_single/
18:56:00 <SamB> @google lazy functional relational
18:56:01 <lambdabot> http://citeseer.ist.psu.edu/context/81143/109476
18:56:59 <SamB> well thats a paper at least
19:04:07 <edrx> http://www.cs.uu.nl/people/daan/download/papers/dsec.ps
19:04:29 <edrx> sorry, I found it and forgot to tell :|
19:04:31 <edrx> but thanks
19:09:13 <SamB> haskell purely functional (lazy?) relational database: http://www.cs.uu.nl/people/daan/download/papers/dsec.ps
19:09:21 <SamB> (for great Googling!)
19:18:27 <SamB> @localtime jlouis
19:18:29 <lambdabot> Local time for jlouis is Tue Nov  8 04:18:05 2005
19:29:42 <SamB> @google conjure samb
19:29:44 <lambdabot> http://www.learner.org/channel/workshops/hslit/session5/lessonplan1.html
19:33:59 <SamB> @google site:naesten.dyndns.org
19:34:01 <lambdabot> No result found.
19:39:26 <SamB> I can't help but notice that my Haskell implementation doesn't support TREX
20:18:54 <Korollary> haskell-mode 2.1 any good ?
20:33:05 <juhp> Setup.lhs: cannot satisfy dependency fps-any
20:33:05 <juhp> ********************
20:33:05 <juhp> setup configure failed for plugins/commonSense
20:33:22 <juhp> dons: where do I get that from?
20:33:35 <dons> @where fps
20:33:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:33:42 <juhp> cheers
20:33:45 <dons> :)
20:38:22 * juhp wishes there could be a final verdict on Setup.hs vs Setup.lhs ;o)
20:46:57 <luqui> what's that ctags program for haskell?
20:47:31 <juhp> luqui: hstags?
20:47:42 <luqui> nope, here it is, hasktags
21:15:01 <dons> autrijus: ping
22:38:20 <dons> @bot
22:45:54 <dons> @yow
22:45:54 <lambdabot> Now my EMOTIONAL RESOURCES are heavily committed to 23% of the SMELTING
22:45:54 <lambdabot> and REFINING industry of the state of NEVADA!!
22:46:21 <dons> @quit testing...
22:46:29 <dons> @seen dons
22:46:39 <lambdabot> You are in #haskell-overflow and #haskell. Last spoke just now.
22:46:52 <dons> @seen shapr
22:46:52 <lambdabot> shapr is in #haskell-overflow, #haskell-blah and #haskell. I don't know
22:46:52 <lambdabot> when shapr last spoke.
23:09:41 <JohnMeacham> What do you think  "f `liftM` g"  or    "g >>= return . f"
23:09:56 <shapr> dons: You called?
23:10:32 <dons> sorry. just testing out a new binary-serialised version of @seen
23:10:35 <shapr> ok
23:11:11 <dons> it dumps the @seen db using the Binary class. much better memory usage when reading it back in than Read/Show
23:11:19 <shapr> spiffy
23:11:28 <shapr> Does SerTH support FPS?
23:11:42 <shapr> Does Binary give equal efficiency to FPS?
23:11:51 <shapr> Is the new code using SerTH?
23:12:02 <dons> I think Binary is better for complex parsing
23:12:06 <shapr> ok
23:12:37 <dons> for simple lists, and lists of pairs, I use FPS.lines and packed strings
23:12:46 <dons> for more complex types, I switch to Binary
23:12:53 <dons> lists of pairs of strings, that is.
23:13:14 <shapr> lambdabot is becoming a showcase for realworld usage of Haskell.
23:13:19 <shapr> Who woulda thought?
23:13:34 <dons> hehe
23:13:51 <dons> yeah, hs-plugins, packed strings, binary persistence, hotswappable state
23:14:01 <dons> runtime evaluation!
23:14:15 <dons> > map (+1) [1..10]
23:14:16 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
23:14:19 <ski> JohnMeacham : liftM or fmap
23:14:20 <dons> literate irc :)
23:14:23 <shapr> I like the new eval syntax.
23:14:33 <dons> yeah, we should thunked of it ages ago
23:14:56 <shapr> You think contiguous > lines could be considered the same 'script'?
23:15:18 <shapr> Then you could define datatypes.
23:15:29 <dons> yeah, I was thinking about this today. maybe even have: \begin \end
23:15:33 <dons> not sure yet though.
23:15:38 <dons> data types could also be done
23:15:49 <dons> though they might need a special syntax
23:15:51 <dons> d> or so
23:16:32 <shapr> Eval is stateless right now, how would you know when to 'stop' in the new flavor?
23:16:55 <dons> I'd do something like fork a reading thread that accumulates until the end taag appears
23:17:04 <dons> ie. \begin{code} .... \end{code}
23:17:09 <shapr> How do you handle two start tags?
23:17:17 <dons> you reset
23:17:21 <dons> or dump core!
23:17:24 <shapr> heh
23:17:31 <ski> it could possibly differentiate between different users
23:17:40 <ski> considering them different sessions
23:17:44 <dons> ah, good point. yes, that could be done.
23:17:47 <ski> (unless otherwise specified)
23:17:49 <shapr> Yeah, I meant to define @more by channel and privmsg.
23:18:01 <ski> (iirc sarahbot has something like that in #scheme-repl)
23:18:25 <ski> maybe we should have a #haskell-repl ..
23:18:33 <shapr> Could be fun
23:18:43 <dons> they have a read/eval/print channel?
23:19:12 <juhp> dons: fps is complaining about missing cbits when I install my fps package:
23:19:19 <juhp> Reading package info from "/usr/lib64/fps-0.1/fps.pkg" ... done.
23:19:19 <juhp> ghc-pkg: cbits doesn't exist or isn't a directory (use --force to override)
23:19:25 <dons> hmm.
23:19:35 <dons> do you have cbits?
23:19:36 <juhp> I see cbits/ in the source
23:19:43 <dons> do you have an old cabal, possibly?
23:20:22 <juhp> dons: cabal-ghc641-1.1.3-2.x86_64
23:20:37 <juhp> I need to update?
23:21:17 <dons> hmm. not sure. i've not seen this error before
23:21:33 <dons> what's fps.pkg? you creating a package?
23:21:46 <dons> or is that just cabal's error being spat out?
23:21:52 <juhp> dons: anyway not cbits dir among the install files
23:21:58 <juhp> no, even
23:22:14 <dons> weird
23:22:35 <juhp> am I building it wrong then perhaps?
23:22:39 <dons> but cbits aren't used at runtime: Data/             HSfps-0.1.o       libHSfps-0.1.a    libHSfps-0.1_p.a
23:23:18 <dons> well they are. but the dir isn't
23:23:41 <juhp> include-dirs: cbits
23:23:55 <dons> doesn't that define bulid-time include dirs?
23:23:59 <dons> so that we get: fpstring.o:
23:23:59 <dons> 00000418 t cmp
23:23:59 <dons> 00000042 T firstnonspace
23:23:59 <dons> 00000000 T firstspace
23:24:06 <dons> inserted in the final binary.
23:24:25 <dons> anyway, it works here. i wonder if being on an amd64 could somehow break things?
23:24:40 <dons> the only thing I can think to do at this point is update cabal
23:24:44 <ski> dons : yes they have
23:24:57 <juhp> dons: ok, I'll try that
23:25:26 <ski> (ah, 'twas #schemerepl, not #scheme-repl)
23:25:39 <dons> on freenode?
23:25:41 <ski> yes
23:35:24 <ski> dons : someone said asymptonic made sarahbot .. so you might want to ask him
23:35:43 <ski> http://cvs.sourceforge.net/viewcvs.py/sisc/contrib/irc/scheme/sarah/
23:41:16 <pesco> JohnMeacham: (liftM f) g
23:41:46 <C-Keen> moin.
23:44:14 <shapr> shazam!
23:44:25 <shapr> I can't believe it's STILL not butter!
23:44:38 * ski thinks of water springs
23:44:48 <ValarQ> shapr: butter?
23:44:53 <shapr> What kind of water do you put into a waterbed?
23:45:24 * shapr looks for his medication...
23:45:29 <ValarQ> shapr: industrial cooling water (they got to hide it somewhere)
23:45:35 <shapr> ValarQ: spring water!
23:45:38 * shapr cackles
23:46:27 <astrolabe> hee
23:48:02 <astrolabe> If one drank heavy water instead of normal water, I s'pose one would get very dense.
23:51:09 <ski> shapr : in one of the comic albums (Johen et Pirlouit) by Peyo (http://en.wikipedia.org/wiki/Peyo), there's a staff that when one say "Shazam!" it creates a salt water spring .. in the story this is used to quench a fire dragon, so it becomes a water dragon
