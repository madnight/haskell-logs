00:03:46 <dhpeterson> ditto, this Frag is cool :)
00:24:13 <o_Rocky> @seen lambdabot
00:24:25 <o_Rocky> :P
00:24:42 <o_Rocky> (netsplit?)
00:24:52 <vegai> yes, 4 minutes ago
00:25:15 <boegel> dunno if it was a netsplit
00:25:25 <boegel> I think dons is having problems
00:25:28 <boegel> there he is !
00:25:29 <o_Rocky> no
00:25:30 <boegel> @seen lambdabot 
00:25:40 <boegel> hmm
00:25:41 <vegai> 10:20 ::: Netsplit brown.freenode.net <-> irc.freenode.net quits: dons, lambdabot
00:25:43 <o_Rocky> Quit (kornbluth.freenode.net irc.freenode.net) <-- net split
00:25:51 <boegel> vegai: oh
00:31:27 <ibid> vegai: 10:25 -!- Netsplit over, joins: lambdabot, dons
00:32:37 <lambdabot> Yes, I'm here. I'm in #boden, #haskell-blah, #khjk, #webwitches, #haskell.
00:32:39 <lambdabot> es, #haskell.it, #gentoo-haskell, #haskell-overflow and #haskell
00:35:10 <ProfTeggy> Moin.
01:47:22 <mardy> Surprice what some food and a good nights sleep can do
01:53:05 <ValarQ> indeed
02:03:05 <boegel> dons: can you point me where the code that handles @quote is located in the lambdabot source ?
02:11:40 * boegel just posted some advertising for TMR on the Haskell mailing list
02:21:05 <dons>  @quote is in Babel, for historical reasons
02:21:15 <dons> but should be factored out into a Quote.hs
02:22:40 <dons> as I think shapr mentioned yesterday.
02:27:39 <boegel> dons: oh okay... I'm _trying_ to build a vote plugin, which allows to vote on polls 
02:29:30 <bringert> I want an operator :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:30:01 <bringert> I think I could use Control.Arrow.>>>, but then I seem to need runKleisli stuff
02:30:05 <boegel> @hoogle Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:30:06 <lambdabot> No matches, try a more general search
02:30:14 <boegel> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
02:30:15 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:30:25 <bringert> heh
02:30:28 <boegel> hmm, nothing :)
02:30:46 <bringert> it's not hard to write it: f >>> g = (>>= g) . f
02:30:55 <boegel> oh, okay then ;)
02:30:56 <bringert> but it seems like it should already be in the libs
02:31:07 <dons> boegel, maybe look at @where?
02:31:19 <dons>  @quote is the oldest plugin I wrote :S so it's a bit weird
02:32:07 <dons>  @where or @todo are much simpler, and do the same thing basically
02:32:17 <ski> bringert : wasn't that operator called (>@>), somewhere ?
02:32:44 <ski> (maybe in 'The Craft ..", not sure)
02:33:02 <bringert> hmm, yes, now that you mention it. I seem to recall writing the same function before
02:33:48 <mauke> @pl \f g x -> f x >>= g
02:33:49 <lambdabot> flip . ((>>=) .)
02:34:08 <dons> I remember >.> from The Cratft
02:34:18 <dons> or maybe it was >@> 
02:34:29 * ski sometimes uses (>.>) = flip (.)
02:39:10 <boegel> dons: I need something that stores info provided by the user... I guess @where would work too, thanks
02:40:19 <dons> yep ,they all use the same basic model, a Map with insertion and removal
02:40:45 <dons>  @where is the much simpler implementation
02:43:58 <mauke> argh, why doesn't this work
02:44:36 <mauke> my code: http://rafb.net/paste/results/EYkC2e48.html
02:52:13 <boegel> mauke: shouldn't it be Flip Id2 Maybe Char ?
02:52:28 <boegel> Flip Id2 Char Maybe -> Char Id2 Maybe -> Char Maybe
02:52:32 <boegel> while you want Maybe Char
02:52:52 <boegel> or am I totally losing it here ? :)
02:54:23 <mauke> I'd expect it to work like this: Flip Id2 Char Maybe -> f=Id2 a=Char b=Maybe -> f b a -> Id2 Maybe Char -> f=Maybe x=Char -> f x -> Maybe Char
02:55:13 <boegel> oh, yeah, I fucked up
02:55:26 <boegel> I took f=Flip, which is obviously wrong :)
02:56:02 <boegel> mauke: ok, then it should be right... which error are you getting ?
02:56:19 <mauke> ERROR "try.hs":6 - Illegal type "Flip Id2 Char Maybe" in constructor application
02:56:31 <boegel> hmm
02:56:36 <mauke> (hugs)
02:56:40 <boegel> have you tried :: (Flip ... Maybe) ?
02:56:56 <mauke> same error
02:57:19 <boegel> hmm
02:57:35 <boegel> well, I'm no type guru, but I'm sure someone should be able to help you...
02:58:37 * ski thinks it assumes   Flip :: (* -> * -> *) -> * -> * -> *
02:58:58 <ski> while what you want is  Flip :: ((* -> *) -> * -> *) -> * -> (* -> *) -> *
02:59:43 <ski> hm, does ghc support kind ascription of args in type-synonym definition ?
03:00:43 <mauke> why can't kind inference figure this out? it works with normal functions
03:01:20 <dons> mauke hacks the types
03:01:38 <dons> Flip has the longest kind i've ever seen.
03:02:13 <ski> type Flip f a (b :: * -> *) = f b a
03:02:26 <ski> that makes it work in ghc (with -fglasgow-exts)
03:02:32 <mauke> I started thinking about this while rereading my parser source
03:02:49 <mauke> which has declarations like genOptional :: (Monad m) => Combine (Parser tok st (m a)) -> Parser tok st a -> Parser tok st (m a)
03:03:03 <mauke> and type Combine a = a -> a -> a
03:03:06 <ski> i think it assumes kind '*' of tyvars, if it can't locally infer anything else
03:03:38 <ski> mauke : i think the answer to why it doesn't work here, while it works with types, is that we have no kind polymorphism
03:05:18 <mauke> why not?
03:05:21 <ski> if we had that, it could infer  Flip :: forall k0 k1 k2. (k0 -> k1 -> k2) -> k1 -> k0 -> k2
03:06:16 <ski> guess nobody thought it was needed (/ worth the trouble/work) to implement it, yet
03:06:21 <kosmikus> mauke: good question
03:06:32 <kosmikus> Omega has kind polymorphism ...
03:06:45 <kosmikus> and Morrow. but both are experimental.
03:07:02 <ski> (url for Morrow ?)
03:07:56 <jlouis> @shapr
03:07:56 <lambdabot> Unknown command, try @listcommands.
03:08:27 <kosmikus> ski: http://www.cs.uu.nl/~daan/morrow/
03:08:30 <ski> jlouis : @get-shapr ?
03:08:34 <ski> danke
03:08:42 <dons> there's rumour around the camp fire about adding kind polymorphism to ghc
03:09:18 <jlouis> @get-shapr
03:09:19 <lambdabot> shapr!!
03:09:35 <jlouis> dons: oh, hehe. Cool!
03:10:01 <kosmikus> dons: would be very nice.
03:10:29 <kosmikus> type-level lambda, too? ;)
03:11:55 <mauke> huhu, type Flip f = \a b -> f b a
03:13:01 <kosmikus> yes, but the really great thing would be that you could partially apply Flip
03:13:46 <dons> kosmikus, we've already got type-level lambda, it's /\. check Parser.y ;)
03:15:30 <dons> don't tell me it's been removed...!?
03:15:43 <dons> looks like BigLam disappeared in recent ghc source
03:15:48 <dons> oh well.
03:17:42 <takuan> what's the function again that converts a list of list of elements into a list of elements?
03:18:30 <Muad_Dib> concat?
03:18:32 <kosmikus> dons: that's complete news to me. when has it been introduced into ghc?
03:19:02 <dons> there's used to be a /\ BigLam token in the parser (and there's always been biglam in the Core syntax)
03:19:18 <takuan> yup thanks Muad_Dib 
03:19:38 <dons> not sure if /\ is used in Core though.
03:19:50 <kosmikus> dons: in Core, yes.
03:20:11 <kosmikus> dons: there it is the abstraction of type variables on the value level, for parametric polymorphism.
03:20:19 <dons> of course it alo has type application, '@'
03:20:28 <dons> ah, right.
03:30:13 <SamB> takuan: you know, @hoogle is great for that kind of thing
03:30:25 <SamB> @hoogle [[a]] -> [a]
03:30:25 <lambdabot> Data.List.concat :: [[a]] -> [a]
03:30:25 <lambdabot> Prelude.concat :: [[a]] -> [a]
03:40:58 <takuan> SamB: yup yup
03:41:02 <takuan> ah
03:41:04 <takuan> wow
03:41:05 <takuan> nice
03:41:08 <takuan> didn't know that
03:42:21 <takuan> @hoogle [[[a]]] -> [a]
03:42:22 <lambdabot> No matches, try a more general search
03:42:27 <takuan> :D
03:42:36 <takuan> @hoogle [[a]] -> [b]
03:42:37 <lambdabot> Data.List.concat :: [[a]] -> [a]
03:42:37 <lambdabot> Prelude.concat :: [[a]] -> [a]
03:42:37 <lambdabot> Data.List.tail :: [a] -> [a]
04:14:38 <dons> @yow
04:14:39 <lambdabot> I am a jelly donut.  I am a jelly donut.
04:17:05 <jlouis> a delly jonut?
04:19:24 <boegel> jlouis: http://is3.okcupid.com/mt_pics/117/11794179361622757184/2504735318118888746-fp.jpg :)
04:20:12 <dons> @uptime
04:20:19 <lambdabot> uptime: 5 days, 11 hours, 57 minutes and 35 seconds
04:21:32 <shapr> jlouis: You called?
04:21:50 <ski> (...g gimbatul. Ash Nazg Thrak(a)t...)
04:21:59 <ValarQ> shapr: what was that about TMR?
04:22:16 <shapr> ValarQ: I asked if you wanted to write up your experience learning Haskell for TMR.
04:22:51 <ValarQ> shapr: whats TMR?
04:23:14 <shapr> ski: Ash nazg durbatulûk, ash nazg gimbatul, ash nagz thrakatulûk, agh burzum-ishi krimpatul
04:23:18 <prionic> greetings
04:23:28 <shapr> ValarQ: http://www.haskell.org/tmrwiki/
04:23:40 <shapr> gutentag prionic, how's code?
04:23:52 <prionic> functional ;)
04:24:13 <shapr> dons: Frag is the coolest Haskell game I've seen since the Finnish Tank Game.
04:24:35 <prionic> anyone knows why alex's generated .hs files cannot be preprocessed by trhsx?
04:24:57 <ski> (shapr : yes .. was reading from boegel's link http://is3.okcupid.com/mt_pics/117/11794179361622757184/2504735318118888746-fp.jpg)
04:25:28 <shapr> Nice pic
04:25:39 <musasabi> prionic: you can locate the offending piece of code by commenting large sections out and manually running trhsx.
04:25:46 * shapr hugs musasabi 
04:25:53 <shapr> hi!
04:26:00 <musasabi> morning shapr :-)
04:26:05 * shapr boings cheerfully
04:26:18 <ski> hiya musasabi
04:26:26 <prionic> musasabi: thanks for the hint, ill try
04:30:00 <prionic> ok found it: iUnbox (I# (i)) = i
04:31:51 <dons> the Finnish Tank Game??
04:31:59 <shapr> Yeah, what's it called?
04:32:05 <shapr> I have the source and binaries around here somewher.
04:32:19 <musasabi> prionic: I could give you a patch for that.
04:32:21 <dons> no idea, I don't know this game.
04:32:36 <shapr> I think ibid's students wrote it.
04:32:51 <shapr> Sadly, I don't have time to look it up at the moment.
04:32:52 <musasabi> How can I get the source packages for the haskell-unsafe repository? (looking for wxhaskell)
04:33:02 <shapr> musasabi: I have wondered this myself.
04:33:20 <shapr> dons: The frag binary is surprisingly small.
04:33:21 <prionic> musasabi: ther is another one: #else
04:34:22 <musasabi> prionic: that is cpp, try using "cpp -traditional foo.hs | trhsx" or similar. (GHC usually takes care of that)
04:35:28 <prionic> musasabi: im on winxp it isnt that easy :(
04:36:12 <dons> shapr, how big on your box?
04:36:44 <shapr> 2.9 mb
04:36:46 <prionic> musasabi: i rather alter alex template files
04:37:06 <shapr> I get ~60fps with the default settings.
04:38:27 <dons> seems to be around what most people get
04:38:36 <dons> at least from the screen shots I've seen
04:39:04 <musasabi> prionic: oh well that can also work, or just not giving alex the GHC specific flags.
04:39:17 <prionic> musasabi: the patch for the # unbox thingy would be nice though
04:39:30 <dons> pill00$ du -hs a.out
04:39:30 <dons> 2.8M    a.out
04:39:30 <dons> pill00$ strip a.out
04:39:30 <dons> pill00$ du -hs a.out
04:39:30 <dons> 1.7M    a.out
04:39:44 <shapr> I don't understand all the AFRP code yet. Is ObjectBehaviour.ray only for firing, or did he write an AFRP raytracer?
04:39:48 <dons> there you go shapr.
04:40:03 <dons> I don't know. we'll have to ask him  :)
04:40:11 <shapr> dons: Ah yes, much better.
04:40:37 <shapr> It's cool that he reused the parser from Yampa Arcade.
04:43:55 <dons> yeah, that's nice.
04:44:15 * beelsebob_ prods ndm with a stick
04:44:24 <beelsebob_> yhc-jvm rockingness!
04:45:35 <shapr> dons: I do wish he'd used the spiffy arrow-do notation. It's hard to read this way.
04:45:55 <shapr> On the other hand, it might be fast precisely because he didn't use the spiffy notation.
04:46:07 <dons> hehe. 
04:46:26 <dons> yeah, doesn't the do notatoin sprinkle lots of funny nodes in the graph?
04:46:59 <ozone> dons: sheesh, mun looks like he's done an absolutely awesome job
04:47:00 <shapr> I don't remember the details, but I know it doesn't reduce directly to the raw notation (s)he's using.
04:47:36 <dons> ozone, you seen the screenshots?
04:47:39 <shapr> Would be interesting to compare profiles of spiffy and raw.
04:47:49 <ozone> just on the wiki page
04:47:59 <ozone> need to free up more disk space so i can install ghc 6.4.1 on my laptop :)
04:48:04 <dons> yeah, pretty fantabulous, I reckon.
04:48:26 <ozone> sean and manuel must be proud :)
04:49:28 * dons makes another attempt to bypass the hsakell@ bogofilter, by announcing hmp3 without using the word `mp3'
04:49:32 * edwinb reads up
04:49:39 <edwinb> shapr: when do you want stuff for the next TMR?
04:49:46 <dons> or 'mp3 warez
04:49:47 <shapr> sloccount says 7227 lines of source code, 1.6 person years, and $215,550 development costs.
04:49:58 <shapr> edwinb: For the next issue, by the first of December.
04:50:20 <dons> 1.6 person years!
04:50:21 * edwinb looks at his calender and squeaks
04:50:25 <edwinb> I'll see if I can come up with something ;)
04:50:40 <shapr> thanks!
04:51:34 <Philippa> dons: email someone running it and explain why filtering for mp3 is bad?
04:52:10 <dons> Philippa, have done so. someone == SimonM 
04:52:18 * Philippa nods
04:52:27 <Philippa> you could go with "MPEG Audio Layer 3"?
04:52:34 <dons> ah, good idea!
04:53:10 <Philippa> I think "MPEG Layer 3 Audio" is more canonical, come to think of it
04:54:40 <ProfTeggy> bbl, need this machine for lecturing
04:56:24 <shapr> Sam Zoy may ask Sony to release GPL'd sources of his that they've modified - http://sam.zoy.org/blog/2005-11-21-suspicious-activity-indeed
04:56:55 <gdfk> That really was the stupidest thing Sony has done in a while.
04:57:20 <dons> hehe
04:57:22 <dons> cool!
04:58:02 <musasabi> prionic: http://www.cs.helsinki.fi/u/ekarttun/haskell/hsx-glasgow-exts.patch (please tell me whether it solves your problem)
05:01:00 <musasabi> argh, that lacks some code.
05:01:07 <musasabi> I'll have the correct patch up in a minute.
05:01:38 <dons> bah, still can't get through, without using the word mp3 anyway. "Message has a suspicious header"
05:01:51 <dons> unless I can't even use the name 'hmp3'
05:02:59 <shapr> sucks :-(
05:03:17 <shapr> Why not call it "hm" ++ "p3" ?
05:03:31 <musasabi> The whole '#' issue seems complex
05:03:36 <gdfk> You should have just written hwma instead, I guess.
05:03:37 <musasabi> How should it be parsed.
05:04:20 <xeiro> good day all
05:04:21 <musasabi> e.g. foo#bar means foo # bar, while foo# means foo# 
05:04:29 <shapr> hiya xeiro, how's code?
05:04:35 <xeiro> interesting :D
05:04:48 <xeiro> I have a question ... am new to haskell of course :)
05:05:28 <xeiro> readFile is of type IO String ... but I need to read the contents of a small text file and assign it to a String
05:05:29 <musasabi> prionic: That patch implements "identifier=<isIdent>+<#>*" but that will cause problems with HLists.
05:05:43 <boegel> dons: no way lambdabot is up 5 days, it left #haskell this morning I believe
05:06:02 <dons> probably just a netsplit
05:06:09 <dons> i got split off last night too
05:06:13 <ski> @hawiki ThatAnnoyingIoType
05:06:13 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
05:06:21 <ski> xeiro : see that
05:06:39 <xeiro> the link?
05:06:47 <ski> yes
05:06:57 <xeiro> yeah .. checking it now
05:07:08 <MarcWeber> Why isn't this working: printrv = putStrLn.show.fst
05:07:19 <xeiro> ski: u had this stored up somewhere :)
05:07:21 <MarcWeber> printrv  (['a'],3)
05:07:28 <ski> (xeiro : and ask here, if something is unclear)
05:07:32 <MarcWeber> but (putStrLn.show.fst) (['a'],3) ?
05:07:39 <ski> xeiro : it's a common FAQ :)
05:07:43 <xeiro> LOL LOL
05:07:50 <xeiro> wooo hooo :)
05:09:12 * ski wonders why '\regularThingie ->' isn't on the first line, there ..
05:09:36 <shapr> dons: Anyway, I hope Mun writes more Haskell code.
05:10:56 <xeiro> ski: whats the -> mean ... as opposed to <-
05:11:08 <dons> i'm not sure what he's doing next year. 
05:11:30 <ski> > let  f x = x * x  in  f 5
05:11:30 <dons> he's finished his undergrad degree, and I don't know what his plans are.
05:11:33 <lambdabot> 25
05:11:41 <ski> > let  f = \x -> x * x  in  f 5
05:11:42 <lambdabot> 25
05:11:55 <ski> > let  f x = x * x  in  map f [1..5]
05:11:58 <lambdabot> [1,4,9,16,25]
05:12:06 <ski> > let  f = \x -> x * x  in  map f [1..5]
05:12:07 <lambdabot> [1,4,9,16,25]
05:12:12 <tuomov> hmph. frag is a bit sloooow on my work machine (nv driver).
05:12:16 <ski> > map (\x -> x * x) [1..5]
05:12:17 <lambdabot> [1,4,9,16,25]
05:12:46 <ski> xeiro : "\arg -> ..." creates a function that takes 'arg' as argument and returns '...'
05:12:57 <ski> xeiro : see those lambdabot examples, e.g.
05:13:00 <tuomov> and back home I can't compile it atm because I can't install hopengl because I switched from debian unstable to testing
05:13:33 <xeiro> ski: yeah .. see em .. thanks .. woo .. gonna have to wrap my brain around this now :)
05:13:42 <dons> ah ha! it made it
05:13:49 <dons> just can't use the word 'hmp3' :/
05:14:00 <dons> since it's obviously illegal warez
05:14:44 <xeiro> ski: ok .. mind wrapped around it :) .. thanks
05:14:58 <boegel> tuomov: HOpenGL is part of GHC
05:15:14 <xeiro> ok .. off to code for a while :)
05:15:19 <MarcWeber> ski: Would you mind putting a glance at my 3 lines above? The first one defines a function, the 2. calls it and the 3. (working) is all in one..
05:15:23 <ski> xeiro : you don't need to understand the expansion of the do-notation into (>>=) and "\x -> ...", just to do what you want .... but, later, it's good to know how it expands
05:15:25 <tuomov> boegel: in debian its a separate package
05:15:36 <boegel> tuomov: oh okay, sorry
05:15:53 <tuomov> and I apparently have too new ghc6 package installed for the ghc6-hopengl package in testing
05:16:07 <ski> xeiro : (if you're the type of person who wants to know how things work inside, knowing that expansion can be good, too)
05:16:29 <xeiro> ski: yeah .... at somepoint ... I kinda like to know how some things work :)
05:16:44 <tuomov> I guess I'll just have to install the package from unstable.. and break something in the process
05:17:52 <ski> MarcWeber : try adding 'printrv :: Show a => (a,b) -> IO ()'
05:18:21 <dons> tuomov, or you could build it and install locally.
05:18:29 <dons> or is that worse?
05:18:39 <tuomov> it is
05:18:47 <tuomov> I'm too lazy for that sort of stuff
05:19:25 <dons> heh. hey, you might be interested in hmp3, the latest child of the riot and yi 
05:19:29 <dons> @where hmp3
05:19:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
05:19:51 <ski> hi again, SuperNoob
05:19:51 <dons> actually, screenshot is at http://www.cse.unsw.edu.au/~dons/hmp3.html
05:19:59 <MarcWeber> ski: Thanks a lot. I forgot to add the Show a instance declaration.. Then I tried without function decl at all..
05:20:09 <ndm> beelsebob_: back
05:20:25 <ski> MarcWeber : i think it was the infamous "monomorphism restriction" that bit you ..
05:20:59 <tuomov> dons: yeah, we talked about it earlier. unfortunately it's just a frontend to mpg321 etc., and those players aren't responsive enough on my system
05:21:07 <dons> ah, right.
05:21:31 <tuomov> very short buffer on the sound card etc.
05:21:39 <dons> ah yes! I remember. 
05:26:52 <jlouis> ah, I better read Dons's papers
05:36:58 <dons> night!
05:40:33 <MarcWeber> ski: Can you help me once more? I want to get the occurence of one element of a list in percent (or as ratio). My attempt is:
05:40:47 <MarcWeber> mratio :: a -> [a] -> c
05:40:54 <MarcWeber> mratio a b = length(filter (== a) b) / (length b ) 
05:41:12 <boegel> g'night dons :)
05:41:38 <MarcWeber> Where I don't know exaclty how to substitute c I've tried Ratio Int and Double
05:41:54 <boegel> @type length
05:41:55 <lambdabot> forall a. [a] -> Int
05:42:09 <boegel> MarcWeber: using / on Int's = trouble
05:42:15 <boegel> @eval 2 / 3
05:42:16 <lambdabot> 0.6666666666666666
05:42:20 <ski> @type fromIntegral
05:42:21 <lambdabot> forall b a. (Num b, Integral a) => a -> b
05:42:28 <boegel> @eval (2::Int) / (3::Int)
05:42:28 <lambdabot>  add an instance declaration for (Fractional Int)
05:42:28 <lambdabot>   In the definition of `xxxx': xxxx = (2 :: Int) / (3 :: Int)
05:42:28 <lambdabot>   In the definition of `v':
05:42:31 <ski> MarcWeber : try inserting that
05:42:37 <superibor> @hoogle map
05:42:38 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
05:42:38 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
05:42:38 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
05:42:43 <superibor> @hoogle getArgs
05:42:43 <lambdabot> System.Environment.getArgs :: IO [String]
05:42:43 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
05:42:43 <lambdabot> String])
05:42:55 <boegel> superibor: you could try @index :)
05:43:15 <superibor> what does @index do ?
05:43:54 <superibor> anyway, I was trying hooglebot and it's true, it works better than the hoogle site which doesn't find getArgs
05:45:25 <boegel> @index getArgs
05:45:25 <lambdabot> System.Environment
05:45:37 <boegel> superibor: it shows where you can find functions
05:45:38 <boegel> @index map
05:45:39 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
05:45:46 <boegel> way better (shorter) than hoogle
05:45:55 <boegel> hoogle is neat of finding functions of some type
05:46:00 <superibor> ok, very useful
05:46:03 <boegel> @hoogle [a] -> [[a]]
05:46:03 <lambdabot> Data.List.inits :: [a] -> [[a]]
05:46:03 <lambdabot> Data.List.tails :: [a] -> [[a]]
05:46:03 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
05:46:07 <superibor> can you use wildcards or types too ?
05:46:24 <boegel> not in index, but you can in hoogle (no wildcards though, afaik)
05:46:49 <superibor> hoogle is very neat, but the website version (not this bot) does not work so well
05:48:57 <superibor> the firefox integration is the cream
05:50:35 <MarcWeber> mdiv :: Int -> Int -> Double
05:50:36 <ndm> superibor, whats bad about the website version?
05:50:45 <MarcWeber> mdiv a b = fromIntegral a / fromIntegral b
05:50:54 <superibor> I don't know, just try to find getArgs for instance
05:51:11 <CosmicRay> autrijus: ping
05:51:11 <shapr> @index getArgs
05:51:12 <lambdabot> System.Environment
05:51:16 <ndm> hmm, thats a bug!
05:51:16 <MarcWeber> Oh.. It works!
05:51:25 <superibor> it works in v2
05:51:27 <superibor> but not in v3
05:51:57 <ndm> its in the function deciding code, it seems to have lost various functions
05:52:05 <superibor> btw ndm, nice tool, thanks for it
05:52:05 <ndm> i'll make sure its back for version 3
05:52:19 <shapr> ndm: Yeah, hoogle r0xx0rz.
05:52:52 <ndm> :)
05:54:14 <MarcWeber> Design question: Would you prefer 
05:54:23 <MarcWeber> mratio a b = foldr1 (/) $ map (fromIntegral.length) [(filter (==a) b), b]
05:54:25 <MarcWeber> over 
05:54:36 <MarcWeber> mratio a b = fromIntegral (length(filter (== a) b)) / fromIntegral(length b ) ?
05:55:15 <MarcWeber> The first one is 3 characters less ...
05:55:43 <soysauce> readability seems more important than terseness, though often related.
05:56:46 * superibor understands second better
05:56:50 * soysauce does too
05:57:20 <MarcWeber> soysauce: So I should introduce another function getlen = fromIntegral.length and use that in the second ? Would be most readable..
05:57:38 <soysauce> sure
05:57:45 <soysauce> er
05:57:48 <soysauce> sorry, read that as "could"
05:58:17 <soysauce> um, how does that even work_
05:58:17 <soysauce> ?
05:58:24 <MarcWeber> soysauce: I've been asking for your opinions, not for laws.. ;)
05:58:34 <soysauce> (fromIntegral 1) / (fromIntegral 2)
05:58:44 <soysauce> oh, nevermind.
05:58:55 * soysauce is still too accustomed to C/C++
06:00:41 <soysauce> @type (/)
06:00:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:01:17 <CosmicRay> good morning soysauce
06:01:25 <soysauce> morning
06:01:39 <CosmicRay> soysauce: I think a lot of us could sympathize with that.  do feel free to ask whatever questions you have.
06:01:50 <CosmicRay> soysauce: have you been pointed to some good haskell tutorials already?
06:02:44 <MarcWeber> soysauce, superibor: This is my final version. Hope it's most readable (but longer) http://www.rafb.net/paste/results/vq5TZe61.html
06:03:45 <boegel> > let flen = fromIntegral.length in (\a b -> foldr1 (/) $ map flen [(filter (==a) b, b]) 'a' "blablablaa"
06:03:46 <lambdabot>  parse error on input `]'
06:03:56 <boegel> > let flen = fromIntegral.length in (\a b -> foldr1 (/) $ map flen [filter (==a) b, b]) 'a' "blablablaa"
06:03:57 <lambdabot> 0.4
06:04:42 <boegel> > let flen = fromIntegral.length in (\a b -> (/) $ flen (filter (==a) b) $ flen b) 'a' "blablablaa"
06:04:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
06:04:43 <lambdabot>   Expected type: a
06:04:43 <lambdabot>   Inferred type: a -> b
06:04:53 <superibor> MarcWeber I tend to use names as length' instead of getLen
06:05:06 <boegel> > let flen = fromIntegral.length in (\a b -> (/) (flen (filter (==a) b)) (flen b)) 'a' "blablablaa"
06:05:08 <lambdabot> 0.4
06:13:11 <prionic> musasabi: the patch worked with the unbox thing, but ther is still a problem with this line:
06:13:23 <prionic> alex_base = AlexA# "\xf7\xff\xff\xff\xe0\xff\xf....
06:14:20 <prionic> musasabi: looks like AlexA is no identifier
06:25:48 <shapr> Does ssh support port knocking by default?
06:26:57 <boegel> shapr: yo ! have you seen my TMR advertisement on haskell@ ?
06:27:05 <shapr> boegel: Yeah, it rocked!
06:27:21 <shapr> boegel: I'm going to do my best to publish on Dec 1st, so make sure your article is ready!
06:27:38 <shapr> CosmicRay: Is there an easy way to write a CGI that just saves POST'd files with MissingH?
06:29:10 <shapr> Does someone have a Haskell CGI program that saves POST'd info to a file?
06:29:34 <boegel> shapr: oh, erm, that might pose a problem :s I have a Phd defense on friday, which I have to attend to try and get a grant, so I won't have time before that...and I have to collect info on the ten items, summarize it, and so on... I'll try though :)
06:30:26 <boegel> maybe I should just go for the 'top 10 libraries' thing, and ask for contributions on the haskell mailing list too
06:30:55 <shapr> boegel: Ok, TMR can wait a day or so if that'll get five articles.
06:31:00 <boegel> ok, so it's official, the first 'take 10 [1..]' article will be on libraries, everyone is free to make suggestions ! (either via the wiki, or through me)
06:31:04 <shapr> hiya karlpauls, learning Haskell?
06:31:18 <karlpauls> kind of
06:31:27 <shapr> boegel: bringert's XmlRpc lib!
06:31:33 <shapr> karlpauls: Have any questions?
06:32:09 <shapr> boegel: NewBinary 
06:32:56 <shapr> boegel: The HTTP lib that bringert is maintaining.
06:33:09 <shapr> Is my web developer bias showing?
06:33:26 <shapr> karlpauls: If you do have any questions about Haskell or FP, feel free to ask here.
06:33:33 <karlpauls> is there a buildin way to parse an int | fload | ... from a string
06:33:50 <shapr> Yes, read is the simplest way, and Parsec is the heavy duty way.
06:33:56 <shapr> > read "55" :: Int
06:33:57 <lambdabot> 55
06:34:01 <shapr> > read "55" :: Float
06:34:02 <lambdabot> 55.0
06:34:11 <karlpauls> oh, cool
06:34:56 <shapr> If you want to parse a larger chunk of text, say a grocery receipt, I'd suggest Parsec: http://www.cs.uu.nl/~daan/download/parsec/parsec.html
06:35:07 <shapr> fworp: btw, what does your nickname mean?
06:35:55 <boegel> does Gtk2Hs count as a lib?
06:35:59 <fworp> nothing, its just pronounceable, and available on most online services
06:37:01 <shapr> boegel: sure, why not.
06:38:43 <fworp> its one of those sound effects in a batman comic i think :P
06:38:50 <karlpauls> read works for me, thanks a lot shapr 
06:41:03 <shapr> fworp: oh, good choice.
06:43:10 <prionic> musasabi: youre still around?
06:45:08 <boegel> shapr: mail sent to haskell@ :)
06:48:00 <prionic> musasabi: sorry wrong info, the offending construct is: "\x00\x00\x00"#
06:48:47 <shapr> boegel: cool
06:49:46 <shapr> Philippa: Want to write a another column?
06:51:48 <superibor> @type fromMaybe
06:51:49 <lambdabot> Not in scope: `fromMaybe'
06:53:12 <xerox> @type Maybe.fromMaybe
06:53:13 <lambdabot> forall a. a -> Maybe a -> a
06:53:32 <superibor> aha
06:53:43 <xerox> To find where functions are:
06:53:47 <xerox> @index fromMaybe
06:53:47 <lambdabot> Data.Maybe
06:53:52 <shapr> I wish @type would show unique names anyway, even if they're not directly in scope.
06:54:30 <xerox> Given that it uses GHCi, it means you have to load modules up.
06:57:17 <CosmicRay> shapr: I'm not sure off-hand
07:01:39 <shapr> xerox: Hook it up with index?
07:02:21 <xerox> I don't know how simple is to write a type inferrer
07:04:22 <MarcWeber> Is hGetContents stdin all to get an array of characters from stdin? I think I starting to love haskell ;)
07:05:17 <xerox> @type System.IO.hGetContents
07:05:18 <lambdabot> GHC.IOBase.Handle -> IO String
07:05:32 <xerox> I'd say a 'list of characters'
07:05:37 <xerox> ...but yes :-)
07:06:33 <boegel> CosmicRay: HWN today ?
07:07:11 <xeiro> @type Size.hsizeW
07:07:12 <lambdabot> Couldn't find qualified module.
07:07:12 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:07:12 <lambdabot> \\)?
07:07:24 <MarcWeber> xerox: You're right, of course you are.. I still call [a] an array because I'm used to from other languages.. STOP ... reprogramming my mind.. DONE ;)
07:08:16 <xerox> Hah.
07:21:42 <mcnster> hi.  anyone know if there is a way to do an ioctl() in the hier. libraries?
07:22:16 <mcnster> or do i have to use foreign? <shiver>
07:24:33 <Lemmih> Why do you want to use ioctl?
07:25:23 <tuomov> I think you need to use foreign, a) to get the IOCTL command #define, and b) because the 3rd argument's type actually depends on the command
07:27:08 <mcnster> lemmih, i'm talking to a sound device node
07:27:45 <shapr> I think I saw some code to do that in the last few days.
07:28:01 <shapr> That is, Haskell sources that talk to /dev/dsp
07:28:13 <mcnster> dsp, bah.  alsa
07:28:41 <shapr> Have you seen Sven Panne's OpenAL binding?
07:28:58 <mcnster> shapr, nope
07:29:05 * mcnster looks
07:29:47 <shapr> What sort of data are you sending? PCM?
07:31:34 <mcnster> shapr, possibly in future.  but right now i'm dealing with /dev/snd/controlC0
07:32:25 <shapr> What does that do?
07:32:39 <shapr> I never got very far into ALSA, since my emu10k is indecipherable.
07:32:57 <tuomov> mcnster: you shouldn't need ioctl with alsa.
07:33:03 <shapr> As far as I can tell, nobody outside Creative knows what most of the emu10k settings do.
07:33:04 <tuomov> why not use the alsa api directly?
07:33:13 <mcnster> shapr, your emu10k1 is indecipherable?
07:33:18 <tuomov> that's what you're supposed to use to get advantage of the plugins and so on
07:33:19 <mcnster> shapr, oh
07:33:24 <tuomov> dmix, for example, is software-side
07:33:41 <tuomov> s/software/user/
07:33:49 <mcnster> ioctls are everwhere in alsa
07:33:57 <shapr> I hope the X-Fi chip gets better docs. Otherwise I'll look for some other OSS friendly sound card. Any suggestions?
07:34:02 <mcnster> i don't want to mess with alsa-lib for the time being
07:34:10 <tuomov> but that's what you're supposed to use
07:34:29 <mcnster> shapr, u don't have access to emu10k1 docs by any chance do u?
07:34:34 <tuomov> directly doing ioctl means your app won't work like every other app
07:34:44 <tuomov> it won't take advantage of dmix and so on
07:36:03 <mcnster> tuomov, its not an app, its satisfying some q's i have
07:37:13 <mcnster> shapr, oss is dead.  have a look at the alsa wiki and near the bottom is a list of cards that have developer friendly positions
07:37:25 <shapr> mcnster: No, I spent hours on Google without much result.
07:37:29 <tuomov> oss=open source software or open sound system
07:37:40 <shapr> software
07:38:23 <jlouis> hows code!
07:38:26 <mcnster> oss = open sound system
07:39:01 <tuomov> shapr: ac97 should be well documented :)
07:39:12 <tuomov> all ac97-only chips suck.
07:39:42 <mcnster> shapr, http://alsa.opensrc.org/Alsa+Preferred+Soundcards
07:39:59 <xerox> There also is jack!
07:40:07 <tuomov> I don't know if there are any well-documented "3d" cards and so on, but most simpler cards should be
07:41:29 <jlouis> there is a new patch on darcs from samb
07:41:39 <jlouis> I'll hope I can get some work done on it this night ;)
07:43:14 <mcnster> ok, i'm off to wet my feet in foreign calls.  ciao
07:45:22 <sethk> +
07:53:46 <xeiro> good day all :)
07:54:07 <xeiro> anyone in here knows how to use a fontDialog :)
07:54:18 <xeiro> in wxhaskell
07:54:23 <xeiro> thanks
07:56:49 <xeiro> @type String
07:56:50 <lambdabot> Not in scope: data constructor `String'
08:18:16 <musasabi> back
08:23:51 <CosmicRay> autrijus: ping
08:23:53 <CosmicRay> @seen autrijus
08:23:53 <lambdabot> autrijus is in #haskell. I don't know when autrijus last spoke.
08:24:10 <autrijus> CosmicRay: yo. sorry I did not check in to $office
08:24:18 <CosmicRay> no problem
08:24:25 <autrijus> they brought me randomly onsite to $client instead :/
08:24:27 <xerox> Soffice :-)
08:24:30 <CosmicRay> I'm trying to build my own GHC 6.4.1 for AIX
08:24:32 <CosmicRay> autrijus: heh
08:24:42 <CosmicRay> autrijus: I never could track down stdint.h for AIX
08:24:44 <CosmicRay> anyway
08:24:57 <CosmicRay> autrijus: have you ever seen this bug: http://sourceforge.net/tracker/index.php?func=detail&aid=1363942&group_id=8032&atid=108032
08:25:10 <CosmicRay> it seems that they have missed defining a function for AIX
08:25:18 <CosmicRay> so I'm curious how you got it to build ;-)
08:25:42 <xerox> "implementing it, of course"
08:26:05 <autrijus> I hadn't seen it
08:26:09 <CosmicRay> xerox: unfortunately, I don't know how to do that.  but perhaps autrijus has diffs to share ;-)
08:26:29 <CosmicRay> autrijus: did you set any special args to configure, any special CFLAGS, etc?
08:27:19 <CosmicRay> now that I think of it, it shouldn't be trying to build nativeGen stuff on AIX anyway.
08:27:29 <autrijus> I think I disabled it
08:27:34 <autrijus> it's unregized
08:27:44 <autrijus> I did try to work with wolfgang a bit on how to regize it
08:27:51 <autrijus> but it ultimately proved to be beyond me
08:28:04 <CosmicRay> me too
08:28:14 <CosmicRay> plus there's the fact that aix development docs are crap
08:29:55 <CosmicRay> what's the magic concoction to force it to do an unregesterized build, even when not doing a bootstrap from a different machine?
08:31:13 <autrijus> GhcUnregisterised in mk/config.mk
08:31:32 <takuan> is there some reference as to which kind of operators kan be defined in haskell?
08:31:44 <prionic> musasabi: ping
08:31:46 <autrijus> yes, the haskell standard
08:31:52 <autrijus> haskell report, rather
08:31:54 <CosmicRay> autrijus: so is that the only tweak you made to get it to build?
08:32:03 <autrijus> CosmicRay: I remember manually killing pthreads.h
08:32:11 <CosmicRay> ah
08:32:14 <autrijus> and that's it I think
08:32:18 <CosmicRay> whoa, does this work:
08:32:18 <prionic> @seen musasabi
08:32:19 <lambdabot> musasabi is in #haskell, #haskell-blah and #haskell-overflow. Last spoke
08:32:19 <lambdabot> 14 minutes and 2 seconds ago.
08:32:20 <CosmicRay> # Include support for generating Java
08:32:21 <CosmicRay> GhcWithJavaGen=NO
08:32:42 <autrijus> spj claims it works
08:32:54 <autrijus> and also claims it's better than IlxGen
08:32:54 <CosmicRay> does that do what I think it does?
08:33:04 <CosmicRay> ie, output Java bytecode?
08:33:08 <autrijus> yeah.
08:33:22 <CosmicRay> wow.
08:33:23 <autrijus> or rather, Java source.
08:33:31 <CosmicRay> that could be incredibly useful.
08:33:32 <autrijus> see compiler/javaGen and compiler/ilxGen
08:33:53 <autrijus> once somebody ports p6 object space to java and/or clr, pugs can really use those.
08:34:17 <CosmicRay> I don't follow; it's not a complete backend?
08:34:50 <kowey> are you around, shelarcy?
08:35:19 <CosmicRay> autrijus: hmm.  where are the haskell.runtime code?
08:35:34 <autrijus> rts?
08:35:35 <takuan> autrijus: i see nothing there about new operators and fancy stuff like that
08:35:47 <CosmicRay> hmm.
08:36:05 <CosmicRay> autrijus: so a GHC built with javaGen will output only java, ever, right?
08:36:06 <takuan> for example <-> is allowed as a new operator
08:36:14 <takuan> <gnu> is not allowed as a new operator
08:36:21 <takuan> where are the rules enshrined?
08:36:25 <CosmicRay> autrijus: I wonder if ghc4 will help with pthreads.
08:36:45 <CosmicRay> autrijus: it turns out that ghc4 doesn't work with gnu binutils on aix, but in my experience ghc3 doesn't work without it.
08:36:47 <CosmicRay> grr.
08:36:57 <Lemmih> takuan: In the Haskell'98 report.
08:36:58 <CosmicRay> I hate this platform.
08:37:19 <autrijus> takuan: http://www.haskell.org/onlinereport/lexemes.html
08:37:50 <autrijus> see "symbol" and "ascSymbol"
08:40:16 <takuan> ah
08:40:53 <musasabi> prionic: pong
08:41:04 <prionic> re
08:41:21 <CosmicRay> autrijus: here seems to be code missing for the java stuff
08:41:26 <prionic> musasabi: i found a second case: "xhsjdjshd"# 
08:41:32 <CosmicRay> Could not find module `PrimRep':
08:41:32 <CosmicRay>   use -v to see a list of the files searched for
08:41:32 <CosmicRay>   (imported from javaGen/JavaGen.lhs)
08:41:45 <musasabi> \x00\x00\x00 sounds like null bytes which should not be there.
08:42:22 <prionic> musasabi: please ignore that one
08:43:12 <prionic> musasabi: its a string that represents a compiled regexp, the problem is the # right after the string
08:43:14 <takuan> sorry autrijus but I can't figure out how to read what's written there
08:43:30 <takuan> what i'm looking for is which infix operators are allowed?
08:44:21 <musasabi> mmh, that is a constant of type GHC.Prim.Addr#
08:44:37 <prionic> musasabi: ?
08:45:00 <autrijus> CosmicRay: it might have been bitrotten since ghc4, maybe
08:45:03 <musasabi> the "foo"#
08:45:04 <autrijus> (or ghc5, not sure)
08:45:07 <CosmicRay> heh
08:45:20 <prionic> musasabi: ok
08:45:30 <autrijus> I only checked the validity of the ppr with spj, not the ghc binding part. sorry :/
08:45:57 <CosmicRay> I wonder if the .net support will work with pono.
08:45:59 <CosmicRay> mono.
08:46:24 <joelr1> howdy folks
08:47:10 <joelr1> assuming :: m (Maybe Word8)
08:47:14 <joelr1> is there a better way to write
08:47:15 <joelr1>        if (cmdType cmd) /= (CmdSitError Server)
08:47:15 <joelr1>           then return $ Just seat_num
08:47:15 <joelr1>           else return Nothing
08:47:33 <autrijus> CosmicRay: I'm not sure about ILX/Mono status. F# gens mono-happy code so maybe it's not that bad
08:48:11 <joelr1> autrijus: F# is Dot Haskell, right?
08:48:45 <musasabi> autrijus: Do you happen to know of any C->parrot compilers?
08:49:56 <joelr1> musasabi: would  taken <- foldl mplus mzero [tryTakeSeat aff_id x | x <- seats] still work if tryTakeSeat returned Maybe X?
08:50:22 <ndm> there is a project to make a cross copmiler from yhc -> JVM b yte code
08:51:03 <musasabi> joelr1: you mean "m (Maybe x)" ?
08:51:13 <joelr1> musasabi: yes
08:51:19 <musasabi> just use a monad transformer
08:51:40 <joelr1> musasabi: how would i use it in this particular case?
08:52:00 <musasabi> depends on the semantics you want.
08:52:20 <joelr1> well, i want Nothing to stand for false of course
08:53:38 <musasabi> how is this different from "ErrorT () m a" ?
08:54:21 <musasabi> One could even define "type MaybeT m a = ErrorT () m a"
08:54:34 <joelr1> musasabi: hmm... not very different
08:54:48 <joelr1> except i'm using errorT for something else here and cannot return errorT
08:54:57 <joelr1>        taken <- foldl mplus mzero [tryTakeSeat aff_id x | x <- seats]
08:55:57 <joelr1> this is working just fine with tryTakeSeat returning m Bool but now i need to modify that to return something else, like Maybe Word8. return a value instead of a boolean when True is being returned
08:56:46 <musasabi> newtype MyMonadWithSensibleName a = Foo (ErrorT () SomeOtherMonad a) deriving(Monad, MonadPlus, MonadError ())
08:57:25 <joelr1> i guess i don't clearly understand the use of mplus and mzero above
08:57:28 <musasabi> or just make it return "m (Maybe x)" and use those monads in a layered fashion.
08:57:43 <joelr1> musasabi: which monad are they from?
08:57:55 <joelr1> in this expression  taken <- foldl mplus mzero [tryTakeSeat aff_id x | x <- seats]?
08:58:02 <musasabi> @type mplus
08:58:03 <lambdabot> Not in scope: `mplus'
08:58:08 <musasabi> mplus mzero x = x; mplus x _ = x
08:58:14 <musasabi> @type Control.Monad.mplus
08:58:15 <lambdabot> forall (m :: * -> *) a.
08:58:15 <lambdabot> (Control.Monad.MonadPlus m) =>
08:58:15 <lambdabot> m a -> m a -> m a
08:58:39 <joelr1> hoogle @foldl
08:58:44 <musasabi> or rather mplus x y = if x == mzero then y else x
08:59:11 <musasabi> (of course the definition depends on the instance but that is the generic idea)
08:59:21 <musasabi> for Maybe mplus is defined as:
08:59:39 <musasabi> mplus Nothing x = x; mplus x _ = x
09:00:48 <joelr1> so how does that expression work with booleans?
09:01:06 <joelr1> tryTakeSeat was :: m Bool
09:01:37 <autrijus> musasabi: no, I don't
09:01:37 <joelr1> so you would have a lazy list [m Bool] 
09:01:54 <joelr1> i guess False stands for mzero then
09:02:21 <sethk> m [Bool], I  think
09:02:29 <joelr1> umm, right
09:02:40 <joelr1> so how does mzero/mplus apply to Bool?
09:05:32 <musasabi> How would it sensibly apply to them?
09:05:44 <musasabi> you could define it as "or"
09:05:56 <joelr1> ok, i just didn't know Bool was a monad too
09:06:03 <musasabi> it is not.
09:06:36 <prionic> musasabi: i took a look look into Lexer.hs of source-exts i am not sure how to apply the change you used on lexIdent on lexString
09:06:45 <musasabi> you could define mplus = or; and mempty = False; (or mplus = and; mempty = True) but e.g. return does not make sense.
09:10:27 <boegel|home> does anyone have more suggestions for the 'take 10 [1..]' article on Haskell libraries ? I've only got 5 so far :( (http://haskell.org/tmrwiki/TopTenHaskell_Libraries)
09:11:31 <joelr1> i don't see a substantial difference between "foldl mplus mzero [True, False]" and "foldl mplus mzero [Nothing, Just 10]" but i'm obviously not understanding how it works with booleans in the first place.
09:11:44 <eivuokko> boegel, Are Parsec, Data.List, Prelude valid candidates?  I dunno what else I use almost everywhere...
09:11:48 <joelr1> trying to run some tests
09:12:29 <boegel|home> eivuokko: feel free to add them to the wiki, deciding if it's a valid entry are concerns for later...
09:12:39 <boegel|home> @type Nothing
09:12:40 <lambdabot> forall a. Maybe a
09:12:44 <boegel|home> @type True
09:12:45 <lambdabot> Bool
09:12:52 <boegel|home> joelr1: that's the only difference
09:13:07 <musasabi> joelr1: look at the definition of MonadPlus
09:13:13 <joelr1> boegel|home: so then it should work the same
09:13:21 <joelr1> @hoogle MonadPlus
09:13:21 <lambdabot> Control.Monad.MonadPlus :: Monad m => MonadPlus m
09:13:24 <boegel|home> joelr1: I'm not sure
09:13:35 <musasabi> class Monad m => MonadPlus m where mzero :: m a; mplus :: m a -> m a -> m a
09:13:40 <boegel|home> > foldl mplus mzero [True,False]
09:13:41 <lambdabot> Couldn't match `m a' against `Bool'
09:13:46 <musasabi> So m has to be a monad.
09:13:57 <boegel|home> > foldl mplus mzero [Nothing,Just 10]
09:13:58 <lambdabot> Just 10
09:14:00 <musasabi> And Bool is not a Monad.
09:14:11 <boegel|home> yeah, I think that's the biggest difference
09:14:37 <joelr1> musasabi: so assuming that I'm now returning m (Maybe Int) it should work just the same, right?
09:14:50 <joelr1> so long as i return Nothing instead of False and Just X instead of True
09:14:59 <musasabi> yes
09:15:09 <joelr1> then why i do i use monad transformers?!
09:15:13 <joelr1> err
09:15:19 <joelr1> why do you say i need monad transformers?
09:17:02 <boegel|home> @ type mzero
09:17:02 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code devils dice dict dict-
09:17:02 <lambdabot> help docs dummy dynamic-load dynamic-reload dynamic-unload easton echo
09:17:02 <lambdabot> elements elite eurohaskell eval fact fact-cons fact-delete fact-set fact-
09:17:02 <lambdabot> snoc fact-update foldoc fortune gazetteer get-shapr ghc google help
09:17:02 <lambdabot> hitchcock hoogle hoogle+ index jargon join karma karma+ karma- kind learn
09:17:04 <lambdabot> [6 @more lines]
09:17:07 <boegel|home> @type mzero
09:17:08 <lambdabot> Not in scope: `mzero'
09:17:15 <boegel|home> @index mzero
09:17:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
09:17:16 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
09:17:16 <lambdabot> Control.Monad.Error, Control.Monad.List
09:17:24 <boegel|home> @type Control.Monad.mzero
09:17:25 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => m a
09:17:49 <joelr1> so then assuming that the following code is within  fun :: m (Maybe Int)
09:17:53 <joelr1> is there a shorter way to write
09:17:59 <joelr1>        if (cmdType cmd) /= (CmdSitError Server)
09:17:59 <joelr1>           then return $ Just seat_num
09:17:59 <joelr1>           else return Nothing
09:18:02 <boegel|home> joelr1: if your type isn't a monad, it just won't work (that's how I see it)
09:18:41 <joelr1> boegel|home: my type _is_ a monad. it's just that the list was m [Bool] before and is now m [Maybe Int]
09:18:55 <boegel|home> joelr1: oh, okay
09:19:22 <boegel|home> but lambdabot seems to work fine with [Maybe Int], but not with [Bool] ? or am I confusing stuff ?
09:19:28 <boegel|home> I probably am, nvm :)
09:22:12 <joelr1> so any way to improve that if then else?
09:36:02 <kosmikus> @seen SyntaxNinja
09:36:03 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 4 days, 15 hours, 50
09:36:03 <lambdabot> minutes and 20 seconds ago.
09:43:16 <fanopnaic> I want to use the Graphics library (or SOEGraphics or anything alike), and want to compile my program with ghc. But it complains it doesn't find the interface file. If I want to trick it to use those in /usr/lib/ghc-6.4/imports it says "Bad interface file <...> requested module name SOE differs from name found in the interface file Graphics.SOE".
09:45:52 <fanopnaic> anything I missed?
09:57:25 <Cale> fanopnaic: hmm
09:58:37 <shapr> fanopnaic: Are you importing it as Graphics.SOE?
09:59:00 <Cale> and compiling with --make, or -package SOE
10:00:18 <fanopnaic> ah, importing as Graphics.SOE works.
10:01:28 <beelsebob_> anyone here using winblows?
10:03:51 <eivuokko> mmh
10:04:04 <beelsebob_> mmh?
10:04:19 <eivuokko> Yes, but I spell it diffrently.
10:04:25 <beelsebob_> ah, okay
10:04:33 <beelsebob_> could you check this renders right in IE? http://www.cs.kent.ac.uk/people/rpg/tatd2/hehe.html
10:05:35 <eivuokko> No.  It says errors in page (I don't have javascript debugging on), and I don't have word installed.
10:05:43 <beelsebob_> m'kay
10:05:50 <beelsebob_> can you check your process list
10:05:51 <beelsebob_> for winword
10:06:05 <eivuokko> Not there
10:06:09 <beelsebob_> m'kay
10:06:18 <beelsebob_> obviously requires word installed
10:06:23 <beelsebob_> it's funny if it is
10:06:34 <eivuokko> I'm not probably the best test subject...my IE has pretty anal configuration.
10:06:40 <beelsebob_> ... if it is it says "do you want this to fuck with your computer by running word"?
10:06:48 <beelsebob_> and then runs it even if you click no
10:06:53 <beelsebob_> even in the most anal configs
10:08:44 <fanopnaic> ah, it works finally. thank you.
10:10:32 <basti_> any newbs on? ^^
10:10:56 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051115","HCAR 11/2005: http://haskell.org/communities/","Haskell libraries top 10:' by boegel|home
10:11:09 <boegel|home> arg, topic is too long :(
10:11:10 <basti_> thats too long for my client boegel.
10:11:22 <SamB> too long for the network, methinks
10:11:27 <boegel|home> can I remove something safely ?
10:11:41 <SamB> its too late for safety now, methinks
10:11:46 <boegel|home> maybe the hIDE stuff ?
10:11:59 <SamB> does lambdabot have keeping-track-of-old-topic functionality?
10:12:02 <boegel|home> now, the last bit is mine, so it's easy to fix it back SamB 
10:12:07 <SamB> ah
10:12:10 <boegel|home> s/now/no
10:12:22 <boegel|home> I just wondered if I can remove something else...
10:13:07 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051115","HCAR 11/2005: http://haskell.org/communities/","Haskell libraries top 10: http://haskell.org/tmrwiki/TopTenHaskell"]' by boegel|home
10:13:10 <boegel|home> yaay :)
10:13:24 <boegel|home> just changed the hIDE stuff a bit, if that's ok
10:13:43 <SamB> yeah. thats fine.
10:13:51 <SamB> was thinking that looked awfully long
10:14:01 <basti_> it still looks awfully long
10:14:07 <basti_> we need a wiki page on the hawiki
10:14:11 <basti_> for the current topic list
10:14:31 <SamB> "Haskell IDE: http://haskell.org/hawiki/hIDE" doesn't look as awfully long as "see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell" though
10:14:37 <boegel|home> can you guys add some suggestions for my Haskell Libraries top then
10:14:55 <boegel|home> s/then/ten
10:15:02 <boegel|home> damn, what's wrong with my typing skills
10:18:34 <araujo> Hello!
10:23:12 <boegel|home> y0 araujo 
10:23:57 <boegel|home> CosmicRay: ping !
10:24:04 <araujo> Hello boegel|home 
10:24:06 <araujo> What's up?
10:24:09 <araujo> :-)
10:25:04 <boegel|home> araujo: do you use a lot of Haskell libraries ? :)
10:26:13 <araujo> boegel|home, Not that much really.
10:26:15 <araujo> Why?
10:26:36 <boegel|home> araujo: because you should add some suggestions for my first 'take 10 [1..]' article at http://haskell.org/tmrwiki/TopTenHaskell_Libraries
10:27:40 <araujo> oh, let's read it :-)
10:29:44 <karma_> Hello! Does someone have experience using `docon' (haskell.org/docon)
10:31:14 <xerox> Why there is no Parsec there!
10:32:40 <araujo> boegel|home, i'd like hs-plugins added there.
10:34:00 <shapr> karma_: I haven't used it, but the author hangs out here sometimes.
10:38:17 <karma_> Sergey Mechveliani?
10:41:18 <dcoutts> woot!
10:41:18 <dcoutts> http://developer.imendio.com/wiki/Gtk_Mac_OS_X
10:43:08 <karma_> btw, does someone know basics of category theory?
10:43:32 * basti_ raises his hand carefully
10:45:23 <neologism> I am also interested in basics of cat-theory
10:46:01 <basti_> maybe in haskell-overflow?
10:46:27 <boegel|home> araujo: just add them then :)
10:46:34 <araujo> karma_, shoot your question here
10:46:48 <araujo> boegel|home, Ok, next to do that :-]
10:47:16 <karma_> is there some proof that algebra can be build using categories and functors like it was done in `docon' ?
10:49:05 <SamB> karma_: proof?
10:49:11 <SamB> what do you mean, proof?
10:49:33 <SamB> it *has* been done before
10:49:58 <karma_> SamB, hmm, may be not proof, but substantiation
10:50:12 <karma_> SamB, yes, may be.. some references?
10:53:32 <SamB> @google "elements of abstract and linear algebra"
10:53:33 <lambdabot> http://www.math.miami.edu/~ec/book/
10:54:57 <SamB> thats a free book I found a while back
10:55:06 <SamB> you can even download it in DVI form
10:55:46 <CosmicRay> autrijus: did you ever see TOC overflow on AIX?
10:56:03 <SamB> well, source too
10:57:05 <SamB> maybe not the best book, but at least you don't have to pay for it only to find out it isn't what you wanted ;-)
11:00:41 <SamB> hmm, wait, thats just normal algebra...
11:00:45 <SamB> sorries
11:04:31 <SamB> anyway, entire branches of mathematics don't just spring up claiming to model something which they do not in fact model...
11:05:47 <basti_> huh?
11:06:54 <SamB> basti_: do not pay any attention to my blathering, I haven't got a clue what I'm talking about
11:07:04 <xinming> How to define an instance for string?
11:07:18 <xinming> instance Myclass [a] where not works. :-/
11:07:36 <xinming> I used `type String = [Char]` also
11:07:40 <xinming> neither works
11:07:48 <basti_> SamB: k
11:07:54 <SamB> xinming: what is the class?
11:07:54 <SamB> and what do you want to do?
11:08:38 <xinming> SamB: I just do some test to see how much I got about haskell.
11:09:00 <xinming> SamB: hmm, for example, I define a class, plus :: a -> a
11:09:21 <xinming> if It is a Int, then I add 1 to the Int
11:09:46 <xinming> if It is a char, I add a "1" at the end
11:10:02 <xinming> hmm, not char, a string
11:11:02 <xinming> can I do this?
11:11:10 <xinming> Or I have to use another name?
11:11:34 <joelr1> @hoogle fmap
11:11:34 <lambdabot> Control.Monad.fmap :: Functor f => (a -> b) -> f a -> f b
11:11:34 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
11:11:34 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f
11:11:34 <lambdabot> b)
11:11:41 <xinming> hmm, Just like plusInt, plusStr
11:12:33 <ricebowl> question -- do [] and () actually allocate space, or do they function as one-time computed constants?
11:13:27 <SamB> ricebowl: usually they just use the same compiled closure 
11:13:48 <SamB> I suppose they could be allocated, but there is little point in it...
11:13:51 <ricebowl> that's what I thought
11:14:21 <joelr1> folks, if a have a structure X and pickTable returns :: m [X] and tiTableID is a label in structure X, how do i write this: tables <- mapM tiTableID $ pickTable game_type filters?
11:14:43 <joelr1> i'm looking to get just the tiTableID fields from each structure
11:14:53 <SamB> of course, that doesn't mean that the compiler uses pointer equality to match them
11:15:02 <joelr1> my version above does not work, obviously
11:15:24 <joelr1> and fmap does not apply to a list
11:15:54 <joelr1> @hoogle mapM
11:15:54 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:15:54 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:15:54 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:16:13 <ricebowl> was curious because I'm building functions of type :: (String -> (a, b) -> (String, ((a, b), c))) -> String -> a -> (String, ((a, b), c))
11:17:01 <SamB> @type fmap
11:17:02 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
11:18:00 <joelr1> i guess i just need to extract the list with <-
11:18:09 <joelr1> and then use regular map
11:19:08 <SamB> @type fmap :: (a -> b) -> [a] -> [b]
11:19:09 <lambdabot> (a -> b) -> [a] -> [b] :: forall a b. (a -> b) -> [a] -> [b]
11:19:40 <joelr1> hmm
11:19:48 <joelr1> SamB: i get the picture! thanks!
11:19:48 <SamB> so thats the same as map
11:20:16 <SamB> when you apply it to a list, that is
11:20:24 <SamB> in fact, it apparantly used to *be* map
11:20:42 <joelr1> :-)
11:20:48 <SamB> probably when list comprehensions were monad comprehensions
11:20:56 <ricebowl> why make the distinction?
11:21:42 <SamB> ricebowl: the only reason I can think of is that it can be more convenient to have a more specific type
11:21:55 <ricebowl> how?
11:22:00 <ricebowl> @eval fmap (+1) [1,2,3]
11:22:01 <lambdabot> [2,3,4]
11:22:19 <SamB> you will see when the compiler starts to complain that your types are ambiguous
11:22:33 <SamB> and that it can't resolve overloading
11:22:35 <ricebowl> but I don't see when that would happen...
11:22:42 <ricebowl> *nods*
11:23:11 <SamB> *you will*. you will.
11:23:19 <ricebowl> ok :p
11:23:39 * SamB is unfortunately not able to quote Yoda verbatim because it wouldn't make sense
11:24:04 <ricebowl> rima-tde? Wtf? Spain?
11:24:42 <SamB> ricebowl: what are you on about?
11:24:55 <ricebowl> I thought he was from the US
11:25:06 * ricebowl finds these things interesting
11:25:52 <SamB> ricebowl: maybe he shipped his computer to spain to save on internet bills?
11:25:59 <ricebowl> lol
11:26:09 <ricebowl> I suppose it's a BNC
11:37:33 <ricebowl> yay time to build GHC all over again
11:37:48 <ricebowl> (on another box)
11:38:02 <SamB> ricebowl: oh, how do I switch branches to something more stable?
11:38:10 <SamB> at least, something that builds?
11:38:13 <SamB> and runs?
11:38:28 <ricebowl> er?
11:38:34 <ricebowl> I think you mistook me for being proficient :p
11:38:37 <SamB> hehe
11:38:44 * ricebowl knows little to nothing about building GHC
11:38:47 <SamB> would you rather I mistook you for an idiot?
11:38:52 <ricebowl> maybe ;)
11:39:00 <ricebowl> low expectations > high expectations, no? ;)
11:39:21 <ricebowl> I'm just emerging GHC on my router while I'm listening to the professor discuss the Simplex algorithm
11:39:25 <SamB> oh
11:39:29 <SamB> hehe
11:39:41 <ricebowl> built it on my Windows box yesterday, quite the experience
11:39:54 <SamB> my router is my desktop...
11:40:09 <ricebowl> if you use Linux that works... ;)
11:40:16 <SamB> yes ;-)
11:40:30 <ricebowl> I have 2 Linux boxen and 2 Windows boxen + a ton of other Windows/Linux boxen that belong to my roommate
11:40:32 <SamB> I also have an XP box, but of course XP would make a turrable router
11:40:40 <ricebowl> haha quite
11:40:44 <SamB> and would be too much work to configure
11:40:47 <ricebowl> "oh shit a new zero-day is out"
11:40:51 <ricebowl> nah it's right simple
11:41:05 <ricebowl> but it's also quite easy for other people to help you "configure" it ;)
11:42:59 <ricebowl> I didn't have much luck building GHC on my Windows machine yesterday, so I'm thinking I'll just work on it from Linux
11:43:09 <SamB> I don't call a maze of GUI simple
11:43:11 <araujo> Hola ofranja 
11:43:17 <SamB> I mean, you can't grep through a maze of GUI
11:43:31 <ricebowl> it's like 2 dialogs or so
11:43:36 <ofranja> hello, araujo.
11:43:59 <SamB> and then there is the matter of dialog boxes being rather inflexible
11:44:17 * ricebowl shrugs
11:44:27 <ricebowl> you can't script it because they don't document it
11:44:34 <SamB> and there is the fact that I had already got my linux box to do it long before I had an XP box ;-)
11:44:37 <ricebowl> but you can quite easily script it from code
11:44:49 <ricebowl> iptables is a lot more flexible
11:44:50 <SamB> there *is* a route(1)...
11:45:10 <SamB> but I don't think that does much for NAT
11:45:27 <ricebowl> it's not the same on Windows
11:45:38 <SamB> I know, its clumsier
11:45:59 <ricebowl> they make everything callable from COM and/or RPC
11:46:07 <ricebowl> but the interfaces in typical MS style are undoc
11:46:22 * ricebowl reverse engineered the one for the DHCP server
11:46:32 <ricebowl> actually there are two
11:46:37 <ricebowl> and nobody knows why
11:46:48 <basti_> :-o
11:46:54 <SamB> I do!
11:46:55 <SamB> compatability!
11:46:59 <ricebowl> haha
11:47:03 <ricebowl> very true...
11:47:09 <SamB> with what, when, or where, who knows!
11:47:21 <ricebowl> I checked the source afterward and there was some lame comment about that
11:47:26 <SamB> maybe the one of them was never used by anything that made it out the door
11:47:37 <neologism> wow! they reopened the functional programming course!
11:47:39 <ricebowl> it was, but it was old
11:51:46 <eivuokko> SamB, ghc head should build and run now, no?
11:51:58 <SamB> eivuokko: is it fixed then?>
11:52:18 <eivuokko> SamB, I compiled GHC head yesterday in Windows.
11:52:31 <eivuokko> And it has not crashed on me or anything
11:52:35 <SamB> whats the flag for recursive updates?
11:52:35 <ricebowl> eivuokko - Cygwin or MinGW?
11:52:39 <SamB> for CVS?
11:52:46 <eivuokko> ricebowl, mingw.
11:52:51 <eivuokko> Uhm
11:52:56 <ricebowl> hm
11:52:57 <eivuokko> I think you just need to give all the modules
11:53:03 <SamB> eivuokko: I know that
11:53:14 <eivuokko> cvs -q upd ghc libraries alex happy is what I do
11:53:24 <eivuokko> -q makes it a bit more quiet about stuff that didnt change
11:54:13 <SamB> cvs [a-z]*/ -d
11:54:21 <SamB> oops, forgot the up
11:55:34 <eivuokko> ricebowl, ghc compiled over recent mingw requires changes, mainly I removed the offending call to sleep and changed hcs2hs removeFile -> try $ removeFile (and need to import Control.Exception)
11:55:56 <ricebowl> I'll have to ask later when I'm back at home
11:56:20 <ricebowl> I might just nuke my Win64 box and put Linux on there; I think it would be easier in the long run to work on Linux than on Windows
11:56:44 <SamB> only in the long run?
11:56:47 <dcoutts> ricebowl, good idea :-)
11:57:06 <ricebowl> SamB - I suppose I should have said the short run
11:57:11 * SamB supposes he is biased, having his linux all set up and being all used to using it and stuff ;-)
11:57:14 <dcoutts> it takes a little which to become productive in a new environment
11:57:16 <ricebowl> I have much better debuggers on Windows
11:57:24 * ricebowl already uses both environments
11:57:24 <o_Rocky> @info Functor
11:57:24 <lambdabot> Unknown command, try @listcommands.
11:57:41 <SamB> ricebowl: what debuggers do you have?
11:58:01 * dcoutts suspects windows programmers have more need of debuggers since they do not always have the source code for everything
11:58:20 <ricebowl> SamB - super custom debugger that I built myself
11:58:26 <eivuokko> dcoutts, not my experience.
11:58:58 <dcoutts> fair enough
11:59:04 <SamB> ricebowl: how can that be very good?
11:59:06 <MarcWeber> Where is the difference between String and [char]?
11:59:14 <dcoutts> MarcWeber, the name?
11:59:14 <ricebowl> SamB ;)
11:59:17 <araujo> No difference.
11:59:19 <SamB> you wouldn't have time to do much else if it is ;-)
11:59:22 <o_Rocky> String == [Char]
11:59:23 <dcoutts> MarcWeber, type String = [Char]
11:59:33 <xinming> anyone here can give me an example? to define a function named plus, and if it is plus 3 :: Int, then, It will add 1 which the result become 4, and if It is a list, It will append "1" to it
11:59:35 <ricebowl> because I can visualize *very* effectively how a program executes, with or without source
11:59:53 <ricebowl> not to mention the ability to step forward or backward through a program's execution
11:59:56 <MarcWeber> One anser is enough.. Thank you all! Then I don't understand the ghc output.. Will have to think again.
11:59:59 <ricebowl> which is covetable.
12:00:02 <SamB> ricebowl: if its that good, you should share it ;-)
12:00:19 <SamB> ricebowl: however, I bet it isn't much help with Haskell code
12:00:38 <ricebowl> yes, not in particular
12:00:46 <dcoutts> xinming, you probaly don't want to do that. But if you really want to have two different functions of different types with the same name you can use a type class.
12:01:09 <SamB> dcoutts: that is what xinming was trying in the first place
12:01:42 <ricebowl> is GHC actually written in Haskell?
12:01:51 <SamB> xinming: you know, your problem is that you can't just stick '1' on the end of any old list, it has to be a [Char]
12:01:55 <dcoutts> ricebowl, yep
12:01:57 <SamB> ricebowl: yes
12:02:13 <ricebowl> hum
12:02:23 <dcoutts> ricebowl, the GHC run time system is written C
12:02:24 <SamB> the RTS is written in C and C--
12:02:28 <ricebowl> I see
12:02:49 <ricebowl> using -fvia-c, BTW, I can still get relatively debuggable output
12:02:50 <xinming> SamB: hmm, how about prepend it to the string? :-/
12:03:23 <SamB> xinming: well, what you want is a way to make an instance that only applies to String, I guess...
12:03:42 <dcoutts> which requires undecidable or overlapping instances
12:03:46 <dcoutts> I forget which
12:03:51 <SamB> not both?
12:03:55 <dcoutts> it's not a good idea
12:03:56 <SamB> probably overlapping
12:03:58 <dcoutts> possibly both :-)
12:04:18 <MarcWeber> How can I ask ghci what type  show [a] is with a beeing instance of Show?
12:04:35 <xinming> SamB: Yes, But the problem is, I can't make a instance for the Mystring type I defined. `type Mystring = [Char]`
12:04:37 <ricebowl> monads are purely conceptual; that is to say that there is no special syntactic feature required to support them, yes?
12:04:55 <SamB> ricebowl: yes
12:05:02 <ricebowl> aha
12:05:08 <flux__> well, there is the 'do' notation for convenience.
12:05:10 <SamB> however, they are a complete pain in the neck with no typeclasses
12:05:29 <SamB> flux__: but that is just for convenience ;-)
12:05:29 <ricebowl> do is the same as bind, hence no syntax required
12:05:29 <dcoutts> @type show [undefined :: (Show a => a)]
12:05:29 <lambdabot> (Show a => a)] :: String
12:05:45 <ricebowl> do confuses me
12:05:48 <SamB> try -ddump-ds and see what happens to your dos
12:05:55 <dcoutts> MarcWeber, does that answer your question?
12:06:07 <flux__> some also say that laziness helps, but I imagine it isn't crucial to have it (I've seen monads on ocaml too)
12:06:10 <MarcWeber> dcoutts: Yes. But I still have to think about it.
12:06:22 <dcoutts> @type show
12:06:22 <lambdabot> forall a. (Show a) => a -> String
12:06:42 <dcoutts> if 'a' is in Show then '[a]' is in show
12:06:54 <MarcWeber> got it.
12:06:57 <dcoutts> therefore we can apply the 'show' function to it
12:07:00 <dcoutts> to get a String
12:07:14 <SamB> oh, actually -ddump-parsed is more clear
12:07:28 <flux__> hmm.. can you write your own typeclasses that work with instances of your class and [instances] of your class?
12:07:46 <SamB> I think
12:07:49 <SamB> I'm not sure.
12:07:59 <SamB> Maybe I shouldn't try to learn things from -e
12:08:12 <xinming> Why you all ignore my question? :'(
12:08:37 <SamB> xinming: that type is in no way different from String
12:08:40 <SamB> they are the same type
12:09:07 <SamB> if you want a new type, use newtype
12:09:51 <ricebowl> SamB - are monads such as IO and ST built using C?
12:10:14 <xinming> SamB: thanks, I think I have to go on reading.
12:10:31 <flux__> hmm.. isn't ST something you could write in haskell?
12:10:35 <SamB> ricebowl: not exactly.
12:10:45 <flux__> but IO obviously needs some means of interacting with the operating system
12:10:55 <SamB> the main thing holding them together is forged dependencies
12:11:07 <ricebowl> "forged dependencies"?
12:11:11 <SamB> there are also primitives that are used
12:11:23 <SamB> ricebowl: well
12:11:37 <ricebowl> am trying to understand how one would implement them
12:11:39 <SamB> Prelude> :i IO
12:11:39 <SamB> newtype IO a
12:11:39 <SamB>   = IO (GHC.Prim.State# GHC.Prim.RealWorld
12:11:39 <SamB>         -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
12:11:45 <SamB> you see that?
12:11:50 <ricebowl> yeah
12:12:50 <SamB> what I mean is that IO is implemented with functions which allegedly take and return values of the type GHC.Prim.State# GHC.Prim.RealWorld
12:13:09 <SamB> only those values don't actually ever exist
12:13:23 <ricebowl> weird
12:13:37 * ricebowl promptly becomes confused
12:13:37 <dcoutts> well coneptually they exist
12:13:38 <SamB> they are just there to keep the optimizer from screwing up the order
12:13:47 <dcoutts> but they can be optimised away
12:14:04 <dcoutts> they never need storage allocated for them
12:14:08 <ricebowl> *nods*
12:14:10 <SamB> so, basically IO and ST are implemented in terms of black magic
12:14:32 <ricebowl> there any docs on the web that explain in further detail?
12:14:33 <dcoutts> and one doesn't need to understand their implementation to undertand how to use them
12:14:44 <SamB> all they do is ensure that everything executes in the correct order
12:14:48 <ricebowl> one does need to understand their implementation to re-implement them ;)
12:14:51 <ricebowl> right, I understand
12:14:56 <MarcWeber> dcoutts: http://www.rafb.net/paste/results/5MqqZb85.html I don't understand this.
12:14:58 <ricebowl> but I want to know the mechanics
12:15:16 <SamB> the mechanics are basically borrowed from the rest of the compiler ;-)
12:15:26 <dcoutts> ricebowl, you might find that's not terribly helpful for gettign a good mental model of them.
12:15:39 <ricebowl> dcoutts - that isn't the purpose ;)
12:15:49 <SamB> ricebowl: what in particular are you trying to do?
12:15:55 <ricebowl> build a compiler
12:16:06 <MarcWeber> dcoutts: In line 5 is the definition, in line 10 is a recursive call from which the result is returned in line 7
12:16:13 <SamB> if you are trying to implement a compiler of your own, you can simply give it a similar blind spot...
12:16:27 <ricebowl> indeed
12:16:29 <dcoutts> MarcWeber, I'm looking
12:16:54 <ricebowl> but I want to understand how it works in theory and in practice
12:16:54 <SamB> you'll probably want to read GHC.IOBase
12:17:00 <ricebowl> ok
12:17:08 <SamB> there isn't a whole lot of theory to it ;-)
12:17:11 <SamB> mostly just practice
12:17:18 * ricebowl shrugs
12:17:23 <ricebowl> BRB, time to relocate now that class has ended
12:17:35 <MarcWeber> dcoutts: Do you also think it's easier to write code then to understand code beeing written by others? ;)
12:17:48 <dcoutts> MarcWeber, indeed :-0
12:17:52 <dcoutts> MarcWeber, show row is a String but you're consing it onto a String
12:18:01 <dcoutts> which doesn't work
12:18:01 <SamB> @where conjure
12:18:02 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
12:18:13 <MarcWeber> dcoutts: Thanks (++)...
12:18:22 <dcoutts> MarcWeber, yep, ++
12:19:08 <SamB> you can download the source to a book on the topic of implementing functional languages from http://j.mongers.org/pub/haskell/darcs/conjure/pjlester-1.11.tar.Z.torrent
12:19:15 <dcoutts> MarcWeber, the trick with finding the source of type errors is to annotate more things with the type you think they have.
12:19:17 <SamB> or you could just download it from http://j.mongers.org/pub/haskell/darcs/conjure/pjlester-1.11.tar.Z
12:19:41 <dcoutts> MarcWeber, until you can narrow it down to some application where the types don't match.
12:20:01 <MarcWeber> dcoutts: But why does ghc expect [String]? a list of String..? '\n' : [char] : [String] ????
12:20:29 <MarcWeber> One thing is really sure: If you program compiles you can bet that it works .. ;)
12:20:35 <dcoutts> MarcWeber, because you've got 'a : b' where a :: String, so that would require b :: [String]
12:20:41 <SamB> well, not quite
12:20:54 <SamB> but it is disproportionately likely
12:21:00 <dcoutts> @type (:)
12:21:01 <lambdabot> forall a. a -> [a] -> [a]
12:21:05 <dcoutts> MarcWeber, see?
12:21:22 <dcoutts> if the first arg is 'a' then second would need to be '[a]'
12:21:40 <MarcWeber> wow.
12:22:01 <dcoutts> and that's where it goes wrong because followingrows needs to be [String] but actually it's just String
12:22:02 <MarcWeber> but that would have resultet in another error... but that would have been a step to far..
12:22:30 <araujo> SamB, Does that link exist?
12:22:32 <MarcWeber> Thanks! I really did understand that.
12:22:43 <SamB> araujo: it ought to!
12:22:58 <araujo> SamB, It isn't working for me :-(
12:22:59 <SamB> oh, maybe not the latter
12:23:07 <dcoutts> MarcWeber, the compiler is not always perfect at finding where the type error is. Or at least you and the compiler might not agree on the real source of the type error.
12:23:10 <SamB> that isn't in the repo
12:23:22 <SamB> @google pjlester-1.11.tar.Z
12:23:22 <araujo> Oh, :-(
12:23:23 <lambdabot> http://tunes.org/files/irc/old/2000.0415
12:23:26 <SamB> sorry
12:23:46 <dcoutts> MarcWeber, in fact it's still a research topic - to find the type errors in the locations where a human would say the error is.
12:24:10 <SamB> you can download it using bittorrent, though
12:24:31 <dcoutts> MarcWeber, some type checking algorithms can end up discovering the error in a location that seems almost completely unrelated to the actual source of the problem.
12:24:31 * araujo doesn't use bittorrent
12:25:04 <SamB> @google "Implementing functional languages"
12:25:05 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
12:26:39 <SamB> I just stuck that in there because it seemed like a decent test file for Conjure that wouldn't land us in trouble with media companies
12:26:48 <MarcWeber> dcoutts: You're perfectly right!
12:27:51 <MarcWeber> But it's more pleasant discovering new ghc error messags then reading the output of fortune.. *lol*
12:28:08 <basti_> @ghc
12:28:09 <lambdabot>  At least one of the forall'd type variables mentioned by the constraint
12:28:09 <lambdabot> must be reachable from the type after the '=>'
12:28:13 <basti_> >.<
12:28:19 <SamB> MarcWeber: and it really does help to add a few well-placed type signatures to pin down where the tyepchecking goes other than you had expected
12:28:33 <SamB> @ghc
12:28:34 <lambdabot>  Unexpected strictness annotation
12:28:43 <basti_> i really like this one ^^
12:28:51 <basti_> this is like "hey. you fucked up."
12:29:15 <flux__> btw, ocaml and its emacs mode has this cool feature where you can put your cursor over an expression and get its type (the type information is gathered during compilation)
12:29:18 <basti_> but i really love "the impossible happened"
12:29:23 <flux__> ..when I can see that with haskell :)
12:29:30 <flux__> (well yeah, hide is propably going to have that)
12:30:12 <SamB> flux__: you mean "when can I see"?
12:30:27 <flux__> haskell doesn't yet have that, does it?-o
12:30:58 <neologism> uhm.. who was the one who was switchign from ocaml to haskell?
12:31:52 <eivuokko> flux, visual studio with visual haskell installed has something like that (but I don't use it for compiling so I am not totally sure if it had lla the types or just top-level)
12:32:09 <ofranja> neologism: i don't know who was, but i'm one that's doing it [slowly].
12:32:12 <flux__> well, top level types are useful but not nearly as useful as having that for everything
12:32:35 <neologism> ofranja: a friend of me is just learning ocaml and I am trying to convicne him to leave that and learn haskell instead ;)
12:32:53 <flux__> I think haskell does that for atleast prelude functions, propably one can extend its list of supported top level functions
12:32:53 <SamB> flux__: I think its mostly a matter of elisp being a pain in the neck to code in
12:32:56 <ofranja> neologism: i'm tell him to learn both. ;)
12:33:01 <flux__> s/haskell/emacs' haskell mode/
12:33:06 <ofranja> s/i'm/i'll/
12:33:12 <flux__> samb, but is the information available from the compiler?
12:33:14 <neologism> no time for that
12:33:20 <neologism> ofranja: he joined this chanell today
12:33:33 <SamB> neologism: linspire?
12:33:35 <neologism> his name's dvekravy :) feel free to advertize haskell :)
12:33:43 <neologism> SamB: uhm?
12:34:04 <Lokadin> how do you convert a string to an integer?
12:34:13 <Lokadin> like input string to an integer?
12:34:30 <neologism> SamB: what do you mean?
12:34:36 <flux__> > read "42" :: Int
12:34:37 <lambdabot> 42
12:34:37 <eivuokko> flux, from dumps, very likely yeah.
12:34:41 <ofranja> oops, i meant "would".
12:34:51 <Lokadin> flux__: thanks :D
12:34:59 <walterbrunswick> > read "somenumber" :: Int
12:35:00 <lambdabot> Prelude.read: no parse
12:35:10 <flux__> lokadin, the type is propably automatically induced so you may not need it
12:35:10 <walterbrunswick> neat
12:35:10 <ofranja> neologism: heh, ok.
12:35:34 <flux__> argh, and again I wrote propably, I can't understand what's my problem with that word
12:35:43 <ofranja> neologism: but i still consider myself as a caml programmer.
12:35:54 <Lokadin> flux__: oh okay
12:35:55 <ofranja> neologism: i wont be a very good haskell advertiser. ;)
12:36:03 <neologism> so dont tell him anything :)
12:36:46 <ofranja> ok.
12:36:48 <SamB> neologism: somebody said his company was switching from ocaml to Haskell for practical stuff on account of ocaml's libraries being stagnant
12:37:20 <neologism> I know there was someone on this channel who was switching from ocaml to haskell
12:37:26 <ofranja> the worst thing about o'caml are it's libraries.
12:38:00 <kosmikus> is Text.Regex available on Windows?
12:38:43 <ofranja> haskell is very clean on that, compared to ocaml.
12:39:02 <palomer> go haskell!
12:39:29 <eivuokko> kosmikus, It is documented in Visual Haskell's helps, so I think they are (vs some unix stuff isn't in those docs)
12:39:47 <eivuokko> I could ofc run ghci..just a sec
12:41:03 <Igloo> kosmikus: The HC&R CSS is missing definitions for kept and unchanged
12:41:30 <Igloo> kosmikus: Also, I'm not sure <div class="new"><div class="unchanged"> would DTRT if it was
12:41:45 <MarcWeber> I now get "Inferred type is less polymorphic than expected" which I've never met before. (http://www.rafb.net/paste/results/iHO79X20.html) What might this mean?
12:42:21 <basti_> MarcWeber: that you didn't get your types right? ^^
12:42:24 <SamB> kosmikus: I think so
12:42:26 <eivuokko> kosmikus, I can :m+ and run mkRegex and matchRegex.  I can get Just [] and Nothing out of it, so I guess..
12:42:41 <kosmikus> eivuokko: thanks, great
12:42:46 <Igloo> kosmikus: I'm not familiar enough with CSS to know why, but the text of the HaWiki section isn't on a blue background for me, while that of HWN is. Or is that meant to happen?
12:42:50 <flux__> eivuokko, the dumps apparently do contain the information, but they don't appear to have source position information -> very difficult to use
12:42:59 <SamB> kosmikus: it looks like there are sources for an implementation of the POSIX regex stuff in the GHC source tree
12:43:00 <basti_> MarcWeber: you got a forall in your type
12:43:17 <kosmikus> SamB: thank you, too
12:43:23 <kosmikus> Igloo: DTRT?
12:43:30 <Igloo> Do The Right Thing
12:43:34 <palomer> man I'm lazy
12:43:42 <basti_> MarcWeber: it appears to me that the missing show constraint in the second type declaration does have something to do with that
12:43:44 <palomer> I'm taking 2 classes and just asked for an extension for an assignment
12:43:59 <eivuokko> flux, :-(
12:44:10 <palomer> the teacher's like "ok", but then he emails me and he's like "omg, you're only taking 2 classes"
12:44:11 <kosmikus> Igloo: I think that unchanged just hasn't any special formatting associated with it ...
12:44:29 <Taral> MarcWeber: Try trainingText :: (Show a) => (forall t. StdGen -> t -> (([a], Double), (StdGen, t))) -> t -> Int -> Int -> StdGen -> ([Char], (StdGen, t))
12:44:55 <kosmikus> Igloo: the blue stuff is meant to happen, see the editorial
12:45:24 <Taral> MarcWeber: Nevermind.
12:45:36 <Igloo> Ah, OK. I find it very confusing, in that case
12:45:52 <Taral> ow, this hurts.
12:46:25 <palomer> would it be possible to write a memoization function:: (Eq a) => (a->b) -> (a->b) ?
12:46:36 <TheHunter> MarcWeber, you probably want (ghc-6.4) trainingText :: forall a t. Show a => ...
12:46:38 <palomer> ie, a function which remembers its argument?
12:47:19 <TheHunter> only using usafePerformIO, I guess.
12:47:21 <MarcWeber> Taral: Your advice caused another error.. TheHunter: I'll try..
12:47:54 <basti_> palomer: what would that be for?
12:48:00 <Taral> MarcWeber: I think the problem is that rowsAsCharList uses randDistProvider, making it not really polymorphic in t.
12:48:16 <Taral> try passing randDistProvider to rowsAsCharList directly, instead of via the environment.
12:49:07 <TheHunter> basti_, the memoize the result of an expensive computation.
12:49:18 <Taral> What you want is rowsAsCharList :: exists t. Int -> StdGen -> t -> ( [Char], (StdGen, t) )
12:49:22 <Taral> but I don't think you can do that.
12:49:33 <basti_> TheHunter: can't you use "let" for that?
12:50:07 <TheHunter> no?
12:50:39 <basti_> seems to me that it does
12:50:51 <mcnster> hello, i could use a 2nd set of eyes on my 1st attempt at foreign imports...
12:50:55 <TheHunter> fib n = fib' (n-1) + fib' (n-2) where fib' = memo fib
12:50:56 <Taral> palomer: If you include bounds, you could use an array to memoize the function with that construct.
12:50:59 <dcoutts> Any keen users of Gtk+ on Mac OS X around here? Want to try the new native Gtk+ port with Gtk2Hs?
12:51:06 <mcnster> foreign import ccall unsafe "ioctl"
12:51:06 <mcnster>    c_ioctl_pversion :: Fd -> CInt -> Ptr CInt -> IO CInt
12:51:15 <mcnster> pversion fd = alloca $ \x -> do
12:51:15 <mcnster>    ret <- c_ioctl_pversion fd 0 x
12:51:15 <mcnster>    print $ if ret == 0 then "ok" else "failed: " ++ show ret
12:51:15 <mcnster>    peek x
12:51:20 <mcnster> why doesn't this work?
12:51:47 <Taral> what does it say?
12:51:53 <basti_> i think you need special file handles
12:51:57 <palomer> Taral: no bounds, you use Eq to find your aurgument
12:51:58 <Taral> I don't think you can pass Fd to foreign imports.
12:52:00 <basti_> or some translation
12:52:01 <mcnster> failed: -1
12:52:17 <flux__> thehunter, util-package has module Memo
12:52:30 <flux__> thehunter, but it is based of reference equality, not physical
12:52:31 <Taral> palomer: No bounds? *shrug*
12:52:31 <mcnster> taral, i assumed since Fd is of Storable, it would be ok
12:52:34 <cinema> dcoutts, Have you seen in HCAR that the PGIP broker (proof general) is written in Haskell ?
12:52:45 <Taral> mcnster: Why are you doing ioctl(fd, 0, &x)?
12:52:57 * dcoutts googles for PGIP
12:52:59 <cinema> dcoutts, I think it would be a great thing to implement PGIP (display) in hIde
12:53:00 <flux__> thehunter, and you want to use something like Ord a or Hash a instead of Eq a to make it fit some nice data structure..
12:53:05 <mcnster> taral, that is the interface (it is alsa code)
12:53:14 <Taral> are you sure the request is supposed to be zero?
12:53:16 <cinema> dcoutts, read http://homepages.inf.ed.ac.uk/da/papers/pgdisp/pgipdisp.pdf
12:53:17 <flux__> thehunter, it's going away in haskell 6.6 though
12:53:18 <TheHunter> flux__, yes, I never found a case where util's Memo would be useful.
12:53:24 <mcnster> taral, yes: zero
12:53:27 <dcoutts> cinema, ta
12:53:34 <Taral> MarcWeber: Any luck?
12:53:38 <flux__> I imagine there might be such cases, but yeah, not very useful ;)
12:53:43 <Taral> mcnster: Then you might have to fetch errno to get more info.
12:53:43 <mcnster> taral, the snippit works perfectly in C
12:53:51 <flux__> I don't know why there isn't another kind of memoization function included
12:54:11 <mcnster> taral, i compared errno to eOK and it came out positive
12:54:16 <palomer> typeclasses correspond to third order predicates, right?
12:54:16 * mcnster scrates his head
12:54:34 <Taral> mcnster: What about...
12:54:34 <TheHunter> because you can screw up referential transperancy by using bogus Ord instances? Not a very strong argument...
12:55:00 <mcnster> taral is there a way to cast Fd to CInt?
12:55:09 <Taral> alloca $ \x -> throwErrnoIfMinus1 (c_ioctl_pversion fd 0 x) >> peek x
12:55:20 <Taral> What module is Fd in?
12:55:26 <Taral> @hoogle Fd
12:55:26 <lambdabot> System.Posix.Types.Fd :: Fd
12:55:26 <lambdabot> System.Posix.Types.Fd :: CInt -> Fd
12:55:26 <lambdabot> Network.Socket.fdSocket :: Socket -> CInt
12:55:50 <mcnster> wow, cool!
12:55:58 <Taral> mcnster: Try unpacking it.
12:56:05 <Taral> newtype Fd = Fd CInt
12:56:18 <Taral> but it should Just Work (tm) in the import, since it's just a newtype of CInt.
12:56:37 <mcnster> hmm
12:56:44 <Taral> I still suggest trying that throwErrno... stuff above.
12:56:47 <MarcWeber> Taral: I have to have a short break now.. But I think I'm a happier now.. ;)
12:56:48 <Taral> You'll find it in Foreign.C.Error
12:56:53 <palomer> so the memoize function is not writable in haskell?
12:56:55 <Taral> MarcWeber: Okay!
12:57:02 <SamB> @google "GRIN" machine
12:57:03 <palomer> (because it is in sml)
12:57:04 <lambdabot> http://www.funnypics.cc/en/grin_machine_197.php
12:57:15 <TheHunter> flux__, especially since you can already crash the RTS using bogus Typeable instances.
12:57:19 <Taral> palomer: Maybe if you used unsafePerformIO...
12:57:20 <mcnster> taral, ok, i'll try throwErrno
12:57:51 <Taral> palomer: The problem is that the compiler can't prove referential integrity.
12:57:58 <Taral> s/integrity/transparency/
12:58:00 <palomer> Taral: what does that mean?
12:58:12 <Taral> it means the compiler wants to be sure that a pure function returns the same output for the same input.
12:58:17 <araujo> There exist standard function to do something like: func [1,2,4,3,5] [1,2,3,9] => [4,5] 
12:58:19 <araujo> ?
12:58:31 <Taral> List.difference?
12:58:40 <TheHunter> @type (Data.List.\\)
12:58:41 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:58:47 <Taral> Yeah, that one.
12:58:53 <TheHunter> > [1,2,4,3,5]  \\ [1,2,3,9]
12:58:54 <lambdabot> [4,5]
12:59:00 <araujo> Thanks TheHunter Taral 
12:59:01 <flux__> there was this some web page that searched for algorithms, if you gave it an example of the task to complete
12:59:12 <flux__> I don't recall if it included haskell prelude though :-o
12:59:16 <flux__> (it did have java libraries)
13:02:15 * araujo hopes it works
13:03:12 <flux__> hm, infact you could build one with hoogle..
13:03:21 <flux__> try every function with matching prototype
13:03:29 <Taral> kind of like Coq's SearchPattern
13:03:34 <flux__> with reversed arguments etc
13:04:02 <flux__> well, actually, simply just all the permutations of the arguments
13:04:07 <Taral> I wish Coq had more powerful automatic tactics, kind of on the scale of ACL2.
13:04:22 <Taral> flux__: The problem is working out which ones actually do what you want.
13:04:41 <flux__> taral, you give example input and output, like araujo did
13:05:15 <Taral> oh, I see.
13:05:29 <Taral> that might work.
13:05:33 <flux__> you could ask it about "asdf" "foo" -> "fooasdf"
13:05:50 <Taral> and it would return flip.concat?
13:05:56 <Taral> :)
13:06:24 <flux__> if it were that smart, then yes ;)
13:06:51 <MarcWeber> Taral: ghc is linking! Thanks at all ( basti_ , dcoutts, SamB, lambdabot & authors)
13:06:56 <flux__> it could internally use \b a -> (++) a b and then use @pointless ;)
13:07:15 <Taral> MarcWeber: So my fix worked? Awesome!
13:07:29 <Taral> Studying System F has a purpose. :)
13:08:13 <sethk> Taral, well, studying latin has a purpose.  :)  But I think system F is definitely worthwhile, although I only understand a small part of it so far
13:08:28 <Taral> Hehehe.
13:08:44 <Taral> I mean I actually applied what I learned from System F to MarcWeber's problem.
13:10:29 <Taral> Although I suspect it's a HM restriction that he ran into.
13:11:08 <boegel|home> I get this error with the latest darcs version of Cabal, any pointers ? 
13:11:08 <boegel|home> Could not find module `Distribution.Compat.Directory':
13:11:08 <boegel|home>   it is hidden (in package Cabal-1.0)
13:11:08 <boegel|home>   (imported from tests/ModuleTest.hs)
13:11:08 <boegel|home> make: *** [moduleTest] Error 1
13:11:52 <TheHunter> no the problem is the lack of scoping of the type variable t over the where clause.
13:12:34 <TheHunter> if there are no other errors, the code should compile fine without a type sig for rowsAsCharList.
13:12:46 <Taral> TheHunter: I thought the problem was that it wanted to universally qualify t in the subfunction when t was constrained by the environment.
13:12:57 <Taral> If you omit the type sig, what is the type?
13:13:03 <Taral> And can that type be expressed in a type signature?
13:13:33 <Taral> And does it work because HM allows it, or because GHC is more flexible than HM?
13:13:39 <TheHunter> does he really use randDistProvider polymorphically?
13:13:56 <Taral> TheHunter: I don't know. He could, given the code provided.
13:14:04 <Taral> I think.
13:14:10 <Taral> Let me check again.
13:14:30 <TheHunter> f :: t -> t; f x = y where y :: t; y = x
13:14:36 <TheHunter> this is a type error.
13:14:46 <Taral> Yeah, looks like he does use it polymorphically.
13:15:06 <Taral> TheHunter: Okay, so it's an expressivity limit to Haskell. :)
13:15:27 <TheHunter> No he doesn't. He uses it only once.
13:15:43 <Taral> Huh?
13:15:43 <TheHunter> there are ways to do it.
13:15:58 <Taral> But what he passes to it... oh, I see what you mean by polymorphically.
13:16:05 <TheHunter> this does what we want: f :: forall t. t -> t; f x = y where y :: t; y = x
13:16:19 <Taral> TheHunter: How is that different?
13:16:19 <TheHunter> i mean with two different instantiations of t.
13:16:40 <TheHunter> the forall makes the t scope over the where clause.
13:16:50 <Taral> Um... that's definitely a GHC extension then.
13:16:59 <TheHunter> yes, sure.
13:17:02 <Taral> Okay. :)
13:17:11 <Taral> Hence the suggestion to use forall a t. ...
13:17:21 <Taral> Useful!
13:17:37 <basti_> ?
13:17:43 <TheHunter> the pre-ghc-6.4 way (still an extension is) f (x :: t) = ..
13:17:47 <MarcWeber> Taral: HM, System f? 
13:18:42 <mcnster> taral, argh.  the ioctl request was not supposed to be zero.  thanks
13:18:45 <Taral> Hindley-Milner.
13:18:48 <Taral> mcnster: :)
13:19:02 <Taral> System F-omega is the language upon which GHC's Core is based.
13:19:15 <basti_> woo.
13:19:20 <Taral> language or logic system or representation, whatever.
13:19:31 <basti_> say what is a cartesian closed category?
13:19:32 <TheHunter> and of course this compiles, too, but is too restrictive: f :: (forall t. t) -> t; f x = y where y :: t; y = x
13:20:01 <Taral> Heh.
13:20:06 <Taral> Yeah, not much you can pass to that f.
13:20:10 <Taral> undefined.
13:20:11 <MarcWeber> It's like speaking with the president of USA (?) *g* I'll finish my program.. I still have to call the function..
13:20:36 <Taral> MarcWeber: Did you use my fix or TheHunter's? TheHunter's fix it better than mine.
13:20:38 <Taral> it->is
13:21:15 <basti_> how about a type system for prolog?
13:21:47 <TheHunter> basti_, do you know curry?
13:21:55 <MarcWeber> Taral: passing the function through the subfunction..
13:22:12 <Taral> MarcWeber: Try going back to what you had, but add "forall a t." to the top-level function's type signature.
13:22:20 <Taral> It's a GHC extension that will make it all happy.
13:22:30 <Taral> You probably need -fglasgow-exts, if you don't already have it.
13:22:54 <MarcWeber> That's the reason.. ok, I'll try again.
13:23:13 <TheHunter> the H98 way is to just remove the type sig of rowsAsCharList.
13:23:25 <TheHunter> @where curry
13:23:25 <lambdabot> I know nothing about curry.
13:23:33 <TheHunter> tststs
13:23:35 <Taral> hehehe
13:23:41 <Taral> No curry for you.
13:23:58 <Taral> I dunno, what *is* a cartesian closed category?
13:24:10 <TheHunter> @help where
13:24:11 <lambdabot>  @where <key>, return element associated with key
13:24:17 <TheHunter> @listcommands where
13:24:17 <lambdabot> where provides: where what where+
13:24:22 <TheHunter> @help where+
13:24:22 <lambdabot>  @where+ <key> <elem>, define an association
13:24:29 <TheHunter> @where+ curry http://www.informatik.uni-kiel.de/~mh/curry/
13:24:30 <lambdabot> curry ~> http://www.informatik.uni-kiel.de/~mh/curry/
13:24:58 <MarcWeber> => "malformed class assertion"
13:25:09 <basti_> TheHunter: hmm i think i heard about i
13:25:09 <basti_> t
13:25:32 <MarcWeber> What does forall a t. mean?
13:26:06 <basti_> TheHunter: is that typesafe?
13:26:20 <Taral> basti_: http://books.google.com/books?hl=en&id=6PY_emBeGjUC&pg=PA35&lpg=PA35&dq=%22cartesian+closed+category%22&sig=Fz8vApUI2eL27kXEENFdULP7PHs
13:27:00 <TheHunter> it has a type system closely modelled after haskell's - without type classes and all the fancy extensions, though.
13:27:01 <Taral> MarcWeber: It means to make a and t scope over the where clause, so that the type signature of the subfunction will use the same t as the top function.
13:27:32 <Taral> Of course, you could do like TheHunter said and just remove the subfunction's type signature. Then you don't need -fglasgow-exts.
13:27:45 <Taral> I personally like having proper typing everywhere.
13:27:54 <Taral> er, specified typing.
13:28:18 <basti_> Taral: that was... brief
13:28:29 <TheHunter> yeah, that's why I've allways hated the way haskell does it.
13:28:49 <Taral> basti_: It's the best I could find. :(
13:28:55 <Taral> Try going on to the next page?
13:29:37 <MarcWeber> Taral: I get malformed class assertion when prefixing Show a with forall a t. And a t doesn't make my function randDistProvider  scope over the where clause, does it?
13:29:39 <basti_> yes i skimmed over it
13:29:56 <basti_> I'm kinda puzzled what this has to do with lambda calculus
13:30:00 <TheHunter> MarcWeber, show us your type signature
13:30:09 <basti_> (i expected it to have some connection)
13:30:18 <MarcWeber> trainingText :: (forall a t. Show a) => (StdGen -> t -> ([(a, Double)], (StdGen, t))) 
13:30:21 <MarcWeber>                 -> t -> Int -> Int -> StdGen -> ([Char], (StdGen, t))
13:30:31 <TheHunter> trainingText :: forall a t. (Show a) => (St
13:30:41 <SamB> @google "implementing functional languages" language-tutor.src
13:30:42 <lambdabot> No result found.
13:31:44 <MarcWeber> TheHunter: Sorry. I should have looked up your previous message.. So I don't need the paranthesis..
13:31:46 <Taral> @google "implementing functional languages"
13:31:47 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
13:32:14 <TheHunter> parentheses are only needed if there's more than one constraint.
13:32:27 <MarcWeber> TheHunter: You deserve your name! ;)
13:33:11 <CosmicRay> lambdabot: @aix
13:33:11 <lambdabot> Arrr!
13:33:17 <CosmicRay> that's what I would have said too.
13:33:55 <TheHunter> heh!
13:34:08 <MarcWeber> So for all a t. means that type a and t from both specifications are the same.. I wondered wether they are.
13:34:28 <CosmicRay> "aix" is usually followed by "sucks" around here
13:35:57 <musasabi> But not as hard as hp-suxs
13:36:32 <boegel|home> CosmicRay: great HWN issue ! (and I'm in itt ! w00 ! )
13:38:39 <Taral> HWN?
13:39:30 <Taral> MarcWeber: No.
13:39:38 <Taral> MarcWeber: forall a t. is the same as forall a. forall t.
13:39:40 <Taral> it means what it says
13:39:47 <Taral> for all a, this type applies.
13:40:04 <Taral> but the extension also causes that type variable to apply to any type signatures in the where clause.
13:40:13 <Taral> so the subfunction's type re-uses the t and is correct.
13:40:45 <Taral> otherwise, the subfunction's type signature creates a new t that doesn't match the top's t.
13:40:46 <tony2> wow, I just ran frag. Real very impressive.
13:40:49 <qwerty-> not really the right place, but anybody know what does "nice function" mean (if it means anything)?
13:40:50 <Taral> frag?
13:41:14 <tony2> 1st person rpg shoot -em -up effort.
13:41:42 <Taral> qwerty-: I suspect it's the same as "well-behaved": http://en.wikipedia.org/wiki/Well-behaved
13:41:45 <tony2>  darcs get http://www.cse.unsw.edu.au/~pls/repos/frag, ghc -O2 --make -fvia-c main.hs -fglasgow-exts
13:42:08 <Taral> is there a web page?
13:42:27 <qwerty-> aha.. could be that, yeah, thanks a lot
13:42:39 <tony2> um, I guess I read about it in the communities report.
13:42:41 <SamB> qwerty-: opposite of "nasty function"?
13:43:04 <qwerty-> that was my first thought :)
13:43:50 <fworp> theres at least this page
13:43:53 <fworp> @wiki frag
13:43:53 <lambdabot> http://www.haskell.org/hawiki/frag
13:44:17 <fworp> well no, not that page
13:44:29 <Taral> http://www.haskell.org/hawiki/Frag
13:44:30 <Taral> ?
13:44:34 <fworp> right
13:44:35 <musasabi> Taral: HWN - Haskell Weekly News
13:44:57 <Taral> One of these days I'll get around to writing that idl parser for the hopengl people.
13:45:36 <MarcWeber> Taral: I tried to say exactly this.. reusing type -> both beeing of same kind -> my lazy expression : specifications beeing equal 
13:47:30 <Taral> yeah, but it's not between a and t, it's between trainingText's t and rowsAsCharList's t.
13:47:45 * MarcWeber nods
13:52:46 * boegel|home is hacking on lambdabot 
13:56:51 <palomer> Taral: how long do you think the memoize function would be?
14:02:36 * araujo thinks he finally found the bug
14:04:26 <palomer> hrm, I guess this is one area in which haskell falls short, a simple memoize function!
14:04:51 <Taral> palomer: Memoization is never simple.
14:05:32 <Taral> And the constraints you provided (Eq a) are very very minimal.
14:06:28 <musasabi> StableName comes to the rescue
14:07:07 <musasabi> I think lor had a simple working memoizing function?
14:07:18 <Taral> why do you need stablename?
14:07:20 <Taral> You have Eq.
14:08:42 <palomer> Taral: this is trivial to do in sml
14:08:53 <palomer> ok, fine, you have Ord
14:09:06 <Taral> SML is strict.
14:09:31 <Taral> I'll bet it involves mutable state in SML.
14:09:33 <pediddle> 11:13:45 <Lor> memoize f range = ((map f range) !!)
14:09:46 <Taral> pediddle: That has bounds. Palomer won't provide bounds.
14:10:07 <palomer> Taral: of course
14:10:16 <pediddle> Taral: but it sure is simple :)
14:12:01 <palomer> what's the type of raneg?
14:12:19 <Taral> @type range
14:12:20 <lambdabot> Not in scope: `range'
14:12:24 <Taral> @type Data.Ix.range
14:12:25 <lambdabot> forall a. (GHC.Arr.Ix a) => (a, a) -> [a]
14:12:40 <Taral> Oh, that range?
14:12:52 <Taral> @type \f range -> ((map f range) !!)
14:12:53 <lambdabot> forall b a. (a -> b) -> [a] -> Int -> b
14:12:59 <Taral> range is type [a]
14:13:11 <palomer> a lists of possible inputs?
14:13:15 <Taral> I think it's supposed to be [Int]
14:13:25 <maitrix_> Hi! I'm doing an animator in GHC and I need to dump the X screen to a imagefile. Is there any function in built-in libraries, that is able to save Graphic to a image file?
14:13:26 <Taral> @type \(f :: Int -> a) range -> ((map f range) !!)
14:13:27 <lambdabot> forall a. (Int -> a) -> [Int] -> Int -> a
14:13:33 <palomer> who says the inputs are ints?
14:13:42 <Taral> palomer: Well, the result is (Int -> b)...
14:13:59 <Taral> I didn't suggest that function.
14:14:02 <palomer> that's _way_ too restrictive
14:14:12 <Taral> Yes...
14:15:09 <maitrix_> Anybody familiar with GHC HGL library?
14:17:17 <MarcWeber> Which commands to use for starting other applications and scripts ?
14:18:08 <dhpeterson> maitrix_: seen Frag?
14:18:34 <dhpeterson> maitrix_: i'm guessing it uses hopengl, and there are a bunch of screenshots, but i don't know how they're done
14:18:53 <dhpeterson> @wiki Frag
14:18:53 <lambdabot> http://www.haskell.org/hawiki/Frag
14:19:29 <dhpeterson> maitrix_: not familiar with the hopengl stuff myself
14:19:47 <maitrix_> ok, thanks
14:20:00 <Taral> @hoogle unsafePerformIO
14:20:00 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:20:00 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
14:21:13 <Taral> palomer: http://www.taral.net/Memoize.hs
14:21:16 <maitrix_> MarcWeber: in module System there is a function called system
14:21:40 <Taral> I'm sure it looks a lot like your SML code.
14:21:56 <Taral> can anyone think of a lazier way to do it?
14:22:56 <Taral> Ooh, I might...
14:23:12 <MarcWeber> maitrix_: Thanks
14:26:06 <Taral> nope, referential transparency bites again!
14:27:12 <MarcWeber> maitrix_: Is there also support for piping? Or do I have to call the system methods directly?
14:29:59 <MarcWeber> Will go to bed now. Thanks @ll
14:30:05 <maitrix_> MarcWeber: system: String -> IO ExitCode
14:30:10 <basti_>  http://members.cox.net/transam57/lights.wmv
14:30:13 <basti_> whoops
14:31:43 <Taral> bbl
14:42:23 <boegel|home> dons: ping
14:46:14 <boegel|home> @type unwords
14:46:15 <lambdabot> [String] -> String
14:47:04 <erob> hi 
14:47:39 <erob> im wondering how haskell matchup against ruby ???
14:48:43 <Lemmih> Hi erob.
14:48:51 <erob> hello Lemmih
14:49:12 <erob> im searching to learn a new langage such as Lisp or Haskell or ruby :)
14:49:15 <palomer> @type \f -> f f
14:49:16 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:49:16 <lambdabot>   Expected type: t
14:49:23 <SamB> erob: well, Haskell is *not* available on rails
14:49:54 <erob> SamB: Uh, okay. I'll take that in account :)
14:49:56 <SamB> however, I am thinking that whatever that means is probably a good thing
14:50:06 <astrolabe> erob: You've come to a good place
14:50:21 <astrolabe> @learn
14:50:21 <lambdabot> http://www.haskell.org/learning.html
14:50:34 <soysauce> @seen xerox
14:50:35 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #
14:50:35 <lambdabot> haskell 1 hour, 29 minutes and 19 seconds ago.
14:50:37 <erob> thx, astrolabe
14:50:39 <soysauce> ah, oh well
14:50:57 <astrolabe> erob:  If you have any questions, ask here.
14:51:06 <soysauce> why would you learn LISP when Haskell exists :/
14:51:21 <sieni> soysauce: why not?
14:51:22 <astrolabe> lisp is very nice too
14:51:41 <soysauce> (((((((if) only) we) wrote) this) way) too)
14:51:50 <astrolabe> :)
14:52:03 <sieni> soysauce: but that's the only proper way to write code ;-)
14:52:15 <astrolabe> Is lisp easier than haskell do people think?
14:52:22 <palomer> is forall t.t inhabited in haskell?
14:52:34 <soysauce> well, I never learned LISP and have no particular desire to do so, so I don't know which is easier ;)
14:53:15 * soysauce is satisfied being fluent in x86 and SPARC assembly, C, C++, Java, Haskell, & Perl
14:53:24 <soysauce> some day I might bother to pick up Python
14:54:12 <soysauce> man, it's only midnight in Europe, where is xerox :|
14:54:15 <gzl> blimey. assembly.
14:54:25 <sieni> astrolabe: probably depends on your background... it didn't take much time for me to understand scheme with a C background and at least CL doesn't have continuations
14:54:45 <sieni> soysauce: why not Lua instead ^_^
14:54:45 <erob> Does Haskell is considered old (like Cobol et. al) ?
14:54:55 * fworp is fluent and english and only speaks broken haskell/c/etc
14:54:56 <sieni> erob: certainly not
14:55:05 <fworp> in*
14:55:17 <sieni> erob: (if I understood correctly what you asked)
14:55:42 <soysauce> er, Haskell as a language isn't even that old
14:55:45 <astrolabe> erob: No, the last 'standard version' is 98, but there are lots of extensions available since then.  I think the first version was 89.
14:55:49 <soysauce> less than a decade, no?
14:55:53 <soysauce> maybe not
14:56:24 <sieni> haskell committee was started in 1987
14:56:29 <fworp> probably a couple decades
14:56:39 <sieni> not even 2
14:56:49 <astrolabe> erob: The wikipedia page on haskell is nice and informative
14:56:52 <SamB> sieni: CL has a huge standard, though...
14:57:36 <erob> thx, sieni, astrolabe, I'll do some research as well..
14:57:36 <sieni> SamB: well... look at c++ standard
14:57:41 <SamB> soysauce: you *can't* be fluent in Java...
14:57:58 <SamB> sieni: well, compared to the Scheme standard, I mean.
14:58:04 <SamB> the CL standard's index is longer than R5RS
14:58:30 <soysauce> SamB - why not?
14:58:47 <soysauce> that's easier than being fluent in C++
14:58:53 <SamB> soysauce: well, no more than you can be fluent in entish
14:58:59 <soysauce> heh?
14:59:02 <soysauce> what do you mean?
14:59:17 <SamB> it takes a long time to say anything in Java
14:59:24 <soysauce> haha
14:59:29 <astrolabe> He means that Java doesn't lend itself to fluent coding
14:59:36 <soysauce> how true! And for that reason I abhor that language
14:59:46 <dcoutts> it lends itself to full enployment
15:00:00 <boegel|home> dcoutts: y0w !
15:00:01 <dcoutts> because it takes so large a team to build anything
15:00:06 <dcoutts> hia boegel|home 
15:00:08 <soysauce> haha
15:00:20 <soysauce> there is much to be said for having a decent library, however :p
15:00:25 <soysauce> but Java takes that perhaps to the extreme
15:00:27 <dcoutts> indeed there is
15:00:36 <palomer> the java library is quite good
15:00:37 <boegel|home> dcoutts: add your favorite library -> http://haskell.org/tmrwiki/TopTenHaskell_Libraries
15:00:41 <SamB> soysauce: which is why we have a decent library ;-)
15:00:41 <soysauce> yes, yes it is
15:00:42 <palomer> sometimes a little obtuse, but quite good
15:00:57 <dcoutts> soysauce, some Java libs are not so well thoyght out however
15:00:59 <soysauce> if it weren't for the Java library, it would have been utterly worthless as a language
15:01:06 <soysauce> dcoutts - the same is true in every language
15:01:22 <dcoutts> soysauce, but in Haskell we can deprecate bad libs
15:01:24 <soysauce> more so in MS .NET I have heard; but that is hearsay
15:01:31 <soysauce> *nods*
15:01:35 <dcoutts> boegel|home, You've already got my favourite :-)
15:01:47 <palomer> my first stab of something is usually in java, simply because of the library
15:01:51 <boegel|home> dcoutts: any others ?:)
15:02:09 <soysauce> the whole type system in Haskell is much more useful than in imperative languages
15:02:12 <dcoutts> boegel|home, I'll ponder it
15:02:20 <soysauce> or rather
15:02:26 <soysauce> specifically those imperative languages which have become popular
15:02:50 <dcoutts> soysauce, I can imagein a language that looks like python but has a type system like Haskell might be sucessful.
15:03:03 <soysauce> it's easy enough to write an equivalent for something such as map in C++, and you can even make it generic, but what you can't (easily) do is function closures or lambdas
15:03:04 <dcoutts> with a decent record system
15:03:05 <SamB> are we allowed to add things already in the heirarchical libs?
15:03:19 <boegel|home> @hoogle Map -> String
15:03:20 <lambdabot> System.Info.os :: String
15:03:20 <lambdabot> System.Info.arch :: String
15:03:20 <lambdabot> System.Info.compilerName :: String
15:03:31 <soysauce> boost has lambdas, but boost isn't standard (though from the sounds of it, it will be)
15:03:38 <soysauce> lambdas and currying
15:03:51 <SamB> soysauce: won't that make it slower to update?
15:03:57 <astrolabe> erob: I find haskell a really nice language to code in, and interesting too.  It does make your head expand when you're learning though, which you might like or not.
15:03:58 <soysauce> to update what?
15:04:14 <boegel|home> @index Map
15:04:14 <lambdabot> Data.Map
15:04:46 <SamB> soysauce: if boost becomes standard, won't that slow down updates?
15:05:01 <soysauce> SamB - specification updates...?
15:05:33 <SamB> sorry it took so long for me to add Parsec
15:05:41 <boegel|home> @type print
15:05:42 <lambdabot> forall a. (Show a) => a -> IO ()
15:06:26 <erob> astrolabe: im just curious about different aspects of computing; sure programming is a great way to learn new things :)   
15:07:42 <SamB> soysauce: boost updates
15:08:38 <astrolabe> erob: haskell might be a good choice then.  It has a few novel aspects which you are forced to confront.  referential transparency, lazy evaluation, monads, a beautiful type system.
15:10:04 <soysauce> SamB - oh, well I don't know. It's not final by any means, but adding boost to the spec is one thing they are considering, last I had heard.
15:10:17 <soysauce> there are a number of other features as well
15:10:36 <boegel|home> @type fst
15:10:37 <lambdabot> forall a b. (a, b) -> a
15:10:46 <soysauce> I'd imagine, however, that if boost is added to the spec, the boost guys will keep doing what they do as additions above and beyond the spec
15:11:29 <soysauce> as if the language weren't *already* complicated enough ;)
15:11:35 <boegel|home> @type print
15:11:36 <lambdabot> forall a. (Show a) => a -> IO ()
15:11:41 <boegel|home> woops
15:12:30 <erob> astrolabe: what kind of appliance does Haskell suites best ?
15:13:27 <erob> or say, research fields :) 
15:13:30 <astrolabe> erob: It is quite general.  A lot of academics use it.  It is particularly good for compilers perhaps.
15:13:48 <astrolabe> personally I don't rate it for numerical stuff
15:14:00 <wchogg> Why's that, astro?
15:14:07 <palomer> haskell should be in reverse polish notation!
15:14:10 <palomer> rpn 4 ever!
15:14:31 <dcoutts> erob, complex problems, symbolic manipulation problems
15:14:41 <dcoutts> erob, GUIs !
15:14:49 <astrolabe> wchogg: I don't think you could get the efficiency (in computing time) of C or Fortran
15:15:05 <erob> astrolable, dcoutts: thanks 
15:15:22 <wchogg> astro:  is that just because of lazy evaluation?  Ocaml supposedly is competitive with c in numeric calculations.
15:15:33 <palomer> ocaml isn't lazy
15:15:36 * dcoutts goes back to writing the GUI for a complex symbolic manipulation problem
15:15:46 <wchogg> palomer, that was my point.
15:15:54 <astrolabe> dcouts :)
15:16:13 <wchogg> Is lazy evaluation the only reason why haskell would be slower than c?
15:16:28 <astrolabe> wchogg: I'm not sure, also it may only be a temporary thing while haskell compiler technology improves.
15:16:41 <sethk> wchogg, no, it's a factor, but not the only one
15:16:54 <sethk> wchogg, however, to say it is "slower than C" isn't quite correct
15:17:21 <sethk> wchogg, it can be, but not in every case, and often with careful coding similar performance is possible
15:17:29 <wchogg> sethk:  What other factors slow haskell down besides laziness?  
15:17:38 <Cale> Languages aren't different speeds intrinsically.
15:17:57 <sethk> wchogg, the literature on that subject is voluminous
15:17:58 <eivuokko> Or rather, what would be hard to optimise besides laziness?  IO-monad and classes maybe?
15:17:59 <SamB> simple problems are nice too!
15:17:59 <palomer> Cale: english?
15:18:04 <sethk> wchogg, there is no short, accurate answer
15:18:16 <wchogg> cale:  This is true, but there's an "average" in terms of how easy it is to make a language perform well.
15:18:20 <Cale> The compilers available for a language determine how fast the code written in that language is going to run.
15:18:25 <sethk> palomer, speakers of English have different intrinsic speeds, not the language itself.  :)
15:19:05 <astrolabe> Cale: true, but I think empirically, there is truth in what I say.
15:19:06 <palomer> Cale has a point, I'm sure it's possible to write haskell code which is nearly as fast as C code
15:19:19 <SamB> sethk: in fact I know of at least one instance in which it is faster than C
15:19:27 <wchogg> sethk:  So alot of work has been done on efficienctly implementing haskell?
15:19:32 <Cale> It's possible to write a Haskell compiler which produces assembly which is as good as with C.
15:19:37 <palomer> however, I think the discussion is "how can I get the patterns I'm used to to compile as semantically equivalent code in C"
15:19:45 <dcoutts> Cale, in some small specific cases
15:19:54 <dcoutts> Cale, in general we're still a bit off
15:19:58 <sethk> wchogg, lots of work, sure, but as palomer notes, it is comparing apples to oranges
15:20:01 <Cale> I mean in general, it should be possible.
15:20:11 <wchogg> Well, for me the question is if it is feasable to do alot of numeric work in haskell.
15:20:33 <dcoutts> Cale, maybe, but we've got put in enough effort to get there yet
15:20:39 <Cale> All I'm saying is that one ought to compare compilers, and not languages, for speed.
15:20:40 <wchogg> I work in high energy physics:  simulations takes weeks as it is, and doing it inefficiently could cost weeks more.
15:20:47 <dcoutts> Cale, indeed
15:21:02 <eivuokko> Well, you can compare things that are hard to opimise in languages.
15:21:19 <astrolabe> My feeling is that haskell is good for complicated algorithms.  For dumb numerical stuff like matrix multiplications and FFTs, it will lag behind in speed.
15:21:23 <dcoutts> Cale, though the language semantics can have an effect on the optimisations that are permissable or tractable.
15:21:48 <Cale> Haskell has a lot of features which are difficult to optimise on today's architectures.
15:22:20 <musasabi> Still no success at getting wxhaskell to compile :-(
15:22:50 <astrolabe> But wasn't someone putting a haskell wrapper around BLAS or something?
15:22:50 <SamB> musasabi: using a recent enough version?
15:22:56 <tuomov> things like lapack have assembly optimisations even
15:23:02 <Cale> Haskell is an excellent language for fitting together algorithms written in C in complicated ways.
15:23:10 <tuomov> so one would presumably use some such package for the low-level matrix stuff
15:23:23 <tuomov> I don't see a problem with using haskell for higher-level algorithms
15:23:32 <Cale> yeah
15:23:57 <wchogg> So how hard is it to interface haskell with c code?
15:24:03 <Cale> It's easy
15:24:04 <soysauce> pretty easy
15:24:10 <musasabi> SamB: 0.9.4
15:24:10 <soysauce> import foreign ...
15:24:13 <soysauce> something like that.
15:24:19 <tuomov> well, lapack in particular is horrible to use from C even, but in general its very easy
15:24:37 <wchogg> Really?  So you can get around speed issues by dropping down to c?
15:24:44 <tuomov> yeah
15:24:52 <SamB> musasabi: that built fine for me!
15:24:59 <SamB> how are you building it?
15:25:11 <Cale> what's hard is convincing a Haskell programmer to write code which uses the terrible APIs that people usually come up with in C.
15:25:13 <Cale> :)
15:25:13 <SamB> wchogg: other issues too
15:25:30 <palomer> they're seriously awful
15:25:34 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
15:25:50 <Cale> there's the foreign function interface documentation
15:26:05 <SamB> Cale: why so many FFIs?
15:26:06 <wchogg> Thanks.
15:26:14 <Cale> SamB: no idea
15:26:27 <Cale> ah
15:26:39 <musasabi> g++ gives me tons of errors and I think I have the relavant things installed.
15:26:39 <jose_da_bicla> anyone with experience with hs-plugins and quickcheck?
15:26:50 <Cale> the ffi documentation tarball just got unpacked into http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:27:28 <wchogg> Okay, this is something I've wondered about for awhile:  is there actually a way to modify something like an array in-place in order to be more efficient?  Or is there absolutely no way in haskell?
15:27:46 <Lemmih> jose_da_bicla: Got a question about hs-plugins?
15:27:56 <tuomov> yes, in the IO monad
15:28:02 <Cale> wchogg: mutable arrays
15:28:05 <jose_da_bicla> yes.. do u mind if a paste a little code here?
15:28:10 <jose_da_bicla> or in pvt..
15:28:10 <palomer> haskell has mutable arrays?
15:28:14 <Cale> Or Diff arrays
15:28:14 <Cale> if you want to keep the pure interface
15:28:17 <Cale> yes
15:28:24 <wchogg> I didn't realize there were mutable arrays, cool.
15:28:24 <palomer> referential transparency means that the same argument returns the same value, right?
15:28:28 <Lemmih> lisppaste2: url
15:28:28 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:28:51 <Cale> palomer: Mutable array modification is considered IO
15:29:01 <astrolabe> palomer: yes
15:29:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
15:29:18 <wchogg> So in place modifications have to take place within a monad like IO, but they are possible.
15:29:20 <Cale> there's the abstract interface
15:29:29 <Cale> yeah
15:29:33 <Cale> or ST even
15:29:59 <astrolabe> wchogg:  check out Diff arrays, they are easy, and maybe just what you need.
15:30:00 <lisppaste2> jose_da_bicla pasted "eval with run" at http://paste.lisp.org/display/13895
15:30:06 <wchogg> Cool.
15:30:25 <Cale> Diff arrays look just like immutable arrays, but a // xs is O(length xs)
15:30:27 <jose_da_bicla> Lemmih: can you see any problem?
15:30:55 <jose_da_bicla> it doesn't do anything useful but besides that.. :P
15:31:15 <Cale> array accesses are also O(1), if you use the array in a single-threaded fashion (only reading the most recently updated version)
15:31:19 <jose_da_bicla> i get a undefined exception every time i try to execute that...
15:31:27 <musasabi> My errors from "make" (did ./configure and it succeeded first) are at http://youzen.b2.fi/~musasabi/a.txt
15:31:31 <soysauce> heh, this is cool
15:31:38 <soysauce> xerox asked me to translate some Haskell code into C++
15:31:45 <Cale> which code?
15:32:11 <soysauce> generate all possible permutations
15:32:58 <Lemmih> jose_da_bicla: And 'run not defOpt' runs fine?
15:33:05 <rafl> Anyone familar with darcs? I'd like to know how darcs recognizes binary files.
15:33:25 <rafl> I've got at least two files which are plain perl modules but darcs thinks they're binary.
15:33:27 <jose_da_bicla> yes
15:33:42 <o_Rocky> jose_da_bicla?
15:33:50 <Cale> rafl: perhaps a strange character encoding?
15:33:56 <soysauce> the output has Haskell syntax :D
15:34:01 <jose_da_bicla> yes o_Rocky?
15:34:08 <o_Rocky> jose_da_bicla: at parece q s portugues...
15:34:18 <jose_da_bicla> disfaro bem :P
15:34:32 <astrolabe> rafl:  There is a #darcs channel I think, if we can't help.
15:35:10 <soysauce> s = you are?
15:35:22 <jose_da_bicla> yes soysauce :P
15:35:32 * soysauce can half read that
15:35:42 <rafl> Cale: latin1
15:35:46 <rafl> astrolabe: Thanks.
15:35:49 <soysauce> "??? it seems that you're Portuguese" ;)
15:35:56 <o_Rocky> yes
15:36:02 <wchogg> So what exactly are unboxed arrays?  What's "unboxed"?
15:36:23 <soysauce> wchogg - check the type of Int
15:36:24 <SamB> wchogg: that means that the values aren't all allocated seperately on the heap
15:36:27 <soysauce> data Int = I# Int#
15:36:40 <SamB> but in one contiguous region
15:36:44 <soysauce> the GHC manual has a nice explanation of unboxed types
15:36:47 <Cale> wchogg: Normally, values in Haskell are really tagged pointers to values
15:36:48 <SamB> rather like the array module in Python
15:36:55 <soysauce> Int# maps *effectively* onto int in C
15:37:00 <soysauce> whereas Int is a data structure
15:37:04 <Cale> which at first actually points to code for computing the value
15:37:35 <Cale> This is how laziness is accomplished
15:37:50 <Cale> To say that a value is unboxed means that it doesn't have that extra layer of indirection
15:37:51 <wchogg> Okay.  So unboxed arrays are for primitive types and they act like arrays of those types in a language like c?
15:38:02 <SamB> wchogg: unboxed arrays
15:38:06 <soysauce> wchogg - IIRC they can hold non-primitive types, too
15:38:08 <Cale> basically -- they will be strict
15:38:13 <SamB> soysauce: not really
15:38:16 <soysauce> hum
15:38:21 <dons> moin
15:38:27 <Cale> Evaluating even one element of an unboxed array will force the evaluation of the whole array
15:38:32 <soysauce> 'lo dons
15:38:48 <wchogg> So the array itself isn't evaluated until a single element is though?
15:38:52 <Cale> right
15:39:13 <wchogg> I can never decide if laziness is awesome or just confusing.
15:39:15 <SamB> not even by seq?
15:39:21 <SamB> wchogg: it is both
15:39:30 <Cale> This is often more efficient, but it really depends on your usage pattern
15:39:42 <soysauce> haha
15:39:43 <SamB> it definately saves space
15:39:45 <Cale> If you don't end up using the whole array, it's a total waste
15:40:01 <Cale> but yeah, it does save lots of space
15:40:28 <soysauce> from what I have read, a number of people are of the opinion that laziness hurts performance in a lot of cases
15:40:49 <soysauce> for all performance in ["time", "space"]
15:41:12 * soysauce thinks it ought to be possible to build a language that accomodates both styles of programming
15:41:14 <wchogg> So why does haskell use laziness as the default with strictness being optional rather than the other way around?  What's the rational for that?
15:41:25 <soysauce> because laziness is easier
15:41:32 <SamB> wchogg: it makes referential transparency truer
15:41:39 <Cale> soysauce: well, it does, but then, it improves compositionality, and lets you write things in ways you couldn't otherwise
15:41:48 <soysauce> ther eis a variant of Haskell that defaults to strictness
15:41:53 <Cale> It also really makes things a whole lot more efficient sometimes
15:42:04 <SamB> and it makes a lot of programs easier to write...
15:42:11 <wchogg> How does it make referential transparency "truer"?  If the language is pure, isn't it always referentially transparent?
15:42:14 <Cale> Basically, you can speed up a slow Haskell program in two ways:
15:42:14 <soysauce> but it's pretty messy. There is no way for them to tell if a computation will terminate.
15:42:20 <astrolabe> lazy evaluation is more general I think
15:42:23 <Cale> Make it stricter, or make it lazier.
15:42:48 <SamB> Cale: also, help the compiler to specialize it or remove irrelevant computation
15:42:53 <SamB> with RULEs and such
15:42:56 <soysauce> they evaluate a computation "for a while", and if it seems to be running away, they stop it and leave it partially evaluated.
15:42:57 <Cale> oh, sure :)
15:43:37 <SamB> or you could use RULEs to help people feel comfortable with writing nicer code
15:43:46 <Cale> Laziness makes datastructures into control-flow mechanisms
15:43:54 <Cale> and really changes the way that you program
15:44:09 <wchogg> I don't see what you mean, Cale.
15:44:15 <Cale> Lists are loops
15:44:34 <soysauce> I thought lists were loops, regardless.
15:44:42 <SamB> like, dons can hopefully feel comfortable write 'P.pack "hello"' instead of 'P.packAddress "hello"#' now that I added a rule which effectively transforms the former into the latter ;-)
15:44:50 <SamB> s/write/writing/
15:44:54 <soysauce> from the beginning I have understood that lists are somewhat analogous to the concept of "iterators" in imperative languages
15:45:06 <Cale> If they're strict, then you have to evaluate the whole list all at once
15:45:27 <soysauce> well, I see
15:45:27 <Cale> which means that there's no way to stop if you've found what you were looking for.
15:45:30 <int80_h> hey did anyone see the "records are broken in haskell" thread on the mailing list?
15:45:41 <wchogg> Oh yeah, I've been following it.
15:45:47 <SamB> and it also makes it a bit difficult to use [1..]
15:45:52 <wchogg> I'm not sure if I understand what the big deal is.
15:45:53 <soysauce> SamB - ;)
15:45:59 <Cale> ugh
15:46:01 <Cale> that thread
15:46:02 <soysauce> sum [1..] heh heh
15:46:03 <int80_h> so why did that guy call records broken?
15:46:03 <Cale> heh
15:46:10 <SamB> what thread?
15:46:21 <SamB> int80_h: cause they are fake records
15:46:21 <int80_h> I think in Haskell cafe, or the other one
15:46:24 <Cale> the thread with over 200 messages in it
15:46:26 <eivuokko> It's too long
15:46:34 <Cale> can't miss it
15:46:36 <int80_h> fake records?
15:46:56 <dons> SamB, hehe. though I couln't get the rule to run in a little test I did. (that doesn't mean it doesn't run though)
15:47:11 <SamB> dons: how did you run it?
15:47:13 <dons> SamB, do you have a nice ghc flag that triggered the right result on your example?
15:47:19 <dons> i just did -O -ddump-simpl
15:47:32 <boegel|home> can one use multiple lines is a case statement ?
15:47:32 <SamB> dons: I think thats what I did...
15:47:36 <SamB> let me try it again
15:47:45 <dons> maybe compilre versions. let  me check.
15:47:47 <wchogg> Are there really only five issues of the monad reader?
15:48:01 <boegel|home> wchogg: yes, but there are more coming up
15:48:11 <boegel|home> wchogg: why ? very interested in it ?
15:48:25 <int80_h> okay I'm confused by what was meant by "fake records"
15:48:43 <dons> with -Onot I get (Data.FastPackedString.pack (GHC.Base.unpackCString# "Hello, World!\n")
15:49:19 <wchogg> Well I've been skimming the old ones and I think they look rather useful for someone who is still learning the language.
15:49:20 <dons> but it's all inlined completely with -O anyway
15:49:36 <dons> check haskell-overflow..
15:49:42 <SamB> dons: maybe thats the wrong flag?
15:49:53 <int80_h> wchogg you just helped me immensely. I thought that it was for people who already knew and were developing the language
15:49:58 <int80_h> so now I will go check it out
15:50:15 <boegel|home> wchogg: that's the whole idea :) we're planning a December issue, I hope we'll be able to make it
15:51:07 <SamB> dons: ah, -ddump-inlinings
15:51:26 <SamB> for some reason on my compiler -ddump-rules does not seem to work
15:52:06 <SamB> its like the second thing in the output for that
15:53:07 <SamB> dons: there?
15:53:12 <dons> Rule fired
15:53:14 <dons>     Rule: pack/packAddress
15:53:14 <dons> :)
15:54:28 <SamB> :)
15:54:54 <dons> @karma+ SamB
15:54:54 <lambdabot> SamB's karma raised to 8.
15:55:06 <SamB> so, *now* will you feel comfortable writing 'P.pack "hello"' instead of 'P.packAddress "hello"#'?
15:55:11 <dons> hmm. I think maybe my long running space leak might have disappeared magically too
15:55:14 <int80_h> oooh ooh I want Karma :)
15:55:15 <dons> oh, maybe..
15:55:17 <dons> I'll see.
15:55:29 <int80_h> will it make me cool at alast?
15:55:34 <SamB> dons: it is probably unrelated
15:55:35 * int80_h always wanted to be cool
15:55:38 <araujo> Hello Haskell'ers!!!
15:55:57 <dons> yeah, unrelated, but i just notice that after 8hrs, 4404K 3988K sleep    poll     8:29  0.00% hmp3
15:56:17 <dons> sorry, 11.31hrs
15:56:40 <dons> which hasn't changed since it started, so that's good. I rewrote some the input handling slightlyy, so maybe that helped.
15:56:51 <astrolabe> hi araujo
15:57:58 <araujo> Hello astrolabe !
16:12:30 <jose_da_bicla> can someone explain what is the class Typeable?
16:12:46 <jose_da_bicla> i want to define a instace of it but i can't understand it...
16:13:08 <SamB> jose_da_bicla: just use "deriving (Typeable)"
16:14:07 <jose_da_bicla> but i'm not defining a new type.. i want to define TestResult as instance of Typeable
16:17:56 <jose_da_bicla> i only can use deriving when defining types right?
16:18:02 <ski_> yes
16:18:06 <jose_da_bicla> *new types
16:18:23 <ski_> right, 'data' and 'newtype' definitions
16:19:56 <dons> Typeable is a class providing the typeOf function, a function that accesses a representation of a values type at runtime.
16:20:21 <dons> It lets us do dynamic typing in statically typed hHaskell, delaying some type checks until runtime.
16:20:47 <dons> It is used in @eval, btw, to check that runtime generated code is type safe at its splice point.
16:21:08 <dons> > typeOf  (1:: Int)
16:21:08 <lambdabot> Int
16:21:19 <dons> > toDyn (1::Int)
16:21:19 <lambdabot> <<Int>>
16:21:28 <ski_> > [typeOf (1:: Int)]
16:21:30 <lambdabot> [Int]
16:21:39 <ski_> > (typeOf (1:: Int),3)
16:21:40 <lambdabot> (Int,3)
16:22:11 <dons> > let dyn = toDyn (1::Int) in 'x' : (fromDynamic dyn)
16:22:11 <lambdabot> Couldn't match `[Char]' against `Maybe a'
16:22:41 <dons> > let dyn = toDyn (1::Int) in case (fromDynamic dyn) of Nothing -> error "types failed" ; Just x -> x + 1
16:22:41 <lambdabot> Add a type signature
16:22:50 <dons> > let dyn = toDyn (1::Int) in case (fromDynamic dyn) of Nothing -> error "types failed" ; Just x -> x + 1::Int
16:22:50 <lambdabot> 2
16:23:13 <dons> > [toDyn 'x', toDyn (1::Int)]
16:23:14 <lambdabot> [<<Char>>,<<Int>>]
16:23:16 <dons> hlists!
16:23:38 <dons> @typeOf [Dynamic.toDyn 'x', Dynamic.toDyn (1::Int)]
16:23:39 <lambdabot> Couldn't find qualified module.
16:23:39 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
16:23:39 <lambdabot> \\)?
16:23:49 <boegel|home> how can I use multiple lines is a case statement item ?
16:24:17 <boegel|home> I want in the case of Nothing to do some IO action, and to return a result, anyone can tell me how?
16:24:27 <dons> Use >> ?
16:24:39 <boegel|home> dons: hmm, explain me pls :)
16:24:45 <dons> Nothing -> do x <- action ; return x
16:24:53 <dons> or Nothing -> action >>= \x -> return x
16:25:09 <dons> is that what you mean?
16:25:26 <ski_> Nothing -> do
16:25:31 <ski_>   x <- action
16:25:36 <ski_>   return x
16:25:38 <boegel|home> actually, currently I'm in 'do case val of Nothing -> doSometing'
16:25:38 <ski_> e.g.
16:25:43 <dons> remember multiple lines are just short hand for inserting the ';' by hand.
16:25:50 <boegel|home> and after doSometing I need todo something else...
16:26:03 <boegel|home> well, I tried that, but I get a parse error :(
16:26:17 <ski_> hm
16:26:19 * ski_ uses that quite a lot ..
16:26:30 <dons> Nothing -> do doSomething ; doSeomthingElse  ; return done
16:26:41 <boegel|home> but maybe it's because the do is outside my case ?
16:28:10 <boegel|home> okay, that was the problem... now I have to repeat the do every time after a case statement, but I guess that's normal ?
16:28:34 <sethk> or use combinators
16:28:42 <ski_> ah, now i understand the issue
16:28:47 <dons> or use combinators. if it's short, I usually use >> or >>=
16:29:10 <dons> e.g. Style.hs:withStyle sty fn = uiAttr sty >>= setAttribute >> fn >> reset
16:29:17 <dons> Core.hs:            Just h  -> hGetLine h >>= warnA
16:29:33 <ski_> boegel|home : yes, when doing a 'case' or 'if' in a 'do' you need to say 'do' again if you need to have several actions in a branch
16:29:36 <boegel|home> dons: hm, okay
16:29:38 <dons> Tree.hs:    if x then do y <- getPermissions a >>= return . readable
16:29:51 <dons> combinatorss rock. and more fun if you use =<< and . together!
16:30:04 <ski_> there's no 'if' nor 'case' command in 'do'  (but there's a 'let' command)
16:30:26 <dons> x <- case of ....  works fine of course
16:31:12 <ski_> (boegel|home : do you also want to return some values from the 'case' and use them later in the surrounding 'do' ?)
16:32:56 <boegel|home> ski_: no... but I might :) I'll ask again then, this Monad stuff is all new to me (yeah, still)
16:34:21 <Taral> stupid computer
16:34:37 <astrolabe> mine too!
16:34:54 <boegel|home> dons: if lambdabot quits (dies, gets killed, whatever), does it loose all of it's data ? (quote, where, ...)
16:35:35 <Heffalump> I doubt it, cos it remembered my quote which is from ages ago
16:35:38 <Heffalump> @quote Heffalump
16:35:38 <lambdabot>  CPP leads to suffering
16:35:39 <dons> nope, it flushes the state to its persistent store
16:35:57 <Heffalump> does it not lose @last information any more either, then?
16:36:14 <dons> do we have an @last ?
16:36:15 <boegel|home> dons: automatically ? also for my Vote module, or do I have to do some stuff for that ?
16:36:30 <boegel|home> Heffalump:  @seen ? :)
16:36:35 <dons> boegel, you get it automagically if you use the Module state component.
16:36:35 <Heffalump> I meant that.
16:36:39 <dons> yes, that's stored.
16:36:46 <boegel|home> dons: coolness ! :)
16:36:46 <dons> in fact in a lovely binary representation :)
16:36:50 <Heffalump> nice
16:36:59 <Heffalump> do you have to implement Binary your own state, then?
16:37:10 <boegel|home> dons: if you want to fiddle with my wip vote module, join #boegelBotTesting :)
16:37:17 <dons> if you want to use binary state, you need to write an instancee yep
16:37:23 <dons> otherwise It just requires Show/Read
16:38:09 <dons> boegel, so to get the persistence, you need to write casess for: 
16:38:10 <dons>   moduleDefState _  = return $ M.empty
16:38:10 <dons>   moduleSerialize _ = Just mapPackedSerial
16:38:34 <dons> where DefStatee is the initial state, and mapPackedSerial is an value of type Serial that will encode and decode your value.
16:38:43 <Taral> @where lambdabot
16:38:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:38:47 <Heffalump> how does it decide whether to use Show/Read or Binary?
16:38:49 <Taral> hehehe
16:38:57 <dons> based on which Serial value you supplyy
16:38:58 <boegel|home> dons: oh, I see... damn :( I still need to figure out the Serialize stuff then...
16:39:24 <dons> what's the state type boegel?
16:39:53 <dons> we have a bunch of prespun serialisers for different types, stdSerial  will work for all that derive Show/Read
16:40:03 <dons> and then there's are specialised serialisers for certain types.
16:40:06 <boegel|home> M.Map P.FastString (Maybe Poll) (with Poll my own type = ([String],[Int])
16:40:24 <boegel|home> err
16:40:26 <boegel|home> make that
16:40:31 <boegel|home> M.Map P.FastString Poll (with Poll my own type = ([String],[Int])
16:40:48 <dons> ok, hmm. stdSerial will work then. but if the state gets big we may want to write a mapPackeded.. for this type
16:41:04 <dons> just use stdSerial for now
16:41:35 <dons> a Serial is a : data Serial s = Serial {
16:41:35 <dons>         serialize   :: s -> Maybe FastString,
16:41:35 <dons>         deserialize :: FastString -> Maybe s
16:41:52 <dons> and stdSerial is stdSerial :: (Show s, Read s) => Serial s
16:41:53 <dons> stdSerial = Serial (Just. P.pack.show) (readM.P.unpack)
16:42:43 <boegel|home> if I use stdSerial, I'll have to provide Show and Read instances for Poll, correct ?
16:42:51 <dons> yep. derive Show Readd!
16:43:02 <Taral> O.o
16:43:10 <Taral> what's up with Lambdabot.lbIO?
16:43:27 <boegel|home> dons: ok :) I'll do that later, thanks for your help
16:43:30 <boegel|home> for now: bedtime !
16:43:44 <dons> Taral: "-- CPS to work around predicativiy of haskell's type system" ;)
16:43:53 <dons> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
16:43:54 <dons> lbIO k = LB $ ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
16:44:01 <dons> we should ask TheHunter sometime
16:44:22 <boegel|home> bye !
16:44:26 <dons> night boegel
16:44:29 <Taral> yeah, that's what I'm wondering about
16:47:38 * Heffalump tries to understand that type
16:48:32 <Heffalump> oh, I think I see.
16:48:41 * Heffalump tries to work out the details
16:49:32 <Heffalump> he wanted to write something that would lift an IO computation into LB, but allow the IO computation to run LB computations when it needed to.
16:50:01 <dons> yeah, I think that's it.
16:50:09 <dons> it's just used in some error catching code
16:50:11 <Taral> O.o
16:50:15 <Heffalump> I can't quite see the type he wanted to pass.
16:50:16 <ski_> interesting idea/idiom
16:50:16 <Taral> it still looks scary
16:50:24 <Heffalump> s/pass/give it/
16:50:53 <dons> for example: withMS :: (s -> (s -> LB ()) -> LB a) -> ModuleT s LB a
16:50:53 <dons> withMS f = lbIO $ \conv -> withMWriter ?ref $ \x writer ->
16:50:54 <dons>   conv $ f x (liftIO . writer)
16:51:05 <dons> oh, and implict params too!!
16:51:10 <dons> lambdabot is such cutting edge stuff
16:51:17 <Taral> implicit params make me twitch
16:51:54 * Heffalump tries to decipher that s -> (s -> ..)
16:52:15 <dons> some state value functionally dependent on the module
16:52:27 <Heffalump> oh, s is repeated later, right
16:52:43 <dons> withMS takes a writer function and does some action on the state
16:52:49 * Heffalump decides not to bother trying to work it out :-)
16:52:58 <dons> withMVar-style
16:53:06 <Heffalump> I barely understood the original way that tower of transformers worked, and I'd written it..
16:53:17 <dons> thanks Heffalump ;)
16:53:28 <dons> I'd have just stuck with IO, but oh well, this is sure fun!
16:53:46 <Heffalump> to some extent the games I played with LB and IRC monads were just cos I could
16:53:51 <ski_> dons : hm, that type looks like state-in-context comonad ..
16:54:15 <Heffalump> but I think there was some concrete benefit, in the way it could handle both being connected and not being connected and have that be part of the type
16:54:53 <dons> ah, yes, I remember this now.
16:55:26 <dons> we should document this one day. lambdabot needs more docs
16:55:32 <dons> a global view of the code
16:57:25 <Heffalump> docs aren't all that useful, generally.
16:57:35 <Heffalump> though yeah, a global view would be
16:57:42 <Heffalump> and interface docs are always important
16:57:55 <dons> @remember Heffalump docs aren't all that useful, generally
16:57:59 <dons> ;)
17:00:03 <Heffalump> aargh, I musn't let that quote get around at work :-)
17:00:24 <SamB> Heffalump: well, that just means that most docs are useless
17:00:50 <SamB> so you must be carefully to make usefull ones ;-)
17:01:06 <SamB> @quote Heffalump 
17:01:06 <lambdabot> Heffalump  hasn't said anything memorable
17:01:15 <SamB> @quote Heffalump
17:01:16 <lambdabot>  CPP leads to suffering
17:01:20 <SamB> dons: fixorate!
17:01:24 <jose_da_bicla> lisppaste2: url
17:01:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:01:29 <SamB> @quote
17:01:29 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
17:01:35 <SamB> @quote
17:01:36 <lambdabot> shapr says: I don't know why the GHC team won't accept my spoonIO
17:01:36 <lambdabot> patch
17:01:58 <SamB> shapr: what does that do?
17:01:58 <SamB> @quote
17:01:59 <lambdabot> ghc says: WARNING: SE CAFs unsupported, forcing UPD instead
17:02:00 <dons> hmm, that's a weird bug
17:02:12 <dons> unless it's a quote..
17:02:20 <lisppaste2> jose_da_bicla pasted "instance typeable testresult" at http://paste.lisp.org/display/13899
17:02:23 <SamB> which is bug?
17:02:36 <dons> "Heffalump  hasn't said anything memorable"
17:02:46 <jose_da_bicla> can someone see the paste and tell me if it is ok?
17:02:52 <Heffalump> it's the space
17:02:52 <jose_da_bicla> :s
17:02:56 <SamB> dons: I obviously used tab completion and ended up saying "@quote Heffalump "
17:03:07 <Heffalump> the input needs chomping
17:03:17 <SamB> yes! much chomping!
17:03:18 <Heffalump> where chomp = reverse . dropWhile isSpace . reverse
17:03:42 <dons> we in fact have this function already. /me patches
17:03:57 <dons> dropSpace = let f = reverse . dropWhile isSpace in f . f
17:04:13 <dons> double chomp!
17:04:18 <SamB> hmm
17:04:32 <SamB> and this doesn't scare you?
17:04:44 <dons> it's lovely
17:04:46 * SamB teases dons about strings
17:04:54 <dons> i'll string you up good!
17:05:02 <SamB> hehe
17:05:17 <dons> ok, P.reverse . P.dropeWhile isPsace in f . f then..
17:05:50 <dons> I'm mostly playing with faststrings  in hmp3, SamB ;) 
17:05:55 <dons> just for fun
17:08:05 <SamB> you have interesting ideas of fun
17:08:13 <dons> :p
17:08:55 <dons> it's like heffalumps tower of monad transformers
17:15:28 <Heffalump> @quote          Heffalump          
17:15:28 <lambdabot> Heffalump           hasn't said anything memorable
17:15:41 <Heffalump> bah, dons is clearly too slow with his dynamic patchery
17:16:07 <dons> it's on its way...
17:16:38 <Heffalump> :-)
17:16:48 <SamB> dons: why does it take so long?
17:17:11 <dons> i forgot to test the patch, and broke it twice
17:17:29 <dons> @dynamic-reload babel
17:17:29 <lambdabot> module reloaded
17:17:34 <dons> @quote    Heffalump
17:17:34 <lambdabot>  CPP leads to suffering
17:17:38 <dons> @quote    Heffalump     
17:17:38 <lambdabot>  docs aren't all that useful, generally
17:17:41 <Taral> what are you using for dynamic loading?
17:17:41 <dons> :)
17:17:47 <dons> @where hs-plugins
17:17:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:17:47 <SamB> @quote Heffalump 
17:17:47 <lambdabot>  docs aren't all that useful, generally
17:17:50 <Taral> hs-plugins? fun.
17:18:05 <Taral> Are they going to integrate the dynamic-friendly loading into the main libraries?
17:18:10 <SamB> isn't that what its for? lambdabot plugins?
17:18:29 <dons> Taral, nope, just use hs-plugins, it's cabalised anyway.
17:18:49 <dons> SamB, hs-plugins?
17:18:55 <SamB> dons: yeah
17:19:17 <dons> I wrote that originally so I could use haskell as the configuration language for conf files in a mutt-alike project I was working on
17:19:31 <SamB> huh
17:21:33 <palomer> mutt for haskell!
17:21:48 <Taral> haskell for mutt.
17:22:42 <palomer> cabalised?
17:22:55 <Taral> @where cabal
17:22:55 <lambdabot> http://www.haskell.org/cabal
17:23:51 <Taral> You know, I think I like implicit params better than monads.
17:24:01 <dons> Taral, bad bad ;)
17:24:23 <Taral> Well, take this Reader monad.
17:24:33 <Taral> It's very similar to implicit params, but is monadic.
17:25:14 <palomer> libraries should be downloaded dynamically.
17:25:20 <palomer> why doesn't anyone invent such a system?
17:25:41 <palomer> this way, we won't need to install libraries anymore
17:25:58 <SamB> palomer: first, we need to do the "libraries should be downloaded and built on command" milestone
17:26:20 <palomer> but we agree that dynamic downloading would be a good thing, right?
17:26:35 <SamB> hmm. dunno what you mean by that, really ;-)
17:26:41 <ski_> implicit params is more or less same thing as reader/environment monad, only more implicit
17:27:01 <ski_> (it's a quite weak effect)
17:27:04 <SamB> I think it would be a pain if my software had to compile modules when I used features I hadn't used before
17:27:20 <SamB> lamer if it needed to download them too
17:27:34 <palomer> require 'bst tree' would go and download 'bst tree' while you compile
17:27:44 <palomer> or before you compile
17:27:57 <palomer> subsequent compiles would check if you have the latest version on your system
17:28:02 <SamB> how is that different from what I said?
17:28:14 <SamB> and why would you want to update to the latest for no reason?
17:28:26 <palomer> SamB: you would have version numbers, of course
17:28:43 <SamB> we have those already, palomer 
17:28:43 <palomer> so, like, require 'bst tree' 1.2 would download the latest 1.2 release
17:28:56 <palomer> SamB: so you don't need to install libraries on your system?
17:28:57 <SamB> also, we don't allow spaces in package names
17:29:03 <SamB> palomer: you do
17:29:20 <SamB> the part where it downloads and installs automatically needs some work
17:29:20 <TheHunter> Taral, dons, the purpose of lbIO is to be able to "unlift" LB computations into IO computations, giving them the same power as implicit parameters (with things being a "little" more explicit). A simpler example for its use than withMS can be found for example in Paste.hs, where it allows us to forkIO a LB.
17:29:34 <palomer> right, in this system you wouldn't. you just import it into your code and have haskell figure out how to get it and install it
17:30:03 <SamB> palomer: that is installing on your system
17:30:17 <dons> TheHunter, right. cool.
17:30:26 <SamB> what you are describing is probably the facility codenamed "cabal-get"
17:30:48 <TheHunter> another example for the technique: http://www.mail-archive.com/haskell-cafe@haskell.org/msg10444.html
17:31:13 <TheHunter> maybe I should _really_ document this function sometime, but it's so hard to describe...
17:31:27 <palomer> SamB: you wouldn't need to type anything at the command line, though
17:31:35 <palomer> SamB: it would be completely transparent to the programmer
17:31:45 <SamB> palomer: um
17:32:00 <SamB> but than how would it know I wanted to compile *my* program?
17:32:13 <dave_m> I'd prefer that my compiler *not* download libraries without my knowledge
17:32:15 <palomer> you compile your program and it'll fetch the libraries on the fly
17:32:23 <SamB> and nothing is really transparent when you have a 56k modem and a 450 MHz PII with 256 MiB of RAM
17:32:32 <palomer> say you want to use binary trees
17:32:47 <SamB> and yeah, I'd want it to be just a bit intrusive
17:32:47 <palomer> you search the repository and you see that there's a library called "BTree" or somesuch
17:32:59 <SamB> I'd use Data.Map ;-)
17:33:18 <SamB> or the appropriate algorithmic structure
17:33:29 <palomer> then you add this line of code 'require 'BTree'" in your .hs file, and then you can use it as you wish. The compiler will then fetch the library before it compiles the file
17:33:42 <SamB> in your hs file?
17:33:43 <SamB> no!
17:33:45 <SamB> not there
17:33:47 <palomer> why?
17:33:51 <SamB> in your .cabal file
17:33:57 <palomer> no!
17:33:58 <palomer> .hs!
17:34:03 <SamB> yes! .cabal!
17:34:07 <palomer> no! .hs!
17:34:11 <SamB> purity of the Haskell!
17:34:23 <palomer> why complicate things?
17:34:33 <SamB> yes, why?
17:34:59 <palomer> look, having one line in my .hs with the familiar syntax versus a jumble of crap in my .cabal file. you decide
17:35:23 <palomer> besides, you'll need to put a line of code in your .hs file _anyways_
17:35:29 <palomer> might as well have that line of code fetch the libraries
17:35:41 <palomer> check if it's the latest subversion available
17:35:42 <palomer> etc...
17:36:17 <ski_> more flexible if such paths are stated externally to .hs file ..
17:36:37 <palomer> ski_!
17:36:55 <palomer> ski_: how much flexibility do we really need?
17:37:03 <ski_> (yes, that is the question)
17:37:03 <palomer> all I want to do is use a library called BTree
17:37:14 <palomer> what more could I want?
17:37:23 <ski_> you need to bind it somehow to it's repository
17:37:33 <palomer> you'd have a central repository
17:37:34 <palomer> of course
17:37:38 <palomer> GPG'd and the lot
17:37:59 <ski_> hopefully you get the right 'BTree' lib (and not something else which is just named the same)
17:38:43 <ski_> also, you need an interface to program to, so you need to know the interface before linking with the lib
17:38:43 <palomer> ski_: you'd have done a search, and located the library you need
17:38:47 <eivuokko> I have slight problems trying to understand what is the big deal between compile time and configure/compile time.
17:39:13 <dons> you don't want the compiler to need a network connectoin ;) kinda bad on the semantics
17:39:26 <palomer> dons: it would, of course, be optional
17:39:38 <palomer> furthermore, it would ensure that everyone is using the latest version of a library always
17:39:49 <palomer> ski_: interface meaning module signature?
17:39:55 <ski_> which is not always a Good Thing(tm)
17:40:10 <palomer> ski_: you'd specify version numbers. minor version numbers would be for bug fixes
17:40:11 <ski_> yes, API
17:40:21 <palomer> ski_: well, you read up on it from a webpage
17:40:39 <ski_> or some module browser
17:40:43 <palomer> sure
17:40:51 <ski_> (possibly integrated with lib search system)
17:41:00 <palomer> yeah
17:41:13 <palomer> people could leave comments in the lib search system
17:41:16 <palomer> ratings
17:41:17 <palomer> etc..
17:41:37 <palomer> (this isn't off the top of my head, I've been thinking of this for quite a while)
17:41:51 <palomer> I hate installing libraries and fiddling with makefiles
17:42:27 <palomer> no network connection? no problem, just store the repository on your hard disk or CD
17:42:44 <palomer> who's with me?
17:43:15 <palomer> don't all speak at once
17:44:00 <dave_m> it'd suck if you mistyped a module name, and your compiler went and installed some huge library
17:44:27 <sethk> palomer, a "do you really mean it" question wouldn't be out of place, as dave_m notes
17:44:32 <SamB> palomer: I fail to see how "require" in a .hs file is familiar
17:44:49 <SamB> furthermore, the Haskell standard has, as a rule, tried to avoid talking about that sort of thing
17:44:50 <palomer> dave_m: ditto if you did it with cabal-get
17:44:53 <sethk> it's familiar if you program in ruby  :)
17:45:06 <palomer> SamB: yeah, it could be a ghc extension or somesuch
17:45:10 <SamB> sethk: I don't
17:45:33 <palomer> sethk: you can do this already in ruby?
17:45:35 <palomer> since when!
17:45:35 <SamB> palomer: its really not going to fly
17:45:40 <palomer> SamB: why not?
17:45:58 <sethk> palomer, no, I just meant the syntax  :)
17:46:10 <palomer> oh, well use any word you like
17:46:23 <SamB> palomer: hardly anyone will want that in their .hs files
17:46:26 <palomer> installAndUsePackage "BTree"
17:46:28 <dave_m> there's a reason that cpan isn't built into perl
17:46:35 <palomer> dave_m: it should be!
17:46:46 <SamB> and it isn't terribly familiar
17:47:00 <sethk> dave_m, doesn't cpan have an option to install automatically, or to confirm?
17:47:46 <sethk> dave_m, that is, it isn't the default, but you can make it automagical if you wish to?
17:47:46 <dave_m> I don't think trying to use a module will trigger a download
17:47:56 <sethk> dave_m, I thought it would, but I could be wrong
17:48:04 <palomer> SamB: why not have import do it?
17:48:07 <dave_m> of course, I haven't checked recently
17:48:29 <SamB> palomer: because I have a 56k modem and a 450 MHz PII?
17:48:55 <SamB> and because I don't like code being downloaded unless I desire it to be so?
17:49:00 <palomer> SamB: so you'd have the repo on your hard disk
17:49:14 <palomer> or a CD
17:49:35 <dave_m> I could go along with a program that analyzed my software and downloaded necessary modules; just not something that runs as part of normal compilation
17:49:43 <SamB> palomer: also, because I don't want my Haskell files cluttered with that sort of thing
17:49:46 <ski_> hm, it could possibly be configured to ask about remote connections ..
17:50:01 <palomer> ski_: yes!
17:50:08 <SamB> how about just leaving it to cabal-get?
17:50:19 <palomer> or "I can't find this module anywhere, downloaded automatically (y/n)"
17:50:30 <palomer> SamB: this way is simpler
17:50:41 <SamB> palomer: not really
17:50:53 <palomer> I don't have to think of .cabal files
17:50:53 <SamB> I don't want yet more ways for GHC to be buggy
17:50:55 <dave_m> how often do you need to download new libraries, anyway?
17:51:05 <sethk> palomer, I think the failure cases could get extremely messy
17:51:15 <palomer> dave_m: that's like the slackware people saying "how many times do you need to upgrade your software"
17:51:17 <Frederick> yo SamB 
17:51:28 <SamB> Frederick: yo
17:51:37 <palomer> sethk: "module could not be downloaded, install it yourself. ABORT"
17:51:45 <SamB> palomer: well, we like to sweep these nasty details off to the side
17:51:55 <Frederick> SamB, I think Im drunk or lost a piece of the code
17:51:57 <dave_m> "how many times" /= "how often"
17:51:58 <sethk> palomer, that's a fine message, but you have to actually abort whatever you did.
17:52:02 <palomer> sweep? I haven't swept anything!
17:52:05 <sethk> palomer, download is hardly the only thing that can fail
17:52:09 <SamB> Frederick: well, did you drink anything?
17:52:15 <palomer> sethk: what else could fail?
17:52:35 <Frederick> SamB, nope, cause I seem unable to run remove useless
17:52:49 <sethk> palomer, everything.  version clashes, misspecified dependencies, everything that fails with every system of this kind
17:52:58 <SamB> palomer: building
17:53:46 <palomer> sethk: minor versions would be for bug fixes only, the repo could check for this
17:54:01 <SamB> Frederick: oh?
17:54:07 <palomer> if the module signature is the same, how could it not build?
17:54:07 <sethk> palomer, that's fine, but there would still be problems and errors.  there always are, and you have to handle them.
17:54:11 <SamB> just unable to run it?
17:54:31 <dave_m> it would be nice if more haskell libraries were available through port/apt-get/rpm/etc.
17:54:44 <SamB> palomer: well, for instance, I have GHC 6.4
17:54:49 <palomer> SamB: because it's buggy? you're in the same situation if you downloaded it manually
17:55:34 <Frederick> SamB, dunno the code seems broken! =/
17:55:38 <palomer> SamB: after the module has downloaded, it's exactly as if you had installed it yourself!
17:55:45 <SamB> really, I just don't think that that is an appropriate thing to do in Haskell.
17:55:53 <SamB> its not in the spirit of the thing
17:55:59 <SamB> Frederick: whats the error?
17:56:12 <palomer> ski_: typeclasses correspond to third order predicates, right?
17:56:17 <dave_m> hi, shapr
17:56:42 <shapr> Greetings eyrie dave.
17:56:49 <Frederick> SamB, remove useless doesnt seem to work
17:57:12 <SamB> <lambdabot> shapr says: I don't know why the GHC team won't accept my spoonIO
17:57:16 <SamB> <lambdabot> patch
17:57:16 <SamB> <SamB> shapr: what does that do?
17:57:22 <shapr> dave_m: Want to write an article for The Monad.Reader? 
17:57:22 <SamB> Frederick: try removeUseless ?
17:57:27 <Heffalump> palomer: what makes you say that?
17:57:46 <Taral> okay... what is the difference between m (forall a. m a -> IO a) and forall a. m (m a -> IO a)?
17:57:52 <ski_> palomer : third order predicates ?
17:57:56 <shapr> SamB: It's like forkIO, but it interleaves it like two people spooning, so it's called spoonIO.
17:58:01 <palomer> ski_: err, second order predicates
17:58:09 <dave_m> shapr: I've thought about it. Any interest in how declare a set that's also a monad?
17:58:10 <palomer> because, well, their argument is a predicate
17:58:11 <SamB> shapr: hehe
17:58:13 <palomer> namely a type
17:58:21 <shapr> SamB: Ok I was really tired and silly.
17:58:32 <shapr> dave_m: Sounds cool to me.
17:59:09 <ski_> Taral : is 'm' a monad ?
17:59:24 <Cale> Taral: In the first one, the monad is containing polymorphic functions
17:59:40 <Taral> yes
17:59:50 <Taral> hm.
17:59:51 <Taral> Oh!
17:59:55 <Taral> I see...
18:00:04 <Taral> so why can't you have the first one in Haskell?
18:00:04 <Frederick> SamB, yo
18:00:10 <Frederick> SamB, yup I meant
18:00:12 <Cale> that was poorly phrased, but you know what I mean :)
18:00:19 <Taral> Yes, I do.
18:00:36 <dave_m> Taral: the first one is impredicative
18:00:40 <sethk> I don't  :)
18:00:41 <shapr> dave_m: You can become a TMR author by creating an account and telling me the name you chose http://www.haskell.org/tmrwiki/UserPreferences I suspect you'll choose DaveMenendez ?
18:00:45 <Taral> this word, I do not know what it means.
18:01:01 <Taral> "impredicative"
18:01:04 <Cale> Types like that just aren't available in H98
18:01:08 <dave_m> I'm not sure what it means, either. Look for Simon PJ's paper on "boxy types"
18:01:13 <Cale> there's an extension coming real soon now
18:01:16 <Taral> @google "boxy types"
18:01:17 <shapr> TaPL talks about impredicativity as well.
18:01:17 <lambdabot> http://research.microsoft.com/users/simonpj/papers/boxy/
18:01:19 <Cale> yeah, boxy types :)
18:01:24 <dave_m> shapr: DaveMenendez would be swell
18:01:32 <shapr> TaPL has lotsa goodies.
18:02:08 <dave_m> Is TaPL still in print?
18:02:10 <ski_> (confusing these two types can lead to type-system being unsound, i think (consider old SML, where the "monad" is the implicit side-effects, and where they didn't have stuff like "imperative type-vars" or "value polymorphism restrition"))
18:02:18 <shapr> Hey did anyone figure out the DARCS_APPLY_HTTP bit that Juliusz suggested on darcs-users?
18:02:31 <shapr> dave_m: I think so, isn't it from 2003 or so?
18:02:43 <shapr> I'd still love to have ATTaPL though.
18:02:53 * ski_ too
18:03:09 <shapr> But I'm saving money for my move south...
18:03:10 <dave_m> Hmm. I just assumed it was older. That's another entry for my Amazon wish list, I guess
18:03:25 <Frederick> SamB, do you stil have any version of the code with you?
18:03:57 <SamB> Frederick: yes
18:04:06 <shapr> dave_m: Once you've created your account and logged in, you'll have access on TmrWiki.
18:04:23 <SamB> Frederick: paste.lisp.org does too
18:04:31 <Frederick> SamB, can you check if remove useless is there and works
18:04:33 <Frederick> ?
18:04:33 <Taral> er, 404: http://research.microsoft.com/users/simonpj/papers/boxy/boxy-pldi.ps.gz
18:04:41 <Frederick> SamB, Im checking pastes
18:04:53 <SamB> http://paste.lisp.org/display/13842
18:04:59 <Taral> aha, boxy.ps.gz
18:05:12 <SamB> I must go now, sorry!
18:05:25 <dave_m> also <http://www.cis.upenn.edu/~dimitriv/boxy/boxy.ps>
18:05:47 <shapr> TaPL is from 2002 it seems, http://www.cis.upenn.edu/~bcpierce/tapl/ 
18:05:57 <shapr> There appear to have been three printings, I don't know which one I have.
18:06:17 <Frederick> SamB, that doesnt have remove useless wierd
18:07:07 <dave_m> gack, US$57.39
18:08:39 <shapr> dave_m: It's worth it.
18:09:22 <shapr> I've kept TaPL in my backpack for months, I read it on the bus and write in the margins.
18:09:46 <eivuokko> TaPL = Types and Programming Languages by Pierce?
18:09:51 <ski_> indeed
18:09:56 <Frederick> SamB, wird I have uselles comented out and no remove useless
18:09:57 <dave_m> Since it still costs US$48 used, it must be popular
18:10:27 <shapr> I now have an excellent collection of animals drawn in my margins, including Jacque, the Weakly Typed Kangaroo Rat of Doom.
18:11:13 <shapr> I tend to write notes, questions, doodles, pictures, etc in the margins of books I read.
18:11:41 <shapr> TaPL has large margins, so it's especially nice. Dead Reckoning has tiny margins, no space for notes.
18:11:59 <Taral> @where impredicative
18:12:00 <lambdabot> I know nothing about impredicative.
18:12:09 <Taral> @where+ impredicative http://en.wikipedia.org/wiki/Impredicative
18:12:10 <lambdabot> impredicative ~> http://en.wikipedia.org/wiki/Impredicative
18:12:26 <dons> @wikipedia Impredicative
18:12:26 <lambdabot> http://en.wikipedia.org/wiki/Impredicative
18:12:44 <Taral> that's just a url-construction hack.
18:12:48 <dons> nah it isn't
18:12:50 <Taral> @wiki Impredicative
18:12:50 <lambdabot> http://www.haskell.org/hawiki/Impredicative
18:12:56 <dons> @wikipedia impredicativity
18:12:57 <lambdabot> No result found.
18:13:04 <dons> oh well, it does do a search
18:13:16 <Taral> I figured @where was a better way to do it, since people won't know to look in @wikipedia.
18:13:45 <dons> hmm, but @where is for haskell projects
18:13:47 <ski_> (possibly there should be a hawiki page on it, on how  it relates to type theory and haskell ..)
18:13:49 <Taral> *shrug*
18:13:50 * ski_ leaves
18:13:54 <Taral> @where- impredicative
18:13:55 <lambdabot> Maybe you meant: where where+
18:13:59 <Taral> hm, can't remove :)
18:14:02 * Frederick cries
18:14:04 <dons> can't remove.
18:14:12 <Taral> *shrug* Won't hurt anything.
18:14:24 <dons> yeah, it's ok.
18:15:08 <Taral> so are boxy types going into ghc?
18:15:37 <dave_m> they're working on it, possibly for ghc 6.6
18:19:58 <SamB> Frederick: isn't it called removeUseless?
18:20:15 <Frederick> SamB, nope Ive grepped the file for it but I cant find
18:20:37 <SamB> Frederick: oh maybe we didn't do that yet?
18:20:50 <Frederick> this is wierd the only thing present there is useless cfg = Map.keys (Map.filter null (productions cfg))
18:21:10 * Frederick knows it was there
18:21:21 <SamB> mine hasn't got it either
18:21:45 <SamB> none of the versions I have do, in fact
18:21:58 <SamB> @google removeUseless site:paste.lisp.org
18:21:59 <lambdabot> No result found.
18:22:07 <Frederick> SamB, but I remmember using it =/ wird, and I have that useless lines wich is retty much the idea
18:22:18 <SamB> Frederick: well
18:22:24 <Frederick> just removes the tuples with empty right
18:22:43 * SamB wonders if this is the one he wrote on paper in history class because he was bored
18:23:13 <Frederick> SamB, NT 'Y':=[] must be removed
18:23:20 * Frederick checks his files
18:23:36 <Taral> What is F_\leq?
18:23:48 <Taral> I've seen F_\omega
18:23:48 <Lokadin> would you say that haskell has better performance then java? 
18:23:55 <Taral> Lokadin: If you use it right, yes.
18:24:40 <Lokadin> Taral: kk
18:25:03 <Lokadin> Taral: well on average would you say? i mean assuming you don't optimize like mad..
18:25:21 <dons> on average, certainly.
18:25:34 <Lokadin> kk :D
18:25:37 <Lokadin> just wondering thanks
18:25:48 <Taral> F_\leq, anyone?
18:26:25 <dons> java: all the interactivity of compiled code, with the performance of interpreted code
18:26:47 <Korollary> not on serverside afaik
18:26:58 <soysauce> @pl \f -> f 0
18:26:58 <lambdabot> ($ 0)
18:27:04 * soysauce loves pl
18:27:12 <dons> that's a nice one.
18:27:39 <soysauce> haha, interesting comment re: Java ;)
18:29:43 <Taral> what is pl?
18:29:49 <shapr> pointless
18:29:51 <soysauce> haha
18:29:51 <Taral> ooh
18:29:53 <arjanb> Taral: F_\leq is system F with subtyping
18:29:56 <Taral> howzat work?
18:30:03 <Taral> arjanb: Thank you.
18:30:05 <dons> @pl \f x -> f x
18:30:05 <lambdabot> id
18:30:16 <dons> @pl \f x y -> f x y f y
18:30:17 <lambdabot> flip flip id . (ap .) . (flip =<< (flip .))
18:30:23 <Taral> O.o
18:30:27 <soysauce> Taral - it removes lambdas or something like that
18:30:29 <Taral> there's a =<< in there
18:30:34 * soysauce views it as "The Great Simplifier"
18:30:39 <Frederick> SamB, is it at you notebook?
18:30:43 <dons> @type =<<
18:30:44 <lambdabot> parse error on input `=<<'
18:30:50 <SamB> Frederick: I dunno.
18:30:59 <Taral> @type (=<<)
18:30:59 <soysauce> @type (=<<)
18:30:59 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
18:31:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
18:31:02 <Taral> LOL
18:31:07 <Lokadin> how about the perforamnce of say haskell in comparison to scheme
18:31:10 <SamB> I think so though, because I wrote it again and it seems like the same program
18:31:11 <Taral> @type flip
18:31:12 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
18:31:17 <SamB> er, function
18:31:17 <Korollary> it's faster than scheme
18:31:28 <Taral> @type (flip =<< (flip .))
18:31:30 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> a1 -> b ->
18:31:30 <lambdabot> c
18:31:30 <lambdabot>   Expected type: (a -> a1 -> b -> c) -> a -> (a -> a1 -> b -> c) ->
18:31:30 <lambdabot> c1
18:31:30 <soysauce> er, isn't flip =<< the same as <<=?
18:31:38 <dons> no such operator
18:31:38 <soysauce> @type flip =<<
18:31:39 <lambdabot> parse error (possibly incorrect indentation)
18:31:43 <Taral> You're thinking of flip . (=<<)
18:31:44 <SamB> soysauce: no, thats >>=
18:31:51 <soysauce> er right, sorry
18:32:00 <soysauce> @type (>>=)
18:32:01 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:32:03 <Taral> @type \f x y -> f x y f y
18:32:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t ->
18:32:04 <lambdabot> t3 -> t4
18:32:04 <lambdabot>   Expected type: t
18:32:06 <Taral> LOL
18:32:13 <soysauce> @type flip (<<=)
18:32:14 <lambdabot> Not in scope: `<<='
18:32:18 <Frederick> SamB, is the definition of the function the same as Ive posted?
18:32:20 <soysauce> @type flip (=<<)
18:32:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> (a -> m b) -> m b
18:32:28 <soysauce> they are the same :|
18:32:54 <Taral> Hm, so @pl will construct notations for impossible programs :)
18:32:59 <SamB> Frederick: you mean useless?
18:33:09 <soysauce> that's not an impossible program
18:33:14 <soysauce> er
18:33:16 <soysauce> nevermind.
18:33:17 <dons> not impossible, they're normal programs
18:33:23 <dons> sometimes more concise
18:33:24 <Taral> Okay, untypeable programs.
18:33:26 <SamB> Frederick: I changed it a bit to make sure it doesn't delete the root
18:33:33 <dons> they're not untyped ;)
18:33:38 <dons> they're well-typed
18:33:39 <dons> hehe
18:33:40 <Taral> I didn't say that.
18:33:45 <Taral> I said untypeable, not untyped.
18:33:53 <Taral> @type \f -> f f
18:33:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
18:33:54 <lambdabot>   Expected type: t
18:34:00 <dons> "untypeable" == not typeable, but these are certainly typeable hehe
18:34:06 * soysauce tries to decide if \f x y -> f x y f y is possible
18:34:09 <Taral> What's the type of \f -> f f
18:34:17 <lisppaste2> SamB annotated #13842 with "removeUseless" at http://paste.lisp.org/display/13842#2
18:34:23 <dons> that may not be typeable.
18:34:27 <dons> @type \f x y -> f x y f y
18:34:27 <Taral> Right, but...
18:34:28 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t ->
18:34:28 <lambdabot> t3 -> t4
18:34:28 <lambdabot>   Expected type: t
18:34:29 <Taral> @pl \f -> f f
18:34:30 <lambdabot> join id
18:34:35 <Taral> See?
18:34:36 <dons> there you go.
18:34:39 <dons> it's purely syntactic
18:34:41 <SamB> @pl \f -> f f
18:34:41 <lambdabot> join id
18:34:47 <Taral> <Taral> Hm, so @pl will construct notations for impossible programs :)
18:34:50 <SamB> @type join id
18:34:51 <lambdabot> Not in scope: `join'
18:34:52 <Taral> is what I said.
18:34:56 <dons> that's just a side-effect though
18:35:02 <Taral> Yeah.
18:35:10 <SamB> @index join
18:35:10 <soysauce> @type Monad.join id
18:35:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
18:35:11 <lambdabot>   Expected type: a -> a -> a1
18:35:11 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
18:35:11 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
18:35:11 <lambdabot> Control.Monad.Error, Control.Monad.List
18:35:14 <Taral> Not sure why it's using monadic combinators
18:35:20 <dons> theyr'e short.
18:35:22 <Taral> @type Monad.join
18:35:23 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
18:35:29 <soysauce> @type Monad.join
18:35:30 <Taral> Which monad is it using?
18:35:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
18:35:43 <soysauce> how the heck can you get join id?
18:35:51 <soysauce> id isn't a monad
18:35:51 <Taral> Is what I'm wondering.
18:35:55 <Taral> @type id
18:35:56 <lambdabot> forall a. a -> a
18:36:11 <Taral> How does one unify m (m a) and a -> a?
18:36:22 <soysauce> indeed
18:36:33 <Taral> @pl \f -> f $ Maybe f
18:36:34 <lambdabot> ap id Maybe
18:36:38 <SamB> Monad ((->) a) ?
18:36:44 <Taral> @type \f -> f $ Maybe f
18:36:45 <lambdabot> Not in scope: data constructor `Maybe'
18:36:49 <Taral> @type \f -> f $ Data.Maybe.Maybe f
18:36:50 <lambdabot> Not in scope: data constructor `Data.Maybe.Maybe'
18:36:56 <Taral> @type \f -> f $ Just f
18:36:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = Maybe a ->
18:36:58 <lambdabot> b
18:36:58 <lambdabot>   Expected type: a
18:37:01 <Taral> Still infinite.
18:37:18 <Taral> @pl \f -> f . f
18:37:19 <lambdabot> join (.)
18:37:23 <Taral> @type \f -> f . f
18:37:24 <lambdabot> forall c. (c -> c) -> c -> c
18:37:30 <Taral> ah, here we go.
18:37:34 <Taral> @type Monad.join (.)
18:37:34 <lambdabot> forall c. (Monad ((->) (c -> c))) => (c -> c) -> c -> c
18:37:38 <Taral> !!!
18:37:43 <Frederick> SamB, http://paste.lisp.org/display/13900
18:37:55 <Frederick> that Y[] shouldnt be ther 0o
18:38:03 <Taral> um...
18:38:10 <Taral> That @pl isn't using Monad.join, what is it using?
18:38:18 <SamB> Frederick: thats an empty
18:38:24 <SamB> not a useless
18:38:39 <SamB> hmm, actually.
18:38:41 <dons> it's using Monad.join, afaik.
18:38:43 <SamB> I didn't do this right.
18:38:44 <Cale> it is
18:38:52 <Taral> What about the bizarre class constraint?
18:38:53 <Cale> with the (e->)
18:38:55 <Cale> monad
18:39:02 <Taral> The what monad?
18:39:26 <Taral> Is that a monad?
18:39:27 <Cale> Reader, essentially -- functions from any particular type
18:39:28 <soysauce> fromIntegral is fast, isn't it?
18:39:29 <shapr> Reader?
18:39:46 <Frederick> SamB, Imho it is not wrong there is only a step missing
18:39:48 <dons> @kind forall a. (->) a
18:39:49 <lambdabot>   `(->) a' is not applied to enough type arguments
18:39:49 <lambdabot>   Expected kind `*', but `(->) a' has kind `? -> *'
18:39:54 <dons> bah
18:39:59 <Taral> @kind (->) a
18:40:00 <lambdabot> Not in scope: type variable `a'
18:40:02 <Taral> hm.
18:40:03 <SamB> Frederick: yes, I just noticed that
18:40:15 <Taral> there's your kind: ? -> *
18:40:18 <dons> `(->) a' has kind `? -> *'.
18:40:26 <ski_> @kind (->) String
18:40:27 <lambdabot> ? -> *
18:40:34 <Taral> @kind Monad
18:40:35 <lambdabot> Class `Monad' used as a type
18:40:48 <Taral> ???
18:40:58 <Taral> Hm.
18:41:13 <dave_m> Whoa, what's the "?" kind?
18:41:19 <Frederick> SamB, but the line I gave you,wasnt it supposed to do that?
18:41:22 <Taral> ? is either * or #
18:41:26 <Taral> iirc
18:41:51 <SamB> Frederick: line?
18:41:51 <Taral> @kind Int#
18:41:52 <lambdabot> Not in scope: type constructor or class `Int#'
18:41:58 <dave_m> ah, that refers to GHC's unboxed types?
18:41:59 <Taral> @kind RealWorld#
18:42:00 <lambdabot> Not in scope: type constructor or class `RealWorld#'
18:42:02 <Taral> hrm
18:42:05 <Taral> yes
18:42:09 <dave_m> they'd probably be in GHC.*
18:42:15 <Taral> @hoogle RealWorld#
18:42:16 <lambdabot> hoogle: Unexpected character when parsing: >
18:42:16 <lambdabot>  
18:42:20 <Taral> !!!
18:42:20 <SamB> @kind GHC.IOBase.RealWorld#
18:42:21 <lambdabot>   Not in scope: type constructor or class `GHC.IOBase.RealWorld#'
18:42:35 <Taral> bah
18:42:37 <dons> @kind 1#
18:42:37 <lambdabot> parse error on input `1#'
18:42:51 <dons> @kind GHC.Base.1#
18:42:51 <lambdabot> parse error on input `.'
18:42:58 <Cale> Prelude Control.Monad.Reader Control.Monad> :t join (.)
18:42:58 <Cale> join (.) :: (c -> c) -> c -> c
18:43:06 <dave_m> does lambdabot's parser do GHC-specific extensions?
18:43:07 <Taral> hm
18:43:07 <Frederick> SamB, useless cfg = Map.keys (Map.filter null (productions cfg))
18:43:10 <SamB> @kind GHC.Prims.RealWorld#
18:43:11 <lambdabot> Couldn't find qualified module.
18:43:11 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
18:43:11 <lambdabot> \\)?
18:43:22 <dons> @kind GHHC.Base.RealWorld#
18:43:22 <lambdabot> Couldn't find qualified module.
18:43:22 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
18:43:22 <lambdabot> \\)?
18:43:25 <Taral> @kind GHC.Prim.RealWorld#
18:43:27 <lambdabot> Not in scope: type constructor or class `GHC.Prim.RealWorld#'
18:43:27 <SamB> Frederick: I wasn't missing that
18:43:32 <dons> @kind GHC.Base.RealWorld#
18:43:32 <lambdabot> Not in scope: type constructor or class `GHC.Base.RealWorld#'
18:43:33 <SamB> thats what I had before
18:43:36 <Taral> won't do it.
18:43:51 <dons> @kind GHC.Base.RealWorld
18:43:51 <lambdabot> *
18:43:59 <Taral> That's the boxed version.
18:44:05 <soysauce> hmm, this is weird
18:44:21 <SamB> *CFG> :i GHC.Base.RealWorld
18:44:21 <SamB> data RealWorld  -- <wired into compiler>
18:44:39 <dons> umm....
18:44:41 <dons> @kind GHC.Prim.Int#
18:44:41 <lambdabot> #
18:44:50 <soysauce> I was trying to benchmark Int8, Int16, and Int32 against each other, but it looks like GHC is only doing the computation once?
18:44:52 <SamB> @kind (->)
18:44:53 <lambdabot> ?? -> ? -> *
18:45:07 <SamB> what is ??
18:45:36 <dave_m> I used to think kinds were fairly simple...
18:45:39 <dons> paprika$ grep '??' fptools/ghc/compiler/types/Kind.lhs
18:45:39 <dons>               ??   (#)
18:45:41 <dons>         ??   [ArgTypeKind]      is the lub of *,#
18:45:43 <SamB> dave_m: they are
18:45:58 <SamB> until you start extending your type system to support unboxed types
18:46:01 <dons> @kind forall (a::??). a -> Bool
18:46:01 <lambdabot> parse error on input `::??'
18:46:10 <dons> @kind forall (a:??). a -> Bool
18:46:10 <lambdabot> parse error on input `:??'
18:46:20 <dons> @kind forall (a:: *). a -> Bool
18:46:21 <lambdabot> *
18:46:25 <dons> oh well.
18:46:46 <soysauce> wtf
18:46:49 <dave_m> why are unboxed types in their own kind, anyway?
18:46:54 <SamB> what other kinds are there?
18:47:08 <SamB> dave_m: so you can't pass them to []
18:47:13 <SamB> among other things
18:47:48 <Cale> Kinds should have proper names rather than * and # and such
18:47:54 <dave_m> are * and # disjoint?
18:47:58 <SamB> yes
18:48:08 <SamB> * are ordinary, # unboxed
18:48:12 <soysauce> http://www.rafb.net/paste/results/BkqjvQ88.html <-- can anyone explain this? I don't understand why test3 and test4 don't show up in the profiled output
18:48:43 <SamB> oh, so ?? doesn't allow unboxed tuples, I get it
18:49:16 <SamB> @type error
18:49:17 <lambdabot> forall a. [Char] -> a
18:49:23 <Taral> ?    [OpenTypeKind]	means any type at all
18:49:25 <dave_m> The need for ? and ?? kinds bothers me, but I guess it doesn't matter since it's invisible to the user
18:49:27 <SamB> @kind forall a. [Char] -> a
18:49:28 <lambdabot> *
18:49:43 <Taral> hm, interesting
18:49:59 <Frederick> SamB, so that line actually does nothing?
18:50:00 <Taral> okay, I cannot find instance Monad ((->) a)
18:50:11 <dave_m> Taral: See Control.Monad.Reader
18:50:20 <soysauce> :| does anyone know anything about the GHC profiler?
18:50:35 <SamB> Frederick: no!
18:50:38 <SamB> but I already had that
18:50:39 <dons> soysauce, sure.
18:50:40 <Taral> aha!
18:50:44 <Taral> thanks dave
18:50:47 <soysauce> dons - can you look at my paste?
18:50:50 <dave_m> I think the Monad and Functor instances for ((->) a) should be in the Prelude, myself
18:50:54 <soysauce> neither of those functions show up in the profiled output
18:51:06 <dons> you using -prof -auto-all ?
18:51:08 <soysauce> and I am baffled.
18:51:14 <soysauce> I am using -prof but not -auto-all
18:51:20 <soysauce> I inserted cost centers by hand
18:51:32 <Frederick> SamB, so how can we remove Y:=[] can we simple filter the null productions? I.E the ones with [] at right?
18:51:33 <dons> try adding -auto-all first
18:51:34 <soysauce> if I didn't use -prof then I would get no profiler output
18:51:43 <dons> yes.
18:51:47 <soysauce> s/show up/take 0% time/
18:51:54 <soysauce> sorry.
18:52:06 <soysauce> they appear in the list, but they show up as taking 0% time
18:52:19 <dons> you have to use -prof
18:52:24 <soysauce> I did use -prof
18:52:42 <dons> anyway, try -prof -auto-all, with the cost centres you inserted, then get back to me.
18:52:49 * soysauce sighs
18:52:50 <soysauce> ok
18:52:53 <Taral> Nifty!
18:52:58 <Taral> So ((->) r) is a reader monad.
18:53:12 <shapr> Yes, I program my stick with extra abstractions.
18:53:21 * shapr has written too much Python code today.
18:53:35 <soysauce> dons - still 0% time
18:53:41 <SamB> shapr: your *stick*
18:53:49 <SamB> is that for poking people with?
18:53:56 <soysauce> however, now I get even more confusing output.
18:53:56 <shapr> SamB: As in, a piece of wood I got out of the snow.
18:54:00 <sethk> hey, this is a clean channel
18:54:09 * shapr leaves snow all over the channel.
18:54:09 <Taral> soysauce: Is that BkqjvQ88?
18:54:10 <soysauce> apparently I am allocating objects in one of my two functions but not the other
18:54:14 <SamB> sethk: what does that have to do with anything
18:54:20 <soysauce> Taral - huh?
18:54:25 * shapr drips snow onto sethk 
18:54:28 <dave_m> shapr: you need a Haskell-to-Python compiler
18:54:28 <Taral> your paste.
18:54:28 <sethk> SamB, I didn't say it was a relevant channel, did I?
18:54:37 <Frederick> SamB, so how can we remove Y:=[] can we simple filter the null productions? I.E the ones with [] at right?
18:54:39 <soysauce> Taral - 	where test' :: Int -> Int -> Int
18:54:39 <soysauce> 	      test' x y = if x == 0 then y else let x' = x-1; y' = x+y in x' `seq` y' `seq` test' x' y'
18:54:40 <soysauce> er
18:54:41 <soysauce> sorry.
18:54:45 <shapr> dave_m: That is an excellent idea.
18:54:50 <SamB> sethk: I mean, who was doing something that gave you the idea you needed to say that?
18:54:50 <soysauce> yes, http://www.rafb.net/paste/results/BkqjvQ88.html is my paste
18:54:53 <Taral> soysauce: Try marking test3/test4 noinline?
18:55:07 <soysauce> ah, will try that...
18:55:13 * shapr wants to upgrade to Stick 2.0
18:55:15 <sethk> SamB, his stick?
18:55:20 <soysauce> {-# NOINLINE <func> #-} right?
18:55:23 <Taral> I think so.
18:55:25 <Taral> Just in case.
18:55:31 <Taral> I didn't think it affected cost centres, but it might.
18:55:40 <SamB> sethk: oh. so why are you making dirty jokes?
18:55:45 <soysauce> I don't think GHC will get around the map in either case... but it's worth trying
18:55:50 <sethk> SamB, you call that a joke?
18:55:58 <SamB> whatever.
18:56:01 <palomer> how many lines of code is GHC?
18:56:01 <Taral> soysauce: I think sum . map gets optimized by the fold/build rules
18:56:04 <SamB> if it was in the snow, it is CLEAN
18:56:13 <sethk> SamB, maybe it was yellow snow
18:56:14 * shapr snickers
18:56:15 <SamB> maybe even CONCURRENT CLEAN
18:56:26 <Taral> ugh
18:56:40 <soysauce> Taral - ah, interesting...
18:57:22 <Taral> You may end up with code that looks like n' = test3 n + test4 n
18:57:28 <soysauce> strange, well, it decided to put all the time in CAF now
18:57:32 <Taral> LOL
18:57:34 <soysauce> *nods*
18:57:51 <soysauce> seriously, I don't see how it's doing 40 million iterations in 0 time?
18:58:16 <sethk> soysauce, you measurement granularity is perhaps a tad broad
18:58:18 <Taral> use -v3 and look?
18:58:19 <soysauce> Int8 and Int16 should never be faster than Int by virtue of the hardware itself
18:58:26 <shapr> I'm tempted to hack on Frag... 
18:58:31 <soysauce> what's -v3?
18:58:32 <sethk> All, I just put a program on the IRC paste page of the wiki
18:58:42 <sethk> I had something that ordinarily I would have written in ruby or python
18:58:48 <sethk> from a shell script that was getting too big
18:58:49 <Taral> -v3 will give you lots and lots and lots of output from ghc
18:58:58 <sethk> I decided to do it in haskell and let everyone tell me what I did wrong
18:59:00 <soysauce> ah, "overly verbose"
18:59:12 <Frederick> SamB, ?
18:59:14 <Taral> most importantly, you can see the intermediate representations :)
18:59:16 <sethk> I only found one place to use a list and pattern matching.  There must be more opportunities
18:59:22 <soysauce> *nods*
18:59:37 <soysauce> looking at core seems more instrumental; but I've forgotten the flag
18:59:46 <Korollary> sethk: why not just "let nargs = length arguments" in main ?
18:59:59 <SamB> Korollary: its -ddump-core
19:00:07 <SamB> only thats my own private extension
19:00:15 <SamB> :-(
19:00:15 <Korollary> SamB: pardon ?
19:00:18 <soysauce> lol
19:00:19 <sethk> Korollary, that's true.  I usually forget that I can use let within a do
19:00:22 <soysauce> Korollary - he meant to address me :p
19:00:26 <Korollary> oh ok
19:00:30 <SamB> oops
19:00:36 <soysauce> hehe
19:00:38 <SamB> huh
19:01:34 <Korollary> sethk: the paste seems to be missing some newline chars
19:01:47 <sethk> Korollary, that's odd, it looks fine in the browser
19:01:51 <sethk> Korollary, are you in windows?
19:02:00 <Korollary> sethk: yes, firefox, winxp
19:02:04 <sethk> do I need to add CR-LF to a paste?
19:02:51 <sethk> I thought HTML was agnostic about that.  I guess not, though.
19:02:54 <Korollary> sethk: it's beyond me what a webform inserts
19:03:21 <palomer> anyone have a copy of the haskell cvs repo on their computer?
19:03:25 <sethk> Korollary, odd that I pasted it in firefox in unix and you can't see it properly in firefox in windows
19:03:47 <lisppaste2> SamB annotated #13842 with "new, fixed removeUseless" at http://paste.lisp.org/display/13842#3
19:04:06 <Cale> sethk: whenever you use  "blah <- return foo", you'd be better off with "let blah = foo"
19:04:28 <sethk> Cale, yes, I think korollary pointed one of those out also.  I forget to use those within a do.
19:04:37 <palomer> if anyone has the haskell sources on their computer, could they do ls -R | wc -l ?
19:04:38 <sethk> I'll fix that
19:04:40 <Cale> > [".","..","file1","file2","file3"] \\ [".",".."]
19:04:42 <lambdabot> ["file1","file2","file3"]
19:04:53 <dons> palomer, really??
19:04:58 <dons> this might take a while
19:05:06 <palomer> it's that many lines of code?
19:05:08 <sethk> Cale, that's a set minus?
19:05:16 <Frederick> SamB, what do I need to import to have mdelete?
19:05:18 <Taral> palomer: I think you want find -type f | wc -l
19:05:18 <SamB> naesten@hydrogen:~/hacking/haskell/fptools% ls -R | wc -l  
19:05:19 <SamB> 27645
19:05:21 <Cale> sethk: yeah, basically
19:05:21 <dons> palomer, umm... several 100k
19:05:26 <Taral> ls -R produces a lot of excess lines.
19:05:29 <Cale> list minus :)
19:05:30 <SamB> Frederick: oh
19:05:35 <palomer> GHC is several 100k lines of code?
19:05:37 <palomer> that's nuts!
19:05:38 <dons> find -type f -name '*.hs' -o -name '*.lhs'
19:05:43 <SamB> Frederick: just rename to Map.delete
19:05:45 <dons> how big do you think it is?
19:05:50 <Taral> palomer: Not when you realize what it has to do.
19:06:02 <palomer> isn't that bigger than the whole gcc compiler family?
19:06:24 <Taral> doubtful.
19:06:27 <Korollary> palomer: I dont think so
19:06:29 <dons> no
19:06:31 <dons> gcc is around 1M
19:06:46 <palomer> oh, but then again it's around 10 languages
19:06:47 <dons> but since 1 line of haskell == 5-10 lines of C, then they're about the same complexity
19:07:02 <palomer> what more does it have to do than any other compiler?
19:07:07 <palomer> (except type check)
19:07:10 <dons> type check
19:07:31 <SamB> naesten@hydrogen:~/hacking/haskell/fptools% find -type f -name '*.hs' -o -name '*.lhs' | wc -l
19:07:31 <SamB> 1292
19:07:53 <Frederick> SamB, 'Y':=[] became NT 'Y':=[[]]} instead of dissapearing
19:08:03 <Frederick> *disappearing
19:08:06 <SamB> Frederick: wait, it was the former?
19:08:10 <Korollary> sethk: in checkFile, you don't have to compare sum1 and sum2 twice. You can put the return's right after the putStrLn's.
19:08:25 <SamB> Frederick: what happens when you do "useless cfg"?
19:08:33 <Frederick> SamB, the former was 'Y':=[]
19:08:48 <Frederick> SamB, it returns a []
19:08:53 <SamB> Frederick: hmm
19:08:53 <sethk> Korollary, yes, that's true.  I had actually printed the entire thing twice, and I sort of fixed it.  :)
19:09:15 <sethk> Korollary, I'll need a do after then, and after else, right?
19:09:48 <SamB> Frederick: and cfg has NT 'Y':=[]?
19:10:01 <SamB> I have no idea whats up with that
19:10:08 <Frederick> SamB, nope
19:10:13 <Korollary> sethk: you can have another do, or you can have ".. then putStrLn "stuff" >> return True". 
19:10:18 <SamB> what does cfg have?
19:10:26 <Frederick> Y:=[] is a uselles symbol it adds no info
19:10:37 <SamB> Frederick: oh.
19:10:38 <sethk> Korollary, right
19:10:42 <SamB> you need to do it like this:
19:12:01 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars ab","start S","S -> aXa | bXb | $","X -> a | b | Y","Y -> $"])
19:12:01 <SamB> *CFG> removeUseless (removeEmpties cfg)
19:12:01 <SamB> CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'X',NT 'Y'], root = NT 'S', productions = {NT 'S':=[[T 'a',NT 'X',T 'a'],[T 'a',T 'a'],[T 'b',NT 'X',T 'b'],[T 'b',T 'b'],[]],NT 'X':=[[T 'a'],[T 'b'],[]]}}
19:12:27 <sethk> Cale, can you give me the syntax for doing that (with \\) all in one line?  the compiler doesn't like it the way I'm doing it.
19:13:02 <Taral> okay, my brain hurts from the boxy types paper.
19:13:05 <Korollary> @type (\\)
19:13:06 <lambdabot> Not in scope: `\\'
19:13:08 <Taral> Show me some code.
19:13:12 <Taral> @type (List.\\)
19:13:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:13:40 <Korollary> > List.(\\) "sethk" "k"
19:13:41 <lambdabot>  Not in scope: data constructor `List'
19:13:44 <Korollary> asdf
19:13:52 <Taral> It's (List.\\), not List.(\\)
19:13:53 <SamB> Frederick: got that?
19:14:01 <Korollary> damn syntax
19:14:06 <Korollary> > (List.\\) "sethk" "k"
19:14:07 <lambdabot> "seth"
19:14:18 <Taral> does > support imports?
19:14:19 <Frederick> SamB, yep I will need to give it again a goood read to cook it up
19:14:20 <SamB> Korollary: but how would we write our programs without it?
19:14:32 <Taral> > "sethk" \\ "k"
19:14:33 <lambdabot> "seth"
19:14:36 <Taral> Heh.
19:14:36 <Cale> myGetDirectoryContents dirname = fmap (\\ [".", ".."]) (getDirectoryContents dirname)
19:14:41 <Korollary> Taral: some modules are already imported for @eval
19:14:49 <Taral> ah
19:15:02 <Taral> do we have @run? :)
19:15:16 <Cale> @eval sum [1..10]
19:15:16 <Taral> I suppose I have ghci if I need to do anything complex.
19:15:17 <lambdabot> 55
19:15:19 <Korollary> no i/o
19:15:36 <SamB> @help eval
19:15:37 <lambdabot>  @eval <expr>
19:15:37 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
19:15:52 <Taral> heh
19:15:53 <SamB> (thats the same as the "> " syntax)
19:15:54 <Taral> 3 seconds :)
19:16:12 <dons> the university of new south wales gladly provides you 3 seconds of cpu
19:16:15 <Taral> Do we have ST?
19:16:19 <SamB> Taral: well, you'll get more out of those three seconds on dons's computer than on mine
19:16:21 <dons> as if.
19:16:34 <SamB> or wherever dons runs that
19:16:37 <Cale> dons' computer is always compiling ghc :)
19:16:38 <sethk> Cale, Korollary, Taral  my problem was I was trying to do it on the same line as the function, which returns IO String, not String.  So I have to do it on another line, or change the function and then use return
19:16:47 <SamB> Cale: even so!
19:16:50 <dons> Cale, not any more! lambdaobt has its own box
19:16:53 <dons> @versoin
19:16:53 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
19:16:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
19:16:57 <Cale> sethk: did you see my version?
19:17:02 <Cale> myGetDirectoryContents dirname = fmap (\\ [".", ".."]) (getDirectoryContents dirname)
19:17:05 <Taral> um.
19:17:09 <SamB> dons: oh
19:17:11 <Taral> it understands the typoed @version? :)
19:17:11 <sethk> Cale, no, I missed that one, let me try it.
19:17:14 <SamB> Taral: yes
19:17:25 <SamB> but it used to think that it should quit when I said
19:17:25 <Korollary> sethk: you can use liftM
19:17:27 <SamB> @quat
19:17:27 <lambdabot> Not enough privileges
19:17:34 <dons> the worlds first dedicated lambdabot server
19:17:36 <SamB> now thats fixed, though ;-)
19:17:44 <dons> yes. :P
19:17:50 <SamB> obviously
19:17:52 <Korollary> dons: Imagine a beowulf cluster of them !
19:18:01 <SamB> Korollary: that would just flood
19:18:05 <SamB> I mean, think of it
19:18:18 <Korollary> not all in channel necessarily 
19:18:20 <sethk> Cale, that's definitely compact.  :)  I don't think of using fmap in those situations, at least not yet.
19:18:42 <sethk> Cale, the line count is going down nicely.
19:18:44 <SamB> Korollary: and its not like they communicate amongst themselves or anything
19:19:49 <Taral> > Control.Monad.ST.runST (do { r <- Data.STRef.newSTRef 4; readSTRef r})
19:19:50 <lambdabot>  Not in scope: `readSTRef'
19:19:55 <Taral> > Control.Monad.ST.runST (do { r <- Data.STRef.newSTRef 4; Data.STRef.readSTRef r})
19:19:56 <palomer> @fmap
19:19:56 <lambdabot>  Not in scope: `Data.STRef.readSTRef'
19:19:56 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:20:02 <palomer> > map
19:20:03 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
19:20:04 <Taral> hey!
19:20:12 <palomer> why don't functions evaluate to themselves?
19:20:16 <Taral> Data.STRef.readSTRef no worky?
19:20:20 <Korollary> user locations ?
19:20:22 <SamB> palomer: they do
19:20:23 <Taral> @hoogle readSTRef
19:20:23 <lambdabot> Data.STRef.Lazy.readSTRef :: STRef s a -> ST s a
19:20:23 <lambdabot> Data.STRef.readSTRef :: STRef s a -> ST s a
19:20:29 <palomer> > fmap
19:20:30 <lambdabot>  add an instance declaration for (Show ((a -> b) -> f a -> f b))
19:20:30 <Cale> sethk: why not combine the two ifs in checkFile?
19:20:30 <SamB> its just that they can't be printed
19:20:32 <Taral> > Control.Monad.ST.runST (do { r <- Data.STRef.newSTRef 4; Data.STRef.Lazy.readSTRef r})
19:20:33 <lambdabot>  Not in scope: `Data.STRef.Lazy.readSTRef'
19:20:37 <Taral> nope, no readSTRef.
19:20:39 <Taral> Borked!
19:20:40 <SamB> because they don't implement Show
19:20:48 <palomer> SamB: ahh, I see
19:21:01 <palomer> wouldn't it be cool if they did?
19:21:26 <palomer> that would be _awesome_
19:21:28 <Cale> palomer: it would pretty much kill efficiency :)
19:21:42 <sethk> ProcessHandle doesn't implement show either
19:21:45 <palomer> no way, it would be optimized out if unused
19:22:01 <Korollary> sethk: heh. highly unlikely.
19:22:24 <palomer> and I would get to see the code associated with a function
19:22:26 <sethk> Korollary, it could at least print out the process name
19:22:26 <palomer> sweet!
19:23:01 <Cale> if sum1 == sum2 then putStrLn "OK" >> return False else putStrLn "FAILURE" >> return True
19:23:09 <Cale> (or the equivalent with do)
19:24:09 <Taral> let b = sum1 == sum2 in putStrLn (if b then "OK" else "FAILURE") >> return b
19:24:09 <sethk> Cale, ok
19:24:17 <Korollary> haha
19:24:22 <Taral> oops, (not b)
19:24:23 <sethk> Taral, ok
19:24:28 <Korollary> sethk hears everything 3 times :)
19:24:33 <sethk> :)
19:24:43 <Cale> palomer: what would  foldr (.) id [(*n) | n <- [1..10]]  print?
19:25:06 <Taral> @pl let b = sum1 == sum2 in putStrLn (if b then "OK" else "FAILURE") >> return b
19:25:07 <lambdabot> putStrLn (if' (sum1 == sum2) "OK" "FAILURE") >> return (sum1 == sum2)
19:25:15 <Taral> hmph
19:25:19 <Korollary> wow
19:25:22 <Taral> it inlined my let expression!
19:25:29 <Korollary> I'd never have written that.
19:26:09 <Taral> written what?
19:26:16 <Korollary> that poinless expression
19:26:23 <Taral> yes, it was quite pointless.
19:26:36 <Cale> it uses if' which isn't even defined anywhere in the libraries :)
19:26:43 <palomer> Cale: oh, good point
19:26:59 <palomer> Cale: well, it would show "unshowable"
19:27:03 <Taral> Ew.
19:27:16 <palomer> Cale: but functions which we've written would show themselves
19:27:21 <dons> @pl 1 + 2
19:27:21 <lambdabot> 3
19:27:27 <sethk> Taral, actually, that barfs with "last statement must be an expression"
19:27:38 <Taral> it what?
19:27:45 <Taral> @type not
19:27:45 <lambdabot> Bool -> Bool
19:27:47 <sethk> Taral, the then part, I think
19:27:50 <Taral> @type (==)
19:27:51 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:28:01 <Taral> @type let b = sum1 == sum2 in putStrLn (if b then "OK" else "FAILURE") >> return (not b)
19:28:02 <lambdabot> Not in scope: `sum1'
19:28:02 <lambdabot>  
19:28:02 <lambdabot> <interactive>:1:16: Not in scope: `sum2'
19:28:02 <Cale> sethk: that's usually a layout issue
19:28:08 <Taral> @type \sum1 sum2 -> let b = sum1 == sum2 in putStrLn (if b then "OK" else "FAILURE") >> return (not b)
19:28:09 <lambdabot> forall a. (Eq a) => a -> a -> IO Bool
19:28:12 <sethk> sethk, ok, let me much around with it then
19:28:15 <Taral> looks ok to me
19:28:24 <Korollary> haha
19:28:29 <Taral> Heh, lambdabot has a bug with multiple errors :)
19:28:38 <sethk> Cale, my layout looks ok, I think
19:28:48 <Cale> hmm
19:29:14 <Taral> I don't have a then part.
19:29:24 <SamB> Taral: watch this
19:29:29 <sethk> Cale, maybe not  :)
19:29:43 <sethk> Cale, it works all on one line  :)
19:29:55 <Taral> I'm not seeing anything... :)
19:29:56 <Korollary> sethk: tabs vs spaces maybe ?
19:29:57 <SamB> @type (id . id . id . id . id . id . id . id . id . id . id . id . id . id . id)
19:29:58 <lambdabot> forall a. a -> a
19:30:02 <SamB> hmm.
19:30:05 <sethk> Korollary, no, I got rid of tabs years ago
19:30:08 <Taral> SamB: Wow!
19:30:26 <SamB> @type  (id . id . id . id . id . id . id . id . id . id . id . id . id . id . id) . (id . id . id . id . id . id . id . id . id . id . id . id . id . id . id)
19:30:27 <lambdabot> forall a. a -> a
19:30:29 <Korollary> sethk: divide and conquer using {}'s I suppose
19:30:31 <sethk> funny, I just moved "in" under "let" and it fails.  I thought that would be ok
19:30:41 <SamB> hmm. maybe that was not what I wanted...
19:30:51 <sethk> "in" has to be indented
19:30:57 <Cale> @type foldr (.) id (replicate 20 id)
19:30:58 <lambdabot> forall a. a -> a
19:31:19 <Taral> @type foldr1 (.) id (replicate n id)
19:31:20 <SamB> > let x = "(.) " ++ x
19:31:20 <lambdabot> Not in scope: `n'
19:31:21 <lambdabot>  parse error on input `}'
19:31:24 <Taral> ha!
19:31:27 <SamB> > let x = "(.) " ++ x in x
19:31:27 <sethk> I'll have to go through the rules and see what happens to the "in" in that position
19:31:28 <lambdabot> "(.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (
19:31:28 <lambdabot> .) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
19:31:28 <lambdabot> (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.
19:31:28 <lambdabot> ) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
19:31:28 <lambdabot> (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.
19:31:30 <lambdabot> [23 @more lines]
19:31:33 <palomer> @type (\x-> x x) (\x-> x x) (\x -> x x) (\x -> x x)
19:31:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:31:34 <lambdabot>   Expected type: t
19:31:46 <SamB> @type (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
19:31:47 <lambdabot> forall a a1 a2 b c a3.
19:31:47 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> a2 -> (a3 -> b) -> a3 -> c
19:32:02 <palomer> @type (\x-> x x) (\x-> x x)
19:32:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:32:03 <lambdabot>   Expected type: t
19:32:07 <SamB> > let x = "map . " ++ x
19:32:07 <lambdabot>  parse error on input `}'
19:32:08 <Taral> no, \x -> x x does not work.
19:32:10 <SamB> > let x = "map . " ++ x in x
19:32:11 <lambdabot> "map . map . map . map . map . map . map . map . map . map . map . map .
19:32:11 <lambdabot> map . map . map . map . map . map . map . map . map . map . map . map .
19:32:11 <lambdabot> map . map . map . map . map . map . map . map . map . map . map . map .
19:32:11 <lambdabot> map . map . map . map . map . map . map . map . map . map . map . map .
19:32:11 <lambdabot> map . map . map . map . map . map . map . map . map . map . map . map .
19:32:13 <lambdabot> [24 @more lines]
19:32:18 <palomer> @type \x -> x x
19:32:19 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:32:19 <lambdabot>   Expected type: t
19:32:25 <SamB> @type map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map . map
19:32:26 <lambdabot> forall a b.
19:32:26 <lambdabot> (a -> b)
19:32:26 <lambdabot> -> [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
19:32:26 <lambdabot> ]]]]
19:32:27 <lambdabot> -> [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[b]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
19:32:29 <lambdabot> ]]]]
19:32:29 <palomer> why not?
19:32:37 <Taral> it's untypeable.
19:32:40 <SamB> hmm...
19:32:47 <SamB> > let x = "map " ++ x in x
19:32:49 <lambdabot> "map map map map map map map map map map map map map map map map map map
19:32:49 <lambdabot> map map map map map map map map map map map map map map map map map map
19:32:49 <lambdabot> map map map map map map map map map map map map map map map map map map
19:32:49 <lambdabot> map map map map map map map map map map map map map map map map map map
19:32:49 <lambdabot> map map map map map map map map map map map map map map map map map map
19:32:51 <lambdabot> [24 @more lines]
19:32:55 <SamB> @type map map map map map map map map map map map map map map map map map map
19:32:55 <palomer> it's typeable in system F
19:32:56 <lambdabot>   The function `map' is applied to 17 arguments,
19:32:56 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
19:33:01 <Taral> palomer: What's the type?
19:33:10 <SamB> > let x = "fmap " ++ x in x
19:33:11 <lambdabot> "fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:11 <lambdabot> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:11 <lambdabot> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:11 <lambdabot> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:11 <lambdabot> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:13 <lambdabot> [25 @more lines]
19:33:21 <SamB> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:33:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) a1.
19:33:22 <lambdabot> (Functor ((->) ((((((a -> b) -> f a -> f b)
19:33:22 <lambdabot>        -> (f1 a1 -> f1 (a -> b))
19:33:22 <lambdabot>        -> f1 a1
19:33:23 <lambdabot>        -> f1 (f a -> f b))
19:33:25 <lambdabot> [141 @more lines]
19:33:32 <SamB> hmm.
19:33:35 <Taral> that's a scary type
19:33:42 <palomer> Taral: I forget, but it's been proved that the terms typeable in system F are exactly those which are proveably complete
19:33:44 <SamB> yeah! 141 more lines!
19:33:57 <Taral> Oh, C-H?
19:34:03 <palomer> curry howard?
19:34:04 <sethk> is there a system F implementation that you guys are playing with?
19:34:14 <palomer> noone actually uses system F
19:34:14 <SamB> dons: do you have a time limit on @type, btw?
19:34:34 <SamB> sometimes it takes an inordinately long time for the compiler to typecheck things, you know?
19:34:42 <palomer> because, well, typeability is not decidable in system F
19:34:50 <palomer> SamB: that's because of resolution
19:34:53 <sethk> palomer, that's what I thought I had read
19:35:06 <SamB> palomer: did you see joelr's explosion?
19:35:11 <dons> SamB, nope.
19:35:16 <palomer> SamB: for system F? nope
19:35:18 <dons> let's see the hack...!
19:35:20 <SamB> dons: you?
19:35:50 <SamB> does lambdabot have any HList stuff installed?
19:35:58 <dons> nope.
19:35:58 <dons> ;)
19:36:12 <SamB> then I dunno if you are vulnerable ;-)
19:36:17 <dons> and no funny -fundecidable-foo-barsd
19:36:18 <SamB> well, lambdabot
19:36:19 <Taral> palomer: I don't think \x -> x x is complete.
19:36:34 <SamB> dons: does HList need that?
19:36:43 <palomer> Taral: how so?
19:36:45 <dons> I thought so, maybe I'm imagining.
19:37:03 <Taral> wait...
19:37:18 <Taral> nope, can't find a type for it anywhere.
19:37:21 <SamB> @type let y f = x where x = f x in y
19:37:22 <lambdabot> forall t. (t -> t) -> t
19:37:28 <SamB> is that what you want?
19:37:39 <SamB> @pl y f = x where x = f x
19:37:40 <lambdabot> (line 1, column 17):
19:37:40 <lambdabot> unexpected "="
19:37:40 <lambdabot> expecting variable, "(", operator or end of input
19:38:22 <SamB> @pl \f -> let x = f x in x
19:38:22 <lambdabot> fix
19:38:27 <SamB> @type fix
19:38:28 <lambdabot> Not in scope: `fix'
19:38:30 <SamB> hm
19:38:31 <palomer> Taral: I'll get back to you on that one
19:38:44 <palomer> I _could_ check my notes, but my fever is running too high
19:38:44 <fworp> @type Control.Monad.Fix.fix
19:38:45 <lambdabot> forall a. (a -> a) -> a
19:38:46 <SamB> thats practically cheating!
19:38:48 <SamB> oh
19:38:53 <SamB> hmm.
19:39:02 * SamB wonders what that has to do with monads
19:39:09 <fworp> no idea
19:39:14 <Taral> it uses monadic combinators sometimes.
19:39:17 <Taral> fix, ap, join, >>=
19:39:45 <SamB> fix has no monadic bits, though!
19:39:47 <SamB> its all pure
19:39:53 <Taral> *shrug*
19:40:02 <SamB> see, ma, no m!
19:40:11 <Taral> You end up with an infinite type problem:
19:40:19 <palomer> are there any functions in the haskell standard library which don't satisfy referential transparency?
19:40:19 <SamB> who does?
19:40:24 * SamB doesn't
19:40:29 <SamB> palomer: standard?
19:40:30 <SamB> hmm.
19:40:35 <SamB> hGetContents?
19:40:41 <Taral> give \x -> x x the type a -> b
19:40:59 <palomer> Taral: quantify your predicates
19:40:59 <Taral> then a must be of type c -> d, and b = d
19:41:03 <Taral> hm?
19:41:14 <palomer> forall a. forall b. a->b?
19:41:20 <Taral> No.
19:41:27 <Taral> This is type inference, not type checking.
19:41:37 <Taral> These type variables are unqualified.
19:41:42 <palomer> err, ok
19:41:48 <Taral> if you insist:
19:41:50 <palomer> I usually start by a theorem as my hypothesis 
19:41:53 <palomer> and work from there
19:41:54 <Taral> give \x -> x x the type exists a b. a -> b
19:41:55 <SamB> no wonder they don't get the job done!
19:42:14 <Taral> See, under C-H, \x -> x x is a proof without a proposition.
19:42:14 <SamB> I want only *qualified* type vars to work in my programs, for the highest quality results!
19:42:47 <palomer> without a proposition? a type?
19:42:52 <Taral> yup
19:42:53 <palomer> (I claimed it does have a type)
19:43:09 <Taral> Only an infinite type would fit.
19:43:14 <palomer> then again, by my logic the Y combinator is typeable
19:43:24 <palomer> ok, you're making me go look into my notes
19:43:25 <sethk> well, my program is 1/3 smaller than when I started, which isn't too bad.  Let's see what else I can find in the same vein.
19:43:25 <TheHunter> @type \(x::forall a. a -> a) -> x x
19:43:26 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
19:43:35 <SamB> palomer: a type is a proposition and an arrow is an implication, don'tcha know?
19:43:40 <Taral> hm!
19:43:45 <Taral> a type!
19:43:56 <Taral> ...
19:43:58 <Taral> weird type.
19:44:05 <TheHunter> @type flip flip
19:44:06 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
19:44:11 <SamB> palomer: you need to use the not-quite y combinator
19:44:19 <palomer> SamB: you silly goose, my notes would say "\x . x x is typeable"
19:44:29 <TheHunter> @type \(x :: forall a b c. (a -> b -> c) -> (b -> a -> c)) -> x x
19:44:31 <lambdabot> forall a c b.
19:44:31 <lambdabot> (forall a1 b1 c1. (a1 -> b1 -> c1) -> b1 -> a1 -> c1)
19:44:31 <lambdabot> -> b
19:44:31 <lambdabot> -> (a -> b -> c)
19:44:31 <lambdabot> -> a
19:44:32 <lambdabot> -> c
19:45:00 <SamB> thebug: does that y combinator do anything useful?
19:45:06 <SamB> er, TheHunter 
19:45:06 <palomer> SamB: tons!
19:45:16 <palomer> it let's you solve lambda equations
19:45:16 <SamB> palomer: but with that forall on it?
19:45:24 <SamB> anyway, whats wrong with fix?
19:45:59 <TheHunter> you can express any recursive function in terms of y.
19:46:05 <palomer> Taral: ah hah! so I was right
19:46:15 <SamB> TheHunter: but does that y do the job?
19:46:15 * palomer does a dance
19:46:25 <palomer> then again, more things are typeable in haskell than system F
19:46:30 <TheHunter> which y?
19:46:36 <palomer> err, I mean more types are inhabited
19:46:45 <palomer> actually, I'm not sure about that one
19:46:51 <palomer> more types are provably inhabited
19:47:14 <SamB> > let y = (\(x::forall a. a -> a) -> x x) (const "foo")
19:47:15 <lambdabot>  parse error on input `}'
19:47:24 <SamB> > let y = (\(x::forall a. a -> a) -> x x) in y(const "foo")
19:47:25 <lambdabot>   Illegal signature in pattern: forall a . (a -> a)
19:47:25 <lambdabot>    Use -fglasgow-exts to permit it
19:47:28 <TheHunter> that's no y, just self-application.
19:47:45 <SamB> oh. right.
19:47:59 <TheHunter> and I would be surprised if it could be used in real-world programs.
19:48:19 <SamB> @type let y f = f f in y
19:48:20 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:48:20 <lambdabot>   Expected type: t
19:48:44 <Taral> O.o
19:48:44 <SamB> @type let y f = f (y f) in y
19:48:45 <lambdabot> forall t. (t -> t) -> t
19:48:52 <Taral> So why does Haskell complain about infinite type?
19:49:01 <Taral> oh, it's trying to make a monomorphic x.
19:49:06 <SamB> Taral: because they are confusing?
19:49:07 <Taral> hahahahahahahaha
19:49:17 <SamB> because you can't give infinite type signatures?
19:49:20 <SamB> who knows!
19:49:22 <sethk> ok, well now we know a bunch of things Y isn't, but I have no memory of what it was
19:49:22 <Taral> :)
19:49:29 <Taral> Y f = f f
19:49:37 <SamB> Taral: okay.
19:49:46 <Taral> no
19:49:50 <SamB> so what is wrong with Y' f = f (Y' f) ?
19:49:51 <Taral> Y f = f (Y f)
19:49:57 <SamB> oh.
19:49:58 <TheHunter> y f = g g where g h = f (h h)
19:49:59 <Taral> not the same as \f -> f f
19:50:18 <SamB> Taral: well, I've seen it both ways already
19:50:23 <Taral> @type let y f = f (y f) in y
19:50:25 <lambdabot> forall t. (t -> t) -> t
19:50:30 <Taral> nothing wrong with it, samb
19:50:32 <dons> luckily we can't add data types to @eval, otherwise you could use the russel encoding to make @type diverge
19:50:44 <Taral> russel encoding?
19:50:47 <SamB> dons: we don't need it to diverge.
19:50:49 <Taral> @google "russel encoding"
19:50:50 <dons>       data U = MkU (U -> Bool)
19:50:51 <lambdabot> http://www.amazon.com/exec/obidos/tg/detail/-/B0001MYLLG?v=glance
19:50:53 <dons>       russel :: U -> Bool
19:50:53 <dons>       russel u@(MkU p) = not $ p u
19:50:55 <Taral> not useful.
19:50:59 <dons>       x :: Bool
19:50:59 <dons>       x = russel (MkU russel)
19:51:01 <dons>       x :: Bool
19:51:01 <dons>       x = russel (MkU russel)
19:51:02 <Korollary> very useful !
19:51:09 <Taral> Korollary: I meant the google result.
19:51:19 <SamB> we could just add a microcosm of HList and show a huge one
19:51:26 <SamB> that would take forever anyway
19:51:30 <Korollary> Taral: It was an inside joke
19:51:35 <Taral> ok
19:51:47 <dons> SamB, ah maybe. but not as much fun as diverging
19:51:49 <TheHunter> dons, I don't think that would make @type diverge.
19:52:04 <SamB> dons: doesn't running out of memory count as diverging?
19:52:09 <dons> oh, it's the inliiiner
19:52:22 <SamB> which is?
19:52:27 <Taral> what makes @type diverge?
19:52:30 <SamB> the inliner runs on interactive expressions?
19:52:31 <dons> maybe ghci doesn't use the simplifier when doing :t
19:52:48 <dons> one way to find out.
19:52:49 <Taral> everything there has a type
19:52:52 <SamB> didn't we try running :t on joelr's explosion?
19:53:01 <TheHunter> i think a checked it a long time ago, I'm not sure anymore.
19:53:28 <dons> hmm.... if it's in a source file it takes a while ..
19:53:41 <dons> now, what if I type it in.
19:53:45 <Taral> google can't find anything useful for "russel encoding"
19:53:53 <Korollary> I think it's misspelled
19:54:22 <TheHunter> @type \a -> let b = a . a; c = b . b; d = c . c; e = d . d; f = e . e; g = f . f in g
19:54:22 <lambdabot> forall a. (a -> a) -> a -> a
19:54:37 <TheHunter> damn
19:55:03 <Taral> TheHunter: We already tried that with (.), it inlines the heck out of it.
19:55:30 <dons> yep, ghci doesn't care if you type it in. since no inliner is run. so :t is safe
19:55:41 <dons> if it's in the source code though ,bad things happen.
19:55:46 <Taral> dons: What type diverges?
19:55:56 <Taral> Everything there had explicit type annotation.
19:56:05 <dons> the inliner diiverges
19:56:15 <Taral> on what?
19:56:56 <dons> i don't know, try it in your head.
19:57:08 <Taral> O.o
19:57:18 <Taral> oh.
19:57:24 <Taral> I was still stuck on types.
19:57:34 <Taral> The type inference doesn't diverge.
19:57:36 <Taral> The computation does.
19:57:41 <Taral> well, can.
19:58:12 <dons> sure, and the inliner can get stuck inlining it
19:58:17 <Taral> not $ not $ not $ ... $ not $ x
19:58:19 <TheHunter> *Main> :t let russel :: U -> Bool; russel u@(MkU p) = not $ p u; x :: Bool; x = russel (MkU russel) in x
19:58:19 <TheHunter> let russel :: U -> Bool; russel u@(MkU p) = not $ p u; x :: Bool; x = russel (MkU russel) in x :: Bool
19:59:04 <Taral> xah :)
20:00:06 <xah> Taral: aye
20:03:55 <Taral> I wonder if it's possible to detect that divergence and compile it out? :)
20:03:58 <Taral> Probably not worth it.
20:04:25 <TheHunter> @type let a = Control.Monad.Fix.fix b = a . a; c = b . b; d = c . c; e = d . d; f = e . e; g = f . f in g
20:04:26 <lambdabot> parse error on input `='
20:04:31 <TheHunter> @type let a = Control.Monad.Fix.fix; b = a . a; c = b . b; d = c . c; e = d . d; f = e . e; g = f . f in g
20:05:02 <lambdabot> Module "type" produced error: thread killed
20:05:10 <Korollary> heh
20:05:21 <Taral> ha ha ha ha
20:05:25 <sploo22> nice
20:05:31 <Taral> did you make the type inference diverge?
20:05:32 <TheHunter> no there we go. I wonder if that left a zombie process on don's machine.
20:05:42 <TheHunter> @type let a = Control.Monad.Fix.fix; b = a . a in b
20:05:48 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
20:05:49 <TheHunter> @type let a = Control.Monad.Fix.fix; b = a . a; c = b . b in c
20:05:50 <Korollary> no type for you !
20:06:00 <SamB> TheHunter: didn't you hear?
20:06:07 <dons> oh!
20:06:07 <lambdabot> forall a.
20:06:07 <lambdabot> ((((a -> a) -> a -> a) -> (a -> a) -> a -> a)
20:06:07 <lambdabot> -> ((a -> a) -> a -> a)
20:06:07 <lambdabot> -> (a -> a)
20:06:08 <SamB> TheHunter: lambdabot has its own box now
20:06:09 <lambdabot> -> a
20:06:11 <lambdabot> -> a)
20:06:13 <lambdabot> -> a
20:06:14 <SamB> @version
20:06:15 <lambdabot> lambdabot 3p188, GHC 6.5.20050806 (Linux i686)
20:06:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
20:06:20 <TheHunter> it just becomes exponentially larger.
20:06:34 <Taral> ha ha ha
20:06:44 <Taral> ghc 6.5? :)
20:07:20 <dons> very nice TheHunter :)
20:07:24 <dons> @karma+ TheHunter
20:07:24 <lambdabot> TheHunter's karma raised to 5.
20:07:32 <Taral> what does karma do?
20:07:34 <Taral> @help karma
20:07:35 <lambdabot> return a person's karma value
20:07:37 <dons> yeah, it really takes quite a long time on my ghci
20:07:37 <Taral> @karma
20:07:38 <lambdabot> You have a karma of 0
20:07:49 <TheHunter> what's that about?  * Provide default @seen state, if file is missing, suggested by sjw
20:08:00 <Taral> @karma+ Taral
20:08:01 <SamB> @seen nobody
20:08:05 <Taral> No?
20:08:09 <Taral> Did I break it?
20:08:10 <lambdabot> You can't change your own karma, silly.
20:08:10 <lambdabot> I haven't seen nobody.
20:08:13 <Taral> Oh, okay.
20:08:16 <Taral> @karma dons
20:08:17 <lambdabot> dons has a karma of 16
20:08:19 <dons>  @seen uses a binary file, on new installations @seen was barfing if that file was missing
20:08:29 <SamB> ah
20:08:30 <dons> so instead a default Map is provided if the state isn't there.
20:08:34 <Taral> Do you lose karma when you raise someone else's?
20:08:43 <dons> no.
20:08:44 <SamB> dons: how was that originally handled?
20:08:49 <SamB> Taral: heh
20:08:56 <SamB> why would you lose karma?
20:09:01 <Taral> I dunno.
20:09:02 <TheHunter> the general state code should be able to do that by default, I'll investigate.
20:09:04 <dons> oringally I just tried to read the State file, and had checked a default state into darcs
20:09:04 <SamB> then karma would be a zero-sum game!
20:09:08 <Taral> So two people can play karma-gaining games.
20:09:20 <SamB> Taral: yes!
20:09:23 <dons> TheHunter, @seen usess a binary serialiser that isn't part of the normal state framework (yet)
20:09:32 <SamB> however, anyone else can just karma- them down again
20:09:35 <SamB> I assume
20:09:42 <SamB> @help karma-
20:09:42 <lambdabot> decrement someone's karma
20:09:47 <Taral> okay, so karma is just fun.
20:09:49 <SamB> yes, it is possible to decrement karma
20:09:55 <SamB> Taral: well, not really
20:10:23 <Korollary> @karma+ lambdabot
20:10:23 <lambdabot> lambdabot's karma raised to 7.
20:10:25 <Korollary> heh
20:10:27 <SamB> you do it when someone does something cool, like give you a RULE to make your code look cleaner but still be as efficient ;-)
20:10:40 <Taral> Okie.
20:10:55 <SamB> thats what I did for my last point ;-)
20:10:58 <Taral> @karma *
20:10:59 <lambdabot> * has a karma of 0
20:11:02 <Korollary> we need @cookie+ as well
20:11:06 <Taral> @karma haskell
20:11:06 <lambdabot> haskell has a karma of 0
20:11:10 <SamB> @karma Haskell
20:11:11 <lambdabot> Haskell has a karma of 2
20:11:12 <TheHunter> ah, I get it.
20:11:16 <Taral> case-sensitive?!
20:11:20 <SamB> Taral: yeah
20:11:21 <Taral> @karma Curry
20:11:21 <lambdabot> Curry has a karma of 0
20:11:26 <Taral> @karma System F
20:11:27 <lambdabot> System has a karma of 0
20:11:29 <Taral> ha.
20:11:34 <Taral> @karma          Haskell        
20:11:34 <lambdabot> Haskell has a karma of 2
20:11:35 <SamB> @karma ocaml
20:11:36 <lambdabot> ocaml has a karma of 0
20:11:39 <Taral> @karma Ocaml
20:11:40 <lambdabot> Ocaml has a karma of 0
20:11:43 <Taral> @karma- ocaml
20:11:44 <lambdabot> ocaml's karma lowered to -1.
20:11:46 <Taral> LOL
20:11:48 <Taral> @karma+ ocaml
20:11:48 <lambdabot> ocaml's karma raised to 0.
20:11:50 <SamB> hehe
20:12:01 <SamB> shoulda left it at -1
20:12:01 <Taral> @karma Java
20:12:02 <lambdabot> Java has a karma of 0
20:12:04 <Taral> @karma- Java
20:12:04 <Korollary> @karma- perl
20:12:05 <lambdabot> perl's karma lowered to -1.
20:12:05 <lambdabot> Java's karma lowered to -1.
20:12:10 <SamB> @karma- Java
20:12:10 <lambdabot> Java's karma lowered to -2.
20:12:24 <Korollary> love is in the air
20:12:29 <Taral> @karma+ Haskell
20:12:30 <lambdabot> Haskell's karma raised to 3.
20:12:48 <SamB> oh, how do you profile stuff?
20:12:54 <Taral> ghc -prof -auto-all
20:12:59 <Taral> ./a.out +RTS -p
20:13:09 <Taral> hp2ps
20:13:21 <SamB> Taral: I'm sunk if it isn't built for profiling already
20:14:01 <Taral> then just run it with +RTS -p and hope?
20:15:12 <SamB> ah good, I've got stage2 built for profiling
20:15:23 <Taral> what are you profiling?
20:15:28 <SamB> GHC
20:15:30 <Taral> O.o
20:15:34 <Taral> have fun
20:16:27 <SamB> I want to see whats taking so long with something that joelr discovered ;-)
20:18:24 <Taral> okay, I'm going to go play games now
20:18:25 <Taral> byebye
20:18:45 <Korollary> Frag !
20:18:50 <Taral> Not frag.
20:19:06 <sethk> I think you raised Eddie Haskell's karma by mistake
20:19:11 <Lemmih> Is Frag a multi player game?
20:19:28 <Korollary> Lemmih: It should be if it isn't.
20:32:36 <SamB> boy, hmp3 works surprisingly well with GHC a-thrashin'
20:32:47 <dons> :)
20:34:27 <dons> added a nice little patch just now, the playlist and current song are saved automatically and restored on startup and shutdown. so it restarts on the last track you were listening to
20:34:42 <dons> and no more need to explicitly write the db
20:35:14 <dons> how will that interact with  how you use it, SamB?
20:36:00 <Korollary> how do you pause in hmp3 ?
20:36:39 <dons> 'p'
20:36:53 <Korollary> I mean, how do you tell mpg321 to pause ?
20:37:24 <Korollary> does it have an interactive mode ?
20:37:30 <dons> yep.
20:37:33 <Korollary> ah
20:37:40 <dons> it has a nice little control protocol
20:37:50 <Korollary> ah, it must be like mplayer
20:38:09 <Korollary> next step: lircd !
20:42:55 * fworp has actually been toying with the idea of a lircd for a while...
20:44:29 <Korollary> in haskell ?
20:44:33 <fworp> yeah
20:45:42 <Korollary> wouldn't most of it be in C ?
20:46:17 <fworp> not really
20:46:26 <fworp> maybe some of it
20:47:11 <Korollary> I've never written a device driver. Maybe it's possible just by using Foreign.
20:47:49 <fworp> a device driver? i thought you meant 'lambda irc daemon', ha
20:47:57 <Korollary> hah
20:48:36 <Korollary> lircd is the linux IR control daemon
20:49:09 <fworp> oh, well, i dunno anything about that, all i saw was 'ircd'
21:02:54 <Korollary> jhc is the 6th hit in google search results.
21:19:07 <Korollary> what the monad is The Gale Chat System ?
21:27:33 * fworp sure wishes he could do something like: newtype Number = forall a. Num a => Number a deriving Num
21:29:05 <dons> data Number = forall a. (Num a) => Number a
21:29:06 <dons> ?
21:31:00 <TheHunter> how do you wanna add two Numbers?
21:31:26 <fworp> oh, hmm, yeah, thats a problem
21:31:33 <fworp> but that was just an example
21:33:08 <dons> kinda hard to get at the thing on the other side of the => ;)
21:33:11 <TheHunter> well this kind of deriving seems to be restricted to type classes that only use a contravariantly.
21:33:53 <TheHunter> and similarly we need covariance only for universal quantification.
21:35:08 <TheHunter> ignore me, talking bs.
21:35:23 <fworp> well, replace Num with anything that makes sense there, but the deriving clause was just kindof tacked on, something like newtype Foo = forall a. Foo a would still work
21:36:26 <fworp> data would work, but might possibly make operations on the a a little slower due to having to deconstruct the number (or foo, or whatever)
21:36:46 <TheHunter> ah, we need at most one occurence of a at a position with the right variance.
21:37:47 <TheHunter> seems to be such a rare phenomenon that it doesn't justify any special treatment.
21:40:25 <TheHunter> maybe it isn't even decidable whether newtype-erasure is sound, in any event we don't have existential newtypes anyway.
21:42:18 <TheHunter> object-oriented people must have thought about that sort of thing already.
21:46:29 <fworp> what is newtype erasure?
21:46:32 <Lokadin> existential newtypes might commit suicide
21:47:14 <Lokadin> if they get too depressed about the meaningless of their own existance
21:47:23 <Lokadin> and they will refuse to do anything believeing that actions are futile
21:47:24 <Lokadin> lol
21:47:33 <skew> evidence translation gets in the way of making existential newtypes
21:47:56 <TheHunter> right, that isn't even possible, I should go to bed.
21:48:13 <skew> I wonder what it would take to handle them in an impredictive system. I think Daan said at the end of his MLF paper that that was one of the things he was working on
21:48:48 <TheHunter> fworp, newtypes are implemented with no runtime-overhead. I invented the term newtype-erasure btw.
21:49:01 <skew> what would be undecidable about erasing them?
21:49:09 <skew> when you are using them to hide recursion?
21:49:17 <fworp> ah, and yeah i know, that was why i wanted to use them
21:50:04 <skew> If I recal TaPL properly, as long as you don't try to do subtyping, then dealing with equirecursive types is just a lot trickier than dealing with isorecursive types
21:50:08 <TheHunter> we were talking about newtype-deriving where certain type-variables are quantified.
21:50:33 <skew> I want to try just leaving the occurs check out of a type checker, and seeing what I get
21:50:51 <TheHunter> the question is: when can we just use the newtype-deriving technique of using the same dictionaries.
21:51:16 <skew> when you are doing what?
21:51:20 <skew> making new types?
21:51:36 <skew> playing around with unsafeCoerce# in ghci should give you a pretty good idea
21:51:48 <fworp> the deriving part was not really important in my initial example, it was just the 'ideal' case. i dont mind just filling in the definitions
21:52:11 <TheHunter> bogus: data Foo = Foo (forall a. Num a => a) deriving Num
21:52:56 <TheHunter> actually I don't really care whether it's decidable, my point was that it is complicated.
21:54:06 <skew> really?
21:54:31 <skew> It seems a deriving clause like that is only sensible for data types with single constructors of a single argument
21:55:09 <skew> and it seems like you should be able to take the type of that argument, toss in a constraint for the class you want, and run the normal constraint reduction algorithm
21:55:51 <skew> which will either come up with a fixed dictionary for that type, which you can wrap, a dictionary translator in terms of other constraints on the algorithm, which you can similarly wrap, or failure
21:56:24 <TheHunter> probably.
21:58:17 <skew> it looks like you can make newtype Foo = Foo (forall a  . (Num a) => a)
21:58:53 <Lokadin> is there any way to define how many bytes to use for a certain value? i mean i don't need more than a byte, and using more than that  would be a waste of ram
21:59:01 <skew> hehehe
21:59:10 <skew> do you have lots of these values?
21:59:17 <Lokadin> yep 512*512
21:59:23 <skew> oh, you can make an array of them then
21:59:41 <Lokadin> yep, that's what i'm saying, but i just need to know if i can make them only take up a byte
21:59:50 <mauke> 256k isn't "lots", really
22:00:04 <Lokadin> :|
22:00:12 <skew> I think they just take 1 byte in the right kind of array
22:00:41 <Lokadin> , well this is for my rts game, so i have to be able to add values to it later,,
22:01:01 <skew> Certainly in a Ptr Word8, but that's a last resort
22:01:36 <TheHunter> i guess people usually use unboxed arrays for that sort of thing.
22:01:43 <Lokadin> so as in right now it has a type with one byte, but i mean i need a few different kinds, some to determine the type(grass, water/sand), and some for elevation, and then for anything else
22:01:47 <skew> try an STUArray Word8
22:02:02 <Lokadin> i'll look it up
22:02:04 <Lokadin> thanks :)
22:02:55 <skew> if you are going to move to things other than the most primitive types, you might end up using a raw Ptr
22:04:01 <Lokadin> well for the map i don't need anything but bytes, bytes of integers
22:04:58 <dons> we have sized Words and Ints for this. Data.Word for example
22:05:08 <dons> however, there wa a nice paper at ICFP on sized types for Haskell
22:05:24 <dons> where you would say something like: data X ==  Y | Z, and also define how to pack it into bits
22:05:50 <Lokadin> hmmm
22:06:07 <dons> this isn't available anywhere. you most likely just want Word8 or some such
22:06:20 <Lokadin> kk, thanks, :)
22:07:01 <Lokadin> yep seems like it
22:07:07 <Lokadin> :D thanks
22:07:22 <Lokadin> i'll er get back to learning haskell :|
22:07:28 <fworp> skew: yeah, that works, but it doesnt let you construct Foo's with anything but _|_
22:07:37 <fworp> as a
22:07:46 <skew> try Foo a
22:07:51 <skew> Foo 1, I mean
22:08:12 <skew> :t 1 => forall a . 
22:08:17 <skew> (Num a) => a
22:08:23 <fworp> i did
22:08:28 <fworp> err
22:08:30 <fworp> no i didnt
22:08:47 <skew> hmm, works for me - newtype Foo = Foo (forall a . (Num a) => a)?
22:08:55 <dons> SamB, hmm. I can prevent the 12hrs + slow space leak on hmp3 by specifying -G1 with -RTS
22:09:01 <dons> very interesting
22:09:23 <fworp> i tried Foo (1::Int)
22:09:25 <fworp> :P
22:09:32 <dons> then the heap space stays constant (well, for at least 20 hours now)
22:09:36 <skew> foralls like that are translated into an extra parameter
22:09:49 <skew> you could do Foo (fromIntegral (1 :: Int))
22:14:07 <fworp> skew an extra parameter? to the type constructor?
22:15:34 <skew> nah, the compiler invents for each class a record holding functions for all the records
22:17:22 <skew> then everything that has a class constraint gets an extra argument added, and things are arragned so at every call a record of the functions for the actual type are passed along
22:17:54 <skew> like if you have double :: (Num a) => a -> a and you call double (1 :: Int) and double (1 :: Double)
22:18:29 <fworp> is that even valid?
22:18:34 <fworp> oh
22:18:35 <fworp> pfft
22:18:36 <fworp> nm
22:18:43 <skew> at runtime it's something like double :: NumMethods a -> a -> a, double methods x = methods.plus x x, double numMethodsInt (1 ::Int), double numMethodsDouble (1 :: Double)
22:18:45 <fworp> yeah, got ya
22:19:28 <skew> so Foo (forall a . (Num a) => a) is something like Foo (NumMethods a -> a), not that much different from Foo (Int -> Bool) or whatever
22:19:49 <skew> forall a . (Num a) => Foo a is more like Foo (NumMethods a, a)
22:20:08 <skew> for some existentially bound a
22:25:20 <Lokadin> bah, no haskell programs work for me :'(
22:25:26 <Lokadin> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/Introduction%20to%20Haskell/sld043.htm
22:25:34 <Lokadin> that doesn't compile complains about a parse error
22:25:45 <Lokadin> on line 3
22:26:19 <Lokadin> hmmm well now on line 8
22:26:30 <skew> 8?
22:27:10 <Lokadin> er the one that isn't there
22:27:16 <Lokadin> as in the one after everything
22:27:17 <Lokadin> :|
22:27:29 <skew> what's the error?
22:27:39 <Lokadin> email.hs:9: parse error (possibly incorrect indentation)
22:27:56 <skew> are you sure you have the indentation right?
22:28:42 <skew> you could try the explicit grouping syntax if you are not sure
22:28:48 <Lokadin> :|... indentation? that's the error it always give me
22:28:51 <skew> also, missing parens might do that
22:28:59 <Lokadin> you mean the { } ?
22:29:21 <skew> that's the explicit grouping - do { stmt ; stmt ; stmt ... stmt }
22:29:49 <Lokadin> o
22:29:50 <Lokadin> kk
22:30:03 <mauke> I'd put the "do" on a line by its own
22:30:25 <Lokadin> kk
22:30:42 <Lokadin> now just changed to line 10
22:30:51 <Lokadin> is there somewher ei can past ehte program?
22:31:13 <Korollary> @paste
22:31:13 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:31:25 <Korollary> or lisppaste
22:31:57 <Lokadin> er how do i use it?
22:32:01 <Korollary> http://paste.lisp.org/
22:33:00 <lisppaste2> Lokadin pasted "email.hs" at http://paste.lisp.org/display/13904
22:33:49 <mauke> the last ; looks wrong
22:34:02 <Lokadin> same problem
22:34:02 <mauke> what's the "asdf" doing there?
22:34:07 <Lokadin> the asdf is the name
22:34:08 <Lokadin> in the file
22:34:34 <mauke> what?
22:34:48 <Lokadin> the recipients file
22:35:30 <mauke> I have no idea what you're talking about but it looks like you're trying to call a string, which doesn't make sense
22:35:48 <Lokadin> recipient is a file...
22:36:10 <mauke> and?
22:36:10 <Lokadin> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/Introduction%20to%20Haskell/sld043.htm
22:36:14 <Lokadin> it exists
22:36:24 <Lokadin> and that is what i'm basing my stuff off of
22:36:25 <mauke> that slide doesn't contain "asdf"
22:36:30 <Lokadin> no
22:36:33 <Lokadin> it contains nothing
22:36:37 <Cale> what?
22:36:46 <Lokadin> ?
22:36:55 <Cale> the slide has some code on it
22:36:56 <Lokadin> the slide doesn't have a name, you're supposed to put one there
22:37:03 <mauke> no, you're not
22:37:11 <mauke> 'name' is the function parameter
22:37:20 <Lokadin> o
22:37:32 <Lokadin> email.hs:3: parse error (possibly incorrect indentation)
22:37:44 <Lokadin> thats my problem, that why i put a name there
22:37:47 <Cale> yeah, space things in to make it match the indentation on the slide
22:38:35 <Cale> that is, "do" should be more tabbed in than "email", and "system", "recipient", etc should line up.
22:39:25 <lisppaste2> mauke annotated #13904 with "my version" at http://paste.lisp.org/display/13904#1
22:39:39 <Cale> that's not the only way to indent it, but the slide's indentation is correct
22:40:17 <Cale> mauke's version is also a decent way to indent the thing
22:40:23 <skew> Lokadin: read this section of the Report several times: http://www.haskell.org/onlinereport/syntax-iso.html#layout
22:40:33 <mauke> my version is easier to get right IMHO
22:41:02 <skew> you will be thoroughly confused the first several times through, and then you will never have layout problems again
22:41:17 <Lokadin> lol kk
22:41:34 <Lokadin> well now it's complaining about system, but i fix that by importing System
22:41:47 <dons> case sensitive
22:41:58 <dons> (for many, many good reasons)
22:42:04 <Lokadin> well no i mean it's fixed
22:42:07 <Lokadin> no more system errors
22:42:15 <skew> nah, slide was missing the import statement
22:42:16 <dons> ah, sorry. I see what you mean.
22:42:19 <Cale> @index system
22:42:20 <lambdabot> System.Cmd
22:42:22 <Lokadin> but now it complains about other things, like     Couldn't match `Int' against `ExitCode'
22:42:30 <dons> return ()
22:42:47 <dons> though actually, maybe something else it wrong.
22:42:50 <mauke> ah, yes
22:42:58 <Lokadin> k i fixed that to, now it complains that no main is defined
22:43:09 <Cale> email :: String -> IO Int is wrong
22:43:11 <mauke> apparently the slide's "system" returns an IO Int
22:43:24 <Lokadin> yeah i changed it to IO ExitCode
22:43:25 <Cale> email :: String -> IO ExitCode
22:43:28 <Cale> yeah
22:43:47 <Lokadin>     The main function `main' is not defined in module `Main'
22:43:58 <skew> is the class using Helium? and an ancient compiler?
22:43:59 <Korollary> because it's not, eh
22:44:23 <Lokadin> well but that i dont' know what to do about :(
22:44:37 <Cale> main = return ()
22:44:37 <Cale> that'll do
22:44:43 <Korollary> Lokadin: Did you check out the tutorials yet ?
22:44:47 <Lokadin> o okay :D thanks 
22:44:48 <mauke> it'll do nothing, successfully :-)
22:44:55 <Cale> :)
22:45:11 <dons> better than failing to do nothing at all ;)
22:45:12 <Cale> I like 'false', which does nothing, unsuccessfully
22:45:25 <dons> hehe
22:45:38 <Korollary> 'Nothing' works for me.
22:45:38 <Lokadin> er it does nothing though :|
22:45:38 <skew> main = main
22:45:43 <Lokadin> oh okay
22:46:09 <Cale> load your program in an interactive environment like ghci if you want to play with it
22:46:15 <Korollary> let main () = print_string "Hello World\n" ;;
22:46:40 <Cale> main = putStrLn "Hello World"
22:47:09 <Korollary> (begin (display "Hello World") (newline))
22:47:59 <mauke> (progn (princ "Hello World") (terpri)) ; I wonder if that actually works
22:48:32 <Cale> mauke: yep
22:48:34 <skew> cmucl likes it
22:49:03 <Lokadin> er none of those work :|
22:49:45 <Lokadin> how do i load email.hs into the interpreter?
22:49:48 <skew> oh, most of those were not Haskell. main = putStrLn "Hello World" will show if the program is working
22:49:58 <skew> ghci email.hs should do it
22:50:50 <Lokadin> <interactive>:1: parse error on input `='
22:51:03 <Lokadin> for the main = putStrLn "Hello World"
22:51:18 <Cale> if you typed that at the ghci prompt, yeah
22:51:25 <Lokadin> oh
22:51:32 <Lokadin> i'm supposed to put that in email.hs?
22:51:35 <Cale> ghci wants expressions
22:51:38 <Cale> to evaluate
22:51:48 <mauke> Lokadin: only if you want a 'main'
22:51:48 <Cale> declarations should go in your file
22:51:58 <skew> if you put that in your file, then ghc would not complain about you not defining main, and would make a program that prints "Hello World"
22:52:29 <Cale> of course, if you want it to send an email, you'll need to call email from main
22:52:38 <Lokadin> well how about the rest of the program,? i mean the email part
22:52:38 <Lokadin> o
22:53:07 <Cale> but you might also just load email.hs in ghci, and type something like: email "John"
22:53:21 <Lokadin> o
22:53:58 <Cale> which will apply the email function to the string "John", which will then produce an IO action which sends John an email.
22:54:03 <Cale> Which will be run :)
22:54:59 <Lokadin> *** Exception: Prelude.last: empty list
22:55:02 <Lokadin> :(
22:55:33 <Cale> perhaps the grep didn't find anything?
22:55:50 <Cale> that program isn't exactly robust :)
22:56:22 <Lokadin> yep
22:56:23 <Cale> do you have an addresses file?
22:56:29 <Lokadin> i believe so
22:56:54 <Lokadin> oo it keeps clearing it i think
22:57:14 <Cale> hm?
22:58:06 <Lokadin> i add addresses, then run the program, it doesn't finnd anything, i check the file and there is nothing there
22:58:21 <Lokadin> o
22:58:22 <Lokadin> i c
22:58:24 <Cale> um, hmm
22:58:57 <Cale> well, recipient will be overwritten
22:59:08 <Cale> but addresses shouldn't get touched
22:59:18 <Lokadin> o
22:59:26 <Lokadin> sorry was sticking it in the wrong file 
22:59:55 <Lokadin> kk
22:59:57 <Lokadin> now it works
23:00:03 <Cale> :)
23:00:06 <Lokadin> :D
23:00:57 <Lokadin> yay, a program with more thena  print and averaging function and it works!! :D
23:01:09 <Lokadin> say how would i call it from main?
23:01:42 <Lokadin> i mean can i just run the binary instead of having to go into the interpreter
23:01:50 <Cale> main = email "John"
23:01:53 <Cale> or
23:01:58 <Cale> main = do
23:02:08 <Cale>    putStr "Who to email? "
23:02:13 <Cale>    name <- getLine
23:02:19 <Cale>    email name
23:02:24 <Lokadin> cool thanks :D
23:02:54 <Cale> np :)
23:04:03 <dons> putStr "Who to email? " >> hFlush stdout
23:04:05 <Lokadin> yay! :D
23:04:29 <Lokadin> dons: whats that for?
23:05:21 <Lokadin> @index hFlush
23:05:22 <lambdabot> System.IO
23:05:31 <dons> so the prompt is printed before readingt he next line.
23:05:57 <Lokadin> it is anyways though
23:06:09 <dons> ah, interesting.
23:06:38 <Lokadin> i mean i can understand it would be good for clarity
23:06:51 <dons> I'm surprised it worked without flushing the buffer
23:06:58 <dons> since it doesn't work on my machine
23:07:09 <Cale> hmm
23:07:37 <dons> it was essential here: main = do putStr "$ " >> hFlush stdout
23:07:37 <dons>           x <- getLine
23:07:39 <dons>           return ()
23:08:11 <Cale> works on my machine okay too
23:08:24 <dons> huh.
23:08:24 <Cale> (without flushing)
23:08:38 <Cale> which ghc?
23:08:39 <sethk> dons, is it possible that the implementation in one platform sets the handle to unbuffered mode by default?
23:08:50 <dons> sure. maybe Windows, but on Cale's box??
23:08:58 <dons> ghc 6.4.1, btw Cale.
23:09:15 <Cale> I thought they changed the buffering to something sane for commandline apps in recent versions.
23:09:35 <Lokadin> i hav 6.2.2
23:09:41 <dons> yeah, rinnngs a bell. turning off unbuffered output would be the sensible option.
23:10:21 <sethk> it also might vary from platform to platform depending on the bugs in the c compiler libraries.
23:10:31 <Cale> I remember I always used to have to turn buffering off, or at least set it to line buffering
23:11:18 <sethk> I use tooo many languages and platforms; I get the bugs and workarounds jumbled up.  :)
23:11:27 <Cale> For a while there, I think the default was block buffering
23:12:50 <sethk> on some platforms the performance of unbuffered is so dismal that it is painful to use it.
23:13:00 <Lokadin> say, so can anyone point me to a good, not out of date, example based tutorial? like maybe an excersize based one? like a course you know, where you have a problem and then you solve it, and see the answer or some such?
23:14:00 <Cale> Yet Another Haskell Tutorial is good
23:14:03 <Cale> also
23:14:20 <Cale> Two Dozen Short Lessons
23:14:23 <Cale> http://haskell.org/learning.html
23:14:54 <Cale> oh, yaht links to that annoying form :)
23:15:04 <Cale> faster to google
23:15:10 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
23:16:12 <Lokadin> :D
23:16:12 <Lokadin> thanks
23:18:29 <Lokadin> :o, the meeting quoted in the tutorial was a month before i was born
23:18:29 <Lokadin> lol
23:19:20 <dons> :)
23:21:27 <Cale> I would have been 4
23:22:07 <Lokadin> time flies
23:22:17 <Cale> Lokadin: btw, you can basically skip to chapter 3 :)
23:22:29 <Lokadin> kk :) thanks
23:26:46 <Lokadin> say just out of curiosity how easy is it to port haskell to windows?
23:26:54 <Lokadin> like on a scale of 1 to 10
23:27:04 <dons> very easy. it should run without modification usually
23:27:13 <Lokadin> oh okay :D that's good
23:27:21 <Lokadin> very relieved ot hear that
23:27:31 <Lokadin> :D
23:27:37 <Cale> Of course, if you use GUI bindings, the GUI that you use has to be available on windows.
23:27:50 <Lokadin> gtk is available on windows no?
23:28:03 <Cale> Yeah, though I've heard it's a little flakey
23:28:11 <Cale> that might have changed
23:28:14 <Lokadin> :S
23:28:19 <Cale> WxHaskell seems rather portable too
23:28:43 <Cale> I haven't really used windows in any serious way in 5 years or so.
23:28:44 <Lokadin> does it have opengl support?
23:28:47 <Cale> yeah
23:28:54 <Lokadin> kk
23:28:55 <Cale> GHC comes with HOpenGL
23:29:11 <Lokadin> o :)
23:29:40 <Cale> Which, by the way has recently been put to use in an FPS game.
23:29:48 <Lokadin> really? which one?
23:30:13 <Cale> It's called Frag, you can get the source if you have darcs
23:30:48 <Cale> It's still a little rough around the edges, but it runs, and the framerate is decent enough :)
23:31:05 <Cale> darcs get http://www.cse.unsw.edu.au/~pls/repos/frag
23:31:18 <Cale> http://haskell.org/hawiki/Frag
23:32:11 <Lokadin> oh wow nice
23:32:22 <Lokadin> reminds me of cube
23:32:39 <Cale> :)
23:33:10 <Cale> and Quake 3, strangely enough *cough* stolen map *cough*
23:33:22 <Cale> :)
23:33:28 <Lokadin> lol
23:33:57 <Lokadin> i was never any good at fps's way too fast for me
23:34:11 <Lokadin> especially quake3
23:34:20 <Lokadin> though i have to admit those space levels were loads of fun
23:34:23 <Cale> :)
23:34:26 <Lokadin> :)
23:34:48 <BadWolf> hi....
23:34:51 <Cale> hi
23:35:30 <Cale> what's up?
23:35:53 <BadWolf> http://rafb.net/paste/results/yg2Txe39.html
23:36:00 <BadWolf> look at line 9
23:36:05 <BadWolf> there is an error...
23:36:08 <BadWolf> mom my message...
23:36:17 <Cale> `div`
23:36:22 <dons> nah, Cale, they give those maps away for free
23:36:26 <sethk> ghci is chopping off an argument.  Does that make sense?  It is a long filename and I'm using :set args
23:36:37 <Cale> BadWolf: you have to put div in backticks to use it as an infix operator
23:36:38 <BadWolf> ERROR ggt.gs:10 - Instance of Fractional Int required for definition of kgv
23:36:54 <BadWolf> Cale: and / doesn't work, does it?
23:37:20 <Cale> BadWolf: (/) only works for instances of Fractional
23:37:34 <Cale> (Float, Double, Rational, etc)
23:37:44 <Cale> if you want integer division, use `div`
23:37:49 <dons> @localtime Cale
23:37:50 <lambdabot> Local time for Cale is Wed Nov 23 02:37:27
23:38:34 <bosie> how do you actually iterate through a user-definied type
23:38:40 <bosie> type bosie = [Int]
23:38:43 <dons> @type fmap
23:38:46 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
23:38:48 <Cale> BadWolf: letzter is in the prelude, it's called 'last'
23:38:50 <dons> oh, @type map
23:38:50 <dons> ;)
23:39:08 <bosie> dons hm
23:39:20 <bosie> dons it throws an exception, i tried it with map
23:39:26 <Cale> bosie: type Bosie = [Int] just makes "Bosie" a synonym for "[Int]"
23:39:28 <dons> bosie, your Bosie type is just a synonym for [Int] so anything that works on [Int[ also works on a  Bosie
23:39:34 <bosie> dons it says that i should have [bosie] and not just bosie
23:39:44 <Cale> Capitalisation
23:39:56 <dons> please, it's confusing bosie!
23:39:56 <Cale> Type names have to start with an uppercase letter
23:40:05 <bosie> dons lol
23:40:17 <bosie> type Text = [String]
23:40:18 <bosie> a :: Muster -> Text -> Text
23:40:18 <bosie> a b c = map (comp b) c
23:40:28 <BadWolf> thank ya very much cale it's working now
23:40:36 <bosie> Expected type: [Text]
23:40:37 <Cale> BadWolf: great :)
23:40:41 <BadWolf> :)
23:40:59 <Cale> bosie: what's the type of comp?
23:41:13 <bosie> Muster -> String -> String
23:41:32 <Cale> okay, so comp b :: String -> String
23:41:42 <bosie> yes
23:42:55 <Cale> okay, shouldn't be any type errors there then
23:43:06 <bosie> awesome!
23:43:23 <Cale> In fact, I can get that to compile with dummy definitions for Muster and comp
23:43:24 <dons> lesson of the day, sometimes specifying +RTS -G1 (for the two-space collector) can remove heap bloatage in long running programs.
23:43:37 <dons> and it can be hard-baked using the ghc_rts_opts C hoook.
23:43:57 <bosie> dons i hope so much that wasnt the answer for me cos i didnt understand a thing :DD
23:44:27 <dons> well, "long running programs" makes sense, doesn't it? ;)
23:44:32 <Cale> dons: neat, I'll have to remember that -- how well did it do?
23:45:32 <dons> anyway, baking -G1 into hmp3 fhas killed off the slow space leak that was causing hmp3 to get up to 10M heap after 20 hours. Now it sits on exactly 3984K
23:46:12 <Cale> neat :)
23:46:36 <dons> so there's no long lived generation anymore, so no old packed strings are hanging around, I think.
23:47:20 <dons> though I don't fully understand the space leak yet.
23:49:14 <dons> I found this by accident when trying to get GC stats, the manual says to use -G1 -Sstderr to get the on the fly stats, and I noticed the next morning that my heap creep problem had vanished.
23:49:46 <Cale> heh
23:50:17 <dons> I wonder if this would help other packed string programs with those light-but-heavy ForeignPtrs
23:50:36 <Cale> Well, you're probably doing better than all my gnome programs then :) They all seem to grow and grow.
23:50:48 <dons> hehe
23:51:33 <bosie> http://bash.org/?580701 lol
23:58:08 <bosie> oki sorry i thought its funny ;)
23:59:34 <Cale> It's alright, just off topic :)
23:59:59 <bosie> we shouldnt be so critical at 8am in the morning ;)
