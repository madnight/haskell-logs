00:00:18 <mwc> Well, I repasted the contents of the entire file as I have it now
00:01:31 <mwc> Okay, so it ran for 3 minutes on that 20x40 domain
00:01:35 <mwc> and it output nothing
00:01:55 <mwc> I assume it's going to write output to stderr?
00:02:17 <mwc> I have a main function that's using writeFile
00:05:15 <Cale> aha, mesh isn't being kept around
00:05:35 <Cale> dataPoints nx nt = [sol (x,t) | x <- range (0,nx), t <- range(0,nt)]
00:05:35 <Cale>     where sol = waveSolver 1.0 ((\x -> 0.0),(\x -> 0.0)) (sinc,(\x -> 0.0)) (-20.0,20.0,nx) (0.0,20.0,nt)
00:06:04 <mwc> ok, so where is mesh dissapearing?
00:06:04 <Cale> *PDESolver> dataPoints 1 1
00:06:04 <Cale> [(-20.0,0.0,Mesh
00:06:04 <Cale> 0.0),(-20.0,20.0,Mesh
00:06:04 <Cale> 0.0),(20.0,0.0,Mesh
00:06:04 <Cale> 0.0),(20.0,20.0,Mesh
00:06:05 <Cale> 0.0)]
00:08:06 <mwc> So it's not keeping a partially evaluated sol around, but regenerating it each time?
00:08:22 <Cale> right
00:08:34 <mwc> Well, I have it "working" for now
00:08:41 <mwc> I suspect it's good enough to hand in
00:09:15 <Cale> you need two seq's to get mesh to stick around
00:09:19 <mwc> ah
00:09:22 <mwc> ok
00:09:45 <mwc> hint?
00:09:50 <Cale> *PDESolver> dataPoints 1 1
00:09:50 <Cale> [Mesh
00:09:50 <Cale> (-20.0,0.0,0.0),(-20.0,20.0,0.0),(20.0,0.0,0.0),(20.0,20.0,0.0)]
00:09:52 <Cale> let me paste :)
00:11:54 <Cale> there
00:12:48 <goltrpoat> this is off-topic, but you folks seem like a bright bunch.  don't suppose anyone here has done any chess programming?
00:13:46 <lispy> goltrpoat: i had a friend that did some.  Only chess programming i've done is knights tour and n-queens.  Those don't really count
00:14:01 <lispy> goltrpoat: do you have a specific question about it?
00:14:05 <Cale> not me, but I know that someone around here was writing a chess game viewer in Haskell
00:15:06 <goltrpoat> yeah, the specific question is that i'm having some trouble getting past 6 ply or so in a reasonable amount of time, with plain alpha-beta with nullmove pruning and a single transposition table
00:15:29 <lispy> what is pyl?
00:15:32 <lispy> er ply
00:15:43 <goltrpoat> tree depth, essentially
00:16:15 <lispy> well you've already implemented more than i know
00:16:19 <mwc> haha, wow cale, that's a 600% speedup
00:16:21 <lispy> so i'm out :)
00:16:23 <mwc> thanks a bunch for pointing that out
00:16:34 <mwc> how did you know where to put those seqs?
00:18:34 <Cale> mwc: well, we want to force the evaluation of the partially applied function before we evaluate any of that list
00:18:52 <Cale> and then we want to evaluate mesh before returning the partially applied function
00:18:56 <gour> dcoutts: ping
00:19:08 <mwc> ah, I get it now
00:20:57 <Cale> otherwise it won't be until you actually print the third element of a given tuple in the list that mesh will get evaluated
00:21:08 <Lokadin> is haskell object oriented? or at least can object orientedness be easily implementable?
00:21:09 <mwc> makes sense
00:21:16 <boegel> dcoutts: finally added your HaskLS version to my HaskLS page, your version is the current darcs version (i.e. the version I'll work from when I find the time)
00:21:18 <Cale> Lokadin: no
00:21:28 <Cale> Lokadin: but there is an implementation of OO in Haskell
00:21:33 <Cale> it's not easy
00:21:52 <Cale> (there's a library for it)
00:22:00 <Lokadin> Cale: :(, are there any object oriented functional programming languages i could look into?
00:22:07 <Cale> ocaml
00:22:15 <Cale> but why do you want OO-ness anyway?
00:22:27 <lispy> yeah, ocaml doesn't have the syntatic pleasantries of haskell, but i'd say ti's pretty nice still
00:22:28 <Lokadin> well for this rts i wanna make
00:22:44 <Lokadin> i dono tell me if i can make it non-OO wise
00:22:51 <Lokadin> what i wanted basically in terms of OO
00:23:31 <lispy> i think haskell should have more OO, but what with what is available in generic haskell you can do much of what OO is used for quite easily
00:23:32 <Lokadin> is that i'll have a basic core, and say i'll dynamically build the game properties over it, so for instance buildings and units will have different abilities that they can have
00:24:07 <goltrpoat> more interestingly, they're starting to implement some functional concepts into the next c++ standard
00:24:14 <Lokadin> so say i have units and buildings defined with basic xml files or what not, and the comp would just load the appropriate modules for their actions and abilities
00:24:18 <goltrpoat> like apparently there's a type class concept now.
00:24:21 <Cale> sure, that seems nicely expressible in terms of parametric polymorphism, which Haskell has
00:24:29 <mwc> I find that I can do most of what I'd use virtual subclasses to do more cleaning with Haskell's algebraic datatypes
00:24:40 <mwc> so that's a plus too
00:24:49 <lispy> Lokadin: you should look at hs-plugins
00:25:08 * gour wonders what will come out of c++ at the end
00:25:29 <Cale> yeah, hs-plugins would handle the loading of custom units nicely
00:25:40 <Lokadin> yea
00:25:42 <Lokadin> ?
00:25:43 <Lokadin> hmmm
00:25:57 <Lokadin> kk well i'll look into it, and it wouldn't require object orientedness?
00:26:06 <Cale> but an rts is a tough first Haskell program
00:26:14 <Cale> what other functional languages do you know?
00:26:35 <goltrpoat> or maybe, what other languages do you know
00:26:43 <Lokadin> er i can't say i know any languages at all in depth, and it's really much easier then you think, i've been working on a normal rts for a while now
00:26:44 <pejo> gour, "core dumps"?
00:26:58 <Lokadin> glob2, if you know it
00:27:06 <Cale> Lokadin: do you have a mathematical background?
00:27:19 <Lokadin> i'm a first year student so i can't say that i do
00:27:22 <gour> pejo: yes, it could be :-)
00:27:47 <Cale> okay, well, Haskell might be a bit of a trip, but perhaps the lack of familiarity with imperative languages will help :)
00:27:57 <goltrpoat> cale:  you don't get 'them' here very often do you :)
00:28:07 <Cale> goltrpoat: 'them'?
00:28:44 <Lokadin> Cale: :D lol alright, personally i find functional programming makes a lot more sense then imperative languages, especially with all the heavy ai work that is required of rts games
00:28:59 <Cale> Lokadin: yeah, it would :)
00:29:02 <goltrpoat> cale:  the 18 year old with a bit of cs 101 pascal under their belt longing for the next blockbuster mmo.
00:29:05 <Lokadin> :D
00:29:12 <joelk> Lokadin: I've been thinking of the same thing. We can discuss it on #globulation2 if you want.
00:29:22 <Lokadin> kk cya there
00:29:41 <int-e> mwc: FWIW, if you compile the PDESolver with ghc -O it memoizes mesh, too, even without the `seq` and the explicit \(x', t') lambda abstraction
00:29:42 <Cale> Lokadin: there are actually a bunch of people here (myself included) who were thinking about writing an RTS game
00:29:53 <gour> pejo: i started with zortech c++ back in '90, but now i'm happy that it went away from it (although haskell has some learning curve, but, at least it makes much more sense)
00:29:55 <Cale> shapr being a major proponent of this idea
00:30:07 <Lokadin> Cale: really? 
00:30:14 <gour> pejo: s/it went.../i went...
00:30:30 <mwc> That sounds like a really good idea
00:30:41 <Cale> Lokadin: yeah -- well, really there was an idea for a strategy combinator library
00:30:47 <mwc> what with the perception of C/C++ being the only thing to write games in
00:30:52 <goltrpoat> rts games are content-heavy.  the usual isometric grid-based type game isn't hard to code, it's hard to get people to do art for you.
00:30:53 <Lokadin> Cale: what you mean by that?
00:31:05 <Cale> but of course, we'd need a Haskell RTS as a testbed :)
00:31:25 <Cale> functions which manipulate strategies as first-class values.
00:31:41 <mwc> What if we had a game that evolved itself? That would be fairly interesting
00:31:46 <goltrpoat> mwc:  i'm in games.. i remember how long it took people to switch from C to C++ (actual C++, not C with classes), just due to the "it'll be slower" mentality
00:31:55 <mwc> yeah
00:31:59 <goltrpoat> people who are very narrowly specialized, are usually very afraid of change.
00:32:25 <mwc> goltrpoat: today's specialization is tomorrow's obsolescence?
00:32:44 <Lokadin> well the idea that i had for the rts is that there would be a core and you would build everything on top of it, generate the units and buildings through xml files that load abilities and different modules. 
00:32:45 <goltrpoat> yeah, there's definitely that as well
00:33:13 <Lokadin> if you've ever played glob2, you'll know it has a pretty grand novel idea of having an ai take care of the units for you, to an extent, 
00:33:51 <Lokadin> but if you modularize the ai as well into different functions the amount of things you could do in terms of strategy starts escalating drasticallly adn there is a lot less micromanagment
00:34:17 <Cale> Lokadin: why not just make it programmable in the same language that it's written in? For example, lambdabot loads modules, written in Haskell, which perform various tasks
00:34:31 <Lokadin> say for instance if you just plop down buildings and units will fill them with resources as is needed by priority, then there will be little need to maintain them adn you'll be able to work on other things
00:34:32 <Cale> @dynamic-load dice
00:34:32 <lambdabot> module loaded
00:34:39 <Cale> @dice 3d10
00:34:40 <lambdabot> 3d10 => 16
00:34:40 <mwc> Cale: better yet, make a DSL for the game language
00:34:48 <Cale> mwc: an edsl
00:34:50 <mwc> that's a real haskell strengths
00:34:56 <mwc> Cale: what's the E?
00:35:00 <Cale> embedded
00:35:09 <Cale> A combinator library
00:35:11 <mwc> Ah
00:35:12 <lispy> edsl's rock
00:35:24 <Cale> like parsec, for game units
00:35:32 <Cale> instead of parsers :)
00:35:50 <Lokadin> no well the problem is that the current game is just badly designed, i mean everything is stored in a bunch of huge files, that are rather hard to manage
00:35:59 <goltrpoat> what are you guys planning on doing about the content eh
00:36:07 <goltrpoat> like i said, the game itself isn't hard to code
00:36:07 <Lokadin> ? what you mean
00:36:07 <sieni> Lokadin: there's always Lua, if you need tiny functional scripting language that integrates well with C and C++
00:36:16 <joelk> reuse glob2's of course. right?
00:36:19 <Lokadin> yep
00:36:22 <Lokadin> why not, it's gpl
00:36:23 <goltrpoat> art, music, design, etc.
00:36:24 <Lokadin> we can use them
00:36:49 <Lokadin> so we can just reuse glob2's graphics 
00:36:59 <goltrpoat> oh.
00:37:04 <Lokadin> and i got plenty of friends at the university that are interested in graphic design and music and such
00:37:17 <Cale> Who needs game content when you have a combinator library? We'll just code ai's and let them fight each other abstractly and that will be the game :)
00:37:26 <Cale> heh
00:37:27 <Lokadin> always good on a resume that you have done work for someone before even if it's volunteer
00:37:41 <Lokadin> Cale: lol, well it's not as fun that way :P
00:37:48 <goltrpoat> lok:  yeah definitely.
00:38:01 <Lokadin> :D
00:38:21 <Cale> Lokadin: you obviously haven't written Haskell code then :) It's plenty of fun :)
00:38:35 <Lokadin> lol :P, well i mean the user base will be rather small
00:38:43 <goltrpoat> well..  it'd be awesome to see something like that done in haskell
00:38:47 <Cale> yeah, that's probably true :)
00:38:51 <Lokadin> though i must admit for the game i'm intending a lot of coding and a lot of what oyu said will occur
00:39:35 <Lokadin> because for instance you can have things like different ai attacking modes, so you can have a roman attack say, where they attack in lines and once the most forward warrior loses too much hp it will go down the left and run to the nearest hospital or innn
00:39:40 <Lokadin> whichever is more needed
00:39:50 <goltrpoat> i have trouble seeing it seep through into the industry though -- i suspect what'll happen instead is the "mainstream" languages will end up acquiring enough of the features to the point where it's all just borg^H^H^H^Hlisp
00:40:13 <mwc> Okay int-e: without a -O flag, I have a 3 minute runtime. With Cale's seq's, I have 15 seconds. And then with -O2, I have a 2 minute runtime
00:40:20 <mwc> ghc-6.4.1 on Mac OS X/ppc
00:41:07 <Lokadin> goltrpoat: well i dono, if we make an rts like that, i'm certiann the demand will be over the roof, i mean we can recerate absolutly any rts currently in existance
00:41:17 <Lokadin> including warcraft and starcraft style games
00:41:30 <Lokadin> because then you simply have a different ai that does next to nothing
00:42:15 <Lokadin> there would be nothing reall that the proprietary rts games could offer that we couldn't
00:42:26 <mwc> just better eye and ear candy
00:42:30 <lispy> Lokadin: it's good that your excited and optimistic, but i think you may be over estimating the effort
00:42:38 <Cale> over?
00:42:44 <Lokadin> ?
00:42:45 <lispy> er
00:42:46 <lispy> sorry
00:42:48 <lispy> under
00:42:53 <Lokadin> yea i know, :P
00:42:57 <mwc> I think the last game to succeed without a million dollars of creative content was Tetris
00:43:06 <Lokadin> lol
00:43:25 <joelk> dons, fps needs a couple imports to compile with -DUSE_ZLIB
00:43:25 <goltrpoat> ah deer hunter
00:43:26 <goltrpoat> hehe
00:43:27 <luqui> RTS is among the most difficult genres to program for
00:43:29 <goltrpoat> er.  ah=and
00:43:31 <Lokadin> with a large enough user base i'm sure graphics will be possible
00:44:00 <int-e> mwc: hmm. I took Cale's version and took out the two `seq` ... and replaced the = \(x', t') by (x', t') = ... ghc -O2 results in a huge speedup over -O0. ghc 6.4.1 on x86 (Athlon XP)
00:44:16 <Lokadin> but that would take a while, but like joelk said we can just use glob2's and their's is pretty nice as it is
00:44:49 <goltrpoat> luqui:  how do you figure?
00:44:53 <Lokadin> main thing is to make it easily themable and make it easy to give sounds to say every unit action and all that
00:45:15 <mwc> hmm, I figure that optimization would occur at a higher level so it should work on both platforms
00:45:18 <int-e> mwc: I added a main = print $ dataPoints 20 40  ...
00:46:00 <mwc> int-e: ghc --make -O2 -o waver Main.hs 
00:46:09 <mwc> well, I have my own main method
00:46:14 <mwc> but it's similar basically
00:46:26 <lispy> one of the things that might be difficult with using haskell for an RTS is that run time performance can be unpredictable
00:46:31 <mwc> just twists the data into a format I can dump to gnupllot
00:46:53 <int-e> mwc: you're calling waveSolver there, right? I guess the key is that this function is inlined at the caller site
00:47:10 <luqui> goltrpoat, okay, I should rephrase.  It is a very hard genre to *prototype*
00:47:11 <Cale> on the other hand, Haskell can let you write some really beautiful interfaces to fast C libraries :)
00:47:17 <luqui> that is, it is hard to get something up and running quickly
00:47:25 <luqui> which, for my programming style, makes it hard :-)
00:47:34 <int-e> mwc: could you try it with {-# INLINE waveSolver #-} in the PDESolver module?
00:48:04 <mwc> int-e: sure I will
00:48:37 <int-e> mwc: I guess that without inlining the mesh `seq` (\(x', t') -> ...) construction becomes essential.
00:48:46 <mwc> fair enough
00:49:10 <takuan> what do I hear?
00:49:14 <takuan> pdesolver in haskell?
00:49:16 <takuan> where?
00:49:29 <takuan> and is it fast?
00:49:29 <mwc> takuan: trivial wave equation
00:49:32 <mwc> takuan: no
00:49:35 <takuan> ah
00:49:44 <mwc> 40x20 mesh is taking 3 minutes wihtout fancy tricks
00:49:58 <takuan> mkay
00:50:04 <takuan> and is it elegant?
00:50:08 <mwc> int-e: okay, with that inline pragma, we're down to 1 minute, 20 seconds
00:50:13 <mwc> takuan: oh, fairly
00:50:20 <mwc> the code is on the wiki
00:50:36 <Cale> wait, 1 minute, 20 seconds? How are you calling it?
00:51:12 <Cale> does that mean that dataPoints 40 20 is taking that long?
00:51:17 <mwc> same way we discussed before
00:51:29 <mwc> could be that the ppc backend generates horrible code
00:52:09 <mwc> let me scp the code up to my linux box
00:52:13 <shapr> Wow, Manfred von Thun is writing monads in Joy.
00:52:40 <mwc> Isn't Joy sort of like Forth?
00:52:44 <Cale> it's almost instantaneous on my machine
00:53:01 <mwc> 40x20 mesh?
00:53:13 <Cale> yeah, only the printing takes any time
00:53:14 <lispy> Lokadin: I have some opengl in haskell examples if you're interested
00:53:24 <shapr> hiya lispy, how's life?
00:53:28 <Cale> the actual solving is done instantly
00:53:45 <lispy> shapr: hi.  Nice to see you.  Life is...well, changing
00:53:50 <Lokadin> lispy: well i dono, i haven't even really finished figuring out what information a gui needs in order to exist
00:53:50 <Cale> *PDESolver Control.Parallel.Strategies> length ((dataPoints 40 20 :: [(Double,Double,Double)]) `using` rnf)
00:53:50 <Cale> Mesh
00:53:50 <Cale> 861
00:53:50 <Cale> (0.03 secs, 2553420 bytes)
00:53:57 <mwc> wow
00:54:10 <Lokadin> lispy: i mean i'll definatly be interested
00:54:14 <Lokadin> actually can you give a link?
00:54:18 <Lokadin> i'll bookmark it
00:54:41 <Lokadin> it's 4 in the mroning here and i gotta go to bed soon as i have school in ther morning :S
00:54:48 <lispy> Lokadin: http://codersbase.com/index.php/Nehe-tuts
00:54:53 <Lokadin> thanks :D
00:54:53 <lispy> Lokadin: yeah, it's 1am here
00:55:12 <takuan> mwc: which wiki?
00:55:13 <mwc> Holy crap
00:55:16 <Cale> even printing them in my nice terminal,
00:55:19 <Cale> (0.22 secs, 23289188 bytes)
00:55:24 <Lokadin> lispy: where you at? 
00:55:26 <mwc> takuan: the haskell.org/hawiki, pastepage
00:55:37 <mwc> Cale: yeah, on my ram-starved machine upstairs, 7 seconds
00:55:48 <lispy> i need to finish converting the nehe tuts, i got stuck at the bitmap fonts examples
00:55:55 <lispy> Lokadin: Oregon
00:56:00 <Lokadin> lispy: o
00:56:05 <mwc> on this 1.25 GB RAM PPC machine, 20 seconds
00:56:07 <int-e> mwc: hmm, weird. it's really much faster if that main function is in the same module.
00:56:10 <Cale> I'll do a 70x80 mesh:
00:56:12 <boegel> shapr: have you replyed on my TMR question ? didn't catch it
00:56:14 <mwc> yeah
00:56:14 <Cale> (2.20 secs, 215892436 bytes)
00:56:19 <mwc> that's strange
00:56:22 <Lokadin> lispy: oregon always reminded me of oregano
00:56:32 <Cale> and that's printing the values, in ghci
00:56:33 <Lokadin> lol
00:56:35 <lispy> heh
00:57:02 <mwc> int-e: yeah, I bet that's the difference
00:57:11 <mwc> I'm calling it from a main function in a different module
00:57:14 <mwc> weird
00:57:24 <mwc> quick, somebody wake the Simons!
00:57:56 <shapr> boegel: If you mean 'how many' then I only know of three if you include me and you.
00:58:31 * Cale does a 100x100 mesh. 5.42 seconds
00:58:38 <boegel> shapr: oh, that's not enough for the next issue, right ?
00:58:56 <Cale> of course, it takes my terminal lots of time to display all that
00:58:58 <mwc> perhaps the suck is in the data formatting?
00:59:06 <mwc>    tabSeparate (a,b,c) = (show a) ++ "\t" ++ (show b) ++ "\t" ++ (show c)
00:59:06 <mwc>     dataLines = map tabSeparate dataPoints
00:59:06 <mwc>     formattedData = foldl (\s r -> s ++ "\n" ++ r) "" dataLines
00:59:12 <mwc> then I write that to a file
00:59:14 <Cale> oh
00:59:21 <Cale> quite possibly
00:59:27 <int-e> @index sinc
00:59:28 <lambdabot> bzzt
00:59:30 <mwc> let me increase the mesh size
00:59:40 <mwc> int-e: 
00:59:41 <mwc> sinc x | abs x <= 1e-3 = 1.0
00:59:41 <mwc>        | otherwise = (sin x)/x
01:01:46 <mwc> Okay, so I squared the number of mesh points
01:01:57 <mwc> let's see what the time scaling is like
01:02:46 <int-e> mwc: with the two `seq` I'm within a factor of 2 of the running time I get if all is in a single module.
01:03:37 <shapr> boegel: No, it's not. But if you know someone who wants to publish an article...
01:04:23 <Lokadin> goltrpoat: lol, i just noticed that er 18 year old comment you made 
01:05:21 <Lokadin> goltrpoat: i'd have to say it's astounding how close you are to the truth
01:05:29 <Lokadin> but yea i'll go read 
01:05:35 * boegel thinks Cale and xerox should write one on Nymphaea, the hIDE - Yi people should write one, maybe dcoutts could write one on the new OpenGL features in Gtk2Hs, and the upcoming 1.0 release, ....
01:05:39 <boegel> more idea's ? :)
01:07:26 <int-e> mwc: and with a {-# SPECIALIZE waveSolver :: Double -> (Double -> Double, Double -> Double) -> (Double -> Double, Double -> Double) -> (Double, Double, Int) -> (Double, Double, Int) -> (Int, Int) -> (Double, Double, Double) #-}, the running times are equal :)
01:09:21 <lispy> man, browsing my public darcs repos makes me miss having time for hobbies
01:09:36 <lispy> so much unfinished work
01:16:23 <machack666> @seen CosmicRay
01:16:23 <lambdabot> I saw CosmicRay leaving #haskell 1 day, 12 hours, 39 minutes and 24
01:16:23 <lambdabot> seconds ago.
01:18:42 <mwc> anybody recommend a nice pretty printer for haskell?
01:18:49 <mwc> something suitible for print output?
01:19:00 <lispy> a2ps
01:19:08 <lispy> it has a haskell syntax highlight mode
01:19:30 <mwc> give it a try I shall
01:19:50 <Cale> er, hmm... is that what mwc means?
01:20:18 <lispy> mwc: i recommend the man page because it has a lot of options and i recommend setting it to the highest level
01:20:23 <Cale> Do you mean a pretty printer for Haskell source code, or a pretty printing library written in Haskell?
01:21:02 <mwc> Cale: the former
01:21:08 <Cale> ah, okay
01:22:22 <Cale> Language.Haskell.Pretty has one of those implemented as a library, but if you're going to want print output, you'll want something which produces nice LaTeX from Haskell sources
01:22:43 <lispy> mwc: of interest: -E haskell -g 
01:23:14 <lispy> you'll want to make sure that your input has a max of 80 chars per line or some such
01:23:26 <lispy> if a2ps does line wrapping it will look terrible
01:24:16 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/haskell-style.html
01:24:43 <Cale> unless a2ps goes via that
01:24:55 <Cale> I haven't tried either one
01:25:48 <lispy> a2ps generates post script
01:25:55 <lispy> i don't think it knows anything about latex
01:26:11 <Cale> well, it's easy to go from latex to postscript :)
01:26:24 <lispy> a2ps is great if you want a quick and decent output to staple with your homework
01:26:54 <lispy> well, i should be asleep
01:26:56 <lispy> see ya later
01:27:10 <lispy> when is icfp?
01:27:37 * lispy looks it up
01:28:03 <lispy> oh it's in september
01:28:07 <Cale> me too, goodnight all
01:28:07 <lispy> so we have quite a while
01:28:13 <lispy> see ya
01:32:43 <mwc> lispy: hmm, a2ps isn't setting the haskell :(
01:32:51 <mwc>  a2ps -E haskell -g -o PDESolver.ps                                                
01:33:03 * shapr boings cheerfully
01:33:29 <mwc> ah, there it goes
01:33:41 <mwc> broken postscript I think
01:33:58 <unixgreybeard> if you have TeX source at any point you can use pdflatex to make printable files
01:34:01 <astrolabe> Is there a permutations library?
01:34:31 <unixgreybeard> I thought I spotted on on the wiki the other day
01:35:09 <unixgreybeard> or was that a probability library? I'm not certain!
01:35:25 <astrolabe> Ha.  You sound like me
01:36:07 <unixgreybeard> I have read soooo many haskell pages the last week!
01:36:25 <unixgreybeard> they blur
01:36:58 * shapr blurs into a purely functional version of Munch's "The Scream"
01:37:32 <jlouis> hahahah shapr 
01:37:58 <jlouis> more conjure
01:38:57 <shapr> jlouis: Did you get email from SPJ too?
01:39:36 <jlouis> directly?
01:39:40 <jlouis> personally?
01:39:41 <jlouis> no
01:39:48 <shapr> Yeah, I just got an email from SPJ asking about STM in Conjure.
01:39:58 <jlouis> oh...
01:40:09 <Heffalump> Conjure?
01:40:13 <jlouis> @where conjure
01:40:13 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
01:40:28 <luqui> @type par
01:40:29 <lambdabot> Not in scope: `par'
01:40:36 <luqui> @type Control.Parallel.par
01:40:37 <lambdabot> forall b a. a -> b -> b
01:40:40 <luqui> what does this function do?
01:40:56 <jlouis> shapr: is it forwardable?
01:41:04 <shapr> jlouis: Sure yeah, I'll send it.
01:41:08 <jlouis> luqui: runs a computation in parallel
01:41:16 <luqui> and then discards the result?
01:41:35 <luqui> how is that useful?
01:41:39 <int-e> luqui: let a = foo in a `par` other computation that eventually uses a
01:41:47 <shapr> jlouis: I think he emailed me because I turned my Combinatorrent HC&AR entry into a Conjure entry.
01:41:56 <jlouis> shapr: ah ;)
01:43:22 <Heffalump> so it's a Haskell bittorrent client?
01:43:47 <jlouis> Heffalump: no. It is the beginnings of a Haskell Bittorrent client
01:43:50 <shapr> jlouis: map pred "kmpvjtAnpohfst/psh", right?
01:44:24 <jlouis> looks right, let me check
01:44:33 <sieni> It would be nice to have i2p implemented with a programming language
01:44:37 <jlouis> right
01:45:03 <shapr> ok, sent
01:45:06 <jlouis> cool
01:46:22 <Heffalump> what'll it do better than the existing ones?
01:47:02 <jlouis> shapr: I can answer SPJ on that. It is possibly a very boring lesson today, so...
01:47:03 <boegel> ProfTeggy: do you want to write an article for TMR ?
01:47:18 <jlouis> (And Olegs TMR article rocks)
01:47:31 <boegel> jlouis: which one ?
01:47:47 <jlouis> the latest
01:47:53 <boegel> TMR5 ?
01:47:54 <jlouis> coding size informaion in types
01:48:05 <jlouis> TMR5 yes
01:48:07 <shapr> jlouis: hah, I like the "turns out he had stolen it from sylvan on #haskell"
01:48:09 * shapr laughs
01:48:31 <jlouis> its a cool repository! Read it!
01:52:33 <shapr> I'm working on too many different projects. :-/
01:53:07 <shapr> At least I'm never bored! :-)
01:53:09 * shapr boings cheerfully
01:53:43 <jlouis> shapr: do you know the principle of GTD (Getting things done) ?
01:53:57 <shapr> Obviously not ...
01:54:02 <jlouis> (Search it on wikipedia)
01:54:21 <shapr> Ah
01:54:38 <jlouis> and search GTD Tiddly Wiki
01:54:59 <shapr> I've actually downloaded the GTD TiddlyWiki, but I haven't gotten around to trying it.
01:55:47 <shapr> This sounds like Memento.
02:00:10 <shapr> sieni: i2p.net ?
02:02:17 * boegel calls another vote: which should be the subject of the first 'take 10 [1..]' article for TMR ? (http://www.haskell.org/tmrwiki/TopTenHaskell)
02:05:14 <astrolabe> Top ten libraries?
02:12:37 <shapr> I like that.
02:13:09 <shapr> A short description of top ten libraries. Björn Bringert's version of Warrick Grey's HTTP would be a good example.
02:13:16 <shapr> We should put in our votes now!
02:13:21 <machack666> How about the top 10 missing libraries?
02:13:34 <machack666> That could provide a useful base for future work. :)
02:13:58 <shapr> boegel: Do people get to vote on items for the top ten?
02:15:08 <shapr> jlouis: Thanks for the suggestion, I'll try the GTD TiddlyWiki.
02:15:45 <boegel> shapr: yeah sure, I don't know enough
02:16:47 <boegel> shapr: maybe I should ask haskell@ to vote ? or would that be too much ?
02:18:58 <shapr> I don't know, you decide.
02:19:17 <shapr> I'd ask haskell-cafe, but haskell might be the right place.
02:19:22 <shapr> Reality is just so subjective :-)
02:20:45 <boegel> I didn't get any reply on haskell-cafe last time, although one or two people did add suggestions to the wiki
02:21:22 <shapr> I'm never sure what to do when that happens.
02:21:27 <boegel> ok, will everyone cast a vote ? then I could construct a mail to ask for suggestions for top10 items on the chosen subject
02:21:39 <shapr> A lot of the fun things I've suggested got that sort of response.
02:22:11 <shapr> Does the small response mean that people are interested but busy, not interested, or did I just ask at the wrong time, in the wrong place, or what?
02:22:33 <shapr> Are we voting for top ten libraries?
02:22:33 <boegel> current possible subjects for the first 'take 10 [1..]' TMR article: publications, tools, citations, tutorials, people, language features, jokes, graphics, n00b FAQ's, user thoughts, typical mistakes, libraries 
02:22:42 <boegel> shapr: no, first the subject
02:22:59 <boegel> I'll ask for item contributions on the haskell mailing list, 'cause I don't want to miss any :)
02:23:05 <shapr> ok
02:23:29 <shapr> I'd vote for top ten libraries.
02:23:36 <boegel> cast your vote people ! (thx shapr)
02:23:51 <shapr> Hey, you could write a lambdabot vote plugin.
02:23:56 <shapr> I bet that would get you a bunch of votes.
02:24:01 <boegel> I _really_ don't have time for that
02:24:05 <boegel> yeah, it would :)
02:24:19 <boegel> anyone up for that ? :)
02:24:20 <shapr> I bet it would take an hour :-)
02:24:27 <sieni> shapr: yes
02:24:37 <Itkovian> @seen Lemmih
02:24:37 <lambdabot> I saw Lemmih leaving #haskell 7 hours, 46 minutes and 13 seconds ago.
02:25:10 <boegel> shapr: not for me it wouldn't
02:25:47 <boegel> Itkovian: vote !
02:26:26 <boegel> hmm, maybe I should build a small php thingie to allow voting...
02:26:33 <shapr> I guess it would take less time for me since I wrote the original plugin support for lambdabot.
02:26:39 <boegel> shapr: does scannedinavian support php ?
02:26:47 <shapr> It did...
02:26:48 <boegel> shapr: yeah ! do it dude ! :)
02:26:56 <boegel> it doesn't anymore ?
02:27:23 <shapr> I'm subscribed to a few security vulnerability lists, and PHP exploits are the most common.
02:27:32 <shapr> I can install it if you need it.
02:27:38 <shapr> You want php5?
02:28:19 <boegel> shapr: euh, yeah, I might find time tonight to build a small vote thingie then
02:28:39 <shapr> Wouldn't it be more fun to try it with Haskell? :-)
02:28:47 <boegel> shapr: yeah, it would
02:28:54 <boegel> a lambdabot plugin would be cool
02:29:05 <boegel> shapr: but how would you allow voting then?
02:29:20 <boegel> something like @vote-top10 list
02:29:24 <boegel> @vote-top10 3
02:29:24 <lambdabot> Unknown command, try @listcommands.
02:29:27 <boegel> something like that ?
02:29:39 <shapr> Sure, that would work.
02:29:53 <boegel> cool
02:30:08 <boegel> if you tell me how to get started, I could try it...
02:30:45 <shapr> I'd suggest you have a VoteModule with commands like @poll-add, @poll-list, and @choice-add maybe?
02:31:15 * shapr thinks
02:31:26 <boegel> shapr: hmm, yeah, probably
02:31:34 <shapr> Polls have choices, choices have votes. Is there anything else?
02:31:50 <boegel> I guess not... 
02:32:08 <shapr> I'd probably use a Data.Map to hold the info.
02:32:11 <boegel> and then use @vote <poll> <choice> or something ?
02:32:36 <shapr> boegel: But in the first version, just write a simple nearly static plugin, then see what sort of user feedback you get.
02:32:44 <boegel> it's been to long since I've done some Haskell... and I guess lambdabot uses monadic code ?
02:32:49 <shapr> That always works best for me, I am *not* the average person.
02:32:54 <boegel> shapr: yeah, I was thinking that too
02:34:36 <boegel> shapr: the first step would be to pull the lambdabot code from darcs ? 
02:34:44 <machack666> would you restrict each user for a single vote per poll?
02:34:51 <shapr> lambdabot plugins are pretty simple, check out the HelloModule: http://www.scannedinavian.org/repos/lambdabot/Plugins/Hello.hs
02:35:09 <boegel> machack666: hmm, that would be a possibility, yes
02:35:12 <shapr> boegel: Yup, darcs get http://www.scannedinavian.org/repos/lambdabot/ 
02:35:25 <shapr> That's the european mirror of dons' repo
02:35:45 <boegel> @hello
02:35:45 <lambdabot>  @help <command> - ask for help for <command>
02:35:58 <boegel> @helloworld
02:35:59 <lambdabot> Unknown command, try @listcommands.
02:36:01 <boegel> hmmz :)
02:36:15 <shapr> Hey boegel, where do you think I should go with ScannedInAvian.org ?
02:36:51 <shapr> Since my business partnership is ending, I'll be paying about seventy euro a month for the server, or more if the bandwidth goes over 5gb.
02:37:06 <boegel> shapr: I'm not sure what you mean ? I think it's great now, your own blog and allowing some people (including me) to show their modest work with Haskell
02:37:16 <boegel> shapr: oh :s
02:37:22 <boegel> shapr: that sucks
02:37:38 <shapr> The server seems valuable to the community, but I wonder which way to go... in or out?
02:37:49 <boegel> in or out what ? :)
02:38:08 <shapr> Should I offer 'real' Haskell hosting and ask for donations?
02:38:16 <boegel> it is valuable, atleast for me it is :) I don't know who else is using it for their Haskell work ?
02:38:20 <astrolabe> shapr: take adds?
02:38:26 <boegel> shapr: that'd be cool
02:38:41 <shapr> astrolabe: I'll investigate ads, good idea.
02:38:47 <boegel> astrolabe: add :| my god :) their should be another way to get 70€ a month
02:38:57 <boegel> I hope you're not thinking about porn ads :P
02:39:01 <shapr> No way
02:39:18 <boegel> alrighty then :)
02:39:21 <boegel> toy adds ? :)
02:39:43 <shapr> Just that I can buy a nice shiny new PC for a few months of ScannedInAvian hosting.
02:39:59 <astrolabe> There is no way you should have to pay for it.
02:40:19 <shapr> I know I'm not obligated, but I do enjoy contributing to the Haskell community.
02:40:58 <boegel> shapr: yeah, you should make sure you're not hungry because some nerds want a space to put their toys on
02:41:01 <shapr> I just don't know whether I should shrink or grow the role of ScannedInAvian.org in the community.
02:41:25 <astrolabe> Maybe there is room for the site on a university server somewhere
02:41:31 <boegel> growing is good, but you shouldn't have to pay for it
02:42:33 <shapr> Well, it is my hardware and domain name. I've just given accounts to worthy causes :-)
02:42:49 <shapr> Do you think anyone would donate if I gave that option?
02:43:42 <shapr> On the other hand, some companies in the community have been considering a community server, sort of like a tiny sourceforge.
02:44:53 <shapr> If you guys have more thoughts on this subject, I'd like to hear 'em
02:45:52 <shapr> boegel: I won't go hungry, that's not a problem.
02:46:09 <shapr> (My girlfriend will always feed me ;-)
02:47:43 <boegel> shapr: a community server would be great, then you could be the amdin ! i.e. taking scannedinavian to the next level
02:59:04 <xinming> class ClassA a => ClassB b where ...
02:59:18 <xinming> is ClassB inherited from Class A?
02:59:41 * xinming is going to commit suicide.
02:59:55 <xinming> too hard for me to understand. :-/
03:00:04 <int-e> hum
03:00:23 <int-e> you probably want class ClassA a => ClassB a where ...
03:00:25 <shapr> xinming: Think of (Eq a) => Ord (Foo a)
03:00:41 <int-e> and it means that for a type to be of class ClassB it has to be of class ClassA.
03:00:59 <xinming> hmm, But The book says, that all instance for ClassB will become the class ClassA
03:01:02 <xinming> Ouch...
03:01:25 <xinming> if the instance for ClassB turned into ClassA, then...
03:01:38 <xinming> ClassA inherited from ClassB
03:01:40 <xinming> :-/
03:01:47 <int-e> well, that's sort of true ... but it's backwards
03:02:13 <int-e> it really means (with a instead of b as I wrote it) that for something to be of ClassB it has to be of ClassA.
03:02:16 <shapr> It's not OOP inheritance, it's more like Java interfaces.
03:02:27 <int-e> yep
03:04:11 <gour_> shapr: i'd suggest to organize server as haskellforge, i.e to provide full hosting-services (darcs, trac, php, dbases...) for haskell-oriented projects and then have a fund-raising by collecting donations to maintain the whole thing
03:05:27 <gour_> shapr: maybe haskell.org could serve the same purpose but with some more-time (i.e, not full-time) admin
03:13:02 <shapr> gour: I'll think about that, thanks.
03:17:28 <shapr> konichiwa voickas-san, are you learning Haskell?
03:17:43 <voickas> yes
03:17:51 <shapr> Do you have any questions?
03:18:03 <voickas> hmm.. nothing paticular
03:18:19 <shapr> Ok, if you have any questions, feel free to ask here.
03:18:43 <xinming> shapr: ... you don't ask me for this while I first come here. :-/
03:18:45 <shapr> I can also give you a short tour of the local Haskell resources if you wish.
03:18:57 <shapr> xinming: I didn't see you first come here, sorry.
03:18:58 <jlouis> shapr: no problem. I'll write back to SPJ now. The exercise lessons were quite boring
03:19:05 <xinming> :-p
03:19:13 <shapr> jlouis: Ok, can you CC me?
03:19:32 <shapr> xinming: Do you want the short intro? :-)
03:19:54 <xinming> /usr/share/doc/haskell98-tutorial/html
03:19:56 <xinming> :-)
03:23:54 <jlouis> shapr: sure ;)
03:24:07 <jlouis> @where conjure
03:24:07 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
03:29:28 <kosmikus> stefanw: Thanks for the patch. I'll have a look.
03:46:07 <jlouis> shapr: sent
03:48:08 <jlouis> (oy Philippa )
03:51:55 <boegel> I get this error while building lambdabot: "Could not find module `Data.FastPackedString':"
03:52:03 <boegel> does lambdabot rely on some library being installed ?
03:52:11 <kolmodin> @where fps
03:52:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:52:22 <kolmodin> boegel: ^^
03:52:39 <boegel> oh wait , nvm :) I neglegted to read the full install instructions :)
03:56:19 <jlouis> aha
03:57:26 <dons> booegel, lambdabot doesn't use Cabal, and boegel doesn't read readmes ;)
03:57:45 <dons> hey jlouis, how's code?
04:01:08 <boegel> the number of pathces in the Cabal repository is 666, the number of the Beast !
04:01:40 <dcoutts> boegel, quick! send in another patch!
04:02:17 <boegel> dcoutts: nah, I quite like it :P
04:02:32 <dons> now Cabal will RULE THE WORLD!!
04:02:39 <boegel> I'm getting quite a few warning though while compiling Cabal
04:03:07 <eivuokko> Yup, it's ok.
04:03:15 <astrolabe> Oh dear.  What rough beast, its hour come round at last, shambles towards GHC to be compiled?
04:03:28 * shapr grins
04:05:03 <gour> dcoutts: have you seen http://mail.gnome.org/archives/meld-list/2005-November/msg00020.html
04:05:20 <dcoutts> gour, oh cool
04:11:11 <dons> hmp3 0.1 is released!
04:11:22 <luqui> is fps the same module as Data.PackedString?
04:11:28 <dons> nope.
04:11:34 <dons> it's Data.FastPackedString
04:11:42 <luqui> what's the difference?
04:11:44 <shapr> The sun went backwards today. That was weird.
04:11:46 <luqui> besides, well, speed :-)
04:11:52 <dons> it's the evil child of PackedString.
04:12:10 <dons> it uses ForeignPtr byte arrays instead of Haskell arrays
04:12:19 <dons> @where hmp3
04:12:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
04:12:32 <dons> yay for fast coding in haskell
04:13:32 <dons> bah, my msg to haskell@ awaits moderator approval, as: "    Message has a suspicious header
04:13:59 <astrolabe> shapr: What do you mean?
04:14:28 <shapr> astrolabe: I mean that the sun came up on my left, and then went back and set on my left instead of on my right as usual.
04:14:55 <astrolabe> that was weird!
04:14:55 <dons> shapr's going crazy in the darkness
04:15:04 <shapr> I know it's an artifact of my northerly location, but it's still weird.
04:15:06 <dons> unless... his house rotated!
04:15:20 <dons> even so, that also would be weird
04:15:46 <shapr> When you're this far north, the sun gets into weird patterns as the seasons change.
04:18:31 <luqui> is there a quick documentation tool for haskell, a la perldoc
04:18:32 <astrolabe> It should always move left to right though.  I back dons house theory.
04:18:56 <dons> luqui, haddock
04:19:08 <dons> @where haddock
04:19:09 <lambdabot> http://www.haskell.org/haddock/
04:19:14 <luqui> that generates docs... but can I just say, like, haddock Data.FastPackedString?
04:19:24 * luqui is currently installing it and is impatient
04:19:36 <eivuokko> Haskell community divided by Sun behaviour o.O
04:20:14 <dons> luqui, you need the src installed for the module whose docs you want to read
04:20:31 <dons> usually it would be easier to find the docs on the projects website.
04:20:47 <dons> http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
04:20:49 <dons> like so ;)
04:20:56 <shapr> eivuokko: I thought that the Java community? :-)
04:21:00 <luqui> :-)
04:21:38 <dons> 4% of the haskell community things fps is necessary for their daily work! that 4% can't be wrong, right? hehe
04:21:51 <shapr> eivuokko: I did read your mail, and I have much to say, but I'm slow at getting it formatted into email.
04:21:56 * luqui thinks that that's a bug in the haskell community convention
04:22:11 <luqui> (the fact that there's no easy doc tool)
04:22:22 <dons> haddock is our easy doc tool
04:22:28 <dons> it's easy! it does docs! it's a tool!
04:22:30 <luqui> yeah, but not like perldoc
04:22:40 <dons> ok. time to hack the, luqui :)
04:22:41 <shapr> What does perldoc do?
04:22:45 <dons> s/the/then/
04:22:53 <luqui> hooray, I could contribute something!
04:23:07 <dons> yeah, seriously, if perldoc is better, then that would be a really cool projcet
04:23:17 <luqui> shapr, perldoc lets me say: perldoc Parse::RecDescent # oh, that's how Parse::RecDescent works!
04:23:22 <dons> take haddock, and adapt it. that would probably be easier. 
04:23:32 <dons> or maybe start with idoc, or just Language.Haskell
04:23:40 <luqui> idoc?
04:23:58 <dons> it was a simpler forerunner to haddock, just one module of pure h98
04:24:20 <luqui> perhaps.  Does haddock render anything besides html?
04:24:22 <dons> @where+ idoc http://www.cse.unsw.edu.au/~chak/haskell/idoc/
04:24:22 <lambdabot> idoc ~> http://www.cse.unsw.edu.au/~chak/haskell/idoc/
04:24:37 <dons> don't think so
04:25:06 <dons> also, you could read the haddock paper that was presented at the Haskell workshop about 3 years ago
04:25:18 <dons> that would cover most of the background on these tools
04:25:40 <dons> bah, i can't believe my announce got bounced on haskell@
04:25:54 <dons> they must be tightening the screws
04:27:57 <shapr> Aren't you a subscriber?
04:30:15 <dons> of course.
04:31:01 <dons> they still occasionally flag mail from subscribes as suspicious, it seems
04:31:47 <dons> boegelBot: @version
04:31:47 <boegelBot> lambdabot 3p189, GHC 6.4.1 (Linux i686)
04:31:47 <boegelBot> darcs get http://www.scannedinavian.org/repos/lambdabot
04:31:58 <dons> boegelBot: > 1 + 2
04:31:59 <boegelBot> 3
04:32:21 <dons> boegelBot: @vixen does boegel feed you properly?
04:32:21 <boegelBot> why don't you guess?
04:32:38 <dons> boegelBot: @vixen my guess is that you're malnourised
04:32:39 <boegelBot> yeah, it is
04:33:21 <luqui> boegelBot: @vixen what is vixen?
04:33:21 <boegelBot> i'm a vixen
04:34:05 <luqui> boegelBot: @vixen what's a vixen?
04:34:06 <boegelBot> i'm a vixen
04:34:10 <luqui> thanks...
04:39:41 <shapr> boegelBot: @part #gentoo-haskell
04:39:54 <shapr> boegelBot: @listchans
04:39:54 <boegelBot> #haskell #haskell-blah #haskell-overflow
04:40:18 <dcoutts> shapr, oh I didn't know about those commands. Thanks.
04:41:00 <dcoutts> is there any reason for us to have 2 lambdabots in here?
04:41:06 <dcoutts> @botsnack
04:41:06 <boegelBot> :)
04:41:06 <lambdabot> :)
04:49:56 <shapr> boegelBot: @part #haskell
05:01:45 <Igloo> Cale: I thought MissingH had an example of decompressing a gzip file?
05:04:49 <musasabi> Does anyone have a wxhaskell-0.9 Debian package (for ghc 6.4.1) ?
05:06:11 <araujo> Good morning!
05:06:44 <musasabi> morning araujo 
05:06:51 <dhpeterson> dons: hi ... i'm with luqui ... perldoc is nice. In fact it's one of the best things about perl imho
05:08:30 <araujo> Hello musasabi , what's up?
05:11:47 <musasabi> trying to get wxhaskell 0.9 installed on Debian
05:12:12 <musasabi> "wxc/include/wrapper.h:474: error: conversion from 'char*' to 'const wxString' is ambiguous", and I think I have all prequisite packages installeed.
05:12:21 <musasabi> when trying to compile it.
05:12:47 <musasabi> rpm + alien does not register it with GHC (and does not leave a package config file lying around)
05:16:47 <astrolabe> What was the convention for an argument you won't use?  Was it something like 'unused_' ?
05:16:56 <Lemmih> _unused
05:17:03 <astrolabe> thanks
05:18:19 <musasabi> if anyone has gotten it to work on Debian I would be very interested in tips (or a .deb)
05:49:13 <shapr> w00, monads are hitting the big time!
05:49:23 <shapr> It's just like Object Technology all over again!
05:49:24 <integral> o_O
05:49:35 <integral> but not as bad, right?
05:49:38 <shapr> Let's all start a monad technology conference series...
05:49:47 <shapr> integral: Just wait till the lemmings get hold of it.
05:50:02 * integral weeps for the monads
05:50:17 <shapr> I worked with some Java programmers who made every method static because they didn't understand instances.
05:50:32 <shapr> It ended up being subroutine clumps.
05:50:45 <roconnor> I'm writing a paper on monads.
05:50:50 <shapr> I'm sure those people could do something equally horrendous to monads.
05:50:53 <roconnor> Well, *a* monad.
05:50:53 <shapr> roconnor: Oh, what subject?
05:51:06 <Oejet> Think of all the "Monads for Dummies" there will be written!
05:51:10 <roconnor> Completing a metric space is a monad.
05:51:21 <musasabi> Rewriting MonadTrans before too late could make sense.
05:51:31 <integral> they'd throw the kitchen sink into IO :-/
05:51:44 <roconnor> Unfortunately it isn't a Haskell monad.
05:51:57 <musasabi> Monads could be made more fine-grained if it was not N^2
05:52:34 <araujo> shapr, most of java programmers don't understand instances (hello!)
05:52:48 <shapr> araujo: Really?
05:52:48 <Oejet> musasabi: What do you mean by N^2?
05:52:52 <shapr> That's sad.
05:53:17 <araujo> shapr, yes, at least that's what happens here, they even got no clue about what object orientation is about.
05:53:23 <shapr> roconnor: Are you doing something with the category of uniformly continuous functions?
05:53:27 <araujo> They end up coding in a C-style. Period.
05:53:38 <shapr> I admit, I have inside information. I read roconnor's blog.
05:54:53 <roconnor> indeed.
05:54:55 <shapr> Anyway, my 'monads hit the bigtime' theses comes from the fact that monad implementations have recently been released in Perl, Ruby, and now Joy.
05:55:02 <shapr> thesis*
05:55:04 <roconnor> I will have my preprint ready in 10 days
05:55:08 <shapr> cool!
05:55:10 <integral> when someone says "category of uniformly continuous functions", they mean that it's a space with the functions as objects?
05:55:39 <integral> so it's a bit like the vector space of uniformly cts fns? with the vector space homomorphisms as the category morphisms?
05:55:42 <ibid> i have long held that the future of programming looks like haskell but i don't know what it will be called. could be called OO, still :)
05:55:46 <roconnor> integral, that's right, however that isn't what I mean by it.
05:55:48 <musasabi> Oejet: defining the transformers one by one is tedious.
05:55:51 <roconnor> I used poor working.
05:56:05 <roconnor> I mean a category where the morphisms are uniformly continuous functions.
05:56:14 <roconnor> ... poor wording.
05:56:26 <Philippa> ibid: probably. I fully expect type class-like things to take front seat and algebraic datatypes the back
05:56:45 <integral> ah, so is this like a category of some kind of topological spaces then?
05:56:54 <Oejet> musasabi: So you mean a kind of Big-O-notation for the effort?  O(N^2)?
05:56:59 <roconnor> The objects are metric spaces.
05:57:01 <samc> hmm, that reminds me of Lawvere which reminds me of "sets for mathematics" anyone read it and if so liked it?
05:57:07 <roconnor> Although they probably couldn't be uniform spaces.
05:57:16 <roconnor> however I know little about uniform spaces.
05:57:24 * roconnor can't type
05:57:35 <roconnor> I mean the objects *could* be uniform spaces.
05:57:51 <roconnor> however I know little about uniform spaces, so I just consider the objects to be metric spaces.
05:58:10 <shapr> hej joelr1 
05:58:19 <joelr1> howdy shapr 
05:58:19 <roconnor> In fact I don't even use metric spaces, but some nice subclass.
05:58:22 <joelr1> hey everyone
05:58:35 <joelr1>        taken <- (fmap or . sequence) $ map (tryTakeSeat aff_id) seats
05:59:05 <joelr1> will this go until the first True or will it keep going after the first True is received? because it appears it keeps going and i want it to stop
05:59:20 <joelr1> i.e. i want it keep going while False is being returned
06:02:57 <musasabi> Oejet: yes.
06:03:31 <Lemmih> > fmap or . sequence $ [return True, undefined :: Maybe Bool]
06:03:33 <lambdabot> Undefined
06:03:50 <kowey> are there any standard Trie-building thingies out there? (i'm looking at the haskell hiearchical lib now)
06:03:53 <musasabi> using explicit recursion could make sense.
06:04:05 <joelr1> musasabi: this is what Cale came up with yesterday
06:05:11 <ricebowl> @hoogle Array#
06:05:11 <lambdabot> hoogle: Unexpected character when parsing: >
06:05:11 <lambdabot>  
06:05:27 <musasabi> > let firstTrueM [] = return (); firstTrueM (c:cs) = c >>= \e -> if e then return () else firstTrueM cs in firstTrueM [return True, undefined :: Maybe Bool]
06:05:28 <lambdabot> Just ()
06:06:32 <ricebowl> um, couldn't you do find Maybe.isJust?
06:06:40 <joelr1> musasabi: anything wrong with Cale's style?
06:06:47 <ricebowl> @eval find Maybe.isJust [Nothing, Nothing, Just 2, Just 3, Nothing]
06:06:48 <lambdabot> Just (Just 2)
06:07:05 <musasabi> joelr1: it is pointless ;)
06:07:19 <joelr1> musasabi: really?
06:07:22 <joelr1> how so?
06:08:21 <ricebowl> @eval head (Maybe.mapMaybe [Nothing, Nothing, Just 2, Just 3, Nothing])
06:08:22 <lambdabot>   Expecting a function type, but found `[a]'
06:08:22 <lambdabot>   Expected type: [a]
06:08:22 <lambdabot>   Inferred type: [a1] -> [b]
06:08:23 <musasabi> pointless == point-free
06:08:27 <musasabi> http://haskell.org/hawiki/PointFreeStyle
06:08:29 <ricebowl> @eval head (Maybe.mapMaybe id [Nothing, Nothing, Just 2, Just 3, Nothing])
06:08:30 <lambdabot> 2
06:10:13 <ricebowl> blah, does anyone know where Array# is documented? I have seen references to it but don't recall where.
06:10:30 <joelr1> musasabi: so you don't like pointless style?
06:10:36 <joelr1> Cale: ping
06:11:03 <musasabi> joelr1: it tends to make programs less readable when applied too much, but that is just my opinion.
06:11:22 <musasabi> of course in small amounts it is a good thing.
06:11:25 <Philippa> I find the way the monad laws are typically expressed in it makes it much harder for me to read them off
06:11:36 <joelr1> musasabi: but can you tell me what needs to be changed in my expression to make it stop after the first True?
06:11:41 <Lemmih> joelr1: Can you use mzero instead of 'return False'?
06:11:49 <Philippa> it takes practice to learn where to put the 'implicit' parameters
06:12:06 <musasabi> joelr1: I think sequence is the culprit.
06:12:07 <joelr1> Lemmih: i need to return m Bool
06:12:13 <musasabi> @libsrc Control.Monad
06:12:14 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
06:13:37 <Lemmih> > foldr Control.Monad.mplus (return False) [Control.Monad.mzero,return True,undefined::Maybe Bool]
06:13:38 <lambdabot> Just True
06:13:43 <musasabi> sequence is strict on the list of actions, but not on the actions itself (if the monad is not strict)
06:14:24 <joelr1> hmm
06:14:55 <joelr1> what do i use instead of taken <- (fmap or . sequence) $ map (tryTakeSeat aff_id) seats
06:15:14 <joelr1> do i absolutely have to go recursive?
06:18:23 <musasabi> joelr1: I think the recursive way is clearer, but you can do it without going recursive.
06:18:37 <joelr1> musasabi: ok
06:19:40 <ricebowl> curious, Array only supports up to 5 dimensions?
06:20:04 <ricebowl> they ought to have made it possible to match (,) in the same fashion that one can match lists
06:20:50 <musasabi> joelr1: taken <- foldl mplus mzero [tryTakeSeat aff_id x | x <- seats]
06:21:12 <musasabi> (untested)
06:21:31 <joelr1> musasabi: thanks! i think recursive is much clearer :D
06:22:19 <sebell> List comprehensions are reasonably nice to read also
06:27:34 <joelr1> sebell: they are except i cannot understand the combo of mplus and mzero 
06:27:38 <joelr1> and foldl
06:27:42 <joelr1> musasabi: why not foldr?
06:30:26 <sebell> joelr1: the mplus function parameters are m a, thus mzero is required
06:30:34 <joelr1> right
06:30:42 <joelr1> why the foldl instead of foldr?
06:31:23 <musasabi> > foldl mplus mzero [Just 1, Just 2]
06:31:24 <lambdabot> Just 1
06:31:28 <musasabi> > foldr mplus mzero [Just 1, Just 2]
06:31:29 <lambdabot> Just 1
06:31:49 <musasabi> because I lean left ;)
06:31:59 <joelr1> > foldr mplus mzero [Just 1, Nothing]
06:32:00 <lambdabot> Just 1
06:32:10 <joelr1> > foldr mplus mzero [Nothing, Just 2]
06:32:11 <lambdabot> Just 2
06:32:11 <joelr1> hmm
06:32:13 <joelr1> cool
06:32:26 <joelr1> musasabi: it will be lazy, right?
06:32:37 <ricebowl> @type foldr
06:32:38 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:32:39 <joelr1> but shouldn't it go left to right? 
06:32:42 <musasabi> > foldr mplus mzero [Just 1, error "urgh"]
06:32:44 <lambdabot> Just 1
06:32:52 <joelr1> musasabi: got it!
06:32:53 <joelr1> thanks
06:36:35 <roconnor> Isn't mplus associative?
06:50:07 <bosie> why is this anything but correct:
06:50:07 <bosie> repeat 0 !! length strings , strings being ["String"]
06:50:34 <bosie> i expect it to be [Int] so 0 is int and return requires a -> [a] so that should work perfectly ?
06:51:24 <ricebowl> huh?
06:51:32 <ricebowl> that should always return 0
06:51:38 <ricebowl> s/return/evaluate to/
06:51:38 <bosie> why ?
06:51:45 <bosie> @type repeat
06:51:45 <ricebowl> (repeat 0) !! (length strings)
06:51:46 <lambdabot> forall a. a -> [a]
06:51:59 <ricebowl> @type (repeat 0) !! (length strings)
06:52:00 <lambdabot> Not in scope: `strings'
06:52:03 <ricebowl> er
06:52:05 <ricebowl> @type (repeat 0) !! (length [])
06:52:06 <lambdabot> forall a. (Num a) => a
06:52:17 <bosie> ah
06:52:17 <ricebowl> repeat 0 is going to have type [Int]
06:52:21 <bosie> hm
06:52:25 <ricebowl> length strings is going to have type Int
06:52:27 <bosie> yea
06:52:37 <ricebowl> and (!!) :: [a] -> Int -> a
06:52:48 <bosie> hmm so how do i fill a list with just one value for a given length if not with repeat ?
06:53:08 <ricebowl> replicate (length "abcd") 0
06:53:08 <ricebowl> > replicate (length "abcd") 0
06:53:09 <lambdabot> [0,0,0,0]
06:53:28 <ricebowl> you could also do this:
06:53:45 <ricebowl> > foldl' (0:) [] "abcd"
06:53:46 <lambdabot>   Expecting a function type, but found `[a]'
06:53:46 <lambdabot>   Expected type: [a] -> b -> [a]
06:53:46 <lambdabot>   Inferred type: [a] -> [a]
06:53:57 <ricebowl> er, right.
06:54:06 <ricebowl> > foldl' (\x y -> 0:x) [] "abcd"
06:54:07 <lambdabot> [0,0,0,0]
06:54:11 <bosie> i got an string list not a string
06:54:22 <musasabi> > map (const 0) "abcd"
06:54:23 <lambdabot> [0,0,0,0]
06:54:27 <ricebowl> well, it will work with any sort of list
06:54:41 <ricebowl> what exactly are you trying to do?
06:55:38 <bosie> filling a list with 0 for the length of strings
06:56:43 <ricebowl> give an example for ["a", "ab"]
06:56:46 <ricebowl> what should the result be?
06:56:51 <bosie> [0,0]
06:57:13 <ricebowl> then any of the solutions that have been posted will work
06:57:22 <bosie> hm
06:57:23 <ricebowl> > map (const 0) ["a", "ab"]
06:57:24 <lambdabot> [0,0]
06:57:26 <bosie> at least that one isnt:
06:57:26 <bosie> foldl (\x y -> 0:x) []  strings
06:57:31 <bosie> map didnt work either
06:57:41 <ricebowl> [0,0] == [0,0]
06:58:54 <bosie> oh boy my fault
06:59:31 <ricebowl> ;)
06:59:37 <bosie> one might call a function not just the paramaters even if there is just one function in the file :(
06:59:49 <ricebowl> huh?
07:00:05 <bosie> test>["",""]
07:00:18 <bosie> so i figured ghci would go to the first and only function in the loaded file
07:00:30 <ricebowl> oh, no
07:00:43 <ricebowl> you would need to put the function name there
07:00:52 <ricebowl> you can evaluate arbitrary expressions in GHCi
07:01:09 <ricebowl> without loading anything you can enter "map (const 0) ["a", "ab"]" and get a result
07:01:15 <ricebowl> Prelude> map (const 0) ["a", "ab"]
07:01:15 <ricebowl> [0,0]
07:01:45 <bosie> hm might be the reason why it doesnt automatically jump to a function
07:02:56 <ricebowl> http://www.rafb.net/paste/results/omuWnr23.html
07:03:44 <ricebowl> you in the process of learning Haskell (like me)?
07:03:54 <bosie> yes sir
07:04:09 <bosie> what is rr.com ?
07:04:40 <bosie> california ?
07:05:13 <ricebowl> no
07:05:20 <ricebowl> rr.com is one of the more popular US ISPs
07:05:20 <bosie> k
07:05:33 <ricebowl> where are you from?
07:05:51 * ricebowl lives in Florida, BTW
07:06:00 <bosie> austria
07:06:30 <ricebowl> ah, nice
07:06:41 <bosie> you even know?
07:06:49 <ricebowl> know what?
07:06:55 <bosie> austria ;)
07:07:03 <ricebowl> no, I've never been there
07:07:15 <ricebowl> I would have attempted to speak Deutsch
07:07:20 <ricebowl> but... my German is not particularly good
07:07:22 <bosie> hehe really... ;)
07:07:39 <ricebowl> that is to say that it is particularly bad since I have only studied for about 10 weeks
07:07:42 <bosie> do you learn haskell for univ too ?
07:07:57 <bosie> hm i guess u dont need german anyway
07:08:10 <ricebowl> yep, I am
07:08:15 <jlouis> @where conjure
07:08:16 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
07:08:46 <bosie> wow u coded all that?
07:08:47 <ricebowl> technically I already speak the "Lengua Franca" of the world, so yes, I don't need anything else...but I speak Spanish when I have the chance
07:09:33 <bosie> hehe well, given the fact half of florida seems to speak spanish... i bet it wouldnt hurt to speak spanish too
07:09:45 <ricebowl> haha probably, but I don't run into any of those people for some reason
07:10:11 <bosie> you wrote a torrent client with haskell ?
07:10:20 <ricebowl> I didn't, someone else did
07:10:40 <bosie> oh sorry, i ddint see that jlouis requested it
07:10:48 <ricebowl> yes :p
07:11:09 <ricebowl> look at the AUTHORS file
07:11:26 <ricebowl> all of those guys are active here
07:11:49 <bosie> seems to be the only active guys in here wrote the client ;)
07:11:50 <boegel> sorry about the boegelBot incident in here :)
07:12:11 <ricebowl> not the only ones I think
07:15:30 <bosie> works
07:15:34 <bosie> thanks bowl
07:16:07 <ricebowl> np
07:16:11 <bosie> btw, being a student myself, why on gods earth are you already up at 9am ?
07:16:19 <ricebowl> haha
07:16:23 <ricebowl> it's 10:13 actually ;)
07:16:36 <trez> 16:16 :P
07:16:39 <bosie> yea but i figured it takes an hour to get to haskell ;)
07:16:55 <ricebowl> nope, I actually started 4 hours ago
07:16:58 <ricebowl> right after I woke up
07:17:04 <bosie> right
07:17:08 <ricebowl> I was tired last night and fell asleep at 20:30 or thereabouts
07:17:19 <bosie> whats ur grade average thingie?
07:17:31 <ricebowl> GPA? Grade Point Average?
07:17:37 <bosie> yea exactly
07:17:38 <ricebowl> just above a 3.0, I think, not very good :p
07:17:54 <bosie> kk
07:18:09 <ricebowl> I get all A's in Computer Science courses, C's and D's in Math courses, and B's and C's in Humanities
07:18:13 <ricebowl> go figure. :p
07:18:22 <bosie> Humawhat ? ;)
07:18:26 <vegai> well, math has nothing to do with computer science
07:18:35 * vegai flees as the angry mob approaches!
07:18:38 <ricebowl> Math has *everything* to do with Computer Science
07:18:52 <bosie> vegai agreed
07:18:57 <ricebowl> in the same manner that Chemistry is applied Physics, Computer Science is applied Mathematics
07:19:06 <ricebowl> *Software Engineering* has little to do with Mathematics. ;)
07:19:19 <bosie> what do you define as CS?
07:19:35 <ricebowl> well, notice the 'S', that stands for the word "science" ;)
07:19:43 <bosie> doesnt answer my question
07:20:13 <ricebowl> Computer Science is research, development of new algorithms, proofs of correctness, etc.
07:20:20 <bosie> yea k
07:20:22 <boegel> dons: how do i 'active' the hello world plugin in lambdabot ? @???
07:20:24 <bosie> so not real life ;)
07:20:46 <ricebowl> well, Software Engineering depends on Computer Science
07:21:22 <bosie> yea but if i go to apple and implement their gui i dont think you need that much math actually. and then the math you need is very limited to a certain area of math
07:21:38 <tuomov> CS is a lot of things, some of which are very mathematical and some not at all
07:21:51 <tuomov> it's a rather vague concept, really, used differently by different people
07:22:08 <vegai> would perhaps be better off without the whole term
07:22:31 <tuomov> Theoretical CS (TCS) is applied mathematics, though.
07:22:38 <vegai> where's "Bomb science"?
07:22:53 <Philippa> chemistry and/or physics
07:22:58 <vegai> also 'genocide science'
07:23:05 <vegai> Philippa: exactly :)
07:23:31 <tuomov> but what's this rocket science?
07:23:45 <vegai> a conspiracy
07:23:52 <Philippa> rocket science isn't rocket science, y'know
07:24:01 <Philippa> any kid can do it these days
07:24:08 <tuomov> (the finnish equivalent of "rocket scientist" is "nuclear physicist", however)
07:24:19 <bosie> lol
07:24:26 <vegai> it is? :P hmm
07:24:31 <vegai> yeah, I guess
07:24:44 <eivuokko> Yea, it is ;)
07:24:46 <bosie> vegai shouldnt u know? ;)
07:24:52 <vegai> yeah, I should
07:26:45 <samc> "Theoretical CS (TCS) is applied mathematics" so is it theoretical or applied :P
07:26:51 <yaarg> @type Control.Exception.bracket
07:26:52 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:27:32 <tuomov> well, some of TCS is mathematics for mathematics' sake, i.e. pure mathematics, but some of it does have real applications
07:27:59 <boegel> does anyone know how i can get my own lambdabot clone to identify so it accepts private messages ?
07:29:00 <boegel> shapr, dons: ping !
07:30:53 <yaarg> Well I wish did Maths instead of CS because I hate the hardware side.
07:34:37 <tuomov> "Computer Science is no more about computers than astronomy is about telescopes." -- E. Dijkstra
07:36:06 <neologism>  I heard different version
07:36:41 <tuomov> IIRC, even Turing had in mind human (wage-)slaves performing the computations when he designed his machine
07:36:49 <vegai> is astronomy really not the least interested in telescopes, other than using them?
07:37:26 <yaarg> vegai: Erm telescope design is a bit part of astronomy. 
07:37:28 <tuomov> telescopes are as useful for astronomy as computers are for CS, but it's not just about them
07:37:36 <neologism> I think there's some work on computers optimalizing images
07:37:37 <neologism> sw
07:37:39 <yaarg> s/bit/big/
07:37:54 <yaarg> i.e. they tend to be designed in Astronomy labs
07:38:11 <yaarg> with engineers help of course :)
07:38:34 <vegai> so Dijkstra was saying that Computer Science is a bit about computers 
07:38:59 <vegai> I'm not sure if I want to be quoted a lot posthumously
07:39:07 <vegai> everyone's bound to misunderstand everything
07:40:14 <neologism> btw: do you have some nice description of stg machines?
07:40:24 <neologism> or.. do you know about any?
07:43:32 <Philippa> they can get a bit involved. The "stock hardware" paper is OK
07:43:42 <Philippa> as in, I eventually got to a point where it was readable for me :-)
07:55:56 <shapr> vegai: Not like that'll be different than people listening to us when we're alive.
07:56:08 * shapr has just finished a 'discussion' with his ex.
07:57:18 <neologism> how many dead?
07:58:47 <ricebowl> haha
08:00:23 <shapr> joelr1_: I tend to use head $ catMaybes
08:00:32 <vegai> shapr: there's a better chance at correcting them in the other case :)
08:00:36 <joelr1_> wow
08:00:39 <joelr1_> i forgot that i was here
08:01:09 <joelr1_> shapr: ok, thanks
08:01:14 * ricebowl is looking for a function with type :: String -> (a, String)
08:01:18 <ricebowl> how can I search for that?
08:01:51 <ricebowl> lambdabot can do it, can't he?
08:02:00 <shapr> yup
08:02:09 <shapr> @hoogle [Char] -> (a, [Char])
08:02:10 <lambdabot> No matches, try a more general search
08:02:20 <shapr> @hoogle String -> (a, String)
08:02:21 <lambdabot> No matches, try a more general search
08:02:29 <shapr> @hoogle b -> (a, b)
08:02:30 <lambdabot> No matches, try a more general search
08:02:34 <shapr> hmm
08:02:41 <shapr> @type split
08:02:41 <lambdabot> Not in scope: `split'
08:02:46 <shapr> @type Data.List.split
08:02:47 <lambdabot> Not in scope: `Data.List.split'
08:02:49 <ricebowl> @type splitAt
08:02:50 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:02:56 <shapr> @type Data.List.break
08:02:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:03:16 <ricebowl> well, I'm looking for something similar to read
08:03:16 <shapr> @hoogle c -> b -> (a, b)
08:03:17 <lambdabot> No matches, try a more general search
08:03:23 <ricebowl> I can't remember what the function was
08:03:32 * araujo feels monadically enlightened 
08:03:38 <shapr> Why doesn't c -> b -> (a,b) match with splitAt or break?
08:04:07 <SamB> @google "Dynamic Applications From the Ground Up"
08:04:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
08:06:11 * SamB fails to see how it is an improvement to use Haskell that looks like ASM to replace an fprintf in C
08:07:08 * SamB imagines a distant future in which "Hello!" will be overloaded
08:07:15 <shapr> SamB: betcha it has fewer buffer overflows and more type safety.
08:07:49 <vegai> if only there was a strdup_printf in the standard lib...
08:08:27 <SamB> shapr: does printf have buffer overflows?
08:08:50 <ricebowl> sprintf does
08:09:03 <ricebowl> possibly in the implementation, and usually in the application
08:09:11 <SamB> well, he was using fprintf before
08:09:34 <SamB> I guess the Haskell doesn't realy look that much like ASM
08:09:52 <ricebowl> yes, I was wondering where you got that statement from :p
08:10:04 * ricebowl reads a lot of x86 asm and doesn't see the resemblance
08:10:09 <mardy> aight, I have spome problems compiling a simple haskell program with support from a c/c++ program that I want to import through ffi, the error I get is:
08:10:09 <mardy> Linking ...
08:10:09 <mardy> Test.o(.text+0xa8):fake: undefined reference to `C_Interface_Get'
08:10:09 <mardy> Test.o(.text+0x15f):fake: undefined reference to `C_Interface_Die'
08:10:09 <mardy> Test.o(.text+0x26b):fake: undefined reference to `C_Interface'
08:10:10 <mardy> collect2: ld returned 1 exit status
08:10:12 <mardy> anybody have any idea how to solve this?
08:10:36 <SamB> ricebowl: do you know what I'm talking about?
08:10:48 <ricebowl> which statement?
08:10:49 <mardy> ghc -static *.o --make -ffi -lstdc++  -pgml g++ -pgmc g++ -lwinmm -L"C:\Program\Microsoft Visual Studio 8\VC\PlatformSDK\Lib" Thest.hs
08:11:06 <flux__> mardy, I know nothing about doing that, but is the name mangling c++ does to symbols taken into account?
08:11:14 <SamB> mardy: its a linking problem
08:11:27 <eivuokko> mardy, instead of -l and -L, just point to the .lib file.
08:11:32 <mardy> yeah it compiles fine enough :D
08:11:40 <SamB> where are C_Interface{_Get,_Die,}
08:11:40 <SamB> defined
08:12:01 <mardy> in a wrapper file
08:12:25 <SamB> maybe you should be using the libraries that came with gcc? or doesn't ghc include those?
08:13:57 <SamB> and is this file written in C or C++?
08:14:14 <SamB> if its in C++, you'll need to be remembering your extern "C" { ... } 
08:14:20 <mardy> I used to have similar errors buyt with imports from a c-lib solved that by importing the lib (surpricingly engough :)) but now I get the error with files that I have written myself, feel kinda stuck to be honest
08:14:45 <mardy> E:\PROGRA~1\FA2\Debug\Ko>cat Wrapper.cpp
08:14:45 <mardy> #include "Wrapper.h"
08:14:45 <mardy> #include "Interface.h"
08:14:45 <mardy> C_Interface::C_Interface()
08:14:45 <mardy>         :_interf()
08:14:47 <mardy> {}
08:14:47 <mardy> void C_Interface::C_Interface_Die(){
08:14:51 <mardy>         _interf.~Interface();
08:14:51 <mardy> }
08:14:53 <mardy> int C_Interface::C_Interface_Get(){
08:14:55 <mardy>         return _interf.FetchData();
08:14:57 <mardy> }
08:15:08 <mardy> E:\PROGRA~1\FA2\Debug\Ko>cat Wrapper.h
08:15:08 <mardy> #include "Interface.h"
08:15:08 <mardy> extern "C" {
08:15:08 <mardy>         class C_Interface{
08:15:08 <mardy>         public:
08:15:09 <mardy>                 C_Interface();
08:15:11 <mardy>                 void C_Interface_Die();
08:15:13 <mardy>                 int C_Interface_Get();
08:15:15 <mardy>         private:
08:15:17 <mardy>                 Interface _interf;
08:15:19 <mardy>         };
08:15:21 <mardy> }
08:15:47 <flux__> hmm, I doubt you can 'extern C' methods
08:15:48 <SamB> also, doesn't MSVC use *.obj for its object files?
08:15:48 <SamB> mardy: you'll want to not use a class
08:15:55 <eivuokko> Can't extern "C" C++ like that.
08:16:04 <yaarg> yup ^
08:16:28 <eivuokko> SamB, where are you getting with .obj files?
08:16:38 <SamB> I'm surprised your compiler didn't complain
08:17:02 <SamB> eivuokko: grasping at straws?
08:17:04 <mardy> can't I? I have gotten it to work on smaller programs just like this
08:17:19 <SamB> mardy: well, its not a good idea
08:17:19 <eivuokko> o.O
08:17:28 <eivuokko> Is that documented somewhere...I'd be interested.
08:17:29 <SamB> at the very least, it will confuse people!
08:17:43 <yaarg> yup, i'd say!
08:18:26 <mardy> screw people, I just wanna get it to work :D
08:18:53 <mardy> ah well think I'm gonna go make some food, at least then I'll be stuck on a full stomach
08:19:00 <shapr> mardy: Hey, for anything over five lines it's better to paste on the wiki or paste bot.
08:20:21 <SamB> lisppaste2: help
08:20:22 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:22:34 <ricebowl> @type readDec
08:22:35 <lambdabot> Not in scope: `readDec'
08:22:36 <ricebowl> @type Numeric.readDec
08:22:37 <lambdabot> forall a. (Num a) => ReadS a
08:22:52 <ricebowl> @type ReadS
08:22:52 <lambdabot> Not in scope: data constructor `ReadS'
08:24:20 <ricebowl> ReadS a is a (String, a) isn't it?
08:24:50 <ricebowl> @eval readDec "42 42 fourty-two"
08:24:52 <lambdabot> [(42," 42 fourty-two")]
08:25:03 <ricebowl> ah, excellent.
08:26:46 <ricebowl> @eval read "42 42 fourty-two" :: (Int, Int)
08:26:47 <lambdabot> Prelude.read: no parse
08:37:20 <xinming1983> instance (Eq a) => Eq (Tree a) where ...
08:37:45 <xinming1983> hmm, anyone here can tell me why not use `instance Eq (Tree a) where` ?
08:38:29 <ricebowl> because you have to be able to compare a's
08:38:32 <ricebowl> not just Tree a
08:39:52 <xinming1983> instance Eq Int where also compare 2 Int. :-/
08:40:04 <xinming1983> what does => mean here?
08:40:16 <ricebowl> constraint
08:40:29 <xinming1983> in a class declaration, it is used for "inheritance"
08:40:30 <ricebowl> instance Eq (Tree a) where a is an instance of Eq
08:40:51 <Lemmih> xinming1983: Not really.
08:41:21 <xinming1983> bbl
08:41:24 <ricebowl> is there any function like Numeric.readDec that produces a single tuple instead of a list of tuples?
08:43:52 <xinming> class A a where... to instance A Int where... And `class (A a) => (B b) where...`, And the same instance for class B is. `instance B (Mytype ) where...`
08:44:56 <xinming> instance (B a) => B (Mytype a) where ...
08:45:38 <xinming>  `instance B (Mytype a) where...`  `instance (B a) => B (Mytype a) where` Which is correct?
08:46:01 <Lemmih> They're both correct.
08:47:10 <xinming> So, for `instance B (Mytype a) where...`, this means that B only allows Mytype a right?
08:47:27 <fworp> xinming: depending on how you define the instance, if you apply functions in the B class to a's, then a needs to be constrained with (B a) =>
08:47:50 <Lemmih> No, it means that any (MyType a) is an instances of B.
08:48:09 <xinming> `instance (B a) => B (Mytype a) where` means the type are not only Mytype a, but also the valid type for B
08:49:10 <Lemmih> That means that any (MyType a) is an instance of B if 'a' is an instance of B.
08:49:49 <xinming> Lemmih: for which one?
08:50:06 <xinming> (B a) => B (Mytype a) or only B (Mytype a) ?
08:50:17 <Lemmih> The former.
08:51:16 * xinming thinks he is so witless...
08:51:31 <basti_> that'll pass xinming 
08:51:38 <basti_> you know that far east religion called "zen"?
08:51:41 <basti_> ^^
08:52:37 <xinming> No. I don't the religion called "zen", Just know Buddhism
08:52:43 <basti_> ah
08:52:46 <o_Rocky> @seen sky_
08:52:46 <lambdabot> I haven't seen sky_.
08:52:50 <o_Rocky> @seen ski_
08:52:50 <basti_> well philosophy school
08:52:51 <lambdabot> I saw ski_ leaving #haskell, #haskell-overflow and #haskell-blah 13 hours,
08:52:51 <lambdabot> 17 minutes and 11 seconds ago.
08:52:54 <basti_> thinkers school
08:53:09 <o_Rocky> @seen ski
08:53:09 <lambdabot> ski is in #haskell, #haskell-overflow and #haskell-blah. I don't know
08:53:09 <lambdabot> when ski last spoke.
08:54:50 <xinming> Lemmih:  formor one means any (MyType a) is an instance of B if 'a' is an instance of B. how about the other one?
08:55:20 <xinming> Does that mean, It's an instance of B, no other meaning?
08:55:55 <ricebowl> heh, GHC has been building for like 4 hours :/
08:56:24 <eivuokko> Did you read quick guide to hacking ghc?
08:56:33 <ricebowl> yeah
08:56:40 <ricebowl> I just...didn't follow it ;)
08:56:43 <eivuokko> ;p
08:57:10 <eivuokko> Removing profiled libraries is already a big save in time.
08:57:12 <ricebowl> I couldn't find the bit with suggestions on reducing build times
08:57:16 <ricebowl> *nods*
08:57:26 <ricebowl> my patch for Word64 was rejected :(
08:57:48 <basti_> xinming: ehm.
08:57:52 <o_Rocky> ahahahhaha
08:58:19 <basti_> xinming: take a closer look at these type specifications. they are built of two parts. (constraint) => (type)
08:58:36 <basti_> the constraint says which type may appear
08:58:47 <eivuokko> ricebowl, I see.  Well, there is a point.
08:59:03 <Heffalump> ricebowl: why?
08:59:16 <ricebowl> Heffalump - "these files are autogenerated, and you should fix the conversion instead"
09:00:12 <xinming> basti_: hmm, `instance Myclass (Mytype a) where ` will also constrain the type maybe used in this instance.
09:00:17 <ricebowl> my thought is that something > nothing
09:00:19 <ricebowl> but that's just me
09:00:49 <eivuokko> Maybe it's the primops.txt.pp mentioned in http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
09:00:55 <basti_> xinming: we're talking about two things here. Lets say "instance EQ MyType where"
09:01:00 <ricebowl> I could have a look later
09:01:07 <ricebowl> I sort've have to finish this homework.
09:01:11 <ricebowl> it was...due 2 weeks ago. :D
09:01:20 <Heffalump> ricebowl: ah, that makes sense
09:01:29 <basti_> then we could go like "instance EQ a where", but without any restrictions, "EQ a" doesn't make much sense
09:01:31 <ricebowl> Heffalump - which? His reply?
09:01:46 <ricebowl> s/are/were/, BTW. They don't appear to be part of the build process.
09:02:02 <ricebowl> appear to be generated as part of the build process, rather
09:02:07 <basti_> so we do "instance (Num a) => EQ a" to infer equality from number properties
09:02:19 <basti_> now we again have (constraint) => (Type)
09:02:55 <basti_> unless i'm talking nonsense
09:04:26 <ricebowl> argh.
09:04:58 <ricebowl> could someone help me with parsing? I know there *must* be a function that does the equivalent of atoi() in C. Something with type :: String -> Int or, perferably, :: String -> (String, Int)
09:05:08 <ricebowl> readDec :: String -> [(String, Int)]
09:05:11 <ricebowl> :(
09:05:38 <basti_> "read"?
09:05:43 <eivuokko> > read "12"::Int
09:05:44 <lambdabot> 12
09:05:54 <ricebowl> is there nothing that will give me the remainder?
09:06:03 <ricebowl> because I have this problem:
09:06:11 <ricebowl> > read "42 42" :: (Int, Int) -- an error
09:06:12 <lambdabot>  parse error (possibly incorrect indentation)
09:06:16 <ricebowl> > read "42 42" :: (Int, Int)
09:06:16 <lambdabot> Prelude.read: no parse
09:06:28 <tromp> reads
09:06:46 <basti_> @type reads
09:06:46 <lambdabot> forall a. (Read a) => ReadS a
09:06:59 <ricebowl> > reads "42 fourty-two 42" :: Int
09:06:59 <lambdabot> Couldn't match `Int' against `[(a, String)]'
09:07:00 <xinming> basti_: hmm, so, you mean, the (constraint) => ( Type ) isn't needed really, right?
09:07:01 <ricebowl> er
09:07:02 <basti_> can you demonstrate tromp?
09:07:04 <ricebowl> > reads "42 fourty-two 42" :: ReadS Int
09:07:05 <lambdabot>   Expecting a function type, but found `[(a, String)]'
09:07:05 <lambdabot>   Expected type: ReadS Int
09:07:05 <lambdabot>   Inferred type: [(a, String)]
09:07:12 <basti_> xinming: yes it is needed, for some kind of things.
09:07:17 <basti_> xinming: it's a nice feature.
09:07:24 <ricebowl> oh, but that produces a list. That's the same as readDec :|
09:07:27 <basti_> xinming: sometimes the compiler can even infer for itself
09:07:34 <xinming> basti_: Just like, we could write, instance ( Eq Int ) => ( Eq Int ) where...
09:07:40 <tromp> (i,rest) <- reads "42 42"
09:07:44 <basti_> xinming: we could do that but that is stupid ^^
09:07:52 <basti_> think: + = +
09:07:57 <basti_> = = =  ;)
09:08:25 <basti_> but we could infer a more general property from lower properties though
09:08:41 <ricebowl> tromp - that produces a list
09:08:46 <ricebowl> you can't assign to a tuple like that
09:09:00 <shapr> jiihaa
09:09:03 * shapr boings cheerfully
09:09:20 <shapr> eivuokko: Hey, you got my reply?
09:09:27 <xinming> basti_: thanks. I think I found some clue on your words.
09:09:40 <basti_> xinming: was a pleasure
09:10:15 <eivuokko> shapr, Yeah, I did.  It's cool :)  I am writing reply, but it takes time as I am *a bit* happy that Simon PJ fixed ghc build :)
09:10:23 <shapr> heh, I understand.
09:12:18 <tromp> you can within a list monad
09:12:36 <ricebowl> yes, but I have to be careful about quantity
09:12:57 <tromp> if you just want one parse, you can do
09:13:10 <tromp> let (i,rest) = head $ reads "42 43"
09:13:59 <ricebowl> yes, I know, but I am concerned about error-handling...
09:21:10 <SamB> whats a good way to make slides for Acrobat Reader in LaTeX?
09:22:44 <basti_> SamB: "beamer"
09:24:08 <Lokadin> say could anyone give me a link with maybe a tutorial that has examples? i mean cause i read all these abstractions but i can't get a working program :|
09:24:19 <shapr> @wiki HaskellDemo
09:24:19 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
09:24:28 <Lokadin> thanks :D
09:25:08 <Lokadin> oo bsd licence makes my stomach churn :S
09:25:48 <shapr> Why?
09:27:22 <Lokadin> dono, just does lol, makes me think of big companies stealing candy from little babies and selling it to consumers
09:27:48 <shapr> Well, everybody makes their own choices.
09:28:03 <Lokadin> true some people like s&m
09:28:14 <Lokadin> :D
09:28:18 <Lokadin> lol
09:28:27 <tromp> try prosper, samB
09:28:32 <wearkilts> more likely people in China where it is not particularly illegal stealing it and selling it to consumers--but then they do that with GPL too.
09:29:14 <Lokadin> true, but at least with gpl every now and again the babies big brother can come along and beat the shit out of the company
09:29:23 <wearkilts> nope
09:29:30 <Lokadin> why not? look at cisco
09:29:41 <Lokadin> beat the sources out of them, and quite a few other companies
09:30:05 <wearkilts> to big companies, yes, but I've never heard of a lawsuit over selling GPLed code. In fact, that is legal. You just have to distribute the changes.
09:30:11 <wearkilts> or original source if you don't modify it.
09:30:28 <Lokadin> oh well yeah thats fine of course
09:30:38 <Lokadin> i mean i make money off of that
09:30:51 <wearkilts> the debate revolves entirely around the question of whether it should be legal to *modify* OSS code and not distribute the changes
09:31:03 <Lokadin> yep
09:31:29 <Lokadin> dono just feels more like stealing to me if they don't help and can just keep on taking, honestly just seems like an abusive relationship to me
09:31:39 <wearkilts> perhaps
09:31:43 <Lokadin> *shrugs*
09:31:46 <Lokadin> it's a matter of opinion
09:31:50 <wearkilts> of course
09:32:08 <Lokadin> :) kk well i'll get back to reading that demo :D thanks for it btw :D
09:32:37 <shapr> sure
09:33:25 * wearkilts continues writing code in CPS for fun
09:33:40 * wearkilts also notes how imperative-style this feels
09:34:48 <Lokadin> say, but there is no main decleration
09:35:19 <Lokadin> i meant as in, if there is an example of fully working classes
09:36:15 <shapr> You mean Object Oriented classes? Or what?
09:36:33 <shapr> Parlez vous français?
09:36:33 <Lokadin> no, well i mean like say an example of a .hs file, that i can compile and run
09:37:00 <Lokadin> so i could understand it's structure, i mean i have no idea how it's supposed to work
09:37:16 <Lokadin> i know the hello world example, main = print("hello world")
09:37:22 <Lokadin> but i can't do much with that
09:37:26 <shapr> Peut-etre Québécois? :-)
09:37:44 <Lokadin> er you got some wierd characters there
09:37:47 <shapr> The HaskellDemo should compile and run.
09:37:50 <shapr> Yeah, I'm using UTF-8.
09:37:53 <Lokadin> really/
09:37:54 <Lokadin> oh okay
09:38:27 <Lokadin> non, je ne parlai pas francais
09:38:39 <wearkilts> s/parlai/parle/
09:38:41 <shapr> quel dommage
09:38:41 <wearkilts> I think.
09:38:43 <samc> yeah that's just shapr he's a weird character 
09:38:46 <shapr> haha
09:38:51 <wearkilts> I don't speak French, either
09:38:53 <shapr> Hey samc, how's life?
09:39:04 <shapr> Talar du svenska?
09:39:08 <wearkilts> japp
09:39:14 <wearkilts> men bara lite
09:39:16 <shapr> roligt :-)
09:39:17 <wearkilts> ;)
09:39:22 <samc> life, don't talk to me about life
09:39:31 <wearkilts> mer spanska :an svenska...
09:39:42 * wearkilts kan inte skriva a med umlaut
09:39:44 <shapr> ¿Hola, como est as?
09:39:49 <wearkilts> estoy bien gracias
09:39:52 <wearkilts> y vos? :p
09:40:17 <xinming> basti_: Does class still obey the rule of (constraints) => (type) ? or, It is just defining another new class ?
09:40:32 <shapr> Jag använder emacs, och det har x-symbol. Med x-symbol man kan tryck C-= a " för att skapa ä.
09:40:32 <wearkilts> en donde aprendiste espa~nol?
09:40:41 <wearkilts> ah
09:40:58 * wearkilts forgets the word for "should"
09:41:01 <wearkilts> starts with a 'd' IIRC.
09:41:08 <shapr> In which language?
09:41:13 <basti_> xinming: hmm. I don't know offhand if you can do that in class declarations at all. or what it means for that reason
09:41:14 <wearkilts> svenska klar
09:41:27 <shapr> börde
09:41:31 <neologism> anyone from .se/.fi ?
09:41:41 <Lokadin> shapr: do you know how to enable utf-8 in gnome-terminal?
09:41:43 <shapr> I live in Sweden, but I'm from Alabama.
09:41:50 <wearkilts> ah right b:orde
09:41:53 <Lokadin> shapr: and you speak french?
09:41:59 <wearkilts> I confuse it with Spanish deber
09:42:29 <Lokadin> shapr: where did you learn it?
09:42:30 <xinming> basti_: thanks, I think It is much clearer to me now.
09:42:32 <shapr> Lokadin: I have LOCALE=en_US.UTF-8 I think that's part of it.
09:42:38 <basti_> xinming: :)
09:42:39 <Lokadin> o
09:42:40 <Lokadin> kk thanks
09:42:42 <Lokadin> brb
09:42:43 <shapr> I learned French in college. I learned Swedish in Sweden.
09:42:45 <wearkilts> Lokadin - probably in Sweden? ;)
09:43:00 <Lokadin> they speak french in sweden?
09:43:04 <Lokadin> kk
09:43:04 <wearkilts> haha
09:43:08 <Lokadin> lol
09:43:11 <Lokadin> alright
09:43:32 <shapr> My girlfriend speaks more French than I do.
09:43:35 <Lokadin> strange language to learn, french, i mean the majority of the french in the world are big racists and not many people like them
09:43:39 <Lokadin> o
09:43:45 <Lokadin> i mean french majorities
09:43:47 <Lokadin> not poeple
09:43:55 <shapr> Every culture has its stereotypes. I know some really wonderful French people.
09:44:05 <mwc> Oh christ
09:44:08 <wearkilts> I know some wonderful French people, too. But none from Paris. ;)
09:44:10 <mwc> I have an assignment due 1:30
09:44:12 <basti_> i know a french girl with a wonderful body...
09:44:13 <wearkilts> actually that's not true
09:44:16 <mwc> I was working until 5 am
09:44:18 <Lokadin> well i'm not saying anything againnst people, just the majorities *shrugs*
09:44:18 <mwc> fell asleep
09:44:24 <mwc> just wokke up at 12:30
09:44:28 <mwc> damn damn damn
09:45:08 <Lokadin> like in quebec they hate english speaking people and will try to rip you off if you don't speak proper french, in france it's more or less the same storry, and in swizterland, well they just hate everyone that isn't paying them money
09:45:23 <wearkilts> the stereotype of Spanish-speakers (from any country including Spain) is that they're impatient. And I think it's true.
09:45:36 <wearkilts> bastards will get pissed off if you stop to think in order to formulate a reply
09:45:40 <Lokadin> dono, haven't met any spanish speaking people
09:45:57 <wearkilts> lol, France can't be so terrible
09:46:07 * wearkilts loves all the latinos
09:46:09 <Lokadin> $12 hotdogs
09:46:13 <wearkilts> it's fun even though they're impatient as fsck
09:46:13 <Lokadin> for tourists
09:47:08 <Lokadin> don't go to russia if you expect to get back alive and with your pants on!
09:47:17 <Lokadin> as a tourist anyways
09:47:20 <wearkilts> haha
09:47:32 <wearkilts> that can't be true of Moscow; I know people who have visited
09:47:39 <wearkilts> a friend of mine went with his parents and interpreted for them
09:47:54 <Lokadin> as do I, i mean i went there
09:48:03 <Lokadin> *shrugs* the corruption there is absolutely insane
09:48:13 <wearkilts> I'm sure, I've heard some of it
09:48:19 <samc> so you just lost your pants then?
09:48:21 <wearkilts> haha
09:48:30 <Lokadin> i mean the one law in the country is that laws are made to be broken with bribes
09:48:46 <neologism> I know that situation ;)
09:48:46 <wearkilts> Latin-America is the same way, you know :p
09:48:56 <neologism> russia is not that bad
09:49:14 <neologism> I dated a girl from belarus.. and thats tough ;)
09:49:17 <Lokadin> *shrugS* i guess if you compare it to some other parts of the world
09:49:33 <Lokadin> my gf is from russia :P don't see why it would be tough
09:49:46 <neologism> I mean that belarus is tough
09:49:52 <neologism> compared to russia ;)
09:49:56 <Lokadin> though i did have belarussian managers at some point, though i'm certain the wife was a skitzo so never thought to generalize
09:49:57 <Frederick> yo folks
09:50:00 <Lokadin> o
09:50:11 <neologism> what is it "skitzo" ?
09:50:22 <Lokadin> schizophreniac
09:50:37 <Lokadin> there are lots of different kinds of schizophrenia
09:51:00 <Lokadin> actually i'm not sure if she was that, i mean but she definatly had a serious anger managment issue
09:51:09 <neologism> ;)
09:51:20 <wearkilts> haha
09:51:28 <Lokadin> some lawyer tried sueing her for abusing the workers
09:51:44 <Lokadin> just cause he noticed it in passing by
09:51:56 <Lokadin> don't know what came of that
09:52:06 <wearkilts> my friend from Russia said that everyone who lives in the Balkan area is hot-tempered ;) Really, I think it's most of that area of the world, and it's just a cultural thing or something. :p
09:52:11 <Frederick> Lokadin, can I get a summer job at your departament?
09:52:42 <Lokadin> Frederick: ? you a masochist
09:52:54 <neologism> wearkilts: everyone from the south is strange ;)
09:52:55 <Frederick> Lokadin, I get a summer job sue the firm and never work again
09:52:59 <neologism> manana ;)
09:53:02 <Lokadin> lol
09:53:25 <Lokadin> Frederick: :P well i'd do the same, unfortunatly it isn't a firm, it's a part time job i had a while back, at a rock climbing gym
09:53:43 <Frederick> Lokadin, are there cute girls around?
09:53:59 <ricebowl> I have an off-topic question ;)
09:54:06 <xerox> Heh.
09:54:06 <Lokadin> dono, there are a lot more at my university, it's 70% female population, and all the ugly ones drop out :S
09:54:07 <ricebowl> is there anything similar to Monad.mapM but for tuples?
09:54:10 <Lokadin> it's soo strange
09:54:22 <xerox> @hoogle mapM
09:54:23 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:54:23 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:54:23 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
09:54:28 <Frederick> Lokadin, so it is like a playboy college?
09:54:30 <xerox> ricebowl: in what sense?
09:54:33 <ricebowl> @type Monad.mapM
09:54:34 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
09:54:42 * Frederick runs scared of the maps
09:54:49 <ricebowl> I want :: (m a, m b) -> m (a, b)
09:55:04 <xerox> @type sequence
09:55:05 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
09:55:09 * Frederick hands ricebowl m (a, b)
09:55:21 <Lokadin> Frederick: well i'm in canada so it's a university, but something like that, most of the guys i talk to can't get work done on campus because they are just staring all around, first year you know
09:55:43 <xerox> @type \(x,y) -> sequence [x,y]
09:55:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a, m a) -> m [a]
09:55:52 <Frederick> Lokadin, I have the amazing plan of sending my self via Fedex to a civilized country
09:55:53 <xerox> Hmm.
09:56:25 <Lokadin> Frederick: where are you?
09:56:55 <ricebowl> I've done something similar before, but I can't remember how I did it.
09:56:59 <Frederick> Lokadin, Brazil
09:57:06 <xerox> @type \(x,y) -> do { x' <- x; y' <- y; return (x',y') }
09:57:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a, m b) -> m (a, b)
09:57:10 <xerox> @pl \(x,y) -> do { x' <- x; y' <- y; return (x',y') }
09:57:11 <lambdabot> (line 1, column 14):
09:57:11 <lambdabot> unexpected "{"
09:57:11 <lambdabot> expecting variable, "(", operator or end of input
09:57:12 <Lokadin> Frederick: i have an aunt there, that's five years younger than me
09:57:39 <xerox> @pl \(x,y) -> x >>= \x' -> y >>= \y' -> return (x',y')
09:57:40 <lambdabot> uncurry (liftM2 (,))
09:57:43 <xerox> Ta-da.
09:57:47 <ricebowl> nifty
09:57:55 <xerox> :-)
09:58:01 <ricebowl> oh! That's right!
09:58:04 <ricebowl> it was liftM2 (,)
09:58:12 <xerox> Good.
09:58:33 <ricebowl> awesome, thanks
09:58:52 <xerox> You're welcome :-)
09:58:55 <ricebowl> does @pl try to map a function into some canoncial form?
09:59:57 <eivuokko> It removes variables, so that you can express the function composition without lambda.
10:00:30 <mwc> It sounds like masochism
10:00:34 <xerox> ricebowl: it translates the given function to a points-free form
10:00:46 <xerox> mwc: sometimes it actually produces nice code.
10:00:59 <mwc> I'm sure it does, I'm just not that cool
10:01:03 <ricebowl> what does "points-free" mean?
10:01:13 <mwc> ricebowl: I prefer to call it "pointless" style :P
10:01:14 <xerox> ricebowl: without points, i.e. named arguments.
10:01:19 <xerox> mwc: watch out:
10:01:22 <ricebowl> ah
10:01:27 <xerox> @pl \f xs -> xs >>= return . f
10:01:27 <lambdabot> fmap
10:01:47 <xerox> @pl \f g x -> f (g x)
10:01:48 <lambdabot> (.)
10:01:51 <mwc> yeah, my understanding of points free style is that you can write: stringToLower str = map toLower str as stringToLower = map toLower
10:01:53 <xerox> @pl \f g x y -> f (g x y)
10:01:54 <lambdabot> (.) . (.)
10:01:59 <xerox> @pl \f g x y z -> f (g x y z)
10:01:59 <ricebowl> that's pretty cool
10:01:59 <lambdabot> (.) . (.) . (.)
10:02:03 <xerox> ;-)
10:02:28 <xerox> @pl \x y -> x >>= \x' -> y >>= \y' -> return (x',y')
10:02:29 <lambdabot> liftM2 (,)
10:02:32 <xerox> (heh)
10:04:21 <xerox> @pl \f x y -> f y x
10:04:21 <lambdabot> flip
10:04:32 <xerox> @pl \f x -> f x x
10:04:33 <lambdabot> join
10:04:42 <ricebowl> > let parsedec f x s = f (x, Just 0) s in parsedec (parsedec (\x y -> (y, x))) () "abc def ghi"
10:04:43 <lambdabot> ("abc def ghi",(((),Just 0),Just 0))
10:04:57 <ricebowl> :/ must be my function then
10:05:14 <xerox> @pl \f x -> f (f x)
10:05:14 <lambdabot> join (.)
10:05:17 <xerox> ;-)
10:05:31 <fworp>  @pl \f x y z a -> a (x (z (y a)))
10:05:54 <xerox> Remove the first whitespace
10:06:35 <xinming> @pl \f x y z a -> a (x (z (y a)))
10:06:35 <lambdabot> const (((ap id .) .) . (. flip (.)) . (.) . (.))
10:06:49 * xerox censures the last output
10:06:53 * SamB waits for beamer to finish downloading
10:07:02 <basti_> SamB: :D
10:07:11 * fworp didnt notice that first whitespace
10:07:54 <xinming> It's really a pain if anyone wish to understand the the '@pl'ed lambda....
10:08:55 <xerox> @pl \x -> \y -> x
10:08:55 <lambdabot> const
10:09:27 <SamB> fworp: why didn't you use "f" in that?
10:09:46 <fworp> i have no idea, i was just typing something convoluted out
10:10:02 <fworp> see how much line noise i could get @pl to make
10:10:24 <basti_> i recently asked it to pl a part of mergesort
10:10:41 <xerox> @pl \a b c -> (a b c, a c b, b a c, b c a, c a b, c b a)
10:10:43 <lambdabot> ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) .
10:10:43 <lambdabot> liftM2 ap (liftM2 (,,,,,) .) flip) (flip id)) (flip flip)) (flip . flip
10:10:43 <lambdabot> id)) (flip (flip . flip id))
10:10:45 <xerox> ;-)
10:11:06 <xerox> I'm not even sure about the type of that thing.
10:11:09 <xerox> @type \a b c -> (a b c, a c b, b a c, b c a, c a b, c b a)
10:11:11 <lambdabot>   Occurs check: cannot construct the infinite type:
10:11:11 <lambdabot>   t = (t -> t1 -> c) -> (t -> t1 -> c) -> a
10:11:15 <xerox> Heh.
10:12:05 <basti_> @pl merge = \(ha:ta) (hb:tb) -> if (ha<hb) then ha:merge ta (hb:tb) else hb:merge (ha:ta) tb
10:12:28 <SamB> @type ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) . liftM2 ap (liftM2 (,,,,,) .) flip) (flip id)) (flip flip)) (flip . flip id)) (flip (flip . flip id))
10:12:28 * basti_ looks on his watch
10:12:31 <lambdabot> merge = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .)
10:12:31 <lambdabot> . flip flip head . ((flip . ((.) .)) .) . ap (ap . (liftM2 (liftM2 ap) .)
10:12:31 <lambdabot> . ap ((.) . ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (.) . (:)) .
10:12:31 <lambdabot> flip flip (:) . (((.) . (.)) .)) (((flip ((.) . (:)) .) .) . (. (:)) . (.)
10:12:31 <lambdabot> ))
10:12:32 <lambdabot> optimization suspended, use @pl-resume to continue.
10:12:34 <lambdabot> Not in scope: `ap'
10:12:37 <lambdabot>  
10:12:38 <lambdabot> <interactive>:1:4: Not in scope: `ap'
10:12:39 <basti_> lol
10:12:43 <basti_> @pl-resume
10:12:48 <lambdabot> merge = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .)
10:12:48 <lambdabot> . flip flip head . ((flip . ((.) .)) .) . ap (ap . (liftM2 (liftM2 ap) .)
10:12:48 <lambdabot> . ap ((.) . ap . (((.) . if') .) . (<)) . flip ((.) . (.) . (.) . (:)) .
10:12:50 <basti_> lets see what that gets
10:12:50 <lambdabot> flip flip (:) . (((.) . (.)) .)) (((flip ((.) . (:)) .) .) . (. (:)) . (.)
10:12:52 <lambdabot> ))
10:12:58 <basti_> is that good or isnt it? ^^
10:15:11 <Lokadin> anyone know if there is haskell syntax highlighting for vim?
10:15:47 <fworp> yeah, there is
10:15:58 <Lokadin> fworp: know where or how to get it?
10:16:16 <fworp> i think its in the ghc source tree, lemme look
10:17:02 <Frederick> yo, SamB 
10:17:19 <Lokadin> fworp: kk :D thanks
10:17:56 <Frederick> SamB, gimme a piece of advice what is easier to do on my work. Implement the freaking greibach's normal form algorithm, or CYK (dinamic programming algorithm)
10:19:33 <SamB> Frederick: hmm.
10:19:39 <SamB> let me look at that page again a sec
10:20:10 <fworp> @google haskell vim
10:20:21 <lambdabot> http://urchin.earth.li/~ian/vim/haskell.vim
10:20:26 <fworp> there ya go
10:20:33 <fworp> (its kind of old though)
10:22:18 <SamB> Frederick: it probably isn't too hard to turn that (CYK) into a functional algorithm
10:22:58 <Frederick> SamB, but can I create a matrix I can acces given fields?
10:23:20 <SamB> Frederick: what page are you using for reference?
10:23:31 <basti_> @where conjure
10:23:31 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
10:23:38 <SamB> or are you using a book?
10:23:54 <SamB> anyway, you'll probably want to use UArray Int Bool for that
10:23:57 <Frederick> SamB, Im using web/books, but my haskell book sucks
10:24:06 <SamB> er, maybe not UArray.
10:24:12 <SamB> no. not UArray.
10:24:35 <SamB> you'll want to use Array for everything...
10:24:58 <xinming> hmm, what's conjure really. :-/
10:24:59 <Lokadin> fworp: thanks :D
10:25:24 <SamB> let me start over.
10:25:27 <fworp> no problem
10:26:25 <SamB> you'll probably want to translate the grammar into CNF Char Int
10:27:20 <basti_> @where fps
10:27:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:28:15 <SamB> then you make an Array (Int,Int,Int) Bool using a circular version of the algorithm
10:28:37 <Frederick> SamB, Im googling for a done version :p
10:28:59 <SamB> done version?
10:29:12 <SamB> Frederick: whats your latest code?
10:29:28 <Frederick> SamB, the teacher says it is THE BEST algorithm and stuff someone in the world must have already implemented that
10:29:46 <Frederick> SamB, the one we were using yesterday I had class untill now
10:30:02 <SamB> Frederick: this actually looks like a lot of fun!
10:30:12 <Frederick> SamB, what?
10:30:42 <SamB> Frederick: did you merge my cfgToCnf function into the rest of the code?
10:30:53 <Frederick> SamB, nope
10:31:14 <Frederick> SamB, I will read and understand before merging
10:31:18 <Frederick> to avoid troubles
10:31:56 <SamB> Frederick: basicly the only thing of importance to know is that in that file I simplified CFG a little
10:31:59 <ricebowl> @where pastebin
10:31:59 <lambdabot> I know nothing about pastebin.
10:32:04 * basti_ builds conjure
10:32:04 <ricebowl> mm...
10:32:39 <astrolabe> @paste
10:32:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:32:45 <Frederick> SamB, ive just found a great paper on the web unfortunatelly it is kinda late =/
10:32:50 <SamB> so instead of having a record constructor with four fields, its just an ordinary constructor with the root and then a map
10:32:58 <SamB> ricebowl: try this
10:33:03 <SamB> lisppaste2: help
10:33:29 <ricebowl> well, that's ok
10:33:30 <SamB> Frederick: late?
10:33:37 <ricebowl> http://www.rafb.net/paste/results/16Yxwg59.html <-- I'm trying to figure out why this code doesn't work
10:33:48 <ricebowl> *Main> parsepair "42 42 foo"
10:33:48 <ricebowl> ("*** Exception: <<loop>>
10:34:06 <ricebowl> but if I evaluate s, i1, and i2 by myself, then it works fine
10:34:19 <ricebowl> rather, the expression "parsedec (parsedec (\x y -> (y, x))) () s" does not cause an exception
10:34:43 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:35:28 <Lokadin> can anyone point give me a file with factorial? i mean that you can compile and run?
10:35:54 <astrolabe> ricebowl: You have parsepair s = (s,...)
10:36:19 <astrolabe> That is recursive, in a bad way.
10:36:39 <astrolabe> Ooops sorry.  Ignore me.
10:36:48 <Lemmih> ricebowl: isdigit = Char.isDigit, digval = Char.digitToInt
10:37:52 <Lemmih> ricebowl: 'parsepair' is doing some nasty shadowing.
10:38:08 <ricebowl> Lemmih - I did not know about those; thanks
10:38:35 <shapr> Isn't factorial just take n $ scanl1 (*) [1..] ?
10:38:38 <xinming> hmm, fun x y z = x + y + z, since plus x y = x + y, the plus can be written in 1 `plus` 2, how about fun?
10:38:54 <shapr> xinming: I'd write it 'sum'
10:38:59 <xinming> oops. sorry, I should try it myself.
10:39:07 <xinming> shapr: I am asking grammar. ;-)
10:39:11 <shapr> oh
10:39:39 <shapr> Lokadin: The first factorial definition that comes to mind is: take n $  scanl1 (*) [1..]
10:39:42 <Lemmih> > let fun a b c = a + b + c in (10 `fun` 20) 30
10:39:43 <lambdabot> 60
10:40:30 <xinming> make it a partial application. :-P
10:40:35 <astrolabe> @eval product [1..6]
10:40:36 <lambdabot> 720
10:40:36 <xerox> fact n = prod [1..n]
10:40:42 <shapr> xerox: Oh right.
10:40:43 <Lemmih> ricebowl: 'parsepair' doesn't use its argument 's'.
10:40:55 <ricebowl> oh, d'oh
10:41:00 <ricebowl> thanks, I see the problem now
10:41:10 <shapr> Lokadin: Sorry, I've been writing too much Python recently. xerox came up with: fact n = prod [1..n] 
10:41:17 <ricebowl> this is really bad: (s, ((_, i1), i2)) = parsedec (parsedec (\x y -> (y, x))) () s
10:41:30 <xerox> @pl \n -> prod [1..n]
10:41:30 <lambdabot> prod . enumFromTo 1
10:41:34 <ricebowl> well, maybe not, I don't know, but that's obviously a bug
10:41:34 <xerox> Heh.
10:41:53 <Lokadin> shapr: well no, i want a file where it works, i can make factorial, just i want say so it will print the answer for factorial five, i  have no idea how to makea  compilable running program
10:41:58 <astrolabe> ricebowl:  I thought it must be something really clever :)
10:42:06 <ricebowl> cool, thanks, it works now
10:42:22 <xinming> > read "True"
10:42:23 <lambdabot> Add a type signature
10:42:25 <ricebowl> astrolabe - nope, just an egregious mistake :p
10:42:34 <xerox> > read "True" :: Bool
10:42:35 <lambdabot> True
10:42:52 <xerox> > (read :: String -> Bool) "True"
10:42:53 <lambdabot> True
10:43:11 <astrolabe> Lokadin: you need to define main
10:43:27 <Lokadin> astrolabe: but how? i mean there are no howtos on the matter
10:43:47 <xerox> It's quite simple.
10:43:56 <Lokadin> lol that's not helping me at all lol :P how do you do it?
10:44:09 <xerox> main = print (fact n)
10:44:09 <xerox> fact n = prod [1..n]
10:44:28 <Lokadin> oh okoay :D thanks
10:44:43 <xerox> (Put those lines in a File.hs and run ghc --make File.hs, then ./a.out)
10:45:09 <SamB> hmm, interesting. beamers tutorial covers feature requests!
10:45:15 <Lokadin> xerox: :( says variable not in scope, fac and print
10:45:16 <xerox> main is of type IO () (or IO a if you really want), so it can actually start a computation.
10:45:34 <xerox> @index print
10:45:34 <lambdabot> System.IO, Prelude
10:45:37 <Lokadin> i mean prod and n :S
10:45:43 <Lokadin> oops nm
10:45:47 <Lokadin> i'm just silly
10:45:58 <xerox> I didn't think you have to 'import System.IO' to use print, but whatever.  And it is 'fact' not 'fac', too.
10:46:04 <xerox> Okay.
10:46:11 <xerox> @index prod
10:46:11 <lambdabot> bzzt
10:46:17 <xerox> Heh.
10:46:27 <Lokadin> k well now i fixed it, but it still complains that prod is not in scope
10:46:35 <astrolabe> product
10:46:58 <Lokadin> so do i have to define that as well? prod x = x * xs ? or...
10:47:08 <Lokadin> *runs around in circles*
10:47:14 <astrolabe> Lokadin: use product instead of prod
10:47:34 <Lokadin> oh okay
10:47:51 <Lokadin> astrolabe: *hugs*!! :D yay it worked
10:48:02 <astrolabe> hooray!
10:48:03 <shapr> Lokadin: http://www.scannedinavian.org/~shae/ProtoFac.hs
10:48:27 <shapr> Lokadin: You can build a real binary with that file.
10:48:33 <Lokadin> shapr: thanks ! :D 
10:48:40 <shapr> I also used parens instead of $ for newbie friendliness.
10:49:01 <Lokadin> :D, thanks, well now i have to run to school so c u all in about an hour :D
10:49:03 <xerox> @karma+ astrolabe
10:49:03 <xerox> Yo-hoo, lambdabot...
10:49:04 <lambdabot> astrolabe's karma raised to 2.
10:49:53 <astrolabe> Wow, what does a karma 2 person come back as next time around?
10:50:20 <basti_> he can't be reduced to normal form.
10:50:24 <basti_> (= nirvana)
10:50:39 <astrolabe> Excellent.
10:55:40 <Frederick> SamB, if I had found it before it would be more usefull
11:14:13 <ricebowl> @pl \f s x = let (s', y) = f s in (s', (x, y))
11:14:13 <lambdabot> (line 1, column 8):
11:14:13 <lambdabot> unexpected "="
11:14:13 <lambdabot> expecting pattern or "->"
11:14:23 <ricebowl> @pl \f s x = let (s', y) in f s in (s', (x, y))
11:14:23 <lambdabot> (line 1, column 8):
11:14:23 <lambdabot> unexpected "="
11:14:23 <lambdabot> expecting pattern or "->"
11:14:26 <ricebowl> er
11:14:39 <ricebowl> @pl \f s x -> let (s', y) = f s in (s', (x, y))
11:14:39 <lambdabot> (line 1, column 15):
11:14:39 <lambdabot> unexpected "("
11:14:39 <lambdabot> expecting natural, identifier or "in"
11:28:41 <Lokadin> ? no conversation seems to be occuring, is very strange
11:28:53 <ricebowl> no it's not :p
11:29:29 <Lokadin> really? i dono, i guess i joined the room yesterday, and the conversation seemed more or less constant till at least 40 min ago
11:33:03 <wearkilts> sometimes, sometimes not
11:35:45 <kombinator> hi musasabi_
11:36:13 <kombinator> how far did you get with your AG gui?
11:38:38 <Frederick> SamB, is there any good tutorial about arrays arounf the ones Ive found are quite superficial =/
11:39:47 <kombinator> kombinator hi musasabi_
11:39:47 <kombinator> kombinator how far did you get with your AG gui?
11:46:00 <ricebowl> @hoogle (b -> c) -> (a, b) -> (a, c)
11:46:01 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
11:46:01 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
12:01:04 <mwc> I'm having problems with profiling, I'm compiling with ghc --make -O2 -prof -auto-all -o waver Main.hs after deleting the .hi and .o files from the last run
12:01:23 <mwc> then running the program with -p produces an empty .prof file
12:01:32 <mwc> I'd expect to see at least a header in there
12:04:55 <mwc> any suggestions?
12:06:02 <Taral> Did you include +RTS?
12:06:16 <mwc_> Hmm, no, do I pass that to the compiler or the program?
12:06:24 <Taral> program: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
12:06:30 <mwc_> yeah, rading that
12:06:34 <mwc_> thought I only needed -p
12:06:39 <Taral> ./Main +RTS -p
12:07:06 <Taral> -p is for the runtime, not your program :)
12:09:37 <shapr> coi Taral
12:10:14 <Taral> coi shapr.
12:10:51 <mwc__> I didn't see the part in the docs where it said to put them between +/-RTS
12:11:08 <Taral> might not be clear, sorry.
12:11:43 <mwc__> Yeah, no biggy
12:12:00 <mwc__> Now I'm trying to get this {- SCC "name" -} pragma working
12:12:16 <Taral> {-#
12:12:35 <mwc__> yeah
12:12:44 <mwc__> can you tell I slept 4 hours?
12:12:45 <Taral> It should Just Work (tm).
12:12:46 <Taral> :)
12:12:55 <Taral> Heh, I slept about 5 myself.
12:21:54 <xinming> Is there a eval function eval the "string" ?
12:22:04 <Taral> ?
12:22:06 <Taral> in Haskell?
12:22:10 <Taral> an eval function?
12:22:13 <Taral> Um, no.
12:22:18 <Taral> No, no.
12:22:56 <basti_> there is this thing in hs-plugins iirc
12:22:59 <vegai> @eval 1+1
12:23:00 <lambdabot> 2
12:23:02 <vegai> witchcraft!
12:23:20 <Lemmih> hs-plugins uses GHC to compile the expressions.
12:23:54 <vegai> more or less what I implied
12:26:01 <xinming> basti_: Can the eval generate a function on the fly?
12:26:45 <basti_> xinming: yes.
12:26:52 <basti_> xinming: you can do so, too, though.
12:27:30 <xinming> hmm, It's said, haskell is a static language... If It can do this, Will it become dynamic?
12:28:01 <basti_> uhm no its still statically -typed-
12:28:19 <basti_> have you ever encountered a type error in a running program?
12:28:23 <Cale> Haskell has dynamic typing too, though it's not very convenient.
12:28:30 <Cale> (well, GHC has it)
12:28:47 <Cale> but even that is type safe
12:29:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
12:29:09 <xinming> basti_: yes, I did, I think I understand now
12:29:43 <basti_> you did have a type error in a -running- haskell program?
12:30:39 <nuffer> what does a $ mean?
12:30:52 <basti_> its just a replacement for parenthenses
12:30:52 <xinming> by the way, `data Mytype = Constructor ... | Mytype :+: Mytype | Mytype :-: Mytype
12:30:58 <basti_> a $ b c === a (b c)
12:31:04 <basti_> xinming: yes.
12:31:16 <xinming> hmm, can the infix :+: and :-: be written in other form?
12:31:24 <xinming> still use (+) in the front?
12:31:31 <basti_> like how?
12:31:50 <mwc__> xinming: `(:+:)` ?
12:31:51 <mwc__> :P
12:32:31 <xinming> basti_ you did have a type error in a -running- haskell program? No, I don't, Sorry, I misunderstood what you mean. I thought that you ask me if I can see type error while running my test. :-)
12:32:43 <nuffer> okay
12:33:04 <xinming> :+: here is the Constructor, and :+: is for infix,
12:33:14 <basti_> xinming: yes. so, this is type-safety ^^
12:33:23 <xinming> and Function can be written in infix form, `Add`
12:33:27 <basti_> ahh
12:33:32 <basti_> but constructors are different
12:33:38 <basti_> : constructors are all infix
12:33:41 <xinming> But for + and -, We have to add : :
12:33:44 <basti_> by convention
12:33:51 <basti_> and no others are
12:34:15 <basti_> every constructor is prefix except for the ones with a : as the first char
12:34:21 <basti_> > 5:6:[]
12:34:22 <lambdabot> [5,6]
12:34:43 <xinming> basti_: that's what I want to know, If we can write :+: as prefix
12:34:52 <xinming> hmm, using another form
12:35:04 <xinming> for function call, (+) 3 4 can be used,
12:35:12 <basti_> yes
12:35:14 <basti_> (:+:)
12:35:24 <basti_> > (:) 4 []
12:35:25 <lambdabot> [4]
12:35:35 <xinming> Ok, I think I understand. :-)
12:35:52 <Lokadin_> yay1 :D
12:36:23 * basti_ lights a bonfire
12:36:56 * Lokadin_ roasts some gyros
12:37:36 * xinming is doing some baked mutton
12:38:29 <Lokadin_> :D:P lol, insanity is the eyes of the beholder
12:38:50 <basti_> yes
12:38:52 <basti_> certainly
12:39:47 <HeverClever> What are people using to code Haskell stuff? Visual Haskell, the Funcional Eclipse plugin, Emacs, vi, other?
12:40:07 <Lokadin_> i'm using vim
12:40:08 <mwc__> Hey, Cale, you around?
12:40:13 <Cale> yeah?
12:40:27 <mwc__> I've found the huge sink of time by inserting profiling all over
12:40:58 <mwc__> Cale: 92.9% of the execution time is in here:
12:41:02 <mwc__> formattedData = {-# SCC "Finalizing Output" #-} dataLines `seq` foldl (\s r -> s ++ "\n" ++ r) "" dataLines
12:41:08 <Cale> yeah, that looks likely
12:41:17 <mwc__> wow, really?
12:41:19 <Cale> ++ is expensive if nested like that
12:41:21 <mwc__> Looks innocent to me
12:41:24 <mwc__> Ahhh
12:41:27 <Cale> very expensive
12:41:39 <mwc__> right, it's a linear time operator on the length of the first array, isn't it
12:41:47 <basti_> HeverClever: emacs
12:43:05 <mwc__> Cale: probably would be smarter to recursively write the strings to the file, I'll do that
12:43:15 <Cale> use shows
12:44:50 <Cale> or yeah, mapM printLine dataLines
12:51:22 <MarcWeber> What is a polymorphic type `forall b. b' ? I'm trying to write some random functions and I don't understand the compiler error message (http://www.rafb.net/paste/results/sU6tG885.html)
12:51:26 <ricebowl> CPS owns :D
12:55:03 <eivuokko> Marc, a :: b <- what kind of type annotation you are doing?  b is not type in sight, but it is variable in where.
12:55:15 <eivuokko> Maybe you meant a:b
12:55:17 <Cale> MarcWeber: there aren't many values of type forall b. b
12:55:17 <mwc__> Cale: replacing ++ with `shows` didn't help too much
12:55:24 <Cale> mwc__: hmm
12:55:34 <mwc__> using mapM (hPutStrLn fh) dataLines is blazing fast
12:56:09 <Lemmih> mwc__: You should replace '++' with '.'.
12:57:13 <MarcWeber> Oh.. I wanted to concatenate a and b.. I should have used ++
12:57:24 <mwc__> (.) :: String -> String -> String?
12:57:28 <mwc__> I thought it was function comp.
12:57:34 <basti_> @type (.)
12:57:35 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
12:57:41 <basti_> @type (++)
12:57:42 <lambdabot> forall a. [a] -> [a] -> [a]
12:57:51 <Lemmih> @type (.) :: ShowS -> ShowS -> ShowS
12:57:52 <lambdabot> ShowS -> ShowS -> ShowS :: ShowS -> ShowS -> ShowS
12:57:52 <basti_> > "hi" ++ " " ++ "mwc__"
12:57:53 <lambdabot> "hi mwc__"
12:57:58 <basti_> oh
12:58:13 * basti_ blushes
12:58:44 <Lemmih> > showString "hello" . showChar '\n' . showString "world" $ ""
12:58:45 <lambdabot> "hello\nworld"
12:58:55 <ricebowl> man my keyboard likes to use any mapping *except* English :/
12:59:11 <mwc__> Good, now I've tracked down this performance suck. Woot for profiling
12:59:23 <ricebowl> good day, basti_ :D
12:59:28 <mwc__> Now most of my time is spent converting numbers to text
13:00:19 <ricebowl> shouldn't that be extrodinarily fast in Haskell, relative to other operations?
13:00:26 <ricebowl> faster than in C, at least
13:01:05 <mwc__> nah, I was doing a relatively simple interative solution for a wave-equation
13:01:06 <vegai> ...how come?
13:01:10 <mwc__> so the math is simple
13:01:27 <ricebowl> because you naturally build the list backward.
13:01:40 <ricebowl> in C you require an extra O(n) flip
13:01:51 <ricebowl> which is very painful.
13:02:10 <Lemmih> You could just use a linked link in C....
13:02:23 <Lemmih> *linked list.
13:02:28 <ricebowl> you could
13:02:31 <ricebowl> which would be even slower ;)
13:02:46 <ricebowl> I was speaking of *relative* performance
13:02:49 <Cale> um, O(n) flip?
13:03:06 <Cale> You don't need any flips if you have random array access
13:03:09 <ricebowl> Cale - yes, if you convert 1024 to a string you get "4201"
13:03:20 <Cale> in some sense, sure
13:03:31 <ricebowl> so you still have to flip it or move it
13:03:42 <Cale> the usual algorithm for it does that, but in C, strings are arrays of char
13:03:43 <cfourier_> hello folks
13:03:55 <ricebowl> actually, I suppose that's not true. I saw a clever algorithm in assembly which does an int -> string conversion *extremely* quickly
13:03:55 <cfourier_> i am having a bit of haskell issues
13:03:56 <Cale> you can just set the indices correctly in the first place
13:04:06 <Cale> cfourier_: hi
13:04:18 <ricebowl> no you can't
13:04:22 <ricebowl> because the length is unknown
13:04:25 <cfourier_> i get an error when i compile some code
13:04:47 <ricebowl> length (show 50) == 2, length (show 5000) == 4, and you don't know that until you finish converting it
13:05:00 <ricebowl> you can compute log10(n) but that's more expensive than the entire conversion
13:05:23 <cfourier_> i just need a pastebin so i can show the error
13:05:30 <Lemmih> lisppaste2: url
13:05:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:06:03 <xinming> hmm, tail [] = []
13:06:20 <Cale> No it's not :)
13:06:20 <xinming> why the type of tail will become tail:: [a] -> [a1] ?
13:06:42 <Cale> tail [] = error "Prelude.tail: empty list"
13:06:44 <xinming> Prelude> :t tail
13:06:44 <xinming> tail :: [a] -> [a]
13:07:15 <xinming> Prelude> let tail [] = []
13:07:15 <xinming> Prelude> :t tail
13:07:15 <xinming> tail :: [a] -> [a1]
13:07:22 <lisppaste2> cfourier_ pasted "term issues" at http://paste.lisp.org/display/13838
13:07:53 <xinming> Isn't [] and [] the same type?
13:07:56 <Cale> xinming: you redefined tail
13:07:57 <Cale> and no
13:08:02 <ricebowl> CPS is working my head over.
13:08:07 <Cale> [] :: [a] for any a
13:08:14 <ricebowl> about the same as (.)
13:08:14 <cfourier_> when i googled the error, they said to #include <curses.h> in the troublesome file
13:08:21 <cfourier_> kinda hard to do
13:08:37 <xinming> :-S
13:09:48 <Cale> cfourier_: do you have curses.h on your system?
13:09:53 <cfourier_> yes
13:10:08 <Cale> are those calls genuinely from curses?
13:10:23 <Cale> you might want -lcurses on the ghc commandline
13:10:36 <cfourier_> ok
13:11:12 * Lemmih wonders how linking with curses would help gcc parse a header file.
13:11:19 <ricebowl> lol
13:11:37 <Cale> I'm really not sure how you'd ever get those errors in the first place
13:11:45 <Cale> to be honest
13:11:59 <shapr> @quote samc
13:11:59 <lambdabot>  monads are hard, let's go shopping
13:12:00 <Cale> how does your program use curses?
13:12:09 <malcolm> cfourier_: how are you binding to curses?  direct FFI calls or using a library?
13:12:11 <Cale> presumably through ffi
13:12:13 <cfourier_> for output
13:12:23 <cfourier_> im not my code uses it
13:12:39 <nuffer> so, is there any sort of array or matrix object I can use?
13:12:39 <cfourier_> all i see in an env variable
13:12:42 <cfourier_> and nothing else
13:13:05 <Lemmih> @docs Data.Array
13:13:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
13:13:21 <cfourier_> @docs FFI
13:13:21 <lambdabot> FFI not available
13:13:23 <nuffer> yay, thanks
13:13:39 <Cale> cfourier_: what haskell library are you using which permits the use of curses?
13:14:05 <Cale> does  adding --make to the ghc commandline help?
13:14:26 <cfourier_> im building darcs
13:15:09 <Cale> oh
13:15:45 <Cale> I'll have a look then
13:16:13 <cfourier_> do you want to see the file that complained?
13:16:32 <mwc__> okay cale, so that's a 60 fold speed up this way, thanks for the help
13:16:37 <Cale> mwc__: np
13:16:44 <mwc__> I've managed to make my code run 360 times faster thanks to your help
13:16:48 <Cale> :)
13:17:10 <Cale> cfourier_: yeah
13:17:24 <Cale> I'm just getting the darcs repo of darcs so I can take a look
13:17:26 <cfourier_> ok its 550 lines
13:17:32 <cfourier_> can pastebin hold that
13:17:47 <Cale> I don't know -- which file is it? I'll just download the package
13:17:56 <cfourier_> External.hs
13:19:42 <Cale> okay, I'm just grabbing the repo
13:20:14 <Cale> of course, it's taking its time, as there are 3613 patches :)
13:20:31 <cfourier_> gotta love patch theory
13:25:35 <takuan> cfourier_: there exists a haskell module which allows (basic) interfacing with fftw
13:25:56 <cfourier_> would it allow me to #include a file
13:26:46 <takuan> oops
13:26:51 <takuan> I read the wrong thing
13:26:56 <takuan> i read fft instead of ffi
13:27:13 <takuan> but it might be interesting as an example of how to use the ffi
13:28:10 <takuan> you might of course just use a binary distribution of the haskell
13:37:50 <Cale> cfourier_: so how did you compile darcs?
13:38:02 <Cale> (what did you type?)
13:38:14 <Cale> I did: autoreconf; ./configure; make
13:38:20 <Cale> and it seems to be compiling just fine
13:38:37 <Cale> this is off the stable branch
13:39:09 <cfourier_> i am using a solaris machine
13:39:31 <cfourier_> in my land things are a bit broken
13:39:57 <Cale> okay, does autoreconf do anything sane?
13:40:28 <cfourier_> works fine
13:40:33 <cfourier_> configure too
13:40:43 <cfourier_> its when i try to make it that issues arise
13:40:46 <malcolm> cfourier_: solaris, hmm, yes.  it doesn't have curses installed by default, no?
13:41:46 * dcoutts curses solaris
13:42:09 * Heffalump curses C++
13:42:20 <Heffalump> do I win, by cursing something far more intrinsically evil?
13:42:34 * dcoutts thinks it's more likely that C++ curses Heffalump
13:42:47 <cfourier_> yes solaris has curses, just seems to be term.h that is broken
13:45:05 <malcolm> cfourier_: I notice in my solaris setup, I have a symbolic link from libncurses.so.5 to libcurses.so, which is not there by default
13:45:51 <cfourier_> is there anyway to just include curses
13:52:19 <mwc__> wow, Cale, you're in Toronto?
13:52:24 <Cale> no
13:52:27 <Cale> Brantford
13:52:30 <mwc__> Ah
13:52:32 <mwc__> London myself
13:52:37 <Cale> :)
13:53:00 <mwc> South Western Ontario Haskell User Group?
13:53:06 <Cale> Yeah!
13:53:17 <Cale> That would be neat... I wonder who else is around here :)
13:55:49 <SamB> Frederick: there really isn't much to arrayts
13:55:53 <SamB> er, arrays
13:56:14 <Cale> someone should still write a nice wiki-tutorial
13:56:25 <Cale> I think I might do that as some point
13:56:41 <Cale> I don't use arrays all that much myself either though
13:56:42 <SamB> wouldn't hurt
13:57:14 <Cale> It's actually more complex than in most other languages because there are so many array types.
13:57:17 <SamB> the most important thing to cover would probably be circular dynamic programming
13:58:30 * SamB had been hard at work on his history presentation slides
13:59:43 <mwc> Cale: I heard there was a pocket of Haskellers at Macmaster
14:00:40 <shapr> hoi asmodai 
14:02:58 <malcolm> cfourier_: just looked at your paste.  Yeah, term.h requires a prior #include of curses.h.  I think I know of a way to solve this.
14:03:06 <Frederick> SamB, what do you mean?
14:03:21 <SamB> Frederick: about them being simple?
14:04:21 <Frederick> SamB, Ive just came back the studff Ive read didnt helped much
14:05:13 <malcolm> cfourier_: in External.hs. in the foreign import lines that refer to term.h, replace "term.h" with "myterm.h".  Then write a new file called myterm.h which just has the lines #include <curses.h> #include <term.h>
14:06:17 <SamB> Frederick: well, you just create an array like this
14:06:49 <shapr> @quote Heffalump 
14:06:50 <lambdabot> Heffalump  hasn't said anything memorable
14:07:00 <SamB> > array (0,10) (zip [0..10] [0,100..])
14:07:00 <shapr> I think I found a bug.
14:07:00 <lambdabot>  Not in scope: `array'
14:07:04 <SamB> hmm
14:07:07 <SamB> > Array.array (0,10) (zip [0..10] [0,100..])
14:07:08 <lambdabot>  Not in scope: `Array.array'
14:07:13 <SamB> rats
14:07:39 <malcolm> > Data.Array.array (0,10) (zip [0..10] [0,100..])
14:07:40 <lambdabot>  Not in scope: `Data.Array.array'
14:07:42 <SamB> *CFG> :m +Data.Array
14:07:42 <SamB> *CFG Data.Array> array (0,10) (zip [0..10] [0,100..])
14:07:42 <SamB> array (0,10) [(0,0),(1,100),(2,200),(3,300),(4,400),(5,500),(6,600),(7,700),(8,800),(9,900),(10,1000)]
14:07:48 <Heffalump> @quote Heffalump
14:07:48 <lambdabot>  CPP leads to suffering
14:07:56 <SamB> @quote SamB
14:07:57 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it
14:07:57 <lambdabot> printed
14:08:24 <xinming> > (x + sum(xs)){(2,[2,3])/(x,xs)}
14:08:24 <lambdabot>  parse error on input `2'
14:08:26 <SamB> (it didn't typecheck)
14:08:33 <SamB> (the shirt, that is)
14:09:29 <Frederick> brb
14:09:31 <nuffer> is Word32 a standard Haskell type?
14:09:43 <nuffer> and how can I convert one to an Integer?
14:10:20 <shapr> @quote malcolm 
14:10:20 <lambdabot> malcolm  hasn't said anything memorable
14:10:25 <shapr> @quote malcolm 
14:10:26 <lambdabot> malcolm  hasn't said anything memorable
14:10:28 <shapr> aha
14:10:31 <shapr> @quote malcolm
14:10:31 <lambdabot>  Most software doesn't need to be fast.  But all software needs a
14:10:31 <lambdabot> fighting chance of correctness
14:10:37 <eivuokko> @type fromIntegral
14:10:37 <lambdabot> forall b a. (Num b, Integral a) => a -> b
14:10:43 * shapr fixes
14:11:00 * malcolm wonders what happened there
14:11:07 <nuffer> eivuokko: was that directed at me?
14:11:14 <eivuokko> nuffer, yeah.
14:11:14 <Lemmih> nuffer: Yes, and you can use 'frromIntegral'.
14:11:29 <shapr> Can you think of any reason lambdabot shouldn't trim spaces from the end of commands?
14:12:27 <shapr> dons: Why is @quote in Babel? Doesn't it fit better in Quote?
14:13:54 <shapr> Is there a canonical whitespace trimming function somewhere?
14:14:27 <Heffalump> @type Char.isSpace
14:14:28 <lambdabot> Char -> Bool
14:14:42 <Heffalump> @type reverse.dropWhile isSpace.reverse
14:14:42 <lambdabot> Not in scope: `isSpace'
14:14:45 <shapr> I mean, something like chomp
14:14:47 <Heffalump> @type reverse.dropWhile Char.isSpace.reverse
14:14:49 <lambdabot> [Char] -> [Char]
14:15:03 <Heffalump> there you go :-)
14:15:33 <shapr> I've used that before, just wondering if there's a better way.
14:16:18 <Heffalump> you are wondering if there is a better white space classification function?
14:18:07 <shapr> Or a more efficient chomp function in any way.
14:18:37 <Heffalump> in what way is that inefficient?
14:18:38 <malcolm> unwords . words
14:18:54 <malcolm> dunno whether that is more or less efficient
14:19:07 <Heffalump> (I can see obvious operational reasons why it might be, but that's clearly a case for making the compiler cleverer :-)
14:19:55 <eivuokko> Hmh.  Writing rules for function composition with two reverses? o.O
14:20:26 <Igloo> You can write a lazy version
14:20:42 <Igloo> And "Char.isSpace.reverse"? Euch!
14:21:29 <Heffalump> Igloo: yeah, euch :-)
14:21:55 <Heffalump> blame the designers of Haskell :-)
14:22:03 <basti_> could I call "Kind" a "Type-arity"?
14:22:30 <Heffalump> Igloo: unwords.words is probably lazy
14:22:34 <Igloo> I'd say no
14:22:40 <basti_> hmm
14:22:44 <Heffalump> though it might look ahead to the next space
14:22:57 <Igloo> As you can have things like (* -> *) -> *
14:23:05 <basti_> ah thats right yes
14:23:10 <basti_> a "Type-Type"?
14:23:12 <musasabi1> a kind is the type of a type.
14:23:19 <musasabi1> a sort is the type of a kind
14:23:23 <musasabi1> ad infinitum
14:23:27 <basti_> how do you explain that to people who drop unconscious when you say "monoid"?
14:23:29 <Igloo> unwords.words is functionally different, e.g. when given "f  g"
14:23:57 <malcolm> > (unwords.words) "f g"
14:23:58 <lambdabot> "f g"
14:24:11 <Igloo> > (unwords.words) "f  g"
14:24:12 <lambdabot> "f g"
14:24:15 <Heffalump> oh, true.
14:24:47 <Heffalump> > undefined
14:24:48 <lambdabot> Add a type signature
14:24:51 <malcolm> on a lambdabot cmdline, does that matter?
14:24:53 <Heffalump> lol
14:25:18 <Heffalump> > (unwords.words) "f \"  \" g"
14:25:19 <lambdabot> "f \" \" g"
14:25:24 <Igloo> I don't know, I didn't read up to the start of the conversation
14:25:24 <Heffalump> malcolm: yes
14:25:46 <Heffalump> well, I can't think of concrete examples
14:25:54 <Heffalump> but given that it does it inside quotes, I think it's asking for trouble
14:29:50 <o_Rocky> @type unwords
14:29:51 <lambdabot> [String] -> String
14:30:02 <o_Rocky> @type words . unwords
14:30:02 <lambdabot> [String] -> [String]
14:30:14 <o_Rocky> @type (words . unwords)
14:30:15 <lambdabot> [String] -> [String]
14:30:35 <o_Rocky> @type (unwords . uwords)
14:30:35 <shapr> o_Rocky: You can also try that in private msgs.
14:30:36 <lambdabot> Not in scope: `uwords'
14:30:42 <o_Rocky> :P
14:30:49 <o_Rocky> thanks
14:31:43 <o_Rocky> some bots only work on the channel...
14:31:52 <o_Rocky> not the case
14:33:18 <astrolabe> Does (,,) automatically have an instance of Show?
14:33:39 <shapr> I think so.
14:34:01 <malcolm> astrolabe: yes, up to at least arity 15
14:34:07 <astrolabe> @eval show (1,2,3)
14:34:08 <lambdabot> "(1,2,3)"
14:34:11 <astrolabe> thankyou
14:47:08 <nuffer> what can I do with a [IO ()]?
14:47:21 <musasabi1> sequence
14:47:24 <basti_> nuffer: sequence it
14:47:31 <musasabi1> @type sequence_
14:47:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:47:53 <nuffer> so that'll give me IO [()]?
14:48:01 <basti_> yes
14:48:06 <basti_> sequence_ not
14:48:10 <basti_> but sequence will
14:48:14 <nuffer> sequence_ ?
14:49:05 <basti_> sequence_
14:49:26 <nuffer> that would give me an IO ()?
14:49:45 <basti_> yes
14:50:00 <basti_> it will ignore all results though. but that's ok when its only ()'s ;)
14:52:12 <reductor> sorry for asking, will lambdabot evaluate [1..]? this is very important to me
14:52:19 <shapr> reductor: try it
14:53:14 <shapr> ChilliX!!
14:53:20 <shapr> Wow, long time no see!
14:53:20 <pesco> ChilliX: Woah
14:53:22 <ChilliX> Hi!
14:53:26 <pesco> :)
14:53:43 <Pseudonym> G'day!
14:53:45 <ChilliX> Yeah, been slack ;)
14:53:54 <pesco> What's up? How's code?
14:54:05 <reductor> thank you
14:54:13 <ChilliX> Good to see everybody still on it.
14:54:15 <shapr> Hey, I've been meaning to ask you about PArr and GHC-SMP.
14:54:48 <Taral> ooo, ghc-smp :)
14:54:56 <ChilliX> shapr: SPJ's been asking that same question ;)
14:55:00 <shapr> Ah, excellent
14:55:04 <Taral> I read the paper the other day.
14:55:19 <Taral> If only GHC.Concurrent weren't so obnoxious.
14:56:01 <Philippa> I quite like GHC.Concurrent, but I wouldn't want to use it for serious parallelism - it's neat for IOish things
14:56:16 <Taral> See, it's not even neat for IOish things.
14:56:24 <shapr> I have two CPUs, I'd rather use them both for the same program at the same time.
14:56:25 <Taral> Try writing a read with timeout.
14:56:26 <ChilliX> There is no a new pragma in the HEAD that enables to  program some forms of self-optimising data types using GADTs
14:56:26 <Taral> It's evil.
14:56:34 <ChilliX> next thing is to rewrite PArr to use that
14:56:46 <Taral> Self-optimizing data types?
14:56:48 <Taral> O.o
14:56:58 <ChilliX> Only I don't quite get around to it due to two other projectsd
14:57:15 <shapr> Two other Haskell projects?
14:57:43 <ChilliX> New core language for GHC that supports GADTs in a nicer way and also supports associated types
14:57:59 <ChilliX> That's one
14:58:29 <ChilliX> Plus we are currently writting a new paper in the NDP saga about how to vectorise higher-order functions
14:58:55 <pesco> "NDP saga" heh.
14:59:04 <shapr> Oh neat
14:59:05 <musasabi1> Someone should write a mixing STM and the real world article.
14:59:44 <ChilliX> NDP = nested data parallelism
15:00:01 <shapr> NDP is cool.
15:01:10 <ChilliX> What are you up to?
15:01:53 <shapr> I have a bunch of projects in various stages of disarray.
15:02:05 <shapr> Fermat's Last Margin is about six lines of code away from a 0.1 release.
15:02:14 <ChilliX> 6 lines? ;)
15:02:24 <shapr> jlouis' Conjure is a Bittorrent client that I've worked on a bit.
15:02:26 <Pseudonym> We have more than six people here.  Assign a line to each of us.
15:02:37 * shapr grins
15:02:45 <ChilliX> hehe
15:03:21 <Taral> What is Fermat's Last Margin?
15:03:36 <ChilliX> Someone else got my nick on freenode :/
15:03:55 <Taral> And Philippa didn't respond to my comment about read w/ timeout.
15:04:26 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
15:04:33 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs. 
15:05:03 <Philippa> Taral: you're right. Sorry if you needed an ack on that
15:05:08 <Taral> O.o
15:05:22 <Taral> Why not process out the individual pages of the pdf/ps and keep them as pdf/ps?
15:05:34 <shapr> The idea has progressed some. I thought of switching to SVG, and thedward told me that pstoedit can turn any .ps or .pdf into SVG. Too bad firefox can't display them.
15:05:42 <Philippa> I've just not run up against that myself, so it's been OK in my personal experience
15:05:55 <SamB> Taral: those don't work well with wikis or browsers
15:05:56 <shapr> I do keep the documents.
15:06:18 <ChilliX> shapr: It's a nice idea w/ Last Margin
15:06:26 <shapr> But there's no easy way to display one specific page of a ps or pdf at a time.
15:06:26 <Taral> I wanted to write an async DNS resolver in Haskell... it went nowhere when I discovered how Concurrent works.
15:06:33 <Taral> No, no.
15:06:47 <Taral> Something like ps2ps which will give you N individual files with just one page in each.
15:06:47 <shapr> Here's the current demo - http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin
15:07:00 <shapr> Taral: There's already an async dns resolver in Haskell.
15:07:21 <Taral> There's a wrapper around libadns...
15:07:25 <shapr> Yeah, that one.
15:07:28 <pesco> Okay everyone, I have to leave the Net, see you all later!
15:07:32 <lisppaste2> SamB pasted "CYK: a partial implementation using Arrays" at http://paste.lisp.org/display/13842
15:07:34 <shapr> cya pesco 
15:07:44 <Taral> I wanted one in pure Haskell.
15:07:56 * pesco waves his arms around in an elaborate manner.
15:08:18 <SamB> *CFG> let cfg = run grammar "" (unlines ["termchars sz","start N","N -> sN | z"])
15:08:23 <SamB> *CFG> cyk (intCnf (cfgToCnf cfg)) "z"
15:08:23 <SamB> array ((1,1,1),(1,1,4)) [((1,1,1),True),((1,1,2),False),((1,1,3),False),((1,1,4),False)]
15:08:23 <SamB> *CFG> cyk (intCnf (cfgToCnf cfg)) "sz"
15:08:23 <SamB> array ((1,1,1),(2,2,4)) [((1,1,1),False),((1,1,2),True),((1,1,3),False),((1,1,4),False),((1,2,1),*** Exception: (Array.!): undefined array element
15:08:26 <SamB> Frederick: see that?
15:10:01 <Taral> and I seem to remember hsdns doing something bad like calling poll/select directly.
15:10:32 <Taral> all I really wanted was onEvent [Read fd, Timeout t] (\e -> do ...)
15:10:33 <Frederick> SamB, lemme copy to a text editor and read carefully
15:10:56 <shapr> ChilliX: What's the next episode in the saga of NDP? Any prepublish info online?
15:11:01 <SamB> Frederick: you'll probably want to ask people what things mean
15:11:10 <Taral> People still use CFGs? I thought parsing grammars were the thing to use now.
15:11:35 <SamB> Taral: its for a class of his
15:11:36 <shapr> ChilliX: PArr seems like the perfect library for GHC on the Cell cpu.
15:11:38 <Taral> Ha.
15:11:41 <Frederick> SamB, oki lets go by small steps
15:11:58 <SamB> Frederick: the code in unitParse in particular is rather convoluted
15:11:58 <Taral> shapr: link for PArr?
15:12:12 <Frederick> you are evaluating the word "z" of the grammar right?
15:12:13 <SamB> someone should make a nicer version and paste it as an annotation
15:12:21 <ChilliX> shapr: nothing online yet, but hope to have a draft by the end of the week
15:12:28 <shapr> cool
15:12:39 <SamB> Frederick: well, I didn't finish the algorithm
15:12:44 <ChilliX> Got already 4 of 8 pages
15:12:45 <Heffalump> ooh, hi Chilli
15:12:58 <ChilliX> Hi Heffalump :)
15:13:11 <ChilliX> C hacker hanging out with the Haskell dudes ;)
15:13:12 <Taral> I found http://www.cse.unsw.edu.au/~chak/nepal/, no progress since 2002.
15:13:15 <shapr> Taral: PArr is part of GHC now, it's parallel arrays. See http://www.cse.unsw.edu.au/~chak/nepal/
15:13:17 <Heffalump> yeah yeah :-p
15:13:26 <SamB> but that was doing what I implemented of the CYK check of whether "z" can be generated by that grammar or not
15:13:37 <SamB> and than the same thing for "sz"
15:13:48 <SamB> which of course didn't work too well
15:13:54 <ChilliX> Taral: at some point I'll clean the web pages usp...
15:13:59 <ChilliX> up, even
15:14:04 * Heffalump spent most of today struggling with Visual Studio configuration and trying to figure out in what situations it is legal to copy from a C++ datatype into an array of characters. Not fun.
15:15:01 <ChilliX> Heffalump: oh!
15:15:03 <Taral> I love citeseer.
15:15:04 <shapr> Struggling with emacs configuration is occasionally fun.
15:15:06 <Heffalump> Though I'm now reviewing a paper which is reminding me that I didn't like writing them :-)
15:15:18 <ChilliX> hehe
15:15:28 <Pseudonym> Why on earth would you need to copy from a C++ datatype into an array of characters?
15:15:56 <Heffalump> Pseudonym: in fact I wanted to cast an array of characters into a C++ datatype
15:16:14 <Pseudonym> Heffalump: Do you know about placement new?
15:16:15 <Heffalump> but I figured if the copying was legal I'd probably get away with the cast.
15:16:18 <Taral> You can only cast a standard structure into a C++ datatype if the datatype has no virtual members.
15:16:26 <Heffalump> Taral: and if it has no base classes.
15:16:34 <Taral> Mmm, even if it has base classes.
15:16:39 <Taral> e.g.
15:16:40 <Heffalump> (or user-defined constructors)
15:16:52 <Taral> class A { int x; }; class B : A { int y; }
15:16:55 <Pseudonym> In general, it's only moral if it's a POD type.
15:16:58 <Taral> You can cast int[2] into B
15:17:07 <Heffalump> according to the C++ standard, B isn't an aggregate class and hence not a POD type.
15:17:14 <Taral> POD?
15:17:14 <ChilliX> Taral: check out http://www.cse.unsw.edu.au/~chak/papers/#afp-arrays
15:17:16 <Pseudonym> And even then you might have to be careful about alignment.,
15:17:19 <Pseudonym> POD == Plain Old Data
15:17:20 <Heffalump> "Plain Old Data"
15:17:31 <Pseudonym> Placement new can often solve your problem.
15:17:35 <Taral> bah, every sane implementation has B defined as { A _base; int y; }
15:17:40 <Pseudonym> Rather than copy it, construct a copy in the target location.
15:17:42 <Taral> which is POD
15:17:43 <Heffalump> Pseudonym: yeah, I think that's why the standard just defines that you can memcpy it, rather than pointer cast.
15:17:53 <Heffalump> taral: what about with multiple inheritance?
15:18:12 <Taral> multiple inheritance is ill-defined enough I wouldn't touch it.
15:18:23 <Taral> Theoretically, without virtual base classes, you can:
15:18:24 <Pseudonym> Multiple non-virtual inheritance is usually okay.
15:18:31 <Heffalump> it shouldn't be particularly ill-defined without virtual base classes.
15:18:33 <Pseudonym> But as I said, it's only MORAL if it's POD.
15:18:39 <Taral> class A : B, C { ... } -> struct { B _base1; C _base2; ... }
15:18:46 <Heffalump> yeah, well, inheritance isn't POD, sadly.
15:18:51 <Heffalump> and neither are user-defined constructors.
15:19:06 <Taral> So use Haskell instead of C++ and solve all your woes.
15:19:09 <Pseudonym> But if you have a copy constructor, then you can just construct an object in place.
15:19:15 <Taral> Grr!
15:19:23 <Taral> I hate it when people only post PS on a site.
15:19:28 <Taral> I don't *have* a PS viewer.
15:19:31 <Taral> Post source code.
15:19:39 <Heffalump> so what is placement new?
15:19:41 <Pseudonym> PostScript _is_ source code.
15:19:47 <Heffalump> (google isn't being all that helpful)
15:19:48 <shapr> Taral: You could throw it into FLM
15:19:48 <Taral> Not when it's dvitops 
15:19:56 <Heffalump> Pseudonym: not in the FSF sense of "source"
15:20:00 <Pseudonym> True.
15:20:01 <Frederick> SamB, how are the elements in the sets of 3 elements related to the algorithm?
15:20:10 <Taral> Have you ever tried to READ dvitops output?!
15:20:13 <Heffalump> (I did try googling for placement new, but it's not being all that helpful)
15:20:16 <Pseudonym> Heffalump: char foo[sizeof(Foo)];
15:20:20 <Pseudonym> new (foo) Foo();
15:20:31 <Pseudonym> That constructs a Foo object in the character array foo.
15:20:32 <Heffalump> that's legal C++?
15:20:32 <SamB> Frederick: those are 3-tuples
15:20:35 <Heffalump> oh, wow.
15:20:38 <SamB> they are indexes in the array
15:20:38 <Pseudonym> Yes, that's legal C++.
15:20:44 <Pseudonym> There is one gotcha.
15:20:46 <Heffalump> what about Foo's vtable?
15:20:52 <Taral> OMG ew.
15:20:59 <Pseudonym> You call the constructor, so the vtable is all set up.
15:20:59 <Taral> I dislike new (ptr) Class(...) syntax.
15:21:11 <Heffalump> is the vtable included in the sizeof?
15:21:13 <Pseudonym> The gotcha is that when you no longer need it...
15:21:25 <Pseudonym> reinterpret_cast<Foo*>(foo)->~Foo();
15:21:36 <Heffalump> that's not much of a gotcha
15:21:37 <Pseudonym> That's the ugly part.
15:21:38 <ChilliX> Taral: Source for TeX?  Then you need to include a million style files and stuff if you want it portable.
15:21:54 <Pseudonym> I know, but the point is that you don't delete something that you create with placement new.
15:21:58 <Pseudonym> You manually call the destructor instead.
15:21:59 <Heffalump> Pseudonym: is that generally well-supported by compilers?
15:22:02 <SamB> ChilliX: well, what if you just post it for people to read
15:22:06 <Pseudonym> Yup.
15:22:07 <Taral> ChilliX: My TeX files are nice and portable without a million style files. :(
15:22:09 <Heffalump> we don't use new and delete anyway, so that's fine
15:22:21 <Pseudonym> The standard new is usually implemented in terms of placement new.
15:22:28 <Heffalump> presumably placement new won't call malloc?
15:22:31 <shapr> I wish I understood half the stuff going by on the Epigram mailing list.
15:22:32 <Pseudonym> And it's required to implement the STL (e.g. vector).
15:22:35 <Heffalump> or rather, is guaranteed not to
15:22:39 <Frederick> SamB, how are they related to the table?
15:22:40 <Pseudonym> Correct.  Placement new does not allocate memory.
15:22:48 <Pseudonym> (The constructor might, of course.)
15:22:48 <Taral> Is there placement delete?
15:22:59 <Heffalump> is it legal for foo to be any size as long as it's larger than sizeof(Foo) ?
15:23:01 <Pseudonym> Taral: No.  You have to manually call the destructor instead.
15:23:03 <shapr> ChilliX: Would you happen to know of an introduction to Michael Dummet's work that's slanted towards a CS background?
15:23:09 <Pseudonym> Heffalump: Modulo alignment, yes.
15:23:11 <SamB> Frederick: they are indexes into the table
15:23:15 <shapr> Or maybe you can recommend someone who might know of such a thing?
15:23:20 <ChilliX> SamB: that's alright, but something people rarely want
15:23:28 <Heffalump> I don't suppose the compiler will actually check that it's not smaller/less well aligned?
15:23:35 <Pseudonym> Nope.
15:24:02 <Heffalump> oh well, I'd already sorted out that problem in other (not very nice) ways :-)
15:24:06 <Pseudonym> :-)
15:24:15 <dons> ah ha! my announce gets through if I send from a different machine. 
15:24:18 <SamB> Frederick: I have to go walk the dog
15:24:23 <dons> hey ChilliX
15:24:25 <ChilliX> Taral: lucky you, but there quite a lot of useful style files around (all of whose functionality you *can* of course code from scxratch)
15:24:40 <ChilliX> Hi dons
15:24:50 <SamB> dons: did you get my patches?
15:24:59 <dons> SamB, yep. thanks for the RULE. tricksy!
15:25:06 <Heffalump> [define the char array in an union with a single instance of all the other types that might be in my Foo structure, and then declare an array of size (sizeof(Foo)<=sizeof(foo)), roughly]
15:25:32 <Frederick> SamB, will you be back today?
15:26:03 <Heffalump> did you answer my question about sizeof including the size of the vtable, btw?
15:26:03 <dons> SamB, you using fps for some project?
15:26:07 <ChilliX> shapr: nope
15:26:13 <Pseudonym> Heffalump: Yup.
15:26:23 <Pseudonym> Oh, I didn't.  But it does, yes.
15:26:26 <Heffalump> cool. Thanks a lot :-)
15:26:41 * Heffalump feels a lot less dirty about this implementation trick, now
15:26:50 <Pseudonym> Now as a matter of interest, there's a trick you can use for the union.
15:27:02 <Pseudonym> It's actually illegal to put an object which has a vtable in a union.
15:27:03 <dons> bah, msg still didn't get through. looks like haskell@ is permanently blocking me.
15:27:04 <Heffalump> ooh, and I can turn my init calls back into constructor calls, too
15:27:22 <Pseudonym> But there's a trick.
15:27:33 <Pseudonym> And it's seriously ugly, but thankfully there's a header file for it.
15:27:36 <Heffalump> I can't put the object in the union anyway, cos the whole point of this is to hide the implementation.
15:27:37 <Taral> ChilliX: So if this parallel array stuff is in ghc... hm, let me check the manual.
15:27:43 <Pseudonym> Right.
15:27:46 <ChilliX> dons: blockign emails?
15:27:47 <Heffalump> The object lives in a .cpp file, the char array in a header.
15:27:57 <Pseudonym> What you CAN do is put it in a union with everything that could be the first element in the object.
15:27:58 <Heffalump> If the header could see the object, the whole point would be lost anyway
15:28:04 <Heffalump> yes, that's what I'm doing
15:28:11 <Taral> ChilliX: I don't see PArr in the ghc manual.
15:28:19 <Pseudonym> Unfortunately you can't define a naked vtable.
15:28:21 <ChilliX> Taral: there is parts in there, but it is not complete; hence, nothing in the manual
15:28:24 <Heffalump> oh, you mean there's an automatic way to do it?
15:28:28 <Pseudonym> Kind of.
15:28:41 <Taral> ChilliX: Is any of it usable?
15:28:46 <Heffalump> oh, first element *including* a vtable?
15:28:51 <Heffalump> eek :-)
15:29:31 <Pseudonym> The Loki solution is to construct a union of every simple type.
15:29:36 <Pseudonym> Including pointers to methods.
15:29:53 <Heffalump> ah, ok. I did consider that.
15:29:55 <SamB> I was annoyed at your cluttering the source code for hmp3 with all those packAddress calls and sharp-pointy strings 
15:30:03 <Pseudonym> However, there's also the chance that the object might be _smaller_ than some simple types.
15:30:09 <Pseudonym> e.g. smaller than a long double
15:30:37 <Pseudonym> So his solution is to use template metaprogramming to construct a union of every simple type that is shorter than or equal in size to the type that you're interested in.
15:30:51 <Pseudonym> Believe me, you don't want to do this from scratch.
15:31:04 <ChilliX> Taral: well you can execute array expressions, but they are not executed in parallel and even not particularily efficiently sequentially
15:31:38 <ChilliX> Taral: that's where the self-optimising data types using GADTs come in, which I need to implement
15:31:38 <Heffalump> and since I don't have the type I'm interested in visible, it doesn't help, does it?
15:31:44 <Pseudonym> Probably not.
15:32:08 <Taral> hmmmmmmmmm
15:32:09 <Pseudonym> One thing you can do is to insert a static check that the char array is big enough.
15:32:18 <Taral> anyone looked at jhc/
15:32:19 <Taral> ?
15:32:22 <Pseudonym> BOOST_STATIC_CHECK is good.
15:32:26 <shapr> Yeah, JHC is cool.
15:32:33 <Pseudonym> And JHC is cool.
15:32:43 <Heffalump> I'm using the trick with a sizeof test as an array bound to do that.
15:32:43 <shapr> GRIN is an excellent low level language.
15:32:54 <Pseudonym> Heffalump: Right.
15:33:13 <Pseudonym> I am curious, Heffalump, as to why you want to do this rather than, say, using a standard pimpl.
15:33:15 <Taral> I dunno... it took me 15 minutes to find the haskell parser in there.
15:33:38 <shapr> Since thunks are nodes, I had the idea to get speculative execution by unwrapping the thunks during compilation. Of course, someone already wrote a paper about the same thing years ago :-/
15:33:58 <Heffalump> some of the objects will be constructed before our memory allocation infrastructure starts up
15:34:00 <Pseudonym> I can't wait for a GRIN-like language which supports separate compilation.
15:34:03 <Pseudonym> Ah, I see.
15:34:12 <shapr> Why a separate GRIN?
15:34:32 <Heffalump> also, won't this have one layer less indirection than a pimpl?
15:34:33 <Pseudonym> It could be an extension.
15:35:02 <Pseudonym> Heffalump: Errr... yes.
15:35:06 <shapr> I sent an email to Boquist asking what he meant about the advantages of SSA in the generated assembly code, but he hasn't responded.
15:35:53 <Heffalump> for someone who works on a C++ compiler for a living, I'm stunningly ignorant of C++ :-)
15:36:34 <Pseudonym> That's a bit frightening.
15:36:45 <Pseudonym> Which compiler?
15:37:05 <ChilliX> Heffa: lol
15:37:11 <Pseudonym> Mind you, I think everyone is ignorant of C++.
15:37:18 <Pseudonym> Especially the committee.
15:37:27 <Heffalump> the ARM one. In my defence, we buy in our frontend, and our implementation is basically C with a bit of C++ gradually creeping in.
15:37:33 <Pseudonym> Ah, OK.
15:37:42 <shapr> On page 194 of the GRIN thesis, he says that SSA has benefits at the machine code level as well, though it was noticed too late to implement. Any idea what that means? Why would SSA machine code be advantageous?
15:37:58 <shapr> hi SuperNoob, learning Haskell?
15:38:04 <Pseudonym> I know the answer to that one.
15:38:14 <Taral> There's a GRIN thesis?
15:38:17 <shapr> Tell me!
15:38:18 <Pseudonym> If you know that a value won't be used, you don't have to write it back into the register file.
15:38:22 <Taral> I'm amazingly ignorant about this field.
15:38:25 <shapr> This is the sort of thing I want FLM for...
15:38:37 <shapr> Taral: You only started hanging out on #haskell .. yesterday?
15:38:45 <ChilliX> shapr: when he says, as well, which level does he discuss before?
15:38:55 <Taral> shapr: I've been studying for about 6 weeks or so now.
15:39:01 <Heffalump> Taral has been around for ages, hasn't he, or is that on #darcs?
15:39:03 <Pseudonym> For example, if you're doing speculative execution, an instruction can simply be removed from the input stream if it doesn't need to write a value back.
15:39:03 <Taral> I knew about GRIN, I didn't realize it was thesis-work. :)
15:39:12 <Taral> I've been in and out of this channel for a couple years.
15:39:22 <Pseudonym> Once its value has been forwarded to whatever instruction uses it.
15:39:25 <Pseudonym> Would an example help?
15:39:28 <Heffalump> it also helps with re-using registers in the CPU early
15:39:35 <shapr> Pseudonym: yes!
15:39:43 <Pseudonym> Well, modern CPUs rename registers anyway.
15:39:44 <Heffalump> (in a microarchitecture with register renaming)
15:39:51 <Pseudonym> OK, example:
15:39:54 <Heffalump> I mean for the CPU to reuse the renamed register
15:40:00 <Pseudonym> Uhm... what assembly language do we all know?
15:40:06 <Taral> found the GRIN thesis.
15:40:09 <SamB> dons: not really.
15:40:09 <SamB> I will probably be using it in conjure soon though
15:40:11 <SamB> someone else is already
15:40:12 <Taral> Only 347 pages, shouldn't take long...
15:40:13 <SamB> and its only a matter of time before my code meets with theirs ;-)
15:40:21 <SamB> Taral: it is
15:40:24 <Pseudonym> Never mind, I'll make one up.
15:40:26 <Heffalump> you don't need SSA machine code to reuse the architectural register early (though it might make the register allocation easier)
15:40:33 <SamB> Taral: -fparr
15:40:45 <Pseudonym> ADD r1,r2,r3
15:40:51 <Pseudonym> I'm using source,source,dest ordering.
15:40:53 <SamB> Frederick: I dunno
15:41:01 * SamB tries to find the library portion
15:41:08 <shapr> ChilliX: GRIN is SSA, but the generated machine code isn't.
15:41:09 <Pseudonym> ADD r3,r4,r1
15:41:13 <Pseudonym> Here, r3 is a temporary.
15:41:21 <Pseudonym> Suppose it's not used after the second ADD.
15:41:23 <Frederick> SamB, k
15:41:40 <ChilliX> shapr: hmm, GRIN is not SSA in the classical sense, is it?
15:41:51 <shapr> Static Single Assignment?
15:41:51 <Pseudonym> In that case, the value doesn't need to be written back into the register file.
15:41:58 <ChilliX> SamB: GHC.PArr
15:42:02 * SamB should go so he has more chance of returning
15:42:05 <shapr> What's the classical sense, and what other senses of SSA are there?
15:42:07 <SamB> ChilliX: true!
15:42:22 <Taral> Ooo.
15:42:27 <Taral> :browse GHC.PArr
15:42:29 <Pseudonym> So, for example, if an exception occurs in the next instruction, it takes less time to clear the pipeline.
15:42:29 <Taral> iiiinteresting.
15:42:31 <ChilliX> shapr: well, SSA's unique feature are these phi function, which GRIN doesn
15:42:34 <shapr> Pseudonym: What's a register file? Is that like a write cache?
15:42:37 <ChilliX> doesn't have AFAIK
15:42:48 <Heffalump> shapr: errm, it's the thing the CPU has :-)
15:42:50 <Taral> um...
15:42:51 <Pseudonym> The register file is the One True Copy(tm) of what the values of the machine registers are.
15:42:53 <ChilliX> GRIN is just a first-order functional intermediate langauge
15:42:58 <Taral> what's the constructor type?
15:43:04 <Pseudonym> It's a small amount of RAM in the CPU.
15:43:06 <shapr> Heffalump: CPUs have several things.
15:43:12 <shapr> Oh, just the registers?
15:43:15 <Pseudonym> Right.
15:43:17 <Heffalump> I mean it's the thing it uses to store the registers.
15:43:18 <shapr> ok
15:43:18 <Heffalump> Yes :-)
15:43:20 <ChilliX> shapr: and yes, there is a tight vonnection between SSA and functional ILs, but they are not the same
15:43:30 <Taral> ([::]) and ([:]) are both parse errors...
15:43:46 <Pseudonym> In a highly pipelined/superscalar/whatever CPU, the One True Copy(tm) isn't true all of the time.
15:43:49 <shapr> Taral: -fparr ?
15:44:11 <Pseudonym> But it needs to be made true if, for example, there's an exception.
15:44:25 <ChilliX> shapr: see Appel's paper or http://www.cse.unsw.edu.au/~chak/papers/#ssa-lambda
15:44:43 <Taral> Did anyone see the MCNP progressive global register allocator?
15:44:45 <shapr> Taral: http://www.scannedinavian.org/~shae/ProtoParrCrash.hs (no longer crashes GHC)
15:44:56 <shapr> Code by musasabi1
15:45:00 <Pseudonym> But if the value of the register isn't used, and you know it isn't used, then you don't need to save it.
15:45:15 <Heffalump> taral: no, URL?
15:45:33 <shapr> Pseudonym: Makes sense, thanks.
15:45:34 <ChilliX> Taral: [::] is not a parse error in my copy of ghc
15:45:39 <Pseudonym> Only the instructions which produce a result that is later used need to be committed.
15:45:57 <Taral> aha!
15:45:58 <Pseudonym> In the Mercury compiler, we found that putting liveness information at the end of basic blocks did the trick.
15:46:01 <Taral> :set -fglasgow-exts
15:46:08 <SamB> its a parse error if you try to use it as a Type constructor, apparantly
15:46:17 <Pseudonym> It meant that you could reschedule the code without re-analysing.
15:46:28 <SamB> or at least, in :i
15:46:40 <Taral> samb: Did you get a data constructor error?
15:46:44 <shapr> Well, that's interesting. I wonder if JohnMeacham knows about that.
15:46:48 <Pseudonym> It's especially handy in abstract assembly languages.
15:46:52 <shapr> That could make JHC that much faster.
15:46:53 <Pseudonym> Especially if you're compiling to JIT.
15:46:55 <SamB> *CFG> :i [::]
15:46:55 <SamB> <interactive>:1:0: parse error on input `[:'
15:47:04 <ChilliX> SamB: no
15:47:12 <Taral> Heffalump: Hm, URL... hm...
15:47:13 <shapr> Pseudonym: Oh, so it would be easier for code morphing software to handle?
15:47:15 <Taral> There are several papers.
15:47:21 <shapr> Aha, I know someone who needs to know that...
15:47:21 <Pseudonym> Right.,
15:47:29 * Heffalump tries google
15:47:41 <Taral> google:multi-commodity register allocatior
15:47:47 <Taral> er, allocator
15:47:54 <Pseudonym> It was a single instruction which was the last instruction in a basic block.
15:48:03 <Pseudonym> Which basically said "these registers and stack locations are live".
15:48:23 <ChilliX> Prelude> :set -fglasgow-exts -fparr
15:48:23 <ChilliX> Prelude> [::] :: [::] Int
15:48:23 <ChilliX> [::]
15:48:23 <ChilliX> Prelude>
15:48:32 <ChilliX> (this is 6.4.1)
15:48:50 <dons> works for me.
15:48:55 <dons> @type [::]
15:48:55 <lambdabot> parse error on input `::'
15:48:57 <Heffalump> Pseudonym: the union of the live sets for all successor blocks?
15:48:58 <dons> probably wonn't though.
15:48:59 <Taral> weird
15:49:03 <Taral> wasn't working a moment ago.
15:49:03 <dons> maybe we should add -fparr to >
15:49:06 <Heffalump> taral: ta
15:49:10 <Pseudonym> Heffalump: Yes.
15:49:13 <shapr> hiya dbremner 
15:49:14 <SamB> dons: probably not...
15:49:21 <ChilliX> dons: lambdabot won't have the right options, I guess
15:49:24 <dbremner> shapr - hi
15:49:28 <SamB> its not like you'd be allowed to use GHC.PArr anyway
15:49:45 <dons> I'm wondering how safe -fparr is, ChilliX?
15:49:48 <Pseudonym> If you think about it, that's everything you need in the way of dataflow information.
15:49:50 <musasabi1> GHC.PArr should be safe in theory.
15:49:51 <SamB> I mean, would you put GHC.PArr in scope?
15:49:58 <dons> or does it also require -fglasgow-exts
15:50:03 <dons> SamB, not sure. maybe..
15:50:04 <SamB> what if they added unsafe functions?
15:50:06 <Pseudonym> Anything which is live on entry is either used in the block or not modified and live on exit.
15:50:07 <Taral> OMG.
15:50:09 <Heffalump> isn't labelling each basic block with that information pretty standard in an intermediate representation?
15:50:12 <Taral> I've been doing too much with CoC.
15:50:19 <dons> SamB, if it's unsafe, then no. but I'm asking if it is ;)
15:50:23 <Taral> I'm mixing types and values.
15:50:24 <shapr> Pseudonym: Makes sense.
15:50:25 <musasabi1> Historically -fparr contained unsafe bugs
15:50:35 <Pseudonym> Heffalump: Yes, but it's not standard in abstract assembly languages.
15:50:40 <ChilliX> dons: well, it's doesn't really do the optimisations yet, so I think there is little point inincluding it
15:50:44 <shapr> Taral: How many Co $SOMETHING are there anyway?
15:50:45 <Heffalump> ah, right
15:50:45 <Pseudonym> e.g. bytecode formats
15:51:00 <Taral> shapr: 8, if you believe the lambda-cube theory.
15:51:08 <shapr> oh
15:51:11 <shapr> ok
15:51:11 <Heffalump> I guess it's just a question of thinking about abstract assembly as just another compiler IR :-)
15:51:13 <Pseudonym> The more powerful JIT compilers go to some trouble to recover the information.
15:51:13 <Taral> more, if you want to allow that CoIC is a separate Co*
15:51:15 <dons> ChilliX, ok.
15:51:15 <ChilliX> musasabi1: there were some bugs, which I fixed after they were reported
15:51:37 * shapr belatedly connects lambda cube and Co *
15:51:39 <Heffalump> does your assembly explicitly identify the stack too?
15:51:44 <Taral> LOL
15:51:48 <dons> SamB, seems to provide a safe interface, btw.
15:51:55 <Pseudonym> Heffalump: The Mercury one did, yes.
15:52:02 <Taral> jhc uses CoC for its intermediate at some point.
15:52:06 <Pseudonym> It identified what parts of the stack frame were live.
15:52:09 <dons> and probably there are some other things in GHC.* that are safe.
15:52:10 <SamB> yeah, you do tend to think thoughts along the lines of "just another compiler IR" when you have seen so many in one compiler...
15:52:13 <Taral> the author calls it "lambda-cube", but I believe this is a misnomer.
15:52:15 <shapr> Taral: Hey, I'm self-taught, I have an excuse :-P
15:52:16 <dons> maybe Num, or Show.
15:52:21 <musasabi1> ChilliX: So it is working alright for 6.4.1 ?
15:52:25 <Heffalump> could stack variables be address-taken?
15:52:40 <Heffalump> Taral: that regalloc stuff looks neat, thanks for the pointer
15:52:44 <ChilliX> musani1: well, as far as I tested it
15:53:05 <ChilliX> musasabi1, that is
15:53:06 <Pseudonym> Heffalump: Pardon?
15:53:27 <shapr> Taral: Are you self taught too?
15:53:52 <SamB> dons: oh, why does hmp3 not like it when mpg321 emits what looks like something from the ID3 tags?
15:54:11 <Heffalump> Pseudonym: as in could people have pointers?
15:54:13 <dons> SamB, it should be handling ID3 flags fine. Do you have an example
15:54:23 <Heffalump> I guess not in the source language.
15:54:28 <dons> i.e. it's used in the titles:   Moloko : Things To Make And Do : Indigo
15:54:43 <dons> and to set xterm titles as well.
15:54:56 <SamB> dons: well, try it on: http://zhaymusic.com/music/the-apprentice-1.mp3
15:55:05 <dons> testing..
15:55:17 <Taral> see, this is why TeX source would be useful.
15:55:21 <Taral> The GRIN paper is in A4 format.
15:55:25 <Taral> I want it in letter format.
15:55:34 <Taral> shapr: Yes.
15:55:41 <Taral> I'm most certainly self-taught when it comes to this stuff.
15:56:10 <dons> SamB, I notice after around 40 hrs the space usage has doubled on my box
15:56:14 <Pseudonym> Heffalump: I still don't understand.
15:56:16 <Taral> I looked at :t ([::]) and had a brain explosion when I saw ([::]) :: forall a. [:a:]
15:56:23 <dons> So there's some other, slower leak perhaps.
15:56:25 <ChilliX> Taral: But would it fit?  Usually, you get a lot of bad formatting if you change paper sizes
15:56:34 <Taral> ChilliX: Even with the original source?
15:56:39 <Heffalump> Pseudonym: knowing whether a stack slot is live is complicated if someone might have the address of it.
15:56:40 <ChilliX> yes
15:56:46 <Taral> That's icky.
15:56:53 <Taral> The point of TeX is paper-size independence.
15:56:58 <Taral> well, part of the point
15:56:58 <SamB> dons: or maybe its just some vestigial laziness
15:57:05 <Heffalump> TeX doesn't really do anything very well :-)
15:57:12 <ChilliX> Taral: especially with conference papers, as they are formatted for tight space limits, people have to fine tune formatting a lot
15:57:20 <Pseudonym> Oh, I see.
15:57:22 <Heffalump> especially not after the hacks people have layered on top of it
15:57:26 <dons> we'll see if the GC wakes up and knocks it on the head. it's happened before, and the space drops down to what it started at.
15:57:27 <Taral> ChilliX: That sucks.
15:57:32 <ChilliX> Taral: that's very annoying, but not really the authors fault
15:57:38 <Pseudonym> I don't think that was a problem in Mercury.
15:57:44 <Pseudonym> But that's an issue in SSA as well.
15:57:45 <Taral> TeX does my stuff very well, but that's because I do everything in plain TeX, none of this LaTeX fanciness.
15:57:59 <ChilliX> believe me, it is quite annoying spending hours just to make your paper one page shorter to keep trhe published happy :/
15:58:05 <shapr> dons: You could add a performGC button :-)
15:58:15 <shapr> ChilliX: You could write for TMR ;-)
15:58:15 <ChilliX> publisher, that is
15:58:25 <SamB> Taral: the point of TeX is so that Knuth doesn't have to worry about them changing typesetting technologies out from under him, because he built the typesetter ;-)
15:58:28 <ChilliX> shapr: no page limit :)
15:58:34 <shapr> Speaking of which, TMR really needs more articles/authors.
15:58:38 <Taral> ha!
15:58:42 <Taral> this paper isn't in A4.
15:58:45 <Taral> It's in something smaller...
15:58:46 <Heffalump> Pseudonym: sure, I was just wondering how you handled it for this liveness info
15:58:48 <SamB> and to facilitate excellent quality typesetting
15:58:57 <dons> shapr! hehe
15:59:06 <Heffalump> shapr: errm, there's the one on GADTs and darcs, but I dunno if I can get it polished up in time
15:59:14 <shapr> Two months in a row without a TMR issue is sad.
15:59:20 <shapr> I have an article, boegel has an article.
15:59:25 <shapr> humasect might have an article.
15:59:28 <shapr> I just need two more!
15:59:36 <shapr> Oh, and I have the SPJ speech sample too.
15:59:38 <astrolabe> Could anyone give me a clue about the GHC error '../mylib/AstroPrelude.hs: file name does not match module name 'Main'  '?
15:59:59 <Taral> What is FLM?
16:00:05 <shapr> Too bad he didn't record "Hello, my name is Simon Peyton-Jones, and I say Haskell as Haskell."
16:00:14 <SamB> astrolabe: you need to put a "module AstroPrelude where"
16:00:15 <ChilliX> lol
16:00:22 <SamB> line in
16:00:23 <shapr> Taral: If it's in relation to me, it's Fermat's Last Margin.
16:00:27 <Taral> oh
16:00:27 <astrolabe> samB thank you
16:00:28 <Taral> yes
16:00:29 <ChilliX> ok, need to go to a meeting - later
16:00:32 <Taral> bye ChilliX
16:00:39 <shapr> cya
16:00:39 <Igloo> Pah, you need "My name is Haskell B Curry, and I [...]"
16:00:41 * SamB needs to actually leave
16:00:46 <Taral> this paper is horribly mis-formatted
16:00:58 <shapr> Igloo: Someone suggested that, but I don't have a time machine.
16:01:24 <shapr> On the other hand, maybe there are recordings by him?
16:01:41 <dons> SamB, what am I expecting to see with this .mp3 file
16:01:45 <dons> (still downloading..)
16:02:57 <tony2> dons/SamB, if I may ask, what is it that you are working on?
16:03:22 <shapr> Heffalump: If you could get it done by the first, that would be very nice.
16:03:29 <dons> hmp3. an ncurses mp3 player.
16:03:32 <dons> @where hmp3
16:03:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
16:03:37 <shapr> Heffalump: I can probably scrape up one more article somewhere.
16:03:48 <shapr> dons: Hey, think you'd have time to write something for TMR?
16:03:51 <Taral> hmp3?
16:03:53 <Taral> O.o
16:03:55 * shapr looks for people to pick on
16:04:04 <shapr> Taral: Want to write about Haskell for The Monad.Reader?
16:04:05 <tony2> ah, very good.
16:04:09 * dons runs and hides under a mountain of work
16:04:13 * shapr grins
16:04:24 <shapr> Pseudonym: Want to write a Pseudocode article?
16:04:42 <shapr> pejo: Want to write about Timber for TMR?
16:05:00 <astrolabe> @karma samB
16:05:01 <lambdabot> samB has a karma of 0
16:05:07 <shapr> dcoutts: Want to write about gtk2hs for TMR?
16:05:19 <shapr> I could write two articles, but that would be pretty sad...
16:05:39 <Pseudonym> shapr: I'd love to.  Whether or not I actually can is another question.
16:05:55 <shapr> Yeah, I understand. What do you do for a living now anyway?
16:06:03 <Pseudonym> Nanotech.
16:06:10 <Heffalump> shapr: poke me again on Sun afternoon
16:06:11 <Pseudonym> Which gets me extra geek cred points.
16:06:11 <shapr> Cale: Want to write about the advantages of laziness for the next TMR?
16:06:21 <shapr> Heffalump: ok
16:06:29 <Heffalump> I certainly won't have time before then.
16:06:36 <Heffalump> But I might have time between then and the 1st.
16:07:11 <dons> SamB, ah! got it: Strange mpg321 packet: zhaymusic.com
16:07:18 <dons> cheers I'll take a peek
16:07:26 <Heffalump> hmm, this paper I'm reviewing is cool, but shoddily written. Is it bad of me to want it to get in so I can talk about it properly? :-)
16:08:27 <shapr> edwinb: Want to write about deptypes for TMR?
16:08:44 <Taral> http://www.cse.unsw.edu.au/~dons/code/hmp3/FastMutInt.lhs
16:08:46 <Taral> O.o!
16:08:46 <shapr> musasabi1: Want to write about comonads for TMR?
16:09:03 <shapr> gaal_: Want to write about Pugs for TMR?
16:09:14 <Taral> what is TMR?
16:09:32 <SamB> Heffalump: you should send it back for correction!
16:09:44 <astrolabe> The monad reader
16:10:01 <Pseudonym> Heffalump: With lots of encouragement.
16:10:02 <musasabi1> shapr: I don't know whether I am right or wrong with them.
16:10:12 <shapr> musasabi1: You could always publish and find out.
16:10:18 <astrolabe> http://www.haskell.org/tmrwiki/FrontPage
16:10:20 <shapr> It's sure better than anything I could write about comonads.
16:10:26 <Heffalump> it's for a conference, so there's no "fix-rereview" cycle
16:10:39 <Pseudonym> Damn.
16:10:39 <shapr> ValarQ: Want to write about your experiences learning Haskell for TMR?
16:10:41 <Heffalump> I'm just saying what I think about it, the PC can decide.
16:11:43 <SamB> Heffalump: well then say that on the one hand you really want it to get in so you can talk about it properly, but on the other hand it is shoddily written
16:12:27 <shapr> tmoertel: Want to write about boxy or arbitrary rank types?
16:12:44 <Pseudonym> Heffalump: In what way is it badly written?  Is it just an English language problem?
16:12:53 <Heffalump> no, it's badly explained
16:12:56 <Pseudonym> Ah.
16:13:08 <SamB> that is probably the worse of the two...
16:13:21 * Pseudonym thinks that the process for accepting conference papers should be the same as for journals
16:13:26 <Heffalump> it's not so bad, if they explain all the things I ask about in my review it'll be quite good
16:13:31 <Pseudonym> Presentations are fleeting, but proceedings are forever.
16:13:46 <shapr> jlouis: Want to write about conjure for TMR?
16:13:48 <SamB> yeah
16:14:03 * shapr looks at SamB 
16:14:10 <shapr> I haven't asked you!
16:14:46 <shapr> ibid: Z  spec for TMR?
16:15:00 <SamB> I was agreeing with Pseudonym 
16:15:11 <shapr> SamB: Would you like to write a TMR article?
16:15:20 <shapr> ok, now I've asked you!
16:15:46 <SamB> hmm, I would. but I don't know what to write it about!
16:16:03 <Pseudonym> Write a postmodern essay about the process of finding something to write about.
16:16:21 <SamB> I've done that too many times already!
16:16:21 <Pseudonym> Oh, hang on, this is TMR, not Haskell Text.
16:16:24 <shapr> I have many suggestions, but I tend to pick something I want to learn more about.
16:16:46 <SamB> good idea!
16:17:00 <shapr> You could write a Template Haskell tutorial.
16:17:13 <sethk> you can combine psychology and software.  How about:  Are functional programmers disfunctional?
16:17:18 <SamB> because whenever I postpone it till after I learn more, I always forget what I learned. Either I don't remember learning it, or I don't remember it...
16:17:22 <musasabi1> shapr: Publishing something that can be wrong is not nice.
16:17:32 <musasabi1> and I still haven't found the holy grail.
16:17:36 <shapr> Or you could write a short demo of a dark corner of the GHC extensions.
16:17:49 <shapr> musasabi1: You could email Uustalo and ask him if you're right :-)
16:17:57 <musasabi1> But I think that what I want cannot be expressed in Haskell type system
16:18:15 <Taral> linear implicit parameters and the monomorphism restriction, anyone?
16:18:26 <SamB> musasabi1: so did I! until skew (I think) showed me how to do it!
16:18:32 <SamB> now I just need to send him $10
16:18:32 <shapr> Taral: That was TheHunter's article.
16:18:46 <Taral> heh
16:18:47 <Taral> yup
16:18:50 <Taral> Ooh, JoinHs.
16:18:54 <Taral> I <3 the join calculus.
16:19:05 <shapr> JoinHs is another fine article by musasabi1 
16:19:44 <shapr> beelsebob_: Want to write about Hats for TMR?
16:19:54 <shapr> ndm_: Want to write about YHC for TMR?
16:20:01 <beelsebob_> shapr: some time
16:20:04 <shapr> ok
16:20:18 <ndm_> shapr, will ask if i should
16:20:24 <shapr> cool
16:20:31 <Taral> shapr: Are you *trolling* for articles? :)
16:20:37 <ndm_> i'm happy to, but it depends on what other people say
16:20:55 <shapr> Taral: I'm the editor, if I don't specifically ask people for articles, nothing gets published.
16:20:55 <musasabi1> SamB: comonad things?
16:21:00 <ndm_> i'll also have a Hoogle one for you, a month after Hoogle3 is released
16:21:05 <Taral> shapr: I figured.
16:21:07 <astrolabe> Why is this happening? 'Not in scope: type constructor or class 'Ix' '?
16:21:08 <shapr> ndm_: Oh, that'll be neat.
16:21:14 <SamB> musasabi1: I don't care about comonads yet
16:21:22 <shapr> astrolabe: import Data.Ix
16:21:23 <SamB> do they have a real app yet?
16:21:36 <Taral> I wonder if it's reasonable to compare STM and Join.
16:21:46 <Taral> They're both concurrency abstractions.
16:21:48 <shapr> Taral: That would be an excellent TMR article...
16:21:58 * shapr grins evilly
16:22:00 <Taral> Yes, it would.
16:22:02 <astrolabe> shapr: I thought it was in the prelude?
16:22:05 <Taral> :)
16:22:10 <Taral> I'll see what I can cook up. It will require some work.
16:22:14 <Taral> Not likely for next issue.
16:22:15 <SamB> Taral: so do it
16:22:26 <shapr> Taral: Hey, any issue is cool with me.
16:22:39 <SamB> astrolabe: its in Ix and/or Array
16:22:54 <shapr> I hope to get five articles by December 1st. I'll be thrilled if I can get five more by Xmas.
16:23:33 <astrolabe> Thanks guys
16:23:36 <SamB> shapr: I don't think I can sustain my interest in TH long enough to do an article on it
16:24:09 <shapr> What subject could keep your interest?
16:25:02 <SamB> I'm not sure
16:26:40 <Taral> Hm, does STM have inference logic to detect wake-one vs. wake-all cases?
16:26:44 <tony2> The two haskell things I'd like to know more about, but don't have the time to look into are, generics and the 'house' os.
16:26:50 <Taral> house/
16:26:51 <Taral> ?
16:26:57 <shapr> I can write about House.
16:27:06 <shapr> @google haskell house hallgren
16:27:07 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
16:27:18 <shapr> I've been playing with the TCP/IP stack from House lots lately.
16:27:25 <tony2> that would be interesting to me at least.
16:27:26 <shapr> Pure Haskell, mmmm
16:27:54 <tony2> Indeed. 
16:28:22 <Taral> nifty
16:28:28 <SamB> shapr: isn't jlouis usually around 12 hours from now (either way) or so?
16:28:28 <Taral> pure haskell is mmm
16:28:37 <shapr> yup
16:29:06 <Taral> any word on GUI in Haskell?
16:29:19 <Taral> htoolkit looks kind of dead.
16:29:19 <shapr> In my blog I have directions for using the House TCP/IP stack via tun/tap.
16:29:23 <SamB> Gtk2Hs is the word on the street
16:29:28 <shapr> Gtk2hs and wxHaskell.
16:29:51 <shapr> Gtk2Hs is more popular on #haskell because some of the developers hang out here.
16:29:52 <SamB> wxHaskell definately does work
16:29:57 <Taral> hm
16:30:15 <Taral> Problem with GTK is it doesn't tend to use platform-native widgets when they're available.
16:30:15 <SamB> I ported an ant trace viewer to a recent version not too long ago...
16:30:33 <SamB> well, apparantly wx doing that has issues
16:30:48 <Taral> wxHaskell... Oh, yeah, I had problems getting all that to work on mingw, installed cygwin, was going to try again.
16:31:45 <shapr> boegel wrote a gtk2hs tutorial app for TMR1
16:32:11 <Taral> what about the higher-level stuff?
16:32:17 <Taral> I look at something...
16:32:22 <shapr> wxFruit?
16:32:23 <shapr> Fran?
16:32:27 <dons> @pl  \s -> s `append` P.empty
16:32:28 <lambdabot> (line 1, column 19):
16:32:28 <lambdabot> unexpected "."
16:32:28 <lambdabot> expecting letter or digit, variable, "(", "!!", white space, operator or
16:32:28 <lambdabot> end of input
16:32:28 <lambdabot> ambiguous use of a right associative operator
16:32:28 <Taral> one of those.
16:32:30 <Taral> I think Fran.
16:32:36 <dons> too verbose :/
16:32:37 <Taral> It used signals and signal transformers.
16:32:48 <Taral> But I hate the arrow notation... I want the arrows to go the other way.
16:33:01 <shapr> I like arrows, but they have the black hole problem...
16:33:05 <Taral> black hole?
16:33:22 <Taral> Oh, I think that's the point.
16:33:26 <Taral> Stuff goes in, never comes out.
16:33:31 <Taral> Like monads that way.
16:33:44 <Taral> Might be nice to compose a GUI in a non-monadic/arrow way.
16:34:17 <shapr> No, I mean that arrows can't lift functions to arrows because lifted functions are a black hole that you can't see into.
16:35:17 <Taral> ?!
16:35:29 <shapr> http://www.haskell.org/tmrwiki/ArrowsIntroduction
16:35:30 <Taral> arr :: (b -> c) -> a b c
16:35:48 <shapr> Sorry, I'm getting tired.
16:36:24 <shapr> Arrows have optimization opportunities that functions don't have.
16:36:49 <shapr> You can shortcut lots of stuff.
16:37:08 <Taral> I see.
16:37:09 <shapr> But, once you lift a function into an arrow, you lose those benefits.
16:37:18 <Taral> Try that again.
16:37:23 <Pseudonym> I think we Really Need(tm) user-defined type operators.
16:37:34 <Taral> Ha. In System F?
16:37:36 <Pseudonym> a b c confuses me in a way that b ~> c doesn't.
16:37:51 <Taral> you could write b :=>: c
16:37:52 <Pseudonym> Or b `Arr` c
16:38:00 <Heffalump> taral: not at the type level
16:38:18 <Taral> oh, I see.
16:38:19 <Taral> hm
16:38:23 <Taral> shapr: You make no sense.
16:38:25 * Heffalump sends Pseudonym off to play with Omega instead :-)
16:38:31 <Taral> shapr: Which one is better? Functions? Arrows?
16:38:33 <Pseudonym> Oooh!  Shiny!
16:38:45 <Taral> I want a free version of Clean. Clean was shiny.
16:38:45 <shapr> Taral: They're just different.
16:38:50 <shapr> And they don't mix.
16:38:52 <Pseudonym> But I don't want to play with other languages.  I want everything that I want inserted into Haskell!
16:38:58 <Heffalump> does Clean not have a free impl?
16:38:58 <Taral> Which benefits do you lose when you lift a function to an arrow?
16:39:04 <Pseudonym> Clean is very shiny.
16:39:05 <Pseudonym> Or was.
16:39:08 <Taral> Clean as a 'fReE' impl.
16:39:13 <Heffalump> you lose the knowledge that it was a "pure" function
16:39:15 <Taral> *has
16:39:29 <Taral> Heffalump: Ah.
16:39:33 <shapr> Search for 'black box' in that ArrowsIntroduction article.
16:39:35 <Heffalump> (pure in the sense of not side-effecting the arrow state)
16:41:06 <Taral> Hm.
16:41:37 <Taral> See, I think it might be possible to make a GUI implementation where the representation is side-effect free, and thus pure.
16:41:56 <Pseudonym> I should point out for completeness that arrows are not just for encapsulating state.
16:42:29 <Taral> What else are they for?
16:42:58 <Cale> the State monad is sufficient to capture state
16:43:18 <Taral> arg, I gotta go...
16:43:29 <Cale> Arrows are a good deal more general than monads, and monads are a good deal more general than the state monad :)
16:44:37 <Taral> byeby!
16:46:03 <dhpeterson> hey all
16:46:17 <dhpeterson> haskell newbie with a question about libraries
16:46:28 <Cale> cool, what's the question?
16:46:52 <dhpeterson> are the haskell heirarchical libraries and missingH the main libraries i need to know about
16:47:01 <dhpeterson> what is cabal
16:47:02 <dhpeterson> for example
16:47:09 <Cale> depends on what you're doing
16:47:16 <dhpeterson> at this stage just learning
16:47:20 <dhpeterson> so console-centric stuff
16:47:27 <Cale> cabal is a mechanism for packaging libraries and software written in Haskell
16:47:27 <dhpeterson> i am using ghci
16:47:42 <Heffalump> I meant state in its most general sense, including "point in time", "exception thrown", "number of multiverses", etc etc, btw :-)
16:47:43 <dhpeterson> is it related to hackage
16:47:49 <Cale> It goes along with Hackage
16:47:52 <dhpeterson> okay
16:48:03 <Cale> which is a tool to distribute those libraries
16:48:06 <SamB> dhpeterson: the heirarchical libs are most everything you need when starting out
16:48:12 <dons> you really only need to know the hierarchical libraries well.
16:48:16 <dhpeterson> right
16:48:22 <dons> MissingH is rarely needed, I think.
16:48:25 <dhpeterson> and they are described here, right: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
16:48:32 <SamB> no need to /MSG me for saying "thanks"
16:48:33 <dhpeterson> okay
16:48:39 <dons> @docs Data.List
16:48:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
16:48:43 <dons> right ;)
16:48:51 <dhpeterson> samb: wouldn't want to thank you publicly ;)
16:48:54 <SamB> @docs Text.ParserCombinators.Parsec
16:48:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
16:49:10 <SamB> dhpeterson: on the contrary, you could even @karma+ SamB
16:49:26 <dons> hehe
16:49:27 <dhpeterson> @karma+ samB
16:49:28 <lambdabot> samB's karma raised to 1.
16:49:31 <dhpeterson> heh
16:49:38 <dhpeterson> is there a lambdabot command reference anywhere
16:49:46 <dhpeterson> i couldn't find one yesterday when i went looking
16:49:58 <SamB> anyway, if you /MSG me you might make me think I did something wrong and someone is taking me aside about it!
16:50:08 <SamB> try @help
16:50:09 <dons> samB, I think I fixed the parsing problem on your mp3 
16:50:23 <SamB> dons: cool
16:50:27 <dhpeterson> samb: sorry, it's just your message came in a different colour so i thought it was /msg :)
16:50:28 <dons> I was assuming '@' wouldn't occur in an ID3 field, silly me.
16:50:36 <dhpeterson> @help
16:50:37 <lambdabot>  @help <command> - ask for help for <command>
16:50:40 <SamB> dhpeterson: ah!
16:50:51 <SamB> that sorta makes sense
16:50:58 <dhpeterson> is there any way for me to talk with the lambdabot without flooding the chan with junk
16:51:12 <SamB> that is a GOOD thing to use /MSG for
16:51:18 <dhpeterson> okay then :)
16:51:24 <SamB> also there is #haskell-overflow
16:51:47 <Heffalump> /msg SamB you're doing something wrong, I think we should take this outside and settle it like men
16:51:48 <SamB> which has the advantage of letting others walk up behind you and point out your mistakes
16:52:03 <dhpeterson> hehe
16:52:25 <dhpeterson> well if our pistols are haskell code i think i'll be dead ;)
16:52:29 <SamB> Heffalump: no, I mean if I was being overly confrontational and shapr called me aside to tell me to tone it down or something
16:52:54 <SamB> dhpeterson: not without unsafeShootFoot or IO
16:53:27 <shapr> Would I do thath?
16:53:39 <Heffalump> yea, I know :-) I was just trying to be funny
16:54:03 <SamB> shapr: call me aside to tell me to be less confrontational? I hope so!
16:54:18 <Frederick> yo, SamB are you oki? Can you continue giving me the hints you we were discussing?
16:54:21 * shapr pretends to be Cardinal Richelieu
16:54:39 <SamB> I wouldn't want you to just BAN me right off the bat, would I?
16:54:44 * Pseudonym pretends to be D'Artagnon
16:54:48 <Pseudonym> En garde!
16:55:05 <SamB> the first thing to do is KICK
16:55:07 <shapr> Right, isn't that how I treated what's his name?
16:55:21 <shapr> I shouldn't even bring it up...
16:55:29 <SamB> shapr: if his name is "nobody"
16:55:33 <SamB> well probably not even then
16:55:35 * Pseudonym wonders why musketeers spend more time sword fighting than firing muskets
16:55:49 <SamB> because there is probably somebody called that around here somewhere
16:57:03 <SamB> and iirc anything at all, you gave plenty of warning...
16:57:16 <shapr> Yeah well...
16:57:17 <Cale> @localtime xerox
16:57:33 <Cale> ah, not even here
16:57:34 <SamB> anyway, if I flip out and start acting like that, you know what to do!
16:57:43 <shapr> whine?
16:57:58 * shapr is just being silly.
16:58:00 <SamB> hehe
17:01:57 <SamB> anyway, after that incident with water in #slate, I think I know how to respond to the first warning ;-)
17:02:49 <shapr> What happened?
17:03:46 <SamB> oh, I annoyed him by asking too many of what he called "stupid questions" or something like that and got banned for a year or so 
17:04:28 <musasabi> firing muskets is not very cineographic, swordfigths are - simple as that.
17:04:35 <shapr> Well, water offended me to the point where I'd rather not communicate with him ever again.
17:05:16 <Heffalump> water??
17:19:22 <dbremner> Heffalump- http://tunes.org/~water/
17:19:52 <SamB> Brian Rice
17:25:26 <SamB> now, these questions were basically the equivalent of "shouldn't that be of type Integral?", as near as I can figure...
17:26:23 <SamB> well, I mean, I wasn't confusing fundamentally different kinds of things, but just newbieish questions about Smalltalkish stuff...
17:33:28 <Frederick> SamB, can you explain me what did you do with the last source you have showed me?
17:33:57 <SamB> Frederick: which parts are you wondering about?
17:34:05 <SamB> you can paste snippets
17:34:12 <Frederick> SamB, the concept of using the arrays
17:34:13 <SamB> probably thats best, actually
17:34:31 <Frederick> SamB, lemme check were did I put it
17:34:42 <SamB> Frederick: the concept is easy
17:36:21 * Frederick pays attention
17:36:54 * fworp hates that xemacs on windows uses the scroll wheel to paste, i scroll through source code and go back to it later and there are irc conversations and links all scattered through out it
17:36:56 <Pseudonym> Lunch.  BBL
17:37:24 <SamB> Frederick: well, I'm waiting for you to tell me which part of the concept you are stuck on.
17:37:32 <SamB> it is so easy I have no idea where to start!
17:37:35 <Cale> fworp: Just rolling the wheel pastes?
17:37:37 <Frederick> SamB, Icant find the source
17:37:44 * Frederick slocates
17:37:54 <fworp> no, pushing it down, but it often gets pushed down when you roll it
17:37:56 <Cale> fworp: it's usually just pressing the middle mouse button that pastes, that's good :)
17:38:19 <Frederick> SamB, my doubts is about the CYK stuff I dont have it here lemme check the channel logs
17:38:20 <Cale> well, it pastes whatever is selected (the primary)
17:38:39 <SamB> fworp: xemacs on *nix also does that
17:38:50 <Cale> I don't think windows has a separate primary and clipboard though
17:39:02 <fworp> SamB: but few things actually take advantage of the scroll wheel for x11 programs
17:39:03 <SamB> http://paste.lisp.org/display/13842
17:39:06 <fworp> so i dont use it to scroll
17:39:23 <Cale> fworp: almost all of my programs use the scroll wheel
17:39:33 <Cale> all gnome and kde apps do, anyway
17:39:49 * fworp shrugs
17:39:50 <SamB> fworp: I bet a lot of my programs would 
17:40:03 <SamB> if only I could get the wheel to actually generate events
17:40:10 <Cale> you just have to get used to rolling it without clicking :)
17:40:19 <fworp> well its inconsistent enough to that i remember having to get out of the habit when i used fbsd and debian
17:40:22 <Cale> SamB: which X server?
17:40:35 <fworp> that was probably it
17:40:38 <SamB> Cale: some old XFree86 4
17:41:23 * Cale looks up his old XF86Config-4
17:41:28 <Cale>     Identifier	"Mouse1"
17:41:29 <Cale>     Driver "mouse"
17:41:29 <Cale>     Option "Protocol"   "ExplorerPS/2"
17:41:29 <Cale>     Option "Device"     "/dev/mouse"
17:41:29 <Cale>     Option "ZAxisMapping" "4 5"
17:41:51 * SamB wonders how that printf is supposed to work...
17:43:21 <dons> SamB?
17:43:42 <dons> not this one: P.pack (printf "\ESC]0;%s\007" (P.unpack s))  ?
17:44:01 <SamB> dons: yes that one
17:44:10 <dons> doesn't work for you?
17:44:19 <dons> seems fine here.
17:44:26 <Cale> I'm willing to bet that just setting ZAxisMapping to something sensible will fix your scrollwheel
17:44:29 <SamB> dons: probably, but how?
17:44:54 <dons> ah, so the gunk on either side of the %s is the magic ansi control code that xterm looks for
17:45:01 <SamB> not that part
17:45:06 <dons> as to how printf itself works, who knows!?
17:45:09 <dons> it's pretty wacky
17:45:14 <SamB> the part where you just say "printf"
17:45:16 <Cale> oh, printf is neat
17:45:30 <dons> @type Text.Printf.printf
17:45:30 <fworp> its TH isnt it?
17:45:31 <lambdabot> forall r. (Text.Printf.PrintfType r) => String -> r
17:45:34 <dons> nah.
17:45:35 <Cale> If you haven't looked at it closely, it's worth looking at
17:45:37 <dons> just instances
17:45:53 <dons> I think it's even just h98?
17:46:02 <SamB> dons: oh, like Testable?
17:46:11 <dons> yeah, probably related.
17:46:12 <Cale> yeah, it looks like it's H98
17:46:23 <SamB> only the other way round?
17:46:36 <Frederick> SamB,  unitParse i j = fromMaybe False $               do cs <- liftM (\l -> [c | Term c <- l]) (M.lookup j prods)                    return (elem (sarray!i) cs) here you create the derivation trees right?
17:46:46 <SamB> so no compiler error if you don't have the right format, then...
17:47:13 <SamB> Frederick: no trees
17:47:48 <Frederick> SamB, my teacher call it trees, doesnt it creates the list of NT thar generate such productions
17:48:00 <SamB> that just determines if there are any length-1 parses for each a given production at a given part of the string
17:48:23 <SamB> s/each //
17:50:08 <SamB> er, for a given nonterminal
17:50:18 <Cale> a neat thing about Haskell printf is that it takes the job of printf and sprintf at the same time :)
17:50:19 * Frederick opens wikipedia
17:50:44 <dons> > (printf "%s" (1::Int)) :: String
17:50:44 <dons> "*** Exception: Printf.printf: bad argument
17:50:44 <lambdabot>  Not in scope: `printf'
17:51:06 <dons> so it's a runtime error
17:51:11 <dons> which is fair enough
17:51:17 <SamB> yes
17:51:18 <dons> since the format string could be dynamically constructed
17:51:32 <SamB> huh, true
17:53:38 <Cale> though I don't know why (IO a) is an instance of PrintfType and not just IO ()
17:54:20 <SamB> @type printf
17:54:22 <lambdabot> Not in scope: `printf'
17:54:39 <Cale> @type Text.Printf.printf
17:54:41 <lambdabot> forall r. (Text.Printf.PrintfType r) => String -> r
17:54:47 <SamB> dons: don't confuse me with that "> " notation
17:55:27 <SamB> > Text.Printf.printf "%d" (1::Int)
17:55:28 <lambdabot>  Not in scope: `Text.Printf.printf'
17:56:26 <SamB> dons: okay next I am going to complain that it doesn't support I18N
17:56:33 <SamB> just to be contrary ;-)
17:56:48 * Frederick draws
17:57:01 <SamB> and that it can't guess things are shift_JIS
17:58:06 <SamB> Frederick: I have no bandwidth for downloading pictures
17:58:28 <Frederick> SamB, nor a bw pic?
17:58:30 <Frederick> small one
17:58:45 <SamB> well I guess
17:59:06 <Frederick> SamB, lemme exercise asc art
18:07:22 <Frederick> SamB, http://paste.lisp.org/display/13847 can you understand this far?
18:10:33 * SamB loads
18:15:19 <fworp> are there unboxed numeric literals in ghc with extensions turned on?
18:16:20 <fworp> or do you have to just pattern match boxed values
18:17:01 <fworp> right now im doing something like let (I# i) = 25 in ...
18:17:32 <ChilliX> re
18:20:03 <Igloo> There's 25#, but I don't think you can let-bind it
18:20:30 <ChilliX> you can case bind it
18:21:22 <fworp> i think its expanded out, im pretty sure i was just doing it
18:23:10 <Frederick> SamB, ?
18:27:59 <SamB> sorry, got called away...
18:29:06 <SamB> Frederick: hmm
18:29:07 <Frederick> np
18:29:23 <Frederick> my hole netword had a frozen minute so I tought Ive lost con
18:29:23 <SamB> why do you repeat A three times? 
18:30:14 <SamB> Frederick: I'm not sure your teacher taught this very well!
18:30:42 <Frederick> SamB, where do I repeat?
18:31:50 <SamB> |A |S |A |A |S <--- productions that generate the terminals
18:31:50 <SamB> |a |b |a |a |b
18:32:47 <Frederick> SamB, take in mind the grammas must be in CNF
18:32:50 <Frederick> why would it be worng?
18:32:57 <SamB> hmm
18:34:33 <Frederick> SamB, so it is sure that only 1 sybol win generate the T, since CNF stands for NT -> NTNT or NT -> T
18:36:05 * SamB wonders if his code works at all
18:36:28 <SamB> oh, wait, this is a different grammar
18:37:20 <SamB> Frederick: so how do you get the cnf for that grammar?
18:38:25 <shapr> Oh I just got the coolest spam I've ever gotten :-)
18:38:37 <SamB> shapr: oh?
18:38:52 <Frederick> SamB, the grammar is already on the CNF
18:38:58 <shapr> From: guido@python.org \n Subject: patched  [2. application/octet-stream; file.txt                                                                   .pif]
18:39:00 <SamB> Frederick: really, all I'm doing is exactly what it says in Wikipedia
18:39:00 <SamB> Frederick: oh
18:39:01 <Frederick> to apply CYK we must have a CNF
18:39:15 * SamB doesn't have a parser for CNF
18:39:33 * SamB writes it raw then
18:39:54 <Frederick> SamB, but once it is in CNF using the module you did
18:42:58 <Taral> shapr: Heh.
18:43:46 <SamB> Frederick: well, mine's table is n-by-n-by-2
18:45:12 <Frederick> SamB, sorry Ive understood
18:45:18 <Frederick> *havent
18:46:31 <SamB>  *CFG> let cnf = CNF 'S' (M.fromList [('S', [Seq 'A' 'A', Seq 'A' 'S', Term 'b']), ('A', [Seq 'S' 'A', Seq 'A' 'S', Term 'a'])])
18:46:44 <SamB> *CFG> cyk (intCnf cnf) "a"
18:46:50 <SamB> array ((1,1,1),(1,1,2)) [((1,1,1),True),((1,1,2),False)]
18:47:15 <Frederick> SamB, I cant read the Seq part properly how does it work?
18:48:17 <SamB> that is the direct translation of your "S -> AA | AS | b, A -> SA -> AS -> a"
18:48:31 <Frederick> k
18:48:39 <SamB> er.
18:48:50 <SamB> modulo my using -> where I meant |
18:49:44 <Frederick> but you cant evaluate S you must evaluate a word like aab if S (starting symbol) belongs to the last box of the table so the algorithm is succesffull
18:50:03 <SamB> huh?
18:50:11 <SamB> did you read the wikipedia article?
18:50:18 <SamB> that is what I followed.
18:50:32 <SamB> I honestly don't understand their diagram
18:51:29 <shapr> Does anyone know where I can find info on DARCS_PUSH_HTTP? Juliusz Chroboczek says that darcs can already push via http to another darcs binary. Sadly, I can't find any info in this from google, darcs.net, DarcsWiki, or grep'ing the sources.
18:52:12 <Frederick> SamB, their diagram is wierd indeed I will edit it
18:52:58 <SamB> Frederick: do you understand their algorithm, though?
18:53:12 <SamB> you don't have to be able to explain it really
18:53:19 <Frederick> SamB, not their, I know the algorithm I can read that table
18:53:45 <SamB> Frederick: well, I was working from their algorithm
18:55:52 <Frederick> SamB, can you understand my algorithm?
18:55:59 <Frederick> lemme complete it
18:56:25 <SamB> no, I don't! all you've given is pictures
18:56:29 <SamB> and they are all 2d
18:56:37 <SamB> wheras I *know* the tables are 3d
18:56:55 <Frederick> SamB, the tables are 2D!
18:57:13 <SamB> Frederick: not in *this* formulation, they aren't
18:57:29 <Frederick> huh?
18:57:48 <SamB> Let P[n,n,r] be an array of booleans. Initialize all elements of P to false.
18:58:13 <shapr> Hm, it looks like darcs really does support pushing via http.
18:58:17 * shapr is surprised.
18:58:26 <SamB> shapr: didn't you get the memo?
18:58:50 <SamB> okay, so maybe it was more of a passing mention in one channel or another
18:58:51 <shapr> Nope, I missed that one.
19:03:25 <Pseudonym> Back.
19:03:38 <Pseudonym> Does anyone know of a good reference for the I2C protocol?
19:05:15 <Korollary> hah. the sensor guy.
19:05:34 <Frederick> SamB, check if you can load http://img500.imageshack.us/my.php?image=cyk6oc.jpg it is 13kb
19:05:57 <Pseudonym> :-)
19:06:12 <Korollary> Pseudonym: how do you like it so far ?
19:06:18 <Pseudonym> I've found out everything I need to know about SPI, thankfully.
19:06:28 <Pseudonym> It's actually kind of comforting.
19:06:34 <Pseudonym> It reminds me of my C64 days.
19:06:38 <Korollary> heh. good.
19:07:22 <Pseudonym> The difference between this and back then is that CPUs are so much faster nowadays.
19:07:58 <Korollary> what kinda processor is it ?
19:08:02 <Pseudonym> So devices with a requirement that pin X be held low for at least 25ms, for example, make it actually worth doing something else.
19:08:22 <Pseudonym> Go away, do something else, then come back and put the pin back high.
19:08:29 <Pseudonym> Atmel ATmega128
19:08:34 <Pseudonym> Very cool chip.
19:08:50 <Pseudonym> I particularly like JTAG.
19:08:56 <Korollary> hehe
19:08:57 <Pseudonym> Never had that back in the day.
19:09:29 <Pseudonym> The thing is, I don't think I could possibly design a low-end embedded chip better than AVR.
19:09:50 <Pseudonym> It's got oodles of registers, and just about every instruction takes one cycle.
19:10:54 <Pseudonym> (The main exception being branches, since they can cause a pipeline stall.)
19:11:22 <SamB> Frederick: its still clear as mud
19:11:59 <Frederick> SamB, do you have the pic there?
19:12:05 <SamB> yes
19:12:12 <Frederick> SamB, oki step by step
19:12:42 <Frederick> so the string to be evaluated is abaab since it is in cnf we have productions like NT -> T
19:13:25 <Frederick> in this case the productions of this kind are A -> a and S -> b oki? Ive noticed Ive missed S -> b in the gramamr definiion
19:15:00 <Frederick> so the second line is filled as A cause A-> a then S cause S -> b A because A->a A cause A -> a and S cause S->b ending as ASAAS oki?
19:18:31 * SamB thinks he gets it now
19:19:15 <Frederick> calm down there is a trick step
19:19:20 <Frederick> very tricky in fact
19:20:05 <Frederick> lets do the next line so we now have ASAAS, put your finger on the cell above the first a
19:20:13 <SamB> so you have basically the set of r for which P[y,x,r] is true in each of your table entries in the diagram?
19:20:37 <Frederick> lemme read the wikipedia
19:21:08 <SamB> only of course in my program I replace all the rs with numbers
19:21:37 <Frederick> yes
19:21:58 <Frederick> oki, next step we have done the 2nd line right?
19:25:45 <SamB> I understand the algorithm okay now.
19:26:28 * Frederick tries uncessfully edit the table from wikipedia
19:26:37 <Frederick> the problems begins in the 3rd line
19:26:58 <Frederick> AS is the result of thr evaluation ofhe pair AS generated by ab
19:27:20 <Frederick> A is the result of the evaluation of SA genetated by ba
19:27:36 <Frederick> S is the result of AA evaluation
19:28:36 <Frederick> then the tricky part, the frist AS from 3rd line from top to bottom is generated evaluating AA AS AA it is like a triangle
19:30:48 * SamB thinks some kind of animation with lines tracing what cells are used to calculate what other cells is in order
19:30:55 <dhpeterson> Pseudonym: seen PicoOS ?
19:31:05 <Frederick> first you match the first right above with the most distant variable of the diagonal in this case AA then SA then comes the trick step we go one cell down above AS (A in this case) and one cell up in the diagonal A in this case, and we evaluate the pair of the combinarion AA
19:31:18 <SamB> Frederick: is this string supposed to match?
19:31:26 <dhpeterson> @google picoos
19:31:28 <lambdabot> http://picoos.sourceforge.net/
19:31:50 <dhpeterson> cross-platform microkernel with an avr port
19:32:01 <dhpeterson> (sorry o/t i know)
19:32:16 <SamB> dhpeterson: oh, is it?
19:32:20 <SamB> I hadn't noticed!
19:32:39 <dhpeterson> heh
19:32:41 <Pseudonym> dhpeterson: Uhm... I think so.
19:32:47 <Frederick> SamB, if each substring has a rule that generates it we add the left side of the rule to the cell we are checking like AS from 3 line down to top beeing placed on the top of A S of the 2nd line
19:32:56 <Pseudonym> Ah, no, I was thinking of TinyOS.
19:33:12 <Pseudonym> Looks cool.
19:33:31 <dhpeterson> i have looked at quite a number of them for a thesis project i helped supervise
19:33:34 <dhpeterson> pico-os is the standout
19:34:03 * dhpeterson wonders how hard it would be to make ghc6 target the avr?
19:34:13 <dhpeterson> heh, embedded haskell
19:34:29 <dhpeterson> apt-get install ghc6-avr
19:34:29 <dhpeterson> :)
19:36:50 <SamB> Frederick: is this supposed to match for abaab or not?
19:38:08 <Frederick> SamB, the end ofthe process is supposed to match with S wich is the starting symbol it is a bottom up algorithm we start from the word and try to match rules against it instead of "derivate it"
19:38:34 <SamB> Frederick: I know that ;-)
19:38:34 <Pseudonym> That might help for the future, when I need to get bluetooth happening.
19:38:37 <Pseudonym> Thanks for the link.
19:38:51 <Frederick> SamB, so Ive missunderstood your question =/
19:38:54 <SamB> Frederick: I know what "dynamic programming" is
19:39:30 <SamB> oh, I think my problem is an "and" where an "or" is needed
19:40:34 <SamB> okay, now I'm getting matches ;-)
19:41:14 <Frederick> amuzing
19:42:36 <lisppaste2> SamB annotated #13842 with "the completed CYK algorithm" at http://paste.lisp.org/display/13842#1
19:43:14 <SamB> Frederick: okay, you seem to understand this algorithm better than I do ;-).
19:43:26 <SamB> hopefully you can understand what I wrote there also
19:44:03 <Frederick> SamB, in fact Ive teached the teacher this algorithm
19:44:18 <SamB> Frederick: oh really?
19:44:30 <SamB> Frederick: I guess the teacher knows you know it then, eh?
19:44:39 <Frederick> SamB, it is a new teacher she doesnt prepares the classes
19:44:46 <dhpeterson> anyone know of running hOp or house on embedded targets?
19:44:52 <Frederick> she takes all her material from another teacher couse
19:44:56 <Frederick> *course
19:45:22 <SamB> wow
19:45:22 <SamB> lazy!
19:45:34 <Frederick> SamB, how do I give input and run it?
19:46:07 <SamB> Frederick: something like this
19:46:17 <SamB> *CFG> let cnf = CNF 'S' (M.fromList [('S', [Seq 'A' 'A', Seq 'A' 'S', Term 'b']), ('A', [Seq 'S' 'A', Seq 'A' 'S', Term 'a'])])
19:46:17 <SamB> *CFG> cyk (intCnf cnf) "abaab"
19:46:21 <Frederick> SamB, it is missing the imports
19:46:43 <SamB> Frederick: did I import something new?
19:46:55 <SamB> Frederick: paste the error messages in an annotation
19:47:06 <Frederick> SamB, 1 sec
19:51:40 <lisppaste2> Frederick pasted "broken merge" at http://paste.lisp.org/display/13851
19:52:58 <SamB> Frederick: why is it complaining about CNF?
19:53:41 <SamB> Frederick: did you forget to include the CNF code?
19:53:58 <Frederick> SamB, I think Ive merged the worng code
19:54:04 <SamB> oh?
19:54:20 <SamB> see, this is why you should have set up a darcs repo at the beginning ;-)
19:55:22 <lisppaste2> Frederick pasted "?" at http://paste.lisp.org/display/13852
19:55:56 <SamB> Frederick: nearly there, now
19:56:22 <SamB> import Data.Array
19:56:44 <SamB> and add "fromMaybe" to the imports from Data.Maybe
19:57:22 <SamB> oh, wait, you haven't imported Data.Maybe yet ;-)
19:57:46 <SamB> import Data.Maybe (fromMaybe)
19:59:22 <Frederick> linked!
19:59:44 <SamB> hmm. you compile this stuff? what a concept!
20:00:31 <Frederick> but
20:01:02 <Frederick> cyk (intCnf cnf) "abaab" Main> cyk (intCnf cnf) "abaab"<interactive>:1:5: Not in scope: `intCnf'
20:01:34 <SamB> Frederick: did you miss that?
20:01:44 <SamB> go back to that and scroll up a bit
20:05:07 <Frederick> SamB, I cant find what Im missing
20:05:24 <SamB> http://paste.lisp.org/display/13842
20:05:43 <SamB> type "/intCnf" in firefox on that page and you'll go right to it
20:06:38 <skew> Hi svens
20:08:10 <Frederick> SamB, does this last code merges both CNF and CFG?
20:08:49 <skew> this is the grammar stuff you have been doing for some days now?
20:08:57 <SamB> Frederick: huh?
20:09:14 <SamB> I still use a different type for CNF...
20:11:26 <skew> where was were the webpages on that stuff again?
20:12:03 <SamB> skew: all over!
20:12:10 <SamB> I've been using wikipedia
20:12:18 <SamB> @wikipedia CNF
20:12:19 <lambdabot> http://en.wikipedia.org/wiki/CNF
20:12:22 <SamB> @wikipedia CYK
20:12:23 <lambdabot> http://en.wikipedia.org/wiki/CYK
20:12:47 <Frederick> SamB, I think it is rejecting instead of accepting :p
20:12:58 <SamB> Frederick: are you sure?
20:13:11 <Frederick> cyk (intCnf cnf) "abaab"
20:13:11 <Frederick> array ((1,1,1),(5,5,2)) [((1,1,1),True),((1,1,2),False),((1,2,1),*** Exception: (Array.!): undefined array element
20:13:27 <SamB> Frederick: are you using the latest cyk?
20:13:37 <SamB> because the one I pasted doesn't try to print an array
20:14:07 <SamB> and it never succeeded in printing to the end with a string longer than a single character
20:14:43 <SamB> oh, also note that there seems to be no provision for handling empty productions
20:15:26 <Frederick> SamB, works now
20:15:31 <Frederick> amuzing
20:16:04 <SamB> from what in particular do you derive amuzement?
20:16:31 <Frederick> SamB, brevity of the code
20:16:54 <SamB> yeah.
20:16:59 <SamB> that could use a bit of work
20:17:03 <SamB> its a bit TOO brief
20:17:16 <SamB> which is to say, horribly unreadable
20:17:29 <Frederick> SamB, in imperative languages it takes a lot of time to build fuctions and data structures
20:17:35 <SamB> yes.
20:17:41 <Frederick> in haskell you dont build them you compose the existing ones
20:17:56 <SamB> they could have called Haskell "data structural", but they probably thought that sounded too boring ;-)
20:18:38 <SamB> it should come as no surprise that functions are easy to build in functional languages
20:18:59 <Frederick> SamB, sure :p
20:19:14 <Frederick> but what amuses me is the level of abstration for data structures
20:19:22 * SamB wonders why C isn't called a segfaulting language
20:21:01 <Frederick> SamB, cause the funny part is when it doesnt segfaults but gives a wrong result
20:21:10 <Frederick> so the algorithm is broken then you have a big problem
20:22:13 <SamB> well, Haskell was apparantly made to translate mathematical things into, so it uses a mathematical approach to data structures. really, ML does almost the same thing, except that ML makes recursion harder because it is strict...
20:22:45 <SamB> oh, and ML's syntax is ugly
20:23:30 <Frederick> SamB, sure haskell is far more beautifull, I had 2 ML classes in university and ski helped me with them my teacher was lazy and that was freaking superficial
20:38:42 <Frederick> SamB, thx a lot I shall read the code tommorw gtg sleep 2:38 am here and I have class 8 am
20:38:45 <Frederick> thx ALOT
20:38:47 <Frederick> cya folks
21:01:04 <fworp> you cannot use class constraints with type synonyms can you?
21:03:40 <SamB> fworp: hmm, I had some trouble with that I think
21:04:10 <SamB> there really isn't a good reason why you shouldn't be allowed to, though, except that it just doesn't seem to work in HM...
21:04:19 <SamB> no idea if this is fixable or not
21:04:36 <skew> I think you can use type synonynms with classes just like you can anywhere else - just as if you wrote out the abbreviated type in full
21:04:45 <SamB> (without making a bigger mess)
21:05:13 <skew> allowing unrestricted lambdas at the type level kills decidability
21:05:30 <SamB> skew: well, I don't think you can put constraints on arguments of the new tyep consructor...
21:05:38 <Cale> You can use type synonyms with classes, but you can't make them do anything which you couldn't do by writing in what they represent, and at least in H98, type synonyms must always be fully applied.
21:06:03 <fworp> ghc rejects constraints between 'type' and the type name, and complains about type variable already being in scope when its a constraint on the rhs
21:06:24 <fworp> ah
21:06:25 <skew> I mean like Cale says, you get to use the abbreviations in class stuff too
21:06:26 <SamB> I mean, if you say type OrdList a = Ord a => [a], I don't think you can then say OrdList Int
21:06:47 <skew> you can't use it like a real data type
21:07:04 <Cale> use newtype if you want a new type
21:08:47 <skew> SamB: on that, I get the error "All of the type variables in the constraint `Ord a' are already in scope"
21:08:48 <Cale> and yeah, that's not a valid type synonym declaration
21:09:06 <SamB> Cale: which is annoying!
21:09:07 <skew> I'm not sure why it shouldn't be, though
21:09:32 <SamB> probably because you can't say Ord Int
21:09:52 <Cale> right
21:09:58 <skew> oh, that would do it
21:10:05 <skew> that's unfortunate
21:10:09 <SamB> but it would be nice if that were allowed!
21:10:17 <Cale> If anything, it would be, type Ord a => OrdList a = [a]
21:10:28 <SamB> well, whatever
21:10:29 <fworp> yeah, i dont really want a newtype, just shorthand for a long winded constraint
21:10:44 <skew> no, I think type Ord a = (OrdList a => [a]) is right
21:10:59 <skew> that way it looks more like it's just a synonym
21:11:02 <SamB> I don't care which is right, I just want it to work
21:11:04 <Cale> um, huh?
21:11:11 <fworp> lol, yeah
21:11:18 <skew> well, write the Simons about it then
21:11:45 <SamB> and if I do the wrong one, I want the compiler to suggest the right one instead of just giving me a cryptic error message
21:11:47 <Cale> how long is the constraint?
21:12:03 <skew> The constraint reduction machinery already weeds out things like Ord Int just fine when they come up because the typechecker figures out a had to be an Int
21:12:21 <skew> so I don't think it would be too hard to remove the check that stopped you writing the constraint in the first place
21:12:48 <skew> yeah, what's the type you are trying to abbreviate?
21:13:01 <skew> There are some other tricks you might use for tacking types onto things
21:13:27 <Cale> Well, it's a little strange, because it can mean that usage of type synonyms can imply class constraints which the user won't know about immediately.
21:13:29 <fworp> Sequence a Char, its not really that big of a deal, i just wouldnt mind having something like CharSeq a
21:13:34 <SamB> it was in my BF implementation I think
21:13:52 <skew> fworp: that's more of a constraint synonym
21:14:06 <fworp> right
21:14:07 <skew> and you can get that with something like class (Sequence a Char) => CharSeq a where {}
21:14:20 <SamB> @google BF "Control.Monad.State" site:paste.lisp.org
21:14:21 <lambdabot> http://paste.lisp.org/display/13015
21:14:32 <fworp> but then i have to instantiate a dumby class for each instance, right?
21:14:45 <SamB> there we go ;-)
21:14:52 <SamB> have at it ;-)
21:15:22 <skew> no, you just have a generic instance CharSeq a where {}, and the superclass constraint does the work
21:15:26 <SamB> C all the repeated (Storable a, Integral a) ?
21:16:03 <SamB> er, see?
21:16:09 <SamB> I need to go to bed now.
21:16:49 <SamB> I start talking like an AOL user *by accident*, when I never had the habbit in the first place...
21:17:12 <skew> or maybe it's class B a where {}, and then a single instance (A a) => B a where {}
21:18:58 <skew> ok - class (Sequence a Char) => CharSeq a where {} AND instance (Sequence a Char) => CharSeq a where {}
21:19:09 <skew> (you need -fallow-undecidable-instances for that)
21:19:36 <fworp> this module already needs them, so i can handle that, thanks
21:19:38 <skew> SamB: works for you too
21:20:05 <lispy> Korollary: did you find a job in seattle?
21:20:06 <skew> I think you can make a module just for the synonym if you don't want to compile the whole program with the option, also
21:20:16 <Korollary> lispy: Yes, that's why I am here.
21:23:24 <skew> what's the best way to restrict the domain of a Map to a given Set?
21:25:24 <lispy> in math you use intersection on the domain set ;)
21:25:35 * lispy hopes that made sense
21:25:49 <Korollary> Best way ? Is there 'a' way ?
21:26:06 <skew> sure, Map.filter (`Set.member` subDomain) mapping is one
21:26:34 <Korollary> oh, I thought you meant statically
21:27:17 <skew> oh, that's a bit harder
21:27:22 <Korollary> You can pretend and use a custom constructor that filters nonmembers.
21:27:41 <Cale> skew: that's probably the best you'll do for now, I wish there was something in the libraries for doing that.
21:28:22 <lispy> skew: i'd say the method you just proposed is pretty general given extensional sets, but what about sets that are defined by some (abstract?) properties?
21:28:35 <skew> lispy: given f : A -> B and a new domain C, don't you mean f \cap C x B ?
21:28:39 <Korollary> I guess that Omega paper (gadts + extended kinds) would allow somrthing like that.
21:28:53 <skew> or is f \cap C frequent abuse of notation?
21:29:10 <lispy> skew: i'm not familiar with f \cap C
21:29:11 <Cale> It's written f|C
21:29:29 <Cale> where | is sometimes a harpoon
21:29:38 <Cale> and C is sometimes subscript
21:29:45 <lispy> yeah, i've seen the harpoon thingy, usually in analysis classes
21:30:19 <skew> \cap is TeX for the usual intersection symbol
21:30:28 <skew> the upside-down U
21:30:34 <lispy> skew: BTW, i don't think you meant f \cap C x B, maybe you meant f : A \cap C -> B ?
21:30:47 <Korollary> mathml now!
21:30:50 <skew> no, I was thinking about treating f as a relation
21:31:15 <skew> as a subset of the cartesian product of domain and codomain
21:31:16 <lispy> oh
21:31:21 <lispy> yeah
21:31:44 <skew> anyway, my code was already explicitly using the membership predicate of the Set at the restriction
21:31:49 <Cale> Set theoretically, if you have a function f: A -> B, represented as a subset of AxB then the restriction f|C is given by f \cap CxB : C -> B
21:32:02 <lispy> why not say, given f : A -> B and a subset C of A, define g : C -> B by c |-> f(c)
21:32:23 <skew> sure, you can do that too
21:32:55 <skew> but it's not taking as much advantage of the set theoretic defitions as you could
21:33:03 <Cale> ah, yeah, it has to be a subset as well, or the restriction as defined my way will fail to be a function
21:33:20 <skew> and on the other hand, it's trickier to prove in set theory that you can define g that way
21:33:42 <lispy> skew: eh?
21:33:44 <skew> you have to use extensionality and stuff, but production and intersection are things you are assuming as axioms
21:34:49 <lispy> is Set.member overloadable?
21:35:05 <Cale> in what sense?
21:35:06 <Korollary> It already is
21:35:29 <lispy> is there a typeclass that it is defined for?
21:35:32 <Cale> no
21:35:41 <Cale> @type Set.member
21:35:42 <lambdabot> Couldn't find qualified module.
21:35:42 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
21:35:42 <lambdabot> \\)?
21:35:47 <Cale> @type Data.Set.member
21:35:48 <lambdabot> forall a. (Ord a) => a -> Data.Set.Set a -> Bool
21:36:25 <lispy> so....Data.Set.Set must know all of it's elements explicitly?
21:36:35 <Cale> yeah
21:36:44 <Cale> they're finite sets represented using balanced trees
21:36:50 <lispy> ah
21:37:03 <lispy> so the weird thing i was worried about isn't even really possible
21:37:14 <lispy> at least not with out a new set type
21:37:55 <Cale> You can define sets as predicates, but they lose that nice enumerability
21:38:06 <lispy> yeah
21:38:21 <lispy> well, in some cases
21:38:26 <Cale> yeah
21:38:48 <lispy> a list comprehension would still be enumerable
21:39:13 <lispy> but that's usually a generator with a predicate
21:42:55 <skew> my favorite notation from set theory comes from the definition of the integers as n = {0,1,..,n-1}, and 0 is the emptyset
21:43:12 <skew> then you write things like sum over i in n
21:44:01 <Cale> n+1 = n union {n}
21:45:24 <Cale> of course you mean the naturals -- the integers are fairly nice too
21:46:46 <Cale> you define the integers as pairs of natural numbers under the equivalence relation that (a,b) ~ (c,d) if a + d = b + c
21:48:03 <lispy> uh
21:48:06 <lispy> integers?
21:48:09 <lispy> hmm...
21:48:30 <Cale> and of course, (a,b) + (c,d) = (a+c,b+d)
21:49:10 <lispy> it looks similar to the rationals when you do it that way
21:49:21 <Cale> and (a,b) (c,d) = (ac + bd, bc + ad)
21:49:32 <Cale> yeah, it is similar
21:49:38 <Cale> also similar to the complex numbers
21:49:48 <lispy> ah true
21:49:59 <Cale> it's going from the rationals to the real numbers that's the hardest step :)
21:50:02 <lispy> and the quaternions? ;)
21:50:08 <Cale> yeah
21:51:06 <lispy> what was the definition of the reals again?  the _____ closure of the rationals...what was that word
21:51:54 <Cale> metric completion
21:52:14 <lispy> okay, maybe that's what i was thinking of
21:52:33 <Cale> the complex numbers are the algebraic closure of the reals
21:52:33 <lispy> because the reals contains the rationals and all the limits of all the sequences in the rationals
21:53:02 <Cale> yeah, it's possible to define the reals as the unique complete ordered field
21:53:21 <Cale> but that still leaves you wondering whether such a field exists at all
21:53:43 <Cale> there are two (or three) popular concrete constructions of them
21:54:14 <lispy> well, certainly the reals are not real
21:54:30 <Cale> Defining real numbers as Dedekind cuts of rationals, or defining them as equivalence classes of Cauchy sequences of rationals.
21:54:31 <lispy> i only believe in the empty set ;)
21:55:06 <lispy> seems like we talked about Cauchy sequences of rationals when i was in analysis but didn't go through the whole construction
21:56:29 <Cale> You say that two Cauchy sequences {x_n} and {y_n} are equivalent if for any e > 0, there is some N such that if n > N, you have |x_n - y_n| < e.
21:57:06 <Cale> e ranging over positive rationals
21:57:21 <Cale> and Cauchy sequence being defined as usual except using the rationals as well
21:58:19 <Cale> Then the operations are easy, you just define addition and multiplication to work like zipWith (+) and zipWith (*) :)
21:58:39 <lispy> hehe
21:59:06 <Cale> you have to show that they're well-defined, but that's an easy-enough exercise :)
21:59:17 <Cale> (I recall doing that in Calc 1 in fact)
21:59:59 <Cale> We spent the first half of Calc 1 talking about sequences.
22:01:38 <lispy> thats' good
22:01:44 <lispy> since analysis is all about sequences
22:01:46 <Cale> You can also define the reals using sequences of (decimal, say) digits under an equivalence relation which identifies sequences which identify a sequence ending in all 9's with one which ends in all 0's but has had the digit just before the repetition incremented.
22:01:54 <Cale> er
22:02:04 <lispy> hmm
22:02:07 <Cale> -spurious extra words :)
22:02:10 <lispy> that sounds like something cantor would try
22:02:21 <Cale> It's not so pretty
22:03:07 <Cale> Makes it hard to prove the properties of + and *, or even really to properly define them, what with carries.
22:03:41 <Cale> You can do it, it's just ugly :)
22:04:00 <Cale> myself, I prefer the axiomatic treatment, together with the understanding that there's a model
22:05:02 <Cale> Just enumerate the properties of a field, an ordered field, and then the least upper bound property, or something else which is equivalent to completeness :)
22:05:14 <lispy> yeah
22:05:36 <lispy> that's the way we studied them in my first term of advance calc (sort of an intro to analysis)
22:07:41 <dons> hey! [Haskell] ANNOUNCE: Frag: a First Person Shooting game
22:07:55 <dons> @where+ frag http://www.cse.unsw.edu.au/~pls/repos/frag
22:07:55 <lambdabot> frag ~> http://www.cse.unsw.edu.au/~pls/repos/frag
22:08:38 <stefanw> boa, Frag sounds interesting. Seems worth hacking on it!
22:09:07 <dons> hehe
22:09:44 <Cale> wow, cool :)
22:10:18 <Cale> how does it run? :)
22:10:59 <dons> how? quickly!
22:11:17 <dons> mm. should get some screenshots up maybe
22:11:31 <Cale> :)
22:11:40 * Cale darcs gets
22:13:10 * dons thinks Cale actually lives in .au somewhere, considering the local time
22:13:35 <Cale> heh
22:14:15 <Cale> might be visiting Melbourne at some point
22:14:37 <dons> cool!
22:14:53 <dons> you won't have any jet lag ;)
22:15:25 <Cale> :)
22:16:07 <Korollary> ugh
22:16:15 <Korollary> @localtime dons
22:16:17 <lambdabot> Local time for dons is Tue Nov 22 17:10:40 2005
22:16:21 <Korollary> @localtime Cale
22:16:32 <Korollary> ...
22:17:07 <lambdabot> Local time for Cale is Tue Nov 22 01:16:41
22:17:09 <Korollary> well, 8 hours I think
22:17:37 <Cale> It was funny when Wolfgang (Thaller) came to McMaster and had jet lag, and Chris, our supervisor, managed to convince him to take a 20 mile bike ride carrying a bunch of stuff.
22:17:57 <dons> argh. poor wolfangt
22:18:00 <Korollary> that is cruel
22:18:18 <dons> oh, I met chris, I think
22:18:24 <dons> at Tallinn.
22:19:05 <Cale> Christopher Anand?
22:19:14 <Cale> (Dr.)
22:19:29 <dons> hmm. some guy called Chris who was at McMaster and worked with Wolfgang?
22:19:35 <dons> was Wolfgang's boss?
22:19:43 <Korollary> google his ass
22:20:37 <Cale> yeah
22:21:01 <Cale> The reason he gave was that it's good to really tire yourself out, so you'll be able to sleep a long time, and wake up refreshed. Hehe, sort of ignoring the fact that he was already really tired, but Chris is a pretty convincing guy. :)
22:21:33 <dons> hehe
22:22:31 <Cale> He has to be, he's working on a somewhat insane project (but pretty cool nonetheless)
22:22:38 <Korollary> that actually does work
22:23:16 <Korollary> instead of 2 weird days, you have just one, truly miserable day.
22:23:34 <dons> is this the compiler with the powerpc backend?
22:23:44 <dons> for some weird language?
22:24:40 <Cale> The idea is to have a declarative language for signal processing, which gets compiled down to incredibly efficient assembly, automatically parallelised to run on multiple machines over a network.
22:24:41 <Cale> yeah
22:24:55 <Cale> I was working on a pipeline scheduler for the powerpc backend.
22:25:10 <Cale> (and a register allocator too)
22:25:22 <dons> ah, right. that's it.
22:26:28 <dbremner> Cale - have you heard of Spiral?
22:27:22 <Cale> dbremner: no, though it does look related
22:31:15 <dbremner> Cale - it's not distributed, but it's still a neat idea. 
22:33:45 <sjanssen> any guesses on the integer type that Frag uses for player's position coordinates?
22:33:58 <sjanssen> I seem to have fallen off the map, wondering how far I can go ;)
22:33:59 <Cale> yeah, the summary paper looks cool :)
22:34:23 <dons> sjanssen, so it works nicely?
22:34:31 <dons> I'll tell Mun. he'll be happy to know
22:34:38 <sjanssen> dons: yes, very well
22:35:34 <Cale> quite nice :)
22:35:50 <Cale> works for me too :)
22:35:50 <dons> Cale, also builds with no problem?
22:35:55 <dons> excellent.
22:36:09 <skew> I seem to not have hopengl installed
22:36:44 <Cale> It doesn't like to be switched out with other apps though :)
22:37:14 <bmedwar_> frag built and plays well for me on windows
22:37:20 <dons> cool!
22:38:07 <dons> anyone can take some screenshots?
22:38:14 <dons> I'll stick up a webpage.
22:38:50 <lispy> dons: did you get a flood of haskell survey takers?
22:39:07 <dons> not sure. it wasn't my survery after all. It was john hughes'
22:39:18 <lispy> ah
22:39:20 <dons> hopefully though. I think we can manage at least 1k users out there 
22:39:29 <dons> who'll actually complete a survery
22:39:58 <lispy> i posted it to a maillist that reaches all of our grad students
22:40:07 <lispy> and someone on the list posted to their old school's list
22:40:08 <dons> @karma+ lispy
22:40:08 <lambdabot> lispy's karma raised to 2.
22:40:29 <lispy> w00t!  i'm at 2
22:41:20 <dons> sjanssen, bmedwar_, Cale, can you take a screenshot?
22:41:48 <dons> then tell me the url, I'll grab it and start a page on the haskell wiki. Mun (the author) doesn't have any webspace, I think.
22:42:13 <dbremner> Cale - is there a website for the project you mentioned?
22:42:14 <lispy> dons: they are obviously too busy adding network play ;)
22:42:21 <dons> seems so!
22:43:12 <lispy> i should reboot and try to darcs it
22:43:26 <lispy> it seems that my windows install is tool-lens
22:43:29 <lispy> er tool-less
22:43:40 <lispy> eg. no darcs and no ghc
22:43:57 <skew> I got it and built it, but it doesn't like my (lack-of) GL - I
22:44:07 <skew> I'm going to try fiddling with X and rebooting
22:44:10 <Cale> http://www.cas.mcmaster.ca/~anand/ -- Coconut
22:45:40 <dbremner> Cale - neat, thanks.
22:46:23 <dons> anyone got a screenshot I can grab?
22:46:39 <dons> xwd -out frag.xpm -frame  will do..
22:47:04 <araujo> Hello!!!
22:47:18 <dons> hey araujo
22:48:12 <araujo> dons, How you doing bud?
22:48:23 <dons> :) ok
22:49:29 <skew> well, it seems that FRAG does not run if you don't have proper GL support
22:49:40 <dons> as it says in the readme..
22:49:41 <dons> ;)
22:49:56 <dons> but skew's first job is now to port it to aalib ;)
22:50:01 <skew> and also that detached screen sessions will survive C-M-Backspace, so I don't need to pop in and out
22:53:27 <lispy> dons: how do you take the screen shot?
22:53:50 <dons> xwd -out foo.xpm -frame   is one way, I think there are others.
22:54:03 <lispy> hmm...
22:54:23 <lispy> Oh
22:54:41 <lispy> that's not right
22:54:50 <lispy> it did create something
22:55:07 <sjanssen> dons: I don't think the output format is actually XPM
22:55:14 <lispy> but, that something is an image of a piece of papre that is torn with a red x
22:55:34 <lispy> but maybe that is a problem with my image viewer
22:55:57 <dons> paprika$ file hmp3.xpm 
22:55:58 <dons> hmp3.xpm: XWD X Window Dump image data, "xwdump", 766x480x24
22:56:21 <lispy> yeah, it looks right in gimp
22:56:33 <lispy> but gqview shows it funny
22:56:34 <dons> save it as a .png in gimp, and send me the url.
22:56:46 <dons> i'll copy it over here, and link to it on the hawiki page
22:56:46 <lispy> well,i have to wait for it to compile firest
22:57:02 <lispy> i was testing the screen shot thingy first
22:58:08 <lispy> GHC is not a fast compiler
23:03:37 <dons> @hawiki Frag
23:03:38 <lambdabot> http://www.haskell.org/hawiki/Frag
23:03:55 <dons> add screenshots, please!
23:04:39 <sjanssen> I have some PNGs, but I probably shouldn't host them from my webspace
23:05:06 <dons> do you have a url? I can copy them over to cse.unsw.edu.au
23:05:20 <sjanssen> yeah, one moment
23:05:54 <dons> @karma+ sjanssen
23:05:54 <lambdabot> sjanssen's karma raised to 1.
23:05:56 <skew> ok, seems to work now that I have video drivers.
23:06:01 <skew> a mouse would help, though
23:06:17 <dons> skew's next patch: keyboard-only mode
23:06:32 <skew> perfect for all the ion users out there
23:06:46 <dons> like me :) and tuomov ;)
23:08:03 <skew> Is the sky supposed to be plain white?
23:08:39 <sjanssen> http://cse.unl.edu/~sjanssen/frag0.png -- also frag1.png .. frag4.png
23:09:13 <sjanssen> there are two decent shots in there
23:09:45 <lispy> dons: http://files.codersbase.com/tmp/
23:10:00 <lispy> my favorite is #3 since it shows that i killed a bot!
23:10:00 <dons> sjanssen, got it. cheers! http://www.cse.unsw.edu.au/~dons/images/frag/
23:10:10 <dons> lispy, great!
23:10:16 <skew> sjanssen: so are you seeing some things as plain white too?
23:10:33 <lispy> i found several missing features/bugs
23:10:36 <lispy> you can't jump
23:10:39 <skew> hmm, looks like I need to patch it a bit...
23:10:44 <skew> 'e' works fine for me
23:10:46 <sjanssen> lispy: jumping worked for me
23:10:47 <lispy> i fell in a big hole, sometimes i would just keep walking...
23:11:02 <lispy> oh, maybe i just used the wrong button
23:11:10 <dons> so basically this guy wrote this whole thing in 10 weeks for his undergrad thesis, but is leaving now, and was not going to publish it.
23:11:20 <lispy> wow, nice
23:11:21 <dons> but we got it in darcs, and its free for all!
23:11:29 <dons> but we'll have to maintain it ourselves, basically
23:11:30 <skew> now, there are big holes you can fall in and not get out of, but that's a bug in level design
23:11:51 <dons> so I'm hosting it, and probably will start taking patches when Mun leaves in a few weeks
23:12:02 <Korollary> Where's the artwork from ?
23:12:14 <lispy> Korollary: looks to be quake3 to me
23:12:17 <dons> from Quake, they have free stuff on their site.
23:12:37 <lispy> open source games need open source artists
23:12:52 <dons> lispy, got the .pngs now. thanks!
23:12:56 <dons> @karma+ lispy
23:12:56 <lambdabot> lispy's karma raised to 3.
23:13:06 <lispy> dons: make sure to get Muns to stick a GPL or BSD on it (if (s)he hasn't already)
23:13:34 <lispy> w00t! level 3
23:13:47 <dons> right. it is GPL. but he only learnt about licenses yesterday :)
23:13:52 <lispy> hehe
23:13:57 <lispy> well, i'm off to bed
23:14:00 <lispy> night all
23:14:06 <dons> night lispy
23:18:50 <lispy> dons: did this student use the quake3 source code as a reference?
23:19:01 <lispy> that's really impressive to do that much of the game in 10 weeks
23:19:24 <lispy> in ten weeks i'm usually so busy on random stuff that i can't get much of anything done
23:19:40 <lispy> oh wait
23:19:42 <lispy> i said i was going to bed
23:19:48 * lispy waves
23:20:43 <dons> it's pretty amazing. i don't think he referenced quake source or such though
23:21:54 <Korollary> what's the rendering engine ?
23:22:55 <dons> not sure. check the src :)
23:24:50 <dons> screen shots are now up :)
23:24:56 <dons> @wiki Frag
23:24:56 <lambdabot> http://www.haskell.org/hawiki/Frag
23:25:56 <ChilliX> Korollary: BSP-based OpenGL renderer
23:26:15 <Korollary> ChilliX: Thanks
23:26:38 <gaal_> shapr: I'm currently a little overcommitted, so not right now... but thanks a lot for the offer! :-)
23:46:23 <palomer> oh crap
23:46:26 <palomer> I have a bad cold
23:50:03 <boegel> heh, the Frag thing is cool :)
23:51:31 <boegel> dons: you should ask that student of yours to write a TMR article on Frag !
23:52:16 <dons> hmm! Chilli's student ;)
23:52:39 <dons> I wonder... I'll ask him.
23:55:19 <boegel> dons: that'd be _really_ cool :)
