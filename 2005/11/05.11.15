00:09:34 <tuomov> stefanw: no
00:10:39 <tuomov> I haven't actually tried a version compiled with recent ghc, though, as all the package stuff on my system is a complete mess
00:11:08 <tuomov> every apt-get upgrade breaks hsplugins and hscurses totally
00:11:24 <tuomov> after I've spend an hour un-hiding them after the previous upgrade
00:13:46 <stefanw> ok, it seems that the error occurs only with ghc6.4.1. I'll built a profiled version of riot, but first I have to enable profiling for hscurses. I don't think it's a riot bug (because riot is single-threaded, isn't it), maybe a RTS problem
00:14:58 <tuomov> riot itself doesn't use threads, iirc, but something it calls might use
00:23:25 <boegel> yo Itkovian 
00:23:53 <Itkovian> hi boegel
00:24:05 <boegel> I'm almost all alone here
00:24:09 * Itkovian just woke up. not at all according to plan
00:25:09 <tuomov> Setup.hs:8:19:
00:25:09 <tuomov>     Couldn't match `IO GHC.IOBase.ExitCode' against `t -> t1'
00:25:15 <tuomov> from trying to build hs-plugins, btw
00:30:23 <tomaszz> boegel: me too :-)
00:31:42 <boegel> tomaszz: is it a royal holiday for you too then ? :P
00:36:01 <tomaszz> boegel: not exactly, I have some deadlines :-(
00:36:38 <boegel> tomaszz: oh, I see
00:37:02 <boegel> well, officially it's a holiday today, but my gf needed to be in Ghent, and I didn't feel like taking a holiday today
00:47:43 <kzm> good morning
00:47:55 <kzm> @seen shapr
00:47:56 <lambdabot> shapr is in #haskell-blah and #haskell. Last spoke 7 hours, 8 minutes and
00:47:56 <lambdabot> 36 seconds ago.
00:48:28 <ibid> shapr: if tmr is still interested, i may be able to write the algebraic specification & haskell thingy in december, after this course ends
00:49:09 <kzm> haskell-blah(?)
00:49:44 <basti_> whats bad about haskell-blah?
00:50:51 <kzm> Just that I didn't know about it, I guess.  That, and that the mix of...well, subjects is slightly original.
00:50:53 <kzm> :-)
00:52:45 <ibid> -blah is apparently for general chit-chat among #haskellers
00:53:09 <ibid> -overflow is for detailed technical discussion that would otherwise make this channel unusable for others
00:53:12 <ibid> i think :)
00:53:37 * vegai concurs.
00:53:42 <basti_> that's the gospel at least ;)
00:54:22 <vegai> we need -reeducation
00:54:35 <vegai> where people with imperative tendencies are fed haskell slogans 24h a day
00:55:04 <basti_> hmm
00:55:12 <vegai> there should be a channel flag that denies the use of quit and part  :)
00:55:21 <basti_> ^^
00:55:37 <basti_> you mean for megzl and the like?
00:57:40 <vegai> oh, I wasn't familiar with that celebrity
00:58:11 <basti_> you would have had enjoyed him
00:58:46 <basti_> "so how do i do <3d stuff> in haskell?" "why doesn't it work like in C++?" "why DOES it work like in C++"
00:58:49 <basti_> etc.
00:58:51 <basti_> ;)
00:59:04 <vegai> heh
01:00:53 <boegel> strange how fast someone can get famous :)
01:01:25 <pejo> boegel: Peter's placebo: An ounce of image is worth a pound of performance. 
01:02:06 <pejo> (Unfortunately it's another Peter, but still. It helps to improve my image).
01:02:59 <boegel> "i'm now write documention about Template Haskell in MS Word." :|
01:08:39 <sethk> anyone have any experience running haskell programs without an operating system?
01:10:28 <ski> house and hOp ?
01:10:50 <sethk> ski, don't know them
01:11:38 <ski> http://www.cse.ogi.edu/~hallgren/House/
01:11:44 <ski> @where house
01:11:44 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
01:11:50 <ski> right
01:12:37 <ski> @where hOp
01:12:38 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
01:13:22 <pejo> sethk, going for embedded systems and similar?
01:13:27 <dbremner> sethk - have you considered Forth or Tcl?
01:13:37 <sethk> well, not exactly relevant but it has useful information
01:13:46 <sethk> dbremner, of course, I write embedded systems all the time
01:14:12 <sethk> I was wondering about what people might have done in haskell, which hOp appears to be relevent to
01:15:41 <sethk> it's not the kind of thing I need to do, but it is a self contained binary image, which gives me a starting point, just to see if it might be an interesting approach
01:21:22 <dons> check out House. the successor to hOp. also just haskell on bare metal.
01:25:22 <sethk> dons, where do I find it?  
01:25:40 <sethk> dons, I see a note on the house web page about an L4 compatible microkernel
01:28:07 <ulfdoz> Hm, what is type of some b in [b..]?
01:28:22 <boegel> ulfdoz: can be anything
01:28:36 <boegel> @eval take 3 [1..] :: [Int]
01:28:37 <lambdabot> [1,2,3]
01:28:40 <boegel> @eval take 3 [1..] :: [Float]
01:28:41 <lambdabot> [1.0,2.0,3.0]
01:28:48 <boegel> @eval take 3 [1..] :: [Char]
01:28:49 <lambdabot>  add an instance declaration for (Num Char)
01:28:50 <ski> @type \b -> [b..]
01:28:51 <lambdabot> forall a. (Enum a) => a -> [a]
01:28:52 <boegel> thought so :)
01:28:53 <thou> @where lisppaste
01:28:53 <lambdabot> I know nothing about lisppaste.
01:29:00 <thou> @lisppaste
01:29:01 <lambdabot> Unknown command, try @listcommands.
01:29:08 <ulfdoz> boegel: I have an user-defined type. Is it enough, when I have pred and succ from Enum?
01:29:12 <boegel> lisppaste: where
01:29:26 <ski> pastpaste.lisp.org seems down ..
01:29:29 <boegel> ulfdoz: not sure
01:29:38 <ski> * paste.lisp.org seems down ..
01:29:41 <thou> ok
01:29:49 <dons> sethk, there's been a couple of papers at the last two haskell workshops, and at this year's ICFP 
01:29:54 <boegel> I'm guessing you need everything in the Enum class
01:30:17 <sethk> dons, thanks, I'll try to track them down.  So you think it is something I can consider for a real life (as in getting paid to do) project?
01:30:31 <dons> hmm. pretty hard.
01:30:41 <sethk> dons, hard to decide, or hard to do?
01:30:50 <dons> though I think there's been some work on using haskell (or other fp langs) to verify hardware
01:31:07 <dons> I think maybe the Chalmers guys have done this. and ibm has some in-house fp lang for hardware
01:31:53 <dons> hard to do, depnds on how portable House is, I reckon
01:31:57 <sethk> dons, there is analysis of the data I'll collect from the hardware testing, and I see haskell doing very well there.  Not sure about the actual testing side, though.
01:32:10 <sethk> dons, fortunately the hardware is not too far from stock x86
01:32:18 <dons> ah! well maybe then.
01:32:31 <ski> "-- Minimal complete definition: toEnum, fromEnum"
01:32:39 <dons> you'd boot up the ghc rts on the hardware, and have some custom driver that probes the harware.
01:32:46 <sethk> dons, but it has on chip encryption and new ethernet hardware that I have to write drivers for
01:32:59 <dons> yeah.
01:33:04 <sethk> dons, which is in a way good, because even if I use more conventional approaches I still have to tackle the ethernet hardware
01:33:13 <sethk> dons, so it wouldn't necessarily be any harder in haskell
01:34:18 <sethk> dons, I'll have to look at house, etc., and see how they handle writing to memory mapped control registers, and such things
01:36:47 <dons> once it was booted you'd be set.
01:36:56 <dons> so I'd email the house guys about what they think.
01:37:03 <tuomov> dons: any idea re me@10:24 (now 11:36)?
01:37:24 <dons> (I've seen House booted on a thinkpad,whcih is cool)
01:37:30 <thou> hi, i have a question about making a function splitEither :: [Either a b] -> ([a], [b]) lazy:  http://pastebin.com/430119
01:37:38 <dons> tuomov, 11:36 what timezone?
01:38:13 <tuomov> doesn't matter, 11:36-10:24 ago
01:38:13 <dons> @localtime tuomov
01:38:16 <lambdabot> Local time for tuomov is Tue Nov 15 11:37:52 2005
01:38:21 <mauke> @hoogle [a] -> ([b], [c])
01:38:22 <lambdabot> No matches, try a more general search
01:38:34 <sethk> dons, I'll definitely do that (email house).  Thanks for the pointer.
01:38:52 <dons> oh, the hs-plugins error?
01:38:56 <tuomov> yeah
01:39:06 <dons> yes. comment out the 'xxx' arg in Setup.hs
01:39:13 <dons> you're using an older Cabal than I am.
01:39:54 <ski> thou : why do you pass down an (), just to discard it at bottom ?
01:40:02 <dblhelix> should cabal package names begin with an uppercase letter?
01:40:48 <mauke> @type foldr (\x (a, b) -> case x of {Left l -> (l:a, b); Right r -> (a, r:b)}) ([], [])
01:40:49 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
01:41:12 <thou> ski: erm... i was confused, trying to delay the function application
01:41:59 <sethk> and ski, thanks also for the pointer to house.h0p
01:41:59 <Lemmih> dblhelix: Have a look at `ghc-pkg list`.
01:42:27 <thou> ski: i was trying to copy something vaguely from the tying the knot wiki page
01:42:53 <dblhelix> Lemmih: thanks... big day for me: first time I get my hands dirty with cabal stuff... to all of you: be prepared to receive questions ;)
01:43:02 <ski> you shouldn't need to tie circular knot, here ..
01:43:51 <dblhelix> Lemmih: what about the parenthesized package names?
01:44:04 <tomaszz> Lemmih: did you find my DNS code useful?
01:45:50 <thou> mauke: i started out with something like that, but get a stack overflow (even when i compile with ghc -O)
01:46:17 <tuomov> hmm.. hsplugins/cabal seems to install stuff with wrong permissions
01:46:31 <tuomov> only root has read access
01:46:48 <dons> weird.
01:47:11 <dons> hsa the correct perms here.
01:47:24 <dons> are you sudo-ing?
01:47:59 <tuomov> su-ing, umask gets changed to 022 for root
01:48:09 <tuomov> so it shouldn't be that
01:48:36 <tuomov> maybe it's been fixed if this is an old version
01:48:48 <tuomov> (whatever debian/unstable has)
01:48:52 <ski> a-ha !
01:48:53 <ski> > let foo = foldr (\x (a, b) -> case x of {Left l -> (l:a, b); Right r -> (a, r:b)}) ([], []); (x,y) = foo (map (\x -> if even x then Left x else Right x) [0..]) in take 10 x
01:48:55 <lambdabot> Stack overflow
01:48:58 <ski> > let foo = foldr (\x ~(a, b) -> case x of {Left l -> (l:a, b); Right r -> (a, r:b)}) ([], []); (x,y) = foo (map (\x -> if even x then Left x else Right x) [0..]) in take 10 x
01:48:59 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
01:49:09 <tuomov> it still didn't help fixing the permissions, though
01:49:13 <ski> thou,mauke : see
01:49:19 <tuomov> ld: cannot find -lHSplugins-0.9.10
01:50:25 <tuomov> sigh. build systems are a mess. especially makefile-based ones.
01:50:45 <dons> are you not using the darcs hs-plugins?
01:51:04 <tuomov> I'm using it. this was from trying to build riot.
01:52:32 <tuomov> ghc -o riot_   -package plugins -package posix -DLIBDIR=\"/usr/local/lib/riot\" Boot.o Riot/BootAPI.o
01:52:50 <tuomov> that command ends in that error
01:53:34 <dons> hmm.
01:53:35 <tuomov> It seems that ghc knows of the package and so on, but it doesn't pass the proper parameters to ld
01:54:07 <Lemmih> dblhelix: Those packages are hidden.
01:54:18 <dblhelix> Lemmih: tnx
01:54:21 <Lemmih> tomaszz: Haven't had much time to look at it.
01:54:56 <thou> ski: wow
01:55:16 <thou> ski: i must think about that for a little bit :)
01:55:18 <mauke> > let foo = foldr (\x y -> case x of {Left l -> (l:fst y, snd y); Right r -> (fst y, r:snd y)}) ([], []); (x,y) = foo (map (\x -> if even x then Left x else Right x) [0..]) in take 10 x
01:55:20 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
01:55:38 <|Lupin|> Hello, guys. Just a quick question: is there an Haskell equivalent to the basename and dirname functions found in many other programming languages ?
01:55:55 <boegel> |Lupin|: you can use regex's
01:56:05 <boegel> |Lupin|: or break
01:56:10 <|Lupin|> break ?
01:56:21 <boegel> @eval break "file.ext"
01:56:23 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
01:56:25 <|Lupin|> boegel: regexps are not very portable, though...
01:56:35 <mauke> @type break
01:56:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:56:37 <boegel> @tpye break
01:56:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:56:40 <Lemmih> |Lupin|: Yes, in the FilePath library. darcs repo: http://scannedinavian.org/~lemmih/FilePath
01:56:52 <boegel> @eval break (=='.') "file.ext"
01:56:53 <lambdabot> ("file",".ext")
01:57:00 <boegel> @eval fst $ break (=='.') "file.ext"
01:57:02 <lambdabot> "file"
01:57:11 <thou> ski: thank you....
01:57:14 <thou> mauke: thanks!
01:57:51 <mauke> @eval break (== '.') "perl-v5.8.zip"
01:57:52 <lambdabot> ("perl-v5",".8.zip")
01:58:44 <Lemmih> Prelude> System.FilePath.splitFilePath "/home/user/perl-v5.8.zip"
01:58:44 <Lemmih> ("/home/user","perl-v5.8","zip")
01:58:52 <|Lupin|> Lemmih: many many thanks !
02:00:31 <flux__> hmm.. how does it differentiate between foo. and foo? ("", "foo", ""), ("", "foo.", "") ?
02:00:58 <mauke> and what happens to ".bashrc"?
02:01:45 <flux__> (I suppose that's some 6.5-package as it doesn't work with my 6.4.1)
02:02:51 <Lemmih> It should with everything from GHC-6.2 to 6.5.
02:03:15 <boegel> mauke: okay, that was a bit short-sighter of me :) I'm sorry
02:16:39 <dblhelix> anyone any comments on using uuag and cabal? tips? references?
02:19:41 <mardy> we get a strange error when trying to compile a haskell/c++ program. The problem seems to be compiler related, the g++ and ghc versions don´t like each other. What versions should work? We would like to keep ghc 6.4.0. What version of g++ should we use?
02:23:49 <shapr> ibid: sure, yeah
02:26:50 <|Lupin|> bye, everybody. And thanks again for your help !
02:29:39 <Lemmih> mardy: What errors?
02:30:12 <earthy> mardy: g++ 3.3
02:33:03 <kzm> Anybody know how .boot files are used?
02:33:29 <kzm> I.e. if they change, do I record the changes?
02:33:40 <kzm> (record, as in "darcs record" of course)
02:33:58 <Lemmih> Yes.
02:34:54 <kzm> @msg Philippa_ hi!  I'm digging into flippi atm!
02:34:55 <lambdabot> Not enough privileges
02:35:05 * kzm blushes.
02:35:45 <boegel> kzm: whahaha :) you're trying to secude Philippa_ or something ? good luck ! :D
02:36:04 <kzm> not quite - that would be on the -blah channel.
02:36:31 <boegel> you're doing it private
02:36:39 <boegel> or atleast, trying to do it private :P
02:37:16 * kzm could of course brag about his big keyboard.  (In fact, so large that he can't find the / key)
02:37:42 <kzm> But it probably wouldn't work.
02:38:02 <wilx> You never know what will impresses the woman :D
02:38:39 <kzm> Heh.
02:39:55 <kzm> Philippa_?  I have some questions on flippi.  Technical ones, honestly.
02:41:05 * kzm sighs.
02:41:59 <kzm> @seen shapr
02:42:00 <lambdabot> shapr is in #haskell-blah and #haskell. Last spoke 17 minutes and 56
02:42:00 <lambdabot> seconds ago.
02:42:33 <kzm> shapr?
02:43:23 <kzm> Anybody else look at the flippi code?
02:43:36 * kzm probably will actually have to try to understand it on his own.
02:43:43 <earthy> @get-shapr
02:43:43 <lambdabot> shapr!!
02:44:28 * kzm would be very interested to see the commit logs to \bot.
02:44:42 <kzm> Seems to grow functionality as we type.
02:45:24 <joelr1> @paste
02:45:25 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:45:43 <svens> hmm, whats the fastest/easiest way to read a defined count of chars from a handle?
02:46:40 <joelr1> howdy y'all
02:48:03 <joelr1> can someone please help with my paste?
02:48:12 <earthy> svens: hGetBuf
02:48:20 <kzm> just squeeze the tube
02:48:22 <earthy> and then convert the data at the Ptr to chars
02:48:31 <kzm> (sorry)
02:49:04 <svens> earthy: hmm, i find this Ptr a annoying ;)
02:49:29 <earthy> you could also look at the fps library
02:50:51 <svens> ok, i'll check this out
02:51:31 <earthy> or use  sequence (repeat count (hGetChar handle))
02:57:56 <Itkovian>      91 bibtexEntry :: Parser (Maybe (BibTexType BibTexInformation))
02:57:56 <Itkovian>      92 bibtexEntry = do  { string "@"
02:57:56 <Itkovian>      93                   ; b <-     (try proceedings) <|> (try article) <|> (try book)
02:58:00 <Itkovian>      94                   ; return b
02:58:02 <Itkovian>      95                   }
02:58:15 <Itkovian> seems not to work, when proceedings fails, it seems to refuse to try article
02:58:23 <Itkovian> if I replace proceedings by article it works fine
02:58:28 <Itkovian> on my example
02:58:52 <Itkovian> however,  parse (do { string "c"; d <- (try (char 'a')) <|> (try (char 'b')); return (Data.Char.toUpper d) } <?> "oops") "" "ca"
02:58:55 <Itkovian> Right 'A'
02:58:58 <Itkovian> works fine
02:59:03 <Itkovian> Prelude Text.ParserCombinators.Parsec> parse (do { string "c"; d <- (try (char 'a')) <|> (try (char 'b')); return (Data.Char.toUpper d) } <?> "oops") "" "cb"
02:59:07 <Itkovian> Right 'B'
02:59:12 <Itkovian> as you can see, it tries the alternative.
03:00:35 <earthy> hm. odd
03:00:50 <earthy> what does proceedings do to make try behave badly, then?
03:00:56 <shapr> kzm: ?
03:02:04 <shapr> kzm: You called?
03:02:36 <joelr1> anyone knows FFI?
03:02:50 <Itkovian> earthy: nothing that I know of
03:03:09 <Itkovian> it returns either Just xxxxx or Nothing
03:03:14 <Itkovian> hmm. ic.
03:03:19 <Itkovian> dang.
03:03:36 <Itkovian> but I need the Nothing for badly formatted bibtex entries
03:03:47 <Itkovian> (badly == according to my grammar)
03:04:01 <Itkovian> because I want to continue to parse the rest of the file
03:04:15 <Itkovian> Maybe that's impossible
03:04:35 * Itkovian eats and watches episode 18 of Lost
03:04:52 <earthy> hm. lost. that's still on the to-watch list
03:04:54 * shapr eats the next episode of 'As the Stomach Turns'
03:05:10 <earthy> at least the episode of dutch tv last friday ;)
03:05:17 <earthy> s/of/on/
03:05:31 <earthy> but, that's kinda weird indeed
03:05:42 <earthy> that the Just xxx or Nothing should not suffice
03:05:54 <Itkovian> ok, proceedings never fails eh.
03:06:00 <Itkovian> it just returns ... Nothing
03:06:09 <Itkovian> let me change that
03:07:09 <earthy> ah, right!
03:07:24 <earthy> you want to make a threefold decision
03:07:32 <earthy> 'Just xxx' 'Nothing' 'failure'
03:08:35 <Itkovian> yeah.
03:08:40 <Itkovian> how can I do that?
03:08:58 <earthy> when would you want the parse to return Nothing?
03:09:19 <Itkovian> nvm, it cannot be done, because if everything fails, it would never skip the entry
03:09:24 <Itkovian> and continue with the rest.
03:09:34 <Itkovian> so I'll ditch the Nothing
03:09:54 <Itkovian> the idea was that Nothing would be returned when something fails, but consumed all the info of the entry
03:10:01 <earthy> it could, but it'd be more trouble than it's worth
03:11:20 <Itkovian> prolly, and I've no idea how to do it.
03:24:08 <shapr> ndm: You called?
03:37:07 <ndm> shapr, i did - was trying to figure out wiki anchors
03:37:11 <ndm> found the command eventually
03:37:59 <ndm> @wiki Keywords
03:37:59 <lambdabot> http://www.haskell.org/hawiki/Keywords
03:38:06 <ndm> my Hoogle keyword index :)
03:39:16 <ndm> and how can i delete a page?
03:39:18 <ndm> @Yhc/RuntimeSystemDocumentation
03:39:18 <lambdabot> Unknown command, try @listcommands.
03:39:26 <ndm> @wiki Yhc/RuntimeSystemDocumentation
03:39:26 <lambdabot> http://www.haskell.org/hawiki/Yhc/RuntimeSystemDocumentation
03:39:43 <shapr> I think page deletion is limited to admins, but I can make you an admin easily enough.
03:40:00 <ndm> just the one page deleted is plenty
03:40:07 <shapr> ok, I can do that.
03:40:23 <ndm> it was created by accident, while Tom was still learning the wiki
03:43:08 <shapr> Ok, deleted.
03:44:38 <shapr> Cale: Any idea where QCExts came from?
04:01:15 <mysteriousentity> @eval 1/0
04:01:16 <lambdabot> Infinity
04:01:26 <mysteriousentity> @eval round(1/0)
04:01:27 <lambdabot> 179769313486231590772930519078902473361797697894230657273430081157732675805
04:01:27 <lambdabot> 500963132708477322407536021120113879871393357658789768814416622492847430639
04:01:27 <lambdabot> 474124377767893424865485276302219601246094119453082952085005768838150682342
04:01:27 <lambdabot> 462881473913110540827237163350510684586298239947245938479716304835356329624
04:01:27 <lambdabot> 224137216
04:01:30 <mysteriousentity> cool
04:02:15 <mysteriousentity> is that a bug or a feature?
04:02:21 <SamB> > fromInteger (round (1/0 :: Double)) :: Double
04:02:22 <lambdabot> Infinity
04:02:30 <SamB> > fromInteger (round (1/0 :: Double) - 1):: Double
04:02:31 <lambdabot> Infinity
04:02:35 <SamB> > fromInteger (round (1/0 :: Double) - 2):: Double
04:02:36 <lambdabot> Infinity
04:02:42 <SamB> > fromInteger (round (1/0 :: Double)/2):: Double
04:02:43 <lambdabot>  add an instance declaration for (Fractional Integer)
04:02:51 <SamB> > fromInteger (round (1/0 :: Double)`div`2):: Double
04:02:52 <lambdabot> 8.98846567431158e307
04:03:44 <SamB> > round (maxBound :: Double)
04:03:44 <lambdabot>  add an instance declaration for (Bounded Double)
04:03:44 <lambdabot>   In the expression: maxBound :: Double
04:03:51 <SamB> hmm
04:04:07 <SamB> well, anyway, apparantly
04:04:13 <SamB> > round (1/0)
04:04:14 <lambdabot> 179769313486231590772930519078902473361797697894230657273430081157732675805
04:04:14 <lambdabot> 500963132708477322407536021120113879871393357658789768814416622492847430639
04:04:14 <lambdabot> 474124377767893424865485276302219601246094119453082952085005768838150682342
04:04:14 <lambdabot> 462881473913110540827237163350510684586298239947245938479716304835356329624
04:04:14 <lambdabot> 224137216
04:04:26 <SamB> is supposed to be larger than
04:04:39 <SamB> round n
04:05:17 <SamB> for any n, as long as all of them are the same type...
04:07:09 * SamB wonders why :i Double only lists instances for Enum, Eq, Floating, Ord, and RealFloat
04:07:43 <SamB> despite the fact that Double is obviously also in Num and Fractional
04:09:08 <SamB> hmm, interesting that all the trigonometric facilities are in Floating except for atan2...
04:09:38 * SamB wonders how they work for complex arguments
04:16:32 * mysteriousentity will read the online logs
05:00:57 * shapr skolemizes gour_
05:02:01 <shapr> asmodai: Learned any Haskell yet?
05:02:36 <ValarQ> hello shapr 
05:02:39 <shapr> hej ValarQ 
05:02:56 <shapr> How's code?
05:03:04 <ValarQ> pretty ok i believe
05:03:04 * gour_ wonders what shapr is telling me
05:03:17 <asmodai> shapr: no
05:04:05 <ValarQ> maybe i should take a look at continuations today...
05:04:07 <shapr> asmodai: aw, too bad.
05:04:23 <asmodai> Got a bit too much other things to take care of.
05:16:57 <shapr> Sure is quiet today.
05:18:09 <ValarQ> shapr: we're busy coding
05:23:25 <shapr> Sounds good.
05:27:42 <gour> shapr: you called me something?
05:27:59 <gour> shapr: (some time ago)
05:29:55 <shapr> I was just talking about skolemization.
05:30:06 <shapr> @wikipedia skolemization
05:30:08 <lambdabot> http://en.wikipedia.org/wiki/Skolemization
05:31:08 <gour> it looks you have fun with math ;)
05:31:29 <gour> did't know abour skolemization and no intent to dive in :-)
05:31:54 <gour> thanks for the pointer though
05:32:10 <shapr> Skolemization happens in Haskell too, but I'm sure you'll see that when you get there.
05:32:48 <gour> shapr: i hope so, or is it required (at all) to see it happens in Haskell?
05:33:10 <gour> shapr: i mean i like nice food but do not understand (always) what's in :-)
05:33:52 * gour wonders why audacity crashes here regularly
05:34:53 <gour> in need something to amplify one usbstick-recorde lecture (wav) and export to e.g. mp3
05:34:53 <gour> s/in/i
05:51:31 * gour has problems with his adsl connection today
06:16:44 <roconnor> @pf \y -> b(\g -> m(g)(y)) . m(f)
06:16:44 <lambdabot> (. m f) . b . flip m
06:17:23 <shapr> hiya roconnor, how's code?
07:29:17 <Cale> ndm: what was it you were looking for me about yesterday?
07:29:34 <ndm> Cale, deleting a page on the wiki - shapr's done it now though
07:29:51 <ndm> sorry about the RuntimeSystemInformation page going on the main wiki - tom was still learning the wiki software...
07:29:53 <Cale> ah, okay
07:30:45 <Cale> It was actually Lemmih who complained, I just thought that it would indeed be a good idea to move it.
07:33:10 <ndm> indeed it was
07:52:55 <musasabi> Is it guaranteeded that hGetArray returns an Int > 0?
07:56:17 <Cale> I'd think do
07:56:18 <Cale> so*
07:56:34 <Cale> or >= 0
07:57:03 <Cale> It returns the number of Word8's actually read, so I'd hope that was nonnegative :)
08:02:26 <musasabi> But does it return 0 or fail with an exception in error conditions?
08:09:05 <Cale> returns 0
08:09:13 <Cale> well, at least, at the end of file
08:09:24 <Cale> It might give an exception in other conditions
08:10:16 <Lemmih> It never returns zero unless the handle is at EOF.
08:10:42 <Lemmih> (or if zero bytes are requested)
08:37:11 <xinming> Is there a log bot here?
08:37:42 <liyang> See topic: 16:36:22 <teddyMac@> THey only have to pay ï¿½30 a year
08:37:47 <liyang> Gah.
08:37:56 <liyang> http://meme.b9.com/cview.html?channel=haskell&date=today
08:38:47 <xinming> oops. sorry for my carelessness
08:40:48 <musasabi> Anyone familiar with:
08:40:49 <musasabi> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
08:40:49 <musasabi>         Ix{Int}.index: Index (1229338681) out of range ((0,662))
08:41:55 <musasabi> Old interface files?
08:46:28 <paolino> good evening. To which types is deriving clause appliable ?
08:49:27 <Lemmih> All except GADTs, I think.
08:50:02 <xinming> how do you read this? <-
08:50:14 <xinming> hmm, I don't know how to read it in English. :-/
08:50:57 <xinming> [a | a <- xs]
08:51:56 <paolino> Lemmih , I have problem deriving this from Show :
08:51:58 <paolino> data  (Groupable a,Cluster b a) => Tree b a = Branch (b a) | Leaf a
08:52:23 <paolino> xinming: read "for a in xs"
08:52:55 <musasabi> Deleting hi-files seemed to help.
08:54:08 <xinming> paolino: thanks
08:56:33 <paolino> xinming it's called list comprehension , it creates a list iterating on the list on the right of the '<-' 
08:57:10 <vegai_> "a belongs in xs", I guess
08:57:37 <xinming> paolino: hmm, In fact, I understand what It does, and it is a sign which is really like <- in maths. But I don't know how to read tht in English
08:59:04 <xinming> IIRC, there is another sign, which is a bit like ->, a -> b which means a includes all elements in b, Just know what It means, but don't know how to read.
08:59:40 <Lemmih> paolino: Hm, looks a bit like a bug. /-:
09:02:02 <paolino> Lemmih , what , my code ?
09:02:03 <eivuokko> I swear I am going to read through report some day and take time to check everything I didn't know or understand.  I didn't know about using @ in patterns before!
09:02:19 <Lemmih> paolino: No, in GHC.
09:05:51 <paolino> Lemmih I don't know how to get around it also, if I try "instance (Cluster b a) => Show (b a) where" I get another  error, why that is wrong ?
09:06:56 <Lemmih> paolino: You probably want: instance (Show (b a), Show a) => Show (Tree b a) where ...
09:08:44 <paolino> Lemmih :-/     Non-type variables in constraint: Show (b a)
09:10:07 <basti_> paolino: you can't restrict types in datatype declarations
09:10:42 <Lemmih> paolino: Oh well. Are you sure you really want such a tree?
09:11:23 * boegel|home boings
09:13:26 <ibid> basti_: you can, but it doesn't do what people expect
09:14:17 <basti_> ibid: hmm. I can?
09:14:55 <paolino> Lemmih I'm experrimenting I have classes and I'm trying to build data with them 
09:16:23 <paolino> the fact that it looks working  aside from printing is not clear to me . Ok if it is a bug anyway
09:17:28 <basti_> lambdabot: 
09:17:30 <basti_> wah
09:17:52 <basti_> paolino: you probably want to say "instance (Cluster a b) => Show (Cluster a b)" dont you?
09:17:53 <paolino> basti_ you know how I can make my data printable ? I'm very confused on classes and types
09:18:49 <paolino> basti_ Class `Cluster' used as a type
09:18:56 <xerox> Ciao!
09:19:12 <paolino> xerox :)
09:19:28 <basti_> < phone... right back
09:31:41 <SamB> awful quiet
09:31:49 <paolino> interesting if I add (Show (b a)) to the constraints on class Cluster I can derive the Tree from Show
09:33:47 <basti_> im back now
09:34:03 <basti_> paolino: you can't show "b a", can you?
09:34:14 <paolino> doesn't hold if I do it on the constrraints of Tree. I really must understand haskell type system, the more I use it the more it gets absurd to me
09:34:39 <basti_> paolino: you can maybe show "Cluster b a" if b and a are Show, but you can't show "b a", usually
09:34:46 <basti_> b would be a functor, then.
09:34:54 <basti_> i don't think you want to state things about functors.
09:35:03 <paolino> nonono
09:35:31 <paolino> now it works but I wish I could understand why also
09:35:54 <basti_> you mean it compiles?
09:36:00 <paolino> yes
09:36:05 <basti_> or did you actually write code that can show "b a"?
09:37:08 <paolino> Branch l
09:37:09 <paolino> Branch [1.0,2.0,3.0]
09:37:17 <paolino> it showed
09:37:25 <basti_> cool.
09:37:33 <paolino> not much to me
09:37:33 <basti_> can you do it the real way too? ^^
09:37:38 * basti_ ducks
09:37:54 <paolino> real way ?
09:38:17 <basti_> like instance Show a => Show (Tree a)...
09:38:30 <basti_> not like Show a b => Show (Thingie a b)
09:39:24 <basti_> brb
09:39:25 <paolino> mmhh, what I did is add a constraint on Cluster class
09:40:06 <paolino> which is not straight obvious 
09:43:13 <paolino> also because it's not asked on Groupable a , mysterious
09:44:13 <paolino> or .... buggy :P
09:46:01 <paolino> OT ,is backtracking something like contexts and zipper ?
09:48:37 <paolino> a zipper on time direction ?
09:51:00 <basti_> back
09:51:02 <eivuokko> Backtracking just usually means that it tries combinations until some condition is met.
09:51:11 <eivuokko> it=algorithm
09:51:12 <xinming> Isn't there any loop "operator" in haskell?
09:51:23 <basti_> xinming: certainly there is.
09:51:38 <basti_> unfold is kind of a loop.
09:51:39 <Lemmih> basti_: Really?!
09:51:41 <luqui> xinming, but it depends on what you want to loop
09:51:45 <xerox> "operator" i'd say not
09:51:57 <basti_> well why not? ^^
09:52:03 <basti_> it operates.
09:52:03 <xinming> hmm, I don't mean the operator, Just like something in perl
09:52:15 <basti_> xinming: what do you want to loop about?
09:52:19 <xinming> for @list { do something }
09:52:29 <luqui> xinming, again, it depends on what the "do something" is
09:52:31 <basti_> fold.
09:52:35 <luqui> the general way to do that is to use "map"
09:52:43 <luqui> or fold
09:52:48 <xerox> @type map
09:52:49 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:52:50 <basti_> or map, if you disregard state carrying between iterations
09:52:51 <xerox> @type foldr
09:52:52 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
09:52:59 <xerox> @type foldl
09:53:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:53:16 <basti_> fold is strictly stronger though. you can write map as a fold.
09:53:32 <xinming> Ok, I know, But It is depend on length of a list
09:53:36 * luqui never thought of that, but supposed it's true
09:53:43 <luqui> s/supposed/supposes/
09:54:03 <xinming> not the counter. :-)
09:54:05 <basti_> it's a nice exercise to do so. you should take about a minute. ^^
09:54:25 <basti_> xinming: well you could fold over an infinite list
09:54:50 <basti_> and then abort if you reached what you consider completion.
09:55:30 <xinming> hmm, In my understanding, It is kind of recursion.
09:55:54 * luqui has never been very comfortable with fold
09:56:01 <basti_> hmm
09:56:06 <basti_> why don't you use recursion then? ^^
09:56:48 <xinming> recursion is easy to understand. yea, It's true, I just feel a bit curious about this in haskell. :-)
09:56:52 <luqui> @pl \a b -> f a:b
09:56:53 <lambdabot> (:) . f
09:56:58 * paolino problem has been basketed :]
09:56:58 <basti_> > foldr1 (\x y->if x>100 then 0 else x+y) [1..]
09:56:59 <lambdabot> 5050
09:57:02 <luqui> yummy
09:57:11 <Speck> huh... anyone seen Daan Leigen's Morrow interpreter?
09:57:17 <basti_> "add 1 to 100"
09:57:23 <basti_> *up
09:57:32 <SamB> xinming: recursion is how all of the looping in haskell operates
09:57:36 <xerox> > sum [1..100]
09:57:38 <lambdabot> 5050
09:57:57 <basti_> xerox: but thats opaque ^^
09:58:14 * xerox polishes basti_'s lens
09:58:24 <luqui> basti_, how does that work!
09:58:27 <SamB> its just that we like to take common recursion patterns and stick them into functions, so that we can consentrate on the interesting parts of our program ;-)
09:58:27 <luqui> the first one
09:58:42 <basti_> luqui: uhm what dont you understand?
09:58:50 <luqui> is it because 0 does not depend on y?
09:58:55 <basti_> @type foldr1
09:58:56 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:58:58 <luqui> the fact that it does not infinite loop
09:59:02 <basti_> luqui: thats why it aborts yes
09:59:07 <luqui> COOL!
09:59:09 <basti_> luqui: you saw that correctly
09:59:18 <basti_> remember, haskell evaluates lazily
09:59:37 <xerox> > foldl1 (\x y->if x>100 then 0 else x+y) [1..]
09:59:37 <luqui> yeah, but I didn't think it did in this sort of case
09:59:42 <lambdabot> Terminated
09:59:42 <luqui> for some reason, though it makes sense
09:59:42 <xinming> Is there a function built-in which will get the current anonymous function?
09:59:45 <xerox> ;-)
09:59:50 <eivuokko> hehe
09:59:52 <SamB> if it didn't, it would never get anything done ;-)
09:59:56 <basti_> luqui: it does everywhere.
10:00:02 <basti_> xinming: uhm.
10:00:07 <xinming> ?
10:00:12 <basti_> xinming: what is "the current anonymous function"?
10:00:13 <SamB> luqui: unless you tell it to be strict
10:00:15 <xerox> Continuations?
10:00:32 <basti_> xinming: do you know the term "fixpoint"?
10:00:43 <luqui> basti_, nonononono don't go there
10:00:53 <luqui> xinming is in his third day IIRC of learning functional programming
10:00:54 <basti_> luqui: where?
10:00:54 <SamB> xinming: there are any number of anonymous closures which contain any given piece of code
10:00:54 <xinming> (\a -> case a of { [] -> 0; (x:y) -> "current function" } )
10:01:01 <basti_> ahh.
10:01:05 <xinming> luqui: yes. :-/
10:01:44 <basti_> xinming: well uhm, you can retransform your program so that you have the exact same program without the "knot in the brains"
10:01:45 <SamB> xinming: if you want to refer to a value again, the best thing for it is to give it a name
10:01:59 <basti_> the "knot in the brains" can be kinda abstracted away.
10:02:06 <basti_> it is a different knot then
10:02:06 <xinming> SamB: :-) I know, use let
10:02:13 <basti_> thats what luqui wanted to say ;)
10:02:34 <basti_> xinming: how does applying a certain number of iterations of a function sound?
10:02:57 <SamB> basti_: that sounds silly
10:03:00 <Igloo> This should be untypable, right? let f x = g x; g :: a -> (); g x = f 'c' in f False
10:03:14 <xinming> I am practising a kind of kungfo which is named iron-head :-P
10:03:25 <SamB> basti_: when is the number ever certain?
10:03:38 <basti_> SamB: thats why you supply a number.
10:03:55 <basti_> ^^
10:04:17 <SamB> last I checked, iterate didn't take a number
10:04:24 <SamB> @iterate (+1) 0
10:04:24 <lambdabot> Unknown command, try @listcommands.
10:04:33 <SamB> > iterate (+1) 0
10:04:34 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
10:04:34 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
10:04:34 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
10:04:34 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
10:04:34 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
10:04:36 <lambdabot> [24 @more lines]
10:04:38 * SamB is silly
10:04:39 <basti_> ah
10:04:45 <basti_> well yes i see ^^
10:05:01 * basti_ didnt know iterate so well
10:05:08 <xinming> > iterate ( +5 ) 0
10:05:09 <lambdabot> [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,
10:05:09 <lambdabot> 115,120,125,130,135,140,145,150,155,160,165,170,175,180,185,190,195,200,
10:05:09 <lambdabot> 205,210,215,220,225,230,235,240,245,250,255,260,265,270,275,280,285,290,
10:05:09 <lambdabot> 295,300,305,310,315,320,325,330,335,340,345,350,355,360,365,370,375,380,
10:05:09 <lambdabot> 385,390,395,400,405,410,415,420,425,430,435,440,445,450,455,460,465,470,
10:05:11 <lambdabot> [24 @more lines]
10:05:17 <xerox> > let f x = g x; g :: a -> (); g x = f 'c' in f False
10:05:17 <lambdabot> Couldn't match `Char' against `Bool'
10:05:52 <basti_> and then, 'c' isnt () either?
10:06:02 <basti_>  > let f x = g x; g :: a -> (); g x = f False in f False
10:06:08 <basti_> > let f x = g x; g :: a -> (); g x = f False in f False
10:06:11 <SamB> xerox: what in the world?
10:06:13 <lambdabot> Terminated
10:06:24 <basti_> strange. since when is False of type ()?
10:06:37 <xerox> Hm?
10:06:39 <SamB> > let f :: a -> (); f x = g x; g :: a -> (); g x = f 'c' in f False
10:06:43 <basti_> xinming: is that kind of what you looked for?
10:06:44 <lambdabot> Terminated
10:06:54 <basti_> xerox: g :: a -> ()
10:06:55 <SamB> xerox: what are you playing at?
10:07:10 <xerox> SamB: Igloo's question
10:07:28 <Igloo> Checking what lambdabot thinks isn't gonig to help me. My problem is hugs accepts it, and I wanted a second set of eyes before I filed a bug in the wrong direction  :-)
10:07:29 <xerox> basti_: so f = g.
10:07:46 * SamB wonders what color Igloo is
10:07:55 * SamB noties Igloo
10:07:55 <basti_> @type False
10:07:56 <lambdabot> Bool
10:08:03 <basti_> @type False::()
10:08:04 <lambdabot>   Couldn't match `()' against `Bool'
10:08:04 <lambdabot>   Expected type: ()
10:08:05 <Igloo> What colour I am?
10:08:06 <basti_> ?
10:08:14 <SamB> Igloo: it is typeable
10:08:22 <SamB> and I can see exactly why
10:08:32 <SamB> erm, some kind of dark-pink/purple color
10:08:32 <xerox> @type let f x = g x; g :: a -> (); g x = f 'c' in f False
10:08:33 <lambdabot> a -> (); g x = f 'c' in f False :: ()
10:09:11 <SamB> Igloo: its an infinite loop, what difference does it make what type of argument you pass it?
10:09:16 <Igloo> SamB: Why? f's type can't be generalised while typing f/g, so it must take Char, no?
10:09:21 <SamB> the same reason why
10:10:09 <Igloo> Note hugs and ghci agree that   let f x = f 'c' in f False   is not typable
10:10:13 <SamB> @type let forever p = x where x = p >> x in forever
10:10:13 * basti_ .o° ( that still contradicts the explicit typing. wtf, people? )
10:10:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:10:41 <SamB> Igloo: maybe it is a bug in the Hugs implementation of the monomorphism restriction, then...
10:11:07 <SamB> but in that case why would GHCi do it too?
10:11:52 * Igloo decides to assume I'm right, and Ross can refute it if I'm not  :-)
10:13:44 <Speck> just to get a point of reference here, what is the motivation behind impredictive type systems -- i.e., what do they let the programmer (or compiler if that is the case) do?
10:13:57 <SamB> @type let forever p = x where x = p >> x in liftM2 (:) (forever (return ())) (forever (return ()))
10:13:58 <lambdabot> Not in scope: `liftM2'
10:14:07 <SamB> > let forever p = x where x = p >> x in liftM2 (:) (forever (return ())) (forever (return ()))
10:14:08 <lambdabot>  add an instance declaration for (Show (m [b]))
10:14:31 <SamB> hmm, why is that typeable?
10:14:36 <SamB> maybe you should look in the report?
10:14:57 <TheHunter> Speck, for example, it allows you do do runST $ do { ... }
10:15:56 <Speck> TheHunter: sorry, I'm probably over my head here anyway, but why couldn't I with a non-impredictive type system (like standard Haskell??)
10:16:02 <SamB> TheHunter: I thought you COULDN't do that
10:16:11 <SamB> > runST $ do { return () }
10:16:13 <lambdabot>  Not in scope: `runST'
10:16:43 <SamB> @index runST
10:16:43 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
10:16:44 <TheHunter> @type Control.Monad.ST.runST
10:16:45 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
10:17:07 <SamB> @type Control.Monad.ST.runST $ do { return () }
10:17:08 <lambdabot>   Inferred type is less polymorphic than expected
10:17:08 <lambdabot>   Quantified type variable `s' escapes
10:17:12 <Ferret> Dammit, I'm joined to too many channels on freenode.
10:17:15 <TheHunter> so runST wants a polymorphic argument, but $ forces it to be monomorphic.
10:17:35 <TheHunter> @type (Control.Monad.ST.runST $)
10:17:35 <SamB> TheHunter: exactly!
10:17:36 <lambdabot>   Inferred type is less polymorphic than expected
10:17:36 <lambdabot>   Quantified type variable `s' escapes
10:17:40 <SamB> now you CAN do:
10:17:50 <SamB> @type runST (do { return () })
10:17:51 <lambdabot> Not in scope: `runST'
10:18:08 <SamB> @type Control.Monad.ST.runST (do { return () })
10:18:09 <lambdabot> ()
10:18:21 <Speck> huh...
10:18:23 <TheHunter> SamB, yes, it's impossible in a predicative type system, that's why people want impredicative ones.
10:18:26 * SamB hates being lagged so much
10:18:47 <Frederick> yo folks, as you suggested yesterday Ive read the records report, but I couldnt understand the whole thing, Ive looked on my book and it seems the book doesnt cover records, Ive also googled and found nothing
10:18:54 <davve_> with the rank-n extension to ghc, you define $ to take a polymorphic argument, but that would mean you could not use $ with non-polymorphic arguments
10:19:21 <davve_> so the win with an impredicative system is that you get a $ that can be used in all cases
10:19:39 <SamB> Frederick: okay.
10:19:46 <SamB> well, lets see.
10:20:08 <Frederick> My book covers record as a data structure like pascal's record, nothign about the record of the function initalization
10:20:36 <SamB> Frederick: oh.
10:20:46 <SamB> well, that is the kind of record you need to read about, actually.
10:21:01 * Frederick goes read the book
10:21:07 <luqui> what's a predicative type system?
10:21:10 <SamB> the top of that function is actually more like the end anyway
10:22:45 <Spark> i'm reading a paper about monads
10:23:16 <SamB> Spark: lovely!
10:23:18 <Spark> and its got "data St a = ST (Sto -> (a, Sto)"
10:23:21 <Spark> whats ST in that
10:23:44 <Speck> the state monad data constructor
10:23:53 <Spark> ah so whats St ten
10:23:54 <SamB> that looks rather like State from Control.Monad.State
10:23:55 <Spark> then
10:24:03 <SamB> only thats a newtype
10:24:23 <SamB> @type Control.Monad.State.State
10:24:24 <lambdabot> forall a s. (s -> (a, s)) -> Control.Monad.State.State s a
10:24:54 <SamB> oh, and it isn't parameterized in the state type
10:24:54 <Spark> so Control.Monad.State.State is ST
10:25:06 <SamB> I mean, the one in the paper isn't
10:25:21 <SamB> Spark: they are close relatives
10:25:22 <Spark> probably omitted for brevity
10:25:40 <SamB> who knows?
10:26:25 <Igloo> Ah, the bug is already known: "Slight relaxation of polymorphic recursion"
10:26:26 <Spark> i think i need a crash course on monads :)
10:26:50 <Spark> preferably a language-independent one actually, does such a think exist? :)
10:27:04 <Spark> or one that uses a minimal amount of language constructs and explains what they all mean
10:27:04 <nocte___> is there french chan about haskell?
10:27:09 <Speck> Moggi's publication is language-independant, right?
10:27:32 <Speck> and that would be a crash course -- that is, crash your head into the desk ;-)
10:27:46 <Spark> the technical report?
10:28:05 <SamB> Spark: why langauge-independant
10:28:11 <Spark> because i dont know haskell
10:28:19 <SamB> Spark: you want a crash course?
10:28:24 <Spark> basically
10:28:25 <SamB> hmm. crash course.
10:28:39 <SamB> Spark: I know! do it in C!
10:28:45 <SamB> thats almost sure to crash
10:29:09 <Spark> what is required in a language?  just tuples and higher order functions?
10:29:10 <Speck> Spark: make sure you understand the monad laws, and the implications of the structure imposed therein
10:29:33 <Spark> i'm not really interested in encapsulation for instance
10:29:45 <SamB> Spark: alternatively, we could give a tour of the MTL
10:29:50 <ibid> the only things one need from a language are lambda abstraction and application
10:29:59 <ibid> everything else, including numbers and tuples, can be built up
10:30:06 <ibid> (of course, that's horribly inefficient)
10:30:12 <Spark> ibid: for a clean definition of monads
10:30:19 <Speck> ibid: that might be too abstracted for educational purposes
10:30:21 <SamB> ibid: also, think CLARITY
10:30:43 <ibid> sorry, missed the context then
10:30:50 <SamB> unless you abstract all that abstraction away, yes, it might be too abstracted
10:31:03 <luqui> Spark, I did it in Perl
10:31:10 <ibid> it the kind of thing that we failed mathematicians like to like: utterly fascinating useless things
10:31:12 <luqui> higher order functions seem to suffice
10:31:13 <Spark> heh i dont know perl either :P
10:31:27 <luqui> erte, closures
10:31:34 <SamB> Spark: well guess which is easier to learn?
10:31:38 * luqui doesn't know where that "te" came from
10:31:45 <Speck> huh... I wonder why Daan introduced a second syntax for his records for the proof section of the scoped labels paper
10:31:47 <Spark> SamB: C :)
10:32:09 * luqui guesses that Perl is easier to learn, but Haskell is more worthwhile to learn
10:32:24 * luqui learned Perl when he only new C++ and Pascal
10:32:28 <Speck> oh well -- gotta run to class. later all
10:32:30 <SamB> luqui: yeah, that seems to be true.
10:32:33 <SamB> Perl is so messy
10:32:45 <Spark> so, what are return and >>=
10:32:45 <xinming> luqui: hmm, they are both worth to learn. :-)
10:32:45 <Spark> :)
10:32:58 <SamB> it has too many features but the feature coverage is horrible
10:32:59 <luqui> xinming, as far as brain wiring goes...
10:33:13 <luqui> feature coverage?
10:33:17 <ibid> one of my students remarked today: "where can i find a list of all the people involved in creating haskell? so that i can kill them?"
10:33:23 <ibid> (my paraphrase from finnish)
10:33:34 <eivuokko> o.O
10:33:44 <SamB> ibid: ouch
10:33:55 <Spark> ibid: the reply to that is "kernighan and richie"
10:34:03 <SamB> Spark: no, no!
10:34:10 <SamB> hmm, who to blame it on...
10:34:14 <SamB> who is responsible for GOO?
10:34:18 <eivuokko> ibid, What's his problem? :)
10:34:34 <Spark> maybe he just likes killing people
10:34:51 <xinming> luqui: Programming in perl is faster for some task, hmm, Just like job control... Just my humble opinion.
10:34:57 * luqui wanted to kill the people involved in creating haskell for the two months I was learning it
10:35:04 <luqui> erte, rather, learning to be comfortable with it
10:35:06 <ibid> i think it was just an instance of black humour
10:35:20 <Spark> ok sod language independent, the paper uses haskell so i may as well learn them with that
10:35:29 <Spark> wheres the nearest monad tutorial?
10:35:32 <luqui> stupid autocomplete
10:35:32 <ibid> true to my own self i've created a tough course, totally by accident, of course
10:35:42 <SamB> @google nomaware monads
10:35:44 <lambdabot> http://www.nomaware.com/monads/html/
10:36:02 <SamB> or is there a better one now?
10:36:23 * luqui really liked "all about monads"
10:36:32 <SamB> @google "all about monads"
10:36:34 <lambdabot> http://www.nomaware.com/monads/html/
10:36:38 <luqui> ahh
10:36:39 <SamB> same one, huh
10:36:40 <luqui> that's the one :-)
10:37:59 <Spark> redundancy
10:37:59 <Spark> like it
10:38:16 <Spark> MAYBE i'll JUST go ahead and read it
10:38:57 <luqui> It's Nothing, really
10:41:13 <xerox> I think it's Something, in fact.
10:42:04 <ibid> Either it's Left somewhere or it is Right there
10:43:05 <pesco> :)
10:44:38 <ibid> should we shoot Bool? er, i think that's a False spelling of it :/
10:46:12 <ibid> True enough, Mr. Bool
10:46:13 <Speck> hmm... I robbed the ST Bank, but now I'm in kind of a >>=. Maybe I should return it.
10:46:16 * ibid gets my coat
10:47:31 <Speck> shoot, I should have said lifted the Bank
10:48:23 <xinming> > replicate 3 'x'
10:48:23 <ibid> well, i'll just QuickCheck an Arbitrary module in this assembly
10:48:24 <lambdabot> "xxx"
10:48:31 <ibid> > cycle "x"
10:48:32 <lambdabot> "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:48:32 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:48:32 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:48:32 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:48:32 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:48:34 <xinming> > replicate 3 "string"
10:48:34 <lambdabot> [23 @more lines]
10:48:36 <lambdabot> ["string","string","string"]
10:48:43 <ibid> oh, only 23 more lines?
10:48:59 <Spark> cycle ":)"
10:49:01 <xinming> hmm, why can't my ghci work with this example?
10:49:28 <xinming> oops. my mistake, It works. I made typo. :-/
10:49:54 <ibid> > take 5
10:49:55 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
10:50:09 <ibid> lambdabot, you don't know how to take a break?
10:50:38 <SamB> > take 5 minutes
10:50:38 <lambdabot>  Not in scope: `minutes'
10:51:02 <ibid> btw, i wrote a Physics module, where one can do dimensional math
10:51:39 <ibid> *Physics> parsec
10:51:39 <ibid> DN 3.0856775813057292e16 [(Metre,1)]
10:51:44 * Speck wants postfix type constructors for his physics modules
10:52:10 <Speck> I guess they'd be data constructors, rather
10:52:27 <Speck> ok now I'm really going to be late -- later
10:53:00 <ibid> *Physics> 5 * m / s
10:53:00 <ibid> DN 5.0 [(Metre,1),(Second,-1)]
10:53:05 <gusn> I'm having trouble installing the frontend packages to HSQL.  Has anyone tried to install them using Cabal-1.1.4 ?
10:53:17 <xinming> where can I found the source for replicate ?
10:53:32 <ibid> xinming: the prelude?
10:53:37 <mentomorph> Hi! Please, what should xx be in "instance Show (Point->Color) where xx" where following is in effect data Point = Pt Double Double and data Vec = Vec Double Double. Thanks
10:53:40 <xinming> ibid: yes
10:53:49 <ibid> xinming: that's your answer then
10:54:05 <SamB> xinming: well, you can get it from fptools CVS, if you have hugs its installed, or you could look at the Report's Prelude...
10:54:05 <Lemmih> gusn: What's the problem?
10:54:06 <ibid> xinming: the report's "standard prelude" section :)
10:54:13 <mentomorph> sorry, change Vec with type Color = Maybe (Int, Int, Int)
10:54:50 <mauke> mentomorph: depends on how you want to print functions, I guess
10:55:05 <gusn> If I for example try "runghc Setup.lhs configure" i the folder SQLite, then I get a type error..
10:55:21 <mentomorph> how do I capture that function in xx? 
10:55:21 <gusn> Couldn't match `LocalBuildInfo' against `PackageDescription'
10:56:02 <Lemmih> gusn: Ah yes. You might want to mail the HSQL authors about that.
10:56:29 <gusn> Probably something with a new Cabal interface or something like that?  Just guessing...
10:56:59 <mauke> mentomorph: instance Show ... where show x = "some string"
10:59:26 <mentomorph> mauke: that doesent work, Illegal instance declar. for Show (P->C) the instance must be of for (T a b c)
10:59:41 <mauke> oh
10:59:52 <xinming> amazing. 2 line is enough for defining the function replicate
11:04:08 <Speck> we can inline perl 6 into haskell code right?
11:04:28 <xinming> Speck: not for now,
11:04:44 <xinming> Speck: hmm, I think this will be available in the future.
11:05:42 <mauke> mentomorph: looks like you can't do that
11:05:56 <mauke> "The type (T u1 ... uk) must take the form of a type constructor T applied to simple type variables u1, ... uk"
11:06:05 <Speck> oh, well I imagine it would be possible, but I'm interested in the extent to which haskell code would be able to access the perl -- not as it is represented in Haskell but maybe like an FFI-like interface between Haskell and an arbitrary language
11:06:36 <mentomorph> Yea it looks like it since show doesent help much.
11:10:40 <mentomorph> Can one put an instance declaration in a do expression ??? How?
11:11:13 <fworp> no, instance declarations are top level only (as far as i know)
11:12:01 <Speck> when GHC is cabalized, I wonder if a camlp4-like library + a heredoc facility like OCaml has could make Haskell a true metalanguage
11:12:29 <SamB> Speck: what do you need heredocs for?
11:12:40 <Speck> embedded XML, SQL, Perl, C (maybe with a different backend for speed)
11:12:42 <SamB> herestrings would work fine!
11:12:48 <Speck> SamB: true
11:13:00 <SamB> though it would be nice if you could use packed ones...
11:13:17 <SamB> actually, I think GHC might already pack them...
11:13:57 <Speck> am I off base, though, in imagining how cool the Cabalization of GHC will be? I don't see it get much mindshare in the community
11:14:08 <SamB> anyways, you don't want to embed SQL that way
11:14:18 <SamB> and you probably don't want to embed XML that way very often
11:14:26 <mentomorph> Sorry folks but I'm a bit desperate: Id like to print Point -> Color where data Point = Pt Double Double and type Color = Maybe (Int, Int, Int). GHC tells me to add an instance decleration for (Show (Point->Color)) in a 'do' expression so I can print it. How is that done ?
11:14:43 <ndm> GHC is a bit too big to be useful as a library - it takes forever to compile
11:14:51 <SamB> Spark: the darcs-ization is more interesting
11:14:56 <SamB> er, Speck 
11:15:12 <SamB> those names are too similar-looking
11:15:15 <Speck> SamB: that's true... darcs is a really cool library
11:15:26 <SamB> Spark: library?
11:16:22 <Speck> I know it's an app, but I meant to emphasize the fact cabalized Haskell somewhat conflates the two
11:16:59 <ndm> Speck, not really
11:17:04 <ndm> darcs is an App
11:17:11 <ndm> HaXml (for instance) is a library
11:17:16 <ndm> very few are truely both
11:17:26 <Speck> I'm bending definitions a lot
11:18:04 <SamB> how about Yi?
11:18:15 <fworp> mentomorph: you are wanting to print the definition of the function? or just have show print 'something'? You cant do the first one at all, and you will likely have to define your own print function for the second one.
11:18:36 <Speck> the majority of an App doesn't exist in its Main.main, take GHC -- consider splitting up and Cabalizing GHC
11:18:53 <kombinator> musasabi: have you seen the paper by Daan Lejien about records on ltu?
11:19:00 <ndm> SamB, Yi is one case where it really is both
11:19:18 <kombinator> they look a bit like hlist, but of course have labels
11:19:20 <Speck> if you consider Yi to be structure on top of hs-plugins, yes
11:19:37 <mentomorph> OK, thank you all.
11:19:44 <ndm> no - because Yi can be used as a program, or as a library in something like Hide
11:19:51 <SamB> Speck: have you seen the dependency graph of GHC?
11:20:01 <Speck> SamB: no, link? sounds interesting
11:20:03 <ndm> Speck, have you tried to use GHC as a library?
11:20:18 <SamB> Speck: me neither, exactly, but it seems convoluted
11:20:29 <Speck> ndm: sadly, not yet -- but I like to think about the possibilities of massive abstraction
11:20:40 <SamB> if anyone even knows how to get a dependancy graph as a picture I'd be interested to know about it
11:20:42 <ndm> abstraction is a fine art
11:20:56 <ibid> dcoutts: ayh?
11:21:09 <SamB> I mean, I'd imagine GraphViz was involved...
11:21:21 <ndm> Doxygen has a feature to do that
11:21:30 <Speck> actually, one of the first things I wanted to do when I learned Haskell was look at funciton dependency in Prelude and rank functions by abstraction
11:21:37 <SamB> ndm: well, for a Haskell program
11:21:39 <xinming> let tmp a = x where x = tmp a
11:21:45 <SamB> maybe you could use Cabal...
11:21:50 <xinming> why my example won't do the same as repeat please?
11:21:56 <mauke> @type repeat
11:21:57 <lambdabot> forall a. a -> [a]
11:22:02 <SamB> does cabal expose a module that can calculate a dependancy graph?
11:22:18 <mauke> xinming: you're just doing let tmp x = tmp x
11:22:21 <ndm> SamB, not really
11:22:22 <mauke> infinite recursion
11:23:00 <SamB> massive abstraction is a pain
11:23:07 <SamB> because it is so unwieldy
11:23:20 <Speck> yeah but you can abstract the abstractions away
11:23:31 <Speck> to quote earlier conversation on this channel
11:23:37 <xinming> ok,thanks
11:25:17 <SamB> Speck: those were lambda abstractions
11:25:20 <SamB> this is different ;-)
11:29:58 <eivuokko> Is there dependency graph in Cabal already?
11:30:32 <SamB> dunno
11:30:46 <SamB> but reportedly not exposed
11:31:33 <eivuokko> Well, last time I checked there was no dependency info available in Cabal, it used external tools to handle that.
11:32:18 <eivuokko> I was going to add it, but I haven't got around to start checking it...maybe someone else added it, tho.
11:32:52 <SamB> I was being presumptious
11:32:57 <eivuokko> (It is one possible way to get cabal build windows dll's, which I need if I want to use visual haskell, which only accepts cabal as build system)
11:33:06 <SamB> it probably isn't in there if you didn't add it
11:34:39 <eivuokko> Dependency calculations are pita, in "real" build systems they need to be dynamic and occur after preprocessing.  Half-embedded preprocessors are kinda pain :-S
11:35:51 <SamB> hmm, true
11:36:01 <SamB> GHC needs to do that, even
11:36:08 <eivuokko> Hmm?
11:36:25 <SamB> preprocess before figuring out dependancies
11:36:57 <eivuokko> Ah, ok.  If ghc doesn't do it, np then ;-P  It's not used anywhere then
11:37:22 <SamB> no, it does do it
11:37:31 <SamB> and it is a pain
11:37:55 <SamB> it can even be a pain to use :-(
11:38:47 <eivuokko> Hmm
11:39:36 <SamB> although I suppose GHC has to parse through the module ... where part anyway before it can extract the dependancies...
11:40:05 <eivuokko> Anyway, the idea was to steal the code from hmake or ghc, but there was (iirc) some license problem with hmake and obvious problem of taking it out of ghc.
11:40:25 <SamB> hmm, what is problem with hmake
11:40:26 <SamB> ?
11:40:28 <SamB> oh.
11:40:35 <eivuokko> I think it is gpl
11:40:42 <eivuokko> (or something, didn't check lately)
11:40:45 <SamB> maybe Cabal isn't substantially different from hmake in purpose?
11:40:58 <SamB> have you seen the nhc98 license?
11:41:20 <eivuokko> It's the dual, GPL or MIT-type?
11:41:55 <SamB> no, its GPL or the nhc98 license itself
11:42:12 <SamB> that is to say, you can convert it to GPL
11:42:40 <SamB> however, there are some interesting provisions you should see
11:54:59 <Frederick> SamB, I think im using the records wrong, when I ask for empties Im getting a empty production printed :op
11:56:15 <Spark> l!!idx 
11:56:19 <Spark> is that indexing a list?
11:56:48 <SamB> Frederick: show me?
11:56:53 <SamB> @type (!!)
11:56:54 <lambdabot> forall a. [a] -> Int -> a
11:56:58 <SamB> Spark: yes
11:57:04 * SamB sometimes gets that mixed up with
11:57:08 <SamB> @type (!)
11:57:09 <lambdabot> Not in scope: `!'
11:57:14 <SamB> @type (Array.!)
11:57:15 <lambdabot> forall e i. (GHC.Arr.Ix i) => GHC.Arr.Array i e -> i -> e
11:57:18 <Frederick> SamB, hm, just noticed im applying the worng stop of the algorithm =/
11:57:29 <SamB> Frederick: hehe
11:57:48 <SamB> I didn't think using records wrong could be the reason for that..
11:58:03 <SamB> using records wrong generally causes either a type or a syntax error ;-)
11:58:31 <Frederick> SamB, I need to make a function that removes things like S -> A it is pretty much like remove empties
11:58:38 <Frederick> nut I need to initializa the record
11:59:01 <Frederick> with the, well I dont know the word but it would be the instance of the cfg without empties
11:59:22 <SamB> Frederick: hmm?
11:59:46 <SamB> have you practiced with a silly record type?
11:59:52 <Frederick> removeEmpties cfg CFG {terminals = [T 'a',T 'b'], nonterminals = [NT 'S',NT 'X',NT 'Y'], root = NT 'S', productions = {NT 'S':=[[T 'a',NT 'X',T 'a'],[T 'a',T 'a'],[T 'b',NT 'X',T 'b'],[T 'b',T 'b'],[]],NT 'X':=[[T 'a'],[T 'b'],[NT 'Y']],NT 'Y':=[]}}
12:00:16 <Spark> is pattern-matching inherent to the do sugar, or is it inheritted from assignment in general
12:00:21 <Frederick> SamB, I couldnt find a sample with a record doing quite what I need Ive only found records beeing used as pascal records
12:00:37 <SamB> Frederick: don't worry what they are used for
12:00:50 <SamB> what you need is probably closer to that than you know
12:01:05 <Frederick> SamB, I couldnt find the link between the ideas
12:01:31 <SamB> Frederick: have you learned about record update?
12:02:41 <Frederick> SamB, more or less
12:02:55 <Frederick> in fact less, I im checking more links
12:03:06 <SamB> well, you know where it says:
12:03:09 <SamB> removeEmpties1 cfg = cfg { productions = prods'' }
12:03:10 <SamB> ?
12:04:13 <Frederick> yep
12:04:24 <SamB> The "cfg { productions = prods'' }" is a record update
12:05:12 <Frederick> hm
12:06:07 <Frederick> it is given to the function wich instance of the cfg it must handle?
12:06:23 <SamB> yes!
12:06:32 <Speck> I think a different syntax mightmake it clearer... cfg.productions = prods''
12:06:51 <SamB> thats what the "cfg" in "removeEmpties1 cfg =" is for
12:07:03 <SamB> cfg is just a variable name
12:07:41 <SamB> we could just as easily use "foo" everywhere we use "cfg" in that function
12:07:42 <Frederick> so to do something like remove replacers I must do removeReplacers cfg = cfg {prodsr = prods''}?
12:08:19 <SamB> Frederick: yes, but there is no particular reason to have "prods''" in there
12:08:33 <SamB> when you haven't even got anywhere in writing the function
12:09:31 <SamB> oh, do you understand "where"?
12:09:39 <SamB> at least superficially?
12:10:05 <SamB> (I don't expect you to know the nasty details of its scope or anything)
12:18:51 <Frederick> does it creates a local semantics or something like that?
12:24:05 <Frederick> ?
12:25:17 <SamB> well, just pretend it is a backwards let...
12:25:28 <Frederick> hm
12:25:32 <SamB> it isn't
12:26:06 <SamB> but thinking of it that way won't hurt until you get scope or syntax errors
12:26:13 <Frederick> k
12:30:25 <Frederick> ?
12:32:03 <SamB> ?
12:32:47 <Frederick> I tought you would say something more
12:34:05 <SamB> Frederick: about what
12:34:15 <SamB> where?
12:34:24 <Frederick> yes
12:34:37 <Frederick> I dont grok the construction
12:34:39 <SamB> anyway, are you getting anywhere over there?
12:34:53 <Frederick> nope
12:35:08 <Frederick> im reading stuff trying to figure it out
12:35:08 <SamB> Frederick: oh, have you seen the tutorial for C users?
12:35:17 <SamB> @google Haskell for C programmers
12:35:18 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
12:35:18 <Frederick> yep
12:36:19 <Frederick> but it is very basic
12:36:50 <Frederick> just the basics about writting functions and stuff
12:37:02 <SamB> yeah, but you seem to be having a bit of trouble with some basic stuff
12:37:09 <gzl> hahaha
12:37:13 <SamB> like what goes on the left of an equals sign
12:37:17 <gzl> "Section 1: What the Heck is Going On?"
12:37:20 <gzl> that's good
12:37:54 <Frederick> gzl, where are the loops :p
12:38:07 <SamB> gzl: isn't that what most programmers think when they are first starting Haskell?
12:38:27 <gzl> probably, but it's the first tutorial I've seen that verbalizes it.
12:38:47 <vegai_> how about "Section 20: NOW what the heck is going on?!"
12:39:13 <vegai_> and "Section 42: Oh now I get it... WHAT IS THAT?"
12:40:16 <SamB> vegai_: it only goes up to "V"
12:41:03 <vegai_> what are the other two sections about? 
12:41:08 <SamB> it figures that by the time you get to section 20, you will be a Haskell programmer and not need special C-programmer treatment ;-)
12:41:54 <SamB> vegai_: V is 5
12:42:48 <vegai_> and we established three sections already...
12:42:55 <vegai_> > 5-3
12:42:56 <lambdabot> 2
12:43:00 * vegai_ smirks.
12:45:33 <SamB> vegai_: but two of those sections were made up
12:48:06 <Spark> hmm, are type classes designed for operator overloading?
12:48:56 <SamB> Spark: exactly!
12:49:02 <eivuokko> For just overloading any function :)
12:49:03 <SamB> and function overloading
12:49:07 <mauke> operators are functions
12:49:08 <SamB> the same thing, really
12:49:15 <Spark> nothing to do with encapsulation then
12:49:42 <Rene_d> I think type classes are the least encapsulated thing in Haskell
12:49:52 <SamB> Spark: ah, yes, they are!
12:49:59 <Rene_d> Which is often good if you want to add a show instance
12:50:13 <eivuokko> Spark, they are pure interfaces, so yeah, they can be used for encapsulation.
12:50:53 <Rene_d> Ahh you mean to hide the actual types used in the implementation
12:51:15 <Spark> i think encapsulation usually means hiding of state so has no meaning in haskell
12:51:26 <Spark> or maybe not
12:51:28 <kombinator> but if you're thinking of encapsulation in oo style then hiding things in modules should do it
12:51:31 <SamB> Rene_d: well, or to hide the workings of the types
12:51:32 <Spark> hiding of implementation too
12:51:53 <SamB> Spark: well, it allows you to avoid referring to the details of any particular type
12:51:57 <Spark> yes, they hide the implementation of e.g. (+)
12:52:09 <Spark> but then thats what a function is for
12:52:24 <SamB> and instead just refer to the operations defined in one or more type classes
12:52:41 <Spark> what they allow you to do, is to avoid things like 1 `integer.+` 2
12:53:06 <SamB> so, like, you could write a sort function that depends only on the things its sorting being comparable...
12:53:16 <Rene_d> I think type classes were added to haskell to support genericity
12:53:33 <Rene_d> Most other things can be done with functions and modules
12:53:33 <SamB> like, well, whatya know:
12:53:33 <SamB> @type sort
12:53:34 <lambdabot> Not in scope: `sort'
12:53:46 <eivuokko> @type elem
12:53:47 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:53:55 <SamB> Spark: actually, they even let you avoid writing things like integer.1
12:54:02 <Spark> mm
12:54:11 <eivuokko> Stupid -fglasgow-exts make signatures more complex then they need to be
12:54:15 <SamB> @type 1
12:54:16 <lambdabot> forall t. (Num t) => t
12:54:32 <Spark> what does => mean
12:55:06 <eivuokko> Class context.  It (Num t) => foo means that in foo, t has/has to have instance of Num
12:55:08 <kombinator> class constraints => actual type
12:55:52 <Spark> so 1 is of type t, but also t is an instance of Num?
12:56:05 <kombinator> t is a type variable
12:56:07 <Spark> why isnt the type of 1 just "Num"
12:56:17 <mauke> because Num isn't a type
12:56:19 <eivuokko> Classes aren't types-
12:56:19 <kombinator> Num is not a type
12:56:23 <Spark> ah i see
12:56:30 <Spark> so its not like java
12:56:37 <eivuokko> Not at all.
12:56:39 <Spark> where you say "this is a runnable"
12:56:44 <kombinator> this signature means "1 is of any numerical type"
12:56:47 <SamB> eivuokko: I know!
12:56:47 <Spark> you instead say "this is a t such that t is runnable"
12:57:05 <eivuokko> SamB, ?!
12:57:25 <SamB> eivuokko: I'm lagged
12:57:34 <SamB> eivuokko: I was replying to "<eivuokko> Stupid -fglasgow-exts make signatures more complex then they need to be"
12:57:36 <musasabi> kombinator: no, I don't think I have seen it.
12:57:44 <Spark> @type 'c'
12:57:45 <lambdabot> Char
12:57:48 <SamB> musasabi: do you have patches for me yet?
12:57:58 <fworp> @type undefined
12:57:59 <lambdabot> forall a. a
12:58:01 <kombinator> musasabi: today's ltu
12:58:09 <eivuokko> SamB, Ah. :)
12:58:12 <Spark> @type (+)
12:58:13 <lambdabot> forall a. (Num a) => a -> a -> a
12:58:34 <Spark> where is 1 defined?
12:58:40 <Spark> (supposing that it was defined)
12:58:50 <kombinator> Spark: probably nowhere
12:59:02 <Spark> what kind of syntax would you use to invent a 1
12:59:07 <Spark> since its like a constant instead of an operator
12:59:17 <mauke> it's built into the compiler
12:59:29 <Spark> would you just define \() -> 1 inside the type class of num or something
12:59:39 <eivuokko> Uhm, you really can't share typeconstructors like 1 would need to do.
12:59:50 <Spark> hmm
12:59:57 <Spark> but you have things like the zero monad
13:00:13 <SamB> musasabi: hmm?
13:00:22 <Spark> or the zero configuration of a monad, should i say?
13:00:38 <SamB> @ping SamB
13:00:39 <lambdabot> Not in scope: type constructor or class `SamB'
13:00:47 <kombinator> it is possible to make your own numerical type, but I don't know what funcrions you have to provide
13:00:51 <musasabi> SamB: sick girlfriend + work and sidetracking has kept me busy :-(
13:00:56 <SamB> Spark: it is defined in the Haskell report
13:01:30 <kombinator> Spark: classes can contain zero-ary functions (constants)
13:01:49 <Spark> ok
13:01:52 * SamB goes off because he is too lagged
13:01:55 <Spark> but you have to do e.g. zero ()
13:02:13 <kombinator> Spark - what do you mean?
13:02:24 <Spark> if i wanted to redefine integers and addition
13:02:38 <Spark> it would end up like (zero ()) `plus` (zero ())
13:02:42 <fworp> im pretty sure you just instantiate Num, and you get full use of integer literals
13:02:43 <Spark> instead of 0 + 0
13:03:10 <kombinator> zero `plus` zero would do
13:03:15 * boegel|home boings
13:03:31 <fworp> fromInteger being used to go from the literal to your type
13:03:48 <Spark> kombinator: but then you're always working with functions, is that wise?
13:03:58 <Spark> kombinator: or is it that you have no choice
13:04:22 <mauke> kombinator: constants are functions
13:04:36 <kombinator> yes, i know
13:04:43 <mauke> er, oops
13:04:56 <mauke> wrong nick completion
13:04:56 <Spark> @type 1
13:04:57 <lambdabot> forall t. (Num t) => t
13:05:04 <kombinator> but Spark insists on makinz zero a () -> Something function
13:05:07 <Spark> is that a function?
13:05:08 <SamB> @type mzero
13:05:09 <lambdabot> Not in scope: `mzero'
13:05:41 <mauke> @type Monad.mzero
13:05:42 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => m a
13:05:53 <Spark> @type ""
13:05:54 <lambdabot> [Char]
13:06:03 <liyang> Try also Monoid.mempty
13:06:06 <Spark> so why doesnt char have a class
13:06:17 <SamB> @type fromInteger
13:06:18 <lambdabot> forall a. (Num a) => Integer -> a
13:06:27 <Spark> shouldnt it implement some kind of comparison operator?
13:06:40 <mauke> it does
13:06:41 <liyang> There's an instance Eq Char somewhere.
13:06:49 <SamB> the report defines integer literals in terms of fromInteger
13:07:14 <mauke> > 'a' >= 'b'
13:07:15 <lambdabot> False
13:08:34 <Spark> so shouldnt the type of char be forall a. (Eq a) => a
13:08:35 <Spark> or something
13:08:56 <liyang> no the type of Char is just Char...
13:08:57 <mauke> no, Char _is_ a type
13:09:05 <Spark> so how come Num isnt a type?
13:09:09 <SamB> @type (>=)
13:09:10 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:09:10 <Spark> whats the difference betwen Num and Char
13:09:14 <liyang> It's an instance of forall a. (Eq a) => a
13:09:19 <mauke> Num is a class, Char is a type
13:09:40 <Spark> so while 'a' has a type, 1 has a class
13:09:47 <mauke> there are different types of numbers (Int, Integer, Double, ...) but only one Char
13:09:56 <Spark> ah, 1 is overloaded
13:10:34 <mauke> a nice thing about Haskell is context-based overloading
13:10:35 <SamB> dons: hmp3 is still doing it
13:10:35 <Spark> its weird that classes arent types
13:10:41 <liyang> 1 belong to a class of types, if you will.
13:10:47 <mauke> C++ can't do that
13:11:07 <liyang> Spark: somewhat different concept of class here.
13:11:10 <mauke> classes are interfaces
13:11:27 <liyang> (only slightly, mind.)
13:11:30 <Spark> classes are interfaces in java
13:11:33 <SamB> dons: it crept up to 30-40% CPU and 3.5% mem in about one and a half hours
13:11:48 <Spark> but in java, 1 would be of type Num
13:11:54 <Spark> and Integer implements Num
13:11:55 <Spark> for instance
13:11:59 <SamB> Spark: no they aren't
13:12:02 <mauke> I doubt that
13:12:13 <SamB> Spark: java has interfaces AND classes
13:12:15 <Spark> i'm applying the java approach to the haskell situation
13:12:18 <mauke> I don't think Java lets you instantiate interfaces
13:12:26 <SamB> and from what I understand neither is terribly useful...
13:12:29 <Spark> i meant classes (in haskell) are interfaces (in java)
13:12:43 <eivuokko> Spark, you really shouldn't, java and haskell typesystems are not similar, really.
13:13:11 <SamB> Spark: oh, maybe
13:13:25 <Spark> i really should, things are explained in terms of things you already know
13:13:41 <SamB> only Haskell classes are a lot nicer
13:13:46 <liyang> Spark: sometimes you have to take a leap. :)
13:13:56 <SamB> also, Java has no functions
13:14:09 <SamB> Spark: learn new things
13:14:20 <eivuokko> Spark, yes, but maybe your starting point is wrong.  Imo you shouldn't take java as starting point to haskell.  But of course, suit yourself.
13:14:27 <SamB> Spark: if you must, learn Core
13:14:50 <SamB> pretend typeclass constraints are actually parameters!
13:14:55 <Spark> so anyway, you have a distinction between class and type in haskell
13:15:06 <SamB> (that is what Core does)
13:15:29 <eivuokko> Uhm, SamB what is core, sounds like way I think...
13:16:14 <Spark> and for something to be of type forall a. Class a => a means objects of that type can be used with the operations in Class
13:16:44 <SamB> eivuokko: Core is what GHC uses right before it translates to the internal C--
13:16:53 <Spark> but the meaning might (will?) be specific to their concrete type
13:16:59 * joelr1 waves
13:17:27 <joelr1> folks, what's a good way to handle this case in my own monad? i would want to throw an error or proceed with h
13:17:30 <joelr1>        (Right h) <- liftIOTrap $ timeout secs $ connect_ host port
13:18:08 <liyang> Spark: the implementation (or instance) is specific to the type, yes.
13:18:15 <joelr1> right now it will bomb out with a pattern matching failure but i want to print a meaningful message, i.e throw an error of my own
13:18:39 <vegai_> Spark: yes, that's about right
13:18:58 <eivuokko> @karma+ SamB
13:18:58 <lambdabot> SamB's karma raised to 4.
13:19:22 <SamB> @type Data.Either.either
13:19:23 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
13:19:46 <Spark> so, with a class, you can either extend it to make a new class (by adding functions, or maybe changing the types of existing function in a backwards-compatible manner), or define a new type that is an instance of that class
13:20:12 <Spark> in the latter case providing the code that implements the function specs in the class
13:20:18 <joelr1> is this a case of x <- liftIOTrap ... 
13:20:18 <joelr1> case x of (Left _) -> throw ....
13:20:18 <joelr1> h = case x of Right x -> x
13:20:46 <vegai_> Spark: silly talking, you should code more :)
13:20:51 <SamB> joelr1: did you see that "either"
13:21:36 <SamB> Spark: go forth and play with monads
13:21:54 * shapr is bored.
13:21:56 <SamB> (in particular, play with those in the MTL)
13:22:04 <joelr1> SamB: yes but that would sort of require me to split my function into two, right? i could do just as well with a acse
13:22:07 <joelr1> case
13:22:10 <SamB> then you will see at least some of what type classes are good for
13:22:25 <SamB> shapr: implement IO for my z-machine interpreter
13:22:34 <shapr> :-P
13:22:35 <SamB> @where ZMachine
13:22:35 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
13:22:36 <Spark> ok im satisfied with type classes now though
13:22:40 <Spark> i'm wondering about monads again
13:22:41 <SamB> joelr1: nah
13:22:59 <joelr1> thing is that i cannot do h <- case ... of 
13:22:59 <joelr1> Right x -> x 
13:22:59 <joelr1> Left e -> throw ...
13:23:03 <SamB> try "either error id (liftIOTrap ...)""
13:23:08 <mauke> ah, that reminds me
13:23:12 <SyntaxNinja> w000t
13:23:27 <SamB> or actually I think I mean
13:23:32 <mauke> I have no idea what Control.Monad.State is, but I've made my Parser an instance of it. is that ok?
13:24:12 <Spark> in "maternalGrandfather s = (return s) >>= mother >>= father", how do we know that we're using a Maybe monad?  is it inferred from the type of father, mother?
13:24:17 <SamB> "h <- liftM (either error id) (liftIOTrap ...)"
13:24:35 <SamB> mauke: no.
13:24:40 <joelr1> SamB: and where do i print my meaningful error? oh, is ee
13:24:42 <SamB> we shall have to educate you!
13:24:44 <mauke> damn
13:24:51 <joelr1> SamB: let me try that, thanks
13:25:10 <SyntaxNinja> I added hooks to cabal so that you can get "configure" support for any old program!
13:25:26 <SamB> mauke: Control.Monad.State.MonadState is a class for monads that allow you to pass a state around through them
13:25:27 <SyntaxNinja> you want configure to find 'ls'? add --ls-args to the configure command line?
13:25:29 * SyntaxNinja pokes kosmikus
13:25:36 <SamB> joelr1: feel free to replace "error" with whatever
13:25:56 <joelr1> SamB: i was just wondering about that, ok
13:25:59 <SamB> especially since I have no idea what the left argument to Either was
13:26:15 <mauke> ok, that fits
13:26:17 <Spark> what irks me about this example is that it doesnt look more like "maternalGrandfather s = (mother o father) (s)"
13:26:33 <Spark> is that just a non-monadic solution to the same problem?
13:26:49 <shapr> lambdabot needs a GHC cmdline option search, what does "-optl -s" do?
13:27:21 <thou> SyntaxNinja: that sounds very cool
13:28:10 <shapr> Aha, pass -s to the linker.
13:28:12 <fworp> Spark, plain ole composition doesnt propogate errors, but thats the general gist
13:28:14 <SyntaxNinja> thou: thanks :)
13:28:42 <mauke> Spark: that wouldn't work
13:28:45 <Spark> fworp: but you could define father and mother to do so? what would you have then
13:28:46 <thou> SyntaxNinja: does it use autoconf, or pure haskell?
13:28:50 <joelr1> how do i fake a handle?
13:28:56 <mauke> mother takes a Sheep but father returns a Maybe Sheep
13:28:57 <joelr1> i.e. if i'm throwing an error
13:29:01 <SamB> mauke: for instance, I used StateT (Maybe Char) IO for my translation of the Unlambda interpreter, so that I could pass around a character for... I don't rembember why!
13:29:01 <Spark> father Nothing = Nothing etc
13:29:04 <SyntaxNinja> thou: pure haskell
13:29:14 <SyntaxNinja> thou: http://www.haskell.org/cabal
13:29:22 <Spark> what if father and mother were Maybe Sheep -> Maybe Sheep
13:29:46 <joelr1> i think i can just return stdout since ... it will never be returned cause i'm throwing an error
13:30:02 <mauke> Spark: that would complicate things needlessly because now you have to duplicate the code that checks for Nothing
13:30:08 <fworp> Spark: sure, but it would be redundant and ugly
13:30:16 <Spark> mauke: where is the duplication?
13:30:18 <fworp> yeah, that
13:30:26 <mauke> in the definition of father and mother
13:30:28 <Spark> the definition of father/mother encapsulates it
13:30:35 <SamB> joelr1: you don't need to return anything when you throw an error
13:30:41 <mauke> Spark: ... twice
13:30:42 <Spark> it would be there twice, i suppose, once for father and once for mother
13:30:43 <SamB> @index throw
13:30:44 <lambdabot> Control.Exception
13:31:00 <mauke> Spark: yes. it's better to make it an independent function
13:31:00 <joelr1> SamB: (a -> c) -> (b -> c) -> Either a b -> c
13:31:20 <SamB> @type Control.Exception.throw
13:31:21 <lambdabot> forall a. GHC.IOBase.Exception -> a
13:31:40 <SamB> joelr1: oh. you can use undefined.
13:31:43 <joelr1> hmm
13:31:51 <joelr1> cool
13:31:57 <Spark> as it stands, sheep could be a tuple of Maybe Sheep x Maybe Sheep i suppose
13:32:06 <Spark> and father and mother would just be .1 or .2 or whatever the syntax is
13:32:47 <SamB> or actually just throw would work fine too
13:32:59 <joelr1>        h <- case liftIOTrap $ timeout secs $ connect_ host port of
13:33:00 <joelr1>               Right x -> x
13:33:00 <joelr1>               Left s -> do throwError s
13:33:00 <joelr1>                            return undefined
13:33:06 <SamB> I mean, an a is an a, right?
13:33:19 <joelr1> SamB: i have Either String Handle
13:33:27 <joelr1> i.e. my error is a string
13:35:16 <SamB> joelr1: so what was te problem with "h <- liftM (either error id) (liftIOTrap $ timeout secs $ connect_ host port of)
13:35:35 <joelr1> SamB: i could not understand that ;)
13:35:48 <joelr1> SamB: err, could not understand what to plug in case of error
13:35:57 <SamB> or
13:35:57 <SamB> h <- liftM (either throwError id) (liftIOTrap $ timeout secs $ connect_ host port of)
13:36:04 <joelr1> ah
13:36:05 <joelr1> now it clicks
13:36:35 <joelr1> SamB: thanks!
13:37:45 <SamB> joelr1: you're welcome
13:38:29 <fworp> Spark: you can't just compose Maybe Sheep with Some other Maybe Sheep with normal composition. so there would still need to be some other stuff going on to get the same behavior as the maybe monad
13:38:43 <SamB> joelr1: hmm, I can't help but wonder what you are doing about withSocketsDo
13:39:04 <joelr1> SamB: nothing, why? there are calls to that within ghc
13:39:15 <joelr1> if it detects that you are on windows anyway
13:39:19 <SamB> I seem to remember something about it being a BAD THING to let errors get thrown through that
13:39:39 <joelr1> SamB: i'm in a composite monad 
13:39:51 <joelr1> so translate the IO errors
13:39:58 <joelr1> into errors of my o wn
13:40:13 <joelr1> otherwise my things just die on exception
13:41:23 <joelr1> SamB: type EngineState = ErrorT String (StateT World IO)
13:43:07 <joelr1>     Couldn't match `m a' against `Handle'
13:43:08 <joelr1>       Expected type: ErrorT String (StateT World IO) (Either String (m a))
13:43:08 <joelr1>       Inferred type: ErrorT String (StateT World IO) (Either String Handle)
13:43:08 <joelr1>     In the expression: liftIOTrap $ ((timeout secs) $ (connect_ host port))
13:43:11 <SamB> @index liftIOTrap
13:43:11 <lambdabot> bzzt
13:43:18 <joelr1> SamB: i think that liftM is extra
13:44:18 <lisppaste2> joelr1 pasted "liftIOTrap" at http://paste.lisp.org/display/13628
13:44:19 <SamB> joelr1: hmm, maybe you need a return somewhere
13:44:30 <joelr1> there it is
13:44:42 <goron> Who reads haskell@freebsd.org?
13:47:29 <joelr1> SamB: liftIOTrap :: IO a -> EngineState a
13:47:38 <SamB> joelr1: I see
13:47:45 <joelr1> type EngineState = ErrorT String (StateT World IO)
13:48:34 <SamB> try (either ... return) instead?
13:48:44 <joelr1> where
13:48:57 <SamB> instead of (either ... id)
13:49:48 <joelr1> trying
13:50:52 <joelr1>        h <- either throwError return $ 
13:50:52 <joelr1>             liftIOTrap $ timeout secs $ connect_ host port
13:50:55 <joelr1> you mean?
13:51:21 <SamB> I suppose so
13:51:34 <joelr1>     Couldn't match `Either a b'
13:51:34 <joelr1>            against `ErrorT String (StateT World IO) (Either String Handle)'
13:51:34 <joelr1>       Expected type: Either a b
13:51:34 <joelr1>       Inferred type: ErrorT String (StateT World IO) (Either String Handle)
13:52:16 <SamB> thats not it then
13:52:20 <SamB> I don't know
13:52:25 <SamB> your monads are too complicated for me
13:52:30 <joelr1> :D
13:52:41 <SamB> you'll figure something out
14:09:11 <shapr> Will cvs up -Pd delete files that aren't version controlled?
14:09:35 <joelr1> is there a fromJust for either?
14:09:38 <joelr1> fromRight? 
14:10:00 <shapr> @index fromRight
14:10:01 <lambdabot> bzzt
14:10:07 <shapr> Easy enough to write it.
14:10:11 <thou> forceEither
14:10:13 <joelr1> yep
14:10:19 <thou> in MissingH.Either
14:10:33 <joelr1> ok, thanks thou
14:10:47 <joelr1> shapr: my project has not been a success 
14:10:55 <shapr> how so?
14:11:07 <joelr1> shapr: haskell is too complicated for the qa techs and many problems on windows
14:11:18 <joelr1> shapr: i will fix the too complicated part for sure
14:11:37 <shapr> What's too complicated?
14:11:39 <joelr1> shapr: but i suggested dumping windows as the test platform
14:11:43 <shapr> hehe
14:11:49 <joelr1> shapr: the scripts turn out too complicated
14:12:05 <shapr> What do the test scripts look like?
14:12:23 <shapr> Have you considered QuickCheckM?
14:12:29 <joelr1> shapr: so i suggested "lego blocks" to the customer thinking they might pay me for it :) turned out i will have to just do it so i offered a compromise. to do it but not on windows.
14:12:43 <joelr1> shapr: the test scripts are quite monstrous
14:12:54 <_thaldyron> I was just wondering: why is Haskell regarded as a "pure" language if the I/O Monads makes side-effects possible?
14:13:13 <shapr> The test scripts are just a model of the possible interactions checked for correct behaviour, right?
14:13:27 <shapr> _thaldyron: Because monads are both pure and side effect-y.
14:13:36 <joelr1> nah, not that simple
14:13:46 <int-e> _thaldyron: the side effects take place outside of the language
14:13:46 <Cale> _thaldyron: evaluating a value of type (IO a) doesn't cause side effects.
14:14:12 <int-e> _thaldyron: there's a run time system component that takes the IO () value returned by Main.main and 'executes' it.
14:14:54 <Cale> Haskell is considered pure because functions are referentially transparent
14:14:57 <int-e> _thaldyron: at least that's one way to view it, conceptually
14:14:59 <_thaldyron> Cale,int-e: ok so Monads preserve purity by just constructing the action which theoretically would always yield the same value when executed in the same world
14:15:12 <Cale> yeah
14:15:26 <shapr> Also, IO monads can't unwind.
14:15:31 <int-e> _thaldyron: in reality, that component and the actual language are intertwined, so no needless evaluations take place
14:15:43 <Cale> A function of type String -> IO () is pure because for the same string, it always returns the same action.
14:16:13 <_thaldyron> Cale: ah i seem to get it
14:17:07 <SamB> so, like, one putStrLn "Hello, World!" is as good as any other
14:21:53 <fworp> @hoogle Int -> (a -> a) -> (a -> a)
14:21:54 <lambdabot> No matches, try a more general search
14:22:33 <Cale> @type iterate
14:22:34 <lambdabot> forall a. (a -> a) -> a -> [a]
14:22:49 <Frederick> The second point is that learning and using Haskell requires unlearning and rethinking the basic assumptions most coders have developed about programming. :p
14:22:56 <shapr> yup
14:23:08 <Cale> > iterate (+1) 0 !! 10
14:23:10 <lambdabot> 10
14:23:20 <fworp> yeah, thanks
14:23:20 <Frederick> shapr, that is very hard
14:23:33 <flux__> > iterate (+1) 0 !! 100000
14:23:34 <lambdabot> 100000
14:23:43 <flux__> > iterate (+1) 0 !! 10000000
14:23:45 <Cale> @pl (\n x -> iterate f x !! n)
14:23:47 <lambdabot> Stack overflow
14:23:47 <lambdabot> flip ((!!) . iterate f)
14:26:16 <fworp> @type flip
14:26:17 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
14:26:24 * shapr discovers a partial implementation of software radio Wi-Fi in Haskell.
14:27:04 <shapr> This is immensely cool. Now, where do I get a decent software radio card for Linux?
14:28:02 <Frederick> SamB, Ive just read the tutorial
14:32:32 <Itkovian> can somebody give me a hand with parsing nested structures?
14:32:39 <shapr> Using Parsec?
14:32:42 <Itkovian> yeah
14:32:54 <Itkovian> man, my mind is going haywire
14:34:07 <Itkovian> it's of the form { ( ([^{]*) | ({[^}]*}))* }
14:34:29 <Itkovian> e.g. { jdfklvjdf { lkdfjvld } {dfvdfv} dfvdfv {vdfvdfv }}
14:34:53 <Itkovian> the nesting only goes one deep
14:34:59 <Frederick> folks can anyone give me ahand with registers?
14:35:12 <Itkovian> registers as in?
14:35:29 <Frederick> as in removeEmpties1 cfg = cfg { productions = prods'' }
14:36:31 <shapr> Itkovian: option
14:36:48 <Itkovian> dude, searching the manual.
14:36:58 <Itkovian> (Hurley is contagious)
14:37:31 <shapr> Who's Hurley?
14:37:42 <Itkovian> He's the fatman in Lost
14:38:12 <ski__> is Lost good ?
14:38:13 <Frederick> what is lost?
14:38:21 <Itkovian> ski__: yes.
14:38:22 <Buggaboo> Lost the television series
14:38:26 <Buggaboo> is great.
14:38:30 <Itkovian> Frederick: welcome to 2005 dude
14:38:32 <Buggaboo> hi ski
14:38:34 <Itkovian> :-)
14:38:34 <Frederick> yo ski__ are you collection underlines?
14:38:37 <Frederick> :)
14:38:39 * ski__ happened to see one of them some weeks ago
14:38:41 <int-e> > let iterate' f x = let x' = f x in x:(x'`seq` iterate' f x') in iterate' (+1) 0 !! 1000000
14:38:42 <lambdabot> 1000000
14:38:45 <shapr> Itkovian: I use http://www.cs.uu.nl/~daan/download/parsec/parsec.html
14:38:48 * ski__ rarely watches tv
14:39:05 <Itkovian> ski__ wll,you should see this series
14:39:09 <ski__> Frederick : hehe
14:39:34 <Buggaboo> hey ski, guess what I'm doing, I'm progging the game go.
14:39:47 <ski__> ok
14:39:57 <Buggaboo> shapr, you go to the same uni as I do.
14:40:07 <shapr> Buggaboo: I doubt it.
14:40:21 <Frederick> folks I need some help over registers here -> http://paste.lisp.org/display/13629
14:40:23 <shapr> Ik begrijp het niet.
14:40:49 <Buggaboo> shapr: utrecht?
14:40:49 <Frederick> ive read some tutorials but I cant take off maybe you can throw me up :p
14:40:56 <shapr> Buggaboo: I last went to uab.edu in 1994 or so.
14:41:27 * fworp is sitting in an office at uab.edu
14:41:48 <shapr> fworp: Is Rust Engineering still around?
14:41:55 <Buggaboo> shapr: so you're an UU alumnus then?
14:42:12 <eivuokko> Uhm.  This maybe stupid, but...ghc doesn't use full lambdaing (as per lambda-cube/henk or so)  for kinds as Henk paper might imply, right?
14:42:23 <shapr> Buggaboo: No, the only thing I ever graduated from was short pants.
14:42:50 <Buggaboo> ow wait, I thought the link you gave was your own.
14:42:51 <shapr> fworp: Are you a CS guy at uab.edu? Or a computing services guy?
14:42:51 <fworp> i have no idea, im in administration, dont know too much about the academic part of the university
14:42:53 <Frederick> Ienvy you all and you university system
14:42:55 <Buggaboo> I jump to conclusions quite quickly.
14:43:07 <fworp> shapr: nope
14:43:27 <fworp> to both
14:43:44 <Buggaboo> cuz, cs.uu.nl is my faculty's domain name.
14:43:51 <shapr> fworp: I used to work in HUC, is that where you are?
14:44:17 <fworp> Im in AB
14:44:19 <SamB> Frederick: try asking a question
14:44:20 <shapr> I also worked in mervyn-sterne and lister-hill at various times.
14:44:24 * SamB is loading dishwasher
14:46:20 <shapr> fworp: Don't think I've ever been in AB, but I was somewhat infamous with the network admins.
14:46:36 <fworp> hehe
14:48:27 <shapr> Computing Services had a Novell 4.x network, and the root management server had a supervisor password of fe2o3. That got me into serious trouble. Mostly because I marched right into their office and told them to fix the stupid password, and they threatened to expel me if I messed with their server again. The password didn't change.
14:49:15 <Frederick> SamB, the point is the register I use them to have sort of a new copy of the structure Im using but for me it is not clear how to use them, I can understand them as a pascal record but this haskell way to use them is confuse, they seem like an assigment operator
14:49:15 <SyntaxNinja> shapr: how did you find the passwd?
14:49:35 <shapr> SyntaxNinja: All the computing stuff is located in the Rust Research Building. It was the first password I tried.
14:49:54 <shapr> I never even got to try fe3o2 (which I vaguely recall is one of the other chemical forms of rust).
14:50:09 <Itkovian> omg
14:50:11 <Itkovian> lame
14:50:19 <Frederick> shapr, can I ssh them and rm -rf :p?
14:50:26 <fworp> i wonder it its changed...
14:50:38 <Itkovian> yeah gives us the server name
14:51:03 <Frederick> someone hacked part of my univeristy web site today
14:51:19 <shapr> Frederick: No, but I did run netadmin.exe and gazed longingly at the "remove partitions" menu choice. Since that was the root server for the Novell tree, it would have removed the partitions for all 136(?) Novell servers in the university.
14:51:34 <Itkovian> our uni used to be a black hole so to speak
14:51:37 <Itkovian> wide open and all
14:52:25 <Frederick> my univeristy was supposed to be the best on cs field on brazill but I sincerelly dont believe in this crap
14:53:03 <Frederick> cause my teachers are some of the most lazy creatures Ive ever seen
14:53:15 <shapr> I had a lot of fun exploring the UAB network. I heard rumors of a 'legion of hackers' at UAB, but I never saw anyone besides myself doing interesting stuff on the wire.
14:53:30 <Itkovian> my masters thesis promotor has 7 kids
14:53:36 <wchogg> Just of curiosity, but what pet projects do you guys use Haskell for?
14:54:11 <Itkovian> one day a sniffer was discovered (they still used telnet then the idiots), and his pasword was discovered to be elke04, elke being his 4th child
14:54:15 <shapr> My pet projects include, a mailing list archive searcher, a research paper annotation tool, and a bittorrent client. I can find others if I look in my sources directory.
14:54:20 <fworp> im too scared to poke around, i think ill just do my job and go home when they let me
14:54:22 <shapr> Itkovian: ouch
14:54:23 <Itkovian> needless to say to what he changed his password?
14:54:25 <shapr> fworp: smart
14:54:43 <SamB> Frederick: laziness can be a virtue!
14:54:47 <shapr> fworp: How did you get into Haskell if you work in uni admin? Are you getting a CS degree at the same time?
14:54:54 <SamB> however, it isn't usually that nice in professors
14:55:13 <shapr> fworp: These days I only experiment with networks I myself own.
14:55:24 <fworp> nope, just a hobbyist
14:55:27 <SyntaxNinja> wchogg: a filesystem, a make-like system for Haskell, random scripts
14:55:39 * shapr inserts standard disclaimer, since this channel is logged and googlable.
14:55:48 <fworp> :P
14:56:34 <wchogg> Has there ever been anything Haskell didn't do very well?  I've been working on genetic algorithms, and so far it seems pretty nice.
14:56:40 <Frederick> SamB, the course Im taking now for this assigment you guys are helping me is the best example of how my university sucks, I had grades to pass but I answered wrong a "main" concept of the discipline so I had to take a second test, where all who did it failed so because of 1 concept Im taking the whole freaking course again
14:56:43 <SamB> shapr: I thought the bittorrent client was jlouis's pet now
14:56:45 <shapr> I used to have an account on uabdpo.dpo.uab.edu, an old PrimeOS box. That thing had security holes you could throw a dead sheep through.
14:56:55 <Frederick> needless to say it is a useless course
14:56:59 <shapr> SamB: Sure, but it's my pet too!
14:57:08 <SamB> Frederick: ouch
14:57:12 <fworp> i used to have a technical job here, but it was only barely technical, i refurbished the dumpy old computers that came into surplus
14:57:33 <Frederick> SamB, the teacher argued that "concepts are more important than grades and numbers"
14:57:40 <SamB> Frederick: well, it sounds like its pretty useless if most of the people are doing it in C!
14:57:42 <shapr> wchogg: Haskell isn't that good at embedded systems.
14:57:43 <fworp> which was mostly just stacking them on top of eachother, and wrapping them in celophane
14:57:55 <Frederick> SamB, in fact Im the only one trying to do it in haskell
14:58:14 <SamB> Frederick: you said so already
14:58:15 <Frederick> I didnt gave up because haskell is looking worth learning
14:58:26 <shapr> wchogg: When you need to track your resource usage because every cycle counts, then I'd probably write a Haskell program to generate the real program instead of using Haskell directly.
14:58:46 <Frederick> SamB, ah some are doing it in pascal too, these ones adre d00med
14:59:02 <shapr> fworp: They used to have a bunch of NeXTs in the Kirklin Clinic and around UAB, did you ever see any of them? I'd still like to get one.
14:59:17 <wchogg> I'm not sure what you mean, how would you write a Haskell program to generate another program?
14:59:20 <SamB> Frederick: that does sound bad!
14:59:29 <shapr> wchogg: GHC is such a program.
14:59:33 <SamB> wchogg: well, GHC is one
14:59:34 <Frederick> SamB, when you get used to it it sounds funny
14:59:44 <SamB> I'll give an example:
15:00:21 <fworp> nah, ive never run into one. the most exotic stuff were sgi indigo's, and a 'mini-vax'
15:00:37 <fworp> which was the size of a volkswagen
15:00:43 <shapr> I got my old school trueblue IBM clicky keyboards from UAB. I had one from 1984, but it melted in my car :-( Now I only have one from 1988.
15:00:47 <shapr> fworp: cool!
15:00:53 <SamB> main = putStrLn "main(){printf(\"Hello, World!\"}"
15:01:08 <SamB> er, I forgot the \n
15:01:25 * shapr should probably go back to hacking on the Evil Project.
15:01:47 <basti_> tep?
15:01:48 <fworp> oh well, got to go. bye.
15:01:54 <shapr> cya
15:02:56 <shapr> I was a pre-CS major at UAB. That's the closest I got to formal education in CS. I had CS 101. We wrote BASIC on true blue IBM XTs, using the ROM BASIC. We brought our own 5.25 floppy to save our programs.
15:03:17 <Frederick> shapr, can you give me a hand with registers?
15:03:37 <shapr> Nah, I'm going back to my Evil Project.
15:03:47 <wchogg> Evil Project?
15:03:58 <shapr> wchogg: If I get any results you'll know.
15:04:02 <Frederick> Im confused they dont look nothing as Ive seen in imperative languages maybe an instance of a class but not quite the samething
15:04:30 * ski__ wonders what Frederick means with 'registers'
15:04:33 <shapr> My Evil Project might end up being a waste of time, so I'd rather not talk about it until it does something, or proves to be nothing useful.
15:04:35 <SamB> Frederick: why do you keep saying "registers"
15:04:37 <SamB> haskell does NOT have registers!
15:04:41 <SamB> Frederick: you mean records?
15:04:42 <wchogg> Well, then good luck shapr.
15:04:44 <Frederick> SamB, how do I call that?
15:04:49 * Frederick is more than confused now
15:04:57 <Frederick> yep
15:04:59 <Frederick> sorry
15:05:04 <SamB> okay
15:05:10 <SamB> so you meant records
15:05:12 * Frederick takes note of the right term
15:05:31 <Frederick> yepo
15:05:43 <SamB> that kind of question we can answer
15:05:48 <SamB> hmm
15:06:11 <SamB> okay, so you are confused because they look imperative
15:06:42 <SamB> lets see... how to explain that records are actually just sugar for normal positional data constructors...
15:06:53 <araujo> I can perfectly have an if .. then .. else clause inside a do { .. } right?
15:06:54 <SamB> do you know about normal data constructors?
15:06:59 <SamB> araujo: of course
15:07:07 <SamB> just as long as you get the indentation right
15:07:11 <araujo> SamB, Thanks ....
15:07:13 <araujo> Right
15:07:24 <SamB> araujo: no need to worry if you actually use braces, of course
15:08:13 <SamB> Frederick: so, you know about normal data constructors right?
15:08:28 <Frederick> SamB, at least I think so
15:08:59 <SamB> Frederick: okay. so a record constructor is just a sugar-coated data constructor.
15:09:18 <Frederick> hm
15:09:25 * Frederick doesnt like sugar :p
15:09:52 <ski__> honey ?
15:10:16 <SamB> Frederick: we could ditch the sugar and use a normal one...
15:10:28 <SamB> Frederick: would you like that better?
15:10:33 <Frederick> they seem to have a obvious reason to be used like that cause the samples ive checked seem very linear, like there is no fancy construction or semantics about it but they have some special property I cant figure out
15:11:14 <Frederick> SamB, I would like to learn how to use the one with sugar since it seems to be the dfautk
15:11:25 <SamB> Frederick: no it isn't
15:11:41 <SamB> the other kind aren't called records
15:11:50 <Frederick> but they are in most part of the samples
15:11:59 <Frederick> the sugar one
15:12:06 <SamB> they are called positional constructors
15:12:41 <SamB> really I think if we cut the sugar it could be instructive
15:12:50 <ski__> data Person = P {name :: String, address :: String, age :: Int}
15:12:54 <Frederick> SamB, you are the teacher here
15:12:56 <SamB> you might want to save the file under a new name first
15:12:58 <Frederick> I wil lfollow you
15:13:02 <SamB> okay.
15:13:07 <ski__> data Person = P String String Int   -- desugared
15:13:25 <SamB> ah, yes, look and see what ski__ just wrote
15:13:50 <SamB> ski__: do you also do record update?
15:13:57 <ski__> yes
15:14:11 <SamB> cool. because GHC's output would be tricky to read
15:14:34 <ski__> ski = P {name = "Stefan", address = "Somewhere in Gothenburg", age = 24}
15:14:39 <ski__> ski :: Person
15:14:49 <ski__> that defines a record value
15:14:58 <SamB> Frederick: you follow this
15:14:59 <SamB> ?
15:15:33 <Frederick> SamB, oki the first thing ski defined is the structure of the record, te seconcd is it signature osnt it? than ski updated it, in fact binded values to one instance? can I say instance of it?
15:16:11 <ski__> i haven't updated it yet
15:16:20 * Frederick suicides
15:16:29 <SamB> Frederick: actually, the second thing ski defined was a sugar-free version of the same datatype, essentially what you have in the middle of the compiler
15:16:58 <ski__> the second 'data' is how it would look like, if desugared, i.e. not using record syntax
15:17:17 <Frederick> SamB, but how can he refer to a given field of that sugar free record?
15:17:24 <SamB> Frederick: hmm.
15:17:56 <dcoutts> ibid, ayh?
15:17:57 <Frederick> on the first if he calls name I can see why he would return Stefan but on the second version it seems wierd for me to expect an output
15:18:18 <SamB> Frederick: well, you'd need to define
15:18:35 <SamB> name (Person x _ _) = x
15:18:39 <dcoutts> SamB, you've seen this? : http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
15:18:58 <dcoutts> SamB, you were asking about graphs earlier
15:19:04 <SamB> no
15:19:20 <ski__> hm
15:19:23 <SamB> dcoutts: I want inter-modular dependency graphs
15:19:32 * ski__ tries again
15:19:32 <SamB> well, I mean, it would be nice
15:19:41 <dcoutts> SamB, yeah, so would I
15:19:45 <ski__> Frederick : i'm going to show two variants of the same thing
15:19:50 <Frederick> k
15:20:04 <dcoutts> SamB, I want a module dep graph as a module browser for hIDE
15:20:04 <ski__> one is using the record syntactic sugar
15:20:19 <ski__> one is not using that, but just plain datatypes
15:20:20 <SamB> dcoutts: that would be sweet.
15:20:24 <dcoutts> SamB, in addition to the ordinary file and module namespace browser views
15:20:25 <ski__> Frederick : ok ?
15:20:35 <SamB> but it would also be nice to see haskellSense work without ghc-api
15:20:37 <Frederick> k
15:20:42 <Frederick> im all eyes
15:21:08 <dcoutts> SamB, well you need some language framework for doing the syntax & semantic analysis
15:21:25 <dcoutts> ghc-api does that pretty well
15:21:29 <SamB> dcoutts: truu, I suppose...
15:21:33 <dcoutts> thoguh it's a bit hairy
15:21:45 <SamB> but it doesn't like 6.4 at all. or rather 6.4 doesn't like it.
15:21:51 * ski__ waits for room to become slightly less noisy
15:22:07 <dcoutts> SamB, it'll be ok in 6.6
15:22:22 <dcoutts> SamB, sicne it'll be supplied by default rather than a hacked backport
15:22:53 <ski__> data Person = P {name :: String, address :: String, age :: Int}  -- this defines a datatype Person, using record sugar
15:23:25 <ski__> data Person = P String String Int   -- this defines the corresponding datatype, without sugar
15:23:29 <SamB> dcoutts: well, I thought it was one of those fixed-in-6.4.1 things
15:23:55 <ski__> (only one of these should be used, of course)
15:24:00 <dcoutts> SamB, the ghc package only comes with ghc-6.5/6.5
15:24:02 <Frederick> ski__, the first definition doesnt shocks me in fact it is very near the C's definition for a struct
15:24:06 <ski__> Frederick : ok ?  questions ?
15:24:09 <ski__> right
15:24:16 <Frederick> none so far
15:24:16 <dcoutts> SamB, but Lemmih back-ported it to ghc-6.4.1 with limited success
15:24:38 <ski__> ok, then i construct a record value
15:24:38 <dcoutts> SamB, most of it works (except the bytecode interpreter)
15:24:44 <ski__> ski :: Person
15:25:16 <ski__> (that's just a type signature, not needed, but informative here, to remind that this is a value of type Person)
15:25:19 <SamB> you mean we get a bytecode interpreter for free?
15:25:20 <SamB> cool!
15:25:30 <ski__> ski = P {name = "Stefan", address = "Somewhere in Gothenburg", age = 24}
15:25:40 <ski__> this defines the record value
15:25:58 <ski__> we use the constructor name 'P' from the type definition above
15:26:05 <Frederick> k
15:26:15 <ski__> order of fields is not important, here
15:26:24 <Frederick> why not!?
15:26:31 <ski__> ski = P {age = 24, address = "Somewhere in Gothenburg", name = "Stefan"}
15:26:37 <ski__> works just as well
15:26:54 <ski__> Frederick : because the parts (fields) are *named*
15:27:12 <ski__> that's one of the points of using names, we don't have to rely on position
15:27:19 <ski__> ok ?
15:27:40 <Frederick> k
15:27:51 <ski__> contrast with the desugared version
15:28:05 <ski__> ski = P "Stefan" "Somewhere in Gothenburg" 24
15:28:11 <bosie> how do i divide 2 integer values to realfrac ?
15:28:13 <ski__> here the order is important
15:28:38 <SamB> hmm, GHC's desugared version just needs some barbed wire ;-)
15:28:44 <Frederick> ski__, hm this is pretty much updating fields in sql Ive justrealized it now
15:28:58 <SamB> Frederick: nonsense
15:28:59 <ski__> > fromIntegral 2 / fromIntegral 3 :: RealFrac a => a
15:29:00 <lambdabot> 0.6666666666666666
15:29:05 <Frederick> SamB, ?
15:29:09 <SamB> nothing has been done yet
15:29:19 <ski__> Frederick : i haven't covered updating, yet
15:29:24 <Frederick> SamB, what do you mean?
15:29:25 <SamB> and nothing will be mutated anyway
15:29:27 <ski__> just creating an initial record value
15:29:52 <Frederick> oki but the only placxe I remmember seeing such thing as using unlabelled fields was in sql
15:29:57 <bosie> ski__ muchas gracias
15:30:30 <ski__> anyway
15:30:43 <ski__> we want to be able to acces parts of a record
15:30:57 <ski__> s/acces/access/
15:31:21 <ski__> recall
15:31:22 <ski__> data Person = P {name :: String, address :: String, age :: Int}
15:31:28 <Frederick> k
15:31:37 <ndm> does anyone have any experience with FFI?
15:31:47 <ski__> this declares 'name' , 'address' and 'age' as selectors for this record datatype
15:31:50 <eivuokko> ndm, some.
15:31:52 <SamB> ndm: dons does ;-)
15:31:53 <ndm> specifically, can you pass a higher order function as a parameter to a C function
15:31:58 <bosie> hm is there some way i know what value a certain variable has ? like debugging 
15:32:04 <SamB> ndm: look in Gtk2Hs
15:32:13 <ski__> that means that one can use those as field names inside 'P {...}', for *setting* fields
15:32:13 <ndm> does it do that?
15:32:24 <eivuokko> ndm, You mean just callback?  Yes you can, with FunPtr
15:32:25 <SamB> hmm. higher-order...
15:32:40 <ndm> runMain :: Module -> (Char -> IO ()) -> (Char -> IO ()) -> (IO Char) -> IO ()
15:32:42 <SamB> you mean like a call-back that takes a function or returns one?
15:32:46 <ndm> thats the signature i want
15:33:01 <ndm> so runMain takes 4 parameters, 2 of which are functions
15:33:06 <ski__> you also use these selectors to access the fields, but in a slightly different way
15:33:29 <ski__> that 'data' declaration above implicitely also defines (selector) functions
15:33:34 <ski__> name :: Person -> String
15:33:38 <ndm> so yeah, essential it takes callback functions
15:33:39 <ski__> address :: Person -> String
15:33:45 <ski__> age :: Person -> Int
15:33:56 <Frederick> k
15:34:21 <ski__> so, to access the parts, e.g. the age we evaluate 'age ski'
15:34:26 <SamB> ndm: you need to do something with "wrappers"
15:34:42 <ndm> SamB, how painful are we talking?
15:35:09 <SamB> ndm: like go through Gtk2Hs and figure out how that does it.
15:35:11 <SamB> not too bad
15:35:31 <ndm> cool
15:35:38 <ski__> Frederick : note that it's slightly confusing that when field names are used at left of '=' inside 'P {...}', it means that part, but when used otherwise, it means a *function* from the whole record to that part of the record
15:35:40 <eivuokko> ndm, wrappers are one linerss mostly.
15:35:55 <SamB> grep for "foreign .*wrapper"
15:36:07 <SamB> I think
15:36:12 <ndm> thanks very much for your help - makes the idea of a Haskell runtime dll much nicer
15:36:19 <ndm> and allows for "GHCi" for Yhc
15:36:24 <Frederick> ski__, I couldnt get the last whole idea
15:36:36 <ski__> ok, once again
15:37:12 <ski__> P {name = ..some string.., age = ..some int.., address = ..some string..}
15:37:19 <ski__> this is an expression of type Person
15:37:21 <ski__> ok ?
15:37:33 <Frederick> k
15:37:41 <ski__> if we say
15:37:46 <ski__> person = P {...}
15:37:49 <ski__> then
15:38:02 <ski__> name person
15:38:17 <ski__> is a string, namely the 'name' part of the person
15:38:29 <ski__> so, in e.g. C you'd write this as person.name
15:38:42 <Frederick> ski__, oki I can see this
15:38:42 <ski__> understand ?
15:39:29 <Frederick> yup
15:39:44 <ski__> so, to access the fields of a record in haskell, e.g. the 'name' field, you call the selector functor 'name :: Person -> String'
15:40:12 <ski__> that function just looks up the field in the person record given, and returns the field value
15:40:17 <ski__> ok
15:40:25 <ski__> now
15:40:34 <ski__> data Person = P {name :: String, address :: String, age :: Int}
15:40:42 <ski__> this was the sugared version, i said
15:40:49 <ski__> in the desugared version
15:41:01 <ski__> data Person = P String String Int
15:41:26 <ski__> you can define the selector functions for accessing in the same way, only explicit
15:41:34 <ski__> name :: Person -> String
15:41:43 <ski__> name (P n _ _) = n
15:41:49 <ski__> address :: Person -> String
15:41:58 <ski__> address (P _ a _) = a
15:42:05 <ski__> age :: Person -> Int
15:42:12 <ski__> age (P _ _ a) = a
15:42:18 <ski__> understand ?
15:42:35 <ski__> (this is all that the selector functions do)
15:42:38 <Frederick> the second line of each definition associate the value with the position it will have inside of the record right?
15:42:49 <ski__> yes
15:42:50 <Frederick> *associates
15:43:12 <Frederick> k this is oki for me
15:43:43 <ski__> there is another way to get the values of the fields in the sugared version
15:43:50 <Frederick> but in the source I have we are using the records to initialize a value the function will take as argument, this is the wierd thing for me
15:44:01 <ski__> consider a function 'foo' that we want to write
15:44:06 <Frederick> k
15:44:09 <ski__> foo :: Person -> ...
15:44:33 <Frederick> k
15:44:38 <ski__> foo (P {name = n, age = x, address = a}) = ..n..x..a..
15:45:06 <Frederick> k
15:45:14 <ski__> we can also use a record pattern, like that, each part to the right of the '=' inside there is a pattern, in this case a variable
15:45:54 <ski__> foo (P {name = n, age = x, address = 42}) = ..n..x..  -- this clause would only match those with age 42, e.g.
15:46:25 <SamB> Frederick: I think you still don't understand "where" properly...
15:46:57 <ski__> (also, in record patterns (as well in in record expressions), the order of the fields doesn't matter .. since we use names, we don't have to rely on position/order)
15:47:31 <SamB> Frederick: maybe you should paste the code you have
15:48:03 <ski__> Frederick : any unclear things ?   should i continue to record "update" ?
15:48:41 <SamB> ski: I think he is confused because we have a record update at the top of a function...
15:49:12 <ski__> SamB : where ?
15:49:35 * SamB waits for Frederick to paste the code
15:49:46 <ski__> http://paste.lisp.org/display/13629 ?
15:50:06 <SamB> ski: I couldn't say if thats the latest or not
15:50:17 <SamB> I almost wish he'd start a darcs repo ;-)
15:51:07 <shapr> ndm: You have an FFI question?
15:51:22 * ski__ could try explaining the record uses in that code .. but preferable after i've done it on these simple examples i do here ..
15:51:49 <SamB> ski: sure, go ahead
15:52:09 * ski__ waits for Frederick
15:52:25 <Frederick> ski__, yes this is the last
15:52:32 <Frederick> I was just runing diff to be sure
15:52:39 <SamB> ah
15:53:00 <ski__> did you have any questions regarding what i said last above, regarding record patterns ?
15:53:28 <Frederick> ski__, I think im with you untill what you said
15:53:47 * shapr is slowly figuring out how PacketParsing works.
15:54:19 <ski__> Frederick : so, should i continue to record "update" ?
15:54:40 <Frederick> yep
15:54:43 <ski__> ok
15:55:19 <ski__> i put quotes around "update" to emphasize that it doesn't *change* a record
15:55:32 <ski__> it's sometimes called "functional update"
15:55:40 <ski__> anyway, remember
15:56:18 <ski__> ski = P {name = "Stefan", address = "Somewhere in Gothenburg", age = 24}
15:56:30 <ski__> now, let's update this
15:56:36 <ski__> ski__ :: Person
15:56:53 <ski__> ski__ = ski {age = 25}
15:57:09 <SamB> ski__: why do the underlines make you older?
15:57:43 * ski__ celebrated birthday some 11 days ago
15:57:59 <SamB> have you been stuck with that nick ever since?
15:58:06 <ski__> so, that is my new age
15:58:11 <int-e> SamB: maybe they're wrinkles, they make him look older ;)
15:58:26 <ski__> SamB : not, not really :)   just was first example i came up with
15:58:32 <ski__> hehe
15:58:33 <SamB> hehe
15:58:57 <ski__> Frederick : note, i used an old record ('ski') instead of the record constructor 'P'
15:59:23 <Frederick> ski__, I didnt got it
15:59:25 <Frederick> *get
15:59:46 <ski__> this means i create a new record from an old, reusing non-changed parts  (instead of creating a fresh new record, and providing values for all fields)
15:59:57 <Frederick> k
16:00:02 <ski__> 'ski' is a record
16:00:11 <ski__> to update it, we do 'ski {...}'
16:00:22 <ski__> s/update/"update"/
16:00:46 <Spark> whats that monad tutorial
16:00:49 <Spark> i'm home now
16:00:50 <Frederick> k
16:00:54 <ski__> and put new values for some fields in the '...' .. the rest of the fields are kept (copied) from the old record
16:00:59 <Spark> SamB: moo
16:01:15 <ski__> the old record is still available, but we have a new which shares the nonmodified parts
16:01:35 <ndm> shapr, I want higher order functions passed as parameters to FFI
16:01:58 <Frederick> k
16:01:59 <ndm> @wiki Yhc/YhiApi
16:01:59 <lambdabot> http://www.haskell.org/hawiki/Yhc/YhiApi
16:02:21 <ski__> Spark : http://www.nomaware.com/monads/html/
16:02:22 <ndm> then runMain function there will be written in C, and wants to be called by Haskell
16:02:56 <ski__> Frederick : ok, that was it, i think
16:02:58 <SamB> ski__: iirc, we sent him there already. like twice.
16:03:12 <ski__> oh
16:03:41 <Frederick> ski__, but I have a record update before my function that doesnt looks like that
16:03:50 <Spark> thassit
16:03:57 <ski__> removeEmpties1 cfg = cfg { productions = prods'' }
16:03:58 <SamB> Spark, I mean
16:04:06 <Frederick> ski__, yes
16:04:15 <ski__> cfg is a record
16:04:33 <ski__> 'productions' is a field name, and prods'' is the new value for that field
16:04:58 <dons> @seen SamB
16:04:58 <lambdabot> SamB is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 59
16:04:58 <lambdabot> seconds ago.
16:05:06 <dons> oh. heh.
16:05:18 <SamB> dons: hello
16:05:23 <shapr> ndm: http://www.haskell.org/hawiki/FfiTutorial
16:05:25 <dons> SamB, so hmp3 does what now? it still goes silly, but just takes longer to do so?
16:05:33 <SamB> did you know that hmp3 also plays mp2s?
16:05:34 <ski__> removeEmpties1 takes the record 'cfg' and returns a record which is same as 'cfg', except the 'productions' field has been updated to prods''
16:05:42 <dons> oh, didn't know that.
16:05:45 <SamB> dons: I guess so
16:05:46 <ski__> Frederick : ok ?
16:05:57 <SamB> I mean it didn't go totally nuts, but it was creeping
16:06:17 <dons> right. i put it on a slow machine, and after about an hour it had 50% cpu.
16:06:32 <Frederick> ski__, ahhhh not it started to make sense so if I want to remove productions that substitute variables I do something like removeReplacers cfg = cfg { productions = prodssimp}
16:06:43 <dons> the mem didn't really go far though.
16:06:49 <Frederick> but why do I update the record on the beginning of the function and not on its end?
16:06:51 <dons> it's weird.  I'''m suspiciious it's the GC since nothing else is happening in the profiles.
16:07:04 <ski__> Frederick : yes .. 'prodssimp' being the replacement value for that field
16:07:12 <SamB> dons: huh.
16:07:21 <dons> SamB, luckily I still have some tricks up my sleeve
16:07:34 <SamB> dons: I don't suppose this thing works in NHC98 or hugs?
16:07:43 <dons> ah, hugs maybe.
16:07:47 <dons> I should try it.
16:07:54 <ski__> Frederick : one mostly doesn't specify order of things to evaluate in haskell
16:08:00 <dons> nhc no. no concurrency.
16:08:14 <Spark> SamB: yeah but i went home and then realised i didnt remember the url :)
16:08:21 <SamB> dons: ah
16:08:36 <ski__> Frederick : you could rewrite 'foo x = y  where y = x * x' into 'foo x =  let y = x * x  in y'
16:08:37 <SamB> Spark: ah
16:09:14 <ski__> Frederick : i.e. you could take all the stuff after the 'where', and put it before the expression before the 'where', using a 'let-in' instead
16:09:36 <SamB> Spark: hmm, if you would say what you want on the same line as you mention my nick, especially when others talking have nicks of similar length and coloration, that would be nice ;-)
16:09:46 <Frederick> ski__, so my code starts with something like that removeReplacers cfg = cfg { productions = prodssimp}
16:09:49 <Frederick> where
16:09:55 <Frederick> prodssimp = productions cfg?
16:10:47 <SamB> ski: you are doing a good job of explaining all this stuff ;-)
16:10:47 <SamB> I didn't do nearly this well when I tried
16:10:52 <ski__> Frederick : see http://paste.lisp.org/display/13629#1
16:11:07 <ski__> Frederick : yes
16:11:14 <ski__> SamB : ty
16:11:23 <Frederick> ski__, great it loaded smooth
16:11:44 <ndm> dons, Tom said he was going to add concurrency to yhc - so soonish maybe
16:11:46 <Frederick> ski__, but this cfg im using to update will be at run time the cfg updated by remove empties right?
16:11:48 <ndm> once its working properly
16:11:52 <ski__> mosty, i prefer using 'where' when i can
16:11:56 <Spark> how is hte concurrency implemented?
16:12:22 <ski__> Frederick : hm, could you rephrase that questoin ?
16:12:24 <Frederick> ski__, what is that?
16:12:54 <ski__> foo x = ..blah..
16:12:57 <ski__>   where
16:13:00 <ski__>   ..bleh..
16:13:02 <Frederick> ski__, yes for e.g. I apply remove empties over my grammar oki?
16:13:05 <ski__> as opposed to
16:13:09 <ski__> foo x =
16:13:15 <ski__>   let ..bleh..
16:13:17 <Frederick> so in the end I will have a updated grammar without the empties oki?
16:13:19 <ski__>   in  ..blah..
16:14:16 <ski__> Frederick : yes
16:14:33 <Frederick> ah oki I got the concept now the coin fallen
16:14:37 <dons> can someone write me a nice ternary operator?
16:14:39 <ski__> the function returns an updated record (grammar, here)
16:16:15 <stefanw> dons, remember the 99% CPU usage of riot? I think it's a runtime bug. When you invoke riot with +RTS -B -RTS, edit some file, close the editor, then the terminal bell (i.e. that GC) goes crazy
16:17:08 <liyang> Spark: http://www.haskell.org/ghc/docs/latest/html/users_guide/concurrent-and-parallel.html
16:17:20 <dons> ah. good idea. I just don't want that to be the problem :/
16:17:56 <dons> and why doesn't lambdabot have this behaviour.
16:18:05 <Spark> liyang: but which one is it
16:18:06 <dons> i'll try this -B trick.
16:18:11 <Frederick> SamB, is there any function I can use to automatically handle ths list of productions when I remove them?
16:18:19 <shapr> dons: I think n-ary ops already exist.
16:18:34 <liyang> Spark: read the page. :p~
16:18:36 <stefanw> does lambdabot invoke external commands via Syste.Cmd.system?
16:18:52 <stefanw> s/Syste/System
16:19:16 <shapr> dons: Couldn't you use Conor McBride's Idiom?
16:19:34 <SamB> Frederick: hmm?
16:19:53 <shapr> dons: http://www.cs.nott.ac.uk/~ctm/notions/implementation/utilities/idioms/
16:19:54 <ski__> handle, how ?
16:20:12 <Frederick> SamB, cause I think I need use Map.mapWithKey
16:20:28 <dons> stefanw, -B is a good trick! I now see there's one gc per refresh.
16:21:07 <SamB> Frederick: I'm not really sure what you need to do.
16:21:15 <stefanw> in which application
16:21:18 <Frederick> SamB, cause if I have S -> aBc B -> b I need to get S-> abc and let B -> []
16:21:21 <SamB> but I think you can probably figure it out
16:22:04 * SamB hasn't thought about
16:22:30 <dons> stefanw, in hmp3.
16:22:42 <dons> which might be reasonable, or might not be.
16:22:57 <dons> we'll see what happens in an hour or two
16:23:09 <SamB> dons: I thought you said you did that on purpose?
16:23:51 <dons> did what?
16:24:05 <stefanw> the problem with riot is that the GC produces some sort of continuous sound, that is, the GC runs ALL the time
16:24:11 <dons> ah!
16:24:41 <dons> haven't seen that yet. but hmp3 is only at 0.44% cpu atm
16:25:10 <dons> it does seem like a GC issue though, sincee all my space-packing tricks only seem to delay the inevitable (by some hours)
16:26:12 <stefanw> the strange thing in riot is that all happens only *after* launching the editor via System.Cmd.system
16:26:14 <Igloo> What's hmp3 actually doing? Blocking read from stdin, update display, loop?
16:26:30 <Frederick> hwere is the monter :p http://rafb.net/paste/results/d2rCuo28.html
16:26:31 <dons> yeah. just blocked almost all the time.
16:26:46 <SamB> Igloo: it threads
16:27:05 <dons> it hasss 4 or 5 threads blocked on different handles/mvars.
16:27:21 <SamB> Igloo: and one thread reads from mpg123 or whatever
16:27:29 <Igloo> Oh, yes, I didn't mean stdin at all
16:27:31 <dons> so stdin, on the external decoder tool, and on two state components.
16:27:36 <Igloo> But you'll obviously want to be listening to that too  :-)
16:27:48 <dons> the state gets updated when it's mvar is touched. 
16:28:12 <dons> unforuntately, all my heap profiles and such seem to indicate nothing much is happening
16:28:27 <dons> but mysteriously the cpu load just creeps up
16:28:40 <SamB> oh, it looks like you broke seeking in a song at some point
16:28:51 <dons> SamB, I think I fixed that last night.
16:28:55 <dons> pull the latest patch.
16:29:00 <SamB> it seems to just restart the song now!
16:29:08 <dons> up. still broken. i didn't push the patch.
16:29:14 <dons> s/up/grump/
16:29:30 <SamB> dons: did you push it?
16:29:44 <SamB> hehe
16:30:30 <dons> I rewrote the lexer to use less space, and  broke the ppr in the process, just for the JUMP signal
16:31:03 <shapr> dons: way spiffy - http://svcs.cs.pdx.edu/trac/wifi/ and svn co http://svcs.cs.pdx.edu/svn/wifi/
16:32:18 <dons> shapr, cool.
16:33:20 <shapr> Makes me want to buy a USRP.
16:34:38 <Frederick> SamB, how can I take a value back once it is evaluated?
16:35:05 <dons> stefanw, also you can get gc stats printed to stderr +RTS -Sstderr -RTS
16:35:33 <SamB> Frederick: huh?
16:35:38 <dons> SamB, patched.
16:35:49 <SamB> why do you want to wait until AFTER it is evaluated?
16:36:08 <Frederick> SamB,like Im wondering if I will need a special function the implement the transitive closure
16:36:21 <ski__> Frederick : 'take a value back' means ?
16:36:44 <SamB> help! what does transitive closure mean?
16:36:55 <Frederick> like if A -> Ba B-> C  C->a I must have aa
16:37:04 <ski__> transitive closure means just what it says
16:37:24 <dons> @foldoc closure
16:37:26 <lambdabot> *** "closure" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
16:37:26 <lambdabot> "
16:37:26 <lambdabot> closure
16:37:26 <lambdabot>  
16:37:26 <lambdabot>    1. <programming> In a {reduction system}, a closure is a data
16:37:27 <lambdabot> [29 @more lines]
16:37:32 <dons> etc etc..
16:37:51 <Frederick> http://mathworld.wolfram.com/TransitiveClosure.html
16:37:55 * ski__ isn't fully sure what Frederick means by it here, in this context, though
16:38:12 <SamB> hmm, that does look familiar...
16:38:16 <SamB> hmm...
16:38:44 <Frederick> if A -> B B -> C C -> a B, C and c are the transitive closure of A
16:38:44 * SamB isn't quite sure how to tie this knot, though
16:39:01 <ski__> you can take the transitive closure of an endo-relation .. the result is a new endo-relation
16:39:26 <ski__> Frederick : surely you don't want to expand all nonterminals, right ?
16:39:57 <Frederick> ski_, this might be a better definition of what I need, take in mind I got a crappy book
16:40:55 <SamB> hmm. Oh.
16:41:03 <SamB> I think I sort of get what is needed.
16:41:24 <Frederick> let me check fot a descent book
16:41:29 <stefanw> what's MUT time
16:42:00 <SamB> @hoogle (a -> Maybe b) -> Data.Map.Map k a -> Data.Map.Map k b
16:42:01 <lambdabot> No matches, try a more general search
16:42:22 <stefanw> bad question, sorry. Does anybody know what MUT time in the statistics file for the GC means?
16:43:15 <dons> is it the time spent in the mutator? or the mutable list?/
16:43:57 <stefanw> the user time for riot is now 7.64s and the MUT time of the GC is 7.61s. 
16:44:29 <int-e> mutator time, perhaps (i.e. user)
16:44:41 <int-e> err, as dons just said
16:44:42 <dons> how did you get the MUT time? 
16:44:52 <int-e> dons: +RTS -S  prints it
16:45:28 <stefanw> yep
16:46:14 <dons> hmm. I only see: 
16:46:15 <dons>     Alloc    Collect    Live    GC    GC     TOT     TOT  Page Flts
16:46:15 <dons>     bytes     bytes     bytes  user  elap    user    elap
16:46:25 <int-e> dons: finish the program :)
16:46:26 <dons> are you using other profiling flags?/
16:46:30 <dons> oh. ok. :)
16:46:37 <SamB> okay, something like
16:46:44 <stefanw> at the very end? or use +RTS -s -RTS, that prints a shorter summary
16:47:13 <SamB> @hoogle [a] -> Bool
16:47:14 <lambdabot> Data.List.null :: [a] -> Bool
16:47:14 <lambdabot> Prelude.null :: [a] -> Bool
16:47:14 <lambdabot> Graphics.UI.ObjectIO.CommonDef.isSingleton :: [x] -> Bool
16:47:18 <int-e> 'mutator' is GC speak for the user part of the program that allocates and manipulates (hence the name) the heap data, so that's very likely what 'MUT' means.
16:47:51 <SamB> hmm...
16:48:16 <dons> hmm   %GC time       5.6%  (0.6% elapsed)
16:48:27 <dons> stefanw, what does riots log look like?
16:49:46 <SamB> Map.fromList [ (nt, prod) | (nt, [prod]) <- Map.toList productions cfg ]
16:49:58 <SamB> do that, and then take a transitive closure of that...
16:50:02 <stefanw> @help paste
16:50:03 <lambdabot> paste page url
16:50:07 <SamB> well. maybe not quite...
16:50:21 <int-e> @paste
16:50:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:50:32 <int-e> lisppaste, url
16:50:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:50:38 <SamB> that might be close, though.
16:51:22 <SamB> oh, not even quite the right precedence
16:51:31 <lisppaste2> stefanw pasted "riot's GC statistics" at http://paste.lisp.org/display/13637
16:53:42 <Frederick> SamB, what do you mean?
16:54:42 <SamB> Frederick: I'm actually not quite sure
16:54:47 <SamB> I think you need someone cleverer than I for this!
16:54:48 <dons> interesting, stefanw. I'll post hmp3 in soon, when it reaches bad behaviour.
16:55:07 <Frederick> SamB, this is very tricky
16:55:14 <Frederick> and my teacher says it is triviakl
16:55:19 <dons> but already I see that hmp3 has a higher GC %. though less bytes are being allocated in general  (by a factore of 10 or more)
16:56:23 <dons> I think riot could do with some space profiling ;)
16:57:37 <SamB> Frederick: well, it is. Except if you want to be reasonably sure you don't end up with an infinite datastructure
16:57:48 <SamB> or do I mean an infinite loop
16:57:59 <ski__> (possibly both)
16:58:10 <Frederick> SamB, Im checking for a boot with a better description of the algorithm it might give some clues
16:58:18 <SamB> the difference between them is not so great, really.
16:59:01 <dons> SamB, how fast is your cpu?
16:59:15 <SamB> Frederick: do you only need to deal with case where there are only one symbol?
16:59:34 <dons> and what level of cpu saturation does it reach after the 1.5 hrs you mentioned?
16:59:42 <SamB> dons: 450 MHz PII
16:59:59 <SamB> didn't I tell you?
17:00:20 <SamB> I think I said 30-40%
17:01:15 <dons> no, I think you just said it was a PII.
17:02:07 <SamB> no, I mean about the saturation
17:02:20 <SamB> I'm also on 56k, and lagged
17:02:30 <dons> oh, yeah, I think you said around 30-40%. my fault.
17:03:08 <Frederick> SamB, nope this is the problem A -> SaB S->a B->a must also result itn A-> aaa
17:03:26 <SamB> and I'm not positive it wasn't an hour or two hours
17:03:38 <dons> getting a slow machine helps debug this problem: I get to 12% after 7mins on a VIA Samuel 2 ("CentaurHauls" 686-class) 533 MHz
17:03:43 <SamB> Frederick: that doesn't loook too tricky
17:03:56 <dons> this box: http://www.cse.unsw.edu.au/~dons/via_openbsd.html :)
17:04:48 <dons> also known as my gf's desktop ;)
17:05:21 <dons> (it's fine for mozilla and editing and such)
17:05:28 <SamB> dons: and does she really appreciate you profiling your mp3 player on it?
17:05:58 <dons> well, when she's at work, she doesn't mind
17:06:01 <SamB> in my experience, most of what mozilla wants is RAM...
17:06:05 <SamB> ah
17:06:11 <dons> yeah, it's got enough ram.
17:06:33 <dons> I think I might buy anothe rone of these and use it as a stereo in the living room 
17:06:46 <dons> running hmp3 (via a tv tuner) of course!
17:06:48 <SamB> mine hasn't :-(
17:06:59 <SamB> its only got like 256 MiB
17:07:29 <dons> oh, I think that's what this has.
17:07:49 <dons> but she only uses firefox, and no java. so that seems to work.
17:09:02 <SamB> she must not be such a mad tab-opener as I am
17:09:13 <dons> hehe maybe.
17:09:29 <dons> many tabs even stress my laptop, which is pretty quick
17:09:34 <SamB> or maybe a better version of firefox
17:09:52 <SamB> its the RAM, I say. the RAM.
17:10:15 <SamB> Half the RAM it uses (or so) seems to be in the X server
17:10:33 <dons> firefox 1.0.6?
17:11:08 <SamB> oh, that uptime thingy doesn't seem to stay in one place very well
17:11:37 <SamB>  26% (204 files)                   play                      0:1140 hmp3 0.0p97
17:11:43 <dons> ah, I see that too now: 0:222
17:11:44 <dons> :/
17:11:53 <dons> another thing that I broke at 12 last night
17:13:37 <SamB> maybe should stop coding at 11:30?
17:14:17 <dons> or get more green tea and lindt 70% in to me :)
17:15:26 <Speck> mmmm... green tea
17:20:18 <shapr> mmm, md5 collisions in 45 minutes on a 1.6GHz P4
17:20:27 <lisppaste2> dons pasted "GC for hmp3" at http://paste.lisp.org/display/13638
17:20:53 <Frederick> SamB, you said that the algorithm didnt look too trick but I cant make it even in C :p how eill I deal with all the possibilities?
17:21:57 <SamB> Frederick: you will need to step carefully.
17:22:12 <SamB> Ask the question again
17:22:48 <SamB> and note that my brain gets fogged up on tuesdays and thursdays
17:22:53 <Frederick> SamB, this is the problem A -> SaB S->a B->a must also result itn A-> aaa but we must take in mind that it is infinite
17:23:05 <Frederick> SamB, what speceial about these days?
17:23:21 <Frederick> Usually I have class 8~18 on tuesdays and thursdays
17:23:47 <SamB> Frederick: I get up earlier to go to a history class
17:24:11 <Frederick> SamB, I tought you study something like CS or Math
17:24:12 <lisppaste2> dons annotated #13638 with "Even longer run" at http://paste.lisp.org/display/13638#1
17:24:57 <SamB> Frederick: eh, well, its a long story
17:25:30 <Frederick> SamB, does beatifull cheicks also attend to the class?
17:26:14 <SamB> Frederick: no
17:27:43 <Frederick> SamB, so I see no point to go to the class :p
17:28:55 <SamB> Frederick: well, yeah, there isn't much actually
17:29:11 <SamB> but I was hoping to get some practice with essays...
17:29:33 <Frederick> SamB, hmmm... I like history too, usually I read at the buss
17:29:36 <Frederick> *bus
17:29:40 <Frederick> if Im not sleeping
17:30:31 <Frederick> SamB, can I handle the grammar as a graph?
17:30:46 <SamB> history is okay, but these american history textbooks are of greatly inferior quality
17:31:19 <SamB> Frederick: it sounds like you want to handle part of it as one, at least
17:31:37 <SamB> I am called away
17:31:47 <SamB> presently
17:31:48 <Frederick> k
17:31:52 <Frederick> huh?
17:33:55 <Frederick> hey can i use dijkstras for that?
17:39:54 <Frederick> yo ski__ 
17:59:16 <ski__> hm .. (=<<) in some sense acts like application
17:59:21 <ski__> @type (=<<)
17:59:22 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
17:59:28 <ski__> @type ($)
17:59:29 <lambdabot> forall b a. (a -> b) -> a -> b
17:59:40 <shapr> What do you call the filesystem checker for ClusterFS? ClusterFsck obviously. Why does that make me nervous?
18:00:21 <ski__> heh
18:00:58 <ski__> (<<=) :: Comonad w => (w a -> b) -> w a -> w b
18:03:58 <Frederick> ski__, how is this operator called?
18:05:17 <ski__> (<<=) ?
18:05:26 <Frederick> yep Im looking to read about it
18:05:36 <ski__> there's no standard name yet, i think
18:05:45 * ski__ calls it 'preserve'
18:05:53 <shapr> dnib?
18:05:57 <ski__> hehe
18:06:34 <ski__> Frederick : Monads has lots of uses .. we haven't found all uses for Comonads yet, though
18:06:49 <Frederick> ski__, how can I read about something I dont know the name?
18:06:52 <Frederick> comonads?
18:06:59 * Frederick runs away scared
18:07:04 <ski__> they are experimental idea ..
18:07:04 * Frederick hides under the bed
18:07:12 <ski__> they aren't so scary
18:08:20 <ski__> but, you can safely ignore them currently
18:09:11 <ski__> (just some maniacs like me are looking for uses for them)
18:10:34 <Frederick> ski__, I wanna be your and SamBs pupil
18:10:45 <ski__> hehe
18:11:07 <ski__> your teachers are that bad ?
18:11:12 <Frederick> Despite all the head ache Im starting to see things I wouldnt even dream days ago
18:11:29 <Frederick> ski__, well you remmember the dictionary assigment and the class material right?
18:11:39 <ski__> vaguely
18:12:03 <Frederick> ski__, well  Iremmeber you said that was superficiall and missleading for some definitions
18:12:08 <Frederick> well things are getting worse
18:12:20 <ski__> mhm ?
18:13:07 <Frederick> ski__, they are lazy, most of them dont know how to code so they give us too big assigments then they cant even read our code and figure things out
18:13:57 <ski__> ok
18:15:33 <SamB> Frederick: comonads would scare me.
18:15:34 <Frederick> what should I look for this operator? http://www.zvon.org/php/Search/fastlookup.php?query= doents seems to feature them
18:15:45 <Frederick> Master!
18:15:50 <SamB> except for the fact that I have no need to associate with them
18:15:50 * Frederick bows
18:15:55 * SamB runs away
18:17:26 <Frederick> dang I cant find this operator
18:17:36 <SamB> which one?
18:17:37 <ski__> e.g. http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html defines 'extend' and '(=>>)'
18:17:39 <Frederick> ski__, isnt it a part of comonads? >p
18:17:45 <ski__> it is
18:17:54 <ski__> 'extend' is a really bad name, imo
18:17:59 <shapr> Comonads are a Haskell library.
18:18:00 * Frederick hits the head againts the keyboard
18:18:10 <shapr> You won't find comonads listed in the standard references.
18:18:20 <SamB> @index Comonad
18:18:21 <lambdabot> bzzt
18:18:36 <Frederick> well on the beginning of the work I was like omfg I need to code at les 100 lines of code a day to get it done
18:18:43 <SamB> or even in the slightly-beyond-standard references available to lambdabot
18:18:46 <ski__> anyway, (=>>) = flip extend, so extend = (<<=)
18:18:47 <Frederick> now im omfg if I code 6 lines a day I will make it!
18:18:47 <SamB> as I suspected...
18:19:01 <ski__> Frederick : hehe
18:19:49 <ski__> Frederick : anyway, you don't need to learn Comonads to solve your assigment
18:20:05 <ski__> so, you don't need to look at them (unless you're really interested)
18:20:07 <Frederick> ski__, this is much like an api does it have a little tutorial teaching how to use it?
18:20:12 <musasabi> Comonads are still an open research problem (with regards to their practical use)
18:20:19 <ski__> indeed
18:20:30 <Frederick> Im really interested in finishing this crap
18:20:37 <ski__> right
18:20:50 <Frederick> than I shall learn haskell for pleasure
18:20:53 <SamB> they might not really be very practical at all, for all I know
18:20:53 <ski__> so, if you want to look at Comonads, you could do that afterwards
18:20:53 <SamB> which is nothing ;-)
18:20:57 <Frederick> btw Im not drunk nor having fever
18:21:28 <SamB> after I heard the OI example comanad was unsafe and impure, I kinda got disinterseted
18:21:33 <int-e> Frederick: hmm. how about tired? on drugs? on coffeine?
18:21:41 <musasabi> In Uustalu's recent article he talked about the comonad on attribute grammar - but mentioned limitations due to Haskell - do you know if anyone has it working for dynamic grammars?
18:21:53 <Frederick> int-e, no no, maybe tired, but when I get veeeeeeeeery tired I just faint
18:21:56 <ski__> (SamB : that's only because haskell isn't linear !)
18:22:49 <musasabi> SamB: that is just because Haskell needs a stronger type system ;)
18:23:16 <Frederick> ski__, how do I use that arrow to solve my problem?
18:23:25 * Frederick wonders about the magic arrow
18:24:09 <ski__> SamB : i think this is really similar to exposing IO a = RealWord -> (a,RealWorld) is a problem (copy and discard of the world)
18:24:21 <ski__> Frederick : arrow ?
18:24:32 <SamB> ooh, magic arrow? isn't that what you use to kill Gannon in Zelda?
18:24:38 <Frederick> <<=
18:24:52 <ski__> SamB : that's light arrows .. at least in Ocarina ..
18:24:55 <Frederick> SamB, yep but I do prefer the flute part or the ocarin
18:24:57 <SamB> ski__: its not a proble,
18:25:06 <SamB> s/,$/m/
18:25:17 <SamB> nobody is stupid enough to import it and then go and destroy the world ;-)
18:25:27 <Frederick> I wich button I must press to talk via reg exps :p?
18:25:32 <Cale> (<<=) as in cobind?
18:25:38 <ski__> yes
18:25:54 <ski__> "  eval (Fby e0 e1) wenv = fby (eval e0 wenv) (eval e1 <<= wenv)"
18:25:57 <SamB> heh
18:26:25 <eivuokko> Comonads cause me headache.
18:26:36 <ski__> Frederick : i thought i said you can safely ignore Comonads for this assignment :)
18:26:41 <Frederick> what is Uustalu? Is it a kind of haskells godess I must sacrify my family?
18:27:09 <ski__> he's a cool guy, 'tseems :)
18:27:33 <Frederick> ski__, ive tried to map some graphs algorithms to my problem with no luck
18:27:41 <Cale> There ought to be the exact same difficulty understanding comonads as monads, given that they're dual.
18:27:50 <ski__> http://greta.cs.ioc.ee/~tarmo/ <<= looks fun to me, at least
18:28:16 <ski__> Cale : well, haskell is not fully dual
18:28:23 <ski__> s/dual/self-dual/
18:28:44 <SamB> Cale: shh!
18:28:55 <SamB> we don't want to mention that monads are difficult to understand!
18:29:00 <SamB> we might scare him!
18:29:03 <ski__> (that could possibly introduce assymetries in how easy it is to understand and use them)
18:29:09 <eivuokko> Hmmm.
18:29:21 <Cale> I don't mean that monads are difficult to understand. I mean that comonads aren't so difficult.
18:29:27 <SamB> oh
18:29:32 <ski__> they're just different
18:29:40 <ski__> and we haven't figured them much out, yet
18:29:48 * ski__ needs to leave
18:29:57 * ski__ waves
18:30:04 <SamB> thats like saying the dodecahedron is so simple, why can't you understand the icosahedron?
18:30:17 <Frederick> rofl
18:30:20 <Cale> Yeah, they have been less digested from a programming applicability standpoint.
18:30:35 <Cale> SamB: hehe
18:30:45 <Cale> Yeah, exactly.
18:30:50 <Cale> Why can't you? :)
18:31:32 <eivuokko> What's a good way to learn category theory?  Seems I should learn it
18:31:53 <Frederick> eivuokko, avoiding the teacher from my university is a good neginning
18:31:57 <Cale> Actually, one neat difference between them is that the Dodecahedron is not a Cayley graph.
18:32:25 <Frederick> Cale, are you graduated(ing) in math?
18:32:39 <Cale> graduated from an undergrad program in pure math
18:32:41 <Frederick> I wonder where do you learn such things
18:32:53 <Cale> The icosahedron is the Cayley graph of A_4 with generators (1,2,3), (2,3,4), and (1,3)(2,4)
18:33:16 <Cale> A course in algebraic graph theory or possibly group theory.
18:33:18 * Frederick takes note to get points with girls
18:34:21 <Frederick> if I say to a girl that "the icosaedron is the Cayley graph of A_4 with...." 1) she hits me and leave, 2) she says oki shut up and kiss me
18:34:26 <Frederick> so it is worth trying
18:35:03 <Cale> Curiously, I was studying with my girlfriend when I learned that
18:35:09 <Frederick> See
18:35:31 <Cale> (she was studying G-symmetric imprimitive graphs)
18:35:35 <Frederick> I study ot alone or on irc
18:36:19 <Frederick> my father came to my room while you were helping me and he said something like theses guys ned get a life, you need get a life, and gave me 5 bucks so I could hang around and buy some cookies
18:36:55 <thou> lol
18:37:14 <thou> Frederick: cookies /= life
18:37:45 <Frederick> thou, dunnu a suny day here 30 celcius outside
18:39:56 <Frederick> OMFG
18:40:14 <Frederick> I got a book that shows all the proofs suggested as exercise from my teachers book
18:45:17 <Frederick> bah I give up for today
18:48:54 <fworp> lol, cookies, yes, stop doing your homework and go eat cookies
18:50:31 <Frederick> fworp, 1 am here tommorow I read about the function I need and come back with all my power to bug you all :p
18:51:46 <Frederick> what is everybody listening?
18:52:18 <SamB> Frederick: girl could also c) say "uh huh" and nod boredly...
18:52:46 <Frederick> SamB, I doubt so
18:53:02 <SamB> you deny that girls have options between slapping and kissing?
18:53:19 <Frederick> SamB, the whole world is a binary machine :p
18:53:35 <SamB> Frederick: even binary machines can do three-way branches
18:54:21 <Frederick> you are the master I wont challenged the master :p
18:54:38 <SamB> ugh. don't be like that!
18:54:41 <SamB> argue sometimes!
18:55:03 <Frederick> SamB, oki so I disagree with you
18:55:07 <SamB> but use more interesting arguments ;-)
18:55:24 <thou> Frederick: you should say, "No, i don't want to argue"
18:55:30 <thou> and then argue about that
18:55:32 <Frederick> SamB, in fact in real life I use to argue a lot
18:55:35 * SamB goes up to rest and watch anime and maybe even read
18:55:47 * SamB loves arguing
18:56:04 <Frederick> but the point is that arguing against you seems harder than argueing against the ppl I know irl
18:56:05 <thou> hard to argue when you're eating cookies, though :-D
19:01:51 <stefanw> dons, I think I tracked the problem down. The editor seems to mess up the terminal: after the editor has been invoked, getch returns immediately (with -1 if no input is available), even if I set nodealy explicitly to false
19:02:44 <stefanw> the result is that riot calls getch again and again until it returns a value different from -1
19:29:20 <dons> stefanw, ah! maybe it should use one of the blocking getch
19:29:39 <dons> getCh = do
19:29:39 <dons>     threadWaitRead 0
19:29:39 <dons>     v <- getch 
19:29:39 <dons>     case v of
19:29:39 <dons>         (#const ERR) -> yield >> getCh
19:29:50 <dons> and you can set getch to block
19:29:57 <dons> I had this problem in yi once too.
19:30:33 <dons> nodelay False turns on blocking, iirc
19:32:02 <stefanw> the strange thing is: getch behaves blocking *before* the editor has been started
19:32:24 <dons> so when curses is inited?
19:32:43 <stefanw> but your point is good: riot uses the "raw" getch of ncurses directly, and not the getCh provided by hscurses
19:36:34 <stefanw> very good, it works. Thanks dons
19:37:10 <dons> ah, good :)
19:37:24 <dons> ncurses is evil
19:47:20 <thou> has anyone got HSQL to build with a current Cabal (1.1.4)?
19:48:55 <thou> i can build & install the hsql package, but trying the MySQL or Postgres gives me an error about postConf types not matching
19:49:24 <thou> maybe an easy fix, i don't know
19:49:51 <araujo> Hola Nomius !
19:50:05 * araujo mira a tizoc 
19:50:22 * tizoc mira a araujo, pero de reojo :P
19:50:46 <araujo> tizoc, ya tenemos #haskell.es !!!
19:50:48 <araujo> :-)
19:50:53 <tizoc> jeje
19:58:18 <thou> ok, the ODBC connector builds with a little bit of hacking
19:58:24 <thou> and i can use that for now :)
20:05:06 <eivuokko> Why can't guards be used in case, or in general anywhere?
20:09:00 <dons> > case 27 of { x | x < 0 = False ; | x > 0 = True }
20:09:00 <lambdabot>  parse error on input `='
20:09:34 <dons> well, you get the idea. you can use them in case. anywhere you bind a var
20:10:23 <araujo>  > case 27 of { a | a < 0 = False ; b | b > 0 = True }
20:10:41 <araujo> > case 27 of { a | a < 0 = False ; b | b > 0 = True }
20:10:42 <lambdabot>  parse error on input `='
20:10:51 * araujo slaps lambdabot 
20:11:01 <dons> ->
20:11:01 <fworp> == maybe?
20:11:05 <dons> I always forget that.
20:11:09 <fworp> oh
20:11:13 <dons> > case 27 of { a | a < 0 -> False }
20:11:13 <lambdabot>  Non-exhaustive patterns in case
20:11:18 <eivuokko> Uhm.
20:11:22 <dons> > case 27 of { a | a < 0 -> False; | otherwise -> True }
20:11:22 <lambdabot>  parse error on input `|'
20:11:35 <eivuokko> Yeah, now I see.  It doesn't use |, but ->, silly me.
20:11:38 <eivuokko> Thanks :)
20:11:41 <dons> > case 27 of { a | a < 0 -> False; | otherwise -> True; }
20:11:42 <lambdabot>  parse error on input `|'
20:12:10 <araujo> > case 27 of { a | a < 0 -> False ; b | b > 0 -> True }
20:12:11 <lambdabot> True
20:13:07 <dons> oh, we don't have layout
20:13:14 <araujo> yeah
20:13:58 <Cale> > case 27 of { a | a < 0 -> False | a > 0 -> True }
20:13:59 <lambdabot> True
20:14:18 <dons> ah!
20:14:30 <araujo> Interesting.
20:15:40 * Korollary_ gives #haskell the coveted ass-backwardness award 
20:16:15 <Cale> hm?
20:16:29 <Cale> > case 27 of a | a < 0 -> False | a > 0 -> True
20:16:30 <lambdabot> True
20:17:50 <Korollary_> this should fail
20:17:54 <Korollary_> > case 0 of a | a < 0 -> False | a > 0 -> True
20:17:55 <lambdabot>  Non-exhaustive patterns in case
20:19:04 <Cale> yeah
20:20:01 <araujo> I am looking for a good Category Theory book , recommendations?
20:22:03 <Korollary_> araujo: I've not read this, but it's in my wish list: http://www.amazon.com/exec/obidos/tg/detail/-/0262660717/ref=wl_it_dp/104-6087657-6931151?%5Fencoding=UTF8&coliid=ITLY2XI0CO1T5&v=glance&colid=1WW1C3M6AL0ZU
20:27:42 <dons> mmm. this looks proimsing. still on 0.00% cpu after 7mins.
20:28:17 <dons> death to lazy, boxed io ;)
20:28:27 <Korollary_> ?
20:30:32 <dons> I'm doing my own packed string getline, and it seems to have killed off the cpu issue I was having with slowly creeping GC
20:31:31 <Korollary_> how does the slowly creeping GC actually happen normally ?
20:32:10 <dons> seems something wasn't being collected. I was perhaps hanging on to some Strings somehow
20:32:28 <dons> so I was doing maybe 100 hGetLines/second.
20:32:43 <Korollary_> so no leak, just slow ?
20:32:49 <dons> a slow leak, I think.
20:32:56 <dons> it would take 1 or 2 hourse
20:33:12 <eivuokko> Could it hang to empty string because of some concat or something?
20:33:33 <dons> possibly, yes. or to other intermediates. 
20:34:06 <araujo> Korollary_, Oh, that looks nice
20:34:13 <araujo> Something like that is what i am looking for
20:34:25 <dons> SamB: I think the cpu issue is fixed. Can you try otu the code?
20:34:26 <araujo> Korollary_, i was looking at this http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
20:34:57 <Korollary_> araujo: That's a popular choice as well.
20:35:07 <araujo> really?
20:35:11 <Korollary_> yeah
20:35:17 <dons> stefanw, almost time for a beer, eh? :D
20:37:53 <fworp> Strings seem to be the bane of space efficiency in haskell
20:38:22 <dons> if you're doing a lot of IO, yes.
20:38:30 <dons> lambdabot gets by fine using normal Strings though.
20:38:33 <dons> not much IO
20:38:49 <Korollary_> lambdabot is not meant to be particularly efficient, tho
20:39:03 <dons> heh? yes it is
20:39:06 <dons> well, I trye.
20:39:18 <dons> not *really* efficient.
20:39:23 <dons> somewhat efficient.
20:39:24 <Korollary_> right
20:39:35 <dons> :)
20:40:00 <dons> it has to be efficient enough to run for weeks at a time on seafood's machine without causing anyone trouble.
20:40:19 <Korollary_> well, the overhead of a linked list for a tiny piece of data such as one character could be considered inefficient in general.
20:43:40 <stefanw> dons: there is some vodka in our room ;-)
20:44:09 * araujo saluda a Nomius_ 
20:44:14 <dons> hehe
20:44:32 <dons> stefanw, so riot is fixed now?
20:45:01 <stefanw> yes
20:45:13 <dons> ah good :) and so is hmp3. bugs be gone!
20:45:47 <stefanw> what was the problem?
20:46:12 <stefanw> (ah, the string issue you described above, I guess)
20:46:19 <fworp> how would concat'ing keep empty strings from getting collected?
20:47:46 <dons> mpg321 spits out around 100 frame messages a second. profiling showed that the frame parser was doominating allocs over time. so I rewrote the hGetLine code to use hGetPackedLine and to also discard 24/25 frames. now the space usage is constant it seems.
20:47:52 <dons> and no cpu creeping.
20:49:00 <dons> it now uses fgets into a packed string :)
20:49:14 <dons> after dropping any unnecessary frame packets
20:49:18 <Korollary> dons: the space usage should have been constant without packedlines as well, yes ?
20:49:42 <dons> it should have, if everything was being released properly. 
20:49:49 <dons> however it seemed to creep by around 4k / s
20:50:03 <dons> the main problem was that after an hour or two GC would dominate everything
20:50:04 <Korollary> library bug ?
20:50:24 <dons> probably my code was too lazy somewhere
20:50:30 <dons> and I was hanging on to unevaluated Strings
20:51:24 <Total_Blackout> will Parser take all strings with or without the variable?
20:54:45 <Cale> Total_Blackout: hm?
20:55:26 <Total_Blackout> im playing a game that uses haskell
20:55:40 <Total_Blackout> i bet tons of people come in here looking for help
20:55:49 <eivuokko> o.O
20:56:02 <Korollary> wow
20:56:03 * fworp wants to play a game that uses haskell
20:56:04 <eivuokko> Which game is that?
20:56:13 <Total_Blackout> its called mod-x
20:56:19 <Total_Blackout> have you guys hurd of it
20:56:53 <Total_Blackout> i have a borken script and i need to fix it becouse the code is written bad
20:57:28 <Total_Blackout> the game is it fix the code and pass it thew a file with over 3000 lives of junk and the haskell code will nerrow it down to one line
20:57:37 <Total_Blackout> and that line is the key for the next level
20:57:45 <Total_Blackout> lines*
20:58:57 <fworp> yeah, thats one of those challenge sites right? does the challenge have anything to do with a skyline?
20:59:21 <Total_Blackout> skyline???
20:59:24 <Total_Blackout> i dont think so
20:59:29 <fworp> guess not
20:59:42 <Total_Blackout> but yes its a challenge site
21:00:15 <Total_Blackout> and i just looking for some good direction for help i dont wanna cheet and have you guys do it for me
21:01:15 <fworp> Total_Blackout: well paste the code somewhere and describe the challenge, like here http://paste.lisp.org/
21:02:26 <Total_Blackout> http://paste.lisp.org/display/13646
21:06:49 <fworp> http://www.ninebynine.org/Software/HaskellUtils/cpphs/ParseLib.hs well that looks like the library it imports
21:09:29 <Total_Blackout> o yeah?
21:11:54 <Cale> Total_Blackout: yeah, there were a bunch of people a while back
21:13:17 <Total_Blackout> do you have any advice?
21:13:26 <Cale> If you want to do it right, you should actually learn Haskell, which should only take perhaps a couple of months to get you to the point where that all makes sense.
21:13:48 <fworp> hehe
21:13:57 <Cale> It's actually a trivial problem once you understand what's going on :)
21:14:39 <Cale> In fact, it's easy enough to construct a valid code without actually getting the program to run, if you understand the intent behind the Haskell code there.
21:14:51 <Total_Blackout> what would be a good tut?
21:15:10 <Cale> Yet Another Haskell Tutorial is a good place to start, let me get a link...
21:15:18 <Total_Blackout> thanks
21:15:27 <Cale> http://www.isi.edu/~hdaume/htut/tutorial.pdf
21:15:37 <Cale> grab ghc/ghci
21:15:42 <Cale> what OS are you running?
21:15:51 <Total_Blackout> linux and winxp
21:15:58 <Cale> which linux?
21:16:03 <Total_Blackout> fedora
21:16:35 <Cale> ah, there ought to be a ghc-6.4.1 package for fedora
21:16:41 <Cale> http://haskell.org/fedora/
21:16:42 <Total_Blackout> also is there a way to remove that paste?
21:16:46 <Total_Blackout> thanks so much
21:17:09 <fworp> Total_Blackout: probably not
21:17:23 <Cale> I don't think so, though I wouldn't think they keep them too long either
21:17:36 <Cale> doesn't matter, as that code is all over the place
21:17:49 <Total_Blackout> if i get banned im gunna cry
21:17:50 * tmoertel thinks that ghc-6.4.1 is in Fedora Extras now
21:18:45 <Total_Blackout> but anyways thanks a tun guys
21:18:48 <Total_Blackout> or gals
21:18:56 <Cale> Haskell is way more fun than Mod-X anyway
21:18:59 <Cale> heh
21:20:27 <fworp> doh, i wanted the input :(
21:23:48 <Cale> hm?
21:24:12 <fworp> the 3000 line file its supposed to parse
21:25:56 <Cale> oh
21:26:45 <Cale> I think his interpretation of what the Haskell code was supposed to do was flawed
21:27:40 <Cale> The Haskell program validates codes to go to the next level. I believe all you have to do is generate a string which the program accepts, which is easy to do by following the parser along.
21:28:16 <fworp> ah
21:28:44 <fworp> yeah, cause from the looks of it, the result of parsing successfully, is the string "Success"
21:28:53 <Cale> yeah
21:32:54 * araujo is in love with quickSort written in Haskell
21:33:26 <araujo> I could get a kindergarden child to understand this.
21:35:51 <araujo> I am surprised about the line between programming languages and algorithms design/implementation.
21:36:00 <ibid> dcoutts: ping?
21:36:27 <Korollary> araujo: Have you read Structure and Interpretation of Computer Programs ?
21:36:41 <araujo> Korollary, Only watched the videos
21:36:54 <araujo> I only read the first chapters....
21:37:02 <Korollary> araujo: In the videos, they don't go into the philosophy of it much.
21:37:06 <Korollary> ah ok
21:37:08 <araujo> yeah
21:37:24 <araujo> They take a more pragmatic approach
21:38:36 <araujo> Korollary, Many people (including professors here) believe than the programming language got nothing to do with the design of algorithms
21:39:16 <araujo> Most of the so called software engineering teach that.
21:39:26 <araujo> Which (IMHO) is evidently wrong.
21:39:43 <araujo> That's probably a reason i hate so much most of the SE stuff.
21:40:17 <Cale> In some sense, they're right, and in some sense you're right too :)
21:40:19 <Korollary> well, you can explain quicksort using no actual computer language.
21:40:42 <araujo> Right. I agree.
21:40:45 <Cale> There is a way in which the Haskell and C versions of quicksort are the same.
21:40:57 <araujo> Though i still wonder why they keep teaching it using C :-)
21:41:14 <Korollary> industry pressure
21:41:20 <Cale> yeah, certainly, we should be using languages which are closer to the specification of the program
21:41:36 <Cale> industry schmindustry :)
21:42:23 <Cale> CS should be part of the Mathematics faculty :)
21:42:27 <Korollary> what a more powerful language does is enabling abstractions that encapsulate algorithms
21:42:43 <Korollary> Cale: It is in some schools here
21:43:12 <Cale> It is at the university at which I did my undergrad
21:43:24 <Korollary> Cale: you can get a BA in CS from the maths dept at Berkeley, or you can get a BS in CS from the engineering dept.
21:43:42 <araujo> Cale, Yeah, i agree with you.
21:43:45 <Cale> At Waterloo, you get a BMath in CS
21:44:08 <Cale> or they have this BCS degree which is more for joint majors
21:44:28 <Cale> BCS + Biology, BCS + Physics, that sort of thing.
21:44:48 <araujo> Saddly it doesn't happen the same here.
21:45:21 <araujo> The closer you have for CS is software engineering (excluding Math)
21:45:32 <Korollary> SE is fluff.
21:45:55 <Cale> I wish SE was actually an engineering degree.
21:46:02 <araujo> I don't know.. i just feel sometimes they care more about the 'protocol' than the researching
21:46:35 <araujo> Cale, It is, sort of here
21:47:01 <Korollary> Cale: It is not up to it like the other engineering disciplines.
21:49:08 <Cale> Korollary: yeah
22:19:41 * xinming is really distracted by the channel log still not ready for 15th. Nov.
23:49:29 <mcnster> hello
23:50:25 <Korollary> wow
23:50:51 <Korollary> there are people who think an OS written in lisp would be *maybe* slow...
23:51:51 <mcnster> can someone help me understand which method gets invoked when i make "... deriving Show"?
23:52:20 <vegai_> Korollary: hmm?
23:52:39 <vegai> Just slow or Nothing? :P
23:53:36 <Korollary> vegai:  He was convinced that it would work well, but not certainly slower.
23:53:49 <Korollary> mcnster: invoked ?
23:54:29 <mcnster> korollary:  whups, my Smalltalk is showing :-).  
23:55:26 <mcnster> i've looked through GHC/Show.lhs and can't seem to find a method that would be appropriate in a default case is what i mean
23:56:14 <Korollary> mcnster: Well, I haven't seen Show.lhs, but why would you look there anyways ?
23:56:22 <Lemmih> Deriving is done by compiler magic, afaik.
23:57:11 <mcnster> korollary:  well, hmm.  I thought that "deriving Foo" was to say "instance Foo ... where ..." using the default method of class Foo.  am i wrong?
23:58:04 <mcnster> wouldn't be the first time...
23:58:30 <Korollary> mcnster: It is, sorta. However, the compiler generates the method implementations for you. I don't think there's a 'default' that's good for everything.
23:58:54 <mcnster> whoa
23:59:12 <mcnster> i had no idea "deriving" was so magical
23:59:41 <Korollary> mcnster: my impression is that it depends on the parsetree. Maybe like the quotation operator in scheme.
