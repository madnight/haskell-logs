00:00:15 <dons> it's just the editor doing markup on special identifiers
00:00:31 <tuomov> you could add definitions for unicode operators (but not lambda) if the compiler supported utf-8 input at all..
00:00:38 <dons> yeah.
00:00:51 <tuomov> and really, it would be cool to have other kinds of operator symbols as well
00:02:33 <tuomov> ⊕ ⊗ would be useful for special addition and multiplication type operations
00:02:39 <tuomov> and so on
00:02:57 <dhpeterson> tuomov: beware of adding extra operators --> syntactic sugar == syntactic overload
00:03:05 <dhpeterson> i'm a perl programmer, i'd know ;)
00:03:23 <dhpeterson> $_ $| $1 $= etc
00:03:39 <xinming> ASCII is evil... :-P
00:03:43 <tuomov> ehh.. now the haskell way is to define e.g. <*> or <+>, which becomes slightly less readable
00:04:01 <tuomov> you _can_ define almost arbitrary new operators in haskell already
00:04:26 <luqui> dhpeterson, you're a perl programmer?
00:04:34 <tuomov> any function that uses certain symbols acts as in infix operator
00:04:36 <luqui> have you seen pugs?
00:04:47 <dhpeterson> luqui: yes
00:04:51 <tuomov> and the standard does specify the use of unicode operator symbols already, the compilers just don't support them
00:04:55 <dhpeterson> pugs was what brought me to haskell in the first place :)
00:05:01 <luqui> like many of us :-)
00:05:08 <dhpeterson> heyh
00:05:13 <dhpeterson> sorry bud but i've gtg
00:05:24 <dhpeterson> can't keep the missus waiting ;)
00:06:14 <luqui> adios
00:33:59 <joelk> anyone know how far gtk2hs is to a release including opengl?
00:39:22 <dons> we already have hopengl, I guess you knew that?
00:39:32 <joelk> hmm... and it's not cabalized...
00:39:46 <dons> gtk2hs?
00:39:56 <joelk> i meant when will gtkglext be in the release (I just pulled darcs)
00:40:06 <dons> ah, right.
00:40:10 <dons> yeah, that'd be cool
00:40:29 <dons> just ask dcoutts!
00:40:44 <dons> that'll get it on the todo list ;0
00:40:44 <dons> )
00:40:48 <dons> ;)
00:41:29 <dons> mmm. using -ddump-minimal-exports knocked 50k off my heap. fun :)
00:41:38 <dons> a whole 50k!!
00:42:43 <joelk> Well, I'll try to compile the darcs pull later. I want to convert my HSDLgears to HGtkGlgears.
01:05:30 <luqui> I have an RWS computation; how do I tell it what to do when a pattern bind fails?
01:06:20 <dons> hmm. how are you doing the pattern matching?
01:06:52 <dons> maybe you should be using `case'
01:07:05 <luqui> yeah, probably
01:07:19 <luqui> I'm just saying, like (foo, bar) <- something
01:07:27 <luqui> but I want to give a custom error message if it fails
01:07:39 <dons> that can't fail, can it? tuples are checked statically
01:07:40 <luqui> and I thought putting that logic elsewhere would be more readable than case
01:07:46 <dons> or are you matching something else, like a list?
01:08:12 <luqui> okay, it's actually this:  (SynT (TFunc vars dom rng)) <- something
01:08:27 <ibid> i sometimes do this:
01:08:28 <dons> ah, so use `case' ;)
01:08:45 <luqui> alright, fine.
01:08:53 <ibid> foo@(~(Just x)) <- something
01:08:55 <dons> v <- do x <- something ; case x of Good _ -> return x ; Bad -> fail
01:08:58 <ibid> ... isJust foo ...
01:09:10 <dons> yeah, or maybe-ify it
01:09:11 <ibid> ... isJust foo ... x ...
01:09:25 <luqui> what's that ~?
01:09:26 <ibid> i mean, this works for other types too than Maybe
01:09:47 <ibid> but the case is usually simpler
01:10:02 <luqui> what does ~(Just x) mean?
01:10:03 <ibid> i think i developed this habit before i grokked case :)
01:10:34 <ibid> luqui: pretend that it's a Just even if it is Nothing; only complain if i try to use x and it was Nothing
01:10:45 <dons> bad habit ;)
01:10:45 <luqui> ahh, a lazy pattern bind
01:10:52 <ibid> y
01:15:40 <reddi> can i somehow debug haskell to show which parameters where passed in an iteration?
01:16:09 <dons> you could use Debug.Trace.trace
01:16:18 <reddi> how does that work?
01:16:36 <dons> i.e. f x = trace (show x) $ ... body of f ...
01:16:53 <Lokadin> :|
01:16:59 <reddi> i see, so there is no direct mode on command line
01:17:01 <Lokadin> i took a 20 minute nap at like 9
01:17:06 <reddi> to go line by line throw the code
01:17:09 <Lokadin> and woke up 5 minutes ago
01:17:12 <Lokadin> it's now 4:16
01:17:27 <Lokadin> oioioi
01:18:13 <ibid> reddi: if there was, you'd probably be very confused
01:18:40 <ibid> reddi: the evaluation order is not as obvious as with a strict language
01:19:16 <dons> there are a few haskell debuggers around, that let you go forwards and backwards through the reduction, but they're rarely rarely needed. ghci + trace is usually enough (always enough?)
01:19:32 <dons> maybe QuickCheck too
01:19:52 <Lokadin> how do you use trace?
01:20:01 <dons> see above
01:20:08 <dons> @type trace
01:20:09 <lambdabot> Not in scope: `trace'
01:20:19 <dons> @type Debug.Trace.trace
01:20:20 <lambdabot> forall a. String -> a -> a
01:20:41 <Lokadin> kk i'll take a look
01:20:47 <reddi> ok, then i will change my functions a bit and see which parameter was passed
01:20:57 <yozora> > Debug.Trace.trace "hello" 1
01:20:57 <lambdabot>  Not in scope: `Debug.Trace.trace'
01:21:13 <dons> :m + Debug.Trace  ;)
01:21:28 <dons> ah, sorry. no . lambdaobt doesn't have trace in scope.
01:22:23 <yozora> yeah it makes sense
01:22:37 <yozora> no unsafePerformIO, so no trace
01:22:45 <dons> well, trace isn't so bad.
01:22:59 <dons> it's hard to imagine how it could break anything.
01:23:32 <yozora> it's impure! :)
01:24:26 <yozora> @vixen are you pure?
01:24:27 <lambdabot> yes, i am
01:24:47 <dons> how nice  :)
01:25:06 <yozora> i guess that's the reason
01:25:14 <Lokadin> bah i'm going back to bed
01:25:26 <Lokadin> way too tired
01:42:33 <kzm> besides IO isn't allowed? (re trace and \bot)
01:46:21 <kzm> Quick import question?  
01:46:33 <kzm> I want to demo some simple parsec usage today.
01:46:59 <kzm> Now, I don't want to clutter everythnig with "Text.ParserCombinators.Parsec" but have everything in local scope.
01:47:23 <kzm> (in ghci that is - so that :t parse will not qualify the result, etc)
01:47:34 <kzm> Trying to use a dummy module, but struggling with the syntax.  how?
01:47:38 <luqui> :module Text.ParserCombinators.Parsec
01:47:53 <luqui> that will put ghci in the context of that module
01:48:24 <luqui> if you're doing it in a module, you just, er, import it (not qualified)
01:48:51 <kzm> Ah, sorry, it doesn't qualify.  My bad.
01:49:07 <kzm> It does make a big prompt, though.  
01:49:59 <kzm> Any way to not print the fully qualified module name in the prompt?
01:51:27 <kzm> Hmm..perhaps I have the module sources here, then I could just :l it (as Parsec).  It is part of text-1.0 which is hidden, so I'm not allowed to just :m Parsec, unfortunately.
01:52:32 <kzm> No way?
01:54:51 <kzm> Isn't it possible to import a module and re-export it (i.e. its definitions)?
01:55:08 <ProfTeggy> Moin
01:59:48 <kzm> Found it: module Parsec (module P) where \n import Text.ParserCombinators.Parsec as P
02:06:46 <kowey> shapr: thanks! :-) hope i didn't make too conceptual errors or take too many shortcuts
02:38:00 <sieni> http://bash.org/?582005
02:43:32 <tuomov> But the Stetson-Harrison method is obviously best for really hard problems :)
02:44:06 <jlouis> When you are writing a ph.d, you have an ``advisor'' (older researcher). What is the real name for it?
02:45:40 <fanopnaic> jlouis: http://tinyurl.com/d4884
02:46:21 <ProfTeggy> jlouis, that's a perfectly good name
02:46:50 <ProfTeggy> In Germany, it's called "Doktorvater" (but this does not translate well)
02:47:08 <ProfTeggy> "PhD Advisor" is understood virtually anywhere
02:48:09 <ProfTeggy> Some say "mentor", but that's not as widely used
02:50:18 <pejo> ProfT, vater = father? 
02:50:32 * ProfTeggy nods
02:52:36 <Heffalump> "supervisor" is the word used in the UK
02:52:36 <dons> supervisor?
02:52:40 <dons> and in .au
02:52:42 <Heffalump> "advisor" seems to be standard in the US
02:53:19 <musasabi> I finally found out how to get wxhaskell on Debian - one needs to compile wx-windows with --disable-unicode and then link against that.
02:53:31 <pejo> Don't you have a supervisor if you end up in jail as well? 
02:53:36 <kzm> The Norwegian equivalent literally means "guide" :-)
02:53:54 <kzm> (or perhaps "pathfinder"?)
02:54:01 <ProfTeggy> pejo, what's the difference between doing a PhD and jail? 
02:54:01 <kowey> musasabi: there is also the unicode patch for wxhaskell
02:54:51 <dons> pejo? ah, counselor? like a lawyer?
02:54:56 <kzm> I'll demo Parsec to my functionally challenged colleagues in 20 minutes.  If Daan is listening, I just want to apologize in advance :-)
02:55:18 <dons> hehe
02:55:51 <kzm> why is it called "solicitor"?  And what is the implied meaning (presumably unrelated) of:
02:56:05 <gus> Lemmih: Is there any chance of getting HASP to work in ghc 6.4.1 ?
02:56:09 <kzm> "don't solicit for your sister, that's not nice// unless you get a good percentage of her prize (price?)
02:56:37 <kzm> (as sung by Tom Lehrer)
02:56:42 <dons> oh, the implication is that you're are pimping your sister as a prostitute
02:56:51 <dons> which is the crime of soliciting in the US, I think
02:57:03 <kzm> Thus the reason lawyers are called solicitors? :-)
02:57:23 <wilx> Hehe.
02:57:30 <kzm> price, then.
02:57:31 <jlouis> Thanks all
02:58:11 <kzm> Sure, don't mention it.
03:00:43 <Lokadin> is  haskell threat optimized?
03:01:03 <Lokadin> thread*
03:01:04 <jlouis> threat optimized?
03:01:06 <jlouis> hehe
03:01:09 <Lokadin> lol sorry :$
03:01:14 <jlouis> what do you mean by thread optimized
03:01:18 <ProfTeggy> Lokadin, it seems to be, esp. to newbies ;-)
03:01:35 <Lokadin> :P lol, no well i mean could it take advantage of multiple processors?
03:01:38 <jlouis> Lokadin: nevermind, typos. I suck at it (mainly because my mind works faster than i write)
03:02:00 <dcoutts> Lokadin, ghc 6.6 will have smp support
03:02:02 <Lokadin> happens all the time
03:02:04 <jlouis> Lokadin: Some compilers will have support for it, yes
03:02:13 <dcoutts> Lokadin, it's still in development at the moment
03:02:17 <Lokadin> oh okay
03:02:19 <Lokadin> just wondering
03:02:21 <Lokadin> :) thanks
03:02:44 <dcoutts> you can use multiple threads at the moment however
03:02:59 <Lokadin> cool, well i'll look into that
03:03:01 <dcoutts> but they will run on one CPU
03:03:07 <Lokadin> right now i'm still struggeling with understanding types :|
03:03:46 <dons> in fact, threads are particularly easy in haskell: forkIO mythread :)
03:04:02 <dons> @type Control.Concurrent.forkIO
03:04:03 <lambdabot> IO () -> IO GHC.Conc.ThreadId
03:04:32 <Lokadin> oo
03:04:56 <araujo> @karma+ dons 
03:04:56 <lambdabot> dons's karma raised to 18.
03:05:06 <gus> Somebody knows how to get ghc 6.5 (or more) with darcs?
03:05:18 <musasabi> kowey: mmh, didn't find that before.
03:05:22 <dons> ghc is not in darcs yet, gus.
03:05:28 <gus> ok.
03:05:35 <dons> it's on the todo list. you can get it with cvs though
03:05:38 <pejo> ProfT, pay is better in jail.
03:05:53 <ProfTeggy> pejo :-)
03:06:01 <gus> is there a version of ghc 6.5 that is "more stable" than the others?
03:06:11 <pejo> dons, I meant when you're on probation, I guess. :-)
03:06:18 <Lokadin> hey say what is darcs? is it significantly better/easier then cvs?
03:06:27 <dons> gus, the snapshot that lambdaot is using seems quite stable:
03:06:28 <kowey> musasabi: it's not the slightest bit official
03:06:29 <dons> @version
03:06:29 <lambdabot> lambdabot 3p196, GHC 6.5.20050806 (Linux i686)
03:06:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
03:06:43 <dons> Lokadin, exponentially better than cvs
03:06:43 <kowey> musasabi: i'm still waiting for someone to approve, reject, or modify it
03:06:55 <kowey> http://www.loria.fr/~kow/download/patch-wxhaskell-unicode-05
03:06:57 <dons> the patch is a first class value in darcs, as it is when we hack
03:07:12 <dons> cvs has no notion of a patch
03:07:23 <Lokadin> o
03:07:37 <dons> s/when we hack/ the way humans think about changes to code/
03:07:38 <musasabi> darcs makes it trivial to work on local branches
03:07:55 <dons> and to publish code as well
03:08:02 <dons> and to send patch, oh my it's just so good
03:08:09 <Lokadin> wow cool
03:08:19 <Lokadin> say could you point me to a tutorial?
03:08:54 <dons> well the website for darcs has a wiki, with tuts I think: darcs.net
03:09:32 <Lokadin> cool
03:09:37 <dons> it's really easy, hardly needs a tut
03:09:52 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot ; haack ; darcs changes ; darcs record ; darcs send 
03:10:09 <dons> darcs whatsnew is helpful
03:10:57 <Lokadin> kk
03:14:00 <Lokadin> bah i feel like i'm living in a backwards era of technology
03:14:43 <Lokadin> btw what does the topic mean? ["Haskell is still the language of choice for discriminating hackers"
03:15:01 <jlouis> Lokadin: it is a reference to the ICFP Contest
03:15:20 <jlouis> The winner gets to call <language> is still the language. ...
03:15:26 <jlouis> for a year, that is
03:15:44 <jlouis> the still is an addition I think, because haskell won the contest 2 years in row
03:16:32 <Lokadin> o
03:16:52 <Lokadin> you figure it's gonna win next year as well?
03:17:15 <Lokadin> seems like a strange thing to say no? 
03:17:52 <Heffalump> well, we hope it'll win :-)
03:18:42 <Lokadin> i mean i haven't herd of any other languages popping up with cool new ideas and innovations to render haskell archaic
03:19:52 <pejo> Lok, maybe there aren't that many ideas that would make current "state of the art" archaic? 
03:22:47 <Lokadin> that's what i'm saying
03:22:51 <benny> languages pop up all the time with cool new ideas and innovations to potentially render haskell archaic
03:22:58 <benny> like epigram
03:23:18 <Lokadin> whats that?
03:23:23 <dcoutts> epigram makes my head hurt
03:23:28 <dcoutts> but it is very cool
03:23:56 <Lokadin> An epigram is a short poem with a clever twist at the end or a concise and witty statement. They are among the best examples of the power of poetry to compress insight and wit.
03:23:59 <Lokadin> from wikipedia
03:24:17 <dcoutts> Lokadin, it's also a programming language
03:24:21 <dcoutts> @where epigram
03:24:21 <lambdabot> http://sneezy.cs.nott.ac.uk/epigram/
03:24:27 <benny> but i think that haskell could even learn a bit from the "mainstream" languages like python and c#
03:24:40 <Lokadin> such as?
03:25:07 <Heffalump> wi benny 
03:25:12 <dcoutts> having a plethora of libs as standard?
03:25:17 <Heffalump> oops :-)
03:25:49 <benny> small things like keyword arguments that improve the self-documentation of code
03:26:01 <Heffalump> haddock does that
03:26:11 <Lokadin> i was about to ask
03:27:08 <Lokadin> how do you check if a variable exists in haskell?
03:27:19 <pejo> Is the big thing with Epigram dependent types? And is the type checking terminating in that case?
03:29:42 <dcoutts> pejo, yes type checking is terminating because all the functions terminate
03:30:26 <Lokadin> i mean i can't get this excersize done in yet another haskell tutorial, cause i have no idea how to check if a variable exists
03:30:34 <dcoutts> pejo, there is no general recursion (at least in the pure part of eppigram)
03:30:51 <Lokadin> data Tuple a b c d = Tuple a b c d
03:30:59 <Lokadin> tuple1 (Tuple a b c d) = if a == null
03:31:14 <dcoutts> pejo, eppigram allows you to use general recusion as an unsafe extension. You then run the danger of type checking not terminating.
03:32:04 <Lokadin> any help?
03:32:07 <pejo> dcoutts, hm. So either there is (atleast) one class of programs which can't be written in Epigram or type checking is not decidable. 
03:32:33 <dcoutts> pejo, yep
03:33:33 <dcoutts> pejo, but you can often use tricks like adding a timer variable to a function which guarantees that the function terminates after a certain (but perhaps large) number of iterations.
03:34:04 <Lokadin> *pokes8
03:34:07 <pejo> Imho the safe part can't be called 'a general purpose programming language' in that case. But there are probably a lot of interesting problems that can be solved with it, I bet. 
03:34:22 <Lokadin> anyone?
03:34:35 <dcoutts> pejo, that's a contentious point. Talk to Connor. :-)
03:34:49 <Lokadin> pejo: :P i'm sure you know how to help me :P
03:35:27 <pejo> dcoutts, hence the "humble" in the beginning. :-)
03:35:38 <Lokadin> dcoutts: maybe you could?
03:36:05 <dcoutts> pejo, and the point of course is that those problems can be solved provably. The type system guarantees termination as well as allowing you to prove many other interesting properties of funtions you write.
03:36:17 <pejo> Loka, I don't even understand the question.
03:36:43 <Lokadin> pejo: oh well i'm supposed to return the a from Tuple a b c d if it exists
03:36:49 <Lokadin> if a exists
03:36:55 <Lokadin> but i have no idea how to check if a exists
03:37:05 <dcoutts> pejo, eg you can write a type for a 'sort' function that states that the result is a sorted list. Then the type checker ensures that your implementation satisfies that type.
03:37:10 <pejo> dcoutts, I'm not against dependent types in any way, but I do prefer to know that type checking is decidable. 
03:37:44 <dcoutts> pejo, well the argument goes that since we mostly write terminating functions then we're ok :-)
03:37:58 <aleator> Lokadin: How do you make value from Tuple a b c d, without it having an a?
03:38:03 <dcoutts> pejo, how often do you write non-terminating functions on purpose?
03:38:29 <tuomov> is there a useful decidable subset of dependent types?
03:38:46 <Lokadin> aleator: if say you declare Tuple without arguments
03:38:53 <dcoutts> tuomov, yes, for total functions.
03:39:19 <dcoutts> pejo, I'm not really asking, but that's how the argument goes.
03:39:54 <dcoutts> pejo, I highly reccomend Connor McBride's lectures if you ever get the chance :-)
03:39:55 <aleator> Lokadin: Show code. Declare as in "Data Tuple..." or as "x = Tupple"
03:40:08 <pejo> dcoutts, I understand the argument, I'm just not sure that I agree with it. I fully acknowledge that there are a lot of interesting computations that can be done with terminating functions though.
03:40:13 <Lokadin> data Tuple a b c d = Tuple a b c d
03:40:20 <Lokadin> tuple1 (Tuple a b c d) =
03:40:20 <Lokadin>    if a == null
03:40:20 <Lokadin>       then Nothing
03:40:20 <Lokadin>       else Just a
03:40:44 <dcoutts> pejo, to be honnest I don't think I could tollerate programming without general recursion either.
03:40:56 <aleator> Lokadin: With such definition a cannot not exist. (btw. use pastebin)
03:41:23 <Lokadin> whaat you mean?
03:41:40 <Lokadin> if i type Tuple 'a' then a exists
03:41:58 <dcoutts> pejo, I think the issue is less that there are functions you can't write but that they become harder to write because basically you have to supply a termination proof.
03:42:05 <Lokadin> like i can check if an array is empty by a = []
03:42:20 <Lokadin> a list*
03:43:08 <aleator> but: "tuple 5" is of type "a b c -> Tuple int a b c".  By saying "Data tuple a b c d = Tuple a b c d" defines that Tuple always has 4 params.
03:43:32 <aleator> please ignore missing capitalization :/
03:43:43 <Lokadin> well then how do i define it as having a possible 4 ?
03:44:03 <Lokadin> i mean it's an excersize from yet another haskell tutorial, to be honest i'm not sure i even understood the question
03:44:25 <aleator> How about "Data Tuple a b c d = OneTup a | TwoTup a b etc.." ?
03:45:08 <Lokadin> can you do that?
03:46:03 <aleator> Certainly. 
03:46:03 <Lokadin> excersize says: Write a datatype Tuple which can hold one, two, three or four elements,
03:46:07 <Lokadin> depending on the constructor (that is, there should be four constructors, one for each
03:46:10 <Lokadin> number of arguments). Also provide functions tuple1 through tuple4 which take a
03:46:12 <Lokadin> tuple and return Just the value in that position, or Nothing if the number is invalid
03:46:15 <Lokadin> (i.e., you ask for the tuple4 on a tuple holding only two elements).
03:46:21 <Lokadin> kk cool, i'll try it :D thanks
03:46:35 <aleator> But depending on excercise I cannot tell you if are supposed to do it excatly like this..
03:46:48 <Lokadin> well the excersize is right ther
03:46:58 <Lokadin> i mean i just pasted it here
03:48:41 <aleator> I think it is like that.
03:49:42 <Lokadin> kk
03:49:43 <Lokadin> :)
03:49:56 <Lokadin> so how would i make say the tuple1 function?
03:50:12 <aleator> Do you know pattern matching? 
03:50:35 <Lokadin> er i remmber them saying something about it
03:51:02 <Lokadin> nope
03:51:06 <Lokadin> it hasn't said anything about it
03:51:11 <aleator> case ?
03:51:14 <Lokadin> word pattern not found in tutorial
03:51:17 <Lokadin> case yea
03:51:49 <Lokadin> well not found in tutorial before the excersizes that i was doing
03:52:40 <aleator> Well. You know how to use that? "case m of {Just a = "Something"; Nothing = "Not a thing}" and so on?
03:53:37 <Lokadin> er
03:56:00 <Lokadin> so i would do case a of OneTup = a; TwoTup = a; ThreeTup =a ?
03:57:39 <aleator> Yes. Except it is ".. OneTup x = x."
03:57:59 <aleator> Erm.. Without the "."
03:58:09 <Lokadin> kk
03:58:17 <Lokadin> tahnks :)
03:59:28 <musasabi> Anyone having hacked Blobs here?
03:59:48 <Lokadin> blobs? lol
04:00:09 <pharm> blobs?
04:01:25 <Lokadin> aleator: so what would i have the original decleration tuple1 (Tuple a b c d) = case a of { OneTup a = a;)
04:03:06 <musasabi> The diagram editor in Haskell
04:03:18 <musasabi> http://www.cs.york.ac.uk/fp/darcs/Blobs/
04:04:27 <aleator> Lokadin: Don't forget the other cases. You can get the a from all of the tuples.
04:04:58 <aleator> You should also recheck the exercise about what you need to return.
04:04:58 <lisppaste2> Lokadin pasted "Tuple" at http://paste.lisp.org/display/13987
04:04:59 <kowey> musasbi: hey, that's pretty cool: could i use it to as a display engine for graphviz output?
04:05:20 <Lokadin> i dono, nothing i do seems to work
04:05:29 <aleator> Does that not work?
04:05:39 <Lokadin> nope
04:06:19 <Lokadin> okay nm
04:06:22 <Lokadin> it works now
04:06:35 <Lokadin> thanks  :)
04:06:48 <aleator> Btw. you need to return Just a, or Nothing.
04:06:55 <Lokadin> o
04:08:04 <Lokadin> and the datatype would be tuple1 :: Tuple a b c d -> Maybe a
04:08:06 <Lokadin> ?
04:08:28 <vincenz> musasabi: looks nice
04:09:15 <aleator> Lokadin: Yes. (Not datatype, type)
04:09:34 <Lokadin> o okay
04:10:58 <Lokadin> seems like a lot of code though :S
04:11:03 <Lokadin> i mean for something soo simple
04:13:28 <dcoutts> kowey, or for a simple solution, just output to a png or svg file and load that up: http://haskell.org/~duncan/gtk2hs/Constraints%20Viewer.png
04:13:45 <kowey> dcoutts: i'm already loading a png
04:13:49 <kowey> (in wxhaskell)
04:14:00 <dcoutts> right
04:14:03 <kowey> but it might be nice if the user could manipulate the graph by mouse
04:14:12 <dcoutts> yeah, that'd be cool
04:14:29 <kowey> hey, you do something very similar to me... i've got a debugger that looks like... uh
04:14:44 <dcoutts> I've been thinking of doing a cairo-based graph display thingie
04:14:53 <dcoutts> rather than loading a png
04:15:05 <kowey> http://wiki.loria.fr/wiki/Image:Geni_realisations.png
04:15:09 <aleator> dcoutts: Hey? Can gtk2hs render svg?
04:15:17 <dcoutts> aleator, yep
04:15:40 <dcoutts> kowey, looks cool
04:16:09 <aleator> @help karma
04:16:10 <lambdabot> return a person's karma value
04:16:45 <aleator> dcoutts: That is really nice. 
04:16:57 <dcoutts> aleator, its just: pixbuf <- pixbufNewFromFile "foo.svg"
04:17:11 <dcoutts> or pixbufNewFromFileWithScale / pixbufNewFromFileWithSize
04:17:55 <dcoutts> the main limitation is that you can't rescale after loading it up since it converts it to a bitmap
04:18:08 <dcoutts> it's mostly there for laoding svg icons etc
04:18:31 <aleator> Ok. Does it preserve alpha? 
04:18:38 <dcoutts> yes, I beleive so
04:18:44 <dcoutts> for the more advanced stuff you'd want to use a canvas
04:19:25 <dcoutts> or use librsvg directly
04:19:42 <aleator> Ok. Thanks.
04:26:19 <Wi_> @eval 2+3
04:26:20 <lambdabot> 5
04:27:12 <luqui> is there a quick way to say "export everything defined in this module"
04:27:49 <ProfTeggy> bbl
04:28:51 <dcoutts> luqui, yes just say: module Foo where
04:29:07 <dcoutts> rather than: module Foo (blah1, blah2) where
04:29:21 <kzm> didn't I just do that? :-)
04:29:54 <kzm> Oh, I see.  What I wanted was "module A (module B) where... import B"
04:30:19 <kzm> Of course, specifying exports is generally more sanitary.
04:31:58 <luqui> ah
04:32:04 <luqui> good :-)
04:37:33 <bourbaki> moin
04:38:34 <bourbaki> if you have a function that maps form A to B will it surfice to add the maybe not thingy to make give it a subobject classifier?
04:41:16 <luqui> "maybe not thingy"?   "subobject classifier"?
04:42:46 <bourbaki> well i want to construct a category for a specific kind of programs
04:42:53 <bourbaki> that is one category for every programm
04:42:58 <luqui> oh, you're speaking category theory?
04:43:08 * luqui runs away screaming
04:43:13 <bourbaki> and it would be cool if it was a topos thats why i want to show that there is a suboject classifier
04:43:18 <bourbaki> heh
05:12:06 <Cale> bourbaki: are you saying that the programs themselves are topoi?
05:14:06 <bourbaki> Cale: thats why i try to show
05:14:18 <bourbaki> they are at least cartesian closed categories
05:14:52 <bourbaki> im not sure what i have to show actually though i think that equilizers will be a problem
05:15:11 <bourbaki> though i am not sure if that is coupled or how to the suboject classfier
05:15:31 <bourbaki> which i think should be possible as long as you are able to classify the functions
05:18:04 <Cale> I'd be surprised if there was a nontrivial finite topos.
05:18:34 <Cale> Say, something with at least 2 distinct objects, but only finitely many.
05:18:38 <bourbaki> well i thought that the exponential objects could be partial applications of functions
05:19:05 <bourbaki> Cale: didnt i show you the graphs of my programs?
05:19:11 <Cale> yeah, you did
05:19:30 <Cale> Those didn't seem to be topoi to me
05:19:52 <bourbaki> well automatas are topi though imho
05:20:55 <Cale> Perhaps the category of all finite automata, or something like that, but individual ones, almost certainly not.
05:21:14 <Cale> (if you're thinking of the graphs of automata as categories)
05:21:19 <bourbaki> yes fsa
05:22:49 <bourbaki> well if all the arrows in my category have functions that are epi or mono functions then this should surfice shouldnt it?
05:30:12 <reddi> what is wrong on the following pattern matching?
05:30:13 <reddi> >inv_graph5 :: Graph -> Graph
05:30:14 <reddi> >inv_graph5 [(u,vs)] = [(u,[v]) | v <- sort vs]
05:30:23 <reddi> graph is [Int,[Int]]
05:30:39 <reddi> sry
05:30:41 <Heffalump> it only handles one element in the input list
05:30:46 <reddi> [(Int,[Int])]
05:30:50 <Heffalump> apart from that, it's fine.
05:31:03 <reddi> [(1,[1,4,2]),(2,[3,1]),(4,[4,1]),(3,[2])] 
05:31:09 <Heffalump> it won't handle that
05:31:12 <Heffalump> look at the pattern match
05:31:13 <reddi> why?
05:31:21 <Heffalump> [(u,vs)] matches a single element list
05:31:47 <reddi> and how do i select the whole list?
05:31:57 <Heffalump> inv_graph uvs = ...
05:32:21 <Heffalump> for example, inv_graph uvs = [(u,[v]) | (u,vs) <- uvs, v <- sort vs]
05:34:11 <reddi> hm... that is not what i wont but i dont get an error! why can i write on the left side uvs without any sepeartion?
05:34:33 <reddi> uvs is the variable Graph, do i see it right?
05:35:09 <Heffalump> yes
05:35:27 <reddi> ok and why can i say on the right side vs
05:36:06 <reddi> what is vs?
05:36:41 <Cale> bourbaki: not sure what you mean by that, but anyway, all the topoi that I've ever seen are infinite. (apart from perhaps the one-object category with no arrows apart from id)
05:37:18 <bourbaki> Cale: my things are finite though
05:37:20 <bourbaki> like the fsa
05:37:34 <bourbaki> but all the programs of course are as a class infinite
05:38:00 <bourbaki> so it is theoretically possible to construct an automaton/program that is infinite 
05:38:22 <Cale> well, depends on your definition of automaton/program
05:38:28 <Cale> :)
05:38:33 <Heffalump> (u,vs) <- uvs gives you the list of (u,vs) elements of the graph one at a time
05:38:35 <bourbaki> the programs are like flow diagrams
05:38:53 <bourbaki> this thingy thats like coloured petri nets
05:41:29 <reddi> ok, but  sort [1,4,2]=[1,2,4]    
05:41:40 <reddi> why do i get a new entry for each number?
05:44:02 <reddi> inv_graph5 [(1,[1,4,2]),(2,[3,1]),(4,[4,1]),(3,[2])]
05:44:02 <reddi> [(1,[1]),(1,[2]),(1,[4]),(2,[1]),(2,[3]),(4,[1]),(4,[4]),(3,[2])]      instead of [(1,[1,2,4],(2,[1,3]....]
05:44:50 <reddi> the second would be the intuitive meaning of >inv_graph5 uvs = [(u,[v]) | (u,vs) <- uvs, v <- sort vs] 
05:44:56 <reddi> but i get the first ;-(
05:45:04 <bourbaki> bye
05:45:05 <reddi> where is the thinking fault?
05:45:27 <Heffalump> you need to do something to group up the elements again, if taht's what you want
05:53:39 <reddi> hm i have tried it out with [1..5] instead of vs and there is the same... i get only ONE element by each entry.... how can i perform a grouping?
05:54:22 <reddi> he makes from every entry of the list a new entry ;-(
05:56:10 <Frederick> folks, can I have a piece of advice here -> http://paste.lisp.org/display/13988 it fails allways the root symbol needs to be replaced
05:59:33 <reddi> MY solution would be to make a new function which iterates through the list with a filter
05:59:45 <reddi> and does this somehow
06:00:20 <luqui> you could just take the current output and group it
06:00:46 <luqui> this should be especially easy if it's guaranteed to be contiguous in the first element of each tuple
06:00:59 <luqui> (but if it's not, it might be worthwhile sorting it first)
06:02:08 <reddi> what do u mean with group? the function group?
06:02:17 <luqui> well, you'd have to write the function
06:02:23 <luqui> but it shouldn't be difficult to write
06:02:36 <reddi> ok, so a directer solution is not possible
06:02:46 <reddi> in the list comprahension
06:02:58 <luqui> well... there might be some utility function in Data.Map that would do it for you
06:03:18 <luqui> but I don't think you can get this inside the list comprehension
06:04:04 <Frederick> reddi, are you talking with me?
06:04:39 <reddi> Frederick no g
06:08:05 <reddi> but i cannot perform this with pattern matching 
06:08:09 <reddi> i have to go through the list
06:08:23 <reddi> by using filter
06:08:35 <reddi> do i see that right?
06:09:54 * astrolabe loves haskell
06:13:42 * shapr too
06:14:19 * luqui hates it
06:14:23 <luqui> ... just kidding ;-)
06:14:32 <astrolabe> reddi: still there?
06:15:36 <reddi> ok, done
06:15:51 <reddi> i have progged that out at the morning, *hehe*
06:15:54 <reddi> same function
06:15:56 <reddi> PERFECT
06:16:05 <astrolabe> Cool.  You learn more doing it yourself I think.
06:17:56 <shapr> yeah
06:18:48 <astrolabe> How's things shapr?
06:21:04 <shapr> The weather is here, I wish I were beautiful.
06:21:13 * shapr misquotes Jimmy Buffet.
06:22:49 <Saulzar> Hmm, it takes quite a while to make a 1000x1000 array...
06:23:01 <shapr> I just made a neat LtU story: http://lambda-the-ultimate.org/node/view/1136
06:23:05 <kolmodin> hey guys
06:23:11 <shapr> hej kolmodin 
06:23:14 <tic> hej kolmodin
06:23:19 <shapr> tjenare!
06:23:26 <Lemmih> Finally! Serenity has hit the cinema in Denmark.
06:23:28 * Lemmih boings happily.
06:23:28 <tic> hej shapr.
06:23:35 <kolmodin> is it possible to run a haskell program as a script, like with #!/usr/bin/runhaskell or something?
06:23:38 * luqui thinks about publishing his Monad.pm for perl
06:23:44 <shapr> Lemmih: yay!
06:23:48 <shapr> kolmodin: yes
06:23:59 <shapr> luqui: yes!
06:24:08 <luqui> lol
06:24:10 <Lemmih> kolmodin: Yep. Cabal advises people to do that with their Setup scripts.
06:24:12 <tic> kolmodin, like that and +x it
06:24:27 <shapr> Though I use runghc on my box.
06:24:43 <shapr> dons: Oh hey, have you seen Thiemann's WSP?
06:25:00 <shapr> Has anyone tried it? I want to know if it's limited to WASH servlets only.
06:25:09 <shapr> Also, I'm looking for a decent persistent triple store.
06:25:22 <shapr> I really need to learn Data.Graph...
06:25:42 <shapr> I want a job writing Haskell... Plone work is brain damaging.
06:26:09 <astrolabe> better or worse than C++?
06:27:14 <astrolabe> Or more to the point, better or worse than trying to decode the first ever program somebody wrote, which is 30 files long and uses WX widgets in C++?
06:28:30 <shapr> Ok, better than C++ :-)
06:28:36 <shapr> Thanks for the perspective :-)
06:30:02 * Heffalump is quite enjoying C++ at the moment
06:32:15 <astrolabe> Why?  What are you doing with it?
06:32:51 <Heffalump> nothing all that special, but the interplay between templates and virtual functions is quite interesting.
06:34:43 <astrolabe> We seem to have to do some weird thing, using loads of stuff in a nugatory function to tell the compiler which template arguments it needs to make stuff for.  It is horrible.
06:35:05 <shapr> Nifty typo. Nugatory is a spiffy neologism.
06:37:15 <astrolabe> http://wordnet.princeton.edu/perl/webwn?s=nugatory
06:37:23 <astrolabe> So :p
06:37:44 <shapr> heh
06:37:55 <shapr> I had no idea that was a real word.
06:38:22 <astrolabe> One of my bosses used it the other day, so I had to look it up.
06:41:04 <tennin> i don't mind C++, personally
06:41:40 <tennin> what I hate are languages like Java that are both restrictive and ugly
06:41:45 <tennin> one or the other is OK
06:43:18 <JKnecht> Since OED dates it from 1603, I don't think "nugatory" can be considered a neologism.
06:44:56 <Saulzar> Hmm, it seems remarkably hard to convert between Double -> Float ... only way I can see is by using encodeFloat decodeFloat which seems rather roundabout, is there a better way?
06:48:28 <ulfdoz> is there no fromDouble?
06:49:47 <shapr> Can you use one of the Floating converters? Aren't they both Floating values?
06:49:58 <shapr> JKnecht: Yup, just a word I didn't know.
06:50:17 <droundy> Saulzar: try fromRational
06:50:51 <shapr> tennin: I suspect beautiful code can be written in any language. I think it's probably a matter of community culture.
06:51:25 <Saulzar> Ahh, great - thanks :)
06:51:49 <Saulzar> Seems to be rather a lot of miscelaneous floating point type classes
06:52:56 <araujo> Hello Haskell'ers!!!
06:53:45 <shapr> droundy: Do you know if something like "DARCS_APPLY_HTTP='curl -f --data-binary -' darcs push http://" will allow http push?
06:54:26 <droundy> shapr: What does that cause curl to do?
06:54:45 <eivuokko> How about writing that wrapper in haskell, to get it to support signing properly.
06:55:29 <shapr> Wouldn't darcs push --sign produce a GPG signed patch anyway?
06:55:51 <eivuokko> There is no --sign for push, atleast yet.
06:55:55 <eivuokko> :-(
06:56:13 <droundy> it would be easy to add...
06:56:27 <eivuokko> darcs send --sign --sendmail-cmd=  would work as well, tho, I think.
06:56:55 <shapr> droundy: data-binary is for a binary file, -f is fail silently, - means use stdin, which I think is the right way to deal with the DARCS_$COMMAND_$PROTOCOL convention.
06:57:01 <eivuokko> And sendmail-cmd has a lot more customisability than DARCS_APPLY_FOO.  But maybe they should be uniform.
06:57:59 <shapr> I wonder if that could darcs send instead?
06:58:47 <shapr> eivuokko: Yeah, --sendmail-cmd= probably is easier.
06:59:29 <droundy> shapr:  I still don't get what the 'darcs push' is doing in your DARCS_APPLY_HTTP
07:00:26 <eivuokko> droundy, To sign patch, to use http POST to send patch, and on serverside cgi script to check signature and apply if relevant.
07:00:30 <eivuokko> Right?
07:00:37 <shapr> I want 'darcs send' that works over HTTP POST, and it seems like the DARCS_$COMMAND_$PROTOCOL convention can probably do that if I have a serverside cgi program.
07:01:23 <dons> i love squashing space leaks, they are my mortal enemies
07:02:25 <droundy> eivuokko: I follow the idea, I just don't understand what curl would be doing exactly... but then I'm not sure I've ever used HTTP POST.
07:02:55 <shapr> droundy: darcs only uses http to download patches, why couldn't it use that to upload patches?
07:02:56 <eivuokko> droundy, http POST is easiest to catch on cgi-program.
07:03:13 <shapr> Lots of developers I know I don't have email setup correctly on their desktop system, only in their client.
07:03:43 <eivuokko> I think it's even better argument that this allows easier way to handle repos dynamically.
07:03:59 <shapr> How so?
07:04:08 <eivuokko> No need for so many email-addresses.
07:04:13 <shapr> Yes, I like that.
07:04:30 <shapr> I have way too many darcs-repo user accounts on ScannedInAvian.org
07:05:02 <droundy> shapr: that would be fine, but I'm not comfortable with handling the security implications of a cgi script.
07:05:19 <shapr> droundy: Security is no different from email, both would be GPG signed.
07:05:53 <dons> shapr, does cvs have any equivalent system?
07:05:53 <droundy> Yeah, except I don't know cgi stuff well, but I do (moderately well) understand procmail.
07:05:54 <shapr> Though later I'd like to see GPG encryption support so companies could do secure submissions.
07:05:58 <tuomov> shapr: yeah, I've had to add notice to my repo page that most likely the user's mail setup is broken because unix MTA:s are total crap
07:06:11 <shapr> dons: Not that I know of...
07:06:16 <tuomov> the config that 99% of users would want does not exist
07:07:13 <shapr> droundy: The only difference is that http is used to upload the file/patch instead of smtp.
07:07:13 <tuomov> but, otoh, I don't want to deal with cgis
07:07:38 <tuomov> email is ideal, but distro standard mta setup should be fixed
07:08:41 <droundy> shapr: My concern would be that a security hole would show up before darcs is ever invoked--it would almost certainly be safe once darcs is invoked, but what if someone could trick the cgi script to do something else?
07:09:04 <tuomov> what's so difficult with "only deliver email with fully-qualified from-field unaltered to isp's smtp server -- failing if not configured -- while also delivering local mail"?
07:09:42 <tuomov> no MTA seems to be able to do that easily, and certainly not by default
07:09:55 <shapr> droundy: How is that different from a procmail or .forward script that could be tricked?
07:10:50 <ulfdoz> .procmail is evil and .forward tends to loop. I like sieve.
07:10:52 <droundy> It isn't, but everyone writes their own procmail or .forward, and each one is likely to be customized for a repository.  With a cgi script, people would be more tempted to accept arguments indicating which repository to apply to.
07:11:21 <ulfdoz> although sieve for forwarding suffers the same problems as .forward.
07:15:32 <shapr> Maybe generate a cgi script for each repo the way darcs-createrepo generated .forward scripts?
07:15:53 <eivuokko> Hmm.
07:16:49 <droundy> One could do that, but it seems a bit scarrier.  The cgi scripts need to be SUID, which itself is a bit scary (although one could make all pushable repos owned by www-data or something--but that has its own security implications).
07:17:29 <shapr> Or you could use a darcs spool.
07:17:56 <droundy> spool?
07:18:05 <shapr> Like /var/spool/user
07:18:37 <droundy> what would that solve?
07:18:37 <shapr> Then the cgi script could upload to a safe location like /tmp/darcs/reponame
07:18:50 <shapr> and a darcs cronjob could go look for patches.
07:19:10 <eivuokko> ..or just locally deliver mail
07:19:17 <shapr> Ah, good point
07:19:24 <shapr> That would reuse the spooling system that MTAs use.
07:19:25 <eivuokko> It is less interactive then, tho.
07:19:33 <shapr> And it depends on installed software.
07:19:56 <eivuokko> cgi-script that does darcs apply by itself can give meaningfull errors back, immediately, which is also nice.
07:20:24 <shapr> Yeah, I'd prefer that myself.
07:21:08 <eivuokko> Yeah, I'd probably, myself, just let www-data own repos, forward email to a list/whatever easily viewable media, and be happy.
07:21:25 <eivuokko> *forward patch as email
07:21:50 <eivuokko> That of course implies not using --test and --posthook.
07:22:12 <shapr> right
07:22:28 <shapr> That's how the wikiwiki repository works.
07:25:24 <eivuokko> Security breach, injected patch and unpullable repo is of course a bit of a challenge for maintainer.
07:27:14 <shapr> It would still be safer than giving out user accounts for cvs commits.
07:30:31 <musasabi> There is also the possiblity of using a special group with the httpd and the relevant users in it and simply having all files with group write permissions.
07:30:49 <musasabi> no suid scripts and the owner can still modify things.
07:39:53 <shapr> In any case, the advantages would outweight the disadvantages for me. I'd like to figure out how to do GPG signed HTTP POST with DARCS_$COMMAND_$PROTOCOL or --sendmail-cmd= if the environment variable doesn't do it.
07:40:44 <droundy> For the moment, --sendmail-cmd is your only option, since push doesn't sign.  I imagine it's doable...
07:45:24 <shapr> Ok, thanks.
07:46:39 <eivuokko> Would additional client-side program be ok?  Writing a wrapper to do http-post with Http-module shouldn't be hard.  And someone wrote gpg wrappers, I think.
07:48:21 <eivuokko> Oops, got to go.  Later.
08:12:56 <shapr> I like playing untangle from sgt-puzzles.
08:19:11 <Cale> I like 'pattern' a whole lot
08:20:01 <Cale> (If you're referring to Simon Tatham's Puzzle Collection)
08:20:26 <ricebowl> anyone familiar with the GHC codebase? I'm a little lost. I want to know where reside the magic functions that GHC knows about internally
08:20:29 <ricebowl> e.g. int2Word#
08:21:05 * ricebowl is looking in fptools/ghc/compiler/codeGen
08:23:14 <shapr> Cale: Yes, you introduced me to sgt-puzzles.
08:24:02 <shapr> Untangle would be a good demo for Blobs.
08:24:30 <Cale> :)
08:24:42 <Heffalump> those puzzles are a great waste of time.
08:24:56 <Cale> There's a game I'd really like to see him do, and that's nurikabe
08:25:07 <Heffalump> what's that?
08:25:13 <Cale> I haven't seen an automatic/randomised version of that puzzle
08:25:15 <Cale> one sec
08:25:44 <Cale> http://www.puzzle.jp/letsplay/play_nurikabe-e.html
08:25:57 <Heffalump> you could email him and suggest it
08:26:02 <Cale> actually, probably better to start with the tutorial or rules page :)
08:26:05 <Heffalump> he is generally on the lookout for new ones
08:26:09 <Cale> I have, I didn't get a reply
08:26:12 <Heffalump> (I read the wikipedia article)
08:26:14 <Heffalump> ah.
08:28:33 * Cale downloads the e17 libs.
08:28:46 <Cale> The important ones ought to be stable enough by now :)
08:30:47 <Cale> I've been thinking that a Haskell binding to them would be a good thing for quite some time now. I did a binding by hand to imlib2 a while back, which worked well. I should finish it up and perhaps figure out how to cabalise it.
08:38:23 <Frederick> Folks, I got a function that fails sometimes, Ive found a pattern of the falure but I cant find a way to fix t, cause for me the failure maes no sense here -> http://paste.lisp.org/display/13988
08:39:28 <basti_> Frederick: again that bizarro grammar stuff?
08:39:49 <Frederick> basti_, yep :(
08:40:12 <Frederick> basti_, I cant understand why does it fail so I cant fix
08:40:21 <basti_> do you understand what it does?
08:40:32 <Frederick> basti_, think so.
08:41:50 <Frederick> basti_, the production is a replacer if it is associated with another touple of symbol production
08:41:54 * shapr yodels cheerfully
08:42:11 <basti_> how does that reflect in the types?
08:42:49 <phys_rules> is there anyone here I can talk about compiling/bootst. of ghc  ? :)
08:43:41 <Frederick> basti_, basically it checks if the second field ofthe touple can be replaced by the second field of another tuple that has the right side of the first as its left side like (A,B) if I have (B,c) it returns me (A,c)
08:43:53 <basti_> ehm
08:44:00 <basti_> i mean, the functions should have types
08:44:01 <basti_> like
08:44:04 <Frederick> basti_, this works fine btw
08:44:36 <basti_> State -> Input -> Maybe State
08:44:43 <basti_> just for a simple example
08:44:52 <basti_> all i see are inferred types
08:44:53 <Cale> phys_rules: I don't really know much about it, but I'm curious as to what arch you're bootstrapping on :)
08:45:02 <basti_> this makes it hard to understand what's going on
08:45:24 <Frederick> basti_, do you mean what are the types I pass to the function? oh oki I will show you them sorry I had missunderstood you
08:45:52 <basti_> yes and maybe of some subfunctions in there
08:45:59 <basti_> which could be named intuitively
08:46:58 <lisppaste2> Frederick pasted "a little bit more of info" at http://paste.lisp.org/display/13992
08:47:15 <basti_> ahh
08:47:50 <Frederick> basti_, the source is ugly as hell and many parts could be optimized but it isnt the intent
08:48:17 <phys_rules> Cale: Solaris x86 :)
08:48:28 <basti_> data CFG t nt = CFG {terminals    :: [Symb t nt],
08:48:29 <basti_>                      nonterminals :: [Symb t nt],
08:48:31 <basti_> whats that?
08:48:46 <basti_> terminals are some symbols, and nonterminals are some symbols too.
08:49:19 <Frederick> basti_, these are the components of a Context free grammar, a set of symbols and productions
08:49:37 <neologism> basti_: nonterminals can be rewritten to other nonterminals or terminals
08:49:40 <neologism> terminals cannot
08:49:58 <basti_> Frederick: why isnt there something that accounts for the relation between terminals, nonterminals and characters?
08:50:06 <basti_> neologism: yes i know.
08:50:14 <basti_> [Either Terminal Nonterminal]
08:50:26 <neologism> I didnt follow the discussion ;)
08:50:38 <phys_rules> Cale: I got to the point where the stage 1 ghc should get linked, but it seems the symbols are not exported properly, so I get a file 11mb worth of undefined symbols :)
08:50:44 <basti_> Rule = (Nonterminal,[Either Terminal Nonterminal])
08:51:13 <Frederick> basti_, the only thing that watches this relation is  production
08:51:51 <basti_> Frederick: why isn't production restricted in some meaningful way?
08:52:04 <Frederick> basti_, what do you mean?
08:52:29 <Frederick> basti_, this was my first program in haskell so it sucks as design
08:52:30 <basti_> well why don't the types reflect what's going on
08:52:56 <basti_> ^^
08:53:04 <basti_> why is your first haskell program such a knot? :P
08:53:31 <Frederick> basti_, took 3 weeks to take this stage
08:53:43 <Frederick> 3 weeks full afternoon work
08:54:16 <shapr> Frederick: You should try writing other small Haskell programs too, that will help you learn Haskell.
08:54:18 <basti_> :-o
08:54:30 <basti_> Frederick: do you know foldr? ;)
08:54:37 <shapr> If you focus on just one program that doesn't work, it's hard to get past the blocks.
08:54:50 <Frederick> shapr, I will do it later =/ I got a book, but now I dont have time for this
08:55:11 <shapr> Or maybe, you don't have time to *not* do it....
08:55:24 <Frederick> basti_, yes http://www.zvon.org/other/haskell/Outputprelude/foldr_f.html
08:55:40 <basti_> Frederick: did you toy around with it?
08:56:43 <Frederick> basti_, Ive did in in the tutorials samples
08:56:51 <basti_> mmm
08:56:56 <basti_> did you do list comprehensions?
08:57:16 <basti_> how many different faculty functions can you come up with?
08:57:33 <Frederick> huh?
08:57:37 <basti_> uhm
08:57:38 <basti_> factorial
08:57:39 <basti_> sorry
08:58:33 <Frederick> basti_, Iver seen tones of variations for that if Ive understood the question
08:59:35 <basti_> can you program tons of variations?
08:59:43 <basti_> can you wield the power of the type system too?
09:00:01 <SlowByte> what is fold*r* used for, besides the the ones that can be done with foldl? I find foldl slightly more intuitive
09:00:34 <Frederick> basti_, I cant program them without checking the tutorial but Ive tested tweaked and understood the idea behind them
09:00:48 <basti_> foldr: a*(b*(c*d)) foldl: ((a*b)*c)*d
09:00:53 <basti_> Frederick: fine :D
09:01:18 <Cale> SlowByte: funny, I find foldr more intuitive :)
09:01:37 <Cale> SlowByte: foldr is more natural in terms of the actual data structures involved
09:01:55 <Cale> SlowByte: foldr f z replaces (:) with f and [] with z
09:02:23 <Cale> http://vx.hn.org/autoshare/foldr.png
09:02:55 <Cale> foldl is slightly broken in that it doesn't work on infinite lists.
09:03:24 <SlowByte> hmm, maybe I'm confusing foldl and foldr
09:03:28 <Cale> Also, it's tail recursive, but most of the benefit of that is lost due to lazy evaluation anyway, so you usually want foldl', the strict version instead
09:04:30 <Cale> The tail-recursiveness is what makes foldl so popular in other (strict) functional languages, but in a lazy one, foldr seems better.
09:06:47 <SlowByte> why doesn't foldl work with infinite lists?
09:07:00 <phys_rules> SlowByte: because it has to start with the last element
09:07:04 <Cale> because it recurses to the end of the list before returning anything
09:07:42 <Cale> It can't even produce part of the result before it hits []
09:09:27 <Frederick> basti_, but the problem is that I cant understand why it fails
09:09:29 <shapr> Cale: Hey, want to write about laziness for TMR? :-)
09:09:40 * Frederick needs to go out for 5 minutes brb
09:09:45 <basti_> Frederick: clarificating your formulation might help with that
09:10:53 <shapr> I hope I can get 5 articles ...
09:11:30 <Cale> shapr: I was trying to -- it seems hard to get a coherent enough argument together for what I want to say. Perhaps I'll try some more :)
09:11:37 <SlowByte> oh, yeah, I was thinking in terms of scanl not foldl
09:11:45 <Cale> SlowByte: ah :)
09:11:56 <Cale> yeah, scanl is more natural than scanr
09:12:17 <shapr> Cale: Send me incoherence and I'll try to bounce back useful ideas?
09:12:23 <Cale> :)
09:12:25 <phys_rules> Is Simon hanging around here from time to time ? :) would be nice to ask him some questions about ghc :)
09:12:52 <shapr> Simon Marlow is JaffaCake 
09:14:36 <phys_rules> shapr: thanks, but he's probably not around now :)
09:15:01 <phys_rules> I'm trying to bootstrap ghc on Solaris x86, got some progress, but there's a problem with linking..
09:15:24 <shapr> JaffaCake: available for Solaris x86 linking problems?
09:15:44 <shapr> Guess not.
09:15:56 <jlouis> kolmodin: thanks, They will be applied soon
09:16:22 <phys_rules> shapr: thanks for trying ;)
09:17:38 <Cale> Well, the idea is pretty simple (in fact, it's kind of the definition of laziness) -- you can have a program f which works well, and a program g that perhaps takes a long time, or maybe doesn't terminate at all, and put them together as f . g or depending on types, perhaps f g, and get a working program.
09:18:27 <Cale> Which means that if you have a lazy program like f, you have a lot more options for how you write g
09:18:41 <phys_rules> lazyiness rocks =)
09:18:50 <Cale> whereas in a lot of these cases, you couldn't break that problem down at all in a strict language
09:19:17 <kolmodin> jlouis: you're welcome :)
09:19:30 <Cale> You'd have to build things into f which generated the parts of the solution which g produces.
09:19:31 <shapr> Cale: So, write up some demonstrations?
09:19:54 <Cale> Yeah, I have a few simple things, mostly centred on nondeterminism and search.
09:20:46 <shapr> Sounds like an article to me.
09:21:16 <Cale> One very simple thing which illustrates the issue is something like searching for a substring by using something like  any (isPrefixOf s) (tails str)
09:21:33 <Cale> If you show that to someone using a strict language, they think you're crazy.
09:22:13 <Cale> tails is way too expensive in terms of space and time if you're going to calculate them all at once
09:22:27 <SlowByte> what other useful infinite data structures are there besides infinite lists?
09:22:48 <Cale> mostly tree-like structures
09:23:23 <Cale> Infinite graphs are also nice, but I'm not sure how to implement them properly :)
09:23:56 <shapr> Okasaki showed that the amortized complexity of lazy algorithms was always superior to the complexity of strict versions of the algorithms.
09:24:21 <shapr> On the other hand, not all algorithms can take advantage of amortized complexity.
09:25:10 <shapr> Wouldn't Erwig's inductive graphs deal be fine with infinite values?
09:25:36 <shapr> Yeah, I'm almost positive it would work.
09:26:14 <SlowByte> oh blah, I have way too much stuff to read... Okasaki's "Purely Functional Data Structures" is still waiting
09:26:17 <Cale> Yeah, it probably would.
09:26:17 <shapr> Inductive graphs are defined by starting with an empty graph and then doing "the graph so far, and one new node and its connections" as much as you want.
09:26:24 <Cale> I need to order some books :)
09:26:59 <Cale> Yeah, and I *think* new contexts can only refer to previous vertices, which probably makes things reasonable
09:27:19 <Cale> You have an ordered graph, sort of :)
09:27:22 <shapr> It should be easy to generate a fully connected graph of any size that way.
09:27:32 <shapr> I'd much rather do that than hack more Python...
09:27:35 * shapr instead goes back to work.
09:29:06 <shapr> Cale: Want to send me a rough article, or put one on the TmrWiki?
09:29:26 <Cale> One neat thing is that in a lazy language, data structures and control structures are sort of the same thing.
09:29:42 <dash> that's true in a lot of contexts
09:30:21 <dash> lazy languages can arguably do it with less reification
09:30:34 <Cale> You don't have to think about loops or recursion explicitly, since you just use the right data structure, and implement some basic operations on it.
09:30:36 <SlowByte> I've been thinking about that a lot... unifying control and data structures that is
09:30:46 <dash> Cale: heh, "just"
09:31:23 <SlowByte> any pointers to interesting papers I should read? (in general, too)
09:31:42 <Cale> Well, most often that's a list. People are always curious why functional programmers use lists so much. I'd ask those people why imperative programmers use loops so much.
09:33:12 <SlowByte> well, most of my hacks have been in Ruby so far, it's imperative in a sense, but I think I haven't used a single loop :)
09:33:47 <SlowByte> map, foldl and zip are my friends ;)
09:33:51 <Frederick> back
09:34:08 <shapr> forward!
09:34:10 <Cale> SlowByte: Ruby is also nice in that your objects give you wrapped up control mechanisms.
09:34:47 <Cale> But I have trouble actually writing anything in a dynamically typed language. :)
09:34:50 <Frederick> basti_, the best solution for me atm was to simple hide the side effect
09:34:59 <SlowByte> yeah, blocks are way too elegant compared to other imperative control structures
09:35:18 <basti_> Frederick: "hide the side effect"?
09:35:23 <basti_> this gets even spookier
09:35:55 <Frederick> basti_, do you agree with me that my list is composed by 1 single type rigth?
09:35:59 <basti_> yes
09:36:01 <SlowByte> of course, in reality they're just a good syntax for anonymous first-class functions
09:36:28 <SlowByte> with closures, which makes them most useful
09:36:35 <Frederick> basti_, so why does it works for productions like A -> B -> C -> d and doesnt works if A is referenced later
09:36:59 <Cale> SlowByte: yeah, with side effects -- they're somewhat like functions a -> IO b
09:37:14 <basti_> Frederick: i don't have a clue
09:37:29 <kowey> i'd like some (functional) software engineering advice, please, maybe this could intersect the current fp discussion
09:37:42 <Cale> kowey: sure
09:37:56 <kowey> i've got some complicated recursive function that builds a Thingy (an automaton)
09:38:12 <Frederick> kowey, welcome to the formall languages club
09:38:18 <Frederick> have a seat
09:38:29 <kowey> the way it works is that it takes a Thingy and some other arguments and returns an augmented Thingy (Frederick, :-) )
09:38:54 <kowey> that's nice and easy, for the most part, i just care about the very last Thingy i get out of my function
09:38:57 <kowey> *but*
09:39:20 <kowey> since Thingys are complicated and could go wrong, it would be nice to visually debug the Thingy construction process
09:39:22 <dash> Frederick: as opposed to what kind of language?-)
09:39:35 <Frederick> dash, as opossed to the usefull ones
09:39:47 <dash> Frederick: like.. English?
09:39:58 <Frederick> dash, likethe ones you can use IRL
09:40:05 <kowey> and see each Thingy that gets produced from each recursive call
09:40:09 <kowey> in a graphical interface
09:40:12 <dash> Frederick: all programming languages are formal languages
09:40:33 <Frederick> dash, but they dont use normal forms for real life
09:41:00 <Cale> kowey: In a GUI, even, so you're willing to go to a bit of effort then. :)
09:41:14 <kowey> now, the solution i've got so far (something already implemented)
09:41:17 <kowey> is very ugly
09:41:22 <Cale> There's Debug.Trace, if you're looking for something primitive and temporary.
09:41:36 <Cale> (and potentially confusing :)
09:41:36 <kowey> in that i use fold to store all the intermediate results, i make a huge list of all the Thingys i ever built
09:41:38 <jlouis> threading a Writer monad around would definitely be pain
09:41:49 <kowey> and then use the visualiser to inspect the list after the fact
09:42:00 <Cale> I don't think a writer monad would be very hard, given what he's described.
09:42:10 <Frederick> dash, are you familiar with normal forms nd grammars?
09:42:21 <Cale> kowey: okay, that actually sounds sane
09:42:23 <dash> Frederick: I forget
09:42:36 <kowey> so i was vaguely thinking that i would need to promote my Thingy construction processing into something vaguely monadic
09:42:54 <Frederick> dash, do you remmember what is a transitive closure?
09:43:03 <dash> sure
09:43:04 <Cale> kowey: If you want logging, use a Writer monad with a list type.
09:43:05 <kowey> and that if i'm not debugging, i just pass an Identity monad or something, but then i just confused myself
09:43:38 <Cale> ah, but you have a bit of a problem with something like logging
09:43:43 <Frederick> dash, the basic abstraction of my problem is a transitive closure stuff
09:43:46 <alar> greetings to everyone
09:43:55 <phys_rule1> alar: hey ;)
09:44:01 <Cale> your code is going to need some special constructs in it to support the logging, and those are going to fix the monad type
09:44:35 <kowey> so, log file or gui or whatever, i'm thinking of some kind of logging problem... ok
09:44:52 <Frederick> basically I got a grammar like A -> S, S -> B, B -> c do you agree with me that there is a transtive closure there and that it adds no real info for the transition we really need that is A -> c
09:44:55 <Frederick> ?
09:45:11 <alar> I have rather stupid question: Why do I have to install, say "HaXML" library? Doen't haskell mean portability?
09:45:14 <Cale> kowey: it alreaady sounds somewhat nicely designed though
09:45:32 <kowey> the return a list of everything doesn't seem ugly to you?
09:45:37 <Cale> no
09:45:38 <dash> Frederick: what's that got to do with anything
09:45:46 <Frederick> dash, calm down
09:45:52 <dash> Frederick: zuh?
09:45:58 <Cale> kowey: as long as you make sure that list is lazy :)
09:46:05 <Cale> which is probably already the case
09:46:12 <Cale> use foldr
09:46:20 <Cale> or iterate
09:46:31 <kowey> hmm... that's reassuring... but i still feel i've got a big mess on my hands
09:46:41 <kowey> well... not from Thingy construction per se
09:46:43 <Frederick> dash, Im trying to check if you might enlighteen me :p
09:46:50 <Frederick> atm Im sitting in the dark room
09:46:57 <dash> Frederick: unlikely
09:47:01 <Frederick> =/
09:47:04 <Cale> so you get a nice list (which is like a reified loop) which you can pass into something which observes what's going on
09:47:05 <dash> i am a python hacker
09:47:16 <Frederick> =/
09:47:21 <dash> i use haskell when i want to play cruel jokes on my friends
09:47:30 <shapr> alar: HaXML is a Haskell library for doing operations on XML.
09:47:36 <kowey> well... thanks for that reassurance, then... i always figured i was doing something wrong
09:47:41 <dash> i wrote a monadic lisp interpreter in haskell, that is about all
09:47:48 <kowey> but wait... does lazinenss really assure
09:47:55 <kowey> that if i don't do any debugging
09:48:07 <kowey> i don't keep the intermediary Thingy's, only the last one?
09:48:11 <Cale> yeah
09:48:30 <kowey> hmm... i wish i could reason better about laziness
09:48:44 <Frederick> dash, sorry to bug you so, the case is that im really stuck :p
09:48:53 <Cale> kowey: it's all about what you observe
09:49:02 <dash> Frederick: programming is hard
09:49:03 <shapr> alar: So it's nothing to do with portability. probably you're using an application that does XML ops, and the creator didn't want to write all the XML processing themselves.
09:49:05 <Cale> If you observe something, it will have to build it.
09:49:09 <dash> i suggest giving up
09:49:18 <alar> sharp: I know, but why do I need "./configure","make", etc. instead of just ":l HaXML" in GHC?
09:49:19 <dash> and becoming a potato farmer instead
09:49:22 <Frederick> dash, Ive tracked the error but I cant understand why does it fail
09:49:25 <kowey> problem is that the latter Thingys are built from the former Thingys
09:49:30 <Cale> Now, it's going to build all those list elements anyway, since each is dependent on the last
09:49:32 <Cale> but
09:49:41 <Cale> It will throw anything away which isn't needed anymore
09:49:45 <kowey> ah-hah
09:50:27 <kowey> so i guess, one general haskell lesson to walk away with is "don't fight the laziness" :-)
09:50:27 <Cale> so doing  last xs  and not referring to xs after that, will cause it to throw away all the intermediate junk
09:50:33 <Cale> yeah
09:50:42 <Cale> laziness is usually good and usually what you want
09:51:08 <kowey> usually... except maybe in certain IO situations
09:51:20 <Cale> Well, really it's only when you're doing something like making a small summary of a large data structure
09:51:29 <Cale> That's when laziness hurts
09:51:56 <shapr> alar: iirc, HaXML checks for stuff like are you using gcc cpp, cpphs, hugs, ghc, etc. It probably doesn't really require configure and make, it's just there to turn out a compiled version of HaXML that's turned for your setup.
09:52:31 <Cale> and even then, a few strictness annotations (usually in your "folding" function) are usually enough to make things happy again :)
09:52:42 <kowey> there's still two places that laziness drives me crazy: trying to time stuff, and trying to say something like
09:52:52 <kowey> "now loading file foo" (dot dot dot).... "done!"
09:52:57 <phys_rule1> shapr: still there is this problem if having to download zillions of different packages just to get something done ;)
09:53:03 <phys_rule1> if=of
09:53:04 <phys_rule1> :)
09:53:06 <shapr> phys_rule1: Contribute to cabal-get!
09:53:11 <alar> shapr: so (theoretically) I can use it without precompilled package and "make" is not mandatory, but used for convenience?
09:53:23 <shapr> I want to run a Scraphead challenge on #haskell once cabal-get works.
09:53:25 <phys_rule1> shapr: first to hIDE =)
09:53:39 <shapr> alar: yes.
09:53:47 <alar> thanks
09:54:20 <shapr> The non-theoretical part is that not all Haskell implementations support the same extensions. Some extensions are *really* handy so they get used a lot.
09:54:25 <nnunley> Scraphead challenge?
09:54:31 <Cale> kowey: for timing things, I recommend "rnf" in Control.Parallel.Strategies, possibly together with something like evaluate from Control.Exception.
09:54:39 <shapr> The Cabal project is designed to deal with these problems in a pure Haskell manner.
09:54:42 <phys_rule1> shapr: I think what is really required is to improve cabal more and more up to the point of not having any of those pesky scripts which are very hard to manage and are hardly portable..
09:54:45 <shapr> nnunley: Sorry, "scrapheaP challenge"
09:54:55 <alar> shapr: IMO HaXML should be implemented in pure Haskell
09:54:56 * shapr is lysdexic today.
09:55:01 <nnunley> Ahh.
09:55:04 <alar> without any extebsion
09:55:17 <shapr> alar: I disagree.
09:55:22 <Cale> kowey: evaluate (x `using` rnf) will be an IO action which forces total evaluation of x.
09:55:37 <shapr> alar: I am thoroughly dependent on many of the GHC extensions.
09:55:46 <Cale> You can then stick getCPUTime calls on either side of that
09:55:50 <alar> shapr: it's just parser/pretty printer/combinators & stuff
09:55:58 <kowey> is this less painful than trying to seq or deepSeq it?
09:56:05 <shapr> Sure, but doing everything by hand is just not worth it.
09:56:11 <Cale> rnf is deepSeq, essentially
09:56:29 <shapr> alar: If you believe it is necessary, I'm sure the HaXML maintainer would welcome patches :-)
09:56:41 <kowey> ok, but here's where my reasoning about laziness fails me again... somehow, i'd want that within x
09:56:49 <kowey> we get all the niceties of laziness
09:56:59 <alar> yes, it might use TemplateHaskell or tool that derives instances (forgot the name)
09:57:00 <kowey> but "outside" of x, we just have a completed computation
09:57:04 <shapr> alar: But in some cases, it's more than parser/pretty printer/combinators, what about type system extensions like GADTs?
09:57:13 <alar> but no compiler-specific stuff
09:57:13 <SlowByte> shapr: dysgraphic, you mean? ;)
09:57:27 <kowey> see what i mean?
09:57:34 <Cale> I really wish someone would document Control.Parallel.Strategies better in the libraries documentation, and make NFData, the class that rnf belongs to, derivable.
09:58:10 <alar> shapr: in those cases necesity of installs and lacks of portability are unquestionable
09:58:12 <shapr> Cale: musasabi's SerTH code can be generalized to deriving any typeclass via TH.
09:58:33 <kowey> but ok, Cale, i'll keep that stuff in mind; many thanks!
09:58:59 <shapr> alar: I disagree there too. For example, I really *want* the SMP support that GHC has, even though no other compiler has it.
09:59:10 <phys_rule1> It would rock if haskell library docs would be extensively documented (ala API in Java), with examples, etc..
09:59:16 <Cale> shapr: that would be a good thing to add -- I'd almost think that it would be nice for that to be automatically derived for all suitable types by the compiler.
09:59:35 <alar> shapr: then you have to wait for other compiler to include that support :)
09:59:47 <shapr> Instead, I'll just use GHC.
10:00:07 <shapr> This computer is a dual Athlon MP 1.5GHz, smp support is really handy.
10:00:13 <alar> shapr: SMP support is not extremely portable core language :)
10:00:48 <dcoutts> shapr, oh? you've tried out the new smp ghc?
10:00:59 <physics_rules> hey dcoutts :)
10:01:02 <shapr> alar: You view is shared by people in the Haskell community, there was a discussion at the Haskell Workshop 2003 titled "Is Haskell the same as GHC?"
10:01:27 <dcoutts> physics_rules, hia
10:01:53 <shapr> dcoutts: I tried the very first version, I haven't tried it recently. Hopefully I'll have time to build the latest cvs version this weekend.
10:02:05 <physics_rules> btw, isn't ghc using an outdated version of gmp ? 
10:02:14 <araujo> Any GO'er around?
10:02:20 <shapr> I want to see if there's an easy way to connect parallel arrays to SMP.
10:02:23 <Cale> araujo: as in the game?
10:02:36 <araujo> Cale, yeah :-)
10:02:48 <Cale> I play a bit
10:03:00 <Cale> shall we have a game?
10:03:01 <araujo> Cale, cool, wanna play now?
10:03:04 <Cale> KGS?
10:03:14 <alar> shapr: much of Haskell is the same as GHC :) Because many of GHC extensions IMHO is a must
10:03:17 <araujo> Sure. mmm , i use IGS myself though
10:03:36 <shapr> alar: I agree. I'd rather just have a Haskell '06 standard.
10:03:43 <araujo> Well, i am actually starting to use it.... 
10:04:00 <araujo> Cale, What KGS client do you use?
10:04:21 <Cale> cgoban2, the only one :) Well, the Java Web Start version.
10:04:42 <shapr> alar: Anyway, I a self-employed contract programmer, so as much as I enjoy the theory, I want to efficiently deliver business value to my clients so I can get paid.
10:05:06 <Cale> http://kgs.kiseido.com/
10:05:26 <araujo> Cale, yup, i used to use cgoban2 , too heavy for me though
10:05:27 <Cale> there's a link to download the client
10:05:51 * araujo should code a Haskell+gtk2hs KGS client
10:07:36 <Cale> I'm not sure the protocol is completely open, but there's a GTP client for KGS that allows bots to play at least.
10:07:57 <Cale> I haven't really looked at it closely.
10:12:55 <frederik> is there a good haskell matrix library yet?
10:13:48 <Cale> frederik: there's nothing to write home about. There are a few small things.
10:13:49 <xerox> I think it's stated that people cannot do own clients to the KGS server :-(
10:13:54 <xerox> (Howdy, too)
10:14:22 <Cale> xerox: which is a shame, since the network itself has some pretty cool features
10:14:32 <xerox> Cale: very much, indeed.
10:14:59 <xerox> The this wms guy is making profit out the "closed source" client.
10:15:14 <Cale> Actually, the client they provide is one of the best go editing tools I've seen, though Java is a bit heavy for some people.
10:15:58 <xerox> It's right.
10:19:59 <frederik> why is everyone into go now?
10:20:15 <frederik> is go the new unicycling?
10:20:19 <Cale> Why not?
10:20:26 <Cale> Go is an excellent game
10:20:48 <Cale> Probably the deepest game I've ever seen :)
10:20:53 <shapr> frederik: Unicycling is a good way to Go.
10:20:58 <xerox> Pun.
10:21:00 <Cale> apart from mathematics, of course :)
10:21:02 <shapr> hiya SyntaxNinja 
10:21:24 <frederik> but mathematics has no rules
10:21:38 <SyntaxNinja> hi
10:21:39 <xerox> It surely has
10:21:39 <shapr> Sure it does, it's the science of finding the rules.
10:21:43 * SyntaxNinja played Go last night
10:22:02 <astrolabe> I have a haskell bot that play on kgs, but it passes all the time
10:22:10 <tuomov> I never seem to have the time :(
10:22:17 <astrolabe> Still, it handles the protocol
10:22:27 <shapr> astrolabe: Source online?
10:22:32 <frederik> shapr: exactly. they aren't there yet
10:22:35 <astrolabe> Unfortunatly, it was the first haskell code I wrote almost.
10:22:46 <shapr> astrolabe: Sounds like a great plugin for lambdabot 
10:23:02 <shapr> frederik: Thus, those who observe make the rules?
10:23:37 * shapr goes shopping
10:23:42 <astrolabe> shapr: It needs someone better at haskell to go over it, but it might serve as a start.  No it isn't on line, but I don't have a problem with it being online.
10:24:09 * xerox is with the mouse pointer on the 'add to cart' button for "his" unicycle.. (talking about shopping)
10:24:38 <xerox> It will probably wait some more, though...
10:25:40 <takuan> if I wanted to do a bunch of array updates, is there an easy way to make each update depending on the previous?
10:26:03 <xerox> Sequence them thought function application?
10:26:03 <takuan> normally I would use   array//[updates]
10:26:38 <Cale> takuan: well, the update list can depend on the array elements
10:26:52 <takuan> hum
10:27:07 <Cale> if you're using a boxed array type, you can even define array elements recursively in terms of one another
10:27:10 <takuan> what i want is some difference scheme which depends on the values i've already calculated
10:27:37 <Cale> that's doable
10:27:45 <takuan> can you hint me? ;)
10:27:51 <Cale> just refer to those elements directly
10:28:08 <takuan> currently i'm justing using something t// [((i,j),calculate i j)|i<-[1..(xbound t)-1],j<-[1..(ybound t)-1]]
10:28:17 <astrolabe> array7 = array6 // (getUpdate array6)
10:28:49 <Cale> right, you could make calculate take t as a parameter
10:29:18 <takuan> that'll be different from the where statement that i'm using now?
10:29:38 <takuan> or is it already happening?
10:29:41 <Cale> um, possibly not
10:29:46 <Cale> I'm not sure
10:30:10 <Cale> oh
10:30:12 <Cale> hehe
10:30:13 <Cale> I see
10:30:17 <takuan> let's see
10:30:31 <Cale> you don't want to refer to t
10:31:52 <takuan> so what do we refer to?
10:32:04 <takuan> the result maybe?
10:32:27 <Cale> s = t // xs
10:32:34 <Cale> and define xs in terms of s
10:32:35 <Cale> :)
10:33:01 <Cale> which isn't an infinite loop as long as you don't need a particular element to calculate that same element again
10:33:16 <Cale> (but you should be careful)
10:33:35 <Cale> btw, it's easier to write (i,j) <- range (bounds t)
10:33:37 <takuan> yup
10:33:57 <takuan> but it'll make my updating scheme clearer than it is now
10:34:09 <Cale> also, this sort of thing won't work with unboxed arrays
10:34:29 <Cale> (I don't think, anyway)
10:34:30 <takuan> dunno
10:34:36 <takuan> what's the difference btw?
10:35:21 <Frederick> does anyone here has Gazdar and Mellish books?
10:35:24 <Cale> Well, in Haskell, values are normally boxed, which means that they're implemented as structures with a tag and a pointer to either code, or a value.
10:35:42 <Cale> the code being code which if evaluated, yields the value
10:35:45 <astrolabe> What is the tag?
10:35:57 <xerox> The type?
10:36:13 <eivuokko> An integer identifying constructor, I think.
10:36:18 <Cale> the tag says whether the thing has been evaluated or not yet, and there might be some extra stuff around in the case of data constructors
10:36:28 <Cale> yeah
10:36:42 <astrolabe> Thank you
10:37:05 <Cale> So normal, boxed arrays are actually arrays of these boxes.
10:37:35 <Cale> This is not terribly space efficient if the arrays are large, so GHC also provides a variety of unboxed array types
10:37:50 <Cale> which store the values directly in an array of memory
10:38:06 <Cale> However, this means that the mechanism for lazy evaluation isn't present.
10:38:15 <takuan> aha
10:38:26 <Cale> So evaluating one cell of the array will force the whole array at once to be evaluated
10:38:30 <takuan> is IArray unboxed?
10:38:46 <Cale> IArray is an abstract interface to both boxed and unboxed array types
10:39:00 <takuan> and DiffUArray?
10:39:10 <Cale> DiffUArray is unboxed (that's what the U is)
10:39:14 <takuan> aha
10:39:16 <takuan> so i'm fucked
10:39:16 <Cale> DiffArray is boxed
10:39:17 <takuan> ;)
10:39:45 <Cale> well, you could try it anyway, and if it fails, change the type to DiffArray
10:40:06 <takuan> let's be terrible unefficient then
10:40:09 <takuan> it fails
10:40:11 <Cale> The other option is to simply build a new array
10:40:14 <takuan> it keeps on running
10:40:34 <Cale> though that defeats the purpose of using a Diff array
10:40:52 <takuan> what's a diffarray in fact?
10:41:07 <xerox> Cale's secret love.
10:41:12 <Cale> hah
10:41:23 <Cale> A Diff array is like any other array except that // is implemented in an invisibly impure way.
10:41:47 <Cale> a // xs  modifies the old copy of the array 'a'
10:41:50 <takuan> that seems to do the trick
10:42:08 <Cale> it replaces it with a pointer to the new array and a list of reverse-updates
10:42:26 <Cale> and simply modifies the array in-place
10:42:51 <takuan> though it isn't terribly fast
10:43:21 <Cale> so (a // xs), after evaluation, is a pointer to the mutated copy of the array, and (a) is a pointer back to that mutated copy with a list of changes that need to be reverted.
10:43:28 <takuan> would building a new array be a better idea?
10:43:35 <Cale> potentially, yeah
10:44:48 <takuan> let's see
10:56:19 <takuan> that doesn't seem to be a whole lotta faster
10:56:31 <takuan> but it works
11:01:43 <MarcWebe1> Today I want start another Programm and write the output (stdout) into a file.. So openFile "name" WriteMode; runProcess "prop" [] N(othing) N N returnedfilehandle N should do it. My question now is: openFile returns a Maybe handle, so it should be convinient to use the Maybe Monad for this task. But the handle parameter isn't the last one. Is there some shorter method then writing a lambda method to "move" the parameter to the end?
11:03:51 <shapr> @wiki CatInHaskell -- MarcWebe1, try this
11:03:51 <lambdabot> http://www.haskell.org/hawiki/CatInHaskell -- MarcWebe1, try this
11:06:02 <shapr> musasabi: Do you remember an arrow based wxHaskell using GUI lib that also found the black hole problem? I can't find the file, and I'd like to...
11:06:38 <shapr> I know it was hosted on a dyndns sort of address, it attempted to use arrow combinators to shortcircuit stuff like redraws, and worked if you didn't lift functions.
11:07:18 * ricebowl hopes GHC actually builds correctly this time :|
11:08:13 <physics_rule> ricebowl: hehe, at least it builds for you :)
11:12:26 <takuan> how does one debug in Haskell?
11:12:57 <SyntaxNinja> takuan: write a really good test suite as you write each function.
11:13:04 <shapr> Yeah, truly.
11:13:08 <SyntaxNinja> if you find a bug, the best thing to do is to try to track t down w/ a test case
11:13:24 <takuan> mkay
11:13:26 <SyntaxNinja> try to make smaller and smaller test cases that fail, unit testing wherever you can.
11:13:30 <takuan> now, for dirty hackers?
11:13:39 <SyntaxNinja> if you want to do it the wrong way, though, you can use Debug.Trace for printf-style debugging.
11:13:52 <shapr> Dirty hackers make the test suite afterwards, when they realize their code doesn't work.
11:14:10 <SyntaxNinja> or just putStrLn.  Debug.Trace can be a bit frustrating, though, because it's not exactly predictable, which isn't good when debugging.
11:14:34 <takuan> how do you put a putStrLn between our functional code?
11:14:59 <SyntaxNinja> takuan: if a function isn't in the IO monad, and you want to debug it w/ printf-style, you need to use debug.trace, not putStrLn.
11:15:10 <takuan> aha
11:15:15 <SyntaxNinja> remember, though, Debug.Trace is not really predictable and it might not output stuff when you expect it to!
11:15:27 <SyntaxNinja> malcolm_ could probably predict it ;)
11:15:29 <takuan> ok
11:16:34 <malcolm_> SyntaxNinja: predicting when a lazy application gets evaluated is pretty difficult
11:17:21 <SyntaxNinja> malcolm_: you flatter yourself ;)
11:17:50 <malcolm_> SyntaxNinja: no, I was claiming the opposite...
11:17:53 <yaarg> What do people think of Dylan?
11:18:10 * musasabi prefers staring at his segmentation faults and getting wrong ideas
11:18:47 <SyntaxNinja> yaarg: "Dylan is a fine programming tool for many applications"
11:18:48 <physics_rule> hey musasabi :)
11:18:55 <physics_rule> musasabi: I went farther with the port :)
11:19:04 <shapr> I've often want to see order of evaluation in Haskell programs, I bet it would look like modern art.
11:19:14 * SyntaxNinja sticks out tongue at malcolm_
11:19:38 <SyntaxNinja> yaarg: Dylan came in 2nd (?) in the latest Functional Programming contest. (haskell was first)
11:19:46 <basti_> is this statement correct: "Type constructors do not appear in the running haskell program"?
11:19:56 <shapr> yaarg: Probably worth learning.
11:20:11 <musasabi> basti_: sounds correct.
11:20:12 <eivuokko> basti, Yes.  All types must be concrete in Haskell.
11:20:20 <malcolm_> basti_: probably.  but data constructors might
11:20:24 <musasabi> physics_rule: nice :-)
11:20:26 <SyntaxNinja> although the whole episode left me with the impression that there are two dylan hackers and two dylan compilers.
11:20:29 <basti_> :D
11:20:30 <musasabi> did you get stage1 to compile?
11:20:31 <Igloo> They effectively do appear, in the form of dictionaries
11:20:35 <basti_> ah
11:20:43 <physics_rule> musasabi: yeah, that's the thing it compiles but it doesn't link :(
11:20:44 <basti_> but the programmer doesn't notice?
11:20:45 <shapr> yaarg: I have a fifteen minut rule for movies, I watch something even when I might not like it, and bail out after fifteen minutes if it still sucks.
11:21:06 <musasabi> physics_rule: want to paste the error somewhere?
11:21:08 <physics_rule> physics_rule: got to compile the libs & stage1 but at the stage of linking gives me 11megs of undeclared symbols stuff :)
11:21:19 <shapr> yaarg: My approach to learning new programming languages is to find five or seven that look cool, and then spend an hour on each of them. At the end of that day, I tend to know which one I want to try.
11:21:26 <physics_rule> musasabi: I think it's related to the way .hc exports things
11:21:32 <musasabi> ouch.
11:21:47 <physics_rule> physics_rule: I've noticed symbols like stg_ap_0_ret, etc.. are UNDEF
11:21:49 <musasabi> physics_rule: are you using sun or GNU toolchain?
11:21:56 <physics_rule> musasabi: sun
11:22:17 <physics_rule> musasabi: if I remove the _info definitions the symbols are back on track
11:22:33 <physics_rule> musasabi: so MAYBE it's related to the way ghc-asm mangler generates the .s files..
11:22:41 <musasabi> trying with gcc (and gnu stuff) might make things simpler
11:22:54 <physics_rule> musasabi: I'm using gcc, just the ld is sun's
11:23:13 <physics_rule> but the ld is quite right, the symbols are not there AFAIK in the .o's generated from .hc
11:23:19 <physics_rule> they just show up as UNDEF
11:23:25 <musasabi> either all the way sun or all the way GNU is a good rule.
11:23:48 <malcolm_> Igloo: a dictionary doesn't represent a type constructor, but a class predicate.
11:24:02 <physics_rule> yeah, but that doesn't change the fact that at least I should see the symbols exported when I do a gcc, then gas ...
11:24:58 <physics_rule> musasabi: plus I had to undefine a TABLES_NEXT_TO_CODE as otherwise I had lots of mistakes related to the fact that info tables get to reference the entry/return functions before they're define
11:25:00 <physics_rule> d
11:25:29 <Igloo> malcolm_: Sure, it's more complicated than that, but I'm not sure what the "real" question was
11:25:41 <physics_rule> but I tend to think it's somehow related to ghc-asm
11:27:34 <MarcWebe1> shapr: Couldn't see how this is related to my problem.. I want to do this: http://www.rafb.net/paste/results/UGxaGi69.html
11:36:29 <malcolm_> MarcWebe1: openFile gives you a Handle, not a Maybe Handle.
11:37:04 <basti_> what does the empty type constraint look like? "true"?
11:37:51 <malcolm_> basti_: empty class constraint is () => ...
11:38:31 <basti_> hmm 
11:38:36 <basti_> ok
11:38:45 <basti_> but thats empty parens isnt it?
11:38:48 <basti_> not some unit constraint?
11:39:34 <malcolm_> basti_: yeah.
11:39:39 <basti_> okay
11:39:47 <basti_> so what is it's ct value? ^^
11:39:49 <astrolabe> In general, a type constraint looks like a tuple
11:39:52 * basti_ ducks
11:40:04 <basti_> i was thinking like: this is an implication
11:40:14 <astrolabe> so I guess that's consistent
11:40:25 <basti_> the "empty enumeration" of constraints would have a meaningful truth value
11:40:36 <basti_> or type logic value
11:41:11 <ricebowl> my copy of GHC keeps crashing :)
11:41:12 <ricebowl> er :(
11:41:21 <ricebowl> crashed on compiling utils/FiniteMap.lhs
11:41:55 <astrolabe> mine is a bit unstable
11:42:00 <SyntaxNinja> ricebowl: what's the error message?
11:42:09 <ricebowl> there's no message.
11:42:20 <ricebowl> I'm trying to build GHC, so I have a binary version of the compiler
11:42:21 <ricebowl> 6.2.2, IIRC
11:42:38 <ricebowl> I got a bunch of "pattern match not exhaustive" messages on that file
11:42:49 <ricebowl> and then: make[2]: *** [stage1/utils/FiniteMap.o] Segmentation fault
11:43:33 <malcolm_> ricebowl: on what platform?
11:43:48 <ricebowl> Gentoo 2.6.13/x86
11:44:31 <Igloo> What version of gcc?
11:44:35 <ricebowl> 3.3.6
11:45:54 <ricebowl> heh, weird. If I compile it by hand, GHC doesn't crash.
11:46:05 <ricebowl> by hand as opposed to using make.
11:46:23 <Igloo> That sounds like it's a hardware/overheating problem, then
11:46:35 <malcolm_> ricebowl: could it be memory corruption then?
11:47:18 <ricebowl> it could be...
11:47:24 <ricebowl> I've had such problems on this box before.
11:47:27 * Igloo doesn't know if those versions of ghc and gcc are expected to work properly together, but I haven't seen any problems with gcc 4 and ghc 6.4.1, if you can upgrade to them
11:47:37 <ricebowl> I swapped out the 1GB DIMM I had with a 512MB DIMM because it all of a sudden became stable.
11:47:52 <ricebowl> Igloo - I can't get a binary version of GHC 6.4.1, AFAIK
11:48:01 <ricebowl> let me double-check.
11:48:32 <ricebowl> oh, wait, I can
11:48:38 * malcolm_ recommends memtest86
11:48:49 <ricebowl> malcolm_ - ran it, the box is solid for more than a day :|
11:49:14 <ricebowl> maybe I'll put Linux on my 64-bit box and try it there
11:49:29 <ricebowl> was too much of a headache trying to build using MinGW on Windows
11:52:27 <jeffno> What's the reasoning behind not allowing definitions in an interpreter like Hugs?
11:54:09 <Cale> jeffno: declarations are harder to deal with because they can be mutually recursive
11:54:19 <Cale> ghci will let you define things with let
11:54:27 <Cale> just functions and values though
11:54:30 <Cale> not data types
11:55:00 <Cale> but in general, it's much nicer to have two windows open, one with your source, and one with the interactive environment
11:55:09 <Cale> you can type :r to reload the file
11:55:48 <jeffno> Hmm, ok, I see why it may be hard to allow definitions.
11:56:07 <jeffno> Though I don't agree that it's nicer bouncing back and forth and remembering to type :r!
11:56:18 <cjb> jeffno: Oh, hello.  I recognise you from rec.games.go.
11:56:36 <Cale> Well, that way, you can see your whole source at once.
11:56:47 <jeffno> cjb: Hi!  What name would I recognize you by?
11:57:14 <tuomov> I think the interactive environment could simply be the IO monad..
11:57:24 <ricebowl> tuomov - it is.
11:57:25 <Cale> and your definitions are kept -- if you typed them all into the interactive environment, they'd just get lost (or at least, you'd have to go back and scrape your backlog to get them if you decided you'd like to keep them)
11:57:32 <tuomov> not exactly
11:57:34 <jeffno> Seeing all the code at once is nice, but not so good for experimentation.
11:57:35 <ricebowl> jeffno - if you make changes in your code, they're still there when you close the interpreter. ;)
11:57:56 <cjb> jeffno: Maybe by Chris Ball, but I lurk more than I post.  I'm in Boston too.
11:58:12 <ricebowl> tuomov - at least in GHCi, commands entered are executed in the IO monad
11:58:12 <tuomov> actually, it is; you can have definitions the IO monad way
11:59:25 <jeffno> My point of view is that I'm just starting to learn Haskell, and it would be nice to try things out entirely in the interpreter.
11:59:30 <tuomov> (/me hasn't used any interactive thingy much)
11:59:49 <Cale> jeffno: well, evaluating expressions can be done, and you can define things with let
11:59:51 <ricebowl> heh, that wasn't so bright...updating GHC while using it to compile GHC ;)
12:00:08 <Cale> > let fac n = product [1..n] in fac 20
12:00:09 <lambdabot> 2432902008176640000
12:01:15 <Cale> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 12 fibs
12:01:17 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144]
12:01:18 <sieni> that's not a valid siteswap!
12:01:27 <ricebowl> unfortunately the interactive environment throws away all your definitions if you load a new module :(
12:01:29 <dcoutts> I'm looking into the type tricks used by Haskell DB libs (because I may need to do the same for TreeModels in Gtk2Hs). Anyone have a suggestion about where I should start? HaskellDB, HSQL, ... ?
12:02:42 <ricebowl> heh, crap, GHC .hi files aren't compatible between versions?
12:02:44 <jeffno> Cale: But then your definition is only temporary, inside the let?
12:02:52 <Cale> jeffno: right
12:02:58 <jeffno> Ah well.
12:03:11 <cjb> Cale: Should we be daring you to add another 0 to the factorial or something?  :)
12:03:17 <Cale> in ghci, you can write  "let fac n = product [1..n]" and it will keep the definition for later lines
12:03:19 <ricebowl> jeffno - in the interpreter you can make it a little more permanent
12:03:23 <ricebowl> like Cale said.
12:03:39 <Cale> > let fac n = product [1..n] in fac 200
12:03:39 <cjb> jeffno: Do you play Go at the MGA at all?
12:03:40 <lambdabot> 788657867364790503552363213932185062295135977687173263294742533244359449963
12:03:40 <lambdabot> 403342920304284011984623904177212138919638830257642790242637105061926624952
12:03:40 <lambdabot> 829931113462857270763317237396988943922445621451664240254033291864131227428
12:03:40 <lambdabot> 294853277524242407573903240321257405579568660226031904170324062351700858796
12:03:40 <lambdabot> 178922222789623703897374720000000000000000000000000000000000000000000000000
12:03:57 <jeffno> cjb: Nope, KGS only.
12:04:08 <cjb> Guess not.  When do factorials start getting hard?
12:04:12 * ricebowl wonders how GMP is so fast
12:04:21 <flux__> hmm.. maybe lambdabot could keep separate namespaces for each nick, so you could define stuff and others could refer to it with nick.function
12:04:31 <flux__> although I guess such a change wouldn't be trivial
12:04:32 <shapr> dcoutts: BoundedList? What type tricks do you need?
12:04:45 <Cale> cjb: around 10000 it starts to take a few seconds
12:04:52 <ricebowl> flux__ - that would be kind've annoying without the ability to access someone else's code. :p
12:04:58 <jeffno> Ignoring lambdabot was the first thing I did when I got here :)
12:05:05 <dcoutts> shapr, basically how to represent the columns/rows of data in a type safe manner
12:05:15 <cjb> jeffno: Oh, what's your username there?  I'm "Kosai".
12:05:18 <flux__> ricebowl, I meant that you could access other people's code with theirnick.name
12:05:25 <jeffno> cjb: PaperTiger.
12:05:26 <shapr> dcoutts: Seen Oleg's article in the most recent TMR?
12:05:28 <Cale> cjb: actually, I think most of the time is probably spent figuring out the decimal digits of the number and encoding it as a string :)
12:05:31 <ricebowl> flux__ - isn't . a legal character in a nickname on Freenode?
12:05:39 <dcoutts> shapr, oh I'll look
12:05:46 <flux__> well, it isn't on ircnet
12:05:58 <flux__> atleast it's not very common one
12:06:10 <ricebowl> fair enough.
12:06:10 <shapr> dcoutts: I can also send you the reply he sent me when I asked about typechecking adjacency.
12:06:18 <dcoutts> shapr, we'd have to be able to connect 'renderers' to columns in the data model. We'd liek that to be type safe
12:06:23 <rice> aha, it tosses the .
12:06:54 <dcoutts> shapr, eg a CellRenderText can render columns of type String, etc
12:07:01 <shapr> dcoutts: I don't understand, but if you ask me again when I'm not occupied, I can probably help.
12:07:13 <dcoutts> shapr, ok, ta. I'll go read stuff
12:07:25 <shapr> Oh, that's easy with typeclasses, but harder and safer with other approaches.
12:07:26 <cjb> jeffno: Oh, I wonder if we've played.
12:08:10 <astrolabe> There is a page on the wiki for go playing haskellers
12:08:27 <jeffno> Really?  Got a link?
12:08:34 <astrolabe> looking now
12:09:15 <astrolabe> http://haskell.org/hawiki/HaskellGoPeople?action=highlight&value=kgs
12:10:01 <astrolabe> Ooops I'm not 4k anymore.  I haven't played much for ages :(
12:11:29 <jeffno> cjb: According to http://lublin.se/kgsstats/ we've never played.
12:12:48 <cjb> jeffno: Okay.  :) 
12:13:12 * cjb wishes he had more time for go.
12:13:36 * tuomov too
12:13:55 <tuomov> I've never even got a around to playing enough games for a proper rating..
12:14:00 <shapr> astrolabe: Did you put that quote onto @wiki TomCooper or did I?
12:14:17 <tuomov> 19x19 is so huge..
12:14:23 <Cale> I was somewhere in the single digit kyus last time I was playing rated games.
12:14:23 <shapr> If I started playing Go, I'd probably starve, but at least I'd do well.
12:14:47 <shapr> How high does it go? Seems tromp has been up to 2dan.
12:14:47 <tuomov> it's much more fun to play 13x13 games
12:15:02 * cjb has been told he's 3-kyu at the local club, but is 9-kyu on KGS.
12:15:02 <Cale> shapr: starve, as in become so addicted as to neglect work?
12:15:20 <jeffno> Go rankings are a mess.
12:15:22 <astrolabe> shapr: It wasn't me.  I don't know how.  What quote?
12:15:29 <cjb> shapr: Realistically, no higher than 7-dan in the US.
12:15:29 <Cale> cjb: yeah, ratings are relative
12:15:42 <astrolabe> Oh, hang on, the wiki.  I'll look.
12:15:45 <shapr> Cale: Yes, that sort of starve.
12:15:49 <cjb> (But there are players in Asia who are many, many stones stronger than that.)
12:15:49 <Cale> heh
12:16:07 <Cale> shapr: well, I'm not suggesting that you starve, but you should play a bit :)
12:16:17 <astrolabe> shapr: Ah, it  wasn't me.
12:16:19 <shapr> I don't think I can do 'a bit' of that sort of thing.
12:16:25 <Cale> hehehe
12:17:08 <astrolabe> It helps to have enough money to buy pro lessons I think.
12:17:20 <shapr> I tend to immerse myself in a system until I get sick of it.
12:17:24 <jeffno> I suspect 11d or 12d would be the highest KGS ranking possible, even for top pros?
12:17:24 <xerox> I find helpful the help of friends.
12:17:27 <tuomov> It helps to have lots of time for that sort of thing
12:17:28 <shapr> The deeper the system, the longer it takes me to get sick of it.
12:17:39 <astrolabe> It would be easy to use up a lifetime with go.
12:17:49 <jeffno> shapr: Go is a blackhole.  Run away, run away!
12:17:54 <Cale> It would be easy to use up several lifetimes with go
12:17:58 <shapr> astrolabe: And I'd rather end up with something that other people can use, not just me.
12:18:07 <Cale> and that's probably still an understatement :)
12:18:30 <shapr> I played Counterstrike for a coupla years, and became *very* good at it.
12:18:30 <astrolabe> I think the best players have created something worthwhile with their game records.
12:18:50 <shapr> I used to play decently against the Swedish guys who won the world championship.
12:19:07 <shapr> Everytime I look back to the time I spent getting there, I think 'What do I have to show for it?'
12:19:25 <jeffno> That's true of any game.
12:19:43 <astrolabe> I think playing is good for the mind.  It teaches you a lot about strategy in a sense independent of go.
12:20:07 <Cale> Go is useful because it teaches you how to combine emotion and reasoning into one tool for thought.
12:20:07 <shapr> Nowadays I put lots of time into learning the theory behind Haskell. When I put my name into google, I see what I have to show for it!
12:20:08 <tuomov> yeah, games that require thinking may be good in many ways
12:20:30 <tuomov> but otoh fps, well, maybe there are some benefits, but they're not immediately clear tome
12:21:02 <cjb> shapr: I think it's worthwhile.  I have a Go game from 196AD on my hard disk; people have been playing it in the same way we do for that long.  It makes all other goals we might have for our lives seem artificial.  :)
12:21:04 <jeffno> All that positives are wiped out by the game-specific details that you spend so much time on.
12:21:13 <xerox> Cale: so true.
12:21:42 <jeffno> Use knowledge of the 3-4 josekis to...?
12:21:42 <astrolabe> LOL when I type 'shae errison' into google it says 'did you mean: shae harrison'  :p
12:22:14 <musasabi> go is very simple on the surface thus not very much rules.
12:22:21 <cjb> jeffno: .. play some *righteous* pincers.
12:22:34 <tuomov> that's what I like about go. chess is way too pedantic for me
12:22:43 <musasabi> of course one can spend all time learning josekis, but then again that is true for most other similar games to even a greater extent
12:22:45 <xerox> tuomov: agreed completely!
12:23:03 <shapr> cjb: I'd rather spend that sort of effort trying to understand the connection between the Curry Howard isomorphism and classical logic.
12:23:13 <cjb> I've spent less time learning joseki than I did learning chess openings, and I'm a much better Go player than chess.
12:23:22 <Cale> You can actually get quite strong without 'learning' joseki (at least, in the stone-by-stone sense)
12:23:24 <jeffno> musasabi: Agreed!  I'm just backing up shapr here.
12:23:30 <xerox> I wasn't very happy about the josekis I know (knew?).
12:23:32 <tuomov> I've never got around to learning chess rules :)
12:23:53 <jeffno> Chess rules are easy, but the gameplay is a bit too tactical/combinatorial.
12:24:14 <xerox> Rules are ok, in some sense.  But I find the 'strategy' gameplay to be somehow 'made up'.
12:24:22 <cjb> There's a Go proverb about how you can get to shodan without learning how to fight.  :)
12:24:25 <astrolabe> You can get a long way in go without deliberately learning joseki
12:24:33 <shapr> cjb: I'm not saying it's not worthwhile, I'm just saying it falls outside of my interpretation of Richard Hamming's 'You and Your Research.'
12:24:59 <jeffno> astrolabe: "deliberate" being the key word there.  You have to learn the patterns, one way or another.
12:25:08 <astrolabe> shapr:  You could avoid sex for the same reason :)
12:25:15 <ricebowl> GCC 3.3.6 and GHC 4.6.0 should work together, yes?
12:25:15 <Cale> hehe
12:25:22 <shapr> I actually played Go once against Richard Braakman, he said it was the best first game he'd ever seen.
12:25:26 <Cale> ricebowl: 4.6.0?
12:25:42 <ricebowl> humptydumpty fptools # ghc -v
12:25:42 <ricebowl> Glasgow Haskell Compiler, Version 6.4, for Haskell 98, compiled by GHC version 6.2.2
12:25:45 <ricebowl> sorry
12:25:50 <ricebowl> dyslexic it would seem :)
12:26:06 <shapr> astrolabe: Nah, sex helps me think better =)
12:26:07 <cjb> Someone from the Go club in Cambridge played Erdos.  :)
12:26:09 <Cale> yeah, they work together
12:26:27 <jeffno> sex has a built-in mechanism too avoid spending too much time on it :)
12:26:41 <tuomov> shapr: go doesn't?
12:26:55 <shapr> Nope
12:27:07 <xerox> I hope this will: http://www.einradladen.net/catalog/images/big_ei1012_einrad_qu-ax_profi.jpg heh.
12:27:10 <ricebowl> Cale - hm, oh well... I don't know what I'm doing wrong then
12:27:20 <ricebowl> I'm getting undefined references
12:27:31 <astrolabe> Maybe maths : masturbation :: go : sex, if you know that notation.
12:27:41 <ricebowl> Main.o: In function `r745_info':
12:27:41 <ricebowl> : undefined reference to `ControlziMonadziWriter_zdfMonadWriterw_closure'
12:27:45 <ricebowl> [...]
12:27:57 <ricebowl> that is compiling Haddocks.
12:28:02 <Cale> astrolabe: heh
12:28:03 <ricebowl> Haddock, blah
12:28:16 <tuomov> astrolabe: as maths is academic wanking, go is academic sex?
12:28:27 <astrolabe> tuomov: right
12:28:29 <xerox> astrolabe: expand the notation :-D
12:28:29 * cjb grins.
12:28:39 <xerox> Uh-oh.
12:29:10 <cjb> "<foo> is to <bar> as <baz> is to <quux>" is the usual expansion.
12:29:16 <astrolabe> The notation comes from Euclids elements it means A is to B as C is to D in some sense.  It is about ratios and comparability.
12:29:37 <Cale> otoh, you can't actually use the game records as models for real-world or other phenomena so easily.
12:29:48 <tuomov> : : / :: :: : =
12:30:10 <cjb> Well, let's say The Breakthrough in AI comes from programming a machine to play Go ..
12:30:13 <xerox> tuomov: ah, cool.  Thanks astrolabe.
12:30:20 <cjb> .. and it was trained on all available game records ..
12:30:24 <cjb> .. therefore!
12:30:28 <cjb> :)
12:31:28 <astrolabe> cjb: right, we should all devote our lives to go to immenantize the eschatchion :)
13:02:44 * araujo running a haskell mp3 player on a haskell shell
13:03:26 <araujo> A web-browser, a text editor, an irc client, an email client and i am fully migrated 
13:03:44 <dcoutts> @karma+ araujo 
13:03:45 <lambdabot> araujo's karma raised to 4.
13:03:52 <araujo> dcoutts, :-]
13:05:45 <physics_rule> araujo: hehe, and then what next, Haskell OS ? =)
13:07:04 <dcoutts> physics_rule, that's already been done
13:07:13 <araujo> physics_rule, hey!, we've got House , 
13:07:21 <araujo> It is possible really....
13:07:39 * araujo considering to start migrating useful tool in Haskell really.
13:07:58 <araujo> That'd be fun.
13:11:17 <araujo> dcoutts, how you guys go with hIDE?
13:11:31 <dcoutts> araujo, stalled at the moment
13:11:42 <araujo> Why is that?
13:12:09 <dcoutts> problems with the GHC API
13:12:15 <dbremner> cjb - reminds me of this. http://ww.kuro5hin.org/story/2003/9/9/224310/1822
13:12:18 <physics_rule> hehe
13:12:35 <physics_rule> dcoutts: did I tell you I'm trying to compile GHC on Solaris x86 ?
13:12:36 <dcoutts> araujo, I'm working on some gtk2hs features that I need in hIDE
13:12:45 <araujo> dcoutts, cool cool
13:12:56 <dcoutts> physics_rule, oh right. I use it on Solaris sparc.
13:12:57 <physics_rule> and I got everything to compile for stage 1, but it doesn't link =) I definitely need to talk to Simon:)
13:13:12 <dcoutts> physics_rule, try gnu ld :-)
13:13:34 <araujo> geez.. ive got gtk2hs in my Learning-TODO list , i just need more time!
13:13:44 * araujo wanna vacations now
13:13:47 <dcoutts> araujo, yeah, neer enough time
13:15:58 <physics_rule> dcoutts: any idea how to force gcc use gld rather than ld ? :)
13:16:17 <dcoutts> physics_rule, I guess you'd need to rebuild gcc
13:16:30 <physics_rule> sounds bad =)
13:16:32 <dcoutts> and pass some configure option to tell it to use gnu ld
13:19:26 <physics_rule> hehe, that sounds weird:
13:19:32 <physics_rule> stage1/basicTypes/MkId.o(.text+0xc0a6): In function `r6Kd_info':
13:19:32 <physics_rule> : undefined reference to `OccurAnal_zdwoccAnal_entry'
13:19:34 <physics_rule> =))
13:19:39 <ricebowl> lol.
13:20:11 <ricebowl> heh, I should have realized that I'd need to re-configure as soon as I upgraded my version of the Haskell compiler
13:20:22 <ricebowl> 'twas what caused my issues earlier...
13:24:01 <physics_rule> dcoutts: same with gld :|
13:24:26 <physics_rule> I think it lies in the way the .s gets generated by ghc-asm
13:25:02 <physics_rule> as when I compile the .s files I see the entry/return functions are undefined but the info table is defined... weird
13:33:57 <dcoutts> physics_rule, you're building unregistered right? and without splitobjs?
13:36:07 <physics_rule> dcoutts: yes, of course
13:36:22 <physics_rule> otherwise it wouldn't compile to the point of linking in the first place:)
13:37:05 <dcoutts> ok ok
13:45:58 <physics_rule> weird, thing though, I tried to compile the raw_s directly and it works!
13:46:31 <physics_rule> so I need a perl script that simply removes the lines that start with / and ----
13:47:36 <musasabi> perl -pe 's/^(\/|----).+//' maybe
13:51:58 <physics_rule> musasabi: yep, thanks ;)
13:52:41 <ricebowl> what's -p?
13:55:33 <musasabi> ricebowl: loop for each input line printing.
13:55:44 <ricebowl> ah, ok
13:56:07 <musasabi> while(<>) { ...; print $_; }
13:56:12 <ricebowl> yes right
13:56:26 <ricebowl> hm, <> is the same as <STDIN>?
13:58:16 <xerox> I think so.
13:58:30 * ricebowl has never used that syntax, obviously
13:58:43 <xerox> Why is it obvious, if I could ask?
13:58:56 <ricebowl> because of my question
13:59:06 <xerox> Dang.
13:59:15 <ricebowl> hehe
13:59:32 <ricebowl> GHC is happ'ly building on my (slow) Linux box :D
14:05:11 <ricebowl> man, learning a non-Indo-European language is hard :/
14:06:48 <wilx> For example?
14:08:42 <ricebowl> wilx - Georgian
14:09:00 <physics_rule> yuppie
14:09:10 <physics_rule> reduced the error file from 12mb to 4mb =)
14:16:50 <physics_rule> 460kb now =)
14:22:30 <physics_rule> 2kb..
14:22:44 <ndm> physics_rule: sounds like quite a reductino...
14:23:08 <ndm> what are you reducing?
14:23:17 <physics_rule> errors from ghc build =))
14:23:26 <ndm> build yhc instead :)
14:23:34 <physics_rule> on solaris ? ;)
14:23:40 <physics_rule> I built yhi
14:23:50 <physics_rule> but for yhc I still need gh
14:23:51 <physics_rule> ghc :)
14:24:20 <malcolm__> or nhc98...
14:24:55 <physics_rule> I think soon it should be possible to bootstrap yhc ;)
14:25:03 <physics_rule> the guys seem to be very active ;)
14:25:14 <ndm> should be about another week
14:25:37 <ndm> physics_rule: did it need any patches for solaris?
14:25:59 <ndm> @wiki Yhc/Ports
14:25:59 <lambdabot> http://www.haskell.org/hawiki/Yhc/Ports
14:26:06 <physics_rule> ndm: I don't even remember, but even if something had to be fixes, it was fixed very fast =)
14:26:11 <physics_rule> fixes=fixed
14:26:19 <ndm> physics_rule: add yourself as a port maintainer to the wiki page
14:26:43 <physics_rule> okies
14:26:59 <physics_rule> ndm: you're Neil, right ?
14:27:06 <ndm> physics_rule: indeed
14:27:10 <physics_rule> nice to meet you then :)
14:27:32 <ndm> physics_rule: what is your name in real life?
14:27:37 <physics_rule> Iurie:)
14:27:41 <ndm> nice to meet you too
14:28:05 <physics_rule> thanks, keep up the good work on yhc =)
14:30:22 <physics_rule> err, would be nice if someone would have Readline_hsc.c
14:30:22 <physics_rule> =)
14:30:55 <physics_rule> it seems it didn't get created at the bootstrap process (since I was doing that on a windows machine:)
14:37:50 <ndm> physics_rule: are you talking about readline_hsc on yhc, or in general?
14:38:04 <ndm> i'm the yhc windows maintainer, so if something doesn't work on that, its my fault
14:41:17 <astrolabe> Why isn't yhc listed here? http://www.haskell.org/implementations.html
14:43:47 <dcoutts> astrolabe, because haskell.org is not a wiki :-(
14:43:56 <dcoutts> astrolabe, you can email the webmasters
14:44:48 <physics_rule> ndm: no worries, that was for ghc, fixed it already ;)
14:44:51 <astrolabe> True, but I know nothing about yhc, except I think it is another haskell complier
14:45:16 <ndm> astrolabe: i'll get someone on it
14:45:19 <physics_rule> ndm: yhc works quite good :) it just needs more libraries and it'll be great :)
14:45:46 <ndm> physics_rule: when did you try, it got a pile more libraries 3 days ago, and should get as many as ghc within a few weeks
14:45:50 <physics_rule> astrolabe: check out their blog, it's great
14:46:14 <physics_rule> ndm: the last dars pull I did was a couple of days ago
14:46:16 <astrolabe> physics_rule: link please
14:46:35 <physics_rule> yhc06.blogspot.com
14:46:42 <astrolabe> thanks
14:46:59 <ndm> @where yhc
14:47:00 <lambdabot> www.cs.york.ac.uk/~ndm/yhc
14:47:23 <ndm> @where+ yhcblog http://yhc06.blogspot.com/
14:47:24 <lambdabot> yhcblog ~> http://yhc06.blogspot.com/
14:47:54 <physics_rule> ndm: add the wiki link as well
14:48:15 <ndm> @where yhcwiki http://haskell.org/hawiki/Yhc
14:48:15 <lambdabot> I know nothing about yhcwiki.
14:48:20 <ndm> @where+ yhcwiki http://haskell.org/hawiki/Yhc
14:48:20 <lambdabot> yhcwiki ~> http://haskell.org/hawiki/Yhc
14:53:47 <dcoutts> @hoogle [a] -> Int -> Maybe a
14:53:49 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
14:53:55 <dcoutts> @hoogle [a] -> Int -> a
14:53:57 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
14:53:57 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
14:53:57 <lambdabot> Data.List.head :: [a] -> a
14:55:00 <TheHunter> ndm, it's (Data.List.!!) not Data.List.(!!)
14:55:25 <ndm> TheHunter: maybe, but in general people do import Data.List, then use (!!)
14:55:53 <ndm> earlier versions dropped the brackets entirely, so it was Data.List.!!
14:56:00 <ndm> but Prelude.. makes no sense
14:56:21 <ndm> is (Prelude..) function composition? or just broken?
14:56:36 <TheHunter> that's function composition, alright.
14:56:49 <ndm> even though .. is enumeration?
14:57:35 <TheHunter> > id Prelude.. id $ 0
14:57:36 <lambdabot> 0
14:58:16 <TheHunter> you should drop the parentheses then, if you dislike (Data.List.!!).
14:58:22 <malcolm__> lexing is maximal munch, so Prelude.. is a qvarop
14:58:56 <ndm> malcolm__: Hugs seems to view (Prelude..) as ((Prelude).(.))
14:59:53 <TheHunter> Hugs.Base> id Prelude.. id $ 0
14:59:53 <TheHunter> 0
15:01:30 <astrolabe> Is there a description of the YHC bytecode somewhere?
15:02:39 <ndm> @wiki Yhc/RTS
15:02:40 <lambdabot> http://www.haskell.org/hawiki/Yhc/RTS
15:02:56 <astrolabe> gratzie
15:03:01 <ndm> astrolabe: yes, quite detailed documentation there, plus a C, Java, Haskell and Python implementations of it
15:03:52 <ndm> but it will be changing soonish, although not massively
15:04:12 <ndm> the bytecode format will stay reasonably similar, but hte layout of a .hbc file will change a bit
15:04:42 <astrolabe> The bytecode is only interpreted at the moment?
15:05:05 <ndm> astrolabe: yes
15:05:17 <ndm> although there 
15:05:33 <ndm> is a project to translate it to C, and one to translate it to JVM instructions
15:34:24 <ricebowl> make[2]: *** [edison/Coll/SplayHeap.o] Illegal instruction
15:34:25 <ricebowl> :(
16:30:05 <Frederick> yo SamB are you back?
17:49:20 <linux-fun> hey 
17:49:28 <linux-fun> does haskell handle large systems well?
17:49:42 <wilx> ?
17:50:55 <linux-fun> like my company has java hell
17:51:08 <linux-fun> it gets database dumps from servers in field then imports em into mysql
17:51:14 <linux-fun> scheduled jobs
17:51:19 <linux-fun> then web front ends
17:51:24 <linux-fun> all waky n crappy
17:51:35 <linux-fun> I wonder if haskell programs could organize this chaos
17:52:11 <wilx> Hmm, I think that the this is not language dependent.
17:52:23 <dons> @index sizeOf
17:52:23 <lambdabot> Foreign.Storable, Foreign
17:53:17 <SyntaxNinja> linux-fun: your chaos sounds like a social issue, not a language issue.
17:53:36 <SyntaxNinja> linux-fun: although I find Haskell is very good for writing reusable code
17:53:44 <SyntaxNinja> and modular code.
17:54:10 <SyntaxNinja> linux-fun: I'm hoping that hackage (http://hackage.haskell.org) and cabal will make deploying complex systems much easier.
18:04:09 <araujo> Hackage is sort of CPAN for Perl?
18:05:09 <SyntaxNinja> hackage is to haskell as cpan is to perl
18:06:38 <araujo> Right, taht's what i meant
18:13:41 <sethk> CPAN is sort of a hackage for Perl
18:14:39 <sethk> that would make it transitive, I think.  All you category mavens out there can all now tell me that I picked the wrong characteristic.  :)
18:14:52 <gzl> what's transitive?
18:16:48 <sethk> gzl, seriously, I somehow get them confused.  Not the concepts, which are easy, but the terms.  If I'm right, then a transitive relation is one where...
18:16:55 <sethk> gzl, if a -> b, then b -> a
18:17:08 <gzl> that's symmetric
18:17:09 <sethk> but actually I think I do have the wrong word.  :)
18:17:37 <gzl> transitive is a < b, b < c => a < c
18:17:53 <sethk> gzl, see, I knew you would tell me.  :)
18:17:55 <sethk> right
18:18:06 <gzl> this has nothing to do with categories either way :)
18:18:15 <sethk> gzl, that's not true
18:18:31 <sethk> gzl, many of the categories include as part of their type, say, a transitive arrow
18:18:42 <gzl> I wouldn't really count that as being related
18:18:57 <sethk> gzl, if it were related, which type of relation would it be?
18:19:00 <sethk> :)
18:19:51 <sethk> gzl, seriously, though, how could you contend that a relation is not related?
18:21:00 <gzl> I don't see how mixing up the names of various kinds of relations is related to category theory simply because those relations show up here or there
18:21:03 <gzl> those things show up everywhere
18:21:48 <gzl> it's like saying, "You physicists will correct me on the use of injective vs surjective" because functions show up in physics :)
18:22:20 <sethk> gzl, mixing up the relations it not related, true.  The relations are related.  What I meant was that people here are so familiar with category theory as to be ready to instantly correct me.  :)
18:24:03 <gzl> it's a strange thing to mention categories in particular, because those relations are so basic to every part of mathematics 
18:24:07 <gzl> that's what I meant
18:24:27 <gzl> I'm aware this has now turned into nitpicking :)
18:24:36 <sethk> gzl, nitpicking?  here?  :)
18:24:38 <gzl> but nevertheless
18:25:18 <gzl> (transitive/symmetric/whatever relations aren't inherently related to category theory in the way that monads are, for example)
18:25:31 <sethk> gzl, I'm not sure you are correct, if I may pick another nit.  Is not category theory in large part related to isolating those things that are used in many places in mathematics but have a more general meaning?
18:26:10 <sethk> gzl, well, ok, but the definition of a monad includes a transitive relation (or rather of a monoid, and the definition of a monad includes the monoid)
18:26:26 <gzl> there's a difference between a construction basic to mathematics and a categorical construction that's generalizing more specific constructions elsewhere in mathematics
18:26:52 <gzl> a relation is a totally basic thing, which is why it's used everywhere
18:27:07 <gzl> what category theory aims to do is to find a common generalization for seemingly unrelated constructions
18:27:27 <gzl> or only intuitively similar constructions
18:27:48 <sethk> gzl, intuitional relationships are surely utterly irrelevant
18:28:05 <gzl> no, they're not, because you can formalize some of them
18:28:13 <sethk> it seems to me the very fact that they are ubuquitous makes them relevant
18:28:38 <sethk> gzl, why is the intuition relevant to the formalization?
18:28:40 <gzl> I wasn't saying anything about relevance or irrelevance
18:28:54 <gzl> I was talking about what category theory does
18:29:21 <sethk> gzl, I suspect we are just using words in a slighly different way.
18:29:59 <gzl> I think you're conflating two different kinds of "basic constructions," only one of which is the concern of category theory
18:30:13 <gzl> though that's probably also true
18:30:22 <sethk> gzl, perhaps; I don't claim to be an authority
18:37:07 <araujo> tizoc!
18:37:18 <tizoc> :)
18:45:35 * Cale steals binding hook ideas from xerox's cairo binding :)
18:47:56 <Cale> c2hs is pretty cool
18:57:22 <benny> @where c2hs
18:57:22 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
19:02:34 <SlowByte> oh brother, I should stay off Amazon
19:02:55 <Korollary> No !
19:03:03 <SlowByte> you go there to check out a book and then you follow a link... and then you follow a link... and then three hours have passed :)
19:03:08 <Cale> hehe
19:03:21 <Cale> and you have a $300 bill for books
19:03:36 <SlowByte> and the length of your "to-read" list is approaching infinity
19:08:56 <sethk> SlowByte, but is he converging?
19:27:52 <shapr> Sometimes I wonder where I find these papers... When was I interested in the coinductive solution of recursive equations, and why?
19:30:13 <Korollary> It's no problem. In two weeks you will be re-interested in them for some possibly other reason anyway. Rinse, repeat.
19:33:57 <shapr> I'm cleaning out my incoming research papers directory, lotsa interesting stuff.
19:34:45 <sethk> shapr, you can burn a _lot_ of papers to one cd
19:35:13 <shapr> I even have a DVD writer.
19:38:23 <araujo> Nomius, hola!
19:40:48 <Nomius> Hola
19:59:03 <dons> @yow
19:59:04 <lambdabot> PEGGY FLEMMING is stealing BASKET BALLS to feed the babies in VERMONT.
20:01:15 <dons> ah, even better for debugging mysterious head [] errors, +RTS -xc, when an exceptoin is raised cause the current cost-centre-stack to be dumped to stderr
20:13:28 <Lemmih> dons: Won't that just name some meaningless CAF?
20:14:07 <dons> depends on where the exception is thrown
20:14:23 <dons> {-# SCC "my fun #-} head []   ...
20:14:41 <dons> -xs is supposedly explicitly for this problem
20:14:43 <dons> so I guess it works
20:15:59 * Lemmih can't get it to work.
20:17:27 <dons> a bell rings in my head about -xc being broke in > 6.4
20:17:32 <dons> I wonder if that's true.
20:17:38 <dons> >= 6.4
20:17:55 * dons plays with +RTS -B -hc -i0.01 -Sstderr
20:19:11 <Lemmih> Yay. JaffaCake is idling.
20:19:45 <dons> sorry, -xc, not xs as I wrote above
20:24:46 <Lemmih> dons: Do you work on hIDE with 6.5 or 6.4?
20:25:30 <dons> I was using 6.5, iirc
20:26:18 <Lemmih> With or without ghc-api?
20:28:35 <dons> with ghc-api, I did get that working I think
20:28:43 <dons> been a while since I played with this code though
20:55:49 <Cale> Anyone here who is familiar with c2hs? I have the function hook:
20:55:54 <Cale> {#fun imlib_context_set_display as contextSetDisplay {id `Xlib.Display'} -> `()' #}
20:56:18 <Cale> and it's generating an import like:
20:56:25 <Cale> foreign import ccall safe "Imlib.h imlib_context_set_display"
20:56:25 <Cale>   contextSetDisplay'_ :: ((Ptr ()) -> (IO ()))
20:56:45 <Cale> rather than:
20:56:55 <Cale> contextSetDisplay'_ :: ((Xlib.Display) -> (IO ()))
20:57:10 <Cale> and I'm not sure why
20:59:28 <Cale> the relevant C code looks like:
20:59:39 <Cale> void imlib_context_set_display(Display * display);
21:00:43 <Cale> where the Display type comes from X11/Xlib.h
21:01:00 <Cale> which is included by the header file that I'm pointing c2hs at
21:03:26 <Cale> by keeping the preprocessed header, I can clearly see that it should know about the Display type on the C side of things.
21:04:39 <Cale> I suppose I can manually cast, but that's a pain, when it could just generate the right import initially.
21:05:59 <sethk> Cale, its a form of encapsulation, primitive as it may be
21:07:01 <Cale> sethk: my question isn't why the C type is Display and not void * or something, it's that the binding that c2hs is emitting has the wrong types in it.
21:07:21 <Cale> If I go in by hand and correct the binding after the fact, it works fine.
21:07:37 <Cale> (changing Ptr () to Xlib.Display)
21:08:45 <Cale> I'm even telling it explicitly what types it's supposed to choose, but it seems to be ignoring that.
21:37:54 <sethk> Cale, I'd have to preprocess the file and go through it in detail to know why.  Which would be painful, obviously.
21:38:10 <sethk> Cale, but if you preprocessed it and looked at the source the compiler actually works with, it would become obvious to you
21:41:34 <Cale> Well, I think it might have something to do with the fact that I'm not using c2hs to generate a binding to Xlib -- I'm just using the Xlib binding which comes with GHC. It is really doing something quite wrong though, since the source which it emits won't typecheck at all.
21:42:00 <Cale> If it just syntactically pasted the type in which I gave it, then there would be no problem.
21:42:19 <Cale> But it decided that it couldn't do that for some odd reason.
21:43:37 <Cale> I've looked at the preprocessed output, and the stuff on the C side is completely sane
21:44:05 <Cale> X11/Xlib.h is included as expected
21:44:27 <sethk> Cale, that part about using the ghc xlib bindings has to be the root cause, then
21:44:51 <sethk> otherwise c2hs has no way to mangle the types that I can think of
21:44:58 <sethk> of course it's a machine so it can be broken...
21:45:03 <Cale> I think it's a bug
21:45:22 <sethk> oh, sure, but you might find a workaround if you know more specifically what's happening
21:45:39 <sethk> it's a bug by definition, no?
21:45:43 <Cale> Oh, I have a workaround, but it's somewhat painful.
21:46:16 <sethk> fixing it is not sensible?  fixing the c2hs bug?
21:46:23 <Cale> I'm just going to complain on haskell-cafe, and if that doesn't work, perhaps look at c2hs myself.
21:47:14 <Cale> ah, there's a c2hs mailing list, I should post there too :)
21:47:50 <sethk> sure, why not?  maybe it's already a known situation
