00:10:41 <lightstep> i'm trying to build yhc, but make prelude fails, saying YHC_BASE_PATH is not set
00:11:11 <lightstep> when is this variable read?
00:11:51 <lightstep> when the compiler is run? when the prelude is built? should i set it myself?
00:15:01 <lightstep> ok, i found out: it should be the "inst" directory in the source tree (at least in the build process)
00:17:57 <lightstep> and NHC_BASE_PATH should also be set to that directory
00:28:28 <palomer> oh crap
00:29:24 <palomer> I think there's a leak in ghci
00:29:57 <palomer> I left it idle for half a day and it ended up taking a gig of memory
00:34:19 <palomer> batman begins sucked
01:13:35 <sethk> palomer, they showed it on the airplane last week flying across the country.  Even there, the ultimate captive audience, it wasn't good enough to watch
01:14:00 <sethk> palomer, I suppose it had a few effects, but even the effects seemed boring to me.
02:01:29 <roconnor> @pl \f -> join . flip fmap f . flip fmap . fmap
02:01:30 <lambdabot> (join .) . (. (flip fmap . fmap)) . flip fmap
02:12:45 <flux__> there should be a standard prelude function called 'flap', it would make the pointless versions more funny!
02:13:36 <{Arias}> @help pl
02:13:36 <lambdabot>  @pointless <expr> - play with pointfree code
02:14:15 <{Arias}> @pl head . tail
02:14:15 <lambdabot> head . tail
02:14:19 <{Arias}> 8)
02:14:36 <flux__> @pl \x -> head (tail x)
02:14:37 <lambdabot> head . tail
02:14:53 <flux__> hmm, a reverse of @pl would be cool..
02:18:02 <flux__> and, infact, sometimes it could even be useful :-o
02:18:09 <flux__> (not saying that @pl isn't.. ;) )
02:18:48 <flux__> you could feed your functions to @pl first and then @unpl
02:19:09 <{Arias}> @unpl (join .) . (. (flip fmap . fmap)) . flip fmap
02:19:09 <lambdabot> (join .) . (. (flip fmap . fmap)) . flip fmap
02:19:40 <flux__> maybe some @sanepl-version could be deviced, that would use both of the functions to reach some understandable, yet concise, solution ;)
02:19:55 <flux__> s/device/devise/
02:20:02 <{Arias}> :P
02:29:04 <pesco> ski: I need more general CPS first. ;)
02:30:32 <ski> ok
02:30:38 <ski> morning #haskell
02:31:06 <sethk> ski, see, that didn't hurt a bit.  :)
02:31:56 * ski is busy reading backlog
02:32:14 <ski> (see ?)
02:32:40 <kolmodin> what do I need to compile gtk2hs with support for cairo? to have cairo installed or >= gtk 2.8 ?
02:33:42 <sethk> kolmodin, both, I think.  I'm not sure about the versions, but you need cairo and gtk
02:33:54 <kolmodin> I perhaps need >= cairo 1.0 ?
02:33:55 <pesco> ski: Good thing, citeseer filenames include the year. I can immediately see in which order to read the papers.
02:34:56 <kolmodin> sethk: ah, according to the configure.ac of gtk2hs I need >= 1.0.0
02:35:02 <kolmodin> ok, thanks
02:37:12 <pesco> ski: So, are those papers suitable for someone with not much understanding of continuation passing style?
02:44:48 <ski> pesco : um .. not sure .. unfortunately, i've forgotten in which papers i learned about the CPS equations ..
02:45:19 <ski> pesco : those two i remember i read i though was good, after i got most of them
02:47:44 <dcoutts> kolmodin, you need gtk 2.8 (which itself requires cairo)
02:48:19 <dcoutts> kolmodin, or you can emerge gtk2hs :-)
02:49:14 <pesco> ski: Wikipedia has an article, I'll see where I can get from there.
03:12:52 <kolmodin> dcoutts: for now when 0.9.10 and the development version are almost equal, yes :)
03:15:01 <kolmodin> I choose the easy path through emerge for now :)
03:15:01 <dcoutts> kolmodin, yeah. (though the dev version now has OpenGL!)
03:15:09 <kolmodin> dcoutts: oo!
03:15:17 <dcoutts> http://haskell.org/gtk2hs/archives/category/development/
03:15:49 <dcoutts> kolmodin, check out the silly flash video
03:21:04 <kolmodin> nice :)
03:21:26 <kolmodin> too bad it doesn't reflect the real thing
03:25:32 <dcoutts> kolmodin, yeah, vnc2swf isn't great for recodring animation
03:37:25 <kolmodin> dcoutts: is it much work to keep gtk2hs compatible with both gtk 2.6 and 2.8?
03:37:49 <dcoutts> kolmodin, no not really. It's still compatible with Gtk+ 2.0
03:38:02 <dcoutts> and ghc-5.04.3
03:38:09 <kolmodin> ok
03:38:49 <kolmodin> so what does a gtk2hs user have to do if he doesn't know which version gtk2hs is built upon?
03:38:55 <dcoutts> which turns out to be useful since my department has Solaris machines with Gtk+ 2.0
03:39:03 <kolmodin> use #preprocessors stuff?
03:39:32 <dcoutts> kolmodin, as of gtk2hs-0.9.10 we install a header file which one can use to do #preprocessor stuff more easily
03:39:53 <kolmodin> ok, good
03:40:34 <dcoutts> the header file makes it easy to compile things conditional on the gtk version and the packages that gtk2hs was built with (eg to check if cairo is available)
03:41:15 <dcoutts> for example my soe graphics implementation has a gdk fallback implementation if cairo is not available
03:41:41 <kolmodin> ok, that's nice
03:43:20 <dcoutts> http://haskell.org/~duncan/soe/Graphics/SOE/Gtk.hs
03:43:29 <dcoutts> it just does #include <gtk2hs-config.h>
03:43:44 <dcoutts> and then, #if GTK_CHECK_VERSION(2,8,0) && defined(ENABLE_CAIRO)
03:44:02 <kolmodin> right, so you need -cpp
03:46:47 <ski> pesco : mhm, ok
03:46:55 * boegel|gf yows
03:47:02 <ski> @yow
03:47:03 <lambdabot> Mmmmmm-MMMMMM!!  A plate of STEAMING PIECES of a PIG mixed with the
03:47:03 <lambdabot> shreds of SEVERAL CHICKENS!! ... Oh BOY!!  I'm about to swallow a
03:47:03 <lambdabot> TORN-OFF section of a COW'S LEFT LEG soaked in COTTONSEED OIL and
03:47:03 <lambdabot> SUGAR!! ... Let's see ... Next, I'll have the GROUND-UP flesh of CUTE,
03:47:03 <lambdabot> BABY LAMBS fried in the MELTED, FATTY TISSUES from a warm-blooded
03:47:05 <lambdabot> [3 @more lines]
03:47:13 <ski> lambdabot : errm, ?
03:48:07 <eivuokko> o.O
03:48:31 <boegel|gf> what do you guys think about dcoutts's proposal to use lambdabot to make the wiki more usefull (i.e. to avoid spam)
03:48:59 * dcoutts thinks it's a good idea
03:49:09 <dcoutts> not just to avoid spam however
03:49:26 <dcoutts> to avoid mistakes
03:49:28 <boegel|gf> for what too then ?
03:49:31 <boegel|gf> hmm, I see
03:49:35 <dcoutts> and to get more contributions
03:49:44 <xerox> How?
03:49:46 <dcoutts> distributed review
03:50:04 <ski> lambdabot reviewing the wiki ?!?
03:50:10 <dcoutts> xerox, the idea is that lambdabot would tell us whenever a wiki page got modified
03:50:15 <xerox> Ooooh.
03:50:24 <dcoutts> with some filtering so we don't get swamped
03:50:36 <eivuokko> Just plain rss-feed support, then?
03:50:42 * ski imagines lambdabot@HOME running in a screen-saver, reviewing the wiki in a distributed way
03:50:45 <xerox> I think it's a good idea.
03:51:02 <dcoutts> yeah, it could be implemented by lambabot polling an rss feed
03:51:14 * gour thinks to turn lambdabot 1st into vegetarian
03:51:18 <dcoutts> that'd give semi-realtime
03:51:37 <sethk> dcoutts, real time non-deterministic sequencing
03:51:51 * gour put some thoughts about wiki etc. to the haskell-list
03:51:58 <soysauce> bleh, why do Haskell arrays allow you to set the lower bound
03:52:14 <boegel|gf> but will we keep reviewing what lambdabot shows us, or will we just get bored after a while ?
03:52:18 <dcoutts> soysauce, generality?
03:52:29 <dcoutts> boegel|gf, I dunno
03:52:33 <soysauce> 0-based arrays are pretty general
03:52:50 <xerox> n-based arrays are more general
03:52:52 <dcoutts> soysauce, it requires a 0
03:53:02 <ski> arrays can be indexed by tuples
03:53:17 <dcoutts> soysauce, Haskell arrays work with any index type, so we don't necessarily know a 0 value
03:53:18 <xerox> forall a. Foo a => a-based arrays okay :P
03:53:23 <ski> and can also be indexed be enumeration types, etc
03:53:25 <soysauce> xerox - they simply arenít. I can do a subtraction myself if I have to.
03:53:42 <xerox> soysauce: listen to dcoutts/ski :)
03:53:48 <soysauce> 95% of the time I want a 0-based array, and the other 5% isnít worth paying a performance penalty and a pain-in-the-arse penalty for the other 95%
03:53:58 <soysauce> dcoutts - ah, I see
03:54:14 <xerox> Num a => (a,a)-indexed arrays make matrices, for example
03:54:55 <dcoutts> soysauce, so it'd be possible to add a zero value to the Ix class, but that's just not the way it was done.
03:54:56 * ski ponders array-indexed arrays .. tensors ?
03:55:09 <jlouis> soysauce: there is no performance penalty if you do it correctly. Pascal has had arbitrary arrars for ages
03:55:16 <jlouis> arrays
03:55:58 <dcoutts> haskell arrays also involve bounds checking so 0-based'ness wouldn't save much
03:56:06 <jlouis> what you need is a specialization to a common case. That should be rather easy to build a module around
03:56:09 <dcoutts> since you'd need to check for >0 anyway
03:56:10 <soysauce> dcoutts - cuts off one comparison
03:56:26 <dcoutts> soysauce, no it cuts off one addition
03:56:36 <dcoutts> soysauce, and you have to do 2 comparisons anyway
03:56:44 <soysauce> no, why would you do 2 comparisons?
03:56:47 <jlouis> unless your bounds check elimination works ;)
03:56:59 <maitscha> hallo, i am new to haskell... i am searching for a way to get the following: list a ["test1", "test2", "test3"] [1,4,2] -> get the element from list a which has the highest value in list b. this means, in list b the value 4 on position 2 is the highest value, so return the element on position 2 of the first list.
03:57:02 <dcoutts> soysauce, you can use unsafe indexing if performance matters, and that is 0-based.
03:57:45 <dcoutts> soysauce, you need tocheck >=minbound and <=maxbound which is 2 compares
03:57:46 <jlouis> @type max
03:57:46 <kaol> maitscha: zip and sort
03:57:47 <lambdabot> forall a. (Ord a) => a -> a -> a
03:58:01 <jlouis> zip, sort, max, etc
03:58:03 <soysauce> dcoutts - thatís the point; with 0-based indexing there is no minbound
03:58:12 <dcoutts> soysauce, yes there is. It's 0.
03:58:17 <jlouis> soysauce: of course there is
03:58:25 <soysauce> yes, conceptually there is
03:58:30 <jlouis> i = -3; a[i]
03:58:30 <dcoutts> soysauce, myarray ! (-1)
03:58:36 <jlouis> boom!
03:58:38 <soysauce> but in implementation the minimum bound is equal to the smallest possible index
03:59:23 <jlouis> you have to bounds check i >= 0 && i < size(a)
03:59:42 <ski> maitscha : what if list b were [1,4,4] ?
03:59:46 <jlouis> unless you can figure out (by data flow analysis and friends) that i always succeeds that test
04:00:05 <soysauce> i < 0 is the same as i > size(a)
04:00:19 <dcoutts> hmm it might be possible to save the min bound comparison as soysauce suggests
04:00:37 <xerox> But's dirty hack
04:00:46 <dcoutts> you convert to unsigned and then compare
04:00:49 <soysauce> not might be possible, it is possible
04:00:53 <soysauce> because I have done it
04:00:55 <dcoutts> so negative values overflow
04:01:07 <ski> (Int is not unsigned ..)
04:01:09 <soysauce> not overflow; they are simply remapped to extremely large positive values
04:01:20 <soysauce> ski - note that signed and unsigned are the exact same thing.
04:01:26 <dcoutts> soysauce, yes, that's what I mean.
04:01:35 <maitscha> ski: that can't be the case
04:01:59 <dcoutts> soysauce, it's a cunning trick. But it can't be done in general for an arbitrary indx type.
04:02:15 <jlouis> Word32 however...
04:02:27 <dcoutts> but it might be possible to do it for the Int case with 0 bounds
04:03:26 <soysauce> dcoutts - arbitrary index types could be mapped onto integers...
04:03:31 <ski> signed is not same as unsigned .. if it were we'd not need two words
04:03:51 <soysauce> I suppose I will simply have to create an array specialization because it is very annoying to get a tuple when I want only the upper bound
04:04:04 <jlouis> ski: oh, -0 ....
04:04:17 * JKnecht sees that Haskell presents unparalleled challenges to the experienced programmer. Experience with relatively exotic languages such as Lisp, Prolog and Smalltalk notwithstanding.
04:04:32 <ski> re _maitscha
04:04:34 <dcoutts> soysauce, right. In the current implementation the bounds check is done in the index type and then gets passed mapped to an integer offset
04:05:11 <ski> (JKnecht : mhm ?)
04:05:14 <soysauce> *nods*
04:05:18 <dcoutts> soysauce, in general it has to be done that way round for higher dimentions arrays, or arrays with holes.
04:05:42 <ski> are arrays with holes allowed ?
04:05:57 <dcoutts> ski, you'd have to use your own Ix type.
04:06:10 <jlouis> soysauce: anyway, the signedness trick is nice. It has been noted here ;)
04:06:12 <_maitscha> ski: i have a list ["bar", "foo"] and a second list [1,5]. I need the element from the first list which has the largest value in the second list, e.a. "foo", because 5 is largest value in the second list and is on position 2.
04:06:14 <dcoutts> ski, bitmaps are often represented as arrays with holds
04:07:06 <_maitscha> i need something to get the position of the largest value of a int-list.
04:07:11 <JKnecht> ski: was my statement unclear?
04:07:17 <ski> @index elemIndex
04:07:17 <lambdabot> Data.List
04:07:26 <ski> @type Data.List.elemIndex
04:07:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
04:07:51 <ski> @type maximum
04:07:52 <lambdabot> forall a. (Ord a) => [a] -> a
04:07:56 <ski> @type (!!)
04:07:57 <lambdabot> forall a. [a] -> Int -> a
04:08:09 <ski> _maitscha : you can use those, e.g.
04:08:39 <ski> (JKnecht : just wondered where the last bit came from ..)
04:10:01 <JKnecht> where it all came from: what I can see of current discussion. Last bit: projection of 'standard HOL' space in context of statement.
04:10:25 <ski> (_maitscha : also, you could use zip and sortBy, as jlouis and kaol mentioned)
04:18:37 <maitscha_> what is, if my prog doesn't recognize the function elemIndex ?
04:18:45 <xerox> @index elemIndex
04:18:46 <lambdabot> Data.List
04:18:54 <xerox> You need to 'import Data.List'
04:19:19 <maitscha_> i have that import: import Data.List (nub)
04:19:31 <xerox> Change it to (nub,elemIndex)
04:19:44 <xerox> It's just an explicit import list
04:19:58 <maitscha_> ok. that worked. thx
04:21:42 <jlouis> Conjure repo updated with a lot of stuff ;)
04:22:39 <boegel|gf> dcoutts: thanks for a link to the HaskLS port :)
04:22:57 <maitscha_> the result of elemIndex is MayBe Int, that is not applicable for (!!). is there a way to use it anyway?
04:23:36 <dcoutts> boegel|gf, if you want the source just ask
04:24:02 <xerox> @type Maybe.fromMaybe
04:24:02 <lambdabot> forall a. a -> Maybe a -> a
04:24:05 <xerox> @type Maybe.fromJust
04:24:06 <lambdabot> forall a. Maybe a -> a
04:24:19 <xerox> > fromMaybe 1 (Just 2)
04:24:20 <lambdabot> 2
04:24:22 <xerox> > fromMaybe 1 (Nothing)
04:24:23 <lambdabot> 1
04:25:06 <boegel|gf> dcoutts, well yeah, I could add it th the HaskLS website, I'm adjusting it as we speak :)
04:26:53 <boegel|gf> dcoutts: cool post on the gtkhs website too ! thanks !
04:26:58 <dcoutts> :-)
04:27:15 <dcoutts> boegel|gf, did you see the video? :-)
04:27:18 <boegel|gf> but I do think you used a too complicated tree as an example :)
04:27:26 <boegel|gf> dcoutts: yeah :)
04:27:30 <dcoutts> yeah it's quite a big one
04:27:33 <dcoutts> 6 iterations
04:27:50 <dcoutts> boegel|gf, you've not implemented the random rule feature
04:28:17 <dcoutts> boegel|gf, so if I have several rules for the same char it should pick the rule to use randomly
04:28:38 <boegel|gf> dcoutts: yeah I know :(
04:29:00 <boegel|gf> dcoutts: so much to do, and so litte time
04:29:03 <dcoutts> http://www.haskell.org/gtk2hs/gallery/Cairo-demo/Cairo_demo_13
04:29:17 <dcoutts> eg xerox get's these pictures by using that technique
04:30:47 <xerox> With the invaluable help of MonadRandom :-D
04:31:04 * dcoutts thinks a monad is not necessary :-)
04:34:04 <boegel|gf> xerox: cool !
04:34:11 <boegel|gf> gotta love it :)
04:34:43 <ski> > fromJust (Just 42)
04:34:45 <lambdabot> 42
04:34:48 <ski> > fromJust Nothing
04:34:48 <lambdabot> Add a type signature
04:34:53 <ski> > fromJust Nothing :: Int
04:34:54 <lambdabot> Maybe.fromJust: Nothing
04:35:12 <ski> > 2 * fromJust (Just 42) :: Int
04:35:13 <lambdabot> 84
04:35:19 <ski> > 2 * fromJust Nothing :: Int
04:35:20 <lambdabot> Maybe.fromJust: Nothing
04:36:08 <xerox> dcoutts, it's a so clean solution.
04:36:16 <xerox> dcoutts, and composable!
04:36:31 <__maitscha> what imports do i need for fromJust?
04:36:38 <xerox> @index fromJust
04:36:39 <lambdabot> Data.Maybe
04:36:40 <xerox> -^
04:37:32 <boegel|gf> dcoutts: can you send the source code to me ?
04:38:11 <maitscha__> erfolgreich s i = s !! fromJust(elemIndex 2 i)
04:38:34 <xerox> Boom boom boom :-)
04:38:46 <ski> maitscha__ : that hardcodes the index to 2 ..
04:38:55 <ski> hm
04:39:02 <ski> bah
04:39:14 <ski> sorry, it hardcodes the value to look for, to 2
04:39:32 <ski> > maximum [1,2,3,48,5,6,72,8]
04:39:33 <lambdabot> 72
04:40:00 <joelr> howd
04:40:02 <ski> > fromJust (elemIndex 72 [1,2,3,48,5,6,72,8])
04:40:02 <joelr> y
04:40:03 <lambdabot> 6
04:40:14 <joelr> any fupdeps experts?
04:41:53 <xerox> Lunch!
04:42:13 <joelr>         (the instance types do not agree with the functional dependencies of the class)
04:42:22 <joelr> how do i fix this?
04:42:25 <ski> which class ?
04:42:41 <joelr> sec
04:42:48 <joelr> class MkCmd k p | k -> p where
04:42:48 <joelr>     mkCmd :: k -> p
04:43:02 <joelr> instance MkCmd CmdType_ (Format p) where
04:43:03 <joelr>     mkCmd k@(CmdConnectGame Client) =
04:43:05 <ski> and which instance (attempt) ?
04:43:07 <ski> ok
04:43:09 <xerox> I think it means you can't have, for class Foo a b | a -> b, both instance Foo Int Int and instance Foo Int Char.
04:43:28 <joelr> i thought that was the whole point
04:43:47 <xerox> If 'a' decides 'b', it goes in one direction
04:43:59 <joelr> ah, so i need a p -> k fundep/
04:44:25 <ski> 'instance MkCmd CmdType_ (Format p)'  implies that e.g.  both 'MkCmd CmdType_ (Format Int)' and 'MkCmd CmdType_ (Format Bool)' is true
04:44:45 <joelr> argh
04:44:49 <ski> the fundep states that each 'p' can only correspnd to at most one 'k'
04:44:57 <ski> (i.e. for each p, unique k)
04:45:03 <joelr> but
04:45:09 <joelr> how does this work then?
04:45:14 <joelr> class (HList l, HList p) => HLPU p l | p -> l, l -> p where
04:45:14 <joelr>     puHList :: p -> PU l
04:45:15 <ski> (umm .. swap p and k, there ..)
04:45:19 <joelr> instance (HList l, HLPU p l) => HLPU (HCons (PU e) p) (HCons e l) where
04:45:20 <joelr>     puHList (HCons pe l) =
04:45:24 <joelr> because it does work
04:45:45 <ski> 'HLPU p l'  says p and l determines eachother
04:45:55 <dcoutts> boegel|gf, sent
04:46:08 <dcoutts> boegel|gf, there's still one segfault I've not tracked down yet.
04:46:17 <joelr> hmm
04:46:20 <ski> so, this instance then says 'HCons (PU e) p' and 'HCons e l' determines each other
04:46:30 <boegel|gf> dcoutts: when does it occur ?
04:46:33 <ski> 'e' is mentioned by both, so there's no problem
04:46:39 <joelr> ski: so in my case can't p and k determine each other?
04:46:58 <ski> joelr : in your can't k doesn't determine p
04:47:19 <joelr> ski: i think i'm getting it... because k is always the same you cannot go from k to p
04:47:27 <ski> (you only had 'k -> p', not 'k -> p,p -> k' so you don't have "eachother" ..)
04:47:28 <joelr> ski: but you can go from p to k, though
04:47:35 <ski> correct
04:47:50 <joelr> ski: because i'm always going from CmdType to Format X
04:47:55 <ski> so, if you had 'p -> k', instead, that instance would work
04:49:13 <joelr> be right back
04:49:23 <dcoutts> boegel|gf, closing the GL window for the second time.
04:50:58 <boegel|gf> dcoutts: hmm, okay, when you solved it, let me know :)
04:52:24 <dcoutts> right
04:58:46 <boegel|gf> dcoutts: where did you mail it to ?
05:00:06 <dcoutts> boegel|gf, see privmsg
05:01:48 <jlouis> @where conjure
05:01:49 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
05:09:46 <boegel|gf> dcoutts: pm
05:10:29 <maitscha1> how do i get the minimum value of a int-list, e.a. [2,1,6,9,2] -> 1
05:11:24 <eivuokko> > minimum [2,1,6,9,2]
05:11:25 <lambdabot> 1
05:13:28 <maitscha1> geringsteStimmen :: [[Int]] -> Int
05:13:28 <maitscha1> geringsteStimmen i = fromJust(elemIndex ((minimum i) i))
05:13:32 <maitscha1> i get a type missmatch
05:13:53 <integral> min [] = error "empty list"; min (x:xs) = let m = min xs in if x < m then x else m
05:16:34 <maitscha1> but i don't understand the error:
05:16:35 <maitscha1> ERROR ".\Aufgabe3.hs":78 - Type error in application
05:16:36 <maitscha1> *** Expression     : minimum i i
05:16:36 <maitscha1> *** Term           : i
05:16:36 <maitscha1> *** Type           : [[Int]]
05:16:36 <maitscha1> *** Does not match : [[[Int]] -> a]
05:18:22 <magagr> shouldn't that be elemIndex (minimum i) i
05:19:05 <dcoutts> boegel|gf, pm?
05:19:40 <magagr> geringsteStimmen i = fromJust(elemIndex (minimum i) i)
05:19:57 <magagr> *t
05:20:04 <lisppaste2> joelr1 pasted "FunDeps" at http://paste.lisp.org/display/13502
05:20:05 <jlouis> he has a gf suffix... he might be ``disturbed'' at times ;)
05:20:17 <joelr1> folks, any idea how to resolve this?
05:20:20 <maitscha1> yes, that worked
05:20:57 <magagr> maitscha1: just a pair of parentheses to much
05:21:33 <boegel|gf> dcoutts: privmsg :)
05:24:13 <jlouis> joelr1: I'd suggest simplifying code
05:24:25 <joelr1> jlouis: in which way exactly?
05:24:59 <joelr1> jlouis: i _need_ to return a generic list (HList ...) because they make my command format
05:25:19 <joelr1> jlouis: i'm just trying to come up with a function that can return any command
05:25:39 <jlouis> you can't change the command format?
05:26:01 <joelr1> jlouis: it's always a different sequence of HCons ... ...
05:26:24 <joelr1> jlouis: i.e. the type is always different. what holds is that each command is Format Props
05:26:42 <dcoutts> boegel|gf, perhaps you've not got your nick registered since I didn't get your message
05:27:00 <boegel|gf> dcoutts: oh :s
05:27:10 <dcoutts> boegel|gf, I got your comment on the web site though :-)
05:27:29 <joelr1> jlouis: ideally, i need a function that given a command type can return the proper Props p => Format p
05:27:41 <boegel|gf> dcoutts: can you try mailing it again, our mail server as a grey listing system which causes problems sometimes
05:27:51 <boegel|gf> well, delays actually
05:28:39 <maitscha1> i have another question: i have lists like [2,3,1], [3,2,1], [5,3,2], [7,3,2], [3,9,1]. now i need to check the first element of the list. if it has an assigned value like '3', i need put this value on the last position of the list. any ideas?
05:29:00 <dcoutts> boegel|gf, sent
05:30:43 <jlouis> joelr1: I can see your problem. But I have nothing in my head clicking regarding how to solve it
05:30:55 <joelr1> jlouis: ok, thanks
05:31:04 <joelr1> dcoutts: can you lend a hand?
05:33:26 <magagr> maitscha1: how 'bout (\i (x:xs) -> if x==i then (xs ++ [x]) else (x:xs))
05:34:31 <dcoutts> joelr1, sorry, I've never taken the time to understand HLists
05:34:36 <gour> boegel|gf: dcoutts, i aproved the comment
05:34:52 <joelr1> dcoutts: it's not an issue of HList, really, it's more an issue of fundeps
05:35:12 <dcoutts> gour, do we use comment approval?
05:35:28 <joelr1> dcoutts: i'm trying to come up with a function that can return different types where a certain property holds for all of these types
05:35:38 <gour> dcoutts: i was not aware of that, but you changed some options when we were attacked with spam
05:36:13 <dcoutts> gour, oh, I thought that was just to hold comments for moderation if they contained urls. That's what I thought I was doing! :-)
05:36:24 <joelr1> Cale: ping
05:37:07 <gour> dcoutts: this is active: Comment author must fill out name and e-mail
05:37:21 <boegel|gf> dcoutts: no mail yet
05:37:37 <dcoutts> boegel|gf, hmm
05:38:33 <gour> dcoutts: so it looks he didn't leave his name (so we can spam him later :-)
05:39:00 <dcoutts> gour, I see
05:39:24 <boegel|gf> dcoutts: it'll arrive eventually :)
05:39:30 <gour> dcoutts: so i see it is reasonable setting if the user is not registered
05:39:55 <dcoutts> gour, thanks
05:41:01 <gour> dcoutts: np, btw i submitted feature request to meld author for adding --output option so it can be used as darcs merger
05:41:12 <dcoutts> gour, cool
05:41:23 <gour> dcoutts: maybe you can add a comment ;)
05:41:50 <gour> dcoutts: however, he won't write a darcs plugin, so if you have some student hacker to write it
05:42:01 <gour> dcoutts: bzr & mercurial are ~4k
05:42:03 <dcoutts> joelr1, is your fundep the right way round? p->k ?
05:42:28 <joelr1> dcoutts: i think so, because i'm always going from CmdType to Format Props1, Props2, etc.
05:42:34 <dcoutts> gour, yeah, some darcs user/dev will need to write the meld plugin.
05:42:50 <joelr1> dcoutts: so k does not uniquely determine p
05:44:56 <gour> dcoutts: http://bugs.gnome.org/show_bug.cgi?id=321290
05:46:26 <dcoutts> gour, we'll see what the meld guy thinks.
05:46:59 <gour> dcoutts: droundy on #darcs gave me an idea to check something
05:48:20 <dcoutts> I've generally found the meld author to be prety responsive to suggestions
05:49:43 <lisppaste2> joelr1 pasted "FunDeps, no HList" at http://paste.lisp.org/display/13503
05:50:06 <joelr1> dcoutts: here's a much simplified example. it does not involve HList and i cannot figure it out
05:53:36 <dcoutts> joelr1, it's the 'p' bit that doesn't work.
05:53:48 <joelr1> dcoutts: it surely looks like it
05:54:00 <dcoutts> joelr1, the type says you're defining an instance for any p
05:54:11 <dcoutts> but the implementation says it's for a specific p
05:55:03 <lisppaste2> joelr1 annotated #13503 with "A more complete example" at http://paste.lisp.org/display/13503#1
05:55:22 <joelr1> dcoutts: this paste works and you can call foo and bar
05:55:48 <dcoutts> joelr1, that would make sense
05:55:50 <joelr1> dcoutts: but i want to have a generic baz that can return either foo or bar depending on its arguments
05:56:16 <dcoutts> joelr1, though they are different types
05:56:32 <joelr1> dcoutts: well, they are both Format Props
05:56:36 <joelr1> dcoutts: or am i missing something?
05:56:53 <dcoutts> joelr1, then jsut include the whole type in the instance
05:56:53 <joelr1> dcoutts: does this call for existential types?
05:57:01 <dcoutts> joelr1, that's another possability
05:57:21 <joelr1> dcoutts: i can't do that (include the whole type) as it will lead to duplication of a bunch of code
05:57:27 <joelr1> well, i can do it but i don't want to
05:57:57 <dcoutts> then you need to make the 'p' not a parameter of the Format type
05:58:03 <dcoutts> possibly by using exestentials
05:58:08 <joelr1> dcoutts: imagine that i have 100 of these foo and bar. i would need to add 100 type signatures. then again, i'm compiling with -Wall so it will complain
05:58:13 <joelr1> dcoutts: how would i do that?
05:58:28 <dcoutts> you probably don't want to use exestentials
05:58:38 <joelr1> dcoutts: it will complain unless i make mkCmd part of a class or something like that
05:58:47 <dcoutts> you probably need to know the full type
05:59:03 <joelr1> dcoutts: but why not use existentials?
05:59:15 <dcoutts> because you'll find it hard to get the data out
05:59:42 <joelr1> dcoutts: the other missing bit is that i'll have a send function that should take any command and serialize it
05:59:58 <dcoutts> once you wrap it up in an existential you can't assume that 'p' has any particular type which will make traversing your HLists rather hard.
05:59:59 <joelr1> dcoutts: so long as the command is Format Props i can walk it
06:00:17 <dcoutts> joelr1, no you need to know the exact type to be able to walk it.
06:00:20 <joelr1> dcoutts: well, right, that's why p has to be Props
06:00:44 <joelr1> dcoutts: but i see where you are leading
06:01:00 * dcoutts wonders where he is leading
06:01:14 <joelr1> because in mkFmt i'm passing the type in and returning the same type
06:01:52 <joelr1> dcoutts: by the same token mkCmd would need a type to return it
06:02:11 <joelr1> dcoutts: unless, as you said, i instantiate it for each particular type
06:02:46 <dcoutts> which is probably the best you can do
06:03:02 <dcoutts> I would have avoided HLists entirely of course :-)
06:03:11 <joelr1> dcoutts: do you normally have type signatures for all your functions in production code?
06:03:18 <dcoutts> joelr1, yes I do
06:03:32 <joelr1> dcoutts: i tried to avoid HLists but... my code was spending 50% of the time collecting garbage with regular lists
06:03:55 <dcoutts> joelr1, GC will be the same with HLists. The runtime representation is the same,
06:04:18 <joelr1> dcoutts: my command layout / packet format is dynamic in that i associate the type of each field with the serializer
06:04:34 <dcoutts> what's the difference between nested tuples and a list of the same length?
06:04:45 <dcoutts> they have different types
06:04:58 <dcoutts> but they have equivalent representations
06:05:07 <joelr1> dcoutts: hmm
06:05:21 <dcoutts> they have the same number of indirections etc
06:05:34 <dcoutts> the same number of heap allocated bits
06:05:36 <joelr1> dcoutts: i think the difference will be in how my parser code is implemented
06:05:49 <joelr1> the pickling and unpickling
06:05:59 <dcoutts> HLists give you greater static guarantees
06:06:04 <dcoutts> but make coding much harder
06:06:48 <joelr1> dcoutts: i think .... i might be stupid
06:07:21 <joelr1> see
06:07:22 <joelr1> cmdProps (CmdTableInfo ServerTourney) = [ gameStartupInfo := [],
06:07:22 <joelr1>                                           tourType := TourNone ]
06:07:36 <joelr1> this is how i used to describe commands before
06:07:49 <dcoutts> right
06:07:54 <joelr1> data Prop = forall a b. (Eq a, Eq b, Show a, PU b, Convertible a b)
06:07:54 <joelr1>     => Attr a b := a
06:07:54 <joelr1>        deriving (Typeable)
06:08:00 <joelr1> and
06:08:00 <joelr1> data Attr a b = Attr String
06:08:00 <joelr1>     (a -> Dynamic, Dynamic -> Maybe a)
06:08:00 <joelr1>     (a -> b, b -> a)
06:08:25 <joelr1> so i would iterate through the format list to build the command representation
06:08:31 <dcoutts> yes
06:08:43 <joelr1> somehow that generated a lot of garbage. with HList i'm building a closure
06:08:53 <dcoutts> I don't know that you need Dynamic
06:09:05 <joelr1> dcoutts: dynamic is for assignments
06:09:44 <dcoutts> we use that [ .. := .. ] style in Gtk2Hs but there's no need for Dynamic
06:09:44 <lisppaste2> joelr1 annotated #13503 with "getprop" at http://paste.lisp.org/display/13503#2
06:09:58 <joelr1> dcoutts: i took that style from wxHaskell
06:10:09 <joelr1> dcoutts: take a look at the paste for getprop
06:10:21 <dcoutts> http://haskell.org/gtk2hs/darcs/gtk2hs/glib/System/Glib/Attributes.hs
06:10:27 <joelr1> i need to make sure that you are extracting the prop into the right Haskell type
06:10:34 <dcoutts> joelr1, yeah, and wxHaskell doesn't use Dynamic either
06:10:49 <joelr1> whereas wxHaskell and, probably, GtkHs go to C variables, etc.
06:11:11 <joelr1> dcoutts: once you build a attr := val you cannot peek inside
06:11:16 <joelr1> dcoutts: for type
06:11:32 <dcoutts> the ( := ) is the action itself
06:11:37 <joelr1> so you do need dynamic to make sure the type you are assigning to matches what's in Prop
06:11:43 <dcoutts> so there's no need to look inside
06:11:48 <dcoutts> each one is a well typed action
06:11:54 <joelr1> well, i do need to look inside later on
06:11:56 <dcoutts> like picking/serialisation etc
06:11:57 <joelr1> that's the whole thing
06:12:10 <joelr1> dcoutts: wait
06:12:22 <joelr1> do you mean you are reusing := for different purposeS?
06:12:41 <joelr1> i.e. if i have a list of := and need to serialize, how would i do it without getting at the value inside?
06:13:08 <dcoutts> look at the set function
06:13:11 <dcoutts> http://haskell.org/gtk2hs/darcs/gtk2hs/glib/System/Glib/Attributes.hs
06:13:20 <dcoutts> we pattern match on the (:=)
06:13:35 <dcoutts> to get the value on the left an right hand sides
06:13:42 <dcoutts> then apply one to the other
06:13:53 <dcoutts> with the object as an extra parameter
06:14:08 <joelr1> dcoutts: that is all fine but
06:14:10 <dcoutts> so the setter *is* the picling/serialisation function
06:14:18 <joelr1> you are assigning to the C type using the getter/setter
06:14:30 <joelr1> wheras i'm keeping the values within haskell
06:14:37 <dcoutts> no we're calling well typed setter functions
06:14:41 <dcoutts> which are implemented in Haskell
06:14:53 <dcoutts> (which then do FFI, but that's not relevant)
06:15:18 <joelr1> dcoutts: hmm
06:15:23 <dcoutts> we are nto assignign to C variables, we're callign complex functions which do things
06:15:50 <dcoutts> most but not all of them happen to do FFI, but that's not relevant here
06:16:37 <dcoutts> do you need this cunning [ := ] stuff anyway?
06:16:51 <dcoutts> what's wrong with a simple Haskell record + a serialisation function
06:16:58 <joelr1> dcoutts: hard on users
06:17:17 <dcoutts> what users?
06:17:36 <joelr1> dcoutts: i'm not convinced re: the getters/setters, etc. they do use FFI but i just want to keep values in a haskell structure
06:17:43 <joelr1> dcoutts: users of my "scripting language"
06:17:55 <dcoutts> ok
06:18:05 <joelr1> dcoutts: it's easier for them to work with := the way it makes it easier for people to work with GtkHs
06:18:12 <dcoutts> right
06:18:17 <joelr1> dcoutts: which is why i tried to mirror the approach
06:18:28 <dcoutts> so what are the command objects used for?
06:18:43 <joelr1> they are serialized into binary packets that are sent to the c++ server
06:18:46 <michael> hellow
06:18:47 <joelr1> and received from it
06:18:51 <dcoutts> nothing else?
06:19:23 <joelr1> dcoutts: nothing else. apart form inspecting them, updating them and doing different actions depending on the values inside
06:19:36 <dcoutts> I'd just go with Haskell records.
06:19:42 <dcoutts> one per type of command
06:19:46 <dcoutts> with well typed fields
06:19:56 <dcoutts> and then use a class for serialising
06:20:06 <dcoutts> you can then use Haskell record syntax
06:20:07 <joelr1> dcoutts: don't want to. makes it hard. to wit, with prop lists i can supply default values and let users set just the ones they care about
06:20:12 <joelr1> dcoutts: cannot do that with haskell records
06:20:16 <dcoutts> you can do that too
06:20:25 <dcoutts> devaultValue { fieldA = ... }
06:20:43 <joelr1> dcoutts: i would need a default value function for that, no? one that returns a well-populated record
06:20:48 <dcoutts> just modifies that field and leavs all others as in devaultValue
06:20:51 <dcoutts> that's right
06:21:01 <dcoutts> you could make it an member of the command class
06:21:04 <joelr1> dcoutts: plus, suppose i have command A and B and they both have a id
06:21:20 <dcoutts> they would get differnt field names
06:21:36 <joelr1> dcoutts: precisely but they are the same, so they names should be the same
06:21:39 <jlouis> can't you just cook it down to data Command = A ... | B ... ...
06:21:44 <joelr1> it's easy of programming vs. ease of using
06:21:51 <dcoutts> if you want to share names then it has to be a single command dat type
06:21:54 <joelr1> i'm trying to make it easy to use
06:21:59 <dcoutts> with multiple cases
06:22:02 <joelr1> and it cannot be a single command type
06:22:04 <joelr1> lets backtrack
06:22:06 <dcoutts> because?
06:22:11 <joelr1> to prop lists in GtkHs
06:22:39 <dcoutts> prop lists in Gtk2Hs actually modify things
06:22:40 <joelr1> dcoutts: how can i have getters and setters store values in a Haskell structure?
06:22:45 <jlouis> module Data.PropList (...) where
06:23:44 <jlouis> you of course get all the typing problems ;)
06:23:50 <dcoutts> joelr1, it's the getting that's hard there
06:23:50 <joelr1> dcoutts: without using Dynamic
06:24:00 <dcoutts> you could use setters ok
06:24:15 <joelr1> dcoutts: i don't think it can be done without Dynamic which is why i was using Dynamic
06:24:20 <dcoutts> hmm
06:24:43 <jlouis> joelr1: let me get this straight: You actually want some kind of runtime type identification?
06:24:46 <joelr1> dcoutts: this way i could always make sure i was extracting the proper value. at runtime of course.
06:25:15 <joelr1> jlouis: no, i want ... what dcoutts has in GtkHs, the same way of describing my commands but without using FFI
06:25:35 <dcoutts> joelr1, ok there's another style
06:25:51 <dcoutts> you have a data type for fields in a record
06:26:03 <dcoutts> then a record is jsut a list of these things
06:26:09 <dcoutts> each field is well typed
06:26:23 <dcoutts> and you can get and set them
06:26:36 <joelr1> dcoutts: not following you in the big scheme of things. how can i get and set them using the := notation?
06:27:13 <dcoutts> you can't get usign that notation, we use 'get propname'
06:27:27 <joelr1> dcoutts: ok, set is fine
06:27:28 <dcoutts> and 'set [ propname := value ]'
06:27:45 <joelr1> dcoutts: how can i have data in haskell records and use your set notation to update it?
06:27:56 <joelr1> dcoutts: to update a particular field
06:28:13 <dcoutts> first define the fields data type, eg data Field = Identifier String | ...
06:28:50 <joelr1> dcoutts: a giant one? or just one data (newtype) per field?
06:28:50 <zagrius> How do I divide an Int by 100.0 and be able to return the result of that to a function which expects a double as its first argument?
06:29:14 <joelr1> dcoutts: i would much prefer one newtype per field
06:29:17 <dcoutts> zagrius, convert the int to a double first using fromIntegral
06:29:33 <dcoutts> joelr1, that might also be possible with more type class hackery
06:29:46 <xerox> zagrius: foo x = f (x / 100)
06:29:52 <joelr1> dcoutts: ok, and what then? after i defined, say, a giant field data type
06:30:02 <xerox> zagrius: foo x = f (fromIntegral x / 100), sorry
06:30:13 <dcoutts> the attributes are a pair of getter setter fucntions
06:30:20 <joelr1> dcoutts: it's 252 field types, btw
06:30:27 <dcoutts> which add the field to the list
06:30:35 <joelr1> dcoutts: i don't even know if ghc can cope with 252 constructors
06:30:36 <dcoutts> or search the list to see if it's present
06:30:40 <dcoutts> joelr1, it can
06:31:04 <joelr1> dcoutts: the attributes of what are getter/setter, sorry?
06:31:22 <dcoutts> the attribute is itself a getter and a setter for that field
06:31:42 <joelr1> dcoutts: ok
06:31:46 <joelr1> and then?
06:31:59 <joelr1> dcoutts: a giant pattern match for :=?
06:32:04 <jlouis> if you have 252, consider autogenerating them
06:32:19 <dcoutts> joelr1, no, there's no giant pattern match
06:32:51 <joelr1> dcoutts: ok, i think i'm starting to follow
06:32:52 <joelr1> so
06:33:01 <joelr1> data Field = Identifier a
06:33:02 <dcoutts> the set function applies the := setters
06:33:11 <dcoutts> giving a list of Fields
06:33:30 <joelr1> then i would have Field := value so i would need to use x := Indentified a
06:33:32 <joelr1> right?
06:33:50 <dcoutts> you don't expose the field constructors necessarily
06:33:55 <dcoutts> you use the attribute
06:34:00 <paolino> sorry if I reask yesterday question .In this instance 'distance is valid for every Num' can I declare it for 'Num a' instead of 'Float' ?
06:34:02 <dcoutts> which is the getter + setter
06:34:02 <paolino> instance Groupable Float where
06:34:03 <paolino>   distance x y = abs $ x - y
06:34:21 <joelr1> dcoutts: but how do i define the getter and setter?
06:34:35 <dcoutts> data Attr a = Attr !([Field] -> a) !(a -> Field)
06:34:42 <ibid> paolino: instance Num a => Groupable a where?
06:34:45 <dcoutts> joelr1, the setter jsut appens the field
06:34:56 <dcoutts> joelr1, the getter searches for the field
06:35:02 <joelr1> i see
06:35:09 <joelr1> dcoutts: no dynamic needed, right
06:35:13 <dcoutts> right
06:35:20 <dcoutts> (the getter probably returnes a suitable default value if the field is not in the list)
06:35:53 <joelr1> dcoutts: hmm... is that substantially better than using Dynamic? is there a large overhead for Dynamic to convert values/
06:36:04 <dcoutts> reasonably large yes
06:36:09 <joelr1> because maybe that's where my 50% garbage collection is coming from
06:36:13 <zagrius> xerox: I get No instance for (Fractional Int)
06:36:43 <zagrius>  arising from use of `/' at
06:37:19 <ibid> zagrius: let me guess: you should replace the / with `div` or `quot`
06:37:22 <ibid> @type quot
06:37:23 <lambdabot> forall a. (Integral a) => a -> a -> a
06:37:44 <dcoutts> identAttr = Attr (\cmd -> head [ s | Identifier s <- cmd ] ) Identifier
06:37:57 <paolino> ibid right but distance signature in Groupable class is   distance :: a -> a -> Float
06:37:59 <joelr1> dcoutts: what's that?
06:38:19 <dcoutts> joelr1, it's the implementation of an attribute
06:38:24 <dcoutts> for a field Identifier
06:38:51 <joelr1> dcoutts: i'm stupid, where the getter and setter?
06:38:53 <ibid> paolino: then you need to change that for it to work, or you need to make distance return Float
06:38:58 <joelr1> dcoutts: ah
06:39:02 <dcoutts> joelr1, the setter is Identifier
06:39:02 <joelr1> the constructor is the setter
06:39:09 <dcoutts> the getter is (\cmd -> head [ s | Identifier s <- cmd ] )
06:39:20 <paolino> ibid there is no fromNum function
06:39:47 <dcoutts> joelr1, in reality you'd not use head but a function which returned a default value if there were no Identifier field present
06:40:14 <ibid> paolino: ok, then your fuction does not work for all Num. may be it works only for Real?
06:40:15 <paolino> ibid and abs returns a Num ..
06:40:21 <dcoutts> joelr1, case [ s | Identifier s <- cmd ] of { (s:_) -> s; _ -> defaultValue }
06:40:38 <paolino> for Fractionals
06:40:50 <ibid> @type abs
06:40:51 <lambdabot> forall a. (Num a) => a -> a
06:41:02 <joelr1> dcoutts: do you think it's worth using a map to back up a record? instead of a list of fields
06:41:12 <ibid> paolino: no, it returns the same type you give as input, see above
06:41:25 <dcoutts> joelr1, yeah maybe if your records are typically large
06:41:40 <joelr1> dcoutts: they are nested, although not all of them are large
06:41:42 <dcoutts> joelr1, for small sets (eg up to 10 members) lists will be faster
06:42:00 <zagrius> Where can I learn about the numeric tower of Haskell?
06:42:04 <joelr1> dcoutts: they are deeply nested in typical c++ fashion
06:42:08 <paolino> ibid do I have to correct the Groupable signature ?
06:42:29 <ibid> paolino: i'm not sure what you really intend it to do, so i can't say
06:42:29 <joelr1> dcoutts: records with pointers to other records where fields are lists of other records
06:42:52 <dcoutts> joelr1, I would just model it directly with Haskell records.
06:43:05 <dcoutts> but it's your thing of course
06:43:24 <joelr1> dcoutts: i would if i could have id for different records :)
06:43:39 <joelr1> but ... i guess i could model fields as classes, right?
06:43:47 <dcoutts> yes
06:43:50 <joelr1> and then instantiate fields for each record
06:43:50 <paolino> ibid no I want a distance to be rigidly a Float
06:44:01 <dcoutts> but you loose the builtin record update syntax
06:44:29 <joelr1> dcoutts: hmm...
06:45:14 <dcoutts> joelr1, if I were doing it, I'd just suffer the fact that it must be fooId, barId etc for different ones that have an id member
06:45:15 <joelr1> dcoutts: i could define the getter and setter for each field, right?
06:45:35 <dcoutts> joelr1, yes, one attribute per field
06:45:48 <joelr1> dcoutts: wait, lets explore this a little bit... suppose i had a class IdField where ...
06:45:48 <dcoutts> and then you can hide the Field data constructors
06:46:09 <dcoutts> joelr1, yeah that'll work fine for accessing the record
06:46:12 <joelr1> and would have := to set the value and something to get the calue
06:46:20 <paolino> ibid there is anything from Fractionals to Float ?
06:46:29 <joelr1> and i could even provide a default implementation for the getter, right? which would give me the default value
06:47:02 <joelr1> dcoutts: the question is how would i 1) specify the order of fields in a record and 2) update a record
06:47:52 <joelr1> dcoutts: can i bring in haskell records somehow?
06:48:09 <dcoutts> yes, haskell records will allow you to describe an order
06:48:22 <dcoutts> the list of fields will make that harder
06:48:29 <joelr1> dcoutts: hmm... records where each field is an attribute... but then i'm back to square one because i cannot have the same name :)
06:48:48 <dcoutts> you really really can't have the same name?
06:49:02 <zagrius> What is wrong with this: f = (fromIntegral 4::Int) / 100.0 ?
06:49:05 <joelr1> dcoutts: i thought i would model a record as two maps, one for field name to field position and another one for position to attribute
06:49:05 <ibid> @type fromReal
06:49:06 <lambdabot> Not in scope: `fromReal'
06:49:09 <ibid> k√§√§
06:49:20 <joelr1> dcoutts: i cannot. makes for poor usability
06:49:31 <xerox> > fromIntegral (4 :: Int) / 100
06:49:32 <lambdabot> 4.0e-2
06:49:37 <xerox> > fromIntegral (4 :: Int) / 100 :: Float
06:49:38 <lambdabot> 4.0e-2
06:49:42 <dcoutts> joelr1, it'd be much easier to implement that way.
06:49:45 <joelr1> dcoutts: from the user prospective. think of having different id name for each widget ;)
06:49:51 <ibid> > fromIntegral 4 :: Int / 100.0
06:49:51 <lambdabot>  parse error on input `100.0'
06:49:58 <ibid> > (fromIntegral 4 :: Int) / 100.0
06:49:59 <lambdabot>  add an instance declaration for (Fractional Int)
06:50:00 <dcoutts> joelr1, we use inheritance
06:50:01 <xerox> zagrius: that is, fromIntegral 4 is not an Int
06:50:02 <joelr1> dcoutts: like treeId, textFieldId, windowId
06:50:02 <ibid> :)
06:50:14 <ibid> xerox: it could be
06:50:16 <joelr1> dcoutts: you wouldn't do it this way, right? i'm in the same boat
06:50:24 <xerox> ibid: sure
06:50:30 <xerox> @type fromIntegral
06:50:31 <lambdabot> forall b a. (Num b, Integral a) => a -> b
06:50:36 <joelr1> dcoutts: but what you are proposing is exactly that scheme.
06:50:36 <dcoutts> joelr1, I did do it that way for a network protocol program
06:50:54 <joelr1> dcoutts: i would do it this way too if i was the only user.
06:51:03 <zagrius> xerox: I don't follow you. Could you explain what's wrong with it?
06:51:10 <joelr1> dcoutts: but i'm selling haskell as a simple scripting language ;)
06:51:57 <xerox> zagrius: (blah blah blah .. :: Type) makes 'Type' be the type of the whole expression.  So you're trying to put an Int as first argument of (/).
06:52:07 <dcoutts> joelr1, and all the fields with the same name mean the same thing and have the same type?
06:52:16 <joelr1> dcoutts: precisely
06:52:42 <joelr1> dcoutts: which is why i thought of having one attribute per field and modeling fields as classes with a getter and setter
06:52:52 <paolino> zagrius, :: is very weak in precedence
06:52:57 <xerox> zagrius: that is, (f 1 :: Int) means that the result of applying 'f' to '1' is an Int, while f (1 :: Int) means that you're passing a value of type Int to 'f'.
06:53:32 <zagrius> xerox: it works :)
06:53:32 <dcoutts> joelr1, well that'll work. But then you don't have much of a static guarantee on the structure of records
06:53:40 <xerox> zagrius: 'it' being what?
06:53:54 <joelr1> dcoutts: what do you mean by that? and do i actually need such a guarantee?
06:53:58 <joelr1> for example
06:54:07 <joelr1> this is how users send a command right now
06:54:32 <joelr1> send $ make (CmdLogon Client) [ name := botName,
06:54:32 <joelr1>                                        password := botPass,
06:54:32 <joelr1>                                        affiliateID := botAFFID ]
06:55:07 <joelr1> dcoutts: so to make a command they give me the command id (CmdLogon Client) and a list of attributes which i apply to the list returned by cmdProps (CmdType)
06:55:13 <zagrius> xerox: Hmm, no it (being my little program) doesn't when I add a few lines that use the result.
06:55:20 <joelr1> dcoutts: then i serialize the list
06:55:47 <zagrius> xerox: I will make a minimal example.
06:55:49 <dcoutts> joelr1, but there's no guarantee that the attributes are appropriate to the kind of command
06:56:19 <joelr1> dcoutts: no guarantee
06:56:36 <dcoutts> then the lsit of fields would be the same
06:56:41 <joelr1> dcoutts: but that's a minor inconvenience since make will return the full list of fields for this command in proper order
06:56:54 <dcoutts> ok
06:57:07 <dcoutts> using Haskell records would give such static guarantees, but maybe that's not important
06:57:12 <joelr1> dcoutts: what i do need to do is go through the list of props supplied by the user and apply them to the default list of fields to update it
06:57:27 <dcoutts> joelr1, right
06:57:33 <paolino> @type (:=)
06:57:35 <lambdabot> Not in scope: data constructor `:='
06:57:37 <joelr1> dcoutts: if they screw up and give me the wrong fields then i do not apply them since i would not find them
06:58:11 <zagrius> xerox: I found the problem. It seems that I had *another* argument which also expected a Double but was given an Int.
06:58:17 <zagrius> xerox: thanks
06:58:27 <SamB> paolino: := is used for properties in a few systems
06:58:35 <joelr1> dcoutts: i'm wondering, thouugh, if nested lists are a good backend for a record, vs. a map or something else
06:58:40 <SamB> such as wxHaskell
06:58:48 <joelr1> dcoutts: but i'm a learned man now. i know how to use the memory profiler :D
06:58:49 <jlouis> oy SamB
06:58:59 <SamB> jlouis: hi
06:59:08 <SamB> @dict
06:59:08 <lambdabot> Supported dictionary-lookup commands:
06:59:08 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
06:59:08 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
06:59:08 <lambdabot> Use "@dict-help [cmd...]" for more.
06:59:21 <jlouis> Pull conjure, I've updated with a lot of things a couple of hours ago ;)
06:59:37 <joelr1> dcoutts: so what i'll do is scrap the HList stuff, fork a copy of my original darcs repo that the HList redesign was forked from
06:59:39 <SamB> cool
06:59:59 <SamB> I hope you did some work on the Store ;-)
07:00:01 <joelr1> dcoutts: apply the new serialization and remove the Dynamic and see what happens :)
07:00:18 <dcoutts> joelr1, good luck
07:00:22 <jlouis> SamB: unfortunately not ... (yet, hehe)
07:00:26 * joelr1 high-fives dcouts
07:00:33 <joelr1> thanks duncan
07:00:45 <SamB> in this "Speling and module locations for the BEncode port", did you intentionally misspell spelling?
07:00:46 <jlouis> The Store is the next target
07:00:54 <jlouis> SamB: sure did ;)
07:01:12 <jlouis> s/port/part/ though. That was not intentional ;)
07:01:14 <dcoutts> joelr1, just be careful if you're borrowing LGPL code and it's a comercial project you're working on
07:01:40 <joelr1> dcoutts: i'm borrowing the concept but not the code
07:01:46 <dcoutts> joelr1, thats ok
07:01:49 <joelr1> dcoutts: i.e. the concept of attributes
07:01:55 <dcoutts> yes, that's fine
07:02:03 <joelr1> ok
07:06:44 <SamB> jlouis: why are we stealing lambdabots config stuff?
07:06:49 <SamB> Isn't that GPL'd?
07:07:05 <jlouis> config stuff?
07:07:15 <jlouis> we are not stealing the config stuff
07:07:22 <jlouis> we are stealing the makefile stuff
07:07:27 <SamB> autocrap stuff
07:07:33 <jlouis> yup
07:07:37 <SamB> thats what I meant
07:07:53 <jlouis> If its GPL'd, its dead
07:07:56 <JKnecht> autocrap=autotools(gnu)?
07:07:58 <SamB> doesn't lambdabot still have its config file written in Haskell
07:08:00 <SamB> ?
07:08:08 <SamB> JKnecht: yes, exactly
07:08:49 <SamB> "compromises by far"?
07:09:04 <SamB> compromising the build environment would be a *bad* thing...
07:09:34 <jlouis> haha
07:09:40 <jlouis> I am the serious typo kinf
07:10:12 <JKnecht> geez I hope Haskell doesn't become computing reference case of the best becoming the enemy of the good. 'specially before it really is the best.
07:10:27 <SamB> I suppose you meant "comprises most of"?
07:10:55 <SamB> JKnecht: what do you mean by "the best" and "the good"?
07:11:28 <jlouis> SamB: yeah
07:11:55 <JKnecht> by 'good' I meant autotools and the little thrill I get everytime I run './configure' on a new free package and it works right ...
07:12:02 <SamB> anyway, I think we usually go with the good, unless we have figured (and implemented) the best. except in key situations, where adopting the good would make it harder to adopt the best.
07:12:13 <jlouis> JKnecht: autoconf is certainly not the way to build software in the long run. But it is better than most other attempts I've seen
07:12:18 <ibid> autotools and good are an oxymoron
07:12:38 <stigmaata> :Clear
07:12:42 <stigmaata> hi
07:13:01 <SamB> JKnecht: well, try dealing with autotools themselves and you'll know what we are talking about
07:13:17 <JKnecht> I have.
07:13:24 <lkrt> Visual Studio project files are the answer.
07:13:32 <JKnecht> OK, point.
07:13:58 <JKnecht> Actually that is the point, i.e. the price of freedom.
07:14:03 <SamB> configure scripts are all well and good, but writing everything in M4 and breaking everything every other major revision is not really that great.
07:14:16 <JKnecht> And the fact that the autotools developers aren't anybodies wage slaves.
07:14:52 <SamB> I suppose they are getting better about that, though
07:15:33 <SamB> but really, how many decades have they been at it and it is still such a mess now?
07:15:37 <jlouis> There are 2 ways you can configure software to the operating system environment: Autocrap and ''build-for-one-platform-then-provide-porting-workarounds''
07:15:58 <thebug> still, whoever originally wrote autotools needs to burn in hell
07:16:07 <vegai> how about "write 100% portable code"?
07:16:16 <Oejet> *coughJavacough*
07:16:21 <jlouis> vegai: that is an impossibility
07:16:23 <thebug> ever try running auto* stuff on anything other than linux, bsd, or cygwin? *BANG* DEAD
07:16:27 <vegai> jlouis: is it?
07:16:35 <SamB> Oejet: that is not going to work
07:16:48 <lkrt> It's about time you start porting your platform to my software!
07:16:51 <jlouis> vegai: kqueue/sendfile versus that linuxthingiforgotitsname
07:17:03 <SamB> vegai: thats okay for a lot of things, until there is something you need to do that isn't strictly portable for one reason or another
07:17:07 <thebug> IRIX is a great example, almost no autotools-based stuff runs on it happily
07:17:17 <xerox> Nymphaea compiled on windows without any modification in the sources :-)  (which was entirely developed on linux.)
07:17:18 <vegai> jlouis: oh, you mean that it is not possible under Linux. Ok, that might be.
07:17:23 <jlouis> different APIs for the same thing.
07:17:32 <xerox> It's true, indeed, ask dcoutts! :-)
07:17:53 <Oejet> SamB: Yeah, Java is only as portable as it's virtual machine. :-/
07:18:04 <JKnecht> not even.
07:18:10 <jlouis> thebug: autotools merely provide you with the possibility of porting the software. It doesn't provide you the solution to run on IRIX
07:18:14 <vegai> plan9 userspace is compiled from one tree that contains no #ifdefs or configure scripts
07:18:23 <SamB> jlouis: you have to admit that you can do a lot of things in Haskell without using nonportable modules
07:18:43 <lkrt> How well does the Plan 9 userland compile for VMS?
07:18:44 <jlouis> SamB: yup. Indeed!
07:18:45 * xerox boings randomly
07:18:46 <SamB> vegai: thats because they put the arch-specific code in different directories
07:18:47 <thebug> jlouis: I'm not saying that it's the software that is broken
07:18:54 <vegai> lkrt: dunno, but it does build for several architectures.
07:18:55 <thebug> it's *autotools* that is broken
07:19:14 <SamB> lkrt: you need to use plan9-ports for that
07:19:15 <vegai> SamB: actually, the put arch-specific code in a special library, afaik
07:19:18 <joelr1> dcoutts: ping
07:19:27 <SamB> I dunno if it works on VMS or not
07:19:37 <dcoutts> joelr1, yarr!
07:19:37 <thebug> but of course it's a moot point, since the GNU zealots will all keep using autotools 'til the sun dies out
07:19:44 <jlouis> ok, guys, I named it autocrap for a reason. Rip out the autocrap from conjure and provide a clean gmake-patch without autocrap and its in the tree at once ;)
07:19:48 <vegai> but anyway, does it matter how they do it? ;)
07:19:55 <joelr1> dcoutts: so something like tihs, right? class Field a where
07:19:55 <joelr1>     set :: a -> Field a
07:19:55 <joelr1>     get :: a
07:19:55 <joelr1>     pickler :: PU a
07:20:01 <jlouis> i'll even add a TODO item for it
07:20:18 <joelr1> dcoutts: how do i make this into an attribute, though, without using existentials?
07:20:42 <joelr1> dcoutts: or should i use existentials and not care because i have a getter and setter?
07:20:43 <dcoutts> joelr1, I think Field needs to be a data type so you can have a list of them and pattern match on it
07:21:09 <joelr1> dcoutts: i would instantiate the data types from Field, at least i thought that's the way to do it
07:21:29 <joelr1> i.e. instance Field Int, etc.
07:21:32 <joelr1> err
07:21:37 <JKnecht> I agree there's no need to use autotools if it's causing more problems that benefit. Hardly a low population space (build tools), only need use one that will deliver a working install pkg.
07:21:40 <joelr1> data MyField = MyField Int
07:21:47 <joelr1> instance Field MyField where ...
07:22:05 <dcoutts> joelr1, the getter I wrote relied on being able to pattern match to extract the field from the list of fields
07:22:12 <lkrt> Autotools isn't doing anything for anybody.
07:22:23 <lkrt> Damn GNU zealots.
07:22:25 <lkrt> Heh.
07:22:38 <zagrius> Isn't using the State monad a slow solution when you thread all your state through it?
07:22:39 <JKnecht> anyway should this be in the darcs purview?
07:22:51 <JKnecht> s/should/shouldn't/
07:22:57 <dcoutts> lkrt, Gtk2Hs uses autotools quite sucessfully however I wouldn't reccomend it as a nice solution.
07:23:06 <lkrt> I was being sarcastic.
07:23:10 <lkrt> It's humor.
07:23:14 <jlouis> ok, i'll correct myself, linux has sendfile, but with different semantics. You need to use the TCP_CORK option on the TCP fd
07:23:18 <vegai> Autotools is dark humor.
07:23:29 <jlouis> FreeBSD has sendfile, but it takes an optional header and footer
07:23:30 <xerox> @yow
07:23:31 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO
07:23:31 <lambdabot> he
07:23:31 <lambdabot> is ...
07:23:57 <jlouis> hi ber
07:24:01 <jlouis> hi xerox
07:24:08 <dcoutts> joelr1, that getter implementation would not work if it was a Field class
07:24:09 <xerox> hey hey!
07:24:16 * jlouis goes away from the keyboard a bit to get his typing better
07:24:19 <joelr1> dcoutts: so it's data Field = huge list of constructors. how do you make that into an attribute with a setter and a pickler?
07:24:37 <joelr1> hmm... stupid question
07:24:39 <dcoutts> joelr1, yes data Field = huge list of constructors.
07:24:50 <dcoutts> joelr1, then one attribute per constructor
07:25:01 <joelr1> idAttr = ... as you said
07:25:06 <jlouis> the point is... if we use sendfile(2), then we can spend as many cycles in userland as we want (almost)
07:25:07 <dcoutts> the constructers themselves need not be exported
07:26:19 <joelr1> dcoutts: is there are more elegant way of supplying a default value?
07:27:13 <dcoutts> joelr1, the use of case can obviously be abstracted
07:28:08 <dcoutts> (\cmd -> defalt theDefault [ i | Identifier i <- cmd ] )
07:28:11 <joelr1> dcoutts: the default value can be another field in the attribute, i think
07:28:32 <dcoutts> ah, then perhaps the defaults should be done as adifferent phase
07:28:56 <joelr1> dcoutts: wasn't there a way to supply a default value in the list comprehension? for when a value is not found in the list?
07:29:09 <dcoutts> yes that's just what I was saying
07:29:12 <zagrius> Isn't using the State monad a slow solution when you thread all your state through it?
07:29:39 <xerox> I don't think so zagrius
07:29:42 <SamB> zagrius: depends.
07:30:00 <lisppaste2> SamB pasted "what is this, if linux doesn't have sendfile?" at http://paste.lisp.org/display/13506
07:30:04 <joelr1> dcoutts: do you remember off the top of your head how to do it?
07:30:29 <joelr1> oh, wait
07:30:43 <dcoutts> joelr1, case [ s | Identifier s <- cmd ] of { (s:_) -> s; _ -> defaultValue }
07:30:46 <joelr1> dcoutts: the list comprehention will return an empty list if the value is not found, right?
07:30:51 <dcoutts> yes
07:30:56 <SamB> I translated the GC'd unlambda interpreter into Haskell using StateT Char IO, and it ran faster than the original...
07:31:04 <JKnecht> or actually I guess Cabal purview.
07:32:03 <SamB> oh, I missed the discussion about sendfile because I was too busy pasting the stub :-(
07:32:31 <joelr1> dcoutts: wouldn't [ ... ] `mplus` [default value] work just the same?
07:33:03 <dcoutts> [ ... ] ++ [default value]
07:33:13 <dcoutts> head ([ ... ] ++ [default value])
07:33:20 <dcoutts> yeah
07:33:27 <joelr1> dcoutts: why not mplus?
07:33:45 <dcoutts> whichever
07:33:50 <joelr1> ok :)
07:34:36 <zagrius> SamB: E.g. for keeping a real-time game state?
07:34:54 <joelr1> thanks duncan
07:35:16 <SamB> zagrius: well, if your state values get too big then you spend a lot of time allocating them, probably...
07:36:09 <zagrius> SamB: and an alternative is to use a MArray?
07:36:48 <SamB> zagrius: if all you want is an array, you could look into DiffArray or DiffUArray
07:37:06 <SamB> those use a mutable array internally, but present a pure interface
07:37:40 <zagrius> SamB: I don't say I want an array, I want to know how I keep state best(read fast).
07:38:38 <joelr1> how do i plug strictness annotation in here?/
07:38:39 <joelr1> data PU a = PU { appP :: (a, [Word8]) -> [Word8],
07:38:39 <joelr1>                  appU :: [Word8] -> (a, [Word8]) }
07:39:01 <joelr1> for appP and appU
07:39:34 <SamB> joelr1: I don't believe you can.
07:39:51 <joelr1> so only in this notation? data Shape = Circle !Int !Int !Colour | Square !Int !Colour
07:39:55 <joelr1> wierd then
07:40:52 <SamB> joelr1: well, the thing is, those are functions. you can't make functions strict by type signature alone.
07:41:30 <joelr1> so i suppose i would need to make the separate functions ... no problem
07:41:32 <joelr1> works the same
07:42:48 <joelr1> data Attr a = Attr !([Field] -> a) !(a -> Field) !(PU Field) !a
07:42:48 <joelr1> getter :: Attr a -> ([Field] -> a)
07:42:48 <joelr1> setter :: Attr a -> (a -> Field)
07:42:49 <joelr1> that type of thing
07:42:53 <joelr1> right?
07:43:34 <jlouis> hehe SamB, ill just comment on it..
07:43:50 <SamB> joelr1: that doesn't make the functions strict
07:44:15 <joelr1> SamB: i don't need to make the functions strict :) just the "fields in my record"
07:44:33 <joelr1> SamB: i was just wondering if there was a way to combine the two bits
07:45:01 <SamB> well, probably!
07:45:19 <lisppaste2> jlouis annotated #13506 with "Clarification" at http://paste.lisp.org/display/13506#1
07:47:53 <SamB> joelr1: yeah, you can just do
07:48:02 <joelr1> SamB: just do ... ?
07:48:15 <SamB> data PU a = PU { appP :: !(a, [Word8]) -> [Word8],
07:48:15 <SamB>                  appU :: ![Word8] -> (a, [Word8]) }
07:48:34 <joelr1> SamB: excellent, thank you very much!
07:49:12 <SamB> its right there in "4.2.1  Algebraic Datatype Declarations"
07:49:21 <SamB> if you look at the grammar
07:51:43 <jlouis> SamB: its good if you know things about the linux semantics. I am sorely lacking in that department, trust me
07:53:47 <SamB> jlouis: is the manpage insufficient?
07:53:48 <JKnecht> actually cabal does apparently subsume autotools: http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#system-dependent .
07:54:15 <SamB> JKnecht: we know! notice how hmp3 uses autoconf?
07:54:51 * Cale works at reducing orphaned wiki pages
07:55:06 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage_2fQCExts_2ehs -- hmm, this is neat, it should be moved somewhere
07:55:37 <jlouis> SamB: the man page is ok. But sometimes the names are different
07:56:08 <SamB> actually, doesn't.
07:56:40 <xerox> Cale, the wiki fairy :-)
07:56:46 <xerox> Err.. elf! ;-)
07:56:53 <Cale> heh
07:57:15 <Cale> xerox: http://vx.hn.org/autoshare/Cabal-With-Text-Light-Dark.png -- the latest edition, btw
07:57:38 <xerox> arf arf!
07:57:52 <xerox> Now unveil the secret about the very good looking logo :-)
07:58:35 <SamB> jlouis: I suppose sendfile might be nice, but I think we should be concentrating on getting it to work before bothering about sendfile.
07:59:34 <Cale> hmm, secret? I suppose I put a good lot of work into getting the character outlines to look balanced, and there's a neat little tie in between the first a and b. The "box" has angles which are mildly suggestive of a lambda.
07:59:49 <SamB> though it wouldn't hurt for FS.Storage to offer a function with a sendfile-like interface
07:59:50 <JKnecht> samb: is there an URL for hmp3?
07:59:59 <SamB> @where hmp3
07:59:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
08:00:11 <JKnecht> thx.
08:00:19 <SamB> thats a darcs repo
08:02:19 <JKnecht> samb: must be brand new. Are you Don?
08:02:22 <jlouis> SamB: I agree. I'll take an attack on the Store next
08:02:47 * Cale considers designing a complete typeface based on this Cabal logo :)
08:03:00 <jlouis> without sendfile. That is performance optimization. I just used it as an example why you need some kind of portability layer
08:03:03 <SamB> JKnecht: no! my name is Sam
08:03:08 <SamB> Don is dons
08:03:09 <Cale> Now that would chew up time :)
08:03:20 <SamB> JKnecht: yes, it is brand new
08:03:28 <jlouis> where is the cabal logo?
08:03:45 <SamB> a few days ago he was looking for a curses-based MP3 player that didn't crash a lot
08:03:45 <joelr1> is there a way to do this?
08:03:46 <joelr1> data Field = DealID Word64 | HandNumbers [DealID Word64]
08:03:58 <SamB> he was asking if anyone had done one in Haskell
08:04:28 <SamB> couple nights ago he was asking for people to try hmp3 ;-)
08:04:32 <jlouis> and since the answer was no, and dons is dons, he built one ;)
08:04:48 <SamB> joelr1: um. what?
08:04:50 <zagrius> Cale: how(program) did you make that?
08:05:20 <joelr1> SamB: well, you know, a Field is either a Word64 (deal id) or HandNumbers which is a list of deal ids
08:05:35 <joelr1> i guess not but i thought i would ask
08:05:49 <SamB> how about
08:05:54 <SamB> type DealID = Word64
08:06:07 <SamB> data Field = DealID DealID | HandNumbers [DealID]
08:06:30 <Cale> zagrius: Inkscape
08:06:41 <joelr1> SamB: that works, thanks. let me check a more complex example...
08:09:33 <jlouis> 50698 jlouis      4  20    0   137M   112M kserel  23:55  0.00% python
08:09:42 <jlouis> we have to beat that ;)
08:10:00 <SamB> jlouis: for what torrent?
08:10:12 <jlouis> bittorrent, 3 or so torrents at once
08:10:15 <zagrius> Cale: It's too bad the output file isn't vector based.
08:10:27 <SamB> for what 3 torrents?
08:10:28 <Cale> it is
08:10:34 <Cale> I have an SVG
08:10:41 <jlouis> mapping 112Mb as the RES set is awfully big
08:10:53 <zagrius> Cale: but we have a lack of browsers handling them...
08:11:23 <Cale> zagrius: yeah -- there is an SVG plugin for Mozilla/Firefox, but it's pretty weak
08:12:45 <dcoutts> Cale, mozilla/firefox do svg natively, no plugin required.
08:12:57 <SamB> I don't suppose you can use profiling to find bugs?
08:13:19 <SamB> I mean, like so you could profile the number of times some event happened?
08:13:37 <SamB> (in a number of different contexts)
08:13:50 <Cale> dcoutts: hmm, last time I tried, it couldn't. I know that they were working on something to that effect
08:14:25 <dcoutts> Cale, it's not necessarily compiled in by default. But in future it will be turned on by default.
08:37:16 <mkoebele> hi
08:37:34 <mkoebele> sorry to bug you, but I cannot configure the ghc-6.4.1 package
08:37:50 <mkoebele> configure aborts with the message:
08:37:51 <mkoebele> checking for hbc... no
08:37:52 <mkoebele> configure: error: GHC is required unless bootstrapping from .hc files.
08:38:10 <mkoebele> how do I proceed here?
08:39:07 <dcoutts> mkoebele, get a binary version of ghc
08:39:34 <mkoebele> dcoutts: can't find one for SuSE 10 :/
08:39:43 <mkoebele> dcoutts: I had success compiling it for SuSE 9.2 though
08:39:49 <dcoutts> the generic binary version will be ok
08:40:03 <mkoebele> ok
08:40:14 <mkoebele> dcoutts: but why does configure complain?
08:40:34 <dcoutts> because you've downloaded the source version
08:40:38 <dcoutts> and that needs ghc
08:40:47 <mkoebele> oh, I need ghc to compile ghc?
08:40:51 <dcoutts> yes
08:41:19 <dcoutts> hence the need for the binary version
08:41:34 <mkoebele> I see
08:41:37 <mkoebele> thanks
08:41:42 <dcoutts> np
08:45:51 <paolino> is it possible to  import from a subdirectory ?
08:46:09 <xerox> Subdirectory.Module
08:46:43 <paolino> must be uppercase ?
08:47:06 <xerox> I think so.
08:47:15 <paolino> k
08:47:18 <dcoutts> mdoule names start with upper case
08:47:26 <xerox> It didn't get in my way, it's just a good naming convention - I think.
08:47:39 <paolino> and subdirs ?
08:47:51 <xerox> Too.
08:47:54 <dcoutts> paolino, alternatively use just import Module and use ghc -i subdir
08:48:17 <dcoutts> -i sets the ghc module search path
08:50:27 <paolino> mmhh , the modulename in the file must be Subdir.Module then ?
08:51:30 <xerox> No
08:51:32 <xerox> Just 'Module'
08:52:47 <paolino> well it doesn't compile without that Subdir. in front :/
08:53:24 <xerox> O_o
08:54:54 <paolino> and after that all mdules in Subdir dir must import peers with Subdir. in front of them !
08:55:06 <dcoutts> you jsut need to use ghc -i subdir
08:55:14 <paolino> k
08:55:21 <dcoutts> it will work, many projects use that style
08:55:50 <dcoutts> if it's not working for you, paste your command line and perhaps we'll see what's wrong
08:57:24 <SamB> paolino: well, it isn't really that bad... but I suppose that isn't very comforting if you wanted it the other way ;-)
08:57:45 <SamB> personally I hate playing "guess the subdir"
08:58:40 <paolino> SamB so ?
08:59:11 <SamB> I mean, I like the heirarchical style myself ;-)
09:00:13 <SamB> though it would work better if emacs would select the whole dotted modulename when you double click on it...
09:00:22 <paolino> SamB that means you will never get to load a module from its dir if it's a subdir
09:01:15 <paolino> well maybe with the -i option ...
09:01:56 <SamB> paolino: no, I mean I *like* having modulenames like FS.Store for FS/Store.hs
09:02:40 <zagrius> I am a bit new to Haskell, but don't you have editor support for that?
09:02:50 <zagrius> s/to/too
09:03:16 <paolino> dcoutts, 175> ls
09:03:17 <paolino> Cluster.hs  Clusters/   Groupables/ Lib/        Tests/      junk/
09:04:03 <paolino> 176> ghc -i Lib -fglasgow-exts
09:04:04 <paolino> ghc-6.4: file `Lib' does not exist
09:04:30 <Lemmih> -iLib
09:05:11 <Lemmih> And you need more than that.
09:05:31 <SamB> zagrius: we have editor support for Haskell, but that doesn't mean we get to selected dotted module names by double clicking!
09:05:45 <SamB> no, wait, we do
09:05:59 <SamB> maybe support, maybe not...
09:05:59 <paolino> 178> ghci -iLib -fglasgow-exts Clusters/DistributionCluster.hs
09:06:12 <SamB> but it doesn't work in X-Chat
09:06:12 <paolino> ./Lib/Distribution.hs: file name does not match module name `Distribution'
09:06:21 <SamB> or is that xterm
09:06:24 <SamB> xterm it is
09:06:30 <SamB> paolino: it works if you say
09:06:47 <SamB> "module Lib.Distribution" at the top
09:06:59 <SamB> er, don't forget the "where" though
09:07:14 <zagrius> SamB: I haven't seen anything besides Emacs haskell mode and some alpha version of an Eclipse plugin.
09:07:37 <SamB> zagrius: oh, well, we've got an IDE in the works
09:07:37 <Lemmih> SamB: But that's what we're trying to avoid.
09:07:42 <SamB> but it doesn't work to well yet
09:07:48 <paolino> Lemmih :)
09:08:14 <SamB> well, yeah, I got that, but I don't understand why people so dearly want to avoid that!
09:08:21 <zagrius> SamB: oh cool.
09:12:37 * SamB tries building it
09:14:18 * SamB needs newer gtk2hs
09:14:23 * SamB pulls patches
09:18:19 <dcoutts> SamB, the released 0.9.10 version is ok for hIDE. You don't need the latest darcs version.
09:18:42 <dcoutts> the development version is likely to have more bugs :-)
09:19:08 <SamB> dcoutts: well, what patches should I unpull to aproximate 0.9.10?
09:19:41 <dcoutts> all the ones back to the point where the patch that bumps the version number :-)
09:23:23 <SamB> done
09:25:06 <Frederick> yo SamB
09:25:52 <SamB> I actually have stuff to do, I shouldn't really be here...
09:26:04 <Frederick> ehehe
09:26:10 <Frederick> Cale, yo
09:29:40 <Frederick> SamB, you said I should use from list to handle my parsing Ive googled and found this http://pleac.sourceforge.net/pleac_haskell/hashes.html I think it is the way to go
09:33:20 <phys_rules> hey everyone ;)
09:36:17 <Frederick> SamB, are you gone?
09:36:42 <ulfdoz> If the answer is yes, he lies. :)
09:37:20 <Frederick> ulfdoz, yups
09:38:06 <Frederick> guys I need some help in from lsit here -> http://paste.lisp.org/display/13513
09:38:54 <Frederick> I know how to iterate over a given list but how can I make that after parsing a list component against a patter I maybe will want to add it to another list
09:39:58 <Frederick> btw this list is inside a map
09:41:55 <Frederick> oh folks never mind my mom called me! I must help her :p be back later :)
09:41:56 <Frederick> cya
09:47:48 <maitscha> hallo, i have a question: i have a function reihenFolgeStimmzettel :: [Int] -> Int -> [Int] which is called from within a map. how is it possible to give more the one parameters to a function which is executed with a map?
09:50:37 <ulfdoz> maitscha: You need to curry it.
09:54:01 <SamB> jlouis: are you still around?
09:54:20 <SamB> you seem to have forgotten to add FS.Piece to the repo
09:54:39 <maitscha> ulfdoz: what does this mean?
09:54:50 <SamB> @where conjure
09:54:50 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
09:56:36 <ulfdoz> maitscha: currying means to make a function, taking more than one argument to taking only one argument.
09:57:14 <maitscha> do you mean to overgive the values within a tupel?
09:57:53 <SamB> @type curry
09:57:54 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
09:57:58 <SamB> @type uncurry
09:57:59 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
09:58:32 <ulfdoz> maitscha: No, I think this explains it quite good: http://en.wikipedia.org/wiki/Currying
09:58:53 <SamB> you want the uncurry function, methinks...
10:06:12 <maitscha> hmmm... I doesn't understand it how to do it.
10:06:55 <SamB> > map (uncurry (*)) [(1, 2), (3, 4)]
10:06:56 <lambdabot> [2,12]
10:08:07 <ibid> i always make the mistake of writiing that as map ((*) . uncurry) ...
10:08:19 <ibid> which, of course, is total bullcrap
10:08:25 <joelr1> Cale: ping
10:14:14 <joelr1> .
10:15:12 <SamB> @type map ((*) . uncurry)
10:15:13 <lambdabot> forall a b c.
10:15:13 <lambdabot> (Num ((a, b) -> c)) =>
10:15:13 <lambdabot> [a -> b -> c] -> [((a, b) -> c) -> (a, b) -> c]
10:15:32 <SamB> total bullcrap, but still valid haskell!
10:15:57 <SamB> which is why strategically placed type sigs are such a good idea
10:16:28 <vegai> I bet that gives a massively informative type error when used in real code
10:16:57 <SamB> vegai: well, probably massive at least
10:17:03 <vegai> > map ((*) . uncurry) [(1,2), (3,4)]
10:17:04 <lambdabot> Couldn't match `a -> b -> c' against `(a1, b1)'
10:17:15 <SamB> that isn't very useful
10:17:36 <vegai> @vixen You should try harder!
10:17:37 <lambdabot> whoa whoa whoa, one question at a time!
10:17:45 <vegai> Gah.
10:49:19 <ibid> SamB: well, i don't usually use (*) in that mistake :)
10:50:02 <xerox> macro postfix:<!> ($x) {
10:50:03 <xerox>   [*] 1..$x
10:50:03 <xerox> } # yay to perl6.
10:52:44 * fworp designed himself a haskell t-shirt on zazzle.com, got it in the mail today, and realized, its got a type error in it
10:53:00 <xerox> This is fun, haha, any url to show it off?
10:53:01 <kombinator> sometimes I'm missing "Perl cookbook" equivalent for haskell...
10:53:40 <fworp> ive got the image still i think
10:53:53 <xerox> I want an HM-tshirt!
10:55:17 <ibid> hmm, i should have made a HM shirt and wore it on my first functional programming 1 lecture :)
10:55:44 <ibid> (with the added text, "if you don't get this, you need to learn it")
10:55:49 * ibid is so mean to his students
10:56:49 <ibid> now, if i had had sense yesterday, i'd have removed two or three of the next week's exercises and upgraded the others
10:56:54 <ibid> but it's set in stone now
10:57:17 * ibid imagines the student evaluation he'll be getting at the end of this course...
10:57:18 <SamB> @where HM shirt
10:57:19 <lambdabot> I know nothing about hm.
10:57:22 <SamB> @where HM-shirt
10:57:22 <lambdabot> I know nothing about hm-shirt.
10:57:29 <fworp> http://img.zazzle.com/img/43E33933-F380-4ACA-8154-B10E837F81D4/pre_sz325_qt80.jpg theres the image on the back of the shirt
10:58:14 <ibid> @google HM shirt
10:58:15 <lambdabot> http://www.mitchellandness.com/detail.aspx?ID=5932
10:58:24 <xerox> ibid: please ping me if you find one :-)
10:58:34 <SamB> fworp: next time, load your shirt up in to GHCi *before* having it printed
10:58:41 <fworp> :P yeah
10:58:45 <ibid> istr seeing one a few years ago mentioned here
10:58:55 <ibid> how does one load a t-shirt?
10:59:00 <xerox> @remember SamB fworp: next time, load your shirt up in to GHCi *before* having it printed
10:59:03 <ibid> :load /dev/thshirt
10:59:05 <ibid> ?
10:59:16 <xerox> ibid: nah, you import it.
10:59:35 <qwerty-> hello, anybody know if there's a way to use fromInt in GHC?
10:59:51 <xerox> qwerty-: it's called fromIntegral
10:59:55 <ibid> xerox: import /dev/tshirt?
11:00:02 <SamB> ibid: well, if it is a Haskell program, its not terribly hard
11:00:04 <xerox> ibid: err O_o as you wish
11:00:18 <qwerty-> xerox this converts from type Integral, not Int
11:00:27 <ibid> qwerty-: Integral is not a type
11:00:34 <xerox> qwerty-: Integral is a class whose instance are Int and Integer
11:00:34 <ibid> qwerty-: Int is an Integral
11:00:36 <qwerty-> hmm it's not?
11:00:39 <qwerty-> ah
11:00:48 <xerox> qwerty-: try :info Integral in the GHCi prompt.
11:00:54 <SamB> there are other instances, many other instances...
11:00:56 <qwerty-> <- newbie in haskell :/
11:01:04 <xerox> qwerty-: you're very welcome here!
11:01:08 <mwc> qwerty-: think of Integral as being a set of types which behave like integers
11:01:32 <mwc> class is kind of an overloaded term in programming
11:01:57 <SamB> you've got your Int, your Word, your {Int,Word}{8,16,32,64}, your Integer, your PortNumber...
11:02:05 <qwerty-> yeah, i have an idea what classes are, we just did them this week in lecture
11:02:49 <dcoutts> qwerty-, which uni is that?
11:02:52 <qwerty-> so if x is an Int, how would i go about getting the expression (360 / x) to return a Float?
11:03:00 <qwerty-> uni of edinburgh
11:03:04 <SamB> well, you can't.
11:03:13 <SamB> you have to use a different expression ;-)
11:03:16 <qwerty-> i mean how should i modify it
11:03:17 <qwerty-> yeah :)
11:03:18 <mwc> qwerty-: you want to do 360.0 / fromInteger(x)
11:03:29 <mwc> er, fromIntegral
11:03:49 <qwerty-> woohoo!
11:03:51 <mwc> qwerty-: integers only have integer division defined
11:03:53 <qwerty-> it worked :)
11:04:04 <dcoutts> mwc, don't confuse the beginners with unnecessary brackets! :-) : 360.0 / fromIntegral x
11:04:12 <qwerty-> thank you all so much, i've been trying to figure that out for 2 hours :)
11:04:26 <mwc> dcoutts: sorry, I've been forced to write for-loops lately
11:04:33 <dcoutts> qwerty-, fromInt used to exist in an earlier version of Haskell
11:04:49 <dcoutts> qwerty-, so lots of old textbooks talk about it
11:04:49 <qwerty-> np with the brackets, i understand the syntax quite well :)
11:05:06 <dcoutts> mwc, heh, poor you.
11:05:07 <qwerty-> yeah i read about that googling for a solution
11:05:17 <mwc> don't google, hoogle
11:05:38 <dcoutts> @hoogle Int -> Double
11:05:38 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
11:05:43 <dcoutts> hmm
11:05:46 <mwc> dcoutts: the status of the darwin port of gtk2hs is that it's in a long line of things that are blocked because of the brokenness of X11 Mozilla/Firefox on darwin
11:05:52 <ibid> i've told my students that doing f(x) makes them look like newbies :)
11:06:05 <dcoutts> ibid, quite right :-)
11:06:06 <ibid> (which they obviously are, but nobody wants to look like one:)
11:06:09 <qwerty-> <- puts this channel in Favorites
11:06:14 <takuan_dozo> is there an easy fix around the problem with writing the following?
11:06:16 <takuan_dozo> map (/(length [1])) [1,2]
11:06:29 <qwerty-> thanks again guys
11:06:30 <dcoutts> mwc, that's a shame. Thanks for the update.
11:06:41 <ibid> > map (/(length [1])) [1,2]
11:06:41 <lambdabot>  add an instance declaration for (Fractional Int)
11:06:47 <xerox> dcoutts, It rhymes ! ;-)
11:06:50 <dcoutts> mwc, ping me when there's a package to link to on the gtk2hs web site
11:07:13 <ibid> takuan_dozo: ah. are you really intending to have the result be a floating-point number?
11:07:14 <dcoutts> xerox, what rhymes?
11:07:16 <mwc> dcoutts: wilco
11:07:20 <takuan_dozo> ibid: absolutely
11:07:35 <SamB> f> map (/ fromIntegral (length [1])) [1,2]
11:07:38 <xerox> dcoutts: shame/update, in some sense O_o  nevermind :-)
11:07:42 <SamB> > map (/ fromIntegral (length [1])) [1,2]
11:07:43 <lambdabot> [1.0,2.0]
11:07:45 <takuan_dozo> ah
11:07:47 <takuan_dozo> yup
11:08:10 <SamB> > map (`div` (length [1])) [1,2]
11:08:10 <dcoutts> xerox, it doesn't rhyme in my language :-)
11:08:11 <lambdabot> [1,2]
11:08:25 <xerox> dcoutts, a lil bit, no? :)
11:08:31 <SamB> > map (`mod` (length [1])) [1,2]
11:08:32 <lambdabot> [0,0]
11:08:34 <ibid> dcoutts: i told them the same thing when they asked if they could avoid the indentation by using {;} :)
11:08:40 <takuan_dozo> thanks
11:08:40 <dcoutts> xerox, no. sorry.
11:08:49 <dcoutts> ibid, ha!
11:08:52 <Heffalump> Igloo: you about?
11:08:58 <Igloo> Yes
11:09:05 <xerox> dcoutts, it's not about the words, but your phrase
11:09:08 <Heffalump> have you seen bugs like http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=336396 ?
11:09:18 <xerox> 'intonation' ?
11:09:19 <ibid> dcoutts: hm?
11:09:53 <dcoutts> ibid, I think you're telling them the right thing.
11:09:58 <ibid> good:)
11:10:06 <xerox> Heffalump: haha.
11:10:17 <dcoutts> ibid, btw if you want to go 3D for next year's FP practical:
11:10:17 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/11/more-opengl-goodness/
11:10:24 <ibid> dcoutts: they are also complaining that my exercises are too hard (which they probably are)
11:10:47 <ibid> dcoutts: opengl doesn't work out-of-the-box like 2d stuff does
11:10:52 <Igloo> Heffalump: The next ghc should have kfreebsd-i386 in its list of arches, so rerunning update-haskell-control should fix that
11:10:56 <Heffalump> oh, I'm confused. update-haskell-control should pick it up if I have a new ghc6.
11:10:59 <dcoutts> ibid, that's true, it can be problematic
11:11:00 <Heffalump> yeah.
11:11:02 <Igloo> But it's begin held up by build-deps of ghc6
11:11:11 <Heffalump> oh, is that not in sid yet?
11:11:15 <dcoutts> ibid, I've found that mine is going ok, it's a bit hard for some but others are getting onto the optional parts already.
11:11:26 <Heffalump> or do you just mean that it's held up on kfreebsd-i386?
11:11:35 <Igloo> It is, but xmltex is broken, so the new ghc6 wouldn't be buildable
11:11:39 <ibid> dcoutts: one of next week's exercises is to draw a binary tree given as a parameter
11:11:50 <dcoutts> ibid, interesting
11:12:12 <SamB> ibid: are they allowed to use cairo?
11:12:34 <Heffalump> ok, but updating will at least fix the reported bug, which is the missing arch.
11:12:37 <ibid> SamB: unspecified. why?
11:12:55 <ibid> SamB: what i'm officially telling them to use is JyuGraphics
11:13:23 <SamB> oh, so they aren't expected to use the ASCII-art method that is so popular?
11:13:27 <Igloo> Nothing would really be fixed
11:13:32 <ibid> SamB: no
11:13:41 <SamB> @where JyuGraphics
11:13:42 <lambdabot> I know nothing about jyugraphics.
11:13:46 <SamB> @google JyuGraphics
11:13:47 <lambdabot> http://www.mit.jyu.fi/antkaij/opetus/fo/2005-2006/luennot/1-1/JyuGraphics.hs
11:13:58 <ibid> SamB: JyuGraphics is an adaptation of dcoutts' reimplementation of SOEGraphics
11:14:01 <dcoutts> @google Gtk2Hs SOE
11:14:03 <lambdabot> http://haskell.org/gtk2hs/archives/2005/11/01/university-courses-using-gtk2hs-for-teaching/
11:14:45 <jlouis> @where fastpackedstring
11:14:45 <lambdabot> I know nothing about fastpackedstring.
11:14:48 <jlouis> bleh
11:14:55 <dcoutts> @where fps
11:14:56 <Heffalump> well, it'd be fixed in the sense of "you say kfreebsd-i386 is missing from the list, I've addedit"
11:14:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:14:57 <SamB> jlouis: get my patch?
11:15:14 <SamB> which adds the file you forgot to add, magically containing the contents of your file?
11:15:38 <SamB> (actually, I grabbed it with links -source)
11:15:53 <jlouis> http://www.cse.unsw.edu.au/~dons/code/fps/
11:16:00 <jlouis> SamB: 2 sec, applying ;)
11:17:32 <jlouis> SamB: fixed, thanks
11:22:24 <SamB> jlouis: cool
11:22:50 <jlouis> I've downloaded FPS from dons. GPL... ARGH!
11:23:08 <SamB> argh indeed.
11:23:30 <jlouis> and not LGPL, we have a slight problem there
11:23:38 <SamB> however, remember, that doesn't GPL our code. it just means we have to provide sources for any binaries linked to FPS we may provide
11:24:38 <jlouis> It can be accepted
11:26:38 <SamB> our code can still be freely copied, pasted, and cp'd, which is the important thing ;-)
11:27:00 <Heffalump> igloo/any other debian developer: don't suppose you understand what's going on in the failed build log in http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=325427 ? I can't reproduce the problem myself.
11:39:49 <Igloo> Heffalump: You've applied the patch, right?
11:40:59 <Heffalump> no, I want to understand what the problem that it fixes first..
11:41:11 <Igloo> The problem is building the package with patch AIUI
11:41:26 <Igloo> Oh, no
11:41:49 <Heffalump> the patch is supposed to be a fix.
11:41:58 <Igloo> I misread it, sorry
11:42:01 <Heffalump> I could just apply it anyway, I guess, but I'd like to understand the problem.
11:42:11 <Igloo> It could be you have different debhelper versions
11:42:17 <Heffalump> Running: cp .installed-pkg-config
11:42:17 <Heffalump> debian/tmp/usr/lib/haskell-packages/ghc6/lib/HTTP-0.4/installed-pkg-config
11:42:19 <Heffalump> cptchaos: cannot create regular file
11:42:26 <Heffalump> s/cptchaos/cp/ # silly irssi
11:42:30 <Igloo> Fixing the deprecated warnings might fix it
11:42:31 <Heffalump> seems to be the first failure
11:42:46 <Heffalump> I've just updated to 5 and it's still not breaking (without the patch)
11:43:23 <Igloo> It could be it has created the tree under debian/haskell-http rather than debian/tmp but something is using the old place because of the old debhelper version
11:43:55 <Heffalump> does the patch improve the structure of debian/rules anyway?
11:44:28 * Heffalump isn't really sure either way
11:44:39 * Igloo doesn't know off-hand
11:45:01 <Heffalump> ok. I think I'll ask if it's fixed without it first.
11:45:46 * Heffalump tries to remember what was going on with 315333. I remember there was a real problem but the report was very confused.
11:48:48 <Cale> hmm, I wish there was a way to get a list of pages which link to a given page on the wiki
11:49:01 <mwc> We oughta write a replacement wiki in Haskell
11:49:18 <mwc> mod_haskell anybody? :P
11:49:23 <Cale> :)
11:49:41 <mwc> nah, if I was gonna do it, I'd look at hooking haskell up to the fastcgi interface
11:49:51 <Cale> There are some webservers written in Haskell, I think
11:49:53 <mwc> Maybe I will look into it, after this weekend from hell
11:50:00 <Cale> and a wiki too
11:50:12 <mwc> Well, I like lighttpd very much
11:50:15 <mwc> so that's my pet
11:52:51 <Cale> still trying to de-orphan pages
11:54:15 <mwc> sounds like not fun
11:54:21 <araujo> Hello Haskell¬ø'ers!
11:55:10 <araujo> Hello Haskell'ers!
11:55:17 <Cale> Hello araujo
11:55:20 <ibid> 'ello
11:55:21 <araujo> :-)
11:55:39 <SamB> araujo: what a decidedly odd typo!
11:56:55 <mwc> I figured it for some south american regional encoding weirdness
11:57:18 <araujo> hah, it wasn't "decidedly" :-]
11:57:47 <araujo> It is the opposite of the charracter '?'
11:58:15 <mauke> U+00BF (194 191): INVERTED QUESTION MARK
11:58:15 <mwc> You mean ? upside down?
11:58:18 <mwc> ah
11:58:21 <Cale> ¬ø
11:58:34 <Cale> <Compose> ? ?
11:58:40 <araujo> Yes.
11:58:54 <araujo> ¬ø What ?
11:59:05 <mauke> ø
11:59:07 <jlouis> n
11:59:08 <araujo> That'd be the spanish way of asking something.
11:59:26 <Cale> ¬°¬ø What ?!
11:59:35 <araujo> Right.
11:59:44 <Cale> I wonder if there's an inverted interrobang
12:00:01 <mauke> haha
12:05:37 <SamB> @unicode interrobang
12:05:37 <lambdabot> Unknown command, try @listcommands.
12:27:38 <xerox> ‚ÄΩ
12:32:09 <ibid> ainoa interrobang joka unicodesta l√∂ytyy on se tavallinen
12:32:13 <ibid> k√§√§k
12:32:29 * ibid doesn't notice writing in the wrong language anymore
12:32:31 <xerox> ibid: teach us a cool word in your language :-D
12:32:47 <ibid> "the only interrobang that one can find in unicode is the usual one"
12:32:50 <Frederick> ibid, wich is your language?
12:32:53 <ibid> xerox: the above had several:)
12:32:54 <ibid> finnish
12:33:33 <xerox> :-)
12:33:39 * ibid is effectively bilingual now, even though my english vocabulary still sucks compared to my finnish one
12:33:50 <ibid> but i'm writing my nanowrimo novel in english
12:34:01 <JKnecht>  /quit FC4 install.
12:34:09 <JKnecht> \quit FC4 install.
12:34:13 <Oejet> Haha.
12:34:21 <Oejet> JKnecht: You will never escape.
12:34:47 <ibid> welcome the new world, the old world
12:34:57 <xerox> He closed the window hehe
12:35:25 <ibid> thehe
12:35:30 <Oejet> Hihihaha.
12:35:44 <ibid> cue evil laughter
12:36:43 <ibid> (http://www.nanowrimo.org/userinfo.php?uid=25367)
12:48:57 <jlouis> MUHHAHAHAHAHAHA! He closed the window
12:49:24 <Frederick> SamB, yo
12:53:42 <Frederick> guys I need some help on using from list
12:54:23 <wilx> @dict mmkay
12:54:24 <lambdabot> Supported dictionary-lookup commands:
12:54:24 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
12:54:24 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
12:54:24 <lambdabot> Use "@dict-help [cmd...]" for more.
12:54:30 <wilx> @jargon mmkay
12:54:32 <lambdabot> No match for "mmkay".
12:54:35 <pesco> Jeez, I'm falling in love with fractals.
12:54:49 <Frederick> I want to remove some entries of a dicitonary I have the source lemme post
12:57:03 <lisppaste2> Frederick pasted "grammar" at http://paste.lisp.org/display/13516
12:58:14 <Frederick> btw this source says I have an ambiguous reference to the map function
12:58:39 <SamB> Frederick: okay, now we are going to have to teach you about qualified imports
12:58:47 <Frederick> oki
12:58:49 * Frederick googles
12:59:10 <SamB> or you could just look them up ;-)
12:59:40 <Frederick> btw I went to the biggest books festival of ny town that is hapenning now, they didnt have a single book about haskell =/
13:00:11 <SamB> whats a good book for intermediate to advanced haskell programmers? SOE sounds fun...
13:00:29 <SamB> Frederick: well thats why they invented Amazon
13:00:39 <pesco> SamB: FOP maybe?
13:00:53 <SamB> @haskell-books FOP
13:00:53 <lambdabot> Unknown command, try @listcommands.
13:01:02 <Frederick> SamB, Im brazillian Amazon sells books in dollar itr is quite expansive for us
13:01:08 <pesco> :) The Fun of Programming.
13:01:10 <SamB> Frederick: oh
13:01:37 <SamB> Fun of Programming -- does  that come with a money-back guarentee?
13:02:15 <SamB> Frederick: well, you could ask your book store to order one, maybe...
13:02:24 <SamB> still would probably be expensive
13:02:49 <SamB> anyways, a book is not needed to get as far as I've gotten at least.
13:02:57 <SamB> though I did print out a bunch of papers
13:03:33 <Frederick> SamB, oki so I need qualified import because i must say for ghci to wich instance of map im reffering
13:04:10 <SamB> Frederick: yes.
13:04:22 <SamB> you'll probably want to
13:04:40 <Frederick> SamB, and the map Im using is the one from Data.Map.map
13:04:42 <SamB> "import Data.Map(Map)
13:04:56 <SamB> s/$/"/
13:05:00 <SamB> and
13:05:28 <SamB> "import qualified Data.Map as Map". only I probably said that wrong, I don't know if I've ever got that to work...
13:06:11 <SamB> then refer to Map.map, Map.fromList, Map.toList, etc.
13:06:29 <pesco> SamB: It's not making any specific promises about _your_ fun. *g* I think the book was made for Philip Wadler's 60th Birthday or something.
13:07:04 <Frederick> SamB, do I need to import Data.Map (Map) even if Ive already imported Data.Map?
13:07:40 <SamB> Frederick: you'll want to replace the existing "import Data.Map" with that
13:07:53 <SamB> I mean, what if you want to map over a list?
13:09:05 <SamB> "import Data.Map (Map)" says to import just the Map datatype defined in Data.Map into the top-level namespace of this source file
13:10:57 <lisppaste2> Frederick pasted "Confuzzled" at http://paste.lisp.org/display/13517
13:12:23 <SamB> Frederick: also "import qualified Data.Map as Map"
13:13:07 <SamB> thats the one that makes the Data.Map functions available as Map.toList, Map.fromList, Map.map, etc.
13:13:33 <Frederick> SamB, do I still need to qualify my call to map in line 13?
13:13:54 <SamB> yes
13:14:09 <Frederick> Because Ive qualified it as Map.map
13:14:31 <Frederick> and it reports a parse error
13:14:58 <Frederick> yo ski
13:16:25 <SamB> Frederick: what did you do for the qualified import?
13:17:56 <Frederick> Ive added the 2 imports as you have described
13:19:00 <SamB> okay, and what happens?
13:19:32 <Frederick> CFG.hs:13:37: parse error on input `Map.map' Failed, modules loaded: none.
13:19:57 <SamB> and let me see the imports?
13:20:38 <lisppaste2> Frederick pasted "map" at http://paste.lisp.org/display/13518
13:21:16 <SamB> oh, I see what you did
13:21:47 <SamB> that one is supposed to be Map. You are only supposed to replace "map" with "Map.map"
13:24:16 <Frederick> oki now it compiles until line 64
13:26:03 <Frederick> Couldn't match `[(ProdName, [Symb t nt])]' against `Map k b'  Expected type: [(ProdName, [Symb t nt])]  Inferred type: Map k b   In the application `Data.Map.map ((,) "") yss'    In the definition of `|->': |-> x yss = (x, Data.Map.map ((,) "") yss) Failed, modules loaded: none.
13:27:26 <int-e> uh, correct the type signature then
13:27:53 <int-e> hmm
13:28:06 <int-e> either that or you're using the wrong 'map'.
13:28:10 <Frederick> but the signature is defined in line 12 and it is   productions :: Map.map (Symb t nt) [(ProdName,[Symb t nt])]} so they math I think
13:29:33 <int-e> Frederick: the error message tells you that the return type of |->  is not a pair of a symbol and a list as specified in the signature but instead a pair of a symbol and a Map.
13:29:43 <int-e> (produced by Map.map)
13:30:25 <Frederick> hm
13:30:42 <Frederick> SamB, so I think Im getting the wrong semantics
13:31:36 <int-e> Frederick: I think you mean a different map. try taking out the import Data.Map (all uses of Data.Map are qualified now, right?) and replace the Map.map by map in the definition of |->
13:33:07 <Frederick> now it seems that the productions definition doesnt matches with the type
13:33:53 <int-e> Frederick: oh, that should be Map.fromList at least
13:35:03 <Frederick> int-e, now it says the type of productions is wrong.
13:35:29 <Frederick> because it was defined before as a map and now we are defining it as a list
13:36:21 <int-e> Frederick: hmm. which version of the definition of productions are you using?
13:36:47 <int-e> Frederick: in the paste, there are two, one commented out.
13:38:17 <Frederick> the commented one is because Ive defined the imports incorrectly on the first attempt
13:38:49 <int-e> Frederick: To match the type you need something like Map.fromList [NT 'E' |-> [NT 'E',T '+',NT 'E'], NT 'E' |-> [NT 'E',T '*',NT 'E']]
13:39:01 * ski wonders which paste
13:39:22 <int-e> err
13:39:38 <int-e> Frederick: To match the type you need something like Map.fromList [NT 'E' |-> [[NT 'E',T '+',NT 'E'], [NT 'E',T '*',NT 'E']]]
13:39:48 <int-e> that looks a bit more sensible
13:39:53 <int-e> ski: http://paste.lisp.org/display/13518
13:41:57 <Frederick> int-e, Ive tried it but  the definition in line 12 is broken so ghci wont even check for productions
13:42:09 <ski> (int-e : no production names ?)
13:42:30 <int-e> Frederick: you're supposed to just use 'Map' for the type
13:42:49 <int-e> Frederick: or Map.Map, but that defeats the purpose of import Data.Map (Map)
13:43:38 <ski> (yay, Data.Map imported 3 times :)
13:43:49 <Frederick> int-e, ah now I got it
13:43:56 * Frederick tests
13:44:39 <int-e> ski: I hope the unqualified import is now gone :)
13:44:54 <ski> it's not
13:45:01 <Frederick> oki now it complains about the production names it is recognizes the |-> what is wierd since it was working before
13:45:05 <int-e> ski: not in the paste, the paste hasn't changed.
13:46:07 <ski> Map.fromList [NT 'E' |-> [("add",[NT 'E',T '+',NT 'E']), ("mult",[NT 'E',T '*',NT 'E'])]]
13:46:07 <ski> ?
13:46:22 <ski> s/mult/mul/
13:46:34 <int-e> Frederick: could you paste the current version, please?
13:46:41 <Frederick> int-e, Imdoing it right now :)
13:46:49 <lisppaste2> Frederick pasted "asw" at http://paste.lisp.org/display/13520
13:47:08 * ski wonders why hte production rules are now grouped on heading nonterminal
13:47:28 <int-e> heh, where did the import Data.Map (Map) go?
13:47:55 <int-e> ski: because they're productions for the same nonterminal
13:48:25 <ski> so ?
13:48:35 <Frederick> int-e, hey you said that if I quilify the map call I dont need the import, at least that was what ive understood
13:48:36 <ski> it looks weird to still use '|->', then
13:49:19 <int-e> Frederick: your definition of |-> still adds a dummy production name, but your definition of productions already provides those. the map ((,) "") can go away
13:50:00 <int-e> . o O ( which means (|->) = (,) with a restricted type ... yes, this is becoming weird )
13:50:08 <Frederick> done
13:50:31 <Frederick> int-e, where did you find it?
13:50:40 <int-e> Frederick: in your code :-P
13:50:53 <Frederick> int-e, our code actually :p
13:51:00 <int-e> nah, it's still yours
13:51:15 <ski> i don't understand why you are keeping '|->' ..
13:51:16 <Frederick> int-e, so it is only ours if it succeds ? :p
13:52:20 <int-e> wait a second ... in productions, you have (NT 'E' |-> , ...), you have to use either NT 'E' |-> ... or (NT 'E', ...)
13:52:38 <Frederick> ski, I was discussing this with SamB and Cale some time ago I need to parse rules like S -> a | B |Ca where -> can be whatever symbol I want as long that I have a symbol that the user can use where
13:52:42 <int-e> ski: that's what confused you so much I guess :)
13:52:51 <int-e> ski: I had not even been looking at that line.
13:53:41 * Frederick needs an editorthat matches braces
13:54:39 * int-e wonders if that's a trolling attempt trying to induce an editor war ;)
13:55:08 <Frederick> int-e, Im too dumb to use an editor :p
13:55:23 <Frederick> oki lemme count
13:57:11 <lisppaste2> Frederick pasted "1 last error :p" at http://paste.lisp.org/display/13522
13:58:13 <int-e> the type signature for |-> is wrong now. obviously.
13:58:26 <Frederick> int-e, Ive tried to come back to the old definition with no succes too
13:58:28 <Frederick> yep
13:58:50 <Frederick> ibid, can I call type signature a type definition? no right?
13:59:10 <ski> no, right
13:59:11 <Cale> Frederick: is the user going to write the CFG in Haskell? I thought that you were writing a parser so that the user would write a CFG in a separate language.
13:59:32 <Frederick> Cale, I think about recieving the cfg from kb input
13:59:51 <ibid> Frederick: those two are two different things, so no
13:59:52 <ski> so, you don't *need* a haskell operator '|->'
14:00:05 <Frederick> or load it from a file
14:00:13 <ski> (maybe it can be convenient, maybe not, but you don't need it)
14:00:25 <Cale> yeah, for those things, there's no need to have a special infix operator in Haskell, of course
14:00:56 <Frederick> ski, I was discussing it with Cale and SamB and they said I dont need but might be convenient as you said too
14:01:11 <ski> your 'expr' is just a test, you aren't going to write your final CFG rules directly in haskell, anyway ..
14:01:30 <Cale> just a parser which parses a nonterminal followed by the string "->" followed by a sequence of possible expansions separated by "|"
14:01:58 <Frederick> Cale, yep this si the basic concept
14:06:29 <Frederick> ski, but I think it would be wise to make it work now so the last step would be load expr from a file, I think that haskell already provides this
14:06:57 <palomer> does haskell have serialization?
14:07:08 <SamB> Frederick: but it won't parse it the way your teacher will be expecting if you do it that way...
14:07:16 <SamB> palomer: well, there is Read/Show
14:07:23 <SamB> but that is anything but efficient
14:07:46 <SamB> there is Binary, but that isn't derivable without DriFT
14:08:25 <SamB> (isn't even in the common heirarchical libs!)
14:08:46 <ski> (Frederick : if you derive Read, then you couldn't use '|->' in the file to read)
14:08:48 <ndm> i think yhc and nhc derive binary
14:11:11 <ski> (Frederick : anyway .. wouldn't it be nicer to focus more on the essentials ?)
14:11:50 <Frederick> ski, sure it is but Im stuck on it now
14:12:06 <Frederick> ski, I need to acces the mapp structure properly
14:12:12 <Frederick> before I can advance
14:12:15 <palomer> omg
14:12:32 <palomer> like 20% of the time, when  I ask a question, someone has asked a very similar question right before
14:12:33 <palomer> it's nuts!
14:12:42 <Cale> Frederick: you might want to browser through the documentation for Data.Map
14:12:44 <palomer> (I hadn't read Frederick's question when I asked mine)
14:12:49 <Cale> @index Data.Map
14:12:50 <lambdabot> bzzt
14:12:56 <palomer> Cale: I'm no closer to solving my congruence problem:/
14:12:59 <SamB> @docs Data.Map
14:13:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
14:13:06 <SamB> @index map
14:13:06 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
14:13:11 <Cale> ah, right
14:13:24 * ski wonders why Frederick imports Data.Map two times
14:13:44 <SamB> ski: one of them is supposed to be qualified
14:13:46 <Frederick> ski, cause I got confused about imports and qualified imports
14:13:48 <Cale> ski: look closely :)
14:13:54 <int-e> ski: to avoid having to write Map.Map for the type
14:14:01 <int-e> ski: which is ugly.
14:14:12 <ski> ah, i wondered if it was that
14:14:26 <int-e> ski: at the same time, You want to import the functions qualified, especially map :)
14:14:33 <ski> of course
14:14:48 <SamB> yes, map was the one he ran into trouble with
14:14:55 * ski wouldn't back from writing M.Map, though
14:15:33 <SamB> if you think Map.Map is ugly, wait till you see BEncode.BEncode.BEncode
14:15:53 <SamB> I'm not sure its in any code, but it was in at least a patch summary
14:16:50 <Frederick> int-e, but if I use -> it matches with the difinition of the (|->) we have defined
14:17:15 <Frederick> it doesnt actually, so Ive added the "," after it but it keeps reporting the parse error
14:17:36 <ski> (you should *parse* '->', not use it in haskell (except for normal haskellish things))
14:18:34 <ski> don't get so caught up on 'expr'
14:19:03 <Frederick> ski, that is why Ive writtent the Productions parser
14:19:38 * ski see no production parser
14:20:22 <Frederick> ski, that was the last thing I was trying to write
14:20:45 <ski> ah, that thing at the bottom
14:20:49 <ski> that's no parser
14:20:59 <ski> (not even a start for a parser)
14:21:02 * Frederick frowns
14:21:49 <Frederick> oki I will comment ou expr for now
14:24:23 <Frederick> ski, should I comment that out or really erase that and write something in parsecs style?
14:24:49 <ski> expr could be nice for testing stuff
14:24:54 <ski> but it's not essential
14:25:05 <ski> you need to write a parser, anyway
14:25:35 <Frederick> ski, xpre was working before and the modules I got till now were tested with SamB's help and they work
14:27:21 <Frederick> brb I will read parsecs docs again
14:27:22 <Frederick> brb
14:29:57 <ski> Frederick : 'cfgParser' should be fleshed out, and prolly you need some more sub-parsers, for individual productions and right-hand-sides of the productions, etc ..
14:50:25 * ski leaves
15:14:17 * SamB wonders when/if dons will be around
15:14:40 * SamB remembers that it is probably sunday in australia
15:14:53 <SamB> @localtime dons
15:14:55 <lambdabot> Local time for dons is Sun Nov 13 10:09:08 2005
15:15:24 <m3ga> i was about to same the same but I didn't know lambdabot knew it :-)
15:15:50 <int-e> @localtime int-e
15:16:06 <SamB> dons: anyways, hmp3 is working beautifully now, with that patch that I sent you earlier today
15:16:06 <int-e> it knows nothing really. ("Received a CTCP TIME from lambdabot")
15:16:30 <m3ga> @localtime m3ga
15:16:31 <lambdabot> Local time for m3ga is Sun Nov 13 10:16:09
15:16:36 <SamB> @localtime lambdabot
15:16:48 <m3ga> should be the same :-)
15:16:52 <SamB> lambdabot doesn't even know what time it is at all ;-)
15:23:22 <fworp> @localtime fworp
15:26:47 <Frederick> @localtime ski
15:26:48 <lambdabot> Local time for ski is Sun Nov 13 00:28:10
15:26:57 <Frederick> @localtime Cale
15:26:58 <lambdabot> Local time for Cale is Sat Nov 12 18:26:04
15:27:07 <Frederick> @localtime SamB
15:27:09 <lambdabot> Local time for SamB is Sat Nov 12 18:26:54
15:27:33 * Frederick thinks wow I have support almost 24 hours a day :D
15:36:26 --- topic: set to '' by benmos
15:36:28 <praseodym> @localtime praseodym
15:36:30 <lambdabot> Local time for praseodym is Sun Nov 13 00:36:05 2005
15:37:06 <Heffalump> umm
15:37:33 <Heffalump> benmos: could you put the topic back?
15:37:50 <benmos> sorry about that - that was accidental.
15:38:10 <benmos> I don't actually know how to - still learning my IRC client.
15:38:46 <Heffalump> I'd go find the logs, but I normally use the topic for that..
15:39:11 <benmos> damn - sorry - it's just a single icon click on this client ...argh.
15:39:17 <Korollary> no big deal
15:39:42 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051101"]' by mauke
15:39:49 <benmos> thanks!
15:41:15 <Korollary> anyone using colinux here ?
15:41:26 <Heffalump> benmos: what client, OOI?
15:46:51 <benmos> It's a Mac OS X one called "Conversation" - it has a big button that apparently gets rid of the channel title - goodness only knows why...
15:47:21 <Korollary> it's more 'stylish' that way I suppose
15:47:44 <Heffalump> :-)
15:48:10 <benmos> yeah - if next time I design an app, I'll make a big "make user look like an idiot button" for newbies to click...
15:49:41 <Korollary> a big, green button that disables grants admin privileges and disables the firewall would be nice.
15:49:46 <SamB> benmos: but label it in RED
16:06:18 <mwc> Anybody know of any ssl socket libs?
16:06:21 <mwc> (for Haskell)
16:07:05 <mwc> haskell.org/libraries and the standard heirachical libs don't seem to have anything
16:07:42 <SamB> try haskell.org/http?
16:08:26 <SamB> the full package requires a crypto package...
16:08:30 <mwc> Yeah
16:08:37 <mwc> well, I need to do a simple http request over ssl
16:08:49 <SamB> ah, so that should be reasonable.
16:08:51 <mwc> so this should take care of it at a higher level if it supports ssl
16:09:17 <SamB> you won't have to pick it apart to get at the SSL support, assuming thats what the crypto is for ;-)
16:12:56 <mwc> drat
16:13:03 <mwc> looks like the TLS/SSL stuff is TODO
16:13:10 <SamB> ouch.
16:13:32 <SamB> what in the world does it want crypto for if that stuff is TODO?
16:13:33 <mwc> I suppose I could write something chincy to pipeline into openssl s_client
16:13:45 <SamB> grab the darcs and DO it?
16:13:56 <mwc> Ahah
16:13:56 <Frederick> great I got a haskell book
16:13:57 <mwc> http://cryp.to/hopenssl/
16:13:57 <Frederick> !
16:14:06 <mwc> You do? Which do you have?
16:14:21 <mwc> SamB: I'd assume hasking
16:14:23 <mwc> *hasking
16:14:26 <mwc> *hashing
16:14:27 <mwc> ahem
16:14:31 <SamB> mwc: oh.
16:14:32 <Frederick> The Haskell Road to Logig
16:14:35 <Frederick> *logic
16:14:47 <luqui> does anybody here have experience with UI.Glut?
16:15:02 <SamB> luqui: probably somebody does.
16:15:15 <Frederick> luqui, I do have some
16:15:23 <luqui> I have a pretty simple question
16:15:28 <mwc> Aha, here we are! http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/
16:15:29 <SamB> Frederick: its a Haskell module, though
16:15:48 <luqui> I have this redraw callback:  redraw win = do { ...; postRedisplay (Just win) }
16:16:06 <luqui> but the screen is updating too fast (or something) and I'm getting ugly refresh lines
16:16:07 <Frederick> SamB, I tought he meant gluit
16:16:15 <Frederick> *glut
16:16:17 <Frederick> from opengl
16:16:19 <Frederick> and stuff
16:16:26 <Frederick> luqui, sorry I cant help you :(
16:16:27 <SamB> Frederick: he does
16:16:33 <SamB> only its the Haskell bindings
16:16:39 <luqui> right
16:16:47 * Frederick runs away scared! NoooooooooOO!
16:16:57 <SamB> Frederick: do you know anything about that sort of problem in C though?
16:17:26 <Frederick> SamB, somethings, Im taking Computer Graphcs course atm so I know the basics at least
16:17:32 <SamB> that might help too
16:17:41 <SamB> most of us probably know C
16:18:06 <luqui> so Frederick, have you ever had that problem?
16:18:24 <luqui> I've never used glut before, just SDL
16:18:29 <luqui> but now I want to write a game in haskell :-)
16:18:44 <Frederick> luqui, you are having refresh problems?
16:18:47 <luqui> yeah
16:18:56 <Frederick> lemme see
16:19:04 <int-e> is there a binding for glutTimerFunc?
16:19:06 <luqui> first off, is that the conventional way to do continual refresh: to put a postredisplay at the end of your draw function?
16:19:25 <luqui> hmm, TimerCallback
16:19:34 <int-e> luqui: not really, you want a delay between the redraws.
16:20:01 <luqui> aye
16:20:03 <Frederick> int-e, insnt the glutmainloop that takes care of it?
16:20:11 <luqui> let me play with timercallback
16:20:27 <int-e> Frederick: I doubt it does delays ;)
16:20:48 <int-e> luqui: but the redraw problems seem to suggest you don't use double buffering.
16:21:20 <SamB> int-e: or that he isn't getting it to work right!
16:21:27 <Frederick> int-e, yes double buffering that was what I was thinking about there is a function to set the swap rate between the buffers
16:22:25 * int-e has (in C) glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);, glutTimerFunc(30, timer, 0);, a glutPostRedisplay() in timer() and another glutTimerFunc(30, timer, 0);, and a glFlush(); glutSwapBuffers() at the end of redraw().
16:22:27 <SamB> Frederick: how do you do vsynch?
16:22:33 * SamB goes afk
16:22:46 <Frederick> int-e, yep that is it this is the function
16:22:50 <luqui> ahh there we go
16:22:52 <Frederick> SamB, for what?
16:23:04 <luqui>  initialDisplayMode $= [DoubleBuffered]
16:23:17 <Frederick> luqui, did you find it?
16:23:35 <luqui> yeah, I wasn't using double buffering as int-e suggested
16:23:46 <int-e> luqui: you should still use timers to prevent the application from using 100% CPU (or thereabouts)
16:24:03 <luqui> is there a continual timer, or do I have to repost every time I callback
16:24:30 <int-e> luqui: I request a new callback every time. I don't think there is another way.
16:24:34 <luqui> okay
16:25:39 <int-e> luqui: and that timer shouldn't redraw directly; instead it should request a redraw with postRedisplay
16:26:07 <dons> SamB, hey. thanks for the patch
16:26:36 <luqui> oh, okay
16:26:38 <luqui> thanks int-e
16:27:33 <luqui> int-e, works like a charm
16:27:39 <int-e> :)
16:28:08 <dons> SamB, jlouis: FPS is BSD licensed: "-- License     : BSD-style
16:28:19 <dons> where does it say GPL?
16:28:41 <dons> ah, the License field on the package.
16:29:23 <int-e> dons: Hmm, do you remember that I wrote a number output routine a while ago? I let it slip and sort of forgot about it for a while. Where should I take it so it can find its way into the ghc libs eventually?
16:30:38 <dons> hmm. I don't remember the code, but usually you post such things to haskell-cafe or libraries@ for comments
16:31:25 <int-e> ok
16:31:55 <Igloo> libraries@ sounds more appropriate from the above, I think
16:33:38 * Frederick needs one more monitor
16:40:39 <Frederick> lol folks
16:40:58 <Frederick> ive dl a haskell course from a big university I wont name
16:41:35 <Frederick> so that blablabla this course is supposed to be taken in a semester blablabla, I could almost say I could pass the course with what you have teached me in this 3 days :p
16:54:30 <palomer> name the university!
16:54:38 <palomer> I wish my university would use haskell
16:54:43 <palomer> we've just   switched to sml
16:54:44 <palomer> yuck!
16:54:58 <luqui> what's wrong with sml?
16:55:01 <palomer> (and I'm the one who convinced the teacher to make the switch from scheme)
16:55:04 <palomer> it's not haskell!
16:55:09 <luqui> fair enough
16:55:14 <luqui> but it's a step in the right direction
16:55:19 <palomer> type classes are so much more convenient than signatures
16:55:30 <palomer> (though admittedly less powerful)
16:55:31 <palomer> and no lazy!
17:02:45 <SamB> palomer: yes, its work! work! work! all day, and no procrastination
17:04:42 <palomer> lazy = less work
17:05:13 <SamB> leave it to lazy functional programmers to design a language with built-in procrastination
17:06:22 <SamB> how am I supposed to use this graphics library to do anything!
17:06:35 <palomer> so true
17:06:55 <SamB> JyuGraphics by name, it is
17:13:03 <dons> SamB, so hmp3 works for you? any issues, comments?
17:13:45 <SamB> dons: well, I sent you the one patch
17:13:58 <dcoutts> SamB, you assign a graphic to a window
17:13:59 <Cale> SamB: it looks the same as Graphics.SOE
17:14:03 <SamB> but other than that so far okay
17:14:21 <SamB> dcoutts: how am I supposed to use text if I don't know how wide it will be?
17:14:21 <dons> SamB, yep thanks. got it. i've put a couple of others in now as well
17:14:29 <dcoutts> SamB, JyuGraphics is an extension of SOE.
17:14:34 <dons> any comments on the ui?
17:14:41 <dons> too complex, simple? missing feature?
17:15:07 <SamB> well, a help screen would be nice, but its fine ;-)
17:15:10 <Cale> @where hmp3
17:15:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3
17:15:22 <dcoutts> SamB, well the SOE interface is pretty limited. It doesn't give text measuring. You can use cairo/gdk directly if you like. Or extend the SOE API with your extra features.
17:15:33 <dons> amB, yes. that's one of today's tasks :)
17:15:52 <dcoutts> SamB, the original SOE module has the API reference. And of course there is the SOE website and book.
17:16:17 <dons> ah, I forgot to commit the todo list
17:18:08 <Cale> Also, the /home/dons/bin/runhaskell thing again :)
17:18:13 <palomer> haskell mp3 player?
17:18:15 <palomer> that's nuts.
17:18:33 <dons> Cale, boo on you ;)
17:18:42 <SamB> palomer: lovely piece of work. at least, my current build is!
17:19:04 <dons> what's the most common place for runhaskell then? /usr/bin ?
17:19:16 <SamB> dons: presumably
17:19:18 <dcoutts> dons, I guess so
17:19:28 <dons> that's debian and friends. /usr/local on bsd
17:19:33 <dons> but most of the world is linux
17:19:53 <dons> only 1 person I know has /home/dons/bin though
17:19:59 <SamB> true!
17:21:34 <dons> often Setup.hs only has a default entry. maybe a setup binary should come with cabal
17:21:47 <int-e> hmm. is that in the #! header of some script? then, how about #! /usr/bin/env runhaskell ?
17:21:52 <dons> that you can override with your own Setuphs if you want, otherwise just use 'setup'
17:22:02 <dons> int-e, does that work?
17:22:21 <int-e> dons: env looks in the PATH environment variable and looks for the program to run there ...
17:22:25 <SamB> dons: maybe one that tries to run Setup.lhs, Setup.hs, or the default version?
17:22:25 <dons> that would require 2 stages of evaluation.. not sure #! is that clever
17:22:35 <dons> SamB, yeah.
17:22:53 <dons> so you just type 'setup' and it will use the default (which seems most common) or any Setup.hs if found
17:23:03 <dons> saves me one file to write
17:23:09 <SamB> #! /usr/bin/env does the second stage of evaluation...
17:23:19 <SamB> er, s/#! /
17:23:22 <SamB> //
17:23:32 <SamB> extra slashes for good mention
17:23:36 <SamB> measure
17:23:58 <dons> ah, it works ! :)
17:24:02 <dons> @karma+ int-e
17:24:02 <lambdabot> int-e's karma raised to 3.
17:24:30 <SamB> it works for python, it sure OUGHT to work for haskell
17:24:35 <dons> right :)
17:24:56 <dons> oh, silly me. I was thinking of the wrong 'env' semantics
17:25:02 <dons> env == id
17:25:17 <dons> I was thinking of `which` for some reason
17:25:22 <SamB> heh
17:25:23 <int-e> yep, mostly :)
17:25:53 <int-e> SamB: it also works for perl, I think that's where I've seen it the first time.
17:26:15 <SamB> int-e: yeah, well, I try to stay away from that stuff.
17:26:45 <int-e> SamB: actually I don't like Perl very much either. ;)
17:27:01 <palomer> down with perl!
17:27:16 <SamB> it seems to be a decent language for writing Great Manglers in, but not too much more
17:27:47 <Cale> we should try to be nice to perl people in that they're using Haskell now :)
17:27:54 <dons> I think the mangler is sufficiently complex it should really be in haskell
17:28:16 <dons> we have mkRegex, after all, which is the main reason perl is used.
17:28:30 <SamB> dons: you are welcome to it if you can figure out how to run it when bootstrapping from .hc files!
17:28:54 <dons> you don't use the mangler when bootstrapping ;)
17:28:57 <int-e> hehe, perl is nice if awk code gets out of hand *g*
17:29:04 <dons> or first, you build a mangler from .hc src
17:29:08 <dons> which itself isn't mangled
17:29:41 <SamB> but then you'd need to be able to cross-build pure C too
17:29:51 <Cale> heh, until I switched to using lambdabot, mbot was just a collection of bash scripts
17:31:12 <dons> hehe
17:32:21 <SamB> I hacked my the mangler in my CVS tree so that I get files that are more objdump-friendly
17:40:01 <dscape> wxhaskell anyone?
17:42:08 <Cale> what about it?
17:45:25 <dscape> Cale i just finished coding a sudoku in wxHaskell
17:45:36 <Cale> cool
17:45:48 <dscape> but when i drawed it i forgot the boxes.. :\
17:46:12 <dscape> and if i draw then over the grid, it stops the game.. and i think theres some paint funcionality
17:46:48 <dscape> but i cant seem to be able to integrate it.. another thing is
17:46:53 <TheHunter> @where ghc-src
17:46:54 <lambdabot> http://scannedinavian.org/~lemmih/ghc-src
17:47:09 <dscape> my tutor told me it was impossible to code wxHaskell with the state monad
17:47:13 <dscape> is this true?
17:49:11 <SamB> dscape: which state monad?
17:49:36 <dscape> in this case its a StateT [[Int]] IO
17:50:04 <dscape> SamB
17:50:05 <SamB> you should be fine...
17:50:16 <SamB> if you remember to do liftIO where needed
17:50:24 <dscape> ok but
17:50:32 <dscape> i doo a fun using the monad
17:50:46 <dscape> and that func is going to be evaled (like evalStateT)
17:50:55 <SamB> mmhmm
17:50:55 <dscape> that function does
17:51:03 <dscape> liftIO $ start gui
17:51:09 <dscape> and then it runs the wx..
17:51:15 <dscape> and no monad in start.. :\
17:51:20 <dscape> do u get my point?
17:51:35 <dscape> only when u close the wx gui u get the monad back
17:51:39 <dscape> so its useless?
17:51:47 <SamB> oh, well, you probably ought to do the evalStateT inside the GIO
17:51:50 <SamB> er, UI
17:51:59 <SamB> obi-wan error or something
17:52:56 <dscape> SamB have u ever used a state monad on a wx program?
17:53:16 <SamB> no
17:53:37 <dscape> just try to do so on a basic wx sample
17:53:41 <stefanw> dons: hmp3 is cool! maybe one day I can throw away all X applications... I really like your idea of pretty printing a ncurses screen
17:53:42 <dscape> inside the gui
17:53:45 <SamB> but then I never wrote my own wx program either, I just updated one to work with a more recent wx
17:53:51 <dscape> if u can, send it to me
17:54:05 <dscape> just a simpel sample..
17:54:24 <dons> stefanw, cheers :) the implementation needs more work, but I think the idea is there
17:54:34 <SamB> stefanw: wait until you see what we could do with GTK combinators!
17:55:11 <dscape> but dont u think its stupid to use a state monad when wx provides u with variables?
17:55:18 <stefanw> SamB, but I can't implement terminal-based applications with them. That's what I'm after...
17:55:39 <dons> so maybe I'll go back and look at the SPJ pretty printer paper.
17:56:00 <dscape> and why does a brute force algoritm with monad is 3 times faster then one without them?
17:56:25 <stefanw> dons: maybe we should come up with a list of useful primitives and combinators
17:56:51 <SamB> dscape: without details, I can't explain a thing
17:56:56 <dons> yes. I think we can start with the pretty printer ones, and build on that
17:57:34 <dons> also we need an attributed Char type (see CharA in Style.hs of hmp3) to build the equivalent of a Doc
17:57:56 <dscape> samx i wouyld be embarressed to show the world how lame my code is :P
17:58:07 <dscape> SamB
17:58:17 <stefanw> really? why not only have some like withStyle :: Style -> Screen -> Screen?
17:58:44 <dons> well our Char type needs to be a union
17:59:10 <dons> data CharA = C {-# UNPACK #-} !Char
17:59:11 <dons>            | A {-# UNPACK #-} !Char !Style
17:59:19 <dons> (forget the don-isms in that code ;)
17:59:44 <dons> and then we can optimise the representation further, so that whole lines can be printed in one go:
17:59:47 <dons> data StringA = Fancy ![CharA]   -- lines with colours in them
17:59:50 <dons>              | Plain !String    -- plain text, no attributes set
18:00:04 <dons> this really helps performance, as any Plain can be waddnstr'd
18:00:10 <stefanw> so this char type would be used in the internal screen representation only?
18:00:18 <dons> yes
18:00:42 <dons> the renderer then converts a list of StringA's into a bunch of curses calls that do the actual work.
18:01:19 <stefanw> ah ok. I was thinking only about the primitives and combinators that the user sees.
18:01:49 <dons> possibly we could do without the C type, by passing a table mapping screen positions to styles instead
18:02:39 <dons> stefaw, ok. so we want some combinators such as: pad, padLeft, padRight, alignL, alignR, alignC, <>, <+> (various cons/append ops)
18:02:54 <dons> vertical composition with $$
18:03:34 <stefanw> what does pad do?
18:03:57 <dons> adds whitespace on the left or right of a string
18:04:10 <dons> for example, we often want to indent 1 char on the left side.
18:04:24 <dons> the Ppr library has hang(?) for this
18:04:26 <dons> I think.
18:04:44 <dons> oh, pad adds whitespace on both ends of the string
18:05:11 <stefanw> how much whitespace?
18:05:24 <dons> I currently don't use it for more than 2 or 3 chars
18:05:42 <dons> but I could imagine more complex uis that need indenting.
18:05:53 <dons> but this is also described in the pretty printer library, so we can steal that i
18:06:21 <dons> ah, interesting, Text.PrettyPrint.HughesPJ has:
18:06:22 <dons>         data TextDetails = Chr  Char
18:06:22 <dons>                          | Str  String
18:06:23 <dons>                          | PStr FAST_STRING
18:06:37 <dons> which we might want too. PackedStrings mean really fast updates
18:07:22 <dons> ah, check the "doc calculus" in Text.PrettyPrint.HughesPJ!
18:07:38 <dons> there's some nice laws (we could QC!)
18:07:45 * stefanw tries to write a mutt screen with Text.PrettyPrint.HughesP
18:08:08 <dons> and the final type is:
18:08:09 <dons> data Doc
18:08:10 <dons>  = Empty                                -- empty
18:08:10 <dons>  | NilAbove Doc                         -- text "" $$ x
18:08:10 <dons>  | TextBeside TextDetails !Int Doc      -- text s <> x
18:08:12 <dons>  | Nest !Int Doc                        -- nest k x
18:08:14 <dons>  | Union Doc Doc                        -- ul `union` ur
18:08:17 <dons>  | NoDoc                                -- The empty set of documents
18:08:20 <dons>  | Beside Doc Bool Doc                  -- True <=> space between
18:08:22 <dons>  | Above  Doc Bool Doc                  -- True <=> never overlap
18:08:25 <dons> so I imagine we use much the same to place boxes on the screen
18:09:48 <stefanw> yeah, that looks good
18:11:30 <dons> so the users write instances thatC[C[C[C[C[C[C[C produce an AST representing the layout, (perhaps we use the type Screen instead of Doc), and then the render walks the AST :: Screen, calling curses in the most efficient fashion.
18:11:56 <dons> which means each ui element gets a type (or newtype) as with the Pretty class.
18:12:15 <dons> this would work very nice, I think. and feels very sound.
18:12:23 <stefanw> really nice, indeed
18:18:17 <Cale> oh neat -- curses pretty printing?
18:18:35 <dons> yeah, that's what we're looking at.
18:18:43 <stefanw> hm, how do I do column-based layout with the pretty printer?
18:19:01 <Cale> sort of like gui layout combinators
18:19:45 <dons> stefanw, column-based? what information do you need? the width? or the current column?
18:20:34 <stefanw> for example, take mutt's index: there is a column for "from" and "subject". How would you do this?
18:20:36 <dons> Cale, yeah, since a screen is just a 2-d layout of text in ncurses, we should be able to compose ui elements as with Text.PrettyPrint, I think. hmp3 does this somewhat, but it could be generalised
18:20:59 <dons> stefanw, ah. verticle elements. hmm.
18:21:03 <dons> vertical.
18:21:48 <dons> so they're actually a transpose of [field1, field2, field3] ... [... ] aren't they
18:21:55 <stefanw> In fact, pretty printing seems to be horizontal oriented, whereas GUIs are often vertical oriented (tables, list, ...)
18:22:22 <dons> yes. we'd have to add vertical elemtns to the AST, perhaps.
18:22:45 <dons> Next Doc Doc
18:22:59 <Igloo> mutt doesn't have h and v, it has a grid
18:23:15 <Igloo> As it never wraps lines you could fudge it in that case, admittedly
18:24:12 <dons> I wonder if more complex box arranging (TeX style) are discussed in the pretty printer papers
18:24:32 <dons> http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps
18:24:38 <stefanw> http://caml.inria.fr/resources/doc/guides/format.html
18:24:52 <stefanw> "boxes: a box is a logical pretty-printing unit, which defines a behaviour of the pretty-printing engine."
18:25:20 * dons notes the Hughes paper on ppr is 44 pages long!
18:25:30 <dons> ah, nice  stefanw.
18:26:24 <dons> a simple ppr library for ncurses in haskell would be a killer feature.
18:26:37 <dons> I'd imagine an explosion of curses applications being produced
18:26:48 <stefanw> that's what I want!!
18:27:22 <stefanw> but then the OCaml guys write: "breaks: a break is a hint given to the pretty-printing engine"
18:27:57 <dons> ah, hints on when to break strings
18:28:09 <stefanw> that works fine for text, but for UIs "hints" do not make much sense
18:28:29 <stefanw> you just cut the text if it does not fit
18:28:52 <dons> right. we don't want autobreaking
18:29:52 * dons is happily reading the ppr paper, and wonders how by page 16 it ends up in backtracking monad territory
18:30:31 * stefanw has to finish his talk before you can go on with these cool ncurses pretty printing stuff
18:30:38 <dons> ok :)
18:30:45 <stefanw> ups, s/you/he
18:30:52 <Frederick> @localtime ski
18:30:53 <lambdabot> Local time for ski is Sun Nov 13 03:32:16
18:31:08 <Frederick> @localtime Cale
18:31:09 <lambdabot> Local time for Cale is Sat Nov 12 21:30:14
18:31:17 <dons> yeah, there's a strong bias towards horizontal composition in the hughes ppr
18:31:26 <Frederick> @localtime SamB
18:31:28 <lambdabot> Local time for SamB is Sat Nov 12 21:31:14
18:31:34 <dons> all the rules get based upon [box1] <> [box2] horizontally
18:32:14 <dons> but this isn't a problem for us, I think.
18:33:48 <dons> @pl map (\_ -> return ())
18:33:49 <lambdabot> map (const return)
18:33:56 <dons> bah, I wanted something cuter
18:34:05 <stefanw> so Hughes does not have the concept of boxes?
18:34:22 <dons> horizontal boxes, yes, I think.
18:35:00 <stefanw> It was cool if $$ would construct just a box. for example:
18:35:20 <stefanw> let d = text "row 1, col1" $$ text "row 1, col 2"
18:35:40 <stefanw> let d2 = text "row 2, col 1" $$ text "row 2, col 2"
18:36:08 <stefanw> and then d <+> d2 would give you a two-column layout
18:36:46 <dons> ah, right. I think we could probably come up with the desired boxing properties
18:44:45 <SamB> Frederick: yes?
18:45:28 <SamB> @type map (\_ -> return ())
18:45:28 <Frederick> SamB, I was just checking you local time
18:45:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m ()]
18:45:34 <SamB> @type map (const return)
18:45:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => [a] -> [a1 -> m a1]
18:45:40 * Frederick runs scared
18:45:44 * Frederick fear maps
18:45:49 <SamB> Frederick: don't be scared
18:46:08 <SamB> anyway, you are really only afraid of ambiguous references
18:46:43 <SamB> dons: he had map imported from both Prelude and Data.Map, and he tried to use the one from Data.Map
18:46:51 <SamB> boy did he get a nasty surprise...
18:47:08 <SamB> I probably should have told him about qualified imports in the first place...
18:47:40 <dons> hehe
18:48:06 <SamB> I hope he isn't scarred for life ;-)
18:48:14 <SamB> then he would never, ever want to use Haskell again!
18:48:20 <SamB> wouldn't that be just sad?
18:48:28 * dons scratches head and wonders why cabal doesn't like mutually recursive modules.
18:48:36 <Frederick> SamB, the work im doing is uselles
18:48:40 <SamB> dons: probably same reason GHC doesn't
18:48:43 <Frederick> but I hope that next time
18:49:04 <dons> SamB? mutually recursive modules work just fine in ghc last time I checked.
18:49:11 <dons> hs-boot forever!
18:49:16 <Frederick> next time I have an assignment for a class of compilers or stuff I can just say, oki I will get haskell and parsec and get it done this afternoon
18:49:25 <SamB> dons: well, thats not quite what I call "just fine"
18:49:30 <SamB> anyway, its non-portable.
18:49:31 <dons> ok
18:49:38 <SamB> so Cabal doesn't know about it
18:49:53 <SamB> and Cabal can't do a topological sort of a cyclic graph
18:49:53 <dons> ok, good point
18:50:21 <dons> it'll just have to! i'm not going to refactor my code in silly ways
18:50:46 <SamB> well, I'm afraid you'll have to make it!
18:51:07 <dons> i'm sure there's a magic ghc-options: I can add
18:51:37 <dons> since cabal just runs  --make  I don't get why it breaks.
18:51:42 <dons> maybe I've done something wrong
18:51:58 <SamB> oh, hmp3 can use a disturbing amount of CPU...
18:52:07 <SamB> hmm, just --make?
18:52:14 <dons> SamB?
18:52:19 <dons> when compiling, or running?
18:52:25 <SamB> running!
18:52:29 <dons> oh, sounds like a  bug.
18:52:39 <SamB> when compiling it is normal to see 100%
18:52:43 <dons> it should use only a tiny amount, since it sleeps almost all the time
18:52:55 <dons> you have the latest code?
18:53:21 <SamB> apparantly
18:53:41 <dons> mine is sitting on 16% which is bad. it was only 0.2% yesterday.
18:53:44 <dons> maybe i broke something.
18:54:04 <SamB> I'm seeing 10-20 % also
18:54:15 <SamB> which is odd, because you undoubtedly have a much faster CPU than I do
18:54:42 <dons> did I leave the profiling flags on in the .cabal file?
18:55:30 <SamB> I don't think so, but if you did I switched the comment to a different line
18:55:36 <dons> there's quite a bit of room to improve performance though, so I wouldn't be worried :)
18:55:55 <SamB> still, what IS it doing?
18:56:16 <dons> not sure. there's some debug strings. probably it's refreshing too often
18:56:16 <SamB> maybe you should read papers on incremental stuff ;-)
18:56:39 <dons> i had a race condition yesterday where a refresh forced another refresh, that made performance suck
18:57:10 <dons> anyway, since it's sitting on a neat 16% here, I'll investigate. it's definitely got worse today
18:57:53 <dons> (nice thing is this must be the only app I've ever developed that's already had several days of uptime testing :)
19:00:44 <Frederick> SamB, oki I got some doubts with parsec
19:00:52 <SamB> Frederick: yeah?
19:00:59 <Frederick> Im a bit confused again
19:01:12 <Frederick> Ive defined the data structures I will use
19:01:20 <Frederick> so now I must create a parser for them
19:01:30 <SamB> yes?
19:01:34 <dons> ah, I forgot {-# SOURCCE #-} !
19:01:41 <SamB> dons: heh
19:01:41 <dons> that's why mutual recursion broke
19:01:54 <SamB> I told you GHC had a problem with that!
19:01:54 <Frederick> but first: I cant see exactly why I need this parser since I already match the definitions against a pattern
19:02:15 <dons> yay: Compiling Keymap[boot]
19:02:19 <SamB> Frederick: the parser is to give you a nice, concise syntax.
19:02:38 <SamB> also, you seemed to want one.
19:02:46 <SamB> I would definately do it!
19:02:59 <SamB> I do not like writing those things in longhand!
19:03:19 <SamB> it takes, like, minutes to write out a single one!
19:03:37 <Korollary> > 140.0 / 13
19:03:38 <lambdabot> 10.76923076923077
19:04:05 <SamB> Korollary: you know, that .0 is unnecessary. this isn't python.
19:04:08 <SamB> or C.
19:04:14 <SamB> or any of that sort.
19:04:18 <SamB> @type (/)
19:04:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:04:48 <SamB> Frederick: so, do you not think a parser is a good idea?
19:04:56 <dons> @type 140 / 13
19:04:57 <lambdabot> forall a. (Fractional a) => a
19:05:12 <SamB> > 140 / 13
19:05:13 <lambdabot> 10.76923076923077
19:05:21 <dons> @type 1
19:05:22 <lambdabot> forall t. (Num t) => t
19:05:24 <Frederick> SamB, ive checked the samples it doesnt seems soooooooooo hard to be done and may avoid future problems
19:05:48 <dons> haskell certainly does win the prize for the most complex types for numeric literals
19:06:00 <eivuokko> heh
19:06:02 <dons> well, except for maybe Twelf or Epigram ;)
19:06:09 <SamB> dons: but also most composable I've seen!
19:06:16 <dons> yes, they're great!
19:06:17 <Frederick> SamB, I think that what I need is described here -> http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html in the Lexeme Parsers section
19:06:25 <dons> but boo on fromIntegral, my most hated function
19:06:36 <Frederick> but obviusly I must do it match with my data structures, what will be the pain
19:06:43 <eivuokko> dons, what's wrong with it?
19:06:45 <SamB> dons: agreed. its name is too long.
19:06:50 <dons> name is too long
19:06:53 <eivuokko> Ah.
19:07:07 <dons> should be a prefix operator, perhaps?
19:07:13 <Korollary> dons: you'd make a lovely java programmer then
19:07:18 <SamB> note that on my side, I said it first that the name is too long
19:07:19 <dons> hehe
19:07:34 <SamB> Korollary: what, complaining about all the long names in Java?
19:07:48 <Korollary> SamB: No, I am not. I don't write java.
19:08:04 <SamB> Korollary: no, I mean do you think he would be good at that?
19:08:15 <SamB> anyway, once I did fI = fromIntegral
19:08:21 <Korollary> SamB: I think dons would be a great programmer in every language.
19:08:23 <SamB> when I was using fromIntegral everywhere
19:08:36 <eivuokko> Yeah, I have shorthand for it in some ffi stuff.
19:08:46 <SamB> Korollary: dons seems to think he is best in Haskell though ;-)
19:09:30 <Frederick> SamB, I think I will need something like rules :: Parser Prod t nt but my Prod is a composed type there is no such kind of example over parsec tutorial
19:10:02 <SamB> Frederick: well, your parser will probably want to be more like rules :: Parser Prot Char Char
19:10:13 <SamB> er,s/Prot/Prod/
19:10:20 <SamB> only with parentheses
19:10:30 <dons> SamB, also I use 'fi'
19:10:40 <SamB> dons: well, mine had a capital I
19:11:14 <Frederick> SamB, where would I need parentheses? Will it be like Prod (Char, Char)?
19:11:15 <SamB> I don't remember what I was writing...
19:11:21 <dons> hmp3 is now happily mutually recursive
19:11:38 <SamB> maybe that was my abortive attempt at an MMIX emulator?
19:12:24 <SamB> I don't think I needed that in my fairly-working but in-need-of-real-IO-support Z-Machine interpreter
19:12:50 <SamB> I mean, not often enough to call it fI
19:13:23 <dons> the Curses code in riot,yi,hmp3 etc uses fi all over the place to get CInts
19:13:34 <SamB> I think I managed to put all the address-unpacking/repacking stuff in a few small functions...
19:14:02 <dons> ok, now to tackle this cpu issue
19:14:06 <SamB> I don't suppose anyone would like to adopt my Z-Machine interpreter?
19:14:13 <dons> hmm, but now it's only using : 0.29%
19:14:22 <SamB> heh
19:14:36 <SamB> well, hit up and down a bunch of times and wait for it to settle down maybe?
19:14:44 <dons> yeah.
19:15:17 * SamB has GKrellM down the left of his screen
19:16:31 <SamB> hmm, mine seems to have gone down to 5.2 % for some reason...
19:16:39 <dons> lotss of scrolling got it up to 20%. that needs tuning at least, but now it's already back down to 3%
19:17:22 <dons> i'll do some more profiling, I've got some (sneaky) ideas for improving the refresh rate
19:17:51 <Frederick> SamB, now I got 2 questions the parsing is done in 2 levels I think
19:18:07 <SamB> well, remember, once per second is probably all that will be visible unless the user is actually doing something, or unless the MP3 is really short
19:18:20 <SamB> or unless the terminal is really huge
19:18:35 <dons> the clock only refreshes once per second.
19:18:37 <SamB> Frederick: yeah?
19:18:44 <int-e> weeeee. screen-filling xterm with 'unreadable' font :)
19:18:45 <dons> the screen only refreshes once per key stroke
19:19:01 <dons> but in the back ground mpg321 sends in messages oover the wire
19:19:05 <SamB> (I shouldn't have said anything, I shouldn't have said anything...)
19:19:05 <Frederick> the easy one is like rules :: CharParser st (Prod Char Char) do {onefOf terminals; return somethingidontknow:p}
19:19:51 <dons> ah, so it could be the message handling in the background
19:20:21 <dons> since that's always running, while all the other threads are sleeping.
19:21:03 <SamB> nit-pick: wouldn't that only run whenever a message comes in?
19:21:18 <dons> yep, it blocks on the handle
19:21:33 <SamB> of course, I imagine that could be a lot
19:21:54 <dons> hmm, a few hundred a second, iirc.
19:22:00 <SamB> wow
19:22:03 <SamB> what is it sending?
19:22:10 <dons> info about the current frame
19:22:22 <dons> which we sample every 1 sec to display the progress bar
19:22:26 <SamB> could you get it to be a little less verbose?
19:22:38 <dons> i'll see.
19:22:45 <SamB> how are you reading it?
19:22:57 <dons> lazy lexer.
19:23:06 <dons> so we could use alex, if the lexer is using too much overhead
19:23:37 <dons> we have to read every message though, to find out when things stop. but we only rarely care about getting frame messages
19:23:44 <SamB> what is this line:
19:23:45 <SamB>     --  hPutStrLn stderr "MPG321"
19:23:58 <dons> that is the debug str that says a message arrived
19:24:16 <SamB> oh, just so you weren't expecting cpp to expand that
19:24:21 <dons> so mine has now stabilised at  2.78%
19:24:53 <dons> SamB, good point :) but I don't import config.h in Core.hs, do I?
19:25:02 <SamB> dons: I dunno.
19:25:27 <SamB> I'm wondering how (MPG321 :: String) makes sense if MPG321 isn't a preprocessor macro, though...
19:25:45 <dons> MPG321 is a preprocessor symbol
19:25:53 <dons> if it isn't, then it doesn't make sense :)
19:26:08 <SamB> yeah, I know
19:26:19 <SamB> and thats in the same file, so...
19:26:24 <dons> ah, i do use configh.
19:26:25 <dons> good point!
19:26:37 <dons> hmm, but would cpp expand something in ""
19:26:45 <Frederick> SamB, how do I say to parsec that I have a sort of a composed structure to the productions what I need is almosr equal to http://rafb.net/paste/results/p6x3Kv47.html but my productions definition is too fancy for a directly adaptation
19:27:39 <Frederick> I think I cant pass to the parser my Prod type
19:27:59 <SamB> you don't need to pass types
19:28:27 <Frederick> neither their entries?
19:28:35 <SamB> you could of course pass in parsers for terminals and nonterminals, but at this point I think it makes more sense to just use the ones you have now
19:29:08 <SamB> don't worry about passing types around until you learn about "haunted types".
19:29:19 <SamB> excuse me, I mean "phantom types"
19:29:49 <dons> hehe
19:30:01 <Frederick> im very confuse about the next steps, I was hopping to be already implementing the algorithms them selves but I still uable to use my data definitions oki
19:30:04 <SamB> your types will get there fine as long as they have values ;-)
19:31:02 <Frederick> well at this stage I can already check a list of productions, so I though I could be already eliminating ¬£ productions
19:31:41 <SamB> how about something like "rhs termchars = many (terminal termchars <|> nonterminal termchars) `sepBy` char '|'
19:31:54 <SamB> oh, wait.
19:32:18 <SamB> rhs termchars = many (terminal termchars <|> nonterminal termchars) <|> empty `sepBy` char '|'
19:32:37 <Frederick> SamB, that would be the definition for a rule I think but as ive said I have it defined
19:32:47 <SamB> oh, you do?
19:32:58 <SamB> do you have it pasted?
19:33:05 <dons> the bad thing about hmp3 is that it sleeps so often, and does so little, it's hard to get any time % in the profiling graphs
19:33:25 <Frederick> when I use the map doesnt it assured that I will have a single variable on the left side?
19:33:43 <SamB> dons: defect in GHC profiling support?
19:33:57 <SamB> Frederick: sure
19:34:15 <SamB> but it doesn't tell how to parse it
19:34:47 <dons> SamB, not sure. I think since most of the time is spent in foreign ncurses code, it doesn't get shown
19:34:49 <SamB> "Lisppaste pastes can be made by anyone at any time. Imagine a fearsomely comprehensive disclaimer of liability. Now fear, comprehensively."
19:34:55 <SamB> dons: oh
19:34:56 <dons> we still get good info on allocs though
19:35:14 <SamB> dons: it would be nice if it would count that towards whatever cost center invoked the curses code...
19:35:22 <Frederick> SamB, http://paste.lisp.org/display/13528
19:35:50 <SamB> Frederick: you don't have that parser there!
19:36:11 <Frederick> SamB,what do you mean?
19:36:44 <SamB> Frederick: you don't have any more parsing code than the last one I saw
19:37:06 <Frederick> SamB, sure cause Im confused
19:37:29 <Frederick> I need something that is almost equal to the bnf parser but the bnf parser doesnt uses a map
19:37:49 <SamB> don't worry!
19:37:52 <SamB> that is a triviality
19:39:03 <SamB> just pretend the type of the whole thing was [(Symb n nt, [[Symb n nt]])]
19:39:26 <Frederick> SamB, when my teachers say something is a triviality and suggested as exercise when run || duck
19:39:40 <SamB> when I say it I am not kidding
19:39:54 <SamB> I already wrote the function that makes it trivial
19:42:27 <SamB> okay, say I have "N -> sN | z"
19:42:37 <SamB> what would you call "sN" and "z"?
19:42:39 <SamB> productions?
19:43:18 <Frederick> yes
19:43:41 <Frederick> Im running PArsecs docs samples here to get a better comprehension
19:46:16 <SamB> @index lexeme
19:46:18 <lambdabot> Text.ParserCombinators.Parsec.Token
19:46:33 <SamB> hmm, don't think I want to mess with Token...
19:47:44 <SamB> where do you want to allow spaces?
19:49:09 <SamB> nevermind, spaces aren't too relevant right now...
19:50:15 <SamB> I take it back, those things are ugly with no spaces
19:50:21 <Frederick> rofl
19:50:37 <Frederick> spaces are only allowed before a separator and after it
19:50:42 <Frederick> no other place
19:50:51 <dons> hmm I think div by 0 caused a space leak. weird.
19:51:11 <SamB> I'm going to do the cheap trick of making a seperator actually consist of " | "
19:51:49 <soysauce> CPS is working me over x_x
19:52:11 * soysauce feels like writing some self-recursive acronyms
19:52:40 <Frederick> SamB, that is called experience not cheap trick :p
19:52:56 <Frederick> by some reason Im failling to compile the sample given in parsecs docs
19:53:16 <dons> ah, no. div by 0 doesn't cause space leaks. non-termination does!
19:53:39 <SamB> http://paste.lisp.org/display/13528#1
19:53:42 <dons> just sit back and watch that thread allocate >> loop>> allocate >> loop ..
19:54:14 <SamB> dons: I thought div by 0 was illegal?
19:54:19 <SamB> > 1 / 0
19:54:20 <lambdabot> Infinity
19:54:25 <SamB> > 1 `div` 0
19:54:26 <lambdabot> divide by zero
19:54:31 <SamB> > undefined `div` 0
19:54:33 <lambdabot> divide by zero
19:54:35 <SamB> heh
19:54:51 <SamB> > undefined `div` 0 :: Int
19:54:52 <lambdabot> divide by zero
19:54:53 <dons> I think I was actually / -1, but that wasn't the problem :)
19:54:56 <SamB> > undefined `div` 0 :: Integer
19:54:57 <lambdabot> divide by zero
19:55:04 <SamB> anyway
19:55:14 <SamB> Frederick: look at that annotation to your paste
19:55:42 <Frederick> k
19:56:04 <SamB> observe:
19:56:05 <SamB> *CFG> parseTest (rhs "sz") "sN | z"
19:56:06 <SamB> [[T 's',NT 'N',NT ' ',NT '|',NT ' ',T 'z']]
19:57:12 <SamB> wait.
19:57:18 <SamB> there is a slight problem with that.
19:57:28 <Frederick> yep
19:57:29 * SamB feels silly.
19:57:32 <Frederick> it didnt ignore
19:57:35 <Frederick> the white spaces
19:58:02 <SamB> Frederick: that, and it thought '|' was a nonterminal
19:58:12 <Frederick> cant we cheat doing x <- " "; return [] :p
19:58:21 <dons> > round (1.0 / 0.0)
19:58:22 <lambdabot> 179769313486231590772930519078902473361797697894230657273430081157732675805
19:58:22 <lambdabot> 500963132708477322407536021120113879871393357658789768814416622492847430639
19:58:22 <lambdabot> 474124377767893424865485276302219601246094119453082952085005768838150682342
19:58:22 <lambdabot> 462881473913110540827237163350510684586298239947245938479716304835356329624
19:58:22 <lambdabot> 224137216
19:58:52 <dons> > (1.0 / 0.0)
19:58:53 <lambdabot> Infinity
19:59:06 <dons> it's good that they try to round infinity
19:59:11 <soysauce> haha
19:59:13 <Frederick> SamB, wow you made me think about something Ive never wondered, like my teacher is all about this is a formal course and blablabla but he never defined the separators formaly
19:59:15 <dons> did it get close though?
19:59:16 <soysauce> that's funny
19:59:36 <Frederick> dons, lim (1.0/ 0.0) tends to infinity
19:59:54 <SamB> Frederick: well, thats the trouble with non-executable specifications
20:00:01 <dons> yes, I was making a joke about the number it returned
20:00:02 <SamB> you can never be quite sure what they mean
20:00:32 <Frederick> SamB, what is a great joke to a discipline that is called "Formal" Languages
20:00:40 <SamB> try "nonterminal termchars = liftM NT (noneOf (" |\n":termchars))"
20:01:03 <SamB> instead of the previous version
20:01:41 <SamB> oopes, type error
20:01:51 <SamB> nonterminal termchars = liftM NT (noneOf (" |\n"++termchars))
20:01:52 <SamB> rather
20:02:02 <SamB> (used : where ++ was needed)
20:02:21 <SamB> okay, now it works better ;-)
20:02:26 <SamB> *CFG> parseTest (rhs "sz") "sN | z"
20:02:26 <SamB> [[T 's',NT 'N'],[T 'z']]
20:02:45 <SamB> that looks nicer, and, better yet, it is the right answer
20:03:06 <Frederick> wait
20:03:16 <SamB> wait what?
20:03:25 <SamB> you didn't get it working yet?
20:03:34 <Frederick> nope it is not compilling here
20:03:44 <SamB> whats the trouble?
20:03:47 <SamB> did you see:
20:03:54 <SamB> <SamB> oopes, type error
20:03:55 <SamB> <SamB> nonterminal termchars = liftM NT (noneOf (" |\n"++termchars))
20:04:22 <Frederick> yep it complains about multiple definitions of nonterminal
20:04:30 <SamB> oh, thats a new version
20:04:31 <Frederick> but Im not defining it again
20:04:34 <SamB> oh
20:04:52 <SamB> are you sure?
20:05:07 <Frederick> nope the version Im using is the same Ive posted to you, please post your version to me so I can run a diff
20:07:01 <SamB> arg, I'm having trouble with pasting.
20:07:12 <SamB> Emacs just doesn't play nice sometimes!
20:08:00 <int-e> > 2^1024 == round (1/0)
20:08:01 <lambdabot> True
20:08:05 * Frederick is using kdevelop now
20:08:30 <soysauce> uh ho... what does one use to debug a Haskell program which is in an infinite loop?
20:08:39 <SamB> actually, I think this is mozilla's fault
20:08:48 <Frederick> soysauce, prays :p
20:08:52 <soysauce> haha
20:09:09 <int-e> ah ok, it's just using the mantissa/exponent formula for the representation of infinity.
20:09:50 <SamB> oh, its a character set issue
20:09:55 <Frederick> int-e, I had a teacher who used to say that infinity is any greatness bigger than an stupidillion
20:10:23 <soysauce> weird
20:10:26 <Frederick> where a stupidillion is the biggest stupid number you can imagine
20:10:32 <int-e> Frederick: well, the good thing about is is that round(1/0) >= round(anything that's a number)
20:10:42 <int-e> err >
20:10:54 <int-e> > round (1/0 - 1/0)
20:10:56 <lambdabot> -26965397022934738615939577861835371004269654684134598591014512173659901370
20:10:56 <lambdabot> 825144469906271598361130403168017081980709003648818465322162493373927114595
20:10:56 <lambdabot> 921118656665184013729822791445332940186914117917962442812750865325722602351
20:10:56 <lambdabot> 369432221086966581124085574502576602687944735992086890771957445725303449443
20:10:56 <lambdabot> 6336205824
20:11:00 <Frederick> SamB, what charater set issue?
20:11:23 <int-e> > round (1/0 - 1/0) < round (-1/0)
20:11:24 <lambdabot> True
20:11:40 <lisppaste2> SamB pasted "my version" at http://paste.lisp.org/display/13530
20:12:16 <SamB> can't paste anything containing ¬£ from emacs to Mozilla
20:12:43 <SamB> emacs just doesn't have any kind of decent unicode support.
20:13:12 <SamB> or maybe its that if I install it I can't use nxml-mode or rng-validate-mode
20:14:03 <SamB> dons: I just got a nasty burp
20:14:16 <SamB> I'm going back to the beginning of the song to see if it is reproducable
20:15:15 <SamB> @type 1/0
20:15:15 <lambdabot> forall a. (Fractional a) => a
20:15:26 <dons> cool. i know there's still one bug with clrtoeol. and i got some weirdness with really huge arg lists
20:15:38 <SamB> > round 1/0 :: Rational
20:15:39 <lambdabot>  add an instance declaration for (Integral Rational)
20:15:48 <SamB> > round (1/0 :: Rational)
20:15:50 <lambdabot> Ratio.%: zero denominator
20:16:54 <dons> SamB, also perhaps grab the latest code
20:17:05 <fnord123> does haskell have first class contnuations in monad.Cont ?
20:17:23 <SamB> fnord123: you are expecting second-class continuations?
20:17:33 <SamB> only it is called Monad.Cont
20:17:38 <SamB> @index callCC
20:17:39 <lambdabot> Control.Monad.Cont
20:17:47 <SamB> Control.Monad.Cont
20:18:12 <SamB> hmm, looks kind of silly to just repeat what a bot just said ;-)
20:18:17 <fnord123> I'm a moron trying to promote Scheme in a forum and someone pwned me / Monad.Cont and I'm hoping I win.
20:18:18 <SamB> anyway:
20:18:37 <fnord123> I am teh lose.
20:18:38 <SamB> @doc Control.Monad.Cont
20:18:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
20:18:39 <Frederick> worked
20:18:45 <fnord123> thank you
20:19:06 <SamB> fnord123: if you get the impression that you are losing this argument, maybe you aren't actually a moron!
20:19:45 <SamB> granted, these continuations are comparatively rather restricted...
20:19:49 <Frederick> @localtime fnord123
20:19:52 <lambdabot> Local time for fnord123 is Sun Nov 13 04:13:38 2005
20:20:04 <Frederick> fnord you are just tired look you local time :p
20:20:31 <SamB> @localtime Frederick
20:20:33 <lambdabot> Local time for Frederick is Sun Nov 13 02:20:11
20:20:46 <Frederick> @localtime SamB
20:20:48 <lambdabot> Local time for SamB is Sat Nov 12 23:20:34
20:20:51 <fnord123> well, let m url you lot
20:20:58 <luqui> @localtime luqui
20:20:59 <fnord123> the forum is a bit shit anyway\
20:20:59 <lambdabot> Local time for luqui is Sat Nov 12 21:20:50
20:21:01 <SamB> Frederick: can you guess the code for "rule"?
20:21:08 <luqui> it's right :-)
20:21:09 <Frederick> trying
20:21:30 <fnord123> http://www.gamedev.net/community/forums/topic.asp?topic_id=357321
20:22:06 <fnord123> im on page2 w/ another f name. though i dont want to connect it since these urls are logged
20:22:16 <fnord123> in fact I use a uhhhhhhhh q nam
20:22:18 <fnord123> name
20:23:24 <luqui> heh, that's a silly thread
20:23:41 <luqui> once upon a time I started a project like that
20:23:51 <luqui> then I discovered that there were languages out there that already had what I wanted
20:24:03 <luqui> and they were implemented by people who actually knew what they were doing
20:24:17 <Frederick> SamB, the basic Idea is rules productions = ... right?
20:24:57 <SamB> Frederick: mm, I would say the function would start "rule termchars ="
20:25:19 <SamB> by analogy with every other parser that we have written thus far
20:26:48 <Frederick> SamB, but even for productions?
20:27:02 <Frederick> my analogy lead my to a different direction
20:27:16 <SamB> Frederick: well, where do you think we are going to get termchars from?
20:27:29 <SamB> did you think we were going to wire it into rules?
20:27:50 <SamB> note that rhs stands for right-hand-side
20:28:03 <Frederick> SamB, yeah it is like induction we are building a structure based on previous definitions
20:28:48 <SamB> hmm, I notice we don't really have any use for the (ProdName, ...)
20:28:54 <SamB> only the ...
20:29:09 <SamB> so you could change:
20:29:11 <SamB>                      productions :: Map (Symb t nt) [(ProdName,[Symb t nt])]}
20:29:13 <SamB> to
20:29:21 <SamB>                      productions :: Map (Symb t nt) [[Symb t nt]]}
20:29:42 <soysauce> it is unnecessary to use a monad for I/O in an eager language, right?
20:30:09 <SamB> soysauce: well, yes, but it can be a pain not to even so
20:30:40 <soysauce> hm
20:30:43 * soysauce is thinking
20:30:43 <SamB> just because *just about every single eager language in existence doesn't use monads* doesn't mean that that is a good thing
20:30:51 <soysauce> I know, I know
20:31:08 <soysauce> but I want to develop a functional-like language for use at work in our debugger
20:31:24 <soysauce> which would allow the user to enter in expressions that execute target-side
20:31:53 <SamB> you could use monads and just not explain how scary that idea is
20:31:56 <soysauce> the terseness of Haskell makes it very attractive; however, I have no desire to spend half my life on this, so whatever is easier that gets the job done... :p
20:32:00 <SamB> or call them "warm fuzzy things"
20:32:05 <soysauce> haha
20:32:36 <soysauce> problem is that I still don't really understand monads
20:32:48 <soysauce> I use them without understanding what they are
20:32:54 <Frederick> SamB, the definition for rules productions is the same ofproductions terms chars isnt it? Cause for a Production with no right side weretuen the production?
20:33:03 * Frederick needs to clarify these last contructions
20:33:21 <SamB> there is no such thing as a production with no RHS.
20:33:43 <liyang> terminal?
20:33:43 <SamB> a production will need to parse a nonterminal, an " -> ", and then an rhs
20:33:52 <Korollary> soysauce: Do you mean it's unnecessary to use monads for i/o in an 'impure' language or 'eager' language ?
20:34:02 <soysauce> a terminal isn't a production
20:34:31 <liyang> well no, but it seems like that's what Frederick meant.
20:34:32 <soysauce> Korollary - what is the exact difference between impure and pure? I seem to be confusing 'impure' with 'eager'
20:34:51 <SamB> nevermind that the things we are parsing are rules, which can define any number >0 of productions
20:34:52 <Frederick> productions = production <|> termchars `sepBy` string " -> "
20:34:58 <Korollary> soysauce: impure allows side effects. eager is a matter of evaluating something now or later.
20:35:15 <soysauce> hm yes, sorry, impure is what I meant...
20:35:23 <SamB> Frederick: that doesn't make sense to me
20:36:02 <soysauce> impurity and eagerness are related, though
20:36:04 <SamB> try to do the Siplest Thing That Could Possibly Work\trademark
20:36:14 <soysauce> in an eager language you have fewer problems with impurity
20:36:35 <Frederick> Im trying to say that a production is a nonterminal associated with termchars or nonterminals (found 1 mistake) sepBy " -> "
20:36:36 <SamB> soysauce: I don't think there is too much point in monads in impure languages
20:36:50 <SamB> the point of monads is to allow pure but imperative programming
20:37:16 <SamB> Frederick: but, we are parsing a rule
20:37:17 <Korollary> SamB: I think monads are implemented in scheme, ocaml, etc. as well.
20:37:21 <Frederick> SamB, should I say that a production contains other productions or nonterminals?
20:37:39 <SamB> and a rule is a nonterminal followed by a " -> " followed by an rhs
20:37:40 <soysauce> SamB - yes, I know
20:38:10 <soysauce> if I understand correctly, monads permit sequencing, though they do not *require* it. Sequencing implies a monad, essentially
20:38:15 <coumbes> soysauce: how does a eager language have fewer problems with impurity. ML is not pure but eager I believe, were haskell is lazy but pure?
20:38:36 <SamB> well, all monads I have seen do some sort of sequencing...
20:38:54 <soysauce> coumbes - if data can change, then a lazy language has big problems since there may elapse a *long* time between when a computation is created and when it is actually executed
20:39:02 <soysauce> but in an eager language the distance is minimized
20:39:50 <Korollary> soysauce: impurity doesn't imply "volatile"
20:40:11 <soysauce> I know. I didn't say that there were *no* problems. I said there were fewer problems.
20:40:18 <SamB> also, I think the way monadic programming works in haskell depends on purity just as much as the laziness does
20:40:36 <coumbes> but if you have a pure language then a function should always return the same result for the same parameters so it lazyness should have nothing to do with it because order of eval does not matter correct?
20:40:54 <SamB> because thunks representing functions and those representing expressions are minimally different...
20:40:55 <Korollary> soysauce: If there are any problems, I don't think they are about evaluation strategies.
20:41:05 <soysauce> coumbes - that's looking at things backwards
20:41:23 <SamB> coumbes: well, it could just as well be strict, yes
20:41:32 <SamB> but I haven't heard of any of those *yet*
20:41:47 <soysauce> hm
20:41:49 <SamB> at least, not practical ones
20:42:03 * soysauce does not know how a monad would be implemented...
20:42:03 <SamB> I've heard rumours of a monadic ML
20:42:26 <SamB> but nothing of substance
20:42:35 <Korollary> I know there are monad implementations in scheme, and scheme is strict and impure. apparently somebody has a need.
20:43:18 <SamB> what I haven't heard of is a strict, pure, practical language.
20:43:27 <SamB> unless you count SISAL, maybe.
20:43:45 <Korollary> well, pure languages are rare, so it's not unusual.
20:44:01 <sh10151> is laziness that important?
20:44:34 <SamB> true
20:44:36 <Korollary> sh10151: There are some really cool things that lazyness enables. It's an idea. Some people don't like it that much.
20:45:05 <SamB> the thing is, being pure practically requires monads in order to do imperative things without getting a REALLY bad headache.
20:45:34 <SamB> and the previous scheme would have been IMPOSSIBLE in a strict language, at that!
20:45:51 <SamB> it involved lazy lists of input and output
20:45:54 <SamB> it was really crazy
20:46:06 <SamB> dons should tell you about it, cause I didn't see it firsthand
20:46:18 <int-e> @type interact
20:46:19 <lambdabot> (String -> String) -> IO ()
20:46:28 <Korollary> SamB: The old way is explained in the Tackling the Awkward Squad paper.
20:46:50 <SamB> Korollary: hmm, true!
20:47:44 <SamB> so its not reall a surprise that pretty much all the pure, practical languages are lazy
20:48:14 <SamB> the technology to create a pure, practical, strict language has only been invented quite recently!
20:48:30 <Korollary> What technology is that ?
20:48:45 <SamB> which is to say, sometime in the last decade or so
20:48:49 <SamB> Korollary: monads.
20:48:57 <Korollary> strict ?
20:48:58 <SamB> ironically.
20:49:40 <SamB> Korollary: well, maybe not always. but in general, at least.
20:50:09 <fworp> is the implication that linear/uniqueness types are not practical?
20:50:33 <SamB> fworp: okay, well, maybe they are.
20:50:38 <SamB> but they are even scarier sounding than monads!
20:50:55 <Frederick> SamB, oki I think Ive cooked up the concept so I will need a lhs for rules that is a nontermnal sepby string -> right?
20:51:02 <SamB> especially linear, cause I actually know what those are
20:51:10 <Frederick> and a rhs rules that is a productin?
20:51:13 <fworp> SamB: but much simpler to understand. though in the languages that implement them, not that easy to use
20:51:29 * int-e gets a headache imagining a pure, strict evaluation version of memoizing data structures.
20:51:36 <SamB> Frederick: you don't need to use sepBy for a rule
20:51:57 <Frederick> SamB, why not?
20:52:15 <Frederick> SamB, but mainly I will have both lhs and rhs right?
20:52:23 <SamB> oh, and I'm not sure I would count linear types as pure
20:52:27 <SamB> Frederick: well, I mean, besides the use in the rhs
20:52:50 <Frederick> SamB, what do you mean?
20:52:55 <SamB> sepBy is for when you have a potentially repeated thing seperated by a seperator
20:53:05 <Frederick> hm
20:53:14 <int-e> and that's a thing you really want to have - caching expensive computations that are evaluated on demand.
20:53:45 <Frederick> bah Im lost again rofl I will make a draft on paper brb
20:54:36 <SamB> int-e: okay, so maybe its not THAT practical.
20:54:48 <SamB> int-e: but that is a challange for the strict-language people to overcome
20:55:00 <SamB> Frederick: I hafta go to bed now!
20:55:14 <Frederick> SamB, np I will read about it
20:55:20 <Frederick> we meet tommorow if you are around
20:55:39 <Frederick> I ned to cook up some ideas cause Im recieving a lot of new info into a very small space of time
20:55:42 <int-e> SamB: sure. I'd be quite interested in a (practical) solution.
20:55:49 <Frederick> SamB, thx A LOT
20:56:13 <int-e> SamB: because I can't imagine how it'd look like :)
20:56:21 <int-e> SamB: good night
20:57:12 <SamB> Frederick: okay, I have written a definition but I will let you process more for now, in order to avoid causing a buffer-overflow in your brain
20:57:28 <SamB> I really wouldn't want to be left with the core file for that one...
20:58:06 <Frederick> SamB, thx a lot, else I would have a buffer overflow on my brain and oly god knows what I would erase :p
21:02:14 <Frederick> folks thx a LOT for all the time help patience and stuff I gtg bed too 3 am here cya
21:37:10 <soysauce> in there any way in GHCi to access non-exported functions from a module that I wrote?
21:54:16 <Lemmih> soysauce: Nope.
22:07:24 <soysauce> suckage.
22:08:52 <soysauce> hmm, data Graph = Graph {mappings :: [(String, Int)]}
22:08:55 <soysauce> mappings isn't a function?
22:09:02 <soysauce> oh nevermind.
22:09:25 <soysauce> I was modifying the wrong file
23:34:18 <araujo> Hello Haskell'ers!!!!!
