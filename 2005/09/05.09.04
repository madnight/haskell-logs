01:26:55 <basti_> hi
01:51:15 <z0d> hello
01:53:56 <z0d> which implementation is better for learning? (if that's a reasonable question)
01:57:21 <ndm> are you on windows?
01:57:43 <z0d> I'm on Unix (specifically Linux now)
01:57:51 <ndm> i'd recommend hugs
01:58:03 <ndm> its the fastest to get to grips with
01:58:04 <Cale> I'd personally recommend ghc
01:58:11 <ndm> and then moving to ghc after
01:58:22 <Cale> I think the error messages are usually better
01:58:38 <ndm> but ghc tends to be slower at compile time, which is a disadvantage
01:58:40 <ikegami--> then you can get both of them :)
01:58:44 <Cale> and ghci has the nice feature that you can define things with let
01:59:04 <ndm> true, i'm not sure there is much in it - maybe try out both
01:59:14 <ndm> they function pretty similar, same keyboard commands etc.
01:59:55 <ndm> although i think the easiest way is to move to windows and use WinHugs, thats very nice and friendly for beginners
02:00:39 <z0d> I don't have a windows machine. I'll try both, thank you
02:01:15 <Cale> ndm: how is it different from running hugs in a decent terminal emulator under linux?
02:01:27 <ndm> drag and drop to open files
02:01:30 <ndm> friendly file dialogs
02:01:41 <ndm> hyperlinks for errors, so it opens the file at the appropriate place
02:01:45 <ikegami--> if you are using Debian, it is quite easy to install them
02:01:57 <ndm> pretty colours (not sure if thats on linux or not)
02:02:02 <ikegami--> (I guess another distribution also provides packages
02:02:05 <ndm> options are controlled through gui's
02:02:42 <ndm> Cale, its not that different but it does feel nicer
02:03:57 <Cale> hm... gone?
02:07:13 <Cale> I find the largest difficulty I have when sitting down at a windows machine is finding a decent terminal.
02:07:15 <ikegami--> in my opinion, it is also important to choose integrated editor
02:07:22 <ikegami--> for learning Haskell
02:07:39 <Cale> Vim and Emacs both have reasonable Haskell support
02:08:00 <ikegami--> right
02:09:04 <Cale> I wonder how yi is doing... I was going to work on that, and got sidetracked by school :)
02:09:36 <basti_> so-so
02:10:08 <basti_> my emacs-workalike frontend is stagnating, I'll need just a little more motivation to have it make sens
02:10:32 <Cale> I'd like to see a really killer Haskell mode for it :)
02:10:51 <basti_> hmm actually someone has spliced out ghc's parser
02:11:29 <basti_> that should be a cool basis
02:27:29 <Lemmih> Use the GHC library and you'll get type-checking and type-inference, too.
02:30:45 <Cale> I wonder how well those work if the file is not compilable though.
02:40:51 <z0d> grr. apt want to remove darcs when I install ghc6
02:40:53 <z0d> wants
02:41:19 <ulfdoz> re
02:41:22 <z0d> I wonder what conflicts
02:42:57 <ulfdoz> Yes I have.
02:43:01 <ulfdoz> ECHAN, sorry
02:43:05 <ulfdoz> *wirr*
02:51:24 <pejo> Cale, the visual haskell article has some notes about it. Seems hard.
03:06:26 <metaperl> "Building Web Services the REST Way" - http://www.xfront.com/REST-Web-Services.html
03:13:31 <xerox> 'morning
03:17:04 <xerox> lispy_: what is too bad?
03:17:26 <goron> Did you also experience that Freenode was down?
03:19:02 <basti_> hmm
03:19:10 * basti_ experiences freenode stutters currently, too
03:54:11 <Micket> Hello guys! im experiencing some problems with GHCi 6.4 for windows (xp). It simply closes when i try to do pretty much anything unless its something really really simple
03:54:36 <Micket> if a list or whatever im trying to look at is slightly to big, it closes without warning
03:55:29 <Micket> running the simpliest checks with quickcheck seems to be out of the question
04:03:15 <Lemmih> Try keeping the console open so you can see the error message.
04:08:15 <Micket> it doesnt give me any error message.
04:08:59 <Lemmih> It just exits with error code 0?
04:10:28 <Micket> I dont see error code anywhere either. it just closes instantly. and im back to the command prompt on the next row.
04:11:46 <Lemmih> Does 'echo $?' make sense on a Windows box?
04:11:55 <pejo> Heh, exactly what I was thinking.
04:12:14 <Micket> http://rafb.net/paste/results/9XirAJ49.html
04:12:18 <Micket> this is what im getting
04:12:28 <Micket> with pretty much any function, anywhere in the progress.
04:12:52 <Micket> Uhm, i dont think it does Lemmih >_<
04:13:15 <Lemmih> Did you hit C-c?
04:13:31 <Micket> no
04:13:49 <greenrd> Use Linux. Then you'll avoid this problem.
04:14:08 <Lemmih> greenrd: Seen it before?
04:14:11 <Micket> yeah i know.. some day..
04:14:19 <greenrd> Lemmih: No, I was joking.
06:17:40 <z0d> is the 8 space wide TAB still needed, or I can use 4 space wide tabs?
06:18:00 <Igloo> Don't use tabs
06:18:03 <basti_> z0d: use spaces.
06:21:03 <z0d> ok
06:21:35 <xerox> I also like 2 spaces, and proper alignment of wheres and lets
06:31:04 <ski> xerox : what do you mean by proper alignment ?
06:32:40 <xerox> foo .. = bar
06:32:40 <xerox>   where baz =
06:32:40 <xerox>         quux =
06:32:40 <xerox>         fnord =
06:33:03 <xerox> Instead of using 2 spaces everywhere:
06:33:06 <xerox> foo .. = bar
06:33:06 <xerox>   wherebaz =
06:33:06 <xerox>         quux =
06:33:06 <xerox>         fnord =
06:33:08 <xerox> Oops sorry.
06:33:11 * cjb gets frustrated by Go.
06:33:17 <xerox> foo .. = bar
06:33:18 <xerox>   where
06:33:18 <xerox>     baz =
06:33:21 <xerox>     quux =
06:33:24 <xerox>     fnord =
06:33:31 <xerox> cjb: why so?  Losing? :-(
06:33:46 <Philippa> heh, I'm slowly starting to play...
06:33:53 <cjb> Yeah.  You'd think someone who hates losing so much wouldn't play games.  :)
06:34:04 <xerox> Philippa: cool, you did play lately?
06:34:31 <Philippa> last game was probably a week back against my boyfriend. Might be playing a friend later today
06:34:31 <xerox> cjb: you could play (and win) me!
06:34:42 <ski> xerox : ah, ok (i indent suchwise, too)
06:35:18 <Philippa> I often line up the where with the = in the parent function
06:35:21 <ski> hm .. or ..
06:35:42 * ski usually does :
06:35:45 <ski> foo .. = bar
06:35:47 <ski>   where
06:35:50 <ski>   baz =
06:35:54 <ski>   quux =
06:35:57 <ski>   fnord =
06:36:27 <xerox> ...also I find myself never using lets, heh.
06:36:39 <ski> not often
06:36:56 * ski wonders who aligns '::' with '='
06:37:31 <Philippa> I don't, though sometimes I feel like aligning patterns and their matching types
06:37:52 <xerox> I do align the '=' in patter matching
06:38:20 <ski> i do that, at times .. but i dislike code in which '::' and '=' is aligned
06:39:48 <Philippa> yeah, that just breaks you up when you're trying to read the type
06:39:56 <Philippa> "uh? WTF's all this whitespace for?... oh"
06:39:57 <xerox> Usually it takes more time to align the '=' because of the "otherwise" guard than writing functions, heh.
06:40:18 <Philippa> I align the = sometimes, but I'm not religious about it by any means
06:41:36 <xerox> I am, in fact.  I need to please the eye with well-shaped code :-)
06:42:50 <ski> i'm too
06:44:22 <Philippa> I do keep to <80 columns, I'd probably line up more often if I didn't
06:44:34 <Philippa> actually, I'd probably have written a macro to do it for me if I didn't
07:24:43 <greenrd> @help doc
07:24:44 <lambdabot>  @help <command> - ask for help for <command>
07:24:52 <greenrd> @help docs
07:24:53 <lambdabot> library documentation
07:24:59 <greenrd> @docs Debug.Trace
07:25:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug.Trace.html
07:27:49 <greenrd> @pl (\s -> Debug.Trace s s)
07:27:51 <lambdabot> (Debug .) . join Trace
07:28:03 <greenrd> @type join
07:28:11 <lambdabot> bzzt
07:28:40 <greenrd> @pl (\s -> Debug.trace s s)
07:28:41 <lambdabot> (Debug .) . join trace
07:28:51 <greenrd> @pl (\s -> trace s s)
07:28:52 <lambdabot> join trace
07:36:29 <dodecahedron> I love oatmeal and meat
07:36:31 <dodecahedron> hehe
07:36:40 <dodecahedron> Oatmeat !
07:36:56 <dodecahedron> Oatmeal and mutton
07:37:34 <dodecahedron> Cale: GHC (The Glasgow rendition) is the finest implementation so far IMO
07:37:37 <dodecahedron> I concur
07:37:55 <dodecahedron> Oatmeal and mutton is very popular in Scotland too
07:37:57 <dodecahedron> :P
07:38:07 <dodecahedron> Consequently there is even oatmeal in haggis
07:38:54 <dodecahedron> Micket: These things where really meant to run on unix and they where ported to windows as an afterthought
07:38:57 <dodecahedron> imo
07:42:08 <olliej> gah... there are so many ways in which the output of ghc -fext-core doesn't match what it is suppose to  be
07:43:20 <Igloo> How do you mean?
07:43:45 <greenrd> How unhelpful: "a.out: Prelude.read: no parse"
07:43:58 <greenrd> Doesn't haskell have something like stack traces?
07:44:17 <dodecahedron> Well GHC was made within the unix environment I think .. using GHC in windows is kind of like using perl in windows it doesn't make much sense
07:44:19 <Igloo> It's recommended to use reads and throw sensible errors yourself
07:44:20 <dodecahedron> :P
07:44:35 <Igloo> But compiling with -prof -auto-all and using +RTS -xc might help
07:45:18 <greenrd> huh?
07:45:24 <greenrd> What does all that mean?
07:45:48 <olliej> Igloo: a variety of things
07:46:14 <olliej> Igloo: grammar doesn't specify the use of exponents in numeric literals
07:46:30 <olliej> Igloo: select statement grammar doesn't match documented grammar
07:47:13 <arjanb> fext-core seems more like a input language for ghc than anything else :/
07:47:19 <olliej> hehe
07:47:32 <olliej> arjanb: or a point to start writing a backend :)
07:47:59 <arjanb> i'm trying that
07:48:06 <greenrd> Igloo: How do I use the profiling results to tell me where the error occurred?
07:48:14 <olliej> arjanb: what are you targetting?
07:48:23 <xerox> Who was I talking about profiling with last time?
07:48:28 <arjanb> jvm
07:48:47 <olliej> arjanb: oh the pain -- how are you dealing with non-strict evaluation?
07:48:48 <xerox> I found that is possible to profile programs linked to libraries whose aren't compiled with profiling.
07:48:57 <olliej> arjanb: I'm targetting the CLR :)
07:50:27 <arjanb> it's no more pain that the CLR i guess
07:50:50 <olliej> arjanb: i didn't like the parametric typing implementation in the jvm
07:51:24 <olliej> arjanb: it seemed yucky as it isn't at the VM level
07:51:58 <arjanb> i don't use parametric types at all
07:52:19 <olliej> yes, but haskell does
07:52:30 <olliej> how do you get around it?
07:53:20 * olliej notes another bug in type system...
07:53:40 <arjanb> make everything a subclass of one abstract base class
07:53:55 <olliej> ah
07:54:59 <arjanb> i think retaining the types in compiled code has little use
07:55:22 <olliej> hmmm
07:55:51 <olliej> arjanb: i'm trying to keep my implementation as interoperable with external code as possible
07:56:38 <olliej> which causes a whole slew of other problems... and there's making primitive types go as fast as possible
07:56:49 <arjanb> you mean having foreign CLR declarations or something?
07:57:03 <olliej> not at the moment
07:57:19 <olliej> but there's nothing to stop any language from using a dll i produce
07:57:31 <olliej> so it needs to appear marginally sane
07:57:45 <olliej> the other trick was making the non strictness as transparent as possible
07:58:38 <greenrd> You'll need to wrap callbacks appropriately in the FFI, otherwise you break referential transparency, obviously.
07:59:01 <olliej> currently i ignore ffi
07:59:22 <olliej> as core can't represent ffi types/functions
07:59:35 <greenrd> well what I mean is you can't just let arbitrary external code pass in arbitrary functions as "functions", because they might not be referentially transparent
07:59:59 <greenrd> So most functional code that accepts functions as arguments will have to be ... private I guess?
08:00:13 <olliej> currently spending vast amounts of time implementing vast quantities of libraires
08:00:36 <olliej> greenrd: it's a problem ... currently just saying the programmer shouldn't be dense :)
08:00:42 <greenrd> hehe
08:02:09 <olliej> greenrd: the big one is getting more or less arbitrary haskell compiling directly to the CLR
08:03:10 <greenrd> olliej: so how do _you_ deal with non-strictness?
08:03:57 <olliej> greenrd: for a type data Foo = Bar Int | Wibble Float
08:04:24 <olliej> you end up with a base class Foo with three subclasses Bar, Wibble, and thunk
08:04:46 <olliej> thunk is just that, it merely wraps up a function the generates a Foo
08:05:26 <olliej> unfortunately while the C# supports user defined cast operators the CLR desn't so access to a constructor is through as methods
08:05:32 <olliej> asBar, asWibble
08:05:49 <olliej> in the thunk class these functions trigger evaluation
08:06:18 <olliej> to make type switches work reasonably quickly there's also a tag property
08:06:27 <olliej> and that also triggers evaluation inside the thunk
08:08:59 <olliej> and thus non strict evaluation occurs (or rather it doesn't :) )
08:10:37 <greenrd> ah I see
08:10:54 <olliej> hopefully i'll have a paper written up in a week or so
08:11:07 <olliej> given i'm at a conference in a fortnight
08:11:12 <olliej> presenting it...
08:11:21 * olliej whistles nonchalantly
08:13:10 <olliej> currently my compilers output runs around 80% slower than ghc direct to architecture
08:14:29 <arjanb> only 80% ?
08:15:30 <olliej> that's for something trivial like the eratosthene sieve finding the first 1000 primes
08:15:47 <olliej> that said it still breaks in annoying cases
08:15:56 <olliej> just recently i realised that
08:15:59 <olliej> foo 1 = 3
08:16:04 <olliej> foo 2 = 1
08:16:10 <olliej> foo 3 = 5
08:16:14 <olliej> foo  _ = 0
08:16:17 <olliej> would break it
08:16:28 <olliej> as it screws up the special casing of Int
08:16:32 <olliej> grrr...
08:24:24 <olliej> arjanb: no i lie -- at a 100 it's 80% slower (still being masked by IO)
08:24:46 <olliej> arjanb: at 1000 it's ~half to a third the speed
08:25:53 <olliej> one of it's big problems is it continuously wraps up things like plusInt in a new fnction object, which chews through cputime
08:26:43 <arjanb> yeah primitives handling can make a big difference
08:29:13 <olliej> i currently munge calls to plusInt straight into '+' or whatever, the way i handle boxed primitives means that this "just works"
08:29:46 <olliej> unfortunately the compiler is somewhat trigger happy with the creation of new objects...
08:38:42 <greenrd> So, I still have my problem that I mentioned earlier.
08:39:07 <greenrd> How can I find out where a "read" parse error is occuring in my code?
09:30:44 <greenrd> Is there much work on functions returning proofs as well as answers?
09:31:29 <greenrd> I want to rewrite a function into one that not only gives me the answer, but demonstrates to me that the answer is correct
09:32:27 <greenrd> I'm not talking about fancy language extensions - I just mean programming techniques for doing that
09:32:41 <basti_> @hoogle Int->[a]->[a]
09:32:42 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
09:32:42 <lambdabot> Prelude.take :: Int -> [a] -> [a]
09:32:42 <lambdabot> List.genericTake :: Integral a => a -> [b] -> [b]
09:33:07 <xerox> greenrd: I don't exactly understand what you want, maybe QuickCheck?
09:35:13 <greenrd> xerox: No, I'm not looking for a unit testing tool. I'm just wondering if there are any papers or articles on writing programs which output demonstrations that their calculations are correct.
09:36:13 <ulfdoz> isn't that a theorem proofer?
09:36:22 <greenrd> I dunno, is it?
09:36:44 <ulfdoz> And where do you get the _correct_ specification for your function which describes what actually is correct.
09:36:44 <greenrd> Note that I'm not asking for proofs that the whole program is correct for all valid inputs - that is a harder problem.
09:37:01 <greenrd> (which I'm also looking into, but not right now.)
09:37:05 <ulfdoz> A function is some kind of program.
09:37:31 <greenrd> yes, well, just assume that the specification is correct.
09:38:00 <greenrd> Here is a simple example.
09:38:03 <ulfdoz> greenrd: That add 3 4 evaluates to 6 doesn't necessarily mean, that the function is wrong only because it's  called "add".
09:38:29 <greenrd> Suppose I write a function that tells me if two long lists are equal.
09:39:02 <greenrd> And it outputs "unequal". But the lists are too long for me to check by eye if they are in fact unequal.
09:39:18 <ulfdoz> So you have to proof all constraints to equality.
09:39:21 <greenrd> So I want it to output "lists differ at position 653"
09:39:31 <greenrd> and then I can just easily verify that for myself
09:40:27 <greenrd> that is a toy example, of course, not a realistic example
09:40:33 <ulfdoz> could be hard for infinite lists. :)
09:40:34 <greenrd> but I hope you get my gist
09:40:36 <greenrd> heh
09:40:41 <greenrd> ok, assume finite lists
09:41:04 <ulfdoz> but basically this is testing which _not_ implies correctness.
09:41:13 <greenrd> Oh, absolutely.
09:41:27 <ulfdoz> Have you had a look at hunit?
09:41:29 <greenrd> In this case, I don't care yet about inputs I haven't tried yet.
09:41:36 <ulfdoz> http://hunit.sourceforge.net/
09:41:39 <greenrd> The thing is, I am lazy.
09:42:03 <greenrd> I don't want to write code to check that the answer is correct, I want to output a demonstration that I can check myself in my head.
09:42:22 <greenrd> well, ok, that might not be much easier, so perhaps "lazy" is the wrong word.
09:43:02 <greenrd> "not trusting my programming abilities" would be more accurate.
09:43:16 <greenrd> If I write a test harness, it might also have bugs.
09:43:27 <greenrd> If I output a demonstration that is trivial to check in my head, that is safer.
09:43:35 <ulfdoz> with my experience from junit: Most code is generated as template automatically, a general function, which tests that for every arbitrary function probably is impossible.
09:44:01 <ulfdoz> At least with junit we generated output which gave us additional information.
09:45:53 <greenrd> so a junit-style of thing would not be what I need for this task
09:46:39 <xerox> You want functions to throw spectacularly helpful and meaningful exceptions :-)
09:46:54 <greenrd> no, not exceptions
09:47:11 <greenrd> This is for non-exceptional, purportedly correct behaviour.
09:47:20 <greenrd> So that I can check that the behaviour _is_ in fact correct.
09:47:53 <greenrd> Something like "This is so because this and this and this is so, which in turn is because..."
09:48:12 <greenrd> But not in incomprehensible detail.
09:48:25 <greenrd> Just the bare outlines, enough to verify things for myself.
09:48:40 <xerox> ...and with natural-language/voice commands!  We could sell it.
09:48:43 <xerox> Sorry, just kidding.
09:48:48 <greenrd> hehe
09:48:52 <ulfdoz> hrhr
09:49:32 <ulfdoz> sounds like defining constraints and to verify them on semantics of the language.
09:49:42 <greenrd> instead of a -> b it is a -> (b, Why)
09:50:09 <greenrd> ulfdoz: No, I already said, I don't want to verify for all inputs, not yet. THat is a much harder task which is not my focus right now.
09:51:49 <humasect> @index Why
09:51:51 <lambdabot> bzzt
09:52:02 <xerox> humasect: it was pseudofantasycode.
09:52:09 <humasect> ^_^
09:52:10 <greenrd> No, just a type.
09:52:14 <greenrd> It could be String, for instance.
09:52:26 <greenrd> Probably would be, unless it was meant to be massaged by other code.
09:52:27 <xerox> OK, it was just something not defined atm.
09:52:30 <greenrd> yeah
09:52:42 <humasect> i like haskell's pseudo Maybe/Either suchlikes.
09:53:05 <xerox> greenrd: btw it's exactly what I thought when you first described it, along with State.
09:53:10 <humasect> when unless maybe either
09:54:07 <ulfdoz> greenrd: Do you look for something like assertions?
09:54:35 <greenrd> ulfdoz: No. I'm already using assertions. I think you just are not reading my words very carefully.
09:54:55 <ulfdoz> hm, probably.
09:56:44 <greenrd> So for example we can consider a modified "and" function.
09:56:47 <greenrd> @type and
09:56:52 <lambdabot> [Bool] -> Bool
09:57:54 <greenrd> we could have an "andReason" which is [Bool,String] -> (Bool,Maybe String) which returns the result plus the label of the counterexample, if there is one.
09:58:18 <greenrd> I mean "label" as a string is just an example - something to identify each input.
09:58:40 <ulfdoz> greenrd: I try to summarize: Assume we have a function a -> bool. If the function returns false, you want the counter example, for the test it made. Ist it what you mean?
09:58:41 <greenrd> Need not be a string.
09:58:50 <greenrd> ulfdoz: Yes!
09:58:58 <greenrd> ulfdoz: That's an example of what I want.
09:59:11 <xerox> You do need to give some details to the compiler I think.
09:59:14 <ulfdoz> ah, rereading helps. :)
10:00:31 <greenrd> xerox: What do you mean?
10:01:03 <xerox> How far can the compiler go with case testing without "bounds" or something?  But I'm only guessing
10:01:07 <ulfdoz> The counterexample thing makes me remembering a modelchecker. The test was, wether an finite automaton fulfills conditions in a temporal logic. If the at least one constraint evaluated to false, we returned a series of states, for which the constraints didn't hold.
10:01:26 <greenrd> ah, cool
10:01:44 <greenrd> was that in Haskell?
10:02:03 <ulfdoz> No, java. And really bad code I wouldn't make public to protect myself. :)
10:02:10 <greenrd> hehe
10:02:56 <ulfdoz> At least the gui was a mess, but me wasn't responsible for it.
10:03:07 <greenrd> xerox: I'm not really asking for compile-time computation here. As I said, proving that it works for ALL inputs is NOT what I'm interested in right now.
10:03:32 <xerox> I was wondering "for what values of ALL".
10:03:44 <greenrd> For 1 value.
10:03:46 <greenrd> My input.
10:03:58 <greenrd> I don't care about anything else, until I decide to input it.
10:04:01 <greenrd> I am lazy that way.
10:04:06 <greenrd> ;)
10:04:07 <xerox> Anyway, I'm not much help to you.
10:05:48 <xerox> Do you know of an introduction about how to make a parser?
10:05:54 <greenrd> np - I suspect this has to be done in function-specific ways, that don't generalise very well.
10:07:44 <xerox> I can understand combinators and such, but how do you convert matched things to an AST, for example?
10:07:54 <ulfdoz> Or you build a datastructure which represents the automaton for your program. The input defines which states in which order are active. In each state you verify your constraint. This is just a sketch. Probably your automaton changes with input or isn't even deterministic or finite.
10:08:18 <Akshaal> hail
10:10:11 <greenrd> hi
10:44:35 <xerox> Is there a more effect way than |head $ map (\p -> if (fst p) == 'a' then p else (' ',""))| to get a (Char,Foo) out of a [(Char,Foo)] ?
10:45:01 <xerox> *effective
10:45:22 <basti_> :-o
10:46:43 <basti_> xerox: "head"?
10:46:48 <greenrd> hehe
10:46:55 <xerox> @type Data.List.find
10:47:02 <xerox> Hmm!
10:47:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:47:03 <greenrd> @type Data.List.lookup
10:47:05 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
10:47:13 <xerox> Oooooh.
10:47:21 <xerox> It saves a .fst :-P
10:47:33 <xerox> BTW, great.
11:21:13 <Cale> greenrd: re: your comment about read and stack traces -- stack traces are somewhat meaningless in a lazy language, since things are evaluated by demand.
11:23:38 <TheHunter> "12 items or less" is that wrong???
11:29:37 <rep> faut qu ca glisse et puis que ca transpire
11:30:13 <greenrd> Cale: Yes, I figured that out. :(
11:30:59 <basti_> rep: uhm.
11:37:41 <rep> err
11:37:42 <rep> sorry
11:42:13 <Cale> greenrd: however, that failure to parse is an exception which you can catch in the IO monad.
11:43:26 <greenrd> cool
11:43:30 <Cale> greenrd: and there are good ways to make a version of read which returns a value of type (Maybe a)
11:44:09 <lisppaste2> greenrd pasted "Why can ghc not see my methods?" at http://paste.lisp.org/display/11368
11:45:10 <lisppaste2> greenrd annotated #11368 with "errors received" at http://paste.lisp.org/display/11368#1
11:45:11 <Cale> r
11:45:33 <Cale> That looks like an instance of a class called "Proven" rather than what you want it to be
11:45:37 <greenrd> ah
11:45:43 <greenrd> I want it to be an instance of Monad
11:45:55 <Cale> instance Monad m => Monad (Proven m p) where
11:46:09 <Cale> "If m is a Monad, then Proven m p is a Monad"
11:46:35 <greenrd> ah yes, I see
11:48:49 <Cale> there will be some additional type errors
11:50:46 <Cale> (Proven mp a) >>= f  -- here f is a function of type (a -> Proven m p b).
11:51:34 <Cale> you want the result of the whole computation to be of type Proven m p b and not Proven m p (Proven m p b)
11:52:13 <Cale> It's sort of annoying that join and liftM are off in the Monad library and not optionally ways to define a monad rather than using >>=
11:52:43 <Cale> but basically, you need to write something of type Proven m p (Proven m p b) -> Proven m p b
11:55:40 <xerox> What a feeling when you write a type signature, then a function, C-c C-l (i.e. load the module in GHCi) and it, just, works.
11:55:51 * xerox enjoys the moment
11:58:36 <Cale> xerox: :)
11:59:41 <xerox> @where fps
11:59:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
12:06:41 <xerox> Does "runhaskell Setup.hs haddock" work for you in fps?
12:12:42 <Cale> I'll try it
12:14:23 <xerox> *LSystems> length $ result 7 ("F+-","F-F-F-F",[('F',"F-F+F+FF-F-F+F")])
12:14:24 <xerox> 15578843
12:14:24 <xerox> (10.74 secs, 522637644 bytes)
12:14:30 <Cale> "No description file found, please create a cabal-formatted description file with the name <pkgname>.cabal"
12:14:39 <xerox> I wonder if using fps it will do better.
12:15:28 <xerox> (What it does is substituting "F-F+F+FF-F-F+F" for 'F' in "F-F-F-F" and its successors n times, 7 in that particular case)
12:18:23 <xerox> Cale: if you build it before, what does it say?
12:34:29 <Cale> xerox: oh, I'm silly, there are two cabal files here, I'm obviously supposed to choose between them
12:34:54 <xerox> Cale: right.
12:39:26 <xerox> Cale: would you like to take a look at the current implementation?  Maybe you could give me some hint to optimize it, if fps isn't really needed.
12:39:46 <Cale> "Fail: dist/build/tmp/Data/FastPackedString.hs: openFile: does not exist (No such file or directory)"
12:39:52 <Cale> xerox: sure
12:39:59 <xerox> Same error here!
12:40:03 <xerox> http://paste.lisp.org/display/11370
12:43:11 <Cale> hmm...
12:44:17 <Cale> there are functions isJust and isNothing for testing which choice you have, not that that should make a huge difference
12:44:47 <xerox> @type isjust
12:44:51 <xerox> @type isNothing
12:44:59 <Cale> @type isJust
12:45:01 <xerox> How would you write it?
12:45:02 <lambdabot> bzzt
12:45:02 <lambdabot> bzzt
12:45:04 <lambdabot> bzzt
12:45:09 <Cale> @type Maybe.isJust
12:45:11 <lambdabot> forall a. Maybe a -> Bool
12:45:25 <Cale> @type maybe
12:45:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:45:32 <xerox> AH!
12:45:41 <xerox> That's the function I was searching for.
12:45:44 * xerox fixes
12:48:08 <Cale> I think the cost is occurring with all the lookups
12:48:25 <xerox> Ah.  It makes sense...
12:48:59 <xerox> Two things: DOLS will have just 1 rule that maps a Char to a String
12:49:08 <Cale> If you were to perhaps use a Map to store them rather than an association list, it would be faster
12:49:45 <xerox> ..Non-determinist OLS will have many rules for each Char (which I'll pick up randomly, with weights, in my best dreams)
12:50:15 <Cale> Whenever you see the type [(a,b)] occurring in your program it might be a sign that something inefficient is going on :)
12:50:53 <xerox> hehe
12:51:21 <xerox> Let's see how to use the Map.
12:51:24 <xerox> @docs Map
12:51:25 <lambdabot> Map not available
12:51:31 <xerox> Mumble.. :-)
12:51:33 <Cale> @docs Data.Map
12:51:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
12:51:49 <Cale> are there currently lots of productions?
12:51:59 <xerox> Nope.
12:52:01 <Cale> hmm
12:52:24 <Cale> those lookups shouldn't cost too much then, but it's probably a good idea to make that a Map anyway
12:52:25 <xerox> In a DOLS, are even less than length alphabet
12:52:36 <xerox> example alphabet "Ff-+"
12:53:04 <xerox> In this case I'd probably get a rule only for 'F' 'f'.
12:53:37 <xerox> in the non-deterministic one, I'll get multiple productions for each item in teh alphabet (modulo '-' '+')
12:54:31 <Cale> ah, if you actually look at  result 7 (...)  it's rather large :)
12:54:38 <xerox> Oh yes!
12:54:45 <Cale> There's exponential blowup in the size of the data
12:55:01 <xerox> Urgh, fps could be really needed.
12:55:04 <Cale> It's probably a good thing that it's all evaluated lazily :)
12:56:10 <Cale> whoa
12:56:17 <Cale> and there are a ton of results too
12:56:34 <Cale> with one production rule, shouldn't there be just one?
12:58:14 <xerox> Hehe
12:58:17 <xerox> It's because of the axiom
12:58:23 <xerox> boegel implemented it as a Char
12:58:41 <xerox> I implemented it as a String, to do more interesting things (e.g. Koch's snowflake).
12:58:56 <Cale> hmm...
12:59:30 <xerox> I'll show you a thing:
12:59:37 <Cale> but that still shouldn't give any more than one result, looking at the intent of this code
12:59:56 <xerox> Hmm, I misunderstood you..?
13:00:05 <Cale> since there's only one axiom and only one way to expand on each step, no?
13:00:09 <xerox> What do you mean with a "ton" of results?
13:00:12 <xerox> Exactly.
13:00:17 <xerox> Just one.
13:00:24 <Cale> there are over 1000 results
13:00:41 <xerox> Different possible results ?!
13:01:41 <Cale> yeah
13:02:23 <xerox> How did you find it?
13:02:42 <Cale> map (\x -> ()) $ results 7 (...)
13:03:11 <xerox> Oh-uhm
13:03:59 <xerox> result returns a String..
13:04:39 <Cale> oh
13:04:53 <xerox> Maybe it isn't a good name :-)
13:04:57 <xerox> Better ideas?
13:05:10 <Cale> oh, that's fine -- I just wasn't watching the types
13:05:30 <Cale> I figured that with all the nondeterminism going on that it would give the whole lot of them
13:05:43 * xerox pokes Cale
13:06:06 <xerox> In the non-deterministic one (which isn't implemented atm), it will still give one result.
13:06:14 <xerox> Which will be different every time.
13:06:31 <Cale> oh, okay
13:06:47 <Cale> Usually nondeterminism means keeping track of all the possible results
13:07:03 <xerox> This is a nice idea.
13:07:08 <Cale> "The list monad models nondeterminism"
13:07:22 <xerox> I heard that while ago :-)
13:07:37 <xerox> How would you apply that idea here?
13:08:56 <xerox> Hmm.
13:08:58 <Cale> well, let's see -- we're already using it to some extent, though it's not that obvious :)
13:09:15 <xerox> Firstly, do you think it's worth it trying? :-)
13:10:06 <Cale> well, if you need to be able to handle results that are this large, and it's already an efficiency concern, then the efficiency is not going to be improved :)
13:10:14 <Cale> but you can certainly do it with little trouble
13:10:39 <xerox> Let me try implement the most useful function, then I'll show it to you.
13:14:49 <xerox> It's a bit tricky, I'll give a try with mdo.
13:19:41 <ulfdoz> bye
13:19:49 <Cale> ulfdoz: later
13:21:47 <xerox> Mumble.
13:22:35 <xerox> Cale: does it make sense? http://paste.lisp.org/display/11370#1
13:23:01 <Cale> paste.lisp.org is slow for me btw
13:23:15 <Cale> ah
13:23:21 <Cale> I see what you're doing :)
13:23:37 <xerox> :-D
13:23:50 <xerox> I suspected you would have understood :-D
13:23:56 <Cale> I think you might need MonadPlus m
13:24:03 <Cale> not sure
13:24:24 <xerox> One solution would be mapM_ iterate, I think...
13:24:29 <xerox> But it would be a pain.
13:25:23 <Cale> a should be String I think
13:25:31 <Cale> unless you're generalising the alphabet type
13:25:41 <xerox> Eh.
13:26:03 <xerox> In my app m would be ReaderT Cairo IO a, a.k.a. Render
13:26:32 <Cale> oh, hmm...
13:26:45 <Cale> That's a different monad than I expected :)
13:26:51 <xerox> :-D
13:27:35 <Cale> ah, okay
13:27:55 <Cale> so you're generalising this thing in a different direction than I expected :)
13:28:20 <xerox> Please tell me what would you have expected
13:28:51 <Cale> Oh, I expected that you were going to handle the nondeterminism with an arbitrary monad.
13:29:08 <xerox> Oh-uhm.
13:29:15 <Cale> Like, if you used the list monad, it would give a list of all possible results, Maybe would give the first, etc.
13:29:37 <xerox> And !! would evaluate only the 'nth' one?
13:29:56 <Cale> oh, the iteration number would still be fixed
13:30:13 <xerox> Yep, I mean, between the list of results.
13:30:20 <Cale> yeah
13:30:24 <Cale> in the list monad
13:30:26 <xerox> It's interesting.
13:31:16 <xerox> You know what, I thought about the generalization in this direction to be able to stroke single lines in the path with alpha blending, giving a nice visual effect.
13:31:18 <Cale> well, !! may be very expensive with such a tree of computation, but then again it can throw away the first (n-1) strings, so maybe not so bad
13:31:27 <xerox> Oh, right!
13:31:35 <xerox> But your idea is really nice to not try it out.
13:32:05 * poetix has a moan about c2hs
13:32:17 <Cale> well, once you have it producing strings, you can convert those to actions in any way you see fit as another step
13:32:35 <Cale> (you don't have to do everything at once, it's lazy :)
13:32:43 <xerox> Hmm.
13:32:48 <xerox> WHOA
13:33:10 <xerox> Cale is open-eyer as much as SICP back when I was entering the FP world.
13:33:40 <xerox> (It was meant to be a compliment, hehe)
13:33:44 <Cale> This is what I mean when I say that laziness increases compositionality -- may I use your code in an example in a TMR article?
13:34:17 <xerox> poetix: please tell me, between this excitement I could have some time to answer your moans :-D
13:34:34 <poetix> I don't seem to have c2hs-config
13:34:56 <poetix> And so can't either add c2hs to the packages list for GHC, or get it to generate the options list that needs to be passed
13:35:01 <xerox> Cale: indeed, this rewrite is going to be part of a public release.
13:35:24 <xerox> poetix: mumble.  IIRC there was no need for one of the two things.
13:35:29 <poetix> But I built c2hs from source, and can't see any missing step I should have taken to get c2hs-config
13:35:45 <xerox> poetix: yea, you prolly don't need it.
13:36:30 <poetix> OK - but I still need to tell GHC where to find the C2HS library - 'cos right now, it's complaining that it can't find it
13:36:39 <xerox> Don't use C2HS.
13:36:59 <xerox> What do you use it for, as now?
13:37:19 <poetix> I don't - I just copied one of the example files and modified it, and the example file had an import C2HS statement in it...
13:37:33 <xerox> Cale: I didn't answer directly, yes, I'd love to be helping with my code in your article :-)
13:38:15 <xerox> poetix: maybe we could gobby it?  There are some sugars in C2HS.hs that aren't worth importing it _that_much_.
13:38:58 <poetix> Well, I just removed that import statement and ran c2hs again
13:40:02 <xerox> If you have the gtk2hs sources, you could see that I copied some handy marshallers from C2HS.hs in Cairo/Types.chs.
13:40:11 * beelsebob_ cacks his pants
13:40:17 <xerox> Cale: what were we up to?
13:40:34 <Cale> up to?
13:41:08 <xerox> withDOLSystem
13:41:41 <xerox> so, maybe it isn't the right name?
13:43:51 <xerox> Hmm, I'm lost, I think I had it before, hmpf!
13:45:03 <xerox> With a :: Int -> NOLSystem -> [String]  I could try to write a lazy implementation of a function which uses all the rules sequentially.
13:45:19 <Cale> yeah
13:45:39 <Cale> And make the rule type something like Map Char [String]
13:45:53 <xerox> Yes.
13:46:04 <xerox> Better to have an LSystems.hs o two separate files?
13:46:19 <Cale> not sure
13:46:50 <Cale> I'd probably leave it as one while working on it, and separate them later if it becomes a nuisance.
13:47:26 <xerox> Sorry, Emacs crashed...
13:47:30 <xerox> What did you say?
13:47:36 <Cale> <Cale> I'd probably leave it as one while working on it, and separate them later if it becomes a nuisance.
13:47:54 <xerox> I was wondering about the Types
13:47:56 <Cale> oh
13:48:13 <xerox> Now I need DOLProduction NDOLProuction or something
13:48:34 <Cale> well, a deterministic lsystem is just a special case of a nondeterministic one
13:48:40 <xerox> Right.
13:48:48 <Cale> you can generalise the result type by monad and do both at once
13:48:55 <xerox> Indeed.
13:49:33 <xerox> I do usually save the file and start a new one, as my Home RCS :-) heeh.
13:49:34 <Cale> Well, L-Systems with productions of the form String -> String are a bit trickier and probably best done separately
13:49:58 <xerox> I wasn't really thinking in doing it
13:50:34 <xerox> I mean, if you mean using "branch" instead of "A" I thought about writing a parser and keep using Char -> String productions.
13:50:43 <xerox> ...if you mean something different I don't know :-)
13:57:04 <Cale> oh, hmm...
13:57:32 <Cale> well, I mean basically the sort where you match the strings in the antecedents of the productions in all possible ways
13:58:45 <xerox> I think I'd better use list comprehensions this time
13:59:13 <Cale> hmm... I think the monadic view is fine :)
14:00:43 <xerox> It's difficult, mumble.
14:01:07 <poetix> xerox: Looks like I do want to import C2HS, one way or another
14:01:13 <xerox> poetix: why so?
14:01:37 <xerox> Anyway, one simple solution is to put it in your code hierarchy.
14:01:45 <xerox> But why you do really need it?
14:01:54 <poetix> GHC complains about not being able to find a bunch of things: withCString, CChar, CUInt, cIntConv
14:02:02 <poetix> Unless they're all in Foreign.x
14:02:13 <xerox> poetix: yeah, for the first three you need Foreign and CForeign
14:02:14 <poetix> and I need to import that instead...?
14:02:22 <xerox> cIntConv is rather simple.
14:02:26 <poetix> Ah, right - I got Foreign, but not CForeign
14:02:34 <Cale> xerox: one minute :)
14:02:44 <xerox> Cale: :-)
14:03:01 <Itkovian> pompom
14:03:04 <xerox> cIntConv = fromIntegral
14:03:18 <poetix> Just missing cIntConv now - oh, OK, there it is...
14:03:19 <xerox> cIntConv :: (Integral a, Integral b) => a -> b
14:03:21 <poetix> :)
14:03:31 <xerox> I told you! :-D
14:07:13 <xerox> I could make a list of Maps filtered this way, for start: map (\c -> filter (==c) productions) alphabet
14:07:29 <xerox> Or a Map of Maps?! :-D
14:07:38 <xerox> I'll wait Cale insights ;-)
14:08:06 <SyntaxNinja> dons: h4sh is a preversion of cabal ;)
14:10:45 <xerox> Oh-uhm, I was wrong.
14:21:18 <basti_> huhu
14:22:47 * boegel|home greets #haskell
14:23:24 * basti_ #haskells boegel
14:23:39 * boegel|home scratches his head
14:24:04 <boegel|home> does anyone know a sudoku solver which is able to generate all possible solutions for an incomplete sudoku ?
14:24:25 <basti_> prolog?
14:24:43 <boegel|home> basti_: :)
14:25:30 <poetix> I think mine can actually
14:25:51 <boegel|home> poetix: where ? the haskell one ?
14:25:57 <poetix> Yes.
14:26:27 <boegel|home> can you show me how? I have about 45mins to find the right solution of one (I can win a gps system) :)
14:26:34 <basti_> LOL
14:26:48 <z0d> in this expression: (\x y -> 2*x + y)    I need to mention y but not x. why?
14:27:23 <basti_> @remember boegel < boegel|home> does anyone know a sudoku solver which is able to generate all possible solutions for an incomplete sudoku ? | < poetix> I think mine can actually | < boegel|home> can you show me how? I have about 45mins to find the right solution of one (I can win a gps system) :)
14:27:25 <poetix> boegel: You need to modify the code to give you all the solutions it finds, rather than just the first
14:27:37 <basti_> z0d: ?
14:27:39 <boegel|home> basti_: you bastard :)
14:27:49 <basti_> actually, no.
14:27:50 <boegel|home> poetix: ow :s damn
14:28:04 <z0d> oh, because that's a free variable. sorry, nevermind
14:28:11 <basti_> z0d: no problem
14:28:12 <boegel|home> then I guess I won't be able to solve it in time....
14:28:39 <poetix> boegel: Don't be defeatist! Go and look at the code...
14:30:08 <xerox> Maybe it's just a take n :-D
14:30:28 <boegel|home> poetix: url ?
14:30:57 * boegel|home decides to give it a shot
14:31:02 <poetix> http://www.haskell.org/tmrwiki/SolvingSudoku
14:32:50 <boegel|home> poetix: do you have a single file with the source code in it, I dont have time to copy/paste all the stuff, I need to have time to check the solutions I receive too... (I hope that won't be 1,000 solutions or someting :p)
14:33:23 <poetix> boegel: It's literate haskell, just grab the lot and ignore the comments...
14:33:41 <boegel|home> poetix: hmm, kay
14:43:37 <boegel|home> poetix: what happens it your program can't decide if there is a solution ? does it just generate _some_ solution, or return False ?
14:43:55 <Cale> xerox: did it :)
14:44:03 <poetix> If there is no solution, it returns Nothing
14:44:18 <poetix> If there is any solution, it returns Just that solution
14:44:48 <poetix> You need to replace the Maybe monad with the List monad...:(
14:45:26 <xerox> Cale: ooooh.
14:45:41 <boegel|home> poetix: and I don't know crap about Monad's, so I guess that won't work :(
14:46:15 <poetix> Hey, I just remembered
14:46:24 <poetix> My first version wasn't monadic, and returned all the solutions...
14:46:25 <poetix> http://codepoetics.com/code/sudokusolver.hs
14:48:29 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:48:59 <Cale> (that's for xerox)
14:49:11 <xerox> Heh!
14:49:11 <boegel|home> poetix: w00 !
14:49:24 <xerox> Cale: I was somewhere near there.
14:49:44 <xerox> Cale: rather cool.
14:49:59 <Cale> xerox: I find the trick is to generalise it to lists first, then to the arbitrary monad -- much easier on the brain :)
14:50:19 <xerox> Cale: yeah, I'm watching a movie too so I'm slow :-D
14:50:19 <Cale> Lists are really the best example of a monad :)
14:50:20 <boegel|home> poetix: ((8,0),2) -> is the 8 the row or column number ?
14:50:41 <xerox> Cale: indeed, I think I'd liked to succeed myself, but thanks much!
14:50:57 <Cale> xerox: well, don't look too closely at my answer then :)
14:51:27 <xerox> the nice thing is that the structure is similar, if not identical
14:51:52 <xerox> but for expand.. it is hard :-D
14:52:13 <poetix> 8 is the column number (the 'x' coordinate)
14:52:20 <Cale> xerox: yeah, it took a bit of experimentation in ghci with :t there :)
14:52:44 <Cale> there may be a way to simplify that
14:52:48 <xerox> I was still playing with the Production type hehe
14:52:57 <xerox> Because I'd liked to pass it lists.
14:53:00 <Cale> @pl (liftM join . sequence)
14:53:01 <lambdabot> fmap join . sequence
14:53:20 <Cale> @pl (\f -> liftM join . sequence . liftM f)
14:53:22 <lambdabot> ((fmap join . sequence) .) . fmap
14:53:30 <Cale> nope, nothing
14:53:32 <xerox> gee.
14:57:19 <xerox> Mumble..
14:57:25 <xerox> type NDOLSystem = (Alphabet,m Axiom,Productions m)
14:57:26 <xerox> ?!
14:57:35 <newsham> hi
14:57:41 <boegel|home> omg, too many solutions :s
14:57:43 <Cale> yeah
14:57:48 * boegel|home cries
14:57:57 <Cale> boegel|home: what?
14:57:58 <xerox> Cale: I don't get m Axiom
14:58:27 <Cale> xerox: Well, there's no reason not to allow it to start with potentially multiple axioms
14:58:34 <boegel|home> Cale: I have an incomplete sudoku for a game (with which I can win a gps system), but there are too many possible solutions to try them all
14:58:38 <boegel|home> I have 13 minutes left
14:58:41 * boegel|home thinks fast
14:58:49 <xerox> Cale: hehe.
14:59:11 <newsham> thre are many sudoku solvers on the net.  see wikipedia for a list.
14:59:23 <boegel|home> @type (!!)
14:59:25 <lambdabot> forall a. [a] -> Int -> a
14:59:26 <TheHunter> sequence . liftM f === sequence . map f === mapM f
14:59:26 <xerox> Cale: anyway, what's the point of making it that generic?
15:00:14 <Cale> xerox: well, if you didn't say m Axiom, then you'd just end up using return to wrap the initial axiom anyway
15:00:51 <Cale> xerox: The point of making it general is that now we can handle all the cases you were talking about
15:01:09 <Cale> (Including probabilistic things)
15:01:57 <xerox> Oooh.
15:02:04 <xerox> I don't see it, but it's nice.
15:03:04 <Cale> TheHunter: ah, I wasn't thinking about that part of the composition...
15:03:05 <newsham> reverse xerox
15:03:36 <Cale> so it's down to  liftM join $ mapM apply axiom
15:03:40 <DeeJay_> sorry to interrupt, is  Constructor $ \x -> doSomethingWith x  just a more asthestic version of Constructor (\x -> doSomthingWith x)   or is there a difference
15:04:08 <xerox> newsham?! :-D
15:04:16 <Cale> DeeJay_: f $ x = f x
15:04:20 <Cale> yeah
15:05:09 <DeeJay_> thanks Cale, it seems a little odd to me to do it that way, but i spose it loses the need to parens
15:05:15 <DeeJay_> *for
15:05:52 <Cale> DeeJay_: yeah, it's common in Haskell when the thing inside the parens is large to do it that way
15:06:16 <DeeJay_> ah yeah that's a good point, thanks
15:08:57 <newsham> hmm.. list monads can be used to represent non-dterministic computations.  neatoh.
15:09:22 <xerox> Mumble.
15:13:22 <boegel|home> is there a simple way to filter the unique lines in a file using shell ?
15:13:37 <newsham> sort file|uniq
15:13:48 <TheHunter> nub
15:14:00 <newsham> the uniq command only works on sorted files though
15:14:06 <boegel|home> 449 possible solutions
15:14:08 * boegel|home wheeps
15:15:11 <xerox> Cale: hehe, very very nice.
15:15:38 * boegel|home gives up, since the deadline is over :(
15:15:44 <newsham> if you need uniq on unsorted data, its easy to write in a high level language .  in python     seen = {}; for line in file("input") : if l not in seen : { seen[l] = 1; sys.stdout.write(l) }
15:15:50 <boegel|home> thanks anyway poetix, nice Sudoku solver :) very powerfull
15:16:03 <boegel|home> it generate the 2929 solutions in no time :)
15:16:28 <Micket> uhm, hey guys, i could use some help.
15:16:29 <Micket> http://rafb.net/paste/results/M94g2G89.html
15:16:54 <Micket> problem on row 8
15:17:22 <Micket> result beeing [IO String] and i need [String]
15:17:24 <Micket> :/
15:17:42 <xerox> Cale: I wonder how to calculate the number of possible solution to drop and head now :-)
15:19:20 <newsham> anyone know why the word "monad" was chosen?
15:20:08 <newsham> oh, from cateogry theory, nevermind.
15:20:20 <gzl> yeah, but now you should ask why it was called monad in category theory. :)
15:20:34 <newsham> i already came across that in wikipedia
15:20:54 <newsham> monoid + triad or some such
15:21:26 <gzl> oh, really?
15:21:34 <moomlyn> has it got anything to do with Leibniz?
15:21:40 <gzl> oh yeah
15:21:44 <gzl> monoid + triad
15:21:45 <gzl> cool
15:22:10 <gzl> oh, I see. they're monoid objects in a certain category
15:22:14 <gzl> and they're triples
15:22:26 <gzl> good thing they didn't name it mople, that would have sucked
15:22:34 <newsham> but easier to type :)
15:22:47 <gzl> i dunno, the 'opl' is a little awkward
15:25:16 * TheHunter_ curses linux.
15:25:27 <newsham> whats the problem?
15:25:46 <TheHunter_> crashes when there's no memory left.
15:25:57 <TheHunter_> instead of JUST killing an application.
15:25:59 <newsham> do you have swap?
15:26:11 <Cale> I think taking the set theory route and naming them after an animal would have been good :)
15:26:15 <TheHunter_> i temporarily turned off swap in order to increase it.
15:26:29 <Cale> Instead of monads, call them raccoons.
15:26:46 <gzl> set theory is nuts
15:26:48 <newsham> cale: why not combinoids?
15:26:59 <gzl> iterable premice have no place in math :P
15:27:10 <Cale> newsham: that works :)
15:27:11 <gzl> and hand grenades and daggers
15:27:16 <newsham> hunger: why did you have to turn off swap to add some?
15:27:19 <Cale> gzl: :)
15:27:53 <TheHunter> low disk space...
15:28:25 <newsham> I'm thoroughly confused.
15:28:39 <newsham> you needed to shut off swap because you dont have enough space to add more swap space
15:29:28 <newsham> you're aware that you can have multiple swaps right?
15:29:41 <TheHunter> well, my swap is in a file so that it's easier to adjust and i wanted to save myself the trouble of messing with /etc/fstab
15:29:54 <newsham> you could have just made a second swap file
15:30:45 <Cale> xerox: So, you could now design a monad which computes the probabilities of various results...
15:30:59 <TheHunter> if i had known that would fuck up linux, i indeed would've done that.
15:31:06 <xerox> Cale: sound interesting, other than not really clear :-)
15:31:49 <TheHunter> plus, i didn't think that evolution, xchat and a shell would eat up 256MB of ram.
15:32:17 <TheHunter> it's linux fault it crashed, not mine.
15:32:46 <Cale> xerox: think about the type [(Float, a)] with the restriction that the floats in any list are between 0 and 1 and add to 1.
15:33:06 <newsham> hunter: depends on if you were using it properly or not
15:33:17 <newsham> not everything that is possible is allowed.
15:33:37 <newsham> for example, dd if=/dev/zero of=/dev/mem   may cause your system to crash.  thats not linux' fault
15:33:43 <Cale> xerox: is there a sensible way to turn that into a monad?
15:34:14 <TheHunter> but running out of ram is not a valid reason, that's for sure.
15:34:48 <newsham> perhaps they dont support running without a swap device?
15:35:11 <xerox> Cale: Mumble.  A reader with a Float?
15:35:31 <TheHunter> an OS that doesn't support running without swap is crap.
15:36:23 <Cale> xerox: you just have to work out return, fmap and join :)
15:36:29 <xerox> I don't know if "m (Float, a)" is a good answer
15:36:37 <xerox> Oh. hmm!
15:36:47 <TheHunter> just killing a random application (or maybe the first application to request memory) should prevent that.
15:37:01 <Cale> xerox: no, I mean, make the type [(Float, a)] into a monad by defining return, map, and join
15:37:25 <newsham> hunter:  great.  problem isolated.  you have source.  fix it.
15:37:38 <TheHunter> that's a WriterT Float [], btw.
15:38:12 <xerox> Urgh..
15:38:34 <xerox> return should randomly return it or not? hehe :-)
15:38:45 <Cale> return x = [(1,x)]
15:39:51 <xerox> @type fmap
15:39:52 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
15:39:52 <lambdabot> b
15:39:56 <xerox> @type Control.Monad.join
15:39:58 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:40:06 <TheHunter> i'm not feeling like digging through the linux sources right now. That doesn't deprive me of the right to complain, though.
15:40:10 <xerox> So the point here is fmap...
15:40:17 <Cale> fmap will be trivial
15:40:47 <xerox> I thought join would be, like summing or take the average of the weights
15:41:10 <Cale> fmap f xs = map (\(p,x) -> (p,f x)) xs
15:41:19 <Cale> join will have to multiply the probabilities
15:42:08 <Cale> join :: [(Float, [(Float, a)])] -> [(Float, a)]
15:44:20 <xerox> Ah-uhm!
15:44:59 <Cale> join xss = concatMap (\(p,xs) -> Prelude.map (\(q,x) -> (p*q, x)) xs) xss
15:45:37 <Cale> well, we can't use this type directly, of course, but something isomorphic to it will work
15:46:05 <xerox> I think I need some explanation, I would not have realised those by myself, hmm.
15:46:23 <Cale> okay
15:46:35 <Cale> you read my article MonadsAsContainers right?
15:46:38 <xerox> Yes
15:46:40 <Cale> okay
15:46:54 <Cale> so we have a container which stores the probabilities of the items stored inside it
15:47:12 <xerox> Let me re-read it, I surely do not remember the details
15:47:13 <Cale> we're trying to represent the idea that there's some probability of the result being each thing
15:47:15 <TheHunter> join xss = [ (p*q, x) | (p, xs) <- xss, (q, x) <- xs ]
15:47:22 <Cale> yeah, that's clearer
15:49:43 <xerox> So a Functor does not really need to contain multiple objects, I'm always thinking in terms of lists..
15:50:41 <xerox> But I still can't get why do you use map in fmap f xs = map (\(p,x) -> (p,f x)) xs
15:50:49 <TheHunter> i would probably use Rational instead of Float, if only to satisfy the monad laws.
15:51:06 <Cale> Yeah, Rationals are probably a better idea
15:51:20 <Cale> since you'll always be using fractions anyway
15:52:30 <TheHunter> otoh, you lose the monad laws anyway, once you move to quickcheck-like 'monte-carlo' nondeterminism.
15:53:50 <xerox> aaah
15:54:05 <xerox> Because our monad uses the list, simply.
15:54:57 <xerox> An "identity monad" instance for fmap would be something like fmap f xs = f xs?
15:55:49 <TheHunter> yep.
15:56:48 <xerox> Darn Emacs.  Sorry.  Did you say anything?
15:57:09 <TheHunter> I just said 'yes'.
15:57:24 <xerox> Oh, great.
15:57:59 <xerox> return a = [(1,a)] -- doesn't need explanation, ok..
16:00:19 <xerox> Trying to figure it out by myself: join xxs = [(p*q,y) | (p,xs) <- xxs, (q,y)] ?
16:00:39 <xerox> No way
16:00:41 <xerox> No wait.
16:00:57 <xerox> join xxs = [(p*q,y) | (p,xs) <- xxs, (q,y) <- xs]
16:01:26 <xerox> Right?
16:01:51 <TheHunter> @type \xss -> [(p*q,y) | (p,xs) <- xxs, (q,y) <- xs]
16:01:52 <lambdabot> bzzt
16:01:57 <xerox> I could have used x instead of y in fact, if it's ok,.
16:02:03 <xerox> Hmm. ok.
16:02:38 <xerox> @type \xss -> [(p*q,x) | (p,xs) <- xss, (q,x) <- xs]
16:02:40 <lambdabot> forall a b. (Num a) => [(a, [(a, b)])] -> [(a, b)]
16:03:13 <xerox> Yay!
16:03:14 <TheHunter> odd, weren't the terms alpha-equivalent.
16:03:48 <xerox> @t ype\xss -> [(p*q,y) | (p,xs) <- xss, (q,y) <- xs]
16:03:49 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
16:03:49 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
16:03:51 <xerox> @type \xss -> [(p*q,y) | (p,xs) <- xss, (q,y) <- xs]
16:03:53 <lambdabot> forall a b. (Num a) => [(a, [(a, b)])] -> [(a, b)]
16:03:59 <xerox> Uh?
16:04:31 <xerox> So now I understand what you meant with join.
16:05:00 <xerox> How would you call this monad?
16:05:34 <Cale> xerox: Probability lists, or weighted lists, or something like that
16:06:30 <newsham> one thing I find disturbing so far in learning haskell is that there seem to be two systems -- one for monadic programmign and one for non-monadic programming
16:06:32 <xerox> fmap and join are meant to be put in instance Monad?
16:06:39 <newsham> and they tend to have similar but different rules and keywords and syntax
16:06:44 <Cale> xerox: no, you can't unfortunately
16:07:10 <Cale> you have to use return and (>>=), but (>>=) can be defined in terms of fmap and join
16:07:41 <xerox> Yes!
16:12:36 <xerox> What kind of trick do I need to do to let GHC eat: instance Monad [(Rational,a)] where  ?
16:15:33 <xerox> data WeightedList a = WeightedList [(Rational,a)]  -- could work, no better way?
16:16:09 <Cale> you need to make a new data declaration, I think, or at least a newtype
16:16:19 <Cale> yeah
16:16:21 <xerox> Ok.
16:16:45 <xerox> So I have to add the constructor in few places
16:16:47 <Cale> because otherwise the mechanism for choosing instances of the Monad class would get confused
16:18:21 <TheHunter> instance Monoid Rational where mzero = 1; mappend = (*), newtype WL a = WL (WriterT Rational [] a) deriving (Functor, Monad)
16:18:43 <xerox> Eek
16:19:20 <xerox> Cale: any "MonoidAsNiceLittlePet" ? :-)
16:19:35 <Cale> xerox: heh
16:20:18 <Cale> xerox: a monoid is just a set with a binary operation such that the operation is associative, and there is an identity with respect to it
16:20:40 <xerox> What other things are a Monoid in Haskell?
16:20:55 <TheHunter> functions a -> a
16:20:57 <TheHunter> lists
16:21:28 <xerox> Oh.
16:21:45 <xerox> lists' mzero = [], mappend = (:)
16:21:50 <TheHunter> for every MonadPlus m, m a could be made a monoid
16:21:59 <TheHunter> mappend = (++)
16:22:01 <xerox> functions' mappend = ($), but what is mzero ?
16:22:04 <xerox> (++) right.
16:22:22 <TheHunter> no, mzero = id (= ($)), mappend = (.)
16:22:34 <xerox> uhuhuhuhuhuhuh
16:22:40 <xerox> I'm getting excited by this.
16:23:06 <xerox> Where does the WriterT comes from?
16:23:14 <TheHunter> oh, it's not mzero, it's mempty!
16:23:20 <xerox> mempty, ok!
16:23:31 <xerox> (What doc are you reading?)
16:23:38 <TheHunter> @docs Control.Monad.Writer
16:23:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Writer.html
16:24:53 <TheHunter> @docs Data.Monoid
16:24:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Monoid.html
16:24:59 <TheHunter> quite a lot of instances.
16:25:50 <xerox> Indeed
16:26:36 <xerox> Writer monad: "Computations which produce a stream of data in addition to the computed values." from Nomaware's, cool.
16:27:32 <xerox> I need to clean my glasses, hehe.
16:29:25 <xerox> The Monoid instance of functions is interesting
16:29:41 <xerox> "A monoid must obey some mathematical laws, such that applying the operator to any values from the set gives another value in the set, and whenever one operand of the operator is the identity element the result is equal to the other operand."
16:30:11 <xerox> That's why it is defined exactly for "a -> a"
16:30:35 <xerox> Because the domain and codomain should be the same
16:30:48 <xerox> Am I disturbing writing my thoughts here?
16:31:34 <basti_> i dont think so
16:41:49 <xerox> TheHunter, how are the weights handled in the WL Monad?
16:42:08 <xerox> tell &c?
16:47:21 <xerox> Mumble, Cale ping
16:47:26 <Cale> yeah?
16:47:36 <xerox> Where did the weights go? :-D
16:47:42 <Cale> in what?
16:47:54 <xerox> In TheHunter's WL
16:48:06 <Cale> instance Monoid Rational where mzero = 1; mappend = (*), newtype WL a = WL (WriterT Rational [] a) deriving (Functor, Monad)
16:48:08 <Cale> that?
16:48:10 <xerox> Yep
16:48:27 <Cale> Rationals store the weights
16:49:09 <xerox> I surely have to runWriter somewhere.
16:51:37 <xerox> Mumble.
16:52:11 <Cale> runWriterT :: WriterT w m a -> m (a,w)
16:52:38 <Cale> where m = [], and w = Rational
16:53:04 <Cale> so runWriterT :: WL a -> [(a,Rational)]
16:53:32 <xerox> Ah..
16:53:43 <Cale> It ought to be possible to have instances with restricted scope
16:53:52 <humasect> is there some convenient function for triple list partitioning?
16:53:57 <Cale> I really liked the named instances paper
16:54:10 <xerox>     Couldn't match `WriterT w m a' against `WL a1'
16:54:10 <xerox>       Expected type: WL a1 -> [(a1, Rational)]
16:54:10 <xerox>       Inferred type: WriterT w m a -> m (a, w)
16:54:15 <xerox> Hmm?
16:54:19 <xerox> > :t runWriterT :: WL a -> [(a,Rational)]
16:54:37 <Cale> hm
16:55:32 <Cale> oh, WL is a newtype
16:55:37 <xerox> Yes
16:55:56 <xerox> unWL needed?
16:55:58 <Cale> yeah
16:56:03 <Cale> oh
16:56:09 <Cale> or deriving MonadWriter
16:56:14 <Cale> perhaps
16:56:32 <xerox>     Can't make a derived instance of `MonadWriter WL'
16:56:32 <xerox>     (even with cunning newtype deriving:
16:56:32 <xerox>      `MonadWriter' does not have arity 1)
16:56:54 <xerox> We need to Monoid 'a' instead of Rational ?
16:56:59 <humasect> http://rafb.net/paste/results/Sw75Sh45.html
16:58:09 <xerox> I don't exactly know, heh.
16:58:23 <xerox> Hiya Pseudonym!
16:58:34 <Pseudonym> G'day.
16:58:57 <humasect> hmm
17:00:34 <xerox> Ah-ha
17:00:51 <xerox> Oh, nope.
17:02:33 <Cale> xerox: you could just write an instance of MonadWriter for it
17:02:41 <Cale> xerox: or use unWL
17:03:00 <xerox> I was trying unWL, /me will try both
17:04:00 <xerox> runWriterT . unWL :: WL a -> [(a,Rational)] :: forall a. WL a -> [(a, Rational)]
17:04:09 <xerox> OK.
17:04:17 <xerox> Let's see the MonadWriter instance.
17:04:50 <Cale> well, it's just boilerplate
17:05:08 <Cale> tell = tell . unWL
17:06:29 <xerox> Is it a recursive definition?!
17:07:14 <liyang> I imagine the two tells are from different instances of the same class.
17:07:14 <Cale> no
17:07:17 <Cale> yeah
17:07:46 <Cale> er
17:07:52 <Cale> yeah
17:08:01 <xerox> OK..
17:08:17 <Cale> listen, hmm...
17:08:30 <xerox> I can't find what should define the minimal definition.
17:08:33 <xerox> listen, ok.
17:09:10 <xerox> "The listen function turns a Writer that returns a value a and produces output w into a Writer that produces a value (a,w) and still produces output w.
17:09:11 <xerox> 2
17:09:42 <Cale> listen m = fmap (\(x,y) -> (x,WL y)) (listen m)
17:09:46 <Cale> I think
17:12:53 <Cale> pass m = pass (fmap (\(x,f) -> (x, WL . f . unWL)) m)
17:13:45 <xerox> Mumble...
17:13:58 <xerox> I'm stuck on the instance line
17:14:21 <xerox> instance MonadWriter (WL a) ... ?
17:15:31 <xerox> I'll not understand this code tomorrow morning :-)
17:15:31 <Cale> instance MonadWriter Rational WL ?
17:15:59 <xerox>     Couldn't match `WL a' against `Rational'
17:15:59 <xerox>       Expected type: Rational -> WL ()
17:15:59 <xerox>       Inferred type: WL a -> m ()
17:16:04 <xerox>     In the expression: tell . unWL
17:16:22 <Cale> oh
17:16:30 <Cale> yeah, I kind of messed up those types :)
17:16:33 <xerox> tell   :: w -> m ()
17:16:36 <Cale> right
17:16:54 <Cale> tell = WL . tell
17:17:10 <Cale> listen = WL. listen . unWL
17:17:20 <Cale> pass = WL . pass . unWL
17:17:38 <xerox> He liked    listen m = fmap (\(x,y) -> (x,y)) (listen m)
17:17:42 <xerox> OK, anyway.
17:18:02 <xerox> Which doesn't make sense hehe
17:19:05 <xerox> err
17:19:13 <xerox> What was the MonadWriter instance for? :-)
17:19:36 <xerox> oh, runWriterT.
17:21:14 <xerox> No wait, I can use runWriterT even without that instance
17:21:23 <xerox> I think I'm lost, could you show me an example usage?
17:23:32 <Cale> oh, you can use runWriterT without it?
17:23:40 <xerox> Mumble.
17:23:52 <Cale> I'm not actually trying any of this :)
17:24:03 <xerox> It eats the type without it
17:24:03 <Cale> perhaps I should be :)
17:25:21 <humasect> is there a tuple zipper =(
17:25:50 <Cale> humasect: like what?
17:25:57 <Cale> humasect: what would the type be?
17:28:25 <humasect> uh
17:28:36 <xerox> > (runWriterT . unWL) (WL (return "foo"))
17:28:36 <xerox> [("foo",1%1)]
17:28:54 <xerox> Without MonadReader
17:29:27 <Cale> the MonadWriter instance should just allow you to drop the unWL from that
17:29:39 <humasect> a zipper to make tuples i mean.
17:29:49 <humasect> wait.
17:30:26 <humasect> yeah i'm not very smart right now
17:30:50 <humasect> saturated with haskell the last few days.
17:31:05 * humasect returns to emacs mountain
17:31:37 <xerox> e.g.
17:31:40 <xerox> (runWriterT (WL "foo")) :: [([Char],Rational)]
17:31:47 <xerox>     Couldn't match `WriterT Rational [] [Char]' against `WL a'
17:31:47 <xerox>       Expected type: WriterT Rational [] [Char]
17:31:47 <xerox>       Inferred type: WL a
17:31:48 <xerox> ?
17:33:10 <Cale> oh
17:33:14 <Cale> I'm silly :)
17:33:31 <Cale> runWriterT is obviously not a method of that class
17:33:34 <Cale> heh
17:33:40 <xerox> err :-)
17:34:00 <xerox> @hoogle runWriterT
17:34:25 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Writer.html
17:34:30 <Cale> yeah
17:34:31 <xerox> Is it here
17:34:49 <Cale> it's part of WriterT
17:35:16 <Cale> so you can't really do anything but write a wrapper: runWL = runWriterT . unWL
17:35:20 <xerox> I don't get it
17:35:29 <xerox> A newtype has Instances?
17:37:10 <Cale> no, it doesn't
17:37:37 <Cale> that's the classes it belongs to
17:39:11 <xerox> What do we have achieved?
17:40:01 <TheHunter> xerox, you should be able to just derive (MonadWriter Rational)
17:40:03 <Cale> well, this monad, when used with the L-Systems thing, will let you compute the probabilities of certain words being formed
17:40:14 <Cale> based on the probabilities of reduction rules
17:40:29 <xerox> Cale: I don't get how to feed it the weights
17:40:45 <Cale> well, look at my tests
17:41:22 <Cale> it would be like the list one, only with weights attached to each possibility
17:41:33 <xerox> TheHunter: seems so!
17:41:48 <Cale> TheHunter: ah, thanks :)
17:41:52 <xerox> Cale: which part of this code does eat weights?
17:42:05 <Cale> xerox: the weights are taken care of by the monad
17:42:18 <Cale> xerox: you don't have to do anything special in the L-Systems code
17:42:20 <xerox> Yes they're inside the Writer, but..
17:42:35 <humasect> how do tuples become iterated? not able?
17:42:41 <xerox> *WeightedList> runWriterT (return "foo") :: [([Char],Rational)]
17:42:41 <xerox> [("foo",1%1)]
17:42:45 <xerox> Ok cool.
17:43:20 <Cale> bbiab -- going to return some CDs
17:43:44 <xerox> Bye Cale, thanks much.
17:46:33 <SyntaxNinja> hi Lemmih
17:48:01 <Lemmih> Hi.
17:48:57 <xerox> TheHunter: do you think Cale meant something like "Control.Monad.Writer.runWriterT $ result 2 ("F+-", ((return "F") :: WL String),fromList [('F', (return "F+F" :: WL String))])" ?
17:50:38 <TheHunter> result as on the paste page?
17:50:44 <xerox> Yes
17:51:06 <xerox> (I also added MonadPlus to WL derives)
17:51:08 <TheHunter> do we have a meaningful MonadPlus instance?
17:51:24 <xerox> Which isn't meaningful..
17:51:51 <xerox> @doc MonadPlus
17:51:52 <lambdabot> MonadPlus not available
17:51:59 <xerox> @index mzero
17:52:00 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
17:52:00 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
17:52:00 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
17:53:40 <TheHunter> there should be an invariant like sum (map fst m) = 1.
17:55:03 <TheHunter> mplus and mzero don't satisfy that invariant.
17:55:11 <xerox> mzero = [(undefined,1)] ?
17:55:58 <xerox> Oh, I see what you mean.
17:56:08 <TheHunter> i think it's impossible to make that thing a proper MonadPlus.
17:56:28 <xerox> We could cheat? :-)
17:56:35 <TheHunter> unless you're fine with probabilies not adding up to 1.
17:56:57 <xerox> It is not enforceable from outside?
17:58:08 <TheHunter> it's just called weighted list, so that might be ok, actually.
17:59:00 <SyntaxNinja> @seen shapr
17:59:01 <lambdabot> I saw shapr leaving #webwitches and #haskell 19 hours, 38 minutes
17:59:01 <lambdabot> and 30 seconds ago.
17:59:04 <xerox> I agree
18:00:14 <xerox> 02:50 am, yawn :-)
18:00:17 <TheHunter> but what you did there uses the WL monad only as a list monad anyway.
18:00:32 <xerox> Hmm, why exactly?
18:00:56 <TheHunter> all weights will be 1.
18:01:09 <xerox> Ah!  I thought before how to access those weights!!
18:01:13 <xerox> :-(
18:01:25 <xerox> s/access/mangle/ or something
18:02:23 <TheHunter> tell (1/2) >> return something
18:03:10 <TheHunter> tell (1/2) gives you [((), 1/2)].
18:03:30 <xerox> But as now I get
18:03:30 <xerox> Couldn't match `Control.Monad.Writer.WriterT w m' against `WL'
18:03:30 <xerox>       Expected type: Control.Monad.Writer.WriterT w m Axiom
18:03:30 <xerox>       Inferred type: WL Axiom
18:03:33 <xerox>      In the expression: (return "F") :: WL Axiom
18:04:03 <TheHunter> you forgot an unWL somewhere.
18:04:31 <TheHunter> you might wanna define runWL = runWriterT . unWL
18:05:26 <xerox> Doesn't deriving MonadWriter let me avoid it?
18:05:55 <TheHunter> nope.
18:06:38 <xerox> So now I get just a "No instance for (MonadPlus WL)" as we saw before
18:08:31 <TheHunter> didn't you say  you derived that?
18:09:58 <xerox> Oh right.
18:11:48 <xerox> Hehe..
18:12:04 <xerox> *NDOLSystem> runWL $ result 3 ("F+-", return "F", fromList [('F', return "F+F")])
18:12:04 <xerox> [("F+F+F+F+F+F+F+F",1%1)]
18:15:56 <TheHunter> now you can introduce nondeterministic rules.
18:16:01 <xerox> *NDOLSystem> runWL $ result 1 ("F+-", return "F", fromList [('F', return "F+"),('F', return "F-")])
18:16:01 <xerox> [("F-",1%1)]
18:16:01 <xerox> *NDOLSystem>
18:16:47 <xerox> runWL $ result 1 ("F+-", return "F", fromList [('F', tell (1/2) >> return "F+"),('F', tell (1/2) >> return "F-")])
18:16:47 <xerox> [("F-",1%2)]
18:17:05 <xerox> (I get the same result in both cases, in every consequent try)
18:17:55 <TheHunter> omit the tell (1/2) part in one of the rules, and see what happens.
18:18:42 <xerox> I get "F-" with n '-' as the number of iterations I do
18:18:59 <xerox> Ah Ooooops
18:19:15 <xerox> In one of the two values
18:19:52 <xerox> > runWL $ result 3 ("F+-", return "F", fromList [('F', tell (1/2) >> return "F+"),('F', return "F-")])
18:19:52 <xerox> [("F---",1%1)]
18:19:52 <xerox> > runWL $ result 3 ("F+-", return "F", fromList [('F', return "F+"),('F', tell (1/2) >> return "F-")])
18:19:52 <xerox> [("F---",1%8)]
18:20:36 <xerox> mmh.
18:21:23 <xerox> It calculates the probability?
18:21:54 <xerox> 2^3
18:21:59 <xerox> 1/(2^3)
18:22:29 <TheHunter> something like a probability.
18:23:09 <xerox> At least it does something, better than nothing for trying to understand it tomorrow morning.
18:23:32 <xerox> (03:15 am)  Thanks very much TheHunter, goodnight.
18:24:41 <TheHunter> good night, see you tomorrow
18:32:35 <dons> moin
18:40:10 <dons> Cale, generating haddocks from the fps src seems to only work with ghc 6.5. not sure why. I assume the 6.4 Cabal doesn't know how to run the preprocessor properly
18:40:52 <thebug> dons: where's your darcs repository again?
18:40:55 <Cale> dons: yeah, I was trying it for xerox
18:41:03 <dons> the docs are at http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html anyway
18:41:03 <thebug> I lost the URL for your site and the repo
18:41:09 <dons> @where fps
18:41:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:41:24 <thebug> :) thanks
19:01:12 <dons> Lemmih/anyone: is Hs-source-dirs: src
19:01:21 <dons> a new extension to Cabaal?
19:02:44 <Lemmih> dons: It's newer than Cabal-1.0, yes.
19:02:46 <dons> look like 6.4 doesn't like this line: *** Exception: Line 38: Unknown field 'hs-source-dirs'
19:03:03 <Lemmih> You can use hs-source-dir instead.
19:03:23 <dons> ah! ok. thank you Lemmih, once again
19:04:54 <dons> @karma+ Lemmih
19:04:55 <lambdabot> Lemmih's karma raised to 3.
19:05:52 <dons> Lemmih, you going to ICFP, by chance?
19:08:22 <dons> Lemmih, another Cabal question: how can I fix this with Cabal 1.0:
19:08:25 <dons> paprika$ runhaskell Setup.hs haddock
19:08:26 <dons> Preprocessing library fps-0.1...
19:08:26 <dons> Data/FastPackedString.hs: no cpphs preprocessor available
19:08:26 <dons> Running Haddock for fps-0.1...
19:08:26 <dons> Fail: dist/build/tmp/Data/FastPackedString.hs: openFile: does not exist (No such file or directory)
19:08:48 <dons> we have: extensions:          CPP, ForeignFunctionInterface
19:08:58 <dons> and haddock works if I use ghc 6.5
19:09:40 <newsham2> is thhere an easy way to deconstruct thhe results of a function returning a tuple?
19:09:47 <newsham2> ie   let a,b = fn   ?
19:10:10 <dons> let (a,b) = fn
19:10:20 <dons> case fn of (a,b) -> ... also
19:10:26 <Cale> xerox: if you get this, test3 = result 3 ("F+-", return "F", fromList [('F', WL $ WriterT [("",1/5), ("F+F",2/5), ("F-F",2/5)])])
19:18:03 <newsham2> ok, I hhave some code i know I'm not doing very intelligently.
19:19:09 <newsham2> basically I have a list of stuff, and I want to take one of them off the top and return it --   getOne d:ds = (d,ds)
19:19:22 <newsham2> so then later on I want to be able to take another one off the remainder
19:19:54 <metaperl> newsham2: what is your ultimate problem specification?
19:20:11 <metaperl> give us the big picture :)
19:20:24 <newsham2> thats a question asked alot here isnt it?  i dont thihnk its relevant but i'll play alon ganyway.
19:20:32 <newsham2> there's a deck of cards, you deal them out one at a time
19:21:07 <newsham2> nextCard :: [Card] -> (Card,[Card])
19:21:47 <newsham2> thhis is pretty similar to what thhe Random class looks like..
19:22:06 <metaperl> newsham2: because you might be breaking it down as a procedure/imperative/object-oriented person would... and that might not work so well in a pure functional language... that's why they ask I guess...
19:23:15 <metaperl> newsham2: I would wager that what you just gave as a type description for nextCard is not really the best one from a pure functional point of view
19:23:30 <metaperl> I forget who told me here, but a function should access something or modify something, but not both
19:23:51 <metaperl> your function nextCard is accessing the deck to get a certain Card *and* returning the modified deck
19:23:57 <newsham2> randomR :: RandomGen g => (a, a) -> g -> (a, g)
19:24:13 <metaperl> if you read the line processing example in SJT's book, you will see a different approach to a similar problem
19:24:16 <newsham2> randomgen accesses something and modifies something
19:24:24 <newsham2> err randomR
19:24:32 <metaperl> newsham2: what is randomR()?/////
19:24:37 <metaperl> newsham2: what is randomR()?
19:24:38 <newsham2> thats part of the Random module
19:24:45 <karma_> hello, isn't it possible to download "Haskell: The craft of functional programming" somewhere?
19:24:50 <newsham2> http://www.haskell.org/onlinereport/random.html
19:24:56 <metaperl> a standard part of haskell? oh I see, thanks
19:25:45 * metaperl examines randomR
19:26:25 <newsham2> randomR 1 10 g ->  randomnum,g'
19:27:44 <metaperl> 2-tuple is the first arg
19:27:50 <metaperl> randomR (1,10) g
19:27:53 <newsham2> yes, thhat
19:28:21 <metaperl> so you are trying to get the nth card from the deck and return the modified deck?
19:28:23 <newsham2> do i somehow want a monad that carries around the remaining deck?
19:28:29 * metaperl has to hit the can briefly?
19:28:32 <metaperl> brb
19:28:41 <newsham2> no, i want to take the top card, repeatedly to form hands
19:31:22 <newsham2> *reads more about State monad*
19:31:22 <metaperl> I'm back
19:31:34 <Lemmih> dons: Weird. Haven't seen that before.
19:31:40 <metaperl> newsham2: i dont think that monad is necessary... you should read SJT's book
19:31:53 <newsham2> have you read the book?
19:31:58 <metaperl> up to chapter 14
19:32:05 <newsham2> and you still dont have a good answer for me.
19:32:08 <newsham2> I tihnk i'll pass
19:32:13 <metaperl> and what you are describing appears do-able without monads
19:32:32 <metaperl> you want these two functions...
19:32:43 <metaperl> dealHand cardInHand deck
19:32:51 <metaperl> dealHands numberOfHands deck
19:32:58 <dons> Lemmih, the code is cpp'd. I don't have cpphs, only cpp. The only flag to say the src is cpp'd is the extensions constructor
19:33:11 <metaperl> you want to call dealHand to create numberOfHands decks
19:33:19 <metaperl> that doesnt require monads...
19:33:27 <metaperl> if you read that book, you would see that
19:33:48 * metaperl goes off to code it up... oh there's the issue of representing each Card, but that's trivial
19:33:54 <Lemmih> dons: Unfortunately, I can't afford traveling to Tallin. /-:
19:33:55 <newsham2> http://www.nomaware.com/monads/html/statemonad.html
19:34:02 <newsham2> looks exactly like the 'motivation' example
19:34:05 <ozone> Lemmih: where do you live?
19:34:15 <newsham2> (whihch doesnt use monads0
19:34:21 <Lemmih> ozone: Denmark.
19:34:27 <dons> Lemmih, maybe people usually specify cpp in the src file? or some other way.
19:35:31 <ozone> Lemmih: ah, for some reason i thought you were in the USA.  maybe it was in that weird dream with mary poppins
19:35:34 <metaperl> newsham2: look at the take and drop functions in the Haskell prelude
19:35:46 <newsham2> will do
19:35:49 <metaperl> they take n args from a list and remove n elements from a list
19:35:54 <metaperl> s/args/elements
19:35:55 <newsham2> yahh, familiar with take
19:36:00 <metaperl> that's all you need
19:36:21 <newsham2> not really.   try apply take twiceto the same list
19:36:24 <newsham2> you get the same thing
19:36:24 <metaperl> dealHand numberOfCards deck = take numberOfCards deck
19:36:42 <metaperl> that's where drop comes in
19:36:53 <metaperl> this is so easy if you read the line processing example in SJT's book
19:37:04 <metaperl> you want to apply take and drop in concert with each other\
19:37:20 <Lemmih> dons: I thought Cabal only used cpphs on files named *.cpphs.
19:37:40 <newsham2> metaperl: and then return the cards you took and the cards remaining after drop?
19:37:54 <newsham2> and then pass the remaining deck back in next time?
19:37:58 <newsham2> sounds like what the state monad is for
19:38:11 <metaperl> newsham2: there is no passing needed...
19:38:22 <metaperl> let's just say you have a list
19:39:00 <newsham2> show me code to take 10 sets of 5 cards from a list
19:39:47 <metaperl> first you take 5... then you do this 4 times drop . take 5
19:40:16 <metaperl> you can do that in the Haskell interpreter... I will paste the results
19:40:17 <metaperl> hold on
19:41:20 <newsham2> let l = [1 .. 52]; h1 = take 5 l; ...
19:42:43 <newsham2> let l = [1 .. 52]; h1 = take 5 l; h2 = take 5 l in (h1,h2)
19:42:43 <newsham2> ([1,2,3,4,5],[1,2,3,4,5])
19:43:10 <newsham2> let l = [1 .. 52]; h1 = take 5 l; l' = drop 5 l; h2 = take 5 l' in (h1,h2)
19:43:10 <newsham2> ([1,2,3,4,5],[6,7,8,9,10])
19:43:25 <metaperl> cards = [1..52]
19:43:25 <metaperl> firstHand = take 5 cards
19:43:25 <metaperl> nextHand lis = take 5 (drop 5 lis)
19:43:27 <metaperl> secondHand = nextHand cards
19:43:45 <dons> hmm. Lemmih, where's __GLASGOW_HASKELL__ here:
19:43:45 <dons> hcDefines :: Compiler -> [String]
19:43:46 <dons> hcDefines Compiler { compilerFlavor=NHC, compilerVersion=version }
19:43:46 <dons>   = ["-D__NHC__=" ++ versionInt version]
19:43:46 <dons> hcDefines Compiler { compilerFlavor=Hugs }
19:43:48 <dons>   = ["-D__HUGS__"]
19:43:51 <dons> hcDefines _ = []
19:44:01 <dons> in PreProcess.hs
19:44:28 * dons was wondering why the ghc-only functions didn't appear in haddock output
19:44:39 <newsham2> meta: so if I want to do that to grab 1,7,9,2,3 cards i have to keep track of theh accumulated number of cards each time?
19:44:41 <newsham2> great solution
19:47:56 <metaperl> cards = [1..52]
19:47:56 <metaperl> dropAmount = [ d*5  | d <- [0 .. 4 ] ]
19:47:56 <metaperl> hand cards = map (\d -> (take 5 $ drop d cards)) dropAmount
19:48:00 <metaperl> done
19:48:35 <metaperl> just run those 3 lines and you will get this
19:48:36 <metaperl> [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]
19:48:40 <metaperl> tada!
19:49:11 <Lemmih> dons: Hm.
19:50:47 <dons> e.g. we don't see packAddress here http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
19:50:51 <metaperl> newsham2: any feedback?
19:53:16 <newsham2> what if you want to grab one card, a list of 7 cards, a list of 9 cards, a list of 2 cards, and a list of 3 cards
19:53:56 <dons> Lemmih, hmm. I wonder if we could build the FastString used in packAddress at compile time.. i.e. use TH to call strlen on the Addr# statically.
19:54:21 <TheHunter> @eval let takeList [] _ = []; takeList (i:is) xs = ys: takeList is rest where (ys, rest) = splitAt i xs in takeList [7,9,1,2,3] [1..52]
19:54:23 <lambdabot> [[1,2,3,4,5,6,7],[8,9,10,11,12,13,14,15,16],[17],[18,19],[20,21,22]]
19:55:01 <dons> which would make construction of packAddress "foo"# an O(1) op at runtime insted of O(n)
20:00:55 <marcot> dons: hi!
20:01:14 <marcot> dons: Is h4sh already usable?
20:01:18 <marcot> dons: are you using it?
20:02:06 <dons> h4sh is stable and usable. I use it :)
20:02:12 <dons> so does Itkovian and others
20:02:34 <marcot> dons: I'll try it!
20:02:41 <dons> let  me know what you think
20:02:52 <marcot> dons: sure.
20:07:48 <TheHunter> ok, first time i ever used mapAccum*:
20:07:51 <TheHunter> @eval let swap (x,y) = (y,x) in snd $ mapAccumL (\xs i -> swap $ splitAt i xs) [1..52] [1,7,9,3,2]
20:07:53 <lambdabot> [[1],[2,3,4,5,6,7,8],[9,10,11,12,13,14,15,16,17],[18,19,20],[21,22]]
20:09:35 <marcot> dons: What cabal version is required?
20:10:07 <dons> should be ok with the version provided by ghc 6.4...
20:10:29 <dons> where "..." means "I might be wrong"
20:10:34 <marcot>     Can't find module `Distribution.Simple.LocalBuildInfo'
20:11:54 <marcot> strange, cause this file exists.
20:12:20 <dons> hmm. is runhaskell actually invoking ghc 6.4?
20:12:41 <humasect> gs (Constructor {record=w}) <- get    ... aww
20:13:08 <marcot> dons: i think it's.
20:13:48 <dons> I'm checking..
20:14:00 <marcot> dons: I think I got it.
20:14:41 <dons> does setting an explicit ghc version in the 'ghc' variable in the Makefile help?
20:14:56 <marcot> dons: add -package Cabal in Makefile.
20:15:15 <dons> oh. hmm. ok.
20:15:31 <marcot> Building h4sh-0.2...
20:15:31 <marcot> ghc-6.2.2: unknown package name: fps
20:15:38 <marcot> Now I've got other error.
20:15:41 <dons> ghc-6.2.2!
20:16:04 <marcot> dons: not supported?
20:16:26 <marcot> dons: what's this fps packages?
20:16:28 <dons> oh, hmm.  I guess it is :) but you need to install the FPS library, and hs-plugins, first
20:16:32 <dons> @where fps
20:16:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:16:37 <dons> @where hs-plugins
20:16:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:17:06 <dons> marcot, it's in the README ;)
20:17:25 <marcot> dons: ok... I'l get some sleep now and try this when I'm waken up.
20:17:29 <dons> btw, ghc 6.2.2 is untested. so I'm not sure what will happen..
20:17:56 <marcot> dons: good!
20:17:57 <marcot> =D
20:18:11 <marcot> dons: what about packaging these things for debian?
20:19:22 <marcot> I gotta go, good night.
20:23:47 <dons> hmm. ghc doesn't handle 1M unboxed string literals very well
20:25:54 <dons> neither does vim :/
20:26:17 * dons fires up yi
20:27:36 <Lemmih> Bah. No splicing of variables with kind # /-:
20:30:12 * dons likes saying :.!concat to join lines inside his editor
20:35:50 <Lemmih> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
20:35:50 <Lemmih>         DsMeta.repLiteral: trying to represent exotic literal "hello"#
20:36:32 <dons> nice
20:36:33 <Lemmih> I think GHC has a near infinite number of error messages.
20:36:39 <dons> @ghc
20:36:40 <lambdabot>  Type signature given for an expression
20:36:42 <dons> @ghc
20:36:43 <lambdabot>  Malformed predicate
20:37:00 <dons> perhaps it has an error message generated based on unfoldr
20:37:01 <humasect> =D
20:37:07 <dons> so it could be infinite!
20:37:18 <dons> an infinite lazy list of errors!
20:37:56 <dons> INLINE is nice
20:38:37 <dons> ghc isn't as keen to inline as I would have thought
20:39:52 <Lemmih> Hi SyntaxNinja.
20:40:03 <SyntaxNinja> hi Lemmih
20:40:24 <SyntaxNinja> Lemmih:  are you getting my barrage of emails :)
20:40:43 <dons> but at least with an INLINE on packAddress, packAddress "foo"# turns into: let addr = "foo"# in case strlen addr of wild -> PS addr PlainNoFinalizer 0 wild
20:41:13 <SyntaxNinja> dons: so is h4sh a shell?
20:41:50 <Cale> it's a bunch of commandline tools
20:42:26 <SyntaxNinja> ok
20:42:35 <SyntaxNinja> because I would like a shell I can script in Haskell :)
20:42:52 <dons> it's a bunch of shell utilities. than when combined with | and ; and () let you program in the pure part of haskell, or the List or IO monad in the shell
20:43:19 <SyntaxNinja> map (\filename -> mv filename (filename ++ ".bat")) *
20:43:47 <Lemmih> SyntaxNinja: Yeah, will get on it when I get time.
20:43:54 <dons> almost. currently h4sh only gives you the referentially transparent functions.
20:44:10 <dons> but i've got an idea for a Shell monad that would provide, say, mapS
20:44:15 <SyntaxNinja> Lemmih: wnat would you think of just uploading the new cabal-put and gpg? they fix some pretty important probs
20:46:58 <dons> oh this is nice. "foo"# really does compile to: static char c1ZB_str[] = "foo";
20:48:10 <Lemmih> SyntaxNinja: Too nervous right now. Will try to relax a bit.
20:49:33 <SyntaxNinja> nervous? what's up?
20:50:00 <SyntaxNinja> is nickserv down or something?
20:50:09 <SyntaxNinja> Lemmih: anyway, I got your envelope
20:52:41 <SyntaxNinja> @seen SyntaxNinja
20:52:43 <lambdabot> You are in #haskell. Last spoke just now.
20:52:54 <Lemmih> I may get a fine which will tremble my budget.
20:53:11 <SyntaxNinja> owch.  what for?
20:53:19 <SyntaxNinja> I'd privmsg you but NICKSERV SEEEMS TO BE DOWN
20:53:23 <SyntaxNinja> it's a conspiracy
20:53:55 <SyntaxNinja> btw, what would you all (all three of you that are here right now) think of trying to get a critical mass to get off this rock and onto a jabber server or something?
20:53:58 <Lemmih> Failing to show at the drafting center for the second time.
20:54:07 <dons> SytaxNinja, you probably ave to register with nickserv to do primsgs, or else Lemmih does.
20:54:12 <SyntaxNinja> you dork ;)
20:54:27 <SyntaxNinja> dons: like I said, nickserv isn't responding to me.
20:54:35 <SyntaxNinja> Lemmih: can you actually avoid the draft?
20:54:40 <dons> oh, oops. I see.
20:55:30 <TheHunter> seriously? if you aren't register with nickserv you can't privmsg, if you can't privmsg, you can't register with nickserv?
20:56:07 <SyntaxNinja> TheHunter: I don't think that's the problem.  I'm actually registered, but I can't 'identify' I think nickserv is just not working right now
20:56:26 <TheHunter> at least, nickserv is responding to me
20:56:28 <SyntaxNinja> try /msg nickserv help
20:56:33 <Lemmih> SyntaxNinja: If I'm lucky or unsuited. Hopefully I'm not mentally fit for duty (:
20:56:39 <SyntaxNinja> oh hm. it responds to that
20:57:08 <Torrente> Hola
20:57:10 <SyntaxNinja> Lemmih: I think that if you don't show up at the draft office, they assume you're sane, so you can't plead insanity ;)
20:57:10 <Torrente> A todos
20:57:15 <Torrente> Hi
20:57:17 <Torrente> Folks
20:57:22 <SyntaxNinja> hi Torrente
20:57:39 <Torrente> SyntaxNinja: Where r you from?
20:58:51 <SyntaxNinja> hm. nickserv is back
20:59:00 <SyntaxNinja> Torrente: USA
20:59:10 <Torrente> SyntaxNinja: I'm from Argentina
20:59:12 <TheHunter> anyway, if you want to switch away from freenode, count me in.
20:59:15 <SyntaxNinja> I can see that :)
20:59:15 <Torrente> do u know?
20:59:23 <Torrente> SyntaxNinja:
20:59:24 <Torrente> yes
20:59:32 <Torrente> SyntaxNinja: I love Haskell
20:59:37 * humasect nods
20:59:58 <Torrente> SyntaxNinja: and formal methods
21:00:07 <SyntaxNinja> TheHunter: OOI, do you have gaim or something that'll allow you to seemlessly do jabber & irc at the same time?
21:00:25 <SyntaxNinja> Torrente: cool. I know a bunch of formal methods guys, but that's all greek to me.  haskell is good, though :)
21:00:38 <TheHunter> i'm using xchat right now, but i'm not too attached to it.
21:01:05 <Torrente> SyntaxNinja: Curry Howard Isomorphism is actually amazing
21:01:26 <Torrente> SyntaxNinja: I am studing this now
21:01:47 <Pseudonym> I think it's even more amazing when you take into account the categorical interpretation.
21:02:10 <humasect> something b@True  <- how is this done for pattern matching and alias?
21:02:25 <humasect> with literals.
21:02:31 <Torrente> Pseudonym: yes
21:02:32 <SyntaxNinja> humasect: huh?
21:02:47 <humasect> something x@(a,b) = ...  <- like this
21:02:51 <Torrente> Pseudonym: but, i dont know much category theory
21:03:07 <SyntaxNinja> humasect: doesn't that work?
21:03:36 <humasect> something x@(1,2) = ...   <-- as this? maybe.
21:04:27 <Torrente> Pseudonym: U are student of....?
21:06:15 <Torrente> aaa
21:06:26 <SyntaxNinja> humasect: that works for me
21:06:27 <Torrente> SyntaxNinja: why u nick?
21:06:53 <SyntaxNinja> Torrente: just silliness.
21:07:02 <humasect> Syntax: hm i see, thanks. i think i overcomplicated something
21:07:03 <Torrente> @ is called ass-pattern
21:07:05 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
21:07:05 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
21:07:05 <lambdabot> dynamic-reload dynamic-unload easton echo elements elite eurohaskell
21:07:05 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
21:07:05 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
21:07:07 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind lambda
21:07:08 <lambdabot> learn leave libsrc listchans listcommands listmodules lojban moo
21:07:10 <lambdabot> [6 @more lines]
21:07:28 <Torrente> SyntaxNinja: @ is called as-pattern
21:07:31 <SyntaxNinja> for some reason, I think, parsing-related words sound cool.  "Lex" ... "syntax" ... "semantics" ... "parser combinator" ... "parsec"  all cool sounding words
21:07:51 <gzl> SyntaxNinja: you would. your nick has "syntax" in it. :)
21:08:03 <SyntaxNinja> Torrente: if you put an '@' at the beginning of a line, it's a command to our lambdabot program
21:08:06 <SyntaxNinja> @type 3
21:08:08 <lambdabot> forall t. (Num t) => t
21:08:16 <SyntaxNinja> gzl: heh
21:08:24 <TheHunter> @todo-add stop '@' silliness
21:08:25 <lambdabot> Entry added to the todo list
21:08:41 <Torrente> SyntaxNinja: pfffff
21:08:44 <SyntaxNinja> humasect: did you come here and ask whys omething doesn't work before you checked to see that it doesn't work? :)
21:09:07 <SyntaxNinja> you should never do that for Haskell ;)
21:10:36 <Torrente> SyntaxNinja: .................
21:11:02 <humasect> sorry, it must have been rude too. i'm not using haskell for science like most of you guys here i think ^_^
21:11:08 <SyntaxNinja> Torrente: ?
21:11:13 <SyntaxNinja> humasect: no, not rude at all!
21:11:23 <Torrente> SyntaxNinja: sorry...
21:12:04 <SyntaxNinja> humasect: I don't use it for science
21:12:29 <humasect> why?
21:12:39 <SyntaxNinja> because I'm not a scientist? :)
21:12:47 <humasect> not student ?
21:12:52 <SyntaxNinja> np
21:12:53 <SyntaxNinja> no
21:13:07 <Torrente> SyntaxNinja: what do u do?
21:13:27 <SyntaxNinja> I work for thiks company: http://www.galois.com
21:14:01 <SyntaxNinja> security, mainly
21:14:15 <humasect> with haskell, that is respectable =0
21:14:19 <Torrente> SyntaxNinja: software enginering
21:14:49 <Torrente> SyntaxNinja: its so cool
21:15:48 <Pseudonym> Torrente: I am not a student.
21:15:53 <humasect> security is a kind of science
21:16:44 <Torrente> humasect: very interesting
21:19:10 <Torrente> someone there??
21:19:16 <humasect> hello
21:19:17 <humasect> ?
21:19:25 <SyntaxNinja> hello, i'm on the phone
21:19:41 <Torrente> SyntaxNinja: oks
21:19:42 <humasect> hi, i'm still coding
21:19:48 <Torrente> humasect: okas
21:19:56 <Trevion> My brain hurts.
21:20:39 <Trevion> Does anyone have some example code that uses datatypes built out of STRefs?  I have type variables running absolutely buck wild and not doing anything related to what I want at the end.
21:20:43 <Torrente> Trevion: a migrana
21:21:06 <SyntaxNinja> actually, I'm talking to ralf on the phone, but I see he's not paying attention
21:21:09 <SyntaxNinja> and instead he's using his computer
21:21:13 <ralf> That's not true.
21:21:21 <ralf> I logged on here in case he wants to have another channel.
21:21:28 <ralf> no one else talk to me okay?
21:21:41 <dons> Lemmih, I've addd unsafePackAddress :: Int -> Addr# -> FastString, which has O(1), and nicely compiles to this Core code: Main.lvl = Data.FastPackedString.PS
21:21:47 <humasect> my only obstacles now with haskell is design and organization. i spend most time on those now than actual code.
21:21:54 <dons>  GHC.ForeignPtr.PlainNoFinalizer 0 123044
21:22:11 <dons> oh, there's a "foo" in between
21:22:29 <Torrente> humasect: u know how use modules?
21:23:23 <humasect> torrente: yeah, but lower level issue than just modules i think
21:24:52 <dons> and this lovely C code: StgWord Main_lvl_closure[] = GHCForeignPtr_PlainNoFinalizzer_closure, (W_)&addr_of_str_array, 0x0, 0x1e0a4U, 0x1U
21:24:57 <humasect> maybe i need more gonads.
21:24:58 <humasect> *monads
21:25:07 <dons> yay. O(1) construction of FastStrings!
21:26:43 <Torrente> humasect: Maybe, hahaha
21:30:24 <SyntaxNinja> gotta get offline. bbiab
21:31:15 <metaperl> gonads, monads... what's the difference
21:34:53 <humasect> the first letter. =)
21:35:20 <humasect> i might have accidentally mutated some things toward OO-like things, with my use of records
21:45:31 <Lemmih> dons: Neat. I'll look into adding string literates to TH.
21:47:09 <dons> well, a cpp macro is ok too. FAST("foo") ~> unsafePackAddress 3 "foo"#
21:47:47 <Lemmih> How does that work?
21:48:24 <dons> not sure. maybe it isn't possible in cpp ;)
21:48:42 <dons> s/a cpp macro is ok/I would like a cpp macro/
21:54:04 <Lemmih> 'packCString' and 'packCStringLen' might be useful.
21:56:40 <dons> how different to mallocCString2FastString? (babadly named)
21:56:59 <Lemmih> It copies the entire string and isn't pure.
21:57:42 <dons> copies?    fp <- newForeignPtr c_free (castPtr cs)
21:57:42 <dons>     let l = c_strlen cs
21:57:42 <dons>     return $ PS fp 0 (fromIntegral l)
21:58:09 <Lemmih> Oh.
21:58:20 <dons> I might just change this to packCString :: CString -> FastString
21:58:32 <Lemmih> 'packCString (Ptr addr#) = packAddress addr#' seems easier to read (:
21:58:43 <dons> nice :)
21:59:01 <dons> for non-malloc'd strings
21:59:19 <dons> do we ever have non-malloc'd CStrings? or are they always malloc'd. hmm.
21:59:27 <dons> I guess sometimes they're alloc'd
23:27:04 <Itkovian> meuning (still have a headache)
23:29:02 * sethk is away: Off to the salt mine
23:52:12 <boegel> yo Itkovian
23:52:23 <boegel> and everyone else, off course
23:52:58 <dblhelix> okay, boegel, then it's all right... ;) and a good morning to you, of course
23:53:06 <boegel> dblhelix: ;)
