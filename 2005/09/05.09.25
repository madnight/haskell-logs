00:19:11 <dons> palomer, there was a recent thread on this on haskell@ I think
00:19:16 <dons> much code was posted
00:19:31 <basti_> hey dons i had a look at emacs2
00:19:42 <dons> yeah, opinions?
00:19:53 <basti_> its great that its so orthogonal
00:20:08 <basti_> to my implementation i mean
00:20:53 <basti_> I think my next step (after straightening out the enter problem) will be merging both parts
00:20:59 <dons> yeah, it was jyp's work, btw.
00:21:06 <dons> also, my Mg.hs is another emacs mode
00:21:07 <basti_> oh ok
00:21:13 <dons> written in lexer combinator style
00:21:14 <basti_> yes i saw that too
00:21:31 <dons> (i prefer Mg.hs, but Lemmih doesn't ;)
00:21:35 <basti_> :P
00:21:59 <basti_> did you see my completion code?
00:22:22 <basti_> i liked how short it was in the end...
00:22:43 <dons> yeah, i was impressed by the conciseness
00:23:22 <basti_> and it used foldr! :D
00:23:39 <dons> @karma+ basti
00:23:43 <dons> hehe
00:23:45 <basti_> :P
00:23:51 <dons> wake up lamdabot!
00:23:57 <basti_> yes where is it?
00:25:57 <dons> i think he got discounnected, but didn't realise
00:26:54 <basti_> -g-
00:29:53 <dons> @version
00:29:55 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
00:29:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:44:43 <ptolomy> @plugs max 3 4
00:44:48 <lambdabot> 4
00:44:51 <ptolomy> Woo.
00:47:42 <ptolomy> anyone know what would happen if I told lambdabot to 'sum [1..]'? Nothing bad?
00:49:09 <basti_> it'll tell you that it stopped trying after a while
00:49:40 <basti_> i think every plugs command may work a few seconds, and if there's no result, a message is printed
00:53:57 <astrolabe> Yes, I've been bad with lambdabot.
01:09:04 <dons> astrolabe, why?
01:12:57 <MarcWeber> Hi. I want to compile haskore using ghc. But in that makefile there is a line: IOExtensions.o : /usr/lib/ghc/4.04/imports/exts/IOExts.hi.
01:13:19 <MarcWeber> This file doesn't exist on gentoo, but there is /opt/ghc/lib/ghc-6.4/hslibs-imports/lang/IOExts.hi
01:18:23 <MarcWeber> Having made this change I get Failed to load interface for `IOExts': Could not find module `IOExts': use -v to see a list of the files searched for. How can I add this file to the list? I couldn't find that command using ghc --help
01:26:13 <dons> is it in -package haskell98 ?
01:28:30 <MarcWeber> dons: How do I know this? Using ghc-pkg?
01:30:29 <dons> try adding -package haskell98 to the ghc command line
01:30:37 <MarcWeber> I've now read on the ghc documentation page about moving the positions to change from the old hugs lib style to a newer hirarchical way.. That could be the solution because haskore is dated 2001 and version (see above) is ghc/4.04/..
01:31:08 <dons> yeah, i'm not even sure where IOExts is
01:31:42 <stefanw> MarcWeber: what version of GHC does haskore require? The file IOExtensions.o seems to depend on a .hi file from GHC 4.04
01:32:13 <dons> huh
01:32:34 <MarcWeber> stefanw: Not sure.. Haven't read anything about that, yet..
01:33:32 <musasabi> MarcWeber: The functions in IOExts can be found in other modules.
01:33:47 <musasabi> MarcWeber: you could comment the import and see what it is missing and then add suitable imports.
01:33:59 <MarcWeber> That is openFileEx
01:33:59 <dons> ah, it's in hslibs.
01:34:06 <dons> -package lang
01:35:11 <MarcWeber> dons, musasabi, stefanw Thanks.. Now I get another error.. Let's see wether I can resolve it by myself now
01:42:15 <MarcWeber> I have to ask again.. where is fromInt definied? How to find this information?
01:43:47 <dons> @index fromIntegral
01:43:48 <lambdabot> Prelude
01:43:49 <dons> ?
01:47:50 <MarcWeber> The line where its used and Not in Scope (=not found?) bshiftr b n = truncate ((fromInt n)/2^b). googling for fromInt told me that it's a function to convert an Int to numeric type.. So is this equal to fromIntegral?
01:48:15 <MarcWeber> bshiftr is BitShiftRight
01:49:10 <MarcWeber> Oh it is.. I've found a post
01:50:33 <MarcWeber> Thanks.. now make has finished without any further error
02:47:02 <basti_> @ghc
02:47:03 <lambdabot>  Urk infer
02:47:12 <basti_> lmao
02:47:39 <ibid> @ghc
02:47:40 <lambdabot>  Inferred type is less polymorphic than expected
02:47:45 <ibid>  boring
02:48:00 <basti_> yup
02:48:03 <ibid> @ghc
02:48:04 <lambdabot>  adjustor creation not supported on this platform
03:06:59 <shapr> whee!
03:08:24 <basti_> whoops
03:09:46 <shapr> @ghc
03:09:47 <lambdabot>  Cycle in type synonym declarations
03:12:00 * basti_ is looking forward to the day of all C programs becoming finally unmaintainable
03:28:31 <shapr> Hiya tensh
04:14:59 <rep> morning
04:20:45 <shapr> jiihaa!
04:21:54 <dons> whoowhoo
04:22:43 <basti_> urp!
04:23:16 <bubblesort> hi
04:23:29 <shapr> hiya, cute nickname.
04:23:31 <dons> hello bubblesort. amusing nick :)
04:24:19 <bubblesort> yeah :)
04:24:24 <bubblesort> tanks
04:24:27 <bubblesort> thanks
04:24:56 <bubblesort> well, I was doing some basic haskell programming after reading two tutorials, and I want to go further
04:25:48 <bubblesort> which book do you recommend for somebody who knows what functional programming is, but who wants to dig into Haskells features?
04:26:53 <dons> hmm. good question.
04:27:39 <bubblesort> or is there a tutorial on the net that I haven't seen yet?
04:27:48 <bubblesort> (Which deals with that).
04:28:01 <musasabi> Writing actual code is a good way to learn.
04:28:22 <dons> yes. i agree with musasabi. probably few people in #haskell actually used a book.
04:28:24 <musasabi> Have you looked at the nomaware monad tutorial?
04:28:51 <bubblesort> thanks
04:28:54 <bubblesort> looks god :)
04:28:58 <bubblesort> s/o/oo
04:29:17 <dons> more likely, using the monad tutorials,the ghc library docs, and a good little project to hack on, is how many of us learnt advanced haskell
04:29:36 <dons> or contributing to an existing project. (e.g. a lambdabot plugin)
04:30:55 <dons> bubblesort, have you seen: http://haskell.org/bookshelf/
04:33:28 <rep> uhm
04:34:43 <shapr> hiya b00t, learning Haskell?
04:36:24 <rep> this is really infuriating
04:37:13 <shapr> rep: What's up?
04:37:38 <rep> trying to understand why http://people.freebsd.org/~ssouhlal/stuff/blah.hs messes up
04:37:57 <rep> or rather, how to make it not mess up
04:39:55 <b00t> hello,shapr,I'm very intersting in haskell,but have no time to learn~
04:40:01 <dons> rep, hmm. interesting code
04:40:27 <dons> what are you trying to do?
04:40:32 <basti_> "interesting?" ;)
04:40:43 <rep> dons use sendfile(2) to send a file over the network
04:40:45 <dons> well, it's rather low level
04:40:57 <dons> hehe $ man 2 sendfile
04:40:57 <dons> man: no entry for sendfile in section 2 of the manual.
04:41:09 <rep> you need a better OS :P
04:41:20 <dons> is this a freebsd-ism?
04:41:32 <rep> yes, but linux has a sendfile too
04:41:37 <dons> oh, interesting
04:41:45 <rep> although it's a bit different
04:41:47 <dons> but apparently not openbsd
04:42:05 <rep> it's an optimization
04:42:20 <rep> sends a file over the network without doing any copies
04:42:53 <dons> ah, ok.
04:42:56 <musasabi> rep: you might be better of having a tight read/write loop.
04:43:12 <rep> musasabi using sendfile(2) makes a pretty big difference
04:43:14 <musasabi> many *nix have sendfile but the implementations are not compatible with each other.
04:43:42 <dons> well, can't be that many *nix.. since there's only 4 or 5 real ones ;)
04:43:45 <rep> my httpd.hs is able to transfer about 4.4MB/s without and 6.5MB/s with
04:44:06 <musasabi> rep: but that won't scale with concurrency very well.
04:44:22 <rep> musasabi why not?
04:44:42 <rep> (other than the fact that in freebsd, sendfile(2) acquires Giant)
04:44:43 <musasabi> rep: because sendfile is blocking thus e.g. a scenario with 5000 simultaneous client connections will cause quite many OS threads.
04:44:52 <rep> musasabi threaded httpd
04:45:00 <rep> oh
04:45:11 <shapr> b00t: Well, you could jump in and learn however much you have time to learn. Here's an introduction I wrote for the impatient: http://www.haskell.org/hawiki/HaskellDemo
04:45:15 <rep> musasabi freebsd has m:n threads, with scheduler activations
04:45:22 <rep> musasabi so it's ok to have a lot of threads
04:45:30 <musasabi> rep: true, but using kqueue might be still faster.
04:45:50 <musasabi> depends on the ratio of data transferred and number of connections.
04:45:57 <rep> right
04:46:14 <musasabi> you might want to look at network-alt (adding kqueue support should be easy).
04:46:24 <musasabi> </plug>
04:46:31 <rep> :)
04:47:01 <shapr> Network Alt - for all your alternative networking needs! http://www.cs.helsinki.fi/u/ekarttun/network-alt/
04:47:44 <dons> @where network-alt
04:47:45 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
04:48:16 <shapr> Does @where have a keyword search?
04:48:43 <dons> nope. but perhaps it could use the spell-checking code
04:49:00 <dons> which sort of doubles as keyword search.
04:52:01 <mflux> where does @where get its information from?
04:52:31 <dons> there's a command to insert key => value pairs
04:52:51 <mflux> quite boring ;(
04:52:52 <mflux> ;)
04:53:58 <dons> yep. it's not, say, parsing our conversations and adding entries in real time ;)
04:54:06 <dons> which would be super-cool
04:54:16 <rep>  93107 blah     CALL  sendfile(0x6,0x6,0,0,0x1b6c,0,0x809c370,0)
04:54:16 <rep>  93107 blah     RET   sendfile -1 errno 38 Socket operation on non-socket
04:54:21 <rep> :/
04:54:37 <rep> wait wtf
04:54:57 <rep> it's using the same file descriptor for input and output?!
04:55:51 <mflux> maybe it wants to echo something back to a socket
04:56:01 <mflux> if it is a socket anyway, it says it isn't?-)
04:56:15 <rep>  93107 blah     NAMI  "/home/refugee/public_html/woo.c"
04:56:16 <rep>  93107 blah     RET   open 6
04:56:22 <dons> oh, that could be a bug;)
04:56:50 <rep> i think it's something to do with laziness or something
05:00:08 <rep> or a bug in the ghc threads
05:00:32 <rep> because when using forkProcess instead of forkIO it doesn't give any problem :)
05:02:03 <dons> well, i'm not sure if i'd immediately blame a bug in ghc threads. did you compile with -threaded?
05:02:03 <rep> hm
05:02:10 <rep> of course :)
05:02:15 <dons> ok, just checking ;)
05:02:41 <rep> wait, it's not behaving correctly with forkProcess either
05:06:23 <rep> "forkProcess blah" should behave the same as "forkOS blah", except creating a new process, right?
05:07:08 <musasabi> yes, but fds behave in a different way when forking a process and a thread.
05:07:27 <musasabi> (those wonderfull *nix semantics)
05:08:40 <dons> *cough* hack *cough*
05:09:01 * musasabi prefers the word braindead ;)
05:09:57 <rep> ah yes
05:16:57 * dons ponders cafe menu and wonders if there are any vegetarians in estonia
05:17:36 <kosmikus> not many, probably
05:17:41 <rep> hm
05:17:49 <kosmikus> dons: which cafe?
05:17:54 <rep> runs out of processes
05:18:06 <dons> oh, just the one in the hotel
05:18:38 <dons> though there's a 'soup gallery' which sounds promising :)
05:18:46 <rep> wierd though, because it never has more than 10 processes
05:19:31 <dons> kosmikus, the chocolate shop next the the icfp venue looks very nice
05:19:47 <musasabi> I think there was a vegetarian restaurant in Tallinn.
05:20:04 <dons> hehe. 'was'!
05:20:07 <musasabi> found it - http://www.inyourpocket.com/estonia/tallinn/en/venue?id=ESTAENR0113
05:20:50 <dons> oh, cheers!
05:21:42 <dons> also saw plenty of italian places today, which are usually easy to find vegetarian stuff in
05:21:48 <rep> oh, a lot of zombies :D
05:26:24 <musasabi> You have to wait for them or double-fork.
05:26:57 <rep> yeah
05:27:10 <rep> wait, double-fork?
05:28:06 <musasabi> then the grandchild will be inherited by init which will kill it.
05:28:24 <rep> that sounds pretty evil
05:29:19 <musasabi> and slow in case you have a lot of children.
05:29:52 <musasabi> you could use SIGCHILD + wait, but then there exists the problem of old systems with non-reliable signals.
05:33:20 <musasabi> Is there something like sendfile on windows?
05:34:09 <rep> not afaik
05:45:05 <rep> is there a way to make a foreign function return an IO action?
05:46:19 <musasabi> like foreign import "foo" foo :: CInt -> IO CInt ?
05:46:31 <rep> that's it?
05:47:22 <musasabi> yes. Most foreign imports (those that are impure) should be imported like that.
05:53:29 <rep> well
05:54:14 <rep> even if i don't call sendfile at all, it gives me errors, when using a lot of simultaneous connections
05:54:32 <rep> http://people.freebsd.org/~ssouhlal/stuff/blah.hs <- with the call to c_sendfile commented out
05:54:39 <rep> blah: closeFd: invalid argument (Bad file descriptor)
05:54:39 <rep> blah: closeFd: invalid argument (Bad file descriptor)
05:55:01 <rep> according to ktrace, it's closing the same fd twice
05:55:32 <rep>  10811 blah     CALL  close(0x6)
05:55:32 <rep>  10811 blah     RET   close 0
05:55:32 <rep>  10811 blah     CALL  close(0x6)
05:55:33 <rep>  10811 blah     RET   close -1 errno 9 Bad file descriptor
05:56:32 <musasabi> It seems that sendfile implementations are at least {freebsd}, {linux,solaris}, {hpux}, and {netbsd,openbsd} don't have it.
05:59:07 <rep> the problem here is clearly not sendfile, though
06:01:23 <musasabi> rep: It might be the Socket -> Handle -> Fd conversion - or something along that way.
06:03:50 <rep> i'll try using Network.Socket
06:08:05 <integral> @hoogle [Bool] -> Int
06:08:06 <lambdabot> Prelude.length :: [a] -> Int
06:08:06 <lambdabot> List.genericLength :: Integral a => [b] -> a
06:08:06 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
06:10:26 <musasabi> rep: please note that Network + -threaded does not scale very well ;)
06:10:44 <rep> musasabi i still don't understand your argument for that
06:12:45 <musasabi> rep: it uses select(2) in a haskell thread...
06:13:25 <rep> that's ok if all it does is accept(2)
06:14:00 <musasabi> you don't want to read/write ?
06:14:12 <rep> sendfile writes for me!
06:14:42 <musasabi> and who reads for you (and you need to write yourself when you add different kinds of processing for the files).
06:14:50 <rep> each thread reads for itself
06:15:25 <rep> (and you can tell sendfile to pre/append stuff to the file to send)
06:15:36 <musasabi> except the reads with Network (which uses Network.Socket) are nonblocking ones and the select loop is used for wakeup.
06:15:54 <rep> that's pretty lame
06:16:21 <musasabi> It is good enough for the cases where performance is not important.
06:16:32 <musasabi> And when you want better performance you can use a better library.
06:16:43 <rep> like yours :)
06:20:05 <rep> yep, now it doesn't mess up!
06:21:28 <rep> although all these sendfiles basically kill the box, because it gets the Giant lock :(
06:22:46 <rep> (i suspect)
06:25:44 <musasabi> sounds nasty.
06:26:04 <musasabi> for small files going the kqueue route will probably be faster.
06:27:22 <musasabi> And even a litle bit more portable.
06:27:37 <rep> i don't really care about portability here
06:31:27 <rep> it seems that lighttpd uses sendfile too
06:51:54 <pesco> cptchaos: Moin!
06:52:12 <cptchaos> pesco: Moin!
06:53:51 <rep> moin
06:54:30 <pesco> Moin rep.
07:14:44 <bubblesort> ist eigentlich genaueres bekannt wann Apple seine Intel-CPU-Rechner rausbringt?
07:15:27 <bubblesort> sorry
07:15:31 <bubblesort> wrong tab
07:16:18 <rep> heehee
07:16:19 <Wilmer> bubblesort: i think during the beginning of 2006 already :-/
07:16:35 <Wilmer> but that's not very "genau" yet, i guess ;-)
07:16:50 <shapr> genom?
07:16:56 <Wilmer> genau == precisely
07:16:58 <shapr> genom == genau ?
07:17:10 <SickJacken> why isnt Set a functor?
07:17:38 <SickJacken> seems logical for it to be
07:17:42 <Wilmer> shapr: "is it actually precisely known when apple, etc"
07:18:44 <SickJacken> obivously the functor laws hold up for Set.map
07:18:49 <SickJacken> fmap = Set.map
07:18:53 <SickJacken> or am i missing something here?
07:21:26 <SickJacken> ok ill try the mailinglist
07:22:44 <shapr> hiya pesco!
07:30:52 <shapr> Did haskell.org just get cracked?
07:31:06 <shapr> It's rejecting my ssh pub key :-/
07:31:27 <autrijus> :-/
07:31:29 <autrijus> yo shapr btw
07:31:37 <shapr> hiya autrijus!
07:31:41 <autrijus> shapr: are you in tallinn or going to be?
07:31:49 <shapr> Nah, I'm in Sweden.
07:32:00 <autrijus> ah.
07:32:03 <autrijus> I should visit you
07:32:13 <autrijus> I'm going to Stolkholm after Euro OSCON
07:32:40 <shapr> !
07:33:06 <shapr> That would be cool!
07:33:08 <autrijus> where are you in .se?
07:33:15 <autrijus> I'm attending Nordic Perl Workshop
07:33:18 <shapr> I'm an hour's plane flight north of Stockholm.
07:33:28 <autrijus> also I'm adopting this erdos lifestyle thing
07:33:33 * shapr laughs
07:33:45 <shapr> Programming as Proofs?
07:33:55 <autrijus> something like that :)
07:34:00 <autrijus> for the next 10 years or so
07:34:05 <autrijus> (it's in my slides -- have you read them?)
07:34:58 <humasect> does yi-gtk use sourceview?
07:35:48 <shapr> humasect: http://www.scannedinavian.org/YiWiki
07:36:08 <shapr> autrijus: I read your CUFP slides, but I don't remember seeing erdos mentioned.
07:36:19 <autrijus> interesting, because that's the last slide
07:36:24 <humasect> nice, thanks
07:36:47 <tensh> I have a function that's supposed to return a pair (Environment, String), but I need to execute a saveEnv command before returning.. Is this possible?
07:37:11 <autrijus> @type seq
07:37:14 <tensh> I've tried using 'do' but I end up with returning (Environment, IO String)
07:37:15 <lambdabot> forall b a. a -> b -> b
07:37:39 <shapr> autrijus: I thought the last slide had PERL6 = practical forall lambda etc
07:37:41 * shapr looks again
07:37:50 <autrijus> er, that's the concluding slide
07:37:56 <autrijus> so maybe I meant penultimate
07:39:51 <humasect> IO (Env, Str)
07:41:41 <tensh> humasect, how do you mean?
07:41:47 <SickJacken> crap
07:41:52 <SickJacken> Ord screwing up things
07:42:08 <SickJacken> instance Functor Set where fmap = Set.map
07:42:09 <humasect> all monad calls have to 'connect' together
07:42:11 <SickJacken> aint working
07:42:20 <SickJacken> because fmap's type is too general....
07:42:25 <SickJacken> and i cant add contraints to it
07:42:37 <humasect> so everything starting from main touches everything that is IO a in the program
07:42:57 <musasabi> ah the famous superclass problem.
07:43:12 <tensh> so basically I can't do this without changing the return-value of my function?
07:43:27 <SickJacken> musasabi, is there a solution..that doesnt include defining my own typeclass ?
07:43:40 <humasect> IO just classifies it as needing to execute in the IO monad
07:43:57 <humasect> if you have a 'do', it's monadic already..
07:44:11 <tensh> damn... I've got to do a read-up on monads :(
07:44:15 <humasect> we call those Mona Lisas.
07:44:21 <tensh> hehe
07:44:22 <tensh> ;)
07:45:38 <tensh> so there's no way to execute two commands in a function with a definition like :: Environment -> Action -> (Environment, String) ?
07:45:59 <tensh> without changing the type definition that is
07:47:33 <humasect> but you change the type requirement already by depending on order of monadic action with a do
07:47:51 <tensh> well.. that didn't work out
07:47:58 <tensh> it won't load in hugs
07:48:07 <humasect> error wa?
07:49:25 <tensh> "Type error in explicit binding"   ;   Type   : Environment -> Action -> (Environment, IO String)    ;    Does not match    :  Environment -> Action -> (Environment, String)
07:50:02 <musasabi> SickJacken: not really. It can be avoided when designing new class hierarchies.
07:50:16 <musasabi> With the use of type proxys.
07:51:27 <humasect> tensh: right, now you must x <- func in the containing do.
07:51:39 <humasect> "to take the IO off it"
07:51:51 <humasect> but it should be IO (Environment, String) rather than (Environment, IO String)
07:52:11 <humasect> or could.. depends on the contents
07:52:21 <tensh> well, i tried something like:  x <- do { saveEnv f env; (env,"game saved") }
07:52:46 <tensh> no
07:52:58 <tensh> errr... yes
07:52:59 <humasect> maybe paste more code to pastebin
07:53:00 <humasect> =)
07:53:00 <tensh> :)
07:53:44 <tensh> hang on
07:54:05 <tensh> I'm writing the code on my laptop where I don't have any internet connection right now
07:54:13 <tensh> I'll have to rewrite on this computer
07:54:53 <humasect> just those two funcs, you can leave out reduntance
07:56:57 <humasect> hm, now i'm also getting "unknown field hs-source-dirs" on hIDE.cabal
07:57:16 <musasabi> humasect: you need to upgrade cabal.
07:57:33 <humasect> i thought it was discovered that 6.4's cabal has hs-source-dirs.
07:57:59 <humasect> oh there. i will use hs-source-dir
07:59:25 <tensh> http://www.tekno.chalmers.se/~joakimc/haskell/ioprob.txt <-- this is what it looks like right now
08:00:14 <tensh> there have been better looking versions though ;) I've had this problem for quite a while now
08:01:13 <humasect> you might have your gameStep as IO
08:01:30 <humasect> if it was...
08:01:44 <humasect> then you can "return (env, show inv)" et. al for the rest
08:02:19 <musasabi> tensh: that looks very much like "type MyGameMonad a = StateT Environment IO a" might be in order.
08:02:58 <tensh> what? I don't understand much from that last sentence
08:03:31 <musasabi> A state transformer monad with IO.
08:03:58 <tensh> anyway, we call the function gameStep like this:   "do { len (env', msg) = gameStep env action; putStrLn msg; gameLoop env' }
08:04:28 <tensh> hmm... do I have to write it myself or can I find it somewhere?
08:04:32 <tensh> find one*
08:04:40 <humasect> that's all you really need
08:04:47 <humasect> then type your functions with it
08:05:05 <tensh> so our callingfunction can handle IO (Environment, String) output as well?
08:05:16 <tensh> ehm... callingline
08:05:25 <goron> Anyone read Practical type inference for arbitrary-rank types?
08:05:26 <humasect> it holds it so you don't have to return it from everywhere
08:05:32 <tensh> I'm going crazy here :) Too much thinking
08:06:14 <humasect> for now just think of state monad as something that holds value for you.. without having to pass it around and return it all over.
08:06:52 <autrijus> goron: I did
08:07:45 <tensh> Ok...
08:08:39 <goron> SPJ and MS say: Since (forall a.a->a) is more polymorphic than (forall x.[x]->[x]), it follows that ((forall a.a->a)->Int is *less* polymorphic than ((forall x.[x]->[x])->Int)
08:09:21 <goron> I don't get a clue about what they are saying. I understand their examples, but this doesn't seem to be consistent with ti.
08:09:24 <goron> er it
08:09:34 <goron> It's on page 8 of the paper.
08:09:42 <tensh> well... I think I have to read up a bit on this stuff before I continue any further here, and continue with the rest of the program instead. Thanks for all the your humasect.
08:10:16 <tensh> Actually I realised a while ago that I didn't really need this for my game, but it should be useful to know how to do this
08:10:18 <humasect> one moment, i have a good example for you
08:11:03 <humasect> can i email you a file? 187 lines.
08:11:19 <tensh> sure
08:11:20 <goron> autrijus: Do you understand what I am saying?
08:12:49 <humasect> tensh, ok this is the first thing i've done with haskell a few weeks ago, demonstrates clearly important basic ideas for realtime, state, and input stuff for examplary use (among other things)
08:14:08 <goron> Since when does Haskell do real-time stuff?
08:14:35 <humasect> since us kids discovered it.
08:14:50 <tensh> okay
08:15:29 <goron> humasect: Could you elaborate on that?
08:15:54 <humasect> tensh, i just need your email. i'll send a 1.6mb file
08:16:11 <musasabi> goron: Can you think about it in terms of covariance / contravariance ?
08:16:13 <tensh> i noticed you
08:16:21 <tensh> check your status :)
08:17:01 <goron> musasabi: I don't know the words covariance/contravariance. (It's assumed that I understand what it is in the paper)
08:17:06 <humasect> :o but.. i guess LimeChat doesn't get anything
08:17:49 <goron> musasabi: I don't think you mean statistical covariance.
08:17:56 <musasabi> goron: hmm ok, they are terms used in OO circles and thus some CS classes that some people are more familiar with.
08:18:20 <musasabi> but if you haven't encountered them, just ignore my suggestion.
08:19:05 <goron> musasabi: If I could find a definition of it, I would probably understand it.
08:21:42 <musasabi> http://c2.com/cgi/wiki?ContraVsCoVariance
08:21:49 <tensh> humasect, i'm not registered.. I've never been on freenode before today
08:22:12 <tensh> give me your e-mail in query and I'll mail you mine ;)
08:22:24 <humasect> i was just going to suggest =)
08:25:33 <shapr> humasect: Ooh I wanna see rt stuff!
08:25:35 <__aleksa> hi
08:25:44 <__aleksa> I need help.
08:26:01 <shapr> Ok, ask your question!
08:26:41 <humasect> =o ? i thought haskell is nice for real time, especially for getting things to happen before you think you coded it all, for a newbie. (unrelated?)
08:26:50 <tensh> humasect, are you sure you remembered to upload the files? :)
08:26:53 <goron> musasabi: But what has this got to do with the type systems of Haskell? They don't really have an object oriented system (modulo classes).
08:27:01 <humasect> tensh, i sent a second one =)
08:27:06 <tensh> hehe, ok :)
08:27:10 <__aleksa> How can I stop following hugs program? mail = print [1,2..]
08:27:26 <__aleksa> I want to stop it by pressing CNTR-C
08:27:39 <__aleksa> main
08:27:43 <humasect> ctrl+break ?
08:27:47 <__aleksa> yes
08:27:53 <Cale> Ctrl-C should stop it
08:27:54 <goron> __aleksa: Control-C works for me.
08:27:59 <goron> (just tested it)
08:28:20 <goron> (but maybe you are non a broken platform)
08:28:23 <goron> er on
08:28:33 <__aleksa> When I am using hugs interpreter it stops the program. But when I am runnig that program from command line it doesn't stop.
08:28:41 * humasect .oO { was gtk2hs really 'chosen' for hIDE/yi }
08:28:51 <goron> __aleksa: Windows?
08:28:58 <__aleksa> Linux
08:29:31 <goron> (oh, I tested it also from the interpreter)
08:29:41 <goron> __aleksa: You could also kill it)
08:29:51 <tensh> "Could not find module `Graphics.UI.SDL'"
08:29:57 <__aleksa> I have killed it.
08:30:00 <shapr> humasect: What do you mean?
08:30:03 <dons> humasect,?
08:30:05 <goron> tensh: recompile ghc.
08:30:21 <goron> tensh: (most likely)
08:30:31 <goron> musasabi: ?
08:30:39 <__aleksa> goron: How to write following program in haskell? I will give python code.
08:30:45 <humasect> darcs get http://scannedinavian.org/~lemmih/SDLhead
08:30:45 <__aleksa> try:
08:30:46 <tensh> argh... I think I'm gonna try it on my laptop later this evening... I'm using one of the school computers right now
08:30:50 <__aleksa>   while 1:
08:30:54 <humasect> goron, er no ~_~
08:31:01 <__aleksa>     print "running"
08:31:02 <tensh> thanks humasect! I'll get back to you if I solve it :)
08:31:14 <humasect> ok, cool =) i hope things go well otherwise
08:31:18 <__aleksa>   except KeyboardInterrupt:
08:31:24 <__aleksa>     print 'end'
08:31:31 <goron> __aleksa: I am not too familiar with Python.
08:31:52 <goron> __aleksa: You just read the APIs and apply those rules and bam you have a program.
08:31:57 <humasect> shapr: by 'see' i automatically think you mean fancy graphics
08:32:00 <__aleksa> Tell me the language that you are familliar just to write you an example.
08:32:14 <Cale> __aleksa: what are you compiling with?
08:32:22 <__aleksa> I am using hugs.
08:32:26 <Cale> hmm
08:32:49 <dons> humasect, what did you mean by the was gtk2hs 'chosen' question?
08:32:54 <goron> __aleksa: You just want a program that halts on Control-C?
08:32:58 <sethk> hey, all.  I'm using parsec.  I want to use "try" with a group of characters (things separated by ; within a do).  I'm not sure where the try should go in this case.
08:33:02 <__aleksa> goron: Yes
08:33:07 <Cale> __aleksa: so how are you running your program from the commandline?
08:33:11 <sethk> I want the try to apply to the entire thing, no any of the components.
08:33:15 <__aleksa> goron: yes
08:33:49 <humasect> dons: i meant.. nothing about alternatives i can find documented, i'm wondering why the vets have chosen gtk2hs for Our Holy IDE
08:34:15 <musasabi> goron: it was the idea how the ordering of composed types is with respect to the ordering of the inner types.
08:34:31 <Cale> __aleksa: I can't get the "won't terminate on ctrl-c" behaviour you're talking about
08:34:34 <sethk> humasect, I've been playing with gtk2hs and wxhaskell the last few days.  I think gtk2hs is a bit clicker looking.
08:34:38 <musasabi> it is a little bit similar in my mind, but it might be an irrational association.
08:34:42 <humasect> (because, i have something to write that would be nice as an hIDE plug, but i think i will prefer to invest development with wxhaskell rather than gtk2hs)
08:34:42 <Cale> (I'm on Linux too)
08:34:43 <sethk> s/clicker/slicker/
08:35:37 <humasect> i like how wxhaskell is '-ified', where gtk2hs feels more of a direct binding to a lower level api
08:36:44 <dons> hmm. this is an interesting issue. we didn't really explore the alternatives (which I think is only wxhaskell). mostly because, i guess, dcoutts was the main hIDE guy, and knows gtk2hs well, so we just went with that.
08:36:45 <humasect> maybe it was glade, maybe it was because wxhaskell linked is ~8mb, or ...
08:36:47 <int-e> sethk: I think the try should go before the do; try $ do ... or try (do ...)
08:36:47 <sethk> humasect, yes, although of course wxhaskell works through gtk in the linux version.  I know the one I downloaded uses gtk.  I think that is the only linux version.
08:37:10 <sethk> int-e, I'll try it with the infix operator, I didn't think about that.
08:37:24 <sethk> int-e, try do is a syntax error
08:37:35 <goron> __aleksa: http://haskell.org/ghc/docs/latest/html/libraries/base/System.Posix.Signals.html#t%3ASignal
08:37:38 <humasect> wxhaskell also comes with DB stuff, opengl, etc "for free"*  (* no choice but to link with wxcore)
08:37:47 <humasect> hmm
08:38:05 <goron> __aleksa: I think you would need to use some stuff related to this.
08:38:14 <sethk> int-e, the parser likes try $.  I'll have to see if it does what I expect.  :)
08:38:20 <humasect> i've played equally with both and i think i would choose wx for a nicer haskell experience
08:38:39 <sethk> humasect, I'm still up in the air about it.
08:38:47 <humasect> ..but i can see hIDE in the picture
08:38:48 <dons> me too in fact
08:39:01 <dons> yi can certainly support both, that would be pretty easy
08:39:08 <__aleksa> How to use asinchronus exceptions in haskell? I just want code example.
08:39:15 <humasect> except sourceview and yi+gtk which is sort of just completed
08:39:26 <humasect> dons, oh ok, good to hear
08:39:36 <dons> not really. that's a very thin layer on top of device-independent yi
08:39:48 <musasabi> __aleksa: http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html#11
08:40:01 <dons> to support wxHaskell, you just implement a buffer instance for wxHaskell buffers, and a UI module
08:40:07 <musasabi> Basically "throwTo someThread myException"
08:40:09 <dons> probably 500 loc
08:40:10 <humasect> i personally could at least provide experiments, like porting ideShell and see how things go
08:40:12 <dons> (easy code)
08:40:15 <__aleksa> musasabi: I saw it? It is api if I am right.
08:40:59 <__aleksa> musasabi: Do you know python?
08:41:07 <sethk> __aleksa, gentle introduction also has some examples
08:41:23 <sethk> __aleksa, not sure what you mean by "it is api".  everything is api
08:41:33 <Cale> __aleksa: you use throwTo :: ThreadIO -> Exception -> IO () to throw an exception to another thread
08:41:38 <musasabi> I know basics of python, but not very well.
08:41:39 <__aleksa> sethk: Gentle introduction doesn't have thing that I want.
08:41:50 <sethk> __aleksa, I thought it had some exception examples
08:41:53 <musasabi> __aleksa: what are you looking for specifically?
08:42:03 <dons> humasect, if you'd like to do that, and know wx well enough, please do so! this would be useful
08:42:52 <__aleksa> sethk: Maybe it have same synchronus exceptions. I wan other thing.
08:43:11 <sethk> __aleksa, k
08:43:44 <int-e> @type catch
08:43:46 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:45:47 <humasect> i can't seem to get a gtk2hs with sourceview working on this w32 setup, so i can't try out the gtk version at the moment.
08:47:53 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage -- how to catch your thread being killed
08:48:03 <Cale> __aleksa: is that what you're looking for?
08:50:20 <__aleksa> cale: how to handle cntr-c signal in haskell?
08:51:18 <Cale> well, the same way, if you can catch it at all
08:52:15 <dons> you can catch it
08:52:31 <dons> at least with a posix signal handler
08:52:43 <__aleksa> maybe implementation of hugs for linux doesn't work properly.
08:52:49 <dons> not sure about a normal exception though. interesting question
08:54:39 <dons> no, unix signal style exceptions have to get mapped manually across to dynamic exceptions
08:54:47 <dons> see darcs for a nice example of this
08:55:35 <dons> or if you really care about signal handling, try: installHandler sigINT (Catch (return ())) Nothing
08:55:40 <dons> roughly
08:55:54 <humasect> /package.conf: openFile: does not exist (No such file or directory)
08:56:01 <dons> import System.Posix.Signals
08:56:18 <dons> humasect, you labouring away on win32?
08:56:55 <humasect> yeah =(
08:57:27 <dons> i actually wonder why there is no module already that maps unix signals to haskell exceptions. kinda odd
08:58:38 <sethk> In the wxhaskell sample files, I see :=.  The := string doesn't occur in the haskell report.  Can someone point me at something that describes this?
08:58:55 <dons> it's an operator defined by wxhaskell
08:59:17 <sethk> dons, k, let me look for it in the wxhaskell source
08:59:51 <dons> constructor, in fact
09:00:38 <Cale> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Attributes.html#t%3AProp
09:00:47 <dons> report 2.4: consym -> (: { symbol | :})<reservedop>
09:01:34 <sethk> dons, I don't believe that this use of := maps to that.
09:01:46 <dons> gtk2hs uses a similar system for Attrs
09:01:50 <Cale> sethk: what?
09:01:52 <dons> sethk, check the link Cale posted
09:02:31 <dons> haddock docs are your friend when learning a library ;)
09:02:50 <dons> check the index entry for ':'
09:02:52 <Cale> as are types :)
09:02:57 <SickJacken> can one abstract over a type constructor like this; "data Pannekoek a cons = cons { bla :: a }"
09:02:58 <SickJacken> ?
09:03:05 <dons> types are always good!
09:03:09 <Cale> SickJacken: no
09:03:12 <SickJacken> darn
09:03:21 <SickJacken> it looked so cool
09:03:44 <Cale> but cons isn't a type
09:03:47 <Cale> there
09:03:54 <Cale> it'd be more of a string
09:04:10 <SickJacken> but is it clear what i mean?
09:04:15 <Cale> sort of
09:04:21 <Cale> not entirely
09:04:27 <SickJacken> somehow to parameterise the type constructor
09:04:31 <Cale> I don't see what use it would have
09:04:49 <SickJacken> well, i have two recordtypes that share structure
09:05:01 <SickJacken> except for the types of the elements and the constructor
09:05:03 <Cale> since any instantiation of that type would use some particular string, and would be incompatible with each other
09:05:04 <SickJacken> so i want to abstract over them
09:05:08 <Cale> ah
09:05:14 <Cale> make a type class
09:05:27 <Cale> for extracting the fields
09:05:40 <autrijus> anyone working on ghc6.4.1 for freebsd?
09:05:42 <SickJacken> ow ofcourse
09:05:47 <dons> "make a type class" -- the standard solution to almost all your type hacking problems ;)
09:05:47 <SickJacken> thanks
09:05:52 <SickJacken> yeah
09:05:59 <SickJacken> i have been hearing that quite often lately
09:06:14 <dons> autrijus, i don't think there's a maintainer atm
09:06:29 <dons> unless JaffaCake is, but didn't tell anyone
09:07:00 <SickJacken> ow btw, anyone that hasnt seen the movie "Saw" MUST see it
09:07:04 <SickJacken> it is awesome
09:07:15 <autrijus> dons: ok. hm maybe I can work on a patch.
09:07:21 <dons> a patch?
09:07:27 <autrijus> to the ports
09:07:32 <dons> oh, right :)
09:07:43 <autrijus> there's different levels of patch :)
09:07:43 * dons panicked for just a second that ghc was broken on freebsd
09:07:51 <musasabi> autrijus: rep was using it I think.
09:07:55 <autrijus> it's very broken, not to mention outdated
09:08:08 <dons> there's different levels of ghc ;)
09:08:12 <autrijus> :D
09:08:17 <dons> ghc cvs shouldn't be broken
09:08:31 <dons> ah yes, rep was/is
09:08:35 <dons> so it works. good good.
09:08:55 <dons> as long as we keep getting nightly builds on openbsd, i doubt freebsd is going to break
09:09:08 * dons makes a bold claim
09:10:15 <dons> autrijus, maybe you could contact Oliver Braun
09:10:25 <dons> http://www.haskell.org/freebsd/
09:10:37 <autrijus> k
09:12:42 <sethk> this is beyond me.  text :: occurs in a class Textual.  A frame has text.  But Textual only occurs as a comment in Frame.hs
09:17:42 <sethk> it must be deduced through Window, but damned if I can trace it back to frame
09:24:13 <bringert> is there any haskell library or interface to a library which can resize jpegs?
09:25:20 <dons> bringert, you could call one of the jpeg transform programs
09:27:06 <bringert> yeah, I thought of that, but I'd like to be able to compile one static binary which has everything it needs
09:27:23 <bringert> but I'll do that if I can't come up with anything else
09:27:42 <bringert> I found a GD binding, from a now dead page: http://web.archive.org/web/20010803163434/http://www.numeric-quest.com/haskell/gd/index.html
09:27:44 <dons> you could encode the contents of the program that does the transform in a "string"#, then write it out and run it ;)
09:27:54 <bringert> haha
09:28:09 <bringert> it would still need libjpeg or something though
09:28:23 <dons> you need a static jpeg binary
09:28:57 <bringert> thing is, I want to run it on an ancient webserver, and I'm not counting on it having any of the libs I want
09:29:37 <dons> this trick isn't that bad in fact. i have a shell script that does this in C http://www.cse.unsw.edu.au/~dons/code/hsinc/
09:30:15 <dons> yeah, it would be good if there's a library. now, i wonder how pantheon does this?
09:30:34 <dons> it has a client that displays and manipulates images, and can at least write jpegs
09:31:22 <dons> ah, it only support bitmaps
09:32:42 <dons> oh, no it actually can read .png files
09:32:48 <dons> http://www.cse.unsw.edu.au/~sseefried/darcs/panic/samples/Bitmap.hs
09:32:59 <bringert> ok, I''l test the GD binding, and if it works maybe I should package and host it
09:37:38 <bringert> *shudder*
09:38:17 <bringert> it includes a C-program which does all the work, writes a bunch of commands to a file, the runs the C program on that file
09:47:18 <Cale> sethk: in case you didn't find it, Textual is in Graphics.UI.WX.Classes
09:47:40 <Cale> oh, you're looking for the Frame instance
09:49:41 <Cale> Frame is just a type synonym: type Frame a = Window (CFrame a)
09:49:55 <Cale> so it's just the instance for Window, as you said, that does it.
09:55:35 <araujo> Hello.
10:12:26 <dcoutts> humasect, so what would you say is missing in the Gtk2Hs API compared to wxHaskell? we are interested in making the binding a bit more high level.
10:13:07 <musasabi> Using OOHaskell would make for an interesting binding.
10:21:08 <dcoutts> perhaps, but we want to remain mainstream and reasonably portable
10:21:52 <humasect> the key differences between each binding page's hello world examples is where if first noticed it
10:25:20 <humasect> combined with glade isn't as rough, but there are enough explicit layout widgets and heirarchy to manage with gtk itself
10:26:29 <humasect> (when i added a menu, there were a lot of one liners added to the source) there is probably something i am missing, maybe wxhask just forces a higher level useage.
10:27:11 <Cale> xerox: are you around?
10:27:23 <humasect> but i'm seeing it in hIDE
10:28:07 <humasect> (eg. DemoEditor.hs -> textEditorPage)
10:28:32 <neadjneki> is there a prelude function for \ f x -> f x ?
10:28:55 <int-e> @type ($)
10:29:00 <lambdabot> forall b a. (a -> b) -> a -> b
10:29:10 <int-e> that's the one.
10:29:58 <Cale> or just id
10:30:09 <humasect> maybe if wxhask is adding stuff above wxwidgets itself, that could very well be shared between the two. maybe another day..
10:30:25 <neadjneki> int-e tx
10:31:43 <dcoutts> humasect, yes the textEditorPage is using the sourceview bi which hasn't had the higher level api stuff added (as has been done with the main gtk package)
10:31:51 <int-e> @eval head `id` tail `id` [1..]
10:31:53 <lambdabot> 28:
10:31:53 <lambdabot>   Expecting a function type, but found `t_a1rJ'
10:31:53 <lambdabot>   Expected type: [a]
10:31:53 <lambdabot>   Inferred type: [a1] -> [a1]
10:32:19 <int-e> @eval head `id` (tail `id` [1..])
10:32:21 <lambdabot> 2
10:32:23 <dcoutts> humasect, ie it's missing the attributes api, which enables the "set obj [ attr := val ]" syntax
10:32:29 <int-e> wrong associativity, duh :)
10:33:34 <dcoutts> humasect, you're quite right though, we've not bothered too much with imporving the layout system since we've got glade, where as in wxHaskell that issue is more important since it doesn't have a gui builder
10:34:51 <dcoutts> humasect, the ideShell could probably have the gui lib abstracted, so it could work with either toolkit, you're welcome to maintain the wx UI
10:35:17 <dcoutts> however I think it's probably more wise to just pick one toolkit and stick to it
10:35:46 <dcoutts> since otherwise it means plugin authors have to write for both toolkits
10:35:57 <dons> practically, considering our developer budget, we can only manage one ui
10:36:05 <dcoutts> we can certainly make improvements to the gtk2hs api
10:36:13 <dcoutts> I'm very happy to do that
10:36:29 <dcoutts> we've already borrowed some api ideas from wxHaskell
10:36:52 <dons> yeah, this is a key point. there's a good feedback loop between hide and gtk2hs.
10:37:00 <dcoutts> indeed :-)
10:37:09 <dons> so we can be sure that gtk2hs can be extended to do what we need, if needed
10:37:21 <dcoutts> yes
10:37:28 <dcoutts> one thing that'd really help is if the heiricharcal module system supported qualified exports
10:37:42 <Cale> dcoutts: I'm going to want a vbox of controls which extends itself with new rows based on user input, filling those rows with essentially the same bunch of controls. Is it sensible to construct a template for the controls to be added in Glade and then smash that into the vbox by xmlGetWidget and then boxPackStart, or will I have problems keeping the event handlers distinct?
10:38:54 <dcoutts> Cale, using xmlGetWidget constructs a new instance I think, so you would have distince signal handers on each
10:39:05 <Cale> ah, good
10:39:13 <Akshaal> why has stdin :: Handle type, but not the IO Handle type?
10:39:21 <dcoutts> Cale, the xml is just a template
10:40:14 <dcoutts> Akshaal, it's kind of a global variable, it's certainly debatable if it should have an IO type
10:40:43 <dcoutts> you can argue it either way
10:40:46 <Cale> Well, something like stdin is as pure a kind of Handle as you're going to get :)
10:41:05 <Cale> it's always the same handle, from the program's perspective
10:43:43 <shapr> musasabi: Maybe dataflow comonads will make an RTS game workable?
10:45:01 <Cale> hmm... I should spend some time coming up with some example comonads and playing around with them
10:47:01 <shapr> I've transcribed part of the comonads source out of the paper.
10:49:18 <rep> i should shave
10:53:57 <musasabi> shapr: the paper has a footnote containing a link about a comonad library.
10:54:32 * musasabi hasn't really gotten the point of comonads yet.
10:55:12 <musasabi> I can understand the operations well enough but I lack the understanding to use them for real problems.
10:55:34 <shapr> For the moment, I pretend they're a big spreadsheet.
10:56:24 <shapr> A spreadsheet is a big bunch of state. You can pull solutions out of that state, like garlic in a garlic squeezer.
10:57:16 <shapr> I dunno if that helps any...
10:58:34 <musasabi> Sure, but I can model a spreadsheet with a Reader monad fine.
11:10:19 <shapr> Yeah, what's the difference?
11:15:55 <Oejet> Hello.
11:16:14 <musasabi> shapr: that you can do lots of things with comonads that are not possible with monads.
11:16:54 <musasabi> But there is a lack of practical examples of applying them to real world problems in such cases.
11:18:03 <shapr> The dataflow paper implies to me that comonads can step in as a more tractable solution to some of the problems that inspired arrows.
11:18:47 <basti_> could an arrow be explained as some combination of a monad and a comonad?
11:21:43 <musasabi> shapr: do you know whether anyone has looked at e.g. parsers and comonads?
11:22:55 <autrijus> any visual haskell people around?
11:24:07 <shapr> I've only heard of ... three papers about comonads. There may be more, but I think the existing papers are just trying to convince people that comonads are worth using. I haven't seen anything about parsers.
11:25:11 <musasabi> A parser in functional form is "Input -> [(Input,Result)]".
11:26:05 <xerox> Cale: hi!  Just came back home :-\
11:26:57 * shapr tries to guess what a comonadic parser type would look like...
11:27:24 <shapr> oh, (Result,String) -> String maybe?
11:27:49 <musasabi> We can't start from the result can we?
11:27:55 <shapr> That doesn't make any sense.
11:28:00 <integral> surely that can't be a comonad type since counit :: ((Result,String) -> String) -> Result doesn't make sense
11:28:02 <shapr> cobind :: (d a -> b) -> d a -> d b
11:28:36 <basti_> i do not think parsers are a good example for comonads
11:28:37 <shapr> I'm thinking "the text is the big state, the result is the solution"
11:28:53 <musasabi> CoParser (Result,String), coeval :: CoParser (Result,String) -> (Result,String)
11:28:54 <basti_> since they work so well monadically
11:29:34 <basti_> maybe un-parsers are a good example for comonads (but they are trivial usually)
11:34:02 <shapr> um
11:34:38 <shapr> whee
11:35:18 <basti_> o0
11:35:45 <ricebowl> lol
11:35:56 <shapr> musasabi: I like the part about higher order dataflow being "all the history of the value" but it sure twists my head to think of what that really means.
11:38:05 <ricebowl> I seem to have solved my n-queens problem
11:38:16 <ricebowl> except I made a stupid mistake which makes it horrendously slow :p
11:38:18 <Oejet> shapr: Wow, then think about _merging_ two values _and_ their histories. :-P
11:38:25 <shapr> yeesh
11:38:32 <basti_> ricebowl: learning curve...
11:38:47 <ricebowl> basti_ - I wrote a nice 3-line function to do what I described yesterday
11:38:52 <ricebowl> and >>= was indeed quite useful
11:38:54 <Oejet> basti_: Some would say Haskell. ;-)
11:39:21 <ricebowl> only problem is that instead of checking each position in a row, I check each position on the board, so I generate redundant solutions
11:39:40 <ricebowl> the 8x8 version would take 64!*63!*62!*61!*...*57! time... :p
11:39:45 <ricebowl> oops
11:39:59 <musasabi> shapr: yes it seems quite hard.
11:42:52 <shapr> basti_: page 23 mentions Freyd categories.
11:42:53 <musasabi> http://youzen.b2.fi/~musasabi/coparser.hs
11:42:55 <basti__> ricebowl: you mean, permutations?
11:43:07 <basti__> sorry i got d/c'd shaper
11:43:10 <basti__> -r
11:43:10 <ricebowl> right
11:43:12 <basti__> argh
11:43:23 <ricebowl> permute (n, x) = x >>= (\y -> map (\x -> (y:x)) (permute ((n-1), x)))
11:43:44 <shapr> Man, I always feel like a newbie when reading papers like this.
11:43:46 <basti_> mm yes that is nicer.
11:43:59 <basti_> shapr: can you give me the link again?
11:44:34 <shapr> Distributive combinations of a comonad and monad give an arrow instance. Yow!
11:44:42 <basti_> ohh
11:44:44 <basti_> :D
11:44:44 <musasabi> But that is quite pointless.
11:44:48 <basti_> yes it is
11:45:13 <musasabi> But what monad/comonad combinations are distributive?
11:45:17 <shapr> This paper uses it to get differently clocked signals.
11:45:18 <musasabi> Certainly not IO?
11:45:24 <basti_> hmmh
11:45:37 <basti_> shapr: shit i gotta a) read b) understand that paper
11:46:00 <xerox> Which paper?
11:46:15 <shapr> This is amusing, John Hughes was experimenting with clocked, unclocked, and differently clocked arrows at EuroHaskell 2004.
11:46:19 <basti_> http://cs.ioc.ee/~tarmo/papers/essence.pdf
11:46:26 <xerox> Thanks.
11:46:40 <shapr> I wonder if Uustalu, Vene, and Hughes have talked about this already.
11:47:44 <musasabi> Uustalu's style is more mathematic than that of the Hughes' papers.
11:47:47 <shapr> biKleisli, yow!
11:50:45 <shapr> He definitely uses more category theory. I'm starting to really like CT as a way of exactly specifying this sort of thing.
11:55:17 <musasabi> http://youzen.b2.fi/~musasabi/coparser.hs (updated with unparsing)
11:55:23 <musasabi> I don't seem to get the point.
11:55:29 <MarcWeber> Do you know a module called Ssf? Its used in haskore but not found.
11:55:50 <musasabi> My code just looks plain stupid - can anyone point what I am doing wrong.
11:57:18 <shapr> MarcWeber: The case is wrong, I think.
11:58:22 <shapr> hi kate`, learning Haskell?
11:59:01 <shapr> MarcWeber: I think I have a working copy of Haskore around, but I'm pretty sure you just need to change the filenames to match the module declarations. Haskore was written on Windows before it cared about case.
11:59:25 <kate`> hello
11:59:31 <shapr> musasabi: Maybe it's a scanner?
11:59:36 <shapr> lexer?
12:00:26 <shapr> kate`: Do you have any questions?
12:00:34 <kate`> no, thank you
12:00:36 <musasabi> shapr: I can define the instances (except .>>) but they seem to be missing the point entirely.
12:01:22 <shapr> kate`: Ok, if you have any questions about Haskell, feel free to ask here.
12:01:39 <kate`> shapr, i assumed, thank you
12:02:16 <shapr> musasabi: 'context-dependent' seems to be the big idea of comonads. I'm not sure how to apply that to standard uses of monads though.
12:02:40 <shapr> It would be handy for an elisp implementation.
12:02:49 <musasabi> If we look at unparsing counit should return :: CoUnparser t -> t. But we obviously want t to be String here. But that makes the type parameter worthless.
12:04:05 <musasabi> If we look at Comonads as pulling values out of computations then parsers should be more natural.
12:04:22 <shapr> hiya justin-, learning Haskell?
12:04:39 <justin-> hi shapr, I am just curious about the community atm :) thanks
12:04:45 <asmodai> shapr: dude!
12:04:51 <shapr> asmodai: You screamt?
12:04:58 <asmodai> shapr: bellowed more likely.
12:05:11 <shapr> justin-: Ok, if you have any questions, feel free to ask.
12:05:17 <asmodai> shapr: How's tricks?
12:05:39 <shapr> Opaque at the moment.. you have any clue about comonads?
12:05:54 <asmodai> shapr: Can you eat those?
12:07:35 <shapr> Never tried it.
12:08:23 <shapr> musasabi: Throwing away the type does seem weird.
12:11:20 <basti_> I think unfold is related to the bind of the list comonad.
12:11:51 <SickJacken> someone kick me in the head and tell me never to construct records in a positional way instead of using the fieldnames
12:11:52 <SickJacken> aaaaaaaaaaah
12:12:12 <SickJacken> i just spend too long searching for the bug where i accidently switched to labels
12:12:17 <SickJacken> with big consequences
12:12:24 * musasabi never got comfortable with unfolding things.
12:12:31 <musasabi> basti_: want to lend a hand?
12:13:03 <basti_> musasabi: i'm experimenting with it
12:13:18 <basti_> I'll paste it if something interesting comes out
12:14:40 <MarcWebe1> shapr: Where is % defined? using ghci -lang :l HaskoreExamples.lhs results in HaskoreExamples.lhs:148:35: Not in scope: `%'
12:16:58 <shapr> @type (%)
12:16:59 <lambdabot> bzzt
12:17:04 <shapr> @type (Data.Ratio.%)
12:17:05 <lambdabot> forall a. (Integral a) => a -> a -> GHC.Real.Ratio a
12:17:06 <xerox> @type (Rational.%)
12:17:08 <lambdabot> bzzt
12:17:09 <xerox> OK :)
12:17:15 <basti_> MarcWebe1: Data.Ratio iirc
12:17:35 <mauke> @type (Ratio.%)
12:17:37 <lambdabot> forall a. (Integral a) => a -> a -> GHC.Real.Ratio a
12:17:40 <shapr> MarcWebe1: Are you following one of the TMR articles, or learning Haskore on your own?
12:17:53 <MarcWebe1> TMR?
12:17:57 <shapr> The Monad.Reader
12:18:28 <shapr> hoi hkr
12:18:30 <xerox> @type Monad.Reader.liftM
12:18:31 <lambdabot> bzzt
12:18:38 <shapr> hkr: Learning Haskell?
12:18:42 <hkr> hi all
12:18:44 <MarcWebe1> At the momen I'm learning on my own. I've downloaded a tutorial and I've got a book from our library..
12:18:47 <hkr> jep
12:18:53 <xerox> My @type-fu is approaching 0.
12:19:13 <hkr> did some functional programming way back ...
12:19:17 <hkr> in sasl!!!
12:19:23 <shapr> MarcWebe1: You may want to try http://www.haskell.org/tmrwiki/Haskore
12:19:31 <shapr> hkr: Whoa cool! That's a neat language.
12:19:34 <hkr> thanks :)
12:20:02 <hkr> got the manual of mr d.a. turner still here ...
12:20:27 <hkr> that was my first experience with currying etc
12:21:00 <shapr> Sasl also did data parallelism, I think.
12:21:14 <hkr> nope
12:21:28 <shapr> Oh, Nesl?
12:21:33 <shapr> Oh, I'm thinking Sisal.
12:21:59 <MarcWebe1> shapr: Thanks.. Have to go home, eat and sleep. bye
12:22:07 <hkr> sasl was a kind predecessor of miranda, i guess
12:24:54 <shapr> musasabi: Too bad I haven't finish FLM, this would be the perfect paper for sharing notes.
12:34:20 <basti_> comonads make your head spin
12:36:25 <musasabi> shapr: yes ._.
12:36:49 <rep> Lemmih it seems that xerox was able to reproduce my problem on linux
12:37:05 <musasabi> I think comonads are conseptually very simple. What is hard is trying to wrap one's mind on how to use them.
12:37:11 <shapr> I want more examples of comonads, streams alone doesn't do it for me.
12:37:13 <Micket> Hey guys. Im tearing my hair off here, help a poor noob out; http://rafb.net/paste/results/OyApX868.html
12:37:19 <shapr> Yeah, "value in a context".
12:37:38 <Micket> locationInWorld is the function i'm trying to write, orderedList was an exemple from the book (which works)
12:37:42 <shapr> Micket: What error do you get?
12:37:54 <musasabi> We have to remember that it was years from the time that monads were first used that e.g. IO was invented.
12:38:00 <Micket> Ambiguous type variable `a' in the constraint:
12:39:18 <Micket> the full error; http://rafb.net/paste/results/yZlgkS73.html
12:39:59 <Micket> line 94 is line 2 in my post.
12:41:22 <shapr> I'd like to try out comonads for reactive guis and reactive simulations that don't have the problems of arrows.
12:47:25 <musasabi> but can comonads do that?
12:47:43 <shapr> Yeah, I think that's what the dataflow paper is all about.
12:47:45 <musasabi> how would you create a new gui element with comonads?
12:48:10 <basti_> (a,*) as a comonad gives you something akin to the reader monad: you can read a all the time and modify a state b.
12:48:25 <basti_> uhm a state that can change type
12:50:41 <musasabi> With GUIs identity is important but I don't yet know how to archive that with a comonad.
12:51:34 <musasabi> let v = counit newMessageBox in (v,v) versus (counit newMessageBox, counit newMessageBox)
12:53:01 <shapr> This sort of reminds me of the pre-monad lazy stream I/O. Section 4.2  on page 15 says that "streams are naturally isomorphic to functions from natural numbers."
12:54:30 <xerox> basti_: a state that can change type ?! :D  whoa.
12:54:44 <musasabi> Uniqueness types would solve this problem.
12:54:50 <basti_> xerox: it's a little like an accumulator
12:55:00 <musasabi> But are they just patching things up?
12:55:05 <xerox> musasabi: what are 'uniqueness' types?
12:56:08 <shapr> ski said something about uniqueness types and comonads being related.
12:56:37 <musasabi> xerox: See http://www.cs.ru.nl/~clean/CleanExtra/report20/chapter9/index.html
12:56:59 <xerox> Thanks.
12:57:32 <shapr> There's some info from ski here - http://www.haskell.org/hawiki/CoMonad
12:58:49 <shapr> too bad dave_m isn't around today.
13:05:34 <shapr> hej ski!
13:05:58 <ski> hejhej
13:06:05 <shapr> ski: Do you think comonads could be used for reactive GUIs?
13:06:28 <ski> mayhaps
13:06:49 <musasabi> With or without uniqueness types?
13:06:53 <ski> i don't know so much about reactive GUIs
13:07:11 <ski> (musasabi : asking me ?)
13:08:34 <musasabi> ski: yes.
13:08:55 <Lemmih> xerox: ping.
13:09:03 <xerox> Lemmih: pooong.
13:09:26 <ski> (oops)
13:09:33 <Lemmih> xerox: You were able to reproduce rep's problem?
13:09:44 <xerox> Yup.
13:10:48 <Lemmih> xerox: Got the code online?
13:11:05 <xerox> blah.hs gives the infamous handles error, blah2.hs doesn't.  Commenting out the sendfile function in blah.hs doesn't change the behavior (i.e. I still get the errors).
13:11:32 <xerox> Wait a second...
13:11:34 <ski> musasabi : hm .. it's for sure needed for OI a ~= (World,World -> a)
13:12:51 <ski> musasabi,shapr : but i'm not sure if it must apply to some gui stuff ..
13:14:38 <xerox> Lemmih: http://paolo.is-a-geek.com:1234/  (I'm trying new rep's httpd to get them online ;))
13:20:58 <Itkovian> Lemmih: what alex version does ghc-src require?
13:21:57 <musasabi> shapr: I think I am getting better - http://youzen.b2.fi/~musasabi/CoMonad.hs
13:23:03 <Lemmih> xerox: Try changing the context-type to text/plain.
13:23:14 <Lemmih> xerox: Viewing haskell as HTML sucks.
13:23:27 <xerox> Right.
13:24:09 <xerox> Done, thanks, I didn't notice.
13:24:24 <ski> musasabi : how about s/counit/extract/ ?
13:24:42 <Lemmih> xerox: Using Linux?
13:25:00 <xerox> Lemmih: yep.
13:25:23 <Lemmih> xerox: On my box sendfile only four arguments and the third is a pointer.
13:25:38 <Lemmih> *only has
13:25:46 <ski> musasabi : is "cobind fun val@(StateC f v) = StateC v $ fun val" welltyped ?
13:25:51 <xerox> Linux 2.6.12-6-386 #1 Wed Aug 10 22:38:46 BST 2005
13:26:01 <Lemmih> xerox: ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
13:26:21 <xerox> ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)
13:26:31 <Lemmih> xerox: Linux debian 2.6.8
13:26:51 <Lemmih> xerox: Your foreign import is wrong and so are the arguments you give to it.
13:26:55 <xerox> c_sendfile :: Fd -> Fd -> COff -> CSize -> CInt -> IO CInt
13:27:21 <xerox> The last CInt..
13:27:26 <Lemmih> That should be: c_sendfile :: Fd -> Fd -> Ptr COff -> CSize -> IO CSize
13:29:00 <Lemmih> Using the socket as input fd and file as out fd can't be good either.
13:29:43 <musasabi> ski: sorry that was the wrong code, I'll upload the correct version.
13:30:05 <xerox> Lemmih: reload them, are they right now?
13:30:14 <ski> musasabi : i think it should be "cobind fun (StateC f v) = StateC (\v -> fun (StateC f v)) v" ..
13:30:41 <ski> (musasabi : it must be linear :) ..)
13:30:42 <Lemmih> xerox: Connection refused.
13:30:54 <xerox> Lemmih: sorry, try now.
13:31:26 <Lemmih> xerox: s/COff/Ptr COff/
13:31:56 <Lemmih> xerox: It's a pointer to a variable which holds the offset.
13:32:03 <Lemmih> (use nullPtr)
13:33:07 <ski> (musasabi : "modify :: (c -> c) -> StateC st a -> StateC st a" is wrong, too)
13:33:44 <SickJacken> is there a ghc 4.6.1 for debian available?
13:33:46 <xerox> Lemmih: OK, are they ok now?
13:34:06 <Lemmih> xerox: Looks good. Does it work?
13:34:15 <xerox> Lemmih: nope.
13:34:22 <xerox> blah: closeFd: invalid argument (Bad file descriptor)
13:34:23 <Lemmih> SickJacken: I doubt it. But you may have better luck with 6.4.1 (:
13:34:52 <musasabi> ski: you were right. Updated version uploaded.
13:35:45 <Lemmih> xerox: It kinda looks like you've uncommented the call to c_sendfile in blah.hs...
13:35:53 <xerox> Yep
13:36:06 <xerox> To check if it is that call making a difference
13:36:37 <Lemmih> It fails without that call?
13:36:42 <xerox> Yep.
13:37:12 <Lemmih> xerox: Does it fail on closing fd1 or fd2?
13:37:33 <xerox> fd2 I think.
13:37:38 <Lemmih> Make sure.
13:37:46 * SamB is glad as doesn't use AT&T operand ordering for MMIX
13:38:06 <ski> musasabi : Kieburz has  (.>>) :: w a -> b -> w b
13:38:58 <xerox> Lemmih: commenting out the closeFd fd2  makes it not print any error.
13:39:00 <SickJacken> hahah
13:39:02 <SickJacken> uhm
13:39:05 <SickJacken> i mean 6.4.1
13:39:31 <xerox> Lemmih: while commenting out the closeFd fd1 makes it print "blah: accept: resource exhausted (Too many open files)"
13:39:55 <Lemmih> And you're working with the blah.hs I can see?
13:40:00 <xerox> Yes.
13:40:37 <ski> musasabi : hm, your WriterC seems similar to ReaderC ..
13:40:40 <musasabi> ski: the wiki uses a definition of (.>>)  :: w a -> w b -> w b.
13:40:46 <xerox> Lemmih: cp'ied to be sure.
13:40:51 <ski> musasabi : noth, actually
13:40:54 <Lemmih> xerox: Testing it with telnet?
13:40:55 <ski> musasabi : both*
13:41:10 <ski> musasabi : but, i'm not sure if (.>>) is actually useful ..
13:41:22 <musasabi> yes, it doesn't feel very natural.
13:41:23 <xerox> Lemmih: no, with webbench -p 50
13:41:38 <Lemmih> xerox: Try it with telnet.
13:42:48 <ski> musasabi : write seems a bit similar to Control.Monad.Reader.local ..
13:43:20 <xerox> Lemmih: I see it does print the page, and it does not give the error.
13:43:46 <musasabi> ski: yes, they seem more or less equivalent (and both can be emulated with StateC)
13:43:57 <xerox> Lemmih: but what does it demonstrate?
13:44:04 <ski> musasabi : so, why separate ReaderC from WriterC ?
13:44:25 <rep> Lemmih it works fine with only one connection at a time
13:44:30 <ski> (musasabi : as opposed to Control.monad.Reader)
13:44:37 <rep> Lemmih but as soon as you have more than one, things get bad
13:44:37 <musasabi> ski: Try to emulate familiar monads?
13:44:38 <Lemmih> xerox: It means that the problem is related to concurrency.
13:45:02 <Lemmih> xerox: Try with forkIO and no -threaded.
13:45:03 <rep> Lemmih yes it is
13:45:03 <ski> musasabi : but i don't think your WriterC is similar to Control.Monad.Writer ..
13:45:34 <rep> Lemmih however, using http://people.freebsd.org/~ssouhlal/stuff/blah2.hs there are no problems
13:45:48 <musasabi> added a second Writer which should be more like it.
13:46:00 <xerox> rep, there are both .hs and 2.hs for linux on my site
13:46:01 <musasabi> of course it needs an operation to run it.
13:46:05 <ski> musasabi : Writer2 is maybe better .. not sure if it's so close anyway, though
13:46:14 <ski> musasabi : sure
13:46:15 <rep> xerox oh ok
13:46:33 <rep> Lemmih note that sendfile is not required for the problems to be there
13:46:37 <Lemmih> rep: handleToFd sets the fd to non-blocking which perhaps can cause problems.
13:46:52 <rep> Lemmih maybe..
13:46:57 * musasabi ponders how to do errors with comonads.
13:47:01 <musasabi> in particular counit.
13:47:04 <ski> musasabi : btw, shouln't you base it on Monoid ?
13:47:46 <ski> musasabi : i don't think you can, in haskell
13:48:07 <ski> (musasabi : base WriterC on Monoid, i.e.)
13:49:39 <ski> (musasabi : btw, you forgot to add a couple of '2's)
13:52:12 <musasabi> new version up.
13:52:31 <musasabi> includes Writer (pointless), Writer2 (lists) and Writer3 (monoid)
13:52:45 <musasabi> and works in ghci.
13:53:02 <xerox> (check the comments)
13:53:14 <jyp> Is hs plugins supposed to work on amd64 ?
13:54:28 <ski> (musasabi : i have no haskell installation here ..)
13:56:00 <ski> musasabi : .. hm, maybe add Stream etc ?
13:56:24 <ski> (musasabi : btw, you know Stream is a monad, too, right ?)
13:56:27 <basti_> musasabi: great, my CoState rendering is the same
13:56:53 <musasabi> ski: yes, just not gotten till there.
13:57:44 * ski 's not sure StateC/CoState actually is the dual/adjuct to State monad ..
13:57:56 * ski checks ..
13:58:50 <basti_> actually i was reading a paper that mentioned the connections and then i remembered this "universal algebra" lecture a whole lot better suddenly...
14:00:12 <ski> hm .. loosely  Not . StateM ~= StateC . Not
14:01:01 <ski> (but not    a -> StateM b  ~=  StateC a -> b    hmm)
14:01:10 <ski> (or ? ..)
14:01:16 <basti_> hmmm
14:01:45 <basti_> no not really.
14:02:01 <basti_> I dont think so.
14:03:04 <basti_> what i really wonder about is: in usual category theory books, "functor" and "monad" are mentioned in the first 50 pages
14:03:14 <musasabi> Added Stream.
14:03:16 <basti_> what happens if we implement the next 200 pages?
14:03:30 <ski> hm, i actually got  a -> (s -> b * s)  down to  (s -> Not b) * s -> Not a .. hmm
14:04:06 <ski> basti_ : esap has tried to implement adjunctions ..
14:04:07 <xerox> @quote basti_ <basti_> what i really wonder about is: in usual category theory  books, "functor" and "monad" are mentioned in the first 50 pages <basti_> what happens if we implement the next 200 pages?
14:04:08 <lambdabot> basti_ <basti_> what i really wonder about is: in usual category
14:04:08 <lambdabot> theory  books, "functor" and "monad" are mentioned in the first 50
14:04:08 <lambdabot> pages <basti_> what happens if we implement the next 200 pages? hasn'
14:04:08 <lambdabot> t said anything memorable
14:04:11 <xerox> ooops
14:04:16 <xerox> @add-quote basti_ <basti_> what i really wonder about is: in usual category theory  books, "functor" and "monad" are mentioned in the first 50 pages <basti_> what happens if we implement the next 200 pages?
14:04:17 <lambdabot> Unknown command, try @listcommands.
14:04:23 <xerox> @quote-add basti_ <basti_> what i really wonder about is: in usual category theory  books, "functor" and "monad" are mentioned in the first 50 pages <basti_> what happens if we implement the next 200 pages?
14:04:24 <lambdabot> Unknown command, try @listcommands.
14:04:28 * xerox gives up
14:04:37 <basti_> ski: what happened?
14:04:58 <ski> basti_ : ?
14:05:04 <basti_> ski: with the adjunctions
14:07:00 <basti_> can you do the IO -> OI transition automatically?
14:07:12 <xerox> Oi! Monad ?!
14:07:23 <basti_> Oi monad yup
14:07:27 <basti_> never heard about it xerox ?
14:07:30 <xerox> Err, no.
14:07:42 <basti_> thats the contravariant equivalent of IO
14:07:45 <ski> basti_ : some info in http://www.haskell.org/hawiki/LicensedPreludeExts
14:07:53 <xerox> I miss what does it mean contravariant :-\
14:08:07 <basti_> basically, OI gives functions like: oigetchar :: OI () -> Char
14:08:31 <ski> OI requires linear typesystem
14:08:34 <wagle> basti_: i cant figure out what book you are refering to
14:08:38 <musasabi> Oi! Monad & Co ;)
14:08:43 <xerox> ¿efas ti si woH
14:09:04 <ski> xerox : ?
14:09:16 <musasabi> And linear type systems can complicate matters.
14:09:16 <wagle> xerox: its like sugar with the chirality reversed
14:09:21 <ski> xerox : OI, you mean ?
14:09:28 <xerox> ski: yep
14:09:32 <basti_> wagle: book?
14:09:35 <musasabi> (they make typing higher order functions a little bit nastier)
14:09:49 <ski> xerox : if the input to oigetchar is linear, then i think it can be
14:10:05 <basti_> wagle: i had one in my hands recently
14:10:08 <wagle> basti_: the one that xerox tried to record your remark for posterity
14:10:10 <xerox> What is a linear input?
14:10:26 <ski> xerox : basically, an 'OI a' carries around a state of the world inside it ..
14:10:43 <xerox> ski: I can go this far, yep..
14:10:43 <basti_> wagle: theres plenty in our library. many of those mention both functor on the first pages, and monads (although called bizarre) some time later
14:10:52 <ski> xerox : no .. what is linear types, you should ask :)
14:11:01 <xerox> ski: but the state could be everything, such, I thought, it should be -> IO a anyway
14:11:08 <rep> btw wagle it turns out sendfile wasn't the problem
14:11:11 <basti_> (of course you have to realize that a kleisli triple is just an inside out way of declaring a monad)
14:11:22 <ski> xerox : could be everything ?
14:11:43 <wagle> rep: he said he'd written sendfile
14:11:52 <rep> wagle who?
14:11:55 <xerox> ski: mumble.
14:11:57 <basti_> xerox: nobody said OI would be as useful, intuitive and/or safe as IO!
14:12:01 <wagle> whoever that was
14:12:43 <rep> wagle the problem is that (i think) handleToFd is not threadsafe
14:12:43 <basti_> ski: uhm that document tickles my brain quite nice thanks .)
14:13:01 <wagle> rep: ah,,  he wasnt showing that part
14:13:02 <ski> LicensedPreludeExts ?
14:13:06 <basti_> yep
14:13:21 <rep> wagle (i think you're talking about me)
14:13:41 <xerox> How does  OI a -> a  differ from  IO a -> a ?
14:13:46 * wagle rubs eyes..  oh yeah
14:13:49 <ski> esap had an idea about the types being adjoint to each other could be considered a 'space' and a 'path' into that space ..
14:13:52 <rep> :D
14:14:12 <basti_> xerox: basically, normal IO functions are a -> IO b
14:14:19 <basti_> and not IO a -> b
14:14:24 <xerox> Sure
14:14:27 <basti_> or something
14:14:29 <ski> xerox : extract :: OI a -> a   is required to be a comonad ..  just like return :: a -> IO a  is required for monads
14:14:39 <xerox> heh.
14:14:58 <basti_> the only IO a -> a functions are unsafe
14:15:08 <xerox> a -> OI a  is unsafe?
14:15:14 <ski> a -> OI a   would be unsafe, too
14:15:16 <ski> yep :)
14:15:18 <xerox> Cool.
14:15:30 <ski> that would construct a world from nothing
14:15:36 <xerox> I waited too long to read the CoMonad page, ok :)
14:15:51 <xerox> god :: a -> OI a
14:15:59 <basti_> what we really need is not the types, but implementions that make sense
14:16:02 <ski> s/god/dog/
14:16:09 <xerox> Pfft :)
14:16:10 <musasabi> rep: I think handleToFd should be thread safe.
14:16:30 <rep> musasabi but it doesn't seem it is :(
14:16:31 <ski> basti_ : we need types an implemntation
14:16:39 <xerox> ski: so what are linear types?
14:16:57 <basti_> now that people realized that comonads/monads relate to arrows (and probably vice versa), and can be used to implement differently-paced streams and their processing... wow
14:17:04 <basti_> i mean, we have a theory for DSP!
14:17:08 <musasabi> rep: do you have a simple test case showing it failing (or an idea why it wouldn't be) ?
14:17:15 <ski> xerox : basically, you can in typesystem ensure that you only have a single pointer/reference to a value
14:17:17 <rep> musasabi http://people.freebsd.org/~ssouhlal/stuff/blah.hs
14:17:20 <basti_> real DSP, not the kiddie stuff.
14:17:21 <rep> musasabi uncomment c_sendfile
14:17:35 <ski> xerox : so, linear values can't be discarded or duplicated freely
14:17:37 <rep> musasabi and have it process multiple CONCURRENT connections
14:18:01 * musasabi tries that
14:18:04 <ski> xerox : so, the world, as well as arrays etc can be linear values  (so we can safely do update-in-place)
14:18:17 <ski> xerox : Clean (and Mercury) does this
14:18:24 <rep> musasabi by "uncomment" i mean "comment out" of course :)
14:18:26 <rep> :D
14:18:32 <xerox> ski: what's the counter-effect?
14:18:52 <ski> counter-effect ??
14:19:10 <xerox> There is no bad thing about linear types?
14:19:32 <ski> well, you still want some stuff to be nonlinear, yes :)
14:19:39 <ski> this complicates it somewhat
14:20:28 <ski> (otherwise you'd have to call a function every time you wanted to use an Int more than one time ..)
14:21:24 <xerox> Thanks for the explanations, I think I'll sleep.  Goodnight folks :)
14:21:30 <ski> night
14:24:25 <ski> (xerox : i associated 'effect' with stuff like 'effect-system' and 'side-effects' :)
14:25:33 <musasabi> strace shows all close(2) calls succeeding.
14:28:42 <musasabi> The only system call errors I get are EINTR and EAGAIN.
14:28:53 <basti_> musasabi: don't forks need to be joined?
14:28:53 * basti_ .o° ( was that english? )
14:29:51 <musasabi> in blah.hs? yes, but that doesn't cause errors.
14:30:05 <basti_> hmm depends on how many forks there are generated
14:30:35 <basti_> that shouldn't be too many, but they'd accumulate
14:30:36 <prionic> what does function local of the MonadReader class do?
14:30:58 <musasabi> runs a computation in a local environment.
14:32:22 <ski> ask `runReader`3 = 3
14:32:27 <ski> local (const 2) ask `runReader`3 = 2
14:32:34 <ski> local (* 10) ask `runReader`3 = 30
14:32:51 <basti_> ski: good examples.
14:34:39 <prionic> thx, i have to think about those...
14:38:50 <basti_> np: Bloodhound Gang - The Inevitable Return Of The G
14:39:44 <prionic> (ReaderT r m a) is an instance of MonadState, what type does get return... r?
14:39:49 <Wilmer> basti_: hah! :-D
14:39:55 * Wilmer just had to notice the BHG
14:39:59 <basti_> Wilmer: mmmh?
14:40:07 <Wilmer> basti_: bloodhound gang :-)
14:40:15 <basti_> yup but why "hah"? ;)
14:40:18 <Wilmer> hehe
14:40:19 <Wilmer> nah
14:40:33 <Wilmer> that was my way of expressing appreciation ;-)
14:40:37 <basti_> mmk
14:40:54 <Wilmer> i'm told they even have some new song these days...
14:40:58 <basti_> prionic: prolly some ReaderT?
14:41:09 <prionic> prolly?
14:41:10 <ski> prionic : a
14:41:33 <ski> prionic : 'ReaderT r m' is the monad
14:42:06 <ski> prionic : if you are starting to understand reader .. you could start with Reader instead of ReaderT ..
14:42:17 <basti_> "probably"
14:42:41 <basti_> so return gets an a and returns a ReaderT r m a?
14:43:07 <ski> m
14:43:23 * basti_ doesnt understand that either.
14:43:33 <ski> @type return :: Monad m => a -> Control.Monad.ReaderT r m a
14:43:34 <lambdabot> bzzt
14:43:42 <ski> @type return :: Monad m => a -> Control.Monad.Reader.ReaderT r m a
14:43:44 <lambdabot> Monad m => a -> Control.Monad.Reader.ReaderT r m a :: forall a r (m :
14:43:44 <lambdabot> : * -> *).
14:43:44 <lambdabot> (Monad m) =>
14:43:44 <lambdabot> a -> Control.Monad.Reader.ReaderT r m a
14:45:01 * ski wonders if lambdabot cuts correctly
14:45:25 <ski> ah
14:45:35 * ski smacks his head
14:45:59 <ski> prionic : sorry, i'm confusing you .. i misread 'get' as 'that'
14:46:33 <ski> forget what i said, ok ?
14:46:35 <prionic> is there comprehensive docmentation/tutorials about these monads?
14:46:52 <prionic> these specific monads
14:47:05 <prionic> oh
14:47:20 <prionic> ski: ok
14:47:25 <basti_> @google nomaware monad tutorial
14:47:27 <lambdabot> http://www.nomaware.com/monads/html/
14:47:28 <basti_> try that
14:47:45 <ski> prionic : were you thinking of   instance MonadState s m => MonadState s (ReaderT r m)    ?
14:48:01 <prionic> ski: yes
14:48:04 <ski> ok
14:48:33 <prionic> basti_: yeah that'll help, thx
14:48:46 <ski> get :: ReaderT r m s
14:48:47 <ski> there
14:49:11 <ski> basically, 'ReaderT r m' is a reader monad on top of a custom monad 'm'
14:49:49 <ski> that instance says that if that custom monad supports state (e.g. 'get' operation, etc), then this monad with reader on top supports it, too
14:50:45 <ski> clearer ?
14:51:19 <prionic> ski: a bit, in my specific case the 'm' is IO
14:51:31 <ski> ok
14:51:38 <ski> hm
14:52:33 <Itkovian> night
14:52:50 <ski> prionic : i don't think IO has an MonadState instance
14:53:40 <ski> (btw, state above means as in monolithic state, not as in IORef and STRef ..)
14:56:45 <prionic> ok
15:08:53 * SamB is trying to translate the MMIX simulator in vol. 1, fascicle 1 from MMIXAL into MMIX GNU C
15:09:14 <musasabi> grah.
15:09:21 <musasabi> CoMonads cause headaches.
15:09:43 <musasabi> And keep running in inverse direction.
15:09:47 <SamB> musasabi: yeah, I figured as much when I heard OI was impure
15:10:44 <musasabi> test2 co = co =>> modifyL (+1) =>> modifyL (*3)
15:10:48 <SamB> they run from the end to the beginning?
15:11:12 <musasabi> and then "runStateC test2 4" results in (13,4)
15:12:35 <musasabi> meaning a right to left order of computation.
15:13:29 <musasabi> That makes for "fun" variable bindings.
15:14:01 <musasabi> Try translating "do x <- get; set 10; set x".
15:14:12 <SamB> why bother?
15:14:18 <SamB> monads actually WORK
15:14:36 <musasabi> that is just an implementation detail ;)
15:15:34 <ski> L  ?
15:16:25 <musasabi> modify :: (c -> c) -> StateC c a -> StateC c a
15:16:32 <musasabi> modifyL :: (c -> c) -> StateC c a -> a
15:17:01 <musasabi> (just had to tag them with a letter - needs a better name)
15:17:08 <ski> cobind modifyL = modify  i guess ?
15:17:40 <ski> um
15:17:46 <ski> cobind . modifyL = modify
15:17:48 <musasabi> or counit + modify
15:18:17 <musasabi> ski: At this stage I am not sure which will make more sense later.
15:18:23 <ski> m
15:18:52 * ski has experimented with  transform :: s -> StateW s s
15:19:42 <ski> (obvous impl.)
15:34:41 <ulph2> I'm running a StateT M recursively, doing lift $ runStateT m s, and in s i have a function say f :: StateT M, but I want it to use the state outside runStateT when it evaluates, is that possible?
15:35:15 <ulph2> There is something like unlift that I've heard of
15:36:34 <ski> @type Control.Monad.State.runStateT
15:36:35 <lambdabot> forall s a (m :: * -> *).
15:36:35 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
15:36:58 <ski> runStateT gives you the final state
15:38:21 <ski> if your expression 's' contains a value of type 'StateT st m a'  you could pass the state returned from the runStateT into a new invocation of runStateT, with this state as initial state in this call
15:38:49 <ski> (btw, why are you running it recursively ?)
15:40:13 <ulph2> Yes, that solves the problem if I want to do two runStateT in succession, I just pass the state along.
15:40:25 <ski> m
15:42:38 <ulph2> But I'm doing it recursively because I need to work on something recursively, so instead of saving the state, doing the work and then restoring the state, I just lift runStateT
15:44:06 <ski> why can't you just call your function/action recursively, and just call runStateT once, at top ?
15:44:32 <Cale> Unless it's syntactically a lot nicer to do so, I wouldn't bother with that trick
15:45:03 <ulph2> Because the functions that I call recursively use a "clean" state
15:45:41 <ski> mhm
15:45:42 <Cale> ah -- maybe turn them into pure functions?
15:45:46 <ski> the initial ?
15:48:13 <ulph2> Hm
15:49:07 <musasabi> => sleep
15:49:17 <ski> musasabi : night
15:49:28 <ulph2> Cale, no they access the state so that won't work, i need to unlift them
15:50:24 <ulph2> Something like
15:51:00 <ulph2> do f' <- unlift f
15:51:20 <ulph2>    runStateT m (S f')
15:51:21 <ski> what type do you imagine unlift having ?
15:56:35 <ulph2> hm
16:01:35 <ulph2> Oh.. now I get!
16:02:47 <ulph2> f' <- lift $ evalStateT f get
16:02:58 <ulph2> hm no maybe not :)
16:03:10 <ulph2> s <- get
16:03:17 <ulph2> f' <- lift $ evalStateT f s
16:04:10 <rep> unlift?!
16:04:21 <rep> sounds evil
16:09:08 <ski> m
16:10:41 <ulph2> well, maybe that was not what I was trying to do
16:12:15 * ski is not clairvoyant ..
16:12:30 <ulph2> I was trying to transform a StateT-function into a pure function given a certain state.
16:13:05 <ulph2> Sorry :)
16:13:38 <ski> (yes, but why ? ..)
16:14:23 <ulph2> So I could pass it into the new state in runStateT
16:15:19 * ski wonders what ulph2 is trying to do ..
16:18:11 <ulph2> I'm parsing a programming language and I use runStateT for every new block that I encounter, but I want to pass in a function lookupDec so I can lookup declarations outside the block I'm currently analyzing :)
16:24:56 <ski> what is the state ?
16:54:41 <sethk> all, I'm trying things from the parsec documentation.  They show a definition where a left paren is used, without a matching right paren.  I don't think it is a typo; it occurs more than once.  ghci flags things that follow as parse errors.  What would a left paren, without a right paren, mean?  Is left paren redefinable?
16:55:19 <Cale> sethk: where?
16:55:35 <sethk> Cale, the example is page 16 of parsec-letter.pdf
16:55:47 <sethk> Cale, the lines are:
16:55:48 <Cale> I'll have a look
16:55:55 <sethk> Cale,    lexer = makeTokenParser
16:56:00 <sethk>         (haskellDef
16:56:09 <sethk> Cale, well, with the correct indentation   :)
16:56:53 <Cale> yeah, that's a typo
16:57:05 <Cale> or possibly a problem with creating the pdf
16:57:55 <sethk> Cale, ok, let me look at it in another format.  thanks
16:58:12 <Cale> hmm, it occurs in the html format too
16:58:30 <sethk> Cale, as I said it occurs in more than one place.
16:58:51 <sethk> Cale, it's not a missing right paren, though, is it?
16:59:02 <Cale> well, there ought to be a right paren after the }
16:59:16 <Cale> it's just that someone forgot to type it
16:59:33 <sethk> Cale, ok, but more than once?  Unless I misread the second one.
17:00:05 <Cale> where does the 2nd one happen?
17:00:13 <sethk> I'm looking
17:00:20 <Cale> ah
17:00:21 <Cale> yeah
17:00:26 <Cale> another lexer
17:00:53 <Cale> probably a copy-pasted typo in this case
17:01:33 <sethk> Cale, ok, so the parens are just grouping
17:01:56 <ski> except for tuples
17:02:14 <sethk> Cale, there are two other errors, although these may be things that have changed, not errors.
17:02:25 <sethk> Cale, the imports are Parsec.Token and Parsec.Language
17:02:32 * ski thinks '$' would have been more appropriate ..
17:02:40 <sethk> Cale, rather than ParsecToken and ParsecLanguage
17:03:09 <ski> changed, yes
17:03:09 <sethk> Cale, also, if you know, while I was messing with this I removed (haskellStyle) from the import of Text.ParserCombinators.Parsec.Language and it didn't change anything.
17:03:14 <sethk> Cale, does that make sense?
17:03:17 <sethk> ski, ty
17:03:56 <ski> prolly you didn't use 'haskellStyle' ..
17:04:19 <sethk> ski, as far as I can see, neither does the example.
17:04:30 <sethk> ski, but maybe he does that to show that you ordinarily would want to
17:04:58 <ski> mayhaps
17:15:43 <witten> what are some ways to allow destructive updates while maintaining referential transparency, other than uniqueness typing and monads?
17:18:01 <Cale> witten: well, depending on your interpretation of that, something like Diff arrays might fit that description
17:18:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.Diff.html
17:18:34 <witten> cale: ok thanks
17:19:24 <Cale> though the updates aren't so destructive -- they just slow accesses to previous versions of the data
17:19:32 <witten> hmm
17:20:29 <witten> interesting
17:21:50 <Philippa> I can't think of any statically safe ways to allow destructive updates in the usual sense + referential transparency that don't significantly resemble either uniqueness typing or monads
17:22:25 <Philippa> insofar as either you'd have to let a bunch of static processing do it for you directly (uniqueness typing) or you'd need an abstract structure to enforce the invariant (monads, arrows etc etc)
17:25:43 <witten> ok
17:25:59 <witten> just wanted to make sure I wasn't missing something
17:26:20 <witten> is there a good intro to monads anywhere, by the way?
17:26:39 <ski> @google nomaware monad tutorial
17:26:41 <lambdabot> http://www.nomaware.com/monads/html/
17:26:41 <witten> the "gentle intro" one doesn't qualify
17:26:41 <ski> ?
17:26:46 <witten> thanks
17:27:18 <ski> also http://www.cs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
17:27:27 <Cale> Shameless Plug: http://www.haskell.org/hawiki/MonadsAsContainers :)
17:29:00 <ski> and  http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
17:29:05 <ski> (see http://www.haskell.org/hawiki/UsingMonads)
17:32:14 <ski> hello havoc651
17:33:23 <brx> hey havoc651
17:47:08 <samx> trying to learn haskell&monads is giving me a headache
17:49:13 * ski is off
17:53:34 <rep> http://www.haskell.org/hawiki/MonadsAsContainers <- this is GREAT
17:56:39 <juhp> yay, the haddock package for Fedora Extras is starting to be reviewed :)
18:40:42 <Torrente> Hi
18:45:08 <Torrente> about monadic type inference algorithm....
18:45:35 <Torrente> someone know one paper?
19:04:34 <sethk> hey,all, I'm looking at the parsec docs, and there is a data statement,   data LanguageDef st       Is the st state monad?  How am I supposed to know that?  What exactly does that _mean_?
19:08:58 <Cale> sethk: well, it's a type variable. Look how it's used in the definition of LanguageDef
19:09:22 <Cale> you see that it gets passed to CharParser
19:09:44 <Cale> CharParser st a is a type synonym for GenParser Char st a
19:09:47 <sethk> Cale, that's my problem, I see absolutely nothing in LanguageDef.  LanguageDef has a list of functions, some of which have an st argument and some of which don't.
19:09:52 <Cale> The General Parser GenParser tok st a data type represents a parser that parses tokens of type tok with a user supplied state st and returns a value of type a on success. GenParser is an instance of the Functor, Monad and MonadPlus classes.
19:10:23 <sethk> Cale, yes, but where does the st come from?  How do I pass it to anything?
19:10:31 <Cale> st is a type variable
19:10:36 <sethk> Cale, I'm trying to use makeTokenParser
19:10:48 <sethk> Cale, then it's a completely undefined type variable
19:10:55 <Cale> makeTokenParser :: LanguageDef st -> TokenParser st
19:11:10 <sethk> Cale, if that's just a type variable, it implies that I can pass any type to it
19:11:16 <sethk> Cale, but I doubt that's correct
19:11:17 <Cale> right
19:11:21 <Cale> that's correct
19:11:31 <sethk> Cale, if it can be any type, why do I need it at all?
19:11:35 <Cale> whichever type of state you'd like to maintain while parsing
19:12:11 <sethk> I just don't see how, using the parsec functions, I can maintain _any_ state information.
19:12:14 <Cale> getState and setState do the obvious with respect to the state
19:12:26 <sethk> not obvious at all, at least to me.
19:12:30 <sethk> what would be obvious?
19:12:30 <Cale> and updateState applies a function to the state
19:12:34 <Cale> oh
19:12:41 <Cale> well, getState returns the current state
19:12:48 <Cale> and setState sets it to a value
19:13:08 <sethk> you're three steps ahead of me.  If I have no idea what the current state means, I don't know why I would get it, set it, or apply a function to it.
19:13:26 <Cale> oh
19:13:32 <sethk> and I especially don't know where to start, which is to provide an argument to makeTokenParser
19:13:36 <Cale> for whatever reason you'd like while parsing
19:13:42 <Cale> you don't have to use it at all
19:13:56 <sethk> ok.  So st here has nothing to do with, say, Control.Monad.ST?
19:14:01 <Cale> nope
19:14:14 <sethk> ok.  So I could pass an Int to it.
19:14:20 <mauke> well, kind of, since a parser is a state monad
19:14:21 <Cale> (except that they're both related to state)
19:14:52 <sethk> mauke, then I don't understand, because we just said that I can pass in an Int parameter
19:14:58 <Cale> This state is above and beyond the state which the parser needs for parsing
19:15:18 <Cale> You can certainly pass it an Int
19:15:19 <sethk> ok.  so I can just pass any old thing into it until I figure out how to really use it.
19:15:32 <Cale> I recommend leaving it abstract
19:15:48 <Cale> (just put a variable there)
19:16:18 <sethk> ok, I'll try that to begin with, at least as a tactic.
19:16:22 <sethk> but
19:16:55 <sethk> in the example, he passes something in to makeTokenParser, specifically, (haskellDef { reservedOpNames = ["*","/","+","-"]})
19:17:01 <sethk> are you saying this does absolutely nothing?
19:17:17 <Cale> haskellDef  :: LanguageDef st
19:17:29 <Cale> the state parameter is still not specified there
19:17:57 <sethk> but then I have to provide an argument of type LanguageDef st.  How can I do that if I don't know what st is?
19:18:05 <Cale> the type "LanguageDef st" is more fully written as "forall st. LanguageDef st"
19:18:24 <sethk> that doesn't help me construct an argument of type LanguageDef st
19:18:25 <Cale> it means that you can do it for *any* st
19:18:44 <sethk> but what is LanguageDef, then?
19:18:52 <Cale> simpler example: look at the type of "length" in the prelude
19:18:56 <Cale> @type length
19:19:02 <lambdabot> forall a. [a] -> Int
19:19:12 <Cale> it doesn't matter what 'a' is
19:19:33 <sethk> not true at all.  a has to be a type for which length makes sense
19:19:40 <Cale> no
19:19:51 <sethk> no?  I can use length on any type at all?
19:20:07 <Cale> for any type a, you can apply length to lists of values of type a
19:20:27 <sethk> oh, ok.  so it has to be a list.
19:20:35 <sethk> that doesn't help me much with LanguageDef st
19:20:43 <sethk> It isn't that I don't understand the concept of a type variable
19:20:49 <Cale> well, in that case, it has to be a LanguageDef
19:20:54 <Cale> but the state type doesn't matter
19:21:32 <sethk> the only information about LanguageDef that I have is that makeTokenParser takes an argument of type LanguageDef st
19:21:48 <Cale> since all type variables in type signatures implicitly have foralls applied to them
19:21:52 <sethk> then I have some LanguageDef things in Parsec.Token
19:22:00 <sethk> Cale, that isn't what I'm having problems with
19:22:12 <sethk> as I said, it isn't that I don't understand the concept of a type variable
19:22:18 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#LanguageDef
19:22:36 <sethk> Cale, I've been looking at that all along.  Let me make sure it is the same one.
19:23:09 <sethk> hm, no that's completely different.
19:23:17 <Cale> so a value of type LanguageDef st is a record with all those things in it
19:23:22 <sethk> it's out of date, but maybe it will help me make some sense of it.
19:23:51 <sethk> the haddoc docs just have a list of LanguageDef things
19:24:26 <sethk> so this says that I have to use one of the already defined language defs
19:24:45 <sethk> which means that I can't use it to construct a parser for any arbitrary language
19:24:51 <Cale> hm?
19:25:07 <Cale> You could build a LanguageDef record yourself.
19:25:29 <sethk> ok.  let me see if I can see how to do that
19:25:48 <sethk> So I need to construct functions of type CharParser st Char
19:25:52 <Cale> yep
19:26:15 <Cale> there are tons and tons of functions to help with that
19:26:40 <samx> anyone know of a simple tutorial into monadic transformers?
19:26:53 <neadjneki> i wonder why an import could fail.. using ghc 6.5 Control.Monad.State fails (module not found) though Control.Monad doesnt.
19:27:13 <samx> ..or combining monads in general, if there are other approaches used than monad transformers
19:27:18 <sethk> neadjneki, Control.Monad.ST I believe is the current name
19:27:34 <Cale> Control.Monad.State and Control.Monad.ST are different
19:27:44 <sethk> oh, sorry about that.
19:27:58 <Cale> samx: http://www.nomaware.com/monads/html/ -- part 3
19:28:30 <sethk> oh, I see it.  I misread the index, sorry again
19:29:04 <neadjneki> it does find ST too, and they are in the very same dir :o
19:29:34 <samx> cale, tried that, was hoping for something simpler.. e.g. combining IO and error monads, not continuations :-)
19:30:15 <sethk> Cale, you said that CharParser is GenParser Char st a.  I'm going to ignore st here as well, for the moment?  It can be any type at all?
19:30:32 <Cale> samx: there should be plenty of practical examples in there -- ignore the stuff about continuations if you want
19:30:42 <Cale> sethk: yep
19:30:52 <Cale> just like the a in length :: [a] -> Int
19:31:24 <Cale> sethk: you're free to choose it if you decide that you need to keep track of some extra state
19:31:29 <samx> calc, as far as i could see, the only monad tranformer example was related to continuations, which isn't too helpful, when i'm still trying to learn basic stuff like io
19:32:00 <sethk> Cale, ok, at this point I want to postpone as much as possible and understand what parsec is doing, so I'll leave it abstract as you suggested before.
19:32:38 <Cale> http://www.nomaware.com/monads/html/xformerexamples.html
19:33:10 <sethk> Cale, so to construct a LanguageDef, I create a file that contains commentStart, commentEnd, ..., as listed for LanguageDef
19:33:20 <sethk> Cale, do I make it a module?
19:33:52 <Cale> sethk: no, just a value
19:34:00 <sethk> Cale, with a data statement?
19:34:31 <sethk> Cale, can the value have any arbitrary name, as long as it has those functions (String, String, String, Bool, ... etc.)?
19:34:34 <Cale> this is probably one of the most awkward cases possible to explain how types work in Haskell. :)
19:34:44 <Cale> You basically would just write:
19:34:50 <sethk> Cale, unfortunately it is the one I need to use to translate my program into Haskell
19:35:02 <sethk> Cale, or use happy, I think it is called.
19:35:13 <Cale> myLanguage = LanguageDef { commentStart = ... , commentEnd = ..., ... }
19:35:27 <Cale> where you fill in all the fields
19:35:48 <Cale> then myLanguage :: LanguageDef st
19:35:53 <sethk> Cale, ok, that won't be a name clash, because the name LanguageDef is already defined?  Is it ok because LanguageDef is defined in Text.ParserCombinators.Parsec.Token?
19:36:12 <mauke> LanguageDef is a constructor
19:36:21 <sethk> Cale, I put the type annotation _after_ the constructor?
19:36:41 <sethk> oh, then I use Text.ParserCombinators.Parsec.Token.LanguageDef  ?
19:37:25 <Cale> sethk: have you carefully read through a Haskell tutorial, like YAHT?
19:37:32 <sethk> Cale, by the way, this won't exactly work, because the delimiter characters change (it uses scanner states in flex)
19:37:44 <sethk> Cale, oh, yes, many many times.
19:37:55 <sethk> Cale, unless you already know what they mean, they don't explain anything.
19:38:19 <sethk> Cale, it's hard to explain to people who already understand this stuff, but saying   xyz has the type a -> b -> c   really says nothing at all.
19:38:27 <neadjneki> i think the nomaware tutorial is very good
19:38:57 <sethk> I'm not saying they aren't good
19:39:15 <sethk> I'm saying you can read them all, understand (more or less) them all, and still not know which end is up when you go to write a program.
19:39:44 <Cale> well, xyz has type a -> b -> c means that for any types a, b, and c,  xyz is a function which takes a value of type a, and a value of type b, and produces a value of type c. There aren't many functions like that.
19:39:49 <sethk> I've written hundreds of thousands of lines of code, but I just can't fit these things into any concepts I'm familiar with
19:40:35 <sethk> let's take a specific example
19:40:42 <sethk> I want to understand the type GenParser
19:41:06 <mauke> GenParser isn't even a type
19:41:09 <sethk> so I :browse Text.ParserCombinators.Parsec, and I see a million instances of GenParser, but not a definition.
19:41:26 <Cale> mauke: type constructor then :)
19:41:27 <mauke> it's an abstract type
19:41:37 <sethk> mauke, ok, CharParser is a type, and CharParser is an alias for GenParser Char st a, so how can GenParser not be a type?
19:41:44 <int-e> newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a)) ... in Prim.hs
19:42:08 <sethk> int-e, why newtype?  why not type?
19:42:26 <Cale> type only makes type synonyms -- like typedef in C.
19:42:37 <Cale> (only they're allowed to have parameters still)
19:43:07 <Cale> newtype makes an actual new type which is different from every other type in the program
19:43:21 <sethk> Cale, ok, that helps.
19:43:34 <int-e> Cale: how is newtype different from data with just one constructor?
19:44:17 <Cale> int-e: well, two things -- newtype only does things in the type system -- the runtime bits representing values of the newtype are the same as the type it wraps
19:44:33 <Cale> also, related to this, there is a strictness concern with pattern matching
19:45:09 <Cale> Because data declarations define boxed values, if you had say,  data Dollars = Dollars Integer
19:45:11 <sethk> Cale, looking in the "gentle introduction", it says "the newtype declaration creates a new type from an existing one"
19:45:17 <Cale> yes
19:45:19 <Cale> it does
19:45:21 <sethk> Cale, which seems to be the opposite of what you just said
19:45:23 <int-e> ok, thanks. I'll have to read up on the details some day :)
19:45:55 <Cale> then you could do something like (\Dollars x -> ()) (Dollars undefined)
19:46:02 <Cale> and have it work
19:46:37 <sethk> Cale, why doesn't   type CharParser st a = GenParser Char st a    not create a new type from an existing one?
19:46:51 <sethk> Cale, did we say GenParser is not a type?
19:46:51 <Cale> It just gives a new name to an existing type
19:47:05 <mauke> so type creates a new name for an existing type, newtype creates a new type from an existing type, and data creates a type from scratch?
19:47:16 <Cale> yep
19:47:19 <sethk> Cale, wait, CharParser is not the same as GenParser
19:47:23 <Cale> right
19:47:29 <sethk> so it is a new type
19:47:40 <Cale> but CharParser st a is the same as GenParser Char st a
19:47:46 <int-e> Charparser st a ist exactly the same type as GenParser Char st a.
19:47:47 <Cale> the same type
19:48:08 <int-e> you can use both interchangably.
19:48:10 <sethk> ok, then, GenParser's definition uses Parser
19:48:23 <sethk> Cale, that doesn't mean it isn't a new type
19:48:36 <sethk> Surely the fact that the type has two names doesn't mean that it isn't new?
19:48:37 <Cale> GenParser's actual definition is an implementation detail that you shouldn't have to care about too much
19:48:57 <Cale> sethk: it's just a new name for a type, not a new type
19:49:00 <sethk> having created Integer, is it then true that all types that have Integer in them already exist?
19:49:17 <Cale> nope
19:49:23 <int-e> that's a philosophical question
19:49:25 * int-e giggles.
19:49:26 <Cale> hehe
19:49:40 <sethk> int-e, no, really, it isn't, if you are trying to understand the concept.
19:49:59 <sethk> we have GenParser, defined with newtype as  Parser (State tok st -> Consumed (Reply tok st a))
19:50:09 <sethk> so why isn't GenParser just another name for  Parser (State tok st -> Consumed (Reply tok st a))
19:50:10 <sethk> ?
19:50:15 <sethk> and so not a new type?
19:50:30 <Cale> because it was declared with newtype
19:50:34 <mauke> because you're not supposed to know the definition of GenParser
19:50:49 <mauke> it's meant to be abstract
19:51:10 <sethk> if I don't know the definition of GenParser, then what does CharParser _mean_?
19:51:32 <Cale> CharParser is just a GenParser whose tokens are Chars
19:51:40 <Cale> from the docs:
19:51:50 <Cale> The General Parser GenParser tok st a data type represents a parser that parses tokens of type tok with a user supplied state st and returns a value of type a on success.
19:52:03 <sethk> Cale, ok, but if I don't know what a GenParser is, what good does it do me to know that a CharParser is a GenParser whose tokens are Chars?
19:52:15 <Cale> well, take that description there as a definition
19:52:24 <sethk> Cale, well, ok, but then I _am_ supposed to know what GenParser is.
19:52:30 <mauke> sethk: you don't
19:52:35 <int-e> and the Parser is actually a marker (similar to a constructor in the data declaration - which is why I asked about differences here), and (State tok st -> Consumed (Reply tok st a)) the type.
19:52:36 <Cale> Yes. You just shouldn't worry about how it's actually represented :)
19:52:42 <mauke> you don't need to know what it is
19:52:53 <mauke> you only need to know what operations it supports
19:53:04 <sethk> mauke, no, not if I want to understand what is happening here.
19:53:18 <Cale> int-e: yeah, and the difference between data and newtype is that with data, that marker exists at runtime, whereas with newtype it doesn't.
19:53:21 <sethk> mauke, I need to know what those operations _do_ if I'm going to write useful programs
19:53:30 <mauke> sethk: the operations are documented
19:53:44 <Cale> sethk: have you read the Parsec documentation online?
19:53:51 <int-e> Cale: figured; I just wondered about the differences on the semantic level. You gave me some ideas for that.
19:53:51 <mauke> sethk: do you need to know the implementation of Integer to understand 2 ^ 100?
19:54:01 <sethk> mauke, absolutely
19:54:08 <sethk> mauke, not to use, to understand, absolutely
19:54:20 <mauke> well, I disagree
19:54:22 * int-e thinks sethk should start with easier examples.
19:54:23 <sethk> mauke, and even if I don't need to, I _can_
19:54:52 <Cale> But there are many different ways to implement the operations which Integer supports, and they all work out to the same thing.
19:54:57 <sethk> but getting the information from the documentation instead of the source code is just a crutch because I don't really understand the source code.
19:54:59 <sethk> Cale, so what?
19:55:08 <sethk> Cale, I'm not trying to write a program that uses Integer
19:55:16 <Cale> Right - it was an example
19:55:16 <sethk> I'm trying to (by analogy) _understand_ integer
19:55:25 <sethk> Cale, I know
19:55:26 <mauke> sethk: which implementation of Integer?
19:55:53 <sethk> mauke, I need to be able to take the source code for _any_ implementation of Integer and figure out what it is doing.
19:56:05 <mauke> the Integer whose implementation you can understand is not the true Integer
19:56:25 <sethk> mauke, why?  Didn't the person who wrote the code understand it?
19:56:49 <sethk> mauke, I can certainly understand the abstraction if I understand the implementation
19:57:16 <sethk> but without understanding the implementation I'm dependent on the documentation, not the source code, which is unacceptable.
19:57:43 <sethk> I'm not just doing this as an academic exercise, I'm writing code that has to be used and supported
19:57:51 <mauke> it reminded me of http://catb.org/~esr/jargon/html/T/the-X-that-can-be-Y-is-not-the-true-X.html
19:58:00 <sethk> if there should be a problem in the library I have to be able to find and fix it.
19:58:14 <sethk> so I _must_ be able to understand the implementation.
19:58:26 <neadjneki> also you could make incorrect assumptions due to certain implementation details, and abuse them.
19:58:36 <sethk> neadjneki, sure I could.  So what?
19:58:46 <Cale> sethk: are you going to take this down to the electronic level? :)
19:58:49 <sethk> neadjneki, the fact that a mistake could be made is hardly relevant.
19:58:54 <neadjneki> so a change in the implementation can bring your code down
19:59:03 <sethk> Cale, oh, I'm an E.E for 35 years, I have no problems whatsoever with the electronic level
19:59:28 <sethk> Cale, I could easily build the machine out of transistors if necessary
19:59:31 <mauke> why are you using haskell at all if you don't know what asm it generates?
19:59:31 <Cale> sethk: the point is that you shouldn't have to care about it
19:59:35 <sethk> it would create a lot of heat :)
19:59:49 <neadjneki> sethk the reason for separating any interface and implementation is minimizing dependency
20:00:03 <sethk> neadjneki, you are looking at the problem backwards
20:00:20 <sethk> neadjneki, I have a library here.  I may use it in a product that will have to be supported, maintained, etc.
20:00:36 <sethk> neadjneki, _I_ have to fix it, if the library doesn't correctly implement the interface
20:00:45 <Cale> sethk: we do this in mathematics -- we axiomatize things, show that there's some model of the axioms, and then proceed not to care about any particular model.
20:00:55 <neadjneki> well you can look at the implementation if it is opensource. if not, you would not even be able to change it either
20:01:11 <sethk> Cale, that's academic.  I'm not doing an academic exercise.  I'm producing a product that has to _work_, and if it doesn't work then I have to fix it.
20:01:20 <sethk> neadjneki, I have to understand it, not look at it.
20:01:24 <Cale> sethk: mathematics seems to work :)
20:01:26 <int-e> FWIW, GenParser (which is a monad) has getState and setState 'methods' which can be used to modify that internal state - from that and elementary char parsers one should be able to build state sensitive char parsers.
20:01:36 <sethk> Cale, well, that can't be proven  :)  but it's irrelevant
20:01:44 <int-e> and 'st' is just the type that represents that internal state
20:01:50 <sethk> Cale, I'm talking about something very concrete here.
20:02:20 <sethk> The people who stand to lose lots of money if this thing does not work will not accept a situation where there is a possibility that something can't be fixed
20:02:36 <sethk> which means that I have to understand all this stuff, not just use it.
20:02:41 <mauke> that's why no one uses windows!
20:02:49 <neadjneki> :)
20:02:55 <sethk> mauke, everyone, unfortunately, uses windows
20:02:55 <int-e> mauke: haha.
20:03:11 <sethk> mauke, I spend a lot of my life trying to move people away from windows, more successfully then most
20:03:18 <Cale> heh
20:03:23 <sethk> mauke, and I'm trying to move them from C++ and Java to a better language
20:03:33 <sethk> but I _must_ be able to fully support that language.
20:04:20 <sethk> so that's not negotiable.  I can't use it unless I can be certain that I understand it and can fix it if necessary
20:04:43 * int-e wonders if it's a good idea to suggest reading the STG-machine paper.
20:04:50 <mauke> what compiler are you using?
20:04:52 <sethk> int-e, oh, I've read that three times
20:04:57 <sethk> mauke, ghc
20:05:06 <mauke> do you understand ghc's internals?
20:05:14 <sethk> I thought there was a way to get ghc to print out all the types it deduces.
20:05:23 <sethk> mauke, not all of it, not by many miles.  yet.
20:05:28 <mauke> what if it miscompiles your program? you'll have to fix it if necessary.
20:05:39 <sethk> mauke, but, if I use the language for commercial programs, I _will_ understand the compiler
20:06:11 <mauke> oh, and you better understand the OS you're running the compiler on, for obvious reasons
20:06:20 <sethk> mauke, absolutely
20:06:26 <Cale> why not just be prepared to file a bug?
20:06:28 <sethk> mauke, if necessary, I can fix a bug anywhere in the o/s
20:06:31 <mauke> and the processor that implements the machine code, and its microcode
20:06:35 <sethk> Cale, because there is no commercial support
20:06:37 <sethk> mauke, of course
20:06:45 <sethk> mauke, occasionally a problem pops up in all of those.
20:06:55 <sethk> mauke, over my career I've made corrections at all those levels
20:06:55 <gzl> what if the electrons screw up?
20:06:59 <gzl> *ducks*
20:07:54 <sethk> gzl, I discussed that, believe it or not, for several hours with several physicists at Los Alamos
20:07:59 <Cale> I don't see the need for one person to take on all of that responsibility as one person. I suppose it's great if you can, but terribly unnecessary. Nothing would ever get done if people insisted on it.
20:08:04 <sethk> gzl, one actually _did_ contend that electrons wear out.
20:08:07 <palomer> oh haskell
20:08:17 <sethk> Cale, you don't understand.  I have to know that I _can_ fix it, if necessary
20:08:29 <sethk> Cale, just as I know that, if necessary, I can fix the C compiler
20:08:31 <palomer> btw, I have a neat random lambda term generator if anyone wants
20:08:39 <mauke> hahaha, what if there's a bug in quantum physics?
20:08:39 <palomer> it's, like, 10 lines of code
20:08:57 <Spark> being able to do something, and being able to arrange the doing of something, are equivalent :)
20:09:09 <neadjneki> sethk if you use newtype you can fix the inner workings without altering code that depend on it ;)
20:09:10 <sethk> mauke, in that case I might be up against it.  :)
20:09:11 <Spark> or maybe thats just the philosophy of an extrovert
20:09:28 <sethk> neadjneki, fine.  The point is that questions about how things work are _not_ irrelevant
20:09:44 <sethk> neadjneki, and in the so called "real world" you can't compartmentalize and just play with one small area.
20:09:47 <mauke> btw, I've written something similar to parsec and I still don't understand how parsec works
20:10:02 <neadjneki> sethk ok, sorry :)
20:10:18 <Cale> sethk: well, largely, people can and do
20:10:27 <sethk> mauke, I'm sure that's quite true.  But I need to understand it before I invest hundreds of thousands of dollars
20:10:45 <sethk> Cale, with haskell it is different, also.  You can hire 100 guys off the street that can fix a c compiler
20:10:55 <sethk> so, paradoxically, it is _less_ important to be able to fix it.
20:11:06 <sethk> there are probably not 100 people in the world who could fix ghc
20:11:18 <sethk> and so you have to face the question of what happens if it is broken.
20:13:55 <Cale> you rewrite the small part of your program that's affected in such a way that doesn't cause the bug to appear, and file a bug report?
20:14:07 <sethk> Cale, sometimes, yes.  but not always
20:14:52 <sethk> Cale, regardless, there is absolutely no reason that I can't understand the parsec implementation sitting in front of me.
20:15:07 <Cale> sure - Parsec shouldn't be too hard
20:15:11 <sethk> or, to put it better, I have to know that I _can_, if I need to.
20:15:18 <Cale> but I recommend learning to use it before learning how it works
20:15:22 <sethk> Cale, once you really understand the language, I'm sure.
20:15:44 <Cale> and also, you should have a firm grasp of types, and then monads
20:15:44 <sethk> Cale, if I can, sure.  But, right away, I can't do anything useful with it without constructing this language definition thing
20:16:22 <gzl> you discussed this with people at Los Alamos?
20:16:42 <sethk> gzl, I tried to.
20:16:57 <sethk> gzl, I have a good friend there who can look at an equation and "see" the orbit it represents
20:17:10 <sethk> gzl, but he says he can't do mathematical logic.  :)
20:18:44 <gzl> mathematical logic is nuts
20:19:09 <Cale> constructing the LanguageDef shouldn't be too hard, even if a little tedious
20:19:26 <sethk> Cale, I think I see how to do it now.  But I didn't before our discussion.
20:22:21 <sethk> hey, xchat let me save the window contents without crashing.   :)
20:22:26 <sethk> xchat is definitely not written in haskell.
20:24:10 <sethk> Cale, I asked this before, but I'm not sure if you answered.  I can put a type annotation (in your example for MyLanguage) after defining it with myLanguage = LanguageDef { commentStart = ... }
20:24:37 <Cale> yeah
20:24:52 <Cale> myLanguage :: LanguageDef st
20:25:06 <sethk> that's interesting.  Hasn't the compiler already induced the type?
20:25:43 <Cale> it will if you leave that out
20:25:51 <Cale> but if you put it in, it will verify the type
20:25:59 <int-e> no. it first reads all the declarations, then does type checking.
20:26:02 <sethk> ok.  multiple passes, I take it.
20:26:10 <sethk> int-e, ok, thanks much
20:26:15 <sethk> Cale, thanks for all your help.
20:26:21 <Cale> no problem
20:42:18 <dons> morning all
20:48:03 <ulph2> what's wrong with
20:48:04 <ulph2> > type LocalS a = StateT Local (GlobalS) a
20:48:04 <ulph2> > type GlobalS a = StateT Global (Either String) a
20:48:30 <ulph2> "Type synonym `GlobalS' should have 1 argument, but has been given 0"
20:48:34 <ulph2> It doesn't make sense
20:49:13 <sethk> ulph2, the first line uses GlobalS with one argument, a
20:49:39 <sethk> ulfdoz, either must gobble up two arguments?
20:49:59 <sethk> ulph2, but don't take my word for it, I'm learning
20:52:14 <ulph2> I think I'm supposed to leave out the last argument since it's a Monad Transformer
20:53:35 <ulph2> > type TestS a = StateT Local (StateT Global (Either String)) a
20:53:38 <ulph2> that works
20:54:25 <rasfar> dons: evening
20:55:21 <ulph2> But can't I define it in two steps?
20:56:32 <int-e> type GlobalS = StateT Global (Either String)   appears to compile though
20:58:24 <ulph2> Yes that should work. Hm.
20:58:34 <ulph2> Oh.
20:59:19 * int-e has a linking problem with that :/
21:00:40 <ulph2> Monad transfors are magic ;/
21:00:47 <ulph2> transformers*
21:01:13 <int-e> it doesn't have to do with the transformers - import Control.Monad.State  alone causes ist. weird.
21:02:47 <int-e> [undefined reference to `__stginit_ControlziMonadziState_']
21:03:30 <ulph2> Hm
21:04:23 <int-e> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg07480.html seems to be related to that.
21:05:26 <ulph2> oh, -package mtl
21:06:27 <int-e> yep, as the followup explains. that helps. :)
21:12:32 <int-e> Ok, leaving out type parameters like that in type synonyms is covered by the Haskell 98 language report. (http://www.haskell.org/onlinereport/decls.html#sect4.2.2)
21:15:20 <ulph2> Ah, thanks!
21:16:03 <ulph2> :)
21:22:06 <int-e> good night
21:59:57 <ulph2> @type evalStateT
22:00:17 <lambdabot> bzzt
22:01:07 <Lemmih> @type Control.Monad.State.evalStateT
22:01:10 <lambdabot> forall a (m :: * -> *) s.
22:01:10 <lambdabot> (Monad m) =>
22:01:10 <lambdabot> Control.Monad.State.StateT s m a -> s -> m a
22:10:04 <araujo> Can't i do something like:
22:10:06 <araujo> mp = do m <- (getArgs >>= cOpts >>= parseOpts)
22:10:06 <araujo> 	m !! 0
22:11:04 <mauke> maybe
22:11:58 <araujo> lisppaste2, help?
22:11:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:12:18 <lisppaste2> araujo pasted "error" at http://paste.lisp.org/display/11987
22:12:24 <araujo> i ma getting that
22:13:01 <mauke> what is the type of cOpts?
22:13:05 <TheHunter> try return $ m !! 0
22:13:06 <araujo> parseOpts returns IO [String]
22:13:16 <araujo> cOpts :: [String] -> IO [Flag]
22:13:38 <mauke> and parseOpts?
22:14:14 <araujo> parseOpts :: [Flag] -> IO [String]
22:14:29 <mauke> looks like TheHunter is right
22:14:48 <araujo> So i _need_ to return a monad?
22:15:46 <mauke> you can't take things out of the IO monad
22:16:21 <TheHunter> do x <- m; f x is being transformed to m >>= \x -> f x, so if you look at the type of (>>=) it is clear that the last statement in a do-expression can't be a non-monadic expression.
22:16:40 <mauke> I wonder why getArgs isn't a plain [String]
22:17:19 <mauke> the IO part seems useless to me
22:20:17 <araujo> TheHunter, oh, i see now
22:20:37 <TheHunter> We want things to always be the same even between different invocations of programs. (I know many of the Data.Char stuff violates that principle).
22:20:52 <TheHunter> @index setArgs
22:20:53 <lambdabot> bzzt
22:23:34 <araujo> TheHunter, So, do preserves the monad in the sameway of >>= ?
22:24:26 <TheHunter> do-notation is syntactic sugar for >>=
22:28:42 <araujo> True.
22:31:34 <mauke> args :: [String]
22:31:46 <mauke> args = unsafePerformIO getArgs
22:31:56 <mauke> is there anything wrong with that?
22:34:43 <Lemmih> Yes.
22:37:44 <mauke> to wit?
22:39:38 <Lemmih> It'll annoy people trying to use the program from GHCi.
22:43:22 <mauke> because :set args doesn't work?
22:45:24 <Lemmih> Yes, withArgs wouldn't be effective.
22:46:57 <mauke> ah
22:50:10 <gour> @where hIDE
22:50:11 <lambdabot> http://www.haskell.org/hawiki/hIDE
22:55:50 <autrijus> greetings
22:57:56 <maayhme> @where linear
22:57:56 <lambdabot> I know nothing about linear.
23:33:07 <JohnMeacham> hello.
23:33:27 <musasabi> I think I got the comonadic syntax right at last :-)
23:34:51 <musasabi> now to write a small page describing it.
23:34:56 <musasabi> JohnMeacham: good morning.
23:41:20 <rasfar> somebody illuminate me please
