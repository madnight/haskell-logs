00:00:56 <JohnMeacham> I asked the same thing on the list a while ago.. ideally (a,,,c) -> \x y -> (a,x,y,c)
00:01:23 <JohnMeacham> the main objection was it was unclear what (a,,(b,)) should do.
00:11:32 <manulito_> "myfunc :: [int] -> int"   can i then use "myfunc @mylist(x:xs) = foobarr mylist x" for example
00:12:15 <manulito_> is the @-notation a way to name my inparameter list?
00:12:42 <manulito_> ahh its mylist@(li:st)
00:14:12 <Cale> @ just lets you give a name to the whole pattern match
00:14:13 <lambdabot> Maybe you meant: all-dicts arr babel botsnack code define definitions
00:14:13 <lambdabot> del-definition devils dice dict dict-help docs dummy dynamic-load
00:14:13 <lambdabot> dynamic-reload dynamic-unload easton echo elements elite eurohaskell
00:14:13 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
00:14:13 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
00:14:15 <lambdabot> hoogle hoogle+ index jargon join karma karma+ karma- kind lambda
00:14:17 <lambdabot> learn leave libsrc listchans listcommands listmodules lojban moo
00:14:19 <lambdabot> [6 @more lines]
00:14:21 <Cale> heh
00:18:26 <manulito_> myfunc :: [int]->int
00:18:56 <JohnMeacham> you probably mean [Int] -> Int
00:18:57 <manulito_> myfunc mylist@(x:xs) = mylist !! x
00:19:05 <manulito_> yeah :>
00:19:30 <manulito_> ok, it worked now nayway, thanks
00:20:37 <boegel> @y0w
00:20:39 <lambdabot> I guess it was all a DREAM ... or an episode of HAWAII FIVE-O ...
00:20:47 <licebowl> small problem. I'm doing some algebraic simplification with a function in Haskell and I'm not sure how to make the recursion work correctly
00:21:14 <ricebowl> for ex. I get Add (Mul (Var "x") (Num 0)) (Var "y")
00:21:22 <ricebowl> should reduce to Var "y", but it can't
00:21:33 <JohnMeacham> do you use dvorak out of curiosity?
00:22:10 <ricebowl> none of my special cases for Add match, so the general case of simplifying Add x y -> Add (simplify x) (simplify y) matches... but now I need to try and simplify the resulting expression without causing infinite recursion
00:22:52 <JohnMeacham> What I have done in this case is use a monad and 'fail' if there is nothing you can do, then only recurse if the subcomputation returns a value.
00:23:23 <ricebowl> hm... kind've ugly, I'd have sworn I solved this same problem in ML before :|
00:23:57 <JohnMeacham> like.. have your default case be 'fail "nothing to do"' and 'return' your other values. it is not that ugly at all if you use 'do' notation. but i would be curious what other people have done.
00:24:35 <JohnMeacham> hmm. might actually be simpler with a Writer Monad... or something other than a Monad completly.
00:25:17 <gour> Lemmih: I can't build hiDE, it gives - Could not find module `Hide.Hooks': while building hide-shell
00:28:03 <Itkovian> I have a question about Haskell and computation state.
00:28:57 <Itkovian> As functional programs evaluate to the same result, provided the input is the same, would it be possible to wrap the 'state' of a program and move it with the code to another machine?
00:29:42 <Heffalump> Add x y | simplifiedx /= x || simplified y /= y -> Add simplifiedx simplified y
00:29:43 <Heffalump> ...
00:29:44 <JohnMeacham> that is usually called 'process migration' and many distributed operating systems provide it as a primitive.
00:29:48 <Heffalump>   simplifiedx = simplify x
00:29:54 <Heffalump>    simplifiedy = simplify y
00:30:10 <Heffalump> (but with the indentation done properly and a where keyword at the appropriate place)
00:30:21 <JohnMeacham> however, pure functional programs should be signifigantly easier to migrate as you would not have to worry about interaction with the world.
00:31:09 <Heffalump> semantically, it should be easy cos of what John says. Practically, it's hard because functional languages are implemented imperatively
00:31:20 <Heffalump> so figuring out the right state to move is quite a bit of work
00:31:49 <Heffalump> oh, an entire program, rather than just a subcomputation
00:32:00 <Heffalump> well, an entire program is of type IO (), which is rather less portable
00:32:09 <JohnMeacham> http://www.cs.virginia.edu/cgi-bin/manpage?section=1&topic=undump is a oldie but goodie. not powerful enough for true migration though.
00:32:35 <ricebowl> Heffalump - that makes sense, I didn't think about using guards, thanks
00:32:45 <ricebowl> am going to look and see what I did before, though...hm
00:33:42 <JohnMeacham> Yeah, the equality method of recursion limiting does work, but it has a horrible flaw, you end up rerecursing the whole tree after every operation giving you superlinear behavior. if speed isn't an issue or your terms are all small it probably doesn't matter though.
00:34:06 <Heffalump> but simplify probably recurses the whole tree. Or was that part of the definition of simplify itself?
00:34:43 <Heffalump> the efficient answer is to make simplify return a tuple indicating whether something changed
00:34:53 <Heffalump> (or use a monad as suggested, if that's easier)
00:34:57 <JohnMeacham> Yeah. but then (/=) recurses down each tree again. and then again when you go one level up.
00:35:19 <Heffalump> JohnMeacham: yeah, it's horrible if that's a case in the definition of simplify
00:35:34 <ricebowl> it would have to be
00:35:39 <ricebowl> but I don't see how that is avoidable
00:36:17 <ricebowl> I thought about using a tuple, but then I'd need a where clause for each case
00:36:19 <JohnMeacham> using the monad it would only visit each node at most one more time than the number of times it is changed, giving you linear time behavior.
00:36:21 <ricebowl> but I suppose that is unavoidable, isn't it
00:36:22 <Itkovian> JohnMeacham: well, I don't really have process migration in mind. What I am thinking about is that one part of a computation moves to another machine (implicitly), so it doesn't need to be the whole program
00:37:03 <JohnMeacham> Itkovian: hmm.. I am not sure what you mean, you might want to look at gph, which is a parallel haskell compiler and can work across machines I think.
00:37:04 <Itkovian> and it should keep running
00:37:22 <Itkovian> ok, let me clarify this a bit
00:38:17 <Itkovian> suppose you have machine A and machine B. Say machine A being a laptop or advanced PDA, machine B being a server sitting somewhere.
00:38:33 <JohnMeacham> ricebowl: nope. if you use the monad it is avoidable because you already know if changes were made without having to test for equality after each change.
00:38:51 <Itkovian> The idea is that computations running on machine A could move to machine B, which may implement a different ISA, run another OS, etc.
00:39:06 <ricebowl> yeah, but I don't have the option of using monads
00:39:10 <Itkovian> Supposedly you would do this to save resources, e.g. battery power on machine A
00:39:17 <ricebowl> this is for a class, and the whole point is to make us write code in a functional language ;)
00:39:37 <JohnMeacham> ricebowl: Monads are completly functional. this has nothing at all to do with IO.
00:39:40 <Heffalump> ricebowl: if you use named fields, you can keep it down to as many definitions as the maximum arity of your constructors
00:39:47 <Itkovian> And when you move out of the vicinity of machine B, the computation would move back, along with thew stat it's in
00:40:03 <ricebowl> what exactly does arity mean? I've never encountered that term before
00:40:07 <Heffalump> data Expr = Add { a :: Expr, b :: Expr } | Sub { a :: Expr, b :: Expr }
00:40:10 <Heffalump> number of arguments it takes
00:40:13 <ricebowl> ah
00:40:19 <ricebowl> yes, I know, that's not that bad
00:40:26 <ricebowl> that'll do; thanks for the help
00:40:44 <Heffalump> and as JohnMeacham says, you can use a monad like ST if you want
00:40:49 <Heffalump> that has a run method so it's completely pure
00:40:55 <Heffalump> externally, that is
00:40:57 <JohnMeacham> but you can use 'Maybe' if you want, it is probably simpler if you don't know monad notation, but will be slightly less terse. have simplify return (Just x) if it made changes and Nothing if it didn't have to change anything.
00:41:01 <Heffalump> but internally you get state
00:41:14 <Heffalump> yeah, that's quite nice
00:42:15 <Itkovian> so basically, what I'd like to know is, is it uberhaupt possible to wrap up the state of a haskell app.
00:42:42 <JohnMeacham> so then you have simplify (Add x y) | Just x' <- simplify x = simplify (Add x' y)
00:43:03 <JohnMeacham> simplify (Add x y) | Just y' <- simplify y = simplify (Add x y')
00:43:25 <JohnMeacham> simplify (Add x y) | otherwise = Add x y
00:43:40 <JohnMeacham> I mean
00:43:57 <ricebowl> mm I just figured out how to do it
00:44:12 <JohnMeacham> um. there should be a 'Just' in there.
00:44:23 <ricebowl> simplify (Add x y) = add_ctor (simplify x) (simplify y)
00:44:33 <ricebowl> add_ctor Add x (Num 0) = x
00:44:34 <ricebowl> etc.
00:44:48 <ricebowl> requires a second function, but it's very easy to do
00:45:17 <ricebowl> anyway, I'm going to go back to coding, thanks for the help
00:45:37 <JohnMeacham> yup. as long as your simplifications can be done in a single pass that will work just fine. it hadn't occured to me that would be the case :) I assumed you wanted to do fixpoint iteration.
00:46:01 <JohnMeacham> I just have fixpoint iteration on the brain.
00:48:42 <JohnMeacham> Itkovian: I don't think it would be particularly harder or easier than any other app. there are many distributed operating systems that do just what you say. for the interpreters it probably can be done much easier though, but ghc and jhc compile to object code just like any other app.
00:50:57 <JohnMeacham> Heffalump: I was acutally just thinking of using the Maybe monad. no need for state.
00:55:44 <Heffalump> JohnMeacham: yeah, true
00:56:20 <Heffalump> the advantage of using a changed flag rather than Maybe is that a very good compiler might be able to update in place
01:03:13 <JohnMeacham> Maybe will most likely compile to be faster in both ghc and jhc. the case-elimination transformations win out over update-in-place in terms of gains
01:04:00 <JohnMeacham> update-in-place is actually a pretty minor improvement except in the case of arrays. (for haskell programs)
01:05:03 <JohnMeacham> however, ST definitly will use update-in-place in any case in ghcp
01:06:29 <JohnMeacham> as it is implemented via primitives that do so. it is actually very hard to optimize 'through' mutable state. the compiler might be able to easily prove that something must be 'Just' or must be Nothing, but it is quite tricky to figure out what was last written to some location in the heap.
01:07:59 <JohnMeacham> so.. the moral is.. don't use mutable state unless it gives you an _algorithmic_ benefit. as it most likely will cause somewhat of a slow down as it inhibits certain optimizations.
01:09:12 <Heffalump> ok :-)
01:12:03 <JohnMeacham> Hmm.. I wish IRC were paragraph based. I am used to gale where multiparagraph puffs are quite common.
01:12:16 <JohnMeacham> (or perhaps I wish we were all on gale instead :) )
01:12:35 <Heffalump> how many people use gale?
01:13:10 <JohnMeacham> in the ofb cell? probably 20-30. but there are other cells out there.
01:13:43 <JohnMeacham> I was able to get shapr on briefly.
01:14:13 <JohnMeacham> or.. I should say, he found it through ginsu... I think.
01:14:52 <Heffalump> [09:01] <Heffalump> how many people use gale?
01:14:55 <Heffalump> oops, sorry
01:15:37 * boegel wonders why firefox just crashed
01:16:05 <pejo> boegel, type error probably!
01:16:39 <boegel> pejo: nah, acroread hanged :)
01:16:41 <vegai> irc is hard to beat
01:17:01 <vegai> it needs something more than just technical superiority
01:18:23 <JohnMeacham> use ginsu for a bit :) IRC is soooo easy to beat. it is very difficult to have real conversations on it, it feels very stifling socially.
01:22:10 <JohnMeacham> I mean, a lot of the differerce is cultural. but it is hard to have meaningful group discussions on IRC. topics wander, and both forks should be able to be taken, people following what interests them, but still being able to pay attention to the other ones. plus, it is hard to express yourself when every other line is split up by someone else saying something in an unrelated conversation.
01:22:47 <vegai> JohnMeacham: I mean 'beat' in a way that 90% of irc users move to the new system
01:23:21 <vegai> I have used ginsu a bit
01:23:43 <JohnMeacham> vegai: oh. I don't necesarily want that. but it would be nice to be able to communicate effectivly with people here.
01:24:48 <vegai> so make a ginsu<->irc gateway :P
01:24:55 <JohnMeacham> sorry, I am just sort of rambling.
01:25:15 <vegai> or gale
01:25:19 <JohnMeacham> no, I looked into it. it wouldn't work at all. paragraph based verses line based is just too different of a model.
01:25:40 <vegai> an AI could handle it :)
01:27:36 * cjb uses gale.  :)
01:27:51 <JohnMeacham> indeed he does. :)
01:28:05 * cjb is also late for work.  Oops.
01:28:15 <JohnMeacham> in fact, he is particularly aware of the social benefits of gale.
01:28:35 <cjb> *grin*
01:29:59 <Khisanth> hmm threaded irc conversations
01:32:18 <JohnMeacham> hierarchical threading. with a filtering system based on a nice boolean algebra. you like what someone says but wish they would stop talking about their cat? just a few button presses and his cat comments are filtered out without affecting his other stuff. conversations diverging? move to a new cat, continue both, conversations blurring? they can rejoin.. it is all very nice..
01:32:28 <JohnMeacham> sorry. I will stop now.
01:32:56 <JohnMeacham> the second cat means category and not the feline I should say.
01:36:43 <Heffalump> JohnMeacham: how do you notice if the conversation about the cat drifts back on topic if you're ignoring it?
01:37:21 <Khisanth> the vies ignores it but the model still tracks, assuming some sort of MVC thing :)
01:40:00 <JohnMeacham> Heffalump: because people will start crosspuffing to the other cat.. and you sort of don't ignore anything... you filter things out temporarily while you read one then you unfilter, get a broad overview and change cats.. or just read them all concurrently which is what I tend to do. since it is paragraph based, puffs tend to be spread out in time much more so constant attention isn't needed as much to keep a big picture in
01:40:00 <JohnMeacham> your head about what is going on.
01:41:02 <Khisanth> this sounds like a lot of work just to have a conversation, I thought it was suppose to be an improvement?
01:41:33 <JohnMeacham> it is a huge improvement. in that conversations can happen :)
01:42:25 * Khisanth has yet to experience any problem with having conversations on IRC in the years of using
01:42:27 <Khisanth> it
01:43:11 <JohnMeacham> i mean, someone is going to come along and ask a haskell question, and then this conversation will break up.. we can go to a private room, but then other people won't be able to participate, which is sort of the point. a discussion I should say rather than a conversation.
01:43:25 <Khisanth> although I have been using xchat in all those years and I basically use the colored nicks to track :)
01:44:24 <Khisanth> hehe but having 4/5 simultaneous conversations is not too bad
01:44:38 * boegel does a little dance
01:45:48 <Khisanth> hrm the filtering sounds a lot like the chatting in Guild Wars, but with more control
01:47:40 <JohnMeacham> but you can't carry on a discussion for more than an hour tops maybe before it gets drowned out, a lull in conversation, and it is gone. multi-day discussions are common on gale. several at once. crosspolinating and breaking off occasionally but then getting ressurected without a missed step because you can pull up all past discussion on a topic with one button.
01:50:04 * Khisanth makes a note to remove that shortcut
01:51:02 <Khisanth> JohnMeacham: there are always mailing lists for that :)
01:53:16 <JohnMeacham> but this is the missing link between mailing lists and IRC :)
01:53:32 <JohnMeacham> s/^/ah /
01:54:28 <boegel> JohnMeacham: but can someone do _this_
01:54:30 <boegel> @code
01:54:31 <lambdabot> PackedString.hs: packString :: String -> PackedString
01:54:35 <boegel> @yow
01:54:37 <lambdabot> On the other hand, life can be an endless parade of TRANSSEXUAL
01:54:37 <lambdabot> QUILTING BEES aboard a cruise ship to DISNEYWORLD if only we let it!!
01:54:42 <boegel> @vixen yaay
01:54:54 <Khisanth> on the other hand it's, internet relay chat and I don't associating chatting with any sort of long term discussion :)
01:55:11 <lambdabot> what's the matter?
01:56:16 <JohnMeacham> exactly :)
01:58:17 <Khisanth> hmm but then again I have logs and grep ;)
01:58:32 <JohnMeacham> so do I.
01:59:44 <JohnMeacham> gale in its purest incaration is pure command line. its just the web logs that are all fancy. most logging is just done via gsub pub@ofb.net > mylog.txt
02:05:34 <JohnMeacham> yawn.
02:05:39 <JohnMeacham> time for bed.
02:06:04 <Itkovian> night
02:09:42 <newsham> configure: error: GHC is required unless bootstrapping from .hc files.
02:09:45 <newsham> brilliant!
02:10:02 <newsham> what does a mere mortal without ghc do to build ghc?
02:11:39 <integral> download a binary version...
02:12:24 <Khisanth> and if a binary version isn't available? cross compile? :)
02:12:34 <newsham> also brilliant.
02:13:36 <newsham> can hugs be used to bootstrap ghc?
02:15:27 <adept> newsham: I wonder how he will go about building C compiler on new platform ...
02:21:31 <Heffalump> newsham: what platform?
02:21:37 <Heffalump> oh, he went.
02:21:53 <Heffalump> LFS type, I bet :-)
02:33:02 <SickJacken> i dont get the zipper context datatype; "data Cxt a = Top | L (Cxt a) (Tree a) | R (Tree a) (Cxt a)"
02:33:22 <Heffalump> you understand what a zipper is?
02:33:24 <boegel> yo shapr
02:33:26 <Heffalump> hmm, it does look a bit odd.
02:33:29 <shapr> hiya boegel
02:33:52 <Heffalump> L and R are presumably for having the left and right siblings, but it's not very clear how to go up and down..
02:33:54 <SickJacken> Heffalump, well not really...i read here they want to change locations
02:34:23 <SickJacken> im having trouble interpreting what for example (R (Leaf 1) (L Top (Fork (Leaf 3) (Leaf 4)))) means
02:34:24 <Heffalump> a zipper is an efficient way of storing a tree + pointer to position inside that tree in a functional data structure.
02:34:58 <Heffalump> the idea is that you store (a) the subtree rooted at the pointer (b) a list of layers
02:35:01 <boegel> any luck with TMR yet ? I'm eager, because I want to show my thesis promoter the article :)
02:35:01 <dcoutts> juhp, btw hIDE doesn't use cairo, but does rely on some recent Gtk2Hs bugfixes
02:36:05 <_gour> Chasing modules from: Hide.IdeShell,Hide.PageTree,Hide.MainWindow,Hide.EditorPage,Hide.DemoEditor
02:36:05 <_gour> Could not find module `Hide.Hooks':
02:36:09 <_gour> dcoutts: attempt to build hIDE -
02:36:19 <SickJacken> Heffalump, in the hawiki example they have this tree "Fork (Fork (Leaf 1) @)
02:36:19 <SickJacken>  (Fork (Leaf 3) (Leaf 4))"
02:36:58 <SickJacken> i dont get why going to the right should bring us to 'Leaf 1'
02:38:02 <gour> dcoutts: i'm back
02:38:27 <gour> dcoutts: have you got my msg?
02:39:18 <gour> dcoutts: btw, 0.9.9 is not enough...
02:39:38 <gour> dcoutts: it reqs 0.9.9.5
02:44:11 <dcoutts> gour, yes it does
02:45:50 <juhp> dcoutts: isn't it possible to build it without cairo?  - need to patch the makefiles?
02:46:16 <dcoutts> juhp, it should be posible to build without cairo if your using an earlier version of gtk
02:46:16 <juhp> at least a --with-cairo option would be nice...
02:46:32 <juhp> dcoutts: not out of the box afaict
02:47:05 * dcoutts thought there was --enable-cairo
02:47:17 <dcoutts> oh, perhaps it was added after 0.9.9.5
02:47:23 <dcoutts> maybe I should roll another tarball
02:47:31 <gour> dcoutts:otoh, yi does not build with cairo 1.0.0-r2 'cause it misses ps & pdf back-ends
02:47:32 <juhp> ok, maybe I　should try a cvs snapshot then :)
02:47:44 <dcoutts> juhp, you can now use darcs :-)
02:47:56 <juhp> ah yeah
02:48:01 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
02:48:06 <gour> dcoutts: is your tailor in function?
02:48:16 <juhp> dcoutts: by cvs is still the master repo?
02:48:20 <dcoutts> gour, soory, not yet :-) I've been hacking on hIDE
02:48:30 <juhp> s/by/btw/
02:48:39 <dcoutts> juhp, yes cvs is the master, the darcs is a read only mirror
02:48:45 <juhp> ok
02:49:10 <dcoutts> but we're quite happy to recieve "darcs send" patches
02:49:49 <gour> dcoutts: ok, what aboutCould not find module `Hide.Hooks': error?
02:50:00 <dcoutts> gour, it looks like you've not been building things in the right order
02:50:27 <dcoutts> gour, the ideShell plugin depends on the baseApp plugin
02:50:41 <gour> dcoutts: well, ghc-pkg gives: hide-base-0.1.0
02:50:41 <dcoutts> you're using the build.sh script?
02:50:50 <dcoutts> oh, hmm
02:50:59 <gour> dcoutts: no, 'cause yesterday i have a strange ghc panic error!
02:51:59 <gour> dcoutts: so want to see what is going on - the script was not very helpful
02:52:06 <dcoutts> well is hide-base the latest verion? have you rebuilt it?
02:52:27 <dcoutts> the script just uses cabal to beuild each plugin and the app core in the right order
02:52:28 <gour> dcoutts: yes, pulled the whole repo from the scratch..
02:52:35 <dcoutts> it registers them locally
02:52:57 <gour> dcoutts: i'm register globally
02:53:12 <gour> dcoutts: it should not be a problem?
02:53:12 <dcoutts> that should still work
02:53:22 <gour> that's i assume too
02:53:54 <shapr> SickJacken: A zipper is like a rubik's cube. It's a structure you can rotate around to expose different nodes.
02:54:37 <dcoutts> so you need to configure build and install the plugins is this order (which is all the build.sh script does): baseApp, ideShell, yiBase, app core (ie ./)
02:55:35 <gour> now i've tried to pull hIDE in another dir
02:55:42 <gour> and executed build.sh
02:55:55 <boegel> shapr: any luck with TMR yet ? I'm eager, because I want to show my thesis promoter the article :)
02:56:00 <gour> which results in: ...Building hide-yi-0.1.0...
02:56:12 <gour> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
02:56:13 <gour>         unknown exception
02:56:41 <SickJacken> still dont get the context type
02:56:44 <dcoutts> gour, just leave off the yi plugin for now
02:56:51 <SickJacken> with respect to the example at the hawiki
02:57:24 <dcoutts> gour, remove "plugins/yiBase" from the "PACKAGES" list in build.sh and then try again
02:58:06 <dcoutts> gour, and when it finnishes run: bin/hIDE hide-base-0.1.0 hide-shell-0.1.0
02:58:17 <dcoutts> ie leave off "hide-yi-0.1.0"
02:58:39 <gour> dcoutts: then it works, but (again) i have that 'libz' problem
02:58:56 <gour> dcoutts: ok, i'm going to put something in my mouth and then i'll resume :-)
02:59:43 <SickJacken> omg why doesnt itunes automatically create a playlist after ripping a cd
03:01:41 <earthy> why should it?
03:01:50 <earthy> you can *trivially* make one
03:01:55 <earthy> but you don't even need to
03:02:09 <earthy> as you can just select the CD in the 'browse' top
03:02:52 <dcoutts> gour, I fixed the libz problem in gtk2hs, you could pull from the repo and make && make install
03:03:32 <SickJacken> earthy, dont you think its annoying that for every cd i let itunes rip...i need to add a playlist and drag those tracks *manually*
03:03:38 <SickJacken> just adding it to the library sucks
03:03:46 <earthy> what do you need, adding manually?
03:03:50 <earthy> s/nead/mean
03:04:03 * earthy reconfigures his brain to use natural language again
03:04:15 <earthy> right, what you can do is simply select the CD in the browse window
03:04:30 <earthy> then you select all the tracks displayed
03:04:37 <earthy> then 'new playlist from selection'
03:04:38 <earthy> hey presto
03:05:00 <earthy> but, why do you even need a playlist per CD?
03:05:13 <earthy> as you can simply select the CD in correct play order from the browse window...
03:05:31 <SickJacken> browse window....
03:05:39 <earthy> browse view
03:06:02 <earthy> go to the library and look in the top right of the window. you see the browse eye
03:06:31 <SickJacken> ow i see
03:06:41 <SickJacken> well i need those playlists because i have an ipod
03:06:49 <SickJacken> which is not able to hold my complete library
03:07:33 <earthy> ah
03:07:34 <earthy> okay
03:07:36 <earthy> that explains :)
03:31:40 <dblhelix> earthy: hungry?
03:32:50 <earthy> somewhat
03:32:58 <wilx> @hoogle Stream
03:33:01 <dblhelix> how about lunch then?
03:33:06 <earthy> good idea! :)
03:33:07 <wilx> lambdabot?
03:33:11 <dblhelix> let's go :)
03:33:20 <wilx> @index Stream
03:33:21 <lambdabot> Network.Socket
03:35:26 <ski> @hoogle food
03:41:50 <dcoutts> hia JaffaCake, not leaving for ICFP yet?
03:42:06 <JaffaCake> I'm going on sunday
03:42:30 <JaffaCake> are you going?
03:42:33 <dcoutts> you don't have as far to travel as dons :-)
03:42:37 <dcoutts> sadly not :-(
03:42:49 <JaffaCake> oh well :(
03:42:53 <dcoutts> we didn't win the programming contest this year :-)
03:42:57 <JaffaCake> dons is going then?
03:43:09 <dcoutts> yeah dons has already leaft I think
03:58:54 <Heffalump> yes, he went several hours ago
03:59:02 * Heffalump is going this evening
04:10:57 <shapr> boegel: No work on TMR yet, but tomorrow I'll convert CosmicRay's article and write up my HUnit/QuickCheck testing article.
04:13:13 <boegel> shapr: cool, be sure to let me know when IssueFive gets published, mmkay ? I won't be able to come online before Wednesday probably
04:17:04 <gour> dcoutts: i fixed manually libz problem, in which repo did you fix it?
04:18:09 <gour> dcoutts: by leaving out yiBase, hIDE builds, but with it, it produces ghc-6.4.1: ghc-6.4.1: panic!
04:18:29 <gour> dcoutts: is it maybe something interesting for JaffaCake?
04:20:02 <dcoutts> gour, so does it run ok then?
04:20:34 <dcoutts> gour, oh you're quite right, I;ve not comitted the libz fix yet
04:20:43 * dcoutts goes off to do that
04:24:07 <gour> dcoutts, well not much to do having that 'dummy page' displayed
04:24:24 <dcoutts> gour, browse through the files
04:24:31 <gour> dcoutts, can you build yiBase?
04:24:36 <dcoutts> yes
04:25:10 <dcoutts> does the file browser work for you then? yuo might have to resize the window a bit
04:25:12 <gour> dcoutts: which files, Open does not work, nor New?
04:25:27 <dcoutts> no, none of the toolbar buttons do anything yet
04:25:47 <gour> ahh, ok, toolbar
04:26:07 <dcoutts> the tree views on the left hand side, there is 'Open' with nothing in it, and 'files' with all the files in the current directroy displayed
04:26:28 <dcoutts> if you select a file it is displayed in the editor
04:26:46 <dcoutts> if you select a .hs file it should be syntax highlited
04:26:47 <gour> i'm still not familiar with those 'dynamic ides' :-)
04:27:30 <dcoutts> np, the default size of the window is not very helpful yet :-)
04:27:48 <gour> by mistake, i selected one of the wrong files and hIDE segfaults :-)
04:28:00 <dcoutts> oh?
04:28:12 <dcoutts> what kind of file did that?
04:28:28 <gour> let me try again
04:28:32 <dcoutts> on menu item does work: View->New window
04:28:54 <dcoutts> so you can have multiple windows open and edit the same file
04:29:09 <dcoutts> and it shares edit buffers
04:29:40 <gour> it was object file
04:30:08 <gour> New Window does work
04:30:36 <gour> here is the log for segfault:
04:30:40 <gour> (hIDE:4477): GtkSourceView-CRITICAL **: gtk_source_undo_manager_insert_text_handler: assertion `strlen (text) >= (guint)length' failed
04:30:40 <gour> Segmentation fault
04:30:51 <dcoutts> oh ok, I'll take a look at that, it's probably a utf8 encoding issue
04:31:14 <gour> any idea why yibase produces that exception?
04:31:23 <gour> should i inform JaffaCake?
04:31:36 <JaffaCake> imform me what? :)
04:31:47 <dcoutts> yes, I get the warning message when opening a .o file but not the segfault
04:31:52 <shapr> boegel: Ok
04:32:42 <dcoutts> JaffaCake, gour is getting a panic message when building the yiBase plugin on amd64
04:32:55 <JaffaCake> oh?
04:33:00 <gour> when i try to build hIDE with yiBase, i get:
04:33:04 <gour> Using package config file: /usr/lib64/ghc-6.4.1/package.conf
04:33:04 <gour> Using package config file: /home/gour/.ghc/x86_64-linux-6.4.1/package.conf
04:33:04 <gour> *** Deleting temp files
04:33:05 <gour> Deleting:
04:33:05 <gour> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
04:33:05 <gour>         unknown exception
04:33:20 <JaffaCake> how strange
04:33:27 <gour> yes it is..
04:33:46 <JaffaCake> could you put it in a message to ghc-bugs please?
04:33:49 <dcoutts> so that's after compling the modules? it's "Deleting:"
04:34:06 <gour> ok, will do
04:34:32 <dcoutts> gour, and mention the darcs repos where the code is, and the data/time you did it (since the repos will change)
04:34:59 <dcoutts> I presume it's possible to do a darcs get from a specific date/time
04:35:59 <gour> well, i can include tail of 'darcs changes' ?
04:36:14 <dcoutts> that might help, I dunno
04:36:39 <dcoutts> gour, and remeber to mention the yi repo too, since yiBase is using the yi package
04:46:24 <gour> JaffaCake: I submitted bug report (#1300803) -http://sourceforge.net/tracker/index.php?func=detail&aid=1300803&group_id=8032&atid=108032
04:46:34 <JaffaCake> gour: cheers
04:46:57 <gour> JaffaCake: let me know if i can do some more tests..
05:01:09 <basti_> hey prionic
05:01:20 * boegel leaves for some presentations
05:01:21 <prionic> moin
05:03:38 <basti_> argh
05:03:39 <basti_> brb
05:04:01 <beelsebob_> Jaffa: did you get my public key?
05:04:43 <gour> dcoutts: which cairo you use?
05:04:58 <dcoutts> cairo 1.0
05:06:04 <gour> hmm, i have 1.0.0-r2, but attempt to build latest yi complains due to missing headers for pdf & ps..
05:06:51 <dcoutts> gour, ah yes that was my fault, you can use the latest darcs version of gtk2hs in which it's been fixed
05:07:09 * dcoutts should probably release a new tarball
05:07:14 <gour> ok, let me try
05:15:32 <shapr> dcoutts: I'm trying to fix the gtk2hs demos, where's renderWithDrawable come from?
05:16:20 <dcoutts> shapr, you only get that if you've built with cairo support
05:16:48 <shapr> I've got it.
05:18:56 <luqui> is there a function :: Monad m => (a -> m b) -> m (a -> b)
05:19:52 <shapr> dcoutts: I get linking errors for Control.Monad.Reader from make. I can fix it by adding mtl to PACKAGES in the Makefile, and definition "HCNEEDSPACKAGE = yes". Is that the correct fix? If so, I can fix all the Makefiles and send you a darcs patch.
05:20:21 <dcoutts> hmm I'll go take a quick look
05:20:27 <gaal> hello! i'm looking for an idom similar to a guard, but for cases where conditions are monadic. http://sial.org/pbot/13265
05:20:33 <dcoutts> we should probably remove the dependence on mtl
05:20:52 <shapr> Monad.Reader is in mtl
05:21:06 <ski> luqui : i think not
05:21:21 <luqui> darn
05:21:25 <luqui> ski, thanks for that link, btw
05:21:32 <ski> ?
05:21:33 <gaal> oh, hi luqui :)
05:21:54 <ski> (e.g. consider m = Maybe ..)
05:22:26 <dcoutts> shapr, I don't think I understand, the cairo.package.conf does mention the mtl dep, what are you building
05:22:35 <luqui> ski, good point
05:23:11 <shapr> Ok, I'm confused too.
05:23:56 <ski> (of course, in the Maybe case, you could do function = const Nothing, but i somehow don't think you want this)
05:24:04 <dcoutts> shapr, which thing were you building
05:24:19 <luqui> true :-)
05:24:37 <shapr> dcoutts: So far, buttonbox, calc, filechooser, fastdraw, and gconf.
05:24:54 <luqui> then just answer gaal's question :-)
05:24:57 <dcoutts> shapr, ok tell me which one breaks
05:25:00 <ski> (luqui : btw, what were you trying to do, that made you think about something like this ?)
05:25:11 <luqui> gaal's question :-)
05:25:39 <gour> dcoutts: i've pulled gtk2hs from darcs repo and now yi builds
05:26:11 <dcoutts> gour, really? so no ghc panic any more when building the yiBase plugin
05:26:16 <gour> dcoutts: i'm concerned whether to install it and try again hIDE with yiBase
05:26:39 <gour> dcoutts: 'cause then ghc panic may disappear. what do you think?
05:27:05 <gour> dcoutts: yi builds, did not attempt yiBase
05:27:48 <gaal> typically a computation terminates on the first failure; i want to express something that terminates on the first success
05:27:56 <gour> dcoutts: but if i install latest yi, then i (maybe) won't be able to reproduce ghc panic ??
05:29:41 <gour> dcoutts: advice?
05:29:47 <dcoutts> hmm, not sure
05:30:11 <dcoutts> ah I've an idea...
05:30:11 <shapr> dcoutts: buttonbox, calc, concurrent, fastdraw, filechooser, gconf, glade, graphic, hello, mozembed, profileviewer, sourceview, treeList, and unicode all give errors because my libHSgtk.o has cairo, and therefore needs -package mtl.
05:30:12 <ski> gaal : for io code ?
05:30:21 <gaal> ski, yes.
05:30:51 <gour> dcoutts: 'cause i'm not sure what was the state of yi-0.2 which is presently installed..
05:30:58 <dcoutts> shapr, hmm, that's odd since gtk depends on cairo which depends on mtl
05:31:05 <shapr> I get "/usr/local/lib/gtk2hs/libHSgtk.a(Cairo.o): In function `__stginit_GraphicsziUIziGtkziCairo_': \n ghc21956.hc:(.text+0x36): undefined reference to `__stginit_ControlziMonadziReader_'"
05:31:36 <shapr> dcoutts: Mine only depends on glib
05:31:46 <dcoutts> shapr, really? hmm
05:32:06 <ski> gaal : for plain Maybe code, mplus could possibly work, .. but for io, hm
05:32:24 <dcoutts> gour, try installing yi locally, ie in your home directory
05:32:55 <dcoutts> gour, ./Setup.lhs configure --prefix=$HOME; ./Setup.lhs build; ./Setup.lhs install --user
05:32:57 <gour> dcoutts: and then hide global yi?
05:33:16 <dcoutts> gour, the local one will automatically be selected rather than the global one
05:33:27 <gour> dcoutts: great..
05:33:51 <dcoutts> shapr, in gtk/gtk.package.conf.in I've got: depends: glib-@PACKAGE_VERSION@ @GTK_CAIRO_DEPEND@
05:34:13 <dcoutts> shapr, so that means that for some reason the @GTK_CAIRO_DEPEND@ value is wrong
05:34:40 <dcoutts> shapr, what version of gtk & cairo did you build against?
05:35:10 <gaal> ski: the example is in the nopaste above
05:35:59 <ski> gaal : of course one can make a chain of if-then-else .. also possibly one could make a function :: [(IO Bool,IO a)] -> IO a  hm
05:36:13 <shapr> dcoutts: I grabbed the darcs repo yesterday.
05:36:20 <shapr> oh, gtk and cairo...
05:38:44 <gour> dcoutts: now it builds, but it fails:
05:38:52 <gour> gour@gaura-nitai ~/repos/hIDE $ bin/hIDE hide-base-0.1.0 hide-shell-0.1.0 hide-yi-0.1.0
05:38:53 <gour> Loading plugins: ["hide-shell-0.1.0","hide-yi-0.1.0"]
05:38:53 <gour> hIDE: /home/gour/repos/hIDE/lib/hide-yi-0.1.0/ghc-6.4.1/HShide-yi-0.1.0.o: unknown symbol `YiziUI_setFont_closure'
05:38:53 <gour> hIDE: user error (resolvedObjs failed.)
05:38:56 <shapr> dcoutts: libcairo2-dev version 1.0.0-3 libgtk2-dev version 2.6.10-1 both from debian/unstable
05:39:34 <dcoutts> shapr, so that's a slighly odd situation since you've got cairo but not the version of gtk that use cairo
05:39:49 <dcoutts> shapr, so the cairo package will be built, but the gtk/cairo integration bits will not
05:40:02 <dcoutts> and so correctly, the gtk package will not depend on cairo
05:40:20 <dcoutts> and you will not be able to build any of the cairo demos that use gtk
05:40:29 <dcoutts> and least that what should happen :-)
05:40:29 <shapr> Which version of gtk uses cairo?
05:40:33 <dcoutts> 2.8.x
05:41:06 <shapr> Aha, I have those as a choice
05:41:09 <gaal> so, is luqui's proposal http://sial.org/pbot/13266 lazy? does it evaluate both fileExists immediately?
05:41:39 <dcoutts> shapr, so which demos were not building then? and was that when doing "make installcheck" or building manually
05:41:53 <shapr> building manually
05:42:07 <dcoutts> because it should be possible to support that situation sanely
05:42:50 <shapr> I want to play with cairo, so I'll just install 2.8.3
05:43:40 <ski> gaal,luqui : wait, that is not correct syntax .. me fix
05:45:00 <gaal> ski: 15:26 < luqui> s/case/return $ case/             -- sorry, that happened on #perl6
05:45:32 <gaal> ski: but i'm wondering whether that's lazy. not that in my particular case i really care, but i'm still wondering :-)
05:45:36 <dcoutts> shapr, ok I think I've fixed it, there was an import of Control.Monad.Reader that was not gaurded by #ifdef ENABLE_CAIRO
05:47:12 <ski> gaal : you saying you meant return in front of the case ?
05:48:04 <shapr> chs_: Hiya, learning Haskell?
05:48:14 <gaal> ski: yes, or rather that luqui meant that. sorry about the perl syntax creeping in :)
05:49:16 <luqui> http://sial.org/pbot/13267
05:54:30 <C-Keen> hi
05:55:15 <musasabi> hello
05:55:35 <ski> luqui,gaal : http://sial.org/pbot/13268
05:56:22 <shapr> C-Keen: Hiya Commander Keen, learning Haskell?
05:56:35 <C-Keen> shapr: yep :)
05:56:51 <shapr> Do you have any specific questions, or would you like directions to the tutorials and intro docs?
05:57:05 <gaal> ski: thanks!
05:57:45 <ski> gaal,luqui : reading 13267, now ..
05:58:15 <C-Keen> shapr: I am reading a book atm..I will just lurk a bit for now thank you :)
05:58:29 <shapr> Ok, if you have any questions, feel free to ask.
05:58:38 <C-Keen> thank you very much :)
06:00:58 <gaal> ski: thanks!
06:01:01 <chs_> shapr: Hi, just listening in.  Actually, I have a (stupid?) irc question: Last time I was logged in irc.freenode.net and my nick was changed from chs to chs_ after several hours of being logged on?  Why?  Is there some special meaning to a trailing underscore in the nick?  (I know this is OT, so feel free to ignore.)
06:01:09 <luqui> is unsafeInterleaveIO basically an :: IO a -> a
06:01:18 <luqui> so you shouldn't really be able to do it?
06:01:39 <ski> gaal,luqui : http://sial.org/pbot/13269
06:01:52 <ski> luqui : no
06:02:00 <ski> unsafeInterleaveIO :: IO a -> IO a
06:02:58 <luqui> oh, um...
06:03:09 <ski> it delays the execution of the action until the value is forced .. so it is safer than unsafePerformIO  (e.g. you cannot implement unsafeCoerce with it)
06:03:11 <shapr> chs_: Most likely your connection was broken on the client side before the server timed out your connection. Then your client reconnected, discovered that the chs nickname was already taken, and used a backup nickname.
06:03:23 <luqui> ski, gotcha
06:03:27 <luqui> that's kinda cool
06:03:42 <luqui> it's nice that you can, in fact, align those
06:03:53 <shapr> chs_: Freenode services like Nickserv ( try /msg nickserv help ) are useful for killing leftover connections. Nickserv has the GHOST command for example.
06:03:54 <chs_> shapr: Oh, that makes sense.  Thanks.
06:04:06 <shapr> ski: Is an an OI comonad related to uniqueness types?
06:04:06 <ski> luqui : i believe one can implement things like getContents and readFile with the help of it, e.g.
06:05:26 <ski> luqui : you can align it because it just an expression (unlike do which uses indent syntax to make { ; ; } stuff explicit)
06:05:56 <luqui> aa, so if it were trying to be the last statement in a do it wouldn't work?
06:06:00 <ski> shapr : yes, i believe to have a safe OI comonad, you need uniqueness/linear types
06:06:07 <shapr> Ok, just curious.
06:07:49 <ski> shapr : this is because the world state is linear, it's sort of a happy coicidence that this actually isn't required with the IO monad, as long as it's an ADT, it manages to hide the linearity .. doesn't matter if the action is not linear, it still can handle linear state .. not so with the OI comond
06:10:14 <ulfdoz> Erm, yes?!
06:13:17 * luqui reads about comonads and is intrigued
06:18:43 <ski> luqui : yay! :)
06:30:50 <Lor> Is there an English name for what's called "aasinsilta" in Finnish: moving from one subject to another by using some very artificial association between them?
06:32:07 <ski> Lor : hm, maybe you know the swedish word ?
06:34:27 <Lor> No, sorry. The Finnish word is literally "donkey's bridge".
06:34:45 <mflux> conan o'brien sometimes says that expression, but I can't recall it ;)
06:35:00 <luqui> Lor, yak shaving
06:35:03 <shapr> Sometimes people say "mixing metaphors" for the same idea.
06:35:37 <luqui> no, that's not quite it
06:35:52 <luqui> yak shaving is the working analogue of the discourse version you are referring to
06:36:29 <luqui> oh yeah, I'm working on my homework, because it's spanish homework, and spanish is a language, and haskell is a lanugage
06:36:32 <ski> Lor : iiuyc, it's 'långsökt' in swedish .. which my lexicon here says is 'far-fetched' in english
06:37:11 <earthy> nice word.
06:37:12 <Lor> Well yeah, "far-fetched connection" would be a good description.
06:37:16 <earthy> vergezocht
06:37:28 <Lor> I was wondering whether there was some simpler idiom.
06:37:38 <ski> can't think of any ..
06:38:11 <earthy> in dutch it'd be 'van de hak op de tak springen'
06:40:06 <Oejet> Hello, when would I show up here on the 30th of September after the Haskell Workshop?
06:40:44 <shapr> Oejet: Are you going to ICFP?
06:41:19 <gaal> luqui: yak shaving is more like, i need to return this library book, but i'm out of cash for the bus, so i have to go to the atm; but my credit card's expired so i have to go to the bank to pick up the new one; but my teller is busy moving to a new cubicle, so i find myself helping him carry stuff.
06:42:59 <luqui> ahh, you need at least 6 levels :-)
06:43:21 <gaal> i think forgetting what you were originally trying to achieve is part of the deal, yes
06:45:15 <Oejet> shapr: I'm afraid not, it's a money/time problem, ya know.
06:46:12 <Igloo> "Meet" in the physical sense, in .ee
06:48:47 <ski> earthy : tak is roof, i guess ?   what is hak ?
06:50:53 <Oejet> I've printed the SMP-GHC paper, but haven't read it yet.  Has anyone tried it on a multiprocessor?  shapr?
07:01:17 <Blownose> how do i declare something like a variable ex if i want  this    MyNumbers = [1, 2, 3, 4, 5]   and i want to be able to use MyNumbers in functions ?
07:01:49 <luqui> Blownose, uh, be more specific
07:02:11 <shapr> Oejet: JaffaCake has, he wrote it :-)
07:02:14 <Blownose> w8 have to change cpuy
07:03:05 * JaffaCake waves to Oejet
07:03:31 <shapr> dcoutts: Is there a simple solution for this? -> "gtk/Graphics/UI/Gtk/Multiline/TextIter.chs:938: (column 11) [ERROR] \n  >>> Unknown identifier! \n  Cannot find a definition for `gtk_text_iter_forward_visible_line' in the header file."
07:03:54 <Blownose> i mean if i later want to use MyNumbers in a function and MyNumbers represent my list
07:04:14 <dcoutts> shapr, you're building with gtk-2.6 still?
07:04:27 <luqui> myNumbers = [1,2,3,4,5]   -- capitalization is important
07:04:34 <shapr> dcoutts: No, 2.8 now.
07:04:39 * Oejet waves back at JaffaCake.  Oejet is reading JaffaCake's article this evening.  Oejet like it.  Mmmmm.
07:04:52 <dcoutts> shapr, oh I know what it is, I just comitted a fix to cvs for this. The */*.precomp files are not deleted on clean, only distclean.
07:05:04 <shapr> ah, so I should distclean first?
07:05:25 <dcoutts> shapr, I've fixed it in cvs now so it does remove them on clean because people get tripped up by it :-)
07:05:42 <dcoutts> shapr, yeah, make distclean && autoreconf && ./configure && make
07:05:51 <dcoutts> shapr, sorry about that
07:05:56 <shapr> JaffaCake: Oh, Lunar^ said that hOp needed priority in the scheduler. That's what was missing.
07:06:27 <shapr> dcoutts: Your instant tech support means I'm not worried about any bugs :-)
07:06:38 <dcoutts> shapr, what was heppening there is the it's trying to use gtk-6.8 functions but the precomp headers are still from 2.6 :-)
07:06:45 <dcoutts> shapr, heh :-)
07:07:36 <dcoutts> shapr, our "out of the box" support for the cvs version has not histocialy been that good, though the tarballs are fine, I'm trying to improve it however
07:07:52 <dcoutts> so your reporting of these buglets is helpful
07:07:55 <luqui> Blownose: success?
07:08:00 <shapr> yay!
07:08:47 <Blownose> luqui: but can i declare MyList as a type ?
07:09:13 <luqui> oh, you want MyList to be the type of things that are either one, two, three, four, or five?
07:09:45 <Blownose> hmm no.. MyList shall always have the same values.. maybe i dont need a type then ?
07:10:00 <Blownose> i want it like a const i java :)
07:10:19 <luqui> you never change anything in haskell :-)
07:10:19 <Oejet> Blownose: Just write it like that then at the top level.
07:10:47 <luqui> myList :: [Int]   -- the type of myList, if you feel like being explicit
07:11:49 <z0d> do you know any good tutorial on the Hindley-Milner type inference?
07:12:05 <luqui> z0d, TaPL
07:13:04 <z0d> luqui: what about on-line accessible ones? (I'm going to order TaPL anyway, thanks"
07:13:23 <Philippa_> there's a paper by cardelli
07:13:28 <Blownose> hmm but lets say like this.. i have myList and yourList and i want to declare a data called someList is this possible then data SomeList = myList | yourList deriving(Show) ??
07:13:29 <luqui> z0d, don't know of any, not to say that none exist :-)
07:13:57 <Philippa_> research.microsoft.com/Users/luca/Papers/BasicTypechecking.pdf
07:14:01 <ski> Blownose : you confuse types with values of types
07:14:05 <Philippa_> the code's in modula-2, but you'll live
07:14:19 <luqui> Blownose, I am completely perpexed by your question
07:14:36 <luqui> there's probably a way to do what you want, but we have to agree on what that is first
07:14:37 <z0d> thanks
07:15:07 <ski> Blownose :  data SomeList = MyList | YourList deriving Show     is correct haskell, and declares a type SomeList, and two constant constructors (like enums) of that type
07:15:37 <Blownose> yes and i want to set the enums how do i do that ?
07:15:46 <luqui> "set the enums" ?
07:15:52 <ski> Blownose : myList = [1,2,3,4,5]    is also correct, and declares a variable what is bound to a list value
07:16:09 <ski> s/what/that/
07:16:35 <luqui> I think he wants C-like enums where you can set the particular value of the symbols you are creating, and also refer to the collection of symbols as a whole
07:16:46 <Blownose> yes so if i have like this       blabla :: SomeList -> blabla        and i get   myList as SomeList   i want myList do be [0,1,2,3]
07:17:17 <Blownose> hmm yes luqui
07:17:20 <gour> dcoutts: can youe help me clarify one sentence?
07:17:38 <luqui> Blownose, you can't do that exactly in Haskell
07:17:42 <ski> Blownose : you can explicitely associate ints with the "enum"-constructors, with the help of type-class Enum
07:18:07 <dcoutts> gour, sure
07:18:09 <luqui> the way I'd do that would be to say: data ListIndex = MyList | YourList
07:18:24 <luqui> and then define a function :: ListIndex -> [Int] (or whatever)
07:18:48 <gour> dcoutts: thanks, Simon T writes: we are not forced to use the derived definitions; we can give our own...
07:18:55 <luqui> then you use the index to refer to the value, but you have to give it to a function to tell you what that value it
07:18:57 <luqui> *is
07:19:21 <luqui> did that make sense?
07:19:30 <gour> dcoutts: why saying "we are not forced..", i.e if i use e.g. deriving (Eq, Ord...) than i'm supposed to use derived ones
07:19:32 <luqui> (my wording is a little convoluted)
07:19:32 <ski> data Foo = A | B | C;     instance Enum Foo where fromEnum A = 8: fromEnum B = 3; fromEnum C = 4; toEnum 8 = A; toEnum 3 = B; toEnum 4 = C
07:19:54 <gour> dcoutts: if i don't use deriving (..) then i have to supply my own..
07:20:07 <pejo> Philippa, is there even any point in arguing with the guy on ltu?
07:20:08 <Blownose> hmm ok..
07:20:16 <luqui> ohhhh, if they're just ints then that works too
07:20:26 <luqui> I thought that the enum values were lists...
07:20:30 <luqui> but now it all makes sense
07:20:47 <gour> dcoutts: and i cannot use deriving (Eq,Ord,..) and re-define my ownm since i ghci/hugs complain about overlapping instances?
07:20:52 <Blownose> no they are lists..
07:20:55 <dcoutts> gour, that's right
07:20:59 <luqui> oh, heh
07:21:03 <Blownose> :)
07:21:11 <ski> Blownose : i don't understand what you want to do with those lists, though
07:21:18 <dcoutts> gour, you can either use deriving (Eq, Ord, etc) or give your own definitions
07:21:27 <luqui> so just to be clear, you want a function to accept one of, like, six predefined lists and no others?
07:21:46 <Blownose> exactly
07:22:00 <gour> dcoutts: ok, this is clear 100%, thanks
07:22:05 <dcoutts> gour, I think he means for "not forced" that using the "deriving" thing is not the only way of getting the ==, >= operators etc definied for your type
07:22:22 <luqui> okay, yeah, I think the way I tried to say above is the best
07:22:26 <gour> dcoutts: that makes sense, thanks
07:22:38 <dcoutts> you're welcome :-)
07:22:40 <luqui> make a data defining six names, then make a mapping between each of those names and a list
07:22:46 <Blownose> but im not allowed to write something like this  getList :: MyLists -> [Int]          getList list      | list == MyList = [0,1,2,3]     and so on
07:22:48 <gour> dcoutts: btw, have you noticed my error when running hIDE with yiBase?
07:22:59 <ski> Blownose : what should your function do if passed another list ?
07:23:00 <dcoutts> gour, the segfault?
07:23:12 <gour> no, the other one..
07:23:21 <dcoutts> gour, oh which was that?
07:23:46 <gour> dcoutts: hIDE: /home/gour/repos/hIDE/lib/hide-yi-0.1.0/ghc-6.4.1/HShide-yi-0.1.0.o: unknown symbol `YiziUI_setFont_closure'
07:24:00 <gour> dcoutts: scroll back
07:24:09 <luqui> Blownose, under my scheme it would be:  getList list | list == listData MyList = [0,1,2,3]
07:24:15 <luqui> if I understand you correctly
07:24:28 <luqui> so you just pass the symbols to listData and it gives you back the list constants
07:24:29 <dcoutts> gour, that's because it's using an old version of yi itself
07:24:47 <dcoutts> gour, what yi is registered?
07:24:52 <gour> dcoutts: hmm, i pulled latest patches from repo
07:24:53 <Blownose> ok..
07:25:21 <gour> dcoutts: yi-0.2 (local)
07:25:28 <luqui> and listData would look like:  listData MyList = [0,1,2,3];  listData YourList = [0,2,4,6,3]   -- or whatever
07:25:39 <dcoutts> gour, perhaps you do need to mask the old global yi install to make it use the local one, I thought you din't need to, but perhaps I'm wrong
07:25:48 <Blownose> ok..
07:25:50 <dcoutts> gour, oh I know!
07:25:56 <gour> yes,?
07:26:01 <dcoutts> gour, it does that when you run hIDE right?
07:26:10 <gour> dcoutts: true
07:26:18 <dcoutts> not when compiling yiBase, yes?
07:26:34 <gour> dcouts: yup
07:26:50 <dcoutts> that's the fault of hIDE's module loader looking for packages in the wrong order
07:26:58 <dcoutts> it looks in the global one first
07:27:05 <dcoutts> bug Lemmih about that
07:27:09 <dcoutts> it's a bug
07:27:21 <dcoutts> or you could unregister the global one
07:27:52 <dcoutts> sorry gour I've got to dash off to a talk
07:28:17 <gour> dcoutts: ok
07:33:00 <orbitz> in a lazy language does that mean i cannot be sure how long it will take for an expression to compute?
07:33:13 <orbitz> would this make writing real-time software in a lazy language unpossimatable?
07:34:55 <vegai> not really "how long" but "when"
07:35:22 <shapr> You can write real-time software in a lazy language, but you need to be sure of the laziness properties of all the code.
07:35:24 <int-e> I wouldn't say impossible but it's certainly a challenge and I guess you'll either write most of your program in monadic style or rely on implementation details (w.r.t. the evaluation order, say) (and it requires an implementation with incremental GC).
07:36:20 <int-e> vegai: the 'when' is very important in a RT context. You have to do the computation when you still have time for it to meet the deadline, not when you need the result.
07:36:49 <Philippa_> yeah, your output action's going to force it though
07:37:10 <vegai> int-e: sure
07:38:56 <esap> There are some design principles in RT modelling that do not work well with functional programming.
07:39:13 <vegai> or perhaps they just need a new abstraction
07:39:34 <vegai> IO didn't seem to work well before the Monad solution came along
07:40:55 <Philippa_> I suspect the right monad (or possibly arrow) will do
07:41:12 <esap> The trouble is, some RT programming methods are very close to what functional programming does. But once you go into the differences, it's completely different. It's actually somewhat hard to see any difference between some styles of FP and RT design until you hit the differences.
07:42:11 <int-e> Maybe arrows (as far as I understand them which is not very far) could help expressing 'I need the result of this computation in 10 ms'.
07:42:17 <orbitz> hi int-e
07:42:26 <esap> One thing that's different is how to handle "functions" that take more than one input.
07:42:39 <Philippa_> int-e: that's a sufficiently-capable-type-system thing from where I'm sitting
07:42:53 <Philippa_> (and one of the conclusions is that you ain't gonna be using return so much)
07:43:16 <esap> Also type system is often non-existent in the RT design [because type systems handling concurrency are not that well defined yet]
07:43:45 <Philippa_> what's the usual mechanism for reasoning about it?
07:44:04 <esap> functional specification, I suppose.
07:44:09 <edwinb> have you seen Hume?
07:44:12 <edwinb> [not that it's lazy]
07:44:24 * esap hasn't seen Hume.
07:44:28 <Philippa_> what's different about the multi-in functions, btw?
07:44:43 <edwinb> http://www.hume-lang.org/
07:44:49 <edwinb> although it's not all that up to date at the minute
07:44:53 <esap> philippa: "when" the input is consumed.
07:45:21 <edwinb> one of the ideas is to separate computation from control
07:46:33 <Philippa_> esap: on-call vs on-use-within-function?
07:46:49 <Philippa_> how does it differ from the usual evaluation order stuff?
07:47:42 <esap> philippa: no, I mean like storing data to database, then once the other argument comes in, then compute.
07:48:16 <Philippa_> not sure I'm following that
07:49:05 <shapr> A sufficiently powerful type system could guarantee a certain time for a system call. That would be neat.
07:49:51 <esap> philippa: It's pretty difficult stuff. Think of two use cases that both _could_ compute the same thing.
07:50:01 <Philippa_> actually wait, got it. Bit inconvenient in a monad
07:50:04 <shapr> It sounds like partial evaluation the way you describe it.
07:51:05 <boegel> shapr: still problems with scannedinaivan.org in #raytracing
07:51:37 <edwinb> I'd have thought guaranteeing a certain time would be difficult; on the other hand, you could maybe guarantee a certain number of computation steps.
07:52:16 <shapr> boegel: and .com too?
07:53:15 <shapr> edwinb: Yeah, true.
07:58:12 <ski> esap : _could_ compute the same thing ?
07:58:37 <esap> ski: depending on whether input is available or not.
07:59:07 <ski> hm
07:59:09 <shapr> I don't get it.
08:00:38 <esap> hmm.. For example, see SICP discussion of "merge" combinator.
08:01:51 <ski> merging two streams, nondeterministically ?
08:02:22 <esap> ski: Yes, and its comparison to alternative approaches.
08:02:24 <basti_> imback
08:02:38 <esap> SICP didn't actually have a good solution for that.
08:03:32 <boegel> shapr: dunno
08:03:50 * ski doesn't remember that from sicp
08:04:28 <esap> pg 290..292
08:05:53 <shapr> esap: merge streams as input is available? So just pick up the ready items?
08:06:16 <esap> shapr: not that simple
08:07:47 <esap> shapr: the question is about whether to introduce time at all, or whether handle functions whose output is not fully determined by their inputs.
08:08:02 <esap> shapr: relations vs. functions
08:08:15 <ski> esap : http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_idx_3896 ?
08:08:51 <ski> relations, how ?
08:08:56 * boegel leaves for home
08:09:03 <ski> the nondeterminism ?
08:10:24 <ski> (hm, no prolly not that link ..)
08:10:37 <esap> Hmm.. the excercise numbers in that version of SICP are different than in my copy.
08:13:03 <esap> There is a section 3.4.6 "Streams versus Objects" in my copy of SICP which I can't find from the online copy.
08:14:25 * esap has fifteenth printing (1993)
08:16:16 * esap needs to read the new information in SICP :-)
08:16:21 <int-e> @hoogle (a->a->Ordering) -> [a] -> [a] -> [a]
08:16:25 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:16:25 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
08:16:57 * ski has no physical version
08:18:07 <esap> I think the section of SICP has been replaced with section 3.4 about concurrency
08:19:14 * shapr has third printing, 1997
08:19:34 <ski> esap : possibly the lectures talk about it ?
08:20:13 <esap> no the old version was basically that there is no good solution known. The new version seems to have a solution :-)
08:20:27 <shapr> Speaking of which, is there a torrent of mpeg flavors of the SICP lectures?
08:21:08 <ski> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ has mpegs
08:24:18 <Lemmih> gour: Still having problems with hIDE?
08:24:53 <esap> gotta go. see you later
08:25:09 <gour> Lemmih: yes, with my old yi-0.2 package installed, hIDE gives ghc panic error - see SF bugs
08:25:27 <shapr> esap: I'd like to hear more about this when you have time :-)
08:25:31 <ski> esap : cya
08:25:37 * ski too :)
08:26:02 <gour> Lemmih: otoh, i built latest yi from darcs repo, and i can build hiDE, but running it gives:
08:26:08 <gour> Lemmih: hIDE: /home/gour/repos/hIDE/lib/hide-yi-0.1.0/ghc-6.4.1/HShide-yi-0.1.0.o: unknown symbol `YiziUI_setFont_closure'
08:26:40 <shapr> Hiya malcolm
08:26:49 <malcolm> Hi shapr
08:26:56 <Lemmih> gour: Clean it and try again.
08:27:00 <gour> Lemmih: dcoutts says it's a bug "..that's the fault of hIDE's module loader looking for packages in the wrong order"
08:27:14 <malcolm> Is there anyone here currently in Tallinn, attending TFP, ICFP, etc?
08:27:15 <gour> Lemmih: i.e. 1st global, then local
08:27:43 <shapr> malcolm: I think they're all on their way.
08:28:36 <Lemmih> gour: Ah, I'll go fix that.
08:28:58 <gour> Lemmih: pls. tell me when you push patch
08:31:03 <malcolm> Ping Igloo?
08:31:59 <Igloo> Hi
08:32:09 <Igloo> I'm not there yet; leaving on Sunday
08:32:19 <Igloo> Why do you ask?
08:33:35 <malcolm> Igloo: you said earlier today something like "Igloo ponders what to do with nhc98 and hat and notes popcon like them about as much as ghc5"
08:33:50 <Igloo> Oh, I've just forwarded you a mail about that
08:33:54 <malcolm> Just wondering what you meant,
08:33:59 <malcolm> Oh, OK.
08:34:12 <Igloo> Bad news, I'm afraid  :-(
08:37:10 <vegai> hmm, I mentioned Haskell at work
08:38:01 <vegai> one answered that it's dead and obsolete.... oh dear.
08:38:09 * earthy grins
08:38:27 <vegai> funnily, the same guy said he likes perl
08:38:35 <int-e> oh cool, just like Fortran? *ducks*
08:38:37 <vegai> let's see if knows what perl6 is :P
08:38:40 * earthy had a student complain about perl being outdated and not used anymore. :)
08:38:58 <earthy> he was quicly set right. :P
08:39:07 <vegai> are the other perl6 implementations than pugs, by the way?
08:39:16 <int-e> perl is ugly. it's powerful, and useful. but ugly :)
08:42:07 * shapr sighs
08:42:27 <shapr> "Building hIDE-0.1.0... \n ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): \n unknown exception"
08:43:10 <gour> shapr: see (#1300803) - http://sourceforge.net/tracker/index.php?func=detail&aid=1300803&group_id=8032&atid=108032
08:44:07 <shapr> Looks like the same problem to me.
08:44:34 <beelsebob_> @seen JaffaCake
08:44:35 <lambdabot> I saw JaffaCake leaving #haskell 33 minutes and 46 seconds ago.
08:44:42 <beelsebob_> bugger
08:45:11 <gour> shapr: JaffaCake knows about it, i.e. he was here when i reported it
08:45:14 <shapr> ok
08:45:58 <gour> shapr: i tried to build hIDE with latest yi, and it builds, but i have another problem - scroll back
08:46:09 <gour> shapr: Lemmih is fixing that
08:46:10 <shapr> I get the same thing from both yi-0.2 and hIDE
08:46:19 <int-e> @where cabal
08:46:20 <lambdabot> http://www.haskell.org/cabal
08:48:03 <shapr> poo
08:49:51 <beelsebob_> oh bum
08:57:25 <Lemmih> gour: Pushed.
08:57:39 <gour> Lemmih: thank you, Lemmih
08:57:49 <Lemmih> gour: I haven't tested it so let me know if it works.
08:57:59 <gour> Lemmih: sure
08:59:59 <gour> Lemmih: i still get the same error, i.e.
09:00:03 <gour> gour@gaura-nitai ~/repos/hIDE $ bin/hIDE hide-base-0.1.0 hide-shell-0.1.0 hide-yi-0.1.0
09:00:03 <gour> Loading plugins: ["hide-shell-0.1.0","hide-yi-0.1.0"]
09:00:03 <gour> hIDE: /home/gour/repos/hIDE/lib/hide-yi-0.1.0/ghc-6.4.1/HShide-yi-0.1.0.o: unknown symbol `YiziUI_setFont_closure'
09:00:04 <gour> hIDE: user error (Unknown package: hide-yi-0.1.0)
09:01:57 <Lemmih> gour: Did you rebuild hide-yi after installing yi?
09:02:40 <gour> Lemmih: yes, i rebuild hIDE
09:02:56 <Lemmih> With build.hs?
09:03:01 <gour> Lemmih: is it required to re-build yi to?
09:03:02 <Lemmih> With build.sh, that is?
09:03:06 <int-e> Why doesn't the Haskell Data.List library have a merge (and mergeBy) function? I keep writing that again and again :/
09:03:10 <gour> Lemmih: true
09:06:14 <trez> How to make a comment over several rows?
09:06:30 <Lemmih> trez: {- multiline comment -}
09:06:30 <gour> Lemmih: before rebuilding with build.sh i did 'clean'
09:06:38 <trez> Lemmih: thank you
09:07:05 <Lemmih> gour: And you've got the latest yi?
09:07:35 <gour> Lemmih: yup
09:07:37 <Lemmih> gour: Try typing ':t Yi.UI.setFont' in GHCi.
09:08:26 <gour> Lemmih: 1st i had to load that in ghci?
09:09:17 <Lemmih> You shouldn't have to load anything.
09:09:33 <gour> Lemmih: Yi.UI.setFont :: (Graphics.UI.Gtk.Types.WidgetClass self) => self -> IO ()
09:10:13 <Lemmih> dcoutts: ping.
09:10:32 <dcoutts> Lemmih, pong
09:10:33 <Lemmih> gour: I don't know what's wrong and I can't reproduce it /-:
09:10:50 <Lemmih> dcoutts: Can you reproduce that error?
09:10:56 <gour> Lemmih: thank you for assistance
09:11:03 * dcoutts reads conversation
09:11:11 <gour> Lemmih: let's see what dcoutts says..
09:13:07 <dcoutts> gour, can you paste: ghc-pkg list
09:13:36 <gour> dcoutts: yup
09:13:53 <gour> gour@gaura-nitai ~/repos/yi $ ghc-pkg list
09:13:57 <gour> /usr/lib64/ghc-6.4.1/package.conf:
09:14:01 <gour>     rts-1.0, base-1.0, haskell98-1.0, template-haskell-1.0, unix-1.0,
09:14:05 <gour>     parsec-1.0, haskell-src-1.0, network-1.0, QuickCheck-1.0,
09:14:09 <gour>     HUnit-1.1, mtl-1.0, fgl-5.2, X11-1.1, HGL-3.1, OpenGL-2.0,
09:14:13 <gour>     GLUT-2.0, stm-1.0, readline-1.0, (lang-1.0), (concurrent-1.0),
09:14:17 <gour>     (posix-1.0), (util-1.0), (data-1.0), (text-1.0), (net-1.0),
09:14:21 <gour>     (hssource-1.0), plugins-0.9.10, (yi-0.2), Cabal-1.1.3, c2hs-0.14.3,
09:14:25 <gour>     harp-0.2, haskell-src-exts-0.2, hide-base-0.1.0, hide-shell-0.1.0,
09:14:29 <gour>     glib-0.9.9.5, cairo-0.9.9.5, gtk-0.9.9.5, mogul-0.9.9.5,
09:14:30 <gour>     glade-0.9.9.5, gconf-0.9.9.5, sourceview-0.9.9.5
09:14:30 <gour> /home/gour/.ghc/x86_64-linux-6.4.1/package.conf:
09:14:30 <gour>     yi-0.2, hide-base-0.1.0, hide-shell-0.1.0, hide-yi-0.1.0
09:14:40 <dcoutts> ok so here's the problem:
09:14:58 <dcoutts> you've got yi-0.2 installed globally and locally
09:15:13 <dcoutts> the global one is an old version that did not export setFont
09:15:26 <gour> yes, global is for re-producing that ghc panic..
09:15:29 <dcoutts> and when you start hIDE it's loading the global one and not the local one
09:15:47 <dcoutts> because hIDE looks in the global db first and then the local one
09:15:48 <gour> but Lemmih fix that by reversing..
09:15:56 <dcoutts> he did?
09:16:01 <gour> i.e. using reverse
09:16:05 <dcoutts> then it didn't work! :-)
09:16:16 <gour> why?
09:16:24 <dcoutts> gour, try this:
09:16:25 <gour> try to pull the patch
09:16:42 <gour> and see for yourself
09:16:56 <dcoutts> save your old global yi-0.2 registration info so you can restore it later
09:17:11 <gour> how to do that?
09:17:22 <gour> by saving *.conf file?
09:17:32 <dcoutts> $ ghc-pkg --global describe yi-0.2 > yi-0.2.package.conf
09:18:02 <dcoutts> then unregister the global one: $ ghc-pkg --global unregister yi-0.2
09:18:14 <dcoutts> and then try running hIDE again, I bet it'll work
09:19:28 <gour> you got it!
09:19:31 <gour> it works!
09:20:14 <dcoutts> so we need to fix hIDE or perhaps hs-plugins to load from the users package db first to match the behaviour of ghc/ghci
09:20:18 <gour> text pane is not unicode-ready?
09:20:27 <Lemmih> I thought I did that /-:
09:20:41 <gour> i cannot get Cro chars..
09:20:43 <dcoutts> gour, the Yi one might not be, the demo one should be
09:20:58 <dcoutts> Lemmih, this is probably something that dons should fix in hs-plugins
09:21:14 <dcoutts> Lemmih, hs-plugins should be aware of the users plugin db by default
09:22:17 <gour> dcoutts: true, demo is, Yi isn't
09:22:19 <dcoutts> it should match ghc/ghci behaviour
09:22:27 <Lemmih> Oh, it is problem in hs-plugins. I only made it load plugins from the local db.
09:22:34 <dcoutts> gour, that's because Yi is not unicode aware
09:22:54 <dcoutts> gour, you'll have to persuade dons of the value of that :-)
09:22:55 <gour> dcoutts: ok, how to restore old yi (global)?
09:23:08 * gour thinks to become more familiar with ghc-pkg
09:23:19 <dcoutts> as root: ghc-pkg register yi-0.2.package.conf
09:23:35 <dcoutts> uing the yi-0.2.package.conf file that you saved earlier
09:23:51 <gour> dcoutts: cute
09:24:11 <dcoutts> Lemmih, yeah it's hs-plugins problem really
09:24:28 <dcoutts> don't wory about it (but we should tell dons when he gets back)
09:24:37 <Lemmih> gour: I got a fix for hs-plugins.
09:24:56 <gour> Lemmih: boy, you're quick :-)
09:25:12 <dcoutts> since we're thinking abut hIDE... I'd like to think about some UI design issues if that's ok
09:26:08 <dcoutts> so in the file browser tree, if you select a file, it should be displayed in the editor pane.
09:26:20 <dcoutts> and it should be single click and not double click
09:26:53 <dcoutts> we should give the impression to the user that all files are 'open' and easily accessable
09:26:54 <gour> that sound nice
09:27:10 <gour> like pida?
09:27:21 <Philippa> textpad does that (though it's not a tree), I'm all for it
09:27:28 <dcoutts> double click makes it seem like you're opening a file, as if that were an expesnive thing when it's really not these days
09:27:31 <Philippa> (admittedly in textpad everything /is/ open)
09:27:52 <Philippa> only possible issue: is there ever any sane meaning for dragging and dropping a file into something?
09:28:02 <dcoutts> Philippa, so it doesn't use a tree? what does it have to select files?
09:28:06 <Philippa> eg might there be support for some kind of analyser I might want to drop one through?
09:28:07 <Philippa> plain list
09:28:21 <dcoutts> of what? the current dir? or of the open files?
09:28:38 <Philippa> the files in the workspace (which are admittedly all open)
09:29:02 <dcoutts> ah ok, so you add files to a "workspace" or in an IDE it mgiht be called a "project"
09:29:10 <Philippa> yeah. Well, you just open them, but hey
09:29:19 <Philippa> I still just open the workspace
09:29:37 <Philippa> opening a file is conceptually the same as adding it to the workspace, if you see where I'm coming from
09:29:43 <dcoutts> yes
09:29:46 <dcoutts> so I think a directoy view would be quite natural for an IDE
09:30:03 <dcoutts> but we shuld have the same immediacy, of all files appearing open
09:30:13 <Philippa> I'm in two minds about directory views
09:30:29 <Philippa> I know I have conceptual groupings I could use folders for, for example...
09:30:33 <dcoutts> I also want to be albe to "re-root" such a view
09:30:56 <Philippa> thing is, I'm not overly keen on the IDE half-dictating my on-disk layout for me :-)
09:31:02 <dcoutts> eg if you're working only in one directory you could open a new view/window starting from that subdir
09:31:11 <Philippa> I don't want to end up shoving all the cabal stuff in a subdir
09:31:17 <Philippa> I just want to be able to separate it out
09:31:24 <dcoutts> Philippa, indeed, which is why it should cope with any directory layout
09:31:26 <Philippa> (I probably also want non-hierarchical views, but hey)
09:31:37 <Philippa> ("show me just this!")
09:31:38 <dcoutts> what kind of other views would you want?
09:31:45 <dcoutts> oh, just the one file?
09:31:55 <Philippa> no, just the one non-directory-based grouping of files
09:32:03 <poetix> Module dependency graph views are nice
09:32:10 <Philippa> yep, was about to use that as an example
09:32:22 <dcoutts> I was thinking of another view of modules, rather than files
09:32:26 <Philippa> well, I was initially going to use a "show me the dependencies of foo" filter, but hey
09:32:44 <Philippa> then I need to switch tabs when I switch thinking about the two, no?
09:32:50 <dcoutts> yes
09:32:59 <Philippa> don't like that
09:33:03 <dcoutts> hmm
09:33:12 <dcoutts> how would you manage multiple views
09:33:16 <Philippa> documentation is a non-code module AFAIC :-)
09:33:46 <Philippa> well, for one I'm eventually going to want to be scripting new views for myself - I'm not sure tabs're entirely appropriate...
09:34:04 <dcoutts> I was thinking of tabs for a module view, a files view, a list of tools, a list of open unsaved files
09:34:06 <Philippa> or if not views, then at least filters, ordering...
09:34:20 <Philippa> the last one's a filter on a file view, no?
09:34:28 <dcoutts> and plugins could add more views
09:34:36 <dcoutts> yes it is a kind of filter
09:34:47 <Philippa> I'd rather have it exposed that way
09:34:52 <dcoutts> how customisable do you think people would want that?
09:35:06 <dcoutts> eg "ignore these files"
09:35:13 <Philippa> ultimately I'd like the option to type expressions in and have 'em evaluate
09:35:38 <Philippa> having some neat thing to let me name parameterisable filter functions and auto-generate forms for them would be cool
09:35:41 <dcoutts> oh, like a (FilePath -> Bool) evaluation function
09:35:47 <Philippa> yup
09:35:56 <dcoutts> that's not impossible :-)
09:36:01 <Philippa> well, (FilePath -> AppropriateMonad Bool)
09:36:40 <dcoutts> so various kinds of filters on file views then?
09:36:47 <Philippa> yeah. Probably also on the project view too
09:36:51 <dcoutts> and plugins can add totally custom views
09:36:59 <dcoutts> so what is a project view?
09:37:06 <Philippa> er, I meant module view
09:37:19 <dcoutts> it lists all files in their module heirarchy positions
09:37:55 <dcoutts> and merges trees of modules thatmight have multiple physical file system roots?
09:38:10 <dcoutts> eg if my sources are split across several dirs
09:38:21 <Philippa> I guess, yeah
09:38:23 <dcoutts> but there is one unified module namespace
09:38:40 <Philippa> hmm, perhaps I want to impose different views-of-the-project though
09:39:05 <Philippa> virtual folders sort of thing
09:39:13 <dcoutts> I was thinking at least at first that the module view would just be a clever filter on the file view
09:39:30 <Philippa> file view + odd sorting?
09:39:34 <dcoutts> virtual folders are fine so long as one can specify what they are :-)
09:39:44 <dcoutts> the file view is "virtual" too!
09:39:54 <dcoutts> they're just plugins that register nodes in a tree
09:40:14 <dcoutts> so it's not limited to files
09:40:16 <Philippa> oh, other obvious point: how're you going to deal with cycles in a dependancy graph view?
09:40:39 <dcoutts> I was not thinking of having a dep graph as a view actually
09:40:50 <dcoutts> but just make it easy to jump to module from within the editr
09:41:03 <Philippa> sometimes I'll want to see the whole graph
09:41:23 <dcoutts> a seperate tool that provides a proper graph would be nice though
09:41:30 <dcoutts> eg render it using graphviz
09:41:57 <musasabi> but usually the graph will need some pruning first.
09:42:04 <dcoutts> and click on the module to jump to it, however I don't think it fits the other model very well because of the cycles
09:42:05 <Philippa> fair enough. I'm starting to suspect I'll have to hack up a split view for that bar just so I can see things like tool results and the open files all at once
09:42:23 <dcoutts> you can open multiple top level windows
09:42:27 <Philippa> The other model might not always work off a tree control?
09:42:28 <dcoutts> would that be enough?
09:42:34 <Philippa> no
09:42:41 <dcoutts> the other model?
09:42:50 <Philippa> that requires me to alt-tab or do something similarly icky to switch between
09:43:04 <Philippa> the tree-based views thing
09:43:54 <Philippa> quick warning: I have exacting standards :-)
09:43:58 <dcoutts> right, I imagined that would always be a tree view thing, I suppose you could add a widget in a tab there that does not use a tree view
09:44:05 <dcoutts> Philippa, that's ok :-)
09:44:11 <basti_> I have found a bug (use of deprecated items) in HSQL that showed up while using haskelldb. I'm not sure which versions are affected (the one on Lemmih's page is, for sure). Where and how should i report it?
09:44:21 <dcoutts> Philippa, especially if you help out with the hacking!
09:44:38 <Philippa> I'm... nowhere near as productive as I'd like to be at the best of times, sadly
09:44:40 <dcoutts> seriously, it's great to chuck around UI ideas
09:45:00 <dcoutts> actually, it would be possible to deal with cyclic modules....
09:45:12 <dcoutts> who says the tree must be finite :-)
09:45:12 <Philippa> get me something I'm willing to at least start using and I'm likely to start hacking up customisations for my own benefit anyway
09:45:23 <Philippa> I really don't like that solution
09:45:29 <sethk> dcoutts, I figured out what my problem was running wxhaskell.  I think you were here when I was asking about it.  I wanted to compare gtk2hs to wxhaskell (which I'm now doing).
09:45:41 <dcoutts> sethk, cool
09:45:47 <Philippa> not unless you at least do something to stop me expanding an infinite list of nodes on my view
09:45:59 <Philippa> (and consider what it does to things like filtering?)
09:46:23 <dcoutts> Philippa, well it's not entirely a serious suggestion, but it's possible to just be able to keep expanding nodes to get their depenednt modules
09:46:41 <sethk> dcoutts, it was rather strange.  The build of wxhaskell sets environment variables that prevent you from compiling and linking.
09:46:42 <Philippa> yeah. It's begging for trouble when people start layering things on top of it though
09:46:47 <Philippa> infinities bad
09:46:55 <dcoutts> however it's prbably not a good idea anyway since the graph has lots of sharing, even without thinking abotu cycles
09:46:56 <sethk> dcoutts, I have to do it again to find the particular variable or variables
09:47:19 <dcoutts> sethk, hmm, odd
09:47:33 <sethk> dcoutts, very.  but repeatable.
09:47:49 <Philippa> oh yeah, I installed gtk+ and gtk2hs, what do I need to do with all the DLLs GHC can't find?
09:47:58 <Philippa> (or the executables, depending on where I try to run)
09:48:10 <dcoutts> Philippa, you're using windows?
09:48:13 <Philippa> yep
09:48:23 <dcoutts> so what's the issue exactly?
09:48:43 <dcoutts> you can't run the gtk2hs demo progs because of missing dlls?
09:48:50 <Philippa> I pick a demo, try to run it in GHCi, it can't find the DLLs
09:49:14 <dcoutts> ah, yes sorry about that. we can't simultaniously support ghc and ghci on win32
09:49:26 <Philippa> OK, will see how a GHC build works out
09:49:32 <Itkovian> Lemmih:  hasp -> cannot satisfy dependency ghc-src-any
09:49:37 <Philippa> any idea if the problem's likely to be resolved in the long run?
09:49:43 <dcoutts> Philippa, because the names of the dlls do not match the names of the static libs import thingies
09:49:50 <Philippa> (what'd need changing in GHC or GHCi, for example?)
09:49:56 <Philippa> ah, crappy
09:50:06 <Lemmih> Itkovian: Install ghc-src.
09:50:24 <Itkovian> erm, from your repos?
09:50:37 <dcoutts> Philippa, because ghc's libs: thing in it's package file quite reasonably assumes that the .dll has the same name as the .lib file, however on win32 that's not always the case
09:51:09 <sethk> dcoutts, can't you just rename them, then?  (Obviously I'm not a windows expert.  :)   )
09:51:10 <dcoutts> Philippa, it could be fixed fi we bug JaffaCake enough, or when ghc uses shared libs for it's own packages
09:51:43 <Philippa> 'k
09:51:50 <dcoutts> Philippa, since then it'll use the standard system linker rather than a custom dynamic linker which doesn't know about some of the quirkier aspects of linking
09:51:57 <Philippa> anyway, with that sorted I guess I could indeed prod around with hIDE then
09:52:29 <dcoutts> Philippa, it's possible to hack it at the moment to make it work by having two different package conf files, one for ghci and one for ghc
09:52:38 <Lemmih> Itkovian: There's an URL to ghc-src in the INSTALL file.
09:52:51 <Itkovian> ok, sorry
09:52:58 <dcoutts> the ghci one will contain the dll names and the ghc one the .lib names
09:53:23 <Lemmih> Kick ass! I just loaded the GHC api in GHCI (:
09:53:30 <dcoutts> Philippa, oh yes, that's obviously a problem for hIDE since it relies on the ghci style loader, bummer
09:53:34 <dcoutts> Lemmih, yar!
09:53:40 <Lemmih> (with some severe limitations, though)
09:53:45 <dcoutts> heh heh
09:53:59 <basti_> Lemmih: did you get my message?
09:54:16 <dcoutts> Lemmih, actually one thing that'd be really useful even without the fancy stuff is module import chasing
09:54:26 <dcoutts> so we can build dep graphs etc
09:55:13 <dcoutts> Philippa, so talking about views again, this is the current version: http://haskell.org/~duncan/hIDE/hIDE.png
09:55:45 <dcoutts> Philippa, so you see we've got the left hand pane with various "views", in that pic, just "Files" and "Open"
09:56:12 <dcoutts> (perhaps "Open" should be "recent" or something)
09:56:41 <Lemmih> basti_: Yeah. Unforfunately I'm not supporting HSQL-1.4. A permanent fix would be to hack haskelldb use HSQL-1.6.
09:57:00 <Philippa> dcoutts: how much trouble would it be to go to a silly-dockable layout?
09:57:00 <dcoutts> anyway, so you don't like the idea of having tabs for those views, you might want to see more than one view at once and not have to use multiple top level windows?
09:57:08 <Philippa> yeah
09:57:12 <basti_> Lemmih: ah. i fear the bug is in other versions too. who is maintaining the cutting edge of HSQL?
09:57:16 <dcoutts> Philippa, it's possible, though it can get annoying
09:57:20 <Philippa> one of the problems with tabs is it's hell if you grow enough tabs
09:57:25 <Philippa> how much code involved?
09:57:33 <Philippa> it's one of my acid tests for GUI libraries
09:57:36 <Lemmih> basti_: Krasimir Angelov, iirc.
09:57:41 <Philippa> because it's the sort of UI I'm likely to want to build...
09:57:45 <dcoutts> well we'd have to borrow the dock system from libegg
09:57:57 <basti_> Lemmih: nickname? ;)
09:57:57 <dcoutts> which is a collection of gtk extension thingies
09:58:21 <dcoutts> Philippa, yes tabs are only ok if there arn't too many of them
09:58:30 <Philippa> so gtk2hs on its own can't do it. Bah :-)
09:58:34 <dcoutts> Philippa, I figured people wouldn't need that many views
09:58:42 <Lemmih> basti_: I'm not sure he IRCs. His mail is: ka2_mail AT yahoo.com
09:58:51 <Philippa> more than about five will get really irritating
09:58:55 <dcoutts> Philippa, well it'd be an extension to gtk2hs, just like it's an extension to gtk
09:59:10 <basti_> Lemmih: k thanks
09:59:31 <Philippa> well, I guess I can live so long as I can do stuff like scroll with my mouse wheel
09:59:33 <dcoutts> Philippa, so how would you arrange it? if you've got lots of views
09:59:51 <dcoutts> Philippa, you can scroll the tree views with the mouse wheel and to interactive search
10:00:22 <z0d> Philippa: this Cardelli paper seems good, thanks
10:00:26 <Philippa> I'd probably want a drop-down list if I've got lots (obvious answer is make it easy enough for somebody to hack in whatever selection mechanism they prefer)
10:00:41 <dcoutts> ah I see, a drop down, hmm
10:00:52 <dcoutts> if you've got lots that would be better yes
10:00:55 <Philippa> z0d: no problem. For christ's sake use the ST monad or something similar if you implement it yourself btw, it makes life a lot easier :-)
10:01:07 <dcoutts> though I was assuming people wouldn't need that many
10:01:30 <Philippa> you seem to be thinking of using tools for things I'd use a view for
10:01:36 <z0d> Philippa: well, I'm at the first stage: studying it
10:01:42 <dcoutts> Philippa, yes I guess so
10:01:48 <Philippa> the easiest way to study it IMO is to translate the code
10:02:20 <Philippa> where do you plan on displaying tool results?
10:02:21 <z0d> Philippa: but before that you'll have to _understand_ it anyway
10:02:26 <Philippa> same place the editor's in?
10:02:27 <dcoutts> Philippa, things that apply to the current open page I was thinking should live in that second pane below the text editor
10:02:29 <Philippa> z0d: true
10:02:42 <Philippa> probably, yeah
10:02:43 <dcoutts> Philippa, but I've thought about that aspect less
10:02:48 <MarcWeber> Is it legal to write myplus=uncurry (+) ? How to call the resulting function, then? I've tried let a=myplus 3 4 but got an error
10:03:02 <dcoutts> Philippa, others have suggested a better system would be to have one single unified tree with different 'views' as subtrees of the root
10:03:06 <Philippa> I'm tempted to consider at least some tool results as being on the same level as files and modules
10:03:22 <dcoutts> Philippa, yes perhaps so, it would depend on the tool
10:03:30 <Philippa> yuck. That makes it hell to switch views fast because you've gotta scroll
10:03:36 <dcoutts> if it's specific to the current open file or not
10:03:48 <dcoutts> Philippa, I agree actually, I think tabs of views is nicer
10:03:55 <Philippa> it also stops you doing things like keeping the currently selected file between views
10:03:57 <dcoutts> but that was another opinion
10:04:13 <Philippa> oh, I /might/ want a way to select or group-select files without opening them all
10:04:19 <Philippa> like if I'm trying to feed them all into a tool
10:04:24 <dcoutts> hmm
10:04:32 <Philippa> (one of the reasons I might want to see files and tools at once)
10:04:53 <dcoutts> I'm not sure re-using the view browser thing for that would be good UI
10:05:12 <Philippa> the alternative is tools having to clone it
10:05:18 <dcoutts> true
10:05:38 <dcoutts> but not all items in the tree correspond directly to files
10:05:51 <Philippa> Filters :-)
10:06:00 <Philippa> And type tagging, and...
10:06:15 <dcoutts> hmm, what kind of tool would need that do you think?
10:07:09 <Philippa> tools that only work on code, only work on text, need to be aware whether they're looking at code, literate code or plain text...
10:07:12 <dcoutts> oh as for the people who want a single unified view, that's easy since underneath, it is a sinlge unified tree, but we only show a subtree in each tab, so to get the unified tree, just show the virtual root
10:07:31 <Philippa> obvious answer: plugins! :-)
10:07:40 <dcoutts> right, we would handle different files differently
10:08:02 <Philippa> and if you've got that mechanism for files, why not use it for folders, virtual links etc?
10:08:04 <dcoutts> eg the haskell code editor would register it's ability to handle .hs, .lhs, .chs etc files
10:08:13 <dcoutts> huh?
10:08:38 <Philippa> tree-objects have a type. Folder is a type, Haskell Code is a type, etc etc
10:08:43 <Philippa> tool result is a type too
10:08:50 <Philippa> which would allow tools to feed off each others' data
10:08:59 <dcoutts> oh, interesting
10:09:05 <syntaxfree> is there any sugary syntax for n-times function composition?
10:09:14 <syntaxfree> like, f(f(f(f(....(f(x))))..)
10:09:28 <dcoutts> syntaxfree, you could easily define a function to do that
10:09:47 <Philippa> yeah
10:09:51 <Philippa> take, fold, iterate
10:09:52 <dcoutts> syntaxfree, applyNTimes f n = ...
10:09:54 <syntaxfree> yes, I know. I just wanted to know if there was some syntax for that. I'm always rewriting stuff already in the language.
10:09:55 <Philippa> not necessarily in that order
10:10:01 <Philippa> no syntax
10:10:15 <dcoutts> less syntax, more functions!
10:10:28 <syntaxfree> dcoutts: that's Lisp, ultimately.
10:10:31 <ski> @hoogle Int -> (a -> a) -> (a -> a)
10:10:33 <lambdabot> Prelude.scaleFloat :: RealFloat a => Int -> a -> a
10:10:33 <lambdabot> Prelude.seq :: a -> b -> b
10:10:33 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
10:10:39 <ski> m, no
10:10:40 <dcoutts> syntaxfree, yes, ok, not that far then :-)
10:11:00 <Philippa> brb
10:11:02 <syntaxfree> I'm very fond of s-expressions and all, but I'm trying to move on to a typed language.
10:11:35 <dcoutts> Philippa, so I was thinking about having a tab of tools, but that only makes sense for tools which do not apply to the current editor view, but to the project as a whole
10:12:42 <dcoutts> Philippa, but I like the idea of non-tree views, eg a proper dep graph
10:14:53 <Philippa> I'm up for a tool tab so long as I can see both files and tools at once
10:15:01 <autrijus> greetings lambdafolks.
10:15:12 <autrijus> anyone perchance know the venue of CUFP?
10:15:23 <autrijus> <- just arrived at tTallinn
10:15:24 <dcoutts> Philippa, you mean a tab for a tool view
10:15:31 <Philippa> being able to splitter the views control'd work if you don't fancy docking, you could even use the one set of tabs
10:15:35 <Philippa> yeah
10:15:47 <Philippa> well, it's a view of all the available tools, yes?
10:15:50 <dcoutts> Philippa, and that would be for tools that apply to the current editor
10:15:55 <Philippa> tools go here, so it's the tool tab
10:15:56 <Philippa> *ah*
10:16:13 <Philippa> hmm, in that case I /really/ want to be able to put it elsewhere
10:16:18 <Philippa> 'sabit modal otherwise
10:16:36 <Philippa> my gut instinct's a toolbar for the editor instead
10:17:07 <dcoutts> that's why I though the tools for the current editor page would be down below the editor pane as a set of tabs
10:17:20 <dcoutts> but quite how yuo select which tool to open, I'm not sure
10:17:25 <Philippa> ah, yeah, that (mostly) works
10:17:35 <dcoutts> perhaps just from a view -> tool menu or something
10:17:38 <Philippa> context menu on the tab bar, menus, etc etc
10:17:52 <dcoutts> yes, ok
10:17:54 <Philippa> editor-specific toolbar (preferably customisable) is also good
10:17:59 <dcoutts> yes
10:18:13 * Philippa apologises for the expanding TODO list btw
10:18:45 <dcoutts> well my job as I see it is not to do all these things, but to make the architecture capable of supporting them
10:18:50 <dcoutts> while keeping the UI sane
10:19:11 <dcoutts> Philippa, here's a Q, what do you display when someone selects a directory in the tree rather than a file/module?
10:19:28 <dcoutts> empty space? don't change from the current file?
10:19:36 <dcoutts> something else?
10:19:37 <Philippa> don't change unless you've any better ideas
10:19:41 <dcoutts> ok
10:19:59 <Philippa> I probably wanted to get info off a context menu or apply a tool to it or something anyway
10:20:27 <dcoutts> it should certainly be ok to have a right click context menu for a directory
10:20:41 <dcoutts> eg items "like add a new module in this dir"
10:21:31 <Philippa> exactly
10:21:49 <dcoutts> another thing I wonder about is how we do project management
10:22:08 <dcoutts> I really hate IDEs that make you 'import' your stuff into them
10:22:20 <Philippa> what kind of project management?
10:22:30 <dcoutts> like I've got to tell them every single file that make up my 'project'
10:22:38 <Philippa> ah, that sort
10:22:42 <dcoutts> I don't need to do that with ghc, ghci, hugs etc
10:23:00 <gour> ..pull from darcs..
10:23:13 <gour> i.e. give url for darcs repo ;)
10:23:21 <Philippa> you're stuck with it, at best you have good tools for telling it what the project is
10:23:29 <Philippa> (like "grab everything this main module's dependant on")
10:23:31 <dcoutts> I just say where I'm starting from (and sometimes specify search paths if it's a complex thing) and ghc/ghci/hugs etc use import chasing and search paths to find everything
10:24:00 <dcoutts> now these days we've got cabal which tells us a lot about a package and how to build it
10:24:32 <dcoutts> so perhaps the logic should go like this:
10:24:56 <dcoutts> in the files view, we assume we're starting at the build root of the project
10:25:33 <Philippa> what about multi-program projects?
10:25:35 <dcoutts> find the .cabal file using the same logic as cabal uses, ie there may only be one cabal file in the directory or it's an error condition
10:25:45 <dcoutts> well cabal doesn't deal with them yet :-)
10:26:01 <dcoutts> we should think about how that should be done
10:26:27 <dcoutts> so by looking throught the file tree you can pickup projects by looking for .cabal files
10:26:43 <dcoutts> and we can find the deps between the packages
10:26:46 <Philippa> I'm not gonna use it that way myself
10:26:55 <dcoutts> how would you do it?
10:27:03 <Philippa> I just want to hand it the filename for a main module or modules and let rip
10:27:14 <Philippa> I'll do the cabal stuff when I'm ready to distribute, it's just a PITA the rest of the time
10:27:23 <Philippa> actually, where possible I want the cabal stuff built for me
10:27:27 <dcoutts> right
10:27:56 <dcoutts> but it at least provides something to integrate with, and a format for saving projects
10:28:27 <Philippa> I'm not convinced it does the latter effectively
10:28:33 <Philippa> where do I dump all my custom metadata?
10:28:51 <dcoutts> yeah we'd probably need that, but at least it covers the basics
10:29:23 <dcoutts> no ***** "please import your source tree into this IDE's limited concept of a project"
10:29:28 <Philippa> I'm inclined to treat cabal as an import-and-export/build format
10:29:43 <dcoutts> and basic project metadata
10:30:01 <dcoutts> it does allow you to define multiple Main modules for building progs
10:30:17 <syntaxfree> this isn't the right place to ask, I guess, but...
10:30:24 <syntaxfree> .. anyone knows the name of the new Jamiroquai album?
10:30:25 <dcoutts> Philippa, so that would support your "just want to hand it the filename for a main module or modules and let rip"
10:31:02 <dcoutts> Philippa, but it'd have to be something you tell the IDE I guess
10:31:16 <araujo> boo
10:31:25 <dcoutts> Philippa, or maybe not, we ought to be able to figure out if a module is a "main" module
10:31:32 <Philippa> Right. Do your new project thing then an "import from Main module" menu option'll do fine
10:31:41 <Akshaal> where is documentation describing syntaxis of haddock style comments?
10:31:49 <Philippa> Does it claim to be? If not, did I tell you it was?
10:31:58 <dcoutts> Akshaal, yes on the haddock website, it's got good documentation
10:32:37 <dcoutts> Philippa, huh? we're you talking to me?
10:34:04 <Philippa> dcoutts: main modules. Does something claim to be one? (module Main where...)
10:34:04 * Akshaal feels himself like a lamo. he mistakenly missed documentation in /usr/share/doc/haddock
10:34:14 <Philippa> if not, did I just tell the IDE that it's a main module? :-)
10:34:34 <Philippa> (a context-menu "treat this file as main and chase dependencies for me" thing in the views'd be a good start)
10:34:39 <dcoutts> Philippa, a main module is either (module Main where...) or has no module header at all in which case it's a main module
10:34:54 <dcoutts> so it's automatically discoverable
10:35:09 <dcoutts> so it means the build system has multple targets
10:35:58 <Philippa> yup. Though there are exceptions because you can tell eg GHC to consider a module to be main
10:36:16 <Philippa> and I might well do that for modules that both provide a main program and some skeleton that's called by another
10:36:17 <dcoutts> yes, that'd be a special case
10:36:22 <ski> Akshaal : lamo ?
10:36:42 <dcoutts> Philippa, well that could be done by manually adding a build target
10:36:57 <dcoutts> but I think we should be able to automatically discover the normal ones
10:37:32 <dcoutts> it does mean though that we probably need some concept of the current build target because otherwise it could be ambiguous
10:37:57 <Philippa> yep
10:38:14 <dcoutts> eg "compile this module" might be ambiguous if the module is part of several projects
10:38:15 <Philippa> a build targets view is thus born ;-)
10:38:22 <dcoutts> argg!
10:38:25 <dcoutts> :-)
10:38:28 <Akshaal> ski: sorry, russian jargon.. means lamer
10:38:45 <Philippa> actually that's potentially pretty useful, I get rather annoyed with not having something like it in MSVC6
10:39:14 <dcoutts> yes, changing build targets in VS6 was annoying
10:40:27 <Philippa> as was configuring all the damn settings, build types etc etc
10:40:35 <dcoutts> indeed
10:40:56 <ski> m
10:40:58 <dcoutts> using cabal's build system should make that easier
10:41:31 <dcoutts> we don't have to invent features that way, just support the features cabal supports
10:42:35 <dcoutts> we ought to be able to build a single module without worrying about the build target
10:42:53 <dcoutts> which is necessary for doing interactive checking etc
10:43:16 <dcoutts> but for a 'project' build we probably need a concept of the current target
10:44:01 <dcoutts> which would probably just be a current cabal project thingy (and indeed any dependent cabal packages in the same workspace)
10:46:16 <Philippa> where's the hIDE repo, btw?
10:46:52 <dcoutts> darcs get http://scannedinavian.org/repos/hIDE/
10:47:08 <dcoutts> it's pretty basic so far
10:47:40 <dcoutts> but it can load modules and the yi stuff is started and I've hacked together a basic UI shell
10:47:57 <dcoutts> there's no nice well defined plugins interfaces yet
10:48:43 <dcoutts> but feel free to start hacking on a project management plugin! :-)
10:48:48 <dcoutts> or indeed anything else
10:49:03 <Philippa> Invalid repository:  http://scannedinavian.org/repos/hIDE
10:49:03 <Philippa> darcs failed:  Failed to download URL http://scannedinavian.org/repos/hIDE/_darc
10:49:03 <Philippa> s/inventory
10:49:03 <Philippa> libcurl error code: 52
10:49:05 <Philippa> fun...
10:49:28 <dcoutts> hmm yes I can't get at it at the moment either
10:49:43 <dcoutts> ah, dns problems again, try this:
10:49:49 <dcoutts> http://scannedinavian.com/repos/hIDE
10:50:34 <dcoutts> the .com dns entry seem to be more stable sometimes, dunno why, ask shapr
10:54:10 <syntaxfree> what is hIDE?
10:55:22 <Lemmih> Hyper Integrated Drive Electronics.
10:55:33 <syntaxfree> huh?
10:56:15 <Lemmih> syntaxfree: It's an IDE for Haskell.
10:56:34 <syntaxfree> hmm.
10:56:42 <syntaxfree> sounds interesting.
10:57:12 <syntaxfree> I'm fed up with trying to learn emacs, anyway.
10:57:21 <Lemmih> Check out the wiki page at http://haskel.org/hawiki/hIDE/
10:57:43 <Lemmih> syntaxfree: hIDE has an emacs emulator (:
10:58:21 <syntaxfree> Attractive UI using Gtk+ 2.x
10:58:30 <syntaxfree> uh-oh. That means "looks awful on OS X".
10:58:35 <Lemmih> *http://haskell.org/hawiki/hIDE
10:59:09 <syntaxfree> wow. The Haste developers demonstrated that it's possible to build an IDE shell in a couple months with inexperienced Haskell developers.
11:00:15 <syntaxfree> hmm. Haste is another Haskell IDE :-O
11:00:57 <syntaxfree> using WxWidgets, it prolly looks better than OS X. But that's not good criteria.
12:00:30 <Itkovian> syntaxfree: uhu
12:03:29 <syntaxfree> ltkovian: yes?
12:03:53 <Itkovian> just reacting to the 'looks awful on OS X"
12:04:45 <gour> dcoutts: i forgot to tell you that Lemmih sent me a hs-plugin patch (1-liner)
12:05:06 <gour> dcoutts: so now hIDE finds local pkgs 1st
12:07:12 <syntaxfree> hmm. Proxima sounds interesting.
12:08:03 <syntaxfree> http://www.cs.uu.nl/research/projects/proxima/why.html
12:22:47 <RemiTurk> good evening to all
12:25:13 <Itkovian> hi
12:26:27 <heatsink> I can't understand what GHC is complaining about when typechecking this... http://www.haskell.org/hawiki/HaskellIrcPastePage
12:27:30 <RemiTurk> isn't that the dreaded "$ doesn't work with rank-(n+1)" story?
12:27:53 <heatsink> huh?
12:27:57 <heatsink> I haven't heard this story
12:28:12 <Igloo> Try putStrLn $ show $ f 2 (g 2)
12:28:27 * RemiTurk thinks that means Igloo confirming my theory ;)
12:28:46 <heatsink> oh, It worked
12:28:55 <heatsink> So it has something to do with the type of ($)
12:28:58 <RemiTurk> yes
12:29:12 <RemiTurk> basically, ($) wants a rank-1 thingy as it's second argument
12:32:13 <RemiTurk> heatsink, I cannot find any of it right now, but there have been quite extensive arguments on the haskell mailing lists regarding rank-2 types and ($)
12:32:46 <RemiTurk> (mostly revolving around things like "runST $ do ..." vs "runST (do ...)")
12:32:53 <RemiTurk> you might be able to find them :-/
12:33:21 <heatsink> heh, my real problem actually involved runST
12:33:23 <int-e> @type ($)
12:33:25 <RemiTurk> haha
12:33:28 <lambdabot> forall b a. (a -> b) -> a -> b
12:33:44 <RemiTurk> you'll have to define your own ($.) or something like that then
12:34:12 <heatsink> I can just use parentheses
12:34:18 <RemiTurk> or wait till ghc/hugs/... supports impredicative types (don't ask me about them, I wouldn't be able to answer ;))
12:35:54 <Oejet> Hejsan.
12:36:07 <RemiTurk> hi oejet
12:41:39 <heatsink> Ah, so something in the mailinglist says that a type variable cannot be instantiated to forall-anything.
12:41:55 <heatsink> That's the restriction that makes ($) not typecheck.
12:45:42 <RemiTurk> I think (though I didn't think much about it, certainly not today ;)) this is one of the places where I think type-level lambdas make things much clearer than quantifiers
12:46:39 <RemiTurk> AFAIK, the (forall a. ST s a) basically means (/\a. ST s a), that is, a function which receives a type as argument (in the System F translation)
12:47:03 <RemiTurk> and when viewed in that way, I think it's quite clear why a type variable cannot be instantiated to it
12:47:10 <RemiTurk> er, someone correct me if I'm wrong, please?
12:48:11 <musasabi> RemiTurk: but just translating them is a bit different from plain System F - no?
12:49:03 <musasabi> e.g. Foo a b | a->b. (\x -> Foo C x) is certainly valid,  but (forall x. Foo C x) is not.
12:50:04 <RemiTurk> with "\x" as in, type lambda?
12:50:20 <RemiTurk> I'd think (\x -> Foo c x) would be just as invalid as the forall then..
12:50:49 <musasabi> Depends on the value of x.
12:50:54 <RemiTurk> because the "| a -> b" basically says that the compiler should create a typelevel function from a to b
12:51:09 <RemiTurk> but "x" entirely depends on the value of C
12:51:46 <RemiTurk> you cannot say "\(x::a) -> x+1" is valid until you try to apply it to a string either, can you?
12:52:04 <musasabi> So we have either "forall x: Foo C x", "forall x: such that: Foo C x" and "exists x: Foo C x".
12:52:07 <RemiTurk> (well, of course, one could define lots of instances for Num, but..)
12:53:11 * RemiTurk would really like someone with a bit more system f/haskell typesystems knowledge to step up and explain everything the Right Way ;)
12:53:19 <musasabi> The second and third seem quite equivalent for practical purposes.
12:53:43 <RemiTurk> err, I'm not really understanding your "So we have either ..." I'm afraid :(
12:53:50 <musasabi> But I specifying the difference between the first and second one would be very nice.
12:55:26 <musasabi> RemiTurk: I am trying to understand what is the proper encoding of the second form with type lambdas.
12:55:58 <RemiTurk> musasabi, you mean the existential?
12:56:50 <RemiTurk> honestly, I don't really know, though I think I might see a parallel with a book about type theory/constructive logic (which I don't fully understand either :D)
12:57:10 <musasabi> yes.
12:57:33 <musasabi> I don't know the right way either :-)
12:58:13 * heatsink doesn't understand existential types
12:59:36 <heatsink> "I can construct a type [| T a |] for all a" makes sense to me.  "There is at least one a for which I can construct a type [| T a |]" sounds useless to me.
13:00:12 * heatsink isn't strong on type theory
13:00:28 <musasabi> heatsink: how about thinking type "[| T |] for all a such that <insert condition>" ?
13:01:36 <heatsink> that makes sense.
13:03:15 <RemiTurk> heatsink, what existential types (in haskell, at least) are actually used for is something like "I have this type "T a", for some particular "a"s, but I'm not going to tell you which ones
13:05:11 <heatsink> Is the validity of the type checked at compile time?
13:05:12 <RemiTurk> btw, does anyone have a working GHCi 6.4.1 lying around? (mine won't be compiled for a few more hours ;))
13:05:40 <musasabi> yes (ghc-6.4.1)
13:05:57 <ibid> yeah, a value of an existential type is essentially a pair (<type>, <value>), where the type of <value> is <type>
13:06:02 <RemiTurk> could you try "let f :: (Monad m, MonadPlus (t m)) => t m a; f = f; g = f" in GHCI, and tell me what it says?
13:06:35 <RemiTurk> (in 6.4, it gives a bogus error (well, the error is bogus, but not necessarily the fact that it gives an error)
13:07:12 <musasabi> http://youzen.b2.fi/~musasabi/a.txt
13:07:24 <musasabi> (contains the error from ghci)
13:07:25 <ibid> it is possible extract <value> from it when you know (in adnvance) <type>; if you guess the type wrong, you get a runtime error
13:07:37 <ibid> (at least as far as i remember)
13:07:48 <RemiTurk> ibid, aren't you talking about Dynamic?
13:07:56 <TheHunter> works fine here.
13:07:56 <ibid> no
13:08:07 <TheHunter> 6.5.20050804
13:08:09 <ibid> in type theory, an existential type is usually used in describing abstract  types:
13:08:21 <RemiTurk> TheHunter, thanks, I won't file a report then :)
13:08:42 <musasabi> 6.5.20050910 complains that there is  No instance for (MonadPlus (t m)), but does not emit the kind error.
13:08:44 <ibid> ie. a value of an abstract type contains a hidden implementation type, a value of that type, and functions that can "see" the internal type
13:09:05 <ibid> but i'm going from memory here
13:09:24 <musasabi> http://youzen.b2.fi/~musasabi/a.txt (added the 6.5 version)
13:09:28 <RemiTurk> our memories seem to agree then
13:09:53 <TheHunter> oh, without -fno-monomorphism-restriction i get the same error as musa.
13:10:24 <RemiTurk> ahh, the Urk!?
13:10:41 <ibid> (the abstract type ends up being essentially a record of functions with a "this" member containing the existential "internal" type
13:11:24 <TheHunter> my ghci's behavior is correct, imo.
13:11:55 <RemiTurk> TheHunter, which one?
13:11:57 <musasabi> It works with -fno-monomorphism-restriction in both 6.4.1 and 6.5
13:12:06 <RemiTurk> it works with -fno-mo.. in 6.4 too
13:12:21 <RemiTurk> but without it Urk!s, which is a little less nice
13:12:35 <TheHunter> the cvs one. The strangly-kinded thing is obviously a bug.
13:27:17 <MarcWeber> Is it possible to create a function such like myadd uncurry (+) ? How to call this then?
13:28:15 <Lemmih> @eval let myadd = uncurry (+) in myadd (10,20)
13:28:20 * RemiTurk isn't sure he understands the question
13:28:22 <lambdabot> 30
13:28:32 <RemiTurk> to define myadd such that myadd uncurry (+) works/
13:28:37 <RemiTurk> myadd = id
13:29:01 <RemiTurk> or do you want  myadd = uncurry (+)? (will probably need a typesig due to the dreaded monomorphism restriction)
13:29:28 <RemiTurk> or you want to know what to call "uncurry (+)", in which case I propose to call it "uncurry (+)" (it's quite short anyway)
13:32:18 <MarcWeber> RemiTurk: I meant myadd = uncurry (+).
13:36:11 <MarcWeber> RemiTurk: typesig, would that be e.g. myplus :: Integer -> Integer -> Integer?
13:36:32 <Lemmih> @type uncurry (+)
13:36:34 <RemiTurk> myplus :: Num a => (a,a) -> a
13:36:34 <lambdabot> forall b. (Num b) => (b, b) -> b
13:36:50 <Lemmih> MarcWeber: @type is :type in GHCi.
13:40:48 <araujo> Is it possible to use guards with case .. of ... ?
13:41:23 <RemiTurk> Prelude> case () of () | () == () -> ()
13:41:23 <RemiTurk> ()
13:41:23 <RemiTurk> Prelude>
13:41:46 <araujo> Thanks RemiTurk
13:42:47 <monochrom> funny example
13:43:02 <RemiTurk> it was supposed to be :)
13:43:21 <RemiTurk> and it's telling me I probably shouldn't try to think anymore this evening :)
13:46:07 <RemiTurk> good night everyone
13:46:56 <MarcWeber> RemiTurk: After adding your typedef myplus :: Num a => (a,a) -> a, I still can't call it this way: let n=myplus 3 4. Where is my mistake?
13:48:00 <Lemmih> MarcWeber: The first argument is a tuple.
13:48:03 <monochrom> let n=myplus(3,4) do you mean?
13:48:16 <monochrom> (isn't that the whole point of myplus?)
13:48:38 <monochrom> If you don't use tuples, why not just write (+) 3 4
13:50:18 <MarcWeber> Thanks, I've mixed curry with uncurry...
13:52:04 <MarcWeber> Oh me stupid boy. Of course. Now everything is clear.
13:54:05 <sethk> @eval myplus (3,4)
13:54:12 <lambdabot> 18: Not in scope: `myplus'
13:54:16 <sethk> @eval myplus 3,4
13:54:17 <lambdabot> 18: Not in scope: `myplus'
13:54:26 <sethk> that's wrong anyway.  :)
13:54:41 <sethk> why doesn't lambdabot see it?  Not loaded by default?
14:00:21 <Lemmih> myplus isn't even in the standard libraries.
14:12:23 <sethk> can lambdabot load libraries?  If it can, are they somewhere lambdabot can see them?
14:15:27 <Lemmih> @eval == runplugs.
14:15:28 <lambdabot> 30: parse error on input `)'
14:17:32 <SicKJacken> what does it mean when the resolution is duplicate with a bug in sourceforge?
14:18:54 <sethk> SicKJacken, can you be a bit more clear?
14:20:01 <SicKJacken> well, in ghc-bugs mailinglist...the bug resolution changed from 'none' to 'duplicate'
14:20:46 <Igloo> Presumably someone already reported the bug
14:20:52 <sethk> ah, that means that there was a bug report already in the database for the same bug
14:26:24 <SicKJacken> ow ok
14:27:15 <thedward> @eval ( foldr (.) id (take 5 (repeat (\x -> x * 2))) ) 2
14:27:18 <lambdabot> 64
14:27:46 <thedward> I'm still new enough to haskell that I am tickled by first class functions
14:27:47 <int-e> @eval iterate (2*) 2 !! 5
14:27:48 <lambdabot> 64
14:28:21 <SicKJacken> it is a very cool feature :D
14:28:49 <sethk> thedward, I'm still new enough to haskell that I'm sometimes confused by first class functions   :)
14:29:08 <thedward> heh
14:29:17 <int-e> thedward: (2*) is equivalent to (\x -> 2*x), iterate f x creates the list [x, f x, f (f x), f (f (f x))] ...
14:29:41 <thedward> I forget about partial application sometimes. :)
14:30:05 <int-e> thedward: you'll get used to it and soon come to miss it in other programming languages :)
14:30:09 <sethk> thedward, actually, I'm not really confused, I just sometimes forget the precedence and have to think a little
14:30:28 <sethk> thedward, partial application is seriously interesting, so I don't forget it.
14:30:52 <sethk> thedward, in fact it is always happening even when you may not think about it, any time there is more than one argument to a function
14:33:10 <thedward> jah
14:33:47 <sethk> thedward, also the types that are printed out in ghci are constantly reinforcing the notion.  int -> int -> int makes no sense without partial application.
14:34:13 <sethk> thedward, and since I still look carefully at the types because they reveal when I'm not clear about something, partial application is reinforced constantly for me.  :)
14:44:51 <Janni> Hi. Back to Haskell after quite some time...
14:45:02 <Cale> hello
14:45:04 <Lemmih> Welcome back, Janni.
14:45:32 <Janni> And as always coming with a question. I'm using Parsec for the first time, and there's a little problem:
14:46:01 <Janni> I want to parse, let's say, a sequence of letters: parseTest (sepBy letter space) "a o e u"
14:46:17 <Janni> (seperated by a single space)
14:46:58 <Cale> yeah
14:47:00 <Janni> But (and that's my problem) ``parseTest (sepBy letter space) "a o e u "'' does NOT succeed
14:47:12 <Janni> unexpected end of input. expecting letter.
14:47:22 <Cale> sepEndBy
14:47:31 <Janni> I think the correct behaviour should be, that the last space should NOT be consumed.
14:47:56 <Janni> At least when I use ``parseTest (sepBy letter (try space) "a o e u "''.
14:48:15 <Janni> I would like the last space not to be consumed.
14:49:06 <sethk> Janni, what you really (most likely) want is to allow either space or end
14:49:14 <sethk> Janni, as a delimiter
14:49:26 <sethk> Janni, I doubt you want to treat the last symbol as a special case
14:50:04 <sethk> Janni, I don't think there really is a "correct" behavior, although I agree that in most cases you want to succeed without that trailing space
14:50:53 <Cale> well, you could write a new version of sepBy
14:50:55 <Janni> Hmm. "end as a delimiter"?
14:51:03 <Cale> which only tries the delimiter
14:51:05 <sethk> Janni, end of the string
14:51:23 <Cale> sethk: the problem is with "a o e u "
14:51:30 <sethk> Cale, oh, sorry
14:51:37 <sethk> Cale, careless reading
14:51:49 <sethk> Janni, why do you care if the space is consumed?
14:52:06 <sethk> Janni, obviously that's reasonable since there is a function in the library that doesn't consume it
14:52:12 <sethk> Janni, I'm curious about why you care
14:52:24 <Janni> Hmm. Let me think _if_ I should care...
14:52:35 <Cale> you could use sepEndBy
14:53:17 <Janni> The thing is, what I actually am using is: sepBy1 ident (spaces >> char ',' >> spaces)
14:53:37 <Janni> And I really don't want to allow a ',' after the idents...
14:54:53 <Cale> I think the problem is that it eats the spaces, and then is committed to finding the comma
14:55:24 <Janni> No, no. It really doesn't matter what separator is used. It's all the same effect.
14:55:36 <sethk> Janni, generally speaking, when parsing that, you parse for     identifier  (, identifier)*
14:55:46 <Cale> (sepBy1 (many1 letter) (try (spaces >> char ',' >> spaces)))
14:55:46 <Janni> A separator at the end is consumed and the parser assumes another "thing"following.
14:55:48 <SicKJacken> if the spaces succeeds (for example if it accepts the empty string) it will want the rest to succeed to no?
14:55:58 <sethk> Janni, starting with an identifier and followed by zero or more   , identifier
14:56:11 <sethk> Janni, which might not fit here...
14:56:34 <Janni> OK. That's a solution...
14:56:37 <Cale> wrap the delimiter in try
14:56:43 <Janni> Although, that's what sepBy should be there for.
14:56:55 <Janni> Cale: Tried that, doesn't help
14:57:00 <Cale> It works for me
14:57:08 <Janni> Hm... Let me see...
14:57:10 <Cale> parseTest (sepBy1 (many1 letter) (try (spaces >> char ',' >> spaces))) "a, o, e, u "
14:57:10 <Cale> ["a","o","e","u"]
14:57:12 <sethk> Janni, there are situations where sepBy is what you want, even if this may not be one of them.
14:58:16 <Cale> adding the extra , makes it fail though, because then the delimiter parser succeeds and it will want another element
14:58:18 <SicKJacken> i would first deploy a lexer
14:58:26 <SicKJacken> keeps the parser cleaner i think
14:58:48 <sethk> SicKJacken, sure, but that's just transferring the problem from the parser to the lexer
14:58:53 <Janni> Hmm. Maybe you're right. The thing is I don't even know what a lexer is.
14:58:57 <sethk> SicKJacken, still has to be solved
14:59:07 <sethk> Janni, usually called a scanner
14:59:09 <SicKJacken> yeah it was more of a sidenote
14:59:28 <sethk> SicKJacken, lexer is lex/yacc centric, not really the correct term.
14:59:43 <Cale> I think that wrapping the delimiter in try is all that's needed
14:59:49 <SicKJacken> cause this reminded me of when my parsers were getting unreadable because of the space parsers everywhere
14:59:52 <sethk> Janni, just divides the problem into scanning (breaking the input into tokens) and parsing (figuring out the structure) to make it easier to manage
15:00:03 <SicKJacken> i just scanned the file...threw away whitespace tokens...and voila....
15:00:06 <sethk> SicKJacken, yes, definitely, that's why scanners exist
15:00:10 <SicKJacken> only structural parsing
15:00:18 <sethk> SicKJacken, but in this case it does nothing
15:00:31 <SicKJacken> if you dont really need the whitespace...it would solve the problem no?
15:00:33 <sethk> SicKJacken, because he then gets, from the scanner,  x  comma y comma z   (etc.)
15:00:59 <SicKJacken> so you parse "identifier (, identifier)*
15:01:12 <Cale> you can also write "symbol p = do spaces; v <- p; spaces; return p"
15:01:12 <SicKJacken> minus the " sign
15:01:17 <sethk> SicKJacken, doesn't solve the general case of   identifier  (, identifier)*
15:01:39 <sethk> SicKJacken, although it certainly is a good thing to do
15:01:51 <sethk> SicKJacken, get rid of white space in the parser, and get rid of comments, etc.
15:02:08 <sethk> SicKJacken, you might be right, because then the space, as a delimiter, no longer matters
15:02:08 <SicKJacken> i dont see the problem there really.... pIdentifier <*> pMany (pComma *> pIdentifier)
15:02:11 <Cale> and then define a bunch of symbol parsers
15:02:23 <sethk> SicKJacken, not a problem, just something not solved by removing spaces
15:03:54 <shapr> hiya Janni!
15:03:56 <sethk> SicKJacken, but I definitely agree, moving delimiters out of a scanner and into a parser is good, which is why all language parsers (that I've seen, which is a large number) do so
15:04:14 <Janni> Hi. Good to see you (or your name)!
15:04:24 <SicKJacken> sethk, then i fail to see what the problem is that janni has
15:05:00 <Janni> Btw: I figured it out. I tried out the "try" solution earlier but didn't succeed. The reason was of course s.th. else...
15:05:09 <sethk> Janni, hey, he _did_ not have a trailing space in the first example, I wasn't reading carelessly.  :)
15:05:11 <Janni> The "ident" consumed the spaces...
15:05:27 <sethk> Janni, didn't think of that, but now that you say it   :)
15:05:41 <SicKJacken> aha, see that without the spaces...this problem would not have occured :D
15:06:04 <sethk> SicKJacken, it is true that if you remove the spaces, the spaces are removed   :)
15:06:10 <SicKJacken> :D
15:06:42 <Janni> Thanks for the help. It's always the same... Either exactly after posting the question one finds the answer himself, or the question wasn't necessary at all...
15:06:45 <Cale> well, with parsec you don't really have to go to the trouble of doing an altogether separate scanning step -- you just write some parsers which do what a scanner would.
15:07:03 <sethk> Janni, that's ok, we got to think about it.  :)
15:07:26 <sethk> Cale, it still clutters the parsing code
15:07:46 <Cale> not really, if you keep things relatively separated
15:07:59 <Cale> What you do is to have a parser for each of your tokens
15:08:17 <sethk> Cale, I understand the concept, I still think it clutters the parser and makes it more difficult to read
15:08:20 <Cale> and then just use those token parsers
15:08:49 <sethk> Cale, and I see no real advantage to that, you are still scanning, it is just that you are scanning where everyone sees it
15:09:01 <SicKJacken> having a parser for each token also means having parsers for parsing whitespace tokens....and doesnt that take you back to the situation where you were?
15:09:07 <SicKJacken> or am i missing the concept here?
15:09:41 <Janni> Isn't space a parser for parsing whitespace tokens?
15:09:48 <sethk> SicKJacken, you essentially have mini scanners inline.
15:10:03 <heatsink> Cale: it still clutters the parser because you have to use 'try' judiciously to avoid putting the tokenizer-parsers into a bad state
15:10:07 <sethk> Janni, generally the way things are done is to eliminate white space in a scanner
15:10:22 <sethk> Janni, take a look at the parsers for any of the open source language compilers
15:10:30 <sethk> Janni, or the docs for lex/yacc
15:10:38 <sethk> Janni, which is not to say that's the only way to do it...
15:11:00 <sethk> Janni, but the thrust of your question, which I think is "don't parsers get rid of white space in general" is no
15:13:42 <sethk> heatsink, can you explain the situation where that happens?  I'm not clear about exactly what "try" does for you in this context
15:27:47 <heatsink> sethk: if any of the tokens you could read have matching prefixes, you need to parse with 'try'... the scanner converts the token into a single token so that 'try' is not necessary
15:28:10 <heatsink> sethk: e.g., next token could be "{" or "{-"
15:28:21 <sethk> heatsink, so it essentially is for backing up the parser?
15:28:28 <heatsink> yes
15:28:33 <sethk> heatsink, similar to pushing things back onto the input stream
15:28:52 <heatsink> sure
15:29:27 <sethk> k
15:29:29 <sethk> thanks
15:30:34 <SicKJacken> or just left-factor your parsers :)
15:32:27 <heatsink> but that's what parser-generators are for :)
15:33:48 <sethk> SicKJacken, you may not have arbitrary control of the necessary syntax.  some grammars don't have an equivalent left factored form
15:34:14 <SicKJacken> achieving LL(1) is not always possible indeed
15:34:18 <SicKJacken> only regular grammars
15:34:52 <sethk> SicKJacken, what I said.  :)
15:35:42 * shapr yawns
15:42:36 <SicKJacken> im off sleeping
15:42:37 <SicKJacken> later
15:45:20 <sethk> I'm trying to use { and } and ; instead of layout.  When I put the { after where, as is shown in the haskell report, I get errors on import.  Is there a compiler switch I need in this case?  Did I misunderstand the report?
15:46:05 <Igloo> Have ou got ;s after all the import statements?
15:46:25 <sethk> Igloo, let me do it again, I edited them out.  maybe I missed one.
15:47:06 <sethk> Igloo, thanks, I think I may have left one out.  Now I just get to figure out how "case" should be delimited.  :)
15:51:54 <sethk> @eval Just
15:51:59 <lambdabot> <Plugins.Eval>:1:12:
15:51:59 <lambdabot>   No instance for (Show (a -> Maybe a))
15:51:59 <lambdabot>   arising from use of `show'
16:20:19 <sethk> Do I remember reading somewhere about an alternative to Maybe/Just that is somehow "better"?
16:20:48 <Lemmih> "better"?
16:21:04 <sethk> Lemmih, I don't remember the details, so I don't remember in what sense they were better
16:21:23 <sethk> and "better" is meaningless anyway
16:21:39 <Lemmih> Maybe is pretty much perfect for what it should do.
16:21:49 <int-e> Maybe or not Maybe ...
16:22:44 <sethk> I may not be remembering what I read correctly, but I thought there was some language-theoretic objection to Maybe/Just.
16:28:54 <int-e> sethk: hmm. what could it be? that 'Nothing' is not expressive enough to express several possible 'errors'?
16:29:26 <sethk> int-e, using them makes the code look like C++ before exceptions, so I can see an objection.  Control.Exception is probably to be preferred
16:29:47 <sethk> BRB
16:30:03 <int-e> @type maybe
16:30:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:58:39 <sethk> how do I start ghci with a module?  I want to use Data.Typeable.   If I say ghci Data.Typeable, I get "Data.Typeable is a package module"   If I say ghci -package Data.Typeable, I get "unknown package: Data.Typeable"
16:59:17 <wilx> The docs should say what package it is in.
16:59:36 <wilx> Look at the right side of the modules listing in docs.
17:00:11 <sethk> wilx, the docs say "base package"
17:01:49 <brx> hi havoc651
17:03:05 <ulph2> Is it possible to import two modules where there is a collision in the name of entities?
17:03:20 <ulph2> Not importing the entities is not an option.
17:03:40 <wilx> Import one of them as qualified.
17:03:41 <Lemmih> sethk: ':m Data.Typeable'
17:03:54 <wilx> Can you do that from command line?
17:04:02 <sethk> Lemmih, I can do that, but I still can't use it.  Rather I can't find the syntax to use it.
17:04:30 <Lemmih> You can't set the current scope from the command line.
17:04:50 <sethk> yes, I know that.  I need to know how I _can_ set the scope, not how I can't.  :)
17:04:55 <ulph2> wilx: oh right thanks :)
17:05:10 <Lemmih> sethk: You can set it with ':m'.
17:06:06 <sethk> Lemmih, thanks
17:06:34 <dcoutts> Lemmih, how's it going?
17:07:16 <Lemmih> dcoutts: Great. I'm about to get renaming and typechecking working.
17:07:34 <Lemmih> (using hi files from 6.5)
17:07:43 <dcoutts> Lemmih, wow, well done
17:08:43 <dcoutts> btw, using your hacked version of ghc-api with 6.4.1 will still be really useful for project management, ie for dependency chasing and that sort of thing (eg module dep graphs etc)
17:09:01 <dcoutts> even though we will not be able to do renaming and typechecking with 6.4.1
17:09:45 <dcoutts> and getting it capable of displaying build errors inline in the text editor will be good too (ie underlining the sections with the error)
17:09:57 <dcoutts> and that can be developed without ghc 6.5
17:10:29 <dcoutts> I've benn thinking more about the UI design and the underlying data model, Philippa was helping me with some ideas
17:14:19 <Lemmih> Renaming would give some neat refactoring possibilities.
17:15:07 <dcoutts> yes, you've seen HaRe ?
17:15:12 <dcoutts> @where HaRe
17:15:13 <lambdabot> I know nothing about hare.
17:15:24 <dcoutts> @google HaRe Haskell
17:15:25 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
17:15:49 <dcoutts> they're moving to useign the ghc-api, and they;ve got emacs & gvim integration
17:16:13 <dcoutts> it should be an ideal fit, an HaRe plugin for hIDE
17:40:49 <wagle> has anyone seen a programming environment where you start out in a dynamically typed environment, then incrementally refactor it into a statically typed environment?
17:41:19 <orbitz> so the type system of the language chagnes as you develope?
17:41:32 <orbitz> would that work well? idioms for dynamically typed languages differ from those of statically
17:41:43 <orbitz> so you might start desiging in a way which doesn't work out for a static language
17:42:26 <int-e> wagle: I think you can come close to that in Lisp, where you can start typeless and incrementally add type declarations; a good compiler will enforce them, as far as possible, at compile time.
17:43:04 <wagle> i'm doing a gui in tcl/tk because i don't know what i want, and i just want to try things..  type system would just slow me down..  eventually, for fragments of the code, i figure out what i'm doing, and could then do some nice stuff with haskell-like programming
17:43:38 <wagle> int-e: hmm
17:43:42 <orbitz> why would a type system slow you down?
17:44:05 <wilx> Well...I think that getting things right from the start is better approach than such approach.
17:44:27 <orbitz> why rewrite things 10 times when you can write it once?
17:44:48 <wagle> the code is incomplete, buggy, flaky, wrong, etc..  but it does do something, and I first want to see what it does, THEN clean and polish it up
17:45:10 <orbitz> a type system will make it not buggy, flaky, or wrong for you
17:45:36 <wagle> wilx: so the first airplane must actually work safely before you test it?
17:46:26 <Philippa_> if you want me flying it, it damn well better do
17:46:31 <wilx> :D
17:46:32 <wilx> Yeah
17:46:43 <orbitz> i should hope it's safe
17:46:47 <wagle> Philippa_ lives in a world with no airplanes
17:47:32 <wagle> it took many attempts to produce a the first airplane
17:47:57 <wagle> once you got a working one, then things went rapidly
17:48:06 <orbitz> using a type system doesn't mean the rpogram is right the first time
17:48:09 <Philippa_> all those attempts made by people willing to fly one that's not safe
17:48:10 <wagle> and it become much more safe
17:48:12 <orbitz> it just means you have gurantees of what is not wrong with it
17:48:16 <Philippa_> that's not me
17:48:31 <orbitz> which sounds quite reasonable to me
17:48:59 <wagle> i didnt say i didnt want a type system
17:49:55 <wagle> its just that i dont want it until i figure out what i'm doing..  i want to try things out AND RUN THEM before i know what i'm doing
17:50:27 <wagle> haskell wont run things that dont COMPLETELY type check
17:50:53 <int-e> hmm. well, I find that helpful most of the time.
17:51:02 <wagle> and i'm not saying that you should be happy with a program that doesn't completely typecheck
17:51:16 <int-e> if you end up correcting too much you've written too much code at once ;)
17:51:26 <int-e> and for trying stuff, there's ghci ...
17:51:34 <wagle> oh well
17:52:32 * int-e finds that the darcs version of c2hs compiles with ghc 6.4.1 and is happy again.
17:53:52 <Philippa_> wagle: I believe some lisp variants can do what you're after
17:54:01 <wagle> summary: i don't want to spend a week prototyping something perfectly in haskell if i can spend a day prototyping it in tcl/tk, and find that its not at all what i want
17:54:30 <wagle> Philippa_: i want to end up with a haskell program
17:55:12 <Philippa_> fair enough. Prototype elsewhere then, and prototype as little as you can get away with
17:55:43 <Spark> hmm
17:55:44 <wagle> 7000 lines of tcl/tk..
17:55:51 <Philippa_> *wince*
17:56:11 <Spark> how about an optional run-time environment for haskell where types are dynamically instead of statically checked
17:56:21 <wagle> some parts I understand, and would be nice as haskell
17:56:34 <Spark> so you can reference non-existant terms so long as that code never gets executed, and so on
17:56:43 <wagle> other parts are completely wrong, and porting to haskell would be a waste of time
17:56:54 <Spark> what was the thesis of that paper about runtime vs static type checking
17:56:58 <Korollary> that has already been demonstrated with dynamic ocaml as such
17:57:23 <wagle> ahh..  dynamic ocaml..  hmm
17:57:31 <sethk> you can always stub out the things that you aren't ready to compile yet
17:57:58 <Spark> how about static type errors being compiler *warnings*, and have a "bail after n warnings" option
17:58:19 <Korollary> But they are not warnings.
17:58:31 <wagle> i want to run the flakey error ridden parts to see if they are even close to what i want..  if not, i throw out the code without having to make it type correct
17:59:34 <Spark> you'd have to execute a type-unsafe program in a special run-time environment, but the fact that it compiled with type warnings could be encoded as a flag in the binary
17:59:54 <wagle> how's this for a different summary: i want to formalise tghe process of taking a buggy program and turning it into a bugless program
18:00:19 <Korollary> that process is called test driven development I believe
18:00:23 <wagle> i want to be able to see how much of the buggy program actually works each step of that incremental process
18:00:55 <wagle> i don't want to be not allowed to even run the buggy program
18:01:02 <Spark> wagle: you want to leave bits of the code that aren't used, unfinished?
18:01:33 <Spark> what about syntax errors
18:02:16 <wagle> one problem with tcl/tk is that it doesn't even detect syntax errors until run-time
18:02:40 <Korollary> why don't you regard as the freedom to not fix the syntax until you know what you want, then ?
18:02:47 <wagle> prototyping GUI's is very rapid and easy, debugging is a PITA
18:03:25 <wagle> Korollary: i don't understand your question
18:04:04 <Korollary> wagle: you said that you want to run as much as you can without worrying about the types so that you can know if what you just wrote can give you what you want.
18:04:14 <wagle> ok
18:04:32 <Korollary> wagle: in a similar sense, you may as well run as much as you can without worrying about the syntax of the broken parts.
18:05:21 <wagle> in tcl/tk, i do just that..
18:05:32 <Korollary> but you said that it was a problem
18:06:20 <wagle> but it would be nice to have the parts that i understand and COULD put into a type safe language could be put in a nice type safe language
18:07:06 <Korollary> there are parts of the program that you don't understand ?
18:07:27 <wagle> Korollary: when i finish the tcl/tk program, I want to _automate_ (partially or completely) the process of porting it to java and/or haskell
18:07:53 <wagle> so i'm wondering if anyone's done anything resembling that already
18:08:28 <Korollary> probably not formally
18:08:39 <wagle> Korollary: there are parts that i dont understand how to do right in the sense of it being what i want to end up with..  so its crufty, half broken, etc
18:08:57 <eieiei> why oh why does hIDE require GV?
18:09:13 <wagle> tcl/tk has some really cool ideas, but also a lot of really bad ones
18:09:30 <wagle> eieiei: print preview?
18:11:03 <wagle> i liked programming in scheme, but i really wanted a type system..  i really like programming in haskell, but its really painful to try certain kinds of wacky things out to see what happens
18:11:30 <wagle> , which is where scheme was better
18:11:41 <wagle> i want both worlds at the same time
18:12:31 <wagle> ... or the first world from the start, then start flipping things over to the second world..
18:13:21 <wagle> there are fragments of the tcl/tk code that do exactly what I want, i could easily port to haskell,
18:13:40 <Lemmih> eieiei: GV?
18:14:01 <wagle> but the tcl/tk is in severe need of refactoring..  i dont want to refactor a type unsafe language
18:14:14 <wagle> Lemmih: gui to ghostview
18:14:43 <Lemmih> Wait, are we talking about the old hIDE?
18:14:54 <wagle> Lemmih: i dunno
18:14:55 * ptolomy has done very little tcl, but it seemed 'yucky' to my language tastes. Perhaps it is an acquired taste.
18:14:59 * wagle points at eieiei 
18:15:25 <eieiei> I like programming in Scheme because there's no type system.
18:15:46 <eieiei> I really like programming in Haskell because of all the interesting syntax patterns, but the type system really gets in my way.
18:16:06 <Lemmih> eieiei: Were you referring to the old hIDE?
18:16:06 <wagle> ptolomy: i've known it for quite a while..  its pretty gross until you get all the little tricks straight in your head, and then its half really cool ideas, and half really bad ones
18:16:07 <int-e> eieiei: well, try to do some of the syntax tricks without a type system
18:16:26 <int-e> eieiei: in particular try doing partial application without a type system.
18:16:35 <Lemmih> eieiei: That's why we have unsafeCoerce# (:
18:16:55 <wagle> ptolomy: it was just that i could get right to trying out the gui, but it would take a while to get up to speed in java or haskell
18:16:55 <int-e> @hoogle unsafeCoerce#
18:16:57 <lambdabot> Prelude.readLn :: Read a => IO a
18:16:57 <lambdabot> Prelude.undefined :: a
18:16:57 <lambdabot> Prelude.reads :: Read a => ReadS a
18:17:29 <int-e> hmm. okay, it *could* be a type variable.
18:17:56 <wagle> ptolomy: so the idea was to get a buggy version in tcl/tk, then watch carefully as I translated that into java and haskell..
18:18:01 <Cale> eieiei: the type system gets in your way?
18:18:15 <Cale> how?
18:18:16 <wagle> .. because that sort of process really interests me
18:18:31 <Cale> eieiei: I've only ever had it catch my bugs.
18:19:35 <Cale> Also, with the typeclass system, you can do type-directed programming which is really flexible.
18:21:00 <int-e> @type cast
18:21:01 <lambdabot> bzzt
18:21:14 <Cale> (though I admit that there are some places where it could be extended -- it would be nice to have a type-equality predicate)
18:21:16 <int-e> @type Data.Typeable.cast
18:21:17 <lambdabot> forall b a.
18:21:17 <lambdabot> (Data.Typeable.Typeable b, Data.Typeable.Typeable a) =>
18:21:17 <lambdabot> a -> Maybe b
18:21:19 <eieiei> explain olhd hIDE vs new hIDE.
18:23:00 <wagle> Cale: yeah.. i want stuff like the typedirected programming now
18:23:33 <Cale> wagle: have you read the HList paper?
18:24:01 <wagle> Cale: i keep meaning to
18:24:22 <Cale> the class system is somewhat prologesque
18:24:24 <wagle> i keep getting distracted
18:25:36 <wagle> yeah, it looked really interesting..  i think its that finally now i am getting to the point that i do need to read it
18:25:46 <Cale> another cool (and slightly cheap) example is Text.Printf :)
18:27:57 <wagle> yeah..  but its isnt just type safety..  i start out with really buggy/wrong tcl/tk code, i try it, fix it up halfway, then 2/3's of the time decide it isn't what i want at all and throw it out
18:28:29 <wagle> ... if i did that in haskell, i'd have to wait until i got it right before i could run it to find that it wasnt what i wanted
18:29:27 <Cale> Sometimes you can tell just from the types that something is or isn't what you want :)
18:29:44 <wagle> hmm..  maybe its a rugged landscape..  i use tcl/tk to find the right cliff face, then want to use haskell to scale it
18:30:10 <wagle> Cale: its more functionality thats the problem
18:30:28 <wagle> its largely a gui with a complex physics behind it
18:30:45 <Cale> behind the gui?
18:30:52 <wagle> yeah..
18:31:47 <wagle> (model-controller-viewer)
18:32:58 <Cale> perhaps I'm taking the word "physics" too literally? :)
18:33:19 <wagle> probably.. i'm a bit loose with the term
18:33:55 <wagle> its a (very abstract) physical simulation
18:34:47 <Cale> ah, okay
18:35:08 <wagle> 11000 widgets
18:35:18 <Cale> eek
18:35:39 <wagle> well, maybe 20 different kinds of widgets
18:35:42 <Korollary> space shuttle control panel ?
18:35:44 <Cale> okay :)
18:39:47 <wagle> its 6000 lines, and i've thrown out 12000 lines..  now about 2000 lines is "what I want", and the other 4000 need a major rewrite
18:40:04 <Cale> of Haskell?
18:40:10 <wagle> tcl/tk
18:40:12 <Cale> oh
18:40:13 <Cale> okay
18:40:30 <Cale> 6000 lines of Haskell is an awful lot :)
18:41:14 <wagle> when its what i want, i want to convert it to something like template haskell to take it to the next level
18:42:14 <wagle> a LOT of that 12000 lines of tossed code was obviously wrong well before i would have gotten it to typecheck in haskell
18:42:41 <wagle> but now i want that 2000 lines in haskell so i can make further progress with it
18:42:50 <Cale> well, it also might not have been 12000 lines in Haskell :)
18:44:05 <wagle> well one goal of the whole thing is to figure out what haskell needs to have allowed me to do all this using haskell from the start
18:44:07 <Cale> My scheduler was about 1000 lines which was around 40% documentation, and I could imagine it being 10 or 15 thousand lines of something like C.
18:44:36 <Korollary> 2000 lines of haskell is a lot of code
18:45:26 <wagle> i started out not knowing what haskell was missing..  now i have some idea..  when i understand what that is, then i'll have someething
18:45:31 * Korollary wonders how long it takes for the Simon's to churn out 2000 lines
18:46:57 <Philippa_> mapM putStrLn (take 2000 $ repeat "this is a line")
18:47:30 <Cale> mapM putStrLn $ replicate 2000 "this is a line"
18:47:55 <Philippa_> point
18:48:15 <wagle> putStrLn "2000 lines, churned"
18:49:03 <wagle> @eval this is a line
18:49:05 <lambdabot> 18: Not in scope: `this'23: Not in scope: `is'26: Not in scope: `a'
18:49:05 <lambdabot> 28: Not in scope: `line'
18:49:17 <wagle> ha!  syntax error!
18:49:25 <wagle> *<8-D
18:49:28 <Philippa_> only in the wrong context
18:49:56 <wagle> well, the initial connotation was "2000 lines of (working?) code"
18:50:04 <Korollary> @eval let this _ _ _ = 0 in this is a line
18:50:06 <lambdabot> 45: Not in scope: `is'48: Not in scope: `a'50: Not in scope: `line'
18:50:09 <Korollary> hah
18:50:13 <Korollary> I'm too lazy
18:50:17 <wagle> touche!
18:50:51 <Philippa_> putStr "line = id\nthis = id\na = id\nis = id\n" >> mapM putStrLn $ replicate 1996 "this is a line"
18:51:08 <wagle> rofl
18:51:53 <Philippa_> (and it still doesn't work because it has 1996 top-level expressions - whoops)
18:52:04 <Korollary> damn type errors
18:52:19 <Korollary> preventing you to churn out 2000 lines quickly
18:52:26 <wagle> in tcl/tk, it would have run..  8-p
18:53:06 <Korollary> it runs with #! runhaskell as well. Just not as far.
18:53:13 <wagle> and you would have proven your point without having to bother getting it to actually typecheck
18:53:34 <wagle> :)
18:56:30 <Cale> It's better that it doesn't typecheck :)
18:57:11 <wagle> you dont like watching program crash and burn?
18:57:42 <Cale> right. If I have to run the program before finding out about problems, that's annoying and sometimes too late.
18:58:31 <Cale> Also, if things are compile time errors rather than runtime errors, I will catch them rather than having some machine-dependent interaction obscure them on my system and make them crop up on someone else's.
18:58:59 <Korollary> I had python programs that ran overnight and thrown errors, which was not pleasant to find in the morning.
18:59:19 <wagle> i'm claiming two modes of programming: (1) rapidly find the best mountain to climb (tcl/tk), (2) climb the mountain with the best equipment available (haskell)
19:01:09 <wagle> Korollary: yeah, i want to avoid that for production code
19:14:42 <Lemmih> eieiei: Old hIDE: http://www.dtek.chalmers.se/~d99josve/hide/. New hIDE: http://www.haskell.org/hawiki/hIDE
19:21:40 <wagle> btw, tcl/tk programs more than 100 lines are hideous
19:25:32 <wagle> hmm..  now i really am using clifford algebras..
20:09:01 <sethk> wagle, tcl/tk programs less than 100 lines are hideous also
20:13:08 <wagle> sethk: hahah
20:13:36 <sethk> wagle, not that I'm opinionated or anything
20:13:42 <pesco> Hi, I'm trying to install a debian package for lhs2TeX 1.10 prerelease. I've found one, but somehow my package management doesn't seem to pick it up. Maybe some debian user here could try to help me out?
20:20:27 <pesco> Okay, I've got it. Nevermind. ;-)
20:21:14 <pesco> Nighty night, #haskell.
21:06:20 <Captain_Fourier> hello
21:07:57 <Lemmih> Hi.
21:08:39 <Captain_Fourier> im having a bit of trouble compiling ghc
21:08:49 <Captain_Fourier> and this is the only place i could think to go
21:10:36 <Korollary> I suppose the binaries don't work for you ?
21:10:44 <Captain_Fourier> they do
21:10:59 <Captain_Fourier> but i need source
21:11:11 <Captain_Fourier> or rather i would prefer source
21:11:42 <Korollary> which platform ?
21:12:17 <Captain_Fourier> solaris
21:12:27 <Captain_Fourier> 32bit and 64bit
21:16:40 <Captain_Fourier> ??
21:16:55 <dons> hello #haskell
21:17:06 <Captain_Fourier> hi
21:17:51 <Korollary> Sorry, I've only built ghc on linux.
21:18:37 * dons is in finland :)
21:18:49 <juhp> Captain_Fourier: what kind of problem?
21:18:57 <juhp> dons: hi!
21:19:18 <dons> hey juhp!!
21:19:32 <juhp> dons: how's the weather?
21:19:46 <dons> mmm. cold :/
21:19:53 <juhp> heh
21:19:53 <dons> 13 degrees or so in helsinki
21:20:02 <dons> it was 29 when i got on in bangkok :}
21:20:13 <Korollary> dons: I thought you were going to Estonia ?
21:20:18 <juhp> dons: you should visit in winter ;)
21:20:29 <dons> yep. sitting in the airport with a 4 hr wait for my flight
21:20:36 <juhp> ah
21:21:07 <Captain_Fourier> im getting ld errors
21:21:17 <Captain_Fourier> and some symbol references bugs
21:21:23 <juhp> hm
21:21:26 <dons> just have time to commit some mid-flight darcs patches
21:21:36 <juhp> :)
21:21:42 <dons> hmm. scannedinavian.com is a lot faster from helsinki than sydney ..
21:21:56 <juhp> heh
21:23:46 <Lemmih> Hi dons.
21:23:59 <dons> hey Lemmih :)
21:24:03 <Captain_Fourier> mind if i paste the exact lines
21:24:12 <Captain_Fourier> to some local pastebin
21:24:22 <Lemmih> dons: Welcome to Europe (:
21:24:29 <Korollary> Captain_Fourier: use lisppaste
21:24:30 <dons> thanks!
21:24:35 <Captain_Fourier> heh
21:24:35 <dons> it looks very nice :)
21:24:43 <Captain_Fourier> those folks hate me
21:24:50 <dons> maybe i'll move here..
21:24:56 <dons> if only it was warmer
21:25:04 <Korollary> dons: how about Italy, then ?
21:25:11 <dons> ah, now that sounds good
21:25:49 <dons> hmm. isn't it really early in Lemmih-land?
21:25:58 <Korollary> @timein Lemmih
21:26:01 <lambdabot>  Sorry, don't know this city
21:26:02 <Lemmih> Yeah. I'm on my way to bed.
21:26:07 <Lemmih> @timein Copenhagen
21:26:09 <lambdabot>  Saturday, September 24, 2005 at 6:14:39 AM CEST
21:29:02 <Lemmih> dons: I've removed the RTS references from the GHC api.
21:29:37 <dons> ah, ok. what's the consequences of doing that?
21:29:45 <dons> we can load it?
21:29:48 <Lemmih> No bytecode compiler.
21:29:58 <dons> oh, ok. future work then
21:29:59 <Lemmih> Yes, it loads in GHCi.
21:30:21 <dons> cool.
21:32:27 <Lemmih> I wonder how hard it would be to translate 6.4 hi files to the new interface.
21:32:58 <dons> hmm. that's an interesting idea
21:34:08 <Lemmih> Oh and I've got a patch for hs-plugins.
21:34:56 <dons> darcs send
21:35:08 <dons> i'll push it to the repo in a few hours once i get to my hotel
21:37:02 <dons> got it, cheers
21:37:09 <Lemmih> It's a very small patch. It just puts new package dbs in front the old instead of behind them.
21:37:26 <dons> i'l push it now
21:38:08 <dons> done.
21:38:12 <Lemmih> Thanks.
21:52:11 <dons> ok. battery flat. time to go!
21:52:42 <Lemmih> Bye.
21:52:54 <dons> hmm. though it has been sitting on 6% -1 miinute remaining for about 20 minutes now..
21:53:11 * dons suspects that the apm daemon doesn't estimate well
21:53:46 <dons> Lemmih, I put some more yi patches up. is there anything you want done in the emacs mode first?
21:53:49 <dons> file writing perhaps.
21:54:04 <Hikaru79> What's the easiest way to convert an IO string to a String?
21:54:14 <dons> also, I need to think about a plugin/standalone-abstracted way to initialise and create windows
21:54:16 <Lemmih> Hikaru79: unsafePerformIO.
21:54:43 <Lemmih> Hikaru79: The correct way is a bit different, though. (:
21:54:55 <dons> Lemmih is teasing
21:55:24 <Hikaru79> =P I prefer to learn it the correct way off the bat.
21:55:35 <dons> you probably mean to use: do s <- getLine
21:56:14 <Hikaru79> dons, I could do that, but I'd like to pass the string directly to a function
21:56:26 <Hikaru79> As in:   read $ hGetLine stdin
21:56:39 <dons> liftM read $ hGetLine stdin
21:56:41 <Hikaru79> (which of course doesn't work)
21:56:51 <dons> or do s <- getLine ; read s
21:57:05 <dons> s :: String
21:57:28 <juhp> getLine >>= read
21:58:54 <juhp> er, scratch that
21:59:05 <Lemmih> getLine >>= return.read
21:59:33 <Lemmih> Goodnight, #Haskell.
22:00:10 <Hikaru79> Night, Lemmih
22:00:51 <dons> night Lemmih
22:06:09 <dons> dcoutts, hmm. Yi should be unicode aware. i think it is a silly bug that means you can't insert greater than \255 atm
22:07:08 <juhp> dons: in my build I can't even delete :)
22:07:51 <dons> hmm, really?
22:08:14 <dons> the vim mode is a bit broken, but emacs should at least delete. works for me
22:09:17 <dons> oh, I see this: printableChars = map chr [32..127]
22:09:24 <dons> hehe. that's going to kinda restrict what you can insert
22:49:36 <Cale> anyone familiar with gtk2hs around?
23:16:13 <autrijus> greetings from CUFP - http://perlcabal.org/~autrijus/cufp2005.pdf
23:16:34 * Korollary cheers
23:17:30 <gour> good luck, autrijus
23:40:35 <Cale> autrijus: I love the O'Reilly spoof
23:56:54 <autrijus> :D
23:57:10 <autrijus> I'm so terribly nervous, I hope I didn't ruin the talk :)
23:58:41 <gour> we'll hear about that :-)
23:59:38 <gour> and we're looking forward to hear news from "Learning Haskell" session in Amsterdam..
