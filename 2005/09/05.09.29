00:08:01 <delYsid> sethk: Calculating the optimal tuning would have been part of my algo, since I'd consider tuning up the "first move", i.e. if a song doesnt work out in the standard tuning, the algo would try again with different tunings
00:09:30 <delYsid> sethk: YOu can look at it like a game, first "move" is setting up tuning, and every additional move is either plucking a open string or pressing down a note...
00:09:53 <basti_> delYsid: a guitar fingerboard game?
00:10:16 <delYsid> basti_: A algo to work out fingerings...
00:10:44 * basti_ nods
00:10:46 <ski> basti_ : OI comonad would not be contravariant
00:11:10 <basti_> ski: not?
00:11:14 <basti_> why not?
00:11:37 <ski> because both monads and comonads are functors
00:11:41 <ski> and those are covariant
00:11:58 <basti_> oh
00:12:19 <ski> (i.e. they are covariant functors .. there is also a concept of contravariant functor, but neither a monad nor a comonad is such a one)
00:12:42 <basti_> a contravariant functor would be like FA -> A ?
00:12:52 <ski> basti_ : the simplest example is  data Id a = a  this can be made into both a monad and a comonad, .. and it's surely covariant
00:13:26 <ski> "FA -> A" ?
00:13:37 <basti_> well a functor is A -> FA
00:13:41 <basti_> with an injection
00:14:03 <basti_> so a co-functor would need to be a epi FA -> A.
00:14:10 <ski> an example of a contravariant functor is  data Foo a = F (a -> Bool)    you can make a comap :: (b -> a) -> (Foo a -> Foo b)
00:14:55 <basti_> :-o
00:15:03 <ski> a functor consists of a mapping of objects, together with a mapping of morphisms/arrows, which also satisy some laws ..
00:15:17 <basti_> yes.
00:15:30 <basti_> A -> FA is the mapping of objects
00:16:00 <basti_> then (A -> B) -> (FA -> FB) is the mapping of meppings
00:16:02 <basti_> e/a
00:16:15 <ski> in the covariant case  F : C -> D, f : A C_-> B |- F_mor f : (F_ob A) D_-> (F_ob B)
00:16:26 <basti_> :-o
00:16:29 * basti_ is trying to parse
00:16:33 * boegel returns
00:16:52 <ski> in the contravariant case  F : C -> D, f : B C_-> A |- F_mor f : (F_ob A) D_-> (F_ob B)
00:17:15 <ski> i don't know why you say 'A -> FA' is the mapping of objects
00:17:38 <ski> F maps objects from a category to a category .. above named C respectively D
00:18:09 * basti_ isnt all that practiced in CT btw.
00:19:06 * shapr yawns
00:19:24 * cbus yawns even louder
00:19:34 <shapr> Good morning #haskell!
00:19:45 <basti_> hey shapr.
00:19:46 <boegel> y0 shapr
00:19:47 <Muad_Dibber> Good morning mister shapr
00:19:57 <basti_> ski: mmmk, i think i'm getting what you're saying.
00:21:34 <shapr> Wassup?
00:21:46 <basti_> ski: diagram wise, my notation of a functor is: C on the top, FC in the bottom. C is A -> B -> C... , D is FA -> FB -> FC ...
00:22:08 <basti_> F_mor is what i'd write (A->B) -> (FA->FB)
00:23:38 <basti_> shapr: CT.
00:26:34 <shapr> I could never read the maps.
00:27:00 <basti_> I bought a star map as a birthday present for my gf
00:29:39 <ski> basti_ : yes .. F_mor : forall A,B : C_ob. (A C_-> B) -> (F_ob A D_ob F_ob B)
00:30:05 <basti_> ski i just took a while to parse
00:30:16 <ski> only that A -> F A  is more a monad F .. not a functor
00:30:29 * ski just got disconnected :)
00:30:39 <basti_> i noticed
00:30:41 <basti_> :P
00:32:06 <shapr> hej phb
00:32:31 <phb> hiya shapr
00:36:40 <phb> bbl, need more sleep =)
00:36:41 <C-Keen> moin!
00:36:43 * basti_ laughs
00:46:11 <shapr> metaperl: Yow!
00:46:25 <shapr> metaperl: How's your study of Haskell? I enjoy reading your blog posts on sequence.
00:46:33 <metaperl> shapr: thanks
00:46:48 <metaperl> shapr: I'm reading the huffman encoding part of SJT
00:46:58 <Pistahh>  metaperl: where is your blog?
00:47:03 <metaperl> but a book on drugs and the US government has been taking all my commute time :)
00:47:11 <metaperl> Pistahh: sequence.complete.org
00:47:36 <shapr> JohnMeacham: Is there a JHC blog?
00:47:36 <Pistahh> metaperl: if you don't put http:// in front of it, I cannot click it! ;P :)
00:47:56 <shapr> Pistahh: http://sequence.complete.org/blog/16
00:48:01 <shapr> That's metaperl's blog on sequence
00:48:06 <Pistahh> thx. I was just joking.
00:48:21 <Lemmih> Hi ProfTeggy.
00:54:06 <ProfTeggy> Hi all, hi Lemmih.
00:55:22 <shapr> autrijus: Do you know which darcs repo holds the darcs-GADT stuff?
00:55:44 <shapr> Encoding darcs patch properties in GADTs is a great idea!
01:02:13 * aleator figures that key of using c++ and haskell together is just to Make it .so
01:03:27 <pejo> aleator, there was a mail on ghc-users from SPJ about that quite recently.
01:03:52 <pejo> (recently = last week?).
01:07:05 <autrijus> shapr: http://urchin.earth.li/darcs/ganesh/darcs-patch-theory/
01:08:38 <aleator> btw. Are there nice, representative gadt examples floating around?
01:13:40 <ProfTeggy> aleator: http://www.cs.pdx.edu/~sheard/
01:15:40 <Pistahh> what is gadt?
01:16:27 <ProfTeggy> Generalized ADTs, a polymorphic 'data' type declaration in which the polymorphic type can be specialized on a per-constructor basis
01:17:02 <Pistahh> ProfTeggy: thx, the only words I understood were "in", "which" and "the". :)
01:17:13 <knobo> what does  discriminating hackers mean?
01:17:15 <ProfTeggy> That's a start, Pistahh ;-)
01:19:33 <sylvan> knobo, hackers who are picky about what language they use, I suppose
01:25:43 <Lemmih> Yihaaa. I just type-checked a document in hIDE with ghc-api.
01:26:16 <psi> knobo: hackers with refined taste and excellent judgement :)
01:26:54 * autrijus has just been blasted by a ray of pure oleg
01:27:18 <autrijus> my mind is reeling :-/
01:27:22 * ski wonders how much ..
01:27:25 * autrijus feels flayed
01:27:25 <dblhelix>       autrijus: there're things that are worse
01:28:47 <knobo> I see
01:29:15 <ski> autrijus : how many oleg, would you think ?
01:33:55 <knobo> dict -> No definitions found for "oleg"
01:41:12 <shapr> knobo: An oleg is a unit of type hackery. It derives from Oleg Kiselyov, famous type hacker.
01:41:32 <Lemmih> dons, dcoutts: http://212.242.49.100/yi-hide-ghc.png
01:42:32 <psi> nice, lemmih
01:42:40 <dons> yeah!
01:43:00 <dons> so, is that the type checkerR?
01:43:10 <dblhelix> Lemmih: yep, cool
01:43:12 <Lemmih> Yes.
01:43:22 <dons> @karma+ Lemmih
01:43:23 <lambdabot> Lemmih's karma raised to 4.
01:43:40 <tic> you should add a short-hand so you can just say lemmih++
01:43:42 <dons> and is that a yi buffer being post-processed? or the normal buffer?
01:43:46 <Pistahh> @karma+ Pistahh
01:43:47 <lambdabot> You can't change your own karma, silly.
01:43:57 <Lemmih> dons: That's the Yi buffer.
01:44:04 <dons> fantastic :)
01:44:04 <Pistahh> @karma+ lambdabot
01:44:05 <lambdabot> lambdabot's karma raised to 4.
01:44:09 <dons> really great work :)
01:44:12 <Pistahh> @karma- lambdabot
01:44:13 <lambdabot> lambdabot's karma lowered to 3.
01:45:33 <dons> Lemmih, so how do you get the position info? is it ghc's new accurate info being used?
01:45:52 <dons> also, performance? (though talking to JaffaCake, I think it should be ok)
01:45:55 <Lemmih> dons: Yep.
01:46:18 <dons> is this also in CommmonSense (hehe)
01:46:50 <Lemmih> It's just a quick hack so it doesn't run it it's own thread yet.
01:47:08 <dons> sure. but should be ok performance wise, you think?
01:47:15 <dons> or not enough data yet?
01:47:42 <dons> shapr: ping. check out Lemmih's hide work.
01:47:58 <Lemmih> It should be OK once I've cleaned it up a bit.
01:51:21 <Lemmih> We can cache a fair bit of the tokens if it proves to be too slow, I think.
01:51:28 <dons> right.
01:51:46 <shapr> Lemmih: gorgeous!
01:51:54 <dons> hmm. I think this would make a nice screenshot of 'future work' at the end of the Yi talk tomorrow :D
01:53:15 <dons> does Visual Hsakell do this, or are we already one step ahead?
01:53:55 * autrijus survived even more oleg ray
01:54:20 <autrijus> so ccshan and oleg came to me and oleg said something scary about that my GADT+Record extension would entail unsafeCoerce
01:54:30 <Lemmih> We can load interfaces from 6.4 so we have the potential to go further than vshaskell.
01:54:31 <dons> ok, this is kinda what VH is doing atm. so that's great :)
01:54:35 <dons> yep!
01:54:39 <autrijus> because they will amount to irrefutable partterns on GADT which is proven to be unsound
01:54:59 <dons> and we have more control over the project. we can tweak any code at any level.
01:55:09 <Itkovian> shapr: do you have any plans on extending the rss feed beyond 'Day's entry'
01:55:16 <dons> Lemmih, have you read the VH paper for ideas?
01:55:17 <autrijus> happily, if I craft my patch in the way that follows the H98 standard of case/of desugaring, then the wobbliness doesn't really escape as oleg thought, so my pet feature is still safe. whew.
01:55:28 <shapr> Itkovian: Yes, but no idea when it will happen.
01:55:34 <Lemmih> dons: Yeah.
01:55:36 <dons> actually, I think we should in fact enumerate their features, work out which ones we want
01:55:52 <shapr> Itkovian: I'd rather hack Flippi to export RSS, then I could use wiki markup in my entries.
01:56:08 <Itkovian> ok, well, till then I'll drop you from my rss reader ;-)
01:56:19 <shapr> ok
01:56:27 <Itkovian> no offense
01:56:31 <shapr> no worries
01:57:19 <dons> and I'll start a wiki entry for plugins we want. e.g. darcs, HaRe, pugs
01:57:35 <dons> @where hide
01:57:37 <lambdabot> http://www.haskell.org/hawiki/hIDE
01:58:53 <ski> autrijus : what extension/feature ? (url ?)
02:01:52 <autrijus> ski: see my journal...
02:02:20 <autrijus> http://use.perl.org/~autrijus/journal/
02:02:27 <ski> danke
02:02:42 <autrijus> bitte schoen
02:07:50 <dons> Lemmih, (before you fall asleep?) what do you think of using -ddump-parsed for auto-indenting?
02:08:01 <dons> or roughly similar
02:08:35 <dons> we may need to write our own pretty printer module, but it would be the best haskell indenter under the sun
02:08:47 <dons> no regex-based indenter could come close
02:09:23 <dons> we'd need to be able to indent expressions at a time
02:09:47 <autrijus> scannedinavian timing out?
02:09:56 <JohnMeacham> wazoo!
02:10:05 <dons> so an instance Ppr Expr is all that would be needed, then replace the selected text with the output of ppr exp
02:10:10 <JohnMeacham> drinks plus haskell equalls good.
02:10:25 <autrijus> oh well, maybe some other time for hacking with ghc-api
02:10:31 <stefanw> dons, are you at a workshop today or just hacking?
02:10:39 <dons> just hacking/talk writing
02:10:46 <dons> later on some sight seeing
02:10:57 <JohnMeacham> It bothers me that I end up partying while y'all are in school. I think it gives an somewhat odd view of my life.
02:11:05 <dons> hehe
02:11:17 <dons> SanFran (that's right?) looks fun from here John.
02:11:22 <JohnMeacham> at least I get the urge to program haskell after partying :)
02:11:36 <JohnMeacham> Los angeles. (pasadena actually)
02:11:53 <dons> ah, right. were you in San Francisco at some point though? or am i dreaming
02:12:04 <JohnMeacham> If anyone is in the area. I highly recommend visiting me.
02:12:11 <dons> heh!
02:12:14 <JohnMeacham> I used to live there when I worked at sun microsystems.
02:12:33 <Lemmih> dons: You want to do automatic indentation from the syntax tree?
02:12:38 <dons> yep
02:12:59 <JohnMeacham> I was in the Kernel Performance group. great guys!
02:13:04 <dons> I want to at least select an expression and have it ppr'd for me
02:13:13 <Lemmih> Ah.
02:13:25 <dons> as ppr = nice indenting
02:13:32 <wagerlabs> howdy
02:13:42 <dons> I could write any old garbage and get nice typesetting of it
02:13:45 <Lemmih> dons: We would need to write our own pretty printer since the one in GHC is broken.
02:14:02 <dons> right. but we can take the existing one.
02:14:09 <dons> I know it pretty well, so that sounds like a nice plugin
02:14:10 <musasabi> Or fix the one in GHC?
02:14:16 <wagerlabs> i'm trying to build Crypto-2.0.3 which requires NewBinary. i built and installed NewBinary but Crypto cannot find it :-(
02:14:19 <wagerlabs> any suggestions?
02:14:22 <dons> hmm, I think Sean Seefried might have worked on that.
02:14:37 <dons> so that the TH-generated code could be ppr'd and fed back in
02:14:46 <wagerlabs> Could not find module `NewBinary.Binary':
02:14:59 <Lemmih> wagerlabs: Did you run 'Setup.lhs configure' again?
02:15:13 <dons> anyway, fairly straight forward plugin, I think. call ghc-api to parse the code, get back an tree, feed it to our ppr plugin
02:15:25 <wagerlabs> i configure both libraries with /opt/local and NewBiary is in /opt/local/lib/NewBinary/...
02:15:39 <wagerlabs> Lemmih: ran it a few times
02:15:52 <Lemmih> wagerlabs: Using Hugs?
02:15:52 <wagerlabs> Lemmih: ./Setup configure --prefix=/opt/local
02:16:01 <wagerlabs> ghc 6.4.1 on mac osx 10.4
02:16:21 <Lemmih> wagerlabs: And the configure script found NewBinary?
02:16:34 <dons> stefanw, any things you'd like to see in hIDE: http://www.haskell.org/hawiki/hIDE_2fDesign and http://www.haskell.org/hawiki/hIDE
02:16:41 <wagerlabs> Lemmih: configure: Dependency NewBinary-any: using NewBinary-0.1
02:17:41 <shapr> hiya wagerlabs, I've been reading your blogs. Interesting stuff.
02:18:02 <wagerlabs> thank you shapr. i'm trying to do a nework proxy in haskell instead of erlang now
02:18:26 <wagerlabs> something that sits between my old poker client at http://sf.net/projects/openpoker and the new server
02:18:38 <Lemmih> wagerlabs: Does NewBinary contain NewBinary.Binary?
02:18:43 <wagerlabs> the old client implements its own encryption protocol instead of ssl
02:18:47 <stefanw> dons, right at the moment, I would really need a "generate program transformation code from LaTeX description" plugin :-)
02:18:56 <Lemmih> wagerlabs: If not then you may need a newer version.
02:19:20 <wagerlabs> Lemmih: let see... ls /opt/local/lib/NewBinary-0.1/NewBinary/
02:19:29 <wagerlabs> Lemmih: Binary.hi       FastMutInt.hi
02:19:42 <dons> stefanw, hehehe. go for it ;)
02:20:02 <dons> just want to keep you in the loop in case you finish your thesis :)
02:20:07 <Lemmih> wagerlabs: Can you load it in GHCi?
02:20:46 <wagerlabs> lemmith: now idea how to do it. :l NewBinary i guess? let me try
02:21:03 <Lemmih> ':m NewBinary.Binary'
02:21:27 <wagerlabs> Lemmih: can't load it. i thought i had the latest version, though.
02:21:38 <musasabi> wagerlabs: what does "ghc-pkg -l" tell you? Does it know NewBinary?
02:22:14 <wagerlabs> Lemmih: darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
02:22:21 * Lemmih takes off but will be back in a bit.
02:22:21 <wagerlabs> musasabi: give me a sec
02:22:49 <wagerlabs>     NewBinary-0.1
02:23:05 <wagerlabs> musasabi: /Users/joelr/.ghc/powerpc-darwin-6.4.1/package.conf:
02:23:10 <wagerlabs> it's finding the package there
02:23:14 <musasabi> ok.
02:23:18 <wagerlabs> strange, i thought i installed global
02:23:58 <wagerlabs> musasabi: it's finding it in the global list too
02:24:46 <autrijus> ski:do  you think the design is basically sane?
02:25:18 <wagerlabs> musasabi: i blew away ~/.gch/ and it's fine now
02:25:34 <wagerlabs> musasabi: i guess it was looking at that first and then at the global package list
02:25:41 <wagerlabs> thanks for your help y'all!
02:26:06 <ski> (autrijus : sorry, not read all yet .. got distracted)
02:27:54 <autrijus> ski: oh ok, never mind. it's just the "data T x where Con { label :: a } :: T a" form
02:39:05 <dcoutts> Lemmih, you rock.
02:40:45 * dcoutts had better get on with his UI work
02:45:54 <ski> autrijus : ok
02:45:58 <ski> i think that syntax looks fine, yes
02:46:27 <ski> what what the issue ccshan and oleg mentioned ?
02:46:51 <manulito_> ski: anv‰nder du vim?
02:46:56 <manulito_> anyone using vim+haskell here?
02:47:12 <ski> manulito_ : icke
02:47:37 <ski> something when a repeated selector has differing result types .. i guess
02:47:54 <ski> hm
02:49:58 <dons> manuito_, yep
02:50:13 <dons> whhat's your question about vim?
02:51:03 <bjak> has anyone tried visual haskell? is it working?
02:51:17 <ski> autrijus : isn't it rather something like .. the types of the fields of the repeated selector must be same ?
02:51:24 <dons> i assume so. i'd be surprised if it wasn't, bjak
02:51:43 <bjak> good. hands on experience anyone?
02:52:52 <bjak> well it's still new. I will wait...
03:07:30 <manulito_> anyone here with some smart .vimrc with some haskell commands?
03:09:32 <Heffalump> several of us will be going to a talk about it tomorrow morning
03:10:35 <dcoutts> Heffalump, the VS/VH talk you mean
03:10:42 <Heffalump> yes
03:10:52 * dcoutts wishes he were there
03:11:22 <dcoutts> dons, nice wish list of plugins btw
03:11:23 <basti_> re
03:11:55 <dons> dcoutts, add any you think of please
03:12:11 <dcoutts> will do
03:18:34 * Lemmih has returned from the library.
03:19:26 * basti_ has not
03:19:32 <Lemmih> With 555 pages of techie literature.
03:19:58 <wilx`> Hm....
03:20:07 <dons> Lemmih, what topic?
03:20:17 <wilx`> Is there any Haskell framework for producer-consumer idiom?
03:20:32 <dons> perhaps a Chan?
03:20:47 <dons> depends on how you want to do it. check out the concurrent haskell work
03:20:59 <dons> (pretty easy to use, btw)
03:21:20 <wilx`> Not concurent, if possible.
03:21:23 <Lemmih> dons: Bookkeeping.
03:21:33 <Lemmih> Pretty dry stuff.
03:21:34 <ProfTeggy> autrijus, I would have expected    Con :: { label::b } ->  T a  syntax
03:21:50 <wilx`> Something with low overhead, concurent (threads?) sound pretty heavy.
03:22:01 <dons> wil`, check out a Chan. threads are super-lightweight in haskell, btw
03:22:12 <basti_> wilx`: what are you trying to do?
03:22:25 <basti_> btw. you could see lazy list generation/processing as consumer/producer
03:22:26 <Heffalump> anyone around with a deep understanding of GADTs?
03:22:29 <dons> or maybe just an MVar is ok for you. depends on what you're doing
03:22:51 <wilx`> I am still trying/fighting the LZW encoding :)
03:22:53 <wilx`> Lazy lists do not work for me.
03:22:54 <basti_> Heffalump: depends on the value of "deep"
03:23:06 <wilx`> Sometimes it is not possible/easy to make things tail recursive.
03:23:17 <basti_> :-o
03:23:29 <basti_> again: what are you trying to do?
03:23:49 <Heffalump> "deeper than Simon Marlow"
03:24:04 <basti_> :-o
03:24:50 <basti_> Heffalump: i don't think so no.
03:24:54 <ski> ProfTeggy : how would that look like, with multiple fields ?
03:25:01 <wilx`> To transform lazy "stream" of "commands" into "stream" of Word8s.
03:25:17 <ProfTeggy> ski,  Con :: { f1::t1, f2::t2 } -> T a
03:25:21 <basti_> wilx`: hmm
03:25:44 <ski> ProfTeggy : i think both 'Con :: {label0 :: b0} -> {label :: b1} -> T a' and 'Con :: {label0 :: b0,label :: b1} -> T a' would look a bit weird ..
03:25:45 <ProfTeggy> But hey, it's only syntax
03:25:58 <basti_> wilx`: /me slurps musasabis comonad lib
03:26:02 <dons> Heffalump, you need a type hacker
03:26:14 <ski> (latter would suggest '{label0 :: b0,label :: b1}' is a valid tyexpr)
03:26:29 <ski> basti_ : which ?
03:26:34 <wilx`> Huh, Comonads? I fear the unknown :D
03:27:23 <ProfTeggy> ski, it's a vlid tyexpr in the current proposal on autrijus' journal
03:27:24 <basti_> ski: http://www.cs.helsinki.fi/u/ekarttun/comonad/
03:27:29 <ProfTeggy> s/vlid/valid/
03:27:47 <basti_> wilx`: streams can be seen as a comonad
03:28:11 <ski> ProfTeggy : i didn't see that ..
03:28:22 <ski> stream is also a monad
03:28:59 <wilx`> *sigh*
03:29:00 <ski> s/did/do/
03:29:17 <wilx`> Why is Haskell always so hard to use?
03:29:34 <basti_> it is not!
03:29:57 <wilx`> I am so proficient with C++ but I really struggle with Haskell.
03:30:40 <basti_> wilx`: how long are you practicing now?
03:30:42 <ski> ProfTeggy : anyway .. i guess one could defend 'Con :: { f1::t1, f2::t2 } -> T a' on the grounds that 'Con :: !t1 -> T' is already allowed (iirc)
03:31:11 <ProfTeggy> yes, strictnes annotations may be thrown in
03:31:12 <wilx`> 9 months with breaks :)
03:31:14 <wilx`> But only as hobby.
03:31:23 <basti_> wilx`: what type should the result have? also stream yes?
03:31:32 <wilx`> Yup.
03:31:57 <wilx`> I want to feed it into file or something.
03:32:18 <ski> musasabi : (>>-) '-- Corresponds >> for monads'    huh ?
03:32:55 <dons> I thought it was >>=
03:34:00 <basti_> lisppaste2: @url
03:34:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:34:27 * ski thinks it corresponds to (>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
03:34:51 <lisppaste2> basti_ pasted "Stream Integer -> Stream Word8 " at http://paste.lisp.org/display/12063
03:36:13 <ski> basti_ : transform = fmap fromIntegral
03:36:38 <basti_> ski: 'kay.
03:37:30 <basti_> ah this works because it's a functor and not a co-functor.
03:37:34 <ski> m
03:37:47 <ski> actually
03:37:53 <basti_> m?
03:37:54 <ski> there aren't co-functors
03:38:02 <basti_> contravariant functor then
03:38:10 <basti_> as opposed to a covariant one
03:38:11 <ski> there are covariant functors (the usual sort) and contravariant functors
03:38:14 <ski> yah
03:38:23 <ski> easy to step on
03:38:36 <basti_> but contravariants aren't the co-version of covariants?
03:38:43 <ski> nope
03:38:50 <ski> two different uses of 'co'
03:39:18 <basti_> okay.
03:39:30 <ski> (so far as i understand, anyway)
03:39:42 <basti_> thats what i stumled across earlier... the co-version of a functor (all arrows switched) doesnt make lots of sense
03:39:44 <basti_> b
03:40:01 <basti_> programming wise at least
03:40:37 <ski> if we have a functor F : C -> D  we can get a functor F^op : C^op -> D^op
03:41:01 <basti_> yes. that would be trivial wouldn't it?
03:41:08 <basti_> i mean it wouldn't change lots for the functor
03:41:09 <ski> so (^op) is a cofunctor over the category of categories
03:41:18 <basti_> :-o
03:41:19 <ski> s/cofunctor/covariant functor/ :)
03:41:25 * basti_ laughs
03:41:48 * ski thinks it's too easy to confuse those
03:41:53 <basti_> yes, way too
03:42:04 <basti_> they should be called functors and antisense functors :P
03:42:08 <Heffalump> basti_: I sent my question to glasgow-haskell-bugs if you're interested.
03:42:26 <basti_> Heffalump: can i see that on the web?
03:42:34 <Heffalump> I think so.
03:43:22 <ski> (basti_ : (^op) just switches interpretation of which way arrows go because of the opposite categories ..)
03:44:11 * wilx` is reading...
03:44:25 <ski> (basti_ : otoh, interestingly enough, (^op) for natural transformations (or more generally, 2-morphisms in N-categories, with N >=2) seems to be contravariant)
03:44:48 <basti_> Heffalump: there is a GADT post http://www.haskell.org//pipermail/glasgow-haskell-bugs/2005-September/005530.html but the names dont match
03:45:07 <dons> @where+ glasgow-haskell-users http://www.haskell.org/pipermail/glasgow-haskell-users/
03:45:08 <lambdabot> glasgow-haskell-users ~> http://www.haskell.org/pipermail/glasgow-
03:45:08 <lambdabot> haskell-users/
03:45:37 <basti_> ski: first line: yes, second line: uhm?
03:45:39 <dons> @where+ cvs-ghc http://www.haskell.org/pipermail/cvs-ghc/
03:45:40 <lambdabot> cvs-ghc ~> http://www.haskell.org/pipermail/cvs-ghc/
03:45:51 <Heffalump> my C+P is broken, but try 005597.html
03:48:59 <basti_> Heffalump: i didnt even know that you can do that sort of stuff in haskell, but it's certainly surprising
03:50:16 <ski> basti_ : N-categories are generalization of categories .. the canonical example of a 2-Category is Cat. objects (0-morphisms) are categories. (1-)morphisms are functors. 2-morphisms are natural transformations.  (e.g. http://math.ucr.edu/home/baez/categories.html has some info, mixed with some physics)
03:51:29 <basti_> ski: as in "order of logic"?
03:51:57 <ski> 'order' ?
03:52:03 <knobo> I'm a very newbie, trying something very simple, that I don't understand? Can I get some short guidence?
03:52:13 <knobo>    time <- getClockTime
03:52:13 <knobo>    putStrLn time
03:52:30 <ski> putStrLn only prints strings
03:52:35 <ski> try with print
03:52:39 <ski> @type putStrLn
03:52:47 <lambdabot> String -> IO ()
03:52:48 <ski> @type print
03:52:50 <lambdabot> forall a. (Show a) => a -> IO ()
03:53:09 <ski> print can show any Show-able value
03:53:49 <ski> (also, if you use print on a string, it prints '"' around the string and also escapes characters .. not so with putStr and putStrLn)
03:54:07 <ski> knobo : does that work ?
03:54:29 <ski> basti_ : what do you mean by "order of logic" ?
03:56:15 <basti_> ski: i mean, n-categories are "orders" of catagories, just as logic has propositional logic, predicate logic, 2nd order logic etc.
03:56:29 <basti_> [the connection probably not being as arbitary as it might sound]
03:56:31 <ski> a bit, i think
03:56:40 <knobo> ski: print worked
03:56:41 <ski> possibly
03:56:46 <ski> knobo : good
03:57:32 <knobo> I have read more than hundred pages of the yet another haskel tutorial..
03:57:41 <knobo> I allso need some practice
03:57:55 <basti_> ski: there is a deep connection between programming, logic and CT
03:57:59 <ski> (basti_ : an N-category can be lifted into an (N+1)-category)
03:58:01 <knobo> haskell is really fun :)
03:58:13 <basti_> (of course)
03:58:14 <knobo> s/fun/interesting/
03:58:22 <basti_> knobo: it's both.
03:58:24 <ski> basti_ : between prog and logic, surely
03:58:25 <knobo> yes
03:58:43 <ski> basti_ : and CT is connected to many things
03:58:49 <basti_> ski: i was thinking curry-howard isomorphism
03:59:22 <ski> (basti_ : e.g. Cartesian Closed Categories corresponds to simply-typed lambda calculus)
03:59:29 <ski> basti_ : ah, yes
03:59:30 * basti_ nodnodnods
03:59:37 <ski> ;)
04:00:09 <basti_> if i just had heard about this stuff when i was 12
04:00:27 <ski> hehe
04:00:52 <basti_> honestly, first time i heard a good explanation of the lambda calculus when i was 21 or something#
04:02:40 <ski> what do you mean by good explanation ?
04:02:57 <basti_> like "look, you can do calculations like THAT too"
04:03:16 <basti_> not like "uhm lambda calculus, thats a very bizarre and obscure thing that nobody really knows about"
04:04:41 * ski learned lambda calculus on his own
04:05:21 <ski> found some papers that mentioned it, i think ..  then found some sites explaining
04:05:40 <basti_> i never really thought that it could have to do with computing
04:05:49 <basti_> until i read "lambda" in some lisp code
04:05:50 * ski is not actually sure how he started reading papers ..
04:05:52 <basti_> which i didnt understand though
04:06:32 <basti_> but then there was a lecture where the lecturer explained it in a single session, together with the theorem about the Paradox operator and i was like "uhm, wow"
04:06:33 <ski> m, i think i read the 'lamdba the ultimate ..' papers quite early
04:10:16 <basti_> that link is really cool
04:10:22 <basti_> the category of tangles, wowzie!
04:10:22 <basti_> :D
04:10:39 <ski> yeah, baez is cool
04:11:05 <ski> (i hope you've seen his 'this weeks finds in mathematical physics' sometime)
04:11:26 <basti_> no
04:12:35 <basti_> now i am
04:14:43 <ski> see e.g. http://math.ucr.edu/home/baez/week202.html about 'golden object' :)
04:15:15 <ski> (relating golden number with an object in a category)
04:15:35 * beelsebob_ prods paul wherever he is
04:15:39 <Jibbler> :)
04:15:40 <ski> (more or less, the objects 'cardinality' is, in some sense, the golden number :)
04:16:00 <beelsebob_> @eval map (\x -> '?') [1..]
04:16:06 <lambdabot> "????????????????????????????????????????????????????????????????????
04:16:06 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:06 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:06 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:06 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:08 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:10 <lambdabot> ?????????????????????????????????????????????????????????????????????
04:16:12 <lambdabot> [23 @more lines]
04:16:15 <beelsebob_> see jibbler?
04:16:16 <basti_> ski: very, very strange.
04:16:21 <ski> hehe
04:17:12 <ski> (s/objects/object's/)
04:22:19 <beelsebob_> interesting... friend of mine has overridden () in C++ to end up with a functional style version that lets you do fun stuff like CPS
04:23:50 <ski> (basti_ : .. e.g. with "T = 1 + T^2" defining binary trees, we can get a nice iso "T^7 = T" ..)
04:25:10 <maayhme> beelsebob_, ur talking about c++ functors or just () overriding ?
04:25:14 <maayhme> overloading, even
04:25:19 <basti_> ski: i'm at that point just right now
04:27:23 <basti_> ski: but thats obvious isnt it? you can just take any binary tree with 7 ends, and put a tree on one of these 7 ends?
04:27:40 <basti_> of course you'll be multiplying your guts out if you try to do that algebraically
04:28:06 <basti_> oh but its supposed to be bijectiv
04:28:09 <basti_> yes thats harder.
04:28:18 <ski> yes, iso
04:46:21 <dcoutts> davve, I see you've added yourself to the list on the hIDE wiki :-)
04:46:36 <dcoutts> davve, what aspects are you interested in working on?
04:46:53 * dcoutts is hoping to recruit someone to help him with UI issues
04:53:26 <Lemmih> *sigh*
04:53:32 <Lemmih> ghc-api is buggy.
04:54:14 <Lemmih> It doesn't get any instances from the interface files.
04:55:43 <dcoutts> :-(
04:59:01 <dcoutts> :-) the Haste project write up says nice things about Gtk2Hs
05:00:39 <aleator> dcoutts: what's the easy gtk2hs approach for rich text? mozembed?
05:01:02 <dcoutts> aleator, it depends how rich you want and if you want it to be editable
05:01:20 <aleator> Non editable, simple formatting and pictures.
05:01:31 <dcoutts> the text view widget can do colour, fonts, sizes, pictures, justification
05:01:45 <dcoutts> you can make it non-editable
05:02:01 <aleator> Ah! I thought there was something better. Thanks.
05:02:30 <dcoutts> but the api for controlling all that is a little tricky, there's no markup language for example
05:03:17 <dcoutts> you have to add markers to the text buffer which control the attributes of the text
05:03:38 * aleator looks..
05:03:45 <dcoutts> currently the best example of doing that from Haskell is Lemmih's syntax highliting code in hIDE
05:04:29 <dcoutts> what is your source/input for the rich text?
05:05:28 <aleator> Well. I'm just fantasizing of making ghci-like tool that would actually display Images as instead of errors of non-existant show instances :)
05:05:46 <aleator> +images
05:06:06 <dcoutts> aleator, ah, you've seen Proxima?
05:06:13 <dcoutts> @where Proxima
05:06:13 <lambdabot> I know nothing about proxima.
05:06:22 <dcoutts> err
05:06:35 <dcoutts> oops I mean "Pivotal"
05:06:37 <dcoutts> @where Pivotal
05:06:38 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal
05:06:43 <dcoutts> yes, that one
05:06:48 <aleator> Yes. That was the source of my inspiration.
05:06:53 <dcoutts> it has a Display class
05:07:06 <aleator> Is it available anywhere?
05:07:17 <dcoutts> not sure, ask the authors
05:07:55 <dcoutts> the simplest way to hack something together I reckon would be to use a seperate window for displaying graphical output from withing ghci
05:08:06 <aleator> There is one thing that makes my idea lot simpler than pivotal. Pivotal transcripts seem to be updateable.
05:08:26 <dcoutts> yes it's a cool idea, but makes it harder
05:08:28 <dcoutts> gtk2hs should work fine for that in ghci
05:08:31 <aleator> I have that. Or. I need to say "display" to ghci.
05:08:55 <b0gg1e> hello espia!
05:09:00 <b0gg1e> oops wrong channel.
05:09:09 <b0gg1e> hello to everybody anyways.
05:09:44 <dcoutts> aleator, yes you might need to say: display $ ...
05:10:11 <dcoutts> otherwise you'd need to hack ghci to automagically recognise things in the Display class, just like it does for the Show class
05:10:26 <aleator> But I thought it would be fun not to say it, and hack ghci.
05:10:46 <dcoutts> yeah it would
05:10:53 <aleator> Or rather.. Wait for ghc-api that allows some easier ghci like hacking.
05:10:55 <dcoutts> with the new ghc api you could do that
05:10:57 <dcoutts> yep
05:11:23 <adept> shapr: ayt?
05:11:34 <dcoutts> however I'm not sure the textview would be so good for that, it can do inline images but it's not great at doing that
05:11:43 <aleator> How so?
05:11:46 <adept> @seen shapr
05:11:48 <lambdabot> shapr is in #haskell-blah, #unicycling and #haskell. Last spoke 1
05:11:48 <lambdabot> hour, 11 minutes and 42 seconds ago.
05:11:56 <autrijus> ProfTeggy: re the -> syntax, we considered it
05:12:03 <autrijus> ProfTeggy: but the :: syntax is more close to the actual type
05:12:14 <autrijus> "Con {...}" _indeed_ has the type
05:12:20 <autrijus> so the :: reads out better
05:12:33 <autrijus> but anyway... there are more language extensions I'm hacking in!
05:12:37 <davve> dcoutts, hmm.. i'm interested in working with intellisense/integrated documentation stuff
05:12:41 <aleator> QT had some really neat way of doing that. Using html tags. So I thought I could cheat with embedded mozilla..
05:12:50 <dcoutts> aleator, I had a feeling it put them inline rather than on their own line, but you could probably get around that
05:12:52 <autrijus> data T = forall b. C { x :: b, f :: b -> Int }
05:13:00 <autrijus> this is legal in the ghc on my laptop :D
05:13:06 <autrijus> as is its GADT counterpart.
05:13:22 <ski> good
05:13:42 <dcoutts> aleator, yes, an embeded mozilla is another option but that's probably even harder since it all has to go via html text
05:13:56 <autrijus> data T a where forall a b. C { x :: a, y :: b, fy :: b -> Int } :: T a
05:13:56 <ski> <ski> i think that syntax looks fine, yes
05:13:56 <davve> dcoutts, gotta go shop some food now, bbl
05:14:06 <dcoutts> davve, ah ok, you'll want to look at Lemmih's CommonSense stuff
05:14:16 <davve> okay.. cool module name
05:14:19 <ski> <ski> what what the issue ccshan and oleg mentioned ?
05:14:20 <dcoutts> davve, ok, we can talk later then
05:14:21 <autrijus> that will make writing "objects" in haskell much easier
05:14:26 <dcoutts> heh yeah :-)
05:14:30 <ski> <ski> something when a repeated selector has differing result types .. i guess
05:14:34 <ski> <ski> autrijus : isn't it rather something like .. the types of the fields of the repeated selector must be same ?
05:14:34 <autrijus> the "x" will be a "public property"
05:14:45 <autrijus> and the "y" and "fy" is "private property"
05:14:55 <dcoutts> davve, with all your Haste GUI hacking I was hoping you might help me with that :-)
05:15:00 <aleator> dcoutts: I see the problem of having images going through files, but otherwise I don't see real difficulty
05:15:01 <autrijus> ski: sure, that is already a given
05:15:19 <autrijus> ski: oleg's concern is that selectors will behave like irrefutable patterns and undermine soundness. it turns out to be not the case; we are sound.
05:15:43 <autrijus> ski: GHC currently does not allow mixing forall and record syntax
05:15:50 <autrijus> because that makes selector functions contain escaped tyvars
05:16:04 <ski> hm .. yes
05:16:07 <autrijus> but I don't think that's very natural
05:16:12 <autrijus> so spj worked out a compromise
05:16:27 <autrijus> if the tyvar is mentioned in GADT's result type, then it doesn't escape, so we allow it
05:16:38 <ski> m
05:16:41 <autrijus> if it's not mentioned, or if it's vanilla, then we allow the constructor and case-matching form
05:16:51 <autrijus> but if you use the selector as a function, it's a compile time error
05:16:58 <autrijus> with suitable error message
05:17:02 <autrijus> I think that's Good Enough (tm)
05:17:04 <ski> because no 'exists'-types
05:17:07 <autrijus> yeah
05:17:27 <autrijus> but casing over it is fine
05:17:34 <ski> m
05:18:06 <ski> (just so long as the unknown type doesn't escape)
05:18:06 <autrijus> blah (C { method = f, private = x }) -> f x
05:18:15 <autrijus> is well typed
05:18:18 <ski> m
05:18:38 <autrijus> so it's a straightforward generalisation to prefix constructors
05:18:48 <autrijus> bringing them to record types, and then to GADTs
05:20:41 <ProfTeggy> autrijus, indeed, the _application_ Con { ...} of the constructor Con has that type.
05:20:57 <Heffalump> where does unsafeCoerce live?
05:21:27 * Heffalump forgets the command for asking lambdabot
05:21:38 <autrijus> GHC.Exts  surely?
05:22:04 <ski> (autrijus : i did not understand the issue about irrefutable patterns ..)
05:22:32 <autrijus> ProfTeggy: it's mostly that (data F where Con { x :: Int } -> String) doesn't seem to associate String to Con
05:22:37 <autrijus> ProfTeggy: but it's a matter of taste
05:23:00 <ProfTeggy> autrijus, I can see your point
05:23:03 <Heffalump> autrijus: ah, apparently so
05:23:04 <autrijus> er, I mean (data F x) and (F String)
05:23:55 <autrijus> ski: data T x where
05:23:55 <autrijus>     CUnit :: T ()
05:23:55 <autrijus>     CInt  :: T Int
05:23:55 <autrijus> let ~CInt = CUnit in ...
05:24:16 <autrijus> and then abuse the poor wobbly
05:25:09 <autrijus> (it gets more interesting when you are taking parameters)
05:25:17 <ski> together with some other value of type  'T2 x' ?
05:25:23 <autrijus> yeah
05:25:26 <autrijus> it's easy to unsafeCoerce# with this idea
05:25:35 <ski> (forcing 'x' to be 'Int')
05:25:38 <autrijus> yup
05:26:00 <autrijus> let ~CInt c = CUnit () in ...
05:26:20 <ski> possibly irrefutable pattern should not refine the args of T ..
05:26:32 <autrijus> anyway, spj ruled irrefutables are verboten on gadt.
05:26:38 <ski> heh
05:26:53 <autrijus> which made oleg unhappy, as now the G in GADT is seriously in trouble
05:27:06 <Heffalump> oh, why?
05:27:06 <autrijus> it's more like "Specialized" ADT in that regard ;)
05:27:20 <autrijus> Heffalump: because there are operations you can use on vanilla that can't be done on gadt.
05:27:27 <ski> uncomparable ADT .. UADT
05:27:43 <autrijus> I have never used irrefutables, so I can't share his feeling
05:27:53 <davve> dcoutts, actually, it was kolmodin who did the intellisense stuff.. but we talked alot about it both of us
05:29:25 <ski> autrijus : so there were no counter-proposal that oleg felt more happy with ?
05:29:35 <dcoutts> davve, right
05:29:47 <autrijus> ski: no... apparently wobbliness is just not happy with irrefutable
05:30:19 <Heffalump> is there a easy summary of what wobbliness is?
05:30:23 <ski> autrijus : i wonder if refining types of args of the data con. but not refining the tyargs of the GADT tycon would work ..
05:30:30 <dcoutts> davve, well Lemmih is the one to talk to about those issues in hIDE
05:30:57 <autrijus> Heffalump: "types with a hole in it that is to be supplied by the user somewhere else", iirc
05:31:12 <davve> dcoutts, yep
05:31:31 <autrijus> Heffalump: http://cristal.inria.fr/~fpottier/publis/pottier-regis-gianas-05.pdf
05:31:45 <ski> (autrijus : the hole being the specializable tyargs in GADT ?)
05:32:25 <dcoutts> davve, and if you want to make a dockable UI then you can come work with me on that :-)
05:33:31 <dcoutts> for the moment I'm not makeing it dockable. But the model I'm building should fit a dockable ui too if someone were to make one.
05:50:48 * autrijus goes back to hacking with spj...&
05:55:52 <Lemmih> Hi Oejet.
05:56:02 <Oejet> Lemmih: Hej.
06:03:48 <davve> dcoutts, okay.. too bad the docking widget in libegg isn't cross platform yet
06:06:43 <dcoutts> davve, actualy it is cross platform now
06:06:55 <dcoutts> it's been fixed to run on win32
06:07:00 <xerox> Yo.
06:07:06 <dcoutts> hia xerox
06:07:27 <xerox> I read the stm paper this morning - _very_ understandable.
06:07:36 <davve> dcoutts, really? that's great :)
06:07:53 <dcoutts> davve, time to get hacking then :-)
06:08:08 <dcoutts> davve, though have you still got exams to do?
06:08:16 <davve> dcoutts, yep..
06:08:16 <SM_ax> xerox, which one?
06:08:21 <dcoutts> :-(
06:08:26 <davve> dcoutts, unfortunately school is quite overwhelming atm
06:08:34 <davve> but it allways is I guess =)
06:09:00 <dcoutts> davve, well when they're over you and kolmodin can come help out with hIDE, since you've both hot a great deal of experience
06:09:16 <dcoutts> hot/got
06:12:01 <davve> davve, sure
06:12:05 <davve> dcoutts, sure
06:12:06 <davve> :D
06:13:32 <davve> dcoutts, btw.. that CommonSense module.. it's not in the darcs repository right?
06:13:47 <dcoutts> davve, not yet I think, ask Lemmih about it
06:13:48 <Lemmih> It's all in my mind.
06:13:53 <davve> oh =)
06:13:55 <dcoutts> :-)
06:14:24 <dcoutts> Lemmih, but you've got something working, we saw the pic! :-)
06:14:27 <Lemmih> Gonna iron out some details about syn-hl'ing and typechecking first.
06:14:36 <dcoutts> np
06:15:54 <shapr> adept: pong
06:16:08 <Lemmih> But loading 6.4 interface files has proven to be a bit more complicated than I initially hoped.
06:17:46 <dcoutts> Lemmih, that's the classes problem?
06:18:12 <dcoutts> is that because of changes in the format between 6.4 & 6.5?
06:19:33 <Lemmih> Yeah.
06:20:12 <dcoutts> Lemmih, you're convinced it's not going to be easier to use a 6.5 snapshot?
06:21:15 <dons> look, I think needing 6. 5 is ok.
06:21:33 <Lemmih> Using a 6.5 snapshot would definitely be easier but then we would lose the ability to load it at runtime and not have access to 6.4 libraries.
06:21:41 <dons> 6.6 will be out by the time this whole thing is stable and good
06:21:49 <dcoutts> dons, true
06:21:53 <dons> so any code written for 6.4 compat will be obsolete.
06:22:30 <dons> i mean, Lemmih, if you want to do it, that's fine. but you could probably use your talents on other more fun things :)
06:22:53 <dcoutts> Lemmih, it could still be loaded at runtime couldn't it? if the whole hIDE were build using ghc-6.5
06:22:54 <dons> esp since your developer budget is so low. we don't want to waste time on anything we don't need to
06:23:00 <dons> s/your/our/
06:23:52 <dcoutts> if we could just pick a recent and reasonalby stable 6.5 snapshot and all say we're going to use that for hIDE development that'd work
06:24:15 <dcoutts> we'd have to specify which snapshot exactly
06:24:26 <dons> I'm using Sep 17
06:24:32 <Lemmih> I fear another 12 months could pass before we see 6.6.
06:24:34 <ozone> dons: is wolfgang at ICFP?
06:24:36 <dons> but we could pick, say Oct 1.
06:24:39 <dons> ozone, yep.
06:24:45 <ozone> dons: say hi to him from me
06:24:45 <dons> had lunch with him the past few days
06:24:50 <dons> will do.
06:24:57 <ozone> does he have a beard?
06:25:02 <dcoutts> Lemmih, JaffaCake recokened on a "few" months, so I think that probably means 3 or 4
06:25:03 <dons> Lemmih, yeah, I'd say 6 months t leasst
06:25:04 <musasabi> Are there concrete plans on where to keep the #haskell-meet?
06:25:17 <dons> ozone, nope.
06:25:23 <ozone> dons: good good
06:26:16 <dcoutts> Lemmih, dons: shall we all try the sept 17 snapshot then?
06:26:17 <dons> Lemmih, but really, how long before hIDE 1.0? 6 months?
06:26:31 <dons> dcoutts, or just pick, say, Oct 1.
06:26:37 <dons> nice and round :)
06:26:38 <dcoutts> dons, that seems a reasonabl estimate
06:27:01 <Lemmih> dons: Can we get around the RTS issues by statically the ghc package to the main app and not pass functions through the dynamic app?
06:27:02 <dcoutts> dons, though something not in the future would be helpful for Lemmih :-)
06:27:18 <dcoutts> Lemmih, could do possibly, but it's not nice
06:27:42 <dons> Lemmih, possibly.
06:28:01 <dons> they could still be passed though, couldn't tey?/
06:28:31 <Lemmih> That would be _really_ annoying.
06:28:57 <dons> yeah?
06:29:05 <dons> maybe i misunderstand what you mean.
06:29:06 <Lemmih> Plugins wouldn't even be allowed to use the types from the GHC package, right?
06:29:28 * dcoutts votes for using a 6.5 snapshot
06:29:41 <Lemmih> (since they aren't allowed to have the ghc package in their build-depends)
06:29:58 <dons> ah. hmm.
06:30:16 <dcoutts> Lemmih, wouldn't it be much easier for you to use 6.5?
06:30:28 <Lemmih> dcoutts: We can't load it at runtime.
06:30:34 <dcoutts> why?
06:30:39 <dons> so you'd have to pass the  ghc pkg functions in a data sructure. and perhaps need Typeable if you need types for some reason.
06:30:57 <Lemmih> dcoutts: It refers to symbols in the RTS which the linker is unaware of.
06:31:01 <dons> a la passing linker fuctions innthe dynamic applications paper.
06:31:13 <dcoutts> Lemmih, then ask JaffaCake to fix it in ghc
06:31:30 <dons> yeah. lets just fix the symbols.
06:31:36 <dons> and use the first ghc that has the fix
06:31:45 <Lemmih> @seen JaffaCake
06:31:45 <dons> making sure it gets into 6.6
06:31:46 <lambdabot> I saw JaffaCake leaving #haskell 5 days, 22 hours, 32 minutes and 10
06:31:46 <lambdabot> seconds ago, and I have missed 1 minute and 49 seconds since then.
06:31:58 <dons> we'ved added symbols for dyn linking before
06:32:01 <dons> it's no big issue
06:32:03 <dcoutts> Lemmih, in the mean time we can fix it by patching it, it's just a list in Linker.c
06:32:16 <dons> right, that's the issue isn't it Lemmih?
06:32:19 <dons> are there others?
06:32:50 <Lemmih> Nope.
06:32:56 <dons> well, that's trivial then.
06:32:57 <dcoutts> great :-)
06:33:06 <dons> no need for complicated solutions.
06:33:30 <dons> just update the RTS_SYMBOLS  in Linker.c, I think
06:33:53 <aleator> dcoutts: Tried the textview. Rather verbose but nearly works. How do I keep the textview widget from expanding over other widgets in the vbox?
06:34:13 <dcoutts> Lemmih, so pick a snapshot, patch it and then tell us what the snapshot & patch are so we can do the same
06:34:30 <dons> and I can commit the patch once we run it past JaffaCake.
06:34:31 <dcoutts> aleator, put it in a scrolled window
06:34:57 <aleator> Ah. Ok. Thanks.
06:35:00 <dons> Lemmih, does this sound ok?
06:35:04 <Lemmih> Sure.
06:35:09 <dcoutts> yay
06:35:57 <dcoutts> I'll fix the build script to use the ghc-6.5 rather than the system ghc once we've picked a snapshot
06:36:40 <dcoutts> ie I'm assuming we'd have a parallel install of ghc-6.5 but it would not necessarily be the default
06:49:30 <wagerlabs> folks, how would i use fast packed strings with a socket?
06:49:35 <wagerlabs> to read/write binary data
06:49:51 <dons> hmm.
06:50:11 <dons> write a function :: FastString -> Socket -> IO ()
06:50:36 <dons> it unwraps the Ptr from the packedstring, and then writes that ptr out to the socket.
06:50:41 <wagerlabs> adding things to a FPS byte by byte?
06:50:45 <musasabi> wagerlabs: use the Ptr unwrapping technique.
06:50:46 <dons> seems doable if you can find a network function that will write from a Ptr
06:51:04 * wagerlabs does not know about the Ptr unwrapping technique
06:51:10 <musasabi> The next version of network-alt should add support for FastPackedStrings.
06:51:16 <dons> cool :)
06:51:24 <wagerlabs> but i do see hGet and hPut
06:51:37 <wagerlabs> as well as hGetContents in the FPS module
06:51:39 <dons> wagerlabs, append? cons? for adding byte by bte  to a packed string.
06:51:50 <shapr> wagerlabs: finns ocks√• #haskell.se om du vill tala svenska
06:52:03 <musasabi> dons: it is only <50 lines of code - the only hard part is the autoconf test and testing on different platforms.
06:52:09 <shapr> Not that my swedish is that great...
06:52:11 <wagerlabs> shapr: my swedish courses don't start for a month or so :D
06:52:18 <shapr> Oh, where are you from?
06:52:20 <musasabi> and I already have that code ready in a separate location.
06:52:27 <wagerlabs> shapr: but i do speak very good english ;P
06:52:29 <shapr> wagerlabs: I know you're in stockholm...
06:52:32 <Lemmih> shapr: Maa man tale dansk der?
06:52:38 <shapr> ikke!
06:52:39 <wagerlabs> shapr: i am but i do not speak swedish yet
06:52:55 <shapr> wagerlabs: My english is as good as any from Alabama...
06:52:58 <dons> musasabi, right. cool.  also, I haven't added toForeignPtr and fromForeignPtr yet.
06:53:07 <dons> which may be useful
06:53:30 <dons> though there's enough other ways to eliminate a FastString that it's probably ok
06:53:33 <wagerlabs> so since hGet, hPut and hGetContents are supported by FPS shouldn't I be using these with a Handle returned by the socket?
06:53:39 <musasabi> dons: my code uses the Ptr functions (and reading will use generate).
06:54:08 * Lemmih mumbles some very unpleasant words about CVS.
06:54:13 * wagerlabs is looking at the hws-wp source code
06:54:22 * autrijus purrs
06:54:38 <shapr> wagerlabs: Hws-wp is old and unsupported. Peter Thiemann wrote a version that uses hs-plugins.
06:54:39 * musasabi packs things for haskell-workshop
06:55:20 <wagerlabs> shapr: i'm looking at that one or something like that... i think
06:55:27 <shapr> wagerlabs: You probably want to start with Simon Marlow's hws directly from fptools.
06:55:28 <wagerlabs> shapr: but i'm just reading the code
06:55:32 <shapr> ok
06:55:43 <wagerlabs> i got the whole shebang from scanedinavian
06:55:54 <shapr> There's a nice research paper that goes with the original hws.
06:55:58 <shapr> Oh, I've heard of scanedinavian ;-)
06:56:06 <wagerlabs> shapr: and i read that paper
06:56:08 <wagerlabs> (sock', addr) <- Network.Socket.accept sock
06:56:15 <shapr> wagerlabs: oh excellent!
06:56:16 <wagerlabs>  handle <- socketToHandle sock' ReadWriteMode
06:56:22 <wagerlabs> return (handle,addr)
06:56:33 <dons> musasabi, wifi coverage here is great, so pack your laptop if you've got one!
06:56:36 <wagerlabs> now i need to go and find out what hGet, hPut and hGetContents do :)
06:56:38 <shapr> wagerlabs: Anyway, I'm the ScannedInAvian.
06:56:46 <wagerlabs> shapr: hehe
06:57:04 <shapr> Speaking of which, see the new logo from last night: http://www.scannedinavian.com/images/ScannedInAvian.png
06:57:27 <wagerlabs> so should i be using hGet, hPut and hGetContents with FPS and a socket handle?
06:57:41 <dons> well, are you reading or writing?
06:57:49 <wagerlabs> both
06:58:07 <wagerlabs> i've got this delphi app that serializes its object tree to the socket and reads it back on the other side
06:58:08 <dons> my guess, hGet hPut. but try it out.
06:58:14 <wagerlabs> client and server are both delphi
06:58:26 <dons> shapr, hehehe!
06:58:27 <wagerlabs> and the packets are obviously huge
06:59:05 <wagerlabs> i'm trying to write an adapter that would read this huge packet, translate it into a series of smaller ones and feed them to a different (newer) server that talks a completely different protocol.
06:59:29 <dons> seems reasonable. are you sure you need packed strings though?
06:59:43 <dons> not that they aren't nice and easy these days :)
06:59:51 <wagerlabs> i would also be maintaining state for each connection (they are long-lived, it's a poker server) and on the way to the delphi side assembling the big packet from smaller ones that arrive asynchronously
07:00:15 <wagerlabs> dons: i don't need fps and i could do the whole thing in erlang. i just want to try it with haskell and it seems like fps are nice and fast
07:00:34 <dons> yep. ok.
07:00:46 <dons> remember that Haskell is the language of choice for discriminating hackers ;)
07:00:53 <wagerlabs> are there ssl sockets for haskell?
07:01:04 <musasabi> wagerlabs: yes.
07:01:05 <wagerlabs> yeah, right! the cops and robbers
07:01:07 <dons> so good for those who want stable, correct, running software in short time ;)
07:01:08 <musasabi> @where hsgnutls
07:01:09 <lambdabot> I know nothing about hsgnutls.
07:01:25 <musasabi> @where+ hsgnutls http://www.cs.helsinki.fi/u/ekarttun/hsgnutls
07:01:26 <lambdabot> hsgnutls ~> http://www.cs.helsinki.fi/u/ekarttun/hsgnutls
07:01:40 <wagerlabs> dons: of course!
07:01:56 <wagerlabs> i got this interesting project pipeline and i'm not restricted in any way in my choice of language
07:02:19 <dcoutts> musasabi, that's yet anothr package with an attributes api, we really need to standardise it
07:02:40 <ski> musasabi : (>>-) '-- Corresponds >> for monads'    huh ?
07:03:06 <wagerlabs> i need to do this big packet <-> small packet adapter, a simulation environment that puts a huge load on a poker server by running a bunch of intelligent agents (umm... bots :D) and this app that optimizes the revenue from a poker table by evaluating which variables have the most effect on it
07:03:23 <wagerlabs> so i want to do something simple (adapter) in haskell first
07:03:40 <wagerlabs> and, yes, i could hack everything but the optimization bit in erlang
07:04:25 <wagerlabs> but haskell wooes me
07:07:23 <shapr> The first lambda comes free, man.
07:07:26 * shapr tokes on a lambda
07:07:30 <wagerlabs> hehe
07:07:47 <ski> hi esap
07:07:48 <shapr> hei esap!
07:08:04 <esap> hi!
07:08:08 * wagerlabs wants to do game dev in haskell
07:08:12 <esap> what's up?
07:08:33 <ski> musasabi : ping
07:08:33 * esap has done nothing in the last two weeks :-)
07:09:06 * ski wants to question musasabi about his comonad code :)
07:10:27 <dons> nibro!
07:10:31 <dons> you in Tallinn?
07:10:40 <nibro> yes, just arrived here :)
07:10:46 <shapr> wagerlabs: me too
07:10:48 <dons> ah ha, explains why I hadn't spotted you yet.
07:11:05 <nibro> I couldn't attend ICFP :(
07:11:11 <nibro> but HW is a must :)
07:11:26 <wagerlabs> shapr: it's not difficult actually. i think you can take Torque /www.garagegames.com/ and plug in Haskell via hs-plugins
07:11:30 <Heffalump> how come you could do one but not the other?
07:11:41 <wagerlabs> i wouldn't want to do a game engine in haskell
07:11:45 <dons> hmm. nibro. you in one of the Reval hotels?
07:11:57 <dons> that ip address looks familiar
07:12:09 <nibro> Heffalump: because HW is a lot shorter?
07:12:23 <nibro> dons: aye, Reval Express
07:12:33 <dons> ah ha! me too :)
07:12:46 <nibro> hehe, go figure :)
07:13:10 <wagerlabs> dons: re: your quesiton on whether i really need to use fps... what do you suggest? using regular lists?
07:13:16 <dons> nibro, it's good, we're about 5 mins from the conference. you go in through the main gates
07:13:43 <dons> wagerlabs, yeah. just wondering if you were optimising prematurely.
07:13:53 <nibro> dons: been there already, had to grab my proceedings and all that :)
07:13:57 <wagerlabs> dons: by all means :-) not necessary
07:14:19 <shapr> wagerlabs: I'd rather wrap the now OSS q3.
07:14:44 <Heffalump> nibro: I guess. Usually my problem with going places is just being able to go at all, not the length of the trip.
07:14:51 <wagerlabs> shapr: interesting idea :-) i'm not into fps i guess
07:14:55 <wagerlabs> dons: i want to use this http://www.mail-archive.com/haskell-cafe@haskell.org/msg09413.html
07:15:03 <shapr> wagerlabs: Neither am I, but have you seen ufo:ai ?
07:15:03 <wagerlabs> dons: i like cale's idea
07:15:47 <wagerlabs> shapr: no. is that a quake npc or something?
07:15:59 <wagerlabs> shapr: what's there to see? is it particularly awesome?
07:16:21 <shapr> It is really cool, but it's turn-based strategy using the Q2 engine.
07:16:22 <nibro> Heffalump: well, I have a paper accepted for HW, so getting the funding wasn't all difficult. I could have gone to ICFP as well, only "family matters" came in the way...
07:16:37 <dons> Lemmih, dcoutts, do we have a nice screenshot of hIDE  (pref. with syn hl and typing on) that I could use as a little hint of where the dynamic architecture is heading ?
07:16:44 <shapr> wagerlabs: So I figure real time strategy is also workable with a quake engine.
07:17:06 <nibro> dons: you too polishing your presentation? :-)
07:17:11 <wagerlabs> shapr: wait, but what's ufo:ai? should i google for ufo or something?
07:17:13 <dons> of course :)
07:17:17 <shapr> I have to go buy a pump for my unicycle, but I'd like to discuss Haskell game-dev later.
07:17:18 <nibro> shapr: you talking RTS in haskell?
07:17:27 <wagerlabs> he
07:17:30 <shapr> wagerlabs: http://ufo.myexp.de/
07:17:32 <dons> hehe. for the dynamic haskell session nibro ;)
07:17:33 <wagerlabs> shapr: good luck!
07:17:36 <shapr> nibro: I am, but gotta go
07:18:26 <musasabi> 5min till a new version of network-alt with fps support.
07:18:54 <ski> musasabi : ping
07:19:02 <nibro> dons: aye, dynamic haskell is the future! ;-)
07:19:17 <wagerlabs> musasabi: what's network-alt?
07:19:37 <dons> yay :)
07:22:03 <musasabi> ski: pong
07:22:14 <musasabi> dons: When building fps:
07:22:15 <musasabi> Compiling Data.FastPackedString ( ./Data/FastPackedString.hs, dist/build/./Data/FastPackedString.o )
07:22:17 <dcoutts> dons, not at the moment since the yi window is not part of the ide shell window yet
07:22:18 <musasabi> ./Data/FastPackedString.hs:285:16: Parse error in pattern
07:22:24 <ski> musasabi : (>>-) '-- Corresponds >> for monads'    huh ?
07:22:26 <Lemmih> dons: Something special you want to see?
07:23:00 <musasabi> ski: in the use with e.g. StateW it works like >> works for monads.
07:23:09 <dcoutts> dons, we've currently got pics of the ideshell, and seperate pics of the Yi with syn hl + semantic errors underlined
07:23:12 <nibro> dons: I read your paper, looks very nice, hsp(r) could use some of that to avoid loading lots of stuff twice...
07:23:14 <musasabi> ski: but yes in general that is quite different.
07:23:29 <dons> musasabi? hmm. no -fglasgow-exts?
07:23:32 <wagerlabs> musasabi: so what is network-alt?
07:23:34 <musasabi> wagerlabs: alternative networking library.
07:23:36 <wagerlabs> ah
07:23:42 <dons> Lemmih, just something flashy ;)
07:23:43 <wagerlabs> musasabi: and the benefits?
07:23:57 <dons> dcoutts, ok. maybe I can take those two and show them.
07:24:05 <ski> musasabi : i would have thought that (>>-) corresponded to (>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
07:24:17 <dons> nibro, yeah. and also update hsp(r) on the fly..
07:24:26 <Lemmih> dons: http://212.242.49.100/typechecking.png
07:24:34 <musasabi> dons: seems the fps.cabal.no-mmap is broken.
07:24:50 <dons> ok. darcs record ; darcs send ;)
07:25:02 <Lemmih> Hi nibro.
07:25:11 <dons> (I must admit .no-mmap doesn't get tested very often)
07:25:14 <nibro> dons: indeed, a very useful feature in a web server
07:25:26 <nibro> Lemmih: hullo there, you in for the HW too? :-)
07:25:31 <musasabi> wagerlabs: cleaner api, better performance.
07:25:49 <wagerlabs> musasabi: can i use it now to write a network server?
07:25:54 <dons> dcoutts, what's the best ide picture we have?
07:25:55 <Lemmih> nibro: I wish! I'm stuck in Denmark.
07:26:27 <dcoutts> dons, this one http://haskell.org/~duncan/hIDE/hIDE.png
07:26:27 <nibro> Lemmih: :-(
07:26:39 <dcoutts> but it doesn't show the monospace font yet
07:26:47 <dcoutts> dons, I could take a new pic
07:27:01 <dcoutts> Lemmih, so that's showing type errors? cool.
07:28:44 <dons> dcoutts, that'll do
07:30:02 <wagerlabs> is this the way to read a byte? hGetByte h = do c <- hGetChar h; return (fromIntegral (ord c))
07:30:35 <dcoutts> dons, I'm just uploading a new pic...
07:31:06 <Lemmih> Goodnight, #haskell. I'll turn in for the day.
07:31:18 <dcoutts> g'night Lemmih
07:31:27 <dcoutts> dons, same url, new pic: http://haskell.org/~duncan/hIDE/hIDE.png
07:31:46 <dons> ok. grabbing it.
07:31:47 <nibro> Lemmih: gnight (at 4pm, you been up around the clock again? ;)
07:35:54 <Oejet> Lemmih: Sov godt.
07:36:04 <musasabi> wagerlabs: yes, you can use it for that.
07:36:19 <wagerlabs> musasabi: url?
07:36:55 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/network-alt/ (Use darcs and add --with-fps=yes to configure to get FastString support)
07:37:11 <musasabi> dons: pushed fps support into Network.Alt.
07:37:25 <wagerlabs> musasabi: trying...
07:37:42 <nibro> musasabi: aha, I didn't realize before who was behind that nick :-
07:37:43 <nibro> )
07:38:05 <nibro> how is hsWebForms these days?
07:38:19 <wagerlabs> hmm
07:38:40 <wagerlabs> i'm an idiot i was trying to pass --with-fps to darcs :) hehe
07:39:05 <wagerlabs> musasabi: invalid repository
07:39:07 <musasabi> nibro: basti has been using it and I have added some new features.
07:39:26 <musasabi> wagerlabs: that is the homepage - the repository is http://www.cs.helsinki.fi/u/ekarttun/network-alt/network-alt
07:39:41 <dons> @karma+ musasabi
07:39:42 <lambdabot> musasabi's karma raised to 1.
07:40:15 <nibro> musasabi: can I point to it in my presentation?
07:40:37 <musasabi> nibro: feel free if you want to.
07:41:58 <nibro> musasabi: I sure do, gotta prove that I have users! ;-)
07:45:07 <nibro> prionic: hello there :-)
07:47:16 <wagerlabs> musasabi: configure: UNKNOWN HOST powerpc-apple-darwin8.2.0
07:47:25 <wagerlabs> musasabi: configure: error: Fake getaddrinfo not yet implemented
07:47:48 <prionic> nibro: hello again, just read ur mail, lets see if i find something
07:52:29 <Lunar^> CosmicRay: there?
07:55:14 <magolo> hi
07:55:54 <ski> hej magolo
07:56:11 <magolo> i need some little help
07:56:41 <magolo> how do i check if a string that I read with getLine can be read as a number?
07:57:04 <ski> hm, you could use reads, i suppose
07:57:05 <musasabi> wagerlabs: hmm I think that tells that the getaddrinfo is broken on your platform.
07:57:09 <ski> @type reads
07:57:14 <lambdabot> forall a. (Read a) => ReadS a
07:57:22 <wagerlabs> musasabi: so what do you suggest?
07:57:32 <wagerlabs> it also said the platform was uknown :)
07:57:40 <musasabi> wagerlabs: I could give you a patch for fake getaddrinfo after ICFP, but that won't help with IPv6.
07:58:00 <wagerlabs> i ain't got no IPv6
07:58:01 <wagerlabs> :D
07:58:04 <ski> case reads str of [(n,_)] -> ...n...  ;  _ -> ..cannot read..
07:58:07 <wagerlabs> musasabi: will wait for the patch
07:58:09 <wagerlabs> thanks
07:58:42 <ski> magolo : another possible way would be to readIO and catch the exception, i guess
07:59:09 <magolo> thanks
07:59:10 <ski> (hm, i think using plain read would work too, in that case)
07:59:28 <wagerlabs> how do i get a list of functions and their types in a module?
07:59:40 <ski> :b Module
07:59:46 <magolo> if i use read then the program crashes if the user doesn't enter a valid number
08:00:15 <ski> magolo : it throws an exception, which if not caught, stops the program, yes
08:00:36 <musasabi> wagerlabs: try darcs pulling.
08:00:38 <wagerlabs> ski: :b IOExts does not work
08:00:45 <wagerlabs> musasabi: now?
08:00:58 <musasabi> wagerlabs: that makes it try compiling. But I won't promise it will work without the proper fake implementation.
08:01:02 <ski> @eval case reads "123" of [(n,_)] -> n; _ -> 0
08:01:05 <lambdabot> 123
08:01:09 <musasabi> now is good.
08:01:12 <ski> @eval case reads "a123" of [(n,_)] -> n; _ -> 0
08:01:13 <lambdabot> 0
08:01:26 <musasabi> (and rerun autoconf)
08:01:34 <musasabi> -> shower
08:01:35 <wagerlabs> musasabi: doing...
08:01:36 <ski> wagerlabs : i think you must give full prefix ..
08:01:51 <ski> wagerlabs : and also, have the module loaded (if in e.g. hugs)
08:01:55 <wagerlabs> ski: lang.IOExts? let me try
08:01:58 <ski> no
08:02:05 * ski checks
08:02:27 <wagerlabs> musasabi: Resolver.hsc:157: error: 'AI_NUMERICSERV' undeclared (first use in this function)
08:03:32 <nibro> magolo: if you only allow integers, then a simple "all isDigit str" would go a long way :)
08:03:40 <ski> wagerlabs : iirc, IOExts is hugs specific
08:04:09 <ski> wagerlabs : are you in hugs ?  ghci ? nhci ?
08:04:10 <wagerlabs> ski: can't be! they used it to write the web server
08:04:25 <wagerlabs> ski: i'm in ghci and it says that IOExts is member of lang and hidden
08:05:09 <ski> hm, ok
08:05:24 <wagerlabs> ski: it is a member of package lang-1.0, which is hidden
08:05:29 <magolo> thanks everybody. it works now. bye!
08:06:43 <ski> wagerlabs : ah, you forgot to say '-package lang' as args to ghci ?
08:06:51 <wagerlabs> yup
08:07:14 <wagerlabs> ski: thanks a lot!
08:07:20 <ski> np, yw
08:08:19 <musasabi> wagerlabs: I defined that away for darwin.
08:08:23 <musasabi> (in darcs)
08:08:33 <wagerlabs> musasabi: another pull?
08:08:36 <musasabi> yep.
08:09:22 <wagerlabs> musasabi: this is a silly question but is it possible to add kqueue support to network-alt?
08:09:29 <wagerlabs> musasabi: feasible even?
08:10:01 <musasabi> wagerlabs: It is very feasible.
08:10:05 <wagerlabs> musasabi: Preprocessing library network-alt-0.2.2...
08:10:15 <wagerlabs> musasabi: Warning: Network.Alt.Types: the following names could not be resolved:
08:10:22 <wagerlabs> Int ForeignPtr Show CInt
08:10:29 <wagerlabs> and a few more like that
08:10:43 <wagerlabs> musasabi: 6 or 7 errors
08:11:54 <wagerlabs> musasabi: also, cp: illegal option -- a
08:12:13 <dons> those  haddock warnings are ok.
08:12:18 <wagerlabs> musasabi: and Warning: Network.Alt.TCPClient: could not find link destinations for:
08:12:29 <wagerlabs> Network.Alt.TCPClient.HostName Network.Alt.TCPClient.Service
08:12:32 <wagerlabs> ah, ok then
08:12:43 <wagerlabs> gotta look at that cp -a
08:12:58 <wagerlabs> oh, part of haddock
08:13:39 <musasabi> wagerlabs: those are just warnings by haddock - nothing serious.
08:13:53 <wagerlabs> musasabi: i think it's cp -r for recursive
08:14:03 <wagerlabs> gonna try to build now
08:14:12 <musasabi> wagerlabs: except that some other systems support -a but not -r :-(
08:15:00 <wagerlabs> ok
08:15:28 <wagerlabs> musasabi: any test harness?
08:17:16 <musasabi> wagerlabs: (cd test && make && ./test)
08:17:20 <wagerlabs> musasabi: running make in the test dir
08:21:08 <wagerlabs> musasabi: getAddrInfo www.google.com fails obviously
08:21:42 <wagerlabs> musasabi: is this ok when running server: server: socket 8: hGetLine: end of file
08:21:57 <wagerlabs> musasabi: happens after it prints all ok
08:22:13 <musasabi> yes. That is ok.
08:23:02 <musasabi> wagerlabs: that means that getaddrinfo is broken on your platform and it will want a fake implementation. Writing one has been long a low-priority item for me. It is not very hard - just boring.
08:23:16 <wagerlabs> musasabi: understood
08:23:23 <musasabi> http://youzen.b2.fi/~musasabi/a.txt for the normal test outcome.
08:24:23 <wagerlabs> musasabi: so how would i proceed with your library if i had a binary protocol where the first few bytes were a header and then a payload that depended on the header info?
08:24:51 <musasabi> wagerlabs: If you want that you can 1) contribute an implementation, 2) bug me next week to write the implementation.
08:25:09 <wagerlabs> musasabi: not necessary /bug you/
08:25:32 <musasabi> wagerlabs: as for the binary protocol you would use a binary parser combinator using e.g. the getFPS.
08:26:16 <musasabi> wagerlabs: are you using UDP or TCP (with UDP you get whole records with each read with TCP you have to think about issues like getting the whole record)
08:26:17 <wagerlabs> musasabi: the binary parser combinator is something i would roll out by hand, right? any examples?
08:26:26 <wagerlabs> musasabi: tcp
08:26:49 <wagerlabs> musasabi: but i have a fixed-size header that i read first
08:26:57 <wagerlabs> musasabi: the header tells me the packet size
08:29:47 <musasabi> wagerlabs: one thing I am using for a binary protocol is youzen.b2.fi/~musasabi/lumikko
08:29:53 <wagerlabs> musasabi: it's like byte, byte, short where the short is the size of the rest of the packet
08:30:31 <musasabi> wagerlabs: under the lib/ directory you will find the stuff relevant to the parsing stuff.
08:31:15 <wagerlabs> musasabi: looking
08:31:27 <wagerlabs> what is lumikko, btw?
08:32:03 <musasabi> a file transfer thingy.
08:32:26 <musasabi> -> away for 15min
08:32:30 <wagerlabs> musasabi: thanks
08:48:22 <wagerlabs> musasabi: back yet?
08:49:23 <musasabi> yes, altough wet.
08:49:30 <wagerlabs> musasabi: he
08:49:48 <wagerlabs> musasabi: PWrite FID Offset S.FastString
08:50:12 <wagerlabs> musasabi: this means that it's a PWrite packet that has id, offset and then a buffer, right?
08:50:22 <nibro> dons: what's today's dinner plans? when and where? :-)
08:51:18 <musasabi> wagerlabs: PWrite = messagetype, FID = the file identifier we are writing to, Offset = where we are writing to (start offset), S.FastString = the data we are writing.
08:51:52 <musasabi> so yes
08:52:11 <wagerlabs> musasabi: so where do you actually translate PWrite into a number of something like that to plug it into the network packet
08:52:21 <wagerlabs> or you don't have this in your protocol
08:52:53 <wagerlabs> musasabi: ClientUtils.hs i think
08:53:13 <wagerlabs> the the demon also
08:55:58 <wagerlabs> musasabi: i think i'm starting to get a hang of this, albeit slowly
09:03:07 <musasabi> wagerlabs: I'll be back from haskell workshop on saturday. Now =>
09:03:47 <wagerlabs> musasabi: thanks for all your help and the sample code. i think i'm well on my way now
09:03:55 <wagerlabs> dons: thanks
09:04:00 <wagerlabs> and everyone else!
09:05:40 <nibro> dons: ping
09:15:40 <basti_> hmm wasnt there a primitive web server written in haskell somewhere?
09:16:31 <cbus> &wii basti_
09:16:36 <cbus> oopsi
09:16:43 <cbus> crap got dvorak on by misstake :/
09:16:49 * basti_ laughs
09:16:56 <cbus> usually run svorak at home :/
09:17:27 <humasect> basti, Haskell Web Server =)
09:18:00 <humasect> WASH-CGI comes with one also, i'm not sure if it's /the/ HWS though.
09:18:01 <araujo> Hello
09:18:02 * basti_ is thinking about doing his own form combination stuff after having looked into musasabi's
09:18:10 <basti_> oh yes wash, there was one
09:18:29 <ski> (combination ?)
09:18:46 <basti_> ski: as in "combinator"
09:19:04 <basti_> i was thinking like, basically a form is a IO a, just that it takes some time.
09:19:15 <ski> web forms ?
09:19:23 <basti_> http://sourceforge.net/forum/forum.php?forum_id=253134
09:19:27 <basti_> yes web forms
09:19:58 <nibro> basti_: hsp is a web server... sort of :)
09:20:24 <basti_> nibro: i've seen this one, yes.
09:20:36 <basti_> nibro: hsp is great, but the web server in there isn't, from what i've seen
09:21:44 <nibro> well, I guess you're right about that
09:22:07 <nibro> I take full blame
09:22:10 <basti_> :P
09:22:30 <nibro> but in mitigation, it's meant as a plugin and not a full-scale WS :)
09:22:41 <basti_> hmmmm
09:22:49 <basti_> how good does this work?
09:22:52 * basti_ goes have a look at it
09:23:11 <nibro> basti_: you could check out www.haskell.org/hsp
09:23:41 <nibro> Lemmih has done some nice work with the server, among other things there's a FastCGI integration with Apache in there
09:23:58 <basti_> i see.
09:25:31 <basti_> so how does this thing work? build the stuff in hspr, then a CGI comes out?
09:26:18 <nibro> basti_: I don't suppose you're attending the HW by any chance? :)
09:26:56 <basti_> I've not been attending anything in regards to haskell at all, sadly :(
09:27:02 <basti_> tight budget constraints.
09:27:10 <basti_> [= broke]
09:27:11 <nibro> basti_: the intention is that you add hspr to your apache (or whatever), and then everything will be handled automatically for you
09:27:15 <nibro> :(
09:27:28 * basti_ nods
09:27:46 <nibro> you only need to bother with the source files, then hspr will compile them on-request behind the scenes
09:27:53 <basti_> oh that rules.
09:28:11 <basti_> where is HSPR.Utils?
09:28:27 <nibro> which repo are you looking at?
09:28:33 <basti_> oh i see the .in
09:28:48 <nibro> aye, some configuration stuff in there
09:29:05 <basti_> hmm but configure didn't make the .hs
09:29:31 <nibro> did you run ./configure (as opposed to runhaskell Setup.hs configure)?
09:29:50 <basti_> oh
09:29:51 <basti_> no
09:29:59 <basti_> :D
09:30:05 <nibro> it's rather tricky to compile (I'm no setup guru), check the INSTALL file for details
09:30:06 <basti_> that explains things
09:30:10 * basti_ nods
09:30:24 <basti_> I've had a hard time with building hsp
09:30:39 <nibro> so have I...
09:30:47 <nibro> :p
09:30:59 <basti_> i thought you wrote it? ;)
09:31:28 <nibro> indeed, but I'm not good at writing installation scripts...
09:31:49 <nibro> but hsp should be fairly easy, it's hspr that's the beast
09:33:04 <nibro> I have to go grab some dinner, but I wish you all the best at setting things up :)
09:33:35 * basti_ nods
09:33:38 <basti_> I'm used to suffering
09:33:44 <basti_> have a nice meal
09:33:50 <nibro> hehe, thanks :)
09:34:13 * nibro runs off to avoid all the blame ;)
09:52:33 <basti_> build stops with "ghc-6.4: module `AltData.Dynamic' is a package module
09:52:35 <basti_> "
09:52:42 <basti_> what is that supposed to mean?
10:05:51 <prionic> basti_: what ure building?
10:06:16 <basti_> prionic: hsplugins. i got the tgz now, which is saner than the darcs version.
10:07:15 <prionic> ive used the darcs version... u have to run autoconf and ./configure first... then u can use setup.hs
10:08:27 <basti_> yes but it breaks with the error message i gave
10:08:44 <prionic> never saw that one
10:09:11 <basti_> i don't have an idea what it's supposed to mean either
10:12:16 <prionic> nibro: ure back?
10:13:31 <sylvan> basti_, I vaguely remember that hs-plugins included their own version of the Dynamic module.. so maybe something about that...
10:13:50 <sylvan> or, maybe they forgot to say "-package XX" where XX is the package where AltData.Dynamic is located
10:13:54 <basti_> sylvan: that might be the reason.
10:14:06 <basti_> sylvan: i circumvented by loading .tgz
10:14:11 <sylvan> ah
10:14:22 <basti_> some wackiness about building from darcs
10:14:42 <prionic> AltData.Dynamic is Module exposed by plugins
10:14:59 <dcoutts> you don't need to run ./configure first for hs-plugins
10:15:13 <dcoutts> the Setup.lhs does that automatically
10:15:33 <dcoutts> not sure if it's necessary to autoreconf
10:15:54 <prionic> if i did it without, build could not find config.h
10:16:39 <prionic> dcoutts: maybe ure right, probably autoconf is needed only
10:17:10 <dcoutts> it'd be nice if the Setup.lhs woulds do the autoreconf too
10:20:03 <prionic> is there some site where i can paste images?
10:20:46 <basti_> putfile.com?
10:21:02 <xerox> www.imageshack.us
10:23:33 <dcoutts> prionic, ah I know why it goes wrong for you, it's because the darcs checkout doesn't make configure executable
10:24:02 <dcoutts> because the configure script is in the hs-plugins darcs repo so there's no need to autoreconf
10:24:20 <prionic> yeah, but its fine for me once i figured it
10:24:20 <dcoutts> but you would need to use the darcs option to checkout preserving executable scripts
10:24:44 <dcoutts> I wonder if dons can make that option the default for that repo
10:24:58 <dons> ah, how so?
10:25:08 <dcoutts> hi dons
10:25:13 <dons> hey duncan
10:25:42 <dcoutts> darcs get of the hs-plugins repo checks out the configure script without the execute bit set
10:25:48 <dons> there's a way to specify --set-scripts-executable on the repo side, is there?
10:25:59 <dons> yep, configure silently fails :/
10:26:02 <dcoutts> which confuses people sicne they don't know that they have to specify --set-scripts-executable
10:26:03 <dons> if it's not exec
10:26:07 <dcoutts> yep
10:26:11 <dons> oh, i think it's on the site now.
10:26:29 <dcoutts> what's on the site?
10:26:34 <dons> but can i set it in the repo somehow?
10:26:39 <dcoutts> dunno
10:26:41 <dons> the corrrect darcs get line
10:26:55 <dons> ah, no it's not.
10:26:58 <dons> my fault
10:27:55 <dcoutts> the possability might be to change the Setup.hs to make configure executable
10:29:35 <Thorn> hello
10:29:50 <xerox> Hi Thorn!
10:30:03 <basti_> greetings
10:30:05 <Thorn> hi xerox
10:31:25 <Akshaal> hrr
10:31:27 <Akshaal> Executing 'builtin_dd if=/tmp/dvd1.iso of=/dev/dvd1 obs=32k seek=0'
10:31:27 <xerox> http://www.grandchallenge.org/downloads/GC_Brochure_9232005.pdf
10:31:28 <Akshaal> zsh: bus error  growisofs -dvd-compat -Z /dev/dvd1=/tmp/dvd1.iso
10:31:29 <Akshaal> what a...?
10:32:52 <sethk> In the state monad, why is there both a state and a value?  What's a typical usage of the state and the value?
10:33:03 <basti_> uhm
10:33:13 <xerox> Return, value.
10:33:14 <basti_> sethk: do you realize what a monad is?
10:33:37 <xerox> My name is Value - Return, Value.
10:33:43 <sethk> basti_, of course
10:34:15 <basti_> sethk: monads are scripts. scripts have states and return a value.
10:34:15 <xerox> So, we need an Haskell powered vehicle for the DARPA challenge!  http://www.grandchallenge.org/downloads/GC_Brochure_9232005.pdf
10:34:30 <sethk> basti_, then every monad would have both a state and a return value, but that isn't so.
10:34:45 <basti_> sethk: they don't?
10:34:53 <sethk> basti_, no.
10:35:00 <basti_> which monad does not have a state?
10:35:11 <sethk> I didn't say that a monad doesn't have a state
10:35:14 <basti_> (or something what you can see as being on)
10:35:18 <sethk> I said that not every monad has a state and a return value
10:35:28 <basti_> uhm
10:35:33 <basti_> all monads do have a return value
10:35:40 <basti_> even if its unit
10:35:40 <sethk> the return value is often the state
10:35:47 <ski> sethk : the state is an underlying hidden value, that can be changed sequentially, by various monadic calls, the value is what is returned from each action, and mostly bound explicitely by '<-' and used by that name ..
10:36:07 <basti_> and then, every monad has a state (or something that can pass as one)
10:36:15 <basti_> except for the identity monad
10:36:18 <basti_> but that is stupid.
10:36:22 <sethk> basti_, yes, I did _not_ say that every monad does not have a state
10:36:31 * basti_ nodnods
10:36:35 <basti_> so wheres the problem?
10:36:43 <sethk> basti_, I didn't say there is a problem
10:36:46 <basti_> okay.
10:36:53 <sethk> basti_, I asked what a typical usage is for the state and the return value
10:37:04 <basti_> uhm, for the state: setting and getting it
10:37:17 <basti_> for the return value: returning a value from the computation
10:37:29 <sethk> no, specifically.  in this case, I use a state of type Q and a return value of type R for this _specific_ purpose
10:37:41 * basti_ nods
10:37:41 <sethk> basti_, reading back the signature doesn't give me any information
10:38:04 <basti_> I fail to see the problem.
10:38:05 * xerox points to the id monad
10:38:16 <sethk> basti_, again, I didn't say that there is a _problem_
10:38:19 <xerox> (whistling)
10:38:21 <sethk> basti_, I asked for an example
10:38:24 <basti_> xerox: i mentioned that.
10:38:26 <Philippa> pretty much every monad has an internal state. You can always recover the degenerate case by modelling it as ()
10:38:28 <basti_> sethk: oh wait.
10:38:36 <prionic> am i right if say that value for the state monad is the same as the a in the list monad [a] ?
10:38:39 <sethk> xerox, I am looking at what you suggested
10:38:41 <xerox> sethk: I come up in the middle of the discussion, sorry.  Are you asking for an example of.. what?
10:38:45 <ski> list monad does not have state, reader/environment monad does not have state, writer monad does not have state
10:38:59 <ski> state monad has state :)
10:39:11 <basti_> @eval runState (do x<-get;return $ x+1) 0
10:39:13 <Blastur> hey! can i redirect haskell output to a file, when using ghc interactive mode?
10:39:16 <lambdabot> 18: Not in scope: `runState'34: Not in scope: `get'
10:39:19 <xerox> Reader Monad does not have state?
10:39:20 <basti_> argh
10:39:29 <Philippa> ski: reader and writer do too have states
10:39:31 <xerox> It does have Environment, which is a kind of State, isn't it?
10:39:32 <basti_> (1,0) would be the result: result 1, state still 0
10:39:32 <ski> xerox : it has environment
10:39:35 <sethk> ski, maybe there is a terminology difference here.  Is it better to say that every monad has a value, and some have a state, rather than the other way around?
10:39:36 <xerox> Writer prolly too.
10:39:50 <Philippa> yes
10:39:57 <prionic> sethk: i would think so
10:40:03 <ski> Philippa : do not :)
10:40:12 <sethk> prionic, Philippa thanks
10:40:14 <Philippa> every computation has a value attached pretty much by definition, it's the a in the type m a
10:40:14 <basti_> all monads do have a return value, and most have a state
10:40:35 <basti_> those which don't aren't particularly interesting imo.
10:40:47 <Philippa> ski: they're limited access, but the obvious semantic model for each is a value and an attached bunch of info which is changed in specific ways over time. Sounds like a state to me
10:40:58 <Philippa> it's not exposed as state per se, but hey
10:41:17 <Philippa> the Maybe monad has a different flavour of state, either it's still executing or it's Nothinging out
10:41:18 <xerox> basti_: they are!! For example, the list monad.
10:41:25 <Philippa> there's a clear state machine for that one
10:41:31 <basti_> xerox: hmm.
10:41:47 <sethk> The Maybe monad I have no problems understanding
10:42:02 <sethk> but that's simply because I can find a concrete example
10:42:05 <basti_> xerox: now one could debate, is that state or isn't it?
10:42:17 <basti_> sethk: did you see my state example up there?
10:42:22 <xerox> basti_: it's not the same thing of a State Monad, but, in some sense, you keep information.
10:42:40 <basti_> thats what i wanted to say yes
10:42:41 <sethk> basti_, yes, but that's useless.  You just through up two integers.  That isn't an example of _using_ it, that's just a bunch of numbers
10:42:48 <Philippa> it mirrors an abstract machine that has state beyond that involved in evaluating values
10:42:53 <xerox> But it's not _state_ in the SM sense.
10:43:08 * ski wasn't arguing whether they could be implemented using state .. surely that is the case
10:43:11 <xerox> What you get are actually the computations output.
10:43:23 <xerox> I'd argue it's much more 'State-like' a Tree Monad.
10:43:25 <Philippa> I'd say Reader, Writer and Parsec all keep state pretty much in the state transformer sense
10:43:26 <sethk> the list monad is clear also
10:43:28 <basti_> sethk: well then change the numbers to something different? and add a put or something?
10:43:52 <Philippa> Parsec more interestingly so than the others, admittedly
10:49:31 <xerox> Philippa: in what sense?
10:51:09 * basti_ bbl
10:53:13 <Blastur> is there an easy way to measure time used by haskell to evaluate a statement?
10:53:50 <xerox> I'd say, in GHCi, :set +s
10:54:12 <xerox> More generally, in compiled programs, by using the profiling skills of GHC.
10:56:58 <Blastur> thanks
10:57:26 <xerox> You're welcome!
10:57:58 <Philippa> xerox: in what sense does parsec have state, or all three of those examples?
10:58:34 <xerox> Philippa: it has in the sense of 'input stream', and maybe more?
10:59:10 <Philippa> actually Parsec has a full state /anyway/, but even without that the input stream gets a lot of chopping and changing
11:02:32 <[Blownose]> whats wrong of writing this   | (y==x) && (y=="-")  i get Cannot unify the type-signature variable `a' with the type [Char]
11:02:55 <xerox> What type has x?
11:03:19 <ski> is x a Char ?
11:03:24 <xerox> Also, it is possible you actually want '-' :: Char instead of "-" :: String.
11:03:36 <[Blownose]> ive tried that..
11:03:51 * ski thinks more context is needed
11:04:01 <[Blownose]> y =      ys!!0 for example where ys can be like "whatever"
11:04:56 <sethk> I've created a state monad (Control.Monad.State).  How do I apply the get function to it?  If I can in fact apply the get function to it.
11:05:31 <ski> [Blownose] : so y is a Char
11:05:38 <xerox> @docs Control.Monad.State
11:05:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.State.html
11:05:44 <xerox> @google All About Monads
11:05:45 <lambdabot> http://www.nomaware.com/monads/html/
11:05:56 <xerox> Those two sources has informations about how to use it.
11:05:57 <[Blownose]> yup and x should be to.. thats why im supprised that
11:06:01 <Oejet> @hawiki ImperativeHaskell
11:06:02 <lambdabot> http://www.haskell.org/hawiki/ImperativeHaskell
11:06:03 <sethk> xerox, I am, of course, reading that.  I have, of course, done what it appears to be telling me to do.  It doesn't work.
11:06:03 <xerox> 'have', even.
11:06:04 <[Blownose]> '-' dosent work or "-"
11:06:09 <[Blownose]> but maybe im wrong
11:06:10 <sethk> xerox, that's why I'm asking for help
11:06:16 <xerox> sethk: check out the nomaware article too!
11:06:24 <xerox> sethk: it comes with examples!
11:06:33 <sethk> xerox, ok, let me try it.
11:06:44 <xerox> Oejet's wiki page probably has too, I never read it, though.
11:06:45 <ski> [Blownose] : possibly there are some other error, too .. change to '-', anyway
11:06:51 <[Blownose]> ok
11:07:14 <ski> what is the error msg, now ?
11:07:33 <ski> sethk : get :: State s s
11:07:54 <sethk> No instance for (Control.Monad.State.MonadState s ((->) (Int, Int)))
11:07:54 <sethk>       arising from use of `Control.Monad.State.get' at <interactive>:1:0-5
11:07:55 <ski> sethk : so you    do s <- get; ...s...
11:08:17 <sethk> ski, no, that's why I was asking.  I did what it appeared from the signature that I had to do
11:08:21 <sethk> ski, wich is not that
11:08:28 <ski> sethk : hm
11:08:36 <ski> sethk : what did you try in ghci ?
11:08:53 <sethk> the definition says     get s m        so I thought I would take my monad, which I called m, and do:     get m
11:09:02 <sethk> which isn't it at all, apparently
11:09:22 <ski>  a monad isn't a value
11:09:32 <ski> possibly you mean your monadic action ?
11:09:42 <xerox> BBL, dinner.
11:09:48 <ski> what type does your 'm' have ?
11:09:53 <ski> @type Control.Monad.State.runState
11:09:54 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
11:09:57 <sethk> this is what everyone doesn't understand about people who are still trying to understand monads.
11:10:13 <sethk> it says     get  m s            which sure as hell looks like you apply a get   to an   m s
11:10:14 <ski> what is ?
11:10:16 <sethk> but you don't
11:10:30 <ski> the docs say that ?
11:10:42 <sethk> ski, the docs say:     get :: m s
11:10:48 <ski> ah
11:10:55 <sethk> and    put :: s -> m ()
11:11:16 <ski> that means that get is a monadic action returning something of type 's' (the state type)
11:11:32 <sethk> when I try    s <- get;      I get No instance for (Control.Monad.State.MonadState s IO)
11:11:32 <sethk>       arising from use of `Control.Monad.State.get' at mt3.hs:16:9-14
11:11:39 <DeadHorse> can anyone direct me to an explanation of what the !! means? it's hard to google for. :P
11:11:42 <ski> and that means that put is a function taking a state and returns a monadic action returning nothing interesting
11:11:54 <ski> DeadHorse : !! is indexing in lists
11:11:55 <arjanb> @type (!!)
11:11:57 <lambdabot> forall a. [a] -> Int -> a
11:12:02 <sethk> ski, but how is get, all by itself, applied to anything?
11:12:04 <ski> @eval [1..10] !! 5
11:12:06 <DeadHorse> mm. thanks.
11:12:06 <lambdabot> 6
11:12:31 <DeadHorse> learning haskell in a week for a class. :P
11:12:45 <ski> sethk : in your code, you can do     do {...; s <- get; ...s...}
11:13:01 <sethk> ski, if I had any idea what ...;  was, that might help
11:13:15 <ski> sethk : just any monadic commands
11:13:15 <sethk> ski, that, by the way, is what I did
11:13:25 <sethk> ski, well, ok, then why do I get that error?
11:13:40 <nibro> @paste
11:13:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:14:13 <sethk> ski, with s <- get as the last line, I get the message about "the last statement in a do construct must be an expression"
11:14:20 <sethk> ski, let me try a print after it.
11:14:32 <ski> sethk : try e.g. (in ghci)    "runState (do {a <- get; put (a+5); b <- get; put (b*2); c <- get; put (b-a); d <- get; return (a,b,c,d)}) 0"
11:15:17 <sethk> ski, it will take hours to try to figure that out.   Can't I create my monad on one line, and do something with it on the next line?
11:15:27 <RemiTurk> goeienavond allemaal
11:15:54 <ski> sethk : only IO monad .. otherwise either write all on one line, or better, write in a file
11:16:03 <sethk> ski, I am writing in a file
11:16:09 <sethk> ski, the problem is _what_ to write in a file
11:16:13 <ski> ah
11:16:19 <sethk> ski, I've created a monad with runState
11:16:32 <ski> sethk : you must of course also bind that expression to some name
11:16:40 <prionic> @paste
11:16:41 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:16:44 <sethk> ski, I can print it, and I get   (3,3)    (my monad has return value and state both as integer, and I made them both the same)
11:16:45 <ski> sethk : you were trying to write expressions directly into the file ?
11:17:03 <sethk> ski, I'm trying to figure out how I can use get, at the moment
11:17:11 <sethk> ski, I'm not sure what your question means
11:17:23 <wagerlabs> folks, what does => here mean
11:17:23 <wagerlabs> simpleWire :: IOSink a => a -> IO SimpleWire
11:17:40 <wagerlabs> why not just :: IOSink a -> IO SImpleWire?
11:17:42 <ski> sethk : were you writing lines "foo = ..." and "bar x = ..." into file ?
11:17:51 <sethk> ski, no
11:18:09 <sethk> ski, I have this:
11:18:28 <sethk> ski, let m = MS.runState (MS.State myval) 5
11:18:40 <sethk> ski, MS is qualified import of Control.Monad.State
11:18:45 <sethk> myval is a function:
11:18:52 <sethk> myval :: Int -> (Int, Int)
11:18:52 <sethk> myval n = (n, n)
11:18:54 <ski> wagerlabs : the part to the left of '=>' is constraints for the types ..
11:19:10 <sethk> ski, so I have the m created by let m = ....
11:19:15 <wagerlabs> ski: what does it mean in this example?
11:19:26 <[Blownose]> how do i write 3 recursive functions in one row and then apply max on all of them ?
11:19:38 <wagerlabs> ski: why not just :: IOSink a -> IO SImpleWire?
11:19:47 <adept> [Blownose]: come again?
11:20:09 <ski> wagerlabs : .. that whatever type 'a' is, it must be in type class 'IOSink', which means that is supports whatever methods there are in that type class
11:20:13 <[Blownose]> like   s (x:xs) (y:ys)= max (s(x,ys), s(xs,y), s(xs,ys)) for example
11:20:15 <sethk> ski, let me try and unravel what you wrote and see if I can get some idea of what is happening
11:20:41 <wagerlabs> ski: but wouldn't  :: IOSink a -> IO SImpleWire do the same?
11:20:48 <wagerlabs> ski: oh, i get it
11:21:21 <ski> wagerlabs : if e.g. the type 'Handle' is an instance of that class, then a valid restriction of simpleWire is simpleWire :: Handle -> IO SimpleWire
11:21:30 <wagerlabs> ski: :: IOSink a -> IO SImpleWire would constrain a to be _exactly_ IOSink whereas IOSink a => a means IOSink and others
11:21:33 <wagerlabs> ski: right?
11:21:57 <ski> wagerlabs : so you can pass just a plain handle, in that case, doesn't need to be wrapped in some IOSink type (whatever that would be)
11:22:20 <adept> [Blownose]: max $ map s [(x,ys), ...]
11:22:36 <ski> wagerlabs : sorry, no. the first would be invalid, if IOSink was a type class
11:22:51 <sylvan> [Blownose]: maximum [a,b,c,d]
11:23:01 <ski> sethk : you wrote that let in ghci ?
11:23:02 <wagerlabs> ski: hmm... ok, so it's a thing for type classes then. gotcha
11:23:15 <ski> wagerlabs : yeah, more or less
11:23:17 <sethk> ski, in a file, and the file is loaded into ghci.  It is part of main
11:23:25 <wagerlabs> ski: cool, thanks
11:23:30 <sethk> ski,   main = do
11:23:40 <sethk> ski, then the let
11:24:12 <ski> wagerlabs : a simpler example    (+) :: Num a => a -> a -> a    means (+) takes two arguments of same type 'a' (which must be in type class Num), and returns something of that type
11:24:26 <sylvan> sethk, what's on the right hand side of the let?
11:24:43 <ski> wagerlabs : you could not say that with your idea
11:24:54 <sethk> sylvan, I have two functions before main:
11:24:58 <ski> <sethk> ski, let m = MS.runState (MS.State myval) 5
11:25:10 <wagerlabs> ski: because there's a difference between types and type classes i suppose, right?
11:25:14 <ski> sethk : aha, ok
11:25:18 <sylvan> wagerlabs, yes
11:25:27 <sethk> ski, that's what I have, although split up
11:25:29 <wagerlabs> cool, i gotta read up on this more
11:25:33 <sylvan> wagerlabs, a type class basically says "these functions are defined for this type"
11:25:42 <wagerlabs> there's nothing like learning by example!
11:25:46 <sethk> sylvan, I have:     myval n = (n, n)
11:25:47 <ski> wagerlabs : yes. values have types .. types are collected in and are related with by type classes
11:25:58 <sethk> sylvan, then     mymonad val = MS.runState (MS.State myval) val
11:26:14 <sethk> sylvan, then, in main (after do)        let m = (mymonad 3)
11:26:17 <wagerlabs> got it
11:26:18 <sylvan> Num just defines a bunch of numeric functions, and a several number types (like Float, Double etc.) are "instances" of the Num class, meaning that someone at one point wrote implementations for (+),  among other functions
11:26:36 <wagerlabs> ok :-)
11:26:39 <sylvan> sethk, myval isn't a monadic action
11:26:50 <ski> sethk : runState runs the monadic action, so what is returned by 'mymonad' is not a monadic action
11:26:50 * wagerlabs thanks everyone for their help
11:26:54 <sethk> sylvan, then why does it work?
11:27:04 <sylvan> sorry, missed your second line
11:27:14 <sylvan> I thought you thought that myval was a monadic action
11:27:34 <DeadHorse> what's the delimiter for comments in a haskell source?
11:27:36 <ski> sethk : i think you should not use MS.State much, if at all
11:27:46 <sethk> ski, I want to understand it
11:27:54 <sethk> ski, regardless of whether or not I will use it
11:27:57 <sylvan> sethk, I think you have a fundamentally wrong idea about what a monad is so it's hard to explain =)
11:28:08 <sylvan> a monad isn't a value, for instance
11:28:19 <ski> DeadHorse : {- {- nested -} block comment -}  -- comment until end of line
11:28:25 <sylvan> so you can't say "I created a monad and put in the variable m"
11:28:31 <sethk> sylvan,  ok.  but you can do     m <- XXXXXX
11:28:37 <DeadHorse> thank you, ski
11:28:42 <adept> DeadHorse: '--' for line comments, {- for block -}
11:28:46 <sethk> sylvan, which looks suspiciously like creating something and putting it into m
11:28:56 <sethk> sylvan, but, ok, what _can_ you do with it.
11:29:00 <DeadHorse> thanks, adept
11:29:03 <sethk> sylvan, we have this thing called a monad.
11:29:03 <sylvan> hmm... The state monad is basically monadic actions which carry state.. So do { x <- get} will bind x to the value of the state within the monadic action
11:29:22 <sylvan> A monad is a way of performing side-effecting computations in sequence
11:29:24 <sethk> sylvan, ok, _what_ monadic action?
11:29:34 <sylvan> for example "get"..
11:29:35 <sylvan> or "put"
11:29:39 <ski> sethk : 'do'-notation creates monadic actions
11:29:40 <sethk> x <- get   has to apply to a particular monad, no?
11:29:48 <sethk> ski, then leave out do and use >>=
11:29:56 <sethk> ski, because I'll never see it otherwise
11:29:57 <ski> get is a monadic action in a state monad
11:30:00 <sylvan> You could define "inc" like so: inc = do{ x<- get; put (x+1)}
11:30:10 <sylvan> whihc just extracts the state, and puts it back increased by one
11:30:22 <sethk> sylvan, ok, but extracts the state from _what_?
11:30:28 <sylvan> from the monad
11:30:37 <sylvan> the state is passed around implicitly
11:30:41 <sethk> sylvan, I don't see a monad, I just see   do { x <- get; put (x+1) }
11:30:43 <sylvan> by the monad
11:30:49 <ski> sethk : the 'm' part of a type 'm a' says it's a type of monadic actions (if 'm' is a monad, but it is, here)
11:31:03 <sethk> ski, yes, that's fine
11:31:06 <sethk> ski, I have a main
11:31:07 <ski> sethk : the monad doesn't exist as a value
11:31:11 <sylvan> inc :: State Int ()
11:31:16 <sethk> ski, ok, but it exists as _what_
11:31:27 <sylvan> it's a tripple of a data type, and two functions
11:31:30 <sethk> ski, it's nice to know what it isn't, but it is nicer to know what it _is_
11:31:33 <ski> sethk : the monad is a type(-constructor) and some method implementations in type class Monad
11:31:47 <sethk> ski, ok, but I still have to _code_ this thing in some way
11:31:58 <ski> (often there are some extra actions, too)
11:32:07 <sethk> and   do { x <- get; put (x+1) } makes sense, but it isn't useful as code by itself
11:32:21 <ski> what you do what you use monads is that you create and combine monadic actions
11:32:26 <sylvan> the data type contains information about a specific type of computation, the "bind" function combines two computations in sequence and the "return" function constructs a computation which does nothing but return the supplied value
11:32:31 <sethk> if the particular monad is implied by the context, then _how_ do you imply it
11:32:36 <ski> then finally, on top, you run the monadic action
11:32:47 <ski> that then runs all of it
11:32:58 <sethk> sylvan, ok, but I still don't see the bind function anywhere in do { x <- get; put (x+1) }
11:33:14 <sylvan> it's there!
11:33:16 <sylvan> =)
11:33:16 <DeadHorse> is there a backward list construction operator? say I want to build from the tail and add to the head -- is there a reverse :?
11:33:16 <sethk> I understand the idea of the bind function, now show me how to use it, and where to put it
11:33:19 <sylvan> that's just syntax
11:33:26 <sethk> sylvan, take out the do, which hides the syntax
11:33:32 <sethk> sylvan, and code it for me with >>=
11:33:34 <ski> 'do { x <- get; put (x+1) }' is syntactic sugar for 'get >>= (\x -> put (x+1))'
11:33:37 <sylvan> it's equivalent to get >>= \x -> put x
11:33:37 <sethk> sylvan, and I'll be able to see it
11:33:48 <sylvan> ah missed th e+1
11:33:56 <sylvan> >>= is the bind-function
11:33:58 <ski> DeadHorse : no
11:34:12 <sethk> sylvan,yes, I know, but I can't just start my main with        get >>=       can I?
11:34:15 <ski> DeadHorse : often one adds to front anyway, and finally reverse, when done
11:34:24 <sylvan> main is in the IO monad, not the State monad!
11:34:30 <ski> DeadHorse : one can also do an accumulator, if not already doing that
11:34:32 <sylvan> so get and put aren't defined
11:34:35 <sethk> sylvan, yes, but every program starts in main
11:34:45 <sethk> sylvan, so how do I get to _anywhere_ where get and put are defined
11:35:01 <sylvan> use runState on a state action
11:35:05 <sylvan> to get a pure value out
11:35:11 <DeadHorse> ski: hmmm... but my function is recursive, so reverse would occur on every iteration
11:35:12 <sylvan> and then print it in the io monad, say
11:35:17 <sethk> sylvan, ok, now what is a state action
11:35:18 <ski> sethk : you can e.g. call a pure normal non-monadic function from main, and invoke your state monad action from that
11:35:29 <sethk> ski, ok, that's progress  :)
11:35:38 <sylvan> a state action is an action which performs a computation and may alter the implicitly passed around state value
11:35:42 <DeadHorse> oh, I can use a helper fcn
11:35:44 <DeadHorse> silly
11:35:52 <ski> sethk : you could invoke it directly from main, too. but you prolly find it easier if you don't mix the monads like that :)
11:36:18 <ski> DeadHorse : not if you make a helper function, and make that recursive, instead
11:36:23 <ski> DeadHorse : yah
11:36:36 <sethk> ski, yes, definitely.  I need to simplify first
11:36:39 <sylvan> sethk, maybe you should read this: http://www.nomaware.com/monads/html/
11:36:46 <sethk> ski, when I understand what's going on, then I can mix
11:36:50 <sethk> sylvan, I have, I have
11:36:59 <sylvan> hmm
11:37:07 <sethk> sylvan, the Maybe monad, it explains very clearly
11:37:11 <sethk> then it falls apart
11:37:11 <ski> main = do {print (foo 0)}
11:37:23 <ski> foo x = runState bar x
11:37:28 <ski> bar = ...
11:37:40 <ski> sethk : so bar can be your state monadic action
11:37:53 <sethk> ski, that's a do because main is in the IO monad, right?
11:38:03 <ski> yes
11:38:03 <sethk> ski, ok, let me mess with that structure a bit
11:38:05 <sylvan> well it's the same thing.. in the maybe monad you perform computations which may return nothing, in the state monad you have computions which pass around an implicit state..
11:38:32 <ski> recall that do is syntactic-sugar, so it's not really needed (especially in this case as it is just one command inside the do)
11:38:48 <sylvan> so all the actions in the state monad have access to a state variable which is implicitly copied around (via the implemenation of >>= for State)
11:38:58 <sethk> sylvan, no, it's really not the same thing at all to the reader, because if you look at the Maybe monad description, he defines the binding function as comp, then he does    ... `comp`   ...   `comp` ...
11:39:03 <sethk> sylvan, which is perfectly clear
11:39:11 <ski> sethk : possibly you want some arguments to bar, too
11:39:25 <sethk> sylvan, but then saying "ok, no do is doing all that somewhere in some weird way for you" is not even slightly clear
11:39:50 <sylvan> okay.. so do basically takes actions which are put after each other and inserts a `comp` between them
11:40:24 <ski> what the composition actually does is up to the specific monad (with some constraints)
11:40:26 <sethk> sylvan, I can get around that hiding of what is really happening by taking the do out and using >>=, and I know how to do that
11:40:35 <sethk> sylvan, but what ski just showed me is what I had no idea how to do
11:41:00 <ski> if you just test around in ghci, you don't need main
11:41:21 <sethk> ski, ok, but that just sort of postpones the problem.  :)
11:41:34 <ski> depending on how complicated foo is, you can often initially skip that too (writing the runState in ghci)
11:41:56 <ski> sethk : sure, if you want a stand-alone, you're gonna need a main
11:42:02 <sylvan> sethk, okay.. So comb combines to actions into a single action, right?
11:42:25 <ski> just one doesn't need it initially, always .. one can test and code quite a bit without coding main
11:42:30 <sylvan> sethk, >>= works the same way
11:43:17 <sethk> sylvan, ok.  what I didn't see what that I had to surround an entire function with runState in order to use the state monad.
11:43:25 <sethk> sylvan, which is hardly obvious
11:43:56 <sylvan> well when you have a monadic action and you want to use it in a pure function you need to "run it"
11:43:56 <ski> sethk : the run function runs the monadic action, bar just creates it
11:44:22 <sylvan> IO is a special case in that you don't have access to the run-function (the compiler does, and that's how main gets run)
11:44:38 <sethk> ski, sylvan thanks, I'm starting to see it.
11:44:41 <sylvan> sethk, you really need to think about actions as "modelling" a computation by combining smaller computations, and then the "run" as actually executing them
11:45:00 <sethk> sylvan, run, as in runState, or runWhateverMonad ?
11:45:04 <sylvan> you're really just building a data structure which represents the computation
11:45:07 <sylvan> sethk, exactly
11:45:10 <ski> usually, one just has a single 'run'
11:45:38 <ski> for IO one have no 'run'  (one can think of it like the run-time system does a 'run' on main)
11:45:42 <sethk> ski, well, at least two, although the one in main is implied, but I get the idea
11:46:02 <ski> sethk : as in runWhateverMonad  same pattern
11:46:31 <sethk> ski, I think I see that part of it now.
11:46:42 <ski> sethk : except some monads are like IO in that you can't run them yourself .. but usually you can convert them to IO, which you can then put in main
11:46:59 <sethk> ski, maybe I don't want to think about that right now?  :)
11:47:02 <ski> (sethk : such monads are usually built on top of the IO monad)
11:47:09 <ski> np :)
11:47:10 <sethk> ski, ok
11:47:27 <sethk> ski, sylvan let me reread the nomaware doc now that I have a better idea about what is going on
11:47:36 <sylvan> good luck!
11:47:40 <ski> sure
11:49:18 <xerox> Back!
11:49:33 <ski> [Blownose] : working ?
11:50:25 <[Blownose]> yup
11:51:14 <ski> good !
11:51:27 * shapr beats DeadHorse 
11:51:44 * ski goes back fighting the comonads
11:51:49 <shapr> DeadHorse: Sorry, just too funny to pass up.
11:52:57 <xerox> ski: wee, what are you hacking?
11:53:16 <ski> xerox : just basic comonad stuff
11:53:40 <ski> xerox : trying to see if i can come up with better idioms and combinators that musasabi
11:53:58 <xerox> What was musasabi's url?
11:54:14 <ski> http://www.cs.helsinki.fi/u/ekarttun/comonad/index.html
11:55:22 <xerox> Thanks.
11:57:04 * ski thinks his combinators are not so good ..
11:57:38 <ski> down with (>>--) and coreturn, i say ! down, down ! :)
11:57:45 <ricebowl> how do I create a datatype using a data *class* instead of a type constructor? i.e. I want data MyType = Case1 Integral | Case2
11:57:55 <ricebowl> is that possible...?
11:58:12 <ski> ricebowl : depends a little
11:58:43 <ricebowl> depends on?
11:58:50 <ski> ricebowl : one possible way is to use  data MyType = forall a. Integral a => Case1 a | Case2
11:59:23 <ricebowl> you case do something like Case1 Int | Case1 Long?
11:59:45 <Cale> Long?
11:59:48 <Cale> :)
11:59:49 <shapr> I know this is meta-#haskell, but I just have to show this: http://www.scannedinavian.org/~shae/01.12.16 :-)
11:59:50 <TheHunter> ski, his combinators don't need cobind, just functors + extract.
11:59:51 <ricebowl> I was guessing
12:00:11 <ski> in this case, when you have put something inside the Case1 constructor, it's type is forgotten (and can not be restored (barring Typable etc)).. only that it was an instance of Integral is remembered
12:00:17 <ski> TheHunter : yah
12:00:31 <ski> TheHunter : hm, misread you .. ok
12:00:34 <[Blownose]> if i have a list of strings ["o","ee","dsd","dwd"] and i want the biggest like ["dsd", "dwd"] how do i do that (i want both not just one)
12:00:56 <TheHunter> coreturn v = fmap (const v)
12:01:31 <Cale> [Blownose]: the function (\x -> (length x, x)) is probably useful
12:01:43 <shapr> isomer: hiya anth!
12:02:04 <ski> [Blownose] : sortBy can be useful, too
12:02:14 <[Blownose]> ahh true cale :) t
12:02:30 <adept> [Blownose]: and group could be useful too :)
12:03:30 <[Blownose]> :)
12:06:30 <isomer> yo shapr
12:09:11 <Blastur> @eval zip [1..] [1..25]
12:09:13 <lambdabot> [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,
12:09:13 <lambdabot> 11),(12,12),(13,13),(14,14),(15,15),(16,16),(17,17),(18,18),(19,19),(
12:09:13 <lambdabot> 20,20),(21,21),(22,22),(23,23),(24,24),(25,25)]
12:10:27 <ulfdoz_> Some stupid question: What happens, if the bot get's a non-terminating algorithm?
12:11:01 <Blastur> ulfdoz_: it limits most stuff it seems
12:11:03 <sethk> ulfdoz_, we aaaaaaaaaaalllllllllllllllll   diiiiiiiiiiiiieeeeeeeeeeeeeeeeeeeeeeeeeee
12:11:09 <Blastur> @eval [1..]
12:11:11 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
12:11:11 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
12:11:11 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
12:11:11 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
12:11:11 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
12:11:13 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
12:11:15 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
12:11:17 <lambdabot> [24 @more lines]
12:11:33 <ulfdoz_> rofl. ok. Nice demonstration.
12:11:38 <Blastur> @eval 2^9
12:11:40 <lambdabot> 512
12:11:57 <ulfdoz_> sethk: The possibility was the reason, why I haven't tried myself.
12:11:59 <ski> @eval 2^85
12:12:01 <lambdabot> 38685626227668133590597632
12:12:07 <Blastur> @eval [x^x | x <- [1..]]
12:12:09 <lambdabot> [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,
12:12:09 <lambdabot> 285311670611,8916100448256,302875106592253,11112006825558016,
12:12:09 <lambdabot> 437893890380859375,18446744073709551616,827240261886336764177,
12:12:09 <lambdabot> 39346408075296537575424,1978419655660313589123979,10485760000000000000
12:12:09 <lambdabot> 0000000,5842587018385982521381124421,341427877364219557396646723584,
12:12:11 <lambdabot> 20880467999847912034355032910567,1333735776850284124449081472843776,
12:12:13 <lambdabot> 88817841970012523233890533447265625,6156119580207157310796674288400203
12:12:15 <lambdabot> [24 @more lines]
12:12:16 <sethk> ulfdoz_, what I said might not be true, but it was more interesting.  :)
12:12:22 <mflux> @eval (2^85)^(2^85)
12:12:26 <lambdabot> Terminated
12:12:35 <ski> @help eval
12:12:36 <lambdabot>  @eval <expr>
12:12:36 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
12:13:24 <Blastur> @eval 99999999999999999^(1/2)
12:13:26 <lambdabot> <Plugins.Eval>:1:38:
12:13:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:13:26 <lambdabot>   `Fractional a' arising from use of `/'
12:13:35 <Blastur> woopsie
12:14:01 <dons> @eval let f () f () in f () :: ()
12:14:03 <lambdabot> 32: parse error on input `in'
12:14:07 <dons> @eval let f () = f () in f () :: ()
12:14:09 <TheHunter> hmm, is there a sensible definition of mapW :: (w a -> b) -> w [a] -> [b] ?
12:14:10 <ski> shapr : :)
12:14:11 <lambdabot> Terminated
12:14:25 <TheHunter> @eval let x = x in x
12:14:27 <lambdabot> <Plugins.Eval>:1:12:
12:14:27 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:14:27 <lambdabot>   `Show a' arising from use of `show'
12:14:31 <TheHunter> @eval let x = x in x :: ()
12:14:33 <lambdabot> Loop
12:14:41 <dons> lambdabot is so smart :)
12:14:55 <Blastur> too smart! it will soon take over humanity
12:14:56 <ski> @vixen are you smart?
12:14:57 <dons> hey TheHunter, greeting from europe!
12:14:57 <shapr> Still, I think there's a DoS available in GHC's typechecking algorithms.
12:14:58 <lambdabot> i truely am
12:15:01 <Blastur> and make haskell of earth
12:15:19 <ulfdoz_> What have I done?
12:15:26 <TheHunter> hey dons, how's europe?
12:15:26 <shapr> Blastur: I think the lambdas will lift us to another plane.
12:15:35 <dons> cold and dark ;)
12:15:39 <dons> hehe
12:15:59 * ski considers TheHunter's questions
12:16:05 <dons> no, it's lovely, i'm having a great time here in Tallinn.
12:16:41 <prionic> @eval (\x y -> x^y) 1 [2..]
12:16:42 <lambdabot> <Plugins.Eval>:1:28:
12:16:42 <lambdabot>   No instance for (Integral [a])
12:16:42 <lambdabot>   arising from use of `^'
12:16:54 <Blastur> shapr, yeah,.. maybe that's how the peeps in stargate finally manage to ascend!
12:17:34 <ski> @eval map ((\x y -> x^y) 1) [2..]
12:17:36 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:36 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:36 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:36 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:36 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:38 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:40 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:17:42 <lambdabot> [24 @more lines]
12:17:51 <prionic> @eval foldl (\x y -> x^y) 1 [2..]
12:17:55 <lambdabot> Terminated
12:18:09 <ski> @eval scanl (\x y -> x^y) 1 [2..]
12:18:10 <dons> i'mm not sure what people think lambdabot is going to do..
12:18:11 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:11 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:11 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:11 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:11 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:13 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:15 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:18:17 <lambdabot> [24 @more lines]
12:18:36 <dons> but, nonetheless, hack away hehe
12:18:39 <ski> @eval scanl (\x y -> y^x) 1 [2..]
12:18:43 <prionic> :)
12:18:46 <lambdabot> out of memory (requested 2097152 bytes)
12:18:52 <dons> yay!
12:18:54 <ski> oops :)
12:18:58 <dons> my poor box
12:19:31 <dons> ski, you've overdrawn your byte budget, and the repo men will be around to collect the debt
12:19:42 <dons> this is a very serious matter
12:19:53 <ski> @karma- ski
12:19:54 <lambdabot> You can't change your own karma, silly.
12:20:38 <dons> the fraudulant request of bytes is a federal offence
12:21:09 <dcoutts> oh dear ski you're in big trouble now
12:21:26 <lambdabot> ouch, I have a headache. someone took my bytes!
12:21:34 <dcoutts> poor lambdabot
12:21:41 <dcoutts> @botsnack
12:21:42 <lambdabot> :)
12:21:48 <[Blownose]> (\x -> (length x, x)) hmm what does it do ?   for every x in my list take the length of x and ?
12:22:12 <dons> the wily lambdabot battles on!
12:22:16 <ski> @vixen you shouldn't have requested that last byte
12:22:17 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
12:22:34 <dons> oh vixen
12:22:48 <ski> [Blownose] : as well as keeping the x
12:23:25 * adept reads: "monads naturally model semantic effects, where comonads naturally capture contextual effects". Oh dears. Is there Comonads 101?
12:23:26 <ski> [Blownose] : map (\x -> (length x, x)) foo = zip (map length foo) foo
12:23:48 <dons> contextual effects, eh?
12:23:49 <ski> ([Blownose] : but the first could be more efficient)
12:24:15 <ski> coeffects ! :)
12:24:37 <ski> adept : i think we have not constructed it yet ..
12:24:41 <[Blownose]> hmm ok
12:25:12 <adept> dons: that's from hawiki
12:25:28 <adept> ski: i think I need cobrain to understand coeffects :)
12:25:45 <dons> @remember adept i think I need cobrain to understand coeffects
12:25:52 <dons> @quote
12:25:54 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a
12:25:54 <lambdabot> bike rode up next to me and said, "There's always a show off." I
12:25:54 <lambdabot> offered to teach him to ride and help set up a unicycle patrol squad,
12:25:54 <lambdabot> but he declined.
12:26:18 <ski> (i'm not sure coeffects is a good name .. before i've used effects for both kinds,  and some kinds seem to be available in both monad and comonad form)
12:27:12 <ski> (s/some kinds/some effects/)
12:28:31 <shapr> @quote dons
12:28:32 <lambdabot>  boegel, stop polluting the quote-space please
12:28:37 * shapr snickers
12:28:42 <[Blownose]> but ski if i already have the max value of the items i want to get.. why zip every length into the list is that neccesary ? like max:3 ["aa","bbb","ccc"] -> ["bbb","ccc"]
12:29:18 <Cale> [Blownose]: if you already know the length you want, check out filter
12:30:30 * ski is not here
12:32:22 * shapr isn't here either
12:32:31 <shapr> @quote ski
12:32:32 <lambdabot> ski hasn't said anything memorable
12:32:35 <shapr> That's not true!
12:32:53 <[Blownose]> length(maximum(map length xs)) gives me my length but.. can i apply that with filter ?
12:35:31 <dons> filter (/= ... ) xs
12:36:38 <[Blownose]> isnt /=.... < a value in the list not the length ?
12:36:49 <thedward> filter (\x -> length x ==  ( maximum ( map length mylist ) ) ) mylist
12:36:51 <dons> @type filter
12:36:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:37:45 <thedward> @eval filter (\x -> length x ==  ( maximum ( map length mylist ) ) ) mylist where mylist = ["o","ee","dsd","dwd"]
12:37:47 <lambdabot> 88: parse error on input `where'
12:38:10 <thedward> huh, that works in hugs
12:38:14 <dons> use 'let'
12:38:23 <dons> irc is not a full haskell environment ;)
12:38:33 <dons> though it's nice that you assumed it was :)
12:38:56 <dons> s/full/unrestricted/
12:38:59 <Cale> well, the issue is that where is not part of the expression syntax
12:39:01 <thedward> I could swear I'd used where before
12:39:05 * adept tried to co-read and co-understand comonads, but got co-re dump
12:39:09 <thedward>  let mylist = ["o","ee","dsd","dwd"] in filter (\x -> length x ==  ( maximum ( map length mylist ) ) ) mylist
12:39:14 <thedward> @eval  let mylist = ["o","ee","dsd","dwd"] in filter (\x -> length x ==  ( maximum ( map length mylist ) ) ) mylist
12:39:16 <Cale> it's part of the declaration syntax
12:39:16 <lambdabot> ["dsd","dwd"]
12:39:30 <sylvan> @eval let f xs = head . groupBy (\x y -> length x == length y) . sortBy (\x y -> compare (length x) (length y)) in f  ["o","ee","dsd","dwd"]
12:39:31 <lambdabot> <Plugins.Eval>:1:12:
12:39:31 <lambdabot>   No instance for (Show ([[a]] -> [[a]]))
12:39:31 <lambdabot>   arising from use of `show'
12:39:37 <sylvan> crap
12:39:47 <sylvan> @eval let f xs = head . groupBy (\x y -> length x == length y) . sortBy (\x y -> compare (length x) (length y)) xs in f  ["o","ee","dsd","dwd"]
12:39:49 <lambdabot> 77:
12:39:49 <lambdabot>   Expecting a function type, but found `[a]'
12:39:49 <lambdabot>   Expected type: a1 -> [[a]]
12:39:49 <lambdabot>   Inferred type: [a2]
12:39:49 <lambdabot>   Probable cause: `sortBy' is applied to too many arguments in the
12:39:50 <lambdabot> call
12:39:52 <sylvan> crap!!
12:39:53 <lambdabot>    (sortBy (\ x y -> compare (length x) (length y)) xs)
12:40:09 <sylvan> @eval let f = head . groupBy (\x y -> length x == length y) . sortBy (\x y -> compare (length x) (length y)) in f  ["o","ee","dsd","dwd"]
12:40:11 <lambdabot> ["o"]
12:40:16 <sylvan> hmm =)
12:40:22 <sylvan> @eval let f = head . groupBy (\x y -> length x == length y) . sortBy (\x y -> compare (length y) (length x)) in f  ["o","ee","dsd","dwd"]
12:40:23 <lambdabot> ["dsd","dwd"]
12:40:25 <sylvan> yay
12:41:20 <thedward> I think "There's more than one way to do it" might be even more true for Haskell than perl.
12:41:30 <sylvan> probably
12:42:40 <dons> @remember adept tried to co-read and co-understand comonads, but got co-re dump
12:44:14 <TheHunter> Cannot import `Language.Hi.Parser':
12:44:14 <TheHunter>   it was found in multiple packages: plugins-0.9.10 hi-0.9.10
12:44:26 <TheHunter> what do I have to do?
12:44:30 <dons> unregister hi-0.9.10
12:44:40 <dons> there's only 'plugins' now that i've switched to cabal
12:45:03 <TheHunter> thanks, makes sense.
12:49:44 <TheHunter> thbot, @eval filter (\x -> length x ==  ( maximum ( map length mylist ) ) ) mylist where mylist = ["o","ee","dsd","dwd"]
12:49:44 <thbot> (line 1, column 84):
12:49:44 <thbot> unexpected "="
12:49:44 <thbot> expecting var, "head", "tail", "null", bool, num, character, "[",
12:49:44 <thbot> string, "(", operator, simple term or end of input
12:50:07 <TheHunter> hm.
12:50:17 <Cale> where isn't part of the expression syntax
12:50:30 <Cale> at least in Haskell
12:50:31 <TheHunter> thbot, @eval x where x = 3
12:50:31 <thbot> (line 1, column 11):
12:50:31 <thbot> unexpected "="
12:50:31 <thbot> expecting var, "head", "tail", "null", bool, num, character, "[",
12:50:31 <thbot> string, "(", operator, simple term or end of input
12:51:43 <TheHunter> where should runplugs be located?
12:52:01 <TheHunter> thbot, @plugs x where x = 3
12:52:02 <thbot> 3
12:52:10 <TheHunter> ah!
12:52:35 <TheHunter> thbot, @plugs !10
12:52:35 <thbot> 0: parse error on input `!'
12:53:35 <dons> ah, maybe I forgot to push the @eval == @plugs patch
12:53:52 <dons> it's probably sitting on lambdabot's machine.
12:54:36 * TheHunter wishes he could read regexps
12:54:47 <Cale> dons: yeah, I had to do that manually with my copy
12:56:48 <dons> i'll push it. bit busy atm though (haskell workshop tomorrow)
12:57:53 <TheHunter> unsafeEval ("let { xxxx = \n# 1 \"<irc>\"\n"++s++"} in take 2048 (show xxxx)") ...
12:59:15 <dons> yeah <irc> would be nicer
12:59:42 <Cale> @eval let x = y where y = 3 in x
12:59:44 <lambdabot> 3
13:00:09 <dons> TheHunter, patch and send
13:01:38 <TheHunter> @index matchRegexAll
13:01:40 <lambdabot> Text.Regex
13:01:42 <TheHunter> @docs Text.Regex
13:01:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
13:02:25 <dons> yeah ,the nice regexes got broken with 6.5  :/
13:04:23 * dcoutts is pleased with his progress on the hIDE UI
13:05:02 <dons> i've put down hIDE as the future on my concluding slides, dcoutts ;)
13:05:14 <dcoutts> it's now cleaner code & will support various kinds of browsers more easily
13:05:28 <dcoutts> dons, excelent! advertising :-)
13:05:46 <dcoutts> dons, so the model now is more like this:
13:06:12 <dcoutts> we have editor pages indexed by uri-like things
13:06:57 <dons> ah, cool!
13:06:58 <dcoutts> and seperately we can have any number of browser views that allow the user to browse & select some subset of these uris
13:07:17 <dcoutts> so the obvious case fits; that of files
13:07:18 <dons> yes, this sounds nice
13:07:30 <dcoutts> the editor pages are accesed by uri (ie file name)
13:07:40 <dcoutts> and the browser is just a file tree
13:07:59 <TheHunter> thbot, @plugs 1 + foo
13:07:59 <thbot> <irc>:1:4: Not in scope: `foo'
13:08:10 <dcoutts> but it should also support other kinds of thing like local or http documentation pages, and config pages
13:08:21 <TheHunter> thbot, @part #haskell
13:08:25 <dcoutts> and those can have differnt ways of browsing them
13:08:39 <dcoutts> so the browsing is not necessarily related to the structure of the uri
13:09:03 <dcoutts> (though it is related in the case of editing .hs files and the file browser view)
13:10:22 <dcoutts> and then since the browser views give an indirection into the editor pages it means we can have a common comcept of the current page between different browser views
13:10:54 <dcoutts> so within on window, if you look at different browser views they update to reflect he current selection
13:10:59 <dcoutts> on/one
13:11:22 <dcoutts> at the moment the UI is still to have tabs for different browser views but that's not essential
13:11:38 <dcoutts> so that's the idea
13:12:03 <dons> ok. sounds really nice
13:12:07 <dcoutts> one thing I've not quite decided yet is how to register pages for uris
13:12:26 <dcoutts> I'll start with something simple but it's something to think about
13:13:26 <dcoutts> the uri concept is useful because it generalises to identify not just pages but elements within pages, eg line column number in an editor, or #index items in a html doc page
13:15:01 <dcoutts> project settings, tools config, and general config/settigns can follow the same model
13:15:45 <autrijus_tw> yay, object types in ghc works!
13:16:21 <autrijus> aka. existentially quantified record types for both vanilla and GADT
13:16:51 <dons> wow
13:17:18 <autrijus> was hacking all day on this, non-stop
13:17:23 <dons> hehe :)
13:17:36 <dcoutts> autrijus, so it's what exactly?
13:17:44 <dons> that's got to be the fastest extension to ghc's type system i've ever heard of
13:18:03 <dcoutts> ah it's a type system extension
13:18:21 <dcoutts> what does it do/allow?
13:18:35 <autrijus> dcoutts:
13:18:53 <autrijus> data Counter = forall a. MkCounter { num :: a, inc :: a -> a, dec :: a -> a, output :: a -> IO () }
13:18:55 <dons> autrijus, i hope you've still got a pugs tshirt for me ;) i want to wear it to the perl class i teach next wednesday
13:19:02 <autrijus> dons: cool. I do
13:19:14 <autrijus> I brought one M sized with me today hoping to find you
13:19:23 <autrijus> that t-shirt found its way to brandon instead
13:19:27 <autrijus> but fortunately I still got on M
13:19:30 <autrijus> s/on/one/
13:19:38 <dcoutts> autrijus, ah so I can do forall in record selectors, cool. I've wanted to do that before.
13:19:44 <dons> cool.
13:19:48 <autrijus> dcoutts: yeah, and it gets better
13:20:11 <dcoutts> autrijus, in fact the screenshot that dons will be showing is of hIDE editing some hIDE code that would like to use that feature
13:20:26 <autrijus> data Obj a where
13:20:26 <autrijus>     Con { public :: a, private :: b, method :: a -> b -> IO () }
13:20:28 <autrijus>         :: Obj a
13:20:40 <autrijus> is really cool to me
13:20:55 <autrijus> note you can have multiple Con and share the labels, as long as both the field type and result types match.
13:20:59 <autrijus> it's _all_ supported :D
13:21:22 <dcoutts> have you missed the binder for 'b' above?
13:21:26 <Cale> autrijus: that's really cool
13:21:34 <autrijus> dcoutts: er right, that should read
13:21:34 <Cale> dcoutts: I think it's implicitly forall'd
13:21:39 <autrijus> where forall b. Con { ... }
13:21:43 <Cale> or it should be explicit :)
13:21:44 <autrijus> but I also hacked in implicit forall.
13:21:48 <autrijus> :)
13:21:55 <dcoutts> ah ok, glad I understand :-)
13:21:57 <autrijus> only for GADT though
13:22:04 <autrijus> for vanilla it's still an error
13:22:07 <autrijus> wouldn't want
13:22:11 <autrijus> data F = Blah { l :: a }
13:22:17 <autrijus> to randomly pass typecheck
13:22:31 <dcoutts> but with an explicit forall it's ok right?
13:22:37 <dcoutts> it's not just for GADT
13:22:40 <Cale> well, this should make OO stuff in Haskell nice :)
13:22:43 <autrijus> sure
13:22:53 <autrijus> it's just GADT gets Implicit support
13:23:07 <autrijus> and along the way I unified the internal representation for GADT and Vanilla
13:23:18 <autrijus> so it should cut down various special cases too
13:24:13 <dcoutts> so I have an example of some code that would probably want this: http://scannedinavian.com/repos/hIDE/plugins/ideShell/src/Hide/EditorPage.hs
13:24:24 <dcoutts> the EditorPage 'object'
13:24:46 <dcoutts> the idea is that we can have a collection of these things
13:25:03 <dcoutts> but they maintain private state (two kinds of private state)
13:25:15 <dcoutts> and that state can be of any type at all
13:25:37 <dcoutts> it's how we indend to support arbitrary "editor pages" in hIDE
13:25:55 <dcoutts> and manage them genericly
13:25:57 <davve> will automatic serialization of that state be possible?
13:26:29 <dcoutts> no
13:26:40 <dcoutts> it'll have to be explicit and by other means
13:26:44 <davve> okay
13:26:58 <dcoutts> since some of that private state corresponds to external objects, eg GUI widgets
13:27:08 <TheHunter> what will the type of eg. 'num' be?
13:27:34 <autrijus> TheHunter: it has no type.
13:27:56 <dcoutts> davve, we intend to have a config subsystem and whatever else is necessary to support saving/restoring editor sessions
13:27:59 <autrijus> TheHunter: to be more specific, whenever you try to use it as a normal term, it throws out a compile time error that tells you to use record selector/update syntax.
13:28:09 <davve> dcoutts, okay
13:28:17 <autrijus> TheHunter: clever no? :)
13:28:58 <TheHunter> ah, i see.
13:29:17 <autrijus> spj suggested that internally we use forall_a_a
13:29:28 <autrijus> but I think maybe Counter -> a
13:29:33 <autrijus> currently it's the bottom type internally.
13:29:43 <autrijus> regardless, whenever you resolve to that, it gives an error.
13:30:10 <autrijus> TheHunter: however, "public" is well typed
13:30:10 <autrijus> and can be used as such.
13:30:52 <TheHunter> ok, that's just a normal record with gadt syntax.
13:31:29 <autrijus> right, but previously you could not have this kind of partially-public stuff.
13:31:47 <palomer> hullo
13:32:02 <autrijus> in record form, I mean. 
13:32:02 <palomer> what's the complexity of an algorithm that takes a normalizable lambda term and normalizes it?
13:33:23 <sethk> I still have  'that does not compute" with the monad definitions.  That's because we said that you can't instantiate a monad value.  The problem is that in the example for Maybe, we _do_ instantiate a monad value.  And...
13:33:33 <sethk> take the signature for >>=, types a and b are both Int
13:33:49 <autrijus> dcoutts: indeed, updator syntax for EditorPage records would r0ck
13:33:53 <sethk> we have m Int -> (Int -> m Int) -> m Int
13:34:06 <sethk> which means we have to code function:   (Int -> m Int)
13:34:14 <sethk> which means that the function takes an Int, and returns an m Int
13:34:30 <sethk> so, if there is no way to instantiate an m Int, how can I return an m Int?
13:34:55 <autrijus> with "return"?
13:35:01 <sethk> and the Maybe combinator certainly returns    Maybe whatever
13:35:02 <TheHunter> palomer, i don't think there is a computable complexity bound to that.
13:35:19 <sethk> autrijus, then it isn't true that you can't instantiate a monad value?
13:35:53 <autrijus> I'm confused. surely you can instantiate it.
13:36:29 <sethk> autrijus, we had a long conversation here earlier when I kept asking how, and I was told that a monad is not a value, and you can't create one.
13:36:46 <autrijus> you can instantiate (m Int)
13:36:49 <autrijus> you can't instantiate (m)
13:37:06 <sethk> autrijus, well, I never tried to instantiate (m)
13:37:47 <sethk> autrijus, and I'm completely confused about how this relates to the run functions such as runState
13:38:18 <sethk> autrijus, this all came up because I asked how to use get
13:38:33 <sethk> autrijus, but perhaps I'll belay that question  :)
13:39:38 <sethk> let me look again at some examples, I'll be back.
13:40:49 <palomer_> if anyone answered my question, I was away
13:40:54 <palomer_> (and would like to hear the answer)
13:41:02 <sethk> palomer_, you were away even if nobody answered.  :)
13:41:09 <palomer_> eh?
13:41:24 <palomer_> oh, you silly goose
13:41:57 <sethk> palomer_, you see, false does imply everything
13:46:58 <skolulph> is there some better way to start nested transformer monads than to do evalState recursively?
13:51:27 <isomer> isaac gooey had a good suggestion
13:51:37 <isomer> set up a smalltalk workspace on a webpage
13:51:52 <isomer> i knew there was a reason he was on jarober's payrole
13:51:59 <isomer> er... wrong window :)
13:56:40 <TheHunter> palomer_, i don't think there is a computable complexity bound to that.
13:57:06 <xerox> 'evening
13:57:37 <palomer_> TheHunter: can you point me to any references?
13:57:47 <palomer_> TheHunter: like how to show this result?
13:58:28 <TheHunter> it least for turing machines, it is well-known, and i guess lambda-calculus is similar.
14:00:34 <xerox> Hiya TheHunter, how's going?
14:00:48 <TheHunter> hiya xerox, fine, thanks.
14:01:31 <xerox> I didn't see you talk much lately!
14:01:52 <TheHunter> I haven't had much time lately...
14:02:09 <palomer_> TheHunter: yeah, got a reference for the turing machine case?
14:03:54 <TheHunter> it should be in most complexity theory books, it is a simple diagonalization argument, iirc.
14:04:19 <palomer_> TheHunter: there's an important clause here:
14:04:21 <malcolm> Is there anyone in Tallinn, planning to be at the HW tomorrow. with a laptop and webcam?  Just had the crazy idea that they could stream the workshop to me by instant messenger...
14:04:33 <palomer_> we assume the term is normalizable
14:05:47 <TheHunter> for each computable f, there is a computable function that can't be computated in time f, that's the kind of statement you should search for.
14:05:50 <dcoutts> malcolm, if someone streamed it, I'd certainly watch
14:06:06 <palomer_> TheHunter: that's obvious
14:07:05 <TheHunter> doesn't that answer your question?
14:07:09 <palomer_> TheHunter: However, I'm looking for a statement: given the size of f, you can't determine the maximum runtime
14:07:41 <palomer_> TheHunter: since I can claim that there is a computable upper bound on the complexity
14:07:51 <palomer_> given the size
14:08:10 <palomer_> given the size of a term, I can determine the worst case runtime
14:08:13 <palomer_> this is complexity.
14:08:30 <TheHunter> i'll be back in half an hour.
14:08:36 <palomer_> eh!
14:08:39 <xerox> Bye bye.
14:16:20 <davve> garhg.. my computer keeps crashing
14:17:06 <dcoutts> hardware problems? or software?
14:17:20 <davve> hardware.. graphics board
14:18:02 <dcoutts> dodgy board or dodgy closed sourse drivers?
14:19:20 <davve> no fan
14:19:23 <davve> :)
14:19:42 <davve> I removed because it didn't work properly
14:19:52 <dcoutts> I recently got a new gfx card with no fan at all
14:19:56 <dcoutts> it's quite nice
14:20:19 <dcoutts> same model as I had before but with no fan (and dual head output)
14:20:43 <dcoutts> and still has open source X drivers with 3d accel
14:21:44 <dcoutts> which means it's a rather old model :-) (all newer ones only have closed source drivers) but on the plus side it meant it was cheap :-)
14:21:51 <davve> oh, which one?
14:22:00 <dcoutts> radeon 9250
14:22:08 <davve> ok
14:23:10 <dcoutts> I've found the radeon 7xxx/8xxx/9xxx models to be very reliable and work well under linux
14:24:05 <dcoutts> the 9250 is the fastest one you can get that still has open source drivers with 3d accel
14:24:12 <davve> hehe :)
14:28:08 <xerox> dcoutts!
14:28:10 <xerox> http://www.4dsolutions.net/ocn/lsystems.html
14:28:34 <ski> sethk : .. 'monad value' is sloppy speak ..
14:28:42 <dcoutts> xerox, nice
14:28:50 <sethk> ski, it occurs in the docs.  What's better?
14:29:00 <ski> sethk : you sure can create values of type 'm a' for various choices of 'm' and 'a'
14:29:11 <sethk> ski, yes, I see that.
14:29:23 <ski> sethk : e.g. 'return' and '>>=' creates such .. also 'get' is one
14:29:29 <sethk> ski, In fact, I've actually gotten the compiler to accept get and put
14:29:41 <xerox> dcoutts, am I wrong, or the rules are deterministic?
14:29:42 <sethk> ski, it isn't doing what I want yet, but it's progress
14:29:42 <ski> sethk : i think 'monadic action' is good
14:29:49 <ski> sethk : good
14:30:07 <dcoutts> xerox, you can make them deterministic, or you can add randomness
14:30:17 <sethk> ski, but it's not always an action, is it?
14:30:23 <xerox> dcoutts, I mean in that python program.
14:30:46 <ski> sethk : right, 'put' e.g. is a function returning an action
14:31:24 <sethk> ski, the () part of m ()  ?
14:31:29 <dcoutts> xerox, it's not obviously doing anything using random numbers
14:32:00 <xerox> dcoutts, ah-ha!
14:32:03 <ski> (adept : even the experts doesn't know fully yet what comonads can do ..)
14:32:12 <ski> sethk : no
14:32:20 <dcoutts> xerox, why do you ask?
14:32:25 <ski> sethk : 'm ()' is the type of the action
14:32:46 <ski> sethk : put :: s -> m ()
14:32:49 <xerox> dcoutts, I tried explaining how the monadic approach improved composability in the core code of Nymphaea to a python guy.
14:33:03 <ski> sethk : put :: s -> State s ()    in the case of the standard state monad
14:33:20 <ski> xerox : and ? :)
14:33:23 <xerox> dcoutts, it was some days ago, now, another person in the channel showed up this thing...
14:33:54 <sethk> ski, I'm making progress, although the notation is still puzzling.
14:34:28 <ski> sethk : do-notation ?  or the idioms for using monads ?
14:34:41 <sethk> ski, I'm using >>=, I still can't handle do
14:34:52 <ski> sethk : ok
14:35:05 <sethk> ski, for some reason it is easier for me that way, I'm not quite sure why yet
14:35:54 <dcoutts> xerox, I don't think I get the context of what was being discussed
14:35:57 <Sickjacken> is there some standard (format) for graph data ?? i have a callgraph and *ideally* would want to dump it in some format so a 3rd party tool kan view it beautifully
14:36:11 <ski> sethk : possibly because you're not so used to do, yet .. and because you are not so used to the standard monads, and thinking in monads, so coding closer to the underlying workings of the monad feels better .. possibly
14:36:13 <Sickjacken> so i dont have to do that viewing myself, which obviously a lot of other people can do a lot better
14:36:15 <dcoutts> Sickjacken, there's some xml format
14:36:25 <xerox> dcoutts, Nymphaea, LSystems.
14:36:29 <ski> wb DeadHorse
14:36:32 <Sickjacken> you mean the da vinci stuff?
14:36:46 <dcoutts> Sickjacken, and there's graphviz which will do nice layout and accepts and produces multiple formats
14:37:10 <dcoutts> xerox, but what was this point about monads, python & random numbers?
14:37:33 <Sickjacken> dcoutts, graphviz lays it out nicely and stuff?
14:37:50 <dcoutts> Sickjacken, graphviz is an open source graph visualistion program
14:38:04 <Sickjacken> ow that is nice
14:38:06 <TheHunter> palomer_, ah, i see what you want, it's even easier then. If you could compute the maximal runtime for each function, you could solve the halting problem.
14:38:06 <Sickjacken> open source
14:38:16 <dcoutts> it's docs mention that there is some standardised xml format that various things use
14:38:25 <xerox> dcoutts, did you see the new LSystem.hs in Nymphaea?
14:38:35 <xerox> dcoutts, I was trying to explain it.  But it was hard.
14:38:52 <dcoutts> Sickjacken, but graphviz also accepts some simple text formats which are easy to produce
14:39:01 <dcoutts> xerox, I've not seen it yet
14:39:07 <dcoutts> @where Nymphaea
14:39:08 <lambdabot> http://haskell.galois.com/~paolo/darcs/nymphaea
14:39:32 <Sickjacken> dcoutts, ow cool, im going to look at graphviz and choose a format
14:39:33 <Sickjacken> thanks
14:40:42 <dcoutts> xerox, the minumum iterations number should be 0, not 1 :-)
14:40:50 <ski> (xerox : typo in 'Minumum')
14:40:58 <xerox> @where+ Nymphaea http://haskell.galois.com/~paolo/nymphaea
14:41:00 <lambdabot> nymphaea ~> http://haskell.galois.com/~paolo/nymphaea
14:41:02 <dcoutts> 0 iterations is just the original axiom
14:41:04 <xerox> Oh.
14:41:23 <xerox> I don't remember the reason why it is 1..
14:42:44 <dcoutts> xerox, I don't get why you make the lsystem calculaton monadic
14:42:50 <dcoutts> what advantage does that give you?
14:43:24 <xerox> dcoutts, lists model nondeterminism!
14:43:45 <dcoutts> but why do you want that in the lsystem calculation?
14:44:00 <dcoutts> what does it give you?
14:44:13 <xerox> ...and a more general (MonadPlus) approach lets me use Cale's MonadRandom to get a random output out of the possible outcomes (calculating their relative probability)
14:44:45 <dcoutts> I'd just do that directly
14:45:00 <dcoutts> by passing in an infinite list of random numbers
14:45:35 <xerox> This way I need just 1 random number in the homogeneous interval 0..1, and undeer the hood!
14:45:41 <xerox> under, even.
14:45:58 <xerox> I think this approach is very, very, nice.
14:46:22 <ski> night #haskell
14:46:26 <xerox> Goodnight ski!
14:46:44 <dcoutts> xerox, ok fair enough
14:46:55 <TheHunter> 'night ski
14:47:00 <xerox> dcoutts, I tried before with a WeightedList monad.  But it wasn't really good.
14:47:31 <xerox> I.e. it needed to actually calculate the outcomes to calculate the weights.
14:48:41 <xerox> dcoutts, it's very nice how could I change the 'box' of the outcomes without modification in the core code.  You could put even better expression than 'very nice' there ;)
14:49:37 <xerox> Like 'absolutely pleasant'  'extremely satisfactory' etc.
14:49:54 <dcoutts> :-)
14:50:04 <Blastur> is there any way to for evaluation? i want to calculate a list,.. i guess i could just type it in and let haskell print it out, but thats crazy slow since the list is very big.. is there any way to evaluate it without haskell outputting anything? i basically just want to measure time it took to generate the list
14:50:10 <xerox> But it's difficult to explain.  Isn't it?
14:50:35 <xerox> Blastur: try 'seq'.
14:51:41 <xerox> @google Haskell seq
14:51:42 <lambdabot> http://www.zvon.org/other/haskell/Outputprelude/seq_f.html
14:54:21 <Sickjacken> omfg, the graphviz textual input format rules
14:54:36 <dcoutts> simple huh?
14:55:47 <Sickjacken> yeah man
14:56:07 <dcoutts> I've got a module that's less than 30 lines of code that produces .dot output
14:56:20 <Sickjacken> digraph G { f -> g -> h ; f -> h }
14:56:22 <Sickjacken> thats it :D
14:56:33 <Sickjacken> what the input of the module dcoutts?
14:56:41 <dcoutts> writeDotGraph :: (Show node, Eq node) => [(node, node)] -> String
14:56:42 <Sickjacken> a Data.Graph ?
14:57:33 <dcoutts> and I generate the (Show node, Eq node) => [(node, node)] from another internal representation
14:58:20 <Sickjacken> you mean you have some class that encapsulates the converting to [(node, node)] for a couple of data types?
14:58:44 <dcoutts> it just uses Show
14:59:15 <Sickjacken> ah like that
14:59:25 <dcoutts> want the code?
14:59:25 <Sickjacken> i thought you meant something else
14:59:46 <Sickjacken> well its for my thesis, so i might as well write it myself
15:00:14 <dcoutts> ok
15:00:23 <Sickjacken> thanks for helping though
15:00:28 <dcoutts> np
15:00:52 <Sickjacken> in any other situation i would have grabbed that software of yours hehe but in this case i feel i should do it myself
15:01:11 <dcoutts> yeah, sure
15:01:54 <Sickjacken> cya im off sleeping
15:04:54 <xerox> Goodnight!
15:22:04 <work_metaperl_> shapr: is Scanned down?
15:22:43 <dcoutts> work_metaperl_, not for me
15:22:51 <work_metaperl_> oh... hmm
15:25:09 <dcoutts> sometimes the dns is dodgy I find
15:25:26 <dcoutts> so the .org may be inacessable but the .com usually works
15:28:36 <work_metaperl_> yes, I can get to it from my cooperative webhost, but not from work
15:28:39 <work_metaperl_> anyway...
15:28:47 <work_metaperl_> I am very confused over ch.16 in SJT's book
15:29:03 <work_metaperl_> he implements updateable storage using nothing but functions in this module: http://194.23.215.164/~metaperl/haskell/craft-of-fp/Code/AbsTypes/StoreFun.hs
15:29:12 <work_metaperl_> I dont understand how in the world that works
15:32:01 <dcoutts> work_metaperl_, ah it's not to complex
15:32:13 <dcoutts> the only tricky part is the update
15:32:14 <work_metaperl_> hmmm
15:32:27 <dcoutts> so the lookup is simple right?
15:32:52 <dcoutts> if you're using a function to implement mapping, then you just apply the function to get the result
15:32:54 <work_metaperl_> the lookup is just creating functions like this  : sto 5 = 12    sto 8 = 11 ,etc ,etc
15:33:15 <work_metaperl_> so when you call sto 5 you get 12, etc, etc
15:33:16 <work_metaperl_> right?
15:33:34 <dcoutts> I'm not sure "creating functions" is the best way to think about it
15:33:52 <dcoutts> it just applys the function
15:34:09 <dcoutts> and the initial store is one that maps everything to 0
15:34:14 <dcoutts> right?
15:34:16 <work_metaperl_> i have to run to a meeting ... back in 30 minutes... sorry to be so rude
15:34:21 <dcoutts> np
15:54:30 <work_metaperl_> ok I'm back
15:54:39 <dcoutts> ah right
15:55:04 <araujo> Im back too!
15:55:13 <dcoutts> work_metaperl_, so the 'initial' & 'value' bits are simple
15:55:23 <dcoutts> the interesting thing is how the update works
15:56:02 <dcoutts> so since the map is represented by a function we need to create a new function
15:56:32 <dcoutts> this functions will represent the new mapping including the extra key|->value mapping pair
15:56:49 <dcoutts> but it also has to still keep all the old mappings
15:57:07 <dcoutts> work_metaperl_, yes?
15:57:23 <work_metaperl_> yes, and this one has to be more recent
15:57:29 <work_metaperl_> than the old value
15:57:35 <dcoutts> yep
15:58:26 <dcoutts> so the way it works is to create a new function that checks if the key is the new key (in which case it return the new value) otherwise it just calls the old function to deal with the old mappings
15:58:45 <work_metaperl_> i'm still a bit lost on value()
15:59:06 <work_metaperl_> if I call value (Sto sto) 5 12 what happens
15:59:22 <work_metaperl_> and what is sto?
15:59:31 <dcoutts> sto is the function
15:59:39 <dcoutts> the function that represents the mapping
15:59:40 <work_metaperl_> that retains the values
15:59:43 <work_metaperl_> ok yes
15:59:52 <work_metaperl_> Sto is the type constructor
15:59:55 <dcoutts> yep
16:00:36 <work_metaperl_> so when I make this call (Sto f) 5 ... oh I get it... it calls sto 5 to see what sto has defined for 55
16:00:37 <dcoutts> so it's making a new value with a new function inside it: = Sto (\w -> ...)
16:00:39 <work_metaperl_> s/55/5
16:00:58 <dcoutts> right
16:02:28 <dcoutts> so in the end if we insert several values we end up creating a big long chain of functions each of which test for one value and then deffer to the next
16:02:47 <dcoutts> so it's not partiularly effecient, it's a linear search, in the order of insertion
16:03:04 <dcoutts> but it is short to code!
16:03:47 <work_metaperl_> it's the else clause that gets me: else sto w
16:04:04 <dcoutts> so the 'sto' is the existing mapping function
16:04:10 <work_metaperl_> ah!
16:04:28 <work_metaperl_> so they are making reference to it in the else, but not making use of it if the "if" fires
16:04:34 <work_metaperl_> neat
16:04:45 <work_metaperl_> that _is_ sweet
16:04:49 <dcoutts> so it just deffers to the existing mapping function in the case that the value being looked up is not the value that was just inserted
16:04:55 <work_metaperl_> dcoutts: did you enter the ICFP contest this year?
16:05:10 <work_metaperl_> yes, that sort of elegance is not found in many other languages.. that is really a neat thing
16:05:10 <dcoutts> yep, our team came 7th out of 161 teams
16:05:25 <dcoutts> it takes advantage of the ability to store funtions in data structures
16:05:27 <work_metaperl_> dcoutts: at least you got the problem solved correctly
16:05:39 <work_metaperl_> correctness is important...
16:05:54 <dcoutts> yes it certainly was in that contest
16:06:15 <work_metaperl_> wow haskell took first!
16:06:27 <dcoutts> yes :-)
16:06:29 <dcoutts> and 3rd
16:06:32 <work_metaperl_> what is judge's prize? how is that more important than first?
16:06:48 <dcoutts> the judge's prize is for elegance
16:06:56 <dcoutts> or whatever the judges think is cool
16:07:24 <dcoutts> in this case it was supposed to be for how well the code from the first round was re-used in the second round
16:12:20 <work_metaperl_> Dylan attracted my attention because of their strong ICFP results, but haskell is ininitely attractive because it has a central concept: function application... most other languages have a ton of features, syntax, etc
16:12:52 <dcoutts> and its strong ICFP results!
16:13:11 <work_metaperl_> yes. consistent strong results.
16:13:40 <wagle> uhh..  haskell syntax has some problems
16:13:43 <work_metaperl_> Haskell doesnt have the pressure of meeting corporate deadlines. It was formed carefully by committe by people interested in doing what made the most sense
16:14:30 <Oejet> work_metaperl_: Those two statements are quite flawed IMHO.
16:14:51 <work_metaperl_> Oejet: in what sense?
16:15:34 <Oejet> Err, what you imply by it.  It's factually true.
16:16:14 <work_metaperl_> Oejet: it's true but flawed?
16:16:20 <work_metaperl_> you danish people are weird
16:16:37 <work_metaperl_> and just wait til we take you out in the World Cup in 2006 :)
16:16:55 <Oejet> work_metaperl_: We didn't qualify. :-(
16:17:16 <Oejet> Err, we won't qualify.
16:18:41 <work_metaperl_> Oejet: ouch. oh well
16:19:02 <Oejet> work_metaperl_: :-P
16:30:11 * shapr bounces quietly
16:30:27 <dcoutts> how're things shapr?
16:30:36 <shapr> Life is always interesting. What's up with you?
16:30:47 <dcoutts> hacking on hIDE UI
16:31:20 <dcoutts> or rather the underlying modular data model that underlies it
16:31:54 * dcoutts peppers his last sentance with more 'moudulars' and 'underlies'
16:32:44 <dcoutts> making a UI is easy, making the stuff underneath to drive it is the interesting & tricky part
16:33:42 <dcoutts> shapr, so when are you going to have some time to hack on hIDE :-)
16:33:55 * dcoutts knows that shapr is a busy man
16:34:36 * dcoutts is quite happy with shapr cheerleading for hIDE
16:34:39 <shapr> After I finish FLM, I assume :-)
16:34:52 <dcoutts> ah yes
16:36:43 <work_metaperl_> shapr: ever thought of moving back to the US and working for Galois?
16:37:01 <shapr> work_metaperl_: Yeah, I even applied...
16:37:08 <shapr> But they turned me down :-/
16:37:12 <dcoutts> :-(
16:37:15 <work_metaperl_> what?!
16:37:24 <work_metaperl_> over-qualified I guess
16:37:33 <dcoutts> mm, that must be it
16:37:48 <shapr> I dunno, they didn't seem very interested.
16:37:57 * shapr shrugs
16:38:17 <work_metaperl_> There's also Aetion, but Oregon is way more interesting than Ohio
16:38:18 <shapr> In any case, I like being self-employed.
16:38:46 <dcoutts> my impression is that they value theoretical knowledge over hacking experience
16:38:48 <shapr> I don't think I'd much enjoy working at Aetion.
16:39:16 <work_metaperl_> dcoutts: who values theory more?
16:39:32 <dcoutts> that's my impression of Galois
16:39:35 <work_metaperl_> oh
16:40:26 <work_metaperl_> well it's time for me to start my commute back into Koreatown
16:40:59 <work_metaperl_> it's nice working in the rich suburbs, but I must head back to my dwellings in the naked inner city at our Buddhist monastery: www.IBMC.info
16:40:59 <shapr> I'm not really sure how to make money off of my good points.
16:41:48 <shapr> work_metaperl_: seriously?
16:42:04 <shapr> That's nifty.
16:42:19 <work_metaperl_> that's my dwelling
16:42:20 <work_metaperl_> :)
16:43:00 <work_metaperl_> here are some pictures of me outside and in back: http://princepawn.perlmonk.org/pix/me/
16:43:17 <work_metaperl_> I took them 1 week ago... I'm wearing the blue top and white pants today --- African clothing is very comfy :)
16:43:45 <work_metaperl_> well, the 1 hour commute has begun... chat in 1 hour or so...
16:43:58 <shapr> You look like a cat.
16:44:19 <shapr> Very nice cat though :-)
16:44:42 * shapr suspects that's just a cat acquaintance of metaperl.
16:45:15 <shapr> Whoa, I want some of that nifty clothing, even if it wouldn't be much use when the snow is about to fall.
16:45:32 <dcoutts> yeah, it looks nice
17:13:15 <shapr> g'day Pseudonym
17:13:43 <Pseudonym> G'day.
17:13:58 <shapr> How's code?
17:15:33 <Pseudonym> Oh, long story.
17:15:38 <Pseudonym> Which I'm not allowed to tell you.
17:16:28 <Pseudonym> But by a series of misadventures, I get to turn up to work next week and not work.
17:16:35 <Pseudonym> Yay!
17:16:59 <shapr> too bad
17:17:11 <shapr> Free money is nice though :-)
17:17:11 <Pseudonym> At least I still have access to the universtity library.
17:17:26 <Pseudonym> I can put it down to "professional development".
17:19:09 <shapr> I've just been reading about open source FPGA tools... it occurs to me that translating logic into FPGA layout is a lot like graph reduction.
17:19:32 <shapr> Or at least, it seems to me that most FP optimization techniques should apply to FPGAs.
17:25:51 * SamB wonders how to design sane MMU mapping tables
17:26:10 <Pseudonym> First off, for heavens sake don't use a untagged TLB.
17:26:20 <SamB> TLB?
17:26:29 <shapr> Pseudonym: Oh hey, what's your opinion on the STI Cell?
17:26:39 <Pseudonym> shapr: I'm really, really unsure about it.
17:26:47 <Pseudonym> It seems like a brilliant idea, but so did the Itanium.
17:27:01 <Pseudonym> As did hyperthreading.
17:27:16 <SamB> the itanium seemed brilliant?
17:27:38 <SamB> it seems like it might be a good torture-test for programs, but other than that...
17:28:00 <SamB> it expects the compiler to be omniscient, doesn't it?
17:28:03 <Pseudonym> At the time it was being designed, it seemed very clever.
17:29:09 <SamB> I don't think architectures designed with the assumption that the compiler is omniscient usually perform very well...
17:29:10 <Pseudonym> Turning control dependencies into data dependencies should eliminate many pipeline stalls.
17:29:34 <Pseudonym> And VLIW should require less hardware to do ILP.
17:30:09 <Pseudonym> That's the theory, anyway.
17:30:16 <SamB> anyway, anybody have any good ideas about sane memory mapping datastructures? Knuth is, like, insane AND lazy to boot...
17:30:34 <Pseudonym> So in summary, I'm uncertain about the cell.
17:30:52 <Pseudonym> I find FPGAs fascinating, though.
17:31:02 <Pseudonym> I'd love to play around with them.
17:31:16 * Pseudonym would love to implement his own CPU
17:31:40 <SamB> Pseudonym: so, how would you do the MMU?
17:31:50 <wagle> i "designed" and built my own pdp8 with my bare hands
17:31:58 <Pseudonym> wagle: Cool!
17:31:59 <wagle> ... okay, i did use a wire wrap tool
17:32:25 <shapr> Pseudonym: from what I've read today, it's not worth it.
17:32:26 <Pseudonym> For my first CPU, I'd seriously consider having what is technically no MMU.
17:32:29 <Pseudonym> The early MIPS chips do that.
17:32:32 <SamB> hmm.
17:32:44 <shapr> It seems that all the commercial FPGA vendors are actively against open source anything.
17:32:45 <Pseudonym> They had no MMU, just a TLB.
17:32:47 <wagle> .. mostly using programmable array logic chips
17:33:02 <Pseudonym> And if you had a TLB miss, you would trap into the operating system.
17:33:10 <shapr> Personally, I'd want to compile Haskell to an FPGA.
17:33:11 <Pseudonym> So the MMU was basically implemented in software.
17:33:13 <SamB> okay, would that be like Knuth's scheme for software address mapping in MMIX?
17:33:22 <Pseudonym> Possibly.  Don't know much about MMIX.
17:33:44 <SamB> probably better that way.
17:34:22 <Pseudonym> The problem is that a TLB miss is very expensive.
17:34:29 <Pseudonym> Even if the page tables are in cache.
17:34:55 <shapr> It seems that EDIF 4 0 0 (from 1996) is the standard intermediate format for FPGAs, but the EDIF standards group fell apart in 2000.
17:35:30 <sethk> seems to me that the hardware manufacturers would be well served by open source.  Or is there something I'm overlooking?
17:35:48 <shapr> I haven't found any open sources tools that generate EDIF from a model, nor tools that turn EDIF into a vendor specific bitstream.
17:35:54 <wagle> fabs cost BIG bucks
17:35:57 <Pseudonym> I think the hardware manufacturers would be well self-served by making their chips not interoperable.
17:36:10 <sethk> Pseudonym, true, but that can be handled with back ends
17:36:23 <shapr> sethk: Only thing I can think of is, no... because then some smart guy would come up with the Linux of CPUs, and Intel/IBM/Motorola/etc wolud all die.
17:36:51 <sethk> shapr, Building FPGAs is more about manufacturing than design
17:36:58 <sethk> shapr, plus, Motorola is already dead
17:37:04 <SamB> but there is no such thing as a Linux of CPUs
17:37:04 <sethk> shapr, or at least in intensive care.  :)
17:37:16 <shapr> SamB: Probably because there aren't any tools.
17:37:20 <sethk> building high density hardware takes _money_
17:37:20 <shapr> Linux required gcc.
17:37:43 <SamB> and people tend to get attached to CPUs
17:37:58 <Pseudonym> FPGA-based CPUs are _always_ going to be slower and consume more power than the equivalent hand-built-circuitry.
17:38:22 * SamB doesn't think so
17:38:23 <shapr> But, I'd like to apt-get install cpu-2.6
17:38:27 <Pseudonym> Or, more likely, computer-assisted-and-partially-hand-built-circuitry.
17:38:38 * SamB thinks hand-built circuitry tends to be rather large and slow
17:38:57 * SamB thinks maybe Pseudonym meant fabricated circuitry
17:39:01 <Pseudonym> Yes.
17:39:08 <shapr> I think if we applied the common FP optimizations to FPGAs, it'd kick butt.
17:39:14 <wagle> transmeta was quasi-programmable
17:39:23 <SamB> was?
17:39:30 <Pseudonym> But you couldn't rebuild the integer unit.
17:39:31 <wagle> i think they are dead
17:39:33 <shapr> I think transmeta stopped making CPUs.
17:39:37 <shapr> They only sell their software now.
17:39:38 <SamB> oh
17:39:47 <SamB> what good is that without CPUs?
17:40:01 <shapr> Their software can dynamically optimize running code of many flavors.
17:40:12 <shapr> It's like a reJIT for x86 and others.
17:40:17 <wagle> ex transmeta employee snickered when i asked about the extent of its programmability
17:40:30 <wagle> ..  guffawed, even
17:40:51 <shapr> It's like Self's poly-inline caching (now in the HotSpot JVM) plugged into valgrind.
17:41:07 <wagle> didnt reallty get a clear explanation though
17:41:19 <wagle> really
17:41:45 <SamB> shapr: sounds decidedly odd!
17:42:05 <shapr> In any case, I don't trust any commercial vendor to know more than I do about optimizing chip layout... especially not since I've been thinking about using shape types to do chip layout...
17:42:24 <shapr> SamB: Actually, it's obvious once you think about applying Self's PIC to hardware.
17:42:29 <shapr> (imho)
17:42:38 <SamB> well, the way you say it sounds odd
17:42:46 <CosmicRay> yes, and very few of them have a unicyclist perspective on the word.
17:42:49 <SamB> but I guess it isn't really very odd
17:42:51 <CosmicRay> s/word/worl/d
17:43:09 <shapr> SamB: CosmicRay has a point... that which is obvious or obscured to me is rarely the same to others.
17:43:31 <CosmicRay> wow, I had no idea I was so erudite.
17:43:38 <SamB> but it would be without the skin, right?
17:43:44 <shapr> Yesterday I realized that I'd like to apply the ICFP2001 contest solution to ELF binaries.
17:44:03 * CosmicRay looks up icfp2001
17:44:10 <SamB> @google ICFP2001 contest solution
17:44:13 <lambdabot> http://www.gwydiondylan.org/icfp/icfp2001.phtml
17:44:27 <shapr> It was about optimizing a markup language.
17:44:53 <CosmicRay> wow, a problem I'd have some chance at solving ;-)
17:45:00 <SamB> ELF is a markup language?
17:45:20 <shapr> I was thinking about different cache sizes. I realized that modifying a binary to load differently could dramatically speed it up.
17:45:21 <CosmicRay> I suppose one could very loosely look at it that way ;-)
17:45:26 <SamB> and what does ELF-as-a-markup-language have to do with unicycling?
17:45:33 <shapr> balance!
17:45:40 <SamB> oh
17:45:43 <wagle> bounces faster
17:46:03 <SamB> yes, there is definately a lot of balance involved in unicycling, balance which I sorely lack
17:46:10 <Pseudonym> I've been thinking a bit about CPU design lately.
17:46:19 <Pseudonym> Which is why I find the FPGA discussion interesting.,
17:47:00 <shapr> I'd just like to write my own coprocessor in Haskell.
17:47:20 <shapr> I thought about implementing self modifying FPGAs recently.
17:47:50 <shapr> FPGAs probably have lots of internal bandwidth, that would be really cool for graph reduction problems.
17:48:02 <shapr> I'd like to write Conway's game of life for an FPGA =)
17:48:26 <wagle> they do have CA machines
17:49:00 <shapr> Or maybe have a CPU that only takes up half the chip space, and when it's not busy it use a genetic algorithm or neural network to try to make more efficient versions of itself.
17:50:25 <shapr> Partial evaluation would have a whole new meaning if it modified your CPU.
17:50:35 <wagle> how does it know what its supposed to be doing?
17:50:43 <shapr> QuickCheck properties.
17:51:10 <wagle> actually, we applied partial evaluation to the linux kernel
17:51:19 <shapr> Oh really?
17:51:36 <shapr> And?
17:52:02 <wagle> under certain conditions, you can specialize a hotspot, but in others, you have to back off to a more general version of the hotspot code
17:52:32 <wagle> we published in a journal
17:53:24 <shapr> Where?
17:54:19 <wagle> http://citeseer.ist.psu.edu/mcnamee01specialization.html
17:54:40 <palomer_> >:o
17:54:51 <wagle> ?
17:55:02 <palomer_> so, erm, anyone have an upper bound on the complexity of reducing normalizable lambda terms?
17:59:12 * araujo got blind with a "monads implemented in java" post 
18:00:00 <wagle> whats wrong with that?
18:02:47 <wagle> that seems kind of interesting, actually
18:03:47 <wagle> araujo: where was this?
18:03:58 <araujo> comp.lang.functional
18:04:40 <wagle> http://www.ccs.neu.edu/home/dherman/code.html
18:07:21 <wagle> araujo: which thread?
18:08:49 <araujo> Benefits of dynamic typing.
18:08:57 <wagle> araujo: thanks
18:09:30 <TheHunter> palomer_, if there were such a computable upper bound, you could solve the halting problem.
18:11:02 <araujo> you welcome
18:16:55 <Pseudonym> Gotta go.  BBL
18:22:16 <SamB> @google untagged TLB
18:22:17 <lambdabot> http://i30www.ira.uka.de/teaching/coursedocuments/99/mkc-08-smalladdressspaces.pdf
18:22:46 * SamB thinks the CPU makers would have more to fear from the GCC of CPUs than the Linux of CPUs
18:22:49 <SamB> @google tagged TLB
18:22:52 <lambdabot> http://people.redhat.com/zaitcev/notes/glew_tag_tlbs.news
18:22:57 <SamB> @wikipedia TLB
18:22:59 <lambdabot> http://en.wikipedia.org/wiki/TLB
18:25:47 <SamB> @google Translation Lookaside Buffer
18:25:49 <lambdabot> http://www.cs.umass.edu/~weems/CmpSci635A/Lecture11/L11.18.html
18:26:01 <SamB> @google untagged Translation Lookaside Buffer
18:26:03 <lambdabot> http://www.cs.bu.edu/techreports/2003-014-user-level-sandboxing.ps.Z
18:26:32 * SamB decides he isn't feeling lucky anymore
18:27:50 <gord> SamB: "GCC of CPUs"?
18:29:22 <palomer_> the microsoft bob of CPUs
18:29:26 <SamB> you know how just about every free OS is built with GCC?
18:40:06 <yaarg> so is os x
18:45:13 <SamB> True
18:56:47 * SamB wonders how to do traps...
19:04:49 <cjs_> I have a couple of questions, if anybody has time.
19:09:17 <shapr> cjs_: Ask your questions, you may get an answer...
19:14:02 <RichN> whoa! slow down with all the questions...  :)
19:24:15 <cjs_> It's about this: http://perlmonks.org/?node_id=450922
19:24:30 <int-e> dons: ping
19:24:42 <cjs_> There's a discussion going on on LtU about it, but I'm wondering about his point #4, because it doesn't seem quite right to me.
19:25:09 <cjs_> (I'm just trying to translate his code into Haskell right now, but I'm having difficulty understanding his code. I hate perl.)
19:25:12 <shapr> cjs_: It's not right, the perl guy is talking about the old lazy stream based IO
19:25:16 <yaarg> that perl monks is full of shit
19:25:42 <CosmicRay> hi everyone.
19:25:42 <shapr> cjs_: er, wait.. I got confused...
19:25:44 <CosmicRay> I have some very weird problems with haddock.
19:25:50 <CosmicRay> It used to work fine
19:25:52 <CosmicRay> now, on the same source, it is dying 100% of the time.
19:25:54 <CosmicRay> Here's an example:
19:25:56 <CosmicRay> http://darcs.complete.org/missingh/MissingH/Str.hs
19:26:03 <CosmicRay> It dies with an error over the "This module provides" line.
19:26:09 <CosmicRay> I've got haddock 0.7.
19:26:28 <CosmicRay> I can't prove it, but I suspect that either haddock 0.7 introduced the problem, or gcc 6.4-4.1 did.
19:26:37 <CosmicRay> dist/build/tmp/MissingH/IO.hs:39:1: parse error in doc string: [TokPara,TokString "This module provides various helpful utilities for dealing with I",TokString"/"]
19:27:23 <shapr> cjs_: Are you talking about not supporting assignment, or lazy evaluation for user input?
19:28:18 <shapr> cjs_: Ah, myth 4 is wrong.
19:28:51 <shapr> cjs_: This is wrong --> "So, theoretically, we could collect all the values that are stored in an lvalue during its life in the program, and store them in a list."
19:29:04 <yaarg> myth 4 is definitely wrong
19:29:22 <yaarg> in fact i can pick holes in every argument ;)
19:29:42 <shapr> cjs_: An lvalue only has one value ever.
19:30:05 <cjs_> Look for my comments (search for "Sampson") in the LTU thread to see where I'm coming from here: http://lambda-the-ultimate.org/node/view/678
19:30:28 <cjs_> But yeah, this is basically what I'm thinking; if x = 3, x is always and foreve?r 3 in that scope, right
19:30:44 <shapr> That's right.
19:30:59 <shapr> In fact, that particular value is never changed or over written.
19:31:19 <shapr> You may have something else named x, but it's not the same value/lvalue/whatever.
19:33:09 <shapr> cjs_: Is that clear?
19:33:13 <shapr> cjs_: Any other questions?
19:34:56 <cjs_> Yeah, what's wrong with my syntax here? :-) http://rafb.net/paste/results/eP9uPz22.html
19:35:15 <shapr> You're right about closures being functions that carry around their bindings.
19:36:12 <Korollary> Saying FP doesn't support variable assignment is like saying fire extinguishers don't support spray painting. They weren't meant to be used as such.
19:36:22 <cjs_> It doesn't even seem to me particularly inefficient, if all bindings are constant. Instead of a stack for the program, you have a tree, which each function effectively gets its own individual stack as a branch going back up the tree, right? And everybody shares.
19:36:45 <Cale> cjs_: change Int to Integer or generalise/remove the type signature on apply
19:37:46 <cjs_> I've tried both changing to Integer and removing, and either way Hugs gives me a type error.
19:37:51 <cjs_> I'll look more closely.
19:37:56 <shapr> cjs_: For implementation, alpha renaming is where every binding gets a unique name.
19:38:22 <shapr> That's one way of expliciting seeing that no lvalue is the same.
19:38:28 <shapr> explicitly*
19:38:30 <shapr> I need sleep.
19:38:36 <cjs_> Oh, never mind. I was an idiot. After reading the file, I was typing "apply ops" instead of "apply 0 ops".
19:38:48 <int-e> if anyone wants to play around with the fast integer printing code I made yesterday, there's an updated version as a standalone module at http://www.inf.tu-dresden.de/~bf3/ghc/ ... I'd be particularily interested in some benchmark numbers from non-Athlon XP computers.
19:39:08 <shapr> Athlon MP?
19:39:15 <Cale> cjs_: also, isn't that just  apply v = map ($v)
19:39:24 <int-e> shapr: should be similar but heh, why not.
19:39:45 <cjs_> Yes, but I was trying to make it match exactly the guy's perl example.
19:39:45 <shapr> Can I run it with -smp 2 ? ;-)
19:40:00 <Cale> oh, I see
19:40:04 <Cale> it's a fold
19:40:16 <cjs_> And hey, I've been studying Haskell for like 2 days. :-)
19:40:26 <int-e> shapr: hmm. that's not quite what I intended ... but of course you should be able to do that.
19:41:05 <Cale> :)
19:41:10 <shapr> int-e: Is this dir a darcs repo?
19:41:20 <int-e> shapr: err, no.
19:41:28 * shapr doesn't want to manually click on a bunch of source files.
19:41:36 <int-e> shapr: let me make a tar.gz
19:42:26 <shapr> ok
19:42:32 <int-e> there
19:42:39 <palomer_> don't click!
19:42:47 <palomer_> shapr: do you use automated testing?
19:43:48 <shapr> palomer_: yup
19:43:57 <palomer_> shapr: does it catch all your bugs?
19:44:16 <palomer_> I'm talking about that cool haskell app that produces test cases for you
19:44:20 <palomer_> based on invariants
19:44:29 <shapr> It catches more bugs than unit testing alone.
19:45:21 <shapr> palomer_: Anyway, that's a rhetorical question, what's your point?
19:45:39 <palomer_> err, I was just curious as to how effective it is
19:45:41 <lispy> interesting thing about testing, i read a paper recently that showed that using block coverage as a test adequacy criteria can cause over confidence
19:46:37 <lispy> i would recommend using defintion-use coverage instead
19:46:39 <shapr> palomer_: There still isn't any silver bullet. QuickCheck is *far* better than unit testing alone, but it won't catch stuff like design errors.
19:47:21 <shapr> On the other hand, I think QuickCheck can keep you from needing to hire a QA department.
19:47:23 <Lemmih> Hi korcs.
19:47:55 <palomer_> what about quickcheck alone?
19:49:16 <shapr> QuickCheck doesn't let you specify values. It could do so without much work, but that means you don't get to choose a single end-to-end test value to begin with.
19:49:36 <cjs_> "definition-use" coverage? Is that as in, "make tests emulating how it's used, rather than tests that make sure they exercise every line of code"?
19:50:17 <lispy> cjs_: means your test hits both value definitions and where the value is used
19:51:23 <shapr> I wrote a TDD version of QuickCheck that does give more of the benefits of unit testing when using QuickCheck.
19:51:54 <shapr> (ok, it was just a few lines added to QuickCheck, not really a 'version')
19:52:16 <shapr> 48500000 --> (N.jtos) time=4886257000000
19:52:16 <shapr> 48500000 --> (O.jtos) time=4446325000000
19:52:18 <lispy> icfp is in portland this year
19:52:23 <lispy> i'm hoping to go
19:52:26 <shapr> lispy: Are you also in portland?
19:52:32 <lispy> shapr: no, but very close
19:53:00 <shapr> I'd like to go to the next ICFP. I could visit my family (Alabama) before or after.
19:54:46 <cjs_> Oh, wait, I think I get the issue with #4 now. Basically, he's like, well, we can make a list of all the values of the "variable" throughout the lifetime of the program, and get the one at time t by asking for "value of that variable at time t".
19:55:13 <cjs_> But it seems to me that the Good Thing or whatever about FP is that it forces you to be explicit, you have to specify that t.
19:55:25 <shapr> huh?
19:55:51 <cjs_> You can't ask for the "current" one because there is no "current." That array aways contains all of the values throughout the life of the program (albeit maybe some not yet calculated).
19:57:34 <shapr> Upon rereading, I think he's saying that, under the hood, you have to use destructive assignment at some point because you only have so much memory. So you really are being imperative.
19:57:46 <shapr> Maybe?
19:58:54 <cjs_> I'll buy that. And it explains his take on Church's thesis, too.
19:58:59 <shapr> cjs_: After staring at it some more.. I think he's just wrong.
19:59:34 <shapr> "So, theoretically, we could collect all the values that are stored in an lvalue during its life in the program, and store them in a list."
19:59:35 <cjs_> So basically, if we go with that take, what he's saying is that we're effectively doing non-FP programming in the end, even if it looks like FP to us.
20:00:04 <shapr> That line I just quoted is wrong. An 'lvalue' has only one value throughout the entire lifetime of the program.
20:00:17 <shapr> I think he's confusing variable name with actual 'lvalue'.
20:00:28 <cjs_> Same as with the integers--it looks to us like we're doing simple integer arithemetic all the time, but in fact it may be up to 2^31, but after that it turns into something more complex underneath the hood.
20:01:05 <cjs_> In which case his argument reduces to stupidity; you may not see it, but something else is really happening. The whole point is that we don't see what's "really" happening, so that life is simple!
20:01:41 <shapr> int-e: http://www.scannedinavian.org/~shae/jtos.shapr
20:02:13 <int-e> shapr: looks good :)
20:02:15 <shapr> cjs_: Any of the possible interepretations I can come up with are wrong.
20:02:30 <shapr> Or even worse, clueless.
20:05:43 <shapr> Myth 3 and 4 look the same to me.
20:05:50 <int-e> shapr: thanks
20:07:47 <shapr> cjs_: Actually, myths 1, 3, and 4 are the same.
20:08:43 <shapr> Basically, that this guy doesn't understand referential transparency.
20:08:53 <ozone> what on earth are you guys dissecting?
20:09:31 <shapr> ozone: http://perlmonks.org/?node_id=450922
20:09:51 <int-e> shapr: yes, the replacement loses out slightly for very small numbers; I'd argue it's worth it.
20:10:00 <ozone> oh, that rant
20:10:07 <shapr> Myth 1 says that lazy evaluation doesn't work because referential transparency doesn't exist.
20:11:12 <ozone> *shrug*  person gets details of FP wrong, news at 11
20:12:00 <shapr> Myth 3 says that referential transparency doesn't exist because ... I don't understand what he's saying actually.
20:12:14 <shapr> Myth 4 says that FP really does have assignment because referential transparency doesn't exist.
20:12:16 <ozone> shapr: i think he's saying that for FP in general, which is true
20:12:45 <shapr> It appears that he assumes Haskell for this article.
20:12:59 <shapr> He also says that Haskell isn't declarative.
20:13:15 <ozone> i don't see a mention of haskell anywhere in that article
20:13:23 <ozone> oh, my bad
20:15:15 <Cale> Haskell isn't as declarative as languages could get, but it's fairly declarative.
20:16:34 <shapr> Ah, Myth 3 says that referential transparency doesn't exist because variables are mutable.
20:17:20 <shapr> or not?
20:17:31 <shapr> Can someone explain myth 3 to me?
20:18:42 <shapr> I swear Myth 3 looks like the Wookie defense to me.
20:18:58 <Cale> myth 3 is "I don't know how to thread state in function parameters or use state monads, so referential transparency is not a desirable feature of programming languages."
20:19:04 <cjs_> He does say at one point that Haskell isn't declarative.
20:19:53 <shapr> "And because length "three" is not 3, referential transparency does not exist."</parody>
20:20:14 <cjs_> Oh, I remembered my other question!
20:20:17 <Lemmih> What myths are you guys talking about?
20:20:26 <shapr> Lemmih: http://perlmonks.org/?node_id=450922
20:20:28 <shapr> cjs_: ask us!
20:21:09 <shapr> @wikipedia "Chewbacca Defense"
20:21:11 <lambdabot> http://en.wikipedia.org/wiki/Chewbacca_Defense
20:21:12 <cjs_> How do I submit something to that Haskell quotes page? The one with all the IRC stuff.
20:21:24 <cjs_> Because I found this little gem on #ruby-lang the other day:
20:21:25 <shapr> cjs_: Edit it and put the content in.
20:21:25 <cjs_> <shevegen> haskell is cool but i personally find it very difficult
20:21:25 <cjs_> <GnuVince> That being said, I hear it's a very nice and fun language,
20:21:25 <cjs_>     although some things are hard to do in a purely functionnal way
20:21:25 <cjs_> <chris2> i prefer less strict languages
20:21:32 <Cale> I remember seeing that perlmonks rant a year or so ago, and thought it was stupid.
20:21:33 <cjs_> (Oops, meant to nopast the link.)
20:21:37 <cjs_> http://rafb.net/paste/results/t9Pluk44.html
20:21:59 <shapr> cjs_: haha, punny!
20:24:58 <int-e> so basically this guy is saying that a programming language can't have constants ...?
20:25:18 <lispy> yeah, he says all FP langs are imperative, but what he means is that most FP langs are operational and futhermore support destructive modification.  But, I'd say neither of those apply to haskell
20:27:43 <retepybrik> this is neat, a browser written in Haskell: http://www.cs.chalmers.se/~hallgren/Thesis/wwwbrowser.html
20:27:46 <int-e> I mean that's the point - all Haskell programs just define a few constants and then interpret the main constant.
20:28:39 <lispy> his example code has a horrible syntax, that isn't a real language is it?
20:29:49 <lispy> in myth 3 how is it, that y != 3?
20:30:02 <int-e> could be Perl ...
20:31:50 <shapr> lispy: x != 3 because he used x++
20:32:11 <lispy> yeah, but why would y != 3?
20:32:28 <shapr> Where does he say that?
20:32:39 <lispy> he seems to imply it with the comment
20:32:44 <int-e> "functional programming doesn't support lvalues." - and that's the point, isn't it? You just don't need them.
20:33:04 <int-e> he keeps mixing implementation and language levels :/
20:33:06 <lispy> shapr: otherwise i don't see why he wasted his time with the example
20:33:29 <shapr> lispy: According to him, the value of x changes.
20:33:47 <shapr> So then x != y at some point.
20:34:06 <shapr> If we alpha renamed this code, things would look very different.
20:34:15 <shapr> It would be z = x + 1
20:35:26 <lispy> Oh, yeah, it's so obvious that x != y that i didn't realize he was trying to make an example out of it
20:35:51 <lispy> and yeah, x gets killed
20:36:37 <lispy> man, this syntax is so bizzare to me "my $inc = sub { return ($_[0] + 1) };"
20:36:39 <shapr> His code won't work in Haskell.
20:36:59 <shapr> Have you ever tried to do x = x + 1 in Haskell?
20:37:12 <lispy> @eval let x = x + 1 in x
20:37:32 <cjs_> Which example, the last one?
20:37:34 <lambdabot> Loop
20:37:43 <cjs_> That's perl. "Eww." Well known for its disasterous syntax.
20:38:20 <int-e> perl is a powerful write-only-language for small to medium text processing ... harhar (hopes no perl addict is listening)
20:38:27 <shapr> lispy: That's roughly equivalent to "let ones = 1 : ones in length ones"
20:38:28 <cjs_> But it translates quite well into Haskell, I think: http://rafb.net/paste/results/3XVOZE77.html   I did it as a little exercise.
20:39:34 <lispy> he seems to use variables without ever defining them
20:39:34 <cjs_> And the typechecker even found a bug in my first go at apply1! You can't dream of how nice that is after two years of ruby.
20:39:39 <lispy> that's a little creepy
20:39:46 <cjs_> They're defined when you assign to them.
20:40:02 <lispy> but he has "if (@etc) {"
20:40:10 <lispy> and i don't see where @etc is defined
20:40:34 <int-e> my ($val, $func, @etc) = @_;
20:40:48 <lispy> that assigns to @etc?
20:40:51 <int-e> yes
20:40:54 <lispy> wow
20:41:01 <cjs_> "my ($val, $func, @etc) = @_;"
20:41:02 <lispy> i thought my was a function or something
20:41:07 <int-e> it's a tuple assignment. Perl has those, Python has those.
20:41:14 <shapr> I think my means "create these variables"
20:41:21 <cjs_> That's almost like a pattern match, actually.
20:41:25 <int-e> it's a predecessor of pattern matching ...
20:41:52 <cjs_> Yes, $val gets the first element of the array of arguments passed to the function (@_), $func gets the second, and the array @etc gets the rest.
20:42:04 <lispy> ah
20:42:25 <lispy> apply (val:func:etc) = ...
20:42:41 <lispy> actually
20:42:57 <lispy> apply (val:func:[]) = (val, func val)
20:43:26 <lispy> apply (val:func:etc) = (val, apply (func (val, etc)))
20:43:30 <lispy> or something like that
20:43:44 <lispy> but of course that doesn't type check
20:45:57 <cjs_> http://rafb.net/paste/results/YPMHMn43.html
20:46:26 <cjs_> You know, I never thought about that (x, y, z) = a thing as a predecessor of pattern matching. Interesting.
20:47:51 <cjs_> Just curious about a little technical issue: in that code I just pasted, is the compiler going to memoize "func val" in apply1, if the second branch is taken?
20:49:07 <int-e> cjs_: it will likely find that term during common subexpression elimination and only evaluate it once
20:49:52 <int-e> (i.e. the code will be transformed to a let func_val = func val in ...
20:49:53 <int-e> )
20:51:33 <cjs_> Ah, I see. Cool.
20:55:23 <Lemmih> dons: ping.
20:56:37 <SamB> Haskell is faster than almost-purely functional C with pseudo-algebraic datatypes ;-)
21:00:35 <gzl> SamB: it's faster than C?
21:03:59 <cjs_> I think that translates as, "it depends on how you write the C."
21:04:19 <SamB> gzl: only sometimes. in particular, a direct translation of the C Unlambda interpreter to Haskell goes a bit faster, at least on my computer ;-)
21:05:02 <SamB> if you then some of the algebraic datatypes with functions, it goes even faster
21:05:38 <gzl> ok.
21:05:42 <int-e> SamB: *the* C unlambda interpreter?
21:06:59 <SamB> well, the one in unlambda-2.0.0/c/
21:07:27 <int-e> SamB: shameless plug: try http://www.inf.tu-dresden.de/~bf3/unlambda/unlambda.c [tried to get it into the CUAN but never got a reply for my mail]
21:07:59 <SamB> int-e: yeah, I tried to get my Haskell version in too ;-)
21:08:08 <SamB> well, one of them anyway.
21:08:46 <int-e> SamB: actually my C version is derived from a Haskell program, hehe.
21:09:09 <int-e> SamB: (and if I were to reimplement it, I'd code a proper garbage collection)
21:09:13 <SamB> I tried to write one in Haskell directly, but I kept running into trouble
21:09:50 <int-e> hmm. well, there's a Haskell version in the same directory.
21:09:52 <SamB> so is this faster than the one in the distribution?
21:10:05 <int-e> SamB: last I measured it, it was.
21:10:15 <int-e> SamB: it's been a few years
21:10:19 <SamB> is it faster than your Haskell version?
21:10:27 <int-e> SamB: yes
21:10:35 <int-e> SamB: (with the same restriction)
21:10:38 <SamB> does it actually run all the example code correctly?
21:10:51 <int-e> SamB: that too.
21:11:52 <SamB> hmm, I can't help but notice that your Haskell version is using ADTs. I'm not sure ADTs are optimal...
21:12:16 <int-e> SamB: they probably aren't.
21:12:43 <int-e> SamB: but they're nice and clean :)
21:20:23 <SamB> compare with http://naesten.dyndns.org:8080/unlambda-2.0.0/hs/unlambda.hs and http://naesten.dyndns.org:8080/unlambda-2.0.0/hs-idiomatic/unlambda.hs
21:21:11 <SamB> though note that you might want to stash them somewhere, because I'm on dialup and the connection could go down at the least convenient time possible
21:24:50 * SamB wonders why he didn't change Function to a closure-based implementation too...
21:25:39 <SamB> anyway, note the use of StateT (Maybe Char) IO
21:27:09 <SamB> also note that the blatant overkill of using Parsec to parse Unlambda doesn't seem to have negatively impacted my speed too much
21:27:18 <int-e> I wouldn't have understood that when I wrote that code ;)
21:27:51 <int-e> Well, parse time is negligible, at least for interesting programs.
21:28:23 <SamB> yeah
21:28:34 <SamB> thats what I figured too, I guess ;-)
21:28:48 <SamB> so might as well do it the easy way ;-)
21:29:27 <SamB> BTW, what is '/' for?
21:30:28 <int-e> SamB: / is like | but generates ?x instead of .x atoms
21:30:41 <SamB> is it in the spec?
21:31:01 <int-e> SamB: I implemented that when I thought about an unlambda interpreter in unlambda; I never got around to do that though
21:31:09 <SamB> ah
21:31:21 <int-e> SamB: no it isn't. It doesn't change the semantics of any valid programs though.
21:31:38 <SamB> true ;-)
21:31:49 <int-e> SamB: it's not strictly necessary of course but the corresponding unlambda term is quite big.
21:32:22 <SamB> I wouldn't know such things
21:32:36 <SamB> I don't actually know how to write Unlambda code ;-)
21:33:37 <int-e> SamB: first step, create a lambda to ski-calculus converter ;)
21:33:55 <SamB> yeah, that does sound like a good idea.
21:34:36 <SamB> would make a good lambdabot plugin ;-)
21:35:49 <int-e> hehe
22:21:37 <dons> Lemmih, pong
22:22:52 <Lemmih> dons: GHCi chokes on duplicate symbols.
22:24:56 <SM_ax> does anybody have access to this (http://portal.acm.org/ft_gateway.cfm?id=224987&type=pdf) paper?
22:25:52 <Lemmih> dons: And I'm having problems compiling hs-plugins with 6.5
22:27:24 <int-e> @where stm
22:27:25 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
22:28:35 <dons> Lemmih, yeah, it does choke on some duplicates
22:28:48 <dons> hmm. problems?  i use 6.5 with no problems atm
22:29:01 <Lemmih> dons: src/AltData/Typeable.hs:452:0: parse error (possibly incorrect indentation)
22:29:10 <dons> hmm. cpp?
22:29:32 <Lemmih> dons: cpp (GCC) 4.0.2 20050821 (prerelease) (Debian 4.0.1-6)
22:29:38 <dons> or you don't have Typeable.h?
22:30:03 <dons> that's a weird one. better check the cpp output to find out what exactly is happening
22:30:38 <SM_ax> int-e, thanks
22:30:50 <Lemmih> Is AltData needed, btw?
22:30:58 <int-e> SM_ax: it's a different paper. sorry.
22:31:10 <dons> yep.  unless you make the applications dynamic from the ground up
22:31:25 <dons> details in the hs-plugins paper
22:31:36 <dons> it's just a bug that requires a bit of C to fix
22:32:38 <SM_ax> int-e, ok, maybe it will do
22:33:09 <Lemmih> dons: I got around it in HSP with some unsafe* hacks.
22:33:43 <dons> hmm.
22:33:57 <Lemmih> dons: INSTANCE_TYPEABLE1 doesn't get expanded and I don't have Typeable.h
22:33:57 <dons> but the you break all dynamic type checks?
22:34:06 <dons> that's super-weird then
22:34:21 <dons> paprika$ pwd
22:34:21 <dons> /home/dons/lib/ghc-6.5
22:34:21 <dons> paprika$ ls include/Typeable.h
22:34:21 <dons> include/Typeable.h
22:34:57 <Lemmih> Ah. Thought you meant in the hs-plugins repo.
22:37:54 <SM_ax> hehe, found it on citeseer :)
22:39:55 <Lemmih> dons: I needed -I/usr/lib/ghc-6.5/include
22:44:04 <dons> yep. if you use ghc with cpp, it should add the flag by default, right?
22:44:21 <cjs_> Wow, this ICFP thing sounds fascinating. I need to get out to one of those one day.
22:44:26 <dons> I'm confused why extensions:           CPP isn't being employed?
22:44:33 <dons> or it is, but not with thhe right path.
22:44:55 <Lemmih> the CPP extension just adds -cpp.
22:45:48 <dons> yeah, and ghc should add the paths to it's headers
22:45:52 <dons> what does ghc -v say?
22:45:58 <Lemmih> (I disabled the duplicate symbols checking for the time being)
22:46:23 <dons> ok.
22:46:34 * dons has to  go to haskell wshop now. back later.
22:47:03 * Lemmih would like to stay clear of all non-hide issues related to ghc 6.5
22:47:14 <Lemmih> Bye. Have fun.
23:27:55 <autrijus> mm droundy has different ideas of 'crazy amount of hours' :)
23:30:14 <stefanw> is this a live report from HW?
23:31:43 <autrijus> stefanw: aye
23:32:10 <autrijus> now in the second talk
23:32:18 <Heffalump> autrijus: he has a real job too...
23:32:19 <autrijus> Visual Haskell (which I still can't manage to install)
23:32:43 <autrijus> Heffalump: I do too... multiple ones :) but I think I'm built in with  unsafeInterleaveJobs
23:34:42 <autrijus> ...or unsafeLeaveJobs
