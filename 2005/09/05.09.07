00:00:46 * gour taking breakfast
00:01:20 * ski dittos
00:05:47 * boegel bounces
00:14:18 <shapr> @yow !
00:14:19 <lambdabot> The FALAFEL SANDWICH lands on my HEAD and I become a VEGETARIAN ...
00:14:41 <ski> @arr
00:14:42 <lambdabot> I heard andersca is a pirate
00:14:43 <shapr> It's a byootiful day in the 'hood!
00:14:58 <ski> it's cloudy
00:15:06 <ski> and rains predicted
00:15:14 <shapr> Yeah, a bit cloudy here. We just got a bunch of rain though.
00:15:15 <ski> s//'/
00:15:41 <ski> though i'm happy there is not much sun
00:16:39 <shapr> I like sun.
00:17:02 <ski> me too, but not too bright
00:17:14 <ksensei> Hey guys. I'm sorry if this is a noobish question, but do you know if the SOEGraphics lib is working in Gentoo?
00:17:56 <ulfdoz> Does it work on any other distro?
00:17:58 <shapr> ski: I'm convinced I must be photosynthetic. I'd run around nude in the 24 hour summer sun if it wouldn't turn me into a crispy lobster shape.
00:18:23 <ksensei> ulfdoz, I guess so, there are binaries on the web page. :)
00:18:27 * ski shapr : hehe :D
00:18:35 <ski> um ..
00:18:35 <shapr> ksensei: It does work, but it's a pain in the butt to install on most distros. You need to install greencard, hsx11, and some other bits.
00:19:13 <shapr> ksensei: Finns ocks√• #haskell.se
00:19:24 <shapr> Though it's not nearly as large.
00:19:25 <ksensei> shapr, ok, thanks.
00:19:39 <ulfdoz> ksensei: The it works on gentoo as well.
00:20:11 * shapr pokes tmoertel with a Perl regex.
00:20:59 * ski recently pondered how to do monad-like things in logic programming .. e.g. dcg is a bit like parser monad but also like writer monad (in a different use)
00:21:05 <shapr> pejo: finns det en LTH irc kanal?
00:22:22 <earthy> http://www.dataretentionisnosolution.com/
00:24:09 <pejo> shapr, LTU. ;) Inte som jag k‰nner till.
00:24:16 <shapr> okej
00:24:20 <shapr> god morgon pejo!
00:24:24 <pejo> Morrn shapr!
00:25:05 <Itkovian> earthy: think that will help?
00:26:11 <dons> gour, why do you think it was a problem with hs-plugins?
00:34:10 <gour> dons: i had the same problem as when trying to build yi
00:34:52 <gour> dons: i.e.: lambdabot: magic number mismatch: old/corrupt interface file?
00:36:13 <boegel> earthy: well, I've never seen a problem in people following me
00:36:27 <boegel> if they think my life is interesting, go ahead, I don't care really :)
00:40:06 <boegel> hey Guest335892438, interesting nick ! :)
00:40:25 <Guest335892438> stupid networks :P
00:41:12 <earthy> boegel: the problem is in the investments the ISPs must make to make data retention possible
00:41:24 <earthy> investments that will directly translate into you paying more for your internet access.
00:41:47 <earthy> oh, and it doesn't provide you any benefit whatsoever. :)
00:41:55 <earthy> itkovian: yes, I think that will help
00:42:00 <dblhelix> boegel: I actually think earthy is following *me*: about five days a week, he enters my room shortly after I arrive, only to leave when I've left ;)
00:42:13 <earthy> I live with the illusion that democracy actually works
00:42:28 * Muad_Dibber agrees on that earthy
00:42:34 <Muad_Dibber> but not only the illusion, also the hope :P
00:42:50 <gour> democracy = demoncrazy (i saw it once)
00:44:10 <earthy> it's just the 'without encroaching on the interests of the minority' that sometimes fails
00:44:11 <dblhelix> earthy: well, it may take some time, but eventually you'll find out that it's just another sucky system
00:44:25 <earthy> oh, I *know* democracy sucks
00:44:37 <earthy> all political systems suck
00:44:41 * Itkovian is all in favor of a beneficial enlightened despotism
00:44:46 <earthy> it's just that democracy sucks less. ;)
00:44:47 <dblhelix> I think democracy is okay, for I can't see a better alternative...
00:44:52 <dblhelix> indeed
00:46:18 <Muad_Dibber> totally true dblhelix :)
00:46:33 <Muad_Dibber> however, if all people where perfect people then socialism might work as well
00:46:50 <earthy> ah.
00:46:52 <earthy> big if, there
00:47:11 <Muad_Dibber> an unsatisfiable if even :)
00:47:27 <dblhelix> Muad_Dibber:  an implication with falsum as antecedent is just an hollow statement
00:47:36 <Muad_Dibber> yeh
00:47:40 <dons> gour, are you using ghc 6.5  from a few months ago?
00:47:43 <Muad_Dibber> any decent compiler would optimize it away
00:47:54 <dblhelix> Muad_Dibber: indeed
00:48:01 <earthy> um.
00:48:05 <gour> ghc: 6.4.1.20050801
00:48:29 <earthy> any decent prooftool would leave it be
00:48:41 <earthy> knowing that there was probably a reason for stating it like that
00:48:53 <dblhelix> Muad_Dibber: admittedly, human beings tend to implement these kind of optimisations towards socialism not before they hit their twenties
00:49:33 <earthy> social democracy?
00:49:37 <earthy> like, most of europe? :P
00:49:38 <dons> gour, some time around there the .hi file format changed. august 18 works, at least. i thought this was just in the head branch though. but since you're the only person reporting this, i'm fairly sure it is the .hi issue.
00:49:41 <Muad_Dibber> anarchy all the way!
00:49:44 <Muad_Dibber> *cough*
00:50:11 <earthy> 'Why do anarchists drink herbal tea?'
00:50:21 <dons> if you can get more info gour, i'll have a look
00:50:21 * boegel hits Muad_Dibber on the head with a hammer
00:50:24 <earthy> 'Because proper tea is theft!'
00:50:30 <boegel> thank you for you belongings, they are mine now
00:50:33 <earthy> (bad pun, *bad* bad pun)
00:50:42 <Lemmih> Why is it theft?
00:50:51 <boegel> Lemmih: proper tea -> property
00:51:08 <Lemmih> haha (:
00:51:12 <dblhelix> now that we've done enough to provide the echelon people with a day's work, I think I'll go focussing on problems that might be solved again
00:51:25 * earthy too
00:51:45 <Pseudonym> Why do I get the impression that the ghost of Smerdyakov is haunting us?
00:52:06 <boegel> here is Osama Bin Laden, attack US, bomb the world, peace ! (have fun :) )
00:52:48 * boegel wonders why the SWAT people are doing outside
00:52:54 <boegel> s/why/what
00:53:12 <Itkovian> they are repairing the roof of the other building :-)
00:53:55 <gour> dons: what info you need?
00:54:26 <Muad_Dibber> how to say "schoolreisje" in english boegel? :P
00:54:39 <Itkovian> school trip?
00:54:51 <Muad_Dibber> of course :P
00:54:55 <earthy> has a somewhat different ring to it, doesn't it? :)
00:54:55 * Muad_Dibber just not fully awake yet :P
00:55:13 <Itkovian> for you high Dutch, maybe yes earthy
00:56:11 <earthy> wow, 'high dutch'. that's, like, a huge oxymoron. :)
00:56:28 <earthy> anyway, time to be slightly more productive
00:56:53 <Muad_Dibber> yeh, before some doaitse is on your back :P
01:00:08 * boegel just finished the 0.9.4 draft of his project proposal and prints it to get comments on it
01:01:40 <Muad_Dibber> gl :)
01:02:49 <boegel> Muad_Dibber: thanks :)
01:07:08 <kzm> Dataflow programming: we put the junk in junction!
01:08:26 * boegel reeds HWN
01:10:50 <boegel> pretty short this week, but hey, it an addition to my current collection :)
01:11:09 <dons> gour, a complete transcript of yi building and failing, for example. or try building and installing hs-plugins from scratch from darcs. there could be an issue there
01:15:44 <Itkovian> any Parsec adepts around?
01:17:00 <basti_> hi
01:18:23 <Muad_Dibber> <- going home
01:31:23 * boegel dances on 'Beck - Loser'
01:38:36 <boegel> xerox: any more cool progress ? just saw the 2nd Sept post on your blog, cool pics !
01:47:05 <ulph> @bot
01:47:06 <lambdabot> :)
01:47:54 <ulph> @yow
01:47:55 <lambdabot> Sign my PETITION.
01:48:26 <Cale> boegel: oh, where is his blog again?
01:48:53 <boegel> Cale: http://haskell.org/gtk2hs/archives/category/cairo/
01:49:22 <boegel> Cale: gotta love those screenshots :)
01:49:46 * gour is away: busy
01:50:06 <Cale> :)
01:50:08 <Cale> yeah
01:51:29 <Cale> and the weighted randomness he mentioned shouldn't be too hard -- I tried it today :) I should get the GTK frontend of his -- so far I've just been manipulating strings :)
01:52:08 <boegel> Cale: yeah, you should, that would make experimenting with it 10x more fun :)
01:53:45 <ProfTeggy> G'day all.
01:54:43 <boegel> hello ProfTeggy
01:54:57 <boegel> ProfTeggy: new here ?
01:58:43 <ProfTeggy> boegel, yes, in a sense
01:58:48 <ProfTeggy> I'm not new to Haskell, but to this channel.
01:59:16 <ProfTeggy> I just saw some articles of mine referenced by people in this channel so I thought I'd stop by and say 'Hi'
01:59:26 <ProfTeggy> (Google also indexes the logs of this channel.)
02:00:00 <kosmikus> hi ProfTeggy
02:00:05 <boegel> ProfTeggy: yeah, there a lot's of interesting people in here
02:00:28 <boegel> ProfTeggy: there are also a lot of tools and information sources available thorugh this channel
02:00:34 <boegel> lambdabot, say hi to the nice man
02:00:36 <boegel> @yow
02:00:37 <lambdabot> HUMAN REPLICAS are inserted into VATS of NUTRITIONAL YEAST ...
02:00:46 <boegel> for example
02:00:50 <boegel> @type foldr
02:00:52 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
02:00:55 <dons> say hi to the nice man
02:01:00 <dons> oops
02:01:11 <boegel> @eval map (*5) [2,4..10]
02:01:12 <lambdabot> say hi to the nice man
02:01:14 <lambdabot> [10,20,30,40,50]
02:01:36 <dons> sorry boegel, continue the tour
02:02:27 <boegel> also, there's HWN composed by CosmicRay @ http://sequence.complete.org/
02:02:34 <dons> @hawiki
02:02:35 <lambdabot> http://www.haskell.org/hawiki/
02:02:37 <boegel> there's shapr, the walking Haskell library
02:02:44 <boegel> yes, there's the Haskell wiki pages
02:02:53 <ProfTeggy> kosmikus, is that you, Andres?
02:02:59 <boegel> there's TMR, a nice Haskell monthly (ahem) magazine
02:03:00 <dons> also, @where indexes a lot of common projects
02:03:03 <dons> @where ghc
02:03:05 <lambdabot> http://haskell.org/ghc
02:03:14 <boegel> ProfTeggy: have you heard about TMR and HWN ?
02:03:24 <kosmikus> ProfTeggy: yes
02:03:34 <boegel> TMR is available at http://haskell.org/tmrwiki
02:03:43 <ProfTeggy> boegel, browsing as we speak...
02:04:00 <boegel> hmm, have I forgotten something ?
02:04:01 <ProfTeggy> kosmikus, hi then :-)
02:04:16 <dons> oh, @lambda
02:04:27 <kosmikus> ProfTeggy: nice to see you here; doing something Haskell-related atm?
02:04:27 <ProfTeggy> kosmikus, I'm working from home today and thought a brief IRC chat couldn't hurt ;-)
02:04:39 <boegel> many people in here are working on interesting stuff: xerox is the Cairo binding man, Lemmih has SDL stuff, dons does darcs, ...
02:04:55 <boegel> ProfTeggy: are you a real professor ?
02:05:04 <dons> Igloo does darcs, I tend to do yi or hs-plugins :)
02:05:04 <kosmikus> he is
02:05:05 <ProfTeggy> kosmikus, well, my prototypical XQuery to relational algebra compiler is written in Haskell, of course.  It's the most substantial Haskell piece I've ever written
02:05:07 <ProfTeggy> boegel, yes
02:05:18 <ProfTeggy> boegel: http://www-db.in.tum.de/~grust/
02:05:34 <boegel> dons: oh, okay, sorry :)
02:05:59 <boegel> ProfTeggy: haskellDB might interest you
02:06:02 <boegel> @where haskelldb
02:06:02 <lambdabot> http://haskelldb.sourceforge.net/
02:06:05 <Itkovian> ProfTeggy: I like the Jana pic ;-)
02:06:07 <dons> boegel, I just submitted some code back to darcs recently :)
02:06:23 <boegel> dons: oh, hence my mistake
02:06:29 <ProfTeggy> Itkovian, thanks ;-)
02:06:54 * boegel likes it too (http://www-db.in.tum.de/~grust/jana/jana-scientific.jpg)
02:06:59 <ProfTeggy> In that picture she's reading a picture that later became quite interesting in my research... at that time I didn't know yet
02:07:09 <ProfTeggy> s/picture/paper/
02:07:55 <boegel> ProfTeggy: Itkovian has produced a little boy recently :) It's becoming a baby boom in here :)
02:07:58 <kosmikus> ProfTeggy: how's life in munich?
02:08:10 <basti_> expensive?
02:08:14 * kosmikus is in Bonn now ...
02:08:41 <ProfTeggy> boegel, I'll be a father for a second time in about 8 weeks
02:08:45 * boegel knows someone who's moving to munich because her 4-month bf foudn work there (crazy people, sigh)
02:08:59 <ProfTeggy> kosmikus, MUC is great.  Working at TUM is a real  experience
02:09:00 <Itkovian> btw, did you know erm, Joubert at Clausthal?
02:09:00 <boegel> ProfTeggy: w00 ! be sure to tape everything and show it to us ;)
02:09:16 <ProfTeggy> Itkovian, of course.
02:09:57 <Itkovian> I met him once during a seminar on parallel computing, where mainly (his?) Master Thesis students gave presentations ...
02:09:58 <ProfTeggy> Itkovian, what's your connection to Clausthal?
02:10:05 <ProfTeggy> I see.
02:10:06 <Itkovian> I've been there once
02:10:28 <ProfTeggy> kosmikus, what kind of contract do you have with U Bonn?
02:10:37 * boegel signs: "It's a smaaal world aaaafteraaaall"
02:10:41 <Itkovian> ProfTeggy: good restaurant ;-)
02:11:00 <kosmikus> ProfTeggy: 2(+1) year dfg grant, bat IIa, no teaching
02:11:10 <ProfTeggy> Itkovian, tell me, because I'll be in Clausthal this September to hold examinations
02:11:52 <ProfTeggy> kosmikus, aha!  If I were you, I'd participate in teaching, though.
02:11:59 <ProfTeggy> Pick the fun pieces. ;-)
02:12:00 <kosmikus> ProfTeggy: I will :)
02:12:04 <Itkovian> well, I meant the uni restaurant. It was pretty good food there
02:12:11 <ProfTeggy> Itkovian, oh OK.
02:12:18 <kosmikus> ProfTeggy: yes, still an advantage to be able to choose ;)
02:12:24 <Itkovian> we also had pizza in town, but I really can't recall where exactly
02:12:25 <boegel> Itkovian: so has our restaurant
02:12:32 <Itkovian> boegel: erm. no.
02:12:44 <boegel> Itkovian: I quie like it really
02:12:49 <boegel> s/quie/quite
02:12:53 <Itkovian> the meatballs perhaps :-)
02:13:03 <boegel> and some other things
02:13:46 <boegel> the vol-a-vent (does that have an English name for it, because some guy asked me this week, and I had to help him pronounce it to make sure he wasn't getting anything else on his plate)
02:14:07 * boegel checks what today's specials are
02:14:22 <boegel> mmmm, lasagna :D
02:15:42 <Itkovian> well, I got sick after last weeks lasagna so ...
02:16:11 <boegel> Itkovian: like hell that was the lasagna's fault :) lasagna can't cause a head ache afaik
02:16:27 <Itkovian> but a sore set of bowels it can cause
02:16:56 <boegel> tss, you're just weak :p
02:22:10 <boegel> lol, Luk heeft iets afgeprint op de printer in het Spraaklabo :)
02:22:14 <boegel> woops :)
02:22:33 <boegel> my mistake :s :)
02:26:40 <boegel> ProfTeggy: how do you like HWN and TMR ?
02:30:16 <ProfTeggy> First of all I didn't know of their existence which is a shame.
02:31:20 <boegel> ProfTeggy: well, now you do know, so spread the word !
02:32:14 <ProfTeggy> Whos is behind TMR?
02:32:53 <boegel> shapr, Shae Ericsson
02:33:18 <boegel> well, basically, someone came up with the idea for a Haskell magazine
02:34:13 <boegel> and then I pushed shapr to go through with it
02:34:32 <boegel> the problem we have though is that there are not enough authors to publish an issue each month
02:34:42 <ProfTeggy> I can imagine...
02:34:42 <boegel> more people reading it could resolve that issue
02:35:44 <boegel> ProfTeggy: maybe you know some people who are interested in it, and could find the time to write a small article for it ? i know shapr would be pleased with that (and so will everyone else, including me)
02:36:47 <ProfTeggy> Hmm, problem is that many of the (knowledgeable) folks I know are usually bogged down in work.
02:37:19 <boegel> anyway, more people reading it could help, right ? so spread the word ;)
02:37:40 <xerox> Moooorning.
02:37:55 <ProfTeggy> Bookmarked.  I'll let the FP-inclined colleagues in my vicinity know.
02:37:58 <boegel> hey xerox
02:38:04 <boegel> ProfTeggy: great !
02:38:21 <xerox> So, you're pushing for the Gtk GUI, I should finish it :-)
02:38:51 <boegel> I'm not, Cale was ;)
02:39:06 <Itkovian> boegel: maybe we should notify kdb, eh
02:39:32 <boegel> Itkovian: about TMR ?
02:39:42 <xerox> The baby reading the paper is a so nice pic...
02:40:05 <boegel> reading ? playing ! ;)
02:40:52 <Itkovian> boegel: yes.
02:40:59 <ProfTeggy> By the way, it is this paper:  http://db.uwaterloo.ca/~david/papers-sigmod03.pdf
02:42:20 <xerox> I was about to ask, thanks =)
02:42:36 <boegel> Itkovian: well, he isn't doing on FP related research dough, is he ?
02:43:14 <Itkovian> no, but he might be interested teaching-wise
02:43:57 <boegel> you might as well mention them, right ?
02:51:11 <Itkovian> hmm...
02:51:24 <Itkovian> i shall mail him
02:51:30 <Itkovian> and point out yr work ;-)
02:51:45 * poetix browses the XQuery-SQL paper
02:52:27 <ProfTeggy> poetix, if this is of interest to you, may I point you to out work on the subject: www.pathfinder-xquery.org
02:52:32 <ProfTeggy> s/out/our/
02:52:33 * boegel blsuhes
02:52:38 <boegel> s<->u
02:53:00 <poetix> ProfTeggy: thanks
02:54:15 <poetix> I'm more interested in relational approaches to representing and manipulating tree-structured data in general than in XML and XQuery specifically
02:55:05 <ProfTeggy> poetix, oh, ok.
02:55:34 <ProfTeggy> poetix, I'm working on this topic since 2002
02:55:49 <ProfTeggy> (relational encodings of trees)
02:56:34 <ProfTeggy> The operations on these trees, however, are motivated by the urge to construct a purely relational XQuery runtime environment.
02:57:01 <ProfTeggy> So typical ops are decscedant/ancestor queries, validation, etc.
02:57:23 <ProfTeggy> But also order, sibling queries and the like.
02:57:32 <ProfTeggy> Also tree construction (tree pasting).
02:57:41 <poetix> It's a good test of the generality of the approach, if you can take a language designed to express operations over trees and translate it into a (sort-of) relational query language
02:57:59 * xerox slaps poetix
02:58:08 * poetix reels
02:58:21 <poetix> Ow! Whassat for?!!
02:58:32 <ProfTeggy> I guess this talk is considered off-topic for #haskell.
02:58:48 <poetix> Oh, I dunno - we like trees here...
02:59:07 <ProfTeggy> Well, you don't have anything but tree in your hands with algebraic data types ;-)
02:59:14 <ProfTeggy> s/tree/trees/
02:59:29 <poetix> And algebras, and little languages, and all that sort of thing
02:59:38 <ProfTeggy> I know, I know.
02:59:51 * poetix gives xerox a hurt look
03:01:51 * poetix hefts a large, wet haddock and starts swinging it menacingly
03:01:54 <xerox> Darn phone..
03:02:07 <poetix> C'mere, you!
03:02:27 * hilarity ensues
03:02:41 * xerox laughs
03:03:04 <xerox> 7nick xerocs
03:03:06 <xerox> oops.
03:03:56 <xerox> I was about taking a cup of tea and then I realized it's midday.
03:04:18 <wilx> You cannot have a cup of tea at midday?
03:04:42 <xerox> ...so we're having lunch soon!  But I'll have it anyway.
03:05:23 <boegel> _huge_ net split :)
03:05:42 <ski> not on my side
03:06:05 <xerox> Is there a difference between (a (->)) and ((->) a) ?
03:06:19 <ski> yes
03:06:55 <ski> in first  a :: (* -> * -> *) -> ...   and in second  a :: *
03:07:13 <ski> in first (->) is argument of a
03:07:42 <xerox> Right.
03:07:44 <ski> e.g. consider data A f = MkA (f Int Bool)
03:10:27 <xerox> What could it be useful for?
03:10:56 <ski> i dunno :)
03:11:14 <ski> maybe some data structure parameterized over an arrow ?
03:11:43 <xerox> OK thanks.
03:12:11 <ski> (a bit similar to stuff like  data MList m a = Nil | Cons (m (a,MList m a))
03:13:25 <poetix> xerox: Did you get a chance to look at that null pointer mapping in c2hs?
03:13:41 <poetix> Not null pointer - pointer to void
03:13:53 <poetix> (Ptr ())
03:24:10 <shapr> @Yow!
03:24:10 <lambdabot> My polyvinyl cowboy wallet was made in Hong Kong by Montgomery Clift!
03:26:25 * shapr pokes poetix with a Haiku 
03:26:55 * poetix is tickled
03:30:35 * poetix contemplates further comedy violence towards xerox
03:31:09 <poetix> They fight! They bite! They fight and fight and bite! Fight fight fight! Bite bite bite!
03:31:47 <poetix> Actually, I think we should all gang up on boegel.
03:31:57 <kzm> Anybody know the status of parallel Haskell?   And MPI?
03:50:58 <kosmikus> kzm: haven't heard anything from the GpH team recently -- I'd be interested to know, too; hMPI looks dead to me
03:55:33 * an_eerie_silence settles over #haskell
03:56:40 <poetix> Aren't there any newbies who want someone to explain to them what the hell a monad is?
03:57:23 <vegai> what the hell are Kiesli Arrows?
03:57:28 <poetix> Good question
03:58:04 <poetix> I think they're a kind of breakfast cereal?
03:58:12 <vegai> A typo might have landed in my previous utterance.
03:58:25 <vegai> Kliesli? Kleslei? Keleselilsei?
03:58:32 <ski> Kleisli
03:58:34 <poetix> Kiesli or Kliesli? I'm never sure myself.
03:58:36 <vegai> ah
03:58:49 <vegai> ok, so what the hell are those?
03:58:55 <ski> Kleisli arrows are monads converted into arroes
03:59:15 <ski> s/arrroes/arrows/
03:59:34 <vegai> humour dies.
04:01:26 <ndm> poetix, i don't understand monads, and i don't want to!
04:01:58 <poetix> It's said that one doesn't understand higher mathematics, one just gets used to it.
04:02:22 <poetix> I guess one could just get used to monads, but actually they're not so hard to understand.
04:03:04 <poetix> T. S. Eliot said poetry should be enjoyed before it is understood
04:03:10 <poetix> But then he would say that, wouldn't he?
04:06:19 <ndm> i used haskell for 2 years without knowing there even were monads
04:06:38 * Itkovian still doesn't grok monads
04:06:41 <Itkovian> help :-)
04:08:10 <wilx> Hm, I do not grok them either.
04:08:42 <wilx> I am content with that that I can use the standard ones.
04:09:39 <poetix> I would say I've never felt the need to make a custom monad, but that's not quite true: I did once make a custom monad, until someone showed me how I could do the same thing with two standard monads and a monad transformer
04:11:21 <poetix> Maybe I only think I understand monads, when really I've just got used to them. Depends what you mean by "grok", what depth of grokking is implied.
04:11:34 * gour is back.
04:11:51 <wilx> Grok is by definition such understanding that it becomes part of you :)
04:11:56 <poetix> I don't grok Category Theory, and I still don't grok arrows.
04:12:16 * boegel gangs up on poetix all on his own
04:12:18 <wilx> "Can work with" is not "to grok" :)
04:12:50 <wilx> http://en.wikipedia.org/wiki/Grok
04:13:24 <gour> stupid question from the newbie: why does compiler not enforce 'monad laws' ?
04:13:49 <poetix> The answer is probably something like "the halting problem"
04:13:56 <gour> this is written in "All About Monads" tutorial
04:14:03 <Igloo> They'll be undecidable, yeah
04:14:06 <gour> poetix: can u explain a bit?
04:14:58 <poetix> The monad laws are rules about the behaviour of functions - specifically bind and return
04:15:07 <gour> ok
04:15:48 <ski> one could do it in a dependently typed system, but then one more or less have to explicitely prove the laws (formally) when making the specific monads
04:16:10 <poetix> (and maybe the type checking would then be undecidable...?)
04:16:26 <gour> is it too difficult?
04:16:27 <ski> i think that needn't be necessary
04:17:17 <poetix> OK, if you've supplied a checkable proof that a function obeys the monad laws, then the compiler can check it
04:17:19 <gour> well, i'm thinking about declaring something as instance of monad class which does not satisfy the 'laws'
04:17:30 <gour> what will happen?
04:17:33 <earthy> poetix: no, the type checking will still be decidable
04:17:37 <earthy> but inferencing would be impossible
04:17:53 <earthy> gour: nothing at all
04:18:06 <gour> earthly: ???
04:18:07 <earthy> but the fact that your code may well do something unexpected
04:18:10 <poetix> But in the absence of such a proof, how is the compiler to know in the general case?
04:18:17 <ski> earthy : maybe some optimizations rely on monad laws ?
04:18:27 <earthy> not that I know of
04:18:29 <gour> earthly: :-)
04:18:54 <poetix> I seem to remember hearing that even the standard monads don't actually rigorously obey the monad laws
04:18:58 <earthy> b'sides, IIRC, current implementations of IO don't fully adhere to the monad laws. ;)
04:18:59 <ski> (e.g. maybe some monading fold/build or something .. hm, not sure)
04:19:17 <ski> because of seq
04:19:21 <earthy> ski: how would you optimize an arbitrary monadic computations?
04:19:36 <earthy> all you know is the order in which the computational effects are to take place
04:19:45 <earthy> there are no reordering laws or anything
04:20:00 <ski> hm, point
04:20:02 <earthy> note that the monad laws only gover the behaviour of return and bind
04:20:09 <ski> m, yes
04:20:22 <gour> so, is creating own monad a real need for haskell prg
04:20:31 <earthy> no
04:20:37 <earthy> it can make things easier though
04:20:38 <gour> or the present one satisfy most reqs?
04:20:39 <ski> maybe reassociating can be done for accumulator introduction (just wild idea) ?
04:20:48 <Itkovian> btw, A Stranger in a Strange Land is an awesome book.
04:21:02 <earthy> in my experience, I've been able to make do with the pre existing monads
04:21:09 <earthy> I just like to sugar them away a bit
04:21:15 <earthy> under different names
04:21:21 <gour> earthy: that's nice to hear
04:21:24 <earthy> so that my meaning is clearer to the ocmpiler
04:21:26 <earthy> compiler
04:21:38 <earthy> oh, and sometimes I reimplement monads, just for the hell of it :)
04:21:54 <poetix> That would be a good test of whether or not you "grokked" them
04:22:04 <ski> (also .. "commutative" monads could possibly present more opportunities ..)
04:22:06 * earthy thinks he groks monads ;)
04:22:21 <ski> (ditto)
04:22:27 <earthy> ski: yes, but then there's extra laws. and you have no way whatsoever to communicate those laws to the compiler
04:22:42 <earthy> (wouldn't that be nice, eh? :))
04:23:01 <ski> earthy : with a new typeclass, maybe ?
04:23:01 <gour> i think so
04:23:53 <ski> (maybe something like class Monad m => ParMonad m where par :: m a -> m b -> m (a,b))
04:24:03 <ski> (s/par/mpar/)
04:24:24 <poetix> There has been some recent work on making monads for things like "fair" interleaving and backtracking, and subcontinuations
04:25:11 <ski> that's interesting, too
04:25:30 <ski> (urls ? :)
04:25:55 <poetix> http://research.microsoft.com/Users/simonpj/papers/control/control.pdf
04:26:22 <poetix> http://www.eecs.harvard.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
04:26:50 <poetix> The second one is Kiselyov/Shan/Friedman/Sabry
04:27:14 <ski> vielen dank
04:27:23 <gour> is it possible to bring haskell closer to average-joe?
04:27:42 <poetix> Haskell spans a range from average-joe to...well, to Oleg.
04:27:48 <poetix> It's useful at both ends of the spectrum
04:28:00 <vegai> depends a bit on your definition of "average-joe"
04:28:13 <gour> well, i do not know for any haskellers in croatia
04:28:22 <vegai> I guess we're not talking about ditch diggers
04:28:26 <gour> while for c(++), java, php...
04:28:38 <vegai> oh, you *were* talking about ditch diggers :D
04:29:14 <gour> whatever, but more people can make it more popular, at least more support in tools
04:29:40 <vegai> haskell already has a rather nice support tool-wise, I think
04:29:41 <poetix> If the first thing you saw in Haskell was some of the example code for gtk2hs, you'd think "oh, that looks quite simple and accessible".
04:29:52 <gour> sometimes i think about "simon hits by the bus" problem
04:30:06 <vegai> poetix: well.... at least if you have some experience in GTK to start with
04:30:21 <gour> can e.g. ghc be developed further without the Simons
04:30:40 <ndm> you have other haskell compilers, ghc is not the only one
04:30:57 <gour> poetix: well, dcoutts sold me on gtk2hs :-)
04:31:10 <gour> ndm: for a serious work?
04:31:22 <ndm> gour, yep - i hardly ever use ghc
04:31:28 <ndm> i use WinHugs mainly
04:31:36 <gour> ndm: what do you use instead?
04:31:52 <ndm> and i'm hoping to use nhc for most work soon, its not got far to come
04:32:04 <gour> ndm: how do you distribute your apps?
04:32:11 <ndm> gour, i don't :)
04:32:25 <gour> ndm: that's a problem
04:32:26 <ndm> but when i do, i'll hope to use nhc
04:32:38 <gour> ndm: i think about getting multi-platform executable
04:32:40 <ndm> hello world in ghc is 1mb
04:32:52 <ndm> i think nhc will provide that, since its already bytecode
04:33:11 <gour> what about extensions, profiler...
04:33:29 <ndm> nhc had profilers long before ghc, a lot of the early heap profiling work was done on nhc
04:33:37 <gour> does it work on amd64?
04:33:50 <ndm> nhc is under active development
04:33:56 <gour> how many devs, community?
04:33:58 <ndm> i've seen a version that does, but i'm not sure if it does
04:34:08 <ndm> 2 devs
04:34:23 <ndm> i suppose the community includes me as well, so maybe 4
04:34:32 <ndm> (a bit bigger, but no, not the size of ghc)
04:34:41 <gour> is there any gui toolkit bindigns available?
04:34:48 <ndm> nope
04:34:50 <vegai> Hello World is 250KB in ghc
04:34:59 <ndm> well, fudgets is available i think
04:35:05 <ndm> vegai, windows? linux?
04:35:08 <gour> well, then "ndm hit by the bus problem" (again)
04:35:09 <vegai> ndm: linux
04:35:20 <ndm> vegai, windows = 1mb, from what i remember
04:35:23 <vegai> 172KB when stripped
04:35:25 <vegai> oh, ok.
04:35:34 <vegai> I guess they're statically linking a whole lot of windowsy crap there
04:35:40 <ndm> gour, but many compilers means lots of people hit by a bus
04:35:42 <vegai> linuxy crap is not so big
04:35:56 <ndm> of course, haskell workshop hit by a plane would probably end it pretty well
04:36:25 <gour> i vote for one compiler with many devs
04:36:26 * boegel thinks it's about time a new Haskell standard is coming up...
04:36:42 * gour agree with boegel
04:36:43 <boegel> that would make a lot more compilers available for production of tools
04:37:20 <ndm> vegai, my bad - its 486Kb for hello world
04:37:31 <ndm> i once did a hello world in wxHaskell, that was 8mb
04:37:36 <vegai> not really slim, though, but not 1MB either
04:37:38 <boegel> I mean, when people hear 'Haskell 98 standard' they just laugh "Why would we use something that hasn't improved over the last √® years"
04:38:00 <gour> i proposed to someone to write a gui app in haskell
04:38:01 <ndm> boegel, i use the haskell 98 standard, and i use development tools from 2000
04:38:03 <boegel> s/√®/7
04:38:15 <boegel> ndm: so do I, but the name is misleading
04:38:27 <gour> and respond was how big is the community, in terms if tools, support etc.
04:38:34 <vegai> ndm: guess how large a statically linked Hello World in C is
04:38:46 <ndm> quite bit, 200kb
04:38:47 <vegai> (compiled against glibc with gcc -static)
04:38:49 <ndm> at a guess
04:38:50 <vegai> 465KB
04:38:56 <gour> where to find programmers to support the code etc.
04:39:08 <Igloo> ndm: What in nhc are you working on?
04:39:16 <vegai> with dietlibc, that'd be less than 8KB probably...
04:39:16 <gour> i don't mind the size - hd space is cheap
04:39:18 <ndm> Igloo, nothing - prodding people near me to do things
04:39:27 <Igloo> heh
04:39:32 <vegai> I mind the size
04:39:35 <vegai> it's not about hd space
04:39:45 <ndm> gour, i do - i'm 4kb of my web quota and 10mb of my hard drive quota
04:39:49 <vegai> it's about something being rotten in the whole equation
04:40:12 <gour> ndm: ok, i understand
04:40:37 <beelsebob_> nhc of course also has the advantage of speed
04:40:52 <beelsebob_> but not really what's being discussed
04:41:04 <poetix> vegai: Maybe the rotten thing is the composition of the core C libs, you can't just statically link to the bits you need but have to pull in the whole shebang?
04:41:10 <gour> ndm: but ability to have multi-platform gui toolkits and tools is more relevant (maybe) for more users?
04:41:26 <Igloo> AFAIK no-one is working on the unsupported features like those needed by Control.Monad.State and cabal support, though  :-(
04:41:30 <ndm> gour, yep - i agree
04:41:48 <ndm> and multiplatform binaries would be nice as well
04:41:54 <Igloo> beelsebob_: I suspect most people care more about runtime speed than compiletime speed
04:41:55 <beelsebob_> gour: I think actually the ability to use *single* platform gui toolkits is what's needed... do you know a single big buisness that writes apps in gtk or wx?
04:42:12 <beelsebob_> igloo: I suspect when building the app, the reverse is true
04:42:15 <ndm> Igloo, wrong - developers care about compile time speed
04:42:43 <beelsebob_> neil once told me that for the n-queens problem nhc is faster than ghc up to 9 queens when you include the compile time and runtime
04:42:45 <ndm> nqueens with n = 9 is faster in nhc, if you include compile time
04:42:51 <ndm> yep, thats true
04:42:53 <beelsebob_> hehe
04:42:56 <Igloo> ndm: Have you done a survey of Haskell developers then?
04:43:13 <ndm> Igloo, no, but i've met a few
04:43:17 <gour> beelsebob: well, i'd like to write app on linux and make it available on win32/mac os
04:43:42 <gour> beelsebob: and there are no qt bindings for haskell :-)
04:43:45 * poetix wants RiscOS compatibility
04:43:48 <vegai> poetix: yes, I believe so
04:43:56 <ndm> i actually agree with gour, cross platform toolkit is good enough, but bob is very particular about his MacOS looking gui
04:44:03 <beelsebob_> gour: sure, you would... but the big businesses are what are gonna get haskell recognised, and they in general want to write an app on windows and have it look like a windows app
04:44:07 <vegai> I've heard that dietlibc's hacky solution was to put every function into a separate object file, or something like that
04:44:10 <Igloo> http://www.haskell.org/ghc/survey2005-summary.html says #1 complaint was compile time and #2 runtime, but that's for GHC which has better runtime performance than it does compiletime
04:44:29 <Igloo> So I'm not sure you can draw any conclusions from that
04:44:29 <beelsebob_> they usually don't care about cross platformness, they care that people like their app within their market
04:44:31 <vegai> of course, that's not the only thing that makes dietlibc small
04:45:09 <ndm> vegai, nhc has that same nasty hack
04:45:10 <beelsebob_> and neil: it's not about *looking* MacOSey, it's about *behaving* MacOSef
04:45:21 <ndm> each prelude function is in its own file :)
04:46:26 <ndm> Igloo, no one ever knows what they want, not developers, not end users
04:46:27 <gour> what's wrong with e.g. gtk2hs and gtk-wimp
04:46:32 <gour> http://gtk-wimp.sourceforge.net/
04:46:39 <ndm> gtk-wimp does not look or feel like windows
04:46:43 <ndm> its close, but not good enough
04:46:59 <beelsebob_> gour: what neil said s/windows/macOS/
04:47:42 <gour> beelsebob: ok, i got it
04:47:45 <poetix> I'm pessimistic about cross-platform GUI, because GUI is platform-specific in a lot of very finely-detailed ways
04:48:07 <beelsebob_> poetix: WOW! Someone who agrees with me!
04:48:17 <beelsebob_> cross platform GUIs are a bad idea from the start
04:48:43 <ndm> bob, they are not good, but they are better than nothing
04:48:44 <gour> i'm happy on linux, but think about poor win32 fellows
04:49:00 <beelsebob_> ndm: true
04:49:30 <beelsebob_> gour: I'm never *happy* with GUIs on linux, because there is no unifying look and feel of everything... each app behaves differently
04:49:40 <gour> i plan to code in gtk2hs (when ready), so i can provide source for win32 & mac os
04:49:48 <gour> if they like it or not
04:49:50 <beelsebob_> sure each app has a good gui, but none of them are predictable from other ones
04:49:51 <poetix> I'll take being able to run linux apps on win32 thanks to gtk-wimp over not being able to run them at all
04:50:06 <beelsebob_> gour: don't expect any Mac or Win users to use your app then :)
04:50:30 <gour> beelsebob_: well, itus up to them, i don't lan to make money on it
04:50:42 <beelsebob_> fair enough then :)
04:51:01 <beelsebob_> that's kinda my point though... big businesses *are* planning to make money
04:51:13 <beelsebob_> and that's why they don't use things like gtk or wx
04:51:20 <poetix> "The Web Will Save Us! Everything Must Be A Web Application!"</stupid_fad_mode>
04:51:32 * beelsebob_ stabs poetix
04:51:35 * int-e wants to be a spider
04:51:38 <gour> what about Qt?
04:51:46 <beelsebob_> gour: exactly the same problem
04:51:58 <poetix> What's with all the slapping and the stabbing and the ow-ow-it-hurts?
04:52:16 <beelsebob_> notice how photoshop is completely different on mac and windows?
04:52:21 <beelsebob_> or Office is
04:52:23 <beelsebob_> ....
04:52:47 <gour> still, haskell community could come more together and provide more practical things
04:52:58 <beelsebob_> it could indee
04:52:59 <gour> i don't whine, its getting better all the time..
04:53:22 <gour> raising general awareness of haskell
04:53:27 <gour> like darcs, pugs...
04:53:42 <gour> gtk2hs, whhaskell...
04:53:51 <gour> err. wxhaskell
04:56:02 <gour> beelsebob_: linux is also getting interested for big  businesses, i have friend writing commercial apps on Linux in Qt, but in C++
04:56:27 <Philippa_> QT doesn't really do any other languages, does it?
04:56:38 <gour> ruby
04:56:53 <beelsebob_> gour: yeh, but compare that to how many big companies are out there deliberately avoiding these tools
04:57:05 <boegel> int-e: why ?
04:57:30 <int-e> well, with all those webs around it must be a paradise.
04:57:50 <boegel> int-e: heh
04:58:00 <boegel> int-e: you could code your own web-spider :)
04:58:32 <gour> beelsebob_: which tools you mean, gui toolkits?
04:58:38 <beelsebob_> yeh
04:58:58 <gour> what's solution?
04:59:15 <gour> win32 will  die a slow death
04:59:19 <beelsebob_> write a different UI for each platform, and have a layer at which the UIs attach to a common code base
04:59:28 <gour> or you mean people are going to upgrade to vista?
04:59:42 <gour> what's wrong with wx?
04:59:55 <tuomov> one-size-does-not-fit-all
05:00:06 <beelsebob_> no... I'm saying that people are going to upgrade to OS X, and new compurets are going to ship with vista
05:00:09 <gour> not the best fit, but still
05:00:23 <beelsebob_> and the people with OS X are not going to want a vista UI
05:00:39 <gour> os x is defininitely better than m$
05:00:48 <beelsebob_> and none of them are going to want some other UI that no one recognises
05:00:54 <boegel> no way current users of windows will migrate to OS X
05:00:58 <gour> e.g.?
05:01:40 <xerox> poetix: ...it's the Itchy and Scratchy shoooooow!
05:01:59 <beelsebob_> gour: as an example... as an OS X user, I expect preferences to take effect as I click the nob... as a windows user I expect to press an apply button... there are 1000s of these differences that add up to an unhappy user if you get them wrong
05:02:32 * poetix slices the top of xerox's head off with a chainsaw, and pours salt and pepper on his exposed brains before sitting down with a knife and fork and a serviette, licking his lips
05:03:08 <gour> beelsebob_: well, i'm satisfied on linux and getting acustomed to it after migrating from os2 :-)
05:03:11 * beelsebob_ watches as poetix realises that xerox's brain is in fact a bomb
05:03:28 * further_hilarity ensues
05:03:45 <beelsebob_> gour: really?  How?  When I use linux I litterally *can't* get accustomed to it because every app has it's own different UI
05:04:11 <beelsebob_> there are no standard way of doing things in linux, and that really hold's it's UI back
05:04:31 <beelsebob_> in fact, by definition, there can't be standard ways of doing things in linux
05:04:53 <gour> beelsebob_: well, i'm on kde, using few gtk apps, and can get along, the secret is not to play with too manyy (free) apps
05:04:57 <int-e> you can blame the policy free design of X11 for that. people are trying though, kde does, gnome does.
05:05:17 <tuomov> they're just trying to force their view on everyone instead of making it the user's choice
05:05:33 * gour agree with tuomov
05:05:33 <tuomov> the real answer is abstraction
05:05:38 <beelsebob_> gour: so what you're saying is that I can have a consistant UI, as long as I don't use your gtk app that has a different UI?
05:05:49 <int-e> that's the point - you have to make a choice (or overwhelm the user with options and the coder with the nightmare to implement them all)
05:05:50 <beelsebob_> ... that's what I've been saying all along
05:05:50 <Philippa_> most users will use a pre-canned choice and stick to it anyway
05:06:10 <tuomov> because they're never even given the chance to try an alternative
05:06:23 <tuomov> easily
05:06:23 <Philippa_> no, most users don't *want* to fuck around customising their UI
05:06:34 <gour> beelsebob_, that's why you ahve e.g. hig for gnome
05:06:35 <Philippa_> so they'll stick with one of a pre-canned set
05:06:36 <xerox> poetix: I didn't realize how to marshal void ptrs :-|
05:06:42 <cjb> My impression was that Gnome/GTK2 is winning, and if you're a Normal Desktop User you won't find an application you need that doesn't fit in with the current gtk theme.
05:06:59 <beelsebob_> gour: absolutely... and those HIGs are different to the OS X ones...
05:07:06 <cjb> But that's obviously inflammatory given that gour's a KDE user.  Just calling it like I see it.  :)
05:07:07 <beelsebob_> so your app will not play nice on OS X
05:07:14 <beelsebob_> cross platform GUIs do not work!
05:07:20 <poetix> xerox: Never mind - what I have now works at least...
05:07:23 <tuomov> a HIG is the problem, not the solution
05:07:33 <cjb> tuomov: What is the solution?
05:07:33 <tuomov> if you need a HIG, your toolkit is too low-level
05:07:42 <gour> cjb: i'm not religios fanatic
05:07:43 <beelsebob_> tuomov: actually... I have tried alternatives... I have settled on liking OS X... that's why I don't want apps to go very far outside the OS X HIGs
05:08:13 <Itkovian> grrr ... mysql
05:08:25 <tuomov> the person who decided that widgets are the correct level of abstraction should be beaten with a cluebat.. to death
05:08:40 <beelsebob_> tuomov: absolutely :)
05:09:02 <gour> i use what suits me: vim - gtk, mutt - console, konversation - kde etc.
05:09:02 <cjb> Huh.  What's the correct level?
05:09:19 <poetix> DWIMmets
05:09:24 <beelsebob_> gour: so do I... that's why I don't wan't to use gtk apps!
05:09:26 <tuomov> cjb: something that doesn't involve the type of UI, so that it should be possible to plug in almost anything over it
05:09:37 <tuomov> http://iki.fi/tuomov/vis/ is one vapourware proposal
05:09:44 <cjb> But doesn't that result in reinvention, giving the same situation we have now?
05:09:55 <gour> beelsebob_: that's fine, but gui choice for haskell is not ig
05:09:56 * beelsebob_ is working on a fairly similar abstraction layer for hat
05:10:15 <tuomov> cjb: think of semantic html+css
05:10:24 <tuomov> cjb: instead of the font-tag crap that the web is abundant with
05:10:33 <beelsebob_> gour: exactly my original point... we need to be able to use windows forms, and Cocoa UI from Haskell
05:10:45 <beelsebob_> gtk2hs does not solve the problem
05:10:53 <beelsebob_> (it does in part... but not fully)
05:11:19 <gour> at least provide bindings to write some gui apps instead of console-only
05:11:40 <tuomov> cjb: It should be very easy to write the "css" for a particular type of UI given a nice semantic description of the app
05:11:41 <gour> you know, blind uncle...
05:11:46 <tuomov> in simple cases a reasonable Ui could be auto-generated
05:12:05 <tuomov> that's the level of abstraction I'm dreaming about
05:12:06 <gour> tuomov: do you think about web-app or..?
05:12:29 <beelsebob_> gour: no... it should be possible to generate a web UI from the semantic description though
05:12:40 <tuomov> gour: no, but web-app could be one of type of UI the application could be ran through in some cases where no special capabilities not available are required
05:12:43 <gour> ahh, that's fine
05:13:11 * poetix worships the terrible Sumerian goddess of user interfaces, XUL
05:13:11 <cjb> I wonder if what you propose is already possible, using glade.
05:13:12 <gour> however, the (original) pint: how to increase awareness of haskell as a language?
05:13:30 <gour> by providing a new way of defining UI ?
05:13:31 <tuomov> cjb: no, It's all about placing widgets, i.e. absolute and total crap
05:13:33 <xerox> poetix: how does XUL and .glade compare?
05:13:42 <tuomov> xul is also widget-based
05:13:49 <cjb> I mean, I understand why glade is at the wrong layer, according to your paper.  But it does provide a semantic description of input/output that we could turn into, say, a description of a command-line I/O system instead.
05:13:50 <poetix> Dunno, I've barely used xul and I've never used glade
05:14:04 <poetix> I suspect xul is also ultimately rather widget-oriented
05:14:34 <poetix> Ditto XAML
05:15:21 <tuomov> cjb: something like glade could be used to generate the stylesheet for a particular tyep of UI, but the interface to which it attachs should be described elsewhere
05:15:41 <tuomov> atm apps just use the widgets glade describes
05:16:11 <cjb> Yeah.
05:16:50 <gour> still, more haskell-gui-apps written in whatever toolkit, would make haskell more appealing for wider audience
05:17:28 <gour> or any haskell-app, i become interested after seeing darcs
05:17:29 <xerox> tuomov: I don't understand how do you imagine the glueing should be down between UI and code.
05:17:55 <cjb> I wonder if we *could* automatically translate some glade/Gtk applications to glade/CLI ones.  I know it's not what you're proposing.
05:18:01 <tuomov> xerox: rtfa :)
05:18:05 <boegel> xerox: how's the L-system stuff going ? have you decided on a name yet ?
05:19:20 <xerox> boegel: I'll work on it in some minutes, and, yup, Nymphaea.
05:19:51 <xerox> tuomov: will do, I'm getting bored in writing that code :-)  Even thought it isn't "that much" code..
05:20:13 <boegel> xerox: oh yeah, right
05:20:17 <boegel> and what about a logo ?
05:20:20 <Cale> xerox: let me know if you have any difficulties with the Rand monad, I implemented that thing we were talking about the other day -- the performance is quite good :)
05:20:45 <xerox> Cale: hehe, I knew you would!  I'll try :-)
05:26:17 * poetix interfaces graphically with some users, and ends up in the evening papers under the headline "Barbaric Butcher's Brochures"
05:34:07 * boegel greets CosmicRay 
05:34:15 <CosmicRay> hi boegel
05:34:18 <boegel> nice work on HWN, bit short, but that's not your fault is it :)
05:34:43 <Igloo> There's a longer version available too
05:34:48 <Igloo> It's called the mailing lists  :-)
05:35:13 <CosmicRay> ;-)
05:35:21 <Igloo> (does anyone else think each HWN issue should mention that the last HWN issue was sent?)
05:35:22 <boegel> Igloo: I only collect HWN itself :) I didn't mean I want more info about the topics, there just aren't as many topics as usual
05:35:36 <CosmicRay> boegel: it does seem to vary week to week.
05:35:38 <Igloo> This world just isn't meta enough for me
05:35:39 <boegel> Igloo: eh ?
05:35:52 <CosmicRay> a lot of the discussion this past week was continuing on threads that were already mentioned in the previous week's HWN
05:36:11 <CosmicRay> I wasn't sure whether or not to mention them again, but finally decided not to, since there wasn't a lot new
05:36:18 <Igloo> boegel: HWN is about the things posted to the list in the last week, right? And the last HWN was one such message...
05:37:07 <CosmicRay> Igloo: heh, if anyone started a thread about HWN, I'd probably mention it, but the fact that it is posted weekly is sorta implied by the first paragraph, don't you think?
05:37:23 <Igloo> I wasn't being serious  :-)
05:37:34 <CosmicRay> Igloo: so hard to tell with you ;-)
05:37:50 <boegel> Igloo: heh :) would be quite stupid though ;)
05:38:10 <CosmicRay> Igloo: better watch it, or you'll wind up as a quote of the week ;-)
05:38:49 <Igloo> Reminds me of Dijkstra's "Sometimes I think I'm just an algorithm" (or similar)
05:39:09 <shapr> Sometimes I think I'm just a source of randomness.
05:39:26 <CosmicRay> heh, I ran across a link last week for an essay entitled "Dijkstra Considered Harmful"
05:40:47 <boegel> yo shapr :)
05:40:51 <shapr> y0 y0
05:41:01 <CosmicRay> shapr: and very boingy randomness at that.
05:41:07 <boegel> shapr: we had a honoring visit today... meet ProfTeggy
05:41:25 <CosmicRay> shapr: you are so much more exciting than /dev/random ;-)
05:42:19 * xerox finds /dev/random very exciting, though
05:42:36 <CosmicRay> xerox: it broke my e-mail last week.  twice.
05:42:44 <shapr> boegel: neato!
05:42:50 <shapr> CosmicRay: Thanks!
05:43:12 <CosmicRay> didn't have enough entropy for exim4 to generate a tls session key, so it sat there for 20 minutes until it timed out.  then tried again, having consumed what randomness there was, and timed out some more.
05:43:59 * Itkovian boings
05:44:13 * shapr bounces
05:44:22 <shapr> boegel: I'm a walking Haskell library! w00!
05:44:55 <cjb> Should it have been using random rather than urandom, if you don't have a source of entropy configured?
05:45:25 <CosmicRay> odd question.  what system of organization do libraries outside the US use?  around here, it's almost always either the dewey decimal system or the US Library of Congress system
05:45:36 <mflux_> (on linux) urandom is fast, random requires entropy
05:45:57 <CosmicRay> right, it was using random, which was the problem, apparently
05:46:19 <cjb> mflux_: Yes, that's why I'm asking why it used random.
05:46:45 <mflux_> ok, I read your message just the other way round ;)
05:46:49 <CosmicRay> cjb: the exim4 debian maintainer claimed it was not a bug since such high-quality randomness is required for a secure key.
05:46:54 <CosmicRay> I don't really believe it
05:46:57 <Igloo> My college library uses dewey decimal
05:47:16 <Igloo> I don't know how to tell if the public one does or not
05:47:51 <Igloo> I only know the college one does because the librarian told me she'd put the computing stuff in misc or something because dewey predated computers
05:47:59 <shapr> boegel: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
05:48:00 <cjb> CosmicRay: Seems like it is a bug, and exim should return a transient failure if it's leaving a connection hanging past a timeout value looking for entropy.
05:48:11 <CosmicRay> Igloo: huh, 001.64 is for computers in dewey.
05:48:40 <CosmicRay> cjb: it does, and then the same thing hapens on the next queue run.
05:49:14 <cjb> CosmicRay: !  Yow.
05:50:32 <Igloo> "000 Generalities" according to http://en.wikipedia.org/wiki/Dewey_Decimal, although it gives 000 Computers, information and general reference (for the 100 rather than 10) earlier
05:50:36 <CosmicRay> apparently computer science is 004
05:50:43 <shapr> Dang, I wish it were 404.
05:50:58 <CosmicRay> and Unix is apparently 001.6424 or 005.282
05:51:04 <CosmicRay> http://hermes.reading-college.ac.uk/LearningResources/subgdes/computing.htm
05:51:08 <CosmicRay> shapr: hah
05:51:16 <boegel> @remember shapr  Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
05:51:30 <CosmicRay> interesting that they list both 001.64 and 004 for computer science on that page
05:51:32 * Igloo can't see a date of death for Dewey anywhere obvious, but there's an 1876 link to Project Gutenberg
05:51:40 <CosmicRay> Igloo: hah
05:51:51 <CosmicRay> obviously somebody is maintaining the standard
05:52:19 <shapr> boegel: :-P
05:52:20 <CosmicRay> Igloo: 1931
05:52:46 <Igloo> Or people are doing things ad-hoc and trying to keep in touch with each other as they go
05:53:26 <CosmicRay> http://en.wikipedia.org/wiki/Dewey_Decimal_Classification#Ownership
05:53:39 <CosmicRay> apparently an organization called the Online Computer Library Center maintains it.
05:54:22 <CosmicRay> whoa, check this out: http://en.wikipedia.org/wiki/Wikipedia:Dewey_Decimal_System
05:54:28 <CosmicRay> wikipedia organized according to the dewey decimal system
05:55:16 <CosmicRay> some people have way too much time on their hands.
05:55:47 <boegel> CosmicRay: yeah, they should learn Haskell
05:55:56 <CosmicRay> boegel: of course! :-)
05:59:27 <CosmicRay> shapr: I've been meaning to ping you about bittorrent.
05:59:45 <CosmicRay> shapr: I don't know enough to know if this makes any sense, but: I feel that the default BT tracker sucks.
05:59:50 <shapr> CosmicRay: it does.
05:59:53 <shapr> For a variety of reasons.
06:00:05 <CosmicRay> shapr: my main complaint is that it behaves more like an application than a daemon.
06:00:17 <xerox> Did you hear about the trackerless bt?
06:00:25 <CosmicRay> xerox: no, url?
06:00:39 <xerox> http://www.bittorrent.com/trackerless.html
06:01:18 <shapr> xerox: That's actually a Kademlia implementation for BT, I really want to write that in Haskell!
06:01:30 <xerox> Yep!
06:01:31 <shapr> CosmicRay: Yeah, I totally agree. It's also inefficient for many connections at once.
06:03:46 <CosmicRay> shapr: what I'd like to see is a BT tracker that has a built-in seeder, and runs as a traditional daemon
06:04:40 <shapr> I'd like to see a launchmany that handles hundreds of downloads efficiently. btlaunchmany eats about 50% of my dual 1.5GHz system with twenty downloads.
06:05:57 <CosmicRay> ouch
06:06:28 <mflux_> lanchmanycurses also crashes randomly when you resize the terminal, and reliably when you make it too small
06:06:38 <mflux_> doesn't really advertise python all that well ;)
06:06:40 <basti_> yes.
06:06:46 <CosmicRay> mflux_: hah.
06:07:01 <CosmicRay> to be fair, ncurses itself sucks.
06:07:02 <CosmicRay> but yes.
06:07:11 <CosmicRay> SIGWINCH, baby.
06:07:16 <mflux_> it maybe sucks but it doesn't (in my experience) crash
06:07:46 <mflux_> I think you can also do it signallesly (and handle it with getch or something)
06:08:01 <mflux_> well, maybe I'm mixing it with the haskell's (or ocaml's) ncurses interface which uses that
06:09:09 * shapr gets a SIGWENCH
06:09:13 <shapr> Gotta go meet a woman, bbl
06:09:21 <basti_> hey.
06:09:26 <basti_> bring pics when youre back.
06:09:33 <CosmicRay> heh
06:09:36 <shapr> Dude, she's cute and you ain't gettin any pix.
06:09:37 <shapr> :-P
06:09:48 <basti_> pffff.
06:09:48 * shapr boings away into the sunset &
06:09:53 <CosmicRay> hehe
06:10:21 <CosmicRay> basti_: you just squandered an opportunity to make a great IO monad joke!
06:10:31 <basti_> huh?
06:10:37 <basti_> about women or about SIGs?
06:11:12 <CosmicRay> basti_: about shapr meeting a woman, anyway.  we should all have cautioned him not to unsafePerformIO with her!
06:11:53 <basti_> ohhh
06:11:54 <basti_> yes
06:11:56 <basti_> indeed
06:11:56 <CosmicRay> ;-)
06:12:06 <mflux_> well, you can still wait till he returns, 'I hope you didn't..'
06:12:09 * earthy cringes
06:12:12 <mflux_> but otoh, the joke may now be ruined :/
06:12:13 <CosmicRay> hehe
06:12:26 <CosmicRay> mflux_: most of mine are before I ever utter them ;-)
06:12:47 <olliej> gah why on earth does ghc have an unpackFloat function??
06:12:52 <CosmicRay> hah
06:14:54 <ski> http://andersca.org/gallery/eurohaskell/p1010060
06:15:54 <CosmicRay> ski: hah!
06:16:07 <CosmicRay> that is great.
06:18:03 <boegel> ski: lol, although I don't understand unafePerformIO completly :)
06:18:08 <CosmicRay> we so need a EuroHaskell USA or something ;-)
06:18:09 <boegel> <insert> e
06:18:28 <ski> the others, such as p1010053 and p1010055 are not so bad, either
06:18:34 <boegel> CosmicRay: HaskellWars or someting ? :p
06:18:42 <CosmicRay> heh
06:18:45 <ski> boegel : the joke or the function ?
06:18:53 <CosmicRay> heh
06:19:57 <xerox> haha ski
06:20:02 <CosmicRay> so, what haskellers that we all know would be in those pictures?
06:20:40 <ski> shapr, of course .. and Hughes and Augustsson
06:20:55 <ski> (hm, i think Augustsson, in any case, might misremember)
06:20:57 <boegel> who's this ? http://andersca.org/gallery/eurohaskell/p1010026
06:21:03 <boegel> ski: the function
06:21:20 <xerox> @type System.IO.unsafePerformIO
06:21:38 <ski> that's John Hughes himself on shapr's unicycle (with shapr on floor)
06:21:40 <lambdabot> bzzt
06:21:48 <xerox> @type System.IO.Unsafe.unsafePerformIO
06:21:51 <lambdabot> forall a. IO a -> a
06:22:03 <xerox> It is the backdoor of hell!
06:22:06 <boegel> http://andersca.org/gallery/eurohaskell/p1010045 and this ?
06:22:08 <CosmicRay> boegel: basically, it lets you do an IO action outside the IO monad.
06:22:21 <boegel> CosmicRay: cool, that exactly what I need :p ;)
06:22:28 <CosmicRay> boegel: it is evil and unreliable ;-)
06:23:04 <xerox> It's fair to say that in some (corner?) cases is useful.
06:23:05 <olliej> it's like C!
06:23:06 <olliej> :)
06:23:12 <CosmicRay> xerox: yeah
06:23:18 <CosmicRay> xerox: I have used it a few times.
06:23:28 <CosmicRay> to initialize a "global" variable, for one.
06:23:48 <boegel> http://andersca.org/gallery/eurohaskell/p1010065 heh :)
06:24:31 <ski> boegel : for p1010045, (left2right) shapr and bringert
06:25:02 <xerox> I used it to do improper nondeterminism :-)
06:25:07 <ski> p1010065, shapr again
06:26:03 <boegel> ski: I knew that was shapr, I was just wondering why he's posing with an iron :)
06:26:17 <ski> oh
06:26:37 <ski> some people were making open-source T-shirts
06:27:03 <boegel> and dutch cows are open source ? :p
06:27:04 <ski> http://www.dtek.chalmers.se/~d00bring/misc/eh-tshirt-bjorn.jpg
06:27:09 <ski> no, not that one
06:27:52 <boegel> don't get that one, but that's probably because I'm not smart enough :)
06:27:59 <boegel> I saw a nice one on the train this morning
06:28:09 <boegel> "> cd /put" "more beer"
06:28:28 <xerox> http://andersca.org/gallery/eurohaskell/p1010051
06:28:30 <ski> basically, they had plain black T-shirts, some blank slide material with holes in it and put that on T-shirt, put on some kind of paint, rubbed it in, let it dry some, and iron it
06:28:30 <boegel> although I would've found "cd /belly" "more beer" more amusing :)
06:28:30 <xerox> haha!
06:28:56 <boegel> xerox: explain ?
06:28:56 <Muad_Dibber> boegel: shouldnt that be cd /pub ?
06:29:03 <boegel> @type flip (>>=)
06:29:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m
06:29:05 <lambdabot> b
06:29:07 <xerox> It's more
06:29:11 <xerox> @pl flip (>>=)
06:29:12 <lambdabot> (=<<)
06:29:18 <xerox> I think, to say the direction :-D
06:29:22 <boegel> Muad_Dibber: hmm, maybe I misread it :)
06:29:37 <xerox> http://andersca.org/gallery/eurohaskell/p1010052
06:29:40 <ski> a local bear and food room was called "The Monad" http://andersca.org/gallery/eurohaskell/p1010003_001
06:29:46 <xerox> http://andersca.org/gallery/eurohaskell/p1010053
06:29:52 * xerox rolls on the floor laughing
06:29:53 <ski> bah s/bear/beer/
06:29:58 <beelsebob_> http://andersca.org/gallery/eurohaskell/p1010060 is my favorite
06:30:30 <Itkovian> lispy: ping
06:31:01 <Itkovian> boegel: it was $ cd /pub
06:31:05 <Itkovian> $ more beer
06:31:15 <xerox> http://andersca.org/gallery/eurohaskell/p1010063  This guy is doing something nice I think
06:31:21 <ski> beelsebob_ : also http://andersca.org/gallery/eurohaskell/p1010059 for better look
06:31:41 <Itkovian> I hope that's a chick on his desktop ;-)
06:32:09 <CosmicRay> Itkovian: heh
06:32:21 <CosmicRay> Itkovian: it would appear to be Afterstep ;-)
06:33:14 <Itkovian> CosmicRay: as long as it's a girl
06:33:22 <CosmicRay> heh
06:33:32 <xerox> When and where will be the next EuroHaskell?
06:33:41 <CosmicRay> xerox: I'm voting for Seattle ;-)
06:33:54 <xerox> Urgh.
06:34:06 <CosmicRay> xerox: seriously, shapr was talking about something in Gotenburg
06:34:20 <CosmicRay> but I suspect the answer is "wherever someone is willing to organize it"
06:34:54 <Itkovian> shapr: get that tshirt out of those pants http://andersca.org/gallery/eurohaskell/p1010046
06:35:06 <CosmicRay> heh
06:35:43 <xerox> Oh, Sweden
06:36:13 <CosmicRay> it would be great to get to sweden, but realistically it will be hard to find enough time for that (for me, anyway)
06:36:28 <CosmicRay> heh: " Is it like a formal conference, or some kind of academic lanparty?  The latter."
06:36:36 <CosmicRay> http://haskell.org/hawiki/EuroHaskell
06:37:32 <CosmicRay> every so often I think of asking someone at haskell.edu if we could hold something at their location.  it's a realy nice campus and in a nice town with lots to do as well.
06:37:51 <Igloo> :-)
06:38:26 <earthy> yeah, Haskell dance does not really show up the dance paper
06:38:29 <earthy> on google
06:38:40 <olliej> @type GHC.Prim.unpackFloat#
06:38:42 <lambdabot> bzzt
06:38:48 <olliej> gah
06:39:21 <ski> earthy : http://lambdadance.spacebar.org/ ?
06:39:40 <CosmicRay> haha
06:39:42 <ski> @index unpackFloat#
06:39:43 <lambdabot> bzzt
06:40:06 <earthy> ski, that is *bad*
06:40:23 <earthy> I meant http://haskell.cs.yale.edu/yale/papers/dance-30-tr/index.html ofcourse
06:42:38 <ski> oh
06:42:57 * ski tries to look innocent
06:45:26 <olliej> hehehe
06:45:38 <olliej> ski got told off :)
06:45:43 * olliej is innocent :)
06:47:26 * ski actually had never seen (or heard about) that robot language before :)
06:51:23 <xerox> I never remember which is the tail-recursive one between foldl and foldr.
06:51:33 <xerox> My guess: foldl
06:53:00 <boegel> if you guys want another edition of EuroHaskell this year, you'll have to hurry up
06:55:42 <Itkovian> xerox: i think so too
06:56:14 <xerox> foldHMM f k (x:xs) = f x (foldHMM f k xs)
06:56:17 <Lemmih> dons: ping.
06:56:29 <xerox> foldFOO f k (x:xs) = f (foldFOO f k xs) x
06:56:49 * xerox shakes ski
06:59:57 * int-e looks at the types for that foldl :: (a -> b -> a) -> a -> [b] -> a ... is foldFOO
07:02:28 <xerox> *Main> length $ dropNewlinesL $ take 10000 $ List.intersperse '\n' $ repeat 'a'
07:02:28 <xerox> 5000
07:02:28 <xerox> (2.62 secs, 302200512 bytes)
07:02:28 <xerox> *Main> length $ dropNewlinesR $ take 10000 $ List.intersperse '\n' $ repeat 'a'
07:02:31 <xerox> 5000
07:02:34 <xerox> (0.03 secs, 1146440 bytes)
07:02:47 <xerox> !!!
07:04:40 <Lemmih> You should restart GHCi to make sure caching doesn't affect the result.
07:04:46 * xerox tries
07:05:49 <int-e> hmm, is there a good reason not to use filter there?
07:07:52 <SamB> which seems in better taste: WinId or WinID?
07:08:25 * int-e would prefer WinId
07:09:54 <xerox> Lemmih: the L version is noticiably slower.
07:13:03 <SamB> maybe foldl is only faster with fairly strict accumulators?
07:13:24 <xerox> I could try ~ on the arguments
07:13:52 <rep> do try
07:14:01 <xerox> (1.33 secs, 301144904 bytes)
07:14:24 <SamB> and remember, x ++ y is O(length x)
07:14:28 <xerox> r: (0.09 secs, 547268 bytes)
07:15:00 <xerox> r (without ~)
07:17:18 <xerox> @index filter
07:17:19 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
07:17:23 <xerox> @libsrc Data.List
07:17:24 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
07:18:06 <SamB> you don't have ghc6-libsrc installed?
07:18:48 <int-e> @eval List.filter (\a->a`mod`2==0) [1,2,3,4,5,6]
07:18:50 <xerox> I do have, right.
07:19:14 <lambdabot> [2,4,6]
07:19:23 <xerox> It would be handy to have index as a standalone unix tool.
07:19:53 <xerox> I should probably run hoogle locally.
07:20:17 <ndm> you can run hoogle locally quite easily, but the web version is so much better than the lamdbabot version
07:20:26 <ndm> its much better to visit the website
07:21:52 <xerox> But it handier to have it as a command
07:22:00 <ndm> and what does index do that hoogle doesn't, other than index more files?
07:22:09 <ndm> maybe, i prefer the GUI goodness
07:22:21 <xerox> It's just faster.
07:22:24 <ndm> perhaps someone could make :h in GHC invoke hoogle
07:22:37 <ndm> is hoogle noticeably slower?
07:23:02 <ndm> i have never profiled it, but if its slow now its going to be 50 times slower once i get the full libraries in
07:23:09 <xerox> I mean, it's faster for me to do M-! hoogle (a -> Bool) -> [a] -> [a] RET
07:23:20 <ndm> oh, ok
07:24:07 <xerox> What about the fact that @index indexed more files?
07:24:18 <xerox> Is it not possible to share the index file?
07:24:41 <ndm> its a lot more than just an index, its also type sigs, instances etc.
07:24:52 <ndm> but i wrote the new hoogle index generator last night, so its no longer a problem
07:24:59 <ndm> i have a full ghc index for hoogle 3
07:25:01 <xerox> Cool
07:25:08 <ndm> now all i need to do is write hoogle 3...
07:25:21 <xerox> Yay!
07:25:53 <xerox> What do you do with instances in hoogle?
07:26:23 <ndm> hoogle 2, nothing
07:26:38 <ndm> hoogle 3, searching Int -> Int -> Int
07:26:45 <ndm> will notice that (+) is a better match
07:26:51 <ndm> @hoogle Int -> Int -> Int
07:26:52 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
07:26:52 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
07:26:52 <lambdabot> Prelude.(*) :: Num a => a -> a -> a
07:27:17 <xerox> It makes sense :-)
07:27:21 <ndm> (not a good example!)
07:29:09 <SamB> um, Int isn't an instance of Floating...
07:29:43 <xerox> hehe, that's hoogle 2.
07:30:46 <ndm> SamB, yeah, it is
07:30:50 <ndm> hence those are all valid
07:31:24 <ndm> SamB, my bad - your're right - hoogle 3 will fix that
07:31:40 <ndm> at the moment it ignores everything before the =?
07:31:44 <ndm> * =>
07:44:28 <schyffe> Hi, is it possible to change a parameter inside a function? Like func param1 = param1 = True
07:44:50 <xerox> schyffe: Haskell does not have mutable variables.
07:45:03 <schyffe> I see
07:45:21 <basti_> it has but... that part is the part that is hard to explain... ("mo...what?")
07:45:28 <xerox> schyffe: you could introduce new bindings to values with 'let .. in ..' and '.. where ..' clauses.
07:45:29 <schyffe> another question, must I have an else statement in my if?
07:45:40 <xerox> schyffe: yes.
07:46:00 <integral> if you have no else, what is the value of the expression when the condition is false?
07:46:48 <schyffe> well it was related to my first question.. if an expression is true, then I'll change the variable, otherwise it'll be as it was
07:47:14 <integral> schyffe: you're inside the IO or ST monad?
07:47:35 <schyffe> uhm.. I have no idea
07:48:04 <xerox> schyffe: could you give more details?  Seeing you're using 'True' sounds like you can accomplish that with a simple function.
07:48:14 <int-e> @hoogle (a -> b -> a) -> a -> [b] -> a
07:48:15 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
07:48:15 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
07:48:30 <int-e> ouch.
07:48:57 <xerox> Gotta go, see you later
07:49:12 <integral> @hoogle Bool -> IO a -> IO ()
07:49:13 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
07:49:13 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
07:49:13 <lambdabot> Prelude.seq :: a -> b -> b
07:49:34 <int-e> xerox: have a look at Data.List.foldl' ... it's a strict evaluation version of foldl
07:49:37 <schyffe> xerox: I'm writing a recursive function that walks through a given hand of cards.. I want to determine if there is an ace in the hand and what the value of the hand is.. but I know how to solve it.
07:59:22 <Hatchetman> "bp = ld -> block[1]" where ld is a pointing possibly to a struct containing a field named block (short block[12][24])....what type would bp be? a pointer?
07:59:29 <Hatchetman> ow, wrong chan
07:59:37 <Hatchetman> ahhh C is killing me
08:07:17 * boegel leaves for home
08:07:25 <boegel> g'bye everyone, cu 2morrow
08:07:31 <ski> xerox : I'm shaking, I'm shaking.
08:07:57 <Lemmih> goron: pong.
08:10:17 <Itkovian> ttyl
08:48:28 * SamB wonders whats a good way to handle stream-like things in address spaces...
08:49:24 <basti_> schyffe: are you still there?
08:50:49 <schyffe> yep
08:51:11 <basti_> schyffe: i could help you a little with your counting stuff
08:51:23 * SamB furthermore wants something that doesn't involve observationally mutable state
08:51:26 <schyffe> great
08:51:47 <basti_> first, to find an ace:
08:51:48 <schyffe> can I pm you?
08:51:55 <basti_> any (isAce) list
08:51:56 <basti_> sure
08:53:17 * SamB supposes a monad could do nicely
08:53:40 * SamB can't think of any other way to do it nicely
08:58:26 <lispy> SamB: the writer monad might be right for you
08:59:46 <SamB> could you explain this?
09:00:04 <basti_> lispy: i fear he's not that far in his learning
09:00:31 <lispy> SamB: hang on and i'll get you a link
09:00:57 <basti_> oh sorry i got confused
09:01:06 <basti_> i thought we were still talking about schyffe and his aces
09:01:40 <lispy> SamB: http://www.nomaware.com/monads/html/
09:02:03 <lispy> SamB: depending on what you want to do to the stream the writer monad might be great or it might not support what youneed at all
09:03:46 <SamB> basicly, I want something which will make it nice and simple to decode instructions with varying length, some of which even have embedded strings...
09:04:32 <SamB> and which I can also use for decoding strings which aren't in the instruction stream
09:05:00 <SamB> (and note that these strings are in a peculiar, non-trivial encoding)
09:05:18 <lispy> SamB: hmm...that sounds similar to parsec.  Maybe you can borrow thos ideas.
09:09:11 <SamB> which ideas?
09:12:26 <SamB> actually, I think I'll likely end up with something close to StateT Addr...
09:12:43 <lispy> SamB: well, i have no idea how parsec does what it does, but it uses monads to construct the parser
09:13:04 <lispy> you could use monads to construct a decoder and then apply the decoder to a stream
09:13:23 <SamB> yeah, but which monads?
09:15:13 <lispy> SamB: i'm not sure.  You'd have to poke at parsec to find out.
09:15:31 <SamB> I'm certain I do not want Parsec's monads
09:15:35 <lispy> i guess i was just thinking that what you are doing is similar....
09:15:39 <lispy> :)
09:16:29 <schyffe> if function hCounter returns a tuple, why won't this work: uncurry (hCounter tmpAces tmpVal) ?
09:17:12 <SamB> this binary stuff is much simpler, except for the random-access, and for the pausing in the middle to go off and read something else...
09:18:39 <SamB> also, the saving everything about the state of the machine both in-memory and in a standard file format...
09:19:28 <int-e> schyffe: what are you trying to do?
09:19:39 <SamB> you see, I want to make a Z-Machine interpreter with undo and quetzal support...
09:20:18 <schyffe> int-e: I want two values returned from a function passed as arguments into another
09:20:53 <SamB> what is the type of hCounter ?
09:21:10 <int-e> schyffe: you need to add that function as the first argument to uncurry.
09:21:22 <lispy> SamB: quetzal?
09:21:40 <SamB> lispy: thats the standardized save file format
09:21:53 <lispy> ah
09:22:02 <int-e> schyffe: uncurry function_to_eval (hCounter tmpAces tmpVal)
09:22:39 <schyffe> what if I have more arguments to pass to function_to_eval?
09:23:46 <SamB> schyffe: what is the type of function_to_eval?
09:23:48 <schyffe> hCounter should return the last two, but there is a first argument i need passed too
09:24:07 <lispy> uncurry (function_to_eval arg1) (hCounter ...)
09:24:09 <schyffe> it takes 3 int's
09:24:15 <schyffe> I see
09:24:27 <SamB> oh, right, this is uncurry...
09:24:39 * SamB gets those two mixed up...
09:24:40 <lispy> that is depending on the type of function_to_eval
09:24:48 <lispy> me too
09:25:03 <schyffe> cool it worked
09:25:09 <lispy> @type uncurry
09:25:14 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
09:25:20 <SamB> thankfully, this is Haskell and not LISP
09:26:03 <lispy> ((lambda (x y) (function_to_eval arg1 x y)) 'hCounter ...)
09:26:44 <lispy> that is unless there is some tuple magic that needs to happen
09:26:47 <SamB> what I meant was, if it was lisp, than I wouldn't get a type error for just sneezing at such code...
09:27:09 <lispy> oh, right you'd have to run it first on a reasonable set of data
09:27:32 <lispy> testing is still important in haskell tho....
09:28:14 <SamB> and worse, if the configuration of the program at the time did not permit exercising all of the code, well, you would have no assurance that it was all well-typed...
09:29:03 <SamB> its nice to know if your code could possibly work, you know?
09:30:35 <lispy> SamB: yes, i really like lisp, but haskell/ml type inference is wonderful
09:31:17 <SamB> I think I'm too flaky unreliable to be trusted with lisp
09:31:19 <lispy> SamB: i'd like to replace my usage of C with ocaml and my usage of lisp with haskell
09:32:23 <basti_> which one is harder lispy?
09:32:41 <lispy> basti_: from what set?
09:32:52 <lispy> c/ocaml/lisp/haskell?
09:32:53 <basti_> i mean, trading c for ocaml or lisp for haskell?
09:33:00 <basti_> which transition
09:33:21 <lispy> i haven't tried trading c for ocaml yet, it's something that occured to me in the last day or two
09:33:33 <gour> why not c -> haskell :-)
09:33:57 <SamB> well, the trouble with that one is you most likely still end up writing some C
09:34:03 <lispy> learning haskell was a big step even over lisp.  the closest lisp has to monads are macros
09:34:11 <gour> you mean, for ffi stuff?
09:34:18 <basti_> lispy: have you done some ocaml already?
09:34:36 <lispy> basti_: i heard through the tutorial but i have yet to actually code anything
09:34:44 <lispy> s/heard/read/
09:34:46 <basti_> ive tried a few lines
09:34:51 <basti_> the syntax scared me
09:35:10 <lispy> yeah, the syntax is not as nice as haskell
09:35:32 <SamB> why, I had to write a 40-line C module just to be able to write a Glk program with Haskell, and worse, it has to import Main.
09:35:48 <SamB> of course, thats really a problem with Glk...
09:35:49 <lispy> i view ocaml as a nicer c++.  I has roughly the same performance, but it's functional and has garbage collection
09:36:46 <basti_> and it has perl's readability
09:36:51 <lispy> the example programs at the great programming language shootout shows that it's a good match for C/C++ performance, but it's a much better language, IMO
09:37:02 <gour> what's the main lack in haskell?
09:37:32 <lispy> basti_: in my experience, perl is unreadable because the type system sucks and there are a lot of hidden things going on in the background
09:37:44 <basti_> i was half kidding.
09:37:50 <basti_> actually perl is far worse
09:37:51 <goron> Lemmih: ping again
09:37:52 <lispy> basti_: :)
09:37:59 <Lemmih> goron: ACK.
09:38:13 <basti_> gour: hmm im still thinking about that one
09:38:20 <goron> Lemmih: I installed the thing you posted to Haskell Cafe.
09:38:37 <goron> Lemmih: The installer should check for sudo.
09:38:39 <Lemmih> cabal-get?
09:38:46 <gour> basti_: which one?
09:38:51 <goron> Lemmih: yes
09:38:51 <lispy> gour: it's easy to write correct and elegant code in haskell, but it's much harder to write efficient code.  Especially if you have some real-time demand to meet.  I was interested in writing a 3d game for example
09:39:01 <basti_> gour: whats haskells greatest lack
09:39:01 <Lemmih> goron: Got a patch? (:
09:39:16 <goron> Lemmih: I don't have sudo on my system, so it just fails then.
09:39:26 <basti_> what lispy is saying is partly right, but i do not think this is a real lack.
09:39:47 <gour> basti_:ahh, ok
09:39:49 <goron> Lemmih: I don't have a patch. Sorry :(
09:40:04 <lispy> well, i have a presentation to prepare for.  Peace out.!
09:40:25 * gour agree with lispy (not based on own experience though)
09:40:48 <basti_> gour: loading dynamic libs is kinda awkward.
09:41:09 <gour> basti_: is it possible at all with ghc?
09:41:11 <goron> Lemmih: And, shouldn't it be possible to install something in your home dir as non-root?
09:41:18 <Lemmih> gour: A better module system and light-weight records.
09:41:38 <gour> are all those things fixable?
09:41:46 <basti_> gour: yes it is.
09:41:56 <gour> so, why not doing something in regard?
09:42:03 <gour> e.g. Haskell 2.0
09:42:04 <basti_> gour: well theres plugins
09:42:14 <basti_> but i was talking like, loading FFI functions from dynamic libs
09:42:25 <goron> Plugins are non-standard, right?
09:42:32 <basti_> i think so yes
09:42:44 <Lemmih> hs-plugins ~= GHCi.
09:42:45 <goron> In CL they are not.
09:42:54 <goron> Not that I like Common Lisp...
09:43:23 <goron> And I also don't know the overhead of plugins.
09:43:37 * gour busy preparing some other non-computer stuff
09:43:44 <goron> In theory they should be non-existent on multiple function calls.
09:44:28 <goron> But I can imagine implementations do have overhead, for <insert weird reason here>.
09:44:55 <Lemmih> goron: I didn't write the cabal-get installer but I'll look into it.
09:45:59 <goron> Lemmih: I don't care whether you will do it. It will be nice of you when you do, but I don't have a lot of interest in it at this point in time. I was just seeing the message and thought, well, why not?
09:46:46 <Lemmih> goron: It's more likely to be fixed if you paste it on the wiki.
09:47:08 <goron> @where cabal-get
09:47:09 <lambdabot> http://hackage.haskell.org/darcs/cabal-get-bootstrap/
09:47:17 <goron> Lemmih: @where?
09:47:30 <goron> I mean the specific page, I know the wiki.
09:48:15 <Lemmih> @wiki Hackage/TODO
09:48:16 <lambdabot> http://www.haskell.org/hawiki/Hackage/TODO
09:48:22 <Lemmih> @wiki Hackage_2fTODO
09:48:23 <lambdabot> http://www.haskell.org/hawiki/Hackage_2fTODO
09:50:19 <goron> Lemmih: done
09:50:27 <Lemmih> Thanks.
09:51:13 <goron> Will Cabal make the autotools obsolete (for Haskell)?
09:51:49 <gour> good question..
09:55:16 <pejo> (Question for lispys comment) Are there hard real time demands on games?
09:55:46 <basti_> (question on pejo) does haskell forbid hard real time?
09:56:16 <Lemmih> Hi SyntaxNinja.
09:57:03 <pejo> basti, I have no idea, but it seems pretty hard to give any guarantees - partly due to the lazy evaluation.
09:57:16 <basti_> .)
10:00:27 <SyntaxNinja> hi Lemmih
10:00:50 <goron> Lemmih (or SyntaxNinja): Will Cabal make the autotools obsolete (for Haskell)?
10:02:55 <SyntaxNinja> goron: not necessarily; for simple packages, yes, but for more complex ones, I don't htink we want to reimplement all that autoconf can do
10:23:06 --- topic: '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050906","see also #haskell.se #darcs"]'
10:23:06 --- topic: set by CosmicRay on [Tue Sep 06 09:07:03 2005]
10:24:01 <basti_> whoops
10:33:12 <psi> I'm looking in vim's haskell syntax file, and it says "Options-assign a value to these variables to turn the option on:", and then follows a list of options
10:33:28 <psi> what does that mean? I've tried 'set' but that doesn't work.
10:33:54 <lispy> pejo: re: hard real-time constraints.  I'd say no, but people that play at huge tournaments might disagree :)  My real-time goals would certainly be soft real-time.  And finally, because of lazy evaluation and garbage collection, haskell is not a natural choice for meeting hard real-time demands.
10:33:58 <psi> for instance, hs_highlight_types
10:37:05 <lispy> haskell is a good tool(tm) but that doesn't mean it's the right tool for every job
10:37:51 <gour> lispy: but it could be made a better one
10:38:55 <lispy> gour: in the case of hard-real time, it would take very noticable changes to the language
10:39:02 <schyffe> what's the command in hugs to see what infix an operator have?
10:39:48 <Igloo> :i
10:39:49 <lispy> gour: you'd have to revamp your run-time and it would probably be wise to make strict the default so that you know how long loops will take in all cases
10:39:52 <gour> lispy: i did not mean reat-time, but general applications which are mostly written in java/c++...
10:40:04 <lispy> gour: ah
10:40:12 <schyffe> :i (==) doesn't work
10:40:24 <schyffe> oh sorry
10:40:57 <lispy> gour: yeah, or even replacing java/c++ with real OO languages could help :)
10:41:12 <lispy> lisp and smalltalk are the ones i'm thinking of
10:41:35 <gour> lispy: i played with smalltalk many years ago
10:41:52 <gour> lispy: if u remember digitalk :-)
10:41:54 <lispy> gour: what did you think?
10:42:11 <gour> lispy: then i left programming & computers for a while
10:42:25 <basti_> because of smalltalk or despite smalltalk?
10:42:59 <gour> lispy: and now i'm coming again back and would like haskell to be for all jobs + ffi to some other C-libs
10:43:29 <gour> lispy: digitalk was selling smalltalk environment
10:44:48 <lispy> gour: i've only played with smalltalk programs.  it's on my list of languages to learn tho
10:44:48 <gour> and i'm concerned a bit with the hardship of anticipating where the haskell code has its performance-bottlenecks
10:45:20 <lispy> yes, and lazy eval can lead to space leaks too :(
10:45:35 <gour> lispy: well, i'm not in position to (re)-learn lot of languages
10:45:54 <gour> and fp-paradigm fits my mind atm :-)
10:45:59 <lispy> hmm...i wonder if those thunks could be thrown away at some point and then recomputed if they endup being needed....
11:02:56 <SamB> at least its usually fairly easy to find the bugs, when they aren't of the "Prelude.head on empty list" variety...
11:07:08 <CosmicRay> argh, nerdtv episode 1 posted, slashdotted, and the bt link is down.
11:07:12 <CosmicRay> it's hard being a geek.
11:07:47 <basti_> bt link down? that sucks lots
11:07:58 <basti_> i thought bt is about not being slashdottet
11:07:59 <basti_> d
11:08:37 <CosmicRay> the .torrent itself 404s
11:08:47 <CosmicRay> hey metaperl
11:08:52 <_metaperl> CosmicRay: hi!
11:10:31 <SyntaxNinja> hi CosmicRay
11:10:38 <CosmicRay> hey SyntaxNinja!
11:10:50 <CosmicRay> Sorry about not including the cabal flamewar du jour in HWN this week
11:11:04 <CosmicRay> I almost did, but by the time I reached the end of the discussion, I thought, "I haven't learned anything from this" ;-)
11:11:32 <Igloo> SyntaxNinja: ghc6 should be installable everywhere but m68k now, BTW, if you want to do a darcs update or anything
11:11:50 <CosmicRay> SyntaxNinja: but in other news, we need a EuroHaskell USA or something ;-)
11:13:02 <CosmicRay> I mean, the guy seemed to be criticizing you for not doing what you have already done.
11:15:29 <rafl> Igloo: Is there already someone that will to the m68k upload? I've got some NEW packages that wait on it..
11:16:44 <Igloo> It's compiling AFAIK
11:16:44 <kosmikus> ah, I haven't read this Cabal discussion on the ML recently; can anyone summarize it briefly?
11:18:18 <rafl> Igloo: Yay!
11:24:04 <CosmicRay> kosmikus: somebody wanted to know why cabal wasn't an abstraction over different compilers, and multiple people pointed out that this is exactly what cabal is.
11:24:44 <kosmikus> that's all? I remember a similar discussion here on the channel ...
11:25:39 <CosmicRay> heh
11:25:46 <CosmicRay> who started that one?
11:25:59 <kosmikus> probably the same person
11:26:07 <SyntaxNinja> Igloo: ooh cool!
11:26:15 <kosmikus> btw, SyntaxNinja, I have a question about Cabal ;)
11:26:17 <SyntaxNinja> CosmicRay: yeah, we totally need EuroHaskell USA.  Portland is the place, I think.
11:26:22 <SyntaxNinja> kosmikus: shoot.
11:26:34 <CosmicRay> SyntaxNinja: that would kick ass.  always wanted to visit that area anyway.
11:26:40 <CosmicRay> SyntaxNinja: what do you need to make it happen?
11:26:47 <kosmikus> I was looking into doing lhs2TeX in Cabal, and was hoping I could use hooks to do it
11:27:18 <SyntaxNinja> CosmicRay: I won't be able to organize it any time soon... got too many threads going on at once right now anyway...
11:27:26 <kosmikus> well, all is fine as long as I use Cabal+autotools, but I'd prefer doing everything from within Haskell, to gain Windows compatibility if possible
11:27:38 <SyntaxNinja> kosmikus: sounds good.
11:27:48 <SyntaxNinja> you want to generate documentation after building the package or something?
11:27:50 <CosmicRay> SyntaxNinja: I could help with this, but I know zero about portland, other than it's in one of those northwest states I've never visited...
11:27:50 <basti_> http://www.lyricsondemand.com/b/baccaralyrics/yessiricanboogielyrics.html < can we rhyme "yes sir i can curry" to that?
11:28:11 <CosmicRay> SyntaxNinja: but in any case we'd probably be looking at early summer 2006, I suppose, given that a lot of haskellers are tied to academic communities
11:28:15 <kosmikus> generating documentation is not the problem, but I need to detect additional tools, and pass additional data from the configure to the build phase
11:28:24 <kosmikus> the data structures seem to be fixed, though
11:28:31 <SyntaxNinja> CosmicRay: the discussion (as I understand it) was actuallly why isn't there an extra abstraction layer between cabal and the compilers and my reply was that there's no room between cabal and the compilers for such an abstraction layer.
11:28:47 <SyntaxNinja> CosmicRay: but I clearly don't understand the question, since I got accused of "evading" it.
11:29:15 <SyntaxNinja> kosmikus: ahh... you need to detect lhs2tex or something?  we don't have any kind of set up for that :(
11:29:33 <kosmikus> I need to detect a local TeX installation
11:29:44 <SyntaxNinja> cabal can only detect the tools it already knows bout.  you COULD add lhs2tex support directly to cabal, like I did for haddock.
11:29:51 <SyntaxNinja> it was super easy.
11:29:51 <kosmikus> it's definitely something that shouldn't be built-in into Cabal, like alex or haddock
11:30:09 <SyntaxNinja> alex and haddock are "built in" to cabal
11:30:36 <kosmikus> yes, that's what I mean; this is too specific, it shouldn't be built-in
11:30:44 <SyntaxNinja> CosmicRay: it could happen.  I'd have to get through some stuff here first.  if all my projects go swimmingly, then I'll probably have a good excuse for asking management for some time to organize such.
11:31:03 <kosmikus> but I'd like a way to extend the data structure
11:31:11 <SyntaxNinja> kosmikus: I would _really like_ to have something like preprocessors and preprocessor hooks for general tools, including ghc, haddock, etc, etc.
11:31:21 <SyntaxNinja> but we don't hvae that yet...
11:31:48 <SyntaxNinja> it would be something like CabalTool {name, autoDetect::IO FilePath, defaultFlags}
11:32:13 <SyntaxNinja> and for each CabalTool, flags will be added to --with-toolname= and --toolname-args=
11:32:34 <kosmikus> yes, something like that
11:32:41 <SyntaxNinja> kosmikus: yes please :)
11:32:47 <kosmikus> ok :)
11:33:27 <kosmikus> I guess my question is: is there (1) a design, but no implementation, or is there (2) no design, or is it (3) beyond the scope of Cabal
11:33:32 <SyntaxNinja> kosmikus: if you feel like whipping up a proposal, I'd be very happy. it could go on the wiki or on a mailing list
11:33:46 <SyntaxNinja> 2) no design, just some ideas that I just outlined
11:34:04 <kosmikus> ok, I'll think about what I need, then
11:34:05 <SyntaxNinja> but it should be modeled after preprocessors, I think, and have the same kind of hooks
11:34:08 <SyntaxNinja> sweeeeet
11:34:38 <kosmikus> "preprocessors" sounds strangely limited to me
11:35:01 <kosmikus> or maybe it's too advanced for me in some other way
11:35:02 <SyntaxNinja> well, I mean, it should implemented in a basically similar way to preprocessors
11:35:10 <SyntaxNinja> but not use the same structures or anything
11:35:16 <kosmikus> I really don't need much more than to detect additional tools and accept command line flags for them
11:35:23 <monochrom> every processor is a preprocessor to some other. (The non-well-ordering principle.)
11:35:37 <SyntaxNinja> right. but we should have a standard way to do that which is used throughout cabal
11:35:40 <kosmikus> I'm happy to say explicitly when to invoke them and what to do with them, I don't need any auto-dependency-generation-and-magically-build-everything for them
11:35:55 <monochrom> but magic is fun!
11:36:02 <SyntaxNinja> right, but it may inform the dependency discussion
11:38:40 <FrederikEaton> what MUA do people use to read the haskell mailing lists? I use mutt but whenever Simon Marlow or SPJ reply to something they start a new thread
11:39:09 <kosmikus> I use mutt myself, but I don't sort by thread
11:39:54 <monochrom> emacs
11:40:40 <monochrom> people who start new threads are annoying. fortunately there is option to organize threads by both references and subject
11:41:12 <FrederikEaton> the archives on the web have the same problem, any message from a Simon starts a new thread
11:41:52 <monochrom> that is a bigger problem because we can't re-program the archive
11:42:40 <FrederikEaton> what is that option? how does it work? is it like only when the subject is long enough? because if i organized by subject in my inbox i'd have a huge "hey" thread
11:43:19 <kosmikus> in my mutt, it seems to work
11:45:28 <Igloo> "work" as in thread by subject?
11:47:40 <FrederikEaton> if you have "strict_threads" set to the default ("no") then it will thread by subject, which I explained is problematic
11:48:00 * Igloo doesn't understand your explanation
11:49:08 <FrederikEaton> there are a lot of messages with simple subjects like "hi" or "hey" that would be threaded together if i sorted by subject
11:49:29 <Igloo> I don't see why that's a problem
11:49:35 <Igloo> They're only sorted adjacently, anyway
11:49:46 <monochrom> I don't see why a serious mailing list has lots of "hi" and "hey".
11:50:02 * Igloo also doesn't remember any such on the Haskell lists, and you can make options apply only to certain folders
11:50:36 <monochrom> I have never seen "hi" or "hey" on haskell and haskell-cafe
11:54:20 <FrederikEaton> sigh, i said "in my inbox" above
11:55:24 <FrederikEaton> is it easy to have different configurations for different folders?
11:59:03 * SamB doesn't think he wants to use Glk for his ZMachine thing after all, pushes Glk patches to another repository and unpulls them
12:02:50 <integral> @pointless \x -> modify (sieveCrossOut x)
12:02:50 <lambdabot> modify . sieveCrossOut
12:04:24 <Akshaal> why it is not possible in haskell?
12:04:26 <Akshaal> x :: (Typeable a) => [a]
12:04:27 <Akshaal> x = [1, 2, "3"]
12:05:02 <integral> wouldn't you mean: x :: [forall a. Typeable a => a] ?
12:05:19 <ski> rather x :: [exists a. Typeable a => a]
12:05:53 <SamB> what is this "exists" thingy?
12:06:03 <SamB> I don't think we have one of those...
12:06:13 <ski> which one has to render as  data SomeTypeable = forall a. Typeable a =>  MkST a;  x :: [SomeTypeable]
12:07:01 <SamB> isn't that called Dynamic?
12:07:04 <Akshaal> wow
12:07:31 <SamB> @index Dynamic
12:07:32 <lambdabot> Data.Dynamic
12:07:46 <ski> basically MkST :: (exists a. Typeable a => a) -> SomeTypeable  which is the same as MkST :: forall a. Typeable a => a -> SomeTypeable   which is what the data declaration means
12:08:34 <SamB> huh?
12:08:41 <Akshaal> what to rtfm?
12:08:44 <ski> Akshaal : anyway, if you define something of type  'forall a. ...'  then the *user* gets to dedice what 'a' should be, not you
12:08:51 <SyntaxNinja> FrederikEaton:  the Simons' mailers are the problem w/ new threads, not your client
12:09:28 <SyntaxNinja> (FWIW)
12:09:38 <SyntaxNinja> and ppl have been complaining about it for years, actually
12:09:40 <ski> Akshaal : i.e. with 'x :: forall a. ...' *you* have to ensure that x works for any type 'a'
12:09:41 <FrederikEaton> SyntaxNinja: yeah, but presumably there should be a way to get around that, short of asking them both to change
12:09:48 <kosmikus> FrederikEaton: yes, but it is easy to have different configurations for different folders
12:09:49 <FrederikEaton> oh, other people have complained?
12:09:56 <SamB> ski: couldn't you let the compiler do it for you?
12:10:05 <ski> SamB : do ehat ?
12:10:05 <kosmikus> FrederikEaton: look for "folder-hook" in the mutt documentation
12:10:05 <SyntaxNinja> yeah, it should practically be a mailing list FAQ ;)
12:10:14 <ski> s/ehat/what/
12:10:19 <SamB> ski: make sure that x works for any type a
12:10:38 <ski> SamB : but Akshaal didn't even want that
12:10:48 <SamB> point
12:11:02 <FrederikEaton> kosmikus: thanks
12:11:19 <ski> point is to realize that these two uses of type variables are diametrically opposite
12:11:23 <kosmikus> FrederikEaton: even has this particular situation as an example :)
12:12:12 <ski> in 'length :: forall a. [a] -> Int'  the definer of 'length' has to ensure it works for any type 'a' the user wants
12:13:45 <FrederikEaton> if other people have complained, maybe i should complain too
12:13:56 <ski> in the 'x' list Akshaal wanted, the definer get's ti decide what type each element should be (and the user must ensure s/he can handle anything) ... though here it's actually "anything, except we know it's in type class Typeable"
12:14:04 <integral> @pointless \a b -> f a (g b c)
12:14:05 <lambdabot> (. flip g c) . f
12:15:01 <Akshaal> Illegal polymorphic or qualified type: forall a. (Typeable a) => a
12:15:17 <SyntaxNinja> FrederikEaton: eh, you might mention it to them personally. I think they know it's an issue, though.
12:15:21 * SyntaxNinja &
12:15:24 <monochrom> in 'x :: forall a. Whatever a => [a]', you get to instantiate a to something you want. But that's one single a.  You can have x :: [Int], or x :: [String].  In the former, [1,2,3] is valid; in the latter, ["1","2","3"] is valid.  What do you make of [1,2,"3"]?  [Int]? [String]? Neither?
12:17:00 <ski> monochrom : [exists a. Whatever a *> a]   (and the former x should be exists a. Whatever a *> [a])
12:17:38 <kosmikus> where *> is an infix implicit version of (,) ?
12:18:05 <monochrom> what is *> ?  new ghc 6.4 stuff?
12:18:07 <ski> kosmikus : yes  (i realized that is necessary with explicite 'exists')
12:18:22 <ski> no, hypothetical first-class 'exists'
12:18:27 <FrederikEaton> SyntaxNinja: mentioned it to Marlow, no response
12:18:36 <monochrom> I like "hypothetical"
12:18:42 <ski> currently we can only encode it with datatypes
12:19:20 <monochrom> "hypothetical first-class exist" and "Higg's particles" are hypothesized to exist. :)
12:19:22 <ski> basically the type [exists a. Whatever a *> a] is encoded as [SomeWhatever]  where  data SomeWhatever = forall a. Whatever a => MkW a
12:20:49 <ski> monochrom : it's just more cumbersome to write the "existential datatype" solution .. easier to think about it as if we had light-weight 'exists'-syntax
12:21:19 <monochrom> the notation "Whatever a *> a" suggests something powerful.
12:22:21 <SamB> how hard/impossible would *> be?
12:22:39 <ski> monochrom : yes .. imagine signatures like    foo :: forall a. Bar a => (...a...) -> exists b. Baz a b *> (...a..b...)
12:23:24 <kosmikus> I think it should be "(Whatever a; a)", not "Whatever a *> a", but syntax is secondary as long as it's not implemented anyway
12:23:58 <ski> that would take some argument with type using any a in class Foo, and then for *some* unknown type b, which we only knows is related to a by typeclass Baz, return something of type using a and b
12:24:00 <Akshaal> not implemented? :[]
12:24:12 <SamB> so, how hard would this stuff be to implement?
12:24:20 <ski> kosmikus : yes, syntax is not fixed :)
12:24:51 <SamB> what would it look like in core?
12:25:11 <kosmikus> SamB: there are different designs, it's not clear which one is best
12:25:26 <ski> well, operationally, i's guess it's prolly not much harder than current existential datatypes )possibly no more oper. impl. is needed)
12:25:34 <ski> but, one also needs to typecheck it
12:25:48 <ski> s/'s//
12:26:37 * ski is currenlty only aware of Mercury having stuff like this
12:27:21 <kosmikus> operationally, it's easy, yes; in Core, an existential would be just a "pair" of a type and a value of that type
12:28:46 <kosmikus> however, it's unclear what to expect of type inference, and whether you want/need explicit (un)packing etc.
12:30:01 <SamB> reminds me of implicit params
12:31:20 <kosmikus> how so?
12:33:03 <ski> input instances act quite similar to implicit params
12:34:08 <kosmikus> input instances?
12:34:23 <ski> Foo a =>
12:34:50 <ski> (as opposed to For a *>)
12:35:22 <kosmikus> yes, certainly, they're both type system extensions based on qualified types
12:35:54 <kosmikus> but SamB said that existentials reminded him of implicit parameters ...
12:36:02 <ski> 'Eq a => [a] -> a -> Bool' can get expanded into 'EqInstance a -> [a] -> a -> Bool'
12:37:32 <ski> '(?x :: String) -> ...' can get expanded to 'String -> ...'
12:38:03 <ski> SamB : i assume this is more or less what you thought of ?
12:38:38 <ski> (hm .. '(?x :: String) => ...'  of course)
12:42:22 <integral> @index Maybe
12:42:23 <lambdabot> Data.Maybe, Prelude
12:44:43 <Akshaal> ok, thanks all. I realized that [1, 2, "3"] is not possible with existing compilers :)
12:46:39 <ski> Akshaal : almost that is possibly
12:47:09 <ski> i.e. you have to use a somewhat more clunkier syntax
12:47:31 <Akshaal> with intermediate MkST constructor?
12:47:36 <ski> yes
12:47:46 * Akshaal sighs
12:48:09 <ski> btw, you still can't "dynamically" check type of the values at runtime, in case you might have thought this was possible
12:48:39 <Akshaal> Data.Typeable can't help?
12:49:10 <integral> @index getArgs
12:49:10 <lambdabot> System.Environment
12:50:00 <ski> Akshaal : hm, actually (after having refresh what Typeable did :) it could possibly be done
12:51:18 <ski> but that's because you require elements to have types in class Typeable  (it wouldn't work otherwise)
12:51:42 <integral> @type forM
12:51:49 <lambdabot> bzzt
12:52:01 <integral> @index forM
12:52:02 <lambdabot> bzzt
12:52:53 <integral> @index putStrLn
12:52:54 <lambdabot> System.IO, Prelude
13:02:13 <SamB> ski: what did you *think* Typeable did?
13:02:36 <ski> i just didn't recall the details
13:03:52 <ski> (could also be phrased as : i just saw yet another class)
13:04:24 <Akshaal> mmm. can't understand error. f :: forall a . (Show a, Typeable a) => SomeTypeable -> Maybe a; f (MkST a) = cast a; main = print $ map f x
13:04:51 <Akshaal>     Ambiguous type variable `a' in the constraints: `Typeable a' arising from use of `f', `Show a' arising from use of `print'
13:05:35 <SamB> you need to be explicity about the type of main, I think
13:05:55 <SamB> no, wait.
13:06:04 <SamB> that won't help.
13:06:04 * SamB puzzles
13:06:23 <SamB> oh, this is about ST, is it?
13:06:32 <ski> no
13:06:36 <Akshaal> this is about 'f'
13:06:37 <ski> not ST monad
13:06:58 <ski> (ST was just short for SomeTypeable, there)
13:06:59 <SamB> whats the ST for?
13:07:08 <SamB> oh, sometypeable.
13:07:31 <Akshaal> data SomeTypeable = forall a . (Show a, Typeable a) => MkST a
13:07:32 <SamB> the thing is, I think I've got this kind of thing with the ST monad
13:08:01 <ski> hm
13:08:41 <ski> possibly, cast doesn't preserver the Show constraint, when passing from the internal type inside SomeTypeable, to the type 'a'
13:08:52 <SamB> actually, I think that was STUArray or something like that
13:09:27 <ski> aha
13:09:29 <Akshaal> but f signature has Show constraint on returned value type
13:09:31 <ski> of course
13:09:38 * ski is stupid
13:09:46 <SamB> I'm not certain it is possible to use STUArray without immediately choosing an element type...
13:10:23 <ski> Akshaal: yes you are correct, i don't think that what i thought could be a problem is one, now
13:10:27 <ski> anyway
13:10:39 <ski> you have a list x, and you map f over it
13:11:03 <Heffalump> if I do a forkProcess from a program running multiple (Haskell) threads, how many threads does the forked process end up with?
13:11:37 <ski> when doing so, you get a new list :: (Show a,Typeable a) => [a]
13:11:37 <Heffalump> aargh. Must think to read documentation *first* then ask question.
13:11:46 <ski> and then you print that list
13:11:48 <Heffalump> (the answer is that it just ends up with one thread)
13:12:07 <Akshaal> ski: yes
13:12:18 <ski> Akshaal : so the problem is, it doesn't know *which* type to try to convert each element to in main, before printing
13:12:49 <Akshaal> mmm
13:12:59 <ski> one possible way would be   main = print (map f x :: [Int])
13:13:07 <ski> another   main = print (map f x :: [String])
13:13:11 <ski> etc
13:14:02 <ski> (also, in more general, one doesn't necessarily have to constrain the expression by a literal type)
13:15:43 <Akshaal> how this typechecker error message related to this problem? :)
13:17:00 <ski>  Ambiguous type variable `a'
13:17:19 <ski> means it can't decide what type to assign to 'a'
13:18:04 * ski first thought the type error occured in f, but it actually occured in main, .. then it was not so hard to figure out why
13:19:35 <ski> @arr
13:19:36 <lambdabot> Aye
13:20:18 <ski> hm, why lambdabot not seems to answer to /msg
13:20:25 <ski> @type ()
13:20:27 <lambdabot> ()
13:20:38 <xerox> ski: are you identified?
13:20:48 <ski> um, maybe not ..
13:20:51 * ski checks
13:21:04 <Akshaal> why it can't find right code at runtime for printing value of Show class in this case?
13:21:32 <ski> xerox: yes "-NickServ- You have already identified"
13:21:56 <ski> Akshaal : it doesn't know what type you intend
13:22:08 <xerox> Maybe new lambdabot policies?  Or she hates you.
13:22:19 <ski> assume  x = [MkST 1,MkST 2,MkSt "3"]
13:22:24 <xerox> She answers me.
13:23:01 <Akshaal> didn't it store type near to value?
13:23:14 <ski> then if we do  main = print (map f x :: [Int])  this should print [Just 1,Just 2,Nothing]
13:23:35 <ski> while if we do  main = print (map f x :: [String])  this should print [Nothing,Nothing,Just "3"]
13:23:54 <ski> surely it stores type
13:24:10 <Akshaal> but if we do main = print (map f x :: [a]) this should print [Just 1, Just 2, Just "3"]
13:24:13 <Akshaal> ?
13:24:23 <ski> but when you call cast (inside f) you are trying to convert to some new given type (Int or String, here)
13:24:35 <ski> no, it can't do that
13:24:55 <ski> [Just 1, Just 2, Just "3"] is not well-typed, so it can't cast to that
13:25:06 <Akshaal> cast from 'a' to 'a' is always should be Just ... Not?
13:25:24 <ski> what would that list's type be ?  [Maybe ??] ?
13:25:44 <Akshaal> that list type [a]
13:26:04 <xerox> Akshaal: Maybe Int != Maybe [Char]
13:26:07 <Akshaal> that list type "Show a => [a]"
13:26:22 <ski> [a] is strictly not a type, but a type scheme .. you have to tell what a is (or comes from)
13:26:30 <xerox> Akshaal: [a] means: homogeneous list of values of type a.
13:26:44 <Akshaal> xerox: ah
13:26:48 <Akshaal> ok :)
13:26:55 <ski> essentially, the list has type [exists a. (Show a,Typeable a) *> a]
13:26:59 <xerox> Akshaal: Show a => [a] is a subset of the possible [a]
13:27:11 <xerox> ski: *> ?
13:28:07 <ski> a list of this, of type a (for some type a, which we know is in class Show and class Typeable)
13:28:15 <ski> s/this/things/
13:28:31 <ski> xerox : see log
13:29:42 <ski> xerox : more or less "Foo a =>" are *input* class constraints, while the hypothetical "Foo a *>" (which can be simulated) are *output* class constraints
13:30:30 <ski> Akshaal : you have a list where each element essentially carries around it's own type, then you are trying to cast over this list ..
13:31:27 <ski> Akshaal : you could try to cast to e.g. Int, then some casts will fail and some not ..
13:32:29 <ski> Akshaal : you could try to cast each separate element from it's own type 'a' to it's own type 'a' (and then package it in a MkST thing again) .. this also works  (but does nothing, in this case)
13:33:07 <ski> first is roughly  [exists a. (Show a,Typeable a) *> a] -> [Maybe Int]
13:33:30 <SyntaxNinja> FrederikEaton: Marlow is pretty busy right now.
13:33:55 <ski> second is [exists a. (Show a,Typeable a) *> a] -> [exists a. (Show a,Typeable a) *> Maybe a]  (each cast should actually succeed here)
13:34:13 <xerox> ski: "output" in the sense you can apply it to _some_ 'a' in the type?
13:34:25 <ski> i think you possibly want something like  [exists a. (Show a,Typeable a) *> a] -> exists a. (Show a,Typeable a) *> [Maybe a]     yes ?
13:34:32 <Akshaal> ok, thanks, I think I understand it
13:35:14 <ski> xerox : with input constraints the caller determines what the type 'a' is (given that 'a' is actually in the class)
13:35:14 <Heffalump> is there any way to indefinitely suspend a thread?
13:35:32 <ski> xerox : with output constraints the *callee* determines what the type 'a' is (and ensures that 'a' is actually in the class)
13:35:39 <xerox> Oh!
13:36:22 <ski> xerox : with input constraints the callee must work with *any* type 'a' the caller chooses (though the callee may assume 'a' is an instance of the class)
13:37:01 <xerox> Right
13:37:08 <ski> xerox : with output constraints the *caller* must work with *any* type 'a' the callee chooses to return (though the caller may assume 'a' is an instance if the class)
13:37:28 <xerox> :-D
13:37:39 <ski> see, it's dual :)
13:37:51 <FrederikEaton> SyntaxNinja: well I didn't name any names in my email (to haskell@haskell.org)
13:38:25 <ski> Akshaal : anyway, i think  [exists a. (Show a,Typeable a) *> a] -> exists a. (Show a,Typeable a) *> [Maybe a]  is not theoretically possible (in a sane way)
13:38:58 <ski> Akshaal : [exists a. (Show a,Typeable a) *> a] -> exists a. (Show a,Typeable a) *> Maybe [a]   on the other hand feels more like it should possibly be possible
13:39:02 * SamB wishes the WINE file browser dialog would just pretend / was \
13:39:16 <ski> Akshaal : understand what i mean ?
13:40:27 <Akshaal> not at all :)
13:40:58 * Akshaal has no strong theoretical backgrounds
13:40:59 <ski> Akshaal : btw, if all you want is to print out a string like "[Just 1,Just 2,Just \"3\"]" then this is quite simple
13:41:13 <Akshaal> f (MkST a) = show a
13:41:14 <Akshaal> ?
13:41:17 <Akshaal> :)
13:42:03 <ski> Akshaal : the one which ends in "*> [Maybe a]" tries to cast every element to some *common* type 'a'  (but *which* type 'a' ?)
13:43:02 <ski> Akshaal : the one which ends in "*> Maybe [a]" otoh tries to simultaneously cast every element to the common type which is the type of them all (and fails if even one of them has type different from the others)
13:43:24 <Akshaal> oh, understand
13:43:47 <ski> yes, even  instance Show SomeTypeable where show (MkST a) = show a  :)
13:44:39 <kosmikus> is this all some theoretical game, or do you need such a function, ski?
13:45:08 <ski> another way to print something like this would be to manualy print the '[',',',']' and print each element in a loop (without casting it)
13:45:40 <ski> kosmikus : Akshaal seemed to possibly want some kind of cast like this
13:46:48 <SyntaxNinja> FrederikEaton: OK. FYI, marlow is the list admin, so once he's back online, you might give him some time to catch up, then ping him about seeing if mailman has a way to cope with this problem for the archives.
13:46:53 * Akshaal tryed to learn QuickCheck this evening, and smoothly ended with existentional types
13:47:35 <kosmikus> why?
13:48:13 * Akshaal wished list of [Testable a => a]
13:50:47 <basti_> @type fst
13:50:50 <Akshaal> what a fun to 'map quickCheck testables'... ekh
13:50:55 <basti_> schyffe: look at that
13:50:56 <lambdabot> forall a b. (a, b) -> a
13:53:16 * ski 's off to sleep
13:54:59 * kosmikus too
14:02:39 * Itkovian too
14:08:32 <lispy> bah, sleeping at 14:00?
14:09:10 <boegel|home> lispy: nah, at 23:00
14:09:28 <lispy> boegel|home: ah
14:09:39 <boegel|home> lispy: here it is anways
14:09:46 <lispy> this is why we need a global time zone
14:10:00 <lispy> one big timezone for the whole planet
14:10:12 <lispy> and we should all get to work by 8am
14:10:21 <lispy> yes...
14:10:29 * lispy envisions the chaos
14:10:33 * xerox votes for close lispy in a small monad
14:11:13 <boegel|home> lispy: as long the universal time zone is close to GMT, I have no problem with that :)
14:11:50 <xerox> boegel|home: they're just numbers :)
14:11:52 <binary42> I vote we use lazily evaluated schedules :) no time. just an instance.
14:12:09 <lispy> bye :: (Monad m) => Lispy -> m Lispy; bye = return
14:12:25 <boegel|home> xerox: heh :)
14:14:44 <xerox> They needed me to do physical cleaning/ordering works around here... sob.  No code at all boegel|home!
14:15:17 <boegel|home> xerox: oh :( well, tomorrow then :)
14:15:33 * boegel|home goes to bed
14:15:42 <xerox> ...and the day after tomorrow: school - groan.
14:15:44 <boegel|home> bye everyone
14:15:52 <xerox> Good sleep boegel.
14:16:01 <boegel|home> xerox: heh ;) you'll miss it when you're done with school :)
14:16:17 <boegel|home> *over and out
14:22:05 <Cale> xerox: how's it going?
14:22:42 <xerox> I was about to start, they sucked my whole afternoon in cleaning/ordering work, grmbl..
14:37:27 <Cale> they?
14:38:14 <basti_> "they"
14:38:16 <lispy> i saw a presentation about ruby on rails today
14:38:23 <basti_> they who keep the UFO's secret
14:38:24 <basti_> ruby is fun
14:38:34 <lispy> it looks really convienent
14:38:45 <basti_> and obfuscateable.
14:38:52 <SyntaxNinja> what has ruby got that Haskell doesn't?
14:38:59 <lispy> basti_: oh, those guys.  Yeah, i had to move out of my last place cuz of them
14:39:00 <earthy> rails
14:39:07 <basti_> lispy: like how?
14:39:08 <SyntaxNinja> in fact, can anyone explain to me in 10 words or less why python caught on more than ocaml?
14:39:09 <earthy> oh, and 'Programming Ruby' ;)
14:39:11 * lispy nods an earthy 
14:39:27 <lispy> SyntaxNinja: dynamicly typed
14:39:32 <basti_> SyntaxNinja: its easy to write and relatively easy to read, and its like C and perl together.
14:39:34 <earthy> syntaxninja: Python had marketing and coolness
14:39:49 <earthy> oh, and Python comes with batteries included
14:40:21 <lispy> basti_: so one of the managers here uses a digital picture frame that cycles through pictures
14:40:32 <earthy> basically, perl, python and now ruby got popular because they were dead easy to surreptitiously start using in corners of systems
14:40:38 <neadjneki> hi
14:40:48 <lispy> basti_: he went from having it all hard coded to using ruby on rails with a database (and letting rails do most of it) in just a little work
14:40:49 <araujo> I wouldn't be sure to consider a dynamicaly typed system as something attractive in many cases
14:40:57 <basti_> yes, cruft is likely to be written in perl, ruby or python.
14:41:01 <neadjneki> could someone explain why this code never terminates: http://rafb.net/paste/results/sHX3eI17.html ?
14:41:41 <earthy> basti: but cruft is *exactly* where new programming languages get their chances
14:41:57 <lispy> dynamically typed languages appar more forgiving and thus easier to learn for most newbies
14:41:59 <basti_> thats why haskell should focus on cruft, do i get you right?
14:42:09 <earthy> no. :)
14:42:32 <lispy> haskell has lots of room for cruft
14:42:35 * lispy points at monads
14:42:39 <earthy> but should make it possible to facilitate spots where you have to deal with cruft
14:42:56 <earthy> hm. I'm obviously getting tired
14:43:00 <lispy> monads bring a lot of power, but with power comes responsibility
14:43:19 <basti_> lol
14:43:21 <SyntaxNinja> hm. so I wonder how much lack of a FilePath module has kept back Haskell
14:43:41 <SyntaxNinja> because "cruft is where new programming languges get their chances" is a pretty convincing point
14:43:48 <basti_> why don't we write one?
14:43:49 <SyntaxNinja> but maybe ocaml has a FilePath module
14:43:55 <SyntaxNinja> we have one now.  it was written for cabal
14:43:58 <basti_> oh
14:44:00 <basti_> great.
14:44:05 <SyntaxNinja> cabal-get install FilePath
14:44:06 <basti_> is it in ghc already?
14:44:09 <basti_> ohh
14:44:16 <zamez> Python also comes with a good library
14:44:24 <SyntaxNinja> no, we were going to get it into 6.4, but there was a flame war and it was decided not ot let it in
14:44:27 <earthy> but yeah, you don't start using new programming languages in core code
14:44:50 <Igloo> A flame war?
14:44:54 <basti_> uhm
14:44:54 <earthy> you start using them in little one-off hacks where they solve small annoyances
14:44:57 <basti_> okay.
14:45:05 * kosmikus reappears ...
14:45:29 <earthy> and then you gain confidence in the language and your abilities with it
14:45:45 <earthy> and you slowly start integrating the language in more of your work
14:45:54 <earthy> and that's how the languages get popular
14:45:58 <lispy> learnability is crucial to adoption when you're targeting individual programmers
14:46:09 <lispy> but when you're target companies it's different
14:46:17 <kosmikus> I think it should be possible to compile a Haskell program dynamically typed with a compiler flag ...
14:46:20 <earthy> and I've seen Perl, Java, Python and now Ruby take the exact same path
14:46:40 <earthy> although Java had some *very* strong marketing behind it
14:46:42 <basti_> kosmikus: and THEN? :-o
14:46:49 <basti_> what would haskell be without its type system?
14:46:56 <integral> perl6?
14:46:59 <integral> :-P
14:47:02 <earthy> basti_: who was saying haskell without its type system?
14:47:05 <basti_> lol
14:47:08 <kosmikus> basti_: no one could complain anymore that the static type system is the culprit
14:47:17 <basti_> hhmm
14:47:25 <basti_> i fail to see how you want to make that dynamic
14:47:55 <kosmikus> not so difficult, is it?
14:48:12 <basti_> :/
14:48:19 <lispy> the type system is very fundamental to a language
14:48:26 <monochrom> you can always delay type-checking to runtime.
14:48:28 <kosmikus> you could even *run* the type checker and only include runtime checks where type errors are
14:48:37 <basti_> i mean, that would basically mean muteables right?
14:48:40 <monochrom> I don't see a benefit, but people love that.
14:48:41 <earthy> you can always ignore types
14:48:49 <kosmikus> nono, you don't change the language
14:49:08 <kosmikus> you only give people who want it the satisfaction of being able to *run* their syntactically correct programs
14:49:23 <basti_> hmm
14:49:30 <earthy> even if the types don't match
14:49:34 <basti_> okay i think i see what you mean
14:49:37 <earthy> hey, no problems there
14:49:40 <kosmikus> and, I won't argue, sometimes it's actually easier to correct an error if you see it occurring at runtime than to correct it using a type error message
14:49:49 <kosmikus> especially if you are not familiar with type error messages
14:49:56 <basti_> hmm
14:50:17 <Cale> Are you sure that there are no technical problems with not at least doing some work beforehand?
14:50:25 <lispy> i'm not sure the runtime has enough type information to do the checks
14:50:38 <kosmikus> Cale: no, I'm not sure :) but I think it might be worth investigating ...
14:50:45 <Cale> You at least need to know which instances of typeclasses will be used
14:50:46 <monochrom> You can keep and check the type information during runtime
14:51:02 <lispy> then we'd have lisp
14:51:05 <kosmikus> Cale: but I'm not saying that the language should be changed
14:51:10 <earthy> hm. it's much *much* more agreeable outside than indoors
14:51:12 <Cale> If you don't, then you need to compile things at runtime
14:51:14 <monochrom> if there are incurable type errors, you can still postpone reporting them until runtime
14:51:26 <earthy> time to enjoy a whiskey and then retire. g'night all
14:51:52 <kosmikus> Cale: I only want that every type-incorrect program should be transformed into an executable that only fails as soon as the first type-incorrect part of the program is executed
14:52:07 <monochrom> Yes!
14:52:28 <kosmikus> earthy: good idea
14:52:34 <ulfdoz> Woah, one more part to test by execution.
14:52:40 <Cale> is there really all that much benefit to that?
14:52:41 <lispy> then there would be motivation to get ghc to give good stack traces ;)
14:52:49 * kosmikus looks for his single malt collection
14:53:09 <kosmikus> Cale: not for me :)
14:53:19 <Cale> I suppose some people really like dynamic typing, but I can't see why.
14:53:20 <monochrom> Hell, alias ghc=yes; alias a.out="/usr/bin/ghc Main.hs; ./a.out"
14:53:29 <monochrom> that will do the trick.
14:53:31 <ulfdoz> I do not see any benefit. If the typing can be made safe, it should.
14:53:33 <kosmikus> Cale: but I've discussed frequently enough with people that think dynamic typing is a blessing
14:53:42 <Cale> Personally, I find it *much* more difficult to program without static typing.
14:53:44 <kosmikus> by now I think it might ease the transition if it'd be just a flag
14:53:46 <monochrom> "all errors are reported at 'runtime'!"
14:54:12 <earthy> how hard would it be to add that to EHC, I wonder
14:54:13 <kosmikus> monochrom: :)
14:54:37 <SyntaxNinja> Igloo: well, not really a flame war.
14:55:11 <_metaperl> Cale: have you seen Hilbert II: http://www.qedeq.org/
14:55:32 <lispy> oh, i wonder, if i wanted to make a bridge ocaml <---> haskell, where should i start?
14:56:05 * lispy thinks of fun projects faster than he can switch betveen them ;)
14:56:10 <xerox> I perfectly agree with Cale
14:56:33 <xerox> Quoting Duncan - I'm too dump to program without static typing.
14:56:35 <xerox> *dumb
14:56:48 <kosmikus> yes, sure, I don't disagree
14:56:50 <Cale> _metaperl: I don't know why, but I find that those kinds of efforts seem kind of pointless to me.
14:56:57 <kosmikus> I don't want to disable static typing
14:57:02 <_metaperl> Cale: oh I see
14:57:07 <kosmikus> but why do you want to impose your world view on everyone?
14:57:07 <Cale> well, I have some reasons, but they take a while to explain
14:57:35 <xerox> kosmikus: indeed, I do just agree in the sense I feel needing it today :-)
14:57:49 <kosmikus> Cale: I have time :)
14:58:14 <Cale> kosmikus: Dynamically typed languages exist already :)
14:59:32 <Cale> I suppose you can make a new language which is "somewhat like Haskell except it is dynamically typed", but that seems like a strange thing to me.
14:59:32 <ulfdoz> In my opinion dynamic typing doesn't solve any problem, it just delays it to time of execution (which sometimes is critical) or even hides problems.
14:59:35 <lispy> man, i'm soo tried after my presentation.  All my nervous energy is gone.  I'm spent :)
14:59:36 <kosmikus> Cale: agreed. but pure lazily-evaluated languages with type classes?
15:00:30 * lispy extinguishes both ends of the candle and curls up to the warm air output on his laptop
15:00:34 <kosmikus> Cale: no. again, to be absolutely clear. I don't want to change the language.
15:00:45 <kosmikus> Cale: the idea is that in the end, any correct program must be statically correct.
15:01:08 <kosmikus> my motivation is the following: if you get a type error in your program, then currently, you're prevented from executing the program at all
15:01:25 <Cale> yeah, allowing those programs to be accepted changes the language
15:01:28 <xerox> ...and go sit in the angle!
15:01:44 <kosmikus> while this is good from a philosophical point of view, it hides potentially valuable information about the location of the error from you
15:01:47 <lispy> xerox: er?
15:02:11 <xerox> lispy: "you can NOT run it!!..."
15:02:19 <monochrom> True.  main = let x = "1"+2 in putStrLn "hello" >> putStrLn x   you may want it to at least print hello.
15:02:32 <kosmikus> Cale: it's fine if the compiler cries during compilation: your program is type incorrect!!!! it's not valid!!! it might even change the binary to produce the same message initially on every program run.
15:02:56 <SyntaxNinja> strong typechecking is for weak minds
15:03:18 <lispy> SyntaxNinja: are weak minds anything like weak pointers?
15:03:27 <ptolomy> ooh ooh. Newbie question: I've been browsing the parsec source, and I saw 'data LanguageDef st = LangaugeDef { <list of type signatures separated by commas> }". What is that? I've never seen that sort of '{' usage before.
15:03:32 <monochrom> My mind is weak.
15:03:41 <earthy> ptolomy: records
15:03:42 <xerox> ptolomy: they're called records.
15:03:45 <ptolomy> hmm.
15:03:47 <ptolomy> Interesting.
15:03:49 * ptolomy googles.
15:03:52 <earthy> i.e.: products with named fields
15:04:01 <lispy> { recordname :: typeofrecord, ... }
15:04:20 <Cale> { fieldname :: typeoffield,... }
15:04:21 <kosmikus> monochrom's example goes into the right direction. If it fails after printing "hello", I can see that the error must have something to do with the "x".
15:04:30 <earthy> recordtype :: recordof { elementname :: typeofelement }
15:04:40 <kosmikus> For some people, this sort of reasoning might be easier or more familiar than reading type error messages.
15:05:22 <monochrom> I understand the psychology of many programmers.  Though I disagree with them, I understand their strange psychology.
15:05:48 <kosmikus> I think it's quite understandable, acutally.
15:05:51 <lispy> kosmikus: i'd say that improving type checkers so that the errors generate are easier to work with is a much more worthwhile venture
15:05:57 <ulfdoz> but doesn't that mean in the first way, that error messages of the type checker have to be improved?
15:06:14 <kosmikus> lispy: perfectly worthwhile, too.
15:06:36 <kosmikus> lispy: but why not give this *additional* information for people who want it.
15:06:49 <ptolomy> Are records somehow non-standard?
15:06:50 <Cale> I don't quite understand why you'd want to ever report errors later than they could possibly be reported
15:06:57 <lispy> ghc --force ?
15:07:08 <monochrom> kosmikus: I have not seen a Haskell implementation that does not scream "the problem is about x".
15:07:18 <ulfdoz> I fear that it ends up like gcc with -Wno.
15:07:28 <Cale> especially in a lazy language where the order of evaluation might be somewhat tricky to determine
15:07:35 <kosmikus> monochrom: because it's a simple program.
15:07:54 <monochrom> I am unconvinced.
15:08:10 <Cale> ptolomy: they're quite standard
15:08:13 <lispy> monochrom: monads are known to generate obscure type messages
15:08:51 <ptolomy> ahah. Found it.
15:08:56 <ptolomy> I'm bad at searching.
15:09:17 <kosmikus> ok, one thing is definitely to improve type error messages
15:09:22 <kosmikus> ghc is better than hugs
15:09:31 <lispy> ptolomy: iirc google was optimized for 1-2 word searches.  maybe knowing that will help :)
15:09:48 <monochrom> I think here is a better example.  data Mine = Blah; main = putStrLn "hello" >> putStrLn Blah
15:09:53 <kosmikus> but to be honest; most of the time I don't even look at type errors. I look at the line numbers and look if I don't immediately see the error.
15:10:00 <xerox> Cale: I was wondering whether I should try to do a more decent parser instead of sticking with list of tuples.
15:10:07 <kosmikus> In <10% of the cases, I have a closer look at the message.
15:10:26 <xerox> I do the opposite  o_O
15:10:37 <lispy> kosmikus: same here, the error message is often incomrehensible when i try to compare it to the way it hink about my code
15:10:58 <monochrom> Haskell would say a rather mystic "Mine is not an instance of Show".  You go, "woah, what is Show?" and you call it obscure.
15:11:01 <xerox> I carefully read them in first instance, I found them helping.
15:11:22 <xerox> find, even
15:11:27 <monochrom> Now I don't know much about Python, but wouldn't Python give a similarly obscure message?
15:11:40 <kosmikus> one thing, otoh, that I hate about Haskell programs is that if I start changing something in a large program, my program will turn into a non-executable thing until I got it completely right again, and that might be a loooong time away
15:12:07 <xerox> Good point.  Because of this I sometime (ever?) restart from scratch.
15:12:16 <kosmikus> if somehwere in between, I find an unrelated bug, and would like to verify that I've corrected it correctly, I cannot test it
15:12:23 <kosmikus> I have to do darcs magic to do that
15:12:34 <monochrom> I wager that Python would say the same thing, "Mine has no ___print_me___ method"
15:12:44 <adept> well, error "under construction" and less type signatures usually help me
15:12:57 <z0d> where can I find some useful networking code? e.g. a POP3 client or something like that
15:13:03 <monochrom> In this regard I don't think Python is more "helpful" than Haskell.  It only postpones the message, that's all.
15:13:24 <lispy> z0d: there is an imap implementation iirc some where
15:13:32 <xerox> monochrom: maybe that way you give more introspection power...
15:13:35 <xerox> Just guessing.
15:13:37 <kosmikus> monochrom: depends on whether it's really unrelated or not
15:13:46 <adept> if you want to talk about cryptic error messages, just use some STArrays ...
15:13:46 <xerox> "you get", I can't type today.
15:14:07 <kosmikus> anyway, I still think that my suggestion is about giving additional information to programmers, only that
15:14:20 <kosmikus> it should be possible, so why not offer it
15:14:30 <kosmikus> I'm not proposing to make Haskell dynamically typed
15:14:36 <lispy> z0d: but, i'm not seeing it now on google
15:15:28 * ptolomy tries to imagine dynamically typed haskell. oooh. weird.
15:15:52 <monochrom> I am still unconvinced.
15:16:07 <kosmikus> what's bad about it?
15:16:07 <monochrom> I mean I'm convinced of the "change little, run again" argument.
15:16:21 <monochrom> But on the "obscure error message" front I don't see a difference.
15:18:58 <kosmikus> monochrom: by now (but I'm programming in Haskell for almost 10 years now), I'm so familiar with type error messages that I rarely feel the need to run my program instead
15:18:59 <monochrom> But perhaps the difference is you can enter the Python error message into Google and get ten tutorials in Python-for-dummies language.
15:19:03 <ulfdoz> bye
15:19:49 <kosmikus> but I can understand python programmers somewhat when I talk to them and they tell me that it's so nice to be able to run your programs as soon as they're syntax correct, and find the errors "interactively"
15:20:15 <xerox> That's what I meant with "you get more introspection"
15:21:13 <monochrom> It's so nice to be able to type-check my programs as soon as they're written, and find the errors "interactively". :)
15:21:47 <monochrom> (Imagine an Eclipse-like environment.)
15:22:31 * kosmikus tries to imagine something slow with an incomprehensible GUI ...
15:22:42 <monochrom> haha
15:23:16 <monochrom> The haskell extension to eclipse is not bad.
15:23:27 <kosmikus> never tried it
15:23:41 <monochrom> you enter something, then click a button, then you get brought to error sites.  pretty interactive.
15:24:04 <monochrom> in simple cases you don't even click a button
15:24:15 <z0d> lispy: thanks
15:24:57 <kosmikus> I'm not opposed to all this
15:25:12 <kosmikus> (as long as it isn't mandatory)
15:25:13 <monochrom> it is so much fun to apply logic to poke fun at mainstream programmers and bust their hypocrisy.
15:26:05 <xerox> > (read :: String -> [(String,Rational)]) $ "[(\"FF\",1/2)]"
15:26:06 <xerox> *** Exception: Prelude.read: no parse
15:26:10 <xerox> What am I missing?
15:26:34 <xerox> Nevermind, got it.
15:26:44 <kosmikus> 1/2 isn't a rational, I think
15:26:58 <xerox> Exactly.
15:27:17 <xerox> Bah, I'm too sleepy.  Goodnight folks.
15:27:35 <kosmikus> monochrom, Cale: ok, I guess I have to find better arguments ;)
15:29:40 <monochrom> To me, the only tenable argument for dynamic typing is you want a type system so powerful that it's undecidable.  array-bound is an example.
15:30:05 <lispy> z0d: you might try searching by rfc numbe
15:30:31 <lispy> z0d: someone wrote a parser for internet messages (email)
15:30:33 <kosmikus> monochrom: nonono, I don't want that -- I believe in static typing ...
15:30:58 <kosmikus> and I think that the majority of people complaining about static typing and it's restrictions don't even know what "undecidable" means ...
15:32:02 <lispy> kosmikus: oh, that's easy.  when my gf asks me if i want cherry or carmel ice cream i can't make up my mind, so it's undecidable
15:32:37 <monochrom> you can reduce it to the question of which one she wants
15:32:38 <kosmikus> undecidable == both ?
15:49:40 <z0d> lispy: thanks, found it: http://cryp.to/hsemail/
15:52:56 <ptolomy> Is there an advantage of Happy over Parsec beside bottom-up parsing being more familiar and maybe speed?
15:55:47 <monochrom> No.
15:57:03 <kosmikus> mattam: ping
15:57:15 <monochrom> speed is nice.
15:59:11 <heatsink> I'm getting a strange ghc panic
15:59:21 <heatsink> I've got the file down to one line...
15:59:23 <heatsink> class Foo a; data Bar = Bar (Foo Int)
16:00:03 <basti_> panics my ghc too
16:00:22 <heatsink> I have absolutely no clue what's wrong with it, it looks like valid code to me
16:00:27 <basti_> its not.
16:00:55 <basti_> this class definition is strange.
16:01:12 <basti_> and then, you would use a class differently in the data definition
16:01:17 <heatsink> It's just a class with no members.  You can give it a "where"...
16:01:35 <basti_> and what you do with it then?
16:01:36 <heatsink> Oh, I need to make a type variable
16:01:42 <heatsink> thx
16:01:52 <kosmikus> doesn't panic here
16:02:38 <heatsink> wait, no... (Foo Int) is a type
16:03:01 <basti_> It is?
16:03:09 <heatsink> basti_: What's the problem iwith the class definition?
16:03:10 <basti_> ohh
16:03:19 <basti_> no its not
16:03:21 <basti_> what you want to say is:
16:03:38 <basti_> data Bar = Bar (Foo a) Int
16:03:40 <basti_> dont you?
16:03:47 <basti_> or data Bar a
16:03:50 <Cale> Is Foo supposed to be that typeclass?
16:04:05 <kosmikus> I get (for the above one-liner):
16:04:08 <basti_> there is nothing explicitely wrong with the class definition no
16:04:20 <Cale> It's the data declaration that's the problem
16:04:22 <kosmikus> C.hs:1:25:
16:04:22 <kosmikus>     Class `Foo' used as a type
16:04:22 <kosmikus>     In the data type declaration for `Bar'
16:04:24 <basti_> data (Foo a) => Bar a = Bar a Int or something
16:04:27 <Cale> yes
16:04:29 <Cale> that's the problem
16:04:35 <heatsink> oh, heh.
16:04:39 <basti_> it shouldnt panic anyway.
16:04:47 <basti_> but give something like an error message
16:04:49 <kosmikus> basti_: version?
16:04:58 <basti_> -6.4
16:05:10 <kosmikus> try with a more recent one, then :)
16:05:16 <kosmikus> seems to be fixed
16:05:18 <heatsink> now I have: class Foo a; data Bar a = Bar (Foo a)
16:05:23 <heatsink> This also panics.
16:05:31 <basti_> 6.5 gives a reasonable error message
16:05:49 <basti_> heatsink: because Foo is not to be used that way
16:06:00 <basti_> because Foo is a type of types, and not a type of values.
16:06:44 <kosmikus> yes, so it seems this problem is fixed in both 6.5 and 6.4.1
16:06:59 <heatsink> basti_: I don't understand.
16:07:13 <heatsink> I thought foo was of kind *->*, and applying foo to a type produces a type
16:07:25 <basti_> heatsink: your syntax would work for a data Foo a, but not for a class Foo a.
16:08:28 <heatsink> Okay...
16:08:39 <heatsink> Maybe I should explain what I want to do
16:08:53 <kosmikus> classes are not types
16:10:01 <heatsink> Apparently so, I didn't know there were usage differences between classes and types.
16:10:07 <Cale> heatsink: You can only apply classes to types in class contexts
16:10:22 <Cale> Like (Ord a) => a -> a -> Bool
16:10:36 <Cale> Ord is a class, you can't use it on the right side of the =>
16:10:49 <kosmikus> heatsink: what do you mean by (Foo Int) ?
16:11:51 <heatsink> What I want to do is parametrize my data and functions over a datatype
16:12:30 <Cale> data Bar a = Bar (a Int)?
16:12:55 <heatsink> No...
16:13:24 <basti_> heatsink: you dont have to use classes for that.
16:14:22 <Cale> give us some examples of types which you'd like to allow?
16:14:31 <heatsink> The original signature for Foo before I made the minimal example was
16:14:41 <heatsink> class (Integral n, Eq a) => IntExp n a where getValue :: a -> Maybe n
16:15:09 <heatsink> In other words, I'm making an interface to a data type a, that can maybe be converted to an integral type
16:16:06 <Cale> okay
16:16:14 <heatsink> With this, I want to make (Integral n, Eq a, IntExp n a) => Bar [IntExp n a]
16:16:36 <heatsink> So bar contains an array of data that is:
16:17:22 <Cale> er, that's not the least bit syntactically correct, but I might be able to guess what you're trying to do
16:17:22 <heatsink> of type a, and can be passed to the getValue :: a-> Maybe n function, for the chosen types n and a
16:17:33 <heatsink> (Integral n, Eq a, IntExp n a) => Bar n a = Bar [IntExp n a]
16:17:49 <Cale> that's syntactically incorrect
16:18:05 <Cale> IntExp is a class, you can't have a list of it
16:18:28 <basti_> :-o
16:18:32 <heatsink> okay
16:18:37 <Cale> (Integral n, Eq a, IntExp n a) => Bar n a = Bar (a,n)
16:18:50 <Cale> you could do something like that
16:18:52 <Cale> or eve
16:19:02 <Cale> (Integral n, Eq a, IntExp n a) => Bar n a = Bar [(a,n)]
16:19:59 <Cale> Do you want to allow for having a heterogeneous list, where the types of the included values can all e different so long as they're in the IntExp class?
16:20:05 <heatsink> no
16:20:41 <Cale> I'm afraid I'm still not sure what you're exactly after, and it's time for dinner -- I'll be back in a bit
16:20:45 <heatsink> okay
16:21:36 <basti_> i'm not sure either
16:23:21 <heatsink> I guess that the data involved is just (a) ... dunno why I didn't figure that out before
16:23:36 <basti_> what are you trying to do exactly
16:24:33 <heatsink> Bar should contain a list of data, on which I can call getValue.  And the type of Bar should uniquely determine the type of getValue.
16:24:48 <basti_> humm.
16:25:09 <basti_> @type find
16:25:14 <lambdabot> bzzt
16:25:34 <heatsink> so that's just (Integral n, Eq a, IntExp n a) => Bar n a = Bar [a]
16:25:38 <basti_> @type Data.List.find
16:25:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:26:17 <basti_> @plugs find (==1) [(2,"hello"),(1,"elmo")]
16:26:19 <lambdabot> <Plugins.Eval>:1:26:
16:26:19 <lambdabot>   No instance for (Num (a, [Char]))
16:26:19 <lambdabot>   arising from the literal `1'
16:26:24 <basti_> uhm
16:27:49 <basti_> argghhhh
16:27:59 <basti_> ahhh
16:28:16 <basti_> @eval  find ((1==).fst) [(2,"hello"),(1,"elmo")]
16:28:18 <lambdabot> Just (1,"elmo")
16:28:21 <basti_> something like that maybe?
16:29:36 <heatsink> nope.  it's not in the standard libraries.
16:29:50 <basti_> actually youre trying to associate yes?
16:29:54 <heatsink> I've figured out what to do with the type signature, though.
16:29:58 <basti_> you have a list that contains 2-tuples
16:30:14 <basti_> and you want to associate by the first of the tuple
16:30:32 <basti_> you give an element, and your function searches through the list, and returns the matching second element
16:30:36 <basti_> no?
16:31:23 <heatsink> basti_: no, getValue is conceptually more like a type cast.
16:31:34 <basti_> did you notice that haskell has variable types?
16:31:51 <basti_> lookup 1 [(2,"hello"),(1,"elmo")]
16:31:55 <basti_> whoops
16:31:58 <basti_> @eval lookup 1 [(2,"hello"),(1,"elmo")]
16:32:00 <lambdabot> Just "elmo"
16:32:04 <basti_> @eval lookup 1 [(2,3.4),(1,5.0)]
16:32:05 <lambdabot> Just 5.0
16:32:24 <basti_> the type of the result depends on the type of the list
16:32:33 <basti_> and only on that.
16:32:55 <basti_> types will propagate through that function too
16:32:58 <heatsink> I'm not seraching a list.
16:33:03 <basti_> @type (lookup 1 [(2,3.4),(1,5.0)])
16:33:05 <lambdabot> forall b. (Fractional b) => Maybe b
16:33:13 <SyntaxNinja> This is an example from Systme.Process's haddock page: For example, to start a process and feed a string to its stdin:
16:33:14 <SyntaxNinja>    (inp,out,err,pid) <- runInteractiveProcess "..."
16:33:14 <SyntaxNinja>    forkIO (hPutStr inp str)
16:33:18 <SyntaxNinja> why use forkIO here?
16:33:19 <basti_> ("maybe a fractional")
16:33:29 <basti_> what are you doing then heatsink?
16:33:40 <basti_> i certainly got the impression you were
16:33:59 <heatsink> I'm making a list of values, some of which can be interpreted as some integral type.
16:34:14 <basti_> what about the others?
16:34:29 <heatsink> The others can only be compared for equality.
16:34:39 <Heffalump> SyntaxNinja: in case the process doesn't read it all immediately and your hPutStr blocks?
16:34:49 <basti_> now what do you want to do with these values?
16:35:17 <basti_> the first problem i see is: they are different types
16:35:26 <basti_> you can't say lots about values of different types.
16:35:41 <SyntaxNinja> Heffalump: so if I want it to block, then I don' tneed that?
16:35:46 <Heffalump> I think so.
16:36:05 <basti_> i mean just because a value is type (Eq a) => a, that doesnt mean you can compare it to another value b.
16:36:15 <SyntaxNinja> similarly, if i want to block until it's waiting for me (I want to get all the input until it's blocking on me) can I just use hGetContents?
16:36:23 <basti_> so you get two values out of that list, which might be comparable, or not, depending on luck?
16:36:49 <Heffalump> SyntaxNinja: no
16:37:05 <heatsink> basti_: in (Integral n, Eq a, IntExp n a) => Bar n a = Bar [a] all the list elements have the same type.
16:37:10 <Heffalump> I'm a bit confused about exactly what would happen, but I don't think it would work.
16:37:19 <basti_> heatsink: yes, a.
16:37:20 <SyntaxNinja> hm. Iwonder how I do this then
16:37:25 <Heffalump> what do you want to do?
16:37:42 <SyntaxNinja> I want to eat all input until its done
16:37:49 <SyntaxNinja> but its not done until its waiting for input from me :)
16:38:04 <basti_> heatsink: so these a qualify for whatever a might be. n does not have to do with it.
16:38:29 <Heffalump> and when it is waiting for input from you, then what do you want to do?
16:39:09 <heatsink> basti_: n is important for calling methods of IntExp
16:39:18 <basti_> ah.
16:39:41 <SyntaxNinja> I want to promt MY user for input
16:39:49 <basti_> so wheres the problem?
16:40:28 <Heffalump> do you basically want to take a program that doesn't prompt for input, and make it do so?
16:40:32 <Heffalump> s/do/so/
16:40:46 <SyntaxNinja> Heffalump: no, I want to make a wrappera round a program, like a GUI
16:40:54 <SyntaxNinja> for a command-line program
16:41:11 <heatsink> The problem was that when I came in, I said (Integral n, Eq a) => Bar n a = Bar [IntExp n a] ... and the compiler panicked so I didn't know where the problem was
16:41:13 <Heffalump> hmm, ok.
16:41:25 <basti_> heatsink: thats solved, then?
16:41:28 <heatsink> yes
16:41:33 <basti_> okay
16:41:35 <Heffalump> I'm not entirely sure if you can tell the difference between "producing output really slowly" and "blocking waiting for input"
16:41:42 <heatsink> :)
16:41:55 <basti_> :)
16:51:15 <SyntaxNinja> Heffalump: yeah
16:51:21 <SyntaxNinja> that's what I was afraid of :)
16:52:31 <Heffalump> you can fudge it with a timeout
16:52:47 <SyntaxNinja> right
16:53:14 <basti_> cyall.
16:55:58 <heatsink> night basti_
16:56:01 <heatsink> or l8r
16:56:12 <Heffalump> hmm, the cool compositionality of waiting on sockets that forkIO gives you is rather broken if you then want to forkProcess :-(
16:57:07 <SyntaxNinja> hm. if I use waitForProcess after runInteractiveProcess, then the other process blocks indefinitely
16:57:14 <SyntaxNinja> maybe somehow my read isn't happening
16:59:32 <Heffalump> try using ghc -threaded and forkOS
16:59:41 <Heffalump> I think waitForProcess will block the OS thread.
17:02:20 <Heffalump> anyone know if getdtablesize is available as a Haskell function somehow?
17:02:26 <SyntaxNinja> hm yeah
17:02:58 <Heffalump> why do you want to waitForProcess?
17:04:36 <SyntaxNinja> not sure whether or not I do.
17:04:46 <SyntaxNinja> basically, I wanted to be sure it was done outputting
17:07:03 <Heffalump> you could forkOS a thread to wait for it
17:07:12 <Heffalump> then send an exception to the main thread to stop it trying to read more
17:07:23 <Heffalump> though it'll fail to read more anyway if it's just sitting there slurping the input
17:07:27 <Heffalump> s/input/output/
17:13:19 <Heffalump> @seen shapr
17:13:20 <lambdabot> shapr is in #haskell. I don't know when shapr last spoke.
17:35:30 <palomer> elements of a binary tree have multiplicity of one, right?
17:39:55 <heatsink> multiplicity is the maximum number of times a key appears in the tree?
17:51:05 <palomer> yeah
17:51:23 <palomer> I mean, usually that's what we mean by binary tree
17:51:32 <palomer> (binary trees with a delete function at least)
17:52:53 <Pseudonym> Of course, it depends in general on the binary tree.
17:53:01 <Pseudonym> You can make a binary tree which represents a multiset.
17:53:17 <Pseudonym> It's quite common to do this with B-trees.
17:54:10 <ibid> a binary tree is simply a tree where a node has at most two children.  however, a binary tree need not be a search tree, so talking about the number "a key" appears in a binary tree is nonsensical
17:54:35 <Pseudonym> True.
17:56:28 <ibid> (though when one primarily uses binary trees as search trees, the distinction easily gets forgotten.  i've made that mistake many times myself)
18:05:32 <z0d> can I define user-defined types interactively?
18:10:52 <Cale> z0d: nope
18:11:21 <z0d> Cale: what's the reason?
18:11:24 <Cale> z0d: The interactive environments are mostly for evaluating expressions and testing your program.
18:11:52 <z0d> I see, thanks
18:12:04 <Cale> Usually what I do is to keep the file I'm working on in one window, and ghci open in another
18:12:17 <Cale> :re  will reload the file when I make changes
18:20:27 <dons> Lemmih, pong
18:33:50 <luqui> someone the other day said "I don't think ListT should be used at all, because it doesn't map monads to monads"
18:33:55 <luqui> What does that mean?
18:42:14 <int80_h> haskell r00lz
18:46:20 <kaol> int80_h: we know that already
19:15:38 <Lemmih> dons: I'm a bit confused about the way you've implemented Data.FastPackedString.concat
19:18:34 <dons> ok. i didn't implement it though... that's from darcs. nonetheless, what's the problem?
19:21:33 <Lemmih> It starts with a 1024 buffer and then resizes as needed.
19:22:04 <dons> right
19:23:23 <dons> so its lazily doing the concat as it walks over the list
19:23:58 <dons> the alternative is to alloc (sum of ps size) somewhere, but we quickly run out of memory that way
19:24:38 <dons> i think thats the motivation for this implementation, anyway
19:24:43 <Lemmih> Why?
19:25:08 <Lemmih> It's not lazy.
19:26:50 <dons> oh, i guess memcpy isn't lazy. right. this function has better behaviour than the big-alloc function i described above (called concatLenPS in darcs)
19:28:15 <dons> what's your concern about concat?
19:28:35 <Lemmih> I just don't understand it.
19:28:44 <Lemmih> Can't grash why it should be faster.
19:28:59 <dons> clearly I don't understand it either :)
19:29:18 * Lemmih will run some benchmarks.
19:30:01 <dons> it's been on my list of functions that need rewriting, but it's weird enough that i couldn't work out if there's some magic secret in there somewhere.
19:30:34 <dons> make sure you check large packed strings. that's where this function beats concatLenPS
19:30:54 <dons> and i'm surprised that I removed concatLenPs. perhaps it should be brought back
19:31:07 <dons> do you have a copy of darcs-unstable src to look at?
19:31:39 <dons> as you'll probably want to check out concatLenPS :: Int -> [PackedString] -> PackedString
19:32:11 <dons> which is much simpler, but tended to cause out of memory errors earlier than concat.
19:33:38 * heatsink would much appreciate it if someone could look at my problems with underconstrained types... http://www.haskell.org/hawiki/HaskellIrcPastePage
19:33:55 <dons> concat is a bottleneck, so a better version is highly welcome Lemmih
19:58:24 <Lemmih> It's surprisingly efficient.
20:00:13 <dons> still, it's weird
20:02:37 <dons> how big is the data you're testing it on?
20:02:54 <dons> i think i've tested concat up to 200M
20:03:06 <dons> so maybe you need to use bigger data to see the effects
20:03:19 <dons> at the bottom of README are some stats
20:19:24 <dons> Lemmih, any other issues you've found with the FastString code?
20:20:34 <Lemmih> Nope, it's all nice.
20:22:15 <dons> ok. let me know if anything is missing or too slow.
20:30:59 <SyntaxNinja> Igloo: alive?
20:31:28 <SyntaxNinja> Igloo: was this haddock bug just waiting on new ghc? http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=316657
20:32:29 <SyntaxNinja> Igloo: I'm wondering about doing uploads for happy and haddock.
20:34:31 <dons> -package mtl hmm
20:36:20 <SyntaxNinja> <--- figured that out on his own too!
20:36:52 <dons> :)
20:50:04 <lispy_> @index logBase
20:50:05 <lambdabot> Prelude
20:50:09 <lispy_> er
20:50:13 <lispy_> @type logBase
20:50:14 <lambdabot> forall a. (Floating a) => a -> a -> a
20:50:19 <lispy_> heh
20:50:23 <lispy_> that didn't help :)
20:50:40 <lispy_> @eval logBase 2 1280
20:50:42 <lambdabot> 10.321928094887362
20:54:00 <lispy_> @eval \x -> (floor (logBase 2 x)) + 1
20:54:01 <lambdabot> <Plugins.Eval>:1:12:
20:54:01 <lambdabot>   No instance for (Show (a -> b))
20:54:01 <lambdabot>   arising from use of `show'
20:54:17 <lispy_> heh, oops
20:54:22 <lispy_> @pl \x -> (floor (logBase 2 x)) + 1
20:54:23 <lambdabot> (1 +) . floor . logBase 2
21:09:51 <TheHunter> @botsnack
21:09:53 <lambdabot> :)
21:10:09 <TheHunter> i got it.
21:11:43 <TheHunter> "but it's received a positive response from many of the users and it may become permanent". what the hell are they smoking?
21:12:25 <TheHunter> (from http://freenode.net/faq.shtml#privmsg)
21:13:35 <TheHunter> @topic-snoc  try '/msg nickserv set unfiltered on' if lamdabot doesn't respond to you
21:13:36 <lambdabot> I do not know the channel try
21:13:52 <TheHunter> @topic-snoc #haskell  try '/msg nickserv set unfiltered on' if lamdabot doesn't respond to you
21:13:53 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050906","see also #haskell.se #darcs","try '/msg nickserv set unfiltered on' if lamdabot doesn't respond to you"]' by lambdabot
22:02:06 <ozone> Pseudonym: off-topic question: do you know of a decent C/C++ cross-platform networking library?
22:02:31 <ozone> just something so i don't have to deal with BSD sockets silliness all day long
23:52:43 <ulfdoz> re
