00:01:16 <vikasg> is excessive use of IORef bad style?
00:01:39 <Pseudonym> G'day.
00:01:58 <mflux> vikasg, excessive use = everything needs to be in the IO monad?
00:02:01 <mflux> in that case I'd say, yeah ;)
00:02:31 <vikasg> mflux, yes, something like that
00:03:06 <mflux> I can imagine that can become inconvenient after a while
00:03:20 <vikasg> the problem is I need to implement mutable pairs (as in Scheme) and that spills the IO monad into everything: primitives, eval, etc.
00:05:25 <mflux> so STRef isn't enough?
00:05:48 * vikasg looks for STRef
00:07:16 <vikasg> mflux, thanks, that's exactly what I need
00:07:33 <vikasg> my code is using StateT anyway :)
00:17:36 <ChronoWiz> say i define the function:
00:17:46 <ChronoWiz> eg :: Int -> [Int]
00:17:54 <ChronoWiz> eg n    | n > 0 = n : eg (n-1)
00:18:00 <ChronoWiz> | True = []
00:18:29 <ChronoWiz> isn't each recursive call of eg returning an Int and not a list of Ints? that makes the definition wrong then?
00:19:08 <vikasg> ChronoWiz, each call is returning a list, since (:) will cons an item to a list
00:19:32 <ChronoWiz> oh right, duh
00:19:36 <vikasg> @type (:)
00:19:38 <lambdabot> forall a. a -> [a] -> [a]
00:19:38 <ChronoWiz> got all worked up about nothing
00:19:55 <vikasg> it happens :)
00:20:09 <ChronoWiz> been drinking too much lately i think
00:21:02 <vikasg> "Don't drink and derive" (type signatures)
00:21:42 <ChronoWiz> lol
00:26:30 <shapr> boegel: Good morning boegel!
00:26:58 * rt converts a bunch of astrophotographs and gets ready to put them in his gallery.
00:42:26 <boegel> shapr: y0
00:45:12 <Itkovian> hi shapr.
00:54:05 * shapr yawns
00:55:22 * boegel yawns in chorus with shapr
00:58:39 <shapr> hoi Itkovian
01:10:48 <shapr> Why do they call them actions figures when they don't actually move?
01:11:02 <boegel> shapr: who call what action figures ?
01:11:21 <ChronoWiz> lol haskell action figures
01:11:30 <shapr> Little plastic figures that kids play with are called "actions figures" in American.
01:12:28 <ChronoWiz> maybe they should call them functional figures?
01:12:48 <dons> hmm. variable figures?
01:13:02 <ChronoWiz> lol
01:13:03 <dons> mutable figures, might be clearer
01:14:43 * shapr snickers
01:21:00 <boegel> how about just figures :)
01:21:40 * boegel thinks xerox is enjoying a long night's sleep after all the hacking he did the last few weeks
01:33:04 <poetix> gtk2hs r0xx0rs!
01:33:28 <ulfdoz> re
01:34:53 <boegel> poetix: ? :)
01:35:15 <poetix> I got the 0.9.9.5 release to build last night
01:35:28 <poetix> And this morning I went to have a little play with some demo code
01:36:00 <poetix> It's so /easy/
01:36:14 * xerox screams "indeeeeeed!"
01:36:18 <xerox> 'morning ^_^
01:37:02 <poetix> Well, my investigations continue
01:37:11 <poetix> But I was very pleased with how readable the demo code was
01:37:40 <xerox> Me too.  I never managed to do GUI programming before using Gtk2Hs and Glade.
01:37:55 <poetix> If you've used something like wxPython before, the concepts will be familiar
01:38:03 <xerox> boegel: thanks for the link, I'm skimming it, sounds interesting!
01:38:33 <poetix> And the Haskell code is really very clean
01:38:39 <boegel> xerox: many great examples in it
01:39:04 <boegel> poetix: yeah, it is :) I noticed that too
01:39:13 * xerox is happy
01:40:14 <poetix> xerox: This is the honeymoon period. Later on, when they run into some icky corner cases, everyone will start yelling at you ;)
01:40:22 <xerox> boegel: I need to introduce randomness in LSystem, I think.
01:40:44 <xerox> poetix: I'll be hiding well then! :-)
01:40:56 <boegel> xerox: yeah, that would be cool
01:41:03 <poetix> Have the Google people seen this release?
01:41:20 <boegel> xerox: there exists something like probablistic L-Systems
01:41:24 <xerox> poetix: Hmm.. I think so.
01:42:10 <xerox> boegel: How complex would be to enable ('A',"foo","bar") and let the system decide randomly between foo and bar results?
01:42:39 <boegel> xerox: well, that's where the probability stuff comes in, you can add a probabilty to a rule
01:42:59 <boegel> as in ('A', (0.3,"foo"), (0.7,"bar") )
01:43:01 <xerox> Oh-uhm. Good idea.
01:43:24 <boegel> I didn't event this, someone else did :) it's probably mentioned in the book too
01:44:05 <xerox> I could clean up the code and make a darcs repo so we can hack these fatures in the renderer :-)
01:47:46 <boegel> xerox: nice :)
01:48:11 <poetix> OK, running before I can walk...
01:48:31 <poetix> If I wanted to fork a worker thread to do some background work while keeping the UI responsive, how would I do it>
01:49:09 <poetix> And how would I return a value from that thread safely to the main window thread?
01:50:11 <xerox> There is a good tutorial written by Duncan about this I think.
01:51:28 <xerox> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
01:52:09 <poetix> Cool, I go there
01:56:23 <poetix> Hmm, interesting
01:57:54 <poetix> In dotnetland, if you want to make a callback from a worker thread to the main window thread, you have to explicitly marshall the callback to the main window thread by placing a delegate in the main window's event loop
01:58:28 <boegel> dotnetland sucks! :)
01:58:58 <poetix> True
02:00:01 <xerox> sucks :: String -> Bool
02:00:12 <poetix> I'm just thinking about how you deal with a non-thread-safe GUI
02:01:07 <Itkovian> anybody cocoafied gobby?
02:03:58 <xerox> Itkovian: beelsebob talked about it, but I don't know if he succeeded.
02:07:54 <dons> if it takes a long time to compile, the code must be good, right?
02:08:41 <boegel> can anyone tell me what gobby is ? I know who Dobby is, but I've never heard of gobby...
02:10:47 <Itkovian> dons: the code will be superb
02:11:03 <earthy> gobby is a collaborative text editor, boegel
02:11:48 <boegel> collaborative ? as in with several people on the same text ?
02:14:11 <earthy> yup
02:15:03 <boegel> nice
02:17:07 <Itkovian> boegel: as in subEthaEdit :-)
02:18:03 * boegel doesn't k now subEthaEdit
02:18:16 <Beelsebob> you don't have to "know" it
02:18:34 <Beelsebob> this seems to be a misconception of vi and emacs users, that editors have to be learned
02:18:41 <earthy> um
02:18:45 <earthy> no
02:18:49 <earthy> editors *do* have to be learned
02:19:19 <earthy> it's just that the simplest things are the same over almost all editors
02:19:25 <earthy> such as moving using arrow-keys
02:19:28 <humasect> knowing != learning
02:19:38 <earthy> and the function of delete and backspace
02:19:40 <sieni> ?
02:19:52 <earthy> however, I can vividly remember my little sister when she first learned to use an editor
02:19:56 <Beelsebob> earthy: actually, those are functions of the operating system's UI
02:20:01 <earthy> 'now the letters are gone!'
02:20:01 <sieni> moving is of course done with h, j, k and l in all true editors
02:20:07 <Beelsebob> they're just put together in a new way
02:20:14 <earthy> beelsebob: no, they are not.
02:20:31 <Beelsebob> earthy: how come they're provided by the OS's UI APIs then?
02:20:45 <earthy> they may be, and in many current systems there is a text filed that provides simple editing functionality
02:20:51 <xerox> boegel: realtime collaborative editing is _really_nice_ !
02:21:01 <Beelsebob> indeed it is
02:21:08 <earthy> but a. not all editors use that and b. not all operating systems provide that
02:21:35 <Beelsebob> earthy: that's what I mean... an editor shouldn't have to be learned because it *should* use that
02:21:42 <Beelsebob> it shouldn't reinvent the wheel
02:22:05 <earthy> sorry, but I'm glad with many editors that don't use that
02:22:30 <sieni> well, most editors that try to be "simple to learn" also "suck big time", because they are not configurable in any meaningful sense
02:22:34 <earthy> as they allow me to e.g. choose from possible completions in a popup
02:22:49 <earthy> or provide *much* more powerful editing functionality
02:23:05 <Beelsebob> sieni: yeh... SEE doesn't
02:23:16 <xerox> Talking of it, gobby doesn't really have any feature other than editing text - i.e. no search/replace, etc..
02:23:21 <earthy> plus, when I learned to use vi, the very few text editing widgets that were available sucked *bigtime*
02:23:35 <Beelsebob> earthy: Ahh, I guess I'm just treated... completions in a pop up is a behavior of OS X's text views
02:23:40 <Beelsebob> ... in all apps
02:23:51 <earthy> is it?
02:23:54 <Beelsebob> yeh
02:24:03 <earthy> so TextEdit should have those?
02:24:05 <humasect> (haskell-mode)
02:24:15 <Beelsebob> earthy, yep, press alt-F7
02:24:24 <Beelsebob> I think... *checks*
02:24:39 <Beelsebob> no... alt-esc
02:25:03 <earthy> whoa
02:25:19 <Beelsebob> hehe
02:25:23 <earthy> but, that's me just learning a part of a text editor.
02:25:45 <earthy> which gets me back to the basic point: all usage of text editors is learned. :)
02:25:48 <Beelsebob> well, no, learning the cocoa UI
02:26:09 <humasect> luqui: http://haskell.org/hawiki/UsingRecords  =)
02:26:22 <earthy> well, learning to use the text editing widget in the cocoa UI
02:26:46 <earthy> but... whoa. *cool*! :)
02:26:52 * earthy loves Mac OS X even more now ;)
02:27:02 <Beelsebob> hehe... it's things like that that make it cool
02:27:38 <Beelsebob> okay, fair enough... my point was not really that no learning is required... my point was that the UI should *not* be so different from the OS that you have to read a book just to find out how to get out of the damn thing
02:27:47 <humasect> what is SEE? it's one of those anti-google words.
02:28:06 <Beelsebob> SubEthaEdit
02:28:11 <Beelsebob> codingmonkeys.de
02:28:28 <humasect> ahh
02:29:21 * xerox thinks we do need a gobby OS X package.  It's the only practical solution to cross-OS collaborative editing.
02:29:38 <Beelsebob> xerox: yeh, I was wondering how portable the code was
02:29:51 <Beelsebob> as in... could I rip out the gtk stuff and put in cocoa stuff instead
02:31:30 <xerox> Uptime record: 4 days, 01:40:45 | Linux 2.6.12-6-386       Sat Aug 27 21:20:16 2005, these last days of development, hehe (it's my laptop)
02:32:26 <Beelsebob> heh, *checks his*
02:32:56 <Beelsebob>  10:28:03 up 35 days, 18:58
02:34:34 * boegel knows he made Itkovian lose his ~120 day uptime :D
02:34:40 <ulfdoz> 2.6.12 is released?
02:34:42 <Beelsebob> haha
02:34:49 <Beelsebob> 2.6.13 is
02:35:08 <Beelsebob> boegel: how'd you do that?
02:35:26 <ulfdoz> It can only become better. So for the moment living on the edge. 2.6.11 isn't what I call stable.
02:35:59 <Beelsebob> heh
02:36:46 <Beelsebob> 2.6.13 allows you to swap the kernel without rebooting... I wonder if it spawns new tasks, or if it migrates them though... having an uptime longer than the time your kernel's been out would rock
02:37:15 <humasect> is "." the reverse of "$"?
02:37:18 <boegel> Beelsebob: I asked him to burn a dvd, and apparently his system didn't like that
02:37:22 <ulfdoz> Rebooting doesn't hurt, normally. Uptime is only a number.
02:37:35 <Beelsebob> hehe... yeh, but it's fun
02:37:42 <Beelsebob> boegel: :o
02:37:54 <boegel> yeah, it is
02:38:10 <boegel> my system only has 2 days of uptime now, due to workstation problems :(
02:38:28 <Beelsebob> hehe... my server pwns you all though
02:38:29 <Beelsebob>  10:39am  up 148 day(s), 21:36
02:38:41 <Beelsebob> :P
02:39:14 <ndm> my system is turned off right now, to save power
02:39:21 <ndm> which is good for the environment!
02:39:36 <Beelsebob> macs save more power in sleep mode than shutting down and rebooting
02:39:56 <boegel> Beelsebob: I think all computers do?
02:39:58 <Beelsebob> the power needed to boot is equivalent to sleeping the machine for a week
02:40:15 <Beelsebob> boegel: probably... but I don't trust any other OS's sleep to actually wake up
02:40:16 <ndm> not my machine, its so old it can't sleep
02:40:46 <ulfdoz> Mine isn't really old, but is not to get into sleep. So 200W minimum power.
02:40:55 <boegel> ndm: are you still using Win95 or something ? :
02:41:45 <ndm> XP, but it requires hardware support, and my machine originally had 98 on it, so too old to support the things
02:42:08 * boegel can't get his laptop to hibernate using Fedora Core 4 :(
02:42:18 * xerox is having a cup of tea and missing dcoutts.
02:42:36 <Beelsebob> tea... good idea
02:43:34 <xerox> It was an habit to have a cup of tea and code with Duncan in the morning.. and the afternoon, oh yes... and the night <grin>
02:43:41 <ulfdoz> btw. is there some reference literature for design patterns in functional programming? Something like Gamma et al. for OOP did.
02:43:48 <Beelsebob> haha
02:44:00 <dons> ulfdoz, we're anti-design patterns ;)
02:44:02 <boegel> omg :) design patters in Haskell ? :)
02:44:31 <poetix> http://www.theonion.com/content/node/40076 <- Google Plans To Destroy All Information It Can't Index
02:44:45 <dons> Matthias Felleisen sez: "... pattern-oriented style is detrimental to the programming process."
02:44:58 <poetix> Does he say why?
02:45:03 * Itkovian notices the ad 'new freedom for student body" on that page
02:45:23 <ulfdoz> Hey, for OOP I made some good experiences with patterns.
02:45:24 <dons> poetix, patterns arise because the language isn't expressive enough.
02:45:32 <dons> once you've got a decent language, no need for stupid patterns
02:45:40 <sieni> patterns?
02:45:50 <dons> http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz
02:45:51 <poetix> Sure, but then it's "stupid languages considered harmful" rather than "stupid patterns..."
02:46:14 <Itkovian> poetix: you do know that the onion is a sarcastic site, yes? well, afaik it is.
02:46:27 <poetix> Of course. It's my favourite source of weekly sarcasm.
02:46:27 <Itkovian> "As a part of Phase One operations, Google executives will permanently erase the hard drive of any computer that is not already indexed by the Google Desktop Search."
02:46:30 <Itkovian> lol
02:46:33 <boegel> google work domination, w00 !
02:46:41 <xerox> Haskell is about abstractions, and they are on some way, patterns.
02:46:48 <poetix> Patterns done right
02:47:31 <humasect> is "." the reverse of "$"?
02:47:53 <poetix> "This fall, we'll unveil Google Sound, which will record and index all the noise on Earth. Is your baby sleeping soundly? Does your high-school sweetheart still talk about you? Google will have the answers."
02:47:58 <xerox> humasect: I think not.
02:48:06 <humasect> ok.
02:48:10 <ChronoWiz> . joins two functions together
02:48:28 <humasect> joins?
02:48:32 <ChronoWiz> pipes the output of one directly into the input of the other..
02:48:38 <boegel> ChronoWiz: composes :)
02:48:43 <ChronoWiz> ah right
02:48:43 <ChronoWiz> yep
02:48:45 <poetix> (g . f) x == g(f(x))
02:48:45 <humasect> non-monadic >>=?
02:48:53 <ulfdoz> often patterns are a nice way to avoid misstructuring a program, which could made problems in further development process or extending/changing the program.
02:49:17 <xerox> poetix: err!
02:49:39 <xerox> humasect: in a sense, yes.
02:49:49 <poetix> xerox: no? Go on, make me look stupid...
02:50:07 <humasect> kk
02:50:32 <humasect> or more like <<=
02:51:05 <xerox> poetix: it was a comment about the Google Purge article, bad timing from my side.
02:51:19 <Beelsebob> oddly, g $ f x and g . f x are the same
02:51:24 <xerox> humasect: (=<<)
02:51:31 <Beelsebob> but that's just because the bracketing just works out that way
02:51:33 <poetix> Oh, right. I was worried. If you can't get the meaning of (.) right, you're in trouble...
02:51:35 <humasect> xerox: k thx ^^
02:51:36 <xerox> Beelsebob: I think not.
02:51:56 <xerox> @type \f g x -> g $ f x
02:51:58 <lambdabot> forall a b t. (t -> a) -> (a -> b) -> t -> b
02:52:00 <xerox> @type \f g x -> g . f x
02:52:02 <lambdabot> forall b c a t. (t -> a -> b) -> (b -> c) -> t -> a -> c
02:52:14 <Beelsebob> duh
02:52:17 <Beelsebob> wrong way round
02:54:00 <xerox> Beelsebob: what do you mean?
02:54:08 <Itkovian> xerox: I've installed gobby on my Linux desktop machine, care to try a session?
02:54:20 <Beelsebob> no, I'm just being dumb... I'm just trying to figure out why they're different
02:54:29 <Beelsebob> f $ g x = f (g x)
02:54:32 <xerox> Itkovian: could you wait some minutes?
02:54:36 <Itkovian> xerox: sure
02:54:48 <Beelsebob> f . g x = (f . g) x = f (g x)
02:54:58 <Itkovian> xerox:  I'm off for lunch in a little while though ... but ping me eh
02:55:01 <Beelsebob> no... function app binds tighter
02:55:04 <Beelsebob> stupid bob
02:58:55 <xerox> Back!
02:59:42 <xerox> f . g x = f . (g x) = f $ (g x) y = f (g x y)
02:59:50 <xerox> Itkovian: ping!
02:59:52 <Beelsebob> indeed
02:59:56 <Beelsebob> fa binds tighter
03:00:14 <Beelsebob> and bob is dumb :)
03:00:29 <Itkovian> xerox: pong
03:01:03 * xerox spawns gobby
03:01:24 <Itkovian> xerox: sorry but we're off to lunch
03:01:30 <Itkovian> I'll get back to you afterward
03:01:34 <xerox> OK :-)
03:02:08 <poetix> Gobby is written in C?
03:02:14 <xerox> C++
03:02:23 <poetix> And uses GTK+?
03:02:28 <xerox> Yep.
03:02:35 * poetix has a Thought
03:03:01 <xerox> What exactly?
03:03:15 <poetix> Two thoughts (and counting...)
03:03:28 * xerox throws continuations to poetix
03:03:32 <poetix> i) Translate Gobby using gtk2hs
03:03:37 <Beelsebob> OI!
03:03:42 <Beelsebob> I wanted the continuations
03:03:43 <poetix> ii) Write separate Gobby-compatible client using gtk2hs
03:04:05 <Beelsebob> iii) integrate gobby protocol into yi
03:04:05 <poetix> client / session host
03:04:06 * xerox foresees "gtk2hs" in the next bullet point item
03:04:26 <xerox> poetix: we do need a collaborative library I think.
03:04:34 <poetix> I like idea iii) the best
03:04:53 <poetix> A lib wrapping the gobby protocol would be a good start
03:05:04 <xerox> They made libobby.
03:05:24 * xerox is off to lunch too.
03:05:34 * Beelsebob is off to lunch 3
03:05:44 * poetix is out to lunch
03:07:26 <humasect> Lemmih: here?
03:18:34 <Lemmih> Yes.
03:20:44 <humasect> ok. i'm not sure if Mixer packages should be consistent with Core, but they need to be included each seperately, where Graphics.UI.SDL.Mixer isn't allowed as an import by itself. excuse my ignorance if i do another thing wrong ^_^
03:21:42 <Lemmih> I don't follow...
03:22:00 <humasect> sorry, ok
03:22:12 <humasect> import Graphics.UI.SDL.Mixer isn't found
03:22:26 <humasect> but each of them (General, Types, Samples, etc) can be
03:22:35 <humasect> and must be included directly so far.
03:23:04 <humasect> (so in my code, i would have MixSamples.loadWAV :: FileName -> IO MixTypes.Chunk
03:23:56 <humasect> oh, i know why. there is no similar file as SDLstable/src/Core/SDL.hs =)
03:24:43 <humasect> *Graphics/SDL.hs
03:26:45 <Lemmih> You can import all of them under the same name.
03:27:02 <humasect> ok, great
03:33:20 <Lemmih> humasect: I've added the module in SDLhead.
03:34:20 <humasect> cool
03:37:28 * poetix skims the libobby source
03:37:58 <poetix> Is it hard to do Haskell FFI to C++?
03:40:40 <aleator> poetix: In my experience it depends much on c++ style. Though I'm not familiar with things like hacanon..
03:41:11 <poetix> libobby is pretty OOP
03:41:20 <poetix> Quite nice code, actually - clean STL-based style
03:41:51 <poetix> (STL used internally, not as part of the API)
03:41:54 <aleator> Does it do lot of templates?
03:42:21 <poetix> Not so much in the API, I think.
03:43:56 <Itkovian> xerox: ping
03:44:08 <aleator> What I've dabbled with ffi I would think it is just tedious, but not difficult..
03:44:43 <aleator> What is difficult is modelling the api in haskellish way.
03:45:19 <poetix> I'm wondering whether it would be better to wrap libobby, or to write a pure Haskell implementation of the protocol
03:47:43 <poetix> libobby itself builds on a library called net6
03:48:34 <aleator> Is the api visible somewhere?
03:48:50 <poetix> I was looking for it, but couldn't find API docs
03:50:29 <poetix> Is there any documentation anywhere on doing FFI to C++ libraries?
03:51:49 <aleator> I would start looking at http://www.haskell.org/hawiki/Hacanon
03:52:25 <aleator> Otherwise doing FFI to C++ is first doing C api over the c++ one and then using normal ffi procedures (c2hs is excellent)
03:56:31 <poetix> So I'd have to write a C++ wrapper for the C++ using extern "C", then a C wrapper for the C++ wrapper...?
03:59:05 <aleator> unless you can use some wrapper generator.
03:59:26 <Lor> A c<->c++ wrapper using extern "C", and a haskell<->c wrapper using the ffi or whatnot.
03:59:39 <aleator> poetix: Though I think you can skip first step
04:00:07 <poetix> Right. So c2hs could pick up the extern "C" functions in the c<->c++ wrapper
04:00:27 <poetix> aleator: How? By using Hacanon?
04:00:35 <Lor> If a language is supposed to be usable from multiple languages, you pretty much need a C api for it.
04:01:07 <earthy> or pascal
04:01:19 <tuomov> assembler!
04:01:22 <tuomov> wait... that's C
04:01:24 <earthy> (but that's really C-in-disguise)
04:01:35 <boegel> binary code !
04:01:41 <poetix> COM!
04:01:46 * poetix blushes
04:02:03 <tuomov> corba!
04:02:10 * tuomov throws out
04:02:18 <poetix> I didn't just say that. Really I didn't...
04:02:19 <tuomov> s/out/up/
04:02:24 <aleator> poetix: you can link ffi with c++ with externs.
04:03:08 <aleator> In general C++ just seems to throw crosslanguage operability out the window..
04:03:45 <poetix> I think I'm getting there. What I need to do is write some c++ exposing a C API vai externs, and have that c++ cast object references to void*
04:04:27 <poetix> So we can turn the object.method(string foo) syntax inside out, and have C functions like class_method(void* objectPtr, string foo)
04:05:05 <xerox> Is it worth the effort compared to an Haskell implementation?
04:05:07 <poetix> Which then cast objectPtr* back into class*, and do classPtr->method(foo)
04:05:14 * xerox just got his new glasses, yay!
04:05:20 <Itkovian> yeah
04:05:26 * Itkovian rejoices
04:05:32 <poetix> It's the sort of thing you really want to automate, for sure.
04:05:43 <aleator> Yes. I found it rather good idea to modify the api at that point to be more haskell like.
04:05:45 <xerox> Itkovian: my ip, standard port!
04:06:24 <poetix> aleator: In which case you *don't* want to automate it, but to be discerning about how you map between the two apis.
04:07:01 <poetix> Basically, libobby already exists. And it uses net6, which already exists. And gobby, and maybe other things as well, are based on it.
04:07:36 <xerox> I didn't mean an incompatible Haskell implementation.
04:07:39 <poetix> So writing an FFI->C Api->libobby C++ api wrapper is probably less work, and has a better chance of being (and remaining) compatible
04:08:24 <poetix> I'm arguing against my own natural tendency to want to re-implement everything from the ground up
04:08:36 <poetix> Just to see if I can persuade myself this time
04:09:04 <aleator> Wrapping is work as well... As is modelling the apis.
04:09:40 <poetix> A fresh implementation would *also* have to model the apis
04:09:43 <xerox> Itkovian: are you experiencing some problem?
04:10:11 <poetix> But a fresh implementation might be able to model the apis in a more idiomatically Haskellish way
04:10:12 <Itkovian> xerox: sorry, just saw yr message
04:10:38 <aleator> poetix: All too true.
04:10:41 * xerox agrees
04:10:59 <Itkovian> xerox: connection refused
04:11:04 <xerox> poetix: how big is libobby + libnet6?
04:11:15 <poetix> The libobby code is not huge
04:11:19 <xerox> Itkovian: mumble, could you try starting the session?
04:11:39 <poetix> I don't know about libnet6
04:11:59 <Itkovian> xerox: hmm, I don't know if our firewall will let you pass, let's see.
04:12:12 <xerox> Itkovian: I'm NAT-ted too :|
04:12:50 <humasect> i think i've been at this a bit too long. i thought i could un-monadize something. (IO Int -> Int)
04:13:09 <aleator> poetix: Though I think that wrapping existing api can be educating experience.
04:13:24 <poetix> That's my other thought
04:13:38 <poetix> It's one way I haven't got my hands dirty yet
04:14:56 <xerox> c2hs is a pretty nice tool, too
04:15:11 <poetix> Yeah, I noticed you used it pretty extensively...
04:15:13 <aleator> You encounter lot of fun c idioms. Such as making one struct for all images (floating point, multichannel etc.). And then failing to document which functions return which kind..
04:15:28 * aleator curses in general direction of opencv
04:16:17 <poetix> I think I'm going to do a practice run with some plain old C, and c2hs
04:16:31 <poetix> And see how I go from there
04:18:20 <xerox> poetix: check the examples in the c2hs distribution, they're pretty clear
04:18:38 <poetix> Will do
04:18:53 <poetix> Later, folks
04:28:16 <shapr> yargh
04:29:08 <xerox> Morning shapr, were you yarghing?
04:33:44 <shapr> why yes, I was.
04:37:52 <boegel> shapr: and why ?
04:40:04 <Stinger> xerox what was the name of that other tutorial you recommended?
04:40:44 <xerox> Stinger: Howdy!  I think it is "Yet Another Haskell Tutorial".
04:41:16 <Stinger> ah thanks
04:41:18 <boegel> yo Stinger, welcome to #haskell
04:42:15 <Stinger> ello
04:42:32 <xerox> Stinger: glad to see you here!
04:42:58 <xerox> Stinger: if you have any question about Haskell or the tutorial itself feel free to ask here.
04:43:40 <Stinger> ok, thanks
04:46:43 <boegel> Stinger: and maybe you should ask shapr for the famous Haskell tour, he's really good at it !
04:47:12 <Stinger> probably not right now :)
04:47:25 <Stinger> I been up for 30 odd hours now
04:47:31 <xerox> Oh right!
04:47:35 <xerox> @wiki HaskellDemo
04:47:36 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
04:47:43 <xerox> Take a look at this, it's worth it.
04:48:52 <boegel> Stinger: then why don't you go to bed ?
04:49:04 <Stinger> I don't know :(
04:49:23 <Stinger> probably will in a little while heh
04:53:47 <shapr> Stinger: Come back when you have sleep, then I can give you the tour!
04:54:07 <shapr> Alpacasaurus: Is that you Mistah Plantagenet?
04:55:00 <Alpacasaurus> shapr: Is "Mistah" is ebonics or something ?
04:55:32 <Alpacasaurus> oops see now you have me speaking bad English too
04:55:41 <Alpacasaurus> shapr: Is "Mistah" ebonics or something, rather ?
04:55:48 <Alpacasaurus> It's contagious
05:02:00 <xerox> Itkovian: ping
05:09:51 <Itkovian> any Parsec experts around?
05:10:14 <Itkovian> how do I automagically transform P1; P2; P3 into P1; sepTokens; P2; sepTokens; P3 ?
05:18:51 <boegel> http://suicidegirls.com/news/culture/11332 -> omg :s
05:20:15 <sylvan> this is the coolest thing ever (OT): www.pandora.com
05:20:49 <goron> Does an implementation of Dijkstra's algorithm exist in Haskell already?
05:21:04 <sylvan> I think the inductive graph lib has one
05:21:25 <Itkovian> sylvan: cool
05:21:52 <sylvan> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data.Graph.Inductive.Query.SP.html
05:22:04 <goron> sylvan: yep, I already found.
05:22:08 <goron> it
05:22:56 <goron> sylvan: Does Dijkstra work on all graphs (directed/undirected/cycles)?
05:23:18 <sylvan> goron, I'm not sure, haven't really used it all that much
05:23:34 <sylvan> look up the paper in which the implementation is described
05:23:34 <goron> I thought it didn't work for graphs with negative cycles.
05:24:08 <goron> I don't see a link to the paper.
05:25:34 <goron> got it
05:27:04 <goron>   qW§Iq©¢ã qn3YeÀ)Ye¤x¦"qe}xp"W¦x¦¦½¢u)WWqs±I"I)"â
05:27:07 <goron>  ç àd ç þ Þd ãç g ç          i Þ g ßf à d  æ  é Þ à d j g çâ ç à d d  à d ßf ç ê g ç  ç ñf ã gf  å ç à ì ó ßâ ç þ 
05:27:11 <goron>  § j ã ç ç f df ß Þ æ à df i ß à æ   j gf ß à d  æ d ß ç d  Þ à ß j gf d á æ å Þ ê  Þ å à df  Þ jâ 
05:27:14 <goron>  )¢7z$sezËüswxq)zü"ïxx7ee)qeÓq¢qe)¦zlé xeez)"¤Àß   ¢& »                                      dß f  EB
05:27:29 <goron> Hmm, copy paste protection?
05:27:31 <earthy> CARRIER LOST
05:29:10 <goron> earthy: You should know this: does Dijkstra work on all graphs(directed/undirected/with cycle) except for graphs containing negative cycles?
05:32:57 <wilx`> Hmm, I think it works only on graphs with positive lenght of edges.
05:33:25 <wilx`> Because of the relaxation part.
05:33:30 <earthy> I think it breaks on graphs with cycles, yes
05:33:35 <pejo> goron, http://www.nist.gov/dads/HTML/dijkstraalgo.html
05:33:59 <earthy> but it will be robust as long as the cycles do not have a total negative path length
05:34:17 <earthy> so, yes, it should work on all graphs
05:34:30 <earthy> but for those that have a cycle for which the total pathlength is negative
05:34:53 <goron> pejo: I already saw that website, but thanks for the help.
05:35:28 <earthy> hm. point
05:35:41 <earthy> no edge can indeed have negative weight in default dijkstra's
05:36:54 <goron> But Bellman(or something like that)-Ford can, I thought.
05:37:24 <earthy> yes
05:37:48 <earthy> but it can't deal with negative cycles
05:37:55 <earthy> http://en.wikipedia.org/wiki/Bellman-Ford_algorithm
05:37:57 <goron> earthy: Thank you
05:40:12 <humasect> @type (>>)
05:40:41 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
05:43:14 <lisppaste2> You may have noticed that lisppaste has been reconnecting a lot lately. I've been trying to come up with a temporary solution to keep lisppaste connected while freenode experiences some instability. I have set them to reconnect every four hours now; this should be a little less noisy in busy channels.
05:53:05 <ikegami--> Hello all from over Europe
05:53:26 <ikegami--> I'm now in airplane and use "Flynet service" of Lufthansa airline
05:54:03 <tromp> gratz on your high altitude contribution to #haskell:)
05:54:18 <dons> @karma+ ikegami--
05:54:18 <lambdabot> ikegami--'s karma raised to 1.
05:54:40 <Itkovian> ikegami--: how much do they charge these days?
05:54:41 <tromp> i'm 6m below sealevel here in amsterdam
05:54:54 * dons experiments with 1G packed strings in haskell
05:54:58 <Itkovian> @karma+ ikegami--
05:54:58 <lambdabot> ikegami--'s karma raised to 2.
05:55:15 <ikegami--> it's little expensive
05:55:29 <boegel> ikegami--: cool
05:55:30 <ikegami--> (not little, I think against
05:55:38 <boegel> bye :D
05:55:47 <boegel> out of money probably
05:55:58 <Itkovian> or plane crash
05:56:15 <dons> ah, not a plane crash
05:56:15 <Itkovian> still flying high eh
05:56:21 <ikegami--> oops
05:56:45 <ikegami--> for 11 hours flight, it costs about 30$
05:56:52 <tromp> not too bad
05:56:52 <xerox> :-D
05:56:56 <xerox> Whoa!
05:56:59 <dons> not so bad.
05:57:08 <tromp> i'm sure using the inflight phone for 11 hours costs a small fortune
05:57:26 <ikegami--> (but my laptop PC will work only 2 hours without outlet
05:57:45 <Itkovian> ouch
05:58:08 <tromp> ah, they wouldn't let you carry fuel cells on board:-?
05:58:12 <tuomov> a battery big enough to power a laptop for 11 hours would probably be caught by some terrorist detector
05:58:50 <boegel> ikegami--: so you're willing to pay $30 for just chatting with us for two hours ? neat :D
06:00:35 <ikegami--> boegel: exactly :)
06:00:50 <tromp> he, karma doesn't come cheap u know...
06:01:04 <ikegami--> Aha, its first time to use the Flynet, and I want to test it
06:01:21 <boegel> @karma+ ikegami--
06:01:22 <lambdabot> ikegami--'s karma raised to 3.
06:01:32 <boegel> @karma boegel
06:01:33 <lambdabot> You have a karma of -1
06:01:34 <ikegami--> (to use Internet at next flight
06:01:36 <boegel> yaay :p
06:02:13 <tromp> you got a window seat?
06:02:41 <vegai> you got a camera? :)
06:02:53 <dons> hmm. == on two 1G packed strings is a good way to make your laptop less responsive
06:02:54 <boegel> you got a webcam ? :D
06:03:12 <ikegami--> yes
06:03:20 <tromp> not if they're random, dons;0
06:03:26 <ikegami--> but unfortunately I'm at aisel seat
06:04:03 <tromp> that's nice if you've got long legs...
06:04:35 <tromp> is the person next to you wondering what the heck you're doing online?
06:06:00 <tromp> can you play flight simulator on your laptop:-?
06:07:46 * boegel thinks ikegami-- should show us live pics of him surfing on a plane (heh :) )
06:08:59 <boegel> it'll probably look something like this: http://hem.bredband.net/gamaco/bilder/014.jpg :p
06:09:17 <ikegami--> hehe
06:10:09 <Itkovian> ikegami--: send us the stewardess pics ;-)
06:10:20 <ikegami--> goodidea
06:14:45 <ikegami--> but network is so narrow...
06:15:03 <ikegami--> (enough to chat, but...
06:16:19 <poetix> I used to feel elated when I read the Daily Python digest - so much cool stuff! Python is really cool! Soon everyone will use Python, and everything will be cool!
06:16:25 <poetix> Now I feel depressed.
06:16:55 <greenrd> Why?
06:17:05 <poetix> Silly articles about "freedom" versus "safety" languages
06:17:09 <poetix> Silly arguments about XML
06:17:18 <greenrd> heh
06:17:33 <Itkovian> boegel: any gobby luck?
06:17:40 <Itkovian> xerox: a name for the parser?
06:18:49 <dons> poetix, freedom versus safety. how weird.
06:18:50 <xerox> Itkovian: Liparse
06:18:59 <poetix> The brightest Python people are basically trying to hack Python into being a different language
06:19:01 <xerox> Li{ndemann}parse{r} :-P
06:19:26 <poetix> If they were doing Haskell, they could be writing combinator libraries...
06:19:40 <greenrd> You should tell them that.
06:19:48 <greenrd> Prompt a brain-drain from Python-land ;)
06:19:55 <poetix> Maybe I should try to convert Philip Elby
06:19:56 <Itkovian> xerox: except it's not really an LSystem parser eh
06:20:01 <boegel> Itkovian: nah :( problems with libsigc++
06:20:09 <xerox> Itkovian: err right..
06:20:22 <xerox> boegel: I nearly succeed in the static build
06:20:38 <boegel> xerox: oh cool
06:21:07 <autrijus> poetix: maybe that's because python can't easly be made into a different language?
06:21:30 <autrijus> in the metaprogramming and DSL sense.
06:22:05 <xerox> Do you know what's the library to link for those:
06:22:09 <xerox> http://rafb.net/paste/results/EWd4Jt24.html
06:22:19 <xerox> -lstdc++ doesn't do it
06:22:36 <Itkovian> erm ... xerox that should be included bij gcc
06:22:38 <Itkovian> afaik
06:22:44 <xerox> mumble.
06:24:14 <xerox> No idea :-(
06:24:17 <poetix> autrijus: I used to think Python's metaprogramming features were all that...
06:25:11 <poetix> But actually they encourage gnarly hacks, particularly if you want to start combining different metaprogramming techniques
06:25:58 <poetix> Metaclasses are fine for isolated magic tricks, but not so good for the principled addition of new semantics to the language
06:26:43 <poetix> Maybe a bunch of us should go an post taunting Haskell examples on PJE's blog
06:26:57 <poetix> We could do an intervention!
06:29:16 <Itkovian> xerox, boegel I could try to make a static build
06:29:39 <xerox> Itkovian: i did rm gobby and:
06:30:13 <xerox> http://rafb.net/paste/results/yTx1qm65.html
06:31:15 <humasect> @source (>>=)
06:31:16 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
06:31:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:31:27 <humasect> =(
06:31:54 <xerox> @index (>>=)
06:31:55 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
06:31:55 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
06:31:55 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:32:00 <xerox> @libsrc Control.Monad
06:32:01 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
06:32:19 <humasect> woo thanks again xEROx
06:32:27 <xerox> I don't know which instance would you find there, humasect.  Do you have any specific question?
06:32:53 <humasect> trying to find out why something isn't happening when there are not ifs/branches/etc
06:32:59 <humasect> only action precedence
06:33:56 <humasect> (no specific question)
06:35:23 <Itkovian> xerox: trying CFLAGS="-static" CXXFLAGS="-static" make
06:36:21 <xerox> Itkovian: didn't work for me.
06:36:31 <Itkovian> hmm
06:44:33 <exe> Hello :-)
06:45:50 <xerox> Hi exe!
06:47:45 <Itkovian> ok, I've got a compiled version, but it will require some shared libs though, weird
06:47:56 <xerox> Cooool
06:48:01 <xerox> Boegel, grab it!
06:48:09 <xerox> Itkovian: how did you build it?
06:48:36 <Itkovian> buggers, it refuses to run.
06:48:46 <xerox> Aww :(
06:48:50 <Itkovian> I'm missing the .a stuff for the gtk stuff
06:49:05 <xerox> Oh yes, me too.
06:49:14 <xerox> What error does it give, running it?
06:49:25 <Itkovian> No such file or directory ;-)
06:49:34 <Itkovian> it _is_ there though ;-)
06:51:59 <xerox> Yay
06:53:31 * boegel wonders why xerox and Itkovian are going through so much trouble
06:54:13 <Itkovian> to save yr ass from getting dirty in the source, eh
06:54:19 <xerox> boegel: yo could give it another trhy..
06:54:57 <Itkovian> get the debian images and install them yrself
06:55:42 <xerox> There are .debs of obby, net6, and gobby
06:56:35 <greenrd> @hoogle isSuffix
06:56:39 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
06:59:53 <Itkovian> gotta run.
06:59:55 <Itkovian> ttyl
07:00:35 <exe> How are you doing xerox?
07:01:11 <xerox> Fine, a bit of headache for compilation problems :-)
07:01:59 <CosmicRay> poetix: When you said "The brightest Python people are basically trying to hack Python into being a different language", were you refering to PEP3000?
07:02:34 <poetix> Not directly
07:02:43 <poetix> I was thinking more of Philip Eby and his multimethods
07:02:51 * CosmicRay hasn't heard of this
07:03:01 <CosmicRay> I haven't really followed python for about a year now, since I switched to ocaml and then haskell
07:04:24 <dons> CosmicRay, http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
07:04:24 <xerox> poetix: multimethods has something to do with CLOS dispatch system?
07:04:26 <dons> any comments
07:04:45 <poetix> PJE is doing some quite clever things with predicate dispatch
07:04:59 <dons> also, preliminary performance measurements versus PackedString (at the bottom of the page): http://www.cse.unsw.edu.au/~dons/code/fps/README
07:05:12 <CosmicRay> dons: I should probably just look at the darcs diffs...
07:05:36 <CosmicRay> I haven't actually gotten around to writing the code that uses FPS yet, so I'm not all that familiar with its API yet
07:05:44 <CosmicRay> so I am probably not the best to comment
07:05:59 <dons> I'd like to propose to libraries@ that we add it to the hier libs after an appropriate polishing periood
07:05:59 <xerox> dons: YAY
07:06:02 <xerox> @karma+ dons
07:06:03 <lambdabot> dons's karma raised to 14.
07:06:37 <dons> CosmicRay, so I was wondering more about any useful remarks on what should be done to make it more acceptable to libraries@
07:06:39 <CosmicRay> nice performance stuff.
07:06:43 <CosmicRay> ah.
07:07:04 <dons> i put a fair bit of work in this week quickchecking and tuning each function, and adding some new ones (i.e. unfoldr!)
07:07:16 <CosmicRay> well, I heard a little bit of grumbling that the PackedString type shares a name with the Data.PackedString module.
07:07:36 <CosmicRay> but in general, I like it, and I especially like the fact that haddock comments exist for everything.
07:07:46 <CosmicRay> it ticks me off to find stuff in fptools without haddock comments.
07:07:58 <Igloo> dons: head1 is just an optimisation, right?
07:08:00 <dons> right. grizzle grizzle fgl
07:08:16 <dons> Igloo, hmm. yes.
07:08:54 <dons> Igloo, comments please.
07:08:56 <CosmicRay> could using it conceivably lead to a segfault?
07:08:57 <Igloo> I think you should have an unwords', even if it's just = unwords
07:09:04 <dons> good idea.
07:09:17 <dons> CosmicRay, head1, or fps in general?
07:09:22 <CosmicRay> head1
07:09:48 <dons> no. it would give a pattern match failure, wouldn't it
07:09:49 <CosmicRay> oh, and what did you do about the lines debate?
07:10:00 <Igloo> It would?
07:10:00 <CosmicRay> ahh, never mind
07:10:06 <dons> oh. hmm.
07:10:10 <dons> > head1 empty
07:10:10 <dons> '\NUL'
07:10:17 <dons> silly me.
07:10:20 <greenrd> @hoogle FilePath -> String
07:10:21 <lambdabot> Prelude.show :: Show a => a -> String
07:10:21 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
07:10:21 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:10:30 <greenrd> @hoogle FilePath -> [String]
07:10:31 <lambdabot> Random.randoms :: (Random a, RandomGen b) => b -> [a]
07:10:31 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
07:10:31 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:10:32 <dons> so head1 etc should stay internal
07:10:40 <Igloo> Or be exported as unsafeHead
07:11:25 <dons> yeah. making it available, but unsafe is probably better, considering the likely users are trying to squeeze performance
07:11:59 <CosmicRay> right.
07:12:11 <poetix> dons: what makes fps go faster?
07:12:42 <Igloo> Why withCString and not withWord8s?
07:12:49 <Igloo> withCString might imply NUL termination
07:12:58 <dons> it never boxes characters into Char unless it has to, would be the main reason poetix
07:12:59 <Igloo> Oh, err, and you don't give the length
07:13:03 <ndm> greenrd, hoogle doesn't know much about FilePath, if anything...
07:13:18 <dons> I'll look at that igloo -- that's straight from darcs and i haven't explored it yet :}
07:13:27 <Igloo> Heh, fair enough  :-)
07:13:52 <dons> same goes for the lazy IO stuff.
07:15:49 <dons> i've also got some improvements to push back to darcs. pack/unpack for one. though again non-critical  (I don't think darcs packs any large Strings)
07:16:21 <Igloo> Cool
07:18:18 * dons gets some sleep
07:19:51 <xerox> Goodnight dons
07:24:43 <boegel> bye dons
07:26:19 <greenrd> Suppose I have a function a -> Tree (IO b)
07:27:01 <poetix> Rather than a -> IO (Tree b)?
07:27:07 <greenrd> yeah
07:27:12 <greenrd> What is the recommended way to translate that into a function a -> IO (Tree b)?
07:27:46 <poetix> Ouch
07:27:56 <greenrd> heh
07:28:16 <xerox> liftIO?
07:28:28 <xerox> with Tree deriving MonadIO?
07:28:43 <greenrd> @type liftIO
07:28:57 <lambdabot> bzzt
07:29:08 <greenrd> @hoogle liftIO
07:29:21 <Igloo> You'll need to write the equivalent of sequence for Tree
07:29:22 <poetix> I guess you need a monadic function to traverse the tree of IO b and build a tree of b
07:29:38 <greenrd> poetix: Yes, that's one way. Is there any other way?
07:29:46 <greenrd> @type sequence
07:29:47 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:29:57 <ape> how come haskell uses really short names? why not InputOutput, liftInputOutput, foldLeft?
07:30:05 <greenrd> ape: saves typing
07:30:24 <ape> but that's what tap-completion is for
07:30:36 <greenrd> I hate tab completion.
07:30:59 <greenrd> Well, at least as it's implemented in bash.
07:31:00 <ape> strange fellow
07:31:12 <ape> bash has several implementations
07:31:15 <greenrd> I mean, it's better than nothing, but it could be better.
07:33:56 <poetix> sequence = mapM (:) ?
07:34:30 <poetix> No...
07:34:51 <greenrd> I suppose I need to do it wrt a certain traversal order
07:35:07 <poetix> @type foldM
07:35:10 <lambdabot> bzzt
07:35:16 <greenrd> Because a depth first traversal could yield different results to a breadth first traversal, no?
07:35:31 <poetix> Same type, different execution order
07:35:47 <greenrd> yeah
07:36:10 <greenrd> ??? . sequence . flatten
07:36:14 <greenrd> heh
07:36:37 <greenrd> "Oh no, I've lost all my tree structure! How do I put it back together again!"
07:36:40 <poetix> @type mapM id
07:36:42 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
07:36:56 <greenrd> @type sequence
07:36:58 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:37:09 <greenrd> Same type - same function?
07:37:32 <humasect> b and a are on different sides
07:37:45 <greenrd> yeah but I don't think that matters
07:37:57 <greenrd> in math forall a b is equivalent to forall b a
07:38:05 <humasect> mm
07:38:52 <poetix> I guess you need a traverseM, so you can write traverseM id
07:39:36 <greenrd> ok, I'll try that
07:39:49 <reppie[^_^]> schni schna schnappi schnappi schnappi schnapp
07:40:19 <boegel> *hack
07:40:29 <humasect> make sure your soup is hot enough so you don't accidentally eat it too fast
07:40:31 * boegel feasts on a headless crocodile
07:40:51 * poetix can't fit into these damn travelling pants
07:42:26 <Hatchetman> @index unsafePerformIO
07:42:27 <lambdabot> System.IO.Unsafe, Foreign
07:42:45 <greenrd> @type mapM
07:42:47 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:42:49 <poetix> greenrd: maybe you need to start with a structure-preserving treeMap, then write treeMapM
07:43:01 <greenrd> I've done treeMap
07:43:42 <poetix> How did you end up with a Tree of IO values anyway?
07:43:56 <greenrd> heh
07:44:23 <greenrd> I'm writing a function readAll which goes Tree Directory -> Tree DirectoryAndData
07:44:42 <greenrd> oops
07:44:57 <greenrd> It goes Tree Directory -> IO (Tree DirectoryAndData)
07:45:12 <greenrd> and so far I've done the  Tree Directory -> Tree (IO DirectoryAndData)
07:45:52 <poetix> That seems like a weird intermediate step, somehow
07:45:53 <greenrd> you can of course filter files you don't want from the Directory data structure before calling that
07:45:56 <greenrd> heh
07:49:40 * boegel leaves
07:49:46 <boegel> c u people tomorrow !
07:51:28 <exe> Is there a function like sgn.x |x>0 = 1|x<0 = -1|otherwise 0 ?
07:51:37 <Hatchetman> @index IOExts
07:51:38 <lambdabot> bzzt
07:53:20 <Hatchetman> hmm
07:57:03 <reppie[^_^]> http://img59.imageshack.us/img59/3641/lolomgwtf6by.gif
07:58:32 <Hatchetman> anyone know of a standard module named IOExts ?
07:58:43 <Hatchetman> the UU parser needs it...but it cant find it on my windows platform
07:58:59 <ndm> Hatchetman, yep, IOExts shipped with old versions of Hugs
07:59:09 <ndm> nowadays its changed name
07:59:12 <Hatchetman> omg...why would it need *that* file
07:59:25 <ndm> if you want unsafePerformIO, which is what it usually gets out of there
07:59:30 <ndm> @index unsafePerformIO
07:59:31 <lambdabot> System.IO.Unsafe, Foreign
08:00:24 <Hatchetman> ok, thanks a lot
08:00:35 <Hatchetman> would have cost me some time searching i guess
08:00:57 <Hatchetman> indeed, they import it to use unsafeInterleaveIO
08:07:53 <greenrd> @hoogle (IO a, IO b) -> IO (a, b)
08:07:54 <lambdabot> No matches, try a more general search
08:08:10 <greenrd> @hoogle (Monad m) => (m a, m b) -> m (a, b)
08:08:11 <lambdabot> No matches, try a more general search
08:08:17 <greenrd> @hoogle (m a, m b) -> m (a, b)
08:08:18 <lambdabot> No matches, try a more general search
08:15:14 <metaperl> Any sufficiently complicated C or Fortran program contains an
08:15:15 <metaperl>   ad-hoc, informally-specified bug-ridden slow implementation of half
08:15:15 <metaperl>   of Common Lisp. -- Phillip Greenspun's tenth rule of programming
08:16:37 <greenrd> @type sequence
08:16:50 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:22:07 <xerox> @index forkIO
08:22:09 <lambdabot> Control.Concurrent
08:26:49 <FrederikEaton> is there a way to use Hat without hmake?
08:27:05 <ndm> Frederik, yep - just run hat-trans on all the files
08:27:10 <ndm> the compile it
08:27:18 <ndm> but hmake is certainly more convenient...
08:27:22 <FrederikEaton> ah
08:27:31 <ndm> why don't you want to use hmake?
08:27:31 <FrederikEaton> hmake is finding the wrong ghc
08:27:39 <ndm> hmake-config
08:27:39 <FrederikEaton> it's not looking in PATH
08:27:43 <FrederikEaton> ?
08:27:45 <FrederikEaton> hmm
08:27:48 <ndm> you can specify which ghc to use
08:28:00 <ndm> or to use multiple ones - i have ghc5 and ghc6 configured with hmake
08:28:17 <ndm> http://haskell.org/hmake/hmake-config.html
08:29:42 <FrederikEaton> what a horrible design
08:30:54 <ndm> how so? once you have it setup its pretty good at doing it all
08:31:04 <ndm> i think the bad design bit of it is that it doesn't run on windows...
08:31:45 <FrederikEaton> it forces you to duplicate information which should be stored elsewhere
08:32:03 <FrederikEaton> i just want it to read $PATH like every other program
08:32:35 <ndm> if you configured ghc to be "ghc" as its full path, then i think it would take it out of $PATH
08:33:04 <ndm>     $ hmake-config add ghc		# takes the first ghc in the $PATH
08:33:07 <ndm> from the example page
08:34:54 <FrederikEaton> Fail: Can't find module Graphics.X11.Xlib in user directories
08:34:54 <FrederikEaton>         .
08:34:54 <FrederikEaton>   Or in installed libraries/packages at
08:34:54 <FrederikEaton>         /usr/lib/ghc-6.2.2/imports
08:35:05 <FrederikEaton> i never mention that version of ghc in my environment
08:35:28 <ndm> hmake-config list
08:35:36 <ndm> you may need to delete the older one
08:37:32 <FrederikEaton> "can't delete, it is configured globally"
08:38:03 <FrederikEaton> now it looks for ghc-pkg in the library directory:
08:38:05 <FrederikEaton> $ hmake -ghc -hat pointtracker.hs
08:38:05 <FrederikEaton> sh: /home/frederik/.toast-i386/armed/lib/ghc-6.4.1.20050812/bin/ghc-pkg: No such file or directory
08:38:25 <Lor> What's the best name for the property "a function always returns the same value for the same arguments"?
08:38:39 <FrederikEaton> Lor: referential transparency
08:38:39 <vegai> a function.
08:38:41 <Lor> (Given a loose, C-ish notion of function)
08:38:44 <FrederikEaton> $ which ghc-pkg
08:38:44 <FrederikEaton> /home/frederik/.toast-i386/armed/bin/ghc-pkg
08:38:46 <vegai> oh
08:38:53 <ndm> Lor: pure
08:38:55 <Igloo> pure function
08:39:22 <Lor> Can it be called "pure" even though it internally does lots and lots of mutation?
08:39:54 <Lor> And the value that it returns may depend on the external state. But it just always returns the same value.
08:40:01 <ndm> yes, as long as its arguments determine its results, and it doesn't effect the state of the world
08:40:17 <Lor> (So it depends on the state at the time it was first invoked on a particular argument)
08:40:36 <ndm> oh, thats not really pure at all
08:40:36 <Lor> ...and caches it thereafter.
08:40:46 <ndm> memoizing
08:41:34 <Lor> I'm not talking about a name for its implementation method, but a name of its external property.
08:43:08 <Igloo> Hmm, do you want idempotent?
08:43:15 * Igloo can't think of anything better
08:43:48 <ndm> i would have said memoizing was best as a name for external property
08:44:03 <Lor> memoization is an implementation technique
08:44:09 <ndm> or at least, there isn't anything better - no maths term because that idea is not a maths concept
08:45:22 <Igloo> I don't think memoization is right. That implies that if the memoization was removed then the behaviour (apart from time/space use) would be the same
08:45:47 <Lor> all that the function does is that given pointers p1 and p2, it returns integers such that f(p1) == f(p2) <==> p1 == p2
09:00:38 <TheHunter> greenrd, the recommended way is to provide an instance of FunctorM (drift can do that for you also). I once plead for the inclusion of fsequence, but it hasn't made it, so you'll have to use fmapM id.
09:02:55 <exe> How can I do integer() of a real number?
09:05:14 <xerox> exe: watch this:
09:05:23 <xerox> @hoogle Double -> Int
09:05:24 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
09:05:24 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
09:05:24 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
09:05:28 <xerox> @hoogle+
09:05:29 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
09:05:29 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
09:05:29 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
09:05:48 <ndm> (ironically, hoogle a->b would have been just as useful...)
09:06:38 <ndm> (and without dons patch for lambdabot, more accurate as well...)
09:06:48 <xerox> haha :-)
09:07:01 <exe> Thanks :-)
09:10:56 <exe> Prelude> :e
09:10:57 <exe> ERROR "alpi.hs":1 - Instance of Fractional Int required for definition of f
09:11:00 <exe> what does that mean?
09:11:30 <ndm> can you give us the definition of f?
09:11:40 <Igloo> exe: You do something with an Int that requires it to be in the Fractional class
09:11:44 <ndm> its basically a type error, you used a function that wanted something function
09:11:51 <Igloo> Possibly using / rather than div
09:12:16 <exe> hehe, yes.
09:12:19 <exe> Thanks.
09:18:42 <xerox> I got a little finnish friend working with my shots, he made a nice video out of them.. heh!
09:18:43 <xerox> http://haskell.galois.com/~paolo/tree/Tree-grow-tall.wmv
09:18:45 <poetix> @type fmapM
09:18:52 <lambdabot> bzzt
09:19:07 <xerox> fmapM ?!
09:19:56 <poetix> Bugadifino
09:20:05 <poetix> @type fmap
09:20:06 <ndm> xerox, thats pretty cool movie
09:20:06 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
09:20:06 <lambdabot> b
09:20:39 <xerox> ndm: a teen .fi friend made it, hehe, yes nice!
09:21:07 <ndm> you said on your blog it was about 150 lines of code, is it available
09:21:13 <ndm> and is it windows compatible?
09:21:16 <TheHunter> @type Data.Functor.fmapM
09:21:17 <lambdabot> bzzt
09:21:21 <TheHunter> @type Data.FunctorM.fmapM
09:21:22 <lambdabot> forall (f :: * -> *) b (m :: * -> *) a.
09:21:22 <lambdabot> (Data.FunctorM.FunctorM f, Monad m) =>
09:21:22 <lambdabot> (a -> m b) -> f a -> m (f b)
09:21:29 <TheHunter> @type Data.FunctorM.fmapM id
09:21:31 <lambdabot> forall (f :: * -> *) (m :: * -> *) b.
09:21:31 <lambdabot> (Data.FunctorM.FunctorM f, Monad m) =>
09:21:31 <lambdabot> f (m b) -> m (f b)
09:22:00 <xerox> ndm: err, not atm, I'm planning to release it
09:22:10 <xerox> I'm working on in atm, too.  I made it threaded.
09:22:33 <ndm> cool, i'm not really interested in it as much
09:22:45 <ndm> but a small easy gui language would be good
09:22:53 <ndm> and that looks a pretty powerful example
09:23:00 <xerox> Oh!
09:23:15 <xerox> In fact we're working with Itkovian in making a parser for a more human specification of the LSystem
09:23:35 <xerox> and with boegel to put some "randomness" in it :-D
09:23:43 <Itkovian> haha
09:24:38 <xerox> ..or every permutation Itkovian like of the last two sentences :-P
09:24:59 <Itkovian> eh?
09:25:55 <SyntaxNinja> morning
09:26:57 <xerox> Hi SyntaxNinja !
09:27:56 <SyntaxNinja> xerox: how's hack?
09:28:04 <xerox> SyntaxNinja: check this out:
09:28:09 <xerox> http://haskell.galois.com/~paolo/tree/Tree-grow-tall.wmv
09:29:00 <xerox> I'll take a shower.. ttyl
09:29:35 <Itkovian> gotta run ttyl
09:33:30 <malcolm> ping FrederikEaton
09:34:39 <wilx> @wtf ttyl
09:34:42 <lambdabot> No match for "ttyl".
09:34:51 <wilx> @wtf fyi
09:34:53 <lambdabot> No match for "fyi".
09:34:57 <wilx> Heh.
09:35:07 <wilx> Does the @wtf trigger really exist?
09:36:59 <TheHunter> @wtf wtf
09:37:01 <lambdabot> No match for "wtf".
09:37:02 <wilx> Hmm, I don't see it in @listcommands
09:37:34 <TheHunter> the autocorrection does strange things.
09:37:38 <wilx> Cygwin has this `wtf' package, that does have this database of acroabbrevs.
09:37:40 <TheHunter> @help wft
09:37:52 <wilx> Err, abbrevs :)
09:37:53 <TheHunter> @wtf test
09:38:04 <wilx> So it will tell you that...
09:38:09 <wilx> ttyl: talk to you later
09:38:18 <lambdabot>  @help <command> - ask for help for <command>
09:38:19 <lambdabot> *** "test" wn "WordNet (r) 2.0"
09:38:21 <lambdabot> test
09:38:24 <lambdabot>   n 1: any standardized procedure for measuring sensitivity or
09:38:26 <lambdabot>     memory or intelligence or aptitude or personality etc;
09:38:28 <lambdabot>     "the test was standardized on a large sample of
09:38:30 <lambdabot>     students" [syn: {mental test}, {mental testing}, {psychometric
09:38:32 <lambdabot>     test}]
09:38:33 <lambdabot> [29 @more lines]
09:38:50 <TheHunter> @todo-add autocorrection for @help.
09:38:51 <lambdabot> Entry added to the todo list
09:57:44 <SyntaxNinja> @seen phillipa
09:57:45 <lambdabot> I haven't seen phillipa.
09:57:48 <SyntaxNinja> @seen philipa
09:57:50 <lambdabot> I haven't seen philipa.
09:58:57 <SyntaxNinja> @seen Philippa
09:58:58 <lambdabot> I saw Philippa leaving #haskell 2 hours, 14 minutes and 36 seconds
09:58:58 <lambdabot> ago.
09:59:27 <TheHunter> @todo make @seen case-insensitive
09:59:28 <lambdabot> module "todo" screwed up: @todo given arguments, try @todo-add or @
09:59:28 <lambdabot> listcommands todo
09:59:38 <TheHunter> @todo-add make @seen case-insensitive
09:59:39 <lambdabot> Entry added to the todo list
10:10:46 <autrijus> hm, is there a fast getLine that does not return String?
10:10:54 <autrijus> I'm fine with either a CStringLen or a PackedString
10:19:15 <Lenny1729> hi all
10:19:46 <lispy> autrijus: iirc dons's version of fast packed strings does that
10:19:49 <lispy> @where fps
10:19:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:20:45 <lispy> autrijus: http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html#17  <-- actually i'm wrong
10:22:04 <Beelsebob> :o
10:22:13 <Beelsebob> iChat is to support "document sharing"
10:22:21 <Beelsebob> ... colaborative editing of... ANYTHING
10:22:49 <Beelsebob> or that's how it appears
10:22:57 <Beelsebob> from various bits of the current app bundle
10:27:58 <Lenny1729> Given data StateT state m a = StateT (state -> m (state, a)) if I want to make StateT an instance of MonadTrans I need to write: instance MonadTrans (StateT state) where... Why does instance MonadTrans StateT where... not work? Is it because StateT isnt really defined without state???
10:30:19 <autrijus> StateT has kind *->*->*->*, and MonadTrans want something of kind *->*->*.
10:31:23 <Lenny1729> ah ok...
10:31:54 <luqui> hmm, is there something like "flip" for types?
10:32:12 <Lenny1729> stupid question... but somehow these Monads make me think weird
10:32:30 <luqui> that is, if I had Foo a b, and I wanted to make a monad out of Foo b in a, could I?
10:32:43 <luqui> hmmm, that wasn't phrased very well
10:32:56 <autrijus> luqui: newtype Flip a b = Flip (Foo b a)
10:33:16 <luqui> 'cept that makes a new identity in the type system
10:33:36 <autrijus> flip makes a new function too.
10:34:17 <luqui> But I couldn't say:  instance Monad (Flip Foo b)
10:34:32 <autrijus> newtype Flip m a b = Flip (m b a)
10:34:35 <autrijus> then
10:34:42 <autrijus> instance Monad (Flip Foo b)
10:34:48 <luqui> huh, interesting
10:35:07 <luqui> I'll have to play with that a bit
10:35:24 * luqui should go to school
10:35:25 * luqui &
10:36:39 <Lenny1729> Does anybody know if Hal Daume continues to write on Yet another Haskell tutorial? or is it abandoned?
10:37:29 <lispy> this is why tutorials should be wikis
10:37:41 <lispy> Lenny1729: no clue :(
10:38:23 <Lenny1729> hm... I really like YAHT but it's so incomplete
10:38:37 <markg> Is there a way to convince GHC to output profiling information on library functions as well as your own?
10:38:53 <markg> I'm curious to find out which library calls are the most expensive in my application
10:39:13 <lispy> markg: near as i can tell, you need to compile with profiling enabled when building the libs
10:39:32 <lispy> markg: but if you figure out a way to do it, let me know, i've wanted/needed that before
10:40:41 <Akshaal> hola
10:44:33 <markg> lispy: Thanks
10:44:46 <markg> That seems to be the consensus
10:46:11 <markg> It appears that my package does have libraries with profiling enabled... Hmm
10:49:12 <markg> Another question, does anyone know of a decent, fast haskell random number generator?
10:49:26 <markg> preferably gaussian doubles
10:54:00 <lispy> markg: i'm not sure, but maybe ghc's Random module uses something nice under the hood?  I know they use GMP for Integers.
10:54:33 <xerox> Do you have a better rephrase for "There is the longer term project to release of the code in a not bundled fashion" ?
10:54:54 <xerox> I mean, we were planning to release the cairo "per-se" sometime
11:02:56 <astrolabe> 'There is a long term project to release the code in an unbundled form' would be more idiomatic.
11:05:56 <xerox> standalone!
11:06:03 <xerox> Is the word I was searching for.
11:06:30 <astrolabe> LOL!  Sorry
11:08:52 <xerox> :-D
11:47:48 <xerox> Do you have any link explaining the mean of "purely functional" in a good way?
12:33:05 <poetix> Anyone have any idea what it might mean when I run ./Setup.hs configure for c2hs, and am told "Unknown field - 'hs-source-dirs'"?
12:33:48 <Lemmih> You need a newer Cabal.
12:35:18 <poetix> Right
12:35:57 <poetix> Hooray for the bleeding edge!
12:36:04 <sieni> Hmm... that looks cool as a second keyboard in addition to happy hacking pro, so that one doesn't necessarily need to move right hand, while using a trackball:  http://www.infogrip.com/product_view.asp?RecordNumber=12
12:41:07 <poetix> That's better (one install of 1.2RC later)
12:41:34 <poetix> Am I going to miss alex, happy and haddock if I don't build c2hs with support for them?
12:42:21 <poetix> I guess I should probably go and get them anyway
12:42:24 <xerox> You can?!
12:43:01 <xerox> I suggest you to install haddock, I think the other two programs are `must' dependencies.
12:43:49 <poetix> It ran configure, claimed not to find alex or happy, but finished configuring quite cheerfully anyway
12:44:00 <xerox> "I was never involved" or "I had never been involved" ?
12:44:18 <poetix> xerox: Context?
12:45:22 <sieni> http://exhouse.untergrund.net/warez/pron/misc/hot_lesbian_action.jpg
12:45:26 <xerox> "in some projects"
12:48:51 <poetix> Doesn't quite make sense either way
12:49:14 <poetix> Is the sense, "I had never been involved in any projects before"
12:49:20 <xerox> Yes
12:49:38 <poetix> Then it's "I had never been involved"
12:49:50 <poetix> And, probably, "any projects" rather than "some projects"
12:50:25 <xerox> OK.
12:50:29 <xerox> Thanks.
12:58:14 <poetix> Happy doesn't like me either...
12:58:41 <Marty> hi. i'm new to haskell and i am currently reading hudak's "the haskell school of expression"... mind if i ask a question?
12:58:50 <poetix> It's complaining about GetOpt being a member of package util-1.0
12:58:56 <poetix> Marty: hi
12:59:02 <poetix> Marty: go ahead...
13:00:13 <Marty> thanks. in the book, there is a function "spaceClose": spaceClose :: Window -> IO ()
13:00:13 <Marty> spaceClose w
13:00:13 <Marty>         = do    k <- getKey w
13:00:13 <Marty>                 if k == ' ' then closeWindow w
13:00:13 <Marty>                             else spaceClose w
13:00:32 <poetix> Uhuh
13:00:56 <Marty> i get the error message: "ERROR "graph.hs":6 - Last generator in do {...} must be an expression"
13:01:37 <poetix> Could be the formatting of the if...then...else statement
13:01:40 <monochrom> check indentation, tables, etc.
13:01:43 <Marty> i'm not into IO-stuff yet and this is a example i copied 1:1 from the book ...
13:01:45 <monochrom> err tabs
13:01:56 <monochrom> try to use no tab
13:02:05 <Marty> okay, i'll try it with space
13:03:58 <Marty> wow. it works. thank you. i love errors like this...
13:08:09 <poetix> I never read Hudak
13:08:22 <poetix> I got to borrow a friend's copy of Bird for a few weeks
13:08:33 <poetix> It's good, but pretty dry...
13:09:50 <xerox> Do you think "#1c86ee" is a good answer to "What is your favorite color?"
13:10:15 <poetix> haha
13:10:24 <Marty> i have already read hudak's "gentle introduction to haskell", which i liked, so i thought i could try his book
13:11:28 <poetix> xerox: Maybe not detailed enough - I notice gtk2hs uses 16 bits for R, G and B values
13:11:45 <xerox> Yay :-)
13:11:56 <poetix> So "#1c0086ffe0e4" perhaps...
13:12:34 <sieni> I have Simon Thompson's "Haskell: The Craft of Functional Programming", which is pretty good although a bit too basic. I'd like to have something similar to Paulson's "ML for the working programmer" for Haskell
13:12:39 <vininim> I prefer Yet Another Haskell Tutorial =p
13:12:59 <poetix> The Gentle Introduction is horribly misnamed...
13:13:14 * xerox agrees with poetix
13:13:46 <poetix> If you came out of that wanting to know more, then I salute your pluck
13:13:48 <xerox> My list of worth paying books includes "The Haskell Road to Math, Logic, and Programming".
13:14:27 <Marty> i went for hudak's book because it doesn't use the usual mathematical examples... until now, i didn't write much in haskell that was not intended to solve a math problem
13:15:34 <poetix> There's a lack of texts with a real emphasis on "practical" Haskell - not that math problems aren't also practical, of course, but they're a small subset of the practical tasks programmers want to accomplish
13:16:01 * poetix thinks xerox should write a book on UI programming in Haskell
13:16:01 <Marty> that's what i'm saying ;)
13:16:16 <xerox> A _book_ ?!
13:16:29 <poetix> Get it published by O'Reilly
13:16:55 <xerox> We could choose an animal for Haskell that way!
13:17:06 <poetix> Exactly! But which animal?
13:17:10 <vegai> Sloth?
13:17:21 <vegai> isn't it obvious? =)
13:17:25 <poetix> Slime mold?
13:17:33 <xerox> Something between myth, fantasy and dream.
13:17:33 <vininim> a catterpillar =p
13:17:40 <basti_> -g-
13:17:46 <basti_> with a hookah
13:18:03 <poetix> Well, we know Haskell is a drug
13:18:23 <xerox> Yes.
13:18:26 <basti_> ohh.
13:18:31 <xerox> So.. hypotic toad?
13:18:36 <basti_> comparable to what?
13:18:36 <xerox> *hypnotic tad
13:18:41 <poetix> liftIO makes you larger, and foldR makes you small
13:18:50 <poetix> And the id that mother gives you, doesn't do anything at all
13:19:04 <vininim> o_o
13:19:16 <basti_> lol
13:19:33 <poetix> I am really not as old as quoting that makes me sound...
13:20:06 <xerox> @remember poetix "Well, we know Haskell is a drug, liftIO makes you larger, and foldR makes you small. And the id that mother gives you, doesn't do anything at all. - I am really not as old as quoting that makes me sound..."
13:20:31 <xerox> Perfect.
13:20:56 <poetix> I mean, I think the reason I don't remember the 60s is that I actually *wasn't* there
13:21:00 <xerox> I could write something for gtk2hs FAQ category (as Duncan, great Duncan) did.
13:21:07 <poetix> At least, not in this incarnation...
13:21:36 <poetix> Maybe there should be a wikibook
13:22:26 <mwc> Does anybody know what the status of the TRex style records mentioned here is: http://research.microsoft.com/~simonpj/Haskell/records.html ? Is it as far along as an -fglasgow-exts
13:23:15 <xerox> mwc: Haskell does have records without any exts, as long as I know.
13:23:33 <xerox> s/long/far/
13:23:44 <poetix> TMR is already quite close to what's needed - just another dozen issues, and there's be enough material to compile into a print book ;)
13:23:50 <xerox> The final Google form for the SoC finish.. is DAMN LONG.
13:24:47 <mwc> xerox, there is a really broken ugly records system
13:24:54 <mwc> in Haskell 98
13:25:02 <mwc> This is supposed to be better and completely replace it
13:25:38 <xerox> What do you think about this description for my project? (hey poetix)
13:25:40 <xerox> http://rafb.net/paste/results/C6FcXT85.html
13:26:20 <stepcut> mwc: There was a meeting at some conference where they discussed records in detailed. They decide that everyone wants better records haskell, but no one can agree on what 'better' is
13:26:23 <xerox> mwc: uh, I think I read that records.html back then when I was trying to find how to use records, and IIRC is much different from the wikipage that actually describe current ones.  Sorry.
13:27:03 <stepcut> mwc: since then, HList has been written, which provides many of the features people want in an extensible record system, without having to change the compiler at all
13:28:20 <stepcut> mwc: HList produces horrid error messages, and can be quite bothersome to use, *but* it shows that good quality records may not required onerous changes to the haskell core...
13:28:27 <stepcut> atleast, that is my opinion
13:28:29 <xerox> That description will show up on code.google.com in some days.
13:28:48 <xerox> It includes an Haskell description (got from haskell.org) so you're interested I think :-)
13:29:12 <stepcut> xerox: did you get that second A* paper I pm'd you? I think freenode may have blocked it because I did not register...
13:29:43 <mwc> stefanw, HList sounds EXACTLY like what I was looking for
13:30:13 <xerox> stepcut: freenode did it, unfortunately, please tell me! I skimmed the first one. I'm reading the Lindenmaier book boegel suggested me now :-)
13:30:26 <xerox> Or was he Linderm[ae]yer?
13:30:38 <xerox> Lindenmayer.
13:30:40 <stepcut> xerox: one moment
13:31:06 <stepcut> http://scholar.google.com/scholar?hl=en&lr=&ie=UTF-8&c2coff=1&safe=off&q=cache:ZLSbcRZnb34J:plan.cs.drexel.edu/courses/itcr01/papers/korf96finding.ps
13:31:44 * stepcut goes to lunch
13:31:59 <xerox> Thanks!  Enjoy the meal :-)
13:46:57 <poetix> xerox: Just got off the phone
13:47:10 <poetix> xerox: And looked at your project description
13:47:23 <poetix> Do yo have a place I can post a proof-read version?
13:48:08 <poetix> Oh, wait - rafb.net/paste...
13:48:12 <xerox> poetix: yes, there.
13:48:22 <xerox> I was about clicking "Send" !
13:55:26 <poetix> xerox: http://rafb.net/paste/results/c4Fvfv86.html
13:56:30 <xerox> Why you dropped the first "the"
13:56:32 <xerox> ?
13:58:11 <poetix> You could keep the "the"
13:58:13 <xerox> Anyway, OK I'll get something from yours, thanks much!
13:58:19 <poetix> Or replace it with "some", even.
13:58:48 <xerox> The question was "Provide a one-paragraph description of your project to be put on ..", so I'll keep it one-line.
13:59:57 <poetix> Maybe "My project was to write Haskell bindings for the Cairo graphics library, and integrate them..."
14:00:14 <xerox> Hmm yes.
14:01:08 <xerox> Good!
14:03:59 <poetix> Well, today I've done the configure/make/make install dance, complete with minor adjustments to makefiles and other special incantations, for five separate libraries...
14:04:20 <poetix> Yesterday it was six, I think, to get GTK2.8.3 in
14:04:37 <poetix> And would've been more, if I'd wanted ps / pdf / glitz backend support for Cairo
14:06:08 <xerox> We have received your report. Thank you for participating in the Summer of Code.
14:06:12 * xerox does a little dance.
14:06:21 <poetix> I must admit, I do like watching the build process output scroll across a terminal window - makes me feel like my computer's doing some real work for a change
14:06:38 * poetix applauds xerox
14:06:43 * xerox hugs poetix
14:07:33 <poetix> I hope they give you large amounts of money, and/or job offers...
14:07:40 <xerox> I hope so too!
14:07:52 <xerox> They asked for expected graduation date.
14:08:45 <shapr> I have a new apartment, yay!
14:08:50 <SyntaxNinja> shpar!!!
14:08:52 <xerox> Cool!
14:10:00 <cjb> Neat.
14:10:41 <shapr> w00
14:11:03 <shapr> And tomorrow I'm moving!
14:11:36 <xerox> Then, uni?
14:12:36 <shapr> Yeah, hopefully.
14:13:58 <Marty> i'm out. bye
14:14:01 <xerox> Bye!
14:15:49 <poetix> shapr: What are you going to do at uni?
14:15:50 <shapr> Man, haven't seen desrt in forever, what's up with him?
14:15:59 <shapr> poetix: As little as possible.
14:16:10 <shapr> No really, I'm going to get a CS degree.
14:16:19 <shapr> I figure it would be nice to learn something about computers.
14:16:20 <boegel|home> shapr: w00 !
14:16:32 <boegel|home> shapr: I bet you will be bored a lot
14:16:34 <shapr> hoi!
14:16:34 <Spark> shapr: so why do you want to get a cs degree :)
14:16:42 <poetix> I cannot imagine you slacking at that, seriously.
14:16:49 <boegel|home> Spark: to find a job and earn more money, duh
14:16:54 <astrolabe> Don't do it shapr, they're nasty complicated things.
14:16:55 <shapr> Actually, what he said...
14:17:05 <Spark> heh
14:17:23 <Spark> the person i know who's on the higest salary didnt even do a levels
14:17:40 <shapr> I personally am on the level, and I still don't get paid much.
14:17:49 <astrolabe> The person I know who's on the highest has a pure maths PhD :)
14:18:01 * boegel|home doesn't like pure maths
14:18:08 <Spark> its more about being in the right place at the right time :)
14:18:09 <cjb> astrolabe: That evens out as you get older.
14:18:15 <shapr> I do like pure math actually.
14:18:16 <Spark> or rather being the person they need really really badly
14:18:20 <poetix> I have no technical education beyond GCSE - it was all humanities for me from age 16 onwards
14:18:24 <boegel|home> shapr: good, you'll need it :)
14:18:31 <shapr> poetix: But you do have a degree.
14:18:42 <poetix> Yes. In English Literature.
14:18:44 <cjb> Gosh.  Most people here are British, then?
14:19:07 <Spark> haskell - the choice for middle class programmers
14:19:41 <shapr> poetix: In most places it's just about having any sort of degree and then qualifications.
14:19:53 <astrolabe> poetix:  How did you get from English Lit to haskell?
14:20:13 <xerox> Patterns!
14:20:16 * xerox guesses
14:20:28 <shrimpx> did ghc allow a module to be defined across many files?
14:20:33 <shrimpx> s/did/does/
14:21:23 <boegel|home> cjb: nah, many nations are represented in here (Belgium !)
14:21:48 <TheHunter> nope, but the c preprocessor does.
14:22:26 <shrimpx> i'm trying to compile some code that supposedly needs ghc 6.0 (with ghc 6.4) and module Main is defined in like 7 files
14:22:53 <cjb> shapr: Where are you going to get the degree?
14:22:55 <TheHunter> looks like 7 different programs then.
14:23:12 <shrimpx> TheHunter: the bundled Makefile doesn't think so =)
14:23:51 <shapr> cjb: I'll start at Luleå Technical University .
14:24:01 <cjb> Ah, not moving too far, then.  :)
14:24:44 <FrederikEaton> hi Chris
14:24:55 <cjb> 'lo.
14:25:02 <FrederikEaton> where do i find HsDebug?
14:25:09 <sieni> shapr: Argh, WTF-8 strikes again ;-)
14:25:19 <shapr> C'mon, it's the way of the present.
14:25:40 <cjb> That was UTF-8?  Can't have been multi-byte, 'cause my client displayed it.
14:25:42 <shapr> cjb: I've moved about fifteen minutes unicycle ride from my previous location.
14:25:45 <basti_> unicode is the way to go.
14:25:57 <sieni> 
14:26:07 <basti_> äöüßÄÖÜ!
14:26:17 <basti_> ð
14:26:26 <shapr> Thïs îs ã tést.
14:26:30 <cjb> If English was good enough for Jesus, it's good enough for me.
14:26:36 * shapr grins
14:26:52 <sieni> - l rkk tuota rkk! en m rkkkn!
14:27:34 <FrederikEaton> hmm, does anybody use HsDebug?
14:27:42 <basti_> cjb: jesus didnt talk english.
14:27:54 <FrederikEaton> i'm trying to get, er, "stack traces" for pattern match errors
14:28:00 <FrederikEaton> basti_: "speak"
14:28:11 <basti_> FrederikEaton: thanks
14:28:30 <FrederikEaton> it seems like it should be easier than this
14:28:53 <FrederikEaton> but Hat doesn't support any libraries, Buddha doesn't support GHC 6.4 ... right?
14:29:35 <cjb> basti_: I know.
14:29:39 <basti_> cjb: good.
14:35:33 <poetix> xerox: It's all about the patterns...
14:35:42 <xerox> Indeed poetix.
14:35:44 <poetix> Anyhow, gotta say goodnight
14:35:53 <xerox> Goodnight!
14:35:55 <poetix> See y'all
14:53:57 <ulfdoz> bye
14:55:36 <xerox> Bye
14:56:06 * boegel|home leaves too
14:56:30 <xerox> Oh boegel!  See ya :-)
14:58:24 <FrederikEaton> Copying patch 435 of 3497: 20050415231250-3fd76-fc2db9ce2a2035ec15f4ab9197719dfee914b102.gz
14:58:25 <FrederikEaton> grr
14:58:57 <shapr> You could use --partial
14:59:25 <FrederikEaton> brilliant
14:59:47 <FrederikEaton> what does that do? makes it so i can't revert past a certain point?
14:59:55 <xerox> Getting comments on blog posts is great.
15:00:13 <boegel|home> xerox: pm ! :)
15:01:03 <xerox> I can't read it, d'oh.
15:01:17 <xerox> It's because the new FreeNode policy, you have to identify :-(
15:01:24 <boegel|home> xerox: oh :s
15:01:30 <xerox> Aww!
15:01:46 * boegel|home tries to remember how to identify using this nick...
15:02:05 <xerox> In fact you could link nicks so you get identified on both (or even more than two)
15:02:42 <boegel|home> xerox: pm ?
15:09:09 <shapr> FrederikEaton: HsDebug is part of the spec_eval fork of GHC.
15:16:22 <shapr> Óla jao
15:17:09 <jao> hola shapr :)
15:17:16 <shapr> ¿como est as?
15:17:31 <jao> bien, y tu?
15:17:41 <shapr> bien!
15:17:57 <basti_> and now in linear b
15:20:57 <boegel|home> g'night (for real now)
15:20:57 <shapr> Guten abend basti_, wie geht es?
15:21:03 <shapr> g'night boegel|home
15:21:26 <basti_> "wie geht es dir"
15:21:40 <basti_> but, rather, "wie geht's"
15:21:47 <basti_> but in germany you dont ask that anyway.
15:21:55 <basti_> except for if you want to hear the answer.
15:22:05 <greenrd> @hoogle [a] -> [[a]]
15:22:07 <lambdabot> List.tails :: [a] -> [[a]]
15:22:07 <lambdabot> List.group :: Eq a => [a] -> [[a]]
15:22:07 <lambdabot> List.inits :: [a] -> [[a]]
15:22:13 <greenrd> @hoogle+
15:22:14 <lambdabot> Prelude.repeat :: a -> [a]
15:22:14 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
15:22:14 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
15:22:38 <greenrd> @hoogle a -> [a] -> [[a]]
15:22:39 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
15:22:39 <lambdabot> Prelude.replicate :: Int -> a -> [a]
15:23:03 <shapr> basti_: I don't ever ask that unless I want to hear the answer.
15:23:10 * TheHunter doesn't understand @hoogle.
15:23:20 <basti_> i got the impression the question actually means "hi" in english.
15:23:23 <TheHunter> @type List.intersperse
15:23:28 <lambdabot> forall a. a -> [a] -> [a]
15:23:34 <greenrd> TheHunter: thanks!
15:23:36 <shapr> But that gets me in trouble in social situations, because I assume that other people don't ask "How are you?" unless they want to know.
15:23:56 <shapr> hiya conal, how's code?
15:24:09 <conal> hey shapr.
15:24:14 <TheHunter> ah, intersperse concats.
15:24:37 <conal> shapr: do you mean "how's code?" as a question about programming?  or just "hello", or what?
15:25:32 <shapr> I mean it as, "How's the code you've been working on?" In your case, you mentioned you were considering rewriting Pan, and you've talked about some other interesting projects (Arrows stuff for example).
15:26:29 <conal> thanks for the clarification.  i've not been programming at all lately.  my energy is elsewhere.  i hope/guess it'll come back again.
15:29:49 <xerox> @hoogle \(_,b,_) -> b
15:29:50 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
15:29:50 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:29:50 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
15:29:55 <xerox> Err.
15:30:02 <xerox> @pl \(_,b,_) -> b
15:30:03 <lambdabot> (line 1, column 6):
15:30:03 <lambdabot> unexpected ","
15:30:03 <lambdabot> expecting letter or digit, operator or ")"
15:30:03 <lambdabot> ambiguous use of a non associative operator
15:30:13 <xerox> Hmpf :-)
15:30:18 <xerox> Any nice way to do it?
15:30:34 <shapr> \(x,y,z) -> y
15:30:39 <Igloo> No nicer way
15:31:01 <Igloo> Other than using a datatype and making it a record
15:31:02 <xerox> Ah, I'm fiddling again with "no fmap instances for n-tuples" ?
15:34:52 <shrimpx> holy @list-commands batman
15:36:39 <monochrom> haha
15:36:50 <basti_> @ghc
15:36:51 <lambdabot>  Malformed context in type or class declaration
15:37:41 <monochrom> @hoogle [a] -> a
15:37:42 <lambdabot> Prelude.product :: Num a => [a] -> a
15:37:42 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
15:37:42 <lambdabot> Prelude.last :: [a] -> a
15:37:52 <monochrom> eh, where is head?
15:38:31 <basti_> o0
15:38:40 <basti_> @hoogle+
15:38:41 <lambdabot> Prelude.sum :: Num a => [a] -> a
15:38:41 <lambdabot> Prelude.head :: [a] -> a
15:38:41 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
15:38:41 <basti_> maybe
15:38:44 <basti_> yep
15:42:42 <shrimpx> crap what's the command that gives you the modules a symbol is defined
15:44:13 <greenrd> @index mapM
15:44:14 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
15:44:14 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
15:44:14 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:44:30 <greenrd> :)
15:45:34 <shrimpx> totally useful for porting old crap
15:52:55 <xerox> @index unsafePerformIO
15:52:56 <lambdabot> System.IO.Unsafe, Foreign
15:53:07 <xerox> @type System.IO.Unsafe.unsafePerformIO
15:53:09 <lambdabot> forall a. IO a -> a
15:53:17 <xerox> @index random
15:53:19 <lambdabot> System.Random
15:55:29 <xerox> I never remember how to normalize the random output to a range
16:05:34 <monochrom> randomR and randomRs do ranges
16:05:49 <monochrom> and randomRIO too
16:05:56 <vininim> Random/MaxValue will give you a range from 0 to 1 =p
16:06:25 <vininim> you can then to min + (max-min)*Random/MaxValue
16:06:35 <vininim> something like that..
16:08:35 <vininim> you could do modulus too, but that would not take advantage of higher order bits entropy...
16:17:27 <xerox> *LSystem> result (2,0,"A",[('A',0,"AA"),('A',0,"BA")])
16:17:28 <xerox> "*** Exception: Prelude.(!!): index too large
16:17:28 <xerox> *LSystem> result (2,0,"A",[('A',0,"AA"),('A',0,"BA")])
16:17:28 <xerox> "*** Exception: urgh!
16:17:35 <xerox> Don't mess with unsafePerformIO.
16:24:53 * xerox cackles evilly - it weeeeeeeeerks!
16:25:24 <xerox> I still can't decide random weights, but I get different renders every time :-)
16:43:57 <stepcut> argh, I can't install ghc6-prof from sid with out uninstalling other useful stuff :(
16:44:05 * stepcut hates C++ ABI transitions
16:46:08 <Igloo> Don't use sid then
16:46:27 <stepcut> oh yeah
16:46:30 <Igloo> (although it should be fixed soon by people wanting to get the transition complete, as it happens)
16:46:49 <stepcut> though, where else is ghc6 6.4 available ?
16:47:13 <Igloo> There's also a 6.4.1 pre in H-U
16:47:32 <stepcut> hrm
16:49:41 <stepcut> three cheers for H-U
16:56:37 <xerox> http://haskell.org/gtk2hs/archives/category/cairo
16:56:40 <xerox> ^_^
16:56:50 <xerox> G'day Pseudonym!
16:57:56 <Pseudonym> G'day.
16:58:58 <luqui> what is the difference between "newtype" and "data"?
16:59:02 <xerox> I hope the choice of colors will be eye-pleasing.
16:59:22 <xerox> luqui: One thing is that the second one adds an extra closure.
16:59:33 <luqui> extra what?
16:59:41 <xerox> While the former will make an isomorphic type
17:00:03 * luqui doesn't understand
17:00:22 <luqui> is there a case where  data Foo = ... (with no "|"s)  and newtype Foo = ... will have different semantics?
17:00:24 <basti_> luqui: ololiu?
17:00:25 <Pseudonym> luqui: "newtype" is like "type", only it's compiler-checked.
17:00:31 <xerox> Maybe someone will explain it better, sorry, I'm off to bed.
17:00:31 <Pseudonym> type String = [Char]
17:00:33 <Pseudonym> vs:
17:00:37 <Pseudonym> newtype String = String [Char]
17:01:35 <luqui> mmkay, and from what I understand, the latter is used just as if I had said "data String = String [Char]"
17:01:44 <Pseudonym> Almost.
17:01:49 <Pseudonym> There's one crucial difference.
17:02:03 <Pseudonym> The "newtype" can be compiled to code that's just as efficient as "type".
17:02:14 <Pseudonym> And more efficient than "data".
17:02:27 <luqui> ahh, that doesn't really count as a difference to me
17:02:39 <luqui> but there's nothing at the language level that makes them different?
17:02:50 <Pseudonym> Yes, newtype has restrictions.
17:03:02 <Pseudonym> newtype Foo = Foo Int String -- Not allowed
17:03:13 <luqui> oh, only one arg?
17:03:13 <Pseudonym> newtype Foo = Foo (Int, String) -- This is okay, though.
17:03:15 <Pseudonym> Right.
17:03:18 <Pseudonym> And only one constructor.
17:03:26 * luqui knew that one
17:03:26 <Pseudonym> newtype Foo = Foo Int | Bar Float -- Also not allowed
17:03:44 <luqui> okay, fair enough
17:03:46 <Pseudonym> The point is that newtype has much the same restrictions as "type".
17:03:46 <luqui> thanks
17:03:55 <Pseudonym> Oh, you can do a one-argument record, though.
17:04:06 <Pseudonym> newtype Foo = Foo { getInt :: Int } -- This is fine
17:04:13 <luqui> that seems reasonable
17:04:40 <Pseudonym> Basically, newtype has all of the restrictions which make it _possible_ to implement as efficiently as a type synonym.
17:04:52 <Pseudonym> But it has none of the restrictions of a simple type synonym.
17:04:59 <luqui> gotcha
17:05:14 <luqui> I wonder why this couldn't be taken as a plain optimization
17:05:34 <luqui> that is, why you couldn't just have the compiler optimize datas with one constructor with one argument to be a synonym
17:05:48 <Pseudonym> Ah.
17:05:57 <Pseudonym> In a strict language, there would be no difference.
17:06:05 <Pseudonym> But in a lazy language, there's a crucial difference.
17:06:13 <Pseudonym> Consider: data Foo = Foo Int
17:06:27 <Pseudonym> Then bottom :: Foo is not the same as Foo (bottom :: Int)
17:06:58 <luqui> aa soo
17:08:06 <Pseudonym> If you ever find yourself wondering why there's a reason for some bizarre rule in Haskell, it's probably because of lazy evaluation.
17:08:24 <Pseudonym> And bottom values in particular.
17:08:25 <luqui> that's pretty much the only bizarre rule I've come across
17:08:40 <luqui> if you have other examples, I'd be delighted to hear
17:08:47 * luqui enjoys learning corner-cases of languages
17:08:56 <Pseudonym> @wiki MonomorphismRestriction
17:08:57 <lambdabot> http://www.haskell.org/hawiki/MonomorphismRestriction
17:09:05 <Pseudonym> That is the _most_ bizarre rule.
17:11:10 <luqui> oh, I had heard of that
17:11:24 <luqui> it kinda makes sense, kinda doesn't
17:11:46 <luqui> I've been both a language implementor and a combinator implementor (but not for Haskell), so I can see the problem from both sides :-)
17:11:57 <Pseudonym> :-)
17:12:09 <Pseudonym> Well, it kinda makes sense, but it kinda doesn't.
17:13:34 <Pseudonym> At the moment, I think the argument is mildly in favour of keeping it, but allowing it to be turned off.
17:13:51 <luqui> what does that buy you?
17:13:55 <Pseudonym> If scoped type variables ever get into the language, then I'd argue in favour of turning it off, but allowing a warning.
17:14:22 <Pseudonym> What it buys you is some ugly overloading-related performance surprises.
17:14:41 <luqui> okay, so it's a performance issue, too
17:14:54 <luqui> I thought that it was mostly "because it's hard to implement that in this type system"
17:15:56 <Pseudonym> @type let { foo :: Int -> Double; foo = undefined; bar :: Integer -> Double; bar = undefined } in \xs -> let l = Data.List.genericLength xs in foo l + bar l
17:15:58 <lambdabot> bzzt
17:16:43 <Pseudonym> Errr... not a good example.
17:17:10 <Pseudonym> But certainly, I think the monomorphism restriction violates the principle of least surprise.
17:18:01 <luqui> probably
17:18:29 <luqui> the "that case isn't common enough" argument doesn't convince me anymore
17:18:29 <Igloo> But do you have a good alternative which still allows   let [(i, xs')] = read xs in (i, xs') :: (Int, String)    work?
17:18:53 <xerox> Pseudonym: you missed an 'xs'
17:18:53 <xerox> I couldn't resist an explanation :-)  I ought to go do bed really.
17:18:55 <luqui> because when you program generically, you end up wanting consitency, not usefulness
17:19:49 <Igloo> Err, "reads" that is
17:38:28 <stepcut> hrm, my program is spending a majority of its time in the 'lines' function :p
17:38:37 <stepcut> that could be hard to optimize
17:45:51 <luqui> would it be worthwhile to switch to packedstrings
17:45:56 <luqui> you might get better cache locality that way
17:57:22 <ozone> stepcut: try using dons's new fastpackedstring package if you're doing heavy string processing
18:23:06 <lispy_> @wiki
18:23:06 <lambdabot> http://www.haskell.org/hawiki/
18:23:26 <lispy_> shapr: what is the license that new wiki content should be under?
18:32:04 <humasect> @index depthFunc
18:32:05 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment, Graphics.Rendering.OpenGL.
18:32:05 <lambdabot> GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
18:40:58 <dons> ghc comment of the day: -- freeze the puppy
18:41:01 <dons> line 89 of utils/PrimPacked.lhs
18:47:02 <Pseudonym> I think our implementation is from ARMan.
18:47:24 <Pseudonym> Unfortunately, my copy of ARMan is at home.
18:47:27 <Pseudonym> I'll check the source.
19:07:11 <lispy_> @hoogle a -> [a]
19:07:12 <lambdabot> Prelude.repeat :: a -> [a]
19:07:12 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
19:07:12 <lambdabot> Random.randoms :: (Random a, RandomGen b) => b -> [a]
19:24:46 <lispy_> here is a some what weird thing you can do with lists: http://www.haskell.org/hawiki/CodeExamples#head-c926349e876dca4d1324036fe67a6eb1fe7afb3c
19:24:53 <lispy_> lists are numbers!
19:41:27 <TheHunter> lispy_, nice.
19:42:28 <humasect> @index fromIntegral
19:42:29 <lambdabot> Prelude
19:42:41 <TheHunter> why not newtype the list? then you can have a show instance.
19:42:59 <lispy_> TheHunter: newtype would make a lot of sense in other ways
19:43:07 <lispy_> TheHunter: but i have no reason for not using it
19:43:25 <lispy_> TheHunter: it was inspired by the following type
19:43:29 <lispy_> @type (:0)
19:43:30 <lambdabot> forall a. (Num [a]) => a -> [a]
19:43:58 <lispy_> IMO, that should give a type error, but then realized that Num [a] would be a fun thing to have
19:44:00 <TheHunter> sometimes you want that to be a type error.
19:44:41 <humasect> @intex Word32
19:44:42 <lambdabot> Data.Word, Foreign, Graphics.SOE
19:44:51 <lispy_> right now i'm trying to figure out a way to specify arbitrary groups/rings/fields
19:45:23 <TheHunter> oh, |polyapply :: (Num a) => [a] -> a -> a| would map a list to a polynomial (considered as a function)
19:45:35 <jgrimes> ok, are there any compilers written for smaller languages (like really small) in haskell?
19:46:21 <lispy_> TheHunter: i wrote a naive version of polyapply, but what do you have in mind?
19:46:45 <TheHunter> lispy_, you need to define classes for each of them. Someone has written something called 'NumericPrelude', but I don't know how good that is.
19:46:52 <TheHunter> @google numericprelude
19:46:54 <lambdabot> http://cvs.haskell.org/darcs/numericprelude/
19:47:26 <lispy_> hm... 404
19:47:32 <TheHunter> flipping the arguments of polyapply.
19:48:24 <lispy_> so you're emphasizing the following? polyapply :: (Num a) => [a] -> (a -> a)
19:48:41 <TheHunter> seems to make more sense to me.
19:48:44 <lispy_> that's a good idea
19:49:50 <lispy_> I was thinking something like |class Group a b where| so that the group operation depends on the instance of the group.
19:50:07 <lispy_> would I need fun. deps for that?
19:50:17 <TheHunter> what's wrong with class Group a.
19:50:36 <lispy_> then Group Int would all have the same group operation
19:50:48 <lispy_> there would be just one group of ints
19:50:59 <jgrimes> I'll take that as a no one currently active knows
19:51:00 <jgrimes> :p
19:51:14 <lispy_> jgrimes: what is a small language?
19:51:19 <lispy_> jgrimes: like C?
19:51:22 <TheHunter> oh, sorry.
19:51:31 <TheHunter> you could take a look at lamdabot's lambda module.
19:51:47 <TheHunter> @lambda (\x -> x x) id 4
19:51:49 <lambdabot> 4
19:51:59 <lispy_> jgrimes: i wrote a translator from an embedded language to procmail
19:52:06 <lispy_> jgrimes: http://www.codersbase.com/autoproc
19:52:12 <TheHunter> @version
19:52:14 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
19:52:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:52:24 <jgrimes> I'll check that out
19:52:46 <jgrimes> but yeah, like C
19:52:57 <TheHunter> lispy_, that's a general problem with type classes, you can only have one for each type.
19:53:12 <lispy_> yeah, i've been thinking about writing a C compiler in haskell for the learning experience, but i've yet to take the time
19:53:21 <TheHunter> of course you can work around that with fundeps like you mentioned, but it ain't pretty.
19:53:31 <jgrimes> if you decide to take that up let me know :P
19:53:51 <lispy_> jgrimes: why are you interested in it?
19:53:58 <lispy_> jgrimes: i'm just curious
19:53:59 <TheHunter> you might be better of treating groups as a datatype as in data Group a = { unit :: a, op :: a -> a -> a, inv :: a -> a }
19:54:15 <lispy_> TheHunter: oh, good point
19:54:26 <jgrimes> lispy: just interested in compiler design in general, and I've been learning haskell recently so I thought it would be interesting
19:54:39 <lispy_> jgrimes: okay, then you're the same as me
19:54:50 <lispy_> jgrimes: take a look at parsec
19:55:02 <jgrimes> alright
19:55:03 <lispy_> jgrimes: it's a parser combinator library
19:55:10 <jgrimes> ah, ok
19:55:23 <TheHunter> oh, sorry lambdabot's @lambda is of course an interpreter.
19:55:47 <lispy_> jgrimes: i have an unfinished lisp interpreter in haskell, http://www.codersbase.com/helisp that uses parsec
19:56:33 <jgrimes> oh nice
19:56:45 <lispy_> jgrimes: you won't say thta when you see my coding style :)
19:57:02 <lispy_> helisp is really messy, but i haven't taken any time to clean it up
19:57:06 <jgrimes> lispy: hopefully it isn't -that- bad :p
19:57:28 <lispy_> jgrimes: well, it's fairly pedestrian so depending on where you are in learning haskell that could help
19:58:52 <luqui> TheHunter, re: a general problem with type classes, it makes sense though.  You can solve the problem by allowing type classes to be parameterized on things that aren't types
19:59:09 <jgrimes> lispy: alright, well, I'll check it out :D
19:59:16 <luqui> instance Group Foo (+);  instance Group Foo (*)
19:59:22 <humasect> there are a lot of number types. which should i investigate if i want to represent one second as 1.0, 450 ms as 0.450, etc
20:00:27 <TheHunter> luqui, like what?
20:01:07 <dons> fast code lesson of the day: peekByteOff uses less space and time than peekElemOff
20:01:12 <luqui> like functions
20:01:23 <luqui> as I just wrote
20:01:35 <TheHunter> i didn't get what you wrote.
20:02:01 <luqui> well, the mathematical definition of a group is (Set, Operator) with certain properties
20:02:07 <luqui> you can't just pretend it's just the set
20:03:06 <TheHunter> yeah, mathematicians just copy the Group type class to get a type class AdditiveGroup with method (*)
20:03:21 <TheHunter> err, (+)
20:04:04 <luqui> right, but you could have a "class Group set op"
20:04:19 <luqui> then you don't have to multiply entities to have AdditiveGroup and MultiplicitaveGroup
20:04:31 <luqui> (as much sense as MultiplicitaveGroup makes)
20:05:01 <TheHunter> isn't that basically whay lispy_ suggested?
20:05:13 <luqui> maybe, I came into the discussion late
20:05:49 <TheHunter> the problem is, all your ops need phantom parameters now, so you might as well introduce a datatype.
20:07:37 <TheHunter> and then there is the implicit configurations approach
20:08:09 <TheHunter> that parametrizes the numerical datatype.
20:08:28 <luqui> implicit configurations?
20:08:50 <TheHunter> @google oleg implicit configurations
20:08:51 <lambdabot> http://okmij.org/ftp/Haskell/types.html
20:08:55 * SamB_XP wonders how to read what comes after a zlib-compressed stream...
20:10:11 <SamB_XP> ... in any language higher-level than C with decent byte-array support
20:10:37 <SamB_XP> (or even byte list! just so long as it is 8-bit clean)
20:11:08 <dons> SamB_XP, what do you want to read?
20:12:33 <SamB_XP> oh, I'm wondering how ADRIFT stores multimedia files...
20:13:35 <SamB_XP> I suppose maybe the header tells something about that sort of thing...
20:13:57 <dons> if you're trying to read zlib compressed data, you might want to use varients of the gzReadFile functions in FastPackedString. or possibly just use the byte array data type
20:16:27 <SamB_XP> I would just bring up the ADRIFT runner in ollydbg, but I already tried that, and it turned out to be compiled to VB6 p-code...
20:17:16 * dons backs away slowly
20:17:44 <SamB_XP> do I sound crazy?
20:18:32 <dons> nah ;)
20:20:05 <SamB_XP> you just scared of VB and/or p-code?
20:20:28 <dons> yes.
20:20:37 <SamB_XP> yeah, me too
20:22:05 <SamB_XP> especially since there don't seem to be any decent freeware p-code disassemblers for vb 5/6 p-code
20:22:37 <SamB_XP> or any half-decent source-included ones, either
20:25:02 <SamB_XP> there is an open-source ADRIFT interpreter (well two actually, one in Java and the other in C), but that just discards everything after the ZLib-compressed data...
20:26:11 <SamB_XP> oh well, at least now I know that if I get stuck in one of those ADRIFT games I can just dump the textual stuff...
20:27:37 <SamB_XP> the C-based interpreter (SCARE) also doesn't seem to use the header for anything...
20:31:05 <SamB_XP> its easy to see why the script is ZLib compressed -- it is not pretty and would be easy to mess up by editing it manually...
20:31:59 <SamB_XP> it reads like a binary format, only textual
20:32:21 <SamB_XP> and not anything like PNG or IFF, either.
20:55:01 <luqui> what's an example of a function that uses the "Ord" (other than, say, min)
20:55:55 <Lemmih> @docs Data.List
20:55:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.List.html
20:56:32 <luqui> hmm, sort is a good example
20:58:39 <Cale> also, everything in Data.Set, and Data.Map
20:59:18 <Cale> since you need to be able to order your data in order to be able to efficiently implement sets and finite maps by trees
20:59:40 * Lemmih is having a hard time convincing GHCi to optimize his code.
21:01:42 <Cale> Lemmih: I don't think it will, unless you compile it to .o with GHC first.
21:02:28 <Lemmih> Cale: I'm working on the source of GHC.
21:03:04 <Cale> Lemmih: oh :)
21:03:32 <Lemmih> Got inlining and the primop rewriting rules enabled but it's just not enough.
21:10:16 <luqui> where is the chanlog for this channel?
21:10:27 <luqui> @log
21:10:29 <lambdabot> Maybe you meant: moo msg yow
21:10:36 <luqui> no, I really didn't :-)
21:10:38 * Lemmih points at the topic.
21:11:06 <luqui> Oh, it was a little hard to find in there
21:11:10 <luqui> okay, I'm lazy
21:15:45 <Cale> @yow
21:15:46 <lambdabot> Jesus is my POSTMASTER GENERAL ...
21:19:39 <lispy_> import qualified ParsecToken as P
21:19:45 <lispy_> what is that module really called these days?
21:20:15 <lispy_> @doc Text.ParserCombinators.Parsec.Token
21:20:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text.ParserCombinators.Parsec.Token.html
21:21:48 <lispy_> @index TokenParser
21:21:49 <lambdabot> Text.ParserCombinators.Parsec.Token, Text.ParserCombinators.Parsec.
21:21:49 <lambdabot> Token
21:22:35 <lispy_> @index makeTokenParser
21:22:35 <lambdabot> Text.ParserCombinators.Parsec.Token
21:22:39 <lispy_> hmm...
21:23:39 <lispy_> @index emptyDef
21:23:40 <lambdabot> Text.ParserCombinators.Parsec.Language
21:34:58 <FrederikEaton> lispy_: you know you can privately message lambdabot, right
21:46:38 <humasect> hm good info.
22:09:08 <lispy_> FrederikEaton: is lambdabot set to unfiltered?
22:18:09 <dons> yes
22:28:14 <lispy_> ah, nice
22:28:24 <TheHunter> unfiltered?
22:28:53 <dons> freenode crap
22:29:23 <TheHunter> no more words necessary.
22:37:53 <newsham> hih.
22:39:03 <newsham> i'm a complete newbie.  i want to write some poker code to get some practice.   I would like something like "data Value = 2|3|4|...|Q|K|A"
22:39:15 <newsham> it appears that thhis isnt allowed due to the integers.. *sigh8
22:39:36 <newsham> any awy around this or am I going to have to use strings or obtuse names to represent values?
22:39:49 <dons> data Value = Two | Three | Four .. Queen | King | Ace
22:39:54 <dons> more readable anyway
22:40:01 <newsham> *sigh* thanks
22:40:11 <newsham> (I disagree about readability :)
22:40:15 <dons> overriding integers would be generally confusing
22:40:31 <Lemmih> Make Value an instance of Num.
22:41:03 <dons> good idea. then at least you get the operations I think you're looking for.
22:41:04 <Lemmih> (if you don't care about type-safety, that is)
22:41:10 <newsham> [Kd] [Th] [2s]  is preferable to   [King Diamonds] [Ten hearts] ...  when showing a hand in ascii
22:41:40 <dons> oh, define your own show instance
22:41:43 <newsham> ok, so what do i do about TJQKA ?
22:42:37 <lispy_> i think you want to make it an instance of Ord also so that you can sort cards
22:42:41 <dons> what are the operations you'd like to perform on this Value type?
22:43:05 <newsham> probably sorting and equality testing only
22:43:13 <dons> eq, compare, sorting, adding them, showing them as strings?
22:43:20 <newsham> and shhowing.  no adding.
22:43:36 <dons> so derivie Eq, Ord. write an instance Show Value where King = "K" for example
22:44:04 <newsham> ok, thhat should keep me busy for a little bit *flipping around in tutorial* :)
22:44:29 <lispy_> data Suit = Diamond | Hearts | ..., instance Show Suite where show Diamond = "<>"
22:45:06 <lispy_> data Card = Two Suit | Three Suit | ...
22:45:38 <Lemmih> type Card = (Value, Suit)
22:45:45 <dons>  print [One,Ace,King]
22:45:45 <dons> [1,A,K]
22:45:53 <dons> > One < Ace
22:45:54 <dons> True
22:46:11 <dons> List.sort [One,Ace,King,Two]
22:46:12 <dons> [1,2,K,A]
22:47:13 <newsham> Poker> Hearts
22:47:13 <newsham> Segmentation fault
22:47:15 <newsham> heh
22:47:26 <dons> ! what did you do?
22:47:39 <newsham> data Suit = Hearts | Spades | Diamonds | Clubs
22:47:39 <newsham> instance Show Suit where
22:47:39 <newsham> show Hearts = "h"
22:47:39 <newsham> show Spades = "s"
22:47:39 <newsham> show Diamonds = "d"
22:47:39 <newsham> show Clubs = "c"
22:48:09 <Lemmih> Oh my various gods. Does that really crash GHC?
22:48:13 <newsham> in 'module Poker whehre'
22:48:19 <newsham> hugs poker.hs
22:48:24 <dons> hugs :/
22:48:26 <newsham> then at the prompt "Hearts"
22:48:43 <lispy_> show Hearts = "<3"; show Spades = "&"; show Diamonds = "<>"; show Clubs = "%"
22:48:44 <dons> ghc is fine
22:49:12 <dons> hugs is fine two
22:49:13 <lispy_> that's what i'd use :)
22:49:14 <dons> too
22:49:21 <lispy_> er, not hugs
22:49:25 <dons> newsham, you on some weird OS?
22:49:30 <lispy_> but that set of symbols...
22:50:10 <newsham> looks like it blew its stack.. thhousands of stack frames in gdb
22:50:21 <dons> what OS?
22:50:27 <newsham> (markSnd in storage.c, self recursive0
22:50:30 <dons> what hugs version?
22:50:31 <newsham> linux fc2.
22:50:47 <newsham> ||   || Version: March 2005     _________________________________________
22:50:56 <newsham> downloaded thihs week
22:51:09 <dons> bizarre. you got ghci installed? you'll fine it more fun in the long run
22:51:19 * lispy_ puts fc2+hugs on his list of software to not use
22:51:19 <newsham> no i dont.
22:51:32 <newsham> i doubt it hahs anything to do with fc2.
22:51:42 <newsham> sorry about th edouble h's, my keyboard is acting up
22:54:43 <newsham> ahh, if I indent the "where" bits it works fine
22:57:39 <lispy_> this might be a nice way to represent it also data Suit = Heart | ...; data Face = Two | Three | ...; data Card = Card { face :: Face, suit :: Suit }
22:58:16 <lispy_> but, i think the way we talked about it earlier would give something which is more natural to workwith
23:02:19 <eckroth> \leave
23:02:22 <eckroth> ergh
23:02:54 <newsham> lispy: meaning?
23:03:08 <newsham> using a num?
23:13:30 <newsham> so a hand is five cards.  is the best way to represent this as 'data Hand = Hn a b c d e f' or is it better to make it a tuple or list (can constraints on the length be added to the type system?) ?
23:15:21 <Lemmih> An array perhaps.
23:24:42 <newsham> hmm.. isnt thhere a builtin sort function in the standard prelude somewhere?
23:24:49 <Korollary> yes, sort
23:24:56 <newsham> how do I get it?
23:25:08 <newsham> ERROR - Undefined variable "sort"
23:25:34 <Korollary> it's in List
23:26:01 <newsham> ohh blah, now its working ;)
23:26:09 <newsham> I tried importing it earlier, but I guess 3rd times the charm :)
23:26:40 <newsham> Poker> sort [ACard Two Hearts, ACard Three Diamonds, ACard Three Spades]
23:26:41 <newsham> ERROR - Control stack overflow
23:26:43 <newsham> great :)
23:27:45 <Korollary> I assume ACard is in Ord ?
23:27:51 <newsham> instance Ord Card where
23:27:51 <newsham>         (ACard v s) < (ACard v' s') = v < v'
23:28:03 <newsham> that should be the only ordering operation i need, right?
23:28:10 <Lemmih> Define 'compare' instead of '<'.
23:28:43 <newsham> that fixed it
23:28:55 <Korollary> Doesn't the suit matter in poker ?
23:29:07 <newsham> thhere is no ordering of suits.
23:29:13 <newsham> suit is significant in hand rankings
23:33:09 <Lemmih> I don't see why you can't just derive Ord.
23:33:34 <newsham> data Card = ACard Value Suit deriving Eq
23:33:38 <newsham> Suit has no Ord
23:40:15 <joelk> then, strictly speaking, the set of Cards does not have a total order, which Ord is supposed to embody. Or is that just being nit-picky?
23:41:07 <newsham> there is an ordering of values
23:41:22 <newsham> (ie. you can order your cards by value)
23:41:41 <mwc_> newsham: really? Suit-most or Value-most?
23:42:00 <newsham> eh?
23:42:14 <mwc_> newsham: does a spade always outrank a diamond, or does it go by value first, then suit?
23:42:26 <newsham> thhere is no ranking of suits in poker.
23:42:37 <mwc_> Yah, so then the set of cards really has no total ordering
23:42:50 <newsham> you can still order cards by value.
23:43:45 <mwc_> how?
23:43:47 <newsham> as an example, lets say thaht you hahve two hands, both hands have a pair of aces and three unpaired cards.  the ordering of th unpaired cards will determine the relative rankings of the two hands
23:44:06 <newsham> ie.  AA952 vs AA854
23:44:10 <newsham> the first is better
23:44:24 <mwc_> so then you're doing a value-only ordering
23:44:26 <joelk> AA952 vs AA952?
23:44:44 <newsham> mwc; yes.
23:44:53 <mwc_> what about AA Spade(952) and AA Spade (95) Diamond (2)
23:45:08 <mwc_> er, assume the first is clubs
23:45:11 <newsham> as another example if you have  23789 all clubs vs 23789 all diamonds, its a draw
23:45:26 <newsham> mwc: identical rankings.
23:45:36 <newsham> suit never breaks ties
23:45:45 <joelk> ah! a draw! so hands don't have a total order either then...
23:46:22 <newsham> as i understand it a "partial order" has some items which have no relationship to others
23:46:32 <newsham> and a total order has relationships between all items in the set
23:46:37 <newsham> all hhands can be ranked relative to each other
23:46:40 <newsham> with draws.
23:46:46 <newsham> is this incorrect?
23:46:52 <mwc_> Right, so then it's hands that are ordered
23:46:53 <mwc_> not cards
23:47:14 <newsham> mwc; a card is a degenerate case of a hand.
23:47:21 <newsham> you can rank partial hands
23:47:25 <mwc_> ok
23:47:48 <mwc_> Well, I don't think Ord in haskell implies a strict ordering
23:47:58 <mwc_> I think as long as any two elements are Eq, Lt, or Gt, you're okay
23:48:02 <newsham> as an example, if the hands are   AAQQ9 vs. AAQQ8   you can compare the AA's first, then the QQ's first, then do a card comparison of the rest
23:48:11 <joelk> partial hands? cool.
23:48:13 <mwc_> the problem I see with treating hands as [Card]
23:48:47 <newsham> joelk; yes, for example, as you're dealing the hand you can rank the current hand to get current winner 9which in  some variations determins betting order)
23:49:10 <newsham> and you can also calculate which hhands you could make with cards to come
23:49:32 <mwc_> newsham: in general, when comparing two hands, you can look at their difference only to decide the superior one, correct?
23:49:34 <newsham> (for example, 4 of the same suit is nothing, but is close to a 5 of the same suit which is a highly ranked hand0
23:49:57 <newsham> mwc: at the end, you decide superior hand for winner.
23:50:05 <newsham> but you can do more complex analysis in the middle of the hand
23:50:20 <newsham> to determine "implied odds" (poker term)
23:50:27 <mwc_> ok
23:50:53 <newsham> for example you might determine that there are 8 different ways you could make a hihghly ranked hand (these are called "outs")
23:51:02 <mwc_> Seems to me that ranking hands is a Hand level operation,
23:51:08 <newsham> then decide which of those highly ranked hands are likely to win if you get them
23:51:15 <mwc_> a card is a more naive bit of data
23:51:30 <newsham> mwc: perhaps.
23:51:43 <newsham> with the view thhat a card is a degenerate form of a hand
23:51:50 <newsham> i guess all ordering can be done in the hand class
23:52:14 <mwc_> is it though? for instance, is the list of remaining, undealt cards, a hand?
23:52:27 <newsham> it is not.
23:52:47 <mwc_> It seems to me that a card isn't really a hand until it's been "blessed" in some way
23:54:01 <newsham> *nod*
23:54:22 <newsham> (you can sort the deck too, though :)
23:54:27 <newsham> but thahts not a meaningful poker operation
23:57:10 * mwc_ sticks to bridge
23:57:26 <newsham> :)
23:57:52 <newsham> ok, next question.  i want to define types for subhands (ie. a type for a pair, a type for a full hhouse, etc)
23:58:19 <newsham> one of the types I want is "Trash".  but I want to have trash items of multiple lengths (from one to five cards0
23:59:23 <newsham> i know hohw to make a list, but can i just make alternations?
