00:02:41 <boegel> hey Itkovian ;)
00:03:10 <Itkovian> hi boegel
00:05:05 <monstre> anyone willing to answer a few questions from a clueless newbie?
00:05:19 <dcoutts> try us
00:06:13 <monstre> can you recommend a tutorial or book to learn the language?
00:06:13 <astrolabe> just ask monstre :)
00:06:35 <vikasg> monstre, try the "Yet another Haskell tutorial"
00:06:35 <monstre> because this here gentle introduction is anything but...
00:06:42 <vikasg> monstre, I know :)
00:06:51 <dcoutts> @google Yet another Haskell tutorial
00:06:53 <lambdabot> http://www.isi.edu/~hdaume/htut/
00:07:01 <astrolabe> http://www.haskell.org/soe/
00:07:08 <monstre> thanks, i'll look for it
00:08:27 <dcoutts> oh yes, the SOE book is a good tutorial but it's not available for free online
00:08:41 <astrolabe> Also this is a useful page: http://www.haskell.org/learning.html
00:09:13 <monstre> thanks everyone
00:09:42 <Itkovian> seen the icfp results?
00:10:12 <dcoutts> Itkovian, I was here when Heffalump relayed the results live :-)
00:10:20 <Itkovian> heh
00:11:11 <dcoutts> the Igloo+Heffalump+dcoutts team came 7th out of 161 teams
00:12:07 <monstre> another question, are tail-recursive functions exucuted in constant space in Haskell?
00:12:26 <dcoutts> usually yes
00:12:29 <astrolabe> monstre: I think they are in GHC
00:12:38 <monstre> so it's not guaranteed then?
00:13:02 <dcoutts> it's a feature of the language implementation, not the language specification
00:13:31 <boegel> Itkovian: Haskell and Dylan ruled the contest
00:13:47 <boegel> never heard of Dylan though
00:14:13 <aleator> Isn't dylan CLOS with syntax?
00:14:21 <dcoutts> boegel, though there were 5 C/C++/Java entries in the top 10 teams
00:14:24 <Itkovian> Dylan is a bit 90210
00:14:48 <monstre> Dylan is basically Lisp in infix clothes, no?
00:15:13 <boegel> dcoutts: how many Haskell ?
00:18:44 <monstre> one last question if you don't mind: can you explain why the monomorphism restriction is necessary?
00:19:22 <dcoutts> boegel, 3 in the top 10
00:19:30 <dcoutts> and 2 ocaml
00:20:17 <boegel> dcoutts: cool
00:20:49 <dcoutts> ok actually it was top 11: 3 Haskell, 2 ocaml, 2 C, 2 C++, 1 Java, 1 Dylan
00:21:25 <boegel> so Haskell wins ! w00 ! :P
00:21:34 <dcoutts> for the second year running!
00:22:52 <monstre> oh well, thanks for your help...
00:23:36 <vikasg> monstre, you ask about 'monomorphism restriction' (whatever that is) and claim to be a newbie? :)
00:23:57 <monstre> well, a Haskell newbie anyway
00:24:07 <sethk> hey, I know about the monorphism restriction.  :)   I read it here, yesterday.  :)
00:24:19 <dcoutts> monstre, it's to do with expected performance due to sharing
00:24:32 * vikasg looks for it on the wiki
00:24:38 <monstre> I ask because I noticed there's an option to turn it off in GHC and it seems to work just fine...
00:25:08 <dcoutts> but you might find the performance confusing
00:25:17 <monstre> what horrible things can happen if you just turn it off?
00:25:25 <dcoutts> the question is should a value like so:
00:25:32 <dcoutts> let blah = ....
00:25:38 <dcoutts> ie a non-function value
00:25:49 <dcoutts> be re-evaluated each time it is used?
00:26:01 <dcoutts> now normally you would think not, right?
00:26:07 <monstre> right
00:26:09 <dcoutts> it should be computed once and shared
00:26:22 <dcoutts> however what if that value is actually polymorphic?
00:26:29 <dcoutts> ie it can be used at several types
00:26:57 <dcoutts> then they can't all be shared
00:27:32 <dcoutts> so the momorphism restriction stops you accidentaly writing very ineffecient code
00:27:54 <dcoutts> I think you can get around it by writing an explict type for the value
00:28:12 <monstre> I know, it's just a nuisance is all...
00:28:29 <monstre> albeit, perhaps a necessary one
00:29:30 <dcoutts> http://www.haskell.org/hawiki/MonomorphismRestriction
00:29:52 <monstre> thanks
00:36:20 <earthy> hm. just saw that Haskell is the programming tool of choice for discriminating hackers for the second year in a row
00:36:50 <earthy> 'yaay' :P
00:36:59 <autrijus> Haskell++ # yay
00:37:02 <dcoutts> oh yes :-)
00:37:11 <autrijus> although the dylan hacker team is consistently very impressive
00:37:17 * earthy nods
00:37:17 <dcoutts> yes
00:38:26 <autrijus> so there is at least _some_ merit in incremental soft typing :)
00:38:50 <earthy> well...
00:38:59 <earthy> I wouldn't quite directly state htat
00:39:14 <earthy> maybe it's due to dylan having a similarly concise and powerful syntax
00:39:24 <autrijus> sure
00:39:58 <dcoutts> autrijus, heracy! heracy! full static typing is the one true way to enlightenment!
00:40:00 <autrijus> sorry, my brain was narrowly focused on typing issues during this conference :)
00:40:02 <dcoutts> ;-)
00:40:09 <autrijus> dcoutts: tell that to emeijer :)
00:40:19 <dcoutts> oh?
00:40:20 * earthy laughs
00:40:35 <earthy> plus, it's spelled heresy
00:40:40 <dcoutts> heh, oops :-)
00:40:58 <earthy> bring! the comfy chair!
00:41:03 * dcoutts crawls back under his rock
00:41:16 <dcoutts> nooo! not the comfy chair!
00:58:16 <dons> @where hide
00:58:18 <lambdabot> http://www.haskell.org/hawiki/hIDE
01:04:45 <Lemmih> dons: "How do we we to ghc-api"?
01:05:00 * dons fixes
01:06:11 <Lemmih> Hi SyntaxNinja.
01:07:53 <SyntaxNinja> hi Lemmih
01:10:00 <Lemmih> How's Estonia?
01:10:09 <dons> @seen ndm
01:10:10 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 6 days, 9 hours, 8
01:10:10 <lambdabot> minutes and 54 seconds ago, and I have missed 1 minute and 49
01:10:10 <lambdabot> seconds since then.
01:10:31 <dons> is ndm in tallinn anyone know?
01:16:06 <humasect> can hIDE's core maybe not fail when looking for ~/.ghc/package.conf ?
01:16:20 <dcoutts> humasect, that'd be good :-)
01:16:38 <dcoutts> feel free to darcs send us a patch
01:17:00 <dcoutts> hmm, maybe gour was right about starting a bug/feature tracking system :-)
01:17:03 <Muad_Dibber> Just (Not Fail) | Nothing
01:17:20 <humasect> ok i'll.
01:17:40 <dons> yeah, i want to turn on Igloo's bark for this
01:17:54 <dons> i've got the code here, but am a bit short of time to send it up atm :}
01:17:55 <boegel> is the latest TMR issue out yet ?
01:18:07 <dons> s/send/set/
01:18:15 <dcoutts> bark?
01:18:22 <humasect> rough?
01:18:23 <dons> dcoutts, cause we have so many testers.
01:18:38 <dons> bark, hmm, bug arkive?
01:18:38 <dcoutts> yes we've got a surplus of testers :-)
01:18:38 <boegel> apperently not...
01:18:45 * boegel summons shapr 
01:18:50 <dcoutts> dons, url?
01:18:53 * Muad_Dibber didnt know boegel was a mage
01:19:00 <dons> Igloo, ping
01:19:05 <dcoutts> @summon shapr
01:19:05 <dons> @seen Igloo
01:19:06 <lambdabot> Unknown command, try @listcommands.
01:19:06 <lambdabot> Igloo is in #haskell. Last spoke 17 hours, 39 minutes and 11 seconds
01:19:06 <lambdabot> ago.
01:19:14 <dcoutts> @todo
01:19:16 <lambdabot> 0. SamB: A way to get multiple results from a google search
01:19:16 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
01:19:16 <lambdabot> 2. SamB: stop mangling long urls
01:19:16 <lambdabot> 3. dons: improve formatting of @dict
01:19:16 <lambdabot> 4. dons: write Haskell Manifesto
01:19:16 * dons looks around
01:19:17 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @
01:19:19 <lambdabot> foo across lines
01:19:21 <lambdabot> [8 @more lines]
01:19:33 <dcoutts> ah, @get-shapr
01:19:50 <dcoutts> which would be subsumed into a general @summon command :-)
01:20:18 <Lemmih> @more
01:20:19 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
01:20:19 <lambdabot> 7. TheHunter: @type 1 :: Int
01:20:19 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.
01:20:19 <lambdabot> It would be nice if it also let you find functions in the given
01:20:19 <lambdabot> module that use a type.
01:20:21 <lambdabot> 9. dons: Implement @whatis
01:20:23 <lambdabot> 10. dcoutts: implement @cool list, as a clone of the @todo(-add)
01:20:25 <lambdabot> commands
01:20:38 <dons>     Bark: Bug And Request Keeper
01:23:00 <boegel> Muad_Dibber: better watch it, or I'll turn you into a frog
01:24:08 <dons> boegel, this isn't #haskell-blah, your powers are useless here ;)
01:24:10 <humasect> it's strange, it looks for /package.conf and i have HOME set.
01:26:40 <boegel> dons: :)
01:26:51 <SyntaxNinja> @wiki
01:26:52 <lambdabot> http://www.haskell.org/hawiki/
01:27:22 <SyntaxNinja> Lemmih: estonia is pretty cool!
01:27:32 <ozone> SyntaxNinja: you're there?
01:27:53 * Lemmih would give his left ear tip to be at ICFP.
01:27:53 <Muad_Dibber> boegel: then i would get kissed by a prinses :D
01:30:51 <dons> ozone, lots of people are here :)
01:31:14 <dons> ozone, and autrijus is handing out perl tshirts like candy :D
01:31:47 <SyntaxNinja> hi ozone. yeah. i'm at icfp.
01:32:57 <Muad_Dibber> damn
01:33:02 <Muad_Dibber> i would love to have a perl tshirt :P
01:33:05 <humasect> ahh i'll do the exception when i wake up
01:33:07 <ozone> dons: :(
01:33:23 <Muad_Dibber> but i cant do anything with a nextra left ear tip Lemmih :P
01:36:22 <ozone> SyntaxNinja: nice nice
01:36:49 * SyntaxNinja is sitting next to jaffacake
01:49:56 <earthy> what would one want with a perl t-shirt?
01:50:12 <earthy> perl is not the language of choice for discerning hackers...
01:50:22 <Lemmih> Voodoo comes to mind.
01:51:56 <Heffalump> a pugs T-shirt is great.
01:52:15 <dons> yeah. they're pugs tshirts. implemented in the language of choice ;)
01:52:41 <dons> "Powerered by Haskell, the language of choice for discerning hackers"
01:53:02 <mauke> "Powered by PhD"
01:53:24 <earthy> okay, now I want to see the pugs shirt. ;P
01:53:40 <dons> it also has an spj-reference in the artwork.
01:55:30 <SyntaxNinja> this should have the tshirts maybe, but seems to be down right now.  is that the same shirt? http://www.cafepress.com/pugscode
01:56:17 <earthy> hm. damn. why do they think it is nighttime and therefore a good time to update.
01:56:22 <earthy> it's like 11 am already
01:56:48 <dcoutts> it's 5am over on the USA east coast
01:56:54 * earthy knows
01:57:02 <earthy> i.e. 2 am on the west coast
01:57:10 <dcoutts> you're right, it's silly
01:57:17 <earthy> but it's so *frigging* us-centric
01:57:25 <dcoutts> indeed
01:57:29 <earthy> don't they realise they have customers worldwide? :P
01:57:31 <dcoutts> grrr
01:57:55 <PeterK> tell them the time to update that will make them the most money
01:58:46 <SyntaxNinja> ar ethey always downn at night?
01:58:46 <earthy> um.
01:58:52 <dcoutts> who needs downtime anyway?
01:59:01 <earthy> no, I don't think so. it's obviously scheduled outage
01:59:09 <earthy> probably a backend upgrade
02:03:24 <Heffalump> dons: ndm is in Tallinn, yes.
02:04:46 <[Blownose]> if i have something like this    [[a,b,c], [d,e,f]] and i have another list [0,15]  now i want to take the index of the lowest value in [0,15] and !! with [[a,b,c], [d,e,f]] is that possible ?
02:05:22 <adept> [Blownose]: what you have got so far?
02:07:17 <[Blownose]> nothing like that.. thats why im asking :)
02:07:24 <Igloo> dons?
02:08:21 <mauke> [Blownose]: like [[a,b,c],[d,e,f]] !! (magicStuff [0,15])?
02:08:32 <dons> Igloo, is there a demo of bark running, dcoutts wanted to check it out
02:09:01 <musasabi> morning
02:09:07 <[Blownose]> mauke yup
02:09:08 <dons> Heffalump, ok thanks. i haven't met him yet.
02:09:23 <dons> hmm, is nibro around too?
02:09:36 <Cale> or like minimum (zip [0,15] [[a,b,c],[d,e,f]]), assuming that 'a' is of a type in Ord.
02:09:55 <Igloo> There is, but I've lost it
02:10:03 <dons> ok :}
02:10:07 <Cale> [Blownose]: how should conflicts be resolved
02:10:08 <Cale> ?
02:10:25 <Cale> like what would you return if it was [7,7] instead of [0,15]?
02:10:33 <Igloo> I'll find it later
02:11:05 <[Blownose]> Cale take the first
02:11:32 <[Blownose]> and i dont want the "zero" i get with the zip function
02:11:57 <humasect> barks = haskell? ~_~?
02:12:23 <mauke> [Blownose]: what's the type of magicStuff?
02:12:31 <Heffalump> dons: I'll try to point him out. nibro is talking at HW, as you've probably noticed. I haven't seen him yet.
02:12:40 <Heffalump> (I think I've seen him before)
02:15:26 <dons> yeah, he was at icfp last year, haven't noticed him here yet. maybe he's just here for hw
02:15:36 <dons> or maybe i just haven't seen him
02:16:27 <dons> Heffalump, Igloo, any dinner plans tonight?
02:16:29 <Cale> [Blownose]: well, project back by taking the second component?
02:16:52 <Heffalump> dons: darcs discussion, probably.
02:16:53 <Cale> [Blownose]: though you probably really want sortBy
02:17:00 <Heffalump> I think David is inviting anyone interested
02:17:09 <Cale> minimumBy rather
02:17:09 <Heffalump> well, darcs discussion may be pre-dinner. Not sure.
02:17:24 <Cale> http://www.haskell.org/onlinereport/list.html
02:17:34 <[Blownose]> Cale: is it possible to remove the (0, i get in     (0,([A,B,C]) ?
02:17:38 <[Blownose]> ok
02:17:59 <dons> argh. battery dying
02:18:03 <Cale> [Blownose]: of course :) see the functions fst and snd in the prelude
02:18:15 <[Blownose]> ah :) thanks
02:18:24 <Heffalump> dons: I'll find you at lunchtime if I can
02:18:27 * Igloo finds it but discovers it's broken
02:18:31 <Heffalump> I'm in the metaocaml workshop now
02:18:33 <Igloo> So I'll fix it even later  :-)
02:18:54 <Cale> [Blownose]: you could also write snd with a lambda like (\(x,y) -> y)
02:19:36 <[Blownose]> ok.. thanks..
02:22:47 <dons> Heffalump, no worries. i've got to go an work on my talk this afternoon, so i'm running off at lunch
02:23:02 <Heffalump> 'k
02:23:37 <dons> anyone spotted a good bakery around here, btw? i'm craving some crusty bread
02:24:02 <dons> (not the chocolate shop next door ;)
02:24:31 <Igloo> chocolate > bread
02:26:23 <Heffalump> chocolate--
02:26:25 <Heffalump> bread++
02:26:32 <Heffalump> now bread > chocolate
02:26:53 * shapr yawns
02:27:09 * dcoutts yawns
02:27:12 <Igloo> Dear God, are you mutating values? In #haskell? Who let the Java hacker in?
02:27:58 <Heffalump> we're in the IRC monad, which has state.
02:28:08 <dcoutts> Igloo, you've got to forgive Heffalump, too much C compiler writing rots the brain
02:28:25 <dcoutts> and especially so if you're writing C compilers in C
02:28:45 * rep yawns
02:28:46 * Heffalump hibernates (cos it's nearly lunchtime, not cos I'm being insulted :-)
02:29:04 <Igloo> :-)
02:29:16 * dcoutts wanders off to find other people to randomly insult
02:29:46 <dcoutts> oh btw Heffalump, Igloo: you saw our teams final icpf ranking?
02:29:56 <dcoutts> it's reasonably respectable
02:30:05 <dcoutts> icpf/icfp
02:33:30 <earthy> gawd, people, you are bad
02:36:30 <Muad_Dibber> am i?
02:58:19 <Lemmih> No HWN this week?
03:03:10 <Lemmih> @seen CosmicRay
03:03:11 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 5 days, 13 hours
03:03:11 <lambdabot> and 18 seconds ago, and I have missed 1 minute and 49 seconds since
03:03:11 <lambdabot> then.
03:03:21 <ProfTeggy> G'day all.
03:03:26 <Lemmih> Hi ProfTeggy.
03:08:25 * shapr boings
03:10:22 <musasabi> I can get even some comonadic parsers to show themselves. Now to figure out a general solution.
03:10:54 * shapr cheers
03:12:48 * musasabi has started GADTs as seriously evil and vile things (but they make all kinds of nifty things possible)
03:21:08 <basti_> re
03:21:41 <shapr> whee
03:23:39 <basti_> shapr: have you seen http://www.haskell.org/hawiki/HsWebForms ?
03:23:49 <shapr> musasabi: Do you have your comonads code in an accessible repo? I want to see the updates :-)
03:24:07 <shapr> basti_: I've seen it, but I haven't had time to investigate.
03:24:25 * basti_ nods
03:24:29 <basti_> musasabi: have you seen too?
03:28:02 <PeterK> I found an implementation of the minimax algorithm with alpha-beta pruning for Haskell: http://cvs.sf.net/viewcvs.py/haskell-libs/libs/chess/Alphabeta.hs?view=markup
03:28:14 <shapr> Yeah, I know that code.
03:28:21 <PeterK> oh yeah?
03:28:57 <shapr> Yeah, delYsid wrote that a few years back.
03:29:09 <shapr> I'm the absent admin for haskell-libs.
03:29:19 <PeterK> I'd like to cannibalize it for some other free software project.
03:29:38 <basti_> delysid does haskell?
03:29:43 <shapr> basti_: He used to.
03:29:43 <sylvan> isn't that code also in the paper "Why FP matters?"
03:29:52 <musasabi> shapr: the same url as yesterday night.
03:29:54 <basti_> didnt know that
03:30:01 * musasabi looks at the wiki
03:30:11 <PeterK> why that particular code, sylvan?
03:30:20 <sylvan> don't know =)
03:30:40 <sylvan> something like that is in there, though, to show off lazy evaluation etc.
03:31:08 <shapr> PeterK: I do know that delYsid had some license problems with his sources, so you probably need to look around and see if he got that from some other place.
03:31:15 <PeterK> I did a minimax with alphabeta in C. I'd just like to do that program in Haskell now.
03:35:30 <tromp> i did one in haskell
03:36:27 <PeterK> The C function I wrote to do alphabeta is about 32 lines long. I'm pretty much new to Haskell and would have a hard time getting started on 'converting' it.
03:36:48 <musasabi> basti_: wrote about DefaultValues.
03:37:07 <PeterK> tromp: how did you do it / can I see source code?
03:37:12 <shapr> tromp: Is yours online?
03:37:26 <tromp> you can find it on my Fhourstones page
03:37:42 <tromp> ask google:)
03:37:57 * Heffalump appears
03:38:49 * basti_ has a look
03:39:12 <tromp> it uses transposition table and history heuristic
03:40:30 <PeterK> tromp: interesting, my game was also Connect Four! I'm probably attracted to it for the same reason: much easier to code than chess or other games.
03:40:34 <Heffalump> one section of my thesis is about semi-automatically deriving alpha-beta pruning
03:42:03 <tromp> you'll like my 4-in-a-row test in haskell, pterk
03:42:16 <musasabi> basti_: Could you describe your other problem in more detail, so I would understand it better.
03:42:37 <PeterK> tromp: you'll hate mine in C :)
03:43:06 <basti_> musasabi: I'll try.
03:44:41 <boegel> shapr: how's TMR5 ?
03:45:01 <shapr> boegel: getting close, I'm going to publish on the first.
03:45:32 <boegel> shapr: okay, nice
03:45:32 <PeterK> tromp: I will publish my source code soon for how I went about doing Connect Four in C. (actually C++ because it uses classes). I actually wrote the code several years ago when it was important to be able to do like 9-ply on an old machine.
03:45:37 <boegel> I was just wondering
03:46:52 <tromp> my code can do 42 ply:)
03:47:32 <tromp> actually it has solved 8x7 c4, so that's 56 ply
03:50:04 <tromp> the bitboard test for 4 in a row is just 2 lines:
03:50:07 <tromp> isWon bb = any ((/= 0) . dir) [1,height,height',height''] where
03:50:07 <tromp>   dir d = let t = bb .&. (bb `shiftR` d) in t .&. (t `shiftR` (2*d))
03:51:15 <PeterK> tromp: I am executing the C program you have on your site... how many ply does it search by default?
03:55:23 * shapr boings
03:58:33 <PeterK> hmmm, the program is taking a long time to execute
04:00:41 <aleator> How hard would it be to take hs-plugins and build a ghci-clone that displays images when some expression evaluates to one?
04:01:06 <tromp> it searches to the bitter end
04:01:21 <Heffalump> is it trivial to clone ghci with hs-plugins?
04:01:37 <Heffalump> if so, pretty easy.
04:02:02 <aleator> Well. Thats what I'm kinda asking :)
04:02:08 <tromp> to make it fast, start with 10 stones on the board
04:02:21 <Heffalump> I'll ask dons when I see him
04:02:35 <Lemmih> hs-plugins doesn't provide a bytecode compiler.
04:02:52 <Heffalump> it can evaluate arbitrary Haskell
04:03:22 <Lemmih> hs-plugins can compile some code with ghc and load the resulting object file.
04:03:44 <PeterK> The 9-ply calculation (with all 7 moves available) takes 1-2 seconds on a classic Pentium in the version I wrote (it was playable). I'm not sure what the complete calculation would take in the version I wrote.
04:04:15 <Heffalump> Lemmih: right, so maintaining state would be tricky.
04:04:22 <Heffalump> aleator: I think that's a really cool idea, though.
04:04:27 <aleator> Or would it be easier to open ghci on other end of a pipe and interpreting on the way?
04:04:30 <Heffalump> especially with a neat Pan-like image library
04:04:43 <aleator> Heffalump: Yep. Pivotal does something like it though..
04:04:49 <Heffalump> aleator: dunno what the best way to implement it is. Making hs-plugins expose ghci-like functionality would be good.
04:04:51 <Lemmih> aleator: ghc-api will hopefully provide full access to GHCi very soon now.
04:05:08 <aleator> Oh. Perhaps I'll let the idea simmer until then :)
04:05:40 <aleator> I have (quite) neat openCV wrapper I've been working with.. Does all kinds of image processing.
04:06:02 <Heffalump> openCV?
04:06:11 <aleator> Just quite tiring to type "display image" everytime something needs to be seen. And closing windows afterwards.
04:06:44 <aleator> Open Source Computer Vision Library - www.intel.com/technology/computing/opencv/
04:07:06 <Igloo> dcoutts: Yeah, could have been worse  :-)
04:07:08 <Heffalump> well, you could of course make a library whose last action was to execute some command to display the image
04:07:13 <Heffalump> and whose first action was to close the last window
04:07:17 <Heffalump> Igloo: have you seen David?
04:07:31 * Igloo tried to look at one of their simulations, but galeon ran out of RAM at turn 87
04:07:48 <Igloo> No, I was just looking for him
04:08:14 <Heffalump> he was talking to Autrijus at lunch and didn't show much sign of moving when I finished
04:08:23 <Heffalump> but I guess if he wants to find me he'll guess that here is a good place to look
04:08:27 <aleator> Heffalump: But it would be much neater to have images appear in the repl :)
04:08:36 <Heffalump> aleator: oh, inline. right.
04:08:41 <Heffalump> that would rock, yes
04:08:48 <Heffalump> (as an option)
04:09:24 <alar> congratulations to the community
04:10:11 <basti_> where in the ghc documentation is the description of record syntax?
04:12:08 <alar> Haskell is the language of choise for discriminating hackers
04:12:08 <dcoutts> aleator, Pivotal seems to be exactly what you're looking for, ghci like with graphics output
04:12:23 <dcoutts> @where Pivotal
04:12:24 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal
04:13:20 <dcoutts> basti_, it's not in the ghc docs, it's in the Haskell language docs/tutorials
04:13:21 <PeterK> tromp: how does the hash table work in this program?
04:13:29 <basti_> dcoutts: ohh.
04:14:02 <SyntaxNinja> alar: thanks :)
04:14:09 <SyntaxNinja> <--- is at the conference now
04:14:40 <SyntaxNinja> the guy who won is wondering around trying to figure out a way to charge his laptopo
04:15:16 * earthy grins
04:15:18 <alar> SyntaxNinja: will someone publish the sources of winning bots?
04:15:19 * SyntaxNinja just plugged it in
04:15:23 <earthy> how about plugging it in? :)
04:17:08 <SyntaxNinja> alar: I should think so, but not sure. I'll ask him if he comes over here
04:17:20 <SyntaxNinja> actualloy, I can see the Haskell 1st place chatting w/ the Dylan 2nd place right now :)
04:17:31 <alar> wow!
04:17:45 <SyntaxNinja> then david roundy walked in the door
04:18:06 * Heffalump spies David
04:19:30 * SyntaxNinja sees Heffalump
04:19:39 <tromp> simply stores scores of already solved positions
04:22:03 <PeterK> does it do reversal along the vertical axis? (i.e., transpose left and right) ... might be useful for the 'solve everything' case.
04:22:27 <tromp> yes, it normalizes left-right symmetry
04:22:32 <PeterK> nice
04:22:58 * SyntaxNinja escapes last session &
04:22:58 <PeterK> 1479113766 pos / 588383 msec = 2513.9 Kpos/sec
04:23:04 <beelsebob_> @hoogle [a] -> a -> [a]
04:23:05 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
04:23:05 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
04:23:05 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
04:25:08 <tromp> is that for solving the game?
04:25:36 <tromp> ah yes
04:27:47 <earthy> okay, what I gather Dylan has most of the advantages of type inference and type checking as well
04:27:53 <earthy> 'that explains'
04:27:54 <earthy>  :P
04:30:32 * shapr yodels
04:31:02 * beelsebob_ prods shapr with a sharp stick
04:31:03 <PeterK> Okay, I'm now running the .hs compiled with ghc -O
04:31:21 <tromp> expect a slowdown of 20-60 :9
04:31:32 <dcoutts> @seen poetix
04:31:33 <lambdabot> I saw poetix leaving #haskell-blah and #haskell 20 hours, 23 minutes
04:31:33 <lambdabot> and 36 seconds ago.
04:31:53 <PeterK> is that less time or more time to finish?
04:31:54 <alar> what is #haskell-blah?
04:32:13 <tromp> much more
04:32:24 <PeterK> oh :/
04:33:28 <PeterK> why do you think it takes longer?
04:33:55 <tromp> ghc doesn't optimize well:(
04:34:11 <PeterK> is ghc the best optimizing compiler for Haskell?
04:34:13 <tromp> produces horrible 64 bit code
04:34:22 <PeterK> eww... I am on a 32-bit machine.
04:34:40 <tromp> i mean code dealing with 64-bit inst
04:34:48 <tromp> ints
04:35:30 <PeterK> is there a better compiler for optimization of Haskell, or even a limited subset of Haskell? if so , what?
04:35:51 <dcoutts> PeterK, jhc?
04:35:56 <dcoutts> @where jhc
04:35:57 <lambdabot> http://repetae.net/john/computer/jhc/
04:36:53 <tromp> i don't expect jhc to be any faster than ghc on fhourstones
04:41:36 <rep> fhourstones?
04:42:30 <alar> it seems that I don't understand arrows right from the beginning
04:42:35 <alar> http://www.haskell.org/arrows/ states: -- Each function may be treated as a computation.
04:42:35 <alar> What's the difference between function and computation?
04:45:13 <dblhelix> alar: a computation is a more general concept
04:45:26 <earthy> i.e.: a computation can have side-effects
04:45:29 <earthy> functions can not
04:45:35 <alar> IO-like stuff?
04:45:45 <dblhelix> alar: f.i.
04:45:53 <earthy> state-updating stuff
04:46:00 <autrijus> ST-like stuff
04:46:16 <alar> ah, I seem to understand now
04:46:20 <tromp> a computation is a sequence of computational steps
04:47:39 <dblhelix> though, in the context of arrows, sequencing is not the only way to combine computations
04:48:11 <ibid> i usually like to say "program" instead of "computation"
04:48:17 <alar> looks like imperative approach
04:48:52 <dblhelix> alar: possibly a functional approach to imperative programming, if you will
05:01:24 <ProfTeggy> Here is the converse: an imperative approach to functional programming ;-) http://www.cs.bris.ac.uk/~henkm/f2c/
05:01:32 <ProfTeggy> Interesting book.
05:02:07 <dblhelix> doesn't the boost library for C++ provides utilities for functional programming too?
05:02:39 <earthy> not quite yet
05:03:04 <earthy> but yes, there is a lib to be included into boost that does
05:03:28 <mauke> hmm? what about boost::lambda?
05:03:45 <dblhelix> mauke: yeah, I think that's the one I was referring to
05:04:04 <mauke> http://boost.org/libs/libraries.htm#Function-objects
05:04:39 * earthy was thinking of fc++
05:06:23 <Pistahh> hi
05:06:46 * Pistahh is new to Haskell, sorry for the lame questions
05:06:55 <basti_> Pistahh: dont be shy.
05:07:12 <Pistahh> how can I format (1,2,3) into the string "1 added to 2 gives 3" ?
05:08:02 <alar> \(x,y,z) -> show x ++ "added to" ++ show y ++ "gives" ++ show z
05:08:04 <integral> format (a,b,c) = (show a) ++ " added to " ++ (show b) ++ " gives " ++ (show c)
05:08:08 <ProfTeggy> "%d added to %d gives %d"
05:08:54 <alar> ProfTeggy: what do you mean?
05:09:18 <ProfTeggy> come again, alar?
05:09:39 <autrijus> import Text.Printf
05:09:55 <alar> thanks
05:09:59 <autrijus> printf "%d added to %d gives %d" 1 2 3
05:10:09 <alar> didn't know about the existence of Text.Printf
05:11:22 <musasabi> tromp: jhc does not yet have the optimizations necessary to be fast with 64 bit ops.
05:11:53 <autrijus> anyone played with ehc?
05:12:03 <autrijus> I'm having problem building it with uust. probably want to cabalise it
05:12:19 <musasabi> altough it should be fairly easy to implement.
05:12:20 * autrijus also suspects utrecht people related to ehc may be somewhere in the conference
05:12:42 <dblhelix> autrijus: both doaitse and atze are
05:13:03 <autrijus> cool, 'cept I don't know their face
05:13:11 <tromp> of course i'm curious to see if jhc can compile fhourstones
05:13:12 <Heffalump> Doaitse is tall with greying hair
05:13:24 <tromp> and how it compares with ghc' speed
05:13:27 <Heffalump> I'll point him out if you want to talk.
05:13:32 <dblhelix> autrijus:  http://www.cs.uu.nl/~doaitse for a pic
05:13:37 <tromp> anyone have jhc up and running?
05:13:38 <autrijus> dblhelix: thanks!
05:13:47 <autrijus> tromp: I have a fairly old version
05:13:48 <musasabi> tromp: I have.
05:13:51 <autrijus> few months ago
05:14:01 <dblhelix> autrijus: although he has a beard now
05:14:02 <earthy> and http://www.cs.uu.nl/staff/atze.html
05:14:08 <musasabi> autrijus: there are very good speedups in compile times.
05:14:12 <autrijus> ok, thanks
05:14:12 <tromp> can you download fhourstones and try?
05:14:17 <autrijus> musasabi: ooh, gladtohear
05:14:21 <musasabi> url?
05:14:24 <earthy> (which looks horrid on him... Doaitse really shouldn't try wearing a beard ;))
05:14:32 <autrijus> Heffalump: is your darcs repo of the darcs patch stuff still the head one?
05:14:38 <tromp> http://homepages.cwi.nl/~tromp/c4/fhour.html
05:14:54 * musasabi really should push the base library for jhc path to the main repo sometime, but comonads keep distracting me.
05:14:56 <tromp> http://homepages.cwi.nl/~tromp/c4/Fhourstones.tar.gz
05:15:01 <Heffalump> autrijus: Igloo and I are having some merge issues, so that has a patch that will be unpulled soon.
05:15:13 <dblhelix> earthy: you are aware this channel is logged and you still need to obtain your phd and doaitse is your promotor? *grin*
05:15:14 <Heffalump> (nothing complicated, we just agreed it's simplest to merge by me unpulling)
05:15:20 <autrijus> okie
05:17:05 <basti_> musasabi: (after some hswebforms hacking) question details! http://www.haskell.org/hawiki/HsWebForms
05:17:36 <earthy> dblhelix: it's nothing I haven't or wouldn't have said to his face
05:17:52 <dblhelix> earthy: okay then :)
05:26:51 <Pistahh> where can I find the documentation about Text.Printf? It does not seem to be in prelude.
05:28:20 <autrijus> Pistahh: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Printf.html
05:28:41 <Pistahh> autrijus: thx.
05:30:41 <musasabi> basti_: I am looking at that (and declareL)
05:35:43 <SyntaxNinja> autrijus: where are you?
05:36:07 <Heffalump> who is at/coming to ICFP that I haven't seen yet?
05:36:07 <autrijus> SyntaxNinja: conference room, left side, last row
05:36:31 <SyntaxNinja> spj is looking for you. we're in the "hacking" room
05:36:36 <SyntaxNinja> where you were before, where daan is
05:36:47 <Heffalump> where is the "hacking" room?
05:36:52 <autrijus> cool!
05:36:52 <Heffalump> and does it have power?
05:36:54 <SyntaxNinja> the registration room
05:36:55 <SyntaxNinja> a bit
05:36:57 <autrijus> Heffalump: it does
05:37:04 <basti_> musasabi: great
05:37:14 * Heffalump wonders about convening the darcs meeting there
05:37:14 <autrijus> ok. the talk will go on for another 20 minutes I think
05:37:16 <SyntaxNinja> autrijus: are you coming here? or should I send hi to you?
05:37:18 <SyntaxNinja> oh right ok
05:37:22 <autrijus> do you want me to invoke escape continuation?
05:37:32 <SyntaxNinja> I don't thinks o.
05:37:37 <autrijus> *nod*
05:37:44 <SyntaxNinja> I'll ask him
05:38:12 <autrijus> (I can't quite follow this AOP talk, to be honest)
05:38:22 <autrijus> <- illterate in pointcuts
05:38:58 <SyntaxNinja> ah
05:39:50 <Philippa_> a lot of AOP keeps striking me as... I guess sloppy
05:39:58 <SyntaxNinja> yeah
05:40:01 <Philippa_> probably because I'm so used to the idea of using monads for a lot of the same stuff
05:40:19 <Heffalump> autrijus: I can tell you about pointcuts if you lik e(see my current T-shirt)
05:42:07 <Heffalump> SyntaxNinja: do you know how long the hacking room will be open for?
05:44:42 <Igloo> When are you starting?
05:45:23 <Heffalump> Igloo: I think the plan was after ICFP, but I forgot about your workshop.
05:45:53 <musasabi> tromp: the fhourstone looks quite un-haskell98ish.
05:46:07 <tromp> it uses some extensions
05:46:46 <tromp> not sure which:(
05:47:20 <alar> are there extensions beyond H-98?
05:47:31 <SyntaxNinja> autrijus: spj says you're kwelcome to come out if you want. he did too.
05:47:36 <dblhelix> alar: quite a few, yes
05:48:23 <Heffalump> SyntaxNinja: is SPJ giving him permission to leave the talk, OAIC? :-)
05:48:31 * earthy grins
05:48:41 <autrijus> SyntaxNinja: ok. throwing myself out of this scope :)
05:49:04 <Heffalump> David and I will be along at 4. He wants to do a darcs discussion with anyone interested.
05:51:54 <musasabi> basti_: the problem with declareL is the length of the list.
05:52:02 <basti_> musasabi: uhm.
05:52:14 <musasabi> basti_:
05:52:18 <musasabi> declareL  :: Monad m => ([Ref m a] -> z) -> Ref m [a] -> z
05:52:22 <basti_> yes.
05:53:06 <basti_> The tuples case is easy i know.
05:53:16 <musasabi> It is trivial to generate an infinite list of Refs that reference the elements in the list (and generate errors beyound the tail) but I don't think this is what you want.
05:53:24 <basti_> I tried declareL and declareBy, but didn't have significant sucess
05:53:56 <basti_> all I want is to refer to a List of form elements.
05:54:12 <basti_> (checkboxes, or submits)
05:54:37 <musasabi> basti_: like combL ?
05:55:01 <musasabi> combL :: Monad m => ([HXML] -> HXML) -> [Form m] -> Form m
05:55:31 <basti_> hmm
05:55:42 * basti_ goes and tries
05:56:06 <alar> what's HXML?
05:56:41 <musasabi> alar: the representation used for XML nodes used.
05:57:50 <alar> musasabi: where can I read about it?
05:59:31 <boegel> yo CosmicRay, anything on HWN yet ?
05:59:32 <musasabi> alar: the hsp paper. http://www.cs.chalmers.se/~d00nibro/hsp/#doc
06:00:31 <CosmicRay> boegel: in an hour or two
06:00:47 <CosmicRay> I just got home from a trip
06:00:52 <alar> thanks
06:02:01 <alar> I need to mess with SVG and if there is a way to do it in Haskell - that would be great!
06:08:24 <earthy> yes, there is a way to do it in Haskell. it starts with 'write a library to deal with SVG'
06:08:26 <dcoutts> alar, do you specifically need to produce SVG output, or just play with vector graphics?
06:08:58 <dcoutts> if it's the latter there are bindings to the cairo vector graphics library
06:10:54 <xerox> Morning!
06:11:46 <alar> SVG output would be easiest way
06:12:09 <alar> and I don't know the limits of portability of cairo
06:12:15 <boegel> y0 xerox
06:13:19 <dcoutts> alar, cairo is portable to every major os
06:14:32 <dcoutts> (win32, linux, osx, solaris, *bsd)
06:15:42 <alar> if QNX is also covered then it can be GUI I dream of
06:16:00 <dcoutts> not sure about that
06:16:08 <dcoutts> @google  cairo graphics
06:16:10 <lambdabot> http://www.cairographics.org/
06:16:31 <dcoutts> some future version of cairo is going to have an svg backend
06:16:55 <alar> ah, another PostScript-inclined GUI
06:16:57 <alar> fine!
06:17:16 <xerox> What do you mean by 'PostScript-inclined GUI'?
06:17:22 <dcoutts> yes, it's a PDF drawing model
06:18:02 <alar> I like this model
06:18:15 <alar> xerox: The cairo API provides operations similar to the drawing operators of PostScript and PDF.
06:19:17 <dcoutts> the current cairo backends are png, xlib, ps & pdf
06:19:19 <musasabi> basti_: Added some things about checkboxes.
06:19:40 <dcoutts> oh and win32
06:20:42 <dcoutts> future ones are quartz, glitz (opengl) and svg
06:21:01 <alar> dcoutts: is XWindows version wm-aware?
06:24:19 <basti_> musasabi: mmmok :) *checks out*
06:25:22 <basti_> hmm not in the darcs repo?
06:25:43 <CosmicRay> hmm, not a lot going on this week.
06:26:05 * Heffalump is at the ICFP darcs BOF :-)
06:27:15 <xerox>     where bof = ..
06:27:33 <earthy> birds of a feather session
06:27:45 <earthy> ie: chatroom in real life ;P
06:30:32 <dons> CosmicRay, Haskell wipes the field in the icfp contest...
06:30:38 <Philippa_> heh
06:30:55 <CosmicRay> dons: oh?  was that announced on a list anywhere?
06:31:11 <dons> it was announced at icfp. here's a link...
06:31:13 <CosmicRay> dons: oh and btw does hs-plugins require a registerized ghc, or will it run anywhere that ghc itself will (even if ghci doesn't?)
06:31:17 <musasabi> basti_: they are in the existing code.
06:31:52 <basti_> oh
06:31:55 <dons> usually, ghci means the linker works. hs-plugins needs the linker.
06:32:05 <CosmicRay> rats.
06:32:08 <dons> so if you don't have ghci, it's unlikely hs-plugins will work
06:32:08 <musasabi> basti_: checkGroup is defined in src/Webform/Prim.hs (and should be visible in the haddock docs).
06:32:16 <CosmicRay> I was afraid of that.
06:32:24 <CosmicRay> I don't have ghci on several of the platforms that I need it on.
06:32:31 <dons> in fact, i know of no arch where the linker works, but ghci doesn't
06:32:32 <musasabi> basti_: the convert example is when you want something in an another form.
06:32:35 <basti_> hmm ok. I might be able to build on that to get what i want
06:32:40 <CosmicRay> dons: I think you are right.
06:32:47 <dons> icfp results: http://icfpc.plt-scheme.org/
06:33:15 <dons> Wolfgang Thaller and team mate (name?) won
06:33:28 <dons> so very relevant, since he's a ghc hacker :D
06:33:46 <dons> Haskell also came 3rd.
06:34:15 <CosmicRay> is that Kieber?
06:34:18 <dons> and, Haskell did very well overall, as the breakdown slides show.
06:34:23 <dons> Keiber is Wolfgang.
06:34:31 <CosmicRay> who is XiaoTou?
06:34:49 <dons> it's a chinese word for "robber"
06:34:54 <dons> hang on, the name is in the slides
06:35:19 <musasabi> Just ask further questions if you have them. Having someone ask things forces me to write better documentation which is always a good thing.
06:35:44 <dons> oh doh. the other guy's name isn't in the slides either.
06:36:17 <dons> so Wolfgang Thaller accepts the prize as 1 member of team "KiebererAndXiaoTou"
06:37:03 <dons> and Haskell is the programming tool of choice for discriminating hackers for the 2nd year running
06:37:30 <Heffalump> dons: ndm is now looking for you too, btw.
06:37:33 <dblhelix> dons: can't you ask him who his team mate is? the folks at home are dying to know, you know?
06:37:44 <Heffalump> he's apparently the only person at the conference with ginger hair.
06:38:21 <dons> oh. i'm not at the conference atm. working on my talkk back at my hotel.
06:38:35 <CosmicRay> dons: whos is Combat-Tantiedan?
06:38:44 <Heffalump> I guessed, just letting you know in general.,
06:38:51 <Heffalump> But there's HW which should be easy to meet up at :-)
06:38:58 <dons> yep :)
06:39:34 <Itkovian> @google monad nomaware
06:39:36 <lambdabot> http://www.nomaware.com/monads/html/
06:39:42 <dcoutts> alar,  wm-aware? I don't know what you mean
06:39:46 <dons> CosmicRay, so 3rd prize was Takayuki Muranushi and Hideyuki Tanaka
06:40:35 <earthy> ah, nomaware is fixed again
06:40:39 <dons> Heffalump, maybe if you see Wolfgang wandering around ask him who his teammate is so he can get into the weekly news
06:40:42 <earthy> it was broken last friday or so
06:40:54 <Heffalump> ok.
06:40:55 <Itkovian> earthy: ic
06:41:03 <alar> I mean library deals with Windowmanagers
06:41:14 <alar> so I don't need to deal with them myself
06:42:13 <dcoutts> alar, cairo is not a gui toolkit so it has very little to do with window managers
06:42:14 <dons> CosmicRay, more details are in http://icfpc.plt-scheme.org/icfpc2005-talk.pdf
06:42:23 <dcoutts> alar, you can use cairo with gtk of course
06:42:42 <alar> then I misunderstand something
06:42:43 <autrijus> dons: where are you? I still owe you a t shirt
06:43:14 <dcoutts> alar, what are you thinking of?
06:43:59 <dons> autrijus, true! i'm not at the conference atm. i'll see you at the HW if not before though
06:44:08 <autrijus> cool
06:44:08 * dons has a talk to finish 
06:44:08 <musasabi> What is the best way to get from harbour to ICFP ?
06:44:16 <autrijus> ah, another of those JIT talks
06:44:18 <dons> musasabi, walk. it's about 5 mins
06:44:24 <autrijus> try takahashi? :)
06:44:27 <autrijus> or is it too late?
06:44:46 <autrijus> ... (and what are you doing on #haskell if you are working on your talk?)
06:44:56 <alar> I misunderstand graphics architecture
06:44:58 <dons> :p
06:45:01 <dons> multitasking
06:45:54 <alar> I supposed: bottom level = XWindows or like, then go applications, one of applications is Window manager, it somehow tries to manage others
06:45:58 <dcoutts> alar, so cairo is a vector graphics library which can draw onto various kinds of surfaces, eg memory buffers, pdf files, xlib windows, win32 gdi handles etc
06:46:08 <alar> ah, just graphics
06:46:10 <alar> thanks
06:46:13 <musasabi> dons: point, I was thinking of the IOC main building. Makes things much simpler :-)
06:46:14 <dons> musa, you go in through the main gait into old town, which is Pikk street/whatever they call it in estonian)
06:46:14 <alar> now I understand
06:46:32 <dons> gate. why is my spelling falling apart today
06:46:58 <dcoutts> alar, then you use something like gtk to manage the rest of the gui (ie top level windows, buttons, menus etc), but you can do custom drawing with cairo
06:46:58 <int-e> dons: <dons> multitasking
06:47:23 <dons> hehe
06:47:48 <musasabi> dons: yes, Pikk is easy.
06:47:50 <dcoutts> alar, for example this app: http://haskell.galois.com/~paolo/nymphaea/
06:48:11 <alar> dcoutts: thanks alot, I have some task exactly matching your description
06:48:24 <alar> maybe cairo is the best tool available
06:48:28 <musasabi> I think I got it :-)
06:48:34 <dcoutts> alar, it uses gtk to draw the gui and cairo to render the pics which are then displayed in the gui
06:48:52 <dcoutts> alar, oh that site doesn't have any pics of the gui, let me find one...
06:48:53 <dons> musasabi, the building you're looking for has a wacky green door
06:49:19 <alar> dcoutts: nevermind
06:49:30 <alar> knowing what it can do is enough
06:49:32 <dcoutts> here's an old one: http://haskell.org/~duncan/cairo/Screenshot-six.png
06:50:24 <alar> thanks
06:53:45 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "#haskell @ ICFP: Meet after Haskell workshop on Sep 30!!", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn' by CosmicRay
06:53:53 <CosmicRay> doh
06:53:57 <CosmicRay> topic is too long!
06:55:08 <SM_ax> get rid of funk in function :)
06:55:46 * adept . o O ("topic is set to 'We just jot rid of "We put funk in funktion" .....')
06:56:17 <alar> I'm not sure that link to logs are useful for anyone
06:56:41 <musasabi> Maybe tinyurl the logs.
06:57:12 <dons> the hide entry could be removed
06:57:18 <dons> it's old news
06:58:01 <SM_ax> Tmr is older
06:59:22 <musasabi> But tmr gets new issues.
06:59:29 <musasabi> (and hide new revisions)
06:59:54 <dons> the hide wiki page is only a small thing
06:59:59 <dons> atm ;)
07:01:10 <SM_ax> well, tmr can be put back when issue 5 is out
07:02:36 <alar> IMHO not very good but pretty usable haskell IDE can be made by hybridizing GHCi and WinHugs
07:03:02 <dons> ah, but we're making a good one :D by hybridizing ghci
07:03:27 <dons> alar, can you describe WinHugs?
07:03:33 <dons> i've never seen it
07:03:45 <dons> where's ndm when you need him....
07:04:11 <alar> it is just GUI built with Hugs
07:04:23 <alar> it allows you to change most of the options
07:04:26 <dons> yeah, but what does the gui do?
07:04:27 <alar> load modules
07:04:40 <dcoutts> WinHugs as I recall is a hugs window with some toolbar buttons for the ":blah" commands
07:04:42 <dons> is it a wrapper over normal hugs cmd line functions?
07:04:43 <alar> start/stop computation
07:04:45 <dons> right.
07:04:55 <dcoutts> and it shows the module dep graph I think
07:04:56 <alar> no
07:05:11 <dcoutts> or perhaps it was the class inheritance tree
07:05:17 <alar> if it is a wrapper than the wrapper is built togeher with hugs
07:05:33 <Sickjacken> drawing a simple diagram with arrows...is it simple in latex? because i usually use dia...but it doesnt let me use latex symbols
07:05:37 <alar> class tree
07:05:41 <Sickjacken> any advice ?
07:05:50 <alar> but the tree is rather clumsy :)
07:05:51 <Sickjacken> ow shit, wrong chan
07:06:43 <int-e> Sickjacken: have a look at the xypic package, or draw them with xfig and import them; at least that's what I'd try.
07:06:53 <Sickjacken> k thanks
07:06:59 <dcoutts> in my humble opinion, winhugs doesn't really make anyone more productive, it is just less intimidating to students who are used to windows programs rather than CLI interfaces
07:07:01 <alar> the main feature lacking IMHO: one cannot write parts of program inside WinHugs window
07:07:11 <alar> like that is possible in GHCi
07:07:57 <alar> dcoutts: drag'n'drop style makes faster first stage of program development
07:08:11 <dcoutts> what drag'n'drop?
07:08:29 <alar> I can drop source file into winhugs window
07:08:30 * dcoutts doesn't remember any drag'n'drop features in winhugs
07:08:35 <dcoutts> ah, ok
07:08:55 <alar> fixing syntax errors, first-time runs, etc
07:09:46 <alar> if development is behind this stage, solidity of GHC is more valuable than this "play" style
07:10:31 <alar> ah, forgot to mention
07:11:20 <alar> GHCi and Hugs output is lost under Win9x, because of stupid virtual terminal
07:11:37 <alar> is the output is longre than 25 lines
07:11:44 <alar> Winhugs has own window
07:12:35 <humasect> make cmd buffer size larger
07:13:09 * humasect has it set to 600.
07:13:10 <alar> where? is it adjustable under Win9x?
07:13:35 <humasect> yes. cmd.exe top left icon -> properties -> layout
07:14:22 <humasect> clipboard ops are there too.
07:15:39 <CosmicRay> Is there any way I could let people extend/customize programs with their own modules, or perhaps write config files in Haskell, without resorting to hs-plugins?
07:16:21 <humasect> most would say hs-plugins are a first resort.
07:16:30 <humasect> *is
07:16:32 <musasabi> CosmicRay: well they would need either hugs or ghc.
07:16:58 <dcoutts> CosmicRay, unless you write your own interpreter or something, or use the new ghc api
07:16:59 <musasabi> CosmicRay: you could make the config-file a program that just outputs the configuration and the main program reads that.
07:17:03 <dons> CosmicRay, Read/Show?
07:17:03 * alar has to go
07:17:38 <dons> but if you want them to write functions, I have a feeling hs-plugins might be the only practical way
07:18:01 * xerox yawns
07:18:03 <CosmicRay> dons: good point.
07:18:19 <CosmicRay> sometimes I forget the easy options. ;-)
07:18:45 <CosmicRay> humasect: it won't work for me because of portability issues with hs-plugins.
07:19:15 <SamB> CosmicRay: portability issues?
07:19:27 <CosmicRay> SamB: hs-plugins only works on platforms where ghci is available.
07:19:30 <SamB> oh
07:19:31 <dons> yeah, so if you can restrict them to, say, writing a nice labelled record value, that might be nice
07:19:42 <CosmicRay> there are quite a few where it isn't (alpha, arm, aix, etc.)
07:19:51 <SamB> why isn't it?
07:19:51 <dons> a la the old package.conf files (they're readable)
07:20:00 <SamB> what prevents it, I mean?
07:20:00 <CosmicRay> dons: that will do initially.  perhaps I could make the hs-plugins features optional.
07:20:05 <dons> SamB, needs ghc rts linker support for that arch/obj format
07:20:12 <SamB> that is to say, what would need to be written?
07:20:34 <SamB> is there some obscure document that talks about this?
07:20:37 <dons> you'd have to hack Linker.c for the arch. by doing so you'd get both ghci and hs-plugins support on that arch.
07:20:51 <dons> yes, the Porting page of the ghc users' guide.
07:21:03 <SamB> that isn't even very obscure
07:21:09 <dons> :)
07:21:23 <SamB> now if only I had the GHC repository checked out still
07:21:29 <SamB> or on CD or something
07:21:33 <dons> the connection to hs-plugins is a bit obscure, if you don't know how hs-plugins works
07:21:54 <SamB> it is a bit obscure, but I can believe it well enough. I think TH is the same way.
07:22:14 <SamB> though with TH it is less obscure why, I suppose
07:22:32 <humasect> hIDE depends on ghc-api already ?
07:23:54 <dcoutts> humasect, some hIDE plugins do yes (or will do shortly)
07:24:41 <humasect> ah
07:25:04 <dons> syntax highlighting! type checking! module dependency graphs!
07:25:29 <dons> chocolate cake with sprinkles!
07:25:31 <dcoutts> humasect, Lemmih's Haskell syntax highliting uses a hacked version of ghc's lexer (actually it is shared with the version used by the VS Haskell plugin)
07:25:57 <humasect> :o interesting
07:27:03 <dcoutts> dons, I'd really like to make a module browser view that is the module dep graph - as a graphical representation (using graphviz to do the layout and cairo to draw it)
07:27:25 <dcoutts> in addition to the modules & files browser views
07:27:37 <dcoutts> which are just ordinary tree views
07:27:57 <xerox> @where gtk+yi
07:27:59 <lambdabot> I know nothing about gtk+yi.
07:28:00 <humasect> i was going to play around with function browser in a similar way
07:28:02 <xerox> @where yi+gtk
07:28:03 <lambdabot> darcs get http://www.scannedinavian.org/repos/yi/
07:28:06 <xerox> @where hide
07:28:08 <lambdabot> http://www.haskell.org/hawiki/hIDE
07:28:35 <dcoutts> humasect, yes then a similar thing would be a funtion call graph
07:29:16 <humasect> say if you were graphing some audio processing modules that way, they would be importable and exportable as haskell code
07:30:25 <humasect> it would display higher order passing, recursion, etc. useful for domain specifics and newbies alike
07:31:16 <humasect> i didn't know about graphviz though
07:31:44 <dcoutts> http://graphviz.org/
07:31:50 <dcoutts> it's pretty good
07:32:01 <humasect> oh, it is something else. like a format to export and view within their app?
07:32:10 <dcoutts> and is easy to integrate with since it uses a simple textual input/output format
07:32:14 <humasect> or GXL
07:32:21 <humasect> ah ok
07:32:49 <dcoutts> oh and it can output loads of other formats, like bitmaps, web image maps, svg etc
07:33:33 <humasect> so far i've got wx -> HsModule/Language.Haskell.* -> XML -> Cairo or GL
07:34:01 * dcoutts doesn't underatand
07:34:45 <humasect> input is .hs modules
07:35:08 <humasect> output is either cairo or GL, GL for now in wx.
07:35:48 <xerox> And what does it do to the inputs?
07:36:43 <humasect> in theory, editing haskell modules without touching source
07:36:44 <xerox> Howdy bojohan.
07:37:42 <bojohan> hi
07:37:45 <humasect> good for DSL.. like audio processing or rendering pipeline. straight to haskell code (or GXL)
07:42:09 <xerox> What kind of editing are you thinking of?  (wondering what do you output exactly)
07:43:46 <CosmicRay> on http://www.haskell.org/hawiki/HaskellUnixDaemon, what is this forkProcessAll?
07:43:51 <CosmicRay> it doesn't seem to be in the ghc haddock docs.
07:44:54 <earthy> indeed not
07:47:02 <earthy> even worse, it doesn't even seem to be in the GHC 6.4 sourcecode at all
07:48:03 <earthy> it *was* in 6.0 however: http://www.haskell.org/ghc/docs/6.0/html/unix/System.Posix.Process.html#forkProcessAll
07:50:01 <earthy> note that forkProcess is quite completely changed between 6.0 and 6.45
07:50:04 <earthy> 6.4 even
07:55:42 <beelsebob_> @hoogle sortBy
07:55:44 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:55:45 * boegel leaves for home
07:56:15 <beelsebob_> how do I figure out what constructors Ordering has?
07:56:47 <ProfTeggy> :i Ordering    (in ghci)
07:56:52 <earthy> interestingly the change was between 6.0 and 6.2 and *not* noted in the release notes
07:56:58 <humasect> xerox: the output would be directly useable haskell module
07:57:38 <humasect> and each "node" in the editable graph would be a function + in/out connections to others
07:57:49 <beelsebob_> chears
08:02:22 <humasect> which team is #haskell on ICFP?
08:04:29 <beelsebob_> team?
08:04:50 <dons> ?
08:04:57 <SamB> isn't there more than one?
08:05:43 <humasect> unsure.
08:19:39 <xerox> humasect: it sounds fun.
08:21:05 <sethk> hey, all.  I'm building the worlds simplest monad (hopefully).  I can create one with runState.  Having created it, what functions do i use to modify/change the value it is holding?  The class talks about get and put, but I don't see get and put defined for the actual thing, just described in the class section of the doc
08:21:36 <xerox> @index get
08:21:38 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.
08:21:38 <lambdabot> StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL,
08:21:38 <lambdabot> Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.Compat.
08:21:38 <lambdabot> ReadP, Text.ParserCombinators.ReadPrec, Text.Read
08:21:45 <xerox> @type Control.Monad.State.get
08:21:47 <lambdabot> forall s (m :: * -> *). (Control.Monad.State.MonadState s m) => m
08:21:47 <lambdabot> s
08:21:48 <xerox> @type Control.Monad.State.put
08:21:49 <lambdabot> forall (m :: * -> *) s.
08:21:49 <lambdabot> (Control.Monad.State.MonadState s m) =>
08:21:49 <lambdabot> s -> m ()
08:21:58 <xerox> Quite straightforward.
08:22:29 <sethk> ok, so get and put are the functions I want
08:23:28 <dcoutts> poetix, I see your obby work is progresing
08:24:30 <poetix> dcoutts: Yes, I have the basic build set-up working now
08:25:09 <poetix> I hope that's a large part of the struggle, and I'll get to make some fairly swift progress on some simple things before I hit the next big bump
08:25:33 <poetix> These things tend to come in plateaux...
08:25:40 <dcoutts> poetix, btw I think you can use "extern C {" over a whole block of function prototypes rather than doing it for each decleration
08:26:10 <poetix> Oh, OK - that's probably tidier
08:26:26 <dcoutts> is it a large API you need to bind?
08:26:30 <poetix> Although slightly harder for my sed script to remove, as it would have to detect the closing brace
08:26:39 <ibid> what language is that?
08:26:50 <dcoutts> I wonder if there is anyway to automatically generate the C/Haskell interface
08:27:06 <poetix> It's not a particularly large API - a couple of objects
08:27:16 <dcoutts> oh ok, that's nice
08:27:52 <poetix> Probably the next hard bit will be dealing with libsigc++, which is used extensively for callbacks
08:28:02 <dcoutts> ah yes, hmm
08:28:04 <musasabi> How large is the Java 1.4 language?
08:28:33 <dcoutts> musasabi, what are you measuring?
08:28:44 <musasabi> How hard would a tool to make Java->Haskell conversion with OOHaskell on the Haskell side be.
08:29:09 <earthy> hey, CosmicRay, does the new code on http://haskell.org/hawiki/HaskellUnixDaemon help?
08:29:11 <dons> hmm. research project.
08:29:14 <musasabi> dcoutts: Core language features only.
08:29:17 <poetix> I think you can pass a plain C function pointer to a sigc++ event as a callback, so provided I can convert a Haskell function to a C function pointer it should be OK
08:29:23 <dons> musa, what kind of "conversion"?
08:29:35 <dcoutts> poetix, converting a Haskell function to a C function pointer is easy
08:29:42 <dons> FFI or compilation?
08:30:17 <dons> there's been a fair bit of work, maybe 10 papers, on compiling haskell to the jvm, some of which compile to java
08:30:29 <dons> others to bytecode
08:30:38 <poetix> The likelihood is however that the signature expected by the sigc++ events will include C++ object references, so I'll have to map between plain C and C++ callback functions
08:31:44 <poetix> There will be a lot of casting back and forward between FooObject* and void*
08:32:09 <dcoutts> poetix, hmm, unpleasent
08:32:28 <xerox> poetix: put a tag on the closing brace like "} // closing foo"  ?
08:32:31 <dcoutts> poetix, have you seen the wxHaskell bindings, that might give you some inspiration
08:33:03 <dcoutts> wxHaskell has a big C lib which interfaces with the C++ wxWidgets library
08:33:24 <dcoutts> and it generates that automatically somehow
08:33:43 <poetix> I do find myself wishing I'd chosen to work on something cuter. But - no pain, no gain.
08:34:00 <dcoutts> but my main point is that you could see what kind of marshaling/conversion it does for the C/C++ bridge
08:34:04 <humasect> wxHaskell uses swig as well?
08:34:13 <humasect> oh my bad, Eiffel wx bindings.
08:34:17 <dcoutts> yep
08:34:43 <poetix> xerox: good batting, thinkman!
08:34:53 <davve> the eiffel dudes did that c binding by hand
08:35:21 <dcoutts> davve, I thought they wrote some generator program to make it
08:35:36 <davve> I don't think so
08:35:40 <dcoutts> oh ok
08:35:41 <poetix> Mmm...parsing C++ code with templates...
08:35:54 <xerox> poetix: err? :-D
08:35:55 <dcoutts> I wonder how they keep up with wxWidgets releases
08:36:27 <autrijus> rehi
08:36:33 <xerox> Hiya autrijus!
08:36:54 <poetix> Yeah, the obby API is about to change...
08:37:47 <musasabi> dons: compilation. And java->haskell not haskell->java.
08:38:03 <musasabi> dons: and just a very simple minded conversion.
08:39:23 <musasabi> Mainly I am wondering whether there is anything besides dynamic loading and reflection that is not readily supported by GHC + OOHaskell.
08:39:35 <dons> oh,  java->haskell. hmm.. not sure i've i've heard of any work going that way
08:40:08 <dons> right, so you want an encoding of java's semantics in haskell
08:40:16 * earthy shudders
08:40:28 <poetix> How about a Haskell JVM?
08:40:29 <musasabi> yes. If that could work it would be tons of libraries for free ;)
08:40:31 <dons> in full haskell, not ghc Core or something.
08:40:34 <autrijus> anyone heard of a Haskell binding of LLVM?
08:40:42 <autrijus> or some way for Hs programs to target llvm
08:41:00 <musasabi> poetix: that would be good for java, not hijacking java libraries into haskell.
08:41:34 <dons> oh, you want to compile java libraries to haskell?
08:42:04 * poetix thinks of Hibernate, and snickers
08:42:19 <dons> why not just a haskell<->java bridge? i.e. an FFI
08:42:29 <dons> then haskell can just import foreign and call java
08:42:36 <dons> we already have a jvm bridge or two
08:42:44 <poetix> It's been done with dotnet too
08:44:16 <musasabi> dons: because that tends to require writing large amounts of wrapper code and things like error handling rarely work very well.
08:46:46 <dons> well, compilation is a bigger problem, I think
08:46:56 <dons> maybe not much bigger though
08:47:52 <Lunar^> CosmicRay: did you filled an ITP for hscurses?
08:50:48 <dons> ITP?
08:51:10 <dons> stefanw's hscurses?
09:10:18 <ProfTeggy> Bye all!
09:14:48 <Kirby> how many ways can you divide 42 unique items into 3 exhaustive groupings (which may be empty) where the size of the first group and the second group are equal to each other?
09:15:33 <dcoutts> Kirby, try writing a program to solve it
09:16:07 <beelsebob_> 42! + 40! + 38! + 36! + ... 0!
09:16:09 <Kirby> I'm quite new to Haskell programming, and I ask for advice. (This isn't homework, fwiw.)
09:16:23 <beelsebob_> lots
09:17:06 <dcoutts> Kirby, well break it down into sub-problems first
09:17:11 <beelsebob_> @eval foldr (+) 0 (map (!) [0,2..42])
09:17:16 <lambdabot> 35: Not in scope: `!'
09:17:22 <beelsebob_> bugger
09:17:52 <Kirby> okay, how many ways can you divide 42 unique items into 2 exhuastive groups of equal size (21 each)? ... hmmm
09:18:05 <beelsebob_> @eval let fac 0 = 1; fac n = n * fac (n-1) in sum (map fac [0,2,42])
09:18:05 <adept> @eval foldr (+) 0 (map (fact) [0,2..42])
09:18:08 <lambdabot> 1405006117752879898543142606244511569936384000000003
09:18:08 <lambdabot> 36: Not in scope: `fact'
09:18:14 <beelsebob_> that many
09:18:20 <beelsebob_> ... lots
09:18:39 <beelsebob_> oh no... more than that
09:18:50 <adept> 0,2,..,43
09:18:55 <beelsebob_> @eval let fac 0 = 1; fac n = n * fac (n-1) in sum (map fac [0,2..42])
09:18:56 <adept> 0,2,..,42
09:18:57 <lambdabot> 1405822556431034085863935884893547760772293028258667
09:19:08 <basti_> Kirby: "choose 21 from 42" many
09:19:14 <adept> yes, thats correct :)
09:19:23 <basti_> (thats 42!*41!*...*22!)
09:19:41 <adept> basti_: not '*', it's '+'
09:19:41 <Kirby> @eval fac 42 / ( fac 21 * fac 21)
09:19:43 <lambdabot> 18: Not in scope: `fac'29: Not in scope: `fac'38: Not in scope: `fac'
09:19:50 <basti_> but i need to do the dishes
09:19:58 <basti_> bbl
09:20:08 <beelsebob_> @eval let fac 0 = 1; fac n = n * fac (n-1) in sum (map (fac . (*2)) (take 21 [0..]))
09:20:10 <lambdabot> 816438678154187320793278649036190835909028258667
09:20:15 <beelsebob_> that's more like it
09:20:17 <beelsebob_> that many
09:20:19 <beelsebob_> lots...
09:20:51 <adept> hmmm
09:20:54 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1) in ( fac 42 / ( fac 21 * fac 21 ) )
09:20:56 <lambdabot> 5.3825787443999994e11
09:23:33 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1) in ( ( fac 42 / ( fac 19 * fac 23 ) ) * ( fac 23 / ( fac 21 * fac 2 ) ) )
09:23:35 <lambdabot> 1.130341536324e14
09:24:26 <adept> Kirby: you need 'fac 2' only if order of items in grouping is significant (it it's a list and not a set, f.e.)
09:24:50 <Kirby> the order of items in a grouping is not significant
09:26:52 <adept> then you will have (C^21_42)*(0)*(C^21_42)+(C^20_42)*(C^2_42)*(C^20_42)+..+(0)*C^42_42*(0)
09:29:54 <Kirby> maybe ?  (C^21_42) * (C^21_21) * (C^0_0) + (C^20_42) * (C^20_22) * (C^2_2) + (C^19_42) * (C^19_23) * (C^3_3) + .... + (C^0_42) * (C^0_42) * (C^42_42)
09:31:18 <adept> that implies that order of forming selections is significant, which is not :)
09:31:28 <adept> i am wrong, though
09:32:03 <adept> or maybe you are right :)
09:34:14 <adept> @eval let fac 0 = 1; fac n = n * fac (n-1); c r n = fac n / ((fac r)*(fac (r-n))); sel x = (c x 42)*(c x (42-x))*(c (42-2*x) (42-2*x)) in sum ( map sel [0..21] )
09:34:16 <lambdabot> Stack overflow
09:34:20 <adept> :)))
09:34:23 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1); comb n r = fac n / ( fac r * fac (n-r) ) in comb 5 2
09:34:25 <lambdabot> 10.0
09:35:05 <adept> there is a need for strict * and +, which is cumbersome to express in @eval
09:35:34 <int-e> @eval let ch n 0 = 1; ch n k = n * ch (n-1) (k-1) `div` k in sum [ch 42 (42-2*k) * ch (2*k) k | k <- [0..21]]
09:35:36 <lambdabot> 8212609533895771131
09:35:38 <adept> @eval let fac 0 = 1; fac n = n * fac (n-1); c r n = fac n / ((fac r)*(fac (r-n))); sel x = (c x 42)*(c x (42-x))*(c (42-2*x) (42-2*x)) in sum ( map sel [0..10] )
09:35:41 <lambdabot> Stack overflow
09:35:55 <adept> bb
09:39:23 <int-e> adept: you mean fac (n-r), not fac (r-n)
09:39:24 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1); comb n r = fac n / ( fac r * fac (n-r) ); myfunc n = (comb n 42) * (comb (42-n) n); in sum (map (myfunc) (take 21 [0..]))
09:39:26 <lambdabot> Stack overflow
09:42:33 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1); comb n r = fac n / ( fac r * fac (n-r) ); myfunc r = (comb 42 r) * (comb (42-r) r); in sum (map (myfunc) (take 21 [0..]))
09:42:36 <lambdabot> 8.212608995637894e18
09:42:41 <Kirby> that might be it
09:48:25 <[Blownose]> if i have a list like this [[A,E],[A],[A,E,D]]  and i want list like this  [1/2,1,1/3]   (1/numbers of item in each []) how do i write it ?
09:48:27 <Kirby> The good news is that fits in a 64-bit int. The bad news is I don't know (yet-if it's possible) how to do a one to one from the combinatorial possibilities to a 64-bit int hash. Like 0 for one possibility, 1 for the next ... up to 8.2126e18 for the last.
09:52:04 <dons> hmm. well, there's Data.Bits, and the Word64 type
09:53:41 <dons> you get: .&. .|. shift setBit, clrBit etc.
09:53:48 <dons> so that should be quite doable
09:55:25 <Kirby> I'm not yet worried about the implementation in Haskell or any other language, but with a compact and efficient way of mapping the combinatorial possibilities to a unique hash number. (It is not necessary to go back from hash to reconstruct the possibilities from that number itself, but to produce a unique hash number for each possibility.)
09:55:59 <dons> ah, ok. is there an ordering? can you just number them [0.. ]
09:56:16 <dons> based on their elems
09:56:42 <xerox> [Blownose]: map a function which calculates (\xs -> 1 / length xs)
09:56:49 <autrijus> [Blownose]:   map ((1 /) . length) myList
09:57:12 <xerox> Maybe it needs fromIntegral.
09:57:12 <Kirby> like let's say the possibility is group1 {0, 4, 7, 41} group2 {6, 20, 35, 37} and group3 the rest. what hash number do I give it?
09:57:47 <xerox> @plugs map ((1 /) . fromIntegral . length) [[1,2],[3,4,5],[6]]
09:57:56 <dons> try @eval
09:57:59 <autrijus> or genericLength
09:58:00 <xerox> @eval map ((1 /) . fromIntegral . length) [[1,2],[3,4,5],[6]]
09:58:07 <lambdabot> [0.5,0.3333333333333333,1.0]
09:58:07 <lambdabot> [0.5,0.3333333333333333,1.0]
09:58:12 <autrijus> or use % instead of /
09:58:16 <dons> oh, @plugs does work ;)
09:58:25 <xerox> @eval map ((1 %) . fromIntegral . length) [[1,2],[3,4,5],[6]]
09:58:27 <lambdabot> [1%2,1%3,1%1]
09:58:28 <dons> Kirby, are the groups always 4?
09:58:32 <xerox> Rational.% yeah.
09:58:33 <dons> of length 4?
09:58:43 <Kirby> no, the groups are of length 0, 1, 2, 3, 4, 5, 6...21
09:58:50 <xerox> @type (Rational.%)
09:58:52 <lambdabot> bzzt
09:58:53 <autrijus> @eval map ((1 %) . length) [[1,2],[3,4,5],[6]]
09:58:55 <lambdabot> [1%2,1%3,1%1]
09:58:55 <xerox> @type (Ratio.%)
09:58:57 <lambdabot> forall a. (Integral a) => a -> a -> GHC.Real.Ratio a
09:59:00 <xerox> Right :-)
09:59:02 <dons> Kirby, what's the largest number that can appear in a group?
09:59:14 <Kirby> the items are numbered 0..41, so 41.
09:59:52 <dons> which needs, what 6 bits
10:00:06 * xerox got headache trying to program in Scheme in the last hour
10:00:11 <dons> so why doesn't it need 126 bits to represeent all possibilties?
10:00:11 <xerox> :-(
10:00:43 <Kirby> there are 8.212608995637894e18 possibilities total.
10:01:28 <dons> is that decimal point supposed to be there?
10:01:35 <int-e> Kirby: no. You have to take 22, not 21.
10:01:41 <Kirby> which is less than 2^63
10:01:47 <int-e> 8212609533895771131 is the right number :P
10:02:26 <dons> oh, you can write a perfect hash functoin
10:02:36 <dons> a lazy map perhaps. i wonder if that would work
10:02:37 <Kirby> int-e: neither group1 nor group2 can be size 22
10:02:49 <dons> depends on whether you need to enumerate many of them
10:02:56 <int-e> @eval last $ take 21 [0..]
10:02:58 <lambdabot> 20
10:03:01 <int-e> your point?
10:03:20 <Kirby> heh, I don't know Haskell well enough then
10:03:40 <int-e> Kirby: just count the numbers 0 to 21 .. there are 22 of them; or just use [0..21]
10:03:43 <dons> so Kirby, can you generate all permutations, zip them with [1..] and use the elem from [1..] as the hash
10:03:52 <dons> (lazily generate them!)
10:04:21 <dons> is that reasonable, or do I misunderstand what you need to use the hash for?
10:04:33 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1); comb n r = fac n / ( fac r * fac (n-r) ); myfunc r = (comb 42 r) * (comb (42-r) r); in sum (myfunc [0..21])
10:04:35 <lambdabot> <Plugins.Eval>:1:148:
10:04:35 <lambdabot>   No instance for (Fractional [a])
10:04:35 <lambdabot>   arising from use of `myfunc'
10:04:58 <Kirby> @eval let fac 0 = 1; fac n = n * fac (n-1); comb n r = fac n / ( fac r * fac (n-r) ); myfunc r = (comb 42 r) * (comb (42-r) r); in sum (map (myfunc) [0..21])
10:05:00 <lambdabot> 8.212609533895769e18
10:05:11 <Kirby> huh?
10:05:44 <Kirby> ah, yes
10:05:45 <eieiei> if a String is just a list of Chars, why doesn't this work?
10:05:59 <syntaxfree> ['G'++x | x<-"Vertigo"]
10:06:20 <dons> @type (++)
10:06:22 <lambdabot> forall a. [a] -> [a] -> [a]
10:06:42 <syntaxfree> ahh.
10:06:52 <Kirby> dons: I can generate all permutations (combinations)? all 8.2e18 of them? On a laptop?
10:07:07 <dons> no, do you need to?
10:07:19 <dons> or are you trying to find a specifc one? what are you looking for?
10:07:22 <Kirby> you said "can you generate all permutations"
10:07:29 <syntaxfree> this works: ["G"++[x] | x<-"Vertigo"]
10:07:38 <syntaxfree> but I get ["GV","Ge","Gr","Gt","Gi","Gg","Go"]
10:07:42 <dons> yeah, i.e. caan you write a function that would generate them all if needed? given infinite resources
10:07:50 <Kirby> I am looking for a hash table that tells me whether I've looked a permutation before. I won't be looking at the permutations in 'sequential' order.
10:08:02 <syntaxfree> how do I show that as "GVGeGrGtGiGgGo"?
10:08:02 <Kirby> s/permutation/combination/
10:08:10 <dons> ah!
10:08:15 <dons> don't use a hash. forget this
10:08:35 <dons> just use a Map MyList Bool
10:09:04 <dons> unless you have some weird reason to really pack it into a word64. why are you optimising ahead of time?
10:09:44 <Kirby> dons; the 'have I looked at it before' thing is an optimization
10:09:54 <dons> yeah, that's ok. use a map
10:09:59 <dons> Map
10:10:04 <dons> do you know about Data.Map yet?
10:10:07 <Kirby> nope
10:10:19 <dons> pureful function finite mapping from keys to elements
10:10:26 <dons> it's what we use instead of mutaable hashtables
10:10:33 <dons> which are rarely rarely needed
10:11:50 * Kirby is looking at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
10:12:07 <dons> @eval insert [[1,2],[3,4]] True empty :: Map [[Int]] Bool
10:12:08 <lambdabot> 44: Not in scope: `empty'53: Not in scope: type constructor or class
10:12:08 <lambdabot> `Map'
10:12:19 * syntaxfree loves how Haskell docs call everything you say in haskell an "equation".
10:12:29 <dons> @eval Data.Map.insert [[1,2],[3,4]] True Data.Map.empty :: Data.Map.Map [[Int]] Bool
10:12:31 <lambdabot> 18: Not in scope: `Data.Map.insert'53: Not in scope: `Data.Map.empty'
10:12:31 <lambdabot> 71: Not in scope: type constructor or class `Data.Map.Map'
10:12:34 <dons> bah
10:12:38 <dons> Prelude Data.Map> insert [[1,2],[3,4]] True empty :: Map [[Int]] Bool
10:12:38 <dons> {[[1,2],[3,4]]:=True}
10:14:07 <dons> Data.Map> member [[1,2],[3,12]] m
10:14:07 <dons> False
10:14:07 <dons> Data.Map> member [[1,2],[3,4]] m
10:14:07 <dons> True
10:14:22 <Kirby> neat, thanks
10:15:18 <dons> i don't know if you program perl (many have) but we use Maps where perl programmers use %
10:15:35 <Kirby> I've done very little Perl.
10:16:36 <syntaxfree> haskell's Map = Lisp's "mapcar".
10:16:59 <CosmicRay> syntaxfree: concat
10:17:26 <CosmicRay> Hugs.Base> concat  ["GV","Ge","Gr","Gt","Gi","Gg","Go"]
10:17:27 <CosmicRay> "GVGeGrGtGiGgGo"
10:17:42 <syntaxfree> cosmicray thanks!
10:17:58 <Kirby> what does the 'empty' mean in insert [[1,2],[3,4]] True empty ?
10:18:06 <CosmicRay> syntaxfree: haskell's *map* (note small "m") is like mapcar.
10:18:13 <syntaxfree> OH.
10:18:14 <CosmicRay> syntaxfree: Map with the big M is a module or data type.
10:19:38 <CosmicRay> Kirby: that's the empty map, so that means you're adding one key/value pair to the empty map.
10:19:58 <xerox> @docs Data.Map
10:19:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
10:20:02 <xerox> Kirby: -^
10:20:23 <Kirby> I already linked there, thank you : )
10:21:31 <xerox> Oh, sorry.
10:22:55 <int-e> @eval M.empty
10:22:57 <lambdabot> <Plugins.Eval>:1:12:
10:22:57 <lambdabot>   Ambiguous type variable `k' in the constraint:
10:22:57 <lambdabot>   `Show k' arising from use of `show'
10:23:32 <dons> int-e, good point
10:23:38 <dons> @eval M.empty () ()
10:23:39 <lambdabot> 18:
10:23:39 <lambdabot>   The function `Data.Map.empty' is applied to two arguments,
10:23:39 <lambdabot>   but its type `Data.Map.Map k a' has none
10:23:45 <dons> @eval M.empty :: M.Map () ()
10:23:47 <lambdabot> {}
10:24:03 <dons> int-e, do you have the lambdabot src? or was that a guess ?
10:24:37 <int-e> dons: I had a look at the lambdabot source.
10:25:00 <syntaxfree> what's with the "ban n+1 patterns" movement?
10:25:37 <int-e> dons: it's quite hard to guess I believe.
10:25:50 <int-e> syntaxfree: there's a movement? where can I join?
10:26:00 <dons> no no, M is the idiomatic way to import Map
10:26:21 <syntaxfree> int-e: why do you want to join that?
10:26:46 <dons> it's a long-ago controversy, really. the flames have died down
10:27:05 <int-e> syntaxfree: because they're not actual patterns to me and they're quite pointless anyway (just use (n-1) on the right side, duh)
10:27:20 <int-e> syntaxfree: of course that's my own personal opinion.
10:27:30 <dons> some code is more natural, so the argument goes.
10:27:44 <syntaxfree> why not just have the richest set of patterns possible, anyway?
10:27:52 <Oejet> int-e: Just use case ... of on the rhs. :-P
10:27:54 <syntaxfree> so idioms can be developed inside the wider language.
10:28:49 <int-e> syntaxfree: I don't actually care. But if I were to decide whether to add that feature to a language, I'd likely vote it down.
10:29:10 <syntaxfree> I don't understand why not to add features.
10:29:37 <SamB> n+k is just too warty
10:29:54 <SamB> and rarely, rarely used
10:29:54 <syntaxfree> warty?
10:30:05 <astrolabe> Small languages are easier to learn
10:30:31 <SamB> would YOU like to be the one who has to support n+k patterns in a parser and compiler?
10:30:39 <dons> it doesn't really behave like the rest of the pattern language, which isn't nice
10:30:55 <int-e> syntaxfree: A feature should be justified by a big class of use cases where it actually simplifies code, to warrent the extra complexity of the compiler and the extra effort needed to fully learn the language.
10:30:57 <dons> it's rarely used, and sufficiently weird, that people don't like it.
10:31:03 <dons> right
10:31:04 <SamB> especially the compiler part
10:31:22 <dons> so these days we go for minimal changes, with maximum impact
10:31:23 <syntaxfree> the first thing that attracted me to haskell was the mathematical-like syntax.
10:31:25 <int-e> syntaxfree: me I don't see a code simplification here so the feature only complicates the language for no reason.
10:31:30 <SamB> think about how much it would complicate the compiler code, compared to how little it is used
10:31:31 <dons> rather than adding lots of things that do very little
10:31:35 <CosmicRay> Lemmih: I've checked out hide but I can't see where it references ghc-plugins.
10:31:37 <SamB> and how often it is forgotten
10:31:42 <syntaxfree> x_{n+1} = f(x_n)  is something you'll see in mathematical writing often.
10:31:50 <dons> ghc-plugins, CosmicRay?
10:31:57 <SamB> well, in writing yes
10:31:59 <dons> do you mean ghc-api, or hs-plugins?
10:32:10 <CosmicRay> ghc-api
10:32:12 <int-e> syntaxfree: tell that a computer scientist, he'll laugh (well, I do.) ;-)
10:32:14 <SamB> but in haskell code? rarely.
10:32:15 <CosmicRay> sorry
10:32:26 <dons> i'm not sure Lemmih has committed that code yet. he may have
10:32:35 <CosmicRay> ah
10:32:38 <dons> if you peek in yiBase you'll see the Visual haskell lexer though
10:32:46 <dons> which is sort of torn out of ghc
10:32:55 <dons> which we use for syn hl
10:33:01 <CosmicRay> so what all fun things could I do with ghc-api?
10:33:03 <dons> (more excellent Lemmih hacking)
10:33:21 <CosmicRay> I'm having a bit of trouble wrapping my head aroudn what it does, vs. what hs-source or ghc-source does.
10:33:21 <int-e> syntaxfree: but that's about the only justification the feature has - to be able to write down primitive recursion just like the examples in the literature.
10:33:26 <dons> ok. so you have a src buffer, and you have access to the lexer, parser, and type checker. as well as bulid system, module info and more.
10:33:47 <dons> what fun things *couldn't* you do! ;)
10:33:50 <shapr> hiya tirkal, learning Haskell?
10:33:53 <CosmicRay> ah, so it's like hs-source, plus type checking?
10:34:04 <tirkal> shapr: intrigued by it :)
10:34:07 <sylvan> syntaxfree, but you can just as well write x_n = f(x_{n-1})
10:34:07 <dons> right. and say, dependency info
10:34:13 <CosmicRay> nifty.
10:34:14 <shapr> tirkal: Have any questions?
10:34:24 <CosmicRay> dons: where would I start reading docs about it? ;-)
10:34:35 <dons> also, it has access to the package system
10:34:46 <dons> the Visual Haskell paper perhaps?
10:35:10 <dons> they use much the same system for their fancy haskell dev environment.
10:35:17 <tirkal> shapr: well, one: is it true you can implement continuations inside the language itself (not needing a change in the platform/interpreter/compiler)?
10:35:27 <dons> which we want to embrace, extend and ..
10:35:36 <dons> oh, release a free version of. that's right.
10:35:38 <Kirby> ewww
10:36:08 <shapr> tirkal: Sort of, yeah. There are several ways of looking at that.
10:36:30 <SamB> @index callCC
10:36:32 <lambdabot> Control.Monad.Cont
10:37:01 <tirkal> shapr: interesting. I'll look into that. thanks :)
10:37:04 <[Blownose]> is it possible to type-convert something in haskell like if  hn is a type wich represent 1/2 ... and i have 1/2 and want to make it to the type that hn is ?
10:37:07 <syntaxfree> sylvan: well, that's actually x_n = f\left( x_{n-1}\right)
10:37:15 <syntaxfree> sylvan you want your parentheses to look right.
10:37:18 <shapr> tirkal: There's a continuation monad, there's mutual recursion via laziness, and threads are coroutines by default. So it depends.
10:37:34 <syntaxfree> well, I have one more idiotic question.
10:37:48 <SamB> well, Control.Monad.Cont uses multi-parameter type classes, but apparantly thats all
10:37:52 <syntaxfree> will a "let" expression be lazily evaluated as well?
10:38:01 <syntaxfree> or is it more like scheme's let?
10:38:14 <SamB> everything that isn't strict is lazy
10:38:16 <shapr> Laziness means that stuff like the same fringe problem are easily solved in Haskell.
10:38:37 <dons> [Blownose], I think you're describing a dependent type system, where values can be encoded in types. some of this is possible in Haskell, yes.
10:39:12 <dons> check out papers mentioning "types" from the last couple of Haskell workshops, for more info :)
10:39:20 <SamB> [Blownose]: you'll want to talk to look for stuff by oleg, methinks ;-)
10:40:26 <[Blownose]> hmm.. how do i convert an Int to a Float ?
10:40:27 <dons> Oleg, also Chung-Chieh Shan
10:40:40 <dons> @hoogle Int -> Float
10:40:42 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
10:40:42 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
10:40:42 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
10:40:59 <dons> @hoogle+
10:41:01 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
10:41:01 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
10:41:01 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
10:41:05 <dons> @hoogle+
10:41:06 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
10:41:06 <lambdabot> Prelude.encodeFloat :: Integer -> Int -> a
10:41:06 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
10:41:15 <dons> we have lots of a -> b functions :)
10:41:26 <SamB> oleg is the one I always think of when I am wondering about crazy computations in the type system ;-)
10:41:33 <syntaxfree> encodeFloat looks like it, but what are the two arguments?
10:42:33 <dons> nah, try realToFrac
10:42:47 <dons> @eval realToFrac 0 :: Float
10:42:49 <lambdabot> 0.0
10:43:00 <[Blownose]> ok
10:44:51 <shapr> I think encodeFloat is for IEEE 754 floating point numbers.
10:45:11 <syntaxfree> @eval [ (^) x y | (x,y) <- zip [1,2,3] [4,5,6]]
10:45:12 <lambdabot> [1,32,729]
10:45:27 <[Blownose]> hmm but why does (realToFrac(1/2)) work but not (realToFrac(1/d)) if d is an int with number 2 ? =)
10:45:52 <syntaxfree> @eval [ (^) x y | x <- [1,2,3] | y <-[4,5,6]]
10:45:53 <lambdabot> 18: Illegal parallel list comprehension: use -fglasgow-exts
10:46:08 <dons> oops
10:46:17 <syntaxfree> :~
10:46:20 <dons> try a ,
10:46:33 <syntaxfree> oo, it works.
10:46:47 <syntaxfree> can I use the haskellbot without flooding the channel in a private chat window?
10:46:52 <shapr> yup
10:47:10 <sethk> that's a good question.  How do you do it?
10:47:34 <shapr> sethk: Do you mean how to privately message lambdabot?
10:47:40 <sethk> yes
10:48:00 <shapr> Most irc clients have a "/query" command that opens a new window just for private messages with one person/client.
10:48:08 <shapr> You can probably use "/query lambdabot"
10:48:23 <dons>     or /msg
10:49:32 <sethk> hm, I did /msg and I see >lamdabot<  and   @eval xxx         (the eval I typed, of course) but no answer
10:49:59 <CosmicRay> nickserv filtering?
10:50:07 <dons> are you a registered user?
10:50:15 <dons> stupid freenode
10:50:37 <shapr> Has someone registered lambdabot's nick? It expired since I last did.
10:50:57 <dons> yes, but maybe the passwd got droopped if he reconnected. checking..
10:51:16 <shapr> Ah, he's online.
10:51:17 <dons> looks fine.
10:51:35 <sethk> dons, I'm registered, yes.  I'm an admin on some other channels and all that works
10:51:51 <sethk> CosmicRay, I am not doing nickserv filtering.  At least, not intentionally  :)
10:52:33 <dons>  /msg works for me
10:52:51 <syntaxfree> metoo
10:53:03 <dons> try @bot or @version
10:53:18 <rep> @ghc
10:53:20 <lambdabot>  panic! (the `impossible' happened, GHC version 6.4)
10:53:35 <dons> :) tht's a good thing
10:54:08 <syntaxfree> what is the impossible?
10:54:28 <dons> things which cannot happen
10:54:32 <CosmicRay> sethk: it's on by default on freenode
10:54:42 <CosmicRay> sethk: the problem is that lambdabot isn't registered.
10:54:43 <xerox> @ghc
10:54:45 <lambdabot>  GHC stack-space overflow
10:54:55 <dons> no, it is registered CosmicRay,
10:54:56 <syntaxfree> @bot
10:55:03 <CosmicRay> oh, never mind then.
10:55:05 <lambdabot> :)
10:55:12 <sethk> @eval 1+2
10:55:14 <lambdabot> 3
10:55:18 <sethk> ok, that's good.  :)
10:55:22 <CosmicRay> @eval pi
10:55:24 <lambdabot> 3.141592653589793
10:55:31 <syntaxfree> @eval exp(pi*i)
10:55:32 <sethk> must be something here.
10:55:32 <lambdabot> 25: Not in scope: `i'
10:55:55 <dons> hmm, I should fix the regexes since updating to 6.5
10:56:00 <Kirby> @eval exp(pi*sqrt(-1))
10:56:10 <dons> column numbers are sneaking in.
10:56:18 <syntaxfree> cool!
10:56:20 <syntaxfree> @jargon Haskell
10:56:58 <lambdabot> NaN
10:57:02 <dons> hehe
10:57:02 <lambdabot> No match for "Haskell".
10:57:10 <syntaxfree> @jargon LISP
10:57:12 <lambdabot> *** "LISP" jargon "Jargon File (4.3.1, 29 Jun 2001)"
10:57:12 <lambdabot> LISP n. [from `LISt Processing language', but mythically from `Lots
10:57:12 <lambdabot> of
10:57:12 <lambdabot>  Irritating Superfluous Parentheses'] AI's mother tongue, a language
10:57:12 <lambdabot>  based on the ideas of (a) variable-length lists and trees as
10:57:14 <lambdabot> fundamental
10:57:16 <lambdabot>  data types, and (b) the interpretation of code as data and vice-
10:57:18 <lambdabot> [30 @more lines]
10:57:20 <syntaxfree> STOP.
10:57:21 <sethk> @jargon lambda
10:57:24 <lambdabot> No match for "lambda".
10:57:31 <sethk> @jargon ocaml
10:57:33 <lambdabot> No match for "ocaml".
10:57:40 <sethk> needs some work here, guys.  :)
10:57:44 <syntaxfree> it's the jargon file thing. Not very Haskell-ish.
10:57:45 <sethk> @jargon clean
10:57:47 <lambdabot> *** "clean" jargon "Jargon File (4.3.1, 29 Jun 2001)"
10:57:47 <lambdabot> clean 1. adj. Used of hardware or software designs, implies `
10:57:47 <lambdabot> elegance
10:57:47 <lambdabot>  in the small', that is, a design or implementation that may not
10:57:47 <lambdabot> hold any
10:57:49 <lambdabot>  surprises but does things in a way that is reasonably intuitive
10:57:51 <lambdabot> and
10:57:53 <lambdabot> [8 @more lines]
10:58:07 <dons> sethk, use a private window. or doesn't that work for you?
10:58:12 <sethk> dons, doesn't work
10:58:18 <sethk> that's why I asked
10:58:32 <dons> weird.
10:58:32 <sethk> I'll give it up for now.
10:59:10 <syntaxfree> @karma syntaxfree
10:59:10 <lambdabot> You have a karma of 0
10:59:17 <CosmicRay> @karma cosmicray
10:59:18 <lambdabot> cosmicray has a karma of 0
10:59:42 <CosmicRay> dons: those icfp slides were impressive, especially the line graph
10:59:50 <CosmicRay> dons: where the haskell teams were just about always on top
10:59:53 <syntaxfree> anyone wants to exchange some #haskell karma for Slashdot karma?
11:00:02 <CosmicRay> heh
11:00:07 <CosmicRay> @karma cosmicray++
11:00:09 <dons> yeah, haskell is good for writing spec-compliant, non-crashing software
11:00:11 <lambdabot> cosmicray++ has a karma of 0
11:00:15 <CosmicRay> bah
11:00:19 <CosmicRay> @help karma
11:00:20 <lambdabot> return a person's karma value
11:00:22 <syntaxfree> @karma++ cosmicray
11:00:23 <lambdabot> cosmicray's karma raised to 1.
11:00:23 <CosmicRay> @help
11:00:24 <dons> and for dealing with specs that suddenly change
11:00:24 <lambdabot>  @help <command> - ask for help for <command>
11:00:29 <CosmicRay> ah there we go.
11:00:29 <syntaxfree> jesus, anyone can do it.
11:00:35 <CosmicRay> syntaxfree: yup
11:00:48 <dons> whereas perl was bad for dealing with changes to the spec, from what it looked like
11:00:49 <CosmicRay> syntaxfree: so, uhm, sure ;-)
11:00:53 <syntaxfree> dons: I thought Haskell was good for writing functional programs.
11:00:56 <CosmicRay> slashdot karma is jsut about as useful as this kind
11:01:04 <CosmicRay> dons: it's good for writing programs.
11:01:08 <CosmicRay> s/dons/syntaxfree/
11:01:27 <Pistahh> @karma lambdabot
11:01:28 <lambdabot> lambdabot has a karma of 3
11:01:36 <dons> it's the kinda stuff Launchbury's been saying for years now
11:01:48 <syntaxfree> 2:56 PM  lambdabot: You can't change your own karma, silly   :(
11:01:48 <CosmicRay> syntaxfree: read this: http://www.perl.com/pub/a/2005/09/08/autrijus-tang.html?page=2
11:01:51 <CosmicRay> it's written by a perl hacker.
11:02:01 <syntaxfree> cosmicray: I posted that on the channel the other day ;-)
11:02:06 <CosmicRay> syntaxfree: ahh
11:02:18 <CosmicRay> autrijus is great.
11:02:20 <xerox> Where can I find info about STM?
11:03:02 <musasabi> The STM paper?
11:03:19 <xerox> So it is not implemented yet?
11:03:21 <sylvan> @where STM
11:03:22 <lambdabot> I know nothing about stm.
11:03:28 <sylvan> xerox, sure it is!
11:03:42 <xerox> Uh!  I think the paper is a good source :-)
11:03:43 <sylvan> http://research.microsoft.com/Users/simonpj/papers/stm/
11:04:30 <xerox> Thanks.
11:04:32 <syntaxfree> "Indeed, you can ask a bot on #haskell to turn programs to its most abstracted form for you"
11:04:33 <musasabi> How to teach lambdabot new where locations?
11:04:37 <syntaxfree> what's the command?
11:04:41 <xerox> With @where+
11:04:42 <syntaxfree> @help where
11:04:43 <lambdabot>  @where <key>, return element associated with key
11:04:51 <xerox> With @where+ key value
11:05:00 <adept> @help where+
11:05:02 <lambdabot>  @where+ <key> <elem>, define an association
11:05:40 <int-e> @where+ STM http://research.microsoft.com/Users/simonpj/papers/stm/
11:05:41 <lambdabot> stm ~> http://research.microsoft.com/Users/simonpj/papers/stm/
11:07:15 <xerox> sylvan: so it is implemented as a GHC module?
11:07:40 <dons> and some new primops underneath
11:08:00 <syntaxfree> hehehe.
11:08:01 <syntaxfree> http://www.cafepress.com/pugscode.28778050
11:08:02 <sylvan> yes
11:08:30 <xerox> dons: how is it called?
11:08:47 <sylvan> http://www.haskell.org/ghc/docs/latest/html/libraries/stm/Control.Concurrent.STM.html
11:09:15 <sylvan> you may need to add "-package stm" if you're not compiling with "--make"
11:09:26 <xerox> One should add 'refer to the paper [url] for some doc :D'
11:09:31 <xerox> Anyway, pizza !
11:09:53 <syntaxfree> @where pizza
11:09:54 <lambdabot> I know nothing about pizza.
11:10:04 <Pistahh> xerox: just don't let the pizza eat you! :)
11:10:40 <syntaxfree> @fact pizza
11:10:40 <lambdabot> I know nothing about pizza.
11:10:54 <syntaxfree> @fact+ pizza Eat pizzas, but don't let'em eat you.
11:10:55 <lambdabot> I know nothing about pizza.
11:11:09 <syntaxfree> @fact++ pizza Eat pizzas, but don't let'em eat you.
11:11:10 <lambdabot> I know nothing about pizza.
11:11:20 * syntaxfree breaks down crying
11:12:17 <adept> xerox: you know, in the Soviet Russian pizza eats you
11:12:19 * adept hides
11:12:59 <syntaxfree> @karma-- adept
11:13:07 <int-e> @help @fact-set
11:13:29 <lambdabot> adept's karma lowered to -1.
11:13:33 <lambdabot>  @help <command> - ask for help for <command>
11:13:41 <int-e> @help fact-set
11:13:42 <lambdabot> Define a new fact, guard if exists
11:16:50 <basti_> back
11:18:26 <Kirby> @fact pizza
11:18:28 <lambdabot> pizza: Eat pizza, but don't let it eat you..
11:19:06 <Kirby> the syntax is "@ fact-set name <entry>"
11:19:37 <Pistahh> @fact recursion
11:19:38 <lambdabot> recursion: recursion.
11:20:09 <Kirby> where's the termination condition? :)
11:20:31 <syntaxfree> Haskell supports infinite lists, therefore infinite recursion,
11:20:42 <Pistahh> @take 10 recursion
11:20:43 <lambdabot> Maybe you meant: state type
11:24:00 * shapr boings cheerfully
11:24:29 <shapr> hiya Trixsey|Laptop
11:24:41 <shapr> Learning Haskell?
11:25:07 <palomer> man, I wish my school would have used haskell instead of sml for this class
11:25:08 <Trixsey|Laptop> hey
11:25:11 <Trixsey|Laptop> well.. I planned to look at it when I got the time :)
11:25:16 <Trixsey|Laptop> im learning alot atm
11:25:48 <Trixsey|Laptop> Java, PHP, MySQL, Photoshop (are the computer related courses im doing atm)
11:25:56 <basti_> courses about Photoshop?
11:25:59 <Trixsey|Laptop> ofc
11:26:03 <Trixsey|Laptop> digital design
11:26:05 <basti_> ohh
11:26:06 <basti_> okay
11:26:07 <basti_> i see
11:26:15 <basti_> you should have a look into hscairo then
11:26:16 <syntaxfree> I had a course in computer graphics.
11:26:33 <basti_> ...or gimp, but theres no haskell in gimp afaik
11:26:34 <syntaxfree> we didn't use computers at all, we just studied the mathematical models behind the stuff.
11:26:45 <basti_> thats a wise idea.
11:26:47 <syntaxfree> by the end of two months, I understood Photoshop perfectly.
11:27:12 <Trixsey|Laptop> actually photoshop, illustratr etc
11:27:15 <Trixsey|Laptop> illustrator
11:27:27 <Trixsey|Laptop> =)
11:27:34 <syntaxfree> Haha. http://haskell.org/hawiki/HowToReadHaskell
11:27:34 <Kirby> @eval let f 1 = 1; f n = if ( n == -100 ) then f 100 else 1 + f (n-1) in f 0
11:27:36 <lambdabot> 200
11:27:46 <Trixsey|Laptop> By the way
11:28:08 <Trixsey|Laptop> where is haskell more suitable than java, cpp, php etc?
11:28:17 <Kirby> @eval let f 1 = 1; f n = if ( n == -100 ) then f 100 else 1 + f (n-1) in f 1
11:28:19 <lambdabot> 1
11:28:26 <Kirby> @eval let f 2 = 2; f n = if ( n == -100 ) then f 100 else 1 + f (n-1) in f 1
11:28:28 <lambdabot> 201
11:28:29 <SamB> Trixsey|Laptop: well, playing with EDSLs ;-)
11:28:37 <Trixsey|Laptop> Whats that?
11:28:39 * Trixsey|Laptop blushes
11:29:03 <SamB> Embedded Domain Specific Languages
11:29:30 <syntaxfree> Haskell supports higher-order functions.
11:29:31 <basti_> Kirby: you can do that all for yourself with a haskell interpreter
11:29:36 <adept> Kirby: btw, what about that task? have you got the final answer?
11:29:43 <syntaxfree> I don't know how anyone manages to get anything done without higher-order functions.
11:29:56 <Kirby> adept: you mean the task of seeing if I came up with a combination?
11:29:58 <SamB> syntaxfree: yeah, me neither!
11:30:05 <adept> Kirby: yep
11:31:05 <Kirby> adept: I will use a Map in Haskell. I will use two 64 bit numbers (representing the items in group1 and group2 respectively--using the least significant 42 bits) to make a hash in C.
11:31:12 <syntaxfree> really. I think I would have become a programmer if I had known about higher-order functions back when I was considering it.
11:31:28 <adept> Kirby: really, this seems like overkill
11:31:39 <basti_> i knew there was something missing in usual languages
11:31:46 <Kirby> adept: why's that?
11:31:46 <basti_> since i learned BASIC
11:31:52 <shapr> Trixsey|Laptop: I'd say that Haskell is good for (almost) any situation if you have intelligent motivated programmers. In my experience, Haskell allows me to write new software and add new features faster than any other language.
11:31:57 <basti_> there was a hole where hof's should have gone
11:31:59 <adept> syntaxfree: other people have Design Pattern and other obscure stuff to compensate for absence of HOFs
11:32:17 <SamB> I thought HOFs were a design pattern
11:32:19 <shapr> Speaking of which, I keep meaning to write a TMR article about how to implement the common Design Patterns in Haskell.
11:32:55 <Trixsey|Laptop> shapr: If haskell is better, howcome C#, Java and C++ are more established?
11:32:58 <Trixsey|Laptop> Haskell is new?
11:32:59 <adept> shapr: i'd like to second that. I often prototype in haskell even if it's my task to develop something. (f.e., i have to write specs)
11:33:11 <Trixsey|Laptop> or there are alot of stupid programmers out there who are too noob for haskell? :D
11:33:21 <adept> Trixsey|Laptop: one word: marketing
11:33:35 <Trixsey|Laptop> oh ok
11:33:59 <shapr> adept: Me too, I write my Python/SQL/etc code in Haskell first so I don't screw up the design.
11:34:12 <adept> shapr: SQL?
11:34:29 <shapr> Have you used HaskellDB?
11:34:32 <adept> shapr: like in 'select * from * where * connect by *'? :)
11:34:35 <Kirby> adept: why is it overkill?
11:35:00 <SamB> yeah, haskell has been striving against success for years ;-)
11:35:13 <adept> shapr: no, not really. I haven't been able to install it on deb unstable. Waiting while they finish zillions of transitions which are underway now.
11:35:37 <shapr> adept: If I implement something in HaskellDB first, sometimes I find an unexpected but simpler solution.
11:35:37 <adept> Kirby: interfacing with C for such task is an overkill for me. Unless you want to study FFI
11:35:58 * adept tries apt-get install haskelldb once again
11:36:00 <syntaxfree> I don't understand how the heck PHP became so important.
11:36:04 <Kirby> adept: C and Haskell are two separate implementations of my program, not interfaced with each other.
11:36:08 <shapr> syntaxfree: Because even a monkey can use it.
11:36:19 <adept> shapr: can I solicit some examples once I have it running
11:36:28 <syntaxfree> shapr: Well, the same thing applies to Python, yet.
11:36:31 <shapr> But seriously, PHP is a domain specific language. It's really good at doing one thing.
11:36:51 <syntaxfree> what thing?
11:37:02 <basti_> failing?
11:37:11 <bojohan> sucking?
11:37:13 <shapr> Well, HTML processing
11:37:17 <basti_> .)
11:37:22 <Kirby> HTML generation most often
11:37:33 <shapr> PHP has a few large chunks, so it's easy to learn.
11:37:51 <basti_> adept: i compiled haskelldb myself. It was a nightmare.
11:37:52 <syntaxfree> Python is easier/better than PHP for that.
11:38:06 <shapr> Smalltalk is totally in the other direction, many small chunks. You need to know the names of all the Smalltalk functions to work efficiently.
11:38:47 <shapr> In my opinion, this is a point in favor of domain specific languages.
11:38:57 <adept> shapr: idiomatic programming, yes
11:39:03 <shapr> right, exactly.
11:39:10 <shapr> I think our job as programmers is to write tools for the domain experts to use.
11:39:13 <syntaxfree> shapr: so, what are these Design Patterns you speak of?
11:39:22 <shapr> syntaxfree: Have you heard of the book "Design Patterns" ?
11:39:27 <syntaxfree> nope.
11:39:33 <syntaxfree> I'm not a programmer, I'm a Domain Expert :)
11:39:37 <adept> syntaxfree: and "gang-of-four"?
11:39:39 <shapr> http://c2.com/cgi/wiki?DesignPatternsBook
11:40:50 <adept> syntaxfree: try to google for "dylan design patterns" and look for presentation which show how popular OO design pattern simply does not exist in Dylan word because in reality they are cludges. Fascinating reading, if you have some experience with patterns.
11:41:01 <adept> ^word^world&
11:41:19 <[Blownose]> if i have a file namned aComp.lhs and i want to use function autoC in it...   what do i do then.. ?   add  > module aComp [autoC]  in the lhs file and then import aComp   in the other file ?
11:42:02 <syntaxfree> shapr and adept: thanks!
11:42:05 <syntaxfree> @karma++ adept
11:42:05 <lambdabot> adept's karma raised to 0.
11:42:08 <syntaxfree> @karma++ shapr
11:42:10 <lambdabot> shapr's karma raised to 9.
11:42:15 <adept> [Blownose]: yep
11:42:26 <[Blownose]> wont work :/
11:42:39 <palomer> Trixsey|Laptop: using haskell to solve certain types of problems requires much more knowledge than solving those same problems with other languages. However, solving the problems with haskell assures that you know exactly what problem your solving and increases the chance that you get the solution right
11:43:12 <adept> [Blownose]: module name should be upcased. Then, "module AComp(autoC) where autoC=..." and "import AComp" should work
11:43:13 <Trixsey|Laptop> oh ok.. so thats why alot of univs teach haskell then? :p
11:43:25 <[Blownose]> ah
11:44:03 <adept> Trixsey|Laptop: another reason for haskell is that it's easier to bridge the gap between theory (typed lambda calculus, f.e.) and practice
11:44:09 <shapr> autrijus and I talked about implementing the GoF patterns in Haskell -  http://64.233.183.104/search?q=cache:o4MbBLGgHJsJ:tunes.org/~nef/logs/haskell/05.06.22+shapr+visitor+pattern+haskell+composite&hl=en
11:44:20 <syntaxfree> I find that Python is the easiest for just exploring ideas. But I'm not too proficient in Haskell yet.
11:44:30 <Trixsey|Laptop> theory and practice?
11:44:39 <adept> Trixsey|Laptop: yes
11:44:40 <Trixsey|Laptop> what you mean? theory would be pseudo?
11:44:48 <palomer> haskell has surprisingly little to do with typed lambda calculus
11:45:07 <palomer> except, mayhaps, syntax
11:45:24 <adept> palomer: yes, but typed LC stuff could be directly projected to haskell. On the contrary. try to do that in C :)
11:45:58 <palomer> adept: that's a grammatical issue, imo
11:46:12 <adept> palomer: I only wish that in my uni I had haskell to experiment during "theory of computation" classes
11:46:27 <shapr> I think Haskell is just lambda calculus with a bit of sugar on top.
11:46:54 <adept> palomer: no, not only. Conside tagged unions, f.e. And try to find them in mainstream languages.
11:48:11 <adept> shapr: read that link about patterns. Exactly to the point.
11:48:21 <palomer> adept: right, the function from LC code to C code would involve inserting function calls everywhere
11:49:02 <shapr> I'd like to write a TMR article about that, though I think I'll just write one on software testing with Haskell for now.
11:49:19 <palomer> adept: but this morphism is stable
11:49:34 <[Blownose]> does my module name has to have the same name as my filename ?? i have module AutoC (filename autoC) and in my other file i use import AutoC and it says cant find module
11:49:41 <adept> palomer: aha! you said "morphism" first, not me :)
11:49:53 <adept> [Blownose]: yes
11:50:04 <palomer> adept: I use morphism loosely, I mean computable function from one language to the other
11:50:15 <adept> [Blownose]: otherwise you would have to maintain that mapping elsewhere, which would be a pain
11:50:21 <shapr> pain :: C -> Haskell
11:50:27 <Oejet> dons: In Yi typing / or : in command mode and then tab repeatedly displays: user error (Curses[-1]:waddnstr).
11:50:28 <adept> :)))))))))))))))))
11:51:01 <xerox> extraPain :: [C] -> Haskell
11:51:01 <palomer> is yi coming along nicely?
11:51:13 <adept> palomer: but deep down in your heart you agree with me, dont you? :)
11:51:48 <palomer> adept: no!
11:52:08 * adept sighs
11:53:00 <palomer> I do find haskell cool though, does that count?
11:53:08 <araujo> yes
11:53:15 <araujo> It couns more than something else
11:53:16 <araujo> :-]
11:53:20 <araujo> Hello all!
11:55:59 <shapr> hiya albertelegance, learning Haskell?
11:56:20 <xerox> Hello shapr, teaching Haskell?
11:57:01 <Blastur> hey everyone, just a tad to eager to talk about Haskell??
11:57:37 <shapr> Blastur: I had a job writing Visual Basic for awhile, I wouldn't wish that on anyone.
11:57:56 <Blastur> VB is ok
11:58:06 <Blastur> so is Haskell
11:58:09 <xerox> It is not, I have to do it at school :(
11:58:26 <xerox> ...or at least had.
11:58:32 <shapr> I had a job working on 65,000 lines of VB4 for trust management.
11:58:52 <xerox> Urrgggh.
11:59:00 <Blastur> let me guess, you could rewrite it to 5 lines of code if they had only let you use Haskell?
11:59:03 <shapr> I bet I could have rewritten the whole app in less than 2000 lines of Haskell.
11:59:10 <Blastur> i knew it
11:59:24 <Blastur> it's always about lines of code
11:59:31 <shapr> Nah, it's about programmer time.
11:59:43 <syntaxfree> I'd like Visual Basic if it supported higher-order functions.
11:59:43 <shapr> and speed of change... that's how you make money.
11:59:44 <xerox> 'Lines of code' in Haskell have a deeper meaning.
11:59:59 <shapr> Blastur: Hey man, I'm self-employed and self-taught :-P
12:00:06 <adept> ... and ease of maintenance
12:00:12 <Blastur> shapr: thats cool
12:00:16 <palomer> my main beef with non ml/haskell languages is lack of datatypes
12:00:17 <shapr> Och jag kommer frn USA ocks :-)
12:00:27 <Blastur> i'm neither!
12:00:35 <shapr> Men Boden r s trevligt.
12:00:43 <adept> shapr: i'll start talkin in koi8-r if you will use swedish :)
12:00:46 <syntaxfree> shapr: so how do you make your money?
12:00:51 * shapr grins
12:00:54 <xerox> Programming!
12:01:15 <adept> xerox: Programming ATMs ;)
12:01:18 <Lunar^> CosmicRay: there?
12:01:21 <[Blownose]> if i have data`s declared in the file i want to export from. And i want to use them to call functions from the file i import my export file from how do i do then ? hmm little strange explenation maybe :)
12:01:34 <shapr> syntaxfree: I'm a contract programmer. Mostly I build websites. I mostly get paid to write Python for Zope/Plone, but I have had a few Haskell contracts.
12:01:42 <Blastur> shapr: yeh, you maybe want to fix that encoding script of yours if you wanna impress me with your language skills! :)
12:01:50 <palomer> haskell contracts?
12:01:52 <palomer> that's amazing
12:02:06 <palomer> what kind of application domain?
12:02:08 <shapr> palomer: Not really. Most clients just want results, at a lower cost.
12:02:08 * araujo would like to be self-employed too
12:02:15 <xerox> I got a grant from Google to code Haskell!
12:02:17 <shapr> Blastur: r utf-8 bttre?
12:02:21 <adept> [Blownose]: do you look for "module Foo(CoolDataType(...)) where ..."? First ellipsis is literal and should be put there to export all constructors of the datatype
12:02:23 <araujo> shapr, any advice that might help me? :-)
12:02:38 <syntaxfree> shapr: do you have any kind of degree in something computer-related?
12:02:57 <Blastur> so what kind of customers orders haskell apps? i thought it was only used as prototyping, education and, maybe by the geeky people who writes OpenGL apps and webservers, in haskell.., as a proof-of-concept :)
12:03:07 <shapr> syntaxfree: No. I took CS101 in 1992. We had IBM ROM BASIC running on real true blue IBM XTs.
12:03:08 <Blastur> shapr: nope, still the same.. 
12:03:34 <shapr> syntaxfree: I keep meaning to get a CS degree.. maybe in Lule
12:04:14 <syntaxfree> shapr: haha. I'm taking CS 101, but I ain't learning anything.
12:04:22 <shapr> araujo: If you do a good job, clients will trust you. Then they don't care how you solve their problems, as long as the solution works.
12:04:26 <syntaxfree> I'm finishing a b.sc in economics.
12:04:27 <adept> Blastur: my favorite example is me having several haskell programs which emulate obscure hardware which is programmed in it's own DLSs which is used as dev/test platform. Way easier than buying two pieces of hardware - one for testing.
12:04:35 <syntaxfree> CS 101 here = Scheme.
12:04:39 * araujo writes it down
12:05:06 <shapr> It also helps to work for very little money :-)
12:05:10 * syntaxfree would like to be a self-employed programmer too.
12:05:32 <Oejet> syntaxfree: MIT?
12:05:37 <shapr> Blastur: My customers don't order Haskell apps. They ask me to solve their problems. They rarely care how those problems are solved.
12:05:38 <[Blownose]> adept: like this >module AComp (autoC, bStyle) where          and   data bStyle = Basic | blabla derivning(Show,Eq)
12:05:41 * adept was a programmer and now wants something a tad different
12:05:50 <syntaxfree> how likely is it that I can actually make a living outside the US, being a contractor for american companies?
12:06:05 <Blastur> shapr, okay.. thats fair enough I guess
12:06:08 <shapr> Blastur: I do charge by the amount of time it took me to solve their problem. If I can write one solution in half the time it takes to write some other solution, clients often choose the cheaper solution.
12:06:09 <syntaxfree> Oejet: I'm in Brazil. I study at PUC-Rio. We're the ones who came up with Lua.
12:06:22 <adept> syntaxfree: in my country, it's a common thing. We even outsource _for_ India :)
12:06:29 <shapr> haha!
12:06:38 <Oejet> syntaxfree: You know the GoboLinux guys?
12:06:47 <syntaxfree> I know one of them, Hirscham.
12:06:58 <shapr> adept: What do you want now?
12:07:00 <adept> [Blownose]: if you want to construct bStyle instabces outside of AComp module, you need "module AComp(bstyle(...))"
12:07:10 <syntaxfree> I don't know how associated with PUC-Rio is GoboLinux. Hirscham happens to work there.
12:07:38 <syntaxfree> Lua was developed here, though.
12:07:58 <adept> shapr: I dont really know. I am systems analyst for telecoms company now. With programmer/PM/consult experience under the belt. But I want more independence and more creativity.
12:08:06 <Oejet> syntaxfree: You Brazilians know some tricks.
12:08:41 <shapr> adept: Maybe your employers should ask you bigger questions?
12:08:56 <adept> shapr: ha!
12:09:04 <adept> shapr: no, even "HA!"
12:09:07 <[Blownose]> hmm adept like this    function AComp(bstyle(Basic)) moreargs
12:09:13 <syntaxfree> Oejet: we also have a big time kernel hacker, Marcelo Tosatti.
12:09:30 <syntaxfree> he was the maintainer of Linux for a while.
12:09:38 <adept> [Blownose]: then you will be able to construct only "Basic" instances, not "blabla"
12:09:40 <shapr> Quite seriously... maybe your employers should ask you something like "What are your suggestions for improving our telecom?"
12:10:12 <shapr> adept: or maybe you should start your own company.
12:10:15 <syntaxfree> actually, he's still the maintainer of the 2.4 family.
12:10:30 <[Blownose]> hmm but whats the diffrence if i use module or import ... i use import now
12:10:31 <adept> shapr: i have a strong opinion that in companies that surpass some certain size, any good advice is doomed by design
12:10:50 <shapr> adept: I agree. I think maximum size is eight people, and that optimum size is four people.
12:11:03 <adept> shapr: it's too messy to start own business unfortunately :( too much time to spend for administration issues.
12:11:09 <shapr> I think companies should operate like jazz bands.
12:11:14 <adept> shapr: how about 3000+ ppl? :)
12:11:20 <shapr> ouch
12:11:34 <adept> shapr: exactly
12:12:02 <Blastur> [Blownose]: wasn't that assignment due last Monday? :)
12:12:27 <Philippa_> adept: cue the "lots of little companies" approach
12:13:02 <Philippa_> I guess it does have the advantage that it's very, very clear when someone's screwed up because there're contracts defining what "screwed up" means...
12:13:08 <syntaxfree> adept: so, how do you get started as a self-employed outsorced programmer?
12:13:57 <adept> syntaxfree: i only wish to.
12:13:59 <adept> syntaxfree: but wait.
12:14:35 <adept> syntaxfree: i was self-employed outsourced sysadm once. Job found me (not vice-versa) through "old boys network"
12:14:52 <syntaxfree> adept: so, how do \textbf{I} get started, etc. etc.
12:15:02 <adept> syntaxfree: ah
12:15:22 <adept> syntaxfree: best if you dont have family, mortgage and kids. It really helps.
12:15:41 <adept> syntaxfree: then, you do some stuff for free.
12:16:01 <shapr> I only have a girlfriend.
12:16:07 <adept> syntaxfree: then, friends and friends of friends ask you for bigger stuff and you charge them
12:16:24 <adept> syntaxfree: then, one day you have a portfolio to impress customers.
12:16:44 <adept> syntaxfree: and energy to do "pilot projects" and win their trust
12:17:04 <adept> syntaxfree: after certain moment, you could have more work offers than you are able to handle
12:17:16 <adept> that's one of the ways
12:17:36 <Philippa_> to emphasise, what this means is you work 60+ hour weeks repeatedly for little pay for a long time
12:17:50 <adept> usually, it is enough to wish strong enough. Synergy will do the rest. Like' you'll find like-minded people, get connections, ...
12:18:22 <adept> Philippa_: yes. That's where young age, and no (family/kids/...) helps especially
12:18:44 <Philippa_> that's... pushing it a little. You have to have a certain degree of social skill, for example, and it helps a lot to catch the crest of a rising technology
12:19:05 <Philippa_> odds are most people in here'll catch the crest of at least one at some point in their lives, mind
12:19:16 <adept> Philippa_: whell, only if you want to "contract for technology'
12:21:33 <Philippa_> if you're going into an established field the competition is much much harder
12:21:56 <Philippa_> sure, you can also use an incoming tech to just allow you to do the job better or faster...
12:22:01 <shapr> Does anything other than HUnit and QuickCheck fit into software testing with Haskell?
12:22:06 <adept> Philippa_: I have a friend that runs small "IT emergency room" company which steps in and does a make-shift solution in projects where actual solution is overdue or at risk, or will not be delivered in full. Usually customers are happy that "something works" and does not pay attention what kind of stuff is inside :)
12:22:41 <shapr> adept: Oh, that sounds like the perfect place for Haskell.
12:23:16 <Philippa_> adept: you still need a suitable tech to allow you to pull that off
12:23:26 <Philippa_> and yeah, Haskell is at least part of it IMO :-)
12:23:29 <adept> shapr: they usually do integration-level stuff, but yes, Iagree with you :)
12:23:58 <syntaxfree> I have a girlfriend.
12:23:58 <syntaxfree> She doesn't expect me to support her yet.
12:23:58 <syntaxfree> I also did some stuff for my parents.
12:23:59 <syntaxfree> But I'm not very proud of it.
12:24:03 <syntaxfree> It's PHP+MySQL stuff, very by-the-numbers.
12:24:07 * syntaxfree is awful at finding connections and meeting people.
12:24:10 <shapr> syntaxfree: We all start somewhere.
12:24:18 <shapr> I started with Visual Basic.
12:24:23 <shapr> But I got better!
12:24:26 <Philippa_> VB? Luxury!
12:24:36 <Philippa_> I was taught Turbo Pascal, but my earliest personal-use hacks were in QBasic
12:24:37 <adept> I started with FoxPro (i think)
12:24:55 <xerox> I never understand FoxPro
12:25:01 <shapr> My first code was on a Sinclair Spectrum. My first paying jobs were VB.
12:25:06 <xerox> What was it about?
12:25:08 <Philippa_> I learnt doing-pascal-properly and C pretty much on my own still as a kid, then moved onto C++. Ran into Java at uni and covered a little Haskell in my second semester
12:25:09 <shapr> I wish I'd know about Haskell then.
12:25:56 <Oejet> shapr: Haskell implementations weren't so extensive then.
12:26:35 <SamB> what was the problem with Turbo Pascal?
12:26:38 <adept> syntaxfree: a good example of power of connection is "linkedin.com"
12:26:40 <Philippa_> yeah, they've only really become useable for many classes of work in the time I've been using it
12:27:45 <shapr> adept: Are you on linkedin.com?
12:27:55 <adept> shapr: yep.
12:28:00 <Itkovian> evening
12:28:06 <pejo> SamB, it was Pascal? :-)
12:28:20 <SamB> pejo: er, was it truly?
12:28:21 <Philippa_> SamB: I didn't know it well enough initially. Oh, and it wasn't the best pascal for low-level hackery on the class of PC I was working on by the time I was looking at it again
12:28:41 <Philippa_> it was a lot more capable than the original versions. Not completely wirthless
12:28:59 <SamB> Philippa_: I'll admit it does seem rather 16-bit
12:29:05 <SamB> but at least it is very consistant
12:29:24 * adept feels like frowning in nostalgia 
12:29:27 <Philippa_> more generally I just wouldn't want to work in a pascal variant now
12:29:42 <Philippa_> the only time I'd consider it I'd only be using it as a C-like language anyway
12:29:51 <adept> ^frowning^drowning^
12:29:55 <SamB> You have a point there.
12:31:25 <Philippa_> C has a certain basic honesty in that regard
12:42:06 <syntaxfree> someone here once told me about a 5-point rule for numerical differentiation.
12:42:33 <syntaxfree> I've been working all day on stability tests for numerical differentiation rules.
12:42:58 <syntaxfree> the three-point rule seems to perform better on polynomials and such, but the two-point rule will still be better when trig is involved.
12:43:24 <basti_> hmm
12:43:36 <basti_> actually thats an extreme topic.
12:44:13 <[Blownose]> when you use zip you take a list [A,B,C] and zip it on [D,E,F]   is it possible to do this      [A,B,C] zip on [A,[B,C], D]   and i want A-A  B-[B,C] and C on D ?
12:44:43 <basti_> [Blownose]: uhm. you probably want to look into list monads or comprehensions.
12:46:28 <lisppaste2> syntaxfree pasted "stability test for numerical differentiation rules" at http://paste.lisp.org/display/12055
12:46:41 <Itkovian> how does one say "eventueel" in english?
12:47:07 <xerox> Do you remember where it is that graph of the Prelude Classes?
12:47:12 * Itkovian is correcting some text, but the many mistakes are messing his brain up
12:47:55 <adept> xerox: Gentle Intro?
12:48:04 <xerox> Found, it's in the report.
12:49:47 <Philippa_> Itkovian: sounds like "eventually", though that could be a faux ami for all I know
12:50:14 <Philippa_> roughly synonymous with "at some point in time (possibly a fair way away)"?
12:50:25 <Itkovian> well, that's what these people thought too, but eventually means "uiteindelijk"
12:50:48 <basti_> Itkovian: more like "maybe"?
12:50:49 <Itkovian> "eventueel" is more like erm ... maybe, perhaps,
12:51:04 <Itkovian> basti_: yeah, but that doesn't cover the complete load of the word
12:51:12 <basti_> in german, "eventuell" means rather maybe too
12:51:20 <basti_> i don't find a better translation too
12:51:22 <Muad_Dibber> who talks german anyway.
12:51:46 <Muad_Dibber> i prefer to talk a bit like Itkovian does :P
12:52:08 <basti_> incoherently? :P
12:52:13 <Itkovian> hey, watch it!
12:52:24 * basti_ suggests #blah
12:52:25 <basti_> ;)
12:52:28 <Muad_Dibber> nothing to see there :P
12:55:09 <[Blownose]> hmm.. if i have a list like this [A,[B,C],D]  and i do this getDur x = [length(y) | y <-x]  i get [1,2,1]  what i want is [1,2,2,1] can i do that ?
12:55:53 <adept> [Blownose]: and what do you expect for [A,[[B,C],D],E]?
12:56:15 <[Blownose]> hmm cant happen
12:56:34 <int-e> how can you have a list like [A,[B,C],D] ?
12:56:54 <basti_> that depends entirely on A and D.
12:56:55 <basti_> :D
12:56:55 <Oejet> Hey, boegel|home.
12:56:56 <adept> int-e: that's another question entirely :)
12:57:08 <[Blownose]> ahh sorry adept...  [[A],[B,C],[D]]
12:57:14 <[Blownose]> i ment like that
12:58:17 <int-e> you're looking for getDur x = [n | y <- x, n <- replicate (length y) (length y)] ?
12:58:20 <basti_> @plugs  map ((\x->replicate x x).length) [[1],[2,3],[4]]
12:58:21 <lambdabot> [[1],[2,2],[1]]
12:58:24 <basti_> something like that?
12:58:56 <int-e> @eval let getDur x = [n | y <- x, n <- replicate (length y) (length y)] in getDur [[1],[2,3],[4,5,6]]
12:58:58 <lambdabot> [1,2,2,3,3,3]
12:59:05 <[Blownose]> @plugs concat(map ((\x->replicate x x).length) [[1],[2,3],[4]])
12:59:07 <lambdabot> [1,2,2,1]
13:00:22 <[Blownose]> @plugs concat(map ((\x->replicate x x).length) [[1],[2,3,5],[4]])
13:00:23 <lambdabot> [1,3,3,3,1]
13:02:13 <Itkovian> hi boegel
13:05:30 <int-e> eek.
13:06:07 <int-e> @eval let getDur x = do { t<-x; let { n=length t }; replicate n n } in getDur [[1],[2,3,4],[5,6]]
13:06:08 <lambdabot> [1,3,3,3,2,2]
13:07:43 <basti_> next question: whats that for?
13:12:42 <Cale> @eval [[1],[2,3,4],[5,6]] >>= (\x -> let n = length x in replicate n n)
13:12:44 <lambdabot> [1,3,3,3,2,2]
13:12:57 <boegel|home> hey Oejet
13:13:01 <boegel|home> oh, he left already
13:13:59 <int-e> Cale: yeah, but do notation is concise and intuitive. *ducks and hides*
13:20:30 <wilx> Why the t<-x;? Shouldn't it work without it?
13:21:37 <basti_> wilx: t<-x is something else than let t=x
13:22:00 <shapr> hiya delYsid!
13:22:08 <shapr> delYsid: wassup?
13:23:07 <wilx> Ok, but the x is visible in the do, isn't it?
13:23:26 <wilx> Why should he need to rebind it like that?
13:23:33 <basti_> because it's a list?
13:23:45 <basti_> [inside the monad]
13:23:55 <int-e> wilx: it's not a rebinding. x is an instance of the Monad
13:24:38 <wilx> @eval let getDur x = do { let { n=length x }; replicate n n } in getDur [[1],[2,3,4],[5,6]]
13:24:40 <lambdabot> [3,3,3]
13:24:43 <wilx> Hmm.
13:24:46 <wilx> Interesting.
13:24:46 <boegel|home> CosmicRay: nice work on HWN :)
13:25:10 <int-e> wilx: it does the same as Cale's version - only using do notation.
13:25:37 <wilx> Hmm, I think I see the difference now.
13:25:39 <wilx> Yup.
13:26:02 <int-e> wilx: his x is my t.
13:29:44 <basti_> are you talking bad handwriting now or what?
13:31:00 <delYsid> shapr: hi!
13:31:25 <shapr> delYsid: wassup?
13:31:30 <delYsid> shapr: Hanging out here since I've got a bit tricky programming problem and wonder if I should perhaps relook at haskell and use it for this one
13:32:09 <delYsid> shapr: how are you doing?
13:32:58 <retepybrik> delYsid: I saw your code on sourceforge for doing a minimax search with alphabeta pruning in Haskell.
13:34:06 <delYsid> PeterK: Yeah, and since this problem is somehow related, I wonder if I should try doing some haskell code again...
13:34:58 <delYsid> shapr: http://www.international-lisp-conference.org/2005/media/mastenbrook-audio.mp3  <-- I thought of you when I listened to that...
13:34:59 <PeterK> delYsid: what's the copyright status of that file (minimax with alphabeta in Haskell)? I'd like to 'cannibalize' it for my free software project.
13:35:57 <delYsid> IANAL...
13:36:11 <PeterK> delYsid: did you write it?
13:36:13 <delYsid> I basically stole the framework for the function from this FP paper
13:36:29 <PeterK> oh, maybe I should roll my own then.
13:36:29 <delYsid> but if that doesnt count then consider it GPL
13:37:03 <delYsid> but the FP paper had the code in erm, how was that haskell predecessor called?
13:37:13 <delYsid> so, yeah, I actually wrote it :)
13:38:05 <PeterK> oh, then maybe I will use it. thanks.
13:38:54 <delYsid> Anyway, now I want to write a program which transforms a musical piece into the best possible tablature for guitar...
13:38:54 <Philippa_> delYsid: Miranda?
13:39:11 <delYsid> I.e., it will have to do perform a search as well, considering physical movement costs...
13:39:25 <delYsid> Philippa_: no, Gofer
13:39:36 <delYsid> or suchlike
13:40:08 <Philippa_> ah, one of the closer predecessors. Gofer was often mostly-Haskell anyway, they even coexisted for a while when gofer was a testbed for type system extensions that did weird things
13:42:37 <sethk> delYsid, there is no best possible tabulature.
13:42:41 <palomer> gofer?
13:42:46 <palomer> isn't that the protocol from the 80's
13:43:08 <palomer> delYsid: I'm working on music too
13:44:40 <Philippa_> palomer: that too
13:45:53 <delYsid> sethk: If I weight each individual movement and add them up, I am petty sure there will be one, or at least just a few candidates
13:46:09 <sethk> delYsid, what would constitute "best"?
13:46:19 <delYsid> sethk: cheap
13:46:30 <sethk> that's very unlikely to be the best sounding
13:46:31 <delYsid> in terms of movement
13:46:44 <sethk> you wouldn't actually want to play that way
13:47:41 <palomer> delYsid: do you know if anyone has written a best fingering algorithm for music pieces?
13:48:12 <delYsid> palomer: dunno, maybe some commercial tab program?
13:48:32 <delYsid> sethk: I'm not that convinced what you say is really true...
13:48:41 <sethk> oh, it definitely is
13:48:51 <sethk> just take a look at some examples of what good players actually do
13:48:55 <delYsid> sethk: But the algo should be parametrized anyway, so "good sound" could just be an option :)
13:49:03 <palomer> delYsid: piano fingering
13:49:16 <palomer> delYsid: does your algo take in midi files?
13:49:24 <delYsid> palomer: That should be relatively simple to do, shouldnt it?
13:49:42 <delYsid> palomer: I plan to do it like that, yes
13:50:33 <delYsid> sethk: Give me a concret example of where the obvious way to make a note play is the wrong one.
13:51:17 <sethk> well, take a look at the tab for just about anything by Normal Blake
13:51:33 <delYsid> Say you want 64, that would be either open e, b on 5th or g on 9th, but does it really matter?
13:51:42 <sethk> delYsid, oh, absolutely, it matters
13:51:48 <sethk> completely different sound
13:51:59 <sethk> delYsid, whether you pull or hammer of pluck the string
13:52:17 <palomer> delYsid: should it be simple? a team in brazil used a funky genetic algorithm to accomplish it
13:52:18 <delYsid> I know...
13:52:21 <sethk> delYsid, very different sound
13:53:07 <palomer> delYsid: actually, you could also use a genetic algorithm to establish the tablature
13:53:19 <sethk> delYsid, also, there is a major difference in how you play based on the size of a players hand
13:53:27 <sethk> delYsid, whether the left hand thumb is used
13:53:44 <sethk> delYsid, how close together the strings are on a particular instrument
13:54:04 <delYsid> yes yes, thats the cost of movement thing
13:55:03 <delYsid> well, well, if I think about bwv1006a, I can think of several places where it wouldnt suffice to just do fretlogic to get the best arrangement...
13:55:14 <delYsid> but still, it would be very interesting to implement and see what it does
13:55:50 <sethk> delYsid, interesting, perhaps.  We'll see what it does
13:56:06 <sethk> delYsid, attempts to mechanize music have rarely been worthwhile
13:56:35 <delYsid> sethk: I am well aware of that, its a bit of a pointless exercise.
13:56:43 <sethk> delYsid, ok.  :)
13:56:49 <delYsid> A good guitar player shouldnt even need tablature to start with
13:56:58 <palomer> http://gsd.ime.usp.br/sbcm/2003/papers/rAlexandre_Viana.pdf <---these guys took a sample of 10,000 midi files and their corresponding fingerings, and produced an alogrithm to get the best fingering
13:57:17 <palomer> maybe you could do the same thing with tablatures?
13:57:26 * shapr boings
13:57:42 <delYsid> shapr: Listened to the climacs thing yet ? :)
13:57:43 * Muad_Dibber boings back
13:57:59 <shapr> Listening to a part of it now.
13:58:48 <delYsid> If I could use McCLIM, I'd switch *NOW*
13:58:53 <delYsid> but hey, thats how it goes.
13:59:02 <shapr> You know me, I prefer Haskell.
14:01:14 <shapr> delYsid: So far, this sounds like the kind of editor I want.
14:02:59 <sethk> now my PM with lambdabot is working.  I wonder why it wasn't before.
14:04:10 <Blastur> @eval [1..]
14:04:11 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
14:04:11 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
14:04:11 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
14:04:11 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
14:04:11 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
14:04:13 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
14:04:15 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
14:04:17 <lambdabot> [24 @more lines]
14:04:20 <Blastur> damn
14:04:31 <Blastur> :)
14:06:48 <palomer> @[1..]
14:06:49 <lambdabot> Unknown command, try @listcommands.
14:07:33 <Pistahh> @eval 1/0
14:07:35 <lambdabot> Infinity
14:07:49 <Pistahh> @eval _|_
14:07:50 <lambdabot> 19: parse error on input `|'
14:07:54 <Pistahh> @eval bot
14:07:55 <lambdabot> 18: Not in scope: `bot'
14:08:03 <Pistahh> @eval x == x
14:08:05 <lambdabot> 18: Not in scope: `x'23: Not in scope: `x'
14:20:32 <xerox> Goodnight.
14:22:21 <musasabi> night
14:22:56 <delYsid> shapr: thought so
14:23:06 <delYsid> shapr: whats up with Yi?
14:26:19 <shapr> delYsid: good stuff
14:26:30 <poetix> I see that Haskell is the tool of choice for discriminating Hackers this year
14:27:48 <nothingmuch> hi
14:28:05 <nothingmuch> i'm working through the WhyAttributeGrammarsMatter thing on the wiki
14:28:09 <nothingmuch> and I have a few questions
14:28:31 <nothingmuch> in the SEM of res on list, is   | Nil    lhs.res = List_Nil, | Cons   lhs.res = List_Cons (@head - @lhs.avg) (@tail.res)
14:28:49 <nothingmuch> considered good behavior? or is there a better way to specify 'List_Nil' and 'List_Cons'?
14:28:58 <nothingmuch> also, how do i get an attribute of a current node, not a child or a parent?
14:29:41 <nothingmuch> and lastly, after i've generated a .hs, is there any way to add a 'deriving show' to the data type, besides editing the .hs file, preferably in ghci?
14:31:49 <autrijus> nothingmuch: "current node" being @lhs ?
14:32:07 <autrijus> nothingmuch: you can derive show adhocly withou DrIFT.
14:32:17 <autrijus> s/withou/with/
14:32:23 <nothingmuch> hmm
14:32:34 * nothingmuch will google for docs in a second
14:33:26 <nothingmuch> as for  "current node"... take a list, e.g. Root( Cons( 1, (Cons 2 Nil) ) )
14:33:47 <nothingmuch> SEM Root     lhs.res = @list.res
14:34:01 <nothingmuch> SEM List
14:34:12 <nothingmuch> Cons   lhs.res = (@head - @lhs.avg) ...
14:34:27 <nothingmuch> is @lhs.avg on the current node? or on the root?
14:34:51 <nothingmuch> for the node (Cons 1 (...))
14:36:58 <nothingmuch> also, how would I define attributes on the "real" haskell list?
14:37:03 <Blastur> @eval f 9999999 where f 0 = 1; f a = f (a-1) * f (a-2) * f (a-3)
14:37:05 <lambdabot> 28: parse error on input `where'
14:37:17 <nothingmuch> i don't see how to fit circumfix syntax into the attr stuff
14:39:12 <autrijus> SEM (:)
14:39:15 <autrijus> or something. not sure
14:39:23 <nothingmuch> okay
14:41:07 <nothingmuch> is there any way to get uuag to generate convenient functions for attrs? i see it generates e.. 'sem_Data -> Data  -> (( type of attr #1 ), ...)'
14:41:22 <autrijus> nothingmuch: I'm not sure... mail the author?
14:41:54 <araujo> Hello.
14:42:02 <autrijus> yo.
14:42:35 <nothingmuch> *Diff> let ((l)) = sem_Root (Root_Root (List_Cons 1 (List_Cons 2 (List_Cons 3 List_Nil))))
14:42:42 <nothingmuch> wee!
14:42:47 * nothingmuch actually got it right
14:45:34 <nothingmuch> can you leave the node constructor thingamabob's untyped?
14:45:50 <autrijus> try and see?
14:46:04 * nothingmuch only asks after trying and not being able to naively
14:49:23 <int80_h> If I could only install ghc on OSX I would be a happy happy man
14:50:02 <integral> the binary pkg that's on the download pages works a treat for me
14:50:24 <autrijus> ...unless your OSX is not on powerpc
14:50:29 <autrijus> in which case I have a binary for you :)
14:50:46 <int80_h> well right now I think it wants me to update darwinports. is there a way around darwinports?
14:51:38 <integral> *blink* the .pkg isn't listed on the download page :-/
14:51:54 <int80_h> I was getting all kinds of darwinports troubles last attempt. I figure making sure it's updated is the way to go. Unless I don't need to use it at all, even better
14:52:13 <int80_h> integral, have an alternative location?
14:52:26 <integral> ah, I got it from email, it's at: http://www.uni-graz.at/imawww/haskell/GHC-6.4.1.pkg.zip
14:52:32 <integral> [http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/8706]
14:53:09 <nothingmuch> wow, ags are nice
14:53:09 <integral> that just dumps ghc into /usr/local, and pops a folder linking to docs (etc) in Applications
14:53:41 <nothingmuch> uuagc -f -c Diff.ag -> Diff.hs
14:53:47 <nothingmuch> then i :%s/Cons/(:)/gc
14:53:54 <nothingmuch> and :%s/Nil/[]/gc
14:53:59 <int80_h> sweet
14:54:02 <nothingmuch> and define Root
14:54:07 <nothingmuch> and *Main> sem_Root (Root [1 .. 5])
14:54:08 <nothingmuch> [-2.0,-1.0,0.0,1.0,2.0]
14:54:23 * nothingmuch is pleased
14:54:35 <nothingmuch> autrijus: thanks again for AGs
14:55:07 <autrijus> no prob :)
14:55:08 <basvandijk> Hi guys, how can I rewrite this function so that is uses currying instead of naming all the arguments?
14:55:09 <basvandijk> sphere :: QuadricStyle -> Radius -> Slices -> Stacks -> Geometry
14:55:09 <basvandijk> sphere style radius slices stacks = Quadric style (Sphere radius slices stacks)
14:55:30 <autrijus> nothingmuch: you can do another talk with the title "safe sex with 70s technology" ;)
14:55:36 <integral> basvandijk: currying or points-free?
14:55:43 <nothingmuch> 70s technology?
14:55:48 <autrijus> @pointless  sphere style radius slices stacks = Quadric style (Sphere radius slices stacks)
14:55:49 <lambdabot> sphere = (. Sphere) . (.) . (.) . Quadric
14:55:57 <integral> sphere style = Quadric style . Sphere
14:55:58 <autrijus> nothingmuch: AG is 70s technology, matured in 80s, ignored in 90s
14:56:03 <nothingmuch> hehe
14:57:36 <basvandijk> actually I have multiple functions like sphere that take a different number of arguments. for example I also have:
14:57:36 <basvandijk> cylinder :: QuadricStyle -> Radius -> Radius -> Height -> Slices -> Stacks -> Geometry
14:57:36 <basvandijk> cylinder style base top height slices stacks = Quadric style (Cylinder base top height slices stacks)
14:57:52 <nothingmuch> it's like the Foxy Admins with Vintage Hardware page on unixsex.com
14:59:15 <integral> basvandijk: can't they all just be \style -> Quadric style . Cylinder ?
14:59:32 <basvandijk> Mmm lets try that
15:02:05 <basvandijk>  integral: sphere :: QuadricStyle -> Radius -> Slices -> Stacks -> Geometry
15:02:05 <basvandijk> sphere = \style -> Quadric style . Sphere
15:02:05 <basvandijk> ghci gives the follwing error:
15:02:05 <basvandijk> Couldn't match `QuadricPrimitive' against `t -> t1'
15:02:05 <basvandijk> Expected type: QuadricPrimitive
15:02:06 <basvandijk> Inferred type: t -> t1
15:02:08 <basvandijk> Expected type: Radius -> QuadricPrimitive
15:02:10 <basvandijk> Inferred type: Radius -> Slices -> Stacks -> QuadricPrimitive
15:02:12 <basvandijk> In the second argument of `(.)', namely `Sphere'
15:03:10 <integral> ok, I must be wrong, I've never got the hang of . with multiple args
15:05:45 <basvandijk> BTW data Geometry = ... | Quadric QuadricStyle QuadricPrimitive | ...
15:06:38 <basvandijk> and QuadricPrimitive comes from HOpenGL: data QuadricPrimitive = Sphere . . . | Cylinder . . . . . . | etc.
15:14:05 <Sickjacken> what are (a,b,c,d) things called? quadruples?
15:14:33 <palomer> 4-tuples
15:14:59 <Sickjacken> hmm what a dissappointment
15:15:06 <Sickjacken> -s
15:16:44 <wilx> Hmm, quadruple sounds sane to me.
15:16:57 <palomer> never heard it before
15:17:08 <palomer> quintuple
15:17:14 <palomer> no wait, that's 5
15:32:06 <Lemmih> 'morning, #haskell.
15:56:27 <nothingmuch> does anybody have a link to an introduction to Hindley Milner type inferrence with language suitable for ignoramouses?
16:35:30 <Lemmih> dcoutts: ping.
16:50:17 <shapr> @YOw!
16:50:17 <lambdabot> Unknown command, try @listcommands.
16:50:21 <shapr> @y0w!
16:50:22 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN
16:50:22 <lambdabot> RIVERS
16:50:22 <lambdabot> in a $200,000 MALIBU BEACH HOUSE!!
16:50:42 <shapr> Pseudonym: comonads are popular lately.
16:51:09 <Pseudonym> Apparently!
16:51:15 <Pseudonym> Even better if they work, I guess. :-)
16:58:26 <int-e> Argh, printing large integers in Haskell (with ghc/ghc libs) is horribly inefficient. (it extracts the digits one after the next by division by 10, instead of using a divide and conquer approach; it takes ~60 seconds to print a 200k digit number here while a proper implementation (still in plain Haskell) takes 0.6 seconds ... (the gmp builtin version beats that by another factor of 1.5)
16:58:39 <int-e> ))
17:03:30 <Pseudonym> You bet it is.
17:03:42 <Pseudonym> It's hard to benchmark large integer code because of it.
17:03:48 <Pseudonym> BTW, if you can think of a better algorithm...
17:04:46 * int-e will make a version that drops into the ghc libs.
17:05:53 <Pseudonym> I've had code where it took a minute to compute a number and an hour to print it out.
17:07:10 <int-e> Pseudonym: heh. that reminds me, the 0.6 seconds include the calculation (of the 1000000th fibonacci number)
17:10:57 <rep> int-e what's the divide and conquer appoarch
17:11:41 <int-e> rep: calculate a big enough power of 10 to approximately divide the number into two halves of the same side then print each smaller one - that's the basic approach
17:13:16 <rep> o i c
17:27:42 <bojohan> "printing large integers" reminds me too... http://www.dd.chalmers.se/~bojohan/emacs/img/2.png
17:31:59 <ulph> Hm
17:32:32 <bojohan> sorry :/
17:33:18 <ulph> :)
17:40:09 <int-e> Hehe, I think I just beat gmp's implementation in Haskell :)
17:49:36 <lispy`> int-e: are you familar with Paul Cull's work?
17:49:48 <lispy`> he's done a bunch of things with fib numbers
17:49:48 <int-e> lispy`: no.
17:50:32 <int-e> http://www.inf.tu-dresden.de/~bf3/PrintBigNumbers.hs <-- comments welcome
17:51:42 <int-e> I guess I'll add a few more comments. Hehe.
18:00:52 <int-e> ok added a few comments to
18:00:56 <int-e> http://www.inf.tu-dresden.de/~bf3/PrintBigNumbers.hs :-)
18:36:40 <JohnMeacham> hello
19:07:19 <JohnMeacham> aha!
19:07:37 <JohnMeacham> the error in jhc corrupting code is in the float inward translation
19:08:12 <JohnMeacham> so do '-fno-float-in' and it should produce non-buggy code. though, the bug is hard to trigger to begin with.
19:08:51 <JohnMeacham> and float-inward is one of the most important optimizations, so I will fix it.
19:42:18 <tennin> can this be a place to ask general category theory questions?
19:42:45 <sethk> tennin, sure.  you may or may not find an answer... :)
19:43:19 <tennin> as with most things...
19:43:50 <sethk> I won't know the answer, but there are more knowlegeable people about, usually
19:45:15 <lispy> tennin: #math does pretty good with category theory i think
19:45:22 <lispy> tennin: so if no one here knows...
19:46:55 <Cale> tennin: question?
19:46:59 <tennin> anyway, is it correct that there's no reason I can't have a category with a morphism, call it id', that behaves identically to the identity morphism when composed with any other morphism but the identity morphism itself, i.e. f . id' = f for all f except when f = id, in which case id . id' = id'
19:47:32 <Cale> tennin: sure
19:47:49 <tennin> hmm
19:48:03 <Cale> just take the single object category with two arrows.
19:48:09 <Cale> id and id'
19:48:50 <Cale> and define id' . id' = id'
19:50:52 <tennin> i'm using a 1986 book called "Algebraic Approaches to Program Semantics".  The explanations and progression/choice of material seem to my liking but when I try to do the chapter-end exercises some of them just don't seem right, i.e. I can find what appear to be counterexamples to some of the things they want me to prove
19:51:11 <wagle>  Arbib?
19:51:15 <tennin> yes
19:51:54 <tennin> do you have the book?
19:51:55 <wagle> i keep meaning to read that..  lately been wondering how dated it is (and why its out of print, etc)...was it recommended to you?
19:53:00 <wagle> yeah, i have it..  but its not high on my reading list..
19:53:15 <sethk> its out of print because the number of people studying category theory is, unfortunately, rather small
19:53:37 <int-e> . o O ( no concatMap, no dropWhile *hacks* *continues compiling ghc* )
19:53:49 <tennin> no, it just happens to be the only book in my university library's CS selection that covers what I want to learn
19:54:34 <wagle> it looks pretty decent..  its just that other cat theory books are ahead of it in line
19:55:46 <wagle> barr and wells 3rd edition is what i'm working through..  i like it a lot..  they've really wrung it through a lot of csci students, and anticipate are the questions
19:56:00 <wagle> ... all the questions
19:56:17 <wagle> 3rd edition is a little hard to get, though
19:56:27 <wagle> not very expensive though
19:56:47 <sethk> delYsid, I thought of what might be a more interesting problem, although fundamentally I have the same objections to it.  How about calculating the optimal tuning?
19:57:02 <sethk> delYsid, as I said it has the same objections, but it has the advantage that the solution is not obvious
19:59:12 <Kirby> taking a break from anything difficult... I implemented "99 bottles of beer on the wall" in Haskell: http://rafb.net/paste/results/VrqE9G49.html
20:00:04 <sethk> Kirby, I must be missing something, I can't imagine what there is to implement.  :)
20:00:49 <Kirby> lol, see http://www.99-bottles-of-beer.net/
20:01:53 <sethk> Kirby, I'm not sure I like things forced to upper case here   :)
20:02:13 <Kirby> whatcha mean?
20:04:56 <sethk> Kirby, sorry, I was putting on a string.   The capitalize function in your paste
20:06:32 <Lemmih> Kirby: capitalize (x:xs) = toUpper x : xs
20:07:13 <Kirby> is that different? better?
20:07:19 <lispy> beers 0 = "no more ..."; beers 1 = "1 more ..."; beers n = show n++...
20:07:28 <sethk> functionally the same.  I would expect it to be more efficient
20:07:35 <lispy> Lemmih: i think that has a bug, right?
20:07:53 <Lemmih> lispy: How so?
20:07:54 <Kirby> ah, I see seth. but, no bug, no.
20:07:54 <lispy> oh, n/m
20:08:03 <lispy> i see it just means to capitalize the first letter
20:10:36 <tennin> the Arbib exercise in question defines a "totalizer" (don't know whether this is a widely used term) for a morphism f:X->Y in a category with a family of zero-morphisms as a morphism t:T->X such that (a) f.t is total, i.e. f.t.x /= 0 for all x /= 0, and (b) if some other morphism u:U->X such that f.u is total exists in the category, then there is a unique a:U->T such that t.a = u
20:10:52 <tennin> then it wants you to prove that any two totalizers in a given category are isomorphic
20:11:36 <tennin> I can prove it for e.g. sets and partial functions, but I can't prove it for the general case and in fact suspect that it's not true for the general case.
20:11:42 <tennin> but maybe I'm missing something.
20:13:57 <tennin> er, sorry, not that the totalizers themselves are isomorphic, but that the "a" is an isomorphism
20:15:25 <tennin> obviously, if there are two totalizers t and u, then not only is there an "a" s.t. "t.a = u" but there's also a "b" s.t. "u.b = t"
20:16:40 <tennin> so "t.a.b = t" and "u.b.a = u" and since "a" and "b" are unique, "a.b.a = a" and "b.a.b = b" also must hold
20:17:03 <tennin> but this doesn't seem to be enough by itself to prove that "b.a = id"
20:22:07 <tennin> sorry, i'm not sure how best to communicate sentences with mathematical notation over IRC
20:22:49 <lispy> use latex :)
20:24:46 <lispy> i wish irc had structured text or latex add-ons
20:24:50 <tennin> yeah
20:26:02 <lispy> man, this granola has corn puffs and dried cranberries.  It's so good!
20:26:04 <lispy> low fat too
20:26:04 <tennin> i don't know the latex code for the compose operator, though
20:26:15 <lispy> \circ, iirc
20:27:55 <tennin> $t\circ a\circ b = t$ ... hmm doesn't quite have the same flow
20:29:24 <tennin> otoh, i was already using a monstrous pseudo-math pseudo-Haskell hybrid, i could just extend that to pseudo-math pseudo-Haskell pseudo-latex and type $t.a.b = t$
20:30:47 <lispy> heh
20:31:32 <lispy> \begin{eqnarray*} ...
20:31:51 <tennin> ...
20:32:17 <lispy> i was just thinking about other cumbersome latex things you could use
20:32:36 <tennin> I know!  I'll just put everything in XML!  =P
20:32:45 <lispy> there is mathml
20:32:55 <lispy> but i think mathml is discusting
20:32:59 <lispy> disgusting
20:39:29 <tennin> something like... <mathematical-notation><equation><left-hand-side><function-composition><outer-function>t</outer-function><inner-function><function-composition><outer-function>a</outer-function><inner-function>b</inner-function></function-composition></inner-function></left-hand-side><right-hand-side>t</right-hand-side></equation></mathematical-notation>
20:45:39 <tennin> er... i guess that's not really funny because you can't parody something that parodies itself
20:49:46 <lispy> heh
20:49:51 <lispy> so true
21:02:01 <tennin> so... the problem seems to come down to, even if $a.b$ and $b.a$ behave exactly like $id$ (except when composed with $id$), they could still be distinct morphisms
21:03:51 <tennin> or should that be $\id$ ?  $\hbox{id}$ ?  hmm...
21:04:55 <Pseudonym> I can basically do anything that I want for a week EXCEPT what I was hired to do.
21:05:00 <Pseudonym> So long as I turn up.
21:05:21 <Pseudonym> Whoops.
21:05:26 <Pseudonym> Didn't meant to say that here. :-)
21:05:35 <Pseudonym> But yes, I get paid to do nothing next week.
21:06:19 <tennin> is this good or bad?
21:06:43 <Pseudonym> I feel bad for everyone else on my team who are one hand short.
21:07:26 <Pseudonym> But I get to do what I want for a week, so that's kinda cool.
21:07:57 <tennin> a friend of mine spent several months of work time surfing the web and playing solitaire, because for reasons of corporate politics she wasn't allowed to do her job
21:08:19 <Pseudonym> Yeah, that's the situation I'll be in.
21:08:23 <Pseudonym> Until it's resolved.
21:08:34 <Pseudonym> Not corporate politics, though.  It'll be for legal reasons.
21:08:51 <Pseudonym> But I think I'll be hacking on open source projects instead of playing solitaire.
21:08:58 <Pseudonym> Gotta keep the brain busy.
21:09:07 <tennin> she got to be really, really, really good at solitaire
21:09:50 <JohnMeacham> hmm.. actually it is an interaction between rules and floating inward. interesting.
21:10:08 <Pseudonym> Anyway.
21:11:35 <Pseudonym> So, at least I have access to the university library still.
21:11:40 <Pseudonym> I can get some serious reading in.
21:18:46 <Korollary> Pseudonym: Is it about patents ?
21:58:54 <int-e> Pseudonym: I have a patch for ghc for speeding up printing large integers (against ghc 6.4[.1] and tested - ghc compiles, test program compiles and flies :) if you're interested; http://www.inf.tu-dresden.de/~bf3/ghc/ghc-6.4.1-show-integer.patch
22:08:47 <Pseudonym> Cool.  But there's not a lot I can do with it. :-)
22:08:55 <Pseudonym> Did you test how much it slows down small Integers?
22:10:06 <int-e> No. The code is virtually the same for integers <10^8 though (using single precision division instead of long division though - so I'd expect a small speedup)
22:10:19 * Pseudonym nods
22:10:34 <Pseudonym> Sounds cool.  Submit it!
22:10:46 <int-e> after I get some sleep
22:11:08 <dons> int-e, and maybe quick check it
22:11:16 <dons> otherwise, nice!
22:11:33 <int-e> dons "quick check"?
22:13:40 * int-e failed to parse that.
22:14:01 <Pseudonym> I suspect that QuickCheck is going to sample small Integers by default.
22:16:00 <int-e> ah. QuickCheck makes sense.
22:17:30 <dons> at least make sure the ghc testsuite still runs through
22:17:49 <dons> (and you can always adjust the QuiickCheck sample)
22:18:13 <dons> it's just with any change this low down in the compiler, you want high assurance that the change is ok
22:18:41 <dons> so have a look at fptools/testsuite at least
22:19:21 <dons> also, benchmarks stating exactly what gets faster and by how much would be good too
22:19:51 <dons> so, in summary, testing and benchmarks :) then the change is more likely to be accepted
22:20:06 <int-e> yep. I understand that
22:21:11 * int-e Isn't sure that Quickcheck is appropriate though - it seems to be hard to get to the boundary cases using it.
22:22:27 <int-e> well, I'll see.
22:23:34 <int-e> I can certainly do more testing than I've already done. (a big fibonacci number, some numbers around +-10^8 and some around 0)
22:35:17 <dons> you can specify any cases. even hard code them
22:35:38 <dons> certainly you could test min .. max for your type, and say filter out 9/10 of those
22:35:42 <dons> or mroe
22:36:21 <dons> for example, I wanted to test only a small number of Chars:
22:36:22 <dons> instance Arbitrary Char where
22:36:22 <dons>   arbitrary = oneof $ map return
22:36:22 <dons>                 (['a'..'z']++['A'..'Z']++['1'..'9']++['\n','\t','0','~','.',',','-','/'])
22:36:25 <dons>   coarbitrary c = coarbitrary (ord c)
22:45:24 <aleator> What is the typical workflow for cabal? configure-build-install-test?
22:46:09 <dons> -haddock
22:48:04 <aleator> Ah. Do you install packages for testing them, or is there a simpler way?
22:49:15 <dons> that' usually the easiest way
22:49:22 <dons> and most portable
22:49:45 <dons> other option is to use include path hackery to your compiler
22:49:58 <aleator> Ok.. Thanks.
23:04:09 <aleator> c2hs doesn't like extern "C" ?
23:16:28 <ibid> extern "C" is C++, not C
23:16:38 <ibid> does c2hs claim to handle C++)
23:16:44 <ibid> s/)/?/
23:20:41 <ski> basti_ : OI comonad would not be contravariant
23:20:43 <aleator> No, but that would be rather reasonable extension?
23:24:03 <aleator> I'm successfully compiling c++ code in a cabal package, but name mangling stands in my way.. :/
23:26:47 <ibid> not really.  any C++ header that's supposed to be included directly to C source should protect the extern "C" by #if..#endif on __cplusplus
23:27:35 <int-e> dons: Benchmark look good here, I have speedups for all numbers I tested; the timings suggested making another special case for <=16 digits numbers which helped those a lot. More to come tomorrow. (URL for simple benchmark: http://www.inf.tu-dresden.de/~bf3/ghc/BenchJtoS.hs)
23:28:24 <int-e> dons: re QuickCheck: I can use that to test small numbers; for big numbers it seems to make more sense to just test a small interval around powers of 10 directly.
23:29:16 <aleator> ibid: It is now.. Yet I get unknown mangled symbols.
23:29:55 <ibid> i thought your problem was that c2hs doesn't like extern "C"
23:30:09 <ibid> what kind of unknown mangled symbols?
23:31:08 <aleator> ibid: It was moment ago :)
23:31:12 <aleator> ibid: HSSVM-0.1.o: unknown symbol `_ZTV6Kernel'
23:36:26 <ibid> that's the virtual table for class Kernel
23:38:02 <dons> int-e, I wonder if you can get anyything for number < 1024, or 128 (which are very common)
23:38:44 <ibid> this may explain the problem (or may not, this is possibly outdated info):
23:38:47 <ibid> "This is probably because you are missing a definition for the first (non-inline) virtual function of the class. Since gcc-2.7.0, g++ uses a trick borrowed from cfront: the .o file containing the definition for the first non-inline virtual function for the class will also contain the virtual function table."
23:40:24 <ibid> current info says about the same thing:
23:40:27 <ibid> "The ISO C++ Standard specifies that all virtual methods of a class that are not pure-virtual must be defined, but does not require any diagnostic for violations of this rule [class.virtual]/8. Based on this assumption, GCC will only emit the implicitly defined constructors, the assignment operator, the destructor and the virtual table of a class in the translation unit that defines its first such non-inline method."
23:44:37 <int-e> dons sure: I just have to generate an appropriate list. I need to sleep though.
23:44:39 <int-e> good night
23:44:53 <dons> night
23:45:36 <ibid> aleator: did it help?
23:46:07 <aleator> ibid: Not yet.. Though I've not yet grokked what that really says..
23:47:42 <ibid> you must locate the .cc or .cpp file that defines the first non-inline virtual function in class Kernel, and make sure the corresponding .o is linked
23:47:45 <ibid> in
23:48:14 <ibid> (i'm not sure what to do if all of them are inline, but...)
23:48:49 <aleator> There is only one source file..
23:50:14 <ibid> by "source file" you mean...?
23:51:42 <aleator> That the whole thing I'm wrapping has just files svm.cpp and svm.h. I mean the first of those.
23:55:11 <aleator> And that I believe that it is linked in, because corresponding c-sources tag in .cabal.
