00:07:52 * boegel bounces
00:11:02 <boegel> does anyone happen to know C.J.Burgess from Bristol University ?
00:19:23 <shapr> @yow !
00:19:24 <lambdabot> Life is a POPULARITY CONTEST!  I'm REFRESHINGLY CANDID!!
00:22:23 <Heffalump> hey shapr
00:22:28 <shapr> hiya Heffalump
00:22:31 <Heffalump> can you turn on email alerts for the Haskell wiki?
00:23:03 <shapr> Not easily.
00:23:28 <Heffalump> cos you don't know how, or cos of technical issues with where it's hosted?
00:23:29 <shapr> I'll look into it more when I'm finished moving.
00:23:35 <Heffalump> I can tell you how.
00:24:00 <shapr> Because I only have access to the 'net for a few hours a day at the moment, so I mostly do work then.
00:24:04 <Heffalump> ok
00:24:34 <Heffalump> I think I can tell you the config options for moin_config.py when you do have time to look at it
00:24:51 <Heffalump> (or I could email them to you now so you have them when convenient)
00:26:14 <shapr> Sure, which email address?
00:26:31 <shapr> $(ELEPHANT_GOD) at earth dot li?
00:28:21 <Heffalump> yes, but don't you want me to email you? :-)
00:30:45 <shapr> Ok, works for me.
00:31:17 <shapr> But I want your email address so I can whitelist it.
00:31:27 <Itkovian> http://www.apple.com/ipodnano/
00:31:29 <Heffalump> ah, right.
00:32:03 <Heffalump> firstname@dodgypun.com ?
00:32:05 <vegai> the Ipods use a nasty database for no apparent reason
00:32:09 <vegai> or does someone know a reason?
00:32:19 <Heffalump> s/com/org/
00:32:23 <vegai> I found it odd that you can't just copy your files into it
00:32:47 <tuomov> eh? I thought ipod (at least the normal one) is just a plain usb hd?
00:32:48 <shapr> That's me.
00:33:10 <vegai> tuomov: the one I tested on was a Mini. I don't know about the others
00:33:18 <tuomov> sure you can have a db for id3 tags and stuff, but it should be possible to just navigate the files
00:33:24 <tuomov> that's how my iriver ihp120 works anyway
00:33:29 <vegai> basically, you need a program that generates or updates the database in addition to moving the files
00:33:44 <mflux_> yes, ihp120 rocks.
00:33:46 <vegai> the files didn't show up on the device without the database
00:34:01 <tuomov> the device itself has the database update capability, but I don't use the db
00:34:14 <vegai> oh, that's better then.
00:34:14 <mflux_> ihp120? I don't think it does?
00:34:28 <mflux_> but there's a program on freshmeat that can write the database for you
00:34:32 <tuomov> umm.. I'm not sure..
00:34:39 <vegai> yeah, there are at least two: gnupod and gtkpod
00:34:40 <tuomov> I though it had something like that
00:34:41 <mflux_> I've never used it though (the db)
00:35:04 <tuomov> config menu -> general -> db scan
00:35:08 <mflux_> a db should speed up starting times and allow browsing by artist/genre/etc
00:35:18 <vegai> it wasn't my device though, I was just debugging it through irc.
00:35:18 <tuomov> or does that do something else?
00:35:20 <mflux_> wo/ a db you can just browse directories and files
00:35:26 <vegai> so there might have been something I missed, of course
00:35:43 <tuomov> mflux_: yep, and since id3 tags are always broken anyway, I juts browse files
00:35:59 <tuomov> e.g. they very seldom include track number, and that totally fucks up playing full albums
00:36:35 <mflux_> well, that could be fixed. I could propably use genre-playing sometimes.
00:36:46 <tuomov> I almost always play full albums
00:36:47 <mflux_> but atm I just have artist/album/nn-xxxx.(mp3|ogg)
00:37:13 <mflux_> yes, I referred to playing albums of certain genre
00:37:18 <tuomov> I have A/Artist/Album/nn-xxx.(mp3|ogg)
00:37:38 <tuomov> with A/ being the first letter of artist name
00:37:42 <mflux_> I guessed that ;)
00:37:51 <mflux_> but there's only 20 gigabytes, I don't see much advantage in that
00:38:14 <tuomov> mine has only about 15 gigabytes since I accidentally dropped it once :)
00:38:58 <vegai> heh. I'm used to mp3-players with a whopping 64-256MB of storage
00:38:59 <mflux_> my fs is a bit corrupted too, I don't dare play certain directories or I'll need to push the reset button ;)
00:39:45 <mflux_> also I would need to transfer all the stuff off before daring to run dosfsck, which said some nasty things last time..
00:39:47 <tuomov> a 20G flash player would be cool.. and expensive
00:39:54 <mflux_> maybe in 5 years
00:40:20 <vegai> perhaps in 5 years, the portable players will have no drive space at all
00:40:27 <mflux_> that would be great
00:40:33 <shapr> Heffalump: Anyway, why do you want email sending for the wiki? What's the point?
00:40:38 <mflux_> but that would propably mean you would need to stream from the operator, not from your home machine
00:40:44 <tuomov> like that's going to happen in such a way that you don't have to pay for the content
00:41:07 <vegai> well, it won't succeed if the prices are not sensible
00:41:08 <Heffalump> it allows one to subscribe to change notification for pages
00:41:17 <psi> have you guys seen the new ipod nano?
00:41:24 <psi> it's pretty neat
00:41:33 <vegai> that's what caused this discussion :)
00:41:37 <tuomov> too small for my needs, and I don't like apple design at all
00:41:45 <psi> vegai: oh :)
00:41:48 <tuomov> space-wise too small, that is
00:42:43 <vegai> a sensible price might be... 1c per listening or something like 2e per song (for permanent ownership)
00:42:49 <vegai> or what do you think?
00:43:08 <vegai> perhaps 10e/mo for unlimited listening
00:43:11 <tuomov> 0e for everything besides what I'm paying for the bandwidth already
00:43:14 <shapr> Heffalump: RSS is much better at that.
00:43:51 <tuomov> such a service is very unlikely to include all the music I want anyway, so I would need to stream it from home
00:43:53 <shapr> You could use rss2email for example.
00:43:57 <tuomov> so why bother with the service at all
00:44:07 <vegai> tuomov: how the hell could that work?
00:44:20 <vegai> 0e for everything, I mean
00:44:35 <tuomov> streaming from home..
00:44:43 <tuomov> I'm not paying n times for the same music
00:45:05 <vegai> that's why you would pay 2 euros (or something) once
00:45:28 <tuomov> for a song? never.
00:45:29 <mflux_> I suppose there would be some costs for the traffic
00:45:37 <tuomov> that's more like the price for montly subscription
00:45:38 <mflux_> if one would just use the current model
00:45:42 <vegai> are you saying that no musical piece can be worth 2 euros?
00:45:51 <mflux_> or maybe if you're in the range of some wlan ap, you could get that for a monthly roaming fee
00:46:29 <tuomov> how do I know in advance if it is worth 2 euros? and no single track ever is.
00:46:35 <banedohnh> so hey can ya do webapps in haskell?
00:46:42 <vegai> tuomov: that's why you would first pay a minimal sum to listen it first :)
00:46:48 <vegai> first first first
00:46:49 <banedohnh> can I script ftp transfers an maasage data?
00:46:57 <vegai> 1c wouldn't be too bad, would it?
00:47:12 <vegai> though I bet that's not enough for the distributing company
00:47:16 <vegai> not at first anyway
00:48:08 <tuomov> very unlikely
00:48:33 <tuomov> and it would all be drm-encumbered shit anyway that is essentially use-until-something-crashes
00:48:44 <tuomov> then-pay-us-again
00:48:46 <vegai> that's true.
00:49:09 <vegai> they'd need to trust their customers a bit more
00:49:30 <vegai> perhaps here's some room for a new company?
00:49:48 <Heffalump> like napster? :-)
00:49:54 <tuomov> with a few megacorps owning the "rights" to 99% of music?
00:49:55 <vegai> Heh. Yeah.
00:50:10 <vegai> Damnit, stop reminding me that the world sucks!
00:50:13 <vegai> :-P
00:50:41 <tuomov> with much of the music I listen to being in the 1%, though...
00:51:03 <vegai> 1% won't feed a company
00:51:05 <tuomov> and thus being less likely to even be available in such a service
00:51:26 <shapr> banedohnh: Yes, you can.
00:51:41 <vegai> otoh, this sorta thing wouldn't need much resources
00:51:54 <vegai> it would need hardware that doesn't exist...
00:52:17 <tuomov> all that is needed is wlan (and 3g?) in the player and I'd stream from home
00:52:35 <shapr> banedohnh: There are several Web app solutions, for FTP John Goerzen has a library.
00:52:58 <tuomov> no need to enforce paying to a service provider
00:53:22 <tuomov> if someone wants to provide such a service, then, please, go ahead, but let me stream from home
00:53:27 <vegai> so, you'd get your music by traditional means in the first place?
00:53:39 <vegai> well, I wouldn't want to restrict anything, that's for sure
00:53:41 <tuomov> traditional warez channels, yes :)=
00:53:46 <vegai> heh. Ok.
00:54:01 <vegai> doesn't that make your ethical stance rather weak? =)
00:54:11 <tuomov> information wants to be free
00:54:32 <tuomov> I do occasionally go buy the album if it is really good and by a smaller record company and not broken
00:54:57 <tuomov> just to show a little support for the artists... I'd rather pay them directly, though
00:55:01 <vegai> aye
00:55:59 <tuomov> and I do go to gigs quite often
00:57:04 <vegai> the free market of music seems to be completely upside down. The better pieces (like classical chamber music) are practically free
00:57:44 <tuomov> One could argue that IP is contrary to a free market
00:57:55 <vegai> It's like if kindergarten paintings costed $10000 a piece, and you could get a mona lisa for $10
00:58:07 <vegai> "costed". I'm on a roll today
00:58:13 <tuomov> but "free market" is just "sanahelinää" anyway
00:59:14 <shapr> Minä ei ymarran!
00:59:20 <shapr> And I can't spell either!
00:59:28 <vegai> I understand it as the quality of the product and its price being in full contrast
00:59:52 <vegai> which is an utopia
00:59:53 * shapr hugs Finland
00:59:58 <tuomov> the dictionary seems to translate sanahelinää to wordmongering/verbiage/froth
01:00:52 <tuomov> -ä
01:01:12 <banedohnh> I want to make money have sex adn live without stress
01:01:18 <vegai> shapr: "ei", 1st singular is "en"
01:01:25 <shapr> banedohnh: Don't we all.
01:01:27 <banedohnh> ;)
01:01:31 <shapr> vegai: Whoops, thanks.
01:01:38 <banedohnh> I evfen liek sexw ith women who most consider fat
01:01:43 <banedohnh> with stong legs and big boobs
01:01:44 <vegai> damn, Finnish is complex and weird
01:01:48 <shapr> banedohnh: Dude, waay too much information.
01:01:52 <banedohnh> :)
01:01:57 <shapr> vegai: But very very nifty
01:01:58 <banedohnh> I dont know shit of programming
01:02:01 <banedohnh> exceot bash
01:02:06 <shapr> banedohnh: So go learn more!
01:02:15 <shapr> That's how we learn Haskell and stuff like that.
01:02:18 <banedohnh> but I see lisp haskell APL and smalltalk ass supposedly best alnguages
01:02:31 <banedohnh> languages
01:02:36 <shapr> I don't think there is a single best language, but there are several good languages.
01:02:39 <banedohnh> problem: how do i learn em
01:02:44 <banedohnh> how do i apply em
01:02:45 <shapr> You jump in and try 'em
01:02:50 <shapr> You do stuff with them.
01:02:56 <shapr> Try to fill a need and you can get a job.
01:02:58 <shapr> It worked for me.
01:03:04 <banedohnh> IO got linux admin job
01:03:06 <banedohnh> got
01:03:13 <banedohnh> my cmopany starving for programming help
01:03:24 <Heffalump> don't suppose anyone is familiar with how the GHC RTS does select?
01:03:28 <banedohnh> mesy java app to control sco unix boxes ho control phonecalls
01:03:37 <banedohnh> to
01:03:47 <banedohnh> and data dumps scheduled over ftp
01:03:49 <banedohnh> ugly
01:03:54 <banedohnh> not modualrized etc.
01:04:04 <banedohnh> 40mil a year
01:04:07 <banedohnh> small telcom
01:04:10 <banedohnh> doing prisons
01:04:15 <banedohnh> www.teampcs.com
01:04:22 <banedohnh> anyone programmer watns job shuld apply
01:04:24 <shapr> banedohnh: So clean it up, make money.
01:04:33 <banedohnh> I dont know progrmain!
01:04:45 <banedohnh> does haskell work on windows XP
01:05:21 <shapr> Yes it does.
01:05:58 <shapr> One of the paradoxical things about programming is that it's best learned by doing it.
01:06:25 <z0d> why is it paradoxical?
01:06:26 <vikasg> how is that paradoxical?
01:08:01 <shapr> I guess it's not, nearly everything is best learned by doing it.
01:08:32 <shapr> I guess it's paradoxical because most institutions of learning teach students lots of theory before they get to program.
01:08:47 <shapr> I think it would make more sense to start from the other side.
01:09:24 <tuomov> eh, I think theory comes after basic programming courses usually
01:09:29 <shapr> First you get the students to write a midsized program, and then you show them research papers that they can apply to fix the problems they had.
01:09:41 <z0d> Those who are enamored of practice without theory are like a pilot who goes into a ship without rudder or compass and never has any certainty where he is going. Practice should always be based on a sound knowledge of theory --Leonardo da Vinci
01:09:47 <shapr> I want call-by-need learning.
01:10:13 <tuomov> z0d: some practical experience motivates learning theory
01:10:20 <shapr> Yeah, what he said.
01:10:27 <vikasg> that's one of the great attractions of programming to me, that a complete newbie can write a useful program after a month. Compare this to, say, physics
01:10:58 <shapr> I always try to put together furniture, etc for a bit first, and then I read the directions once I have a good idea what they pieces should do.
01:11:07 <shapr> vikasg: Newbies can still throw things :-)
01:11:54 <tuomov> maths is a better example
01:12:26 <tuomov> even there it is not strictly true that theory comes first, however
01:12:59 <tuomov> you just can't get much further than counting 1+1 without theory
01:14:03 <shapr> z0d: Though I admit that the commercial software industry of today really needs more theory.
01:14:52 <z0d> shapr: indeed
01:15:47 <tuomov> they do have some "theory", but its crappy management theory
01:16:33 <tuomov> based on the same ideas as assembly lines
01:16:51 <shapr> The eXtreme Programming stuff is neat. I'd say it's call-by-need specification and design.
01:21:11 <shapr> hej Blownose
01:21:49 <dblhelix> Blownose: havin' a cold?
01:22:00 <Blownose> yup :)
01:22:20 <shapr> Are you pejo when you're not having a cold?
01:22:34 <Blownose> ?
01:22:38 <shapr> Guess not :-)
01:22:49 <shapr> Hej Blownose, lär du dig Haskell?
01:23:04 <Blownose> mm eller försöker :)
01:23:05 <dblhelix> shapr: I sense this is an opportunity for a Tour ;)
01:23:09 * shapr grins
01:23:18 <shapr> dblhelix: In swedish even...
01:23:49 <shapr> Blownose: Har du nån frågor? Eller vill du ha links till Haskell (oh I don't know how to say "learning materials")
01:23:54 <xerox> @babel en se Welcome to the Haskell Tour 1.0
01:23:55 <lambdabot> module "babel" screwed up: Error: Language se not supported
01:24:01 * xerox boings
01:24:06 * shapr hops
01:24:15 <dblhelix> shapr: that 'd be cool... curious to find out how much I understand from a Tour in swedish
01:24:30 <xerox> @botsnack
01:24:31 <lambdabot> :)
01:24:46 <Blownose> shapr: skrev i .se men har du några bra guider så
01:24:56 <shapr> okej
01:25:04 <shapr> dblhelix: Seems the Swedish conversation will happen in #haskell.se
01:25:25 <dblhelix> xerox: do you have pets? kids? why rewarding the bot for not being helpful? :)
01:26:11 <xerox> Se deserve it anytime!
01:26:13 <xerox> *She
01:30:35 <vikasg> xerox, how goes the summer of code?
01:32:22 <ProfTeggy> G'day all.
01:32:30 <adept> z0d: commercial software industry has enough theory as it is, thank you very much. It just needs more practitioners.
01:32:40 * shapr laughs
01:32:47 <shapr> Guten morgen ProfTeggy
01:32:56 <ProfTeggy> Servus. ;-)
01:33:01 <rep> i can't handle this confusion.
01:33:08 <shapr> rep: What confusion?
01:33:15 * rep points ->
01:34:13 <xerox> vikasg: it's over!
01:35:46 <vikasg> Google said your work is ok?
01:36:12 <xerox> Still waiting.  My mentor (from Google) happened to mentor other guys too.
01:36:25 <xerox> We got a map!
01:36:43 <xerox> http://mwarden.f2o.org/socmeetup/map.php
01:36:53 * vikasg swears at his mouse
01:37:05 * boegel rewrites his proposal, once again
01:39:23 <vikasg> nice
01:39:38 <boegel> it's like the 8th time already :s
01:47:29 <xerox> boegel: for what?
01:47:47 <shapr> hiya ProfTeggy, how's research?
01:53:19 <ProfTeggy> :-)  I won't complain.  I'm a database person but I enjoy the many connections of this field with FP.
01:53:39 <ProfTeggy> Since I am into query compilation (and transformation), you can imagine the interlinks.
01:53:52 <ProfTeggy> All my prototyping is done in Haskell.
01:53:56 <shapr> nifty!
01:54:10 <ProfTeggy> (Currently an XQuery to relational algebra compiler)
01:54:31 <shapr> What do you think of the HaskellDB project?
01:55:37 <shapr> Yeah, I can imagine the interlinks. I wish HaskellDB had a query optimizer that had backend specific plugins.
01:55:52 <ProfTeggy> HaskellDB emits relational queries for combinator queries, right?
01:56:12 <ProfTeggy> I have worked in this area myself for quite some time.
01:56:22 <ProfTeggy> Esp. on monad comprehensions for DB querying.
01:56:31 <shapr> That sounds cool
01:56:45 <ProfTeggy> http://www-db.in.tum.de/~grust/files/monad-comprehensions.pdf
01:56:56 <ProfTeggy> "Monad Comprehensions. A Versatile Representation for Queries"
01:57:38 <ProfTeggy> Are you working on HaskellDB, shapr?
01:58:00 <Heffalump> ooh, barbed wire and lenses and stuff :-)
01:58:01 <shapr> I've only used HaskellDB some.
01:58:38 <ProfTeggy> Heffalump ;-)
01:58:42 <xerox> Is there a "that's how to write a parser" article on hawiki or something?
01:58:51 <shapr> I had a job years ago where we had multipage SQL queries, and I've wanted a simpler approach ever since. HaskellDB seems like the right approach to me.
01:59:51 <ProfTeggy> multipage SQL expressions?  I would love to get hold of such beasts.  I'm interested in "hopeless optimization cases"...
02:00:31 <adept> xerox: well, there is Parsec users doc, which has quite a lot of examples
02:01:06 <shapr> Nowadays I still write SQL queries, but my main priority is to keep them nicely parameterizable.
02:01:50 <adept> ProfTeggy: well, we have multipage SQL queries too (i'm in IT in telco business), but their hopelessness is mostly related to fierce de-normalization of databases and sheer amount of data
02:02:04 <vikasg> xerox, there's a "functional pearl" paper by Graham Hutton which should serve your purpose
02:02:28 <ProfTeggy> adept, hmm.  Denormalization because of performance concerns or because of bad schema design?
02:02:51 <pejo> ProfTeggy, are you interested in any 'hopeless' sql queries or just a certain kind?
02:03:52 <ProfTeggy> pejo, any hopeless case will do actually... :-)  Sheer size, nesting depth, hevay correlation, any of these
02:04:12 <ProfTeggy> s/hevay/heavy/
02:04:47 <adept> ProfTeggy: 80% - performance concerns, 20% - bad genes, backwards compatibility consequences and bad design
02:04:57 <rep> what's your opinion on zurich.
02:05:12 <shapr> rep: As cities go, it's very high on my altitude list.
02:05:19 <shapr> hoi ctrlsoft, hoe gaat het?
02:05:22 <rep> so you like it?
02:05:23 <ProfTeggy> Zurich as a city?  Nice, nice, nice.
02:05:43 <rep> what if a person doesn't speak german?
02:06:04 <ProfTeggy> Zurich people speak English (some French or Italian)
02:06:16 <pejo> ProfTeggy, ok, I'll dig up some examples and get back to you.
02:06:24 <pejo> rep, an excellent time to learn though!
02:06:27 <ProfTeggy> pejo, really?  That'd be nice!
02:06:35 * rep speaks english, french and italian!
02:06:45 <rep> so it shouldn't be too bad?
02:06:48 <ProfTeggy> rep, you'll feel at home then
02:06:52 <rep> gr8
02:07:49 <xerox> rep: great :)
02:08:06 <boegel> xerox: for my Phd, so I'll receive a grant
02:08:12 <xerox> boegel: cool!
02:08:25 * boegel thinks ProfTeggy has become a regular
02:08:54 <boegel> xerox: I've been working on it since the beginning of August, and still I have to change it a lot
02:08:54 <ProfTeggy> uh oh
02:10:12 <rep> i hear life in zurich is expensive, though
02:10:23 <ctrlsoft> hoi shapr
02:11:04 <ProfTeggy> rep, this is true.  But if you get paid according to Swiss standards you should be fine.
02:11:19 <rep> well
02:11:37 <rep> i think i'll get paid around $6k/month
02:11:59 <xerox> Holy google..
02:12:21 <ProfTeggy> Ah, planning to work for Google R&D?
02:12:31 <rep> yes
02:12:56 <ProfTeggy> I was in Norway last week just when they openend their new R&D office.
02:13:00 <ProfTeggy> Nice buffet ;-)
02:13:06 <rep> :D
02:13:10 <xerox> yay :)
02:14:50 <boegel> rep: that's a hell of a lot of money !
02:15:07 <rep> ah
02:16:12 <tuomov> that it is
02:16:58 <xerox> I don't get how to shape what I parse in Haskell types.
02:18:27 <rep> anyway, nothing is sure yet
02:20:04 <rep> heh, this is weird
02:20:06 <rep> http://images.google.com/images?q=google%20zurich&hl=en&lr=&c2coff=1&safe=off&client=safari&rls=en&sa=N&tab=wi
02:20:13 <rep> returns 3 pages
02:20:32 <rep> but if you go to the second page, it won't let you go to the 3rd
02:20:53 <rep> (and the 2nd and 3rd page are the same)
02:21:03 <boegel> rep: I've seen that happen before
02:21:04 <rep> (if you click on them from the first one.)
02:21:22 <rep> ah
02:22:19 <xerox> Click "repeat the search with the omitted results included."
02:22:28 <pejo> ProfTeggy, does google have an office in Norway?
02:23:36 <ProfTeggy> pejo, since last week, yes
02:25:01 <rep> so what do they do there
02:25:17 <xerox> Sauna!
02:25:24 <shapr> w00
02:26:18 <rep> hehe
02:26:48 <xerox> I can't believe you never did parsers! :(
02:26:58 <rep> so how are the swiss girls? :)
02:27:11 <shapr> xerox: The Parsec tutorial is good.
02:27:27 <xerox> shapr: I'll return to it, hmpf.
02:27:45 <adept> xerox: and what seems to be the problem?
02:28:29 <xerox> I don't understand how to shape the parsed bits in Haskell types
02:31:47 <xerox> Oh-uhm...
02:32:55 <adept> xerox: like
02:32:55 <adept> someParser = do
02:32:55 <adept>   h <- parseHeader
02:32:55 <adept>   r <- many (parseRecord)
02:32:55 <adept>   return $ MyContainer h r
02:32:56 <adept> parseHeader = do
02:32:58 <adept>   i <- number
02:33:00 <adept>   symbol "END"
02:33:02 <adept>   return $ Header i
02:33:04 <adept> ?
02:33:07 <adept> or what?
02:35:06 * xerox tries
02:35:24 <hatchetman> ow yeah, my haskell app sucks up 512mb of internal memory and 1 gig of swap
02:35:48 <rep> that's not very good :(
02:36:08 <Itkovian> depends on what it actually does, no?
02:36:34 <hatchetman> hehe
02:36:50 <hatchetman> i told my app to do maximum precision in its analysis
02:37:33 <hatchetman> that means it separates the analysis results for each callstring
02:37:38 <xerox> "it conquers the universe"
02:37:53 <hatchetman> i.e. extremely huge Data.Map-s
02:39:30 <hatchetman> so a Map gets transformed into a new Map etc
02:39:38 <hatchetman> i guess that's pretty expensive
02:39:47 <hatchetman> since they are immutable and a new one is created
02:39:50 <hatchetman> i guess
02:42:07 <Heffalump> I think you'll get a log-space update.
02:42:20 <Heffalump> (following the spine from the updated entry)
02:43:00 <hatchetman> so using arrays wouldnt really help in the space department>?
02:46:17 <Heffalump> would if you use mutable ones
02:46:26 <Heffalump> or DiffArrays
02:47:01 * cjb is being silly with Unicode today:  http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
02:50:49 <hatchetman> Heffalump, in my Map that holds the analysis results, i associate an integer with a Set....But there can be holes between the integers (dont know how large)
02:51:06 <Heffalump> hatchetman: hmm, dunno then.
02:51:23 <hatchetman> i'd be allocating way to large arrays i think
02:51:36 <hatchetman> unless i have a function mapping all those keys to indices....
02:51:48 * Heffalump double-takes at seeing Tim Bagot in that list and then realises why :-)
02:52:07 <Heffalump> hatchetman: make a hash table?
02:52:50 <hatchetman> hashtable instead of the map? or to facilitate the mapping?
02:53:55 <hatchetman> with mapping here i mean mapping keys to arrat indices
03:11:22 <boegel> I'll repeat the question I asked this morning, maybe someone can help me now...
03:11:35 <boegel> does anyone happen to know C.J.Burgess from Bristol University ?
03:18:14 <z0d> where did 'ord' get its name?
03:19:27 <xerox> Order I think.
03:19:32 <hatchetman> omfg, they resetted the pc on my uni because it was inaccessible due to my program running on it taking all the mem :S
03:19:42 <hatchetman> ordinal ?
03:20:33 <xerox> "That has order"  "Order-able" :-)
03:20:35 * cjb assumed ordinal.
03:23:14 <Lucinda> hi
03:23:30 <Lemmih> Hey.
03:24:24 <z0d> xerox: not Ord, ord, the composite function of chr
03:25:47 <xerox> Oh.
03:27:28 <hatchetman> hmm i need some datatype advice guys
03:27:39 <hatchetman> cause i have a serieus problem with my space usage
03:27:44 <hatchetman> serious
03:28:35 <hatchetman> i store my analysis results in the following structure.....
03:28:40 <hatchetman> Map ContextString Analresult
03:28:56 <hatchetman> where Analresult is......Map Int (Set String)
03:29:01 <hatchetman> so a nested Map
03:29:36 <hatchetman> now what happens...is that the 'Map ContextString (Map Int (Set String))' is transformed to a new one.....A LOT
03:31:09 <hatchetman> any suggestions?
03:31:09 <hatchetman> :D
03:31:45 <adept> each char - 4 bytes...
03:32:30 <hatchetman> eh?
03:34:25 <adept> so, maybe its just too much strings being hauled around
03:34:53 <hatchetman> im not really doing anything with the strings themselves...so you suggest making them strict?
03:35:05 <adept> erm, no
03:35:23 <adept> what kind of space problems do you actually have?
03:35:38 <hatchetman> it takes up 1.5 gig of swap and 512mb real mem
03:35:57 <adept> with how many elts in maps?
03:36:11 <hatchetman> i actually received a call from a student that was working on the linux pc that i was executing my app at....that he couldnt do anything with the pc :P
03:36:37 <hatchetman> lets see
03:36:40 <adept> i'm saying that maybe it is real mem usage for your amount of data
03:37:58 <hatchetman> the inner possibly a thousand
03:38:40 <hatchetman> and the outer maybe a hundred
03:51:28 <Lucinda> does anyone know anything about continuation passing style?
03:52:05 <shapr> The monadic interface is a special case of CSP.
03:52:24 <Lucinda> yeah? what exactly is a continuation?
03:52:28 <shapr> Lucinda: Structure and Interpretation of Computer Programming has some good info on CSP. http://mitpress.mit.edu/sicp/
03:53:25 <shapr> A continuation is 'the rest of the computation'.
03:53:44 <Lucinda> ah I see. cheers!
03:55:48 <Lucinda> so a continuation is a higher order function?
03:56:09 <Lucinda> or it is a function that you want to evaluate?
03:56:10 <shapr> No, it's something that represents the future of the computation.
03:56:15 <Lucinda> right
03:56:37 <Lucinda> but how can you make sure that haskell will evaluate that in a particular order?
03:56:43 <shapr> Some systems can save continuations to disk, in that case they have to save however much of the state of the system they need to recreate it exactly.
03:57:23 <shapr> First class continuations are especially cool, you can create any control structure if you can modify continuations.
03:57:59 <shapr> Monads give order in Haskell.
03:58:09 <shapr> @type (>>=)
03:58:17 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
03:58:17 <lambdabot> b
03:58:20 <Lucinda> but continuations dont give order?
03:58:39 <shapr> Yeah, they do. monads are a special case of continuation passing style.
03:58:48 <Lucinda> *confused*
03:59:06 <Lucinda> what is the point in monads if you can use continuations?
03:59:21 <Lucinda> or vic versa
03:59:23 <Lucinda> *vice
03:59:33 <shapr> Monads are a convention that has certain useful properties.
03:59:50 <Lucinda> suc as implicit state, for example?
04:00:03 <shapr> You probably already know about objects in OOP, and you probably know their useful properties ( at least implicitly).
04:00:27 <shapr> Monads don't have implicit state.
04:01:07 <shapr> Monads' useful properties are mostly compositionality.
04:01:52 * shapr thinks
04:02:01 <Lucinda> compositionality?
04:02:32 <shapr> Software engineering is 100% about compositionality. You want to guarantee that code won't suddenly act differently when stuck together with some other code.
04:02:59 <Lucinda> ok
04:03:32 <shapr> For example, if you stick some Java code that heavily uses threads together with some other Java code that heavily uses threads, it's very likely that one will step on the other, and you'll get deadlock, race conditions, etc.
04:03:44 <Lucinda> sure...
04:04:18 <shapr> So, compositionality for threads and locking can be found in something like Software Transactional Memory, just added to GHC 6.4
04:04:43 <shapr> Objects are useful for compositionality because, for the most part, they don't step on anything outside of their own object instance.
04:05:11 <shapr> Makes sense, right?
04:05:39 <Lucinda> erww
04:06:02 <shapr> Have you used objects for OOP?
04:06:05 <Lucinda> yes
04:06:19 <shapr> You know that the state of an objects is usually private, right?
04:06:23 <Lucinda> yep
04:06:32 <shapr> Why is that?
04:07:14 <Lucinda> so it doesnt effect the state of the other objects?
04:07:18 <shapr> You got it.
04:07:23 <shapr> How is that useful?
04:07:42 <shapr> (affect is the verb, effect is the noun)
04:07:45 <Lucinda> so you can take an object and plug it in a different evironment, and it still works
04:07:48 <shapr> exactly!
04:08:26 <Lucinda> but why are monads so special? surely you can take a haskell function and place it into another program, and it still works?
04:08:28 <shapr> That way you can predict that an object will behave pretty much the same way in the presence of whatever other objects.
04:08:33 <Lucinda> ok
04:08:39 <Lucinda> yeah, that makes sense
04:09:23 <shapr> Monads are special (in my opinion) because they do more to separate code into its own safe place, and they require less pieces to do it.
04:09:29 <shapr> In programming, fewer moving parts is a good thing.
04:09:36 <shapr> But I'm sure you already know that :-)
04:09:55 <Lucinda> well yeah, but i dont see how monads do that
04:10:20 <shapr> I can explain it to you, but this does a better job: http://www.nomaware.com/monads/html/index.html
04:10:40 <Lucinda> ok cheers
04:10:47 <shapr> In my opinion, a monad instance is roughly like a metaclass.
04:10:55 <musasabi> What has been happening on the GHC 6.4.1 front lately?
04:10:56 <xerox> Cale's article will be pretty explanatory about how monads improve compositionality.
04:11:34 <shapr> Has he started writing his article?
04:11:38 <Lucinda> ok...Ill take a look at this now. Cheers for your help!
04:12:12 <xerox> shapr: It is possible, at least we got a nice code example
04:12:43 <xerox> BTW it's not so straightforward to notice this, IMO.
04:13:04 <shapr> Lucinda: Sure, ask me more questions if/when you get them.
04:13:48 <Lucinda> shapr: cheers!
04:17:28 <Lucinda> shapr!
04:17:30 <Lucinda> Ah!
04:17:33 <shapr> What?
04:17:46 <shapr> You understand monads now?
04:17:53 <Lucinda> i see...you can have a monad in a program, and it is totally seperate from the calling function
04:17:58 <shapr> Yes!
04:18:09 <Lucinda> so any state in the monad doesnt affect the rest of the program
04:18:12 <Lucinda> :)
04:18:32 <shapr> And you can use monads for lots of cool stuff, like abstracting out really big if-then-else statements.
04:18:38 <Lucinda> yes
04:18:55 <Lucinda> oooh...i suddenly like monads a lot more now
04:19:02 <shapr> Yeah, they're great!
04:19:08 <Lucinda> this is a nice tutorial
04:19:13 * shapr agrees
04:19:19 <Lucinda> i think i will go through it for the good of my health
04:19:24 <Lucinda> cheers shapr
04:19:31 <shapr> Glad I could help :-)
04:19:34 <Lucinda> but...
04:19:41 <Lucinda> why monads instead of continuations?
04:19:56 <Lucinda> because monads can be isolated, continuations cannot?
04:20:00 <shapr> Because monads have useful features that continuations by themselves do not.
04:20:04 <Lucinda> right
04:20:09 <Lucinda> cool
04:20:23 <shapr> For example, (a >>= b) >>= c must be the same as a >>= (b >>= c) for a monad instance.
04:20:32 <Lucinda> yeah...
04:20:35 <shapr> That's really handy for software engineering purposes.
04:20:42 <Lucinda> ok
04:21:31 <shapr> Raw continuations don't follow the three laws of monads.
04:21:49 <Lucinda> so continuations still give a computation order to the program?
04:22:01 <shapr> continuation passing style does.
04:22:20 <shapr> In CPS, one of the arguments to the function is the function to call with the result.
04:22:27 <gour> do we need cps when we have monads?
04:22:27 <Lucinda> right
04:23:30 <vegai> there's a continuation monad, isn't there?
04:23:47 <shapr> So, monads are useful to give execution order to a language that doesn't have order. Monads are also useful in languages like Scheme/Perl/Java/etc as an abstraction with many of the same benefits as OOP.
04:24:04 <rep> don't touch too much.
04:24:15 <gour> shapr: i ask for haskell only?
04:24:35 <gour> vegai: could be, i'm a newbie
04:25:06 <shapr> gour: CPS is a superset of monads, so I think it's possible that CPS can do some things that monads can't do. But I'm not an expert, ask TheHunter when he's around. He knows more than I do.
04:25:28 <shapr> Yes, there is a continuation monad, but I haven't used it.
04:25:58 <gour> shapr: ok, thanks. i'm not in a hurry, but good to know whom to ask :-)
04:34:07 <dblhelix> @seen earthy
04:34:08 <lambdabot> earthy is in #haskell. Last spoke 13 hours, 29 minutes and 37
04:34:08 <lambdabot> seconds ago.
04:34:22 <dblhelix> earthy: ping
04:43:50 <hatchetman> dblhelix, you are doing program analysis too right?
04:56:29 <shapr> I wish ssh -X also forwarded sound.
04:56:33 <shapr> hej cyph1e
04:56:39 <cyph1e> tjopp
04:56:48 <shapr> Learning Haskell?
04:56:58 <cyph1e> japp
04:57:13 <shapr> xerox: Any ideas on how to get fin || die to work across ssh -X ?
04:57:21 <shapr> cyph1e: Have any questions? Want the quick tour?
04:57:42 <cyph1e> I'm fine right now ;)
04:58:07 <Cale> It was about how laziness improves it (though monads should be in there as well) -- I haven't actually typed much yet, but I have a good portion of it formed in my head :)
04:58:08 <shapr> Ok, if you have questions, feel free to ask.
04:58:16 <shapr> Cale: I want to read it!
04:58:27 <Cale> hehe :)
04:59:02 <Cale> Have you looked at the code xerox and I were working on to compute L-Systems?
04:59:35 <shapr> No, where is it?
04:59:44 <shapr> hej psi
04:59:51 <psi> hej
04:59:59 * shapr throws go stones at psi 
05:00:07 <Cale> xerox: Okay if I put the L-Systems code on the wiki?
05:00:26 * psi picks them up and starts playing with them
05:00:48 <shapr> Do you have a darcs repo for the L-systems code?
05:00:58 <psi> shapr: when are you starting at ltu?
05:00:59 <Cale> not me anyway
05:02:01 <Cale> It's on the paste page
05:02:52 <Cale> nice little example of how you can write one piece of code and have different monads give that code different effects.
05:03:49 <Cale> oh, you'll also need MonadRandom which I added to the wiki the other day
05:05:29 <Cale> something odd is going on with the syntax colouring
05:05:40 <Cale> there's an error message stuck in there
05:07:45 <Cale> One nice thing that you'll notice about the list and WL monads is that even if the iteration count is high, it doesn't cost much more than usual to get the first results, even though the lists are quite possibly blowing up exponentially in length.
05:07:54 <Cale> (well, of course, because it's lazy)
05:09:16 <Cale> Without that laziness, we'd have to do something special to modify the algorithm to take account of the fact that we don't want it to finish computing one list before expanding again.
05:09:30 <Cale> which would basically break the generality of it
05:12:45 <tuomov> shapr: can't you have ssh forward some port for a network sound system
05:13:16 <hatchetman> can a map "Map String (Map Int (Set String))" become as large as hundreds of mbs when i have 2000 element in the inner map, and 100 in the outer map and 50 strings in each set ?
05:13:50 <Cale> with no sharing between the strings?
05:14:12 <tuomov> ssh -R port:localhost:port
05:14:16 <xerox> Cale: OK, I'll be making the darcs repo today
05:14:28 <tuomov> maybe it can be configured in .ssh/config too
05:14:31 <Cale> that's 10 million strings already.
05:15:04 <hatchetman> no sharing at all
05:15:15 <hatchetman> well, i dont think so
05:15:19 <hatchetman> when are they shared?
05:16:07 <Cale> when they came from the same strings initially
05:16:20 <labra> has anyone used Haskell XML Toolbox in Windows?
05:16:32 <Cale> like, if you had some small pool of strings that the sets are subsets of
05:16:38 <hatchetman> in that case, they should be shared yeah
05:17:39 <hatchetman> in the case that they are shared....could the memory consumption still be hundreds of megs?
05:17:45 <Cale> (and you constructed them by referring to the strings in that pool)
05:17:53 <Cale> I can imagine
05:18:03 <Cale> if you built the whole structure
05:18:38 <Cale> if each node takes 10 bytes, hundreds of megs is not out of the question.
05:18:41 <Cale> er
05:18:42 <Cale> hmm
05:18:46 <Cale> no, that's off
05:18:53 <Cale> but it doesn't have to take much
05:19:11 <Cale> yeah, 10 bytes or so would give 100MB
05:19:26 <labra> has anyone used Haskell XML Toolbox in Windows?
05:19:47 <Cale> and then the sets have to store which strings are in them (they're trees)
05:19:55 <Cale> trees of pointers to strings
05:20:46 <int-e> data Set a    = Tip
05:20:46 <int-e>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
05:20:54 <hatchetman> hmmm
05:20:56 <int-e> what's that, a tag and for pointers for every element?
05:21:03 <int-e> four
05:21:28 <hatchetman> Cale, the sets of strings are all created by modifying the former one
05:21:42 <hatchetman> so only one map with sets of strings are original so to say
05:28:08 <shapr> psi: Since I don't have any papers yet, it might not be till next term.
05:28:13 <shapr> tuomov: Yeah, would make sense.
05:29:59 <shapr> Does jackd do network connections?
05:30:15 <tuomov> I don't know. Isn't jack meant for low-latency stuff?
05:30:59 <shapr> Yeah, but it has a bunch of features, so I can hope :-)
05:57:03 <dblhelix> hatchetman: sorry, only just noticed your question
05:57:11 <dblhelix> hatchetman: but, yes, I do
05:59:43 <hatchetman> does your way of doing analysis resemble the one used in APA ?
06:00:11 <dblhelix> hatchetman: on a certain level, but not directly
06:00:36 <dblhelix> hatchetman: think t & e systems
06:01:33 * boegel sees lot's of new people here today
06:01:40 <Micket> Like me
06:01:41 <boegel> s/lot's/lots
06:01:45 <boegel> hey Micket
06:01:48 <boegel> learning Haskell ?
06:02:04 <dblhelix> a Tour! a Tour! a Tour!
06:02:13 <boegel> dblhelix: sst, don't spoil the fun
06:02:13 * dblhelix gets all excited
06:02:18 <dblhelix> oops
06:02:23 <dblhelix> boegel: I'm sorry :)
06:02:31 <dblhelix> boegel: please, go ahead
06:03:57 <Micket> Uhm. Im looking for a way to save a variable to a file, so i can quickly open it for the main program. It's my own data type.
06:04:26 <Micket> Well i've been learning for a week or so.
06:04:55 <ndm> Micket, Show and Read work quite well
06:05:11 <ndm> data x = .... deriving (Show, Read)
06:05:14 * boegel feels IO and monad-related problems coming up
06:05:24 <ndm> then "show x" converts it into a string
06:05:29 <ndm> and read gets it back
06:05:38 <Micket> ah.. perfect!
06:05:46 <dblhelix> hatchetman: are you a student at utrecht?
06:06:03 <Micket> i've had my fair amount of those already boegel :)
06:07:36 <boegel> Micket: yeah, and lot's more to come :) I don't want to frighten you, but IO stuff isn't easy in Haskell when you're coming from C/Java
06:07:42 <hatchetman> dblhelix, i pm-ed you
06:07:48 <hatchetman> or are you not receiving it :)
06:08:36 * musasabi thinks IO is easier in Haskell than C/Java but it needs quite a lot thinking first
06:08:52 <dblhelix> hatchetman: I guess I'm not receiving it... mmm...
06:09:25 <kosmikus> not registered
06:09:54 <kosmikus> or at least not identified
06:09:58 <hatchetman> who me?
06:09:59 <ProfTeggy> musasabi: thinking good, hacking bad
06:10:05 <kosmikus> hatchetman: yes
06:10:09 <boegel> hatchetman: yep, new freenode policy
06:10:18 <hatchetman> ow, i never registered
06:10:18 <boegel> hatchetman: /msg nickserv help
06:10:33 <boegel> hatchetman: /msg nickserv help register
06:10:37 <boegel> it's quite easy
06:10:37 <hatchetman> since i used to have the day + a random nr
06:10:39 <hatchetman> as my nick
06:10:52 <hatchetman> i know about nickserv
06:10:55 <boegel> hatchetman: oh, that's you ! :) I though you were new ;)
06:10:57 <hatchetman> i just dont feel like registering
06:11:15 <hatchetman> dblhelix, still not receiving pm-s?
06:11:19 <boegel> hatchetman: it never hurt anyone
06:11:22 <musasabi> the built in IO libraries are just not very helpfull.
06:11:30 <dblhelix> hatchetman: ah, you're just Thu56896 :)
06:11:38 <dblhelix> hatchetman: no, still not
06:11:39 <hatchetman> some day i was
06:11:41 <hatchetman> :D
06:11:42 <boegel> hatchetman: as long as you're not registred you won't be able to pm anyone
06:11:47 <hatchetman> owwww
06:11:57 <hatchetman> in any case, i was wondering what datatype you were using, since my app currently sucks up 1,5 gigs of memory
06:12:05 <hatchetman> datatype to store the analysis in
06:12:46 <hatchetman> my name is already registered....
06:12:48 <dblhelix> hatchetman: I mostly use combined monads
06:12:55 <hatchetman> ow...
06:13:19 <dblhelix> hatchetman: you've implemented a monotone fw?
06:13:24 <hatchetman> yeah
06:13:43 <hatchetman> maybe not so smart after all
06:13:57 <hatchetman> embellished monotone framework even
06:14:24 <dblhelix> hatchetman: yes, that can be quite hard when moving from theory and small toy programs to practice and large real-world progs, I guess
06:14:39 <dblhelix> hatchetman: or does it even gets dirty for toy programs?
06:14:59 <hatchetman> well, depends on what you call dirty>
06:15:00 <hatchetman> ?
06:15:27 <hatchetman> are you referring to the mem usage?
06:15:35 <dblhelix> where being dirty is defined as consuming huge amount of memory
06:15:36 <dblhelix> yes
06:15:41 <hatchetman> cause for small examples...its doable....
06:15:53 <hatchetman> i havent tried unbounded callstrings though
06:16:18 <hatchetman> trying that for the mpeg2decoder resulted in some student giving me a phonecall to stop freezing his computer hehe
06:16:51 <hatchetman> using callstrings of length 4 resulted in linux killing my process since memory run out
06:16:56 <dblhelix> no obvious pitfalls like building huge closures instead of using finite maps etc?
06:17:09 <dblhelix> ouch
06:17:12 <hatchetman> i dont know...this is my datastructure
06:17:23 <hatchetman> (Map String (Map Int (Set String))
06:18:09 <hatchetman> the outer map....maps callstrings to a map that contains the analysis results
06:18:42 <dblhelix> should be reasonable... you could use IntMap for the inner map but that won't make a big difference, not in space anyway
06:18:44 <hatchetman> the innner map( the analysis results) maps every programpoint of interest to some set of variables that represent for example the set of live variables
06:19:05 <hatchetman> yeah, but every step in the iterationprocess means im adjusting the outer/inner map
06:19:22 <dblhelix> have you tried to speed things up with the occasional seq?
06:19:27 <hatchetman> so i think there are 2 possibilities.....1) because the maps are mutable...this means lots of space waste
06:19:38 <hatchetman> or 2) the dataset is really that big
06:19:51 <hatchetman> hmm
06:19:58 <hatchetman> lets think where i could plant a seq
06:20:13 <dblhelix> still, it could be that the entires in the map merely consist of computations
06:20:17 <Lemmih> Have you tried profiling?
06:20:36 <dblhelix> instead of just string sets
06:20:57 <hatchetman> im profiling as we speak
06:21:21 <hatchetman> do you think making the Strings strict in the datatype definition would help?
06:21:37 <hatchetman> i mean...im storing a hell of a lot strings without doing anything with them but just moving them from set to set
06:21:40 <hatchetman> adding/removing etc
06:23:04 <hatchetman> (the inner map has around 2000 entries btw)
06:23:34 <dblhelix> mmm... that's not an awful lot
06:24:25 <Lemmih> So that's a total of 100*2000 elements?
06:24:34 <hatchetman> that means for every context, there's a map with 2000 entries.....
06:25:13 <hatchetman> each entry has on average a set of 40 strings
06:25:22 <hatchetman> 100*2000*40 strings
06:25:35 <hatchetman> 100*2019*40 strings actually
06:26:33 <hatchetman> but every outer map element shares a great deal of strings with eachother
06:26:36 <Lemmih> What's the average length of the strings?
06:26:53 <hatchetman> they are variable names
06:27:07 <hatchetman> sooo, lets say 10
06:27:19 <hatchetman> (its open source C code for mpeg2 decoder)
06:27:54 <Lemmih> In a strict structure it would be almost 400megs of data.
06:28:08 <hatchetman> assuming no storage between the strings
06:28:15 <hatchetman> sharing i mean
06:28:17 <hatchetman> -storage
06:29:50 <hatchetman> but the amount of outer elements probably varies heavily
06:30:13 <Lemmih> Profiling should clear things up.
06:30:18 <hatchetman> yeah
06:30:56 <Micket> whats profiling? :x
06:31:24 <hatchetman> something you do when your application is shot down by linux for using all the system and virtual memory
06:31:25 <hatchetman> :)
06:32:37 <hatchetman> Lemmih, would you do a heap profile, or retainer....or something else?
06:39:25 <CosmicRay> gooooooooooood moorrrrrrrrning,  #palmchat!
06:39:27 <CosmicRay> err
06:39:28 <CosmicRay> wrong window
06:40:56 <ulfdoz> Really? :)
06:41:00 * Muad_Dibber looks around
06:41:03 <Muad_Dibber> this is #haskell :P
06:41:14 <vegai> this is not my office!
06:41:17 * vegai storms out.
06:41:20 <CosmicRay> hehe
06:41:38 * Muad_Dibber doesnt have an office anyway so :)
06:41:49 <CosmicRay>  gooooooooooood moorrrrrrrrning,  #haskell!
06:41:57 <CosmicRay> Muad_Dibber: now you don't have to feel left out ;-)
06:42:52 <CosmicRay> or should I say 'g' : (replicate 15 'o') ++ "d moo" ++ (replicate 10 'r') ++ "ning, #haskell!"
06:48:14 <Muad_Dibber> oh
06:48:21 <Muad_Dibber> but i understand perfectly fine plain english :P
06:48:24 <Muad_Dibber> (c:=
06:50:49 <shapr> ProfTeggy: Ah I see one of your papers was mentioned here: http://lambda-the-ultimate.org/node/view/953
06:51:38 <Lemmih> Someone spammed the wiki again *sigh*
06:52:06 <shapr> We need a plugin that holds a bunch of duplicate urls, or at least lets you rollback a bunch of changes at once.
06:52:37 <shapr> Flippi is seeing more development recently.
06:53:15 <shapr> Lemmih: Ah, if you put the urls into LocalBadContent they can't resubmit.
06:53:52 <Lemmih> I'm not allowed.
06:53:59 <Heffalump> does the wiki do rel=nofollow on links?
06:54:52 <shapr> Heffalump: Hey, what do you think of rss for change announcements?
06:55:09 <Heffalump> of what?
06:57:32 <shapr> Instead of turning on email sending for the wiki, using rss.
06:57:36 <shapr> Lemmih: Now you do.
06:57:59 <Heffalump> I'd far rather get an email.
06:58:10 <shapr> What about using rss2email?
06:58:20 <Heffalump> well, I could set it up. Is turning on email sending hard?
06:58:39 <Heffalump> If there's a problem, I'll find some other way or not bother. I just thought it would be easy.
06:59:10 <shapr> Assuming the config stuff you sent me just works, it is easy.
06:59:23 <shapr> But I don't like push mediums because they require admin effort.
06:59:36 <shapr> I wonder if spammers will figure out some way to get the wiki to send spam mail.
06:59:43 <shapr> RSS is easy to unsubscribe from.
07:00:30 <Igloo> It's already an opt-in thing, surely?
07:00:42 <Igloo> push is clearly what is wanted here, IMO
07:00:44 <Heffalump> they can only spam people who have opted in.
07:01:01 <Heffalump> and I'm not sure what admin effort is required beyond enabling it.
07:01:02 <Igloo> (in as much as anything to do with a wiki is wanted  :-)  )
07:01:40 <Heffalump> igloo: well, you tell me how to write a forking daemon properly in Haskell.
07:02:13 <Igloo> I'm lost; what's that got to do with this discussion?
07:02:49 <Igloo> A fairly direct translation of forking daemon code in any other language ought to work, though
07:03:21 <Heffalump> igloo: http://haskell.org/hawiki/HaskellUnixDaemon is the page IO want to subscribe to
07:03:26 <Heffalump> and I see that someone has answered.
07:03:27 <Igloo> Weren't you actually trying to write a threaded daemon?
07:03:29 <Heffalump> (my question)
07:03:46 <Heffalump> no, I want it to have the option of forking so I can upgrade it without killing existing connections.
07:03:58 <Heffalump> (though their answer is inadequate)
07:04:25 <Igloo> Why not ask the mailing list rather than the web?
07:05:36 <Igloo> inadequate because it assumes 255?
07:06:00 <Heffalump> I will ask the mailing list, but the fact that it already had some useful information there meant it was a good starting point.
07:06:11 <Heffalump> no, inadequate for the reason just posted.
07:06:25 <Igloo> With the FFI you could do the same as in C
07:06:36 <Igloo> What reason?
07:07:45 <Heffalump> that's not enough, cos there might be a real Handle associated with some of them, I think.
07:07:59 <Heffalump> and I can't avoid a specific Handle, because I can't get the Fd from it without closing it.
07:09:11 <Igloo> handleToFd will do that, no?
07:09:51 <labra> has anyone used the Haskell XML Toolbox?
07:11:22 <Heffalump> it closes the Handle.
07:11:57 <Heffalump> I'll show you the actual code that's going horribly wrong this evening.
07:12:22 <shapr> labra: Yeah, it's cool.
07:12:57 <shapr> Greetings labra, I've read some of your papers.
07:13:22 <labra> do you know if it works in windows?
07:13:43 <shapr> No, I don't know. I don't use Windows.
07:13:43 <xerox> @hoogle a -> Rational
07:13:47 <lambdabot> Prelude.toRational :: Real a => a -> Rational
07:13:47 <lambdabot> Prelude.quotRem :: Integral a => a -> Rational
07:13:47 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
07:14:02 <labra> I don't use also...
07:14:15 <labra> but it is giving some strange errors
07:14:23 <shapr> labra: Your name appears in the lambdabot sources even :-)
07:14:58 <labra> and what does that mean?
07:15:11 <xerox> Parsec is fun!
07:15:29 <shapr> There's a lambda calculus interpreter plugin for lambdabot that uses some ideas from your papers.
07:15:37 <shapr> Anyway, what errors do you get from HXT?
07:16:15 <labra> I did not know that...I have been 2 years os so away from haskell
07:17:01 <labra> the error is: illegal URI for input fileName
07:17:22 <shapr> What input filename did you give it?
07:17:35 <labra> a filename in the current directory
07:17:48 <labra> it does not work any of the examples...
07:17:59 <labra> so I suppose it is probably a problem with windows
07:18:06 <shapr> Maybe it wants a real URI like "file:///home/jose/somename.xml" ?
07:18:13 <musasabi> hmm upgrading debian seems to have gotten rid of darcs and now it is uninstallable due to ghc hanging in the libgmp transition...
07:18:20 <shapr> It could be a problem with the path.
07:18:31 <labra> I tried that also...
07:18:44 <shapr> Do you have access to a Linux box for comparison?
07:19:34 <Heffalump> musasabi: install libgmp from sarge or etch
07:19:45 <labra> yes...I will try in debian...I was just asking to see if it was a known problem
07:20:07 <shapr> I haven't heard of it before. Si\ is the most experience HXT user I know.
07:20:12 <Igloo> Oh, hmm, that's a pain
07:20:22 <shapr> Si\: Do you use HXT on win32?
07:20:44 <Igloo> Can you fdToHandle them and compare handles?
07:21:27 <Heffalump> that actually does something with openFd
07:21:41 <Heffalump> so (a) it has nasty side-effects and (b) I don't think you get equal values
07:22:06 <Heffalump> I'm leaning towards just keeping a global list of handles and sockets.
07:22:16 <Heffalump> But it damages the nice compositionality of forkIO.
07:22:44 <SickJacken> does anyone have a nice link to an even nicer document explaining when you need to use what profiling options....because from just the ghc manual...i cant tell
07:24:49 <musasabi> Heffalump: cannot do that because libgmpxx3 conflicts with libgmp3 and some packages depend on that...
07:25:30 <z0d> musasabi: the same here
07:25:38 <z0d> installing ghc removed darcs
07:26:21 <shapr> labra: Will you be doing more research on modular monads?
07:26:41 <labra> I hope so
07:26:57 <labra> but at this moment I have not many time
07:27:29 <labra> It is great that you know my research
07:27:41 <musasabi> z0d: I think this because of the new ghc6 NMU build which depends correctly on libgmp3c2 and darcs not yet being rebuilt.
07:27:47 <SickJacken> hey labra, want the haskell tour :P
07:27:59 <shapr> SickJacken: He doesn't need the tour :-)
07:28:41 <z0d> what is this haskell tour thing you keep talking about?
07:28:54 <labra> This is my first time in #haskell
07:28:54 <SickJacken> thats probably why i said it :P
07:29:00 <SickJacken> does anyone have a nice link to an even nicer document explaining when you need to use what profiling options....because from just the ghc manual...i cant tell
07:29:15 <earthy> modular monads?
07:29:33 <Heffalump> who NMUed ghc6?
07:29:56 <labra> yes...my research was about that
07:30:07 <earthy> in what sense?
07:30:21 <earthy> I've seen the modular language components
07:30:28 <labra> In that sense
07:30:36 <earthy> but how are those monads modular in and of themselves?
07:30:57 <earthy> ah, 'kay
07:31:01 <Igloo> Kurt Roecx (possibly misspelt)
07:31:03 <earthy> I understand now. :)
07:31:23 <earthy> nice code btw, labra
07:31:33 <labra> Thanks...
07:31:45 <labra> I have made a sourceforge version of the LPS
07:32:02 <labra> My last work was using monads for program slicing
07:32:55 <Heffalump> oh, is he doing ABI transition stuff?
07:33:03 <labra> the project is at: http://sourceforge.net/projects/lps
07:33:07 <Igloo> Yes
07:33:22 <labra> But I did not gave it much publicity...
07:33:39 <musasabi> Heffalump: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=319222 seems to suggest that Kurt Roeckx was working on it.
07:33:40 <labra> And i would like it to adapt to the new libraries
07:34:29 <musasabi> Seems Isaac is working on the problem (only now catching up on mailing lists).
07:34:50 <earthy> um, why is slicer.tar.gz in slicer.tar.gz, labra?
07:36:12 <earthy> weird...
07:36:12 <labra> sorry?
07:37:27 <earthy> oh, slicer.tar.gz on sourceforge contains a file slicer.tar.gz, which contains a smaller file slicer.tar.gz and so on
07:37:47 <labra> I think that is a mistake...
07:37:53 <shapr> Heffalump: The email sending isn't working, and there aren't any informative errors. I'll look at it more later.
07:37:54 <labra> thank you for pointing it
07:38:05 <labra> Now I have a new thing to correct :)
07:38:24 <earthy> well, I've extracted, it contains about 4 levels of slicer
07:38:44 <labra> Just look at the haskell files :)
07:38:56 <labra> I will have to clean that
07:39:13 <earthy> I was looking at the haskell files ;)
07:39:18 <earthy> just to see if they differed, at first ;)
07:39:47 <earthy> nope, no file differences...
07:41:16 <Heffalump> shapr: oh. well I subscribed ok.
07:41:28 <shapr> Can you get an email?
07:41:46 <Heffalump> haven't tried. Can you edit HaskellUnixDaemon.
07:41:46 <earthy> the code is highly interesting to me as I think I have a neater way of doing it ;)
07:42:35 <Si\> shapr: I use HXT on GNU/Linux
07:42:40 <shapr> Si\: ok, thanks.
07:42:49 <earthy> oh, and it'd be an interesting exercise to see how easily this would be adapted to the stuff that is in Monad.Trans these days
07:42:55 <shapr> Heffalump: I can edit the page, but if email notification is checked, I get a server error.
07:43:21 <labra> Yes...that is something that I would like to do...one day :)
07:43:40 <earthy> well... maybe I'll do it, just for the heck of it
07:43:42 <SickJacken> ow cool, now my app only uses 1.3 gigs
07:43:43 <labra> As you can see the code is not updated
07:43:46 <SickJacken> that is just excellent
07:43:48 <earthy> I kinda understand Monad.Trans
07:43:55 <Heffalump> shapr: ah. bugger.
07:43:57 <Heffalump> what's the error?
07:44:06 <labra> That would be great
07:44:13 <labra> If you do it...let me know
07:44:18 <earthy> and many of your thingT monads look like duplicates of the stuff in Monad.Trans
07:44:27 <labra> yes...
07:44:37 * Heffalump reproduces it. Hmm, that's unhelpful.
07:44:54 <earthy> (which actually makes it harder to understand, for me ;))
07:45:18 <Heffalump> shapr: oh, I got the emails.
07:45:23 <shapr> That's good, I don't get any.
07:45:28 <labra> probably so...the code is from before the haskell libraries
07:45:36 <Heffalump> hmm. that's odd/annoying.
07:45:37 <earthy> yup, I recognised that
07:45:40 <Heffalump> I guess you'd better just disable it.
07:45:52 <Heffalump> It's not important enough to waste huge amounts of time on.
07:46:00 <Heffalump> If you can read the server logs, that might help fix it easily.
07:46:42 <labra> the modular interpreters code were part of my phd
07:46:48 <labra> but the phd is in spanish :(
07:46:55 <earthy> I've read through parts of it
07:47:07 <labra> I finished it in 2001
07:47:13 <shapr> Heffalump: I can read the server logs, but the error doesn't seem to be present in either apache's logs or moin's logs.
07:47:19 <labra> the slicer code is the only new code
07:47:19 <earthy> spanish is not that hard to pick up if you know some latin
07:47:29 <Heffalump> it's not in apache's error log??
07:47:36 <shapr> labra: I would like to read your PhD thesis, but I don't read Spanish.
07:47:39 <Heffalump> probably /var/log/apache2/error_log
07:47:45 <Heffalump> or error.log, or maybe /var/log/apache/
07:48:02 <shapr> I have used apache before :-)
07:48:12 <Heffalump> ok, sorry :-)
07:48:15 <labra> You can try it if you want at: http://lsi.uniovi.es/~labra/Thesis.html
07:48:18 <Heffalump> I just find that really odd.
07:48:32 <Heffalump> oh well, just disable it, I guess.
07:48:35 <rafl> Igloo: When will we see a new happy upload?
07:48:42 <shapr> I find it odd also, that's why I'll look at it again later.
07:48:43 <earthy> shapr: Read David Espinosa and and Sheng Liang's theses
07:48:47 <labra> Sorry...the pdf is http://www.di.uniovi.es/~labra/tesis/tesis.pdf
07:48:57 <shapr> I've read some of Espinosa's stuff, but not Sheng Liang's.
07:49:03 <Igloo> shapr: Is this on haskell.org?
07:49:05 <earthy> it's got most of the ideas as well, what I understood
07:49:06 <shapr> Igloo: yes.
07:49:10 <Igloo> Are you root then?
07:49:13 <shapr> yes
07:49:16 <Igloo> Ah, OK
07:49:26 <Igloo> rafl: Not sure
07:49:35 * shapr is 1773
07:49:38 <earthy> (that's why I read but parts of your thesis, labra. it was tough to find stuff I hadn't seen elsewhere)
07:49:39 <shapr> er, whatever...
07:49:43 <xerox> shapr is the root!
07:49:44 <shapr> 1337 maybe?
07:50:11 * xerox will do the branch, now we need people for the leafs
07:50:13 <shapr> xerox: I've got root on haskell.org, but that just means people ask me to do sysadmin work there.
07:50:40 * xerox pokes shapr
07:50:57 * shapr throws lambdas at xerox 
07:51:05 * Igloo assumed the move meant Paul was doing it all now
07:51:09 <xerox> Go back to your sysadmin angle! Bad boy!
07:51:17 <shapr> angle == corner?
07:51:21 <xerox> True
07:51:39 <shapr> ok
07:51:46 * shapr can't speak any italian at all.
07:52:00 * xerox can't speak english - sigh.
07:52:21 * shapr grins
07:52:25 <shapr> You write it well on irc.
07:52:28 <earthy> oh, but for the comparison of the different specification methods ofcourse
07:52:34 <xerox> Thanks ^_^
07:52:50 <earthy> speaking and writing on IRC are different skills
07:52:55 <earthy> trust me ;)
07:53:12 <xerox> Indeed.  My pronunciation isn't as trained as my typing skills.
07:53:51 <shapr> Yeah, my Swedish is much better on IRC than in person.
07:54:30 <xerox> If you can survive in Sweden.. maybe your Swedish isn't so bad :-)
07:54:49 <shapr> Most Swedes speak American, lucky for me.
07:54:57 <earthy> oh, you can live for *years* in the Netherlands without speaking a word of dutch
07:54:59 <xerox> Ah!
07:55:14 <earthy> that's the trouble with well developed countries... the inhabitants speak foreign langusges
07:55:20 * xerox thought about moving outside Italy when he starts uni the next year
07:55:27 <xerox> ...even if it's a bit frightening.
07:55:40 <xerox> I want to go where I could do Haskell!
07:55:42 <earthy> xerox: d'you know about Utrecht University College? :)
07:55:53 <xerox> Nope :-D  Where is it?
07:56:14 <xerox> Here in Italy CS people do C/Java (at least in the first years) for what I know.
07:56:21 <earthy> http://www.ucu.uu.nl/
07:56:55 <xerox> It's all so foggy atm, though :)
07:56:58 <earthy> and you get to choose cs courses at utrecht... :)
07:57:16 <Heffalump> earthy: how does it differ from UU?
07:57:21 <SickJacken> ucu!?!?
07:57:34 <earthy> it's a completely different education
07:57:36 <SickJacken> isnt it just cs.uu.nl?
07:57:44 <earthy> it's only funded by UU
07:57:53 <earthy> and the cs courses are ofcourse identical to those @cs.uu.nl
07:58:33 <earthy> but it's a very nice path to take if you still have to take a bachelor's
07:58:50 <earthy> and the bachelor's will give you access to the cs.uu.nl master's courses
07:58:53 <xerox> I'll bookmark and keep it in mind, thanks much.
08:01:32 <ctrlsoft> oh, more UU people here :-)
08:01:43 <ctrlsoft> earthy: I really liked the FP course btw! (-:
08:02:03 <earthy> *good*! :)
08:02:09 <earthy> now come do an ST master's. :)
08:02:10 <xerox> earthy: do you teach here?
08:02:14 <xerox> *there
08:02:16 <xerox> @index either
08:02:18 <lambdabot> Data.Either, Prelude
08:02:22 <earthy> I'm a lowly PhD @ cs.uu.nl
08:02:27 <xerox> @type Data.Either.either
08:02:36 <SickJacken> hey earthy, im dont have to do coll. at UU :D
08:02:50 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
08:03:03 <SickJacken> me is dude that had the day + random nr in his name btw
08:03:34 <earthy> I'd already matched the login. Niels, right?
08:05:18 <shapr> SickJacken: So you've chosen a static nickname now?
08:05:55 <SickJacken> earthy, yeah
08:05:58 <SickJacken> and shapr yeah
08:06:04 <SickJacken> this is my static home
08:06:13 <SickJacken> with home i mean house
08:06:26 <SickJacken> the other period was temporary
08:06:31 <shapr> neat
08:10:03 <SickJacken> hey, its always good to be home and have your mom cook dinner etc :D
08:10:26 <earthy> hm. I'm a slightly better cook than my mom was...
08:10:44 <earthy> unfortunately I don't have all her recipes... :(
08:11:07 <earthy> (yet... I think there's a notebook somewhere)
08:11:42 <earthy> anyway, back to kicking haskell into behaving
08:18:12 <SickJacken> :D
08:18:51 <earthy> hey, there's no computer science problem that cannot be solved by adding an extra layer of indirection, right. :)
08:19:34 <adept> except the problem of having too many layers of indirection
08:20:18 <earthy> oh, but it can. you hide all those layers under just one indirection. :P
08:21:11 <boegel> earthy: hehe :) it's just how you sell it, right ?
08:21:30 <earthy> well, newtype is just that, really
08:21:42 <earthy> add a layer of indirection
08:23:04 * xerox adds a layer of indirection on earthy
08:27:22 <SickJacken> the uust package never seems to build on a linux pc...it always mistakes when doing 'ar cru'
08:27:34 <SickJacken> but only for the profiling version of the lib
08:27:53 <earthy> hm. never tested that
08:28:18 <earthy> and I don't think there's anybody @cs.uu.nl that currently develops under linux
08:28:28 <earthy> but for the stratego folks
08:28:35 * shapr gives up for the day
08:29:12 * earthy passes a hand through the fur of one of his cats and finds his hands end up furry as well...
08:29:37 <boegel> shapr: already ? come on, even I am still working
08:31:06 <SickJacken> hmm dinner is ready
08:31:07 <SickJacken> later
08:33:54 <earthy> dinner? already?
08:34:14 <earthy> man... it's still like 30 degrees centigrade
08:37:24 <Lucinda> hi
08:37:30 <earthy> hi
08:37:51 <earthy> are you perhaps interested in programming in Haskell, Lucinda?
08:38:00 <Lucinda> does anyone know of a monad which works on tuples?
08:38:14 <earthy> um
08:38:18 <earthy> explain
08:38:22 <integral> "works on tuples"?  umm?  you can put tuples as the state in a state monad, or the environment in a reader monad
08:38:32 <Lucinda> ok
08:38:43 <earthy> and you can *always* put the tuples in the argument position of the monad
08:38:43 <Lucinda> well i need an example for a function...
08:38:50 <earthy> as monads are type constructors
08:39:03 <earthy> (in haskell, at least)
08:39:05 <Lucinda> f :: t1 -> t2 -> ... -> tk -> m (s1,s2)
08:39:06 <integral> fst . get :: State (a, b) a
08:39:47 <earthy> f a = return (a,a)
08:39:50 <Lucinda> yeah
08:39:52 <earthy> there you go. example provided. :)
08:39:54 <Lucinda> Id thought of that
08:39:56 <Lucinda> :)
08:40:07 <earthy> ofcourse, k=1 :)
08:40:55 <xerox> f = return . liftM (,)
08:41:01 <xerox> @pl \a -> return (a,a)
08:41:02 <lambdabot> return . join (,)
08:41:09 <xerox> BEEP, wrong :-)
08:41:54 <Lucinda> what does liftM do?
08:42:02 <earthy> (,) is dyadic, liftM only lifts monadic functions
08:42:03 <xerox> @type Control.Monad.liftM
08:42:04 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
08:42:04 <lambdabot> r
08:42:27 <earthy> you guessed return . liftM2 (,)
08:42:32 <earthy> @type Control.Monad.liftM2
08:42:34 <lambdabot> forall r (m :: * -> *) a2 a1.
08:42:34 <lambdabot> (Monad m) =>
08:42:34 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:43:01 <earthy> @type join
08:43:02 <lambdabot> bzzt
08:43:05 <earthy> @index join
08:43:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
08:43:06 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
08:43:06 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
08:43:14 <earthy> @type Control.Monad.join
08:43:15 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:43:29 <earthy> I should've known that
08:44:03 <Lucinda> Im confused
08:44:09 <earthy> as to what?
08:44:22 <Lucinda> what liftM, liftM2 and join actually do
08:44:58 <earthy> ah
08:45:17 <earthy> liftM takes a function and lifts it to function under the monad
08:45:32 <Lucinda> can you give an example?
08:45:48 <earthy> yes. suppose I have the monad Maybe Int
08:45:53 <Lucinda> yep...
08:46:08 <xerox> @wiki MonadsAsContainers
08:46:09 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
08:46:09 <earthy> and 2 values of that monad, say   Just 1 and Just 2
08:46:14 <Lucinda> yup...
08:46:18 <xerox> This article explains join, above other things
08:46:19 <Lucinda> i think i can see where this is going
08:46:27 <earthy> I cannot then calculate (Just 1) + (Just 2)
08:46:32 <Lucinda> yep...
08:46:41 <earthy> but I *can* calculate liftM2 (+) (Just 1) (Just 2)
08:46:47 <Lucinda> ah I see
08:46:54 <Lucinda> and the would return Just 3 ?
08:47:08 <xerox> @plugs liftM2 (+) (Just 1) (Just 2)
08:47:13 <lambdabot> Just 3
08:47:16 <Lucinda> cool
08:47:23 <xerox> @karma+ Lucinda  ;)
08:47:24 <lambdabot> Lucinda's karma raised to 1.
08:47:29 <Lucinda> cheers
08:47:46 <Lucinda> @type (,)
08:47:49 <lambdabot> forall b a. a -> b -> (a, b)
08:47:54 <earthy> ofcourse, liftM2 (+) (Just 1) (Nothing)   would result in Nothing
08:48:04 <earthy> @eval liftM2 (+) (Just 1) (Nothing)
08:48:05 <Lucinda> @plugs (,) 1 2
08:48:11 <lambdabot> Nothing
08:48:13 <lambdabot> (1,2)
08:48:16 <Lucinda> @eval (,) 1 2
08:48:18 <lambdabot> (1,2)
08:48:41 <ProfTeggy> The lambdabot dude knows his thing ;-)
08:48:46 <mflux_> @pl \a b c d -> ((a, b), (c, d))
08:48:47 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
08:48:49 <Lucinda> @eval liftM (,) (Just 1) (Just 2)
08:49:06 <xerox> (Just 1,Just 2)
08:49:10 <Lucinda> cheers
08:49:23 <xerox> no
08:49:26 <xerox> bzzt I think
08:49:30 <earthy> yes, but that gives you (Maybe Int, Maybe Int) as type
08:49:34 <lambdabot> Couldn't match `(->) t' against `Maybe'
08:49:36 <earthy> and not Maybe (Int,Int)
08:49:36 <ProfTeggy> Just (1,2) rather
08:49:43 <Lucinda> @hoogle
08:49:53 <Lucinda> @hoogle liftM2
08:49:57 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
08:50:31 <beelsebob_> @type Lucinda
08:50:34 <earthy> anyway, things clearer to you, Lucinda? :)
08:50:39 <Lucinda> @type liftM
08:50:55 <Lucinda> im confused...what is the differnce between liftM and liftM2
08:51:02 <lambdabot> bzzt
08:51:03 <lambdabot> bzzt
08:51:12 <xerox> Lucinda: the arity of the funciton lifted
08:51:15 <xerox> *function
08:51:18 <Lucinda> @hoogle liftM
08:51:21 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
08:51:21 <lambdabot> Monad.liftM3 :: Monad a => (b -> c -> d -> e) -> a b -> a c -> a d ->
08:51:21 <lambdabot> a e
08:51:21 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
08:51:27 <Lucinda> but
08:51:40 <Lucinda> @liftM (,) (Just 1) (Just 2)
08:51:41 <lambdabot> Unknown command, try @listcommands.
08:51:50 <Lucinda> @eval liftM (,) (Just 1) (Just 2)
08:51:53 <earthy> type error
08:51:58 <Lucinda> ah
08:52:01 <xerox> @type (,) 1
08:52:18 <earthy> well, not necessarily a type error per se
08:52:20 <Lucinda> oh yeah
08:52:22 <lambdabot> Couldn't match `(->) t' against `Maybe'
08:52:23 <Lucinda> im being stupid
08:52:24 <Lucinda> :)
08:52:25 <lambdabot> forall a b. (Num a) => b -> (a, b)
08:52:51 <Lucinda> sorry for some reason i couldnt distinguish the types for liftM and liftM2
08:52:54 <earthy> ;)
08:53:09 <xerox> BBL
08:53:11 <Lucinda> yeah thats made things a lot clearer cheers
08:54:08 <Lucinda> @hoogle split
08:54:12 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
08:54:12 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
08:54:12 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
08:54:38 <Lucinda> @eval Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9]
08:54:55 <lambdabot> ([1,2,3,4,5,6,7],[8,9])
08:55:13 <Lucinda> interesting
09:04:48 <Lucinda> @eval return (Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9])
09:04:51 <lambdabot> <Plugins.Eval>:1:12:
09:04:51 <lambdabot>   No instance for (Show (m ([a], [a])))
09:04:51 <lambdabot>   arising from use of `show'
09:05:35 <Lucinda> @eval show.return (Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9])
09:05:37 <lambdabot> <Plugins.Eval>:1:12:
09:05:37 <lambdabot>   No instance for (Show (a -> String))
09:05:37 <lambdabot>   arising from use of `show'
09:05:54 <Lucinda> @eval show $ return (Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9])
09:05:57 <lambdabot> <Plugins.Eval>:1:18:
09:05:57 <lambdabot>   No instance for (Show (m ([a], [a])))
09:05:57 <lambdabot>   arising from use of `show'
09:09:31 <earthy> @eval Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9]
09:09:33 <lambdabot> ([1,2,3,4,5,6,7],[8,9])
09:10:04 <earthy> @eval (return ( Prelude.splitAt 7 [1,2,3,4,5,6,7,8,9])) :: Maybe ([Int],[Int])
09:10:06 <lambdabot> Just ([1,2,3,4,5,6,7],[8,9])
09:15:04 <Lucinda> earthy: was it because it didnt know which monad to use?
09:18:48 <earthy> lucinda: it was because you didn't specify a monad
09:18:57 <earthy> and you can't show an unspecified monad
09:19:15 <Lucinda> ok
09:19:36 <earthy> for stuff like this Control.Monad.Identity or Maybe are good choices
09:23:06 <earthy> goody... I've sent the type inferencer into the woods on a path it won't be able to come out of
09:25:31 <SickJacken> ahhh nice hot dinner is what i needed
09:26:52 <earthy> ah, hot dinner...
09:26:56 <earthy> that'll have to wait
09:27:10 <earthy> time to see if type annotations fix this
09:29:35 <z0d> SyntaxNinja: hello. do you use ghc and darcs?
09:29:58 <SickJacken> no no no earthy, eat before work :)
09:30:00 <SyntaxNinja> z0d: I'm afraid to answer... yes.
09:31:12 <z0d> SyntaxNinja: upgrading ghc removed darcs. according to musasabi maybe darcs needs to be recompiled with the new libgmp package
09:31:28 <SyntaxNinja> z0d: hmm. I do know a little something about this...
09:31:35 <earthy> ooh, wow. pagelong type errors
09:31:44 <SyntaxNinja> z0d: which version of debian?
09:31:55 <ProfTeggy> Bye bye
09:32:02 <z0d> SyntaxNinja: sid
09:32:10 <SyntaxNinja> z0d: which platform? when did you upgrade?
09:32:40 <z0d> SyntaxNinja: x86. a few days ago
09:32:44 <z0d> 2 or 3
09:33:10 <z0d> apt-get install darcs: darcs: Depends: libgmp3 but it is not installable
09:33:25 <SyntaxNinja> apt-get update && apt-get install darcs :)
09:33:29 <SyntaxNinja> I fixed that yesterday
09:33:41 <Akshaal> hail
09:34:04 <Lunar^> SyntaxNinja: someone said that haddock was FTBFS with latest GHC package
09:34:13 <z0d> SyntaxNinja: ah ok. thanks
09:34:18 <Lunar^> (last)
09:34:44 <SyntaxNinja> Lunar^: yeah, happy and haddock need to get uploaded... haddock I think has needs a new package flag. there are bug reports for these.
09:34:53 <Lunar^> SyntaxNinja: ok cool
09:35:22 <SyntaxNinja> Lunar^: But that's Igloo's job :) I tried to get his attention yesterday when I was bus building gthe packes by hand.  I could upload them.
09:35:32 <SyntaxNinja> Igloo: want to make me co-maint on those packages?
09:35:55 <Lunar^> SyntaxNinja: I was wondering if we could form a small team for haskell-debian
09:35:58 <SyntaxNinja> hi Akshaal
09:36:18 <Lunar^> SyntaxNinja: taking care of the packages together.. that would allow me to do more work on them, I think
09:36:19 <SyntaxNinja> don't we already have one? ;)
09:36:23 * SyntaxNinja nods
09:36:43 <Lunar^> having a darcs repo somewhere to use darcs-buildpackage or something
09:37:13 <CosmicRay> Lunar^: such as I've started at http://darcs.complete.org/debian?
09:37:27 <Lunar^> I do want to do more work on Debian, but I don't want to work alone, and I don't feel starting a new package just for the sake of it
09:37:31 <CosmicRay> Lunar^: that would be a great idea.
09:37:32 <Lunar^> CosmicRay: yep
09:37:43 <CosmicRay> Lunar^: the OCaml folks do that, but they use svn, and so, have all the associated issues.
09:38:22 <CosmicRay> they were a little surprised, maybe a bit miffed, when I started writing code and packaging stuff and didn't put it in their repo and set the maintainer to the ocaml list.
09:38:26 <Lunar^> CosmicRay: small team are a good trend I think.. I have given some of my thoughts about it on debian-women last month (IIRC) (without any reaction though)
09:38:55 <CosmicRay> I'd just say, put it in there where it makes sense, and leave it out where it doesn't.
09:39:11 <CosmicRay> I think things like haskell-devscripts, ghc, hugs, cabal, etc. could make sense to have in there
09:39:22 <CosmicRay> and whatever other packages people want to maintain as a team
09:39:32 <Lunar^> right :)
09:39:35 <CosmicRay> but of course one of the nice things about darcs is that there doesn't have to be a single central repo
09:39:47 <CosmicRay> maybe what we need is a central list of darcs repo URLs
09:39:50 * Akshaal loves debian
09:40:08 <CosmicRay> I publish all (well, almost all) of my Debian packages on darcs and encourage people to send me patches through darcs.
09:40:20 <CosmicRay> but I don't want to have to go periodically pull from some other debian repo.
09:40:50 <Lunar^> I don't know... if we form a team it could be better to have some kind of central place for newcomers
09:41:03 <Lunar^> but I would give a try to anything :)
09:41:19 <CosmicRay> you're thinking of sort of a mentoring arrangement for people new to packaging Haskell stuff for Debian?
09:42:08 <SyntaxNinja> I tried to get something like that going, but only one person was really responding, and I'm not even sure if I managed to upload all of his packages.
09:42:16 * SyntaxNinja should look into that.
09:42:32 <CosmicRay> see, we have to really approach things in a diferent way for it to work.
09:42:54 <CosmicRay> the ocaml people treated it as similar to a bsd ports tree -- everyone hacks on it, and periodically some random person from the team makes an upload.
09:43:01 <CosmicRay> that works fine if you've got a smallish team
09:43:07 <CosmicRay> and if you all know what each other is doing.
09:43:18 <CosmicRay> it's overkill for small one-off bindings
09:43:30 <Lunar^> CosmicRay: that could work for haskell packages I think
09:43:43 <CosmicRay> I could see it being useful for ghc and hugs, but then Igloo hasn't complained about the workload, and I don't know how many others have expertise to contribute there.
09:43:54 <Lunar^> CosmicRay: even for small one-off, you can still leave the possiblity for someone else to take care of it if you're away
09:43:56 <SyntaxNinja> hugs has never been a problem to manage alone
09:44:09 <CosmicRay> I would love to have help with haskell-devscripts.  debhelper uses perl and I have discovered that I have forgotten much perl since I last used it 6 years ago
09:44:16 <SyntaxNinja> I think the payoff would be more for libs or programs which all have to get uploaded at the same time
09:45:17 <CosmicRay> seems overkill to me for that too.  we have NMUs already for that sort of thing.
09:45:32 <CosmicRay> We should get an @lists.d.o list.
09:46:10 <Lunar^> CosmicRay: sure, but you need to be oa DD, etc
09:46:13 <Lunar^> -o
09:46:58 <CosmicRay> Lunar^: the word between "be" and "DD" appeared as "o007Fa" over hwere, what did you mean?
09:47:43 <CosmicRay> debian has only one list that is not open to the public, and I'm not suggesting that a debian-haskell should be like that.
09:48:29 <musasabi> How about simply sending more mail to debian-haskell@lists.d.o ?
09:48:29 <earthy> @type uncurry
09:48:31 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
09:48:49 <earthy> @type curry
09:48:50 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
09:49:02 <CosmicRay> musasabi: debian-haskell@lists.d.o doesn't exist
09:49:11 <CosmicRay> it is on some address I have to look up every time I post
09:49:16 <lispy> @type uncurry . curry
09:49:19 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
09:49:19 <CosmicRay> some finland thing or something
09:49:24 <CosmicRay> I don't remember.
09:49:27 <Lunar^> CosmicRay: you need to be a DD to do NMU
09:49:42 <CosmicRay> Lunar^: true, but then you need to be a DD to do any upload, so it's no worse off
09:49:54 <CosmicRay> you don't need to be a DD to make patches and send them to a DD to sign.
09:50:02 <Lunar^> CosmicRay: yep, I'm trying to see how I could get more involved
09:50:08 * musasabi thought it was on lists.d.o but now that you mention it seems that it is elsewhere.
09:50:33 <CosmicRay> ah.  debian-haskell@lists.urchin.earth.li
09:50:54 <CosmicRay> now I know why I thought it had something to do with urchins.
09:50:58 <SamB> what is a good way to read fairly structured binary files?
09:51:39 <CosmicRay> SamB: there has been some debate on that recently.  the short answer is, it depends on what you want to do with the data once read.
09:51:59 <CosmicRay> I would suggest starting with the functions in System.IO.Binary and do some googling if they're inadequate for your needs.
09:52:18 <earthy> @pl \f a b -> f (lift1 a) (lift1 b)
09:52:18 <lambdabot> flip flip lift1 . ((.) .) . (. lift1)
09:52:20 <CosmicRay> err sorry, just System.IO
09:52:21 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html#21
09:52:35 <xerox> My Google mentor was also mentoring a guy on this project: http://osmo.sourceforge.net/  Check out the flash demo, hehe, it's fun.
09:52:43 <SyntaxNinja> z0d: did that work for you/
09:52:47 <Lunar^> CosmicRay: Anyway, I'll try to think more of it and post something on the current list if no else does :)
09:52:47 <earthy> right. pointless style sucks.
09:52:55 <CosmicRay> Lunar^: that would be good.
09:53:01 <CosmicRay> Lunar^: I assume you would be infavor of darcs?
09:53:13 <Lunar^> CosmicRay: what else? :D
09:53:16 <SamB> err, the part about getting the bytes into memory is the easy part.
09:53:16 <CosmicRay> Lunar^: you might want to give some thought as to how you think people might best work together with darcs in this situation
09:53:16 <CosmicRay> heh
09:53:28 <CosmicRay> Lunar^: There are several different ways to do it, I'm not sure which is best right off-hand
09:53:50 <CosmicRay> Lunar^: anyway, thanks for thinking about this.
09:53:59 <Lunar^> I would be glad to get the return of ghc-snapshot (or whatever should we call the package)
09:54:01 <CosmicRay> Lunar^: anything people can do to bring more haskell to debian is good in my opinino.
09:54:09 <CosmicRay> Lunar^: oh btw, are you in NM?
09:54:18 <Lunar^> CosmicRay: we should rewrite apt, dpkg and debconf in Haskell ;)
09:54:32 <earthy> yeah, right. :P
09:54:36 <Lunar^> CosmicRay: no, I haven't done enough for Debian yet, IMHO
09:54:39 <CosmicRay> Lunar^: my my my, aren't we eager for a flamewar ;-)
09:54:53 <CosmicRay> Lunar^: have you worked on any debian packages?
09:55:04 <Lunar^> CosmicRay: not any official Debian package
09:55:20 <CosmicRay> Lunar^: some that you'd like to see in debian?
09:55:35 <beelsebob_> bah!
09:55:55 <CosmicRay> Lunar^: you should sign up now.  by the time someone gets around to processing your application, you'll be more than ready to be a DD ;-)
09:56:12 <Lunar^> CosmicRay: I don't want to work on package I don't use
09:56:20 <beelsebob_> I go through a board full of maths to define the correct items in the trace, and Olaf comes along and writes it in four lines!   On the plus side... I did prove that parent pointers are superflous
09:56:31 <Lunar^> CosmicRay: and everything get packaged too quickly :)
09:56:49 <CosmicRay> Lunar^: sorry about that ;-)
09:56:49 <Lunar^> CosmicRay: that's why I like the small team idea.. I enjoy to get things better
09:57:12 <CosmicRay> a lot of teams in debian are ad hoc, or at least started out that way.
09:57:15 <z0d> SyntaxNinja: it seems that the mirror I use doesn't the new package yet
09:57:31 <CosmicRay> Lunar^: I'd say, the best way to contribute now is to find something that's interesting, and send patches (diffs, darcs, whatever) or questions
09:57:39 <CosmicRay> Lunar^: know perl?
09:58:13 <Lunar^> CosmicRay: I often do that.. but it's easier to do that in a more cooperative way
09:58:37 <CosmicRay> Lunar^: hey are you the guy that volunteered to help the SPI treasurers?
09:58:38 <SyntaxNinja> z0d: oh hm. doesn't look like it hit most mirrors yet.  seems a bit slow
09:58:40 <Lunar^> CosmicRay: I have some kind of repulsion toward Perl, but autrijus is going to make me learn Perl 6 if lambdacamels goes one like they do
09:58:50 <CosmicRay> Lunar^: I can identify with that.
09:58:52 <SyntaxNinja> z0d: should be 1.0.3-2
09:59:03 <Lunar^> CosmicRay: nope
09:59:14 <CosmicRay> Lunar^: ok, never mind, too many nicks and names.
09:59:16 <z0d> SyntaxNinja: thanks, I'll try it
09:59:21 <CosmicRay> my internal implementation of Data.Map is lossy.
10:07:22 <z0d> SyntaxNinja: does your mirror have it?
10:08:01 <Lunar^> SyntaxNinja: did you get any feedback from David Roundy btw?
10:08:01 <SyntaxNinja> z0d: apt-get source and a debuild will solve your problem if you're desperate
10:08:13 <Lunar^> SyntaxNinja: I feel loosy about that whole issue
10:08:18 <SyntaxNinja> Lunar^: feedback wrt what?
10:09:29 <Lunar^> SyntaxNinja: FUSE binding
10:10:02 <SyntaxNinja> z0d: no
10:10:24 <SyntaxNinja> Lunar^: oh, a little bit... not much actually, he didn't react to my mention of hfuse, maybe he missed it
10:10:31 <SyntaxNinja> I was interested in his virtual filesystem thingy
10:10:35 <SyntaxNinja> so we talked about that a bit.
10:11:34 <Akshaal> is there plan for implementing first-class modules in ghc?
10:11:59 * SyntaxNinja meeting &
10:12:25 <Lunar^> Akshaal: I don't think so, you could ask on the mailling-list though
10:39:51 <xerox> <interactive>: Prelude.read: no parse
10:39:53 * xerox screams
10:40:38 <SyntaxNinja> @eval read "screams"
10:40:50 <SyntaxNinja> @wiki
10:40:53 <lambdabot> <Plugins.Eval>:1:12:
10:40:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:40:53 <lambdabot>   `Show a' arising from use of `show'
10:40:53 <lambdabot> http://www.haskell.org/hawiki/
10:41:03 <SyntaxNinja> @eval (read "screams")::Int
10:41:06 <lambdabot> Prelude.read: no parse
10:41:08 <SyntaxNinja> darn
11:22:45 <Igloo> CosmicRay: SyntaxNinja: I think co-maintanance of packages would make me less efficient overall. If people wanted to work on the hard stuff, like patches to support ghci, object splitting and even NCG on other arches then that would be great though
11:23:37 <Igloo> CosmicRay: SyntaxNinja: I also think NM drive seems to have fizzled rather (not sure what effect eh ghc6 issue had on that). I noticed Arjan seems to have disappeared from NM the other day after waiting in the to-be-advocated pile for a while
11:25:45 * Heffalump would like to find some time to set up some infrastructure for co-maintaining and backporting packages
11:25:50 <Heffalump> but...
11:26:06 <Igloo> Lunar^: One thing that would be really great, both for Debian and Haskellers in general, is testsuites (preferably ones that can be run either as part of the package build or for an installed package) BTW
11:27:30 <Igloo> For the "while building" testsuites I think we'd need cabal's currently non-existant (AFAIK) install-in-place, though
11:29:03 <Igloo> Lunar^: See http://urchin.earth.li/~ian/haskell-policy/haskell-policy.html/ch-testsuites.html for my proposed interface so they can be automatically run to test after a new compiler comes out or whatever
11:32:51 <Akshaal> could anybody explain Test.QuickCheck.Batch.TestResult ?
11:33:38 <Akshaal> meanings of arguments for TestOk TestExausted TestFailed TestAborted
11:49:38 <SickJacken> what the default app for ps files?
11:50:11 <SickJacken> under linux
11:50:47 <Akshaal> ghostscript (gs)
11:54:30 <Lunar^> Igloo: thanks for the pointer
11:54:44 <kaol> I would use ghostview (gv) instead
11:55:42 <cjb> My Ubuntu install uses ggv.
11:56:34 <SickJacken> ah ggv that was the name
11:56:35 <SickJacken> thanks
11:59:13 <Akshaal> quickcheck looks like nice idea, but its API is terrible
12:15:45 <SickJacken> if i have a package also compiled for profiling...should there be a HSuust.p_o in addition to HSuust.o?
12:19:52 <SickJacken> AHHHHHHHHHHHH this bloody uust tree is driving me insane
12:19:57 <SickJacken> i get ghc-6.4: unknown package: uust
12:20:03 <SickJacken> but ITS THEREEEE
12:28:38 <SickJacken> i quit
12:52:29 * poetix doesn't understand how GHC does linking when importing C functions through FFI
12:54:24 <poetix> When I do ghc -fffi -c ClientBuffer.hs, an object file is created - but presumably the client_buffer.o object file for the C functions isn't linked to it at that point?
12:54:33 <musasabi> yes.
12:54:49 <musasabi> you have to separately suply the file containing the symbol to GHC.
12:55:05 <poetix> What's the incantation for that?
12:55:27 <musasabi> ghc -fffi -c ClientBuffer.hs my_c_implementation.o
12:55:47 * poetix goes away and tries it
12:55:55 <musasabi> or actually wait.
12:56:20 <musasabi> if you are using -c to compile the object files you will need my_c_implementation.o only in the final link phase.
12:56:38 <poetix> How will I supply it then?
12:57:08 <poetix> At the moment I get linker errors, presumably because I don't supply it
13:00:23 <musasabi> poetix: are you using make or some similar tool?
13:00:28 <poetix> Yes
13:00:57 <musasabi> poetix: just add it to the final ghc a.o b.o c.o ... -o foobar command.
13:03:49 <poetix> OK, now I get even more confusing errors...
13:04:20 <poetix> It seems to want to know where all the libs referenced by the C source are, too
13:04:43 <poetix> It doesn't help that the C source is really C++ with extern "C" declarations
13:05:07 <musasabi> poetix: could you paste the errors somewhere?
13:05:24 <musasabi> poetix: adding -lfoo for libfoo can work.
13:07:09 <musasabi> Using C++ libraries is possible but makes an interesting fight and I haven't gotten them to work inside ghci although compiled apps are fine.
13:12:02 <poetix> Oh, hey, it just worked...
13:12:14 <poetix> -lfoo did the trick
13:12:39 <poetix> And a.out ran without segfaulting or otherwise complaining
13:13:58 <poetix> musasabi: thanks, you've just saved me possibly hours of glaring at documentation
13:14:32 <musasabi> np
13:19:45 <ulfdoz> bye
13:38:00 <ski> @arr
13:38:01 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
13:51:07 <SyntaxNinja> w00t
13:53:08 <SyntaxNinja> Igloo: CosmicRay: lunar: heffalump: so maybe co-maint isn't quite the answer, but if we just had public repos where ppl were welcome to send patches?
13:53:12 <SyntaxNinja> via darcs
13:54:29 <poetix> If a compiled Haskell program terminates by sending the word "Aborted" to the console and stopping, that's bad isn't it?
13:55:24 <SyntaxNinja> depends on whether or not youw anted it to stop? ;)
13:55:33 <SyntaxNinja> yeah, that means it crashed
13:55:35 <poetix> I don't think I did...
13:56:52 <poetix> OK, it's definitely an error in the C code - if I comment out the function body and just call the empty through FFI, it's all sweetness
14:00:04 <Itkovian> enjoy ... http://messenger.jhuapl.edu/the_mission/images/flyby_images/mdis_depart.mpeg
14:03:31 <SamB> @index !
14:03:36 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap,
14:03:36 <lambdabot> Data.Map, Data.Array, Text.Html
14:06:45 <xerox> @type Data.Map.!
14:06:50 <lambdabot> bzzt
14:06:54 <xerox> @type (Data.Map.!)
14:06:55 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> k -> a
14:11:08 <poetix> xerox: I can call a method on a ClientBuffer object now!
14:11:21 * xerox runs around in circle
14:11:27 <xerox> "Cool! Cool!"
14:14:29 <xerox> poetix: what now?
14:17:37 * SamB wonders if GHC can optimize consecutive gets
14:18:13 <TheHunter> very unlikely
14:18:27 <SamB> yeah, I suppose so
14:18:50 <SamB> but it seems like it ought to be so easy!
14:24:10 <SickJacken> question...when i run my app it takes up 1.5 gigs....i do a profiling (compiled with -prof -auto-all) and run it with +RTS -hc -RTS....the highest mem usage accoording to the graph is 80mb
14:24:16 <SickJacken> what am i doing wrong?
14:27:32 <Igloo> What do you mean by "it takes up 1.5 gigs"?
14:28:27 <SickJacken> well, if i let my app run and look at 'top'
14:28:39 <SickJacken> i see it draining 1 gig of virtual mem
14:28:48 <SickJacken> and almost 450 of 'real' meme
14:28:52 <SickJacken> -e
14:28:53 <Igloo> What does top say while you run it with profiling?
14:29:03 <SickJacken> hmmm
14:29:04 <SickJacken> good one
14:32:33 <SickJacken> Igloo, the app is currently on 160mb and rising
14:34:00 <Igloo> Do you allocate memory with malloc or any C libraries or anything?
14:37:12 <SickJacken> no
14:37:17 <SickJacken> im using just haskell stuff
14:37:23 <SickJacken> 'just'
14:37:29 <SickJacken> its at 275 mb now
14:40:06 <SickJacken> this sucks
14:40:13 <SickJacken> excuse me french
14:45:36 <Igloo> Not sure, then. I suggest you make a small test case and send it to the list
14:46:16 <Itkovian> wtf:http://www.thedailywtf.com/forums/43223/ShowPost.aspx
14:46:47 <SickJacken> my application uses attribute grammars that do analysis all over the place ....would it be sensible to send?
14:46:51 <SickJacken> to the list
14:47:01 * poetix 's wife allows him back on the computer
14:47:30 <poetix> xerox: The method that I call is "login", and it throws an error...
14:48:02 <poetix> But the error is a proper exception from the C++ lib, and is handled correctly
14:48:23 <poetix> So the actual FFI interface is working fine
14:48:56 <poetix> One of the things I need to think about is exception handling, actually
14:49:39 <poetix> If we catch C++ errors, how do we communicate them back across the C API? The obvious way is to return something like an HResult.
14:49:51 <ski> Itkovian : isn't that similar to the idiom of looping through e.g. a file stream until eof exception which makes you stop in a handler ?
14:50:37 <ski> (Itkovian : one point of doing something like this could be to avoid "interpreting" i.e. checking for bad case all the time)
14:50:43 <Itkovian> ski: hmmm ... once a reviewer actually told me to rewrite my record/replay code, because people actually use exceptions to model control flow. I was amazed.
14:51:03 <Itkovian> ski: but in a fucking loop!
14:51:05 <Itkovian> come on
14:51:31 <Itkovian> loops are way less costly, say two bad predictions vs. an exception handler that is run
14:51:43 <poetix> Itkovian: Python generators throw StopIteration when they run out of values to return...
14:52:20 <Itkovian> poetix: that is when one uses an iterator, hmm, seems weird to me, but this is a bloody for-loop
14:52:21 <dbremner> ltkovian - a couple weeks ago I was talking with a MS employee who worked on their XML libraries. For some reason the code had been written to throw an exception on EOF, because, of course, a file ending is an exceptional circumstance. They tweaked that part and got a 10% speedup
14:52:42 <Itkovian> hehe
14:52:50 <Itkovian> MS, I should have guessed ;-)
14:53:06 <Itkovian> dbremner: I will quote you on this
14:53:16 <vegai> are there actually any companies where the produced code has any quality?
14:53:22 <Itkovian> lol
14:53:26 <Itkovian> fraid not
14:53:29 <xerox> poetix: I did manage to `convert' exceptions to IO Exceptions in cairo code, mostly.
14:53:30 <vegai> for the sake of fairness, let's filter startup companies from this search
14:53:53 <dbremner> ltkovian - the larger the organization the more it tends towards mediocrity.
14:54:14 <poetix> xerox: Did you do that by checking return values?
14:54:24 <xerox> poetix: but cairo provides a getStatus function.
14:54:52 <poetix> So you call something, then do getStatus to find out if it succeeded?
14:56:06 <xerox> In case of troubles, the lib resets the cairo_context to a dummy value which is equivalent to a 'no operation' for the successive cairo calls - so I can check the CAIRO_STATUS at the end of a block-scoped "withCairo" function.
14:56:47 <xerox> (Which is called renderWith, in fact, to do an eye-pleasing (and more meaningful, since one does not 'see' the cairo_context at all) renderWith surface $ do ..)
14:57:29 <poetix> heh. Block-scoped withFoo functions. I have one of those already...
14:57:59 <xerox> What for?
14:58:15 <poetix> Oh, just to make sure we call deleteBuffer on a buffer after we've used it
14:58:45 <xerox> Just wondering :-)  It makes sense, I suppose, to scope clientBuffers.
14:59:19 <poetix> I may switch to using ForeignPtr to manage object lifetimes, since we mostly don't need deterministic finalization
15:00:17 <Itkovian> howcome darcs send only tries the last patch and not any before that?
15:00:54 <xerox> Itkovian: darcs push does sync two repos in fact.
15:01:20 <Itkovian> xerox: yes, but the second one is way behind a firewall, so a send -o file would do I'd think
15:01:28 <poetix> Using scoping for error handling is an interesting idea though, although I guess it makes more sense when you have blocks of code that tend to chain a lot of operations together and don't want to be checking for exceptions for every single one individually
15:01:40 <xerox> Itkovian: I don't know if you should check it by hand... :-\
15:01:54 <xerox> poetix: I think so too.
15:02:08 <poetix> Is getStatus thread-safe?
15:06:54 <Itkovian> hmm ...
15:07:30 <xerox> poetix: good question.  I'll answer you.. sometime.
15:08:19 * poetix imagines thread A getting thread B's exceptions, and other horrors
15:09:45 <poetix> Anyhow, time for bed again. I'll do a darcs push first, so you can see what's there if you're interested.
15:10:04 <xerox> poetix: I could have the answer in some minutes!
15:10:20 <xerox> poetix: getStatus _isn't_ available for the end user.
15:11:56 <poetix> Oh, what's the marshaller for CInts btw?
15:12:36 <musasabi> fromIntegral
15:12:37 <xerox> cIntConv
15:12:41 <xerox> Which is fromIntegral
15:12:48 <xerox> Oops.  musasabi was faster.
15:13:09 <xerox> poetix: anyway, the theory is that cairo is thread safe as long as one thread at time does a call on the same context.
15:13:27 <xerox> There is a bug opened because they made an error in that sense if you care: https://bugs.freedesktop.org/show_bug.cgi?id=4299
15:13:40 <poetix> OK, so things like getStatus might be scoped to a context
15:13:55 <poetix> That makes sense.
15:15:49 <poetix> I get a type error trying to return a 'CInt' from a function and marshall it with cIntConv - says it's expecting an Int, and infers a CInt
15:16:23 <tuomov> do multiple threads really need to access a graphics library?
15:16:30 <xerox> poetix: just use Int.
15:16:39 <xerox> c2hs is smart enough in these cases.
15:16:42 <Itkovian> night
15:16:48 <poetix> Then I have to have unsigned ints in the C api
15:17:16 <poetix> Or it complains at me that it wants a CInt
15:18:31 <xerox> Uh?!
15:18:47 <poetix> Dammit, I'm going to get into trouble if I take any longer trying to fix this tonight
15:19:03 <poetix> I'll have to push it to the repo tomorrow, it's time to go...
15:19:29 <xerox> You could... whatever.
15:30:25 <vegai> http://lists.gnu.org/archive/html/emacs-devel/2005-06/msg00789.html
15:37:21 <Micket> Is there something simliar to splitAt that works like takeWhile / dropWhile
15:39:00 <arjanb> @type Data.List.span
15:39:02 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:46:21 <Micket> thanks!
16:15:18 <musasabi> Lemmih: hackage-bootstrap seems to fail in building GnuPG, and is fixed by a "mkdir src; mv System src/" inside the GnuPG dir.
17:22:09 <TheHunter> FrederikEaton, have you seen this? http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters
18:35:14 <luqui> TheHunter, poke
18:42:55 <TheHunter> yes?
19:28:15 <SnakeEyesDCLXVI> anyone willing to help me figure something out?
19:28:59 <dave_m> what sort of thing is it?
19:29:33 <SnakeEyesDCLXVI> I'm just starting on Haskell, found a college lecture, but can't get it to run in Hugs
19:30:22 <dave_m> are you getting an error message?
19:30:22 <olliej> how do you mean can't get it to run?
19:31:17 <SnakeEyesDCLXVI> i copy the example exactly, but Hugs tells me that Last generator
19:31:17 <SnakeEyesDCLXVI>  in do {...} must be an expression
19:32:00 <dave_m> what does the example look like?
19:32:16 <SnakeEyesDCLXVI> import ParseLib
19:32:16 <SnakeEyesDCLXVI> digitList :: Parser String
19:32:16 <SnakeEyesDCLXVI> digitList = do char '['
19:32:16 <SnakeEyesDCLXVI> 			d <-digit			
19:32:16 <SnakeEyesDCLXVI> 			ds <- many (do char ','
19:32:17 <SnakeEyesDCLXVI> 						  digit)
19:32:19 <SnakeEyesDCLXVI> 			char ']'
19:32:21 <SnakeEyesDCLXVI> 			return (d)
19:32:30 <SnakeEyesDCLXVI> minus the black boex
19:32:34 <SnakeEyesDCLXVI> *boxes
19:33:17 <dave_m> that looks like it should work. I'm guessing there's a layout problem
19:33:41 <SnakeEyesDCLXVI> would brackets help, or is it just spacing and layout?
19:34:09 <dave_m> do you possibly have a mixture of spaces and tabs? that would confuse things & be hard to see
19:34:20 <SnakeEyesDCLXVI> i do, let me clean it up
19:34:27 <SnakeEyesDCLXVI> spaces better than tabs?
19:34:46 <dave_m> marginally. It doesn't really matter as long as you're consistent
19:35:02 <olliej> it might also help if you use lisppaste -- prevents our clients from doing funky things with indentation
19:35:30 <phb> hm, anyone got any idea why a 'map f x' function would call f only for the first entry in the x array, and then return?
19:36:05 <olliej> errrr...
19:36:13 <olliej> does x have more than one element?
19:36:15 <dave_m> this is the standard map from the Prelude?
19:36:29 <olliej> oh hang on
19:36:38 <olliej> is f a ffi function?
19:36:54 <olliej> with a side effect you haven't mentioned? (such as counting number of calls)
19:37:03 <phb> dave_m: yep, x has 64 elements (according to (me trying to debug using 'trace' from Trace)
19:37:15 <phb> lettme paste, 2sec
19:37:38 <lisppaste2> phb pasted "probs with map" at http://paste.lisp.org/display/11494
19:37:50 <dave_m> map is only going to call f when you examine the cells
19:37:58 <dave_m> it evaluates lazily
19:38:04 <olliej> yeah
19:38:14 * olliej didn't know about trace for counting :)
19:38:31 <olliej> basically haskell won't evaluate a function till it has to
19:38:50 <phb> ah. doh. explains why.. I don't have hugs installed on my windows machine, so I wrote up a quick hack to make it simply create the array instead of displaying all items on screen.. *stupid*
19:38:56 <olliej> so it won't evaluate f (x!!63) till you try to access the 64th element
19:39:41 * olliej knows all about lazy evaluation 
19:39:53 * olliej is having to implement it
19:40:21 <phb> :=)
19:46:45 <SnakeEyesDCLXVI> thanks davem and olliej, got it sorted out now
19:47:16 <SnakeEyesDCLXVI> Main> papply digitList "[1,2,3]"
19:47:16 <SnakeEyesDCLXVI> [("123","")]
19:48:01 <dave_m> glad I could help
19:50:34 <phb> Where can i get "SOEGraphics" for win32?
19:51:38 <dave_m> Have you tried <http://haskell.org/soe/software.htm>?
19:52:52 <phb> excellent, thanks.. odd.. google is really bad with finding stuff on haskell.org..:/
19:53:51 <dave_m> I guess not enough people link to it.
19:58:10 <gzl> phb: you can always do "<query> site:haskell.org"
19:58:33 <gzl> for example: http://www.google.com/search?q=SOEGraphics%20windows%20site:haskell.org
19:59:19 <phb> true
19:59:32 <dave_m> of course, that only works if the information you're looking for is on haskell.org somewhere
20:01:30 <dave_m> is there any information about SOE on the wiki?
20:03:56 <phb> I was trying to find some docs about it this morning, didn't find much, but my laboration requires me to use it, so =)
20:07:36 <dave_m> they should mention the book's web site, though. If nothing else, the errata are probably useful
22:57:29 * boegel awakes way too early
22:58:27 <Lemmih> Morning boegel.
22:58:39 <boegel> hi Lemmih
22:58:53 <boegel> are you up early or late ? :)
22:59:23 <Lemmih> Early. Woke up some hours ago.
22:59:41 <boegel> same here, but I had to wake up early to get here in time
23:02:26 * boegel is getting nervous
23:15:58 <earthy> Good Morning #haskell
23:16:29 <boegel> @y0w
23:16:30 <lambdabot> If I felt any more SOPHISTICATED I would DIE of EMBARRASSMENT!
23:21:18 <vikasg> yo dblhelix
23:21:32 <dblhelix> hi vikasg
23:25:14 <boegel> hi vikasg dblhelix
23:27:05 <vikasg> hi boegel, how's the proposal going?
23:27:44 <boegel> vikasg: I have to do a presantation on it in 45m, and I'm nervous as hell
23:27:57 * earthy gives boegel a nice cup of tea
23:28:18 * boegel spits it out
23:28:24 <boegel> tea in the morning, are you nuts !
23:28:36 <earthy> to soothe your nerves
23:28:44 * boegel enjoys his cold choco
23:31:46 <earthy> good. time to go.
