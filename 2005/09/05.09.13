00:00:13 <sethk> dcoutts, I have dabbled in gtk2hs.  I have qualms about gtk, though.
00:00:18 <Cale> I can't recall what it was named at the moment.
00:00:30 <dcoutts> sethk, have you noted your interest on: http://www.haskell.org/hawiki/hIDE
00:00:32 <sethk> it is very spotty.  not w.r.t haskell, in general.
00:00:42 <sethk> dcoutts, no, not yet, but I will try to do so tomorrow.
00:00:43 <dcoutts> sethk, spotty? how so?
00:01:13 <dcoutts> you mean it has wierd api in places?
00:01:18 <sethk> dcoutts, things like incremental completion on dialogs, a lot of details that, say, QT does well, gtk is not great
00:01:20 * dblhelix switches from blah to haskell mode
00:01:27 <sethk> dcoutts, that too, the API can be odd
00:01:34 <sethk> dcoutts, and has some legacy strangeness
00:01:41 <dcoutts> sethk, yes there are various bits of depracted api
00:01:50 <dcoutts> depricated
00:01:55 * dcoutts an't spell
00:02:11 <sethk> mee neeether
00:02:40 <dcoutts> sethk, the incremental completion of dialogs? you mean the "instant apply" rather than having to press ok/apply in the dialog?
00:03:16 <dcoutts> that was a deleberate UI choice by the Gnome people after doing a bunch of usability studies
00:03:18 <sethk> no, more like what happens in qt, where if you type in two letters of the filename, the dialog advances to the first file name matching
00:03:25 <dcoutts> oh
00:03:29 <dcoutts> it does that now
00:03:37 <dcoutts> the filechooser dialog
00:03:43 <sethk> about time.
00:03:47 <dcoutts> yes :-)
00:04:03 <dcoutts> it was indeed a sore point for rather too long
00:04:25 <sethk> there are others, I'm sure, that is just the most obvious one that popped into my mind.
00:04:37 <sethk> but I need to bring myself up to date, obviously.
00:04:48 <sethk> I'll try to get on the wiki tomorrow.
00:04:52 <dcoutts> cool
00:05:22 <dcoutts> gtk has indeed got better with recent releases, eg more widgets, better apis, better windows support etc
00:05:46 <ProfTeggy> Good morning
00:05:46 <dcoutts> and now it's got excelent vector graphics :-)
00:06:03 <Cale> http://www.sandr.dds.nl/FunctionalForms/index.html
00:06:59 <dcoutts> Cale, yes it's interesting. It's not clear to me if it's a general way of structuring GUIs or just dialog windows.
00:07:14 <Cale> dcoutts: it's just for dialogs
00:07:21 <dcoutts> right
00:07:38 <int-e> let cmp (a,_) (_,b) = compare a b; list = [(1,1),(1,1),(0,1),(1,0)] in (head $ Data.List.sortBy cmp list, Data.List.minimumBy cmp list)
00:07:44 <int-e> @eval let cmp (a,_) (_,b) = compare a b; list = [(1,1),(1,1),(0,1),(1,0)] in (head $ Data.List.sortBy cmp list, Data.List.minimumBy cmp list)
00:07:45 <lambdabot> ((1,1),(1,0))
00:08:04 <dcoutts> we've got a couple other prototypes for gui combinator libs based on top of Gtk2Hs and using arrows.
00:08:10 <int-e> ProfTeggy: would that be enough to convince you that head.sort and minimum do not perform the same computation?
00:08:10 <Cale> (but dialogs are important, because they're often the messiest bits)
00:09:55 <musasabi> How should Unique in GHC be used?
00:10:38 <sethk> 'night all, I have to try to get some sleep over here in New York.
00:11:00 <Cale> int-e: is that even a partial order?
00:11:19 <int-e> Cale: of course not. if it were, the results would indeed be the same.
00:11:42 <int-e> Cale: (because sort is a stable sort and min prefers the first element over the second)
00:12:04 <int-e> Cale: it's besides the point though because ghc does not enforce Ord instances to be a partial order.
00:12:12 <Cale> I think it's safe to say that sortBy is only intended for use with comparison operators which at least provide a partial order.
00:12:31 <Cale> (and minimumBy for that matter)
00:13:09 <int-e> Cale: I know, but it's still a different computation underneath.
00:14:02 <Cale> oh, sure
00:14:08 <Cale> @eval sortBy (\x y -> compare ((x+1) `mod` 3) ((y+1) `mod` 3)) [1,2,3]
00:14:10 <lambdabot> [2,3,1]
00:15:24 <int-e> Cale: I cheated by not using a partial ordering in order to avoid having to discuss the underlying algorithm in detail to show that.
00:17:29 <Cale> I'd think that they would be equivalent in the presence of a partial ordering though.
00:17:46 <Cale> hmm... well, possibly not quite
00:17:54 <Cale> total ordering definitely
00:18:01 <int-e> Cale: they are even for partial orders
00:18:18 <int-e> Cale: (for the implementation that's used in the ghc libs)
00:18:26 <Cale> that's good
00:20:21 <Itkovian> nice hs-plugins article on lambda-the-ultimate
00:23:07 <dcoutts> Itkovian, ah yes don's hs-plugins papers. I'm just re-reading the second of those.
00:26:25 <boegel> yo Itkovian
00:26:27 <boegel> hey ProfTeggy
00:26:41 <Itkovian> ho boegel
00:27:26 <int-e> Cale: In fact if they were not I'd have produced an example with a partial order instead ;)
00:27:59 <ProfTeggy> <- currently in oral examinations
00:29:52 <Itkovian> boegel: could I shamelessly steal some of your figures (at least the form) for my poster?
00:30:21 <Itkovian> ProfTeggy: shouldn't you listen to what the students say then? Or are they talking rubbish?
00:30:59 <int-e> ltkovian: he probably just had a short break between two students.
00:31:58 <int-e> Itkovian: or rather, exams.
00:32:40 <Itkovian> heh, enough to wipe the sweat from his head caused by deep cleavage and short skirts ...
00:35:41 <boegel> Itkovian: you mean the images from my proposal ?
00:36:13 <boegel> Itkovian -> #haskell-blah
00:37:28 <Itkovian> boegel: yes
00:51:11 <musasabi> Has anyone had success with loading GHC into GHCI?
00:51:52 <Lemmih> Don't think it's possible.
00:51:59 <musasabi> I keep having problems with hooks (can be #ifdeffed away from parser/hschooks.c) and RtsFlags which I cannot currently solve.
01:03:08 * shapr boings
01:03:11 <shapr> Good morning #haskell!
01:03:18 <Lemmih> Hi shapr.
01:03:25 <Cale> good morning shapr
01:03:44 <boegel> shapr: join us in #haskell-blah !
01:04:31 <boegel> shapr: problems with scannedinavian again ?
01:08:47 <dcoutts> shapr, we can't get to scannedinavian
01:09:55 <dcoutts> shapr, tracepath reports that we can't get any further than 213-242-137-166.interact.se
01:10:24 <dcoutts> but some people in other parts of the net can get there
01:10:26 <dcoutts> odd
01:12:21 <shapr> It's because the dns changed.
01:12:29 <shapr> it's not at interact.se anymore.
01:12:57 <shapr> lemme see if I fixed all of the dns files.
01:14:12 <shapr> oops, I forgot to update the serial on scannedinavian.org
01:14:30 <shapr> Should work now.
01:15:38 <tuomov> 404
01:15:57 <tuomov> for the main page, if there's supposed to be anything there
01:15:57 <shapr> huh, weird
01:16:01 <shapr> Yeah should b
01:16:47 * Lemmih pokes dcoutts with the hide-design stick.
01:19:07 <dcoutts> Lemmih, ouch
01:22:24 <dcoutts> Lemmih, did you have some stuff to add to http://www.haskell.org/hawiki/hIDE ?
01:27:11 <olliej> does anyone have a clue what GHC.Base.getTag actually does?
01:27:41 <olliej> beyond calling GHC.Prim.dataToTag#?
01:29:38 <int-e> olliej: getTag x = x `seq` dataToTag# x
01:30:37 * boegel invites Lemmih to #haskell-blah
01:30:38 <Lemmih> dcoutts: I would like to starting discussing more concrete issues like plugin design/API.
01:30:42 <boegel> and everyone else is welcome too
01:30:53 <dcoutts> Lemmih, yes that sounds good
01:31:35 <olliej> int-e: cheers
01:31:47 <olliej> int-e: i think i've worked out what it needs to do :)
01:35:34 <boegel> Muad_Dibber: join #haskell-blah
01:50:48 <boegel> ndm: join #haskell-blah
01:51:07 <z0d> what is that channel about?
01:51:18 <boegel> z0d: just check it out :)
01:59:41 <schyffe> how do I remove the last element from a list?
01:59:56 <boegel> schyffe: 'remove' ? you can't
02:00:08 <schyffe> say I want [1..9] from [1..10]
02:00:21 <boegel> schyffe: Haskell is tail-recursive, so that's a problem
02:00:35 <schyffe> damn
02:00:47 <boegel> schyffe: you could try this:
02:00:54 <mflux> so is 'init' what you're looking for?
02:01:12 <boegel> @eval (reverse . head . reverse) [1..10]
02:01:14 <lambdabot> <Plugins.Eval>:1:45:
02:01:14 <lambdabot>   No instance for (Enum [a])
02:01:14 <lambdabot>   arising from the arithmetic sequence `1 .. 10'
02:01:23 * boegel swears
02:01:31 <boegel> @eval reverse [1..10]
02:01:32 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
02:01:39 <Lemmih> boegel: s/head/tail/
02:01:47 <boegel> @eval (reverse . tail . reverse) [1..10]
02:01:49 <lambdabot> [1,2,3,4,5,6,7,8,9]
02:01:50 <boegel> Lemmih: thx :)
02:02:17 <Lemmih> But 'init' is faster.
02:02:25 <schyffe> what about this
02:02:55 <schyffe> if I want to take the last element, then the second last.. like [ n | n <- last [1..10]]
02:03:03 <schyffe> but that doesn't work
02:04:22 <Lemmih> You want to reverse the list?
02:04:36 <schyffe> yep
02:04:45 <schyffe> without using reverse
02:04:57 <schyffe> just hint me
02:05:00 <schyffe> it's for a school task
02:05:52 <dblhelix> schyffe: what about using an accumulator?
02:06:08 <schyffe> what's that? (++)?
02:06:47 <int-e> schyffe: you're looking for reverse
02:06:57 <int-e> @eval reverse [1..10]
02:07:01 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
02:07:23 <Lemmih> int-e: He has to do it without 'reverse'.
02:07:43 <schyffe> yep.. I can't use reverse
02:07:47 <dblhelix> schyffe: write a function reverse' :: [a] -> [a] -> [a] where one of the arguments represents the part of the list that's already processed (and reversed) and the other one represents the remaining (unreversed) elements
02:07:54 <schyffe> I got told I could use (++) but I can't figure out how
02:07:59 <int-e> Lemmih: sorry. I should read to the end before answering.
02:08:24 <dblhelix> schyffe: then reverse = reverse' [] for instance
02:08:45 <Lemmih> schyffe: rev (x:xs) = rev xs ++ [x]
02:09:45 <schyffe> hmm
02:09:48 <int-e> @eval foldl (flip (:)) [] [1..10]
02:09:58 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
02:11:18 <shapr> g'day RickyRyan
02:11:26 <RickyRyan> hey shapr :)
02:11:33 <shapr> RickyRyan: Are you learning Haskell?
02:11:37 <RickyRyan> yep
02:12:07 <shapr> Are you just getting started, or do you have some specific questions?
02:12:25 <RickyRyan> bit of both, im working on an excercise at the moment and am stuck
02:12:26 <RickyRyan> hehe
02:12:37 <shapr> What's the exercise?
02:12:43 <RickyRyan> i need to write a function to replace text, without going too much into detail
02:13:24 <shapr> A String is a list of Char values, so you can use that information.
02:13:41 <shapr> Does that help any?
02:14:54 <RickyRyan> sure does
02:15:18 <RickyRyan> i need to do pattern matching
02:15:33 <RickyRyan> recursively
02:15:52 <RickyRyan> its a bit daunting for me though hehe
02:16:05 <RickyRyan> do you know of any simple examples?
02:17:19 <Cale> Well, you can break a string apart with tails:
02:17:28 <Cale> @eval tails "Hello"
02:17:30 <lambdabot> ["Hello","ello","llo","lo","o",""]
02:17:33 <schyffe> how do I access the n'th index of a list?
02:17:39 <schyffe> err retrieve it
02:17:40 <Cale> schyffe:  xs !! n
02:18:12 <Cale> schyffe: note that this takes O(n) time though, so don't overuse it :)
02:18:28 <boegel> shapr: we need a good pic !
02:18:48 <Cale> RickyRyan: you might want to look at how tails is implemented
02:19:19 <boegel> @eval [1,3,..] [[ 128
02:19:20 <lambdabot> 23: parse error on input `..'
02:19:23 <boegel> @eval [1,3,..] !! 128
02:19:24 <lambdabot> 23: parse error on input `..'
02:19:28 <boegel> @eval [1,3..] !! 128
02:19:29 <Cale> http://www.haskell.org/onlinereport/list.html -- it's about 2/3 of the way down the page
02:19:30 <lambdabot> 257
02:19:40 * juhp has fun trying to rpm-package hs-plugins with cabal
02:19:51 <juhp> er, "fun"
02:20:02 <Cale> RickyRyan: there are some other good recursive list algorithms there and in the Prelude as well
02:20:13 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
02:30:45 <Lemmih> dcoutts: Do we need to handle editor plugins differently from non-editor plugins or can we device some universal plugin API which handles both? Can plugins depend on each other? Can two editor plugins be loaded at the same time?
02:31:56 <dcoutts> Lemmih, I don't think there is  single plugin API, there is a set of plugin interfaces. Some plugins will provide interfaces that other plugins can use. Yi would be one such example. The IDE shell would be another
02:32:11 <dcoutts> plugins must be able to depend on each other
02:32:48 <dcoutts> wether more than one plugin of the same variety can be loaded at once depends on the provider of the interface
02:33:36 <dcoutts> eg how does an editor plugin hoist itself in? probably by registering itself with the IDE shell. So if the IDE shell allows more than one they yes.
02:34:42 <dcoutts> I expect that for some kinds of plugins it'll make perfect sense to have multiple ones loaded at once, others it might be only one at once with a user preference to select which and others might be fixed (eg core plugins, or platform support plugins)
02:38:37 * Lemmih can't get a clear picture of it in his head.
02:40:34 <dcoutts> Lemmih, so the whole thing is a bunch of modules, there's no base app with a single unified plugin interface
02:40:40 <dcoutts> the whole thing is plugin modules
02:40:53 <dcoutts> plugins can be linked against each other
02:41:00 <dcoutts> so they canprovide interfaces to each other
02:42:14 <dcoutts> each plugin gets an initialisation function. That allows it to register with any interfaces it intends to implement
02:42:54 <dcoutts> eg the core IDE shell plugin will provide interfaces for adding menu items and such like
02:43:28 <dcoutts> other plugins will linkagainst the IDE shell plugin and use it's public interface to register hooks like menu items
02:43:32 <RickyRyan> Hey, if you've got an hour or two spare, and would be able to offer me some assistance in completing some excercises i have, please msg me back. Im more than happy to pay you for your help ;p
02:44:03 <dcoutts> RickyRyan, you would learn more if you did your own homework
02:44:07 <jewel> you have exercises for homework?
02:44:46 <juhp> can some remind me where is the new cvsroot for fptools?
02:45:30 <dcoutts> juhp, http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html unless that's out of date
02:46:03 <dcoutts> oh it's cvs.haskell.org rather than glass.cse.ogi.edu
02:46:36 <juhp> thanks
02:46:40 <Lemmih> dcoutts: But we would still need some way for plugins to specify version number and dependencies, right?
02:46:47 <dcoutts> juhp, yeah cvs.haskell.org now points to haskell.galois.com rather than glass.cse.ogi.edu, but just use cvs.haskell.org in case they change it again :-)
02:47:00 <juhp> yeah
02:47:14 <shapr> Lemmih: Think emacs, it uses (require 'foo)
02:47:36 <dcoutts> Lemmih, right, plugins depend on whatever other plugins they import, doesn't hs-plugins deal with that automatically?
02:47:39 <Lemmih> shapr: I know nothing about emacs/elisp.
02:48:08 <dcoutts> not sure about version numbers, I'd have to ask dons
02:48:46 <dcoutts> Lemmih, I thought hs-plugins looked at the .hi file to see what other modules it depends on
02:49:09 * shapr throws a villanelle at poetix 
02:50:21 * dcoutts should really re-read the first hs-plugins paper to make sure he's not talking nonsense
02:50:44 <Lemmih> Ah. Now I get it.
02:52:22 * dcoutts feels a bit less like he's talking nonsense now that Lemmih gets it
03:00:07 <shapr> hiya Drakioned
03:00:29 <Drakioned> morning shapr
03:03:45 <juhp> dcoutts: I just asked on libraries, but is there some way to specify libdir with cabal?
03:04:31 <juhp> dcoutts: I finally got run to trying to package a cabal lib ;)
03:07:08 <dcoutts> juhp, it's not obvious is it. the ghc package has the library-dirs: bit but the .cabal file doesn't
03:08:19 <juhp> dcoutts: ok thanks - I'll probably do some nasty hack in the spec file for now...
03:09:52 <Lemmih> dcoutts: So the only thing in the static code should be the plugin loading code? Or would you make that a plugin, too - some simple plugin loading code to load the more advance loader?
03:11:27 <dcoutts> Lemmih, you've read the latest hs-plugins paper?
03:11:34 <ski> ? <boegel> schyffe: Haskell is tail-recursive, so that's a problem
03:11:52 <dcoutts> Lemmih, yes the only thing in the static code should be the plugin loading code
03:12:06 <boegel> ski: isn't it ?
03:13:11 <Lemmih> dcoutts: I think it's a bit scary since changes in the interface of a plugin could cause segfaults.
03:13:22 <dcoutts> Lemmih, other plugins will use the plugin loading service, eg the startup routine will probably read some list of plugins that the user wants and the IDE shell will no doubt provide a graphical way of loading plugins
03:13:36 <ski> boegel : i don't know what that's supposed to mean
03:13:51 <dcoutts> Lemmih, doesn't hs-plugins allow you to check for mismatches?
03:14:01 <ski> boegel : function implementations/algorithms can be tail-recursive
03:14:08 <dcoutts> Lemmih, we need dons here to answer some questions
03:14:11 <dcoutts> @summon dons
03:14:12 <lambdabot> Unknown command, try @listcommands.
03:14:14 <Lemmih> dcoutts: Nope.
03:14:20 <boegel> ski: well, yeah, that's what I meant
03:14:36 <boegel> I mean, it's easy to get the first element of a list, but not as easy to get the last
03:14:42 <boegel> that's what schyffe was asking
03:14:46 <boegel> gotta run
03:14:47 <Lemmih> dcoutts: It can only check the type of the resource you load from the plugin.
03:14:47 <boegel> lunch !
03:15:23 <dcoutts> Lemmih, so what senario would be a concen exactly?
03:15:47 <ski> (schyffe : of course one can transform e.g. [1..10] to [1..9] by omitting last element (i think boegel might have meant you can't mutate/change the list so the last element disappears .. this is true (for the standard lists)))
03:16:28 <ski> (boegel : ya)
03:16:56 <Lemmih> A uses B.f. B changes the type of B.f. Hide will segfault if A doesn't get recompiled.
03:17:29 <int-e> @hoogle a->b->a
03:17:31 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
03:17:31 <lambdabot> Prelude.const :: a -> b -> a
03:17:31 <lambdabot> Prelude.(^^) :: (Fractional a, Integral b) => a -> b -> a
03:19:12 <int-e> @hoogle b->a->a
03:19:12 <lambdabot> Prelude.seq :: a -> b -> b
03:19:12 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
03:19:12 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
03:21:23 <Lemmih> @seen dons
03:21:24 <lambdabot> dons is in #haskell. Last spoke 5 hours, 25 minutes and 30 seconds
03:21:24 <lambdabot> ago.
03:30:31 <ProfTeggy> All but one exam through, one kicked out (1 out of 8).  not too bad.
03:32:25 <shapr> Do you usually have more or less kicked out?
03:32:41 <dblhelix> ProfTeggy: one *student* kicked out?
03:33:03 <ProfTeggy> shapr, a ratio of 20% is normal from what I've experiences in the last few years
03:33:12 <ProfTeggy> s/riences/rienced/
03:33:20 <ProfTeggy> dblhelix, yes
03:33:37 <dblhelix> ProfTeggy: why?
03:33:57 <ProfTeggy> dblhelix, he knew next to nothing about core topics of the exam.
03:34:04 <dblhelix> I cannot remember anybody kicked out here
03:34:14 <ProfTeggy> dblhelix...
03:34:17 <shapr> I think he means "failed the class".
03:34:26 <shapr> Or failed the exam.
03:34:32 <dblhelix> ah okay
03:34:40 <ProfTeggy> dblhelix, if you spring into the middle of a discussion, read the backlog :-)
03:35:22 <dblhelix> thought it started with "All but one exam through, one kicked out (1 out of 8).  not too bad.", ProfTeggy
03:35:44 <Lemmih> ProfTeggy: What are the topics?
03:35:56 <dblhelix> natural language is ambigious
03:37:15 <ProfTeggy> Foundations of databases, lemmih
03:38:10 <dblhelix> ProfTeggy: relational algebra, etc?
03:38:18 <ProfTeggy> ER modelling, SQL, functional dependencies, transactions
03:38:34 <ProfTeggy> dblhelix, yes
03:39:02 <shapr> Sounds straightforward. I'd like to take that class.
03:39:32 <shapr> I'm sure there's an optimal reduction and canonical form for queries, much like lambda calculus.
03:39:39 <ski> ProfTeggy : any deductive dbs ?
03:40:00 <ProfTeggy> shapr, there is
03:40:18 <ProfTeggy> shapr, there is even a normal form based on the complete unnesting of monad comprehensions
03:40:52 <shapr> Hm, neat. I'm sure that's useful for distributed queries.
03:40:58 <ProfTeggy> ski, not in this course
03:41:08 <ski> ok
03:41:48 <ski> (your set and bag and list monad interpretation of sql was interesting ..)
03:45:12 <ProfTeggy> shapr, the normal form is useful for several things... you cannot, however, read off efficient execution strategies (normally)
04:04:13 * shapr boings
04:09:02 <dcoutts> Lemmih, yep, lets ask dons how lambdabot deals with that issue
04:21:19 <dons> Lemmih, interfaces are only unsafe if you're not using dynload or pdynload, aren't they?
04:22:36 <dons> however, in general, if something would have to be recompiled if it was statically linked, the same applies dynamically
04:26:03 <musasabi> How do I write this in Haskell98:
04:26:25 <musasabi> foo :: forall a. Storable a => IO a
04:26:48 <musasabi> foo = myfun u >>= peek where u :: a; u = undefined
04:27:04 <dons> so in the case Lemmih describes, of plugin B changing the defn of a type used by plugin A, clearly A depends on B, and should be recompiled if B changes. versioned .hi files might be nice, though
04:27:32 <dcoutts> dons, so is there any way for the plugin loader to detect out of date plugins?
04:27:41 <dcoutts> ie ones that needs recomping?
04:28:15 <dons> you can't say is Foo.o out of date, however, given the src, we can ask ghc to recompile any it thinks, using recompileAll or makeAll
04:28:45 <dons> so the loader can't `detect' this, but we can work around it by just ensuring it never happens
04:28:50 <dcoutts> yep
04:29:08 <dcoutts> it's only a problem during development anyway rather than with deployment
04:29:19 <dons> the state Lemmih describes is equivalent to a borken makefile
04:29:23 <dcoutts> yes
04:29:49 <dcoutts> dons, want to add yourself to the list on http://www.haskell.org/hawiki/hIDE ? :-)
04:29:57 <dcoutts> Lemmih, you too :-)
04:30:01 <dons> oh, maybe I should
04:30:32 <dcoutts> mentioning that you are the great hs-plugins/dynamic app guru
04:30:41 * dcoutts bows to dons
04:30:55 <dons> :}
04:31:31 <dcoutts> and Yi author too and anything else that's relevant
04:31:54 * boegel invites dons in #haskell-blah
04:32:28 <dons> haskell-blah?
04:33:17 <dons> maybe it's a trap, boegel..
04:33:52 <boegel> dons: it's not, believe me :)
04:34:07 <dblhelix> dons: it sure is... considering on- and off-topicness, #haskell-blah is the dual of #haskell
04:46:42 <Lemmih> dcoutts: lambdabot doesn't deal with that issue, iirc.
04:48:20 <dcoutts> Lemmih, right, do you find dons's comment on the issue convincing?
04:48:34 <Lemmih> dons: A.f = print B.f. hs-plugins can't detect if B.f has changed since A was compiled.
04:48:54 <boegel> Lemmih: we're still missing a South Park char of you in #haskell-blah
04:49:03 <Lemmih> boegel: I can't do flash.
04:49:39 <boegel> Lemmih: oh :( do you have a pic of yourself, then someone else can make you :)
04:49:42 <dons> hs-plugins can't tell if it changed directly, but i wonder - wouldn't ghc spot this during the typecheck in pdynload?
04:50:13 <Lemmih> boegel: Actually I do. Just scanned an image of myself an hour ago. (:
04:50:16 <dons> doesn't matter anyway, you shouldn't have broken dependencies like this
04:50:37 <boegel> Lemmih: -> #haskell-blah (to keep off-topic chat low in here)
04:51:58 <dcoutts> dons, because a plugin collection build system should rebuild all plugins that need updating
04:52:38 <dons> right, like lambdabot's does.
04:54:03 <dcoutts> dons, right
04:54:14 <dcoutts> Lemmih, so do you still see any problem?
04:55:49 <Lemmih> Hm, using pdynload might solve it.
04:56:04 <dcoutts> dons, what do you think about licencing issues in a pluggable applcication that is likely to have many developers and aggregate/borrow code from many of the other systems it's tring to integrate with?
04:56:05 <dons> I think ths problem is mentioned in  the hs-plugins paper. at least we were aware of it. if you can break a static link somehow, you can also break a dynamic link the same way. hs-plugins only brings dynamic linking back to the level of safety static linking gives us
04:56:39 <dons> i would have though lgpl or gpl
04:56:51 <dons> the aggregate issue is interesting though
04:58:40 <juhp> % ./yi-inplace
04:58:40 <juhp> yi_: magic number mismatch: old/corrupt interface file?
04:59:03 <dons> amd64?
04:59:09 <juhp> dons: yes
04:59:15 <dons> hmm. gour reported this too
04:59:30 <dons> did hs-plugins ever work on amd64?
04:59:41 <juhp> good question
04:59:47 * juhp scratches head
05:00:05 <dons> since it depends on ghci-ish linker stuff, that's only recently been done, i'm  not sure it's been tested before
05:00:16 <juhp> hmm
05:00:20 <juhp> guess not
05:00:24 <dons> however, the magic number error is from the .hi parsing code
05:00:30 <dons> which should work even if the linker doesn't
05:01:26 <Lemmih> It still segfaults with 'pdynload' /-:
05:01:49 <dons> ok. so that means ghc can't tell the difference
05:02:00 <dons> if ghc can't, i can't
05:02:06 <juhp> heh
05:02:07 <dons> we'd need versioned .hi files
05:02:15 * Lemmih will have a closer look at 'unify'.
05:02:57 <dons> also documented in the hs-plugins paper too Lemmih, in case you need more docs on it
05:03:24 <juhp> dons: I'm using darcs head fwiw
05:03:55 <dons> thats fine. gour reported the same problem, but i haven't been able to look at it yet
05:04:56 <juhp> ok
05:08:19 <Lemmih> dons: pdynload only checks the type of the resource.
05:08:50 <Lemmih> The type of the symbol is completely irrelevant.
05:09:23 <dons> huh?
05:09:40 <dons> the type of the symbol?
05:10:11 <Lemmih> "A.f = print B.f :: IO ()"
05:10:23 <dons> pdynload checks the type of the value you retrieve against  an expected type, using ghc's type checker t runtime
05:11:06 <Lemmih> Change the type of B.f and A.f will segfault.
05:11:49 <dons> i agree, but since ghc won't notice this if you compile things with -c, then there's nothing much more we can do
05:12:13 <dons> ie. if we live with it when doing static linking, it's no different with dynamic linking
05:14:06 <Lemmih> It's still worrying since cheating System.Plugins.Make.hasChanged is very easy.
05:15:42 <dons> i'm not sure this is a problem outside of loading untrusted code
05:21:17 <Lemmih> So we'll just tell the user to stay far away from the object files?
05:24:42 <dons> what kind of users? user-users or users-who-write-code?
05:24:52 <dons> actually, both should probably just deal with src
05:24:54 <Lemmih> All users.
05:25:03 <dons> src, Config.hs style
05:25:56 <dons> hmm. Lemmih, is there a particular use you are imagining will lead to this problem, yet won't be dealt with by a proper build system?
05:27:33 <Lemmih> Not really. It just seems fragile to be so dependent on correct file timestamps.
05:29:14 <dons> we could add a layer. perhaps checksumming .hi files
05:38:08 <RickyRyan> Hey, if you've got an hour or two spare, and would be able to offer me some assistance in completing some excercises i have, please msg me back. Im more than happy to pay you for your help ;p
05:46:35 <musasabi> An extension to haskell which would make constructor independent matching possible would be fun: e.g. foo (_ v1 v2 v3)
05:46:45 <dons> RickRyan, umm, you don't happen to be studying at a university in australia, by chance?
05:48:09 <Lemmih> musasabi: What would the type be?
05:48:48 <dons> yeah, the type seems hard
05:50:32 * Lemmih did something like that to get around the evilness of Data.Dynamic.Dynamic.
05:52:36 <dons> dcoutts, i just got a msg from SimonM sending me his version of PackedString with foreign ptrs
05:52:53 <dons> foreign ptrs are apparently much faster in the HEAD
05:52:59 <dcoutts> dons, oh right, cool
05:53:07 * boegel kicks musasabi to #haskell-blah
05:53:25 * poetix notes that hs-plugins is frontpage news on LtU
05:53:31 <dons> :)
05:53:33 * poetix notes that dons is frontpage news on LtU
05:53:44 <poetix> Oops
05:53:46 <poetix> http://lambda-the-ultimate.org/node/view/964
05:57:27 <musasabi> Lemmih: Either monomorphic (would need an explicit signature) or all types and just a bunch of pattern match failures.
06:05:28 <aleator> is Marshal.Alloc.free safe when applied to arrays returned by c functions?
06:06:36 <Lemmih> If the arrays are allocated by malloc, yes.
06:08:04 <aleator> thanks..
06:11:26 <yozora> hi, i've been taking a look at the ffi, and while i understand the simple examples,
06:11:39 <yozora> i'm not sure how you pack and unpack c structs
06:12:13 <yozora> i guess one way to do it would be to write c functions to return the struct members
06:12:34 <yozora> or set them
06:12:45 <Lemmih> yozora: hsc2hs can be used for that.
06:13:16 <yozora> i hear that there are a few programs that help you out with this stuff
06:13:40 <yozora> though i'd like to get my head around the basics first
06:14:13 <yozora> is there a haskell way to play with structs, or do you have to go into c?
06:16:20 <musasabi> yozora: both hsc2hs and c2hs do it.
06:16:56 <yozora> i'll have a look
06:17:02 <boegel> musasabi -> #haskell-blah
06:17:16 <Lemmih> yozora: If 'x' is a pointer to a struct and the struct has a member called 'y' at an offset of 10 then you can add 10 to the pointer and peek 'y'.
06:17:28 <yozora> ahh
06:17:42 <yozora> the hsc2hs and c2hs way sound a lot nicer now :)
06:17:42 <xerox> c2hs will do the calculation for you, I don't know hsc2hs
06:18:24 <yozora> is there a simple tutorial on this kind of stuff out there?
06:18:43 <musasabi> {#set foo->bar #} in c2hs, (#poke struct foo, bar#) in hsc2hs
06:19:05 <yozora> i've had a look at the wiki and a quick look at the language extension reference thingy
06:19:37 <Lemmih> yozora: It's not Haskell specific.
06:20:04 <xerox> yozora: c2hs comes with a number of snippets yep
06:20:06 <yozora> i understand the offset stuff isn't haskell specific, i'm just wondering about
06:20:12 <yozora> haskell's ffi
06:20:27 <xerox> In c2hs/tests
06:20:42 <musasabi> What would be a good syntax for binary matching (like Erlang bit syntax) ?
06:21:06 <musasabi> Using TH + strings would be straightforward, but ugly.
06:21:20 <Lemmih> musasabi: Parsec+FastString's?
06:21:26 <musasabi> Using simple combinators fails when fields use each other.
06:21:55 <musasabi> Lemmih: I have my own binary parser thing, but I am thinking of packaging it and looking for a nicer interface.
06:22:13 <musasabi> currently parsing is done in monadic do blocks, but I am wondering is there a better way.
06:22:35 <boegel> xerox: ! check #haskell-blah
06:25:25 <Lemmih> dons: I got Parsec working with FastString's, btw.
06:26:50 <ski> musasabi : use each other ?
06:29:37 <shapr> dd
06:29:40 <shapr> d00d
06:29:44 <shapr> gah, my keyboard is acting up again.
06:32:31 <dons> Lemmih, any tricks required? I'll pass this on to Ketil
06:35:24 <boegel> anyone wondered how lambdabot and some of the other look like ?
06:35:49 <Lemmih> dons: Had to rewrite some of Parsec /-:
06:37:17 <musasabi> ski: like a FastString field whose length is dependent on an earlier integer field.
06:39:03 <boegel> lambdabot: this is you -> http://elis.ugent.be/~kehoste/haskell-blah/lambdabot.png
06:39:46 <lambdabot> i love you boegel!
06:39:59 <Muad_Dibber> lmao
06:40:37 <boegel> dons: asshole ;)
06:41:10 <dons> who me?
06:41:54 <musasabi> Also does it make sense to combine packing and unpacking or should those be kept separate?
06:43:22 <dcoutts> xerox, were you going to send me the latest code for the lsystem thing?
06:43:52 <xerox> I couldn't code yesterday :(
06:43:55 <xerox> Today you'll have it
06:44:45 <dcoutts> xerox, ok cool
06:51:35 * shapr boings
06:51:45 <ski> musasabi : ah.    combine ?
06:52:13 <shapr> Muad_Dibber: Haha, I just saw your shapr contest entry :-)
06:52:19 <shapr> whoops, wrong channel
06:52:31 <musasabi> packing and unpacking a protocol usually follows the same skeleton - so can they be combined in a sensible fashion.
06:54:37 <ski> aha (like combined parser/(pretty)printer)
06:57:20 <musasabi> yes.
06:58:07 <musasabi> Only I am not sure about the best way to express values depending on each other. (like the length-prefixed string)
07:00:40 <ski> thinking about combinators ?  syntax extension (like erlang) ?  (th ?)
07:06:09 <pitecus> Hi. How do I convert a string to an integer?
07:06:14 <musasabi> I currently have 1) monadic combinators. They work quite well but are verbose and need separate ones for packing/unpacking. I also have similar code with TH that just automatically derives the serializers. I don't have 3) fancy TH that is like Erlang bit syntax. Doing a syntax extension (4) would be easy but would limit users willing to add dependency.
07:06:20 <musasabi> pitecus: read
07:06:21 <ski> @type read
07:06:27 <lambdabot> forall a. (Read a) => String -> a
07:06:47 <musasabi> I am thinking about either better combinators or 3).
07:07:34 * ski think he saw some paper with a combined parser/pretty-printer combinators .. somewhere
07:07:40 <pitecus> Thanks
07:07:57 * boegel notices the interesting functional vs imperative discussion someone started on haskell-cafe
07:08:33 <musasabi> ski: if you find a pointer to that, I would be interested.
07:09:18 * shapr boings furiously
07:10:18 <ski> actually i think
07:10:18 <ski> square(inc(*x)) is undefined behaviour
07:10:24 <shapr> musasabi: You could ask on haskell-cafe what users would like.
07:11:06 <musasabi> good point.
07:14:12 <ski> (increment several times to an l-value with no sequence-points in between ..)
07:14:19 <Dread[]> Anyone awake?
07:14:24 <Lemmih> Yep.
07:14:55 <Dread[]> great, I just started programming haskell and I'm a little bit unsure about the syntax of a thing. Would this be the place to ask?
07:15:03 <ski> sure
07:16:11 <boegel> Dread[]: this is indeed _the_ place to ask such a thing, go ahead (but don't paste >3 lines of code)
07:16:41 <Dread[]> great (/N is a linebreak) module Square    where /N data Square = Sq int int /N deriving (Show, Eq) /N. But then it complains about the next line clength :: Square -> Square. Have I missed anything?
07:17:08 <ProfTeggy> int -> Int
07:17:25 <Dread[]> yea, got it. just typed wrong in here
07:17:57 <Dread[]> when I load it it gives me a ERROR "Square.hs":5 - Syntax error in input (unexpected symbol "clength")
07:18:06 <shapr> @wiki HaskellDemo is a quickstart guide.
07:18:06 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo is a quickstart guide.
07:18:16 <ProfTeggy> Indentation might play tricks on you, Dread
07:18:17 <Muad_Dibber> and the past bin?
07:18:20 <boegel> @paste
07:18:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:18:32 <boegel> Dread[]: paste it on there, makes it easier
07:18:33 * ski thinks this's a good reason not to implicitely "existentially quantify" non-parameter vars in datatype definitions
07:18:46 <ProfTeggy> ski, agreed
07:19:23 <ski> (not to mention possible extensions with tyvars bound "further out")
07:20:19 <Dread[]> Should I just edit the page?
07:20:51 <ski> yes
07:21:18 <ski> put   {{{#!syntax haskell  ...your code here...}}}  e.g. at top of page
07:21:33 <int-e> Hmm, I suspect it's an indentation error.
07:22:06 <int-e> is the clength indented deeper than the data declaration above?
07:22:19 <int-e> because it should not be.
07:22:43 <int-e> it should be on the same level actually.
07:23:38 <ProfTeggy> You need a newline after the Square -> Square
07:23:55 <ski> Dread[] : indent all declarations after the 'where' to the same level
07:24:11 <ProfTeggy> Dread, and read about Haskell's "offside rule"
07:24:27 <ski> i.e. either indent 'clength' more or indent 'data ...' less
07:24:41 <Dread[]> hmm, noone ever said anything about offside rule @school. I need google. now.
07:25:49 <shapr> @help google
07:25:50 <lambdabot>  @google <expr>, search google and show url of first hit
07:26:00 <Dread[]> hmm, didn't help with clength more indented
07:26:37 <ski> Dread[] : you indented both the type signature and the definition to the same depth as 'data ...' ?
07:27:22 <Dread[]> yep, and now it gave me unxexpected keyword "deriving"
07:27:35 <ski> deriving should be indented more
07:27:52 <Dread[]> but the rest as data?
07:27:52 <ski> (because it belongs to the 'data' declaration)
07:27:55 * ProfTeggy mumbles offside rule
07:28:21 <Dread[]> ProfTeggy: got it :)
07:28:40 <Dread[]> wonder why they don't mention it when they try to teach the language...
07:29:02 <ski> Dread[] : all things belonging to the 'data' declaration (after 'data') should be indented more
07:29:19 <Dread[]> ski: got it to work. One final question though
07:29:29 <ski> m
07:30:32 <Dread[]> if I declare Square as Sq Int Int, can I just use (Sq x1 x2) then in my functions?
07:30:44 <ski> yes
07:31:06 <ski> Sq is a function, taking two args (integers) and constructs a value of type Square
07:31:10 <Dread[]> wierd because it said it was a Square -> Square -> Int when I tried making a simple function. Must be me
07:31:55 <ski> (it's a special kind of function called "constructor" .. that means it starts with upper rather than lower case .. and that you can match against it, to the left of "=", as you do in clength)
07:32:12 <ski> Sq :: Int -> Int -> Square
07:34:05 <dpowers> bizarre question... is there a way to get Haskell to evaluate a list and forget about the bits it has evaluated?  Specifically I have a very large permutation, which is simple enough to construct, but far to large to evaluate fully.  I don't need to whole thing, I just need to look at each piece one at a time though.
07:34:28 <dpowers> but the garbage collector in hugs kind of hates it.  ;)
07:34:33 <Itkovian> dpowers: doesn't that come with lazy evaluation
07:35:34 <dpowers> Itkovian: I was hoping it would - but it doesn't seem to.  I still need to look at each member of the list, so laziness doesn't help me much
07:35:58 <dpowers> in an imperative language I would generate each list item in turn, check it, and then discard it - constant memory usage
07:36:07 <Itkovian> well, but that doesn't mean you need to keep it all in memory?
07:36:13 <ski> if can avoid keeping a reference to the start of the list, it should work
07:36:21 <ski> s/can/you can/
07:36:22 <Itkovian> the items will be generated in turn as they are required
07:36:44 <dpowers> hrm... I considered that, but I'm not sure about the best way to ditch the start of list reference
07:36:49 <ski> dpowers : possibly you have defined the list as a global ?
07:36:56 <dpowers> I have
07:37:04 <ski> then don't (if you can avoid it)
07:38:07 <Dread[]> why does clength (Sq x1 y1)(Sq x2 y2) = x1 + x2 give the result 1?
07:38:21 <dpowers> ski: even if I don't define it as a global, how do I evaluate each item in turn without holding onto the reference - wouldn't that require an imperative looping construct?
07:38:53 <ski> dpowers : no, just recurse down the list
07:39:14 <ski> dpowers : each item is evaluated as needed
07:39:18 <dpowers> ski: that is what I am doing now, and the recursion seems to hold it
07:39:38 <ski> dpowers : that's because you keep a reference to the start (the global
07:39:38 <dpowers> each :: [Team] -> IO ()
07:39:38 <dpowers> each (x:xs) = do
07:39:38 <dpowers> 	print x
07:39:38 <dpowers> 	each xs
07:39:44 <dpowers> tried something simple like that
07:39:48 <dpowers> ah
07:40:11 <soma_> does anyone have a tip on resources on how to debug haskell code?
07:40:13 <dpowers> ski: now I slink off to find a way to unglobalize my reference
07:40:21 <ski> Dread[] : clength has two Square arguments, now ?
07:40:22 <dpowers> ski: thanks much
07:40:46 <soma_> I need to inspect a value a function i wrote gets
07:41:02 <ski> dpowers : one way is to define it locally to the thing that is passing it to each (but then only that thing has access to it (directly))
07:41:32 <Dread[]> ski: yea, I give it clength (Sq 1 2)(Sq 2 3) for example and it returns 1
07:41:40 <ski> dpowers : another way would possibly be to make a function from () instead (i.e. of type '() -> [Team]')
07:41:47 <dpowers> ski: wouldn't the local def still hold the start because the recursion hasn't unwrapped?
07:42:08 <ski> Dread[] : that seems weird
07:42:09 <Dread[]> ski: nevermind man, Im a moron
07:42:25 <dpowers> or will Haskell just figure out that it doesn't need it anymore with magic pixie dust
07:43:03 <ski> dpowers : no .. local definitions are made alive by the activision of the function they're local to   (i think)
07:43:18 <ski> hehe
07:43:25 <dpowers> well - I'll try it and run it.  takes about 20 minutes to eat all my memory.  ;)
07:43:33 <ski> :)
07:44:55 <Dread[]> Im not used to having to reload the file before executing. Programing Java for example, you save your file and then recompile it
07:45:24 <Muad_Dibber> heh
07:45:26 <Muad_Dibber> so whats the difference?
07:45:33 <ski> Dread[] : ghci ?
07:45:36 <Muad_Dibber> instead of closing the applet/application
07:45:41 <Muad_Dibber> and recompiling it
07:45:44 <Muad_Dibber> you reload it :)
07:45:56 <Dread[]> my mind isn't in a funcional mode yet
07:46:12 <Dread[]> Need to recompile myself with a Kilkenny
07:53:16 <ProfTeggy> I'm off for today.  Bye bye.
08:29:55 <beelsebob_> bugger... I think I've broken delta-debugging
08:37:16 <ski> musasabi : it might have been this .. http://www-users.cs.york.ac.uk/~malcolm/projects2005.html
08:38:12 <musasabi> thanks for the link
08:39:57 <ski> (possibly there is better link .. this is what i found rn)
08:40:43 <ski> (though i wonder .. i think not i saw it this year .. and this says "projects 2005")
08:44:17 <ski> (musasabi : this could be interesting, too http://www.google.se/url?sa=t&ct=res&cd=6&url=http%3A//www.cse.ogi.edu/PacSoft/publications/phaseiiiq7papers/ppiso.pdf&ei=OO8mQ575H5KmQbO7qM8I)
08:47:30 <Lemmih> dcoutts: What do you think about having plugins as Cabal packages?
09:15:24 * rafl wants CosmicRay back..
09:21:47 * shapr boings
09:24:56 <Dread[]> can haskell understand 'and' in a function?
09:25:23 <Dread[]> like | x2-x1 == 0 && y1==y2 = True
09:25:37 <Lemmih> @eval True && False
09:25:42 <lambdabot> False
09:26:13 <Lemmih> @type (&&)
09:26:15 <lambdabot> Bool -> Bool -> Bool
09:26:16 <vegai> @eval True `and` False
09:26:17 <lambdabot> 18:
09:26:17 <lambdabot>   The infix expression `True `and` False' requires `and' to take two
09:26:17 <lambdabot> arguments,
09:26:17 <lambdabot>   but its type `[Bool] -> Bool' has only one
09:26:17 <Dread[]> So the correct syntax in my case would be?
09:26:24 <vegai> whoyy
09:26:38 <liyang> and [True, False]
09:26:56 <Korollary> Dread[]: are you asking about guards in func defitions ? You can put anything there that is of type Bool
09:27:02 <vegai> ah, and works for li.... yes.
09:27:32 <vegai> gotta hate those verbose error messages
09:27:57 <Dread[]> Im comparing 2 squares with 2 criterium. 1) Is x2-x1 == 1 AND 2) is y2 == y1? How would I write that?
09:28:46 <Lemmih> I would be worried if some expression was both 1 and 2 (:
09:29:08 <Korollary> Lemmih: quantum computers for free yay
09:29:16 <vegai> hmm, really? it's x1 x2 vs y1 y2
09:29:23 <Dread[]> yea
09:29:23 <liyang> x2 - x1 == 1 && y2 == y1
09:29:35 <Dread[]> ah, so && works in haskell?
09:29:37 <liyang> *criteria
09:29:44 <vegai> Dread[]: do you know what @eval means here? =)
09:29:48 <Lemmih> Dread[]: (&&) is just a function.
09:29:56 <liyang> && is the binary infix version of and.
09:30:04 <liyang> Or and is the generalisation of && to lists.
09:30:05 <Lemmih> @eval or (map (10==) [1,10])
09:30:07 <lambdabot> True
09:30:12 <Lemmih> @eval or (map (1==) [1,10])
09:30:14 <lambdabot> True
09:30:16 <Lemmih> @eval or (map (4==) [1,10])
09:30:17 <lambdabot> False
09:30:22 <vegai> never start a sentence with "Or and" :P
09:30:45 <liyang> or and not but then else if!
09:31:57 <SamB> liyang: is that FORTH or something?
09:32:21 <Lemmih> Dread[]: You can take the tour through the Prelude.
09:33:54 <vegai> it's not FORTH anything
09:39:13 <Lemmih> @seen dcoutts
09:39:14 <lambdabot> dcoutts is in #haskell-blah and #haskell. Last spoke 2 hours, 27
09:39:14 <lambdabot> minutes and 17 seconds ago.
09:50:13 <dcoutts> Lemmih, pong
09:51:00 <dcoutts> Lemmih, yeah if it's possible that might make things easier, especially for out-of-tree plugins
09:51:30 <dcoutts> dons, do you think such a thing is possible?
09:51:52 <dcoutts> dons, Lemmih asked "What do you think about having plugins as Cabal packages?"
09:52:03 <SyntaxNinja> 'mornin
09:52:08 <dcoutts> hia SyntaxNinja
09:52:26 <dcoutts> SyntaxNinja, oh have you seen http://elis.ugent.be/~kehoste/haskell-blahSouthPark.html yet?
09:53:28 <dcoutts> you'll have to make yourself one or live with the representation that others imagine :-)
09:54:31 <cm> heya
09:54:35 <dcoutts> SyntaxNinja, more on topic: we were just wondering if Cabal could help with building plugin-based applications
09:54:46 <Lemmih> dcoutts: I've made a minimal implementation of hIDE.
09:55:07 <dcoutts> Lemmih, oh yeah? cool, where? darcs get ... ?
09:56:07 <SyntaxNinja> dcoutts: oh... goodness
09:56:12 <SyntaxNinja> where did that come from?
09:56:13 <Igloo> There's nothing special about plugin-based stuff is there?
09:56:19 <SyntaxNinja> I have more hair than that, so far ;)
09:56:38 <SyntaxNinja> dcoutts: I"ve talked w/ dons about that a bit, is he involved in this conversation?
09:56:48 <dcoutts> SyntaxNinja, I guess it's just the name "SyntaxNinja" that inspired someone ;-)
09:56:54 <SyntaxNinja> hehe
09:57:24 <SyntaxNinja> oh, it's boegel
09:57:34 <dcoutts> Igloo, maybe not, I'm not seen it done though
09:58:15 <dcoutts> SyntaxNinja, yes dons is involved in this conversation but hasn't yet talked about this specific point
09:58:26 * Igloo hasn't build any plugin stuff, but can't see why it should be
09:58:28 <dcoutts> hmm, he's probably asleep
09:58:44 <dcoutts> Igloo, indeed I don't see why not
09:59:29 <Akshaal> hello
09:59:31 <dcoutts> Lemmih, so it'd mean that the core plugins would need to be an installed package
09:59:34 <SyntaxNinja> hi Akshaal
09:59:38 <Lemmih> dcoutts: http://scannedinavian.org/~lemmih/hIDE but it's practically empty.
10:00:03 <Lemmih> dcoutts: I imagined all plugins as installed packages.
10:00:44 <SyntaxNinja> dcoutts: dons was talking about writing a cabal-and-load module, which would be able to load any cabal-ized package as a plugin
10:01:48 <dcoutts> Lemmih, right so that their .hi files are installed and you can compile against them
10:02:17 <dcoutts> Lemmih, it'd also provide a convenient metadata format for plugins, ie it includes author info, description etc
10:02:27 * dcoutts thinks it's an excelend idea
10:02:46 <dcoutts> and of course it includes dependencies
10:03:19 <dcoutts> and deps on external packages / C libs etc
10:03:23 * Lemmih starts hacking.
10:03:42 <dcoutts> SyntaxNinja, do you think it needs anything special?
10:04:31 <SyntaxNinja> don't know, really. I know dons has put some thougth into it, so you'D probably want ot ping him. I think it's high on his todo list
10:04:43 <dcoutts> right, will do
10:05:06 <dcoutts> Lemmih, so the startup/bootstrap sequence..
10:05:43 <dcoutts> Lemmih, here's what I imagine:
10:06:06 <Reveng-ER> christel@freenode/staff/christel is a corrupt staff member. people on the staff social channel beg for modes and she is setting them just to read "christel we love you". do you all support such networks with corrupt staff members who set modes for personal pleasure?
10:06:22 <dcoutts> static core starts and loads the baseApp plugins package
10:07:04 <dcoutts> it transfers control to the dynamic_main in one of the baseApp plugins
10:08:08 <SyntaxNinja> Reveng-ER: thanks for the tip. now go away, please.
10:08:21 <dcoutts> that is then responsible for loading the other basic platform plugins, it may involve consulting user preferences
10:08:48 <dcoutts> one of the basic platform plugins should be the IDE shell, ie the main GUI bit.
10:09:15 <dcoutts> once that is started then all of the other plugins that the user has elected to use should be started
10:09:34 <dcoutts> if this takes some time then the GUI should provide feedback
10:10:02 <dcoutts> perhaps with one of those annoying startup/loading screens
10:10:19 <beelsebob_> it shouldn't take some time
10:10:21 <dcoutts> if the user has configured loads of plugins then it may be necessary
10:10:27 <dcoutts> hopefully not
10:10:54 <beelsebob_> ideally, the plugins should be loaded on a seperate thread... and the app should be usable while they load
10:11:29 <dcoutts> beelsebob_, though it would cause the GUI to change as plugins get loaded and things get added to the UI
10:11:37 <dcoutts> it'd be nicer to hide that from users
10:11:55 <beelsebob_> I'm not sure it would
10:12:01 <Lemmih> Loading an empty .o files takes 0.5 secs on my box /-:
10:12:10 <beelsebob_> I think the user should see their code
10:12:20 <beelsebob_> and then after the highlighter plugin loads
10:12:26 <beelsebob_> they should see their highlighted code
10:13:19 <Lemmih> beelsebob_: Take a seat among the developers and you can make it happen. (:
10:13:36 <dcoutts> beelsebob_: http://www.haskell.org/hawiki/hIDE
10:13:37 <beelsebob_> lemmih: sorry, too many apps to write at the mo
10:14:09 <shapr> Looks like I might be offline for a few days. Wish I had an RSS feed of recent research papers!
10:14:11 <dcoutts> beelsebob_, s'ok you can add youself to the cheerleading section along with shapr :-)
10:14:26 <beelsebob_> m'kay' cheerleading I will do
10:15:16 <shapr> Oleg kicks ass.
10:15:38 <cm> yessir
10:15:39 <cm> hi shapr
10:15:51 <SyntaxNinja> hi shapr!!!!
10:16:18 <SyntaxNinja> shapr I thought you _have_ been offline for a few days.
10:23:03 <cm> hIDE seems very exciting
10:23:35 <SyntaxNinja> whoa, "... to the extent the federal government didn't fully do its job right, I take responsibility," -- Bush
10:23:41 <dcoutts> cm, have you added yourself to the list: http://www.haskell.org/hawiki/hIDE
10:24:32 <cm> dcoutts: haven't even read through it and i'm already drooling over it :-)
10:24:46 <dcoutts> cm, excelent :-)
10:24:59 <dcoutts> cm, feel free to add your ideas
10:26:04 * dcoutts notes that cabal-1.1.3 has landed in portage ~x86 and ~amd64
10:27:54 <dcoutts> SyntaxNinja, one issue we noticed with 1.1.3 is that the "make setup" builds the setup program against the *installed* Cabal package rather than the local version. Which means it can do things wrong, like not building the GHCi .o files etc. Our solution is to just "-ignore-package Cabal" when making setup
10:28:21 <dcoutts> SyntaxNinja, our cheat is to make setup HC="$(ghc-getghc) -ignore-package Cabal"
10:28:42 <dcoutts> SyntaxNinja, but obviously it'd be better to fix it in the makefile itself
10:32:16 <cm> a debugger (breakpoints, variable inspection, ..) would be cool
10:33:07 <dcoutts> cm, integratin with debugging/tracing tools would be nice, however Haskell debuggers typeically don't do breakpoints as such
10:35:14 <cm> hmm
10:36:41 <cm> how hard would it be to (hack/)extend GHC to provide something like that?
10:37:37 <cm> i'm not sure what it should look like (i could imagine a hack like automatically adding calls to breakHere :: Monad a => a () / breakOnEval :: a -> a primitives or something like that..)
10:37:57 <dcoutts> not sure, take a look at the approaches the existing haskell debuggers/tracers take
10:38:06 <dcoutts> I think you'll find it's rather different
10:38:34 <cm> hrm
10:38:38 <dcoutts> a breakpoint is not really a well defined concept in a language with no specifed evaluation order
10:38:48 <cm> well, inside monadic code it certainly is
10:39:14 <dcoutts> inside *strict* monnadic code it is mostly
10:39:42 <dcoutts> and then only at the bind points, not elsewhere
10:39:52 <cm> yes
10:41:11 <cm> maybe it wouldn't be all that useful given an integrated toplevel & maybe some graphical "inspector" for data structures
10:41:29 <cm> (just toying with use cases in my head)
10:43:29 <dcoutts> cm, see http://haskell.org/libraries/#tracing
10:43:46 <Lemmih> dons: ping.
10:44:09 <dcoutts> Lemmih, how's hacking, and where can I start?
10:44:36 <Lemmih> dcoutts: I got hIDE to load the baseApp library.
10:44:42 <dcoutts> cool
10:44:45 <Lemmih> dcoutts: Required a small change to hs-plugins.
10:44:46 <cm> dcoutts: I guess I'm thinking of something like a GHood plugin for hIDE :)
10:44:57 <dcoutts> cm, that'd be nice
10:45:16 <dcoutts> Lemmih, ok right, what was the issue?
10:45:46 <dcoutts> Lemmih, perhaps you can send me the patch for hs-plugins
10:46:23 <cm> dcoutts: a toplevel with some niftyness would also be cool (could automatically issue a :m $currentModule command whenever the current source file changes).. brb
10:46:23 <Lemmih> dcoutts: Had to refactor System.Plugins.Load.loadFunction for use without a Module.
10:46:53 <SyntaxNinja> dcoutts: which ghc?
10:47:09 <dcoutts> SyntaxNinja, that's with ghc-6.4 and 6.4.1_pre
10:47:22 <dcoutts> SyntaxNinja, however 6.2 doesn't understand -ignore-package
10:47:26 <SyntaxNinja> I think 6.4 would have different behavior?  but yeah, ignore-package Cabal might be good, but we don't know if cabal is on yet
10:47:30 <SyntaxNinja> s/on/installed
10:48:11 <dcoutts> hmm, you think -ignore-package fails if the package doesn't exist?
10:48:55 <SyntaxNinja> maybe?
10:51:24 <Lemmih> dcoutts: Sent.
10:51:51 <dcoutts> ta
10:52:58 <SyntaxNinja> dcoutts: can you email me w/ any probs w/ this cabal?
10:53:08 <dcoutts> SyntaxNinja, yep
10:54:44 <dcoutts> Lemmih, that's against the latest darcs version of hs-plugins I assume
10:55:12 <Lemmih> Yep.
10:57:59 <Lemmih> dcoutts: The static core now loads the cabalized 'baseApp'.
11:01:09 <dcoutts> Lemmih, cool!
11:01:28 <dcoutts> Lemmih, where should I add the ide shell gtk bits?
11:01:38 <dcoutts> same package but different plugin or what?
11:01:53 <dcoutts> how granular are these packags going to be?
11:02:09 <Lemmih> New package called hide-gtk-shell, perhaps?
11:02:13 <dcoutts> ok
11:02:32 <dcoutts> are all the packages going to be prefixed with hide- ?
11:03:38 <Lemmih> You're the boss. You decide.
11:06:02 <dcoutts> seems like a good idea, if we're going to have lots of them
11:19:49 <Lemmih> dcoutts: Got time for some gobby'ing?
11:21:39 <dcoutts> Lemmih, sure
11:21:45 <dcoutts> I'll start the session?
11:22:19 <Lemmih> Yeah.
11:24:02 <dcoutts> ok started, see privmsg for details
11:25:31 <Lemmih> Joined.
11:35:42 <xerox> Lemmih, dcoutts: hi! What are you gobbyin?
11:35:55 <Lemmih> xerox: Yeah. Wanna join in?
11:35:59 <dcoutts> xerox, hIDE :-)
11:36:11 <xerox> Ooh, I'd love to, Lemmih :)
11:40:09 <araujo> Hello hello
11:46:46 <basvandijk> Hello guys, is there anybody here that has experience with Parsec (the parser combinator library)?
11:46:59 <Lemmih> A bit, yes.
11:47:15 <pesco> A bit, yes.
11:47:23 <Itkovian> basvandijk: a bit
11:47:25 <basvandijk> I want to define a parser like this: many (a <|> b <|> c)
11:47:32 <Itkovian> ok
11:47:42 <basvandijk> but where a, b and c are of different type!
11:47:42 <Itkovian> a, b, c being chars or parsers themselves?
11:48:01 <basvandijk> a,b and c are parsers of different type
11:48:03 <Itkovian> do they return something?
11:48:15 <Igloo> That doesn't make sense; what would the type of the whole thing be?
11:48:26 <Itkovian> Igloo: exactly
11:48:27 <xerox> ... -> a
11:48:29 <xerox> ^_^
11:48:31 <Igloo> You might want to define a datatype that has alternatives for each of th types
11:48:33 <dpowers> Itkovian: I fail to bind a local variable in a way that prevents hugs from eating itself for very large lists... :(
11:48:34 <basvandijk> obviously  many (a <|> b <|> c) wont work because <|> needs to parsers of the same type
11:49:01 <Itkovian> dpowers: and what makes you think I can solve that? I am flattered, but still ...
11:49:11 <basvandijk>  Igloo: yes that's what I'm doing right know, but I would like to know if there's another approach
11:49:25 <dpowers> Itkovian: nothing - bad tab completion.  ;)
11:49:30 <basvandijk> I was looking at parsec's support for permutations
11:49:58 <Lemmih> basvandijk: Do you care about the result from 'a', 'b', and 'c'?
11:50:11 <basvandijk>  Lemmih: yes I do
11:50:16 <dpowers> I mean, if you can - please.  ;)  but I actually just had I in my buffer and hit tab by habit before saying that
11:50:49 <basvandijk> but I don't think my problem is really a permutation, is it?
11:51:27 <Itkovian> hmm, not really imo
11:56:56 <TheHunter> basvandijk, if there were only two alternatives, you would do many (fmap Left a <|> fmap Right b) to tag the alternatives. In case of three alternatives you can either nest Either or you can define your own ADT (data Foo = A A | B B | C C).
11:57:43 <basvandijk> TheHunter: ok, right know I'm going for the my-own-ADT approach
12:04:56 <Igloo> Arg, making a nice Iconv binding is a pain
12:05:23 * Igloo ponders just throwing an exception if a stric conversion fails
12:41:29 <kaol> hmm... I have haskell and haskell-cafe mailing list archives dating back to 2001, but have never got around to read them.
12:45:50 * kaol considers answering to some of those (yeah, right)
13:07:42 <Blastur> if I have a list of tuples, [(a,b)], how can i search for a specific a and then return it's paired b value?
13:07:56 <xerox> @hoogle lookup
13:07:59 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:08:05 <Blastur> nice
13:08:05 <xerox> @hoogle find
13:08:08 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
13:08:08 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
13:08:08 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
13:08:20 <xerox> lookup, yeah.  :)
13:11:08 <Blastur> if I have a (Maybe [a]), is there an easy way to do like: if it's nothing, return X, otherwise just a? .. like a default value when converting from Maybe [a] to [a]
13:11:42 <psi> @hoogle fromMaybe
13:11:42 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
13:11:45 <xerox> Sure, map a function which pattern match the Maybe constructors
13:11:52 <psi> oh, a list
13:11:53 <xerox> OK :)
13:13:01 <psi> uh, yeah. fromMaybe works.
13:13:17 <xerox> Yep.
13:15:52 <Blastur> is there any way to make a "generated" variable become available in a local function? like: myfunc myList = [fromMaybe c newVal | c <- myList] where newVal = lookup c someList
13:16:12 <Blastur> the problem is, in newVal declaration, c is out of scope
13:16:51 <xerox> Hmm.
13:17:08 <xerox> You could just pass it to newVal, but mumble..
13:17:16 <TheHunter> [fromMaybe c newVal | c <- myList, let newVal = lookup c someList]
13:17:43 <Blastur> oh, let? never heard of that :)
13:18:27 <xerox> TheHunter: where is your SouthPark-like character? :D
13:18:40 <TheHunter> SouthPark what?
13:18:58 <boegel|home> TheHunter -> #haskell-blah
13:28:40 <basti_> hi
13:30:58 <beelsebob_> hellooooooooooooooooooooo
13:31:13 <basti_> yow
13:34:45 <beelsebob_> how's code?
13:34:56 <xerox> flattened. to. zero.
13:35:08 <beelsebob_> sounds like mine
13:35:16 <beelsebob_> I prove my theory wrong earlier to day
13:35:22 <beelsebob_> which meant that all my work collapsed
13:35:25 <beelsebob_> :(
13:35:52 <xerox> G'night :)
13:36:06 <dcoutts> ah they joys of phd research eh beelsebob_
13:36:11 <beelsebob_> indeed
13:36:36 <beelsebob_> on the plus side... I get to give a really embarrasing talk at IFL at which I say "my paper's a load of rubbish!"
13:36:47 <dcoutts> nice
13:37:00 <dcoutts> "and here's why..."
13:37:04 <beelsebob_> indeed
13:37:17 <beelsebob_> actually... I think it can be fixed
13:37:25 <beelsebob_> but the paper as it stands is rubbish
13:37:31 <dcoutts> :-(
13:37:43 <dcoutts> you've got time for re-writing?
13:38:14 <beelsebob_> yeh... before the final drafts... after IFL
13:59:45 <basvandijk> Hi guys, is it possible to import a module unqualified but some of the exported names as qualified? I'm writing a parser with parsec and I have a parser named eof (Engine Off) but ofcourse that clashes with parsec's eof. If I import the parsec module as qualified I need to prefix all the parsec function. I don't like that and I also don't want to change my eof. Can I import a single name as qualified?
14:00:12 <dcoutts> basvandijk, yes
14:00:26 <dcoutts> import Foo
14:00:49 <dcoutts> import qualified Foo (blah)
14:01:04 <basvandijk> lets try that
14:01:08 <dcoutts> oh you might want:
14:01:12 <dcoutts> import Foo hiding (blah)
14:01:22 <dcoutts> if the blah clashes with something else
14:01:39 <basvandijk> but I want to use the blah from Foo but also my own blah
14:02:39 <basvandijk> can't I say something like: import Foo (qualified blah as F.blah)
14:02:47 <basvandijk> or doesn't that make sense?
14:02:49 <dcoutts> no
14:02:58 <dcoutts> you have to do it in two lines
14:03:11 <dcoutts> import Foo hiding (blah)
14:03:22 <dcoutts> import qualified Foo as F (blah)
14:03:31 <basvandijk> oh yes of course! thanks!
14:03:41 <basvandijk> I'm still a newby ;-)
14:03:42 <dcoutts> then blah is your local one and F.blah is the other
14:04:08 <dcoutts> basvandijk, that's no problem, the channel is for helping newbies too!
14:19:43 <dcoutts> @seen speck
14:19:44 <lambdabot> I saw speck leaving #haskell 13 hours, 20 minutes and 23 seconds ago.
14:25:30 <boegel|home> @seen Igloo
14:25:31 <lambdabot> Igloo is in #haskell. Last spoke 2 hours, 20 minutes and 8 seconds
14:25:31 <lambdabot> ago.
14:26:08 <Igloo> Hello
14:27:44 <boegel|home> Igloo -> #haskell-blah
14:28:02 <Igloo> Why? What is it?
14:28:12 <boegel|home> Igloo: just check it out
14:28:26 <boegel|home> nobody will bite (I hope)
14:29:39 <boegel|home> Igloo: ?
14:31:55 <Igloo> It seemed pointless and I'm too busy right now
14:32:25 <boegel|home> Igloo: okay then, I hope you'll be back though
14:32:58 <Igloo> I'm more likely to join if it's on OFTC
14:33:52 <RickyRyan> Hey, if you've got an hour or two spare, and would be able to offer me some assistance in completing some excercises i have, please msg me back. Im more than happy to pay you for your help ;p
14:34:15 <Lemmih> Third time's the charme (:
14:34:36 <boegel|home> RickyRyan: if you're asking us to help with your home work: don't
14:34:38 <kosmikus> RickyRyan: this is annoying. please stop such announcements on this channel.
14:34:44 <RickyRyan> k
14:35:06 <boegel|home> RickyRyan: you're going to get kicked if you keep doing it
14:35:22 <RickyRyan> np
14:35:40 <boegel|home> Igloo: why would it be ok if it was on OFTC ?
14:36:16 <boegel|home> no HWN today ? :(
14:36:30 <Lemmih> Just ask in the main chat if you got a question/problem, RickyRyan.
14:38:01 <Igloo> I'm trying to avoid becoming more entrenched in OPN
14:39:04 <boegel|home> Igloo: okay then
14:39:06 <boegel|home> too bad
14:42:19 <Philippa> Igloo: I imagine #haskell-blah would move if OFTC did, or do you just have too many query windows?
14:46:55 <Igloo> DYM s/OFTC/Haskell/?
14:47:18 <Philippa> yes
14:47:25 <Igloo> Err, #haskell even
14:47:27 <Philippa> my thinko rate is a little high at the moment
14:47:31 <Igloo> AOL  :-)
14:48:20 <Igloo> Currently I'm only on OPN for help or helping with technical things, but I expect to stop lurking in channels even for that at some point
14:54:59 <Igloo> Oh nuts, Diablo-D3 registered #darcs on OFTC
14:56:17 * Igloo has just gone through my channel list and decided #haskell and #darcs are the only places keeping me here permanently
14:57:08 <Heffalump> Igloo: what's wrong with that? (him having registered it)
14:57:45 <Igloo> He's the person I had to ban from OPN's
14:58:34 <Heffalump> oh.
14:59:31 <Heffalump> what'd he do? (I probably knew but forgot)
15:01:26 <Igloo> When he wasn't off topic he was talking rubbish. I think everyone I asked was irritated by him except one person who couldn't remember having seen him speak
15:05:19 <Igloo> Hmm, can't find anything on OFTC's website about what they do with e-mail addresses you register with either
15:09:13 <SyntaxNinja> Igloo: ooh, diablo-d3 registered #darcs? wild
15:35:10 <Blastur> if a function is suppose to return IO [Sometype], what does the IO mean?
15:37:04 <basti_> Blastur: thats "the funny IO thing"
15:37:27 <Blastur> sounds like a lot of fun!
15:37:33 <basti_> yes it is
15:37:36 <basti_> it's a monad.
15:37:41 <basti_> a monad is a cute fuzzy thing
15:38:56 <Igloo> Hmm, Control.Monad.HtmlT, Text.Html.MonadTransformer or something else?
15:39:01 <Blastur> okay, i guess everything touched by a cute fuzzy thingie also becomes funny?
15:39:06 <basti_> yes.
15:39:27 <basti_> Blastur: see, there are things that are no functions
15:39:30 <basti_> for example, getChar
15:39:32 <Blastur> then my function result really should become IO, since it contains IO Random
15:39:59 <basti_> getChar delivers a different result every time you call it
15:40:18 <Blastur> yeah, i get it, it's an exception to the whole idea behind the language
15:40:27 <basti_> yes
15:40:32 <basti_> so we need to do something
15:40:40 <Blastur> so if you call the same func with the same parameter, it should always return the same value
15:40:43 <Blastur> but getChar does not
15:40:54 <basti_> what we do is: we make our type system coerce us to bear some hidden thing
15:41:02 <Blastur> the cute funny thing!
15:41:06 <basti_> no
15:41:09 <Blastur> :(
15:41:13 <basti_> the cute funny thing is the thing that keeps the other thing
15:41:18 <Blastur> oh, okay
15:41:19 <basti_> the other thing is a "state"
15:41:29 <Blastur> sounds not so funny
15:41:36 <basti_> well you wont ever see it
15:41:48 <basti_> you just write x<-getChar
15:42:04 <basti_> and x will automagically contain the value getChar got from the keyboard
15:42:13 <basti_> or x<-randomWhateverThing
15:42:33 <basti_> and since you do that inside a very fuzzy thing called "do notation", you don't even see what you're doing!
15:42:49 <Blastur> if I do a function, like: myFunc :: IO Char; myFunc = getChar;
15:42:50 <basti_> actually you're passing a state around "clandestino"
15:42:54 <Blastur> will that become IO?
15:43:05 <basti_> uhm
15:43:09 <basti_> actually ermmmh
15:43:26 <basti_> think of values of type "IO a" as a script that delivers a value of type a
15:43:49 <basti_> the runtime engine might run across some "IO a" value, thinks "ooo neat a script"
15:43:51 <rafl> To whom it may concern: haskell-src-exts is in Debian now. :-)
15:43:52 <basti_> does abracadabra
15:43:57 <Blastur> do all IO code be encapsulated within a "do"-clause?
15:44:07 <basti_> and delivers a value of type a
15:44:13 <basti_> not necissairly
15:44:15 <Blastur> must all IO code be encapsulated within a "do"-clause, i mean
15:44:16 <basti_> but it helps lots
15:44:29 <psi> do is really just a pretty version of something else
15:44:34 <basti_> yup
15:44:49 <Blastur> i have this: randomTransformations = [(matchP, (pick r responses)) | (matchP, responses) <- brain]
15:44:50 <basti_> one-liners are the same with or without do
15:44:55 <Blastur> 	r = randomIO :: IO Float
15:45:23 <Igloo> rafl: Have I mentioned the Debian Haskell list to you?
15:45:35 <rafl> Igloo: No, never.
15:45:53 <basti_> Blastur: that is an IO script that returns a float value, if the runtime gets to run it
15:46:19 <Igloo> http://urchin.earth.li/mailman/listinfo/debian-haskell (it's very low traffic - probably too low  :-)  )
15:46:27 <Blastur> basti_: okay, nice
15:46:46 <basti_> Blastur: to get the runtime to run it, it has to be part of other scripts
15:46:52 <rafl> Igloo: Why isn't it a l.d.o?
15:47:01 <Blastur> yeah, it's part of randomTransformations = [(matchP, (pick r responses)) | (matchP, responses) <- brain]
15:47:03 <basti_> (thats the part where you run into funny messages that mention IO or just go amok)
15:47:36 <Igloo> Less hassle
15:48:09 <rafl> Igloo: btw, do you maybe want to sponsor a haskell related package for me? hs-plugins. It's at http://www-user.tu-chemnitz.de/~rafl/Code/Debian/nomeata/
15:48:19 <rafl> Igloo: OK, I'll subscribe to it.
15:49:12 <basti_> @eval do {x<-(randomIO::IO Float);putStrLn x}
15:49:13 <lambdabot> Couldn't match `String' against `Float'
15:49:15 * Igloo doesn't have time for sponsoring right now, but CosmicRay might be interested. Or maybe SyntaxNinja, but I guess he'll not have time for a couple of weeks either
15:49:20 <basti_> @eval do {x<-(randomIO::IO Float);putStrLn $ show x}
15:49:21 <lambdabot> No IO allowed
15:49:24 <basti_> aww.
15:51:15 <Igloo> Ah rats, jadetex exploded on m68k so happy didn't build
15:51:23 <rafl> Igloo: I guess CosmicRay will have some time tomorrow or the following days: [response regarding a patch I sent] Thanks.  I've applied this to my tree (and will push it to the web when I return home tomorrow). -- John
15:52:07 <Igloo> Ah, I thought he'd been quiet the last few days  :-)
15:53:20 <Blastur> is there any way to step through a haskell program in ghc? it would be nice for instance to pause in the middle of execution of a function and do stuff like :type on "local variables".. is this possible?
15:53:29 <Blastur> like, a debugger or whatnot :)
15:53:39 <basti_> Blastur: sadly not really.
15:53:52 <basti_> that is, it IS possible, but noone would understand the single steps
15:54:07 <basti_> there are some things that help though
15:54:26 <basti_> for example, you should make your functions so short that you can debug them without tracing them. thats entirely reasonable in haskell
15:54:38 <basti_> then, theres Debug.Trace with trace
15:55:02 <basti_> you can make a value like thisanint = trace "thisanint was evaluated" 12345
15:55:50 <basti_> this might backfire a bit though, since the runtime might display the message just once and use the value several times, not exactly intuitive probably
15:56:00 <Blastur> okay, .. so you basically have to edit your code to get a debugger then?
15:56:21 <Igloo> If you're sticking to Haskell 98 then hat might help
15:56:49 <basti_> basically, you should be programming stuff that works. thats not as hard with this type system.
15:58:02 <basti_> :D
15:58:41 <Blastur> okay then =)
15:59:07 <basti_> but, Igloo pointed to "hat", which is some sort of a debugger
16:11:16 <Igloo> SyntaxNinja: Is there a polic on whether synopses should start with a capital or end with a full stop?
16:12:50 <SyntaxNinja> Igloo: no policy, but seems like a good idea :)
16:13:13 <Igloo> Having a policy, or doing both the above?
16:13:40 <SyntaxNinja> doing both of the above
16:13:58 <Igloo> OK, so now there is a policy  :-)  Thanks
16:15:20 <SyntaxNinja> ooh, a policy!
16:20:20 <Igloo> Oh, bah. Can't test on the machine I made the package on
16:20:52 <Heffalump> why, what did you make it on?
16:20:59 <Igloo> urchin
16:21:03 <Heffalump> old?
16:21:10 <Heffalump> if you're really desperate I still have it
16:21:18 <Heffalump> but it sounds like an express train, so I'd rather not.
16:21:30 <Igloo> No, I can't test it because it doesn't have cabal  :-)
16:21:35 <Igloo> (or maybe because it's too old)
16:32:25 <Igloo> SyntaxNinja: What is a "compiler" as far as test-with is concerned?
16:32:29 <basti_> good night
16:34:39 <SyntaxNinja> Igloo: I forget if that field is free text? is Compiler the type of the field?
16:35:08 <Igloo> Well it didn't like ghc6, but does like GHC. Can I be more precise than that?
16:36:55 <SyntaxNinja> did you try GHC >= 6.2 ?
16:37:31 <Igloo> Doesn't work
16:37:42 <Igloo> Hmm, extensions are for all source files or none, right?
16:38:48 <SyntaxNinja> don't knwo what you mean by that
16:39:01 <SyntaxNinja> maybve try above without spaces?
16:39:20 <Igloo> Oh, the LANGUAGE pragma uses the same names as cabal extensions?
16:39:54 <SyntaxNinja> what are cabal extensions?
16:39:56 <Igloo> OK, that works, ta
16:40:05 <Igloo> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution.Extension.html#t:Extension
16:42:42 <SyntaxNinja> oh, for some reason I thought you were talking about file extensions
16:42:51 <SyntaxNinja> yeah, extensions are all-or-nothing
16:43:03 <Igloo> Hmm, looks like ghc 6.4 doesn't know about the LANGUAGE pragma, though
16:43:03 <SyntaxNinja> don't know if the language pragmas use the same names. I wouldn't be surprisedc
16:43:57 * Igloo puts this back on the shelf
17:31:31 <Spark> @eval life
17:31:33 <lambdabot> 18: Not in scope: `life'
18:22:32 <juhp> dons: dunno if this is a hex joke, but magic seems to be 0x1face64 on x86-64 ;)
18:25:28 <dons> hmm. 1face64 eh? that could be important
18:25:53 <juhp> yeah - going to try to rebuild with that now and see what happens
18:26:11 <dons> because: binaryInterfaceMagic = 0x1face :: Word32
18:26:21 <juhp> yep
18:26:22 <dons> which seems wrong
18:26:27 <juhp> oh
18:26:29 <dons> cpp away!
18:27:02 <dons> check out Binary.hs in Language/Hi/ and see if setting your value for iface works
18:27:17 <juhp> dons: yeah, that's what I'm going to do :)
18:27:29 <dons> :)
18:27:58 <dons> seems like i must have missed the commit when this change got added to ghc
18:28:44 <juhp> I'm using a 6.4.1 snapshot from the end of July btw
18:29:16 * juhp wonders if there is a new eta for 6.4.1?
18:30:35 <dons> ghc says:
18:30:37 <dons> #if   WORD_SIZE_IN_BITS == 32
18:30:37 <dons> binaryInterfaceMagic = 0x1face :: Word32
18:30:37 <dons> #elif WORD_SIZE_IN_BITS == 64
18:30:37 <dons> binaryInterfaceMagic = 0x1face64 :: Word32
18:30:40 <dons> #endif
18:31:58 <juhp> ah ;)
18:32:05 <juhp> ergo
18:32:42 <dons> i think this broke probably more than 1 year ago, when it suddenly stopped working on ia64 too
18:32:52 <dons> just noone's tried on a 64 bit box till now
18:33:09 <dons> and ia64 was too suckful for me to chase down
18:33:09 <juhp> :)
18:34:23 <juhp> dons: yay, tests in "make check" are passing :-)
18:35:44 <dons> hooray!
18:35:48 <dons> @karma+ juhp
18:35:49 <lambdabot> juhp's karma raised to 1.
18:35:56 <dons> @karma+ juhp
18:35:56 <lambdabot> juhp's karma raised to 2.
18:35:59 <juhp> thanks :)
18:36:23 <juhp> @karma+ dons
18:36:24 <lambdabot> dons's karma raised to 14.
18:36:31 <dons> darcs send when you're done
18:36:48 <juhp> ok
18:38:48 <juhp> almost all the tests were "ok" :)
18:39:22 <dons> great
18:39:29 <dons> i'd expect a couple of failures
18:39:38 <juhp> ok
18:39:46 <dons> 2 merge-related tests should fail as they need hsx
18:39:56 <dons> they test the extended syntax merging that hsx does
18:40:59 <juhp> I think pdynload/bayley1 and plugs/runplugs failed
18:41:26 <juhp> 11 tests ignored
18:41:45 <juhp> I can send you the output if you're interested
18:41:52 <dons> ok
18:42:07 <dons> runplugs fails as 6.4.1 doesn't have the signals patch that's in the head
18:42:24 <dons> bayley1 fails to remind me to fix it
18:42:38 <dons> so if that's all, actually, it's ok
18:42:54 <dons> as the same tests fail on x86
18:43:08 * dons should get an amd64
18:43:11 <juhp> lovely :)
18:45:51 * araujo back from first day of univ.
18:48:12 <araujo> mmm..
18:48:27 <araujo> got a project already assigned too
18:48:30 <ptolomy> is it my imagination/lack of experience, or is PHP a pretty yucky programming language? Started working with it today; feels like bastard child of C and Perl with a crapload of random libraries.
18:48:46 <dons> ptolomy, your analysis is correct
18:48:52 <araujo> anyone knows a way to create data-base applications using haskell?
18:49:01 <dons> give a script kiddy 2 hours, and they come up with php
18:49:08 <juhp> ptolomy: no, php is a yucky lang...
18:49:18 <araujo> php is nota lang :-P
18:49:25 <juhp> lol
18:49:26 <dons> hehe
18:49:28 * ptolomy is spoiled from doing Ruby and Haskell for the last few months..
18:49:43 <sethk> araujo, what is it?
18:49:55 <dons> yeah, spoiled by having things that work, and that can be tested :)
18:50:06 <dons> juhp, those test results look normal
18:50:10 <araujo> sethk, mm.. i really wouldn't know the eaxact name in english .. but they are kind of tables to access databases
18:50:17 <juhp> dons: ok :)
18:50:35 <juhp> dons: unfortunately yi segfaults :)
18:51:03 <araujo> sethk, you know windows?.. that crazy stuff you do with powerbuilder and access
18:51:33 <dons> bah.
18:51:48 <araujo> and if i don't find something else (on haskell preferavly) i will be forced to the dark side.
18:51:48 <dons> oh, probably -fvia-C issue?
18:51:53 <sethk> araujo, I'll never admit that I know how to do that   :)
18:51:57 <dons> with 6.4.1? or was that fixed.
18:52:04 <dons> does ./yi-static work?
18:52:05 <araujo> sethk, me neither :-P
18:52:28 <juhp> dons: yes yi-static is ok
18:52:32 <araujo> and i am not interested to use those programms too , but i need to find other way then....
18:53:07 <sethk> araujo, to do what, exactly?
18:53:14 <araujo> anyway, i think i just need to do my searching , i just was throwing the question in the channel in case anyone knew
18:53:29 <sethk> araujo, trying to do something with databases and haskell is an interest of mine, although I haven't seen a solution I like.
18:53:44 <juhp> dons: I can send you the buildlog but I don't think it is via-C
18:54:00 <araujo> sethk, mm, sorry, really don't know the exact name in englishof what i wanna do, i wanna do tables , visual tables to access data-bases
18:54:27 <juhp> dons: I see -fasm
18:54:34 <dons> send away, i'll ponder this
18:54:39 <juhp> ok
18:54:40 <sethk> araujo, for an end user?
18:54:41 <araujo> For example, an application which prompts you for searching specific data in a database
18:54:43 <araujo> Yeah
18:55:08 <araujo> And, if it is possible that it gets connected to a database too.
18:55:54 <sethk> araujo, I have an open source database engine, so I can make changes on the engine side also if that helps to develop a good haskell interface
18:56:25 <sethk> araujo, suppose the interface could be anything at all.  (not the gui part right now.)  what should it be?
18:56:44 <sethk> araujo, the way it's done in, say, c++ is really awful
18:57:31 <sethk> araujo, the gui part is easy, actually.  it's the interface side that is not trivial
18:58:53 <ptolomy> Heh. Ocaml is getting reamed in the slashdot poll.
18:59:40 <sethk> ptolomy, why?  good reasons (valid, that is) or otherwise?
19:00:00 <sethk> ptolomy, where are you reading?
19:03:50 <araujo> sethk, i see i see.. well, i am both interested on the interface and gui side specifically
19:04:16 <sethk> araujo, the gui with access or crystal reports is easy to use, I think.
19:04:32 <sethk> araujo, and it is straightforward to organize the data
19:04:57 <sethk> araujo, what next, though?  What would be a functional approach to executing a database search and fetching results?
19:05:00 <ptolomy> sethk, Because it is a poll that allows for bitching at people. I'm looking at the slashdot poll on the main page.
19:05:20 <araujo> sethk, that's what i need to figure out yet :-/
19:05:36 <araujo> sethk, access/crystal reports?
19:05:36 <sethk> araujo, you mean the design, or how to do it?
19:05:41 <araujo> sethk, the design
19:06:16 <sethk> araujo, crystal reports has a nice gui for creating a report and populating it with data from a database
19:06:38 <sethk> araujo, access has a reasonably good one, although not quite as good as crystal reports.  Of course access can also do forms
19:07:15 <sethk> take a look at crystal reports if you haven't played with it, for user interface inspiration
19:09:47 <araujo> is that windows stuff sethk ?
19:12:59 <sethk> araujo, yes.  I'm suggesting that you milk it for ideas, not that you use it
19:14:20 <araujo> haha ok
19:14:49 <araujo> sethk, don't you know of any work going on about it in haskell so i can take a look?
19:15:12 <juhp> dons: it is not a very good one, but I have a small gdb backtrace
19:15:25 <sethk> araujo, no, but I haven't checked in quite a while.
19:15:41 <sethk> araujo, and I may have time to do something with it myself, although that's not certain yet.
19:15:48 <sethk> have to walk the dog, BRB
19:15:53 <araujo> sethk, what i need to design is precisely a database access design
19:16:19 <sethk> araujo, I can give you some ideas.  but after I get back with the dog.  :)
19:16:26 <araujo> ok, off to eat , talk to you later
19:16:33 <araujo> Cool
19:39:56 <juhp> dons: sent
21:25:13 <dons> juhp, did you send the patch?
21:25:47 <dons> that ncurses issue looks like the amd64 bug with fasm i think gour(?) spotted
21:58:34 <juhp> dons: not yet - need to work out the cpp
22:00:16 <dons> hmm. word size.
22:00:24 <dons> it's in one of the standard ghc header files
22:00:27 <dons> ghcconfig.h /
22:00:28 <dons> ?
22:04:27 <creichen> Hi! Since ghc now has rank-k polymorphism (IIRC), I'm curious-- what makes Haskell's type system weaker than System F?
22:31:11 <olliej> what is an Addr#?
22:31:51 <olliej> nuts... it's considered a generic pointer...
22:31:53 <olliej> grrrr...
22:38:45 <dons> @type "haskell"#
22:38:46 <lambdabot> GHC.Prim.Addr#
22:39:00 <dons> it's a pointer to space outside the storage-managed heap, iirc
22:39:51 <dons> yes, ghc's prelude says this is so
22:40:17 <dons> olliej, what are you messing with Addr#'s for?
22:42:31 <olliej> dons: i have to work out how to maps them to the CLR :(
22:42:39 <olliej> except they're untyped...
22:42:41 <dons> CLR?
22:42:48 <olliej> .net virtual machine
22:42:56 <dons> oh. fun fun
22:42:59 <olliej> hehe
22:43:27 <dons> yeah, they're untyped. hooray for nasty low-level haskell hacking
22:44:04 <olliej> hehe
22:44:32 <olliej> the problem is convincing them to interact with the clr
22:47:12 <Korollary> olliej: why do you "have to" ?
22:48:53 <olliej> ghc.base uses them at various point
22:49:21 <olliej> i can probably special case many of them, but it'll get irritating very quickly
22:49:38 <dons> GHC.Ptr uses them too
22:49:47 <olliej> i thought it might
22:49:53 <olliej> damnable things
22:49:57 <dons> data Ptr a = Ptr Addr# iirc
22:50:19 <dons> data Ptr a = Ptr Addr# deriving (Eq, Ord
22:50:34 <dons> it's nice to have a table of data decls in your head :)
22:51:06 <olliej> oh yes
22:51:16 <olliej> thats fun, you can compare the address of pointers
22:51:22 <olliej> you can add them together...
22:51:26 <dons> then, Ptr is all through Foreign.*
22:51:32 <olliej> the CLR doesn't let you access pointers
22:51:45 <olliej> grumble grumble
22:51:57 <Korollary> why do you need to play with the clr ?
22:52:14 <luqui> what does # mean?
22:52:19 <olliej> strict
22:52:22 <dons> hmm. perhaps you could map a Ptr with a Ptr_Class that wraps an 'a'?
22:52:31 <dons> not even sure if that makes sense in your context
22:52:32 <luqui> I thought that was !
22:52:41 <dons> # means unboxed
22:52:50 <dons> which is strict, also
22:52:54 <olliej> hehe
22:53:01 <Korollary> luqui: it's a ghc extension thing
22:53:07 <luqui> okay
22:53:12 <dons> @kind 1#
22:53:13 <lambdabot> bzzt
22:53:21 <dons> @type 1#
22:53:22 <Korollary> hmm
22:53:23 <lambdabot> GHC.Prim.Int#
22:53:32 <Korollary> why no * for 1# ?
22:53:33 * luqui looks it up in the wiki
22:53:34 <dons> @kind GHC.Prim.Int#
22:53:35 <lambdabot> #
22:53:51 <dons> @kind GHC.Bsae.Int
22:53:53 <lambdabot> bzzt
22:53:54 <dons> @kind GHC.Base.Int
22:53:55 <lambdabot> *
22:54:25 <dons> why boxed values are not represented with a box, i.e. # is a mystery ;)
22:54:36 <luqui> :-)
22:54:42 <dons> unboxed values should be the * that has come out of the #
22:54:51 <jedi`>  hey anyone in here know about relational schemas and Entity relationship models?
22:56:04 * luqui groans "schemas"
23:02:13 <luqui> jedi`, I think that's a "no" :-)
23:02:38 <jedi`> hehe okeie :P
23:03:18 <Itkovian> meuning
23:05:12 <svens> good morning
