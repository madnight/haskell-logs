00:00:04 <autrijus> yeah, it should be fun :)
00:00:58 <gour> you're becoming top of the Haskell-penetrating-arrow, take care ;)
00:02:12 <gour> i just sent your 'teaser' to one of my IT (aka C++) friend and now i'm waiting for his reply
00:02:34 * autrijus practices the a b c -> a c d -> a b d skillz
00:02:46 <autrijus> have you attached a link to language shootout too? :)
00:03:20 <gour> no, has it changed (considerably) ?
00:03:28 <autrijus> probably not
00:04:41 <gour> then it's better to not - he likes to do his own memory manag. writing own string classes etc.
00:04:59 <autrijus> ahh.
00:05:02 <gour> i'm not for all that and therefore learning haskell :-)
00:05:11 <autrijus> that sounds prudent :)
00:05:22 * Heffalump waves at autrijus
00:05:58 <autrijus> Heffalump: you're in the realspace room?
00:06:04 <Heffalump> two spaces to your left.
00:06:19 <gour> that's funny to hear
00:06:29 <autrijus> ah, you are the one who got most of the jokes
00:06:32 <autrijus> no wonder
00:06:51 <gour> it looks you are having fun there
00:07:12 <autrijus> quite so. listening to the MLDonkey story
00:07:23 <gour> :-)
00:07:48 <gour> well you deserve it, bring us lot of nice material back
00:08:10 <autrijus> hmm I should announce my commercial venture somewhere around the break
00:08:17 <autrijus> eur$10 for a t-shirt
00:08:32 <Heffalump> do you have a supply here?
00:08:35 <autrijus> yes
00:08:43 <autrijus> carried several dozens from .tw
00:08:59 <autrijus> brought 4 with me, more in the hotel (which coincides with dinne place)
00:09:04 <Heffalump> they'll revoke your visa ;-)
00:09:09 <gour> you are making a good profit then :P
00:09:09 <autrijus> roflmao
00:09:24 <autrijus> actually the cost to produce is eur$9
00:09:34 <autrijus> I just wanted to avoid the change ;)
00:09:44 <gour> and you don't make any profit..sure i heard this one ;)
00:10:06 <autrijus> that does not make it less true :)
00:10:25 <gour> lol
00:20:33 <autrijus> MLDonkey: "Freedom as a mean not as an end"
00:42:22 <gaal> rotfl on "arrow length" in the commits/committer graph
00:43:51 <musasabi> Why are (k+1) patterns evil?
00:44:22 <wli> They seem innocuous enough to me.
01:15:25 <autrijus> so where is the post-icfp meeting?
01:18:20 <Itkovian> autrijus: hungry for victory?
01:19:26 <autrijus> er mm?
01:19:44 <autrijus> I just looked at the topic
01:20:00 <autrijus> but noted no location info -- assuming it will be decided at the workshop
01:30:18 <Itkovian> I never look at the topic. bad bad bad
01:53:31 <musasabi> Tarmo Uustalu's new paper on dataflow programming with comonads was much readable than the old set of slides.
01:53:41 <musasabi> I think I even managed to understand most of it.
01:54:37 <autrijus> url?
02:10:13 <musasabi> http://cs.ioc.ee/~tarmo/papers/essence.pdf
02:26:59 <pesco> Moin Moin, #haskell!
02:28:43 <pesco> Is Arjan Oosting here, by any chance? I'm compiling his lhs2TeX .deb on linux-powerpc...
02:29:27 <dons> hello for Tallinn, #haskellers
02:29:32 <dons> from ;)
02:30:09 <pesco> dons: Hi dons, at the Haskell workshop?
02:30:40 <dons> yep.
02:30:47 <dons> though the workshop is in a few days
02:30:53 <autrijus> yo dons
02:31:28 <dons> autrijus, you here too?
02:32:42 <autrijus> yeah, in CUFP
02:32:59 <autrijus> you in TFP?
02:33:35 <dons> nope, just landed a few mins ago. i'm in the hw, but also at icfp
02:34:59 <dons> how's CUFP?
02:35:55 <autrijus> very interesting
02:38:26 <autrijus> you going to tonight's dinner in Le Paris?
02:39:00 <dons> nope, trying to sleep off my jet lag tonight i think :)
02:39:17 <autrijus> ah. have fun doing it :)
02:39:25 <dons> hmm i left home, what, 27 hours ago..
02:53:42 * earthy pouts
03:14:48 <musasabi> Is there a way of duplicating a Handle ?
03:17:41 <earthy> well...\
03:17:45 <earthy> yes and no
03:18:05 <earthy> on Posix you can use handleToFD, and then dup
03:18:11 <earthy> and then fdToHandle
03:18:17 <earthy> i.e.
03:18:58 <earthy> do { fd <- handleToFD handle; newfd <- dup fd; newhandle <- fdToHandle newfd; }
03:19:20 <earthy> but that depends on System.Posix.IO
03:22:17 <musasabi> I was trying to get rid of going via Fds
03:22:25 <musasabi> as that is the way I am doing it at the moment.
03:33:19 <earthy> musasabi: the problem is that dup is not defined for handles
03:33:32 <earthy> nor can it be, IIRC, as windows does not have a dup-like system function of itself
03:34:18 <earthy> ah, I was wrong. it *does* have DuplicateHandle
03:34:36 <earthy> but with an entirely different paramaterset and semantics from dup
03:37:46 <dcoutts> dons, glad to hear that Yi will do unicode
03:38:30 <dons> yeah, i'll try to get the patch in today
03:39:11 <gour> is there any chance tht Haskell get full-unicode support?
03:39:30 <gour> i remember several discussions on mailing lists
03:39:54 <gour> and, iirc, some libs must be rewritten..
03:40:34 <gour> maybe it is an Haskell-2.x issue
03:41:15 * gour wonders if/when Haskell-2.x will happen
03:45:50 <dcoutts> gour, Haskell can do nicode, but you;ve got to code your IO stuff using non-standard functions
03:49:05 <gour> dcoutts: oh, really? what was the main focus on those ml discussions then?
04:03:34 <shapr> dons: welcome to ScannedInAvia!
04:04:25 <dons> yay :)
04:05:05 <Lor> Hm, a meeting _after_ HW? Good to know, so I won't reserve a very early ferry back home...
04:08:34 <Igloo> How late do they run?
04:10:02 <Lor> Hm, the last one seems to depart at eight.
04:10:23 <Igloo> From where?
04:10:32 <dons> the port, I guess
04:10:39 <Igloo> I think HW ends at 6, so if you're going that night you don't have a lot of time  :-(
04:11:35 <Lor> Yeah, too bad. I only reserved four nights at the hotel, since I figured I could leave straight after hw.
04:12:03 <shapr> autrijus: I like your CUFP slides.
04:13:34 <gour> autrijus: not really covers is great
04:15:11 <shapr> I still have the "unknown exception" from GHC when building Yi, has anyone found a way around it?
04:15:34 <gour> shapr: build with the latest Yi
04:15:51 <shapr> I have the latest yi, I just pulled from the darcs repo.
04:16:00 <gour> shapr: i.e. pull latest patches from yi
04:16:31 <shapr> I have.
04:16:46 <gour> old yi-0.2 created a problem for me
04:17:14 <gour> re-build hs-plugins to check local pkgs 1st - new patch
04:17:35 <shapr> ok
04:18:12 <gour> let me know, i'm going to take a lunch, but will be back
04:18:17 <shapr> ok
04:18:53 <gour> shapr: do you have latest gtk2hs too?
04:18:55 <dcoutts> gour, the focus of the ml discussions were about making it easier and making it the default
04:19:11 <gour> dcoutts: will it happen?
04:20:07 <dcoutts> and dealing with different encodings and the problem of the encodings of file names
04:20:15 <dcoutts> happen? dunno, maybe :-)
04:20:24 <gour> dcoutts: how is the program at icfp workshop in england?
04:21:24 <dcoutts> ? in england, icfp is in Estonia
04:21:40 <gour> dcoutts: i mean, hIDE workshop :-)
04:22:10 <dcoutts> gour, oh, ha
04:22:32 <shapr> gour: I think so,lemme check.
04:23:00 <shapr> I want some sort of script that updates all my darcs repos, rebuilds the new stuff, and reinstall all the packages in the right order.
04:23:12 <dcoutts> gour, I've got some ideas but no time to code them this weekend
04:24:56 * shapr snickers: "grave bugs of xscreensaver (4.21-5 -> 4.21-7) <done> \n #94300 - <TITLE>404 Not Found</TITLE> \n Merged with: </BODY></HTML>"
04:25:24 <gour> dcouuts, i've also got one idea - to take a lunch. i hope you are not starving either :-)
04:28:54 <MarcWeber> Anyone in here who wants to learn haskell, too? Perhaps we can learn together?
04:30:00 <basti_> MarcWeber: don't be shy to ask specific questions, you can talk with me in german privately too.
04:32:24 <MarcWeber> basti_: Do you have some well written sample programs to learn from?
04:33:15 <basti_> hmm.
04:33:37 <basti_> the problem with that question is, that "well written" is certainly not suitable for beginners most of the time ;)
04:33:52 <basti_> did you read some basic introductions?
04:34:01 <basti_> (YAHT, gentle intro)?
04:34:35 <basti_> < phone
04:35:04 <MarcWeber> basti_: Yes, I already did. I've read half of a book and half of a tutorial so know I want to start somewhere.. ;)
04:37:38 <wilx> Hm, I have just compiled Yi and started it --as=emacs.
04:37:54 <wilx> Backspace doesn't work, Ctrl-H does.
04:37:58 <wilx> Enter doesn't work either.
04:38:09 <basti_> wilx: uhm
04:38:30 <basti_> MarcWeber: i was recently working at yi.
04:38:59 <basti_> wilx: do you have my emacs keymap?
04:39:01 <dons> wilx, are you talking about the new yi+gtk you get from scannedinavian.com?
04:39:16 <dons> this is quite different (atm) to the ncurses yi
04:39:35 <wilx> No, ncurses one.
04:39:37 <MarcWeber> basti_: I've noticed that it's in portage now
04:39:53 <wilx> basti_, huh, I don't know, Yi doesn't come with one?
04:39:57 <basti_> MarcWeber: it can certainly show off what haskell can be like
04:40:31 <basti_> wilx: no i do not know which version youre using. theres a gtk version, and an ncurses version, and I am responsible for the current emacs keymap in the ncurses version.
04:41:00 <wilx> Ncurses version.
04:41:14 <basti_> wilx: is my name (B.Zapf) in the top of Yi/Keymap/Emacs.hs?
04:41:42 <wilx> -- Copyright 2005 by B.Zapf
04:41:46 <basti_> yup
04:42:10 <dons> wilx, try --as=mg or --as=emacs2 for a start.
04:43:06 <wilx> dons, with emacs2 I get enter working. Backspace still prints ^?
04:43:52 * basti_ gets an error message with --as=emacs2
04:43:56 * basti_ .oÂ° ( ? )
04:44:21 <dons> try --as=mg
04:45:21 <wilx> With --as=mg both backspace and enter work fine.
04:46:03 <wilx> This is FreeBSD box, if it is important.
04:46:40 <autrijus> I just presented my talk a second time :)
04:47:00 * basti_ darcspulls newest modifications
04:47:00 <autrijus> (to spj)
04:47:09 <dons> it's just that the emacs and emacs2 modes aren't as flexible about what they think are backspace keys
04:47:17 <dons> easy to fix, as the code is in the mg module
04:47:32 <dons> autrijus, cool :)
04:47:50 <basti_> autrijus: :-o
04:48:17 <autrijus> notes to self: rehearsal definitely helps, it's a good idea, maybe give it a try next time
04:49:41 <pesco> basti_: Cool, new verb "to darcspull". :)
04:49:52 <MarcWeber> basti_: When looking at yi, where to start reading the source?
04:49:59 <basti_> pesco: :P
04:50:12 <xerox> autrijus: any url?
04:50:29 <basti_> MarcWeber: i was mainly concerned about the keymaps, and they make quite an impression
04:50:53 <basti_> (being built from combined lexers)
04:51:00 <autrijus> xerox: http://no.perlcabal.org/~autrijus/cufp2005.pdf
04:51:13 <xerox> autrijus: thanks.
04:51:21 <autrijus> np :)
04:55:56 <xerox> -Ofun
04:55:58 * xerox rolls on the floor laughing
04:56:04 <autrijus> :D
04:56:18 <shapr> Is that like "Oh fun!"
04:56:20 <shapr> ?
04:56:26 <autrijus> it's like "Pugs is optimized for fun"
04:56:33 <xerox> ...and an optimization flag!
04:57:04 <xerox> You should take a video of the presentation :D
04:57:22 <autrijus> or make one, sure :)
04:57:36 * xerox hugs autrijus 
04:57:55 <autrijus> I'm sold to the Takahashi method
04:58:07 <xerox> What is it?
04:58:12 <autrijus> (the style of presentation that uses huge fully scaled words)
04:58:19 <autrijus> eg. http://www.rubycolor.org/takahashi/thinkinrails/img0.html
04:58:32 <xerox> Then you play it _vary_ fast to achieve subliminal effects.
04:58:33 <autrijus> this was my first takahashi experience
04:58:35 <xerox> *very
04:58:37 <autrijus> yes
04:58:49 <autrijus> it takes 3x time to prepare but is worth it
05:00:22 <xerox> Those glyphs appears very well in takahashi method :D
05:00:23 <xerox> Lunch.
05:19:56 <autrijus> ...you know a joke is good when you laugh so hard the chair got bend backwards and breaks in two ;)
05:20:07 <autrijus> actually three pieces
05:20:44 <autrijus> fortunately the laptop seems to be unharmed
05:20:57 <gour> yeah, we know you're overweight
05:21:08 <autrijus> except I'm not :-/
05:21:15 <autrijus> maybe my laptop is
05:21:30 <gour> ahh, that could be, maybe it's desktop-replacement
05:22:58 <autrijus> ;)
05:23:04 * autrijus focuses back to the Erlang talk
05:30:36 <xerox> autrijus: giving or getting? :D
05:30:54 <autrijus> getting :)
05:40:47 <MarcWeber> will be back in some minutes
05:46:22 <Sickjacken> any software recommendations for software that has to draw a graphical view of my lattice ?
05:46:31 <Sickjacken> i dont feel like drawing lines myself
05:47:07 <camio> SickJacken, Something like GNUPlot?
05:48:38 <pesco> Sickjacken: Do you know Postscript? It's ridiculously easy to produce by hand.
05:49:45 <pesco> Sickjacken: I could also offer you an undocumented but well-working Haskell library for defining vector graphics that can export SVG and PostScript...
05:49:50 <Sickjacken> i dont know how to program postscript, would that involve giving coordinates of the lines by hand etc?
05:50:39 <pesco> Sickjacken: Well, of course it involves giving coordinates, but I thought more like generating them from whatever you have with a small Haskell program...
05:51:12 <Itkovian> pesco: url?
05:51:16 <musasabi> perl + gnuplot is quite easy
05:51:25 <Sickjacken> hmm, i think i will simply take out the dia program instead...it will take the least time i think
05:51:25 <goron> You can also write it in PostScript :) You could even write a compiler in postscript :)
05:51:29 <pesco> Itkovian: Wait a minute until I put it up...
05:51:35 <Itkovian> ok, np
05:51:59 <pesco> goron: Yes, but it's much more convenient to do the calculations in Haskell. ;-)
05:56:03 <pesco> Itkovian: http://scannedinavian.org/~pesco/code/Vectorgraphics/
05:57:43 <Sickjacken> link not working for me
05:57:45 <xerox> autrijus: What is whipuptitude? :-)  Hmm, the ability of fast prototyping/refactoring?
05:57:52 <autrijus> yes.
05:58:01 * xerox dances around
05:58:13 <xerox> I tried explaining it to some people, I'll use your terms in the future :-)
05:58:28 <autrijus> :)
05:59:15 <xerox> What did you use to make the slide?
05:59:58 <autrijus> vim
06:00:03 <autrijus> and then ported to powerpoint
06:00:08 <autrijus> then converted to pdf using openoffice
06:00:33 <xerox> I wouldn't expect it conserved scalable font after so much steps :D
06:00:47 <autrijus> OOo is very good :)
06:00:50 * autrijus praises OOo
06:01:07 <goron> autrijus: Experience with impress?
06:01:16 <autrijus> goron: the 2.0-beta one is good enough
06:01:32 <goron> autrijus: I am downloading the package now. It's LARGE.
06:01:55 <autrijus> *nod* not larger than MSO though
06:02:12 <goron> LARGE is relative as always...I am on a 512/256 line.
06:03:02 <goron> Yeah, it seems to work!
06:03:25 <autrijus> :)
06:03:40 <pesco> Itkovian: If you look at the library, tell me what you think! :)
06:05:18 <basti_> shapr: are you there?
06:06:03 <goron> autrijus: Do you know whether I can also get a overview of the slides of the left of the screen, such that the text is selectable (just like in PowerPoint)?
06:08:00 <autrijus> no, I don't :-/
06:10:53 <goron> autrijus: But yes, OpenOffice 2 seems nice, but it's still no match for powerpoint.
06:10:54 <Itkovian> pesco: I will when I have time. And I've got numerous deadlines coming up (and swooshing past), so don't expect word too soon
06:12:21 <autrijus> goron: yup, but it makes a very good pdf exporter.
06:12:31 <autrijus> goron: also it's considerably easier to run on linuxfreebsd ;)
06:13:15 <gour> lyx/latex rules :-)
06:13:33 <basti_> texmacs rules!
06:13:56 <ulfdoz> I still do latex with vim or emacs.
06:14:17 * gour hugs ulfdoz
06:15:12 <ulfdoz> Just for the sake of masochism. :)
06:15:56 <Sickjacken> pesco, the link times out with me
06:25:03 <gour> ulfdoz: that's why i do something with lyx, although non-existance of unicode support is pain :-(
06:26:43 <gour> ulfdoz: s/existance/existence
06:31:19 <Oejet> Hej.
06:31:23 <Heffalump> hi
06:32:03 <basti_> y0w.
06:35:30 * Oejet is hacking Java graphics. :-/
06:35:49 <basti_> poor Oejet :(
06:36:13 <Oejet> Yes, poor, poor Oejet.
06:39:59 <marcot> dons: Hello.
06:40:18 <basti_> musasabi: how am i supposed to change the way a record is rendered by WebForms.HaskellDB.renderDetails?
06:46:42 <musasabi> basti_: using a newtype would be one good way.
06:47:08 <basti_> musasabi: like newtype and instance DefaultRender?
06:47:47 <musasabi> yes.
06:48:18 * basti_ nods
06:48:57 <musasabi> although you could try with overlapping instances defining instance DefaultRender tail => DefaultRender (RecCons YourLabel YourType tail) where ...
06:49:11 <musasabi> if that works then even better.
06:49:48 <basti_> hmmm
06:50:38 <musasabi> The instances already defined are of the form: instance (FieldTag f, DefaultRender b) => DefaultRender (RecCons f String b) where (and the same for few other types HaskellDB supports.
06:51:23 <musasabi> Now making the f explicit might work.
06:51:27 <basti_> so I could render diffently depending on FieldTag?
06:52:06 <musasabi> I think so, but if it doesn't work then using a newtype will work in any case.
06:52:31 <basti_> I'll try that fieldtag thing first... sounds exciting
06:52:34 <musasabi> Try it out (and if it works please tell me and I'll add a note about the technique and mention you ;)
06:52:47 <basti_> mmk
06:53:48 <autrijus> wow, the MDA whitepaper is even worse than the speaker hinted it to be
06:53:51 <autrijus> # http://www.omg.org/news/whitepapers/OMG_Article_December-2004-MDA-and-Sarbanes-Oxley.pdf
07:01:10 * ptolomy is awakened by reading 'Sabarnes Oxley'.
07:28:30 <shapr> basti_: eh?
07:28:48 <basti_> shapr: ah that was back then... i got it already.
07:28:50 <basti_> :D
07:42:22 <shapr> Which version of libcairo should I use for yi?
07:43:36 <basti_>     `renderOverview' is not a (visible) method of class `DefaultRender'
07:43:50 <basti_> what other methods are there to a class? how do they become invisible?
07:44:14 <jyp> jp@peppin:~/haskell/yi$ runhaskell Setup.lhs configure
07:44:14 <jyp> *** Exception: Line 11: Unknown field 'hs-source-dirs'
07:44:26 <basti_> jyp: install new cabal version
07:44:32 <jyp> I take it this means install cabal ;)
07:44:43 <jyp> ok  :-)
07:45:03 <int-e> jyp: 'the ghc builtin cabal is too old for our project'
07:47:36 <jyp> btw, is dons' yi repo outdated, or scannedinavian just a temporary branch ?
07:48:29 <shapr> Afaik, dons' yi will stay ncurses, and the scannedinavian repo is for hIDE, which is yi+gtk.
07:48:30 <basti_> any ideas on that: I get an error because some method of a class that i imported would not be visible in an instance declaration. What sense does a class make that you can't instantiate? How can i help this?
07:49:13 <shapr> basti_: I'd guess DefaultRender(..) imports all the methods too.
07:49:19 <basti_> hmm
07:49:21 * basti_ tries
07:49:22 <shapr> And maybe without the dots it's only the type?
07:49:25 <shapr> I'm not sure though.
07:50:49 <basti_> hmm
07:50:59 <basti_> i tried something similar but that sort of thing doesn't seem to help
07:51:27 <basti_> .. gives no error & no change, mentioning the name explicitely gives "doesn't export ..."
07:51:33 <basti_> maybe it should, then.
07:51:51 <basti_> though, what sense does a class make when you don't export the methods?
07:52:43 * basti_ tries changing the haskelldb sourcecode
07:53:58 <basti_> this is better. so, methods need to be exported explicitely
07:54:05 * basti_ .oÂ° ( wtf? )
07:58:57 * shapr disables cairo in gtk2hs and tries again.
07:59:19 <shapr> Has anyone hand typed the Comonads code out of Uustalu/Vene's latest paper?
07:59:32 <shapr> I want the source to try some simulators.
08:01:08 <musasabi> basti_: see Webform.HaskellDB.Generic.
08:01:32 <musasabi> I can see the problem.
08:02:52 <goron> Is there a Haskell PQ tree implementation?
08:03:17 <musasabi> basti_: darcs pull - it should be fixed.
08:03:55 <basti_> musasabi: missing (..) in the header of Generic?
08:04:14 <musasabi> yes that was the problem, it is fixed now.
08:04:31 * basti_ nods
08:04:37 <basti_> great
08:26:06 <basti_> musasabi: that works flawless. needs -fglasgow-exts though (argh! ;) I'm building an example now.
08:28:32 <rep>     Failed to load interface for `Parsec':
08:28:32 <rep>         Could not find module `Parsec': use -v to see a list of the files searched for
08:28:35 <rep> wth?
08:28:42 <rep> isn't parsec supposed to come with ghc?
08:28:57 <integral> Text.ParserCombinators.Parsec?
08:29:06 <manulito_> is there any smart way to get the highest value found in an [int] ?
08:29:08 <likens> -package parsec
08:29:15 <shapr> manulito_: max
08:29:28 <likens> or ghc -make
08:29:29 <basti_> shapr: is this smart?
08:29:37 <Lor> musa, I think the last ferry over the bay on friday departs at nine.
08:29:42 <manulito_> max [1,2,5,2], does that give me 5?
08:29:44 <rep> ah i imported Parsec instead of Text.etc
08:29:48 <shapr> manulito_: try it
08:30:41 <manulito_> im not able to, do i need to do somethin else, import something? im kinda new to haskell
08:31:01 <basti_> @hoogle max
08:31:04 <lambdabot> Prelude.max :: Ord a => a -> a -> a
08:31:04 <lambdabot> Prelude.maxBound :: Bounded a => a
08:31:04 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
08:31:11 <basti_> no you shouldn't have to.
08:31:28 <basti_> whats the error message?
08:31:45 <manulito_> perhaps i should foldr1 max into the list!
08:31:59 <basti_> no you shouldnt have to.
08:32:33 <basti_> folding something over a list to get max would be a nice possibility to practice folds though.
08:32:46 <basti_> @plugs max [1,5,4,2]
08:33:04 <lambdabot> <Plugins.Eval>:1:12:
08:33:04 <lambdabot>   No instance for (Show ([a] -> [a]))
08:33:04 <lambdabot>   arising from use of `show'
08:33:12 <manulito_> it gives some error about, No instance for (Show ([t] -> [t])), im using ghci
08:33:16 <basti_> :-o
08:33:27 <basti_> uhm yes.
08:33:28 <basti_> lol
08:33:49 <basti_> wait
08:34:02 <basti_> @plugs maximum [1,4,3,2]
08:34:06 <lambdabot> 4
08:34:06 <basti_> @type max
08:34:08 <lambdabot> forall a. (Ord a) => a -> a -> a
08:34:13 <manulito_> ahh! thanks
08:34:16 <basti_> :D
08:34:24 <manulito_> max is for foldr1 then :> tho ill use maximum :p
08:34:30 <basti_> yup
08:43:04 <likens> Not a helpful error message, you need to use foldr1 or figure out a base case.
08:49:58 <ptolomy> @plugs sum [1..4]
08:50:05 * ptolomy had to try.
08:50:31 <lambdabot> 10
08:54:57 <araujo> Hello all
08:55:25 <araujo> What is a function lookup if an element exist or not in a list?
08:55:30 <psi> elem
08:55:37 <araujo> thanks psi
09:15:13 <shapr> Neat - CNC programming with Haskell - http://www.dsic.upv.es/~jsilva/cnc/
09:16:25 <RemiTurk> hi all
09:16:35 <shapr> hiya RemiTurk
09:17:11 <shapr> dcoutts: I can't get Yi to build when libcairo2-dev is enabled on debian/unstable, maybe there's a version mismatch?
09:24:38 <Lemmih> 'morning, #haskell.
09:25:30 <gour> Lemmih: 'evening, Lemmih :-)
09:30:32 <shapr> Yay, yi+gtk builds with cairo disabled!
09:32:41 <shapr> ah crap, seg fault
09:33:26 <shapr> And another different segfault...
09:33:35 <shapr> But it RUNS!
09:33:39 * shapr cheers frenetically
09:34:12 <shapr> So, are there any QuickCheck or HUnit tests for hIDE/yi+gtk ?
09:35:16 <dons> there are for yi's buffer code, i should integrate them.
09:36:06 <shapr> I seem to type faster than the gtk text buffer iterators can react. That's what I get errors for, at lest.
09:36:23 <dons> oh, that's interesting. hmm.
09:36:45 <dons> someone else, i think dcoutts, mentioned this too
09:37:12 <dons> ah, but it's early days yet. plenty of improvements to come
09:37:19 <shapr> When I hit C-x C-f I get Prelude.undefined
09:37:25 <shapr> Where can I jump in?
09:39:07 <dons> hmm. I get the feeling that we need to trust gtk less
09:39:16 <gour> shapr: i had the same problem as you - ghc panic, but then i was able to install & run everything...
09:39:45 <gour> shapr: which version of cairo you have?
09:40:10 <gour> shapr: mine is 1.0.0
09:40:47 <shapr> 1.0.0-3
09:41:05 <gour> shapr: latest patches from hs-plugins, yi, gtk2hs & hIDE
09:41:38 <shapr> I just disabled cairo for gtk2hs, and now it works.
09:41:39 <gour> shapr: my problem was old version of yi-0.2 so is (temporarily) unregistered it
09:41:51 <manulito_> is there a smart function to get the last value in a list, that works like head, atm im doing "drop (lenght list)-1)
09:42:02 <shapr> dons: Is there a TODO for yi+gtk?
09:42:22 <dons> manulito_: last?
09:42:37 <gour> shapr: ok then
09:43:04 <dons> shapr, hmm. i'll write one. mostly what is happening is that i'm merging back in code from curses-yi. once that's done, things will be clearer how to proceed
09:43:27 <manulito_> thanks dons!
09:43:27 <dons> @eval last "haskell"
09:43:36 <dons> wake up sleep lambdabot
09:43:50 <lambdabot> 'l'
09:43:54 <shapr> Now you see why ScannedInAvian.org is so much faster :-)
09:44:00 <dons> oh, hmm. doing nightly builds during daily euro-time is bad for euro-performance
09:44:37 <dons> hehe. but it's not just network lag, head and stable ghc are getting build atm
09:45:00 <dons> so the box struggles to swap back in lambdabot
09:45:52 <shapr> Ah, that explains it.
09:46:03 <shapr> Eurotime evenings are busy on #haskell.
09:46:30 <Igloo> Why not build in series?
09:46:30 <dons> yeah, i think i'll switch the builds over to aussie midday
09:46:43 <shapr> I have a sudden urge to name the yi+gtk/hIDE critter for one of the other Confucian virtues.
09:46:46 <dons> I like to get them both mailed out at the same time :)
09:46:55 <dons> oh no shapr!
09:46:56 <Igloo> Delay the first mail  :-)
09:46:58 * shapr looks for the actual names to put on the suggestion list.
09:47:28 <shapr> It would have to be one of benevolence, justice, courtesy, wisdom, and sincerity. Which one fits an IDE best?
09:47:30 <dons> actual names for super-hIDE?
09:47:50 <dons> courtesyIDE hehe
09:48:04 <shapr> Or maybe The top level is Confusious and the components are named for the virtues?
09:48:51 <shapr> "Our type checker is named justice, help system is courtesy, intellisense is wisdom..."
09:48:58 * shapr snickers
09:49:20 <Igloo> What was the first Confucian virtue?
09:49:45 * dons installs euro-friendly ghc cron jobs
09:49:53 <shapr> Yi == righteousness
09:50:14 <Igloo> Oh, OK
09:50:18 <dons> yeah, this is a good theme shapr. you should put this on the wiki
09:50:26 <metaperl> cnc is indeed neat - they take an XML specification and turn it into a haskell program
09:51:26 <shapr> metaperl: I thought it was the other way around?
09:51:50 <metaperl> We are able to automatically convert programs specified with the XML DTD to programs specified with the Haskell data structure and viceversa.
09:52:05 <metaperl> I guess it is both :)
09:52:24 <metaperl> i need to quit reading Underground Empire on the bus and start reading SJT again :)
09:54:49 <shapr> metaperl: Have you seen the screenshots of the new yi+gtk?
09:55:45 <dons> do we have screenshots of yi+hIDE up somewhere?
09:55:52 <shapr> Still some minor problems though: "*** glibc detected *** malloc(): memory corruption: 0x086005b8 *** \n zsh: abort      ./yi"
09:55:59 <dons> erk
09:56:02 <shapr> dons: No, but I'll put some on the Yi wiki.
09:56:29 <dons> i don't get any nasty stuff like that. i wonder if my gtk version is different
09:56:53 <dons> oh my: paprika$ ldd `which yi` | length
09:56:53 <dons> 35
09:57:02 * shapr grins
09:57:04 <dons> that was more than I thought
09:57:16 <Igloo> gtk stuff?
09:57:26 <shapr> I only get crashes when I type fast.
09:57:29 <Igloo> lol
09:57:40 <dons> yuck
09:57:47 <dons> Igloo, yep
09:57:59 <dons> shapr, i'm using gtk 2.4.14
09:58:16 <shapr> I was using gtk 2.6 and I just upgraded to gtk 2.8
09:58:34 <dons> hmm. interesting
09:59:25 <shapr> Poo, the cursor doesn't scroll the window automatically yet.
09:59:45 <dons> nope, cause we're grabbing the cursor. need to ask dcoutts about how best to deal with this
09:59:46 <rep> Ambiguous occurrence `map'
09:59:46 <rep>     It could refer to either `GHC.Base.map', imported from Prelude at Implicit import declaration
09:59:49 <rep>                           or `Data.Map.map'
09:59:53 <rep> what do you do in these situations?
10:00:02 <dons> import qualified
10:00:20 <dons> s/grabbing the cursor/grabbing the arrow keys/
10:00:34 <dons> but they're not yet calling back into the UI to scroll
10:00:38 <rep> thanks
10:01:06 <marcot> Prelude> (-0.008) ** (1/3)
10:01:06 <marcot> NaN
10:01:12 <marcot> Why doesn't haskell answer to that?
10:01:45 <dons> the mysteries of floating point units
10:06:15 <der_eq> marcot: perhaps because the floating point implementation of haskell uses math.h and the only root that's defined there is square-root
10:07:11 <Korollary> The power function behaves the same in python. It doesn't allow the exponent to be <1 if the number is negative.
10:11:07 <shapr> Ok, I put up a screenshot - http://www.scannedinavian.org/YiWiki/FrontPage
10:12:27 <Korollary> I am missing a character set I suppose
10:12:55 <Korollary> can't display &#32681
10:20:24 <dcoutts> dons, you can scroll the view to the cursor, and I'm sure you can check if the cursor is moving outside the view's visible area
10:21:41 <astrolabe> marcot:  I guess powers of non-negative numbers only are defined.   To allow your example, 1/3 would need to be recognised as a rational with an odd denominator: (-0.008)^(1/2) or worse (-0.008)^pi are more awkward to define.
10:22:04 <int-e> marcot: for negative bases, the libc pow() function only allows integer exponents. In fact the value 1/3 is not even representable as a floating point number, so execting it to work is too much.
10:23:10 <dons> dcoutts, ok, sounds easy enough
10:23:53 * int-e was surprised to find that pow() is in fact required to handle integer exponents by the IEC 60559 Floating-Point Option (that's an extension for ISO C).
10:24:54 <dcoutts> dons, you may want to look at the source code of the gtktextview if it's not immediately obvious
10:25:19 <dons> ok
10:25:38 <dcoutts> dons, interestingly it's probably done in the keystroke handler in the gtktextview, rather than reactive to changes in the cursor marker
10:25:48 <dcoutts> since that's the only thing we're blocking
10:26:01 <dcoutts> so you probably want to do the same
10:26:29 <dcoutts> ie move cursor then if it's gone out of visible area then scroll view
10:26:39 <dons> i.e. bind functions to the arrow keys that call window scroll functions
10:26:54 <dons> yep. that's how i'll do it
10:27:06 <astrolabe> int_e: I agree, presumably it guesses the floating point number is an integer if the fractional part is below its least significant digit.
10:28:47 <astrolabe> A shame haskell has to inherit the unpleasantness though.
10:34:05 <int-e> astrolabe: at least Haskell provides a ^^ operator for that purpose (power with integer exponents), so using that feature of ** can be discouraged (I'm not sure if it's actually advertised anywhere in the Haskell docs - I guess the Haskell library report would be the right place to look for that)
10:35:18 <astrolabe> good
10:35:47 <rep> is there a sendfile(2)-like function in haskell?
10:38:11 <TFK> How would I represent a mutable, cyclical structure in Haskell? Suppose I want to walk a cyclical structure of 100 points, labeled 1..100, and knock out every 7-th until only one label is left. (Knocked-out labels don't count when "walking" over them in the future.)
10:39:51 <jyp> I'd use an array
10:40:37 <RemiTurk> rep, there used to be one somewhere in Network IIRC, but I think it has been removed some time ago
10:41:14 <rep> RemiTurk do you know why?
10:41:20 <RemiTurk> nopes
10:41:35 <TFK> No elegant way to do it with a list?
10:42:28 <Korollary> TFK: You can access list elements with an index as well. It's not mutable, though, so you'll be constructing a new list at every step.
10:43:22 <RemiTurk> TFK, I've never used them seriously, but something inside of Data.Graph may be useful too
10:43:25 <TFK> Yes, I know. And it's not very elegant that way, too. Even with an array, I'd still have to somehow implement the cyclical part.
10:43:58 <Korollary> TFK: You can implement the cyclical part by taking the integer modulo of the indices you use.
10:44:20 <TFK> Yes, I can.
10:44:51 <TFK> I was just wondering about a more elegant solution .
10:45:38 <Korollary> TFK: Like this one ? : http://www.haskell.org/hawiki/TyingTheKnot
10:46:29 * TFK crawls
10:46:44 <astrolabe> But don't you need a new copy of the whole thing everytime you delete an element?
10:47:46 <Korollary> astrolabe: right, so the array is not usable.
10:48:21 <astrolabe> Ha, I was talking about the doubly linked list loop thing actually :)
10:49:12 <astrolabe> I thought with the array you could use an array of Maybe Int  s or whatever, and use //.
10:49:25 <astrolabe> Not very nice, but it would work.
10:56:27 <RemiTurk> you could use DiffArray's (as you are using them single-threadedly)
10:56:58 <shapr> TFK: If you want elegance, use Oleg's Zipper as tree of subcontinuations.
10:57:17 <TFK> A-what?
10:57:34 <RemiTurk> ahh, subcontinuations
10:57:38 <rep> heehee
10:57:53 <RemiTurk> I'm still looking for a nic tutorial explaining _normal_ continuations without scheme... anyone ideas?
10:57:54 <TFK> I was actually goofing around with 20 lines of C code... but trees of subcontinuations...
10:58:20 <TFK> btw, hi shapr :-)
10:58:29 <shapr> hiya!
11:08:21 <integral> @type unsafePerformIO
11:08:26 <lambdabot> bzzt
11:08:33 <integral> @index unsafePerformIO
11:08:34 <lambdabot> System.IO.Unsafe, Foreign
11:08:38 <integral> @type Foreign.unsafePerformIO
11:08:39 <lambdabot> forall a. IO a -> a
11:09:41 * shapr sighs
11:10:26 <RemiTurk> what's up shapr? ;p
11:11:19 <shapr> Just reading about Digital Rights Management, Palladium, etc
11:12:10 <shapr> And that Finnish guy who said two days ago that "listening to the music on a CD you purchase is a right, not a privilege."
11:14:40 <RemiTurk> finnish guy?
11:14:53 <shapr> Minister of something or other in Finland.
11:15:19 <RemiTurk> ehm, drm, sighs too
11:15:45 <int-e> shapr: it's a sad story really - but the problem is that people seem to be willing to buy CDs even with DRM. As long as people buy it, the industry will make it.
11:17:01 <shapr> Yup, I agree. I'm not willing to put any money into the Media Mafia. I need to find more websites and labels outside the Mafia.
11:19:48 <Korollary> shapr: I think the guy said just the inverse of that
11:20:47 <Korollary> something to the effect of "listening to a cd on a computer is a privilege, not a right. if you can't listen to it on linux, buy a cd player".
11:20:50 <rep> does Foreign.Marshal.Alloc.alloca behave like alloca(3) (ie, allocates on the stack)
11:21:01 <rep> or does it actually allocate on the heap?
11:21:35 <Janni> Hi.
11:21:51 <rep> hi.
11:22:03 <Janni> Coming with another question on parsec...
11:22:05 <shapr> shazam!
11:22:35 <Janni> As some of you suggested yesterday, I wrote a scanner, instead of parsing the string itself.
11:22:57 <Janni> I implemented the scanner as a "Parser [Token]".
11:23:40 <Janni> The problem is, I don't know how to concatenate this with the actual parser.
11:24:19 <Janni> In the parsec documentation the scanner is implemented as (String -> [(Int,Val)])
11:24:27 <rep> yess
11:24:36 <Janni> where the int is the source position
11:25:21 <Janni> What I could do now is to actually run the scanner, yielding (Int,Val) and then operate the parser on that.
11:25:30 <Janni> [(Int,Val)] I mean.
11:26:01 <Janni> But what I assume is, that there is some function automatically extracting the source positions out of one parser and feeding it to another along with the values...
11:26:40 <Janni> Is anybody able to confirm this?
11:27:51 <Janni> As far as I see, there is no function operating on two Genparsers with different input.
11:28:04 <Janni> (input type)
11:28:09 <shapr> What are you doing?
11:28:25 <Janni> Parsing CSS.
11:28:38 <Janni> For writing an SVG renderer.
11:28:48 <shapr> You can return source positions, though I forget how. What does your parser look like so far?
11:29:11 <shapr> Do you want source positions for error messages?
11:29:39 <Janni> Yes, but that's not really the point.
11:29:52 <Janni> I just want to concatenate two Parsers with different input type.
11:29:58 <Janni> I have:
11:30:04 <Janni> scanner :: Parser [Token]
11:30:35 <Janni> parser :: GenParser [Token] x Stylesheet
11:30:49 <Janni> But how can I combine them?
11:30:56 <shapr> I don't get it.. can I see your code?
11:31:30 <shapr> Isn't GenParser a convenience type that's roughly equal to Parser?
11:31:35 * shapr tries to remember...
11:31:39 <Janni> Hmm. The code of the scanner, yes. But the parser itself isn't implemented in that way yet.
11:31:54 <Janni> type Parser = GenParser String st a
11:32:00 <Janni> s/Parser/Parser a
11:32:21 <Janni> So I have two GenParsers with different input type.
11:32:46 <Janni> The scanner operates on a string, the parser on a [Token].
11:33:25 * shapr blinks
11:33:34 <Janni> An example:
11:34:08 <shapr> When I'm first implementing a Parsec parser, I tend to build the parser and the scanner together. I just build the ADT values directy.
11:35:42 <Janni> But I thought it to be easier this way, because then I have a list of Tokens where I can just filter out the whitespace, comment, ... ADTs.
11:35:44 <shapr> I think I need food to be able to think...
11:36:57 <Janni> In your way I guess the parser itself is still operating on a String.
11:37:24 <Janni> My way it has only a list of tokens.
11:45:16 <integral> I'd like a predicate ((Ord a) => [a]->Bool) to check than an array is strictly increasing
11:45:20 <integral> so far I've got: \(x:xs)= fst $ foldl (\(b,p) x -> (b && (p < x), x)) (True, x) xs
11:45:41 <integral> is there something a bit neater I could be doing instead?
11:45:45 <Janni> Oh? GenParser is a primitive type?
11:48:07 <integral> all $ map (uncurry (<)) $ zip xs (tail xs) -- maybe?
11:49:03 <integral> s/all/all id
11:49:22 <marcot> Janni: no.
11:50:30 <Janni> Good to hear. Then it's just not described in the docs...
11:54:50 <int-e> integral: you can use zipWith f instead of map (uncurry f) $ zip
11:55:20 <int-e> @type and
11:55:21 <lambdabot> [Bool] -> Bool
11:55:22 <integral> thanks
11:55:28 <integral> ah
11:55:30 <int-e> and 'and' for 'all id' :)
11:55:55 <integral> that's much better already :-)  I guess the hard bit was getting from folding to zipping
11:56:19 <int-e> yep
11:58:58 <Janni> That's really nice: \xs -> and $ (zipWith (<) xs $ tail xs). I like this language :D
11:59:52 <Janni> (One '$' too much, btw)
12:06:30 <jix> moin
12:07:45 <ricebowl> is there a way to generate (1, 1) .. (n, n)? I'm actually hoping to generate a very, very, very large list this way... >p
12:07:51 <ricebowl> :p
12:08:04 <ricebowl> to make use lazy evaluation
12:09:00 <shapr> hiya jix, learning Haskell?
12:09:13 <jix> yes
12:09:29 <jix> i'd like to get the execution time of a function call
12:09:31 <shapr> Have any specific questions? Want pointers to the introductory docs?
12:10:13 <shapr> @type (,) -- ricebowl: it's just a constructor.
12:10:14 <lambdabot> forall b a. a -> b -> (a, b)
12:10:31 <jix> i wrote 2 different heap-like priority queues and i'd like to benchmark them
12:11:18 <ricebowl> shapr - not understanding, huh?
12:11:23 <ricebowl> I know that () is a ctor
12:11:24 <shapr> @eval let tupz = map (\x -> (x,x)) [1..] in take 5 tupz
12:11:26 <lambdabot> [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:11:33 <ricebowl> right
12:11:46 <ricebowl> @eval a = [(1) .. (8)]
12:11:48 <lambdabot> 20: parse error on input `='
12:11:50 <ricebowl> @eval let a = [(1) .. (8)]
12:11:52 <lambdabot> 38: parse error on input `)'
12:12:00 <ricebowl> @eval let a = [1 .. 8]
12:12:01 <lambdabot> 34: parse error on input `)'
12:12:06 <shapr> jix: You can use GHC's profiling support.
12:12:07 <ricebowl> wtf. :(
12:12:11 <Cale> @eval [(x,x) | x <- [1..5]]
12:12:13 <lambdabot> [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:12:19 <jix> shapr: how do i use it?
12:12:41 <Cale> jix: there's also http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.CPUTime.html
12:12:41 <ricebowl> @eval let a = [1]
12:12:43 <lambdabot> 29: parse error on input `)'
12:12:54 <ricebowl> @eval let foo = [1]
12:12:55 <lambdabot> 31: parse error on input `)'
12:12:56 <shapr> jix: You can also try this - http://urchin.earth.li/~ian/bench/
12:12:57 <ricebowl> why is this breaking?
12:13:20 <shapr> @eval let foo = [1] in foo
12:13:22 <lambdabot> [1]
12:13:27 <Cale> ricebowl: because lambdabot only evaluates complete expressions
12:13:39 <ricebowl> @eval let foo = [(1) .. (8)] in foo
12:13:42 <lambdabot> [1,2,3,4,5,6,7,8]
12:14:23 <ricebowl> @eval [(x,y) | x <- [1 .. 3], y <- [1 .. 3]]
12:14:25 <lambdabot> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:14:30 <ricebowl> that is what I want, a little bit different
12:14:41 <Cale> @eval [(x,x) | x <- [1..5]]
12:14:44 <lambdabot> [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:15:02 <ricebowl> hmm, for some reason I was thinking that I would have N dimensions, but I suppose not
12:15:06 <Cale> oh
12:15:08 <Janni> @eval [1..8]
12:15:10 <lambdabot> [1,2,3,4,5,6,7,8]
12:15:37 <Cale> @eval [[(x,y) | y <- [1..3]] | x <- [1..3]]
12:15:39 <lambdabot> [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
12:15:49 <Janni> What happens if I enter @eval [1..]?
12:16:02 <Cale> It spits a few lines of that to the channel
12:16:08 <Cale> and then stops
12:16:10 <ricebowl> if I were to do that with a very large N, lazy evaluation would permit me to iterate through the array without memory problems, right?
12:16:19 <Cale> ricebowl: right
12:16:43 <ricebowl> ok
12:16:46 <Cale> ricebowl: You can get away with incredible things with lazy evaluation :)
12:16:56 <ricebowl> I know
12:17:31 <ricebowl> but I'm fairly new to the language, have only been learning for a few weeks, less really
12:18:00 <Janni> What does lambdabot do with @eval last (replicate 3)?
12:18:09 <Cale> The other day I was thinking about taking a tree t, and producing a tree of the same shape, but on each of the vertices, there was a list of subtrees of t starting at the corresponding vertex and heading up toward the root.
12:18:13 <Janni> Only calculates a few seconds?
12:18:39 <Cale> Janni: type error
12:18:52 <Janni> s/replicate/repeat of course...
12:18:59 <Cale> oh, yeah, it'll stop
12:19:08 <Cale> @eval last (repeat 3)
12:19:19 <lambdabot> Terminated
12:19:22 <Janni> @eval last (repeat 3)
12:19:22 <Janni> @eval last (repeat 3)
12:19:23 <Janni> @eval last (repeat 3)
12:19:23 <Janni> @eval last (repeat 3)
12:19:26 <Janni> Let's see.
12:19:33 <lambdabot> Terminated
12:19:39 <Cale> @eval 1 + 1
12:19:43 <lambdabot> Terminated
12:19:51 <Janni> Uhh...
12:19:54 <lambdabot> Terminated
12:20:04 <lambdabot> Terminated
12:20:06 <lambdabot> 2
12:20:34 <Janni> lambdabot: I hope I wasn't being too cruel to you.
12:21:10 <Cale> @help eval
12:21:11 <lambdabot>  @eval <expr>
12:21:11 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
12:22:06 <Akshaal> how is no IO checked?
12:22:29 <Akshaal> oh, ok, known
12:23:28 <shapr> pesco: Hail Eris!
12:23:46 * TheHunter wonders why lambdabot didn't do the evals in parallel
12:24:08 <shapr> hiya TheHunter, how's your international adventure?
12:24:35 <TheHunter> it's ok, on the weekends I actually have free time.
12:24:45 <Akshaal> @eval System.IO.Unsafe.unsafePerformIO $ print "123"
12:24:47 <lambdabot> 18: Not in scope: `System.IO.Unsafe.unsafePerformIO'
12:25:22 <shapr> TheHunter: What are you doing for fun these days?
12:26:44 <TheHunter> well, the normal stuff, we went to a bar yesterday, still I'm a little hung over.
12:26:48 <jix> i have some benchmark results of my priority queues
12:27:24 <TheHunter> i haven't done any haskell in a long time.
12:27:44 <TheHunter> how's your school going?
12:28:01 <shapr> I haven't started yet, I think I'll end up going next term.
12:28:58 <shapr> Work and a new apartment is taking up all my time at the moment.
12:29:41 <shapr> Have you seen the Yi+Gtk/hIDE screenshot? http://www.scannedinavian.org/YiWiki
12:30:37 <TheHunter> yeah, i've seen screenshots, they look really cool.
12:30:59 * TheHunter sets up a proxy on a german box since .org isn't resolving here again.
12:32:35 <TheHunter> so the syntax highlighting comes from a real haskell parser?
12:33:42 <int-e> . o O ( scannedinavian.org DNS is still broken here :/ scannedinavian.com instead works though )
12:34:09 <lscd> it worked for me
12:35:00 <shapr> hiya lscd
12:35:06 <Lemmih> Hi lscd (:
12:35:16 <lscd> heya shapr, Lemmih - how's hide going? :)
12:35:30 <rep> is there something like select(2), but for a list of handles?
12:35:51 <rep> and/or sockets
12:35:52 <shapr> I got it to build. I had to disable cairo support for gtk2hs.
12:36:00 <shapr> int-e: I must have screwed up something.
12:36:05 <Lemmih> lscd: It's OK, I think. Been busy with some other things.
12:37:04 <shapr> TheHunter: I think the existing synhl is coming from dcoutts' highlight file for the GTK SourceView widget. Lemmih has hacked out a ghc-api package that'll be much niftier.
12:37:09 <int-e> shapr: the .org nameservers provide an IP address for scannedinavian.org - and that's the wrong one. the authoritative name servers are fine. Now if a caching DNS server is configured to only work with authoritative answers, everything is fine; if it doesn't, it caches the wrong IP.
12:38:44 <int-e> shapr: at least that's my current explanation of the phenomenon. my knowledge about DNS is quite abstract really - I don't know the gory details of nameserver configurations, nor do I understand the administrative part.
12:38:51 <shapr> Any idea why the authoritative servers have the wrong IP?
12:39:06 <shapr> I thought I understood both of those. Obviously not :-)
12:41:29 <int-e> shapr: have you seen http://paste.lisp.org/display/11890 ?
12:42:34 <int-e> shapr: (it's still up to date except for the first query; that cached IP has expired and it returns the wrong one for me now)
12:42:59 <int-e> shapr: and the problem is the reply from the .org nameserver
12:44:57 <int-e> shapr: if it were just a delegation (as to my understanding it actually should be) it would not return an IP address at all and everything would be fine - I don't know why it returns the IP address :(
12:45:59 <shapr> That's really weird.
12:47:31 <int-e> shapr: and the (constant) 86400 says it's not even a cached entry, it's just the information that the .org nameserver has and gives out. For me it's an administrative problem from there on - who's responsible for that entry? And as I said I don't understand how that works.
12:48:26 * int-e goes idle for a bit.
12:57:41 <jix> is there a standard function to apply a function n times on value x
12:59:21 <Cale> I suppose iterate f x !! n
12:59:38 <Cale> @eval iterate (+1) 0 !! 5
12:59:52 <Cale> @eval (iterate (+1) 0) !! 5
12:59:57 <shapr> I think .au just left the 'net
13:00:02 <Cale> oh yeah
13:00:11 <jix> Cale: thx
13:05:12 <wilx> Hmm...
13:05:58 <wilx> @pl \n f -> take n $ repeat f
13:06:21 <wilx> Hmpf.
13:11:04 <Hikaru79> Bonjour, #Haskell
13:12:24 <rep> the io monad is everywhere!
13:18:38 <wilx> foldl (.) f (take (n - 1) $ repeat f)
13:18:39 <wilx> Hah!
13:19:03 <wilx> My Haskell-fu is weak. Took me whole lot of time to get it right.
13:25:04 <int-e> wilx: that doesn't work for n=0 though
13:25:30 <wilx> It does.
13:25:49 <wilx> Oh.
13:25:50 <wilx> Right.
13:26:04 <wilx> Details :)
13:26:11 <Cale> foldl (.) id (replicate n f)
13:26:17 <wilx> replicate!
13:26:26 <wilx> I knew there was some such function but I couldn't remember.
13:27:02 <int-e> (!!n).(iterate f)
13:27:16 <Cale> yeah, that's essentially what I suggested before :)
13:27:38 <int-e> Cale: I know. I wanted something that does it without lambda and without an explicit argument.
13:28:51 <Cale> @pl (\x -> (iterate f x) !! n)
13:28:55 <Cale> oh
13:29:05 <Cale> lambdabot still isn't back
13:29:22 <Cale> probably comes up with the same thing anyway :)
13:30:27 <Lemmih> Hi dons.
14:04:01 * rep cheers
14:19:06 <Janni> From the sources of parsec:
14:19:17 <Janni> type Parser a = GenParser Char () a
14:19:29 <Janni> newtype GenParser tok st a = Parser (...)
14:19:58 <Janni> Is that just a weird way to express a recursive data structure?
14:20:40 <Lemmih> No.
14:20:56 <Janni> Ah, I get it.
14:21:08 <Lemmih> 'Parser' the type and 'Parser' the data constructor aren't related.
14:21:31 <Janni> Was just gonna say it. Thanks :)
14:24:36 <rep> is there a way to tell haskell to sleep?
14:25:48 <Lemmih> @type Control.Concurrent.threadDelay
14:26:41 <rep> thanks!
14:28:09 <Lemmih> Where did lambdabot go?
14:28:36 <int-e> [21:45:29] <-- lambdabot has quit (Read error: 110 (Connection timed out))
14:28:42 <shapr> au dropped off the 'net for half an hour, and lambdabot isn't smart enough to reconnect.
14:29:23 <Janni> Back to my parsec problem: What I'm looking for is a function that takes two parsers and results in a parser that acts as if the input is feeded to the first parser whose output is eaten by the second parser. The signature:
14:29:32 <Janni> catParsers :: GenParser input st intermediate -> GenParser intermediate st output -> GenParser input st output
14:30:09 <goron> Janni: Maybe you could buy one on EBay? They sell a lot these days.
14:30:13 <Janni> I don't think it's possible to implement this function if the parsec sources aren't modify.
14:30:53 <Janni> s/if the parsec sources aren't
14:31:01 <Janni> hrmph.
14:32:29 <shapr> Could it be something simple like lifting function composition?
14:32:32 <Lemmih> Sure it's possible.
14:34:26 <Janni> Hmm. You know how?
14:34:39 <Lemmih> Just run the second parser with the result of the first.
14:34:58 <Janni> Of course, but then the source positions are dismissed.
14:35:26 <Lemmih> Use getPosition/setPosition.
14:36:00 <Janni> Of course, but I can only use it inside the first parser between it's "commands"
14:36:36 <Janni> That would mean I must implement the first parser as "GenParser input st (SourcePos, intermediate)
14:37:20 <Lemmih> Why would you want to reparse some parsed information, btw?
14:38:10 <Janni> I want to modify the result of my scanner a bit before parsing over the result, for example removing whitespace tokens, comment tokens etc...
14:38:40 <Janni> I know there are other ways, but that would be quite comfortable
14:39:19 <Lemmih> I don't see why you would use parsec to filter out tokens.
14:39:37 <Janni> you mean "wouldn't"?
14:40:02 <Janni> I don't understand.
14:40:03 <Lemmih> No, I don't.
14:40:16 <Janni> YOU don't understand? ;)
14:40:39 <ricebowl> I don't mean to interrupt, but is there anything similar to the `x` operator in perl? i.e. (1 x 3) = (1, 1, 1)
14:40:53 <basti_> ricebowl: yes, "replicate". It works with lists though.
14:41:00 <ricebowl> right, I understand that :p
14:41:05 <basti_> @plugs replicate 5 1
14:41:06 <ricebowl> () is the list construct in perl
14:41:24 <basti_> oh ok. i'm not that fluent in perl
14:41:40 <Lemmih> Janni: That's correct. I don't understand why you would use parsec to filter out tokens.
14:41:42 <basti_> where is lambdabot?
14:41:46 <integral> ricebowl: no, , in list context is the list "constructor", not ()...
14:41:58 <Janni> Ah, now I know what you mean.
14:42:02 <basti_> ricebowl: replicate :: Int -> a -> [a] iirc.
14:42:05 <ricebowl> yes
14:42:11 <ricebowl> I was just playing with it, I see how it works
14:42:15 <ricebowl> thanks
14:42:25 <basti_> you know that you could use an infinite list too?
14:42:31 <ricebowl> yes, that's what I was just about to ask
14:42:34 <Janni> Erm, the scanner isn't that simple. Actually it's a parser itself...
14:42:37 <basti_> thats "repeat"
14:42:55 <ricebowl> hmm...
14:43:02 <ricebowl> I'm not sure how that would work
14:43:02 <basti_> repeat a gives a list of arbitary length
14:43:06 <Janni> It parses Floats and Strings and such...
14:43:10 <ricebowl> infinite it would seem ;)
14:43:16 <Janni> unicode characters...
14:43:22 <basti_> if you never need infinitely many elements, then it won't be a dead end
14:43:35 <basti_> of course, if you try to print *all* the list or something, there will be an endless loop
14:43:52 <basti_> but you can have the n'th in any case
14:44:07 <ricebowl> what I want to do is construct a list of all possible permutations of N integers in range 1..M
14:44:16 <ricebowl> which of course would be extremely large
14:44:32 <basti_> oh thats a nice task. do you want a solution, or do you see it as an exercise problem?
14:44:36 <ricebowl> er, actually, in the range 1..N
14:44:40 <ricebowl> yes, a solution :p
14:44:48 <basti_> wait I'll paste you one
14:44:55 <ricebowl> I can come up with a way to do it, but I was hoping to find a better way to do it
14:45:02 <ricebowl> the latter as an exercise
14:45:06 <basti_> lisppaste2: @url
14:45:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:45:20 <ricebowl> let me elaborate a bit.
14:45:44 <ricebowl> for a class assignment I have to write a solution to the N-queens problem. Simple problem. The reason why we have to do this is to force us to experiment with Haskell since the class is about Haskell.
14:45:58 <lisppaste2> basti_ pasted "permutation generation" at http://paste.lisp.org/display/11949
14:46:01 <basti_> there you go
14:46:08 <ricebowl> my idea was to generate a list of all possible permutations, write a function to check to see if one was valid, and then use filter
14:46:20 <basti_> that will work
14:46:29 <ricebowl> right, but I have to figure out how to generate the permutations :p
14:46:33 <basti_> actually this function is from an n-queens program
14:46:36 <ricebowl> it's a list of positions, each position is a list of (x,y)
14:46:39 <ricebowl> ah, cool
14:47:46 <basti_> its not the quickest possibility probably.
14:47:50 <ricebowl> weird... heh, I'm having trouble understanding the code :p
14:48:01 <ricebowl> but I should probably get dinner
14:48:24 <basti_> the idea is simple... to make a permutation of [1,2,3,4] you take the 1 and reach it "through" the first permutation of [2,3,4], then through the second etc.
14:48:38 <basti_> "reaching through" means: [1,2,3,4] [2,1,3,4] [2,3,1,4]...
14:48:44 <ricebowl> ah
14:49:01 <basti_> only that it recurses then, to get the permutations of 2,3,4
14:49:06 <ricebowl> right
14:49:56 <basti_> actually i think this is one of the most bizarre functions I ever wrote. ;)
14:50:05 <ricebowl> haha
14:50:29 <basti_> but i dont want to stop you from getting food
14:50:40 <Cale> ricebowl: have a look at the list monad :)
14:50:57 <ricebowl> well, I think I'm going to order a pizza as is (often) my custom on Saturdays ;)
14:51:16 <basti_> oh
14:52:36 <ricebowl> heh, I think really the way I would write it is essentially [1..N] x N
14:52:50 <ricebowl> er... d'oh
14:52:57 <ricebowl> this is wrapping my mind in circles :p
14:53:07 <basti_> -g-
14:53:39 <ricebowl> I think I am starting to understand how it must work underneath the hood, though
14:53:43 <int-e> ricebowl: you mean, [n, n*2..n*n]?
14:53:45 <Cale> ricebowl: consider a board with n < N queens already on it, and determine the list of ways to add a queen to it.
14:53:56 * int-e isn't paying attention.
14:54:06 <ricebowl> int-e - eh don't worry about it :p
14:54:07 <basti_> actually, there is an algorithmic solution for the n-queens problem
14:54:16 <basti_> I'm sure you're supposed to implement the search though
14:54:21 <ricebowl> hmm, is there? I'm not familiar with it.
14:54:23 <ricebowl> yes probably
14:54:47 <ricebowl> Cale - true...
14:54:47 <basti_> its O(n) and very simple, just non-obvious
14:55:17 <Cale> ricebowl: at that point, you will find (>>=) very handy :)
14:55:57 <ricebowl> well, I think I am still going to stick with my shoot-first-ask-questions-later solution ;)
14:56:05 <Cale> [10,20,30] >>= (\x -> [x+1, x+2]) == [11,12,21,22,31,32]
14:56:13 <ricebowl> I was mostly trying to figure out how Haskell deals with lists in terms of understanding what would be efficient
14:56:48 <Cale> lists together with this operation >>= are a great way to represent a search and backtracking problem :)
14:57:01 <ricebowl> what does >>= do?
14:57:13 <basti_> ricebowl: monads are cute pink fuzzy little things.
14:57:21 <gzl> with plutonium inside.
14:57:22 <Cale> takes each thing in the list on its left and pass it into the function on its right
14:57:24 * basti_ is just preparing ricebowl for the shock
14:57:26 <Cale> which returns a list
14:57:30 <ricebowl> I'm sure, but I have only been studying Haskell for like 3 weeks
14:57:33 <int-e> ricebowl: for lists, it's a mix of concat and map.
14:57:39 <Cale> then it collects up those lists and concatenates them
14:57:57 <ricebowl> weird; can you offer an example?
14:57:59 <Cale> so  xs >>= f = concat (map f xs)
14:58:03 <Cale> I just did :)
14:58:06 <Cale> [10,20,30] >>= (\x -> [x+1, x+2]) == [11,12,21,22,31,32]
14:58:10 <ricebowl> right, but I've forgotten what map is
14:58:13 <ricebowl> oh, d'oh, sorry :p
14:58:14 <Cale> oh
14:58:15 <ricebowl> err
14:58:17 <ricebowl> s/map/concat/
14:58:20 <ricebowl> map is obvious
14:58:28 <Cale> concat :: [[a]] -> [a]
14:58:35 <int-e> concat takes a list of lists and concatenates them
14:58:57 <ricebowl> oh
14:59:07 <ricebowl> I see
14:59:40 <ricebowl> sort've... grr, never have sugar on an empty stomach x_x
15:00:49 <Cale> So all you have to do is write a function addQueen :: Board -> [Board], which gives all the ways of adding a queen to the board (and [] if there are none)
15:00:50 <int-e> Cale: argh, I can see this come down to a foldl (>>=) [0] (some function)
15:01:04 <Cale> int-e: exactly :)
15:01:08 <int-e> Cale: err, replicate n (some function)
15:01:25 <int-e> eek :)
15:01:37 <Cale> You just take your empty board, and extend it by addQueen n times.
15:01:58 <Cale> no thinking about backtracking involved :)
15:02:16 <Cale> it's all handled by >>=
15:02:35 <Cale> and laziness
15:02:37 <int-e> yep, it boils down to a pretty standard implementation of breadth first search, actually.
15:02:48 * int-e can do the same in C ;-)
15:02:55 <Cale> except that when you run it, it's depth first
15:03:00 <Cale> hehe
15:03:15 <Cale> you get to think about it breadth first, but that's not how it runs :)
15:03:18 <int-e> ok, it is, but that's due to lazyness.
15:03:22 <Cale> right
15:03:31 <Cale> which is incredibly convenient
15:03:43 <int-e> (did I say 'but'?)
15:03:49 <ricebowl> seems to me that lists are really something similar to "iterators"
15:03:50 <Cale> because things like this tend to explode combinatorially :)
15:03:57 <Cale> ricebowl: yes
15:03:58 <ricebowl> this all makes a lot of sense
15:04:08 <ricebowl> or would make sense if I could concentrate ;)
15:04:09 <basti_> back
15:04:09 <Cale> Data structures are control flow mechanisms :)
15:04:14 <ricebowl> right
15:04:45 <int-e> Data is Program. War is Peace ... Exactly one of these statements is true.
15:04:49 <Cale> (except that you can forget that and go back to thinking about them as data structures whenever you feel like it)
15:11:55 <rep> httpd: internal error: main thread has been GC'd
15:11:55 <rep>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
15:11:56 <rep>     or http://www.sourceforge.net/projects/ghc/
15:11:57 <rep> hehe
15:13:03 <Cale> Lazy evaluation also lets you do all sorts of coroutine type tricks. As a simple example, let evens = 0 : map (+1) odds; odds = map (+1) evens. Evaluation bounces back and forth between evens and odds.
15:13:53 <int-e> Cale: well, deep down in the virtual machine a thunk is just a suspended coroutine. :)
15:14:00 <Cale> yeah
15:14:46 <ricebowl> hmm, I have an idea
15:15:12 <ricebowl> is it possible to use pattern matching on anonymous functions?
15:15:20 <ricebowl> I want to create a function that iterates through a list
15:15:43 <Cale> you should either use let or case
15:15:45 <jix> my priority queue is faster than i thought
15:15:58 <jix> i loaded a dictionary with 48076 words
15:16:07 <ricebowl> eh? I want the anonymous equivalent of this:
15:16:16 <jix> popped the first 100 words without printing them
15:16:18 <ricebowl> er wait...
15:16:21 * ricebowl thinks
15:16:27 <jix> popped another 100 words with popping
15:16:42 <jix> deleted the words "worldly spunk reiterated" from the queue
15:17:01 <Cale> ricebowl: remember that you can just use a where clause or a let if you just want a locally defined function. You don't have to use a lambda.
15:17:11 <ricebowl> right, I know
15:17:11 <Cale> But you can write \x -> case x of ....
15:17:14 <musasabi> basti_: did you reach a conclusion with the hswebforms DefaultRender thing?
15:17:16 <ricebowl> I have been doing that quite often
15:17:17 <jix> popped 47576 without outputting and dumped the remaining queue in 14 secs
15:17:36 <ricebowl> but anonymous would be appropriate here
15:17:41 <ricebowl> except that I'm not sure if it will work...
15:18:32 <ricebowl> hmm... I was just thinking about the equivalence of a list and a function (as an iterator), but I'm not sure how to write it
15:18:43 <ricebowl> mainly because I'm tired and probably shouldn't be coding right now
15:19:15 <ricebowl> oh well, bbl
15:19:44 <basti_> musasabi: yes i did. what you suggested was 100% possible. I just doubt that it makes more sense than just implementing one's own functions
15:19:50 <basti_> it doesnt abstract a lot
15:20:35 <musasabi> basti_: yes, in many cases after prototyping you would write your own functions.
15:20:47 <xerox> rep: I think alloca allocates on the heap
15:21:13 * basti_ nods
15:21:48 <basti_> i can think of situations where this might make sense though
15:21:57 <rep> xerox alloca in libc allocates on the stack though
15:22:36 <basti_> for example, if you want to override the default behaviour just for one single column.
15:23:02 <xerox> rep: yes I know
15:23:30 <musasabi> yes. and the defaults are nice so that one can incrementally add more suitable views but get instant results when prototyping.
15:23:37 * basti_ nods
15:26:35 <shapr> Another one of shapr's laws of code: All code should be simple. If you want optimized code, write a simple optimizer.
15:27:39 <shapr> But maybe that's just shapr's Law of Speed of Change.
15:27:42 * shapr shrugs
15:27:46 <xerox> If you want simple rules.
15:27:59 <rep> is it me or does forkOS actually lie?
15:28:05 <rep> s/actually//
15:28:10 <shapr> xerox: hm?
15:28:14 <rep> it deosn't seem to create OS threads, on my box
15:28:17 <rep> boxes
15:28:30 <xerox> shapr: I thought two different things and wrote them in a single phrase... I need sleep.
15:28:31 <shapr> Are you using -threaded ?
15:28:34 <rep> shapr yes
15:28:48 <shapr> Sounds like it should work then.
15:28:48 <xerox> I went to a sk8 contest today - big fun.
15:29:20 <shapr> Cool! Were you a spectator or participant?
15:29:45 <xerox> It was a 'best trick' one - too much for me, there were some guys who really rock.
15:29:47 <rep> shapr maybe because ghc wasn't built with --use-threaded-rts or something?
15:30:03 <shapr> I think that's the default with 6.4 and 6.4.1
15:30:18 <rep> hm
15:30:38 <xerox> But we did much skate before the actual contest!
15:30:54 <xerox> My kickflip-fu is nearly perfect now.
15:31:12 <rep> shapr according to top(1), it _always_ has 3 threads
15:31:22 <rep> even though it should have way more
15:31:24 <araujo> Hello here.
15:31:50 <shapr> rep: I dunno.
15:32:22 <rep> oh wait
15:32:39 <rep> yeah, i forgot i'm using n:m threads :)
15:32:51 <xerox> I'll tune in some old good Go, and watch it trying to sleep.  Goodnight.
15:32:58 <rep> night
15:33:02 <shapr> rep: http://www.mail-archive.com/ffi@haskell.org/msg01164.html ?
15:33:12 <shapr> n:m ?
15:33:31 <shapr> I was doing something cool, I wish I could remember what.
15:33:45 <rep> shapr freebsd's libpthreads (by default) creates only 3 or 4 kernel threads
15:34:17 <shapr> ah, ok
15:34:20 <rep> depending on how many cpus you have
15:35:04 <rep> that way, you have both the advantages of kernel threads (can take advantage of multiplecpus) and the ones of user threads (very lightweight)
15:35:18 <rep> i'll try with the 1:1 libpthread
15:35:42 <basti_> good night
15:36:55 <rep> yes, it works
15:37:02 <rep> ghc doesn't lie!
15:37:03 <rep> \o/
15:37:36 <shapr> It's too bad I can't send snailmail to lat/long co-ords.
15:37:44 <rep> heh
15:38:51 <rep> i'm hitting a lot of ghc bugs though
15:39:00 <rep> internal error: scavenge_stack: weird activation record found on stack: 58332
15:39:20 <Lemmih> With 6.4.1?
15:39:26 <rep> 6.4
15:39:41 <wagle> shapr: build a front-end to googlemaps
15:39:43 <rep> is this supposed to be fixed in 6.4.1?
15:40:03 <shapr> wagle: interesting idea.
15:40:20 <wagle> find the closest postal address
15:47:47 <rep> hm
15:47:59 <rep> freebsd doesn't have 6.4.1 yet :(
15:48:30 <wagle> rep: darwinports has it
15:48:56 <wagle> and darwin is a lot like freebsd (or so i've been told)
15:49:00 <rep> but not freebsd ports
15:49:19 <rep> i don't think darwinports will run on freebsd
15:49:40 <wagle> but the port might compile on freebsd
15:50:46 <rep> *shrug*
15:55:00 <rep> i suspect updating the port is trivial
16:02:48 <HiveNode> hi guys...i have a problem...i use getKey to get a key typed while a hugs graphics window is open and then i try to determine if a special key was typed...it doesnt work
16:02:57 <HiveNode> i can print the character
16:03:28 <HiveNode> but once i want to do "if character=='K' then..." it doesnt catch it
16:03:31 <HiveNode> any ideas?
16:04:20 <int-e> that's shift-K?
16:04:31 <HiveNode> iv tried either way
16:04:41 <HiveNode> it just doesnt realize i have a normal char
16:04:44 <HiveNode> i can catch space
16:04:48 <HiveNode> but not a normal character
16:05:34 <HiveNode> so "if character==' ' then..." works but now "if character=='<insert char to test for here>' then..."
16:05:53 <HiveNode> but not...not "but now"
16:08:21 <HiveNode> any ideas?
16:09:33 <rep> updating the port is not trivial :(((
16:10:11 <HiveNode> but why doesnt it work right away? isnt space a char like any other?
16:10:45 <wagle> unicode?
16:11:07 <HiveNode> ummm...i have no idea how the characters are encoded
16:11:25 <HiveNode> so if i cant use getkey...how should i solve this?
16:11:25 <wagle> one end is doing unicode and the other ascii (maybe)
16:11:33 <wagle> i dunno
16:11:43 <wagle> never done it in haskell
16:12:09 <arjanb> what is the result of getKey in int?
16:12:28 <HiveNode> havent tried treating it as an int
16:12:57 <wagle> arjanb: good idea
16:14:05 <HiveNode> hmm...im a bit new to haskell so i cant remember off the top of my head how you do explicit type conversions...help? =)
16:14:28 <wagle> @ttype ord
16:14:32 <wagle> @type ord
16:14:42 <wagle> waugh!
16:14:50 <int-e> lambdabot has gone missing
16:15:13 <int-e> Data.Char.ord :: Char -> Int
16:15:44 <wagle> HiveNode: ^^^
16:15:48 <wagle> int-e: thanks
16:16:08 <HiveNode> hmmm..."undefinded qualified type Data.char"
16:16:29 <HiveNode> undefined qualified variable "data.char" even
16:17:11 <sylvan> Data.Char is a module, import it
16:17:27 <int-e> HiveNode: first, capitalization matters; secondly you probably want to wrap that in an import statement 'import Data.Char (ord)' and then use just ord
16:17:36 <arjanb> you can also use fromEnum
16:17:50 <int-e> oh
16:17:52 <musasabi> unsafeCoerce# gives all type conversions with a oneway trip to hell included.
16:19:23 <HiveNode> um...im a bit lost here
16:20:51 <int-e> HiveNode: fromEnum ' ' -> 32. fromEnum 'A' -> 65 etc.
16:21:17 <int-e> HiveNode: ord does the same, but only for Char.
16:21:31 <HiveNode> is fromEnum predefined? or is that a module too?
16:21:49 <HiveNode> and the numbers i get back, are they ascii?
16:23:01 <int-e> fromEnum is defined in the Prelude or builtin; you get back an Int, a whole number.
16:23:19 <int-e> for ASCII characters you'll get their ASCII value
16:23:41 <HiveNode> ok...if they are not ascii, what is the default character set?`
16:24:02 <Torrente> Hi!
16:24:36 <shapr> hiya Torrente
16:25:04 <Torrente> I'have a dubt....
16:25:04 <Torrente> shapr: hi
16:25:06 <HiveNode> what i mean is...were can i find a list of numbers and their coresponding chars?
16:25:10 <int-e> HiveNode: ASCII is just the first 128 characters. There aren't different character sets in ASCII (although there are slight variations like replacing the $ by the british pound sign)
16:25:44 <int-e> HiveNode: you can just press the corresponding key in your window and print the number you get from toEnum $ getKey win
16:25:54 <Torrente> why all fixed point in lambda calculus must contain self application
16:25:57 <Torrente> ??
16:25:58 <int-e> err, fromEnum.
16:26:09 <Torrente> fixed point operators
16:26:34 <HiveNode> ok, thanks
16:26:36 <Torrente> there is a proof of this????
16:27:05 <int-e> Torrente: what's self application? what version of lambda calculus are you using?
16:27:57 <Torrente> int-e: self application is for example \x.xx
16:28:19 <Torrente> \x.xx is not typable in curry type system
16:28:34 <Torrente> because it contain self app
16:29:13 <int-e> Oh, so your question is about typability, actually?
16:29:17 <Torrente> and all fixed points op have selfapp
16:29:27 <Torrente> yeah
16:29:51 <Torrente> this implies that in curry system not is posible type a fixed point
16:29:58 <Torrente> this is my question
16:30:58 <Torrente> I cant thing why all fixed point terms must contain self app
16:32:35 <Lor> What exactly is a "fixed point term" here?
16:32:48 <rep> hm my httpd in haskell seems faster than apache?!
16:33:01 <Torrente> Y f = f ( Y f ) ???
16:33:06 <Torrente> Y is the term
16:33:09 <Lor> Apparently it's some kind of a syntactic notion (instead of a traditional mathematical fixpoint), but also obviously not just "some application of Y operator".
16:33:56 <Torrente> what is the matematical fixpoint definition?
16:34:33 <Lor> x is a fixed point of f when f(x) = x
16:34:55 <Lor> But you were not talking about the semantics of lambda calculus, I take?
16:34:57 <Torrente> okok
16:34:59 <Torrente> yes
16:35:23 <araujo> Anyone knows if there exist a pre-defined function to get the bigger number in a list?
16:35:30 <Lor> So you are asking why any term implementing Y must contain a self-application?
16:35:37 <Lemmih> araujo: List.maximum
16:35:42 <araujo> Thanks Lemmih
16:36:10 <Torrente> yes
16:36:13 <Torrente> exactly
16:36:44 <Torrente> my question is about this proof (if exist)
16:37:09 <Torrente> but first, is true?
16:37:46 <Torrente> the matematical notion is f x = x
16:38:11 <Torrente> but if Y f = f (Y f )
16:38:11 <Torrente> f = Y f
16:38:19 <metaperl> araujo: maybe it's Data.List.maximum . try that if you don't see it
16:38:43 <Lor> torrente, no.
16:38:44 <Torrente> g x = x whith g = Y f
16:39:02 <Torrente> if the same
16:39:04 <Torrente> is the same
16:39:27 <Torrente> sory, x = Y f
16:40:26 <Torrente> Lor: no?
16:40:33 <Torrente> Lor: what?
16:41:24 <Torrente> fixed point is the matematical definition
16:42:25 <Lor> The world of lambda calculus terms and the world of mathematical objects are different beasts. Beware confusing them.
16:42:42 <araujo> metaperl, yeah, i know, Thanks :-)
16:43:00 <Lor> In particular, mathematical functions have extensional equality.
16:43:13 <Torrente> sorry
16:43:18 <Torrente> i cant read
16:44:57 <palomer> any complexity theorists around?
16:45:12 <palomer> the problem is: given T and T', find f such that T f = T'
16:45:30 <palomer> (assuming it exists)
16:46:01 <Lor> T is what? A computable function? A lambda term?
16:46:53 <Torrente> yes
16:46:54 <Torrente> go on
16:46:59 * wagle starts turning blue
16:47:37 <palomer> a lambda term
16:47:42 <Torrente> mm
16:47:49 <palomer> or a program, whatever
16:47:51 <palomer> it's really the same
16:47:59 <palomer> T' in normal form
16:48:11 <Torrente> mmmm
16:48:17 <Lor> I think Rice's theorem says it cannot be done.
16:48:28 <palomer> rice's theorem?
16:48:39 <Lor> Rice's theorem pretty much says that nothing interesting can be done. :)
16:48:46 <Torrente> lol
16:48:47 <Torrente> yeas
16:48:50 <Torrente> but.....
16:49:38 <Torrente> it is not posible for all T
16:49:51 <palomer> this problem is possible
16:49:53 <Torrente> the halt problem i guess
16:49:58 <palomer> since you can simply enumerate all the possible f's
16:50:06 <Torrente> but...
16:50:08 <wagle> is T isnt closed, then if T = x, then there is no f such that T f = (\x . x)
16:50:20 <palomer> wagle: I'm assuming that f exists
16:50:38 <wagle> false assumption if T = x
16:51:10 <Torrente> via type habitation???
16:51:43 <palomer> wagle: you don't even need that assumption: (\y.\x. x) f = \x.xx has no solutions in f
16:52:12 <wagle> sure
16:52:26 <palomer> wagle: but we're assuming that f exists
16:52:33 <palomer> (this is a key point)
16:52:35 <wagle> so you know for certain that f exists, you are just supposed to find it
16:52:40 <palomer> yeah
16:52:44 <Torrente> mmmm
16:52:49 <Torrente> find a type for T'
16:53:08 <Torrente> T is any lambda term?
16:53:13 <wagle> Mayer Goldberg (and Oliver Danvy?) have some stuff like this
16:53:23 <palomer> Torrente: yeah
16:53:26 <palomer> T is closed
16:53:44 <palomer> and T' is closed
16:53:46 <Torrente> with strong normalization property ?
16:53:50 <palomer> but I don't think it makes much of a difference
16:53:51 <Torrente> ahhh
16:53:52 <Torrente> ok
16:54:00 <palomer> T' is normal, T may not be
16:54:25 <wagle> T f is normalized, though, i imagine
16:54:39 <palomer> T f is normalizable since T' is in normal form
16:54:44 <Torrente> yeas
16:54:53 <Torrente> T' is in normal form
16:55:08 <palomer> now, this IS computable
16:55:13 <palomer> because it's recursively enumerable
16:55:26 <palomer> can everyone see this?
16:55:30 <wagle> ah..  so the thing is that you know it normalizes, and even know what it normalizes to
16:55:41 <palomer> right
16:55:43 <wagle> sure
16:55:52 <palomer> so which complexity class:O
16:56:02 <Torrente> haha
16:56:14 <Torrente> NP-complete
16:56:21 <palomer> are you sure?
16:56:25 <Torrente> nope
16:56:29 <palomer> >:O
16:56:35 <palomer> you see, this is what I'm trying to do
16:56:41 <palomer> take any random program
16:56:52 <palomer> find some invariants of that program
16:57:05 <Torrente> aha
16:57:12 <palomer> so that it's hard to find another program with the same invariant
16:57:16 <palomer> invariants
16:57:43 <palomer> T f = T' is an invariant
16:58:52 <Torrente> palomer: you know why all fixed point terms have self appication?
16:58:52 <palomer> so...noone have any idea?
16:59:04 <palomer> Torrente: what does this mean?
16:59:04 <Torrente> i'm thinking
16:59:04 * wagle is thinking
16:59:14 <palomer> yeah, this problem MAY be trivial
16:59:26 <palomer> the first time I saw it I was like "fixed point! fixed point!"
16:59:47 <Torrente> ?
16:59:53 <palomer> fixed point theorem
17:00:28 <palomer> given f t_1 ... t_n = g I can find f
17:00:40 <wagle> if you select the right T, I think you can make it arbitrarily difficult to find f
17:00:52 <palomer>  wagle how so?
17:00:53 <wagle> adversary type proof
17:01:22 <wagle> you provide T', adversary provides T
17:02:16 <wagle> T only normalizes for f
17:02:23 <wagle> else it diverges
17:02:37 <wagle> (or something similar)
17:03:07 <int-e> Torrente: strong normalization solves your fixed point problem. if Y f = f (Y f) that implies Y f has no normal form. Thus no lambda term for Y can be typable (which to my understanding means it contains self application)
17:03:16 <wagle> since you cant solve the halting problem, you can't tell if your current f candidate is diverging
17:03:18 <palomer> so there's a term U such that U T' = T where T only normalizes for f ?
17:03:51 <palomer> oh, I forget, f is normalizable
17:04:09 <Torrente> int-e: yea
17:04:17 <wagle> palomer: thats the assumption..  its sufficient that U f diverges for infinitely many f
17:04:20 <Torrente> int-e: this is exactly i said
17:04:31 <int-e> Torrente: I must have missed that, sorry.
17:04:41 <Torrente> int-e: really
17:05:09 <Torrente> int-e: thx
17:05:09 <palomer> who says such a U exists?
17:05:16 * wagle feels uncomfortable with his proof
17:05:46 <palomer> and why are you applying U to f?
17:05:59 <wagle> U g = if g == f, then T else _|_
17:06:19 <palomer> ok, that's fine
17:06:52 <wagle> you provide T', adversary produces U suchs that finding f such that U f = T' is undecidable
17:07:10 <palomer> so U T' only normalizes when applied to f
17:07:27 <palomer> so wait, U T' = _|_
17:07:27 <wagle> enumerable wont work if U g diverges for infinitely many g
17:07:48 <wagle> (enumeration, rather)
17:08:09 <palomer> wagle: so you're saying that the problem is not enumerable?
17:09:42 <palomer> or you're saying that enumeration won't work because T f will diverge for infinitly many f ?
17:09:46 <wagle> if the the adversary can produce U with the property that U g diverges for infinitely many g, AND you cannot determined that you have been handed a term with this property, then yes
17:09:59 * wagle cant type
17:10:07 <palomer> I thought we established that the problem is quite enumerable
17:10:15 <wagle> you claimed that
17:10:55 <palomer> the functions are enumerable
17:10:59 <palomer> so you start with f_1
17:11:04 <palomer> you see if T f_1 = T'
17:11:15 <palomer> while this is going on, you see if T f_2 = T'
17:11:25 <wagle> you produce a sequence of all terms f..  you try them out to see if ... no wait
17:11:36 <palomer> there you go!
17:11:54 <wagle> diagonization
17:12:15 <palomer> ok, how is your table built?
17:13:10 <marcot> Hello, how is the state of yi, hs-plugins and h4sh? Is there a stable release? Is it very different from the development one?
17:13:32 <wagle> the adversary looks at your sequence to find the worst case
17:14:59 <wagle> my intuition likes telling me that i'm wrong (and its right), but doesn't tell me how..
17:15:15 <wagle> its telling me that know..  i think i found it..  hold on
17:15:38 <wagle> (actually: 16:53  * wagle feels uncomfortable with his proof
17:15:51 <wagle> thinking
17:16:37 <palomer> can't we agree that it's obviously enumerable and start talking about complexity?
17:17:30 <marcot> http://cgi.cse.unsw.edu.au/~pls/cgi-bin/darcs.cgi/h4sh/Setup.hs?c=annotate
17:17:31 * wagle agrees that the moon is made of cheese
17:17:39 <marcot> Why do I see nothing? How can I see the content of the file?
17:18:07 <palomer> but seriously, if we can enumerate the functions then we can enumerate T applied to those functions and compare them to T'
17:18:31 <wagle> gawd, i'm rusty
17:19:46 <wagle> Z^2 is isomorphic to Z, but Z^Z is not..  i appear to have been confusing Z^2 with Z^Z
17:20:38 <palomer> Z^Z is obviously not isomorphic to Z^2
17:21:48 * wagle got into an argument ten years ago with someone who didnt think that obvious..  but its irrelevant. 
17:22:02 <Torrente> andddddd?
17:22:14 <palomer> Torrente: we seem not to be making progress
17:22:15 <Torrente> enumerable or not?
17:22:21 <palomer> of course it's enumerable!
17:22:22 <Torrente> lol
17:22:28 <Torrente> hahaha
17:22:31 <palomer> do you guys seriously disagree?
17:22:44 <Torrente> i'm out
17:22:47 <wagle> i was dealing with a mathematical object in my head which was Z^2, but i thought it was Z^Z
17:23:18 <wagle> seems enumerable to me now, but i'm still uncomfortable
17:23:56 <Torrente> int-e: but....
17:24:00 <palomer> ok, we can enumerate T f_i, so we do so an then we normalize
17:24:04 <Torrente> int-e: in you proof....
17:24:31 <int-e> Torrente: yes?
17:24:34 <Torrente> a lambda term dont have type iff contain self app
17:25:11 <Torrente> this implies (->) is that you need
17:25:11 <palomer> btw, is there a notion of normal form for combinatorial logic?
17:25:46 <palomer> make that combinatory
17:25:56 <Torrente> but, only <- is true
17:25:58 <Torrente> i guess
17:25:58 <Torrente> =|
17:26:35 <palomer> is reduction in CL church-rosser?
17:27:31 <Torrente> int-e: ?
17:31:05 <int-e> Torrente: well, consider a typing algorithm - which is basically a series of structural unifications.
17:32:05 <int-e> Torrente: that can only fail if a type variable is instantiated in itself I think - which one can track down to a self application on the syntactic level. That idea is rather vague.
17:32:57 <Torrente> int-e: right
17:33:01 <Torrente> int-e: thank
17:35:56 <int-e> Torrente: basically I'm trying to sidestep a syntactical definition of 'self application' by defining 'contains self application' as 'not typable', because I see no good way to do it.
17:36:20 <int-e> Torrente: err, to do it syntactically. Maybe I'm missing something obvious.
17:36:21 <Torrente> good
17:36:39 <Torrente> ok
17:37:09 <Torrente> int-e: you are student?
17:37:31 <int-e> Torrente: not anymore.
17:37:40 <Torrente> int-e: ah
17:38:19 <Torrente> int-e: I am a degree student in Computer Science
17:39:55 <int-e> Torrente: (syntactically, (x x) is a self application, but (x a x) is, too, and also (x (a x)) - this gets confusing very soon)
17:41:53 <Torrente> I see
17:53:03 <marcot_> Hum... h4sh installed thigs with wrong permission.
17:57:52 <marcot_> Where's this i from?
18:02:00 <shapr> marcot: It's your umask
18:02:35 <marcot> shapr: ok, but it's the deffault one. And in other programs I don't have this problem.
18:16:59 <Torrente> int-e: sorry but....
18:17:19 <Torrente> int-e: i have another doubt
18:17:58 <Torrente> Y f dont type
18:18:05 <Torrente> -> Y dont type?
18:18:28 <Torrente> is true, right?
18:18:52 <shapr> I wish people would publish the sources for their papers on their homepage.
18:18:58 <palomer> hrm
18:19:10 <palomer> implementing a combinatory logic evaluator isn't as trivial as one is believed to think
18:19:11 <int-e> Torrente: well for all we know x could just be a variable; then Y in Y f has exactly the same type as just Y
18:19:18 <shapr> I'm trying to type in enough of Uustalu's comonads source to make it work, but it would be easier if I didn't have to type it in at all.
18:19:22 <int-e> err, f, not x.
18:19:43 <rubenz> :q
18:19:46 <rubenz> oops
18:20:28 <Torrente> int-e: ok
18:27:45 <wagle> ^X^C
18:30:22 <thedward> any debian users around here? I'm having issues with cabal on debian
18:30:39 * wagle wishes that people would at least put enough of the source in their papers that you could replicate their results
18:31:00 <wagle> why is it always debian causing the problems
18:31:12 <wagle> (sorry, i dont know debian)
18:31:14 <thedward> heh
18:31:39 <thedward> well, do you know in the abstract how I could tell ghc to look for libs somewhere it isn't looking by default?
18:31:57 <thedward> I don't think ghc is looking for the cabal modules where debian put them
18:32:08 <wagle> find out where it is looking, then grep the sources for that
18:32:57 <thedward> so there isn't a config file or something.
18:32:58 <wagle> ptrace is the command to trace the syscalls, i think
18:33:07 <wagle> i dunno..
18:33:07 <thedward> strace
18:33:17 <wagle> ptrace is the lib..  right
18:33:35 <wagle> since i dont know, the way i'd find out is what i said
18:33:38 <thedward> well, I know I can give it an import path with -i, but that seems to replace the default instead of adding to it
18:34:00 <wagle> then you might even find the skeleton of the default config file
18:34:58 <wagle> hmm..  i saw a variation that appended instead of replaced.. check the docs
18:35:18 <thedward> ah. wait, no that worked, but now I am missing something else. sigh.
18:35:20 <wagle> could be something like +i or -i+, or...
18:35:24 <Lemmih> thedward: Did you register Cabal?
18:36:17 <thedward> Lemmih: I didn't do so explicitly ... that isn't done by the debian package?
18:36:25 <thedward> how would I do that explicitly
18:36:48 <Lemmih> I've never installed Cabal via a debian package.
18:36:56 <Lemmih> Does 'ghc-pkg list' show the new Cabal?
18:37:28 <thedward> ghc-pkg -l does
18:37:59 <Lemmih> Oh, you're using GHC 6.2 /-:
18:38:29 <thedward> (though what I am actually having a problem with is Distribution.Simple.LocalBuildInfo , which appears to come in the cabal package )
18:38:36 <thedward> too new or too old?
18:39:15 <Lemmih> It's pretty old. Although it should be supported.
18:40:21 <wagle> is it too old if it wasnt built from today's CVS?
18:40:46 <rep> nvi sucks for writing haskell
18:40:50 <rep> you really have to use emacs
18:41:01 <wagle> hmm:  Version 6.2 (released 16 Dec 2003)
18:41:18 <thedward> oh. I think I see. it is registering Cabal but not Distribution
18:41:21 <thedward> silly
18:42:28 <thedward> are there any apt sources for more recent versions?
18:42:54 <wagle> All these platforms have ghc packages in unstable in the main Debian archive ...
18:43:04 <wagle> </quote>
18:43:15 <palomer> does anyone really use the variability of  operator precedence
18:43:16 <palomer> ?
18:43:20 <wagle> @google ghc debian 6.4
18:43:37 <wagle> "variability"?
18:43:40 <rep> httpd: setNonBlockingFD: invalid argument (Bad file descriptor)
18:43:43 <rep> w h y
18:43:46 <palomer> the fact that you can change operator precedence
18:44:26 <wagle> people who both hate parens and like using lots of symbolic operators
18:44:50 <wagle> rep: where was that?
18:46:05 <wagle> palomer: i've seen people give talks and show some REALLY bizarre haskell code using that sort of thing..  (and watch the OO guys go "WTF?!?!")
18:46:20 * int-e wonders what happens to a socket fd if one side disconnects.
18:46:30 <wagle> int-e: depends
18:46:57 <int-e> (thinking about rep's problem)
18:47:54 <wagle> i think i've seen rep's problem in faq's talking about windows
18:48:18 <wagle> (except for the httpd part)
18:48:45 <int-e> the httpd is his own code from what I gathered
18:49:07 <int-e> i.e. he wrote an http demon in haskell
18:49:33 <wagle> heh: http://craffe.se/irc.jpg
18:50:24 <wagle> there is the usual C style that doesnt check every single lib call for errors,..
18:50:44 <palomer> would it be possible to write a function that returns a random element of any datatype if that datatype?
18:50:58 <wagle> fd = open(...) ; ioctl(fd, ...) ; etc
18:51:15 <wagle> "if"?
18:51:35 <wagle> there's a random number monad, i hear
18:52:43 <int-e> wagle if? if is for weenies.
18:52:52 <int-e> wagle: real unix hackers die on errors.
18:53:34 * wagle couldnt successfully parse palomer's question
18:53:39 <int-e> with a descriptive error message ("Segmentation fault. Core dumped.") and a core dump.
18:53:42 <palomer> ok, for example:
18:53:54 <int-e> wagle: 'if' -> 'of'
18:54:11 <palomer> say you have a datatype with two constructors: K, S and APP
18:54:16 <palomer> this is for the CL datatype
18:54:21 <palomer> and APP takes two CL terms
18:54:33 <wagle> you might be able to do that in template haskell
18:54:33 <palomer> you want to generate random CL terms
18:54:35 <int-e> data CL = K | S | APP CL CL
18:54:40 <palomer> yeah, sure
18:55:03 <palomer> data NUM = ZERO | SUCC NUM
18:55:06 <palomer> there's another datatype
18:55:12 <wagle> it might have enough reflection to find out what the constructors are AND be able to use them in expressions
18:55:19 <palomer> now the code to generato random NUMs or random CL's is _very_ similar
18:55:22 <palomer> almost identical
18:55:40 <palomer> in fact, to generate random elements of any datatype is quite trivial and similar
18:56:01 <rep> yay
18:56:14 <int-e> palomer: hmm, generate a random member of ... uh ... (Int -> Int) -> Int.
18:56:16 <wagle> i'm assuming that you want a single polymorphic function that does this
18:56:37 <palomer> int-e: what's the datatype?
18:56:50 <int-e> palomer: (Int -> Int) -> Int is a type in Haskell.
18:57:09 <palomer> by datatype I mean a set of constructors
18:57:12 <int-e> data Foo = Foo ((Int -> Int) -> Int) if you want
18:57:26 <palomer> oh, righto
18:57:48 <palomer> lemme rephrase: if that datatype does not contain constructors with functions as parameters
18:58:46 <wagle> its just goedelization, i think
18:59:41 <rep> so i was able to make my goddamned httpd use sendfile(2)
19:00:39 <int-e> palomer: There are several problems I see. 1) random numbers do not work well in a functional context (a random number monad can do it though) 2) the types that you consider are quite restricted 3) which of the many possible distributions of your (infinitely many in the interesting cases) members of the ADT do you want?
19:01:24 <palomer> I want all members of my ADT to possibly show up
19:01:45 <wagle> some of the unit testing frameworks for haskell cover this sort of thing
19:02:14 <wagle> (i've only heard people give talks about them)
19:02:42 <wagle> i think they even found a way to sort of generate random functions
19:03:08 <palomer> that's _awesome_
19:03:12 <palomer> wait, that's easy
19:03:20 <palomer> >:O
19:03:29 <palomer> just have an ADT representing functions
19:03:37 <int-e> a generic 'fold' function would also be fun. (for CL: fold s k app S = s; fold s k app K = k; fold s k app (APP x y) = app (fold s k app x) (fold s k app y))
19:05:08 <rep> when should one use unsafePerformIO?
19:05:18 <wagle> rep: never
19:05:28 <wagle> not that that stops anyone..  8)
19:05:31 <int-e> (if you have to ask, don't use it)
19:05:38 <wagle> int-e: haha
19:05:38 <rep> wagle so why is it there?
19:05:49 <int-e> because it's useful.
19:05:54 <int-e> people want it
19:06:02 <wagle> rep: to allow tricky programming in library functions, i believe
19:06:11 <int-e> and in some cases one can even use it safely
19:06:12 <shapr> Because the ivory tower academic bit is pure fiction ;-)
19:06:27 <rep> it seems that i have to use it
19:06:31 <rep> and i have no idea why
19:06:39 <rep> if i don't use it, my program crashes
19:06:45 <wagle> why do you need to use it?
19:06:51 <rep> no clue
19:06:57 <int-e> (unsafePerformIO $ print "I was here") `seq` some computation or other
19:06:57 <rep> do c_sendfile fd1 fd2 (fromIntegral 0) (fromIntegral 7020) nullP
19:06:57 <rep> tr nullPtr (fromIntegral 0)
19:06:57 <rep>                    closeFd fd1
19:06:57 <rep>                    return $ unsafePerformIO $ closeFd fd2
19:07:14 <int-e> uh
19:07:24 <int-e> do x <- closeFd fd2
19:07:27 <int-e>    return x
19:07:30 <int-e> doesn't do it?
19:08:16 <wagle> is c_sendfile unsafe?
19:08:21 <rep> wagle yes
19:08:28 <rep> int-e no
19:08:28 <wagle> thats why then
19:08:36 * int-e doesn't get it.
19:08:42 <rep> wagle why?
19:08:56 <wagle> you should have it return a IO command that performs the operation
19:09:14 <rep> have c_sendfile return a IO command?
19:09:24 <rep> but it's a foreign function
19:09:54 <wagle> print "foo" returns a value of type IO () that when the second IO pass goes over it, causes the stuff to actually happen
19:10:16 <wagle> rep: yeah, i expected it to be a foreign function, hence my question
19:10:51 <wagle> you should look out how print, etc. are implemented, and do it in a similar way
19:11:02 <wagle> (i havent looked)
19:11:26 <rep> hm ok
19:12:39 <wagle> so by making c_sendfile unsafe, you were making it occur before the print..  it you wrap print in unsafePerformIO, you cause it to happen immediately..  huh.. now (finally) _I_ understand unsafePerformIO..  cool
19:13:07 <rep> heh
19:13:24 <wagle> when the toplevel sees a value of type IO t, it "runs" it or something
19:14:09 <wagle> "unsafePerformIO happens at IO value construction time"
19:14:22 <rep> i see
19:14:23 <wagle> "normal IO happens at IO value run time"
19:15:04 <wagle> the structure of the IO a value fully determines the order of the operations when it is "run"
19:15:56 <wagle> but lazy evaluation makes it especially different to predict the order of evalution when you are constructing the IO a value
19:16:09 <wagle> s/different/difficult/
19:17:31 <int-e> so it's completely unclear when rep's closeFd fd2 is executed - and for that matter, if it's ever executed.
19:17:45 <int-e> (at least from that fragment)
19:18:37 <wagle> yeah, the IO a value will be completely run
19:18:48 <wagle> (IO a)
19:19:24 <int-e> (and in fact the compiler might even produce code that evaluates closeFd fd2 twice ... I don't expect it does, but it could)
19:19:49 <wagle> why should it do that?
19:20:37 <int-e> wagle: I don't know, but it's certainly allowed to evaluate the same expression arising from the same context twice
19:21:26 <wagle> yes, but it evaluates it to an IO () value that when (later) _run_ performs the close operation
19:21:53 <wagle> and it will be run only once
19:22:13 <wagle> (i'm not sure that "run" is the right word)
19:22:30 <int-e> unsafePerformIO does the 'running'
19:22:50 <wagle> yeah
19:23:51 <int-e> and that will be evaluated whenever the return value of the big do statement is used - which might be never, or once, or twice (but lazy evaluation means the unsafePerformIO will most likely happen only once even in this case).
19:24:02 <wagle> huh..  toplevel might do something like  x <- eval expr; if (typeof x) unifies_with (IO a) them unsafePerformIO x
19:24:43 * int-e isn't sure he's talking about the same issue that wagle is talking about.
19:25:51 <int-e> wagle: what do you mean with 'toplevel'?
19:25:58 <wagle> i imagine that unsafePerformIO takes a value of type (IO a), runs it, and returns (return a)
19:26:41 <int-e> yes. it does that, at the time that the unsafePerformIO term is evaluated.
19:27:07 <wagle> ah.. for an interpreter, toplevel is the prompt that takes and expression and evaluates it
19:27:07 <int-e> well, it returns, not a, but the result value of the closeFd operation
19:27:14 <wagle> compiler is a little different
19:28:15 <wagle> yeah... i wasnt going to get that detailed, but neglected to make that decision obvious
19:29:01 <rep> would seq help me avoid the unsafePerformIO here?
19:29:10 <wagle> no
19:29:11 <rep> or something similar
19:29:17 <int-e> rep: when do you want that closeFd to happen?!
19:29:33 <wagle> you need to fix c_sendfile
19:29:34 <rep> int-e anytime after c_sendfile
19:30:01 <int-e> rep then just take out the return $ unsafePerformIO $ part.
19:30:24 <wagle> it should not perform the operation, it should return a value in IO a that, when "run" performs the operation
19:30:25 <int-e> hmm - or what monad are you working in?
19:30:33 <rep> IO
19:31:03 <int-e> well, then what I said should work.
19:31:19 <wagle> using unsafePerformIO is a hack in this situation
19:31:30 <wagle> c_sendfile is misdesigned
19:31:35 <int-e> do c_sendfile ...; closeFd fd1; closeFd fd2
19:31:43 <rep> int-e that doesn't work
19:31:48 <wagle> learn to do it right unless you are on a tight deadline or something
19:31:52 <int-e> rep: how so?
19:31:57 <rep> wagle well, c_sendfile is just sendfile(2) :)
19:32:10 <rep> no deadline
19:32:37 <wagle> yeah..  look at how the print, close, etc commands are implemented..
19:33:24 <wagle> they will return a IO value that is something like a wrapped function pointer to the actual operation
19:33:49 <int-e> rep: the task of the IO Monad is to make sure that if two operations in the monad are sequenced with >>=, they are executed in that sequence. so the closeFd will happen after the c_sendfile
19:33:57 <wagle> (i dont really know how the IO monad is implemented, but i understand the design and behavior)
19:34:39 <wagle> int-e: as currently implemented, c_sendfile is not an IO operation
19:35:02 <int-e> wagle: how can it even be used like above in a do statement?!
19:35:06 <rep>  c_sendfile :: Fd -> Fd -> COff -> CSize -> Ptr a -> Ptr COff -> CInt -> IO CIn
19:35:09 <rep> t
19:35:09 <wagle> .. so >>= does not sequence it
19:35:33 <int-e> wagle: see rep's quote - it's an IO operation
19:35:38 <rep> doesn't the IO CInt return value mean that it is an IO operation?
19:35:56 <wagle> "return 1 :: IO Int" does not make 1 an IO operation
19:36:13 <int-e> rep: so explain again in what way it fails to work if you do not do that unsafePerformIO hack?
19:36:32 <int-e> rep: which most likely just has the effect that the fd is *never* closed anyway.
19:36:59 <wagle> c_sendfile does something like "return x" to return a value in the IO monad, but it is _not_ returning an IO _operation_
19:37:12 <rep> int-e httpd: setNonBlockingFD: invalid argument (Bad file descriptor)
19:37:21 <wagle> rep: int-e is wrong
19:37:26 <rep> wagle ok :)
19:37:45 <rep> hm
19:38:14 <rep> i'm loooking at how closeFd is implemented
19:38:22 <Lemmih> c_sendfile is just a foreign import, right?
19:38:27 <rep> and all it does is call c_close
19:38:35 <rep> which is:
19:38:35 <rep> foreign import ccall unsafe "close"
19:38:36 <rep>   c_close :: CInt -> IO CInt
19:38:39 <wagle> unsafePerformIO performs IO operations in the evaluation order, not the IO >>= sequencing order
19:38:39 <rep> Lemmih yes
19:38:57 <rep> anyway, this is exactly the same as i'm doing
19:39:06 <Lemmih> rep: Got any other unsafe* calls in the code?
19:39:09 <rep> (unless i'm missing something)
19:39:11 <rep> Lemmih no
19:39:27 <wagle> c_sendfile is itself a kind of unsafePerformIO..
19:39:38 <Lemmih> rep: You use the fd after closing it?
19:39:45 <rep> Lemmih no
19:39:52 <wagle> which is why you have to wrap everything else in unsafePerformIO
19:40:33 <int-e> wagle: when do you think that unsafePerformIO is evaluated?
19:40:57 <wagle> when the IO value is being constructed
19:41:01 <Lemmih> rep: Do you know where and when setNonBlockingFD is being called?
19:41:11 <wagle> the "toplevel" RUNS IO values
19:41:17 <rep> Lemmih my guess is during openFd
19:41:35 <rep>           fd1 <- openFd name ReadOnly Nothing defaultFileFlags
19:41:35 <wagle> the IO monad is a kind of hack that way
19:41:55 <Lemmih> rep: Could you paste a minimal error case somewhere?
19:42:20 <int-e> wagle: it won't. it will be executed only *if* the return value of that IO operation is ever used anywhere.
19:42:39 <wagle> Lemmih: he is directly calling the sendfile system call, so its unsafe
19:43:01 <Lemmih> wagle: Define 'unsafe'.
19:43:04 <rep> Lemmih ok, just a minute
19:44:19 <wagle> the operations in values of the IO monad do not start happening until the toplevel receives a value of type (IO a), which is then starts "run"ning
19:44:44 <wagle> unsafeIO happens BEFORE that "run" probes it
19:44:57 <Lemmih> The toplevel? as in GHCi? What does GHCi has to do with anything?
19:45:12 <wagle> read the IO monad implementation notes
19:45:13 <Lemmih> wagle: He said he didn't use unsafePerformIO.
19:45:37 <wagle> Lemmih: no, he said he was _forced_ to use unsagePerformIO
19:46:13 <Lemmih> I just asked him if he had any calls to unsafe* in his code. He said 'no'.
19:46:17 <int-e> wagle: compare  print "foo1" >> return (System.IO.Unsafe.unsafePerformIO $ print "foo2"), print "foo1" >> return (System.IO.Unsafe.unsafePerformIO $ print "foo2") >>= \x -> print "blah" and print "foo1" >> return (System.IO.Unsafe.unsafePerformIO $ print "foo2") >>= \x -> case x of () -> print "blah"
19:46:52 * wagle IS speaking "ex Cathedra"
19:47:17 <wagle> i have said the correct thing several times.
19:47:35 <wagle> int-e does not understand what is happening here
19:47:51 <wagle> and now i have nothing more to say that is not repeating myself
19:48:10 <wagle> follow int-e 's advice, and learn to create unpleasant hacks
19:48:49 <int-e> what? I want to get rid of the unsafePerformIO altogether.
19:51:25 <rep> Lemmih http://people.freebsd.org/~ssouhlal/stuff/blah.hs
19:51:27 <Lemmih> rep: You did remove all references to unsafePerformIO, right?
19:51:45 <rep> Lemmih it doesn't crash, but it gives me a lot of blah: closeFd: invalid argument (Bad file descriptor)
19:52:18 <int-e> wagle: I missed where you said that c_sendfile is essentially a return though, sorry. That explains the behaviour and has indeed to be fixed.
19:53:01 <wagle> int-e: thanks, that explains the confusion
19:53:51 * wagle got really curious, and is presently hunting down ghc's implementation of the write syscall
19:54:12 <rep> Lemmih (if i do "return $ unsafePerformIO $ closeFd fd2", it doesn't give me those errors)
19:55:55 <Lemmih> rep: That's pretty much the same as '-- closeFS fd2'.
19:56:14 <rep> Lemmih then why isn't it running out of file descriptors?
19:58:09 <int-e> rep: out of curiosity: if you do 'return $ unsafePerformIO $ (putStrLn ("closing "++show fd2) >> closeFd fd2)' there, does it print anything? because I'd really expect it not to.
19:58:43 <Lemmih> rep: They'll most likely get garbage collected.
19:59:45 <rep> int-e it does
20:00:07 <rep> blah: setNonBlockingFD: invalid argument (Bad file descriptor)
20:00:14 <rep> but crashes
20:02:45 <rep> funny, if i remove both closeFd fd1 and closeFd fd2, it runs out of file descriptors
20:02:54 <rep> if i only remove closeFd fd2, it doesn't
20:07:42 * rep has no idea what's going on
20:11:43 <Lemmih> sendfile gotta be different on FreeBSD compared to Linux, right?
20:11:47 <rep> yes
20:11:50 <rep> i guess
20:11:59 <rep>      int
20:11:59 <rep>      sendfile(int fd, int s, off_t offset, size_t nbytes,
20:12:00 <rep>          struct sf_hdtr *hdtr, off_t *sbytes, int flags);
20:12:03 <Lemmih> ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
20:12:20 <rep> ok, just remove the Ptrs
20:12:27 <Lemmih> ^^ Flipped in/out fds. only four arguments.
20:12:34 <rep> right
20:12:45 <Lemmih> It works perfectly on my box.
20:13:03 <rep> freebsd sucks :(
20:13:53 * Lemmih still doesn't get wagle's arguments.
20:15:38 <int-e> oh my, how many openFd are there?!
20:18:39 <Lemmih> wagle: Around?
20:19:35 <marcot> Doens't gtk2hs libglade support read the signals in the .glade file?
20:20:05 <rep> wait!
20:22:14 <Lemmih> what?
20:24:08 <rep> i wonder if it could be that sendfile files
20:24:32 <rep> and something weird happens
20:24:34 <rep> hm
20:30:03 <rep> blah: sendfile: resource vanished (Broken pipe)
20:30:04 <rep> blah: closeFd: invalid argument (Bad file descriptor)
20:30:58 <int-e> intriguing
20:32:00 <Lemmih> rep: Maybe you should try the sendFd function from Network.Socket.
20:32:33 <Lemmih> Oh wait. That's totally different.
20:33:49 <int-e> rep: hmm, what happens if you leave out the c_sendfile completely?
20:38:37 <rep>  Warning: Pattern match(es) are overlapped
20:38:38 <rep>              In a case alternative:
20:38:38 <rep>                  ePIPE -> ...
20:38:38 <rep>                  otherwise -> ...
20:38:41 <rep> what does this mean?
20:39:54 <Lemmih> Are you familiar with pattern matching?
20:39:58 <rep> yes
20:40:13 <rep> but it's the first time i see this
20:40:16 <Lemmih> "case () of a -> ()" is the same as "case () of otherwise -> ()".
20:41:23 <rep> i think i'm just too tired
20:41:25 <rep> 5:30am
20:41:25 <Lemmih> 'ePIPE' and 'otherwise' will both successfully match everything.
20:41:51 <rep> hm why should ePIPE match everything
20:42:11 <Lemmih> Where are you from? (I'm also in GMT+1)
20:42:17 <rep> italy
20:42:34 <int-e> it's GMT+2 :)
20:42:43 <Lemmih> Same reason 'a' matches everything.
20:43:05 <int-e> ePIPE is a variable.
20:43:15 <rep> oh
20:43:23 * Lemmih is haunted by off-by-one errors. (:
20:43:31 <rep> duh
21:03:17 <int-e> @type catchException
21:06:54 <thelsdj> how can i access the numeric ascii of a Char? like if i just want to do something like: if somechar == 0xFF
21:07:13 <rep> ord
21:07:19 <int-e> fromEnum
21:07:19 <rep> ord 'a'
21:07:25 * int-e has a deja vu.
21:07:56 <int-e> (both work)
21:08:29 <int-e> rep: which ghc version are you using?
21:08:45 <rep> 6.4
21:09:40 <thelsdj> and do I need to worry about what encoding i'm running in for that? is Char always 8 bit or do i need to take other encodings into default and if so how can i force reading 8 bits from a file? (are there other file reading methods besides the char/line/entire file in IO? (guess i need to go looking for full list))
21:11:08 * int-e finds that the implementation of sockets, file decriptors, handles and some other stuff around it are quit complicated.
21:11:19 * rep goes to bed
21:11:40 <Lemmih> thelsdj: There's System.IO.hGetBuf
21:12:28 <int-e> sleep well rep
21:12:42 <rep> hopefully i won't dream of sendfile :)
21:13:09 <Lemmih> 'night, rep.
21:13:13 <rep> night
21:19:49 <thelsdj> arg i got disconnected, did the channel get my 2 messages and did anyone respond? heh
21:39:43 <Lemmih> thelsdj: There's System.IO.hGetBuf
21:53:36 <thelsdj> Lemmih: hmm? i don't see that
21:54:59 <Lemmih> Prelude> :t System.IO.hGetBuf
21:54:59 <Lemmih> System.IO.hGetBuf :: GHC.IOBase.Handle
21:54:59 <Lemmih>                      -> GHC.Ptr.Ptr a
21:54:59 <Lemmih>                      -> Int
21:54:59 <Lemmih>                      -> IO Int
21:59:49 <thelsdj> ah there we go, in ghc but not hugs
22:01:41 <Lemmih> System.IO> :t hGetBuf
22:01:41 <Lemmih> hGetBuf :: Handle -> Ptr a -> Int -> IO Int
22:01:45 <Lemmih> ^^ In Hugs.
22:05:01 <thelsdj> very weird, definatly not seeing it in mine, wonder if mine is old or missing stuff or something
22:06:08 <Lemmih> Type ':l System.IO', followed by ':t hGetBuf'.
22:07:11 <thelsdj> definatly not there, grabbing new release, mine does seem old
22:18:09 <dons> morning
22:18:47 <Lemmih> Hi dons.
22:19:09 <dons> hey Lemmih
22:21:07 * Lemmih is working on a 6.4 -> 6.5 ModIface converter.
22:21:51 <palomer> damnit, CL reductions aren't that easy:O
22:23:10 <palomer> how would you guys implement a CL evaluator?
22:23:14 <palomer> the two rules are:
22:23:17 <palomer> Kxy = x
22:23:24 <palomer> Sxyz = yz (xz)
22:23:32 <palomer> and I want to use left most reductions
22:24:28 <palomer> (my terms are of the form K@K@S
22:25:41 <palomer> which would evaluate to K
22:39:53 <Cale> palomer: encode the terms in a type and write a function which performs a reduction step
22:41:50 <palomer> yeah
22:41:53 <palomer> that's what I'm doing
22:42:10 <palomer> (I'm doing this in sml, which is why I'm reticent to paste my code:P)
22:50:40 <palomer> wow I love generating random programs
22:50:42 <palomer> so much fun:O!
23:04:57 <gour> morning #haskell
23:07:34 <orbitz> afternoon
23:07:40 <gour> :-)
23:37:17 <palomer> is there a function in ghc to run a function for a certain period of time, and stop computation if it hasn't finished?
23:44:34 <TheHunter> You can check out timeout in lambdabot's Util.hs.
23:44:36 <TheHunter> @version
23:45:27 <TheHunter> http://www.cse.unsw.edu.au/~dons/lambdabot/Util.hs
