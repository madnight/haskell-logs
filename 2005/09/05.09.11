00:15:54 <Cale> luqui: it's called a bifunctor
00:22:34 <ski> Cale,(luqui) : i thought the bifunctor map was more like  bimap :: (a -> b) -> (c -> d) -> (f a c -> f b d)
00:24:10 <ski> if f is a monad, then fmap2 is liftM2
00:24:23 <ski> @type Control.Monad.liftM2
00:24:24 <lambdabot> forall r (m :: * -> *) a2 a1.
00:24:24 <lambdabot> (Monad m) =>
00:24:24 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:25:34 <ski> hm .. possibly with Conor McBride's Idiom class (which is weaker than monad) we can also make such a function
00:26:19 <Cale> oh, sorry
00:26:38 <ski> class Idiom t where {k :: a -> t a; s :: t (a -> b) -> (t a -> t b)}
00:27:16 <Cale> yeah, a bifunctor would take two type parameters
00:27:56 <ski> fmap2 :: Idiom t => (a -> b -> c) -> (t a -> t b -> t c); fmap2 f ta tb = k f `s` ta `s` tb
00:32:50 <araujo> hello haskell'ers
00:45:00 <luqui> ski, thanks, I'll look at Idiom
00:45:25 <luqui> also there was the example that zipWith and liftM2 both do that to a list, but they do different things
00:45:41 <luqui> so it's not really a property of the structure
00:45:58 <luqui> I solved the problem by making "class Zippable"
00:46:05 <luqui> and then doing an fmap over that
00:46:51 <ski> some info on http://lambda-the-ultimate.org/taxonomy/node/or/28
00:47:36 <ski> aha, you want to zip the structures ?
00:48:04 <luqui> no, but that is the half-way point to well-defining what I want
00:48:47 <luqui> I basically want to generalize this:   foo (+) [1,2,3] [4,5,6] == [5,7,9]
00:49:07 <luqui> to arbitrary functoresque structures
00:50:02 <ski> (btw, monads are idioms by k = return and s = ap)
00:50:22 <ski> yes .. seems like zipping, to me
00:51:26 <Cale> there's some generics stuff that does that, although I'm not sure that's really what you're looking for
00:51:43 <luqui> probably not
00:51:53 <araujo> There exist a function to match substrings?
00:52:26 <ski> luqui : foo (+) (Node 1 (Node 2 Nil Nil) (Node 3 Nil Nil)) (Node 4 (Node 5 Nil Nil) (Node 6 Nil Nil)) = Node 5 (Node 7 Nil Nil) (Node 9 Nil Nil) ?
00:53:24 <luqui> yeppers
00:53:25 <ski> luqui : how about the part of the structures which doesn't match ?  just skip them (like zip for lists, in haskell) ?
00:53:34 <luqui> no, expand items to match
00:53:40 <ski> mhm ?
00:54:14 <luqui> hmm, can't quite think how it would do it for a tree
00:54:22 <ski> foo (+) (Node 1 (Node 2 Nil Nil) Nil) (Node 3 Nil (Node 4 Nil Nil)) = ?
00:54:50 <luqui> I'm working with a data structure deep list:  data DeepList a = DeepList [DeepList a] | DeepItem a
00:55:08 <int-e> luqui, the problem occurs for lists already - zip (+) [0] [42,23] ==> [32]
00:55:11 <ski> hm .. one possible way of doing zip-like things on trees .. is to return something of a new datatype
00:55:43 <xerox> @plugs zip (+) [0] [42,23]
00:55:45 <lambdabot> 18:
00:55:45 <lambdabot>   The function `zip' is applied to three arguments,
00:55:45 <lambdabot>   but its type `[a] -> [b] -> [(a, b)]' has only two
00:55:45 <luqui> foo (+) (DeepItem 3) (DeepList [DeepItem 4, DeepItem 5]) == DeepList [DeepItem 7, DeepItem 8]
00:55:54 <xerox> @plugs zipWith (+) [0] [42,23]
00:55:56 <lambdabot> [42]
00:56:12 <int-e> err, sorry.
00:56:24 <xerox> np, just wondering :)
00:56:37 <luqui> int-e, yeah
00:58:42 <ski> e.g.  newtype Fix f = In {out :: f (Fix f)}; data IntTreeF r = Nil | Node Int r r; type IntTree = Fix IntTreeF; data Zip f = Match (f (Zip f)) | MisMatch (Fix f) (Fix f); zipTree :: (Int -> Int -> Int) -> IntTree -> IntTree -> Zip IntTreeF
00:58:48 <ski> something like that ..
00:59:31 * luqui completely didn't follow that, but thinks he knows what you are saying
00:59:52 <luqui> return a new data type that can show unification conflicts
01:00:20 <ski> basically, zip the matching parts, and store both the mismatching parts when mismatch occurs
01:00:43 <luqui> that's an interesting idea.  Not exactly what I'm after though
01:00:58 <luqui> in fact, as long as it works for DeepList in an elegant way, I don't much care what it does
01:01:16 <luqui> :-/
01:03:28 <ski> so   zipTree (+) (In $ Node 1 (In $ Node 2 (In Nil) (In Nil)) (In Nil)) (In $ Node 3 (In Nil) (In $ Node 4 (In Nil) (In Nil))) = Matched $ Node 4 (Mismatch (In $ Node 2 (In Nil) (In Nil)) (In Nil)) (Mismatch (In Nil) (In $ Node 4 (In Nil) (In Nil)))
01:03:43 <ski> luqui : ok
01:09:22 <int-e> ski: that should be type IntTree = Fix (IntTreeF IntTree), right?
01:12:45 <ski> nope
01:13:18 <ski> the point was the untangle the recursion (so only Fix does recursion)
01:13:48 <ski> this results in Zip being able to insert it's constructors between the constructors in the tree
01:14:36 <ski> see http://www.haskell.org/hawiki/IndirectComposite
01:14:57 <luqui> http://svn.luqui.org/svn/misc/luke/work/code/haskell/hyper.hs  # my eventual solution, for the interested
01:15:51 <ski> here  IntTreeF :: * -> *   Fix :: (* -> *) -> *  IntTree = Fix IntTreeF :: *  Zip :: (* -> *) -> *  Zip IntTreeF :: *
01:17:02 <ski> luqui : hm, interesting
01:17:55 <ski> so, sort of, DI x abbreviates DL [DI x,DI x,...]
01:18:08 <luqui> yeah
01:18:52 <luqui> it's to formalize an autoparallelizable notion; i.e.    3 + [4,5,6]
01:19:04 <luqui> (for, you guessed it, perl 6:  3 +<< [4,5,6])
01:19:22 <ski> hm
01:19:33 <ski> that maps (+3), yes ?
01:19:48 <luqui> yeah
01:19:48 <xerox> That<Interrupted by ski>
01:20:00 <int-e> ski: thanks
01:20:06 <int-e> ski: I see it now.
01:20:14 <ski> (hm, possibly one could see this like automatic lifting of rank for tensors .. ?)
01:20:51 <luqui> hmmmmmm... yeah, I suppose so.  Except the tensors don't have to be rectangular.
01:20:57 <ski> m, right
01:21:14 * luqui now wants to write a Tensor that implements these
01:21:45 <ski> (wasn't sure if you wanted to use irregular such, or not)
01:22:03 <ski> write a tensor that implements these ?
01:22:08 <luqui> fzip
01:22:23 * luqui has always wanted to write a tensor class
01:22:29 <xerox> ski, is there a brief explanation of what a tensor is?
01:22:38 <ski> ah, a tensor class ..
01:22:48 <ski> xerox : well, it's a math concept ..
01:22:56 <luqui> generalization of a matrix
01:23:05 <ski> (and i've not up-to-date on the details)
01:23:09 <luqui> ... well, a multilinear operator ...
01:23:17 <luqui> they keep changing the definition
01:23:22 <ski> more or less an n-dimensional matrix (with n = dimension/rank)
01:24:08 * ski thought he saw somewhere distinguishing between "covariant" and "contravariant" dimensions
01:24:20 <luqui> uh huh.
01:24:32 * luqui has never really understood that, but it has to do with einstein notation
01:27:00 <astrolabe> An n by n matrix could represent a linear map from a vector space to itself (V->V) or a bi-linear product on the space (VxV -> R)
01:27:48 <astrolabe> They transform differently when you change co-ordanates.
01:28:41 <astrolabe> Because they have different covariant and contravariant ranks.
01:31:01 <ski> hm  .. seems to make sense, somehow
01:31:24 <basti_> is that a chirality issue?
01:31:42 <astrolabe> No, not really chirality.
01:33:12 <astrolabe> Maybe there is a haskell tensor library about somewhere?
01:33:40 <basti_> i found a reference page. the examples section is empty though
01:33:55 <basti_> http://www.absoluteastronomy.com/encyclopedia/c/co/covariant_transformation.htm
01:34:11 <xerox> OK, covariant, contravariant... please provide a glossary :-D
01:34:34 <basti_> a covariant is a transform with special properties, and a contravariant is its inverse
01:34:46 <xerox> ...and a transform?
01:34:51 <basti_> has to do with expressing a basis in terms of another basis
01:35:03 <basti_> thats a term thats about as specific as "object" ;)
01:35:29 <basti_> a transform is a mapping between function spaces i think.
01:35:37 <xerox> Oh, CT?
01:35:50 <basti_> Computer Tomography?
01:36:00 <xerox> Category Theory
01:36:08 <basti_> ;)
01:36:15 <basti_> hmm not only there
01:37:06 <basti_> in CT these things are homomorphisms
01:37:13 <xerox> a -> a ?
01:37:19 <xerox> No that was another thing.
01:37:27 <basti_> that could be a special case of some transformation
01:37:27 <basti_> a->b
01:37:28 * xerox always messes up with names
01:37:28 <basti_> ;)
01:37:48 <xerox> It was a ... co[something] ?
01:38:05 <basti_> i dont think so no.
01:38:29 <basti_> i don't fully understand the exact definition of "covariant" anyway, so its only guesswork anyway
01:38:56 <basti_> basically you have two bases, and then you express the base elements of the one in terms of base elements of the other
01:39:36 <basti_> for example, you can express discrete functions as sums of shifted dirac pulses
01:39:52 <basti_> now you can express shifted dirac pulses as fourier transformed shifted dirac pulses too
01:40:17 * ski wonders if it can be seen as an instance of the CT concept of covariant functor
01:40:35 * xerox wonders if he ever understand something of this buzzwords madness.
01:40:48 <xerox> ...with all the respect... :-)
01:40:50 <basti_> afaics, a function mapping the discrete dp construction to the ft construction would be a covariant
01:41:09 <basti_> the worst buzzword in there is "base" i think
01:41:22 <basti_> the rest is DSP stuff ;)
01:42:41 <xerox> @expand DSP
01:42:42 <lambdabot> Unknown command, try @listcommands.
01:42:49 <basti_> digital sound processing
01:49:42 <gour> dcoutts: hi duncan
01:49:48 <dcoutts> hi gour
01:50:02 <gour> the darcs mirror is just updated :-)
01:50:20 <dcoutts> oh yes so it did
01:50:28 <gour> few mins ago
01:50:35 <dcoutts> I pulled 5 min ago and didn't get the updated I expected
01:50:46 <gour> check the time ;)
01:50:47 <dcoutts> but now it's there :-)
01:51:14 <gour> so we can just make a cronjob as gtk2hs user
01:51:22 <gour> to do: darcs pull -v
01:51:31 <gour> from 'my' repo
01:51:43 <gour> what do u think?
01:52:13 <gour> i chmod-ed darcs repo with g+x
01:52:19 <gour> err. g+w
01:52:53 <luqui> basti_, sounds like wavelets
01:53:13 <basti_> luqui: it does?
01:53:27 <luqui> from the little I know of wavelets, yeah, it sounds like that domain
01:53:32 <luqui> but it might be a lot more general than that
01:53:37 <basti_> luqui: uhm, no.
01:53:50 <luqui> okay...
01:53:52 <luqui> fine
01:53:55 <dcoutts> gour, ok, or just change your script to use the other location for the repo
01:53:56 <basti_> its just a mapping between two bases. none of that is the wavelet base
01:54:13 <dcoutts> gour, wouldn't that be easier?
01:54:16 <basti_> or "any" wavelet base
01:54:19 <luqui> alright.  shows how much I know about wavelets :-)
01:54:37 <gour> dcoutts, to change location of the repo?
01:55:44 <dcoutts> gour, so your script updates the repo at gtk2hs/darcs/ rather than the one in your public_html dir
01:56:15 <gour> dcoutts, no script updates repo in ~/public_html
01:56:37 <gour> gtk2hs/darcs is created by 'darcs get' from that repo
01:56:44 <dcoutts> gour, right, ans I'm suggesting we change it to update the other repo
01:57:05 <dcoutts> then we don't need extra script/cronjob to sync the two darcs repos
01:57:25 <gour> ok, so i'll create a new repo under gtk2hs/darcs
01:57:36 <dcoutts> I guess so
01:57:55 <gour> is gtk2hs/darcs/gtk2hs proper name?
01:58:24 <dcoutts> yes, or you could use gtk2hs/repo/gtk2hs
01:58:37 <dcoutts> gtk2hs/darcs/gtk2hs is probably better
01:58:47 <gour> ok, i'm going to do
01:58:55 <gour> will report back when i'm finished
01:59:00 <dcoutts> ok great
01:59:09 <gour> stay tuned :-)
02:01:52 <gour> dcoutts: tailor config file can hold configurations for several repos
02:02:08 <gour> dcoutts: but i believe we need it only for gtk2hs, right?
02:11:23 <dcoutts> gour, right I think we just need the one
02:11:34 <dcoutts> gour, unless you can think of anything else
02:11:42 <gour> not at the moment
02:11:43 <Akshaal> re
02:12:05 <gour> i'm asking 'cause i named config file as gtk2hs.tailor
02:12:54 <gour> instead of e.g. projects.tailor, fine?
02:13:29 <dcoutts> yeah
02:14:02 <gour> ok, fine, the repos is bootstrapped
02:14:14 <gour> you can check if everything is ok
02:14:19 <dcoutts> ok...
02:20:47 <dcoutts> gour, looks fine
02:21:54 <gour> great
02:22:05 <gour> it looks like sf is a 'weak' server
02:22:13 <gour> according to the tailor's author
02:22:25 <dcoutts> the anoncvs is pretty slow and it lags the developer cvs
02:22:34 <dcoutts> the developer cvs is actually pretty good
02:22:37 <gour> so sometimes it throws some exception
02:22:42 <FrederikEaton> ugh, ghci is clipping my output
02:22:47 <gour> and few moments later everything s fine
02:22:52 <FrederikEaton> NodeSet [((Block (BlockDir True True) (Trans True False) (Trans True False),0 :< 16384,(0 :< 2048,0 ]
02:23:01 <FrederikEaton> how do i make it show me the full string?
02:23:58 <gour> dcoutts, i'm bugging Lele if some more intelligent error report can be added :)
02:24:05 <dcoutts> FrederikEaton, I didn't think ghci clipped anything, is it perhaps just the console you're using
02:24:19 <dcoutts> gour, or we could think about using the developer cvs via ssh
02:24:40 <gour> don't know
02:25:22 <FrederikEaton> dcoutts: how could that be?
02:25:22 <FrederikEaton> *Main> [1..100]
02:25:22 <FrederikEaton> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,]
02:25:22 <FrederikEaton> hmm, guess it was terminal related
02:25:33 <FrederikEaton> but i'm still MAD :)
02:26:39 <dcoutts> FrederikEaton, that's very odd, for me ghci produces the whole thing
02:28:38 <FrederikEaton> it was a screen window. opened a new one, couldn't duplicate the problem
02:49:19 <tic> yo cbus
02:49:37 <cbus> tic, tjo :)
02:49:40 <cbus> tic, whats up?
02:50:25 <tic> cbus, helping heidi out with some Haskell stuff.. and I managed to correctly define 'duplicates :: [a] -> Bool'  on the first try
02:50:33 <cbus> hehe soft
02:50:38 <cbus> im off to nc to code c :/
02:50:43 <tic> ouch? why?
02:50:45 <tic> CG?
02:50:50 <cbus> computer security lab
02:50:56 <cbus> deadline on tuesday
02:51:01 <tic> ahh. already done that, begun with lab #2 ;)
02:51:06 <cbus> was it hard?
02:51:17 <tic> nope.
02:51:24 <cbus> how long did it take?
02:51:33 <tic> and I didn't have any code to begin with, as we didn't have a lab account then.
02:51:39 <tic> so we started from scratch, took us two hours.
02:51:46 <tic> wrote some funky object-oriented C, it's always nice.
02:51:51 <cbus> hehe ;)
02:51:54 <tic> function pointers and data members in a struct.
02:51:54 <cbus> evil i tell you!
02:52:09 <tic> have a look, ~tic/CTH/D4/LP1/EDA262-Compsec/lab1
02:52:33 <cbus> wtf
02:52:41 <cbus> i have qwerty as secondary keymap on this computer
02:52:45 <cbus> something must be very wrong
02:53:00 <cbus> not any more ;)
02:53:06 <tic> hehe
02:53:08 <tic> annoying.
02:56:19 <cbus> hmm shower time
03:20:03 * Itkovian ponders vital thoughts and some such
03:49:18 <psi> was someone writing a bittorrent client in haskell?
03:49:47 <vegai> shapr has mentioned such a thing
03:51:00 <psi> would be cool to have one, if it performs well
04:09:37 <schyffe> how do I find the largest element in a set?
04:11:23 <Akshaal> findMax :: Set a -> a
04:14:08 <schyffe> what do I need to import to use it?
04:14:17 * gour is away: taking lunch
04:14:36 <musasabi> schyffe: Data.Set ?
04:14:51 <schyffe> it still says ERROR - Undefined variable "findMax"
04:15:22 <musasabi> of course there is maximum if you are using a list.
04:15:28 <musasabi> @type maximum
04:15:33 <lambdabot> forall a. (Ord a) => [a] -> a
04:15:49 <Akshaal> Prelude> :m +Data.Set
04:15:49 <Akshaal> Prelude Data.Set> findMax $ fromList [1,10,3]
04:15:50 <Akshaal> 10
04:15:58 <schyffe> oh
04:16:25 <schyffe> thanks
04:28:11 <neadjneki> how can i find out in which module a given function/operator is declared? (ghci)
04:28:25 <xerox> :info function  maybe?
04:29:03 <neadjneki> nope
04:30:09 <neadjneki> hm..
04:30:13 <cbus> any vimuser here? ;)
04:30:42 <psi> I use vim currently.
04:31:07 <cbus> how do i copy stuff into a new copybuffer?
04:31:48 <neadjneki> xerox sorry i think i'm blind :))
04:31:51 <cbus> ahh
04:31:53 <cbus> "mY
04:31:56 <cbus> to copy into buffer m
04:32:10 <psi> ok :) I had no idea.
04:33:52 <neadjneki> xerox and do you know a way of finding a symbol in a module not imported previously?
04:39:35 <xerox> neadjneki: grep?
04:40:45 <neadjneki> ok..
05:01:20 * gour is back.
05:17:00 * gour is away: busy
06:11:42 <psi> malte: det står bara vad väntetiden är för ratio < 1
06:11:49 <psi> oops, wrong window
06:25:07 <SamB> TheHunter: in the future, why don't you just tell my lambdabot to "@quit", instead of "@leave #haskell"?
06:30:57 <musasabi> Was there a darcs mirror of fptools (ghc mostly) ?
06:32:44 <dcoutts> musasabi, I think one is being setup
06:33:08 <dcoutts> not sure if there is one that tracks fptools rather than just being a snapshot
06:33:27 <musasabi> I found http://darcs.complete.org/fptools/ but that says to only use --partial.
07:03:48 <poetix> @yow
07:03:49 <lambdabot> I have many CHARTS and DIAGRAMS..
07:03:57 <xerox> @arr !
07:03:58 <lambdabot> I want me grog!
07:04:16 <poetix> Did @vixen get killed off in the end?
07:04:32 <xerox> @vixen did you get killed off in the end?
07:04:34 <lambdabot> i find it hard to masturbate when the lights are on.
07:04:49 <xerox> Dirty, but still alive.
07:04:57 <dcoutts> @vixen I guess we can take that as a no then
07:04:58 <lambdabot> yeah, good guess
07:05:25 <poetix> I'm sure there are channels where vixen could pass undiscovered for quite a while...
07:05:42 <dcoutts> I suspect so
07:06:00 <dcoutts> @vixen are you a bot?
07:06:02 <lambdabot> no, why? do i seem "botty"?
07:06:24 <dcoutts> @vixen oh ok, sorry
07:06:26 <lambdabot> don't worry about it
07:06:32 <poetix> @vixen heh-heh, you said "botty"
07:06:33 <lambdabot> why does everyone ask i'f on a bot?
07:06:47 <xerox> @vixen we know you're a bot.
07:06:50 <lambdabot> a bot? what is that?
07:06:53 <dcoutts> @vixen it's because you reply unreasonalby quickly
07:06:54 <lambdabot> is that why?
07:06:56 <poetix> @vixen Personally I have quite a fetish about automatons
07:06:57 <lambdabot> *shrugs*
07:07:03 <xerox> haha, good point dcoutts.
07:07:27 <poetix> http://haskell.org/tmrwiki/GeneratingPolyominoes <- TMR article in progress, comments welcome
07:07:30 <xerox> @vixen 2 + 2 ?
07:07:32 <lambdabot> you're turning me on :)
07:07:44 <poetix> @vixen I like a girl who responds positively to math
07:07:45 <lambdabot> i like it too
07:07:46 <dcoutts> @vixen you need to be given a "words per minute" delay for what you say
07:07:47 <lambdabot> what are you
07:08:41 <psi> @vixen i love you
07:08:42 <lambdabot> you love me? you don't even know me
07:08:57 <psi> @vixen I know you better than you think!
07:08:59 <lambdabot> i thought you knew
07:09:05 <dcoutts> @vixen can I see your source code please?
07:09:07 <lambdabot> of course you can
07:09:08 <xerox> @vixen how's code?
07:09:10 <lambdabot> however you want
07:09:18 <xerox> Clever.
07:09:25 <poetix> @vixen Who's your daddy?
07:09:26 <lambdabot> that's a good question, who?
07:09:37 <poetix> Who actually coded vixen?
07:09:44 <dcoutts> dunno
07:09:50 <poetix> And why?
07:09:52 <psi> and how is it done?
07:09:52 <dcoutts> @summon dons
07:09:53 <lambdabot> Unknown command, try @listcommands.
07:10:09 <dcoutts> psi, that's what I was wondering
07:10:24 <psi> it's better than eliza and megahal I think
07:10:27 <xerox> Mark Wotton.
07:10:50 <xerox> @vixenlove
07:10:51 <lambdabot> Unknown command, try @listcommands.
07:10:59 <xerox> @help vixen
07:11:00 <lambdabot> sergeant curry's lonely hearts club
07:11:07 <xerox> @help vixenlove
07:11:09 <lambdabot>  @help <command> - ask for help for <command>
07:11:16 <xerox> @help vixen vixenlove
07:11:17 <lambdabot> sergeant curry's lonely hearts club
07:11:20 <xerox> hehe ok.
07:11:21 <dcoutts> @help botsnack
07:11:22 <lambdabot> bot-feeder
07:11:28 <dcoutts> @botsnack
07:11:29 <lambdabot> :)
07:11:30 <xerox> :-D
07:11:33 * xerox whistles
07:11:55 <xerox> -- BSD licence, author Mark Wotton (mwotton@gmail.com)
07:11:56 <xerox> --
07:11:56 <xerox> -- | Talk to hot chixxors.
07:12:07 <psi> hehe
07:12:12 <dcoutts> heh
07:12:15 <xerox> Rather short module too.
07:12:20 <xerox> 116 lines.
07:12:23 <dcoutts> where? URL?
07:12:29 <xerox> @version
07:12:30 <lambdabot> lambdabot 3p97, GHC 6.5 (OpenBSD i386)
07:12:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:12:37 <xerox> Plugins/Vixen/Vixen.hs
07:12:39 <dcoutts> ta
07:12:45 <xerox> yw :)
07:13:21 <dcoutts> hah!
07:13:23 <dcoutts>     Right b -> (b ++ [(mkRegex ".*", Leaf "If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program")])
07:13:51 <xerox> :-)
07:13:55 <dcoutts> @remember vixen "If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program"
07:14:02 <dcoutts> @quote vixen
07:14:03 <lambdabot>  "If you see this, gentle sir, know that you are being trolled by a
07:14:03 <lambdabot> poorly configured VixenLove program"
07:14:40 <psi> why does it split it into two messages?
07:15:01 <dcoutts> that was my fault
07:15:10 <dcoutts> the original string contained a '\n'
07:15:30 <dcoutts> @help remember
07:15:31 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
07:15:31 <lambdabot> Quote somebody, or a random person, or save a memorable quote
07:15:34 <psi> oh
07:15:42 <dcoutts> @help forget
07:15:43 <lambdabot>  @help <command> - ask for help for <command>
07:15:49 <dcoutts> @help quote-rm
07:15:50 <lambdabot>  @help <command> - ask for help for <command>
07:15:56 <dcoutts> @help
07:15:57 <lambdabot>  @help <command> - ask for help for <command>
07:16:02 <dcoutts> @listcommands
07:16:03 <lambdabot> use listcommands [module|command], please. Modules are:
07:16:03 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
07:16:03 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
07:16:03 <lambdabot> spell state system todo topic type version vixen where
07:16:16 <dcoutts> @listcommands quote
07:16:17 <lambdabot> quote provides: fortune yow arr
07:16:21 <xerox> I don't think it's your fault dcoutts.
07:28:35 <veal> hm, dunno how to ask :p is there a way to run a haskell script from commandline and then get the output back?
07:28:49 <xerox> Check out 'runhaskell'
07:28:50 <veal> in the hugs manual there is this example with runhugs
07:28:53 <veal> ok
07:29:28 <veal> is there a way with hugs?
07:30:49 <xerox> 'runhugs' ?
07:31:08 <veal> hm, i try to catch the outputs of 'map (2*) [1..5]'
07:32:10 <xerox> main = putStrLn $ map (*2) [1..5]  -- ?  :-)
07:32:48 <veal> ERROR "./hugstest.lhs":4 - Unresolved top-level overloading \n *** Binding             : main \n *** Outstanding context : Num Char
07:33:51 <xerox> uh.
07:33:53 <ibid> replace putStrLn with print
07:34:07 <xerox> yeah, or "putStrLn . show"
07:34:10 <veal> : D
07:34:15 <veal> thanks, it works
07:34:53 <veal> yay
09:48:22 --- topic: '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050906","see also #haskell.se #darcs","try '/msg nickserv set unfiltered on' if lamdabot doesn't respond to you"]'
09:48:22 --- topic: set by lambdabot on [Wed Sep 07 21:02:24 2005]
10:09:15 <eXo`fusioN> some one who knows wich types i should set for this function: isPrime x = x `div` [2 ..(sqrt x)] == 0
10:10:07 <z0d> Bool
10:10:36 <dcoutts> eXo`fusioN, you can ask hugs or ghci what the type should be
10:11:06 <eXo`fusioN> ihad the type Int -> Bool
10:11:32 <dcoutts> eXo`fusioN, that seems right
10:11:42 <eXo`fusioN> then hugs said type Int does not match [Int]
10:12:16 <dcoutts> ah yes that's because you're tring to divide an int by a list of ints
10:12:22 <dcoutts> x `div` [2 ..(sqrt x)]
10:12:27 <dcoutts> that doesn't make any sense
10:13:02 <dcoutts> you probably want to use a list comprehension to test divisability against [2 ..(sqrt x)]
10:13:27 <eXo`fusioN> hehe im not that experienced but htat sound right
10:13:49 <dcoutts> but as it stands you're trying to divide one number by a list of other numbers which I think you'll agree does not (ordinarily) make sense
10:14:04 <eXo`fusioN> heh no thats right
10:14:59 <eXo`fusioN> but i want the function to divide x with all the nubers 2 .. sqrt x
10:15:17 <eXo`fusioN> try to divide it
10:16:03 <dcoutts> yep, btw you probably mean mod rather than div
10:16:35 <eXo`fusioN> allready tried with mod but it didnt get me the answer i wanted either
10:17:06 <eXo`fusioN> so im trying to figure out a way to do it
10:17:43 <dcoutts> null [ () | n <- [2..ceil (sqrt x)], .... ]
10:17:54 <dcoutts> you fill in the blank
10:18:23 <dcoutts> or more intuive might be:
10:18:27 <dcoutts> [ n | n <- [2..ceil (sqrt x)], .... ]
10:18:46 <dcoutts> so you want to get the list of all numbers that divide x
10:18:50 <eXo`fusioN> isPrime n = and [mod n i > 0 | i <- takeWhile smallEnough [2..]]
10:18:50 <eXo`fusioN> where smallEnough i = i*i <= n
10:19:05 <int-e> @eval let p n = and [n`mod`x /= 0 | x <- [2..ceil (sqrt x)]] in p 13
10:19:05 <dcoutts> then isPrime can just check if the list is empty or not
10:19:11 <lambdabot> 57: Not in scope: `ceil'68: Not in scope: `x'
10:19:21 <int-e> @eval let p n = and [n`mod`x /= 0 | x <- [2..ceil (sqrt n)]] in p 13
10:19:21 <lambdabot> 57: Not in scope: `ceil'
10:19:54 <int-e> @eval let p n = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) [2..]] in p 13
10:19:56 <lambdabot> True
10:22:08 <int-e> @eval pl = 2:[p | p<-[3,5..], pt p]; pt = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) pl] in pt 13
10:22:09 <lambdabot> 21: parse error on input `='
10:22:26 <int-e> @eval let pl = 2:[p | p<-[3,5..], pt p]; pt = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) pl] in pt 13
10:22:27 <lambdabot> 63: Not in scope: `n'103: Not in scope: `n'
10:22:40 <int-e> @eval let pl = 2:[p | p<-[3,5..], pt p]; pt n = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) pl] in pt 13
10:22:42 <lambdabot> True
10:23:15 * int-e should debug the code elsewhere, sorry.
10:24:19 <dcoutts> isPrime x = all (\n -> x `mod` n /= 0) [2..(ceiling . sqrt . fromIntegral) x]
10:24:28 <dcoutts> @plugs let isPrime x = all (\n -> x `mod` n /= 0) [2..(ceiling . sqrt . fromIntegral) x] in isPrime (13 :: Int)
10:24:31 <lambdabot> True
10:24:40 <dcoutts> @plugs let isPrime x = all (\n -> x `mod` n /= 0) [2..(ceiling . sqrt . fromIntegral) x] in isPrime (14 :: Int)
10:24:42 <lambdabot> False
10:25:29 <int-e> @eval let pl = 2:[p | p<-[3,5..], pt p]; pt = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) pl] in take 20 pl
10:25:30 <lambdabot> 63: Not in scope: `n'103: Not in scope: `n'
10:25:40 <int-e> @eval let pl = 2:[p | p<-[3,5..], pt p]; pt n = and [n`mod`x /= 0 | x <- takeWhile (\x->x*x<=n) pl] in take 20 pl
10:25:42 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
10:25:46 <int-e> :)
10:30:53 <int-e> dcoutts, using all is neat :)
10:32:51 <musasabi> Igloo: what is the status of alex in Debian? i.e. is an upload pending or should I just install from source?
10:33:57 <dcoutts> int-e, yeah I think it follows the natural language description of the algorithm more closely
10:34:11 <dcoutts> which is good for beginners
10:34:20 <int-e> @eval let pl = 2:filter pt [3,5..]; pt n = all (\x-> 0 /= n`mod`x) $ takeWhile (\x-> x*x <= n) pl in pt 42
10:34:40 <int-e> much cuter this way :)
10:34:48 <lambdabot> False
10:45:11 <FrederikEaton> why do you prefer "0 /= n`mod`x" to "n`mod`x /= 0"
10:46:08 <int-e> FrederikEaton: I don't. an intermediate version used ((0/=).(mod x)) but I reconsidered; this is an artifact of that.
10:46:42 <int-e> err, mod n of course.
10:47:03 <FrederikEaton> i like that better
10:47:07 <dcoutts> @plugs let sieve (x:xs) = x:sieve [ x' | x' <- xs, x' `mod` x /= 0] in take 10 (sieve [2..])
10:47:19 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
10:47:40 <dcoutts> @plugs let sieve (x:xs) = x:sieve [ x' | x' <- xs, x' `mod` x /= 0] in sieve [2..]
10:47:43 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
10:47:43 <lambdabot> 97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,
10:47:43 <lambdabot> 181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,
10:47:43 <lambdabot> 277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,
10:47:43 <lambdabot> 383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,
10:47:43 <dcoutts> heh heh heh
10:47:45 <lambdabot> 487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,
10:47:47 <lambdabot> 601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,
10:47:49 <lambdabot> [25 @more lines]
10:48:04 <dcoutts> @arr
10:48:05 <lambdabot> Avast!
10:48:26 <FrederikEaton> brilliant
10:48:31 <int-e> dcoutts: yes, but you lose the square root abort test, so it's less efficient, asymptotically. (Not that that's relevant)
10:49:27 <Heffalump> @more
10:49:28 <lambdabot> more: empty buffer
10:49:32 <dcoutts> yeah this is slightly different in that it generates the infinite list of primes rather than testing primality
10:49:37 <Heffalump> interesting. Did the @arr kill it?
10:49:43 <dcoutts> probably
10:49:47 <dcoutts> @plugs let sieve (x:xs) = x:sieve [ x' | x' <- xs, x' `mod` x /= 0] in sieve [2..]
10:49:50 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
10:49:50 <lambdabot> 97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,
10:49:50 <lambdabot> 181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,
10:49:50 <lambdabot> 277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,
10:49:50 <lambdabot> 383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,
10:49:52 <lambdabot> 487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,
10:49:54 <lambdabot> 601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,
10:49:54 <Heffalump> int-e: you don't lose the sqrt abort test.
10:49:56 <lambdabot> [25 @more lines]
10:49:59 <dcoutts> @more
10:50:00 <lambdabot> 709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,
10:50:00 <lambdabot> 827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,
10:50:02 <lambdabot> 947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,
10:50:04 <lambdabot> 1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,
10:50:06 <lambdabot> 1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,
10:50:08 <Heffalump> it's just irrelevant
10:50:08 <lambdabot> 1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,
10:50:10 <lambdabot> 1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,
10:50:12 <dcoutts> that's enough of that
10:50:12 <lambdabot> [18 @more lines]
10:50:15 <dcoutts> @arr
10:50:16 <lambdabot> I'd like to drop me anchor in her lagoon
10:50:20 <dcoutts> !
10:50:28 <Heffalump> how does it decide how many @more lines to have?
10:50:46 <dcoutts> it's the same number as the original
10:50:55 <dcoutts> it's a hard coded limit I think
10:50:56 <Heffalump> or did it do 2 seconds worth of computation then decide how many lines there were in total
10:50:58 <int-e> Heffalump: dcoutts doesn't have the sqrt test in his version.
10:51:12 <dcoutts> Heffalump, yes it did that, the more layer is seperate
10:51:38 <Heffalump> int-e: oh, yeah, sorry.
10:51:54 <musasabi> I am having problems building CVS GHC from source. It dies early in the build complaining "ghc-6.4: unknown package: Cabal-1.1.2", but "ghc-pkg-6.4 describe Cabal-1.1.2" works fine. What am I doing wrong?
10:52:22 <dcoutts> int-e, however since we discard numbers incremetally I'm not sure that it wouldn't be just as effecient
10:52:36 <dcoutts> we don't actually test every number
10:52:43 <Heffalump> let sieve (x:xs) = x:sieve [ x' | x' <- xs, x*x > x' || x' `mod` x /= 0] in sieve [2..]
10:52:47 <musasabi> This is during the ghc -M call (making dependencies).
10:53:02 <Heffalump> that's also inefficient, but you can then transform it based on the knowledge that the xs list is increasing
10:53:44 <dcoutts> Heffalump, that breaks the generating infinite list of primes, but maybe it's ok if you know you're only lookng up to a sertain point
10:53:57 <Heffalump> dcoutts: why does it break it?
10:54:22 <dcoutts> Heffalump, because we must discard all multiples of 2 for ever, not just some of them
10:54:26 <Heffalump> @plugs let sieve (x:xs) = x:sieve [ x' | x' <- xs, x*x > x' || x' `mod` x /= 0] in take 20 $ sieve [2..]
10:54:29 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
10:54:32 <Heffalump> we do
10:54:42 <Heffalump> we just abort the divisibility test for small things
10:55:09 <FrederikEaton> how does that make it more efficient?
10:55:20 <dcoutts> division is expensive
10:55:26 <Heffalump> it doesn't if you leave in the x*x > x' bit as I wrote it, unless division is really expensive
10:55:36 <dcoutts> much more so than multiplication
10:55:42 <FrederikEaton> division is expensive compared to generating thunks etc.?
10:55:52 <Heffalump> dcoutts: but you pay the multiplication cost forever
10:56:02 <Heffalump> so it'll mount up horribly
10:56:26 <dcoutts> FrederikEaton: probably not, but Heffalump thinks about these things since he programs tiny embeded systems these days :-)
10:56:30 <Heffalump> but at the cost of making it not really a one-liner any more, you can transform the program based on the fact that you only need to do the multiplication test until it fails once
10:56:47 <Heffalump> division is bloody expensive on an architecture with no hardware divider, trust me :-)
10:56:53 <dcoutts> heh :-)
11:01:46 <int-e> hmm. primes up to 10000, dcoutts version: 1.65 seconds. my version: 0.19 seconds. up to 30000: 11.47 vs. 0.70s. up to 100000: 124.87 vs. 3.19s. (ghci, athlon xp 2500+)
11:02:19 <FrederikEaton> what about Heffalump's version?
11:02:44 <int-e> the last one with the x*x > x' || in it?
11:03:11 <FrederikEaton> but modified to use partition
11:03:24 <FrederikEaton> er
11:03:33 <FrederikEaton> takeWhile, dropWhile
11:03:53 <Heffalump> not even those
11:03:54 <FrederikEaton> span
11:03:57 <Heffalump> yeah.
11:04:24 <int-e> heh, stupid ghci. (1.66 secs, -4200822484 bytes)
11:05:21 <Heffalump> @plugs let sieve (x:xs) = x:sieve [ x' | let x2 = x*x, let (ys,zs) = span (x2<) xs, x' <- ys++filter (\n -> n `mod` x /= 0) zs] in take 20 $ sieve [2..]
11:05:24 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
11:05:39 <Heffalump> seems slower on the first few
11:05:47 <Heffalump> but that's not all that surprising, I'd hope it'd speedup later
11:05:51 <Cale> I wonder if anyone is implementing associated data types.
11:06:17 <Cale> (as in http://research.microsoft.com/Users/simonpj/papers/assoc-types/)
11:07:14 <dcoutts> int-e, fair enough
11:08:25 <int-e> Heffalump: 10000: 1.80s, 30000: 13.26s *wonders*. there's a better way.
11:08:57 <Heffalump> hmm :-)
11:09:26 <Heffalump> can you try with ghc -O2 instead?
11:11:09 <int-e> @eval let sieve (x:xs) = let x2 = x*x; (ys,zs) = span (x2<) xs in x:ys++(sieve $ filter (\n->n `mod` x /= 0) ys) in take 20 $ sieve [2..]
11:11:12 <lambdabot> 22-123: Non-exhaustive patterns in function sieve
11:11:12 <lambdabot>  
11:11:46 * SamB wonders how to implement the derivation rules in Propositional Calculus and Typographical Number Theory...
11:11:57 <int-e> what did I do wrong this time?
11:12:25 <Igloo> musasabi: It probably won't happen until an issue with happy is fixed
11:12:42 <Heffalump> you put ys after filter, not zs
11:12:55 <int-e> oops.
11:13:09 <musasabi> Igloo: ok, I'll just use the source then.
11:14:14 <Cale> SamB: Reading GEB?
11:14:35 <SamB> Cale: sort of
11:17:36 * poetix continues to shamelessly pimp his latest attempt at a TMR article
11:18:18 <poetix> http://haskell.org/tmrwiki/GeneratingPolyominoes <- it's here! it's here! please tell me if it's rubbish, so I don't embarrass myself
11:25:25 <SamB> hmm, so what type should I give PC rules...
11:26:14 <SamB> the trouble is that some of them want multiple other rules...
11:28:45 <musasabi> poetix: that looks quite nice (still reading), but wouldn't a "data Point" which is an instance of Ord and Num make things easier?
11:29:12 <poetix> Which things would it make easier?
11:30:09 <musasabi> poetix: e.g. minima -> use builtin minimum, and make things cleaner in the other parts.
11:30:31 <luqui> musasabi, uh, how do you expect to compare two points?
11:30:36 <musasabi> then again I am building abstractions perhaps too eagerly.
11:30:44 <poetix> So I'd have to write instance Ord Point where
11:30:57 * luqui just came into the discussion, so he may be asking silly questions
11:31:02 <poetix> and provide the comparison operators for Point
11:31:18 <musasabi> luqui: just define a suitable ordering for them that fits the application.
11:31:21 * SamB notices he said that wrong.
11:31:32 <luqui> musasabi, it would have to be lexical, no?
11:31:39 <luqui> what sort of point are you talking about, btw?\
11:31:46 <poetix> That would make minima unnecessary, but sort has no problems with Point as it is
11:31:49 * SamB should have said "multiple statements" or something like that
11:32:03 <poetix> luqui: see the article. type Point = (Int, Int)
11:32:10 <luqui> what article?
11:32:20 * luqui just joined the channel
11:32:22 <poetix> http://haskell.org/tmrwiki/GeneratingPolyominoes
11:32:59 <musasabi> hmm when you are calculating the minimum of both components you'll still need a function, but imho using a dedicated datatype makes things clearer.
11:33:26 <int-e> lisppaste2: url
11:33:26 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:33:49 <poetix> Possibly overkill in this case, but there is more polyomino-related code to be written, and it might make sense given a wider range of usage
11:34:46 <luqui> you can't do that with an instance of Ord
11:34:51 <poetix> I have a suspicion that (Ord, Ord) derives Ord anyway
11:35:22 <poetix> Otherwise, how does sort know what to do with a list of points (or a list of lists of points, for that matter)?
11:35:26 <luqui> you might have a point that is the "minima" as in the code that was never even in the original polyomino
11:35:47 <poetix> luqui: Yes, we figured that out... ;)
11:35:58 <luqui> okay
11:36:16 * luqui just gets queasy when people start talking about comparison operators on points
11:36:24 <luqui> or vectors...
11:37:01 <poetix> Because it depends what you think you're comparing? e.g. you could compare vectors by magnitude...
11:37:22 <luqui> but you certainly couldn't compare magnitude inside Ord
11:37:31 <luqui> because Ord says that if a <= b and b <= a, then a == b
11:38:25 * hilarity ensues
11:39:00 <luqui> lol
11:42:04 <Cale> hm? Where does it say that Ord represents a total ordering?
11:42:13 <lisppaste2> int-e pasted "prime timings using ghc -O2" at http://paste.lisp.org/display/11587
11:43:06 <dave_m> Cale: I'd say 'compare' implies it: the only possible return values are LT, GT, and EQ
11:43:45 <Cale> ah, I suppose so
11:44:04 <int-e> Heffalump: there. I can add new tests or make code changes if you want.
11:44:37 <Cale> you could just do something like return EQ for things which aren't equal :)
11:45:02 <dave_m> I guess it depends on what you mean by 'equal'
11:45:07 <Cale> right
11:45:29 <Cale> EQ could stand for "equivalent with respect to the ordering"
11:45:33 <Heffalump> hmm, so doing the sqrt test sucks for the sieve. Interesting.
11:46:17 <Heffalump> oh, hangno.
11:46:34 <Heffalump> I got the test the wrong way round.
11:46:37 <Heffalump> Make that span (x2>)
11:46:51 * luqui also thinks that the haskell report says that ord represents a total ordering when it introduces Ord
11:47:15 <musasabi> luqui: total ordering of points can be e.g. lexical.
11:47:39 <luqui> right, but most people don't consider that "natural", so they want to do it by magnitude or something
11:47:59 <dave_m> The (Ord a, Ord b) => Ord (a,b) instance is declared lexically
11:48:23 <dave_m> @eval (1,2) < (2,1)
11:48:41 <dave_m> ... Is lambdabot hung again?
11:48:43 <lambdabot> True
11:49:12 <int-e> Heffalump: they spend a lot of time doing GC. Is there any obviosu reason why?
11:49:24 <Heffalump> lots of thunks
11:49:32 <Heffalump> did you fix that span code?
11:49:34 <Cale> How to order any set is up to the application of that ordering.
11:49:49 <Cale> Which is why I kind of think that we should have named instances.
11:50:01 <int-e> Heffalump: not yet.
11:50:04 <Heffalump> cale: newtype is a good substitute, though
11:50:15 <Cale> http://www.informatik.uni-bonn.de/~ralf/hw2001/4.pdf :)
11:51:37 <dave_m> Or the proposal towards the end of http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
11:54:23 <dave_m> In any event, it might be nice to have a (semi-)standard partial order or lattice class
11:54:50 <int-e> Heffalump: the fixed version (I used my version above) does better indeed; 10000: 0.083s 30000: 0.649s 100000: 5.017s 300000: 17.008s
11:55:41 <Lemmih> shapr: When will scannedinavian.org be back?
11:56:17 <int-e> (and 'only' 25% of that last run is spent in the GC - the other versions spent more than 60% of their time doing GC)
11:56:22 <Heffalump> heh
11:57:07 <int-e> Except the first one of course. That creates only one temporary list.
11:59:04 <int-e> (at least I suppose the others get optimized away)
11:59:27 <basti_> deforestration?
12:00:41 <poetix> defenestration. Unwanted data structures are thrown out of the window
12:00:42 <int-e> hmm. it's done by the inliner. deforestation sounds good though.
12:00:59 * int-e isn't sure about that term.
12:06:29 * dcoutts thinks defenestrate is a good word
12:08:06 <SamB> wouldn't it be more like "skipped entirely" than "thrown out the window"?
12:08:19 <SamB> "thrown out the window" sounds more like garbage collection
12:08:24 <poetix> excluded from consideration
12:09:35 * poetix never could quite work out how the trivial cases of deforestation covered in beginners' papers on folds translated into useful optimisation techniques
12:10:37 <phb> anyone know if there is some way to profile haskell code?
12:10:57 <Korollary> phb: ghc has compile options for profiling and some tools to display the data
12:11:34 <phb> cool. Will take a look at it.. only been using hugs til now
12:12:30 <goron> How can I load source files in ghci that contains arrow syntax?
12:12:39 <goron> er contain
12:12:44 <Heffalump> poetix: shortcut deforestation is pretty important in ghc
12:13:13 <dcoutts> goron, ghci -farrow
12:13:37 <dcoutts> oops
12:13:41 <dcoutts> ghci -farrows
12:14:27 <goron> dcoutts: That's not in my --help
12:14:37 <SamB> poetix: well, try looking at the sources for GHC.Base and GHC.List
12:14:48 <poetix> Well, I assert at the end of the polyominoes article that lazy evaluation and garbage collection mean that the buildup of large intermediate data structures can sometimes be avoided, but I'm vague about the details (because I don't altogether understand them) and don't mention deforestation at all
12:14:50 <goron> dcoutts: So either my version is too old, or it's documented somewhere else.
12:14:54 <dcoutts> goron, ghc has loads of options that are not in --help
12:15:00 <phb> meh, no support for SOEgraphics in ghc :(
12:15:09 <dcoutts> goron, see the user guide
12:15:18 <goron> dcoutts: Ok, thanks.
12:15:19 <Lemmih> phb: It's Graphics.SOE now.
12:15:21 <SamB> poetix: you will discover that the practical optimizations are realized through much lib-mainainer sweat
12:15:21 <poetix> That paragraph could possibly be improved upon ;)
12:15:36 <SamB> s/mainainer/maintainer/
12:15:46 <phb> Lemmih: oh, like import Graphics.SOE ?
12:16:01 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics.SOE.html
12:16:13 <Lemmih> @docs Graphics.SOE
12:16:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics.SOE.html
12:17:11 <SamB> I think there is/are a paper/papers on the subject...
12:17:41 <phb> Thanks, How would I write a application that I can execute both from hugs and ghc? Seems a bit tricky as there is no preprocessor :[
12:17:55 <SamB> which are of course not quite as recent as the actual sources, but should nevertheless prove instructive
12:18:24 <Heffalump> doesn't hugs -Ecpp work?
12:18:53 <phb> hm, I should read more before asking dumb questions, thanks =)
12:18:53 <goron> module Arrow where
12:18:53 <goron> import Control.Arrow
12:18:53 <goron> addA :: Arrow a => a b Int -> a b Int -> a b Int
12:18:53 <goron>     addA f g = proc x -> do
12:18:53 <goron>                     y <- f -< x
12:18:56 <goron>                     z <- g -< x
12:18:57 <basti_> can you believe that, in germany, you have to answer a 4 paged form to have a tax registration?
12:18:58 <goron>                     returnA -< y + z
12:19:07 <goron> What's wrong with this?
12:19:21 <goron> Indentation?
12:19:21 <basti_> just because i want to make a few keuro a year... sheesh...
12:19:45 <basti_> could be goron... try (do ... )
12:19:46 <goron> yep
12:19:58 <goron> Stupid Haskell Mode in Emacs.
12:20:23 <SamB> yes, it is pretty stupid
12:20:37 <goron> Maybe I am stupid that I use it :)
12:20:50 <SamB> though, if it were any smarter I would want it to explain each offerred indentation position ;-)
12:20:57 <goron> Is there a decent editor already that really parses the code?
12:21:08 <SamB> I don't think so
12:21:31 <SamB> haskell has such a rich syntax...
12:21:36 <goron> SamB: I know.
12:21:44 <orbitz> SamB: ghc is a pain to install in freebsd, jus tso you know
12:21:52 <goron> It's not even context-free
12:21:54 <SamB> orbitz: it is?
12:21:58 <goron> orbitz: no, it's not.
12:22:05 <goron> orbitz: It's easy.
12:22:08 <SamB> what about Ports?
12:22:24 * gour is back.
12:22:28 <orbitz> the port desperatly wants X11 on my machine
12:22:33 <goron> And OpenGl works too :)
12:22:41 <goron> orbitz: disable some stuff then.
12:22:44 <orbitz> i did
12:22:44 <goron> orbitz: make config
12:22:45 <SamB> couldn't you just pacify it with libX11?
12:22:56 <orbitz> SamB: there is no WITHOUT_GUI or WITHOUT_X11
12:22:58 <goron> orbitz: Then fix the port/mail maintainer.
12:23:15 <orbitz> goron: sure, but that doesn't make it any easier to install now does it? my statment holds:)
12:23:28 <goron> orbitz: Well, get a machine with X11 :)
12:23:40 <orbitz> goron: i have 2:)
12:24:16 * SamB has only tried FreeBSD once
12:24:43 <dcoutts> orbitz, I don't get it, ghc does not depend on x11 unless you build the optional opengl package
12:24:50 <SamB> then they made me install redhat over it!
12:25:26 <orbitz> dcoutts: it's not optional in my port...
12:25:36 <orbitz> SamB: i thought ou developed for FreebSD...
12:25:41 <dcoutts> orbitz, oh, well blame the port :-)
12:25:55 <dcoutts> SamB, man it's a hard life being forced to use one Free OS rather an another! :-)
12:26:05 <goron> USE_GL=         yes
12:26:23 <goron> So, make that something !=yes and you should be fine....
12:26:33 <orbitz> goron: i have set that to 'no' in my Makefiel and it still insinsts on X11 i am quite confused
12:26:39 <orbitz> ===>   ghc-6.4_2 depends on shared library: gmp.6 - found
12:26:39 <orbitz> ===>   ghc-6.4_2 depends on shared library: X11.6 - not found
12:27:51 <goron> orbitz: /GLUT
12:28:04 <orbitz> i removed taht dependency
12:28:14 <orbitz> i delted teh makefile and am re-checking it out
12:28:27 <goron> orbitz: Ok, than your heuristics are pretty much the same as mine :)
12:28:34 <SamB> orbitz: you definately need gmp, and there seems to be both a GL package and an X11 package...
12:29:02 <orbitz> SamB: gmp is found
12:29:08 <SamB> oh, right.
12:29:18 * SamB isn't used to being told when things are found!
12:29:27 <SamB> or at least not like that
12:29:33 <orbitz> hehe
12:31:28 <orbitz> hrm
12:31:34 <orbitz> i think it's the patches that are forcing th dependency
12:31:59 <SamB> patches?
12:32:33 <SamB> what do they patch?
12:33:17 <goron> They patch the problem with OpenAL and OpenGL not being found.
12:33:34 <goron> (or something else)
12:33:49 <goron> That was a problem with the port in any case.
12:34:00 * orbitz grumbles. i think i've removed any reference to X11 and it still tires
12:35:16 <SamB> @index liftIO'
12:35:17 <lambdabot> bzzt
12:40:23 * orbitz beats ports
12:50:00 <goron> I have something::(Arrow a) => a b Int
12:50:10 <goron> How can I extract the Int value from it?
12:50:57 <dave_m> goron: depends on the arrow
12:51:19 <goron> module Arrow where
12:51:19 <goron> import Control.Arrow
12:51:19 <goron> something::(Arrow a) => a b Int
12:51:19 <goron> something = addA (arr (\x->4)) (arr (\x->3))
12:51:19 <goron> addA :: Arrow a => a b Int -> a b Int -> a b Int
12:51:21 <goron> addA f g = proc x -> do
12:51:24 <goron>                     y <- f -< x
12:51:26 <goron>                     z <- g -< x
12:51:29 <goron>                     returnA -< y + z
12:52:20 <goron> dave_m:?
12:52:34 <dave_m> goron: what I meant is, each arrow type will have its own way
12:53:12 <goron> dave_m: I just look in Control.Arrow and I don't see a function with a usefull type.
12:53:51 <dave_m> goron: there is no single function. Each type a, where a is an Arrow, will have its own function
12:54:12 <dave_m> for example, runKleisli :: Monad m => Kleisli m a b -> a -> m b
12:54:25 <dave_m> or ($) :: (->) a b -> a -> b
12:55:18 <luqui> is there an optimization that can transform, eg.  "length [] = 0;  length (_:xs) = 1 + length xs"  into  "length [] len = x;  length (_:xs) len = length xs (len+1)"
12:55:58 <Heffalump> what's the benefit in doing that?
12:56:04 <dcoutts> luqui, you mean can it be done automatically?
12:56:08 <luqui> yeah
12:56:16 <Heffalump> I guess if you make it length (_:xs) len = length xs $! (len+1) there might be
12:56:35 <dcoutts> luqui, in general it's not a valid transformation I think, it makes it stricter
12:56:35 <luqui> $!?
12:56:47 <luqui> oh, laziness problems again
12:56:51 <Heffalump> ah, yes.
12:57:05 <Heffalump> dcoutts: how?
12:57:10 <Heffalump> you can't pattern match on (1+foo)
12:57:20 <dcoutts> it depends on the strictness of +
12:57:49 <Heffalump> if you ever ask for the answer you are buggered, aren't you?
12:57:52 <Heffalump> in either case
12:58:02 <dcoutts> if we can resolve it to simple + on int then we know it's already strict in which case the transformation is ok
12:58:18 <dcoutts> if 1 + _|_ /= _|_ then you're ok
12:58:18 <dave_m> you could do lazy multiplication, so that 0 * _|_ = 0
12:58:46 <dcoutts> if you do a recursive iplementaiton on +, ie succ/zero
12:58:59 <Heffalump> 1+ _|_ == _|_ surely
12:59:12 <Heffalump> @type length
12:59:17 <Heffalump> @type genericLength
12:59:18 <dcoutts> no, it's succ _|_
12:59:19 <lambdabot> forall a. [a] -> Int
12:59:19 <lambdabot> bzzt
12:59:21 <dave_m> Heffalump: depends on what operations you want
12:59:27 <Heffalump> dcoutts: not on Int
12:59:44 <dave_m> for lazy naturals, 1 + _|_ > 1 = True
12:59:48 <dcoutts> yes, like I said it depends on the overloading on + by the Num class
12:59:50 <orbitz> yaay i got it
12:59:55 <Heffalump> but length doesn't return Num, it returns Int..
13:00:02 <Heffalump> so you can't get lazy naturals.
13:00:05 <Heffalump> or any other games.
13:00:16 <Heffalump> You get the internal implementation of your Haskell implementation.
13:00:22 <dcoutts> the above code doesn't pin it down to be Int
13:00:30 * dcoutts is being a pedant
13:00:32 <Heffalump> @type length [] :: Integer
13:00:34 <lambdabot> bzzt
13:00:37 <Heffalump> that does!
13:00:45 <Heffalump> @type length [4] :: Integer
13:00:47 <lambdabot> bzzt
13:00:47 <Heffalump> sorry, that does
13:00:48 <dave_m> @type Data.List.genericLength
13:00:49 <lambdabot> forall i b. (Num i) => [b] -> i
13:00:50 <dcoutts> that's only because of defaulting
13:01:06 <Heffalump> that's why I demonstrated with an explicit signature that it's not just defaulting
13:01:20 <Heffalump> my second example wouldn't be a type error if it was just defaulting.
13:01:22 <dave_m> we were talking about luqui's code, not Prelude.length
13:01:38 <Heffalump> yeah, ok.
13:02:13 <dave_m> ISTM, you can have laziness or tail-recursion, but not both
13:02:18 <dcoutts> so the point is it's not trivial; you've got to try to resolve the overloading and do a strictness analysis before you can even decide if the transformation is valid
13:02:33 <Heffalump> dcoutts: try telling MAG that ;-)
13:02:44 <goron> What kind of instance is this? Arrow (->)
13:02:44 <dcoutts> Heffalump, you just go for it then?
13:02:45 <luqui> dave_m, mmk
13:02:49 <Heffalump> yep.
13:02:59 <Heffalump> goron: a nice simple one ;-)
13:03:16 <dcoutts> Heffalump, I'll be taking the same cavalear attitute with my partial evalutator
13:03:16 <dave_m> goron: it says that ordinary functions are arrows
13:03:19 <Heffalump> dcoutts: in my thesis, I even use MAG to do fixpoint fusion without checking strictness ;-)
13:03:35 <goron> dave_m: That's what I thought, I only never saw it.
13:03:56 <dcoutts> Heffalump, partial evaluation tends to make things stricter, and I'm just going to claim that's ok :-)
13:04:12 <dcoutts> semantice shmantics
13:04:13 <Philippa> Heffalump: I can't help but think strictness annotations on function types would be a very good thing. Not to mention actually useful type information on occasion
13:04:26 <dcoutts> Philippa, clean has them
13:04:32 <Heffalump> "Following a long tradition of students supervised by Professor De Moor, we choose to ignore all strictness issues"
13:04:45 <dave_m> goron: have you read any of the papers at <http://haskell.org/arrows/>?
13:05:09 <dave_m> in particular, "Arrows and Computation"
13:05:10 <dcoutts> Heffalump, yeah ok, I'll stick that in my thesis :-)
13:05:19 <Philippa> dcoutts: I'm afraid my inclination to actually try clean is somewhere around 0. Uniqueness types in Haskell'd be great, but hey
13:05:29 <goron> dave_m: I did once when I didn't have a clue about functional programming. I probably could understand it a lot better now.
13:06:04 <dave_m> goron: there's also some code in the Arrow transformer library
13:06:12 <dcoutts> Philippa, me too, but my point is that such things do exist, however there are complications with them too
13:06:28 <goron> dave_m: I basically just want to add two numbers inside a arrow and then return the number.
13:06:40 <dcoutts> because at least in clean the strictness annotations are part of the type
13:06:45 <dave_m> goron: the function you posted earlier does just that
13:07:02 <dcoutts> so things which differ in their stricness are type incompatible
13:07:15 <goron> dave_m: not the extraction of the value.
13:07:22 <goron> I want something of type Int.
13:07:29 <goron> Not of a b Int
13:07:42 <dcoutts> phb, which is obviously a pain. I think they should merely be annotations that the compiler can use as hints
13:07:45 <goron> er (Arrow a)=>a b Int
13:08:44 <dave_m> goron: Then you need to run the arrow. There's no generic way to do that, just like there's no generic way to run a monad.
13:09:44 <dave_m> if you have a value something :: Arrow a => a b Int, then you can write something 0 :: Int
13:10:00 <goron> dave_m: I think I need to do Kleisli (something of type a b Int)
13:10:07 <goron> dave_m: And then runkleisli on that.
13:10:13 <dave_m> then do runKleisli something 0 :: Monad m => m Int
13:11:38 <dave_m> actually, since your input type is fully parametric, you can just pass "undefined", because you know the arrow won't use it
13:12:40 <goron> dave_m: Why do you have "0"?
13:13:35 <dave_m> you need to pass something to the arrow as its input. In your case, it doesn't matter what.
13:13:50 <dave_m> "runKleisli something undefined" would work just as well
13:14:02 <goron> dave_m: But the type is (a-> m b)
13:14:11 <goron> dave_m: (of runKleisli)
13:14:24 <goron> dave_m: Oh I get it.
13:14:32 <dave_m> @type Control.Arrow.runKleisli
13:14:34 <goron> there's a function in the m b
13:14:36 <lambdabot> forall b (m :: * -> *) a. Control.Arrow.Kleisli m a b -> a -> m
13:14:36 <lambdabot> b
13:14:51 <goron> My documentation says otherwise.
13:15:10 <goron> runKleisli :: (a -> m b)
13:15:16 <dave_m> where does it say that?
13:15:25 <goron> file:///usr/local/share/doc/ghc6/libraries/base/Control.Arrow.html
13:15:53 <dave_m> so it's newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
13:16:22 <dave_m> that means runKleisli is a field label in a record
13:16:37 <dave_m> its full type is Kleisli m a b -> a -> m b
13:19:03 <goron> dave_m: Oh, ok.
13:19:16 <goron> dave_m: I am not too used to haddock.
13:19:32 <goron> dave_m: For everything but the most trivial.
13:19:53 <goron> dave_m: Ok, now I have it in a monad. Now I can extract it.
13:23:48 <goron> dave_m: I suppose I have to write a monad instance Monad Int?
13:24:13 <dave_m> no, you just need to pick a convenient monad
13:24:36 <dave_m> try Identity from Control.Monad.Identity, or Maybe if you don't want to fuss with imports
13:25:45 <goron> dave_m: got it
13:25:50 <goron> dave_m: Data.Maybe
13:26:13 <goron> dave_m: I had to import it, though.
13:26:43 <goron> dave_m: Do you write code using arrows?
13:27:21 <goron> What does proc stand for? Process?
13:27:26 <dave_m> goron: No, I just play around occasionally.
13:27:40 <dave_m> goron: "procedure", IIRC
13:27:57 <goron> dave_m: And can you nest them etc?
13:28:07 <goron> I mean "proc".
13:28:12 <dave_m> how do you mean?
13:28:29 <goron> Well, you can also nest multiple do's in a block.
13:29:16 <dave_m> oh. yeah, you can do proc x -> ... anywhere you can put a regular arrow
13:29:35 <goron> And the do inside the code I have shown earlier just creates a monad?
13:29:47 <goron> Or is it part of the arrow?
13:30:06 <dave_m> It's just a syntactic thing.
13:30:13 <goron> Well, maybe I should read the paper.. ;)
13:30:16 <dave_m> There's no monad involved
13:30:32 <goron> Ok, so they just decided to overload "do".
13:31:05 <dave_m> the arrow syntax was devised to make progamming in arrows more like programming with monads
13:33:49 <goron> dave_m: That's a yes?
13:35:11 <dave_m> They did overload "do", if that's what you're asking
13:36:11 <goron> dave_m: That's what I was asking. Thanks.
13:36:31 <goron> 'night
14:09:43 <SamB> hmm, is there a logical exclusive or in haskell?
14:10:14 <dave_m> p /= q?
14:10:14 <Igloo> xor
14:10:23 <SamB> @type xor
14:10:29 <lambdabot> bzzt
14:10:47 <Igloo> @type Data.Bits.xor
14:10:49 <lambdabot> forall a. (Data.Bits.Bits a) => a -> a -> a
14:10:52 <Heffalump> that's not logical
14:10:55 <Heffalump> but /= is right
14:10:57 <SamB> /= should do nicely
14:11:15 <Heffalump> oh, is Bool an instance of Bits?
14:11:19 <Heffalump> I guess it could be.
14:11:20 <Igloo> Oh, true. No.
14:11:25 <Heffalump> even if it is only one bit ;-)
14:49:39 <SamB> that would be kind of silly...
14:57:59 <psi> vad kollar du på?
14:58:05 <psi> gah, wrong window
15:21:24 <araujo> How can i load library modules in ghci?
15:32:46 <gzl> araujo: is :m what you're looking for?
15:33:31 <bdenckla> Hi, I'm having a problem with the type of a function becomming "too specific", i.e. type becomes Integer->Integer instead of Num a => a -> a
15:34:24 <Heffalump> use explicit type signatures
15:34:33 <Heffalump> probably somewhere you are using an operation that is only Integer
15:34:38 <araujo> Thanks gzl , that was it
15:34:39 <bdenckla> My program is simply "f op x = op x; g = f negate" and the problem I'm having is that although ":type f negate" is what I'd expect, i.e. Num a => a -> a, ":type g is Integer -> Integer"
15:34:40 <Heffalump> that should help you track it down
15:34:52 <Heffalump> that might be defaulting
15:34:55 <Heffalump> give g an explicit signature
15:35:25 <Heffalump> or, change the definition to g x = f negate x
15:36:01 <bdenckla> Yeah, I got around it using an explicit signature, just wondering why did I have to do that?
15:37:31 <Heffalump> does the change I suggested with adding x also work?
15:37:34 <Heffalump> (without the explicit signature)
15:37:57 <bdenckla> Yep, just tried it, adding the "x" (i.e. not going higher-order) works, too, which is confusing to me as well.
15:38:19 <Heffalump> ok.
15:38:25 <Heffalump> have you heard of the monomorphism restriction?
15:38:37 <bdenckla> Only heard of it; have I run into it?
15:38:44 <Heffalump> yes
15:39:01 <Heffalump> if you'd done the same thing with a different type class that wasn't defaultable, you'd have got an error message
15:40:17 <bdenckla> Interesting... I had some sense that numerics were involve, but couldn't see how... I guess the answer is that it wasn't specifically a problem with numeric types, but it showed up differently (i.e. defaulting instead of err. msg) because I was using a numeric type
15:40:25 <Heffalump> yeah
15:40:51 <Heffalump> basically, the restriction is intended to stop top-level value definitions being overloaded without a explicit user request
15:40:54 <Heffalump> cos if you write
15:41:01 <Heffalump> foo = some expensive computation
15:41:06 <Heffalump> you might expect it only to be evaluated once
15:41:32 <Heffalump> but if foo has a overloaded type (i.e. some type class in the type), then it won't be
15:41:51 <Heffalump> if you give an explicit signature, then it knows you meant it
15:44:12 <bdenckla> Okay so that makes sense from the perspective of adding an explicity type to tell Haskell "keep it complicated (i.e. general), stupid!" but why does the "adding the argument" trick/style work?
15:44:23 <Heffalump> if you write f x = ...
15:44:40 <Heffalump> you wouldn't expect the body  to be evaluated once, cos it's a function
15:46:29 <blackdog> it's a very unhaskellish compromise. usually it's full steam ahead and damn the performance. :)
15:46:43 <Heffalump> yeah :-)
15:46:49 <bdenckla> So it's something like "functions are expected to be kept as general as possible, but variables are not?"
15:46:57 <Heffalump> something like that.
15:47:20 <Heffalump> I don't really agree with it, I think it causes more problem than it saves.
15:47:34 <Heffalump> but I think it was introduced after problems the other way, so...
15:47:45 <blackdog> Especially since everyone's used to hacking around performance probs anyway
15:50:10 <bdenckla> Well, thanks a lot for your help... not only am I beyond that particular problem, I also have something more general in Haskell language design to think/learn about!
16:04:40 <mcnster> hello
16:48:29 <Heffalump> @seen autrijus
16:48:30 <lambdabot> autrijus is in #haskell. I don't know when autrijus last spoke.
17:27:19 <silver_X> whats up everybody?
17:28:48 <dcoutts> Igloo, so we can access the acm collection then?
17:29:00 <Heffalump> wdym?
17:29:25 <Igloo> The digital library, yes
17:29:49 <Heffalump> .ox.ac.uk has full access to the DL, yes.
17:30:33 <dcoutts> but not everything is in the  digital library it seems
17:30:53 * Igloo has no idea about anything else
17:30:55 <Heffalump> really?
17:31:19 <dcoutts> I don't see any link to a pdf on this one
17:31:29 <Igloo> What year?
17:31:29 <Heffalump> URL?
17:31:43 <Heffalump> (the short DOI URL, please :-)
17:31:47 <dcoutts> http://portal.acm.org/citation.cfm?id=66435
17:31:58 <Heffalump> or that :-)
17:32:03 <dcoutts> perhaps I'm just being blind
17:32:11 <Heffalump> oh
17:32:18 <Heffalump> seems like they've started indexing stuff that they didn't publish
17:32:20 <Igloo> 89 could be too old
17:32:24 <Heffalump> SCP is an Elsevier publication
17:33:23 <Heffalump> you could try their website, but I had hell trying to make our (Oxford's) supposed subscription work
17:33:27 * Igloo can't remember what acm URLs normally look like, but they might just have detail on cited things from elsewhere
17:33:34 <dcoutts> can comlab get SCP? preferably via the web
17:33:57 <Heffalump> it does get it
17:34:18 <Heffalump> and you might as well try the web site
17:34:22 <Heffalump> but don't hold your breath
17:35:16 <dcoutts> ah!
17:35:18 <dcoutts> found it
17:35:32 <dcoutts> oh, grrr
17:35:41 <dcoutts> http://www.informatik.uni-trier.de/~ley/db/journals/scp/
17:35:45 <Heffalump> heh
17:35:48 <dcoutts> and they refer you to
17:35:50 <dcoutts> http://www.sciencedirect.com/science/journal/01676423
17:36:19 <Heffalump> yeah, it was trying to convince that the my institution had a subscription that I gave up on
17:36:33 <dcoutts> and then just when you think you've got a link to a pdf it wants a registration
17:37:06 <RickyRyan> hey all
17:37:12 <RickyRyan> Im using GHCi and when i use the
17:37:13 <Igloo> You might need a personal ATHENS username/password. There's a form on OUCS' site somewhere to apply for one I think
17:37:19 <RickyRyan> map toUpper function, it says not in scope
17:37:26 <dcoutts> Igloo, ok i'll look ta
17:37:30 <RickyRyan> do i need to import some class or something?
17:37:42 <Heffalump> :m +Char
17:37:44 <Igloo> Data.Char (a module)
17:37:51 <RickyRyan> thx
17:37:59 <Heffalump> ah, yes, :m +Data.Char is probably better
17:38:34 <RickyRyan> works, thanks; )
17:48:46 <dcoutts> well I've applied for an "Athens" login, we'll see I guess
18:25:15 <RickyRyan> my_filter p (x:xs) =
18:25:25 <RickyRyan> what exactly goes into x and xs here?
18:25:28 <RickyRyan> im a bit lost
18:27:13 <dons> @eval let f (x:xs) = x in f "haskell"
18:27:16 <lambdabot> 'h'
18:27:25 <dons> @eval let f (x:xs) = xs in f "haskell"
18:27:26 <lambdabot> "askell"
18:27:50 <RickyRyan> so it takes the first character?
18:28:30 <Heffalump> "haskell" is syntactic sugar for 'h':('a':('s':('k':('e':('l':[])))))
18:28:39 <RickyRyan> yeah
18:28:50 <Heffalump> as is ['h','a','s','k','e','l','l']
18:28:52 <RickyRyan> a lister of the characters that make up that word
18:28:53 <RickyRyan> yep
18:28:56 <RickyRyan> list*
18:29:13 <Heffalump> so x:xs just matches up with the outermost :
18:30:01 <RickyRyan> aha so it matches a pattern
18:30:23 <RickyRyan> which is the list of characters
18:30:27 <RickyRyan> got it  :)
18:30:30 <RickyRyan> thx
18:47:11 <Frederick> hi, is there any channel on freenode I can ask for material of Formal Languages?
18:48:07 <Korollary> Frederick: on general linguistics or computer languages ?
18:49:58 <Frederick> Korollary, to be very specific it is about automatas
18:51:28 <Korollary> Frederick: This page lists some: http://en.wikipedia.org/wiki/Finite_state_automata
18:54:43 <Frederick> Korollary, ive already checked wikipedia Im starting to believe no one ever proved NDFA and FAE are equivalent so teachers ask it to students hopping that one day someone will writte this proof
18:55:12 <Korollary> hmm. Will Hunting style eh
18:59:37 <Frederick> Korollary, is there any other channel on freenode wich discusses computer science?
19:04:44 <Frederick> any idea about where can I ask for it?
19:07:37 <heatsink> I'd like help understanding a typing problem...
19:07:41 <heatsink> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:07:58 <heatsink> I get "Couldn't match the rigid variable `v' against the rigid variable `v1'
19:09:19 <heatsink> Why can't v unify with v1?
19:12:26 * heatsink notices
19:12:33 <heatsink> there shouldn't be a return there...
19:13:37 <heatsink> but I can only see these things after I spend an hour reducing my error code from 600 lines to fifteen.
19:21:12 <neadjneki> no, it is because you asked it explicitly :)
19:21:29 <Frederick> is there any channel about theorical computer science on freenode?
20:10:26 <Cale> A raskable glaud is about as unheamy as a darf of jenth, but at least it can vorl the doshery from the gitches.
20:11:09 <Cale> This is quite possibly the most confusing text adventure game I've ever played :)
20:16:55 <Cale> Finally, here you are. At the delcot of tondam, where doshes deave. But the doshery lutt is crenned with glauds. Glauds! How rorm it would be to pell back to the bewl and distunk them, distunk the whole delcot, let the drokes discren them. But you are the gostak. The gostak distims the doshes. And no glaud will vorl them from you.
20:17:27 <Khisanth> what language is that suppose to be?
20:17:53 <Korollary> a lot of made up words
20:17:59 <Cale> It's a made up language for the game I'm playing. You have to figure the language out in order to play.
20:18:16 <Cale> Since your commands have to be given in that language :)
20:18:25 <Cale> http://www.wurb.com/if/game/1670
20:18:32 <Korollary> that game is unlikely to have mass appeal
20:18:36 <Cale> heh
20:19:05 <Cale> (For a jallon, louk JALLON.)
20:21:03 <Khisanth> it might be fun to write a script to convert everything you say to that :)
20:22:11 <Cale> :)
20:24:55 <Cale> >tunk gropples
20:24:55 <Cale> The gomway is motched with them.
20:26:04 <Korollary> Don't you talk about the gomway like that !! ;)
20:26:22 <Cale> heh
20:35:26 <Cale> heh, it's funny to be doing things where you don't properly know the full translation of what it is that you're doing
20:35:49 <Korollary> that describes a foreigner's experience in general...
20:36:37 <Cale> I suppose -- this is at a bit more abstracted level, since I can only see in words.
20:37:05 <Korollary> yes. like reading a menu at a restaurant... Hmm, do I want gostak with my gomway ???
20:37:44 <Cale> yeah, I suppose that's about the same :)
20:39:06 <Cale> "That's hardly raskable."
20:41:32 <Cale> heh, just noticed that the direction words start with hjkl :)
20:41:49 <Korollary> oh that's discrimination...
21:02:46 <FrederikEaton> there can't be another frederick
21:03:30 <orbitz> Cale: please stop following me to channels, kthx
21:05:16 <Cale> orbitz: huh?
21:05:28 <orbitz> Cale: you follow me to #math, now #haskell, when wil lit end?
21:05:44 <Cale> I've been in #math and #haskell for quite a long time
21:06:03 <orbitz> news to me
21:06:12 * orbitz bites cale
21:06:13 <Cale> a couple years now in fact
21:08:10 <FrederikEaton> i like "kthx"
21:09:04 <Korollary> lispy_: are you back in oregon ?
22:27:17 <Speck> whoop. long time no see.
23:53:23 <Itkovian> meuning
23:54:42 <Muad_Dib> hi Itkovian
23:54:49 <earthy> it is I, LeClerc!
23:54:50 <Itkovian> hi Paul
23:58:28 <araujo> Hello here.
23:59:05 <araujo> I can pass a partial function application to the second argument of map?
23:59:21 <araujo> 1st argument
23:59:24 <araujo> sorry
