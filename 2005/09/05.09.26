00:04:33 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/comonad/
00:12:51 <dons> hi from icfp :)
00:13:53 * Heffalump waves to dons
00:13:58 <Heffalump> (I think I'm two seats behind you)
00:18:10 <dons> hehe
00:20:45 * dons wonders if we should have an icfp note-taking page on hawiki
00:37:59 <Lemmih> God morgen, Oejet.
00:42:52 <JohnMeacham> Hello ICFP, from california.
00:44:31 <Oejet> Lemmih: Godmorgen. :-)
00:47:56 <Oejet> I read the Haskell on SMP paper; very interesting stuff.
01:08:29 <wilx> Hm...
01:08:31 <wilx> @paste
01:08:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:10:12 <wilx> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
01:10:28 <wilx> So...what is wrong with that piece of Template Haskell?
01:15:25 <Lemmih> wilx: I've pasted a fix.
01:16:06 <Lemmih> The code is not designed to be evaluated, though.
01:19:15 <wilx> Thanks.
01:51:48 <shapr> dons: That's a good idea actually. That or an ICFP wiki.
01:52:10 <shapr> hej ralejs!
01:55:16 <ralejs> hej shapr
01:56:02 <shapr> How's code?
01:56:41 <ralejs> shapr: Are you asking me?
01:56:45 <shapr> Hey have you seen the dataflow comonads paper from a few days ago? It sounds like the stuff that John Hughes was talking about at EuroHaskell 2004.
01:56:52 <shapr> ralejs: Yes, how's code?
01:57:49 <ralejs> Well, I don't do much coding nowadays. I'm on sickleave because I have among other things concentration problem. You can't code very well if you have concentration problems....
01:58:05 <ralejs> But yes I've read the dataflow paper. It's cool stuff!
01:59:59 <shapr> Yeah, I think it might make for simpler reactive programming.
02:00:30 <shapr> musasabi wrote up a comonad library last night - http://www.cs.helsinki.fi/u/ekarttun/comonad/
02:01:24 <ralejs> Cool library! I should ask Henrik Nilsson about using it for reactive programming. He's the king of Yampa so he should know.
02:02:42 <shapr> Ah, I see that Dave Menendez also wrote something about this paper.
02:03:05 <shapr> http://permalink.gmane.org/gmane.comp.lang.haskell.general/12187
02:04:44 <shapr> ralejs: Yes, focus is very important for programming. Too bad I can't offer you some of my Ritalin ;-)
02:05:47 <ralejs> Yep, I also saw Dave's mail. We should really check that those laws hold but if they do his stuff shows that comonads are really useful.'
02:21:35 <ProfTeggy> G;day all
03:07:59 <Itkovian> meuning
04:57:47 <autrijus> does record syntax for GADTs make sense to anyone else than me? :)
04:58:55 <Heffalump> DYM for specifying the types?
04:59:05 <autrijus> # http://haskell.org/hawiki/HaskellIrcPastePage
04:59:50 <Heffalump> does that work? (I hope it does..)
05:00:18 <autrijus> no, I'm writing to simonpj to sanity check it and (gasp) volunteer to hack it into ghc
05:00:31 <Heffalump> record syntax is just sugar, isn't it?
05:00:37 <Heffalump> for the first argument etc
05:00:38 <autrijus> yup.
05:00:43 <Heffalump> so it should be here too
05:00:44 <autrijus> for selection and updating
05:00:56 <Heffalump> right
05:01:19 <autrijus> that, plus the already-granted feature request of deriving()for gadt
05:01:30 <autrijus> should make possible for gadt to take over the world ;)
05:02:55 * Heffalump is copying the perl source code onto his laptop now so I can put a perl without multiplicity on it.
05:03:16 <Heffalump> though I ssem to have put the one on my server in a chroot for some reason, I wonder why..
05:28:07 <kosmikus> autrijus: already-granted feature request of deriving()for gadt: reference?
05:28:26 <Heffalump> what makes deriving not work for them?
05:28:30 <Heffalump> (by default)
05:28:40 <kosmikus> Heffalump: not so simple in general
05:28:58 <kosmikus> Heffalump: it's simple for Eq or Show, but what about Read?
05:29:13 <Heffalump> ah, right
05:30:09 <kosmikus> I'm interested in whether the status of "already granted" implies that these problems are solved already ...
05:30:20 <autrijus> kosmikus: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg08338.html
05:30:25 <kosmikus> thanks
05:30:43 <autrijus> the caveat is that the term type
05:30:49 <autrijus> must be within vanilla h98
05:31:15 <autrijus> I don't know about whether Eq etc are made to work specifically
05:31:32 <Heffalump> so you only want records for GADT syntax without GADT features?
05:31:46 <kosmikus> ok, I see
05:31:59 <kosmikus> that's good, of course, but not the same as allowing deriving for real gadts
05:32:11 <autrijus> kosmikus: sure, I think it can be extended further
05:32:17 <kosmikus> I much prefer gadt syntax for all datatypes, too
05:32:28 <autrijus> Heffalump: I want _everything_ but I'm grateful to each intermediate step
05:32:39 <Heffalump> hangon, why is Read hard?
05:32:52 <Heffalump> any given call of read has a known static type
05:32:59 <Heffalump> so you know the type of the arguments to each constructor
05:33:43 <kosmikus> I'm not saying impossible, but still hard ... think about how this translates to instance declarations
05:34:12 <kosmikus> you cannot just give "instance Read (Term a)" ...
05:34:22 <Heffalump> I still don't see why not
05:34:38 <autrijus> another thing I'd like to do is fix haddock and drift so they grok gadt
05:34:48 <autrijus> I wonder if it's already being worked on
05:35:50 <kosmikus> Heffalump: if you have a "Term Int", you want to only allow terms constructed by "TInt" etc.
05:43:02 <musasabi> Having deriving work for higher order type parameters would be nice too.
05:43:17 <musasabi> e.g. the data Wrap w = Wrap (w (Wrap w)) case.
05:44:25 <kosmikus> that's just Fix, isn't it?
05:44:30 <kosmikus> still doesn't work?
05:44:41 <musasabi> nope deriving doesn't work.
05:45:30 <musasabi> and in practise the types are like data ComplexWrap w = C1 .. | Wrap (w (Wrap w)) (w (Wrap w)) | ... | CN
05:45:32 <kosmikus> that's no problem in theory, though; I think it's not there because you'd need quantified class constraints in Haskell
05:46:17 <kosmikus> use Generic Haskell, then :)
05:51:11 <kosmikus> for the Eq-instance of Wrap you'd need "instance (forall a. Eq a -> Eq (w a)) => Eq (Wrap w)" to be allowed in Haskell
05:51:21 <kosmikus> this is discussed in "Derivable Type Classes" ...
05:52:59 <musasabi> thanks, I'll read that paper.
06:18:07 <Blownose> if i have something like this  [[A]] and i want it to be [A] how do that ?
06:18:25 <musasabi> @type concat
06:18:25 <mauke> @hoogle [[a]] -> [a]
06:18:29 <lambdabot> forall a. [[a]] -> [a]
06:18:30 <lambdabot> Prelude.concat :: [[a]] -> [a]
06:18:30 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
06:18:30 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
06:18:47 <Philippa> damn, I appear to've missed most of the conversation about comonads completely
06:18:55 <Philippa> as in, didn't have a client running logging it :-(
06:19:18 <musasabi> well the logs are in the web (and better formatted than irssi does).
06:20:15 <Philippa> point
06:20:40 * musasabi is skipping class reading "Comonadic functional attribute evaluation"
06:22:34 <Philippa> might be an idea if a small comonad bibliography pops up on the wiki?
06:23:13 <Philippa> which class, anyway?
06:23:22 <musasabi> hmm that might make sense.
06:24:25 <musasabi> Just a math course on logics (and this one is covering things that an another logics course covered this week)
06:24:37 <xerox> musasabi: is that paper online?
06:24:44 <Philippa> am also wondering how hard comonad transformers are, stuff like that
06:24:58 <Philippa> (mostly because I'd like to try layering FRP on top of something ST-like)
06:25:46 <yaarg> musasabi: do you have a link to that paper?
06:27:02 <musasabi> yes, just a moment.
06:27:39 <musasabi> http://www.cs.ioc.ee/~tarmo/papers/tfp05.pdf
06:27:58 <musasabi> Is CoMonadArticles or CoMonad/Articles better?
06:28:41 * musasabi goes with the subpage.
06:29:35 <musasabi> except the wiki didn't like it.
06:29:58 <xerox> _%7f or something?
06:30:37 <xerox> _2f2
06:30:54 <xerox> Nah, Foo_2fBar  =~=  Foo/Bar.
06:34:23 <musasabi> http://haskell.org/hawiki/CoMonadArticles
06:34:27 <Philippa> thanks
06:35:07 <yaarg> musasabi: thanks
06:38:58 <Philippa> stupid question time: if it's possible to implement >>- and >>=-like operators on comonads, can we have =>> and .> on monads?
06:39:14 <Philippa> 'cos coeval exists on a large class of monads (IO not being one)
06:39:31 <Philippa> it's what's more normally a (possibly parameterised) runFoo func
06:40:25 <Philippa> I suspect there's a significant class of things that're both monads and comonads...
06:40:26 <musasabi> Philippa: see the code on my page.
06:40:55 <Philippa> URL?
06:41:03 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/comonad/ (under Combinators)
06:41:06 <Philippa> (hell, put it under CoMonadArticles?)
06:41:21 <Philippa> yeah, I saw that - it's the reverse set I'm thinking about
06:41:53 <Philippa> is there such a thing as a bimonad?
06:41:59 <Philippa> (both monad and comonad)
06:42:17 <xerox> id? :D
06:42:22 <musasabi> "(=>>)  :: w a -> (w a -> b) -> w b" should be trivial.
06:42:30 <Philippa> if so, are they useful and what class of transformer is required to retain bimonadicity?
06:42:57 <musasabi> a =>> b = return (b a)
06:43:20 <Philippa> many monads have an entire family of possible coeval functions
06:43:23 <musasabi> given (=>>) :: Monad m => m a -> (m a -> b) -> m b
06:43:52 <Philippa> point. Do the rules play well together?
06:43:57 <musasabi> .>> feels somehow wrong with comonads.
06:44:12 <musasabi> Or it seems hard to find an use for it.
06:44:28 <Philippa> there might be one in normally-lazy monads
06:44:47 <musasabi> The essence of dataflow had things about distributivity of monad comonad combinations, but I haven't had time to think about that section much.
06:45:26 <musasabi> comonad (monad a) -> monad (comonad a)
06:46:25 <musasabi> Philippa: do you think error or absence of value can be modelled in any way with comonads?
06:46:46 <Philippa> not sure, I've not done enough real thinking about it
06:47:22 <Philippa> my understanding of comonads is still at a pretty handwavey level, I've not got myself a good characterisation of what kind of semantics they support
06:49:14 <esap> There was some kind of guideline that "comonads are 'values-in-context'".
06:49:41 <Philippa> I'm not sure I get what "values-in-context" means sufficiently
06:50:20 <esap> It means a value together with a context. The value can depend on the names specified in the context.
06:50:24 * musasabi thinks of monads as computations in a context and computations are values thus monads are just values in a context :-(
06:50:51 <esap> musasabi: hehe, but computations are not values.
06:51:23 <Philippa> but with the comonadic signiature I still have to extract values from their context/computation with coeval
06:51:57 <musasabi> esap: are they not first-class?
06:53:15 <esap> musasabi: They are not in normal form.
06:53:37 <esap> musasabi: Not fully reduced
06:54:41 <esap> musasabi: a computation can produce a value *when* it is evaluated. But before it has been evaluated, there is big difference between a value and a computation.
06:55:27 <esap> musasabi: There are also values that *represent* computations. But those are also not the same as the computation itself.
06:55:35 <musasabi> esap: But a value might not be possible to evaluate either.
06:55:53 <musasabi> (or I just happen to have a funny notion of a value)
06:55:58 <Philippa> congratulations, you reinvented the non-termination monad ;-)
06:56:19 <musasabi> e.g. would you consider foo :: Int, foo = foo to be a value or a computation?
06:56:36 <Philippa> a value. Specifically, bottom
06:57:57 <esap> musasabi: that's a value that represents the infinite computation.
06:57:58 <Philippa> I sort-of have a hunch about ordering being reversed, "earlier" computations can depend on effects from "later" ones...
06:59:31 <xerox> Is there an abstraction which performs get/put of a record with updated contents?
06:59:41 <musasabi> esap: My logic was that in a language where we can treat computations as objects they are values, but I can now see why it leads easily problems.
06:59:56 <musasabi> (values in the sense of that language)
07:00:04 <esap> musasabi: the comparison to foo :: IO a ; foo = do { foo }  is interesting.
07:00:46 <Philippa> xerox: not really, but modify functions give you something close
07:01:07 <Philippa> modify (\x -> x {foo = bar})
07:01:08 <xerox> Philippa: good, I can't find the doc, though - any idea where is it?
07:01:11 <Cale> hmm... I wonder if a variant of comonads would be useful where rather than  extract :: w a -> a, we had extract' :: a -> w a -> a, where an initial value was provided. Types in this class would contain an embedded comonad, plus some "failing" values.
07:01:46 <Philippa> modify's just the obvious get-then-put
07:02:03 <shapr> Is there some easy way to read text out of a pdf with Haskell?
07:02:19 <adept> pdf2text + readFile ? :)
07:02:25 <shapr> adept: Probably so, thanks :-)
07:02:42 <Cale> after all, =>> is nothing but a huge generalisation of scanl1 :)
07:02:56 <Cale> why not generalise scanl in the same way? :)
07:03:23 <Philippa> parameterised extract's useful more generally
07:04:30 <shapr> adept: Do you know if pdf2text is in debian/unstable?
07:04:42 <musasabi> Cale: or have class CoMonad Proxy2 w a => CoMonad w where counit :: w a -> a; (although I am not yet sure how to do cobind.
07:05:14 <esap> Proxy2?
07:05:24 <musasabi> "class Proxy2 a b"
07:06:36 <adept> shapr: yep. it's xpdf or some xpdf-related package
07:06:44 <musasabi> so it would be possible to define "instance Proxy2 MaybeComonad (Maybe a)" and thus sidestep issues with errors.
07:07:04 <musasabi> The SYB3 encoding technique.
07:08:15 <shapr> adept: thanks, it's pdftotext
07:08:58 <Philippa> you could also try adding an error-value field to both Maybe's constructors
07:09:09 <Philippa> that way you specify how to handle errors at construction-time
07:10:43 <adept> shapr: silly me. of course. NB: it tends to interleave text from different blocks for fancy-formatted documents (with callouts, flowed-around quotations and so on), so be warned
07:12:24 <shapr> Thanks for the warning.
07:14:05 <musasabi> google converting pdf-to-html and a text-mode browser with the ablity to dump to text is sometimes a good way too.
07:19:55 <Philippa> ooh, just had another thought...
07:19:57 <xerox> Is GHC smart enough to not calculate f x as many times as it is used in the same function, without explicitly using |where foo = f x|, and foo?
07:20:15 <Philippa> the ST monad's references-limited-to-this-scope trick... what happens when you try it with comonads?
07:20:51 <Philippa> my gut feeling is references bound to a specific coeval...
07:21:00 <Philippa> but I don't know what you get from that
07:21:20 <musasabi> There is some stuff to finegrained parallel eval with comonads.
07:21:38 <musasabi> The Codata and Comonads in Haskell paper has it.
07:22:19 <musasabi> Section 3.2.4 A comonad of parallel threads
07:22:36 <Philippa> so they got references bound to their threads?
07:23:54 <musasabi> no, I don't think so.
07:28:25 <Sickjacken> is it appropriate to talk about multiple roots in the presence of a directed graph?
07:28:51 <Sickjacken> or am i abusing terms here?
07:29:09 <wilx> Hm.
07:29:12 <Philippa> is the graph acyclic?
07:29:15 <wilx> Only trees have roots :)
07:29:23 <wilx> If it is a tree than it can have roots.
07:29:43 <Philippa> um. Trees have exactly one root, pretty much by definition
07:29:52 <int-e> if you're doing garbage collection then you're on safe ground - they abuse the term like that already :)
07:30:41 <Philippa> it makes some sense on some non-tree graphs as eg "one of a minimal set of nodes from which all nodes can be reached"
07:30:49 <Sickjacken> Philippa, the graph can contain cyclic parts, but there is always a clear entry point (sometimes multiple) im struggling what to call these entry points
07:31:10 <Sickjacken> i was tempted to call them roots
07:31:19 <Sickjacken> but i dont know if that is correct
07:32:39 <int-e> I'd think calling them roots does no real harm - explain what you're doing. You could call them minimum elements and treat the graph as a relation ... but that's not very intuitive.
07:33:09 <Sickjacken> well, the directed graph represents the dependencies of how to calculate data flow equations.
07:33:40 <Sickjacken> i want to tell that the roots need initial values basically
07:34:04 <Philippa> "initial dependencies"?
07:34:51 <int-e> oh - but that seems to rule out (directed) cycles (A->B->C->A)? then you have a directed acyclic graph.
07:34:52 <Sickjacken> hmmm
07:35:24 <Sickjacken> no it can be cyclic because a system of dataflow equations can easily be cylic...it will just stabilize at a certain point
07:37:06 <Sickjacken> actually, it could be completely cyclic
07:37:14 <Sickjacken> so using root is not appropriate
07:40:28 <srle> hi
07:40:46 <Sickjacken> hi
07:42:20 <srle> Why following thing doesnt work ih haskell? connect s (SockAddrInet 80 "google.com")
07:45:32 <dons> oh wow. house talk is being given on slides running on house!
07:45:50 <srle> Why doesnt following thing work ih haskell? connect s (SockAddrInet 80 "google.com")
07:46:00 <Philippa> dons: cool
07:48:25 <srle> can somebody help me?
07:50:02 <musasabi> srle: you might want to try Network.connectTo
07:51:24 <Sickjacken> heheh thats the standard procedure...build a tool that processes the tool itself again...that sorta thing
07:52:00 <musasabi> srle: the Network.Socket is basically the same as the C API.
07:52:23 <musasabi> dons: have they talked about the microkernel in Haskell thing?
07:54:31 <srle> thatnks
07:54:52 <shapr> musasabi: Yeah, we want to hear about the L4 microkernel work as well.
07:55:02 <shapr> er, dons
07:55:09 * shapr gets confused from doing too many things at once.
07:55:42 * cm untangles shapr
07:55:46 <shapr> hiya cm!
07:55:50 <cm> hey there
07:56:36 <musasabi> L4 abstractions are not as nice as they could be if one is interested in a capability based design.
07:58:07 <shapr> hej bojohan
07:58:30 <bojohan> hej
07:59:00 * Itkovian is bored
07:59:03 <musasabi> But there is nothing better. (but eros has some nice design advantages - but there are other areas where L4 is nicer)
07:59:07 <dons> musa, talking about L4-haskell now
07:59:47 <xerox> Hello bojohan!
07:59:57 <bojohan> hello :)
08:00:03 * int-e was just going to ask if musasabi knows EROS :) - L4 started out to be as policy free as possible so capabilities in the kernel weren't originally supported; the latest developments go into that direction however.
08:01:03 <shapr> Itkovian: learn about comonads!
08:01:22 <Itkovian> yeah, I'd love to, but first I need to grok monads a bit better
08:01:35 <Itkovian> I think I'm delving too deep, instead of just applying the stuff
08:01:48 <shapr> xerox: It's called common subexpression elimination. It's on by default.
08:01:57 <xerox> shapr: good, good.
08:02:19 <shapr> xerox: Though I think -fno-cse and -O0 (or is it -OO?) turns off CSE.
08:02:24 <musasabi> => home
08:02:40 <xerox> Bye bye musasabi.
08:03:01 <xerox> Anyway I found a clever way to avoid many typing by pattern matching.
08:03:10 <xerox> (In the particular case)
08:03:45 <srle> how to convert "google.com" to "x.y.z.w" in haskell?
08:04:10 <shapr> srle: http://cvs.haskell.org/darcs/http/
08:04:19 <shapr> hoi roconnor
08:04:22 <shapr> long time no see
08:04:26 <roconnor> hi
08:04:30 <roconnor> how are things
08:04:42 <shapr> Quite nifty, have you seen comonads?
08:04:54 <srle> shapr: thanks
08:05:00 <roconnor> sort of.  They didn't seem to work very well last time I looked.
08:05:40 <roconnor> someone was advocating that it made better IO, but I remained unconvinced.
08:06:16 <shapr> There's a new Uustalu & Vene paper, and other goodies: http://lambda-the-ultimate.org/node/view/988
08:07:38 <roconnor> Estonia!
08:11:22 <roconnor> I must go for dinner now.  I'll read the paper when I get back. Thanks.
08:34:21 <shapr> It occurs to me that SASL, DHIS, and lots more would be subsumed into a decent remote capability protocol.
08:43:20 <ulph> @type System.IO.Unsafe.unsafePerformIO
08:43:22 <lambdabot> forall a. IO a -> a
08:46:34 <xerox> Prelude> reverse . takeWhile (/='.') . reverse $ "/blah.html"
08:46:34 <xerox> "html"
08:46:34 <xerox> Anything smarter than that?
08:47:18 <shapr> You could split "."
08:47:38 <ulph> dropWhile?
08:47:45 <ulph> Or maybe not :)
08:48:31 <xerox> split!  good good idea.
08:49:24 <ulph> blah.foo.html won't split well though :/
08:49:57 <shapr> ulph: Sure it will. last $ split "."
08:50:43 <xerox> :-)
08:51:08 <ulph> @index split
08:51:09 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.
08:51:09 <lambdabot> Haskell.TH.Ppr, System.Random
08:51:25 <xerox> I was wondering where it was.. :D
08:51:39 <ulph> I know about splitAt but not split
08:51:46 <xerox> @type splitAt
08:51:51 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:51:55 <dons> shapr, have you read http://www.cse.ogi.edu/~hallgren/ICFP2005/?
08:52:14 * shapr looks
08:52:15 <xerox> Mumble.
08:52:48 <shapr> Oh yeah, I've read that one, it's nice. No screenshots though.
08:53:02 <xerox> shapr: where is split?!
08:53:03 <shapr> I particularly like the hardware monad. That's seriously awesome!
08:53:14 <shapr> xerox: PreludeExts, and lambdabot. tmoertel wrote split.
08:53:22 <xerox> Good.
08:53:26 <dons> yeah, talk was really impressive
08:53:41 <dons> kind of quickcheck-as-comments/annotations, with tool support
08:53:52 <shapr> That's Programatica, saw it at ICFP2003
08:54:02 <int-e> @index splitFileExt
08:54:03 <lambdabot> Distribution.Compat.FilePath
08:54:15 <pejo> shapr, is it the House article? A bunch of screenshots on the homepage iirc.
08:54:25 <dons> oh, I had the impression they'd extended it for House
08:54:37 <shapr> Maybe so?
08:54:50 <shapr> I'm really good at missing stuff ;-)
08:54:56 <ulph> hm
08:54:59 <dons> or maybe that's how they presented their house work, in a reusable way. i'll have to check
08:55:52 <shapr> pejo: Those screenshots only show the first working version of Noble's Gadgets GUI stuff. If they have Programatica running on House, I want to know!
08:56:33 <shapr> Personally, I hope JaffaCake adds priority to the GHC scheduler, and that House gets into base GHC.
08:56:45 <shapr> Then I could run House -smp on my dual Athlon MP! w00!
08:57:21 <pejo> shapr, and run hello really fast!
08:58:27 <dons> hehe
08:58:31 <shapr> I want to try Halfs (the Haskell filesystem) in House.
08:58:39 <dons> we should start contributing plugins
08:58:53 <pejo> dons, don't you ever run out of time? :-)
08:58:56 <shapr> Someone suggested using TH in House, but you can't use it without a filesystem. But now...
08:59:15 <dons> i wonder if the code is in darcs. for seem reason house doesn't get a lot of press (compared to what it's doing)
08:59:22 <shapr> I have a some spare boxes now that I could run House on.
08:59:43 <shapr> Let's see... House for the OS, Postmaster for the MTA... Yi for the editor... what am I missing?
08:59:51 <dons> oh, i finally found out what House stands for..
08:59:51 <shapr> Oh right, we need a mail client. Riot is a good starting place.
09:00:19 <shapr> I very much wish I could have been there for CUFP and "future of haskell"
09:00:25 <shapr> I have so much I'd like to say :-/
09:00:27 <pejo> shapr, port Gnus to Yi!
09:00:37 <dons> 'You feel more secure in a House, than if you just have Windows'
09:00:41 <shapr> haha!
09:00:53 <dons> that's their slogan :)
09:01:08 <shapr> I thought of hIp hOp / House
09:01:21 <shapr> and stepcut joked that Hugs on the bare metal was bOing!
09:01:45 <dons> hip hop house makes sense.
09:01:59 <shapr> haskell Interface protocol?
09:02:07 <dons> bOing? maybe i'm sleepy
09:02:18 <shapr> hOp and bOing
09:02:25 <dons> oh, oops yes :)
09:03:22 <shapr> Maybe I should write an email to Daan, he's running HW2005, right?
09:03:43 <shapr> Yes, he is.
09:04:14 <dons> yep he is. what do you want to ask him?
09:04:40 <shapr> Nothing really, I just have a bunch of ideas and suggestions for the future of Haskell.
09:05:20 <ulph> xerox: btw, check the function isSuffixOf
09:05:33 <autrijus> shapr: I spoke out in CUFP a bit about setting up onlamp.com and perlmonks.org style things for fp.
09:05:47 <dons> autrijus, did you see spj's shirt today?
09:05:51 <autrijus> because it seemed that the chair @ galois wants to set up something like that, so I chimed in
09:05:55 <autrijus> dons: yes. :)
09:05:56 <shapr> Yes!
09:06:05 <autrijus> I also gave one to b. pierce :)
09:06:08 <shapr> autrijus: That's definitely part of what I want.
09:06:11 <shapr> autrijus: oh awesome!
09:06:19 <shapr> I bet he enjoyed that.
09:06:33 <autrijus> I see people commenting on it -- especially the timeline picture on the back -- with him ultiple times.
09:06:38 <autrijus> it delighted me much.
09:06:48 <dons> hehe :)
09:06:57 <autrijus> shapr: also I volunteered to hack record syntax into GADT with spj -- we'll see if he likes that idea
09:07:16 <autrijus> data Term a where
09:07:16 <autrijus>     Lit    { val   :: Int }       :: Term Int
09:07:18 <dons> i tried to spot you btw, but didn't :/ though had a good talk to wolfgang
09:07:22 <autrijus>     Succ   { exp   :: Term Int }  :: Term Int
09:07:22 <autrijus> etc.
09:07:28 <autrijus> dons: where are you now?
09:07:34 <shapr> Why is record syntax useful?
09:07:36 <dons> at my hotel, actually.
09:07:47 <autrijus> shapr: er, so we can rewrite everything into GADT?
09:08:04 <shapr> How so?
09:08:05 <autrijus> it's pegagogically significant
09:08:18 <autrijus> the same motivation as adding deriving()to gadt
09:08:23 * shapr thinks about that.
09:08:38 <dons> autrijus, is the graphic on the back of the shirt online somewhere?
09:08:51 <shapr> I've been doing webmonkey Python/SQL stuff for days... must reformat brain!
09:08:51 <musasabi> A good mail client would be very nice.
09:08:53 <autrijus> dons: http://pugscode.org/images/timeline.png
09:09:07 <dons> that's the one
09:09:19 <xerox> I want the HM_tshirt :-(
09:09:20 <musasabi> Automatic sorting of new messages to mailboxes based on their current contents would be a good feature.
09:09:24 <autrijus> the t-shirt dropped the gradient, "community goodwill", and used comic sans for the title
09:09:52 <autrijus> going to ICFP reception & bbiab
09:09:54 <shapr> autrijus: I still don't get it. How is record syntax pedagogically significant?
09:10:10 <autrijus> shapr: (Foo a b c d e f g h)
09:10:14 <autrijus> is not very readable.
09:10:28 <shapr> Maybe it'll hit me in a flash... (or even a <BLINK>).
09:10:35 <autrijus> also Pugs's use of DrIFT to emit labeled trees from data declarations
09:10:38 <autrijus> in JSON and Perl5 etc
09:10:44 <autrijus> so having field names is a _definite_ win
09:11:37 <autrijus> but gotta run. ttul &
09:11:38 * shapr thinks about that.
09:11:40 <shapr> ok, cya.
09:12:17 <shapr> Oh, I get it!
09:12:28 <shapr> Hm, that is neat.
09:12:38 <xerox> @index isPrefixOf
09:12:39 <lambdabot> Data.List
09:27:32 <shapr> hiya david_
09:27:43 <davve> hi
09:28:52 * shapr boings
09:31:18 * musasabi bakes some lambdas
09:31:28 <shapr> mmm, lambda kebab!
09:38:42 <araujo> @hoogle usageInfo
09:39:21 <shapr> This is wild - http://lambda-the-ultimate.org/node/view/608#comment-10116
09:40:06 <araujo> Anyone knows that function?
09:40:29 <shapr> @google usageInfo filetype:hs
09:40:31 <lambdabot> http://repetae.net/cgi-bin/darcs.cgi/DrIFT/src/GetOpt.hs?c=annotate&p=20041201085915-a825d-d71e26ce1c23ab7619840f6213337098f2afad8b.gz
09:41:14 <shapr> It appears to be part of the Haskell gnu getopt implementation.
09:41:17 <Sickjacken> arghhh whats the use of email if i still have to call the person on the receiving end for not responding
09:41:29 <shapr> hiya Baughn, learning Haskell?
09:41:37 <shapr> Sickjacken: It can use up your time!
09:42:03 <Sickjacken> i know, the man on the receiving end is a busy man indeed....but hey...he wants the software im writing!!
09:42:09 <araujo> shapr, yeah
09:42:16 <int-e> Sickjacken: you can print it out and archive it. :P
09:42:19 <musasabi> Sickjacken: but many times you have to irc to the person to put his/her phone on ;)
09:42:25 <shapr> haha
09:42:38 <Sickjacken> hahaha
09:43:02 <Sickjacken> hey if this guy doesnt react on my mail this week, he's not getting tested software
09:44:26 <Baughn> shapr: So I am. Well, trying to...
09:44:56 <Baughn> shapr: The tutorials are all full of language details, and short on ghc invocation details. I hope installing it *with* documentation will help with that, though.
09:46:03 <shapr> Baughn: This is a simple language details intro - http://www.haskell.org/hawiki/HaskellDemo
09:46:46 <Baughn> shapr: Thanks. Still no invocation, but I *assume* that will be in the compiler docs. ;)
09:47:30 <shapr> Save the syntax highlit part of that page as HaskellDemo.hs, then run "ghci HaskellDemo.hs" in the same dir.
09:48:40 <Baughn> Is there some reason why a file consisting of the single line "main = putChar 'a'" wouldn't work?
09:49:02 <shapr> Hm, I think that would work.
09:49:09 <shapr> Haven't tried it myself though.
09:49:15 <Baughn> It compiles to a.out, but does nothing.
09:49:26 <shapr> try running it. ./a.out
09:49:35 <shapr> Oh, I get it.
09:49:45 <shapr> Try main = putStrLn "a"
09:49:48 <araujo> What is a function to remove a specific element in a list?
09:49:53 <Baughn> If I use "-o test", I get "compilation IS NOT required", and a bunch of other files.
09:50:16 <shapr> Baughn: Thing is, GHC is line buffered by default. If you write out a single char, you won't see it.
09:50:40 <Baughn> shapr: I'd assumed it would flush its buffers when closing them, but.. ok.
09:50:59 <Baughn> That works, though. Yay!
09:51:49 <araujo> you could do, main = do{ putChar 'a'; putChar '\n'}
09:51:55 <int-e> Baughn: it does flush them; maybe your prompt is overwriting the output?
09:52:26 <Baughn> int-e: It does not.
09:52:27 <int-e> try  ./a.out;echo
09:53:03 <araujo> Anyone knows a pre-defined function remove an element of a list?
09:53:13 <Baughn> OKay, that worked. Unintuitive, but... now I know how it works. Thanks a lot!
09:53:43 <shapr> Baughn: There was a recent discussion on LtU where someone said "After the nipple, nothing is intuitive."
09:53:48 <int-e> it flushes the buffer; it still doesn't add a newline (why would it?) - but echo just prints a newline.
09:54:21 <Baughn> Yess, but if I do the same in C I get "a<prompt>" on one line.
09:54:28 <dons> hFlush guys
09:54:40 <int-e> hmm. and with this you don't? that's strange indeed.
09:55:19 <Baughn> ..hang on....
09:55:50 <Baughn> I could strangle that OS. Gentoo did it.
09:56:08 <shapr> @index hFlush
09:56:09 <lambdabot> System.IO
09:56:26 <shapr> main = putChar 'a';System.IO.hFlush
09:56:32 <shapr> err
09:56:35 <shapr> Something like that.
09:56:46 <shapr> @type System.IO.hFlush
09:56:48 <lambdabot> GHC.IOBase.Handle -> IO ()
09:56:53 <shapr> Yeah, it wants a handle as input.
09:56:58 <araujo>  main = putChar 'a';System.IO.hFlush stdout
09:57:02 <Baughn> Nope, Gentoo did it. It's set PS1 to something involving \r.
09:57:13 <dons> hFlush stdout
09:57:15 <prionic> anyone knows something about problems with hs-plugins load/reload stuff?
09:57:22 <shapr> prionic: What problems?
09:57:29 <araujo> Nobody knows?
09:57:34 <shapr> prionic: dons might know. He wrote hs-plugins.
09:57:35 <dons> ask away prionic.
09:57:54 <prionic> hspr seems to be broken if it comes to reload a changed source file
09:57:54 <dons> araujo, delete?
09:58:37 <dons> List.delete: -- | 'delete' @x@ removes the first occurrence of @x@ from its list argument.
09:58:39 <prionic> everything compiles fine, but ill alway get the same result
09:58:59 <dons> sounds like an hspr issue, not hs-plugins
09:59:19 <dons> i.e. the code that uses the library, not the library itself
09:59:29 <araujo> dons, oh, yeah, something like that, but i was looking for a function to remove all of the ocurrences if possible
09:59:55 <dons> araujo, filter!
10:00:32 <prionic> dons: whats hspr does is load, then reload
10:00:57 <dons> @eval filter (/='l') "haskell is cool"
10:01:00 <lambdabot> "haske is coo"
10:01:11 <araujo> Thanks dons
10:01:40 <dons> prionic, feel free to send me a bug report, but i certainly need more info before I can debug this. if you construct a minimal testcase, that would really help
10:02:03 <prionic> dons: wasnt there something about reloading the same .o more than once?
10:02:24 <dons> you can reload objects, that's fine.
10:02:39 <dons> the yi demo i'm going to give in a couple of days depends on this working ;)
10:03:01 <shapr> Can you dynamically load the GTK frontend?
10:03:12 <dons> sure. that's what hide does
10:03:43 <davve> yi demo? :)
10:03:45 <davve> what kind of demo?
10:03:46 <dons> (you can't reload though. well you could but we don't yet)
10:04:01 <dons> davve, haskell workshop 2005
10:04:11 <davve> dons, ah.. where's that?
10:04:19 <tic|afk> davve, so, up at 08? :)
10:04:21 <shapr> Tallin!
10:04:21 <dons> tallinn, estonia
10:04:26 <davve> okay
10:04:39 <davve> tic, hmm.. we'll see? :)
10:05:14 <tic|afk> davve, yah. I'm not too, uhm, up right now, either.
10:05:25 <tic|afk> davve, but that's basically the only time we have off tomorrow.
10:05:40 <davve> tic, mm..
10:06:40 <shapr> pejo: Don't you enjoy discussing with Brandon vE?
10:06:45 * shapr cackles evilly
10:07:10 <tic|afk> yay for living your life on IRC... :(
10:07:22 <pejo> shapr, I'm overly optimistic about people a  lot of the time. Unfortunately.
10:08:03 <dons> pejo, hehe :)
10:08:29 <pejo> I find it a bit odd to claim results are invalid because they are "old", without having read the papers.
10:08:29 <shapr> pejo: He's totally wrong, but I doubt he'll listen to anyone. On the other hand, I wonder if leaving his clueless comments unchallenged leads newbies to believe he's right.
10:08:56 <shapr> Hiya Kirby
10:09:08 <davve> whats he saying this time?
10:09:13 <pejo> shapr, I could see why people think he's right. He's obviuosly very sure he has the right answer.
10:09:34 <shapr> confidence /= clue
10:09:48 <Philippa> pejo: he was confusing micro-optimisations (instruction scheduling, stuff like that) with those the next level up
10:09:55 <shapr> Lemmings jump off cliffs with great confidence.
10:10:13 <pejo> shapr, but I appear less confident, therefore I don't know anything! Atleast it's pretty easy to reason that way.
10:10:15 <ulph> shapr: lambdabot has disappeared from #unicycling!
10:10:19 <shapr> oh no!
10:10:23 <Philippa> part of the problem is that Brandon thinks he knows things about optimisation
10:10:24 <Kirby> hi shapr
10:10:26 <dons> @yow
10:10:28 <lambdabot> Did YOU find a DIGITAL WATCH in YOUR box of VELVEETA?
10:10:33 <Philippa> when talking strictly about machine code written by hand, he does
10:10:41 <shapr> Kirby: Have you been here to #haskell before?
10:10:47 <Kirby> shapr: no
10:10:53 <shapr> Ok, would you like the short tour?
10:11:08 <Kirby> shapr: okay. I don't really know the programming language.
10:11:09 <dons> shapr, please start the tour. it's been a while since we've had one
10:11:44 <shapr> Ok, first on your left you have the famous lambdabot. lambdabot is an irc bot written in Haskell and has lots of useful features to help you find stuff, both Haskell and non.
10:12:07 <pejo> Philippa, would you say the optimistic evaluation and the Boquist stuff is 'next level up'?
10:12:17 <dons> @eval 1 + 2
10:12:19 <lambdabot> 3
10:12:24 <dons> @type 1
10:12:25 <lambdabot> forall t. (Num t) => t
10:12:27 <shapr> Next there's the Haskell wiki. The Haskell Wiki is a repository of much useful information, both beginner quality and flat out esoteric: http://www.haskell.org/hawiki
10:12:51 <shapr> After that, there are the logs for this channel. You can find the url to those in the channel topic.
10:12:55 <Philippa> pejo: Much of Boquist's work is a level up from that, yes. What he does with case statements, for example
10:12:59 <shapr> @learn Last but not least, the learning Haskell page!
10:13:00 <lambdabot> http://www.haskell.org/learning.html
10:13:01 <Philippa> optimistic evaluation definitely is
10:13:28 <shapr> Kirby: If you want a short syntax intro, I like http://www.haskell.org/hawiki/HaskellDemo
10:13:52 <Kirby> @eval f(10); f(x) = f(x-1) + f(x-2); f(1)=1;
10:13:54 <lambdabot> 23: parse error on input `;'
10:13:59 <Philippa> optimistic evaluation is something you can implement while compiling to C. That pretty much makes it a level up by definition
10:13:59 <dons> almost ;)
10:14:00 <shapr> Kirby: After you've read the HaskellDemo, you might like Hal Daume's "Yet Another Haskell Tutorial", which is linked from the Learning page.
10:14:18 <shapr> And of course, you can ask questions here on #haskell.
10:14:37 <Kirby> Thanks muchly for the tour.
10:14:43 <dons> @eval let f 1 = 1; f x = f (x - 1) + f (x - 2) in f 10
10:14:44 <sylvan> @eval let f 1 = 1 ; f x = f (x-1) + f (x-2) in f 10
10:14:46 <lambdabot> Stack overflow
10:14:47 <lambdabot> Stack overflow
10:14:49 <dons> hehe
10:14:50 <sylvan> =)
10:14:56 <pejo> Philippa, sure. If anything "above the C compiler" is 'next level' that doesn't leave much of the stuff Boquist did. Probably only the interprocedural register allocation and the standard textbook compiler stuff.
10:15:18 <Kirby> @eval let f 1 = 1; let f 2 = 1; f x = f ( x - 1 ) + f ( x - 2 ) in f 10
10:15:20 <lambdabot> 83: parse error on input `)'
10:15:34 <dons> no second let
10:15:42 <Philippa> pejo: exactly
10:15:45 <sylvan> @eval let f 1 = 1; f 2 = 1; f x = f ( x - 1 ) + f ( x - 2 ) in f 10
10:15:46 <lambdabot> 55
10:15:51 <Kirby> yay
10:16:08 <dons> shapr, lambdabot is much more responsive now builds get done during the morning
10:16:14 <dons> at least it seems that way
10:16:25 <pejo> Philippa, well, shapr is pretty right though. I probably deserve a bit mocking for trying to inform him.
10:16:26 <shapr> yay!
10:16:32 <pejo> (him = Branden, not shapr).
10:16:33 <Cale> @eval let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10
10:16:35 <lambdabot> 89
10:16:39 <Cale> @eval let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 9
10:16:40 <lambdabot> 55
10:16:47 <shapr> pejo: No, I think BvE deserves mocking. You're just trying to help.
10:16:55 <dons> @pointless let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 9
10:16:57 <lambdabot> fix ((1 :) . (1 :) . ap (zipWith (+)) tail) !! 9
10:17:01 <dons> oh boy
10:17:13 <shapr> I am so very tempted to reply in a less than polite manner.
10:17:28 <pejo> shapr, I should get the hint when nobody is interested in listening though.
10:18:00 <shapr> LtU was founded on the idea that the members want to get knowledge from each other.
10:18:06 <Philippa> Brandon clearly considers it issue closed...
10:18:18 <shapr> Even though he's wrong.
10:18:55 <pejo> It's a lot easier to just let it go though, doing something constructive is better way to spend time.
10:19:12 <Philippa> as for the industrial issues, I'm tempted to just say "look, MS are hiring the hell out of folks working on this stuff - I think we've got the industrialisation sorted"
10:19:21 <sylvan> what are you guys talking about? Where does this discussion take place?
10:19:25 <Baughn> Brandon J. Every?
10:19:28 <Philippa> yup
10:19:35 <shapr> Baughn: You know him too?
10:19:45 <Baughn> shapr: He's spent some time in comp.lang.lisp.
10:19:48 <shapr> Ah yes.
10:19:56 <Philippa> look on the bright side
10:19:57 <Baughn> shapr: And in comp.lang.python, comp.lang.forth, comp.lang.smalltalk...
10:20:01 <Philippa> I moderate a mailing list with him
10:20:04 <Baughn> He's a troll, plain and simple.
10:20:19 <shapr> He's irritated these communities that I know of: Python, OCaml, Smalltalk, Ruby, Lisp, freeciv, forth, Haskell...
10:20:24 <Philippa> not in the traditional meaning of the word
10:20:35 <Baughn> freeciv?
10:20:35 <Philippa> he *is* an idiot and an arsehole, admittedly
10:20:48 <shapr> Baughn: Yeah, he does not limit himself to programming languages.
10:20:57 <Baughn> One does not need to be aware of trollhood to be a troll.
10:21:54 <Philippa> he probably POed the Nebula Device folks as well
10:21:56 <shapr> sylvan: Here's a good example - http://lambda-the-ultimate.org/node/view/976#comment-9944
10:22:22 <shapr> "I bet you can't find me *1* paper on the use of monads to achieve performance optimizations. I'd definitely like to take a look at such a paper if you've got one. And please, will all posters spare us the indirected chain of reasoning that because you like pure FP, it must by rights provide performance somehow. Stick to what can be demonstrated."
10:22:52 <Philippa> note that just about everyone who'd said FP can provide performance was giving examples of algebraic manipulations that're only safe given purity
10:23:11 <Philippa> brandon's reaction when I talked about preconditions for applying optimisations was... amusing. In a very, very stupid kind of way
10:24:07 <shapr> This is his reaction - http://lambda-the-ultimate.org/node/view/976#comment-10050
10:24:36 <shapr> "In theory, practice doesn't matter - In practice, practice matters. Or how does that saying go, exactly? Anyways, given the 30 year history of FP, I wouldn't trivialize the problems of bringing compiler technology into widespread industrial use, or claim it's incomparable to the problems that AI and VR people have faced. Hard mathematics is a pile of modeling hopes. That's what you're managing."
10:24:39 <Kirby> What are some suggestions for implementing http://rafb.net/paste/results/grHqFf65.html in Haskell?
10:25:32 <shapr> comonads! w00!
10:26:03 <Kirby> Basically, I think, I need two functions, where a(0) = false and b(0) = false. Then I need to have the results of a(1..) depend on the lower values of b(), and the results of b(1...) depend on the lower values of a(). I think.
10:26:09 <Philippa> the "30 year history" is at least 45 depending on when you choose to count from...
10:26:30 <edwinb> would I be entertained or irritated if I read this thread? or both?
10:26:35 * edwinb has 20 minutes or so to waste...
10:26:44 <Philippa> probably more irritated than entertained
10:27:06 <shapr> edwinb: Plus, it might take more than 20 minutes
10:27:22 <edwinb> hmm, oh well.
10:27:55 <pejo> Philippa, somehow I don't think MS will support GHC in the commercial sense.
10:29:29 <sethk> I'm looking at it.  Some of the responses _to_ this BJE (BVE?  whomever) are funny
10:29:46 <Philippa> no. Much of where they're going with C# is increasingly functional though
10:29:59 <Philippa> sethk: any in particular?
10:30:15 <sethk> well, is he a troll?  what is a troll?
10:30:59 <Philippa> someone who gets off on causing arguments online
10:31:22 <sethk> I understand that, more or less.  :)  I meant there are interesting comments in the thread about whether he is a troll, or not.
10:31:58 <sethk> He does seem to favor sweeping totally unjustifiable generalities
10:31:58 <sylvan> shapr, my oh my, he's quite a character
10:32:44 <sethk> he certainly doesn't understand parallel computing
10:33:02 <shapr> There's a lot he doesn't understand. But he has confidence that he does.
10:34:55 <Philippa> somebody fed him the "FP = easy parallelisation" line a while back, I suspect
10:35:09 <sethk> Hm, one of the comments says something about a "K5" troll.  What's K5?
10:35:37 <Philippa> kuroshin. Like slashdot only six months less retarded at any given time
10:36:26 <sethk> Philippa, k.  :)
10:39:09 <Philippa> one of the problems is that Brandon really can't tell hype from stuff with a solid technical backing
10:39:30 <Philippa> so he assumes it's all the former until he sees a commercial-grade implementation
10:39:36 <shapr> What about GHC?
10:39:51 <Philippa> it's slower than ocaml, therefore purity loses
10:40:01 <Philippa> because he doesn't realise what laziness costs because he's not thought about it
10:40:26 <sethk> the idea that the ghc developers don't care about performance is comical
10:40:39 <shapr> Also the idea that no one makes money off of Haskell.
10:40:56 <Philippa> it's true that there's no asm nut writing a stupefyingly fast x86 back end, but that's not "not caring"
10:41:29 <sethk> Philippa, I don't see anyone writing a stupefyingly fast x86 back end to _anything_
10:41:35 <Philippa> ocaml's got one
10:41:44 <shapr> sethk: Doesn't tzi.de do some commercial work with Haskell?
10:42:04 <sethk> shapr, that sounds right, but my memory isn't perfect
10:42:21 <sethk> shapr, I'm trying to do so as well.  With very limited success so far, but I'm not giving up yet.
10:42:29 <Philippa> ocaml code goes fast almost entirely because the back end's hot - it doesn't have half the sophistication of GHC when it comes to high-level optimisations
10:42:35 <sethk> shapr, especially since there are still parts of the language I don't fully understand.
10:42:55 <dons> Philippa, really?
10:43:01 <shapr> I think those of us who would like to do commercial work with Haskell should get a mailing list or some sort of discussion forum.
10:43:10 <dons> i'd always assumed it was strictness that made it easy for them.
10:43:11 <sethk> Philippa, that should be easy to demonstrate by running side by side tests, ocaml vs. haskell, somewhere other than x86
10:43:27 <Philippa> strictness makes it easy for the back end to be good
10:43:36 <shapr> OCaml also sacrifices safety for speed. Int size is by cpu, and overflows are not reported.
10:43:57 <Philippa> bear in mind when I say ocaml is fast, I mean by comparison with C
10:44:07 <sethk> shapr, my feeling is that if you are sacrificing safety, then hell, you might as well program in C
10:44:12 <shapr> I agree.
10:44:19 <dons> ok, but it's not like we can just swap in a new asm backend in ghc. there's language decisions that make it easy for ocaml
10:44:25 <shapr> Safety decreases developer time costs.
10:44:29 * Philippa nods
10:44:37 <Philippa> we did point this out to Brandon
10:44:38 <dons> types == safety == profit!
10:44:43 <shapr> yay!
10:44:47 <Philippa> but apparently no shit-hot back end = people don't care about speed
10:45:05 <shapr> I sort of wish for speculative GHC to come back, at least as an option.
10:45:05 <dons> concern about speed is for 1st year students
10:45:06 <Philippa> it /is/ true that C's a lousy target for lazy code
10:45:26 <Philippa> GHC's insufficiently fast for a number of tasks that FP would otherwise be really good for
10:45:34 <Philippa> tasks I'm interested in
10:45:40 <Philippa> I'm not exactly a first year student
10:45:41 <dons> ok, that's interesting. do you have a list?
10:45:51 <sethk> Philippa, hm., why?  C is basically one step up from assembly code, and the assembly code is the ultimate target.  How would a different target help?
10:45:58 <Philippa> yeah. Most of the tasks I have to hand come from gamedev, admittedly
10:46:09 <shapr> Here's what I have to say about OCaml vs Haskell http://www.scannedinavian.com/2005-04-29.html
10:46:10 <Philippa> that one step up comes with a *lot* of imposed model
10:46:21 <dons> Philippa, sorry. not insulting you :) i agree with you. but this guy seems to be obsessed with performance as the sole metric, which is silly.
10:46:36 <sethk> Philippa, true.  can you give an example?  If it can be done simply, that is.
10:46:42 <sethk> Philippa, if not I can go read about it.
10:46:42 <Philippa> he used to write fast machine code for the alpha
10:46:59 <Philippa> try building continuations on top of C in as lightweight a manner as possible
10:47:18 <sethk> Philippa, what I'm saying is, what alternate target helps with that problem.
10:47:19 <dons> is ocaml suitable for the jobs that haskell isn't, in your case?
10:47:31 <Philippa> at least some of them, yeah
10:47:38 <shapr> Yeah, C has a return stack. That's no good for a lot of nifty FP stuff.
10:47:48 <dons> ok. that's important.
10:48:26 <sethk> shapr, but I'm confused.  the assembly language target has a return stack.  So what intermediate target would product better end result code, the end result being of course the assembly code?
10:48:36 <Philippa> not only does C have a return stack, but you can't really get nice control over the heap without either OS-specific info or allocating an entire heap to yourself and sitting on it
10:48:40 <dons> now, can you elaborate on what particular kinds of code aren't fast enough?
10:48:50 <Philippa> sethk: most modern architectures do not have hardware stacks
10:49:01 <sethk> Philippa, x86 does
10:49:08 <Philippa> insofar as x86 does, there is no requirement to actually use it whatsoever
10:49:16 <dons> modern architectures sethk ;)
10:49:26 * shapr grins
10:49:37 <Philippa> furthermore, on x86 the stack *still gets in the damn way*
10:49:49 <shapr> I wish Alpha had survived :-/ I hope STI Cell makes it.
10:49:51 <Philippa> just not so much as in C because you have better control over it
10:50:06 <sethk> Philippa, no doubt.  My question is, wouldn't the stack get in the way just as much if an intermediate target other than C were used?
10:50:22 <Philippa> no, because a non-C intermediate that's good for FP *doesn't have a stack*
10:50:25 <sethk> Philippa, wouldn't you just be shifting the problem to a stage closer to the back end?
10:50:38 <shapr> sethk: There is no stack.
10:50:43 <sethk> Philippa, I'll have to look at an example, I guess, to understand.  I'll look for some papers
10:50:45 * shapr throws a spoon at lambdabot
10:50:48 * Kirby just compiled "Hello world" in Haskell :)
10:50:49 <sethk> shapr, there is no stack where?
10:50:57 <shapr> sethk: Turing machines have no stack.
10:51:01 <Philippa> anywhere. The CPU thinks it has one, but it's still not a conventional stack
10:51:16 <Philippa> the CPU's theoretical stack is wide open to screwing around with
10:51:17 <sethk> shapr, ok.  However, none of my platforms are pure turing machines  ... :)
10:51:26 <sethk> Philippa, I know.  I'm certainly not disputing that
10:51:37 <Philippa> so you simply don't use push and pop most of the time
10:51:42 <sethk> Philippa, I'm merely asking how a target different than C would solve the problem.
10:51:49 <Philippa> by not having a stack, like we said
10:51:53 <shapr> sethk: Are you familiar with continuation passing style?
10:52:07 <Philippa> alternatives include a heap full of continuations, a heap full of thunks...
10:52:10 <sethk> Philippa, well, you don't use push and pop, push and pop happen in the hardware when you do call and return.
10:52:26 <sethk> Philippa, shapr I've read about them, and I understand why they can be better
10:52:36 <Philippa> those aren't the only times the stack gets touched - how do you think your local variables get set up?
10:53:08 <sethk> Philippa, stack registers are adjusted in the common code generation schemes at the beginning of every function, yes.
10:53:10 <shapr> sethk: There is no return, there's only call.
10:53:33 <sethk> shapr, I was talking about the machine instructions in x86 (the _not_ modern architecture.  :)   )
10:53:46 <shapr> Both return and stack are artificial abstractions on top of most CPUs.
10:53:46 <sethk> shapr, because the discussion started about ocaml having a more optimized x86 layer
10:53:58 <Philippa> even on x86, you don't need a proper stack
10:54:13 <Philippa> you might use the stack regs to give you a second place in memory you can prod at quickly, but that's it
10:54:16 <sethk> Philippa, no, of couurse, you can generate code that doesn't use call and return.
10:54:22 <sethk> shapr, but return _is_ a machine instruction
10:54:39 <sethk> shapr, which I agree you can decide not to use
10:54:53 <shapr> But, return just means "call this saved address"
10:54:57 <sethk> shapr, Philippa I'll do some more reading so I can have a more intelligent conversation some time.
10:54:59 <shapr> So return is call.
10:55:20 <sethk> shapr, in the processors I've worked with lately, return modifies the stack pointer before doing it's jump
10:55:24 <Philippa> sethk: try deciding not to use the stack in C...
10:55:29 <Philippa> the overhead is scary
10:55:34 <sethk> Philippa, yes, I agree
10:55:37 <dons> Philippa?
10:55:40 <dons> goto
10:55:53 <dons> i.e. what ghc does
10:55:58 <sethk> Philippa, but I think that's a limitation of the x86 architecture, not an artifact of the choice of C as a target language for ghc.
10:56:09 <dons> or did i miss something
10:56:24 <Philippa> I thought GHC didn't? Or does it just not use that for exported functions?
10:56:25 <shapr> sethk: So, it's "call this saved address, and do some other stuff too" but, it's still just jumping to an address to start executing.
10:56:44 <Philippa> sethk: it's a limitation of C. C is *not capable* of giving an appropriate level of control over the stack
10:56:54 <dons> ghc doesn't use the C stack at all.
10:57:04 <musasabi> I am fearing that continuation passing style compiling will lose some of its edge when processors are containing better and better optimizations for call/ret pairs.
10:57:11 <Philippa> yes, and GHC produces slower code than it could with a native back end as a result
10:57:17 <sethk> Philippa, ok.  As I said I'll have to do some reading before I understand the details.
10:57:47 <sethk> dons, what do you mean?  It never does a function call at the C level?
10:57:52 <dons> ah. now i wonder about that. /me looks for the STG paper
10:57:53 <sethk> dons, it doesn't use C automatic variables?
10:58:02 <shapr> musasabi: Until someone finds a way to make a cheaper CPU that doesn't do all those optimizations. I like the "back to the basics" approach of the STI Cell.
10:58:05 <astrolabe> Hmmm I must be a first year too :)
10:58:06 <dons> sethk, we compile our own blocks, and jummp to them
10:58:22 <dons> computed gotoes
10:58:26 <dons> go-toes!
10:58:30 <sethk> dons, so there are no C function calls, and no use of C automatic variables?
10:58:36 <dons> right
10:58:38 <xerox> @hoogle [FilePath]
10:58:39 <lambdabot> Prelude.repeat :: a -> [a]
10:58:39 <lambdabot> Prelude.tail :: [a] -> [a]
10:58:39 <lambdabot> Prelude.concat :: [[a]] -> [a]
10:59:11 <xerox> What's the Haskell way to list directories contents?
10:59:13 <Philippa> GHC also makes use of GCC extensions, doesn't it?
10:59:21 <sethk> dons, I'll have to peruse some generated code.  ghc has an option for keeping the generated c code, does it not?
10:59:31 <dons> for this compilation strategy, check out the lazy languages on stock hardware paper
10:59:33 <Philippa> something like getDirectoryContents
10:59:54 <xerox> @index getDirectoryContents
10:59:56 <lambdabot> System.Directory, Distribution.Compat.Directory
10:59:59 <musasabi> Philippa: Adding a peephole optimizer to the native compiler would solve many problems - but that would need aliasing analysis.
11:00:02 <dons> sethk, --ddump-cmm iirc
11:00:03 <sethk> Philippa, that's not a language extension, it is a library call, no?
11:00:05 <Philippa> yeah, I read that paper a while back while thinking about doing silly things with mixtures of strict and lazy code and a mix of GC and regioning
11:00:12 <musasabi> Which is not passed down there I think.
11:00:56 <Philippa> sethk: I wasn't talking about getDirectoryContents when I talked about GCC
11:01:14 <dons> "at first it seemed sensible to map functions from the original functional language to C functions, but we soon abandoned that"
11:01:16 <sethk> Philippa, ok, I'll look at what that is.
11:01:32 <Philippa> the getDirectoryContents was for Xerox
11:02:05 <sethk> Philippa, are you saying that, because of the limitations of C, ghc has to generate code that doesn't use the stack?  That it could make use of the stack at the machine language level if C were a better target?
11:02:14 <dons> but then ghc relies on gcc extensions for things like specifying globals that need to be held in registers
11:02:32 <int-e> dons: is that the paper where they first show a CPS scheduler in (ANSI) C and then explain some hacks that strip function prologues and epilogs to get rid of that?
11:02:33 <dons> and of course, the perl mangler, for post processing the gcc output to get rid of stuff we don't want
11:02:47 <Philippa> I'm saying that GHC has to incur expenses (and also loses out on GCC-provided optimisations, most likely) by circumventing C's usual model of execution
11:03:16 <dons> ah, but is this true? do we have comparisons somewhere?
11:03:22 <dons> how do we know?
11:03:40 <dons> it does lose out on gcc optimiations, that is known
11:04:04 <dons> in fact, the C ghc generate has been known to *break gcc*
11:04:06 <shapr> C-- motivational papers will tell you everything.
11:04:40 <shapr> C doesn't support tail-calls.
11:04:42 <Cale> hi xerox
11:04:48 <dons> shapr, but gcc does
11:04:50 <xerox> Given  f :: a -> IO [a]  in  f >>= g  (>>=) is just IO destructuring or concatMap too?
11:04:54 <xerox> Hello Cale!
11:05:11 <shapr> Hm, good question then.
11:05:24 <Cale> It's sort of concatMap like in a very strange way with IO :)
11:05:33 <dons> so it's not elegant, for sure, but i don't think we've got performance penalties. at least i don't know of any. possibly the stack issue -- that could well be true, but i don't know of any reference for that
11:05:47 <xerox> So that g :: a -> ..  or [a] -> .. ?
11:05:54 <Cale> You have to look at a value of type IO a as a box indexed by states of the universe
11:05:59 <shapr> dons: It sure broke when gcc versions changed.
11:06:01 <Cale> er
11:06:10 <Cale> or are you referring to something else?
11:06:35 <Cale> (>>=) :: IO a -> (a -> IO b) -> IO b
11:06:51 <Cale> (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:06:53 <xerox> OK, g :: [a] -> IO b
11:06:54 <Cale> in general
11:07:08 <Cale> yeah, if you start with an IO [a]
11:07:10 <sethk> shapr, if you mean tail recursion optimization, gcc does it and visual C++ does it also
11:07:12 <xerox> So if I want the list monad's >>= I need to f >>= g >>= h
11:07:17 <xerox> Fair enough.
11:07:45 <xerox> Cale: I'm working on rep's httpd atm, no nymphaea working lately :-\
11:08:25 <dons> shapr, ghc actually generates switches strange enough to break gcc 2.95.* -- even though they're valid C.
11:08:55 <shapr> Nifty
11:08:58 <Cale> xerox: yeah, I was going to ask about that :) I've been thinking about abstracting things a bit more with the drawing.
11:09:41 <xerox> Cale: cool, you also asked about a different Surface datatype, right?
11:09:41 <Cale> (which involves abstracting the parser, as well as adding on a new UI for modifying/creating drawing commands)
11:09:47 <Cale> ah, yeah
11:09:58 <xerox> What are you thinking about exactly? :)
11:10:22 <Cale> Having user definable syntax elements for the turtle-graphics
11:10:45 <Cale> to a certain extent of course
11:10:47 <shapr> sethk: Anyway, there's a serious impedance mismatch between C and Haskell.
11:11:12 <xerox> Cale: sounds fun, which kind of elements are you thinking it would be useful that feature for?
11:11:27 <Kirby> I have been playing around with Haskell, and I got it to compute fibonacci( 40 ). However, it took much longer (about ten seconds) than finding fibonacci( 10 ). With ghc.
11:11:33 <astrolabe> Oh no, not another one.  My office mate sees everything in terms of impedence matching :)
11:11:34 <sethk> shapr, yes, I see that.  My question was, given that there is a serious and unavoidable mismatch with the target processor language, is it really true that, at the end of the day, we've lost performance by using C
11:11:38 <Cale> xerox: Well, it would be nice to have arcs
11:11:41 <shapr> sethk: http://www.cminusminus.org/
11:11:56 <xerox> @plugs let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 40
11:11:57 <sethk> shapr, I had looked at that a while back but I've forgotten.  I'll look again, thanks.
11:11:58 <lambdabot> 165580141
11:11:59 <dons> Kirby, there are good functions, and bad ones :)
11:12:01 <xerox> Cale: right.
11:12:01 <Cale> also, to change hue, and width in an algorithmic way
11:12:13 <Cale> (well, colour in general)
11:12:15 <dons> and good compilers, and bad ones ;)
11:12:20 <xerox> Cale: hehe, that sounds fun.
11:12:26 <xerox> I wonder how deep the change is.
11:12:36 <Kirby> fib x = if x <= 2
11:12:36 <Kirby>           then 1
11:12:36 <Kirby>           else fib(x - 1) + fib(x - 2)
11:13:06 <sylvan> Kirby, your problem is that fib (x-1) will call fib(x-2) and thus that value is computed twice.. So you need to memoize
11:13:12 <Cale> Perhaps it can just be built into the language, but we'd need a way to declare things
11:13:25 <Cale> or it would be cumbersome to use
11:13:28 <sylvan> xerox' version is memoized but perhaps a bit obscure for a newbie.. =)
11:13:40 <Kirby> sylvan: interesting. I would like to learn this. (I also wonder why a compiler might not handle this for me.)
11:13:52 <dons> that's a classic fib
11:13:53 * wli looks for survey CGI scripts that don't need to be modified for custom questions.
11:13:55 <astrolabe> Kirby, or you could use a helper function that computes (fib n,fib n-1)
11:13:55 <sylvan> your best bet is to write a helper function which returns a pair of two fibs (n and n-1) and then use that to define fib
11:14:06 <astrolabe> snap!
11:14:10 <Cale> Kirby: it's a memory/time tradeoff
11:14:11 <sylvan> =)
11:14:22 * wli has an O(lg(n)) fib function.
11:14:27 <sylvan> LIE!
11:14:28 <sylvan> =)
11:14:32 <int-e> wli: me too ;)
11:14:57 <wli> http://holomorphy.com/~wli/Fib.hs
11:15:01 <Cale> Lazy evaluation will only share computations which are obviously the same
11:15:12 <int-e> Cale: in that case, considering that the recursive definition needs a stack, it's not really a tradeoff :)
11:15:28 <shapr> dons: That was punny.
11:15:47 <astrolabe> There is a mathematical formula for fib n.  That is cheating!
11:15:57 <xerox> Cale: did you see Context-Free?
11:16:19 <Cale> int-e: well, the stack eventually goes away, but the memo table probably couldn't
11:16:40 <dons> wli needed unfoldl!?
11:16:48 * dons looks on in awe
11:16:55 <Cale> xerox: hmm... I think briefly
11:16:59 <xerox> Cale: I think having a parser which goes towards its kind of definition would be cool.
11:17:04 <wli> dons: Well, some consider it spurious.
11:17:20 <xerox> Cale: I mean, there you declare the rules with meaningful names, for example.
11:17:25 <Cale> xerox: I think that having a UI to construct the L-systems would be seriously cool
11:17:41 <Cale> like, you could actually draw the productions
11:17:42 <dons> no no. all programming is unfoldr ;) . but i've not seen unfoldl before
11:17:44 <xerox> Cale: Okay.  I don't know what you mean with UI to construct the L-System :-D
11:17:56 <Cale> (with the mouse)
11:18:03 <wli> dons: Well, it seemed to fit.
11:18:15 <dons> @karma+ wli
11:18:16 <lambdabot> wli's karma raised to 1.
11:18:24 <dons> though I think we actually need an @unfoldr+
11:18:24 <xerox> Cale: abandoning the 'draw by writing rules behavior' ?
11:18:36 <dons> to encourage the use of unfoldr to solve everything
11:18:46 <Cale> xerox: well, the GUI would create the textual rules
11:18:48 <xerox> dons: agreed-
11:18:56 <Cale> I suppose it's orthogonal
11:19:02 <dons> agreed- !!
11:19:06 <dons> bad xerox
11:19:15 <int-e> @index (^^)
11:19:18 <lambdabot> Prelude
11:19:24 <xerox> Oops, the '-' wasn't expected!!!
11:19:34 <dons> oh that what you say now ;)
11:19:39 <xerox> Grmbl.
11:19:58 <xerox> You only partially evaluated my sentences :(
11:20:25 <Cale> rnf xerox
11:20:42 <xerox> Ehrm.. ? :)
11:20:47 <Cale> @index rnf
11:20:49 <lambdabot> Control.Parallel.Strategies
11:21:03 <dons> Cale pulls out his magic wand
11:21:26 <xerox> @docs Control.Parallel.Strategies
11:21:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Parallel.Strategies.html
11:21:55 <dons> be wary of haskell ninja-fu for anyone who quotes Parallel.Strategies at you ;)
11:21:57 <Cale> unfortunately, that documentation sucks
11:22:18 <xerox> What do you want to use it for?
11:22:26 <Cale> rnf reduces a term to normal form -- forcing its evaluation
11:22:43 <dons> oh, that code has my favourite piece of code in it...
11:23:11 <dons> here: markStrat n s x = unsafePerformPrimIO (
11:23:12 <dons>      _casm_ ``%r = set_sparkname(CurrentTSO, %0);'' n `thenPrimIO` \ z ->
11:23:12 <dons>      returnPrimIO (s x))
11:23:12 <Cale> supposing that you're an instance of NFData, this would certainly force the evaluation of all your sentences :)
11:23:47 <xerox> That was hard :-)
11:23:52 <shapr> dons: That's slightly terrifying.
11:24:04 <jyp> any tip on running hIDE? ... jp@legolas:~/haskell/hIDE$ dist/build/hIDE/hIDE yi-0.2
11:24:04 <jyp> hIDE: user error (Failed to load plugin)
11:24:06 <dons> i think it is the scariest code in all of fptools
11:24:14 <Cale> dons: why is such a low-level construct needed?
11:24:23 <wli> My googling is going badly. If anyone's got hints as to where CGI scripts with configurable questionnaires might be I'd be much obliged. (Worst case I have to write my own.)
11:24:24 <dons> jyp, did you use ./build.sh ?
11:24:25 <Kirby> What is the syntax for returning two values? As in the fibonacci helper function.
11:24:32 <dons> it prints the command line to use after building
11:24:34 <jyp> I guess not
11:24:34 <Cale> Kirby: return a pair (x,y)
11:24:42 <jyp> I'm gonna try
11:24:45 * xerox goes eating his leibniz-equal typed dinner  (trying to make up a {Cale,TheHunter}-like joke)
11:25:00 <dons> Cale, I guess they didn't want to add a primop
11:25:21 <dons> i'm not even sure that code is valid ghc
11:25:37 <dons> i've never seen _casm_ anywhere else
11:25:44 <Cale> dons: well, from the paper, the strategies stuff doesn't really seem to require any special compiler support
11:25:55 <Cale> apart from seq
11:25:55 <dons> i guess not, if you have _casm_ ;)
11:25:58 <Cale> heh
11:26:16 <Cale> I mean, it should be implementable with Haskell 98
11:26:35 <Cale> NFData should be derivable
11:26:49 <Cale> I wonder who we have to bother to make that happen :)
11:27:16 <dons> jyp, btw yi+gtk seems to be slightly dicey atm, gtk doesn't always place nicely
11:27:25 <Kirby> Cale: how do I add together the two values returned by the helpfib function?
11:27:42 <dons> jyp, though you'll be pleased to see that Emacs2.hs is the default mode for hIDE
11:27:54 <Cale> \(x,y) -> x + y, or use uncurry (+)
11:28:02 <Cale> @eval uncurry (+) (5,6)
11:28:04 <lambdabot> 11
11:28:12 * jyp bounces in excitement :)
11:29:14 <Cale> Control.Parallel.Strategies should be more popular
11:29:39 <Cale> hmm... I wish the libraries documentation was a wiki
11:29:45 <shapr> me too
11:29:50 <shapr> I wish it were even a darcs repo.
11:30:01 <sethk> shapr, cale, start one
11:30:27 <dons> Cale, that's a cool idea
11:30:34 <shapr> dons: Speaking of the Future of Haskell, if they'll turn fptools into a darcs repo, things will move MUCH faster.
11:30:45 <dons> i know
11:31:10 <jyp> That is already in blueprints if i'm correct
11:31:16 <dons> i wonder if JaffaCake has spoken to David Mr. Darcs yet
11:31:40 <Kirby> @eval let f 3 = (1, 1); f n = (f( n - 1 ) -> y, uncurry (+) f(n - 1 )) in f 10
11:31:42 <lambdabot> 54: parse error on input `->'
11:31:58 <jyp> or I've been interpreting some post in a slightly too optimistic  fashion
11:32:08 <shapr> Whatever the status, the ability to send commits without a userid on the box will (or even anonymously) will speed up GHC development.
11:32:16 <Kirby> hmmm, I need to get just the second value returned by f.
11:32:44 <dons> shapr, well, you can always diff anoncvs.
11:32:44 <shapr> I just don't have enough patience to deal with cvs anymore. I'm spoiled by darcs.
11:32:50 <dons> buut i think cvs is just too hard
11:32:54 <Cale> Who would be able to add NFData derivable? It's annoying that there's no easy way to use, say, template haskell to define deriving methods.
11:33:46 <shapr> Cale: You can.
11:33:49 <dons> an interesting darcs-ish point that shows I think that darcs would help is the number of libraries typos i've commited from people who've found them on #haskell
11:34:01 <shapr> oh, to define *new* deriving methods?
11:34:02 <Cale> There ought to be a way to attach a piece of TH code to a class in order to make adding that class to a deriving clause meaningful.
11:34:08 <dons> that only happens cause i'm here and have commit access. but with darcs, individuals would probably send those patches anyway
11:34:12 <Philippa> yeah, I want that
11:34:59 <dons> so there's a large body of people who are reading fptools code, spotting typos and the like, but cvs is currently stopping them sending in patches
11:35:07 <shapr> Yes! Exactly!
11:35:22 <Cale> that would make the benefits of TH accessible to people who don't know anything about TH
11:35:23 <metaperl_> I loved darcs easy of use too until I tried to start a project from a 4 gigagbyte website I had... darcs tried to juggle all the patches in memory and look at them and not only did it take too long, but I ran out of physical memory.. roundy mentioned that as a weak spot of darcs
11:35:43 <dons> the only channels are currently finding a committer on irc. which is a poor approximation of darcs push ;)
11:35:57 <dons> sorry, darc ssend
11:36:54 <shapr> I wonder if I can get my focus up to write cgi-gpg-send support.
11:39:12 <Cale> hmm...
11:39:33 <wli> I figured someone would have written some kind of canned CGI meta-program that could take lists of questions and do questionnaire -type affairs somewhere.
11:39:49 <araujo> @hoogle exit
11:39:50 <lambdabot> System.exitFailure :: IO a
11:39:50 <lambdabot> System.exitWith :: ExitCode -> IO a
11:40:05 <wli> Looks like something along these lines has been done before but it's payware.
11:40:39 <jyp> btw, do haskell tool chain binaries exist for amd64 ?
11:41:14 <dons> isn't the tool chain just ghc?
11:41:18 <jyp> ...debian of course :p
11:41:41 <jyp> I 'just' finished building ghc
11:42:03 <jyp> so I guess most of the work is behind anyway...
11:42:08 <Philippa> wli: many CGI questionnaire programs will work like that...
11:42:25 <Philippa> livejournal must have one for its polls, too
11:42:31 <Kirby> @eval curry lst 1 2
11:42:33 <lambdabot> 24: Not in scope: `lst'
11:42:50 <dons> @type curry
11:42:52 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
11:42:52 <jyp> ... but now gtk2hs wants newer happy
11:42:55 <shapr> wli: What about using hswebforms? http://www.cs.helsinki.fi/u/ekarttun/hswebforms/
11:43:08 <Cale> @eval curry fst 1 2
11:43:10 <lambdabot> 1
11:43:22 <Kirby> @eval curry last 1 2
11:43:23 <Cale> @eval const 1 2
11:43:23 <lambdabot> Couldn't match `[a]' against `(a1, b)'
11:43:24 <lambdabot> 1
11:43:29 <Cale> @eval curry snd 1 2
11:43:30 <lambdabot> 2
11:43:31 <dons> snd ;)
11:43:39 <Kirby> thanks dons
11:43:42 <dons> last is for lists
11:43:59 <Cale> @eval last [5..15]
11:44:01 <lambdabot> 15
11:44:20 <Cale> @eval init [5..15]
11:44:22 <lambdabot> [5,6,7,8,9,10,11,12,13,14]
11:49:37 <Kirby> I'm not sure I understand what ghc is saying about the syntax error in: else (curry snd helpfib (y - 1), uncurry (+) helpfib (y - 1))
11:50:36 <Cale> you're passing too many parameters to curry?
11:50:55 <Kirby> Couldn't match `(t -> b, t -> b)' against `a -> (a, b)'
11:51:29 <Cale> ah... more context?
11:51:40 <Cale> @paste
11:51:41 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:51:51 <Cale> could you put the function there?
11:56:08 <Kirby> Okay I did: http://www.haskell.org/hawiki/HaskellIrcPastePage
11:57:40 <Cale> shouldn't helpfib take a pair
11:57:41 <Cale> ?
11:58:04 <Kirby> why would it need to? the two items it takes are always one off each other
11:58:16 <Kirby> so it just takes the higher one
11:58:53 * shapr finally gets around to fixing Pete Gammie's PLog
11:59:10 <Kirby> helpfib(2) = (1, 1); helpfib(3) = (1, 2); helpfib(4) = (2, 3); helpfib(5) = (3, 5); helpfib(6) = (5, 8)...
11:59:51 <Cale> ah, okay
12:00:01 <Cale> I see what you want to do with it
12:02:24 <Cale> there you go :)
12:02:55 <Cale> when you want to do something complicated with the values, it's best to use let and pattern match
12:03:09 <Cale> or possibly case, but there's only one possible pattern here
12:03:35 <Cale> @paste
12:03:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:04:52 <shapr> hiya JohnMeacham
12:04:58 <JohnMeacham> heya
12:05:21 <Kirby> sweet!  fibonacci number 40 is now calculated in a fraction of a second.
12:05:25 <Cale> :)
12:05:48 <sethk> Kirby, a proper fraction, or an improper fraction?
12:06:03 <Cale> so is fib 10000
12:06:04 <Kirby> proper seth
12:06:18 <Cale> (try it)
12:06:19 <Philippa> 'lo John
12:06:57 <Kirby> haha! works great even on a 32-bit machine.
12:07:33 <Cale> The Integer type in Haskell is arbitrary precision.
12:09:09 <Kirby> Can I tell the compiler or do something with the language to make it store already calculated values returned from a function in memory? so it doesn't compute them again?
12:09:35 <Philippa> no, but you can pass the same value everywhere and it'll only need to be computed once
12:10:37 <Cale> well, there are ways to write automatic memoisers (using unsafePerformIO)
12:10:57 <Cale> which you could then use after forgetting that they made use of that :)
12:11:18 <Kirby> I am trying to implement http://rafb.net/paste/results/grHqFf65.html in Haskell.
12:11:22 <Cale> another trick is just to define a value to be, say, an array of results from your function
12:11:43 <dons> you don't just want a `let' do you?
12:12:25 <Cale> wow, that code is annoyingly spaced :)
12:12:40 <Kirby> Cale: I know, somethign about Unix/Windows CR-LF
12:12:40 <sethk> Cale, or a tuple?
12:13:04 <Cale> sethk: if you're only planning to store very few results
12:13:21 <Cale> tuples are only useful in Haskell up to about 7 elements
12:13:32 <dons> 7 is too high ;)
12:13:34 <int-e> http://www.haskell.org/hawiki/MemoisingCafs does something like that
12:13:36 <dons> 3 is the limit
12:13:58 <Cale> int-e: yeah :)
12:14:06 <sethk> Cale, k.  I'm thinking along the lines of (st, realReturnValue)
12:14:37 <davve> anyone using debian and cabal?
12:14:45 <Cale> sethk: I was referring to storing the return values of a function so that they don't have to be recomputed
12:15:28 <sethk> Cale, I was thinking of st being a state monad, but maybe that doesn't apply.
12:16:38 <Cale> sethk: you could, if you were planning on doing everything in something like the ST monad, make an ST array of the return values, which you update as you compute them. But this requires all the code which uses that array to be in ST as well.
12:17:03 <sethk> Cale, ok
12:17:07 * Igloo peers at dons
12:17:16 <Igloo> I'm convinced you don't really exist
12:18:35 <araujo> lisppaste2, help?
12:18:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:18:52 <basti_> lisppaste2: test
12:19:20 <lisppaste2> araujo pasted "better than this?" at http://paste.lisp.org/display/11995
12:19:21 <dons> Igloo, tried to spot you today.
12:19:38 <araujo> Anyone knows if there exist a better way to write that pattern matching?
12:19:51 <Kirby> okay this should be beautiful: http://rafb.net/paste/results/lIKcuq91.html
12:20:32 <int-e> araujo: (Help:_)
12:22:23 <araujo> Thanks int-e
12:25:16 <orbitz> hi araujo
12:26:10 <araujo> Heya orbitz , learning haskell? :-)
12:27:37 <Kirby> @eval let f(0) = 0; f(1) = 1; f(2) = 2; least [f(0), f(1), f(2)]
12:27:39 <lambdabot> 76: parse error on input `)'
12:27:53 <Kirby> @eval let f 0 = 0; f 1 = 1; f 2 = 2; least [f(0), f(1), f(2)]
12:27:55 <lambdabot> 73: parse error on input `)'
12:28:03 <orbitz> araujo: eventually, been busy with school an dwork unforauntly
12:28:44 <xerox> So I got to write an article about the SoC Haskell project for the Dottor Dobbs Journal.
12:29:44 <xerox> The limits are quite restrictive but I'd like to write about how Haskell is blah blah :-)
12:31:21 <araujo> orbitz, well, have fun and enjoy Haskell!
12:32:37 <shapr> hiya malcolm, have you seen the nhc98 discussion the debian list?
12:33:08 <malcolm> shapr: err, no, but Igloo sent me an email about something last week?
12:33:16 <shapr> Right, sounds like the same thing.
12:33:35 <malcolm> apparently nhc98 has stopped working on the mips architecture or something
12:33:51 <davve> anyone recognise this: *** Exception: Line 11: Unknown field 'hs-source-dirs'?
12:34:07 <dons> Cabal version issue.
12:34:26 <davve> I've got ghc 6.4.1
12:34:28 <malcolm> I had a quick look around the debian websites, but couldn't really find an error report.
12:34:42 <shapr> meren: hiya
12:34:50 <dons> hs-source-dir: perhaps? or update Cabal
12:34:58 <meren> hey shapr! :)
12:35:05 <shapr> How's code?
12:35:56 <davve> dons, I have to build Cabal from cvs? (I'm using debian)
12:36:03 <meren> nice (i'm with Python still) ;) but i promise that i'll focus on the haskell when I able to
12:36:22 <davve> dons, ah.. you meant remove the s from hs-source-dirs..
12:36:27 <davve> didn't see that
12:37:22 <shapr> meren: Well, only if you want to.
12:37:54 <wli> Philippa: I'm getting thwarted in my search for the programs, any hints at specific ones (I'm not very picky, really).
12:38:07 <meren> shapr: i really want to involve..
12:38:18 <davve> dons, changing to hs-source-dir works, thanks
12:38:29 <shapr> meren: Ok, jump in when you have time!
12:40:01 <Igloo> malcolm: neilm accosted me earlier and convinced me to keep a ghc6 hat, BTW (which is easier as I don't have to worry about getting a single copy of the tools but multiple libraries)  :-)
12:40:48 <Igloo> malcolm: http://buildd.debian.org/fetch.php?&pkg=nhc98&ver=1.18-3&arch=mips&stamp=1127407878&file=log&as=raw is the mips failure
12:40:56 <Cale> Kirby: want to see my translation?
12:41:00 <malcolm> Igloo: not sure what you mean? were you thinking of dropping Hat from debian altogether?
12:41:00 <meren> shapr: and i also want to do something with functional programming languages during my PhD.. so maybe i can try to get some advices from you in a few months..
12:41:15 <Kirby> Cale: yes please :)
12:41:28 <Cale> Kirby: it's only 6 lines of code :)
12:41:35 <Kirby> Cale: awesome!!
12:41:38 <dons> hmm. i think i built nhc on mips a year or so ago.
12:41:48 <Igloo> malcolm: But essentially it's a bus error  first time nhc itself is run, I think, so almost certainly just due to one of the invalid assumptions nhc makes that yhc will correct
12:42:02 <Igloo> malcolm: Yup, it was in the second half of that e-mail
12:42:33 <Cale> it's on the paste page now -- I didn't do the IO stuff, but that's not too hard to deal with
12:42:35 <malcolm> Igloo: yhc?  do I detect some plans our research students have not yet divulged to me... :-)
12:42:53 <Igloo> malcolm: Ah you in Tallinn, BTW?
12:43:01 <Igloo> s/Ah/Are/
12:43:27 <Igloo> yhc is what neilm (and I thnk beelsebob) are calling nhc2
12:43:47 <Igloo> The one with the hat tracing stuff built in
12:43:50 <malcolm> Igloo: no, stuck in York due to funding/project-related issues
12:43:56 <Igloo> :-(
12:45:18 <malcolm> Igloo: but I'll be moving back to a Haskell-related project in the new year (yay!)
12:45:27 <shapr> <weebl> Jag vill ha paj!
12:45:32 <Igloo> Cool  :-)
12:45:40 <Igloo> Tracing, or something else?
12:46:33 <Oejet> Hello.
12:46:37 <Cale> ah, it ought to read nail <= amax
12:46:49 <malcolm> Igloo: "A lazy polytypic grid" - to do with visualisation of large scientific datasets on the grid, but using FP ideas to make it more efficient.
12:47:09 <Igloo> Ah, right, I remember the ad
12:48:36 <jyp> Building hide-yi-0.1.0...
12:48:36 <jyp> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
12:48:36 <jyp>         unknown exception
12:48:42 <jyp> ramble
12:48:56 <davve> hihi
12:48:57 <Cale> possibly...
12:49:20 <dons> hmm. now i wonder if that's shapr's bug jyp?
12:49:35 <Igloo> No wonder I'm having trouble doing anything, I'm getting packetloss to my gateway over wired internet
12:50:15 <z0d> wired internet is an euphemism for weird internet
12:50:27 <jyp> I successfully compiled gtk, hs-plugins, cabal, and yi... last stone fails :p
12:50:44 <dons> well, surely you can run 'yi' though?
12:50:56 <dons> just not hide, cause ghc is being silly
12:51:03 <jyp> actually not
12:51:12 <Cale> Kirby: there - now it's right :)
12:51:14 <dons> now why is that?
12:51:38 <jyp> my being dense probably, but...
12:51:42 <Cale> Kirby: had to take care of the 0 case correctly due to the condition changing :)
12:51:42 <jyp> jp@legolas:~/haskell/yi$ dist/build/yi/yi
12:51:42 <jyp> Unable to load Yi.dynamic_main. Exiting..
12:51:56 <dons> hmm. do you have the right yi?/
12:52:08 <dons> you need yi+gtk, which lives only on scannedinavian.com
12:52:20 <jyp> Yup I got that one
12:52:40 <jyp> dunno if the way I run it is ok though
12:52:49 <dons> you installed it first?
12:53:03 <jyp> as user
12:53:18 <JohnMeacham> off to work..
12:53:20 <jyp> understanding --user
12:53:23 <dons> hmm. not sure if that is ok. it works for hIDE, but maybe not yi
12:53:38 <jyp> ok let's try as root ...
12:53:58 <Lemmih> Definitely not for yi.
12:54:15 <dons> right, cause i haven't pulled across the user patches
12:54:22 <malcolm> Igloo: Hmm, I see the nhc98/mips error involves building with gcc-4.0
12:54:44 <dons> morning Lemmih ;)
12:54:55 <Lemmih> Hi dons (:
12:54:58 <Igloo> Yup
12:55:41 <malcolm> Igloo: this brings back bad memories of the fiddling we needed to do when gcc-3.2, then gcc-3.3 arrived...
12:55:45 <Lemmih> What's up, dons?
12:55:56 * jyp dances around
12:56:10 <dons> yay, jyp :)
12:56:17 <jyp> Three days of builds finally succeeding :)
12:56:38 <dons> oh, why was it so hard?
12:57:24 <dons> ok, so ghc panics on hide-yi for some reason. and yi needs --global, what else jyp?
12:57:37 <jyp> Well it was down from ghc up to the top
12:58:04 <dons> ah, ok, so there's 2.9 of your 3 days ;)
12:58:11 <malcolm> One thing I'd really like to do is generate a platform-independent bytecode directly in binary from nhc98.  With a simple runtime loader/linker, we could even do the same trick as O'Caml, and place a #!nhcruntime line
12:58:14 <jyp> 1.5 at least
12:58:54 <jyp> the only thing worth mentioning is that cabal MUST be updated first;
12:59:14 <jyp> and the older one removed right away
12:59:24 <jyp> otherwise ghc
12:59:34 <jyp> impossible happens :)
12:59:47 <dons> oh, is that the cause?
12:59:59 <dons> for the earlier panic?
13:00:25 <jyp> It was one of them, the other one being --user not supported
13:00:33 <dons> so the 6.4.1 cabal and hide-yi triggers a panic?
13:00:53 <jyp> actually not just so
13:01:30 <jyp> if you build some packages with old cabal and some with new, that makes ghc panic at some point
13:01:41 <dons> oh, ok. that's reasonable then
13:01:45 <jyp> I can't be more specific
13:01:54 <Igloo> malcolm: I was under the impression that's what yhc does  :-)
13:03:04 <davve> jyp, what packages requires the new cabal?
13:03:08 <malcolm> Igloo: AFAIK yhc does exactly the same as nhc98 for now - who knows what ndm and co have planned though.
13:03:33 <Igloo> HehOK
13:03:58 <jyp> none... cabal builds with naked ghc
13:04:51 <jyp> ... davve
13:06:05 <jyp> davve, did you mean the other way around... hIDE requires recent cabal :p
13:06:06 <davve> I meant the other way around :)
13:06:11 <davve> okay
13:06:36 <davve> I'm building gtk2hs right now for hIDE purpose.. with the 6.4.1 cabal :(
13:07:11 <jyp> you also need the very newest gtk2hs btw
13:07:15 <davve> do I have to rebuild yi and hs-plugins with the latest cabal then aswell?
13:07:44 <jyp> I know it's critical for hs-plugins
13:07:56 <davve> jyp, you mean gtk2hs-0.9.9 or from latest sources?
13:07:58 <jyp> but better rebuild all of them
13:08:06 <davve> okay..
13:08:07 <jyp> latest sources
13:08:35 <jyp> it wants 0.9.9.5
13:08:42 <davve> oh.. heh :)
13:11:30 <Itkovian> evening
13:11:43 <Cale> Kirby: does it make sense?
13:12:01 <Kirby> Cale: I think so. I'm modifying it a bit, and adding i/o.
13:14:39 <jyp> well yi runs but hIDE still fails with panic...
13:16:54 <jyp> I guess it is because build.sh uses --user
13:17:14 <Cale> Kirby: I added some IO there too for fun
13:17:29 <Kirby> How do you read an integer from IO? I am getting some typing problem with 'IO String' instead of 'String'.
13:17:59 <Cale> Kirby: you have to use  var <- myIOString inside a do block to get the string out
13:18:05 <Cale> then you can use read
13:18:14 <Cale> there's also, I think readIO
13:18:15 <musasabi> You won't ever get out of IO.
13:18:17 <jyp> Ah, that annoying IO type ... :)
13:18:37 <int-e> @type readIO
13:18:38 <musasabi> with a few exceptions.
13:18:38 <lambdabot> forall a. (Read a) => String -> IO a
13:18:41 <Cale> ah
13:18:42 <int-e> looks good :)
13:18:46 <Cale> nope, not lifted
13:18:53 <jyp> @google  thatannoyingIOtype
13:18:56 <lambdabot> http://haskell.cs.yale.edu/hawiki/ThatAnnoyingIoType
13:19:03 <int-e> oh.
13:19:05 * basti_ laugs
13:19:10 <Cale> I was going to check that, but I can't seem to connect to haskell.org right now.
13:19:27 <jyp> neither do i
13:19:34 <int-e> so ... getLine >>= readIO ...
13:20:19 <Cale> in his case, it'll actually likely be:  args <- getArgs, and then args is a list of strings which have to be read
13:20:24 <Cale> @type read
13:20:25 <lambdabot> forall a. (Read a) => String -> a
13:20:42 <Cale> @eval read "5" :: Integer
13:20:44 <lambdabot> 5
13:21:24 <Cale> ah, seems haskell.org is back
13:22:25 <Cale> Kirby: http://www.haskell.org/hawiki/HaskellIrcPastePage -- there's my version with IO
13:23:48 <Cale> heh, I should alter the printing so that 1st, 2nd and 3rd are handled correctly :)
13:27:33 <Cale> oh, hmm... I messed something up there :)
13:29:36 <Cale> there
13:30:38 <jyp> ha hah ahaaaaa... I finally got there :) My user's yi was confusing ghc.
13:31:28 * Oejet is reading the Yi and dynamical loading paper by dons and chak; very interesting.
13:32:22 <dons> thanks :) questions?
13:32:40 <dcoutts> hi dons, hows the conference going?
13:33:31 <dons> some very interesting talks today. lots of fun module system stuff. and cool house talk (talk presented on a thinkpad running house )
13:34:03 <Lemmih> dcoutts: Are you able to load gtk in GHCi?
13:34:15 <dcoutts> Lemmih, yep, except on win32
13:34:47 <Lemmih> I'm getting undefined references to symbols in mtl-1.0
13:35:01 <dcoutts> oh, hmm, that's probably my fault :-)
13:35:09 <dons> hmm that doesn't sound too bad, as far as undefined syms go
13:35:44 <dcoutts> Lemmih, have you pulled gtk2hs in the last couple days, I fixed a mtl linker bug that shapr reported
13:36:04 <dcoutts> it was only triggered in the case that the user had cairo installed but not gtk+-2.8
13:36:15 <Cale> argh, is it just me or is haskell.org really unstable today?
13:36:34 <dcoutts> Lemmih, if you still get it with the latest gtk2hs please tell me
13:37:01 <dcoutts> Lemmih, what've you been working on recently?
13:37:25 <Lemmih> dcoutts: Syntax highlighting.
13:37:29 <Lemmih> Almost done.
13:37:42 <dcoutts> I've been thinking about the data model behind the ide shell UI
13:37:49 <dcoutts> Lemmih, oh great
13:38:14 <dons> Lemmih!
13:38:35 <dcoutts> and using the GtkTextModel/View spans stuff to do the colours/fonts etc?
13:38:41 <Kirby> Cale: I fixed it up because the first period is a special case. It is the second period that repeats forever, not necessarily the first.
13:39:07 <dons> Lemmih, a patch to yi or hIDE?
13:39:44 <dcoutts> dons, oh, what was the module system stuff? ideas for extending the Haskell module system? I'me very interested in that because it really gives us problems in Gtk2Hs
13:39:54 <Lemmih> dons: hIDE.
13:40:11 <dons> Lemmih, you'll be pleased to know SyntaxNinja and I came up with lots of evil schemes to keep you writing code :)
13:40:23 <dcoutts> heh heh
13:40:24 <Lemmih> oh?
13:40:35 <dcoutts> what kind of ideas? for Cabal or hIDE/Yi ?
13:40:38 <Cale> Kirby: no, it really does work that way -- since what does the second period end up repeating?
13:40:44 <dons> their schemes. i can't tell you, then you'll know ;)
13:40:48 <dons> they're. sleepy
13:40:59 <Cale> Kirby: also, I tested it without the periodicity optimisation, and got the same results
13:41:09 <Lemmih> dcoutts: I'm having trouble pulling from http://haskell.org/gtk2hs/darcs/gtk2hs
13:41:17 <davve> me too
13:41:17 <Cale> haskell.org seems down
13:41:17 <dcoutts> Lemmih, oh?
13:41:24 <dcoutts> hmm
13:41:29 <Lemmih> Cale: Ah. Thanks.
13:41:31 <dons> Lemmih, are you doing syn hl on a normal gtk text buffer ?
13:41:46 <Cale> it was up a little while ago
13:42:38 <Kirby> Cale: here is the modified program: http://rafb.net/paste/results/4MizpF90.html
13:42:41 <dons> Lemmih, also, are you using the Lexer.x api they us for Visual Haskell?
13:42:53 <Lemmih> dons: Yes and yes.
13:42:54 <dcoutts> dons, it seems to me that Yi should provide an interface for syntax highlighters, and Yi should then implemente that in terms of GtkTexxtBuffer thingies or curses colour stuff.
13:43:29 <dons> yep. i originally envisaged a Syntax class
13:43:41 <dons> providing, I think, render, renderLine, , and a kind of fmap
13:43:48 <dcoutts> dons, from what Lemmih is doing you'll b able to see what knid of interface needs to be provided
13:44:08 <dcoutts> and then we can convert Lemmih's code to use an interface provided by Yi.
13:44:35 <dons> good point. i never got a decent ncurses word colouring going to make much progress
13:44:49 <dcoutts> Lemmih, yeah haskell.org seems to be down for me too
13:45:15 <Cale> Kirby: also, subtract 1 from periodicity a b in the inner loop
13:45:31 <dons> so as soon as push Lemmih I'll look to get it running in Yi.
13:47:23 <Kirby> Cale: try typing, for your version and mine (with the subtract 1 modification): ./hammertime 51 1 50 1 1 3
13:47:59 <Kirby> The first period is a special case when one or the other ends up winning throughout the second period (and all subsequent ones)
13:49:00 <Cale> aha
13:49:02 <Cale> yeah
13:49:56 <Kirby> Thanks muchly for your help with this.
13:50:20 <Cale> there's one more IO modification which could be made
13:50:29 <Cale> which is pretty trivial :)
13:50:44 <Kirby> 1st/2nd/3rd/4th?
13:50:47 <Cale> yeah
13:51:08 <Cale> I was about to put code for that up, but haskell.org went down
13:52:21 <Cale> http://rafb.net/paste/results/BicWVW21.html
13:53:57 <Cale> ah, I suppose it should also handle larger cases :)
13:57:03 <Cale> http://rafb.net/paste/results/xIWf5K40.html -- there we go
13:59:52 <Cale> I like how for a lot of these sorts of problems, Haskell makes the problem itself seem simpler than printing the results (and not because printing the results is all that hard :)
14:04:29 <retepybrik> Cale: I made some minor adjustments, see here: http://rafb.net/paste/results/QjQhZJ25.html
14:05:11 <Cale> PeterK: yeah, that's a good way to handle it :)
14:06:07 <heatsink> @eval case (return []) of {Nothing -> Nothing; Just xs -> Just xs}
14:06:08 <lambdabot> <Plugins.Eval>:1:12:
14:06:08 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:06:08 <lambdabot>   `Show a' arising from use of `show'
14:06:30 <heatsink> That's what I expected...
14:06:37 <heatsink> but for some reason ghci prints "Just []"
14:07:12 * heatsink wonders how ghci infers Show a
14:07:17 <PeterK> Cale, all: Let's say I wanted to make a game that plays Connect Four in Haskell and that I wanted a graphical user interface. How should I manage the interface? In Haskell?
14:07:42 <Cale> PeterK: well, you'd probably want to use one of the GUI libraries that are available
14:07:51 <davve> PeterK, there are GUI libraries for Haskell, for instance gtk2hs and wxHaskell
14:08:11 <PeterK> I have already made the game in C++; I'd just like to practice Haskell. :)
14:08:14 <Cale> gtk2hs + glade is a nice combination
14:08:23 <metaperl_> what is glade?
14:08:36 <Cale> http://glade.gnome.org/
14:08:48 <Cale> a UI designer tool
14:09:17 <Cale> which saves an XML file from which you can load widgets into your GTK app
14:19:02 <wilx> #moo
14:19:04 <Cale> http://vx.hn.org/autoshare/nymphaea.png
14:19:04 <wilx> @moo
14:19:10 <wilx> Hmpf.
14:19:33 <Cale> there's a screenshot of the app that xerox and I have written using gtk2hs and glade
14:20:14 <Cale> (and the new cairo support in gtk2hs that xerox did :)
14:25:45 <Cale> heh, I think my machine is not happy about the humidity
14:28:00 <wilx> Humidity?
14:28:48 <Cale> yeah, it's really humid at the moment
14:33:21 <Cale> the little blue pin on the drawing window sets the initial position and direction of the drawing, and appears when the user clicks the window and drags
14:43:14 <Cale> heh, I have a lot of junk in autoshare
14:55:51 <JohnMeacham> Much like machines, I do not like excess humidity. coincidence? I think not.
17:11:29 <Lemmih> dcoutts: ping.
17:23:48 <humasect> hello
17:28:18 <exe> Hello.
17:34:12 <Cale> hi
18:19:34 <palomer> is there a simple bijective computable function from data tree = left | right | node tree tree to the natural numbers?
18:22:32 <TheHunter> yes
18:22:55 <palomer> what is it?
18:24:15 <TheHunter> you can construct one by just enumerating all such trees in some order.
18:24:55 <TheHunter> do you want a nice one?
18:27:49 <palomer> yeah
18:27:50 <palomer> :O)
18:27:57 <palomer> I can only think of ugly ones
18:29:21 <TheHunter> oh, i didn't read *simple, sorry.
18:53:07 <Cale> palomer: if you'll settle for an injection, I could give something simple :)
18:53:28 <palomer> shoot
18:53:45 <palomer> I have a relatively simple bijection, but I want something simpler
18:54:26 <Cale> f(left) = 2, f(right) = 3, f(node x y) = 5^f(x) 7^f(y)
18:55:07 <Cale> this is an incredibly sparse representation though :)
18:56:07 <palomer> hrm
18:57:00 <palomer> f(left) = 0, f(right) = 1, f(node left right) = f(left) || f(right) where || is bitwise concatenation
18:57:02 <Cale> I suppose you could also use f(node x y) = 2^f(x) 3^f(y), since you'll be able to tell it apart by the distinctness of factors
18:57:15 <Cale> palomer: you sure?
18:57:23 <palomer> yeah, I'm pretty sure
18:57:49 <Cale> how do you tell where the right branch starts and left branch stops?
18:58:35 <sethk> palomer, I was reading a paper and it was describing something, and it said it wasn't a polymorphism, it was a bijection.  Since you just mention bijection ... what exactly does bijection mean?  Is it a two dimensional projection or something of that sort?
18:58:54 <sethk> palomer, sorry
18:59:00 <sethk> palomer, isomorphism
18:59:05 <sethk> isomorphism, not polymorphism
18:59:15 <palomer> Cale: eh?
18:59:20 <Cale> sethk: an isomorphism of what?
18:59:33 <palomer> bijection = isomorphism in this case
18:59:40 <sethk> Cale, it's a logic equasion
18:59:48 <sethk> palomer, ok, then tell me what _either_ means.  :)
18:59:57 <Cale> sethk: isomorphisms are maps which preserve structure -- so probably in this case, preserve the logical operations
18:59:59 <palomer> isomorphism: bijection and stable under some binary relation
19:00:00 <sethk> Cale, equation.  I can't spell nothin'
19:00:11 <palomer> I meant bijection here
19:00:27 <sethk> Cale, let me see if I can find the example.
19:00:34 <palomer> Cale: oh, you have a point, it's not a bijection
19:00:50 <Cale> palomer: it is a surjection though
19:01:16 <Cale> it also has problems like node left left -> 0
19:01:31 <palomer> darn, I need a bijection
19:02:27 <Cale> well, let's see
19:03:02 <Cale> palomer: exactly why do you need the bijection?
19:05:58 <palomer> oh, because I want my combinators to represent functions from N -> N
19:06:06 <palomer> and a combinator is really nothing but a binary tree
19:06:15 <dave_m> you could have f(left) = 0, f(right) = 1 then you can use the bijection of rationals to naturals for node; f(node x y) = nat(x/y)
19:06:20 <sethk> Cale, it's a calculus with only conjunction and implication defined, and the comment about isomorphism vs bijection is in a spot where he is noting that the reduction rules are not reversible.  That is, things that appear on the left side of a reduction cannot appear on the right side of a reduction.
19:06:56 <Cale> dave_m: that won't work because of equivalence of rational numbers
19:06:59 <dave_m> that is, f(node x y) = nat(x/y) + 2
19:07:13 <Cale> better to take the bijection of pairs of naturals to naturals
19:07:19 <dave_m> then just use the diagonalization directly
19:07:22 <Cale> yeah
19:07:47 <dave_m> (0,0) -> 2, (0,1) -> 3, (1,0) -> 4, (0,2) -> 5, etc...
19:08:01 <palomer> oh my, any simple bijections from N^2 to N?
19:08:07 <palomer> (computationally simple)
19:08:58 <Cale> yeah
19:09:05 <dave_m> I think the diagonal one is as simple as it gets, but I could be wrong
19:09:24 <palomer> Cale: any examples?
19:09:24 <Cale> let me work out the exact expression
19:09:28 <sethk> I found a great diagram that explains bijection and surjection.  :)
19:09:57 <palomer> a bijection is a surjection and injection
19:10:06 <sethk> it's simple actually.  In words it sounded difficult.  :)
19:10:19 <sethk> palomer, yes, and this diagram even shows me what surjection and injection mean.  :)
19:12:59 <Cale> palomer: (n,m) -> n + (n+m)(n+m+1)/2
19:13:05 <Cale> is a bijection
19:13:31 <Cale> from NxN to N (where N includes 0)
19:14:15 <palomer> nested summations?
19:14:25 <palomer> how'd you get that?
19:14:32 <Cale> n+m gives you the diagonal which (n,m) lies in
19:14:41 <sethk> palomer, injective means mappings are unique (no two source domain values map to the same target domain value).  surjective means all target domain values are mapped.  bijective means both.  Is that right?
19:14:54 <int-e> or: n, n+m gives you an ordered tuple. (n<=n+m)
19:14:55 <palomer> sethk: righto
19:15:33 <sethk> palomer, thanks.  there might be hope for me yet.  :)
19:16:15 <Cale> A function f: A -> B is a subset of A x B = {(x,y) : x in A, y in B} such that if (a,b) and (a,c) are in f, then b = c.
19:16:57 <Cale> If (x,y) is in f, we write f(x) = y
19:17:09 <int-e> (a,b,c) -> choice(a,1) + choice(a+b+1,2) + choice(a+b+c+2,3)  is also a bijection. :)
19:17:12 <Cale> A function f is an injection if f(x) = f(y) implies x = y
19:17:37 <palomer> cale, I still don't understand how your bijection works (intuitively)
19:17:39 <Cale> A function f: A -> B is a surjection if for every b in B, there is some a in A such that f(a) = b
19:17:59 <Cale> palomer: make a plot of the values for points (n,m)
19:18:06 <Cale> (as a grid)
19:18:08 <Cale> you'll see :)
19:18:33 <Cale> note that k(k+1)/2 is the sum of the numbers [1..k]
19:18:49 <dave_m> how do retrieve the pair?
19:19:16 <palomer> here's a better question: is there a bijection such that f (node (node left x) y) = f x and f (node(node(node right x) y) z ) = f(node (node x z) (node yz))
19:19:48 <palomer> heck, is there an injection
19:19:55 <palomer> (making it easier for you guys)
19:21:53 <palomer> (if there was a bijection it would be considered an isomorphism)
19:22:00 <palomer> s/would/could
19:22:15 <int-e> If you want a bijection from N to NxN with an easier to compute inverse, you can use \a b->if a>b then a*(a+2)-b else b*b+a .
19:22:19 <Cale> bijections are the isomorphisms of sets
19:23:13 <Cale> palomer: it wouldn't be an injection then would it?
19:23:28 <palomer> oh, good point
19:23:33 <int-e> ['easier' meaning 'more obvious' - it still involves a square root]
19:23:35 <palomer> ok, give me a surjection
19:23:57 <palomer> Cale: actually, it is an injection for some other equality
19:24:24 <palomer> consider node(node(node right x) y) = node (node x z) (node yz)
19:24:34 <palomer> and node (node left x) y = x
19:24:35 <Cale> palomer: yeah, if you take equivalence classes of trees, then map those equivalence classes to naturals, then it might be
19:25:17 <palomer> Cale: the problem is finding a representative is undecidable:(
19:25:35 <Cale> palomer: what's your equivalence?
19:25:49 <Cale> (I can almost guess :)
19:26:00 <Cale> this is combinatory logic, right?
19:26:18 <Cale> left is K, right is S
19:26:45 <palomer> oh no, I've been caught!
19:26:49 <Cale> heh
19:27:00 <palomer> yeah, I want to consider my combinators as functions on the integers
19:27:07 <palomer> themselves being integers
19:27:16 <palomer> as you can see, these results aren't very interesting
19:27:37 <palomer> :(
19:27:43 <palomer> lemme give you another problem (complexity theory)
19:27:49 <palomer> if you can tell me the answer, you get a gold medal
19:27:52 <palomer> ready?
19:28:41 <palomer> actually, a smaller question
19:29:16 <palomer> is there a combinator that returns the true combinator when it gets two equal normalizable terms and the false combinator when it gets two non equal normazilable terms?
19:29:58 <Cale> is that a computable function?
19:30:11 <palomer> yes
19:30:15 <palomer> normal forms are unique
19:30:35 <palomer> However, I can't think of any combinators for the life of me
19:30:40 <Cale> then I think yes
19:30:45 <palomer> and my intuition is screaming "there isn't one"
19:31:12 <palomer> ok, this is equivalent to some lambda term that takes two variables and returns yes if they're equal, no otherwise
19:31:17 <palomer> can you think of any term?
19:31:20 <Cale> isn't every computable combinator expressible in terms of S and K?
19:31:30 <palomer> Cale: yes
19:31:33 <Cale> Well, I don't know how the algorithm works.
19:31:45 <palomer> I don't think there is such a lambda term
19:32:23 <Cale> hmm...
19:32:28 <Cale> perhaps there isn't...
19:32:50 <palomer> this is why I get goose bumps when people tell me "lambda calculus is turing complete"
19:32:51 <Cale> (disclaimer: I haven't formally studied computation)
19:32:59 <palomer> anyways, here's my problem:
19:33:08 <palomer> I have this function f
19:33:20 <palomer> which takes strings in some language (programs)
19:33:27 <palomer> and decides some property of that string
19:33:30 <palomer> (program)
19:33:33 <palomer> or doesn't halt
19:33:46 <Cale> yeah, maybe you can't do it directly -- you may need to encode the terms in some way first
19:34:05 <palomer> how hard is it to find a P such that f(P) is true
19:34:09 <palomer> knowing that such a P exists
19:34:11 <palomer> and always halts
19:34:27 <dave_m> depends on f, I'd say
19:35:14 <Kirby> palomer: that can be very hard, or very easy. (e.g., find the seed number P that has the property f(P) that it generated a certain 'pseudo-random' sequence)
19:35:52 <palomer> right
19:35:58 <palomer> the complexity depends on f
19:36:07 <palomer> but, the question is, how complex can it get?
19:36:27 <Kirby> insoluble complex
19:36:35 <palomer> there's such a thing?
19:36:43 <Kirby> in formal systems, ya
19:36:56 <palomer> but, like, you can enumerate all the P
19:37:03 <Kirby> says who?
19:37:10 <palomer> you can enumerate programs
19:37:22 <Kirby> you never said what P or f mean
19:37:36 <palomer> oh, f is a function which takes functions (programs, string, whatever)
19:37:54 <palomer> and decides something about it
19:38:15 <palomer> like f x = (x 4 = 6)
19:38:19 <Kirby> There are aleph-null program that have finite length. How would you look at all of them algorithmically?
19:38:32 <palomer> you can enumerate them
19:27:31 <palomer> can you not?
19:27:48 <dave_m> not in finite time
19:27:52 <Kirby> How can you look at *all* of them with an algorithm that will necessarily terminate?
19:28:02 <palomer> you know that such a P exists
19:28:12 <sh10151> doesn't a diagonalization argument work here?
19:28:13 <palomer> right?
19:28:23 <palomer> (we assume this)
19:28:28 <palomer> so you start with P_1
19:28:34 <palomer> while you're working on P_1 you start on P_2
19:28:36 <palomer> etc....
19:28:39 <Kirby> sh10151: sure. aleph-null is equivalent to the size of the set of natural numbers
19:29:03 <palomer> so, the further you have to go, the more programs you have to consider at once
19:29:07 <palomer> but this number is always finite
19:29:50 <dave_m> best case scenario, you find it right away; worst case, the universe ends before you find it
19:29:50 <Kirby> palomer: why not describe more exactly and concretely what you'd like to do?
19:30:31 <palomer> ok, I'll formulate it another way
19:30:39 <palomer> I have combinators (or lambda terms) T and T'
19:30:53 <palomer> and I know that there's an f such that T f = T'
19:31:07 <palomer> f having a normal form
19:31:12 <palomer> how hard is it to find such an f
19:31:26 <palomer> (my other formulation I thought easier to understand, but they're both equivalent)
19:31:35 <palomer> note: this is enumerable
19:34:28 <palomer> T and f can be thought of programs
19:34:35 <palomer> or values
19:34:36 <palomer> or whatever
19:34:46 <Kirby> That's not concrete to me :)
19:35:05 <palomer> ok, here would be a concrete example
19:35:38 <Cale> palomer: arbitrarily hard
19:35:58 <palomer> Cale: such a thing exists?
19:36:20 <palomer> Kirby: say I have computer programs
19:36:23 <palomer> and I have a compiler
19:36:38 <Kirby> okay
19:36:51 <palomer> and the compiler decides if the program has useless variables, or unmet dependencies, or some other predicate P
19:36:53 <Cale> Well, I think you can encode the finding of solutions to diophantine equations like this.
19:37:24 <palomer> now, you know that some program satisfies P, and you want to build this program
19:38:55 <Cale> or proving theorems in mathematics
19:38:59 <Kirby> so, for example, build a program that has 'useless variables'? int main() {int x; return 0;} ... is that what you want in a way?
19:39:33 <Cale> well, finding proofs of provable theorems anyway
19:39:50 <palomer> Kirby: yeah
19:40:01 <Kirby> or do you want a program with the property that it computes the nth factorial or something interesting--and you want to build these programs with a program?
19:40:15 <palomer> Cale: proving any formula about arithmetic is undecidable
19:40:28 <palomer> Kirby: nono, I want int main() {int x ; return 0;}
19:40:38 <Cale> palomer: right, I know
19:40:47 <palomer> Cale: this is decidable
19:40:50 <palomer> since its enumerable
19:41:19 <Kirby> palomer: I fail to see what's important about this, building a program automatically that has one 'useless' variable.
19:41:33 <Cale> If you know that a theorem is true, then assuming a finite axiomitisation, you can enumerate proofs until you find one./
19:41:39 <palomer> Kirby: now here's the deal, I want you to build a program for any predicate!
19:41:45 <palomer> Cale: right
19:41:57 <Kirby> I thought you had something like that in mind...
19:41:57 <palomer> Cale: actually, this problem IS equivalent to theorem proving
19:41:58 <Cale> So I think it's as hard as that.
19:42:04 <Cale> yeah
19:42:05 <palomer> Cale: now, what's the complexity of theorem proving?
19:42:12 <Cale> not sure
19:42:18 <palomer> argggggggggh
19:42:19 <Cale> I suspect very hard
19:42:31 <Kirby> palomer: build a program that has the property that it picks a stock that will double in price tomorrow
19:42:37 <Cale> and dependent on the axioms selected, but usually multiply exponential.
19:43:34 <palomer> Kirby: the property has to be checkable
19:43:41 <palomer> P is a program
19:43:47 <Kirby> read the newspaper =P
19:43:47 <palomer> if P is useless variables
19:43:58 <palomer> then P (int main(){int x;}) would return true
19:44:04 <palomer> then P (int main(){}) would return false
19:44:24 <Cale> I think C is a bad analogy for the sort of programs we're talking about :)
19:44:29 <Cale> hehe
19:44:35 <palomer> Cale: but it's concrete
19:44:48 <int-e> P (int main(){int x;f();x=42;return x;}) would solve the halting problem for f()?
19:44:52 <Cale> perhaps it would be better to think of our programs as Haskell-definable functions Integer -> Integer.
19:45:18 <palomer> Cale: I don't know if its equivalent
19:45:45 <Cale> hmm...
19:45:55 <Cale> oh, well, you'd need to restate it :)
19:45:57 <Cale> sorry
19:46:11 <int-e> have you come to a conclusion for the binary tree to integers surjection that's compatible with those combinatory logic reduction rules?
19:46:11 <Kirby> palomer: do you want to build programs or check programs, or make a program checker so you can spit out all possible programs and check them until you find one?
19:47:14 <palomer> build a program to build programs that satisfy a predicate
19:47:46 <Kirby> ghc compiler might do that for you.
19:48:42 <palomer> int-e: no, but it's a very interesting question
19:49:54 <palomer> ill think about it
19:51:08 <palomer> Cale: you can have theorem proving without axioms
19:51:16 <palomer> then again, we have to figure out which theorem proving we're talking about
19:51:23 <palomer> this is probably equivalent to higher order theorem proving
20:17:06 <int-e> palomer: regarding your 'equal reduced terms' question, the answer is no: consider App (App S K) K and App (App S K) S ... both behave as the identity combinator but they are different.
20:18:44 <int-e> With proper encoding, the problem is decidable of course; a black box approach like this is bound to fail.
22:05:01 * rasfar tinkles
22:15:02 <Torrente> Hola
22:15:07 <Torrente> alguien habla espanol"
22:22:44 <Lemmih> Dudo que mucho Haskellers habla espanol.
22:28:59 <dons> morning Lemmih
22:32:53 <Cale> huh, haskell.org is still down
22:35:15 <Lemmih> dons: http://212.242.49.100/hide-yi.png
22:35:43 <Lemmih> (scaled down 50%)
22:45:13 <palomer> int-e: err? I don't see why it's bothersome that they both act like the identity combinator
22:45:34 <palomer> Lemmih: nice
23:02:48 <autrijus> greetings \folks
23:05:00 <dons> morning autrijus
23:05:36 <dons> Lemmih, nice!
23:06:06 <dons> Lemmih, using ghc-src for Lexer.x ?
23:06:41 <dons> Lemmih, pushed? /me wants ot hack
23:09:06 <Lemmih> dons: I'm using the same lexer vshaskell is using.
23:11:15 <dons> are you calling into ghc-src? where does the lexer live?
23:12:39 <Lemmih> I'm planning to bundle it with hide-yi since it's pretty small (~200 lines).
23:14:30 <Lemmih> I'll push it once I've tracked down the last bug.
23:16:19 <ProfTeggy> Good morning.
23:16:38 <dons> Lemmih, ok. sounds good.
23:18:58 <musasabi> morning
23:29:49 <dons> autrijus, want to compile perl6 to javascript?
23:30:26 <autrijus> dons: already did so
23:30:29 <autrijus> passing 90% of 10,000 tests
23:30:37 <autrijus> spidermonkey is our first-tier vm.
23:30:46 <autrijus> (opera's and IE's works as well)
23:31:34 <autrijus> I think I'm going to give brendon a pugs t-shirt to thank him for "working on the perl6 vm" without knowing about it
23:31:44 <basti_> yay for perl6!
23:31:57 <autrijus> # http://m19s28.vlinux.de/cgi-bin/pugs-smokeserv.pl
23:32:06 <autrijus> grep for "javascript"
23:32:35 <autrijus> it's not very fast though, due to lack of goto()s so we needed to trampoline for CPS
23:32:45 <dons> @karma+ autrijus
23:32:46 <lambdabot> autrijus's karma raised to 2.
23:33:16 <basti_> even though i thoroughly dislike perl, i think the perl6 people are heading in the right direction.
23:36:20 <autrijus> I totally admire the Links (and now LINQs) vision :)
23:36:37 <autrijus> (and it just happens that haskell is a wonderful vehicle to make that happen)
23:36:52 <basti_> youre not secretly trying to take over world domination by compiling your interpreter to everything? .)
23:36:57 <autrijus> yes.
23:37:05 <autrijus> currently only ghc, perl5, parrot, javascript
23:37:11 <autrijus> but CLR, JVM and YARV are on the radar.
23:37:29 <autrijus> and some odd person who just arrived to this channel is working on a minimal native C codegen :)
23:37:39 <basti_> jvm might be a pretty good idea imo.
23:37:42 <autrijus> yup.
23:37:45 <basti_> at least bootstrap wise
23:37:55 <autrijus> *nod* tho for bootstrap perl5vm is the only choice
23:38:04 <autrijus> due to social, not technical, reasons
23:38:13 <basti_> heh
23:38:20 <autrijus> but jvm would draw useful hackers from a large pool indeed
23:38:37 <musasabi> autrijus: Have you gotten to the point where both javascript and haskell are just subsets of perl6? ;)
23:40:51 <autrijus> musasabi: no, we are still having problems with higher ranked polymorphism :)
23:41:02 <autrijus> musasabi: it'll be fixed in the milestone after the next though :)
23:41:39 <autrijus> ...and now I learned core GHC is not hard to hack after all, that may make it easier
23:42:29 <C-Keen> moin.
23:42:45 <autrijus> (worked on GADT+Record syntax with spj last night -- very exciting hacking)
23:43:15 <autrijus> spj had this idea that if the return type of GADT+Record constructors agree with each other, then we accept the same-named records
23:44:08 <autrijus> i.e. this should typecheck
23:44:10 <autrijus> data D t where
23:44:10 <autrijus>     C1 { x :: a, y :: b } :: D (a, b)
23:44:10 <autrijus>     C2 { x :: w, y :: (w, z) } :: D (w, z)
23:44:17 <autrijus> I think it's a pretty good extension to have
23:44:33 <autrijus> er
23:44:40 <autrijus>     C2 { x :: w, y' :: (w, z) } :: D (w, z)
23:44:43 <autrijus> sorry 'bout that.
23:47:48 <dons> $1b spend on IE *sigh*
23:48:35 <autrijus> dons: where are you in the room?
23:52:40 <dons> right side, 5 rows back
23:53:45 <autrijus> I can't see you from here then. I'm on the left side, 5 rows back
23:55:26 <ProfTeggy> dons, autrijus: where are you guys?  Some sort of conference/workshop?
23:55:44 <ProfTeggy> Lecture even? :-)
23:56:09 <autrijus> ICFP
23:56:23 <ProfTeggy> Oh, a worthy place to be.  Enjoy!
