00:01:08 <humasect> i'm not sure how to get readline linked in other than Extra-Libraries
00:18:30 <musasabi> Is there any tool to analyze dependency chains of Haskell modules? I am trying to find the best places to change imports to reduce dependencies.
00:24:56 <dons> hmm no. but there should be
00:28:54 <musasabi> As a related note - what would be an elegant way of making code using command line options not depend on the option parsing (even indirectly)
00:30:21 <musasabi> The basic problem is that we have "options = unsafePerformIO (getArgs >>= parseOptions)" and define e.g. "verbose = verboseFlag options" and a lot of code uses that.
00:31:29 <musasabi> One easy solution would be to use an IORef but then there would be no guarantee that it is really initialized. (i.e. options = unsafePerformIO (readIORef globalOptions))
00:49:15 <basti_> good morning
01:07:32 <gour> duncan: ping
01:23:55 <gour> @seen dcoutts
01:23:56 <lambdabot> dcoutts is in #haskell-blah and #haskell. Last spoke 14 hours, 45
01:23:56 <lambdabot> minutes and 22 seconds ago.
01:24:30 <gour> dons: ping
01:24:40 <dons> yes
01:24:46 <gour> hi dons
01:25:00 <dons> hey gour, what's up?
01:25:18 <gour> i just 'discovered' one interesting app in regards to hIDE project
01:25:44 <gour> have you seen http://pida.berlios.de/index.php/PIDA:About
01:26:08 <dons> nope, looking now
01:26:28 <gour> it's not haskell, but some ideas maybe be worth
01:27:50 <dons> very interesting, yes
01:28:07 <dons> can you stick a link on the hide wiki?
01:28:12 <gour> ok
01:34:31 <gour> dons: done
01:34:33 * boegel|home leaves again
01:46:33 <pkern> Is there any way to implement Float * Vector with Vector being (data Vector = Vector Float Float Float)?
01:48:29 <basti_> yes?
01:48:30 <basti_> :D
01:48:35 <humasect> smulvec f (x,y,z) = (f*x,f*y,f*z)  or something nicer.
01:49:01 <basti_> you could make type Vector = [Float]
01:49:15 <basti_> then scalarmul f v = map (f*) v
01:49:50 <humasect> ..which would work past 3 dimensions as well
01:50:21 <ibid> #haskell-blah?!
01:50:30 <pkern> So I need to develop a special set of functions to act on it instead of e.g. instanciating Num?
01:50:42 <basti_> ibid: yes?
01:50:54 <basti_> pkern: of course you can instance Num too
01:51:07 <basti_> if that is possible, that is
01:51:13 <pkern> basti_: But then it would only work on Vector `op` Vector? ;)
01:51:47 <basti_> yes, obviously it'd only work for +, - and maybe abs
01:51:47 <pkern> But ok thanks, I'll go for the set of functions then.
01:52:05 <ibid> basti_: just noted that upscroll
01:52:12 <pkern> basti_: Yeah, signum and fromInteger would be pointless. (*) would be the vector product which I do not know yet.
01:52:39 <basti_> pkern: it's not possible generally anyway
01:52:44 <pkern> Ok.
01:52:48 <basti_> only 3d vector product is a->a->a
01:53:07 <basti_> 4d ("tensor product") is a->a->a->
01:53:08 <basti_> a
01:53:19 <basti_> ibid: #haskell-blah is the channel for everything not haskell
01:53:39 <ibid> there are tons of channels for that ;)
01:53:55 <basti_> but none of them has the #haskell people as visitors! ;)
01:54:21 <humasect> also, readline is not linking in.
01:54:41 <ibid> basti_: too many channels already, sorry ;)
01:54:45 <basti_> ibid: ;)
01:55:03 <pkern> basti_: Thanks. (:
01:55:13 <ibid> (19 is the limit one can comfortably handle in irssi)
01:55:39 <basti_> hrh
01:56:00 <basti_> you just have to bind the a-row of keys
01:56:08 <humasect> c:/ghc/ghc-6.4/libHSreadline.a(Readline__108.o)(.text+0xa4):ghc2892.hc: undefined reference to `readline'
01:57:14 <basti_> humasect: -package readline?
01:57:26 <humasect> using Build-Depends: of cabal
01:57:56 <basti_> hmm
01:58:14 <humasect> also added it to Extra-Libraries which also os nop
01:59:14 <ibid> basti_: okay, 29. that's still limited :)
01:59:41 <basti_> ibid: you need a keyboard with an infinite number of keys.
02:01:03 * basti_ goes showering
02:01:03 <ibid> basti_: i suppose such a keyboard would have a key for "all of shakespare's works" :)
02:01:12 <basti_> definitely
02:02:25 <humasect> so i'm not sure what to do, i will go back to custom Makefiles for now.
02:12:08 <humasect> it looks like a little problem with the windows version of GHC 6.4, now... rr
02:52:31 <araujo> Hello
02:54:06 <ski> morning
03:08:24 <humasect> \c:/ghc/ghc-6.4/libHSreadline.a(Readline__108.o)(.text+0xa4):ghc2892.hc: undefined reference to `readline'
03:08:28 <humasect> YAY.
03:12:00 <humasect> ghc -o xyz <objects> -lreadline -package readline -package plugins
03:21:27 <basti_> humasect: congrats
03:21:47 <humasect> that's what fails.
03:22:06 <basti_> uh?
03:22:18 <humasect> that's all i can think of, even tried a different libreadline.a
03:22:40 <basti_> strange
03:22:42 <humasect> my suspicion is somewhere in the link process before it catches -lreadline, or -package readline.
03:32:00 <gour> @seen dcoutts
03:32:01 <lambdabot> dcoutts is in #haskell-blah and #haskell. Last spoke 16 hours, 53
03:32:01 <lambdabot> minutes and 27 seconds ago.
03:37:10 <Lemmih> dons: pong.
04:23:27 <basti_> :-o
04:23:32 <basti_> haskell is the power.
04:25:16 * xerox highfives basti_ 
04:25:30 <basti_> ^5
04:25:43 <basti_> postingrowhtml r = <tr><td><% r!body  %></td></tr>
04:25:43 <basti_> perform q db = do result <- query db q
04:25:44 <basti_>                   return $ map postingrowhtml result
04:26:06 <basti_> this snippet is all what i need to transform sql rows into a html table.
04:26:12 <xerox> yay
04:26:27 <xerox> What do you use for the embedded HTML syntax?
04:26:31 <basti_> hsp
04:26:35 <xerox> ooh.
04:26:37 <basti_> @where hsp
04:26:37 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
04:26:45 <xerox> The Lemmih's stuff?
04:26:53 <basti_> there is some code preprocessing feature in ghc
04:26:55 <basti_> yes
04:27:04 <basti_> i think it's lemmih's, that is
04:27:29 <basti_> it mangles arbitary xml stuff into haskell expressions
04:27:36 <basti_> and these are output reasonably by default
04:27:46 <basti_> further down i do:
04:27:48 <basti_>  <body>
04:27:48 <basti_>  <% queryhtmltable %>
04:27:49 <basti_>  </body>
04:28:16 <basti_> and the most exciting is: haskelldb and hsp don't bite each other at all
04:28:35 <xerox> :-D
04:28:37 <basti_> as you see in the r!body being mentioned inside a hsp expression
04:28:46 <xerox> Yep.
04:29:08 <basti_> most "wow" thing i've ever seen in haskell i think ;)
04:32:18 <dons> Lemmih, pong
04:33:04 <basti_> well worth the effort to build it.
04:34:47 <dons> Lemmih, I've decided you're probably right about the difficulty in adapting Yi immediately to hIDE.
04:35:11 <dons> I think i'd like to concentrate on building a gtk gui for standalone yi
04:35:38 <dons> whereas it may be better to proceed with a sourceview or what not in hIDE.
04:35:47 <dons> whaddya think?
04:36:01 <humasect> :o
04:36:18 <xerox> basti_: point me to something comprehensive for HaskellDB! :-D
04:36:27 <basti_> xerox: http://www.haskell.org/hawiki/HaskellDbTutorial
04:36:35 <xerox> Danke
04:37:24 <basti_> I'd recommend building from lemmih's packeages
04:37:33 <basti_> server seems down atm, though
04:47:08 <Lemmih> basti_: You're using musasabi's HSP, right?
04:47:20 <humasect> for hIDE interest: http://www.cs.kent.ac.uk/projects/pivotal/
04:47:36 <basti_> Lemmih: musasabi? maybe i confused people.
04:47:40 <Lemmih> dons: Sounds good.
04:48:57 <basti_> yes right http://www.cs.helsinki.fi/u/ekarttun/hsp/
04:50:29 <basti_> Lemmih: read the success story? First, i managed to build haskelldb yesterday. And then, today, I combined HSP and haskelldb, and it was totally painless
04:50:39 <Lemmih> Hurrah.
04:51:31 <basti_> haskelldb took about 30 minutes to build though.
04:51:48 <basti_> but as long as it finishes...
04:54:54 <musasabi> Has anyone implemented Text.Regex in pure Haskell?
04:56:09 * shapr boings cheerfully
04:56:44 <basti_> hey shapr. i got haskelldb+hsp to work.
04:56:46 * shapr throws salmiakki at musasabi 
04:56:55 <shapr> basti_: whoa cool, do you have a tech demo online with sources?
04:57:15 <basti_> uhm I could clean the sources a little, and show you the resulting page, which is a little bland so far though
04:57:16 * musasabi catches them in his mouth
04:57:33 <basti_> basically its a table with a silly text in its only cell
04:57:35 <basti_> ;)
04:57:41 <musasabi> god morgon shapr
04:57:45 <gour> dons: what is the impact of standalone Yi-gtk on hIDE in the long-term?
04:58:06 <shapr> hyv√§√§ huomenta musasabi!
04:58:46 <basti_> shapr: http://deimos.dynalias.org/cgi-bin/Viewposts < tech demo, source follows ;)
04:59:26 <musasabi> I got the idea that it should be quite easy to implement Text.Regex using parsec, the only small thing being parsing extended posix regexes (slightly boring to write the full parser).
05:00:02 <shapr> musasabi: Would be easier to test it for correctness then too.
05:00:44 <Igloo> I think I have a complete (except diacritics(?)) regexp engine in Haskell
05:01:11 <Igloo> http://urchin.earth.li/darcs/ian/regexp/
05:01:16 <musasabi> thanks.
05:01:47 <ndm> i'm having issues using Data.Map
05:01:55 <ndm> i am doing |import Data.Map as Map
05:02:04 <shapr> basti_: Uller Uller gong gong ?
05:02:11 <Igloo> You need to import it qualified
05:02:14 <basti_> shapr: should i put the source on the haskelldb page?
05:02:14 <ndm> but then when i use lookup in my code, it complains that
05:02:16 <ndm> *** Could refer to: Hugs.Prelude.lookup Data.Map.lookup
05:02:27 <ndm> is not import Data.Map as Map importing it qualified?
05:02:33 <basti_> shapr: yea fine uller... what do YOU put into demo datasets?
05:02:34 <Igloo> (or import Prelude hiding (lookup))
05:02:36 <Igloo> No
05:02:43 <ndm> ok, whats the qualified syntax?
05:02:47 <Igloo> You need qualified after import IIRC
05:03:00 <ndm> @docs Data.Map
05:03:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
05:03:06 <shapr> basti_: The same sort of stuff I guess.
05:03:14 * Igloo finds it hard to remember import syntax
05:03:16 <basti_> shapr: haskelldb wiki tutorial thing?
05:03:18 <ndm> that needs updating then
05:03:33 <shapr> basti_: Probably paste your source into its own page and link from the HaskellDB tutorial.
05:03:37 <ndm> import qualified Data.Map as Map is correct
05:03:41 <ndm> thanks Igloo
05:04:02 <basti_> mmmk
05:12:34 <basti_> shapr, xerox: http://www.haskell.org/hawiki/HaskellDbandHsp?action=show
05:13:44 <xerox> yay.
05:21:26 <shapr> hej sylvan
05:28:34 <dons> gour, i'd imagine that hIDE would eventually be able to use yi+gtk
05:28:44 * shapr boing profoundly
05:28:48 <shapr> jiihaa!
05:28:55 * shapr hugs dons 
05:29:00 <shapr> dons: Thanks for writing Yi!
05:29:13 * shapr boings in random circles
05:29:13 <dons> sure :)
05:29:30 <shapr> Oh, and thanks for hs-plugins too.
05:29:36 <shapr> and h4sh is really neat
05:29:42 * dons blushes
05:29:57 <shapr> oh and thanks for maintaining lambdabot
05:30:11 <metaperl> dons runs off and hides in the bushes
05:30:12 * dons thinks shapr must be drunk tonight
05:30:17 <xerox> ahah, shapr, you reminded me that when I was eight I wrote a program which drawn random circles (colours, position, and dimensions), it was between fun and psychedelic experience.
05:30:33 <dons> :D
05:30:36 <shapr> dons: Nah, I rarely drink.
05:31:22 <basti_> but if you do you drink lots?
05:31:37 <shapr> Yeah, I tend to off a bottle of sake in one sitting.
05:31:54 <basti_> sake tastes good.
05:32:00 <shapr> Yeah, I like it.
05:33:15 <ski> @vixen do you like sake?
05:33:16 <lambdabot> sure, i definitely don't hate
05:33:20 <shapr> So what's the status of yiDE?
05:33:49 <dons> so, I think we've decided that yi would have to be torn into little pieces to make it fit into hIDE.
05:33:54 <dons> I started doing this yesterday
05:34:03 <shapr> oh? what sort of pieces?
05:34:08 <dons> then I decided: maybe I should just get yi working with gtk first
05:34:23 <dons> I started rewriting the buffer code to use GTK.TextBuffer underneath
05:34:34 <sylvan> I need a fast catenable sequence in Haskell... Preferably O(1) to concatenate and O(n) to convert to a regular list.. Suggestions?
05:34:35 <dons> which would be easily drawable as a widget thingo
05:35:00 <Heffalump> so, who is ICFPing?
05:35:08 <shapr> sylvan: ++ is like that if you use it right.
05:35:14 <ndm> Heffalump, me - and TFP and Haskell Workshopping
05:35:14 <Lor> _o/
05:35:15 <dons> I will be, Heffalump
05:35:27 <sylvan> shapr, ++ is O(n) for concatenation?
05:35:30 <Heffalump> ndm: doing what inbetween? :-)
05:35:35 <Heffalump> oh, *and*, sorry
05:35:41 * Heffalump is going to CUFP + ICFP + HW
05:35:48 <shapr> sylvan: It's lazy, so it can be O(1) if you do it right.
05:35:58 <sylvan> "do it right"?
05:36:11 <sylvan> how do I do it wrong? =)
05:36:17 <dons> not . do it wrong ;)
05:36:23 <sylvan> =)
05:37:10 <Heffalump> ndm: do you know what dons or I looks like?
05:37:22 <ndm> Heffalump, nope
05:37:40 <ndm> i have a  photo at http://www.cs.york.ac.uk/~ndm
05:38:25 <Heffalump> http://www.earth.li/~ganesh/ is me
05:38:32 <dons> don't we have south park characters. isn't that enough? ;)
05:39:25 <ndm> mine is, yes
05:39:28 <shapr> sylvan: You know how ShowS works as opposed to Show ?
05:39:45 <sylvan> shapr, not really
05:41:05 <dons> anyone know how easy it is to get to the city from the airport in Tallinn?
05:41:55 <Heffalump> the instructions made it seem fairly simple
05:42:01 <Heffalump> but I haven't checked them for a bit. WHen do you arrive?
05:42:03 <ndm> does anyone know what currency estonia uses?
05:42:10 <Heffalump> Estonian stuff.
05:42:14 * ndm is a bit behind in the organisation...
05:42:14 <Heffalump> (i.e. not the Euro)
05:42:21 <ndm> do they take the euro?
05:42:31 <Heffalump> no idea. I suggest getting some local currency.
05:42:36 <ndm> Estonian Kroner is the official currency
05:42:37 <dons> the instructions on the icfp site. oh, "catch a taxi", wasn't it?
05:42:38 <Heffalump> But I think I read that ATMs are usually fine.
05:42:44 <Heffalump> dons: no, I saw some about buses.
05:42:52 <dons> ah. ok. i'll check again
05:42:54 <ndm> cool, its probably too late to get EKK now
05:43:03 <Heffalump> ndm: really?
05:43:09 <Heffalump> My bank can usually get them within a day or two.
05:43:13 <Heffalump> But perhaps I should order them now.
05:43:16 <ndm> maybe then
05:43:25 <ndm> i could get euros in a second
05:43:35 <ndm> but Estonian i'd have to order for, and that takes time
05:43:39 * Heffalump hangs on to euros
05:43:49 <Heffalump> I guess if you are going to TFP you'll be leaving in a day or two
05:43:57 <ndm> thursday morning
05:43:59 <Heffalump> ah, ok
05:44:02 <ndm> so yeah, not long
05:44:06 * Heffalump is going on Friday evening I think
05:44:10 <ndm> given that all banks close at weekends
05:44:39 <Heffalump> Lloyds OLB lets you order it online for delivery to a nearby branch
05:44:55 <ndm> i was going to try the post office
05:45:30 <shapr> sylvan: http://www.haskell.org/tmrwiki/LearningHaskellNotes#head-6b8b98b8ccb872401d38c597c93bfd0633b5dd92
05:46:52 <ndm> @docs Language.Haskell.TH.PprLib
05:46:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language.Haskell.TH.PprLib.html
05:47:06 <ndm> with reference to Doc, how does Haskell not get screwed up into little circles
05:47:15 <ndm> type Doc = PprM Doc
05:47:28 <dons> that constructor helps ;)
05:47:29 <ndm> where Doc in this case is a different Doc to the one defined in the type
05:47:41 <dons> oh. really?
05:47:45 <ndm> yep
05:47:49 <dons> hmm
05:47:49 <ndm> if you expand the type alias
05:48:03 <ndm> Doc = PprM (PprM (PprM (PprM (PprM (PprM ...
05:48:14 * ndm is writing a program that _does_ expand teh type alias
05:48:30 <dons> I have: type Doc = PprM HPJ.Doc
05:48:40 <dons> which makes it a bit simpler
05:49:35 <ndm> yeah
05:49:46 <ndm> but the haddock documentation i'm going from ommits the HPJ
05:50:07 <dons> ok, must be a haddockism
05:50:37 <ndm> grr, Haddock has a million little complications...
05:51:04 <shapr> I wish for a single doc format, something that combines both LaTeX beauty and Haddock html output.
05:51:38 <ndm> i wish for an XML output format
05:51:43 <shapr> Whyso?
05:51:49 <ndm> that can be then made to create HTML and Latex
05:51:57 <ndm> and also Hoogle input files etc.
05:52:06 <ndm> a separation between the front end and back end
05:52:07 <shapr> Ah, good point.
05:52:11 <dons> @seen Lemmih
05:52:12 <lambdabot> Lemmih is in #haskell. Last spoke 1 hour, 1 minute and 32 seconds
05:52:12 <lambdabot> ago.
05:52:17 <ndm> i also know someone working on such a tool, Salmon
05:52:26 <ndm> unfortunately its miles off being ready...
05:52:46 <dons> how's Hoogle2 (or is it 3?) coming along ?
05:52:54 <dons> in a darcs repo yet?? ;)
05:52:59 <dons> hehehe
05:53:01 <ndm> it has a CVS repo on sourceforge
05:53:11 <ndm> which is probably the best comprimise for suiting everyone
05:53:13 <dons> I know. just teasing!
05:53:16 <ndm> its Hoogle3
05:53:34 <ndm> i have a massive list of all GHC's functions, data's, type's, instances etc.
05:53:40 <ndm> i can parse that
05:53:52 <ndm> and i (just) have a type = dealiaser
05:53:54 <dons> should I update the hoogle I run in lambdabot yet?
05:54:01 <ndm> definately not
05:54:10 <ndm> its likely i'll have to break the existing one to get the new one in place
05:54:22 <ndm> so hold steady until the update is finish
05:54:26 <dons> ok.
05:54:35 <ndm> i'm also trying to make it 100's of times faster
05:54:53 <ndm> because its going to have 80 times more functions, and an insane amount of class information
05:54:57 <dons> hmm. does it have to suck in heaps of .hi files each time?
05:55:04 <dons> or is it all in a Show/Read database
05:55:10 <ndm> a database
05:55:19 <ndm> there is the sources, which it gets from haddock HTML files
05:55:24 <ndm> to a hoogle data file
05:55:32 <dons> where's the time penalty coming from?
05:55:38 <ndm> then there will be a parsed and optimised hoogle data file, with as much preprocessing as possible
05:55:46 <ndm> in the existing one>?
05:55:55 <ndm> everywhere, it was just never designed to be fast
05:55:59 <dons> no, the cutting edge
05:56:10 <ndm> the cutting edge one doesn't work at all
05:56:14 <ndm> i haven't got to the engine yet
05:56:24 <ndm> i'm just trying to make everything fast to begin with
05:56:30 <dons> ah ok. i was just sniffing out a chance to push fast packed string mmap IO on you ;)
05:56:46 <shapr> I tend to refactor existing code, then when I get bored I can just commit the changes and do something else.
05:56:49 <shapr> I can never do rewrites.
05:56:57 <ndm> the main time penalty is just a lot of data flying around
05:57:06 <ndm> shapr, usually i agree - hoogle 3 is an exception
05:57:13 <dons> shapr, did I tell you that SimonM sent me his packed string code?
05:57:21 <ndm> although having said that, i just rewrote WinHugs from scratch...
05:57:34 <dons> @karma+ ndm for that
05:57:34 <lambdabot> ndm's karma raised to 3.
05:58:01 <ndm> for hoogle3 or winhugs?
05:58:01 <shapr> dons: Nah, is that how your FPS lib was created?
05:58:22 <ndm> thanks anyway :)
05:58:24 <shapr> dons: I'm really glad you made the FPS lib, I really need it for combinatorrent.
06:00:19 <Lemmih> dons: I'm here.
06:01:03 <dons> Lemmih, so how do you want to proceed with hIDE at this point?
06:01:42 <dons> I was starting to pull Yi apart, and then I realised i was pulling it apart, which might take a  while to put back together
06:02:35 <dons> so, like I said, get a gtk yi going, independent of hIDE. but then what do we want to do with hIDE? back burner?
06:03:09 <shapr> What's the relation between hIDE and yi-gtk?
06:03:20 <Lemmih> I'm trying to dirty hack Yi into GTK mode just to get something going.
06:03:43 <Lemmih> shapr: Yi will probably be the primary editor in hIDE.
06:03:52 <dons> yep, I think so too
06:03:54 <Lemmih> shapr: Most of the cool plugins will require Yi.
06:03:59 <shapr> Sounds good to me.
06:04:04 <dons> Lemmih, are you starting with the code i sent you?
06:04:12 <dons> or are you doing something else?
06:04:16 <Lemmih> dons: Yes.
06:05:16 <Lemmih> (Yes, I'm using your code)
06:05:48 <dons> so i would imagine you get the buffer working, then get the core functions using that, which gives you vim and mg/emacs. you'll have to hack the Window code a bit I think. maybe it isn't even necessary to keep that code.
06:05:52 <shapr> samx: Are you the person formerly known as samc?
06:07:56 <dons> probably you can just get a single window up and editing in say vim or mg mode fairly quickly, with a bit of collateral damage on the way
06:07:59 <dons> but that would be ok
06:08:36 <samx> shapr, nope
06:08:48 <dons> anyway, night guys!
06:09:21 <Heffalump> afternoon.
06:09:24 <xerox> Goodnight dons!
06:11:54 <Lemmih> 'night dons.
06:17:42 <musasabi> dons: is there any chance of getting fps BSD licensed ?
06:18:25 <musasabi> Personally I would like to see it in base in the future...
06:21:57 <shapr> g'night dons
06:22:10 <shapr> Yeah, I'd like to see FPS in base as well.
06:25:44 <shapr> privet ikor
06:34:12 * Igloo has mailing contributors about that on my TODO list
06:34:26 <Igloo> I don't see why it should go into base, though
06:35:41 <ikor> i tebe privet, shapr :)
06:36:37 <Oejet> ikor: –ö–∞–∫ –¥–µ–ª–∞?
06:40:46 <ikor> Oejet: don't understand. please, in english or translit.
06:41:58 <musasabi> Igloo: to slowly replace Data.PackedString. It is very usefull in very many apps.
06:42:22 <musasabi> It seems that currently all larger Haskell projects have their own PackedString variant.
06:43:19 <Igloo> Why not just have a packed string package that everyone uses, though?
06:43:56 <Igloo> If we need to stuff everything useful into base then I think cabal has largely failed
06:44:33 <Oejet> ikor: Sorry, kak dela?
06:45:07 <musasabi> Igloo: I am thinking that it is useful to provide FastString instances for things in libraries. But depending only because of that on fps does not seem sensible.
06:45:32 <Igloo> Why not?
06:46:30 <musasabi> Because it is not needed for the library to work - just makes things simpler for everyone using PackedStrings.
06:47:00 <Igloo> But why is depending on fps worse than depending on base that includes fps?
06:47:46 <musasabi> Because installing libraries is not yet very automatized.
06:48:13 <Igloo> Then fix it, don't kludge around it
06:48:29 <ikor> Oejet: hot' my i ne znakomy. vse otlichn. u tebya kak? :)
06:50:11 <Oejet> horosho, spasibo.
07:00:31 <SickJacken> there's <<loop>> again
07:04:52 <Heffalump> that means it noticed it was in a blackhole
07:05:31 <SickJacken> now for locating it :S
07:06:38 <Heffalump> mapException might help
07:06:45 <Heffalump> or just catching exceptions at strategic points
07:06:57 <SickJacken> catching exceptions in haskell....
07:06:59 <SickJacken> thats new for me
07:07:32 * Heffalump is just off out so can't explain how, but it's quite simple (from IO)
07:07:36 <Heffalump> mapException doesn't require IO though
07:07:37 <SickJacken> ok later
07:07:53 <ndm> black-hat, from the hat tools helps with black holes
07:08:00 <Heffalump> but maybe you should just write a circularity test for your AG ;-)
07:08:15 <SickJacken> right
07:08:24 <SickJacken> then ill be finished with my thesis next year
07:09:36 <ndm> have you tried out hat before
07:09:39 <ndm> @where hat
07:09:40 <lambdabot> http://www.cs.york.ac.uk/fp/hat
07:10:10 <ndm> @help where
07:10:11 <lambdabot>  @where <key>, return element associated with key
07:10:11 <SickJacken> no i havent tried hat ever, ill have a look
07:10:23 <ndm> you run your computation, it produces a black hole
07:10:31 <ndm> you run black-hat over it, and it tells you why
07:10:42 <ndm> its a specialised hat tool just for black holes
07:10:51 <SickJacken> noiiiiice
07:29:45 <shapr> hiya AtnNn
07:29:49 * shapr boings
07:30:50 <shapr> Sure is quiet here today.
07:31:51 <ndm> maybe everyone is too busy hacking haskell, i know i am!
07:32:03 <shapr> Oh, that's a good reason!
07:32:08 * shapr gets busy hacking Haskell!
07:40:43 <vegai> anyone here played Master of Magic?
07:41:10 <Muad_Dibber> vegai: Master of Magic?
07:41:17 <vegai> the PC game, not the C64 game
07:41:51 <vegai> I find it weird that that game hasn't been cloned yet
07:42:01 <vegai> or remade with a GPL engine
07:42:07 <Muad_Dibber> well
07:42:15 <Muad_Dibber> we have #haskell-blah for offtopic chat ;)
07:42:21 <vegai> this is not offtopic
07:42:27 <Muad_Dibber> so come to the poitn :)
07:43:30 * ski 's played the C64 game
07:45:55 <gour> dcoutts: ping
07:57:26 <shapr> hey lightstep, ltns. What's up?
07:58:05 <lightstep> i was drafted to the army
07:58:24 <shapr> Oh, good reason.
07:58:43 <lightstep> not at all: they kill people
08:05:50 * shapr reads up on Starkiller
08:06:12 <Igloo> Wassat?
08:07:08 <lightstep> star wars? python?
08:07:20 <shapr> Static typing for Python, I wonder if I can do better in Haskell.
08:07:34 <shapr> Whether or not, it'll be fun to try.
08:24:17 <shapr> hiya jewel
08:25:55 <ndm> hugs seems to dislike my 6494 element array :(
08:26:06 <ndm> when it comes to haskell arrays is that just asking too much?
08:26:57 <shapr> tried it with ghc?
08:27:09 <ndm> not yet
08:27:17 <ndm> but i love my little WinHugs
08:27:36 <ndm> i was just wondering what a sensible size for an array was in haskell
08:29:18 <jewel> hi
08:29:26 <ozone> ndm: keep in mind that hugs is an interpreter, and that its arrays are boxed, meaning that it's an array of pointers to your values rather than an array of values
08:29:51 <ozone> ndm: so hugs isn't the ideal vehicle for dealing with huge quantities of small values
08:30:02 <ndm> ozone, yep, i know that - am increasing the heap size and trying again
08:30:12 <ndm> but i really like WinHugs2 :)
08:30:17 <ozone> cool
08:30:28 <ozone> and with that, g'night
08:30:31 <sylvan> I think I need some form of new data structure after all.. I'm basically merging disjoint paths over and over an that involves (++) and but also a "reverse" of one of the operands (in about 50% of the cases).. So I need to concat and reverse sequences in O(1) and then finally convert it back to a list (in O(n) preferably, but at least < O(n^2))
08:30:55 <sylvan> suggestions?
08:31:10 <ndm> a list of lists
08:31:24 <sylvan> what?
08:31:30 <ndm> if you keep a list of the paths
08:31:39 <ndm> then at the end, concat will merge them all in O(n)
08:32:15 <sylvan> that doesn't really work for my case.. I get a binary tree of (++) nodes basically
08:32:27 <sylvan> and some of those nodes may be wrapped in a "reverse"
08:32:34 <Igloo> 6494 doesn't sound like all that many elements
08:32:37 <ndm> sylvan, can you give precise details of the semantics of all the ops you need?
08:32:54 <sylvan> well... concat and reverse in O(1) =)
08:32:55 <Igloo> What's hugs saying?
08:33:09 <sylvan> I'm doing Kruskal's TSP algorithm, btw
08:33:18 <ndm> it was saying garbage collection failed to reclaim sufficient space, i've bumped teh heap size and its sorted now
08:33:33 <sylvan> I just need to be able to merge two sets in O(1) and possibly reversing one of them at the same time
08:33:49 <ndm> do you need to access that data again?
08:33:53 <ndm> before the final convert to a list
08:34:06 <sylvan> I may need to merge it with another path
08:34:14 <sylvan> which is itself a merger of two paths etc.
08:34:17 <ndm> by merge, you mean concat with a possible reverse?
08:34:21 <sylvan> yes concat
08:34:22 <sylvan> sorry
08:34:31 <ndm> so, to get it as an ADT:
08:34:35 <sylvan> so at the very end I end up with just a single path with concists of two subpath
08:34:43 <ndm> data Structure = ...
08:34:53 <ndm> concat :: Structure -> Structure -> Structure
08:34:58 <ndm> reverse :: Structure -> Structure
08:35:05 <ndm> fromList :: [a] -> Structure
08:35:11 <ndm> toList :: Structure -> [a]
08:35:16 <ndm> correct?
08:35:32 <sylvan> I'm in the ST monad so I'm thinking about doing a double-linked list and then tagging a reversed list with a "reverse" node which signals that the toList goes backwards
08:35:33 <sylvan> yes
08:35:38 <xerox> Structure a, maybe ?
08:35:44 <xerox> I mean, data Structure a.
08:35:48 <sylvan> yes
08:35:50 <ndm> pseudocode :)
08:35:55 <xerox> Sure, k.
08:36:06 <ndm> why not have:
08:36:39 <ndm> data Structure a = Reverse (Structure a)
08:36:41 <ndm>                            | Concat (Structure a) (Structure a)
08:36:42 <ndm>                            | List [a]
08:36:56 <ndm> then you can implement the first 3 as really simple
08:37:02 <sylvan> because thats basically what you get internally by just using ++ and reverse...
08:37:07 <ndm> and i reckon toList is O(n) best case
08:37:25 <ndm> traversing a binary tree in order is O(n)
08:37:26 <sylvan> you still have the problem of getting O(n^2) toList because every other node may be a reverse
08:37:37 <ndm> but you can be clever
08:37:41 <ndm> and propogate reverses
08:37:45 <sylvan> but you may concat two lsits, then reverse it, then concat and reverse again..
08:37:48 <ndm> using reverse laws
08:37:54 <ndm> i.e. reverse (reverse x) = x
08:38:10 <sylvan> Reverse (Concat x (Reverse x))
08:38:17 <ndm> reverse (a ++ b) = reverse b ++ reverse a
08:38:40 <sylvan> you'll still get some reverse's
08:38:48 <ndm> you do, but only at the bottom level
08:38:55 <ndm> so each element gets reversed at most once
08:38:58 <ndm> hence O(n)
08:39:00 <lightstep> you need to use the [a]->[a] trick too
08:39:08 <sylvan> that what-trick?
08:39:21 <lightstep> like shows
08:39:36 <sylvan> explain
08:39:38 <ndm> accumulation, you mean?
08:39:57 <int-e> traverseStructure::Bool -> Structure a -> [a] -> [a]; traverseStructure reverse struct tail = ...
08:39:58 <lightstep> yes, i'm searching for the wiki page
08:40:34 <lightstep> @wiki ListMutation
08:40:34 <int-e> the trick is to be able to pass tails into the list building function
08:40:35 <lambdabot> http://www.haskell.org/hawiki/ListMutation
08:41:19 <ndm> so you need two stages: pushing reverse to the bottom and doing the reverse, and traversing a binary tree
08:42:10 <ndm> sylvan, have you seen how reverse is defined internally?
08:42:31 <ndm> thats the standard example of accumulation, it turns an O(n^2) algorithm to an O(n) one
08:43:36 <sylvan> yes
08:44:46 <sylvan> aren't there structures like this available already?
08:45:00 <sylvan> there should be...
08:45:00 <shapr> Yup
08:45:03 <sylvan> where?
08:45:03 <ndm> not with your reverse property
08:45:05 <lightstep> Map
08:45:20 <shapr> Oh, I dunno about special properties, but have you tried Erwig's Graph library?
08:45:36 <ndm> doing toList on Structure can't be more than 3 lines
08:45:38 <sylvan> nah, I'll look into it...
08:45:47 <ndm> well, maybe 6...
08:45:53 <sylvan> Graph library with sequence data types?
08:46:41 <shapr> Erwig's lib is specialized for graph stuff. If you want the best of both worlds, check out Okasaki's libs (what's the name again?) and the recent new sequence library stuff on the libraries list.
08:47:26 <shapr> I wonder if Erwig's graph lib is cabalized. Last I heard Aetion was maintaining it.
08:47:44 <shapr> Pseudonym is maintaining a new version of Okasaki's libs, I think it's on haskell-libs.sourceforge.net
08:48:29 <sylvan> Edison?
08:48:34 <shapr> Yeah!
08:48:57 <sylvan> I may just write it myself, might be fun
08:49:03 <shapr> Yeah, true
08:49:59 <shapr> Erwig's lib is called fgl I think, functional graph library.
08:50:45 <lightstep> @paste
08:50:47 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:51:34 <sylvan> I don't want a finished graph solution, I need to write it myself..I just want the sequence data type
09:09:07 <SickJacken> hat needs hmake...
09:18:26 <ndm> yes, it really does
09:18:29 <ndm> (for the moment)
09:18:40 <Igloo> Well, technically it just makes it easier
09:18:53 <ndm> but realistically, its pretty hard without it
09:19:03 <ndm> although instructions are on the website for how to do it manually
09:20:04 <SickJacken> it doesnt compile
09:20:16 <ndm> using hat, you mean?
09:20:48 <SickJacken> i cant get it to compile on my ghc-6.4 system
09:21:24 <ndm> hat itself, or your code?
09:21:39 <SickJacken> hat
09:21:59 <ndm> have you got 2.04?
09:22:16 <ndm> only the very latest version builds with GHC 6.x
09:23:38 <SickJacken> i got the latest
09:24:16 <ndm> report the bug to the mailing list
09:24:45 <ndm> hat -AT- haskell.org
09:25:04 <SickJacken> maybe later, first im going to look for that black hole
09:26:12 <ndm> just copy the compile error and send it off quickly
09:26:27 <ndm> it should really compile out the box
09:27:44 <SickJacken> yeah maybe, but i really dont feel like fooling around with makefiles packages etc. ive lost to much time....so later on i will look into it
09:55:54 <araujo> Anyone knows if there is an equivalent function of the C popen() ?
09:59:07 <psi> @hoogle popen
09:59:24 <ndm> hoogle woulnd't have that even if it was there, sadly
09:59:34 <ndm> but looking at the GHC library i can't find popen
09:59:43 <ndm> but i think System.Posix may have something similar
10:01:17 <araujo> yeah, looking through it, let's see
10:01:59 <psi> System.Process has something like that
10:02:40 <int-e> System.Process.runInteractiveCommand looks good.
10:04:24 <araujo> let's see that, i just tested runCommand ....
10:14:15 <SickJacken> hey ndm, is it adviced to download the latest hat or
10:14:19 <SickJacken> ow crap
10:14:20 <SickJacken> wrong msg
10:14:33 <SickJacken> ICPanal: out of memory (requested 4183818240 bytes)
10:14:49 <ndm> SickJacken, i guess the latest hat is the recommended one
10:15:37 <SickJacken> ok,
10:15:49 <SickJacken> damn, i think i removed the black hole
10:15:55 <SickJacken> but this msg tells me different
10:19:56 <SickJacken> ffs how can that be true
10:20:09 <SickJacken> 4,1 gig of memory requested
10:31:31 <Heffalump> overcommit?
10:31:51 <SickJacken> whats overcommit?
10:32:10 <Heffalump> where the kernel allocates memory it doesn't have any only worries if people actuall write to more than it has
10:32:26 <Heffalump> s/any/and/ ; s/actuall/actually/
10:32:37 <SickJacken> could this be a kernel issue?
10:32:42 <SickJacken> i have this own 2.6 kernel
10:33:06 <int-e> hmm, could this be a way of saying 'I miscalculated and tried to allocate -111MB of memory'?
10:33:16 <Heffalump> int-e: lol
10:33:53 <SickJacken> cause first it said <<loop>> and that was right because i accidently defined two attributes in terms of eachother
10:34:09 <int-e> (it's 111149056 from 2^32)
10:34:22 <SickJacken> omfg
10:35:15 <SickJacken> i know what happened....
10:35:53 <SickJacken> in this AST tree the frontend gave every variable a unique identifier....i use the identifiers to built a callgraph...but i need to give Data.Graph.buildG a range....
10:36:03 <SickJacken> so i calculated the maximum of those identifiers...
10:36:12 <SickJacken> its was.....1045839327
10:36:13 <SickJacken> :D
10:36:26 <SickJacken> so i think this is the memory allocation
10:37:37 <int-e> sounds like fun.
10:38:59 * arjanb thinks SickJacken needs a weekend off from coding
10:39:22 <int-e> SickJacken: and the minimum was about 461000?
10:39:39 <int-e> SickJacken: err, divided by 4, 115000?
10:41:04 <SickJacken> haha arjanb is so right, but i havent got the time :D
10:41:19 <SickJacken> this thursday, i promise, im going to get totally wasted
10:54:29 <ptolomy> I mention this here because nobody I know in real life would find anything amusing: Today I was in Barnes and Noble, and while walking through their photography section, I saw two books on Design Patterns.
10:58:35 <xerox> @where GADT
10:58:36 <lambdabot> I know nothing about gadt.
10:58:44 <xerox> Me neither - hehe.
10:58:56 <xerox> I mean, where is The Right Source of knowledge about them?
10:59:16 <xerox> The Simon P.J. paper?
10:59:42 <Lemmih> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
11:00:00 <xerox> Ah-ha!  Thanks Lemmih.
11:00:07 <int-e> @help where
11:00:08 <lambdabot>  @where <key>, return element associated with key
11:00:45 <int-e> @where+ GADT http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
11:00:46 <lambdabot> gadt ~> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.
11:00:46 <lambdabot> html
11:03:48 <Lemmih> dcoutts: ping.
11:09:11 <xerox> Good.
11:17:39 <shapr> I think you can force a license onto users of software, but not hardware, right? That sort of license that says "use of this software shows agreement with the license" really does apply, doesn't it?
11:18:12 <shapr> Basically, I was just wondering how you could use the DMCA, etc to force particular hardware to only run OSS approved software.
11:18:22 <shapr> hiya greenrd
11:18:31 <gour> shapr: do you have time for a short question?
11:18:35 <shapr> gour: Sure, ask me.
11:18:43 <gour> 14th chapter of the book..
11:18:45 <ibid> since usage is protected by law, "use shows agreement" does not hold
11:19:00 <gour> shapr: i defined type of months
11:19:01 <ibid> you need either distribution or other such thing to be able to say that
11:19:11 <shapr> ibid: How so?
11:19:25 <shapr> ibid: Could I put a license on hardware that such distribution of this hardware shows agreement with the license?
11:19:37 <gour> shapr: deriving (Eq,Ord,Show,Read)
11:20:07 <gour> shapr: how i can check derived definitions in ghcis/hugs?
11:20:18 <shapr> I don't think you can check them at all.
11:20:20 <ibid> shapr: hardware is not copyrightable, is it?
11:20:37 <shapr> ibid: It is if all your hardware is running on FPGAs, right?
11:21:01 <ibid> shapr: if you're just moving a physical copy around, that's not distribution or copying
11:21:22 <ibid> shapr: distribution in this sense means activity that creates new copies of the software
11:21:34 <ibid> (and distributes them to other people)
11:21:53 <gour> shapr: hmm: 14.7 exercise: investigate the derived definitions for Temp & Shape..
11:22:08 <int-e> shapr: the DMCA will not do that; but the DMCA can prevent people from replacing the BIOS in the hardware that enforces your policy.
11:22:25 <ibid> shapr: it's like you don't need a license from the copyright holder to resell a book  you own
11:22:32 <shapr> ibid: Since software has lots of insane protections in the USA, I'm trying to find some way to use those protections to enforce DFSG-like use of FPGA patterns.
11:22:53 <ibid> shapr: i won't help you there
11:23:18 <int-e> shapr: if you look at possible uses and abuses of TPM&co this is the most prominent worst case scenario - the industry locking down the computers so it will only run MS software. (say)
11:23:19 <shapr> Just curious if it's possible at all.
11:24:06 <shapr> gour: It probably means "use the derived typeclass instances, see what you get"
11:24:09 <xerox> GADTs are great!
11:24:20 <shapr> int-e: Yeah, and I wonder if FPGAs is the most likely way to do that.
11:24:53 <ibid> shapr: what you can do is make every recipient sign (or otherwise agree to) a contract.  if there's an offer, an acceptance, and consideration, then the contract is binding
11:26:16 <xerox> dcoutts: ping
11:26:33 <shapr> This implies to me that software is in fact math, and should not be patentable at all.
11:26:35 <gour> shapr: ok
11:26:45 <shapr> I'm not even sure how you could copyright math.
11:26:49 <shapr> I guess you could copyright proofs...
11:27:36 <ibid> shapr: you can copyright a math text, but math is ideas, not its expression and hence uncopyrightable
11:27:42 <ibid> math is also unpatentable
11:28:00 <int-e> ibid: but you can patent a machine that carries out proofs ... :(
11:28:15 * int-e thinks of software patents.
11:28:17 <shapr> So why can't I use the curry-howard isomorphism to show that all software is math?
11:28:38 <ibid> so are computer programs "as such" (the funny thing is that when you write it "a computer system, some of which may be implemented in software, that does blah blah", then you effectively patent the program)
11:28:48 <xerox> shapr: what a point.
11:29:04 <xerox> How are isomorphism treated in legislation? :D
11:29:06 <int-e> shapr: you'll have to explain that in court when someone sues you for copyright infringement.
11:29:21 <int-e> err, patent infringement, sorry
11:29:44 <ibid> shapr: what you, in fact, end up doing is show how math is also patentable ;)
11:29:57 * int-e wonders about a better place for this discussion.
11:30:02 <xerox> Patented formulas, brr
11:30:10 <shapr> hiya eieiei
11:30:11 <xerox> int-e: I think it's fine here.
11:30:27 <eieiei> I need a better nickname.
11:30:33 <int-e> eggeggegg?
11:30:38 <shapr> eieiei: what about eieio ?
11:31:01 <xerox> A lisp!
11:31:11 <syntaxfree> I wonder if Sonic Youth was thinking about Lisp when they wrote "The Ineffable  Me".
11:31:12 <shapr> A concatenative language!
11:31:18 <int-e> a TeX!
11:31:20 <xerox> @wikipedia Curry Howard isomorphism
11:31:23 <lambdabot> http://en.wikipedia.org/wiki/Curry_Howard_isomorphism
11:31:45 <syntaxfree> I have a little idiotic piece of code that just doesn't run.
11:31:45 <shapr> hiya camio
11:31:52 <camio> hi
11:31:55 <syntaxfree> http://pastebin.com/366497
11:31:55 <shapr> syntaxfree: Tell us about it.
11:32:07 <int-e> ibid: well, math in form of software in form of 'mechanisms' is patentable. that's proven in practice.
11:32:24 <shapr> syntaxfree: you need to change your indentation
11:32:28 <ibid> int-e: tell me something i don't know
11:32:45 <syntaxfree> gah, I'm going braces-und-semicolons.
11:32:49 <shapr> syntaxfree: line up the then and else lines with the if
11:32:59 <shapr> camio: Learning Haskell?
11:33:23 <camio> No, just trying to find words to speak of what I just read . . . the OOHaskell paper.
11:33:33 <gzl> shapr: can you actually make that argument with curry-howard?
11:33:34 <xerox> It does compile here syntaxfree.
11:33:48 <syntaxfree> hmm. I'll try that.
11:33:50 <gzl> is simply typed lambda calculus turing complete?
11:33:55 <int-e> ibid: hmm. did you know that ``ci`ci is a nonterminating Unlambda program?
11:34:06 <gzl> I know System F isn't
11:34:06 <syntaxfree> it does compile, but a call to secantroot will yield an error.
11:34:20 <xerox> System F is what GHC uses internally IIRC
11:35:25 <gzl> I'm no expert on C-H, but I thought the programs it uses are in simply typed lambda calculus
11:35:54 <gzl> so you can't really say that some random program in some random language is equivalent to one of those and so equivalent to some proof, no?
11:36:21 <Heffalump> you can'twrite non-terminating programs in simply typed lambda calculus, can you?
11:36:31 <shapr> I can write 'real' programs in Haskell, right?
11:36:32 <Heffalump> (without adding constant symbols)
11:37:10 <gzl> I don't remember.
11:37:24 <ibid> int-e: no, thanks :9
11:37:39 <camio> shapr, anyone: Have you checked out the OOHaskell paper? Seems like the most revolutionary Haskell concept since Monads. http://homepages.cwi.nl/~ralf/OOHaskell/
11:38:07 <greenrd> camio: I have read it, and offered suggestions on an earlier draft.
11:38:23 <shapr> Yeah, OOHaskell is cool.
11:38:44 <gzl> damn, this is long
11:38:55 <gzl> shapr: I guess. is that enough to make this claim/
11:39:37 <shapr> I don't know, I'm reading the wikipedia article.
11:40:14 <camio> I can¥t wait until OOHaskell becomes widely used. I think some ghc candy put on it could make it perfect for making nice object systems.
11:40:55 <shapr> camio: Do you think Haskell needs an object system?
11:41:10 <shapr> For the most part, I'm fine with monads as the main abstraction.
11:41:19 <camio> shapr: Absolutely.
11:41:28 <shapr> How so?
11:41:50 <int-e> syntaxfree: what's your call to secantroot?
11:41:54 <camio> shapr: For a extendable heiarchical CAD/CAM program for example.
11:42:24 <shapr> How are objects needed for that?
11:42:37 <shapr> I think I could do that just as well with monads, maybe better.
11:43:17 <camio> shapr: Each object needs to be interfacable with widgets as well as OpenGL drawable.
11:43:33 <shapr> Typeclasses could do that.
11:43:42 <shapr> gzl: Look at the "Programs are proofs" section.
11:44:01 <camio> shapr: So could OOHaskell, but in a painless way instead.
11:44:32 <shapr> In my experience, typeclasses are less painful that OOP systems. But I haven't used every OO system that exists.
11:44:42 <camio> shapr: We, of course, would need to maintain a list of distinct objects. The OOHaskell method for that is key.
11:44:45 <shapr> s/that/than
11:45:37 <shapr> What would a widget interface/OpenGL drawable look like with OOHaskell?
11:45:48 * shapr hacks up a quick typeclass implementation
11:46:42 <camio> shapr: Essentially a member function that does the appropriate output for OpenGL. Each property would have a two way get/set connection to a widget.
11:46:47 <gzl> shapr: ok.
11:48:19 <shapr> gzl: If you have proofs for S and K, and all other functions can be created from those two, it seems to me that you could come up with a proof for any program.
11:49:32 <shapr> camio: Member functions for each instance sound about the same as typeclass instances for a ShowOpenGL typeclass. I'm still thinking about connecting widgets and values easily.
11:49:37 <camio> shapr: Best part of it is, all this OOHaskell stuff maintains being statically typed. So now we can do OO in a straghtjacket too :)
11:49:49 * syntaxfree wonders if his connection is back.
11:49:49 <syntaxfree> it's  funny how my internet connection often will go down for 10 minutes and IRC will keep onl
11:51:17 <camio> shapr: And then having a list of GLDrawAble objects? Therein lies a problem.
11:52:03 <syntaxfree> geeze. Domain names must be broken. I can't make lisppastes or open google. But I'm still online here.
11:52:15 <shapr> camio: What problem?
11:53:03 <camio> shapr: You can't represent a list of GLDrawable objects without using something like HList.
11:53:11 <Lemmih> camio: Sure you can.
11:54:57 <camio> Lemmih: How? Using that existencial extension? HList works much better. I don't have to do any extra definitions or types and I get a list with the type of "lowest common superclass" for free.
11:57:13 <shapr> I'd probably start with a record type for CAD/CAM solids.
11:57:26 <shapr> Or maybe combinator definitions.
11:58:15 <Lemmih> I'm not interested in which approach you like the most. I'm saying that it's easy to have a list of objects which share a common interface without using something like HList.
11:58:41 <camio> Lemmih: I'm waiting for you to show how it's easy.
11:59:30 <shapr> I wonder if there's a nice non-OO solution to a CAD/CAM application.
11:59:33 * shapr thinks
11:59:47 <Lemmih> @wiki ExistentialTypes
11:59:47 <camio> shapr: But I don't see how that approach is going to be quicker or easier than an OOHaskell approach.
11:59:48 <lambdabot> http://www.haskell.org/hawiki/ExistentialTypes
12:00:08 <camio> shapr: I would love a non-OO solution to that particular problem.
12:00:36 <camio> Lemmih: Sorry, but when compared to HList, it is not easy ... seems more like a pain.
12:01:09 <shapr> What about a record type that has a list of Property values?
12:01:26 <camio> Lemmih: And you have to specify what type of list you want instead of the compiler figuring that out for you.
12:01:30 <tuomov> how to cat without cat?
12:01:39 <int-e> shapr: did your quick typeclass implementation end up anywhere? I'd like to see it :)
12:01:40 <tuomov> ~$ cat /proc/mounts
12:01:40 <tuomov> bash: /bin/cat: Input/output error
12:01:41 <shapr> tuomov: echo < filename maybe?
12:02:05 <tuomov> shapr: no, that doesn't work
12:02:24 <lightstep> xargs echo filename?
12:02:25 <tuomov> exec can be used to do something, but it quickly kills the shell, and I can't start new ones
12:02:58 <int-e> # perl -p -e '' < /proc/mounts
12:03:00 <int-e> hehe
12:03:02 <shapr> int-e: No, I got distracted, but I can finish it.
12:03:10 <tuomov> no, with the shell alone
12:03:19 <tuomov> ls seems to be in memory, but that's about it..
12:03:19 <lightstep> dd if=file
12:03:28 <tuomov> I don't think I've used dd recently either
12:03:32 <camio> shapr: An object in this system is essentially a bunch of modifyable values coupled with a few functions that "decompose" it in a sense. Interfacing this structure to the user is where OO really helps.
12:03:47 <tuomov> Now the music died too! This is the end!
12:03:57 <shapr> camio: I don't see how OO helps more than other approaches?
12:04:04 <syntaxfree> tuomov: are you the ion3 tuomov?
12:04:07 <Lemmih> camio: No you don't. And HList's must be known at compile-time so their usability is limited.
12:04:19 <tuomov> syntaxfree: yes
12:04:25 <syntaxfree> hey. cool!
12:04:31 <int-e> # (read i; while [ ! -z "$i" ]; do echo $i; read i; done) < /proc/mounts
12:04:50 <syntaxfree> I met one of the authors of Lua the other day.
12:04:51 <camio> shapr: Helps in that it requires less code and is more straightforward to implement.
12:04:53 <tuomov> killed the shell
12:05:00 <syntaxfree> met personally.
12:05:00 <int-e> cool.
12:05:06 <int-e> works here though
12:05:06 <tuomov> I think I need to boot and hope this fixes the hd again..
12:05:06 <shapr> camio: I don't believe that it requires less code. I'd have to see it to believe it.
12:05:10 <camio> shapr: Same argument for a high level language over assembly.
12:05:26 <tuomov> actually, I'm starting to think it is the interface that is broken
12:05:28 <camio> shapr: Plenty of examples in the paper.
12:05:40 <int-e> shapr: that would be nice
12:05:49 <tuomov> I used to have hda simply hang the system, but now its hdb, IIRC, that's simply not responding
12:05:55 <camio> Lemmih: What do you mean that they must be known at compile time?
12:09:30 <camio> Anyway, OOHaskell is the best object system I've seen. It is very exciting. We'll be seeing big changes in the haskell code put out. Along with many more user-interactive applications.
12:09:49 <syntaxfree> *Main> :t and        ==>     and :: [Bool] -> Bool
12:10:06 <syntaxfree> does that mean "and" takes a list as an argument, as opposed to an arbitrary number of individual arguments?
12:10:17 <shapr> camio: Which examples in the paper?
12:10:56 <psi> syntaxfree: yes
12:11:32 <camio> shapr: http://homepages.cwi.nl/~ralf/OOHaskell/code.html <- get the zip file and check out the Shapes.hs example and compare it to the Shapes directories.
12:12:00 <camio> shapr: The directories contain the pre-paper haskell solutions.
12:13:37 * shapr reads
12:18:11 <shapr> hey SyntaxNinja
12:18:17 <shapr> Fixed your laptop?
12:18:46 <shapr> camio: I dunno, these code examples assume that OO-style extensibility and mutability are good things.
12:19:59 <camio> shapr: The IORefs used could be easily changed to be MVars.
12:20:02 <shapr> camio: I don't miss OO-style extensibility these days, and I only miss mutability because it's faster on today's hardware.
12:20:04 <greenrd> shapr: well I think they just did imperative style OO because if you can do imperative style OO, functional style OO should be easy
12:20:43 <greenrd> it's a proof-of-concept paper
12:21:35 <shapr> It sure is a cool paper.
12:21:41 <shapr> But then, anything Oleg writes is cool.
12:21:58 <camio> shapr: Really? What other papers has he written?
12:22:07 <camio> shapr: Especially cool ones I mean.
12:22:31 <shapr> Lots, I was especially impressed with his series of email 'articles' on the Zipper as a tree of delimited continuations.
12:23:22 <SyntaxNinja> hi shapr
12:23:24 <greenrd> camio: I read the paper some time ago. What is the essential reason why you can't just use type classes to do OO in Haskell? I did know it but I've forgotten.
12:23:32 <xerox> shapr: url?
12:23:35 <SyntaxNinja> no, my laptop still sucks, but it takes like an hour to break, or more. depends on temperature.
12:25:29 <camio> greenrd: I really couldn't tell you. I've just begun to understand the HList stuff.
12:25:46 <Lemmih> camio: Try generating a HList from some dynamic information.
12:27:07 <SyntaxNinja> hi Lemmih!
12:27:21 <greenrd> Is it possible to write a curried pair type constructor?
12:27:23 <shapr> camio: Anyway, I still don't see that OO does much that I can't do with monads, but I'd be happy to be shown how OOHaskell will solve my problems :-) Why not write up a gtk2hs demo for the property stuff? If it's much more elegant, I'll start using it.
12:27:36 <greenrd> Not a custom one, but one which actually creates a pair like (a,b)
12:27:50 <Lemmih> Hi SyntaxNinja.
12:27:51 <greenrd> I want to say instance ConsG Pair b c
12:28:07 <greenrd> where ConsG is a class of mine and Pair is the curried pair type constructor
12:29:40 <camio> shapr: I guess I only know from my experience of trying to do CAD/CAM in haskell. I had to give up and get some real work done in the end. Now I have new hope :)
12:30:07 <SyntaxNinja> Lemmih: how's it going?
12:30:17 <shapr> camio: If you show a motivational code demo that vaguely works, you'll get a lot of people interested.
12:30:53 <lightstep> greenrd, do you mean having OO interface = type class, OO class = existential type?
12:31:26 <lightstep> greenrd, if so, the OOHaskell paper claims you don't have as much type inference as their solution has.
12:31:53 <greenrd> lightstep: I wasn't thinking of existential types, just ordinary, boring, non-existential types, but whatever.
12:31:55 <camio> shapr, that's a good idea. I might just put something together with my previous attempts.
12:32:54 <lightstep> greenrd, if you have a Shape type class, then the type of a general list of shapes uses an existential type.
12:33:12 <Lemmih> SyntaxNinja: Great. Almost finished integrating Yi in hIDE.
12:33:45 <greenrd> lightstep: OK
12:34:13 <SyntaxNinja> Lemmih: you're an animal ;)
12:34:15 <greenrd> lightstep: However, I am of the view that type inference is inappropriate in general for OO code.
12:34:21 <camio> Anyway, gotta go guys. Later.
12:34:23 <greenrd> lightstep: I believe that OO methods should be explicitly typed.
12:35:11 <greenrd> lightstep: Otherwise, their types may hinder future evolution (both in terms of changing existing classes, and subclassing).
12:35:25 <lightstep> greenrd, there may be other problems, I only read about 1/3 of the article.
12:58:02 <SyntaxNinja> @wiki
12:58:04 <lambdabot> http://www.haskell.org/hawiki/
13:01:00 <ndm> does haskell have any serialisable class or some such?
13:01:15 <ndm> i.e. to save an element to a file and read it back?
13:03:42 <lightstep> Show
13:03:59 <Cale> ndm: Doesn't seem like there's really a standard for that.
13:04:02 <SyntaxNinja> ndm: read and show are good for a simple version of that
13:04:12 <ndm> yeah, i want more than just Show
13:04:24 <SyntaxNinja> ndm: there's a Binary.hs module for writing structures as binary data, which I picked up from dons, I think.
13:04:27 <ndm> since I want to use Show for something else as well, i.e actually showing it
13:04:54 <SyntaxNinja> eh, I would stick to using the default implementations for read and show, since they come for free
13:04:57 <ndm> SyntaxNinja, i thinik i'll avoid binary for the mo, but it might be later now
13:05:05 <ndm> not really helpful
13:05:07 <SyntaxNinja> use them for serialization, then write your own functions, like "prettyShow" for printing to the screen or whatever.
13:05:32 <ndm> hmm, i don't think just show for serialisation will cut it sadly
13:05:39 <SyntaxNinja> why?
13:05:54 <ndm> i have arrays, will they read/show serialise?
13:06:14 <Igloo> Yes
13:06:32 <Igloo> Assuming you don't have any undefine elements, anyway
13:06:40 <shapr> ndm: There's SerTH by musasabi
13:06:56 <ndm> shapr, i'm going to try and avoid template haskell
13:07:01 <shapr> Oh, ok
13:07:03 <ndm> i guess thats what the TH stands for
13:07:09 <shapr> yup
13:07:29 <ndm> i've decided i hate it, because of all the nasty bits in teh haddock docs generated mean i have to have lots of specific TH code
13:08:01 <ndm> (not really a good reason, but a reason none the less)
13:08:15 * shapr shrugs
13:09:10 <ndm> how fast is Show/Read?
13:09:16 <ndm> i.e. faster than a hand rolled implementation
13:10:35 <SyntaxNinja> don't know
13:11:06 <lightstep> Read is specified to be slow
13:12:05 <SyntaxNinja> it's so easy, though! ;)
13:12:19 <ndm> no, its quite hard
13:12:27 <ndm> with all the {} and [] and ,'s
13:12:43 * Igloo has visions of delay loops being inserted into read code to make it slow enough
13:12:48 <ndm> Show is easy, 1 to 1 mapping
13:12:54 <Cale> Igloo: heh
13:13:06 <ndm> Read there are many instances that go to the same data structure
13:13:09 <lightstep> lazy delay loops, that is
13:13:13 <Igloo> Why is that a problem?
13:13:21 <ndm> its a complication
13:13:25 <Igloo> For what?
13:13:26 <basti_> lazy delay loops? they dont do anything until their result is needed?
13:13:27 <ndm> and also checking for a valid syntax
13:13:34 <Igloo> reads does that for you
13:13:45 <lightstep> no, they count lazily
13:13:55 <ndm> exactly, but that means reads must do more work
13:13:59 <Igloo> You can just use show and reads and never look at the string yourself
13:14:11 <ndm> than an equivalent hand rolled imp that never checks the details
13:14:22 <ndm> i know that,, but i was wondering about their performance
13:14:29 <Igloo> I'm not sure I understand "its a complication"
13:14:43 <Igloo> It's not complicated to code
13:14:54 <Igloo> If profiling later shows it is too slow then replace it with something faster
13:17:15 <poetix> Does the Show typeclass require that a read implementation be specified as well as one for show?
13:17:43 <lightstep> poetix, no
13:18:28 <SyntaxNinja> ndm: easy == easy to use
13:18:34 <poetix> I didn't think so. So I haven't broken any kind of contract if I write a show implementation that can't be unambiguously read back into the original value?
13:19:07 <Igloo> poetix: No, but if you don't derive them then it is unpleasant to use hugs/ghci with the types
13:19:24 <Igloo> Well, if you don't derive Show, anyway
13:19:32 <ndm> SyntaxNinja, usually i agree - but because of the particular problem I want soemthing fast rather than easy to write
13:20:03 <poetix> Yes, I understand that - I tend to derive Show for exactly that reason - but don't always represent the *whole* of the value
13:20:06 <lightstep> The contract is between Show, Read and Eq: read . show = (==)
13:20:21 <SyntaxNinja> ndm: makes sense.
13:20:46 <poetix> lightstep: Right, so there is some contract. But it's not enforced by the type system.
13:21:28 <poetix> Or is that just the contract for Read?
13:22:16 <lightstep> Nothing is enforced.
13:22:53 <poetix> Should any implementation of Show in principle be such that an implementation of Read could be given for which read . show would = (==)?
13:24:04 <poetix> In Python, for example, __str__ is distinct from __repr__ - one specifies how a value should be inserted into a string, the other specifies how a representation of it (that happens to be a string) should be given
13:25:25 <xerox> read . show = (==)  ?!
13:25:25 <lightstep> http://xp.c2.com/YouArentGonnaNeedIt.html
13:26:59 <Heffalump> xerox: no
13:27:06 <Heffalump> oh, sorry.
13:27:07 <lightstep> silly me
13:27:13 * Heffalump reads scrollback properly.
13:27:37 <Igloo> id, not (==)
13:27:52 <xerox> or  read . show == show . read  ?
13:27:53 <Heffalump> x == id x
13:27:58 <Heffalump> oh, but that's obvious
13:28:02 <Heffalump> xerox: that's not type correct
13:28:11 <xerox> show . read = id -- makes sense
13:28:26 <xerox> @type read . show == show . read
13:28:33 <xerox> Oh yes
13:28:35 <lambdabot> bzzt
13:28:36 <xerox> Silly me this time.
13:28:42 <poetix> @type read . show
13:28:43 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
13:28:44 <poetix> @type show . read
13:28:46 <lambdabot> String -> String
13:29:03 <poetix> @type read . show . read . show
13:29:04 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
13:29:17 <xerox> @karma+ poetix
13:29:18 <lambdabot> poetix's karma raised to 3.
13:29:44 <lightstep> forall x. read (show x) == x
13:29:47 * poetix glows with a strange, unearthly light
13:29:49 <lightstep> that's what i meant
13:30:06 <poetix> I must stop putting uranium in my cocoa
13:30:23 <xerox> @type \x -> read (show x) == id
13:30:25 <lambdabot> bzzt
13:30:32 <xerox> eheh, oops!
13:30:56 <xerox> @type \x -> read (show x) == id x
13:30:57 <lambdabot> forall a. (Eq a, Read a, Show a) => a -> Bool
13:34:17 * poetix wonders if there's a way to enforce a relationship like read . show = id using the type system
13:35:12 <xerox> I think not.
13:35:26 <poetix> You could have a class like Serializable that required an implementation of both "marshall" and "unmarshall", but even that wouldn't enforce that unmarshall . marshall = id
13:35:32 <int-e> sure: read: () -> a. show : a->()
13:35:43 <int-e> err, the other way around but you get the idea
13:36:03 <xerox> int-e, why () ?
13:36:13 <int-e> xerox: because that's the unit type
13:36:22 <int-e> xerox: so all functions () -> () are identities
13:36:39 <xerox> But then you could not use it with other types, could you?
13:37:00 <poetix> I'm not sure I understand the syntax there
13:37:10 <int-e> xerox: (well, actually () still distinguishes () and undefined ...)
13:37:20 <xerox> poetix: show :: () -> a; read :: a -> ()
13:37:52 <xerox> int-e: ah ok, but it still not so useful.
13:38:02 <int-e> xerox: of course not. it was not meant to be useful.
13:38:26 <xerox> int-e: I think poetix was wondering about invariants on actual types... I could be wrong.
13:38:57 <poetix> It's a similar question to how the monad laws could be enforced
13:39:06 <int-e> xerox: well, what poetix wants is that the compiler verify that a computations is equivalent to another one, and that problem is undecidable in general.
13:39:17 <xerox> Maybe with the Leibniz Equal typing TheHunter showed...
13:39:31 <xerox> int-e: right.
13:39:40 <int-e> xerox: unless you're willing to give up computational power ...
13:39:47 <xerox> Yep, got it.
13:39:49 <poetix> It's possible to prove that a given computation is equivalent to another one, and a compiler could require and check that proof
13:41:07 <int-e> hmm. there goes the rapid prototyping aspect of the language. hehe.
13:43:37 <int-e> poetix: besides, Goedel will come and hunt you with such claims.
13:44:40 <poetix> Well, I guess the compiler could only require and check a certain class of proofs, not proofs in general
13:45:07 <poetix> That's why I said "a given computation" rather than "any computation you like"
13:45:12 <lightstep> it can check all of the proofs
13:45:40 <int-e> lightstep: there might be not proof in the given formal system, although the computations are equivalent.
13:46:07 <lightstep> yes
13:47:34 <int-e> I'm arguing on a purely theoretical level with no claim of any practical implications here, of course. The practical issues that I have are that requiring such a proof will make coding very cumbersome and not requiring it will lead to people not using it out of lazyness.
13:47:59 <int-e> using->doing
13:49:13 <poetix> In any case, the proof offered would likely be constructive, and take the form of a program of some kind, in which case the problem of how to type-check and enforce the variants of that program comes around again...
13:49:30 <poetix> s/variants/invariants/
13:56:30 <xerox> Would invariants make the program "crash" as in "stop execution" at runtime?
14:07:08 <poetix> As in assertions?
14:07:54 <poetix> I think Eiffel does both compile-time and run-time invariant checking - at compile-time, it detects obviously incompatible invariants
14:29:19 <Lemmih> dcoutts, dons: I got a _very_ minimal Yi running in a Gtk TextView buffer.
14:32:48 <xerox> oooh.
14:35:16 <poetix> aaah
14:35:47 <Cale> xerox: I think I'll take a shot at the autoplacing thing
14:36:27 <Cale> xerox: did you ever get it not to segfault?
14:36:41 <xerox> Nope :(
14:36:49 <xerox> I was thinking of working on it tomorrow
14:37:31 <Cale> also, I think the menus should do something sensible, so I'll see about getting them hooked up :)
14:37:40 <xerox> Yep :)
14:37:52 <xerox> View should go away prolly.
14:38:03 <xerox> The "Save as.." intrigued me :)
14:39:43 <Cale> hmm... is there a way in Cairo to get the bounding box of a drawing?
14:39:57 <xerox> I think not.
14:40:01 <xerox> err, well..
14:40:19 <xerox> One of the demos does it using some *Extents function, but it's probably font-specific
14:40:36 <Cale> Otherwise we have to draw the thing virtually first, or maintain some state parameter
14:40:57 <xerox> Yep.  That was we thought before.
14:42:56 <Cale> I really think that's something that cairo should be able to do though
14:43:08 <Cale> (even if it can't)
14:43:18 <xerox> In fact there is a way..
14:43:21 <xerox> though it's not exposed.
14:43:35 <xerox> There is a C way to mess with the internal path of the cairo_context.
14:44:20 <Cale> cairo_stroke_extents() looks promising, but undocumented
14:44:31 <xerox> Right :-D
14:45:00 <xerox> Those functions showed up in the last release when I mechanically synched the API without thinking too much :-D
14:45:03 <xerox> Sorry :)
14:46:11 <Cale> Oh, I wasn't referring to your documentation
14:46:19 <Cale> I was referring to the cairo documentation
14:46:30 <Cale> http://www.cairographics.org/manual/cairo-cairo-t.html
14:46:35 <xerox> Good idea
14:46:43 <xerox> I should check for things to synch.
14:49:32 <xerox> This night I promised to teach Haskell to a friend :)
14:49:54 <Cale> ah, cool :)
14:50:26 <xerox> He now can do basic things like define functions and use map/fold and such, I was thinking of going deeper in types... GADT?
14:51:13 <Cale> typeclasses?
14:51:32 <xerox> Oh we talked about them, Show/Read as an example
14:51:41 <xerox> Maybe work with them would be nice, yeah.
14:51:42 <int-e> monads?
14:51:57 * xerox hears a sound from the background but can't distinguish what it is...
14:52:13 * int-e feels ignored.
14:52:19 * xerox hugs int-e 
14:52:25 <xerox> Will do, later :)
14:52:30 <int-e> ;)
14:52:47 <Cale> I think that the GADT syntax should perhaps become the default way to declare data types.
14:53:24 <Cale> Though it has some strangenesses to it currently.
14:53:31 <xerox> We will gobby the session, if you want to come, or whatever.
14:53:40 <xerox> Cale: what exactly?
14:54:11 <Cale> I seem to recall that type parameters are ignored and only serve to indicate the kind of the type constructor?
14:54:16 <ndm> how do i like FFI code into GHC
14:54:31 <ndm> I have my files, with ffi in them
14:54:33 <ndm> and my C .o files
14:54:41 <ndm> but i'm not sure how to prod them at GHC
14:54:43 <xerox> s/like/link/ ?
14:54:54 <ndm> indeed, *link :)
14:54:56 <xerox> You do it in ffi declaration
14:55:09 <ndm> in the .hs file you mean?
14:55:15 <xerox> ...and then there probably is a path to find them, I don't know if it's the same for the haskell modules.
14:55:23 <xerox> *declarations, even
14:55:25 <xerox> yep.
14:55:37 <ndm> foreign import ccall "artutils.h" getNmMod      :: FileNode -> CString
14:55:50 <ndm> but that doesn't specify a .o module file
14:55:59 <Cale> You can pass the .o files on the commandline to ghc, iirc.
14:56:02 <ndm> and i end up with link errors
14:56:13 <ndm> Cale, any idea how? I tried -l but no luck
14:56:24 <Cale> just include them like you would a source file?
14:56:52 <ndm> Cale, yep, thanks :)
14:56:56 <Cale> -l will work if you have a .so in /usr/lib or something
14:57:05 <ndm> was so busy looking for a flag i didn't think of trtying it just raw
14:57:14 <Cale> not sure how that would translate to windows
14:57:26 <Cale> maybe a .dll file being somewhere :)
14:57:53 <neadjneki> where can i find documentation of stream monad?
14:58:15 <xerox> SICP? ;)
14:58:23 <Cale> hmm... I could type the definition of it :)
14:58:30 <xerox> Please do!
14:58:42 <neadjneki> is that nothing special?
14:59:19 <Cale> it'd be just like the list monad, only return has to give the infinite stream consisting of copies of that one value
14:59:48 <Cale> data Stream a = Str a (Stream a)
15:00:01 <Cale> return x = Str x (return x)
15:00:43 <neadjneki> oh, sorry for my ignorance.. thanks
15:00:52 <Cale> hmm... there's a number of ways to define bind/join though
15:01:17 <Cale> Probably you want join to do something nontrivial.
15:01:53 <Cale> Like wrap through the "diagonals" of the stream of streams.
15:02:26 <Cale> You can just define it to take the first elements, but that's cheesy :)
15:03:12 <Cale> let's see...
15:05:13 <Cale> interleave (Str x xs) (Str y ys) = Str x (Str y (interleave xs ys))
15:05:13 <Cale> instance Monad Stream where
15:05:13 <Cale>   return x = Str x (return x)
15:05:13 <Cale>   (Str x xs) >>= f = interleave (f x) (xs >>= f)
15:05:23 <rubenz> has anyone had any luck compiling docon with ghc 6.4?
15:05:37 <Cale> that ought to work :)
15:06:25 <neadjneki> is logicm part of ghc?
15:07:03 <neadjneki> cale thanks for the input - processing :)
15:09:03 <rubenz> naedjneki: what's logicm?
15:09:40 <neadjneki> just found it: http://okmij.org/ftp/papers/LogicT.pdf
15:10:35 <Cale> hmm... nah, that doesn't quite work :)
15:10:52 <neadjneki> ?
15:11:38 <Cale> I wonder if the first elements idea is really the only reasonable way to do it.
15:12:25 <int-e> hmm, well you can't use the trick of the list monad that the end of the list marks the end of the computation
15:13:01 <int-e> interleaving works but there seem to be some exponential growth problems that are undesirable.
15:13:04 <TheHunter> is the first elements idea the reader monad?
15:14:02 <Cale> int-e: xs >>= return = xs
15:14:18 <int-e> Cale: oh right. stupid me.
15:14:30 <Cale> I made the same mistake :)
15:14:51 <Cale> but taking the nth element for any n should work, I'd think
15:15:48 <TheHunter> yes, that's the reader monad under Str =~= (->) Integer
15:16:29 <Cale> yeah
15:18:11 * shapr boings
15:18:38 <TheHunter> since we know all functions Str (Str a) -> Str a, it shouldn't be to difficult too test them for making a valid join.
15:27:06 <SickJacken> hoooooraaaaaaaaaaaay
15:27:18 <SickJacken> my app doesnt have a black hole annnnnd is not requesting 4.5 gigs of memory
15:27:22 <SickJacken> this calls for a celebration
15:42:07 <lament> latest theory is that there's a supermassive black hole in the center of every application.
15:42:57 <xerox> What was the right context to introduce fmap on Binary Trees?
15:43:12 <xerox> Giving a definition of what a Functor is, for example?
15:43:31 <xerox> ..or just saying "map is just a special case, we could make our function work more generally"
15:43:35 <xerox> yeah, I'll do it that way.
16:04:14 <TheHunter> are there any speakers here who make a distinction between wine and whine?
16:04:39 <basti_> that would be aspiration, then?
16:05:25 <Cale> xerox: well, the formal picture is kind of nice :)
16:05:34 <TheHunter> from what i've gathered, it's an entirely different consonant
16:05:36 <xerox> Cale yes I found that
16:05:56 <Cale> but yeah, it really amounts to about the same story :)
16:05:57 <xerox> Cale, if you mean the fact that it does have to obey some rules
16:06:10 <Heffalump> TheHunter: I don't.
16:06:48 <TheHunter> the IPA-symbol is  ç.
16:06:49 <basti_> http://www.answers.com/main/ntquery?method=4&dsid=2222&dekey=H-cluster+reductions&gwp=8&curtab=2222_1
16:07:47 <Korollary> TheHunter: In some parts of the US, they pronounce "what" something like "hwat". Is that like it ?
16:08:12 <TheHunter> yes, that's it. I was wondering how they pronounce "wacky"
16:09:11 <Frederik1aton> i could imagine pronouncing "wacky" as "whacky"
16:09:23 <Cale> xerox: yeah, and that triangles get mapped to triangles
16:09:36 <Cale> (well, that's essentially one of the rules)
16:09:44 <Korollary> TheHunter: That's a southern/east coast thing. You tell me when you find out :)
16:09:46 <xerox> Cale: err? :D
16:10:37 <Cale> Like, if you have some commuting triangle g . f = h, then map g . map f = map h
16:10:58 <xerox> A definition of "Functor" itself?
16:10:59 <TheHunter> i would guess that "wacky" is derived from "whack" and was quite puzzled when the dictionary i checked didn't know "whacky".
16:11:10 <Cale> (think of the functions as arrows)
16:11:27 <xerox> Ah, triangle in that sense!
16:11:57 <Frederik1aton> my program seems to be stuck in an infinite loop, is there a way to find out the location of the looping?
16:12:32 <TheHunter> and now, rather than accepting the "wacky" spelling, my natural reaction is arguing against it.
16:12:50 <Cale> Frederik1aton: hmm... Debug.Trace may be handy, if you have some general idea as to where it is
16:12:53 <Frederik1aton> (hmm, i wonder what happened to my name...)
16:13:04 <Korollary> TheHunter: merriam webster says "wacky: Etymology: perhaps from English dialect whacky fool"
16:13:23 <Frederik1aton> Cale: i've tried that. it freezes in the middle of a trace statement
16:13:31 <Frederik1aton> Cale: so i think it's a bug in ghc but not sure
16:13:39 <Cale> Frederik1aton: what does the trace statement print?
16:13:54 <Cale> If the evaluation of what it's printing is the loop, then it will seem to freeze
16:14:02 <Frederik1aton> Cale: it prints stuff which has already been evaluated
16:14:22 <Cale> you're certain?
16:14:23 <Frederik1aton> Cale: also, it is more likely to freeze if i suspend with ^S and resume with ^Q
16:14:31 <Cale> hmm
16:14:44 <TheHunter> oh, m-w also knows "whacky".
16:15:07 <TheHunter> so I'll just use that variant :)
16:15:08 <Cale> "whacky" is actually how I'd spell it
16:16:27 <Frederik1aton> Cale: although I'm piping it through 'tee', but i don't see why that should be a problem
16:16:56 <Cale> Frederik1aton: is it possible to reconstruct the situation in ghci?
16:18:18 <palomer> what is haskell especially good for?
16:18:35 <xerox> Programming?
16:19:01 * basti_ nodnods
16:19:05 <Cale> :)
16:19:13 <Cale> Programming is a good answer
16:19:23 * xerox bounces happily
16:19:23 <palomer> what type of programs are best programs with haskell
16:19:55 <xerox> The ones which works
16:19:56 <basti_> the ones that require turing complete systems to run on
16:20:03 <Korollary> you all know what he means
16:20:06 <Cale> It's hard to say, really. I think algorithms where the control flow would otherwise be hard to set up or determine come out especially nice with laziness.
16:20:29 <Korollary> I think autrijus would say that Haskell is the best language to write something like Pugs
16:20:45 <Cale> Haskell makes things like backtracking incredibly trivial.
16:20:59 <basti_> haskell is good for short things
16:21:05 <basti_> and long things are built from short things
16:21:06 <xerox> Or modelling some kind of behaviours
16:21:11 <xerox> Like nondeterminism and much more
16:21:16 <Cale> yeah
16:21:22 <basti_> and then we like types
16:21:30 <basti_> almost masochistically
16:21:36 <palomer> what's pugs?
16:21:46 <xerox> Perl Users Golf System
16:21:54 <xerox> A Perl6 implementation written in Haskell
16:21:56 <Korollary> @google Pugs
16:21:58 <lambdabot> http://www.pugs.com/
16:21:59 <Cale> Haskell is a good language when your program being correct is more important than your program being incredibly fast.
16:22:22 <xerox> oh, and he's known for his fast prototyping skills.
16:22:29 <Cale> But it is getting rather practical.
16:23:01 <basti_> our language has more error messages than most programs have lines
16:23:06 <Cale> hehe :)
16:23:20 <basti_> @ghc
16:23:22 <lambdabot>  Can't reify a non-Haskell-98 data constructor
16:23:27 <basti_> like that one
16:23:31 <Frederik1aton> Cale: testing... ghci seems to work better
16:23:37 <Cale> but it's surprisingly rare that I actually have to deal with an error message
16:23:39 <xerox> Examples of practical Haskell showed up in these last weeks are 2d vector graphics and LSystems, raytracing, please help me :)
16:23:42 <Cale> Frederik1aton: hmm :)
16:23:47 <palomer> see, I want to learn haskell and the way I learn languages is by writing something fairly complex in them
16:23:56 <basti_> hmm
16:24:01 <basti_> you could start with monads, then
16:24:05 <Korollary> palomer: check out the new text editor, Yi, that is written in haskell
16:24:22 <Cale> palomer: yeah, Yi needs more programmers :)
16:24:28 <basti_> yi is bizarre.
16:24:32 <Cale> hehe, I should work on yi as well
16:24:35 <basti_> i wrote a emacs keymap for it
16:24:56 <basti_> still needs some work though
16:24:58 <Korollary> basti_: which one ? em2 or mgs or whatever it was
16:25:04 <Cale> If yi had syntax colouring, I'd probably use it as my main editor.
16:25:14 <basti_> Korollary?
16:25:17 <palomer> yi looks awesome
16:25:31 <Korollary> basti_: which switch in yi gives your binding, I mean.
16:25:52 <basti_> oh i dont know. I defaulted that in my .yi-rc
16:26:13 <palomer> ok, yi is probably my next big project:O
16:26:17 <palomer> looks like fun
16:26:37 <basti_> you should know what a monad is before you say things about fun in haskell
16:26:38 <palomer> The PugsCom site is dedicated to providing honest, factual information about Pugs.
16:26:39 <Frederik1aton> Cale: they are even giving different results, ghc is giving the wrong result...
16:26:52 <Frederik1aton> Cale: and not printing trace statements that I know should be printed
16:27:05 <basti_> Korollary: try --as emacs
16:27:14 <Cale> palomer: my first really large haskell program was a pipeline scheduler for PPC+Altivec. It ran at a practical rate, produced fairly near-to-optimal schedules, and was about 1000 lines of literate haskell code, which was about 1/2 documentation.
16:27:45 <Cale> Frederik1aton: hm..
16:27:59 <Cale> Frederik1aton: what switches are you using?
16:28:57 <Cale> palomer: though I'd written lots of smaller programs before that :)
16:29:08 <Frederik1aton> now just -O3 but i was using "-prof -auto-all"
16:29:18 <basti_> Korollary: if ^T gives you a strange interface that you don't understand, then you got the latest version.
16:29:24 <Cale> don't use -O3, try just -O
16:29:28 <basti_> it's a test for the completion interface
16:30:48 <Cale> basti_: code completion?
16:31:12 <basti_> no arbitary "tab" completion
16:31:16 <basti_> as in, filenames
16:31:19 <basti_> or command names
16:31:23 <Cale> oh :)
16:32:45 <basti_> palomer: the completion framework i wrote for yi is 77 lines long, including comments
16:34:22 <basti_> and including a debugging help
16:35:08 <basti_> listToTree = foldr (\a b->CT [(a,b)]) (CT [])
16:35:15 <basti_> i can't believe i actually wrote this
16:35:16 <basti_> lol
16:39:06 <basti_> Cale: a completion is a continuation that holds the code you didn't write yet?
16:39:25 * xerox looks strangely around
16:39:34 <Cale> basti_: hm?
16:39:44 <basti_> < Cale> basti_: code completion?
16:39:51 <Cale> basti_: I was thinking of tab-completion on language keywords and identifiers
16:39:55 <basti_> oh. no.
16:39:59 <basti_> though the code is general
16:40:04 <basti_> so if you want to use it, feel free
16:40:24 <basti_> it doesnt contain "suggest" yet, though, it just does the obvious, but you could easily add a "suggest" thing
16:41:38 <Cale> the cool thing will be when somewhat figures out how to compile broken Haskell source enough to figure out the possible types at the current cursor location so as to restrict the tab completion to those things which would work there :)
16:42:09 <Cale> someone*
16:42:22 <basti_> that would be cool yes.
16:42:50 <basti_> ive heard opinions that this is basically impossible with everything besides the most simple of languages
16:42:59 <basti_> but then again, haskell syntax -is- pretty simple
16:43:02 <sylvan> Anyone familiar with parsing? ReadP vs. Parsec, what are the main differences?
16:43:12 <xerox> Parsec is cute
16:43:45 <sylvan> ReadP isn't?
16:43:52 <xerox> Dunno!
16:44:08 <basti_> why is everyone so hot for parsers?
16:44:18 * xerox parses basti_
16:45:28 <basti_> http://www.haskell.org/hawiki/HaskellDbandHsp
16:45:30 <basti_> here look at that
16:48:07 <basti_> I
16:48:10 <basti_> mdfmsklf
16:48:14 <basti_> I'll go to bed
16:48:51 <xerox> Goodnight basti_!
16:49:13 <basti_> cu all
16:51:17 <Korollary> @index unsafeAt
16:51:19 <lambdabot> bzzt
16:51:28 <Korollary> @hoogle unsafeAt
16:57:34 <wagle> @google unsafeAtAnySpeed
16:57:35 <lambdabot> http://www.unsafeatanyspeed.com/
16:57:46 <xerox> What could be another home-made type which is a Functor?
16:58:34 <arjanb> all simple 'container' types are
16:58:39 <bluefox> hello! this looks like a fun language.
16:58:40 <xerox> Like?
16:58:49 <xerox> bluefox: indeed!  Howdy.
16:59:24 <bluefox> im taking a break from java :p. i like python quite a bit.
16:59:37 <bluefox> so what do you guys recommend to get started on linux? should i get a compiler or an interpreter, and if so which one(s)
16:59:48 <Korollary> get ghc, which is both
16:59:59 <Korollary> http://haskell.org/ghc
17:00:08 <xerox> @wiki HaskellDemo
17:00:09 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
17:00:12 <xerox> To see it :D
17:00:23 <cjb> Python programmers should be used to interpreters that are compilers :)
17:00:27 <bluefox> thank you
17:01:27 <bluefox> yeah yeah
17:37:59 <ptolomy> man, that even/odd definition the end of the HaskellDemo page is such a cool examlpe.
17:38:16 <neadjneki> :)
17:39:11 <Frederik1aton> hmm, using DiffArray instead of Array causes 20x slowdown
17:45:37 <dons> Lemmih, cool!
17:47:07 <Lemmih> dons: I'm having trouple with the control keys.
17:56:31 <dons> hmm. how so?
17:56:38 <dons> btw, is the code somewhere I can pull?
17:57:09 <dons> oh, possily you don't get the meta bit set by gtk?
17:57:10 <Lemmih> Control keys are harded coded to Curses.
17:57:41 <dons> oh, you mean the names of meta keys? not keys like '\^C' though
17:57:47 <dons> names like 'backSpace'
17:58:17 <dons> but yes, they are. they use names defined in Curses.hsc - but we should be able to map those names across.
17:58:39 <dons> or are you saying things like '\^C' don't work?
17:59:58 <Lemmih> GTK gives a name like "Left" or "Shift" but Yi wants a Char.
18:01:16 <dons> ah, yes. Yi _really_ wants a Char
18:01:35 <dons> can't we map these things to Chars?
18:01:48 <Lemmih> It wouldn't be pretty.
18:01:53 <juhp> not modifiers
18:02:43 <dons> what type is a 'Left'
18:02:45 <dons> ?
18:02:53 <Lemmih> String.
18:03:31 <dons> oh. but that's a [Char], made up of what? ESC x y or such?
18:04:40 <dons> could you write a function: setMeta (_:y) = chr (setBit (ord c) metaBit) where metaBit = 7 ?
18:04:46 <Lemmih> I don't follow. GTK will give you a Char if it's valid unicode and a String if it's not.
18:05:06 <dons> I'm wondering what the individual Char's in these Strings are?
18:05:20 <Lemmih> 'L':'e':'f':'t':[]
18:05:34 <dons> me boggles
18:05:54 <Lemmih> It really gives you "Left", "Backspace" or whatever.
18:05:55 <dons> so GTK gives you an Either Char String?
18:06:14 <Lemmih> Nah, (Maybe Char, String)
18:06:46 <dons> hmm. we could still map "Left" -> keyLeft :: Char
18:07:29 <Lemmih> It wouldn't be pretty (:
18:07:29 <dons> but these aren't control chars. what about real control chars? like \^G or what not?
18:08:14 <Lemmih> Chars with modifiers set.
18:08:29 <dons> ok. that's fine then.
18:08:34 <Lemmih> Yep.
18:09:26 <dons> well, I suggest mapping "Left" -> keyLeft :: Char (some high value, probably just take the ncurses value for keyLeft). I can't think of another way atm.
18:09:31 <dons> this "Left" thing seems bogus
18:09:58 <dons> Lemmih, is the code up somewhereE?
18:14:06 <Lemmih> Pushed.
18:18:24 <Lemmih> Hm, I think I broke something.
18:19:09 <dons> probably you should use 'mg' mode as the emacs mode. it's more complette
18:19:22 <Lemmih> What's 'mg'?
18:20:00 <dons> mg - emacs-like text editor. no lisp
18:20:09 <dons> very fast
18:22:27 <Lemmih> Editor mode shouldn't really matter.
18:22:57 <dons> oh, I just noticed you'd set emacs2 as the default
18:25:25 <juhp> dons: does mg have a homepage btw?
18:27:35 <dons> well, the public domain release i have has a README dated: Mg 2a README  May 15, 1988
18:28:03 <dons> it has survived because the OpenBSD kernel hackers use it  and work on it
18:28:44 <dons> it has been ported back to linux though
18:29:16 <juhp> dons: ah ok :)
18:29:34 <juhp> was wondering why I'd never heard of it before :)
18:30:24 <dons> src for all: http://www.openbsd.org/cgi-bin/cvsweb/src/usr.bin/mg/
18:31:26 <dons> it's actually part of the openbsd base system
18:31:58 <juhp> nice that they prefer it to vi :)
18:39:20 <rep> nvi forever!
18:41:31 <stepcut> yi forever!
18:41:39 <stepcut> as in, how long it will take to finish
18:41:41 <stepcut> :p
18:44:28 <dons> sigh
18:44:40 <dons> yi+gtk now!
18:44:50 <Lemmih_> Did I miss something?
18:45:42 <dons> not sure Lemmih. nothing serious though
18:52:32 <Cale> dcoutts: heh, make distclean apparently doesn't remove Cairo.chs
19:04:48 <dons> yay. hIDE+Yi on OpenBSD :)
19:04:58 <dons> @karma+ Lemmih
19:04:59 <lambdabot> Lemmih's karma raised to 3.
19:15:34 <heatsink> What is the type variable `s' in [| STRef s a |] for?
19:22:11 <dons> -- It serves to keep the internal states of different invocations
19:22:12 <dons> -- of 'runST' separate from each other
19:22:25 <dons> -- The @s@ parameter is either
19:22:25 <dons> -- * an unstantiated type variable (inside invocations of 'runST'), or
19:22:25 <dons> -- * 'RealWorld' (inside invocations of 'Control.Monad.ST.stToIO').
19:25:30 <orbitz> good afternoon
19:25:55 <heatsink> unstantiated == uninstantiated?
19:26:53 <dons> hmm. yes.
19:27:33 * dons fires up cvs
19:28:14 <Lemmih> Goodnight, guys.
19:28:25 <heatsink> night lemmih, hi orbitz
19:28:29 <dons> night Lemmih
19:29:55 <heatsink> In runST, is the value of type s ever used?
19:30:30 <dons> don't think so
19:30:41 <heatsink> Okay, that helps
19:30:56 <dons> well, sort of. it's threaded through the computation
19:30:59 <dons> that's all.
19:31:07 <dons> never inspected
19:31:17 * heatsink tries to understand the description in the spj paper of how the typechecker prevents references from escaping the runST computation
19:32:06 <dons> heatsink, how would you like to be referred to in my commit msg?
19:32:21 * heatsink doesn't understand
19:32:44 <heatsink> Knowing that the value of type s is never inspected helps me understand what's going on, though.
19:32:48 <dons> you spotted the typo. i'm committing it now, but like to give credit to those who find these things.
19:33:04 <heatsink> oh. Sure :)
19:33:33 <dons> heatsink on #haskell, or do you have a name I should use?
19:33:45 <heatsink> this name is good enough.
19:33:53 <dons> ok
19:34:04 <dons> done
19:34:14 <heatsink> thx for crediting me
19:38:41 <heatsink> Ok, I think I see
19:39:18 <heatsink> The universally-quantified typevar inside runST cannot be universally-quantified if it unifies with anything outside runST
19:39:37 <heatsink> ...man, it's impossible to explain these things in plain language.
19:41:52 <dons> type theory, yay!
19:41:58 <heatsink> :D
19:46:38 <heatsink> The `forall s' means that `s' cannot escape the type.  That's clever.
19:58:04 <andrei_> Hi, I'm very new to haskell, and I have an issue that I can't readily solve.. I'm trying to make a simple GUI with gtk2hs. But I want to update something every 5 seconds. I could use a callback, but I don't know how to make that function see a list from which to update the data, because it can't get any arguments.
19:58:08 <andrei_> Any ideas on what I can do?
20:00:17 <andrei_> Maybe I should mention.. without looping indefinitely updating the screen, because I managed to do it that way
20:00:23 <andrei_> And the CPU usage wasn't fun
20:01:05 <heatsink> andrei_: Can I see the GTK docs?  Specifically I'd like to see how callbacks are typed.
20:01:13 <heatsink> the gtk2hs docs rather
20:01:23 * heatsink found them
20:02:15 <andrei_> A function that returns IO Bool
20:05:35 <heatsink> So you need to look at the state that may have changed in the last 5 seconds, and then draw accordingly...
20:05:52 <andrei_> Is making another thread to update that value the only way? And.. is there a wait for N ms or ps function?
20:05:52 <heatsink> Can you modify a widget's callback after you create it?
20:06:32 <andrei_> Oh! Yes.. I can just partially apply the function!
20:06:50 <heatsink> right.
20:06:52 <andrei_> Thank you
20:07:22 <dons> dcoutts, a downloadable .tgz of the gtk2hs docs would be nice
20:08:13 * dons trys make html
20:12:48 <stepcut> often times, when I do 'darcs pull -a' to update yi, it hangs and never updates, but if I check it out fresh, everything works fine... :-(
20:13:45 <dons> hmm.
20:13:50 <dons> darcs version?
20:14:22 <stepcut> 1.0.3 right now, but I had the same problem with 0.9.7 (or something like that)
20:15:04 <andrei_> Does haskell have a sleep/delay function? that works on the order of ms or ps?
20:15:37 <stepcut> andrei_: i think it is in the System.Posix someplace
20:16:11 <stepcut> file:///usr/share/doc/ghc6-doc/html/libraries/unix/System.Posix.Unistd.html#v%3Ausleep
20:16:23 <dons> @type Control.Concurrent.threadDelay
20:16:28 <lambdabot> Int -> IO ()
20:16:30 <stepcut> file:///usr/share/doc/ghc6-doc/html/libraries/base/Control.Concurrent.html#v%3AthreadDelay
20:16:30 <andrei_> Thank you
20:16:46 <andrei_> What's the difference between the two?
20:16:52 <andrei_> I've never used threading in haskell
20:17:32 <stepcut> GHC Note: threadDelay is a better choice. Without the -threaded option, usleep will block all other user threads. Even with the -threaded option, usleep requires a full OS thread to itself. threadDelay has neither of these shortcomings.
20:17:36 <andrei_> Thank you :D
20:18:24 <stepcut> threadDelay is GHC specific, so usleep is better if you want to use hugs too
20:34:05 <heatsink> How come [| openFile "/dev/null" WriteMode |] throws an exception?
20:35:58 <orbitz> hrm, you look familiar heatsink
20:36:06 * heatsink has been here before
20:36:22 <heatsink> I've talked with you before too.
20:40:06 <humasect> isn't [| |] ocaml
20:46:16 <heatsink> humasect: It's notation from template haskell
20:46:31 <humasect> hmm dastardly
21:11:36 <humasect> long live the hasking
21:22:40 <Korollary> hmm, the language shootout site is borked.
21:29:01 <humasect> hm, ffi cannot have exports returning tuples ?
21:33:21 <musasabi> humasect: that wouldn't make sense.
21:33:30 <musasabi> humasect: what would the C side type be?
21:33:38 <humasect> or something similar, without having to have a wrapper
21:33:44 <humasect> return (float *)something;
21:34:02 <humasect> the C type could be float[2] for CFloat -> CFloat
21:34:19 <humasect> (CFloat,CFloat) oops.
21:35:03 <musasabi> But you cannot really return an array in C.
21:35:11 <humasect> right
21:35:37 <humasect> it could know it is a float[2] and map it iso. i would think
21:36:12 <musasabi> In C you would probably have: void myfun(float *result);
21:36:40 <musasabi> and that translates to "Ptr CFloat -> IO ()"
21:37:08 <humasect> hm yeah. would Ptr translate to tupes/lists ?
21:37:14 <humasect> would/could
21:38:38 <musasabi> Doing it automatically would be problematic as many times the length of the array needs to be maintained in a separate way.
21:38:53 <musasabi> So returning a list of floats could become either:
21:39:47 <musasabi> some_other_type myfun(float *arr, unsigned *arr_len); or unsigned myfun(float *arr);
21:40:30 <humasect> hmm
21:41:09 <humasect> it's not a gigantic array requiring a mass element get, so maybe a haskell side wrapper into a tuple is best now
21:42:25 <Korollary> can you use a void myFun(struct APair *) {...} ?
21:43:06 <musasabi> yes, but struct element access needs either hsc2hs or c2hs.
21:45:51 <humasect> haskell ffi does not have struct alignment/etc built in?
21:48:37 <heatsink> I think part of the problem is that struct alignment is not fully specified by C
21:48:45 <musasabi> humasect: struct pointers are not a problem.
21:49:26 <musasabi> humasect: but struct as values (done differently by different C compilers) and struct element access (needs parsing the C headers) are not done.
21:50:53 <musasabi> I think the FFI is one of the best compromises I have seen in different languages for FFI.
21:51:30 <musasabi> (feel free to point to better ones)
21:54:55 <dons> yay. i'm currently running dynamic yi with a gtk gui, with syntax highlighting provided by gtksourceview
21:54:56 <orbitz> hi musasabi
21:55:13 <dons> time for a screenshot!
21:55:35 <orbitz> dons: ohh let's see!
21:59:35 <dons> http://www.cse.unsw.edu.au/~dons/yi+gtk.png
21:59:40 <humasect> ok, i have to agree. ahh *looks*
22:00:08 <dons> in 3 hrs gtk hacking, i've already made more progress than in the last 3 months sobbing and pleading with ncurses
22:00:11 <dons> long live gtk!
22:00:28 <humasect> aka. nocurses
22:00:32 <heatsink> ooh!
22:03:24 <Korollary> sweet. You want to use monospace fonts, though
22:03:37 <musasabi> hello orbitz
22:03:51 <dons> yep. this is just quick-n-dirty of course
22:04:09 <Korollary> you will make me install gtk if you keep going like this
22:04:44 <musasabi> dons: pretty, it looks like it will slowly become the time to throw my elisp away :-)
22:05:13 <stepcut> dons: haha
22:05:45 <stepcut> yi requires alex now ?
22:05:57 <stepcut> for synhi ?
22:06:03 <dons> it sort of does. not really.
22:06:07 <musasabi> Actually monospace-fonts are not as important if you just can align things sensibly (but that might be hard)
22:06:34 <dons> stepcut, the gtk yi isn't in the yi main repo yet
22:06:55 <stepcut> dons: that's ok, I just want to see where things are at in general
22:07:00 <dons> this was just a sneak preview ;)
22:07:01 <stepcut> ... like emacs bindings
22:07:15 <dons> check out --as=mg
22:07:26 <stepcut> heh
22:07:35 <musasabi> dons: Does Yi support multiple buffers at the same time and how hard would it be to add a ghci-mode?
22:07:56 <dons> it does support multiple buffers and split windows
22:07:59 <dons> ghci-mode?
22:08:28 <Korollary> that means running a shell window and interacting with it
22:08:57 <dons> this is probably a job for hIDE
22:09:30 <musasabi> dons: to evaluate expressions in ghci and print them (with history for previous expressions).
22:09:37 <musasabi> hmm point.
22:09:39 <dons> I'm still looking to keep yi as a basic editor, with syn hl support and the like, but fancier IDE stuff will go into hIDE (which will use the yi lib)
22:09:50 <stepcut> neat
22:10:34 <stepcut> as soon as it can do synhi, email, and irc, I can ditch emacs :p
22:11:25 <stepcut> haskell-mode for emacs drives me up the wall with bugs, but it is a nightmare to fix
22:12:47 <stepcut> If you have a string like "select * from blah where a = b", haskell-mode will see the where, but not realize it is inside a string, and therefore not syntactively active
22:23:28 * heatsink gets that problem with "of"
23:03:03 <dons> I'm still looking to keep yi as a basic editor, with syn hl support and the like, but fancier IDE stuff will go into hIDE (which will use the yi lib)
23:03:08 <dons> oops
