00:08:39 <Itkovian> meuning
00:14:55 <genneth> moaning
00:25:51 <Cale> mourning
00:26:31 <boegel> hello Cale
00:26:35 <Cale> hi
00:26:49 <boegel> Cale: nice post on haskell-cafe, you really made some stuff clear for me
00:26:54 <Cale> thanks
00:27:14 * boegel just noticed his post didn't arrive on the list and wonders what went wrong
00:27:18 <boegel> stupid ISP :@
00:29:54 <genneth> i think i've just realised why there are no design patterns in haskell... if we can describe how to do something, we can formalize it into a HoF
00:30:09 <Cale> basically
00:30:21 <genneth> makes for interesting industrially effects, however
00:30:47 <dons> design patterns are products of less expressive languages
00:30:47 <genneth> where you only need really good people that can create and formalize
00:30:58 <boegel> how can I easily support logs for a IRC-channel, without having to suport it myself ? can i add it to meme?
00:31:04 <Cale> Well, there seem to be no design patterns that are not explicit.
00:31:33 <Cale> dcoutts: are you around?
00:31:41 <genneth> there appear to be plenty of design patterns that are vague as hell
00:32:23 <Cale> genneth: well, in Haskell, it just seems that if there's a design pattern, we'll turn it into a function, or a class or something.
00:32:45 <genneth> Cale, yes; that's what I was thinking
00:32:51 <gour> dons: yi+gtk does not compile here
00:32:57 <Cale> Anyone else know much about installing gtk2hs?
00:33:16 <gour> Cale: what's the problem?
00:33:19 <genneth> but then, you would only need people that can abstractly consider a problem, and formalise it
00:33:35 <dons> gour, don't worry , development is moving faster
00:33:56 <gour> dons: ok
00:34:13 <dons> i'm already merging the code into hIDE itself
00:34:33 <gour> there is no more yi+gtk repo?
00:34:38 <Cale> gour: well, in the darcs version, autoreconf fails with a nonzero exit code. (configure is created, but it complains that it can't find Makefile.in)
00:35:06 <dons> gour, right.
00:35:31 <gour> Cale: 1st i recommend to not execute autoreconf, but invoke aclocal, automake & autoconf manually
00:35:32 <Cale> in the tech preview version, I get errors from ./tools/c2hs/c2hsLocal +RTS -H50m -M80m -RTS -iglib:gtk:cairo --precomp=gtk/gtk.precomp -o gtk/Graphics/UI/Gtk/Cairo.hs gtk/Graphics/UI/Gtk/Cairo.chs
00:35:42 <Cale> gour: okay
00:36:44 <Cale> ah, perhaps it's my automake version
00:38:45 <gour> yes, afaik, 2.59 is required
00:39:11 <gour> shapr: are you somewhere around?
00:39:36 * boegel pokes shapr too
00:39:42 <boegel> @seen shapr
00:39:43 <lambdabot> shapr is in #boden, #haskell.se, #haskell-blah, #webwitches and #
00:39:43 <lambdabot> haskell. Last spoke 8 hours, 2 minutes and 9 seconds ago.
00:40:21 <gour> Cale: maybe not 2.5.9, but Lemmih had similar problems
00:41:31 <ape> morning... gour, you around?
00:41:39 <gour> yes
00:41:47 <gour> where you were yesterday?
00:42:21 <ape> sorry man, i passed out... was so tired
00:42:27 <gour> np
00:44:37 <ape> may i pm you?
00:44:48 <gour> yes
00:45:38 <gour> Cale: any progress?
00:46:22 <Cale> well, it's in the middle of the compile now -- I'll see if it makes it past where the tech preview gets
00:46:38 <gour> good
00:47:41 <gour> autrijus: are you close to croatia?
00:50:07 <gour> autrijus: ahh, mixed hinet.net with hinet.hr :-(
00:52:34 <Khisanth> gour: well he does travel around so that is still a possibility :)
00:53:19 <gour> Khisanth: well, i took that his internet connection hinet.net is htnet.hr :-(
00:53:31 <gour> Khisanth: but it's not
00:53:49 <gour> Khisanth: but he does very good marketing for Haskell ;)
00:54:48 <Cale> heh, it's a brilliant trick :)
00:55:03 <gour> Cale: what?
00:56:22 <gour> ape: have you tried query me?
01:00:10 <Cale> gour: Autrijus' trick for bringing perl people to Haskell :)
01:00:21 <boegel> hey ProfTeggy, thanks for your South Parh-char contribution
01:01:18 <gour> Cale: ah, yes it is
01:01:37 * boegel leaves for a while
01:08:30 <Dread[]> Morning all
01:09:46 <musasabi> What is the point of package base?
01:10:01 <musasabi> I think it is going to be different and incompatible for all compilers.
01:14:23 <ProfTeggy> Moin
01:14:33 <ProfTeggy> boegel, my pleasure
01:16:40 <humasect> "Indeed, you can ask a bot on #haskell to turn programs to its most abstracted form for you."
01:17:49 <dons> musasabi, it's mostly shared between all 3 common compilers/interpreters
01:18:10 <dons> at least Data.* System.* Foreign.* is
01:18:41 <Dread[]> If I have a data type "Car" data Car = C String String (ie: C owner color) is it possible for haskell to use cars without owners or colors?
01:19:15 <humasect> Maybe.
01:19:19 <dons> hehe
01:19:39 <Dread[]> so data Car = maybe C String String ?
01:19:47 <dons> data Car = Car (Maybe Owner) (Maybe Color)
01:19:50 <dblhelix> humasect: I think by 'most abstracted form'  'pointfree' was meant
01:20:02 <dons> type Owner = String ; type Color = String
01:20:28 <dons> so, actually the form containing the *least* abstractions ;)
01:20:34 <earthy> Maybe Car  ? :)
01:20:43 <humasect> o
01:20:50 <Dread[]> maybe beer tonight. Definately.
01:21:09 <earthy> not beer. whisky.
01:21:13 <humasect> *ok thanks.  also Maybe (Owner, Color, ...) if you are using Car without anything at all or everything
01:21:16 <dblhelix> earthy: no, that one has one car less, i.e., the colorless ownerless car
01:21:32 <earthy> one car more, I'd say
01:22:17 <dblhelix> lemmethink
01:22:26 <musasabi> dons: yes, but can it be versioned in a sensible matter?
01:22:33 <Dread[]> Hmm, still cant get it to work
01:22:40 <musasabi> dons: and even those modules are different between compilers.
01:22:49 <musasabi> dons: e.g. Foreign.Concurrent.
01:22:49 <ski> Dread[] : what are you trying to do ?
01:22:57 <fibonaci> @pl \n f x -> f (n f) x
01:22:58 <lambdabot> ap id
01:23:03 <dblhelix> (O + 1) * (C + 1) > (O * C) + 1
01:23:08 <fibonaci> ap?
01:23:36 <Dread[]> i have a function that takes Car -> int -> int -> Car -> boolean
01:23:37 <ski> fibonaci : Control.Monad.ap :: Monad m => m (a -> b) -> (m a -> m b)
01:24:14 <Dread[]> sometimes I want to take (Car "Mike" "Red") but sometimes I just want (NoCar)
01:24:17 <fibonaci> interesting, kind of like a funny lift
01:24:31 <fibonaci> @pl \m n f x -> m f (n f x)
01:24:31 <lambdabot> liftM2 (.)
01:24:38 <Dread[]> NoCar is a type of Car but when I try to use "NoCar" it sais that it expects a owner and a color
01:25:00 <ski> Dread[] : maybe  'data Car = Car Color Owner | NoCar'   with 'type Color = String'  and 'type Owner = String' ?
01:25:09 <dblhelix> Dread[]: but do you also want Car (no owner) (no color) or Car "Mike" (no color) or Car (no owner) "red"?
01:25:24 <Dread[]> Either both or none
01:25:39 <ski> fibonaci : ap and return can be used to derive all the other monadic liftMX, iirc
01:25:45 <Dread[]> so either I have cars with owners and colors or ownerless colorless cars
01:25:53 <fibonaci> cool
01:26:05 <dblhelix> what about newtype Car = Car (Maybe (Maybe Owner, Maybe Color))?
01:26:05 <earthy> but Car Color Owner | NoCar  is fully isomorphic with  Maybe Car
01:26:08 <humasect> it might not need to be a Car it Nothing is okay.
01:26:30 <earthy> if Car = C Color Owner
01:27:09 <dblhelix> it seems to me he wants (O + 1) * (C + 1) + 1
01:28:38 <humasect> hm... GHC.Conc or Control.Concurrency
01:29:19 <Dread[]> Its so frustrating when english isn't your first language and you try to explain so people understand but you lack the words to make it understandable...
01:29:25 <Muad_Dibber> dblhelix : either cars with ownsers and colors, or without those
01:29:33 <fibonaci> data RealCar = Car (Maybe Car) (Maybe Car)
01:29:46 <fibonaci> type Car = Maybe RealCar
01:29:58 <humasect> data Car Color Owner | NoCar  <- is probably what you want
01:29:58 <Muad_Dibber> so i think id'd agree with earthy on the datatype
01:30:14 <fibonaci> er, yeah, Maybe Owner and whatnot
01:30:23 <earthy> oh, but dread, some people here understand swedigh
01:30:23 <Dread[]> I get a type error that says: Expression : Car _ Red  Term : Red Type: Color Does not match : Maybe Color
01:30:26 <earthy> swedish, even
01:30:39 <earthy> and there's #haskell.se
01:30:39 <humasect> Just Red
01:32:08 * shapr yawns
01:32:11 <shapr> Good morning #haskell!
01:32:17 <gour> hi shapr!
01:32:26 <shapr> bok gour
01:32:27 <Muad_Dibber> Good morning mister shapr. How are you today?
01:32:38 <shapr> Muad_Dibber: I am AWAKE!
01:32:39 <shapr> w00!
01:32:46 <Muad_Dibber> oooooh
01:32:52 * Muad_Dibber runs to #haskell-blah and hides there.
01:33:02 <gour> shapr: do you want reminder from yesterday?
01:33:18 <shapr> um, oh right.
01:33:26 <shapr> Yes, thanks :-)
01:33:38 <gour> it's called: Trac on haskell.org
01:33:44 <shapr> yeah!
01:34:01 <gour> python is too old..
01:34:17 <gour> i have a new one installed under my home
01:34:36 <gour> which serves tailor for gtk2hs mirror
01:35:26 <gour> but i'm not sure apache will be happy with that one
01:36:03 <gour> shapr: are u op here?
01:36:04 <Dread[]> beeing awake is always a start
01:38:04 <shapr> gour: Where?
01:38:15 <gour> shapr: #haskell
01:38:19 <shapr> Yup
01:38:26 --- mode: ChanServ set +o gour
01:39:06 <gour> shapr: i'm thinking to setup hIDE as a topiv
01:39:11 * shapr has the power (if rarely the time)
01:39:44 * gour does not like the power
01:40:29 <Muad_Dibber> Power corrupts.
01:40:32 * gour not knowing what do to with it
01:40:40 <gour> :-)
01:40:52 <Muad_Dibber> kick somepeople from the channel you don't like. :P
01:40:55 <Muad_Dibber> (not including me)
01:41:03 <shapr> You could put hIDE into the channel topic.
01:42:00 <humasect> see, now i've got a thread forked off from ghci, now i need to talk with it.
01:42:18 <ulfdoz> try english. :)
01:43:03 <shapr> humasect: What about getting the thread to read from one of the channels in Control.Concurrent?
01:43:09 <gour> shapr: how to do that?
01:44:15 <humasect> shapr, can i make the Chan and pass it into the IO a when i fork it? a problem right now is holding some globals in ghci.. i'm using it for shell-like commands
01:44:24 <humasect> IORef didn't seem like the way.
01:44:44 <Cale> gour: so you wouldn't happen to know how I actually run something in the Render monad and draw to an image control?
01:45:14 <shapr> gour: You can use the "/topic" command to see the existing topic, then edit the topic to add your message and use "/topic some new topic" to put in the new topic.
01:45:22 <Cale> xerox has handed me some code to fix up, seemed to be in quite a rush, and I've never used gtk2hs :)
01:45:22 <gour> Cale: nope
01:45:40 <shapr> humasect: I don't remember. My first reflex would be to use the credit card transform to pass a reference to a Chan, but that may not be the best way.
01:46:15 <humasect> STM?
01:47:05 <Cale> It seems that I need a value of type Surface to be able to draw, but I don't know how to get hold of one.
01:48:24 <shapr> Nah, you don't need STM.
01:48:32 <shapr> At least, I don't think so.
01:48:48 <humasect> okay, that's what i thought (reflex) when you said credit card
01:49:46 <shapr> http://www.haskell.org/hawiki/TyingTheKnot
01:53:07 <humasect> hm hmm
01:54:00 * shapr boings happily
01:54:08 <shapr> Man I love programming!
01:54:19 * Muad_Dibber sends all his homework to shapr 
01:54:20 <Muad_Dibber> ;)
01:54:30 <shapr> This is such a cool job to have :-)
01:56:34 <humasect> =D
01:59:52 <shapr> hi trez, how's code?
02:00:04 <shapr> trez: Are you learning Haskell?
02:02:01 <Wilmer> okay, great
02:02:08 <Wilmer> the thompson book does all kinds of graphical things
02:02:18 <Wilmer> and i'm supposed to do those exercises too :-)
02:02:34 <Wilmer> while the yaht starts with nice string exercises
02:02:50 <Muad_Dibber> yeh bleh @ graphical stuff ;)
02:03:01 <shapr> The thompson graphical exercises are really string exercises too.
02:05:31 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050913","see also #haskell.se #darcs","try '/msg nickserv set unfiltered on' if lamdabot doesn't respond to you"]".' by gour
02:06:17 <Wilmer> heh, i just noticed indeed :-)
02:09:03 <sieni> It's sad that there doesn't seem to be any Haskell books on a similar level to Paulson's "ML for the Working Programmer"
02:10:09 <shapr> You could write one :-)
02:11:02 <vegai> also, we need a "Poignant guide to Haskell"
02:11:24 <vegai> I'm afraid I don't have enough humour in me for that
02:18:50 <poetix> http://lambda-the-ultimate.org/node/view/967 <- OMFG, *Visual Basic* is stealing ideas from Haskell!
02:20:32 <Micket> So, whats a good code editor for linux?
02:20:32 <Cale> whee! Got it working :)
02:20:45 <Cale> Micket: I use vim and/or emacs
02:20:58 <poetix> Micket: For Haskell code?
02:21:13 <Cale> Eventually, yi will be good :)
02:21:23 <Micket> Yes, preferably for other code too.
02:21:37 <Cale> (but right now, it's missing syntax colouring)
02:21:53 <poetix> Haskell mode in emacs is good. jEdit does nice syntax colouring, and can run ghci in a separate buffer
02:24:52 <poetix> Eclipse support for Haskell is still in its early stages, although I quite like Eclipse generally
02:26:11 <pesco> Sorry for the OT, but does anyone here know of a good Linux (and/or Gnome) program to manage network settings wrt. different locations?
02:26:37 <cjb> NetworkManager?  :)
02:27:37 <adept> pesco: guessnet?
02:28:37 <pesco> Thanks! Any opinions as to which one is preferable?
02:29:31 <adept> pesco: guessnet is a thingy which integrates into bootup scripts, it has no UI at all. If you want something Gnomeish, you should look elsewhere
02:30:30 <Micket> gah.. I can't stand this anymore. Help me please! I was going to set up the mouse buttons for work properly, and saw some guide pointing me to XF86Config, but i cant find that file anywhere. :(
02:31:05 <shapr> With all the mail config problems I'm having, maybe I should switch to postmaster.
02:31:17 <pesco> Hi shapr!
02:31:24 <shapr> hiya pesco! ltns! What's up?
02:31:28 <gour> Micket: maybe xorg.conf?
02:31:53 <pesco> shapr: I have an invitation for you... Join the KHJK!
02:32:09 <shapr> The what?
02:32:20 <pesco> Looky looky: http://www.khjk.org/
02:32:27 <shapr> Is that like the PoEE, the Paratheoanametamystikhood of Eris Esoteric?
02:32:40 <pesco> (Oh no! Google's gonna find me now.)
02:32:49 <pesco> shapr: Sort of, in a way. ;-)
02:33:42 <pesco> shapr: I thought you were already running postmaster...
02:34:12 <shapr> I was running it locally, but not on Scannedinavian
02:34:20 <pesco> oic
02:36:38 <poetix> "My principal goal in life is to make this reality approximate cool science fiction realities" <- as opposed to uncool sci-fi dystopias, presumably
02:37:03 <shapr> I like it!
02:37:06 <pesco> poetix: Basically.
02:37:14 <poetix> Maybe someone should set up the Soylent Green Society, dedicated to solving the problems of world hunger and overpopulation...
02:37:32 <pesco> poetix: But remember, any tool we create is probably equally well-suited to sinister sci-fi dystopiae.
02:37:51 <pesco> poetix: Really nice idea.
02:38:13 <pesco> shapr: Well, you've had your invitation. I can prepare a formal one, if you like. ;-)
02:38:17 * poetix wonders if dystopiae is really the plural of dystopia
02:38:31 <poetix> I think dystopia is Greek, rather than Latin, so it might not be...
02:38:39 <pesco> Oh, hm.
02:39:00 <pesco> Does latin have the letter y?
02:40:17 <pesco> So would that make distopia the imported latin form, whose plural probably would be distopiae?
02:40:32 <pesco> And what would be the greek plural I wonder?
02:40:41 <pesco> I've never learned greek.
02:43:12 <shapr> pesco: Who's Eike?
02:43:25 <pesco> shapr: cptchaos!
02:43:27 <shapr> oh!
02:43:30 <pesco> :)
02:43:54 <pesco> He moved in with me a couple of months ago, too.
02:46:57 <SickJacken> hmmm, any thoughts on....tabs vs spaces?
02:47:49 <int-e> hard disks are bigs, bandwidths are growing, packers pack consecutive spaces quite well and noone seems to agree on the tab size.
02:47:54 <int-e> bigs -> big
02:48:06 <shapr> Always use spaces.
02:48:10 <earthy> spaces, yes.
02:48:10 * int-e usually avoids tabs.
02:48:27 <SickJacken> i lean towards spaces....because what i see is what is there
02:48:29 <SickJacken> so to say
02:48:37 * earthy only does tabs when coding standards require them, and then only inserted by automatic indenters
02:48:50 * earthy will *not* write tabs
02:49:25 <SickJacken> vim does smartindenting....but it inserts spaces with me
02:49:37 <SickJacken> actually, pressing my tab key will just insert 4 spaces
02:50:09 <SickJacken> the downside is however....that with tabs...one could delete sentences/words faster...now i got to delete every single space
02:50:38 * earthy gives sickjacken dw
02:50:42 <earthy> and dW
02:50:49 <SickJacken> but dw will still just eat one space
02:50:54 <earthy> no
02:50:56 <SickJacken> no?
02:51:01 <ski> (fibonacci : liftM f x = return f `ap` x; liftM2 f x y = return f `ap` x `ap` y; liftM3 f x y z = return f `ap` x `ap` y `ap` z   etc)
02:51:03 <earthy> it will eat the entire word
02:51:15 <SickJacken> so it will work as a whitespace trimmer so to say
02:51:18 <earthy> if you are on a space, it will eat all the whitespace until the next word
02:51:24 <SickJacken> niiiiice
02:51:50 <earthy> basically, w jumps to the next word
02:51:52 <SickJacken> i wish there was some game similar to those oldschool typing games......that will improve my vim skills
02:52:08 * vegai gives SickJacken a mouse :)
02:52:13 <earthy> sickjacken: typespeed?
02:52:16 <SickJacken> haha
02:52:24 <earthy> or otherwise, nethack? :)
02:52:42 * poetix has always used tabs
02:53:07 <SickJacken> actually, now that i think of it....typing is the same in vim as in other editors...so i will improve my typing skills instead hehe
02:53:28 <SickJacken> vegai, i try to use my mouse as little as possible
02:53:59 <vegai> SickJacken: your loss then :)
02:54:10 <SickJacken> :)
02:54:23 <SickJacken> mouses are for games in my case hehe
02:54:35 <SickJacken> keeps my wrists happy
02:55:10 <poetix> What is the main objection against tabs, as opposed to spaces?
02:55:47 <musasabi> poetix: they look different for each person.
02:55:58 <poetix> In wordprocessing, it's *much* better to use tabs
02:56:12 <musasabi> poetix: and if tabs and spaces are ever mixed then relative indentation changes depending on tab length.
02:56:31 <vegai> SickJacken: well, my rodent is a trackball, actually
02:56:57 <humasect> tabs are nice for cursor navigation
02:57:00 <vegai> otoh, I *do* have a weird lumb on my hand ...
02:57:02 <vegai> lump
02:57:37 <SickJacken> on the top of your wrist?
02:58:24 <earthy> poetix: tabs are not standardised to a certain width
02:58:27 <vegai> I don't know the name of the spot... near the bottom of my palm, the spot that rests on the desk while using the mouse
02:58:43 <vegai> otoh, that spot rests on the desk while using the keyboard too
02:58:47 <earthy> which means that you totally fuck up depending on which interpretation the tab is given
02:58:52 <vegai> even more so that with the ball, actually
02:59:51 <SickJacken> ah, cause a lot of people have this thing...i forgot the medical name...
03:00:19 <SickJacken> small lump somewhere near the wrist, kind of swelling things
03:00:21 <SickJacken> -s
03:01:03 <z0d> SickJacken: RSI?
03:01:15 <Lemmih> dons: ping.
03:02:07 <shapr> boing boing boing!
03:02:17 <shapr> cysts?
03:05:54 <SickJacken> z0d, no no
03:06:00 <SickJacken> kind of cyst
03:06:19 <SickJacken> but other name, more friendlier than cyst
03:07:06 <SickJacken> GANGLION
03:07:09 <SickJacken> that's it
03:08:39 <z0d> ahh
03:08:45 <dons> Lemmih, pong
03:10:59 <shapr> pesco: Oh, you should check out #haskell-blah
03:12:23 <Lemmih> dons: Can you send me those patches another way? Gmail messes 'em up.
03:12:55 <dons> hmm. how should I send them?
03:13:24 <Lemmih> DCC?
03:13:52 <dons> really? but how in general will we proceed with hIDE development. will you be the maintainer of the repo?
03:14:00 <dons> or perhaps I could push over ssh
03:14:17 <dons> i've not used DCC
03:15:09 * gour hope shapr will put Trac with darcs backend online
03:15:32 <dons> Lemmih, you want me to try dcc?
03:16:00 <Lemmih> dons: Sure.
03:18:30 <dons> sent
03:21:11 <Lemmih> Hm, can you put it online somewhere?
03:21:25 <ndm> how does gmail mess a patch up?
03:21:31 <dons> yep, sure.
03:21:32 <ndm> why can't you send it as an attatchment
03:21:43 <dons> i have done so, ndm
03:21:56 <Micket> Hmm. I think ill gonna use Vim for coding. (or am i going to regret that later?)
03:21:57 <dons> so I'm not sure what gmail is doing
03:22:03 <dons> Micket, vim is good
03:22:09 <dons> I recommend it
03:22:10 <Micket> phew
03:22:16 <Micket> yeah. it seems nce
03:22:29 <Micket> but it has a even more steep learning curve than irssi
03:22:42 <Micket> especially to a linux noob like me
03:22:55 <dons> http://www.cse.unsw.edu.au/~dons/patches/hide.patch
03:23:17 <dons> Micket, :set nocompatible makes things easier
03:24:10 <Micket> Hmm
03:24:57 <gour> Micket: do you have vim quick refer. card?
03:25:28 <Micket> have it? i dont even understand what you just asked
03:25:50 <gour> Micket: short pdf with most import. commands
03:25:55 <dons> all good now Lemmih?
03:26:26 <Micket> well. im not sure. I guess i don't
03:26:40 <gour> i can send you, if u want
03:27:22 <Lemmih> shapr: Got time to setup an email address for hide on scannedinavian.org?
03:27:41 <dons> Lemmih, we can talk about yi integration if you'd like, before I leave
03:28:18 <Micket> Uhm ok, thanks :) But ill most likely mess up the dcc since im not used to irssi yet
03:28:49 <shapr> Lemmih: What's the source repo address?
03:29:13 <gour> Micket: well, i use simple kde's konversation
03:29:45 <Lemmih> shapr: http://scannedinavian.org/~lemmih/hIDE/
03:29:51 <shapr> Oh hey, what about a cheesy darcs email repo new developer bootstrapping trick where all the public keys are kept in their own files in a certain dir, and new pushes to the repo try to add all the keys from that dir?
03:29:59 <Micket> Uhm, gimme a minute, ill look up the help for irssi
03:30:07 <gour> ok
03:30:19 <shapr> Then any currently permitted public key for a darcs email repo would be able to add more keys.
03:30:57 <shapr> Any obvious flaws in that scheme?
03:32:10 <Micket> did it time out gour?
03:32:19 <Micket> try again i *think* i know how too now :D
03:32:23 <gour> Micket:yes, want again?
03:32:35 <kosmikus> shapr: not sure if I understand, but wouldn't then also everyone be permitted to revoke access for all other users?
03:33:19 <shapr> kosmikus: Yeah, but that's not much of a problem since the server admin would have the final say.
03:33:35 <Micket> guess i didnt know how to :/
03:34:59 <kosmikus> shapr: there was no mention of a server admin in your proposal; I thought you wanted to describe a scenario where you could do without
03:35:09 <shapr> Well, would be nice...
03:35:34 <musasabi> scannedinavian.org/ does not seem to respond to http.
03:35:37 <shapr> Much like the wiki, only spammers want to screw up stuff. Normal people tend to just help as best they can.
03:36:13 <gour> Micket: http://dev.atmarama.org/repos/VIM_Quick_Reference_Card.pdf
03:36:15 <shapr> Lemmih: Is your gpg key on the servers?
03:36:55 <shapr> dons: Is your gpg key on the servers?
03:37:29 <Micket> :) thanks
03:38:42 <shapr> Lemmih: Can I use your lemmih@gmail.com key?
03:42:44 <dons> i don't have a gpg key. is this really going to be a good way to work?
03:43:39 <shapr> I don't know, but it's worth trying.
03:43:49 <gour> Micket: so you got it?
03:43:59 <dons> i guess the best, in my mind, arrangement, would be push-over-ssh access to a central hIDE repo
03:44:28 <gour> i agree
03:44:29 <shapr> email works sort of like push.
03:44:54 <Micket> yes
03:44:58 <dons> you need to get a machine configured for email though
03:45:09 <shapr> I'd rather have gpg-signed cgi, then you don't need any configuration.
03:45:09 <dons> which involves a darcs send in between, perhaps
03:45:18 <gour> Micket: so i'll remove it
03:45:25 <humasect> darcs can handle email patches? wicked.
03:45:59 <shapr> dons: What do you think about cgi submission of gpg-signed patches? Any downside there?
03:46:06 <shapr> grussgott ded
03:46:23 <dons> would it work out of darcs?
03:46:31 <shapr> Yeah, with curl.
03:47:26 <dons> that would be ok
03:48:19 <shapr> darcs doesn't do it yet, but it sounds like the best balance of ease of use and patch pushing.
03:48:57 <dons> so we would have a 'hands-free' repo? developers aren't pushing to a maintainer, but instead directly to the repo?/
03:49:18 <gour> but isn't 'darcs push' the natural thin for "distributed development" according to hIDE manifesto?
03:49:41 <dons> yeah, I reckon. but we need ssh accounts for any developers
03:49:42 <shapr> Once cgi-gpg-push works, you'de just push to the repo.
03:50:05 <shapr> I'm willing to give ssh accounts to the people I already know and trust :-)
03:50:24 <gour> your site will be used for central repo (and maybe Trac :-)
03:50:55 <gour> shapr: you know dcoutts, dons, Lemmih, so you?
03:51:05 <gour> s/so/do
03:51:22 <dons> we could email ssh keys to shapr
03:51:32 <dons> this is how haskell.org works
03:54:16 <shapr> gour: Yes, I know dcoutts, dons, and Lemmih
03:54:29 <Micket> Hmm, how do get temporary root powers as a user in a terminal? i cant remember any commands :(
03:54:41 <tuomov> su, sudo
03:54:49 <shapr> Of course, the cgi-gpg-push would be nicest.
03:56:16 <gour> shapr: so they are the main devs and can have ssh accounts
03:56:36 <gour> shapr: i won't be able to contribute in the short-term..
03:57:01 <gour> shapr: but if, i can always send patch to e.g. dcoutts
03:57:31 <gour> shapr: but for main devs its, imho, more convenient to just do 'darcs push'
03:58:16 <shapr> gour: When you are able to contribute, come talk to me.
03:58:28 <gour> shapr: sure, i'll do
03:58:32 <shapr> If you have some good patches, I'll deputize you.
03:59:06 <gour> :-}
03:59:55 <gour> shapr: in the meantime i can open some ticket(s) in Trac ;)
04:06:42 <Micket> Do i always have to install every little package one at the time when they are all dependt off eachother in linux?
04:07:14 <gour> Micket: what distro?
04:07:18 <Micket> fedora
04:07:21 <Micket> trying to install vlc
04:07:35 <Micket> I have all the rpm files needed in a folder
04:07:57 <Micket> but the /rpm -U vlc/* --force   command doesnt do the trick
04:08:17 <gour> Micket: i tried with SuSE, but after switching to Gentoo, never looked back - enough of rpm-dependency hell :-)
04:08:27 <gour> Micket: portage rocks
04:08:44 <Muad_Dibber_> word gour.
04:09:05 <Micket> Soo. the sullotion is basicly.. switch to Gentoo?
04:09:05 <gour> with rpm-based distro, i had to compile from the tarballs too often
04:09:06 <Micket> :(
04:09:37 <gour> and upgrade was always a pita, well mostly re-install
04:09:41 <Wilmer> Micket: if that's a solution, i don't want to know what the problem is ;-)
04:10:12 <Micket> ah crap.. guess ill just install these one at the time in the correct order..
04:10:12 <gour> Micket: read Gentoo docs 1st ;)
04:11:14 <gour> but i heard that debian-like Ubuntu is also fine
04:12:00 <kosmikus> and debian itself, of course
04:12:07 <gour> sure
04:12:33 <gour> although, maybe, ubuntu is more up to date with the packages
04:14:40 <Wilmer> compared to debian testing it's pretty much the same, i think
04:14:58 <Wilmer> it all depends on what you want
04:15:50 <shapr> I use debian unstable, it's my favorite flavor!
04:15:56 <gour> Micket: i have a text file (~50k) posted sometime on http://sequence.complete.org/ with review of many linux distros
04:17:30 * Wilmer pets shapr
04:17:44 <Micket> Hmm thanks, buuut i think ill stick with fedora a while longer so i can learn more about it and get a good understanding of it
04:17:58 <Micket> I dont know enough about linux to tell the distros apart
04:18:50 <gour> well linux is linux, but the difference is in package management (although i prefer gentoo init scripts)
04:19:17 <Wilmer> gentoo has some dependency-based init system, right?
04:19:27 <Wilmer> doesn't macosx have something similar these days btw?
04:19:38 <gour> yes, very clean
04:19:49 <Wilmer> yeah, that's kind of nice indeed
04:19:53 <gour> i never liked SuSE doing too much of its own
04:20:06 <gour> with gentoo i know what's going on and what's installed
04:20:11 <gour> and why
04:20:22 <mflux_> rpm doesn't tell you?
04:20:24 <Wilmer> what in suse stops you from knowing what's installed?
04:20:52 <gour> well it was a pain to make a new install
04:21:23 <gour>  i left suse at 7.x
04:21:47 <gour> but yast scripts were often re-writing my settings
04:22:32 <gour> but, i understand, everyone has his/her own favorite flavour
04:25:24 <Wilmer> i can understand that mainly people who have a lot of boxes and/or don't want to spend too much time getting things to work go for suse, while people like you and me with too much spare time stick with debian or gentoo :-)
04:25:32 * SamB wonders if haskell-using employers would bother looking for people who knew haskell, or would just train them
04:26:09 <Wilmer> how many haskell-using employers are there in the big bad world?
04:26:22 <metaperl> Wilmer: aetion, galois in the USA
04:26:24 <Wilmer> i think many people from universities know it, at least a couple of them over here teach it to all students
04:26:31 <Wilmer> ok, that's a bit too far away for me :-)
04:26:43 <Wilmer> oh well, like i'm a haskell coder with just two lessons and one evening of experience
04:26:43 <metaperl> :)
04:26:52 <gour> Wilmer: gentoo was recommended to me by it guy
04:27:18 <shapr> I've had two small paying Haskell gigs so far.
04:27:32 <shapr> Just a few days of work, but better than nothing :-)
04:27:36 <gour> gour: and it does not require too much time for admin
04:27:41 <gour> ahh...
04:28:14 <Wilmer> just changed your nick, i guess? ;-)
04:28:53 <gour> Wilmer: however, i was frustrated being forced to update to a newer version, cause there was no newer package avaialable for older versions
04:29:31 <gour> and updates were not cheap - local distributer wanted $150 for SuSE 8.0
04:29:34 <Wilmer> yeah, for volunteer-based distros it's a bit too hard to continue to maintain a couple of releases
04:29:46 <Wilmer> huh? suse did the same thing?
04:30:04 <gour> yes, suse did it
04:30:11 <Wilmer> that's odd
04:30:22 <Wilmer> at least redhat supports every release for a couple of years...
04:30:33 <Wilmer> and so does debian, but that's more because of their release cycle length ;-)
04:30:42 <gour> with gentoo there is no concept of 'release', only profile changes
04:30:46 <Micket> the cdinfo rpm requiers libcdio.so.0 but when i try to install the package libcdio-o.71-0.i386.rpm it says its already installed :(
04:31:01 <gour> Micket: good luck with rpm
04:31:20 <Micket> Im getting depressed.
04:31:22 <Wilmer> i'm still pissed off with the gentoo libc devvers putting a libc with a totally broken fprintf in the distro
04:31:32 <gour> i ended up on SuSe using apt-get :-)
04:31:36 <Wilmer> Micket: rpm can work very well, but just avoid to install rpms by hand
04:31:39 <Wilmer> exactly
04:31:47 <shapr> Micket: Try debian!
04:31:53 <gour> WIlmer: nothing is perfect
04:31:58 <Wilmer> like you use apt-get on debian, emerge on gentoo, you should use some high-level packaging manager on other distros too
04:32:12 <Wilmer> gour: problem is that they don't seem to be willing to fix it
04:32:14 <shapr> Yeah, but apt was a bolt of lightning when it first came out.
04:32:22 <Wilmer> they don't care that fprintf doesn't return what it should
04:32:34 <Wilmer> shapr: uhuh :-)
04:33:05 <gour> Wilmer: didn't hit a 'fprintf'
04:33:05 <Wilmer> Micket: yast -i is what you're supposed to use to install packages... but i'm afraid the thing you want to install now doesn't come with suse?
04:33:17 <Wilmer> gour: hmm?
04:33:45 <gour> Wilmer: where do you have problem with fprintf?
04:34:19 <Micket> You guys really shouldnt be asking me questions regarding anything on linux and packages and expect a good answer :)
04:34:22 * int-e still remembers that SuSE used to come with a ghc package, then, one release, they shipped a ghc compiler that worked but produced executables that were linked against some older libraries ... and two releases later the package was gone.
04:34:27 <humasect> i am exploring ways to manage state in a ghci-controlled application
04:35:09 <Wilmer> gour: http://bugs.gentoo.org/show_bug.cgi?id=72260 <=- that's the one
04:35:13 <humasect> holding data with the existing FFI is all i can see right now.
04:35:24 <Wilmer> bug is open for almost a year already :-/
04:36:59 <kosmikus> Wilmer: is this the same as bug 100172?
04:38:10 <Wilmer> kosmikus: yeah, it seems to be the same
04:38:21 <kosmikus> that one claims it's fixed
04:39:46 <Micket> I just tried some install command with yum on the vlc package.. was that a bad idea?
04:39:55 <Micket> it seems to be doing some stuff now..
04:39:57 <Micket> :x
04:40:07 <Wilmer> kosmikus: yeah, i see. hmm, then someone should maybe fix the bitlbee bug too
04:43:08 <gour> Micket: http://dev.atmarama.org/repos/distros.html
04:59:32 * duncan_ is in the middle of demoing cool Haskell/cairo graphics at a department open day
05:00:10 <duncan_> xerox, it's going well so far, I was able to borrow a very fast machine so the drawing is really quick
05:00:24 <duncan_> xerox, sorry I couldn't use your updated version of the lsystem code
05:00:50 * Igloo checks his machine is still there...ah, good  :-)
05:01:08 <Igloo> (not that it classifies as "very" these days)
05:02:21 <humasect> @index unsafePerformIO
05:02:21 <lambdabot> System.IO.Unsafe, Foreign
05:03:50 <duncan_> Igloo, nah, I din't pinch your machine, it's one of the brand new machines the dapartment aquired recently
05:04:15 <duncan_> they've not been given out to students yet :-) I'm the first user
05:04:22 <Igloo> I didn't seriously think you would have  :-)
05:04:46 <duncan_> yeah, it's far too slow :-)
05:05:46 <humasect> now i've learnt the magic of MVar. excellent, and beautiful
05:06:08 <Igloo> Yeah, no way it could keep up with your bloated code  :-Ã¾
05:06:44 <humasect> heh
05:06:56 <humasect> (at discussion here)
05:07:17 <duncan_> Igloo, quite :-)
05:09:55 <boegel> somebody needed me in here ?
05:10:39 * boegel checks the logs
05:10:42 <SickJacken> no
05:10:43 <SickJacken> :P
05:11:06 <boegel> SickJacken: I was mentioned, because my XChat tab was blue :)
05:11:12 <SickJacken> :)
05:11:30 <SickJacken> in this case, that blue doesnt say the context your name was used in :D
05:11:54 <boegel> oh, it was just ProfTeggy replying :) nvm
05:20:38 <bourbaki> moin
05:23:53 <boegel> yo bourbaki
05:26:52 <humasect> MVar > monad state... is there an extreme difference really?
05:30:10 <humasect> (besides not requiring monadic functionality, of course)
05:31:38 <humasect> (StateT)
05:32:52 <manulito_> Hi, i got an error i can understand when using do: http://pastebin.com/365420
05:33:36 <manulito_> could anyone help me understand the problem, im kinda new to haskell and dont know the shit =(
05:33:36 <boegel> manulito_: if you _can_ understand it, then what's your question? ;)
05:34:03 <manulito_> =)) my english aer not best
05:34:05 <manulito_> :>>>
05:34:31 <boegel> manulito_: ok, sorry then :)
05:34:53 <manulito_> just wanted to brag =)
05:35:04 <manulito_> perhaps you understand the error-msg ?
05:35:20 <Philippa> you missed out a return
05:35:22 <musasabi>  fixedList <- [(inp,head(drop (floor r*(length rep)) rep)) | (inp,rep)<- tupleList] is the problem.
05:35:44 <musasabi> let fixedList = ...
05:35:50 <musasabi> as it is not in the monad.
05:35:52 <Philippa> non-IO values need a return in front of them to lift them into the IO monad before you can put them on the RHS of a <-, or you can use let
05:36:44 <Philippa> that's a really common newbie mistake, it'd be nice if GHC suggested a fix
05:37:00 <manulito_> thanks! it works
05:37:17 <manulito_> tho we still dont know anything about what a monad is :) but we got it to work
05:37:54 <Philippa> Think you mean "I" there, unless there's more than one person behind your IRC client?
05:38:18 <shapr> kanske!
05:40:12 <boegel> manulito_: many people in here still don't understand monads (including me), so don't worry
05:40:20 <shapr> @where monads
05:40:21 <lambdabot> I know nothing about monads.
05:41:01 <int-e> @where wadler
05:41:02 <lambdabot> I know nothing about wadler.
05:41:08 <boegel> @where shapr
05:41:09 <lambdabot> I know nothing about shapr.
05:41:16 * shapr hides effectively!
05:41:23 <boegel> @botsnack
05:41:24 <lambdabot> :)
05:45:22 <manulito_> =)
05:46:04 <Micket> got another linux question :}  rpm packages with devel in its name are for developing software that uses the package right?
05:46:31 <shapr> Right, they include the sources.
05:46:44 <Micket> ah ok, thanks!
05:46:49 <integral> 1
05:46:58 <Micket> 2?
05:49:23 <boegel> 3!
05:49:40 <shapr> 42
05:50:32 <Micket> the meaning of life!
05:51:01 * boegel loves that answer
05:52:33 <shapr> hoi asmodai, learning Haskell? ;-)
05:53:42 * Wilmer feels a tour coming up ;-)
05:53:54 <boegel> Wilmer: nah, asmodai is a regular
05:54:07 <shapr> asmodai has been resisting my attempts to teach him Haskell.
05:54:12 <Wilmer> heheh, okay, the nick seemed familiar already
05:54:54 <boegel> asmodai: shame on you !
05:55:19 <Wilmer> hmm, for a moment i confused asmodai with some guy who read traffic announcements on the radio here some time ago, but that guy is called tom :-)
05:56:15 <boegel> Wilmer: I can see the connection :|
05:56:33 <Wilmer> ah, cool, so it's not just me :-)
05:57:30 <Wilmer> you listened to dutch radio?
05:58:38 <asmodai> shapr: hahaha
05:58:40 <asmodai> shapr: not at all
05:58:51 <asmodai> shapr: just that working on this compiler is taking most of my time.
05:59:01 <asmodai> Wilmer: hahahaha
05:59:04 <asmodai> Wilmer: I hear that a lot.
05:59:09 <asmodai> He might be family somewhere
05:59:10 <Wilmer> hehe, i was afraid so, sorry :-)
05:59:14 <asmodai> but IIRC he is Ruigrok van de Werve
05:59:19 <Wilmer> yeah, just noticed
05:59:20 <asmodai> whereas I am Ruigrok van der Werven
05:59:34 <Wilmer> and he got fired for watching porn at work, it seems
05:59:40 <asmodai> seriously?
05:59:42 <shapr> asmodai: Haskell is good at compilers :-)
05:59:43 <Wilmer> yeps
05:59:48 <asmodai> :|
05:59:52 <asmodai> Wouldn't have guessed.
06:00:03 <Wilmer> asmodai: http://www.goedzo.com/goedzo.php/2004/11/29/
06:00:09 <Wilmer> it's on some weblogs
06:00:56 <boegel> watching porn is illegal ?
06:01:00 <Wilmer> at work it is
06:01:01 * boegel closes some windows
06:01:04 <Wilmer> hehe
06:01:10 <asmodai> haha
06:01:11 <dblhelix> boegel: lol
06:01:40 * boegel looks around frantically while trashing his collection
06:01:41 * asmodai kicks screen, termcap and such
06:02:10 <dblhelix> looking at the stats from the major league baseball is like watching porn for boegel...
06:02:25 <boegel> dblhelix: fu :)
06:02:31 <asmodai> It gets him off?
06:02:44 <dblhelix> asmodai: you don't wanna know
06:03:21 <boegel> hey, what's going on here ? is this on-topic ?
06:03:37 <basti_> hi all
06:03:42 <shapr> topic!
06:03:43 <boegel> otherwise, I'd gladly invite you guys to #haskell-blah, where that off stuff is legal
06:03:59 <asmodai> Hahah
06:04:01 <dblhelix> it's all about baseball there :)
06:04:13 <asmodai> rofl
06:04:35 <basti_> oh
06:09:56 * boegel considers expanding the support of his HRay renderer
06:11:20 <SickJacken> to draw baseball cards
06:19:24 <humasect> hray != hsrt (?)
06:28:54 <boegel> humasect: hray is my raytracer for my thesis (see http://scannedinavian.org/~boegel/HRay)
06:44:40 <SamB> hmm, why do I get a parse error at *column 15* in this:
06:44:46 <SamB>     decode a  (x:xs@~(x':xs'))
06:45:08 <int-e> what's ~ ?
06:45:21 <SamB> column 15 is before that
06:45:28 <ProfTeggy> int-e: irrefutable pattern
06:45:35 <ProfTeggy> Google. :-)
06:47:06 <int-e> ProfTeggy: thanks *reading*
06:48:15 <SamB> is there an index of funny symbols in the report?
06:48:57 <Igloo> SamB: Does decode a  (x:xs@(~(x':xs'))) work?
06:49:47 <SamB> yes, it does.
06:50:31 <SamB> so what is with the misleading column number?
06:51:02 <SamB> oh, maybe that was supposed to be the location of the pattern...
06:51:20 <int-e> oh, is @~ a single lexeme? would @ ~ work?
06:51:53 <SamB> wouldn't look very good...
06:55:12 * SamB wonders if his program is getting into an infinite loop, or just running very slowly all of a sudden... compiles it in the hopes that it is just being slow...
06:55:32 <manulito_> ls
06:55:41 <manulito_> oups
06:55:46 <ProfTeggy> EWINDOW, manulito
06:55:54 <SamB> ENOTTY
07:02:34 <z0d> ls? trivial root password
07:04:58 <boegel> z0d: root, _that's_ a trivial root password ;)
07:05:25 <z0d> no, that's a tricky one. I would never try that <-:
07:05:57 <SamB> I only try that if its an image I got from somewhere else, or a freshly installed system...
07:06:55 <boegel> z0d: lots of people do that, you'd be surprised
07:18:36 * boegel leaves for home
07:26:26 <basti_> what does haskelldb do more than hsql?
07:26:58 <shapr> lotsa stuff
07:27:21 <shapr> haskelldb uses combinators instead of SQL
07:27:22 <Lemmih> They aren't really comparable.
07:27:36 <shapr> You get real haskell data types for the data and tables.
07:28:22 <shapr> You can build higher order queries with the combinators, for example. You can't do that with SQL at all.
07:28:29 <basti_> hmm
07:28:43 <basti_> then the problem is: i can't build directdb. is it essential for haskelldb?
07:28:59 <Lemmih> Nope.
07:29:00 * shapr gives up and gets his unicycle ready to take to town.
07:29:23 <shapr> Man, I've had this headache for days.
07:29:33 <basti_> hmmmok.
07:29:36 <basti_> thats cool then
07:32:33 <Lemmih> @wiki HaskellDbTutorial
07:32:33 <lambdabot> http://www.haskell.org/hawiki/HaskellDbTutorial
07:33:51 <basti_> thanks
07:34:09 <basti_> the body of documentation on that topic is distributed and not obvious
07:35:08 <z0d> good day neadjneki
07:37:38 <neadjneki> hi :)
07:54:27 <basti_> debian sucks.
07:54:34 <basti_> all versioning sucks.
07:54:35 <xerox> :(
07:54:38 <beelsebob_> ndm: I've broken hat-trans!
07:55:01 * ndm shoots beelsebob_
07:55:17 <ndm> of course, the new hat trace generator will solve all
07:55:32 <beelsebob_> no seriously... I've found a program that you feed to it and it generates an invalid hat file
07:56:03 <ndm> how long?
07:56:09 <ndm> how long is the source for this program?
07:58:27 <beelsebob_> it's about 30 lines
07:58:32 <beelsebob_> prelude only
07:58:40 <beelsebob_> given one line's input
07:59:17 <basti_> this s-ckf-cks.
07:59:54 <ndm> put the source somewhere
07:59:56 <ndm> @paste
07:59:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:00:06 <beelsebob_> ndm: just went out on the hat mailing list
08:00:12 <beelsebob_> along with my terminal output
08:00:22 <ndm> hat mailing list?
08:00:26 <ndm> oh, will have to subscribe
08:00:27 <beelsebob_> hat@haskell.org
08:00:35 <beelsebob_> hang on... I'll paste it too then
08:02:08 <beelsebob_> @paste ndm
08:02:09 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:02:35 <basti_> the whole versioning situation is unbearable!
08:02:45 <basti_> you can't upgrade ANYTHING without breaking everything else!
08:04:31 <ndm> nothing that unusual there, but you did break syntax colouring on the paste page
08:04:56 <beelsebob_> hehe
08:05:29 <beelsebob_> do you like what I called the file?
08:05:39 <ndm> yeah, i noticed
08:05:50 <Blownose> i have the following [([String], [[String]])] where i want to randomize one of the [[String]] and make the following ([String],[String]) is it possible in one row ?
08:05:56 <beelsebob_> stephan sent it to me to test hat-delta
08:06:50 <ndm> stephan?
08:07:36 <beelsebob_> Stephan Kahrs, our version of Detlef
08:08:02 <ndm> ah, the required departmental German
08:08:28 <beelsebob_> no... the departmental psycho... who thinks that that kind of program is nice and easy
08:08:42 <ndm> Detlef can't even program haskell
08:08:53 <beelsebob_> yeh... but he can program GP
08:09:16 <ndm> yeah
08:20:45 * dcoutts clears his throat
08:20:47 <dcoutts> ah hem
08:21:00 <dcoutts> I should like to announce that xerox rocks
08:21:06 <basti_> dcoutts: the versioning situation sucks, though.
08:21:08 * xerox hides
08:21:09 <dcoutts> specifically...
08:22:02 <dcoutts> I was demoing xerox's cairo code at a department open day today and was showing it to one of the seionor preofessors in the lab
08:22:06 <ndm> btw xerox, ages ago you asked where the hoogle darcs had got to
08:22:32 <dcoutts> he is now very keep to use it as the basis for a frist year practical to tech students Haskell
08:22:33 <ndm> its now got a CVS on sourceforge, hoogle.sourceforge.net
08:22:42 <xerox> yay
08:22:50 <rep> !
08:22:53 <xerox> I'm very proud of it :)
08:23:12 * xerox hugs dcoutts  --  it's all about your support in these months :D
08:23:21 <dcoutts> so come October or so dozens on 18 year old students at Oxford will be cursing xerox for comming up with more work for them
08:23:44 <xerox> Ouch!
08:24:02 <dcoutts> or hopefully they'll be pleased that it's an interesting and pretty practical rather than the usual dull ones :-)
08:24:03 <beelsebob_> bah... fucking ghc
08:24:07 * beelsebob_ downloads nhc
08:24:19 <xerox> hehe!
08:24:30 <dcoutts> so well done xerox
08:24:47 * dcoutts applaudes
08:24:51 <xerox> Thanks very very much.
08:25:00 <dcoutts> basti_, what were you saying?
08:25:01 <Cale> :)
08:25:07 <basti_> dcoutts: versioning sucks, generally.
08:25:22 <Cale> dcoutts: that's cool
08:25:25 <dcoutts> basti_, oh, are you talking about anything in particular
08:25:39 <dcoutts> Cale, yeah, soory it was too late to use your new code for the demo today
08:25:43 <basti_> dcoutts: debian versioning
08:25:48 <xerox> I should publicly thank you, again, Cale/TheHunter for monadic support (heh), and the whole Haskell community in these months.  I'm very impressed about you all.
08:26:28 <dcoutts> basti_, oh was I complaining?
08:26:33 <basti_> dcoutts: no.
08:26:34 <xerox> I never find such a great community around a subject, the fact that it is 1) great 2) very interesting, surely help :D
08:26:37 <basti_> dcoutts: i just have to rant.
08:27:07 <dcoutts> basti_, funny you should say so, I was having a similar rant yesterday when trying to install debian on a couple machines
08:29:26 * basti_ is now deinstalling ALL ghc related debian packages because this is such a PITA
08:29:45 <Igloo> basti_: Debian versioning?
08:29:57 <beelsebob_> :o
08:30:09 <beelsebob_> gour is an op... does that ever happen in #hasklee?
08:30:10 <basti_> Igloo: yes
08:30:13 <beelsebob_> haskell too
08:30:26 * Igloo doesn't even know what you mean by that
08:30:57 <basti_> Igloo: its either ancient everything (stable), or broken everything (testing, unstable)
08:31:47 <gour> beelsebob_: my op is shapr's trick only
08:31:54 <basti_> then if you install something, and upgrade something, chances are about 1:1 that this operation will break something.
08:34:15 <Lemmih> dons: Sleeping?
08:49:02 <z0d> do you think classifying langauges based on paradigms will be obsolete soon? more and more language are multiparadigm languages
08:49:43 <z0d> *are becoming
08:49:44 <ndm> z0d, a language can't be both pure adn impure
08:49:52 <ndm> there are some one or the other paradigms
08:50:24 <musasabi> z0d: multiparadigm languages usually do none very well.
08:57:19 <ProfTeggy> Nice weekend all, bye!
09:07:10 <ape> hello, anyone seen gour?
09:07:25 <gour> her i'm
09:07:33 <ape> hey, it's me :) how's it going?
09:07:39 <gour> ok
09:07:43 <gour> and you?
09:07:57 <ape> bad :\
09:08:05 <gour> :-(
09:08:12 <gour> what's wrong?
09:08:18 <ape> sorry i didn't pm you earlier, freenode is apparently sucking even more, they've blocked pms from unregistered nicks
09:08:36 <gour> yeah, i heard about it, can you register?
09:08:51 <ape> how about we just join a private channel? #gour should do
09:09:05 <gour> ok, invite me
09:20:46 <dcoutts> Lemmih, have you seen dons new code and ideas?
09:23:12 <dcoutts> Lemmih, we had a long discussion about Yi/hIDE integration last night
09:23:25 <dcoutts> it looks reasonably promising
09:24:40 <Lemmih> I get the feeling that Yi is horribly hard coded for use in a terminal.
09:25:17 <dcoutts> Lemmih, that's not what dons thought
09:26:10 <dcoutts> Lemmih, we're trying to get it to use the GtkTextBuffer as it's buffer rather than the current FastBuffer implementation
09:26:30 <dcoutts> this can be done my making GtkTextBuffer an instance of Yi's Buffer class
09:26:47 <dcoutts> then we connect the TextView to the TextBuffer
09:27:52 <dcoutts> that should handle the buffer side of things, then we have to deal with the input side of things
09:28:06 <dcoutts> ie who is responsable for actually updating the buffer
09:28:57 * Lemmih has been looking at Proxima.
09:29:30 <dcoutts> oh yeah, it looks neat
09:31:58 <Lemmih> Starting off with a proxima-style design is a lot more charming than hacking similar features into yi, IMHO.
09:33:37 <dcoutts> Lemmih, well you can see if you can get their code :-)
09:33:53 <dcoutts> Lemmih, what proxima lacks currently is interactive editing
09:34:15 * gour gour wonders about proxima
09:34:16 <Lemmih> Interactive editing?
09:34:23 <dcoutts> it allows you to edit things only in that one edit box, the main page itself is not directly editable
09:35:03 <dcoutts> because actually doing a GUI editor is non trivial
09:35:09 * basti_ still doesnt know what to do with his versioning issues
09:35:35 <dcoutts> managing all the drawing, cursor, line wrapping, text measuring etc
09:36:04 <dcoutts> the Gtk TextView/TextBuffer system is quite a big chunk of code
09:39:03 <Lemmih> But that's a problem with the implementation and not the idea.
09:39:35 <Lemmih> Hi SyntaxNinja.
09:40:20 <dcoutts> Lemmih, sure
09:40:43 <dcoutts> it'd be cool, but I fear the implementation may be rather tricky
09:42:12 <dcoutts> SyntaxNinja, you've seen that JaffaCake is suggesting the ./setup register --package-db=<file> approach too
09:43:29 <SyntaxNinja> dcoutts: no
09:43:53 <dcoutts> SyntaxNinja, he sent it to you, me and the Haskell libraries list
09:45:30 <musasabi> What should that mean for implementations without a package database file?
09:45:56 <dcoutts> musasabi, quite, that was one of SyntaxNinja's main points
09:46:10 <musasabi> I am slowly hacking together JHC support into Cabal - so that is why I am interested.
09:47:26 <SyntaxNinja> musasabi: I'm folling up now
09:50:25 <musasabi> Why not simply support multiple cabal files and let them depend on each other in non-circular ways and let each implementation worry about things?
09:51:09 <dcoutts> musasabi, that'd nice, but it's a slightly different point than what --package-db=<file> is trying to solve
09:51:30 <dcoutts> thats for this vistualisation stuff and no end of other hacks
09:51:58 <dcoutts> like using non-standard package database locations
09:52:10 <dcoutts> (if the compiler supports such a notion)
09:52:47 <musasabi> How about --ghc-package-db=<file> ?
10:15:03 <SyntaxNinja> musasabi: http://www.haskell.org//pipermail/libraries/2005-September/004376.html
10:15:13 <SyntaxNinja> (and dcoutts)
10:20:19 <dcoutts> SyntaxNinja, I don't see how --package-db= conflicts with --prefix
10:20:35 <dcoutts> "That is, if you specify a package database, it changes the
10:20:35 <dcoutts> location of the installation"
10:20:48 <dcoutts> is this really true? why?
10:23:42 <SyntaxNinja> dcoutts: hugs doesn't have a package database, do if you say --package-db= for Hugs, then you're saying that the package itself must be in that directory.
10:24:23 <SyntaxNinja> Hugs can't have a package database that's distinct from the actual package installation locations.
10:26:17 <basti_> ok, i'm officially too stupid to build haskelldb
10:26:21 <basti_> or even to install it
10:28:53 <SyntaxNinja> basti_: ?
10:29:14 <basti_> SyntaxNinja: I can't install it because the versioning in testing sucks.
10:29:22 <basti_> (debian testing that is)
10:29:30 <basti_> trying to do so results in conflicting dependencies
10:29:40 <Lemmih> How about installing it from source?
10:29:42 <dcoutts> SyntaxNinja, oh yes, good point
10:29:48 <basti_> that can't be resolved wihtout deinstalling vital software (including ghc)
10:29:53 <basti_> then, about compiling:
10:30:03 <basti_> i tried that.
10:30:08 <basti_> ghc-6.4 crashes
10:30:15 <Lemmih> Segfault?
10:30:24 <basti_> basically lots of same errors
10:30:29 <basti_> about -1 being some illegal opcode
10:30:30 <basti_> in ghc-asm
10:30:35 <basti_> something like that
10:30:40 <basti_> which is said to be a fixed issue in a later version, but i can't upgrade it.
10:30:45 <Lemmih> Then remove -O from GHC-Options in the cabal file.
10:30:50 <basti_> hmm
10:30:54 <basti_> ok I'll try that
10:30:59 <SyntaxNinja> dcoutts: it seems that this point was also missed by simonMar and f.e.  I feel like I've been effectively shouted out of hte conversation.
10:31:00 <basti_> because upgrading ghc, have a guess what it demands!
10:31:40 <dcoutts> SyntaxNinja, I don't think the point about hugs was very clear actualy, I missed it in that last email
10:32:42 <basti_> Lemmih: its stuck again, apparently.
10:32:45 <SyntaxNinja> dcoutts: I guess I'm not communicating it well.
10:37:44 <SyntaxNinja> dcoutts: do you think I should follow up to make it more clear?
10:38:35 <dcoutts> SyntaxNinja, the hugs point, possibly yes
10:38:56 <basti_> so, basically, i can't compile haskelldb because i have the wrong compiler, which i can't upgrade because all versioning sucks, and then i don't need to compile it on the cvs version, since i'm not gonna use the cvs version of ghc for something serious
10:41:36 <SyntaxNinja> basti_: what versioning sucks?
10:41:40 <SyntaxNinja> why can't you install ghc?
10:41:40 <basti_> debian versioning
10:41:45 <basti_> i can install it
10:41:48 <basti_> i got it installed
10:41:56 <basti_> i just wonder if doing that by hand would be less pain
10:42:00 <SyntaxNinja> why can't you upgrade it?
10:42:08 <basti_> because it implies conflicting installs
10:42:14 <basti_> some arbitary precision-math-library
10:42:20 <SyntaxNinja> that should be fixed now
10:42:20 <Lemmih> What version of GHC do you have installed?
10:42:27 <SyntaxNinja> apt-get update and try again?
10:42:30 <basti_> ok
10:43:12 <basti_> its not that I didnt try that part
10:43:14 <basti_> recently
10:43:15 <basti_> or anything
10:43:57 <SyntaxNinja> you'Re using untesting, or unstable?
10:44:01 <SyntaxNinja> heh er, testing
10:44:23 <basti_> lol
10:44:27 <basti_> testing atm
10:44:33 <basti_> ok that part seems to be fixed
10:44:43 <basti_> lets see if that helps with compiling haskelldb
10:45:00 <basti_> last time i tried that was just a few hours ago
10:45:32 * basti_ slurps silently
10:45:39 <SyntaxNinja> hm. something else must have messed up, it's been fixed for a week or two
10:45:53 * basti_ sighs
10:45:55 <SyntaxNinja> but only in unstable. not sure what the status of testing is
10:46:04 <basti_> maybe the change took time to propagate
10:46:16 <basti_> in any case, change sets should be committed atomically to any database.
10:46:23 <basti_> even debians sucky packet database
10:46:45 <basti_> which really really gets lots of things wrong. more on that on -blah though
10:46:46 <basti_> ;)
10:47:00 <manulito_> how would a string->string function to remove backspace look like ?
10:47:47 <basti_> it would probably copy everything but the backspaces
10:48:42 <manulito_> and backspace are some strange char \A or U?
10:48:50 <basti_> \\
10:48:53 <basti_> as usual
10:48:53 <manulito_> ok
10:51:23 <basti_> Lemmih: upgrading ghc to what debian calls "6.4-4.1" (whatever that is, the --version just says 6.4...?) didn't help, removing -o didnt help too
10:53:15 <Igloo> That's backslash
10:53:26 <basti_> argh
10:53:30 * basti_ got confused
10:53:45 <basti_> manulito_: i was stupid.
10:55:21 <manulito_> its '\b', found a nice way to do it :>
10:55:25 <basti_> :)
10:55:33 <manulito_> stripBS (x:'\b':xs) = stripBS xs
10:55:33 <manulito_> stripBS (x:xs) = x:stripBS xs
10:55:33 <manulito_> stripBS [] = []
10:55:42 <basti_> ohhh
10:55:44 <basti_> yes thats cute
10:55:56 <basti_> i didnt realize you want to strip them together with the char that they'd delete
10:56:02 <basti_> what does it do on "aaa\b\b\b"?
10:57:31 <manulito_> guessing "aaa", with 3 recursions on middle function then 3 on first then quit with last one?
10:57:50 <basti_> i'd say it does not what i'd expect it to do
10:57:56 <basti_> it should result in "" shouldnt it?
10:59:15 <manulito_> im not able to remove written chars when i input stuff in ghci, and i dont want the \b for input
10:59:34 <basti_> um
10:59:36 <basti_> bye then
10:59:43 * basti_ .oÂ° ( ? )
11:02:35 <basti_> oOoooOooOO
11:02:40 <basti_> its wooorking
11:03:38 * basti_ slaps a trout onto haskelldb and ghc.
11:04:29 <xerox> how is haskelldb?
11:04:35 <basti_> its advancing
11:04:43 * xerox will have to mess with that beast
11:04:53 <basti_> the newest ghc in debian-unstable made it
11:04:58 <basti_> after ... 10 minutes of grovelling
11:10:40 <basti_> i somehow find the thought appealing that my compiler might spend even more time with that program than me
11:10:48 <basti_> would be the first time, though.
11:20:01 <basti_> grovelling... slowly...slowly.... .... ...
11:20:10 <basti_> 18 minutes compile time now!
11:25:13 * basti_ explodes
11:25:16 <basti_> its done :)
11:30:30 <basti_> that was something like 3 days of ever repeating frustration now.
11:32:18 <CosmicRay> what exactly are you compiling, basti?
11:32:28 <CosmicRay> it sounds as if you are trying to build ghc on aix ;-)
11:32:57 <basti_> haskelldb
11:33:38 <CosmicRay> basti_: hey, have you fixed it so i'm not required to have DISTINCT with every SELECT yet? ;-)
11:34:30 <basti_> no
11:34:32 <basti_> i just built it
11:34:36 <CosmicRay> heh
11:44:26 <musasabi> SyntaxNinja: I added yet another way to http://www.haskell.org/hawiki/Cabal_2fVirtualizationRequirements
12:14:40 <nano-> I'm having problems with an assignment in school. "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" so that: match '*' "test=*" "test=hooray" returns "hooray" and I have no idea where to begin. Just wondering if anybody could give me a hint in the right direction.
12:18:46 <int-e> nano-: find the position of the '*'; then you can split the pattern in a prefix, the '*' and a suffix; then you can split the other list accordingly and compare the prefix and suffix.
12:21:04 <nano-> hmm.. ok. I'll play around some.
12:39:37 <xerox> Parsec? :)
12:45:55 <luqui> @type let foo = 7 in foo
12:46:02 <lambdabot> forall t. (Num t) => t
12:47:31 <luqui> hmm, well that didn't illustrate it
12:47:41 <luqui> anyway, in ghci, if I type "let foo = 7"
12:47:44 <luqui> then ":t foo"
12:47:53 <luqui> it says "foo :: Integer"
12:48:08 <luqui> so when does it decide that it's an Integer and not a (Num a) => a
12:48:32 <Lemmih> That's the defaulting mechanism kicking in.
12:48:43 <luqui> which is...
12:48:57 <luqui> the "default" Num is Integer or something?
12:52:26 <luqui> found what I was looking for in an faq
13:07:46 <sethk> @eval foo=7
13:07:51 <lambdabot> 21: parse error on input `='
13:07:54 <sethk> @eval let foo = 7
13:07:55 <lambdabot> 29: parse error on input `)'
13:08:08 <sethk> @eval let foo=8
13:08:09 <lambdabot> 27: parse error on input `)'
13:08:12 <sethk> hmm
13:10:30 <nano-> int-e: Thanks for the tip, but I'm getting nowhere, do you have time to explain in detail? priv? Just started out with fp so nothing makes much sense yet, I understand what I have to do and almost how, but I don't know how to put it together.
13:15:58 <astrolabe> nano:  As a subtask, try writing a function that returns the bit of a list before the first occurance of *, and the bit after
13:18:41 <astrolabe> nano: sorry, that was confusing, let me think a mo.
13:21:39 <astrolabe> nano:  Right!  make a function Eq a => a->[a]->([a],[a]) that separates the second argument into the bit before the first argument, and the bit after it.
13:23:03 <nano-> astrolabe: oh.. sorry for ignoring you :))
13:24:42 <astrolabe> np
13:46:35 <goron> Does anyone have a C3D viewer on a *n*x platform?
13:56:03 * basti_ just made his first haskelldb query work
13:56:28 * basti_ boings
14:04:06 <ProfTeggy> G'Evening.
14:07:25 <astrolabe> evening
14:20:20 <SickJacken> from all the functions Data.Map has....i need to find the max key...and there is no builtin function for it
14:20:23 <SickJacken> what a shame
14:22:03 <SickJacken> @eval Data.Map.findMax (Data.Map.fromList [(1,"foo"), (3, "bar"), (-1, "rino")])
14:22:09 <lambdabot> 18: Not in scope: `Data.Map.findMax'36: Not in scope: `Data.Map.
14:22:09 <lambdabot> fromList'
14:22:46 <SickJacken> @eval findMax (fromList [(1,"foo"), (3, "bar"), (-1, "rino")])
14:22:47 <lambdabot> 18: Not in scope: `findMax'27: Not in scope: `fromList'
14:23:13 <SickJacken> @help eval
14:23:13 <lambdabot>  @eval <expr>
14:23:13 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
14:23:18 <SickJacken> @help
14:23:18 <lambdabot>  @help <command> - ask for help for <command>
14:23:23 <SickJacken> @help command
14:23:24 <lambdabot>  @help <command> - ask for help for <command>
14:23:25 <SickJacken> @help commands
14:23:25 <lambdabot>  @help <command> - ask for help for <command>
14:23:29 <SickJacken> @help help
14:23:30 <lambdabot>  @help <command> - ask for help for <command>
14:24:16 <SickJacken> @eval Map.findMax (Map.fromList [(1,"foo"), (3, "bar"), (-1, "rino")])
14:24:17 <lambdabot> 18: Not in scope: `Map.findMax'31: Not in scope: `Map.fromList'
14:24:27 <SickJacken> @list
14:24:28 <lambdabot> Maybe you meant: listchans listcommands listmodules dict
14:24:31 <SickJacken> @listcommands
14:24:31 <lambdabot> use listcommands [module|command], please. Modules are:
14:24:31 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
14:24:31 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
14:24:31 <lambdabot> spell state system todo topic type version vixen where
14:24:46 <SickJacken> @plugs Data.Map.findMax (Data.Map.fromList [(1,"foo"), (3, "bar"), (-1, "rino")])
14:24:47 <lambdabot> 18: Not in scope: `Data.Map.findMax'36: Not in scope: `Data.Map.
14:24:47 <lambdabot> fromList'
14:24:48 <Lemmih> @tyep Data.Map.findMax
14:24:49 <lambdabot> forall a k. Data.Map.Map k a -> (k, a)
14:25:15 <SickJacken> @plugs Data.Map.findMax (Data.Map.empty)
14:25:17 <lambdabot> 18: Not in scope: `Data.Map.findMax'36: Not in scope: `Data.Map.
14:25:17 <lambdabot> empty'
14:25:21 <SickJacken> i dont get this
14:25:25 <SickJacken> qualified is not allowed anymore
14:25:29 <SickJacken> ow wait
14:25:35 <SickJacken> those modules are not incorporated
14:25:40 <Lemmih> eval /= ghci.
14:26:14 <SickJacken> there were ideas of incorporating those modules no?
14:31:40 <SickJacken> the api documentation is wrong in Data.Map
14:32:02 <SickJacken> deleteFindMin ; Delete and find the minimal element.
14:32:14 <SickJacken> it deletes and finds the element with the minimal KEY
15:01:56 <eieiei> does Haskell support higher-order functions à la Scheme?
15:02:20 <integral> Have you looked at Haskell at all?  There's some examples on the website. (www.haskell.org)
15:02:36 <eieiei> well, I'm following one of the tutorials.
15:02:40 <eieiei> I'm getting the hang of the syntax fast.
15:02:59 <eieiei> I'm just asking if I can pass a function as an argument, and how to do it if possible.
15:03:14 <integral> func1 func2 -- yes, this simple
15:03:26 <eieiei> thanks :)
15:04:03 <eieiei> so, is "derivative func x h = (func (x+h) - func(x-h))/(2*h)"  correct?
15:05:10 <integral> I think so
15:05:29 <eieiei> thanks.
15:05:40 <integral> hmm, but I'm not entirely sure on the precedence of - vs. juxtaposition
15:06:06 <lispy_> function application always binds the tightest
15:06:21 <eieiei> so I should add parenthesis around (func (x+h)).
15:06:23 <lispy_> but operators have whatever precedence has been defined for them
15:06:47 <integral> lispy_: and that precedence can't be defined tighter than application?
15:06:59 <lispy_> integral: not that i'm aware of
15:07:11 <integral> ok.   It's all these little details of Haskell I'm clueless about :)
15:07:44 <eieiei> *Main> derivative (\x->x*x) 12 0.0000001
15:07:44 <eieiei> 23.999999854140697
15:07:48 <eieiei> it worked. thanks.
15:07:51 <SickJacken> if you can pass a function as an argument...DUDE you are talking about haskell here
15:08:30 <eieiei> I'm very fond of S-expressions, but I'm beginning to derive pleasure from Haskell.
15:08:35 <eieiei> (\x->x*x)  is very pretty.
15:09:03 <integral> @pointless \x -> x * x
15:09:04 <lambdabot> join (*)
15:09:34 <eieiei> I'm in programming for the syntatic sugar :-P
15:09:35 <int-e> @hoogle a->(a,a)
15:09:37 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
15:09:37 <lambdabot> Prelude.properFraction :: (RealFrac a, Integral b) => a -> (b, a)
15:09:37 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
15:10:00 <eieiei> anyway, I can't live without higher-order functions or recursion. I don't have the slightest idea of how so many big real-world applications are built without those.
15:10:18 <integral> by using objects,  they're the same as closures
15:10:39 <eieiei> so what's the point of CLOS and O'Haskell?
15:10:48 <eieiei> or O'Caml for that matter?
15:11:05 <luqui> because some problems map into the OO mental space better than the functional mental space
15:11:11 <luqui> and vice versa
15:11:16 <luqui> so it's good for languages to have both
15:11:27 <eieiei> maybe I should learn about OO some day.
15:11:38 <integral> CLOS can be implemented in pure LISP, I thought?
15:11:41 <eieiei> but I program for pleasure, so.
15:12:05 <integral> eieiei: don't feel bad, I program in Perl for pleasure :-P
15:12:11 <luqui> well, the thing about OO is that the mathematicians haven't figured it out as well as functions
15:12:26 <luqui> so there's not as much rigor, and there's not as much higher-order-ness
15:13:39 <integral> OO seems much more ill-defined than functions too.  Smalltalk (72, and more modern), Java, Python and C++ are all rather different
15:14:33 <eieiei> I remember being a 12-year-old thinking I wrote OO programs because I used Visual Basic :)
15:15:09 <eieiei> I'm trying to pick up VB again, as I want to write Excel add-ins, but.. no higher-order functions. How am I supposed to work like that?
15:17:54 <luqui> VB man.  How are you supposed to work like that?
15:23:26 <sethk> eieiei, you are trying to pick up vb?  Not being forced to at gunpoint or something?
15:40:54 <SickJacken> VB aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaah
15:41:04 <SickJacken> thats more i can take today
15:48:40 <eieiei> sethk: I need to write MS-Excel extensions.
15:48:46 <eieiei> It's either VB, or, VB.
15:49:57 <sethk> eieiei, I figured as much.  :)
15:50:28 <Muad_Dibber> can you not use open office? :P
15:50:42 <eieiei> and be forced to use RealBASIC or whatever they use?
15:50:54 <eieiei> Besides, I want to write stuff that will be used in the financial world.
15:50:59 <Muad_Dibber> hehe
15:50:59 <eieiei> Excel is a must.
15:51:11 <Muad_Dibber> at least you can then say that you tried to get away from VB :P
15:51:20 <neadjneki> :)
15:51:38 <eieiei> I went away for half an hour because I went pick up my new glasses.
15:51:53 <eieiei> I'd been using the same glasses for 6 years. I can't believe how clear I see now.
15:52:30 <Muad_Dibber> thats the intention of glasses yeah?
15:54:59 <eieiei> is there any one-word way to say in Haskell what "cadr", "cadadr", etc. will say in Scheme?
15:55:47 <integral> those aren't in the standard prelude.  You'd probably use pattern matching,  and constructors in Haskell
16:00:55 <eieiei> this is very cool. http://www.cse.ogi.edu/S3S/PeytonJones.ppt
16:01:16 <eieiei> it's a presentation from Microsoft Research about making MS-Excel more Haskell-like.
16:01:51 <eieiei> ops.
16:01:57 <eieiei> this is the url. http://research.microsoft.com/~simonpj/papers/excel
16:07:56 <bourbaki> moin
16:12:31 <bourbaki> can anyone of you point me to a website with definitions for anamorphism catamorphism and so on?
16:13:03 <eieiei> you should start with isomorphisms :-P
16:13:18 <eieiei> try wikipedia, anyway.
16:13:36 <bourbaki> well i tried wikipedia but its not in there
16:13:51 <eieiei> An anamorphism is a distorted projection or perspective; especially an image distorted in such a way that it becomes visible only when viewed in a special manner.
16:13:54 <eieiei> there it is.
16:14:50 <bourbaki> hm
16:15:09 <eieiei> http://lair.xent.com/pipermail/fork/Week-of-Mon-20031020/026287.html
16:15:39 <bourbaki> thx
16:16:11 <eieiei> Most functional programmers are familiar with the notions of folding
16:16:11 <eieiei> (catamorphisms) and unfolding (anamorphisms). These concepts are the
16:16:11 <eieiei> rice and potatoes of every self-respecting functional programmer.
16:16:16 <eieiei> sorry for the three-line paste.
16:16:31 <bourbaki> cant i use the ana or catamorphism to build a limit for a circular subgraph that is fold a recursion?
16:16:39 <bourbaki> aha! :)
16:17:53 <eieiei> the message contains an interesting sub-message called "Visual Basic programmers love anamorphisms"
16:18:15 <bourbaki> oh heh ill have to check it out in a sec :) thanks a lot
16:21:16 <eieiei> strip club reopens in New Orleans' French Quarter.
16:22:01 <bourbaki> heh
17:01:59 <eieiei> omfg. there's a Cobol.net
17:05:13 <sethk> eieiei, there is still as much cobol code running as any language
17:06:54 <eieiei> I hear so.
17:07:12 <eieiei> But aren't those running in mainframes running arcane IBM OSes and so on?
17:07:55 <eieiei> "The COBOL 2002 standard includes support for object-oriented programming and other modern language features" o__O
17:10:38 <ptolomy> Odd. XChat stopped showing who is in the channel.
17:14:01 <SyntaxNinja> ptolomy: maybe you're alone
17:14:47 <ptolomy> SyntaxNinja, Damn. Then my hallucinations are uneventful.
17:18:49 <bourbaki> where can i find this paper?  Functional Programming with Banana
17:20:51 <eieiei> try scholar.google.com
17:20:57 <arjanb> http://research.microsoft.com/~emeijer/Papers/fpca91.pdf
17:21:26 <bourbaki> thanks
17:21:43 <eieiei> http://scholar.google.com/url?sa=U&q=http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps
17:21:45 <eieiei> there is is.
17:21:50 <eieiei> unctional Programming with Bananas, Lenses, Envelopes and Barbed Wire
17:41:49 <mwc> Everybody's jumping the Itanic. With everybody blaiming poor compilers for why these chips never really took off, I was wondering if maybe a language like Haskell or ML was what they needed
17:42:47 <mwc> Seems to me those languages allow the compiler to parallelize more, since there are large blocks of code with no side effects.
17:42:59 <mwc> Anybody smarter than me on the FP scene care to comment?
17:44:32 <sethk> mwc, not smarter in that area, more a logistical comment.  As a practical matter it doesn't matter because the supply of FP coders is too limited.
17:45:41 <sethk> mwc, I have terrible trouble trying to convince anyone to use any language not completely mainstream
17:46:37 <sethk> mwc, read that, c++ and java.
17:47:07 <sethk> mwc, also, the time it would take to build optimizers to take advantage of an architecture is longer than the lifetime of the architecture, certainly in this case.
17:48:16 <mwc> sethk: I'm still in university, so I'm lucky enough to use whatever gets the job done
17:48:45 <sethk> mwc, I hope this tunnel vision will not last forever.  It won't, but I mean I hope it won't last my entire working lifetime.
17:49:04 <sethk> mwc, of course, when I started almost everything was built in cobol or fortran, so I guess I shouldn't complain.  :)
17:49:06 <mwc> But I think the problem has always centered around compilers not being able to see enough ILP to generate 4 streams of ops
17:49:32 <mwc> Haha, I saw a cobol hello world once
17:49:36 <mwc> It was 40 lines
17:49:46 <mwc> BEGIN MODULE ; BEGIN PROCEDURES, etc.
17:51:39 <sethk> mwc, that is probably true, but I don't think (right now) that a perfect optimizer would make a difference.
17:52:07 <sethk> mwc, out here in the real world, unfortunately, decisions are usually made on such technical observations as "everybody else uses it."
17:52:33 <sethk> mwc, although my favorite is "if it was that bad, it wouldn't be in the language."
17:52:45 <sethk> mwc, even forgetting the grammatical problem.  :)
17:53:49 <mwc> Fair enough. I'm trying to justify taking 1.5 k out of my education trust to build an Opteron rig :)
17:54:30 <mwc> But I was thinking about the other CPUs in that arena
17:54:52 <sethk> mwc, definitely check them all out.  It would be interesting to do an unbiased evaluation including cost.
17:55:06 <sethk> so much of the data about processors comes from manufacturers
17:55:17 <sethk> much of the rest is superficial
17:55:39 <mwc> sethk: I'd love to see benchmarks for an FPL. Just for fun. Ocaml runs on Itanium and x86-64, right?
17:56:33 <sethk> mwc, I'm not a big ocaml fan.  I don't know.  The question is how hard it is to build.  Ocaml and haskell will run anywhere once you get them built.  :)
17:56:54 <sethk> you have to be careful with ocaml, though, because you can simply write imperative code with it.
17:57:05 <sethk> really bad imperative code, usually.
18:01:46 <mwc> Yeah, I kinda like SML to Ocaml
18:02:08 * mwc goes to beat himself with the iron mallet of grammar
18:04:28 <Lor> ocaml has some redeeming features such as polymorphic variants.
18:05:21 <mwc> I'm swayed by SML being a seemlingly more stable standard
18:05:30 <Lor> sml is definitely much prettier.
18:05:39 <Lor> And the standard basis is more comprehensive.
18:05:40 <mwc> That's what convinced me too
18:05:56 <mwc> Just look at some code and decide if I like how it reads
18:06:02 <Lor> Ocaml just has lots of nifty additional features.
18:06:07 <mwc> personally, Haskell is the prettiest
18:06:08 <Lor> I'm currently working on a new syntax for ocaml.
18:06:41 <ptolomy> Lor, What is different?
18:06:48 <sethk> Lor, there are parts of the imperative and especially object extensions to ocaml that I really dislike
18:06:58 <sethk> Lor, syntactically
18:07:20 <Lor> You mean defining objects and classes? Or method invocation?
18:08:03 <Lor> I very much dislike all the "(class|struct|sig|whatever) decl; decl; decl end" constructs.
18:08:06 <sethk> Lor, well, both, I think.
18:08:14 <sethk> Lor, yes, I agree
18:08:41 <Lor> Method invocation is just ob#method. Admittedly # isn't quite as pretty as . (or ->), but that's a minor quibble.
18:12:09 <orbitz> it seems that ML's and Erlang contain a lto of syntaxual similarites
18:14:15 <sethk> Lor, one symbol is the same as another on the invocation.  However, remember that there is no implied self.  To invoke a method from within another method, you have to use a name, and the name is arbitrary and selected during class definition.  What a mess that is.
18:15:26 <dave_m> sethk: Lots of other languages do it that way. Python and OOHaskell come to mind
18:15:41 <sethk> dave_m, true.  I don't like it there either.
18:16:06 <sethk> dave_m, but the point is that you shouldn't need the name at all.
18:16:08 <Lor> sethk, you think that having an explicitly named self variable is a bigger mess than having a magical implicit "self"-variable?
18:16:16 <sethk> Lor, absolutely
18:16:38 <sethk> Lor, unqualified names in ocaml have an implied context everywhere else
18:16:54 <sethk> Lor, the problem of course is that the implied context is "used up" already
18:17:03 <sethk> Lor, but that doesn't mean that the syntactical problem doesn't exist.
18:18:06 <Lor> So you'd like the method name to act like it were a variable in a module?
18:18:30 <Lor> (Btw, first-class modules do most of the stuff that objects are needed for)
18:19:08 <sethk> Lor, well, I would have to review the details of that.  But one big supposed advantage of oo is encapsulation.  Implied context goes along with encapsulation naturally.
18:19:48 <sethk> Lor, it's more of an issue with virtual functions and such
18:19:58 <Lor> Well yes, I see your point, kinda.
18:20:44 <Lor> Then again, you could always define let rec m1 = ... and m2 = ... in object method meth1 = m1 method meth2 = m2 end
18:20:55 <sethk> sure, you could.
18:21:22 <Lor> I agree that the object system feels like an unorthogonal hack.
18:21:27 <sethk> it is only those languages that have tacked on objects as an afterthought that use a name.
18:21:48 <sethk> Lor, that's a good way to put it.  It is an unorthogonal hack, so it's not surprising that it feels like one.
18:22:24 <Lor> Well, it's convenient for creating language bindings for OO-structured foreign libraries.
18:22:52 <sethk> Lor, yes, if it restricted to only that use...
18:23:47 <Lor> But yeah, if first-class modules can be used (and ocaml's "local modules" are essentially that, as they allow a struct to depend on term variables), they should probably be preferred.
18:24:58 <sethk> It seems more natural to me.
18:25:07 <eieiei> have you ever seen Lush?
18:25:14 <eieiei> It's apparently a Lisp variant meant for numerical code.
18:25:35 <eieiei> it changes the syntax in bizarre ways, though. define/defun became just "de".
18:26:12 <sethk> eieiei, well, that's in the spirit of lisp.  never use something comprehensible when something short and difficult to remember is available
18:26:48 <lispy_> nah, that's not true
18:26:58 <sethk> maybe a slight exagguration
18:26:59 <lispy_> lisp programs tend to have very long identifiers
18:27:09 <eieiei> lispy yeah, I still try to use dashes in function names in other languages.
18:27:09 <sethk> I meant the keywords
18:27:19 <lispy_> this-is-the-function-that-takes-two-args-and-creates-a-new-list
18:27:30 <orbitz> does haskell have arbitrary precise reals?
18:27:33 <orbitz> hi lispy
18:27:41 <lispy_> orbitz: it can
18:27:50 <lispy_> oh, wait, maybe just rationals
18:28:12 <eieiei> *Main> derivative (\x->x*x*x) 12 0.0000001
18:28:12 <eieiei> 431.99999709031545
18:28:18 <eieiei> looks pretty precise to me.
18:28:45 <orbitz> did you pass a function and get teh derivative?
18:28:57 <Cale> orbitz: not by default
18:29:08 <orbitz> Cale: is it a compile roptino of runtime?
18:29:12 <Cale> orbitz: though it has the Rational type
18:29:13 <orbitz> the port i'm using requires gmp
18:29:30 <orbitz> with waht eieiei just showed, could one use haskell much liek maple?
18:29:41 <mwc> Hahah, matlab maybe
18:30:01 <lispy_> orbitz: that's was just a numerical approximation not a symbolic computation
18:30:05 <eieiei> Maple is a symbolic manipulation package.
18:30:06 <Cale> That was just a double precision calculation, not arbitrary.
18:30:13 <eieiei> not a programming language.
18:30:16 <mwc> Yehah, probably used the 3 point rule
18:30:24 <Cale> You can use Haskell for symbolic computation, but it takes work
18:30:29 <mwc> eieiei: no, it has a programming language
18:30:38 <mwc> I think that Mathematica has a better language thought
18:30:42 <dave_m> Oleg posted some code a while back that did symbolic derivation
18:30:49 <lispy_> yeah, i think perl is a better language than
18:30:51 <dave_m> Let me see if I can pull that up
18:31:14 <eieiei> derivative func x h = (func (x+h) - func(x-h))/(2*h)
18:32:13 <eieiei> hey. why is that function so unstable numerically?
18:32:22 <eieiei> looky:
18:32:47 <eieiei> *Main> derivative (\x->2*x) 12 10e-15
18:32:47 <eieiei> 2.1316282072803006
18:32:58 <eieiei> then I go, "uh, lattice not small enough".
18:33:06 <eieiei> *Main> derivative (\x->2*x) 12 10e-18
18:33:06 <eieiei> 0.0
18:33:11 <eieiei> "Oh, geez".
18:33:16 <eieiei> *Main> derivative (\x->2*x) 12 10e-4
18:33:16 <eieiei> 1.9999999999988916
18:33:18 <lispy_> eieiei: that's the problem with floats
18:33:25 <mwc> eieiei: you're dividing by a quantity small to zero
18:33:37 <orbitz> what ist eh \ doing there?
18:33:39 <mwc> it causes ridiculous loss of precision
18:33:55 <lispy_> orbitz: that's how you create an anonymous function
18:34:00 <orbitz> oh
18:34:00 <lispy_> \x -> x + 1
18:34:05 <eieiei> it's the Haskell equivalent of "lambda".
18:34:18 <orbitz> sounds about right
18:34:19 <eieiei> in Lisp that would be (derivative (lambda (x) (* 2 x)) 10e-18)
18:34:38 <lispy_> it's a really nice notation
18:34:42 <mwc> I'd really hope that lambdabot is using a 5 point rule to evaluate these. If it's doing (f (x + h)) - (f x) / h, I'm gonna scream
18:34:47 <orbitz> i wa shoping it might pass the parsed expression liek a lisp macro
18:34:51 <lispy_> when you put the paren there it actually looks a bit like a lambad (\
18:35:08 <eieiei> what does the 5 point rule look like?
18:35:26 <orbitz> ghc is finally compiling, yaaay
18:35:38 <eieiei> lispy: jesus, I wish you hadn't said that. Now I'm obsessed about how it's not really like a lambda.
18:35:39 <Cale> lambdabot?
18:35:44 <lispy_> orbitz: congrats, now, sit back, wait 6 hours and you'll be ready to go
18:35:51 <orbitz> hah
18:36:01 <orbitz> lispy_: it might take longer, i'm doing make buildworld too
18:36:05 * eieiei ponders the wonders of Gentoo written in Haskell.
18:36:05 <lispy_> ah
18:36:09 <mwc> Google is failing me
18:36:17 <lispy_> orbitz: well, it takes 6 hours on my ibook to install from darwinports
18:36:18 <mwc> I have to go pull out my sophomore numerical textboot
18:36:33 <orbitz> hrm
18:36:42 <Cale> It would be nice if you could type  (Î»x -> 2*x)
18:36:45 <orbitz> i wonder if i can distcc freebsd ports isntalls magically
18:36:55 <eieiei> APLHaskell.
18:36:56 <orbitz> Cale: being able to type lambd aowuld be nice
18:37:07 <lispy_> Cale: i had an emacs mode that displayed "lambda" as the greek letter when using lisp mode
18:37:14 <sethk> eieiei, I like \x ->
18:37:26 <Cale> orbitz: Well, you can configure your keyboard such that it's easy -- Gnome in particular has a nice way to set that up
18:37:28 <sethk> or whomever
18:37:36 <Cale> Î±Î²Î³Î´Îµ :)
18:37:41 <eieiei> maybe we could get an "arrow" character too.
18:37:57 <eieiei> yes, yes, and special characters for "map" and "filter".
18:38:10 <Cale> lenses and bananas and such :)
18:38:17 <eieiei> * eeeeeeeevil laugh ***
18:38:26 <lispy_> you can still do a lot with just ascii tho, take ~> for instance
18:38:37 <eieiei> I like =>
18:38:53 * Cale thinks about typing Î· x instead of return x.
18:39:03 <lispy_> Cale: awesome :)
18:39:14 <eieiei> my girlfriend got me addicted to the ":~" emoticon.
18:39:25 <lispy_> nu has to be one of my fav. greek letters tho
18:39:26 <eieiei> :~ is a general-purpose, if saddish-tinted, emotion.
18:39:27 <eieiei> :~
18:39:33 <Cale> Î½?
18:39:43 <eieiei> my favorite greek letter is csi/xi.
18:39:52 <lispy_> yeah, although, it doesn't look very nice in my currnty fon
18:39:55 <Cale> Î½ is nu, Î· is eta.
18:40:20 <Cale> Î¾
18:40:33 <dons> Lemmih, dcoutts: ping
18:40:44 <eieiei> http://www.navarro.mus.br/diego/?p=141
18:41:41 <lispy_> haha, i haven't played ut2k4 in serveral months in part because the performance had been terrible.  I just installed an updated audio driver and performance is great again
18:42:02 <lispy_> so many missed months of game play :)
18:42:05 <Cale> Under gnome, in Preferences -> Keyboard, you can add a greek layout as non-default, and in Layout Options -> Group Shift/Lock behaviour, there's options to set up keys to swap back and forth
18:42:05 * dave_m finally locates Oleg's symbolic differentiation code
18:42:33 <lispy_> dave_m: omg, that's *so* 10 minutes ago
18:42:48 * dave_m hangs head in shame
18:42:49 <eieiei> I still want to see it.
18:42:59 <dave_m> http://article.gmane.org/gmane.comp.lang.haskell.general/10614/
18:43:11 <mwc> eieiei: the 5 point ule looks like this: f'(x0) = [ f(x0 - 2h) - 8f(x0 - h) + 8(x0 + h) - f(x0 + 2h)]/12h
18:43:30 <mwc> It has Order-4 convergence
18:43:31 <lispy_> interesting
18:43:57 <eieiei> mwc: hmm. nice.
18:44:08 <eieiei> haha, that message is written in such an academic style.
18:44:19 <eieiei> In this message, we develop the `symbolic' differentiator for a subset
18:44:19 <eieiei> of Haskell functions (which covers arithmetics and a bit of
18:44:19 <eieiei> trigonometry).
18:44:26 * eieiei is sorry.
18:44:27 <mwc> notice that it doesn't evaluate at x0, so it works even at point discontinuities
18:45:51 * mwc goes to do work
18:45:58 * eieiei goes rewrite his derivative function.
18:48:39 <eieiei> GHCI is quite a bit slower than Hugs.
18:49:07 <luqui> but it has ghc extensions :-)
18:49:25 <dons> quite a bit? I'm not sure if it is that much slower
18:49:43 <eieiei> the 5-point rule yields worse results than the 3-point rule at h=10e-4.
18:49:50 <orbitz> is ghci part of ghc?
18:49:58 <dave_m> yes
18:51:15 <dons> I imagine ghci will be much faster for code that uses a lot of libraries, as it gets to call compiled code. unlike hugs which has to interpret even the libs
18:52:00 <eieiei> *Main> threepointderivate (\x->2*x) 12000 10e-4
18:52:00 <eieiei> 2.0000000004074536
18:52:03 <orbitz> is ghci not a compiler?
18:52:06 <eieiei> but then, using the 5-point rule..
18:52:16 <eieiei> *Main> derivative (\x->2*x) 12000 10e-4
18:52:16 <eieiei> 1.9999999991947939
18:52:28 <luqui> ghci interprets
18:52:45 <dons> for much code hugs is fasster, but not a lot faster.
18:53:21 <eieiei> 3-point rule yields an error of 4.0745362639427185e-10
18:53:28 <orbitz> my algorithm analysis class lets us writ eh assignments in any language we want, i thought it would be a good reason to learn haskell and use it for taht
18:53:28 <dons> if you care about speed, use ghc
18:53:31 <eieiei> 5-point rule yields an error of 8.052061239993691e-10
18:58:28 <ptolomy> My, it is annoying when ghci and ghc yield different results.
18:59:29 <dons> that is due to using -fasm or -fvia-C
18:59:44 <dons> if you use -fasm with ghc, you'll get the same results as ghci
19:00:00 <dons> (fingers crossed)
19:00:23 <dave_m> What sort of different results are we talking about?
19:00:41 <dons> should be just some floating point differences, right?
19:01:22 <dave_m> What would cause that? Different numeric libraries?
19:01:52 <dons> difference code generators
19:02:03 <dons> one is compiling via gcc, the other generates its own assembly
19:03:06 <dave_m> I get that, but I don't see why they would come up with different results. Do C and assembly have different floating-point semantics?
19:03:54 <dons> different instructions get generated, with different handling of limit conditions. there's a descriptiong in the users guide of this problem
19:05:44 <dave_m> I guess we'd get the best numeric results by compiling to Fortran, then. :)
19:08:06 <dons> there's a flag that adds extra floating point precision, iirc, which is required for high end floating point programs
19:08:17 <dons> -fexcess-precision?
19:49:25 <orbitz> sweet mama why does this ghc take so long
19:51:01 <dons> it's thinking really hard
19:51:28 <dons> it has much more work to do than, say, gcc
19:53:25 <orbitz> why so?
19:53:42 <orbitz> gcc has to compile it's own broken dialect of lisp and then compiele itself, that sounds like a lot of work:)
19:55:06 <dons> huh? gcc has to compile C to asm, which I'm suggesting is easier than compiling lambda calculus with a static type system to asm
19:55:27 <dons> esp. since the phase C -> asm is actulally the final fast phase of ghc itself
19:55:50 <orbitz> i'm talking about compiling ghc
19:55:52 <orbitz> not compiling iwth it
19:56:04 <orbitz> bu ti guess ghc has to do that making itself
19:56:12 <orbitz> since a lot of stuf fis written in haskell  in it
19:56:17 <dons> oh, ghc takes a long time to compile because there are 500,000 lines of Haskell code, and Haskell code is hard to compile
19:57:20 <eieiei> how fast is ghc-compiled Haskell code compared to gcc-compiled C code?
19:57:35 <dons> usually a bit slower, sometimes faster
19:57:44 <dons> always better than java ;)
19:58:18 <orbitz> hehe
19:58:27 <orbitz> hrm
19:58:32 <sethk> dons, there is also compiled to machine language java, so that's not true in general
19:58:36 <orbitz> when peopel compare speeds to they just compare runtiem speeds?
19:58:47 <sethk> orbitz, depends on the people
19:58:55 <orbitz> it seems like comparing ratios of amount of development time/run time would be better
19:59:48 <dons> yep. haskell wins on those metrics
19:59:50 <sethk> orbitz, depends on what you care about.
20:01:02 <sethk> certainly from a cost perspective you have an excellent point
20:01:24 <sethk> sometimes even stronger from a time to market perspective
20:02:01 <orbitz> well i think it'd be a better metric since someoen can put lots of time into a C program and proabbly out perform a haskell one, but if someone puts the equivalent time in to teh haskell one they can probably ge ta lot closer, so you get a better idea of how much work it takes to achieve that
20:02:06 <sethk> but there are cases where execution speed is paramount.
20:02:43 <sethk> you might have a case where the hardware has a fixed level of performance and run time performance is more important than cost.
20:02:47 <Korollary> imho, ghc is not always faster than java
20:02:54 <orbitz> sethk: sure, but i dont' think those cases should really be considered when comparing langauges
20:03:09 <sethk> orbitz, if you are allowed only one metric, I would agree.
20:04:23 <sethk> Korollary, again, I suspect that it depends on some details.  Am I allowed to keep working on my Haskell program until I exceed the performance of the Java program?
20:05:21 <sethk> I've found that the quality of the programmer is vastly more important in Haskell than in something like Java.
20:06:10 <eieiei> Java sucks.
20:06:19 <eieiei> Even on my Mac mini, Java GUI apps are zzzzz
20:06:50 <Korollary> java gui complaints are common. java server side is not bashed as much, though.
20:07:11 <eieiei> In my mind, Java is subconsciously associated with "slow".
20:07:22 <dons> sethk, that's interesting. can you expand on that point?
20:07:24 <eieiei> That comes from the days of Java applets and the dreadful HotJava.
20:08:44 <eieiei> old VB programs that called vbrun300.dll were faster than trivial Java applets.
20:09:10 <Korollary> eieiei: do you have problems with eclipse as well ? that's in java, too.
20:09:12 <sethk> dons, It's somewhat based on unscientific ad hoc data.  I took some fairly simple problems, coded them in Java, C++, and Haskell.  I found that, within Java or within C++, you got roughly a 2 to 1 difference in execution speed between the most obvious implementation and a good implementation
20:09:24 <eieiei> I never tried Eclipse.
20:09:25 <sethk> dons, in Haskell, I found that the difference can easily be an order of magnitude or more.
20:09:57 <sethk> Korollary, the java plug in for eclipse is a remarkably good piece of work, but I wouldn't want to run it on a slow machine with not much memory.
20:09:58 <dons> high-speed aps in haskell certainly need a bit of guru in the developer
20:10:08 <sethk> dons, yes.
20:10:14 <dons> however, high-quality, non-crashing aps are within reach of everyone
20:10:28 <Korollary> space leaks are also within reach
20:10:35 <dons> hehe
20:10:43 <sethk> dons, I started with Euclids algorithm, which is of course perhaps the simplest recursive algorithm you could find.
20:11:00 <sethk> dons, I also did some "how long until the program works" tests.
20:11:26 <Korollary> sethk: have you tried writing any of the programs at the language shootout site ?
20:11:53 <sethk> Korollary, no, not yet.
20:12:04 <sethk> Korollary, what I did was as I said not terribly systematic.
20:12:27 <Korollary> sethk: not much of this is systematic until we start churning full blown haskell apps
20:12:40 <sethk> For a simple insertion short, Haskell of course had a working program far faster than the others that I tested
20:12:51 <sethk> which were c++, java, and ruby
20:13:02 <sethk> ruby came in second, but took about 4X as long to work.
20:13:03 <Korollary> sethk: but I got obsessed with one of them, and wrote it in ocaml, haskell & c++.
20:13:12 <sethk> but of course that may well be a factor of the coder.
20:13:18 <sethk> Korollary, what results did you get?
20:13:49 <Korollary> sethk: ocaml was within 20% of c++. haskell was about 10x slower.
20:14:07 <Korollary> of course, I am not a haskell guru
20:14:12 <sethk> Korollary, I wasn't really looking for compative execution speed, though.  I was looking for the delta of a well written program and a poorly written one.
20:14:23 <sethk> s/compative/comparative/
20:14:25 <dons> though I always dispute that haskell has to be slower. it's just a matter of low-level IO haskell work
20:14:49 <humasect> =(
20:14:51 <Korollary> dons: yeah i/o is slow, although that benchmark did no i/o.
20:14:59 <sethk> dons, quite possibly.  I haven't done low level profiling.
20:15:05 <eieiei> why is OCaml so fast?
20:15:10 <sethk> Korollary, it would be great to profile the implementations
20:15:16 <dons> i/o isn't slow, just normal i/o. use packed strings with mmap for good io
20:15:18 <Korollary> eieiei: the implementation was 100% imperative.
20:15:33 <eieiei> interesting.
20:15:36 <sethk> eieiei, he said ocaml was 10% faster, more or less (he actually said haskell was 10% slower, which is slighly different)
20:15:46 <Korollary> I said 10x slower
20:15:50 <Korollary> not 10% heh
20:15:51 <sethk> ah, 10 times
20:16:02 * sethk cleans his trifocals
20:16:32 <Cale> meh, it's just a constant factor :)
20:16:34 <eieiei> trifocals?
20:16:46 <sethk> eieiei, what us old folks need to read
20:16:51 <Korollary> if I can find time, I'd like to rewrite the ocaml version in a more functional style, and bang on the haskell implementation a bit more.
20:16:54 <humasect> 10x is a lot of times.
20:16:58 <eieiei> my dad has "multifocals".
20:17:08 <eieiei> I just have big time myopia and light hypersensitivity.
20:17:23 <sethk> humasect, but remember my result, which was an order of magnitude of difference between a poorly coded program and a well coded program.
20:17:35 <sethk> Not that I'm implying that Korollary's program was poorly coded.  :)
20:17:45 <sethk> Since I haven't even seen it, that would be dumb.
20:17:54 <humasect> true.. human time is kind of precious. not to say that haskell can't be optimised and stay haskell.
20:18:16 <Korollary> sethk: mine was the somewhat advanced haskell version using mutable arrays. The pure version was 20x slower.
20:19:04 <Korollary> I picked it precisely because it was so much slower than c/ocaml
20:19:07 <sethk> humasect, my results don't necessarily imply that more human time is always needed.  It might be the case that once a finite set of guidlines are followed, the haskell program will be near optimized
20:19:23 <sethk> humasect, in other words, it might just indicate a longer learning curve
20:19:33 <humasect> hm i see that
20:19:57 <humasect> a lot of ocaml can translate directly to C by just changing syntax, too
20:20:00 <sethk> humasect, I suspect that's the case, at least for a large part of my results.
20:20:20 <sethk> humasect, yes, but then you are using ocaml as a brain dead imperative language.
20:20:25 <sethk> humasect, might as well just use c
20:20:33 <humasect> yeah =)
20:20:41 <Korollary> sethk: imperative ocaml is better than c imho :)
20:21:19 <sethk> Korollary, possibly.  I haven't studied ocaml anywhere near enough to have a worthwhile opinion about that.
20:21:36 <humasect> it makes one wonder why the ocaml FFI is actually requires more maintenance/setup thank haskell ffi. it could just #include and be done with it..
20:21:44 <sethk> Korollary, the imperative code is seriously ugly, though.  (which is I realize completely subjective and probably irrelevant)
20:21:59 <Korollary> sethk: ocaml syntax is pretty ugly compared to haskell's
20:22:17 <humasect> engineThread :: MVar ThreadId
20:22:17 <humasect> engineThread = unsafePerformIO $ newEmptyMVar
20:23:25 <sethk> Korollary, I think so.  But then, I think having where instead of having to always use let ... in is a great feature, and nobody else I've ever talked to thinks it makes any difference at all.
20:23:53 <sethk> humasect, if that's relevant to the conversation, then I'm completely lost.  :)
20:24:26 <Korollary> sethk: ocaml's let...in is ugly as well. You have to type "and" between them. blah.
20:24:49 <sethk> Korollary, I'll look.  I didn't notice that.
20:24:55 <humasect> an accident, sorry ^_^ ocaml needing so /many/ lets is where it gets spammy. also begin/end.
20:25:10 <humasect> ocaml with indent syntax wouldn't be so bad, then.
20:25:53 <sethk> when I read the let ... in style, I think  I don't know why I need this, and I don't know why I need this, and ... and now I can't make sense of the function without going back and reading each let as I encounter the value in the function body
20:26:40 <dons> hmm. gtk2hs is really nice. I'm going to focus Yi development on a gtk version now
20:26:57 <dons> I think this could really move Yi along a bit
20:27:01 <humasect> i'm not sure if developed haskell apps had a real chance for being optimised, including ray tracers
20:27:14 <dons> as I don't have to rewrite all the low-level buffer and window handling
20:27:33 <dons> anyone have any opinions regarding Yi+gtk?
20:27:36 <humasect> i believe gtk has a console backend as well, somewhere.
20:27:51 <dons> oh! that would make my life much easier
20:28:06 <Korollary> Yi + gtk for president
20:28:10 <dons> so I'm looking to produce a Yi that looks roughly like the gtk-based gvim
20:28:27 <humasect> excellent
20:28:33 <sethk> dons, I have to look at gtk again; I'm told it is much better than the last time I decided I didn't like it.
20:28:53 <sethk> dons, you are going to ignite the emacs vs. gvim argument again.   :)
20:29:17 <dons> no no. it may look like gvim, but you get both emacs and vim keybindings still
20:29:39 <sethk> dons, ok.  I wasn't being serious.  :)
20:29:41 * humasect starts to wonder how the vim haskell mode is, compared to his current use of emacs haskell mode
20:29:42 <dons> the one editor to rule them all, remember ;)
20:30:04 <dons> vim haskell mode provides excellent syn hl, no indent support
20:30:33 <dons> i have a collection of haskell vim scripts if you're interested
20:30:39 <humasect> okay, i'm already using manual indent in emacs anyway. (2 spaces)
20:30:54 <sethk> humasect, why?  why not use auto indent?
20:31:04 <Korollary> it gets confused
20:31:09 <Korollary> I manually indent, too
20:31:14 <humasect> i have widescreen, but not to have emacs full screen =
20:31:37 <humasect> if you change function names or anything, you have to reindent
20:32:07 <sethk> humasect, indent-region.
20:32:14 <humasect> i'd like to set it to 2 spaces only, but it uses the previous statement alignment, which doesn't effect anything but visual appearance
20:32:24 <sethk> humasect, ok, that's a better reason
20:32:57 <humasect> i tend to use a lot of w@(Something { x = y; }) in definitions and such too, which doesn't help things
20:33:20 <sethk> the ocaml channel here rarely has activity.  The folks there hang around waiting to insult someone.
20:33:45 <humasect> that's a good measurement of productivity
20:33:47 <Korollary> I cant understand why #ocaml is so dead
20:35:26 <humasect> one could also say that C/ocaml/c++ is too fast.
20:35:31 <sethk> maybe the "real" irc channel is on another server
20:36:02 <Korollary> humasect: I wouldn't say too fast. I'd say too unsafe, maybe.
20:37:14 <humasect> performing programmers start feeling an urge to "add" to their application
20:37:28 <humasect> maybe.
20:38:01 <sethk> humasect, one could say that ocaml is faster because elephants are grey.  That's a true statement, at least extrinsically.  Elephants _are_ grey.
20:39:09 <humasect> i still don't have a malleable issue with writing haskell programs who depend on performance
20:40:14 <sethk> humasect, what do you mean by that?
20:40:25 <sethk> malleable means changeable, no?
20:50:26 <dons> humasect, can you explain what you mean?
20:52:10 <stepcut> greetings, dons!
20:52:42 <dons> hey stepcut
20:53:37 <stepcut> how is h4sh doing these days?
20:54:59 <dons> well, i've released v0.1 and it will be stable like that for a while
20:56:03 <stepcut> cool
20:56:05 <humasect> sorry, back. i'm working on a project with haskell that demands performance, but i have hopes that somehow haskell won't impede it's requirements
20:56:11 <orbitz> the common example of succinct haskell is the qsort (generally comparing it to another language).  but the qsort given isn't close to what one would really use, so does a real implementation look so nice?
20:57:18 <dons> humasect, i wouldn't worry too much. i haven't found a performance issue yet that couldn't be solved by profiling and thinking
20:57:36 <humasect> excellent, that is nice to hear =)
21:07:04 <sethk> to let me be lazy, how do you get ghc (compiled, not ghci) to dump out the types of what it compiles?
21:08:02 <dons> the types of what it compiles?
21:09:42 <humasect> oh hs-plugins is beautiful'
21:10:19 <dons> thankyou, but why do you say so?
21:11:08 <humasect> sentimentally, it contains everything i most obviously found strangely missing from base
21:11:48 <dons> hs-plugins does? really -- you missed dynamic loading and runtime eval?
21:11:52 <humasect> i'm going to have my way with it
21:11:58 <humasect> yes
21:12:07 <dons> heh. ok.
21:12:35 <humasect> it will be great because i am doing some unconventional things with ghci
21:12:49 <humasect> with FFI sprinkled around
21:13:21 <dons> ok. cool. you might want to look at hs-plugins/tests/plugs/* for example interpreter-like apps implemented using runtime eval
21:13:35 <humasect> cool, ok
21:14:06 <sethk> dons, I remember being able to get a listing of the inferred types from the compiler
21:14:07 <humasect> hm could not find Language.Haskell.Hsx ?
21:16:24 <dons> humasect, grab the darcs repo. you don't need Hsx anymore
21:16:34 <humasect> kk.
21:16:36 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/hs-plugins
21:17:26 <humasect> with examples/plugs/* it doesn't seem like i will be restricted with ghci anymore. hooray =)
21:17:42 <dons> this is how @eval is implemented, btw
21:17:50 <dons> @eval map (+1) [1..10]
21:17:51 <humasect> :o
21:17:55 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
21:17:57 <humasect> and hs-plugins is your baby?
21:18:02 <humasect> (one of them)
21:18:04 <dons> yep :)
21:18:29 <humasect> cool =) very good job. it /has/ to make its way into base for sure.
21:18:55 <dons> oh, I don't know. perhaps language support for dynamic loading should be in Haskell 2
21:19:07 <humasect> Haskell... 2k?
21:20:35 <dons> I think Cabal makes the need to move things into the base package much less than it used to be
21:21:22 <stepcut> dons: indeed, though cabal-get will make it even nicer -- as hunting down, building, and installing all the stuff is a pain
21:21:27 <humasect> it does, but..
21:21:45 <dons> right, cabal-get is even better
21:22:18 <humasect> oh, cabal-get would solve not knowing something as hs-plugins exists. i used to think it was ... plugins for hs. not plugin support for hs itself.
21:22:49 <dons> oh. maybe i should have picked a better name
21:22:59 <humasect> rename to donscow-ext and all problems disappear
21:23:05 <dons> "The Haskell Dynamic Linking Library"
21:23:27 <dons> I just wanted to have -package plugins on the command line, that was the main motiviation for the name
21:23:33 <humasect> something about dynamic haskell for sure
21:24:12 <humasect> ah
21:26:27 <humasect> CHG - controlling/controlled haskell goodies  (reverse)
21:34:33 <humasect> it exposes things that are ususally internal to ghc command, --make, --interactive, etc. which further moves in the direction of componentized ghc
22:55:00 <orbitz> hello
23:01:42 <lispy_> is there a free implementation of the adobe print to pdf thingy like you can get for windows by paying adobe $$$?
23:02:12 <dons> acroread?
23:02:19 <orbitz> as in being able to print a file to a .pdf rather than printer?
23:02:22 <dons> tex?
23:03:08 <dons> i use pdfs all the time an never need to use adobe anythings.
23:03:23 <dons> lispy, what are you trying to do?
23:03:31 <ibid> lispy_: what kind of a file do you want to convert to pdf?
23:03:34 <orbitz> is the simple defintion of someething liek qsort in Haskell what one would use in a real application or is it meant purly for demonstrative purposes?
23:03:52 <ibid> lispy_: or are you looking for a generic "print to pdf"?  i doubt something like that exists
23:04:12 <orbitz> Word.app does print to pdf, as does open office
23:04:25 <dons> orbitz,  it's much the same as the real version
23:04:27 <ibid> yeah, but those aren't generic
23:05:12 <Korollary> lispy_: you can download the generic postscript printer windows driver from adobe, and then print to a file. you can then convert that ps file into pdf.
23:05:15 <ibid> orbitz: it has some deficiencies, so i'd write it slightly differently for real use, but the simple definition is simple dynamite in terms of understanding the idea
23:05:21 <orbitz> dons: with all the filtering and appending, isn't a lot of copyign going on?
23:05:37 <dons> the library sort uses mergesort, but it is still only 5 or so lines
23:05:45 <orbitz> wow
23:05:50 <ibid> orbitz: there's bound to be a lot of copying in a purely functional language
23:06:08 <dons> we don't like destructive updates!
23:06:12 <ibid> yeah, merge sort works better than quicksort in a purely functional setting
23:06:45 <orbitz> would something liek 'insertion sort' be fairly terrible in a purely functional language?
23:08:05 <ibid> depends on what data structure you're using to represent the sequence
23:08:28 <ibid> but it wouldn't be my first choice :)
23:08:43 <orbitz> what sort of data structure would resul tin less copying?
23:09:34 <Korollary> mutable arrays, mwahah ;)
23:10:40 <ibid> orbitz: you're too focused in avoiding copying
23:10:46 <ibid> orbitz: there are also other things that matter
23:10:57 <dons> copying of what, pointers?
23:11:08 <humasect> what is hs-plugins cabal name?
23:11:10 <dons> rearranging pointers isn't too costly
23:11:15 <dons> 'plugins'
23:11:19 <humasect> ok
23:11:20 <ibid> orbitz: i was actually thinking about a rope-style data structure
23:11:46 <Korollary> if it doesn't have to lazy, then I think it's possible to have an array based qsort implementation that converts the result into a list at the end and looks pure.
23:11:52 <Korollary> +be+
23:11:53 <orbitz> well i'm not relaly, it's just one metric i'm lookign at i suppose.  i guess thr eal question is: does having to copy data around mean that various algorithsm cannot be equal in terms of performance to a language that has side effects?
23:12:32 <dons> no. it's only ptrs that get copied anyway
23:12:35 <ibid> orbitz: if you're really interested in this, i suggest reading okasaki's data structure book
23:12:44 <orbitz> are there any haskell book online by teh way?  Something equivalent to Programming In SML possibly
23:13:08 <orbitz> ibid: i think i should learn haskell first
23:13:25 <orbitz> i've mentioend hti sbefore, but i plan to use it to implemenat all the algorithms we need ot do in my algorithm analysis class
23:14:27 <ibid> orbitz: it is likely that some algorithms and data structures stuff can only be done efficiently in imperative style (but then again, there are data structures that are impossible in imperative style but possible in a functional style)
23:14:55 <ibid> orbitz: if your teacher doesn't teach you data structures in haskell, i'd avise against it
23:14:56 <Korollary> ibid: which data structures are not possible in an imperative setting ?
23:15:06 <orbitz> ibid: why so?
23:15:42 <ibid> orbitz: some of the stuff traditionally taught in an imperative data structures course is impossible or at least unidiomatic in a functional language
23:16:00 <orbitz> ibid: hrm, i think i'll be ok as far as i can see, i mostly program in Erlang
23:16:07 <ibid> orbitz: btw, the okasaki book uses sml as the language (haskell versions are given in an appendix)
23:16:17 <orbitz> ok
23:16:30 <ibid> Korollary: for example, a list of all primes
23:17:02 <orbitz> not all functional languages can do taht thouhg
23:17:07 <orbitz> just lazy evaluations ones, right?
23:17:08 <ibid> orbitz: btw, there's an algorithms and data structures textbook for haskell, too
23:17:14 <ibid> orbitz: right
23:17:23 <orbitz> i can't do a list of all primes in Erlang atleast
23:17:29 <ibid> orbitz: some people would claim that those are the only functional ones ;)
23:17:32 <Korollary> ibid: how is "list of all primes" a distinct data structure ?
23:17:35 <orbitz> ibid: ah
23:17:53 <orbitz> ibid: do you hav eany haskell books in pdf form online?
23:17:57 * orbitz checks haskell webiste
23:18:08 <ibid> Korollary: define "distinct data structure".  if you want, i can revise that to "regular infinite trees", if you want
23:18:10 <Korollary> orbitz: google for "yet another haskell tutorial".
23:18:31 <Korollary> ibid: by that I meant: how different is that from just a list ?
23:18:39 <ibid> orbitz: my lecture notes from two years ago are online (but they're in finnish)
23:19:14 <ibid> Korollary: your question is ambiguous. define "list".  (do you mean haskell's list concept, or linked lists, or ...)
23:19:19 <orbitz> ibid: i'm a monolingual american unfortunatly
23:19:53 <orbitz> anyways, i am quite tired, thanks for the input, good night ibid
23:20:12 <ibid> Korollary: point being that there are several related but distinct concepts that are all called "list"
23:20:29 <ibid> Korollary: one of them certainly includes my "list of primes"
23:20:39 <ibid> orbitz: i just woke up three hours ago ;)
23:21:00 <ibid> Korollary: but not all of them
23:23:18 <Korollary> ibid: Would a list of all zeroes constitute a separate data structure by your definition ?
23:23:56 <ibid> does that matter?
23:24:07 <Korollary> it's a yes or no question
23:24:23 <ibid> it's a yes or no question that cannot be answered
23:24:43 <ibid> like "have you already stopped beating your wife", but in a different way
23:25:36 <ibid> when one says "data structure", one can mean either a specific structure containing data (in which case it's "yes"), or a template for one (in which case i'd say "no")
23:26:38 <ibid> anyway, this terminology game has no bearing on the actual issue :)
23:27:58 <ibid> which is the difference between imperative and lazy-functional programming
23:28:14 <Korollary> there's only one list of all prime numbers. Can it still be a template ?
23:28:47 <ibid> it's not a template
23:28:56 <ibid> it's a specific data structure
23:29:04 <ibid> abstract one, i'd say even
23:29:11 <Korollary> so it is like a list of all zeroes (both yes and no).
23:30:07 <ibid> and?
23:30:44 <Korollary> then, a list of all zeroes and a list of all primes are both data structures by your terminology ?
23:31:15 <ibid> they aren't in yours?
23:31:55 <Korollary> well, no. In my view they are just two lists, filled with different contents.
23:32:08 <ibid> and lists are not data structures?
23:32:13 <Korollary> lists are
23:32:33 <ibid> so, a list is a data structure, but a list filled with zeros is not?
23:32:37 <Korollary> right
23:32:46 <ibid> whatever
23:45:36 <humasect> Build-Depends:		plugins readline          <-- parse error
23:47:32 <dons> there should be a comma after pluugins
23:47:36 <dons> whose code is this?
23:48:04 <humasect> okay, it didn't need a comma in Extensions or others
23:48:37 <humasect> humasect's code
23:49:06 <lispy_> Korollary: ah, that might work
23:49:33 <lispy_> Korollary: now i wonder if there is an automatable way to do the ps -> pdf part :)
23:50:22 <humasect> still getting undefined refs to readline and add_history, also after adding readline to extra-libraries:. (from libHSreadline)
23:53:26 <dons> yay. new wireless card, custom kernel tweak, and the card is in business!
