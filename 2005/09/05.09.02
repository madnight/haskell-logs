00:08:19 <joelk> newsham, it occurs to me that suit does matter with partial hands, because it affects the outs. The question remains whether that can be put into a simple order.
00:10:16 <newsham> yes, suits hahve a big effect on implied odds
00:12:36 <astrolabe> Would a partial hand containing a straight but with a gap count as trash, or some other type?
00:13:17 <newsham> its trashh at the moment but with outs (usually 4, depending on if you see others withh one of your outs)
00:14:44 <astrolabe> but if you are giving types to subhands, what would it be?  or am I misunderstanding?
00:15:15 <newsham> if you're just ranking hands its a trash hand
00:15:48 <astrolabe> Ah, thanks.
00:19:09 <astrolabe> The Ord class is for totally ordered data types
00:20:10 <newsham> reguardless that distinction is rather academic to me ;)
00:21:18 <newsham> can I do somethihng akin to   data Trash = ATrash Card | ATrash Card Card | ...   ?
00:22:12 <newsham> ahh.. ATrash1, ATrash2 ...
00:26:00 <ulfdoz> re
00:27:36 <shapr> yow!
00:30:06 <lispy_> newsham: no
00:30:22 <lispy_> newsham: youd have to make each "ATrash" unique
00:30:40 <lispy_> data Trash = Trash1 Card | Trash2 Card Card | ...
00:30:46 <lispy_> newsham: oh,  you figured that out tho
00:30:49 <lispy_> geez, i'm slow
00:31:11 <lispy_> newsham: but, wouldn't you be happier with data Trash = Trash [Card]
00:32:37 <newsham> i dont know.  that implies that there can be an infinite length of cards.
00:32:43 <newsham> when i only want from one to five cards.
00:32:48 <newsham> but perhaps thats what I should use
00:33:44 <joelk> what about 7 card games?
00:34:35 <newsham> in 7 card games you pick the best 5 card hand out of your 7 cards
00:35:02 <joelk> but you need a 6 card partial, don' t you?
00:35:23 <newsham> no, you have a large number of partial 5-card hands.
00:35:28 <joelk> ah
00:36:01 <newsham> (thhere's also a 9card game called omaha but in that you still make a 5 card hand out of a restricted subset of some of your cards and some common cards)
00:36:03 <joelk> or, perhaps a larger number of partial 4 card hands would make sense
00:36:22 <newsham> thhats whhat i meant.. a partial (ie. not all 5 cards) 5-card hand.
00:37:47 <humasect> where > let ?
00:38:55 <newsham> ?
00:41:23 <astrolabe> What is the purpose of having types for sub-hands?
00:42:32 <newsham> mostly to decompose the problem.
00:42:53 <newsham> this may not be the best way to do thhings.. i'm learning hahskell.  i'm open to advise :)
00:45:36 <astrolabe> I'm not expert, but these types don't seem a very good fit to the problem to me.  For instance, you would have to decompose some other way for >5 cards, and some subhands could lead to straights or flushes etc.  I have no better suggestions though :)
00:53:19 <newsham> http://www.lava.net/~newsham/x/poker.hs -- this is what i had in mind
00:53:21 <newsham> its not complete yet
00:53:28 <astrolabe> A very hard problem to do well I think.  Still I should be at work, sorry, bye.
00:53:52 <newsham> yah, to do it efficiently can be tricky and I'm not that interested
00:54:06 <newsham> i would rather have code that is good haskell (first) and reads well (second)
00:54:38 <newsham> i welcome feedback
01:06:09 <earthy> um?
01:06:23 <earthy> weird. I'd rather have code that reads well first
01:06:52 <newsham> i'm learning haskell.
01:07:03 <newsham> purpose #1
01:07:29 <wilx> Hmm, usually you should write code that looks nice/is readable.
01:08:23 <newsham> I could write clean code that reads like how I would code it in python but I wouldn't learn much about haskell that way
01:14:06 <newsham> thanks for the help.  enough for tonight
01:31:16 <humasect> ^_^
01:34:24 <Cale> humasect: you were wondering about where and let?
01:35:24 <Cale> humasect: the difference is where they occur in the Haskell syntax: where is part of the declaration of a function/value, whereas (let ... in ...) is an expression.
01:35:40 <Cale> one interesting thing to note is that where scopes over guards
01:35:46 <Cale> so if you have
01:35:51 <Cale> f x | x < 0 = ...
01:36:00 <Cale>     | x >= 0 = ...
01:36:08 <Cale>   where y = ...
01:36:20 <humasect> oohh cool
01:36:21 <Cale> you can use y in both of the first two lines
01:37:16 <humasect> is let .. "in" optional? it almost seems so, or does it just make one expression with the let and the expression after 'in'?
01:38:30 <earthy> let x = 12 in x    is one expression
01:38:48 <humasect> kk
01:38:57 <Cale> the "in" is optional in the do-notation
01:39:29 <earthy> um
01:39:31 <earthy> no. ;)
01:39:44 <earthy> it then means something slightly different
01:39:44 <humasect> o_o
01:39:48 <Cale> (it's not really the same syntax there)
01:40:07 <Cale> yeah, it is something different :)
01:40:44 <humasect> i've been mostly using lets within monad
01:40:50 <Cale> well, it's sort of like all the lines after the let are wrapped in a do-block and stuck in the "in" part
01:40:53 <humasect> or only. lots of where
01:41:11 <humasect> ah k
01:41:33 <humasect> it certainly feels about that different=)
01:49:48 <humasect> i'm getting some strange problems with Word32 and fromIntegral
01:49:52 <humasect> precision
01:57:24 <Cale> humasect: what's going on?
02:19:54 <humasect> woo all fixed ^_^
02:33:35 <humasect> i think i am having troubles with monad state
03:10:30 <z0d> good day
03:11:11 <genneth> gooday skip
03:11:12 <ndm> hello z0d
03:11:17 <z0d> hi ndm
03:13:52 <genneth> anyone here familiar with postgres?
03:14:07 <shapr> I've used it a bit.
03:14:35 <genneth> should have guessed you did :-p
03:15:19 <genneth> ever felt an itch to get it to support haskell data types, so that haskelldb can be a little more natural?
03:32:31 <ski> hm .. does god live in IO ?
03:33:24 <Lor> God made sure that when each sparrow falls, its flesh will be reclaimed...
03:34:58 <genneth> if that's not one for the quotes page, i don't know what is
03:35:52 <ski> ...by the garbage collector, after the finalizer has done its job
03:37:17 <Lor> genneth, it's not mine.
03:37:29 <Lor> It's the greatest programming song ever.
03:39:08 <ski> not "God Wrote The World In Lisp", no ?
03:39:39 <Lor> Yep.
03:39:49 <Lor> It's just beautiful.
03:40:06 <ski> :)
03:40:16 <ski> ">> This would make the :-mutable declarations more generally accessible."
03:40:23 <ski> "> We don't want `mutable' declarations to be generally accessible, for they are an abomination in the sight of God. Albeit sometimes necessary."
03:40:26 <ski> "They are only an abomination in the sight of God because God feels left out of the picture because he lives in the I/O state :-)"
03:40:53 <sieni> And I've got the last 5 lines of His Source Code:
03:40:53 <sieni> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
03:40:53 <sieni> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
03:40:53 <sieni> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
03:40:53 <sieni> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
03:40:55 <sieni> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
03:41:13 <ski> sieni : haha :)
03:44:48 <sylvan> lol
03:45:29 <Lor> Not to be a spoilsport, but that's a pretty old one: http://www.netfunny.com/rhf/jokes/90q2/lispcode.html
03:46:16 <Lor> ski, was that quote related to what? mercury?
03:46:59 <ski> yes (it's takes straight from mailing list)
03:47:56 <ski> (s/takes/taken/)
03:48:35 * boegel boings
03:48:47 <Itkovian> hi all
03:52:41 <shapr> genneth: Seen SerTH and HsWebForms?
04:04:07 <boegel> @seen xerox
04:04:08 <lambdabot> xerox is in #haskell. Last spoke 10 hours, 45 minutes and 14 seconds
04:04:08 <lambdabot> ago.
04:04:26 <boegel> he's really catching up with sleep, is he ? :)
04:45:55 <genneth> shapr: nope... have now. interesting...
04:46:21 <genneth> may not cut it for what i have in mind, however
04:47:48 <xerox> boegel: yeah :-D
04:51:57 <boegel> xerox: how's the L-system stuff ?
04:53:57 <boegel> any people good with recognizing planets in here ?
04:58:22 <xerox> Check the blog!
05:02:48 <Itkovian> hi xerox
05:02:55 <Itkovian> I am ill today ... so ...
05:03:06 <xerox> Itkovian: aww!  Did you see the blog?
05:03:12 <Itkovian> nope.
05:03:15 <Itkovian> url?
05:03:28 <xerox> http://haskell.org/gtk2hs/archives/category/cairo
05:08:00 <Itkovian> xerox: nice
05:08:44 <xerox> ^_^
05:21:47 <boegel> can anyone help me with this: http://elis.ugent.be/~kehoste/whatisthis.png
05:22:12 <boegel> it's for some contest, I'm supposed to link a country to this, but I have _no_ clue what it is
05:22:22 <boegel> any hint is welcome ^_^
05:22:41 <boegel> I know the scan is kinda sucky, but I can't help it :)
05:22:54 <ndm> looks a bit like an old telephone
05:22:59 <xerox> One of those things that transmit messages via cable?
05:23:06 <xerox> Something pretty old, yep..
05:24:17 <boegel> yeah, it's pretty old.... the others answers I have (in the same series) are tasmanian devil (tasmania), maagdenburgse bollen (germany), hafnium (denmark) and the hobbit skull (indonesia)
05:25:31 <xerox> @docs System.Random
05:25:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
05:29:20 <boegel> anyone ? :(
05:29:34 <boegel> is there a better channel to ask this kinda thing on freenode ?
05:30:40 <resiak> boegel: When do you need the answer by?
05:31:23 <boegel> asap, the contest ends on Sunday, but I need to solve some more stuff (including a sudoku)
05:31:34 <resiak> boegel: Use poetix's Haskell Sudoku solver!
05:31:57 <poetix> Aha, I see my arrival is timely!
05:32:31 <xerox> poetix!
05:34:01 <boegel> resiak: I need more answers first, I need the answers to various question for filling in some numbers in the sudoku, otherwise there's no way I'll be able to solve it
05:34:09 <resiak> Oh, I see.
05:39:23 <boegel> resiak: why ? do you know a way to figure out what it is ?
05:39:35 <resiak> boegel: I'm putting it on my LJ :)
05:39:58 <boegel> LJ ?
05:40:02 <ndm> boegel: Use a better sudoko solver, http://www-users.cs.york.ac.uk/~shackell/sudoku/Sudoku.html - not haskell but online
05:40:04 <ndm> livejournal
05:40:23 <ndm> www.livejournal.com
05:41:05 <beelsebob_> ndm: does that just brute force it?
05:41:15 <beelsebob_> or does it solve it properly?
05:41:18 <ndm> nope, its very clever
05:41:21 <ndm> arc consistency
05:41:28 <beelsebob_> cool
05:41:36 <ndm> in most puzzels it doesn't even have to backtrack once
05:41:37 <resiak> boegel: (in the vague hope that someone I know can help.)
05:41:46 <ndm> the source is on the web as well
05:41:50 <boegel> it generates a solution, but who says that's the solution I need :) with the numbers I have now, there are probably several solutions to it
05:42:07 <xerox> boegel: you could try to generate every possible solution, heh
05:42:16 <ndm> the C one if run locally will generate every solution
05:42:28 <ndm> with the appropriate flags or somehting
05:42:52 <boegel> resiak: link to your LJ?
05:43:22 <boegel> oh, found it, nvm :)
05:43:29 * boegel refreshes ! :p
05:43:42 <xerox> Url?
05:43:51 <boegel> xerox: http://www.livejournal.com/users/resiak/
05:44:22 <resiak> boegel: Funny that :)
05:44:37 <resiak> It's not of much interest to those who don't know me.
06:04:04 <genneth> any one mind if i start a page on hawiki about a crazy idea i have?
06:05:49 <boegel> genneth: no, that's why hawiki is there ! I've created pages too for projects I'll never finish :)
06:06:18 <genneth> cool
06:06:21 <genneth> :-D
06:16:29 <boegel> genneth: be sure to show us where you added it
06:16:34 <genneth> :-p
06:16:51 <genneth> it about a database interface
06:17:19 <genneth> the sort of thing that seems so good after a 12 hour stint with databases
06:25:58 <poetix> hsMySql?
06:26:51 <poetix> I just grabbed some API docs for libobby
06:27:36 <poetix> I want to have a go at creating a generic C API for it
06:27:47 <poetix> Then writing a Haskell wrapper using FFI
06:30:37 <genneth> poetix: no. i was trying to introduce a user defined type into the database. involves C
06:30:49 <shapr> Ah, I've been informed by Malcolm Wallace that HaXml also does generic trees, and that the major difference between HXT and HaXml is that HXT can operate over the DTD as well as the document content.
06:40:40 <poetix> Should I create a hawiki page about hsobby (hobby?)?
06:44:15 <earthy> dobby... dobby likes harry... err haskell...
06:45:06 <boegel> earthy :)
06:45:48 <earthy> what'd Kreacher be?
06:47:45 <boegel> earthy: a house elf
06:48:02 <boegel> ow wait, that's not what you asked :)
06:49:54 <boegel> with all the stuff going on in New Orleans, will Americans finally learn that allowing everyone to have weapons is a bad thing ?
06:50:08 <basti_> boegel: heheh...
06:50:14 <poetix> If *everyone* had weapons, it mightn't be so bad
06:50:14 <cbus> no give them more weapons
06:50:18 <poetix> Or it might be ten times worse
06:50:19 <basti_> boegel: i'd love seeing you try to debate this on #politics
06:50:19 <cbus> so they can defend themselves
06:50:20 <cbus> ;)
06:50:33 <poetix> Opinions differ...uh...violently on this matter...
06:50:37 * boegel joins #politics
06:51:02 <Philippa_> those being shot at are trying to do more than just shoot and therefore can't do so as effectively. That alone's a problem
06:51:46 <Philippa_> escalation = increased cost of conflict, duh
06:51:54 * poetix thinks that only good people should have weapons, and they should have really kick-ass weapons too
06:52:43 <poetix> I would like a personal disintegrator. The question is, am I good enough to be allowed one?
06:53:26 <Philippa_> not if you'd ever use it, duh
06:53:45 <poetix> If only good people had weapons, I'd never need to...
06:54:38 <Philippa_> then why have one at all?
06:54:43 <poetix> Of course, if it was an ACME personal disintegrator...well, you can guess what might happen...to me...personally...
06:55:21 <Philippa_> yup. Personally I settle for a bit of martial arts and knowing I'm not that likely to piss off anyone with anything worse than a knife here
06:55:27 <poetix> Philippa_: because it would be shiny, and cool.
06:55:47 <earthy> hm.
06:55:54 <earthy> and lethal
06:57:18 <genneth> but cool; no one like to have a hot knife stuck in them...
06:57:44 <genneth> i mean, that would just be insult upon injury
07:02:31 <poetix> I mean the disintegrator
07:10:20 <genneth> Oh. Well, I guess I could live with a hot disintegrator...
07:10:31 * genneth mumbles about when he was a child...
07:15:39 <xerox> boegel: I can't come up with the LSystem describing von Koth's curve, did you ever tried?
07:17:35 <boegel> von Koth ? never heard of it
07:17:52 <poetix> Hmm, looks like you need to provide a subclass overriding some virtual methods to handle signal events in libobby
07:18:16 <poetix> That means the C code is going to have to call back into the Haskell code when signals are fired
07:18:32 <basti_> koch's curve
07:18:50 <poetix> xerox: You've done FFI...
07:18:51 <xerox> boegel: abop, page 13 (or 1 as it shows up here)
07:19:00 <basti_> its step, turn left, step, turn right, step, turn right, step, turn left, step
07:19:39 * xerox tries F-F+F+F-F
07:20:30 <xerox> With angles of?  60° ?
07:20:40 <earthy> roughly, yes
07:20:47 <basti_> 90°
07:20:47 <xerox> Hmm doesn't work...
07:21:01 <xerox> 90 makes the wikipedia page's one!
07:21:56 <basti_> then add the formula to the page
07:21:56 <basti_> :D
07:22:32 <poetix> If I want to pass a callback from Haskell into some C code, how do I do it?
07:22:42 <xerox> http://haskell.galois.com/~paolo/Koch.png
07:22:48 <poetix> Is it possible to convert a Haskell function into a function pointer?
07:23:22 <xerox> (Notice I made GUI improvements too ;)
07:23:46 <sylvan> poetix, yes, I believe so.. You add "wrapper" or something to the FFI callback...
07:24:01 <sylvan> (I'll check some code)
07:24:08 <xerox> Yes you can do that, I've to search how.
07:24:26 <poetix> OK, I'll cross that bridge when I come to it
07:24:42 <sylvan> here's an example from my FMOD binding: foreign import ccall "wrapper" mkStreamCallbackRaw :: StreamCallback -> IO (FunPtr StreamCallback)
07:25:03 <sylvan> type StreamCallback = Ptr CSoundStream -> Ptr () -> CInt -> Ptr () -> IO CSChar
07:25:23 <xerox> FunPtr is in some Foreign module?
07:25:44 <sylvan> FunPtr is in Foreign.C or something like that
07:26:12 <xerox> @index FunPtr
07:26:13 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
07:26:21 <xerox> Index knows everything!
07:26:24 <basti_> xerox: uhm did you mean the koch snowflake?
07:26:29 <xerox> @index my keys
07:26:30 <lambdabot> bzzt
07:26:33 <xerox> ...
07:26:36 <xerox> basti_: yep!
07:26:50 <basti_> xerox: thats F-F++F-F of course
07:26:51 <basti_> with 60°
07:27:13 <basti_> i was thinking about the square koch curve
07:27:14 <earthy> you guys never did turtle graphics?
07:27:14 <xerox> Ah
07:27:15 <earthy> sheesh...
07:27:17 <xerox> You got it.
07:27:39 <xerox> Soooo nice!!!!!
07:27:41 <basti_> :D
07:27:45 <poetix> OK, so my Haskell to register callbacks could be something like:
07:27:51 <basti_> earthy: i did.
07:27:52 <poetix> registerCallback onDocumentCreated clientPtr (\event -> (do whatever))
07:28:39 <poetix> clientPtr `registerCallback` onDocumentCreated (\event -> whatever)
07:29:00 <sylvan> hmmmm... maybe =)
07:29:15 <boegel> xerox: screenshot !
07:29:29 <sylvan> the "wrapper" thing just wraps up a function into a FunPtr so you can pass it to an imported C function which expects that
07:30:00 <xerox> boegel: I'm trying to do a good pose :-)
07:30:37 <poetix> Yep. registerCallback would translate to a call to just such a C function, passing a pointer to the C++ object and a function pointer to the Haskell function we wanted called when that object's onDocumentCreated method got called.
07:30:59 <poetix> And the C function would arrange things with the C++ object so that would happen.
07:31:21 <sylvan> ah.. sure that would probably work
07:31:29 <poetix> It would really be an extern "C" function in some C++ code, of course...
07:32:33 <poetix> It occurs to me that I could start with just libobby client code, and run gobby as a libobby server for testing.
07:33:09 <poetix> No need to wrap it all up at once.
07:33:12 <xerox> http://haskell.galois.com/~paolo/Koch2.png
07:33:37 <poetix> shapr: xerox keeps posting pictures of his Koch!
07:33:49 <xerox> Ouch.
07:35:19 <poetix> Looks a bit flakey...
07:35:28 <xerox> Hnmm?
07:35:41 <poetix> Joke. Joke in poor taste. About Koch flakes.
07:35:54 <boegel> xerox: nice :)
07:36:00 <xerox> I do not have a way to specify the initial pic I think...
07:36:06 <xerox> Or maybe I do, mumble.
07:36:17 <boegel> xerox: how about a higher iteration level ?
07:36:27 <xerox> boegel: it always make that shape
07:36:36 <boegel> xerox: oh okay then ;)
07:37:17 <xerox> Also I can't use the "S",[('S',"|F")] trick to draw the trees growing upwards, after the non-determinism patch, ouch  :-)
07:38:15 <boegel> xerox: yaay :)
07:38:42 <xerox> @where hackage
07:38:43 <lambdabot> I know nothing about hackage.
07:38:51 <xerox> @where HSP
07:38:53 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
07:41:22 <Akshaal> hello
07:41:34 <xerox> Hi Akshaal!
07:41:45 <boegel> hi asmodai
07:41:54 <boegel> woops :) hi Akshaal
07:43:26 * xerox tab-completed to asmodai at first try too :-)
07:44:34 <boegel> xerox: :)
07:46:19 <Igloo> #haskell challeng for the day: Simplify http://musketeer.comlab.ox.ac.uk/~igloo/unfoldr.txt into a prettier use of unfoldr
07:47:12 <xerox> @pl \power x -> foldl (.) id ((unfoldr (\n -> if n == 0 then Nothing else Just (if even n then ((^2), n `div` 2) else ((*x), n - 1)))) power) 1
07:47:17 <lambdabot> flip flip 1 . (foldl (.) id .) . flip (unfoldr . ap (flip if'
07:47:17 <lambdabot> Nothing . (0 ==)) . (Just .) . ap (liftM2 if' even ((,) (^ 2) . (`
07:47:17 <lambdabot> div` 2))) . (. subtract 1) . (,) . (*))
07:47:17 <lambdabot> optimization suspended, use @pl-resume to continue.
07:47:23 <xerox> @pl-resume
07:47:25 <lambdabot> flip flip 1 . (foldl (.) id .) . flip (unfoldr . ap (flip if'
07:47:25 <lambdabot> Nothing . (0 ==)) . (Just .) . ap (liftM2 if' even ((,) (^ 2) . (`
07:47:25 <lambdabot> div` 2))) . (. subtract 1) . (,) . (*))
07:48:02 <xerox> There you go
07:48:43 <xerox> Hiya shapr.
07:48:46 <shapr> y0
07:48:47 * Igloo hands xerox a dictionary opened at the "pre" page  :-)
07:50:56 <shapr> hei esap
07:51:08 <esap> hi!
07:51:15 <esap> what's up?
07:51:42 * xerox reads .. to preclude, preclusion, preclusive, precociousness, precocity, .. mumble.
07:51:49 <shapr> I'm busy moving, what's up with you?
07:52:10 <esap> shapr: Been ill for a while, so not that well, but getting better all the time.
07:52:24 * genneth finds that xchat can tab complete
07:52:29 <genneth> thanks xerox
07:52:38 <Itkovian> xerox: you may want Lemmih's hsp implementation
07:53:18 <shapr> esap: I'm glad you're better.
07:53:48 <xerox> Itkovian: I was searching for it
07:55:15 * boegel disappeares into thin air
07:55:35 <xerox> genneth: good :-)
07:55:38 <Lucinda> hola
07:56:58 <xerox> Hey hey Lucinda!
08:05:34 <poetix> Hoboy...now I have to learn all about libsigc++...
08:05:56 <genneth> not much to learn
08:06:33 <xerox> I had hard time learning to type his name well
08:06:40 <genneth> C++'s usual craziness applied to signal slots
08:06:47 <poetix> Well I hope not. I need to trap signals coming from the C++ library and convert them to Haskell callbacks
08:07:02 <xerox> IIRC it is descripted as "Type Safe <something> in C++"
08:07:29 <xerox> @google libsigc++ site:sourceforge.net
08:07:31 <lambdabot> http://libsigc.sourceforge.net/
08:07:35 <genneth> actually, that reminds me
08:07:55 <genneth> twisted (python library) deferreds are remarkably like monads
08:08:29 <poetix> genneth: Really?
08:09:29 <genneth> the syntax for chaining callbacks reminds me of >>=
08:09:47 <poetix> Hmm.
08:10:47 <poetix> Last I looked, it was something like: return Deferred().addCallback(foo).addErrback(bar)
08:10:54 <genneth> yep
08:11:00 <poetix> Have they done some operator overloading craziness?
08:11:13 <genneth> foo is given the result from the previous stage
08:11:27 <xerox> The 'add' makes me think more about an arrow
08:11:42 <esap> libsigc++ has lots of overloading, template and interoperability craziness
08:11:55 <genneth> perhaps... my instinct about monads and what not isn't that good
08:12:27 <poetix> Well, they do allow you to compose functions together in a particular way
08:12:55 <poetix> Which I suppose - stretching a point slightly - is also what the deferred callback system is doing
08:13:05 <genneth> yes
08:13:21 <poetix> But I don't think it follows the monad laws, or anything like them
08:14:04 <genneth> it would be useful to have an IO-like monad that cothreads with a reactor
08:14:18 <poetix> Deferreds are kind of like continuations
08:14:37 * poetix thinks about that
08:15:19 <poetix> You could either have an explicit yield() to pass control to another "thread"
08:15:50 <poetix> Or just interleave expressions (which there is already a monadic way of doing)
08:16:40 * esap thinks about something different: Is there some connection between callbacks and constraint propagation?
08:17:22 <poetix> Well, callbacks "propagate" I suppose
08:18:52 <esap> But are callbacks constraints?
08:19:50 <poetix> I guess a reactor monad would be useful in the case that you had a suspend/resume mechanism, so a cothread could suspend until a particular signal was set and then resume next time the "scheduler" got round to it. But how would that be better than Haskell's own green threads?
08:20:46 <poetix> esap: If a callback can return a value, it can validate an event
08:20:58 <poetix> So by adding callbacks, you can add validation rules to say whether than event should proceed
08:21:32 <poetix> You can use that in a state machine, attaching callbacks to particular actions or state transitions
08:22:14 <poetix> Or to implement transaction semantics, to collect votes from each participant in a transaction
08:23:13 * xerox notes that somehow poetix isn't concentrating on the bindings... <grin>
08:26:27 * poetix leaves #haskell, that notorious disrupter of concentration
08:28:28 * xerox hides
10:07:25 <SyntaxNinja> 'morning
10:07:45 <Cale> morning
10:44:02 <SyntaxNinja> quiet today
10:44:29 <basti_> we need @noise
10:46:56 <xerox> @code
10:46:58 <lambdabot> Ptr.hs: instance Show (FunPtr a) where
10:46:59 <xerox> @code
10:47:01 <lambdabot> ForeignPtr.hs: newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
10:47:02 <xerox> @code
10:47:10 <lambdabot> Printf.hs: case (case c of 'e' -> showEFloat; 'f' -> showFFloat; 'g' -> showGFloat)
10:47:16 <basti_> :-o
10:56:13 <xerox> Quite quiet...
11:18:34 <Cale> @yow
11:18:36 <lambdabot> I'm encased in the lining of a pure pork sausage!!
11:19:57 <stepcut> @arr
11:19:59 <lambdabot> Get out of me way, yeh landlubber
11:21:23 <SyntaxNinja> @yow
11:21:24 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT
11:21:24 <lambdabot> MY
11:21:24 <lambdabot> WAY" I've ever heard!!
11:25:32 <xerox> @vexen speak loud, lambdawarrior!
11:25:33 <lambdabot> are you being sincere?
11:27:44 <shapr> @arr
11:27:44 <lambdabot> Smartly me lass
11:40:31 <SyntaxNinja> you don't have to be identified to recieve msgs, do you?
11:41:14 <xerox> SyntaxNinja: as far as I know you must be identified to send messages, not the other way around.
11:41:23 <newsham> hi
11:41:27 <SyntaxNinja> OK thoguht so
11:41:48 <SyntaxNinja> maybe we should all move to jabber
11:41:50 <SyntaxNinja> hi newsham
11:41:57 <xerox> SyntaxNinja: it's exact, I just tested.
11:42:00 <newsham> I have a bunch of types (lets say A, B, C) and I want to make another type that is just the union of all of those subtypes
11:42:06 <xerox> Silcnet!
11:42:21 <newsham> do I have to do something like:   AllType = AA A | AB B | AC C ?
11:43:22 <xerox> Maybe data UnionType = UnionType A B C?
11:44:07 * shapr has a colonel panic.
11:44:25 <newsham> some people dont even have a colonel
11:44:45 <newsham> xerox: isnt that a composite type containing an element of each?
11:44:57 <newsham> let me make this concrete, tiny dump:
11:45:02 <newsham> data Single = ASingle Card deriving (Show, Eq, Ord)
11:45:02 <newsham> data Pair = APair Card Card deriving (Show, Eq, Ord)
11:45:15 <newsham> I want another type "SubHand" which could be either a Single or a Pair (or other things)
11:45:47 <newsham> but I still need to be able to have a type of "Pair" because some subhands have a Pair as one of their components
11:46:57 <xerox> data SubHand = Either Single Pair -- ? :-)
11:47:08 <newsham> is there an Either?
11:47:11 <xerox> Err, s/data/type/
11:47:15 <xerox> Yup
11:47:19 <newsham> perfect.
11:47:21 <xerox> @kind Either
11:47:34 <xerox> @type Left
11:47:36 <newsham> please excuse me, I'm completely new to this.  this is my learning project.
11:47:38 <xerox> @type Right
11:47:38 <lambdabot> * -> * -> *
11:47:38 <lambdabot> forall b a. a -> Either a b
11:47:39 <lambdabot> forall b a. b -> Either a b
11:48:01 <xerox> newsham: Cool, what is it about?
11:48:33 <xerox> Or even, which card-game is it about? :-)
11:48:43 <newsham> type SubHand = Either Single Pair TwoPair Trip Straight Flush FullHouse Four
11:48:50 <newsham> ERROR "poker.hs":55 - Illegal type "Either Single Pair TwoPair Trip Straight Flush FullHouse Four" in constructor application
11:49:08 <basti_> newsham: uhm Either takes exactly 2 arguments.
11:49:10 <xerox> Indeed.  Either has kind * -> * -> *, i.e. it takes two type arguments.
11:50:00 <basti_> btw. we're missing union (sum) tuples.
11:50:33 <xerox> You could use type classes!
11:50:38 <basti_> hmm
11:50:48 <basti_> xerox: he should first know what he needs
11:50:57 <xerox> I'm just guessing
11:51:06 <basti_> he could be needing some data Type = ConsA Int | ConsB Int Int
11:51:08 <basti_> or something
11:51:20 <basti_> of course, in some situations, type classes would make sense too
11:51:40 <xerox> I was guessing he would need functions like  something :: SubHand a => a -> ...
11:52:29 <xerox> newsham: maybe you could describe the problem you're trying to solve, or the behaviors you're trying to model?
11:52:37 <newsham> 1 sec, I have an ideas
11:52:46 <xerox> Good enough :-)
11:52:49 <basti_> i would also doubt that it makes sense to save something that's bound to change perspective as fixed data.
11:53:41 <xerox> In fact I was wondering if it made sense to have those concepts bound at type level.
11:53:56 <newsham> data Pair = APair Card Card deriving (Show, Eq, Ord)
11:53:56 <newsham> data TwoPair = ATwoPair Pair Pair deriving (Show, Eq, Ord)
11:54:06 <newsham> I need a type that can represent both Pair and TwoPair
11:54:10 <newsham> and others
11:54:26 <newsham> Ie: data Hand = APairHand Pair | ATwoPairHand TwoPair ...
11:55:15 <Lemmih> data Hand = Pair Card Card | ... ?
11:55:34 <newsham> and TwoPair Card Card Card Card?
11:55:43 <newsham> I would rather explicitely represent two pairs as two pairs
11:56:01 <xerox> Maybe it could be useful to have |type Pair = (Card,Card)|, but it's a minor problem
11:56:38 <xerox> Lemmih's solution is clearer, I think
11:56:54 <Lemmih> data Hand = Pair Pair | TwoPairs Pair Pair | ... ?
11:58:33 <newsham> > Ie: data Hand = APairHand Pair | ATwoPairHand TwoPair ...
11:59:18 <newsham> hm.. actually.. yah, i kind of like what you just said.
11:59:21 <newsham> anyway, conf call, brb.
11:59:21 <Lemmih> Why the extra layer of indirection?
12:01:01 <newsham> wait, isnt that the same as what you have?
12:01:19 <newsham> oh heh, blah
12:01:23 <newsham> context switch hurting my brain
12:04:41 <SyntaxNinja> IRC has become a cone of silence
12:04:48 <xerox> SyntaxNinja: it's strangely true
12:05:07 <SyntaxNinja> <maxwell smart>Chief, I think we should use.. the cone of silence!</maxwell smart>
12:05:07 <xerox> How was to enable profiling?
12:06:25 <SyntaxNinja> can someone who is not identified send me a message (and tell me here that you're doing so?)
12:07:02 <Lemmih> I just did.
12:07:16 <SyntaxNinja> ok cool. I got it
12:07:19 <SyntaxNinja> whew
12:07:46 <xerox> Mumble.
12:08:04 <xerox> ghc --make Foo.hs -o foo  does work
12:08:20 <xerox> ghc -prof --make Foo.hs -o foo  do complains about missing modules
12:08:49 <SyntaxNinja> xerox: use cabal
12:08:55 <Lemmih> xerox: You have to compile your libraries with profiling too.
12:09:05 <xerox> Urgh!
12:09:31 <Lemmih> Cabal makes it really easy.
12:09:40 <xerox> I can't stand a Gtk2Hs compilation now, I'll try printing timediffs.
12:10:10 <SyntaxNinja> (thanks to lemmih)
12:22:01 <newsham> TwoPair needs to be a type because there is a hand that is made up of a TwoPair and a Single card
12:22:31 * SamB wonders why they haven't done a third run of the Inform Designer's Manual
12:27:55 <SamB> @hawiki
12:27:56 <lambdabot> http://www.haskell.org/hawiki/
12:42:29 <SamB> where would you put information about a suite of interactive fiction decompilers written in Haskell?
12:43:27 <SamB> like, where on the wiki?
12:43:38 <SamB> shapr: perhaps you, the keeper of the wiki, have some clue?
12:46:42 <astrolabe> What are fiction decompilers?
12:47:00 <SamB> astrolabe: you misparsed it
12:47:12 <SamB> the interactive is stuck to the fiction
12:47:41 <SamB> heard of Zork?
12:47:44 <Lemmih> What are interactive fiction decompilers?
12:48:25 <astrolabe> :)  Ah, shame.  It would be nice to know how some novels work.
12:48:50 <SamB> tools to help you decompile interactive fiction, of course
12:49:07 <astrolabe> Have you written them?
12:49:31 <SamB> in this case, one for the Z-Machine, one for Glulx, and I think a couple of TADS decompilers...
12:49:55 <SamB> no. but I am the first person to express interest in hacking on them beside the author, apparantly.
12:50:40 <vininim> interactive fiction? o_O
12:51:17 <SamB> vininim: are you wondering what it is, or just interested in the subject?
12:51:40 <vininim> wondering a lot
12:52:03 <Igloo> http://www.ifarchive.org/ is the cannical URL, I think
12:52:07 <astrolabe> I remember books that say stuff like 'to attack the zargs turn to page 34, to run away turn to page 40 etc.
12:52:26 <SamB> @google interactive fiction
12:52:28 <lambdabot> http://www.ifarchive.org/
12:53:02 <SamB> first hit on google, too. there seems to be some sort of new-user-addiction guide...
12:54:49 <vininim> oh.. just like what I tought it would be
12:54:57 <SamB> astrolabe: that is sort of a weak form of IF
12:55:34 <SamB> what kind of formal machine would that be?
12:56:45 <astrolabe> I guess it would be a pain but possible to keep an inventory like that, but formally, I would have thought it was a general.
12:57:10 <astrolabe> *as general
12:57:30 <SamB> thought what would be as general as what?
12:58:03 <SamB> oh, maybe you call it a finite-state-machine?
12:58:19 <astrolabe> as what you could do with a text-interface computer.
12:59:07 <Lemmih> Hi conal.
12:59:23 <conal> hi lemmih
12:59:39 <mflux> maybe you could have a book that would have each page divided in n parts horizontally
12:59:44 <SamB> well, with a text-interface computer you have at least a few k of ram... which is a lot better than the 7 plus-or-minus something cells of short-term memory that we humans have...
12:59:47 <mflux> to have parallel state machines
12:59:58 <mflux> they could even feed signals to each other
13:00:18 <mflux> and then add a roll of paper and have the turing machine right there..
13:00:57 <SamB> sounds like it would need frequent repairs, though
13:03:36 <astrolabe> What output do the decompilors produce?
13:05:38 <SamB> Something more or less resembling Inform source code, for the Z-Machine and Glulx decompilers
13:06:53 <astrolabe> Oh. It sounds cool.  You should put it on the wiki :)
13:07:10 <SamB> yes, I will as soon as I figure out where
13:08:40 <shapr> SamB: I am the keeper of the wiki. It sounds like an application/library to me. Create a page, add info.
13:08:42 <astrolabe> Links can be added or removed later I guess.
13:09:54 <SamB> how will anyone find the page?
13:10:17 <SamB> also, whatever shall I call it?
13:10:18 <shapr> Add it to the Libraries index
13:10:23 <shapr> What's the name of it now?
13:10:36 <shapr> Also, google indexes HaWiki.
13:10:36 <SamB> @google mrifk reform haskell
13:10:38 <lambdabot> http://www.darkweb.com/~benrg/if-decompilers/
13:10:56 <SamB> thats the page about it
13:11:39 <SamB> the author just put up a darcs repo at http://www.cl.cam.ac.uk/~br276/darcs/if-decompilers
13:11:59 <shapr> Call it InteractiveFictionDecompilers maybe?
13:12:30 <SamB> sure, if anyone else writes any they can figure out where to put the stuff about these ones ;-)
13:14:29 <shapr> Yeah, wikis are anarchic. People throw in content. If other people dislike the format/structure/etc, those other people fix it.
13:15:18 <astrolabe> What is the job of the keeper of the Wiki? (makes it sound like a ferocious beast :)  )
13:28:45 <SamB> astrolabe: he fixes MoinMoin when it breaks, keeps it tricked out for Haskell and such, and upgrades it from time to time
13:29:29 <SamB> Okay, so I have started on http://www.haskell.org/hawiki/InteractiveFictionDecompilers
13:30:43 <SamB> anyone else grabbed the repo yet?
13:36:15 <Igloo> What's the motivation, OOI? Writing a simulator in Haskell?
13:36:31 <Igloo> Or does it do more decmopilation than a simulator would need to?
13:36:37 <Igloo> interpreter, I guess I should say
13:36:40 <SamB> Igloo: huh? motivation?
13:36:46 <Igloo> Why write it?
13:37:33 <Philippa> interpreters don't need to, they can just run the z-machine code as-is
13:37:49 <SamB> They are tools for figuring out how games work, whether in order to steal their ideas or just so you can figure out how to win...
13:38:02 <Philippa> or to modify or extend them, I guess
13:38:11 <sieni> how can ideas be stolen?
13:38:15 <Igloo> Ah, right; I think I'd assumed people pretty much wrote z code directly
13:38:22 <SamB> I should add the sections for the other decompilers
13:38:48 <poetix> I remember peeking at the z-code for Curses (the IF) to try to figure out how to solve a couple of gnarly problems
13:39:13 <poetix> I didn't get as far as decompiling it, but I needed to transform the code a bit just to get some readable text
13:39:45 <poetix> So there's a motivation ;)
13:39:53 <poetix> I'd like to know how Graham Nelson's mind works...
13:40:53 <poetix> Incidentally, the manuals and technical documents he wrote for Inform are wondrous
13:46:45 <newsham> is there a way to index into lists and take slices of lists?
13:47:22 <Igloo> !! and take m . drop n, but beware: They are linear time
13:47:37 <xerox> poetix: hiya!  Any news?
13:47:51 <poetix> I had some paid work to attend to...
13:48:05 <poetix> I'm just trying to sort out a build environment, for starters.
13:48:34 <poetix> I guess I'm going to have to go with the whole gnu build environment, all of which is totally new to me
13:48:44 <poetix> Well, apart from make anyway
13:50:14 <poetix> Do you think it's better to write a fairly naive C API, and make things more Haskellish in the Haskell layer?
13:50:43 <newsham> igloo: what about a slice?  ie. 3rd through fifth elements
13:51:43 <xerox> poetix: opposed to?
13:52:01 <poetix> Making a C API that already does a certain amount of translation
13:52:06 <poetix> For example:
13:52:53 <poetix> To register a callback for an event on the client object, in C++ you would get the signal object that's exposed as a public member of the client, and call a method on it to register a callback
13:53:15 <poetix> Now that could be two C functions, one to get a pointer to the signal object and then another to register a callback with it
13:53:29 <poetix> Or it could be one, that gets the signal object and registers the callback all in one go.
13:55:11 <xerox> But the former hypothesis means more work on the glueing C code, right?
13:55:44 <poetix> Well, the former version you could do without really thinking about it
13:56:15 <poetix> Just turn the method invocation inside out, so instead of client.document_created_signal you have get_document_created_signal(client* client)
13:56:56 <xerox> But the former implies something like a double-layer on the Haskell side
13:57:07 <poetix> The latter version means thinking about a particular pattern of usage, where the only thing you're going to do with that signal object is register a callback with it anyway, so you might as well make just one function
13:57:41 <poetix> Yes, it would be like: client <- createClient; signal <- getSignal client; registerCallback signal callback
13:57:45 <xerox> I think this last could be worth it, but I didn't have a deeply look at the sources.
13:58:05 <poetix> Rather than: client <- createClient; registerCallbackForSignal client callback
13:58:42 <poetix> But the thing is, I could put a Haskell layer between the plain FFI code and the library API that simplified things for the end-user anyway
13:58:54 <xerox> Indeed
13:59:03 <poetix> So it's not necessarily an issue if the C layer is a bit cumbersome
13:59:24 <poetix> And it maybe makes it more generic, in case someone wants to use it to link from another language, or has another intended pattern of usage
13:59:34 <SamB> okay, now I've added a section for Mrifk and some stub sections for the other 3...
13:59:52 <xerox> poetix: I think I agree.
14:00:55 <poetix> So it might be best for me to keep the C layer really as close to a straightforward mapping of classes and methods as possible
14:01:03 <poetix> And do the "design" work in Haskell
14:01:34 <xerox> I can't really estimate how does that work differ in terms of LOC or something.
14:01:47 <poetix> No, me neither.
14:04:15 <poetix> What would you recommend for working with C and C++ code? Did you just use the standard GNU tools?
14:04:45 <xerox> I did not mess with glueing C code at all :-)
14:05:16 <poetix> Of course, the gtk+ code is already in C, so you could just glom c2hs onto it...
14:05:26 <xerox> And cairo too.
14:05:54 <xerox> Anybody has the link of Lemmih's work on HSP?
14:06:17 <poetix> gtk2hs uses autoconf and automake, though...?
14:06:31 <Lemmih> darcs repo: http://scannedinavian.org/~lemmih/hsp
14:06:31 <xerox> Err, yes.
14:06:40 <xerox> And it has a very very complex build system.
14:06:54 <xerox> It took months to Duncan to grok it.  But now he can manage it very well.
14:07:03 <xerox> Lemmih: thanks!
14:07:07 <xerox> @where hsp
14:07:08 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
14:07:18 <xerox> Maybe you could replace this/add an entry
14:07:37 <poetix> Maybe I should just start with simple makefiles, and migrate to a more complex build system later on if it's needed
14:07:49 <xerox> Lemmih: could you paste the url of the running copy? I'd like to show it to a friend.
14:11:57 <Lemmih> xerox: The only running copy is located on my development box and may go down at any moment /-:
14:12:29 <xerox> Lemmih: oh. Is it browsable for some minutes, now?
14:13:31 <Lemmih> Yeah. http://212.242.49.100/work/hsp/Browse
14:13:52 <xerox> Thank you!
14:14:04 <Lemmih> The wiki example is broken and the Session example keeps recompiling for some reason.
14:15:57 <xerox> Oh.  I noticed it.
14:38:45 <poetix> xerox: Do Haskell strings convert to char*, or something else?
14:39:04 <xerox> poetix: it is correct
14:39:08 <xerox> @index withCString
14:39:09 <lambdabot> Foreign.C.String, Foreign.C
14:39:11 <newsham> is there an easy way for me to take the difference between two enumerated types?
14:39:31 <poetix> Cool. Now I have to convert a char* into a std::string
14:39:50 <newsham> data Blah = A | B | C | D       it would be useful if I could compute (C-A) for example
14:40:16 <xerox> poetix: I think you can apply the string object constructor to do it, mumble, but what to do from C code?
14:40:49 <poetix> Well, I'm hoping that won't be a problem, as it will actually be C++ code, only global functions declared with extern "C"
14:41:05 <newsham> (one obvious solution is to make a list of the enumerated values and then use indices.. anythign cleaner?)
14:41:52 <xerox> poetix: oh, that way it isn't a problem at all I think.
14:42:00 <poetix> I hope c2hs can deal with that...
14:42:24 <xerox> "That" being?
14:42:42 <poetix> C++ source files with global functions declared as extern "C"
14:42:57 <poetix> If it can't, I'll have to write some *very* boring glue code.
14:43:26 <basvandijk> Hi guys, I'm a Haskell newby and I'm playing a bit with the language. I have a question about how to define a funtion.
14:43:44 <poetix> basvandijk: Fire away
14:43:53 <basvandijk> I have the following datatype:
14:43:53 <basvandijk> data Tree a = Tree a [Tree a]
14:43:53 <basvandijk> I want to define a function:
14:43:53 <basvandijk> p :: Tree a -> [[a]]
14:43:53 <basvandijk> That given a tree returns all paths from root to children.
14:43:54 <basvandijk> For example:
14:43:56 <basvandijk> p (Tree 2 [ Tree 1 [Tree 1 [Tree 1 [Tree 1 []]]]
14:43:58 <basvandijk>           , Tree 2 [ Tree 1 [Tree 1 []]
14:44:00 <basvandijk>                    , Tree 2 []
14:44:02 <basvandijk>                    ]
14:44:04 <basvandijk>           ]
14:44:06 <basvandijk>    )
14:44:08 <basvandijk>    =>
14:44:10 <basvandijk> [ [2,1,1,1,1]
14:44:12 <basvandijk> , [2,2,1,1]
14:44:14 <basvandijk> , [2,2,2]
14:44:16 <basvandijk> ]
14:44:18 <basvandijk> Any ideas how to define p?
14:44:19 <wilx> Ewww....we have a paste bin...
14:44:24 <basvandijk> oops copy paste doesn't work that nice
14:44:32 <xerox> poetix: I think that if the extern "C" functions are plain C function there is no problem at all.
14:44:37 <wilx> @paste
14:44:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:44:48 <xerox> poetix: also, consider that c2hs analyzes the header files.
14:45:17 <vininim> wiki paste is little awkward :/
14:45:22 <xerox> basvandijk: is there a specific reason to use lists inside trees?
14:45:23 <vininim> I prefer rafb.net ones =P
14:45:36 <poetix> xerox: Ah, yes.
14:45:45 <basvandijk> Well, I need a tree with multiple childrenen
14:46:56 <xerox> basvandijk: what kind of three do you exactly need?  I do know the classical binary tree datatype definition:  data BTree a = Leaf a | Branch (BTree a) (BTree a)  or even  data BTree a = Leaf | (Tree a) a (Tree a).
14:47:06 <xerox> I think people usually use the latter.
14:47:34 <poetix> basvandijk: Do you need the paths to the leaves only, or to all the nodes?
14:47:34 <astrolabe> I have used trees with lists
14:47:45 <basvandijk> only to the leafs
14:48:52 <xerox> astrolabe: what is an example usecase?
14:49:10 <astrolabe> board game search trees
14:49:12 <poetix> xerox: An XML document?
14:49:32 <xerox> Oh-hum!
14:49:41 * poetix thinks the world would be a much simpler place if all trees were binary
14:49:47 <xerox> And an example for the two trees I described above?
14:51:35 <basvandijk> xerox: Let me explain the problem I'm trying to solve. I want to define a function: sum :: Int -> [[Int]] sum n returns a List of all sums of n. sum is the List of Integers greater than zero that added together form n. For example: sums 4 => [ [1,1,1,1], [2,1,1], [2,2], [3,1], [4]]
14:51:44 <astrolabe> basvandijk:  I guess the list for a tree would be the concatenation of the lists for the children, but with the value at the root node consed onto each element.
14:52:39 <xerox> I think I would use list comprehensions
14:52:44 <poetix> basvandijk: I think what you need is a tree traversal function with an accumulator
14:53:00 <poetix> Actually, now I've read what astrolabe just said, I don't think that any more
14:53:51 <astrolabe> partitions might be a better name than sum :)
14:54:08 <basvandijk> Yeas you're right
14:54:44 <basvandijk> I have this function:
14:54:44 <basvandijk> data Tree a = Tree a [Tree a] deriving Show
14:54:44 <basvandijk> partitions n = [ mkT x (n-x) | x <- [1..n]]
14:54:44 <basvandijk>                           where
14:54:44 <basvandijk>                           mkT :: Int -> Int -> Tree Int
14:54:45 <basvandijk>                           mkT x 0   = Tree x []
14:54:47 <basvandijk>                           mkT x rem = Tree x [ mkT a (rem-a) | a <- [1..rem], a <= x, a <= rem]
14:55:18 <xerox> Heh, why don't you use plain lists?
14:56:11 <basvandijk> I allready tried that but I couldn't solve it... (I'm still a Haskell newby)
14:58:59 <vininim> the enumeration problem
14:59:05 <vininim> I think a list could do
14:59:13 <astrolabe> The partitions of n are {n} together with {pU{1}| pis a partition of n-1}.   You could remove duplicates.
15:00:54 <astrolabe> Oops.  I mean together with {pU{{1}} | p is a partition of n-1}
15:01:25 <astrolabe> Oh, still not right :)
15:02:11 <basvandijk> I'm not trying to find all partions of n, I'm trying to find all lists of Integers (>0) that when added together form n
15:02:42 <vininim> it maps directly to the partition/enumeration problem
15:02:59 <basvandijk> sums 4 => [ [1,1,1,1], [2,1,1], [2,2], [3,1], [4]]
15:03:19 <basti_> lisppaste2: @url
15:03:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:03:43 <lisppaste2> basti_ pasted "partition problem" at http://paste.lisp.org/display/11335
15:03:45 <astrolabe> Why isn't [1,2,1] in the list?
15:03:52 <basti_> this is how i'd do it
15:04:14 <basvandijk> I consider [1,2,1] the same as [2,1,1]
15:04:52 <astrolabe> Hmm, then they are essentially partitions I think.
15:07:38 <basvandijk> basti_: Your solutions I almost correct I think. Only "duplicate" elements like [1,3] and [3,1] should be removed.
15:08:55 <basti_> basvandijk: hmm
15:09:18 <astrolabe> you could use sort and nub
15:09:37 <basti_> @pl \x-> nub $ map sort x
15:09:38 <lambdabot> nub . map sort
15:09:45 <basti_> like this
15:10:02 <xerox> basti_: I don't understand you code, whoa.
15:10:08 <astrolabe> Yeah!
15:10:08 <basti_> xerox: why not?
15:10:37 <basti_> xerox: its just obfuscated map :D
15:11:09 <Lemmih> @type Data.Set.toList . Data.Set.fromList
15:11:10 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:11:37 <Lemmih> Might be faster than sort and nub.
15:11:49 <basti_> yup
15:12:03 <astrolabe> but don't you need to sort?
15:12:14 <basti_> oh yes.
15:12:17 <basti_> faster than nub though
15:13:05 * xerox can't get it
15:13:18 <basti_> ?
15:13:37 <xerox> The base case is clear, part 1 too..
15:13:50 <Lemmih> Ah, we're talking about a list of lists.
15:14:11 <xerox> basti_: how would you explain the code in words?
15:14:45 <basti_> xerox: "to get the partitions of n, for each x in [1..n] do: append the list of partitions of (n-x) to x.
15:14:49 <basti_> "
15:14:56 * astrolabe thinks his idea would be more efficient.
15:15:36 <astrolabe> basti uses the fact that every partition of n, is m appended to a partition of n-m, for some m.
15:16:12 <xerox> Hmm kay.
15:16:27 <astrolabe> Oh, my idea is wrong :(
15:16:31 <TheHunter> @paste
15:16:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:16:39 <basti_> lol
15:17:04 <basvandijk> "nub (map sort (part 4))" pretty much does what I want but how efficient is it?
15:17:20 <xerox> ahah, guard!
15:17:45 <basti_> basvandijk: myNub = Set.toList . Set.fromList
15:18:04 <basti_> and you'd need import Data.Set as Set
15:18:10 <basvandijk> k
15:18:10 <astrolabe> I would be better to do the nub and sort stuff as part of the definition, so it gets applied at each recursion.
15:18:25 <basti_> nub is O(n^2), making/breaking sets is O(n lg n)
15:18:49 <Cale> if your list is sorted, then  map head . group is the same as nub
15:18:50 <basti_> astrolabe: yes it might pay out.
15:19:08 <basti_> Cale: the lists inside the list are sorted
15:19:10 <Cale> (assuming that the ordering given by < is total)
15:19:53 <Cale> sorry, I'm jumping in randomly here -- what is the problem?
15:20:05 <basti_> generating all partitions
15:20:09 <basti_> of an integer
15:20:12 <Cale> ah
15:20:19 <basti_> as in 3 = 3, 2+1, 1+1+1
15:20:22 <astrolabe> basti, Why are the inside lists sorted?
15:20:38 <TheHunter> maybe better: part' n m = [ k:xs | m >= n, k <- [n..m], xs <- part' k (m-k) ]
15:20:38 <basti_> astrolabe: because we want 2+1 = 1+2
15:21:20 <astrolabe> maybe a helper function to produce all partitions of n for which no part is greater than m would be useful for speed.
15:22:06 <basti_> TheHunter: now im lost.
15:22:13 <astrolabe> basti:  Sorry, misunderstood.
15:22:27 <xerox> Ah! basti_, we share something :-P
15:22:45 <TheHunter> basti_, why?
15:22:47 <basti_> haskell - powered by PhD
15:23:29 <basti_> TheHunter: is part' a b generating the partitions with a<=(first part elem)<=b?
15:23:29 <TheHunter> i just translated the do-block into a list comprehension.
15:23:52 <basti_> :-o
15:24:08 <TheHunter> partitions with sum b in which only numbers >= a occur.
15:24:22 <basti_> ah yes
15:24:23 <astrolabe> I don't understand the syntax of '| m >= n' when m and n are arguments.
15:24:57 <TheHunter> @botsnack
15:24:59 <lambdabot> :)
15:25:01 <xerox> I was about to ask.
15:25:10 <basti_> TheHunter: why does that do what we want?
15:25:57 <basti_> that is... it doesn't at all.
15:26:00 <TheHunter> that is just a guard.
15:26:18 <TheHunter> of course it does.
15:26:21 <basti_> TheHunter: i can't get your function to run
15:26:51 <TheHunter> part = part' 1 where
15:26:51 <TheHunter>   part' _ 0 = [[]]
15:26:51 <TheHunter>   part' n m = [ k:xs | m >= n, k <- [n..m], xs <- part' k (m-k) ]
15:27:02 <basti_> ah
15:27:23 <basti_> yes, lots faster.
15:27:38 <basti_> ahh and i understand why it works, too :D
15:27:45 <xerox> Whoa..
15:29:13 <basti_> basvandijk: did you see that?
15:29:28 <basvandijk> yeas but I can't get part' to run
15:29:38 <basvandijk> part' 1 3 => []
15:29:51 <basti_> see that TheHunter said
15:31:19 <TheHunter> part' 1 3 => [[1,1,1],[1,2],[3]]
15:31:28 <basvandijk> great it works... Now I gonna try understanding it
15:31:42 <SamB> okay, whats a good way to remove an unknown number of items satisfying a predicate from the end of a list?
15:31:42 <astrolabe> I guess it could be speeded up further by memoizing or something like it.
15:31:49 <SamB> (I want them back, too!)
15:31:49 <TheHunter> it's pretty much the same as what you started using trees.
15:32:15 <Cale> SamB: You know the list is finite?
15:32:32 <basti_> astrolabe: actually its much more efficient because it doesnt generate lots of stuff that gets thrown away
15:32:59 <Cale> SamB: I'd probably just reverse the list first, and use span/break
15:33:00 <SamB> Cale: there are bigger issues if the list is not finite...
15:33:05 <Cale> SamB: yeah
15:33:14 <basti_> basvandijk: do you know the list notation with the | and the <-?
15:33:20 <astrolabe> basti:  Yeah, but I bet part 10 calls part 3 lots of times.
15:33:22 <basvandijk> yeas I know
15:33:27 <SamB> such as how in the world did the user obtain an infinately long TADS 2 .gam file
15:33:38 <Cale> SamB: heh
15:33:48 <basti_> astrolabe: hmm
15:35:54 <basti_> basvandijk: part' a b generates only partitions with parts >= a, because that way we will have the large numbers in the back
15:36:19 <basti_> we won't miss a partition, too, since we're clever and start with partitions with parts >= 1, and so get all the small numbers in front
15:37:02 <basvandijk> basti_: I think I get it... it is indeed somehow similar to my Tree solution like TheHunter said
15:39:05 <Cale> tailSatisfying p xs = find (\(x,y) -> all p y) (zip (inits xs) (tails xs))
15:39:12 <Cale> SamB: how's that?
15:39:40 <Cale> (probably somewhat poor efficiency compared to the much simpler way, actually)
15:40:11 <SamB> yeah, I'll probably go with the reverse way...
15:41:06 <basvandijk> Hey guys, I need to go away (to bed), thanks very much, this IRC really helps alot... bye!
15:41:15 <astrolabe> bye
15:41:54 <Cale> tailSatisfying p xs = (\(x,y) -> (reverse y, reverse x)) (span p (reverse xs))
15:48:59 <SamB> @type (\(x,y) -> (reverse y, reverse x)) (span p (reverse xs))
15:49:00 <lambdabot> bzzt
15:49:34 <SamB> @type span
15:49:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:50:02 <xerox> Maybe the problem is that 'p' is a free variable
15:50:19 <SamB> oh, right
15:50:32 <SamB> @type \ p xs ->(\(x,y) -> (reverse y, reverse x)) (span p (reverse xs))
15:50:33 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:00:46 <ulfdoz> bye
16:01:41 <exe> Haha, araujo.
16:28:16 <newsham> can I convert a enumerated type into an integer or somehow get the difference between enumerated values?
16:28:44 <SamB> newsham: with the right "deriving" clause, yeah sure
16:28:56 <Igloo> You can get an Int with fromEnum
16:29:06 <newsham> can you point me in the right direction?  I basically want:   data Foo = A | B | C | D | E | F
16:29:15 <newsham> with the ability to compute E - C
16:29:45 <newsham> what should I be deriving?
16:31:01 <Igloo> You want the answer to be 2?
16:33:33 <newsham> yes.
16:33:46 <Igloo> Enum
16:33:55 <Igloo> And use fromEnum
16:35:16 <newsham> where do I find this?
16:36:10 <dave_m> Enum is defined in the Prelude
16:37:12 <dave_m> See http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AEnum
16:37:18 <SamB> so you want "data Foo = A | B | C | D | E | F deriving (Enum)"
16:37:27 <newsham> yah, I just figured that out.
16:37:31 <newsham> thanks sam.
16:50:05 <newsham> is there a builtin for uniq'ing a list?
16:52:38 <TheHunter> @eval nub [1,2,3,1,2,3]
16:52:41 <lambdabot> [1,2,3]
16:53:07 <newsham> what does nub stand for?
16:53:20 <TheHunter> it's a word, i think.
16:53:31 <TheHunter> @wn nub
16:53:34 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
16:53:34 <lambdabot> nub
16:53:34 <lambdabot>   n 1: a small lump or protuberance [syn: {nubble}]
16:53:34 <lambdabot>   2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {
16:53:34 <lambdabot> stub}]
16:53:36 <lambdabot>   3: the choicest or most essential or most vital part of some
16:53:38 <lambdabot>    idea or experience; "the gist of the prosecutor's
16:53:40 <lambdabot> [5 @more lines]
17:01:54 <newsham> hmm.. this isnt working right for me
17:02:08 <newsham> c2 -> [[Ts],[Kd],[Qh],[Ad],[Jc]] :: [Card]
17:02:16 <newsham> nubBy sameValue c2 -> [[Ts],[Kd],[Qh],[Jc]] :: [Card]
17:02:30 <newsham> (similar results if I sort by value first)
17:03:35 <dave_m> what does your sameValue function look like?
17:03:43 <newsham> sameValue :: Card -> Card -> Bool
17:03:43 <newsham> sameValue (ACard s v) (ACard s' v') = (v == v')
17:04:30 <dave_m> 's' is the suit, and 'v' is the rank?
17:04:38 <newsham> yes
17:04:49 <newsham> (i'm using the word "value")
17:05:22 <dave_m> what's the type of 'v'?
17:05:50 <newsham> data Value = Two | Three | Four | ... Ace deriving (Eq,Ord,Enum)
17:07:37 <dave_m> strange. what does filter (sameValue [Ad]) c2 give you?
17:08:24 <newsham> Poker> filter (sameValue (ACard Ace Diamonds)) c2
17:08:24 <newsham> [[Kd],[Ad]] :: [Card]
17:09:28 <dave_m> How about King == Ace?
17:09:38 <newsham> False
17:10:01 <newsham> blah, s v backwards :)
17:11:04 <newsham> better
17:31:27 <newsham> http://lava.net/~newsham/x/poker.hs.txt  <- simple hand ranking is working now
17:31:37 <newsham> i would love to hear any feedback (the purpose here is education)
17:34:55 <dave_m> so, if you're holding two pairs, does the fifth card get dropped?
17:35:18 <newsham> if you have KK553 and someone else has KK55A the latter will win
17:35:28 <newsham> which is why the comment says its not complete
17:35:35 <newsham> I need to collect the "trash" cards at some point
17:35:45 <dave_m> Ah, I see
17:36:21 <newsham> I will have to make a  FullHand = PartialHand [Card]    or something like that
17:37:00 <dave_m> one possibility would be to use PartialHand to only record the relevant bits of the hand
17:37:21 <dave_m> eg. TwoPair { high :: Value, low :: Value, trash :: Card }
17:37:32 <dave_m> and then have a function [Card] -> PartialHand
17:37:42 <dave_m> might make comparison of hands easier
17:37:43 <newsham> it needs to record the exact cards.. people want to know that, and besides you may need it to exclude cards when selecting the trash
17:37:58 <newsham> dave: that optimization is already present in the compare methods
17:38:27 <newsham> notice when it compares two Flush instances it only compares the top card
17:38:34 <newsham> because they are always represented sorted
17:38:50 <newsham> oh, blah, I didnt allow for Ace=Low in straights yet
17:39:24 <TheHunter> the contract for Ord is that compare x y === Eq <==> x == y
17:40:07 <newsham> I cant read that, too many "="s
17:40:27 <dave_m> yeah, poker hands have more of a partial order
17:40:46 <TheHunter> compare x y is Eq if and only if x == y.
17:40:56 <TheHunter> *EQ
17:41:17 <newsham> hunter: I dont think I violated that.
17:41:18 <shapr> newsham: Are you going to get rich writing a poker bot in Haskell?
17:41:33 <newsham> shapr: no, I'm going to get poor by writing haskell instead of doing real work
17:42:03 <dave_m> if two hands are in the same equivalence class, it might make sense to say they are equal
17:42:22 <shapr> newsham: Been there, doing that, Love It!
17:42:26 <dave_m> you just have to be clear about what your semantics
17:42:49 <shapr> On the other hand, I have some Haskell contract work I need to do this week.
17:42:51 <newsham> i think "have to" is a bit strong :)
17:42:59 <TheHunter> compare (ACard Two Hearts) (ACard Two Spades) === EQ
17:43:04 <TheHunter> but ACard Two Hearts /= ACard Two Spades.
17:44:21 <newsham> yup, I guess I forgot to override '=='/Eq
17:44:46 <dave_m> handy default : (a == b) = (compare a b == Eq)
17:44:57 <dave_m> Or, rather, EQ
17:46:45 <newsham> instance Eq Card where
17:46:45 <newsham>         x == x' = ((rank x) == (rank x'))
17:46:48 <newsham> better?
17:47:27 <TheHunter> yep.
17:47:43 <TheHunter> you could even write x == x' = rank x == rank x'
17:48:10 <newsham> new language, I dont want to rely on precedence that isnt intuitive to me yet
17:48:24 <dave_m> although with that many ='s, some parentheses may be helpful for readability
17:48:30 <newsham> its already bit me in the ass a few times
17:48:41 <dave_m> I'd go with (x == x') = (rank x == rank x')
17:49:12 <newsham> it doesnt let me parenthesize the LHS
17:49:20 <TheHunter> application (juxtaposition) always has highest precedence. There is no exception to these rule.
17:49:42 <newsham> hunter: when that sinks in to my brain I will be less paren happy
17:50:31 <dave_m> newsham: weird. I've done things like (f |+| g) k = ...
17:50:33 <TheHunter> i'm just telling you. Things like a*b `mod` c are less clear, and I usually use unnecessary parens in such cases as well.
17:51:12 <newsham> any way I can make the "rankno" stuff less obvious?
17:51:24 <newsham> err.. less awkward :)
17:52:14 <dave_m> Haskell takes each case in order, so you could do something like:
17:52:29 <dave_m> compare (Four Kind ...) (FourKind ...) = ...
17:52:44 <dave_m> compare (FourKind ...) _ = GT
17:52:47 <dave_m> and so forth
17:53:25 <TheHunter> you could also use (FourKind {}) instead of _ _ _ _.
17:53:25 <newsham> *nod* that is probably cleaner.
17:53:43 <newsham> {} is an arbitrary number of unnamed items?
17:53:55 <dave_m> does that work for non-records?
17:54:05 <TheHunter> i'm fairly sure it does.
17:54:32 <TheHunter> @eval case Just () of Just {} -> True
17:54:34 <lambdabot> True
17:54:52 <dave_m> huh. that's handy
17:55:13 <newsham> can I do   (Flush x {}) ?
17:56:14 <TheHunter> afraid not. You would have to declare the whole Flush constructor as a record to do something like it.
17:57:07 <newsham> that worked well..  see updated srcs
17:58:32 <newsham> now is there any way to enforce that TwoPair be made up of two Pair's?
17:58:43 <newsham> without making a complex type heirarchy (I had previously, it wasnt pretty)
17:59:49 <dave_m> wait, what does compare (FullHouse ...) (FourKind ...) eval to?
17:59:50 <TheHunter> sorry, not possible
18:00:09 <dave_m> I think you need another set of cases
18:00:21 <newsham> FullHouse is less than Four Kind
18:00:41 <dave_m> is that what your code says?
18:01:00 <newsham> should match compare (FourKind {}) _ = GT
18:01:11 <newsham> oh, wait.. backwards.
18:01:30 <newsham> *sigh* so this was probably more compact the way it was previously
18:01:31 <dave_m> you'll also need compare _ (FourKind {}) = LT
18:02:06 <newsham> *nod*
18:03:13 <dave_m> have you played with HUnit at all? some testcases would probably be useful while you're nailing down compare
18:04:02 <newsham> is there a way to have this call "deriving Enum" so I can use fromEnum to compare between unequal variants?
18:05:20 <newsham> doenst appear so
18:08:18 <SamB> what is a good way to word-wrap text in Haskell?
18:08:44 * SamB wants prettier Inform/TADS string literals
18:18:03 <dave_m> SamB: I haven't seen any libraries, but there's a paper about it at <http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#para>
18:22:29 <Igloo> You could use fsep (IIRC) from PrettyPrint
18:25:18 <dave_m> @hoogle fsep
18:27:42 <newsham> I still havent found an answer to my slicing question.  is there a way to get a slice (subset) from a list (using prelude functions)
18:28:11 <dave_m> you want to slice by position?
18:28:20 <newsham> yah say 'the first five items'
18:28:35 <newsham> or better -- the first five items, or all items if there are less than five present
18:28:40 <dave_m> @eval take 5 "abcdefghi"
18:28:41 <lambdabot> "abcde"
18:28:59 <dave_m> @eval take 5 "abc"
18:29:00 <newsham> what if i want from 7 to 12?
18:29:01 <lambdabot> "abc"
18:29:34 <dave_m> @eval take (12-7) (drop 7 ['a'..])
18:29:36 <lambdabot> "hijkl"
18:29:52 <dave_m> probably an off-by-one error in there
18:52:52 * SamB greatly abuses the list monad
18:53:24 * SamB thinks somebody will most likely clean up the mess later
18:58:34 <newsham> fixed the ace-low straight issue, added straightflush (oops forgot that earlier) and now it has a way to rank full hands
18:59:06 <newsham> any other advice or opinions?  If you were doing this what would you have done differently?
19:05:10 <SamB> @hoogle [a] -> a -> Int
19:05:11 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
19:05:11 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
19:05:11 <lambdabot> Prelude.seq :: a -> b -> b
19:05:20 <SamB> um, no
19:05:45 * SamB thinks hoogle is an idiot. no, worse than an idiot.
19:06:54 <elk> @hoogle Eq a => [a] -> a -> Int
19:06:55 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
19:06:55 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
19:06:55 <lambdabot> Prelude.seq :: a -> b -> b
19:08:36 <SamB> looks suspiciously like a roll-my-own situation...
19:09:35 <dave_m> SamB: you're talking about word-wrapping?
19:09:43 <SamB> @type (`lookup`(`zip` [0..]))
19:09:44 <lambdabot> bzzt
19:10:14 <SamB> @type (flip lookup) . (`zip` [0..])
19:10:16 <lambdabot> forall b a. (Eq a, Num b, Enum b) => [a] -> a -> Maybe b
19:10:22 <Lemmih> @type List.elemIndex
19:10:23 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
19:10:37 <SamB> oh, right
19:11:01 <elk> @hoogle Eq a => [a] -> a -> Maybe Int
19:11:02 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
19:11:16 <elk> oh, you got it already
19:12:08 <SamB> @type flip ((flip lookup) . (`zip` [(0::Int)..]))
19:12:09 <lambdabot> forall b. (Eq b) => b -> [b] -> Maybe Int
19:12:23 <SamB> what a distinctly odd type
19:12:35 <humasect> @hoogle [a] -> a
19:12:37 <lambdabot> Prelude.product :: Num a => [a] -> a
19:12:37 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
19:12:37 <lambdabot> Prelude.last :: [a] -> a
19:12:52 <humasect> hm no first/
19:13:04 <Lemmih> @type head
19:13:05 <lambdabot> forall a. [a] -> a
19:13:13 <humasect> m thanks
19:13:25 * SamB remembers again that he can't use the results of functions in pattern matching
19:13:40 <dave_m> Does Hoogle only show the first three results?
19:15:36 <TheHunter> @hoogle+
19:15:37 <lambdabot> Prelude.sum :: Num a => [a] -> a
19:15:37 <lambdabot> Prelude.head :: [a] -> a
19:15:37 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
19:17:31 <humasect> o_o
19:39:37 <newsham> blah I dont understand how to use the random number package (I'm not very hip to the monads yet)
19:40:07 <newsham> how can I get a single (or a finite list of) random values?
19:41:18 <dons> Random.getStdRandom (0,10)
19:41:20 <dons> iirc
19:41:33 <TheHunter> @docs System.Random
19:41:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
19:42:09 <TheHunter> do
19:42:40 <newsham> already read that
19:44:08 <TheHunter>   gen <- getStdRandom
19:44:08 <TheHunter>   let rs = ramdomRs (0,10) gen
19:44:08 <TheHunter>   ...
19:45:58 <newsham> Poker> do {g <- getStdRandom; r <- randomRs (0,10) g; return r }
19:46:05 <TheHunter> i needed it to produce the example.
19:48:41 <newsham> *sigh*
19:50:45 <TheHunter> do {g <- getStdRandom; return $ randomRs (0,10) g } ?
19:52:08 <newsham> i have no idea what that means, also it doesnt work at my cmd prompt
19:52:39 <TheHunter> yeah, it doesn't work at the ghci prompt.
19:52:50 <TheHunter> try do {g <- getStdRandom; print $ randomRs (0,10) g }
19:53:04 <newsham> ERROR - Type error in final generator
19:53:04 <newsham> *** Term           : print $ randomRs (0,10) g
19:53:04 <newsham> *** Type           : IO ()
19:53:04 <newsham> *** Does not match : (StdGen -> (a,StdGen)) -> b
19:53:15 <TheHunter> get ghci.
19:53:36 <newsham> not useful.
19:53:56 <TheHunter> oh, it needs to be getStdGen.
19:54:26 <newsham> unresolved overloading
19:54:38 <newsham> what is "print $ ..." ?
19:54:58 <TheHunter> it prints the list of random numbers.
19:55:45 <TheHunter> this even works with hugs: do g <- getStdGen; print $ randomRs (0::Int,10) g
19:56:12 <humasect> ~_~
19:56:34 <newsham> ok now can I have it return something instead of printing something?
19:57:21 <TheHunter> actually, it can't.
19:57:26 <newsham> I want for example a function that returns a list of random integers
19:57:56 <TheHunter> @wiki ThatAnnoyingIOType
19:57:57 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIOType
19:58:23 <dons> Prelude Random> let f = getStdGen >>= return . randomRs (0::Int,10)
19:58:23 <dons> Prelude Random> :t f
19:58:23 <dons> f :: IO [Int]
19:58:23 <dons> Prelude Random> f >>= return . take 10
19:58:23 <dons> [9,3,7,10,10,10,2,5,6,4]
19:58:26 <TheHunter> probably the easiest thing to do is to create a list of random numbers in the main function, and then pass it down to whatever function needs random numbers
20:01:46 <TheHunter> the reason i suggested to use ghci is that you can do
20:02:06 <TheHunter> 'g <- getStdGen' at the prompt and then use g as a pure value from there.
20:02:27 <newsham> randomList :: Int -> Int -> IO [Int]
20:02:28 <newsham> randomList n m = let f = getStdGen >>= return . randomRs (0::Int,m) in
20:02:28 <newsham>         f >>= return . take n
20:02:44 <newsham> not quite working (no errors compiling, but doesnt output when I run "randomList 5 10")
20:03:03 <humasect> have to use the value. (like print )
20:03:34 <liyang> If you're okay with non-standard (who are we kidding here, GHC *is* the standard) type extensions, you can use linear implicit parameters to make the code read a lot nicer.
20:03:51 <newsham> i'm using hugs
20:04:06 <dons> excet noone except TheHunter likes implicit parameters ;)
20:04:29 <newsham> so its not possible to make a function that returns a random list?
20:04:41 <liyang> Not a pure one in any case.
20:05:44 <TheHunter> a function must always the same value when given the same argument.
20:05:46 <liyang> At least, only pseudorandom.
20:06:01 <Korollary> a sentence must a verb
20:07:05 <liyang> You could write a function, which given some initial seed, produces a sequence of numbers that /looked/ random.
20:07:31 <TheHunter> *return
20:07:35 <liyang> Korollary: clear from context. ;)
20:08:09 * Korollary torments TheHunter
20:11:11 <newsham> a sentance does not need a verb.
20:12:29 <Korollary> or proper spelling
20:12:42 <humasect> needing
20:13:12 <liyang> noe dis is teh fuchur ov ingerlisch
20:13:51 <liyang> Damn. I used a verb.
20:19:37 <newsham> how can I make a "main :: IO ()" that prints a list of 5 random values?
20:21:14 <Korollary> your function returns an IO [Int], right ? how about do { myRands <- yourFunc; putStr $ show myRands }
20:21:48 <newsham> what is "putStr $ show myRands" (in particular the dollar symbol)
20:22:04 <liyang> main = randomList 5 m >>= print would also work
20:22:19 <liyang> f $ x = f x
20:22:25 <newsham> liyang: what is the "m"?
20:22:43 <liyang> newsham: dunno. You defined randomList yourself. ;)
20:22:45 <Korollary> it's "putStr (show myRands)"
20:22:55 <newsham> putStr $ show Myrands = putStr (show myRands)  ?
20:22:58 <liyang> Because the way $ associates, it's effectively what Korollary just said there.
20:22:59 <Korollary> yes
20:23:00 <newsham> ok.
20:23:08 <newsham> thats a useful operator
20:23:39 <newsham> can you use $ to apply lists as arguments to functions?
20:24:01 <Korollary> yeah
20:24:13 <newsham> neat, I needed that earlier but not enough to look it up
20:24:21 <Korollary> why did you need it ?
20:24:44 <newsham> constructor taking 5 arguments, had the requisite data in a list
20:25:04 <newsham> I did it with pattern matching/deconstruction
20:25:05 <liyang> nope, that won't work...
20:25:31 <Korollary> umm, we never really "need" the $. We use it to reduce the number of parens we need to type for some expressions.
20:25:38 <liyang> You never(?) /need/ $ as it were. It just makes things easier to read.
20:25:48 <humasect> and/or write
20:26:05 <liyang> :)
20:30:35 <newsham> randomList :: Int -> Int -> IO [Int]
20:30:35 <newsham> randomList n m = let f = getStdGen >>= return . randomRs (0,m) in
20:30:35 <newsham>         f >>= return . take n
20:30:35 <newsham> main :: IO ()
20:30:35 <newsham> main = myRands <- randomList 5 10
20:30:36 <newsham>         putStr (show myRands)
20:30:38 <newsham> dont work
20:30:50 <newsham> doesnt like the "<-"
20:31:10 <newsham> oops, forgot do
20:35:08 <liyang> I usually indent it like:
20:35:10 <liyang> main = do
20:35:18 <liyang>   foo <- bar
20:35:19 <liyang>   thing
20:35:42 <Korollary> but your style is no match for my pink foreground !
20:35:50 <newsham> how can I do this all in main with no aux function.   something like:   do { g<-getStdGen; r<-randomRs (0,10) g; putStr $ show $ take 5 r }
20:35:51 <liyang> O.o
20:36:47 <humasect> ^_^;
20:37:52 <liyang> newsham: that looks like it ought to work.
20:37:54 <Pete_I> hmm, stuff reminds me of perl.
20:37:59 <humasect> i picked up a style from someone, something about 2 spaces and more newlines than "regularily"
20:38:06 <humasect> so far.
20:38:34 <newsham> liyang: i get a syntax error onthe "<-"
20:38:55 <newsham> (the second one)
20:40:43 <newsham> hmm, I added semicolons and now its not complaining, but there's a type error
20:40:58 <liyang> oh, because randomRs not in the IO monad.
20:41:08 <liyang> (?)
20:41:21 <newsham> ERROR "poker.hs":206 - Type error in generator
20:41:21 <newsham> *** Term           : randomRs (0,10) g
20:41:21 <newsham> *** Type           : [Int]
20:41:21 <newsham> *** Does not match : IO a
20:41:46 <humasect> how would i organize something like this: (leaf (branch tree)) into something more like: ((tree branch) leaf) ? (which operator, '.'?)
20:42:24 <liyang> newsham: do { g<-getStdGen; let r = randomRs (0,10) g; putStr $ show $ take 5 r }
20:43:11 <newsham> that worked (with added "in" keyword).  Can you explain the sublety?
20:43:41 <humasect> @type (.)
20:43:41 <liyang> You shouldn't need `in' if it's do notation...
20:43:43 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
20:43:59 <newsham> ERROR "poker.hs":210 - Last generator in do {...} must be an expression
20:44:01 <newsham> without "in"
20:44:13 <liyang> huh?
20:44:16 * liyang tries.
20:44:24 <humasect> use return (take 5 r)
20:44:43 <newsham> putStr $ show $ return (take 5 r) ?
20:44:46 <humasect> yes
20:45:34 <newsham> human: i cant get that to work
20:45:53 <Korollary> lol
20:46:31 <newsham> I appreciate your help with this.  can someone explain why using a "let" makes it work vs using a "r <-"
20:46:58 <liyang> newsham: this ought to work; I can't explain why the braces style doesn't though...
20:47:06 <liyang> main = do
20:47:16 <liyang>   g <- getStdGen
20:47:25 <liyang>   let r = randomRs (0, 10) g
20:47:34 <liyang>   putStr $ show $ take 5 r
20:48:05 <newsham> liyang: that doesnt work here in hugs unless I add "in" for the let
20:48:52 <newsham> ok, so if its in the IO monad I have to use the "a <- b" form and if its not I use a let binding?
20:49:56 <liyang> Yup.
20:50:07 <liyang> Um... what I just typed there does work in /my/ Hugs...
20:50:21 <Korollary> newsham: <- is syntactic sugar. You can read about it here: http://www.nomaware.com/monads/html/class.html#donotation
20:50:37 <liyang> (okay, not quite. I needed a :: [Int] at the end of the let line.)
20:51:31 <newsham> anyone know if there's a way to start off with a random seed?
20:51:33 <humasect> @libsrc (.)
20:51:34 <lambdabot> (.) not available
20:52:28 <newsham> kor: thanks, I read some of this in the 'gently introduction' earlier, but it hasnt completely sunk in yet.
20:52:45 <dons> does Cabal know that if I generate a .h file from a foreign export, it should install that as a header file in a pkg/include directory?
20:53:34 <newsham> ``let clauses in do blocks do not use the "in" keyword''
20:53:38 <newsham> I guess hugs is nonstandard :)
20:53:41 <Korollary> newsham: There's a function named mkStdGen where you can supply your seed.
20:53:55 <dons> newsham, let clauses without 'in' is standard in do blocks
20:53:57 <newsham> yes, but I dont want to provide a seed.  I want a unique seed for each invocation
20:54:06 <humasect> supply your seed..
20:54:14 <Korollary> ok ok
20:54:23 <newsham> huma: you just misunderstood the whole question.
20:54:25 <Korollary> I love Friday nights
20:54:33 <newsham> I am aksing if there is a way to get a generator that is randomly seeded
20:54:36 <newsham> providing my own is not random
20:54:50 <humasect> (@koro)
20:55:13 <humasect> mkStdGen needs your seed supply, call now, etc etc
20:55:22 <liyang> dons: but what about the do notation in braces? I thought the two forms were pretty much a straight newline <-> ; translation.
20:55:25 <newsham> yes.. so is there a way to get a random seed from elsewhere
20:55:29 <Korollary> I think the default is already randomly seeded using current time.
20:55:30 <newsham> or another api call
20:55:53 <newsham> main --> [8,0,0,9,4]
20:55:58 <newsham> main --> [8,0,0,9,4]  (second invocation)
20:56:21 <Korollary> you can use current time as the seed
20:56:31 <newsham> (if I restart hugs I get a new seed)
20:56:33 <newsham> I guess this will do
20:56:45 <dons> braces and layout styles are separate to do notation completely. braces/newlines are processed by the lexer
20:57:23 <liyang> Hrm...
21:01:16 <liyang> I feel that violates the principle of least surprise somehow.
21:01:27 <Korollary> what does ?
21:01:43 <liyang> The braces / do block notation.
21:02:09 <Korollary> lexer ninjitsu
21:03:00 <liyang> It's spelt ninjutsu, but what are you on about?
21:03:04 <dons> I don't understand what the problem is. Can you clarify?
21:03:29 <liyang> Not a major problem as opposed to a slight annoyance.
21:03:50 <Korollary> it's indeed spelled as such. thanks.
21:06:18 <liyang> The braces do notation seems identical to the block do notation, only that we write ; instead of newlines in the former (and put braces around the whole thing). With the exception of let bindings...
21:10:09 <dons> you can use { } notation anywhere
21:10:14 <dons> not just in do block
21:10:22 <dons> module F where { ... ; ; ; }
21:10:51 <dons> so its not surprising I think, as { ;; } notation is a general alternative to layout-based newline notation
21:11:05 <dons> and not a weird thing just for do-code
21:11:24 <mwc_> dons, indeed, the report specifies how layout is TRANSFORMED into { ; } form
21:11:32 <mwc_> { ; } form is the native haskell format
21:11:58 <dons> exactly. this was my comment about the lexer handling the insertion of explicit ; where the users writes \n
21:12:23 <liyang> I see.
21:14:13 <dons> consider, for example, http://www.cse.unsw.edu.au/~dons/pretty.html
21:17:08 <dave_m> dons: wow. It took me a moment to realize I wasn't looking at the result of some encoding error
21:17:10 * liyang looks and feels ill.
21:18:03 <dons> haskell is truly a beautiful language
21:18:51 <liyang> Hugs doesn't like it. ;)
21:18:59 <liyang> (ghci is fine though.)
21:19:12 <dons> hugs doesn't like it?
21:19:13 <liyang> ERROR "poo.hs":15 - Syntax error in declaration (unexpected `(')
21:19:37 <dons> hmmm. I wonder if its a bug in hugs' Haskell98 conformity?
21:20:12 * dons checks
21:20:40 <resiak> dons: That is truly horrible.
21:22:47 <humasect> sometimes i start where's at column 0 for haskell-mode function decl/def highlight
21:23:10 <dons> well, ghc and nhc accept it
21:23:15 <dons> I wonder what hugs is up to?
21:35:43 <newsham> ok, so I have a function "shuffleDeck" which works right, but if I try to declare its type I get an error.
21:35:47 <newsham> -- shuffleDeck :: [Card] -> (IO StdGen) -> [Card]
21:36:20 <Korollary> I am pretty sure that it's not really its type
21:36:33 <newsham> shuffleDeck d g = shuffle d r where
21:36:33 <newsham>         dl = (length d) - 1
21:36:33 <newsham>         r = [head $ randomRs (0,dl-n) g | n<-[0 .. dl-1]]
21:36:43 <newsham> shuffleDeck :: RandomGen a => [b] -> a -> [b]
21:37:02 <humasect> -> StdGen a -> ?
21:38:20 <newsham> getStdGen :: IO StdGen
21:38:34 <humasect> -> StdGen ->
21:38:50 <humasect> the IO "goes away" once you've <-'d it
21:38:51 <newsham> shuffleDeck :: [Card] -> StdGen -> [Card]
21:38:56 <newsham> that worked.  tada. thanks
21:40:37 <humasect> yay
21:46:02 <exe> Ciao, besitos.
22:30:49 <liyang> dons: btw, the program in pretty.html is buggy...
22:31:09 <liyang> At least, it doesn't do what I imagine it should.
22:31:29 <dons> i don't even remember what it was supposed to do :}
22:31:44 <dons> it's really more an illustration of a particular programming style ;)
22:31:52 <liyang> Running it on /usr/share/dict/words, speak and peaks aren't placed together, at least for me.
22:32:03 <liyang> ah. I was bored and demangled it.
22:32:07 <dons> yeah, it was something along those lines.
22:32:25 <dons> basically, I replaced all keywords with equivalent lambda expressions. then obfuscated identifiers.
22:32:29 <liyang> Fixed it using Data.Set instead of Data.HashTable though.
22:32:34 <dons> ah! interesting.
22:32:38 <dons> care to send a patch?
22:32:39 <liyang> dons: manually?
22:32:48 <dons> send your version
22:32:58 <liyang> dons: I can send you the non-obfuscated version... <_<
22:32:58 <dons> dons at cse dot unsw dot edu dot au
22:33:03 <dons> sure.
22:33:08 <liyang> Sure, one sec. :)
22:33:12 <dons> HashTable is evil anyway, and no one uses it
22:33:22 * dons hopes JaffaCake isn't watching
22:33:33 <liyang> Heh.
22:34:27 <dons> Lemmih, I've finally properly cabalised hs-plugins. Fingers crossed it meets your approval.
22:34:45 <dons> runhaskell Setup.hs {configure, build, install}
22:34:52 <Lemmih> How did you do it?
22:36:23 <dons> well, moved src/* into ./ ; changed the style to the build style that calls configure.
22:36:38 <dons> that's about it. oh. bunch of other little tweaks, but nothing major
22:36:54 <Lemmih> How did you handle the optional dependency on hsx?
22:36:56 <dons> and i removed support for C calling haskell. but ii don't think anyone uses that
22:37:05 <dons> same as with fsp.
22:37:14 <dons> two cabal files. you ln -s the one your want
22:37:17 <dons> before you build
22:40:10 <Lemmih> I'm in trouble... forgot my second appointment with the drafting center );
23:01:03 <Lemmih> dons: Why did you move src/ to ./?
23:15:23 <humasect> how would i write something on the order of: ((tree branch leaf) if it is (leaf (tree branch))? it seems this is what the . operator could be used for.
23:16:40 <Lemmih> '(tree branch leaf)'?
23:17:08 <humasect> i want to organize record access functions in revers
23:31:26 <dons> Lemmih, oh, would the cabal file understand src/-relative paths?
23:31:40 <dons> i just assumed it couldn't
23:32:04 <Lemmih> You can set 'Hs-source-dirs: src'
23:32:15 <dons> cheers.
23:32:18 <dons> wil ldo so
23:39:26 <dons> Lemmih, btw, if you are playing around with this ghci-eval stuff, I'm keen to have a ghci-based Eval.Haskell in hs-plugins
23:39:50 <dons> it would be essential for quick scripting in Yi, for one.
23:41:04 * luqui wrote his first monad transform today
23:41:30 <humasect> grats.
23:41:42 * luqui feels proud :-)
23:43:13 <humasect> =D
23:43:16 <Lemmih> dons: The GHC library might be a bit heavy for hs-plugins.
23:43:57 <dons> certainly an optional dependency
23:44:20 <dons> it would be interesting just for its research value
23:46:46 * Lemmih would like take a couple of years out of his calendar to re-design the GHC library as a library instead of an application with no 'main'.
23:48:06 <dons> thiis is called a PhD
23:48:37 <liyang> Heh.
23:50:16 <dons> Lemmih, finally we have hs-plugins haddocks online: http://www.cse.unsw.edu.au/~dons/hs-plugins/html/
23:51:29 <Lemmih> Neat.
23:51:59 <dons> just have to improve the docs a bit :/
23:52:08 <dons> as the quality isn't so high, atm
