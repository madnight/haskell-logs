00:13:47 <C-Keen> good morning.
00:16:55 <adept> morning
00:32:18 <autrijus> dons: where are you? come find me and claim your t-shirt
00:32:36 <knobo> A Gentle Introduction to Haskell -- Is that suppose to be a joke?
00:32:41 <autrijus> yes.
00:32:45 * Matt-W wonders if he actually just started his PhD or if he's suffering from hallucinations
00:32:47 <autrijus> a crude, bad, sadistic one
00:32:54 <knobo> shuld be brutal intro.
00:33:07 <Matt-W> Is it possible to gently introduce people to Haskell?
00:33:07 <autrijus> knobo: try http://www.haskell.org/~pairwise/intro/intro.html http://www.isi.edu/~hdaume/htut/
00:33:07 <C-Keen> indeed.
00:33:54 <knobo> Yet Another Haskell Tutorial is good. I have read 100 pages of it :)
00:34:06 <autrijus> knobo: the pairwise one is helpful too if a bit sparse
00:34:32 <knobo> What makes you think I know C?
00:34:51 <autrijus> I don't think such things
00:34:59 <knobo> good :)
00:35:30 <knobo> actualy I know a bit C but I never use it.
00:35:35 <cjs_> Ah, I'm just on the exercises of Chapter 3.
00:35:43 <sieni> Matt-W: wait until you see all the burnout induced hallucinations just before getting your Ph.D.
00:36:07 <cjs_> I've also read the first couple of chapters of The Haskell School of Design, which I rather like, despite my lack of interest in multimedia.
00:36:14 <Matt-W> sieni: I'm saving those for thesis write-up time
00:36:58 <Matt-W> at the moment I'm looking into the possibility of wrangling my project into something to do with Haskell :-)
00:37:48 <cjs_> Would I really want to bother with "Haskell for C Programmers"? I quite dislike C. I like Smalltalk.
00:38:53 <autrijus> cjs_: if you are versed in smalltalk, "Gentle" introduction may make more sense
00:39:07 <autrijus> but the pairwise one might still be helpful
00:39:12 <ski> different gospel variants for different crowds, i guess :)
00:39:27 <dons> autrijus, ping
00:39:38 <dons> i'm at the back right of the room ;)
00:39:52 <Cale> autrijus: so your new type system extension will appear in the next ghc?
00:40:32 <autrijus> Cale: aye, in 6.5 I think
00:40:37 <Cale> cool
00:40:37 <autrijus> I need to polish the updator a bit
00:40:41 <autrijus> but otherwise it's looking good
00:42:42 <cjs_> Actually, this "Gentle Intro" looks to be excellent. Albeit maybe it's only gentle to someone with a bit of Scheme or something.
00:43:42 <autrijus> the "Gentle" is only in comparison with the language definition in the report.
00:44:26 <sieni> cjs_: It would be gentler, if Haskell had a sane syntax, like Scheme has ;-)
00:44:27 <cjs_> Ah. It's probably for people like me, then. I quite enjoyed reading R5RS.
00:45:00 <autrijus> so, who was the one presenting Dazzle? Martijn or Arjan?
00:45:13 <cjs_> Yeah, I rather like Scheme's syntax, or lack thereof. Very little to stumble over. Haskell's syntax is one of the things that put me off learning it for quite a while.
00:47:29 <cjs_> But then I read that paper on the concurrency thing in Haskell, and I was blown away.
00:47:59 <autrijus> haskell also has no syntax :)
00:48:04 <autrijus> or rather, very little
00:48:30 <autrijus> (you can (write (scheme)) in (haskell) (quite easily))
00:49:30 <cjs_> Haskell has enough to stumble over, at least for beginners. The use of parens seems....odd.
00:49:42 <cjs_> Maybe I just didn't find a proper, complete description of it.
00:50:41 <Lemmih> knobo: No, it's not a joke.
00:50:44 <Cale> odd?
00:51:00 <Cale> the use of parens is fairly regular -- they're only used for grouping
00:51:17 <Cale> (and for tuples)
00:51:21 <ski> (and for tuples)
00:51:26 <ski> heh
00:51:29 <autrijus> (and for pattern matches)
00:51:39 <basti_> thats grouping again
00:51:41 <Cale> well, there it's for grouping too
00:51:41 <ski> autrijus : ?
00:51:54 <autrijus> foo@(Blah _ _)
00:51:55 <Heffalump> Haskell has enough syntax that embedding DSLs with their own syntax is usually hard work.
00:51:57 <autrijus> yeah, I guess.
00:52:22 <autrijus> Heffalump: TH helps a lot though
00:52:23 <ski> foo@Nothing  is just fine
00:52:27 * autrijus *heart* TH
00:52:31 <Heffalump> has anyone actually used TH for a EDSL?
00:52:36 <Cale> foo@(Blah {})
00:52:37 <autrijus> ...me
00:52:44 <autrijus> for openafp
00:52:55 <Heffalump> my general impression of TH is that it has so many implementation-driven restrictions that it is hard to do anything useful with it
00:52:58 <Heffalump> got a URL?
00:53:04 <autrijus> sure, sec
00:53:50 <autrijus> hm, actually I dropped it in favour of a perl5-based TH solution after the great 6.4 transition
00:53:57 <autrijus> so maybe it's not that great an example ;)
00:53:58 <cjs_> Darn. I really like DSLs. It's what's killing me in ruby; it can be done, and it looks great in the end, but writing the DSL itself can be pretty tough.
00:54:31 <Heffalump> cjs_: if you don't mind your DSL following the syntax of Haskell, you'll be fine.
00:54:42 <Heffalump> you just don't get completely free choice.
01:00:01 <metaperl> whee is the best place to read on how newtype differs from data? SJT says newtype is more efficient and that's the only difference
01:00:07 <metaperl> in Chapter 16
01:00:28 <Cale> In the Haskell Report
01:00:38 <metaperl> too mathematical  for me I think
01:00:44 <Cale> that's not quite the only difference
01:00:59 <Heffalump> it has different strictness properties.
01:01:04 <Cale> basically newtype gives you a new type which is implemented using an existing type
01:01:08 <metaperl> newtype is not widely used from what I can see
01:01:16 <Cale> oh, it's used a lot
01:01:20 <Heffalump> newtype Foo = Foo Bar is almost like data Foo = Foo !Bar
01:01:23 <cjs_> Oh, this is what I needed! http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html
01:01:28 <autrijus> the Righteousness talk is on!
01:01:28 <Heffalump> with one subtle difference you probably don't need to know about.
01:01:41 <Heffalump> metaperl: it is used a lot.
01:01:46 <autrijus> (that's what the chinese character in the middle of the screen means)
01:02:09 <autrijus> (it also means "semantics", which is also appropriate)
01:03:09 <Cale> Basically, data Foo = Foo Integer will give you values which have a little tag to match against "Foo", so for example, you can write f (Foo _) = 5 and f (Foo undefined) will not fail.
01:03:55 <Cale> but if you had defined it with a newtype, Foo would have exactly the same internal implementation as Integer, and so you couldn't match against the tag like that
01:04:18 <metaperl> I thought the double list queue implementation in SJT was neat.. Okasaki is/was a very clever person
01:05:17 <ski> (Cale : i thought the tag-match would be a noop with newtypes ..)
01:05:55 <ski> metaperl : i actually think that double list queue implementation comes from the FP folklore .. not Okasaki
01:06:12 <Cale> well, I sure hope Okasaki is still alive, he posts to the Haskell mailing list from time to time :)
01:07:11 <cjs_> autrijus: it also means "in-law," in Japanese.
01:07:18 <autrijus> cjs_: in Chinese too.
01:07:26 <metaperl> ski: i see
01:07:33 <Cale> oh, hmm...
01:08:22 <Cale> oh, yeah, that example was bad
01:08:23 <ski> (Cale ; i think you managed to trip on the subtle difference Heffalump mentioned ..)
01:08:27 <Cale> yeah
01:09:20 <Cale> It's not different with Foo undefined
01:09:35 <Cale> but with undefined
01:09:42 <Cale> f undefined
01:09:58 <Cale> with the newtype will return 5
01:10:07 <Cale> and with data will fail
01:10:20 <Cale> because you're forcing the evaluation of the constructor
01:10:27 <Cale> right
01:10:30 <autrijus> ...I always thought newtype is just a compiler optimization flag to tell GHC that we can compile the constructor away
01:10:47 <Cale> sorta - it changes the semantics a bit
01:11:25 <ski> with newtype Foo = F Integer,  F _|_ = _|_ and matching on F is a noop
01:11:32 <dblhelix> autrijus: there's (because of that) slightly different pattern matching behaviour, too
01:11:34 <Cale> right
01:11:40 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.3 has the details.
01:13:08 <Cale> newtype also has this nice property that you can derive all classes defined on the type that you're renaming.
01:13:11 <ski> with data Foo = F !Integer,  F _|_ = _|_ and matching on F forces the Integer     <-- is this right ?
01:13:14 <Cale> (but that's a GHC extension)
01:13:33 <Cale> yeah
01:13:35 <Cale> that's right
01:13:41 <autrijus> (suspend-to-disk editor)++
01:13:56 <ski> with data Foo = F Integer,  not (F _|_ = _|_) and matching on F forces the constructor, but not the Integer
01:14:13 <Cale> yeah
01:14:45 <ski> maybe good to have a short summary comparision
01:14:54 <Heffalump> dons is talking about lambdabot now
01:15:04 <Cale> newtype deriving is so incredibly convenient with monad transformers
01:15:37 <Cale> Heffalump: where?
01:15:48 * ski thinks restricted typesynonyms are underappreciated
01:16:15 <Cale> like those given by 'type'?
01:16:17 <Cale> oh
01:16:22 <Cale> restricted?
01:16:45 <ski> yes, only a restricted part of the code knows about what the type expands to
01:16:57 <Cale> ah
01:17:04 <Cale> yeah
01:17:05 <ski> it's a bit like newtype, but without the explicit constructor
01:17:34 <Heffalump> cale: haskell workshop
01:17:42 <Cale> oh
01:17:45 <autrijus> lambdabot: dons is talking about you now
01:17:58 <ski> so, if you have a restricted type Foo = Bar,  then you can internally convert [Foo] to [Bar] without mapping .. etc
01:18:12 <Cale> It would be nice if type synonyms didn't need to take all of their parameters.
01:18:39 <autrijus> Cale: hm?
01:18:43 <autrijus> type Foo = Bar a
01:18:44 <autrijus> like this?
01:19:02 <ski> Cale : it's present in hugs ..  current syntax is like    type Foo = Bar in bleh, boor
01:19:03 <Cale> say you do something like type Foo a b = Bar b a
01:19:44 <Cale> because maybe Bar b is an instance of a class that you have, and Foo a is an instance of a different class.
01:20:11 <autrijus> okay...?
01:20:18 <lambdabot> Yay!
01:20:29 <lambdabot> I'm famous!
01:20:32 <ski> @yay
01:20:34 <lambdabot> My mind is making ashtrays in Dayton ...
01:20:50 <autrijus> @yay
01:20:52 <lambdabot> Are we THERE yet?  My MIND is a SUBMARINE!!
01:20:57 <Cale> autrijus: currently, whenever you use a type synonym, you must apply it to all of its parameters
01:21:13 <autrijus> Cale: oh, you mean it can't be used in a curried fashion
01:21:17 <Cale> right
01:22:24 <autrijus> hm, give me a minimal example?
01:22:59 <Cale> data Bar b a
01:23:09 <Cale> type Foo a b = Bar b a
01:23:16 <Cale> instance Monad (Foo a) where ...
01:23:19 <autrijus> data Bar a
01:23:19 <autrijus> type Foo a = Bar a
01:23:19 <autrijus> type Baz = Foo
01:23:38 <autrijus> okay, let me see what I can do.
01:24:49 <Cale> well, it essentially amounts to type lambdas
01:24:53 <autrijus> ah, that's because internally it's a TyConApp not a NoteTy
01:25:04 <Cale> er, somewhat restricted perhaps
01:25:11 <autrijus> and the App has its own tc_arity
01:25:32 <autrijus> so over-applying it is okay but it can't be curried yet
01:25:34 <autrijus> fixing
01:26:39 <Cale> If you could add support for type lambdas, that would be really cool
01:26:45 <Cale> :)
01:29:17 <autrijus> hm, need to conjure up a synonym of shape (Foo_a b)
01:29:28 <autrijus> the error message will be fun
01:32:59 <autrijus> Cale: my example works.
01:33:02 <autrijus> now trying yours...
01:33:15 <dons> re
01:33:32 <lambdabot> Hey dons
01:33:42 <autrijus> lambdabot: feeling talkative todya?
01:34:04 <lambdabot> I'm important! I should talk more.
01:34:31 <autrijus> Cale: yours doesn't work because type variables escapes
01:34:31 <autrijus>     Could not deduce (Monad (Bar a1)) from the context (Monad (Foo a))
01:34:42 <autrijus> that means the "b" has to somehow remember it came from "Bar"
01:34:49 <autrijus> thinking (may need to consult wiht spj on this)
01:35:16 * autrijus tickles lambdabot a bit
01:35:42 <Cale> autrijus: ask him about implementing type lambdas as an extension too, they'd be fun to play with :)
01:36:12 <autrijus> Cale: give me an example :)
01:36:19 <autrijus> I need material to check into fptools/testsuite :)
01:36:30 <lambdabot> hehe
01:36:51 <ski> @arr
01:36:52 <lambdabot> Avast!
01:36:59 * autrijus ponders fptools/testsuite/tests/ghc-wishlist
01:37:02 <autrijus> or ghc-todo, or something
01:38:01 <Cale> well, it's similar to what the modified "type" would do, only in-place...  (/\ a b -> (Integer, Foo a [(Char,b)])) is a type constructor which takes a and b in a curried fashion and produces the given type
01:38:52 <autrijus> and /\ is part of syntax?
01:39:24 <autrijus> (/\ (IO a) -> (Maybe a))
01:39:39 * autrijus ponders the implications
01:39:41 <ski> just tyvars, i think
01:39:59 <dblhelix> Cale: I'd say "type-level function" rather than "type constructor"... and reserve "type constructor" for the nominal part of the type language
01:40:01 <autrijus> oh, but then their expressiveness is exactly the same as regular data type?
01:40:13 <Cale> dblhelix: well, yeah :)
01:40:19 <autrijus> or am I missing some cases that ordinary data can't represent?
01:41:05 <Cale> well, formally, I'm not sure
01:41:12 <Heffalump> autrijus: you're making type synonyms partially applicable?
01:41:18 <autrijus> Heffalump: trying to, yeah
01:41:38 <Heffalump> aren't there some well-known problems with doing that? (just trying to find a reference)
01:41:47 <autrijus> Heffalump: is there some pitfall I'm going to fall into, some soundness I'm going to break?
01:41:59 <Heffalump> just looking
01:42:00 <autrijus> Heffalump: I don't know, I'm new to this language. help me finding such reference will be appreciated :)
01:42:16 <dcoutts> doesn't partially applying type synonyms give you something like type lambdas
01:42:31 <dblhelix> dcoutts: yeah, we were just discussing those
01:42:35 <Heffalump> section 6 of http://www.cse.ogi.edu/~mpj/thih/TypingHaskellInHaskell.html
01:42:45 <Heffalump> >> Extending the type system with higher-order features
01:42:45 <Heffalump> >> (such as lambda expressions on types), or with other
01:42:45 <Heffalump> >> mechanisms that allow reductions or rewriting in the
01:42:45 <Heffalump> >> type language, could make unification undecidable,
01:42:45 <Heffalump> >> non-unitary (meaning that there may not be most
01:42:48 <Heffalump> >> general unifiers), or both. This, for example, is
01:42:50 <Heffalump> >> why Haskell does not allow type synonyms to be
01:42:53 <Heffalump> >> partially applied (and interpreted as some
01:42:55 <Heffalump> >> restricted kind of lambda expression).
01:43:44 <autrijus> trying to imagine an example
01:44:09 <autrijus> mm nontrivial equalities
01:44:53 <autrijus> I see that preserving a1 and a in Cale's example above may lead to non-unitary unification
01:45:02 <dblhelix> I can't imagine you would ever unify partially applied type synonyms... unification is triggered by values and partially applied type synonyms do not have values
01:45:30 <autrijus> dblhelix: in type classes for example?
01:45:50 <dblhelix> well, okay ... if they are used as type arguments to higher-order kinded type constructors
01:46:28 <Cale> yeah, I was aware that there was some kind of problem with it, but I wonder exactly how much one could get without getting into trouble :)
01:46:35 <dblhelix> autrijus: indeed, like higher kinded type classes (such as Monad)
01:47:04 <autrijus> Cale: and indeed the most practical use of curried synonyms will be in instances
01:47:11 <autrijus> where unfication happens
01:48:28 <autrijus> currently pugs solve it in by defining every precurried form
01:48:42 <autrijus> type Eval x = EvalT (ContT Val (ReaderT Env SIO)) x
01:48:42 <autrijus> type EvalMonad = EvalT (ContT Val (ReaderT Env SIO))
01:49:05 <dblhelix> autrijus: yeah, that's common practice
01:49:09 <autrijus> I wonder if it's possible for the compiler to pregenerate such arities
01:49:39 <autrijus> I mean, when I write
01:49:42 <autrijus> type Foo a b = Bar b a
01:49:58 <autrijus> it generates Foo_ and Foo_a_ for me
01:50:03 <autrijus> (internally of course)
01:50:36 <autrijus> and substitute those forms whenever an arity mismatch happens
01:50:37 <autrijus> I think
01:50:47 <autrijus> am I on crack?
01:51:15 <Heffalump> how is Foo_ defined?
01:51:19 <Heffalump> You need lambda on types to do it
01:51:24 <dblhelix> you can't write Foo_
01:51:25 <autrijus> Heffalump: it's internally defined
01:51:27 <dblhelix> ah, indeed
01:51:32 <autrijus> it's never exposed to surface syntax
01:51:38 <Heffalump> but it's equivalent to it..
01:51:40 <Igloo> It should be possible for the case that annoys me
01:51:52 <autrijus> Igloo: mm?
01:52:09 <dblhelix> autrijus: yeah, but then the problem still exists, just internally
01:52:18 <Igloo> Wher I can't say MyMonad' = StateT Int MyMonad a without copying and pasting the defn of MyMonad
01:52:21 <autrijus> dblhelix: yes, but I mean, instead of proceed during unification
01:52:30 <autrijus> dblhelix: we proceed first during the renamer
01:52:58 * dblhelix thinks
01:53:09 <autrijus> so the curried forms are pregenerated instead of searched during unification
01:53:21 <autrijus> not sure if that would work
01:53:57 * autrijus needs to experiment and see
02:07:01 <autrijus> Igloo: I think it's possible to safely fix the use of curried type synonyms in other type synonyms
02:07:07 <autrijus> but not in instances
02:07:40 <autrijus> that will still be a step forward though.
02:11:10 <autrijus> Igloo: just to make sure... you mean this, right?
02:11:11 <autrijus> newtype ReaderT r m a = ReaderT { runReaderT :: (r -> m a) }
02:11:12 <autrijus> type MyMonad a = ReaderT () Maybe a
02:11:12 <autrijus> type YourMonad = ReaderT () MyMonad
02:12:47 <autrijus> so type-lambdaish use (type Flip a b = Flop b a) will be rejected, but the normal shorthand is allowed
02:13:06 <autrijus> it works on my laptop now :)
02:13:14 <Heffalump> but don't you still need to unify lambda-expressions to deal with that?
02:13:51 <Heffalump> there may be a trivial implementation in terms of eta-expansion, but it's not obvious to me that you can distinguish your Flip example from Igloo's example
02:14:16 <autrijus> the Flip example has ununified "a" and "a" after check of tau types
02:14:21 <autrijus> we just don't unify them
02:14:33 <autrijus> it's as if you had written (type Flip a b = Flop b c)
02:14:40 <autrijus> which is a normal rejection
02:15:03 <autrijus> it sounds hacky but is what I currently have
02:15:06 <autrijus> better suggestions welcome
02:16:00 <Heffalump> errm, isn't that just wrong?
02:16:39 <Heffalump> hacking the type system so that it doesn't have a proper sepcification isn't really a good idea :-)
02:16:54 <autrijus> I think this can be specced...
02:17:09 <autrijus> if you fully apply "a" and "b" to Flip then it behaves correctly
02:17:25 <autrijus> but if you apply it partially then there's no attempt at recovering the non-mentioned parts
02:17:38 <autrijus> outside type synonym definitions
02:17:46 <autrijus> I agree it feels 1)messy 2)wrong
02:19:27 <Heffalump> "it behaves correctly in situation x and unpredictably in situation y" isn't much of a spec
02:20:01 <autrijus> "it predicably breaks down in situation y in this way"
02:20:12 <autrijus> but hey, I think we are in vehement agreement anyway :)
02:20:23 * autrijus tries to think of better ways
02:20:30 <dons> greek symbols are good for this purpose. see for example the careful adjustments made in the associated types paper to check that it's safe to add to ghc.
02:20:39 <ChronoWiz> doesn't having all the IO stuff make haskell not strictly functional?
02:20:54 <autrijus> ChronoWiz: we are lazily functional, not strictly functional
02:21:04 <Heffalump> ChronoWiz: no, because the IO is handled in a way that embeds it within a pure type system
02:21:08 <autrijus> ChronoWiz: but the IO stuff is still very much functional.
02:21:25 <cjs_> Heh, you want to be careful with the term "strict" around here.
02:21:56 <cjs_> Do you mean strict as in "not loose" or "not lazy"?
02:22:14 <Heffalump> ChronoWiz: IO is modelled in Haskell by passing around an imaginary "RealWorld" token, which can't be duplicated.
02:22:22 <Heffalump> (the compiler eliminates this, of course)
02:22:35 <cjs_> Wow, what a great way of putting it!
02:22:57 <Heffalump> cjs_: which?
02:23:17 <cjs_> The 'imaginary "RealWorld" token' thing.
02:23:31 <ChronoWiz> hmm well our lecturer was saying it is functional as in it is mathematically sound
02:23:39 <ChronoWiz> as in f(x) is always equal to f(x)
02:23:49 <Heffalump> ChronoWiz: that's a common definition of 'functional', yes.
02:23:57 <Heffalump> (It's also known as referential transparency)
02:24:04 <Heffalump> [who is your lecturer, btw? Manuel?]
02:24:24 <ChronoWiz> but with IO you can have it do extra things apart from just taking arguments and returning normally..
02:24:27 <dons> don't think so. hmm. maybe??
02:24:32 <ChronoWiz> this guy named Tony Wirth
02:24:33 <dons> ChronoWiz, you at unsw?
02:24:36 <ChronoWiz> unimelb
02:24:37 <dons> ah, guess not
02:24:51 <ChronoWiz> my tutor is Bernie Pope.. he seems to know more about it than the lecturer
02:25:02 <Heffalump> ChronoWiz: right, but the type system specifies a function that does IO as being of type RealWorld -> (RealWorld, x)
02:25:06 <dons> yeah, Bernie's a great Haskell hacker.
02:25:12 <Heffalump> and the second time you call it, you get a different RealWorld input
02:25:16 <Heffalump> cos the real world changes
02:25:27 <autrijus> newtype IO a = IO (State RealWorld -> (State RealWorld, a))
02:25:28 <ChronoWiz> ah ok
02:25:42 <autrijus> modulo the unboxiness
02:25:47 <ChronoWiz> but then isn't every language functional?
02:25:59 <ChronoWiz> you can call anything a State
02:26:05 <ChronoWiz> State DataInThisFile
02:26:07 <ChronoWiz> etc etc
02:26:10 <Heffalump> no, because most languages don't have a type system that specifies this.
02:26:25 <Heffalump> Haskell makes it an explicit part of the type system, so that when you *don't* have state, you can tell.
02:26:32 <Heffalump> so f :: Int -> Int really is pure
02:26:49 <ChronoWiz> ah i see, it only uses exactly what you specify
02:27:02 <Heffalump> f :: Int -> IO Int [which is equivalent to f :: (RealWorld, Int) -> (RealWorld, Int) ] isn't.
02:27:15 <autrijus> so you can't, for example, destructively update things during f
02:27:20 <autrijus> if it's of type Int->Int
02:28:06 <autrijus> unlike languages that allows you to read from some external database during the evaluation of "f"
02:28:17 <autrijus> which will make f(x) not always equal to f(x).
02:30:16 <ChronoWiz> ok next question :) how do i make a function that uses randomR to return the number as an int?
02:31:05 <ChronoWiz> as it stands i am using do <- which can only return stuff as IO Int
02:32:17 <ChronoWiz> sorry the poor wording of that question probably reflects my poor understanding of the language :)
02:33:18 <autrijus> it's not your fault :)
02:33:43 <autrijus> ChronoWiz: read http://haskell.org/hawiki/ThatAnnoyingIoType
02:33:48 <autrijus> I need to run for lunch now
02:33:56 <ChronoWiz> thanks, enjoy your lunch
02:38:01 <cjs_> Can we have a haskell where you use the shift key a little less?
02:38:35 <dcoutts> cjs_, you mean all lower case types etc
02:38:48 <ChronoWiz> can we have a haskell that doesn't care about whitespace :)?
02:39:05 <dcoutts> ChronoWiz, you can, use the non-layout style
02:39:11 <cjs_> No, types are no problem.
02:39:53 <dcoutts> ChronoWiz, you can use the {  } style rather than layout, but no-one else does :-)
02:40:04 <ChronoWiz> hahah i think i will
02:40:08 <ChronoWiz> just to piss off my markers
02:40:12 <dcoutts> cjs_, which bits are would you say?
02:40:13 <cjs_> It was punctuation, really. Maybe just because it's such different punctuation from OO languages, I can't type it as easily. I expect I'll get used to it.
02:40:18 <ChronoWiz> i'll use literate style or whatever it's called too :)
02:40:26 <dcoutts> ChronoWiz, well that's a good a reason as any
02:40:41 <cjs_> I guess if I got a vim mode it would help with the indentation, too.
02:40:46 <dcoutts> ChronoWiz, well literate style is a good thing (usually)
02:41:21 * dcoutts wants to write a sensable indent mode for hIDE
02:41:28 <ejt> hi, does anyone here have experience of using arrows ?  I'm thinking of using them for writing some automata code and was wondering how hard they'll be to use ?
02:41:36 <ChronoWiz> my vim has a haskell mode...
02:41:42 <cjs_> Oh, particularly annoyiing is "'x'" for a char. Why not just "'x", with the second quote?
02:41:46 * Lemmih wants to know how dcoutts plans on doing that.
02:42:03 <dcoutts> Lemmih, using your CommonSense system! :-)
02:42:23 <dcoutts> or is that not what it's for
02:42:47 <dcoutts> I think it could be done purely lexically by looking at the current line when someone hits enter
02:43:47 <dcoutts> eg indentation for if/then/else and let/in and do should be possible that way
02:44:06 <Lemmih> Right.
02:44:39 <adept> ejt: i'm reading about arrows right now. Still trying to bend my mind around them
02:45:06 <ejt> adept: y, they're a bit of a mindful.  I've been reading the chapter in 'the fun of programming'
02:45:07 <dcoutts> Lemmih, so I wouldn't use the CommonSense system for that then?
02:45:33 <dcoutts> Lemmih, just lex the current/last line and decide on that basis?
02:45:40 <adept> ejt: i'm reading 'extending monads to arrow', what's your source? what's that 'fun of programming'?
02:46:02 <Lemmih> dcoutts: No, it's probably best to do it in CommonSense.
02:46:12 <dcoutts> oh ok, good
02:46:44 <dcoutts> I'm very interested to see this CommonSense :-)
02:47:02 <dcoutts> but just at the moment I'm fixing up the new gui code
02:47:14 <ejt> adept: http://www.amazon.co.uk/exec/obidos/ASIN/0333992857/qid=1128073556/sr=1-6/ref=sr_1_11_6/026-8807112-7182801
02:47:28 <JohnMeacham> did we ever get fptools into darcs?
02:48:04 <ejt> adept: do you have an url for that paper you're reading please ?
02:48:53 <adept> ejt: http://citeseer.ist.psu.edu/hughes98generalising.html
02:49:01 <dcoutts> JohnMeacham, I think there are darcs mirrors around, I'm not quite sure how well they track the master cvs repo or if they're just snapshots
02:49:45 <ejt> adept: thx
02:50:24 <malcolm> Is anyone sitting in on the Haskell Workshop, with a webcam?
02:50:38 <JohnMeacham> ah. well, mainly I want to know if I can make changes and use 'darcs send' such that they will make it back into the main tree.
02:50:43 <adept> ejt: aha. "Arrows and computations" from the book you cited is available online. cool.
02:51:00 <ChronoWiz> getRandom xs = getRandom' xs >>= (\a -> return (a))  .. how can i then use the return value as an Int?
02:51:30 <dcoutts> JohnMeacham, I think at the moment if you darcs send it'll go to someone who might then manualy apply it to the cvs repo
02:51:42 <ChronoWiz> like (getRandom [1..10]) + 1
02:52:28 <ejt> do {r <- getRandom [1..10]; return (r + 1)}
02:52:29 <ChronoWiz> the wikipage says that return is the way to turn something from IO a to just a
02:52:46 <ejt> you can't escape the IO monad
02:52:47 <ChronoWiz> but it won't return it as an int
02:52:50 <dblhelix> ChronoWiz: no, it's the otherway around
02:52:52 <ChronoWiz> i can't escape it!
02:52:53 <ChronoWiz> nooo
02:53:07 <ChronoWiz> so there is no way to get a random number and not have the IO monad
02:53:14 <ejt> think about it
02:53:38 <dblhelix> ChronoWiz: as soon as you're inpure, you can't be turned into something pure... I'm sorry
02:53:57 <ChronoWiz> hmm i'm beginning to understand that now..
03:07:21 * sylvan whispers "don't tell  him about unsafePerformIO"
03:07:48 * ejt whispers: we weren't
03:07:53 <sylvan> =)
03:07:55 <cjs_> ChronoWiz: remember, every function must return the same thing every time it's called with the same parameters.
03:08:50 <cjs_> I'm looking forward to writing unit tests for Haskell programs, because I think that that's going to be a feature that I particularly appreciate.
03:15:04 <Lemmih> Yes! Finally got the interface code right.
03:15:25 <Lemmih> dons, dcoutts: I'm gonna continue to use 6.4.1 and ghc-api.
03:16:59 <aleator> What is ghc-api actually?
03:17:13 <Lemmih> aleator: GHC as a library.
03:18:00 <aleator> Oh. Where can I get it?
03:18:14 <Lemmih> http://scannedinavian.org/~lemmih/ghc-api/
03:18:17 <aleator> Thanks!
03:19:31 <dcoutts> Lemmih, you got what working exaclty?
03:19:35 <Lemmih> (the bytecode generator is currently down)
03:19:44 <dcoutts> that's not a problem
03:19:58 <dcoutts> we don't need ghci like features yet
03:20:41 <Lemmih> dcoutts: The way instances are kept have changed in 6.5
03:21:04 <dcoutts> Lemmih, and you've managed to translate?
03:21:08 <Lemmih> Yep.
03:21:13 <dcoutts> well done
03:21:27 <aleator> Hmm.. scannedinavian.org is down?
03:21:36 <Lemmih> aleator: try scannedinavian.com
03:21:51 <dcoutts> Lemmih, so we can continue to use ghc-6.4.1 .hi files for renaming/typechecking
03:22:33 <dcoutts> not sure if that was a question or statement
03:23:07 <dcoutts> either way, nice work Lemmih :-)
03:23:38 <Lemmih> Moving to 6.5 may be more attractive when 6.6 gets close.
03:23:42 <dcoutts> yes
03:23:51 <dcoutts> and the bugs are fixed :-)
03:24:02 <dcoutts> like the linker things & hs-plugins etc
03:24:28 <dcoutts> and new ghc versions sometimes break gtk2hs
03:28:12 <aleator> So, when should I start looking at ghc-api for ghci-like features?
03:29:52 <Lemmih> It's only the data constructor part of the bytecode generator which is down. You can still run lookups and evaluate expressions.
03:30:05 <Lemmih> You can even run ghci in ghci.
03:30:21 <aleator> Ah.. Neat!
03:30:23 <dcoutts> nice
03:30:34 <dcoutts> so what's the data constructor part?
03:32:44 <lambdabot> eeek! an Isaac! kill!
03:33:10 <dcoutts> lambdabot, now now don't be nasty to SyntaxNinja
03:34:24 <Lemmih> dcoutts: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/rts/StgMiscClosures.cmm?rev=1.8
03:34:38 <Lemmih> dcoutts: That stuff is apparently needed.
03:34:49 * dcoutts takes a look
03:35:23 <dcoutts> Lemmih, and it doesn't work because of?
03:35:42 <Lemmih> It can't access those symbols.
03:35:51 <dcoutts> ah ok
03:37:24 <boegel> shapr: hwo's TMR5 going ?
03:37:27 <Lemmih> It may be possible to implement "jump %RET_VEC(Sp(0),0);" in C if I figure out what it means (:
03:37:28 <boegel> *how's
03:37:56 <dcoutts> Lemmih, we don't need ghci immediatly so I'd wait for JaffaCake to get back and fix the linking issues
03:37:59 <shapr> boegel: On schedule!
03:38:24 <Lemmih> dcoutts: We also have problems with duplicate symbols.
03:38:39 <shapr> boegel: I've been working on my HUnit/QuickCheck article, and there's possibly another article coming from musasabi
03:38:41 <dcoutts> Lemmih, where are we getting duplicates from?
03:39:21 <Lemmih> dcoutts: The ghc package in 6.5 links to hschooks.c which clashes which the hooks in ghci.
03:40:01 <Lemmih> (hschooks gets loaded twice)
03:40:18 <cjs_> BTW, what's the best way to use HUGS? I've been editing a file with my definitions in one window, the in another :load'ing it and calling a function. Then I edit some more, :reload, and call again. It seems a little more awkward than a Scheme REPL, where you can define stuff in the REPL.
03:40:24 <boegel> go musasabi
03:40:32 <boegel> shapr: so that means 6 articles ?
03:40:34 <dcoutts> Lemmih, do we need the hooks if we're not using ghci?
03:40:39 <Cale> cjs_: if you use ghci, you can define stuff with let
03:40:50 <Cale> cjs_: but that's basically the right way to use it
03:41:30 <cjs_> Ok.
03:41:38 <dcoutts> Lemmih, it seems to me that we have plenty of stuff to implement even without interactive evaluation or code generation
03:41:40 <Cale> :re should work for reload
03:41:56 <Cale> maybe that's just in ghci
03:42:15 <dcoutts> Lemmih, just getting error messages in the editor & module dep graphs for project management will be plenty to be getting on with
03:42:22 <Lemmih> dcoutts: Ideally, the hooks shouldn't be linked with the ghc package. They should only be linked with the ghc binary.
03:42:30 <dcoutts> right
03:42:54 <dcoutts> there's quite a lot of simpler stuff that we need to get working well
03:43:07 <dcoutts> the basics need to be solid
03:43:33 <basti_> hey Lemmih do you have some time to give me help how to compile your hspr?
03:44:04 <Lemmih> Sure.
03:44:44 * Lemmih is a bit ashamed to have left hasp is such a sorry state.
03:45:02 <basti_> i talked about it with musasabi, and it seems that you have some RunCGI part that is no longer needed because of FastCGI
03:45:32 <basti_> i had to nudge that a bit to make it build
03:45:44 <Lemmih> RunCGI?
03:46:04 <basti_> HSPR.CGI.RunCGI
03:46:43 <shapr> boegel: maybe
03:46:51 <basti_> musasabi uttered something about that it wouldn't be needed
03:46:55 <Lemmih> basti_: I think you've got HSP there.
03:47:03 <Lemmih> basti_: I'm the author of HASP.
03:47:08 <basti_> :-o
03:47:13 <Lemmih> (:
03:47:29 <pejo> cjs, if you use Haskell there are a couple of modes avail for it. haskell-hugs.el.
03:47:39 <basti_> so. uhm. where and how is hasp?
03:47:40 <basti_> @where HASP
03:47:41 <lambdabot> I know nothing about hasp.
03:47:58 <basti_> i was just trying to get that apache-plugin working
03:47:59 <Lemmih> basti_: http://scannedinavian.com/~lemmih/hsp/
03:48:10 <cjs_> I don't think .el files work in vim. :-)
03:49:40 <basti_> Lemmih: ok. I'll try to build that, then.
03:50:30 <basti_> oh my
03:50:32 <basti_> o.o
03:55:57 <basti_> thats the first time i use a shell script to semiautomatically satisfy dependencies.
03:58:07 <rep> morning
03:58:12 <basti_> Lemmih: i was looking at hswebforms and found that they were all functional, except for actually combining forms... like "the reply of form a is fed into form b"
03:58:45 <dons> re
04:00:19 <boegel> shapr: cool
04:01:00 <basti_> is scannedinavian.org down?
04:03:37 <boegel> basti_: not here
04:04:19 <basti_> bizarro
04:04:35 <basti_> for me its "dest host unreachable"
04:06:45 <Lemmih> hide with the new ghc-api: http://212.242.49.100/instance-aware-hide.png
04:07:17 <dcoutts> nice
04:07:26 <basti_> it's back up
04:07:27 <basti_> strange
04:08:07 <dcoutts> so it can now figure out that's an error because the data T is not an instance of the Monad class
04:08:21 <Lemmih> Yep.
04:08:29 <dcoutts> cool
04:08:48 <basti_> :-o
04:08:49 <dcoutts> so how do we deal with mult-line errors/underlining
04:09:02 <dcoutts> ghc provides one great big span right?
04:09:40 <Heffalump> it would seem so, from the Visual Haskell demo this morning
04:09:51 <Heffalump> the tooltip was wrapped really badly
04:10:10 <dcoutts> Heffalump, but I guess it doesn't underline the spaces between lines
04:10:37 <SyntaxNinja> Lemmih: krasimir mentioned Hackage in his talk, and you were mentioned in the Haskell Server Pages talk.
04:10:45 <Lemmih> :D
04:11:03 <dons> Lemmih, nibro asks if we can compiled a file with ghc-api, say via -fasm
04:11:04 <dons> ?
04:11:25 <Lemmih> dons: Yeah, that should be possible.
04:11:30 <dcoutts> actualyl it'd probably look reasonable to underline the spaces within a line but to not underline the leading and trainling white space on each line of a mult-line error span
04:11:36 <autrijus> Heffalump: so, oleg said he thinks "allow partially-bound type synonyms in type synonym declarations" is relatively sane but can give rise to ambiguities; one way to deal with them is to rule them all as errors. he also suggests me to unearth some 3-years-old discussion about that, so I'll go do that
04:12:11 <dons> Lemmih, then hsp wouldn't need a separate ghc. it'd just need ghc-api + some libs?
04:12:18 <autrijus> dons: have you got my darcs patch?
04:12:36 <dons> hmm. no :/
04:12:42 <dcoutts> Lemmih, have you though about how we display the errors in tooltips? want me to look into it?
04:12:45 <Heffalump> autrijus: so it turns out that Igloo's stated problem is a non-problem, because you can just partially apply the type constructor when making the type synonym originally.
04:12:47 <dons> is it making it off your machine autrijus?
04:13:07 <dons> Lemmih, dcoutts. lots of hIDE questions after the talk :)
04:13:08 <Lemmih> dons: Yeah, I've been toying with that idea for a while (:
04:13:17 <autrijus> Heffalump: but that requires two synonyms for each monadic type
04:13:20 <dcoutts> dons, oh cool :-)
04:13:23 <dcoutts> like what?
04:13:28 <autrijus> as I demoed with "type Eval" and "type EvalMonad"
04:13:34 <autrijus> of arity 0 and 1 respectively
04:13:42 <Lemmih> dcoutts: Errors in tooltips?
04:13:50 <dons> is it ready? where can I get it? it looks cool :)
04:14:19 <autrijus> type MyMonad a = ReaderT () Maybe a
04:14:19 <autrijus> type YourMonad = ReaderT () MyMonad
04:14:21 <autrijus> is my test case
04:14:27 <dcoutts> Lemmih, well you underline the thing in red, then the user moved their mouse over the error and wants to know what's wrong they want to see the error message
04:14:34 <dons> autrijus, is it going to dons@cse.unsw.edu.au?
04:14:43 <autrijus> yeah. I'll send again using normal email
04:14:48 <Heffalump> autrijus: you can just write
04:14:48 <dcoutts> Lemmih, VisualHaskell displays that in a tooltip
04:14:54 <Igloo> autrijus: You can dro the first a's and it works
04:14:54 <Heffalump> type MyMonad = ReaderT () Maybe
04:14:59 <dcoutts> Lemmih, we should probably do the same
04:15:00 <Heffalump> as you said, overapplying is fine.
04:15:09 <Igloo> I just assumedyou had to have things of kind *
04:15:22 <dcoutts> Lemmih, so was going to look at how we'd do that kind of tooltip thing with gtk
04:15:32 <dcoutts> so was/so I was
04:16:05 <dons> Lemmih, btw, how do you get the gtk buffer across to ghc's lexer?
04:16:20 <dons> esp. since it's unicode (?) which the lexer won't handle (?)
04:16:33 <SyntaxNinja> are you guys going to hack something to rival visual haskell by the end of the conference?  they might let you present it, if so :)
04:16:44 <dons> hehe :)
04:16:45 <Heffalump> yeah, hurry up.
04:16:46 <dcoutts> dons, well it's only unicode if the file contains unicode chars
04:16:55 <Heffalump> you've got until 17:30 or so
04:16:56 <dons> ah, true.
04:16:58 <dcoutts> dons, so that's just like any odrinary .hs file
04:17:03 <dons> yep.
04:17:22 <autrijus> Heffalump: I see. I stand corrected
04:17:29 * autrijus goes back hacking in record selectors for existentials
04:17:38 <Heffalump> you do not, you're sitting down
04:17:43 <dons> ah then, if there were unicode chars in the file, we'd have to squish them some how for the lexer to handle
04:17:58 <autrijus> alright. I sit corrected
04:18:01 <dons> autrijus, got it. thenaks
04:18:06 <autrijus> np :)
04:18:18 <autrijus> oh, right, unicode in lexer!
04:18:24 <SyntaxNinja> someone was saying that there is a conference where they display the IRC discussion alongside the speaker
04:18:27 <SyntaxNinja> I think they should do that here ;)
04:18:31 <autrijus> it's in the alex level, right?
04:18:36 <dons> yup
04:18:46 <dons> SyntaxNinja!
04:19:17 <Heffalump> dons!
04:19:21 <dcoutts> dons, I don't see that we have to worry about it any more than we do normally, it's not a problem pecuiar to hIDE
04:19:23 <dons> Heffalump!
04:19:33 <autrijus> dons: the cabal-powered yi-bootloader idea is dropping off my heap now... hopefully it'll remain in your memory
04:19:45 <Heffalump> Igloo!
04:19:49 <dons> yep. i've todo'd it
04:19:51 <autrijus> lambdabot!
04:20:02 <Igloo> Foo!
04:20:05 <lambdabot> autrijus!
04:20:13 <lambdabot> Foo bar!
04:20:16 <dcoutts> dons, I mean it'd be nice to make it more unicode friendly but it's not an immediate priority (in my opinion)
04:20:22 <autrijus> I think lambdabot should give a talk
04:20:25 <lambdabot> Bar foo!
04:20:27 <SyntaxNinja> dons: !
04:20:29 <autrijus> just hook up #haskell to the screen
04:20:36 <autrijus> and have a text-to-speech
04:20:37 <Heffalump> wasn't dons invented just so that lambdabot could do that?
04:20:39 <dons> ok. but we can already read unicode. it's just a matter of making sure the lexer doesn't break if we feed it unicode
04:21:06 <dcoutts> dons, but ghc is going to break as soon as it tries to compile the module anyway
04:21:12 <dons> ah.
04:21:16 <autrijus> it's politically sensitive though. {-# OPTIONS -fencoding=utf8 #-} ?
04:21:26 <autrijus> I mean it's all assumed to be in latin1 now.
04:21:30 <dcoutts> dons, perhaps our lexer should just highlight it as a lexical error
04:21:52 <Heffalump> why is it _politically_ sensitive?
04:21:57 <dcoutts> unless ghc's lexer ignores unicode in {- comments -}
04:22:00 <Heffalump> hi nibro :-)
04:22:04 <dons> oh well. ok. it doesn't matter. but still: how does Lemmih pass the gtk buffer the alex lexer?
04:22:06 <nibro> hi :-)
04:22:14 <autrijus> Heffalump: whenever a notion of "default encoding" arises it becomes political
04:22:18 <autrijus> at least in my experience
04:22:19 <nibro> that's at least three persons using irc in the same room... ;-)
04:22:20 <dcoutts> dons, he does it line be line
04:22:24 <Heffalump> nibro: easily more.
04:22:28 <dons> many more
04:22:33 <autrijus> dcoutts: it does ignore unicode in comments.
04:22:35 <dcoutts> dons, it's easy to extract a span from the buffer
04:22:36 <nibro> aye, I see that in the list :)
04:22:36 <Heffalump> dons, autrijus, Heffalump, Igloo, SyntaxNinja
04:22:41 <Lemmih> dons: I get it as a String and then convert it to a StringBuffer.
04:22:42 <autrijus> dcoutts: Pugs has Tolkien poetry in Chinese all over the place.
04:22:55 <lambdabot> and me!
04:22:55 <dons> Lemmih, hmm. would be nice to kill off that String.
04:23:00 <Lemmih> dons: Indeed.
04:23:03 <dons> so you need a CSTringLen -> StringBuffer.
04:23:07 <dons> roughly
04:23:10 <dcoutts> autrijus, ok that's nice
04:23:12 <autrijus> lambdabot: would you like to give a talk about how you implemented dons?
04:23:14 <Igloo> lambdabot: Liar!
04:23:43 <Heffalump> dons: can your dynamic loading be used to do process migration?
04:23:45 <autrijus> "dynamically overloadable network system"
04:23:49 <Heffalump> and if not, quick, hack it up so it can
04:24:11 <dons> process migration eh? hmm.
04:24:14 <Igloo> You'd need serialisable state
04:24:22 <autrijus> i.e. no Dynamic tricks
04:24:25 <dons> you can send .o files between multiple rts
04:24:30 <dons> then start them up
04:24:42 <autrijus> yeah but state?
04:24:43 <Igloo> At which point the dynamic stuff isn't actually giving any benefit, is it?
04:24:43 <dons> and you could send the state along with it
04:24:50 <autrijus> Igloo: yup, exactly
04:24:52 <poetix> Serializable continuations...
04:25:00 * Heffalump thinks someone should say hello to musasabi.
04:25:11 <dons> so package up a .o file with any state it accumulated, send it over the network. bang!
04:25:15 <autrijus> hello: musasabi!
04:25:26 <dons> musasabi! in the house?
04:25:34 * Heffalump thinks Isaac should do it, since TTBOMK he is immediately to musasabi's right.
04:25:44 <Heffalump> at least, the real names match up.
04:25:47 <nibro> aye, he's the guy who implemented the hswebforms
04:25:59 <nibro> I even pointed him out for you during my talk :p
04:26:09 <Heffalump> but I was walking around with Heffalump on the back of my t-shirt earlier and he didn't say hello.
04:26:20 <nibro> I think he's just shy
04:26:32 <Igloo> Is Ross here?
04:26:41 <nibro> nope
04:26:41 <Heffalump> no
04:26:55 * basti_ wants to be at the #haskell channel party too
04:27:08 * Heffalump notices that Richard Bird has disappeared from the HW program
04:27:10 * shapr too!
04:27:13 <Igloo> Hmm
04:27:24 <Heffalump> and been replaced by a demo
04:27:31 * Igloo hasn't seen him here
04:27:38 <dons> hmm. some were going to see Frank Pfenning's talk over in Mer\in
04:27:59 <dons> but I doubt R Bird is one of them.
04:28:05 <nibro> what a way to go, replaced by a demo! :(
04:28:07 <Heffalump> he's not here, TTBOMK
04:28:16 <Heffalump> I assume he's been replaced cos he's not coming for some reason.
04:28:27 <SyntaxNinja> we need to get droundy on here, IMO
04:28:28 <dons> yup
04:28:33 <Heffalump> HW seems to have a bad recent tradition of people not showing
04:28:33 <SyntaxNinja> we
04:28:35 <SyntaxNinja> er
04:28:36 <Heffalump> his wireless card doesn't work
04:28:42 <Heffalump> and he doesn't want to waste lots of time on IRC
04:28:42 <SyntaxNinja> we'll seduce him away from Physics!
04:28:48 <SyntaxNinja> bah
04:28:49 <SyntaxNinja> "waste"
04:28:58 <dons> collaborate!
04:29:12 <dons> hmm. can we darcs send through irc/lambdabot yet? why not?
04:29:13 * Heffalump pokes SyntaxNinja with scrollback
04:29:26 <Heffalump> but he's stopped reading IRC again
04:29:44 <rep> boku wa kimi ga suki
04:29:47 <Lunar^> SyntaxNinja: did you made your talk about the filesystem already?
04:29:52 * Heffalump looks forward to learning about theorem proving
04:29:57 <Heffalump> Lunar^: it's near the end
04:29:59 <Heffalump> (so no)
04:29:59 <shapr> rep: xu do tavla mi bau la lojban
04:30:09 <Lunar^> Heffalump: ok
04:30:09 <rep> lol lojban.
04:30:28 <shapr> rep: mi djica lenu do tavla fo la lojban
04:30:28 * basti_ .o° ( ? )
04:30:28 <SyntaxNinja> Lunar^: "already"?
04:30:37 <SyntaxNinja> oh, make == give
04:31:24 <Lunar^> SyntaxNinja: thanks
04:31:27 <SyntaxNinja> I don't know what I'm loooking for in scrollback
04:31:33 <Heffalump> say hello to musasabi
04:31:35 <SyntaxNinja> Lunar^: I'm giving the talk in a few hours
04:31:43 <Heffalump> [12:25] * -> Heffalump thinks Isaac should do it, since TTBOMK he is
04:31:43 <Heffalump>           immediately to musasabi's right.
04:31:47 <Lunar^> SyntaxNinja: good luck (or whatever you need :))
04:31:53 <SyntaxNinja> Lunar^: thanks!
04:31:58 <SyntaxNinja> oh, that's musasabi?
04:32:09 <Heffalump> I _think_ so, from /whois on here and his badge.
04:32:18 <nibro> aye, that's him
04:32:38 <nibro> I checked during my talk :)
04:32:52 * Lunar^ imagine the scene: people with laptops, starting slowly to look all at the very same point
04:33:04 <dons> hehe
04:33:26 <nibro> the talks have started again as well, so we have to multitask too :)
04:34:31 <nibro> oh, hi musasabi :)
04:34:32 <SyntaxNinja> Heffalump: hello -musasabi
04:35:00 <nibro> I saw you typing... ;-)
04:35:29 <basti_> one of you should raise his hand
04:35:51 <nibro> I think that would distract the talker somewhat...
04:36:01 * basti_ laughs
04:36:04 <basti_> what is he talking about?
04:36:19 <basti_> need a track from the new oldfield album to play loudly? :D
04:36:25 <nibro> how to prove Haskell programs correct using type theory
04:36:30 <basti_> oh
04:37:25 <basti_> Lemmih: i satisfied all dependencies now ;)
04:38:24 * Heffalump wants to know if the implementation is available
04:38:44 <nibro> for the talk?
04:38:55 <basti_> a theorem prover? :P
04:38:57 <Heffalump> the Haskell -> Agda translator
04:38:57 <dons> well, agda is.
04:39:42 <nibro> I think so, since my room partner (UlfNorell) is involved
04:39:52 <nibro> he would never leave anything unimplemented
04:40:00 <b0gg1e> hi ppl.
04:40:04 <kosmikus> the q is whether it's available, though ...
04:40:05 <autrijus> greetings, b0gg1e.
04:40:08 <Heffalump> I'll try his webpage then. It's not on the speaker's webpage.
04:41:14 <Heffalump> no sign.
04:41:21 <Heffalump> oh well, I'll ask the speaker lately.
04:41:23 <dons> we can't display irc during the talk, @vixen might get noisy
04:41:29 <Heffalump> s/lately/later/
04:42:21 <Heffalump> oh, http://dilbert.cs.chalmers.se/Cover/CoverTranslator/
04:46:18 <rgrig> newbie (arrays). In Gentle... the type of index (from Ix class) is ":: (a,a) a -> Int". Why not ":: (a,a) -> a -> Int" ? Is there a difference?
04:47:07 <dblhelix> rgrig: that'a typo then
04:47:15 <rgrig> 10x :)
04:47:31 <dblhelix> (a, a) a -> ... is nonsense: (,) is a binary type constructor
04:48:02 <dblhelix> dblhelix: @kind (,)
04:48:09 <dblhelix> (,) :: * -> * -> *
04:48:13 <dons> it looks like Core :)
04:48:21 <dblhelix> (lambdabot does not do kinds ;))
04:48:28 <dons> yeah it does.
04:48:31 <dons> @kind Int
04:48:33 <lambdabot> *
04:48:37 <dblhelix> cool!
04:48:42 <dons> @kind Maybe
04:48:44 <dblhelix> @kind (,)
04:48:44 <lambdabot> * -> *
04:48:45 <lambdabot> * -> * -> *
04:48:53 <dblhelix> @kind Monad
04:48:54 <lambdabot> bzzt
04:48:55 <rgrig> it's strange thou since the next row reads "inRange     :: (a,a) -> a -> Bool", so by contrast the first typo should be easy to spot..
04:49:04 <dblhelix> mm... too bad
04:49:06 <dons> Monad is a class.
04:49:09 <dons> not a type
04:49:33 <basti_> Lemmih hhhhhh!
04:49:35 <basti_> Error in server: HASPR/CGI.hs:54:19-42: Non-exhaustive patterns in function fix
04:49:36 <basti_>  please report as a bug to lemmih@gmail.com
04:49:53 <dblhelix> dons: I know, obviously ;). but it makes perfect sense (for me, at least) to ask for the kind of a class, don't you agree?
04:49:57 <dons> Lemmih will regret that error msg...
04:50:24 <dblhelix> Monad ::~ * -> *
04:50:25 <Lemmih> basti_: You have to be careful (:
04:50:33 <nibro> is that an error in the function fix, or is it in the fix of a function? :)
04:50:40 <dblhelix> don't know what to do for mp type classes, though
04:50:57 <basti_> Lemmih: thats what i get on the very first try to get your stuff running ;)
04:51:16 <Lemmih> basti_: What URL did you try?
04:52:02 <basti_> "/"
04:52:33 <basti_> that is: localhost/hsp/
04:53:03 <Lemmih> It'll probably work if you give it the url to a real file.
04:53:15 * basti_ tries
04:53:48 <aleator> Weird. When building ghc-api it says
04:53:53 <aleator> "unknown package: Cabal-1.1.1"
04:54:09 <aleator> When ghc-pkg claims that it exists.
04:54:21 <autrijus> is there some other url to get ghc-api?
04:54:48 <Lemmih> basti_: echo "page = <b>Hello world</b>" >> hsp-pages/Hello.hsp and then try /hsp/Hello.hsp
04:55:02 <Lemmih> autrijus: http://scannedinavian.com/~lemmih/ghc-api/
04:56:49 <basti_> hmm okay
04:57:11 <autrijus> cool, thanks
04:58:32 <autrijus> Lemmih: when building it on stock 6.4.1-freebsd
04:58:32 <autrijus> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
04:58:32 <autrijus>         unknown exception
04:58:38 <dons> yay!
04:58:43 <Lemmih> haha
04:58:45 <basti_> ghc-6.4: could not execute: trhsp
04:58:55 <basti_> i got a trhsx, but not trhsp
04:59:01 <autrijus> is this supposed to work? :)
04:59:03 <Lemmih> basti_: trhsp is in the repo.
04:59:08 <basti_> ohhh
04:59:35 * basti_ blushes
05:00:03 <Lemmih> autrijus: Try removing the -v0 from the cabal file.
05:00:38 <dons> mmm... portland eh?
05:01:28 <basti_> YOW :D
05:01:34 <basti_> works
05:01:43 <Lemmih> aleator: That's indeed very weird. /-:
05:01:48 <nibro> dons: now you know how to get people to come to unsw, just advertise in your HW talk :p
05:01:58 <nibro> too bad you did it already
05:02:00 <SyntaxNinja> mmm. portland
05:02:03 <Lemmih> basti_: Hurrah (:
05:02:05 <dons> doh!
05:02:16 <dons> but maybe I should go to portland instead... mmm
05:02:22 <nibro> I heard it rains a lot there...
05:02:28 * dons ponders graduating
05:03:53 <Heffalump> don't do it!
05:04:06 <dons> yeah, good idea.
05:04:11 <nibro> oooh, graduating. That sounds scary...
05:04:13 <Heffalump> you might end up in industry and have to pay for your own ICFP visits!
05:04:26 <dons> bah!
05:04:40 <nibro> Heffalump: talking from experience? :)
05:05:05 <Heffalump> nibro: indeed ;-)
05:05:49 <nibro> poor guy :-(
05:06:02 <autrijus> Lemmih: that is still impossible with unknown exception
05:06:40 <Lemmih> autrijus: It doesn't even manage to compile a single file?
05:06:45 <autrijus> aye
05:06:49 <autrijus> --verbose doesn't tell me anything
05:06:56 <Heffalump> nibro: on the plus side, they pay me enough to be able to afford this ;-)
05:07:04 <autrijus> it fails as soon as it enters ghc
05:07:21 <autrijus> (and as an aside, if I say "build -verbose" it fails with "no parse")
05:07:26 <autrijus> but it's irrelevant
05:07:48 <nibro> Heffalump: I guess some would even consider that an advantage over academic work... ;-)
05:07:51 <autrijus> I wonder if it's because I have a new cabal.
05:07:55 <autrijus> 1.1.3
05:07:57 <Lemmih> autrijus: Try removing -DGHCI from the cabal file.
05:08:08 * Lemmih got 1.1.4
05:09:26 <autrijus> Lemmih: same panick
05:09:42 <autrijus> should I upgrade to cabal 1.1.4? I don't think that matters
05:09:52 <dons> I think ghc should say, "the impossible happened, unknown picnic"
05:10:05 <Lemmih> That shouldn't matter.
05:10:37 <dcoutts> mmm picnic
05:11:05 <Lemmih> An 'unknown exception' is an uncatched dynamic exception, right?
05:11:13 * basti_ feeds his landlord sucker 
05:11:31 <dons> I think unknown exceptions are one's who typeable isn't caught
05:11:33 <dons> yeah.
05:11:49 <dons> who's Typeable doesn't match those that are expected
05:12:12 <Lemmih> How can that happen in GHC?
05:12:44 <dons> well, it can happen in the presense of dynamic loading, due to the typeable/altdata issue
05:13:02 <dcoutts> dons, I'm going to push my new UI code to the hIDe repo today, I'd it's currently useing the demo editor. I'd like to get it using Yi.
05:13:22 <dons> yep. me too. long plane flight coming up ...
05:13:29 <dcoutts> so we need to fit Yi into an 'EditorPage'
05:13:43 <dcoutts> you'll see the code, it's not very complicated
05:13:58 <dons> ok.
05:14:00 <dcoutts> I'll ping you when it's in
05:14:32 <dcoutts> then there are lots of little Yi things we'll want to fix so we can actually start using it
05:14:40 <dons> yes
05:14:55 * dcoutts wants to use hIDE to develop hIDE
05:15:04 * dcoutts want's to ditch nedit asap
05:15:07 <dons> i expect to have a couple of weeks starting next week to hack non-stoop
05:15:12 <dcoutts> cool
05:15:16 <dons> no stoops at all!
05:15:23 <nibro> yeah, stooping is bad
05:15:29 <nibro> should be avoided at all cost
05:15:33 <Igloo> Do you have week 3 earmarked for sleeping?
05:15:34 <dcoutts> good, I never likes stooping either
05:15:38 <dcoutts> bad for the back
05:16:07 <dons> yeah, sleep in week 3 is a good idea. i'll add that to my todo list :p
05:16:39 <dcoutts> dons, we'll probably find the UI api is not quite flexable enough, so ust shout at me when you run into limitations
05:16:55 <dcoutts> at the moment it's not obvious which direction needs extending first
05:17:03 <dons> ok, sure thing.
05:17:51 <dcoutts> I think we need prototypes of several kinds of plugins just so we can test the interfaces
05:18:11 <dcoutts> I'd like to add a mozilla based html documentation viewer
05:18:22 <dcoutts> for haddock docs
05:18:23 <dons> yeah. for haddock, at least..
05:18:47 <dons> Lemmih, i'd like to hit a command that inserts for me the type decl of an expression
05:19:00 <dons> so I don't have to write them
05:19:28 <dons> can we walk the annotated syntax tree yet? do we store it somewhere?
05:20:38 * dons feels like a kid in a chocolate shop with that annotated syntax tree available :)
05:23:35 <nibro> Tim is really lively... :)
05:23:40 <dons> hehe
05:24:45 <dons> so 'undefined' is kinda the hole in the proof, Isabelle style
05:30:01 <autrijus> dons: oh, in the PackedString shim, you want to change bindings so nilPS=nil
05:30:06 <autrijus> should say nilPS=empty
05:30:15 <autrijus> if so we can drop the -fno-warn-deprecations in the cabal
05:30:17 <autrijus> but it's a minor point
05:31:32 <dons> ah, hmm.
05:31:48 <dons> yeah, it's minor. doesn't matter much either way
05:31:52 <autrijus> aye.
05:40:27 <shapr> Is the annotated syntax tree code available in the yi or hIDE repos?
05:40:38 <Lemmih> No.
05:41:13 <dcoutts> shapr, it's just too new :-)
05:41:52 * dcoutts tries to tempt shapr into joining the hIDE hackfest
05:41:54 <Heffalump> so yi is a plugin for hIDE?
05:42:01 <dcoutts> Heffalump, sort of
05:42:21 <dcoutts> there is a hIDE plugin that depends on Yi
05:42:39 <dcoutts> so Yi does not depend on hIDE
05:42:42 <shapr> Lemmih: Is it in ghc-api?
05:43:14 <dons> but basically, yes, yi is loaded dynamically into hIDE
05:43:26 <dons> running in a little gtk wrapper gui
05:43:31 <dons> s/gui/widget/
05:43:54 <Heffalump> does it get nice integration with the usual mouse-based IDE featues?
05:44:05 <dons> hmm. yes, I would say.
05:44:05 <dcoutts> mostly yes
05:44:11 <dons> much bettre than curses!
05:44:18 <Heffalump> how, OOI? Changes to yi?
05:44:24 <shapr> dcoutts: Can't join yet, I need to get TMR 5 out today/tomorrow, and finish FLM.
05:44:25 <Heffalump> Or does it behave nicely in text mode too somehow?
05:44:27 <dons> scrolling, selection etc work out of the box
05:44:44 <Lemmih> shapr: Yes.
05:44:56 <dons> the yi that is loaded in hIDE doesn't have a curses gui atm.
05:45:05 <dons> was that your question?
05:45:43 <dcoutts> shapr, how's FLM going?
05:46:20 <Heffalump> does the one loaded in hIDE have features that the text-mode one doesn't?
05:46:47 <shapr> dcoutts: Asymptotically nearing completion...
05:46:47 <dons> yes. syntax hl for example
05:47:04 <dons> and typechecking. also it scrolls horizontally
05:47:22 <dons> but it is very new, and not all features from the yi 0.1 work yet
05:47:29 <dcoutts> shapr, ah the last 10% that takes 90% of the time :-)
05:47:41 <shapr> Right, the last 10% takes the last 90% of the time.
05:48:29 <dcoutts> and loading it in hIDE give is extra features like a file/module browser
05:48:35 <shapr> So, will yi/hIDE have support for other languages as well? How would I write a new mode? Hack the ghc-api to parse and typecheck the new language? :-)
05:48:45 <autrijus> and the 10/90 rule can get recursively applied and diverge
05:48:49 <shapr> I'm thinking about something simple like lojban.
05:48:54 <shapr> autrijus: ouch!
05:49:02 <dons> shapr, well, we'll think of something.
05:49:07 <dons> i need to hack C and tex
05:49:09 <autrijus> oooooh
05:49:13 <dons> so we need those at least
05:49:13 * autrijus hears the key phrase
05:49:19 <autrijus> "we define a parser and get a printer for free"
05:49:35 <shapr> dons: I need to hack Python and SQL.
05:49:38 <autrijus> using BiArrows! what a great hack!
05:49:46 <dons> autrijus, yeah :)
05:49:51 <shapr> autrijus: Hand of Eris? -><- ?
05:49:52 <dons> less code == good
05:49:59 <dcoutts> we get syntax highliting of other languages for free
05:50:05 <autrijus> dons: it boils down to you still having to write both sides
05:50:12 <Heffalump> autrijus: I woke up when I heard that. I've been saying it for ages.
05:50:14 <autrijus> but it provides a framework to join thme together in a sensible way
05:50:19 <Heffalump> But can it be done with a really good parser?
05:50:24 <autrijus> for some value of sensible
05:50:30 <Heffalump> one that optimises and stuff
05:50:33 <dcoutts> but anything more sophisticated needs more code
05:50:48 <autrijus> Heffalump: I think so, if we only care about the print-parse roundtrip
05:50:52 <shapr> BiArrows?
05:50:53 <autrijus> and not demand parse-print roundtrip
05:50:54 <Heffalump> and we need a notation.
05:50:57 <autrijus> shapr: bidirectional arrows
05:50:58 <autrijus> Heffalump: aye
05:51:14 <Heffalump> and Ross Paterson took ages to get arrow notation right
05:51:21 <Heffalump> so bi-arrow notation would be hard
05:51:31 <Heffalump> (at least potentially)
05:51:32 <dcoutts> we can do simple regex based syntax highliting for all major languages by using the Gtk SourceView system
05:51:33 <autrijus> we can always go for DSLs :)
05:51:56 <Heffalump> that's what arrow notation is
05:52:04 <shapr> dcoutts: regexes have problems in emacs.
05:52:12 <autrijus> i.e. instead of coding biarrow computations generally, simply structure special-purpose biarrow constructors for the parsing
05:52:17 <autrijus> and printing
05:52:23 <dcoutts> shapr, yeah, they're not perfect, but we get them for free
05:52:29 <shapr> True
05:52:32 <dcoutts> shapr, and for Haskell we do it properly
05:52:39 <dcoutts> with the ghc lexer
05:52:40 <shapr> And for other languages too, I hope...
05:52:49 <dcoutts> if you write the code :-)
05:52:54 <shapr> Fair enough :-)
05:53:09 * autrijus ponders HSP as DSL for XML parsers
05:53:18 <dcoutts> teir 1 support for Haskell, teir 2 for everything else so far
05:53:29 <dons> hmm. well we can use dcoutts C lexer.x ?
05:53:30 <shapr> dcoutts: It'll just be a matter of writing another Lexer.x right?
05:53:43 <dons> and any other language lexers written in Haskell
05:53:47 <dcoutts> dons, shapr yes and yes
05:54:19 <dcoutts> the lexers usually need changing slightly to me useful for syntax hl
05:54:26 <shapr> What about typechecking of new languages? Is that possible with ghc-api?
05:54:35 <dcoutts> no
05:54:48 <dcoutts> it does haskell & glasgow haskell
05:54:55 <dons> ghc-api is just ghc
05:55:04 <dons> for some value of 'just'
05:55:07 <dcoutts> you need another language framework for other languages
05:56:24 <dcoutts> actually, lexing C is unpleasent
05:56:32 <dcoutts> to do it properly anyway
05:57:01 <dcoutts> the c2hs C lexer assumes preoprocessed C
05:57:34 <dcoutts> but it'd be a good place to start
05:59:13 <shapr> I think Python comes with its own lexer.
05:59:24 <dcoutts> written in?
05:59:43 <shapr> HaskellDB must have some support for lexing/parsing SQL.
05:59:57 <dcoutts> any C lex code should be convertable fairly easily
06:00:04 <shapr> Python's stuff is written in Python, but it comes with a BNF grammar.
06:00:28 <dcoutts> I wrote the alex/happy lexer/parser for C from a lex/yacc spec
06:00:32 <shapr> No clue about TeX
06:01:01 <dcoutts> but there's no great pressing need for all that since GtkSourceView does support all those languages
06:01:39 <dcoutts> only do it once the regex based highliting annoies you enough
06:01:46 <dcoutts> there are more important things to do
06:02:17 <dcoutts> like we've got the whole project management / build system task unassigned...
06:03:24 <shapr> Regex based highlighting will annoy me as soon as I need to use yi/hIDE for a given language.
06:03:32 <shapr> btw, is there a single name for this new critter now?
06:03:36 <dcoutts> heh heh
06:03:49 <dcoutts> hIDE I'd say
06:04:06 <dcoutts> we've got a name competition running on the wiki though
06:04:14 <dcoutts> if anyone has a better name
06:04:28 <shapr> Is the bidirectional arrows paper available as ps or pdf?
06:04:31 <Lemmih> Does GtkSourceView use regex based highlighting?
06:04:35 <dcoutts> Lemmih, yep
06:04:51 <dcoutts> Lemmih, take a look at the syntax definition files it uses
06:05:00 <dcoutts> (I wrote the Haskell one)
06:05:15 <dcoutts> hia davve
06:05:24 <davve> hi!
06:09:13 <shapr> autrijus: Is there a 'top level' name for Confucianism? I thought if yi is the text editor part, justice could be the type checker, courtesy could be the autocompletion, wisdom could be the source control part... etc. So I'd want the whole collection to be named whatever you might call all the five virtues, or just for Confucianism.
06:09:33 <dcoutts> :-)
06:09:38 <shapr> paolino: Hiya
06:09:42 <shapr> paolino: Learning Haskell?
06:09:56 <paolino> mmhh
06:09:58 <xerox> Another Paolo!
06:09:58 <dcoutts> shapr, I hope you'll add whatever name you come up with to the hIDE wiki
06:10:05 <shapr> dcoutts: Definitely.
06:10:15 <paolino> 2 time I get next to this idey
06:10:27 <shapr> xerox: Maybe time to start #haskell.it ;-)
06:11:06 <Lunar^> We should try to get type-error slicing into hIDE
06:11:15 <shapr> yes!
06:11:19 <paolino> at least you get one learner for free
06:11:28 <Lemmih> type-error slicing?
06:11:33 <dcoutts> Lunar^, huh?
06:11:56 <Lunar^> http://www.cee.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/
06:11:58 <shapr> Type error slicing is awesome stuff. It infers the types from multiple directions, and finds out where they clash.
06:12:16 <Lemmih> Urk.
06:13:07 <dcoutts> fortunately we're not aiming to do totally new type anslysis stuf, just make a platform for ther people to plug those things in
06:13:15 <dcoutts> ther/other
06:13:37 <paolino> BTw hello everyone, I'm trying to parse the ROT 13 example http://www.willamette.edu/~fruehr/haskell/code/short.html#rot13 what is the '.' operator there ?
06:13:44 <dcoutts> otherwise we'd have far too much work to do! :-)
06:13:56 <xerox> shapr: I have #haskell-it !
06:14:06 <shapr> For example, two different modules of a program might work fine separately, but when they talk to each other, one uses Float type, and the other uses (^)
06:14:09 <shapr> xerox: cool!
06:14:11 <dcoutts> tieing together existing libs & tools is quite enough work as it is
06:14:51 <Lunar^> paolino: function composition
06:15:20 <Lunar^> paolino: (f . g) x = f (g x)
06:15:41 <paolino> thnx
06:24:59 <nibro> anyone else having major trouble with the connection?
06:25:12 <Heffalump> oege was complaining about it earlier
06:25:31 <Heffalump> I'm using an openvpn link so I don't notice disconnects unless I'm actually using it at the time.
06:25:54 <nibro> I was disconnected since my conputer started hibernating I guess
06:26:05 <nibro> but it was major trouble getting back on again
06:26:25 <nibro> and I can't seem to use a browser...?
06:26:32 <Heffalump> the web seems very slow to me
06:26:38 <Heffalump> oh, no, it's dead.
06:26:51 <Heffalump> I should direct my web traffic over my VPN link
06:27:17 <nibro> ok, so it's not just me then
06:27:19 <Heffalump> oh, working now
06:27:35 <nibro> not for me :(
06:27:42 <Heffalump> very slowly.
06:27:48 <Heffalump> so maybe you just need to be patient ;-)
06:28:38 <xerox> Skate time!  Bye bye.
06:28:56 <nibro> well, I can see the progress in Opera, and it's not moving one bit. :-\
06:29:11 <Heffalump> oh, something failed again.
06:29:16 <Heffalump> Perhaps I was just lucky with my google query.
06:29:35 * earthy grins
06:29:52 <nibro> I can't even get up google...
06:30:12 <Heffalump> seems faster now
06:30:13 <dons> so HW people, shall we meet after this session ?
06:30:50 <nibro> sounds like a plan
06:30:52 <dons> get some dinner somewhere? SyntaxNinja suggested the african cafe?
06:30:54 <autrijus> I thought that was the plan all along
06:30:55 <Heffalump> dons: sure.
06:31:01 <autrijus> the african cafe is good because it has wireless.
06:31:10 <Heffalump> so that you can ignore the waiting staff? :-)
06:31:13 <autrijus> yes!
06:31:20 <dons> ah good. and it's near our hotel, nibro
06:31:20 <autrijus> my favourite pastime
06:31:35 <nibro> this whole town is one big access point....
06:31:35 <dons> autrijus is great at ignoring the wait staff.
06:31:52 <nibro> african cafe sounds great to me :)
06:32:18 <Heffalump> I didn't like it that much, but it's ok with me.
06:32:31 <dons> Heffalump, do they do vegetarian, you think?
06:32:58 <Heffalump> umm, can't remember
06:33:02 * dons doesn't want to see any more sausages
06:33:22 * dcoutts found getting vege stuff in estonia was not totally straight forward
06:33:33 <Heffalump> SAUSAGES!
06:33:37 * Heffalump likes sausages
06:33:39 <dons> argh!
06:33:42 <dcoutts> SALAD!
06:33:47 <dons> TOFU!
06:33:54 <Heffalump> BACON!
06:34:00 <dons> LENTILS!
06:34:06 <dcoutts> SAUSSAGES are too MEATY to be GEORGEOUS!
06:34:11 <Heffalump> MEAT!
06:34:28 <dcoutts> VEGE! VEGE! VEGE! VEGE! VEGE!
06:34:49 * Heffalump eats vegetables too
06:34:53 * dons throws apples at Heffalump
06:34:54 <Heffalump> though tofu and lentils are evil
06:34:57 <Heffalump> I like apples.
06:35:00 <Heffalump> Where?
06:35:11 * Heffalump fails to spot apples being thrown at him
06:35:12 <nibro> vegetables are the perfect side dish :-)
06:35:31 <Heffalump> WANT APPLE!
06:35:46 * nibro sits in a direct line between Heffalump and dons...
06:35:57 <nibro> so take it easy with those apples will you!
06:35:58 <dons> whatch out for apples, nibro!
06:36:03 * autrijus ponders throwing the apple sticker to Heffalump
06:36:16 <dcoutts> autrijus, carfule he might eat it
06:36:29 <autrijus> I'm sure it won't kill him
06:36:31 <autrijus> but make him stronger
06:36:37 <autrijus> sort of like Popeye
06:36:42 <dons> oh no. super-heffalump on the rampage!
06:37:03 <dcoutts> autrijus, mm like Popeye but with more plastic and glue
06:38:11 <rafl> Hello, I'm not very familar with haskell but I need to analyze some lines of haskell code to know what they do because the applications lacks some documentation.
06:38:46 <SamB> rafl: at your service, as long as it looks like a useful program and not like a homework assignment ;-)
06:38:57 <SamB> @paste
06:38:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:39:01 <rafl> Maybe someone can help me out with that? The code is at http://nopaste.debianforum.de/1229
06:39:28 <dblhelix> rafl: maybe CosmicRay can help you with that :)
06:39:33 <dblhelix> @seen CosmicRay
06:39:34 <lambdabot> CosmicRay is in #haskell. I don't know when CosmicRay last spoke.
06:39:39 <rafl> dblhelix: If he were here, yes.
06:39:48 <rafl> Whops. He just joined. :-)
06:40:17 <rafl> CosmicRay: I'd like to know how to deal with multiple {upstrea,debian}repo's with darcs-buildpackage.
06:40:17 <SamB> rafl: what part were you wondering about?
06:40:59 <rafl> SamB: getDirectories. I wanna know how the config should look like to work with more than one upstream and debian repository.
06:41:06 <CosmicRay> rafl: I'm not quite sure I understand your situation, can you describe it a bit more?
06:41:39 <rafl> CosmicRay: I have a local repo as well as one at costa for a group maintaince project.
06:42:13 <SamB> maybe you should just pull all the patches you want together first?
06:42:18 <rafl> CosmicRay: It's guaranteed that there's no package with the same name in both repos. So it should work with two repos, shoudn't it?
06:42:32 <SamB> dunno how darcs-buildpackage works...
06:43:07 <rafl> SamB: Well, CosmicRay wrote it. So he can probably help out better here. :-)
06:43:15 <CosmicRay> rafl: yes.  you could add the remote repo as a mirror.
06:43:25 <Lunar^> CosmicRay: here you are ! :)
06:43:35 <CosmicRay> rafl: one of the things on my todo list is to automate pulling from the remote repo into your local repo
06:43:48 <CosmicRay> rafl: right now, you'd have to go into your local repo and darcs push/pull as appropriate
06:43:52 <CosmicRay> Lunar^: eeeeeep!
06:43:59 <Lunar^> CosmicRay: I would like to continue the work on packaging yi and riot... Do you have filled ITPs for hscurses and these two?
06:44:27 <CosmicRay> Lunar^: nope, AFAIK I have no open ITPs
06:45:05 <Lunar^> CosmicRay: ok cool... should I fill ITPs CCing debian-haskell@ ?
06:45:37 <rafl> CosmicRay: But adding it as a mirror allows me to mirror only into one direction, doesn't it? I don't want all my packages to be maintained by that group. :-)
06:46:40 <CosmicRay> Lunar^: yup
06:47:01 <CosmicRay> rafl: no, the local "mirror" is just a darcs repo.
06:47:10 <CosmicRay> rafl: so when you dbp-get, darcs-buildpackage checks out of the mirror.
06:47:19 <CosmicRay> you can push your local changes to the mirror, then run darcs push in the mirror dir.
06:47:34 <CosmicRay> I want to write dbp-pull and dbp-push at some point to automate all that.
06:47:44 <rafl> CosmicRay: Ah, OK. Do you have a ~/.darcs-buildpackage example for using a mirror?
06:48:02 <CosmicRay> repobase = /home/jgoerzen/repo/debian
06:48:05 <CosmicRay> upstreamrepo = %(repobase)s/%(package)s.upstream
06:48:19 <rafl> CosmicRay: I would appreciate that very much. HE as well. We want to maintain the gtk2-perl packages using dbp.
06:48:23 <CosmicRay> debianmirrors = loginname@complete.org:darcs/debian/%(package)s
06:48:37 <CosmicRay> upstreammirrors = loginname@complete.org:darcs/debian/%(package)s.upstream
06:48:46 <CosmicRay> yeah, it does annoy me too.
06:48:55 <paolino> How does it work with dictionaries/hashes here in haskell ? I suppose theire usage is imperative is it?
06:49:27 <Heffalump> no, you modify them functionally
06:49:39 <mflux> are there functional hashes?
06:49:39 <Heffalump> so you get a new copy (log-space cost) when you update them
06:49:39 <CosmicRay> paolino: you can use it that way (Data.HashTbl if memory serves).  But Data.Map is the usual way, and it simply returns a new hash when you "modify" it.
06:50:00 <CosmicRay> it actually leads to some really cool function chains
06:50:09 <Lunar^> CosmicRay: I will do this during the week-end, I'll be happy to have you as a sponsor, if you agree
06:50:17 <CosmicRay> Lunar^: are you in nm?
06:50:46 <Lunar^> CosmicRay: I was waiting to get a package in the archive before starting the process
06:51:08 <CosmicRay> Lunar^: I'll sponsor uploads as long as the packages are correct.  I have time to run dupload but not time enough to spend helping out with figuring out the packaging system, I'm afraid
06:51:21 <CosmicRay> if you're already up to speed with that part, you should be fine
06:52:16 <autrijus> the patch for gadt/record/existentials is reaching 1000 lines quickly...
06:52:30 <rafl> CosmicRay: How do I import a package to that mirror directly?
06:52:37 <autrijus> ghc is so very vast.
06:53:04 <CosmicRay> rafl: when you dbp-get a package, it will automatically pull it from *mirrors into repobase, then pull from there into your working dir.
06:53:22 <CosmicRay> note that it is also possible to have repobase be non-local.
06:53:25 <shapr> Are the various GHC optimizations separate enough to write QuickCheck tests for them?
06:53:29 <CosmicRay> if you want all your stuff to be remote
06:53:47 <Lunar^> CosmicRay: I've been playing with debian package for two years now... most of them unofficial though, but I've read a lot of docs during that time
06:53:55 <autrijus> shapr: you mean instead of the operational tests in fptools/testsuite/ ?
06:53:56 <rafl> CosmicRay: So initial import works the other way round? import locally and push to the mirror?
06:53:56 <CosmicRay> Lunar^: super
06:54:19 <CosmicRay> rafl: well, you get it to the mirror however you want.  it's outside the scope of dbp
06:54:26 <shapr> autrijus: Yeah, JohnMeacham asked about testing optimizations recently, and I've had this urge to see if QuickCheck solves at least the correctness side of things.
06:54:32 <CosmicRay> rafl: I usually darcs initialize an empty directory on the server, then darcs push to it.
06:54:40 <rafl> CosmicRay: Would be cool if it could handle that, though.
06:54:55 <CosmicRay> rafl: there's no way to do that automatically.
06:55:08 <autrijus> shapr: what would be the properties though.
06:55:28 <shapr> autrijus: Correctness properties are easy to come up with.
06:55:42 <rafl> CosmicRay: Why? I can imagine to somehow tag each mirror and doing something like dbp-importdsc --to=TAG *dsc
06:55:43 <Heffalump> the nice thing is that all repos have the same root, i.e. empty
06:55:47 <autrijus> then there's nothing that prevent them from being tested
06:55:49 <Heffalump> and you can trivially create that repo with darcs init
06:56:02 <shapr> Ok then.
06:56:33 <CosmicRay> rafl: because setting up a new directory on a mirror cannot be done solely with darcs commands
06:56:43 <CosmicRay> rafl: for instance, in my case, I have to ssh to the mirror and mkdir, then darcs initialize.
06:57:03 <CosmicRay> rafl: maybe somebody else does something different.  maybe it requires an admin to create it in a certain area.
06:59:17 <autrijus> fortunately this is not defcon
06:59:25 <autrijus> otherwise the laptop will be displaying something silly now
07:00:43 <shapr> autrijus: Already seen ICFP mentioned in connection with Perl6? -> http://www.oreillynet.com/pub/wlg/7928?CMP=OTC-BD0016219291
07:01:27 <rafl> rep: Sounds reasonable.
07:01:35 <rafl> Err, CosmicRay: Sounds reasonable.
07:03:36 <shapr> autrijus: Ah never mind, I see it on your journal.
07:03:38 <shapr> hiya pesco!
07:03:39 <pesco> Pozdravy, #haskell!
07:03:45 <pesco> Ahoj shapr!
07:11:23 <shapr> hey pesco
07:11:38 <pesco> What's up?
07:12:17 <pesco> As I've told you I relocated to Prague for a year.
07:12:30 <pesco> And I just found quasi-free Internet. :)
07:13:31 <pesco> Free as in "order a cup of tea every hour or so and hack away".
07:13:53 <praseodym> are there any cs (or anything like that) students here doing haskell?
07:14:09 <pesco> praseodym: Yes, me.
07:15:11 <praseodym> pesco: how deep are the haskell classes you are getting going?
07:16:34 <pesco> praseodym: Oh, hrm. There aren't any.
07:16:54 <praseodym> no haskell on cs?
07:17:00 <pesco> I just happen to to be a Student and do Haskell at the same time.
07:17:05 <praseodym> I see
07:17:05 <pesco> praseodym: Nope.
07:17:33 <pesco> Well, there are people at my University who have at least heard of Haskell. I'm not sure if anyone actually uses it.
07:17:38 <Heffalump> probably many Haskellers who are also CS students are in this room right now ;-)
07:17:43 <praseodym> I'm not on uni yet, but am trying to learn haskell. but I want to know if cs is something for me
07:17:47 <Heffalump> (the Haskell workshop)
07:17:51 <Heffalump> praseodym: almost certainly
07:17:56 <Heffalump> what uni(s) are you considering?
07:18:04 <Heffalump> if you're in .nl, Utrecht is very good for Haskell.
07:18:08 <praseodym> university of utrecht, or delft
07:18:44 <Heffalump> they teach Haskell, and have an active Haskell research group.
07:18:55 <Heffalump> absolutely the obvious place to go in .nl for doing Haskell
07:18:58 * pesco curses.
07:19:02 <praseodym> I want to do a study that learns me something though :)
07:19:32 <prionic> every study learns you something...
07:19:38 <Heffalump> well, unless you already know lots of CS, you'll learn something for sure :-)
07:19:54 <Heffalump> have you looked at their syllabus?
07:20:51 <praseodym> syllabus?
07:21:40 <praseodym> well thats what I need to figure out, how much of CS I know. I don't want a study where I learn nearly nothing the first years or so
07:22:22 <prionic> if you want a practical education consider going to polytechnical/applied sciences school, but if you like to research and create new knowledge university is where u belong
07:22:46 <Heffalump> well, what do you know?
07:23:00 <shapr> prionic: What if you like both?
07:23:30 <prionic> university it is then
07:23:56 <praseodym> I know some c++, .net, php, html/xml/css, that sorts of stuff
07:24:09 <praseodym> not haskell yet but I am a quick learner :)
07:25:26 <Heffalump> what do you mean you know .net? that's not a language.
07:25:32 <Heffalump> And none of those things are CS.
07:26:05 <Heffalump> CS is mainly about principles, not practical details, though of course practical details are needed to illustrate the principles.
07:26:30 <prionic> what i learned during the first year of univerity was mathematical and scientific thinking, nothing practical... but valuable nonetheless
07:26:30 <Heffalump> I suggest you go and find out what you would learn from a CS degree.
07:27:25 <CosmicRay> shapr: aware of any smtp client code in haskell?
07:27:45 <shapr> CosmicRay: Fudgets Internet Utilities, but it requires Fudgets.
07:27:53 <shapr> InternetLib I think it's called.
07:28:28 <praseodym> Heffalump: theres not much information about it on the homepage of the utrecht university
07:28:37 <shapr> praseodym: I'd suggest looking at the introductory articles on lambda-the-ultimate.org
07:28:42 <CosmicRay> http://www.cs.chalmers.se/ComputingScience/Research/Functional/Fudgets/Manual/current/index.html
07:28:46 <CosmicRay> is that the wrong place to look?
07:29:20 <shapr> CosmicRay: http://www.cse.ogi.edu/~hallgren/untested/
07:29:24 <SamB> wouldn't it be more fun to look at okasaki's thing about functional datastructures than to look at a course list for a CS degree?
07:29:54 <praseodym> shapr: hey, thats a drupal-powered site :)
07:30:03 <Heffalump> praseodym: what have you found?
07:30:20 <shapr> praseodym: I've taught myself a lot of CS and practical software stuff. I had CS101 in 1992. I don't think university is necessary, but it can be a place to learn stuff if you have good teachers.
07:30:27 * Heffalump can't read Dutch
07:30:31 * Heffalump pokes earthy hopefully
07:30:39 <praseodym> let me get you a babelfish link
07:30:40 <earthy> hm?
07:30:44 <earthy> what?
07:30:46 <Heffalump> tell praseodym about the UU CS course :-)
07:30:49 * autrijus ponders if the zipper thing is a good theoretical model of SVK
07:30:55 <dblhelix> praseodym: what kind of information were you expecting to get from the uu site?
07:31:07 <Heffalump> autrijus: zippers give you a nice functional view of tree + pointer.
07:31:16 <earthy> hef, why would I need to?
07:31:17 <Heffalump> I think Oleg is complicating it a bit, but it's a really nice simple idea.
07:31:20 <praseodym> dblhelix: what exactly the study is about -- some more details
07:31:28 <Heffalump> earthy: well, or point him at a URL that describes it properly.
07:31:37 <autrijus> Heffalump: yes, and multiple zippers that transactionally affect each other is not unlike how svk works.
07:31:41 <earthy> bachelor's or master's?
07:31:47 <Heffalump> the transactional stuff seems a bit confused.
07:31:47 <earthy> praseodym: bachelor's or master's?
07:31:49 <praseodym> bachelor
07:31:55 <pesco> autrijus: What's SVK?
07:31:58 <praseodym> hell, I'm not even on uni yet
07:31:59 <autrijus> pesco: svk.elixus.org
07:31:59 <CosmicRay> shapr: thanks, but no smtp in there anyway
07:31:59 <dblhelix> praseodym: earthy and myself are working at cs.uu.nl: feel free to ask
07:32:01 <Heffalump> autrijus: I'm not sure what the zipper model gives you.
07:32:08 <praseodym> dblhelix: aha
07:32:12 <pesco> autrijus: Heh, that was quick. Thanks. :)
07:32:16 <earthy> might be slightly tricky, as the bachelor's is in dutch. nice opportunity to learn dutch though... :P
07:32:19 <autrijus> Heffalump: not sure either. just wondering.
07:32:23 <praseodym> earthy: I am dutch
07:32:27 * autrijus is waiting for the patched ghc to compile itself
07:32:27 <earthy> *owh*
07:32:28 <Heffalump> perhaps because you can just edit a subtree in svn/svk, it gives you something.
07:32:32 <earthy> http://www.cs.uu.nl/info/studie/informatica/
07:32:34 <earthy> in that case. :)
07:32:37 <Heffalump> but it's not obvious to me what.
07:32:48 <shapr> CosmicRay: Oh sorry, only pop.
07:32:48 <Heffalump> earthy: I think he wants specific syllabus details.
07:32:57 <shapr> CosmicRay: Maybe Postmaster has something?
07:33:00 <earthy> ofcourse, there's a shitload of choices that you can then still make
07:33:14 <CosmicRay> shapr: good point
07:33:55 <earthy> hef: he wants http://www.cs.uu.nl/bama/IcaMajor.html then
07:34:26 <earthy> note, even your dutch should be strong enough to get that ;)
07:34:35 <Heffalump> earthy: yeah :-)
07:34:41 <dblhelix> Heffalump, praseodym: there's quite some variety in the bachelor's courses... there'e programming courses, but also more maths-related courses, there's courses on management and organization, there's a course that lets you develop presentation skills
07:34:47 <Heffalump> praseodym: well, if you know all of the stuff linked from that page, there's no point in going ;-)
07:34:54 * earthy laughs
07:35:01 <Heffalump> but if you do, you probably are God (as your user details say)
07:35:49 * CosmicRay starts adding Maildir and mbox support to MissingH.
07:35:55 <praseodym> I can do OO programming, databases
07:36:18 <praseodym> not functional programming yet, but thats what I want to learn this year
07:36:44 <Heffalump> praseodym: being able to program in a particular language is not the same as understanding the theory behind it.
07:36:49 <earthy> praseodym: FP is in the first year of the bachelor's, advanced FP is in the master's
07:36:55 <Heffalump> "Future of Haskell discussion"
07:36:55 <nibro> now the fun starts :)
07:37:18 <earthy> hef: we concluded that we need more haskell compilers before we start talking about Haskell 2
07:37:20 <shapr> Does that discussion take IRC input? :-)
07:37:32 <earthy> where we == dblhelix, eelco dolstra & me
07:37:32 <dblhelix> praseodym: you can do databases, but do you know about the relational calculus that's underlying RDBMSs? that's for example something you learn in the course on databases
07:37:42 <Heffalump> I wonder if John will want to go on about the commercial support thing again
07:37:51 <Heffalump> earthy: so you guys are writing one? :-)
07:37:57 <Heffalump> (where is UHC going these days?)
07:38:05 <earthy> um
07:38:08 <Heffalump> jhc becoming complete would be good
07:38:14 <praseodym> dblhelix: thats more the area I dont know anything about :)
07:38:18 <dblhelix> Heffalump: yes, we will hack one this weekend... you'll have it by monday :)
07:38:19 <earthy> EHC is going to wherever atze likes it to go
07:38:59 <Heffalump> dblhelix: great.
07:39:05 <praseodym> dblhelix, earthy: what year are you in
07:39:24 <dblhelix> praseodym: point is... you can say "I know about databases, I can do OO programming", but there's still a lot to learn even in these areas
07:39:35 <Heffalump> shapr: If you make a point I agree with, I'll make it. But I'm not transcribing the entire thing to IRC :-)
07:39:35 <earthy> preseodym: we're PhD students
07:39:52 <shapr> CosmicRay: tuomov's riot has either mbox or maildir, I forget which.
07:40:08 <Heffalump> John Launchbury is talking about whether the Haskell community should push towards high assurance or convenient productivity
07:40:13 <praseodym> aha :)
07:40:25 <dblhelix> praseodym: that's what becomes of you when you stay at uni to long... but, hey, they acutually pay you to do that
07:40:26 * dcoutts votes for convenient productivity
07:40:36 * earthy is with dcoutts
07:40:43 <dblhelix> /s/to long/too long
07:40:48 <praseodym> my school pays me to do stuff too... but thats another story
07:40:54 * nibro thinks it's a really good question
07:41:04 <shapr> I'd say that QuickCheck gives you high assurance. We need basic libraries anyway.
07:41:09 <CosmicRay> shapr: mbox, thanks.
07:41:10 <Heffalump> yes, but it's also one that John has been going on about for years.
07:41:15 <SyntaxNinja> 0
07:41:16 <SyntaxNinja> y0
07:41:21 <CosmicRay> I'm writing a generic interface that I hope will work with maildir, mbox, and imap.
07:41:26 <Heffalump> well, it's a fusion of two things he's been going on about before
07:41:27 <dcoutts> high assurance is boring, but people might pay more for it
07:41:28 <SyntaxNinja> <--- galois spy. watch it, Heffalump
07:41:29 <nibro> aye, and one that no one ever wants to answer
07:41:32 <autrijus> I think my quip is not a bad brand ;)
07:41:37 <autrijus> the "faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP" thing ;)
07:41:41 <Heffalump> Galois can read the weblogs if they care ;-)
07:41:54 <Heffalump> ooh, he wants Haskell '06.
07:42:00 <Heffalump> "Conservative refinement of Haskell 98"
07:42:06 * dcoutts votes for that too
07:42:08 <Heffalump> H98+FFI+clean up H98 mistakes
07:42:10 <dblhelix> praseodym: what do you think of the courses being mentioned at the website?
07:42:15 <Heffalump> plus other key addenda
07:42:34 <SyntaxNinja> let us know if you want us to ask any questions :)
07:42:37 <Heffalump> (what they are is not specified)
07:42:44 <dcoutts> the module system extension + perhaps standardise some more core libs
07:42:48 <earthy> well, H98+FFI+cleanup +standardised hierarchical libs
07:42:55 <CosmicRay> autrijus: btw that was a great read.
07:42:56 * pesco votes for H'06, too.
07:42:59 <autrijus> otherKeyAddenda :: forall a. a
07:43:00 <autrijus> otherKeyAddenda = undefined
07:43:02 <praseodym> dblhelix: some do sound interesting. but with say 'Internetprogrammeren' I really think there's not much for me to learn there
07:43:10 <autrijus> CosmicRay: thanks :)
07:43:17 <Heffalump> "Is Haskell SPJ's latest LSD trip or is it some coherent set of pieces?"
07:43:29 <dblhelix> praseodym: you'd be surprised
07:43:32 <earthy> praseodym: there's more people that think that. I like proving them wrong. :P
07:43:32 <pesco> I also vote for not calling Haskell 2 Haskell 2 but Haskell with a year attached.
07:43:48 <praseodym> earthy: go ahead
07:43:48 <dblhelix> praseodym: but you should ask earthy about that... he's been involved with the course once or twice
07:43:52 <dcoutts> pesco, makes it sounds like a car :-)
07:43:52 <earthy> (I'm the TA running the practical part of 'Internetprogrammeren'. ;))
07:44:13 <autrijus> I think tool writers should just all hook with ghc-api
07:44:16 <Heffalump> he really does want it to be Haskell 06
07:44:17 <shapr> Personally, I want: 1. haskellforge 2. cabal-get, cabal-find, hackage 3. make a list of basic libraries and implement them 4. QuickCheck tests for everything GHC 5. QC Tests for all base libs  6. Haskell Cookbook 7. More TMR articles that aim for motivated commercial programmers 8. some sort of webapp server
07:44:23 <autrijus> but I come from an adhoc language community ;)
07:44:36 <dblhelix> I'd say, let's go for Haskell '08 or so
07:44:49 <dblhelix> that gives us some time to get things sorted out
07:44:52 <praseodym> Haskell Vista
07:45:01 <CosmicRay> haha
07:45:05 <Heffalump> he wants something simple and conservative that can be done quickly
07:45:06 <CosmicRay> psi: Longhaskell?
07:45:20 <dblhelix> Haskell-a-Vista then
07:45:26 <dblhelix> baby
07:45:30 <autrijus> Vaskella
07:45:31 <dcoutts> :-)
07:45:50 <praseodym> well at least you'll have some time then!
07:46:04 <dblhelix> that's the whole point
07:46:09 <dblhelix> we should not be rushing
07:46:22 <shapr> I think we should rush to get prototypes out, but not rush to call them finished.
07:46:27 <autrijus> "if you only care about the practical part, we'll become perl 6!"
07:46:42 <dblhelix> we still need to do some research to type classes and decidability, for instance
07:46:51 <praseodym> earthy: do you have any more details what that internetprogrammeren is about
07:47:02 <rafl> autrijus: Who says that? :-)
07:47:03 <pesco> withSocketsDo!
07:47:08 * dblhelix says bye... it's weekend
07:47:12 <autrijus> rafl: the chair
07:47:15 <Heffalump> SPJ thinks a year would be feasible
07:47:25 <autrijus> <spj> "conservative" extension better than the "reboot" approach of Haskell 2
07:47:26 <Heffalump> rafl: John Launchbury
07:47:33 <dcoutts> dblhelix, yes I think it would be a mistake to standardise on MPTC+FunDeps now, since we don't know where that leads yet
07:47:36 <rafl> :-)
07:47:36 <SyntaxNinja> paul hudak talking now
07:47:46 <praseodym> dblhelix: have a nice weekend
07:47:46 <dblhelix> dcoutts: exactly
07:47:52 <earthy> yeah, just a sec. can you open http://www.cs.uu.nl/docs/vakken/inp/ ?
07:47:54 <dblhelix> praseodym: thank you
07:48:15 <SyntaxNinja> SPJ just mentioned 'thrusting young things' meaning new folks
07:48:21 <shapr> heh
07:48:23 <dcoutts> heh heh
07:48:27 <Heffalump> Lor is talking now
07:48:34 <Heffalump> SyntaxNinja: that's you, isn't it?
07:48:34 <SyntaxNinja> and hudak referred to the 'few lunitics from the original standard'
07:48:44 <shapr> haha
07:49:04 * earthy thinks having a stronger standard library would be very useful
07:49:09 <shapr> Yeah, I agree.
07:49:12 <earthy> *very* very useful
07:49:12 <praseodym> earthy: and still I think I know a lot about it :) cant help it
07:49:21 <SyntaxNinja> I'm strongly considering starting a new stdlibrary effort
07:49:23 <Heffalump> Lor is proposing calling H98/H06 "Stable Haskell" or similar and GHC-Haskell "Experimental Haskell"
07:49:29 <SyntaxNinja> I've talked to spj about this a bit
07:49:31 <pesco> Shouldn't we really try to get extensible records/first class modules sorted out?
07:49:31 <pesco> I always feel a tiny bit guilty when I use H98 records.
07:49:31 <earthy> praseodym: oh, a lot, yes, no problems there. everything? I think not.
07:49:34 <Heffalump> SyntaxNinja: you should mention that.
07:49:37 <autrijus> Haskell-stable and Haskell-current
07:49:46 <earthy> not even I know it all, and I've been hobbying in internetprogramming for at least 10 years
07:49:57 <Heffalump> pesco: that's a scary extension people don't understand yet
07:50:04 <shapr> praseodym: IPv6 is nifty.
07:50:14 <praseodym> earthy: me for 5+ years
07:50:22 <shapr> Heffalump: Speaking of which, motivational examples of every extension in the docs...
07:50:59 <shapr> praseodym: I've been hobbying in internetprogramming for sixteen years, there's still lots to learn.
07:51:15 <Heffalump> shapr: propose that if this committee gets formed.
07:51:17 <dcoutts> SyntaxNinja, would that new stdlibrary effort include the String/Char/Unicode/IO conundrum
07:51:19 <praseodym> innovation doesn't stop, so that logical
07:51:25 <earthy> anyway, the concepts are simple, and it's good to see them spelt out. we try to do that.
07:51:33 <SyntaxNinja> dcoutts: it would be on the table I guess. I haven't scoped this.
07:52:15 <dcoutts> SyntaxNinja, one of our biggest practiccal problems is slow strings and slow IO
07:52:22 <praseodym> earthy: essay topic "More and more of our customers are complaining that our website does not work well in their new browsers. What may be the causes?"
07:52:46 <shapr> What about reviving optimistic GHC?
07:52:51 <earthy> praseosdym: that's to appease the 'informatiekunde' people
07:52:54 <praseodym> earthy: that sounds like, hey, we used IE proprietary extensions with table layout and etc.
07:53:04 <earthy> for instance, yes
07:53:07 <Heffalump> shapr: what does that have to do with a a language standard?
07:53:16 <earthy> zilch
07:53:21 <shapr> It has to do with slow strings and slow IO.
07:53:26 <praseodym> for me it'd be more like problems with old browsers though :)
07:53:30 <autrijus> <daan> 06 has two contradicting goals: "a useful stable base" and "high assurance features"
07:53:38 <dcoutts> shapr, no, I think that's just a question of the standard libs
07:53:40 <autrijus> eg. -fallow-overlapping-instances
07:53:45 <earthy> um? why are those contradictory?
07:54:28 <Heffalump> the 'useful' bit might require -fallow-overlapping-instances
07:54:59 <Heffalump> which might contradict high assurance, though John doesn't think so
07:55:02 <earthy> and that conflicts with high assurance how?
07:55:11 <autrijus> john says it's not about type theoretic safety
07:55:15 <autrijus> so they don't contradict.
07:55:23 <shapr> The more complicated the implementation, the more bugs.
07:55:38 <Heffalump> kosmikus thinks we need more addenda
07:55:42 <Heffalump> as does nibro
07:55:48 <Heffalump> for overlapping instances etc
07:56:00 <arjanb> i think experimenting with haskell compilers should be made easier by making them more like a set of libraries
07:56:01 <dons> addenda are good
07:56:07 <autrijus> mm SRFIs
07:56:18 <earthy> anyway, the things we obviously want included are: hierarchical modules, arrow notation, ...
07:56:26 <shapr> Yeah, cut the compilers into experimentable bits.
07:56:27 <earthy> probably recursive do notation
07:56:29 <autrijus> SRFIs isn't such a bad idea.
07:56:30 <Heffalump> arjanb: well, if you can get SPJ to do it :-)
07:56:50 <Heffalump> Paul Hudak (possibly) wants a formal static semantics
07:56:55 <earthy> infix type constructors
07:56:59 <paolino> why this is faulty ? head. head [[1,2],[3,4]]
07:57:10 <Heffalump> the discussion is at a higher level than such specifics
07:57:14 <autrijus> arjanb: they are already -- they just have incestous interdependent interfaces
07:57:17 <Heffalump> paolino: (head.head) [[1,2],[3,4]]
07:57:30 <earthy> hef: a formal static semantics... ugh
07:57:30 <Heffalump> space binds tighter than .
07:57:40 <nibro> ohoh, here goes Tim...
07:57:46 <arjanb> it's useful for things like hide too
07:57:48 <Heffalump> nibro: :-)
07:57:49 <tromp> you were doing head . [1,2]
07:58:05 <Heffalump> Tim Sheard wants Haskell 2.
07:58:08 <praseodym> how long does ghc take to compile
07:58:16 <Heffalump> (with the implication of it being a kitchen sink language, I think)
07:58:18 <autrijus> praseodym: 4hr here
07:58:22 <praseodym> wow
07:58:23 <praseodym> besides, are the haskell compilers for windows and ppc?
07:58:24 <Heffalump> or maybe just that it should be Omega.
07:58:26 <paolino> ah got it
07:58:29 <dons> well, formalising things in twelf are a nice idea
07:58:32 <nibro> ... and I can guess what he would want in it... (*cough* Omega *cough*)
07:58:32 <autrijus> praseodym: sure, ghc and ghc :)
07:58:35 <Heffalump> oh, no, he's saying it should be smaller.
07:58:48 <Heffalump> Johan Jeuring says you can't do Haskell 2 by committee.
07:58:54 <autrijus> yup.
07:58:56 <praseodym> autrijus: haha :) well it's compiling now
07:59:05 <autrijus> praseodym: you should be able to find a precompiled binary
07:59:12 <earthy> um, yes you can
07:59:14 <Heffalump> and that it should be Haskell 10 ;-)
07:59:22 <earthy> but you end up with Haskell'68 :P
07:59:28 <autrijus> Haskell 2098
07:59:35 <autrijus> the Hundred-Year language indeed!
07:59:40 <Heffalump> John Launchbury is volunteering some effort from Galois.
07:59:43 <praseodym> autrijus: oh yeah I got one installed, but I'm a gentoo user
07:59:46 <SyntaxNinja> :)
07:59:48 <earthy> which is so hard to implement that everybody will abandon it
08:00:01 <Heffalump> SPJ wants to know who will help with H06.
08:00:14 <earthy> and the languages that then arise and become popular will no longer have the beauty and elegance of Haskell
08:00:28 <Heffalump> several important volunteers.
08:00:42 <SyntaxNinja> email john@galois.com if you're willing
08:01:09 <shapr> What will it involve to work on H06?
08:01:30 <praseodym> autrijus: when it's released in 2098 you should definitely call it haskell vista
08:01:33 <Heffalump> a range of things.
08:01:38 <earthy> anyway, I think conservative extensions would be 'that stuff that nhc, ehc, hugs and ghc agree on'
08:01:41 <Heffalump> I asked if the RFC-feedback process would be open and he said yes
08:01:47 <earthy> and that isn't in H'98 yet
08:01:48 <dcoutts> good
08:01:50 <Heffalump> decisions made by the committee, but comments from the community.
08:01:55 <dcoutts> good
08:01:58 <Heffalump> discussion over now, SPJ is on.
08:02:00 <dons> earthy, but also stuff that non-ghc doesn't have, but that we often need
08:02:08 <SyntaxNinja> spj on "social process"
08:02:13 <earthy> dons: true enough
08:02:18 <autrijus> "Apps and Tools" group
08:02:24 <SyntaxNinja> Heffalump is taking off his shirit
08:02:25 <SyntaxNinja> shirt
08:02:25 <earthy> I'm not one to speak. I have code requiring undecidable instances. :P
08:02:31 <shapr> SyntaxNinja: haha!
08:02:32 <Heffalump> just one layer :-p
08:02:41 <shapr> Heffalump: Is this a Wadler reference?
08:02:50 * Heffalump 's visible T-shirt now says </Heffalump> on the back
08:02:56 <Heffalump> as opposed to advertising an AspectJ compiler
08:03:11 <paolino> Is type inheritance multiple ?
08:03:14 <praseodym> what specific IDE do you recommend (using kde) or would you recommend me getting haskell syntax highlighting for kate
08:03:16 <shapr> I definitely want in on an Apps and Tools group.
08:03:21 <autrijus> paolino: typeclass? yes
08:03:28 <dcoutts> shapr, me too :-)
08:03:39 <metaperl> who participated in ICFP this year? is this on the Haskell Wiki? The Monad Reader?
08:03:46 <metaperl> the programming contest I mean
08:03:54 <autrijus> spj is saying that "GHC and Libraries" people keeps getting requests and/or demands from them
08:03:54 <Heffalump> I did.
08:04:03 <Heffalump> Haskell came 1st and 3rd (not us)
08:04:09 <metaperl> Heffalump: which place did you get? 7th?
08:04:10 <dcoutts> we came 7th
08:04:12 <Heffalump> I think we came either 5th or 7th, but I don't understand the results.
08:04:14 <shapr> Cabal will let libraries evolve faster than GHC.
08:04:15 <autrijus> "GHC+Libraries" is a large surface for things to go wrong in them
08:04:19 <autrijus> shapr: yes
08:04:25 <Heffalump> dcoutts: two of the people above us apparently failed, so I'm not sure if they should really be counted..
08:04:25 <SyntaxNinja> cabal! woohoo
08:04:25 <autrijus> but not without hackage :)
08:04:35 <metaperl> who placed first? and third?
08:04:43 <paolino> how can I ask a type its ancestors ?
08:04:47 <shapr> Simon Marlow said something recently about cutting GHC down to just enough to bootstrap. I think that's a good idea.
08:04:54 <earthy> yup
08:04:55 <autrijus> minighc
08:04:56 <shapr> Everything else should be in cabal-get.
08:04:57 <autrijus> yeah.
08:05:00 <autrijus> yup.
08:05:00 * dcoutts agrees with shapr 
08:05:03 <earthy> agreed
08:05:04 <Heffalump> paolino: types don't have inheritance
08:05:15 <earthy> but that is not important to the language spec. or... well... it is, in a sense
08:05:28 <pesco> Cabal-get really needs to get out of beta.
08:05:30 <shapr> I also think that everything cvs.haskell.org should be available via darcs.
08:05:32 <CosmicRay> yes indeed.
08:05:33 <Lemmih> s/cabal-get/hackageDB/
08:05:38 <pesco> And cabal-put!
08:05:44 <Heffalump> shapr: shout about Hackage
08:05:49 <shapr> darcs.haskell.org will get GHC and libraries moving much faster.
08:05:49 <Heffalump> s/shapr/SyntaxNinja/
08:05:51 <earthy> as that which is necessary to get minighc working should be in the standard libs
08:05:56 <Heffalump> ah, SPJ mentioned it
08:06:01 <dcoutts> we need more people working on Hackage, since Lemmih is overworked
08:06:12 <pesco> Lemmih, maybe, just _maybe_, I'd like to work with you on cabal-getput.
08:06:17 <SyntaxNinja> aww, spj put a smily face next to cabal
08:06:25 <autrijus> aww as in very cute?
08:06:27 <pesco> Lemmih: It's a question of availability, not will, mind you. ;-)
08:06:28 <dcoutts> I have a list of hackage fixes I would like
08:06:37 <Lemmih> pesco: (:
08:06:37 <shapr> We also need darcs push that does cgi+gpg.
08:06:41 <nibro> I think that symbolizes Happy :)
08:07:00 <shapr> er, darcs send?
08:07:16 <Heffalump> shapr: that would be an easy tool to implement externally
08:07:26 <autrijus> (community ownership)++
08:07:33 <dcoutts> shapr, no it'd be darcs push because it would be syncronous
08:07:39 <paolino> Heffalump, so how I say a type implents two classes ?
08:07:59 <Heffalump> paolino: two different instance declarations
08:08:01 <dcoutts> paolino, instance Class1 Foo; instance Class2 Foo
08:08:02 <Heffalump> but that's not inheritance
08:08:29 <shapr> If the GHC development roadmap and process were better known, it's likely GHC groupies would help Simon Marlow with whatever he's doing now.
08:08:40 <Heffalump> shapr: like whom?
08:08:50 <Heffalump> there are people who help with some GHC things
08:08:52 <dcoutts> and it being accessable via darcs would help
08:08:58 <Heffalump> but GHC is a big complicated bit of code
08:09:01 <Heffalump> dcoutts: yeah.
08:09:10 <Heffalump> But big stuff with darcs isn't very reliable yet IMO.
08:09:13 <Lunar^> minighc would be a lot better for packaging, also
08:09:21 <shapr> Heffalump: Yes, and those people mostly work independently rather than focussing on a specific goal.
08:09:25 * dcoutts agrees with Lunar^ 
08:09:48 <paolino> ok, then how I get known that Foo implements Class1 and Class2 ?
08:10:12 <shapr> Whether reliable or not, darcs will bring in code from the community.
08:10:14 <dcoutts> paolino, by writing instance declerations for them
08:10:23 <dcoutts> shapr, yeah :-)
08:10:23 <Heffalump> Simon Marlow wants a better bug tracking system.
08:10:32 <dcoutts> bugzilla?
08:10:36 <shapr> What about trac+darcs ?
08:10:38 <autrijus> I volunteered to set up rt. :)
08:10:41 <Heffalump> well, anything would be better than sourceforge
08:10:47 <dcoutts> Igloo's bark thing?
08:10:52 * Lunar^ agrees with Heffalump
08:10:54 <shapr> Right, bark is a good idea.
08:10:58 <Heffalump> that's what he said
08:11:05 * dcoutts agrees with Heffalump, sourceforge's bug system is ****
08:11:09 * Heffalump suggests something mature (and preferably not rt)
08:11:17 <Lunar^> dcoutts: URL?
08:11:19 <dcoutts> bugzilla
08:11:24 <shapr> sourceforge is mature ;-)
08:11:25 <Heffalump> bugzilla or the debian system IMO
08:11:28 <Heffalump> shapr: and shit
08:11:34 <autrijus> Heffalump: weird, you prefer bugzilla over rt.
08:11:53 <Lemmih> rt?
08:11:54 <shapr> hiya conal
08:11:58 <Heffalump> droundy is suggesting breaking things out of fptools
08:12:02 <dcoutts> Lunar^, URL for what?
08:12:04 <conal> hey shapr
08:12:07 <Lunar^> dcoutts: bark
08:12:16 <autrijus> Lemmih: http://www.bestpractical.com/rt/
08:12:19 <dcoutts> @where bark
08:12:20 <lambdabot> I know nothing about bark.
08:12:36 <shapr> Lunar^: http://urchin.earth.li/darcs/ian/bts/
08:12:45 <dcoutts> @where+ bark http://urchin.earth.li/darcs/ian/bts/
08:12:47 <lambdabot> bark ~> http://urchin.earth.li/darcs/ian/bts/
08:12:56 <earthy> that's implementation again
08:13:03 <SyntaxNinja> lots of hackage talk
08:13:11 <Heffalump> kosmikus is asking about breaking up ghc (sort of)
08:13:28 <SyntaxNinja> spj wants to go o the "darcs ide"
08:13:28 <Heffalump> SPJ says ghc will get darcs-ified.
08:13:31 <SyntaxNinja> ;)
08:13:36 <shapr> yay!
08:13:38 <Lunar^> yay!
08:13:45 <autrijus> yay!
08:13:50 <SyntaxNinja> simon mar was non-commital ;)
08:13:51 <dcoutts> SyntaxNinja, you can note that we have developed a semi-automatic Hackage -> Portage sync system
08:13:55 <Heffalump> the consensus is that darcs-ification helps lower barriers to entry.
08:13:55 <shapr> SyntaxNinja: haha!
08:14:10 <SyntaxNinja> dcoutts: oh, I mentioned that in Trends in FP
08:14:12 <malcolm> I'm enjoying the blow-by-blow description of the discussion - but I wonder if anyone there can stream the audio to me via skype etc :-)
08:14:17 <earthy> lower barrier to entry is always good
08:14:24 <dcoutts> SyntaxNinja, oh cool
08:14:39 <shapr> conal: Are you here for the blow-by-blow on the Future of Haskell discussion?
08:14:43 <nibro> kosmikus == Andres Lh?
08:14:45 <Heffalump> simon marlow says debundling of fptools will happen when hackage does
08:14:47 <earthy> nibro: yup
08:14:47 <Heffalump> nibro: yes
08:14:57 <nibro> thanks :)
08:15:03 <dcoutts> we need more hackage hackers
08:15:07 <Heffalump> (kosmikus is in the chair for the discussion, for the benefit of everyone else)
08:15:09 <SyntaxNinja> simon mar wants to attend a class for "how to become a ghc hacker"
08:15:14 <shapr> YES!
08:15:27 * Heffalump needs to start saving up for next year's ICFP.
08:15:38 <shapr> An introductory GHC hacker class would really help.
08:15:42 <dcoutts> indeed
08:15:45 * Lunar^ hopes it'll be in europe again 
08:15:47 * earthy needs to find something to talk about for next year's ICFP... that'd mean me actually going there. ;)
08:15:50 <conal> shapr, no.  hadn't heard about it.  going on now?
08:15:55 <Heffalump> conal: yes, at HW
08:15:56 <SyntaxNinja> ghc hackathon proposed
08:15:57 <shapr> conal: Yes, on this channel.
08:16:00 <shapr> SyntaxNinja: w00!
08:16:00 <Heffalump> the usual Future of Haskell discussion
08:16:03 <earthy> next year will be in portland, oregon, right?
08:16:04 <SyntaxNinja> hi malcolm
08:16:10 <Heffalump> several of us in both places are trying to interface
08:16:33 <Heffalump> malcolm: sorry, it's too unreliable on my laptop atm.
08:16:36 <Oejet> Здравстуйте, хаскель канал.
08:16:44 <autrijus> ghc hackathon would rock.
08:16:45 <Heffalump> oh, well it'sabout to finish anyway.
08:16:46 <earthy> anyway, was this the future of haskell, the language, or the future of ghc?
08:16:47 <malcolm> SyntaxNinja: are you offering to skype me?
08:16:50 <Heffalump> I should have tried earlier.
08:16:54 <Heffalump> malcolm: it's just finishing
08:16:55 <SyntaxNinja> malcolm: no, sorry. no skype
08:17:08 <earthy> since ghc is but one element of the equation
08:17:12 <Heffalump> seems like H06 is a concrete thing happening.
08:17:18 <earthy> *good*
08:17:19 <shapr> awesome!
08:17:19 <Heffalump> It's the usual "Future of Haskell" discussion.
08:17:34 <Heffalump> all over.
08:17:35 <earthy> now, someone needs to update the 'The Future of Haskell' page on www.haskell.org
08:17:39 <earthy> :P
08:17:41 <malcolm> Oh, I keep forgetting about the time difference - missed most of it.
08:17:54 <shapr> Speaking of which, haskell.org needs to be community manageable.
08:18:05 <earthy> um, well, sorta
08:18:07 <shapr> Hand editing html is no fun.
08:18:30 <Lemmih> autrijus: Looks nice.
08:18:32 <Heffalump> SPJ wants a HW steering committee.
08:18:39 <dcoutts> shapr, yes the front page doesn't even mention Haskell's triumph at the ICFP contest
08:18:46 <shapr> right
08:19:06 <shapr> I could go fix that, but I wonder if I'll break something else?
08:19:20 <shapr> dcoutts: Have a suggestion for the text to put there?
08:19:41 <autrijus> Lemmih: I'm biased as I'm a RT core hacker, but to me it's the least effort path -- seeing how it already powers rt.cpan.org without any maintainence at all for a long time  :)
08:20:19 <shapr> Ah, I'll use the same text from 2004.
08:20:49 * Heffalump leaves. #haskell people here, don't forget to meet up!
08:20:50 <dcoutts> shapr, <i>"Haskell is the programming tool of choise for discriminating hackers"</i>
08:21:11 * SyntaxNinja is hungry
08:21:13 <Heffalump> you can find me or Igloo or anyone else who is coming to the meet.
08:21:16 <Heffalump> or SyntaxNinja
08:21:22 <Heffalump> <gone>
08:22:11 <nibro> aye, time to shut down
08:22:27 <dcoutts> shapr, for the second year running. The teams winning first and third place in the ICFP 2005 programming contest both used Haskell.
08:22:42 <dcoutts> for the second year running!
08:22:49 <dcoutts> with the ! mark
08:23:08 <dcoutts> so it should flow as one sentance <i>"Haskell is the programming tool of choise for discriminating hackers"</i> for the second year running!
08:23:12 <SamB> what about second place?
08:23:31 <dcoutts> SamB, dylan took 2nd place
08:23:42 <SamB> ah
08:23:44 <prionic> dylan, interesting language if i may say so
08:23:50 <SamB> last time too?
08:23:59 <SyntaxNinja> wrapping up again
08:24:00 <SyntaxNinja> l8r all
08:24:40 <shapr> dcoutts: looks okay?
08:24:58 <dcoutts> shapr, you don't need the first '!'
08:25:15 <dcoutts> but otherwise yes fine.
08:25:40 <malcolm> s/choise/choice/
08:25:41 <shapr> SPJ asked me to put TMR onto the front page at some point.
08:25:44 <dcoutts> to be picky, this year the judges said "programming tool of choice"
08:26:26 <shapr> Ok, fixed
08:27:47 <dcoutts> shapr, nice
08:28:04 <shapr> Anything else?
08:28:14 <shapr> What about Haskell Weekly news?
08:28:31 <dcoutts> oh, hmm not sure.
08:28:49 <malcolm> Yeah. I like the idea of a link to HWN on the front page.
08:28:49 <dcoutts> it's not quite the same category as the other news items
08:29:17 <dcoutts> HWN & TMR are a slighlty differnt category of thing from the other news items
08:30:01 <malcolm> Maybe put them next to "book, tutorials, mailing lists, wiki" etc
08:30:02 <dcoutts> hmm it doesn't even have the communitites & activities report linked from the front page
08:30:08 <shapr> If someone will dump me some text for "Future of Haskell" I'l put it online.
08:30:49 <dcoutts> the HWN, TMR & HCAR should get a section
08:31:04 <shapr> How about "You can learn more about the Haskell community by reading The Communities and Activities Report, Haskell Weekly News, and The Monad.Reader."
08:31:23 <shapr> TC&AR is biannual?
08:31:25 <dcoutts> oh, my mistake, the HCAR is linked from the front page, just not where I was looking
08:31:35 <malcolm> shapr: you can bump the "last update" line to today's date too
08:31:53 <shapr> malcolm: ah, thanks for spotting that.
08:31:59 <malcolm> HCAR is semi-annual, not biennial
08:33:18 <shapr> Ah right, I always get those confused.
08:33:49 <shapr> Once GHC is in a darcs repo, I'd like to get the website in another repo.
08:34:01 <malcolm> It's the length of time between issues - half a year, vs two years.
08:34:19 <shapr> And while we're at it, can we switch haskell.org to debian/unstable? I'd be willing to do more haskell.org sysadmin work then.
08:34:46 <earthy> damn shame EuroOSCon is so expensive
08:35:03 <shapr> We need another free Haskell gathering.
08:35:13 <dcoutts> shapr, I think you should ask around a bit before that, I'm quite happy with their current setup
08:36:13 <shapr> The existing system does a lot of things right, but I can still suggest improvements.
08:36:49 <shapr> Debian would mean easy upgrading of ghc and darcs.
08:36:49 <dcoutts> eg?
08:37:08 <shapr> And I could rip out the current website and put in something that authenticated users can edit.
08:37:23 <dcoutts> that'd be nice
08:37:54 <shapr> There's no index for haskell.org. A lot of neat websites and papers there aren't well known in the community.
08:38:09 <earthy> and that is a true pity
08:38:28 <dcoutts> shapr, oh you can remove the "ICFP 2005 Programming Contest; starts 24 June 2005." news item
08:39:07 <shapr> So, I'd like to have debian so I can change things myself.
08:39:15 <dcoutts> yes I see
08:39:20 <shapr> dcoutts: ok, done.
08:39:43 <dcoutts> I guess all the ICFP news is old news too now
08:40:13 <shapr> If an auth'd user framework were in place, you could fix this yourself :-)
08:40:37 <dcoutts> heh
08:42:23 <Si\Uni> How do I create executables with Cabal in GHC 6.4? All I get when I add an "executable" field is *** Exception: Line 13: Unknown field 'executable'
08:42:47 <shapr> I dream of a web-based Haskell CMS.
08:43:49 <pesco> shapr: We need a CMS for khjk.org, want to sync ideas some time?
08:43:57 <shapr> Yes, definitely.
08:44:30 <shapr> Si\Uni: I think yi and hs-plugins both create executable. You may need to upgrade to the latest Cabal.
08:46:02 <shapr> pesco: Seen hswebforms?
08:46:34 <pesco> shapr: I basically wish for something with a clear background structure that can be cleanly mapped to the external representation (HTML), basically avoiding a distinction between "user" and "developer" view.
08:46:36 <Si\Uni> Yi doesn't appear to use Cabal
08:46:45 <pesco> shapr: No, I've not seen hswebforms.
08:48:06 <pesco> shapr: I'm thinking of arranging documents in relations, or a graph, and basically building a web interface to view that structure.
08:49:06 <pesco> Maybe taking files or some kind of general objects with associated metadata as the relations.
08:49:36 <shapr> That would be very nifty.
08:49:47 <pesco> Then you would probably navigate through this structure, so there would be a "current object" on display or so.
08:50:17 <pesco> Different relations could receive different handling, as in, linking to another object, or being displayed in-line.
08:50:48 <shapr> Sort of like deriving HtmlShow from a Data.Graph ?
08:50:53 <pesco> But there must be answers to questions like "are there 'directories'"?
08:51:00 <pesco> shapr: Kind of, probably.
08:51:22 * dcoutts wants to make a graph view browser plugin for hIDE
08:51:31 <pesco> And "Do 'people' appear as objects in this system"?
08:51:33 <shapr> How would a web request ask for a part of the graph?
08:51:59 <pesco> shapr: No idea.
08:52:56 <pesco> You could specify a relation that forms a spanning tree, for your typical tree-view side menu.
08:53:07 <shapr> pesco: You could have a WebPubish typeclass to know how to display a certain value in html/xml.
08:53:18 <shapr> malcolm: Any ideas on that?
08:53:57 <malcolm> shapr: been away hacking code - what is the question?
08:53:58 <shapr> The navigation could be a graph holding WebPublish instances.
08:54:20 <shapr> We were just wondering about a good way to design a website framework in Haskell.
08:54:39 <shapr> I suggested a WebPublish typeclass, sort of like Show for html/xml.
08:55:25 <shapr> musasabi's hswebforms uses HaskellDB to derive view/edit forms for database rows. That would be cover a lot of my daily work.
08:55:59 <shapr> malcolm: Any thoughts on the matter?
09:02:58 <malcolm> shapr: What's the difference between a WebPublish class and the Haskell2Xml class in HaXml?  (The latter is a Read/Show-like combination, only for XML rather than text)
09:04:14 <shapr> Hm, just me needing to read HaXml docs, I think...
09:04:51 <malcolm> DrIFT is capable of deriving instances of Haskell2Xml.  As it happens, I have also been improving the API recently - the class methods types will change, and it should have better error-reporting.
09:04:53 <Si\Uni> Personally, I would recommend a homogenous (i.e. non-HTML) output of the data you want to present, and then an XSL script to convert it to XHTML
09:05:06 <Si\Uni> that way you have abstraction from the presentation layer
09:05:51 <Si\Uni> and each page is simply a data-type with suitable Haskell2Xml/XMLData instances
09:07:04 <shapr> That does sound nice.
09:07:44 <Si\Uni> problem is XSL support is poor; HXT does have it but only very preliminary. You'd need to confine yourself to almost pure XPath
09:08:21 <malcolm> You could write an XSL-like script to convert XML->HTML using HaXml.Combinators :-)
09:09:27 <Si\Uni> well, it's mostly XPath anyway.
09:09:48 <Si\Uni> yeah that's a possibility
09:09:59 <shapr> Ulf Norell wrote some TH code to do deriving for typeclasses not supported in GHC.
09:10:18 <shapr> I like it!
09:10:48 <Si\Uni> yeah, see my two papers on HAIFA, they do similar
09:11:38 <Si\Uni> but HaXML has DrIFT support anyway
09:12:55 <shapr> After that, CMS features would be authentication and ... ?
09:13:01 <malcolm> DrIFT is more portable across compilers
09:13:48 <Si\Uni> yes, it just can't do IO
09:37:20 <manulito_> is there any easy way to get the first or the second value from a tuple, if its returned by a function, something like head/last on lists?
09:37:42 <ibid> fst, snd?
09:37:55 <manulito_> niec!
09:37:57 <manulito_> thanks
09:39:40 <Oejet> manulito_: Hang around a bit, you might have some more questions.
09:52:03 <Blastur> @eval last [1..]
09:52:11 <lambdabot> Terminated
09:53:30 <Blastur> is there an easy way to compare the contents of 2 lists? the order may differ, but i want to check that both lists contains the same elements
09:54:01 <tromp> sort them?!
09:54:32 <tromp> is [1] same as [1,1] for u?
09:55:08 <Blastur> both lists should be of same length, and contain the same contents.. the only thing that differs is the order
09:55:24 <basti_> are the lists sorteable?
09:55:26 <Blastur> sorting is a problem, since i don't know what kind of elements the list contains
09:55:32 <basti_> aj
09:55:33 <basti_> ah
09:55:36 <tromp> is [0,1,1] same as [0,0,1] then?
09:55:50 <basti_> Blastur: tried sets?
09:55:52 <Blastur> tromp: no
09:56:04 <Blastur> [0,1,0] is the same as [1,0,0]
09:56:08 <Blastur> etc
09:56:15 <basti_> ah then you'd need multisets
09:56:44 <Blastur> so, basically, foreach in list 1, check if it exists in list 2.. and then finally, check that length list1 == length list2
09:56:56 <tromp> no
09:57:12 <malcolm> xs `same` ys = all (`elem`ys) xs && all (`elem` xs) ys
09:57:22 <tromp> the
09:57:35 <tromp> then  [0,1,1] ==  [0,0,1]
09:57:57 <Blastur> okay, then its tricker =)
09:58:36 <basti_> Blastur: put the first list into a set, then remove each element of the second list
10:00:16 <kowey> hello, is there a Bart Robinson in the room by any chance?
10:00:39 <kowey> (or Paul Hudak maybe... or somebody who knows about wxFruit)?
10:00:50 <tromp> check that each el occurs same number of times in both lists
10:01:41 <basti_> kowey: uhmh. how does that go together with haskell?
10:02:21 <kowey> basti_: http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
10:02:28 <kowey> i believe that goes with haskell :-)
10:03:05 <beschmi> you need instances of Ord if you want to use Data.Set
10:03:12 <kowey> was looking for some hand holding on compiling his code... will send a mail if need be
10:03:24 <basti_> ooh ok
10:03:32 <basti_> whats the problem?
10:04:14 <RemiTurk> hi all
10:04:37 <kowey> ./WXFruit.hs:81:31: parse error on input `->'
10:04:49 <basti_> hmmm
10:04:52 <kowey> maybe it's something silly, i don't know... i thought it had something to do with arrows
10:05:20 <kowey> (which i know nothing about... maybe somebody could help)
10:05:33 <basti_> probably not
10:05:46 <basti_> oh yes it does
10:05:50 * basti_ saw the sourcecode
10:06:06 <basti_> you have to give the compiler some option to add arrows
10:06:36 <basti_> -farrows iirc
10:07:36 <kowey> aha!
10:07:51 <kowey> oh... now i get linker errors
10:07:53 <basti_> :D
10:07:56 <kowey> ok, well thanks!
10:08:05 <basti_> Graphics.UI.WX?
10:08:26 <kowey> /usr/bin/ld: Undefined symbols:
10:08:26 <kowey> _AFRPEvent_merge_closure
10:08:29 <kowey> and a bunch of stuff
10:08:33 <basti_> uhh
10:08:47 <kowey> hmmm... gotta run... thanks for the help so far
10:08:50 <basti_> try --make
10:09:05 <kowey> ghc -package afrp -farrows --make paddle.hs
10:09:10 <kowey> bye :-)
10:20:54 <dcoutts> Lemmih, dons: I'm pushing some UI patches
10:21:08 <dcoutts> it's a significant UI code reorganisation & cleanup
10:21:43 <dcoutts> dons, so I'd like to get Yi done as an editor in this new UI scheme
10:22:29 <praseodym> just wondering.. how exactly does one compile a haskell compiler written in haskell
10:22:36 <basti_> :D
10:22:41 <basti_> praseodym: magic!
10:22:47 <basti_> no honestly
10:23:12 <dcoutts> praseodym, using another Haskell compiler or interpreter
10:23:12 <basti_> there was a bootstrap compiler for a subset language written in another language
10:23:20 <praseodym> hm yeah
10:23:29 <praseodym> gentoo merged ghc-bin first
10:23:44 <dcoutts> the really tricky one is building ghc which needs ghc to build, not just any old haskell compiler
10:23:46 <SamB> hmm, my hacked MMIX emulator is now looping on a virtual address translation trap... which, believe it or not, is actually encouraging ;-)
10:23:47 <basti_> ah i thought you were referring to the general problem
10:24:01 <dcoutts> praseodym, yes we use a -bin version to bootstrap with
10:25:01 <SamB> actually, I have no clue what trap it is looping on...
10:25:32 <praseodym> dcoutts: are you a gentoo dev?
10:25:38 <dcoutts> praseodym, yep
10:25:56 <dcoutts> praseodym, if you've got an questions feel free to ask in #gentoo-haskell
10:26:05 <dcoutts> an/any
10:27:04 * RemiTurk is feeling very disappointed neither Yi nor Darcs have any new remote changes to pull in since last time I checked
10:27:10 <dcoutts> dons, I should split the demo editor out into a seperate plugin package, just to show how it's possible to write a handler thingy
10:27:11 * RemiTurk forgot a ;) there
10:27:18 <praseodym> dcoutts: do not yet have any problems :)
10:27:19 <dcoutts> RemiTurk, check hIDE, it's got some changes :-)
10:27:26 <dcoutts> praseodym, good good
10:27:50 * RemiTurk will
10:27:53 <dcoutts> RemiTurk, you've seen the new Gtk+ UI for Yi?
10:28:03 <dcoutts> Lemmih, ping
10:28:21 <dcoutts> Lemmih, are we going to see some more of your code in the hIDE repo soon?
10:28:31 <dcoutts> I'm eager to see it
10:28:33 <RemiTurk> dcoutts: not yet. where is it..?
10:28:43 <dcoutts> @where hIDE
10:28:44 <lambdabot> http://www.haskell.org/hawiki/hIDE
10:29:00 <dcoutts> RemiTurk, the instrustions are on the wiki ^^^
10:29:20 <RemiTurk> ahh, hIDE _is_ more or less Yi+Gtk+...? ;)
10:29:26 <RemiTurk> (right now, that is)
10:29:31 <dcoutts> yep
10:29:44 <dcoutts> but it's going to aggregate much more
10:30:03 <dcoutts> more accurately, Yi is the editor component of hIDE
10:31:14 <praseodym> whats a good editor for kde
10:31:28 <RemiTurk> hm, does it need the new cabal? (*** Exception: Line 12: Unknown field 'hs-source-dirs')
10:31:49 <dcoutts> RemiTurk, yeah it probably does, try Cabal 1.1.3
10:31:50 * RemiTurk remembers something about a new cabal not being packaged with 6.4.1
10:31:53 * RemiTurk will
10:31:57 <praseodym> dcoutts: there aint an ebuild for hIDE is there
10:32:09 <dcoutts> RemiTurk, yep but you can easily upgrade Cabal
10:32:28 <dcoutts> praseodym, that's because it's very much alpha quality software
10:32:39 <praseodym> dcoutts: I see
10:32:52 <dcoutts> praseodym, hIDE is about a week of so old :-)
10:33:00 <praseodym> lol
10:33:54 <praseodym> oh, also, what would be a good way to create graphs using haskell
10:34:22 <praseodym> just talking about line-graphs here
10:34:43 <dcoutts> visual representations of graphs?
10:36:49 <Blastur> whenever i hit ctrl+c to abort the execution of a ghci evaluation, it seems to put me into some odd mode where every odd line inputted is interpretted by the windows shell, and every other is interpretted by ghci? only way to fix this is to restart ghci
10:38:18 <dcoutts> Blastur, wierd. Report it as a bug.
10:38:59 <Blastur> i get it everywhere, tried it on several machines, (win xp & win2k), different versions, ghc v6.4.0 and ghc 6.4.1 etc
10:39:48 <dcoutts> definately a bug then :-)
10:40:05 <dcoutts> the ghc devs mostly use linux so they might not have noticed
10:40:11 <dcoutts> so it's best to report the bug
10:40:43 <SamB> I blame windows ;-)
10:41:05 <Blastur> i thought it may be a feature or something
10:41:21 <Blastur> since ghci has built-in support to execute shell commands from within the program
10:41:32 <praseodym> dcoutts: visual representations yes
10:41:50 <dcoutts> praseodym, use graphviz
10:41:58 <SamB> it sounds like somehow the shell stops waiting for GHCi to exit without GHCi actually waiting
10:42:22 <SamB> s/waiting$/exiting/
10:43:09 <SamB> maybe GHCi has multiple processes?
10:43:19 <dcoutts> SamB, don't think so
10:46:39 <praseodym> how can I use graphviz with haskell
10:49:41 <dcoutts> praseodym, output to (one of) the graphviz text format(s) and run one of the graphviz layout programs and get it to produce the output formate you want
10:49:56 <dcoutts> eg png, svg, web imange map formats etc
10:50:29 <dcoutts> it's only about 30 lines of code to produce the graph text format
10:50:53 <syntaxfree> hello.
10:51:16 <syntaxfree> I'm trying to declare a function's type to receive two lists of numbers and return one number.
10:51:24 <syntaxfree> to no avail.
10:52:40 <syntaxfree> help?
10:53:01 <int-e> syntaxfree: something like x :: Num a => [a] -> [a] -> a ?
10:53:38 <syntaxfree> I tried x :: [Num a] -> [Num a] -> Num a
10:53:48 <syntaxfree> I think I don't understand type declarations yet.
10:54:11 <int-e> ah. no, you need a type (a) that's an instance of the num class - the type context Num a =>  does that.
10:54:20 <syntaxfree> I see.
10:54:36 <syntaxfree> yes, but will that accept two lists of integers and return a float if necessary?
10:54:40 <int-e> (Num is a type class, not a type constructor)
10:55:09 <syntaxfree> problems. GHCI won't take it.
10:55:17 <syntaxfree> I'll make a lisppaste.  Just a min.
10:55:32 <int-e> hmm.
10:56:41 <lisppaste2> syntaxfree pasted "so how do I declare type exactly?" at http://paste.lisp.org/display/12100
10:57:05 <int-e> @type (**)
10:57:10 <lambdabot> forall a. (Floating a) => a -> a -> a
10:57:30 <syntaxfree> Floating is a type class, right?
10:57:41 <int-e> yes.
10:57:50 <syntaxfree> but shouldn't Floating be a subset of Num?
10:57:59 <syntaxfree> What's the most general class of numbers?
11:00:55 <PeterK> funk :: Num a => [a] -> [a] -> a \n funk m n = product m + sum n \n ... funk [2.5, 2.0] [1..4] works for me (and prints 15.0)
11:01:10 <int-e> Num. Floating is more specific than Num; rmse :: Floating a => [a] -> [a] -> a  will compile
11:01:21 <syntaxfree> it does indeed.
11:01:24 <int-e> every Floating instance is a Num instance but not vice versa
11:01:36 <int-e> you might also think about using ^ or ^^
11:01:37 <syntaxfree> so Floating is really a subset of Num.
11:01:41 <int-e> @type (^)
11:01:42 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:01:42 <int-e> @type (^^)
11:01:43 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:01:45 <syntaxfree> What are non-floating Nums?
11:02:09 <int-e> syntaxfree: integers
11:02:12 <int-e> to name one
11:02:34 <int-e> replace (**2) by (^2) and it'll work with Nums
11:02:37 <syntaxfree> well. But then I can't feed a list of integers to a function that expects a list of Floatings, then.
11:02:41 <RemiTurk> dcoutts, I had to pass -cpp to runhaskell to configure Setup.lhs. Am I doing something wrong, is it intentional or a bug? ;)
11:03:08 <RemiTurk> dcoutts, sorry, I'm talking with my hair
11:03:19 <int-e> syntaxfree: there's a reason for having three different exponentiation operators in Haskell :)
11:03:32 <syntaxfree> ok. more problems.
11:04:22 <int-e> oh. but you use sqrt. dang
11:04:25 <int-e> @type sqrt
11:04:26 <lisppaste2> syntaxfree pasted "nothin' but trouble" at http://paste.lisp.org/display/12101
11:04:26 <lambdabot> forall a. (Floating a) => a -> a
11:05:02 <syntaxfree> Haskell's type system is pretty annoying. And what bugs me the most is that if I don't declare types, stuff will Just Work.
11:05:10 <syntaxfree> I'm tempted to pretend Haskell's dynamically typed sometimes.
11:05:38 <int-e> syntaxfree: there are cases where it doesn't work without explicit types.
11:05:55 <syntaxfree> I'd guess so.
11:06:03 <syntaxfree> And I'm trying to learn things the Right Way.
11:06:21 <arjanb> you can ask for the type of a function with :t in ghci
11:06:52 <dcoutts> RemiTurk, sorry I don't know what you're building exacly
11:07:00 <syntaxfree> yes. But it doesn't always guess it the best way.
11:07:12 <syntaxfree> I want "rmse" to accept possible lists of integers.
11:07:26 <syntaxfree> and return a float, obviously.
11:07:53 <syntaxfree> Can I do something like (Num a) (Floating b) => [a]->[a]->b?
11:08:14 <int-e> you can certainly declare (Num a, Floating b) => [a] -> [a] -> b
11:08:24 <syntaxfree> I see.
11:08:24 <int-e> but you'll have trouble implementing that.
11:08:34 <syntaxfree> why?
11:09:00 <int-e> because you can't convert arbritrary Num instances to real numbers
11:09:11 <int-e> *arbitrary
11:09:33 * int-e wonders if there's a good type class for that.
11:09:52 <syntaxfree> so what's the type for a function like "mean"?
11:10:00 <syntaxfree> mean list = (sum list) / (length list)
11:10:25 <syntaxfree> I managed to get rmse working conceding to Floatings all along, but can't seem to type mean.
11:10:40 <RemiTurk> dcoutts, I was building cabal but thought I was building hIDE *sighs*
11:11:30 <dcoutts> ok :-)
11:12:12 <xerox> Yo!
11:12:31 <RemiTurk> so much for having >20 windows open concurrently ;)
11:12:39 <xerox> I did _really_ improve my balance these days, skateing.  I'm thinking about a unycicle now.
11:12:45 <xerox> unicycle, even :-)
11:12:46 <syntaxfree> can I turn an Integer into a Float with some function?
11:12:52 <RemiTurk> fromIntegral
11:12:58 <int-e> syntaxfree: I have something for you, mompl
11:13:02 <RemiTurk> @type fromIntegral
11:13:03 <lambdabot> forall b a. (Num b, Integral a) => a -> b
11:13:21 <lisppaste2> int-e annotated #12100 with "try this :)" at http://paste.lisp.org/display/12100#1
11:14:01 <dcoutts> xerox, do it! unicycles are great
11:14:18 <syntaxfree> I understood the type declaration and t he realToFrac thing. But, just curious, what's with the $ syntax?
11:14:19 <xerox> I don't know 1) how much does it cost 2) where can I get one!
11:14:21 <int-e> there's a nice type class diagram at http://www.haskell.org/onlinereport/basic.html , that helped.
11:14:46 <int-e> syntaxfree: a $ b = a b, but $ has a very low priority
11:14:48 <dcoutts> xerox, see unicycle.com
11:15:01 <syntaxfree> I see.
11:15:09 <int-e> syntaxfree: and $ is right associative
11:15:16 <syntaxfree> (It seems that all I need is Real for now, looking at the diagram)
11:15:30 <int-e> syntaxfree: right, and that code does that.
11:15:48 <syntaxfree> hey, thanks!
11:15:55 <syntaxfree> the diagram is very helpful too :)
11:16:34 <int-e> syntaxfree: I was happy to find it there - I didn't know of it before.
11:20:12 <syntaxfree> (Fractional a, Ord a) =>
11:20:13 <syntaxfree>               (a -> a) -> a -> a -> a -> a
11:20:19 <sethk> I bought a moped recently.  It's really good for my balance; if I let it fall, it's too heavy for me to pick up.
11:20:25 <syntaxfree> what does it mean when the same "a" is declared as two different classes?
11:20:51 <int-e> syntaxfree: it means a has both classes
11:21:00 <int-e> syntaxfree: err, is an instance of both classes
11:21:04 <shapr> xerox: Start with a cheap learning unicycle. I got one for 100 euro that's pretty decent.
11:21:09 <syntaxfree> ah, ok.
11:21:25 <shapr> xerox: You can also ask lots on #unicycling and http://www.unicyclist.com/forums/forumdisplay.php?s=&forumid=3
11:21:27 <syntaxfree> but from the diagram every Real i s an Ord!
11:22:08 <int-e> syntaxfree: yes, but it says Fractional there
11:22:31 <int-e> @type realToFrac
11:22:33 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
11:23:06 <syntaxfree> I restate my case. from the diagram, every Fractional is an Ord!
11:23:17 <syntaxfree> (and incidentally, every Fractional is a Real)
11:23:18 <int-e> syntaxfree: no
11:24:01 <syntaxfree> Fractional = { Float, Double}
11:24:11 <syntaxfree> Real = {Int, Integer, Float, Double}
11:24:26 <int-e> syntaxfree: there could be other instances of Fractional
11:24:35 <int-e> syntaxfree: those don't need to have an ordering.
11:25:05 <int-e> syntaxfree: the diagram just shows the instances that the standard library provides.
11:25:15 <syntaxfree> anyway, GHCI's type guessing returned {Fractional a, Ord a) ==> etc, but I managed to compile with with {Fractional a) => etc.
11:25:44 <int-e> interesting.
11:26:42 <syntaxfree> I don't understand what Ord a is doing there.
11:26:57 <int-e> syntaxfree: could you show us the corresponding code?
11:26:59 <syntaxfree> it seems to be it's just a very general class.
11:28:58 <lisppaste2> syntaxfree pasted "hmm" at http://paste.lisp.org/display/12103
11:29:28 <Blastur> how do you make comments that span over multiple lines in haskell?
11:29:52 <int-e> {- multi line comment -}
11:30:13 <Blastur> cool, thanks
11:32:59 <int-e> syntaxfree: derivative really only needs Fractional; the Ord came from the comparison in secantroot. Note that Floating includes both Fractional and Ord.
11:38:14 <SamB> syntaxfree: Ord *is* just a very general class
11:38:35 <syntaxfree> I'm beginning to understand.
11:38:46 <syntaxfree> I need to make "a" an instance of "Ord" if i want to make comparisons.
11:38:48 <syntaxfree> How cumbersom!
11:40:15 <int-e> It may seem cumbersome but it also offers quite a bit of flexibility. For example you can make complex numbers an instance of Fractional, although they can't be compared.
11:40:35 <syntaxfree> I'm tempted to create a class called "Useful" that derives what I need.
11:40:44 <syntaxfree> deriving Show, Eq, Ord, etc. etc.
11:41:34 <syntaxfree> *Main> (* 2) $ secantroot (\x->sin(x)-1) 3 0.00001 10e-20
11:41:34 <syntaxfree> 3.141592669610089
11:41:43 <syntaxfree> mathematical question: what function would you use to estimate pi?
11:41:53 <syntaxfree> secantroot finds x such that f(x) = 0.
11:42:13 <syntaxfree> sin(x)-1 doesn't seem very efficient.
11:42:56 <int-e> I wouldn't. For just a few digits I'd use atan, for some more a spigot algorithm and then I'd look at some of the formulas with quadratic convergence that (if I remember correctly) built on elliptic integrals.
11:43:10 <int-e> *build
11:43:39 <syntaxfree> I'm trying to use my fancy secant root function. I could always use series involving factorials and all.
11:44:37 <SamB> hmm, estimate pi?
11:44:50 <int-e> cool: http://paul.rutgers.edu/~rhoads/Code/Pi.iter.txt
11:45:56 <syntaxfree> This is accurate to 166 decimal places after three loops, and 848 after four.
11:45:56 <syntaxfree> Only 13 iterations yields over a billion digits. WOW.
11:46:04 <SamB> atan2 1 0 * 2.0?
11:46:40 * SamB offers useless suggestions
11:46:47 <SamB> pi?
11:46:51 * int-e glares ar SamB 
11:47:22 <syntaxfree> is it in better style to declare function types at the beginning, or together with the equations that define them?
11:47:24 * SamB grins
11:47:26 <int-e> echo 'scale=200; 4*a(1)' | bc -l
11:48:35 <SamB> syntaxfree: I would probably either put them right with the definitions, or right above small groups of definitions
11:50:13 <syntaxfree> can I use hyphens in function names  la Lisp?
11:50:42 <SamB> no
11:50:59 <SamB> we use bumpyNamesLikeThis
11:51:24 <syntaxfree> ISee.
11:51:27 <SamB> ocassionally we use words_with_underscores_between_them
11:51:29 <syntaxfree> What_about_underscores?
11:52:03 <syntaxfree> if two functions have the exact same type, can I declare them together?
11:52:09 <syntaxfree> a, b: [a]->a
11:52:11 <SamB> yes
11:52:22 <syntaxfree> er, func1,func2 :: [a]->a ?
11:52:38 <SamB> yes, you can!
11:59:24 <SamB> however, what do you need to write more functions of that type for?
11:59:30 <lisppaste2> syntaxfree pasted "what can possibly be wrong with secondDerivative?" at http://paste.lisp.org/display/12104
11:59:50 <syntaxfree> that's not the actual type. look at the lisppaste :~
12:01:25 <SamB> it looks like a rather straightforward type error to me..
12:02:06 <SamB> or not
12:02:19 <int-e> derivative f x0 is missing a h
12:02:20 <SamB> I suspect the minus sing
12:02:25 <SamB> s/sing/sign/
12:02:34 <SamB> they always trip me up
12:02:38 <CosmicRay> does anyone have some insight on the haddock problem documented here?  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=330924
12:02:57 <syntaxfree> true.
12:03:15 <syntaxfree> yay!
12:03:20 <syntaxfree> int-e is teh rool :-D
12:03:37 <int-e> I'm not sure what the error is trying to tell us though.
12:04:16 <syntaxfree> int-e: nevermind. you were right.
12:04:22 <syntaxfree> I wanna grow up to be like you.
12:04:38 <dcoutts> CosmicRay, haddock's error messages arn't much good, the actual error can be much further up the file than the location it reports
12:04:41 <syntaxfree> (sadly, I'm too old to grow up much more :( )
12:04:42 <kosmikus> where did the #haskell rl meeting end up to be?
12:04:53 <CosmicRay> dcoutts: I can't figure out what it is.  Everything in there was valid to haddock 0.6
12:04:59 <dcoutts> CosmicRay, it's usually an escaping problem
12:05:17 <dcoutts> CosmicRay, oh so only haddock-0.7 comlains?
12:05:24 <CosmicRay> right
12:05:32 <CosmicRay> this is on code that built perfectly before.
12:05:40 <dcoutts> dunno, I dindn't know it had got stricter
12:05:44 <CosmicRay> now haddock chokes on just about every file.
12:05:48 <syntaxfree> *Main> (*2) $ hillClimber (\x->sin(x)) 1 0.1 10e-20
12:05:49 <syntaxfree> 3.141592653589793
12:05:55 <syntaxfree> now, there's a better pi.
12:05:59 <int-e> I guess what's it doing is: the derivative f x0 is of type a->a. the right side has to have the same type. therefore the f parameter there has to be of type (a->a)->a->a.
12:06:08 <CosmicRay> pfft, the last digit is rounded.
12:06:12 <dcoutts> CosmicRay, really? it worked without changes on Gtk2Hs which has masses of haddock markup
12:06:18 <CosmicRay> huh.
12:06:21 <CosmicRay> that is realyl weird.
12:06:26 <CosmicRay> perhaps it has to do with module headers.
12:06:29 <SamB> @plugs pi
12:06:32 <lambdabot> 3.141592653589793
12:06:51 * SamB just isn't seeing the difference
12:06:52 <dcoutts> CosmicRay, yes they can often mess up haddock because it interprets stuff as haddock markup
12:06:58 <CosmicRay> dcoutts: http://darcs.complete.org/missingh/MissingH/Str.hs
12:06:59 <syntaxfree> I only memorized it up to 3.141592653
12:07:04 <dcoutts> especially "-- *" things
12:07:09 <CosmicRay> dcoutts: so this is one file it doesn't like.
12:07:19 <SamB> what is better about your pi?
12:07:31 <CosmicRay> dcoutts: I thought that maybe my email address on the maintainer address was freaking it out, but I added a backslash and it only led it to a different error.
12:07:32 <syntaxfree> SamB my previous pi sucked.
12:07:46 <CosmicRay> dcoutts: I cannot figure out what in the world could be making it complain now.
12:07:50 <syntaxfree> *Main> (* 2) $ secantroot (\x->sin(x)-1) 3 0.001 10e-20
12:07:51 <syntaxfree> 3.141592669517771
12:08:00 <CosmicRay> that is inaccurate
12:08:05 <syntaxfree> the hill-climber finds a much better approximation with the same cost.
12:08:10 <dcoutts> CosmicRay, yes I get an error, let me try and figure it out...
12:08:16 <CosmicRay> dcoutts: thanks much
12:08:31 * SamB fails to see how there is any better way to find pi :: Double than saying pi
12:08:45 <dcoutts> CosmicRay, got it :-)
12:08:57 <dcoutts> -   Maintainer : jgoerzen@complete.org
12:09:02 <dcoutts> +   Maintainer : jgoerzen\@complete.org
12:09:10 <dcoutts> :-)
12:09:16 <syntaxfree> *Main> (\x-> x-pi) $ (* 2) $ secantroot (\x->sin(x)-1) 3 0.001 10e-20
12:09:16 <syntaxfree> 1.5927978047614033e-8
12:09:17 <CosmicRay> now that is weird.
12:09:21 <CosmicRay> because I tried that ;-)
12:09:27 <dcoutts> it works for me
12:09:32 * CosmicRay checks again
12:09:48 <syntaxfree> *Main> (\x-> x-pi) $ (*2) $ hillClimber (\x->sin(x)) 1 0.1 10e-20
12:09:48 <syntaxfree> 0.0
12:09:50 <syntaxfree> YAY.
12:10:02 * syntaxfree bounces happily to the techno music.
12:10:46 <CosmicRay> eww, techno ;-)
12:11:12 <syntaxfree> I was actually listening to Anglagard. I save techno music to study for big exams.
12:12:10 <syntaxfree> I still wonder how people manage to get anything done without higher-order functions.
12:12:38 <CosmicRay> I still wonder how people manage to get anything done with Java.
12:12:49 <araujo> haha
12:12:57 <araujo> CosmicRay++
12:13:08 <syntaxfree> ah, that reminds me.
12:13:09 <syntaxfree> @karma++ int-e
12:13:10 <CosmicRay> ;-)
12:13:10 <lambdabot> int-e's karma raised to 1.
12:13:17 <syntaxfree> @karma++ int-e
12:13:18 <lambdabot> int-e's karma raised to 2.
12:13:35 <CosmicRay> dcoutts: dammit, you're right!
12:13:53 <xerox> @pl \x -> x - pi
12:13:55 <lambdabot> subtract pi
12:13:57 <xerox> subtract pi.
12:13:57 <CosmicRay> dcoutts: I apparently edited that file and then got the same error from one of the 2 dozen other files with the same situation
12:13:59 <xerox> ^_^
12:14:11 <CosmicRay> dcoutts: and didn't notice the different filename in the error message.
12:14:17 <Trevion> @seen Igloo
12:14:19 <lambdabot> Igloo is in #haskell. Last spoke 6 hours, 58 minutes and 44 seconds
12:14:19 <lambdabot> ago.
12:14:25 <Trevion> @seen SyntaxNinja
12:14:26 <lambdabot> I saw SyntaxNinja leaving #haskell 3 hours, 50 minutes and 23
12:14:26 <lambdabot> seconds ago.
12:14:44 <PeterK> I get a stack overflow with this: somecalculus x = (x * 0.5) + somecalculus(x * 0.5).  Is there ever a case where Haskell will evaluate a recursive function that doesn't 'terminate'?
12:14:57 <dcoutts> CosmicRay, :-0
12:15:50 <syntaxfree> peterk: well, yes, if the result of the recursive function is a list.
12:15:57 <syntaxfree> for instance, ones = 1 : ones
12:16:01 <CosmicRay> PeterK: yes there is, but in this case, it can't return anything without doing that
12:16:06 <syntaxfree> not a number, though.
12:16:18 <Pistahh> hi
12:16:40 <Pistahh> (beginner question follows) is there any fundamental differences between using "let ... in .." and "... where ..." ?
12:17:01 <syntaxfree> @eval somecalculus x = (x * 0.5) :  somecalculus (x * 0.5)
12:17:02 <lambdabot> 33: parse error on input `='
12:17:09 * syntaxfree is stupid.
12:17:43 <z0d> what should I install to have System.Glib.Types?
12:18:28 <PeterK> @eval somecalculus (x:xs) = (x * 0.5) : somecalculus (x * 0.5)
12:18:30 <lambdabot> 38: parse error on input `='
12:18:38 <int-e> Pistahh: let ... in ... is an expression; where only works on a declaration level.
12:19:21 <syntaxfree> you can't @eval a definition.
12:19:24 <syntaxfree> I'm stupid.
12:19:42 <syntaxfree> but just try it. or try a fib, like
12:19:47 <Pistahh> int-e: wow, thanks
12:19:50 <int-e> @eval let somecalculus (x:xs) = (x * 0.5) : somecalculus (x * 0.5) in take 5 somecalculus
12:19:51 <lambdabot> 70:
12:19:51 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:19:51 <lambdabot>   Expected type: [a]
12:19:51 <lambdabot>   Inferred type: a
12:19:51 <lambdabot>   In the expression: x * 0.5
12:20:05 <int-e> err ups.
12:20:44 <int-e> @eval take 4 $ iterate (0.5*) 0.5
12:20:45 <lambdabot> [0.5,0.25,0.125,6.25e-2]
12:21:14 <syntaxfree> I love "$".
12:21:17 <syntaxfree> very useful.
12:21:38 <z0d> not bad, but I prefer EUR
12:22:08 <PeterK> so, how do I get Haskell actually to sum somecalculus? :)
12:22:20 <syntaxfree> the european monetary situation is unsustainable under the current combination of stagnation and trade deficits.
12:22:28 <syntaxfree> at some point, the euro will devalue.
12:22:57 <int-e> @eval sum $ take 40 $ iterate (0.5*) 0.5
12:22:59 <lambdabot> 0.9999999999990905
12:23:51 <syntaxfree> the post-dotcom world lived a surge of prosperity as Europe and the USA managed to absorb third world production with severe trade deficits, but that imbalance can't work in the long run.
12:24:31 <syntaxfree> we, gentlemen, have been feasting on the impossible free lunch. But now the going is getting tough, and the tough won't be pretty.
12:25:47 <Pistahh> syntaxfree: what is "$" ? (more general question: which document can I find it in? (negative on gentle intro)
12:26:08 <syntaxfree> I just learned about it with int-e.
12:26:28 <syntaxfree> s/with/from
12:26:45 <syntaxfree> 3:09 PM  int-e: syntaxfree: a $ b = a b, but $ has a very low priority
12:26:51 <syntaxfree> 3:09 PM  int-e: syntaxfree: and $ is right associative
12:27:32 <integral> priority?
12:27:43 <int-e> precedence
12:27:48 <integral> ah
12:27:51 <syntaxfree> so, for instance, instead of doing "2* (bigfunction lots of arguments here annoying to edit by hand)", I can do "(*2) $ big function here etc etc"
12:27:52 <int-e> didn't remember that word when I typed that.
12:29:32 <int-e> FWIW, $ (and a lot of other useful stuff) is definined in the standard Prelude.
12:30:46 <syntaxfree> in any case, if anyone here is holding a position in EUR, I suggest divesting while in profit.
12:32:32 <z0d> xerox: ping
12:32:45 <Pistahh> @eval let fact x = if x == 0 then 1 else x*fact(x-1) in fact 1000
12:32:47 <lambdabot> 4023872600770937735437024339230039857193748642107146325437999104299385
12:32:47 <lambdabot> 1239862902059204420848696940480047998861019719605863166687299480855890
12:32:47 <lambdabot> 1323829669944590997424504087073759918823627727188732519779505950995276
12:32:47 <lambdabot> 1208749754624970436014182780946464962910563938874378864873371191810458
12:32:47 <lambdabot> 2578364784997701247663288983595573543251318532395846307555740911426241
12:32:48 <lambdabot> 7474349347553428646576611667797396668820291207379143853719588249808126
12:32:50 <lambdabot> 8678383745597317461360853795345242215865932019280908782973084313928444
12:32:52 <lambdabot> [23 @more lines]
12:33:00 <Pistahh> (sorry :)
12:33:03 <ape> @more lines
12:33:04 <lambdabot> 0328123155861103697680135730421616874760967587134831202547858932076716
12:33:04 <lambdabot> 9132448426236131412508780208000261683151027341827977704784635868170164
12:33:04 <lambdabot> 3650241536913982812648102130927612448963599287051149649754199093422215
12:33:04 <lambdabot> 6683257208082133318611681155361583654698404670897560290095053761647584
12:33:04 <lambdabot> 7728421889679646244945160765353408198901385442487984959953319101723355
12:33:06 <lambdabot> 5566021394503997362807501378376153071277619268490343526252000158885351
12:33:08 <lambdabot> 4733161170210396817592151090778801939317811419454525722386554146106289
12:33:10 <lambdabot> [16 @more lines]
12:34:03 <nnunley> @more lines
12:34:04 <lambdabot> 2187960223838971476088506276862967146674697562911234082439208160153780
12:34:04 <lambdabot> 8898939645182632436716167621791689097799119037540312746222899880051954
12:34:04 <lambdabot> 4441428201218736174599264295658174662830295557029902432415318161721046
12:34:04 <lambdabot> 5832036786906117260158783520751516284225540265170483304226143974286933
12:34:04 <lambdabot> 0616908979684825901254583271682264580665267699586526822728070757813918
12:34:06 <lambdabot> 5817888965220816434834482599326604336766017699961283186078838615027946
12:34:08 <lambdabot> 5955131156552036093988180612138558600301435694527224206344631797460594
12:34:10 <lambdabot> [9 @more lines]
12:34:15 <nnunley> Ieee.
12:40:41 <acke-> i have an list of [a] and would like to add 'a' at the end of the list.. how do i do that?
12:41:17 <TFK> @index trace
12:41:18 <lambdabot> Debug.Trace
12:41:59 <mauke> @hoogle [a] -> a -> [a]
12:42:01 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
12:42:01 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
12:42:01 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
12:42:56 <Pistahh> @hoogle [a] -> [a] -> a
12:42:57 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
12:42:57 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
12:42:57 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
12:43:40 <mauke> acke-: list ++ ['a']?
12:47:54 <xerox> z0d: pong!
12:48:03 <xerox> Yay, check this out.  It's weird.  http://www.unicycling.org/unicycling/skills/skills.html
12:49:27 <z0d> xerox: what do I need to run nymphaea?
12:50:00 <Blastur> @eval last [1..]
12:50:04 <lambdabot> Terminated
12:50:23 * SamB wishes objdump didn't assume that (a) all lines in a sourcefile are used, (b) they are in order, and (c) that they are uninterleaved
12:50:29 <Pistahh> @eval "Terminated"
12:50:30 <lambdabot> "Terminated"
12:52:34 <acke-> mauke 'a' is an object so i cant just add the list
12:52:53 <syntaxfree> @eval let bot = bot
12:52:55 <lambdabot> 31: parse error on input `)'
12:53:20 <SamB> lets just say that objdump doesn't play well with CWEB, especially not with changefiles...
12:53:23 <syntaxfree> @eval let bot = bot in bot
12:53:24 <lambdabot> <Plugins.Eval>:1:12:
12:53:24 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:53:24 <lambdabot>   `Show a' arising from use of `show'
12:53:44 <mauke> huh?
12:54:02 <syntaxfree> @eval let bot = bot in 2+2
12:54:04 <lambdabot> 4
12:54:15 <syntaxfree> @eval let bot = bot in 2+bot
12:54:17 <lambdabot> Loop
12:54:28 <xerox> z0d: just gtk2hs (from darcs or the tech preview)
12:55:02 <Pistahh> @eval sum [1..]
12:55:07 <lambdabot> Terminated
12:55:25 <Pistahh> @eval sum [1..999999999999999999999999999999999999]
12:55:26 <PeterK> aha. I've got an infinite list now. thanks for the help. halfsequence a n = a' : (halfsequence a' h) where h = 0.5 * n; a' = a + h
12:55:29 * syntaxfree stops monkeying around wih @eval
12:55:30 <lambdabot> Terminated
12:56:53 <TFK> Guys, any comments (better implementations) of the following: http://hbin.dyndns.org/pastebin/79.html ?
12:57:11 <rep> we belong together
12:59:28 <TFK> OK, that seems to  be a wrong implementation of what I had in mind... erm...
12:59:35 <int-e> @type span
12:59:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:00:01 <Pistahh> TFK: what do you want to implement?
13:00:02 <int-e> @eval span (/=42) [666,23,42,4711]
13:00:04 <lambdabot> ([666,23],[42,4711])
13:00:58 * syntaxfree still can't read other people's Haskell.
13:01:06 <int-e> ah!.
13:01:16 <syntaxfree> the function composition confuses the heck outta me.
13:01:42 <TFK> you have a ring of, say, [1..100]. You begin from 1, knocking out, say, every 7-th number. What number will you end up with?
13:02:22 <TFK> No wait, that implementation isn't erroneous.
13:02:54 <Pistahh> TFK: so basically the question is whether you knock out the last element or not?
13:04:15 <TFK> The question is, what is the last number to stay standing.
13:04:34 <Pistahh> TFK: but it is either 100 or 99 if 100 is knocked.
13:05:01 <TFK> is your ring is [99..100] and 100 is knocked out, than 99 is the last one standing and is the answer.
13:05:04 <z0d> xerox: thanks
13:05:48 <TFK> *if your ring...
13:06:03 <int-e> lisppaste2: help
13:06:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:07:01 <syntaxfree> they should write haskell syntax coloring for the lisppaste bot.
13:07:04 <TFK> If ++ is O(n), as I suspect it is, than this implementation is by an order of magnitude slower than the equivalent in Icon (or Python, with deque). So I was wondering...
13:07:30 <TFK> They can just plug-in hscolour ;-)
13:07:49 <PeterK> why couldn't ++ be O(1)? with a linked list?
13:07:59 <lisppaste2> int-e pasted "another cleo implementation" at http://paste.lisp.org/display/12105
13:08:19 <TFK> It could be, but IIRC in Haskell (GHC) it isn't. (Is it?)
13:08:21 <malcolm> Someone wrote a haskell pastebot a few months back, which incorporated hscolour
13:08:37 <mauke> PeterK: how do you copy a linked list in O(1)?
13:08:44 * TFK reads
13:08:58 <int-e> malcolm: hmm. I like lisppaste's annotate feature.
13:09:07 <PeterK> no copy, mauke.... that's a problem, unless the compiler knows it isn't
13:09:13 <TFK> malcolm, wouldn't that be me and my CGI script? ;-)
13:09:29 <malcolm> TFK: I thought it might have been you
13:09:34 <syntaxfree> I  like the mouseover parens matchingi n lisppaste.
13:11:26 <xerox> z0d: you're welcome.  Feel free to ask any question, if needed.  Also, feedback is really appreciated! :-)
13:13:26 <TFK> modulo was used in one of the C++ solutions as well :-P
13:14:07 <syntaxfree> grr.
13:14:15 <TFK> It's nicer (doesn't require Eq a), but still uses ++.
13:14:15 <syntaxfree> I hate how PHP will break code from version to version.
13:14:27 <syntaxfree> I moved hosting providers and now PHP code is broken.
13:15:15 <TFK> Are you sure that it is due to version mismatch?
13:15:47 <syntaxfree> well,  it worked before.
13:15:50 <syntaxfree> it's unchanged.
13:15:58 <syntaxfree> one file self-contained code.
13:16:00 <z0d> maybe it's the php.ini
13:16:07 <syntaxfree> the syntax of sort()   changed.
13:16:13 <z0d> oh
13:16:21 <int-e> TFK: you can't avoid all O(len) operations anyway, can you?
13:16:48 <int-e> TFK: hmm. I guess with a binary tree you can.
13:17:26 <TFK> Well, you have to traverse the list somehow until you hit the spot. But rebuilding the list over and over again makes it inefficient by an order of magnitude, I think.
13:23:01 <xerox> Goodnight.
13:39:52 <lisppaste2> int-e annotated #12105 with "cleo with a binary tree data structure" at http://paste.lisp.org/display/12105#1
13:41:20 <TFK> Oh my...
13:42:27 <int-e> *Main> cleo 15 $ take 10000 [1..] --> 778 (0.57 secs, 16927704 bytes)
13:43:46 <TFK> hehe. Over here, the naive implementations exhibit the following: ERROR - Garbage collection fails to reclaim sufficient space
13:43:49 <int-e> TFK: note that it doesn't have any O(len) operations in it anymore, so the total running time is O(len log(len)).
13:45:56 <int-e> I like it.
13:46:21 <TFK> That monstrousity? (No offense, but hey...)
13:47:26 <int-e> heh, it's actually quite straight-forward. I only made a few mistakes that the type checker caught and one that it didn't.
13:47:49 <int-e> (but hey, that's why we test our programs, right?)
13:50:33 <TFK> But, this is one is as long as an O(n) solution in, say, C++ and less efficient. (I'm taking your word for it, since I'm still reading it.)
13:51:19 <TFK> (Strictly speaking, the one I was trying to imitate was O(n^2), I think, but it is cute and very short, so... ;-)
13:52:47 <int-e> TFK how do you achieve O(n) ... err, what's n?
13:53:07 <TFK> len
13:54:11 <TFK> Oh wait, it isn't O(n). Bah, sorry.
13:55:18 <int-e> it's O(n) for fixed 'nth', right?
13:55:26 <autrijus> Heffalump: just for the record, bugs.darcs.net is running this extremely ancient version of RT; modern RT is nothing like that.
13:55:56 <TFK> fixed 'nth'?
13:57:38 <int-e> well, you eliminate every nth person from a circle.
13:58:17 <int-e> hmm. there should be a better name for that. hehe.
13:58:29 <TFK> "cancel"?
13:59:53 * int-e renames 'nth' to 'k'. So you eliminate every k-th person from a circle that originally contains n persons. If you fix k, you can solve that in O(n) time, obviously.
14:00:16 <TFK> "fix k"?
14:00:30 <int-e> "make k constant"
14:00:46 <TFK> k is constant, the number of people isn't, though.
14:03:42 <TFK> Sorry, I'm very tired now :-( I'll delve into your binary-tree solution tomorrow, then.
14:22:14 <int-e> funny.
14:22:25 <int-e> cleo_small_k 15 [1..10000] --> 778, (0.09 secs, 15236512 bytes)
14:24:45 <lisppaste2> int-e annotated #12105 with "neat cleo for small k (formerly nth)" at http://paste.lisp.org/display/12105#2
14:26:23 <int-e> this one is quite close to the linked list implementation in other programming languages.
14:28:18 <Cale> what problem are you solving?
14:29:27 <int-e> find the survivor of eliminating every k-th person in a circle of n persons (actually a list of persons is given)
14:29:35 <Lor> Whee.
14:29:57 * int-e can optimize his last version a bit more.
14:30:19 <Cale> oh, I've seen that before - it's called the Josephus problem. There's a closed form solution iirc.
14:34:18 <lisppaste2> RemiTurk annotated #12105 with "yet another one - DiffArray" at http://paste.lisp.org/display/12105#3
14:35:12 <RemiTurk> although the 5 to remove every 7th looks, err, funny :)
14:36:38 <syntaxfree> int-e: how are you timing the execution of that?
14:36:46 <musasabi> home, thanks for the fun things @ Tallin :-)
14:36:54 <int-e> syntaxfree: ghci, :set +s
14:38:14 <syntaxfree> wow. thanks :)
14:40:30 <syntaxfree> int-e: what does the number of bytes mean?
14:41:48 <lisppaste2> int-e annotated #12105 with "version for small k, optimized for larg k ;-)" at http://paste.lisp.org/display/12105#4
14:42:18 <int-e> syntaxfree: bytes allocated during the execution. those values vary wildly though
14:42:31 <syntaxfree> I noticed.
14:44:51 <int-e> Cale: I thought the problem was hard for arbritrary k and n and there are some closed formulas for small k.
14:45:27 <Cale> ah, possibly -- there seem to be two nice recursive formulas.
14:46:31 <RemiTurk> funny enough, my DiffArray version is _much_ (~3x) slower than cleo_small_k for 15 & 10000
14:47:50 <syntaxfree> so, can ghc produce .dll's that can be loaded from C?
14:51:31 <int-e> RemiTurk: ghc is good at dealing with list producers and consumers.
14:54:11 <RemiTurk> int-e: even better than I thought indeed :)
14:57:22 <syntaxfree> *Main> exp(1)
14:57:22 <syntaxfree> 2.718281828459045
14:57:22 <syntaxfree> (0.06 secs, 3924140 bytes)
14:57:23 <praseodym> all haskell sites seem to be drupal powered :)
14:57:23 <syntaxfree> what?
14:57:36 <syntaxfree> how can exp(1) be slower than a hill-climbing algorithm?
14:59:07 <int-e> syntaxfree: have you tried more than once? the first time there could be some shared object initialization kicking in...
14:59:19 <dcoutts> Lemmih, hIDE reports a misleading error message when the plugin is missing a plugin_main symbol.
14:59:25 <dcoutts> It says: hIDE: user error (Unknown package: hide-html-viewer-0.1.0)
14:59:34 <dcoutts> which is rather confusing :-)
15:00:14 <dcoutts> it'd be nicer if it said hIDE: user error (Package hide-html-viewer-0.1.0 exports no dynamic_main :: IO function)
15:00:18 <dcoutts> or something
15:00:28 * dcoutts goes to fix his code
15:04:13 <syntaxfree> why doesn't this work? (\x->1/x).(\x->2*x) 2
15:04:29 <dcoutts> @eval ((\x->1/x).(\x->2*x)) 2
15:04:31 <lambdabot> 0.25
15:04:41 <dcoutts> you're missing some brackets
15:04:45 <syntaxfree> ah, yes.
15:04:57 <basti_> juxtaposition binds tightest!
15:05:10 * basti_ has learned something from this chan
15:05:27 <syntaxfree> so, ((**2).logistic) 2 is the same as (logistic 2)**2 ?
15:05:44 <basti_> only if ** is commutative
15:06:05 <syntaxfree> which it isn't.
15:06:13 <basti_> rarely.
15:06:15 <syntaxfree> so what is ((**2).logistic)?
15:06:39 <basti_> what is "logistic"? the standardized logistic function?
15:06:52 <syntaxfree> there's a standardized logistic function? I defined it.
15:07:05 <syntaxfree> logistic                        :: (Floating a)=>a->a
15:07:10 <syntaxfree> logistic x                      = 1/(1+exp(-x))
15:07:21 <basti_> hmmm
15:09:12 <syntaxfree> *Main> ((**2).(+1)) 2
15:09:12 <syntaxfree> 9.0
15:09:12 <ski> @eval let logistic x = 1/(1+exp(-x)) in (((**2).logistic) 2,(logistic 2)**2)
15:09:14 <lambdabot> (0.7758034925743758,0.7758034925743758)
15:09:31 <syntaxfree> that is indeed ((+1) 2)**2, as I thought.
15:09:46 <ski> ((**2).logistic) 2  is the same as  (logistic 2)**2
15:10:18 <syntaxfree> @eval let logistic x = 1/(1+exp(-x)) in (((**2).logistic) 7,(logistic 7)**2)
15:10:20 <lambdabot> (0.9981787276254777,0.9981787276254777)
15:10:22 <basti_> for a special case, it might be, yes
15:10:42 <syntaxfree> @eval let logistic x = 1/(1+exp(-x)) in (((**13).logistic) 41,(logistic 41)**13)
15:10:44 <lambdabot> (1.0,1.0)
15:10:46 <ski> basti_ : it is an instance of  (f.g) x = f (g x)
15:11:09 <syntaxfree> @eval let logistic x = 1/(1+exp(-x)) in (((**1.3).logistic) 4.1,(logistic 4.1)**1.3)
15:11:11 <lambdabot> (0.9788587747745365,0.9788587747745365)
15:11:21 <syntaxfree> frankly, I'm sold :)
15:11:24 <basti_> uhm
15:11:56 <ski> we don't need to assume some commutativity or something.  those two expressions are equal by definition
15:12:00 * basti_ nods
15:12:09 <basti_> i see what you have been meaning
15:12:10 <basti_> my fault
15:12:21 <basti_> i was thinking about the other 2
15:12:43 <basti_> obviously I'm pretty deranged
15:12:49 <basti_> confusing 2's
15:14:05 <syntaxfree> "activationFunction              = logistic" will pass any arguments from activationFunction to logistic, right?
15:14:17 <ski> syntaxfree : yes
15:14:19 <basti_> yes
15:14:34 <ski> (that states that activationFunction is the same as logistic)
15:14:57 <basti_> you might want to put that function as a paremeter some where.
15:15:13 <basti_> functions are fcc's
15:15:16 <syntaxfree> I might want to use a variation of the logistic function at some point.
15:15:28 <basti_> then you put in another parameter .)
15:15:32 <syntaxfree> say, activationFunction = (*2).logistic
15:15:45 <basti_> \plugs (\x y->x y) (10+) 5
15:15:49 <rep> what exactly can templace haskell be used for?
15:15:56 <syntaxfree> metaprogramming,  la Lisp?
15:15:56 <basti_> rep: the same as lisp macros
15:15:57 <lisppaste2> int-e annotated #12105 with "finally, cleo in linear time" at http://paste.lisp.org/display/12105#5
15:16:26 <rep> yes and what's the point of lisp macros?
15:16:41 <syntaxfree> extending the  language.
15:16:50 <ski> syntactic abstraction ?
15:16:55 <basti_> for example.
15:17:08 <rep> what does that mean?
15:17:14 <basti_> and then you could imagine some tendious stuff that you'd want to have calculated at compile time
15:17:25 <ski> that one can create new pieces of syntax
15:17:42 <rep> maybe an example would be more easily understood
15:17:48 <basti_> phew.
15:17:48 <basti_> :P
15:18:52 <basti_> I'm going to bed now I'm sorry... the problem is that you'll need quite a large example for TH to really make sense and not only being l'art pour l'art
15:19:01 <rep> :(
15:19:10 <rep> goof nigth :)
15:19:14 <rep> night
15:19:17 <basti_> first I'll brush my teeth
15:20:07 <basti_> imagine that you have a certain set of optional parts in your program
15:20:20 <int-e> Cale: that recursive formula should've been blindingly obvious. well, at least I found (or remembered? who knows) it now.
15:20:27 <SamB> l'art pour l'art?
15:20:31 <basti_> now you could write TH so that dependencies will be satisfied
15:20:40 <basti_> SamB: "doing it just because we can"
15:20:57 <rep> basti_ hm
15:21:07 <Cale> I can do the problem for n = 100000000, k = 150 in 0.02 secs
15:21:14 <basti_> lets say, you'd need part A for part B, and with part B, some new options show up
15:21:21 <Cale> *Main> burde 100000000 15000
15:21:21 <Cale> 25681813
15:21:21 <Cale> (1.22 secs, 125729240 bytes)
15:21:21 <SamB> basti_: and not because it makes things any easier?
15:21:48 <basti_> SamB: TH surely does, but i find it hard to come up with a really small example
15:21:55 <basti_> that'd make sense
15:22:09 <rep> basti_ oh
15:22:20 <basti_> rep: TH can do this at compile time
15:23:01 <basti_> basically its evaluating haskell functions at compile time
15:23:13 <rep> i see
15:23:15 <basti_> if you ever wanted to know how long an input line ghc can process....
15:23:25 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:24:21 <Cale> burde is ridiculously faster than tait for large values
15:24:35 <rep> so not a lot of people use TH
15:24:39 <rep> or am i wrong?
15:24:59 <basti_> rep: or, lets say, for some reason you want to process an external file to make a program from it
15:25:09 <basti_> or a part of your program
15:25:12 <basti_> no not at all
15:25:15 <basti_> its a fringe thing
15:25:23 <basti_> but its important that it's there
15:25:29 <rep> right
15:25:35 <Cale> int-e: check out the paste page, if you didn't notice I pasted there :)
15:27:27 <basti_> well goodnight
15:27:36 <int-e> Cale: will do in the moment, I'm trying to figure that out on my own right now.
15:30:24 <Cale> (note that burde and tait don't return the same values, but they do return values which are congruent mod n)
15:34:03 <ape> what do you guys think about writing a NES emulator in haskell?
15:34:17 <dcoutts> Lemmih, dons: I've partially implmented an html viewer for documentation, it's about 50 lines of code :-)
15:34:28 <dcoutts> it works, mostly
15:34:42 <dcoutts> it needs to be cleaned up before it can be comitted however
15:35:32 <dcoutts> or rather it needs the ide shell to be cleaned up to properly export interfaces for registering new page viewer
15:35:34 <Blastur> ape, haskell is terrible slow :( probably too slow for a nes emulator
15:35:43 <Cale> I don't know about that
15:35:51 <Cale> it's probably fast enough
15:36:36 <Cale> NES emulation shouldn't require all that much speed these days.
15:36:59 <Cale> but there are already pretty decent NES emulators out there
15:37:07 <ape> yeah but none in haskell :D
15:37:17 <Cale> :)
15:37:22 <Cale> *Main> burde 1000000000000000 150000
15:37:23 <Cale> 734752861110202
15:37:23 <Cale> (30.34 secs, -673109676 bytes)
15:37:31 <ape> i'm still trying to figure out which will be easier to do though, nes or gameboy
15:37:36 <Cale> I love the negative byte counts :)
15:37:49 <int-e> hrm, getting stack overflows.
15:38:08 <Cale> load ghci with +RTS -K10000000 -RTS
15:38:29 <Cale> or however much memory you want for the stack
15:42:46 <RemiTurk> arghh
15:42:50 <Cale> I could probably rewrite that without the list...
15:43:03 <RemiTurk> does anyone have experience with autoconf-hell (gtk2hs from darcs)
15:43:28 <Cale> RemiTurk: make sure all your autoconf stuff is completely up to date
15:43:52 <Cale> I had problems until I switched to using newer versions of the autoconf tools
15:44:41 <RemiTurk> hm, my 2.59 appears to be the newest autoconf..
15:44:55 <RemiTurk> though my automake isn't the very latest and greatest
15:48:01 <RemiTurk> upgraded and it still dies with error: possibly undefined macro: AC_MSG_ERROR :(
15:52:09 <Cale> updated so as to just recurse without the extraneous list
15:52:43 <Cale> RemiTurk: hmm..
15:53:44 * RemiTurk just upgraded libtool to a version which appeared only today... *feels very uptodate now*
15:54:15 <Cale> heh
15:54:30 <Cale> yeah, I was using really old versions of the tools, so it's probably not that
15:54:35 <int-e> Cale: nice. I got the basic idea correct, but my implementation was bad. You should add a fallback to tait for n<k though.
15:54:54 <Cale> yeah
15:55:07 <Cale> I was assuming that k < n
15:55:30 <Cale> or just mod out
15:55:52 <RemiTurk> Cale: hm, running autoreconfig multiple times "solves" that error and causes others to appear. I guess I'll just leave it for today. but thx anyway :)
15:56:04 <Cale> huh
15:56:11 <Cale> odd
15:56:19 <Cale> maybe ask Duncan
16:02:23 <RemiTurk> happy happy joy joy
16:02:53 <RemiTurk> simply removing all incorrectly-unexpanded macros from ./configure (do-we-have-this-or-that-library?) helped ;)
16:03:17 <int-e> Cale: why are you passing f' through the function call? f is unused ... (which solves my last mystery about that code - the meaning of f)
16:04:05 <Cale> ah, yeah, I suppose I could avoid that
16:04:41 <int-e> Cale: and get rid of the tuple now that they are no longer stored in a list :)
16:04:53 <Cale> yeah
16:50:37 <sylvan> any particular reason why Data.Map doesnt' have an instance in Read?
16:57:28 <RemiTurk> sylvan, not that I know of
17:47:19 <araujo> hey, update the haskell.org News with the ICFP results :-)
17:54:45 <int-e> Cale: check the paste page again :)
18:05:41 * CosmicRay invites feedback on http://darcs.complete.org/missingh/MissingH/Email/Mailbox.hs
18:26:48 <metaperl> autrijus: your statement in that interview about Haskell being as fast as C++ has been bothering me ever since I read it 2 weeks ago... can you back that statement up?
18:30:05 <ape> what interview?
18:31:13 <CosmicRay> ape: http://changelog.complete.org/node/389
18:31:16 <metaperl> ape: http://www.perl.com/pub/a/2005/09/08/autrijus-tang.html?page=2
18:31:21 <CosmicRay> ape: http://www.perl.com/pub/a/2005/09/08/autrijus-tang.html?page=2
18:31:29 <metaperl> :)
18:31:38 <CosmicRay> heh
18:31:46 <metaperl> hi CosmicRay, I been looking at Dylan pretty hard lately
18:31:55 <CosmicRay> I've never looked at it much
18:32:00 <metaperl> oh? why is that?
18:32:09 <CosmicRay> dunoo
18:32:10 <CosmicRay> got a url?
18:32:17 <CosmicRay> it is apparently difficult to google for
18:32:27 <metaperl> well... gwydiondylan.org
18:32:31 <CosmicRay> all this bob dylan crap
18:32:31 <metaperl> plus #dylan
18:32:36 <cjs> What a time to arrive.
18:32:41 <metaperl> lol
18:32:41 <araujo> opendylan.org too, if you got problems remenbering the name
18:32:42 <araujo> :-)
18:32:59 <CosmicRay> from the description, it sounds like python.
18:33:12 * araujo has noticed an increase of traffic on #dylan since the ICFP
18:33:30 <CosmicRay> metaperl: ok, now I know why I haven't messed with it much.  oop doesn't interest me anymore.
18:33:50 <metaperl> I see...
18:35:28 <CosmicRay> metaperl: is there anything cool that's unique to dylan?
18:35:35 <CosmicRay> cuz honestly, I'm not seeing anything. ;-)
18:35:58 <metaperl> CosmicRay: their ICFP results for one thing
18:36:12 <CosmicRay> well, haskell took first *and* third ;-)
18:36:19 <metaperl> and 7th
18:36:35 <CosmicRay> while it's exciting to have those results, I would say that more depends on the skills of the participants than on the language they use
18:36:45 <metaperl> but Haskell's results dont bear relevance on your question about Dylan
18:37:00 <CosmicRay> since it spans such a large amount of time, if you get a large team with people with time on their hands, you could do well even in C ;-)
18:37:13 <CosmicRay> but what about the language itself?
18:37:15 <Kirby> I thought you get 24 hours for revision.
18:37:52 <CosmicRay> good point
18:37:57 <CosmicRay> the initial round was measured in weeks though, right?
18:38:06 <Kirby> Yes.
18:39:09 <CosmicRay> metaperl: I've actually considered giving Erlang another look.  it seems that it has some nifty binary stream parsing support.
18:39:21 <araujo> CosmicRay, you got multiple dispatch, it is statically typed, i also think that is the most dinamically OOPL , they say that only Smalltalk is more dynamic than it.
18:39:29 <metaperl> the interesting thing about the Dylan language is that it too is centered around functions... although the language appears to be another oo language, function application in Dylan can match up functions with data types
18:39:54 <metaperl> the static typing is optional araujo
18:40:08 <araujo> Right,
18:40:17 <CosmicRay> araujo: now that is starting to sound like ruby a bit ;-)
18:40:26 <araujo> You can use both dynamic or static typing.
18:40:33 <CosmicRay> freaky.
18:40:39 <CosmicRay> nifty too.
18:40:40 <CosmicRay> maybe.
18:40:41 <CosmicRay> ;-)
18:40:43 <araujo> hah yeah
18:40:49 <araujo> It's a good language really.
18:40:55 <metaperl> one of the members of the winning ICFP team mocked up everything in Ruby until he could hook up with the rest of the team
18:41:12 <araujo> Ive not used it at all reall,y just read about it, but it looks interesting.
18:41:48 <CosmicRay> I dunno.  after using c++, python, java, perl, and ocaml...  i don't really get excited about oop languages anymore.
18:41:58 <CosmicRay> they all seem pretty much like one of the above ;-)
18:42:04 <araujo> If i neede to do some OOP , i probably would go with Dylan.
18:42:16 <CosmicRay> ocaml is rather in a different category though, since its heart is not really in oop
18:42:30 <araujo> CosmicRay, Dylan is really different than those OOPL.
18:43:45 <araujo> It only has some equivalents to macros on Lisp.
18:44:35 <metaperl> CosmicRay: you missed my point about Generic Functions being the heart of Dylan
18:44:51 <metaperl> and method dispatch flexibly on the types of the arguments of the function
18:45:38 <CosmicRay> metaperl: yes, it seems I didn't quite get what you meant the firs time around.  Are you saying that it has some equivolent to a [a] -> [a] sort of function in haskell?  (what we could call a function with polymorphic args?)
18:46:00 <CosmicRay> metaperl: well, java and c++ do that
18:46:04 <CosmicRay> (the dispatch)
18:46:09 <CosmicRay> and python can as well, though it's manual.
18:46:13 <ski> CosmicRay : more related to type classes, then, i think
18:46:40 <ski> it's not parametric polymorphism
18:47:09 <CosmicRay> but aren't type classes superfluous in an oop language?
18:47:23 <CosmicRay> I've sort of thought of type classes as providing the same features as oop, just in a different way
18:47:37 <metaperl> CosmicRay: please read this: http://www.cs.dartmouth.edu/~brd/cs212/handouts/comparison.htm
18:47:39 <ski> java has interfaces which is sortof like type classes with one argument
18:49:10 * CosmicRay reads
18:49:30 * metaperl goes to buy bus pass
18:50:48 <ski> CosmicRay : http://www.haskell.org/hawiki/UnderestimatedTypeClasses
18:52:38 * CosmicRay finishes reading.
18:52:43 <CosmicRay> so what I got out of that article was:
18:52:49 <CosmicRay> 1) C++ sucks (we all know that already)
18:52:55 <CosmicRay> 2) Dylan is better than C++ (no surprise there)
18:53:26 <CosmicRay> 3) I did see the likeness to the Haskell typeclass system.  Nice.  But the examples didn't illustrate anything Python can't do.
18:53:37 <CosmicRay> 4) Dylan can be compiled to native code and is probably faster than Python.
18:53:45 <CosmicRay> 5) Dylan can also use a VM, like Python does.
18:54:21 <CosmicRay> I would also say that dylan would compare favorably to Java.
18:54:32 <CosmicRay> but then, that's not hard to do either ;-)
18:54:37 <araujo> haha
18:54:48 <araujo> @karma CosmicRay++
18:54:49 <lambdabot> CosmicRay++ has a karma of 0
18:55:12 <ski> araujo : @karma+
18:55:43 <araujo> @karma+ CosmicRay
18:55:44 <lambdabot> CosmicRay's karma raised to 1.
18:55:49 <araujo> Thanks ski
18:55:50 <araujo> :-]
18:55:59 <CosmicRay> thanks arajuo ;-)
18:56:06 <CosmicRay> araujo, even.
18:56:12 <araujo> :-]
18:56:52 <araujo> Ive not touched _that_ many OOPL really.
18:57:06 <araujo> The only OOPL i used to work with was Smalltalk.
18:57:09 <CosmicRay> you know, I think Haskell is the first language that I really think is a good language.
18:57:20 <araujo> Though for educational purposes only.
18:57:30 <CosmicRay> most languages I've come to because they "suck less" than other languages.
18:57:40 <araujo> But i think that if i go with OOP, i'd give a try to Dylan.
18:57:57 <araujo> Haskell is sweet.
18:58:02 <CosmicRay> I probably would too, if I didn't already know python.
18:58:21 <CosmicRay> dylan doesn't seem to bring enough to the table to convince me to use it instead of python.
18:58:43 <CosmicRay> I tend to build up substantial codebases in the languages I use, so it's a pretty high bar to get me to switch
18:59:03 <araujo> CosmicRay, i wanted to give a try to python time ago, one yer ago approximately... but i dodn't know, i didn't find my way around.
18:59:55 <araujo> I use to feel aversion for perlish languages
19:00:16 <CosmicRay> python is not very perlish
19:00:36 <CosmicRay> araujo: I came from python to haskell.
19:00:50 * araujo came from Scheme
19:01:03 <CosmicRay> araujo: you will find some interesting similarities.  list comprehensions and the indenting syntax are python features that appeared first in haskell.
19:01:20 <araujo> I see.
19:01:36 <CosmicRay> araujo: python also has the beginnings of a functional language infrastructure.
19:01:37 <araujo> Indeed. The indenting syntax is similar.
19:01:48 <CosmicRay> araujo: however the python community wants to get rid of it.
19:01:56 <CosmicRay> araujo: in my mind, Haskell is the language that python should have been.
19:02:07 <araujo> CosmicRay, Like the one statement lambda function?
19:02:13 <CosmicRay> right
19:02:30 <araujo> I tell you, i saw that as a joke :-P
19:02:36 <CosmicRay> they also have generators, which are somewhat a way of simulating a lazily-generated list in haskell
19:02:37 <CosmicRay> hehe
19:02:50 <Cale> I like Haskell's way of handling the indentation rule better than python's (the optionality is good)
19:03:17 <CosmicRay> araujo: there are quite a lot of people that have come to haskell from python recently, it seems.
19:03:36 <araujo> Nice.
19:03:53 <araujo> CosmicRay, So, i suppose you guys find very much similarities at first?
19:04:09 <CosmicRay> well, not so much.
19:04:18 <CosmicRay> but there are a few things that are, well, "comforting."
19:04:23 <CosmicRay> one is the haskell type sytem.
19:04:32 <CosmicRay> very cool how type inference lets it stay out of your way.
19:04:34 <araujo> Kind of similar in python?
19:04:43 <CosmicRay> pythoners are used to not giving explicit typing information.
19:04:44 <CosmicRay> yes
19:04:45 <araujo> yeah, it is sweet.
19:05:07 <CosmicRay> of course, python programmers that have used python's functional features will be in heaven with haskell
19:05:12 <CosmicRay> because it is so much easier and better in haskell
19:05:18 <araujo> :-)
19:05:37 <araujo> You still use python?
19:05:38 <CosmicRay> the haskell syntax also feels, well, modern and friendly.
19:05:40 <Cale> I found the behaviour of lambda somewhat confusing in python
19:05:49 <CosmicRay> I do, but I'm mostly in maintenance mode with my python code at this point.
19:06:14 <araujo> I really never read any lambda or functional example in python (well i really just read about it for a few weeks)
19:06:29 <CosmicRay> as someone that's used ocaml, as well as worked with lisp, the syntax of those languages is rather off-putting.
19:06:38 <araujo> CosmicRay, you should take that code to Haskell :-)
19:06:42 <CosmicRay> araujo: I am
19:06:46 <araujo> Nice.
19:06:57 <CosmicRay> araujo: I am starting to implement Maildir, Mbox and then IMAP libraries in Haskell.
19:07:07 <CosmicRay> araujo: when that is done, I will port OfflineIMAP, my largest Python project
19:07:13 <araujo> Cool.
19:07:21 <CosmicRay> oh, also, Haskell has Parsec.  Coolest parser ever.
19:07:38 <CosmicRay> I *like* writing parsers now.
19:07:41 <CosmicRay> how weird is that? ;-)
19:08:06 <araujo> Ha, i think it is normal in Haskell :-]
19:08:11 <CosmicRay> hehe
19:08:27 <CosmicRay> haskell functions can be passed around as args.
19:08:50 <CosmicRay> lambda exists, but works only with expressions, and (unlike haskell), python is not an "everything is an expression" language.
19:08:55 <CosmicRay> for instance, "print" is not an expression.
19:09:20 <araujo> Ah
19:09:21 <CosmicRay> but I use lambda in offlineimap's configuration system.
19:09:23 <CosmicRay> nametrans = lambda foldername: re.sub('^INBOX\.*', '.', foldername)
19:09:28 <CosmicRay> that's in my ~/.offlineimaprc
19:09:53 <CosmicRay> think of it as (\foldername -> subre("^INBOX\.*", ".", foldername)
19:10:08 <araujo> I see.
19:10:21 <CosmicRay> so when I call that function in python, I pass it a string and get back a string.
19:10:25 <araujo> See, that one thing i like, the Haskell syntax si so clean.
19:10:36 <CosmicRay> araujo: my MissingH library is basically a project to add those things to Haskell that I miss from Python.
19:11:05 <CosmicRay> MissingH.ConfigParser, for instance, is pretty much a direct port of Python's ConfigParser module.
19:11:25 <araujo> How is Python parsing?
19:11:38 <CosmicRay> SocketServer was inspired by Python, as was the HVFS (Haskell Virtual FileSystem)
19:11:43 <CosmicRay> araujo: unremarkable.
19:12:08 <Lemmih> dcoutts: Still awake?
19:12:09 <CosmicRay> araujo: you have your standard choices: regexps, basic string searching functions, and various lex/yacc implementations.
19:12:27 <araujo> I see, didn't know really Python was so closed to Haskell.
19:12:44 <CosmicRay> python has nothing even close to parsec.
19:13:48 <CosmicRay> well, similarities exist, sure, but they are very different languages, fundamentally.  Python is OOP, purely dynamic, imperative, and dynamically-typed.  Haskell is FP, lazy, and statically typed.
19:14:05 <CosmicRay> However -- it is possible to call from Haskell to Python without too much fuss.
19:14:36 <CosmicRay> I do that in my MissingPy library, and use Python's dbm layer to implement instances of a pure-Haskell DBM class.
19:14:59 <araujo> You use bindings?
19:15:07 <CosmicRay> araujo: Python's C API
19:15:13 <araujo> Ah ok.
19:15:40 <CosmicRay> Python uses a reference count garbage collector.  very handy to interface with haskell's GC.
19:15:53 <CosmicRay> I just set the finalizer to be a call to Py_DECREF and we're set.
19:16:25 <araujo> I don't know, i tried python, but i just didn't like those "hidden" variables everywhere
19:16:33 <CosmicRay> I agree.
19:16:37 <CosmicRay> They seem nice at first.
19:16:48 <CosmicRay> but I think that they're a poor excuse for a typeclass.
19:16:57 <CosmicRay> python uses them to do what haskellers would use a typeclass for.
19:17:15 <araujo> I see.
19:17:21 <CosmicRay> so python has no equivolent of Haskell's Num type, but you can declare an __add__ method (or something) for an object to make it work with +
19:17:29 <araujo> Well, definetly, Haskell solution seems far cleaner to me.
19:17:30 <CosmicRay> it sucks and there is very little type checking
19:17:33 <CosmicRay> yup
19:18:02 <int-e> CosmicRay: but at least it's not Perl (or Java)
19:18:08 * int-e giggles.
19:18:08 <araujo> Yeah, that was precisely what got me away from the language.
19:18:09 <CosmicRay> yeah
19:18:18 <CosmicRay> python is far better than perl or java
19:18:33 <CosmicRay> araujo: in fairness, pythoners rarely abuse those features.
19:19:31 <Cale> Autrijus' type system extensions might allow for a cleaner OO approach in Haskell.
19:19:32 <araujo> CosmicRay, That doesn't introduce too much confusion into the code?, probably unnecessarily?
19:19:55 * araujo got that impression
19:20:04 <CosmicRay> araujo: usually they use it to good effect.  for instance, to make something that is really dict-like appear to work like a dict
19:20:08 <CosmicRay> (a dict is pythonspeak for a hash)
19:20:56 <int-e> isn't that perl speak for a Map?
19:21:01 <araujo> I see.. so , it is just the same functionality than the type classes of Haskell as you said...
19:21:22 <Cale> int-e: :)
19:21:23 <araujo> Or they use it in that way.
19:21:44 <CosmicRay> araujo: yup.
19:21:49 <Cale> I was about to make that sort of comment. "finite map" seems like a good generic term
19:22:19 <int-e> Cale: did you see the modification I made on the paste page? I replaced the formulas by what I believe are less obscure ones (and the result is slightly faster, too)
19:22:19 <Cale> or any of the other words used to denote a function in place of "map"
19:22:30 <Cale> int-e: yeah, cool
19:28:55 <ricebowl> does Hugs normally crash often?
19:36:39 <Cale> ricebowl: well, I haven't used it much, but I didn't think so
19:41:31 <ricebowl> hm
19:41:41 <metaperl> CosmicRay: ping?
19:41:43 <ricebowl> seems I forgot the base case on my sort, caused Hugs to exit without printing any messages
19:41:49 <ricebowl> grr, how annoying
19:42:01 <ricebowl> <troll>The SML interpreter never did that</troll>
19:42:19 <int-e> maybe ghci would do better :)
19:43:26 <ricebowl> perhaos
19:43:27 <ricebowl> er perhaps.
19:43:36 <ricebowl> perhaps after I turn in this assignment I'll mess with it
19:43:42 * ricebowl checks the time, "Oh shit"
19:43:46 <ricebowl> ^_^
19:43:57 <ricebowl> only lost an hour trying to figure out why Hugs was crashing <3
20:42:30 <PeterK> How hard would it be to write a sort of parser/compiler that goes from [C | Pascal | Fortran] -> Haskell? What tools are available to help some intrepid programmer wanting to do that?
20:43:56 <rasfar> PeterK, have you looked at parsec?
20:44:18 <PeterK> I have the url and have glanced at it.
20:45:12 <rasfar> Well I think it's the tool of choice for that, although I personally haven't done much with it.
20:45:34 <rasfar> Translating C to Haskell, in full generality, might be kinda tricky?
20:46:52 <PeterK> certainly tricky, I'd say. but in general, a procedural programming language such as Pascal or Fortran or C or Basic or whatever. if it doesn't support everything about the source language at once, that's fine.
20:47:42 <rasfar> I think most of the Haskell compilers compile to C at some stage.  Looking at the source for GHC or JHC might help...
20:48:20 <PeterK> I want to go the other way, from procedural to Haskell. :)
20:49:02 <rasfar> Yeah.
20:49:31 <rasfar> I googled, but not sure what tools are available yet.  You're aware of the FFI I suppose?
20:50:43 <PeterK> the Foreign Function Interface; I have heard about it.
20:51:24 <rasfar> Well I've never used that either -- but if it's just access to existing C code you need, it would be the simpler solution.
20:52:23 <PeterK> I figure that if I could translate language P into Haskell, I would have a better understanding of Haskell. That's the main motivation.
20:53:31 <rasfar> By the looks of it, if you could translate P to Haskell, you'd be a candidate for tenure :)
20:54:39 <ricebowl> PeterK - there is no equivalent to pointers in Haskell
20:54:59 <ricebowl> if you want to go C -> Haskell, you'll have to figure out a solution for handling pointers
20:56:04 <rasfar> I'm not any kind of authority unfortunately, but -- you can simulate pointers at the source code level with monads or something.  However that would be quite perverse in most cases!  At the level of Haskell implementations I'm sure there are pointers all over the place, but not in the source usually.
20:56:24 <rasfar> Anyhow, as chatty as I'm apparently feeling, I must be off......
20:56:27 <Cale> what?
20:56:31 <Cale> of course there are pointers
20:56:36 <Cale> see Foreign
20:56:53 <rasfar> (okay) (I'll catch up later!)
20:56:53 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Ptr.html
20:58:07 * ricebowl shuts his mouth :p
20:58:26 <ricebowl> I thought that was a violation of being free of side-effects
20:58:27 <ricebowl> oh well
21:03:23 <Cale> not if you can't dereference them :)
21:03:26 <Cale> hehe
21:03:58 <ricebowl> you mean if you can't modify them
21:04:02 <Cale> (or if the dereferencing only happened in the IO monad, that'd be okay)
21:04:15 <Cale> you can modify the pointers
21:04:33 <Cale> in the sense that there are pure functions taking pointers to pointers
21:05:00 <ricebowl> yes, but in a pure functional language they can't modify inputs :p
21:05:11 <ricebowl> no side-effects ^_^
21:05:34 <ricebowl> pointers don't (necessarily) entail side-effects as Java programmers familiar with String can attest to
21:16:00 <Cale> well, functions can't
21:16:08 <Cale> but IO actions are allowed to modify things
21:16:13 <ricebowl> yes, I know
21:16:43 <ricebowl> monads seem to me to be bubbles of imperative programming in the middle of a functional program :p
21:17:01 <Cale> only the IO monad is
21:17:29 <Cale> and even then, you're manipulating imperative primitives in a functional way
21:18:25 <ricebowl> mm I don't really know enough about Haskell yet to argue that
21:18:28 <ricebowl> oh well :p
21:18:34 * ricebowl is sleepy
21:18:42 <ricebowl> need to finish this homework and turn it in, bbl
21:18:50 <Cale> I suppose it's sort of like imperative programming with any monad in that you "sequence" your monadic values
21:19:07 <ricebowl> more than that, but I don't know
21:19:12 <Cale> but it depends on the way that you're thinking about it
21:19:21 <Cale> the list monad, for example
21:19:47 <Cale> it's basically just a bunch of \x -> [x] and concatMap, which are really pure
23:36:59 <Baughn> Xgc: Non-commercial Lisp implementations in Windows? Nope, not really.
23:38:49 <basti_> scheme maybe?
23:39:02 <basti_> it's not lisp, but close.
23:39:10 <Baughn> It'd help if he was actually online. Nickcompletion fooled me. :/
23:39:41 <basti_> ah :/
23:50:39 <Igloo> Who was trevion?
23:51:58 <basti_> ?
23:53:48 <Igloo> [20:13] < Trevion> @seen Igloo
23:55:12 <basti_> ah
23:56:10 <basti_> i thought you were talking history or something, and expected an answer like "uhm, a famous roman consul contemporary to marc aurel"
23:56:24 <basti_> I'll be silent now.
23:56:54 <nibro> http://catb.org/~esr/jargon/html/F/foo.html
23:58:39 <Igloo> lol
23:59:52 <nibro> I wanted to see if I had net access, so I typed foo in my google bar :)
