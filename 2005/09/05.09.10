00:04:16 <Torrente> yes, that is the rule
00:04:28 <Torrente> but, no the implementation
00:04:33 <Torrente> not is trivial
00:04:41 <Torrente> i guess
00:53:52 <humasect> i'm thinking about OpenGL 2.0 support with GHC standard
01:08:50 <newsham> $ runhugs Poker.hs
01:08:51 <newsham> runhugs: compileExpr: invalid module
01:09:01 <newsham> if I run "hugs Poker.hs" then "main" at the prompt it works
01:09:11 <newsham> I'm not sure what the error is referring to.. ideas?
01:14:34 <humasect> module name needs to be the same as file name
01:15:06 <newsham> I suspected that.  but that doesn't help me towards a solution :)
01:15:08 <araujo> lisppaste2, help?
01:15:08 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:15:15 <newsham> pretend I'm fairly new to haskell and hugs ;-)
01:15:32 <humasect> sorry, i just entered. i could have checked the logs
01:16:10 <lisppaste2> araujo pasted "directory" at http://paste.lisp.org/display/11535
01:16:21 <araujo> What's wrong with that guys?
01:18:08 <ski> try using "mapM putStrLn c" instead of "return (map putStrLn c)"
01:19:31 <araujo> Ok
01:20:27 <ski> since   c :: [FilePath]     then    return (map putStrLn c) :: IO [IO ()]    which you don't wnat (the actions in the list are not run here)  instead you want  mapM putStrLn c :: IO ()
01:20:34 <ski> @type mapM
01:20:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
01:21:15 <ski> mapM is used to map a monadic function over a list
01:21:21 <ski> hm
01:21:23 <ski> sorry
01:21:31 <ski> actually  mapM putStrLn c :: IO [()]
01:21:33 <ski> so
01:21:37 <ski> @type mapM_
01:21:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
01:21:49 <ski> use  mapM_ putStrLn c :: IO ()
01:21:51 <ski> instead
01:21:59 <ski> (no need to collect a list of units)
01:22:19 <ski> araujo : ok ?
01:22:26 <araujo> ski, yeah, just testing :-)
01:22:30 <araujo> Let me see
01:22:57 <ski> another way would be to use  sequence_ (map putStrLn c)
01:23:04 <ski> @type sequence_
01:23:05 <ski> @type sequence
01:23:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
01:23:13 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
01:23:25 <ski> those are used to perform a list of actions, in left-to-right-order
01:23:56 <araujo> ski, check, i keep getting this weird error:
01:23:57 <araujo> /usr/lib/ghc-6.4/libHSrts.a(Main.o)(.text+0x10): In function `main':
01:23:58 <araujo> : undefined reference to `__stginit_ZCMain'
01:23:58 <araujo> /usr/lib/ghc-6.4/libHSrts.a(Main.o)(.text+0x36): In function `main':
01:23:58 <araujo> : undefined reference to `ZCMain_main_closure'
01:23:58 <araujo> collect2: ld returned 1 exit status
01:24:18 <ski> (though, mapM and mapM_ can be defined as   mapM = sequence . map  and  mapM_ = sequence_ . map)
01:24:50 <ski> hm, that's some linking error ..
01:25:04 <ski> maybe you are using some lib/package and not linking with it ?
01:25:05 <araujo> yeah
01:25:38 <araujo> mmm... that's what i am thinking, but that's the only code i am using
01:25:39 * ski thinks he's seen this error before, but can't remember rn how to fix it
01:28:11 <Akshaal>     No instance for (Typeable Test.QuickCheck.Property)
01:28:12 <Akshaal>       arising from use of `test' at test/hglib-gstring.hs:70:7-10
01:28:12 <Akshaal> hrrrr
01:28:42 <int-e> araujo: does your program define a main symbol in package Main? this appears to say that you don't.
01:29:02 <ski> araujo : hm, do you have a file with "module Main" ?
01:29:09 <araujo> ski, No
01:29:28 <ski> araujo : i think you must have one, to compile a standalone
01:29:36 <int-e> araujo, you can't create a program without those. (yeah, ski)
01:29:37 <humasect> or -main-is
01:29:46 <araujo> really? .. mmm , let's see
01:29:50 <ski> (though the file doesn't need to be called Main.[l]hs  iirc)
01:29:56 <ski> humasect : hm, yes
01:30:18 <dcoutts> araujo, or if you have any module that has no "module" bit at all then it defaults to being main
01:30:26 <Akshaal> how to derive instance for Typeable as easy as possible without touching source of QuckCheck?
01:30:29 <araujo> Thanks ski , that was it...
01:30:35 <araujo> dcoutts, hey bud!
01:30:43 <dcoutts> araujo, hia :-)
01:30:49 <araujo> dcoutts, how that goes?
01:30:56 <araujo> been long time
01:30:56 <ski> (araujo : some info on http://www.haskell.org/pipermail/cvs-all/2001-October/015816.html)
01:30:59 <dcoutts> araujo, what are you hacking on?
01:31:17 <araujo> dcoutts, i am writing some scripts
01:31:22 <dcoutts> araujo, I'm just back from holiday, life is good :-)
01:31:32 <araujo> :-)
01:32:02 <araujo> ski, Thanks
01:32:33 * Akshaal grumbles
01:33:00 <ski> Akshaal : i think, to derive instance of any class, for some type, you have to do it in the definition of the type
01:33:57 <dcoutts> Akshaal, or you can give the instance youself of course, has anyone written a Template Haskell way of deriving Typeable I wonder
01:33:58 <ski> (Akshaal : if you don't want to touch the source, you can try making an explicit instance Typable Test.QuickCheck.Property in your own file  (this isn't java :))
01:34:25 <dcoutts> someone should really re-write DrIFT using Template Haskell
01:42:44 <Akshaal> is there maintainer of QuickCheck on channel?
01:49:25 <araujo> What module the 'find' function is?
01:50:07 <dcoutts> @index find
01:50:08 <lambdabot> Data.List
01:50:17 <dcoutts> @type List.find
01:50:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:50:19 <araujo> handy :-]
01:50:32 <ski> @hoogle find
01:50:33 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
01:50:33 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
01:50:33 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
01:51:01 <araujo> hah . hoogle
01:52:44 <Akshaal> yeah, instance Typeable QC.Property where typeOf _ = mkTyConApp (mkTyCon "Test.QuickCheck.Property") []
01:55:39 <newsham> Test.hs:   module Test where; main :: IO () ; main = do putStrLn "Hello"
01:55:43 <newsham> $ runhugs Test.hs
01:55:43 <newsham> runhugs: compileExpr: invalid module
01:56:43 <newsham> is my runhugs simply broken?
01:56:48 <newsham> (runs fine in "hugs")
02:02:32 <ulfdoz> re
02:03:17 <newsham> oh!  runhugs doesnt want to run a module.
03:59:35 <xerox> Today is http://softwarefreedomday.org/ !
04:25:44 <Lunar^> Igloo: CosmicRay did not tagged #320970 as fixed in NMU
04:27:55 <Akshaal> Prelude Data.Char Data.PackedString> unlinesPS $ [packString "hello"]
04:27:55 <Akshaal> "hello"
04:27:55 <Akshaal> Prelude Data.Char Data.PackedString> unlines ["hello"]
04:27:56 <Akshaal> "hello\n"
04:28:50 <Akshaal> please, submit a bug somebody, I can't do it by sitting on GPRS
04:37:30 <int-e> unlinesPS = joinPS (packString "\n")
04:37:34 <int-e> hmm, not quite :)
04:42:28 <Akshaal> different behaviour of same functions is wrong
04:43:10 <arjanb> which packedstring library is that?
04:43:36 <Akshaal> from base
04:47:53 * int-e finds that the property joinPS (packString [x]) (splitPS x ls) = ls does not hold ... joinPS (packString "a") $ splitPS 'a' $ packString "aba" -> "ab". That's bad.
04:52:07 <musasabi> Akshaal: the Data.PackedString is not very good, you might want to use fps.
04:53:38 <arjanb> dons found similar problems in FastPackedString: http://www.abridgegame.org/pipermail/darcs-devel/2005-August/003128.html
04:55:04 * musasabi converted his opaque data Buf = Buf (ForeignPtr Word8) Int, to FastPackedString and the end result is very pleasing.
04:55:34 <musasabi> next, I could convert the binary parser combinators.
04:56:15 <int-e> arjanb: they probably implement unlines and lines in terms of join and split as well, but at least the join/split law quoted above holds there.
05:10:51 <^buggy^> Hello, can anyone see why this is crashing my hugs when calling say factors [(2,3)]
05:10:52 <^buggy^> http://pastebin.com/359682
05:12:42 <int-e> because you're missing a tail
05:13:29 <^buggy^> i don't understand, when will i not have a tail? :/
05:13:48 <int-e> btw, why don't you break the string in a pattern, factors ((x,y):xs) | ... = ?
05:13:56 <^buggy^> i tried to do that
05:14:01 <^buggy^> oh, I need those brackets
05:14:09 <^buggy^> I tried doing factors (x,y):xs = blah
05:14:11 <^buggy^> and got errors
05:14:17 <int-e> this part is wrong: (factors ((x,y-1) : xs))
05:14:22 <int-e> yes, you need those brackets.
05:15:01 <^buggy^> oh yeah
05:15:03 <^buggy^> I see why that is wrong
05:15:21 <^buggy^> i forgot to change that from when i waas doing factors (x,y):xs :(
05:15:23 <int-e> oh, and I meant list, not string :)
05:20:04 <^buggy^> yay works now, thanks
05:24:45 <^buggy^> if you're interested this is how i wrote it in the end
05:24:46 <^buggy^> http://pastebin.com/359690
05:28:39 <int-e> looks much better :)
05:56:33 <sylvan> question about unsafePerformIO ethics... I have a function, mapPar, which takes a function and a list and spawns off a new thread for each element computing f, this function along with the "-threaded" flag should give me a speed boost for heavy functions mapped on lists... Anyway, would you say that this is an acceptable candidate to have a pure interface even though the implementation is impure?
06:01:07 <int-e> sylvan: speed issues aside, that's exactly what map does, right? sounds pure to me.
06:06:24 <sylvan> int-e, yep, that's what I figure
06:09:50 <int-e> sylvan: I suppose the right question to ask is 'does the computation have any observable side effects' which it shouldn't have - the result of the computation is the only effect it has, any other effect would be a bug.
06:11:22 <sylvan> yep.. I'm considering if something unexpected can happen in forkIO (throwing weird exceptions etc.) which shouldn't happen in pure functions
06:13:24 <sylvan> Or I can just wait for them to implement `par`
06:13:31 <Heffalump> pure functions can throw exceptions too
06:13:47 <sylvan> but what _kind_ of exceptions?
06:13:57 <Heffalump> well, anything, they can call throw.
06:14:03 <sylvan> I'd be surprised to get some sort of IO exception from a pure function
06:14:20 <Heffalump> I'm not sure what specific exceptions, if any, forkIO itself might throw
06:14:37 <Heffalump> but I don't think there's any fundamental semantic problem.
06:15:01 <Heffalump> what are you going to do with the result of applying the function to an element inside the forked thread?
06:15:23 <Heffalump> oh, just return it I guess.
06:15:37 <Heffalump> map (unsafePerformIO.forkIO.return.f) xs
06:15:49 <Heffalump> oh, not quite that simple.
06:15:52 <sylvan> hmm.. not really
06:16:16 <sylvan> I use an intermediate step that returns a list of MVars which will get filled by all the forked off threads
06:16:19 <Heffalump> you'll need to either pass it back through an MVar
06:16:20 <Heffalump> right
06:16:25 <sylvan> then i mapM takeMVar
06:16:31 <sylvan> and return that
06:16:49 <Heffalump> either that, or let ys = map f xs in { fork off a load of computations that demand individual elements of ys }
06:17:00 <Heffalump> but I think the MVar approach is better
06:17:09 <sylvan> yeah me too
06:17:48 <int-e> hmm, using parallel Haskell ... parMap f l = let res = map f l in foldr par res res
06:17:52 * int-e ponders that
06:18:02 <Heffalump> actually, if you implemented runInThread :: IO a -> IO a on top of forkIO and an MVar
06:18:07 <Heffalump> then the code I gave above would work
06:18:25 <sylvan> jepp... They're supposed to implement a par function in the new GHC (the -threaded stuff) but in the paper they say they haven't done it yet
06:18:28 <Heffalump> and you'd have a general purpose operation you could use on other data structures etc
06:21:23 <int-e> (i.e. compute a lazy result and spark a computation for every element of the result list)
06:21:23 <sylvan> Heffalump, what would be the use of it though? You'll spawn off a thread and wait for it to finish? So you're not really saving time
06:21:23 <sylvan> runInthread :: IO a -> IO (MVar a) makes more sense
06:21:23 <sylvan> cause then you can do other stuff while the computation runs
06:21:23 <Heffalump> oh, true.
06:36:47 <sylvan> where the hell do I find gdk-2.0
06:36:50 <sylvan> ?
06:38:02 <int-e> sylvan, it comes with gtk+
06:38:13 <sylvan> ah.. weird that it can't be found then..
06:38:42 <sylvan> or it isn't, considering I installed an old version
06:38:45 <sylvan> doh
06:42:00 <Heffalump> sylvan: btw, be careful you don't pass back an unevaluated thunk in the MVar
06:42:10 <Heffalump> I've been bitten by that one several times.
06:42:24 <Heffalump> It's especially bad when the thunk might throw an exception
06:42:33 <sylvan> ah, you have a point.. Didn't think about that
06:43:18 <Heffalump> but in your case you just want to make sure some computation has been done
06:43:34 <Heffalump> are you planning on doing this on a multi-processor machine with ghc 6.5, btw?
06:43:38 <sylvan> yeh, I'll seq it in the forked thread..
06:43:39 <sylvan> yep
06:43:51 <Heffalump> what type is 'a'? Will you need to DeepSeq it?
06:44:24 <sylvan> that type could be anything I guess...
06:45:04 <sylvan> I'll just leave it to the user to make sure the function they pass in deepSeq's anything that will need to be deepSeq'd =)
06:45:41 <sylvan> or maybe I'll wait til par gets implemented and use that...
06:45:56 <sylvan> It's not something I really need for anything, just an experiment
06:47:43 <Heffalump> doesn't par have the same semantics as seq?
06:48:22 <sylvan> yep..
06:48:57 <sylvan> map' f (x:xs) ) f x `par` f x : map' f xs
06:49:05 <sylvan> if I'm not misstaken about par, that is
06:49:14 <Heffalump> my point being that it won't DeepSeq things for you either.
06:49:30 <Heffalump> it'll just parallelize the reduction to WHNF. ICBW.
06:49:55 <sylvan> ah... well then the user will have to wrap their functions in a deepSeq if it's needed
06:49:59 <int-e> sylvan: you're relying on CSE there, better use let, let e=f x in e `par` e:map' f xs.
06:50:28 <sylvan> any reason CSE wouldn't work there?
06:50:40 <Heffalump> it's not guaranteed
06:50:46 <sylvan> ah..
06:50:50 <int-e> any reason a Haskell compiler *has* to implement CSE?
06:50:57 <sylvan> yeah you have a point
06:52:23 * int-e wonders what map' f l = [x `par` x | x <- map f l] would do.
06:53:33 <int-e> but it seems wrong - the `par` wouldn't be triggered eagerly.
06:53:54 <Heffalump> it'll only be triggered when you demand x anyway
06:53:58 <Heffalump> which isn't much use
06:54:02 <sylvan> anyone get the gtk2hs "cairo release" to work? When I make it says it can't find Cairo.chs..
06:55:16 <int-e> sylvan's map' has a similar problem though.
06:55:58 <Heffalump> ah, yes
06:56:07 <Igloo> shapr: You here?
06:57:13 <int-e> so probably something like parEval::[a]->[a]; eval l = foldr par l l   is best. the foldr yields no result before all computations in the list have been sparked.
06:57:27 <sylvan> There should be a standard "take this list and evaluate each element completely and in parallell"... That seems to me as a very common pattern if you're trying to speed stuff up using multiple CPUs
06:58:03 <Heffalump> well, there's the implementation :-)
06:58:06 <sylvan> =)
06:58:37 <sylvan> It would be nice to have it in the libs, though
06:59:03 <Heffalump> there's no `par` yet, though
06:59:12 <sylvan> yeah... too bad...
06:59:37 <sylvan> dammit.. I can't get Gtk2Hs-0.9.9.5 to compile...
07:07:14 <Heffalump> par x y = unsafePerformIO ( do { forkIO (return x) ; return y } )
07:07:16 <Heffalump> why isn't that par?
07:09:12 <Lemmih> What should force the evaluation of 'x'?
07:09:32 <psi> sylvan: I had a similar problem. I think it said it couldn't find 'cairo/cairo.h', though.
07:09:44 <sylvan> so what's the solution?
07:10:09 <psi> I don't know :) I haven't tried to solve it yet.
07:10:20 <Heffalump> sorry, return $! x
07:10:37 <Heffalump> I think that would make par behave like seq but in parallel
07:10:44 <psi> I have installed cairo, of course.
07:11:21 <Philippa_> how well-specced are the concurrency extensions?
07:11:26 <Lemmih> @type Control.Concurrent.forkIO
07:11:32 <sylvan> psi, did you install the cairo development files as well?
07:11:47 <lambdabot> IO () -> IO GHC.Conc.ThreadId
07:11:48 <Philippa_> to put it another way, why would I expect the values used by the forked thread not to be copied?
07:12:03 <Lemmih> Heffalump: forkIO (x `seq` return ())
07:12:17 <Heffalump> ah, yes
07:12:35 <psi> sylvan: they aren't separated in darwinports, I believe. there is only one 'cairo' package.
07:12:49 <sylvan> ah.. I think they were different on ubuntu
07:13:01 <sylvan> the synaptic package mangaer thingy
07:13:05 <psi> debian tends to do that
07:15:04 * int-e thinks
07:15:30 <int-e> forkIo (return (x `seq` ())) looks better.
07:17:19 <Philippa_> you're a lisper, right?
07:17:26 <sylvan> =)
07:18:09 <Philippa_> (though that should then be forkIO (return (seq x ())))
07:18:24 <musasabi> Of course seq does not help for many types.
07:18:28 <int-e> no, it would be (forkIO (return (seq x ()))) then.
07:18:38 <Lemmih> int-e: That's not the same.
07:19:06 <int-e> Lemmih: yes, but your version evaluates x in the context of the thread that creates the IO monad for forkIO.
07:21:29 <int-e> Lemmih: and that's not the purpose of the exercise, the purpose of the exercise is to give the newly created thread something to work on.
07:22:24 <Lemmih> forkIO (return (seq x ())) will not force the evaluation of x.
07:24:46 <int-e> @hoogle unsafePerformIO
07:26:24 <int-e> which module defines that again?
07:26:35 <Lemmih> System.IO.Unsafe
07:27:54 <Heffalump> I'm not convinced putting the seq inside the return is ok.
07:28:03 <Heffalump> What if forkIO never looks at the ()?
07:29:36 <int-e> it seems it doesn't. but it's wrong in front of the return as well.
07:29:49 <Lemmih> Why?
07:30:41 <sieni> why, oh why do I have to compile grep myself for fink
07:30:43 <sieni> dang
07:31:58 <Lemmih> 'forkIO (x `seq` y)' /= 'x `seq` forkIO y'
07:32:06 <gour> shapr:hi
07:34:09 <z0d> Haskell arrays are always hashes?
07:34:33 <int-e> Lemmih: hmm.
07:35:08 <Heffalump> z0d: wdym?
07:35:26 <z0d> Heffalump: are they vectors or association lists?
07:35:35 <Heffalump> Haskell arrays are vectors.
07:35:47 <z0d> ok, thanks
07:35:55 <Heffalump> Data.Map gives association lists
07:36:02 <z0d> nice
07:48:23 * gour is away: short nap
07:49:47 <int-e> Lemmih: ok, there's no reason for forkIO to look at the IO monad (i.e. evaluate it to whnf) before the fork is done, so your version is sufficient. it never looks at the result of the return, too, so my version does not work.
09:31:57 * gour is back.
09:32:14 <gour> hi duncan
09:32:29 <gour> have you checked mirror?
09:32:49 <dcoutts> sorry, gour, we can talk later, I've gotta go
09:33:09 <gour> ok, i also just passed by :-)
09:50:06 <bouncy`> hi
09:50:23 <xerox> Hello bouncy`
09:50:24 <bouncy`> i'm new to haskell, and i can't figure out what is wrong with this snippet: http://paste.se.linux.org/?id=1192
09:50:37 <bouncy`> could someone please point me in the right direction?
09:51:04 <bouncy`> hi xerox :)
09:52:40 <basti_> @type match
09:52:46 <lambdabot> bzzt
09:52:52 <basti_> uhm
09:52:53 <basti_> lol
09:53:06 <basti_> but, obviously, bouncy`, loot at the return type of your function
09:53:17 <xerox> What is the purpose of the code?
09:54:11 <bouncy`> xerox: see my comment under the code
09:55:58 <bouncy`> basti_: that is what i am having trouble with
09:56:10 <xerox> @type lookup
09:56:12 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
09:57:21 <bouncy`> the preceeding check makes sure that i won't get Nothing in the subsequent call, but this is not obvious to the interpreter
09:57:29 <xerox> @plugs (\c xs ys -> lookup c $ zip xs ys) '*' "a=*" "a=2"
09:57:31 <lambdabot> Just '2'
09:57:43 <xerox> ^_^
09:58:27 <basti_> bouncy`: you need to destruct the type. (ie. match it away)
10:01:02 <bouncy`> basti_: hmm, how do i do that. my book doesn't mention anything about destructing types.
10:01:22 <xerox> bouncy`: by pattern matching
10:02:23 * gour is away: busy
10:02:54 <xerox> bouncy`: by pattern matching the constructors
10:03:26 <bouncy`> xerox: neat snippet - i hope i will reach that level of enlightenment some day :)
10:03:32 <xerox> e.g.  f :: Maybe Int -> Int  f (Just x) = x  f Nothing = 0.
10:03:40 <bouncy`> basti_, xerox: hmm... i going to experiment a bit
10:04:00 <basti_> :)
10:04:06 <xerox> bouncy`: in fact it's just an idea, and it doesn't take consideration of the other chars at all.
10:05:36 <bouncy`> xerox: yeah, my function needs to handle expressions such as match '*' 'i am *' 'i am tall', and i am not sure your snippet does that
10:06:13 <xerox> It doesn't :-)
10:11:04 <basti_> lisppaste2: @url
10:11:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:11:33 <lisppaste2> basti_ pasted "string replacement toy problem" at http://paste.lisp.org/display/11548
10:11:39 <basti_> bouncy`: like that?
10:23:20 <bouncy`> basti_: i think i get the idea
10:24:06 <bouncy`> i'm thinking of replacing the s : match ... with a function that pattern matches away the problem (i.e. takes a character and Maybe), and has explicit definitions for the Just and Nothing cases
10:24:56 <basti_> that should be easy
10:25:43 <bouncy`> haha... "Inferred type is not general enough"
10:25:59 <lisppaste2> int-e pasted "a match function for bouncy`" at http://paste.lisp.org/display/11550
10:33:30 <bouncy`> int-e: thanks, but i need to figure out how to get my code to work the hard way :-)
10:38:53 * SamB desires the secret to ultimate cosmic power
10:39:32 <SamB> er, well, actually, I really just want to know how to control the scoping of a where clause...
10:40:02 <bouncy`> SamB: from where i'm standing, those two are equal :-)
10:40:44 <xerox> Do you know of any program that perform sort of static analysis on a C source?
10:40:47 <SamB> well, the latter seems just a little bit more probable to me...
10:41:21 <SamB> xerox: I don't even know how to parse it, nevermind analyze it.
10:41:54 <ibid> xerox: humm?  either i don't get what you're asking or the answer is rather trivial
10:42:39 <xerox> ibid: in the latter case what would be the answer?
10:43:19 <ibid> xerox: the c compilers and the various lints are well known ones
10:44:31 <xerox> Lints seem a good idea.
10:48:08 <ibid> a student made a c extender as a course project in my fp course
10:49:02 <ibid> (one that transforms c source to add bounds checking)
10:49:22 <xerox> Cool.  A friend of mine asked for help in his segfaulting C program... :-)
10:50:32 <dcoutts> gour, btw the darcs Tailor mirror is working fine, it translated my cvs commit from yesterday to a darcs patch preserving the commit message etc
10:50:53 <xerox> Hi dcoutts!
10:50:57 <dcoutts> hi xerox
10:51:04 <dcoutts> how's stuff?
10:51:04 <gour> dcoutts, glad to hear
10:51:05 * SamB gives up on where and uses a let
10:51:33 <dcoutts> gour, this Tailor cvs->darcs thing seems quite good really
10:51:47 * gour is back.
10:52:07 <gour> dcoutts, true and i'm bugging author with some bug-reports :-)
10:52:08 * SamB curses the uselessnes of "Prelude.head: empty list"
10:52:14 <dcoutts> gour, what do you think we need to do before announcing it publicly
10:52:39 <gour> dcoutts, well it's already announced on gtk2hs-dev :-)
10:52:44 <dcoutts> true
10:52:57 <xerox> dcoutts: pretty well
10:53:20 <dcoutts> goron, I mean like a link on the web page and the repo being in the gtk2hs web space etc
10:53:25 <gour> it's just a question if we want it under gtk2hs site?
10:54:15 <dcoutts> gour, I think we do, don't you?
10:54:25 <gour> sure
10:54:37 <Heffalump> how does tailor handle two-way mirroring, if at all?
10:55:29 <gour> not yest tested, but it does handle
11:01:42 <gour> dcoutts, so we can wait a few more commits and then move it under gtk2hs site?
11:03:22 <dcoutts> gour, yeah I reckon so
11:04:06 <gour> ok, now i'm going to take a dinner, c u later
11:04:14 * gour is away: taking dinner
11:04:19 <dcoutts> ok bye gour
11:10:44 <SamB> okay, is there some way to embellish the exceptions thrown by Prelude.error?
11:11:39 <xerox> @index bracket
11:11:40 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.
11:11:40 <lambdabot> Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
11:11:49 <xerox> @type Control.Exception.bracket
11:11:54 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:12:06 <xerox> @docs Control.Exception
11:12:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
11:12:48 <SamB> I just want to add a little to the beginning of the message...
11:13:20 <Heffalump> based on the call site?
11:13:42 <Heffalump> if you just want to append the same thing to all errors within a given computation, mapException
11:13:43 <xerox> Oh I have it.
11:13:43 <SamB> sort of.
11:13:59 <Heffalump> but that will be very painful to apply to all call sites of things that might cause errors
11:14:59 <SamB> well, yes, for all exceptions within a computation, I want to prepend the address of the Z-Machine instruction the computation is supposed to interpret...
11:15:46 <xerox> catch (do { head []; return () } ) (print.("Foo: "++).show)
11:15:46 <xerox> "Foo: Prelude.head: empty list"
11:16:45 <SamB> I don't want to *catch* it, I just want to annotate it
11:16:59 <ski> @type Control.Exception.mapException
11:17:00 <lambdabot> forall a. (GHC.IOBase.Exception -> GHC.IOBase.Exception) -> a ->
11:17:00 <lambdabot> a
11:17:07 <Heffalump> mapException will annotate it, as I said
11:17:25 <Heffalump> but it will still be very painful to do that for each call site
11:17:34 <SamB> I only have one call site
11:17:49 <Heffalump> but how do you get the Z-Machine instruction?
11:17:49 <xerox> OK sorry.
11:18:46 <SamB> right now, I have a line that says: runStateT (forever exec) $ ZState [...]
11:20:15 <SamB> I'll just do something like "let exec' = mapException f exec" in the line before...
11:20:24 <SamB> or thereabouts
11:23:30 <SamB> no wait, that won't work...
11:23:52 <SamB> hmm, how do I do this with a StateT?
11:24:54 <Heffalump> why won't it work?
11:25:36 <SamB> oh
11:25:49 <SamB> I didn't notice the type there...
11:26:10 * SamB wonders how that works
11:28:13 <SamB> @index showHex
11:28:14 <lambdabot> Numeric
11:28:48 <Oejet> xerox: You might find http://en.wikipedia.org/wiki/Cyclone_programming_language interesting with regards to static analysis of C.
11:30:20 <SamB> @index ErrorCall
11:30:21 <lambdabot> Control.Exception
11:30:49 <xerox> Oejet: thanks!
11:43:54 <TheHunter> Prelude Control.Exception> mapException (\(ErrorCall e) -> ErrorCall $ "foo: " ++ e) $ error "bar"
11:43:54 <TheHunter> *** Exception: foo: bar
11:43:54 <TheHunter> Prelude Control.Exception> mapException (\(ErrorCall e) -> ErrorCall $ "foo: " ++ e) $ [error "bar"]
11:43:54 <TheHunter> [*** Exception: bar
11:44:32 <TheHunter> so you might have to watch out for laziness.
11:46:29 <SamB> actually, I had rehash mapException to work with StateT...
11:47:01 <SamB> so I have:
11:47:08 <SamB>            mapExceptionStateT f (StateT g) = StateT h
11:47:08 <SamB>                where h s = catch (g s) (\x -> throw (f x))
11:47:14 <SamB> in the middle of my code
11:47:38 <SamB> I suppose I could have stuck it down at the bottom or something...
11:47:59 <SamB> and actually, that isn't even named very well
11:48:14 * SamB thinks the MTL needs some work
11:49:43 <TheHunter> @type Control.Monad.State.mapStateT . Control.Exception.mapException
11:49:49 <lambdabot> forall (m :: * -> *) a s.
11:49:49 <lambdabot> (GHC.IOBase.Exception -> GHC.IOBase.Exception)
11:49:49 <lambdabot> -> Control.Monad.State.StateT s m a
11:49:49 <lambdabot> -> Control.Monad.State.StateT s m a
11:50:05 <SamB> you think that would work?
11:50:41 <SamB> compare to:
11:50:46 <SamB> mapException f v = unsafePerformIO (catch (evaluate v)
11:50:46 <SamB>                                           (\x -> throw (f x)))
11:50:59 <TheHunter> ah, you're using StateT IO ?
11:51:52 <SamB> StateT s IO
11:51:58 <SamB> yes
11:52:16 <TheHunter> then it's different.
11:52:28 <TheHunter> But you can still use mapException.
11:52:31 <SamB> I guess so
11:52:44 <TheHunter> *mapStateT
11:52:51 <TheHunter> that's what i wanted to say.
11:53:05 <SamB> show me, and show me it working, not just type sigs!
11:54:33 <TheHunter> @type \f -> Control.Monad.State.mapStateT (\x -> x `Control.Exception.catch` throw (f x))
11:54:35 <lambdabot> bzzt
11:55:11 <SamB> oh, I think I see what you mean...
11:55:24 <TheHunter> @type \f -> Control.Monad.State.mapStateT (\x -> x `Control.Exception.catch` (throw . f))
11:55:26 <lambdabot> bzzt
11:55:41 <TheHunter> @type \f -> Control.Monad.State.mapStateT (\x -> x `Control.Exception.catch` (Control.Exception.throw . f))
11:55:43 <lambdabot> forall a s.
11:55:43 <lambdabot> (GHC.IOBase.Exception -> GHC.IOBase.Exception)
11:55:43 <lambdabot> -> Control.Monad.State.StateT s IO a
11:55:43 <lambdabot> -> Control.Monad.State.StateT s IO a
11:56:42 <TheHunter> @type \f -> Control.Monad.State.mapStateT (\x -> x `Control.Exception.catch` (Control.Exception.throwIO . f))
11:56:44 <lambdabot> forall a s.
11:56:44 <lambdabot> (GHC.IOBase.Exception -> GHC.IOBase.Exception)
11:56:44 <lambdabot> -> Control.Monad.State.StateT s IO a
11:56:44 <lambdabot> -> Control.Monad.State.StateT s IO a
11:56:57 <SamB> is it really any easier that way?
11:57:29 <TheHunter> it is for me. No need to fiddle with the StateT internals.
11:57:34 <SamB> true
11:57:36 * gour is back.
11:57:44 <SamB> but who would change those?
11:58:09 <TheHunter> your definition of mapExceptionStateT does.
11:58:11 <gour> ski: hi
11:59:05 <SamB> what is the significance of throwIO?
11:59:57 <TheHunter> i guess throwIO x `seq` () ==> (), throw x `seq` () ==> _|_
12:01:25 <SamB> @type Control.Exception.throwIO
12:01:26 <lambdabot> forall a. GHC.IOBase.Exception -> IO a
12:01:40 <SamB> is that actually usefull?
12:02:04 <ski> gour : hiya
12:02:04 <TheHunter> what?
12:02:30 <gour> ski: just to thank you for your support yesterday
12:02:55 <gour> ski: i was able to unify all the examples from 13.7
12:03:00 <ski> np, yw
12:03:04 <ski> ok, nice
12:03:19 <gour> ski: and now i can start grokking 14th chapter :-)
12:03:31 <TheHunter> in the situation above, i would prefer throwIO, but I'm not sure if throw could bite you in the ass in some situations.
12:04:26 <gour> ski: it was a kind of showstopper for my further haskell-adventure
12:04:46 <TheHunter> usually, one wants IO actions not to be bottoms.
12:06:07 * Philippa_ winces for a moment while her brain fails to context-switch fast enough
12:06:09 <Philippa_> *bad* image
12:07:15 <ski> gour : the craft .. ?
12:07:28 <gour> ski: yes
12:08:03 <gour> ski: i'm not solving all the exerc., but trying as much as possible
12:08:27 <ski> oki
12:09:17 <gour> i'm planning to re-work some of them during the further readings
12:09:28 <gour> to see how the code is evolving
12:09:46 <gour> while learning new language-features
12:10:00 <gour> however, the real stuff just begins
12:14:07 <ski> m
12:15:32 * Akshaal is wrapping glib-2.0
12:16:24 * Akshaal tired of filesystem encoding issues, encoding, charsets in haskell
12:17:22 <gour> Akshaal: would you like to hav unicode?
12:17:39 <dcoutts> Akshaal, you might like to see the Gtk2Hs glib stuff
12:17:59 <gour> that's a good idea ;)
12:18:19 <dcoutts> Akshaal, we wrap parts of the glib/gobject api and we have a code generator for producing the bindings semi-automatically
12:22:28 <gour> dcoutts, next week i'm going to 14th ch.
12:22:36 <gour> wish me a good luck
12:25:22 * musasabi has had encoding issues with GTK apps too - so glib might not be the ultimate solution.
12:25:57 <gour> musababi: what's wrong with encodings?
12:26:23 <musasabi> gour: filename encoding vs locale vs encoding inside files
12:27:03 <gour> musababi: how is with utf-8?
12:27:36 <gour> musababi: you mean in gtk apps in general, not haskell, ie. gtk2hs
12:27:43 <musasabi> gour: Only about 2% of my daily things are in utf-8.
12:28:01 <musasabi> gour: yes, gtk in general.
12:28:21 <gour> musababi: my locale is utf-8, but for the filenames i stick with latin-1
12:28:51 <gour> musababi: my problem is that LyX does not speak unicode (yet)
12:37:35 * vegai wonders why people use lyx
12:37:50 <ibid> yeah, use groff ;)
12:38:04 <vegai> no! troff!
12:38:07 * vegai smirks.
12:38:22 <ibid> troff is not free software :)
12:38:31 <ibid> except gnu troff :)
12:38:48 * ibid ponders writing my dissertation in *roff
12:40:43 <vegai> hmm, is there an "original troff"?
12:41:39 <ibid> yes
12:42:07 <musasabi> troff is nice, except the maths part is not very good and using styles rather than absolute markup is harder than in latex. (of course macro packages remedy that)
12:42:11 * SamB generally keeps filenames in ascii, but would prefer that they be in utf-8 otherwise
12:42:21 <musasabi> But it is nice for small homework exercises.
12:42:35 <ibid> it's part of the historical unix releases, and i assume survives in the proprietary unices
12:42:52 <ibid> musasabi: usign styles is about as easy as in TeX
12:43:17 <musasabi> true, but I haven't had to use TeX.
12:43:33 <ibid> and even the ancient ms macros provide the basic styling
12:44:48 <ibid> you have headings, you have floats etc
12:44:52 <ibid> what else does one need :)
12:45:41 <araujo> What is the special charactr for space?
12:46:06 <SamB> special character?
12:46:12 <musasabi> 32 - 0x20 - ' '
12:46:31 <SamB> how is that special?
12:46:37 <SamB> its just a space!
12:47:01 <musasabi> what is special space then?
12:47:17 <musasabi> (I don't understand the term)
12:47:18 <ibid> non-breaking space?
12:48:46 * araujo got too much <other-language-here> in his head
12:49:16 <SamB> other than english, or what?
12:50:54 <vegai> incidentally, the plan9 version of troff supports unicode
12:50:57 <poetix> (Seemingly off-topic, but actually not): Has anybody got a copy of Arthur C. Clarke's "Imperial Earth" to hand?
12:53:04 <araujo> SamB, differents programming languages handles character representation differently, you should know that :-)
12:53:32 <xerox> poetix: not!  But, could I ask you why? :)
12:53:52 <poetix> It has to do with pentomino puzzles, and my TMR article on generating polyominoes
12:54:40 <poetix> I don't have a copy myself, although it used to be one of my favourite books, but I do remember that the main protagonist struggles with a pentomino puzzle at one point - I'm just trying to clarify the details
12:56:16 <Philippa_> poetix: there's one next door somewhere I think, but that's not really "to hand"
12:57:15 <poetix> It's not mega-important, I'm just trying to find out what form the polyomino puzzle given to Duncan Mackenzie actually takes - I remember a set of pieces, but not whether the box was 6x10 squares or 3x20
12:57:49 <poetix> Now I think of it, my sister almost certainly has my copy - I should bug her about it
12:58:23 <Philippa_> I think I vaguely remember 3x20, but I could very easily be wrong
13:02:39 <poetix> I know he struggles with the 3x20 puzzle at some point. Damn, I want to re-read it now.
13:13:16 <dcoutts> musasabi, re gtk & file name encodings, yes we do have a problem. We can either translate from the locale encoding into unicode so it can be displayer to the user or keep the raw encoding so it can be used to open files. Because the locale -> unicode translation is not reversable.
13:14:51 <musasabi> dcoutts: and the problem is made worse by users having filenames in multiple locales.
13:15:25 <musasabi> But I don't think that is a problem specific to Haskell.
13:39:43 <sethk> musasabi, that's fair (that it is not specific to haskell).  :)
15:19:14 <xerox> Goodnight folks.
15:19:53 <cjb> G'night.
16:10:33 <araujo> Anyon knows a function to splitup strings using a pattern?
16:16:42 <Korollary> there's regexp support in the libraries
16:30:49 <araujo> thanks Korollary
17:00:06 <Drakioned___> hey, anyone here?
17:01:27 <araujo> sort of
17:02:54 <Drakioned___> d'you know any websites that demostrate the syntax and use of MVars?
17:03:48 <Cale> Drakioned___: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.MVar.html
17:05:15 <Cale> Drakioned___: or are you looking for something more detailed?
17:05:34 <Drakioned___> hmm, kinda, I'm just learning Haskell at the moment
17:06:31 <araujo> Can anyone help me with the reasoning of a simple function?
17:07:04 <Cale> Drakioned___: I'll see if I can find you something
17:07:49 <Drakioned___> thanks
17:10:11 <lisppaste2> araujo pasted "spaces" at http://paste.lisp.org/display/11563
17:10:53 <Cale> www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz -- this is detailed, but I don't know how easy it'll be for someone new
17:11:08 <araujo> I wanna do something like: (['c'] ++ ['d']) : [] ++ (['f'] ++ ['f]) : [] .......
17:11:24 <Cale> then again, thread communication isn't exactly the easiest subject :)
17:11:35 <Cale> araujo: hm?
17:11:37 <Drakioned> heh
17:12:04 <araujo> Cale, the exampledoesn't work, just gives the general idea of how i wanna do it so far....
17:12:54 <araujo> I wanna  "hello there" -> ["hello" , "there"]
17:13:07 <Cale> ah
17:13:18 <Cale> @eval words "hello there"
17:13:24 <lambdabot> ["hello","there"]
17:13:32 <araujo> yeah, i know words exist :-]
17:14:07 <Cale> you could look at the code for words to get some idea :)
17:15:17 <araujo> yeah, i just didn't want to do it before to know if it is possible to get it done in the way i am doing
17:16:38 <cognominal> "you can ask a bot on #haskell to turn programs to its most abstracted form". Where is the code of this bot?
17:16:58 <cognominal> btw, quote from http://www.perl.com/lpt/a/2005/09/08/autrijus-tang.html
17:17:15 <Cale> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:17:55 <cognominal> thx
17:19:03 <Cale> The module that does the simplification is in Modules/Pl
17:19:11 <Cale> iirc
17:19:23 <Cale> and though it tends to work, it's not perfect
17:20:16 <TheHunter> which is not surprising as making it perfect involves solving the halting problem...
17:20:24 <cognominal> :)
17:21:13 <TheHunter> but Cale is right, the parser doesn't support much sugar, but it can do that:
17:21:19 <TheHunter> \1 -> 1 * 1
17:21:23 <TheHunter> @pl \1 -> 1 * 1
17:21:24 <lambdabot> join (*)
17:21:40 <cognominal> apparently for the world to be perfect, it has to be regular org finite/ that is ... boring
17:22:57 <TheHunter> hmm
17:23:02 <TheHunter> @type \1 -> 1 * 1
17:23:03 <lambdabot> forall a a1. (Num a, Num a1) => a -> a1
17:31:04 <Drakioned___> test
17:31:07 <Drakioned___> hmm
17:35:03 <Drakioned___> okay, now I'm really confused.
17:36:52 <Cale> hello
17:36:58 <Cale> what are you confused about?
17:36:59 * SamB just thinks filenames should always be in unicode
17:37:08 <Cale> SamB: I agree. :)
17:37:19 <SamB> I think microsoft does too
17:37:20 <Cale> But which encoding of unicode?
17:37:30 <SamB> doesn't particularly matter...
17:37:43 <Cale> as long as you're consistent :)
17:38:10 <SamB> the filesystems can even use different ones, so long as its only one each...
17:38:12 <Cale> Drakioned___: having trouble?
17:38:14 <Drakioned___> well, you know what I asked about earlier? well, I tried writing a thread to decrement a MVar from 10, and another that prints a line when it hits 0, and the program seems to do nothing.
17:38:32 <Cale> can you paste the program somwhere?
17:38:48 <Cale> are you making sure to start the threads from main?
17:38:59 <Drakioned___> yeah, they're starting in main
17:39:13 <Cale> So you're familiar with plain IO in Haskell then
17:39:19 <Drakioned___> a tad
17:40:21 <Cale> I believe what you'd do is to have something like  v <- newMVar 10; forkIO (myThread v)
17:40:52 <Drakioned___> yeah, that's what I'm doing
17:41:10 <Cale> and you pass v to both your threads like that...
17:41:16 <Drakioned___> yeah
17:41:34 <Drakioned___> but the program terminates and I can't see anything happening from the threads
17:42:05 <Cale> I think readMVar will let you examine the MVar without blocking
17:42:33 <Cale> oh
17:42:46 <Drakioned___> hmm, think I'm trying to solve the wrong program
17:42:51 <Cale> takeMVar will block if the MVar is empty
17:43:23 <Drakioned___> I just tried to do forkIO(print "Hello World") and that didn't do anything either, methinks it's printing to somewhere else other than the screen..
17:43:30 <Cale> remember that you don't want main to finish while your threads are running
17:43:59 <Cale> or the program will end and kill off all your thread
17:44:00 <Cale> s
17:44:00 <Drakioned___> no.. how'd I prevent that?
17:44:31 <Cale> either move the waiting thread into main directly
17:44:37 <Cale> (don't fork)
17:45:00 <Cale> or you can add an MVar which something writes to when it's done
17:45:18 <Cale> and have main try to read that mvar (create it so it's empty, so main will block)
17:45:38 <Drakioned___> is there a function that ends the program?
17:45:45 <Cale> exitWith
17:45:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Exit.html
17:46:12 <Drakioned___> ah.. so I can do main = (code here) ; (some check to kill the program) ; main ?
17:46:58 <Cale> main = do (spawn the writer thread); (loop to check if the MVar is 0 yet); print "Hit zero"
17:48:11 <Drakioned___> okay.
17:51:38 <Cale> well, you actually probably want putStrLn, but that's a minor point :)
17:51:56 <Drakioned___> heh
17:52:36 <Drakioned___> well, I figured there was enough I had figured out to do what I actually wanted to do, the MVar testing thing was just to see how it worked
17:53:31 <Drakioned___> here's hoping I don't get disconnected again whilst trying to download cygwin..
18:55:20 <blackdog> good morning all
18:56:59 <sethk> how come everyone on #haskell gets confused about whether it is morning or evening?   :)
18:57:15 <Drakioned____> hey Cale, are you still there?
18:59:15 <Cale> Drakioned____: yeah
18:59:51 <Cale> sethk: many people are in Europe, and some Australia, as well as a good number of North Americans
19:00:16 <sethk> Cale, I suspected as much.  :)
19:00:25 <Drakioned____> I've gone and written that MVar thing I was trying to do, but I get an infinite loop somewhere, if I can upload it somewhere, can you take a look at it?
19:00:47 <Cale> Drakioned____: yeah, put it on the HaskellIRCPastePage on the wiki
19:00:57 <Cale> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:01:36 <Drakioned____> er.. how to use that?
19:01:52 <Cale> EditText of this page
19:02:21 <Cale> then add the code near the top, and surround it with {{{ }}} -- you can use {{{#!syntax haskell ... }}} to get syntax colouring
19:03:20 <Cale> sethk: http://www.haskell.org/hawiki/HaskellUserLocations :)
19:03:49 <blackdog> Cale: actually, i'm just drunk and wearing sunglasses. </unconvincing>
19:03:58 <Cale> heh
19:04:09 <Drakioned____> done
19:06:51 <mr_ank> hi people - is this a suitable channel to ask a beginner-level Haskell question?
19:07:18 <Cale> mr_ank: yep :)
19:07:21 <Drakioned> mr_ank -> well, I'm one and I've been asking lots
19:07:43 <neadjneki> draki i could make misterious-deadlock with shorter code :P
19:07:50 <mr_ank> cool!
19:08:16 <mr_ank> well i'm sure it's pretty simple - i'm defining a simple recursive function like so "function (x:xs) = x + function xs"
19:08:56 <Cale> mr_ank: that's sum, so long as the base case is handled correctly
19:09:00 <mr_ank> the thing is, it'd be really cool to be able to have the *last* element of the list and the rest instead of the first and the rest
19:09:19 <Cale> mr_ank: well, that's just interpretation, isn't it?
19:09:27 <sethk> how about tail?
19:09:32 <Cale> you could reverse the list before you began
19:09:43 <mr_ank> Cale: i mean, just for my particular example
19:10:01 <Drakioned> I think it'll have to be a reversed list, otherwise it'll break if you try and do function [1..]
19:10:24 <Cale> (well, it's going to break on that list anyway :)
19:10:38 <Drakioned> er.. good point
19:10:40 <Cale> but you're possibly describing the difference between foldr and foldl
19:10:51 <mr_ank> Cale: i read a bit about that too
19:10:59 <mr_ank> thing is i'm self-learning haskell
19:11:03 <Cale> the way you have it written, it's  foldr (+) 0
19:11:16 <Drakioned> nead -> any idea about the mysterious deadlock?
19:12:19 <mr_ank> hm - so it's not possible to do something like (xs:x)?
19:12:34 <Cale> Drakioned: you know, concurrency and parallelism are separate concepts in Haskell at the moment...
19:12:43 <Cale> mr_ank: nope
19:13:01 <Drakioned> Cale -> well yeah, but how else to implement that idea?
19:13:03 <mr_ank> Thanks people :)
19:13:07 <Drakioned> besides forkIO?
19:13:30 <Cale> mr_ank: though if you care nothing about efficiency, you can use last and init to get the last element and everything but the sat element
19:13:32 <Cale> last*
19:13:42 <sethk> Cale, when would concurrency and parallelism _not_ be separate concepts, in any language?
19:13:54 <Drakioned> mr_ank, well, the thing is on most lists, there's usually a first element, but there isn't necessarily a last element
19:14:16 <mr_ank> Cale: i'm self-learning haskell from a book - but i think an excercise i'm trying to do cannot be solved with the haskell they've introduced so far
19:14:22 <Cale> sethk: when the compiler automatically puts separate threads on separate processors?
19:14:34 <Drakioned> mr_ank -> ooh, which book?
19:14:39 <mr_ank> but i don't want any help with the excercise itself - just questions about Haskell.
19:14:47 <sethk> sethk, what does that have to do with concurrency w.r.t. coding or languages?
19:15:05 <Cale> sethk: you're asking yourself a question?
19:15:08 <mr_ank> Drakioned: it's a book in Spanish "Razonando con Haskell" used mainly in Spain
19:15:10 <Drakioned> sethk: talking to yourself is a really bad sign
19:15:17 <Drakioned> mr_ank: ahh
19:15:35 <sethk> sethk, but I give such great answers.  :)
19:15:40 <Drakioned> wow, this thing has tab completion, neat.
19:15:45 <sethk> I never could figure out how to use a mouse.  :)
19:17:59 <Drakioned> hmm, well, on the subject on parallelism, how do I apply a function to a list and have the process threaded?
19:18:22 <Drakioned> besides using that piece of code which doesn't work.
19:19:10 <neadjneki> draki it seems to me that holder <- takeMVar datStore as it never holds a value
19:19:33 <neadjneki> i mean it is blocking because datStore is always empty
19:20:21 <neadjneki> i might be wrong though..
19:20:52 <Cale> neadjneki: I think you're right
19:21:06 <sh10151> sounds like Control.Concurrent, Drakioned
19:21:38 <Drakioned> er... yeah.
19:21:50 <Cale> Drakioned: I don't really understand why you'd want to have it threaded unless to run on multiple processors
19:22:12 <Cale> In which case you want Control.Parallel (if that's working at the moment, I haven't tried it)
19:22:14 <Drakioned> Cale -> actually, it's to run on a dual core Athlon.
19:22:25 <Cale> Yeah, you want Control.Parallel
19:22:38 <Cale> Concurrent threads still run on the same processor, iirc.
19:23:00 <Cale> and Control.Parallel.Strategies
19:23:40 <Drakioned> I looked at the page on Control.Parallel, and couldn't figure out what it did.
19:23:42 <Cale> let me find the paper you'll need to read to be able to understand that :)
19:24:31 <Drakioned> okay, because http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Parallel.html at the moment seems to be rather empty.
19:25:42 <Cale> http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html
19:26:31 <Cale> there was a nice pdf version somewhere...
19:26:59 <neadjneki> is it possible to terminate a computation explicitly with parallel?
19:27:21 <Cale> http://research.microsoft.com/Users/simonpj/Papers/strategies.ps.gz -- ah, there's a gzipped postscript
19:27:36 <Cale> neadjneki: probably not at the moment, but I'm not sure
19:27:46 <sh10151> Drakioned: parMap <strategy> (+1) [1,2,3,4]
19:27:48 <Drakioned> oh, I got that piece of code to run by the way, using listData <- newMVar [] rather than listData <- newEmptyMVar, but it doesn't seem to produce any results
19:27:54 <sh10151> where strategy looks like one of r0 and rwhnf
19:28:09 <Cale> neadjneki: well, you could rig something together with unsafePerformIO and the concurrency stuff
19:28:15 * dons reads Strategies.hs and boggles!
19:28:16 <dons> markStrat :: Int -> Strategy a -> Strategy a
19:28:16 <dons> markStrat n s x = unsafePerformPrimIO (
19:28:16 <dons>      _casm_ ``%r = set_sparkname(CurrentTSO, %0);'' n `thenPrimIO` \ z ->
19:28:16 <dons>      returnPrimIO (s x))
19:28:23 <sh10151> but that's just me browsing the module
19:28:28 <Drakioned> Cale -> yeah.. was kinda what I was going to do
19:28:40 <Cale> I think someone's done that
19:28:48 <Drakioned> sh10151 -> er.. what?
19:28:55 <Cale> I seem to recall some mailing list stuff...
19:29:09 <Drakioned> sh10151 -> you mean there's already a function like that?
19:29:18 <sh10151> Prelude Control.Parallel.Strategies> parMap rwhnf (+1) [1,2,3,4]
19:29:18 <sh10151> [2,3,4,5]
19:29:31 <sh10151> i'll let someone else explain how that parallelizes because I have no clue
19:29:32 <sh10151> :)
19:30:25 <Drakioned> that kinda makes my life a lot simpler
19:30:48 <Cale> Drakioned: the basic thing about seq and par is that the evaluation of (seq a b) evaluates a to WHNF then evaluates b (which is returned), and the evaluation of (par a b) causes evaluation of a and b to start simultaneously (and a will be evaluated to WHNF, and b's value returned)
19:31:24 <Cale> the strategies just wrap up various techniques for using seq and par
19:31:55 <Drakioned> umm. what's a WHNF?
19:31:57 <Cale> WHNF is called Weak Head Normal Form, and basically means that the top level constructors will be determined.
19:32:08 <Cale> s/is called/stands for/
19:32:25 <sh10151> so the question is, which to use, r0 or rwhnf? :)
19:32:50 <Cale> r0 is probably not what you want.
19:33:04 <Drakioned> well, how does r0 and rwhnf differ?
19:33:04 <Cale> rnf is actually more likely what's desired
19:33:09 <Cale> r0 does nothing
19:33:23 <Cale> rwhnf evaluates to weak head normal form
19:34:33 <Drakioned____> hmm
19:34:36 <Cale> A value of type (Strategy a) is a function a -> () which is a little bit impure in the sense that it might force the evaluation of its parameter before returning ()
19:34:46 <Drakioned> this wireless link is really starting to bug me
19:35:09 <Cale> r0 does nothing
19:35:10 <Cale> rwhnf evaluates to weak head normal form
19:35:15 <Cale> in case you missed that
19:35:32 * Cale hands Drakioned an ethernet cable
19:35:35 <Drakioned> okay, any reason why anyone would use rwhnf?
19:35:48 <Cale> often it's all you need, and it works for every type
19:35:56 <Cale> it's the default kind of evaluation
19:35:57 <Drakioned> er.. r0 rather
19:36:26 <Cale> r0 is there for when you're building up a more complicated strategy, and there's something you don't want to evaluate
19:36:36 <Drakioned> okay
19:37:10 <sh10151> so rwhnf will get you some parallelization but in theory you could specify a better one?
19:37:11 <Cale> http://research.microsoft.com/Users/simonpj/Papers/strategies.ps.gz -- I really recommend reading that
19:38:25 <Cale> Well,  mapList f xs = map f xs `using` (parList rwhnf)
19:38:29 <Cale> is probably what you want
19:38:39 <Cale> or possibly you're looking for
19:38:44 <Cale> Well,  mapList f xs = map f xs `using` (parList rnf)
19:39:07 <Cale> mapList is a terrible name ;)
19:39:58 <Cale> rnf will evaluate something as far as possible
19:40:10 <Cale> (recursing through the structure)
19:40:25 <Drakioned> okay, hang on
19:40:36 <Cale> but you need to make more instances of NFData if you want to apply it to new data types
19:41:13 <Drakioned> where's mapList under in the libraries?
19:41:19 <Drakioned> what's*
19:41:29 <Cale> I just defined it
19:41:40 <Cale> parList is in Strategies
19:41:43 <Drakioned> ah
19:41:52 <Cale> mapList would be better named mapPar
19:42:02 <Cale> or parMap
19:42:08 <Cale> oh
19:42:12 <Cale> hey, look at that :)
19:42:12 <Drakioned> well, I was going to call mine pMap
19:42:19 <Cale> it's in Strategies already :)
19:42:31 <Cale> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:43:16 <sh10151> I said that 10 minutes ago dude
19:43:17 <sh10151> :)
19:43:23 <sh10151> 15, even
19:43:25 <Cale> heh
19:43:39 <Drakioned> okay
19:44:07 <Drakioned> well, that's good, now to go through my program and write parMap everywhere..
19:44:10 <Cale> sh10151: sorry about that :)
19:44:44 <mcnster> anyone know why the ghc cvs repos is down?
19:44:58 <mcnster> ... its been a few days now
19:45:20 <Cale> Drakioned: I think that's pretty elegant, eh?
19:45:35 <Drakioned> oh yeah
19:46:21 <Cale> bbiab
19:52:48 <Drakioned> wahey, it works.
19:52:59 <sh10151> measurable speed improvement?
19:53:15 <Drakioned> no, I'm just surprised I got it to run..
19:54:39 <sh10151> run it through a stress test and time it
19:54:40 <sh10151> :)
19:55:46 <Drakioned____> sh -> you on Windows?
19:57:51 <sh10151> no
19:58:35 <Drakioned____> Linux?
20:06:54 <sh10151> no
20:07:32 <Drakioned____> okay, nvm then
20:07:36 <Cale> back
20:10:32 <Cale> Drakioned____: you might also try a strategy which evaluates pairs of elements in parallel, but otherwise evaluates the list sequentially.
20:11:23 <Cale> Drakioned____: or one which doesn't force evaluation of the rest of the list at all, but when one of the elements is being evaluated, the next is evaluated in parallel
20:12:03 <Drakioned____> well, the application is for an encryption program, wanted to split the file in two, encrypt them in seperate threads and then put them back together
20:14:16 <Drakioned____> although I suspect I may have to go back to the drawing board with that, since I just threw Jane Eyre at it for a test and it's gone and used up 233mb of ram..
20:14:42 <Cale> well, you're evaluating all the elements of the list in parallel
20:16:03 <Cale> you probably just want to split the file in two and do something like  encrypt firstPart `par` encrypt secondPart `seq` firstPart ++ secondPart
20:16:08 <Cale> er
20:16:31 <Cale> sorry :)
20:16:56 <Cale> you likely know what I mean by that :)
20:17:15 <Drakioned____> kinda
20:17:27 <Cale> let x = encrypt firstPart; y = encrypt secondPart in x `par` y `seq` (x ++ y)
20:17:43 <Cale> that's what I mean :)
20:17:58 <Cale> the other code just throws away the encrypted bits :)
20:18:05 <Drakioned____> heh
20:18:17 <Drakioned____> although it's an extremely inefficient program so I'm going to have to go back to the drawing board anyway
20:18:29 <Cale> well, try that strategy instead
20:19:02 <Drakioned____> will do next time.
20:19:06 <Cale> I think it's costing a lot because you're evaluating the entire file at once and can't garbage collect or reuse any space
20:20:22 <Drakioned____> well, it costing a lot of memory is okay at the moment, I just think the program will take like several hours to finish trying to encrypt anything more than like 50K..
20:22:09 <Drakioned____> Cale: are lists really as slow as people make them out to be compared to arrays?
20:22:58 <Cale> Drakioned____: it depends
20:23:12 <Cale> Lists are quite efficient and fast if used correctly
20:24:30 <Drakioned____> hang on, I'll post what I'm trying to do on the IRC paste page
20:25:06 <Cale> As far as efficiency is concerned, it's possibly best to think of lists like (possibly infinitely deep) stacks.
20:25:47 <Cale> Where you only have to compute elements on the stack when they get looked at :)
20:25:58 <Cale> (okay, I suppose the analogy is a little thin :)
20:26:29 <Cale> They're singly linked lists where rather than the rest of the list, it's possible to have a bit of code for computing the rest of the list.
20:27:10 <Drakioned____> you lost me on the infinitely deep stacks..
20:31:36 <Cale> hehe
20:32:15 <Cale> well, access to the first element of a list is pretty much about as fast as if the list wasn't there at all
20:32:29 <Cale> and you can add new elements to the start quickly
20:32:37 <Cale> lists can be infinitely long
20:32:39 <Drakioned____> ah, okay
20:33:55 <neadjneki> i wonder why print "a" `par` print "b" only prints "b"
20:34:16 <Cale> neadjneki: because a `par` b only returns b
20:34:32 <Cale> it just computes a in parallel, doesn't return its value
20:35:41 <neadjneki> shouldnt 'computing print "a"' mean printing "a" on the stdout?
20:35:45 <Cale> nope
20:35:58 <Cale> evaluating (print "a") doesn't do anything
20:36:06 <Cale> it just evaluates it into an IO action
20:36:11 <Cale> it doesn't run that IO action
20:36:29 <neadjneki> and how could i achieve that effect?
20:36:40 <Cale> unsafePerformIO
20:38:04 <Cale> (or Concurrency)
20:40:08 <Cale> Drakioned: the thing to watch out for in your programs (which accounts for a good deal of the efficiency problem with lists) are lists of type [(a,b)] used as association lists.
20:40:43 <Cale> In these cases it's almost always better to move to something like a Map
20:40:56 <Cale> or even an Array, depending on usage.
20:41:37 <Drakioned> hmm, methinks I need to go and read a lot more, since I have no idea what a map is..
20:41:44 <Cale> There are many different kinds of Arrays (and other data structures) in the hierarchical libraries, so it can be good to get familiar with them.
20:42:25 <Cale> A value of type (Map a b) is an association mapping between values of type a and values of type b, internally stored as a balanced tree.
20:43:31 <Cale> the type a has to be a member of the Ord class, since the algorithms make use of the ordering to build the tree.
20:44:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
20:44:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
20:44:20 <Cale> those are two libraries it's good to be familiar with
20:44:48 <Cale> If what you have is a finite map or a set, they're much more efficient than using lists.
20:46:05 <Drakioned> does a set allow for repeating elements?
20:46:10 <Cale> no
20:46:31 <Drakioned> hmm, didn't think so.
20:46:36 <Cale> it specifically means a mathematical finite set of elements -- but of course, in order to be efficient, it needs that ordering
20:48:26 <Drakioned> okay
20:50:05 <Cale> (and it's not optional)
20:55:59 <Drakioned> what's haskell.se and darcs?
20:58:26 <Cale> darcs is a revision control system written in Haskell
20:59:03 <Cale> #haskell.se is the swedish version of #haskell
20:59:40 <Drakioned> ah
22:53:49 <Cale> anyone recall the name of the proposed extension in which classes are allowed to have (abstract) datatype members, which may be different for each instance?
22:56:18 <Cale> ah, associated types
23:53:38 <luqui> is there some abstraction like Functor like: fmap2 :: (a -> b -> c) -> f a -> f b -> f c
