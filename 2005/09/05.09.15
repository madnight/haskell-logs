00:19:34 * gour is away: busy
00:46:43 <SickJacken> morning
00:46:43 <SickJacken> is there a nice tutorial/explanation of STRefs and STArrays?
00:46:43 <SickJacken> other than the GHC api docs
00:46:43 <SickJacken> ....is it a bit like this....instead of indexing in an array....we use STRefs to index the array...and we modify this reference to a new reference if we want to access another element
00:46:43 <Korollary> the wiki has an entry
00:46:59 <SickJacken> @wiki starray
00:46:59 <lambdabot> http://www.haskell.org/hawiki/starray
00:47:05 <SickJacken> hehehe
00:47:14 <SickJacken> @wiki bogus
00:47:15 <lambdabot> http://www.haskell.org/hawiki/bogus
00:55:18 <araujo> Reading about the data type system here, it is just like a fence :-]
01:24:29 <ski> SickJacken : http://www.haskell.org/hawiki/ImperativeHaskell
01:25:29 <ski> SickJacken : how'd you use STRef:s to index an array ?
01:27:42 <ski> araujo : fence ?
01:30:18 <SickJacken> pong
01:31:08 <SickJacken> ski, well i can relate to what araujo says i think...because i would often like a more high-level conceptual description about datatypes like STRef ....a bit more context so to say instead of just API
01:31:44 <SickJacken> but also about the connection with other datatypes
01:34:19 <Itkovian> meuning
01:36:27 <ski> ok
01:37:50 <ski> (SickJacken : any particular question, rn ?)
01:38:19 <Lemmih> dcoutts: ping.
01:41:58 <dblhelix> Itkovian: meuning
01:44:20 <SickJacken> ski, well i was reading that wiki page that uses STArrays, but i also thought it had to be used in conjunction with STRefs,...which is not the case....
01:44:47 <Cale> SickJacken: well, part of the point of the ST and IO monads is to hide some of what's really going on. That's not to say that it's not good to know sometimes, but the cool thing is that it can mostly be ignored.
01:44:58 <SickJacken> i wonder if Map String (STArray with Int as key and (Set String) as value) is more memory efficient than Map String (Map Int (Set String))
01:45:06 <SickJacken> there is a lot of modifying of the map going on
01:45:13 <Cale> If you really want to know about how ST works, there's a paper called Lazy functional state threads
01:45:40 <SickJacken> yeah maybe after my graduation project i will read it hehe
01:46:17 <Cale> I think the documentation would do well to include more asymptotic bounds on time (and perhaps memory)
01:46:34 <Cale> The Data.Set and Data.Map documentation is really good.
01:46:52 <Itkovian> @seen boegel
01:46:53 <lambdabot> boegel is in #haskell-blah and #haskell. Last spoke 1 hour, 4
01:46:53 <lambdabot> minutes and 16 seconds ago.
01:47:24 <Cale> But in order to evaluate efficiency, you sort of have to get used to the lazy evaluation order.
01:48:07 <dcoutts> Lemmih, pong
01:48:14 <Cale> and the efficiency of a data structure can vary widely depending on how you use it, of course, but it seems almost exaggerated by the lazy evaluation
01:48:21 <SickJacken> yeah, but i was thinking, since Map is immutable...and knowing that it gets changed a lot in my prog...probably a mutable datatype would be more memory efficient no?
01:48:21 <Cale> then again, this also has benefits :)
01:48:28 <dcoutts> aleator, pong
01:48:34 <Cale> Well, it could be :)
01:48:45 <Cale> Diff arrays are quite a nice structure
01:48:52 <SickJacken> hehe, thats my prob... a lot of things could be :D
01:48:53 <Cale> and don't involve any state monads
01:49:15 <Cale> If you're going to do lots of updates, try a Diff array
01:49:33 <Cale> it's always O(1) update if you use it in a single threaded fashion
01:49:34 <SickJacken> hey btw, if i use STArrays, can i add something to the underwater state? or would that require deeper knowledge about what gets hidden by using STArrays?
01:49:52 <Cale> Well, you're not allowed to touch the state directly with ST
01:50:21 <Cale> in fact, the type system prevents you from doing so
01:50:45 <SickJacken> Cale, in the Map String (Map Int (Set String)) the amount of elements in the inner map is constant....(like 2000) but its the Sets that get modified often
01:50:49 <SickJacken> adding, removing elements etc
01:51:11 <Cale> well, that's a complicated enough structure that you may consider writing a typeclass that embodies what you're doing with it
01:51:23 <Cale> and then you can just have two instances and test :)
01:51:38 <Cale> (or implement one, and if it causes problems, the switch is easy)
01:52:18 <Cale> but yeah, look into Diff arrays
01:52:19 <SickJacken> any recommendations of tutorials/guides that show me how to fit things in typeclasses *nicely*
01:52:25 <SickJacken> ok i will Cale
01:52:49 <Cale> they're sort of new and have somewhat magical efficiency properties :)
01:52:57 <SickJacken> :D
01:53:03 <SickJacken> alright, first coffee
01:53:04 <SickJacken> brb
01:53:15 <Cale> I'm going to bed anyway
01:53:17 <Cale> later
01:53:59 <Lemmih> dcoutts: How are we gonna integrate yi (or another editor) with the ideShell?
01:54:06 <Cale> as for classes, hmm... look at the Prelude, though it kind of messes some things up in my opinion :)
01:54:16 <Cale> It mostly gets them right
01:55:46 <dcoutts> Lemmih, well we're assuming that yi will get a gtk interface
01:56:23 <dcoutts> Lemmih, it is possible to embed a terminal in a widget so it would be possible to support vim/emacs/yi in text more
01:56:46 <dcoutts> Lemmih, and as an intermediate editor, the GtkSourceView has Haskell syntax highlighting
02:02:52 <dcoutts> Lemmih, I think we would do it by loading the yi app plugin, rather than running yi as a seperate process
02:03:11 <ski> (SickJacken : ok)
02:03:47 <dcoutts> Lemmih, we'd probably need a bit of glue code to hook yi into the ideShell
02:04:14 <Lemmih> dcoutts: So yi development is next on the hIDE ToDo list?
02:04:39 <dcoutts> Lemmih, possibly, my immediate concern is the ideShell
02:05:22 <dcoutts> Lemmih, using a simple GtkTextView/GtkSourceView would be the easeir initial test for an ideShell
02:06:15 <dcoutts> Lemmih, but it would be possible to look at how to get yi to load as a plugin within yi could go on in parallel
02:06:37 <dcoutts> plugin within yi/plugin within hIDE
02:06:59 <dcoutts> and look at developing the gtk interface to yi
02:09:15 <Itkovian> for hIDE, should I upgrade cabal?
02:12:37 <Lemmih> Yeah, or just change Hs-Source-Dirs to Hs-Source-Dir.
02:13:35 <dons> moin
02:14:00 <dcoutts> morning dons
02:14:28 <dcoutts> dons, so we were just talking about yi/hIDE/gtk
02:14:36 <dons> you could certainly load yi as a plugin in another app
02:14:42 <dons> it comes as a library, HSyi.o
02:14:52 <dons> load that, then call dynmain to start it up
02:15:08 <dons> this is essentially what the yi bootloader does, but the hide loader can do that instead, i think
02:15:19 <dons> (but this model isn't going to work for other editors, right?)
02:15:28 <dcoutts> dons, true
02:15:39 <dcoutts> others will have to work out of process
02:15:51 <dcoutts> and display in an embeded terminal widget
02:16:02 <dons> yi loads its own plugins as well. hmm
02:16:25 <dons> though i think this wouldn't be too hard, just adapt the Boot.hs file in Yi to your needs
02:16:29 <dcoutts> how does yi connect to the static core / plugin loader code?
02:16:48 <dons> Boot.hs is the static core. it imports System.Plugins
02:17:00 <dons> it consists of a short main function, that loads HSyi.o
02:17:05 <dons> back in a sec
02:17:11 <Itkovian> Lemmih: ok, thx
02:17:33 * dcoutts wonders if it's possible to make yi display in a terminal widget if it's running in-process
02:17:58 <dcoutts> as a temporary measure only of course, until yi gets a gtk gui
02:18:44 * dcoutts will be back in a sec
02:25:29 <dons> hmm. not sure. sounds tricky.
02:25:45 <dons> maybe forking an external editor is going to be easier in the long run
02:26:48 <dons> what's the relationship between hIDE and Yi?
02:27:00 * gour is back.
02:27:04 <dons> is Yi privledged somewhat?
02:27:11 <gour> that's a good question
02:27:25 <gour> is Yi supposed to be default editor?
02:27:31 <dons> how editor-indepednent is hIDE going to be?
02:27:45 <dons> or does it come with its own editor - Yi, with extra, fancy support?
02:27:52 <gour> or we want to be able to fire emacs/run/my_preffered_editor ?
02:28:16 <dons> perhaps there are certain things that will require having an editor source we can hack
02:28:25 <dons> and one written in Haskell -- even better
02:28:25 <SickJacken> vim
02:28:31 <Itkovian> I would love an IDE that allows me to plug in whatever editor I like using
02:28:59 <gour> and if we want some other editor, what hs-plugin-technology we can share/use ?
02:29:07 <Lemmih> Keeping features like auto-completion, type inference and pop-up documentation would be _really_ hard with arbitrary editors.
02:29:27 <dons> any other editor will have to run over a fork
02:29:54 <dons> Lemmih, right, so we want Yi as the first-class editor of hIDE
02:30:43 <dons> then I also don't waste time working on my own competing auto-completion (which yi already has) and so on
02:30:58 <gour> dons: and Yi should be able to emulate my_prefererred_editor?
02:31:09 <dons> right. that was its goal from the outset
02:31:19 <dons> it does vim well, emacs is getting there
02:31:24 <dons> but its a one man job atm
02:31:32 <dons> and that one man is also trying to do a phd
02:31:33 <gour> dons: that's make things easier & still satisfies wide range of users...
02:31:40 <dons> yeah
02:32:03 <gour> dons: your phd is based on Yi ;)
02:32:10 <dons> remember yi is/was supposed to be an editor *core*
02:32:15 <dons> hIDE is the rest of the show
02:32:20 <gour> :-)
02:32:30 <dons> gour, true true - but don't tell my supervisor
02:32:38 <dons> (though I think he might suspect by now)
02:32:39 <Lemmih> Someone wrote a wxWidgets frontend for yi, right?
02:32:44 * gour silent
02:32:52 <dons> Wolfgang hacked up one over a weekend
02:33:05 <Lemmih> Is the code online?
02:33:18 <dons> which revealed what has to be changed in the ui model - where i've encoded assumptions about having a terminal, fixed-char interface
02:33:22 <dons> no code
02:33:30 <dons> we could ask though
02:33:48 <SickJacken> wtf
02:33:50 <dons> though someone who knows gtk well could probably reach the same point pretty quickly
02:34:01 <SickJacken> i have a cd that is not known by freedb...
02:34:02 <SickJacken> sick
02:34:23 <rep> impossible
02:35:21 <SickJacken> its true, i have searched the freedb.org site...i never owned a cd that werent in freedb
02:35:45 <musasabi> @seen JohnMeacham
02:35:45 <lambdabot> I saw JohnMeacham leaving #haskell 2 days, 6 hours, 45 minutes and 8
02:35:45 <lambdabot> seconds ago.
02:37:38 <Lemmih> dons: How big are the required changes?
02:46:46 <basti_> hi
02:49:21 <dons> hmm. couple of hundred lines?
02:49:33 <dons> in the hands of someone who knows gtk and yi well
02:49:40 <dons> unfortunately, i know yi, but not gtk
02:49:43 <dcoutts> dons, yes yi should be the internal first class editor which all the wizzy features will be basd on
02:49:55 <dons> ok. so the yi vision will be realised
02:49:58 <dcoutts> other editors running out of process will get second class support
02:50:10 <dons> (an editor core that we hack and extend)
02:50:11 <dcoutts> since we can't support all the other stuff
02:50:16 <dons> right.
02:50:21 <dcoutts> since it'd have to be written in elisp or whatever
02:50:25 <dons> and why bother! we have our own gpl/haskell editor!
02:50:26 <gour> one thing is clear, great!
02:50:30 <dcoutts> while we want to do this stuff in Haskell
02:51:05 <dcoutts> dons, so one question is how much should yi know about hIDE?
02:51:16 <dcoutts> or perhaps only the gtk front end to yi knows about hIDE
02:51:56 <dcoutts> can we structure it to get realy good integration and still allow yi to run as a standalone console app?
02:52:06 <rep> anyone use xfs here?
02:52:10 <dons> I think so, dcoutts
02:52:22 <dons> by loading yi as a library, we can call whatever we want internally
02:52:30 <dcoutts> yes
02:52:31 <dons> hIDE could even manage its own ui
02:52:33 <Lemmih> Wouldn't the gtk yi-frontend be a widget like gtkSourceView?
02:52:38 <rep> if so: what's the default xfs block size?
02:52:45 <dcoutts> Lemmih, yes I think so
02:53:17 <dons> coudl yi run as a standalone gtk app?
02:53:24 <dcoutts> dons, so we load yi into hIDE, can we then load a plugin that knows about yi and the gtk ideShell
02:53:41 <dons> i don't see why not
02:54:11 <dcoutts> dons, possibly, but Is supect it'd be easier to have seperate front ends in that case, the gtk standalone UI and the hide/yi integration front end
02:54:20 <dons> the good thing with loading yi is that any extensions/wizbangeries can be called directly, and don't affect the standalone yi, unless we make it so
02:54:29 <dcoutts> yes
02:55:02 <dons> ok. maybe gtk-yi will actually be yi+hIDE
02:55:15 <dcoutts> dons, that's what I was thinking
02:55:20 <dons> sounds good
02:55:54 <dcoutts> so the gtk front end will depend on the hIDE gtk shell plugin
02:56:13 <dcoutts> that still gives us an acyclic package/plugin graph
02:57:17 * aleator thinks that would name it yiDE..
02:57:33 <dons> ah!
02:57:40 <dons> @karma+ aleator
02:57:40 <lambdabot> aleator's karma raised to 1.
02:57:57 <dons> dcoutts, why is it acyclic?
02:58:21 <bourbaki> moin
02:59:01 <dcoutts> aleator, add that name to the name contest on the hIDE wiki page!
02:59:04 <dcoutts> @where hIDE
02:59:05 <lambdabot> http://www.haskell.org/hawiki/hIDE
03:00:19 <dons> also, one point springs to mind, we should be able to build hIDE as a static glob too
03:00:40 <dons> riot, yi and lambdabot can all have their plugins statically linked
03:00:49 <dons> this is critical for *profiling*
03:00:55 <dons> which doesn't work when plugins are loaded
03:01:08 <dons> (we can't currently load profiled plugins)
03:01:17 <dcoutts> sure I don't see any reason that feature would be lost
03:01:34 <dons> nope. they aren't. it's just linker tricks
03:02:02 <dons> instead of having the bootloader load the dynamic main, you write a Main.hs that does a normal import of the entry module
03:02:09 <dons> so the whole thing gets statically linked
03:02:21 <dcoutts> yes
03:02:35 <dcoutts> you just need to know exaclt which plugins you were going to load
03:02:49 <dcoutts> dons, it's acyclic because: yi deps on nothing (but it's own external deps) and the yi/hIDE/gtk front end depends on yi and the ideShell component
03:03:27 <dcoutts> presumably yi front ends have to register themselves with the yi core?
03:03:50 <dons> front end as in keybindings? or as in user interfaces?
03:03:55 <dcoutts> UIs
03:04:19 * dcoutts will try to use UI so as to be less ambiguous
03:04:39 <dons> as Yi only has one UI there isn't a registration process
03:04:40 <dcoutts> and you select the UI by just loading the right UI plugin?
03:04:48 <dons> but there should be
03:04:53 <dcoutts> ok, how did the wx UI work?
03:05:15 <dons> I think he rewrote the module improrts. so instead of Yi.Curses.UI it imported Yi.Wx.UI
03:05:21 <dcoutts> so it wasn't selectable at runtime then, ok
03:05:23 <aleator> What is yi anyway?
03:05:23 <dons> should be hard to register the ui properly
03:05:28 <dons> back in a sec
03:05:36 <manulito_> im a beginner in haskell, having problem with a do statment, errormsg + code @ http://pastebin.com/364396
03:05:40 <manulito_> anyone got time to help?
03:06:00 <dcoutts> aleator, it's an editor written and extensable in Haskell
03:06:26 <aleator> dcoutts: Yes. That i know. But why is it?
03:06:49 <aleator> What's the killer feature?
03:07:26 <dcoutts> allowing advanced features to be implemnted in Haskell
03:07:36 <manulito_> it says "smee.hs:12: The last statement in a 'do' construct must be an expression"
03:07:38 <Lemmih> manulito_: 'return' is just a function, and you shouldn't use it in this case.
03:08:05 <dcoutts> aleator, eg language aware highliting and editing
03:08:09 <Lemmih> @eval (return 10 :: Maybe Int)
03:08:14 <lambdabot> Just 10
03:08:22 <Lemmih> @eval (fail "urk" :: Maybe Int)
03:08:23 <lambdabot> Nothing
03:08:53 <aleator> dcoutts: ah. Perhaps I'll go read it instead of asking. :)
03:08:58 <manulito_> Lemmih: ok
03:09:14 <dcoutts> aleator, but those things aren't there yet, it's still just a potential
03:09:43 <dcoutts> aleator, but you can see why we might want an editor extensable in Haskell for an IDE that's extensable in Haskell
03:09:45 <dons> killer feature is that it is dynamically extensible in statically typed haskell
03:09:50 <dons> it's the only such ap, afaik
03:10:01 <manulito_> im really new to this, didnt understand all, so i should change "else return Nothing" to "else Nothing" ?
03:10:14 <kosmikus> manulito_: seems to me like you shouldn't use "do" at all
03:10:37 <manulito_> might be right, tho my brain keeps thinking like c++ =( only had a few days of haskell
03:10:47 <dcoutts> manulito_, yes you probably don't want the do, and you let ret = ... *in*
03:10:56 <dcoutts> you/use
03:11:47 <dcoutts> manulito_, inside a 'do' you can leave off the 'in' part of the 'let', since you're removing the 'do', you'll need to add the 'in' part back in
03:12:02 <manulito_> ok, think im in over my head
03:12:06 <manulito_> =)
03:12:07 <dcoutts> ie:
03:12:09 <dcoutts> let ret = (matchUntil (head ps) str)
03:12:21 <dcoutts>  in if length ret > 0
03:12:25 <dcoutts>    ... etc
03:13:15 <dcoutts> manulito_, the 'do' is for "monadic" style code which you probably wont meet until later in your course
03:14:23 <Lemmih> dons, dcoutts: While IRC is good for throwing in ideas, please write conclusions on the wiki.
03:14:38 <manulito_> okey, thanks
03:15:04 <manulito_> ill try to continue with the "in" thing, tho i never seen it before, gonna read some more =)
03:15:13 <dcoutts> Lemmih, yes you're quite right
03:15:45 <dcoutts> Lemmih, you can write down conclusions too :-)
03:15:54 * dcoutts goes to look at the wiki
03:16:21 <dcoutts> Lemmih, so we have the whole "design document" part missing so far
03:16:42 <dcoutts> we've got plenty on motivation & on some of the interesting general questions
03:17:01 <dcoutts> do you think a seperate page would be appropriate here?
03:17:15 <dcoutts> how do you add 'sub pages' in the wiki?
03:17:25 <dcoutts> @where hIDE
03:17:26 <lambdabot> http://www.haskell.org/hawiki/hIDE
03:17:32 <aleator> The hIDE page is already a bit cumbersome so you could split it up a bit..
03:17:52 <dcoutts> yeah
03:18:03 <aleator> http://www.haskell.org/hawiki/HelpOnEditing_2fSubPages
03:18:09 <dcoutts> ah, ta
03:19:02 <aleator> Though I think wiki engines ought to just know when a page is a subpage when there is a link..
03:19:33 * dcoutts starts editing http://www.haskell.org/hawiki/hIDE/Design
03:28:27 <Lemmih_> haskell.org is down?
03:28:42 <z0d> Lemmih_: works for me
03:28:56 <tromp> it's up
03:38:21 <dcoutts> Lemmih, ok there's a new page up and linked from the main hIDE page
03:38:28 <dcoutts> with  some category headers
03:38:42 <uHaul> how can i make a quadtree?
03:38:50 <dcoutts> Lemmih, I've noted the plugin == cabal package decision
03:41:21 <ulol> how can i build a binary tree
03:43:09 * dcoutts notes that the hawiki has email notification support turned off
03:43:27 * dcoutts thinks that is unfortunate
03:43:51 <ulol> dcoutts: do you know how to 'build' a binary tree?
03:43:55 * ulol thinks
03:44:51 <dcoutts> ulol, you mean how to design the data type / data structure, or how to actually build an instance of a binary tree once you've got the data type done?
03:45:00 <ulol> and instance
03:45:03 <ulol> *an
03:45:37 <dcoutts> well what does your data type definition look like then?
03:45:57 <ulol> data Tree = Leaf|Fork Tree Tree
03:46:39 <dcoutts> ok, so the simplest tree is going to be just "Leaf" right?
03:46:50 <ulol> yeah
03:47:03 <dcoutts> and a slightly more complicated one will be: Fork (Fork Leaf Leaf) Leaf
03:47:22 <ulol> yeah
03:47:27 <ulol> A fork has 2 leaves
03:47:34 <dcoutts> so you can just write one down like that, however you're probably trying to build one from some initial set of data?
03:48:03 <ulol> yeah, from some data
03:48:06 <dcoutts> more specificaly a fork has 2 subtrees
03:48:22 <dcoutts> and such a subtree might be a Leaf
03:48:23 <ulol> or just Trees
03:48:27 <dcoutts> right
03:49:08 <ulol> if it has a Leaf it is a Tree :)
03:49:37 <ulol> having trouble writing a function to build one though
03:49:40 <dcoutts> so what kind of tree are you tring to build? or what kind of data are you starting with?
03:51:23 <ulol> i _actually want to build a 'quad tree' but a binary tree should be a good start..
03:51:47 <ulol> data would be a string representation of the tree
03:51:51 <dcoutts> but I don't know what data you're starting with, is it a list?
03:52:11 <uLaul> a list of Chars
03:52:32 <dcoutts> and at the moment your tree can't actually contain any data because you've no where to put it in your tree
03:52:40 <dcoutts> data Tree = Leaf|Fork Tree Tree
03:52:51 <dcoutts> see, there is no Char in there
03:53:12 <cbus> yawn *hopes the lab is working*
03:53:14 <dcoutts> where in your tree to you intend to put the Chars ?
03:53:22 <dcoutts> the leaves? the forks?
03:54:10 <ulol> umm in either
03:54:20 <ulol> im not sure i understand
03:54:41 <Blownose> if i have a statement like this  | (x==k) =  and then i want two new if statement how do i do that =
03:54:42 <Blownose> ?
03:54:53 <cbus> may i spam?
03:54:55 <cbus> im a bit happy ;)
03:55:05 <cbus> [cbus@braindead ~/algo/lab1/src]$ time ./a.out data/tsp38.txt 8
03:55:06 <cbus> lab3 473 [1,4,6,8,3,2,5,7]
03:55:06 <cbus> real    0m36.259s
03:55:06 <cbus> user    0m27.011s
03:55:06 <cbus> sys     0m4.294s
03:55:08 <cbus> finally!
03:55:23 <ulol> good work cbus
03:55:37 <int-e> Blownose: it's not a statement. | (x==k) is a guard. normally if expressions look like this:   if condition then value-true else value-false
03:55:45 <cbus> ulol, bruteforce travelling salesman :)
03:56:45 <ulol> oh nice
03:56:46 <Blownose> int_e: ok so i do like this       |(x==k) = if(xs==ys) then ?
03:57:13 <int-e> Blownose: you have to add an else to that, but yes.
03:57:26 <dcoutts> ulol, well suppose you want to store Chars in the leafes of your binary tree, then we would modify the data declaration
03:57:36 <dcoutts> instead of:
03:57:37 <dcoutts> data Tree = Leaf|Fork Tree Tree
03:57:40 <dcoutts> we'd have:
03:57:46 <dcoutts> data Tree = Leaf Char | Fork Tree Tree
03:57:50 <dcoutts> see?
03:58:05 <dcoutts> and if you wanted it in the Forks then you could do:
03:58:09 <ulol> ok yes
03:58:14 <dcoutts> data Tree = Leaf | Fork Char Tree Tree
03:58:48 <ul0l> u get it ulol?
03:58:56 <dcoutts> eg: Fork (Fork (Leaf 'f') (Leaf 'o')) (Leaf 'o')
03:59:30 <ul0l> ulol: we have to recurse over the input so i dunno how to do ^^^
04:00:37 <ulol> hmmm
04:00:51 <ulol> thanks dcoutts
04:00:57 <dcoutts> it depends on what the tree is supposed to look like, eg is it supposed to be sorted
04:01:01 <dcoutts> or balanced
04:01:12 <ul0l> there is an order to it
04:01:43 <dcoutts> ok, so you're using it like a set?
04:02:08 <dcoutts> to insert and retieve chars with log time
04:02:20 <ul0l> a set is unordered though isn't it
04:02:52 <dcoutts> yes, but the implementation useally uses an ordered structure of some kind, like a tree
04:03:22 <ul0l> ok
04:04:46 <ulol> the leafs on the tree will have a Int value
04:05:04 <ulol> depending on which level they are on
04:05:14 <dcoutts> ok
04:05:21 <aleator> dcoutts: Just for fun: http://www.cc.jyu.fi/~aleator/yide.png
04:05:46 <dcoutts> aleator, ah, this is the outline mode thing?
04:06:24 <aleator> Some weird vision to that direction..
04:06:29 <dcoutts> aleator, add a link from the wiki, probably the UI design section
04:06:48 <dcoutts> aleator, nice mockup :-)
04:07:35 <dcoutts> I like the "no useless buttons" thing :-)
04:07:52 <Lemmih_> So many ideas, so few developers. /-:
04:08:29 <dcoutts> I agree that the top level toolbar is a bit... odd for a UI with many selectable pages
04:08:40 <dcoutts> Lemmih_, heh indeed
04:09:11 <dcoutts> Lemmih_, well hopefully with a working shell we can pull in more contributors
04:09:33 <Lemmih_> Working shell?
04:09:35 * dcoutts looks about for people interested in working on the hIDE core components
04:09:58 <dcoutts> Lemmih_, a working shell is a milestone we've not got to yet :-)
04:10:05 * SlowByte just "got" monads
04:10:19 * dcoutts congratulates SlowByte 
04:10:23 <SlowByte> read the "Tackling the Awkward Squad" paper. just great. had to come and announce :)
04:10:28 <Lemmih_> Define 'working shell'. Shell with yi plugin?
04:10:49 <cbus> yawn i hate waiting for numbercrunching
04:11:07 <dcoutts> Lemmih_, the shell is just the bit that the editor plugs into
04:11:33 <dcoutts> Lemmih_, the shell has the top level window and contains the views, like the file views
04:11:42 <Lemmih_> dcoutts: Isn't it working now? It could just use some more hooks.
04:12:13 <dcoutts> Lemmih_, there's more stuff to do to make the files tree view actually work
04:12:42 <dcoutts> Lemmih_, but you could stick a yi gui in there now, without the file browsing features
04:13:10 <dcoutts> but yi has no gtk ui yet
04:13:42 <dcoutts> dons reckons that's easy since the wx one didn't take long
04:14:03 <dcoutts> if it does take longer, we could use the console UI in a terminal widget in the meantime
04:14:45 <dcoutts> Lemmih_, do you want to document the bootup sequence in the hIDE/Design wiki page?
04:15:47 <Lemmih_> Making the gtk frontend right would probably be non-trivial.
04:15:57 <dcoutts> that's what I thought too
04:16:14 <cbus> oops
04:16:14 <cbus> 11270 algo-3    25   0 1601M 1.2G   328 R    98.8 62.7   6:42   0 a.out
04:16:15 <cbus> ;)
04:19:15 <ul0l> dcoutts, trees look easy if u know what data to put in them and if u know the structure of the tree, what if the structure and date inside the tree depends on the different input?
04:19:20 <Lemmih_> I can't comprehend how the various yi modes should interact with gtk /-:
04:19:56 <gour> dcoutts: since hIDE is a bigger project, what do you think about putting it under Trac, i.e. integrated wiki, tickets, browsing source..?
04:20:07 <gour> dcoutts: maybe on haskell.org
04:20:23 * dcoutts drowns under piles of questions
04:20:47 * gour gour patiently waits
04:21:07 <dcoutts> ulol, eg a common on is to build a order tree from unorded data
04:21:45 <Lemmih_> gour: What's Trac?
04:21:59 <dcoutts> ul0l, in which case you'd want an insert function that can add an item to the tree preserving the sorted proerty of the tree
04:22:02 <gour> http://projects.edgewall.com/trac
04:22:33 <dcoutts> Lemmih_, yeah, I'm not sure either
04:22:49 <gour> it has darcs backend written by tailor's author
04:22:52 <dcoutts> Lemmih_, for example? what modes are there?
04:22:58 <ul0l> hm
04:24:04 <dcoutts> Lemmih_, I wonder how much of the yi UI concepts might need to be adapted to fit a GUI nicely
04:24:23 <dcoutts> we should ask dons how he imagines it
04:24:26 <Lemmih_> gour: Trac looks great.
04:24:44 <gour> Lemmih_: i like it - it's simple enough
04:25:02 <gour> dcoutts: now it's time to make right choices for Yi
04:25:19 <dcoutts> gour, you mean UI-wise?
04:25:30 <gour> Lemmih_: and upcoming 0.9 has webadmin
04:25:42 <gour> dcoutts: right
04:25:50 <Lemmih_> gour: Can you setup Trac on hsakell.org/hide/, or something?
04:26:20 <gour> Lemmih_: i can try
04:26:30 <Lemmih_> gour: I have no idea what webadmin is (:
04:27:18 <gour> Lemmih_: webadmin means you can admin trac'c project web-interface instead of invoking cli
04:27:20 <Lemmih_> dons: How do you imagine it?
04:27:57 * dcoutts wonders if modes in an editor work better for a consol UI
04:28:45 <dcoutts> while GUI editors more commonly use dialogs or other frames in place of modes
04:28:56 <SickJacken> hmmm
04:28:57 <dcoutts> (I think)
04:29:52 <Lemmih_> dcoutts: I was thinking about modes as in vim or emacs mode.
04:30:03 <SickJacken> would changing the outer map in 'Map Int (Map String (Set String))' into an STArray result in noticeable memory gain?
04:30:39 <gour> Lemmih_: python on haskell.org is too old - Trac reqs >= 2.3 (I installed 2.4.x under my home dir to serve gtk2hs mirror)
04:31:26 <dcoutts> Lemmih_, I use vim a bit, but mostly GUI editors, I'm less familiar with the modes concept, can you give an examle
04:31:30 <gour> Lemmih-: plus few more packages are required, e.g. clearsilver, sqlite..
04:31:57 <Itkovian> SickJacken: didn't you ask this yesterday?
04:32:02 <gour> dcoutts: insert mode, visual mode, command mode - vim
04:32:46 <SickJacken> no
04:32:53 <SickJacken> Itkovian, the datastructure changed
04:33:06 <Itkovian> ah, ok
04:33:12 <Lemmih_> SickJacken: Depends on how you use the data structure.
04:33:19 <SickJacken> i thought it was 'Map String (Map Int (Set String)' with at least a 100 outer elements and always 2000 inner
04:34:01 <SickJacken> the case is however, that the outer map has a constant amount of elements and the inner map is subject to change quite frequently, either removing keys from the map or changing Sets that are stored in the inner map
04:35:13 <musasabi> SickJacken: sounds like the inner map should be made an array.
04:35:30 <musasabi> also strictness might be important.
04:35:52 <SickJacken> the inner map does have strings as keys....
04:36:33 <SickJacken> and musasabi, with strictness here you mean forcing the evaluation of the strings?
04:37:46 <musasabi> You don't want a large frequently changing Map.
04:38:12 <SickJacken> i can grasp that, because of the immutable nature of Map right?
04:38:22 <dcoutts> dons, how did the wx Yi UI manage the modes issue?
04:39:38 <beelsebob_> why do people on yahoo chess ask for a draw when you're one move from checkmating them?????
04:39:52 <beelsebob_> like anyone's going to accept!
04:39:57 <dcoutts> because they're bad loosers?
04:40:27 <beelsebob_> something like that
04:40:36 <tromp> they're being polite, and refrain from asking you to resign:)
04:40:41 <beelsebob_> they then told me I was a twat for turning it down
04:40:53 <Itkovian> beelsebob_: of course you are!
04:41:04 <beelsebob_> hehe... their rating was 700 above mine!
04:41:22 <Itkovian> no wonder
04:41:25 <Itkovian> they never lose
04:41:34 <beelsebob_> heh, indeed... *g*
04:41:43 <tromp> they know the fact you even play on yahoo means you're a sucker for abuse:(
04:41:48 <beelsebob_> true
04:41:52 <beelsebob_> but yahoo is free
04:42:06 <tromp> is there no good free chess server?
04:42:11 <beelsebob_> to be fair... I did take a hammering yesterday, and lost about 600 ranking points, so I'm well below my norm
04:42:16 <beelsebob_> not that I've found
04:42:22 <Itkovian> I can't strech my legs under this desk. grr.
04:42:23 <beelsebob_> most want a subscription
04:42:35 <tromp> you can always switch to playing Go :_)
04:42:49 <beelsebob_> I can't play go... it hurts my head
04:42:59 <beelsebob_> I can't see where the patern starts to emerge
04:43:20 <tromp> that comes automatically if you play a few hundred games
04:43:25 <tromp> start small, at 9x9
04:43:48 <beelsebob_> hmmm, maybe... at the moment, I'm very involved with chess playing
04:43:50 <manulito_> myfunc (Just x) _ = Just x, what does the _ mean?
04:44:08 <beelsebob_> it means there's a second argument that you're ignoring
04:44:11 <tromp> _ means an unused argument
04:44:15 <beelsebob_> you don't care what it looks like
04:44:29 <beelsebob_> my entire house plays chess... got a mini ladder going
04:46:56 <Itkovian> tromp: any free go servers?
04:50:17 <psi> Itkovian: yes. kgs is one.
04:50:59 <psi> they have a nice client, written in java
04:51:15 <Itkovian> ah java.
04:51:34 <Itkovian> I should learn the game first though, I know the basic principles ... but that's it.
04:51:47 <Itkovian> anybody here playing gipf?
04:55:10 <beelsebob_> nice client and java in general don't mix
04:55:19 <edwinb> everyone should play go ;)
04:57:52 <tromp> many free go servers
04:58:25 <tromp> in fact, i don't know any requiring subscription
04:58:59 <tromp> although kgs offers extra features like pro lectures at cost
05:00:30 <ski> manulito_ : if you want, you can change 'orElse' into 'mplus' (in module Monad) (it's the same, for the Maybe Monad)
05:01:53 <ski> manulito_ : also, if you do so, it'd look nicest to change 'Nothing' to 'mzero', too (in same module)
05:02:36 <ski> SlowByte : nice
05:09:25 <humasect> i can't seem to find the repo for SDLhead
05:10:46 <humasect> ok got ot.
05:17:59 <manulito_> ski: thanks, tho the assinment says we should use Maybe =(
05:17:59 <manulito_> if i got a function, that i need to deliver Nothing, if first arguments are, Just(emptystring) Maybe a, how should i define that?
05:17:59 <manulito_> or arguments are
05:17:59 <ski> manulito_ : you'd still use Maybe, even if you change 'orElse' to 'mplus' and 'Nothing' to 'mfail'
05:17:59 <manulito_> ok
05:17:59 <ski> could you rephrase that question ?
05:18:00 <ski> does you function have 2 or 1 arguments ?
05:19:17 <manulito_> it worked out, i understood how to declare what i wanted, wanted this "myfunc Nothing b = b"
05:19:48 <ski> 'orElse' ?
05:20:21 * boegel reads the 'Functional vs imperative' thread with great interest
05:20:54 * aleator elaborates his weird haskell ide vision at http://www.haskell.org/hawiki/hIDE
05:23:03 <dcoutts> aleator, to get a link instead of a pic use [http://blah/thing.png "link name"]
05:23:21 <dcoutts> I don't mind having the big pic there though
05:23:33 <dcoutts> I changed my one to put the pic inline too
05:24:39 * boegel wonders when the hell shapr is finally going to finish FLM
05:25:22 <rep> FLM?
05:26:04 <ProfTeggy> G'day all.
05:26:08 <kosmikus> fermat's last margin, iirc
05:27:46 <dblhelix> kosmikus: you remember correctly
05:27:58 <aleator> dcoutts: Still feel that the outline solution is too far off for ordinary people?
05:29:32 <gour> aleator: it's interesting, i played a bit with leo one year ago
05:30:09 * ski thinks whether IO being side-effectful or not is just a matter of pov
05:30:16 <gour> aleator: haskell is not (yet) for ordinary people :-)
05:30:33 <boegel> hey ProfTeggy
05:31:10 <aleator> gour: I said that yesterday.. Then someone said "plugs!"
05:31:40 <aleator>  - l
05:32:46 <gour> aleator: but we want it to become
05:32:50 <dcoutts> aleator, I'm not sure yet really, especially about the outline within a single module idea
05:33:25 <dcoutts> I think the "one editor file for a single module" UI is pretty ingrained
05:33:56 <dcoutts> that's not to say that discovering or imposing more structure on the module is impossile or undesirable
05:34:17 <dcoutts> but the 100% tree/node outline thing is rather radical
05:34:52 <gour> i agree
05:35:26 <aleator> Well.. You decide, I wish just to provide ideas..
05:35:28 <aleator> :)
05:38:11 <dcoutts> It should be easy to add views to left hand pane, so a node view like you describe should be possible
05:38:42 <dcoutts> and you can make the main editor pane splitable
05:40:30 <dcoutts> aleator, the ideShell interface should not make sush an UI style impossible so anyome is welcome to try it out
05:43:56 <aleator> dcoutts: When you get enough far, I'll try to find time to try..
05:44:03 <dcoutts> aleator, ok
05:44:31 <musasabi> Also many apps use things like cpp making tree views harder.
05:44:53 <dcoutts> musasabi, you mean because it makes them harder to parse?
05:45:22 <beelsebob_> how does C++ make tree views harder?
05:45:25 <CosmicRay> autrijus: awesome interview at perl.com
05:45:32 <CosmicRay> metaperl: thanks for linking to the awesome interview ;-)
05:45:32 <musasabi> dcoutts: yes, and the structure might not be there (think #ifdefs and #defines)
05:45:40 <dcoutts> musasabi, yes
05:45:44 * CosmicRay notes this for HWN
05:45:54 <metaperl> sure, it certainly was hot
05:46:01 <humasect> are people using haste here?
05:46:10 <dons> Lemmih, dcoutts, modes don't have anything to do with uis. they're a term describing separate lexers that may be switched between. lexers are mappings from char input to editor actions, and you can swap these mappings dynamically. this is what a mode is
05:46:54 <dons> all editors are moded to some extent
05:47:02 <dons> emacs has sub modes, i.e. M-x
05:47:39 <dons> so,  in summary, these modes should just work
05:47:44 <dcoutts> dons, but eg search is done as a mode in vim but some other UI thing in a GUI editor
05:48:14 <dons> ah, the line editing stuff?
05:48:24 * dcoutts is not saying that search must popup a little dialog since that is not great UI either
05:48:42 <dons> ok, that's really about a speciific mode's design
05:48:48 <dcoutts> ok
05:49:03 <dons> some such modes may be predicated on having, e.g. an editable msg buffer to write to
05:49:08 * musasabi notes that several apps like firefox and opera have integrated the "/phrase"-searching in addition to the search dialog.
05:49:11 <dcoutts> so would we support arbitrary modes or is it related to the UI in use?
05:49:35 <dcoutts> musasabi, yes and it's better there, gedit is doing the same thing
05:49:51 <dons> we would support arbitrary modes, they're unrelated to the ui
05:49:55 <dcoutts> musasabi, eg a find toolbar or sidebar/bottom bar
05:49:59 <dcoutts> dons, ok
05:50:31 <dcoutts> musasabi, oh actaully we're talking about slightly different things
05:51:50 <boegel> @type (~~)
05:51:54 <lambdabot> bzzt
05:51:58 <dcoutts> dons, right so if we've got the hIDE internal editor in vim emulation mode then we get vim style searching
05:52:33 <boegel> " ... hamming ~~ map ... " -> this is from the autrijus article, what is it ? I've never seen it before
05:52:39 <dcoutts> dons, and if someone wrote a Gnome/HIG GUI editor mode then we might have searching done by some other UI style?
05:52:48 <boegel> A user-defined lexical operator "~~" makes it more readable. -> okay, nvm :)
05:52:53 <dons> yep
05:53:14 <dcoutts> dons, I don't think I fully understand what the yi lexers are cabable of
05:53:26 <dons> the search mode would just be bound to a different set of core operations
05:53:37 <dcoutts> they lex the incomming stream of keystrokes from the user and take appropriate actions?
05:53:59 <dons> they generate a lazy list of actions, whiich are evauated as they arrive
05:54:08 <dcoutts> ok
05:54:36 <dons> really, the lexer itself is isomorphic to a Map Char Action, where Action == IO ()
05:54:43 <dcoutts> ok
05:55:01 <dons> when you run the lexer, the stream of input is applied to this map, generated the set of actions bound to the input sequence
05:55:19 <dcoutts> so in a hIDE preferences dialog somewhere we'd have a thing for selecting the users' preferred editor emulation mode, and that would switch the yi lexer
05:55:33 <dons> yep. sounds easy and convenient
05:55:41 <dcoutts> ok, nice
05:55:54 <dons> currently this is done using the --as= cmd line flag. a menu option is just as simple
05:56:13 <dons> the current mode is a component of the global state, and maybe be changed at will
05:56:19 <dcoutts> right
05:57:04 <CosmicRay> when autrijus says "Indeed, you can ask a bot on #haskell to turn programs to its most abstracted form for you.", what exact command is he referring to?
05:57:14 * dcoutts wonders how to map gtk+ style keybindsings into the stream of chars for consumption by the yi command lexer
05:57:20 <dons> @pl \x -> x + x
05:57:21 <lambdabot> join (+)
05:57:48 <dons> the pl or pointless command, implemented in the Pl plugin
05:58:55 <boegel> @eval join (+) 5
05:58:58 <lambdabot> 10
05:59:02 <dcoutts> dons, I imaginge a slight conflict between the keybindings that the yi editor will want to control and ones that other UI elements might have bound
05:59:12 * boegel likes the way autrijus sell Haskell to the Perl people
05:59:32 <dons> hmm. dcoutts, yes, perhaps
05:59:40 <dcoutts> yi is used to having complete control over the keyboard input
05:59:48 <dons> yi assumes it runs everything
05:59:59 <dons> though any char it never sees, it doesn't know about
06:00:14 <dons> so as long as only input chars get passed to it, then yi should be ok
06:00:17 <dcoutts> sure so you could overried things
06:00:44 <dcoutts> but yi will want to see many ctl+key combinations
06:01:06 <dons> well, the emacs mode surely does, yes
06:01:19 <boegel> CosmicRay: yaay for posting it on haskell@haskell.org
06:01:24 <dcoutts> So we'd want to pass anything that had not already been stolen by other UI elements
06:01:45 <dcoutts> or have those UI elements inject command into the yi input stream
06:01:58 <dons> either would be possible
06:01:58 <CosmicRay> boegel: :-)
06:02:16 <dcoutts> eg ctl+s might activate a button on a toolbar which just puts something into the yi control stream
06:02:30 <dons> yep. that would be fine
06:03:27 <dcoutts> dons, though we might need some actions to be done less conditionally on the current command lexer, eg saving a file
06:03:46 <dons> right, can be done entirely independently
06:03:49 <dcoutts> ok
06:03:58 <dons> just call Core.write, or whatever
06:04:04 <dcoutts> right yes
06:04:29 <dons> that's all that say ":wq" is going to produce anyway, a lazy list containing the value 'Core.write' which gets forced eventually
06:04:49 <dons> ":w" i mean.
06:06:31 <dcoutts> though it depends on the lexer state, eg in vim it'd need to be <esc>:w
06:06:52 <dcoutts> but yes, it sounds ok
06:07:36 <dons> ok, time for sleep in .au
06:07:37 <beelsebob_> :o
06:07:39 <dons> night!
06:07:50 * beelsebob_ loves spotlight more!
06:08:06 <dcoutts> g'night dons
06:08:29 <boegel> g'night dons ç
06:08:42 <beelsebob_> g'night dons
06:08:48 <boegel> dons: we still need a lambdabot entry from you by the way :) entries are due Monday !
06:12:39 <jedi`> Does anyone know what the strings this regular expression describes?
06:12:45 <jedi`> [0-9]+((E|e)(\+|\-)?[0-9]+)?
06:13:11 <boegel> jedi`: what does that have to do with Haskell ?
06:13:48 <jedi`> boegel: its relevant to any programming language i feel
06:14:16 <boegel> jedi`: is this homework ?
06:15:10 <ProfTeggy> Use the force, jedi
06:15:17 <ProfTeggy> It will come to you in an instant
06:15:24 <Itkovian> jedi`: float?
06:15:45 <Itkovian> jedi`: a dragon?
06:15:54 <Itkovian> jedi`: a sith?
06:16:04 <boegel> jedi`: your father !
06:16:12 <jedi`> boegel: stfu?
06:16:15 <jedi`> ;)
06:16:27 <boegel> jedi`: just tell us what this is for, then we might help
06:16:35 <boegel> we're not a homework-doing-channel
06:16:38 <jedi`> k, im trying to learn about regular expressions
06:16:46 <jedi`> im studying haskell online
06:16:48 <Itkovian> jedi`: for regexes, you might consider asking the perl folk
06:16:52 <boegel> jedi`: where ? :)
06:16:54 <jedi`> okei thx
06:17:02 <jedi`> www.haskell.org
06:17:05 <jedi`> yet another haskell tutorial
06:17:05 <jedi`> :)
06:17:11 <Itkovian> just take it step by step, it's an easy expression
06:17:35 <boegel> jedi`: what does this do [0-9]+ ?
06:17:51 <Itkovian> 00000000000000000000000099999999999999999999999999999999999
06:18:08 <Itkovian> jedi`: think.
06:18:25 * Itkovian dons his homework club
06:19:47 * beelsebob_ slaps itkovian with a trout
06:19:58 <Itkovian> @dice 1d20
06:19:59 <lambdabot> 1d20 => 6
06:20:04 <Itkovian> I evade
06:20:17 <beelsebob_> jammy get
06:20:21 <beelsebob_> @dice 09823754
06:20:23 <lambdabot> 09823754 => 9823754
06:20:29 <beelsebob_> really????
06:20:40 <beelsebob_> @dice3d6
06:20:41 <lambdabot> Unknown command, try @listcommands.
06:20:47 <beelsebob_> @dice 3d6
06:20:48 <lambdabot> 3d6 => 8
06:21:03 <beelsebob_> ah, just an average swing, you do indeed evade
06:21:10 <sieni> @dice 42d1
06:21:11 <lambdabot> 42d1 => 42
06:21:15 <sieni> cool
06:21:23 <beelsebob_> I take it it rolls n d ms
06:21:25 <sieni> @dice 42d52
06:21:27 <lambdabot> 42d52 => 1063
06:21:55 <beelsebob_> @dice 3d6
06:21:56 <lambdabot> 3d6 => 11
06:22:08 <musasabi> @dice 3d6 + 7d4 + 2d80
06:22:09 <lambdabot> 3d6 + 7d4 + 2d80 => 87
06:22:10 <beelsebob_> ohhh, the gru tries to eat itkovian!
06:22:24 <musasabi> you can have contants too.
06:22:30 <musasabi> @dice 500 + 1d2
06:22:31 <lambdabot> 500 + 1d2 => 501
06:22:32 <beelsebob_> yeh... with d1s
06:23:21 <Itkovian> what's a gru?
06:23:57 <beelsebob_> similar to a grue, but shorter
06:23:58 <ulol> lolllllllllllllll jedi`
06:24:11 <humasect> ulol'd
06:24:19 <ulol> hullo
06:25:31 <Itkovian> and what's a grue?
06:25:57 <sieni> similar to gru, but longer
06:26:03 * ski thinks he saw the term 'grue' in a 'philosophical paradox'
06:28:03 <beelsebob_> @google "you have been eaten by a grue"
06:28:04 <lambdabot> http://arstechnica.com/journals/thumbs.ars/2005/6/21/542
06:28:32 <ski> http://en.wikipedia.org/wiki/Grue_(color)
06:29:34 <beelsebob_> http://en.wikipedia.org/wiki/Grue_%28monster%29
06:29:40 <ski> yah
06:29:42 <beelsebob_> those are more likely to eat you ;)
06:30:13 <ski> i wonder if the name of the zork one was taken from the goodman paradox ..
06:30:53 <ski> "Vance probably took the name from an archaic/dialectal English verb meaning shudder" .. prolly not
06:41:40 <cyanite> Does anyone have an overview over what kind of problems macros in lisp are supposed to solve, and how this compares to how to solve them in, say, Haskell or ML or other fun languages?
06:44:41 <Philippa> there're several
06:44:56 <cyanite> example?  :p
06:44:57 <Philippa> one problem they solve is inventing new control constructs - Haskell gets that "for free" due to lazy evaluation
06:45:14 <Philippa> (you need the macro to avoid evaluating the parameters until you choose to)
06:45:30 <cyanite> yeah
06:45:53 <Philippa> You can also use them to introduce new binding constructs, which Haskell and ML can't do on their own
06:46:00 <Philippa> (for example, you could build do notation in lisp)
06:46:36 <humasect> template haskell?
06:46:55 <Philippa> yeah. Doesn't count as plain Haskell though
06:47:03 <Philippa> (similarly MetaML, camlp4 etc etc)
06:47:18 <ski> MetaML ?
06:47:30 <cyanite> So what do people have against having such a feature? ;)
06:47:42 <Philippa> finally, you can use macros in lisp for wholesale code generation. Template Haskell doesn't match this because TH is "staged"
06:47:58 <ski> cyanite : not fully clear how to do when not sexping ?
06:48:11 <Lor> Philippa, what do you mean?
06:48:12 <Philippa> nah, TH works
06:48:16 <cyanite> ....
06:48:24 * ski thought macros was staged
06:48:25 <cyanite> I'm sorry, sex..ping?
06:48:47 <Philippa> ski: I'm pretty sure there're ways to get them to evaluate at run-time in at least one lisp
06:48:53 <ski> using sexprs i.e. parens around every syntactic form
06:48:54 <Philippa> and I suspect that one lisp is common lisp
06:49:11 <ski> Philippa : with 'eval', surely
06:49:20 <Lor> Philippa, being able to do run-time evaluation (including macro expansion) is really orthogonal to the issue here.
06:49:26 <ski> Philippa : only, that is still considered macro-expand-time
06:49:41 <cyanite> What's staged about TH?
06:50:12 <ski> cyanite : it runs in an earlier stage, i.e. at compile-time
06:50:31 <cyanite> ski: right... lisp's runs at eval time I suppose.
06:50:53 <ski> lisp can run at many times
06:51:29 <cyanite> at many times?
06:51:29 <Philippa> Lor: I'm not convinced it is entirely - if you can expand macros at run-time you can feed them data that didn't exist at compile-time
06:51:48 <Philippa> eval time is eval time is eval time. But there're many places that eval, no?
06:52:36 <musasabi> Philippa: one can generate code that is used at run time. (but the code generation cannot depend on values supplied at run-time)
06:52:37 <cyanite> I think we need to lower the level here. I don't know the first thing about lisp after all ;).. well... the first, but not the second.
06:52:47 <Philippa> musasabi: ah, fair enough
06:53:14 <Philippa> then perhaps you'd like to do a little research?
06:53:39 <Philippa> If you don't even understand what lisp macros /are/, you can't expect to understand opposition to including them in the ML family
06:54:17 <cyanite> No I don't want to do a little research. I understand fine what macros are in principle, meta programming.  I just wanted to know how some of the power they have could be archieved in say Haskell.
06:54:27 <Lor> Does someone really "oppose" macros? They are just bloody hard to do smartly in a typed language with a more complicated syntax than lisps.
06:54:41 <Lor> metaml and th are pretty good attempts, though.
06:55:04 <ski> does metaml suport macros, now ?
06:55:16 * ski thought MetaML was just for staged programming
06:55:17 <musasabi> Dylan tries to do lisp macros without sexps.
06:55:24 <Lor> Metaml _is_ a macro system, essentially. :)
06:55:27 <Philippa> I suspect a lot of people would oppose lisp-like macros that can't be distinguised from functions at the call site
06:55:35 <ski> Lor : i don't agree
06:55:40 <Lor> Ah, but that's a trivial syntax issue.
06:56:23 <musasabi> Philippa: depends whether they would be unclean or not.
06:56:39 <Lor> ski, write your macro definitions, then the entire program in quotes, then unquote and do macro calls as needed, then eval the result.
06:56:52 <ski> Lor : yes, related .. but not same
06:57:06 <beelsebob_> bloody fire alarms
06:57:48 <boegel> beelsebob_: they're there for your own good you know
06:57:50 <Philippa> musasabi: if they're more powerful than functions, people won't like the idea. Also, there're plenty conceivable reasons to want to know when you're passing quoted code into a function and when you're passing it to a macro
06:57:51 <Lor> Well, there's MacroML which explicates their relationship further.
06:58:31 <ski> Lor : http://citeseer.ist.psu.edu/467071.html
06:58:59 <Lor> Right.
07:01:20 <boegel> CosmicRay: having trouble ?
07:01:35 <CosmicRay> yeah, my sound card was apparently hosed.
07:01:38 <CosmicRay> reboot fixed it.
07:03:18 <boegel> any idea how one can check for the ip of a network printer using linux? :s
07:03:28 <boegel> yo ndm
07:03:32 <musasabi> Philippa: isn't that an issue mostly associated with unclean (and unsafe) macros.
07:03:39 <genneth> boegel, broadcast ping?
07:03:40 <ndm> yo boegel
07:03:51 <musasabi> Philippa: I think it is more like not knowing how strict functions are on data.
07:04:19 <musasabi> Of course macros cannot be functions as they break referental transparency.
07:05:31 <boegel> genneth: thanks !
07:06:22 <genneth> boegel, no probs; don't suppose you've ever had things like ls, hostname and awk start to spew segfaults and illegal instructions at you?
07:06:38 <ski> musasab : in which sense were you thinking about ?
07:06:56 <boegel> genneth: no, why ? :) I would've know about ping broadcast otherwise ?
07:07:11 <boegel> beelsebob_: join #haskell-blah pls
07:07:20 <musasabi> ski: let x = y in (macro x, macro y)
07:07:42 <musasabi> now if macro can see x and y it can result in different result.
07:08:17 <ski> you mean if it can see name of them ?
07:08:26 <musasabi> yes.
07:08:33 <genneth> boegel, it's happening to my server; and i'm just desperately fishing. the haskell people are usually more helpful than the fc4 people
07:08:55 <boegel> genneth: heh :)
07:08:59 <ski> musasabi : macros should arguably be hygienic
07:09:09 <boegel> genneth: sorry, no idea...
07:10:09 <ski> (musasabi : e.g. r5rs macros in scheme are ..)
07:10:40 <Lor> hygienic macros don't always fullfill musa's equality above
07:10:53 <ski> (musasabi : and the ones in the paper are, i think)
07:11:24 <ski> Lor : you are thinking of stuff like '=>' and 'else' in 'cond', yes ?
07:11:52 <Lor> No, I mean e.g. "quote" as a macro, where the expression given as an argument to the macro is turned into a data literal.
07:11:57 <Lor> "assert" is another case.
07:12:47 <ski> then "assert" should not be a macro :)
07:13:30 <Lor> There are lots of situations where e.g. the #x construct in C's macros is very useful for debugging purposes.
07:15:36 <ski> (hm .. maybe one could encapsulate such uses in something (a monad ?) that only admits debugging-system access)
07:22:38 <Lor> Sure, an output monad ought to do, if all that it does is generate debug messages.
07:49:19 <yankie> how do I get the n'th element of a list?
07:49:19 <neadjneki> !!
07:49:19 <yankie> thanks
07:59:34 <rafl> CosmicRay: ping
08:00:53 <rafl> CosmicRay: The patch I sent recently has some bugs. If you don't supply an argument '--dbp_builder' will be used as build command.
08:01:18 <rafl> CosmicRay: I'd also like to ask you if you would like to sponsor hs-plugins for me.
08:38:57 <CosmicRay> rafl: pong
08:38:57 <rep> what's your opinion on B+trees
08:38:57 <CosmicRay> rafl: ahh.  do you want me to revert it, or will you be sending some more patches to fix it?
08:38:57 <CosmicRay> rafl: I would do that, on the condition that you are in NM and actively pursuing becoming a maintainer
08:38:57 <CosmicRay> s/maintainer/dd/
08:38:57 <rafl> CosmicRay: Well, I counted on you for fixing that. :-)
08:38:57 <CosmicRay> the bug or the NM situation? ;-)
08:38:57 <CosmicRay> actually I was pondering rewriting the command-line parsing to use getopt anyway.
08:38:57 <rafl> CosmicRay: I wouldn't like to revert it. It works quite well, only that one race condition.
08:38:57 <rafl> The bug, of course. :-)
08:38:57 <CosmicRay> ok, I shall then.
08:38:57 <rafl> Well, I'm waiting for DAM approval and maintain quite a lot of packages: http://qa.debian.org/developer.php?login=Florian%20Ragwitz
08:38:57 <CosmicRay> excellent.
08:38:57 <CosmicRay> so you've just got a 2-month random wait and then you're done, right? ;-)
08:38:57 <rafl> CosmicRay: I also tried it with getopt, but it bugged me too much because I didn't write a single like of haskell before.
08:38:57 <CosmicRay> I can see that
08:39:12 <CosmicRay> what I mean is, I can see getopt being confusing in that situation.
08:39:39 <rafl> CosmicRay: btw, I think the policy of sponsoring only people in the NM queue is a bit strange to me, because you normally need to have contributed before applying to NM. A kind of deadlock.. ;-)
08:40:19 <rafl> CosmicRay: Well, I would definitely not count that it will be two months. Maybe 6 with the current speed. Or even longer.
08:40:48 <CosmicRay> heh
08:41:35 <CosmicRay> rafl: I say that because while I have time to upload a few packages for a few people for a little while, I don't have time to upload packages for people for years, or to teach people how to build debian packages.
08:41:42 <CosmicRay> which often is the case if someone isn't in NM already
08:41:57 <CosmicRay> so if I say "I'll do it if you're in NM", it weeds out the people that are less erious.
08:42:00 <rafl> CosmicRay: Would you sponsor the package today? I ask because there's someone who said he will sponsor it, but he doesn't seem to do anything about it.
08:42:03 <CosmicRay> s/erious/serious/
08:42:11 <CosmicRay> sure, if it looks sane.
08:42:17 <CosmicRay> where's the source package?
08:42:31 <CosmicRay> hmm, didn't I already sponsor this for you or something?
08:42:47 <CosmicRay> I can't remember.  maybe that was gour.
08:42:52 <CosmicRay> and a different package.
08:42:53 <CosmicRay> sigh.
08:43:16 <CosmicRay> ahh, ganesh.
08:43:18 <CosmicRay> never mind me.
08:43:32 <rafl> CosmicRay: Here it is: http://www-user.tu-chemnitz.de/~rafl/Code/Debian/nomeata/
08:43:34 <CosmicRay> rafl: just send me the source package or a link to the sources and I'll give it a quick inspection and then upload.
08:43:37 <rafl> CosmicRay: Not that I know of.
08:43:59 <CosmicRay> ok, I'll look at it right now.
08:44:51 <rafl> CosmicRay: haskell-src-exts is in since yesterday, btw. (as well as pugs, yay!)
08:45:23 <CosmicRay> I was 5 seconds away from complaining about that ;-)
08:45:33 * CosmicRay updates
08:46:24 <CosmicRay> humm, packages.d.o knows about it, but ftp.us.d.o doesn't.
08:47:32 <rafl> ftp://ftp.us.debian.org/debian/pool/main/h/haskell-src-exts/
08:48:26 <CosmicRay> I found it on another mirror.
08:48:38 <CosmicRay> rafl: one mirror in the ftp.us.d.o rotation apparently didn't have it yet
08:49:18 <rafl> Strange.
08:49:27 <CosmicRay> indeed
08:49:44 * CosmicRay tries a build.
08:50:11 <CosmicRay> do you need a build-dep on some of the tex stuff?
08:50:18 <CosmicRay> it is apparently necessary to build the docs.
08:50:55 <CosmicRay> ah, I see you may not be installing the docs.  it would really be good to do so, IMHO
08:51:13 <CosmicRay> would you like to patch it to do that, or should I?
08:55:45 <rafl> CosmicRay: Let me see how you would do that in a nice and clean way. I would have used make haddock, but unfortunately the package isn't cabalized.
08:57:47 <CosmicRay> rafl: there is a makefile in the doc/ dir that apparently generates a html and ps
08:58:00 <CosmicRay> I would say, generate both and list them in the .docs or dh_installdocs for the package
08:58:12 <CosmicRay> you'll also need to build-dep on the tools it needs to do that.
08:58:33 <rafl> I'd prefer HTML over ps.
08:58:47 <rafl> OK, I'll do that now. Thanks.
08:59:04 <CosmicRay> It is nice to provide both, since some people like to have a printable version
08:59:10 <CosmicRay> the ps will get gzipped anyway
08:59:23 <CosmicRay> I think you will need to add mzscheme, tetex-bin, tetex-base to the build-deps.
08:59:32 <CosmicRay> tex2page appears to be in mzscheme for some reason.
09:40:01 * shapr boings quietly
09:40:21 <musasabi> evening shapr
09:40:34 <shapr> greetings
09:40:37 <shapr> What's up?
09:40:39 <duncan_> yarr
09:40:41 <basti_> nuthin
09:40:42 <shapr> @arr
09:40:43 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
09:41:23 <duncan_> shapr, I'm installing debian on a couple machines in the lab in preperation for a Haskell + Gtk2Hs + cairo + cool graphics demo, for a student open day
09:41:50 <duncan_> that's what's up
09:42:09 <shapr> duncan_: awesome!
09:42:10 * duncan_ thinks that perhaps shapr wasn't talking to me
09:42:19 <shapr> Hey, it was a broadcast question.
09:42:23 <duncan_> ok :-)
09:42:42 <shapr> I just got 'net in my new apartment, now I have to do a bunch of backed up sysadmin tasks.
09:42:43 <duncan_> yeah, now where's xerox, it's his stuff I'm demoing
09:42:46 <duncan_> xerox, ping!
09:43:27 * musasabi has been looking at jhc and cabal
09:45:13 <duncan_> musasabi, so is jhc working now? is it ready for packaging?
09:48:05 <musasabi> duncan_: I sent a mail to john about my ideas how to manage libraries properly with jhc. The actual code + hacks to cabal should take less than a week to implement.
09:50:16 <duncan_> musasabi, cool
09:50:41 * duncan_ wonders if jhc supports enough of the FFI to handle Gtk2Hs
09:51:53 <musasabi> duncan_: I think multiparameter type classes may be a larger problem if gtk2hs uses them.
09:52:28 <duncan_> musasabi, it doesn't
09:52:47 <duncan_> we stick pretty close to H98+FFI
09:53:50 <ndm> duncan_, would it work on nhc?
09:54:12 <musasabi> Then there are good chances that it would work.
09:55:21 <musasabi> Although ForeignPtr would need to be implemented.
09:55:47 <duncan_> musasabi, ah yes we use lots of ForeignPtrs
09:56:22 <duncan_> ndm, possibly with some hacking, the "dynamic" exports or "wrapper" imports are required
09:56:44 <duncan_> ndm, it's not clear if nhc has them, I've read things saying both ways
09:59:25 <ape> greetings. any med students here by any chance?
09:59:42 <shapr> y0 ape, what's up?
10:00:01 <beelsebob_> why would there be med students
10:00:16 <Lemmih_> ape: Seeking medical advice on IRC?
10:00:19 <ape> hi shapr
10:00:23 <ape> sadly, i am
10:00:31 <ape> but not really advice, just information
10:01:33 <Lemmih_> We got a couple of doctors in here, don't we?
10:02:45 * ape crosses fingers
10:02:52 <gour> ape: my wife is one
10:03:10 <gour> ape: homeopathy included :-)
10:04:11 * Lemmih fears hIDE2 is dying.
10:04:54 * gour is wondering
10:04:56 <ape> hm... gour: do you think you could ask her a question?
10:05:04 <gour> ape: yes, sure
10:05:28 <gour> ape: although she is atm in the ambulance, but will be back for about 1 hour
10:05:36 <ndm_> Lemmih, so soon?
10:05:45 <gour> ape: buy i can phone her before
10:06:09 <gour> Lemmih: what happened?
10:06:21 <gour> ape: s/buy/but
10:07:27 <Igloo> Hmm, I need a cunning way to have something like read of a record but that has defaults for missing fields
10:09:00 <duncan_> Lemmih, why do you fear that?
10:09:01 <Lemmih> gour: Yi needs a fair bit of hacking and I'm not sure I'm up for that.
10:09:16 <duncan_> ah because of Yi
10:09:42 <duncan_> Lemmih, well we can start with GtkSourceView until Yi catches us up
10:09:47 <shapr> Yeah, totally.
10:09:53 <gour> Lemmih: why don't you start with  GtkSourceView while dons catches with Yi
10:10:05 <Lemmih> But the editor is the most important part of the IDE.
10:10:06 <shapr> Yeah, do what works.
10:10:07 * duncan_ appears to agree with gour
10:10:19 <shapr> Lemmih: nah, users is far more important :-)
10:10:25 <Lemmih> Almost all the plugins requires tight integration with the editor.
10:10:31 <duncan_> true, it just means we can't do the cool editor plugins yet
10:10:34 <ape> gour: it's not super urgent
10:10:45 <duncan_> but actually there are many other things to do
10:10:47 <shapr> But if we start with something that we can use, then we can build up momentum.
10:10:56 <gour> ape: ok, what's the time there now?
10:11:01 <duncan_> and yi doesn't have any cool editor plugns yet anyway
10:11:01 <ndm_> i would say you can have a very ueseable proejct with only a textbox
10:11:08 <ndm_> that yi can be added to later
10:11:11 <Lemmih> So hIDE is not dead, it's just crippled? (:
10:11:38 <gour> ape: for 90 you can query me, ok?
10:11:38 <duncan_> ndm_, and GtkSourceView does syntax highliting for loads of languages, and it has other useful code editor featrues
10:11:39 <shapr> I'd say it's just not in the form you expect ;-)
10:11:44 <duncan_> just nothing language specific
10:12:00 <Lemmih> duncan_: I don't think anyone would use it for anything serious.
10:12:00 <gour> long live hIDE
10:12:05 <Lemmih> I know I wouldn't.
10:12:14 <schyffe> I want to change the string "aabba" into [1,1,2,2,1] (replacing 'a' with 1 (int)). I tried this using 'map stupid "aabba"' where stupid is a function which returns 1 if the char is 'a' etc.. But how can I do this without using a function? The string contains only two different elements
10:12:20 <ape> gour: the time is 20:02
10:12:37 <duncan_> Lemmih, well I use nedit for all my Haskell coding and it's not really much different from gedit which is basically GtkSourceView
10:13:02 <duncan_> Lemmih, ie syntax highliting + search features
10:13:08 <duncan_> I don't really use much else
10:13:09 <Lemmih> duncan_: I would definitely not use gedit for anything serious (:
10:13:19 <duncan_> Lemmih, what does it lack?
10:13:23 <gour> ape: ok, i'm one hour back, so in 90min - 21:30 ?
10:13:31 <duncan_> (but yes I don't either)
10:13:41 <ape> gour: yes... what should i do in 90 then?
10:14:03 <gour> ape: you can query me (in private) with the question
10:14:08 <Lemmih> duncan_: The features that haskell-mode gives you.
10:14:19 <ape> gour: ok thanks
10:14:40 * duncan_ uses vim + nedit which have no such Haskell-specific features beyond syntax highliting
10:15:04 * gour gour lis learning haskell and using vim
10:15:17 <duncan_> Lemmih, I don't even know what haskell-mode gives you
10:15:33 <Lemmih> duncan_: What's next on the hIDE ToDo list? I can't think of anything more important than a decent editor.
10:15:55 <Akshaal> jhc looks very promising
10:15:58 * ndm_ uses textpad, again no specific haskell features
10:16:03 * shapr uses a stick
10:16:06 <duncan_> Lemmih, well on my todo list it's the ide shell, making that work and be extensable
10:16:11 * shapr beats the lambdas into normal form by hand.
10:16:16 <Lemmih> duncan_: auto-indentation, type pop-up when cursor idles on a variable.
10:16:29 <duncan_> ndm_, yeah I used to use textpad on win32, it's quite good
10:16:38 <ndm_> not quite good, perfect :)
10:16:55 <ndm_> obviously all these haskell features would be nice, but only syntax colouring is absolutely essential
10:17:04 <gour> Lemmih_: what about support for build-system, cabal
10:17:19 <duncan_> Lemmih, so what are the Yi issues? and how long do we expect them to take? if we used a simpler editor in the mean time, how long would it be there for?
10:17:37 <Lemmih> gour: That's secondary to a decent editor.
10:17:42 <gour> Lemmih_: do we need Yi for it or just hs-plugins tech. ?
10:17:50 <duncan_> Lemmih, I agree with ndm_ on this one, it's ok temporarily
10:18:35 <duncan_> in fact the auto-indentation is probably possible with the sourceview widget - but I'm not trying to argue that its an ok final solution
10:19:02 <gour> Lemmih: sure we need the best editor (Yi), but Haskell-support in today's IDE is..well..
10:19:16 <duncan_> gour, we need an editor that is extensable in Haskell, it's crucial for an IDE thats extensable in Haskell
10:19:36 <duncan_> we can't do the nice integration things without it
10:20:07 * Lemmih doesn't understand how anything else than the editor can have priority.
10:20:22 <duncan_> like showing type popups, jump to definition, language aware indenting, etc
10:20:27 <gour> duncan_: yes, i understand that, therefore we need hIDE
10:20:40 <duncan_> gour, and that needs an editor component
10:20:54 <shapr> Have I described my ideas for a parser based editor?
10:21:04 <duncan_> Lemmih, though actually we can't have the editor bit without the shell
10:21:14 <duncan_> shapr, vaugly, tell us again
10:21:15 <Lemmih> shapr: Post ideas on the wiki (:
10:21:25 <shapr> Ok, I will, but I'll give the essentials...
10:21:29 <duncan_> shapr, oh yes, do add it to the wiki too
10:21:46 <shapr> If we can access the parse tree of the buffer, we can do lots of cool stuff.
10:21:52 <gour> shapr: today Lemmih asked if i can put Trac on haskell.org..
10:21:54 <Lemmih> duncan_: I think we should develop the shell as it becomes needed.
10:22:10 <shapr> Does Trac's darcs integration work with the latest versions?
10:22:33 <duncan_> Lemmih, ok, that gives me more breathing space :-)
10:22:40 <gour> shapr: darcs backend works with 0.9 trunk
10:23:15 <shapr> hm, I'll look into it.
10:23:32 <gour> shapr: i use it on my local machine
10:23:42 <shapr> Anyway, I'd like to have an editor where syntax highlighting and all the standard features use language parsers.
10:23:48 <duncan_> Lemmih, you see I've already go a design for the pages api, but the implementation of the tree view in the left pane is more tricky, the bit the does the files/modules view
10:23:52 <gour> shapr: but it is maybe too much for haskell.org
10:23:58 <shapr> gour: Or maybe not...
10:24:02 <shapr> I don't know.
10:24:34 <gour> shapr: well, i don't have access to Apache there, and i'm still Haskell newbie, no establishment in the community
10:24:35 <shapr> regexes are flaky, ie line breaks in odd places.
10:24:44 <duncan_> shapr, do you need to do anything special to make it quick? reparsing the file on each keystroke is probably out :-)
10:24:46 <shapr> gour: I got r00t on haskell.org
10:24:55 <gour> shapr: but i can help with configuration...
10:25:16 <shapr> Incremental parsers already exist. dons had a list of papers on incremental reparsing.
10:25:22 <duncan_> ok cool
10:25:27 <shapr> The Semantic Bovinator in Emacs uses 'buckets'
10:25:39 <shapr> Sort of like the damage extension for X
10:25:39 <gour> shapr: it would be nice to put it on and having all hIDE related stuff there, together with the darcs repo
10:25:59 <gour> shapr: what do you think?
10:26:10 <duncan_> shapr, you know the VS Haskell people are using the ghc lexer which is fast can you can easily save the lexer state and re-lex only the bits that have changed
10:26:11 <shapr> Each top level 'section' is reparsed in its existing context when the content changes (whether it be class, function, type, or whatever)
10:26:20 <shapr> duncan_: Yeah, that would be perfect!
10:26:28 <shapr> But you'd have a Haskell-only editor there.
10:26:38 <duncan_> shapr, but that's only lexing, not parsing
10:26:52 <shapr> A more generic editor would allow definition with SDF2 or something.
10:27:10 <duncan_> hmm, not sure how that'd integrate with the ghc bits
10:27:25 <duncan_> ideally we could use the ghc parser too
10:27:33 <shapr> Yeah, but I'm just dreaming out loud at the moment, I don't expect this all to be available right away.
10:27:43 <duncan_> but do something cunning to only reparse bits that have changed
10:27:50 <duncan_> shapr, sure
10:28:08 <duncan_> well a good start would be to do the ghc lexing stuff
10:28:17 <shapr> My vision is something like re-builder in emacs where you can quickly and interactively define a parser and see which rules match which parts of a buffer with colorizing.
10:28:17 <duncan_> it'd give a basis for further parsing
10:28:33 <shapr> hoi Wilmer
10:28:59 <Wilmer> hey shapr, do we know each other? :-)
10:29:16 <shapr> Wilmer: No, but let me introduce myself...
10:29:22 <shapr> Hi, I'm Shae Erisson, who are you?
10:29:32 <Wilmer> Hi, I'm Wilmer van der Gaast. :-)
10:29:37 * gour lol
10:29:40 <shapr> Nice to meet you, are you learning Haskell?
10:29:41 <Wilmer> and it seems you know at least one word of dutch
10:29:49 <shapr> ik begrijp het niet!
10:29:50 <Wilmer> yeps
10:29:54 <Wilmer> had one lecturing so far, looks pretty cool
10:30:08 <shapr> Spiffy! Do you want the introductory tour for #haskell?
10:30:22 <Wilmer> hehe
10:30:31 <Wilmer> with >150 nicks that could be useful ;-)
10:30:36 <shapr> Ok!
10:30:53 <shapr> lambdabot is an irc 'bot written in Haskell with lots of useful features.
10:31:04 <Wilmer> i guessed so from /topic
10:31:07 * duncan_ recalls the pic of shapr welcoming newbies to #haskell http://elis.ugent.be/~kehoste/haskell-blah/shapr-angelic_dcoutts.png
10:31:11 <shapr> The Haskell Wiki has lots of useful information - http://www.haskell.org/hawiki/RecentChanges
10:31:30 <shapr> The url to the public logs of this channel are listed in the topic, and last and best ...
10:31:32 <Wilmer> duncan_: hehe, it's part of the culture? :-D
10:31:34 <shapr> @learn The Learning Page!
10:31:35 <lambdabot> http://www.haskell.org/learning.html
10:31:52 <Wilmer> yeah, i had that one :-)
10:32:21 <duncan_> Wilmer, some people made some South Park style charactures a few days ago, they're pretty silly :-)
10:32:25 <Wilmer> i was also looking for an online version of the exercises of thompson's book because my amazon order will take a week or two to arrive, don't know if they're somewhere :-(
10:32:29 <shapr> lambdabot can search for Haskell functions by type, name, and substring, search google, and do a bunch of other useful Haskell related (and unrelated) stuff.
10:32:32 <Wilmer> duncan_: yeah, i know the site, had a lot of fun with it. :-D
10:32:44 <Wilmer> nifty :-D
10:32:59 <Wilmer> hrmm, /msg lambdabot help doesn't do a lot though
10:33:08 <shapr> I don't know of an online version of Thompson's exercises, but you could start with Hal Daume's Yet Another Haskell Tutorial.
10:33:18 <Wilmer> uhuh, let's do that
10:33:21 <shapr> You need to set the option in the topic, since lambdabot doesn't identify yet.
10:33:32 <shapr> (maybe I should fix that, why doesn't lambdabot identify?)
10:33:37 <Wilmer> but i think i don't have that option enabled, let's see...
10:33:38 * shapr boings energetically
10:33:52 <Wilmer> problem is that the teacher expects me to make the exercises, so i'll try to think of some excuse :-)
10:34:03 * basti_ holds a sledge hammer above shapr's head on downboing
10:34:13 * shapr sideboings cleverly!
10:34:21 <Wilmer> hehe
10:34:25 <Wilmer> i feel at home now already ;-)
10:34:35 <shapr> Yes, this is the non-stop academic lan-party!
10:35:25 * gour feels somewhat angry never had the opportunity to participate in shapr's welcome-tour
10:35:44 * gour #$&#("#($#!$$#%$)("!$
10:35:52 <Wilmer> gour: just join with an unfamiliar nick :-)
10:36:06 <Wilmer> shapr: do you have a list of "hi" in every language or did you type "hoi" by accident? ;-)
10:36:15 <Lemmih_> gour, shapr: Did I miss something about Trac on haskell.org?
10:36:15 <gour> Wilmer: too late, shapr will recognize me ;)
10:36:23 <Wilmer> gour: not if you do it in a week... ;-)
10:36:37 <gour> Wilmer: you don't know him :-)
10:36:39 <shapr> Wilmer: Nah, I learned a bit of Dutch long ago and far away. Nowadays I'm learning Swedish.
10:37:00 <shapr> Talar du svenska?
10:37:00 <Wilmer> ah, that's cool :-)
10:37:17 <Wilmer> not yet, but i hope to have an internship there in half a year
10:37:22 <Wilmer> might learn some there
10:37:26 <shapr> Spiffy, at Chalmers?
10:37:27 * duncan_ leaves for home
10:37:33 <Wilmer> nope, delaval
10:38:05 <Wilmer> company that makes all kinds of milk-related equipment (iirc they also invented the well-known tetrapak), including milking robots, which will be my cup of tea
10:38:16 <shapr> Oh neat.
10:38:18 <gour> Wilmer: and try Thompson's exercises, i'm doing them
10:38:32 <Wilmer> gour: but they're in the book i won't have in the next two weeks, right?
10:38:36 <shapr> Are you going to write Haskell to milk cows? :-)
10:38:38 <Wilmer> or are they somewhere else?
10:38:39 <Wilmer> hehe
10:38:43 <Wilmer> would be nifty
10:38:52 <gour> Wilmer: no online edition, though
10:38:56 <Wilmer> at least the robot "firmware" runs on linux, so that's one step
10:39:03 <Wilmer> gour: you got the dead-tree version?
10:39:25 <gour> Wilmer: yes i use the book
10:39:34 <Wilmer> i hope to have it soon too
10:39:41 <gour> Wilmer: highly recommended
10:40:13 <Wilmer> yeps, seems to be a popular one
10:40:14 <gour> Wilmer: try to skim through those tutorials mentioned on haskell.org to have an overview
10:40:18 * Wilmer looked around a bit already
10:40:26 <Wilmer> i already saw the qsort implementation
10:40:35 <Wilmer> during lecturing
10:40:37 <Wilmer> nice one :-)
10:40:40 <gour> that's a good one
10:40:45 <Wilmer> yep
10:40:57 <gour> good luck in mastering haskell
10:41:02 <Wilmer> and with the right compiler it's just as fast as a c implementation?
10:41:02 <gour> it's fun
10:41:03 <shapr> Yeah, Haskell rocks!
10:41:14 <Wilmer> and thanks for the tour, shapr :-)
10:41:23 <gour> Wilmer: i did not have opportunity to check this one
10:41:32 <shapr> Wilmer: It can be faster if you exploit lazy evaluation, but it rarely is faster execution wise.
10:41:38 <shapr> For the most part the advantage is developer time.
10:41:42 <Wilmer> yeah, true
10:41:46 <gour> that's important
10:42:09 <Wilmer> i heard of one fp teacher who tells, with every line he writes on the board, how many lines of c/java/etc it would've been :-D
10:42:14 <gour> no fiddling with low-level memory management
10:42:30 <shapr> It really is amazing how much C/Java/etc it takes to implement the equivalent Haskell.
10:42:35 <shapr> In some cases it's just not worth it.
10:42:54 <shapr> Look at monads for example... you can do them in Java, but it's a massive pain in the butt.
10:43:10 <Wilmer> i guess i will see that example soon?
10:43:23 <shapr> Sure, if you want to.
10:43:40 <Wilmer> sure :-)
10:43:41 <shapr> One example I like is: fib = 0 : 1 : zipWith (+) fib (tail fib)
10:43:54 <shapr> You know the fibonacci series, I assume?
10:44:05 * gour thinks about joining shapr's monad tour (in the future :-)
10:44:07 <Wilmer> yeps, 0 1 1 2 3 5 8 13, right?
10:44:24 <shapr> Yup, that's it.
10:44:36 <z0d> shapr: too much cleverness in that fibonacci <-:
10:44:42 <shapr> Lazy evaluation in Haskell means you can define and use infinite data structures.
10:44:44 <Wilmer> couldn't come up with that one for now indeed :-)
10:44:58 <gour> :-)
10:45:02 <shapr> The simplest example of an infinite series in Haskell is ones = 1 : ones
10:45:13 <shapr> the colon is a list constructor.
10:45:28 <shapr> @eval take 5 ones where ones = 1 : ones
10:45:32 <lambdabot> 30: parse error on input `where'
10:45:36 <shapr> bah
10:45:46 <shapr> @eval let ones = 1 : ones in take 5 ones
10:45:48 <lambdabot> [1,1,1,1,1]
10:46:09 <shapr> Wilmer: IS that clear or confusing?
10:46:19 <Wilmer> Hugs.Base> let ones = 1 : ones in take 5 ones
10:46:19 <Wilmer> [1,1,1,1,1]
10:46:20 <Wilmer> clear :-)
10:46:21 * gour tech. problems ;)
10:46:23 <shapr> z0d: It's efficient though.
10:46:40 * Wilmer took the opportunity to see if his hugs install works
10:46:50 <z0d> shapr: but it takes a Haskeller to understand it <-:
10:47:06 <shapr> z0d: Only because actual use of lazy eval seems to be limited to Haskell users :-)
10:47:24 <z0d> no. because Haskellers generally more competent
10:47:25 <Wilmer> it's just recursion to the max :-)
10:47:35 <shapr> z0d: Hm, could be. Why is that?
10:47:53 <shapr> Wilmer: zipWith takes two lists and stick them together with the given operator.
10:48:04 <shapr> @eval zipWith (+) [1,2,3] [1,1,1]
10:48:05 <lambdabot> [2,3,4]
10:48:11 <z0d> shapr: because you have to work harder to understand Haskell
10:48:18 <Wilmer> and what's the tail?
10:48:30 <shapr> @eval tail [1,2,3,4]
10:48:31 <lambdabot> [2,3,4]
10:48:34 <Wilmer> ah yeah
10:48:36 <shapr> @eval head [1,2,3,4]
10:48:37 <lambdabot> 1
10:48:58 <shapr> Wilmer: So, do you see how that fibonacci sequence operates?
10:49:43 <Wilmer> i'm trying to :-)
10:49:56 <Wilmer> at least i couldn't come up with it myself yet
10:50:18 <shapr> Lazy evaluation is black magic at first, and beautifully elegant when understood.
10:50:45 <gour> Wilmer: it's 17th chapter (out of 20) in the book
10:50:47 <Wilmer> have to say it's one of the last subjects i'll have for haskell, so i'm a bit fast now :-)
10:50:49 <int-e> @eval let fac = 1:zipWith (*) fac [1..] in take 10 fac
10:50:50 <Wilmer> exactly
10:50:51 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880]
10:51:07 <shapr> Wilmer: Yeah, you're doing just fine ;-)
10:51:19 <int-e> I think this may be *slightly* easier to understand
10:51:30 <int-e> the basic principle is the same though
10:52:03 <Wilmer> let's say it makes sense to me :-)
10:52:13 <shapr> heh
10:52:32 <shapr> It's like a zippe that starts with the two initial values and zips together the results incrementally.
10:52:38 * shapr wonders if that was a helpful description.
10:52:48 <Wilmer> :-D
10:52:52 <int-e> shapr: well it's why it's called zip :)
10:52:57 <Wilmer> uhuh
10:53:05 <shapr> yeah!
10:53:10 <Wilmer> maybe now is the time for me to first read some basic instructions
10:53:18 <shapr> Anyway, if you get the urge to try to translate that to Java/C/etc...
10:53:31 <Wilmer> well, the fac is doable, did it like that once
10:53:50 <int-e> . o O ( public class Zip implements Thunk { } )
10:53:53 <Wilmer> but it'd be a bit longer :-)
10:54:37 <shapr> There are a bunch of incremental calculations like that called spigot algorithms - http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf
10:54:45 * int-e feels an astonishing lack of urge to continue.
10:54:58 <shapr> Jeremy Gibbons got an award in the most recent IOHCC for his Pi Spigot code.
10:55:02 <shapr> int-e: whew
10:55:24 * shapr boings randomly
10:55:42 * Wilmer boioioioioioings along
10:55:57 <gour> shapr: will you take a look for trac?
10:58:09 <shapr> gour: Not tonight, ask me again tomorrow?
10:58:53 <CosmicRay> hey shapr
10:58:55 <gour> shapr: np, it's not a rush
10:59:00 <shapr> y0 CosmicRay, wassup?
10:59:53 <CosmicRay> shapr: basking in the glow of autrijus, I think ;-)
11:00:00 <CosmicRay> shapr: did you see his interview on perl.com?
11:00:11 <shapr> I saw the first one, but not the recent one.
11:00:17 <shapr> You have the url?
11:00:41 <CosmicRay>  http://www.perl.com/pub/a/2005/09/08/autrijus-tang.html?page=2
11:06:10 <Wilmer> ah, i found shapr's other hat :-) http://elis.ugent.be/~kehoste/haskell-blah/shapr-ChanOp_dcoutts.png
11:07:06 <dcoutts> heh heh heh
11:07:31 <Wilmer> dcoutts: lol, i see you're not too fond of the bot? ;-)
11:07:54 <dcoutts> Wilmer, no I thought it was a sympathetic portrait, poor overworked lambdabot
11:08:03 <Wilmer> hehe, okay, good point
11:08:14 <Wilmer> have to meet the first bot that really gets tired though
11:08:39 <shapr> Wilmer: Happily, I don't have to use that hat much.
11:09:00 * dcoutts has only seen it once
11:09:12 <Wilmer> shapr: i'll do my best to keep it like that ;-)
11:09:21 <Wilmer> dcoutts: but it seems that you were very impressed
11:09:27 <dcoutts> oh yes
11:09:49 * shapr wonders when that was
11:10:18 <dcoutts> I think you were about to dispatch someone for turning up and being very OT
11:10:32 <dcoutts> but they backed down
11:10:49 <dcoutts> and promised to play nice
11:11:11 <dcoutts> ah! it was the "lama farmer dude"
11:11:28 <z0d> lambda farmer dude
11:11:34 <dcoutts> "my lama is going to kick your lama's ass" and all that
11:11:59 <dcoutts> z0d, yeah, that would have been more on topic :-)
11:13:56 <rep> do people get PhDs without having master's?
11:14:18 <Wilmer> if i have to believe those people who mail me, they do ;-)
11:14:23 <CosmicRay> rep: not in the US
11:14:30 <cjb> CosmicRay: That's not true.
11:14:44 <cjb> In hard sciences in the US, a masters is what you get if you drop out of your PhD program.
11:14:56 <rep> hard sciences?
11:15:03 <cjb> eg. chem/phys/bio.
11:15:06 <CosmicRay> cjb: huh, I've never heard of that
11:15:10 <rep> how about computer science
11:15:34 <cjb> CosmicRay: It's true for MIT and Harvard, at least.  It's impossible to apply for a masters there; you apply for the PhD course, and can leave after two years with a masters or after six years with a PhD.
11:15:39 <ndm_> rep, in england you can get a phd without a masters
11:15:49 <ndm_> but if you drop out early, you can end up with a masters
11:16:06 <ndm_> but you can also get a masters on its own
11:16:15 <ndm_> or instead of a bachelors
11:16:31 <cjb> But my gf's (who's at Harvard) Dad (who's a professor in San Diego) told me that when he sees an applicant with a masters, he thinks "Oh, they dropped out of a PhD." and doesn't consider them.  So, there are at least some situations where it's expected that you have a PhD and not a masters.
11:16:35 <rep> maybe i could go to england
11:17:21 <cjb> Brit PhDs are three years, and my gf's is likely to take seven, so there are definitely some advantages to doing it over here.  :)
11:17:32 <ndm_> in england an MSc or MEng is a real masters
11:17:34 <CosmicRay> rafl: do you have an updated package yet?
11:17:39 <ndm_> MPhil usually means drop out phd
11:18:12 <z0d> is it that usual to be dropped out of PhD?
11:18:33 <rep> is it hard to get into a phd program
11:18:44 <z0d> rep: I know that
11:18:53 <rep> you know what?
11:18:57 <cjb> z0d: For a program that takes six/seven years, yes.
11:19:01 <rep> (it was a question)
11:19:06 <Trinity> if i have ([Char], [Char]) how do i get the second string ?
11:19:18 <z0d> rep: that it's hard to get in
11:19:23 <Cale> Trinity: snd will work, or pattern matching
11:19:27 <dcoutts> xerox, ping
11:19:28 <rep> z0d so how do you get in
11:19:31 <cjb> No, not too hard.  You need strong degree grades and some experience doing self-motivated research.
11:19:46 <Cale> @eval snd ("Hello", "World")
11:19:48 <lambdabot> "World"
11:19:53 <Trinity> thanks
11:19:58 <rep> i think my grades are average
11:20:12 <dcoutts> xerox, I've got an early version of you L-system code wrking on my demo machine but I'd quite like the latest version of the code. Is it available anywhere?
11:20:14 <cjb> Have you finished undergrad yet?
11:20:33 <cjb> I'm talking about final-year undergrad grades.  They'll need to be pretty exceptional, if you're not doing a masters first.  Having a masters can offset having average grades.
11:20:53 <rep> CosmicRay yes
11:20:56 <rep> err
11:20:57 <rep> cjb yes
11:21:15 <rep> my in-major GPA was 3.36/4.00, apparently
11:21:41 <cjb> Okay.  Well, apply a couple of places, see what happens.  You'll need a good research idea and a professor who wants you to do it with him first; the reason a Brit PhD is half as long is that you're expected to have a full research proposal before you start.
11:21:49 <rep> my final-year grades were the worst :)
11:21:56 <cjb> (Whereas in the US, you usually spend the first two years taking (and giving) classes.)
11:21:59 <shapr> hiya Trinity, are you learning Haskell?
11:22:04 <rep> because i was really tired of doing homework etc
11:22:46 <cjb> Yeah.  Well, if you're particularly competent with Haskell, I can imagine research groups being very interested in you despite average grades.
11:23:47 <Trinity> ok whats the opposite of snd if i want the first :) ?
11:23:55 <pejo> Trin, fst
11:24:01 <Trinity> :) thank you
11:28:12 <Wilmer> damn
11:28:24 <Wilmer> these sheets on cs.chalmers.se look damn familiar
11:28:38 <Wilmer> looks like my teacher translated them to dutch and used them for his lessons *g*
11:37:46 <Trinity> if i have ([Char], [Char])  and in the function i want to do (x:xs) do i type it the same way then ?
11:38:08 <ndm_> cjb, i didn't have a research proposal
11:38:16 <ndm_> my proposal was "i don't like electronics"
11:39:08 <ndm_> Trinity, do you want to join the two lists together?
11:39:24 <ndm_> if so its ++, not :, because both parts are lists
11:42:12 <Wilmer> hmm, i wonder why [1,2,3] ++ ( 4 : [5,6,7] ) is okay while ( [1,2,3] : 4 ) ++ [5,6,7] is not...
11:42:30 <ndm_> Wilmer, look at types
11:42:32 <ndm_> @type :
11:42:34 <lambdabot> bzzt
11:42:39 <ndm_> @type (:)
11:42:41 <lambdabot> forall a. a -> [a] -> [a]
11:42:46 <ndm_> @type (++)
11:42:48 <lambdabot> forall a. [a] -> [a] -> [a]
11:44:08 <Trinity> hmm ok.. but if i have a functionname like  functionname x y s n    and  n is ([char], [char]) do i have to type something else then =
11:44:14 <Wilmer> have to admit i don't see a mistake yet, i'd say the types are okay...
11:44:30 <Wilmer> ndm_: i'd say the two things in my line are equal, just a differnt order
11:44:54 <ndm_> Wilmer, not at all
11:44:56 <Wilmer> oh, wait
11:44:58 <musasabi> Wilmer: the order of function arguments is important.
11:45:05 <Wilmer> : requires that the non-list arg comes first?
11:45:14 <musasabi> yes.
11:45:16 <rafl> CosmicRay: Sorry, I won't get it ready today. I unfortunately need to leave now. I hope it's ready tomorrow.
11:45:30 <Wilmer> musasabi: ah yeah, of course, oops :-) thanks
11:46:56 <shapr> Whoa, pugs has debs available.
11:47:22 * dcoutts notes that pugs has been in gentoo for longer than he can remember
11:48:12 <kosmikus> yes, it was added relatively early by the pearl team
11:49:16 <CosmicRay> rafl: no problem
11:53:58 <Itkovian> pompom
11:54:49 * shapr waves the pompoms
11:55:01 * shapr boings
11:55:19 * CosmicRay calculates the displacement of shaprs spring
11:55:54 <schyffe> is there a function to remove the n'th element from a list?
11:57:13 <CosmicRay> splitAt may be useful for you.
11:57:22 <CosmicRay> you could write a function to do that in terms if splitAt in one line.
11:57:36 <schyffe> yeah thanks
11:59:06 <dcoutts> list n -> case splitAt n list of (before,_:after) -> before ++ after
11:59:20 <dcoutts> @plugs (list n -> case splitAt n list of (before,_:after) -> before ++ after) "012345" 2
11:59:21 <lambdabot> 26: parse error on input `->'
11:59:26 <dcoutts> @plugs (\list n -> case splitAt n list of (before,_:after) -> before ++ after) "012345" 2
11:59:27 <lambdabot> "01345"
12:00:24 <dcoutts> schyffe, you're welcome
12:00:48 <schyffe> thank you
12:14:28 <dcoutts> Lemmih, you about?
12:32:21 <Trinity> if i have like this [([a], [a])]  how do i pick the first pair, the second and so on ?
12:33:03 <musasabi> map ?
12:33:07 <musasabi> @type map
12:33:08 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
12:33:17 <musasabi> or fold.
12:33:21 <Trinity> ah ok..
12:33:30 <ndm__> can you give an example?
12:33:38 <ndm__> i would have said a zip might help more
12:33:43 <Cale> yeah, I'm thinking an example of what you want would help :)
12:34:03 <Cale> @type zip
12:34:05 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
12:34:25 <musasabi> or even unzip
12:34:29 <Trinity> hmm ok.. will try them out
12:34:49 <Cale> or do you just mean  xs !! n?
12:35:02 <Cale> @eval [0..10] !! 5
12:35:03 <lambdabot> 5
12:36:37 <Trinity> hmm but in that case wouldnt this work ? map reverse [("jkfejfe", "kfeiok"), ("kfeok"), ("jfiej")]
12:37:00 <Cale> that list is a type error
12:37:24 <Trinity> yup i see but [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:37:34 <Cale> @eval reverse [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:37:35 <lambdabot> [("kfeok","jfiej"),("jkfejfe","kfeiok")]
12:37:41 <Cale> it reverses the list
12:38:51 <Trinity> ok but if i want to pick one pair like ("jkfejfe", "kfeiok") and then use in another function
12:39:03 <Cale> @eval [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")] !! 1
12:39:05 <lambdabot> ("kfeok","jfiej")
12:39:07 <Cale> @eval [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")] !! 0
12:39:09 <lambdabot> ("jkfejfe","kfeiok")
12:39:24 <Cale> @eval head [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:39:26 <lambdabot> ("jkfejfe","kfeiok")
12:39:41 <Trinity> ok.. is there a way to do it to all the pairs in one command ?
12:39:51 <Cale> @eval [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")] >>= (\(x,y) -> x ++ y)
12:39:53 <lambdabot> "jkfejfekfeiokkfeokjfiej"
12:40:16 <Cale> @eval [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")] >>= (\(x,y) -> [x ++ y])
12:40:18 <lambdabot> ["jkfejfekfeiok","kfeokjfiej"]
12:40:55 <Cale> @eval [10,20..100] >>= (\x -> [x,x+1])
12:40:56 <lambdabot> [10,11,20,21,30,31,40,41,50,51,60,61,70,71,80,81,90,91,100,101]
12:41:19 <Cale> @type (>>=)
12:41:21 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
12:41:21 <lambdabot> b
12:41:31 <Cale> er, that got mutilated :)
12:41:34 <Trinity> hmm but can i apply a function to the list so it will take the first pair and then the second until end of list ?
12:41:41 <Cale> map
12:41:47 <Cale> map does that :)
12:41:58 <Cale> @eval map (\x -> x + 1) [1,2,3,4]
12:42:00 <lambdabot> [2,3,4,5]
12:42:22 <int-e> @type curry
12:42:23 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
12:42:44 <Cale> @eval map (\(x,y) -> x ++ y) [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:42:46 <lambdabot> ["jkfejfekfeiok","kfeokjfiej"]
12:42:50 <int-e> @eval map (uncurry (++)) [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:42:51 <lambdabot> ["jkfejfekfeiok","kfeokjfiej"]
12:43:01 <int-e> :)
12:43:32 <Trinity> [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")] so i can use map here and the first time it will take ("jkfejfe", "kfeiok") ?
12:44:01 <Cale> It will apply the function to all the elements of the list (the pairs) and return the list of all the results.
12:44:40 <Cale> Of course, due to lazy evaluation, nothing will get done until you look at the list elements.
12:45:30 <int-e> @eval map (\(x,y)->error "Not implemented") [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:45:31 <lambdabot> <Plugins.Eval>:1:12:
12:45:31 <lambdabot>   Ambiguous type variable `b' in the constraint:
12:45:31 <lambdabot>   `Show b' arising from use of `show'
12:45:47 <int-e> @eval map (\(x,y)->error "Not implemented"::Int) [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:45:49 <lambdabot> Not implemented
12:46:01 <int-e> @eval length $ map (\(x,y)->error "Not implemented"::Int) [("jkfejfe", "kfeiok"), ("kfeok", "jfiej")]
12:46:02 <lambdabot> 2
12:47:56 <int-e> that's lazy evaluation at work: computing an element of that list raises an error; however, to determine the length of the list, you never need to look at the values of the elements - therefore no error occurs.
12:48:55 <Cale> @eval map (+1) [undefined,1,2,3]
12:48:56 <lambdabot> Prelude.undefined
12:49:03 <Cale> @eval tail $ map (+1) [undefined,1,2,3]
12:49:05 <lambdabot> [2,3,4]
12:49:08 <Trinity> map (transformationsApply k f y x) ([("jkfejfe", "kfeiok"), ("kfeok", "jfiej")])   if i want every pair here to be y how do i do that ?
12:49:54 <Cale> (\y -> transformationsApply k f y x) ?
12:50:05 <Trinity> hmm ok
12:50:12 <Cale> do you have values to plug in for k,f, and x?
12:50:19 <Trinity> yes
12:51:08 <Cale> also, what are you using the list of pairs of strings for?
12:51:37 <Cale> often such things are ripe for replacement by a more suitable datatype like a Map
12:52:19 <Trinity> its for a pattern matching..
12:55:25 <Cale> the thing to watch out for is if you'll be searching through the list because you have some x, and want the corresponding (x,y)
12:55:53 <Cale> This can be okay, but it's generally more efficient to use Data.Map for that.
12:57:12 <Trinity> whats the diffrence ?
12:57:22 <ndm> if you are learning about haskell its best to not worry about efficiency
12:57:36 <ndm> and to only learn as few concepts as you can to start with, then slowly build up
12:59:17 <Cale> Yeah, but it's also the case that Data.Map has a library of functions with that use in mind :)
13:00:02 <ndm> maybe true, to be honest i've never looked at Data.Map
13:00:45 <Cale> really? It's one of the nicest libraries in the GHC distribution :)
13:01:23 <ndm> GHC, I've never really used that either :)
13:02:09 <ndm> @docs Data.Map
13:02:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Map.html
13:02:37 <Cale> Well, it's also available in hugs
13:03:18 <ndm> yeah, not the old version of hugs i've been using :)
13:03:33 <ndm> but i upgraded last week, so i'm taking a look at data.map now
13:06:05 <goron> Trinity: no.
13:06:55 <goron> That was a message in response to an old message. I.e. just ignore it.
13:09:15 <Wilmer> hmpf... it seems hugs doesn't know about isLower?
13:10:24 <Trinity> is it possible to do map but.. i only want to do it until i get a match so i continue on every Nothing
13:10:30 <kosmikus> @hoogle isLower
13:10:31 <lambdabot> Char.isLower :: Char -> Bool
13:10:32 <arjanb> you need to import Data.Char
13:10:35 <Wilmer> ah
13:11:02 * Wilmer growls at the Yet Another Haskell Tutorial
13:11:08 <Wilmer> seems to be more specific to GHC
13:11:34 <Wilmer> ah, good
13:11:41 <Wilmer> :load Data.Char did the job :-)
13:11:59 <ersan> hi
13:12:13 <kosmikus> no, it's probably more specific to old versions of Hugs
13:12:29 <ndm> yep, older versions of Hugs exported isLower from the prelude
13:12:56 <Wilmer> ah, ok, thanks
13:13:07 <ndm> but still mail teh YAHT author to tell him
13:14:15 <Wilmer> good idea
13:18:07 <trez> how to generate a random nummer from 1 to 52 ?
13:18:23 <Dread[]> I need to convert 'a1' to 2 integers. It would be easier if I had 'a' and '1' than digitToInt would work, but I don't know how to split them. Anyone?
13:18:29 <Lemmih_> @dice 1d52
13:18:30 <lambdabot> 1d52 => 9
13:18:49 <Dread[]> there is a module Random
13:19:05 <Dread[]> RandomGen(next, split, genRange) something.
13:21:57 <Dread[]> anyone?
13:22:08 <Trinity> have a problem here i dont want to use fromJust BUT substitute dont take maybes what to do? cant change substitute
13:22:08 <Trinity> transformationApply :: Eq a => a -> ([a] -> [a]) -> [a] -> ([a], [a]) -> Maybe [a]
13:22:08 <Trinity> transformationApply k f x y = Just (substitute k (snd(y)) (fromJust (id (match k (fst(y)) (x)))))
13:22:14 <musasabi> What are (:+:) and (:*:) ?
13:23:30 <ndm> constructors
13:23:36 <ndm> @index (:+:)
13:23:37 <lambdabot> bzzt
13:23:43 <kosmikus> musasabi: probably infix type constructors for types isomorphic to Either and (,)
13:23:45 <ndm> @hoogle :+:
13:23:51 <Dread[]> @split
13:23:52 <lambdabot> Unknown command, try @listcommands.
13:24:06 <kosmikus> musasabi: where?
13:24:26 <musasabi> kosmikus: from haskell-cafe (binary parsers thread) "it may be eliminated even without TH! :+: and :*: should work, although i don't tried this"
13:25:19 <musasabi> google does not like special symbols in queries...
13:25:49 * musasabi thinks they are related to generic haskell
13:26:08 <TheHunter> @type (Data.Generics.:*:)
13:26:09 <lambdabot> forall b a. a -> b -> (GHC.Base.:*:) a b
13:26:29 <TheHunter> they are related to generic instances.
13:26:49 <musasabi> The GHC user guide just tells "Note: support for generic classes is currently broken in GHC 5.02"
13:27:08 <musasabi> I think some folks are using them, but I don't know whether they use stock-ghc.
13:27:34 <TheHunter> i think they (still?) work.
13:27:50 <Dread[]> noone know how to split 'a1' or 'b2' and so on?
13:28:09 <TheHunter> your question isn't precise enough
13:28:20 <kosmikus> musasabi: they're defined in Generic Haskell, that's why I asked
13:28:40 <Dread[]> TheHunter: you ment mine?
13:28:44 <TheHunter> yes
13:28:52 <kosmikus> musasabi: but the GHC definition is the same, I think
13:30:06 <Dread[]> well, I give my function "a1" but want to analyze it as a set of two Integers. So 'a1' should be interpered as (1 1). If the input would be (a 1) it would be easy with digitToInt but I don't know how to do it when the input is "a1"
13:31:33 <TheHunter> so all your strings consist of two characters the first of which is a letter and the second of which is a digit?
13:31:52 <Dread[]> yes
13:32:16 <TheHunter> i suggest pattern matching then:
13:32:33 <Trinity> if i have a something like this [Just "my name zach", Nothing, Just "my name tomas"] i want to pick the first that is not Nothing how do i do that ?
13:32:38 <CosmicRay> shapr: am I misrembering your homepage?  isn't it scannedinavian.com?
13:32:49 <TheHunter> @eval case "a1" of (x:y:[]) -> (x, digitToInt y)
13:32:51 <lambdabot> ('a',1)
13:32:56 <shapr> It is, but I just moved my server.
13:32:59 <CosmicRay> shapr: it's giving me "the requested URL / could not be found"
13:32:59 <CosmicRay> ah
13:33:03 <shapr> I'll fix it soon.
13:33:57 <schyffe> any standard way to count the number of occurences of an element e in a list?
13:34:32 <TheHunter> length . filter f ?
13:34:42 <schyffe> ah right
13:34:52 <Dread[]> TheHunter: hmm...
13:37:26 <TheHunter> @eval "a1" !! 0
13:37:26 <TheHunter> @eval "a1" !! 1
13:37:27 <lambdabot> 'a'
13:37:27 <lambdabot> '1'
13:48:40 <Trinity> if i have a something like this [Just "my name zach", Nothing, Just "my name tomas"] i want to pick the first that is not Nothing how do i do that ? Or is it possible to do map in a way that i only get one response and it cant be Nothing ?
13:51:33 <Heffalump> head . catMaybes
13:51:44 <Heffalump> @type head . catMaybes
13:51:45 <lambdabot> bzzt
13:51:47 <Heffalump> @type head . catMaybe
13:51:49 <lambdabot> bzzt
13:51:55 <Heffalump> @type head . Data.Maybe.catMaybe
13:51:56 <lambdabot> bzzt
13:52:00 <Heffalump> @type head . Data.Maybe.catMaybes
13:52:02 <lambdabot> forall a. [Maybe a] -> a
13:52:06 <Heffalump> (finally :-)
13:52:17 <Heffalump> of course, if there are no Justs then you'll get a runtime error
13:52:37 <Trinity> ok.. well thats a possibility :(
13:53:25 <Micket> argh.. irssi has a high learning curve..
13:53:35 <Heffalump> @type \xs -> case Data.Maybe.catMaybes xs of { [] -> Nothing ; x:_ -> Just x }
13:53:35 <shapr> Emacs is much easier!
13:53:36 <lambdabot> forall a. [Maybe a] -> Maybe a
13:53:41 <Heffalump> that might be even better
13:54:58 <Trinity> huh you mean all this in the map method ?
13:59:58 <ndm> @docs Data.Array.IArray
13:59:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.IArray.html
14:00:19 <ndm> can anyone explain the definition of HasBounds and bounds
14:00:49 <ndm> given class HasBounds a has only one method, bounds, which is Ix a =>
14:01:04 <ndm> why is it not just class Ix a => HasBounds a where bounds ....
14:01:30 <ndm> is there a difference, or a reason?
14:02:27 <Micket> hmm
14:05:25 <ndm> it happens quite a few times in the libraries sadly
14:05:36 <ndm> as it means hacking in yet another rule into hoogle :(
14:10:30 <TheHunter> @type Data.Array.IArray.bounds
14:10:31 <lambdabot> forall (a :: * -> * -> *) i e.
14:10:31 <lambdabot> (Data.Array.Base.HasBounds a, GHC.Arr.Ix i) =>
14:10:31 <lambdabot> a i e -> (i, i)
14:10:49 <Dread[]> if I have a datatype like this: data Car = C Colour Kind Owner but then I want to define a "noCar" whitch doesn't have any attributes (ie no Colour, Owner or Kind) how do I do that?
14:11:46 <TheHunter> you obviously can't have class Ix i => HasBounds a
14:12:27 <liyang> Dread[]: use Maybe
14:13:09 <Dread[]> liyang: so data Car = C Maybe Colour Kind Owner ?
14:13:21 <liyang> Nope.
14:13:34 <liyang> type Car' = Maybe Car
14:14:11 <liyang> So you'd either have (Just (C colour kind owner)) or Nothing
14:15:16 <Muad_Dibber> boegel|home forgot something.
14:15:36 <Dread[]> since I'm a beginner with haskell I didn't quite follow you. When you said type Car is that in the declarations in the beginning?
14:16:23 <boegel|home> Muad_Dibber: forgot ?
14:16:51 <Muad_Dibber> nothing.
14:17:00 <SickJacken> who in here gave me the advice to make a typeclass out of my (Map Int (Map String (Set String))) datatype so i could abstract from the implementation (in this case with maps) ?
14:18:10 * boegel|home scratches his head
14:18:12 <liyang> Dread[]: you could either write data Car = C Colour Kind Owner | NoCar
14:18:43 <ndm> TheHunter, oh, i missed that
14:18:47 <ndm> cheers
14:18:54 <Dread[]> liyang: Ahh, now I got how the | works... ahhh
14:19:03 <Dread[]> clever... really clever
14:19:26 <liyang> Dread[]: or you could make use of the Maybe a type (constructor), which lets you either have Just a value (in your case this will be a Car) or Nothing.
14:21:16 <Dread[]> so if I want a specific Colour to be attached to a Bool it would be data Car = C Colour Bool | Kind Owner or am I thinking wrong?
14:21:41 <rep> http://kecy.roumen.cz/picccszb23.jpg
14:22:01 <SickJacken> any fans of kung fu movies here?
14:22:37 * boegel|home just posted his first helpfull post on the haskell mailing list and cheers
14:24:12 <SickJacken> boegel, the imperative vs fun. thread?
14:24:55 <Micket> sigh, setting up linux is going to take forever before i can get down to some codign :(
14:25:02 <Micket> *coding
14:25:24 <boegel|home> SickJacken: no, the one about the xxs@(x:xs) notation
14:25:32 <boegel|home> in the autrijus thread
14:25:42 <liyang> Dread[]: thinking wrong... :(
14:26:09 <Dread[]> liyang: alright, back to the drawingboard
14:26:14 <liyang> What do you mean by a specific colour attached to a Bool? I can't parse that sentence...
14:27:07 <SickJacken> boegel, i only see a reaction by Philippa and john something
14:27:56 <Dread[]> lets say that if a car is green, i want to remember if its green metallic or green non-metallic by attaching a Bool to data Car = c Colour Kind Owner, but this should only be possible if the color is green...
14:28:56 <boegel|home> SickJacken: it'll take a while probably, my isp is quite slow with delivering mails (for some strange reason)
14:29:34 <liyang> Dread[]: then you should add two different constructors to the Colour datatype, one for Green and another MetallicGreen
14:29:58 <SickJacken> owww you just submitted it
14:30:02 <boegel|home> SickJacken: yeah
14:30:04 <SickJacken> check
14:30:12 <liyang> Dread[]: Or have data Colour = ... | Green Bool | ...
14:30:26 <boegel|home> SickJacken: I'm guessing it'll take 15m, but it could be longer
14:30:27 <SickJacken> is it useful to report dead links in the ghc doc...or would that be "mierenneuken"
14:30:33 <liyang> (So instead of writing Green you'd write (Green True) or (Green False)
14:30:46 <Dread[]> alright. Last question for tonight. I have a function compare color :: C -> C =
14:31:33 <liyang> Shouldn't it be Colour -> Colour -> Bool?
14:31:47 <Dread[]> yea my bad
14:31:52 <boegel|home> SickJacken: fucking ants
14:31:52 <boegel|home> ;)
14:32:25 <Dread[]> liyang: Anyhow, I dont want to give colors into it, I want to send in cars into my compare color.
14:32:40 <SickJacken> thought so
14:32:42 <liyang> mmkay...
14:32:48 <Dread[]> can I write | car1 colour == car2 colour = False
14:33:43 <liyang> Not quite.
14:33:55 <boegel|home> I'm off to bed
14:33:59 <boegel|home> g'night
14:34:12 <Dread[]> Do you understand at all what I want to do or am I not making any sense at all? :)
14:34:25 <liyang> compareCarColour (C c _ _) (C c' _ _) = c == c'
14:34:47 <liyang> will test to see if two cars have the same colour
14:34:50 <SickJacken> gnight
14:34:53 <Dread[]> where _ is anything
14:35:05 <liyang> *nod*
14:35:08 <liyang> _ matches anything.
14:35:21 <Dread[]> aye
14:36:00 <liyang> I hope I'm not doing your homework for you. ;)
14:36:20 <Dread[]> no, the course starts in 2 months and its said to be really hard
14:36:40 <Dread[]> Im preparing like hell becuase my whole semester stands and falls with this course...
14:37:56 <liyang> What books have you there?
14:38:22 <SickJacken> no matter what boegel says...for the record...the link "http://www.haskell.org/~simonmar/libraries/libraries.html" in ghc manual 7.3.1 is dead
14:38:36 <Dread[]> Graham Hutton - Programming in Haskell and Simon Thompson Haskell The Craft of FUnctional Programming SE
14:40:33 <liyang> Dread[]: heh. I started with Hudak's book. Not seen Graham's... Thompson's I heard is good.
14:41:13 <Trinity> if i have like this ["i", "was", ..] and i have another list [("i", "you"), ("was", "were")] are there an easy prelude function for matching this ?
14:41:27 <Dread[]> I get Undefinied constructor function "c" from your example above
14:42:21 <liyang> Trinity: \xs ys -> xs == map fst ys
14:42:58 <dcoutts> xerox, ping!
14:43:00 <liyang> Dread[]: C is the (only) constructor for Car right?
14:43:36 <SickJacken> hmmmm
14:43:53 <SickJacken> using STArrays weaves into every function of mine
14:44:16 <SickJacken> no use using STArrays if i have to call runSTArrays within every function is there?
14:44:23 <Dread[]> yea
14:44:35 <Dread[]> but it's the small 'c' it complains about
14:46:11 <liyang> but the small 'c' isn't used in a constructor position...
14:46:46 <Dread[]> i know... I thought it was a variable just used for the purpose of comparing
14:47:18 <Trinity> liyang: can you explane that one dont really understand :)
14:47:26 <Dread[]> never mind, I'll go to bed now. Too late here :)
14:48:03 <SickJacken> only the first place is for a constructor...the rest of the places are occuped by types
14:48:12 <SickJacken> in the definition of a datatype
14:48:36 <SickJacken> data Name = <<constructor>> <<type>> <<type>> ....
14:48:36 <TheHunter> @type Data.Maybe.mapMaybe lookup
14:48:38 <lambdabot> bzzt
14:49:33 <liyang> Trinity: I presume you have a list xs and a list of pairs ys. And you wanted to compare xs with the first of each pair in ys...
14:49:45 <TheHunter> @type Data.Maybe.mapMaybe . flip lookup
14:49:47 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [a] -> [b]
14:49:49 <Trinity> yes
14:49:59 <Trinity> and i want the second result
14:50:11 <liyang> given some (a, b), fst (a, b) == a.
14:51:17 <SickJacken> omg using STArrays infects all your functions ofcourse because of the state monad
14:51:18 <liyang> so map fst [(a1, b1), (a2, b2), ...] == [a1, a2, ...]
14:51:25 * SickJacken thumbs his head to the wall
14:52:46 <Trinity> hmm if  a = ["i", "was"] b = [("i", "you"), ("was", "were")]   here i want answer like ["you", "were"]
14:53:30 <TheHunter> @eval (mapMaybe . flip lookup) [("i", "you"), ("was", "were")] ["i", "was"]
14:53:32 <lambdabot> ["you","were"]
14:53:57 * SickJacken ponders what evil purpose this function will have
14:54:50 * shapr boings happily!
14:56:08 <SickJacken> isnt it like really late in scandinavia now?
14:56:20 <shapr> Um, maybe?
14:57:12 <Micket> Nah
14:57:25 <Micket> 11:43 PM in sweden.
14:57:26 <SickJacken> hey shapr, tell me....i have a lot of function that for example draw an element out of a map, do something with it....modify the map etc.....now i want to try STArrays for space efficiency....but this is going to infect all the functions with ST right?
14:57:56 <SickJacken> because doing runSTArray in each of these functions would pretty much rape the concept i think
14:58:19 <SickJacken> ow i thought scandinavia was more than gmt+1
14:58:26 <SickJacken> it seems so far away
15:00:48 <kosmikus> SickJacken: more in which direction?
15:01:43 <Micket> Hmm. Any irssi users here? got a little question
15:02:00 <SickJacken> kosmikus, is that comment targeted towards my perception of where scandanavia lies or my STArrays question?
15:02:42 <kosmikus> where scandinavia lies ;)
15:06:50 <SickJacken> well since im to the left of scandinavia on my roadmap...i thought it would be like gmt+2 or +3
15:13:09 <Trinity> (mapMaybe . flip lookup) [("i", "you"), ("was", "were")] ["i", "was"] = ["you","were"]  but if i have [("i", "you"), ("was", "were")] ["i", "was", "never"] = ["you","were","never"] so it includes nonmatches
15:15:05 <SickJacken> @type mapMaybe
15:15:07 <lambdabot> bzzt
15:15:13 <SickJacken> @index mapMaybe
15:15:14 <lambdabot> Data.Maybe
15:15:26 <SickJacken> @type Data.Maybe.mapMaybe
15:15:27 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
15:15:31 <SickJacken> duh
15:16:05 <SickJacken> mapMaybe (_ -> Nothing) [1,2,3]
15:16:09 <SickJacken> @eval mapMaybe (_ -> Nothing) [1,2,3]
15:16:10 <lambdabot> 30: parse error on input `->'
15:16:16 <SickJacken> @eval mapMaybe (const Nothing) [1,2,3]
15:16:17 <lambdabot> <Plugins.Eval>:1:12:
15:16:17 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:16:17 <lambdabot>   `Show a' arising from use of `show'
15:17:01 <Cale> @eval mapMaybe (const Nothing) [1,2,3] :: [Integer]
15:17:03 <lambdabot> []
15:17:18 <SickJacken> ow right
15:17:59 <SickJacken> @eval lookup "never" [("i","you"),("was","were")]
15:18:01 <lambdabot> Nothing
15:18:34 <SickJacken> @eval mapMaybe (flip lookup [("i","you"),("was","were")]) ["never"]
15:18:35 <lambdabot> []
15:18:44 <SickJacken> explain Trinity
15:19:10 <Trinity> [("i", "you"), ("was", "were")] ["i", "was", "never"] = ["you","were","never"]  << answer
15:19:30 <SickJacken> @eval mapMaybe (flip lookup [("i","you"),("was","were")]) ["i", "was", "never"]
15:19:31 <lambdabot> ["you","were"]
15:19:35 <SickJacken> i dont see never here
15:19:43 <Trinity> exactly but i want never there =)
15:19:48 <SickJacken> owww
15:19:49 <SickJacken> lol
15:19:53 <SickJacken> totally misunderstood
15:19:56 <Trinity> ah :)
15:22:29 <SickJacken> @eval mapMaybe (\e -> (maybe id e (flip lookup [("i","you"), ("was", "were")]))) ["never"]
15:22:30 <lambdabot> 41:
15:22:30 <lambdabot>   Expecting a function type, but found `b'
15:22:30 <lambdabot>   Expected type: Maybe b
15:22:30 <lambdabot>   Inferred type: a -> a
15:22:58 <basti_> cu all
15:23:00 <SickJacken> @eval map (\e -> (maybe id e (flip lookup [("i","you"), ("was", "were")]))) ["never"]
15:23:03 <SickJacken> cu
15:23:03 <lambdabot> 42:
15:23:05 <lambdabot>   Expecting a function type, but found `Maybe a'
15:23:07 <lambdabot>   Expected type: Maybe a
15:23:09 <lambdabot>   Inferred type: a1 -> c
15:23:11 <lambdabot>   Probable cause: `flip' is applied to too few arguments in the
15:23:14 <lambdabot> call
15:23:15 <lambdabot>    (flip lookup [("i", "you"), ("was", "were")])
15:23:36 <SickJacken> @eval map (\e -> (maybe id e (lookup e [("i","you"), ("was", "were")]))) ["never"]
15:23:37 <lambdabot> Couldn't match `b -> a -> a' against `[Char]'
15:23:45 <SickJacken> geez im so tired
15:24:18 <SickJacken> @eval map (\e -> (maybe e id (lookup e [("i","you"), ("was", "were")]))) ["never"]
15:24:20 <lambdabot> ["never"]
15:24:31 <SickJacken> @eval map (\e -> (maybe e id (lookup e [("i","you"), ("was", "were")]))) ["never", "i", "was"]
15:24:32 <lambdabot> ["never","you","were"]
15:24:55 <SickJacken> probably can be more elegant...but hey...its 0:15
15:26:31 <Trinity> what does id function do ?
15:26:58 <Cale> @type id
15:27:00 <lambdabot> forall a. a -> a
15:27:04 <Cale> @eval id 5
15:27:06 <lambdabot> 5
15:27:15 <Cale> @eval id "Hello"
15:27:17 <lambdabot> "Hello"
15:27:23 <Cale> id x = x
15:27:36 <manulito> this conversations is getting logged and mailed to cs@efd.lth.se
15:27:36 <Trinity> ?? whats the point ?
15:27:45 <manulito> xiit =))
15:28:01 <Cale> manulito: hm?
15:28:18 <manulito> nothing :> i think we are working on the same assigment for school
15:28:27 <Cale> Trinity: It's the identity function
15:28:35 <Trinity> :) maybe..
15:28:58 <manulito> Trinity: what part of the problem are you working on ?
15:29:01 <Cale> It comes in handy whenever you need a function value that doesn't do anything to its parameter
15:29:17 <SickJacken> because maybe expects a (a -> b) function at that place
15:29:37 <SickJacken> and i dont want to do anything but return the translated word...so i use id
15:29:52 <Trinity> ahh ok,
15:30:15 <SickJacken> @index trim
15:30:16 <lambdabot> bzzt
15:30:20 <SickJacken> @hoogle trim
15:31:05 <SickJacken> @eval dropWhile (`elem` [' ', '\n', '\t']) "       ds"
15:31:06 <lambdabot> "ds"
15:31:40 <Cale> @eval dropWhile (`elem` " \n\t") "       ds"
15:31:42 <lambdabot> "ds"
15:31:45 <SickJacken> heheh
15:31:54 <SickJacken> sometimes i overcomplicate the obvious
15:32:12 <Cale> well, it does kind of make more sense as a list
15:32:20 <SickJacken> so focused on the fact that there should be a list there
15:32:32 <SickJacken> without realising im writing a list of chars instead of a string "_
15:32:34 <SickJacken> :)
15:32:39 <Cale> @eval dropWhile (isSpace) "       ds"
15:32:41 <lambdabot> "ds"
15:32:53 <Cale> isSpace c =  c `elem` " \t\n\r\f\v\xA0"
15:33:08 <SickJacken> is that the truth...or a custom fun
15:33:13 <Cale> It's in Char
15:33:15 <SickJacken> @eval isSpace "\n"
15:33:16 <lambdabot> Couldn't match `Char' against `[Char]'
15:33:19 <SickJacken> @eval isSpace '\n'
15:33:20 <lambdabot> True
15:33:33 <SickJacken> so its really isWhiteSpace instead of isSpace
15:33:53 <Cale> well, (== ' ') is too trivial to name :)
15:33:55 <SickJacken> cause i think about ' ' when it says...isSpace
15:34:06 <SickJacken> sure, but the name is not handy imho
15:34:23 <SickJacken> but thats probably just bitchin from my side
15:34:27 <Cale> It just matches any kind of space character
15:37:47 <SickJacken> @type replicate
15:37:48 <lambdabot> forall a. Int -> a -> [a]
15:40:21 <Dread[]> how the hell do I make a data type that can be either of the kind Square = Sq Int Int OR sq String ?
15:40:35 <Dread[]> data Square = Sq Int Int | sq String doesn't work?=
15:41:44 <Heffalump> data Square = IntSq Int Int | StringSq String
15:42:07 <Heffalump> IntSq and StringSq can be anything you like as long as they start with capital letters and are different from each other
15:43:21 <Dread[]> Im getting this wierd type error and my brain feels fried :)
15:45:24 <SickJacken> hmmmm would concatenating two lists be more expensive than the similar operation with sets.
15:48:22 <jedi`> be a simple filter, that is it must read its input from standard input and write its output to standard
15:48:22 <jedi`> output.
15:48:34 <jedi`> does this mean just reading text from the text prompt
15:48:38 <jedi`> and i read it from using
15:48:59 <jedi`> putStrLn "Please enter a word: "
15:48:59 <jedi`>    word <- getLine
15:49:02 <jedi`> ? :)
15:50:03 <SickJacken> i would say so jedi`
15:50:36 <SickJacken> uhm....+s in ghci does weird things
15:50:46 <SickJacken> (14.22 secs, -2527315204 bytes)
15:50:50 <SickJacken> ...
15:51:18 <shapr> See how many bytes FP saves you?
15:52:54 <Heffalump> SickJacken: depends what you do with the concatenated lists
15:52:58 <jedi`> so basically standard input is just reading in text u type?
15:52:58 <Heffalump> and with the sets
15:53:03 <jedi`> and standard output prints to the screen?
15:54:54 <Cale> Yeah, that +s bug should really be fixed. It's been there a long time.
15:55:17 <Igloo> Is it an overflow or what?
15:55:21 <Cale> I don't know
15:55:50 <jedi`> anyone?
15:56:20 <Cale> jedi`: hm?
15:56:25 <Cale> yeah
15:56:41 <Cale> well, that's the default behaviour of most shells
15:56:51 <Cale> but in any decent shell, they can be redirected
15:57:07 <Cale> so that the standard out of one program is hooked up to the standard in of another, say
15:57:37 <Cale> or dumped into a file
15:58:40 <jedi`> yep
15:58:47 <jedi`> im doing an excercise is all
15:58:50 <jedi`> so for his specs
15:58:58 <jedi`> it would just be reading from the text he types into it
15:59:06 <jedi`> thats all im trying to clarify hehe
16:00:17 <Cale> yeah
16:00:36 <SickJacken> Heffalump, well i have a tree and over all the branches i synthesize either lists or sets...with every node i join them...so at the root i have the complete thing so to say
16:01:07 <SickJacken> but now that i think of it....i need to have a list because i would have to do a Set.toList after the synthesizing
16:01:19 <Heffalump> do you know about cat elimination?
16:01:30 <SickJacken> maybe :D
16:01:33 <SickJacken> what is it
16:02:13 <Heffalump> it's where you take all the cats you can find, and take them out and shoot them^UA technique for avoiding quadratic blowup when repeatedly sticking lists together
16:03:23 <SickJacken> uhm...im aware that leftnesting is deadly....
16:03:49 <SickJacken> the "shoot them^UA" i dont get
16:05:16 <ndm___> Heffalump, also called accumulation
16:06:41 <Heffalump> ^U is a fake control character
16:07:02 <Heffalump> if you press Ctrl-U in many text mode IRC clients it deletes to beginning of line
16:07:20 <Heffalump> so the "A ..." is the beginning of my serious content.
16:07:32 <SickJacken> aha
16:07:34 <Heffalump> and yes, cat elimination/accumulation is a standard technique for avoiding left-nesting
16:07:59 <Heffalump> instead of writing functions of type getList :: Tree a -> [a]
16:08:05 <Heffalump> you write accumList :: Tree a -> [a] -> [a]
16:08:22 <Heffalump> and pass in the list so far, and ask for the bits from the Tree to be stuck on the beginning
16:08:46 <Heffalump> (you have to take care to call things in the right order to get the result in the order you want, but if you were considering sets anyway you presumably don't care about that)
16:09:27 <SickJacken> this would have been my approach...if i wasnt using Attribute grammars :D
16:09:44 <SickJacken> which is compositional
16:10:05 <ndm___> any idea why Haddock documents sometimes contain instances involving "???" ?
16:10:07 <Heffalump> you can compose functions of type [a] -> [a] using .
16:10:36 <SickJacken> i yes i can ofcourse, it doesnt mean a thing im using AGs...i just synthesize a ShowS kind of thing
16:10:39 <Heffalump> ndm___: it couldn't resolve the reference? </guess>
16:10:48 <SickJacken> compose the functions that do the accumulation
16:10:59 <SickJacken> im definitly not sharp anymore
16:11:08 <Heffalump> SickJacken: right. Standard technique for turning an entire AG into a one synthesised attribute of type Inh -> Syn
16:11:24 <ndm___> but if its trying to resolve a ref, then it must have a name, so why not output the name instead of ???
16:11:26 <Heffalump> (this is just a special case of that)
16:11:32 <Heffalump> ndm___: dunno
16:11:53 <SickJacken> well im off
16:11:54 <SickJacken> gnight
16:11:55 <ndm___> ah well, unfortunate but will have to live with it
16:12:10 <ndm___> maybe even have a HaddockKnowsNothing class...
16:22:57 <jedi`> Can someone explain how interact works
16:23:01 <jedi`> i am not sure what it means
16:23:11 <ndm___> @hoogle interact
16:23:12 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
16:23:20 <ndm___> you give it a function, i.e. id
16:23:32 <ndm___> and it takes the input stream, transforms it via the function, and gives an output stream
16:23:48 <ndm___> i.e. interact id will echo your stream
16:23:56 <Cale> interact f  =  do hSetBuffering stdin  NoBuffering
16:23:56 <Cale>                   hSetBuffering stdout NoBuffering
16:23:56 <Cale>                   s <- getContents
16:23:56 <Cale>                   putStr (f s)
16:24:27 <Cale> the hSetBuffering just makes sure that output appears and input is read as soon as possible
16:25:27 <jedi`> hmm
16:25:46 <ndm___> jedi`, what in particular are you aiming for?
16:25:50 <jedi`> so does it take in what is parsed after the program name when it is run
16:26:00 <ndm___> no, thats getArgs
16:26:08 <ndm___> the command line arguments
16:26:13 <ndm___> @hoogle getArgs
16:26:14 <lambdabot> System.getArgs :: IO [String]
16:26:40 <ndm___> already parsed into parameters, separated by spaces and observing quotes etc
16:27:19 <jedi`> http://pastebin.com/365004
16:27:27 <jedi`> thats the format i have to use for this excercise
16:27:58 <jedi`> i dont understand how to use it though
16:28:20 <ndm___> ignore the interact bit
16:28:20 <jedi`> where does the user put his input in
16:28:35 <ndm___> cs
16:28:40 <ndm___> cs becomes the user input
16:28:59 <jedi`> how do you mean
16:29:05 <jedi`> can you give an example as i dont understand
16:29:10 <ndm___> if you ran that, then typed "hello"
16:29:17 <ndm___> then the value of cs would be "hello"
16:29:28 <jedi`> where would i type hello but
16:29:32 <jedi`> ?
16:29:36 <ndm___> at the console
16:29:42 <ndm___> are you on windows?
16:29:48 <jedi`> can u show me an example program using that structure to say
16:29:53 <jedi`> times every number by 2
16:29:57 <jedi`> just for a simple example
16:30:05 <jedi`> of how i implement my program using interact
16:30:18 <ndm___> just on the body put cs
16:30:26 <ndm___> and you'll see it echo your characters
16:30:39 <ndm___> or |map toUpper cs|
16:30:43 <ndm___> and it will upper case them
16:30:46 <jedi`> i need to see an example, isnt making sense
16:32:10 <ndm___> where it says, put your code here
16:32:18 <ndm___> write: map toUpper cs
16:32:22 <jedi`> okei
16:32:24 <ndm___> and add import Data.Char at the top
16:34:09 <jedi`> i got it now
16:34:13 <jedi`> so it just takes whatever is input
16:34:30 <jedi`> and it just recurses infinitely until you close the program?
16:35:10 <ndm___> yeah
16:35:14 <jedi`> got it :)
16:35:18 <ndm___> Ctrl + Z might finish the list
16:35:21 <ndm___> but not sure
16:35:27 <jedi`> now, all i need to do is find a way to match text hehe :)
16:35:58 <int-e> @eval lines "abc\ndef\nhij\n"
16:36:00 <lambdabot> ["abc","def","hij"]
16:47:33 <jedi`> @eval words "eggs are good"
16:47:35 <lambdabot> ["eggs","are","good"]
16:48:12 <jedi`> what is the easiest way in haskell to scan a line of text for a word
16:48:31 <jedi`> For instance, if i wanted to replace every instance of the word shit, with sugar in a input line
16:48:38 <jedi`> how would i best go about that?
16:52:53 <ndm___> use words
16:52:55 <ndm___> and lines
16:53:07 <ndm___> @hoogle words
16:53:07 <lambdabot> Prelude.words :: String -> [String]
16:53:07 <lambdabot> Prelude.unwords :: [String] -> String
16:53:31 <jedi`> yeah but words is delimited by spaces
16:53:42 <jedi`> i need it to recognise every instance of the string "shit"
16:53:44 <jedi`> and replace it
16:53:52 <jedi`> like sdfjsdkfjshitsdfkjdfjks
16:53:55 <jedi`> would need to become
16:53:59 <jedi`> like sdfjsdkfjsugarsdfkjdfjks
16:53:59 <jedi`> hehe
16:57:55 <Heffalump> is this homework? :-)
17:00:59 <jedi`> no it isnt haha
17:01:03 <jedi`> im asking a really general question
17:01:26 <ulol> have you looked at filter
17:01:39 <jedi`> thats how it is done i have read
17:01:45 <jedi`> i dont know how to use it
17:02:33 <Heffalump> replace str | take 4 str == "shit" = "sugar" ++ replace (drop 4 str)
17:02:46 <Heffalump> replace [] = []
17:02:51 <Heffalump> replace (x:xs) = x:replace xs
17:02:57 <humasect> can one filter (\(x:xs) -> ...) "sadfasdfasf" ?
17:03:11 <Heffalump> not very efficient, but it'll work
17:03:28 <jedi`> ok
17:03:36 <jedi`> what about filter, what is the method for using filter
17:03:37 <jedi`> :)
17:03:51 <humasect> definately homework
17:04:00 <ulol> http://www.zvon.org/other/haskell/Outputprelude/filter_f.html
17:04:37 <jedi`> thats perfect
17:04:46 <jedi`> however, that totally gets rid of it
17:04:55 <jedi`> i need to replace the text with new text
17:04:56 <jedi`> hehe
17:05:19 <liyang> Oh my. Has the new school term started already?
17:05:25 <ulol> perhaps you need to iterate though the string checking for each Char
17:06:09 <jedi`> hmmm
17:06:42 <humasect> i lost that page describing a custom main() for hs apps but with a ghci-like toplevel. maybe it was the wiki
17:11:10 <Heffalump> there's no way you can do it with filter.
17:11:18 <ndm___> words
17:11:37 <ndm___> then you can use map
17:13:19 <jedi`> so i split it into words
17:13:33 <jedi`> and map it how?
17:14:24 <Heffalump> you can't use words if you want to replace like you said above
17:14:30 <Heffalump> anyway, what's this for?
17:28:03 <neadjneki> it's for replacing shit with sugar ;)
17:33:07 <ulol> what is a wild cared for any integer?
17:33:13 <ulol> *card
17:34:36 <dcoutts> @seen xerox
17:34:37 <lambdabot> xerox is in #haskell-blah and #haskell. Last spoke 1 day, 5 hours,
17:34:37 <lambdabot> 25 minutes and 56 seconds ago.
17:34:52 <int-e> you mean something like
17:34:58 <int-e> @eval map Data.Char.isDigit "abc12e3f"
17:35:00 <lambdabot> [False,False,False,True,True,False,True,False]
17:35:02 <int-e> ?
17:35:26 <ulol> hmm
17:35:28 <ulol> yes i think so
17:35:32 <ulol> ill try that thanks
17:36:27 <int-e> @eval let i::Integer; i=read "123" in i
17:36:29 <lambdabot> 123
17:37:54 <elmrfudd> anyone use erlang?
17:46:47 <Cale> @eval read "123" :: Integer
17:46:49 <lambdabot> 123
17:51:16 <int-e> Heh. I was trying to produce an example that's closer to a top level declaration.
17:51:35 <ulol> hmm what is this error ' Warning: Pattern match(es) are overlapped'
17:51:58 <Igloo> One of your definitions is unreachable
17:52:10 <int-e> it means that there are invokations of your functions that match more than one pattern
17:52:21 <ulol> ah ok
17:52:30 <Igloo> No, it is stronger than that
17:52:47 <ulol> ok, it was because i was trying to match a wild card..
17:52:49 <int-e> for example f (_,'a') = 1, f ('b',_) = 2; would produce that error because f ('b','a') matches both
17:53:07 <Igloo> No it wouldn't
17:53:35 <ulol> i want to find [0-9]
17:53:57 <ulol> 'x':xs' -> add xs'
17:54:49 <ulol> i want x to be any integer?
17:55:38 <int-e> Igloo: oh! thank you.
17:59:12 <ulol> should i be able to use isDigit in this instance int-e
18:06:39 <humasect> is -fffi required for import Foreign.* ?
18:07:08 <int-e> ulol: I'd reuse Haskell's read (resp. readsPrec) functions to parse integers.
18:08:33 <int-e> @type readsPrec
18:08:34 <lambdabot> forall a. (Read a) => Int -> ReadS a
18:08:45 <ulol> hmm
18:09:06 <ulol> it is an input.. but ther emay be chars in front or after it
18:09:46 <ulol> "X235", "X43656X" etc
18:10:16 <ulol> i want to see if there is an Int after the X
18:10:55 * int-e isn't quite sure what a good, accessible way to do that would be.
18:11:06 <ulol> hehe
18:11:36 <ulol> isDigit'3':xs' -> add xs'
18:12:06 <heatsink> Is there a search feature in the haskell.org mailinglist archives?
18:12:17 <ulol> google?
18:12:19 * heatsink wants to search the template haskell mailing list archives
18:14:01 <int-e> I guess you could do something like getNonDigits l = span (not.isDigit) l.  getDigits l = span isDigit l. the first takes a string and returns a pair of two lists - the first containing the string up to the first digit and the second the rest of the list.
18:15:32 <ulol> yeah
18:15:36 <ulol> maybe il have to do that
18:15:38 <int-e> and then f l@(c:_) | isDigit c = let (digits, rest) = getDigits l; number = read digits :: Integer in [do something with number and the rest]
18:15:58 <jedi`> ulol: join #haskellhelp
18:16:14 <int-e> (the l@ just gives the matched pattern (c:_) a name)
18:16:27 <ulol> k
18:17:36 <ulol> i now get the pattern overlapped error again..
18:17:39 <ulol> lol
18:18:17 <int-e> well, put the more general patterns after the special patterns
18:24:31 * SamB wishes that the three-finger solute offered some kind of quick-kill/unpin option for those pesky fullscreen apps...
18:24:55 <int-e> 'shutdown computer'
18:25:28 <SamB> without killing everything else!
18:25:40 <heatsink> SamB: Does Alt-Tab work?
18:25:46 <heatsink> or Alt-Esc
18:25:53 <SamB> heatsink: alt tab? not very well.
18:26:09 <SamB> it shows up, but the fullscreen program is probably halted in a debugger...
18:27:08 * heatsink isn't sure what that means
18:27:25 * SamB also wishes OllyDbg would leave his patches in place from run to run...
18:28:13 <heatsink> well maybe I'll just ask here since I can't find it in html... Is there a way to find out in template haskell if a type is an instance of Integer?
18:29:31 <SamB> well, seeing as Integer is a type and not a typeclass, no.
18:30:00 <heatsink> geh
18:30:03 <heatsink> I meant Integral
18:30:58 <SamB> well, there might be, but it isn't necessarily always going to tell you "yes" when it is
18:33:07 <heatsink> right... I'll be happy if I can do it when there are no type variables or foralls in the type
18:35:04 <SamB> why don't you look in the TH modules?
18:36:38 * SamB sets breakpoint before first patch so he doesn't do that again
18:39:19 <jedi`> how do i return the position of a character in a string
18:39:24 <jedi`> ie "Hello"
18:39:28 <jedi`> how do i find out where e is
18:39:29 <jedi`> ?
18:40:13 <dons> @eval elemIndex 'a' "haskell"
18:40:15 <lambdabot> Just 1
18:40:22 <dons> @eval elemIndex 'z' "haskell"
18:40:23 <lambdabot> Nothing
18:41:01 <dons> @eval elemIndices 'l' "haskell"
18:41:02 <lambdabot> [5,6]
18:41:55 <sethk> @eval elemIndices 'l' "elemental"
18:41:57 <lambdabot> [1,8]
18:42:11 <sethk> @eval elemIndices 'e' "elemental"
18:42:12 <lambdabot> [0,2,4]
18:42:24 <heatsink> wow, template haskell touches a lot of the compiler
18:42:58 <dons> @where hIDE
18:42:59 <lambdabot> http://www.haskell.org/hawiki/hIDE
18:43:39 <heatsink> it doesn't seem to be in the modules anyway
18:44:25 <Cale> heatsink: well, there are the TH modules
18:44:46 <Cale> heatsink: but yeah, there's a good deal of special syntax and such that has to be built into the compiler
18:45:38 <jedi`> how do you import in GHCi
18:45:43 <jedi`> i wanna use elemIndex
18:45:54 <heatsink> jedi`: :module
18:46:05 <dons> :m + List
18:46:12 <jedi`> what module is it in?
18:46:14 <jedi`> List?
18:46:18 <dons> yep
18:46:26 <dons> @index elemIndex
18:46:27 <jedi`> and if i was writing in a haskell program
18:46:27 <lambdabot> Data.List
18:46:31 <jedi`> Data.list
18:46:32 <jedi`> yep :)
18:46:36 <jedi`> Data.List
18:46:58 <dons> you could use List or Data.List. Data.List is better form.
18:47:41 <dons> as an aside, @eval imports List and other by default, which is why you don't need to specify the imports to an @eval cmd
18:47:45 <jedi`> im trying to write a function that finds and replaces an instance of a word
18:47:49 * SamB wonders why directdraw allows setting the display mode when not running fullscreen
18:47:51 <jedi`> but really not having much luck
18:47:55 <dcoutts> hi dons
18:48:19 <jedi`> is the best way to use elemIndex
18:48:24 <jedi`> or would there be an easier way
18:48:30 <dons> hi dcoutts, i'm about to chase up last night's hide work, and have time in the next few days to work on it
18:48:37 <TotaX> Hi. I need a GUI for Haskell? do u know?
18:48:46 <dcoutts> dons, excelent
18:48:53 <dcoutts> TotaX, Gtk2Hs
18:48:57 <dcoutts> @where Gtk2Hs
18:48:58 <lambdabot> http://haskell.org/gtk2hs/
18:49:11 <TotaX> ok. thx
18:49:12 <dcoutts> dons, Lemmih was getting dispirited with looking at yi/hIDE integration
18:49:47 <dcoutts> dons, he was worried it was too much work/skill for him
18:50:12 <jedi`> can someone explain what Just 4 means also
18:50:16 <dons> yeah, I saw. i'll have to work out why. maybe he's just unfamiliar with yi.
18:50:31 <dcoutts> dons, and of course an extansable IDE is not much good without an extensible editor
18:50:34 <dons> i don't think it's too much work, but Lemmih hasn't hacked Yi before
18:50:38 <dcoutts> sure
18:51:03 <dons> right. so i'm looking to get yi in, as per the plan
18:51:19 <dcoutts> is the wx ui code hanging around, that might be a start for us to see the structure/organisation of an alternate ui
18:51:28 <dcoutts> dons, ok sounds good
18:51:50 <dcoutts> dons, and my TODO items are mainly on the IDE shell
18:51:52 <dons> we do have a proposed ui interface, yes
18:52:05 <dcoutts> yes, I've got some ideas
18:52:26 <jedi`> @eval elemIndicies '.' "This is the text to find the .'s in..asdds.asdsdds.asdsd."
18:52:27 <lambdabot> 18: Not in scope: `elemIndicies'
18:52:42 <dcoutts> they're not entirely written down, but you can get an idea from the mockup
18:52:49 <jedi`> @eval elemIndices '.' "This is the text to find the .'s in..asdds.asdsdds.asdsd."
18:52:50 <lambdabot> [29,35,36,42,50,56]
18:52:51 <TotaX> @where Gtk2Hs
18:52:52 <lambdabot> http://haskell.org/gtk2hs/
18:53:07 <dons> ok. i'll ask if i'm stuck, and make notes
18:53:26 <jedi`> alright, so how do i find what is at 29 in a string
18:53:31 <dcoutts> dons, there's some discussion of in on the wiki along with the mockup picture
18:53:46 <TotaX> @where wxhaskell
18:53:46 <dcoutts> dons, but there's no api to work against yet
18:53:47 <lambdabot> http://wxhaskell.sourceforge.net/
18:53:53 <dons> !! jedi`
18:54:15 <dons> also, I'd like to see the booter that gets us into the dynamic code
18:54:29 <dcoutts> you've seen Lemmih's code?
18:54:37 <dons> not yet
18:54:44 <dcoutts> ok, it's not complex
18:54:57 <dcoutts> it'd be good to have you look it over
18:54:58 <jedi`> anyone there?
18:55:13 <dons> jedi`, you want !!
18:55:23 <jedi`> !! ?
18:55:25 <dons> @eval "hhaskell" !! 4
18:55:27 <lambdabot> 'k'
18:55:29 <dcoutts> dons, yi will do multiple views into a single buffer?
18:55:33 <dons> yes
18:55:39 <dons> will do/does for ages ;)
18:55:50 <dcoutts> dons, good, the UI concept rather relies on that
18:55:51 <dons> you can do :split a la vim
18:56:00 <dons> of course.
18:56:02 <jedi`> ok how do i return 4 characters after hhaskell" !! 4
18:56:17 <jedi`> so that it returns "kell"
18:56:21 <jedi`> is that possible?
18:56:34 <dons> @eval take 4 $ drop 3 "haskell"
18:56:34 <Cale> @eval drop 4 "hhaskell"
18:56:35 <lambdabot> "kell"
18:56:36 <lambdabot> "kell"
18:56:42 <dcoutts> dons, I'm imagining that we can have multiple top level windows and so you could view the same file in more than one window, so they must be able to share the open buffer
18:57:19 <dcoutts> and perhaps the split frame thing too if people really find that UI useful
18:57:50 <dons> well, :split is how you create a `window' in ncurses
18:58:03 <dons> in a better gui, :split would instead pop up a new window
18:58:09 <dcoutts> right
18:58:22 <dons> but underneath yi just has a Window type for associating windows with the underneath buffer
18:58:30 <dcoutts> ok good good
18:59:58 <dons> so yi will be a plugin, right? which means I should also cabalise it
19:00:04 <dcoutts> yes
19:00:12 <dons> so yi can be installed properly, and then HSyi.o can be found and loaded
19:00:23 <dcoutts> right
19:01:44 <TotaX> dcoutts: do u know a haskell UI but for kde?
19:02:18 <dcoutts> TotaX, I don't think wxWidgets has a QT backend does it?
19:02:32 <dcoutts> TotaX, there is no Qt/Haskell binding
19:03:15 <dcoutts> TotaX, your best bet is Gtk2Hs or wxHaskell using the Gtk+ backend and a Gtk+ theme to make it look like Qt/KDE
19:03:53 <dcoutts> dons, and the thought was that the gtk/hIDE UI to Yi would do all the hIDE integration stuff so that the Yi core itself doesn't need to know about hIDE
19:04:06 <TotaX> dcoutts: ok. thx.
19:04:13 <dons> yep. seems reasonable
19:04:56 <dons> so we just keep yi as a sort of editor buffer library, in a way.
19:05:03 <dcoutts> so the yi core will no doubt need some generalisations but nothing that would stop it running in a standalone way
19:05:10 <dons> yep
19:05:41 <dcoutts> dons, and as an interface between 'pure' editor plugins (eg syntax aware editing) and the IDE
19:06:51 <dons> yes.
19:06:56 <dcoutts> like I said before, I'm not sure how many assumptions we're going to bump into when we put a Graphical UI on Yi, some of the conventions are rather different
19:07:10 <stumbles> hi
19:07:25 <stumbles> what interesting things can lamdabot do?
19:07:30 <dcoutts> @arr
19:07:31 <lambdabot> Well me hearties, let's see what crawled out of the bung hole...
19:07:45 <dons> ah, but yi has always meant to fully support a graphical ui
19:07:49 <sethk> @arr ???
19:07:50 <lambdabot> Avast!
19:07:55 <dons> if it doesn't, it will be hacked until it does :)
19:08:00 <dcoutts> dons, ok, great :-)
19:08:20 * dcoutts hopes this will cheer up Lemmih 
19:08:37 <dons> yi is only seemingly tied up with ncurses for historical reasons. the reason being that i didn't know any of the gui libs, and terminal editing worked for me
19:08:52 <dcoutts> sure, it's a reasonable place to start
19:09:06 <dcoutts> and it means you can emulate vim + emacs more easily
19:09:31 <dcoutts> dons, I'd love to see how the wx UI worked
19:09:46 <dons> how about FreeHS as a name?
19:10:04 <dcoutts> dons, ok, the reason?
19:10:14 <dons> or Free*. oi.e. FreeHIDE
19:10:22 <dons> just to emphasise that its free!
19:10:26 <dcoutts> :-)
19:10:36 <dcoutts> add it to the wiki
19:10:41 <dons> Open* is another prefix often used
19:10:49 <dons> OpenStudio ;)
19:10:58 <dcoutts> heh heh
19:11:00 <dons> FreeStudio
19:11:07 <dcoutts> HaskellStudio
19:11:51 <dcoutts> VisualStudio
19:11:57 <heatsink> What does yi mean? It looks like "I'm a sheep" to me.
19:11:58 <dcoutts> look at the haming distance on that
19:13:12 * heatsink doesn't know chinese, but recognizes the radical for "I" and the radical for "sheep"
19:13:21 <dons> also, I'm interested in how we encode modules/plugins as values . what does a plugin look like to hIDE? do they have a common api (defined via a class)
19:13:33 <dons> check the Yi wiki heatsink
19:13:46 <dcoutts> dons, no there's no common plugin api
19:13:59 <dcoutts> there's just plugins that provide various interfaces
19:13:59 <dons> is that a decision?
19:14:07 <dcoutts> yes, it's a decision :-)
19:14:21 <dons> ok. what about state inside plugins? how is that managed?
19:14:37 <dons> so it is a very loose coupling?
19:14:44 <dons> unlike lambdabot's tight control of its plugins
19:14:47 <heatsink> thx, I've been wondering.  yi is the only project name I've seen with three different meanings :)
19:14:49 <dcoutts> yes, quite loose
19:14:54 <dcoutts> so I imagine there will be some basic services, like config
19:15:05 <dcoutts> or the reloading suport
19:15:36 <dons> ah, ok. yes, we need to be able to 'grab' the plugin somehow if we ever reload it.
19:16:02 <dcoutts> the base will probably provide some concept of a module/plugin identity that can be used for other services that will do things on a per-plugin basis
19:16:25 <dcoutts> eg config, each plugin will get a private config space (perhaps in addition to some shared config)
19:17:14 <dcoutts> and the UI will need to be able to enumerate loaded plugins and available plugins so the user can make the selction of whick plugins they want loaded
19:17:21 <dons> yes, lambdabot does this via a functionally dependent state type on the Module class
19:17:31 <dons> have you looked at the Module class in lambdabot?
19:17:35 <dcoutts> nope
19:17:46 <dcoutts> I probablyshould :-)
19:18:01 <dons> class Module m s | m -> s where
19:18:28 <dons> provides, amogst other things, moduleName, moduleHelp, moduleSerialize
19:18:39 <dcoutts> I'm not sure a single state for a plugin is the right model for an IDE (though I see why it is for lambdabot plugins)
19:18:41 <dons> moduleInit, moduleExit
19:19:21 <dons> then all plugins export an value of Module type, wrapped in an existential.
19:19:22 <dons> data MODULE = forall m s. (Module m s) => MODULE m
19:19:48 <dcoutts> we can get module name from the .cabal file
19:19:59 <dons> good point
19:20:07 <dcoutts> and the description
19:20:57 <dcoutts> I'm not sure if all plugins will support unloading/reloading
19:21:11 <dons> so it may be jplugins only need: init, exit, and possibly serialise if we want persistent state
19:21:14 <dcoutts> I can see the dynamic connections between plugins getting quite complex
19:21:31 <dons> hmm. that's true. interesting.
19:21:57 <dcoutts> I was also assuming a seperate config subsystem which would obviously be persistent
19:22:14 <dons> ok.
19:22:30 <dcoutts> since while there is obviously private state in each plugin, there will also no doubt be some shared config state
19:22:40 <dcoutts> and a config subsystem can do both
19:22:53 <dons> yes, this is the same as lambdabot
19:23:00 <dcoutts> ok
19:23:09 * dcoutts shoudl really read lambdabot's source more
19:23:44 <dcoutts> dons, so if some modules support unloading then they can register an unload hook when the initialise
19:24:32 <dons> they probably don't know how to actually unload themselves though. they do known how to get ready to be unloaded
19:24:40 <dcoutts> true
19:24:44 <dons> so moduleExit above is the unload hook in lambdabot
19:24:55 <dcoutts> yes
19:25:25 <dcoutts> so the model I imagine is that plugins initialise and register themselves all over the place for all the features/capablites they can provide
19:26:02 <dcoutts> including registering with the core if they have any special abilities like being able to be unloaded
19:26:15 <dons> yep, seems reasonable.
19:26:29 <dcoutts> since preparing to unload involves unregistering all the callbacks and UI entries they made
19:26:40 <dons> yes. good point
19:26:43 <dcoutts> so it's not something that can be done fully automatically I think
19:27:09 <dcoutts> well it mgiht, but it'd require quite a bit of infrastructure to track
19:27:16 <dons> a non-issue in lambdabot too, we rule that any plugin that talks to other plugins (just the dynamic plugin) must be static and never unloaded
19:27:24 <dcoutts> right yes
19:27:53 <dcoutts> I'm happy that plugins can be loaded and neer unloaded, if they can unload it's a bonus
19:28:26 <dons> ok. for an editor-like app it probably doesn't matter if they're not unloadable
19:28:43 <dons> yi doesn't try very hard to unload individual modules, its easier to quit
19:30:12 <dcoutts> yes, whereas for lambdabot it's obviously crucial
19:31:01 <dons> right. only configuration components written in haskell would require unloading (and reloading)
19:31:08 <dons> i.e. config files, if that is what we want to do
19:31:24 <dcoutts> yes, like the lexers
19:31:32 <dons> yep, that  too
19:32:02 <dcoutts> I must also look at how lambdabot does config via plugins since I still don't realyl get it
19:32:15 <dons> lambdabot doesn't, yi does
19:32:18 <dcoutts> oh ok
19:32:24 <dons> lambdabot just reads a module containing a large record
19:32:43 <dons> yi dyn loads (and reloads) a module Config.hs as if it was a plugin
19:32:52 <dcoutts> right
19:32:54 <dons> that module contains a dynamically compiled record
19:33:09 <dons> so you get dynamic configurability, via haskell src fragments
19:33:24 <dcoutts> neat
19:33:33 <dons> e.g. to change the colours on the fly, add something like         style  = ui { modeline_focused = Style blue darkBlue }
19:33:37 <dons> to the Config.hs
19:33:38 <dcoutts> but then it requires anything that uses that config to reload too right?
19:33:48 <dons> yi notices it is out of date, compiles it , loads it, updates the internal state
19:33:56 <dcoutts> that is very cool
19:34:12 <dons> anything that uses the config?
19:34:20 <dons> explicitly, via an import?
19:34:25 <dcoutts> yes
19:34:32 <dons> such ones would be, but you don't structure it like that
19:34:41 <dcoutts> oh
19:34:42 <dons> users of the config module don't exist. only users of the config value
19:34:49 <dcoutts> yes ok
19:35:09 <dcoutts> so they have some reconfigure function and get given the new config
19:35:17 <dcoutts> ?
19:35:44 <dons> they just notice the colour value is different next time functions that care are invoked
19:35:47 <dons> so it is a lazy update ;)
19:35:58 <dons> it could be 'strict', via a reconfigure function, yes
19:36:08 <dcoutts> ah right, so the config componet of the plugin state gets updated
19:36:12 <dons> yes
19:36:16 <dcoutts> and then config values get used from there
19:36:20 <dons> yep
19:36:26 <dcoutts> hmm
19:36:37 <dons> the config plugin is just one more way to provide global settings
19:36:44 <dons> command line params are another way
19:36:54 <dons> defaults hardcoded are a third
19:37:20 <dons> the config plugin just happens to persist across runs, and is encoded in haskell
19:37:25 <dcoutts> the usual gnome config style is 'instant apply' so you react to config changes immediately (even cross process)
19:38:05 <dcoutts> their system uses vars and events when the things change
19:38:06 <dons> i imagine a 'reconfigure' functoin :: Config -> IO () as part of the plugin api could achieve this
19:38:15 <dons> or signals/events, yep
19:38:43 <dcoutts> eg you tell the config subsytem to call you back whenever a certian config item changes
19:39:00 <dons> ah, good idea. that's much more gui-ish
19:39:06 <dcoutts> and there are higher level abstractions on this idea
19:39:19 <dcoutts> Manuels ports concept is very similar
19:39:48 <dons> yep. that would be one way
19:40:18 <dcoutts> the idea of mutable var which tells you when it changes is quite widspread in GUIs and high level GUI abstractions
19:40:29 <dcoutts> (somtimes hidden behind arrow interfaces)
19:40:30 <dons> do Chans work for this?
19:40:39 <dons> or it needs to be more a singleton
19:41:00 <dcoutts> yes indeed, a channel of values is more or less equivalent
19:41:39 <dcoutts> so you ca block waiting for the value to change, then react on the ne value
19:42:14 <dons> or via a thread reading from a Chan that writes that latest value to an MVar
19:42:29 <dcoutts> yep
19:42:38 <dons> the Design page is a bit sparse?
19:42:43 <dcoutts> yes :-)
19:42:53 <dcoutts> feel free to record some decisions
19:42:59 <dons> I will now read the source
19:43:12 <dcoutts> it won't take you long :-)
19:43:29 <dcoutts> and you can build it :-)
19:43:57 <dcoutts> it'd be nice if we could load packages from the user's ghc package.conf file rather than just the global one
19:44:02 <dons> oh, that booter really is short
19:44:14 <dcoutts> it'd mean we could build it without needing root
19:44:16 <dons> we can, or hs-plugins certainl ycan
19:44:28 <dcoutts> but discovering the file name is not trivial
19:44:38 <dcoutts> /home/duncan/.ghc/i386-linux-6.4.1.20050909/package.conf
19:44:45 <dons> loadPackage gets a package.conf arg, so just a matter of finding it ;)
19:44:51 <dcoutts> indeed
19:44:59 <dcoutts> just a matter of finding it :-)
19:44:59 <humasect> i'd like to make a custom toplevel (ghci).. are the methods for interactivity in the C API or GHC API?
19:45:01 <dons> how about using a path found in the configure process?
19:45:24 <dons> yi uses this to remember the path to the yi library
19:45:24 <dcoutts> dons, sure, that'd give use easier access to the $OS $ARCH
19:45:53 <dcoutts> $HOME/.ghc/$ARCH-$OS-$GHC_VER/package.conf
19:45:59 <dons> humasect, hmm. definitely cutting edge stuff there
19:46:24 <dcoutts> humasect, I'd hope it's in the GHC API
19:46:46 <humasect> (i meant C GHC API or haskell ghc api sorry)
19:46:53 <dons> you can write your own ghci-alike using hs-plugins.
19:46:54 <dons>  
19:46:56 <dcoutts> humasect, I may be mis-remembering but I thought that in the cvs HEAD, that ghci had been converted to use the GHC API
19:47:03 <humasect> i have it working great with FFI, but if i have some exports i would have to deal with stubs in a seperate compile stage
19:47:21 <humasect> dcoutts: ohh interesting
19:47:37 <dcoutts> humasect, but don't quote me on it! :-)
19:47:53 <humasect> and of course you guys plan to have hs-plugins in base at some point? =) (i remember some discussion)
19:48:11 <dcoutts> really? that'd be good
19:48:13 <dons> do we? I'm not sure. maybe it could happen. though Cabal is where it's at these days
19:48:35 <humasect> but base has stuff like HGL (x11/w32) ...
19:48:38 <dcoutts> well it'd mean not playing catchup with rts/linker changes
19:48:40 <dons> maybe once 20-30% of haskell apps depend on hs-plugins ...
19:48:58 <humasect> dons: hehe.
19:49:00 <dons> yeah, hs-plugins is probably already more common than HGL, even FGLl
19:49:01 <dcoutts> humasect, well there is a good argment for splitting those out from the base
19:49:21 <dons> yeah, i think the tendency is weight loss, not gain ;)
19:49:28 <humasect> i was thinking of personally updating base's OpenGL to 2.0
19:49:34 * dcoutts would remove HGL, FGL, X11, OpenGL
19:49:38 <dons> and hs-plugins is reasearch software only 1.5 yrs old
19:49:50 <dons> it could do with a year or two more iterations
19:50:06 <dons> hIDE might start to push it a bit, which would be good
19:50:08 <humasect> i would like to keep OpenGL, remove HGL FGL X11, and add SDL and perhaps hs-plugins and that other thing..
19:50:16 <dcoutts> dons, yes :-)
19:50:19 <humasect> hmm
19:50:37 <dcoutts> humasect, OpenGL & SDL are fine as seperate Cabal packages
19:50:45 <dcoutts> in my humbe opinion :-)
19:50:52 <humasect> hm yeah, true
19:51:10 <humasect> and SOE ? (??)
19:51:22 <dcoutts> yep, it's part of HGL
19:51:28 <humasect> (OpenGL counts with Graphics.UI)
19:52:02 <dcoutts> dons, one issue Lemmih and I had with doing cabal packages for plugins is which module to load to find the entry point
19:52:08 <humasect> actually Graphics.* is stale
19:52:17 <dcoutts> humasect, stale?
19:52:44 <humasect> wxhaskell and gtkhs are nice, and do great as cabals
19:52:46 <dcoutts> dons, what convention would you use? we're currently loading the first module in the package in the order in which they appear in the .cabal file
19:53:15 <dcoutts> humasect, yes (though actually neither of those two packages are cabalised)
19:53:39 <dcoutts> dons, which I don't think is terribly satisfactory
19:53:47 <humasect> ah ok
19:53:59 <humasect> wxhaskell has actually a register.bat on windows ~_~
19:54:22 <dcoutts> humasect, Gtk2Hs has an graphical installer on windos :-)
19:54:33 <humasect> the OpenGL binding is great, but i would like 2.0 features for this project - not sure who to contact. on pause.
19:54:38 <dons> hmm. we need a convention
19:54:43 <dcoutts> dons, yep
19:54:52 <dons> well,  a Main module would be nicce
19:54:57 <humasect> windos.. i like it.
19:55:07 <stumbles> do you need to be registered on freenode to use lambabot?
19:55:14 <dons> $package.hs or $package/Main.hs
19:55:15 <dcoutts> humasect, actualyl it was a typo, but I like it too :-)
19:55:30 <stumbles> *lambdabot
19:55:49 <dons> lambdabot should accept msgs from unregistered users I think
19:55:53 <humasect> ^_^ .. i think i will just call out to FFI for now, ghci is working great so far
19:55:55 <dcoutts> dons, well so far we've been doing things like Hide/Thing.hs
19:56:08 <dcoutts> dons, so that's Hide.Thing as a package name
19:56:34 <jedi`> does anyone know of any text replacement functions on the web
19:56:36 <jedi`> that i could adapt?
19:56:50 <dons> yeah, I think loading the module based onas a transformation on the pacckage name is the way to go
19:57:03 <dons> jedi` text replacement?
19:57:14 <dcoutts> dons, but the package name probably doesn't want to be in the module name exaclty, otherwise it be package "hide-gtk-shell" and "Hide.HideGtkShell.Main" as the module name
19:57:16 <humasect> try filter with \(x:xs) -> ...
19:57:52 <jedi`> how does that work humasect?
19:57:54 <dons> what about leaving off the Main?
19:58:03 <humasect> you can't do any privmsg without registering (or logging in) to freenode
19:58:05 <dons> and having the first 'hide-' become Hide.
19:58:16 <dons> hide-gtk-shell -> Hide.GtkShell
19:58:36 <dcoutts> dons, yeah, it's ok, but not a great universal convention, eg for other projects
19:58:50 <dons> true.
19:59:16 <dcoutts> I wonder if there is any .cabal thing we could use
19:59:17 <dons> oh, hIDE needs latest hs-plugins
19:59:22 <dcoutts> dons, yep
19:59:24 <dons> hmm, I wonder if Lemmih needed to do that
19:59:28 <humasect> filter (\(x:xs) -> x ++ xs == "string")  "somethingstringadasda" ... in principle
19:59:33 <dcoutts> dons, do what?
19:59:45 <dons> I'm surprised, as lambdabot seems to do the same kind of loading, without needing access to the guts of hs-plugins
20:00:03 <dons> Lemmih just likes to break all my nice abstractions ;)
20:00:25 <dcoutts> dons, you'll have to ask Lemmih, I'm not really sure why it was needed
20:00:36 <dcoutts> dons, feel free to unbreak it :-)
20:00:51 <dons> I think he couldn't work out how to load functions from a library
20:01:00 <dcoutts> yes
20:01:07 <Cale> humasect: that
20:01:14 <Cale> humasect: that's a type error
20:01:17 <dons> and indeed, the only way is to have a top-level module in a library that exports a single value containing the exposed interface
20:01:34 <humasect> oops x : xs
20:01:58 <dons> that's how hs-plugins was designed -- that we simulate export lists at runtime via records
20:02:05 <dons> anyway, it's not that important
20:02:17 <Cale> jedi`: still having trouble?
20:02:32 <Cale> jedi`: what exactly are you trying to do?
20:03:02 <Cale> replace occurrences of one string inside another?
20:03:05 <dcoutts> dons, that style is ok for when the app expects a praticular interface from it's plugins, but hIDE will be rather more general than that as we said before
20:03:42 <dons> yeah, it's a bit scary though. instead of the plugin specifying its own export list, the caller just calls in
20:03:53 <dons> the opposite of our normal module system
20:03:58 <dcoutts> dons, so I'm expecting each plugin to get nothing more than initialised, and if it wants to hook itself into any other interface then it must regisrer in it's init function
20:04:29 <dons> yep, ok.
20:05:25 <dcoutts> dons, it's not entirely the oppisite, it's somewhat common to provide an interface to allow an unknown implementation rather than just linking directly by importing
20:05:52 <Cale> jedi`: ?
20:05:59 <dcoutts> it's often done by classes, and sometimes by record of functions
20:06:12 <dons> yep, true.
20:06:18 <dcoutts> the latter is what I'd expect to see quite a bit in hIDE
20:06:40 <dcoutts> my ide shell prototype is based around this style
20:06:50 <dons> oh, I need gtk to build hIDE ;)
20:07:05 <dcoutts> dons, well you need it for the ideShell component
20:07:13 <humasect> i can see that hIDE will be great
20:07:20 <dcoutts> try version 0.9.9, or the latest darcs version
20:07:45 <dcoutts> humasect, feel free to add your name to the list of potential contributors :-)
20:07:48 <humasect> can i write C with haskell syntax? (.hsc files?)
20:07:50 <dcoutts> @where hIDE
20:07:50 <lambdabot> http://www.haskell.org/hawiki/hIDE
20:08:18 <humasect> i can see myself putting some effort into it.. i'll try to summarise there, thanks =)
20:08:20 <dons> dcoutts, where's the darcs repo?
20:08:33 <dcoutts> humasect, .hsc files are Haskell files with FFI preprocessor directives
20:08:35 <dons> dont't worry, i'll grab the .tar ball
20:09:01 <dcoutts> darcs get http://haskell.org/gtk2hs/darcs/gtk2hs/
20:09:22 <humasect> so skellers still need to write C in C
20:10:10 <dcoutts> humasect, well you can write effecient low level code in Haskell, but you might need C for somethings occasionally, like sometimes when interfacing to C libs
20:11:09 <humasect> ah i see. the seperation is good then
20:16:33 <sethk> separation
20:16:36 <sethk> not seperation
20:16:41 <humasect> thanks
20:16:46 <sethk> :)
20:16:48 <humasect> i tried objective caml again the other day
20:17:11 <sethk> humasect, hmm, so did I.  the types of member functions change
20:17:14 <dcoutts> did you feel dirty?
20:17:25 <sethk> humasect, when you invoke them
20:17:43 <sethk> so the "same" object can have instances with member methods that have different types
20:17:52 * dcoutts shouldn't be rude about ocaml
20:17:55 <humasect> yes i actually did feel dirty. i thought this project could use straight hacking with OO and functional mix, i think i needed sleep then.
20:18:00 <sethk> which seems utterly bizarre to me.
20:19:02 <humasect> huh yes that does seem bizarre. i think because haskell seemed like a dream i got lost
20:19:38 <humasect> firstly interfaces and implementations are messy to maintain with little emacs buffer switching
20:20:51 <humasect> i wonder if other newbies making friends with haskell subconsciously want it to be huge and slow to provide some percieved balance
20:22:01 <sethk> perceived.  :)  I don't think so.
20:22:55 <sethk> the haskell syntax just seems for natural to me for some reason
20:26:35 <dcoutts> @index evaluate
20:26:36 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
20:27:53 <dcoutts> @hoogle a -> IO a
20:27:54 <lambdabot> Prelude.return :: Monad a => b -> a b
20:27:54 <lambdabot> System.getEnv :: String -> IO String
20:27:54 <lambdabot> Prelude.ioError :: IOError -> IO a
20:29:17 <humasect> sethk: i probably agree on the natural syntax, even control flow/code organization
20:30:51 <humasect> it could be love. wonderfully simple. hIDE is being prototyped with gtk2hs now?
20:32:50 <dons> yay. hIDE runs :)
20:32:50 <ulol> how do you add a string to the end of another?
20:33:03 <dcoutts> humasect, yep
20:33:06 <humasect> @type (++)
20:33:08 <lambdabot> forall a. [a] -> [a] -> [a]
20:33:15 <dons> ooh. buttons!
20:33:18 <ulol> hmm
20:33:21 <dcoutts> dons, ?
20:33:42 <dcoutts> dons, you've got the UI mockup running?
20:33:59 <humasect> ohh those, images on the wiki.
20:36:05 <dons> dcoutts, yep. runs fine on OpenBSD
20:36:28 <dons> now, where does yi fit in
20:36:56 <ulol> i have : add ('0':a)
20:37:13 <ulol> /but i want to add the 0 onto the end
20:37:16 <dcoutts> dons, you see the big ugly editor pane?
20:37:40 <dons> yep
20:37:44 <dcoutts> dons, to be replaced by a beatuiful Yi widget
20:37:46 <dons> module Main where etc?
20:37:50 <dcoutts> yep
20:38:11 <dons> ok. /me looks and thinks
20:38:17 <humasect> a ++ "0"
20:38:24 <Korollary> ulol: you need a ++ "0"
20:38:35 <dcoutts> or rather a single Yi 'window' since there can be multiple files open and multiple views/windows into each file
20:38:50 <dcoutts> I've been calling them editor pages
20:39:01 <dcoutts> borrowing the eclipse terminology
20:39:26 <dons> ok. i'll try to get a single yi window onto a buffer running in the editor mockup
20:39:32 <dcoutts> ok
20:39:50 <dcoutts> you can edit the .glade file
20:39:58 <dcoutts> remove the editor widget
20:40:12 <dcoutts> and pack something different into the pane
20:40:14 * humasect cheers on
20:40:37 <dcoutts> so the view in the left hand pane is for browsing between files
20:41:25 <dcoutts> dons, no I think the way we'd want to structure that is to keep a single UI widget and just change it's state when we switch between files
20:42:18 <dcoutts> so you'll keep you Window object which holds all the state of a editor page/window and we'd use that to reconfigure the Gtk widget when we change buffers
20:42:33 <dons> ok.
20:42:40 <dcoutts> so that keeps resource usage low when we've got hundreds of files open
20:42:50 <dcoutts> ie when browing the fptools repo :-)
20:42:54 <dons> now, I'm trying to understand the glade stuff. is "GtkTextView" the widget?
20:43:00 <dcoutts> yes
20:43:30 <dcoutts> you're using the glade GUI designer right?
20:43:42 <dons> am I? I'm using vim actually
20:43:47 <dcoutts> oh dear
20:44:01 <dcoutts> you don't want to edit that xml file by hand
20:44:08 <dons> how do entries in that file refer back to actual code to run?
20:44:11 <dcoutts> use glade
20:44:19 <dcoutts> or glade-2 it's sometimes called
20:44:30 <dcoutts> it's a visual gtk gui designer
20:44:50 <dcoutts> dons, check the glade demo in the gtk2hs source tree for a very short example
20:44:57 <ulol> Korollary: i am aiming to do this: http://pastebin.com/365192
20:44:59 <dons> ok
20:45:20 <dcoutts> basically one loads the xml file and then extracts references to widgets by name
20:45:39 <dcoutts> it has to do a dynamic type check at that point obviously
20:46:06 <dcoutts> so the widgets that will be used in the code need sensible names in the gui designer / .glade file
20:46:28 <dcoutts> at the moment I've probably not got any sensible names
20:46:35 <dcoutts> except the top level window
20:50:58 <Korollary> ulol: your comment line is not entirely correct. You are left-padding a string up to 8 characters.
20:51:09 <ulol> ahh
20:51:16 <ulol> yeah i want to add to right :)
20:52:10 <Korollary> ulol: If you are using ghc, you can use this one: http://haskell.org/ghc/docs/latest/html/libraries/base/Text.Printf.html
20:52:26 <dons> dcoutts, now, how do I turn HSyi.o something that can be called a widget?
20:52:33 <ulol> ahh i quickly looked over that, thanks
20:54:33 <dons> we need a small example plugin that runs and prints something in a window
20:55:24 <Korollary> @eval (printf "%08s" "lol")::String
20:55:26 <lambdabot> 19: Not in scope: `printf'
20:55:35 <Korollary> @eval (Text.Printf.printf "%08s" "lol")::String
20:55:36 <lambdabot> 19: Not in scope: `Text.Printf.printf'
20:56:19 <ulol> thats ok Korollary i think im ok
20:56:50 <Korollary> Is Text.Printf no-no for lambdabot because it could return IO a ?
20:57:44 <dons> I'm not sure it could do that.
20:57:56 <dons> it just isn't in the list of expose modules by accident probably
20:59:03 <dcoutts> dons, ok what are you planning to use as the top level widget for the Yi UI?
20:59:41 <dons> I have no idea. I'm totally clueless about widgets
21:00:14 <dcoutts> dons, what was used for the prototype wx yi UI
21:00:43 <dcoutts> whas it a pre-exsiting widget or a custom drawn thing?
21:01:26 <dons> I see no reference to any widgets in the code Wolfgang's passed on to me
21:01:45 <dcoutts> they might be called controls in wx
21:02:10 <dcoutts> but actually it wouldn't be called a widget anyway, but some specific name
21:02:22 <humasect> wxWidgets =(
21:02:26 <dcoutts> dons, do you have that code available
21:02:34 <dcoutts> humasect, good point :-)
21:02:54 <dcoutts> dons, I see two approaches really
21:03:04 <dons> no, I don't have his code
21:03:12 <dcoutts> oh :-(
21:03:16 <dcoutts> 1. do all one's own drawing
21:03:21 <jedi`> die u loser nerd cunts
21:03:28 <dcoutts> 2. cusomeise the GtkTextView widget
21:03:57 <dons> hmm. yi probably wants to do its own drawing, but I can remove that quite easily
21:04:26 <dons> well, since we don't have any code to draw to a gtk ui, then our path is open
21:04:57 <dcoutts> dons, however doing all ones own drawing is tricky, a text widget is rather complex
21:05:10 <dons> right!
21:05:19 <dcoutts> I'd suggest 2. :-)
21:05:36 <dons> so Yi has a buffer, full of text. what's the best way to get that rendered?
21:06:14 <dcoutts> now that's the tricky part, since a GtkTextView is supposed to work with a GtkTextBuffer
21:06:58 <dcoutts> unfortunately the GtkTextBuffer is a concrete object and not an interface
21:07:14 <dcoutts> so we can't pretend to be a GtkTextBuffer
21:07:49 <dcoutts> we would have to abstract the buffer management somewhat
21:08:12 <Korollary> hmm, haskell weekly news spells Kiselyov's first name as Olaf instead of Oleg...
21:08:20 <dons> mistake
21:08:23 <sieni> ough
21:08:40 <humasect> GtkTextView.Text = Yi.Buffer ?
21:09:34 <dcoutts> humasect, not quite sure what you mean there
21:09:48 <dcoutts> dons, it is possible to subclass the GtkTextBuffer
21:10:07 <dcoutts> that's what the GtkSourceView/GtkSourceBuffer does
21:10:26 <dcoutts> I'm not sure how much it'd help, I'd have to look at the code in detail
21:10:31 <humasect> setting the text view's text "string" to yi's buffer when it is convenient..
21:11:00 <dcoutts> humasect, it's not quite that simple
21:11:10 <humasect> didn't think so
21:12:50 <musasabi> morning
21:14:50 <dcoutts> dons, I see the buffer is already a class
21:14:59 <dcoutts> class Buffer a
21:15:34 <dons> yep
21:15:42 <dons> and FastBuffer is the instance we use
21:16:17 <dcoutts> I'm reading through the list of operations and all of them look like they could be implemented on top of a GtkTextBuffer
21:17:35 <dcoutts> instance Buffer Gtk.TextBuffer where ...
21:18:32 <dcoutts> does that seem a reasonable approach?
21:20:17 <dons> hmm. we could do that, I guess
21:20:28 <dons> interesting
21:20:41 <dcoutts> dons, what were you imagining?
21:21:17 <dons> I was imaginging that we could use the native haskell buffer somehow, but this might be quite feasible
21:22:03 <dons> probably things would play togeter nicer
21:22:06 <dcoutts> so yes a possible alternative is to subclass the GtkTextBuffer in C and have that delegate to a Haskell implementation
21:22:32 <dcoutts> but I'm not sure how customisable it is via subclassing, it depends on what virtual methods it has
21:22:40 <dons> urk
21:23:26 <dcoutts> quite
21:23:55 <dons> ok, so that means I need to write an instance of Buffer in terms of the available Gtk ops
21:24:46 <dcoutts> yes
21:25:12 <dcoutts> that probbly means you'll need a wrapper data type
21:25:24 <dcoutts> since you might need some extra small state components
21:26:13 <dcoutts> and the regexp searching is not yet part of GtkTextBuffer but is part of GtkSourceBuffer, but can be used with a GtkTextBuffer
21:26:32 <dcoutts> (it'll go in to the core gtk lib in the next version)
21:26:58 <dcoutts> the GtkTextBuffer has qute a rich api
21:27:20 <dons> ah, yes! I see it does
21:27:36 <dcoutts> the intro is mor readable
21:27:57 <dcoutts> http://developer.gnome.org/doc/API/2.0/gtk/TextWidget.html
21:29:17 <dcoutts> dons, do you have just a single point in the buffer? or is there a point and a cursor
21:29:18 <dons> I might fork (temporarily) yi+gtk to work on this
21:29:24 <dcoutts> it wasn't obvious
21:29:27 <dons> a set of points
21:29:30 <dcoutts> dons, right
21:29:33 <dcoutts> dons, oh ok
21:29:47 <dons> point 0 is the 'cursor'
21:29:51 <dcoutts> that may correspond to a GtkTextMark then
21:29:59 <dons> yep
21:30:03 <dcoutts> or rather a set of them
21:30:20 <dcoutts> so points move with the buffer? ie as things get added/removed?
21:30:37 <dons> hmm. if we move them they do
21:30:47 <dons> the current point certainly moves
21:30:59 <dcoutts> so they're just fixed offsets into the buffer
21:31:03 <dons> marks don't. too hard :)
21:31:49 <dcoutts> so Gtk provides temporary iterators and more permanent marks, the cursor insertion location is a mark
21:32:02 <dons> so then, the yi plugins will consist of a Buffer shown in a widget, implemented on top of GTK.TextBuffer
21:32:15 <dons> this can be drawn nicely by gtk right?
21:32:27 <dcoutts> drawn nicely?
21:32:41 <dcoutts> how do you mean?
21:32:44 <dons> it's easy to pass a TextBuffer to gtk to draw?
21:33:03 <dcoutts> that TextBuffer is connected to the TextView
21:33:13 <dcoutts> whenever the buffer is modifed the view will update
21:33:16 <dons> gtk handles all the hard work of working out what is visible, scrolling etc?
21:33:21 <dcoutts> yes
21:34:02 <dcoutts> you typically don't get flicker from doing buffer operations because of the gtk delayed drawing style
21:41:49 <dons> ok, I'm having a go at implementing a new Buffer instance using gtk.
21:42:09 <dcoutts> ok, shout if you run into trouble
21:42:30 <lament> should i take a class called "definition of programming languages" that uses Scheme, or a class called "functional and logic programming" that uses prolog and haskell?
21:42:40 <lament> considering that i already know everything that will be taught in either course :)
21:43:01 <dcoutts> dons, especially if you find you need gtk functions that are not bound
21:43:13 <dons> ok.
21:43:21 <dcoutts> dons, you built from the darcs verson of gtk2hs?
21:43:21 <dons> i'll just try to get a really simple buffer working first
21:43:27 <dcoutts> yep
21:43:28 <dons> yep
21:43:37 <dcoutts> ok cool, that should make updates easier
21:47:39 <dcoutts> I hope you've got some quickcheck tests for your buffer :-)
21:47:48 <Korollary> lament: I'd take "definition of programming languages" (did you mean that you knew Scheme, or are you really familiar with the course contents ?)
21:48:23 <dons> dcoutts, FastBuffer does, yes
21:49:16 <dcoutts> great (presumably they'll work with a different Buffer instance)
21:49:42 <dons> fingers crossed
21:49:43 <lament> Korollary: i'm pretty sure i'm familiar with the contents, they can't go much farther than sicp
21:49:47 <dons> yeah, they should
21:49:56 <dcoutts> cool
21:51:51 <Korollary> lament: do you have to take one of them ? It'd be easy, but a waste of time as well. Maybe your professor will let you take something else.
21:52:11 <lament> yeah...
21:52:20 <lament> i think the cool courses have these as pre-reqs
22:28:52 <Korollary> What kind of an instance is this "Typeable3 (,,)" in http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Typeable.html#t%3ATypeable3
22:28:56 <Korollary> ?
22:30:00 <humasect> ":set -llibname" doesn't seem to work in .ghci files
22:31:55 <dcoutts> morning Lemmih
22:31:59 <humasect> $B"v(B
22:32:04 <dcoutts> or Lemmih_
22:32:27 <dcoutts> Lemmih, you'll be glad to know that dons is on the case :-)
22:32:47 <dcoutts> Lemmih, he's looking at the Yi/hIDE integration issues
22:33:22 <dcoutts> at the moment he's trying to make the GtkTextBuffer an instance of Yi's Buffer class
22:33:50 <dcoutts> so that we'll be able to use a GtkTextView widget to view a Yi-managed buffer
22:38:30 <humasect> is there a way to load objects without System.Posix.DynamicLinker ?
22:46:25 <gour> morning dcoutts, Lemmih, dons..hIDE devs :-)
22:52:04 <dons> ok, i've created a new yi repo, darcs get --partial http://www.cse.unsw.edu.au/~dons/code/yi+gtk
22:52:46 <dons> I'm thinking along the lines that we break Yi up into a yi-base lib, providing a buffer library with gtk support, and a set of keymap plugins
22:53:33 <dons> the first go at a Buffer implementation based on GTK is in Yi/GTKBuffer.hs
22:56:00 * gour is very happy seeing dons continue with his phd
22:56:28 <dons> :P
22:58:26 <gour> dons, is yi+gtk a new branch of Yi or the focus of Yi development will go to hIDE integration issues?
22:59:12 <dons> I imagine it is a branch, that will end up contributing code back into the normal standalone yi at some point
22:59:37 <dons> however, it is designed to be used as a plugin, so pieces need to be separated out, some code is not relevant, and other code needs to be rewritten
23:01:37 <gour> so, there is still place for a standalone Yi app?
23:01:46 <dons> certainly.
23:02:12 <humasect> hooray to concurrency ! is there a penalty when yielding if not forkIO'd? (to not provide a yield version and a non-yield version of a realtime loop.)
23:02:37 <dons> possibly it may end up using gtk for its ui though
23:03:07 <dons> I won't be getting rid of the curses interface though
23:03:15 <humasect> i'd like to see a Yi window pop up when opening .hs files if i didn't want the whole IDE.
23:03:23 <humasect> (like gnuclient)
23:04:08 <humasect> you guys probably considered collaborative editing, but emacs' server/client functionality is quite useful.
23:09:31 <Korollary> I sometimes wish that I could use the emacs GUI on this machine to an emacs on another machine, heh.
23:10:07 <humasect> gnuclient =)
23:10:16 <Khisanth> hrm you can't?
23:10:26 <Korollary> doesnt that just send a command to open a file ?
23:10:29 <humasect> you can. the server bit manages the buffers too.
23:10:33 <gour> dons: so, after becoming addicted to Yi, we can always use it in a console :-)
23:10:59 <dons> yeah :)
23:11:20 <gour> that's fine, no need to fiddling with any other editor
23:11:45 <gour> i hope vim -> Yi will be a smooth transition
23:11:56 <gour> and no need to wait for a Yzis
23:12:25 * gour is happy about the prospect of being able to settle on Yi-only
23:13:47 <gour> but i'd need Yi to serve as a mutt editor too...
23:19:31 <sieni> What's the status of Yi? For example, is there an emacs-style syntax coloring / indentation mode for C?
23:19:49 <musasabi> humasect: for loading objects you should look at hs-plugins.
23:19:59 <humasect> musasabi: aha, thanks
23:20:11 <humasect> now i will depend on hs-plugins.
23:22:00 <musasabi> as for concurrency benchmark without yield and with yield and use the one which happens to work better (that is related to how scheduling happens so there is no general guideline)
23:22:00 <dons> no colouring sieni. just uncoloured text.
23:22:38 <musasabi> It seems that syntax highlighting is the single most wanted feature in Yi.
23:24:14 <dons> indeed.
23:24:27 <dons> deciding to use ncurses really slowed Yi down
23:24:43 <dons> so much stuff had to be managed by Yi, very painful
23:25:10 <dons> I expect switching to gtk will mean we will get much further along quite quickly
23:25:48 <humasect> musasabi: thanks
23:31:01 <boegel> @y0w
23:31:02 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
23:35:16 * boegel is really enjoying the Functional vs. Imperative thread on the mailinglist :)
23:35:58 <ski> again ?
23:38:33 <boegel> ski: yeah, the new posts eh :)
23:38:39 <juhp> dons: yeah
23:38:49 * ski checks them out
23:39:12 <boegel> "Haskell - the finest imperative language in the world" heh :)
23:39:20 <humasect> o_o
23:40:21 <dons> Lemmih, sent you a hIDE patch
23:41:14 <ski> "ha! little do you know, but you have been actually learning advanced functional programming for 3 chapters now!" :)
23:41:58 <astrolabe> ski, boegel: do you mean haskell-cafe?
23:42:22 <ski> astrolabe : yep
23:42:28 <astrolabe> ta
23:43:58 <ski> boegel : i think whether code in ST and IO monads are side-effectful or not, is just a matter of perspective
23:53:17 <boegel> ski: i didn't grok monads, but now I feel like I'm starting to scratch the surface...
23:53:37 <boegel> ski: someone explained it quite well, i believe it was Cale
23:54:39 <boegel> ski: "However, evaluation of an expression
23:54:39 <boegel> which represents an IO action always yields the same action (even if
23:54:39 <boegel> that action may not do the same thing when it is actually performed in
23:54:39 <boegel> the end)."
23:55:04 <ski> it's useful to think of 'IO' a as 'RealWorld -> (a,RealWord)'
23:55:06 <boegel> so they have no side-effects, it's the action that generates the side-effect
23:55:24 <ski> this explains why evaluating an io-action is not the same as running it
23:55:54 <ski> (first corresponds to evaluating a function, which second corresponds to *calling* the function, on the current world state)
23:56:38 <ski> (e.g. evaluating 'if x > 3 then sin else cos' does not call the function)
23:56:50 <ski> boegel : yep
23:58:15 <musasabi> How are Haskell packages versioned as per cabal?
23:58:20 * boegel is finding this thread very helpfull for him
23:58:37 <musasabi> Is an [Int] + lexical order sufficient?
