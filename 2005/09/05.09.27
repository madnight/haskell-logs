00:21:14 * dons idly wonders if we could embed pugs in hIDE
00:21:22 * autrijus wonders where is this hIDE thing
00:21:32 <dons> @where hide
00:21:34 <lambdabot> http://www.haskell.org/hawiki/hIDE
00:21:43 <autrijus> oh that reminds me. I need to write the VH people to request support for VS2005 Express Edition
00:21:54 <autrijus> as I don't really want to warez vs2003
00:22:32 <dons> autrijus, hIDE loads haskell libraries as plugins. could pugs be library-ified?
00:24:20 <autrijus> dons: sure can
00:24:36 <autrijus> I'm thinking about foreign exporting it anyway
00:24:49 <autrijus> but what you ask is even simpler as I can do it in a way simiiliar to libGHC, right?
00:25:35 <dons> is it even easier, since pugs is pure haskell, being called from haskell?
00:25:40 * Lemmih tries to finish his patch before attending his doctor appointment.
00:26:22 <dons> Lemmih, you can hack in the waiting room ;)
00:27:17 <dons> autrijus, can I link pugs into my haskell program, call it with a string, and get back a haskell value?
00:27:51 <autrijus> dons: sure, though it would be currently in the "Val" type
00:28:13 <autrijus> I need to learn how to make a package and cabal out of it
00:28:38 <dons> easy peasey
00:29:25 <autrijus> I'd appreciate if you, Heffalump, SyntaxNinja, or other #haskell people can walk me thru
00:29:27 <Lemmih> dons: Pushed. You probably need to turn off the haskell-highlight-sourceview-thingy in Yi.
00:29:36 <dons> yep, will do
00:29:39 <autrijus> in realspace during lunch or the upcoming break
00:29:55 <dons> so switch back to TextView, and use Lexer.x for syn hl ?
00:31:12 <Lemmih> SourceView is OK. Just turn off the built-in syntax-highlighting.
00:31:19 <dons> ok.
00:31:27 <Lemmih> We can use SourceView for other things.
00:31:38 <dons> what does it give us?
00:32:31 <Lemmih> Line numbers.
00:32:36 <dons> ah, right
00:33:37 <dons> autrijus, want to chat over coffee?
00:34:08 <autrijus> dons: sure!
00:34:20 <autrijus> dons: find me at the bench outside the left-side door?
00:34:29 <dons> ok
00:34:38 <Lemmih> dons: I'm planning to move most of the code into a CommonSense plugin.
00:34:40 <autrijus> is simonmar at icfp?
00:34:55 <autrijus> jaffacake that is
00:35:07 <dons> yep
00:35:15 <dons> Lemmih, ok :)
00:35:26 * Lemmih takes off.
01:06:54 <autrijus> Igloo, Heffalump: http://nopaste.snit.ch:8001/4413
01:07:10 <autrijus> I changed data into a newtype and did some random cleanup
01:07:13 <autrijus> otherwise identical
01:08:46 <Igloo> Cool, thanks
01:08:50 <autrijus> np :)
01:11:20 <dcoutts> Lemmih, pong.
01:12:12 <dons> dcoutts, what do you reckon about a pugs plugin for hIDE
01:12:28 <dcoutts> why?
01:12:41 <dcoutts> I'm sure it's possible though
01:12:55 <dons> why not? seems an easy way to get a scripting language for hIDE
01:13:09 <dons> (since ghci embedding is a while away)
01:13:17 <dcoutts> oh, not fur users using hIDE for developing perl6 code?
01:13:27 <autrijus> that would rock too :D
01:13:35 <dcoutts> I though we could use Haskell via hs-plugins for scripting
01:13:49 <dons> that's doable, but kinda slow
01:14:05 <autrijus> dcoutts: pugs compilation, although slow, is quite faster than ghc :)
01:14:13 <autrijus> (I mean for program fragments)
01:14:19 <dcoutts> @plugs "isn't too slow it is?"
01:14:24 <lambdabot> "isn't too slow it is?"
01:14:28 <dcoutts> hmm
01:14:35 <dons> yeah, it just seems a very short path -- all we need is libPugs.o
01:14:40 * dons fixes llambdabot
01:15:01 <autrijus> why wouldn't .a work?
01:15:14 <dcoutts> ghci loads the .o files
01:15:25 <autrijus> ah. pugs is already lots of .o files
01:15:31 <dons> yep. the ghc rts linker needs .o
01:15:34 <autrijus> I'm not sure how to merge them into a single .o
01:15:40 <dons> you can convert .aa to .o in one step
01:15:42 <autrijus> cabal handles that too?
01:15:42 <dcoutts> they never implemented loading from .a files
01:15:50 <dons> yep. cabal does tihs
01:15:56 <autrijus> cabal does a lot.
01:16:19 <dons> @bot
01:16:20 <lambdabot> :)
01:16:22 <autrijus> so where do I find a copy of latest cabal, now haskell.org is down?
01:16:29 <dons> @eval "isn't too slow it is?"
01:16:33 <lambdabot> "isn't too slow it is?"
01:16:46 <dons>  no @plugs. maybe i deprecated that
01:18:36 <dons> Igloo, how's bark coming along?
01:18:47 <dcoutts> what's the difference between eval & plugs ?
01:19:03 <dons> alpha-equivalent
01:19:13 <dcoutts> oh ok
01:19:28 <dcoutts> hia SyntaxNinja
01:19:29 <Igloo> I got sidetracked into cabalising bits, then stalled as I couldn't use the packages I'd created on the machine I was developing on  :-)
01:19:49 <dons> doh. i think bark for hIDE would be good
01:19:51 <Igloo> I'll probably get back to it onceI backport ghc 6.4.1 to Debian stable
01:19:57 <dcoutts> bark?
01:20:16 <SyntaxNinja> hi
01:20:21 <dons> with 3 of us hacking away, and lots of testers, it's a little bit tricky to keep track of bug reports
01:20:29 <SyntaxNinja> autrijus: what's the pugs repo?
01:20:33 <dcoutts> dons, however we'd still need an api for the scripting language to use, we don't have that yet
01:20:37 <autrijus> SyntaxNinja: http://svn.openfoundry.org/pugs/
01:20:47 <autrijus> I'll redo the darcs mirror
01:20:58 <SyntaxNinja> thanks
01:20:59 <dons> dcoutts, sure. but, say, :perldo would be easy
01:21:00 <autrijus> using two-way tag-delimited storage suggested by davie roundy
01:21:16 <autrijus> so it won't be that bloody slow, hopefully
01:21:19 <SyntaxNinja> autrijus:  404
01:21:20 <dcoutts> dons, there are places where a little user defined function might be handy though, eg in text searching, or filtering a file view or something
01:21:31 <autrijus> SyntaxNinja: huh.
01:21:36 <autrijus> http://svn.openfoundry.org/pugs/ worksforme
01:21:47 <autrijus> er, subversion.
01:21:47 <SyntaxNinja> oh, it's not darcs?
01:21:49 <arjanb> haskell.org still down?
01:22:00 <dons> i think this plugin==cabal package is going to pay off nicely
01:22:07 <dcoutts> dons, yes :-)
01:22:08 <autrijus> http://perlcabal.org/~autrijus/darcs/pugs/
01:22:12 <SyntaxNinja> dons: yay
01:22:22 <autrijus> SyntaxNinja: that's darcs, but it's going away soon to be replaced by something less slow/klugy
01:22:31 <autrijus> so use svn for now if you can
01:22:34 <SyntaxNinja> what should I use
01:22:34 <SyntaxNinja> ok
01:22:42 <dcoutts> SyntaxNinja, we just need a way of registering in a non-standard package db :-)
01:22:54 <autrijus> plugin==cabal?
01:23:06 <SyntaxNinja> yeah
01:23:12 <dcoutts> autrijus, hIDE plugins are just cabal packages
01:23:14 <SyntaxNinja> it's coming soon
01:23:16 <autrijus> excelelnt
01:23:23 <autrijus> "visual haskell hIDE plugin perspective"
01:24:09 <dons> it's good, as any app that uses cabal only needs to write a little gtk window wrapper over their code to have a working hIDE plugin
01:24:19 <dcoutts> SyntaxNinja, oh great. We'd rather keep the hIDE plugin packages seperate from the users main packages collection since we expect there may be rather a lot of them.
01:24:41 <autrijus> 'separate' as in differnet places or somehow distinguished by tag?
01:25:01 <dons> ~/.hide/plugins.conf or something, right dcoutts?
01:25:05 <dcoutts> seperate as in a different package db, eg ~/.hIDE/plugins.conf
01:25:15 <autrijus> k
01:25:19 <dcoutts> dons, yep :-)
01:26:11 <dcoutts> the other nice thing about using cabal packages for plugins is that it gives us a natural format for plugin metadata
01:26:35 <dons> yep. and we can let SyntaxNinja maintain that code ;)
01:26:48 <dcoutts> eg plugin author, plugin synopsis & description
01:27:03 <dons> why implement something, when some else on #haskell can do it for you ;)
01:27:08 <dcoutts> quite
01:27:19 <SyntaxNinja> :)
01:28:03 <autrijus> Heffalump: I wonder the Patch a b stuff yesterday can be expressed happily in MLF's setting
01:28:29 <autrijus> Heffalump: it obviously does away the need to encode existentials using newtype, but also we can put those stuff into lists
01:29:46 <dons> dcoutts, also, we could load libDarcs.o ...
01:29:54 <dcoutts> oooh
01:30:12 * autrijus mumbles something about "Haskell as the finest dynamic language"
01:30:25 <dcoutts> does darcs provide a sensible api?
01:30:28 <dons> damn straight!
01:30:55 <dons> dcoutts, well, I remember rumours of it
01:31:15 <xinming_Beijing> autrijus: How about perl 6? :-)
01:31:26 <xinming_Beijing> :-P
01:31:33 <dcoutts> "Haskell is a state of the art static functional language; it is also the worlds finest imperitive language and the finest dynamic language"
01:32:21 <dons> :)
01:32:24 <autrijus> xinming_Beijing: maybe perl6 can still take the finest logic language slot ;)
01:32:38 <autrijus> I don't seen haskell going to subsume curry any time soon
01:33:10 <dcoutts> dons, yes I think they were thinking of one but decided to wait 'til there were some applications that wanted to use it, so that they wouldn't just create an api in a vaccume which might end up being useless.
01:33:24 <dons> ah, ok.
01:33:45 <dcoutts> so maybe if we say what we want then we might get it
01:33:54 <dons> yep.
01:34:01 <dcoutts> what would darcs integration look like?
01:34:07 <dons> "why write code, when someone else on #haskell can do it for you"
01:34:12 <dcoutts> from a UI point of view?
01:34:24 <dcoutts> what operations would you expect as a user
01:34:28 <dons> hmm. I wonder what the eclipse ide does
01:34:38 <JohnMeacham> howdy
01:35:50 <dons> well, i'd like to see diffs for one
01:36:00 <dcoutts> dons, have you ever used meld?
01:36:05 <dons> nope
01:36:16 <dcoutts> I reccomend you try it, if one for some ideas
01:36:21 <dcoutts> one/only
01:36:41 <dcoutts> it works with cvs, subversion & arch
01:36:54 <dons> ok. i'll have a look
01:37:03 <dcoutts> and it's a general file/dir diff/merge tool
01:37:13 <dcoutts> but it works well as a cvs interface
01:37:28 <dons> ah, ok. yes, I imagine there's much previous work we could use
01:37:45 <SyntaxNinja> how do you configure pugs to produce pugs_config.h?
01:38:04 <dcoutts> I use it in developing gtk2hs for all cvs stuff except actually comitting
01:38:05 <autrijus> SyntaxNinja: make src/Pugs/pugs_config.h
01:38:16 <autrijus> see the rule for it
01:38:18 <autrijus> in MAkefile
01:38:22 <autrijus> it's genned from util/config_h.pl
01:39:05 <kosmikus> hey, you should have been listening to my talk rather than chatting here ;)
01:39:13 <SyntaxNinja> kosmikus: we were listening!
01:39:18 <SyntaxNinja> it got really quiet in here
01:39:19 <autrijus> but we were!
01:39:25 <dcoutts> dons, http://meld.sourceforge.net/meld_file1.png
01:39:45 <SyntaxNinja> make: *** No rule to make target `src/Pugs/pugs_config.h'.  Stop.
01:39:50 <dcoutts> dons, and the cvs view: http://meld.sourceforge.net/meld_cvs2.png
01:39:58 <autrijus> SyntaxNinja: I also think I'll move the primary integration API to src/Pugs.hs just so not to confuse the Main.hs namespace
01:40:09 <autrijus> SyntaxNinja: have you run Makefile.PL
01:41:24 <dcoutts> http://meld.sourceforge.net/screenshots.html
01:42:21 <SyntaxNinja> autrijus: how do I do that?
01:42:44 <autrijus> SyntaxNinja: "perl Makefile.PL"
01:43:02 <autrijus> there is a INSTALL file :)
01:43:19 <dcoutts> dons, so I can imagine a darcs view of you project (in addition to modules & files views) which gives you diffs of your current version relative to the recorded version
01:43:47 <dcoutts> and then it'd allow you to mark patches to record
01:43:50 <dons> yep, that seems good
01:43:57 <dons> ah, very nice!
01:44:10 <dcoutts> doing the live edit & re-diff might be tricky
01:44:18 <dcoutts> meld manages that feature very well
01:44:23 <dons> also specifying reverts would be nice
01:44:55 <dons> we could highlight diffs using our syn hl as well..
01:45:25 <dcoutts> dons, yes
01:45:32 <dcoutts> yes, viewing/reverting the patch history would be nice too
01:45:47 <SyntaxNinja> what's the deal with this: src/Pugs/Types/Object.hs: file name does not match module name `Main'
01:45:54 <SyntaxNinja> why doesn't it have a module name?
01:47:10 <autrijus> SyntaxNinja: which ghc are you using?
01:47:20 <autrijus> SyntaxNinja: if you do a "make" it should neve rget there
01:47:30 <autrijus> src/Pugs/Types/* are #include'ed into src/Pugs/AST/Internals.hs
01:47:54 <autrijus> that is because GHC 6.4 is horribly broken re mutrec module.
01:48:04 <SyntaxNinja> autrijus: I'm not using Make :)
01:48:09 <SyntaxNinja> OK
01:48:10 <autrijus> figured :)
01:48:26 <autrijus> so we can do it with mutrec or some other way
01:48:31 <SyntaxNinja> #included? you prevert
01:48:33 <autrijus> but if cabal can accomodate with exclusion list, so much better
01:48:45 <autrijus> SyntaxNinja: it's not my fault that mutrec is broken :-/
01:48:52 <autrijus> need to retest with 6.4.1
01:49:18 <SyntaxNinja> where does PreludePC come from?
01:49:23 <SyntaxNinja> I'm using 6.4
01:49:27 <autrijus> k
01:49:57 <autrijus> it's generated by gen_prelude
01:50:06 <autrijus> util/gen_prelude.pl
01:50:52 <autrijus> which is invoked from util/build_pugs.pl
01:51:02 <autrijus> which is the main entry point
01:51:05 <autrijus> in place of ghc --make
01:51:17 <autrijus> so if we switch to cabal, that's the switchpoint
01:51:47 * SyntaxNinja nods
01:52:03 <dons> @seen ndm
01:52:05 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 5 days, 9 hours, 50
01:52:05 <lambdabot> minutes and 47 seconds ago, and I have missed 1 minute and 49
01:52:05 <lambdabot> seconds since then.
01:52:31 <dons> ndm should write a hIDE interface for hoogle.
01:52:35 <autrijus> dons: Data.FPS really rocks. what would it take to get it into core? :)
01:53:19 <dons> just have to merge it with JaffaCake's version he sent me. it supports utf8
01:53:36 <autrijus> ok. actually I'll be willing to do it
01:53:40 <autrijus> if you are not working on it now
01:53:47 <autrijus> how about you send me the jaffacake version?
01:53:57 <autrijus> since I've got use cases for most utf8 things :)
01:53:58 <dons> ok. will do
01:54:07 <autrijus> k
01:54:12 <dons> address?
01:54:18 <autrijus> autrijus@autrijus.org
01:54:26 <dons> can you stick it in darcs?
01:54:40 <autrijus> how do I do that?
01:55:27 <dons> i mean, can you put the merged version in a darcs repo?
01:55:40 <autrijus> I was thinking about just darcs sending it to you
01:55:52 <dons> ok. that would be fine
01:55:54 <dons> good idea
01:56:27 <SyntaxNinja> autrijus: hm. not sure I'll be able to grok your perl build system sufficiently to get cabal going.  it's pretty interesting.
01:56:43 <autrijus> SyntaxNinja: I'm sure if we get a bit time pairing on it during lunch it could work
01:56:50 <SyntaxNinja> sure
01:56:53 <autrijus> SyntaxNinja: I'm willing to take it apart :)
01:57:23 <dons> autrijus, sent
01:57:40 <autrijus> dons: danke
01:58:27 * autrijus hands SyntaxNinja a committer bit, just in case
01:58:39 <SyntaxNinja> :)
01:59:04 <autrijus> invitation sent to your syntaxcops address.
01:59:50 <musasabi> dons: supporting both raw 8bit strings and utf8 would cover for most cases.
02:00:09 <autrijus> ...and optional iconv linkin would be cool too
02:00:11 <autrijus> I've got code for that.
02:00:16 <SyntaxNinja> some DrIFT modules are called DrIFT.Foo and some are just called foo
02:00:34 <dons> autrijus, keep it simple if you want it in fptools though
02:00:36 <musasabi> but please don't make them utf8 by default.
02:00:42 <autrijus> SyntaxNinja: the D.Foo thing is actually used
02:00:53 <autrijus> SyntaxNinja: the other stuff are just there to placate hugs-drift -- we don't build them
02:01:18 <dons> possibly we may just have to keep it standalone, but fast and flexible
02:01:20 <autrijus> see the horrible kluge that is util/drift.pl for the whole story.
02:01:43 <SyntaxNinja> do you use DrIFT.Binary?
02:02:09 <autrijus> yes, but not heavily
02:02:13 <autrijus> I'll happily drop it for the time being
02:02:15 <SyntaxNinja> suggestions for this? Could not find module `Pugs.Internals.RuntimeLoader':
02:02:17 <SyntaxNinja> no, nm.
02:02:28 <SyntaxNinja>   (imported from src/Pugs/External/C.hs)
02:02:48 <autrijus> er, no, that file is obsolete
02:02:49 <autrijus> rm'ing.
02:02:58 <musasabi> The conversion could be one layer on top of fps.
02:03:13 <autrijus> done.
02:03:16 <musasabi> As it has to deal with errors and non-representable characters.
02:03:47 <Lemmih> Hi SyntaxNinja.
02:03:51 <SyntaxNinja> hi Lemmih!
02:04:08 <SyntaxNinja> Lunar^: you got mentioned at ICFP wrt your work on hop
02:04:24 <SyntaxNinja> Lemmih: I mentioned hackage and cabal-get at TFP
02:04:39 <SyntaxNinja> Could not find module `Pugs.Config':
02:04:39 <SyntaxNinja>   use -v to see a list of the files searched for
02:04:39 <SyntaxNinja>   (imported from src/Pugs/Eval/Var.hs)
02:04:40 <Lemmih> Cool. What's TFP?
02:04:45 <SyntaxNinja> Trends in FP
02:05:06 <autrijus> SyntaxNinja: I'll be on the same bench
02:05:11 <Lemmih> dcoutts: Did you see the syntax-highlighting code in hIDE?
02:05:18 <SyntaxNinja> autrijus: I know this isn't quite the right way to do this...
02:05:28 <SyntaxNinja> autrijus: I'll stick around for this talk.
02:07:22 <autrijus> SyntaxNinja: er, sure, I mean after this
02:07:48 <SyntaxNinja> ok
02:08:00 * autrijus focuses back on packedstring merging
02:08:08 <Igloo> You skipping lunch, then?
02:08:30 * Lemmih just earned $100 by volunteering for a medical study. (:
02:08:39 <SyntaxNinja> Lemmih: did they take anything out?
02:08:45 * Igloo drowns in a sea of less-polymorphic-than-expected type errors
02:08:46 <SyntaxNinja> Igloo: I'm not, but I might eat quick
02:08:58 * SyntaxNinja hands Igloo a _real_ type system ;)
02:09:34 <Lemmih> SyntaxNinja: They only took some fluids.
02:10:21 <autrijus> Igloo: port darcs to Morrow :D
02:10:38 <Igloo> http://urchin.earth.li/darcs/ian/patch/Patch.hs - anyone got any ideas?
02:10:38 * SyntaxNinja goes away
02:11:39 <Igloo> Porting it to epigram might be good. If epigram could multiply numbers without using swap  :-)
02:11:44 <autrijus> bah, VS2005 Express Edition isn't any good -- no plugins support
02:11:54 <JohnMeacham> mmmm... monday night drinking.
02:11:56 <autrijus> Igloo: morrow looks far saner :)
02:12:09 <JohnMeacham> and then haskell programing. could one ask for anything more?
02:29:38 <autrijus> dons: so the main difference is you have a skipfield
02:30:10 <autrijus> which mails "tail" superefficient
02:30:24 <autrijus> I assume you want to keep this for the merge?
02:30:52 <autrijus> s/mails/makes/
02:33:05 <dons> slices, you mean?
02:33:17 <dons> so we can make sub strings in O(1)
02:33:24 <dons> yeah, we need to keep that I think
02:34:57 <autrijus> also yours is encoding agnostic
02:35:08 <autrijus> which I think makes a lot of sense as the lowest layer
02:35:35 <dons> oh, good point
02:35:51 <autrijus> it encapsulates the [Word8] viewpoint
02:36:06 <autrijus> as anything upper from there will need encoding and charset information
02:36:16 <autrijus> which would make a good "String" type, but probably not Data.FPS
02:36:17 <musasabi> The lowest layer must encapsulate [Word8] if we wish to read e.g. crypted files.
02:36:41 <dons> be isomorphic to, you mean?
02:36:48 <dons> what do you mean "encapsulate"?
02:37:01 <autrijus> jaffa has
02:37:01 <autrijus> #define CHARTYPE Word16
02:37:01 <autrijus> #define CHARBITS 16
02:37:15 <autrijus> to arbitrarily change storage size
02:37:15 <ayrnieu> randomly, does anyone know of a mirror of http://www.haskell.org/ghc/ ?
02:37:27 <dons> anyone doing anything for lunch
02:37:29 <autrijus> I'm arguing it's not the way to go usually
02:37:41 <autrijus> dons: I'm looking forward to more cabalizing and FPSing
02:37:42 <xinming_Beijing> anyone here can tell me if www.haskell.org is down?
02:37:46 <autrijus> I'll be @ the same bench.
02:37:48 <autrijus> xinming_Beijing: it is
02:37:55 <xinming_Beijing> Why can't I connect to it... :-S
02:37:57 <dons> ok. coming over.
02:37:59 <xinming_Beijing> autrijus: Ok,thanks.
02:38:16 <xinming_Beijing> autrijus: hmm, when will it be back please?
02:38:53 <musasabi> dons: provide a way to work with the readed data like it would be a sequence of bytes.
02:39:22 <xinming_Beijing> autrijus: hmm, maybe I asked a wrong person. :-P
03:20:15 <kolmodin> is haskell.org not responding or is it just me?
03:20:26 <integral> it's not just you
03:21:01 <kolmodin> ok
03:21:19 <Lemmih> Who's in charge of the server?
03:25:34 <dcoutts> Lemmih, I've not seen your syn hl code yet
03:25:40 * dcoutts goes to look at it
03:37:19 <dcoutts> Lemmih, the package loading from the user package db before the global db issue is not fixed yet right? we're waiting on dons for a propper fix in hs-plugins right?
03:37:47 <Lemmih> dcoutts: No, it's done.
03:38:01 <dcoutts> hmm, doesn't work for me I think
03:38:03 <Lemmih> Or so I think.
03:38:22 <dcoutts> or was it fixed in hs-plugins already and I just need to rebuild&install hs-plugins?
03:38:56 <Lemmih> Yeah, it was fixed in hs-plugins.
03:43:07 <Lemmih> Goodnight, #haskell.
03:43:23 <dcoutts> g'night Lemmih
03:43:32 <dcoutts> oh right, I'll re-build hs-plugins
03:43:54 <dcoutts> btw, the syn hl is building/working for me
03:44:01 <dcoutts> I'm just about to read the code
03:44:08 <sylvan> does lambdabot filter out "unsafe" operations before running "@eval"?
03:44:44 <dcoutts> sylvan, ask dons how it works exaclty
03:45:54 <sylvan> maybe hs-plugins should have a feature where you can set it up so it won't load any unsafe code.. that way you can have an interface with actions in the STM monad and be sure that no malicious code can get executed...
03:46:26 <musasabi> What is malicious code?
03:46:35 <musasabi> Haskell would need proper sandboxes first.
03:46:42 <sylvan> basically code that does evil stuff.. like "rm -rf *"
03:46:49 <dcoutts> that'd only be possilbe for code that is built from source, you can't check once it's a .o file
03:47:06 <dcoutts> musasabi, well it's pretty safe so long as you can't do IO
03:47:07 <musasabi> sylvan: that is quite hard to check with haskell.
03:47:12 <sylvan> yes, so it would only load from source
03:47:30 <musasabi> dcoutts: Unchecked array operations -> buffer overflow -> IO
03:47:42 <dcoutts> and if the imports are restricted to a set of known safe packages
03:48:06 <dcoutts> eg not Data.Array.Base (whcih allows the unckecked array operations)
03:48:10 <sylvan> yeah hmm.. you'd need quite a bit of restrictions there..
03:48:18 <musasabi> then there is the problem of resource exhaustion.
03:48:25 <dcoutts> musasabi, yes there is that
03:48:40 <sylvan> so long as it doesn't screw up anything which can't be fixed by killing the host program I'm fine with it
03:49:07 <dcoutts> the lambdabot eval works by forking a new process and only letting it run for a certain time
03:49:09 <sylvan> I'd like to say "nobody will ever delete your entire home directory by in a plugin"
03:49:42 <dcoutts> and the forked proces drops priviledges so it can't read from the disk
03:50:08 <dcoutts> earlier on, the plugs module couldbe used to read the /etc/passwd file on the lambdabot server machine
03:50:15 <sylvan> ah...
03:50:19 <dcoutts> I think that was because it allowed template haskell
03:50:24 <musasabi> dcoutts: can it use TH ?
03:50:26 <musasabi> ah.
03:50:28 <dcoutts> which is another route into the IO monad
03:51:15 <dcoutts> eg @type ${ doEvil >> return ''() }
03:56:14 * dcoutts notes that the lag he used to see with Yi+gtk seems to have gone
03:58:24 <Lemmih> dcoutts: The code in hide-yi is only temporary.
03:58:46 <dcoutts> Lemmih, because you mean it's going to move into Yi
03:59:56 <dcoutts> Lemmih, this looks really cool :-)
04:00:14 <dcoutts> well done, that was very quick
04:00:30 <dcoutts> only a few days to hack it together!
04:00:52 <Lemmih> No, I think it should be separate from Yi. I'm planning to create a CommonSense (free version of IntelliSense) for easy implementation of syn-hling and other more advanced features.
04:01:12 <dcoutts> right, but it'd be a pure Yi plugin rather than depeding on hIDE
04:01:46 <dcoutts> and it should use a colou/font interface provided by Yi rather than using the GtkTextBuffer directly
04:01:52 <dcoutts> is that what you mean?
04:03:39 <Lemmih> I would like to keep the syntax-highlighting management code in hIDE.
04:03:48 <dcoutts> ok
04:04:06 <dcoutts> so how does it split across yi & hIDE ?
04:04:25 <dcoutts> eg the selecting the colour scheme would be in hIDE
04:04:33 <dcoutts> in a user config dialog
04:04:49 <Lemmih> Using a lexer for syntax-highlighting shouldn't depend on Yi.
04:06:07 * Lemmih isn't very interested in a stand-alone Yi.
04:12:28 <dcoutts> Lemmih, yeah, we can let dons worry about that :-)
04:13:18 <dons> :p
04:14:44 <musasabi> Having syn-hl in pure yi too would be nice.
04:15:04 <dons> well. hmm. i certainly want that. i guess yi could depend on commonSnese
04:15:20 <dcoutts> ncurses could at least support colouring if not font effects like bold/underline etc
04:15:33 <dons> yes.
04:16:39 <Lemmih> dons: I pushed a patch to yi+gtk, btw.
04:16:52 <dons> ok, good
04:17:03 <dons> feel free to commit to yi+gtk
04:19:49 <dcoutts> Lemmih, oh you've seen that we can do the wavy error underline effect?
04:19:55 <dcoutts> http://developer.gnome.org/doc/API/2.0/pango/pango-Text-Attributes.html#PangoUnderline
04:20:33 * dcoutts checks if we've bound that in gtk2hs
04:20:56 * dons will try to get some yi hacking done tonight
04:22:11 <dcoutts> oh, it is bound, the textTagUnderline attribute and the UnderlineError enum value
04:22:28 <dcoutts> not sure how one sets the error underline colour
04:28:11 <beelsebob_> @seen JaffaCake
04:28:12 <lambdabot> I saw JaffaCake leaving #haskell 3 days, 20 hours, 28 minutes and 34
04:28:12 <lambdabot> seconds ago, and I have missed 1 minute and 49 seconds since then.
04:28:16 <beelsebob_> :(
04:28:28 <dcoutts> he's at ICFP
04:29:17 <beelsebob_> ah, that makes sense
04:29:32 <Lemmih> Hi shapr.
04:29:33 * shapr boings
04:29:34 <shapr> y0!
04:29:40 * beelsebob_ pongs shapr
04:29:49 * shapr poings beelsebob_ 
04:29:57 <beelsebob_> how goes the world
04:30:02 <shapr> I think a poing is a ping, a pong, and a boing.
04:30:10 <shapr> The World# is fine.
04:30:12 <shapr> How's yours?
04:30:16 <dcoutts> Lemmih, one minor bug in the syn hl: the space after "::" (ie ":: ") get's highlited the same as the "::" itself.
04:30:29 <musasabi> shapr: I am trying to write something small about comonads for TMR - but I don't think I can get any new results into that just a summary in non-theoretic form of the existing results.
04:30:48 <dcoutts> Lemmih, we will need to worry about that sort of precision thing once we do error underlining.
04:31:04 <shapr> musasabi: That would be perfect. I don't have time to become obsessed about even more nifty stuff ;-)
04:31:05 <beelsebob_> mine is mostly good at the moment
04:31:05 <Lemmih> Feel free to fix it (:
04:31:25 * dcoutts was just testing that the "Gtk.set tag [ Gtk.textTagUnderline := Gtk.UnderlineError ]" works
04:31:37 <beelsebob_> I'm about to break hat-delta in impressive style
04:31:43 <dcoutts> and it does automatically underline in red
04:31:48 <shapr> musasabi: I'm going to release the next issue on the first, think you can have the non-theoretic summary ready then?
04:32:14 <shapr> beelsebob_: So there's hat and black-hat, is delta-hat the special forces debugger?
04:32:42 <musasabi> shapr: I am trying to get it ready tomorrow + one day for corrections (as I am in Tallinn on friday).
04:32:47 <shapr> spiffy!
04:32:47 <beelsebob_> shapr: yes, it is, it sneaks in, cleans up and does the job quickly
04:32:58 <shapr> beelsebob_: awesome :-)
04:33:05 <beelsebob_> as long as hat-detect doesn't get him
04:33:22 * shapr snickers
04:33:52 <beelsebob_> but as long as that doesn't happen, he's home at night to see pretty-hat
04:47:03 <autrijus> dons: you've got patch
04:48:24 <autrijus> dons: http://no.perlcabal.org/~autrijus/tmp/fps.patch
04:48:49 <autrijus> it's just API unification; internals would need careful benchmarking
04:49:34 <shapr> @yow !
04:49:36 <lambdabot> I had a lease on an OEDIPUS COMPLEX back in '81 ...
04:49:50 * shapr snickers
04:50:36 <shapr> Hey, silly question... is there any sort of apache weblog analysis tool that lets you navigate around in great detail? I guess I want something more like a database explorer tool.
04:50:51 <shapr> Seems like it'd be easy to write such a tool in Haskell at least.
04:51:00 <shapr> ayrnieu: hiya!
04:51:26 <shapr> ayrnieu: Oh famous CleverDragon, are you still in the Armed Forces?
04:52:02 <adept> shapr: try webdruid
04:52:10 <shapr> edwinb: Hey, do you want to write something about dependent types for TMR?
04:52:14 <shapr> adept: Thanks, I'll check it out.
04:52:46 <musasabi> Any good tutorials on building bayesian filters? (or even a Haskell library)
04:52:47 <adept> shapr: or something with 'druid' in it. It is in the unstable. It even plots graphviz diagrams of paths that users take trough your site.
04:52:47 <shapr> gzl: Hey, want to write about WASH for TMR?
04:53:03 <shapr> musasabi: I hacked one up long ago, they're extremely simple.
04:53:24 <shapr> musasabi: I called it Paskalle. You can appreciate the name better than most :-)
04:55:13 <musasabi> found it :-)
04:56:08 <shapr> musasabi: It's a direct (and ugly) translation of this article: http://www.paulgraham.com/spam.html
04:56:47 * shapr cranks up w/trem
04:56:55 <shapr> poetix: Are you the singer on all of the w/trem songs?
04:57:22 <shapr> musasabi: I got distracted because I could never figure out a nice way to do token promotion. I think I did find a good solution two days ago though.
05:00:01 <shapr> What's the fix to get apache2 to serve up .hs as text?
05:01:02 <shapr> hoi takuan
05:01:34 <shapr> musasabi: Here's the lazy token promotion I never finished - http://www.scannedinavian.org/~shae/src/haskell/ProtoLazyList.hs
05:05:18 <shapr> I think I'm going to email Uustalu and Vene and ask for their Haskell sources.
05:05:37 <shapr> And point them to the comonad goodies that have just appeared.
05:06:24 <basti_> "just appeared"?
05:06:29 * basti_ is back from work
05:06:39 <shapr> Yeah, musasabi and dave_m both wrote new goodies.
05:06:56 <basti_> what do they do?
05:07:04 <autrijus> LogicT looks sufficiently magical.
05:07:06 <basti_> i've seen musa's, but not dave_ms
05:07:25 <shapr> basti_: Check my reply to the original article on LtU.
05:07:27 <basti_> (that is, i've seen musa's up to the Stream Comonad declaration)
05:07:29 <basti_> okay
05:08:17 <shapr> autrijus: That's another Oleg product, isn't it?
05:09:03 <shapr> Ah yes - http://okmij.org/ftp/papers/LogicT.pdf
05:09:46 <shapr> autrijus: Don't you already know Ken Shan?
05:09:57 <autrijus> shapr: yeah, when I was 12 or something
05:10:04 <shapr> Huh, wow. How'd that happen?
05:10:23 <autrijus> high school computer club etc
05:11:13 <shapr> Surprising that two people from the same computer club would make it to the same ICFP.
05:11:21 <poetix> shapr: There's one w/trem track my sister sings on. The rest are all me.
05:11:45 <shapr> poetix: Have you submitted stuff to magnatune yet?
05:15:51 <shapr> I've never been in a computer club at all. I'd like to know some computer geeks in the same physical area one day.
05:16:26 <basti_> musasabi: are you there?
05:17:47 <musasabi> here?
05:18:27 <basti_> yes!
05:18:33 <basti_> i got a problem with hswebforms
05:18:43 <basti_> I want to make links from database records
05:19:10 <basti_> now i can make a Form from my database records, but how can I get "n" Refs there?
05:19:53 <musasabi> http://cs.helsinki.fi/u/ekarttun/hswebforms/hswebforms/examples/record/record.hs ?
05:20:04 <musasabi> That is quite ugly however.
05:20:22 <basti_> that's GET method and not really your DSL :P
05:20:40 <musasabi> But I am not sure what it should look like.
05:20:45 <basti_> hmm
05:20:52 <basti_> maybe I'll do some explorative programming then
05:23:41 <musasabi> I really think the best way would be to make haskelldb use OOHaskell and hswebforms could then take benefits from there.
05:24:11 <basti_> i don't. :P
05:24:18 <basti_> i thought about some monad.
05:34:15 <musasabi> That might be the answer also.
05:34:20 <musasabi> Or make it a comonad ;)
05:34:28 <basti_> just for good measure?
05:39:04 <shapr> musasabi: Anything in particular I should ask Uustalu?
05:39:22 <Oejet> Hello.
05:40:52 <shapr> hiya Oejet
05:44:55 <musasabi> shapr: emptyness seems hard, but it might be just a problem of perspective.
05:54:33 <takuan> hye shapr
05:54:39 <takuan> everything fine?
06:00:02 <autrijus> hurray haskell.org is back.
06:00:06 <autrijus> is there a darcs mirror for ghc cvs?
06:00:45 <shapr> takuan: Code is good. How's yours?
06:01:01 <takuan> no idea shapr, i'm just back from a loooong vacation
06:01:09 <shapr> autrijus: CosmicRay has one, but I don't remember if it's updated regularly.
06:01:18 <autrijus> k, I'll just grap the snap.
06:01:34 <takuan> anyways
06:01:35 <shapr> autrijus: Also, it's a read-only mirror, you can't commit to the darcs fptools.
06:01:36 <takuan> i'm gone
06:01:43 <shapr> takuan: Vacation again? ;-)
06:01:44 <shapr> foo
06:02:00 <shapr> I very much wish for an fptools darcs repo.
06:02:00 <autrijus> shapr: so had your brain reconfigured to agree with the labelled-gadt-is-a-good-idea meme? :)
06:02:24 <shapr> I think so.
06:02:27 <autrijus> :D
06:02:41 <shapr> I'm still considering it, but I see the benefits you want.
06:02:57 <autrijus> cool
06:03:08 * autrijus is hacking the ghc typechecker part for that
06:03:36 <autrijus> anyone seen SyntaxNinja?
06:03:39 <autrijus> in realspace
06:03:55 <shapr> Ah, CosmicRay's darcs fptools was last updated Jun 14
06:04:10 <shapr> You mean, anyone at ICFP?
06:04:16 <autrijus> yeah
06:04:27 <autrijus> looking to continue cabalize pugs
06:06:26 <xerox> yo.
06:09:23 <shapr> y0 xerox
06:09:57 * poetix cowers
06:11:07 * xerox pokes poetix
06:11:33 * poetix emits plaintive meeping noises
06:11:47 <xerox> Yo poet, what's up?
06:11:54 <poetix> You get the email about hobby?
06:12:15 <xerox> It's like the second time you remind me to check the mailbox... thanks :-)
06:13:14 <poetix> I /hope/ I'll be able to make some more visible progress now my problems with c2hs are sorted out
06:13:21 <xerox> Cool!
06:13:27 <poetix> Which, to be fair, were never really c2hs problems anyway
06:14:05 <poetix> Anyhow, the darcs repo is at http://www.codepoetics.com/hobby
06:15:06 <autrijus> spj++ # very enjoyable, mad presentation skillz
06:16:46 <Oejet> autrijus: Refering to any particular presentation?
06:17:07 <autrijus> Oejet: the SYB+Class one just this hour
06:17:40 <xerox> autrijus, I'll have to do some presentation for school, I'll try out your advices and takahashi method :-D
06:17:43 * shapr converts the infidels on LtU
06:17:58 <autrijus> xerox: good, I believe it'd be impressive
06:18:11 <autrijus> I prefer white-on-black but the japan takahashi practitioners all use black-on-white
06:18:14 <shapr> autrijus: Yeah, SPJ roxx. He also tends to take off shoes, sweater, and untuck his shirt when speaking.
06:18:28 <autrijus> shapr: very amazing fellow.
06:18:40 <shapr> Yeah, and so very modest!
06:18:50 <shapr> Hey, is Doaitse Swierstra there too?
06:19:43 <Oejet> Is ICFP going on now?
06:19:45 <shapr> Yup
06:20:13 <Oejet> Any taped presentations or slides up yet?
06:20:53 <xerox> poetix: -l is unuseful in -c steps, using g++.
06:21:21 <poetix> Yes, so g++ keeps telling me
06:21:58 <Heffalump> shapr: yes
06:22:09 <xerox> During -c compilation no linking is being done, that's why.
06:22:52 <poetix> Yeah, I need to get the invocation right for ghc later, when we do have to link to produce an executable
06:30:47 <SyntaxNinja> y0
06:30:55 <autrijus> yo SyntaxNinja
06:31:01 <autrijus> I've got cabal, cabalget
06:31:28 <autrijus> installing it
06:32:25 <SyntaxNinja> hi autrijus
06:32:34 <SyntaxNinja> cool. you got cabal-get-bootstrap?
06:32:44 <autrijus> yeah
06:33:08 <SyntaxNinja> autrijus: you won't need it for what we're doing tonight, but I know you're interested otherwise
06:34:18 <autrijus> aye
06:34:26 <autrijus> $ sudo runhaskell Setup.lhs  install
06:34:26 <autrijus> WARNING: /home/autrijus/.ghci is owned by someone else, IGNORING!
06:34:29 <autrijus> ./Distribution/Simple.hs:61:1: lexical error
06:34:50 <autrijus> but without sudo:
06:34:51 <autrijus> *** Exception: /usr/local/lib/Cabal-1.1.4: createDirectory: permission denied (Permission denied)
06:35:03 <autrijus> (the standard cpan solution is to run sudo after asking the user)
06:35:16 <autrijus> (this is for main cabal)
06:35:30 <SyntaxNinja> right
06:35:39 <SyntaxNinja> Install.hs is very rough
06:35:51 <SyntaxNinja> this is for cabal, or cabal-get?
06:35:51 <autrijus> so do I just chown ~/.ghci to root
06:35:55 <autrijus> for cabal
06:36:19 <SyntaxNinja> are you installingg as user or something?
06:36:31 <autrijus> if I sudo install then it complains presumably because it inherits my HOME
06:36:38 <autrijus> if I don't then I don't have permission.
06:36:49 <autrijus> anyways, chown ~autrijus/.ghci to root, _then_ sudo install
06:36:50 <autrijus> that worked.
06:36:54 <SyntaxNinja> ok
06:37:05 <autrijus> Warning: hiding the following packages to avoid conflict:
06:37:05 <autrijus>   Cabal-1.0
06:37:06 <autrijus> that's normal?
06:37:10 <SyntaxNinja> yeah
06:37:12 <SyntaxNinja> which ghc?
06:37:21 <SyntaxNinja> you might have to remove Cabal-1.0, not sure.
06:37:26 <SyntaxNinja> see README
06:39:48 <autrijus> 6.4.1-release-freebsd
06:39:51 <autrijus> k
06:40:24 <SyntaxNinja> ok
06:40:39 <SyntaxNinja> well, 6.4.1 is better, but there are still small problems. I think you'll be OK
06:42:28 <autrijus> k. this talk is very interesting to me, so I'm shifting control out of this context for now...
06:43:42 <SyntaxNinja> ok
06:57:45 <xerox> http://www.futurehi.net/archives/000741.html
07:10:48 <Oejet> Man, I wouldn't know which slots to choose at the Haskell Workshop.  All my favourites are overlapping. :-(
07:11:36 <Heffalump> overlapping with what?
07:11:51 <Oejet> With each other of course.
07:12:07 <shapr> class instances ;-)
07:12:16 <Heffalump> how can HW talks overlap with each other?
07:12:32 <retepybrik> sessions in more than one room at a time
07:12:38 <Heffalump> no..
07:13:02 <autrijus> Oejet: I think you read it as choose 1 from 3
07:13:05 <autrijus> it's actually sequential.
07:13:18 <Heffalump> ahhh :-)
07:13:30 <Oejet> Ah!  :-D
07:13:37 * Oejet runs to the airport.
07:14:05 <autrijus> have a nice day :)
07:16:37 <shapr> beelsebob_: Seen the coKleisli arrow in Uustalu's most recent comonads paper?
07:16:52 <beelsebob_> no... these things scare me
07:17:05 <shapr> Aw c'mon, they're simple.
07:17:48 * shapr pretends to have a clue.
07:18:11 <shapr> @wiki CoMonad
07:18:12 <lambdabot> http://www.haskell.org/hawiki/CoMonad
07:18:26 <xerox> @wiki CoMonad/Articles
07:18:28 <lambdabot> http://www.haskell.org/hawiki/CoMonad/Articles
07:18:42 <xerox> @wiki CoMonadArticles
07:18:44 <lambdabot> http://www.haskell.org/hawiki/CoMonadArticles
07:18:45 <xerox> Okay.
07:18:54 <beelsebob_> heh, that's really dumb
07:19:03 <beelsebob_> @wiki ShaprsArse
07:19:05 <lambdabot> http://www.haskell.org/hawiki/ShaprsArse
07:19:11 <shapr> beelsebob_: So fix it.
07:19:17 <Heffalump> your arse? :-)
07:19:26 <Heffalump> you want us ot make a wiki page for it?
07:19:27 <shapr> I think wikipedia does check whether the page exists, you can probably use the same code.
07:19:33 <shapr> Heffalump: Happily, my arse is not broken.
07:19:44 <shapr> I couldn't be arsed to break it!
07:19:58 <Heffalump> http://www.haskell.org/hawiki/ShaprsArse : "Happily, shapr's arse is not broken"
07:20:10 <Heffalump> (since deleting pages properly is tricky, I won't actually make it ;-)
07:20:22 <shapr> I'm happy to hear that!
07:20:23 <xerox> haha, Bart had to write on the blackboard something like "I'll not make a website about my arse" sometime.
07:20:28 <shapr> My butt is off-topic!
07:20:42 <autrijus> thank goodness. I wouldn't want it to be on the topic.
07:21:00 <Heffalump> yes, it might get it dirty
07:21:10 <xerox> ...and flat
07:21:12 <shapr> My butt is also clean :-P
07:21:24 <Heffalump> even if the topic ends up rammed all the way up?
07:21:26 <shapr> xerox: Hey don't butt in! ;-)
07:21:27 * autrijus resists a joke on Clean and unique types
07:21:29 <shapr> eww
07:21:36 <xerox> haha.
07:21:38 <shapr> Heffalump: That's disgusting!
07:21:47 <shapr> autrijus: whew!
07:23:15 <Heffalump> me? evil? never.
07:23:17 <shapr> Dang, I lost the email Oleg sent me about shape types.
07:24:26 <autrijus> does this shape has anything to do with shape inferencing?
07:24:46 <shapr> Oh look, Brandon van Every thinks that LtU is of interest to such a small group that he should be able to post announcements for SeaFunc.
07:24:51 <shapr> autrijus: Er, yes, sort of.
07:25:11 <autrijus> ah. the "types with holes in it" idea
07:25:26 <shapr> Originally I wanted to create type-safe Penrose tiles. Later I realized the simplest part of that problem is very interesting.
07:25:45 <autrijus> oh. geometric shapes.
07:26:52 <shapr> If you have two values, each of which is a pair of square tiles, one above the other... How can you typecheck that the top two squares being placed adjacently also makes the bottom two squares adjacent?
07:27:44 <autrijus> shapr: this sounds dangerously like the (Patch a b) problem that Heffalump and Igloo are hacking on yesterday
07:28:52 <Heffalump> autrijus: we have it roughly working now
07:28:54 <shapr> I don't know. This sort of typechecking would have a lot of uses.
07:29:01 <autrijus> Heffalump: !!. url?
07:29:11 <Heffalump> I just sent something to Igloo, he needs to apply it
07:29:22 * Igloo doesn't know if I can easily do that
07:29:30 <Heffalump> are we in a group on urchin?
07:29:43 <Heffalump> you could just change the perms so I can push directly
07:29:49 <shapr> Some I've thought of are: ASIC layout and shape database searching.
07:29:54 <Heffalump> I'll make my own repo.
07:30:04 <Heffalump> I do.
07:30:14 <Igloo> I worked that out before pressing enter
07:30:22 <Heffalump> I didn't work out that you did work that out.
07:31:26 * poetix still thinks that using the typechecker to validate spatial properties is perverse
07:32:03 <shapr> Oh, I also realized that region allocation is roughly equivalent to one dimensional spatial typechecking.
07:32:41 <poetix> It sounds like the sort of logic problem for which you should write a DSL, not convolute poor old H-M into ever more tortuous shapes
07:33:36 <shapr> I think region allocation is sufficiently general to implement on top of HM.
07:33:36 <tensh> is it possible to display text in color in hugs?
07:33:58 <tensh> in the regular consolelike display
07:33:59 <poetix> It probably is - you probably can - but *should* you?
07:34:17 <poetix> (reply to shapr, not tensh)
07:34:20 <tensh> well... we're making a game and it would look nice to display different things in different colors
07:34:25 <tensh> ahh, ok ;)
07:34:35 <shapr> I define 'should' as "what other people want me to do."
07:34:41 <shapr> I think there's only what I need, and what I want.
07:35:05 <poetix> That's funny - in programming, if not in life, I have a strong sense of objective morality
07:35:21 <poetix> Like, come the day of judgement, I'm going to face a terrible Code Review
07:35:31 <shapr> It's always distracting when there's howitzer fire that I can hear over the music from my headphones.
07:35:46 <autrijus> the countdown in the ICFP contest page, instead of going into negative number, now announces:
07:35:49 <Heffalump> someone at ICFP, what time is the dinner?
07:35:50 <autrijus> " Time until the Winners are announced:  Very short  "
07:35:55 <poetix> and all my little abominations will be paraded before me, until I break down and beg for pardon
07:35:55 <Heffalump> autrijus: :-)
07:35:59 <shapr> poetix: In that case, I definitely *should* do it.
07:36:00 * Heffalump can see two of the winners right now.
07:36:14 <Heffalump> dunno what they won though.
07:36:36 <Igloo> 8 I think
07:36:36 <shapr> Because if I do it, someone else won't have to figure out if it's cool or not.
07:36:47 <Heffalump> Igloo: yeah, David pointed out it's on the ticket
07:36:51 <poetix> If you can do it elegantly, then that would be very cool.
07:36:56 <Heffalump> which he had in his pocket
07:37:01 <poetix> If it's an ugly hack, at least you've proved it can be done.
07:37:20 <poetix> But I still think type-hackery is a terrible way to do metaprogramming
07:37:24 <Heffalump> poetix: yes.
07:37:32 <Heffalump> especially when it's really hacky.
07:38:16 <shapr> Where's the line between metaprogramming and type hackery?
07:38:52 <genneth> the difference between haskell and C++ ?
07:39:02 <nothingmuch> hi, my name is nothingmuch, and I'm an alco^W^Wcompsci illiterate
07:39:03 <shapr> What about bounded list types?
07:39:12 <shapr> nothingmuch: Welcome nothingmuch!
07:39:15 <nothingmuch> can anyone help me understand some funny chars i haven't seen before in an article?
07:39:23 <Heffalump> do they look like bananas?
07:39:23 <shapr> nothingmuch: Which article?
07:39:24 <poetix> That one's a lambda
07:39:29 * shapr is betting on bananas and lenses
07:39:30 <Heffalump> or lenses
07:39:34 <poetix> The other one is ++ scrunched up together
07:39:36 <poetix> Or (+)
07:39:38 <nothingmuch> The Essence of Compiling with Continuations
07:39:55 <Igloo> ++ scrunched together is just ++
07:40:00 <shapr> nothingmuch: What's the url to the paper?
07:40:03 <nothingmuch> Figure 2 causing my brain to swap thrash... every time I figure out what one thing means i forget another
07:40:06 <nothingmuch> http://research.compaq.com/SRC/personal/flanagan/papers/pldi93.ps
07:40:14 <nothingmuch> and some are simply ungrokkable to me
07:40:24 <poetix> I've seen it where the two vertical lines were really close together
07:40:57 <shapr> nothingmuch: Which chars?
07:41:09 <nothingmuch> okay... I know what a CEK machines purpose is
07:41:16 <nothingmuch> and roughly what goes in and what comes out
07:41:23 * shapr doesn't
07:41:28 <xerox> Which is the lenses and bananas paper?
07:41:30 <nothingmuch> but the semantics of the transition functions, as well as the data constructions make absolutely no sense
07:41:38 <shapr> @google bananas lenses barbed wire
07:41:39 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
07:41:46 <xerox> Danke.
07:43:23 <nothingmuch> shapr: bah... my ride is leaving... can't be helped in the immediate future
07:43:24 <shapr> nothingmuch: In TaPL, |--> means big step(?) reduction
07:43:24 <nothingmuch> but thanks
07:43:26 <shapr> ok
07:43:44 * nothingmuch will come back later for more schooling
07:44:08 <shapr> Hey, I'm self taught too.
07:44:18 <shapr> I had CS101 in 1992.
07:44:27 <poetix> What do you reckon the big black dot is?
07:44:38 <nothingmuch> shapr++; # sympathy is nice ;-)
07:45:03 <nothingmuch> so how does one learn to read this stuff?
07:45:05 <autrijus> mm metagame. brings back lots of memories :)
07:45:24 <shapr> nothingmuch: The jargon/symbols is the hardest part.
07:45:27 <shapr> Everything else is easy.
07:45:37 <shapr> I suggested Symbolpedia on LtU :-)
07:45:45 <nothingmuch> that sounds useful
07:45:54 <shapr> The Bananas, Lenses, etc paper had me tied up in knots for weeks.
07:46:16 <nothingmuch> is symbolpedia hypothetical?
07:46:19 <shapr> Once you know the symbols, it's suddenly so easy.
07:46:25 <shapr> Yes, it's hypothetical. Want to create it?
07:46:40 <nothingmuch> i reckon the symbols also have a bootstrapping problem
07:47:05 <shapr> Not really. Allow the user to upload or draw an SVG.
07:47:15 <shapr> And a category.
07:47:15 <autrijus> or just png.
07:47:36 <shapr> Computer Science / Math / $ParticularFlavorMath / etc
07:47:38 <autrijus> and allow other people to associate it with a unicode codepoint somehow if there's one
07:47:50 <shapr> Right, unicodepoints would be the best association.
07:48:15 <xerox> Now who is going to write an hsp app for that? :-)
07:48:30 <autrijus> mm there is already mathworld and wikipedia
07:48:37 <shapr> Amusingly, Category Theory is (imho) often the best way to describe what all these symbols do/mean.
07:49:24 <poetix> It looks to me like the little black circle is a sort of placeholder - sometimes it appears on the far left, sometimes on the far right, and sometimes in the middle, I would guess to seperate out the items to the left of it from the items to the right
07:55:10 <shapr> My upstairs neighbor is seriously strange...
07:55:23 <shapr> poetix: Anyway, I think you're right. It appears to mean something like "right here"
07:55:49 <shapr> Sort of like looping through a list.
07:55:54 <poetix> It looks like an over-sized full stop
07:56:38 <poetix> I suspect you could crunch through the reduction rules just substituting symbols without ever once knowing or caring what it means...
07:57:09 <dcoutts_> xerox, ping
07:57:21 <shapr> Yeah, but understanding can be handy.
07:58:31 <poetix> Well, it shows up in the definitions for "ap" and "pr". Do we know what those are?
07:58:44 <xerox> dcoutts_, pong!
07:59:05 <dcoutts_> xerox, we're using your lsystem thing as a practical (it's confirmed now)
07:59:20 <dcoutts_> xerox, but we can't get cairo installed on our sun machines :-(
07:59:23 <xerox> Whoa.  Nymphaea or the old code?  I'm very very happy to ear it :-)
07:59:36 <dcoutts_> bit's of the old code probably
07:59:38 <xerox> Ooh!  Shake cairo people :-D
07:59:52 <dcoutts_> we need to keep it simple for the students
08:00:15 <xerox> If we ever implement the last ideas it will be even simpler!
08:00:17 <dcoutts_> well the thing is that Solaris 9 has an X server that doesn't support the X Render extension
08:00:33 <dcoutts_> so I can't build the cairo Xlib backend
08:00:38 <xerox> I.e. draw the pieces with the mouse or something.
08:00:41 <dcoutts_> and so I can't build gtk+-2.8
08:01:00 <dcoutts_> so I'm re-writing the stuff to use the old crappy gdk interface :-(
08:01:04 <xerox> Hmpf!
08:01:13 <dcoutts_> but next year we'll make it pretty by using cairo
08:01:26 <dcoutts_> we just can't get them to upgrade the stuff soon enough
08:01:26 <poetix> Why not use the pdf backend, then render the pdf in a viewer?
08:01:37 <poetix> pdf/ps
08:01:41 <dcoutts_> they'd need to get Solaris 10 installed
08:01:59 <dcoutts_> well it'll still look ok, just no alpha tranparency
08:02:01 <xerox> ...or just a png?
08:02:12 <dcoutts_> hmm, possibly
08:02:20 <xerox> Oh but, no cairo installed...
08:02:32 <dcoutts_> well we can build cairo with no Xlib backend
08:02:36 <dcoutts_> just the png backend
08:03:24 <xerox> Ah, so going from gtk to png it's a matter of changing some lines of code.
08:03:43 <dcoutts_> yes we can load png's using a Pixbuf
08:04:12 <xerox> Better than going back to gdk for sure.
08:04:18 <dcoutts_> maybe
08:04:29 <dcoutts_> it's only line drawing so it'll work fine with gdk
08:04:43 <dcoutts_> though with more jadged edges :-9
08:04:47 <xerox> As you prefer :-)
08:04:51 <dcoutts_> I'll see how it looks
08:05:07 <dcoutts_> even getting them to install cairo in time might be tricky, I'll see how it goes
08:05:17 <dcoutts_> but either way we're doing the L-system stuff
08:05:32 <xerox> And that's great.
08:05:45 <dcoutts_> the professor running the course was very impressed by your pictures and code xerox
08:05:46 <xerox> I actually saw a game which used L-Systems to draw trees! :D
08:05:59 <xerox> dcoutts_: wow, I'm... wow.. :-)
08:06:18 <dcoutts_> though we couldn't understand boegel's code :-)
08:06:30 <xerox> Tricky use of bind :-)
08:06:33 <dcoutts_> yep
08:06:48 <dcoutts_> it's not how we'd write it for first years :-)
08:06:52 <xerox> Refactoring that part was kinda good.  With all the credits to Cale too :-)
08:07:04 <dcoutts_> oh right, I might look at that
08:07:27 <dcoutts_> he liked the book that you & boegel suggested, the "abop" book
08:07:39 <dcoutts_> he's going to buy it, and reccomend it to the students
08:07:58 <[Blownose]> if i have 4 and 5 and i want to generate a tripple combination of it how do i do that   ( like this [444] [445] [454] [455] [544] ..... [555]) ?
08:08:00 <xerox> It's not to be harsh, but if you have any question I'll be pleased to answer.
08:08:11 <dcoutts_> sure, you're a busy man :-)
08:08:13 <xerox> dcoutts_: it is freely available on the web!
08:08:28 <dcoutts_> xerox, yes, which is good for the students
08:08:30 <xerox> ...and it's really good.
08:08:40 <dcoutts_> which is why the prof wants a paper copy :-)
08:08:41 <beelsebob_> blownose: what's this for?
08:08:59 <xerox> Check this out: http://www.darwinia.co.uk/screenshots/image15.jpg
08:09:31 <[Blownose]> i mean i want it like [4,4,4] ... [5,5,5] not [444]
08:09:36 <musasabi> dcoutts_: You can get xrender with solaris 9 iirc.
08:09:44 <dcoutts_> musasabi, really?
08:09:50 <Heffalump> here come the contest results..
08:09:53 <Heffalump> (well, soon)
08:10:06 <dcoutts_> Heffalump, oooh, tell us when it comes in
08:10:08 <musasabi> See e.g. http://www.sun.com/software/solaris/9/fcc/ucc-details1202.xml
08:10:09 <Heffalump> will do.
08:10:18 <dcoutts_> musasabi, ta, I'll take a look
08:10:38 <xerox> dcoutts_: I think they are L-Systems outputs, what do you think?
08:11:10 <dcoutts_> xerox, heh nice
08:11:26 <dcoutts_> it's like boegel's 3D version
08:13:27 <musasabi> Also the sunsolve patch 113098.
08:14:14 <beelsebob_> let f x 0 = [], f x n = foldr (: (f x (n-1))) [] x in f [4,5] 3
08:14:25 <beelsebob_> @eval let f x 0 = [], f x n = foldr (: (f x (n-1))) [] x in f [4,5] 3
08:14:29 <lambdabot> 32: parse error on input `,'
08:14:30 <dcoutts_> musasabi, that's useful to know, however I doubt our IT staff will upgrade very quickly, they're an ineffecient and concervative lot
08:14:38 <beelsebob_> @eval let f x 0 = []; f x n = foldr (: (f x (n-1))) [] x in f [4,5] 3
08:14:40 <lambdabot> 48:
08:14:40 <lambdabot>   Expecting a function type, but found `[a]'
08:14:40 <lambdabot>   Expected type: a -> [a] -> [a]
08:14:40 <lambdabot>   Inferred type: a -> [a]
08:14:40 <lambdabot>   In the expression: (: (f x (n - 1)))
08:15:18 <beelsebob_> @eval let f x 0 = []; f x n = foldr ((++) . (: (f x (n-1)))) [] x in f [4,5] 3
08:15:20 <lambdabot> [4,4,4,5,5,4,5,5,4,4,5,5,4,5]
08:15:30 <beelsebob_> bah,,, not quite
08:15:40 <beelsebob_> @eval let f x 0 = []; f x n = foldr ((:) . (: (f x (n-1)))) [] x in f [4,5] 3
08:15:42 <lambdabot> 49:
08:15:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:15:42 <lambdabot>   Expected type: a -> [a] -> [a]
08:15:42 <lambdabot>   Inferred type: a -> [[a]] -> [[a]]
08:15:42 <lambdabot>   In the expression: (:) . ((: (f x (n - 1))))
08:15:49 <musasabi> dcoutts_: well it can be installed as a single patch (113098), installing cairo should be much harder ;)
08:16:00 <beelsebob_> oh no... now I'm just being dumb
08:16:10 <musasabi> of course administrative policies might make things more complicated.
08:16:20 <dcoutts_> musasabi, hmm, thanks, the smaller the better for admin politics
08:16:59 <xerox> How is hIDE going?
08:17:00 <Heffalump> dcoutts_: I suspect they are actually quite good at maintaining the Solaris boxes.
08:17:05 <Heffalump> They just suck at new things, like Linux.
08:17:18 <dcoutts_> this is for the old Solaris boxes
08:17:20 <beelsebob_> @eval f x 0 = []; f x n = map (: (f x (n-1))) x in f [4,5] 3
08:17:21 <lambdabot> 24: parse error on input `='
08:17:34 <dcoutts_> Heffalump, we wanted them to install the latest version of Gtk+
08:17:49 <beelsebob_> buh... what've I done now?
08:18:12 <xerox> @plugs let f x 0 = []; f x n = map (:) (f x (n-1)) x in f [4,5] 3
08:18:14 <lambdabot> 42:
08:18:14 <lambdabot>   The function `map' is applied to three arguments,
08:18:14 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
08:18:14 <lambdabot>   In the definition of `f': f x n = map (:) (f x (n - 1)) x
08:18:18 <xerox> heh.
08:18:34 <xerox> beelsebob_: what are you trying to do?
08:18:36 <xerox> (in words)
08:18:38 <beelsebob_> @eval let f x 0 = []; f x n = map (: (f x (n-1))) x in f [4,5] 3
08:18:40 <lambdabot> 46:
08:18:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:18:40 <lambdabot>   Expected type: a -> a
08:18:40 <lambdabot>   Inferred type: a -> [a]
08:18:40 <lambdabot>   In the expression: (: (f x (n - 1)))
08:18:58 <xerox> @eval let f x 0 = []; f x n = map (++ (f x (n-1))) x in f [4,5] 3
08:19:00 <lambdabot> 46:
08:19:00 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
08:19:00 <lambdabot>   Expected type: [b] -> b
08:19:00 <lambdabot>   Inferred type: [b] -> [b]
08:19:00 <lambdabot>   In the expression: (++ (f x (n - 1)))
08:19:01 <beelsebob_> xerox: a nice solution to permutations
08:19:42 <beelsebob_> @eval f x 0 = []; f x n = foldr (:) [] (map (: (f x (n-1))) x) in f [4,5] 3
08:19:43 <lambdabot> 24: parse error on input `='
08:19:54 <beelsebob_> @eval let f x 0 = []; f x n = foldr (:) [] (map (: (f x (n-1))) x) in f [4,5] 3
08:19:56 <lambdabot> 60:
08:19:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:19:56 <lambdabot>   Expected type: a -> a
08:19:56 <lambdabot>   Inferred type: a -> [a]
08:19:56 <lambdabot>   In the expression: (: (f x (n - 1)))
08:20:22 <beelsebob_> oh!!!
08:20:30 <beelsebob_> @eval let f x 0 = []; f x n = foldr (:) [] (map ((flip :) (f x (n-1))) x) in f [4,5] 3
08:20:32 <lambdabot> 61:
08:20:32 <lambdabot>   Expecting a function type, but found `[(a -> b -> c) -> b -> a ->
08:20:32 <lambdabot> c]'
08:20:32 <lambdabot>   Expected type: a -> b
08:20:32 <lambdabot>   Inferred type: [(a1 -> b1 -> c) -> b1 -> a1 -> c]
08:20:34 <lambdabot>   Probable cause: `(flip :)' is applied to too many arguments in the
08:20:36 <lambdabot> call
08:20:37 <beelsebob_> ... or not
08:20:38 <lambdabot>    ((flip :) (f x (n - 1)))
08:21:25 <beelsebob_> @eval let f x 0 = []; f x n = foldr (:) [] (map ((flip (:)) (f x (n-1))) x) in f [4,5] 3
08:21:27 <lambdabot> 73:
08:21:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:21:27 <lambdabot>   Expected type: [a]
08:21:27 <lambdabot>   Inferred type: [[a]]
08:21:27 <lambdabot>   In the application `f x (n - 1)'
08:22:39 <beelsebob_> @eval let (f :: [a] -> Int -> [[a]]) x 0 = []; f x n = foldr (:) [] (map ((flip (:)) (f x (n-1))) x) in f [4,5] 3
08:22:40 <lambdabot> 22: Parse error in pattern
08:25:43 <Heffalump> Dylan wins judges prize
08:25:48 <xerox> URL?
08:25:53 <Heffalump> Haskell (some Japanese people) 3rd
08:26:03 * xerox does a little dance
08:26:08 <Heffalump> Dylan 2nd
08:26:34 <beelsebob_> @eval let f x n = foldr ((++) . (foldr (flip (:)) [] (f x (n - 1)))) x in f [4,5] 3
08:26:35 <lambdabot> Couldn't match `a1 -> [a]' against `[a1 -> [a]]'
08:26:42 <beelsebob_> oh ffs... I give up
08:26:42 <Heffalump> xerox: no idea. google?
08:26:54 <xerox> Heffalump: you are on there?
08:26:59 <[Blownose]> cant you do it with a generator or something :) ?
08:27:04 <Heffalump> yes
08:27:10 <beelsebob_> a generator?
08:27:40 <dcoutts_> so.... who's going to be first?
08:27:59 * dcoutts_ waits with baited breath for Heffalump's report
08:28:06 * xerox too
08:28:08 <Heffalump> there's a discussion of Dylan
08:28:19 <Heffalump> (the Dylan Hackers won the judge's prize and the 2nd main prize)
08:28:27 <dcoutts_> wow
08:28:39 <xerox> http://icfpc.plt-scheme.org/
08:28:57 <[Blownose]> i mean something like this permstest[] = [[]];  permstest xs = [x:ps | x<-xs,ps<-permstest(xs\\[x])] it dosent do the right thing.. but something like it
08:29:02 <dcoutts_> heh:  "Time until the Winners are announced:  Really Really Really Really REALLY *R-E-A-L-L-Y* Extremely short"
08:29:09 <dcoutts_> (from the above page)
08:29:15 <Heffalump> :-)
08:29:59 * dcoutts_ wonders if he goes to make a cop of tea if he'll miss the result
08:30:10 * dcoutts_ decides to wait here
08:30:16 <Heffalump> the Dylan guy is still talking
08:30:17 * xerox has his tea, ah! :-D
08:30:47 <dcoutts_> xerox, you lucky thing, in the office I've got to go up two floors to find the kitchen
08:31:03 <Heffalump> Haskell 1st.
08:31:08 <xerox> HASKELL!!!!
08:31:08 <dcoutts_> woooooo!
08:31:12 <Heffalump> Wolfgang Thaller.
08:31:15 <Heffalump> (et al)
08:31:15 <dcoutts_> oh yeah.
08:31:18 <dcoutts_> cool
08:31:24 <dcoutts_> two years running
08:31:37 * xerox does a dance bringing in Heffalump and dcoutts
08:31:51 <ozone> wolfgang won?  ahaha
08:32:36 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "#haskell @ ICFP: Meet after Haskell workshop on Sep 30!!", "logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","see discussion on http://haskell.org/hawiki/hIDE about the development of an IDE for Haskell","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050920","se' by Heffalump
08:33:16 <xerox> Cut :-(
08:33:21 <dcoutts_> we need to send an email to get the haskell.org front page updated
08:33:45 <beelsebob_> @eval f xs y = map (y :) xs; g xs ys = foldr (++) [] (map (f xs) ys); h xs 0 = []; h xs n = g (h xs (n-1)) xs in h [4,5] 3
08:33:46 <lambdabot> 25: parse error on input `='
08:33:57 <beelsebob_> @eval let f xs y = map (y  xs; g xs ys = foldr (++) [] (map (f xs) ys); h xs 0 = []; h xs n = g (h xs (n-1)) xs in h [4,5] 3
08:33:58 <lambdabot> 41: parse error on input `;'
08:34:17 <beelsebob_> @eval let f xs y = map (y :) xs; g xs ys = foldr (++) [] (map (f xs) ys); h xs 0 = []; h xs n = g (h xs (n-1)) xs in h [4,5] 3
08:34:19 <lambdabot> []
08:34:25 <xerox> The third ones used Windows XP and "xyzzy", to code Haskell, whoa :-D
08:34:28 <beelsebob_> ah well... no type errors now
08:34:44 <xerox> (and darcs as rcs!)
08:36:09 <beelsebob_> @eval let g xs ys = foldr (++) [] (map (: xs) ys); h xs 0 = []; h xs n = g (h xs (n-1)) xs in h [4,5] 3
08:36:11 <lambdabot> [4,4,4,5,5,4,5,5,4,4,5,5,4,5]
08:36:19 <beelsebob_> oh bugger... back where I started
08:36:28 <beelsebob_> oh... doesn't need the ++ now
08:36:42 <beelsebob_> @eval let g xs ys = map (: xs) ys; h xs 0 = []; h xs n = g (h xs (n-1)) xs in h [4,5] 3
08:36:44 <lambdabot> 72:
08:36:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:36:44 <lambdabot>   Expected type: [a]
08:36:44 <lambdabot>   Inferred type: [[a]]
08:36:44 <lambdabot>   In the application `h xs (n - 1)'
08:36:52 <beelsebob_> yargh!
08:37:23 <[Blownose]> beelsebob i mean [[4,4,4],[4,4,5]....[5,5,5]]
08:37:33 <[Blownose]> :)
08:37:35 <beelsebob_> I know you do
08:38:29 <arjanb> sequence (replicate 3 [4,5])
08:39:24 <[Blownose]> :) thanks..
08:40:03 <tensh> is it possible to display text in color in hugs98?
08:40:19 <beelsebob_> use escape codes
08:40:39 <tensh> how do I escape it? \x<code> ?
08:46:01 <araujo> Yeah!!, Haskell is _still_ the language of choice for discriminating hackers
08:48:21 <musasabi> :-)
08:48:53 <xerox> Great :D
08:49:33 * araujo goes and get some juice to celebrate .... 
08:49:45 <wilx> Hmm. The results are out?
08:50:01 <araujo> I think now everybody will start programming in Haskell to have an opportunity to win 1st prize? :-]
08:50:18 <araujo> Yes wilx
08:50:34 <araujo> http://icfpc.plt-scheme.org/
08:50:52 <wilx> *reading*
08:52:33 <dons> haskell really kicked but
08:52:34 <dons> butt
08:53:06 <dcoutts_> dons, how did you do? whatwas your team called?
08:53:07 * araujo admits he's quite impressed with Dylan too
08:53:38 <dcoutts_> our team got eliminated in round 1 :-)
08:54:43 <dons> don't know. have to check the site.
08:55:00 <dcoutts_> dons, what was your tema name?
08:55:15 <dons> hang on ... let me check the results first ;)
08:55:22 <dcoutts_> ok :-)
08:55:31 <dcoutts_> http://icfpc.cs.uchicago.edu/teams/
08:55:48 <dons> doh, lost ;)
08:55:57 <dcoutts_> :-(
08:56:09 <dcoutts_> to who/what in which round?
08:56:47 <dons> oh, judge cops all rounds
08:56:51 <dcoutts_> dons, "High-Performance DSS" perhaps? they used "yi" I see :-)
08:56:58 <dons> http://icfpc.cs.uchicago.edu/teams/139.html
08:57:02 <dons> ;)
08:57:08 <dcoutts_> yep, though so :-)
08:57:08 <dons> Don Stefan Sean
08:57:15 <dcoutts_> yi was the give away
08:57:26 <dons> oh!! you think there's only 1 user!!
08:57:28 <dons> :p
08:57:40 <dcoutts_> we were: http://icfpc.cs.uchicago.edu/teams/083.html
08:58:00 <dcoutts_> we lost to judge cops in Twist 2
08:58:26 <dons> where are the rankings though?
08:58:37 <dcoutts_> dunno, coudn't really understand them
08:58:46 <dcoutts_> http://icfpc.cs.uchicago.edu/pl/tw.html
08:59:13 <dcoutts_> they've got scores for each pod, but no overall list as far as I can see
08:59:41 <dons> cool you did well
08:59:50 <dcoutts_> in the last 11 at least
09:02:03 <dons> oh well, that's a bit disappointing. i though we'd go much better - the code seemed solid.
09:02:21 <dons> possibly we introduced some bad heuristic at the end
09:02:49 <dcoutts_> you can view the image transcripts of some of your games
09:06:38 <DarkSSJ> hi
09:06:42 <xerox> Hello!
09:12:24 <brx> dons: your transcripts look funny. (our team suffered a major defeat also) :)
09:12:46 <dons> yeah. the robber seems to be behaving very strangely
09:13:42 <araujo> shapr!
09:13:51 <shapr> hiya!
09:13:59 <shapr> I saw the logs, go Haskell!
09:14:03 <araujo> shapr, Haskell _still_ the language!
09:14:18 * xerox dances around shapr
09:14:48 <shapr> w00!
09:15:01 <dons> there's a nice slide (hopefully) in the commentary showing how teams made it through to the playoffs
09:15:05 <dons> haskell++ :)
09:15:18 <xerox> @karma+ Haskell
09:15:19 <lambdabot> Haskell's karma raised to 1.
09:15:21 * shapr cheers
09:15:28 <xerox> Can't believe it's just 1.
09:15:52 <xerox> @karma+ Haskell -- for being third too.
09:15:54 <lambdabot> Haskell's karma raised to 2.
09:16:18 <shapr> Foo, what's the name of the coding of the third place entries? jp something?
09:16:35 <xerox> Combat-Tanteidan
09:16:43 <shapr> Nah, I'm trying to read their sources.
09:16:44 <xerox> http://icfpc.cs.uchicago.edu/teams/069.html
09:16:46 <xerox> Oh.
09:19:20 <dons> they should have presented results on the 'rcs' fields of the teams
09:19:37 <shapr> Yeah, would be interesting :-)
09:20:02 <shapr> Third place used darcs
09:20:17 <xerox> ...and winxp, yay :)
09:21:09 <[Blownose]> is it possible to do a search in the list (like find) but just return a bool instead of maybe a ?
09:22:23 <xerox> isThere x = any (==x)
09:22:47 <xerox> @type \x -> any (==x)
09:22:52 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:23:03 <shapr> dons: Is Wolfgang at ICFP? Do you know when we'll see the sources for the winner?
09:24:14 <dons> yep. he's here. i'll ask him
09:24:19 <shapr> dons: thanks
09:24:30 <shapr> I am unable to read the comments of the third place winners.
09:24:35 <dons> me too :)
09:24:47 <shapr> I figured out the encoding, but I still can't read .jp
09:25:33 <shapr> If you use emacs, you can put this on the very topmost line: --*- coding: japanese-shift-jis-dos --
09:25:34 <mauke> @type (maybe False (const True) .) . find
09:25:35 <lambdabot> bzzt
09:25:37 <xerox> Two moves lookahead: 112 GigaBytes
09:25:46 <xerox> Three moves lookahead: 1/2 PetaByte
09:25:47 <xerox> O_o
09:25:50 <dons> hmm. i think we might have been screwed by timeouts. i wonder..
09:26:02 <integral> mauke: isJust?
09:26:28 <mauke> d'oh
09:26:28 <musasabi> shapr: is it kana or mostly kanji?
09:26:40 <dcoutts_> xerox, my robber planned a few moves ahead, but only under the assumption of cops that moved towards me, rather than optimal cops
09:26:58 <dons> dcoutts_, how far ahead?
09:27:08 * dcoutts_ checks his code
09:27:12 <dons> we had up todepth 14 for cops and robbers, but i think this may have been a mistake
09:27:39 <dons> i'm suspicious the tricky code for timing out searches bit us in the ennd
09:29:48 <xerox> Are you reading the slide presentation?
09:30:36 <dons> xerox, I just sat through the slides ;) i was in the room
09:30:50 <xerox> Where was it?
09:31:04 <dons> Tallinn
09:31:20 <xerox> Third Prize - The third prize goes to Combat-Tantedian: Haskell is not too shabby
09:31:21 <xerox> hah.
09:31:39 <xerox> dons: whoa!  You did a long trip :D
09:32:00 <dons> yep
09:32:29 <xerox> How long will you stay in Europe?  Planning to visit any Euro Haskeller ? :D
09:32:56 <dons> unfortunately not. i'm just here till monday
09:33:03 <dons> hmm. sunday actually
09:33:17 <xerox> Take pics! :D
09:33:57 <dons> here's our code, i still think it's good, even though it got beaten badly ;) http://www.cse.unsw.edu.au/~dons/code/icfp05/
09:35:07 <xerox> heh!
09:37:49 <dons> kinda amazing how much code can be written in 4 days
09:38:21 <dcoutts_> dons, for the robber we counted the number of paths which would have us still be alive after 6 turns (under the assumption that the cops moved towards our last position) and took the adjacent node with the largest number of these escaping paths
09:38:49 <dcoutts_> it worked reasonably well as an escaping strategy
09:39:00 <xerox> ...and so well commented.
09:39:14 <dcoutts_> our downfall it seems was that we were too cautious in robbing banks
09:39:39 <dcoutts_> we were concerned that previously our robber kept robbing banks and ended up getting caught
09:39:56 <dcoutts_> where as he could usually rob one bank and get away with it
09:40:19 <dons> ok, wee did A-B search, which returns the optimium path accroding to a list of heuristic functions you plug in
09:40:19 <dcoutts_> but it seems other teams were able to rob multiple banks and get away with it
09:40:37 <dons> but our depth may have caused timeouts on their machines, i have a feeling.
09:40:41 <dcoutts_> and what depth di you manage?
09:40:45 <dcoutts_> or try to manage :-)
09:40:49 <dons> it was unnec. to search as deep . up to 17 I think.
09:40:54 <dcoutts_> wow
09:41:20 <dons> but we were using the full 20 secs * the number of states.
09:41:32 <dons> sorry, it was 20 secs all up, if you used all the states, iirc.
09:41:38 <dcoutts_> right
09:41:40 <dcoutts_> the other thing we had which was interesting is that our cops maintained a set of positions that they knew the robber could be in
09:41:55 <dcoutts_> it updated that based on info from the other robbers and smells and evidence etc
09:42:07 <dons> yep. us too.
09:42:20 <dcoutts_> then our robber did the same thing, it maintaind a set of positions it knew the cops had us pinned down to
09:42:28 <dons> ah, that's good
09:42:30 <dcoutts_> under the assumption that the cops shared info perfectly
09:42:38 <dons> excellent. that's nice.
09:42:44 <dcoutts_> so that enabled us to know when to run away and when to go rob a bank
09:43:17 <dcoutts_> we just had a threshold, if we were pinned down to 50 nodes or less then we ran away
09:43:27 <dcoutts_> otherwise we looked for a bank to rob
09:44:02 <dcoutts_> and that automatically deals with deciding to run away when we get smelled or if we've just robbed a bank
09:53:14 <basti_> re
10:07:06 <z0d> I'm trying to get lambda working
10:07:08 <z0d> Rebuilding dependencies ... ghc-6.4: unknown package: plugins
10:07:08 <z0d> rm: cannot remove `depend': No such file or directory
10:07:11 <z0d> what do I need?
10:08:16 <dcoutts_> you probably need to install hs-plugins
10:08:20 <dcoutts_> @where hs-plugins
10:08:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:08:33 <z0d> thank you
10:12:06 <[Blownose]> if i have something like this  [[A,B,C],[],[],[E,F,A]] how do i remove all the empty [] ?
10:12:12 <shapr> tried filter?
10:12:14 <integral> filter?
10:12:20 <dcoutts_> filter (not.null)
10:12:29 <[Blownose]> ah
10:12:31 <shapr> @eval filter (==1) [1,3,4,1,5,6]
10:12:33 <lambdabot> [1,1]
10:13:17 <dcoutts_> or you can use a list comprehension
10:13:44 <dcoutts_> [ x | x <- xs, not (null x) ]
10:13:48 <integral> [ x | x <- xs, not $ null x
10:14:00 <dcoutts_> :-)
10:15:05 <mauke> now if we had a Boolean class, we could just use filter id
10:15:31 <dcoutts_> hmm, I'd rather make it explicit
10:17:56 <integral> xs >>= \xs -> (guard $ not $ null xs) >> return xs
10:18:23 <integral> @pl \x -> (f x) >> (return x)
10:18:24 <lambdabot> liftM2 (>>) f return
10:28:43 * shapr boings
10:29:06 <basti_> yow shapr. I didnt made significant progress with my problem
10:29:14 <shapr> Aw
10:29:45 <basti_> in principle, it should work similar to an attribute grammar
10:30:15 <basti_> i don't know, however, how to bring metaknowledge to the next incarnation of the program ("submit 17 was related to record 49")
10:32:06 <shapr> Can you say ?record49=17 ?
10:32:17 <basti_> yes i could do it like that
10:32:25 <basti_> then i would basically abandon hswebforms though
10:32:55 <basti_> (which to me seems more a hindrance anyway)
10:34:11 <shapr> Do you have code that demonstrates your problem?
10:34:44 <basti_> i can put some onto the hawiki maybe?
10:34:46 <shapr> Sure
10:35:55 <sylvan> hIDE folks: Check out section 2.1 in this paper: http://www.cs.uu.nl/research/projects/proxima/thesis.pdf
10:36:16 <davve> I'll do that
10:38:26 <sylvan> O_o
10:42:33 <shapr> sylvan: Wow, this is cool. Is the code for this available?
10:44:35 * dcoutts_ reads the paper sylvan pointed to
10:44:49 <basti_> shapr: http://www.haskell.org/hawiki/HsWebForms?action=show
10:49:10 <sylvan> shapr, http://www.cs.uu.nl/research/projects/proxima/installation.html
10:49:59 * dcoutts_ notes that section 7.3.2 is out of date
10:50:00 <dcoutts_> GTK is now well supported on Windows
10:51:24 <dcoutts_> I wonder how Proxima compares to Pivotal
10:51:30 <dcoutts_> where Pivotal
10:51:32 <dcoutts_> @where Pivotal
10:51:34 <lambdabot> I know nothing about pivotal.
10:51:40 <dcoutts_> @where-add Pivotal http://www.cs.kent.ac.uk/projects/pivotal
10:51:41 <lambdabot> Unknown command, try @listcommands.
10:51:47 <dcoutts_> @where+ Pivotal http://www.cs.kent.ac.uk/projects/pivotal
10:51:48 <lambdabot> pivotal ~> http://www.cs.kent.ac.uk/projects/pivotal
10:54:18 <xerox> The structure editor idea is pretty neat.  Lisp folks had it for years, very, very nice.
10:54:29 <sylvan> yeah, really cool
10:55:14 <xerox> Rename within scope is something I'd like in Emacs too, heh.
10:57:09 <xerox> sylvan: proxima is win32 only?
10:57:34 <sylvan> nah, I don't think so
10:57:38 <sylvan> it uses wxHaskell I believe
10:57:38 <dcoutts_> it uses wxHaskell so it should work on linux
10:58:00 <xerox> I'd like to try it out.
10:58:33 <dcoutts_> well if someone wants to make a structure-editor style editor for it should be quite easy plug it into hIDE
10:58:58 <dcoutts_> hIDE is not restructed to using Yi, we've already got two editors
10:59:45 <dcoutts_> they should be pluggable (though of course not all editors support all operations)
11:00:56 <sylvan> You'd need a good plugin to handle dynamic type-checking and things like that too, that that the editor could use to display types (and perhaps haddock-comments) etc.
11:01:00 <xerox> Little "bug" in the Makefile, I suggest: EXTRA_HC_OPTS="-cpp" make depend
11:01:28 <dcoutts_> sylvan, we're planning on using the ghc-api
11:01:33 <xerox> dcoutts_: which is the other editor?
11:01:44 <sylvan> @where ghc-api
11:01:45 <lambdabot> I know nothing about ghc-api.
11:01:47 <sylvan> bah
11:02:02 <xerox> I'll leave proxima compiling... dinner time.
11:02:05 <dcoutts_> sylvan, read the VisualHaskell paper by Simon Marlow
11:02:19 <dcoutts_> sylvan, the ghc api will come with the next major version of ghc
11:02:21 <sylvan> ah.. it isn't in the ghc-distribution yet?
11:02:26 <sylvan> check
11:02:34 <dcoutts_> xerox, I've been testing with a simple editor based on GtkSourceBuffer/View
11:02:47 <dcoutts_> sylvan, it's in ghc-6.5 (ie the current cvs version)
11:03:01 <sylvan> okay
11:03:15 <sylvan> I think Haskell is very well suited for a highly intelligent editor
11:03:22 <dcoutts_> the VisualHaskell VS plugin comes bundeled with a ghc-6.5 snapshot
11:04:00 <dcoutts_> hIDE already uses ghc's lexer for syntax highliting
11:04:20 <xerox> We had no internet at school the other day so I couldn't download and try it, grmbl!
11:04:27 <davve> we should have a parser based lexer in the future though
11:04:31 <xerox> But I did Haskell instead of VB nevertheless ;)
11:04:40 <davve> parser based syntax highlighter, i mean
11:04:49 <sylvan> Yeah, that statement didn't compute =)
11:04:54 <davve> :D
11:04:56 <dcoutts_> davve, what advantage would that give?
11:05:12 <sylvan> \x -> x*2, would color the arrow different from f :: a -> b
11:05:17 <sylvan> for example
11:05:31 <davve> yeah, things like that
11:05:34 <sylvan> and you could highlight the current scope in some way perhaps
11:05:46 <dcoutts_> ah, now that's more interesting
11:06:07 <davve> hmm.. what about type level high lighting? :)
11:06:07 <sylvan> and even collapse a function defintion "like in VS.Net"
11:06:14 <dcoutts_> colouring types vs data constructors is not a highly compelling reason
11:06:20 <dcoutts_> in my humble opinion
11:06:44 <dcoutts_> yes, ok so doing more structure editor things would need parsing
11:07:07 <sylvan> I think it would be sweet to have an extremly intelligent editor that would suggest things based on the expected types (like intellisense but taking in account the type)
11:07:22 <dcoutts_> yes, that'd be great
11:07:46 <dcoutts_> in many circumstances there are only a few values/functions that would fit the required type
11:07:51 <sylvan> so if you write "minimum ..." it would realise that it would need a list of Ord a's and find the ones in the current scope which fits (and then of course filter by what you've typed)
11:08:06 <davve> sylvan, there is a plugin for eclipse that suggests code snippets based on the type of the object you want to create
11:08:11 <dcoutts_> we'd need an incremental parser probably
11:08:13 <davve> sylvan, for java that is
11:08:32 <dcoutts_> the ghc api is not designed for that kind of interactive use, the performance would not be good
11:08:33 <sylvan> maybe you could put all the other definitions in the list as well, but below a separator or something.. Sometimes you type the parameter before the function when you're chaning stuff around and so on
11:09:06 <basti_> doing that correctly would be highly complex
11:09:17 <sylvan> yes, but probably easier in Haskell than in C!
11:09:17 <sylvan> =)
11:09:22 <sylvan> and pretty damn useful
11:09:25 <basti_> imagine, i type something like "f . . g" and put the cursor in the middle
11:09:51 <dcoutts_> you'd need to be able to deal with partial syntax trees and partial type information
11:10:18 <sylvan> yeah it would bail out to regular intellisense then... or if you type "minimum ( .." it would realise that you're typing something which is of type (Ord b) => a ->b, where a can be anything
11:10:30 <sylvan> (because of the opening paranthesis)
11:10:31 <davve> the important things is to come up with a plugin API that lets people make this type of plugins
11:10:39 <dcoutts_> davve, indeed
11:11:07 <roconnor> Is shapr here?
11:11:48 <shapr> He is.
11:11:58 <shapr> What would you like to ask the man with the huge ego?
11:12:15 * shapr gives on the whole third-person bit.
11:12:27 <shapr> roconnor: Seriously, though, what can I do for you?
11:12:41 <davve> maybe we should have haskell type-checkers and parsers as plugins?
11:12:51 <roconnor> I've been reading that paper just now.
11:13:21 <shapr> roconnor: Oh, what do you think/
11:13:41 <roconnor> I just got to the part of distributive combinations of a comonad and monad
11:14:09 <roconnor> at this point my head exploded, and little bits of my brain are dripping down the walls.
11:14:54 <dcoutts_> davve, they can certainly be loaded as plugins, the interesting/tricky thing is makeing them swapable so that other tools don't need to know which one they're using, this requires makeing interfaces
11:15:22 <dcoutts_> which usually means picking some minimum featureset
11:16:05 <ulph> How are mplus and mzero defined in Control.Monad.State?
11:16:06 <davve> dcoutts, or having some cabability-based interfaces
11:17:02 <davve> but maybe it's better if plugins that need special functionality from a type checker are just children of that type checking plugin
11:17:16 <davve> I dunno
11:17:51 <davve> maybe not children, but that they require it directly
11:19:51 <davve> btw, should hIDE be used for Haskell only?
11:19:59 <roconnor> Anyhow, the paper at least make comonads seem useful in some situations.
11:20:15 <dcoutts_> davve, yes they would directly import that plugin rather than some interface which is implemented by one or more plugins
11:20:31 <dcoutts_> davve, plugins can easily import each other, they're just cabal packages
11:20:39 <davve> dcoutts, right
11:20:59 <dcoutts_> davve, not necessarily, we could edit C code or anything else
11:21:13 <dcoutts_> davve, and in not necessarily Haskell only
11:21:18 <dcoutts_> and/as
11:21:50 <dcoutts_> we can use the existing syntax highliting that GtkSourceView provides for languages other than Haskell
11:22:06 <dcoutts_> this is what hIDE with the Yi editor plugin does already
11:22:28 <davve> so the plugins API's should be language-neutral?
11:22:33 <dcoutts_> that allows us to support every other major language with basic syntax highliting
11:22:45 <dcoutts_> davve, oh, no. The plugins are implemented in Haskell.
11:23:09 <shapr> roconnor: I haven't quite understood the distributive part either.
11:23:35 <dcoutts_> davve, of course that allows us to use the FFI etc (the ide shell is just a plugin that uses the Gtk C libs)
11:23:50 <davve> dcoutts, I didn't mean it that way
11:23:56 <dcoutts_> oh, ok
11:24:09 * dcoutts_ was confused perhaps
11:24:24 <davve> dcoutts, I mean, the plugins API would be language neutral in the way that functionality that can be useful for any language should be supported and pluginnable
11:24:46 <davve> so that you can use hIDE for ocaml or any other language
11:24:50 <dcoutts_> hmm, give me an example, I'm not sure if I understand
11:24:54 <davve> with ocaml plugins
11:25:32 <davve> well, basically, no hard coded stuff like notions about Module-views or whatever in some core API's
11:25:48 <dcoutts_> so, eg a plugin to support intelegent indenting in the editor for ocaml source code
11:25:50 <davve> because a module is something language-specicif
11:26:23 <roconnor> Anyhow, time for me to go home.  Thanks for the reference shapr.
11:26:39 <dcoutts_> well at the moment we don't have a great deal of language-aware infrastructure
11:27:27 <dcoutts_> just in, the Yi editor plugin so far, it uses special syntax hl routines for Haskell and a fallback for everything else
11:28:06 <dcoutts_> I'm sure it'd be possible to write some special support for other languages if anyone is interested in doing it
11:28:33 <davve> okay, but, the reason I say this is just because I think maybe things are easier if Haskell is hard coded as the language to be edited, but maybe we want things to be more general
11:28:56 <dcoutts_> we just have per-language plugins
11:29:05 <davve> ok =)
11:29:20 <dcoutts_> if we end up supporting more languages then it might make sense to abstract out common code
11:29:26 <tic> Yi? Crazy :-)
11:29:41 <davve> tic, it's not the language Yi
11:29:50 <davve> dcoutts, yep
11:30:05 <dcoutts_> davve, the main constraint is developer time really
11:30:22 <basti_> hey musasabi, I've made a hawiki page about my hswebforms problem... http://www.haskell.org/hawiki/HsWebForms?action=show
11:30:37 <davve> dcoutts, yeah
11:32:17 <dcoutts_> davve, I'm tring to design the UI API such that it isn't really specific to editing Haskell code, or even files necessarily, it allows various 'editor pages' which know how to edit nodes in a big virtual tree of nodes (in practice these mostly correspond to editor views and files on disk)
11:33:15 <shapr> hiya sad0ur, learning Haskell?
11:35:54 <xerox> ulph: you can do:
11:35:57 <xerox> @libsrc Control.Monad.State
11:35:57 <davve> dcoutts, yeah.. I've looked at the code and read about it on the wiki. Sounds like a good idea
11:35:58 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/State.hs
11:37:31 * araujo should add Haskell on Gentoo in theHawiki
11:37:43 <dcoutts_> good idea araujo
11:38:12 <dcoutts_> araujo, we need to publicise the fact that Gentoo is the linux distro with the best Haskell support!
11:38:23 <araujo> :-]
11:39:03 <xerox> It stopped compiling because an overlapping instance problem, let's see if I can successfully complete the compilation of proxima :)
11:39:32 * dcoutts_ stops waving his Gentoo pompoms and goes home
11:39:41 <xerox> Later, Duncan :-)
11:39:42 <ulph> xerox: thanks
11:40:00 <xerox> ulph: you're welcome.
11:40:45 <araujo> later dcoutts_
11:43:24 <xerox> sylvan: did you compile proxima successfully?
11:49:49 <xerox> Bah, wxhaskell isn't debian-installable, I give up.
12:05:19 <xerox> @wikipedia Entanglement
12:05:22 <lambdabot> http://en.wikipedia.org/wiki/Entanglement
12:05:40 <shapr> Is there a wxHaskell cabal package?
12:11:52 <xerox> Complete a reading of a wikipedia article it's nearly impossible to me.  I always NEED to click on the links inside the text.
12:13:09 <mauke> middle click to open them in new tabs
12:13:44 <xerox> Right, but the number of them grows fast, and trying to skim them make the number grow exponentially.
12:14:14 <shapr> Try a depth-first search?
12:14:25 <shapr> Or maybe bookmark pages instead of opening them?
12:14:30 <xerox> Maybe I should get a firefox extension which disables links, then read the article, and enable them.
12:14:47 <xerox> ...or train myself, as a friend said one time.
12:15:41 <shapr> Self discipline is powerful.
12:16:44 <xerox> It's hard for me.  It took ages to learn to not do C-c C-SPC every time the trackbar in the modeline showed up something.
12:17:09 <xerox> (I still do it too much, leading to zero work done.)
12:18:21 <shapr> (erc-track-disable) or (setq erc-track-exclude ...)
12:18:48 <shapr> xerox: Also, use sanduhr and a specific goal.
12:18:50 <xerox> Discipline, self discipline.
12:18:59 <xerox> What is sanduhr?
12:19:05 <shapr> Are you using debian?
12:19:08 <xerox> Yep.
12:19:14 <shapr> apt-get install sanduhr
12:20:08 <shapr> Then something like: sanduhr +10m -m "refactor in preparation for Cale's improvement"
12:20:52 <shapr> Then you know you have exactly ten minutes to finish that task, so you don't have time to check irc!
12:21:10 <xerox> WOW
12:21:11 <shapr> For more detail - http://c2.com/cgi/wiki?SandglassProgramming
12:21:30 <xerox> That's a cool idea.  Thanks much.
12:21:36 <xerox> I just needed another webpage, didn't I? ;-)
12:21:38 <shapr> xerox: This has several advantages. First, if you spend three hours refactoring, something is very wrong.
12:21:52 <araujo> What is the C exec equivalent function in haskell?
12:22:07 <shapr> xerox: If you get distracted and start reading slashdot, the ring will snap you back to work.
12:22:16 <xerox> araujo: there is a popen implementation in lambdabot sources, FWIK.
12:22:30 <shapr> xerox: If you get interrupted playing three times in a row... do something away from the computer :-)
12:22:31 <xerox> shapr: I'm giving it a try, let's see how it goes.
12:22:44 <xerox> +bling+
12:22:57 <araujo> xerox, nice
12:39:31 <araujo> Does anybody know what are the last 3 arguments of executeFile ?
12:40:00 <xerox> @index executeFile
12:40:01 <lambdabot> System.Posix.Process, System.Posix
12:40:07 <xerox> @type System.Posix.executeFile
12:40:09 <lambdabot> FilePath -> Bool -> [String] -> Maybe [(String, String)] -> IO ()
12:40:30 <araujo> yeah xerox , i am reading the library reference, but it doesn't explain the arguments values
12:40:36 <xerox> 'buh' 'argv' 'env' ?
12:40:41 <araujo> reference library*
12:41:16 <araujo> Ok, what is the Bool?
12:41:38 <xerox> @docs System.Posix
12:41:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System.Posix.html
12:42:21 <xerox> @libsrc System.Posix.Process
12:42:22 <lambdabot> http://darcs.complete.org/fptools/libraries/unix/System/Posix/Process.hs
12:43:02 <xerox> executeFile :: FilePath			    -- Command
12:43:02 <xerox>             -> Bool			    -- Search PATH?
12:43:02 <xerox>             -> [String]			    -- Arguments
12:43:02 <xerox>             -> Maybe [(String, String)]	    -- Environment
12:43:07 <araujo> yeah, i am there, i know it gotta be true or false, but i don't know what it is used for....
12:43:11 <araujo> ah
12:43:32 <xerox> i.e. toggle the search in $PATH mechanism.
12:43:40 <araujo> yeah, get it
12:43:40 <araujo> thanks
12:43:49 <xerox> You're welcome.
12:51:13 <araujo> mmm...
12:51:26 <araujo> When ghc uses to give linking problems?
12:55:30 <araujo> lisppaste2, help?
12:55:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:56:01 <lisppaste2> araujo pasted "link" at http://paste.lisp.org/display/12022
12:56:10 <araujo> weird error, clue?
13:16:20 <xerox> Goodnight.
13:21:32 <autrijus> yo
13:21:46 <autrijus> jaffacake++ # exciting hacker to pair with
13:21:51 <autrijus> syntaxninja++ # too
13:22:15 <autrijus> so in my quest to get gadt-records in core I've now hacked with simon and simon
13:22:23 <autrijus> all bases are covered now, just fill in the details and submit :)
13:22:41 * autrijus does a little first-patch dance
13:24:27 * adept . o O (all our base are belong to him)
13:24:57 <autrijus> :D
13:35:15 <Lunar^> autrijus: how's Talinn?
13:35:26 <Oejet> syntaxninja == SPJ?
13:35:33 <musasabi> no
13:35:39 <Lunar^> Oejet: SyntaxNinja = Isaac Jones
13:35:58 <Lunar^> Oejet: SPJ never came to IRC, as far as I know
13:36:14 <Oejet> Lunar^: Oh, that's right.  autrijus: Was one of them SPJ?
13:36:27 <Lunar^> Oejet: Jaffac
13:36:28 <Oejet> Lunar^: That's what makes him productive. ;-)
13:36:33 <autrijus> Oejet: spj and jaffacake
13:36:36 <autrijus> spj last night
13:36:36 <Lunar^> Oejet: JaffaCake is Simon Marlow
13:36:40 <shapr> SPJ has been here twice.
13:36:43 <Oejet> Lunar^: I know.
13:37:04 <autrijus> Lunar^: Tallinn is wonderful. I finally learned how cabal and hackage works.
13:37:09 <autrijus> it's very neat.
13:37:29 <Lunar^> autrijus: Did House already been showed up?
13:38:22 <Lunar^> (uh my english is ugly this evening)
13:38:32 <autrijus> there has been a House talk.
13:38:58 <Lunar^> autrijus: Tolmach alone? or his co-workers too?
13:39:42 <autrijus> there was just one speaker
13:39:58 <Lunar^> must have been Andrew Tolmach then
13:40:42 <Lunar^> autrijus: How was it?
13:41:02 <autrijus> it was very nice.
13:41:16 <autrijus> "One feels safer in a House rather than just with Windows"
13:41:52 <Lunar^> good one :)
13:42:26 <adept> oh. Talinn.
13:42:44 * adept slaps himself for not going to ICFP this year.
13:42:57 <Lunar^> adept: if only I had the money
13:42:59 <adept> and it was so near ... Silly me.
13:43:30 <adept> Lunar^: where are you from? (or, rather, where you would be going from?)
13:43:38 <Lunar^> adept: France
13:43:51 <adept> hmmm...
13:44:08 <Lunar^> the entrance fees were prohobitive anyway
13:44:09 * adept tries to guess what is farther from Talinn ...
13:44:11 <Lunar^> prohibitive
13:44:21 <dcoutts> shapr, heh, really? what did SPJ think?
13:44:52 <adept> Lunar^: ah. Entrance fees! That must be the reason I haven't went :)
13:45:01 <musasabi> Yes, not exactly cheap.
13:45:28 * adept . o O (is it far from Talinn yet ... ? Not yet ... :)))
13:45:30 <Lunar^> autrijus: I wonder if Pugs could run on House
13:45:41 <Lunar^> autrijus: could make a great live CD :))
13:45:56 <autrijus> Lunar^: cross-compiled, probably yes
13:46:11 <autrijus> but would probably take a full L4-Posix to be interesting
13:46:44 <Lunar^> autrijus: we'll need a filesystem first maybe... did Isaac made his talk about the Haskell filesystem?
13:46:45 <adept> autrijus: it does not have to be interesting at first, it have to be great :)
13:47:01 <autrijus> Lunar^: no, that's for the workshop
13:48:20 <musasabi> A good OS could be quite different from *nix and just have a posix compability layer.
13:48:40 * musasabi would love to have a functional filesystem with proper metadata
13:48:43 <Lunar^> autrijus: I'm really looking forward to his work... that means a filesystem for House
13:48:58 <Lunar^> autrijus: with the GHC API, we could have an Haskell compiler
13:49:48 <Lunar^> musasabi: having a full Posix layer could be interesting, even to keep compatibility with the current hierarchical library
13:50:58 <musasabi> Lunar^: point, but the way to the future is re-implementing *nix.
13:51:04 <musasabi> is *not*
13:51:50 <Lunar^> musasabi: I can't agree much :) That's what interested me in hOp first!
13:52:18 <Lunar^> musasabi: but I lost some faith, though... I feel more working on practical things lately
13:55:22 <musasabi> Lunar^: but with practical things there are few advantages over the various *nix clones.
14:31:37 <sjanssen_> any ICFP winners here?
14:35:49 <dcoutts> sjanssen_, not from this year I think
14:36:36 * dcoutts used to have ICFP bragging rights but they expired
14:54:39 <wagle> dcoutts: are you now required to program in dylan?
14:55:28 <dcoutts> wagle, fortunately not since Haskell came first again :-)
14:56:03 <dcoutts> "The judges are happy to proclaim that Haskell is the programming tool of choice for discriminating hackers"
14:56:11 <wagle> but the judges said that dylan was cool
14:56:39 <dcoutts> but it's not the programming tool of choice
14:57:00 <wagle> haha
14:57:30 <dcoutts> dylan probably is cool, but around here we're discriminating hackers
14:58:33 <dcoutts> anyway at least we can all agree that it was nice to see C++/C/Java trounced
14:59:18 <astrolabe> Fantastic news!  I must get better at Haskell.
14:59:40 <dcoutts> oh they've updated the results page to give a ranking of the top teams (and my team came 9th)
15:05:57 <Lemmih> 'morning, #haskell.
15:06:00 <dcoutts> in the top 11 teams (ie the top 13 entries counting multiple entries per team) there are: 3 Haskell, 2 OCaml, 2 C, 2 C++, 1 Dylan and 1 Java.
15:06:05 <dcoutts> hia Lemmih
15:06:34 <dcoutts> Lemmih, you've seen that Haskell came top in the icfp contest again this year
15:07:42 * wagle wants to see someone do an accounts receivable in haskell..  8)
15:08:15 * dcoutts doesn't know what an "accounts receivable" is
15:08:49 <wagle> business accounting software that tracks money coming in
15:09:39 <dcoutts> sounds like the sort of boring software that you'd get paid lots to write
15:25:58 <astrolabe> 161 teams!  Then 9th is really good.
15:27:55 <dcoutts> (or 7th if you don't count multiple entries per-team) :-)
15:28:28 <Lemmih> Is there a list of the languages used?
15:28:36 <wagle> top 5 percentile:  truncate (100 * (9 / 161))
15:28:43 <wagle> @eval truncate (100 * (9 / 161))
15:28:44 <lambdabot> 5
15:30:41 <astrolabe> 34 c++,21 OCaml,20 Python,19 Java,16 Haskell,10 C,9 Perl and 32 others (each <=5)
15:32:37 <sethk> wagle, do you really want to do an A/R in Haskell.  As far as I know there is no good open source A/R program.
15:33:29 <sethk> dcoutts, it isn't necessarily boring.
15:34:00 <sethk> dcoutts, it can be interesting to construct one that is not succeptible to user error.
15:37:39 <astrolabe> Looking at the ICFP contest results, the haskell teams do seem to be definitely the best performers (judging by % of teams succesfully completing each stage)
15:46:08 <araujo> Hello herte
15:46:10 <araujo> here
15:46:24 <araujo> http://paste.lisp.org/display/12022 , anyone?
15:46:56 <dcoutts> araujo, -package unix
15:47:36 <dcoutts> or add unix to your cabal file if you'er building a cabal package
15:47:52 <dcoutts> Lemmih, so what are you hacking on now?
15:48:48 * dcoutts is hacking on a new improved data model for the ide shell
15:58:02 <araujo> Thanks dcoutts !
16:02:23 <araujo> @hoogle wait
16:02:25 <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool
16:13:56 <Lemmih> dcoutts: I'm trying to load interface files from 6.4 with ghc-api.
16:20:47 * shapr stabs postfix with a spoon.
16:20:52 <shapr> Man, I want to switch to Postmaster.
16:23:12 <wilx> Heh.
16:23:27 <wilx> Postfix looks rather good when I compare it to Sendmail.
16:23:39 <shapr> I used to be a sysadmin for sendmail.
16:24:20 <shapr> Sendmail is blindly fast to execute, but painfully slow to configure. That's mostly because it compiles to a bunch of regexs.
16:28:46 <sethk> wilx, I've had excellent luck with postfix
16:28:55 <sethk> wilx, good results with qmail as well
16:34:46 * SamB wonders if it is cheating to do TAOCP excercises in C
16:35:17 <SamB> all it said was "MMIX program", though, so a C program intended to work on MMIX should be fine, right?
16:37:08 <sethk> what's TAOCP?
16:37:53 <SamB> I did 1.3.2'.35, and almost exactly reproduce Knuth's metapost program for his example matrix...
16:38:16 <SamB> sethk: The Art of Computer Programming
16:38:30 <sethk> the knuth books?
16:38:35 <SamB> yeah
16:38:52 <sethk> MMIX is clearly supposed to be his made up assembly language
16:39:05 <sethk> so if your C compiler can generate MMIX code...
16:39:09 <sethk> it might be ok.  :)
16:39:09 <SamB> isn't that called MMIXal?
16:39:34 <sethk> I didn't think so, but I read the books 20 years ago when it  was MIX so I'm not sure
16:39:57 <sethk> I know a lot of people who won't use the knuth books because they use MIX
16:40:11 <sethk> which tends to indicate that the idea is that if you do use knuth, you do use MIX
16:40:16 <SamB> it still is MIX in the main books
16:41:39 <SamB> 1.3' and 1.4' are from Volume 1, Fascicle 1
16:43:38 <SamB> which is the one that replaces the material actually about MIX with material about MMIX
16:45:09 <SamB> the primes are until the rest of the material is updated to use MMIX...
16:46:07 * SamB wonders how useful an RTL parser would be in implementing MMIX for real
16:47:34 <SamB> (where by "for real", I mean supporting kernelspace as well as userspace. And I think it would need a new MMU/privilige system, too)
16:49:01 <sethk> SamB, there was a project at one time to make an MMIX back end for gcc, but I think it died of stupidity
16:49:13 <SamB> nah, GCC supports MMIX
16:49:20 <sethk> dumb
16:49:25 <sethk> :)
16:49:36 <sethk> in any event, why write for a hypothetical machine?
16:49:48 <SamB> though it is pretty stupid. not in terms of being a bad use of GCC, just that it doesn't output very good code.
16:50:09 <sethk> the only reason MIX exists in the first place is that when the books were originally written real assembly languages were seriously ugly
16:50:16 <sethk> but that's not been true for a long, long time
16:50:28 <musasabi> I think I figured out comonadic parser construction ^_^
16:50:29 <SamB> true
16:50:45 <musasabi> Now I can sleep in peace...
16:50:53 <SamB> I don't know why Knuth didn't pick a nice clean 24- or 32- bit arch and go with that
16:51:03 <sethk> SamB, egomania
16:51:18 <SamB> or at least SIMPLIFY rather than COMPLICATE
16:51:38 <SamB> and the equal division of the address space into four parts is silly
16:51:50 <SamB> which is why the MMU has to go ;-)
16:52:01 <SamB> oh, and that was just userspace.
16:52:52 <SamB> plus, he doesn't seem to have any sort of bus, mythical or otherwise, but that isn't quite so urgent...
16:53:13 <sethk> SamB, well, there is no need for something that would actually work ... :)
16:53:39 <SamB> but how am I supposed to write NNIX with such a stupid MMU?
16:54:27 <sethk> with lots and lots and lots of code
16:54:57 <SamB> it wouldn't be a real *nix without at least SOME implementation of an MMU, in any case...
16:58:04 <sethk> I'm convinced.
16:58:12 * shapr 's brain explodes
17:07:47 <SamB> shapr: your brain, why does it explode? comonads?
17:08:00 <shapr> yes, comonads.
17:08:22 <SamB> good, nothing to do with my ramblings about MMIX ;-)
17:08:49 <mcnster> hello
17:08:53 <shapr> hiya
17:09:12 <mcnster> i think i found a bug in fgl
17:09:27 <mcnster> in gsel
17:09:49 <mcnster> or i don't understand
17:10:38 <mcnster> shapr, u wouldn't be a fgl guru would u?
17:10:49 <shapr> Heck no.
17:11:02 <mcnster> drat
17:11:36 <shapr> I'd suggest you first ask on the haskell-cafe mailing list. If you don't get a response by the next day, contact the FGL maintainer and possibly Erwig himself.
17:12:04 <mcnster> ufold f u g | isEmpty g = u
17:12:04 <mcnster>             | otherwise = f c (ufold f u g')
17:12:04 <mcnster>             where (c,g') = matchAny g
17:12:36 <mcnster> if matchAny returns 1 arbitrary node, can this fn ever return more than 1 element?
17:16:42 <mcnster> ok, i'll try haskell-cafe.  thanks
17:41:31 <Cale> mcnster: I suppose I could have a look
17:42:07 <Cale> (though I'm not all that familiar with fgl -- I read the paper quite a while back
17:46:15 <Cale> mcnster: well, that ufold looks just like the one in the paper -- is it not doing what you expect?
17:46:34 <araujo> Hello hello
17:46:51 <Cale> I suspect that almost the whole library would be broken if it didn't work as expected, as it seems to be one of the first things defined and lots of stuff uses it.
17:46:55 <araujo> Anyone knows a good way to get an interval of values from a list?
17:47:18 <mauke> as in take . drop?
17:48:26 <mcnster> hi cale
17:48:32 <Cale> getRange start end xs = take (end - start) $ drop start xs
17:48:47 <Cale> mcnster: hi
17:48:48 <araujo> Thanks mauke
17:48:54 <araujo> Thanks Cale
17:49:03 <mcnster> cale, my problem is gsel in Graph.Inductive.Basic
17:49:04 <Cale> araujo: quite welcome :)
17:49:07 <araujo> :-]
17:49:09 <mauke> @pl \start end xs -> take (end - start) $ drop start xs
17:49:10 <lambdabot> ap (flip . (((.) . take) .) . subtract) drop
17:49:43 <mcnster> cale, gsel is returning only 1 context and it should return a list of all contexts that meet f
17:50:11 <Cale> hmm
17:55:16 <Cale> it really looks like it ought to work...
17:55:56 <Cale> -- | Return all 'Context's for which the given function returns 'True'.
17:55:56 <Cale> gsel :: Graph gr => (Context a b -> Bool) -> gr a b -> [Context a b]
17:55:56 <Cale> gsel p = ufold (\c cs->if p c then c:cs else cs) []
17:56:55 <mcnster> cale, that's whats so wierd--it should work
17:57:32 <Cale> hmm... perhaps matchAny isn't a good thing for ufold to use.
17:58:01 <mcnster> but when i make:
17:58:04 <mcnster> f con = (length $ pre' con) > 1
17:58:30 <mcnster> i only get one 1 con in a graph that i *know* has many that satisfy f
17:59:04 <Cale> I'll give it a shot :)
17:59:14 <mcnster> cale, thanks dude
18:00:42 <Cale> mcnster: note that you're matching against the context, and contexts are a somewhat ambiguous way to construct graphs
18:01:43 <mcnster> what is ambiguous about a context?
18:01:43 <Cale> try using pre instead of pre' ?
18:02:07 <Cale> er, hmm.
18:02:13 <Cale> that won't work due to types
18:02:22 <mcnster> cale, yep
18:03:15 <Cale> well, http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.ps.gz -- look at page 5
18:03:33 <Cale> see how the graph at the top has two constructions?
18:03:41 <mcnster> cale, looking...
18:04:01 <Cale> the colours denote the various contexts used to build up the graph
18:04:52 <Cale> a context has a list of (labelled) incoming arcs, a list of (labelled) outgoing arcs, a node number, and node label.
18:05:31 <Cale> but arcs need only be mentioned in one of their predecessor or their successor.
18:05:52 <mcnster> hmm
18:05:59 <Cale> so the context doesn't really give you complete adjacency information for the vertex.
18:06:06 <Cale> just part of it
18:07:37 <shapr> dave_m: Hiya!
18:07:50 <dave_m> Hi, shapr
18:08:06 <mcnster> holy smokes ur right
18:08:14 <shapr> dave_m: I like your recent comonads code.
18:08:45 * musasabi wakes up on magic words
18:08:48 <dave_m> shapr: thanks. Since posting, I noticed I defined a few things the hard way.
18:09:32 <musasabi> dave_m: Do you think a Maybe comonad is possible?
18:09:55 <mcnster> cale, many thanks
18:10:09 <dave_m> musasabi: Not sure. What would it do?
18:10:48 <musasabi> dave_m: Use the GADT encoding technique in a simple to understand manner.
18:11:17 <shapr> dave_m: Do you have a more recent version of your comonad sources online?
18:11:35 <dave_m> musasabi: The Maybe would do that, or are you asking me to do that
18:12:11 <dave_m> shapr: Not on-line. I haven't done much with comonads b/c I don't really understand them
18:12:27 <shapr> Neither do I, but that's why I'm interested...
18:12:33 <dave_m> Same here
18:12:38 <Cale> mcnster: good :)
18:13:20 <dave_m> Right now I'm working out a comonad for decorated NTree zippers, to see if they make XML processing any simpler
18:13:34 <musasabi> dave_m: I ran into some problems when defining it.
18:14:12 <dave_m> musasabi: I don't think you can capture error effects with a comonad
18:14:45 <dave_m> maybe if there's always a rational default value
18:14:54 <musasabi> dave_m: but you can produce a computation which can have errors.
18:16:12 <dave_m> Right, but the comonad would be about operating in a context with errors, rather than generating errors, if  I understand correctly
18:16:28 <dave_m> (which I don't guarantee)
18:17:20 <Cale> I don't think one should expect that comonads are useful for the same things monads are useful for :)
18:17:28 <musasabi> I think it is more like the comonad operating in a universe which forces error values into it the results.
18:18:03 <musasabi> s/it//
18:20:01 <dave_m> Well, (Condition, a) is a comonad; you could use it to indicate whether an error has already occurred
18:20:25 <Cale> a graph library which uses Diff arrays is just begging to be written
18:20:43 <Cale> (unless, of course, one already exists which I don't know about)
18:22:45 <musasabi> dave_m: thanks, I think I got it.
18:25:31 <TheHunter> musasabi, your comonad examples don't use the full power of comonads, they just need fmap and a function f a -> a.
18:26:30 <TheHunter> coreturn v = fmap (const v)
18:29:08 <musasabi> TheHunter: are you meaning the combinators (>>-) - they are indeed very simple, but they looked nice for State comonads.
18:29:30 <musasabi> Now with vastly different comonads I am seing that they are not the only direction to go.
18:29:58 <dave_m> I think the "state-in-context" name is misleading
18:30:48 <TheHunter> yes, that's what i meant.
18:31:12 <TheHunter> I would even go as far as to say that there is no state comonad (it least, I haven't seen one yet).
18:31:37 <dave_m> It's dual to the state monad, but Either is dual to (,), and they're hardly interchangeable
18:32:00 <Pseudonym> The "state comonad" is actually an environment comonad.
18:32:48 <TheHunter> "state comonad" would suggest that the cokleisli arrow is a state arrow, which is not the case.
18:33:11 <dave_m> One trick I discovered is that it lets you change the context of *prior* computations; that's the difference between it and the product comonad
18:33:55 <shapr> How does that work?
18:34:24 * PeterK notes that this "comonad" stuff is a whole different language for him.
18:34:57 <Pseudonym> I don't know what your coproblem with it is.
18:35:12 <Pseudonym> Cocategory theory is perfectly cocomprehensible.
18:35:16 <PeterK> co-monad. oh, thank you. I was reading como-nad.
18:35:24 <dave_m> We're all cofamiliar with it
18:35:32 * shapr grins
18:35:40 <shapr> What's the dual of familiar?
18:35:47 <PeterK> confamiliar
18:36:03 <dave_m> That's when it knows about you
18:36:21 <Pseudonym> So friendship is coparanoia.
18:36:22 <musasabi> dave_m: yes, changing prior state was scary.
18:36:51 <musasabi> shapr: Using =>> and friends lands you into modifying the past state, not the future one.
18:37:07 <dave_m> musasabi: it does make the head hurt
18:37:54 <Cale> hehe
18:38:09 <musasabi> dave_m: This is why I started using >>- (and >>--) for StateW - but they don't seem to make sense for some other comonads.
18:38:13 <Cale> It's probably just bad to think of it as state.
18:38:44 <dave_m> Which is why the OI comonad was doomed from the start
18:39:13 * musasabi tries to think about modifying what the machine did in the past.
18:39:59 <dave_m> Aside from the product comonad and the exponent monad, there probably aren't any comonads that do the same thing as a monad
18:40:32 <TheHunter> the identity comonad? (scnr)
18:40:59 <dave_m> I guess. It's the same functor as the identity monad, though
18:41:13 <dave_m> It's a monad *and* a comonad.
18:42:14 <Pseudonym> I wonder if every functor has a free comonad.
18:42:20 <Pseudonym> I think it probably would.
18:42:40 <Pseudonym> I see nothing in the definition of a functor which would make monads special in that respect.
18:43:04 <dave_m> I know that for any functor f, Strf f a = a :< f (Strf f a) is a comonad
18:43:11 <Pseudonym> Maybe the functor needs to be contravariant or something.
18:43:28 <Pseudonym> Actually, THAT would make sense.
18:44:35 <musasabi> dave_m: yes that is a nice comonad.
18:45:01 <dave_m> It turns out to be very handy for decorating datastructures
18:45:13 <Pseudonym> So... what's the equivalent monad?
18:45:18 <musasabi> dave_m: Do you know any nice ones beside finite (Maybe), rose-trees ([]) and newtype Bin a = Bin (a,a), binary trees.
18:45:54 <musasabi> Also PArrow type parsers are comonads.
18:47:17 <dave_m> musasabi: Strf F a is a decorated version of T if F is a functor such that T = F T
18:47:43 <dave_m> I've been using NSpine node ntree = NS node [ntree]
18:48:04 <dave_m> NTree node ~= NSpine node (NTree node)
18:48:10 <musasabi> dave_m: yes, but any functors good for general purpose things other than those mentioned.
18:48:22 <eieiei> why  should I use Haskell instead of Ada?
18:48:36 <sethk> eieiei, because you aren't insane?
18:48:42 <Pseudonym> http://www.swiss.csail.mit.edu/users/dae/notes/monads-algebra
18:49:01 <Pseudonym> Now here's the thing.
18:49:13 <Lemmih> eieiei: Beacuse Haskell is the programming tool of choice for discriminating hackers.
18:49:30 <Pseudonym> Hmmm.
18:49:32 * Pseudonym thinks
18:49:45 <eieiei> I read that Ada is a modern programming language designed to support sound software engineering principles and practices.
18:49:57 <sethk> eieiei, modern?
18:50:03 <Pseudonym> Modern enough.
18:50:10 <Pseudonym> eieiei: You should learn both.
18:50:23 <sethk> learn?  yes.  deploy?  no
18:50:25 <Pseudonym> The more programming languages you know, the better your programming will be.
18:50:35 <musasabi> Look at both and you will probably find out which will suit your needs better.
18:50:41 <Pseudonym> For a given problem.
18:50:54 <musasabi> We obviously have an opinion on that.
18:51:03 <Cale> Ada is somewhat insane. I remember my friend going nuts writing an Ada compiler.
18:51:20 <sethk> It would be difficult to find a problem that is better solved in Ada than in, say, C++ or Java
18:51:24 <Pseudonym> Oh, writing Ada COMPILERS is insane.
18:51:36 <musasabi> Cale: but the language has nice sane subsets.
18:51:38 <eieiei>  "This programming language is the result of careful, deliberate design choices; by design it is intended to solve (directly or indirectly) many definite problems in software engineering. Many of these problems still plague those who do not use Ada."
18:51:40 <Pseudonym> Excuse me?  I'd take Ada over Java any day.
18:51:51 <sethk> Pseudonym, the language?  I don't think so.
18:51:55 <sethk> why?
18:51:56 <Pseudonym> Yeah, I would.
18:52:01 <Pseudonym> Though I'd prefer Modula-3 to both of them.
18:52:05 * eieiei is not good at trolling.
18:52:14 <sethk> eieiei, keep trying.
18:52:28 <Cale> you're not persistent and inflammatory enough
18:52:32 <sethk> eieiei, if you want to troll here, you should probably talk about, oh, I don't know, how about clean?
18:52:39 <eieiei> haha, yes.
18:52:42 <Pseudonym> Yes, I'd take Ada the language over Java the language.  Java the language is one of the least flexible languages there is.
18:52:47 <musasabi> eieiei: What kind of application need do you have in mind or are you learning the language for fun?
18:52:55 <Pseudonym> Though there's no problem you can't solve in Java if you apply enough reflection, I suppose.
18:53:46 <sethk> Pseudonym, I think ada is equally inflexible.  I admit it's been over a year since I was aggraved by ada, though.
18:53:51 <eieiei> I'm not learning Ada.
18:54:02 <eieiei> I'm looking around at Haskell because I like Scheme.
18:54:14 <Pseudonym> Ada has the advantage that it supports a lot of modern idioms, especially generic programming.
18:54:27 <eieiei> I love Scheme. I never had so much fun programming since I was a child dabbling with Basic.
18:54:39 <Pseudonym> But I'd almost certainly choose C++ over Ada, if only because non-zealots care about it.
18:54:48 <sethk> eieiei, well, that's better.  :)
18:54:50 <Pseudonym> (As well as some zealots.)
18:55:01 <Pseudonym> Yes, we appreciate Scheme around here, even if we don't use it.
18:55:02 <sethk> Pseudonym, yes, I'd agree.
18:55:47 <Pseudonym> We tend to avoid dynamic typing vs strong typing flamewars here, unless we're REALLY bored.
18:56:01 <musasabi> Haskell is very good at building abstractions that suit the applications needs. Many times one implements just a sub-language (really just a collection of functions and combinators (which are functions)) that suits the needs. Then the main application becomes very easy to implement with the DSL.
18:56:10 * dave_m puts away his "Strong Typing R00lz!" signs
18:56:54 <Pseudonym> We also appreciate ML and variants, though some of us detest the syntax.
18:57:18 <dave_m> I'm too lazy to learn ML
18:59:11 <Pseudonym> Which is why you use Haskell.  Laziness is encouraged.
18:59:48 <eieiei> I wish Haskell was dynamically typed. Or that there was a Scheme/Lisp variant with a Haskell-ish syntax.
19:00:17 <dave_m> It's not Haskell-ish, but have you looked at Dylan?
19:00:32 <eieiei> just the Hello world stuff.
19:00:43 <eieiei> Anyway, I have to learn to deal with typed languages one day.
19:00:49 <eieiei> so I'd better get started.
19:00:56 <Pseudonym> Haskell would be an excellent choice.
19:01:14 <Pseudonym> Haskell's type system is one of the most flexible that you'll find in a practical language.
19:01:21 <eieiei> yeah. I managed to write nifty stuff letting the compiler guess types, but I found a few show-stoppers.
19:01:45 <Pseudonym> You'll get to the point where those show stoppers tend to be flaws in your thinking.
19:01:55 <eieiei> Scheme is nice because code = data.
19:01:57 <dave_m> After using Haskell, I get nervous when using dynamic typing. "How do I *know* this input is a number?", etc.
19:02:03 <eieiei> so you get to do stuff like this:
19:02:42 <lisppaste2> eieiei pasted "symbolic logs" at http://paste.lisp.org/display/12035
19:04:56 <dave_m> I do envy Scheme/Lisp's ability to define new binding forms.
19:07:08 <musasabi> dave_m: Should I be worried if I can define the same thing both as a monad and comonad (that is define both instances for the same datastructure)
19:07:13 <Pseudonym> Sometimes I envy Prolog's syntax, too.
19:07:33 <Pseudonym> The ability to specify arbitrary operators, with all sorts of weird and wonderful fixities is kinda cool.
19:08:02 <dave_m> musasabi: Assuming it satisfies the various laws, no. The identity functor is a monad and a comonad
19:08:18 <sethk> Cale, are you about?  I have a question about the parsec stuff we were talking about
19:08:28 <Pseudonym> musasabi: Did you have a specific thing in mind?
19:08:47 <Cale> sethk: yep
19:08:53 <Pseudonym> In Haskell, every functor has a "strength" criterion which means that it has a free monad.
19:09:02 <musasabi> Pseudonym: parsers.
19:09:07 <eieiei> are those functors like category-theory functors?
19:09:07 <Pseudonym> I'm guessing that every functor probably also has a free comonad.
19:09:14 <Pseudonym> eieiei: Yes!
19:09:14 <sethk> Cale, remember I was constructing a LanguageDef record to use with makeTokenParser
19:09:19 <eieiei> how so?
19:09:22 <Pseudonym> If you know some category theory, you HAVE to learn Haskell.
19:09:31 <sethk> Cale, I have that done, the LanguageDef part, that is.
19:09:46 <Cale> eieiei: class Functor f where fmap :: (a -> b) -> (f a -> f b)
19:09:47 <eieiei> I've done up to chapter 4 of Michael Arbib's "Arrows, structures, functors".
19:09:53 <Pseudonym> Ah, cool.
19:09:53 <sethk> Cale, so now I have a TokenParser st
19:10:04 <Cale> sethk: okay
19:10:07 <Pseudonym> It would be more correct to call Haskell functors "endofunctors".
19:10:28 <Pseudonym> But you can think of Haskell as being a category, with types as objects and functions as morphisms.
19:10:36 <sethk> Cale, now I want to make a parser for a string.  string "select" to be specific, was what I did with CharParser
19:10:41 <Cale> yeah, they're endofunctors on the category of types and Haskell-definable functions
19:10:48 <Pseudonym> Haskell directly supports endofunctors in that category.
19:10:55 <dave_m> Pseudonym: for every functor F, there is a cofree comonad and a cofree recursive comonad
19:11:03 <sethk> Cale, but how do I take my TokenParser st, and use it?
19:11:08 <Pseudonym> dave_m: Right.
19:11:21 <eieiei> Duality cuts work in half.
19:11:27 <Pseudonym> So we should not be surprised if you can express a monad and a comonad on the same data structure.
19:11:40 <sethk> Cale, do I create a parser for the string, as before?
19:11:56 <dave_m> I guess the writer monad and the product comonad are similar
19:13:46 <Korollary> @seen dbremner
19:13:47 <lambdabot> I saw dbremner leaving #haskell 17 days, 19 hours, 54 minutes and 52
19:13:47 <lambdabot> seconds ago, and I have missed 1 minute and 49 seconds since then.
19:14:32 <dave_m> If M is a monoid, then F A = M * A is a monad and a comonad
19:14:55 <Cale> sethk: well, you included that string in your list of reservedNames?
19:15:00 <sethk> Cale, yes
19:15:18 <sethk> Cale, does the TokenParser then return identifier?
19:15:31 <sethk> Cale, identifier being a CharParser st String?
19:15:42 <Cale> yeah it has the identifier parser in it, as well as reserved
19:15:57 <sethk> Cale, oh, sorry, identifier is a string that's _not_ a keyword
19:16:01 <sethk> Cale, mixed those up
19:16:04 <Cale> reserved "select"
19:16:28 <sethk> Cale, ah, thanks, let me play with that.  I think I'm closer to understanding how this works.
19:16:30 <Cale> it will make sure not to match things like selectNames
19:16:41 <Cale> (which is, say an identifier)
19:17:02 <sethk> Cale, TokenParser is not a type, it is a record?  (record is the correct term for   data .....  ?
19:17:25 <Cale> it's both the name of a type and a record constructor
19:17:47 <sethk> Cale, then does the context resolve that ambiguity?
19:17:52 <Cale> yes
19:18:06 <Cale> because type constructors can only occur in type signatures
19:18:27 <sethk> Cale, neat.  I understand why it makes sense to use the same name, when you are very familiar with this stuff, but it sure can confuse us newbs.  :)
19:18:32 <Cale> yeah
19:19:38 <sethk> Cale, ghci doesn't recognize reserved  in myThing.reserved.  Maybe I created the type, not the record?
19:19:42 <Cale> the term "record" tends to only get used when you're using the record-syntax for data constructors
19:20:15 <Cale> well, types and data are separate -- you called makeTokenParser?
19:20:16 <sethk> Cale, ghci (:t) says it is a Text.ParserCombinators.Parsec.Token.TokenParser
19:20:21 <Cale> okay
19:20:31 <eieiei> what is a combinator?
19:20:59 <sethk> Cale, so how do I use that?  Or am I on the wrong track and I shouldn't have created it?
19:21:07 <Cale> that's what you need
19:21:32 <Cale> try:  reserved myThing
19:21:37 <dave_m> A combinator is a function with no free variables. But I usually use it to mean higher-order function
19:21:49 <sethk> Cale, oh, not  myname.reserved, just reserved.
19:22:02 <Cale> you pass it as a parameter
19:22:19 <Cale> :t reserved and see what you get
19:22:40 <dave_m> if "myname" is a value and "reserved" is a field, then you want "reserved myname"
19:22:47 <Cale> right
19:23:07 <sethk> Cale, ghci says  "not in scope: `reserved'
19:23:33 <Cale> check that Parsec.Token is loaded
19:23:49 <sethk> Cale, it has to be, :t myname   shows  TokenParser
19:24:08 <sethk> Text.ParserCombinators.Parsec.Token.TokenParser st to be specific
19:24:11 <sethk> so it is loaded
19:24:47 <sethk> so I have a value that is a TokenParser   if I understand
19:24:51 <Cale> right
19:25:02 <sethk> so I do  myname reserved?
19:25:09 <Cale> reserved myname
19:25:18 <Cale> reserved myname "select"
19:26:04 <sethk> Cale, ah, I see, although I have to qualify it as Text.ParserCombinators.Parsec.Token.reserved
19:26:22 <Cale> oh, then that module probably isn't properly loaded
19:26:32 <Cale> :m + Text.ParserCombinators.Parsec.Token
19:26:38 <Cale> will bring it in
19:26:53 <Cale> or add "import Text.ParserCombinators.Parsec.Token" to the top of your file
19:27:21 <sethk> Cale, oh, I imported it qualified, so I have to use the qualified name
19:27:27 <Cale> yeah
19:28:07 <Cale> if you want to keep it qualified, you'd probably be better off with something like import Text.ParserCombinators.Parsec.Token qualified as Token
19:28:18 <sethk> Cale, yes, that's what I did
19:28:47 <sethk> Cale, another question, how can I make keywords case insensitive while keeping identifiers case sensitive?
19:29:01 <sethk> Cale, I know I can force the input string to upper case, but I don't want to if possible
19:30:17 <Cale> set caseSensitive?
19:30:22 <Cale> in the LanguageDef?
19:30:42 <sethk> Cale, case sensitive is true, but I want select or SELECT or Select, etc.
19:30:49 <sethk> Cale, case insensitive for keywords
19:30:53 <sethk> Cale, but not for identifiers
19:31:03 <sethk> Cale, is that just caseSensitive false?
19:31:10 <sethk> Cale, and it will return the identifier as typed?
19:31:16 <sethk> Cale, as in the string, that is.
19:31:35 <Cale> hmm -- well, if you set it to true, does the identifier parser automatically lowecase the identifiers?
19:31:48 <sethk> Cale, I'm constructing an example to see.
19:31:56 <sethk> Cale, thanks for all your help, by the way.
19:32:12 <Cale> sethk: no problem :)
19:33:49 <sethk> Cale, it does the "right thing" (that is, it doesn't lowercase the identifier with caseSensitive false)   :)
19:34:04 <Cale> okay :)
19:36:18 <sethk> Cale, ok, now I have my still abstract st that is part of my language def   LanguageDef st   .  If I want to stuff data into it, it has to be a monad and I use <- to put data in it?
19:36:38 <sethk> Cale, in cases where the parser doesn't return what I need
19:36:45 <sethk> Cale, should that come up
19:36:55 <sethk> Cale, is that the way st is intended to be used?
19:37:14 <sethk> Cale, or should the parser return st?  whatever st turns out to be?
19:37:33 <Cale> well, the parser is a monad and it's carrying around a piece of state data for you
19:37:49 <Cale> the type of parsers is a monad
19:38:01 <sethk> Cale, right.  I'm thinking now about the type of st
19:38:07 <Cale> you use getState and setState if you want to get and set the state
19:38:27 <sethk> Cale, ok, I'll look at those.
19:38:49 <neadjneki> :)
19:40:47 <sethk> Cale,  the parser returns getState  ?
19:41:17 <Cale> getState is a parser which does no parsing and returns the current state
19:41:52 <Cale> setState is a function which takes a new state and returns a parser which sets the state, does no parsing, and returns ()
19:42:13 <Cale> when you call runParser, you set the initial state
19:42:24 <Cale> runParser  :: GenParser tok st a -> st -> FilePath -> [tok] -> Either ParseError a
19:42:34 <Cale> see the st that gets passed in there?
19:43:03 <sethk> Cale, ok.  The example I see in the docs where they use getState is, within a do,     n <- getState; return n
19:43:05 <Cale> that parameter is the initial value for the state
19:43:10 <Cale> right
19:43:28 <sethk> Cale, I can use setState within the parser to change it.
19:43:32 <Cale> which runs the getState parser, captures its result in 'n' and then returns n
19:43:51 <Cale> which, incidentally, is exactly the same as getState alone :)
19:43:56 <sethk> Cale, right.  That's why I was asking whether I have to return the state
19:43:57 <Cale> right
19:44:00 <Pseudonym> Gotta go.
19:44:01 <sethk> Cale, right, I figured that.
19:44:09 <sethk> Cale, that's why I asked about returning getState
19:44:35 <Cale> assuming that the state is a numeric type, you could write something like incState = do { n <- getState; setState (n+1); return () }
19:44:39 <Cale> or just
19:44:42 <Cale> assuming that the state is a numeric type, you could write something like incState = do { n <- getState; setState (n+1) }
19:44:49 <Cale> whoops :)
19:44:49 <Cale> heh
19:45:17 <Cale> that's right though :)
19:45:31 <sethk> so I don't have to return getState?
19:45:44 <sethk> I can use getState in the caller?
19:46:00 <Cale> you use getState to get the current state while parsing
19:46:20 <sethk> ok, then if I don't return getState, I can't get the value.  I'm asking because your second example doesn't return it
19:46:48 <sethk> the other doesn't either.  :)
19:47:22 <sethk> Cale, so if you did   setState(n+1)  in the parser, and I don't return getState, how do I get to that value?
19:47:33 <sethk> Cale, or was that a fragment and I do return getState?
19:47:50 <Cale> okay
19:48:02 <Cale> so let's write a parser which uses incState
19:48:12 <sethk> good, thanks
19:48:36 <Cale> do { n <- getState; incState; m <- getState; return (m-n) }
19:49:10 <Cale> let's give that a name, say  testIncState
19:49:36 <Cale> If we run it with runParser testIncState 0 "" ""
19:50:01 <sethk> so that's a parser that returns an integer
19:50:07 <Cale> yep
19:50:11 <sethk> which could be getState if that happens to be the value we want
19:50:16 <Cale> in particular, it will return 1
19:50:23 <sethk> right, I see that in this case
19:50:30 <sethk> but presumably that isn't the only option.  :)
19:51:09 <Cale> well, that parser will always return 1
19:51:23 <sethk> I see getState, setState, and updateState, but not incState, in the docs
19:51:23 <Cale> because it's returning the difference between the old state and the incremented state :)
19:51:31 <Cale> I just wrote incState
19:51:34 <sethk> right, a somewhat contrived example
19:51:40 <Cale> incState = do { n <- getState; setState (n+1) }
19:51:41 <sethk> ok,
19:52:04 <Cale> this is contrived, but I'm just using it as an example of how to get and set the state
19:52:29 <sethk> If I need a state that is complex, I can make it a tuple, or a data x y z?
19:52:44 <sethk> a state that is more than a single value
19:52:52 <sethk> then I use a structure of some sort
19:52:56 <sethk> list, data, tuple
19:53:28 <Cale> right
20:01:19 * juhp imports haddock into Fedora Extras cvs :)
20:06:59 <sethk> Cale, I have it parsing two real statements already.  This thing is amazing.  :)
20:07:11 <Cale> :)
20:15:49 <juhp> built!
20:19:19 <PeterK> where can I find a natural deduction engine for first order predicate logic written in Haskell, if there is one?
20:20:00 <Lemmih> dons: I got ghc-api to load interface files from 6.4 (:
20:20:09 * Lemmih just compiled a Haskell file from GHCi.
20:21:12 <juhp> Lemmih: into 6.4.1?
20:21:32 <Lemmih> juhp: into 6.4.1?
20:21:55 <juhp> Lemmih: sorry - just a naive question :)
20:22:25 <vina> nighty night...
20:22:26 <juhp> Lemmih: load 6.4 .hi file into what? :)
20:23:06 <vina> does anybody here have the Haskell 98 Language Report at hand?
20:23:10 <Lemmih> juhp: To GHC's internal representation.
20:23:26 <juhp> ok cool
20:24:14 <juhp> Lemmih: was just daydreaming that you might have found a way to work around ghc ABI version restrictions :)
20:24:17 <Korollary> vina : I do
20:24:44 <Lemmih> juhp: hIDE will use the GHC api and the libraries from 6.4.* for renaming and typechecking.
20:25:04 <vina> Korollary: can you help me? there is a thing that puzzles me...
20:25:20 <Korollary> vina: I'll try
20:25:29 <juhp> Lemmih: oh, so it will be possible? :-)
20:25:39 <vina> Korollary, see page 37
20:25:50 <vina> section 3.17.3
20:26:21 <Korollary> ok
20:26:24 <dons> Lemmih!!
20:26:27 <dons> very nice
20:26:46 <vina> Korollary, figure 3.1, first line
20:27:04 <vina> (a) case e of { alts } ...
20:28:30 <Korollary> vina: I don't know formal semantics, but the lambda expression doesn't make it more understandable than it already is, imho
20:29:01 <eieiei> vou, amor.
20:29:23 <vina> Korollary, I use to read more "gentle" text, but in some cases, the formal definition helps...
20:30:01 <vina> Korollary, anyway, my question might sound stupid...
20:30:25 <vina> Korollary, what is the "alts" in the expression????
20:30:33 <Korollary> vina: alternatives
20:31:05 <vina> Korollary, I told you that it was stupid :-$
20:31:10 <vina> thanks!!!
20:31:24 <Korollary> vina: no problem :)
20:41:20 <sethk> in this:   do { x; y; z }     do the three parts, x y and z, have to be the same type?  More generally, what are the possible types for x y and z?
20:41:38 <sethk> does x set the type?
20:42:07 <mauke> @type \x y z -> do {x; y; z}
20:42:23 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => m a -> m a1 -> m b -> m
20:42:23 <lambdabot> b
20:43:06 <ricebowl> how do you convert an Int into a Double?
20:43:20 <Korollary> sethk: do {e;stmts} 	=	 e >> do {stmts}. Just syntactic sugar. '>>' plays a role in determining the types.
20:43:40 <Cale> sethk: so they can be different types, but have to be in the same monad
20:44:29 <mauke> @hoogle Int -> Double
20:44:33 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
20:44:33 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
20:44:33 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
20:44:53 <Korollary> @hoogle Int -> a
20:44:54 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
20:44:54 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
20:44:54 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
20:45:19 <Korollary> @type fromIntegral
20:45:21 <lambdabot> forall b a. (Num b, Integral a) => a -> b
20:45:29 <Cale> mauke: fromIntegral?
20:45:29 <ricebowl> hm
20:45:30 <mauke> @eval (toEnum (42 :: Int)) :: Double
20:45:36 <lambdabot> 42.0
20:45:40 <mauke> huhu
20:46:21 <ricebowl> I used fromInteger, can't seem to get it to convert to double, but I guess that syntax you used binds it to Double?
20:46:38 <Cale> fromIntegral is what you want
20:46:41 <JohnMeacham> hmm..
20:47:09 <Cale> probably context will force it to Double -- if not, add a type sig
20:47:26 <sethk> Cale, so if the first value in the do is   CharParser st (), then the others have to be   CharParser  somethingorother  ?
20:47:31 <ricebowl> yes, I was unaware of type sigs
20:47:49 <ricebowl> mm... I think it was doing Integer -> Integer
20:47:54 <ricebowl> alright, thanks
20:48:32 <Korollary> JohnMeacham: How is JHC going nowadays ?
20:48:48 <Cale> CharParser st somethingorother
20:48:51 <Cale> yeah
20:54:33 <sethk> Cale, I put, in my do values,   n <- Prim.getState;     which is fine.  but when I put in     Prim.setState "abc";  I get an error because the type of the parser is now    GenParser Char [Char] String    instead of  GenParser Char st [Char]
20:54:56 <sethk> Cale, it isn't the String vs. [Char]
20:56:46 <JohnMeacham> Korollary: fine :) I have started working on it more recently and musasabi has been doing some great work too.
20:56:46 <Cale> check that the type signature matches
20:57:09 <Cale> (you'll have to replace st with String)
20:57:29 <Cale> just for the definition of that one parser
20:57:38 <Cale> and anything which uses that parser
20:57:46 <Cale> but not the parsers used to build it
20:57:56 <sethk> Cale, ok, let me see ...
21:04:10 <sethk> Cale, I must not have understood.  If I change the signature to be GenParser Char String String  it still barfs.  Because I'm using it as an argument to run
21:05:23 <Cale> ah, you need to run it with runParser
21:05:36 <sethk> ok, let me see...
21:05:41 <Cale> and pass in an initial state
21:06:14 <Cale> you can set the FilePath to "" if there's nothing obvious to set it to
21:08:23 <sethk> ok.  Now I just need to spend a few hours figuring out why that works.
21:08:54 <Cale> okay
21:09:08 <Cale> well, if you want a simpler example, look at the State monad
21:09:58 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.State.html has a bit of documentation
21:10:22 <Cale> http://www.nomaware.com/monads/html/statemonad.html
21:12:17 <sethk> Cale, thanks, I'll read those.  I doubt I'll understand it, but I'll try it.
21:14:37 <sethk> Cale, is it because the other run function (the non-parsec one) does not take the st argument?
21:16:23 <Cale> yeah
21:16:37 <Cale> it just calls runParser with () passed as the st argument
21:16:53 <Cale> which basically means you don't get to keep track of extra state.
21:17:17 <sethk> and adding the setState "abc";    changes the type of the parser?
21:17:27 <sethk> before that, it doesn't know about st?
21:18:08 <sethk> putting that line in changes the inferred type of the parser that contains it
21:23:12 <Oejet> Good morning.
21:23:31 <Lemmih> Hi Oejet.
21:23:36 <Lemmih> You're up early.
21:24:15 <Cale> sethk: yes
21:24:27 <sethk> Cale, ok.  it isn't as bad as I thought.  :)
21:24:44 <Oejet> Lemmih: Got up at five to clean up my room. :-)
21:25:54 <Oejet> Lemmih: You are awake early too.
21:27:24 <Lemmih> Nah, I'm up late.
21:28:53 <Oejet> Thought so. ;-)
21:36:06 <mcnster> hello
21:36:16 <Lemmih> Hi mcnster.
21:36:27 <mcnster> lemnih, hi
21:36:37 <mcnster> quick q
21:36:49 <mcnster> is there an easy way to eliminate duplicates in an unsorted list?
21:37:19 <mauke> @eval List.nub [1,2,3,2,2,3,2,1,4,2,4,5]
21:37:36 <sethk> speed demon today
21:37:49 <lambdabot> [1,2,3,4,5]
21:38:26 <mcnster> oh wow, i read over Data.List x times (where x > 3) and never saw nub... thanks mauke!
21:39:01 <Oejet> mcnster: My mnemonic is: NodUBlicates.
21:39:35 <mcnster> oejet, that smakes of insanity :-D
21:39:39 <Oejet> Err, No dUBlicates.
21:39:42 <dons> moring Lemmih
21:40:13 <Oejet> mcnster: Maybe so, maybe so.
21:40:21 <mcnster> oejet, do u say dublicates like Alfred Hitchcock?
21:40:33 <Pseudonym> @wn nub
21:40:38 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
21:40:38 <lambdabot> nub
21:40:38 <lambdabot>   n 1: a small lump or protuberance [syn: {nubble}]
21:40:38 <lambdabot>   2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {
21:40:38 <lambdabot> stub}]
21:40:40 <lambdabot>   3: the choicest or most essential or most vital part of some
21:40:42 <lambdabot>    idea or experience; "the gist of the prosecutor's
21:40:44 <lambdabot> [5 @more lines]
21:40:45 <Pseudonym> Note definition 3.
21:40:46 <sethk> Cale, is there a way I can use putStrLn within the parsers?  It complains about my using the IO monad instead of the parser monad.  Which it is correct about.  For debugging and tracing purposes, I'd like to be able to print messages.
21:40:59 <mcnster> anyhoo, thanks all.  gotta book.
21:41:28 <mauke> @hoogle IO a -> a
21:41:30 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
21:41:30 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
21:41:30 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
21:41:35 <mauke> bah
21:41:49 <Lemmih> @type Debug.Trace.trace
21:41:51 <lambdabot> forall a. String -> a -> a
21:43:37 <sethk> Lemmih, same thing
21:44:26 <sethk> Lemmih, debug.trace is type IO
21:44:44 <dons> nope
21:45:03 <sethk> sorry, putTraceMsg is.  But it still barfs on trace
21:45:26 <dons> you're probably misusing it. trace "foo" $ my code
21:46:03 <sethk> dons, within a do { ; ; ; }  ?
21:46:12 <dons> tracce "foo" $ do ...
21:46:22 <sethk> dons, that's not what I want or need
21:46:32 <sethk> dons, I can do that, sure
21:46:58 <Cale> sethk: trace causes a message to be output when something gets evaluated
21:46:59 <sethk> hmm, it might work with $ within the do
21:47:03 <Cale> yeah
21:51:15 <palomer> yay for haskell!
21:51:17 <palomer> we won!
21:51:40 <palomer> btw, is there a lambda term that return true if its argument is the identity and does something else if it isn't?
21:54:10 <dons> the identify function?
21:54:50 <dons> you want something :: (a -> a) -> Bool ?? no. surely not.
21:57:37 <JohnMeacham> what was won?
21:57:54 <palomer> dons: why not?
21:58:39 <palomer> dons: what about \x (\z\y x z) ?
21:59:14 <dons> well, how will you work out if it is the identity function, and not bottom?
21:59:36 <dons> John, a board game of the puzzzle, and some $ I think
21:59:39 <palomer> dons: eh?
21:59:45 <dons> yay: compiler hackers win again!!
22:00:18 <Cale> palomer: at the very least you'd need to encode the combinator somehow before passing it
22:00:20 <dons> oh, sorry. /me didn't realise you were talking lambdas
22:01:12 <dons> still, i'm not suure this is a useful function
22:01:57 <Korollary> how do you compare values in lambda calculus ?
22:02:16 <Korollary> in pure LC, I mean
22:02:17 <dons> with lambdas ;)
22:02:46 <Korollary> dons: isn't it 6am where you are now ?
22:02:51 <Korollary> @timein helsinki
22:02:55 <lambdabot>  Wednesday, September 28, 2005 at 8:02:31 AM EEST
22:02:58 <Korollary> oh ok
22:03:01 <dcoutts> morning folks
22:03:07 <Lemmih> Hi dcoutts.
22:03:20 * dcoutts couldn't sleep so is up unreasonably early
22:03:48 <dcoutts> Lemmih, so you're loading ghc-6.4.1 .hi files using the ghc-api ?
22:03:58 <Lemmih> dcoutts: Yep.
22:04:02 * dcoutts didn't think that was possible
22:04:10 <dons> which makes me think that backwards compaible .hi files aren't that weird
22:04:21 <dons> they only change slightly each release
22:04:27 <mauke> what does \x (\z\y x z) mean? \x z y -> x z?
22:04:29 <dcoutts> hmm, interesting
22:04:45 <dcoutts> Lemmih, did you have to hack anything to make it work?
22:04:57 <dcoutts> ie to get the right binary format?
22:05:08 <palomer> Cale: no way, doesn't my solution work?
22:05:17 <palomer> Cale: this is a continuation of yesterday's question
22:05:37 <palomer> Cale: if I can tell if a term is a list of church numerals, then I can show my problem is at least as hard as something really hard:O
22:06:00 <palomer> or rather, it returns true if it's a list of church numerals
22:06:01 <Lemmih> dcoutts: Yeah, but not much. The Binary instance for [a] changed and some fields were added to ModIface.
22:06:12 <palomer> true iff list of church numerals
22:06:20 <dcoutts> Lemmih, well, good job on doing the impossible ;-)
22:06:39 <Lemmih> dcoutts: I hope the new fields in ModIface aren't very important (:
22:06:47 <dcoutts> :-)
22:07:04 <dcoutts> So that means we can do parsing, renaming & typechecking?
22:07:18 <dcoutts> or should make it possible to do that at least
22:07:29 <dcoutts> with ghc-6.4.1
22:07:42 <Lemmih> yeah.
22:07:45 <dcoutts> cool
22:08:32 <Lemmih> Anyone wanna test ghc-api: http://scannedinavian.org/~lemmih/ghc-api/ ?
22:08:40 <dcoutts> I presume the ghc api exposes the '--make' import chasing feature?
22:08:46 <mauke> palomer: can you restate \x (\z\y x z) in haskell syntax?
22:08:48 <Cale> palomer: how do you tell apart things which don't have normal forms?
22:09:04 <Cale> mauke: \x -> (\z y -> x z)
22:09:16 <palomer> mauke: \xzy -> x z
22:09:30 <mauke> ok, how is that different from const?
22:09:31 <palomer> err, \x z y -> x z
22:09:42 <palomer> Cale: if it doesn't have a normal form, it's not the identity
22:09:53 <palomer> and I don't care if it loops forever if its not the identity
22:09:54 <mauke> oops, y z, not z y
22:10:21 <Lemmih> dcoutts: It's in there somewhere but I don't think it has a nice interface.
22:10:39 <palomer> all I need is t x = true iff x is the identity
22:11:03 <dons> Lemmih, talking to JaffaCake, it shouldn't be too hard to get a :: Env -> String -> a function from the ghci-api
22:11:40 <dons> i.e. we could construct a :: Buffer -> Buffer function on the fly, a la :perldo
22:12:00 <Lemmih> I don't follow.
22:12:13 <dons> we'd like to embed ghci in hIDE
22:12:32 <Lemmih> How will you fix the RTS issues?
22:12:48 <dons> well, just considering the static case for now
22:12:57 <dons> if nec, we could statically link ghci in
22:13:55 <palomer> actually, what I really want is t x = true iff x is a list of integers
22:14:00 <mauke> palomer: t x == true where t = \x z y -> x z and x = const true?
22:14:07 <dons> so, what I'd like is a little widget that let me type:  \b -> map toUpper (lines b) perhaps. which ghci then hands me back as  a normall haskell function, which hIDE then applies to the current buffer
22:14:24 <dons> a Typeable would make that nicer
22:14:41 <palomer> mauke: I consider true \z y -> z
22:15:12 <mauke> yeah, but const true != true
22:15:19 <dcoutts> Lemmih, the GHC module has 'depanal' which seems to be the thing
22:15:54 <dcoutts> we want the import chasing feature for hIDE project management
22:16:17 <Cale> palomer: okay, yeah, that appears to work :)
22:16:20 <dons> good idea dcoutts
22:16:29 <dons> so you just add the toplevel
22:16:35 <dcoutts> and for building module graphs (which might be a nice alternate browser view, rather than just a files view)
22:16:36 <dons> -- though hs-plugins also provides this already
22:16:53 <Cale> palomer: though you have to put up with the fact that you have junk if it's not the identity
22:16:54 <dons> so you just add the top level module, and we work out the rest of the projjectT?
22:17:03 <dcoutts> dons, yes
22:17:31 <dcoutts> and even the top level can we worked out automatically since it's specified in the .cabal file
22:17:37 <dcoutts> (I think)
22:17:48 <dons> this is just chasing deps. hs-plugins provides getImports :: String -> IO [String]
22:18:07 <dons> which returns the deps of the .hi file of the module in String
22:18:22 <dcoutts> right, so it has to compile the files first
22:18:24 <palomer> Cale: yeah, I don't min
22:18:26 <dons> @type System.Plugins.Load.getImports
22:18:42 <lambdabot> String -> IO [String]
22:18:49 <dons> dcoutts, yeah. but I guess ghc can do that without producing .hi filles (?)
22:18:51 <palomer> Cale: now does such a function exist to identify lists of integers?
22:18:52 <dcoutts> dons, the ghc --make/-M feature does not need to fully parse the files for it to work
22:18:56 <dcoutts> dons, exactly
22:19:06 <dons> which files? the src files?
22:19:16 <Cale> palomer: what's your list representation?
22:19:18 <dcoutts> yes, it on'y parses the module headers
22:19:19 <palomer> mauke: yeah, forget constant true:o
22:19:23 <dons> ah cool.
22:19:25 <palomer> Cale: the standard list representation
22:19:29 <dons> ghc -M, yeah good idea
22:19:32 <palomer> in lambda calculus:
22:19:41 <dons> in a pinch, we could regex the output of ghc -M anyway
22:20:01 <dcoutts> true
22:20:12 <dons> this sounds nice. you going to work on that?
22:20:17 <dcoutts> but if we're using the ghc api anyway
22:20:18 <palomer> things like \c\n c(a_1,\c\n c(a_2, n))
22:20:22 <dons> right
22:20:23 <dcoutts> oh, not yet
22:20:34 <dcoutts> I'm still working on the UI
22:20:41 <dons> maybe we should keep a little work plan on the wiki, so we know what each other is plannign to work on
22:20:45 * dcoutts looks around for volunteers
22:20:49 <dons> and to check we're not leaving gaps
22:20:56 <dcoutts> yes, good idea
22:21:00 * dons fires up w3m
22:21:01 <palomer> Cale: note that datatypes in lambda calculus are represented as \constructor1 -> constructor2 -> .... -> constructor representation
22:21:16 <dons> @where hIDE
22:21:17 <palomer> (they should really teach this)
22:21:17 <lambdabot> http://www.haskell.org/hawiki/hIDE
22:22:16 <dcoutts> http://www.haskell.org/hawiki/hIDE_2fDesign
22:22:22 <Cale> palomer: I'm in mathematics, not in CS :)
22:22:24 <dcoutts> would probably be a better page
22:22:27 <dons> dcoutts, embedded ghci is also a novel, if we get that going
22:22:34 <dons> ok
22:22:41 <palomer> Cale: they _only_ teach this stuff in the math department at my university
22:22:54 <palomer> actually I lie
22:23:06 <palomer> but that's only because my supervisor likes to torture students
22:23:21 <Cale> palomer: there's no pure mathematics course teaching lambda calculus here, only CS courses have things like that.
22:23:29 <dcoutts> dons, yes it'd be the first non-ghc implementation, and the first in an app
22:23:48 <palomer> Cale: when I was in france, I had 2 courses involving lambda calculus
22:23:51 <palomer> both in the math department
22:23:53 <dons> very lispish too
22:24:38 <dcoutts> dons, the question is, would the embeded ghci session be a seperate session with it's own module namespace or would all the loaded hIDE modules be accessable?
22:24:50 <Cale> CS is part of the math department here
22:25:00 <dcoutts> dons, ie is it just an embeded ghci, or is it an app console/scripting interface
22:25:00 <Cale> er, math faculty rather
22:25:19 <Cale> CS used to be a department, it's grown into a "school" now, whatever that means :)
22:25:26 <dcoutts> dons, both would be useful actually
22:25:52 <palomer> grade school:O
22:25:54 <dons> right, dcoutts. embedded is useful, like perldo, scripting the internals, another level of sophistication, and ultimately more useful
22:26:06 <palomer> Cale: waterloo?
22:26:19 <dons> so if possible, we want ghci to see the functions in hIDE it can call back to
22:26:34 <dons> but easier is to just have an empty context
22:26:38 <dons> a la @eval
22:26:54 <Cale> palomer: yeah
22:27:14 <dcoutts> dons, JaffaCake says that once we have ghci inside hIDE we're going to have to worry about the ghc-api and hs-plugins having different notions about what is currently loaded
22:27:22 <palomer> I almost went to waterloo
22:27:25 <Lemmih> Embedding GHCi would deprecate hs-plugins, right?
22:27:39 <palomer> I'll probably visit you guys one of these days
22:27:42 <dons> hmm.
22:27:49 <palomer> Cale: anyone big in lambda calculus over there?
22:28:04 <dcoutts> dons, and that at least hs-plugins should share some infrastructure with the ghc-api if not be based on it entirely
22:28:30 <dons> Lemmih, possibly we'd need to write an hs-plugins interface to ghc-api
22:28:37 <Cale> palomer: I'm not sure -- there are some people into formal languages, Shallit for one
22:28:47 <dons> as the ghci code isn't quite as nice as the Load interface
22:29:08 <dons> but yeah, maybe we could structure the booter on calls to ghc-api, instead of hs-plugins
22:29:19 <dons> and still keep our nice  dynamic architecture.
22:29:28 <dons> also, it would be possible to load plugins as src files
22:29:43 <dons> (rather than make >>= load)
22:30:14 <dons> dcoutts, yeah, ultimately we might want an hs-plugins-2 based on ghc-api
22:30:38 <dons> i wanted to do that initially, but -package ghc wasn't mature enough.
22:30:46 <dcoutts> yeah
22:31:35 <dcoutts> well you've got the time to persuade JaffaCake to export a suitable interface for hs-plugins to use
22:31:53 <dcoutts> the api is not fixed 'til 6.6 is out
22:32:04 <dons> yep, i spoke to him about it yesterday
22:32:21 <dons> we just need to start using it, and making suggestions :)
22:32:27 <dcoutts> yep
22:32:56 <dcoutts> this issue of visability & linker sessions is non-trivial I fear
22:34:01 <dons> we'll see. i mean already you can successfully load hs-plugins in ghci itself, and have things run ok.
22:34:12 <dons> hs-plugins won't load anything that ghci already has loaded
22:34:18 <dcoutts> ok
22:34:47 <dcoutts> JaffaCake's example was what happens if you load hIDE within hIDE :-)
22:34:58 <Lemmih> heh.
22:35:01 <dons> yeah. i scratch my head.
22:35:05 <dcoutts> eg if you're developing hIDE using hIDE
22:35:15 <dcoutts> is it a seperate app, or the same app
22:35:19 <dons> noones loads ghci in ghci...
22:35:39 <dcoutts> it should be different since they will probably be different versions
22:35:56 <dcoutts> and that goes for all the packages that hIDE itself depends upon
22:36:11 <dons> yeah. hmm. symbols should get versioned!
22:36:22 <dons> M-1-0.foo ;)
22:36:30 <dons> linker scripts to the rescue!
22:37:03 <dcoutts> well that's one possability, or to have seperate linker sessions so you can load the same thing in different sessions without them being shared
22:38:13 <dcoutts> otherwise to keep the sessions seperate you'd need to fork or something
22:39:45 <dcoutts> so I see the utility for both haiving a shared session for scripting hIDE itself, (think hIDE console) and also a non-shared session for the app that is being developed using hIDE
22:40:19 <dcoutts> dons, are you still editing that page?
22:40:30 <dons> yep. just a sec.
22:40:34 <dcoutts> ok
22:41:27 <dons> ok, feel free to add youur entries
22:41:33 <dcoutts> a non-shared ghci session should allow you to load hIDE since it should just load another copy rather than sharing with the host hIDE
22:42:06 <dcoutts> so you need the concept of a linker session, this was something JaffaCake mentioned
22:42:23 <dons> yep. a list of context taht you can switch between
22:43:08 <dcoutts> not sure if you need to switch between them, but it becomes a parameter of the module load actions
22:44:07 <dcoutts> though for the sake of api sanity you probably keep the existing functions that use the default session
22:44:46 <dcoutts> and add extra linker-session aware functions for the odd uses where it actually matters
22:45:55 <dons> ok. gotta run!
22:47:58 <dcoutts> see you later
22:50:40 <dcoutts> Lemmih, do you want to add the things you're working on (or planning to work on) to the hIDE/Design wiki page: http://www.haskell.org/hawiki/hIDE_2fDesign
22:52:42 <gour> hi dcoutts
22:52:55 <C-Keen> moin!
22:53:46 <gour> dcoutts: seeing "Division of labour" section it looks like soon hiDE will be ready for a ticket system ;)
22:54:49 <gour> dcoutts: i have lot of things to do for my week-end seminar, so just a little time to chime in and see what's going on with hiDE
23:02:54 <dcoutts> morning gour
23:09:30 <sethk> I'm trying to make the simplest possible example of a monad.  I have Control.Monad.State.  There is a    newtype State s a    then it lists two constructors:  State   and  runState.  State, as a constructor, does not have a type signature; the signature is from newtype?  How do I instantiate one of these?
23:10:04 <sethk> I see how to do things with it, but not where it comes from in the first place.
23:10:29 <sethk> there is a runState constructor; does it generate the monad?
23:10:55 <dcoutts> it has only one constructor State
23:11:11 <dcoutts> which is a record with one field runState
23:11:36 <sethk> oh, it's one constructor on two lines.  thanks.
23:11:44 <sethk> now, how do I use it?
23:11:47 <dcoutts> not quite
23:11:59 <dcoutts> it's just a simple record
23:12:09 <sethk> in the docs I have:
23:12:11 <dcoutts> so you can just use (State foo)
23:12:28 <dcoutts> where foo is a function of the appropriate type
23:12:29 <sethk> then foo has type runState?
23:12:34 <dcoutts> yes
23:12:59 <sethk> so I have to make a function of type runState
23:13:03 <dcoutts> well sort-of
23:13:17 <dcoutts> runState has as a first parameter 'State'
23:13:29 <dcoutts> but your 'foo' does not
23:13:43 <vikasg> sethk, you write a function which takes a value of type 's' as an extra parameter
23:13:49 <dcoutts> what does the whole data decl look like?
23:14:06 <sethk> you mean the constructor?
23:14:10 <dcoutts> yep
23:14:26 * juhp wonders what to package for fedora extras next... :)
23:14:36 <sethk> ok.  there is no data, but I'll postpone that question
23:14:45 <sethk> State    on the first line
23:14:56 <sethk>     runState :: (s -> (a, s))        on the second line
23:15:30 <dcoutts> so: newtype State a = State { runState :: (s -> (a, s)) }
23:15:50 <sethk> well, no.  newtype says:    newtype State s a
23:16:01 <dcoutts> ok
23:16:09 <dcoutts> newtype State s a = State { runState :: (s -> (a, s)) }
23:16:49 <dcoutts> an instance might be: State (\n -> (chr n, n+1))
23:17:13 <dcoutts> that'd have type :: State Int Char
23:17:41 <sethk> why did you write   (Char, Int) then?
23:18:08 <dcoutts> because that's the order that runState returns them in
23:18:12 <dcoutts> runState :: (s -> (a, s))
23:18:49 <dcoutts> the 'state' parameter is Int in my example and the 'value' parameter is Char
23:19:16 <sethk> I write     foo = ('a', 1)
23:19:28 <sethk> then  State foo   ?
23:19:31 <dcoutts> nope
23:19:37 <dcoutts> it has to be a function
23:19:50 <sethk> isn't foo = ('a', 1) a function?
23:19:55 <dcoutts> of the type s -> (a,s)
23:20:00 <dcoutts> no that's just a pair
23:20:08 <sethk> a function can return a pair, can't it?
23:20:13 <dcoutts> indeed it can
23:20:20 <dcoutts> your foo there has type :: (Char, Int)
23:20:31 <sethk> ok so I was doing    foo (whatever)   before main as a function.
23:20:36 <dcoutts> you want a foo of type :: Int -> (Char, Int)
23:20:44 <sethk> ok, so
23:20:56 <sethk> foo n = ('a', 1)
23:21:01 <dcoutts> yes
23:23:14 <sethk> ok, now I get my old friend   "the last statement in a 'do' construct must be an expression
23:25:02 <dcoutts> right, it can't be another bind: x <- something
23:26:54 <sethk> are you saying that, in main, I can't do       main = do { m <- State foo }        ?
23:27:13 <dcoutts> you can't do that
23:27:22 <dcoutts> because there's no result
23:27:41 <sethk> do I use evalState to get the result?
23:28:11 <dcoutts> well within that do statement you need to 'return' something
23:28:30 <dcoutts> eg: do { m <- State foo; return m }
23:28:52 <dcoutts> (which of course is just equivalent to: State foo)
23:29:21 <dcoutts> but you can't have the last bit in a do construct be a "thing <- otherThing"
23:29:26 <sethk> didn't you just say that I can't do    m <- State foo    ?
23:29:43 <dcoutts> you can't have it as the very last bit in a do construct
23:29:56 <dcoutts> because it doesn't specify what the result should be
23:29:58 <sethk> and, putting that in main(), I get can't match   IO a     against   State(t->(Char,b1))
23:30:07 <dcoutts> that's quite right
23:30:16 <dcoutts> main usually has type IO ()
23:30:25 <sethk> right.  so how can I ever use my monad?
23:30:31 <dcoutts> ie the IO monad, which is not the same as your monad type
23:30:53 <sethk> ok, but I have to have main(), so how do I ever get to use my monad?
23:30:59 <dcoutts> you can extract the result of a comutation in your monad using runState
23:31:12 <dcoutts> main = do
23:31:23 <dcoutts>   result <- runState (....)
23:31:26 <dcoutts>   print result
23:32:43 <sethk> ok, please show me the missing part of that, not (....)
23:33:06 <sethk> I thought it would be my foo function
23:33:09 <sethk> but that doesn't work
23:34:50 <sethk> that is, I still get the message about the last statement must be an expression
23:35:12 <sethk> I have curlies around the two statements in the do, is that a problem?
23:36:20 <Muad_Dibber> what is the last statement?
23:36:31 <sethk> putStrLn "hello"
23:37:12 <Muad_Dibber> identing is correct?
23:37:29 <sethk> only one line is indented, the one with putStrLn
23:37:34 <sethk> like this
23:37:54 <sethk> main = do m <- Control.Monad.State.runState foo
23:38:00 <sethk>             putStrLn "hello"
23:38:06 <sethk> the p for putStrLine is under the m
23:38:20 <sethk> the m of m <-
23:38:25 <Muad_Dibber> yeah i get it
23:38:47 <Muad_Dibber> well, i'm not near ghc so i cant test it here
23:38:54 <Muad_Dibber> and i'm not that good that i directly see it
23:38:55 <sethk> my function (foo) type is wrong, but I don't know how
23:39:07 <sethk> I have         foo n = ('a', 1)
23:39:39 <sethk> so it complains:  I coded    t2 -> (Char,b)   when it wants         t -> t1
23:41:48 <Muad_Dibber> did you try giving a type signature to foo manually?
23:41:59 <Muad_Dibber> like foo :: Int -> (Char,Int) ?
23:42:07 <sethk> yes
23:42:40 <sethk> let me check it again, make sure I didn't mistype
23:46:00 <dcoutts> sethk, sorry my mistake
23:46:08 <dcoutts> it's slightly more complicated:
23:46:22 <sethk> good, because I don't think I mistyped.  :)
23:46:24 <dcoutts> newtype State s a = State { runState :: (s -> (a, s)) }
23:46:24 <dcoutts> foo n = ('a', 1)
23:46:24 <dcoutts> main = do
23:46:24 <dcoutts>   let (result, _) = runState (State foo) 0
23:46:24 <dcoutts>   print result
23:46:45 <dcoutts> so first of all it's:
23:46:52 <dcoutts> let ... = runState ...
23:46:54 <dcoutts> rather than
23:47:01 <dcoutts>  .. <- runState ...
23:47:14 <dcoutts> because it's a pure computation, not in the IO monad
23:47:27 <dons> re
23:47:57 <dcoutts> next, runState applied to (State foo) still has type :: Int -> (Char, Int)
23:48:09 <sethk> ok ...
23:48:14 <dcoutts> so we need to give it that extra int (I've given 0)
23:48:28 <dcoutts> and we need to extract the appropriate bits from the result
23:48:31 <sethk> what's the purpose of that value?
23:48:34 <sethk> the zero?
23:48:48 <dcoutts> it's the initial value for the 's' parameter
23:48:53 <dcoutts> the initial state
23:48:58 <C-Keen> re
23:49:36 <dcoutts> so I extracted the 'value' part from the result and ignored the 'state' part
23:49:40 <sethk> runState takes a value and returns  (v1, v2)
23:49:48 <dcoutts> let (result, _) =
23:50:04 <dcoutts> sethk, right
23:50:48 <dcoutts> though it's first parameter is of course the computation of type 'State s a'
23:51:35 <sethk> ok.  I have my function which returns  (Char, Int)        then I have     State(myfunc) initalValue
23:51:44 <dcoutts> yep
23:51:49 <sethk> how is my function used?
23:52:07 <dcoutts> the int output is the final state
23:52:19 <dcoutts> the char output is the 'value' result part
23:52:55 <sethk> I don't see how it is used.  It's a function, when is it called?
23:53:25 <sethk> Is it called by   (State foo) 0      or by    runState (State foo) 0  ?
23:54:05 <dcoutts> try running it in ghci with various definitions of foo
23:54:28 <dcoutts> eg: in ghci (or hugs) just type: runState (State foo) 3
23:54:56 <sethk> how do I print the integer again?
23:55:08 <dcoutts> it should just print automatically
23:55:28 <dcoutts> it'll print the pair (a, s)
23:56:02 <dcoutts> for your current definition of foo of course it'll just print:
23:56:03 <dcoutts> ('a',1)
23:56:07 <sethk> Couldn't match `String' against `Char'
23:56:14 <sethk>       Expected type: String
23:56:20 <sethk>       Inferred type: Char
23:56:22 <dcoutts> what did you type?
23:56:44 * boegel is back
23:56:51 <sethk> exactly what you gave me, unless I made a mistake.  I'll check again
23:57:01 <sethk> wait, sorry
23:57:15 <sethk> my fault
23:57:19 <dcoutts> np
23:57:22 <sethk> I used putStrLn instead of print
23:57:49 <dcoutts> no need to type print at all, in ghci/hugs just say: runState (State foo) 3
23:58:00 <dcoutts> you don't need to use the main function
23:58:12 <sethk> ok, but in a compiled program I do, correct?
23:58:16 <dcoutts> yes
23:58:20 <dcoutts> but at the moment it's just a distraction
23:58:56 <sethk> ok, I was just making sure I understood
