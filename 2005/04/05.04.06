00:00:17 <SyntaxNinja> HaXml: now with more hemplates!
00:21:35 <SyntaxNinja> Lemmih: got it to build. thanks for your help. i'm off to bed.
01:04:10 <Itkovian> meuning
01:13:19 <theorbtwo> G'morning lambdas.  I'm trying to debug an issue I'm having with DynamicLoader, and would thus like to put in a tracing print (I'm already monadic).  However, the thing I'd like to print does not derive a Show instance.
01:13:38 <theorbtwo> Can I derive it myself, without altering DynamicLoader, and if so, how?
01:13:48 <theorbtwo> I'm rather a Haskell-newbie, I'm afraid.
01:15:34 <Itkovian> hmm ... a newbie messing around with monads. I'm impressed.
01:16:36 <theorbtwo> It may be more accurate to say that my code is inside a do block, rather then that /I/ am monadic.
01:16:56 <Itkovian> ah, then I may be up to par with you :-)
01:17:18 * Itkovian has never used DynamicLoader
01:17:30 <theorbtwo> Well, I've never used it successfuly.
01:17:38 <Itkovian> heh
01:17:50 <theorbtwo> But I don't think the question really has much to do with it, I was just giving some context.
01:19:15 <basti_> hi
01:29:08 <metaperl> is there some way to write this using filter but still pattern match on the tuples instead of using fst and snd?
01:29:09 <metaperl> books dBase findPerson
01:29:09 <metaperl>   = [ book | (person,book) <- dBase , person==findPerson ]
01:30:38 <Itkovian> erm
01:31:54 <musasabi> you will probably want to use the do-notation instead of list comprehension so it can be generalized to an another monad.
01:32:37 <metaperl> oh ok, never mind...
01:33:07 <metaperl> I was just asking ahead... Thompson is covering everything thoroughly... I just need to be patient. I'm sure he will get to all that in due time
01:35:47 <metaperl> Thompson just brought up a pitfall I would've fallen into: the args to a function are different from the same variable names used in a list comprehension
01:36:30 <metaperl> e.g. myfun a b = [ c | (a,b) <- lis ] -- the a and b in the comprehension do not pattern match using the a and b passed to myfun
01:36:38 <metaperl> glad he brought that up
01:36:54 <Matt-W> well that's sort of sensible I suppose
01:37:06 <Matt-W> I wouldn't have thought of it though, thanks for mentioning it :-)
01:38:08 <metaperl> It's nice to see that a functional language can manipulate relational data as well... as long as it is data, why not?
01:39:34 <Itkovian> all your data are belong to us
01:39:56 <Matt-W> well put :-)
01:40:15 <Matt-W> has anybody written anything about techniques for doing text processing in Haskell
01:40:34 <Itkovian> all I know about it, is that you want to stay far away from it
01:40:50 <Itkovian> people informed me that a char in a [char] takes 16 bytes ...
01:41:25 <Itkovian> all I ever did was some regular expression stuff from the erm what's it called PreludeBlahBlah on the wiki
01:41:48 <metaperl> I believe there is a separate regexp library
01:41:56 <metaperl> that is PCRE compatible and context-sensitive
01:42:30 <metaperl> CosmicRay is building up an article on Haskell for hackers that probably covers that
01:42:59 <Matt-W> I think I might write this thing in Python anyway
01:43:03 <Matt-W> will be an excuse to learn it
01:43:27 <Matt-W> otherwise I'm tempted to over-engineer it hideously and use Parsec :-)
01:44:01 <Matt-W> that's assuming I can wrangle some sort of grammar out of what I need to parse...
01:44:31 * theorbtwo quietly assumes that "Python" was a typo for "Perl".
01:44:47 <metaperl> lol
01:45:03 <Matt-W> no, I already know Perl rather well
01:45:05 <theorbtwo> Matt, I find most things aren't hard to guess at a grammar for -- and proper usage of Regexp::Common for the hard bits can make it much easier.
01:45:10 <Matt-W> I want to learn Python
01:46:04 * Matt-W watches a deathly silence settle over the channel
01:48:30 <metaperl> @type if
01:48:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
01:48:43 <metaperl> can you get the type for if-then-else in Haskell?
01:49:23 <nlv11757_> anyone know a nice stopwatch app for linux?
01:51:16 <musasabi> @type (\a b c -> if a then b else c)
01:51:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (\a b c -> if a then b else c) :: forall t. Bool -> t -> t -> t
01:52:29 <Matt-W> nlv11757_: as in?
01:53:02 <nlv11757_> just being able to record the time of some event
01:53:23 <musasabi> time(1), date(1), ...
01:53:33 <Matt-W> well it's easy enough to time a command
01:53:43 <Matt-W> don't know about timing things that aren't inside the computer though
01:54:00 <theorbtwo> type date, then up, and press "enter" when done.
01:55:27 <nlv11757_> i'll right a nice stopwatch in haskell then :P
01:55:31 <nlv11757_> write
01:55:32 <nlv11757_> :S
01:55:35 <nlv11757_> coffee
01:56:08 <musasabi> nlv11757_: a simple stopwatch: (data && read && date)
01:58:21 <nlv11757_> ah, that is pretty nice actually musasabi :)
01:58:42 <Itkovian> nlv11757_: you may also use the time stamp coutner of your processor ...
01:58:51 <Itkovian> nlv11757_: on what platform are you working?
01:59:11 <Itkovian> I can heartily recommend perfctr for x86, x86_64 and ppc
01:59:25 <musasabi> s/data/date will make it even work.
01:59:43 <musasabi> (should not type anything before drinking morning coffee)
01:59:56 <nlv11757_> im working on fedora core 3 itkovian
02:00:20 <Itkovian> x86?
02:00:23 <nlv11757_> yep
02:00:42 <Itkovian> well then. fetch perfctr (google for it) , patch the kernel and yr off.
02:01:16 <Itkovian> you can time your programs using a provided tool called perfex, or you might consider using FFI to call the perfctr stuff from wthin your program.
02:01:35 <Itkovian> When I finish this Java mumbo jumbo, I plan on looking at performance of Haskell stuff.
02:01:48 <nlv11757_> ok, ty
02:01:52 <Itkovian> I already found the IPC to be very small
02:02:01 <Itkovian> nlv11757_: I you need help, drop me a line
02:02:12 <Itkovian> nlv11757_: it's all well documented
02:02:18 <Itkovian> esp on x86
02:07:40 <metaperl> isn't this cute... I just did it:
02:07:40 <metaperl> romanDigit d
02:07:40 <metaperl>  | d < 5 = replicate d 'I'
02:07:40 <metaperl>  | otherwise = 'V':romanDigit (d-5)
02:08:39 <vegai> romanDigit 4?
02:08:55 <vegai> cute it is, though :)
02:09:53 <nlv11757_> hehehe
02:10:05 <Itkovian> romanDigit 99 ?
02:10:28 <nlv11757_> L and M should probably also be included
02:10:35 <nlv11757_> and C
02:10:57 <theorbtwo> You can't really do IV that way, but that's OK, the Romans didn't either.
02:11:15 <vegai> oh?
02:11:35 <xerox> @plugs romanDigit 4 where romanDigit d | d < 5 = replicate d 'I' | otherwise = 'V' : romanDigit (d-5)
02:11:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `where'
02:12:28 <xerox> @plugs let romanDigit d | d < 5 = replicate d 'I' | otherwise = 'V' : romanDigit (d-5) in romanDigit 4
02:12:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "IIII"
02:12:37 <gzl> is there any shortcut to writing (foo string = if string == "" then "" else tail string) manually?
02:12:51 <gzl> couldn't find anything really appropriate in the prelude
02:13:43 <theorbtwo> http://en.wikipedia.org/wiki/Roman_Numerals#IIII_or_IV.3F
02:13:44 <xerox> foo "" = ""; foo (x:xs) = xs
02:14:01 <xerox> foo "" = ""; foo (_:xs) = xs --even.
02:14:34 <gzl> that seems equally verbose.
02:15:35 <metaperl> I dont believe I am appending a carriage return to these lines...
02:15:37 <metaperl> onThreeLines a b c = [ s ++ ['\n'] | s <- [a,b,c] ]
02:16:13 <gzl> what's s?
02:16:20 <gzl> oops
02:16:26 <gzl> should have finished reading the line. :)
02:16:42 <xerox> gzl, you also have guards if you want, find the writing you like more :-)
02:17:10 <gzl> xerox: oh, that's not what I meant. I was wondering if there was some slick built-in function that did this so I didn't have to bother defining it at all
02:17:42 <nlv11757_> gzl use (drop 1)
02:17:54 <nlv11757_> @eval drop 1 "bla"
02:17:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- la
02:17:59 <nlv11757_> @eval drop 1 ""
02:18:00 <gzl> ah, nice
02:18:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- []
02:18:01 <gzl> there we go
02:18:08 <xerox> Oh, great.
02:18:25 <gzl> somehow there's always something like that. :)
02:18:30 <nlv11757_> :)
02:18:57 <metaperl> it's boring the read the Prelude. more fun to see it parceled out here
02:19:21 <Itkovian> hehe
02:24:55 <metaperl> Chapter 5 in Thompson is complete...
02:25:09 <metaperl> Attention Deficit Disorder of the Haskell Kind has kicked in
02:25:19 <metaperl> time to find something else to do...
02:25:28 <metaperl> hmm, how about .net
02:25:40 <metaperl> just kidding
02:25:43 <metaperl> laters
02:44:29 <theorbtwo> If anybody wants to take a look, Paser.hs in the Pugs source kills GHC 6.4 under -dcore-lint when compiled with -O.
02:45:37 <tromp> g'morning!
03:02:04 <TFK|Uni> 25 Haskell projects on sourceforge :D
03:04:01 <TFK|Uni> 25 projects in BASIC, too o.o;
03:05:04 <TFK|Uni> Smalltalk, 53 projects...
03:05:55 <autrijus> maybe that's because haskell users finds project hosting easier to find.
03:05:58 <autrijus> i.e. more resourceful.
03:06:40 <TFK|Uni> What do you mean? Are there better hosts for Haskell projects than Sourceforge?
03:06:52 <TFK|Uni> (I'm still wondering about public hosts with darcs)
03:07:30 <ibid> sourgeforge is a has-been :)
03:07:38 <TFK|Uni> Haskell is not even listed on BerliOS... (HTML is, though)
03:07:38 <Itkovian> eh?
03:07:42 <Itkovian> idib: howcome?
03:07:48 <Itkovian> ibid: howcome?
03:07:58 * Itkovian still manages not to find the tab key :-)
03:08:13 <ibid> Itkovian: it used to be cool :)
03:08:46 <xerox> Hiya pirroH
03:08:48 <theorbtwo> It used to be up most of the time, and the anon cvs used to be up to date.
03:08:56 <ibid> nowadays there are others with similar services, and people have also easier time to get their own hosting
03:09:21 <TFK|Uni> With bug-tracking/RFE/patch submissions, mailing lists, nightly builds...?
03:09:25 <autrijus> and svn/darcs is gaining popularity.
03:09:39 <autrijus> TFK|Uni: the CVS thing has really hurt sf.net.
03:09:46 <TFK|Uni> Oh really...
03:10:00 <TFK|Uni> Sourceforge gets points for allowing Open Source projects to get high scores on the Joel test.
03:10:12 <ibid> TFK|Uni: yes
03:10:14 <autrijus> sure, sf.net is wonderful and all :)
03:10:19 <TFK|Uni> I suppose BerliOS/Savannah do the same, but they don't use darcs :-(
03:10:20 <ibid> TFK|Uni: there are savannah and friends
03:10:33 <ibid> TFK|Uni: does sf?
03:10:35 <TFK|Uni> Plus, I can't readily get Savannah's language statistics.
03:10:40 <pirroH> hi xerox
03:10:44 <TFK|Uni> No. But SF is *big* ;-)
03:11:02 <TFK|Uni> Are there other hosts a la sf you can mention by name?
03:11:13 <ibid> alioth and savannah come to mind
03:11:23 <ibid> though alioth is restricted and has problems
03:11:31 <ibid> there is also some french thing
03:11:50 <TFK|Uni> Alioth uses CVS, apparently.
03:11:59 <TFK|Uni> No French here :-(
03:12:00 <ibid> or svn
03:12:26 <ibid> i believe people are going for the self-hosted thing nowadays
03:12:37 <ibid> cheap virtual machines help there :)
03:12:55 <TFK|Uni> With the whole bug-tracking/patch-submission/mailing-list/nightly-build shebang?
03:13:41 <TFK|Uni> That doesn't sound cheap, and if it is, isn't it a headache to set up every time?
03:13:45 <ibid> it's a little more work to diy, but it also is more flexible
03:14:08 <TFK|Uni> True enough.
03:14:17 <ibid> TFK|Uni: with virtual machines, you set up whatever software you like and pay only for the basic stuff
03:14:41 * ibid has mailing list and darcs-repo capability on my virtual machine
03:15:11 <ibid> haven't yet found a bug-tracker that i like (apart from the debian bts, but you really can't use that on single-package projects)
03:15:47 <ibid> patch submission should be integrated in the issue tracker :)
03:16:16 <TFK|Uni> Still, I'm guessing the numbers probably reflect usage percenteges.
03:16:34 <ibid> there is no way to know, really
03:16:41 <ibid> the numbers are therefore unreliable
03:17:26 <TFK|Uni> Why do you think there's no way to know? What makes Haskell programmers want to self-host their projects more than Lisp programmers?
03:17:32 <ibid> (i never liked the sf bug tracker)
03:17:55 <ibid> TFK|Uni: if you think there is a way to know, please tell me
03:18:00 <autrijus> TFK|Uni: I run two haskell projects and I do not use sf.net :)
03:18:12 <xerox> autrijus, what's the other?
03:18:15 <autrijus> but I'm biased because I run rt.openfoundry.org, a sf.net workalike with svn support.
03:18:29 <autrijus> (and GPL'ed too)
03:18:37 <TFK|Uni> I assume that large groups of people would roughly follow the same distribution patters.
03:18:53 <ibid> TFK|Uni: "I assume". what do you base this assumption on?
03:18:53 <autrijus> xerox: svn.openfoundry.org/openafp/
03:19:13 <TFK|Uni> ibid, empirical induction.
03:19:28 <ibid> TFK|Uni: ie. you guess
03:19:55 <TFK|Uni> It's a bell-curve-like thing.
03:20:18 <ibid> how do you figure that?
03:20:30 <TFK|Uni> Empirical induction...
03:20:32 <ibid> how do you know it's not "smart people avoid sf", for example?
03:20:34 <autrijus> I find very little mathematical research project on sf.net :)
03:20:37 <ibid> TFK|Uni: iow, you guess
03:21:01 <TFK|Uni> Yes, well, I was talking about Useful Code (TM) projects ;-)
03:21:27 <TFK|Uni> What's 'iow'?
03:21:30 <autrijus> ah. now that's something :) you think proof aiding systems are not Useful Code, maybe?
03:21:31 <ibid> in other words
03:21:50 <TFK|Uni> autrijus, aiding proof of what?
03:21:57 <autrijus> mathematical proofs
03:22:07 <autrijus> in axiomatic systems
03:22:43 <TFK|Uni> If you wish to call it "guess", then OK. As the Russian saying goes, "call it a pot, just don't put it in the oven" (translated loosely).
03:23:26 <TFK|Uni> autrijus, well then, does Linus Torvalds use those in Linux kernel development? ;-)
03:23:28 <ibid> TFK|Uni: you have not demonstrated any credible analysis of the sampling method, hence it's as good as a guess
03:24:25 <TFK|Uni> Yes, perhaps you are correct. Mostly smart people use Haskell. Smart people know that SF is rubbish. Smart people don't write non-math related applications.
03:25:02 <autrijus> TFK|Uni: I don't know, I'm not involved with lkml :)
03:25:17 <autrijus> (but I do use lots of math tools in perl 6 development.)
03:25:20 * theorbtwo wouldn't agree with that last bit.
03:26:00 <ibid> i'm not saying that you can't be right, you just disputed my "you can't know", and i responded to that :)
03:26:56 <TFK|Uni> autrijus, development of Perl 6? Or development in Perl 6?
03:27:44 <TFK|Uni> Heh, Taiwan's open source initiative :-)
03:28:15 <autrijus> TFK|Uni: development of perl 6. http://pugscode.org/ is my project :)
03:28:36 <TFK|Uni> Cool :-D
03:30:48 * Itkovian waits impatiently
03:31:01 <Itkovian> how long can it takes to ship one powerbook?
03:31:51 <TFK|Uni> It takes more than a month to ship four books, apparently.
03:32:23 <theorbtwo> All depends on how it's being shipped, and where.
03:32:23 <xerox> An #emacs guy has a blog about his pb, maybe he says it: http://www.ee.ryerson.ca/~elf/powerbook/
03:32:50 <TFK|Uni> Yes. But it should ship *here* faster, because, well, it's *here*.
03:33:57 <tuomov> regarding discussion on sf clones above, berlios has been having mailing list downtime on weekends recently
03:34:13 <TFK|Uni> In hindsighty, maybe I should've tried amazon.co.uk :-/
03:34:19 <TFK|Uni> *hindsight
03:34:32 <TFK|Uni> Ah, so there is strength in numbers ;-)
03:39:33 <Itkovian> I ordered on April 1st. Est shipment on or before April 11 :-|
03:39:48 <xerox> Why didn't you wait for tiger?
03:40:12 <TFK|Uni> I ordered on April 3-rd, estimated arrival on 3-rd to 18-th of May :-/
03:40:26 <Si\> hmm, according to the GHC docs I can splice a type, so why doesn't x :: $(conT $ mkName "Int") work?
03:41:26 <Igloo> What GHC docs say you can splice a type in?
03:41:39 <Si\> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
03:41:50 <Si\> "a type; the spliced expression must have type Type."
03:42:16 <Igloo> Hmm
03:44:01 <Igloo> AFAIK that's wrong
03:44:47 <Itkovian> xerox: afaik there's an upgrade ticket included in the box.
03:45:29 <Igloo> And I can't see where it would be accepted in the parser in 6.4
03:45:33 <xerox> Itkovian, good :)
03:46:19 <nlv11757_> kids who play video games kill people :D
03:46:20 <nlv11757_> lol
03:51:29 <Si\> oh well, it's not as if it makes life that much more unbearable ;)
03:53:07 <Cale> Wow, some people on the wiki seem to be very much against syntactic sugar. I'd think turning if-then-else into a function would make a lot of code much more difficult to read, and dropping list notation seems silly.
03:54:03 <Si\> dropping list notation??
03:54:46 <Cale> "The comma separated list notation [0,1,2,3] is very common, but is it sensible?..." -- http://www.haskell.org/hawiki/SyntacticSugar_2fCons
03:55:25 <Cale> and they seem to have something against parallel list comprehensions
03:55:42 <Cale> which I think are a fairly natural extension
03:56:59 <theorbtwo> Hm, it seems that the author of at least the General section has problems with the definition of syntatic sugar.
03:57:11 <theorbtwo> "It's amazing that every syntactic sugar has pure functional explanations. "
03:57:33 <theorbtwo> Well, if there weren't some other way to do it, it wouldn't be syntactic sugar.
03:57:36 <Si\> yes, I find that different situations are better suited to both map/foldr/filter sequences, and some better to parallel list comprehensions
03:57:38 <nlv11757_> this List a instead of [a] doesn't seem like a big advantage to me
03:59:47 <Cale> and dropping guards seems like a really bad idea as well
04:04:53 <Philippa_> there's a really good reason to keep [1,2,3] IMO - it gels well with the tuple syntax
04:05:19 <Philippa_> and that becomes important when you find yourself writing complex structures down
04:07:18 <Cale> I generally find that Haskell code often really looks good syntactically, because while not going overboard, it offers just enough choices for syntax that the author can emphasize what is important.
04:09:00 <Philippa_> likewise. That's the main reason I like the `infix` sugar - it allows the author to break things up into conceptual chunks
04:12:04 <Philippa_> (it's great with seq)
04:12:28 * TheHunter wants `liftM2 (+)`
04:13:01 <Philippa_> yeah, we've had the discussion
04:15:11 <xerox> Oh, now is not possible?
04:16:02 <Philippa_> right
04:16:12 <Philippa_> it's not an expression inside the `quotes`
04:21:31 <Cale> Yeah, I want that too
04:23:36 <Philippa_> It seems to me that if you allow `infix` at all it's a pretty damn minor extension
04:24:00 <Philippa_> it would be nice to have a paper or something on tracking desugared syntax back to the sugared version though
04:24:07 <Philippa_> (for error reporting etc etc)
04:24:27 <Philippa_> I dare say there's a little folklore buried somewhere, and I can no doubt figure it out, but that's not the point
04:26:38 <Philippa_> and if you get a standardised solution, all's easy after that. Hell, you could write the desugarer using Parsec :-)
04:30:12 <mflux> philippa_, and what great fun you'll have after that, with expressions like 2 `let .. .. ..(5 lines of code).. ` 3 ;)
04:31:00 <mflux> although that would seem like a neat addition
04:33:38 * autrijus reads up on snorting ritalin, decides it's exceedingly dangerous, makes a mental note to Not Do It
04:34:32 <Cale> There's always a certain intent that goes with syntax, and it usually seems possible to abuse it horribly. :)
04:35:45 <Philippa_> mflux: people can always write crap code
04:35:52 <mflux> quite true
04:36:02 <Philippa_> there comes a point where you're supposed to dump it out into the where block or something
04:36:54 <Cale> usually after it becomes more than the name of a function, or a function applied to 1 or 2 short parameters (which are simple names or values)
04:48:23 <nlv11757_> my objection against ocaml is the verbosity, Haskell syntax is much easier on the eye.
04:49:07 <Philippa_> that's part of my problem with it too
04:50:01 <musasabi> not so much verbosity as ugliness.
04:50:11 <theorbtwo> Hm, I think Haskell syntax is horrible on the brain-parser, though.
04:50:18 <nlv11757_> hehe i didnt want to insult anyone, but i did find it ugly
04:50:31 <nlv11757_> i dont agree orbtwo
04:50:36 <theorbtwo> You have to know the arity of all the functions.
04:50:51 <theorbtwo> (Yes, I do realize they're all unary at one level.)
04:51:28 <Philippa_> 'sonly occasionally a problem IME, and avoidable by eg hinting with parens if it really crops up
04:51:32 <nlv11757_> you dont like parameterised functions in that sense then?
04:52:08 <theorbtwo> Not sure what a parameterized function is.
04:53:11 <nlv11757_> functions that get a few but not all parameters
04:53:34 <nlv11757_> i should have said partially parameterized
04:53:42 <theorbtwo> Ah.
04:54:00 <theorbtwo> The concept is fine, but should probably be made explicit and more general.
04:54:08 <Philippa_> nlv11757_: usually called "partially applied"
04:54:31 <theorbtwo> Of course, when you make it explicit and more general, you find that it's just a lambda.
04:55:09 <theorbtwo> halve = \n -> n / 2
04:55:36 <tromp> halve = (`div` 2)
04:55:38 <tromp> on ints
04:56:22 <theorbtwo> Yeah, but you can't use that syntax to curry the 2nd parameter of a trinary function.
04:57:15 <nlv11757_> Philippa_: i translated it directly from the dutch term which is
04:57:20 <nlv11757_> partieel geparameteriseerd
04:57:21 <nlv11757_> :D
04:57:34 <nlv11757_> in english partially applied is prob. better
04:57:36 <theorbtwo> That's really only a side-issue, though.
04:57:44 <smott> curried?
04:58:09 <theorbtwo> To curry a function is to take a partially applied form of it.
04:58:27 <theorbtwo> (From Haskell Curry, not at all coincidentally.)
04:58:43 <TheHunter> oh, no addToFM_C and Map.insertWith expect the arguments of their combining functions in different order.
04:58:46 <ibid> but still wrongly, since curry did not invent it :)
05:03:54 <TheHunter> someone needs to put that into the docs with a lot of exlamation marks.
05:04:09 <Philippa_> theorbtwo: that's not "to curry a function"
05:04:21 <theorbtwo> It's not?
05:04:37 * theorbtwo is rather new to this functional stuff, but thought he knew at least that much...
05:04:39 <Philippa_> currying is when your '3 parameter' function has the type a -> b -> c -> d rather than (a,b,c) -> d
05:05:09 <Philippa_> currying /allows/ partial application, but it isn't partial application itself
05:05:17 <theorbtwo> Oh.
05:06:04 <Philippa_> and you can always use the flip function or something of that ilk
05:08:45 <dustin`> Isn't currying just the right adjoint of the product functor?
05:10:18 <Arafangion> How fast can Haskell generate, say, the factorial of a number compared to other languages?
05:10:37 <Arafangion> As I'm guessing this has already been asked and discussed til hell freezes over, so is there a good website on this?
05:10:57 <Igloo> Is calculating factorials quickly important to you?
05:11:03 <smott> http://shootout.alioth.debian.org/
05:11:39 <musasabi> haskell is fast enough for most purposes ;)
05:12:28 <camio> I'm trying to make a parsec Parser that consumes all input until it reaches the end of the string or the sequence "<?cs". Does anyone have any ideas of how to do this?
05:12:47 <Philippa_> manyTill
05:13:17 <Philippa_> as a general rule of thumb, it's worth looking through the combinators available
05:13:21 <Philippa_> they cover a lot of useful patterns
05:14:07 <camio> manyTill doesn't work because using it will consume the "<?cs".
05:15:39 <camio> That's where I can't figure it out. It is almost like I need to do two try's nested within eachother, but when one fails I need to know which one.
05:17:16 <Philippa_> is there a good reason consuming the "<?cs" is bad if you know it's got to be that next?
05:18:36 <Philippa_> (brb, rescuing pasta)
05:18:37 <camio> I don't know if it is a good reason, but the ?cs that is going to be consumed could depend on something else.
05:19:13 <camio> I'd like something like mainParser = many $ csStatement <|> nonCsString
05:19:28 <camio> csStatement = ifStatement <|> ...
05:19:55 <camio> ifStatement = ifPart >>= nonCsString >>= endifPart
05:20:04 <camio> Does that make sense?
05:20:32 <camio> s/>>=/>>
05:20:49 <TheHunter> you want ifPart >> (nonCsString >> endifPart)
05:21:43 <camio> I want whatever is equivelent to do{ ifPart;nonCsString;endifPart }
05:22:17 <Philippa_> between
05:22:19 <skew> camio: that's ifPart >> nonCsString >> endifPart (>> is associative)
05:22:43 <skew> camio: the Report describes the translation from do notation to >>=
05:23:01 <TheHunter> >> is left-associative and do notation producese a right-associative version.
05:23:30 <TheHunter> right-associativity probably has better performance.
05:23:39 <Si\> Is there any way of getting eval to allow overlapping instances?
05:23:40 <camio> Philippa: How would between work?
05:24:40 <musasabi> Where is the current lambdabot repo?
05:24:42 <Philippa_> RTFM. I believe it'll consume all three and return the result of the middle parser
05:24:48 <TheHunter> @version
05:24:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p164, GHC 6.4 (OpenBSD i386)
05:24:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:24:51 * musasabi needs some irc-bot functionality in haskell..
05:24:57 <musasabi> thanks.
05:25:16 <Arafangion> Igloo, Factorials were just an example!
05:25:57 <camio> Philippa: TMHAITMPP (Tell me how to apply it to my problem please)
05:26:02 <Philippa_> RTFM
05:26:06 <Philippa_> it's trivial
05:27:47 <camio> If it is so trivial it should be no nuisance for you to show how it solves my problem.
05:28:01 <Philippa_> and it should be no nuisance for you to RTFM either
05:28:31 <Philippa_> I've named the combinator and told you the pattern it parses, how much more do you actually need?
05:28:52 <skew> a >> (b >> c) == a >>= (\_ -> b >>= (\_ -> c)) == a >>= (\x -> (\_ -> b) x >>= (\_ -> c)) == (a >>= \_ -> b) >>= \_ -> c == (a >> b) >> c
05:29:19 <Philippa_> => skew is bored?
05:29:21 <Igloo> Arafangion: Simple arithmetic on machine sized integers can be as fast in Haskell as C. My point was really that such benchmarks don't generally tell you anything useful
05:29:23 <TheHunter> skew, i know >> is associative.
05:29:28 <camio> I think you don't understand how it doesn't solve the problem. Let me explain how it doesn't and you can correct me if I'm wrong.
05:29:32 <TheHunter> but try foldl (>>) (return ()) $ replicate 10000000 (return ())
05:29:40 <Philippa_> camio: I think you mis-stated the problem then
05:29:42 <Arafangion> Igloo, I was actually wondering what the function overhead was, etc.
05:30:14 <Philippa_> ifStatement = ifPart >>= nonCsString >>= endifPart <- using >> aside, this is the exact pattern described by between, feel free to throw away the result
05:30:28 <Philippa_> therefore, if you don't want between, you don't want what you specified as the solution
05:30:35 <camio> the if combinitor needs to parse some stuff and then a <?/if>. So, I need to be able to parse some stuff which can be either textStuff or another if.
05:30:42 <xerox> GHC's heap exhausted :-(
05:31:04 <camio> textStuff should parse until it sees a "<?cs".
05:31:05 <Philippa_> does the if parse /have/ to parse a <?/if>?
05:31:06 <TheHunter> skew, and it might just be that the effect of that in parsec is exponential (in time and/or space).
05:31:30 <Philippa_> so far you've failed to provide a clear spec of the problem and your attempts to clarify conveniently skip it
05:31:56 <TheHunter> s/exponential/quadratic/
05:32:10 <Philippa_> it /appears/ that what you want is many (try (between openthingy closedthingy many statement) <|> anyChar) where statement covers all the other stuff
05:32:29 <skew> TheHunter: I think the only difference is stack space/cache coherencey/etc, unless the monad instance is weird
05:33:08 <camio> Okay, here is an example in the language -> "Some stuff <?cs if:#1> More Stuff <?cs if:#1><?cs define:?> more stuff<?cs /if?>stuff<?cs /if?>Stuff"
05:33:33 <skew> Anyway, that's all a bit deep for just thinking about how to translate a do
05:33:56 <Philippa_> skew: especially one that's a) covered by an existing combinator and b) doesn't do what he wants
05:35:38 <Philippa_> camio: this starts to make more sense. I assume the tags're required to go in stack order?
05:35:52 <camio> Philippa: yep
05:36:34 <Philippa_> so your top-level is alternating raw text and expressions-that-contain-text, and the expressions-that-contain-text consist mostly of a start tag, a bunch of text and an end tag?
05:36:58 <Itkovian> is there any chance anything alike subEthaEdit might appear in yi?
05:37:00 <camio> Well, they can also contain inbetween tags, like else.
05:37:07 <Philippa_> (where 'bunch of text' is the same as the top-level thingy)
05:37:28 <Philippa_> okay, that gets mildly harder but only mildly - any given tag knows which in-betweeners it expects
05:37:54 <jlouis> Igloo: furthermore. Such tests tend to make people hammer enough on their code, so it ends up being a reimplementation of the C-variant
05:38:05 <camio> right
05:39:31 <camio> Philippa: Do you see how if I had a stuff-in-between parser that didn't consume "<?cs..." would make the rest really easy?
05:40:04 <Philippa_> yes and no. It's not as big a deal as it appears to be
05:43:07 <Philippa_> for example, you could have all statement's subparsers eat the <?cs... stuff themselves
05:43:58 <musasabi> Any pointers how one would create a lambdabot-module that would log all messages to a channel?
05:44:46 <shapr> look at BaseModule, lambdabot is essentially a typeclass with a method for each IRC message type
05:44:50 <TheHunter> musasabi, grep the source for ircSignalConnect
05:45:18 <musasabi> thanks.
05:46:09 <camio> Philippa: I see what you are saying abstractly. But how would I get around the other-stuff parser eating the <?/if> for example.
05:58:26 * boegel yawns and waves at the same time
06:01:49 <Itkovian> well hi and hello there boegel.
06:01:52 <Itkovian> :-)
06:02:03 * shapr boings
06:02:52 <shapr> wow, lotsa people on #haskell today
06:03:23 <Itkovian> one less
06:03:26 <shapr> heh
06:03:51 <Igloo> Now we have a maximum snooker break's worth
06:08:54 <musasabi> parsec + IO seems to be a no-go.
06:11:07 <camio> Philippa: I got it working. Thanks for your help.
06:12:09 <Heffalump> igloo: there's some way of getting more than 147 that happened recently
06:12:17 <Heffalump> something to do with a foul giving you a free ball
06:13:14 <Igloo> Yeah, but 147 is still commonly refered to as a maximum break
06:14:59 <Heffalump> true.
06:20:58 <duncan_> Igloo: still no gtk2hs 0.9.7 :-( I guess you're all busy with ghc 6.4 packaging, we certainly are in Gentoo land
06:22:06 <TFK> Hello, Haskelleers
06:22:37 <Darius> Itkovian: (re yi) You could always implement it yourself...
06:22:42 * Igloo hasn't heard from Marvin recently. I'll try harder to get what he has now, even if it's not perfect, when I get a minute
06:22:59 <duncan_> Igloo: ta :-)
06:23:10 <boegel> hi and hello there back at you Itkovian
06:23:30 <Itkovian> Darius: I might, were I a good haskell hacker.
06:25:24 <TFK> Woo, shapr popularizes Pugs on LtU ;-)
06:25:48 * Itkovian surfs over there
06:28:59 <autrijus> musasabi: why no-go?
06:29:05 <autrijus> <- planning to do parsec+io soon
06:31:57 <shapr> TFK: I may not be great coder, but I swing a mean pom-pom.
06:32:22 <shapr> hoi arjanoosting
06:32:38 <TFK> Always knew you had something of a cross-dresser in you...
06:32:46 * shapr sniggers
06:36:21 <jlouis> TheHunter: Nice cleanup by going for a Multi-parameter typeclass in lambdabot
06:36:38 <jlouis> I am giving the SeenModule an overhaul today
06:37:05 <shapr> yay!
06:37:56 <TheHunter> yes, that thing still has an enormous amount of duplication
06:38:36 <TheHunter> i won't touch SeenModule today, then.
06:38:44 <boegel> shapr: how's TMR2 going ?
06:39:02 <jlouis> TheHunter: exactly. The duplication is going away quickly though ;)
06:39:17 <shapr> boegel: haven't started yet, first step is the author's wiki
06:39:40 <boegel> there's no TMR2 on the way yet ? that's a shame
06:40:00 * shapr goes into TMR2 recruiting mode
06:40:17 <shapr> ok, who can I pick on for a TMR2 article?
06:40:27 <TheHunter> shapr, i've got a half-finished one.
06:40:39 <shapr> yay! That's one
06:40:50 <shapr> Ok, who else?
06:40:53 <dustin`> TMR2?
06:41:07 <shapr> @wiki TheMonadReader
06:41:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/TheMonadReader
06:41:10 <dustin`> I can write excellent polemics.  Do you need polemics?
06:41:36 <shapr> Is polemics tactful for flames?
06:42:03 <dustin`> Yes, only you call your opponent 'petit-bourgoies' as much as possible.
06:42:16 <shapr> Seriously though, if you want to write for TMR, send me an outline
06:42:41 <shapr> bringert: want to write for TMR2?
06:42:47 <Lunar^> shapr: I enjoyed your last post on LTU
06:43:06 <shapr> Lunar^: glad you liked it :-)
06:43:23 <dustin`> I'm still a bit n00bish in Haskell, but perhaps someday
06:43:54 <shapr> dustin`: You can still write an article. In fact, it's best if you write an article about something you're just learning.
06:44:05 <boegel> dustin`: like me !
06:44:16 <CosmicRay> shapr: there's an item in the submissions queue on the sequence that needs a vote, if you wouldn't mind
06:44:19 <boegel> I'm still noobish, and I already wrote an article
06:44:27 <jlouis> oh, I am a Haskell Newbie too ;)
06:44:28 <CosmicRay> dustin`: oh, you're writing an article about something?
06:44:38 <CosmicRay> I get the feeling that all of us are Haskell newbies sometimes.
06:44:41 <jlouis> but FP is not particulary new to me
06:44:47 <CosmicRay> except maybe igloo and Simon*
06:44:51 <shapr> Many readers are not familiar with subject before they read the article, so the author is closer to the audience in that case.
06:45:11 <JaffaCake> I just know how to write C in Haskell :)
06:45:39 <CosmicRay> heh
06:45:46 <shapr> JaffaCake: want to write an article for TMR2?
06:46:00 * JaffaCake tries to think of a good topic
06:46:19 <JaffaCake> how about "how to write C in Haskell" ? :)
06:46:25 * shapr snickers
06:46:36 <ibid> could be interesting
06:46:50 <shapr> There's really not much info on optimizing Haskell.
06:47:01 <JaffaCake> one article I'd like to write sometime is "how to optimise Haskell code with GHC"
06:47:04 <CosmicRay> shapr: that would make an excellent topic.
06:47:11 <JaffaCake> shapr: hehe
06:47:22 <xerox> "Arrows by examples" ^__^
06:47:46 <CosmicRay> I've also never quite understood the exact mechanics of memory utilization and performance of recursive functions in a lazy language like haskell
06:47:57 <CosmicRay> it seems quite different than in most other fp languages
06:48:06 <shapr> xerox: That would be fun to write.
06:48:21 <CosmicRay> and it seems like some of the rules of thumb ("tail recursion is good", for instance) don't apply
06:48:26 <xerox> shapr, go for it! (as you say ;))
06:48:27 <dustin`> I will write something nifty once I've finished "An Introduction to Higher-Order Categorical Logic".  There seems to be a lot of "viewing concepts from category theory through Haskell", but not much "viewing Haskell through category theory"
06:48:50 <JaffaCake> CosmicRay: tail recursion is still good, but you have to watch out for laziness too
06:49:34 <shapr> xerox: I think I'd call that article "Quiver of Artemis" or something.
06:50:25 * xerox takes the vocabulary
06:50:27 <CosmicRay> yeah, that's the bit I don't quite get yet.  If I am generating a list and wish to consume it lazily, do I write my function differently?  that sort of thing.  also I haven't yet quite understood the whole deal with leaving unevaluated values on the heap (there's a word for that, I forget...)
06:50:50 <nlv11757_> closures?
06:50:52 <jlouis> CosmicRay: thunks?
06:50:57 <CosmicRay> that sounds right
06:51:00 <CosmicRay> (thunks)
06:51:19 <CosmicRay> unless haskell is using "closures" to refer to somthing new, I don't think that's what I mean
06:51:44 <nlv11757_> closures == thunks
06:51:48 <CosmicRay> oh.
06:51:49 <JaffaCake> you probably understand "closure" to mean "function closure"
06:51:53 <CosmicRay> yes
06:52:02 <JaffaCake> in Haskell a closure doesn't necessarily have to be a function
06:52:15 <JaffaCake> it can be any expression
06:52:47 <Darius> CosmicRay: I wrote StackOverflow that indirectly and partially addresses that issue using the folds as a representative.
06:53:02 <nlv11757_> lots of terms for unevaluated things
06:53:30 <CosmicRay> interesting, so I take it this expanded closure is required for laziness to work?
06:53:53 <Itkovian> he! my powerbook has been shipped!
06:53:56 <Itkovian> whooiee!
06:53:58 <Itkovian> rejoice
06:54:00 <Darius> Though in general, hand-evaluating some iterations of a loop should give some ideas about the behavior of the function.
06:54:21 <nlv11757_> you dont evaluate it, just allocate a thunk and evaluate it if needed
06:54:53 <CosmicRay> so let's say I'm writing a recursive function like this:
06:54:56 <nlv11757_> you refer to the memory location of the thunk, so when it is evaluated once, every pointer to that location will suddenly not point to the thunk anymore but the evaluated value
06:54:59 <CosmicRay> myFoo [] = []
06:55:02 <nlv11757_> so no re-evaluation is needed
06:55:11 <CosmicRay> myFoo (x:xs) = (x + 5) : myFoo xs
06:55:47 <JaffaCake> i.e. map (+5)
06:55:59 <CosmicRay> right, but I don't know how map works internally, so I wrote it out
06:56:08 <JaffaCake> it works just like that ;)
06:56:22 <CosmicRay> so when I call this function, and consume, say, 2 elements, it only evaluates the first 2 elements, right?  (basic laziness)
06:56:24 <nlv11757_> @plugs definition map
06:56:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `definition'
06:56:33 <JaffaCake> yes
06:56:38 <CosmicRay> and those 2 elements disappear from memory entirely after I'm done with them, I assume
06:56:50 <Darius> CosmicRay: If they are unreferenced, yes.
06:57:00 <JaffaCake> they'll be garbage collected, as long as nothing else references them
06:57:56 <CosmicRay> right.
06:58:03 <CosmicRay> so now, what if I write it this way:
06:58:08 <CosmicRay> myFoo accum [] = accum
06:58:09 <CosmicRay> myFoo accum (x:xs) = myFoo ((x + 5) : accum) xs
06:58:25 <CosmicRay> will this force the entire list to be generated before any output is given?
06:58:54 <CosmicRay> (I do realize this presents the output in a different order)
06:59:23 <JaffaCake> well, the entire input is consumed before the result is available
06:59:45 <JaffaCake> and the output will be a list of unevaluated closures
07:00:11 <CosmicRay> which will probably make my program not very memory-friendly, right?
07:00:27 <CosmicRay> or at least less memory-friendly than the first version
07:00:32 <CosmicRay> probably slower too?
07:00:36 <JaffaCake> depends on the demand
07:00:45 <JaffaCake> it might be faster, if you definitely want the entire list
07:01:00 <CosmicRay> hmm, interesting, how could it be faster?
07:01:05 <JaffaCake> because the tails aren't thunks
07:01:21 <JaffaCake> with map, each tail is a thunk, which adds a little overhead
07:02:01 <JaffaCake> time it and see!
07:02:02 <CosmicRay> it's less overhead to have a list of thunks than to have to evaluate a thunk to get the next element in a list?
07:02:17 <CosmicRay> I believe you, I'm just trying to understand why
07:02:33 <JaffaCake> in both cases, the elements will be thunks
07:02:42 <Darius> CosmicRay: map will produce a list of thunks as well as thunks for tails.
07:02:51 <JaffaCake> in the map case only, each tail is a thunk
07:03:03 <CosmicRay> Darius: ahh.
07:03:11 <CosmicRay> Darius: twice the thunkage then, eh?
07:03:29 <JaffaCake> on the other hand, map deforests nicely....
07:03:29 <CosmicRay> so you have a thunk that returns another thunk as the next element of the list?
07:03:32 <jlouis> But map (+5) will return quite a lot faster than myFoo, right?
07:03:56 <CosmicRay> jlouis: than the second version (the one with the accumulator), I'd assume
07:04:05 <jlouis> CosmicRay: yes
07:04:05 <Igloo> It'll return the /first/ element faster
07:04:17 <CosmicRay> this is very interesting.
07:04:19 <jlouis> Igloo: yes
07:04:27 <shapr> hey basti_, want to write for TMR2?
07:04:46 <basti_> shapr: i was planning to complete my article and submit it why?
07:04:55 <shapr> just checking
07:05:01 <basti_> ;)
07:05:06 <CosmicRay> the version with the accumulator would usually be the preferred version for other FP languages, esp. if they can do tail recursion optimization (here I'm thinking of ocaml, for instance)
07:05:21 <CosmicRay> since the version written more like the haskell map could consume vast amounts of stack
07:05:33 <Darius> CosmicRay: That's because without laziness, the "map" version in not-tail-recursive.
07:05:46 <CosmicRay> right
07:05:56 <JaffaCake> yes - but in Haskell you might prefer the map version for two reaons
07:05:57 <Darius> CosmicRay: Laziness though causes the function to "return" before handling the next element.
07:05:59 <CosmicRay> so it seems that in haskell, tail recursion is only desirable in some narrow cases
07:06:06 <CosmicRay> Darius: right
07:06:06 <JaffaCake> it works with infinite lists
07:06:06 <TFK> The Monad Reader, eh?
07:06:08 <jlouis> I fail to see why myFoo is better than map (+5) if we want the entire list. The overhead in map with forcing the tail is also done in myFoo when we build the list of thunks
07:06:13 <jlouis> what am I missing?
07:06:20 <shapr> TFK: yeah, want to write a TMR article?
07:06:25 <JaffaCake> it consumes constant memory
07:06:30 <JaffaCake> and it deforests nicely
07:06:31 <TFK> I'll get censored :-/
07:06:36 <JaffaCake> *3* reasons :)
07:06:38 <jlouis> JaffaCake: map?
07:06:42 * TFK reads issue #1
07:06:45 <Darius> CosmicRay: Tail-recursion is always desirable, it's just that different functions are tail-recursive or not.
07:06:53 <CosmicRay> what does "deforest" mean?
07:07:05 <CosmicRay> Darius: well it seems here that there are some good reasons to not be tail recursive in haskell
07:07:06 <nlv11757_> folding structures into values
07:07:07 <Darius> jlouis: Most foldr based things
07:07:13 <JaffaCake> deforest == eliminate intermediate structures in a composition
07:07:25 <Darius> CosmicRay: No.  The "map" version -is- tail-recursive.
07:07:31 * CosmicRay blinks
07:07:32 <Darius> CosmicRay: It just doesn't look like it.
07:07:41 <JaffaCake> Darius: I don't agree
07:07:51 <CosmicRay> Darius: are you saying that the lazy nature of haskell makes it tail recursive automatically?
07:08:04 <nlv11757_> deforest prevents that first a complete structure is being built, to be broken down again.
07:08:14 <Lunar^> JaffaCake: btw, I have somehow narrowed a concurrency problem with FFI, but I'm still unhappy with these tests, as they don't always works
07:08:21 <monochrom> Deforest means in fold.unfold the intermediate list is optimized away.
07:08:27 <Darius> CosmicRay: In this case, yes, in general no and it can make "tail-recursive" things non-tail-recursive.
07:08:41 <JaffaCake> Lunar^: nice giong
07:08:58 <Darius> JaffaCake: If we wrote map in a strict language with explicit thunks using lambda, one would consider it tail-recursive (trivially), no?
07:08:59 <CosmicRay> monochrom: ah, so sort of like evaluating an equation by substituting values for the unknowns?
07:09:30 <JaffaCake> Darius: no, map isn't tail recursive in any language
07:09:31 <Lunar^> JaffaCake: where should I post them, anyway ?
07:09:48 <TheHunter> jlouis, oh i forgot, i already fixed SeenModule today.
07:09:56 <monochrom> I don't see that analogy.  I think it is like fusing two loops.
07:10:03 <JaffaCake> Lunar^: on the bugs list, if it's not too big
07:10:21 <Igloo> CosmicRay: deforestation means that in map (+1) . map (+2) you never make a list whoe values are 2 more than the input list
07:10:23 <Lunar^>  118 total
07:10:34 <jlouis> TheHunter: Do you have a repository online? I could take a look at it
07:10:40 <Lunar^> JaffaCake: I'll do that then
07:10:41 <Igloo> CosmicRay: You take each value and apply (+2) then (+1) and then return that as a list cell
07:10:42 <TheHunter> jlouis, the 6.2 insertWith must be changed to "insertWith f k e m = FM.addToFM_C (flip f) m k e"
07:10:49 <CosmicRay> ok.  I think I understand this bit.  thanks everyone.  now next question :-)  How might seq or strict record fields improve performance?
07:11:04 <TheHunter> jlouis, and the order of the arguments in SeenModule must be reversed.
07:11:06 <CosmicRay> Igloo: gotcha, thanks
07:11:19 <jlouis> TheHunter: thats it?
07:11:27 <jlouis> Because then I am goin to do that ;)
07:11:34 <skew> CosmicRay: I think the big thing those do is give the strictness analyzer information
07:11:37 <monochrom> In foldl (+) 0 [1..10000], if you use seq somewhere, you will save a lot of stack space.
07:11:39 <TheHunter> jlouis, yeah, that's it.
07:11:47 <jlouis> TheHunter: okie
07:12:06 <CosmicRay> monochrom: what about foldr?
07:12:34 <monochrom> foldr (+) 0 [1..10000] doesn't really benefit from seq.
07:13:09 <monochrom> You use seq when you know the eager strategy beats the lazy strategy.
07:13:22 <skew> monochrom: (foldr (+) 0 [1..10000] :: Int) shouldn't benfit, should it?
07:13:31 <skew> monochrom: foldl, I mean
07:13:37 <JaffaCake> if you use seq in foldl, it becomes a tail-recursive accumulator
07:13:59 <JaffaCake> foldr isn't tail-recursive, so doesn't benefit in the same way
07:14:31 <monochrom> which comes to what skew says.  you use seq to help the strictness analyzer to be more aggressive.  this eliminates a lot of spurrious thunking.
07:14:32 <TheHunter> jlouis, shall send you an email, so that dons doesn't have to deal with conflicting changes?
07:14:44 <jlouis> TheHunter: jlouis@mongers.org, please do
07:15:21 <CosmicRay> hmm, so why is there there difference between foldl and foldr in this instance?
07:15:29 <CosmicRay> I thought I could work that out but couldn't quite :-)
07:15:44 <skew> CosmicRay: foldr needs stack space
07:16:07 <monochrom> foldr (+) 0 [1..n] uses Theta(n) space, eager or lazy.
07:16:17 <CosmicRay> since it actually has to begin processing at the right side of the list?
07:16:31 <monochrom> foldl (+) 0 [1..n] uses O(1) space eager, Theta(n) space naive lazy.
07:17:16 <skew> foldr (+) 0 [1,2,3] turns into (1 + (2 + (3 + 0))), which takes linear stack space recursing down the list
07:17:21 <monochrom> no theoretic difference in time complexity.
07:17:29 <thou> is anybody running a recent ghc from CVS?  I just updated and built it (trying to get GLUT to work), and it seems OK except ghci can't parse anything (I get ghc-6.5: panic! (the `impossible' happened, GHC version 6.5): tcSyntaxOp "noSyntaxExpr"); anyone seen this before?
07:17:42 <monochrom> (in practice, wasting space is a good way to waste time too)
07:18:02 <JaffaCake> thou: think that was introduced yesterday
07:18:26 <thou> i figured something like that, just wanted to check.  thanks, JaffaCake
07:18:43 <JaffaCake> it smells like Simon PJ's fault :)
07:18:48 <JaffaCake> and he's not about today
07:19:09 <skew> lazy foldl (+) 0 [1,2,3] accumulates like foldl (+) (0+1) [2,3] => foldl (+) ((0+1)+2) [3] =>foldl (+) (((0+1)+2)+3) => (((0+1)+2)+3, then uses space forcing that expression
07:20:52 <CosmicRay> hmm.  from my memory, in ocaml, foldr is also more efficient, but for a different reason
07:21:00 <CosmicRay> err, no maybe I'm mixed up.
07:21:02 <CosmicRay> hmm.
07:21:08 <thou> JaffaCake: thanks
07:21:44 <tromp> foldr stacks many function applications
07:22:09 <tromp> which cannot be made strict
07:22:29 <CosmicRay> hmm, in ocaml, foldl is more efficient because it is tail-recursive
07:22:37 <tromp> foldr leaves applications in the accumalator which can be made strict
07:22:48 <tromp> change last foldr to foldl:)
07:23:04 <CosmicRay> so, if I don't force the strictness in haskell, foldr is the more efficient?
07:23:38 <CosmicRay> wouldn't it be possible for the optimizer to see what's going on with foldl and evaluate that expression that's stacking up immediately?
07:23:42 <tromp> about same memeory wise, but foldl is tail recursive
07:24:08 <monochrom> There was a subtlety in the statements I made.  On space complexity of foldl (+) 0 [1..n], my statement is about space of "foldl (+) 0", not of the part [1..n].
07:25:33 <tromp> that's what strictness analysis might achieve, CosmicRay
07:25:40 <Darius> CosmicRay: Yes, but if the argument passed to foldl isn't strict then treating it as such can change the behavior of the code.
07:25:42 <CosmicRay> tromp: ah.
07:26:00 <tromp> not sure exactly what cases ghc will catch
07:26:12 <CosmicRay> so I'm looking at the implementation of foldl and foldr in hugs for clarity.  to me it looks like one would end up with closures all over the place with either one
07:26:23 <CosmicRay> foldl f z []      = z
07:26:24 <CosmicRay> foldl f z (x:xs)  = foldl f (f z x) xs
07:26:32 <CosmicRay> foldr f z []      = z
07:26:33 <CosmicRay> foldr f z (x:xs)  = f x (foldr f z xs)
07:26:36 <Heffalump> foldl' exists
07:26:48 <CosmicRay> yes, I know
07:26:57 <CosmicRay> I want to understand these first :-)
07:27:31 <jlouis> TheHunter: applied, thanks
07:27:45 <JaffaCake> foldl always creates a chain of new thunks the same length as the input list
07:28:30 <CosmicRay> do those thunks represent (f z x) or the recursive call to foldl itself (or both?)
07:28:50 <monochrom> f z x
07:28:57 <JaffaCake> the (f z x) call is the thunk;  the recursve call to foldl is tail recursive
07:30:27 <CosmicRay> so when my program demands the result from foldl be computed, it first runs through the entire list via the tail recursion, generating a bunch of thunks, then it evaluates all the thunks to produce the final result?
07:31:56 <nlv11757_> isnt it the case that only one thunk is created initially for the top-level call....and only when for example a bit of result is needed, this thunk is evaluated a bit creating a new thunk representing the tail call......
07:31:57 <monochrom> if naive, yes
07:32:24 <nlv11757_> if that is enough for the result that was needed of course, otherwise more is evaluated...
07:32:30 <nlv11757_> thats the idea right?
07:32:58 <CosmicRay> well with foldl and foldr, there is no "bit" of the result, there is all of the result or none of it
07:33:03 <tromp> no, it has a lazy (thunked) representation of f (f (... (f z xn) ... x1) x0
07:33:04 <CosmicRay> since they aren't building lists
07:33:05 <monochrom> yes nlv, but what is tail-recursive in eager becomes monolithic in lazy: either not computed at all or pursued to its final conclusion
07:33:44 <nlv11757_> ow of course in the fold case there is no bit of result, but i meant it in general for recursive functions....
07:34:22 <monochrom> Yes.
07:34:31 <CosmicRay> monochrom: in that case, why would we get a whole chain of thunks out there with foldl?
07:34:56 <monochrom> For example "take 10 (map f [1..])", with lazy you'll just generate 10 items of the list.
07:35:51 <monochrom> The thunk looks like (((a+b)+c)+d)+e...
07:36:16 <monochrom> I mean the thunk looks like (((a+b)+c)+d)+e... if naively lazy.
07:37:09 <monochrom> There is no urgency to recall 0+1 = 1  until you've finished foldl-ing
07:37:53 <CosmicRay> ok, I think I grok that.
07:38:17 <CosmicRay> so with foldr, why don't we wind up in the same situation?
07:38:26 <monochrom> we do.
07:38:41 <nlv11757_> wouldnt the first thunk be 'map f [1..]'
07:38:48 <CosmicRay> oh.
07:38:50 <CosmicRay> hm.
07:39:00 <monochrom> but no one whines about foldr :)
07:39:15 <CosmicRay> oh right, you said they both use Theta(n) space lazy.
07:41:04 <CosmicRay> why do we even have a foldl given foldl'?
07:41:11 <nlv11757_> btw there *can* be a bit of result when dealing with a fold
07:41:16 <nlv11757_> it depends on the operator
07:41:31 <nlv11757_> @plugs list
07:41:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `list'
07:41:37 <nlv11757_> @plugs
07:41:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
07:41:44 <nlv11757_> @plugs help
07:41:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `help'
07:41:51 <nlv11757_> @plugs listcommands
07:41:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `listcommands'
07:41:56 <nlv11757_> @plugs modules
07:41:56 <CosmicRay> nlv11757_: ah, ok, point taken.
07:41:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `modules'
07:41:59 <CosmicRay> @listcommands
07:42:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I react to the following commands: ["all-dicts","arr","babel","define","
07:42:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- definitions","del-definition","devils","dict","dict-help","dummy","dump"
07:42:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements"
07:42:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","help"
07:42:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"hitchcock","jargon","join","karma","karma+","karma-","kind","learn","leave"
07:42:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"listchans","listcommands","listmodules","lojban","moo","more","msg","part"
07:42:03 <wilx> lambdabot, @help
07:42:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"paste","pl","pl-resume","plugs","pointless","prelude","quit","quote","
07:42:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3 @more lines]
07:42:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  @help <command> - ask for help for <command>
07:42:20 <Darius> @help plugs
07:42:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @plugs <expr>
07:42:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have Haskell, 3 seconds and no IO. Go nuts!
07:42:25 <nlv11757_> @plugs eval (take 10 (foldr (:) [] ([1 .. ])))
07:42:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `eval'
07:42:36 <nlv11757_> @eval (take 10 (foldr (:) [] ([1 .. ])))
07:42:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 18):
07:42:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected ":"
07:42:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting simple term
07:42:51 <wilx> @plugs (take 10 (foldr (:) [] ([1 .. ])))
07:42:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,2,3,4,5,6,7,8,9,10]
07:42:57 <Darius> nlv11757_: @plugs is essentially GHCi, @eval is a sugared lambda calculus.
07:43:06 <nlv11757_> ow ok
07:43:11 <nlv11757_> that clears its use up
07:43:17 <xerox> @plugs foldr1 (flip (:)) [1..10]
07:43:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Occurs check: cannot construct the infinite type: c = [c]
07:43:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: c -> c -> c
07:43:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: c -> [c] -> [c]
07:43:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `flip', namely `(:)'
07:43:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `foldr1', namely `(flip (:))'
07:43:22 <monochrom> I can't think of an application of the lazy foldl for the moment.
07:43:23 <xerox> :\
07:43:25 <Darius> CosmicRay: There is a semantic difference between foldl and foldl'
07:43:34 <Darius> But foldl is mostly useless.
07:43:36 <nlv11757_> see cosmicray, if there never was a *bit* of result to a fold......take 10 (foldr (:) [] ([1 .. ])) wouldnt work
07:44:08 <CosmicRay> ah ok, so foldl is useful when there is in fact a bit of the result, due to laziness?
07:44:40 <nlv11757_> foldl is usefull when not used in a lazy sense
07:44:42 <nlv11757_> i think
07:44:47 <Darius> CosmicRay: A possible scenario when you might want to use foldl v. foldl' is described on http://www.haskell.org/hawiki/StackOverflow.
07:44:47 <musasabi> Created a DiceModule for lambdabot...
07:44:50 <monochrom> I can think up a pathological example.
07:45:29 <Darius> CosmicRay: Nevertheless, it's not very compelling and in almost all cases you want foldl' (unless you want foldr).
07:45:44 <wilx> @type foldl'
07:45:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
07:45:57 <nlv11757_> foldl1 ?
07:45:58 <wilx> @type foldl1
07:46:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- foldl1 :: forall a. (a -> a -> a) -> [a] -> a
07:46:02 <wilx> @type foldl
07:46:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
07:46:42 <vegai> question for you ... oldtimers
07:46:42 <monochrom> good explanation on that wiki
07:47:15 <vegai> when you see the type of the complexity of e.g. foldl, do you instantly understand it?
07:47:24 <Lunar^> JaffaCake: Do "dynamic" wrapped functions always get their own thread?
07:47:41 <JaffaCake> Haskell thread? yes
07:47:42 <Darius> @type Data.List.foldl'
07:47:43 <monochrom> Almost instantly.
07:47:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.List.foldl' :: forall a b. (a -> b -> a) -> a -> [b] -> a
07:47:45 <CosmicRay> thanks for all the exlpanations
07:48:04 <nlv11757_> foldl's type in combination with its name says enough i think vegai
07:48:07 <Lunar^> JaffaCake: mhhh
07:48:19 <vegai> yes, the name helps a lot, of course.
07:48:23 <Lunar^> JaffaCake: then a pthread one if -threaded?
07:48:31 <Darius> vegai: The more polymorphic a function is the more limited the possible implementations are, whereas Int -> Int, say, has quite a few possible implementations.
07:48:55 <vegai> I find it quite hard to sometimes see the implications of different polymorphic types
07:49:06 <nlv11757_> vegai: theres only one function with this type: (a,b) -> (b,a)
07:49:07 <shapr> musasabi: oh that's neat, did you submit it?
07:49:10 <nlv11757_> modulo sneaky cases
07:49:13 <JaffaCake> Lunar^: you mean a foreign import "dynamic"?
07:49:27 <vegai> nlv11757_: swap?
07:49:31 <vegai> hmm
07:49:33 <nlv11757_> exactly,
07:49:47 <nlv11757_> in many times, the type almost writes the function
07:49:51 <vegai> yes, I agree
07:50:00 <vegai> it doesn't mean that it's fast to comprehend :)
07:50:06 <monochrom> natural transformations rule the world!
07:50:06 <nlv11757_> thats why if a function is correctly typed...its correct in a lot of cases
07:50:24 <Lunar^> JaffaCake: Yes, I still trying to understand my FUSE binding deadlock
07:50:25 <nlv11757_> it may take a bit of adaption at first vegai
07:50:57 <JaffaCake> Lunar^: a foreign call runs in a separate pthread if it is "safe"
07:51:08 <JaffaCake> "dynamic" makes no difference
07:51:13 <Darius> JaffaCake: Is there any term for this, f () = \() -> f (), scenario?
07:51:14 <vegai> @type (\a b c -> a . b . c $ a)
07:51:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (\a b c -> a . b . c $ a) :: forall c b c1.
07:51:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                              (c1 -> c) -> (b -> c1) -> ((c1 -> c) -> b)
07:51:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- -> c
07:51:36 <wilx> @pointfree (\a b c -> a . b . c $ a)
07:51:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "pointfree", try "lambdabot: @listcommands"
07:51:47 <musasabi> shapr: I am submitting it now :-) (just had some testing to do)
07:51:47 <wilx> @pointless (\a b c -> a . b . c $ a)
07:51:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s (flip . (flip .) . (. (.)) . (.) . (.)) id
07:51:54 <shapr> spiffy
07:51:55 <JaffaCake> Darius: yes, a type error :P
07:52:23 <JaffaCake> Darius: perhaps I don't understand - could you elaborate?
07:53:32 <Darius> JaffaCake: A recursive call guarded by a lambda.
07:53:41 <Lunar^> JaffaCake: *sigh*, I still don't understand the whole concurrency+FFI thing
07:53:49 <vegai> @pointless (\a b -> (a+b))
07:53:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (+)
07:53:54 <vegai> touch
07:54:10 <jlouis> @pointless \x -> length $ concat x
07:54:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- length . join
07:54:36 <vegai> extremely spiffy
07:54:40 * shapr agrees
07:55:03 <shapr> Oh, I should scrape my hacks out of HaddockModule and into Haddock itself.
07:55:08 <JaffaCake> Lunar^: it's not that hard, really!
07:55:11 <jlouis> Actually, I had hoped for a non-reduction
07:55:35 <jlouis> I often have (\x -> foor $ bar x) and want it points-free
07:55:49 <jlouis> foo . bar maybe
07:55:51 <JaffaCake> Lunar^: you tried running with +RTS -Ds?  (you need to build a thr_debug RTS though)
07:56:24 <Lunar^> JaffaCake: oh thanks! I forgot that I hadn't a network connection last time, and that I was laciking binutils-dev
07:56:37 <Lunar^> shapr: Have you seen http://svn.openfoundry.org/pugs/docs/advocacy/phd.png ?
07:56:42 * shapr looks
07:56:56 <shapr> haha!
07:57:08 <JaffaCake> lol
07:57:13 <shapr> That's great, where did it come from?
07:57:21 <Lunar^> shapr: autrijus log
07:57:29 <basti_> hehehe
07:57:35 <TFK> What's that asterisk for?
07:57:44 <TFK> *asteriks?
07:58:00 <autrijus> mugwump drew it :)
07:58:13 <autrijus> after I mentioned that haskell is "powered by phd"
07:58:16 <wilx> What's asteriks?
07:58:23 <wilx> The * thing is asterisk.
07:58:41 <TFK> asterisk, I knew it!
07:58:56 <shapr> oh hey, autrijus pointed out something really interesting yesterday on #perl6. He said that GADTs are actually easier to understand for newbies, because they follow the rest of haskell style. Constructors with types show obvious parallels with functions.
07:59:02 <CosmicRay> oo, who else is talking about asterisk?
07:59:19 <autrijus> data Point where
07:59:23 <Lunar^> Igloo: ghc6 package should Suggests binutils-dev, btw. -debug requires linking with libbfd
07:59:25 <autrijus>     Pt :: Int -> Int -> Pont
07:59:29 <wilx> Hm, Asteriks et Obelix or something like that are French animated characters.
08:00:08 <shapr> So now I wish for deriving show et al with GADTs, because I'd like to exclusively use GADTs in HaskellDemo
08:00:08 <wilx> Asterix even.
08:00:12 <TFK> wilx, hmm, the funny vikings vs. the evil Roman empire?
08:00:23 <wilx> Yup :)
08:00:31 <Igloo> Ta, Lunar^
08:00:31 <TFK> :-D
08:00:39 <autrijus> shapr: it's not hard to use one of the derive generators to generate Show
08:00:41 <Itkovian> bye
08:00:48 <autrijus> shapr: but it'd be wonderful if GHC has it in core
08:00:57 <wilx> Derive generators?
08:01:00 <shapr> Are there any cases where GADTs allow less options than a non-GADTs constructor?
08:01:14 <keygjones> is there a way to define a function wich takes an Int x and returns a list with (x-1) say x=5 then [1,2,3,4,5] ??
08:01:18 <autrijus> wilx: there are a number of tools out there that helps you generate "instance" clauses for nonderivable things
08:01:21 <JaffaCake> I bet the {-# UNPACK #-} directive doesn't work on GADTs
08:01:33 * JaffaCake checks
08:01:39 <basti_> what are GADTs? GA Data Types?
08:01:44 <shapr> basti_: yes
08:01:47 <basti_> and whats GA?
08:01:54 * Lunar^ will try to figure out this deadlock problem another time
08:01:59 <autrijus> Generalised Algebraic
08:01:59 <wilx> General Algebraic iirc.
08:02:02 <basti_> ahhh
08:02:03 <wilx> Oh.
08:02:09 <shapr> Glasgow Abstract Data Tree
08:02:11 * shapr snickers
08:02:16 <basti_> okay now i can join the discussion.
08:03:00 <JaffaCake> there's no strictness annotations at all in GADTs, it seems
08:03:20 <nlv11757> hmmm that was a disconnect, and now my ghost is still on here
08:03:31 <TFK> Erm, regarding the Pseudocode article in TMR#1, second code sample (accumulator recursion), I can't figure it out... acc doesn't seem to get a value anywhere.
08:03:31 <shapr> nlv11757: you can use the ghost command to get rid of it.
08:03:33 <Darius> JaffaCake: I thought the User Guide said you could put them where it would make sense?
08:04:27 <shapr> TFK: passed in?
08:04:37 <JaffaCake> hmm, it does say that...
08:04:50 <TFK> From where? A person calls reverse, not rev', right?
08:04:53 <autrijus> JaffaCake: it works
08:05:15 <JaffaCake> ah i see why... strictness marks are allowed anywhere in a type
08:05:31 <JaffaCake> please ignore me :)
08:05:53 <nlv11757> i dont see a ghost command shapr
08:06:03 <nlv11757> or is it nickserv related
08:06:04 <shapr> nlv11757: /msg nickserv help ghost
08:06:10 <nlv11757> ah thought so
08:06:23 <shapr> TFK: oh, that first acc should be [] I think
08:06:27 <nlv11757> i havent registered my nick :D so i dont think ghost is going to help me out
08:06:31 <shapr> But I also thought I fixed that bug :-(
08:07:06 <TFK> Oh, that makes more sense, then :-)
08:07:12 <Darius> JaffaCake: I pretty sure it's been asked, but why does Haskell not have Clean-like strictness annotations for functions and further no compiler supports them as an extension?
08:07:18 <nlv11757> thats the accmuluating parameter TFK ;)
08:07:19 <TFK> Noobs like me will read TMR, I must note
08:07:21 <keygjones> found it : construct :: Int -> [Int]
08:07:21 <keygjones> construct x = [1..x]
08:07:47 <nlv11757> Darius: uniqueness types you mean?
08:07:50 <shapr> TFK: someone found that bug before, and I fixed it before. So I am surprised it is still there.
08:07:54 <JaffaCake> Darius: good question... I think we'd like to do it in a more general way
08:08:08 <mugwump> The asterix on the logo refers to the in-depth thesis discussing the meaning behind the assertion (to-do ;)
08:08:16 <TFK> I got the single-zine-in-a-file version.
08:08:25 <JaffaCake> Clean just allows ! as an annotation on an argument type, but it would be nice to have [!Int] for example too
08:08:29 <nlv11757> uniqueness typing in concept is interesting from a performance point of view for sure, i dont know how it would fit in the haskell setting though
08:08:32 <shapr> TFK: oooh
08:08:34 <TFK> tmr_full_issue1.pdf from the wiki
08:08:49 <shapr> I only fixed it in the single file version
08:08:54 <TFK> Is that unedited?
08:08:58 <TFK> Oh, heh...
08:09:02 <shapr> I need to talk to Itkovian when he returns, he generated the single file.
08:09:11 <shapr> This is why I want to use a wiki :-/
08:09:17 <Darius> nlv11757: Not uniqueness typing.  That would be interesting as well, but I can see why Haskell implementors haven't made that extension.
08:09:22 <nlv11757> tiki-wiki-friki
08:09:27 <shapr> wikiwiki!
08:09:37 <nlv11757> how many bloody wiki variants are there :D
08:09:44 <nlv11757> twiki wiki, wiki wiki, ...
08:09:45 <shapr> Oh hey, I applied to the Stewards of Wiki committee!
08:09:46 <TFK> Moin.
08:09:48 <CosmicRay> nlv11757: I don't know, start a wiki to count...
08:09:53 <TFK> MoinMoin.
08:09:54 <nlv11757> counti wiki
08:10:06 * CosmicRay wonders if there would be any use to have a generic forums area on the sequence
08:10:13 <TFK> [Moin,MoinMoin,MoinMoinMoin...]
08:10:36 <shapr> In his reply Ward Cunningham sounds interested in the read-only synchronized serverless filesystem darcs-wiki idea I suggested.
08:10:37 <Darius> JaffaCake: Wouldn't a strictness annotation like [!Int] require a DeepSeq-like behavior and not necessarily be a good idea?
08:11:02 <Darius> shapr: Reply where?
08:11:04 <JaffaCake> not necessarily, it just denotes a list of evaluated Ints
08:11:30 <shapr> Darius: in email
08:11:53 <Darius> JaffaCake: If ! is a compiler hint, wouldn't the compiler have to make that true, or are you thinking having a strictness "type" system?
08:12:00 <TFK> Hmm, how will that work?
08:12:08 <nlv11757> @plugs take 3 $ iterate (++ "Moin") "Moin"
08:12:11 <TFK> And what does darcs have to do with it?
08:12:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ["Moin","MoinMoin","MoinMoinMoin"]
08:12:19 <nlv11757> TFK ;)
08:12:31 <JaffaCake> there's two questions: what types can you write, and what automatic coercions are added by the compiler
08:12:37 <TFK> heh, nice :-)
08:13:14 <wilx> Hmm, none? :)
08:13:22 <wilx> Dunno.
08:13:25 <wilx> Ignore me :)
08:13:46 <JaffaCake> Darius: I don't have complete answers to either of those.. there's a design space to explore
08:14:25 <TFK> Say, how does lambdabot handle infinite data structures that may cause a channel flood?
08:15:25 <shapr> TFK: I described a read-only synchronized serverless filesystem darcs-wiki in itself. Grab the wikiwiki repo from http://www.scannedinavian.org/repos/wikiwiki
08:16:18 <Darius> TFK: It should only show so much output no matter what.
08:16:28 <nlv11757> i'd say not too much type juggling
08:16:59 <Darius> TFK: All modules (though mainly eval and plugs) should have a way to avoid tying up the bot forever. (on a related point)
08:22:48 <jlouis> @type liftIO
08:22:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
08:23:08 <jlouis> @type Control.Monad.liftIO
08:23:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
08:23:13 <jlouis> heh
08:23:16 <nlv11757> anyone have a nice 'learn-C-by-doing-exercises'-website?
08:23:30 <shapr> nlv11757: -fvia-C
08:23:34 * shapr cackles evilly
08:23:47 <nlv11757> www.-fvia-C.com then i assume?
08:23:48 <nlv11757> :P
08:23:49 <Heffalump> ooh, kernel dropping bitkeeper (or vice-versa), if slashdot is to be believed
08:23:59 <mattam> switching to ?
08:24:04 <vegai> in favour of darcs?`=)
08:24:08 <df_> When compiling some code using ghc-6.2.2 (solaris) with -prof -auto-all and running with +RTS -xc, why does the cost centre stack only show <Data.Maybe.CAF> when the following gets evaluated (fromJust Nothing) occurs, ie Fail: Maybe.fromJust: Nothing
08:24:19 <Heffalump> http://kerneltrap.org/node/4966
08:24:27 <Heffalump> mattam: not decided yet.
08:24:36 <vegai> that was to be expected
08:24:44 <Heffalump> but darcs is being mentioned in the same breath as the other options
08:25:00 <vegai> interesting. I mentioned that here as an april's fool ;)
08:26:12 <df_> thats not been on LKML
08:26:21 <df_> in any way shape or form
08:26:29 <Igloo> I don't see darcs happening if they want something now, unfortunately
08:26:58 <Heffalump> did they pick up an AF joke and repost it or something?
08:27:16 * Heffalump is keen on cross-VC integration.
08:27:41 <nlv11757> i call it a day, cya
08:27:47 <shapr> cya nlv11757
08:28:09 <Igloo> Your problems with CVS were caused by not being able to lock what was necessary, right? Could you do what you were trying to do with svn, arch etc?
08:28:27 <Heffalump> not sure.
08:28:39 <Heffalump> I think it was only a problem with CVS pserver.
08:28:41 <Igloo> Actually, I'm not sure it makes sense with arch
08:28:44 <JaffaCake> df_: <Data.Maybe.CAF> probably because the exception is thrown from a CAF
08:28:46 <Heffalump> which is not necessarily that common a case
08:29:49 <df_> JaffaCake :: unfortunately this is dangling in bits i do not currently understand as well as i'd like.  is there anyway to find out what the previous costfunction was?
08:29:58 <Igloo> Bah, I should scan in Milner's '78 H-M paper
08:30:10 <shapr> Igloo: I want a copy!
08:30:19 * shapr googles for type theory warez
08:30:27 <df_> ie, i can't find out what evaluated fromJust Nothing
08:30:41 <JaffaCake> df_: this is kind of a problem with the profiling system at the moment: it doesn't handle CAFs very well
08:30:54 <df_> ah
08:31:13 <shapr> I get "fromJust Nothing" when rebuilding pugs sometimes. make clean && make fixes it.
08:31:16 <JaffaCake> if the call to fromJust is in your code, then you can write your own version of fromJust and hope the compiler doesn't turn the exception into a CAF
08:31:45 <JaffaCake> shapr: I think someone reported that
08:32:04 <JaffaCake> I'll look into it at some point
08:32:30 <shapr> I can reproduce it every ten or so times I rebuild.
08:32:55 <JaffaCake> ok, thanks
08:33:12 <df_> jaffacake :: ta.  does modularisation affect what gets turned into a CAF?
08:33:29 <JaffaCake> no, but optimisation probably does
08:34:03 <df_> thank you, will have a play.
08:34:05 <JaffaCake> you want the call to error to be inside a function: use whatever tricks you can think of to stop the optimiser pulling it out to the top level :-)
08:34:43 <shapr> salut cognominal
08:35:08 <cognominal> I was wondering where I had met you first. That must be here :)
08:35:19 <thou> JaffaCake: is it a known problem that in GLUT/examples/RedBook, about half of the programs core dump?  or is it just me having a bad build?
08:35:35 <JaffaCake> no idea, sorry
08:35:38 <thou> k
08:35:52 <shapr> cognominal: It seems likely. I am often here.
08:35:55 <thou> i think it might be NURBS aren't implemented yet (properly) yet
08:36:28 <thou> gdb on a core file isn't too much fun, though  :-)
08:36:33 <basti_> the c2.com/cgi/wiki thing is rather popular and polemic isnt it?
08:36:47 <shapr> polemic?
08:37:02 <shapr> basti_: That's the original wiki, Ward Cunningham's wiki.
08:37:18 <basti_> yes like, saying what people want to hear
08:37:20 <shapr> I started using Ward's Wiki in the mid to late 90s, could have been as early as 95
08:37:59 <basti_> http://c2.com/cgi/wiki?ProofsCantProveTheAbsenceOfBugs < for example this page
08:38:13 <basti_> wrong in several points i'd say
08:39:06 <shapr> There are many dissonant viewpoints on the wiki these days, and a lot of utter bullshit lately.
08:39:15 <basti_> yup.
08:39:29 <shapr> In the beginning there were many dissonant viewpoints, but everybody was listening and learning.
08:39:43 <TFK> So! Before I go away and make a c2.com-like wiki, maybe someone came up with nice projects-for-a-beginner overnight?
08:39:47 <shapr> Extreme Programming came from early dissonance on Ward's Wiki.
08:43:12 <shapr> TFK: text fractal?
08:43:23 <shapr> TFK: sierpinski thingies? cantor dust?
08:43:51 <basti_> l systems!
08:43:59 <shapr> Yeah, L-systems are cool.
08:44:15 <jlouis> ah, heh, refactorisation galore
08:44:23 <jlouis> just saw how this should be done
08:44:23 <musasabi> Lambdabot needs really a better way to include/exclude modules.
08:44:26 <autrijus> Pseudonym++ # "Prototyping new monads" in http://lambda-the-ultimate.org/node/view/290
08:44:28 <TFK> Something less acamedic, perhaps?
08:44:30 <shapr> Wow, we're over 150 unique clients in #haskell
08:44:43 <shapr> TFK: hm, I thought those weren't academic :-/
08:45:00 <TFK> They are for me :-/
08:45:00 <shapr> TFK: I wrote a mandelbrot as my first program, and I haven't had either math or computer science classes.
08:45:35 <shapr> TFK: http://mathworld.wolfram.com/SierpinskiCurve.html
08:45:48 <TFK> What, you cloned Benoit Mandlebrot?...
08:46:06 <shapr> TFK: and I use him for line noise correction.
08:46:17 <shapr> Isn't that where his research started anyway?
08:46:33 <TFK> Doesn't that violate some articles in the UN's bill of rights? o_O
08:46:54 <TFK> (Or whatever it's called.)
08:47:04 <shapr> Bah, all UN legal documents are :: _|_ anyway!
08:47:24 <TFK> :-D
08:47:35 <basti_> ah!
08:47:36 <basti_> ;)
08:47:44 <TFK> Good thing is, they never get evaluated ;-)
08:47:48 <shapr> haha
08:47:54 <df_> jaffacake :: building Data.Maybe without optimizations worked
08:48:04 <TFK> UN is lazy, which is the only thing that guarantees its operation ;-)
08:48:08 <JaffaCake> df_: great!
08:49:54 <TFK> BTW, I believe it was Dijkstra who said that the programmer's best asset is mastery of his/her native tongue.
08:50:10 <TFK> (Regarding Pseudocode article ;-)
08:50:14 <TFK> (Still reading)
08:50:39 <shapr> mugwump: this PhD powered logo is awesome!
08:50:49 <shapr> Can I use it on my websites too?
08:52:56 <df_> Linus has just posted something on SCM to LKML
08:52:57 <autrijus> it's in the pugs tree, so probably yes :)
08:53:13 <shapr> spiffy
08:53:32 <bringert> shapr: so they have type bottom?
08:53:35 <autrijus> I'll probably use it too without the line at the bottom
08:53:42 <bringert> wouldn't that mean they can't even be checked
08:54:42 <basti_> have you ever tried to check a UN legal document?
08:54:44 <df_> ``NOTE! BitKeeper isn't going away per se. Right now, the only real thing that has happened is that I've decided to not use BK mainly because I need to figure out the alternatives, and rather than continuing "things as normal", I decided to bite the bullet and just see what life without BK looks like. So far it's a gray and bleak world ;)'' -- Linus
08:54:52 <TFK> I think it means that when evaluated, the program goes "boom!" ;-)
08:55:15 <shapr> I think I'd like the * at the bottom to point to something like "GHC, powered by dissertations. -- Autrijus"
08:55:26 <TFK> df_, link?
08:55:35 <musasabi> shapr: Would changing the command-list of modules in lambdabot to a data Command = Command String String (first is the group of the command, second the name of the command) make sense. Then listcommands would display commands sectioned by their group and omit commands with a a group of ""/
08:55:43 <autrijus> hrm, I hope someone will point linux to svk, darcs and tla
08:56:11 <df_> ``PS. Don't bother telling me about subversion. If you must, start reading up on "monotone". That seems to be the most viable alternative, but don't pester the developers so much that they don't get any work done. They are already aware of my problems ;)''
08:56:16 <df_> --Linus
08:56:31 <mattam> GADT already there ? that's quick theory-to-practice :)
08:56:43 <df_> TFK :: onesec
08:57:24 <df_> http://www.ussg.iu.edu/hypermail/linux/kernel/0504.0/1540.html
08:57:35 <bringert> shapr: I'll see if I can think of something for TMR2. maybe writing natural language apps in haskell using GF? but I'm not promising anything
08:57:37 <autrijus> mattam: such is the usual case with GHC :)
08:57:50 <autrijus> GF? girlfriends?
08:57:52 <shapr> musasabi: Sounds okay to me. dons is the main man behind lambdabot right now, but I think he'll likely say "go for it"
08:57:55 <theorbtwo> GADTs are already used... damn, beaten to the punch.
08:58:10 <shapr> bringert: Yes, that's exactly the sort of article I was hoping you might write :-)
08:58:24 <autrijus> theorbtwo: eh? :)
08:58:43 <theorbtwo> GADTs are already in live use in Pugs.
08:59:11 <autrijus> yeah.
08:59:18 <Lemmih_> shapr: Yo.
08:59:30 <shapr> y0 y0
08:59:46 <bringert> I'm having problems with the interaction between GADTs and fundeps
08:59:54 * shapr points to JaffaCake 
08:59:55 <mattam> autrijus: yeah, that's the nice thing about it. There's someone working on it for ocaml but i'm not even sure it'll get integrated :(
09:00:10 <musasabi> What is the issue with Dynamic vs StaticModules? (in lambdabot and which are the way to future)
09:00:10 * JaffaCake runs away
09:00:14 <Lemmih> shapr: I'm having prolems with Hackage in /cgi-bin/.
09:00:23 <shapr> Lemmih: elucidate
09:00:30 <bringert> JaffaCake: the code and error message are at the bottom of http://haskell.org/hawiki/HaskellIrcPastePage
09:00:49 <shapr> Lemmih: what problems?
09:01:16 <JaffaCake> bringert: I'm afraid that's not my domain, try sending it to ghc-users
09:01:28 <Lemmih> shapr: It's not executing the cgi binary.
09:01:33 <shapr> musasabi: I think the way to the future is to switch to hs-plugins, it's the next step after libs like Hampus Ram's DynamicLoader.
09:01:45 <shapr> Lemmih: ah, lemme fix that.
09:02:17 <bringert> JaffaCake: I thought you might say that :-)
09:02:46 * JaffaCake grins
09:03:10 * TFK reads Problem o' The Month
09:03:54 <nibro_> any op around who'd care to kick my shadow who forgot to sign off when he left work? =)
09:05:17 <basti_> hm
09:05:20 <basti_> it'll die.
09:05:21 <basti_> eventually
09:05:53 * nibro_ kicks nibro
09:06:10 <basti_> it still replies to ping's!?
09:06:15 <basti_> 18:07 [ctcp(nibro)] PING 1112803622 647066
09:06:16 <basti_> 18:07 CTCP PING reply from nibro: 0.936 seconds
09:06:28 <basti_> ahh you left the client open
09:06:30 <nibro_> sure it does, I just locked the computer when I left
09:06:32 <basti_> no then it WONT die.
09:06:38 <nibro_> nope
09:08:27 <TFK> Does the Problem o' The Month require graphs and/or graph-theory?...
09:09:10 <TFK> Also, it appears that TMR#2 is behnd schedule? :-P
09:09:14 <bringert> nibro_: ssh home and kill the client?
09:09:32 <bringert> or if you are running windows, just use one of the remote root exploits and do it
09:09:44 <bringert> poor man's ssh
09:09:50 <basti_> -g-
09:09:59 <nibro_> I can't ssh to xi, it won't accept remote logins
09:10:31 <bringert> ah, sorry, I read "left home", not "left work"
09:10:49 <nibro_> hehe, I don't keep your schedule ;)
09:11:10 * bringert is planning to have lunch soon
09:12:12 * nibro_ had lunch at lunch...
09:13:33 --- mode: ChanServ set +o nibro_
09:14:05 * shapr is planning to have breakfast soon.
09:15:15 --- kick: nibro was kicked by nibro_ (nibro_)
09:15:40 <nibro_> eh...
09:16:03 <shapr> If you've registered your nickname you can ghost the other client.
09:16:30 <nibro_> I was planning to register it now... :p
09:16:42 <Igloo> If it can rejoin it's still running
09:16:52 <nibro_> it most certainly is
09:17:10 <bringert> nibro_: where is xi? can I go kick tha box?
09:17:14 <nibro_> I have the bad habit of just xlocking when I leave
09:17:23 <bringert> as in kicking with my foot
09:17:38 <Igloo> You could kill the process
09:17:59 <nibro_> don't think so, it's the computer that I end up at when I login at my desk (sun ray client)
09:19:12 <nibro_> I could of course send you my passwd and you could kill it from my desk, but I'd say that's not the Right Way (TM) to do it...
09:20:01 <df_> pull the network cable out for 2mins
09:20:54 <nibro_> might work :) bringert, know where my desk is?
09:21:57 <df_> oh, you using thin clients?
09:22:03 <nibro_> yes
09:22:06 <df_> it won't work
09:22:08 <SamB> shapr: did you get my email?
09:22:14 <df_> stuff isn't run on the local machine
09:22:48 <bringert> nibro_: you in the same room as ulf?
09:22:55 <nibro_> I guess I'll just have to live with my stupidity...
09:23:04 <nibro_> bringert: yes, pete's old desk
09:23:23 <nibro_> ah, but of course, you can kick me out through xlock =)
09:23:37 <SamB> nibro_: you can't kill your own processes?
09:23:38 <df_> they use a virtual framebuffer on a server which the thin client then connects to.  (a la vnc)
09:23:59 <nibro_> SamB: I can't remotely login to the computer that's running them
09:24:08 <SamB> oh
09:24:22 <bringert> nibro_: do the thin clients have the kickable xlock? isn't that just for student machines?
09:24:27 <bringert> I'll go have a look
09:24:43 <nibro_> dunno
09:25:00 <nibro_> never thought about that :\
09:26:01 <nibro> ah, to be back in one's own guise =)
09:26:07 <nibro> thanks bringert =)
09:26:08 <SamB> what is the point of thin clients if you cannot log in to the mainframe (or whatever they call them) remotely from thick clients?
09:26:28 <df_> (or at least thats the way i've always done thin clients with sunrays so that you can log in to any machine and keep a session persistant)
09:26:36 <bringert> nibro: you're welcome
09:27:02 <stepcutHM> so, is darcs ready for linus yet ?
09:27:31 <nibro> SamB: I don't even want to try to understand how our support thinks...
09:27:41 <df_> samb :: i wouldn't want people using up resources on the thin client servers if they can use it else where
09:27:44 <SamB> stepcutHM: not from what I see in #darcs...
09:27:47 <CosmicRay> stepcutHM: doubtful, since it toook him 2 hours
09:28:10 <stepcutHM> :p
09:28:14 <SamB> df_: resources are one thing, but processes are another!
09:28:29 <nibro> so maybe now I can start asking real questions ;)
09:28:50 <nibro> is there a command I can use to glean the contents of a .a archive?
09:29:13 <SamB> nibro: glean?
09:29:21 <df_> nibro :: at -t
09:29:25 <df_> ar -t even
09:30:20 <nibro> lol, I should have waited for the answer, ar -p was *not* the right thing ;)
09:30:47 <df_> hehe
09:31:23 <nibro> thanks :)
09:31:42 <nibro> so here's a more lengthy question:
09:32:03 <nibro> I'm trying to create and install a package for ghc-6.4
09:32:36 <vegai> CosmicRay: 2 hours?
09:32:55 <nibro> I think I have it all correct, but still ghci complains
09:33:26 <nibro> Loading package haskell-src-exts-0.2 ... linking ... done.
09:33:27 <nibro> During interactive linking, GHCi couldn't find the following symbol:
09:33:27 <nibro>   LanguageziHaskellziHsxziBuild_name_closure
09:33:27 <nibro> This may be due to you not asking GHCi to load extra object files,
09:33:27 <nibro> archives or DLLs needed by your current session.  Restart GHCi, specifying
09:33:27 <nibro> the missing library using the -L/path/to/object/dir and -lmissinglibname
09:33:29 <nibro> flags, or simply by naming the relevant files on the GHCi command line.
09:33:30 <nibro> Alternatively, this link failure might indicate a bug in GHCi.
09:33:32 <nibro> If you suspect the latter, please send a bug report to:
09:33:34 <nibro>   glasgow-haskell-bugs@haskell.org
09:33:45 <nibro> so I do the following:
09:34:22 <nibro> > ghc-pkg field haskell-src-exts library-dirs
09:34:22 <nibro> library-dirs: /users/cs/group_multi/pub/linux/lib
09:34:24 <df_> right, i think it is home time.  ttfn peoples
09:34:48 <nibro> > ll /users/cs/group_multi/pub/linux/lib
09:34:58 <nibro> -rw-r--r--    1 d00nibro _cs       2045448 Apr  6 18:14 libHShaskell-src-exts.a
09:35:28 <nibro> what am I doing wrong?
09:37:14 <juhp> nibro: how about HShaskell-src-exts.o ?
09:38:04 <nibro> juhp: doh, of course you're right! I renamed it from hsx to haskell-src-exts, but I forgot the HShsx.o file...
09:38:08 <nibro> thanks :)
09:39:46 <TFK> Well, no one will do my thinking for me, so I'll make a wiki after all :-)
09:40:34 <Philippa_> it does have the upside of a) being fun and b) getting you thoroughly inducted into haskell IO
09:41:54 <nibro> :( still won't work
09:42:34 <nibro> now I have the correct HShaskell-src-exts.o file, in the same dir, but I get the same error
09:42:50 <nibro> the .o is
09:42:53 <nibro> gah
09:43:15 <nibro> the .o is created from the .a by simply extracting the contents, and the .a seems to contain the right stuff
09:43:36 <Lemmih> Are you trying to build a package without Cabal?
09:43:47 <nibro> yes
09:43:58 <TFK> Philippa_, indeed. So all is well that ends well. Of course the end is just the beginning on this one...
09:44:04 <Lemmih> Why?
09:44:17 <nibro> I've found Cabal is too limited in its configuration capabilities
09:44:21 <TFK> BTW, regarding Darcs in the linux kernel dev: "Larry noted that Linus tried monotone, but a simple import of flat files without versioning information took 2 hours, far too slow. The same was true for Darcs."
09:44:40 <nibro> it only passes a select few flags to configure
09:44:55 <basti_> aww :(
09:45:00 <basti_> poor darcs
09:45:02 <Lemmih> nibro: It can pass anything to configure.
09:45:17 <nibro> oh?
09:45:41 <nibro> "The --with-hc, --with-hc-pkg and --prefix options to the configure command are passed on to the configure script.
09:45:59 * Lemmih recently cabalized his SDL binding which can take a --with-pthread flag.
09:46:24 <nibro> did you make a custom main function then?
09:46:55 <nibro> or is the above quote just plain wrong?
09:47:37 <Lemmih> nibro: I used 'defaultMainWithHooks'
09:47:56 <Lemmih> and 'defaultUserHooks'.
09:48:23 <nibro> hmm...
09:49:27 <Lemmih> You should always use Cabal except in extreme cases.
09:50:10 <nibro> yikes, it didn't like my .cabal file!
09:50:15 <nibro> but ghc accepts it
09:50:36 <nibro> I guess I shouldn't be surprised though...
09:51:14 <nibro> how do I specify that the package should be exposed or not by default?
09:51:25 <nibro> I get: *** Exception: Line 6: Unknown field 'exposed'
09:52:47 <Lemmih> You don't.
09:53:13 <Lemmih> Hey SyntaxNinja.
09:53:17 <nibro> Lemmih: I wouldn't hesitate to use cabal if there was full-fledged system working, but right now it still feels like there's a lot of work left on it
09:53:36 <Lemmih> SyntaxNinja: shapr is looking at the server config so Hackage will probably soon be running.
09:53:53 <Arafangion> What would be the fastest functional language in existance?
09:54:01 <basti_> ocaml?
09:54:07 <Arafangion> One that potentially supports unlimited tail-call recursion.
09:54:08 <nibro> Lemmih: in particular I want a way to define "shipments"
09:54:16 <Arafangion> ocaml might be a decent suggestion, actually.
09:54:18 <Lemmih> shipments?
09:54:32 <SyntaxNinja> Lemmih: cool. thanks shapr
09:55:14 * SyntaxNinja wonders if we're talking about cabal shipments
09:56:08 <nibro> Lemmih: that's isaac jones' word for it, i.e. a bundle of interrelated packages and executables distributed together
09:56:20 <nibro> SyntaxNinja: yes :)
09:56:59 * nibro should learn to use whois...
09:57:24 <nibro> speak of the dev... eh...eloper :)
09:57:31 <TFK> So, Network.CGI, Text.HTML and System.IO is what I should be looking at?
09:57:40 <TFK> (for a simple wiki)
09:57:41 <SyntaxNinja> hi nibro
09:58:09 <Lemmih> As in 'Setup.lhs sdist'?
09:59:00 <SyntaxNinja> nibro: what's your question about shipments?
09:59:08 <Philippa_> TFK: that works
09:59:40 <nibro> <nibro> Lemmih: I wouldn't hesitate to use cabal if there was full-fledged system working, but right now it still feels like there's a lot of work left on it
09:59:48 <TFK> OK ^_^ finally, figuring out whetehr to use Haskell.syn or Haskell2.syn in TextPad :-/
09:59:49 <nibro> <nibro> Lemmih: in particular I want a way to define "shipments"
10:00:19 <Lemmih> 'sdist' isn't quite working right but that doesn't mean it's worse than nothing (:
10:00:44 <SyntaxNinja> nibro: shipments will appear in the next version, most likely, if people still think they're necessary after we implement Hackage.
10:00:46 <nibro> SyntaxNinja: Lemmih is trying to convince me to use Cabal despite the lack of shipments :)
10:00:48 <SyntaxNinja> Lemmih: sdist isn't a shipment.
10:00:56 <SyntaxNinja> nibro: why do you need shipments so badly?
10:01:06 <Lemmih> Then what is shipments?
10:01:35 <nibro> SyntaxNinja: what I want is a way to modularize my system into subpackages
10:01:37 <SyntaxNinja> Lemmih: a way to define multiple ghc-packages in a single cabal package, or something. there isn't yet a proposal with details.
10:02:08 --- mode: ChanServ set +o SyntaxNinja
10:02:13 <nibro> SyntaxNinja: I don't know much about hackage, but I suppose it could solve the problem
10:02:44 --- mode: SyntaxNinja set -o nibro
10:02:53 <Lemmih> Can't you just use a new .cabal file for each project? Or am I missing something here?
10:03:13 <SyntaxNinja> Lemmih: yeah, he wants to be able to explicitly relate them, and maybe just write one .cabal file.
10:03:22 <vegai> hmm
10:03:46 <vegai> is it easy to extend cabal's Setup.hs to run tests after a build?
10:03:50 <SyntaxNinja> nibro: I haven't heard people clamoring for shipments; cabal is already _way_ better than just rolling your own makefiles. it's not as though a shipment concept exists outside of cabal
10:04:33 <nibro> My setup is this: I have a webserver-like app. that contains what I like to think about as several packages: one with cgi support, one with http support, one with my own programming model, and then the app itself
10:05:08 <nibro> the two first don't depend on anything (except standard libs), the third depends on the two first and the last on all the previous
10:06:25 <nibro> by making each a package of its own, I impose a distinct separation on them
10:07:01 <nibro> how would you suggest I do this with cabal/hackage?
10:07:35 <SyntaxNinja> nibro: I would say go ahead and package them as separate cabal packages
10:07:50 <SyntaxNinja> we're working on support for saying something like "cabal-get install foo" and it'll download foo and its dependencies
10:08:04 <SyntaxNinja> hackage is the back-end for that, which will be a database of packages and their dependencies
10:08:12 <SyntaxNinja> and it's not quite done yet, but it's getting there.
10:08:22 <SyntaxNinja> it's not as though not using cabal will make your life easier :)
10:08:52 <nibro> I suppose that would work alright, my only gripe then would be that the sub-packages have no real value outside of the whole
10:09:11 <SyntaxNinja> nibro: then why do you want to make them separate packages?
10:09:31 <nibro> SyntaxNinja: I know, I really love cabal and how it simplifies things
10:09:42 <Philippa_> nibro: perhaps somebody else would use them? It also keeps them separate as patch targets
10:09:46 <nibro> SyntaxNinja: to get the element on separation
10:09:48 <TFK> OK, Hello, world! wokrs :-P
10:09:52 <nibro> s\on\of
10:10:42 <Philippa_> TFK: console or CGI?
10:10:51 <nibro> Philippa_: well, if I would keep them in one single package I wouldn't expose them, they're basically internals of the system
10:10:59 <SyntaxNinja> vegai: I'm afraid not at the moment :( there's a hook to add a test function, but there's no command to actually run it; that's a bug.
10:11:04 <Philippa_> if the latter, try "Hello, <insert name here>!" as the next thing?
10:11:11 <TFK> Console :-/
10:11:20 <vegai> SyntaxNinja: so I can expect such a feature in the future? That's good enough
10:11:23 <Philippa_> OK, go do the CGI and if necessary sort out a server to test it on
10:11:27 <TFK> But it means GHC is installed properly :-)
10:11:28 <Philippa_> shouldn't take long, the CGI's not hard
10:11:31 <Philippa_> heh
10:11:36 <nibro> too bad dons is asleep, he has something similar in hs-plugins
10:11:49 <TFK> Yup. I'd have to install Apache or something :-/
10:12:01 <SyntaxNinja> vegai: absolutely.
10:12:19 <SyntaxNinja> vegai: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution.Simple.html#t%3AUserHooks
10:12:55 <SyntaxNinja> check out the UserHooks, they define a function "runTests" that you can add to your setup.hs file. and the intent was to run that function when someone ran ./setup tests, but *someone* forgot to add the command-line argument to actually run it
10:13:19 <vegai> heh, ok
10:14:28 <SyntaxNinja> I could do that in like a half hour... I should make a new release of cabal
10:15:01 <shapr> What's the url of the Haskell ide project at chalmers? I can't remember.
10:16:10 <Lemmih> haste.dyndns.org:8080
10:16:30 <shapr> aha
10:17:29 <shapr> nibro: are you related to Johan Broberg on the Haste project?
10:17:50 <nibro> shapr: not that I know of
10:17:55 <shapr> ah, ok
10:17:59 <SyntaxNinja> nibro: cabal actually works pretty well, I installed like 5-6 packages with it yesterday which would have been a pain without it
10:18:29 <SyntaxNinja> nibro: the intent was to get a working system that does what it does well, not to implement everything we could think of, so there are things we'd like to have, but cabal is a foundation to build on
10:18:45 <TFK> " We have not released the editor yet..." <--- how did they get the screenshots, then?
10:18:59 <shapr> TFK: They wrote the editor.
10:19:21 <TFK> Yes.
10:19:55 <shapr> Doesn't it mean they wrote the editor, but it's not available for public consumption yet?
10:19:57 <Philippa_> I haven't released the version of Flippi sitting on my GD
10:20:00 <Philippa_> *HD
10:20:09 <Philippa_> you can bet your arse I've run more recent versions than the last release though
10:20:13 <shapr> Philippa_: hey want to write up Flippi for TMR2?
10:20:18 <nibro> SyntaxNinja: I'm in no way a disbeliever, Cabal is the future afaic =)
10:21:05 <TFK> shapr, maybe it does!
10:21:11 <musasabi> Has anyone done an auto-op module for lambdabot?
10:21:20 <nibro> SyntaxNinja: and you've convinced me to use it already
10:21:32 <Philippa_> shapr: I've enough damn writing to not get on with
10:21:36 <shapr> hah
10:21:41 <stepcutHM> musasabi: can't the chanserv do that better ?
10:21:47 <Philippa_> also, I thought wouter was (ab)using it for AG pimping purposes?
10:22:01 <shapr> Good point.
10:22:01 <musasabi> stepcutHM: no chanservs everywhere.
10:22:04 <TFK> Can I still get the code? There seem to be no pointers to it.
10:22:20 <Philippa_> TFK: for Flippi? Google is your friend
10:22:26 <nibro> SyntaxNinja: so I just screened out my Makefile and configure, tidied up my .cabal, and had a working system in the time it took us to have this discussion =)
10:22:40 <TFK> Haste, actually.
10:23:17 <TFK> Heh, the Wiki clone, incidentally :-)
10:23:17 <stepcutHM> musasabi: why would you be anywhere but freenode :p
10:24:12 <shapr> musasabi: I haven't heard of an auto-op module before.
10:24:33 <nibro> SyntaxNinja: ... except it only handles one single package of course
10:24:38 <shapr> y0 pesco
10:24:44 <shapr> pesco: want to write for TMR2?
10:24:45 <CosmicRay> hello mr. regex
10:24:52 <pesco> shapr: Yes!
10:24:56 <shapr> yay!
10:24:56 <musasabi> ok.
10:25:17 <CosmicRay> shapr: when's the deadline, and do I have to learn tex?
10:25:21 <shapr> so, who else can I unsafeCoerce into writing for TMR2?
10:25:41 <shapr> CosmicRay: you need to have your stuff ready in the two weeks, and no.
10:25:55 <shapr> Just put it up on the authors wiki. (which is not up yet :-/ )
10:26:07 <pesco> musasabi: After some thought about our discussion about packages and versioning two weeks ago, I have come to agree with you.
10:26:47 <TFK> So no online code for Haste?
10:26:57 <shapr> TFK: I doubt it.
10:27:12 <pesco> "online code"?
10:27:22 <TFK> CVS/SVN/Darcs/whatever.
10:27:27 <CosmicRay> shapr:  you could possibly unsafeCoerce me into writing something about MissingPy.
10:27:29 <nibro> SyntaxNinja: I still want the 'uninstall' cmd in cabal though, I can't rely on an external packaging system
10:28:18 <shapr> CosmicRay: I like it!
10:28:32 <CosmicRay> shapr: so long as you remember that the results of unsafe I/O can be unpredictable and volatile :-)
10:28:55 <Heffalump> I thought cabal has uninstall?
10:29:10 <Philippa_> CosmicRay: not to mention really itching?
10:29:14 <Lemmih> shapr: How's it going?
10:29:24 <shapr> Lemmih: The weather is here, I wish I were beautiful.
10:29:45 * shapr misquotes Jimmy Buffet
10:29:49 <xerox> Ahah
10:29:50 <SamB> shapr: did you get my email?
10:30:02 <shapr> SamB: yes!
10:30:13 <CosmicRay> Philippa_: heh
10:30:30 <pesco> musasabi: While it is unecessary to expand the language for that, I believe it is nonetheless important to mark in the source which version of a module's interface an import refers to.
10:30:55 <Lemmih> shapr: And what about your server and opportunities for executing CGI programs?
10:31:02 <CosmicRay> shapr:  if I don't use latex, what format do you want the submission in?
10:31:21 <shapr> CosmicRay: paper instead of plastic?
10:31:37 <shapr> wiki format actually.
10:31:41 <CosmicRay> oh, snail mail, inventive.
10:31:46 <shapr> haha
10:31:49 <pesco> Yeah, I'm making a paper submission!
10:32:05 * pesco dances around.
10:32:08 <CosmicRay> heh
10:32:16 <CosmicRay> pesco: you are seeming almost, well, shapr today! :-)
10:32:37 <pesco> CosmicRay: He's having an influence on me, surely.
10:32:40 * shapr laughs
10:32:54 <pesco> shapr: Hey, you just became an adjective!
10:33:02 <shapr> whoa nifty!
10:33:03 <CosmicRay> pesco: yes, well most of that is safe.  earlier he was having an influence on JaffaCake.  The results of that are yet to be seen :-)
10:33:18 <SamB> shapr: so when will it be set up?
10:33:19 * pesco raises an eyebrow.
10:33:25 <shapr> SamB: um, very soon =)
10:33:38 <shapr> I was having an influence on JaffaCake?
10:33:41 <shapr> What did I do?
10:33:48 * SamB says after he looks at his twistd.log
10:34:06 <SamB> shapr: nice
10:34:06 <CosmicRay> shapr: you make IRCing fun, so he hangs out here explaining thunks to me instead of coding :-)
10:34:30 <pesco> I think Cabal should include a constructor for the do Whatever The Fuck you want license.
10:34:44 <pesco> WTFL
10:34:44 <shapr> It's everybody here that makes IRC'ing fun.
10:34:49 * CosmicRay pretends to act surprised at pesco
10:34:50 <SamB> pesco: isn't that BSD3?
10:34:56 <shapr> pesco: oh that's a cool name
10:35:08 <xerox> MIT licence?
10:35:11 <SyntaxNinja> nibro: yeah, an inistall command would be good
10:35:17 <SyntaxNinja> nibro: glad it worked easily for you :)
10:35:41 <shapr> Lemmih: ok, I *think* binaries that end in .cgi should work from ~/public_html now
10:35:41 * CosmicRay decides to go back to school to finish his CS degree
10:35:45 <shapr> Lemmih: can you try it?
10:35:51 <musasabi> pesco: that is true, but there is no really good way to do that.
10:36:03 <musasabi> pesco: as programmers are quite lazy.
10:36:16 <pesco> xerox, SamB: Well, those still have text. As I see it, the Do Whatever The Fuck You Want License has no text (but the name).
10:36:29 <CosmicRay> pesco: in other words, public domain?
10:36:32 <pesco> musasabi: Of course they should not be forced.
10:36:33 <shapr> The name is the text?
10:36:55 <shapr> Wow, a license combinator.
10:36:58 <CosmicRay> haha
10:37:08 * CosmicRay calls the GPL monad
10:37:12 <SamB> I guess WTFL (NT) isn't a valid constructor name...
10:37:18 <pesco> shapr: Well, I think it has no _significant_ text but the name.
10:37:42 <CosmicRay> pesco: http://quux.org/devel/missingh/html/MissingH.Regex.Pesco.html
10:37:47 <CosmicRay> pesco: you're in debian now :-)
10:37:52 <pesco> Woohoo. :)
10:37:57 <mflux> hmm.. that'd be cool.. licenses enforced by the type system!
10:38:01 <CosmicRay> mflux: heh
10:38:19 <CosmicRay> mflux: please tell me we get a fatal error if you try to combine GPL with Larry McVoy :-)
10:38:36 <pesco> Who's Larry McVoy?!
10:38:52 <CosmicRay> pesco: annoying president of bitmover, who makes bitkeeper
10:39:01 <Oejet> Whoa!  148 people. :-)
10:39:10 <pesco> CosmicRay: How's he annoying?
10:39:12 <CosmicRay> pesco: who, among other things, revoked the free bitkeeper license from several debian people that were involved with arch
10:39:17 <SamB> mflux: it wouldn't work very well, the type system is (thankfully) not powerful enough to encode licenses in a comprehensible way
10:39:23 <shapr> Lemmih: ok, maybe it doesn't work, lemme try something else.
10:39:40 <pesco> CosmicRay: Wow, cool! Battle of the Licensors.
10:39:42 <CosmicRay> pesco: his gifts come bearing many strings, some of them not immediately visible.
10:40:23 <SamB> is that way Linus is looking at other VCSes?
10:40:39 <CosmicRay> SamB: no, that's only because of the most recent of Larry's little adventures
10:40:55 <shapr> It would be cool if he picks darcs. Unlikely, but cool.
10:41:03 <CosmicRay> SamB: larry has decided to terminate the free bitkeeper licenses altogether because some contractor under osdl's employ happens to be reverse-engineering it.
10:41:06 <dustin`> I was just going to say that
10:41:09 <SamB> where can I read about The Adventures of Larry McVoy?
10:41:11 <TFK> It's already too slow, apparently (darcs).
10:41:19 <CosmicRay> shapr: he's already ruled it out on performance grounds
10:41:36 * dustin` is waiting for GNU/hOp
10:41:40 <shapr> Did Linus say that?
10:41:41 <SamB> how often do you import the linux kernel to darcs?
10:41:52 <TFK> Larry said Linus said that :-)
10:41:57 <shapr> too bad
10:42:07 <Igloo> It doesn't really matter who said it, it's true  :-)
10:42:16 <CosmicRay> SamB: google should turn up plenty
10:42:22 <Oejet> No loss, the linux kernel is already too slow too.
10:42:27 <CosmicRay> try http://www.kerneltraffic.org/kernel-traffic/quotes/Larry_McVoy.html
10:42:42 <CosmicRay> but keep in mind that most of what larry says it at least 90 degrees away from the truth
10:42:44 <SamB> lambdabot: google The Adventures of Larry McVoy
10:42:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
10:42:54 <TFK> SamB, http://kerneltrap.org/node/4966
10:42:57 <SamB> why can't lambabot google?
10:43:05 <shapr> He's not a very smart bot yet.
10:43:06 <CosmicRay> @google the adventures of larry mcvoy
10:43:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "google", try "lambdabot: @listcommands"
10:43:14 <wilx> SamB, it tells you why :)
10:43:55 <shapr> SamB: you should write a plugin!
10:44:08 <SamB> hmm, so the way I tried wouldn't have worked at all...
10:45:49 <SamB> @source
10:45:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "source", try "lambdabot: @listcommands"
10:45:52 <SyntaxNinja> CosmicRay: be careful talking about l.mcV he might sue you
10:45:58 <sorje> @version
10:45:58 <wilx> @version
10:45:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p164, GHC 6.4 (OpenBSD i386)
10:45:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:45:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p164, GHC 6.4 (OpenBSD i386)
10:45:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:46:01 <SyntaxNinja> CosmicRay: he threatened to sue me for saying that people shouldn't use it
10:46:01 <sorje> heh
10:46:13 <CosmicRay> SyntaxNinja: scary thing is -- I completely believe that.
10:46:13 <SamB> hehe
10:46:26 <CosmicRay> SamB: do you get the idea yet? :-)
10:46:35 <SamB> CosmicRay: yes
10:46:49 <TFK> SamB, did you read the kerneltrap article?
10:46:57 <SamB> I need to /msg lambdabot @listcommands before trying to get lambdabot to do anything for me
10:47:00 <CosmicRay> SyntaxNinja: he's probably still pissed at me for setting up the arch repository tracking the entire history of the linux kernel from 0.01 to the present day
10:47:03 <SyntaxNinja> so linus is looking at other systems?
10:47:10 <SyntaxNinja> CosmicRay: good for you!
10:47:16 <CosmicRay> SyntaxNinja: or maybe he hasn't heard of it, in which case he's not pissed at me yet. :-)
10:47:26 <CosmicRay> SyntaxNinja: yes, but he's ruled out darcs on performance grounds
10:47:29 <SamB> TFK: not yet, no.
10:47:58 <SyntaxNinja> we need to performance-itize darcs :)
10:49:02 <dustin`> "BitKeeper allows a truly distributed system in which everybody owns their own master copy" <--- I thought this was something that darcs does?  It seems that a slow initial checkout would be not that much of a price to pay?
10:49:19 <CosmicRay> dustin`: it is if "slow initial checkout" is measured in days
10:49:23 <SyntaxNinja> dustin`: darcs and arch both do that, but darcs is slow for other reasons
10:49:30 <SyntaxNinja> CosmicRay: owch
10:49:32 <dustin`> oh, okay
10:49:37 <mflux> then there's svk that uses subversion backend
10:49:41 <SyntaxNinja> CosmicRay: so are you still tracking the kernel in arch? opr is someone?
10:49:48 <SamB> SyntaxNinja: other reasons?
10:49:49 <mflux> it's written in perl, though
10:50:02 <SyntaxNinja> SamB: in that, the slowness doesn't have to do with the distributed nature per-say
10:50:11 <CosmicRay> but I think that coming from a bk background, he will find the difficulty to pull copies of the tree "as it existed" on a specific date to be annoying
10:50:11 <mflux> I imagine before solving the scalability issues of darcs, it's not worth the time using it in large scale projects..
10:50:20 <TFK> Linus said to not mention Subversion.
10:50:22 <dustin`> has anyone attempted to formalize the patch theory in darcs?
10:50:25 <CosmicRay> SyntaxNinja: no, I gave up maintaining it about 6 months ago, but it's still up on arch.debian.org
10:50:29 <TFK> He did point at monotone...
10:50:30 <shapr> Lemmih: yay! I got it!
10:50:37 <SamB> fortunately, most projects are not huge
10:50:38 <CosmicRay> TFK: svk could have some promise
10:50:45 <CosmicRay> TFK: I think arch could do
10:50:49 <shapr> Lemmih: executables in ~/public_html/cgi-bin/
10:50:51 <integral> what's the issue with svk being in perl, mflux?
10:50:54 <CosmicRay> in fact, a haskell front-end to arch could be quite doable.
10:50:57 <TFK> We shall wait and see, I suppose.
10:51:17 <TFK> How many lines of Haskell code does Linus have behind him? :-P
10:51:22 <mflux> integral, well, I would personally like more a version that would only depend on system's native libraries
10:51:40 <CosmicRay> I think that arch is a well-designed system on the backend.
10:51:46 <mflux> subversion is little more than slightly better cvs, but the set of libraries and interfaces it provides can greatly shorten the time to develop a real configuration management system
10:51:50 <CosmicRay> I also think that tla, the arch client, sucks in many ways.
10:51:55 <Lemmih> shapr: Now I get a 403, Forbidden error .
10:51:58 <shapr> TFK: more importantly, How many lines of Haskell code does Linus have in front of him?
10:52:05 <integral> mflux: hmm, well rather than distributing just your executable, you just distribute a perl binary + script,  which isn't much of a space penalty
10:52:07 <CosmicRay> it seems that baz has dramatically improved upon it, but baz is largely undocumented so I don't know
10:52:14 <mflux> integral, plus all its dependencies?
10:52:14 <shapr> Lemmih: check your privs
10:52:27 <integral> mflux: what dependencies?   perl depends on very little
10:52:27 <shapr> Lemmih: cgi-bin must be chmod ugo+rx
10:52:33 <TFK> shapr, heh, good point
10:52:40 <mflux> integral, and the perl installations between systems vary, not everybody has debian, or linux
10:52:42 <integral> mflux: Just libc and libmath iirc
10:52:50 <mflux> integral, perl libraries?
10:53:14 <integral> it's trivial to distribute them with your app.   Rather than using ld to link them into a binary,  you use perl tools such as par to link them together
10:53:15 <mflux> I don't like arch's dictated three level hierarchy
10:53:39 <CosmicRay> mflux: I didn't at first, but it works quite well, actually.
10:53:50 <CosmicRay> mflux: the problem is that tla requires me to type too much of it too often
10:53:56 <CosmicRay> mflux: baz supposedly is much better about that
10:54:01 <mflux> baz?
10:54:11 <Lemmih> shapr: Still forbidden.
10:54:15 <CosmicRay> mflux: my standard joke about tla is that it gives everyone cts (carpal tunnel syndrome)
10:54:33 <CosmicRay> mflux: http://bazaar.canonical.com/index.html
10:54:50 <shapr> Lemmih: http://www.scannedinavian.org/~lemmih/cgi-bin/hackage/dist/build/hackage
10:55:02 <mflux> baz seems nice
10:55:14 <mflux> judging from the 10 seconds I've spent evaluating it
10:55:22 <SyntaxNinja> shapr: so does this mean I can push to lemmih's directory? or to my own directory?
10:55:26 <Lemmih> Oh. I'm not allowed to use symlinks ):
10:55:44 <SyntaxNinja> shapr: by push I mean 'install hackage', not 'darcs push'
10:55:45 <shapr> SyntaxNinja: if he gives you privs, sure.
10:55:47 <shapr> oh
10:56:08 <SyntaxNinja> is someone tracking the high-water mark for this channel?
10:56:24 <shapr> I saw 153 earlier today.
10:56:39 <mflux> and apparently is native ;)
10:57:16 <shapr> SyntaxNinja: do you mean you want to get info into the postgresql database? or what?
10:57:17 * SyntaxNinja sees sirDinosour on #darcs
10:57:21 <SyntaxNinja> it's all downhill from here
10:57:37 <SyntaxNinja> shapr: when I'm hacking on hackage, I want to try it out, that's all.
10:57:51 <CosmicRay> oh shit, I see what you mean
10:57:59 <shapr> In that case, I'll set you up with a database.
10:58:03 <CosmicRay> trying to telephone david at cornell to ask him a question about his personal politics?
10:58:04 <CosmicRay> wtf?
10:58:21 <TNKS> hello everybody, I'm getting a warning from ghc that I'm not sure about.
10:59:48 <shapr> TFK: Is that your blog with Conway and SPOJ?
11:00:07 <TNKS> "map (snd.properFraction) limits" gives me the warning: "Defaulting the following constraint(s) to type `Integer' `Integral b' arising from use of `properFraction' ..."
11:00:08 <TFK> Erm, yes.
11:00:15 <TNKS> and limits is of type [Double]
11:00:21 <shapr> TFK: you need more content ;-)
11:00:23 <TFK> How much did that code suck?
11:00:30 <TFK> No d'uh ;-)
11:01:13 * shapr grins
11:01:34 <shapr> This is pot calling kettle...
11:01:39 <shapr> come in kettle!
11:01:40 <TFK> It'll come, with time, when it accumulates enough cruft to pass for "engaging writing" ;-)
11:01:45 <TFK> hehe
11:02:50 <TFK> Speaking of which, your n00b column didn't appear in the first issue of The Monad Reader!
11:02:59 <shapr> :-(
11:03:02 <shapr> It's true.
11:03:04 <shapr> I ran out of time.
11:03:11 <shapr> Hopefully it will be in the second issue.
11:03:44 * ibid is still missing a good topic to write about
11:04:22 <shapr> ibid: what about how QuickCheck relates to Z specs?
11:05:07 <ibid> that's a hard one
11:05:19 <ibid> now, about qc and algebraic specs, that's easier
11:05:36 <shapr> There's a section of the QuickCheckST paper that mention Z specs in passing.
11:05:48 <shapr> algebraic specs would be cool too.
11:06:00 <shapr> ibid: You know this sort of stuff, so I think you'd be the best person to do it.
11:06:19 <ibid> you know my formal methods course project was about z and haskell :)
11:06:27 <shapr> Yes I do :-)
11:06:42 <ibid> what about me don't you know?:)
11:06:57 <shapr> I just remember stuff that you say on #haskell.
11:07:02 <shapr> How hard is that? =)
11:07:42 <ibid> that somebody bothers to do so is flattering :)
11:07:43 <CosmicRay> shapr: http://sequence.complete.org/node/50, at the end of the last comment, "p.s. btw, what is with the 2nd issue of MR?" :-)
11:07:51 <shapr> I tend to remember what people say, whether in person or online via irc or blog.
11:08:04 <CosmicRay> shapr: me too.  my problem is that I forget who said it.
11:09:01 <shapr> ibid: It is my philosophy that smart people are interesting, and what they say is worth considering.
11:15:22 <TFK> http://www.poignantguide.net/ruby/ <--- here's what Haskell needs :D maybe more code and less chat, but still ;-)
11:15:54 <CosmicRay> TFK: or something like diveintopython
11:16:09 <TFK> Yup. I've read Dive into Python on a Palm :-)
11:16:26 <TFK> Actually, even Python docs could be better.
11:18:51 <TFK> Although, he does say to speak out loud each of the code samples, and I just couldn't do it :-/
11:19:06 <shapr> wha?
11:19:16 <shapr> hm, neat idea
11:19:26 <shapr> I bet that really works.
11:19:44 <shapr> That's an excellent way to study now that I think about it.
11:20:15 <TFK> Yes, unless your language has Syntax Bizarro.
11:20:30 <CosmicRay> TFK: such as brainfuck?
11:21:06 <TFK> Brainfuck will have no "learn to program" books about it, if there's any sanity left in the world.
11:21:14 <CosmicRay> heh
11:21:18 <mflux> Brainfuck for Dummies
11:21:42 <CosmicRay> mflux: ahh, someone slapped a new cover on vb for dummies? :-)
11:22:40 <jlouis> I think most programs done in brainfuck is actually done in a simple toy language and then compiled
11:22:44 <jlouis> same goes for whitespace
11:22:48 <jlouis> maybe unlambda too
11:24:03 <shapr> SyntaxNinja: you know how to use PostgreSQL? I've done createuser for you, and you can create your own databases. Is that sufficient?
11:24:11 <shapr> Lemmih: what about you?
11:24:42 <Lemmih> Great.
11:24:57 <Lemmih> I'll look at it later.
11:25:05 <shapr> ok
11:25:32 <shapr> hi Dark3ness, looking for Haskell info?
11:26:53 <Dark3ness> nah im good, just thought I would drop in as I have done some haskell at uni recently, am actually looking for some help with assembly in other chans :P
11:27:07 <Dark3ness> no one seems to be around though :(
11:27:08 <shapr> We can help you assemble your brain.
11:27:12 <basti_> Dark3ness: better stick to haskell
11:27:15 <basti_> =)
11:27:17 <basti_> -g-
11:27:38 <shapr> I reassembled my brain using monadic continuation passing style, and now I can see five seconds into the future!
11:28:09 <esap> continuation passing doesn't allow you to actually see into the future. It just allows you to refer to it.
11:29:02 <shapr> Finally, I've seen the future! It looks like a thunk.
11:29:16 <esap> exactly.
11:29:23 <CosmicRay> hah
11:31:41 <esap> But double negation is strange: consider the type of lexer for happy-generated lexers: >lexer :: (LToken -> ParseM a) -> ParseM a. It's really just a way of choosing one possible future from a collection of futures indexed by the tokens.
11:36:46 <nibro> (lengthy) Cabal question again, setup is the following:
11:36:53 <nibro> I have a package haskell-src-exts that defines parsing and ppr-ing haskell source code with extensions
11:37:04 <nibro> I have a second package harp that defines the model behind HaRP, i.e. haskell regular patterns
11:37:16 <nibro> Finally I have an executable preprocessor trhsx that desugars regular patterns, and that adds an import for the HaRP model
11:37:31 <nibro> Clearly the preprocessor belongs with harp and not with haskell-src-exts, it just depends on the former
11:37:53 <nibro> However, if I in cabal put the executable in with the harp package and state that it depends on haskell-src-exts, the whole harp package gets the dependency too, which is not what I want
11:38:30 <nibro> any ideas on how I should do this to get it Right (TM)?
11:39:32 <SamB> harp-dev?
11:39:48 <nibro> SamB: come again?
11:41:05 <SamB> a package named harp-dev which would contain the preprocessor? no clue whether that is good form or not...
11:42:04 <nibro> aha, but then the package would contain no code, which means its not really a package at all...? Can you do that in cabal? (runs off to check)
11:44:53 <Lemmih> Cabal = Common Architecture for Building Applications and Libraries.
11:45:59 <Philippa_> nibro: is the preprocessor a binary rather than source then?
11:47:02 <nibro> Philippa_: aye
11:49:00 <nibro> it worked alright, but now I'm back where I always seem to end up: I want them together, not in two separate pieces...
11:49:11 <nibro> Lemmih: ah =)
11:52:37 * nibro pokes SyntaxNinja to see if he's awake
11:55:23 * shapr throws lambdas
11:56:08 * nibro ducks
11:56:18 * TFK is not afraid!
11:56:24 * Philippa_ watches as shapr gets hit by his own lambdarangs
11:56:35 <vikasgp> if I have something like f n (xs) = ... f (n-1) n:xs ,
11:56:47 <shapr> where did @join go?
11:57:07 <shapr> for that matter, where did @listcommands go?
11:57:23 <Philippa_> @join makes me think of SQL
11:57:24 <vikasgp> is it guaranteed that the two lists in the successive calls share structure?
11:57:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "join", try "lambdabot: @listcommands"
11:57:26 <Igloo> vikasgp: Do you mean (n:xs)?
11:57:36 <shapr> @listcommands
11:57:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "listcommands", try "lambdabot: @listcommands"
11:57:50 <vikasgp> yeah
11:57:54 <shapr> strange
11:58:07 <nibro> lambdabot: @listcommands
11:58:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "listcommands", try "lambdabot: @listcommands"
11:58:08 <Igloo> Ermm, they will do, but you can't tell anyway
11:59:03 <vikasgp> I'm thinking about this from an efficiency POV
11:59:17 <Igloo> Ah, right. Then yes
11:59:42 <TheHunter> i guess, that's my fault:
11:59:45 <TheHunter> <TheHunter> @dynamic-unload system
11:59:45 <TheHunter> -lambdabot- unknown module
11:59:58 <shapr> :-/
12:00:17 <shapr> doesn't lambdabot automatically restart if it dies?
12:00:37 <shapr> lambdabot: @reconnect smoking
12:00:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "reconnect", try "lambdabot: @listcommands"
12:00:53 <shapr> lambdabot: @quit smoking
12:00:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "quit", try "lambdabot: @listcommands"
12:00:57 <shapr> !
12:01:11 <theorbtwo> It's not dead, though, just lombodimized.
12:01:28 <hellish> ghc(i) doesn't want to link to HaXml for some reason. It reports "Could not find module `Text.XML.HaXml.Html.Parse'". I'm using -package HaXml
12:02:02 <TheHunter> oh, i'm sorry folks.
12:02:18 <jlouis> TheHunter: ah, we all make errors. As long as we can fix them again
12:02:29 <jlouis> I have some pretty ones I think ;)
12:03:04 <shapr> The heatsink died on the previous box while lambdabot was running. That was the most spectacular death lambdabot has seen yet.
12:03:18 <TheHunter> i guess i have fixed that bug, though.
12:04:13 <TheHunter> nope, weird...
12:04:42 <shapr> Since the box was colocated elsewhere, the system stayed on for several days with no cpu fan. I still have the heatsink. Where it touched the CPU it has black melted bits of the cpu covering, and it fades from black out to a light brown on the top of the heatsink.
12:05:25 <shapr> Unsurprisingly, the motherboard and some of the PCI cards also died.
12:06:14 <shapr> right, it's time for $work !
12:06:31 <TheHunter> perl?
12:07:00 <theorbtwo> Photo, shapr?
12:07:09 <shapr> theorbtwo: good idea
12:07:29 <shapr> Next time I get access to a digicam.
12:07:58 <vikasgp> shapr, you write any perl code now?
12:08:06 <shapr> vikasgp: sort of...
12:08:44 <shapr> vikasgp: check out the top article on http://lambda-the-ultimate.org/
12:08:45 <vikasgp> good luck :)
12:09:05 <shapr> TheHunter: Python is today's work.
12:09:32 <vikasgp> shapr: that's why I asked
12:10:25 <shapr> It's interesting. Perl's viewpoint is very different from Python, Haskell, Java, VB, etc.
12:11:16 * theorbtwo wonders...
12:11:22 <vikasgp> what's the viewpoint?
12:11:26 <theorbtwo> ...do you think it's better, worse, or simply different?
12:11:31 <shapr> On the one side it directly builds on knowledge of all the single-purpose unix command-line tools. On the other hand, it's gaining interesting features as it evolves.
12:13:06 <shapr> theorbtwo: Perl goes against my general principle of regularity, so at first glance I would generalize into saying it's worse for *me*. But I don't have enough data until I've really used Perl.
12:13:16 * theorbtwo nods.
12:13:17 <araujo> What i don't like is that Perl code can very easily become a big mess
12:13:27 <theorbtwo> All code can very easily become a big mess.
12:13:52 <shapr> Yeah, bad Haskell code is no better than bad Perl code.
12:13:52 <araujo> I think you are wrong.
12:14:02 <CosmicRay> though having a perl implementation written in Haskell has clear benefits for haskellers too
12:14:06 <vikasgp> yeah, Perl doesn't fall into any neat category
12:14:07 <araujo> Brainfuck is one example.
12:14:08 <shapr> CosmicRay: definitely!
12:14:28 <theorbtwo> Araujo, do you mean it's impossible for bf code to become a big mess?
12:14:34 <CosmicRay> I don't see myself ever going back to perl, unless there are significant changes with perl6 (I guess there are, the question is whether they're in areas I'm interested in having change)
12:14:39 <shapr> Even if I don't end up using Perl for my daily scripting tasks, I very much want to use Pugs to script a Zope clone in Haskell.
12:14:45 <CosmicRay> perlers probably don't see themselves ever using haskell for daily work
12:14:53 <TFK> http://www.python.org/doc/Humor.html#zen <--- Python's philosophy :-D
12:15:04 <araujo> theorbtwo, no, but that the language plays an important role to understading of the code
12:15:12 <CosmicRay> otoh, if haskell's main problem is lack of available libraries, this could be a huge win
12:15:21 <shapr> Yeah, good point.
12:15:33 <shapr> We can just borrow CPAN.
12:15:35 <TFK> Someone's gotta write them, then ;-)
12:15:36 <CosmicRay> and one huge problem with perl is the annoying complexity of extending the interpreter (links to C libs or whatnot)
12:15:44 <CosmicRay> so they can gain a lot from haskell automatically, too
12:15:53 <shapr> Yeah, pugs is so much fun to work with.
12:16:04 <metaperl_> CosmicRay, Inline::C changed that I believe
12:16:08 <CosmicRay> shapr: well it will probably not be *that* easy (things like laziness, purity, typing, etc.)  but surely easier than FFIing everything.
12:16:10 <shapr> You can write a new builtin in about a minute.
12:16:39 <theorbtwo> The plan at this point is to use haskell as a start until we can self-host, so I'm not sure that pugs will be such a huge help to the haskell community, other then by being a good introduction.
12:16:43 <TFK> Actually, this is a PEP: http://www.python.org/peps/pep-0020.html
12:17:00 <CosmicRay> metaperl: ah, had not seen that.  I looked at the perl extending&embedding docs before I wrote MissingPy, deciding whether to make an interface to PYthon or to Perl, from Haskell (this is calling *to* perl or python code)
12:17:02 <basti_> btw, in make yi, with ghc-6.3 i get:
12:17:03 <basti_> CWString.hsc:69:0:
12:17:03 <basti_>     Warning: Module `GHC.Exts' is imported, but nothing from it is used
12:17:04 <basti_>              (except perhaps instances visible in `GHC.Exts')
12:17:08 <basti_> which i would correct manually
12:17:16 <CosmicRay> metaperl: perhaps it's just the docs, but I couldn't really figure out how to do it with perl
12:17:54 <theorbtwo> The difficulty of extending perl5 was one of the major reasons for starting perl6, but it's not /that/ bad.
12:17:57 <CosmicRay> theorbtwo: even if the perl community forks away from pugs, it is possible that autrijus could continue maintaining it, tracking the canonical implementation
12:17:58 <shapr> I like the fact that Perl has a bunch of sublanguages inside the one language. That's DSL-land right there. I'm sure I can learn good stuff about implementing DSLs from studying how Perl integrates the pieces.
12:18:30 <theorbtwo> Aye, shapr.
12:19:08 <CosmicRay> theorbtwo: perhaps it is just that the docs were written at people writing perl modules and desiring to call C, rather than people wanting to use C to call into perl... in any case, I found docs on memory management to be the most sore point
12:19:22 <CosmicRay> it was my general impression that garbage collection in perl works by black magic :-)
12:19:27 <theorbtwo> Embedding is somewhat underdocumented.
12:19:41 <theorbtwo> Yeah, MM in perl5 is complicated.
12:19:55 <theorbtwo> The problem is that there is too much black magic that you're expected to know.
12:20:01 <CosmicRay> ah
12:20:14 <CosmicRay> python's memory management is just black :-)
12:20:24 <theorbtwo> Non-refcounding MM has more black magic, I think, but unless you're looking at the fine details of the MM, you shouldn't care, it's all done for you.
12:20:28 <CosmicRay> as in, complex, but it's documented
12:20:34 <theorbtwo> Refcounting means that everybody has to care.
12:20:34 <shapr> In any case, whatever my end opinion of perl{5,6} becomes, I'm having fun hacking on Pugs and hanging out on #perl6.
12:20:55 <theorbtwo> I think most people should be able to find something to like in p6.
12:20:58 <CosmicRay> theorbtwo: exactly.   Part of the definition of every C API call into Python is how it handles refcounting.
12:21:24 <CosmicRay> theorbtwo: which makes it annoying to track from outside, but otoh the information to make it work right is right there.
12:21:54 <theorbtwo> Hm, I can see how that'd be useful.
12:22:22 <CosmicRay> it incidentally meshed pretty nicely with FFI in haskell; I could set Py_DECREF as the thing to call when haskell GC's a Python object
12:22:39 <TFK> Is there any CGI+Haskell tutorial? Or am I googling it wrong?
12:22:48 <CosmicRay> tfk: google for wash haskell
12:23:01 <CosmicRay> there is no one canonical cgi implemetnation for haskell
12:23:20 <CosmicRay> there is a more traditional library here http://www.janweb.net/laitenbe/haskell/CGI/
12:23:22 <TFK> Coo, thanks
12:23:54 <TFK> Ah, that must be Network.CGI
12:24:11 * CosmicRay blinks
12:24:14 <CosmicRay> I never noticed that there.
12:24:17 <CosmicRay> is it new?
12:24:57 <TFK> Pretty old, apparently. There are docs from '97, but I figured those were too old.
12:25:10 <TFK> Or maybe I'm just speaking out of the wrong hole ;-)
12:25:22 <smott> is there any haskell module that implements decent client-side www support (something like libwww)? and by this i mean mostly cookies and POST requests
12:25:48 <shapr> smott: yes, HTTP.hs and friends are way spiffy.
12:26:01 <shapr> I think bringert is the maintainer of those at the moment.
12:26:30 <basti_> i'm getting "Failed to load interface:" when i try to import something from Config.hs
12:26:49 <basti_> i tried recompiling yi completely (including .hi), but it didnt help
12:27:02 <smott> shapr: i'll check it out, thanks
12:27:02 <basti_> also, trying to use another version of ghc didnt help
12:27:11 <shapr> basti_: Are you using a very recent version of hs-plugins?
12:27:41 <basti_> hmmm well i built it myself
12:27:46 <basti_> 0.9.8
12:27:50 <basti_> is that recent or not?
12:27:50 <basti_> ;)
12:27:53 <shapr> Is your hs-plugins from the last week or two?
12:28:13 <basti_> hm.
12:28:28 <basti_> downloaded yesterday.
12:28:52 <SyntaxNinja> nibro: i'm awake now
12:29:35 <shapr> basti_: from the nightlies?
12:29:58 <SyntaxNinja> nibro: in that case, what do you mean by 'the whole harp package gets the dependency too'?
12:30:32 <basti_> hmm
12:30:34 <basti_> probably not
12:30:36 <basti_> should I?
12:30:53 <shapr> yeah
12:31:01 <basti_> okay.
12:31:50 <xerox> dons, ping
12:32:32 <nibro> SyntaxNinja: I mean that a module that imports Harp.Match from the harp package is implicitly dependent on haskell-src-exts
12:33:13 <basti_> where do i find the nightly builds? http://www.cse.unsw.edu.au/~dons/hs-plugins/ < i got it from there
12:33:35 <shapr> ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots/
12:33:47 <TFK> Grrr. Guess I'll have to read YAHT anyway.
12:34:26 <basti_> wow there's one of tomorrow.
12:34:30 <SyntaxNinja> so there are 'cabal' packaegs, and GHC packages... if your preprocessor is in the 'harp' package, and it build-depends on the haskell-src-exts, then yes, in that sense, the harp package depends on the haskell-src-exts package
12:34:30 <basti_> now THAT'S nightly
12:34:35 <shapr> TFK: Flippi demonstrates a nice use of CGI in Haskell.
12:34:59 <Philippa> shapr: he's trying to write his own wiki, I imagine he doesn't want to read my code for one :-)
12:35:10 <TFK> Reading Flippi code would be cheating. Err, Philippa said it best ;-)
12:35:18 <nibro> SyntaxNinja: so how would you suggest I do it?
12:35:40 <xerox> OT: How would you make the simplest echo-server with something like netcat?
12:35:46 <shapr> oh right
12:35:57 <SyntaxNinja> nibro: what's wrong w/ the harp package depending on the src package?
12:36:02 <nibro> SyntaxNinja: it would be nice to be able to claim that the executable build-depends on something other than the whole package
12:36:13 <pesco> CosmicRay: Ah, I see you've renamed Pesco.Regex to to (MissingH.)Regex.Pesco. After hearing that's the prefered way, I'll follow that convention with the next update.
12:36:26 * basti_ autoreconf
12:36:43 <SyntaxNinja> nibro: you mean specify which modules it depends on? why?
12:36:53 <nibro> SyntaxNinja: simply that the harp (ghc) package has absolutely nothing to do with haskell-src-exts
12:37:49 <nibro> SyntaxNinja: well, there's probably a better way, but it would solve my problem
12:38:08 <SyntaxNinja> nibro: I don't think that the harp GHC package will depend on the haskell-src-exts package.
12:38:15 <Philippa> TFK: main = wrapper cgi where cgi env = {- some IO action that returns Html -}
12:38:22 <SyntaxNinja> if in the executable, you say it build-depends on the src package
12:38:38 <Philippa> env :: [(String, String)], it's a dump of the CGI environment variables and those in the querystring/post data as an association list
12:38:38 * basti_ make
12:38:57 <Philippa> Network.CGI's easy, it's Text.Html that's a bugger :-)
12:39:04 <nibro> SyntaxNinja: ?? but I cannot say in the executable that it build-depends on src if its in the harp (cabal) package...?
12:39:06 <basti_> oh where was the link to this "powered by Ph.D" graphics?
12:39:42 <nibro> SyntaxNinja: If I place the exec outside the harp (cabal) package, then harp -/-> src
12:39:44 <Philippa> mmm, haven't had Early Bird in 3 years. Too bad I'll have to wait 'til next spring for more, but hey
12:40:25 <nibro> SyntaxNinja: but if I place the exec in the harp package, then harp (ghc) --> src, since the build-depends is "global" in the cabal file
12:40:35 <theorbtwo> It's in the pugs SVN.
12:40:40 <SyntaxNinja> oh right, I see
12:41:13 <nibro> :)
12:41:42 <SyntaxNinja> yeah, it would be nicer if the ghc-package didn't depend on the harp package, but it's not much different practically speaking, right?
12:41:55 * basti_ make yi
12:42:04 <SyntaxNinja> nibro: er, I mean that the harp ghc package didn't depend on the source package
12:42:14 <SyntaxNinja> you could put the executable in a 3rd package that depends on the other two
12:42:21 <SyntaxNinja> that's probably the "most right" way to do it.'
12:42:22 <TFK> Philippa, thanks. I'll need much more knowledge to get it to work, thugh. Don't want to burdain the channel with questions, since this is strictly not something I looked up on my own yet.
12:42:38 <nibro> SyntaxNinja: but I don't think that's "right" at all!
12:42:58 <Philippa> TFK: To give an example from within that cgi, if you want the query string, you do a lookup env "QUERY_STRING"
12:43:00 <nibro> SyntaxNinja: the exec is irrelevant w/o the harp (ghc) package
12:43:25 <nibro> SyntaxNinja: and the other way around too
12:43:30 <basti_> hmm
12:43:40 <SyntaxNinja> well, dependencies are between packages, so if you want to cut back the dependencies, then you break apart the dependent parts, just like in any source code.
12:43:41 <basti_> shapr: now its a different error message.
12:43:50 <shapr> That's progress, I hope.
12:43:52 <basti_> Unable to load config file, using defaults
12:43:57 <shapr> oh, that's fine.
12:44:02 <shapr> create ~/.yi/
12:44:02 <basti_> :)
12:44:10 <basti_> i got ~/.yi/
12:44:19 <shapr> Do you have a Config.hs ?
12:44:21 <SyntaxNinja> nibro: then in a very practical sense, the harp package depends on the src package. the only issue is that ghc adds the -package flag when it's unnecessary, right?
12:44:23 <basti_> yes
12:44:27 <TFK> Hmmm. Doesn't that restrict responsiveness to the user?
12:45:17 <nibro> SyntaxNinja: that sounds about right. harp (cabal) --> src is definitely true, whereas harp (ghc) -/-> src
12:45:27 * TFK browses WASH examples
12:46:11 <CosmicRay> pesco: I don't know if it's the preferred way, I'm just using that way in my code, in case I import anyone else's regex module too
12:46:20 <CosmicRay> is anyone aware of time/date parsing code for haskell?
12:46:23 <SyntaxNinja> nibro: yeah. it's unfortunite that there's no way to separate those, but I think that if its a build-depends, then the spurrious -pcakage flag will only happen when building harp, not while building packages that depend on harp
12:46:29 <CosmicRay> something along the lines of strptime would be perfect
12:46:36 <CosmicRay> but anything better than doing it all by hand would be acceptable
12:46:51 <shapr> CosmicRay: bringert's ParseDate works well.
12:47:05 <nibro> SyntaxNinja: if that's the case then I'm prefectly happy, but I'm not so sure
12:47:15 <CosmicRay> shapr: you rock.
12:47:43 <basti_> shapr: uhm. so, what about my Config.hs?
12:47:49 <nibro> SyntaxNinja: I have a small test file that imports Harp.Match, and when I load it into ghci it loads src...
12:48:00 <SyntaxNinja> nibro: try it :) when you install harp, look at ghc-pkg's package.conf file
12:48:12 * CosmicRay imports ParseDate into MissingH immediately.
12:48:51 <pesco> CosmicRay: Igloo said that to me (Text.Regex.Pesco probably prefered to Pesco.Regex).
12:49:01 <CosmicRay> pesco: yes, that's prboably right
12:49:25 <pesco> I'd never considered that, but after thinking about it, it seems quite natural.
12:52:06 <nibro> SyntaxNinja: :( harp --> src in package.conf
12:52:23 <pesco> Well, but back to the interface version thing! I think it can be supported very easily and naturally. I can release the current version of the Regex module as Text.Regex.Pesco_1 and the next as Text.Regex.Pesco_2 where the number is incremented with every interface change (_not_ for pure implementation revisions!). Then, in each release of the package, I include Text.Regex.Pesco which reexports the latest version of the package _and_ all previous version
12:52:51 <SyntaxNinja> nibro: and that's just with a build-depends? that sucks :(
12:53:55 <nibro> SyntaxNinja: to me it sounds like the definitions are too course. How would you separately specify "real" depends from build-depends?
12:54:06 <nibro> s/course/coarse
12:54:33 <pesco> That way, to use the module, you need only know the regular name. "Text.Regex.Pesco". But that module will contain a warning pragma telling you at compile time which version you were actually using, so then you can put it in the code directly with the tremendous benefit of (theoretically) everlasting compatibility.
12:54:47 <nibro> SyntaxNinja: perhaps there should be two fields, depends and build-depends?
12:56:31 <nibro> SyntaxNinja: ... where build-depends can be specified once for each stanza, just like other-modules (which is conceptually similar)
12:56:41 <SyntaxNinja> nibro: hm. there was a lot of discussion about that actually, and I think ross paterson determined that two fields was redundant
12:57:02 <SyntaxNinja> but he doesn't like executables that depend on libraries in the same package, so he probably didn't think about that, or ignored it
12:57:05 <basti_> hmm
12:57:36 <nibro> SyntaxNinja: and ross' solution is shipments?
12:58:05 <SyntaxNinja> yeah, I think so.
12:58:14 <SyntaxNinja> but shipments haven't even really gotten any hard thought.
12:58:48 <SyntaxNinja> we wanted to keep the interface minimal so that we wouldn't be 'stuck' with supporting things that might go away eventually, so it's sometimes conservative.
13:00:55 <nibro> SyntaxNinja: probably a wise choice
13:02:58 <nibro> fwiw I think I agree with ross on this one, putting executables in with (cabal) packages makes the packages act as shipments in some cases and (ghc) packages in other
13:03:50 <nibro> if I remove my exec from the harp package and put it in a separate one everything works, except I cannot guarantee that they will be shipped together
13:04:16 <nibro> having an outer shipment entity could solve that
13:06:47 <basti_> yi-static works, but doesnt read the config file
13:06:48 <basti_> :/
13:07:11 <shapr> basti_: did you copy the demo Config.hs into your ~/.yi/ ?
13:07:19 <basti_> yes.
13:07:35 <basti_> but yi still "Unable to load config file, using defaults
13:07:38 <basti_> load: couldn't find symbol <<yi>>
13:08:13 * shapr has no clue
13:08:15 <shapr> lemme try it
13:09:12 * basti_ thinks yi doesnt find its libraries
13:09:13 <shapr> poo, I broke my hs-plugins installation
13:09:21 <basti_> its also "unable to load Yi.Main"
13:09:37 <basti_> and cant find dynamic_main
13:09:37 <shapr> basti_: my presence is desired by my Significant Other, so I won't be able to try more until later.
13:09:42 <basti_> lol
13:09:45 <basti_> -g-
13:09:52 <basti_> greetings ;)
13:16:27 <CosmicRay> shapr: thanks for the ParseDate suggestion.  It is *exactly* what I'm looking for.
13:18:26 * Philippa wonders if it'd be an idea to collect a pile of useful parsers in Parsec?
13:18:47 <Philippa> things like URIs, email addresses, that kind of thing
13:19:54 <theorbtwo> Hm, anybody know of a good intro to Haskell for mathematicians?
13:20:30 <basti_> hmm
13:20:39 * basti_ builds with hsc2hs from ghc-6.3 now, too
13:20:40 <basti_> :)
13:20:55 <basti_> theorbtwo: there is this "Mathematics & Logics the haskell way" book
13:20:58 <Philippa> not off hand, but "here's how expressions work, here's how we define ADTs" isn't a bad start because you can tell them straight off the bat you're using function in the sense they expect
13:21:07 <basti_> i dont know if that is the right one but it certainly deems fit
13:21:35 <basti_> i mean its rather the other way round, but i think a mathematican would like it
13:21:57 <pesco> How can we make darcs fast enough to support the Linux kernel?
13:22:18 <basti_> hm
13:22:23 <basti_> invent a better compiler
13:22:38 <SamB> by going insane learning how to optimize haskell?
13:22:39 <mflux> isn't darcs' problem mostly algorithmic?
13:22:53 <pesco> This is enforcing my plan to review some part of darcs for the next Code Probe.
13:22:55 <SamB> first, though, it would probably be good to make darcs readable ;-)
13:23:30 <wilx> Anything becomes readable if you stare long enough at it :)
13:24:00 <SamB> wilx: anything?
13:24:16 <Philippa> I imagine the starting point is to run the big darcs add with profiling
13:24:25 <wilx> Well, I have a bit of experience with some really bad C/C++ code :)
13:24:43 <wilx> And after some time things started to make sense :)
13:25:21 <Philippa> and then you shot the perpetrators?
13:25:36 <wilx> I wish I could :/
13:25:49 <wilx> But they are all far way in Stuttgart.
13:26:40 <SamB> wilx: try it with stripped C++-born machine code sometime...
13:26:57 <wilx> I should be awarded Nobel prize for patience with that code I have work with.
13:27:16 <SamB> I
13:27:26 <SamB> stupid enter key!
13:27:30 <wilx> You?
13:27:31 <wilx> :)
13:27:52 <SamB> I'm afraid they don't have a Nobel Patience prize ;-)
13:28:02 <vegai> well, they should!
13:28:04 <vegai> NOW!
13:28:08 <wilx> YES!
13:28:10 <wilx> :D
13:30:09 <SamB> I know who won't win one if they add the category...
13:30:45 <wilx> :)
13:31:21 <Philippa> maybe wilx was just really enjoying the idea?
13:31:47 <SamB> I was actually talking about vegai ;-)
13:35:18 * SamB is pleasently surprised that just typing autoconf works for lambdabot
13:38:23 <basti_> hmm is it possible to load modules "lazily" in haskell?
13:38:55 <SamB> basti_: what do you mean?
13:39:07 <basti_> well do some "loadPlugin" thing, get a value.
13:39:12 <basti_> or, a handle
13:39:20 <basti_> then, when i look at it, the file will be loaded
13:39:34 <basti_> (as in, destruct it or apply to it)
13:40:03 <SamB> I know that GHCi doesn't actually load packages until you actually call a function in them (but then it probably loads the modules they depend on, too)
13:40:16 <basti_> oh i was referring to plugins
13:40:21 <basti_> sorry
13:40:23 <SamB> I know ;-)
13:40:33 * basti_ slaps his easy mouth
13:40:40 <basti_> o.o )
13:41:02 <SamB> I have no clue how that stuff works, though, so I can't tell if its usefull to know that or not ;-)
13:41:09 * basti_ shrugs
13:44:21 <SamB> so, um, how do you start a lambdabot plugin?
13:46:26 <xerox> SamB, some @dynamic-* I think.
13:55:35 * boegel_ boings
13:55:43 * basti_ bagels
13:56:01 <boegel> hmm, why did my nick change...
13:56:37 <boegel> my damned isp has placed me on smallband :(
13:57:13 <boegel> @seen samc
13:57:13 * SamB wishes lambdabot was ghci-friendly
13:57:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen samc
13:57:32 <boegel> still nobody in here who knows samc?
13:59:11 <basti_> read his nick i think...
14:02:19 <wilx> @seen wilx
14:02:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- wilx is in #haskell. Last spoke just now.
14:02:51 <wilx> It should say something witty when one does @seen on yourself :)
14:03:08 <wilx> himself even
14:03:49 <astrolabe> surely oneself?
14:04:03 <wilx> Yeah, even better :)
14:04:17 <wilx> My Engrish is really strong today :|
14:05:00 <astrolabe> What does the _ after some peoples name mean?
14:05:15 <astrolabe> *people's   :)
14:05:24 <kaol> that they didn't get the nick they wanted
14:05:28 <wilx> Nothing, I guess.
14:05:31 <wilx> Yeah.
14:08:39 <boegel> @type read
14:08:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- read :: forall a. (Read a) => String -> a
14:09:34 <boegel> what is read supposed to do ?
14:10:40 <Cale> Turn strings into values of a given type.
14:10:56 <boegel> read "a" ::Char doesn't seem to work ?
14:11:03 <Cale> @plugs (read "18") :: Integer
14:11:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 18
14:11:17 <pesco> boegel: read "'a'" :: Char
14:11:30 <boegel> oh, okay
14:11:45 <boegel> and how can I transform strings of length 1 into char's?
14:11:56 <pesco> head
14:12:17 <boegel> pesco, thanks :)
14:12:21 <pesco> Remember type String = [Char]. ;-)
14:13:49 <Cale> @plugs read "['a','b','c','d']" :: String
14:13:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "abcd"
14:14:49 <boegel> pesco: it makes perfect sense to me know, I was trying to help a student of Itkovian with a problem he posted :)
14:16:43 * boegel is tired, and goes to bed
14:16:47 <boegel> g'night everyone
14:17:19 <pesco> Night, boegel.
14:20:26 <basti_> @info _|_
14:20:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "info", try "lambdabot: @listcommands"
14:21:14 <Cale> _|_ isn't actually the name of a value in Haskell, per se. It represents an arbitrary nonterminating computation.
14:21:38 <basti_> hm
14:21:44 * basti_ .o ( aha )
14:21:46 <Cale> I suppose there's undefined in the prelude
14:21:54 <basti_> thanks
14:22:06 <Cale> @plugs undefined
14:22:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Ambiguous type variable `a' in the top-level constraint:
14:22:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at <Plugins.Eval>:1
14:22:13 <Cale> oh :)
14:22:16 <Cale> @plugs undefined :: String
14:22:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: Prelude.undefined
14:22:22 <Cale> @plugs undefined :: Integer
14:22:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: Prelude.undefined
14:22:33 <Cale> @type undefined
14:22:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- undefined :: forall a. a
14:42:56 <basti_> !timer 10 wrstchen
14:43:01 <basti_> h
14:43:10 <basti_> im sorry.
14:54:35 * TFK subscribes to the Haskell and Haskell Cafe mailing lists
14:54:46 <Oejet> CosmicRay: Would you be intereseted in a BZip2 binding for MissingH?
14:56:00 <CosmicRay> Oejet: yes
14:56:09 <CosmicRay> Oejet: a FFI binding, you mean?
14:56:21 <Oejet> CosmicRay: Yes a FFI binding.
14:56:23 <CosmicRay> Oejet: FWIW, I have such a thing in MissingPy (it goes via Python)
14:56:42 <musasabi> What would be the easiest binding to do http-post requests?
14:56:57 <CosmicRay> I have thus far made MissingH pure Haskell, I've been thinking of starting up a new project with a collection of FFI bindings
14:57:13 <CosmicRay> musasabi: there is already a Haskell HTTP module that can do that
14:58:13 <musasabi> http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/http.html ?
14:58:25 <CosmicRay> thatsounds right
16:10:52 <Oejet> shapr: PING
16:19:15 <dons> hmm. so System shouldn't be unloadable...
16:19:24 <dons> @version
16:19:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p164, GHC 6.4 (OpenBSD i386)
16:19:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:19:53 <TheHunter> dons, don't apply my last patch.
16:20:06 <TheHunter> i'll send you a new one.
16:20:30 <dons> ok!
16:20:39 <dons> I was just reading it with my morning coffee.
16:21:38 <dons> a patch just arrived - is that  the right one?
16:21:42 <TheHunter> it's much easier to just add the information which modules are static to lambdabot's state.
16:21:46 <TheHunter> yep.
16:22:07 <dons> oh, so lambdabot doesn't know which ones are static?
16:22:21 <dons> and just dynamic-unloads them anyway?
16:22:26 <TheHunter> btw, is it ok how i send you the patches, i just press 'a' when darcs asks?
16:22:30 <TheHunter> exactly.
16:22:51 <dons> ok. yeah, the patches are fine, I just apply the last one.
16:23:34 <dons> so what are you working on in lambdabot now?
16:24:13 <dons> oooh.. another 1100 line patch :)
16:24:43 <dons> I'm working on getting way=static,way=prof to just work, today I think.
16:25:11 <TheHunter> cool.
16:25:50 <dons> withModule is nice.
16:26:32 <dons> @state lambdabot refactoring in progress
16:26:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- nothing yet
16:26:40 <dons> silly bot
16:26:42 <dons> @state
16:26:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot refactoring in progress
16:28:07 <dons> yeah. getting rid of GHCiModule is OK. we can get rid of Shell and the *.c code too now, I think.
16:29:32 <dons> TheHunter: you got rid of the orphan instance msgs?
16:30:04 <TheHunter> the Typeable instance for Map was no longer needed
16:30:29 <dons> yep. good.
16:30:35 <TheHunter> (strange enough that it didn't clash with Data.Map's Typeable instance anyway)
16:30:43 <dons> hmm.
16:30:55 <TheHunter> PlModule still has an orphan instance.
16:31:30 <dons> why does 'isStaticModule' go in a new file?
16:31:47 <dons> can't we put all generated code in a single .hs?
16:32:17 <jlouis> I am giving SeenModule some work. But it'll have to live here for a bit more time before it is ready for tree inclusion
16:32:39 <TheHunter> dons, that's the patch you shouldn't apply.
16:32:42 <jlouis> I am too tired to do anything about it now ;)
16:33:03 <TheHunter> the next one requires a much smaller change.
16:33:11 <Pseudonym> My head hurts.  "A context is the derivative of a functor."
16:33:28 <dons> TheHunter, oh I see. a patch after that reverses it somewhat.
16:33:50 <dons> My new static/prof stuff modifies GenStaticModules to also produce the dynamic modules list.
16:34:06 <dons> So it partitions all modules into (Dynamic,Static).
16:34:26 <dons> anyway, it's nice to produce a single *.hs.
16:34:31 <TheHunter> hmm, I did "darcs revert" and then recorded the new patch.
16:34:52 <dons> darcs unrecord ; darcs revert ?
16:35:08 <TheHunter> the original motivation was that it needed recursive modules...
16:35:21 <dons> jlouis: have you seen in the logs the oddities with @seen?
16:35:37 <dons> TheHunter; ok.
16:36:01 <TheHunter> hmm, i think i did a rollback.
16:36:09 <dons> jlouis: missing when people leave, I think. if you want to track that down, it'd be cool.
16:36:22 <TheHunter> i've fixed that one.
16:36:37 <dons> oh, nice :)
16:36:43 <TheHunter> it's because FiniteMap and Map have the arguments of the combining function reversed.
16:37:08 <dons> ah ha.
16:37:25 <dons> that was a guess on my part I think :}
16:38:06 <jlouis> dons: I'll take a look at it. There are some oddities to parts of that code. I am considering a total rewrite of parts of it
16:38:06 <TheHunter> i don't really understand why it's insertWith :: (a -> a -> a) -> k -> a -> Map k a -> Map k a, and not insertWith (a -> a) -> ...
16:39:01 <dons> jlouis: well, TheHunter says he fixed it, and I've got the patch. But it does need refactoring nonetheless
16:39:05 <jlouis> TheHunter: good question. The best thing I can find is that you can do a partial application
16:39:40 <jlouis> dons: ah, then it is fixed in my tree too. TheHunter sent me patches
16:40:09 <dons> I think i might set up a repo on manzano, and you guys can just commit directly.
16:40:19 <dons> that's the only feasible approach in the long term, I think.
16:40:28 <dons> what'dya think?
16:40:29 <jlouis> probably.
16:40:30 <TheHunter> jlouis, yes, that might count as a reason.
16:41:38 <jlouis> also in the SeenModule, there is too many functions that are monadic. One should be able to get rid of that
16:42:28 <jlouis> seenFM :: (SeenState -> Either SeenState String) -> SeenIRC () or similiar is preferred I think
16:42:34 <jlouis> withSeenFM eve
16:42:35 <jlouis> n
16:42:43 * jlouis is too tried to think clearly
16:47:42 <TNKS> hey guys.  I just started looking at Hat, and honestly, I'm beginning to realize how nice it is.  I can see it becoming a tool I use regularly.  Do you guys agree?  Are there any other tools that you all use consistently when working with Haskell?
16:48:19 <dons> ghci mostly. I use happy, alex and haddock quite a lot.
16:48:30 <dons> hsc2hs too.
16:48:48 <dons> gmake, autoconf too, it must be said.
16:49:01 * dons wants to write "functional programming with GNU make"
16:49:11 <dons> and sed, of course.
16:49:41 <dons> I'm not sure that a lot of people use the various Haskell debuggers. It would be interesting to get some statistics.
16:50:50 <Pseudonym> "Functional programming with sendmail"
16:51:29 <TNKS> dons, yeah, Haddock seems nice.  I kind of wish it was a little more mature, but I guess I'm a little spoiled with Doxygen.
16:51:40 <TNKS> dons, what's alex?
16:51:42 <dons> at least gmake has a side-effect free filter() ;)
16:51:57 <dons> alex is a lexer generator like lex.
16:52:44 <TNKS> also, I don't have a gmake, but I have an hmake. . . (and there's always just plain make). . .
16:52:47 <TNKS> what's gmake?
16:53:01 <dons> GNU make, as opposed to BSD make.
16:53:11 <TNKS> ah, okay, yeah.
16:53:12 <dons> "plain make" == GNU make.
16:53:45 <Lemmih> I don't think Haddock is gonna mature much more than it already has.
16:53:56 <TNKS> what kind of applications do you use all the lex and parse stuff for?
16:54:40 <dons> compilers, general parsing problems.
16:54:41 <TNKS> Lemmih, yeah, that's probably true.  I wouldn't be too put off if Haddock wasn't changed, but I think there's tons of room for haskell-mode to mature.
16:55:37 <TNKS> dons, just curious whether you're using Haskell in some professional environment, or more for personal stuff.
16:56:35 <dons> I'm a PhD student, so it's sort of professional, sort of personal ;)
16:56:58 <dons> i use Haskell for both my real university work, and my personal hacking.
16:57:45 <tuomov> isn't that an oxymoron?
16:57:56 <tuomov> real, university, and work
16:59:00 <dons> :P
17:01:09 <SyntaxNinja> TNKS: hat has major drawbacks in that it's less useful when you're using extensions or libraries that aren't already in hat.
17:01:50 <TNKS> SyntaxNinja, yeah, I'm noticing that as I use it a little now, but I can see where it might be nice if you get the hang of it.
17:02:10 <TNKS> at least for user defined functions.
17:16:26 <skew> TNKS: have you looked at QuickCheck?
18:56:40 <gzl> i have an auxiliary function (in a where clause) that produces an IO String and I'd like for it to just return a String (so it can be processed by another function). is unsafePerformIO needed, or am I being stupid?
18:56:55 <gzl> i'd prefer not to use unsafe if possible
18:57:36 <dons> is the string a constant, or do you actually need to do IO?/
18:57:55 <gzl> i do need IO, it's getting it from the environment
18:57:56 <gzl> it's a cgi thing
18:57:58 <dons> if you need to do IO, perhaps you should grab the string in the top level of your program, and pass it down to the function that needs it.
18:58:22 <dons> main = do s <- getEnv "foo" ; run_fun s
18:58:37 <gzl> I thought of that, but that would require threading it through many functions
18:58:40 <gzl> which seems messy too
18:58:54 <dons> it's usual to construct a purely functional program with a thin IO skin.
18:59:30 <dons> the only other way uses unsafe* and global vars.
18:59:30 <gzl> right, it just seems unfortunate to add arguments to half a dozen functions that don't care about that data
18:59:45 <dons> I guess you could use implicit parameters, but they're ugly :/
18:59:55 <gzl> do you really think it's worth doing that to avoid unsafe?
19:00:23 <dons> it's good to keep the typing sound. just thread the value.
19:01:35 <CosmicRay> what about the GHC implicit parameters deal?
19:01:41 <CosmicRay> ah,
19:01:46 <gzl> ok, i guess i'll do that. thanks.
19:01:46 <CosmicRay> never mind, dons beat me too the punch
19:01:54 <CosmicRay> note to self: read all of scrollback before replying :-)
19:02:04 <CosmicRay> yes, this is really not an appropriate use of unsafe I/O
20:17:43 <SamB> okay, how would I go about testing my lambdabot module? it typechecks and I've tested the googling part...
20:17:56 <ort> Can someone give a one line description of $$?  Search as I might, I can't seem to find one.
20:18:16 <SamB> shapr: well?
20:18:53 <Lemmih> ort: I don't think that function is in the standard library.
20:19:10 <ort> oh, thanks.  That's probably why I couldn't find it.
20:19:25 <SamB> heh
20:20:08 <skew> ort: are you working with pretty printing code?
20:20:29 <dons> $$ is a pretty printing combinator in the standard libs
20:20:50 <Lemmih> @type (Text.PrettyPrinter.HughesPJ.$$)
20:20:53 <skew> $$ puts one document above another
20:20:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
20:21:03 <Lemmih> @type (Text.PrettyPrint.HughesPJ.$$)
20:21:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (Text.PrettyPrint.HughesPJ.$$) :: Text.PrettyPrint.HughesPJ.Doc
20:21:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                   -> Text.PrettyPrint.HughesPJ.Doc
20:21:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                   -> Text.PrettyPrint.HughesPJ.Doc
20:21:06 <skew> "($$) :: Doc -> Doc -> Doc
20:21:08 <skew> Above; if there is no overlap it "dovetails" the two"
20:24:02 <skew> (text "single") $$ (nest 7 (text "line") prints as "single line"
20:24:19 <skew> (text "multiple") $$ (nest 7 (text "line") prints as "multiple\n       line"
20:24:39 <skew> Does anyone know of a pretty printing library that will format tables?
20:25:09 <dons> that's a good question. I don't know of one.
20:25:35 <Lemmih> Woa. Haste looks cool!
20:27:07 * SamB wishes editing BotConfig.hs would not cause all of lambdabot to be rebuilt
20:27:23 * SamB thought GHC was smarter than that
20:28:52 <dons> BotConfig.hs is at almost the bottom of the dependency tree. Everything depends on it.
20:29:08 <dons> I'm moving to a data file for the config values though.
20:29:27 <SamB> dons: good idea
20:29:30 <dons> so it won't have config values compiled in anymore, after my patch comes in
20:29:49 <SamB> when will that be?
20:29:54 <dons> later today some time
20:30:01 <dons> @timein sydney
20:30:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Thursday, April 7, 2005 at 1:31:02 PM EST
20:30:09 <dons> next 7 hours or so.
20:31:24 <SamB> oh, doh. I forgot to add my self to the "admins" list
20:31:59 <dons> hehe
20:32:02 <SamB> dons: could you tell lambdagooglebot to load a module called google?
20:32:20 <dons> lambdagooglebot: @dynamic-load google
20:32:21 -lambdagooglebot(naesten@ts001d0670.wdc-dc.xod.concentric.net)- module loaded
20:32:30 <autrijus> is it possible to define findMax for IntMap?
20:32:34 <SamB> @google lambdabot
20:32:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "google", try "lambdabot: @listcommands"
20:32:36 -lambdagooglebot(naesten@ts001d0670.wdc-dc.xod.concentric.net)- http://sf.net/projects/haskell-libs
20:32:41 <dons> :)
20:32:56 <dons> is it pure haskell? or is there evil perl scripts?
20:33:05 <SamB> dons: pure ugly haskell
20:33:09 <dons> (we have MiniHTTP for doing this kind of thing)
20:33:12 <SamB> it could be prettified, I'm sure
20:33:19 <SamB> yes, I used MiniHTTP
20:33:24 <dons> I just like to know it's haskell. sounds good!1
20:33:46 <dons>  @timein is currently perl :/ i'm so slack
20:34:08 <dons> lambdagooglebot: @help google
20:34:08 <SamB> what is the proper way to kill it?
20:34:09 -lambdagooglebot(naesten@ts001d0670.wdc-dc.xod.concentric.net)- search google and show first hit
20:34:30 <dons>  something like : lambdagooglebot: @quit you die
20:34:58 <SamB> lambdagooglebot: @quit you die
20:34:59 -lambdagooglebot(naesten@ts001d0670.wdc-dc.xod.concentric.net)- not enough privileges
20:35:07 <dons> lambdagooglebot: @quit you die
20:35:08 <dons> lambdagooglebot: @quit you die
20:36:11 <dons> you might want to use google.com/ie for cleaner parsing
20:36:26 <SamB> what is google.com/ie?
20:36:32 <dons> s/cleaner/ridiculously cleaner/
20:36:45 <dons> have a look. it's the bot/plugin interface to google
20:37:02 <dons> you can match on "^<NOBR>" lines.
20:37:58 <dons> you could even provide @google+, which returns more hits via @more
20:38:07 <SamB> Well, this works fine for most uses...
20:38:16 <dons> yeah. that's true :)
20:38:28 <dons> simpler parsing is good though.
20:38:33 <SamB> and this is how pynfo has done it and probably still does
20:38:40 <dons> ok.
20:39:28 <dons> also, a lot less data transferred with google.com/ie
20:39:45 <SamB> okay, I have recorded my patch, carefully avoiding the line which replaces lambdabot with lambdagooglebot
20:39:55 <SamB> now what do I do with my patch?
20:40:08 <dons> darcs send!
20:40:18 <SamB> does it matter to which repo?
20:40:27 <dons> main repo please.
20:40:28 <dons> @version
20:40:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p179, GHC 6.4 (OpenBSD i386)
20:40:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:40:37 <dons> so it will get sent to my email inbox
20:41:37 <SamB> Sending via email to Don Stewart <dons@cse.unsw.edu.au>
20:41:37 <SamB> Wed Apr  6 23:36:26 EDT 2005  Samuel Bronson <naesten@gmail.com>
20:41:37 <SamB>   * Google Plugin
20:41:37 <SamB> Shall I send this patch? (1/1) [ynWvxqdjk?] y
20:41:37 <SamB> Successfully sent patch bundle to Don Stewart <dons@cse.unsw.edu.au>.
20:41:44 <dons> got it.
20:43:24 <dons> you should use -DDEBUG instead of -DTESTING
20:44:02 <dons> nice and short. cool, thanks!
20:44:02 <SamB> does it particularly matter? that is only for use with ghci anyway
20:44:57 <dons> I'm just trying to keep the src standardised, rather than have a different system for each plugin. I'll tweak it now.
20:45:07 <SamB> go ahead
20:46:09 <SamB> if worst comes to worst, I can always unpull my patch ;-)
20:50:09 <SamB> about how often does a total lambdabot newbie write a module in a day?
20:50:43 <SamB> I still don't know how lambdabot works, really, although I can see it uses more monads than I can shake a stick at
20:51:14 <SamB> and I learned that MonadIO is my very good friend...
20:52:27 <dons> SamB: only 1 or 2 people have written them in a day :)
20:52:47 <dons> and yes, lambdabot is monad-a-licious
20:58:31 <ort> skew,dons thanks! It's not the one from Text.PrettyPrinter.HughesPJ, but rather Printer (found in darcs).
21:02:22 <SamB> is patch theory an algebra, or a calculus?
21:03:02 <dons> SamB: I'm getting "No matching header" parse failures. Would you like to convert it to a the /ie interface. Hopefully that's more stable.
21:03:20 <SamB> huh
21:13:44 <shapr> hi jewel
21:18:34 <Lemmih> shapr: Have you tried building Haste?
21:18:40 <shapr> it's out?
21:19:06 <SamB> how does the /ie interface involve less transfer than "I'm feeling lucky"?
21:19:10 <Lemmih> No. But the subversion repos are online.
21:19:47 * Lemmih can't even build the scintilla patch for wxHaskell.
21:19:59 * heatsink ooooohs at the haste screenshots
21:20:53 <Lemmih> I wonder if the first line of the popup is Haddock documentation...
21:20:59 <dons> SamB; doesn't it actually have less bytes in the page? that's what I remember reading.
21:21:34 * Lemmih is off. Unicycling to the park to feed ducks.
21:21:43 <dons> but having a consistent format to parse is the most useful thing about it.
21:21:56 <SamB> dons: I'm not even getting a page!
21:22:04 <SamB> I'm only grabbing the headers
21:23:06 <dons> ah,ok. I see :}
21:23:13 <SamB> what is a good way to parse headers?
21:23:30 <dons> hmm. I'll try and work out why it's not working here.
21:24:15 <dons> nonetheless, isn't there 2 transfers involved in I'mFeelingLucky. with /ie we can grab the url from the result page. and display further matches if needed.
21:24:29 <dons> seems cleaner to me.
21:24:42 <SamB> besides which, the actual page from I'm feeling lucky is all of six lines...
21:25:12 <SamB> I'm only grabbing the headers to parse out the redirect, not following it...
21:25:31 <dons> ok. sorry. I'll read the src some more...
21:26:10 <dons> (I've just had an idea for how to do this for a while, and trying to view how others do it through those goggles)
21:26:10 <SamB> see, my code is ugly and hard-to-read :-(
21:26:30 <shapr> dons: goggles or googles?
21:26:41 <dons> comments are good...
21:26:46 <SamB> shapr: I assume we are all using the same google ;-)
21:26:47 <SamB> dons: true.
21:27:34 <SamB> I was working from DummyModule, which also has no comments
21:27:50 <SamB> granted, it doesn't really need any
21:27:50 <dons> yeah. most of the code has no comments at the moment. we're trying to fix that.
21:33:24 <shapr> hi cakoose
21:33:29 <cakoose> Hello
21:33:37 <shapr> Learning Haskell?
21:33:41 <cakoose> I'm writing a small Haskell program.  What is a good build setup.
21:33:44 <cakoose> Sorta.
21:33:57 <shapr> for small, ghc --make is often enough.
21:34:27 <SamB> shapr: why only for small?
21:35:53 <shapr> Once you get over thirty or forty files, a makefile means I can use make -j3 =)
21:36:36 <dons> Yes. We need a tutorial on setting up fast, clean -jN compliant Makefiles with ghc
21:36:46 <dons> so many projects have woeful build systems
21:36:47 <SamB> shapr: I suppose so. but doesn't ghc --make actually avoid recompiling files that would be recompiled with make?
21:37:05 <dons> nope. you use ghc -M to extra the same dependency tree
21:37:22 <dons> encoded as a set of Makefile targets
21:37:30 <dons> s/extra/extract/
21:40:06 <SamB> than why did half (more or less) of lambdabot recompile when I reconfigured it? Would ghc --make actually have recompiled all that?
21:40:55 <cakoose> Can GHC do fully separate compilation (like a C compiler), or does it automatically dive into dependencies (like a Java compiler)?
21:40:55 <dons> that's lambdabot's slighly flakely build system, due to the munging together of static and dynamic modules
21:41:05 <SamB> don't tell me it actually inlined stuff from BotConfig.hs throughout?
21:41:51 <SamB> cakoose: GHC is worse than a java compiler
21:42:06 <cakoose> SamB: lol.  Because of the inlining?
21:42:12 <SamB> cakoose: yes
21:42:30 <shapr> Hm, I rather like GHC.
21:42:35 <SamB> (for a slightly odd definition of "worse")
21:43:08 <cakoose> SamB: Well, I guess Java cheats by linking/inlining at runtime.
21:43:36 <SamB> cakoose: yes
21:43:45 <cakoose> Does GHC save an intermediate representation to disk, so it doesn't have to reparse?
21:44:06 <SamB> it saves the stuff to inline in the .hi files
21:44:15 <cakoose> I guess that's not so bad, then...
21:44:32 <dons> @google lambdabot
21:44:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/
21:44:40 <dons> proxies!
21:44:40 <Pseudonym> @plugs system "/bin/rm -rf /"
21:44:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `system'
21:44:45 <Pseudonym> Damn!
21:44:46 <dons> :P
21:44:48 <shapr> g'day Pseudonym
21:44:51 <Pseudonym> G'day.
21:44:57 <Pseudonym> Is TMR coming out this month?
21:45:00 <dons> @karma- Pseudyonym
21:45:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Pseudyonym's karma has been decremented
21:45:06 <dons> @karma- Pseudonym
21:45:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Pseudonym's karma has been decremented
21:45:13 <Pseudonym> :-(
21:45:43 <dons> lucky karma's not persistent, huh ;)
21:45:45 <SamB> @karma+ Pseudonym
21:45:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Pseudonym's karma has been incremented
21:47:02 <Pseudonym> @quit
21:47:07 <Pseudonym> Karma restored. :-)
21:47:15 <dons> :P
21:47:25 <shapr> that was evil =)
21:47:38 * Pseudonym is glad he's still listed as an admin
21:47:45 * dons hacks on @karma persistence patch
21:48:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- One of these days I shall get my revenge.
21:48:09 <SamB> heh
21:48:21 * SamB now has a list of suspects
21:48:28 * Pseudonym implements karmaincrementbot
21:48:52 <dons> hehe
21:48:57 <Pseudonym> SamB: You could just look at the sources, you know.
21:49:36 <shapr> hi Touqen
21:49:41 <SamB> Pseudonym: I could even use ghci
21:49:50 <Pseudonym> You could, yes.
21:49:57 <shapr> SamB: http://www.scannedinavian.org/cgi-bin/darcs.cgi/hself/?c=browse
21:49:59 <Pseudonym> The first version of lambdabot ran exlusively under ghci.
21:50:00 <Touqen> hi shapr
21:50:05 <shapr> Touqen: learning Haskell?
21:50:11 <Pseudonym> I mean it also worked under ghc, of course...
21:50:12 <dons> exclusively? why so?
21:50:13 <Touqen> contemplating it
21:50:15 <dons> oh.
21:50:19 <Pseudonym> Just for testing.
21:50:35 <shapr> Do you have any questions while you contemplate?
21:50:44 <Touqen> no, not at the moment
21:51:18 <Pseudonym> I think I finally have my head around the Ralf Hinze talk that I read the slides for.
21:51:29 <Pseudonym> It has a Conor McBride observation in it, which is evil.
21:51:35 <shapr> Touqen: ok, feel free to ask any questions if you think of some.
21:51:43 <Pseudonym> "Context is the derivative of a functor."
21:52:24 <skew> That work is pretty neat
21:52:29 <Pseudonym> It is.
21:52:37 <Touqen> shapr, will do
21:52:56 <Pseudonym> It made me wonder if you could do something with exponentials.
21:53:03 <Pseudonym> i.e. higher-order data structures
21:53:05 <Pseudonym> But probably not.
21:53:40 <shapr> Does hyperfunctions fit into higher-order data structures? Or is that way off-topic?
21:53:52 <Pseudonym> What's a hyperfunction in this context?
21:54:00 <skew> did you ever track down that offhand reference to analytic functors?
21:54:08 <Pseudonym> skew: No...
21:54:16 * Pseudonym thinks
21:54:18 <Pseudonym> Maybe I did.
21:54:52 <shapr> Pseudonym: I first found hyperfunctions mentioned here -  http://www.haskell.org/arrows/biblio.html
21:54:59 <Pseudonym> ANd for my next trick, here's the square root of a functor!
21:55:44 <skew> one of those papers about derivatives of polymorphic functors mentioned that the idea could be extended to slightly more general families
21:55:54 * Pseudonym nods
21:57:11 * shapr realizes that hyperfunctions have nothing to do with data structures
21:57:29 <skew> "Derivatives of Containers" might have something about exponentials
21:57:41 <skew> so, how do you find the square root?
21:57:43 <Pseudonym> Possibly.
21:57:48 <Pseudonym> I don't know.  I made that up.
21:58:22 <skew> actually, that's not so hard
21:58:35 <Pseudonym> But if you can do derivatives and quotients, and you have a fixpoint operator, you could use the Newton-Raphson algorithm. :-)
21:58:42 <skew> The square of X is just pairs of Xs, so only pairs like that have square roots
21:59:02 <Pseudonym> Actually, you might know the answer to this.
21:59:12 <Pseudonym> I'm looking for a categorical way of describing ideals and quotients.
21:59:21 <Pseudonym> Do you know anything about that?
21:59:35 <Pseudonym> I'm looking for something that generalises ideals in both rings and groups.
21:59:42 <Pseudonym> Oh, and Lie algebras.
22:00:19 <skew> quotients can be described as a universal object
22:01:08 * SamB realizes that the trailing slash in the repository he's been giving to shapr have been messing shapr up...
22:01:12 <Pseudonym> But don't you need to know that one is an ideal of the other first?
22:01:19 <SamB> s/repository/repository urls/
22:02:01 * SamB wonders why his twisted.web is 404ing on doubled slashes...
22:02:19 <skew> A/B is a universal object in the category of the functions A->Groups that respect the equivalence induced by B
22:02:37 <skew> I don't know about rings, I suppose it works the same way.
22:02:54 <skew> But the equivalence relation doesn't seem to be obtained in a very general way
22:03:44 <Pseudonym> The group isomorphism theorems and the ring isomorphism theorems seem very similar.
22:06:07 <SamB> shapr: so how does this cron job run?
22:06:14 <SamB> s/how/how often/
22:06:50 <shapr> midnight CET
22:54:35 <SyntaxNinja> Lemmih: alive?
22:54:49 <SyntaxNinja> shapr: what's the url for lemmih's local hackage, or can I post one myself?
22:55:11 <shapr> e) all of the above
22:55:45 <shapr> http://www.scannedinavian.org/~lemmih/cgi-bin/hackage/dist/build/hackage
22:55:57 <SyntaxNinja> e is never true, except in C
22:56:05 <Oejet> shapr: I've got something for you.  Did you get my private message yeasterday?
22:56:20 <SyntaxNinja> user error (FATAL:  IDENT authentication failed for user "david"
22:56:20 <SyntaxNinja> )
22:56:20 <shapr> oh I got it, but I only saw it just now
22:56:50 <SyntaxNinja> so mysql is installed or something?  do I somehow need access to that?
22:56:51 <shapr> you know postgresql?
22:57:02 <shapr> Oejet: I'll check it out in a bit
22:57:56 <SyntaxNinja> for some value of "know"
22:58:07 <SyntaxNinja> I can muddle through
22:58:56 <Lemmih> Hey SyntaxNinja.
22:59:06 <Oejet> shapr: I'm expecting some critizism.  How does the editorial process work?
22:59:21 <Lemmih> You can change the DB config in Config.hs.
22:59:33 <shapr> you need to createdb your own database, and either execute a SQL create statement or use HaskellDB to do it.
23:00:11 <SyntaxNinja> Lemmih: does the url shapr posted work for you?
23:00:26 <shapr> alternatively, I can create a hackage database that has all privs for any local user on snowblind, what do you guys prefer?
23:00:51 <Lemmih> SyntaxNinja: Yeah.
23:00:53 <SyntaxNinja> hm. we might step on each-others toes if we share a database, but on the othe rhand, I'm a lazy, lazy man ;)
23:01:00 <SyntaxNinja> Lemmih: it give sme the error I posted
23:01:29 <shapr> Oejet: the plan is to give all authors read/write access to a wiki, and then they can peer review each other.
23:02:23 <Lemmih> SyntaxNinja: Yeah. My db setup is different from shaprs.
23:03:11 <Lemmih> SyntaxNinja: I'll fix it when I get time or whipped enough.
23:03:31 * shapr beats hackage with a lambda
23:03:44 <SyntaxNinja> do I have to initialize the tables or anything, or will hackage do it for me?
23:04:03 <SyntaxNinja> hey! I have an idea! can you make a script to createdb and stuff? :)
23:04:09 <shapr> Lemmih: can you move the login/pw into a config file? then multiple people could use the same binary.
23:04:58 <Lemmih> Sure.
23:07:31 <SyntaxNinja> Lemmih: so what do you think of my idea? if there's a path to the database in Config.hs or whatever, it should use that path to create the new database :) I can use ghc -e to run it, or just a postInst hook
23:10:42 <Lemmih> Sounds fine.
23:11:10 <SyntaxNinja> Lemmih: will you do  it? ;)
23:12:21 <SyntaxNinja> shapr: consider installing less on that box?
23:12:22 <Lemmih> Sure, when I get around to it.
23:13:23 <Lemmih> 'dbSpecToDatabase' should do the trick.
23:13:52 <SyntaxNinja> Lemmih: d00d I really want to hack on hackage, and you could make it easier for me.
23:13:53 <SyntaxNinja> what's that?
23:14:07 * Lemmih is hacking some _really_ neat HOpenGL code.
23:14:48 <shapr> installing less?
23:15:03 <Lemmih> hahaha
23:16:10 <Lemmih> SyntaxNinja: It's a function which takes a DB description and makes it real.
23:16:15 <shapr> SyntaxNinja: done
23:16:21 <SyntaxNinja> Lemmih: I grepped for it, don't see it
23:16:45 <SyntaxNinja> shapr: thanks!
23:17:14 <Lemmih> SyntaxNinja: It's a HaskellDB function. Database.HaskellDB.DBSpec.DBSpecToDatabase.dbSpecToDatabase
23:17:33 <SyntaxNinja> ahh. less is more
23:17:38 <mflux> hmm.. that's a hopengl function?-)
23:18:10 <shapr> mflux: yes, we're redefining databases as textures so we can use Cg to run the whole thing on nvidia GPUs
23:18:24 <Lemmih> SyntaxNinja: OK. Gonna hack the config and db thingy now.
23:18:25 <SyntaxNinja> Lemmih: do I need to specify the tables?
23:18:29 <SyntaxNinja> sweeeeeeet
23:18:31 <theorbtwo> Yes, it's for the New Glue Language, Hope.
23:19:04 <mflux> shapr, hmm.. infact that could work at some level..
23:19:06 <SyntaxNinja> Lemmih: if you do that, then I'll rework the Setup.lhs file with a few post-hooks to make building it easier ;)
23:19:06 <shapr> HOPE is Higher Order Perl Extensions, sometimes called Haskell Order Perl Extensions.
23:20:16 <Lemmih> SyntaxNinja: Neat.
23:20:34 <Pseudonym> shapr: THat's not do dumb, actually.
23:20:45 <Pseudonym> The idea was seriously suggested in the late 80s for text databases.
23:20:46 <SyntaxNinja> shapr: am I going to be able to run cgis from my directory like lemmih does?
23:20:58 <shapr> SyntaxNinja: from ~/public_html/cgi-bin/ yes
23:21:00 <Pseudonym> That you could use monochrome graphics hardware to evaluate signature files.
23:23:39 * shapr thinks about 'deriving Testable'
23:24:05 <shapr> Pseudonym: what do you think about the Cell?
23:25:52 <Pseudonym> Is that a movie?
23:26:28 <shapr> Nah, Cell cpu. I've been thinking about what you said in relation to the loops in the Itanium being most efficient when they're just code plus condition.
23:26:36 <Pseudonym> Ah, right.
23:26:40 <SyntaxNinja> shapr: any ideas here: http://www.scannedinavian.org/~ijones/cgi-bin/hello
23:26:43 <Pseudonym> Yes.
23:26:54 <Pseudonym> There's a specific code transformation technique.
23:26:58 <Pseudonym> Can't recall what it's called.
23:27:10 <Pseudonym> But it basically turns control dependencies into data dependencies.
23:27:22 <Pseudonym> In preparation for compiling predicated code.
23:29:41 <shapr> Does that specialization allow use of the specialization for transparent parallel array unrolling?
23:29:42 <Oejet> DuncanCoutts, JeremyShaw and WouterSwierstra: PING.
23:30:02 <shapr> that would be duncan_, stepcut, and swiert
23:30:17 <Oejet> shapr: Thanks.
23:31:25 <shapr> Pseudonym: It sounds to me like the Cell cpu could profit more than the Itanium from that control -> data transform
23:31:37 <Pseudonym> Perhaps.
23:31:55 <Pseudonym> I'm not sure that the Cell can handle very fine-grained parallelism.
23:31:59 <Pseudonym> It hought it was more suited to SIMD.
23:32:09 <shapr> somewhat
23:32:15 * Pseudonym might be wrong -- haven't read much about the Cell
23:33:03 <shapr> the Cell is nine cores, a big mostly general purpose POWER cpu with very little cache / out-of-order / pipeline ability
23:33:30 <shapr> and eight simplified powerpc 604 cores with 256k 'ram' and 64k cache
23:33:33 <Pseudonym> OK, so it's just a multi-core thing, with different tradeoffs?
23:34:06 <SyntaxNinja> shapr:  any ideas here: http://www.scannedinavian.org/~ijones/cgi-bin/hello
23:34:09 <shapr> it does up to two instructions at once, but other than that it's pretty much in-order.
23:34:44 <Pseudonym> So why does it need eight cores?
23:34:47 <Pseudonym> Multi-threading?
23:34:58 <shapr> SyntaxNinja: [Thu Apr 07 08:27:13 2005] [error] [client 67.160.135.40] malformed header from script. Bad header=hello, world.: hello
23:35:06 <SyntaxNinja> oh hm
23:35:20 <shapr> I dunno, works in my homedir. http://www.scannedinavian.org/~shae/cgi-bin/Flippi.cgi
23:36:09 <shapr> The sidekick CPUs are designed for (dual precision?) floating point ops, Altivec iirc
23:36:35 <Pseudonym> Ah, so they're not symmetric.
23:36:45 <shapr> huh?
23:36:46 <Pseudonym> It's not eight cores all of which are the same.
23:37:10 <shapr> The eight sidekick CPUs are the same, the ninth core is designed to be the straw boss.
23:37:20 <Pseudonym> Oh, I see.
23:37:35 <Pseudonym> And the eight sidekick CPUs are floating point units only?
23:38:44 <shapr> The sidekick cpus can call the DMA controller to get data to/from main memory, but it seems likely that the straw boss will be doing most of the moving around, so the sidekicks can be a poor man's cluster.
23:39:36 <Pseudonym> Also sounds like a glorified superscalar architecture.
23:40:01 <Pseudonym> Except that the FPUs are synchronous.
23:40:02 <shapr> Doesn't superscalar mean heavy pipelining?
23:40:13 <Pseudonym> Superscalar means multiple operations at once.
23:40:16 <Pseudonym> I think.
23:40:18 <Pseudonym> @foldoc superscalar
23:40:19 <shapr> This is much of my info - http://arstechnica.com/articles/paedia/cpu/cell-1.ars/2
23:40:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "superscalar" foldoc "The Free On-line Dictionary of Computing (27 SEP
23:40:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 03)"
23:40:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- superscalar
23:40:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-      
23:40:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         <architecture> A superscalar architecture is a {uniprocessor}
23:40:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         that can execute two or more {scalar} operations in parallel.
23:40:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [10 @more lines]
23:40:28 <Pseudonym> @more
23:40:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         Some definitions include {superpipelined} and {VLIW}
23:40:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         architectures; others do not.  Superscalar architectures
23:40:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         (apart from superpipelined architectures) require multiple
23:40:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         {functional unit}s, which may or may not be identical to each
23:40:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         other.  In some superscalar processors the order of
23:40:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         instruction execution is determined statically (purely at
23:40:39 <shapr> Anandtech has more details, but so many adverts I can't bear to read it.
23:40:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         compile-time), in others it is determined dynamically (partly
23:40:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3 @more lines]
23:40:47 <Pseudonym> Sounds like it fits.
23:40:56 <Pseudonym> Eight floating point functional units.
23:41:26 <shapr> seems that the sidekicks can do iteger ops as well...
23:41:38 <shapr> "has a 128-entry register file (128-bits per entry) that stores both floating-point and integer vectors"
23:41:54 <Pseudonym> Makes sense.
23:42:14 <Pseudonym> There's probably no reason in this day and age why you need separate integer and floating point registers.
23:43:22 <shapr> The Cell's first use will be the PlayStation 3. I'd like to have a desktop box that has four of them though.
23:45:01 <mflux> apparently you still wouldn't be able to compile haskell code any faster?-o
23:45:35 <Lemmih> SyntaxNinja: It's now reading hackage.conf when ran. Moving on to automatic DB creation.
23:45:37 <Pseudonym> Well, except that it'll probably be a generally faster CPU.
23:45:46 <Pseudonym> i.e. faster than the previous POWER
23:46:11 <mflux> really? doesn't it sound more like that the central cpu is infact scaled down a bit?-o
23:46:12 <shapr> I think Haskell would be the perfect language for a bunch of Cell cpus. There's already array unrolling in Parr, SMP support via STM in GHC baseline is just starting.
23:46:54 <shapr> I suspect that parallel arrays would let you track the data dependency for a chunk of code well enough that you could make sure the sidekick cpus always have stuff to do.
23:47:26 <shapr> At a minimum you could add region allocation to get around most of the problems of NUMA garbage collection.
23:48:50 <shapr> Or maybe not.
23:49:58 <dons> @version
23:49:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p193, GHC 6.4 (OpenBSD i386)
23:49:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:50:00 <shapr> mflux: do you think that would work?
23:50:10 <theorbtwo> /ignore lambdabot
23:50:21 <theorbtwo> Damn, that wasn't supposed to show up.
23:50:25 <shapr> oops
23:50:46 <shapr> dons: hey, did you see musasabi's command suggestion yesterday?
23:50:58 <dons> what was that?
23:51:00 * dons checks the logs
23:51:53 <Oejet> theorbtwo: Are you using Gaim?
23:52:41 <Lemmih> Hmm HaskellDB can't show bool fields /-:
23:53:25 <shapr> Oh, the stick setting in lambdabot modules was there to keep from unloading important modules.
23:53:34 <cakoose> Is there a way to get a free "Show" instance for disjoint unions?
23:53:46 <cakoose> I just want it to print out the tag identifier.
23:53:50 <shapr> deriving Show ?
23:53:54 <dons> shapr, yep. I think TheHunter sorted it out.
23:54:10 <cakoose> shapr: Err...without doing it explicitly.
23:54:12 <Si\> dons, I wanted to ask you, is there any practical reason why hs-plugin shouldn't have a safe version of unsafeEval_ (i.e. one which allows command line customization etc.)?
23:54:34 <dons> oh, it should have an eval_ , yes.
23:54:50 <Si\> ok, just making sure I hadn't overlooked something
23:54:51 <shapr> cakoose: that's not explicit, is it?
23:54:53 <dons> you want customisation, + Typeable?
23:55:04 <Si\> yes
23:55:09 <cakoose> oh...I guess I don't know what you mean.
23:55:12 <dons> ok. I'll add it now.
23:55:17 <cakoose> so I just say "deriving Show" somwhere?
23:55:26 <Si\> for 2 reason, one so I can have overlapping instances and also so I can get back string errors
23:55:28 <shapr> cakoose: If you want more automatic than that, you could use the Template Haskell deriving code after you've lifted your module.
23:55:50 <shapr> Then you could derive everything for a module all at once.
23:55:51 <dons> Si\, yep. the errors are very useful.
23:56:09 <shapr> bit more work than typing 'deriving Show' though.
23:56:51 <cakoose> shapr: Just tried "derving Show"; that's what I was looking for, thanks.
23:56:52 <shapr> cakoose: data Foo = Bar | Baz deriving (Show, Read, Eq, Ord)
23:57:07 <Si\> that reminds me, has anyone done a TH deriver for Show?
23:57:19 <shapr> Have you seen Ulf Norell's IOHCC code?
23:57:24 <cakoose> shapr: BTW, that's a pretty rad feature.  I usually use a macro hack to do that for C enums.
23:57:33 <shapr> Other than being a slice of pure evil, it's extremely nifty code.
23:58:01 <Si\> yes, I expanded it for SYB3, I was just wondering if anyone had already done the same for Show
23:58:13 <cakoose> Is "deriving Show" thing part of the compiler?
23:58:15 <shapr> oh, don't know.
23:58:22 <shapr> cakoose: yes
23:59:18 <shapr> Man, lambdabot development has exploded into action! Yay!
