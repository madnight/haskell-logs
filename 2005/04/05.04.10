00:01:02 <skew> This talk of fancy math makes me wonder how much the code uses exoctica like monad transformers, and how much of an obstacle that is to people coming from perl to work on it
00:03:55 <skew> did you drop the version number -> 2Ï€ scheme?
00:04:37 <skew> oh, I didn't read quite well enough
00:07:17 <skew> you will have 6.2.0, 6.2.1, etc under the 6.2 milestone before 6.28.0 adds "Classes and traits"
00:12:54 <autrijus> right.
00:13:13 <autrijus> pugs uses lots of monad transformers
00:13:15 <autrijus> and GADTs
00:13:22 <autrijus> and a healthy dose of template haskell
00:13:38 <autrijus> and concurrnet haskell; STM interface is planned.
00:15:31 <autrijus> I think perl people are adapting quite fast :)
00:29:55 <sh10151> and just when I am leaving perl for ksh/awk/sed
00:33:45 <Khisanth> heh that seems a bit backwards :)
00:35:24 <mflux> sh10151, why not just pick the pure ksh/awk/sed-subset of perl and use that?-)
00:35:32 <sh10151> bad notation
00:35:39 <sh10151> no |&
00:36:50 <sh10151> bidirectional piping, that is
00:37:21 <sh10151> if someone has already done the lifting in perl, I will turn it into a filter/source/sink and use ksh to control it
00:37:32 <mflux> |& does bidirectional piping in ksh?
00:37:41 <sh10151> ksh93 anyway
00:37:46 <Khisanth> IPC::Open2, open2 - open a process for both reading and writing ? :)
00:37:49 <sh10151> can't remember if it is in ksh88
00:38:00 <sh10151> Khisanth: like I said, bad notation
00:38:07 <mflux> so left's stdout is connected to right's stdin and vice versa?
00:38:11 <sh10151> Khisanth: if that were good enough I would use just about anything
00:38:27 <mflux> or wha
00:38:28 <mflux> t
00:38:33 <sh10151> mflux: that wouldn't work :)
00:38:43 <sh10151> it's a pipe separate from stdin and out
00:38:58 <sh10151> access with read -p and print -p
00:39:06 <mflux> oh you mean coproceecss
00:39:15 <sh10151> yeah, them
00:39:16 <mflux> coprocess even, in zsh-terminology
00:39:31 <sh10151> zsh does it too?
00:39:32 <sh10151> cool
00:39:38 <sh10151> in any case
00:39:57 <Khisanth> then again, if you are mostly calling other processes to do things you probably shouldn't be writing it in Perl
00:39:59 <sh10151> perl gives me bizarre operators for datatypes/contexts/whatever you call them
00:40:13 <sh10151> and makes me spell out everything else in notation not much better than raw C calls
00:40:30 <sh10151> i want the operators to be high level
00:40:46 <Khisanth> hmm datatypes are quite different from contexts
00:40:56 <sh10151> well
00:41:17 <sh10151> let's just say that the semantics of $ % & @ in perl5 are still a black art
00:41:26 <sh10151> i have learned the incantations but i have not learned the rationale
00:41:31 <Khisanth> of course almost anything I say becomes invalid for perl6
00:41:46 <autrijus> there is this IPC::Run
00:41:48 <autrijus> and that IO::All
00:41:52 <autrijus> which you may be interested
00:42:40 <Khisanth> autrijus: but isn't shell more well suited for things consisting of mostly glueing other programs together?
00:43:03 <autrijus> Khisanth: I don't know, I find shell hard to refactor.
00:43:16 <sh10151> well now
00:43:19 <Khisanth> heh :)
00:43:27 <sh10151> refactoring is an entirely different can of worms
00:43:42 <sh10151> if I am doing something that gets "refactored" instead of "rewritten"
00:43:48 <sh10151> I don't use Perl or shell
00:43:51 <sh10151> :)
00:44:28 <sh10151> but for a lot of things I do, I can "refactor" into another filter on the pipeline
00:44:29 <autrijus> sad, because there is actually refactoring browser support for perl :)
00:44:55 <autrijus> but, if the tool works better for you, that's good enough
00:45:12 <sh10151> i like python for OO
00:45:20 <sh10151> but I don't find much need for OO
00:46:07 <sh10151> typical IT would be a lot less costly if people realized when they were working as plumbers vs. when they were working as building architects
00:46:23 <sh10151> everyone wants to be a building architect and no one wants to be a plumber
00:49:02 <autrijus> hrm, Data.IntMap and Data.Map are both finite?
00:49:26 * Khisanth wants to be neither :)
00:49:40 <sh10151> well
00:49:43 <Khisanth> since those metaphors tend to start breaking down pretty quickly
00:50:09 <sh10151> at some point a Map just becomes a function, no? As it approaches non-finitude?
00:50:30 <autrijus> sh10151: uh, I'm talking about implementation
00:50:33 <autrijus> not the concept
00:51:41 <sh10151> well yeah, and I am saying that a finite map with a promise for more values is just a function...
00:51:47 <sh10151> a memoizing function I suppose
00:52:06 <autrijus> yes, I know that.
00:52:41 <sh10151> just suggesting alternate terminology for InfiniteMap
00:52:49 <sh10151> memoize :)
01:02:23 <skew> autrijus: what do you want?
01:03:07 <skew> You could probably make an infinite Map if you looked at the internals (balancing might get in the way)
01:03:19 <autrijus> skew: I think I'm just going with vanilla IORef [Val] now.
01:03:23 <autrijus> sucks
01:03:35 <autrijus> but it looks the most sensible
01:03:42 <autrijus> maybe later on I'll investigate Lazy STRef
01:04:06 <skew> what does that have to do with Map?
01:04:22 <sh10151> how does haskell's memoization work?
01:04:26 <autrijus> skew: I'm selecting the type to use in Pugs to implement hash and array variables.
01:04:43 <autrijus> skew: they have to be in IO monad
01:04:55 <autrijus> normally HashTable and Array are natural choices
01:05:06 <autrijus> except in perl 6, both hash and array needs to be 1)lazy 2)infinite
01:05:51 <sh10151> by that i mean the memoization that gives me "take 5000 primes" very quickly the second time i call it.
01:06:17 <skew> sh10151: that's just lazy evaluation
01:06:21 <autrijus> facs = scanl (*) 1 [1..]
01:06:21 <autrijus> fac n = facs !! n
01:06:31 <autrijus> something like that.
01:06:45 <sh10151> well yeah but it's memoizing something somewhere
01:06:52 <skew> the first time the list primes hasn't been evaluated, and 5000 values need to be computed.
01:07:08 <sh10151> right, what does it do with the computed values?
01:07:22 <skew> you have a list called primes somewhere in the program
01:07:34 <skew> the values are in that list
01:07:52 <skew> In a semantic sense, primes is a list containing all the primes
01:08:21 <sh10151> got it
01:08:31 <skew> operationally, primes is represented in memory at the beginning of the program by a chunk of data describing how to compute primes begining from the first element
01:08:46 <sh10151> i remember now
01:10:04 <skew> incidentally, lazy evaluation gives you the sort of coprocessing you were talking about with |&
01:11:26 <skew> does anyone understand how to use wxHaskell? I'm having trouble getting a window to come out the right size.
01:11:55 <gzl> anybody familiar with Parsec? quick question.
01:12:02 <skew> I can probably help
01:12:57 <gzl> is there anything simple like noneOf but for a full string? for example, I want to accept [ but not [[
01:13:48 <skew> I don't think noneOf over the rest of input would be too useful
01:13:56 <skew> Maybe notFollowedBy would help?
01:14:26 <skew> or, if you want to accept both [ and [[ but process them differently you could just put [[ first
01:15:10 <gzl> no, i just want it to take [ like any other character. but i'll check out notFollowedBy
01:15:39 <skew> what are you trying to parse?
01:15:58 <gzl> wikitext.
01:16:12 <skew> I don't understand enough of the question. Is [[ a special sequence, but [ just an ordinary character?
01:16:16 <gzl> yes.
01:16:48 <skew> you might consider investing in a lexer
01:17:43 <gzl> hm, never used a lexer
01:19:06 <skew> you could do something along the idea of many (notFollowedBy (char '[') (char '[') || anyChar), but that isn't very pretty
01:19:15 <gzl> yeah, it starts getting nasty.
01:19:47 <gzl> i was hoping there might be something nice like noneOf ["[[", "#", "*"] or something.
01:19:57 <skew> actually, it might not be that ugly to build it automatically
01:20:14 <skew> what would your noneOf do, though?
01:21:08 <skew> I was thinking it would match and return any string except the ones listed, running to the end of file, by analogy with the one for Char
01:21:25 <gzl> oh, you're right. i see the problem.
01:21:33 <skew> but noneOf that returns () if none of those strings match and fails otherwise shouldn't be too hard
01:21:44 <gzl> yeah, I guess I can just write something to do this myself
01:22:20 <skew> still, you should look at alex
01:22:50 <gzl> the way I'm doing this, there's no way of using special formatting characters for anything besides formatting. so I couldn't have wikipedia's '''Bold''' syntax for example, because then you couldn't write anything with apostrophes :)
01:23:10 <gzl> but yeah, i'll check this out
01:23:16 <skew> I wonder if there is anything for this sort of parsing
01:23:49 <skew> it seems like what you want is a catch-all case that returns huge chunks of text that don't match anything else
01:24:00 <gzl> yeah, that would be good
01:25:14 <skew> hmm
01:25:16 <gzl> totally unrelated question -- do you happen to know something that can take small snippets of LaTeX and turn them into images?
01:25:32 <skew> how about latex?
01:25:42 <skew> Or do you have something against DVI images?
01:25:45 <gzl> i do.
01:25:50 <gzl> png would be nice.
01:26:01 <gzl> also, i'd like something that crops the page down
01:26:13 <skew> I don't know how to get the page size you want, but why not just run latex and convert the output?
01:26:13 <gzl> i don't want an 8.5 x 11 page with just "x^2" on it :)
01:26:21 <gzl> the page size is the major issue
01:26:25 <gzl> not the format
01:26:41 <gzl> (as you said i can just convert)
01:27:15 <skew> I think digging through enough LaTeX documentation would tell you how to set the page size
01:28:13 <gzl> i'll look through it, but i assumed it wouldn't be able to crop the page size to the size of the formula
01:28:53 <skew> TeX let's you do just about anything if you work hard enough
01:29:23 <skew> somebody wrote a Haskell parser to make a package that typesets haskell nicely, for example
01:29:37 <skew> but getting the size of an equation should be extremely easy
01:30:08 <skew> I know next to nothing about how TeX works, but it's based around stuffing everything into little boxes with different sorts of strechiness and stuff
01:30:22 <gzl> hmm, ok, i'll look into it
01:31:23 <skew> If I'm remembering things correctly there is some way of getting the size of of some text with two or three commands
01:32:52 <skew> Are there just a few special symbols you need to recognize for the wiki thing?
01:33:01 <gzl> yeah, not a huge number
01:33:05 <skew> I mean, a few fixed strings that are treated specially
01:33:10 <gzl> yes
01:33:27 <skew> Actually, the "fixed" is important not the "few"
01:33:42 <gzl> they're fixed
01:34:13 <skew> The easiest thing then is probably to write something on your own that splits up the text
01:34:26 <skew> That's more string processing than parsing anyway
01:35:09 <skew> I was hoping Alex might have some sort of catch-all case you could use, but I guess not
01:35:11 <gzl> ok
01:35:38 <gzl> oh, neat. there's this program "texvc" somebody wrote that does the whole thing.
01:35:44 <gzl> tex -> png
01:36:23 <gzl> that should make this fairly easy.
01:36:41 <skew> you don't know anything about lexers?
01:36:47 <gzl> not yet, sorry. :)
01:37:13 <gzl> normally i'd be willing to learn some, but the timeframe for this thing is too short
01:38:11 <skew> Basically, you give it a bunch of regular expressions, and then it breaks up your input into a list of matches by matching them in parallel at the start of the text and always taking the longest match, then repeating on the rest of input
01:39:18 <gzl> hm, ok
01:39:41 <skew> I was hoping Alex might have some way of also including chunks of text that don't include any matches to any of your patterns, in which case it would probably be worth learning
01:42:59 <gzl> i need to be getting to bed, but thanks for your help. i'll look into some of the suggestions tomorrow
01:43:34 <skew> I'll have a bit of code in a minute
01:48:40 <skew> @hawiki HaskellIrcPastePage
01:48:57 <skew> lambdabot: hello?
01:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "hawiki", try "lambdabot: @listcommands"
01:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
01:51:12 <dons> @paste
01:51:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
01:51:31 <skew> There's a shorter command yet.
01:54:26 <skew> gzl: look at the "lexText" function at the top of the page.
01:56:55 <gzl> skew: ok.
01:57:05 <skew> Writing noneOf and using many (noneOf specials >> anyChar) might be simplest for now.
01:57:14 <gzl> ok
01:57:36 <skew> That's just about what my code does, and you shouldn't need anything else unless that's too slow
01:57:46 <gzl> also, is there any simple way to do the equivalent of (try (string "\n") <|> eof) ? the types don't match, but basically i want to match on either a newline or the end of the document.
01:57:57 <gzl> yeah, i'll look through this, thanks
01:58:24 <skew> Why do you need to match that?
01:58:51 <gzl> because this thing is explicitly looking for newlines, and it fails if it's at the end of a document.
01:59:26 <skew> what do you do with newlines?
02:00:03 <gzl> i'm parsing a list. if it's in the middle of the doc, it'll be something like "text\n\n* foo\n* bar\n\ntext," but if there's one at the end, it's just "* foo\n* bar"
02:00:46 <gzl> the newlines are just a signal that the current item is done
02:01:22 <skew> Would it be hard to treat them as separators rather than terminators?
02:01:40 <gzl> hmm.
02:02:00 <gzl> let me see if sepBy does the trick. one moment.
02:02:12 <skew> (try (string "\n" >> return ()) || eof) should work too
02:13:21 <gzl> skew: yep, that works (only it's <|> not ||), thanks a lot
02:13:26 <gzl> didn't think of using >> return ()
02:14:17 <gzl> ok, now I really am going to bed. and i'll check out the code you pasted. thanks again :)
02:16:49 <skew> okay, getTextExtent says my string is 192 pixels wide. My window *is* 192 pixels wide, and the last few characters don't fit when I show the string
02:17:01 <skew> What is happening with this wxHaskell?
02:17:53 <Khisanth> different fonts maybe?
02:20:04 <skew> I'm not setting any fonts
02:20:38 <skew> I'm using withPaintDC on the panel that is going to do the drawing, and then getTextExtent on that DC
02:20:57 <skew> this is while I'm setting up the application, so that might be a problem
02:21:22 <theorbtwo> dons, anybody, I'm having more hs-plugins problems, though I'm not sure that it's not an "I don't know Haskell" problem.  I can't import loadObject.
02:21:28 <Khisanth> well I guess the font used calculate the size is not the same one used to display
02:23:18 <skew> Is there any sort of widget for displaying a bit of text?
02:23:47 <skew> I'm drawing a clock into a panel, and I want a text label of the current time underneath
02:24:01 <Khisanth> why not use a label then?
02:24:15 <skew> but the closest I could find was making a disabeled textEntry which looks ugly and only has space for a few characters
02:24:35 <skew> you mean "label" in the layout stuff? As far as I can tell, that's just for putting in static text
02:25:12 <dons> theorbtwo: looks like you've got an old hs-plugins.
02:25:17 <dons> what version is it?
02:25:19 <dons> 0.9.8?
02:25:22 <Khisanth> arg wait a minute this is wx right?
02:26:15 <Khisanth> I kept thinking you were using gtk :)
02:26:25 <theorbtwo> Nightly from a few days ago.
02:26:37 <dons> theorbtwo: hang on -- hs-plugins doesn't have a loadObject function, it has load.
02:27:11 <dons> (well, it does have a loadObject, but it's internal to Plugins.Load)
02:27:25 <theorbtwo> module Plugins.Load (...) doesn't export it?
02:27:30 <dons>  no.
02:27:34 <theorbtwo> Oh.
02:27:37 <dons> use load().
02:27:43 <dons> that's what it's for.
02:28:06 <dons> or if you want really simple, not dep chasing loadObject, use: loadModule :: FilePath -> IO Module
02:28:21 <dons> where'd you get the idea to use loadObject?
02:28:37 <theorbtwo> The problem is that it's not a haskell module; it's just C.
02:28:52 <dons> what is?
02:28:54 <theorbtwo> However, I depend on it, and it doesn't seem to be listed in the .hi.
02:29:02 <theorbtwo> UncodeC.o, which I'm trying to load.
02:29:12 <dons> do you want the foreign import ccall unsafe "loadObj" c_loadObj :: CString -> IO Bool
02:29:28 <dons> there's a loadObj function in the Linker.h file provided by the ghc rts.
02:29:54 <dons> how can you depend on a function that isn't visible ?
02:31:01 <dons> it sounds like you're doing something weird. can you explain more what you're trying to do?
02:37:32 <theorbtwo> Well, pugs uses a few C bits.  When load tries to load modules that depend on them, it can't find the symbols -- presumably the .o files given explicitly on the command line aren't included in the .hi file.
02:38:05 <dons> yeah. C depends aren't listed in .hi files - so hs-plugins can't find them magically
02:38:17 <dons> if they're listed in a package.conf file, it can deal with that.
02:38:25 <theorbtwo> Ah!
02:38:30 <jlouis> heheh, Brandon J. Van Every
02:38:35 <theorbtwo> That's a much better WTDI.
02:38:38 <dons> i.e. _cbits.o files.
02:38:49 <theorbtwo> Where can I find documentation on package.conf files?
02:39:23 <dons> another option is to load the C bits `by hand' by linking them statically.
02:39:36 <dons> package.conf stuff is specified in the ghc user's guide.
02:40:03 <dons> you'd add a field like: extraLibraries = ["HSbase_cbits"]
02:40:16 <dons> to the package.conf of the relevant .hs lib you want to load.
02:41:10 <dons> or you can use ld to link them into a .a file with the compiled .hs files you want, and then load that .a file.
02:41:27 <dons> (as a haskell library with an accompanying package.conf file)
02:41:45 <dons> this is in the slightly trickier end of hs-plugins usage
02:42:43 <autrijus> statically?
02:42:47 <autrijus> pugs compiles with -static already
02:43:27 <autrijus> but I imagine pcre.o is like _cbits.o and needs to be loaded by hand
02:43:40 <dons> well, it can be done automagically with a package.conf file
02:43:45 <dons> loadPackage     -- load a ghc library and its cbits
02:44:14 <dons> so you treat the .hs-.o files as a haskell lib, with an accompanying package.conf which specifies the cbits
02:44:18 <autrijus> which means we need to write a package.conf for pugs
02:44:19 <skew> jlouis: what does that mean? Is he giving my name a bad name again?
02:44:32 <autrijus> would it work in the klugy way of exposing loadObject forcefully
02:44:34 <autrijus> and use that?
02:44:56 <autrijus> if it would, I'd like to test to see that way works first
02:45:25 <dons> I think loadObject would probably work.
02:47:01 <autrijus> would you consider exposing it? :)
02:47:05 <autrijus> it's not like it's unsafe.
02:47:17 <dons> it does work in fact, that's how loadPackage works.
02:47:23 <dons> mapM_ (\l -> loadObject l (Package (mkModid l))) libs
02:47:29 <autrijus> cool.
02:47:29 <dons> where libs = hslibs ++ extralibs
02:48:28 <dons> I originallly hid it for a reason, but  I might expose it as 'loadCobj' or so.
02:48:37 <autrijus> that'd be appreciated.
02:49:01 <dons> loadModule is for .hs, I hadn't thought of this scenario - where you want to avoid a package system
02:49:17 <dons> ok. I'll hack it up now.
02:49:18 <autrijus> right, eg. for really lightweight adhoc plugins
02:49:20 <autrijus> dons++
02:49:21 <autrijus> dons++
02:49:31 <dons>  you can use @karma for that ;)
02:49:36 <autrijus> @karma dons
02:49:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 1
02:49:39 <autrijus> @karma dons +1
02:49:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 1
02:49:40 <theorbtwo> @karma+ dons
02:49:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons's karma has been incremented
02:49:51 <autrijus> @karma+ dons @karma+ dons
02:49:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons's karma has been incremented
02:51:49 <wilx> @karma dons
02:51:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 3
02:51:52 <wilx> Wow!
02:52:28 <xerox> 'morning
02:52:42 <shapr> good morning #haskell!
02:52:47 <autrijus> greetings shapr-san!
02:53:07 <skew> hi shapr
02:53:17 <shapr> It's time to code!
02:54:22 <zamez> always!
02:55:10 <skew> do we now have anybody that understands wxHaskell, or knows of a nice event driven networking library for C?
02:58:34 <skew> my wxHaskell program segfaults whenever I kill the window
03:02:25 <dons> ok. that seems to work.
03:02:37 <vegai> there is something built on libevent, but I don't know about the nice part
03:04:52 <dons> morning TheHunter
03:05:04 <TheHunter> morning dons.
03:06:17 <dons> hey basti_ - how emacs/yi going?/
03:06:27 <basti_> dons: oh i had a talk with stepcut about it
03:06:38 <basti_> hi btw.
03:06:45 <dons> yeah - did you work anything out?/
03:07:00 <basti_> well i have some halfway decent C-x support now
03:07:04 <dons> cool!
03:07:07 <basti_> (as in, feedback works)
03:07:18 <basti_> i just realized that i need a flat list of wacko modes
03:07:24 <dons> do you want to darcs send me what you've got?
03:07:29 <basti_> (C-x M-x, C-x C-f etc.)
03:07:45 <dons> so they introduce their own sub-mappings?
03:07:48 <basti_> its not a diff btw.
03:07:48 <basti_> ;)
03:07:51 <basti_> yes something like that
03:07:56 <basti_> to unify it
03:08:03 * shapr wants a copy too
03:08:08 <dons> yep. then you need a bunch of sub-modes/wacko modes ;)
03:08:16 <dons> "its not a diff" ?
03:08:20 * basti_ writes a few comments
03:08:24 <basti_> in fact its a rewrite.
03:08:25 <basti_> ;)
03:08:30 <dons> that's fine!
03:08:31 <basti_> ;)
03:08:43 <dons> the old code was totally bitrotted.
03:09:06 <dons> there was perhaps 3 months of furious eyeball peeling hacking, and that code got neglected
03:09:06 <basti_> I'm just writing a few comments ok?
03:09:17 <dons> yep. comments are good :)
03:09:45 <dons> @karma+ basti_
03:09:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- basti_'s karma has been incremented
03:12:08 <autrijus> forM :: (Monad m) => [a] -> (a -> m b) -> m [b]
03:12:09 <autrijus> forM = flip mapM
03:12:09 <autrijus> forM_ :: (Monad m) => [a] -> (a -> m b) -> m ()
03:12:09 <autrijus> forM_ = flip mapM_
03:12:22 <autrijus> is it sane? am I reinventing the wheel? :)
03:12:56 <skew> I just wrote some code with flip mapM_
03:13:23 <basti_> lol
03:17:47 <basti_> soooo... where to darcs send?
03:18:04 <basti_> and how?
03:18:06 * basti_ still new to darcs
03:18:08 <dons> darcs send
03:18:10 <dons> should do it
03:18:31 <basti_> hm
03:18:32 <basti_> -.-
03:19:02 <basti_> No recorded local changes to send!
03:19:07 <basti_> basti@deunan:~/yi$ darcs add Yi/Keymap/Emacs.hs
03:19:15 <basti_> The following file is already in the repository;
03:19:15 <basti_> note that to ensure portability we don't allow
03:19:15 <basti_> files that differ only in case:
03:19:21 * basti_ .oÂ° ( ? ) 
03:19:30 <ibid> basti_: is it really a new file?
03:19:40 <basti_> its not.
03:19:44 <ibid> don't add it then
03:19:44 <dons> you don't add Emacs.hs - it's already there.
03:19:49 <basti_> but its not being recognized add changed???
03:19:50 <basti_> as
03:19:54 <dons> so darcs record --all Yi/Keymap/Emacs.hs
03:19:54 <basti_> lol
03:19:54 <ibid> darcs record
03:20:04 <dons> or other files too if you've touched them.
03:20:11 <basti_> no i havent
03:20:13 <ibid> no need to list the file :)
03:20:30 <dons> (I just didn't want to get a bunch of other changes that were incidental ;)
03:20:34 <ibid> if you don't use --all, either, it'll show you what you're recording
03:20:44 <basti_> ahhh
03:20:53 <dons> darcs rocks!
03:20:54 <basti_> okay, it tried to send
03:20:56 <basti_> darcs failed:  failed to send mail to: Don Stewart <dons@cse.unsw.edu.au>
03:20:58 <basti_> -.-
03:21:07 <dons> ? no idea.
03:21:12 <basti_> probably a local problem
03:21:17 <dons> maybe you don't have mail working.
03:21:20 <basti_> yes.
03:21:22 <dons> you can: darcs send -o /tmp/f
03:21:28 * basti_ never buried the mail server hatchet
03:21:29 <dons> then mail /tmp/f to me however you can.
03:21:47 * basti_ nods
03:22:04 <dons> make sure to attach it, and not copy and paste or anything like that ;)
03:22:08 <basti_> yes.
03:22:10 <dons> mucho bad karma
03:23:43 <basti_> sent
03:23:54 <dons> arrived!
03:24:01 <basti_> isnt email cute?
03:24:20 <dons> hehe
03:25:40 <dons> hehe. irc logs as comments ;)
03:25:43 <basti_> :)
03:26:42 * basti_ sighs.
03:27:00 <basti_> smtp organisation is definitely uncute though.
03:30:11 <ibid> hm, what file type is .hcr?
03:30:17 <dons> basti_, thanks for the patch. feel free to keep hacking.
03:30:21 <dons> .hcr is external Core.
03:30:24 <ibid> ok
03:30:42 <dons> my all-time favourite language ;)
03:30:58 <basti_> dons: i will.
03:32:26 * dons has so many patches arriving now it would be hard to keep up without darcs
03:32:36 <dons> diff -u /patch would really suck
03:37:07 <dons> theorbtwo: latest snapshot has loadRawObject which might help you.
03:39:04 <theorbtwo> Cool.
03:52:06 <skew> Using start just once fixed my segfault.
03:52:14 <autrijus> now I keep hitting GHC bugs :-/
03:52:41 <dons> yeah?
03:52:42 <xerox> poor autrijus :(
03:52:48 <autrijus> *** Exception: expectJust upsweep_mod:old_linkable
03:53:00 <autrijus> and also the familiar "impossible: fromNothing"
03:53:05 <dons> it's not a bug if it's thrown ;)
03:53:09 <autrijus> or was it fromJust: Nothing
03:53:21 <xerox> fromJust: I think
03:53:23 <autrijus> eh, it killed :r in ghci :)
03:53:49 <dons> ah!
03:54:08 <theorbtwo> Hm, after using some loadRawObjects, I get...
03:54:12 <autrijus> for both of them, "make clean" + re "make" works
03:54:13 <dons> ok. that looks like the compilation manager complaining
03:54:14 <theorbtwo> pugs: /usr/src/pugs/blib6/arch/CORE/pugs//Internals.o: unknown symbol `__stginit_Compat_'
03:54:15 <autrijus> but is annoying.
03:54:24 <theorbtwo> (And I see no reason that shouldn't be in the .hi files.)
03:54:35 <autrijus> theorbtwo: have you made a "make install"?
03:54:42 <autrijus> Compat.hs was renamed from Posix.hs pretty recently
03:54:43 <dons> you can use ghc --show-iface to check, theorbtwo.
03:54:50 <autrijus> and your old .hi may be outdated
03:55:05 <theorbtwo> Shouldn't need to; I'm running off of of the blib6 dir.
03:55:13 <dons> do you have a depends rule in the makefile for .hi files?
03:55:21 <theorbtwo> But I'll make sure I'm from proper a clean.
03:55:26 <autrijus> currently I use ghc --make
03:55:27 <theorbtwo> Er, s/nonsense/sense/
03:55:31 <autrijus> which should handle it
03:55:36 <dons> yep.
03:56:19 <dons> @quit more code
03:56:30 <dons> @version
03:56:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p217, GHC 6.4 (OpenBSD i386)
03:56:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:56:43 <skew> @karma dons
03:56:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 4
03:56:58 <autrijus> @quit can I use it too?
03:56:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
03:57:03 <autrijus> cool
03:57:22 * theorbtwo should fix NOTIFY in Gaim, but is too lazy.
03:57:32 <skew> I thought karma wasn't persistent
03:57:38 <dons> if you find out how, add it to the wiki page
03:57:48 <dons> skew: thanks to the heroic TheHunter, it now is.
03:57:57 <theorbtwo> Nope, cleaning didn't help.
03:58:23 <xerox> Someone reported the "bug" to #gaim people I think.
03:59:00 <theorbtwo> Nifty.  I haven't followed gaim development in several years, and was hoping to avoid going back.
03:59:11 <dons> @wiki Lambdabot/Notices
03:59:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/Lambdabot/Notices
03:59:25 <dons> not quite.
03:59:41 <dons> @wiki Lambdabot_2fNotices
03:59:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/Lambdabot_2fNotices
03:59:57 <dons> bah.
04:00:13 <theorbtwo> @wiki LambdaBot/Notices
04:00:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
04:00:15 <xerox> Do we need an urlEncode?
04:00:19 * shapr was just wondering that
04:00:25 <dons> hmm..
04:00:45 <xerox> Or even support for / in urls, for the wiki..
04:01:02 <shapr> that would be more difficult
04:01:20 <theorbtwo> I think the wiki should check for a matching page case-insensitively, and redirect if it finds one.
04:01:34 <theorbtwo> (Note that "my" link works; it isn't the problem you think it is.)
04:02:12 <dons> yep.
04:02:13 <shapr> wow
04:02:57 <xerox> "I'm a *private* logbot." ?
04:03:01 * dons is in to his 11th hour of .hs hacking for today :}
04:03:27 <dons> hmm.
04:03:39 <skew> That page breaks my hawiki firefox keyword. firefox escapes the '/', and the Wiki doesn't recognize the page name
04:05:15 <theorbtwo> Hm, possibly the wiki should recognize it either way, though that does imply that you can't put a literal / in a node name.
04:08:54 <theorbtwo> The hawiki seems to have an odd idea of what time it is.
04:10:10 <shapr> I'd guess it's set for GMT, and you set your time offset when you create a HaWiki account.
04:10:25 <shapr> If the time is seriously off, I'll talk to the sysadmins.
04:10:33 * shapr looks
04:11:28 <shapr> If it's the wiki that's confused, I'll fix it.
04:22:08 <basti_> shapr: i sent dons my Emacs.hs
04:22:58 <shapr> yay
04:23:13 <dons> basti_: maybe you'd like to add --as=emacs to Yi.hs
04:23:57 <basti_> uh.
04:24:25 <shapr> hiya perdix, have you already gotten your copy of the proselytization literature?
04:24:47 <perdix> shapr: hi, err, huh?
04:24:57 * Lemmih wishes he knew more about the inner workings of Cabal and apt-get.
04:24:57 <shapr> Typing the word proselytization is almost as much fun as typing Paratheoanametamystikhood of Eris Esoteric.
04:25:16 <shapr> perdix: Hi, are you learning Haskell?
04:25:22 * shapr grins
04:25:49 <perdix> shapr: I believe that words containing "meta" are usually evil, but thanks for that info :-p
04:25:55 * shapr snickers
04:26:03 <perdix> shapr: yes, I'm always learning haskell
04:26:14 <shapr> Cool, do you have any questions? Anything I can help with?
04:26:44 <metaperl> "I believe that words containing "meta" are usually evil, " --- as in metaperl???
04:26:58 * metaperl glares at the monitor
04:27:02 <skew> words containing perl are evil too :)
04:27:02 <perdix> not yet, but I'll get back to you when I can see what dw did w.r.t. Isabelle/HasCasl
04:27:06 <metaperl> lol
04:27:07 * shapr glares at metaperl's monitor also
04:27:21 <metaperl> oh so I am doubly evil? FINE!!!! I can take a hint! I'm leaving
04:27:22 <dons> basti_: I just added --as=emacs to the list of --as=foos
04:27:26 * shapr hugs metaperl
04:27:31 <metaperl> lol
04:27:38 <shapr> Some of us still love you! Don't abandon us now!
04:27:40 * shapr sniffles
04:28:17 * pesco stretches.
04:28:21 <shapr> "Tune in next week for the next episode of as the redex normalizes"
04:28:22 <pesco> Good morning, #haskell.
04:28:28 <shapr> y0 pesco!
04:28:42 <perdix> metaperl: I think it was Jean-Yves Girard who first said that...
04:28:43 <pesco> Yo. You're shooting a series?
04:28:54 <shapr> Yeah, and the series keeps shooting back.
04:29:03 <pesco> Ouch.
04:29:04 <basti_> dons: that is fine. I do not know what you're talking about, but I'm sure you did the right thing.
04:29:16 <basti_> :)
04:30:04 <shapr> I'd guess it means "yi, please act like emacs"
04:30:27 <basti_> i think so too, but i didnt find the "list of --as=foos".
04:30:36 <shapr> perdix: Are you working on HasCasl?
04:30:40 <vegai> will yi have a true form?
04:30:49 <vegai> I mean... will yi ever act like yi?
04:31:06 <shapr> Yes, but it requires a keyboard that can type lambda calculus directly.
04:31:07 <perdix> shapr: I've been working on it for half-and-a year, now I'm having a time-out :)
04:31:17 <basti_> the tao we're talking of, is not the true tao.
04:31:18 <basti_> :)
04:31:37 <perdix> shapr: I guess I'll get back to it for my thesis
04:31:38 <shapr> perdix: Are you Lutz?
04:31:45 <dons> I guess yi will eventually get augmented with useful bindings for Haskell
04:31:50 <dons> and then we will see its true form
04:31:55 <perdix> no, I'm Martin. Lutz is my favorite instructor :)
04:32:08 <shapr> Ah, ok.
04:32:14 <shapr> Hi, I'm Shae.
04:32:15 <dons> btw,             --as=[editor]    Start with editor keymap
04:32:16 <perdix> guess I won't be mentioned anywhere anyway ;)
04:32:18 <shapr> Nice to meet you.
04:32:26 <basti_> =)
04:32:37 <perdix> shapr: Shae, as in editor-of-the-monad.reader? glad to meet you too :)
04:32:43 <theorbtwo> Hi, I'm James.
04:32:49 <theorbtwo> (But I'm nobody important.)
04:33:02 <perdix> theorbtwo: neither am I :p
04:33:03 <shapr> Yes, I'm that Shae. I do a few other things too, like the Haskell Wiki.
04:33:30 <perdix> shapr: .. and research about spears...
04:33:31 <theorbtwo> Probably the biggest Lambadite to hang out on #perl6 regularly.
04:33:32 <shapr> I'm also not important, but I suspect if we get enough unimportant people together, we are important as a group.
04:33:43 <dons> hehe
04:34:06 <shapr> perdix: Heh, yes. That was a very silly joke.
04:34:09 * shapr blushes
04:34:41 <dons> how's Control.Spears going anyway, shapr?
04:34:50 <shapr> Britney sued me :-(
04:35:04 <dons> doh.
04:35:12 <shapr> The MPAA and the RIAA have gotten in on the act, since Control.Spears could be use for p2p distribution of music.
04:35:26 <shapr> And now I've left the country to seek asylum in Sweden.
04:35:26 <theorbtwo> shapr++
04:35:31 <shapr> It's terrible.
04:35:31 <dons> ah, of course. curse them!
04:36:00 * shapr laughs
04:36:37 <perdix> dons: won't they sue over that as well?
04:37:12 <shapr> I am a font of silly jokes.
04:37:46 <theorbtwo> Serif, or sans?
04:38:02 <shapr> Both, as long as they're high quality bitmaps.
04:38:54 <theorbtwo> bitmap fonts?  Ugh.
04:39:29 <shapr> I haven't tried HasCASL, and I'm not really sure what an algebraic specification language does. Is it sort of like QuickCheck's algebraic specifications in the QuickCheckST paper?
04:40:21 <perdix> kinda, but it lets you really prove stuff instead of just testing a lot
04:41:23 <friedo> what's a good book for learning Haskell?
04:41:26 <shapr> Does HasCASL call an external proof assistant like Coq or Alfa? or does it include its own?
04:41:33 <perdix> actually you just state properties and hope integration w/ Isabelle gets done fast ^^
04:41:48 <dons> hehe
04:41:51 <perdix> I think they're going for Isabelle, Lutz is a great fan of it
04:42:17 <shapr> Greetings friedo. If you want to buy a book, I like Hudak's "Haskell: School of Expression" and Thompson's "Craft of Functional Programming"
04:42:26 <perdix> I have no actual knowledge of any roadmap though
04:42:45 <friedo> shapr, I was looking at the Thompson book on Amazon - it looked pretty good.
04:42:48 <shapr> @learn
04:42:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/learning.html
04:43:03 <shapr> You can find a list of hardcopy books and online material on the learning page.
04:43:19 * jlouis had a look at MUD economies today
04:44:02 <vegai> has anyone used Cabal's 'runTests' hook?
04:44:42 <shapr> friedo: If you know and can use basic algebra and basic geometry, I'd suggest Hudak's book. Thompson's book makes no such assumptions, but then you don't get to do fun ascii graphics and music.
04:45:28 <friedo> thanks shapr.
04:46:08 <shapr> autrijus has mentioned that the Rabhi & Lapalme functional algorithms book is also good for starting, but I got that book too long after I started to be a good judge myself.
04:47:59 <shapr> friedo: Would you like to see the Baskin-Robbins one free spoonful intro to Haskell?
04:48:27 <friedo> shapr, sure
04:48:34 <shapr> @wiki HaskellDemo
04:48:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellDemo
04:49:31 <shapr> That's the quickstart guide for those with short attention spans (like me!). It should give you a good idea of the syntax and how the most basic parts work in as little time as possible.
04:49:45 <shapr> Though I haven't yet integrated the latest ideas from Alias
04:50:55 <friedo> so am I correct in assuming the "multi-arg function" example is really just currying?
04:52:05 <shapr> Yes, that's correct.
04:52:17 <friedo> groovy
04:52:29 <friedo> i've recently been messing around with currying in Perl
04:52:41 <friedo> which is what got me interested in functional stuff in general
04:52:43 <shapr> The partial appliction in the next step gives more evidence of that.
04:52:50 <friedo> yeah I just saw that
04:53:31 <theorbtwo> shapr, I'd appreciate if you could look at the current External/Haskell.hs, and see what I messed up.
04:53:50 <shapr> I can look, but no promises I can fix anything.
04:57:19 * shapr installs the latest hs-plugins
04:59:38 <johs> Is Cabal kind of like Python's distutils? (If anyone here is familiar with that.)
04:59:50 <shapr> Yes, that was the original idea.
05:00:54 <johs> So I can just write Cabal description files instead of makefiles, then?
05:01:06 <johs> Never mind, I'll just RTFM.
05:01:07 <shapr> theorbtwo: Do you still get the problem with posix package hiding?
05:01:48 <shapr> Ah, I guess not.
05:02:46 <theorbtwo> No, it's been renamed from Posix to Compat.
05:03:01 <theorbtwo> I do have the problem with Eval hiding, which is what the makefile patch was for.
05:04:02 <shapr> Do you get the "Couldn't match `IO' against `[]'" error?
05:05:54 <theorbtwo> Exactly.
05:06:44 <theorbtwo> (I'm not exactly clear how smart it was to break the compile...)
05:06:49 <shapr> try this - LoadFailure _   -> error ("load of extern__"++name++" failed")
05:07:39 <shapr> I can just check that in
05:09:12 <shapr> ok, I'm checking it in.
05:09:39 <theorbtwo> Oh!
05:09:44 <shapr> friedo: perl6 is a great way to combine your interests in Perl and functional stuff.
05:09:48 <theorbtwo> I thought the error was somewhere else completely!
05:10:02 <shapr> Pair programming is so handy :-)
05:10:23 <theorbtwo> Woo!
05:10:31 <metaperl> here is my upcoming talk on perl functional programming (actually more on slurpy params): http://www.metaperl.com/talks/p6-fp-slurpy/
05:10:34 <theorbtwo> It no longer dies at all!
05:10:39 <metaperl> perl 6 functional programming
05:10:57 <metaperl> hit space bar to advance between slides to see perl 5 equivs of the perl 6 code
05:13:41 <xerox> I can recognise the Haskell underneath your examples!
05:14:02 <metaperl> I didnt actually write the perl6 examples... stevan did
05:15:05 <friedo> metaperl, have you seen MJD's new book yet?
05:15:13 <metaperl> no i dont friedo
05:15:23 <shapr> metaperl: can I link to this on lambda the ultimate?
05:15:27 <friedo> metaperl, you should check it out. it's superb.
05:15:37 <metaperl> sure, the URL is not going to change shapr
05:15:43 <shapr> spiffy
05:15:53 <metaperl> everyone says it is. I am waiting for it be free online friedo
05:16:31 <metaperl> shapr: here is my previous p6 talk on "junctions" : http://www.metaperl.com/talks/p6-junctions/
05:17:00 <metaperl> shapr, maybe I should put these slides on ScannedInAvian?
05:17:07 <shapr> sure, if you want.
05:17:23 <xerox> How do you create those we slides?
05:17:29 <metaperl> cuz I dont do much there but metaperl.com gets buffeted about
05:17:34 <metaperl> xerox, I used PLies
05:17:46 <metaperl> http://www.metaperl.com/talks/p6-junctions/
05:18:14 <metaperl> you can run perl inside of your slides to generate text for them
05:18:32 <metaperl> so all the perl code is on disk and I just run a little incfile() sub to inline them
05:18:39 <metaperl> ooops
05:18:45 <metaperl> http://www.rot13.org/~dpavlin/PLies.html
05:18:53 <xerox> I see
05:28:43 <metaperl> shapr, all of the p6 code in my talk links to the examples directory in Pugs... so they cant be remade on ScannedInAvian without pugs being symlink-able
05:33:44 <multi_io> does the "unique" function on slide7 really work?
05:34:17 <metaperl> yes... it did work. I tried it
05:34:33 <multi_io> I would think one needs a list of already found non-unique members?
05:34:36 <multi_io> hm
05:35:18 <multi_io> unique(5,5,4) == unique(5,4) == (5, unique(4)) == (5,4)
05:35:24 <multi_io> ?
05:35:49 <multi_io> (I don't know much of Perl6)
05:35:58 <metaperl> unique 5 5 4 would return (4)
05:36:12 <metaperl> I think ... I'm kinda sleepy
05:37:13 <metaperl> terry@Abulafia:~/haskell/pugs/pugs/examples/fp$ pugs unique.p6
05:37:13 <metaperl> ... member
05:37:13 <metaperl> 1
05:37:13 <metaperl> 0
05:37:13 <metaperl> 1
05:37:13 <metaperl> ... unique
05:37:15 <metaperl> 5, 1, foo, 3, 4, bar
05:37:17 <metaperl> 3, 2, 4, 1
05:37:19 <metaperl> 1
05:37:21 <metaperl> foo
05:38:04 <metaperl> multi_io, this is the program that generated that output: http://www.hcoop.net/~terry/haskell/pugs/pugs/examples/fp/unique.p6
05:39:37 <perdix> is there a nice way other than pugs to get into template haskell?
05:43:22 <multi_io> hmmm, so 1 is unique in (1, 1, 1, 1, 1, 1, 1, 1) ?
05:44:16 <multi_io> not my definition of "unique" ;)
05:45:15 <pesco> What does the (chinese?) symbol on the yi homepage mean?
05:50:12 <shapr> pesco: It's Yi, the Han ideograph of the source of all righteousness in Confucianism.
05:50:40 <pesco> Wow.
05:50:45 <pesco> Thanks for the info.
05:51:25 <shapr> I forget the unicode number, but you can find it on the wikipedia Confucianism page, I think.
05:51:25 <pesco> Source of all righteousness. Cool.
05:52:01 <pesco> Now that I'm back on MacOS X I'm finally going to try Yi.
05:52:43 <pesco> Hah! There's no darwinport for it yet!
05:52:53 <pesco> I'm going to become a contributor. :)
06:02:04 <multi_io> metaperl: oh, so I misunderstood what unique was supposed to do
06:02:34 <multi_io> I thought it was supposed to return all elements that occur only once
06:33:37 <shapr> pesco: the symbol is on the front page of the YiWiki - http://www.scannedinavian.org/YiWiki/FrontPage
06:35:34 <pesco> Ah.
06:52:46 <shapr> The guys on #perl6 found the largest Haskell error I've seen yet. With -dcore-lint and -debug, the optimizer does something evil with GADTs. Without optimization, it works fine.
06:53:54 <shapr> The strange thing is that it happens with a module that doesn't use GADTs, so maybe it's something inside GHC itself?
06:54:32 <shapr> pesco: hey, did you look at Oleg's module writings? Did you understand them? =)
06:57:05 <Lemmih> s/Haskell error/GHC error/
06:57:19 <shapr> right, good point.
06:58:34 <shapr> The error is fifteen thousand three hundred and forty nine lines long.
06:59:06 <xerox> O_O
06:59:22 * xerox fightenens
06:59:24 <theorbtwo> Well, I think it includes a complete copy of pugs' AST.hs, in GHC's AST form.
07:07:20 <pesco> shapr: No, I've not had time to anything but skip it. But it's open in my browser window and flagged as "read before proceeding".
07:07:31 <pesco> s/skip/skim/
07:09:05 <shapr> haha
07:09:30 <shapr> I tried to do that, but I ended up with so many tabs my browser crashed.
07:10:05 <pesco> Haha.
07:11:07 * pesco tries to install hs-plugins for the third time.
07:12:10 <shapr> hiya dominic!
07:12:14 <poetix> hi
07:12:56 <shapr> pesco: I used the the latest nightly, "autoreconf && ./configure && make"  then as root "make install && make register"
07:13:07 <Arafangion> shapr: Show's dominic?
07:13:15 <shapr> Huh? show?
07:13:25 <Arafangion> *Who's* :)
07:13:28 <poetix> quick question - if I go get GHC 6.4, is there already some cabal stuff packaged up with it?
07:13:31 <poetix> me's dominic
07:13:34 <poetix> I mean, I is
07:13:37 <Arafangion> Darn peculiar letter mixup!
07:13:40 <shapr> poetix: I'm slowly getting my head wrapped around your idea of less stateful persistent web publishing.
07:13:51 <shapr> poetix: yes, 6.4 comes with and requires cabal.
07:14:09 <pesco> shapr: The problem was not in hs-plugins but the darwinport which didn't register it properly.
07:14:10 <shapr> Which is why it won't install packages that don't use cabal yet.
07:14:18 <shapr> oh, ok.
07:14:25 <poetix> Is there a package browser for cabal?
07:14:42 <shapr> Lemmih is working on one, there's a web version and a local wxHaskell version.
07:14:43 <pesco> Hackage is supposed to become that. I take it?
07:14:54 <shapr> Yes, hackage is the web-based package browser.
07:15:11 <pesco> Oh, it's not the name of the database in general?
07:15:14 <Lemmih> Hackage is more than that.
07:15:25 <pesco> Oh, hi Lemmih. :)
07:15:41 <poetix> wget or darcs for package retrieval?
07:15:46 <shapr> poetix: for one thing, I've realized that the only reason Python needs to persist the entire object and its data is that the object can be arbitrarily modified after creation, more like a prototype oriented language for functionality.
07:16:11 <shapr> SyntaxNinja has discussed the idea of darcs for packages.
07:16:20 <Igloo> darcs shouldn't be needed for real releases
07:16:46 <shapr> Right, but if packages include a darcs repo, and you have darcs installed, submitting patches would be so smooth.
07:17:09 <Igloo> The tarball could include an _darcs
07:17:15 <poetix> I guess that might vary from package to package, depending on development process etc
07:17:28 <Igloo> Or there could be a way to ask for a darcs checkout instead of a tarball
07:17:39 <Igloo> But requiring darcs would quite bootstrapping issues needlessly
07:17:45 <shapr> Yeah, I agree.
07:17:49 <Igloo> s/quite/create/
07:19:27 <shapr> poetix: Have you read about the CGI arrow (and its problems) in John Hughes' original arrows paper? Josef Svenningsson has a version of arrows that might fix those problems.
07:19:32 <poetix> shapr: when an object is modified after creation, I would guess that usually either the data or the functionality is altered, but not both at once
07:19:42 <poetix> shapr: so not up to speed on arrows...
07:20:39 <shapr> In my experience, lots of functionality gets modified after creation with Archetypes at least.
07:21:02 <shapr> Thought that may be only in the development/upgrade cycle.
07:21:51 <shapr> But you can easily end up with instances that no longer have their class definitions available, and yet still work (unless you need to scrape them out of the ZODB, in which case, you have found purgatory).
07:23:18 <shapr> So even a short step towards full separation of data and functionality would make my Zope/Plone work easier.
07:23:31 <poetix> I find I want to treat persistance, data management and code organisation as orthogonal. Objects are a code organisation detail; they're not a great fit for data management, although pickling gives them a headstart with persistence.
07:24:25 <poetix> Not to be an RDBMS zealot - there are other data management methods, and other kinds of persistent store - but those are not areas where I want to be object-centric. It turns out to be less than convenient in the longer run.
07:24:26 <shapr> I think you're right, I've been mulling over your comments that RDBMSs have those two separate major functions.
07:25:02 <shapr> Your point that temporary data could need persistence but not management is telling there.
07:25:36 <poetix> It might need only rudimentary management - hashkey retrieval - and not the more general mechanisms provided by an RDBMS
07:26:36 * poetix wonders whether hs-plugins could be used to persist and retrieve compiled Haskell object code from pickles of some kind
07:26:41 <jlouis> RDBMSs have which 2 separate functions?
07:27:26 <skew> poetix: persisting code might be a bit tricky
07:28:01 <poetix> I guess hs-plugins doesn't expose object code at the level where you could serialize it.
07:28:08 <skew> If you understood the GHC internals much better than I, it might be possible to scrape some code out of the heap
07:28:50 <shapr> hs-plugins does let you load and run code at runtime, but you can't really migrate compiled anything to another box.
07:28:57 <poetix> Maybe some encapsulated pickling mechanism could be added to it, so you can store and retrieve but not inspect directly
07:29:11 <poetix> The alternative I guess would be to store plaintext, and evaluate on demand
07:29:39 <shapr> The Yi editor has a cool feature where you can edit Yi itself, and use the :reboot command to save the editing state, rebuild the editor, reload the pieces of the editor, and reload editing state, in 0.2 seconds.
07:30:02 <skew> It would be nifty to persist a value without needing to force it
07:31:11 <skew> the return value of hGetContents would be trouble
07:31:13 <pesco> shapr: I'm getting the feeling I'm going to like Yi.
07:31:13 <shapr> musasabi wrote SerTH, which uses Template Haskell to automatically derive serialization for basic types.
07:31:50 <poetix> I really must look at Yi...
07:32:31 <shapr> Yi has a lot of nifty features.
07:33:26 <pesco> Oh, grand, it wants me to build GHC before installation of hs-plugins will work. :/ Fuck darwinports.
07:33:39 <poetix> One thing I notice in Haskell is that people keep having to come up with ad hoc reflection mechanisms, like the way HSQL manages SQL types - you have a SqlType datatype for all the different types, and the SqlBind type class for instances of them.
07:34:42 * shapr looks
07:35:12 <poetix> You have to write something like instance Serializable foo for every foo you want to serialize
07:35:56 <xcas> hello, anyone know of a haskell debian repo? im trying to learn haskell gtk2hs... haskell-unsafe packages looks broken.
07:35:56 <skew> I'm not sure that can be avoided
07:37:14 <skew> what kind of generic reflection system would let you derive Serializable (Int -> Int) ?
07:37:37 <Heffalump> Int is a finite datatype.
07:37:56 <Heffalump> </helpful>
07:38:01 <skew> Okay, so that's not the best example
07:39:05 <poetix> Well, pickle works well enough in Python - well enough for a whole running Twisted web server to pickle itself in one go. Is that only possible because Python isn't typesafe in the same way?
07:39:28 <skew> half of it is being able to persist code
07:39:49 <shapr> xcas: I don't know of any gtk2hs debs
07:40:01 <skew> and half of it is that Python is perfectly willing to fail at runtime if it runs into some object it can't serialize
07:40:09 <shapr> At least, nothing outside of haskell-unsafe
07:42:06 <shapr> xcas: you might be able to apt-get source and rebuild?
07:42:21 <skew> Using typeclasses ensures that you actually know how to serialize your object
07:42:44 <shapr> I vaguely recall that the gtk2hs deb in haskell-unsafe is for ghc6.2, so you'd need to see if there's a gtk2hs cabal in the cvs repo
07:43:32 <xcas> ok.. will checkout the cvs repo
07:43:42 <xcas> shapr, so ur running debian?
07:43:49 <shapr> yup, debian/unstable
07:44:06 <skew> That's not to say that some kind of generic runtime reflection wouldn't be interesting, but it gives you different things than typeclasses or generic programming
07:44:18 <xcas> shapr, /usr/local/* haskell stuff?
07:44:25 <shapr> huh?
07:44:35 <shapr> ich verstehe nicht
07:44:40 * Igloo has just sent Marvin a mail to see what's up with it
07:44:41 <xcas> shapr, u compile ur own libs?
07:44:52 <shapr> I use the debian packages whenever possible.
07:45:24 <xcas> shapr, ok.. im still linux noob.. hehe. im still struggling ;)
07:45:39 <poetix> 6 years and still struggling
07:45:42 <poetix> Linux is like that
07:45:45 <shapr> aha, I found this in the most recent cvs checkin for gtk2hs "GHC 6.4 cabal support: add new cabal package file templates."
07:45:47 <shapr> That's a good sign.
07:46:08 <skew> poetix: Data.Generics might be interesting
07:46:36 <xcas> shapr, tnx for all this.. hehe. time to dl stuff...
07:46:38 <shapr> xcas: No worries. We're mostly helpful here on #haskell
07:46:51 <xcas> :)
07:46:59 <poetix> skew: I'll take a look. I'm sure that good enough solutions exist for most purposes...
07:47:03 <shapr> We don't do homework, but we do give hints.
07:47:17 <shapr> xcas: Are you learning Haskell for business or pleasure?
07:47:38 <xcas> shapr, hehe. for pleasure... cobol makes me sick...
07:47:44 <skew> poetix: what are you proposing?
07:47:46 <xcas> shapr, :)
07:47:57 <shapr> I can understand that. I used COBOL for a short time some years ago.
07:48:18 <poetix> skew: I'm just trying to understand why a generic solution doesn't exist / isn't possible / isn't desirable
07:48:27 <shapr> xcas: Have you seen the gtk2hs tutorial article in the The Monad.Reader?
07:48:51 <skew> poetix: one thing about Python is that being dynamic and all it needs to keep full type information at runtime, while Haskell hopefully can optimize some of that away
07:49:09 <xcas> shapr, nope... i just got the thomson book.
07:49:29 <xcas> shapr, still learning since yesterday
07:49:30 <skew> poetix: what do you want a generic solution to do?
07:50:04 <poetix> skew: give me Serializable for free, I guess. I'm trying to understand whether this would violate some law of Haskell programming thermodynamics
07:50:27 <shapr> That's a good choice. You might also enjoy reading Kenneth Hoste's gtk2hs introduction: http://haskell.org/~shae/memory.pdf
07:51:17 <xcas> shapr, tnx! will check this out. :)
07:51:26 <shapr> poetix: darcs get http://www.cs.helsinki.fi/u/ekarttun/SerTH/SerTH/
07:53:14 <shapr> The real webpage for SerTH is http://www.cs.helsinki.fi/u/ekarttun/SerTH/
07:56:31 <skew> poetix: The question is how you get information about various types
07:56:32 <shapr> How could you persist functions? Save them in Core format?
07:56:53 <shapr> Is that any different from saving the source? Is there a better way?
07:57:26 <ozone> generics would give you serialisation for free
07:57:30 <ozone> Data.Generics, as skew said
07:58:03 <skew> (getTypeOf :: a -> TypeInfo) breaks our pretty free theorems, and puts restrictions on the runtime.
07:58:34 <xcas> anyone know where to find PLog blog sources? :)
07:59:15 <shapr> Pete just moved back to .au so his website is down for the moment. As far as I know.
07:59:26 <ozone> he moved back?
07:59:27 <shapr> I have a pre-release copy of 0.6
07:59:41 <skew> Bounding that inspection (Data a) => a -> <stuff about the type of a> makes everything happy in Haskell land. Also, inspecting the type at compile time (via TH) when the compiler still has it is fine too.
08:00:29 <shapr> I don't think Pete would mind if I put up the pre-release of PLog 0.6, but you'll probably need some help getting it configured in the beginning.
08:01:13 <shapr> ozone: I just heard this a coupla days ago from Mrak.
08:01:21 <ozone> shapr: oh, wow
08:01:25 <ozone> do you know if he's heading back to UNSW?
08:01:26 <xcas> shapr, ic... hehe. i dunno if i could handle that. hehe.
08:01:52 <shapr> I think he's already back at UNSW, but I don't have any clear information.
08:02:29 <shapr> xcas: Where did you hear about PLog?
08:03:11 <xcas> shapr, google
08:03:23 <kolmodin> instructions on how to build our editor haste under linux is now available at http://haste.dyndns.org:8080/download.php
08:03:39 <basti_> < basti_> how is unicode input thought to be?
08:03:43 <basti_>  < basti_> as in, i type "Ã¤", what would a program get?
08:03:43 <shapr> There's also BjÃ¶rn Bringert's BLob blog that uses HaskellDB.
08:03:45 <basti_> < basti_> whops sorry wrong chan
08:03:59 <shapr> kolmodin: yay!
08:04:05 <kolmodin> :)
08:04:23 <ozone> shapr: cool, thanks.  i'll email mrak
08:04:24 <basti_> hmm
08:04:33 <xcas> shapr, urls? im looking for a blosxom replacement. :D
08:04:42 * basti_ .oÂ° ( p0nders)
08:05:04 <xcas> shapr, but db code looks like fun
08:05:17 <shapr> HaskellDB is quite nifty, I agree.
08:06:01 <xcas> it looks like u guys here know each other
08:06:29 <basti_> who thought up this fecal matter about the "Meta key" sending ESC instead?
08:06:46 <shapr> Where'd you get that from?
08:06:53 <basti_> in xterm
08:07:04 <basti_> it i type alt-k i get ESC k
08:07:05 <shapr> I know emacs recognizes ESC as an alternate form of Meta.
08:07:19 <basti_> what would a sane alternative be?
08:07:27 * shapr doesn't know
08:07:34 <shapr> xcas: darcs get http://www.dtek.chalmers.se/~d00bring/darcs/blob/
08:08:15 <xcas> shapr, tnx
08:08:24 <shapr> xcas: If you spend some time here, you'll get to know everybody too. Lots of friendly folks here on #haskell.
08:08:46 <xcas> i guess i feel more at home here... :D
08:08:56 <xcas> i was choosing on what to learn
08:09:02 <xcas> between mono and haskell
08:09:05 <xcas> hehe
08:09:57 <shapr> A friendly and helpful community is definitely a plus for any software.
08:10:15 <xcas> anyways. gtg. tnx for all the help. still need to go to work. bye.
08:10:30 <xcas> cya guys soon :D
08:11:26 <skew> Is there any reason an attribute grammar couldn't work over a monad with fix?
08:12:32 <poetix> wow, ghc6.4 takes a long time to compile...
08:12:57 <basti_> skew: i wouldnt know why it shouldnt.
08:12:57 <Heffalump> skew: nafaik.
08:13:12 <Heffalump> not sure what the benefit of using a monad would be
08:13:25 <skew> Well, I'm thinking about how to handle some code generation
08:15:07 <skew> I've got a tree structure representing some kind of distribitued query, where each subtree needs to know where to send its results and where to transfer control once it is one, and needs to know how to start and abort its children
08:16:53 <wilx> Huhuhu, paralel LR parsing?
08:18:16 <shapr> That sounds *interesting*.
08:21:44 <skew> An attribute grammar seems natural for making those connections, but I also need to come up with unique names, and do some other things I haven't quite figured out yet
08:22:00 <shapr> you've got the Unique name supply in ghc
08:24:23 <Heffalump> standard way to handle unique names in AGs is to thread around a name supply, or distribute a forking one downwards
08:24:43 <Heffalump> I guess using a monad would be a nice way to do the former.
08:27:07 <skew> All I really want is some threaded state, for assigning names and memory locations, and I would use it in a morally commutative way.
08:27:45 <skew> I guess that isn't so bad with the way the default copy rule threads things around
08:28:07 <skew> mostly it's that accessing and updating the threaded state isn't very pretty
08:28:47 <Heffalump> you'd be using mdo for each attribute computation, presumably.
08:29:15 <Heffalump> that calculates a local fixpoint, I think, so it's not entirely clear to me how that would interact with the global fixpoint you actually want
08:29:54 <Heffalump> it may be that your individual computations don't actually need a fix operator (i.e. mdo) at all, and you just want to calculate a global one.
08:30:22 * sorje is struggling with runInteractiveProcess. :-/
08:30:54 <skew> there are some laws mfix is supposed to follow
08:31:05 <skew> I don't know how much they help
08:31:59 <skew> the local fixedpoint turns a subtree into a function from inherited to synthesized attributes, so I think the fixedpoint probably works out in the end
08:34:09 <skew> Actually, I could use the attribute grammar to thread the state and runState locally
08:36:27 <skew> compute a tuple in a local attribute if multiple rules interact through the state, then split state and values up to send their separate ways
08:36:47 <Heffalump> skew: why is the local fixpoint needed, though?
08:36:54 <Heffalump> would you have local recursive dependencies?
08:37:03 <Heffalump> (within the computation of a specific attribute)
08:37:47 <skew> yes
08:38:09 <Heffalump> evil person ;-)
08:39:09 <skew> there is nothing special about the root of the tree, in my application or in a general attribute grammar
08:39:12 <Heffalump> (have you read the paper on First Class Attribute Grammars by de Moor, Backhouse and Swierstra, btw)
08:39:25 <skew> no, but that sounds like something useful
08:39:45 <Heffalump> the root is special only because it is where you tie the knot to make the fixpoint
08:40:12 <Heffalump> and in some views of the world is the only place you read out resulst (i.e. you compute them in a synthesized attribute that comes out there)
08:41:14 <skew> Oh, you mean usually the attribute grammar has a specail node at the top just for tying up the fixpoint
08:41:57 <Heffalump> it doesn't have to be used just for that, though often it's easiest to
09:01:39 <poetix> #haskell's collective mind reels in silence for a while...
09:04:49 <sh10151> enjoy it
09:06:02 <poetix> ghc6.4 *still* compiling...
09:18:53 <wilx> :)
09:18:59 <wilx> It take some hours to compile :)
09:19:25 <pesco> poetix: Same here (ghc 6 compiling)... Take a nap or something. Or shoot a round of UT...
09:19:44 <pesco> (on a different machine, preferably ;))
09:25:12 <chr1s> hey all :)
09:25:20 <chr1s> if something returns an IO State
09:25:56 <chr1s> why can't I do something like do { \n function \n return state }
09:25:56 <skew> ... how do I get the State out?
09:26:08 <skew> oh, you should be able to do that
09:26:26 <skew> as long as "function" has type IO a for some a
09:26:58 <skew> and of course as long as "state" gets a value from somewhere
09:27:22 <chr1s> the function returns IO ()
09:27:38 <skew> so what is the problem?
09:27:55 <chr1s> well it says :  Couldn't match `IO ()' against `t -> t1'
09:28:16 <skew> Oh, maybe you need a semicolon between the lines
09:28:45 <chr1s> yeah, that works.
09:28:47 <skew> using explicit braces turns off layout, including the part that adds semicolons between lines
09:29:00 <chr1s> ah, ok
09:29:38 <chr1s> ah, THAT's it
09:29:40 <chr1s> thanks :)
09:36:51 <chr1s> and what does $ do?
09:38:13 <TheHunter_> @type ($)
09:38:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown command ':lambdabotFlags'
09:38:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- use :? for help.
09:38:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- command 'lambdabotFlags' not defined
09:38:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ($) :: forall b a. (a -> b) -> a -> b
09:38:24 <waltz> omg
09:38:24 <TheHunter_> f $ x = f x.
09:38:30 <waltz> shut the fuck up with the noticing!
09:38:49 <chr1s> ah thanks
09:38:51 <TheHunter_> so it's a function application.
09:39:19 <TheHunter_> but $ associates to the right, so you can write f $ g $ h x without having to add parens.
09:39:29 <chr1s> nice :)
09:40:08 <chr1s> It's pretty hard to find what stuff like that does
09:40:23 <chr1s> functions are no problem, but finding a '$' can be much harder
09:40:34 <chr1s> :s/can be/is
09:40:48 <skew> why?
09:40:48 <johs> http://haskell.org/onlinereport/prelude-index.html
09:41:06 <skew> tha index to the documentation has a symbol page
09:41:47 <TheHunter_> also, http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3A%24
09:41:56 <TheHunter_> it's one of the few functions actually documented.
09:42:00 <skew> if you don't know what module it comes from, try something like :info ($) in ghci (after loading the same modules as the file your operator is used in)
09:42:18 <chr1s> ah, ok. thanks
09:42:51 <skew> I guess :info isn't so useful
09:43:07 <chr1s> well, you see, I've started with learning helium
09:43:25 <skew> it will give you the type. I was expecting a fully qualified name somwhere too
09:43:54 <chr1s> and I'ts not in the helium prelude, but now I'm using ghci, and I guess I need the Tour of the Haskell Prelude :)
10:01:03 <shapr> Is there any BEEP (formerly BXXP) code for Haskell?
10:01:29 <theorbtwo> Yes, shapr.
10:01:34 <sh10151> do I even want to know what that is?
10:01:46 <theorbtwo> Oh, for Haskell?
10:01:50 <theorbtwo> No idea.
10:01:59 * theorbtwo temporarlly forgot what channel this was.
10:02:20 <sh10151> you shouldn't be such a language dilettante
10:02:37 * sh10151 says from his comfortable spot on #python #scheme #lisp and #haskell
10:03:07 * theorbtwo is on #perlmonks, perlmonks.org, #perl6, #parrot, #haskell, and #emacs.
10:03:31 <sh10151> heh
10:03:31 <jlouis> cool, CDDB has some classical music
10:03:37 <sh10151> I wonder if you have heard of "pugs"
10:03:39 <sh10151> :-P
10:04:13 * jlouis comfortably rests on #sml and #haskell
10:04:38 <jlouis> I occasionally grok python though. And perl. I do not like perl that much, however
10:04:51 <shapr> I flit among languages, real and imagined.
10:05:07 * vegai tries to be in one language-channel at a time. Focus!
10:05:33 <sh10151> vegai: then you run into the "man this is boring, i wonder what they are talking about on #snobol..."
10:06:05 <vegai> or perhaps get up from the box and go out for a walk (yeah, right)
10:07:27 * sh10151 just came back from washing his car
10:08:23 * shapr 's brain explodes
10:08:49 <shapr> theorbtwo: truly, externRequire is exciting.
10:09:29 <sorje> Stupid getProcessExitCode always returns ExitSuccess, even when the process is running still. :-(
10:11:13 <chr1s> do you guys use haskell for "normal" apps or only for science/research/school?
10:12:12 <vegai> /religion
10:12:15 * vegai hides
10:12:21 * shapr burns vegai the heretic
10:12:29 <vegai> ayyeee!
10:12:32 <chr1s> I can understand, it IS way cool
10:12:38 <vegai> I need better hideouts
10:12:40 <shapr> chr1s: I'm self-employed, that's how I use Haskell.
10:13:11 <chr1s> but a lot of apps with I/O are more easy in imperative languages, I think.
10:13:20 <shapr> I disagree.
10:13:26 <autrijus> hrm. I can install hs-plugins
10:13:31 <autrijus> but it does not show up in ghc-pkg.
10:13:39 <shapr> make register
10:13:55 <autrijus> oh.
10:13:56 <chr1s> I think the IO is not really obvious in haskell
10:14:02 <autrijus> here we go
10:14:04 <autrijus> thanks shapr!
10:14:06 <shapr> :-)
10:14:13 <chr1s> Sometimes you just want to print stuff to the stdout
10:14:43 <shapr> chr1s: believe it or not, it is pretty obvious, it's just that prior carnal knowledge of imperative programming distracts people.
10:14:52 <shapr> This is my opinion, because that was my experience.
10:15:30 <shapr> So maybe I should have said, "Once it clicked, it was oh so simple!"
10:15:44 <chr1s> so, If I get used to the IO by using it a lot, It's quite obvious?
10:16:02 <shapr> Once you get used to monads, IO is quite obvious.
10:16:41 <shapr> The only really interesting data I have to back this up is stories I heard from the chalmers.se guys about students who learned Haskell before they learned C.
10:17:09 <shapr> These students had no trouble learning about monads, IO, etc
10:17:19 <shapr> But they had a lot of trouble the first time they hit an imperative language.
10:17:58 <sorje> How would you restrict the runtime of a program you're starting through runInteractiveProcess?
10:18:23 <shapr> Once these Haskell-only students heard that C functions "have an implied IO monad signature" then everything was clear to them.
10:20:25 <shapr> sorje: I'd see how @plugs does it in lambdabot
10:20:27 <chr1s> ah
10:20:49 <chr1s> and can you tell me something like that for a imperative-only student? :p
10:21:15 <shapr> Yes, sort of.
10:21:59 <chr1s> tell me!
10:22:19 <wilx> Btw, monads, when I was learning them on the sheeps example from the tutorial this occured to me: Monads are like that Japanese pachinko game. You have a fixed web of tubes and you throw your marbles into them and depending on the marbles they fall out altered a/o transformed. But the main pint is that the tubes are fixed :))
10:22:29 <wilx> This has really helped _me_.
10:22:29 <chr1s> because I think haskell is a GREAT language, I really like everything about it except the IO
10:22:54 <shapr> ok... Monads have three pieces, a partially filled in type and two functions. One function fills in that type with a value, the other function puts together two filled-in values to get a result of the same filled-in type.
10:22:56 <wilx> s/pint/point/
10:24:14 <shapr> Depending on what you want to do, you choose which combination of container type and value mixers to use.
10:24:50 <shapr> The simplest example is using the Maybe container type to represents computations that can fail.
10:25:21 <shapr> "data Maybe a = Nothing | Just a"
10:25:38 <sond> shameless plug: http://haste.dyndns.org/download.php <- windows and sourcecode releases now online
10:25:45 <shapr> that's the maybe type, your function can represent failure with Nothing, and success with Just (some value)
10:25:51 <chr1s> yeah
10:26:26 <shapr> You've probably written some code somewhere that had a zillion nested if/then/else statements, and you wondered if there was some way to factor those out into some kind of common structure.
10:26:33 <shapr> the maybe monad is that common structure.
10:26:40 <chr1s> ah
10:28:26 <shapr> your container type is Maybe, you lift a value into the container with Just, and you combine two containers by saying Nothing and another function will be Nothing, because obviously later if statements can't succeed if earlier statements died.
10:28:42 <chr1s> ah, I get it. you carry around the state of the IO thing
10:28:46 <shapr> in the other case, a result plus another container just passes the result to the container
10:29:15 <TheHunter_> @wiki MonadsAsContainers
10:29:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/MonadsAsContainers
10:30:42 <shapr> This is a good monads tutorial: http://nomaware.com/monads/html/ and I strongly recommend the MonadsAsContainers link too.
10:31:46 <chr1s> reading those :)
10:32:20 <shapr> So like I said, monads are small and simple, what you can do with them is big and complicated.
10:33:01 <chr1s> Just like haskell programs :)
10:33:19 <shapr> Yes, totally!
10:33:59 <chr1s> so, now the practical problem :)
10:34:14 <chr1s> I have the following function: paintCommands :: DC () -> State -> [Command] -> IO State
10:34:47 <chr1s> and what I want to do is take the first Command in [Command], do a paintCommand and then a paintCommands on the rest
10:35:13 <chr1s> just like normal recursive functions, but it doesn't work :)
10:36:04 <chr1s> I'm trying to do:
10:36:05 <chr1s>         paintCommand dc state command
10:36:05 <chr1s>         ; paintCommands dc state commands
10:36:08 <shapr> Do you have paintCommand :: DC ()  -> State -> Command -> IO State ?
10:36:23 <chr1s> yeah, the paintCommand does work, but it only paints the last command.
10:36:44 <chr1s> It works perfectly if i have a [Commands] with only one item.
10:37:01 <shapr> try mapM paintCommand on [Command]
10:37:05 <shapr> @type mapM
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown command ':lambdabotFlags'
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- use :? for help.
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- command 'lambdabotFlags' not defined
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- mapM :: forall b (m :: * -> *) a.
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         (Monad m) =>
10:37:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         (a -> m b) -> [a] -> m [b]
10:37:12 <shapr> whoa
10:37:32 <chr1s> ah
10:38:51 <Darius> @listmodules
10:38:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- babel base dice dict dummy dynamic eval google help karma more pl plugs
10:38:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- quote seen state system topic type version
10:39:08 <Darius> @listcommands dice
10:39:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Module dice provides the following commands: ["dice"]
10:39:15 <Darius> @help dice
10:39:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @dice <expr>. Throw dice. <expr> of the form 3d6+2.
10:39:28 <shapr> @dice 3d3
10:39:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3d3 => 9
10:39:31 <shapr> heh, neat
10:39:32 <wilx> :)
10:39:36 <shapr> It has three sided dice.
10:39:41 <Darius> @dice 1d2
10:39:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1d2 => 2
10:39:42 <chr1s> lol
10:39:43 <wilx> @dice 2d12+2
10:39:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2d12+2 => 6
10:39:45 <wilx> @dice 2d12+2
10:39:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2d12+2 => 15
10:39:49 <wilx> Wheee!!!
10:39:50 <Darius> @dice 2d1
10:39:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2d1 => 2
10:40:01 <wilx> This reminds me I need to finish playing NWN.
10:40:18 <wilx> Got stuck in the city with wizards and their tower.
10:43:21 <shapr> hiya mwc
10:46:36 <mwc> shapr, good afternoon
10:46:58 <mwc> reading this tutorial is like reading a detective story....
10:47:17 <mwc> I have an idea how monads work mathematically]
10:47:24 <mwc> now just need to see if it pans out :P
10:47:44 <shapr> heh
10:48:03 <Darius> mwc: Monads are used for a whole variety of things in math and in computer science, they are much more general than the way they are used in Haskell.
10:50:35 <mwc> Darius, yeah, but after consulting a classic greek encyclopedia I've got a theory :P
10:51:40 <mwc> a monad, for instance, the IO monad, represents a space and the sequence of "functions" applied to them (noncommutatitvely) transform them into a final state
10:51:48 <mwc> but don't spol it for me :P
10:52:36 <shapr> hi daf
10:52:39 <daf> hi!
10:52:45 <shapr> learning Haskell?
10:52:51 <daf> I am
10:53:09 <shapr> Do you have prior functional programming experience? Would you like the short tour of nearby learning materials?
10:53:24 <daf> well, I have some experience
10:53:43 <daf> I have purchased the Haskell School of Expression
10:53:43 <jlouis> daf: does higher-order function say anything?
10:53:50 <daf> jlouis: it does :)
10:54:16 <daf> I haven't been making much progress recently, because I haven't had much time to devote to it
10:54:19 <jlouis> daf: cool ;)
10:54:37 <daf> I like Haskell a lot, so far
10:54:40 <shapr> me too!
10:54:56 <daf> I think what I need is practice using it
10:55:32 <shapr> daf: do you have some ideas?
10:55:32 <jlouis> I like Dvorak and Ravel a lot. Though they are not languages
10:55:42 <shapr> rehi poetix
10:55:43 <daf> I've been applying functional techniques in not-strictly-functional for a couple of years
10:55:52 <sh10151> hah
10:55:53 <daf> * not-strictly-functional languages
10:55:59 <sh10151> i know what you mean there
10:56:28 <sh10151> a fellow programmer was completely confused by some javascript I wrote
10:56:36 <jlouis> a = foo(); b = bar(a); c = baz(b); ====> c = baz(bar(foo)))
10:56:40 <jlouis> and the like
10:56:42 <scalopus> hi
10:56:45 <sh10151> "no, you pass in the function that you want to execute onclick"
10:56:47 <shapr> greetings scalopus
10:56:52 <sh10151> "pass in the function"
10:57:01 <daf> sh10151: heh
10:57:15 <jlouis> haha
10:57:22 <sh10151> "what function? whatever function you want. if you want it to do nothing then pass function () { return }"
10:57:33 <sh10151> "this is too complicated"
10:57:48 <daf> speaking of which, I'm intrigued by this book: http://perl.plover.com/hop/
10:57:58 <sh10151> "well it's either going to be too complicated or it will only be useful as cut-and-paste"
10:58:11 <sh10151> of course with the state of programmers today cut-and-paste is the norm
10:58:18 <shapr> Yeah, I'll definitely read Higher Order Perl when it reaches the freely downloadable stage.
10:58:43 <daf> it's interesting to see a book on HOP for a popular language
10:59:18 <sh10151> i swear this person made like 5 commits to the CVS tree that were just changing the default behavior for something that could be overridden by passing in a function as a parameter
10:59:19 <daf> perhaps an indicator of a wider trend of increased popularity for functional programming
10:59:22 <daf> (but perhaps not :))
10:59:28 <shapr> I can hope so.
10:59:39 <sh10151> i would change it back and explain it again
10:59:45 <shapr> daf: have you heard about Pugs, the perl6 implementation in Haskell?
10:59:53 <sh10151> and the next day it is wrong in CVS again
11:00:07 <daf> shapr: oh, I think I saw that mentioned somewhere
11:00:14 <daf> but I don't know much about it
11:00:32 <shapr> It's quite nifty.
11:01:05 * daf finds the website
11:01:08 <mwc> Perl 6 is designed to counter the python/ruby threat?
11:01:21 <shapr> No, I think it's designed to be better than perl 5.
11:01:41 <poetix> ghc6.4 compile failed with an error in libHSReadline - undefined reference to "readline" in function s6KV_sLow
11:01:41 <mwc> perl developed a reputation for being arcane and doing unexpected things if you don't know the minutiae
11:01:43 <smott> i wish they'd get rid of the $,@,% in variables
11:02:04 <shapr> poetix: do you have readline5 libs installed?
11:02:04 <mwc> smott, yeah, that makes my eyes bleed. I mean, Qbasic is SO 1988
11:02:06 <sh10151> i have migrated away from perl for a lot of things
11:02:07 <poetix> I assume I'm missing some -devel package...
11:02:13 <sh10151> to ksh/sed/awk ironically enough
11:02:14 <sh10151> :)
11:02:21 <poetix> shapr: probably not. I'll go check.
11:02:35 <sh10151> when I break out perl it is to write something to be put incide a ksh pipeline
11:02:39 <sh10151> inside
11:02:42 <mwc> sh10151, I really liked ruby, just needs to get its toolset caught up Pythons
11:03:09 <daf> I like Ruby a lot
11:03:20 * Oejet likes Java a lot.
11:03:27 * shapr likes programming.
11:03:52 <shapr> Given the choice between digging ditches for a living and writing code for a living, I'd rather code.
11:04:00 <mwc> the thing that bugged me about python is how some functions on lists are in place, some are copy, so are functoins, some are methods, etc. Just became too much semantics for my heat
11:04:05 <daf> shapr: absolutely
11:04:07 <mwc> shapr, I'd take the ditch digging job
11:04:16 <shapr> reverse  = lambda x: x.reverse() or x
11:04:20 <shapr> sort = lambda x: (lambda x=x[:]: x.sort() or x)()
11:04:21 <mwc> shapr, then build a machine to dig the ditches, program it to do my days work
11:04:26 <mwc> and get another job :P
11:04:26 <daf> mwc: yes, I like the way Ruby makes destructive operations explicit
11:04:43 <sh10151> mwc: with Jython reinvigorated that's going to be much harder to do
11:05:00 <TFK> shapr, that's unnecessary in 2.4
11:05:08 <mwc> sh10151, that's why there's JRuby :P
11:05:09 <TFK> there are reversed() and sorted()
11:05:31 <daf> TFK: yes, I was very glad to see those additions
11:05:37 <TFK> I'm not aware of any methods that return an implicit copy of a list.
11:06:06 <TFK> (or functions, for that matter. methods are just special functions. Yes, I'm a pedant.)
11:06:53 <TFK> Writing your own reversed() and sorted() would be quite easy, btw ;-)
11:09:54 <sh10151> shapr: actually I think I'd like to dig ditches and write code
11:09:54 <sh10151> I'd like to not have to do either though...
11:09:54 * sh10151 is gunning for that post-scarcity society...
11:10:30 <shapr> I like to write code that people use. I find it rewarding.
11:10:34 <shapr> Of course, I like eating too.
11:12:43 <TFK> Some code is very useful to keep tables from moving...
11:13:11 <shapr> You wad it up and put it under the short leg?
11:13:27 * Oejet is scared of other people using his code.
11:13:30 <TFK> That's often the case, yes.
11:13:35 <shapr> Is that what you meant?
11:13:42 <TFK> Yes o.o;
11:14:04 <shapr> Let me clarify that, I like to write code that people like to use.
11:14:40 <TFK> Well, that's one of the usages :-)
11:15:53 <shapr> daf: haskell makes destructive operations explicit too :-)
11:16:25 <daf> heh, of course :)
11:22:56 <ibid> shapr: you can't send a missile flying implicitly? ;)
11:23:28 <shapr> Not with Haskell's Software Transactional Memory(tm)!
11:23:57 <shapr> Other companies use languages like C++(tm) that don't give guaranteed behaviour like our product, Haskell(tm)!
11:23:59 <ibid> :)
11:24:18 <ibid> actually, what stm does is to avoid an accidental second launch :)
11:24:23 <Darius> shapr: You could surely add a primitive "fireMissle :: STM ()", you just need to find a way to undo it ;)
11:24:34 <shapr> Darius: haha
11:24:56 <ibid> Darius: just back up the world changelog :)
11:25:16 <Darius> Which RCS does the universe use?
11:25:43 <kaol> BitKeeper (ducks)
11:25:58 <ibid> Darius: you don't use rcs to use a transaction log :)
11:27:28 * Heffalump uses darcs and CVS
11:30:02 <ibid> LOG ENTRY: N.N.: live -> dead
11:30:19 <ibid> LOG ENTRY: The White House: standing -> ruind
11:30:23 <ibid> ruins
11:30:37 <ibid> and you just back up the logged changes :)
11:31:00 <Oejet> Where's the lost log entry for Elvis: dead -> live?
11:33:07 <ibid> Oejet: it was backed out :)
11:33:31 <ibid> divine resurrection of elvis transaction ABORTED
11:34:24 <Oejet> ibid: No it just starving, while retrying all the time.
11:34:29 <Oejet> *it is
11:34:43 <ibid> :)
11:36:51 <ibid> as to what rcs people use, i use darcs where i can, and cvs for hysterical raisins where i must
12:01:19 <TFK> Woo! Windows binaries for Haste!
12:03:41 <kolmodin> :)
12:04:20 <wilx> Haste?
12:04:24 <wilx> @google Haskell Haste
12:04:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://haste.dyndns.org:8080/
12:07:34 <Heffalump> nice.
12:07:38 <Heffalump> how usable is it?
12:07:40 <chr1s> what does Non exhaustive patterns in function blah mean?
12:08:48 <shapr> It means some options aren't handled.
12:08:54 <Heffalump> e.g. if you write
12:08:57 <Heffalump> foo (Just x) = x
12:09:06 <Heffalump> then Nothing is an unhandled case
12:09:24 <shapr> hi gaal
12:09:28 <gaal> hey shapr
12:09:28 <chr1s> ah, could have figured that out, thanks :)
12:09:47 <Oejet> @wiki ImperativeHaskell
12:09:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/ImperativeHaskell
12:10:40 <shapr> Oejet: nifty!
12:11:06 <gaal> hey all. i have a build problem with hs-plugin on msys:
12:11:06 <gaal> building GHCi library C:/DOCUME~1/GAALYA~1/LOCALS~1/Temp/hs-plugins-20050411/src/altdata/HSaltdata.o...Reading package info from stdin... done.
12:11:06 <gaal>  
12:11:06 <gaal>  Fail: rawSystem: invalid argument (Invalid argument)
12:11:30 <shapr> Does it mention the value of the argument?
12:12:03 <gaal> nope, that's the entire message.
12:12:42 <gaal> (the first line is just context)
12:20:23 <shapr> hej fajje
12:20:36 <fajje> hallu
12:20:44 <shapr> Learning Haskell?
12:20:54 <fajje> nepp, kan redan haskell
12:20:59 <fajje> :)
12:21:13 <shapr> spiffy, written any cool code recently?
12:21:30 <fajje> not really, trying to code up a scheme compiler
12:21:40 <shapr> Using parsec?
12:21:41 <Darius> in Haskell? ;)
12:21:49 <fajje> alex, happy, c--
12:21:53 <shapr> oh, cool
12:22:10 <fajje> haven't got to the c-- part yet though
12:29:25 <chr1s> I'm trying to draw a line only if some bool is set to true
12:29:51 <chr1s> with the following expressing: if penDown then line args
12:30:00 <chr1s> do I need an "else" too?
12:30:07 <shapr> yes
12:30:09 <Darius> chr1s: You -always- need an else.
12:30:28 <chr1s> and is there a statement in haskell that does nothing?
12:30:36 <ibid> there are no statements in haskell
12:30:36 <fajje> return ()
12:30:45 <Darius> chr1s: However, there are standard functions (that are easily definable) that does what you want, 'when' in this case.
12:30:56 <Darius> @type Control.Monad.when
12:31:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown command ':lambdabotFlags'
12:31:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- use :? for help.
12:31:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- command 'lambdabotFlags' not defined
12:31:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.when :: forall (m :: * -> *).
12:31:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       (Monad m) =>
12:31:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       Bool -> m () -> m ()
12:31:42 * Darius wonders wtf is wrong with lambdabot.
12:32:10 <chr1s> ah nice :)
12:33:08 <ski> see also 'unless'
12:33:57 <shapr> hiya hefner
12:34:05 <hefner> hi
12:34:19 <shapr> How's code?
12:34:24 <ski> hiya shapr
12:34:30 <shapr> hej ski
12:35:00 * shapr hacks on perl6
12:35:02 * ski gÃ¶r nÃ¥t han inte gjort pÃ¥ lÃ¤nge
12:35:16 <shapr> vad Ã¤r det som du gÃ¶r?
12:35:24 <hefner> I had to use C++ for a few weeks, totally put me off programming
12:35:28 <ski> shapr : nÃ¤mligen, kodar lite i C
12:35:33 <shapr> jasÃ¥
12:35:37 <shapr> hefner: I can dig it
12:35:48 <ski> shapr : Ã¥t brorsan
12:36:10 <ski> shapr : en liten AVL-impl.
12:36:30 <shapr> Jag kodar lite av bÃ¥da Perl och Haskell.
12:36:55 <wilx> o_O
12:37:03 <wilx> Ah, UTF-8?
12:37:11 <shapr> yup, it's the way of the future.
12:37:34 <ski> shapr : och naturligtvis har jag redan gjort hÃ¶gre ordningens funktioner, och klagar pÃ¥ brist pÃ¥ closures ... :(
12:37:36 <wilx> Yeah, unfortunately IRC doesn't enforce it thus mIRC doesn't quite handle it :/
12:38:00 <shapr> ski: haha!
12:38:18 <shapr> I understand, I have the same problem when I write Python.
12:38:52 <ski> shapr : though, gcc's local functions ameliorates the problem a little
12:38:56 <skew> ski: building closures in C?
12:39:01 <ski> yep
12:39:06 <skew> that's what I'm doing right now
12:39:18 <skew> well, writing Haskell to write C that builds closures :)
12:40:05 <ski> or, almost building closures. i haven't defined specific struct types just for encapsulating env and code, just passing them around separately in parallel
12:40:14 <ski> skew : oh
12:41:03 <ski> (more problems come when one want garbage collection (even an explicit reference counting one), though ...)
12:42:16 <skew> fortunately, I can statically determine when things can be freed
12:42:31 <ski> (anyway, maybe my bro will learn a little modularity from the code ...)
12:42:33 <ski> oh
12:42:42 <ski> what kind of app ?
12:42:49 <skew> for now the answer is I don't need to because it's just a prototype :)
12:42:58 <ski> heh
12:43:11 <skew> It's sort of a DSL for a little distributed query problem
12:43:54 <skew> I need a fixed amount of memory, and I can free it once the query finishes
12:44:38 <ski> mhm
12:44:41 <ski> ok
12:45:12 <stepcut> happy birthday to me! happy birthday to me!
12:45:57 <shapr> Happy birthday stepcut! How old are you now?
12:46:14 <stepcut> 29, I think
12:46:21 <stepcut> april 10, 1977
12:46:27 <stepcut> 28 maybe?
12:46:35 <stepcut> @plugs 2005-1977
12:46:38 <shapr> haha
12:46:41 <shapr> I was just typing that
12:46:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 28
12:46:52 <stepcut> I guess I am 28 :)
12:46:53 <ski> passing closures around in anything but very strict ways more or less requires building in a free function in the closure for freeing the environment (of unknown/existential type) when freeing the closure, and then you wonder if maybe the env-freeing-closure maybe should be a closure itself with an env and maybe a freeer for *that* env, etc ... :(
12:46:55 <shapr> @plugs 2005-1971
12:46:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 34
12:47:32 <shapr> ?
12:47:40 <shapr> Oh right, in september of this year.
12:47:53 <stepcut> yeah
12:48:06 <stepcut> that doesn't work until on or after your birthday
12:49:01 <stepcut> over christmas I was at a wedding, and this thirteen year old girl wanted to know how old I was
12:49:02 * ski can't either remember how old he's
12:49:12 <stepcut> and I couldn't remember -- which totally boggled her mind
12:50:19 <stepcut> I had a hard time explaining that once you get past a certain age, you only care how old you are +/- 5 years
12:50:28 <shapr> Yeah, it's true.
12:50:44 <mwc> stepcut, I think it's really your age +/- x %
12:50:55 <mwc> 10% or so
12:51:01 <shapr> Maybe the x is your age? =)
12:51:04 <stepcut> mwc: yeah, % is probably more correct
12:51:12 <mwc> shapr, ahahaha, good one
12:51:15 <shapr> age +/- age %
12:51:36 <mwc> age +/- age/100
12:51:39 <stepcut> the latest exciting milestone was @ 25 I could finally rent a car in all 50 US states
12:52:07 <stepcut> though I think we you reach a certain age, it starts to reverse
12:52:19 <mwc> 19 was the last exciting day... I could by guns and porn at 18, but then I could by guns, porn, and booze
12:52:20 <shapr> You're too old to rent cars?
12:52:30 <wilx> :))
12:52:40 <mwc> *s/by/buy
12:52:43 <wilx> 18 was fun.
12:52:52 <wilx> I could start drinking.
12:53:07 <wilx> Just to stop when I was 22.
12:53:08 <stepcut> shapr: no, I am old enough -- in many states you can not rent a car if you are not atleast 25 years old
12:53:58 <mwc> It amuses me that I could have gotten my Private Pilot's License before I could have gotten my learners license for a car
12:54:15 <stepcut> hehe
12:54:25 <mwc> but that's Canada for you
13:00:07 <KrispyKringle> mwc: it's half true in the states, too. One can begin training for a private pilot's license at 15, but often cannot begin training for a driver's license until a year later.
13:00:28 <mwc> KrispyKringle, hey there, I know you from #macdev I think
13:00:33 <KrispyKringle> Really?
13:00:39 <KrispyKringle> I've been in #macdev maybe once :P
13:00:45 <mwc> or was it #macosx
13:00:46 <mwc> one of those
13:00:51 <mwc> you do EE, right?
13:00:52 <KrispyKringle> yeah, the latter.
13:00:56 <KrispyKringle> EE? No.
13:00:58 <KrispyKringle> CS.
13:00:59 <KrispyKringle>  ;)
13:01:01 <mwc> Ah
13:02:24 <KrispyKringle> Anyway, I'm trying to parse something into WASH output--basically, text interspersed with links. So since I currently can easily return a list of strings containing the raw links and text, I was hoping to return a list of HTMLMonad types, "text" and "a". But I can't figure out the properly typed way to do this.
13:02:29 <KrispyKringle> Anyone able to suggest a way?
13:02:59 <KrispyKringle> like, I can't just have the function be something like foo = text "asdf", at least, without a type signature, because that type is ambiguous.
13:03:00 <mwc> KrispyKringle, anyways, its true, you can take the exam at 16 but you can only get a G1 at age 16, and then a G2 probationary a year after the G1, and then finally a G a year after that
13:03:18 <mwc> Reminds me to take that G test soon, My G2 probably expires sometime soon :P
13:03:35 <KrispyKringle> G1? G2?
13:03:39 <KrispyKringle> This is some Canadian thing?
13:03:53 <mwc> KrispyKringle, yeah, the ontario government overhauled everything
13:03:58 <KrispyKringle> Ah.
13:04:04 <mwc> G1 is a learners permit, you can drive with a G holder
13:04:26 <mwc> G2 is a probationary, basically a G with the restriction of 0.0 blood alchohol and that every passenger has a seatbelt
13:04:55 <mwc> A G2 is good for like 4 years so I haven't bothered going back to the DMZ zoo to get my G
13:06:02 <KrispyKringle> heh
13:08:03 <mwc> plus I'd have to go out and practice parallel parking
13:08:06 <stepcut> KrispyKringle: I think you need to do something like, mapM (\str -> text str) ["test","1","2","3"]
13:08:12 <mwc> which I haven't done since my last road test
13:08:19 <shapr> That's why I have a two cpu desktop.
13:09:19 <KrispyKringle> stepcut: actually, i may have had it right. if i use it in context, i suppose, it helps the typechecker unify the type signature. it seems to be working in that case.
13:09:28 <KrispyKringle> although, yeha, your solution is also fine. thanks :)
13:09:39 <KrispyKringle> mwc: i've parallel parked maybe four times in my life :P
13:09:45 <skew> shapr, parallel *parking* requires two hard drives
13:10:01 <shapr> oh, right, I have tha too!
13:10:06 <mwc> I did it once on the road test, and that's about it
13:10:10 <mwc> took me about 5 minutes :P
13:10:34 <shapr> I got pretty good at parallel parking in Seattle.
13:10:41 <mwc> I'm not even sure where I'd part parallel
13:10:52 <mwc> not in this town
13:11:04 <shapr> Seattle had 65% of the parking places needed for the number of cars while I lived there.
13:11:13 <mwc> shapr, hehe, ouch
13:12:14 <mwc> I do everything in the burbs, never go downtown
13:13:26 <mwc> I thought Seattle was a car-town
13:14:18 <shapr> ?
13:14:25 * boegel bounces
13:14:54 <mwc> lots of wide roads and parking lots
13:15:01 <mwc> as opposed to say New York
13:15:15 <mwc> roads were built for cars not horses
13:16:35 <KrispyKringle> No, they were built for bicycles, mwc :P
13:22:55 <poetix> shapr: readline5 it was.#
13:24:00 <poetix> oh, sod
13:24:19 <poetix> no it wasn't - compilation just stopped again with the same error...
13:27:33 <poetix> hmm - /usr/local/lib or /usr/lib?
13:27:42 <poetix> wouldn't be the first time that's bitten me...
13:27:47 * shapr doesn't know
13:28:19 <shapr> mwc: In Seattle cars are parked on both sides of the road, sometimes several cars deep.
13:28:34 * poetix does make install for readline-5.0 again, after ./configure --prefix=/usr
13:29:55 <mwc> shapr, oh, lovely
13:31:08 <pesco> Woohoo, Yi is finally building.
13:31:26 <mwc> How's Yi's haskell mode?
13:31:33 * pesco shrugs.
13:31:41 <pesco> I'm just building. ;-)
13:32:53 <shapr> basti_: has been working on the Emacs keybindings.
13:33:29 * pesco commits a patch to darwinports.
13:35:31 <poetix> still no good...trying make clean and then going again from the beginning...
13:35:40 <poetix> (anyone done a Suse 9.1 RPM?)
13:35:40 <mwc> pesco, beautiful
13:36:14 <pesco> mwc: Are you a darwinports user?
13:36:15 <poetix> (for ghc6.4, in case you weren't here several hours ago...)
13:39:25 <shapr> I don't know of any suse ghc rpms, sadly.
13:42:08 <Darius> poetix: The redhat RPMs at the GHC page are tested with SuSE 9.1 and 9.2
13:42:39 <poetix> Darius: right. Thanks. Think I'll save myself a few hours of headache...
13:45:47 <boegel> anyone here who is familiar with cg ?
13:46:25 <sylvan> cg as in nvidia's shader language?
13:46:39 <boegel> cg as in computer graphics
13:46:44 <sylvan> yes
13:46:46 <boegel> radiosity, to be more exact
13:47:02 <sylvan> ah, well not a lot, but some...
13:47:06 <sylvan> try me
13:47:21 <stepcut> ahhh. much better!
13:47:22 <boegel> sylvan: can you tell me which techniques radiosity uses, so it works better than raytracing ?
13:48:16 <pesco> Eek, does Esc in Yi eat keypresses?!
13:48:28 <sylvan> in what sense?
13:48:36 <sylvan> radiosity could be used in raytracing
13:48:55 <sylvan> typical raytracing is just direct lighting though, whereas radiosity is a global illumination
13:49:10 <sylvan> (light bounces => soft shadows)
13:50:13 <boegel> sylvan: yeah, I know that, but ray tracing is based upon intersection calculations, mostly...what does radiosity use as a math tool ?
13:50:48 <chr1s> I have the following function:
13:51:04 <chr1s> parseArgs :: Maybe CMD -> Maybe Command
13:51:04 <chr1s> parseArgs Just (FW (Just x)) = Just (Forward x)
13:51:18 <sylvan> well I'm not all that familiar with it, but you could do it monte-carlo I suppose.. there is one technique called the hemisphere techinque which basically means that you at several points around the world render a view of the world and then average up (with weights) the incoming lights.. Repeat for more bounces..
13:51:58 <chr1s> but ghci says     Couldn't match `Maybe Command' against `t -> t1'
13:52:12 <chr1s> but I'm REALLY sure Forward x is a command.
13:52:16 <boegel> on how do you calculatue the hemisphere ? integrate ? differentiate ?
13:52:53 <sylvan> well it's an integral, but you could do it with 3D-hardware, or with a raytracer... just render it at some appropriately high resolution and average it up..
13:53:35 <sylvan> so at each texel you'll have a hemisphere with the incident light at different directions which allows you to do specular lighting and so one with global lighting information..
13:53:57 <boegel> hmm, I see
13:53:59 <sylvan> you could also represent the hemisphere with spherical harmonics of an appropriate order, putting point lights in that is pretty easy
13:54:14 <sylvan> SH is pretty neat because you can basically do it in real time with current hardware
13:54:46 <sylvan> a 2nd order SH is something like 9 coefficients.. so that's a 9D dot product at each pixel to find global illumination information... pretty cheap
13:54:46 <boegel> nice
13:55:18 <sylvan> Here's what a quick google gave me on the hemisphere approach: http://freespace.virgin.net/hugo.elias/radiosity/radiosity.htm
13:56:30 <chr1s> anyone?
13:58:06 <Darius> chr1s: The compiler is always right
13:58:46 <chr1s> :p I know, but when I return Just Command, it should be good, shouldn't it?
13:58:48 <boegel> sylvan: thanks :)
13:59:18 <sylvan> boegel: np
14:00:15 <Darius> chr1s: Anyways, it looks like you are applying something to too many arguments or not applying something to enough arguments elsewhere.
14:01:13 <chr1s> yeah, that's it.
14:01:23 <chr1s> I think it's bedtime.
14:01:55 <boegel> sleep tight chr1s
14:02:02 <mwc_> pesco, are you the guy who does the GHC port for darwinports?
14:02:16 <pesco> mwc_: No, that's not me.
14:02:26 <mwc_> ah, I have a bone to pick with the guy who does :P
14:02:41 <shapr> I'm sure he'd accept patches.
14:03:06 <shapr> Sometimes I put up crappy code because that's all the motivation I have. I figure if someone is really interested, they'll improve it.
14:03:17 <pesco> grep maintainer ${darwinports}/dports/lang/ghc/Portfile
14:03:24 <pesco> maintainers     gwright@opendarwin.org
14:03:40 <shapr> Take lambdabot as an example.
14:06:24 <poetix> Hooray. I now have ghc6.4.
14:06:27 <mwc_> shapr, the portfile is a mess of TCL and it's just hard coded to a prefix of /opt/local
14:06:41 <shapr> eek
14:07:35 <pesco> I must say, I like the way they use Tcl for the Portfiles. I never knew Tcl, but once I checked how it actually works, I thought "Wow, that's one pretty scripting language.".
14:07:35 <mwc_> Which is the default port prefix, just that I live at /opt/dports
14:07:42 * Darius has never really given Tcl a chance...
14:09:22 <pesco> Darius: It is the cleanest scripting language I've seen. It doesn't pretend to be anything. It doesn't do anything magical. It's just a replacement system with IO. The spec is what, one page long?
14:10:06 <shapr> g'day blackdog
14:10:11 <wagle> small (one page?) tcl programs are great (see also tk and expect)..  large tcl programs are horrible..  also, its very easy to call tcl from C and C from tcl..  so tcl is great for slamming quick guis on things while prototyping
14:10:25 <blackdog> good morning, shapr. I trust you and yours are well?
14:10:56 <shapr> Yeah, I'm having fun hacking on Pugs.
14:11:07 <blackdog> am watching the old spiderman cartoon while i get ready... they got the swinging physics so very wrong
14:11:37 <shapr> I gotta sleep, I have class in the mornin.
14:11:48 <shapr> and the usual buttloads of work after class.
14:12:05 <blackdog> Fair enough. talk to you later, perhaps.
14:12:25 <wagle> the swinging physics was bizarre in the latest movie too (but entertaining to watch)
14:16:10 <Darius> Forget the physics, there's the perennial problem of Spiderman "swinging" from nothing, especially e.g. in the last movie when he's over water.
14:16:51 * pesco submits the Yi darwinport.
14:17:31 <blackdog> in the cartoon, he has to be attached to some kind of rig... his focal point keeps moving forward, it's very strange
14:17:56 <pesco> This is fun. I've been churning out darwinports ever since I switched back to MacOS X, because they're so easy to make.
14:18:12 <pesco> I thought Gentoo's ebuilds were simple, but darwinports are even better.
14:18:18 <blackdog> pesco: so yi works properly on mac now? yi-static worked ok for me, but yi didn't...
14:18:36 <pesco> blackdog: It should, I think I caught all the dependencies.
14:19:55 <pesco> But I'm seeing some strange behaviour in vi mode, when I escape out of insert mode.
14:20:42 <wagle> Darius: form a parachute/windsail
14:20:55 <pesco> I enter some stuff and press Esc at the end of the line. Instead of moving back one position, the cursor stays at the "after eol position" until I press something. That keypress is otherwise ignored.
14:21:07 <pesco> Is this the same for everyone else?
14:21:19 <wagle> pesco: what all does darwinports put outside of /opt?
14:21:36 <pesco> wagle: Nothing, I think!
14:21:46 <wagle> it puts something into /etc
14:21:54 <pesco> Hm.
14:22:01 <pesco> What?
14:22:21 <pesco> Ah, system-wide configuration. In /etc/porcts.
14:22:23 <pesco> /etc/ports even.
14:22:36 <wagle> sounds right
14:22:55 <blackdog> so why darwinports over fink?
14:23:18 <pesco> I didn't get fink to work well when I last tried.
14:23:19 <wagle> given that /opt/etc/ports would have worked, i'm wondering what other leaks there are
14:23:36 <wagle> darwinports has ghc 6.4, fink has 6.2
14:23:40 <pesco> Also, darwinports might be more up-to-date, because they're easier to make than fink packages.
14:23:56 <pesco> And you can always fix them yourself.
14:24:36 <blackdog> ok, fair enough. I've been relying on fink, maybe i need to check out darwinports as well... it's annoying to have two parallel systems, though. can they use each other's stuff?
14:25:16 <pesco> Like I said, I've contributed about 10 Portfiles since I started using MacOS again.
14:25:25 <blackdog> pesco: did you get this error?
14:25:30 <blackdog> /usr/local/lib/yi/HSyi.o: unknown symbol `_stg_int64ToInt'
14:25:38 <wagle> (three, you mean..  macosx, fink, and darwinports..  hmm  four, even: non-distribution stuff in /usr/local
14:25:54 <pesco> blackdog: No, I've not seen that.
14:26:06 <pesco> I have next to nothing in /usr/local.
14:26:15 <pesco> I don't use fink at all.
14:26:21 <blackdog> wagle: sure. but i'm willing to assume responsibility for stuff I build myself, and the base stuff doesn't change that much, right?
14:26:27 <wagle> pesco: so you think that /etc/ports is the only thing darwinports sticks outside of /opt?
14:26:32 <pesco> macos, well. It doesn't do much. Just sits there. ;)
14:26:43 <pesco> wagle: I _suspect_ so. Why do you ask?
14:27:09 <pesco> Summing up, I am _very_ happy with darwinports. ;)
14:27:36 <wagle> because i want to install darwinports, and i want to later reinstall macosx without breaking it
14:27:51 <pesco> BTW, the documentation has become pretty decent by now.
14:28:28 <shapr> My mind is so open I keep having to scoop it up with a spoon.
14:28:30 <pesco> wagle: Well, your darwinports tree will live wherever you put it (mine is just in ~/darwinports)
14:29:08 <pesco> wagle: But aside from that, I'm very sure it doesn't put anything in /usr or /usr/local.
14:29:11 <blackdog> so /opt isn't the canonical source - you can regenerate it whenever?
14:29:14 <wagle> i also want to be able to uninstall darwinports without leaving cruft behind
14:29:38 <pesco> wagle: I'd say /opt/local and /etc/ports should kill it away completely.
14:29:50 <pesco> Maybe the documentation has something to say...
14:30:30 <wagle> yeah.. i just dont trust documentation..  tends to bitrot
14:31:05 <wagle> so i gather info from various places, etf
14:31:07 <wagle> etc
14:31:19 <pesco> It installs some libraries in /Library/Tcl/darwinports1.0.
14:31:36 <wagle> oh yeah..  i saw that
14:31:48 <wagle> decided it wasnt so bad
14:31:59 <pesco> Just look though the Makefile, that's the safest way!
14:32:31 <wagle> i just am waiting to sit down and watch while I carefully walk it through an install
14:33:25 * pesco shrugs.
14:33:55 * pesco calls rm -r oldshit/.
14:34:03 <wagle> mkfs
14:35:41 <theorb> Just remember: The only way to securely delete files is to use a belt-sander.
14:35:52 * shapr agrees
14:36:42 <wagle> tipler claims that enough energy might exist at the end of the universe to recreate all of history
14:37:07 <wagle> so, there is no way to securely delete files..  8)
14:38:12 <pesco> OK, I'm going to bed.
14:38:18 * pesco waves good night.
14:38:44 <shapr> ddarius: did you actually understand what NeelK said in that comment on LtU?
14:41:14 <Darius> shapr: Some
14:41:30 <Darius> I've read a paper relating S4/modal logic to monads.
14:42:24 <poetix> shapr: You mean the one about premonoidal categories, comonads etc
14:43:54 <shapr> yeah, the one about S4/modal logic.
14:44:49 <wagle> there's only one paper on S4/modal logic?
14:46:32 <Darius> wagle: poetix is asking about the LtU thread (presumably)
14:46:58 <wagle> whats the LtU thread?
14:47:05 <wagle> (whats LtU?)
14:47:09 <poetix> http://lambda-the-ultimate.org/node/view/630/5390#5390
14:47:32 <poetix> Not everything on LtU is as scary as this
14:48:12 <poetix> There's a spectrum running from "slightly scary" to "really scary", with this sort of scariness close to the "really scary" end.
14:48:56 <Darius> Andris Birkmanis looks to be at least an intermediate stage research paper junkie.
14:49:14 <shapr> Sometimes the Oleg stuff is worse, because I really do know at least *something* about language design, type theory, etc, and then I read an Oleg post and I see that what I know is so very small.
14:49:23 <poetix> I am trying to raise my scariness quotient by small incremental steps. Andris is a few large steps ahead of me there...
14:50:08 <shapr> At least with this neelk comment I can comfort myself that I've not yet really pursued category theory.
14:50:49 <poetix> With Oleg it isn't just what he knows, but the sheer wizardry with which he deploys it. The stuff I think I understand, albeit partially, is just gobsmackingly clever.
14:52:28 <poetix> Well, I must leave off a) LtU maven hero-worshipping, and b) trying to persuade Yi to compile, as my SO is calling for me.
14:52:32 <wagle> barr and well's 3rd edition is quite good (thick, hopefully thorough, but geared to cs people)
14:52:41 <shapr> poetix: nice to see you again
14:52:55 <poetix> Later...
14:53:06 <shapr> I have to sleep.
14:53:19 * shapr attempts to pry himself away from the keyboard
14:54:49 <wagle> killall -SLEEP shapr
14:54:53 <shapr> :-P
14:55:06 <wagle> heh
14:55:45 <kaol> only shapr himself or root have the necessary rights to do that
14:56:26 <blackdog> also, do you have a unique shapr process?
14:56:33 <wagle> sudo killall -SLEEP shapr
14:56:44 <kaol> doing that to his login shell should work
14:56:49 <wagle> killall gets all the processes
14:57:19 <kaol> or X server if that's what's running on him
15:01:01 <basti_> ltu is so bizarre that i actually laughed reading that post
15:01:23 <Darius> basti_: Bizarre?
15:02:01 <basti_> i mean imagine printing out that article, going out to the street and telling some passer-by to read it aloud
15:02:24 <basti_> "What does this mean? The categorical semantics of the simply typed lambda calculus is a cartesian closed category, and what Moggi's metalanguage does is give a categorical semantics for lax logic"
15:02:39 <Darius> basti_: You think it would be better for most other domains?
15:02:54 <basti_> probably not
15:03:03 <Darius> basti_: Most people wouldn't even be able to pronounce the words for say biology or chemistry.
15:03:39 <basti_> hmm.
15:10:23 <gzl> i think set theory would be funny.
15:10:45 <gzl> "Wait, what is all this about mice, hand grenades, and daggers?"
15:10:56 <Darius> gzl: Bah, category theory is much more crazy sounding.
15:11:23 <gzl> i dunno, can category theory beat "zero hand grenade" and "iterable premouse"?
15:13:00 <tuomov> eh, what kind of set theory is that?
15:13:38 <tuomov> some people just call some symbols with strange names (dagger is normal, though), or are those real concepts with no other names?
15:14:19 <Darius> gzl: I don't know any off the top of my head, but in the areas related to topology I bet it gets funky.
15:51:09 * mwc has completed the Haskell tutorial
15:52:29 <thou> mwc: sounds like an accomplishment
15:53:16 <Darius> mwc: Which?
15:53:31 <mwc> the Hal Daume one
15:53:52 <mwc> and now I need to do something with it to cement the knowledge
15:54:41 <mwc> is there a way to use a non-Cabalized package with GHC 6.4 or am I SOL?
15:56:47 <Darius> mwc: It may be finaglable, but I'm not sure how or if it's worthwhile.  Asking on the GHC mailing list (after checking past posts) may be a good idea.
15:58:17 <mwc> I may as well ask here what the "favourite" UI toolkit for Haskell is
15:58:47 <mwc> just let me get some smore-supplies before the flames start
15:59:46 <Darius> wxHaskell is probably your best bet
15:59:48 <blackdog> wxhaskell is more or less standard now, i think?
16:00:02 <Darius> blackdog: de facto and barely at best
16:00:54 <mwc> Darius, heh, that's what I'm trying to get working
16:01:33 <blackdog> Are the higher-level interfaces still being worked on? Fudgets and whatnot?
16:02:26 <Darius> blackdog: Not with strong community backing and none appear to be anywhere near ready.
16:02:56 <phusen> anybody want to talk about complexity?
16:03:13 <mwc> Only in simple terms
16:03:20 <phusen> great
16:03:49 <Darius> mwc: You have to build from source if you want a GHC 6.4 wxHaskell (unless they've made a binary).  The only (special) "difficult" part is actually registering the package.
16:03:50 <monochrom> what is the complexity of "complexity"?
16:04:23 <phusen> given a binary search tree, I want a function to return a list of elements in some range
16:05:12 <phusen> so in my function, I have this line: | otherwise   = rangeSearch min max t1 ++ ((v,x):(rangeSearch min max t2))
16:05:28 <phusen> and of course some base cases
16:06:02 <phusen> so I'm worried, that (++) has complexity linear in its left argument
16:06:33 <phusen> so maybe my function will have quadratic complexity in the size of the output
16:06:44 <phusen> put maybe lazy evaluation helps me out
16:07:49 <blackdog> unless you're not going to look at the whole list, i don't think lazy eval helps you here
16:08:31 <Darius> phusen: If the binary tree is totally left associated, I believe you are foldling (++) on a list essentially.
16:09:23 <Darius> phusen: Either way you are "redoing" some work, you might as well switch to another approach.
16:09:31 <mwc> Darius, yeah, exactly, I'm gonna have to become an expert on Cabal it seems, since it's probably a big job to write the file for such a complex package
16:09:55 <Darius> mwc: Technically you should only need to translate the old package info.
16:10:20 <mwc> Darius, heh, I usually don't bet on things being easy
16:10:51 <phusen> my input is of type: data Dictionary a b = Nil | Node (a,b) Height (Dictionary a b) (Dictionary a b)
16:11:12 <Darius> mwc: Actually I did it before (to an extent) with the binary package, but since I was using 6.2.2 binaries with 6.4 it didn't work (or at least I assume that's the problem).  It did seem to register alright.
16:11:12 <phusen> and it is an AVL-tree, ie. it's balanced
16:12:00 <mwc> Darius, yeah, GHC breaks bincompat with every other patch
16:12:50 <mwc> gonna try the CVS on wxHaskell
16:13:11 <phusen> what do you mean by a left associated tree?
16:13:18 <Darius> mwc: Twiddling some bits in the 6.2.1 wxHaskell to make it work with 6.2.2 worked, but 6.4 is a bigger change.
16:15:57 <Darius> phusen: The result you'd get foldling (\x y -> Branch x (Leaf y)) over a list, i.e. one of the two maximally unbalanced trees.
16:16:05 <Darius> phusen: You shouldn't have this problem with an AVL tree.
16:16:28 <phusen> ok
16:17:21 <mwc> phusen, imagine reading the dictionary into some kind of unbalanced tree
16:17:30 <mwc> you'd have a right assoc tree
16:19:23 <phusen> but I was wondering whether the leftmost elements of the list being constructed are parsed many times
16:19:37 <Darius> phusen: With a balanced tree at each level in the worse case you'd copy half of all the elements in the tree, so you gen n log n.
16:20:30 <mwc> phusen, at the worst you're off by a constant factor, I'd say
16:22:12 <Darius> Using an approach that provided a constant time append the complexity should be O(n)
16:23:06 <Darius> phusen: You may want to look at the paper, "Concatenate, Reverse, and Map Vanish For Free".
16:24:50 <phusen> yes, the data type should allow for O(n) running time
16:25:19 <phusen> (but O(n log n) is good enough for my needs)
16:27:24 <phusen> but are you sure about O(n log n) using my approach?
16:28:05 <phusen> I think you might visit the same levels many time
16:28:18 <Darius> Pretty.  Each level you copy the list generated by the left tree of all trees at that level.
16:28:20 <phusen> suppose all of the elements are in the range
16:28:41 <Darius> phusen: I am assuming all elements are in range for simplicity
16:30:38 <Darius> phusen: The constant factor probably isn't pretty and there's a corresponding space factor that wouldn't exist with (a typical) O(n) version.
16:31:31 <Darius> (Though maybe not a live space factor)
16:32:30 <phusen> OK, I'm getting convinced about O(n log n) now :)
16:32:53 <Darius> phusen: But defining cons x xs = (x:) . xs, and nil = id, and shadowing (++) with (.) and replacing (:) and [] with cons and nil is all you need to do.
16:33:00 <phusen> I'm not concerned with space or constant factors
16:33:34 <Darius> phusen: In fact, if it weren't for the fact that constructors and functions are in different "namespaces" you could just "shadow" (:) and [] as well.
16:35:09 <Darius> phusen: Oh, and you'd have to apply the result to [].  All of this can be abstracted into a higher order function (i.e. by passing the definitions of cons nil and (++) into your code).
16:35:41 <Darius> This is what is done in the "Concatenate, Reverse, and Map Vanish" paper.
16:35:47 <phusen> ah
16:43:11 <phusen> ah, so this constructs a function that creates the list, only appending to the front
16:45:04 <phusen> or something like that?
16:45:57 <phusen> but I suppose when considering running times in Haskell, it all depends on how you use the output
16:47:26 <Darius> phusen: Well actually two things, 1) the concatenate, reverse, map vanish approach doesn't have to use that representation, it can in fact use any (including (:) = (:), [] = [], (++) = (++) or (:) = Leaf, [] = Empty (++) = Branch) and 2) (++) would be fast if it were right associative the functional list representation just makes all "(++)"'s right associative.
16:48:14 <Darius> phusen: Not exactly, it partially depends on how (or more whether) the output is used but it depends on other things as well.
16:57:48 <phusen> well, those approaches are clearly above the level of this assignment I have
16:58:14 <phusen> so I guess, I'm on to stating that the complexity is O(n log n)
16:58:26 <phusen> but thanks for your help :)
17:43:49 <KrispyKringle> In Parsec, can't notFollowedBy be given a string parser? The docs seem to say it can be, but I'm getting a type error; it seems to expect a GenPArser Char st Char.
17:44:39 <Lemmih> @type Text.ParserCombinators.Parsec.notFollowedBy
17:44:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown command ':lambdabotFlags'
17:44:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- use :? for help.
17:44:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- command 'lambdabotFlags' not defined
17:44:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Text.ParserCombinators.Parsec.notFollowedBy :: forall st tok.
17:44:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                (Show tok) =>
17:44:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                Text.ParserCombinators.Parsec.
17:44:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prim.GenParser tok
17:44:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:44:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- st
17:44:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:44:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- tok
17:44:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                -> Text.ParserCombinators.
17:44:59 <KrispyKringle> wow. illegible! :P
17:44:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Parsec.Prim.GenParser tok
17:45:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:45:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- st
17:45:05 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:45:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ()
17:45:45 <gzl> hahaha
17:45:50 <gzl> what was that
17:45:56 <Lemmih> It takes a 'GenParser tok st tok'.
17:45:59 <KrispyKringle> *shrug*
17:46:15 <KrispyKringle> Lemmih: that allows it to take a string parser, no? I'm a little confused by these type signatures.
17:46:22 <Lemmih> Your type-error must be located elsewhere.
17:47:08 <KrispyKringle> Lemmih: I don't think it is: http://rafb.net/paste/results/mdxOB250.html
17:47:10 <KrispyKringle> is it?
17:47:35 <Darius> GenParser tok st tok when tok = Char is GenParser Char st Char with st = () it's Parser Char
17:47:43 <KrispyKringle> i tried it with do{ notFollowedBy (string "b")}
17:48:07 <Darius> You can only use notFollowedBy with things that return a tok (presumably a Char in this case).
17:48:12 <KrispyKringle> ah.
17:48:23 <KrispyKringle> string doesn't return a tok?
17:48:36 <Darius> string presumably returns a String
17:48:44 <KrispyKringle> right. ok.
17:49:00 <KrispyKringle> but char returns a Char...
17:49:07 <KrispyKringle> So what's a tok?
17:50:11 <KrispyKringle> what I really want to do is match strings that don't contain a certain string.
17:50:20 <KrispyKringle> I'm not sure what the best way is to do this, though.
17:52:36 <Lemmih> @seen SyntaxNinja
17:52:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen SyntaxNinja
17:54:12 <Lemmih> KrispyKringle: Try posting some code.
17:55:10 <Darius> KrispyKringle: If you are using type Parser a tok is a Char.
17:55:13 <skew> I think gzl wanted to do the same thing
17:57:42 <skew> Are you also working with a Wiki?
17:57:43 <KrispyKringle> skew: probably. He's been stealing my ideas all week.
17:57:52 <KrispyKringle> more or less. :-/
17:57:53 <gzl> haha, right.
17:58:10 <KrispyKringle> Darius: ah.
17:58:44 <Lemmih> What's the function of a .lib file in windows?
17:58:47 <KrispyKringle> Lemmih: Well, what I ultimtaely want to do is parse strings up until a given string. e.g. if I don't want to accept "foo", given input "fogoofoo" i'd accept and return "fogoo".
17:59:41 <KrispyKringle> The reason I want this is I want to be able to specify tags to enclose text in, and I want to accept all text between tags that may include the start of a tag, but not the complete tag.
18:00:05 <KrispyKringle> So that, for instance, "<tag>lorum < ipsum </tag>" would be valid.
18:00:39 <KrispyKringle> If all close tags were to end with </, this would be fairly simple, but that wasn't my plan.
18:00:45 <KrispyKringle> er, start with.
18:03:53 <Darius> KrispyKringle: Parse up to the start of a tag, then attempt to parse the tag, if it parses fine else goto start.
18:05:54 <KrispyKringle> well, how could i do that, concretely? I'd have to do "(noneOf "<") <|> (char '['; notFollowedBy "restoftag")", which was why i wanted to use notFollowedBy on strings :P
18:06:21 <Darius> I.e. parse = many (satisfy (/='<')) >> parseTag <|> (char '<' >> parse)
18:07:41 <Darius> I think I messed up the precedence and of course you want to do something with this stuff, but you get the idea.
18:08:22 <KrispyKringle> i suppose. don't you need to do "try"?
18:08:32 <KrispyKringle> otherwise, it'll consume input on the failed parsing of the tag, no?
18:10:02 <skew> the type on notFollowedBy looks a bit restrictive, but I think the definition "notFollwedBy p = try (do c <- p; unexpected (show [c])} <|> return ())" should work for any type of parser
18:10:26 <KrispyKringle> skew: right, i'd have thought so. i suppose I should bea ble to construct my own version of notFollowedBy that works for this.
18:11:10 <Darius> KrispyKringle: It depends on whether you use try in parseTag or not, but possibly.
18:11:29 <skew> then you can construct your own string matching function something like many (notFollowedBy special >> anyChar)
18:11:33 <KrispyKringle> given that i wrote this around notFollowedBy, perhaps I *can* just rewrite notFollowedBy to work with strings, though.
18:11:37 <KrispyKringle> I don't see why not.
18:18:24 <KrispyKringle> anyway, ill be back later. thanks for the help.
18:29:15 <dons> @type ($)
18:29:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ($) :: forall b a. (a -> b) -> a -> b
18:29:22 <dons> @kind 1
18:29:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1 :: *
18:30:31 <dons> @seen SamB
18:30:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SamB is in #haskell. I don't know when SamB last spoke.
18:30:34 <SamB> hmm, is it just me or is seq a hack
18:30:51 <dons> did you see the @type issues caused by the .ghci patch?
18:31:05 <gzl> in WASH, how do you make a text link that performs the same action as a submit button?
18:31:12 <dons> check the logs from last night. i've reverted it for now.
18:31:14 <gzl> can't seem to find quite the right function to do it.
18:31:29 * SamB goes to check logs
18:32:29 <dons> I'd really like to not use the .ghci thingo. it breaks too many things.
18:33:23 <dons> also, test it on your own bot before submitting it up to me, then we won't have to pull the patch once it breaks the live lambdabot.
18:33:42 <SamB> hmm
18:33:44 <SamB> okay
18:34:57 <Pseudonym> "Live lambdabot" sounds spooky.
18:35:14 <Pseudonym> "I live!"
18:35:19 <dons> "it's alive!"
18:35:31 <SamB> would be spookier if lambdabot said it
18:35:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- of course I'm alive
18:36:05 <Pseudonym> Hmmm... not so spooky, no.
18:36:07 <SamB> lambdabot: then why aren't you using privmsg!
18:36:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:36:23 <Pseudonym> I think we can change that message.
18:36:35 <Pseudonym> lambdabot is a lot smarter than when that messge was put in.
18:36:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:36:38 <dons> not responding would be ok with me.
18:36:48 <dons> or only responding to @foo
18:36:51 * Pseudonym nods
18:37:32 <blackdog> morning dons. 3161 humming along?
18:37:55 <SamB> would definately make these conversations in which words are put into lambdabots mouth more fun...
18:37:59 <dons> blackdog, yep. got the assignment out on time. so  that was a relief
18:39:15 <blackdog> excellent. am hacking zopey stuff now... web programming's a
18:39:27 <blackdog> actually kind of fun, i'm surprised i didn't get into it before...
18:39:34 <ddarius> Pseudonym: When the 'bot responds with a suitably glib remark it will be smart enough.
18:39:49 <blackdog> did my lambdabot patches break the world, or have you just not had time?
18:40:05 <dons> not. I committed them last night.
18:40:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- This glib enough, fool?
18:40:27 <SamB> it will be glib enough when it is a privmsg
18:43:23 <SamB> it still looks like a notice to me...
18:43:44 <Igloo> It's meant to be a notice
18:43:51 <Pseudonym> As a matter of curiosity, why has it changed to a notice?
18:43:53 <Igloo> If your client makes notices ugly then you should fix it
18:44:03 <Igloo> Pseudonym: It's recommended in an RFC to avoid loops
18:44:31 <skew> it is forbidden to autorespond to notices
18:44:36 <dons> which we had a couuple of since there's been so many bots around
18:44:57 <SamB> well, when humans are pulling the strings, it needn't be a notice
18:45:07 <Pseudonym> That's true.
18:45:35 <dons> @wiki LambdaBot/Notices
18:45:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
18:45:38 <Pseudonym> The specific command name to pull the strings suggests it's a msg rather than a notice.
18:45:46 <ddarius> SamB: But when lambdabot is it should be, and it's lambdabot that should be providing the glib replies.
18:46:03 <Pseudonym> So at the very least, the command name should be changed.
18:46:07 <Pseudonym> Or another should be added.
18:46:16 <skew> Or both
18:46:16 <SamB> if lambdabot is smart enough to provide glib replies, lambdabot is smart enough not to get into loops
18:46:46 <Pseudonym> Right.  When we have two lambdabot instances arguing, THEN we know we've made it.
18:46:52 <dons> SamB, i'm very disinclined to not comply to the rfc.
18:46:59 <skew> you wouldn't want @sendMsg to send a notice and @sendNotice to send a message, would you?
18:47:13 <Pseudonym> lambdabot should also probably have support for /me and CTCP
18:47:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
18:47:21 <Pseudonym> That's annoying.
18:47:22 <dons> but the @msg issue is more interesting.
18:47:27 <SamB> dons: the RFC doesn't cover using bots as puppets, nor does it cover sentient bots
18:47:41 <dons> hence my last comment.
18:47:48 <Pseudonym> That it doesn't cover sentient bots is something of an omission.
18:47:58 <dons> well, it does talk about AI
18:48:08 <dons> so they almost got there ;)
18:48:11 <Pseudonym> More A than I, though.
18:48:26 <SamB> haven't they officialy renamed that to AS?
18:48:44 <Pseudonym> Oh, is that the new buzzword?
18:48:53 <Pseudonym> 1950s: Electronic brain
18:48:58 <Pseudonym> 1960s: Artifician intelligence
18:49:07 <Pseudonym> 1970s: Neural net
18:49:11 <dons> I think I like Electronic Brain.
18:49:12 <Pseudonym> 1980s: Expert system
18:49:14 <SamB> you know, for artificial stupidity
18:49:20 <Pseudonym> 1990s: Agents
18:49:27 <Pseudonym> 2000s: AS?
18:49:30 <gzl> AS?
18:49:42 <Pseudonym> It just keeps changing every decade.
18:49:43 <gzl> what's AS?
18:49:58 <SamB> Artificial Stupidity!
18:50:06 <gzl> why do we need more of that?
18:50:15 <Pseudonym> I did hear "wisdom" mentioned at some point in the 90s.
18:51:23 <SamB> gzl: we don't. its just that Artificial Intelligence is a misnomer.
18:52:33 <gzl> what about "machine learning," was that one?
18:54:57 <Pseudonym> Hmmm.
18:55:03 <Pseudonym> Oh, that might have been in the 60s.
18:57:59 <gzl> damn, a whole decade of expert systems?
18:58:06 <SamB> when is this "last night" you speak of, and what do I need to look for in the logs?
18:58:07 <gzl> the 80s really did suck.
18:58:40 <SamB> expert users work much better
18:58:58 <dons> SamB: last night meant last 12 hours. here: http://tunes.org/~nef/logs/haskell/05.04.10
18:59:03 <dons> grep for 09:38:13 <TheHunter_> @type ($)
18:59:03 <gzl> yeah, "error between chair and keyboard," etc. :)
18:59:19 <dons> or, i can show you: 09:38:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown command ':lambdabotFlags'
18:59:32 <SamB> gzl: error is not between chair and keyboard when is system trying to be expert
19:00:01 <gzl> heh
19:00:20 <SamB> or at least, not the user's chair and keyboard
19:08:12 <SamB> dons: oh well. I may revisit ghci usage at some point in the future, but I don't feel like it right now...
20:07:56 <mugwump> how big is a Haskell -> template haskell -> C-- -> binary "Hello, World?"
20:08:20 <mugwump> (not sure on the exact sequence there)
20:08:31 <Cale> how big?
20:09:07 <mugwump> mmm.  roughly, ie, could you write /sbin targeted tools with it?
20:10:00 <mugwump> I saw pugscc making ~5MB binaries, but was wondering if simple cases can be much smaller, ie, without bundling the pugs interpreter :)
20:10:29 <dons> pill00$ du -hs a.out
20:10:29 <dons> 188K    a.out
20:10:46 <dons> on the mac, we have dynamically linked rts and friends, so hello world is around 5 k.
20:11:08 <Cale> here, I get a 272k Hello World
20:11:13 <dons> strip?
20:11:25 <Cale> yeah, 180k :)
20:11:30 <Darius> mugwump: Did you try to strip the binary?
20:12:16 <dons> as long as you don't use a lot of statically linked HSlibs, then the size stays sane.
20:12:38 <dons> once you start pulling in all the packages out there, without dynamic linking, then the static binary size gets large.
20:12:41 <Darius> mugwump: Anyways, GHC doesn't dynamic link anything on all but MacOSX(?), but that should change shortly (probably already has in HEAD)
20:12:53 <dons> already has.
20:13:06 <dons> let's see...
20:13:40 <dons> stealth$ ghc -dynamic t.hs
20:13:41 <dons> stealth$ du -hs a.out
20:13:41 <dons>  32K    a.out
20:13:41 <dons> stealth$ strip a.out
20:13:41 <dons> stealth$ du -hs a.out
20:13:43 <dons>  28K    a.out
20:13:49 <dons> stealth$ uname -msr
20:13:50 <dons> Darwin 7.8.0 Power Macintosh
20:16:14 <wagle> hey cool..  i just crashed BeOS on my mac
20:17:13 <mugwump> 28k is small alright.
21:00:56 <dons> blackdog, heard the flaming lips version of seven nation army? pretty fun.
21:05:55 <SamB> hmm, apparantly setting the clock forward an hour (via NTP) causes your screensaver to kick in...
21:10:08 <wagle> time sure flew
21:13:00 <SamB> I think something screwy happened involving a power failure, daylight savings time, and presumably a non-UTC BIOS clock happened...
21:14:30 <wagle> i've never seen linux switch daylight savings time if the bios clock wasnt utc
21:15:20 <SamB> I don't really have a clue what happened...
21:15:56 <SamB> actually, it probably was more of a matter of nothing having happened to the BIOS clock.
21:16:16 <SamB> or I don't know...
21:16:35 <wagle> bios's know nothing of time zone
21:16:38 <SamB> right
21:17:06 <wagle> you know about the hwclock command, right?
21:18:11 <SamB> not at the moment
21:18:49 <wagle> reads/sets/etc the bios clock from linux
21:19:38 <wagle> hwclock
21:19:45 <wagle> hwclock --systohc
21:19:58 <wagle> hwclock --hwtosys
21:20:06 <wagle> are the two main incantations
21:20:12 <wagle> s/two/three/
21:22:30 <SamB> hmm, it looks like my bios clock is in local time now, which is probably not helping
21:23:19 <wagle> ntpdate command does nothing to the hw clock
21:23:35 <SamB> well, yeah. of course.
21:24:13 <wagle> my usual sequence is: ntpdate truechimer ; hwclock --systohc
21:24:50 <wagle> when you boot, the linux rc.d scripts will read the hwclock
21:25:28 <wagle> ntp wont even try if you are more than a few minutes off
21:28:05 <blackdog> dons: no, i haven't. i don't dig the flaming lips that much, to tell the truth... little bit too wispy
21:30:40 <SamB> well, I seem to have managed to get my hardware clock into UTC, and I have that in /etc/adjtime
21:32:12 <dons> yeah. I agree. this version wasn't though.
21:36:42 <wagle> SamB: hopefully, thats a correct way to set to utc..  8/
21:37:17 <SamB> it worked, though it upped the drift value because of the clock having "drifted" an hour...
21:37:23 * wagle is cynical enough to believe that utc flags exist in 3-5 files
21:41:14 <SamB> it looks like debian is saner than most in this respect...
21:42:25 <SamB> but the documentation seems to be decietful
21:42:41 <wagle> if you find the gui that sets the utc flag, then that will set the flags in all but 0-1 of those 3-5 files..  8)
21:43:54 <wagle> command line tends to get one file at a time..  (so, i'm endlessly looking stupid to command line mavens..  of course, i try to figure out what the gui thinks is the correct thing_
21:46:28 <mugwump> http://nopaste.snit.ch/paste # any ideas for getting this working?  I know it's a pugs question, but ... what's going wrong here?  :)
21:47:05 <mugwump> http://nopaste.snit.ch:8001/2306 is the real URL :)
21:48:15 <SamB> I found two files, and I don't think there are any more
21:50:10 <wagle> SamB: i have years of scar tissue, so I expect the worst
21:50:48 <SamB> the worst is my system comes up with a totally wrong time on the next boot
21:50:57 <SamB> isn't it?
21:50:59 <wagle> two is not unlikely..  one for the boot sequence, one for whatever actually flips the savings time
21:51:30 <wagle> worst is that it doesn't flip the savings time in 6 months, probably
21:51:46 <SamB> nothing has to flip the savings time if I use UTC for my hardware clock...
21:52:58 <wagle> huh..  maybes thats why savings time only works right if you are in utc..
21:53:36 <wagle> i didnt think about it more than to decide to always try to set the utc flag when installing
21:54:11 <SamB> the thing is, I thought I had done that!
21:54:18 <SamB> I may actually have done it, too.
21:55:12 <wagle> i did most of my sysadmining in indiana, which doesnt fool with daylight savings time
21:56:26 <SamB> it certainly does not make much sense -- why save daylight starting in the spring? wouldn't it make sense to save daylight all year round?
21:57:00 <SamB> like, including WINTER, when there is the least daylight?
21:57:49 * wagle shrugs
21:59:55 <wagle> i guess i dont might dawn occurring at 5am instead of 4am in the summer
22:00:05 <wagle> ... dont mind ...
22:00:48 <SamB> oh, yes, they should call it darkness saving time ;-)
22:00:53 <wagle> hehe
22:02:52 <wagle> mugwump: where's the new contents of Prim.hs?
22:03:49 <mugwump> wagle: I've got it compiling, so I'll write a test and commit ;)
23:33:22 <Oejet> How are the articles for TMR2 coming along?
23:47:27 <dons> @yow
23:47:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- The fact that 47 PEOPLE are yelling and sweat is cascading down my
23:47:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SPINAL COLUMN is fairly enjoyable!!
