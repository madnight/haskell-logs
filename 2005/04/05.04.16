00:07:54 <skew> I love how simulating algebraic data types in Java with class hierarchies requires making a different file for every data constructor
00:08:03 <skew> It's just so ridiculous
00:15:51 <skew> I'd like to see a refactoring brower handle the Aardappel source...
00:24:00 <blackdog> evening, all. anyone watching the rugby tonight? </slim hope>
00:27:49 <dons> blackdog, on free to air?
00:28:21 <dons> doesn't look like it
00:43:10 <blackdog> dons: nope. I'm heading down to the carlisle castle with some friends.
00:44:04 <blackdog> ...hoping that they actually show it. oh well, there's always the courthouse.
00:45:17 <blackdog> shapr or any other zope hackers around? I want to talk about hazopeskell some more. (go on, _you_ come up with a better name...)
00:52:54 <pesco> Morning!
00:59:04 <jlouis> I've played around with Zope for 2 days now. My conclusion is I absof*ckinglutely hate it
00:59:41 <wilx> Heh.
00:59:51 <wilx> PHP? No wonder :)
01:00:05 <desrt> that's zend :)
01:00:25 <wilx> ?
01:00:38 <desrt> zend.. the php compiler
01:00:50 <wilx> Oh.
01:00:56 <wilx> So, what is Zope?
01:01:10 <desrt> cmf
01:01:31 <desrt> it's like plone, etc
01:03:45 <skew> isn't plone build with zope?
01:04:36 <desrt> ah.  i didn't know that
01:05:28 <skew> it's just about the first thing on their webpage
01:05:59 <skew> "Plone is built using Zope, an object oriented application server."
01:06:30 <skew> Oh, "cmf" means "content management framework"
01:06:59 <desrt> ya.  it's when you want to make a webpage without screwing around
01:07:27 <skew> Is that really a common acronym, or just in web stuff
01:10:01 * pesco shrugs.
01:10:01 <desrt> it's not even that common in web stuff
01:10:12 <desrt> some people say CMF some say CMS (system)...
01:27:44 <pesco> CosmicRay: Congratulations, you're now credited in my official WTFL license-file. http://scannedinavian.org/~pesco/WTFL
01:31:32 <sorje> hehe
02:02:00 <theorbtwo> Hello, Lambdas!
02:02:08 <theorbtwo> What would (->) [String] mean as a type?
02:03:24 <skew> what would (<) 2 mean as a function?
02:03:48 <skew> it's the same way with types
02:03:55 <skew> if it works at all
02:04:23 <theorbtwo> Well, it's in the Expected bit of a type mismatch error message.
02:05:43 <skew> That sounds a bit strange
02:06:15 <theorbtwo> So it's a function that expects an argument that is an array of strings, and returns nothing at all (not even a monad containing nothing)?
02:06:26 <skew> no
02:07:05 <skew> (->) String is a type of kind * -> *, like IO has kind * -> *
02:07:17 <boegel> thebug: it's a function that takes a certain number of Strings and returns a String too
02:07:36 <boegel> I think :)
02:07:37 <skew> you can't make a value of type IO, and you can't make a function of type (->) [String]
02:07:42 <skew> boegel: read that more carefully
02:07:57 <theorbtwo>     Couldn't match `(->) [String]' against `IO'
02:07:58 <theorbtwo>       Expected type: (->) [String]
02:07:58 <theorbtwo>       Inferred type: IO
02:07:58 <theorbtwo>     In a 'do' expression: ret <- eval_ code imports [] [] []
02:08:27 <boegel> skew: I'm wrong ?
02:08:45 <skew> both IO and (->) [String] are type constructors that need to be applied to one more type argument to give you a "real" type, like [String]->String or IO Char
02:08:51 <boegel> skew: I was just guessing really, telling my interpretation of it
02:08:53 <skew> boegel: there's only one argument to (->)
02:09:06 <skew> that's the infix form of the type constructor ->
02:09:17 <skew> String -> String and (->) String String are the same types
02:09:47 <skew> so (->) [String] is only partially applied
02:09:57 <skew> That's a bad error message
02:10:30 <skew> it really means that it inferred type IO a for some expression, but it was expecting type (->) [String] a, i.e. [String] -> a
02:10:46 <skew> I don't know why your compiler decided to leave out the a.
02:10:50 <boegel> skew: oh, I see
02:11:07 <boegel> a bit strange as error message dough
02:11:08 <theorbtwo> Hm, except the type of eval_ is...
02:11:14 <theorbtwo> eval_ code [import] [flags] [package.confs] [load paths] -> IO (Either [error-strings] (Maybe a))
02:11:30 <theorbtwo> Er, wait a sec, that's my notes, not the real sig.
02:12:15 <skew> I was hoping the common notation for using an infix thing in a prefix place would make this obvious, and I just needed to give a little push in the right direction
02:12:39 <theorbtwo> eval :: Typeable a => String -> [String] -> [String] -> [FilePath] -> [FilePath] -> IO (Either [String] (Maybe a))
02:12:57 <theorbtwo> s/eval/eval_/
02:13:16 <skew> I'll try providing only the correct answer and imparting absolutely no understanding for a while.
02:13:51 <skew> theorbtwo: add a [] after the call to eval_
02:13:59 <theorbtwo> Egads.
02:14:04 <theorbtwo> I just misscounted again?
02:15:10 <theorbtwo> Nope, that just gives the "is applied to too many arguments" error.
02:15:20 <skew> hmm
02:15:27 <theorbtwo> (With the Expected type that I expected, which is a plus.)
02:15:48 <skew> your do is used in the wrong context
02:15:54 <skew> maybe
02:16:06 <skew> can you post the code?
02:16:14 <skew> is this GHC you are using?
02:16:56 <skew> because it decided that your do expression is using the monad (->) [String]
02:19:37 <theorbtwo> http://sial.org/pbot/9380
02:19:47 <theorbtwo> The Glorious Glasgow Haskell Compilation System, version 6.5
02:19:56 * theorbtwo should possibly find a package of 6.4.
02:22:10 <skew> theorbtwo: remove [String] from the type of evalHaskell
02:22:27 <theorbtwo> Yeah, I just realize that...
02:22:29 * theorbtwo sighs.
02:23:14 <theorbtwo> I had it taking a code :: String and an imports :: [String], but got rid of the second parameter when I started having these problems.
02:23:25 <theorbtwo> ...but only in one place.
02:23:57 <autrijus> aren't types fun?
02:24:30 <theorbtwo> Um, if I say "no", the lambdas will beat me to a bloody pulp, so yes, tons of fun.
02:24:38 <dons> hooray!1
02:24:48 <dons> types for everyone
02:24:50 <dons> free types for all!
02:25:06 <autrijus> dons :: forall a b. a -> b
02:25:19 <theorbtwo> That looks like a pretty free type to me.
02:25:29 <dons> I don't like that one so much.
02:25:59 <autrijus> hey dons. I was working on Inline::GHC support for perl5 yesterday
02:26:11 <autrijus> I see eval_s etc
02:26:19 <dons> yeah.
02:26:26 <autrijus> it should be a straightforward improvement to just cast it into a dyn
02:26:30 <autrijus> and return that dyn, right?
02:26:41 <autrijus> so that
02:26:49 <autrijus> my $x = hs_eval("1 + 2")
02:26:55 <autrijus> my $y = hs_eval("'x'")
02:27:01 <autrijus> can both work reasonably
02:27:03 <dons> can you unwrap the dynamic on the perl side though?
02:27:11 <autrijus> also this: my $x = hs_eval("return 1 + 2")
02:27:16 <autrijus> err
02:27:24 <autrijus> my $x = hs_eval("return (1 + 2)")
02:27:32 <autrijus> dons: the "perl side" turns out to be a C wrapper
02:27:42 <autrijus> so as long as there's an api somewhere that let me do that, sure
02:27:52 <dons> hehe. I don't think that exists.
02:28:03 <dons> but you can use normal FFI marshalling to get it to a Ctype
02:28:06 <autrijus> so I need to play binary unpack games? fun
02:28:09 <dons> on the Haskell side.
02:28:14 <autrijus> okay.
02:28:19 <autrijus> so force it into a SV
02:28:24 <autrijus> (that is a Scalar Value pointer)
02:28:31 <autrijus> that looks like a win. thanks!
02:28:52 <dons> interesting.
02:29:04 <theorbtwo> Where is liftIO defined?
02:29:34 <autrijus> Control.Monad.prettymucheverything
02:29:39 <dons> @type Control.Monad.Trans.liftIO
02:29:40 <lambdabot> Control.Monad.Trans.liftIO :: forall (m :: * -> *) a.
02:29:40 <lambdabot>                               (Control.Monad.Trans.MonadIO m) =>
02:29:40 <lambdabot>                               IO a -> m a
02:29:51 <dons> free kinds for all!
02:30:46 <autrijus> dons :: forall (m :: * -> *) a . m a -> a
02:30:53 <autrijus> mmm unsafePerformAny
02:31:04 <dons> mmm.
02:31:07 <dons> tasty
02:32:11 <dons> hs_eval :: Storable a, Typeable a => String -> a, then do something from there to ffi-ify it
02:32:46 <autrijus> yup.
02:33:08 <autrijus> hmm, can you put IO in it?
02:33:16 <autrijus> I'd like both "IO a" and "a" to transparently work.
02:33:21 <dons> not if it's Typeable
02:33:29 <autrijus> no I mean
02:33:48 <autrijus> class (Storable a, Typeable a) => Evallable a where ...
02:33:58 <autrijus> err, wrong
02:34:06 <autrijus> class Evallable a where ...
02:34:20 <autrijus> instance (Storable a, Typeable a) => Evallable a where ...
02:34:21 <dons> this sounds like a good idea.
02:34:24 <autrijus> instance (Storable a, Typeable a) => Evallable (IO a) where ...
02:34:37 <autrijus> there can be others too
02:34:45 <autrijus> but the idea is that we can simply call the class method "eval"
02:34:50 <autrijus> without worrying too much
02:34:50 <dons> yes. this sounds good.
02:35:03 <dons> Send any code you get in this direction, and I'll add it to hs-plugins
02:35:19 <autrijus> alright. when I get the next batch of tuit supply :)
02:35:25 <autrijus> dons++ # hs-plugins is fantastic
02:35:43 <dons> then we get the type safety on the Haskell side, and let the foreign lang deal with it with it's own type system
02:35:51 <autrijus> yup. that's the idea
02:36:07 <autrijus> free type classes for all!
02:36:27 <dons> typesafe foreign eval for all!
02:36:51 <autrijus> Guile is dead! Long live GHC!
02:36:53 <autrijus> oops
02:36:58 <dons> whoohoo!
02:37:29 * dons goes back to hacking yi, so as to kill elisp
02:37:40 <vegai> how can you tell from Guile that it's dead? ;P
02:37:50 <autrijus> mmm the revenge of typed lambdas
02:59:36 <shapr> @floo
02:59:37 <lambdabot>          (__)
02:59:37 <lambdabot>          (oo)
02:59:37 <lambdabot>    /------\/
02:59:37 <lambdabot>   / |    ||
02:59:37 <lambdabot>  *  /\---/\
02:59:37 <lambdabot>     ~~   ~~
02:59:39 <lambdabot> ...."Have you mooed today?"...
02:59:47 * shapr cackles evilly
02:59:57 <Lemmih> shapr: How's the collective wiki coming along?
03:00:02 <theorbtwo> Allo, shapr.
03:00:07 <shapr> Status unchanged
03:00:12 <shapr> y0 theorbtwo
03:00:26 <skew> hi shapr
03:00:47 <shapr> y0 skew
03:00:50 <skew> I managed to get aardappel to compile
03:01:03 <shapr> cool, did you get the parallel tree eval happenin?
03:01:10 <skew> that doesn't work
03:01:17 <shapr> oh
03:02:16 * shapr boings cheerfully
03:02:51 <shapr> Arctic winters are very motivational. Once it starts getting light again, *everybody* goes outside.
03:03:07 * theorbtwo grins.
03:03:18 <theorbtwo> I thought you lived... um, somewhere in the US.
03:03:41 <shapr> Five years ago, yes. Nowodays I live 70km/40miles south of the Arctic Circle.
03:04:08 <theorbtwo> Hm, I don't feel like going to the effort of doing a whois or dig on an IPv6 address.
03:04:16 <shapr> ?
03:04:30 <theorbtwo> Your whois shows an ipv6 addr.
03:04:43 <shapr> I'm in Boden, Sweden. The nearest big city is Lule√•.
03:04:55 <shapr> I'm pretty close to the point where Sweden, Finland, and the Gulf of Bothnia touch.
03:05:02 <theorbtwo> Ah, OK then.
03:05:15 <theorbtwo> That explains the #haskell.se membership.
03:05:26 <shapr> Yup, I'm learning Swedish.
03:05:40 <Lunar^> theorbtwo: It's a 6to4 address, really
03:05:50 <theorbtwo> Yeah, I know.
03:06:04 <theorbtwo> And if I googled a bit, I could probably figure out how to get it back to an ipv4 addr.
03:06:05 <shapr> You too can have a 6to4 address if you read CosmicRay's HOWTO!
03:06:12 <theorbtwo> But it's way more effort then it's worth.
03:06:27 <shapr> I can dig it.
03:06:40 <theorbtwo> Eh, but using ipv6 via tunnel means that I have to move packets over an even longer path.
03:07:11 <theorbtwo> Oh, and I could get an ipv6 addr that way, but I don't have a static ipv4 addr, so it wouldn't be all that useful.
03:07:14 <shapr> It's not a tunnel like freenet6. It is tunneling, but only until you reach the nearest 6to4 router.
03:07:54 <shapr> Luckily for me, the nearest 6to4 router is just a few hundred km south, and quite close logically speaking.
03:08:17 <theorbtwo> Aye, but the nearest 6to4 tunnel isn't all that close, networkally, I think.
03:08:22 <shapr> Oh
03:08:35 <theorbtwo> The german educational and commercial networks are fairly sepperate, for some silly reason.
03:08:52 <shapr> And most of the german 6to4 goodies are on the other half?
03:08:53 <theorbtwo> ...and I'm on a DSL connection, and not a terribly good one.
03:09:00 <shapr> oh, that sucks.
03:09:05 <theorbtwo> Yup.
03:09:14 <theorbtwo> It tends to go down on Sundays.
03:09:33 <theorbtwo> And as far as I can tell, there are no techs in the entire co on sundays.
03:09:35 <shapr> It takes the day off. And thinks you should too.
03:24:48 <TheHunter> hmm,     unknown flags in  {-# OPTIONS #-} pragma: -fno-pre-inlining
03:52:22 <pesco> theorbtwo: Where in Germany are you?
03:52:40 <theorbtwo> Munich.
03:53:13 <pesco> theorbtwo: Ah, hm. And you can't pursuade munet to give you a tunnel to their SixXS pop I take it?
03:53:17 <Arsilan> what does "mundane" mean?
03:53:25 <smott> common
03:53:42 <theorbtwo> I can, and have, in fact.
03:53:50 <theorbtwo> I could have sworn that it was several hops out of the way, though.
03:54:08 <Arsilan> tanks
03:54:21 * theorbtwo shrugs.
03:54:27 <pesco> theorbtwo: What's your round-trip time
03:54:28 <pesco> ?
03:54:33 <theorbtwo> Perhaps at some point I'll try to get my router to play nice to it again.
03:54:39 <theorbtwo> To?
03:54:51 <pesco> To the access point.
03:55:17 <pesco> Aggregator, POP, whatever they call it.
03:55:21 <pesco> The "server". ;)
03:55:50 <pesco> I'm in Hamburg, and after the up and down over new-year of deham1, they've been running reliably.
03:56:48 <theorbtwo> Hm, come to recall, I'm on deham1, with about 75ms ping.
03:57:04 <mflux> aika h‰mment‰v‰‰: http://www.tietoviikko.fi/doc.te?f_id=716317
03:57:10 <mflux> whops, wrong channel
03:57:51 <xerox> √§√§√§ :)
03:58:58 <pesco> theorbtwo: Oh, OK then. But where's the problem?
03:59:56 <pesco> I'm very happy, since my DSL line gets cut every day and the tunnel keeps my address static for IRC.
04:01:14 <dons> ghc msg of the day, part 2:
04:01:15 <dons>     My brain just exploded.
04:01:16 <dons>     I can't handle pattern bindings for existentially-quantified constructors.
04:01:32 <dons> I'm so glad I finally got that msg.
04:01:44 <pesco> @remember ghc My brain just exploded.
04:02:05 <pesco> dons: Isn't it rewarding? I've had it, too. Some months ago.
04:02:17 <dons> :)
04:02:38 <Lunar^> dons: ?
04:02:39 <pesco> Interestingly, with Haskell, such fatal errors actually feel _good_.
04:02:39 <TheHunter> that message is annyoing.
04:03:03 <Lunar^> dons: Is that an error message?!
04:03:08 <pesco> I find myself even enjoying, in some perverted way, segfaults and bus errors.
04:03:09 <dons> it's just a pattern matching error.
04:03:37 <pesco> "Wow, my Haskell program just segfaulted. How did I _manage_ that?!"
04:03:52 <pesco> ("Everyone's going to envy me about this!")
04:03:54 <dons> yeah - that's always fun. you know you did something really evil
04:04:17 <TheHunter> Lunar^, data Foo = forall a. Num a => Foo a; Foo x = Foo 1
04:04:19 <Lunar^> pesco: That's pretty easy to do with unsafePerformIO :)
04:04:42 <dons> I presume getting the typechecker to diverge is fairly fun too
04:04:44 <Lunar^> TheHunter: mhhh I see
04:04:54 <Lunar^> dons: sebc managed to do that once
04:05:02 <pesco> dons: Oh yes, I've yet to achieve such levels.
04:05:11 <dons> me neither.
04:05:17 <pesco> (And I'm hesitant to cheat by looking at the mailing list. ;))
04:05:31 <dons> TheHunter, in your type hackery, perhaps?
04:06:27 <TheHunter> i haven't got the typechecker to diverge yet.
04:06:33 <TheHunter> The inliner, however is fairly easy.
04:14:41 <pesco> Oh, right. The mailing list post was about the inliner, wasn't it?
04:26:34 <theorbtwo> @type ContT
04:26:42 <lambdabot> bzzt
04:26:52 <theorbtwo> @type Control.Monad.ContT
04:26:54 <lambdabot> bzzt
04:27:14 <wilx> @type Control.Monad.Trans.ContT
04:27:16 <lambdabot> bzzt
04:27:21 <wilx> Hm.
04:28:17 <Lemmih> You probably want what once were @info.
04:45:03 <Cale> where did @info go?
04:45:33 <dons> didn't we decide that @info was far too verbose?
04:45:35 <theorbtwo> Bitbucket: it tended to flood the channel.
04:45:55 <theorbtwo> (Of course, I never actually knew it was there until it was gone.)
04:46:19 <dons> just use ghci :info
04:48:51 <theorbtwo> Hm... I'm inside of an Eval do-block, and evalHaskell is a String -> IO String function which I want to get the String out of.
04:49:17 <theorbtwo> is retstr <- liftIO $ evalHaskell cstr not the way to do this?
04:50:30 <dons> sounds plausible, the way you state it
04:53:29 <dons> sleep!
04:53:38 <theorbtwo> Oh, I'm being somewhat silly.
04:53:44 * shapr is always silly.
04:53:52 <theorbtwo> One of the many error messages I can get it to emit is on the next line.
04:56:10 <shapr> w00, I'm in love - http://www.surlybikes.com/blogimages/Goiter.jpg
04:59:12 <Lemmih> ...
05:00:14 <shapr> Ain't it gorgeous? 65mm rim, 26" x 3.7" tire, magura hydraulic brakes.
05:13:54 <TFK> Hmmm. A skeptic is asking, "in what applications do you need infinite data structures?"
05:15:20 <zamez> you should reply: "in those which deal with your ignorance"
05:15:31 * zamez hides
05:15:37 <TFK> Not sure he'll be convinced.
05:16:45 <shapr> Lots of times you need infinite data structures.
05:17:06 <shapr> But in Haskell, there's not so much difference between data structures and code.
05:17:16 <xerox> Do trees accomplish the definition of `infinite data structures' ?
05:17:27 <shapr> For example, is this data or code? fib = 0 : 1 : zipWith (+) fib (tail fib)
05:19:15 <Cale> primes = sieve [ 2 .. ] where sieve (x:xs) = x : sieve [y | y <- xs, (y `rem` x) /= 0]
05:19:34 <shapr> In Haskell, if your code can deal with infinite lists as parameters, it almost always means your code will have advantageous laziness properties.
05:19:41 <Cale> sometimes it's unnatural to have finite data structures
05:20:23 <Cale> also, being able to deal with infinite data structures also means programs are able to deal with combinatorially large data structures
05:20:37 <shapr> That is, one chunk of data can go through your code like a pipeline, and then the maximum amount of memory usage is the runtime system plus the pipeline plus the size of your largest single chunk.
05:21:03 <Cale> If my program emits a tree with (10000!)! vertices, then I'm not going to be able to see every vertex.
05:21:10 <shapr> TFK: Any comments from the skeptic?
05:21:25 <TFK> Err, sorry, was away, on second.
05:21:34 <shapr> Who's on first?
05:21:40 <TFK> *one
05:21:44 <TFK> hehe
05:21:45 * shapr grins evilly
05:22:04 <TFK> Yup, those fibonacci examples from Gentle are quite cool.
05:22:20 <tuomov> infinite data structures simply make things more convenient to write sometimes
05:22:43 <shapr> And they can mix nicely with memoization.
05:22:46 <Cale> TFK: being able to produce and consume infinite data structures means more places become natural points for breaking down code into chunks
05:22:47 <tuomov> e.g. padding a string to given length: take n $ s ++ repeat " "
05:23:02 <tuomov> s/"/'
05:23:48 * TFK nods
05:24:49 <Cale> There are places where you simply can't break down a problem using eager evaluation because it would require huge or infinite structures which can't be evaluated.
05:26:45 <TFK> tuomov, how is your example more convinient, though? (Unless the string is infinite already.)
05:27:02 <Cale> as an example which I've used before (though it's not really perfect), consider the problem of determining if a given string is a substring of another.
05:27:10 <shapr> I think it makes for more general code as well. If your Haskell code works with all positive integers by using [1..] and just pulling out what it needs, it'll still work in five years on your 128 bit machine for numbers that are comfortable on that box. A C++ program may not scale smoothly to 128 bit numbers.
05:27:31 <TFK> (He's a C++ programmer, btw)
05:27:36 <TFK> :-P
05:27:40 * shapr grins
05:27:42 <tuomov> TFK: well, you could do something like "repeat_n n ' '", but it is already more code :)
05:27:58 <tuomov> let alone calculating the number of spaces really needed
05:28:07 <shapr> Right, in tuomov's example, repeat ' ' creates an infinite list of spaces.
05:28:10 <tuomov> and if you eagerly evaluate repeat_n, you may waste a lot of memory
05:28:10 <Cale> I might already have code which computes if one string is a prefix of another (that's easy to write)
05:28:47 <Cale> So I can say that x is a substring of y if it is a prefix of one of the tails of y.
05:29:15 <Cale> This would be unthinkably inefficient in an eager language
05:29:46 <Cale> but it's fine in a lazy language
05:30:20 <Cale> you're not going to compute all of the tails and store them separately
05:30:48 <TFK> Yes, but what about algorithms like KMP, which take streams?
05:30:59 <shapr> What's KMP?
05:31:05 <TFK> Won't what you suggested be O(n*m)?
05:31:22 <TFK> Knuth-Moris-Pratt algorithm. I implemented it once o_O
05:31:37 <tuomov> another thing infinite lists are nice for is zipping things
05:31:42 <tuomov> dig2int d = sum $ zipWith (*) (reverse d) (map (10^) [0..])
05:31:57 <tuomov> dig2int [1,2,3,4,5] => 12345
05:32:17 <TFK> Oh, nifty :-)
05:32:56 <Cale> TFK: it's doable, but similarly to the usual case, it's going to be a bit more involved to write
05:33:30 <TFK> But ultimately you'd want algorithms with a lesser Big O, no? I mean, the quicksort example is cool, but it will consume a lot of memory.
05:34:17 <TFK> (with big lists)
05:34:57 <shapr> In general, non-strict has the potential to be more efficient through amortization.
05:35:09 <TFK> What's "amortization"?
05:35:16 <shapr> At least, that's how I understand Okasaki.
05:35:32 <shapr> Basically it means put off doing stuff till you really need it.
05:35:38 <TFK> Okasaki, sounds Japanese.
05:35:51 <tuomov> dividing costs of costly operations to less costly ones
05:35:56 <shapr> I dunno, he's teaching at West Point these days.
05:35:58 <TFK> Yes, when you have a huge graph or a tree or whatnot.
05:37:32 <Cale> TFK: I wrote a pipeline scheduler for ppc+altivec assembly last summer -- it generated a (lazy) list of all possible schedules in order of decreasing greediness, to feed into the register allocator, which if it failed on the first schedule, could just look a bit farther into the list.
05:38:10 <Cale> The number of schedules was combinatorially large -- probably in the trillions.
05:38:19 <Cale> but I don't have to care :)
05:39:05 <TFK> That's the kind of example I was looking for :-)
05:40:37 <shapr> If you look at the queues implementation in the FP Algorithms book that uses two lists, you can see that the code (implicitly) only reverses the input items list when the output items list is empty. Most eager code immediately puts new input items on the end of the item list, costing that much more for every new item.
05:40:37 <Cale> The scheduler itself worked in that exact pattern -- from a list of a few initial empty schedules, it would take each schedule, and decide how it could expand it by adding one instruction (or ticking time forward one clock)
05:41:06 <Cale> in all possible ways :)
05:41:35 <Cale> these results were then concatenated -- you might recognise this as >>= from the list monad
05:41:52 <theorbtwo> Every time you add an element to a list might take twice as long in Haskell as in well-coded C.
05:41:53 <TFK> (I won't, I'm yet to learn about arrows ;-)
05:41:56 <shapr> There are lots of ways to use laziness to get increased efficiency. Those ways usually cost a bunch of extra code in strict languages.
05:42:08 <theorbtwo> But if you only do it a third as much, you've still make execution-speed gains.
05:42:08 <Cale> TFK: learn about monads before arrows :)
05:42:30 <TFK> Yeah, but before monads I have to finish Gentle :-)
05:42:37 <TFK> I'm still on chapter 8
05:42:59 <Cale> TFK: so basically, control flow in a lazy language can be structured using data structures
05:43:09 <blackdog_> man, that was a crappy game. one try and some penalty kicks... </offtopic>
05:43:22 <shapr> and that sort of control flow is a cool and sexy trick.
05:43:31 <TFK> This whole thing started when I wanted to implement (pseudo) infinite data structures in Python, and I wanted to show off. Then the other guy said, "huh?"
05:43:34 <Cale> lists *are* loops
05:43:37 <TFK> Hmmm.
05:44:06 <shapr> TFK: have you seen the recent Python generators discussion on the Haskell mailing list?
05:44:06 <Cale> (though it's a bit more sophisticated, because you basically have coroutine style passing of data back and forth)
05:44:17 <TFK> shapr, Haskell/Haskell-Cafe?
05:44:18 <tuomov> lists are coroutines
05:44:19 <blackdog_> shapr: how would you improve ZPT?
05:44:27 <shapr> blackdog_: use Halipeto
05:44:27 <TFK> I'm actually subscribed to those, lemme check.
05:45:05 <shapr> blackdog_: add DTD-based type checking to ZPT macros so they could be called top down instead of bottom up.
05:45:07 <TFK> shapr, which thread?
05:45:24 <shapr> It's got Python in the Subject.
05:45:24 <tuomov> Halipeto is such a cool name :)
05:45:40 * TFK can't find it :-(
05:45:46 <theorbtwo> Sounds like some sort of spicy pepper.
05:45:52 * TFK will utilize gmail's search function
05:46:17 <blackdog> shapr: looks interesting... might look through it for a little while.
05:46:19 <TFK> And bingo was his name-o!
05:47:39 <blackdog> b, i...
05:48:05 <theorbtwo> What are depreciated HTML presentation tags, Alex?
05:48:38 <theorbtwo> (Don't forget u and blink.)
05:49:21 <shapr> heh
05:49:29 <sorje> TFK, [Haskell] Control.Monad.Writer as Python generator ChrisK 05.04.12 23:09 ;-)
05:54:42 <TFK> sorje, unfortunatelly, gmail got there before you :-P
05:57:31 * CosmicRay returns
05:57:40 <shapr> blackdog: actually, more type checking in ZPTs sounds pretty nifty.
05:58:28 <blackdog> shapr: was going to ask you about that. What do you mean by DTD-based typechecking?
05:59:31 <blackdog> i dislike lots of things about zope, but the dynamicity of it is awesome. i was thinking about a haskellish acquisition trick: would it make sense to modify acquisition so that it matched the first one that typechecks?
06:02:47 <karingo> That definitely could be useful
06:04:26 <blackdog> i'm worried that it could be confusing... you make a function more general, and suddenly something starts working completely differently...
06:13:53 <karingo> Modifying it now would break everything that depends on its current behavior which would be bad
06:20:26 <theorbtwo> Bah.
06:20:53 <theorbtwo> I just spent about a half hour debugging a problem where it was signigilaning a lexical error on the line #include "../pugs_config.h".
06:21:04 <theorbtwo> Because it's OPTIONS_GHC, not GHC_OPTIONS.
06:23:57 <desrt> :)
06:24:36 * theorbtwo wonders why it doesn't flag a warning on unknown {-# foo _ #-} blocks and unknown options.
06:25:18 <theorbtwo> (And why {-# SOURCE #-} is not documented with a see also where the rest of them are documented.
06:26:24 * theorbtwo wonders if he ought to send a mail to the ghc list with these things.
06:26:41 <desrt> it seems that giving an error on an unrecognised comment is not really an appropriate thing to do :)
06:27:00 <theorbtwo> If it was just a comment, you could have left off the #es.
06:27:28 <desrt> maybe you liek #s though
06:27:31 <desrt> *like
06:27:37 <desrt> the point is that it's a comment
06:27:40 <theorbtwo> I did say warning, not error...
06:27:42 <TheHunter> desrt, raising an error on unrecognized pragmas would be a perfectly appropriate thing to do.
06:27:46 <desrt> ah
06:27:59 <desrt> a warning is somewhat less evil :)
06:28:08 <desrt> TheHunter; ... heh? :)
06:28:14 <theorbtwo> Well, not for me, because pugs compiles with -Werror.
06:28:47 <desrt> TheHunter; the *purpose* of a pragma is to be unrecognised
06:29:09 <TheHunter> that doesn't make any sense.
06:29:23 <desrt> or rather, to allow the program to continue to compile if it's unrecognised, but if it is recognised, to provide additional functionality
06:29:29 <TheHunter> if i have a spelling error in a pragma, i certainly want that to be recognized.
06:29:55 <desrt> right.. but say hugs decides to start reading {-# OPTIONS_HUGS #-}
06:30:05 <desrt> do you want the two of them throwing errors for each other's pragmas?
06:30:07 <theorbtwo> But the programmer intended for the pragmata to do something; otherwise they wouldn't have put it in there.
06:30:16 <theorbtwo> No, but I have no problem with them throwing warnings.
06:30:31 <TheHunter> #ifdef __HUGS__ ...
06:31:07 <theorbtwo> That'd be nice, if there were a way to use #ifdef without a compiler-specific pragmata.
06:31:29 <desrt> you really can't throw errors on unrecognised pragma
06:31:38 <desrt> and i can see throwing warnings becoming annoying quite fast
06:31:55 <theorbtwo> How about a nondefault warning?
06:32:17 <desrt> as with all non-defaults, anything is acceptable :)
06:32:18 <theorbtwo> It'd be really useful to not silently ignore the difference between GHC_OPTIONS and GHC_OPTION.
06:32:20 <TheHunter> desrt, warnings are the least you can do. And it makes an awful lot of sense.
06:32:41 <desrt> TheHunter; don't you mean OPTIONS_GHC? :)
06:32:43 <TheHunter> people are wasting hours because of spelling errors in pragmas.
06:32:52 <desrt> s/TheHunter/theorbtwo/
06:33:01 <theorbtwo> Speaking of spelling errors...
06:33:13 <theorbtwo> Anyway, now that I've finally fixed this problem, I need to go out shopping.
06:33:26 <desrt> TheHunter; that's because pragmas are a dirty thing to do :)
06:33:57 <theorbtwo> pragmata are sometimes neccessary.
06:33:57 <desrt> i mean, ideally, everyone would just implement haskell98
06:34:15 <theorbtwo> In fact, when they are used, they are almost always compulsary, I suspect.
06:34:26 <theorbtwo> That is, the program will not function correctly if they are ignored.
06:34:32 <TheHunter> some pragmas are even specified in the report.
06:34:42 <desrt> TheHunter; they are?
06:34:46 <TheHunter> i could never live with just haskell98
06:35:34 <desrt> the originally purpose of pragmas is to provide more information to implementations that support them while not harming those that do not
06:35:50 <desrt> so, all told, if it's critical to complation, {-#  #-} was a *really* bad choice
06:36:00 <desrt> considering either
06:36:05 <desrt> a) the compiler knows about it
06:36:06 <desrt> or
06:36:09 <desrt> b) it fails anyway
06:36:14 <ibid> haskell98 is like ISO C: for most stuff, it's too restricting but it helps to minimize the places where you go above it
06:36:16 <desrt> so why bother putting it in comments?
06:36:34 <TheHunter> The point is, pragmas are there for a reason, and if they're not recognized, chances are all hell will break lose.
06:36:53 <desrt> TheHunter; your argument doesn't hold very much ground :)
06:38:24 <desrt> theorbtwo; if you are going to write the list, maybe you should suggest that critical compile-time options get moved outside of comments
06:38:25 <TheHunter> desrt, consider {-# NOINLINE #-} and the unsafePerformIO hack.
06:38:36 <TheHunter> or condiser {-# OPTIONS -fno-cse #-}
06:38:37 <desrt> theorbtwo; since that way the compiler will flag them as errors
06:38:59 <desrt> theorbtwo; if it doesn't recognise them, that is
06:39:11 <TheHunter> in both cases, your program will go wrong and it will be very hard to debug.
06:39:53 <desrt> TheHunter; consider {-# HUGS_OPTIONS -foo #-} or {-# nhc98 -blah #-}
06:40:03 <desrt> in both cases, your program will totally fail to compile for no good reason
06:41:09 <TheHunter> you can use ifdefs or put it in a Makefile.
06:41:33 <desrt> you can't use ifdefs without invoking the chicken and egg problem
06:41:46 <desrt> but yes.  you can put it in a makefile
06:43:28 <TheHunter> and compilers could always choose to ignore pragmas they know other compilers are using (though that might be dangerous, too).
06:44:01 <desrt> TheHunter; that leads to unmanageability of the order of n^2 even *if* all projects release new versions of themselves at exactly synchronised times
06:44:12 <TheHunter> in the end, i think ifdefs are the way to go, pragmas are mostly needed for non-portable code anyway.
06:44:41 <desrt> TheHunter; will you please listen to what theorbtwo said about #ifdefs.  what you're saying makes no sense
06:44:41 <shapr> blackdog: halipeto calls aren't guaranteed to produce legal xml, but they could via Template Haskell or something if the sub-DTD of the chunk being generated were passed in. Make sense?
06:46:36 <TheHunter> desrt, what did theorbtwo say about #ifdefs?
06:46:56 <desrt> 08:31 < TheHunter> #ifdef __HUGS__ ...
06:46:56 <desrt> 08:32 < theorbtwo> That'd be nice, if there were a way to use #ifdef without a
06:46:56 <desrt>                    compiler-specific pragmata.
06:48:17 <TheHunter> if you're using pragmas, you usually don't care about compatibility.
06:48:52 <desrt> actually, that's *exactly* why you use pragmas
06:49:16 <TheHunter> for example using the unsafePerformIO hack in an implementation that doesn't support {-# NOINLINE #-} is just crazy.
06:49:23 <desrt> the exact reason that pragmas are placed inside comments is as to not break compatibility with other implementations
06:50:07 <TheHunter> then NOINLINE, etc. shouldn't be placed in pragmas at all.
06:50:12 <desrt> i agree
06:50:30 <TheHunter> But if pragmas are the only place where they can put, checking pragmas is better than not checking them.
06:50:51 <desrt> well.  i've given lots of reasons why i think you're wrong
06:50:55 <desrt> and i don't want to go over them again
06:50:58 <desrt> so i guess we disagree :)
06:51:22 <TheHunter> ok, then.
07:37:02 <tromp> i
07:37:02 <tromp> l
08:16:40 <minus273> hi all
08:17:24 <Lemmih> Hey
08:59:48 <TFK> "collatzW" o_O;;
09:14:21 <TFK> Heh. Does Haskell even need a yield-like construct?
09:20:46 <wagle> what does yield _mean_ functionally/declarationally?
09:24:24 <TFK> I'm not sure. I have to analzy the examples on the ml more.
09:24:30 <TFK> *analyze
09:31:45 <Lemmih> @type Control.Concurrent.yield
09:31:46 <lambdabot> Control.Concurrent.yield :: IO ()
09:32:25 <stil> i've a question
09:33:17 <stil> I want to write show for a datatype
09:33:29 <stil> but I must use a helper function in show
09:33:40 <stil> but I must use a helper function for show.. better
09:34:01 <stil> but "\n"
09:34:09 <stil> it becomes problem
09:34:14 <stil> like
09:34:42 <stil> >> show (xy (5) (4))
09:34:50 <stil> >> "5\n4"
09:35:11 <stil> but I want \n to be the newline
09:35:25 <Lemmih> '\n' _is_ a newline.
09:35:27 <stil> anyone know how to handle helper functions with show instances
09:35:40 <stil> okay, I know :)
09:35:49 <stil> but it doesn't act like a newline
09:36:02 <stil> in fact I can paste the function
09:36:27 <stil> instance Show a => Show (NTree a) where
09:36:28 <stil>    show (Node(val,clist)) = show2 0 (Node(val,clist))
09:36:35 <stil> indenter 0 = []
09:36:36 <stil> indenter k = "    " ++ indenter (k-1)
09:36:37 <stil> show2 k (Node(val,[])) = (indenter k) ++ "(" ++ show val ++ ")" ++ "\n"
09:36:38 <stil> show2 k (Node(val,clist)) = (indenter k) ++ "(" ++ show val ++ "\n" ++ (foldl (++) "" (map (show2 (k+1)) clist)) ++ (indenter k) ++ ")" ++ "\n"
09:36:42 <Lemmih> @paste
09:36:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:37:17 <stil> sorry. I'll read
09:37:32 <Lemmih> stil: It does act like a newline.
09:38:00 <Lemmih> stil: It gets escaped if you don't print it manually.
09:38:08 <stil> you mean putStr
09:38:38 <stil> but I must write it so that
09:38:49 <Lemmih> putStrLn would probably be more appropriate.
09:39:06 <Lemmih> 'putStrLn (show (xy 5 4))'
09:39:51 <stil> but I must write it so that >> (x y 5 4)
09:40:01 <stil> must show with newlines
09:40:08 <stil> I mean
09:40:10 <stil> like
09:40:14 <stil> >> 5
09:40:16 <stil> >>   4
09:41:00 <Lemmih> Then make 'xy' an IO action which prints the value on its own.
09:44:16 <stil> okay I know I can do this.. but it means change on a basic design constrict in my program
09:53:27 <liet> can I make it behave "putStr (show2 ...) " instead of printing string
09:53:37 <liet> (I mean show :: a->String)
09:55:19 <liet> I want to show the string it produces , but I don't want the "\n"s escape
09:55:24 <liet> that's the problem
09:57:08 <tetraeder> hi
09:57:53 <liet> hi
10:01:25 <Lemmih> liet: 'putStrLn (show (xy 4 5))' didn't work?
10:16:14 <liet> it works..
10:16:44 <liet> but I can't and don't want to try like show :: a -> IO()
10:16:58 <liet> I just want to make it print
10:17:03 <liet> >> 5
10:17:06 <liet> >>     4
10:17:17 <liet> not with another function
10:17:21 <liet> with just show
10:17:22 <Lemmih> That's not possible.
10:17:39 <Lemmih> Calling 'show' on a string will always escape the characters.
10:20:32 <Lemmih> liet: Did you try just calling 'xy 4 5'?
10:20:55 <liet> okay I understood what you mean
10:21:04 <liet> I just wondered if it could be done
10:21:10 <liet> thanks for the absolute answer
10:21:59 <liet> I'm curious about something else, is this language, Haskell, written with another language
10:22:03 <liet> I mean like C
10:22:38 <Lemmih> liet: Hugs (a Haskell interpreter) is written in C but GHC is written in Haskell.
10:22:52 <TFK> Lemmih, the entire GHC?
10:23:03 <TFK> The compiler itself? o_O
10:23:06 <Cale> TFK: yeah
10:23:13 <Cale> pretty much :)
10:23:38 <TFK> Then how is it bootstrapped?
10:24:01 <TFK> Also, I think someone said that arrays were not implemented with Haskell.
10:24:13 <theorbtwo> There are two GHCs, as I understand it.
10:24:16 <Cale> well, there's extra stuff for bootstrapping it.
10:24:17 <Lemmih> There's about 50,000 lines of C in GHC.
10:24:33 <TFK> That's a lot of lines.
10:24:36 <Igloo> You need GHC to build GHC
10:24:39 <theorbtwo> The Glorious Glasgow Haskell Compiler (written in Haskell).
10:24:45 <liet> I gotta ask something else
10:24:49 <theorbtwo> The Evil Glasgow Haskell Compiler (written in perl).
10:25:01 <liet> how many of you think functional programming is "useful"?
10:25:02 <TFK> Igloo, chicken and the egg problem?
10:25:04 <Cale> GHC compiles to C or native code.
10:25:13 <liet> in stuff like programming big projects
10:25:14 <Lemmih> liet: I do.
10:25:18 <mwc> liet, I haven't done FP in the large
10:25:19 <Cale> (compiles Haskell code to C or native code)
10:25:27 <liet> and fast programs.. concerning memory allocation and stuff
10:25:41 <mwc> but I find it's great for doing things like iterators in
10:25:50 <mwc> check out Ruby for a good mix of FP and regular IMP
10:25:55 <Cale> liet: I think it's quite good
10:25:57 <TFK> iterators?
10:26:00 <Igloo> TFK: But we already have GHCs, so it's OK
10:26:13 <mwc> myArray.forEach do |elem| printElem end
10:26:16 <Cale> liet: GHC is a pretty big program :)
10:26:18 <mwc> that sort of thing
10:26:32 <TFK> for item in some_seq: print item ?
10:26:34 <TFK> :-P
10:26:34 <liet> :) I see some good things in FP, too
10:26:35 <mwc> do |params| end is ruby's lambda expression, essentially
10:26:42 <TFK> That's not really functional, but OK.
10:26:53 <TFK> (At least Python's iterators aren't.)
10:26:54 <liet> but most of the time, in so many things, IMP is GREAT
10:27:02 <mwc> liet, no, it's not
10:27:32 <TFK> Igloo, ah, but how were the Adam/Eve of GHCs made?
10:27:34 <mwc> IMP is essential in 4% of the cases where you need to manually micromanage every allocation to squeeze the last drop out of the hardware
10:27:43 <mwc> otherwise, you're just doing pointless book keeping
10:27:48 <sproingie> TFK: probably in C
10:28:04 <liet> okay I admit that
10:28:06 <TFK> Hmm, OK.
10:28:14 <Igloo> TFK: Toggled in with switches, of course  :-)
10:28:28 <sproingie> TFK: there is no c-based ghc anymore tho
10:28:32 <liet> but accept the fact that FP output programs lack some performance
10:28:41 <sproingie> liet: why are you in #haskell then?
10:28:41 <TheHunter> TFK, that was such a long time ago, i don't think anyone remembers :)
10:28:46 <liet> :)
10:28:48 <TFK> SO the prototype was erased? :-P
10:28:51 <liet> learning.. learning..
10:28:51 <musasabi> evening
10:29:05 <liet> remember
10:29:09 <TFK> liet, it's best to learn first, then criticize later.
10:29:15 <liet> Dijkstra thought OOP was bad..
10:29:17 <liet> :)
10:29:33 <musasabi> liet: FP has no inherit performance penalties.
10:29:35 <sproingie> Dijkstra had lots of opinions.  never actually had to program after algol-60
10:29:55 <TFK> Lots of Smart People (TM) think OOP sucks, actually.
10:29:59 <musasabi> (that is quite an evil way of saying things as it really says nothing)
10:30:00 <TFK> (Dunno why.)
10:30:00 <sproingie> good thinker, good teacher, stopped being an engineer
10:30:35 <sproingie> lots of definitions of oop
10:30:41 <TFK> That's true.
10:30:47 <liet> I heard about Dijkstra's personality
10:30:47 <sproingie> usually people saying it sucks have a problem with just one of the definitions
10:31:05 <liet> but in "big" applications.. OOP becomes a must sometimes
10:31:08 <sproingie> "modern" oop with templates looks a lot like FP actually
10:31:14 <musasabi> sproingie: the problem is that it is defined in a very loose matter.
10:31:17 <TFK> The ops in Python keep asking "what is OOP?" :-P
10:31:44 <Cale> Basically, abstractions of some kind are required for big projects. OOP provides some abstractions.
10:31:48 <musasabi> liet: in large apps certain things like good encapsulation boundaries are necessary - that does not mean OOP.
10:31:58 <sproingie> argh.  so much for building ghc from cvs
10:32:03 <Cale> Haskell and other functional programming languages tend to provide other abstractions.
10:32:07 <sproingie> which fairly well scotches building pugs
10:32:25 <musasabi> OOP is one way of providing encapsulation, FP offers other methods.
10:32:28 <sproingie> linker errors galore
10:32:41 <musasabi> sproingie: what platform and how recent?
10:32:42 <liet> okay, I didn't mean I don't enjoy programming in FP
10:32:51 <Lemmih> pugs depends on GHC HEAD?
10:32:55 <sproingie> musasabi: x86_64.  just checked it outta cvs
10:32:57 <liet> I like "recursion" :)
10:33:07 <sproingie> Lemmih: 6.4.  it uses GADTs
10:33:17 <liet> but I meant in usefulness in real life.. I may be wrong
10:33:25 <TFK> Erm.
10:33:25 <Lemmih> sproingie: Then why are you building from CVS?
10:33:34 <musasabi> sproingie: I think you can build 6.4 for x86_64.
10:34:21 <sproingie> guess i should try it instead of HEAD
10:34:39 <liet> is haskell the best FPL?
10:34:40 <TFK> Heh... how come GHC doesn't use darcs?
10:34:49 <musasabi> HEAD had some linker work very recently.
10:35:06 <musasabi> TFK: GHC existed long before darcs.
10:35:09 <Lemmih> TFK: Lacking maturity from darcs.
10:35:20 <sproingie> darcs is very very slow with big changesets
10:35:38 <musasabi> actually darcs is usable on the fptools repository.
10:35:43 <sproingie> doesnt use tempfiles for one, so it eats lotsa ram
10:35:45 <Lemmih> SyntaxNinja: Hi!
10:35:49 <TFK> Heh, OK.
10:35:55 <musasabi> I have instructions how to use it with it in the wiki.
10:36:04 <sproingie> 'course building ghc eats lotsa ram too
10:36:19 <theorbtwo> Just find a binary of 6.4, then?
10:36:25 <musasabi> btw the current darcs unstable needs half the ram for big repositories.
10:36:38 <sproingie> for x86_64, i only see it as a fedora rpm
10:36:42 <musasabi> and those changes are likely to make into darcs 1.0.3
10:36:46 <sproingie> i suspect that means it depends on fedora's lib versions and all
10:36:59 <sproingie> whereas i have ubuntu
10:37:40 <chucky> sproingie: I've built ghc 6.4 for ubuntu
10:37:52 <Oejet> @wiki ImperativeHaskell
10:37:53 <lambdabot> http://www.haskell.org/hawiki/ImperativeHaskell
10:38:08 <sproingie> no kidding
10:38:22 <SyntaxNinja> hi
10:38:25 <sproingie> oh examples.  i thought it was a branch of haskell
10:38:57 <chucky> :)
10:39:16 <Oejet> He.
10:39:19 <sproingie> imperative's easy in one ST monad ... tricky when you have lots of state in lots of places
10:39:37 <liet> moa
10:39:40 <liet> monad is good
10:39:42 <liet> :)
10:39:48 <sproingie> i wonder what the usual approach to that is... use concurrent?
10:39:48 <SyntaxNinja> programming is  tricky when you have lots of state in lots of places
10:40:17 <liet> yes..
10:40:25 <liet> that exactly what I mean.
10:40:31 <sproingie> concurrent with one actor per stateful subsystem?
10:40:51 <sproingie> sorta comes round to oop there :)
10:41:21 <sproingie> guess i could look at lambdabot ... i imagine that has lots of state
10:43:10 <sproingie> well ghc6.4 tarball doesnt compile either
10:43:14 <sproingie> at least it fails immediately
10:43:32 <sproingie> chucky: how'd you build it for ubuntu amd64?
10:44:01 <chucky> you need to define SplitObjs=NO somewhere
10:44:26 <chucky> hold on I have to do some stuff in the kitchen, then I'll tell you how if noone else can. :)
10:44:39 <sproingie> aha indeed it does complain about splitting object files
10:45:09 <sproingie> looks like config.mk
10:45:10 <TheHunter> @version
10:45:11 <lambdabot> lambdabot 2p331, GHC 6.4 (OpenBSD i386)
10:45:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:45:29 <TheHunter> the approach lambdabot currently uses is very OO-like, actually.
10:46:39 <SyntaxNinja> Lunar^: alive?
10:47:25 <sproingie> i looked at the code once ... really does scream out for some syntax sugar for the stateful parts
10:47:33 <sproingie> didn't look too deep
10:48:20 <TheHunter> many things have been simplified since then.
10:48:36 <chucky> sproingie: Yes in config.mk. I *think* putting SplitObjs=NO there was the only thing that was required
10:48:47 <chucky> note that this means GHCi won't work
10:49:20 <sproingie> :(
10:50:01 <TheHunter> sproingie, for example, this is all that is needed to implement the simple state module: http://www.cse.unsw.edu.au/~dons/lambdabot/lambdabot/StateModule.hs
10:50:30 <sproingie> TheHunter: looks a lot simpler than when i last looked at it
10:50:48 <sproingie> which was probably a year ago
10:50:54 <musasabi> sproingie: lambdabot?
10:50:59 <TheHunter> sproingie, can't you just use a x86 tarball?
10:51:15 <musasabi> sproingie: we like the state manipulations to be explicit.
10:52:41 <sproingie> TheHunter: guess i'll have to.  thought i'd get a 64bit native ghc, but i'll settle for 32bit right now
10:52:46 <TheHunter> the state manipulation stuff was a total mess. Plus there was much code duplication going on.
10:52:58 <sproingie> docs say amd64 port doesnt registerize anyway ... sounds slow
10:53:43 <TheHunter> does that mean ghci is not supported?
10:53:53 <musasabi> TheHunter: isn't it mostly {readMS,writeMS} ?
10:54:12 <musasabi> from the module perspective.
10:54:13 <sproingie> TheHunter: looks like it.  my binary has ghci, but it panics and dies
10:54:25 <sproingie> Loading package base ... /usr/lib/ghc-6.2.2/HSbase.o: unknown architecture
10:54:26 <sproingie> ghc-6.2.2: panic! (the `impossible' happened, GHC version 6.2.2):
10:54:46 <musasabi> sproingie: you might want 6.4.
10:54:56 <sproingie> yep, is what i was trying to compile
10:55:10 <sproingie> ubuntu being debian, is of course, months behind even in stable
10:55:15 <sproingie> er in unstable
10:56:01 <CosmicRay> behind what?
10:56:17 <sproingie> current releases
10:56:21 <CosmicRay> of what?
10:56:31 <sproingie> in this case, ghc
10:57:00 <musasabi> sproingie: ghc 6.4 is not in sid for a reasong (sarge).
10:57:01 <CosmicRay> well, "months" is a little exaggerated...  but I think it is completely inaccurate to imply that everything, or even most htings, in sid are outdated.
10:57:02 <TheHunter> musasabi, sure, now it's easy. But older lambdabots used this Dynamic FiniteMap kludge.
10:57:07 <sproingie> tho the alternative for me was gentoo, which burned me a couple times ... not to get into distro wars tho
10:57:17 <CosmicRay> sproingie: what arch are you trying to run ghci on?
10:57:46 <sproingie> CosmicRay: amd64
10:58:24 <musasabi> debian sid worked quite nice on a amd64 laptop I was playing with.
10:58:33 <musasabi> and NetBSD <3
10:58:37 <sproingie> it does work nice
10:58:43 <musasabi> but that is mostly a matter of taste.
10:59:14 <sproingie> ghc on the other hand is not liking my arch too much
10:59:34 <CosmicRay> sproingie: ahh.  ghci does not yet support amd64.
10:59:34 <CosmicRay> I'm not sure that it does in 6.4 even
10:59:34 <CosmicRay> however ghc itself does support amd64
10:59:34 <CosmicRay> if you want an interactive interpreter on amd64, hugs works
10:59:36 <CosmicRay> yeah I run it on amd64 myself
10:59:40 <CosmicRay> I'm just saying ghci doesn't support amd64 upstream
10:59:53 <sproingie> naw, ghci is just a "nice to have" thing
11:00:00 <CosmicRay> sproingie: you're having trouble with ghc on amd64 debian?
11:00:09 <CosmicRay> sproingie: I just installed the ghc from pure64 and it worked perfectly for me out of the box
11:00:16 <sproingie> mostly want ghc.  i'd be happy with 6.2, but i also want to play with pugs
11:00:26 <sproingie> CosmicRay: what version is it?
11:00:27 <CosmicRay> does pugs require 6.4?
11:00:30 <CosmicRay> sproingie: 6.2.2
11:00:38 <CosmicRay> same as sid
11:00:46 <CosmicRay> apt-get install ghc6 will get it for you
11:00:47 <theorbtwo> pugs requires 6.4
11:00:49 <sproingie> yep.  uses GADTs and whatever else aujitrus finds shiny and fun
11:01:01 <CosmicRay> you can probably build yourself a 6.4 anyway
11:01:07 <CosmicRay> but you will need ghc installed to build ghc
11:01:11 <theorbtwo> You can apt-get install ghc-cvs, or apt-get install ghc=experimental
11:01:14 <CosmicRay> so might as well apt-get install ghc6
11:01:14 <sproingie> CosmicRay: not much luck building it from tarballs or cvs
11:01:21 <sproingie> i have installed it
11:01:25 <theorbtwo> Er, apt-get install ghc6=experimental
11:01:26 <sproingie> using it to build the others
11:01:27 <CosmicRay> ghc-cvs though is not up to date with 6.4
11:01:31 <CosmicRay> app
11:01:33 <CosmicRay> ahh
11:01:39 <CosmicRay> theorbtwo: is 6.4 in experimental?
11:01:50 <sproingie> theorbtwo: got an apt source line i can use for experimental?
11:01:52 <theorbtwo> 6.4 is in experimental; ghc-cvs is 6.5.
11:01:52 <CosmicRay> theorbtwo: he won't be able to install it form there since he's on amd64
11:01:56 <theorbtwo> (Really, I'm using it right now.)
11:02:04 <sproingie> i run ubuntu, which doesnt really have an experimental
11:02:10 <CosmicRay> sproingie: I'd suggest grabbing the Debian source packages for ghc6.4 from experimental, then debuild -rfakeroot -us -uc them
11:02:13 <theorbtwo> ghc-cvs in deb unstable, that is.
11:02:19 <theorbtwo> sproingie: Use debian's.
11:02:19 <CosmicRay> sproingie: should be ok with debian experimental anyway
11:02:47 <theorbtwo> apt-get will tell you if anything else needs to be upgraded, and it won't get from experimental unless you explicitly tell it to.
11:03:03 <sproingie> ah thats what i was worried about
11:03:24 <CosmicRay> theorbtwo: what he needs is a deb-src line for unstable.  actually I think it would be easier to just download the source package
11:03:29 <sproingie> got a source line for me?  all mine have the usual ubuntu animal names, nothing to go off of :)
11:03:34 <CosmicRay> theorbtwo: unstable doesn't have the amd64 debs he needs
11:03:55 <sproingie> anyway if i disable SplitObjs, i may be able to build it from the tarball
11:04:16 <theorbtwo> deb-src   http://ftp.de.debian.org/debian-non-US unstable non-US/main non-US/contrib non-US/non-free
11:04:25 <theorbtwo> (Change the .de. as approps for you.)
11:04:33 <CosmicRay> look here: http://ftp.debian.org/debian/pool/main/g/ghc6/
11:04:38 <CosmicRay> download diff.gz, tar.gz, and .dsc
11:04:40 <CosmicRay> dpkg-source -x .dsc
11:05:22 <theorbtwo> You can just apt-get source package.
11:05:25 <sproingie> huh.  there's a line in there to disable SplitObjs
11:05:30 <sproingie> but it's not firing
11:05:48 <sproingie> ifeq "$(TARGETPLATFORM)" "ia64-unknown-linux"
11:06:37 <sproingie> probably because it's x86_64-unknown-linux
11:06:41 <SyntaxNinja> heya CosmicRay
11:07:02 <theorbtwo> dpkg --print-architecture ?
11:07:15 <sproingie> amd64
11:07:23 <theorbtwo> That'd do it, sproingie.
11:07:24 <sproingie> i'm looking in config.mk itself
11:07:55 <sproingie> guess i should file a bug
11:09:03 <chucky> sproingie: What you should do is, first run configure, then create a file called mk/build.mk and add SplitObjs = NO to that file
11:09:40 <chucky> you shouldn't have to touch config.mk (although you probably could, but I think it's auto-generated so it's probably a bad idea)
11:10:03 <CosmicRay> hi SyntaxNinja
11:10:17 <CosmicRay> ia64 is not the same as x86_64
11:10:32 <CosmicRay> ia64 is itanic
11:10:34 <CosmicRay> x84_64 is amd64
11:10:50 <tromp> ia64 is headed for obsolescence
11:11:04 <CosmicRay> tromp: it never made it out of obsolescence :-)
11:11:20 <tromp> 2 billion down the drain:(
11:11:51 <tromp> 'it does lead some benchmark lists...
11:12:42 <SyntaxNinja> i'm trying to figure out the right way to link _stub.o files in cabal.
11:12:46 <SyntaxNinja> hear that, Lunar^
11:13:02 <xerox> hi!
11:13:28 <musasabi> SyntaxNinja: from what is that _stub.o produced ?
11:13:36 <sproingie> ahhh that's right.  will amend the bug report, since it's got the same problem anyway
11:14:08 <SyntaxNinja> Foo.hs which uses foreign import
11:14:26 <sproingie> shame about itanic.  256 general purpose registers is nice
11:14:34 <sproingie> tho explicit parallelism sort of rots
11:15:30 <sproingie> learned it was originally HP.  sounds like something they'd do
11:16:03 <musasabi> sproingie: alpha was the nicest arch.
11:16:20 <tromp> i sure loved alpha
11:16:27 <sproingie> musasabi: yah, tho the heat ... they make pentiums look frosty
11:16:48 <tromp> if only the money sunk into itanic had gone into Alpha....
11:17:43 <musasabi> sproingie: that is an implementation detail ;)
11:18:18 <sproingie> coulda been running at 1ghz with old fab processes... smaller process should mean cooler chip
11:18:57 * musasabi is kind of upset with HP
11:19:12 <sproingie> just kind of?
11:19:21 <musasabi> they killed of alpha and tru64 and what do they offer? itanic and hp-sux.
11:19:34 <sproingie> they eviscerated every bit of engineering that company had
11:20:48 <musasabi> Even now the old alpha machines running tru64 are nicer to use than the servers with hp-ux.
11:22:19 <sproingie> eh.  hpux was ok for its time.  better than dgux
11:30:35 <sproingie> looks like it's building now
11:37:15 <_JusSx_> o
11:39:01 <sproingie> wow.  am i supposed to see screenfulls of "Bad eta expand" followed by bizarre compiler output?
11:39:18 <sproingie> still compiling tho...
11:40:11 * theorbtwo tries to remember: You can run normal ia32 binaries on that, or not?
11:40:46 <chucky> sproingie: Yes I think that's normal
11:42:01 <musasabi> theorbtwo: one needs a chroot for that.
11:42:07 <theorbtwo> Oh.
11:42:12 <theorbtwo> Sounds like work.
11:43:46 <sproingie> work for the packager.  smooth for the user
11:45:09 <sproingie> i think ld.so does something tricky, and knows to use /usr/lib32 when it needs to
11:45:21 <sproingie> because the whole app certainly isn't chrooted
11:46:05 <theorbtwo> Oh.
11:46:10 <theorbtwo> That's not a chroot.
11:46:10 <sproingie> still cant use 32 bit libs in a 64 bit app tho.  so no flash for me
11:46:37 <theorbtwo> Right, but you could just install the ia32 ghc, and have it Just Work.
11:47:07 <autrijus> pugs> say eval_haskell<"Lambda!">
11:47:07 <autrijus> Lambda!
11:48:07 <sproingie> theorbtwo: maybe, maybe not.  i dont rightly know what's required
11:49:00 <Oejet> autrijus: Cool.
11:49:42 <theorbtwo> Thank you, Oejet.  ;)
11:51:58 * sproingie ponders what must be a faq... how do you pronounce autrijus?
11:52:24 <autrijus> autrijus.org/autrijus.mp3
11:52:25 * theorbtwo tries to remember if it's in PA1.
11:52:49 * sproingie sighs loudly
11:52:52 <sproingie> GC.c:83: error: static declaration of ‚Äòstatic_objects‚Äô follows non-static declaration
11:53:26 <sproingie> maybe i'll compile it on cygwin
11:54:53 <theorbtwo> autrijus: add that to pa1?
11:54:57 <sproingie> tho i suppose theres no point ... maybe i can alien the fedora rpm
11:56:57 <sproingie> eh.  i'll fight this battle later.  rebootage.
12:33:30 <autrijus> dons: there?
12:33:38 <autrijus> I just woke up to a revelation that eval_ is broken :)
12:33:43 <autrijus> it returns Maybe a without a "Just" contructor
12:33:54 <autrijus> thus forcing the string to be evalled to contain "Just" by itself.
12:34:02 <autrijus> that's clearly not what was intended, and does not agree with eval
12:34:35 <autrijus> ...now I go back to sleep
12:34:35 <autrijus> &
12:39:17 <sproingie> huh.  minor problem with the ghc-6.4 msi for windows
12:39:21 <sproingie> it's actually 6.2
12:39:56 <sproingie> oh bloody ... it installs both
12:46:52 <SyntaxNinja> Oo
12:47:41 <SyntaxNinja> sproingie: I work with Sigbjorn. I can kick him on monday ;)
12:48:04 <SyntaxNinja> it does say something about instaling the appropriate version
13:18:15 <poetix> \alias the_master
13:18:53 * poetix = hopeless IRC n00b
13:19:15 <Lemmih> /nick the_master ?
13:20:13 <the_master> Sadlly not to be
13:23:04 <the_doctor> haha
13:26:39 * gods_of_ragnarok blasts the_doctor with powerful bolts of pure energy
13:26:55 <poetix> God, it was almost worth it
13:29:22 <sproingie> gotta hand it to godaddy, editorializing on why they "allow" registrations of "bad words"
13:29:25 <sproingie> https://www.godaddy.com/gdshop/blogredirect.asp?se=%2B&ci=439
13:35:29 <wagle> bs.  i had a book on japanese dirty words and idioms
13:40:02 <sproingie> no kidding
13:40:12 <sproingie> if there's any culture more repressed in their language than ours ...
13:41:00 <sproingie> tho considering the actual definition of "vulgar"
13:41:30 <esap> Hmm.. is there a nice way of getting a useful syntax for: proc name -> do (do sharedStorageVar -< name) `initializes` \ xcoord -> do succeed -< NamedObject xcoord. I've tried several different things but didn't find any good way. This is supposed to initialize a single variable (OO way) and construct an object containing it.
13:41:59 * sproingie shrugs.  little truth both ways.  well, time to get out to the big blue room
13:44:25 <wagle> interestingly enough the internet provider for this coffeeshop blocks the first google hit for an ishipress book
13:55:36 * tumbleweed blows disconsolately across the desolate wastes of #haskell
14:29:25 <Itkovian> hmm
14:37:46 <Itkovian> quiet in here
14:37:54 <Itkovian> anyway, I'm off too
14:51:51 * poetix observes that muad_dibbler would be the kwizzzatch haderach in a Terry Pratchett re-working of Dune.
14:52:38 <skew> prescient visions of the future onna bun. 5c!
14:52:53 <skew> and that's cutting my own throat!
14:53:22 * poetix is speechless with mirth
14:53:41 <theorb> Kitsch Hadda-Swatch?
14:54:32 <theorb> I donno, skew, is it a SpicyTM bun?
15:06:33 * shapr y0wdels
15:06:57 * CosmicRay covers ears
15:07:08 <shaprs_echo> yodell-ee-oo
15:07:19 * shapr grins
15:07:24 <shapr> hiya dominic
15:07:24 <CosmicRay> shammah: 24 arch or svn projects converted to darcs today.  woohoo.
15:07:26 <Lenny1729> @version
15:07:27 <lambdabot> lambdabot 2p331, GHC 6.4 (OpenBSD i386)
15:07:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:07:39 <shapr> hiya florian
15:07:51 <Lenny1729> hi shapr
15:07:58 <shapr> poetix: hey, did I already ask you about type-safe penrose tiles?
15:08:10 <poetix> You mentioned something about penrose tiles
15:08:20 <SamB> Lenny1729: you know shapr?
15:08:37 <poetix> Where would type-safety enter into it?
15:09:00 <shapr> I looked at your polyominoes in hopes of using the same code to create type-safe penrose tiles, but I think polyominoes are something else entirely.
15:09:28 <poetix> They're tetris pieces, essentially
15:09:38 <poetix> Although you can tile them
15:09:44 <shapr> Really my essential question is how to enforce two tile values to typesafely connect.
15:10:10 <shapr> Like two values of one square tiled above another, if you join the top two side by side, how do you infer that the bottom two must be side by side?
15:10:19 <poetix> A similar (-ish) question is whether you can use the type system to enforce the connectedness of squares in a polyomino
15:10:27 <shapr> Right, what do you think?
15:11:13 <shapr> It would be easy enough to check at runtime, but just for fun I'd like to think of a type safe approach.
15:11:34 <poetix> Dubious. More likely to try to enforce well-formedness in a constructor, make it a phantom type or something like that.
15:11:53 <poetix> A type system that could do that would be interesting.
15:12:20 <shapr> Probably I should just ask Oleg and get it over with :-)
15:12:28 <poetix> Yes, it sounds like his sort of thing.
15:13:34 <poetix> In my original polyomino code, I made the definition of a polyomino either a monomino or another polyomino plus a path to where you stuck the next square on
15:13:38 <shapr> hm, I wonder if it could be done with a type parameter.
15:13:56 <poetix> So I guess that did enforce connectedness, although it couldn't stop you sticking a square on where there was already a square
15:14:47 <poetix> I don't know what sub-languages might be embedded in the Haskell type-system, to what extent it's programmable the way people do template metaprogramming in C++
15:15:22 <Lenny1729> Good night everybody! and thanks for your help SamB
15:15:44 <shapr> I've seen some incomprehensible mailing list posts about that sort of thing, but as my adjective says, I didn't understand anything.
15:16:15 <poetix> Incidentally, I saw Penrose speak in a room above a pub once
15:16:22 <shapr> wow, awesome
15:16:25 <shapr> Is he any good?
15:16:37 <poetix> Almost he persuaded me that I understood Godel
15:16:40 <shapr> wow!
15:16:52 <shapr> Better than reading GEB?
15:17:21 <poetix> He was talking about computability and consciousness. I didn't really agree with him. But I didn't feel especially confident about disagreeing...
15:18:08 * poetix sort of skimmed the number theory bits in GEB
15:18:33 <shapr> What about data Shape a = ... such that you could make something :: Shape (Square Square) ... but how would you know if it's vertical or horizontal?
15:19:12 <shapr> maybe data ColumnShape a = ... where :: ColumnShape (Square Square) means a vertical column?
15:19:27 <poetix> This would be easier in 1 dimension
15:19:40 <shapr> But much less fun.
15:19:50 <poetix> As the bishop said to the actress
15:20:02 <shapr> :-)
15:21:08 <shapr> Then you'd need a Row type, and Row (Column Square Column Square) would have to typecheck as equal to Column (Row Square Row Square)
15:21:11 <shapr> how the heck would that work?
15:21:24 * poetix shrugs vertiginously
15:23:31 * shapr cogitates vociferously
15:24:11 <shapr> I wonder if that means "thinks out loud"
15:24:45 <poetix> voci-ferous: voice-bearing
15:25:04 <shapr> That would make sense.
15:25:23 <shapr> Though it's really a misuse of the word vociferous.
15:25:44 <shapr> It usually implies loud and disagreeable.
15:25:55 <poetix> Like using lactiferous to describe a milkman
15:26:00 * shapr laughs
15:26:45 <shapr> Then there's lactiferrous, when milk fortified with extra iron.
15:27:26 <shapr> Hm, I think that lactiferrous joke gets a 2 on a scale of 1 to 10.
15:28:05 <shapr> I had a beer a few hours back, totally wrecks my thinking for the rest of the day.
15:29:32 <poetix> Well, it's 11.30pm here and I'm halfway through a bottle of red wine
15:29:58 <theorb> It's half past midnight here, and I've probably not eaten nearly enough today.
15:30:15 <poetix> I surely am not going to do any wizardly Haskell programming now
15:30:20 <shapr> theorb: Have you lost your number?
15:30:47 <theorb> Lost my number?
15:30:57 <shapr> Aren't you usually theorbtwo?
15:31:05 <shapr> Or is that only when you're at work?
15:31:10 <poetix> I think it's time for bed. To be precise, my wife does. She knows what time it is.
15:31:15 <shapr> g'night poetix
15:31:24 <theorb> Oh, that's only when I'm using my usual client.
15:31:33 <theorb> But my computer is rather messed up at present.
15:31:37 <shapr> oh, I see.
15:32:02 <SamB> what do you usually use?
15:32:16 <theorb> gaim.
15:32:28 <theorb> irssi when gaim isn't playing nice.
15:32:41 <SamB> gaim? isn't that wierd?
15:32:44 <shapr> I rather like poetix' code for polyominoes.
15:32:45 <theorb> (Which is annoyingly often, but not quite annoying enough for me to actually fix it.)
15:37:19 <CosmicRay> shapr: I figured out how to use Apache to serve up my darcs stuff in a decent-looking fashion: http://darcs.complete.org/
15:37:32 <CosmicRay> feel free to take anything of interest, btw :-)
15:38:52 <shapr> oh that's nice
15:39:21 <shapr> I especially like the [Category] part in the description, allow easy sorting by subject.
15:40:01 <CosmicRay> yup
15:40:16 <CosmicRay> AddDescription directive in apache
15:40:30 <CosmicRay> though I can't figure out how to make it apply to only one specific file
15:40:53 <CosmicRay> if someone happens to browse down through the tree, every directory named gopher will say "[C] UMN Gopher client distribution" :-)
15:41:03 <shapr> I've never figured out how to use AddDescription at all.
15:41:13 <CosmicRay> it doesn't appear to behave as documented
15:41:21 <CosmicRay> according to the docs, an absolute path should work
15:41:23 <CosmicRay> it doesn't.
15:41:36 <shapr> Oh, you've really used HaXml for something, I should steal this code to write a tutorial.
15:41:57 <CosmicRay> shapr: I have, but that was the first time I used it.  the code probably sucks.
15:42:04 <CosmicRay> but feel free to take it anyway :-)
15:42:24 <shapr> HaXml was one of the first Haskell things I tried to use, took me hours of study just to figure out what the heck it did.
15:42:52 <CosmicRay> it's very slick if what you're doing fits their usage case well.  I happened to be going from xml to xml, so it more or less did.
15:43:06 <CosmicRay> it is a big pain if your conversion involves IO though
15:43:17 <CosmicRay> the consensus seems to be to juse use unsafePerformIO
15:43:19 <shapr> Does it handle subDTD checks?
15:43:30 <CosmicRay> I don't know, I never had a DTD for any of my docs
15:43:40 <shapr> How did you generate the types?
15:43:50 <shapr> Is Content a generic tree or something?
15:43:59 <CosmicRay> yeah, it's a generic HaXml type
15:44:25 <CosmicRay> http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text.XML.HaXml.Types.html#Content
15:45:35 <shapr> hm, neat.
15:45:49 <shapr> I never did really use HaXml for anything. I should remedy that.
15:46:40 <shapr> Have you tried to make an RSS aggregator with HaXml?
15:46:56 <CosmicRay> heh:
15:46:57 <shapr> That would be useful and a good tutorial project.
15:46:58 <CosmicRay> <dilinger> trave11er: CosmicRay's weblog hasn't led me astray yet :P
15:46:58 <CosmicRay> <trave11er> dilinger: i cannot trust people who can write a 100+ line haskell program :-)
15:46:58 <CosmicRay> <trave11er> that's almost a legal definition of insanity
15:46:58 <CosmicRay> <-- fockewulf has quit (Remote closed the connection)
15:46:59 <CosmicRay> <Igloo> You're right; Haskell is such a concise, elegant language that anyone who stretches a program beyond 100+ lines is clearly doing something wrong
15:47:10 * shapr laughs
15:47:19 <shapr> must be a debian channel.
15:47:26 <CosmicRay> yeah, #debian-devel
15:48:05 <CosmicRay> shapr: I'm not so much into rss stuff, but that would indeed be a great project.
15:48:28 <SamB> #debian-devel is awfully quiet for a channel with 300+ people...
15:48:49 <CosmicRay> activity comes and goes, just like here
15:49:50 <shapr> I'm not so much into RSS stuff either, but I might be if Pete gives up on PLog.
15:50:15 * CosmicRay googles
15:50:42 <CosmicRay> is it written in haskell?
15:50:52 <shapr> Hey, Agent Goerzen, would you happen to have a list of suggested missing libraries and their relative priorities for Haskell?
15:51:25 <chr1s> Is it possible to have a function that takes n arguments and drops the first argument, returning n-1 arguments?
15:51:28 <CosmicRay> hmm.  The most common ones I need exist in some form or another already, but generally inconveniently...
15:51:31 <shapr> Yeah, PLog and BloB are the two Haskell blogs that I know about.
15:52:01 <CosmicRay> I would mention: curses, imap, pop3, smtp, nntp, gzip/bzip2 C bindings, dbm C bindings, etc.
15:52:18 <shapr> Yes, look at the polyvariadic args critter from Oleg. The same trick is used in Bj√∂rn Bringert's XmlRpc library.
15:52:20 <CosmicRay> oh, also ssl, ldap
15:52:24 <TFK> Haskell blogs?
15:52:45 <shapr> Yeah, blogs that are written with Haskell. I use PLog 0.6 for example.
15:53:13 <CosmicRay> shapr: I would say SSL is the #1 things missing from Haskell right now, and it is probably beyond my present skill level to fix that.
15:53:14 <TFK> oooh, plog 1.0 :-)
15:53:33 <shapr> I wonder if there's a Wikipage that lists wanted libraries.
15:53:50 <shapr> CosmicRay: have you looked at Dominic Steinitz' cryptolib?
15:54:10 <CosmicRay> shapr: yes, it does some of the underlying operations but is nowhere near suitable for ssl
15:54:17 <CosmicRay> shapr: also the licensing on it is a mess
15:54:39 <CosmicRay> shapr: but between the cryptolib components and peter's work, we pretty much have things like md5, sha1, base64, etc. in haskell
15:54:41 <shapr> What's missing from crypto to get SSL? I know almost nothing about SSL.
15:54:50 <shapr> Peter Simons?
15:54:57 <CosmicRay> shapr: well, for instance, it doesn't do any of the wire protocol
15:54:59 <CosmicRay> yes
15:55:12 <CosmicRay> I don't think it does key exchange or certificate validation either
15:55:13 <shapr> He shows up here sometimes as peti
15:55:22 * theorb notes that no SSL library is complete until you can feed the normal "open a URL" call a https://foo URL.
15:55:44 <shapr> real certificate validation is a total nightmare.
15:55:53 <CosmicRay> generally languages get ssl support by binding to openssl or gnutls
15:56:02 <CosmicRay> because it is so large and complex
15:56:46 <shapr> Dominic's ASN.1 Haskell code makes a lot of stuff easier, but his code doesn't parse the various ASN.1 specification flavors.
15:57:01 <shapr> It just lets you design ASN.1 structures 'by hand'
15:57:15 <CosmicRay> ah
15:57:47 <shapr> I might actually enjoy working with ASN.1 again with Haskell. Doing ASN.1 in Java was not fun.
15:57:56 <CosmicRay> heh
15:58:36 <shapr> Writing an ASN.1 spec parser wouldn't really be so hard.
16:05:02 <shapr> I've been wondering about using something like BNF to specify state transitions in protocols.
16:05:26 <CosmicRay> you mean in a program, or just in a spec?
16:06:08 <shapr> Both, I guess.
16:06:42 <shapr> The RFCs have a BNF-like format for parsing, why not for state transitions?
16:06:52 <CosmicRay> hmm.
16:07:05 <CosmicRay> that would be nice.
16:12:59 * shapr thinks of magnetic clutch designs for a unicycle.
16:39:12 <nuffer> can anyone give an example of a "Show data constructor" or whatever ghci keeps complaining about?
16:39:41 <wilx> Hm?
16:39:57 <nuffer> Tree.hs:3:0: Not in scope: data constructor `Show'
16:40:00 <wilx> Are you using Show which is type class name as data constructor?
16:40:18 <theorb> Are you saying "Show foo" when you meant to say "show foo"?
16:40:23 <nuffer> no, I have a type data Tree a = Leaf | Branch a (Tree a) (Tree a)
16:40:32 <nuffer> theorb, no, I'm copying and pasting from ghci
16:40:47 <nuffer> and I Just do, say "Branch 3 Leaf Leaf" and I get that error
16:40:53 <nuffer> presumably because ghci doesn't know how to print the type
16:40:56 <theorb> Right.
16:41:16 <theorb> Try data Tree a = ... deriving Show
16:41:48 <nuffer> and then?
16:42:10 <theorb> Do a Branch 3 Leaf Leaf and see if it still complaigns.
16:42:35 <theorb> "deriving Show" says "I want to have a Show, but I'm not going to tell you how, you figure it out".
16:42:41 <theorb> And it does.
16:42:45 <nuffer> okay, it works now
16:42:54 <nuffer> but how can I specify how I want it to be printed?
16:43:50 <wilx> You have to make your own instance of Show a.
16:44:04 <nuffer> and what does that entail?
16:44:37 <wilx> instance (Show a) => Show (Tree a) where ...
16:44:40 <wilx> IIRC.
16:44:45 <wilx> Read up in some tutorial.
16:45:06 <nuffer> I didn't see that in "A Gentle Introduction"
16:47:57 <wilx> You haven't read patiently enough then :)
16:47:58 <wilx> http://www.haskell.org/tutorial/classes.html
16:49:49 <nuffer> I apologize
16:50:07 <wilx> np
16:58:48 <nuffer> is Haskell not OO?
17:00:20 <wilx> It is not OO.
17:00:24 <wilx> It is functional.
17:02:27 <nuffer> since when are OO and functional mutually exclusive?
17:03:31 <wilx> Dunno :)
17:04:29 <theorb> They aren't.
17:04:44 <theorb> But you do tend to get some impedence mismatch when you try to do both.
17:04:56 <theorb> OTOH, haskell does do many of the defining bits of OO.
17:05:16 <nuffer> because honestly, I've programmed in (mixed) functional languages before
17:05:28 <nuffer> and I'm just going on blind faith that Haskell is going to get better at some point
17:05:34 <theorb> It is technically only monomorphic, not polymorphic.  ;)
17:05:34 <nuffer> but right now I can't imagine writing any sizeable language in it
17:05:49 <nuffer> did I say language? I meant program
17:07:59 <wilx> :)
17:08:10 <nuffer> I guess what I'm asking is, does it get better?
17:08:26 <wilx> Having experience helps :)
17:08:42 <nuffer> will I ever be as efficient in Haskell as in another language?
17:08:57 <nuffer> (if I keep working with it)
17:09:17 <wilx> Yup.
17:10:14 <lispy> nuffer: what languages are you more familiar with?
17:10:51 <nuffer> probably my most comfortable language right now is C++
17:10:58 <nuffer> on the the functional front I use Nemerle
17:11:23 <nuffer> well, mixed more than functional, but I try to write in a functional style
17:11:29 <lispy> hmm..okay, i'm not familiar with Nemerle, but I'm sure you can become more efficient with Haskell than C++
17:12:23 <nuffer> it's a .NET language
17:12:32 <lispy> functional programming can allow much of the same "flexibility" that OO programming provides, and in some cases less and in other cases more
17:12:38 <nuffer> semantically it's C# with some added niceties, like pattern matching and macros
17:13:23 <nuffer> okay, this is still only my third day working with Haskell
17:13:35 <lispy> i think generally people who enjoy the elegance of math (more generally therory) enjoy functional programming
17:14:00 <lispy> this is my 25th year of english and i still can't spell :)
17:14:01 <nuffer> it's not that -- I love that -- but I can't imagine living without my OO
17:14:27 <lispy> nuffer: i know what that is like, i can't live without higher order functions
17:16:00 <lispy> my main language is lisp which has very nice OO, in fact the creator of OO at one point said that only lisp and smalltalk really have OO (I think this was in the early 90's)
17:16:15 <lispy> but i rarely use it, the times i have it has been nice tho
17:16:58 <lispy> probably other languages since then would fit their criteria.
17:17:11 <nuffer> well, in point and fact, I think when I work it'll probably be with C++ or C# just because those are so standard
17:17:18 <nuffer> but I have years of school ahead of me before I have to do that
17:17:23 <nuffer> I'm just trying to become the best programmer I can
17:17:40 <lispy> then it is no surprise you are learning functional programming :)
17:17:56 <tuomov> years from now the industry will have a zillion new hype languages
17:18:17 <nuffer> I'll be surprised if years from now there aren't a lot of C++ and C# jobs
17:18:45 <tuomov> yeah -- maintaining the shit that was previously written
17:18:49 <lispy> there will be less time spent coding at that level in the future
17:19:02 <nuffer> and more time spent coding at what level?
17:19:07 <lispy> more and more programming will be done "automatically"
17:19:22 <lispy> generating code from specifications and the like
17:19:28 <lispy> UML diagrams for example
17:19:32 <nuffer> this is not what I want to hear about the field I want to enter in four or five years =(
17:19:32 <tuomov> graphical programming! tendavaginitis!
17:20:21 <lispy> nuffer: well, automatic code generation is not very good yet, and it's a very difficult problem
17:20:26 <tuomov> I never properly entered the "field" and I never want to..
17:20:39 <lispy> so that is one area where traditional programming will probably still be "hot"
17:20:41 <tuomov> I just want to program fun stuff
17:20:45 <nuffer> well, I'm planning on going for a CS degree
17:20:58 <nuffer> and, no insult to you guys, but what two or three people tell me on IRC probably isn't going to change that
17:21:27 <lispy> nuffer: i never said you shouldn't
17:21:28 <blackdog> I'm not convinced that graphical programming is any more concise or powerful than text-based. We moved on from cave-painting a while ago...
17:21:30 <lispy> it's what i'm doing :)
17:21:39 <tuomov> there's lots of other things in CS besides code slavery
17:21:54 <tuomov> most of that involves universities, though..
17:22:52 <tuomov> blackdog: that has never stopped m$ before.
17:23:00 <tuomov> the GUI is far inferior to command line..
17:23:10 <tuomov> well, WIMP GUI
17:23:51 <blackdog> I'm not sure it makes sense to say one is inferior to another - which is better, a hammer or a screwdriver?
17:24:04 <lispy> blackdog: hammer, definitely
17:24:11 * blackdog sighs
17:24:13 <lispy> because then everything looks like a nail....
17:24:16 <tuomov> with a hammer I can make screwdriver
17:24:57 <blackdog> sure. but why not let somebody who cares deeply about screwdrivers and their ergonomic factors make 'em instead?
17:25:56 <blackdog> Don't get me wrong: on Linux i use ion and appreciate it. On Mac, though, I use their window manager and like it, not necessarily because it's the best model available, but because they've put enough time and thought into it that it's usable and even fun.
17:25:57 <tuomov> and soon we'll have hammerheads mounted on a piece of plastic and a thin metal stick
17:26:06 <tuomov> doesn't make very good a hammer
17:26:50 <blackdog> no, but the toolbox is big enough for both, right?
17:26:55 <tuomov> but because the screwdriver maker is the biggest player on the market, everyone is forced to use those crappy hammers
17:27:32 <blackdog> who's forcing you to use anything? You get cheap hardware from the screwdriver maker and put whatever you like on it.
17:27:36 <tuomov> and some idiots will start making screwdriver handles for proper hammers too
17:27:51 <tuomov> blackdog: not at work
17:27:54 <nuffer> how can I test if something matches a certain pattern?
17:28:00 <nuffer> like, I have "data Tree a = Leaf | Branch a (Tree a) (Tree a) deriving Show"
17:28:12 <nuffer> and I want to say in one line "if left is Leaf then..."
17:28:17 <lispy> nuffer: one thing to remember is that more and more end-users are doing the programming.  This paper I have in front of my says that by 2005, they estimate that 55 million programmers will be end-users ande 2.75 million will be professionals
17:28:33 <blackdog> tuomov: Point. Do you have one of those cygwin+Xwin32 encrusted Windows boxes, too? :)
17:28:43 <nuffer> lispy, and what does that mean for people holding CS degrees?
17:28:52 <tuomov> I don't work atm.
17:29:08 <tuomov> and many places strictly disallow installing any of your own software
17:29:22 <lispy> nuffer: that those of use in industry will probably be creating their tools
17:29:26 <tuomov> so you're forced to use programs with an absolutely unusable UI
17:30:09 <blackdog> tuomov: you don't have to work at 'em, though. In fact, that'd be a pretty good indication of somewhere that cares more about processes than results, appearances rather than content: you really want to work at one of those places?
17:30:15 <lispy> nuffer: my MS research topic is a graphical programming language to help end-users create and use webservices
17:30:20 <tuomov> of course, the real problem here runs much deeper than a single software monopoly.. to the very roots of the capitalist system
17:30:39 <tuomov> of wage slavery
17:31:23 <nuffer> well, what I'm saying, lispy, is that that 2.75 million sounds mighty small, considering those would probably be the jobs someone with a cs degree would want
17:31:25 <tuomov> blackdog: there isn't always a choice
17:31:29 <blackdog> lispy: what kind of services?
17:32:16 <tuomov> and that's exactly the reason why they can demand anything they want from you
17:32:19 <blackdog> tuomov: i don't really believe that. You're a pretty sharp programmer, and you've got a fairly impressive resume. How hard could it be?
17:32:27 <nuffer> and is there any-way to say "if x is Leaf" or something like that?
17:32:30 <lispy> blackdog: well, my part is to add features that automate software engineering.  So I have to say, I don't know much about webservices.  But I do have an example that converts USD to russian currency
17:32:52 <blackdog> I've got a much spottier resume than that, and I get tolerably jobs pretty easily.
17:32:55 <lispy> blackdog: and to get the exchange rates it uses a webservice
17:33:26 <blackdog> s/tolerably/tolerable/
17:33:40 <tuomov> the only proper job I've applied to since I lost the last one (that sucked!) I didn't get past their psycho tests...
17:33:48 <lispy> nuffer: something like isLeaf Leaf = True should work
17:34:07 <blackdog> lispy: ok. My current obsession is with making it easy to write haskell apps on the web - something like zope.
17:34:14 <nuffer> so there's no standard way to do this, I need to write my own functions?
17:34:40 <blackdog> tuomov: yeah, i heard. take heart, i once failed a psych test for Pizza Hut. :)
17:34:49 <lispy> nuffer: my point was to use pattern matching, but i don't think i undersand what you are doing
17:34:50 <blackdog> Who was the employer?
17:35:13 <nuffer> okay, I have a "left" which is of type tree
17:35:17 <tuomov> which one?
17:35:18 <nuffer> I want to know if it matches the pattern Leaf
17:35:24 <blackdog> the psych test one
17:35:37 <tuomov> tietoenator
17:35:40 <lispy> nuffer: and you understand the isLeaf function i just showed you right?
17:35:41 <nuffer> in Nemerle, for instance, I would say "if (left matches Tree.Leaf) ..." but I don't know what to say in Haskell
17:35:52 <nuffer> I do, I'm asking if there isn't some shorter way of expressing the same thing
17:36:05 <lispy> nuffer: it uses pattern matching on it's first argument to test if it is a Leaf
17:36:22 <nuffer> right, I understand how the function works
17:36:29 <tuomov> anyway, I didn't even really try the job, just checked if I could get it as it could've had a small chance of actually being interesting
17:36:40 <tuomov> what I really want is to start graduate studies
17:36:41 <nuffer> but I'm curious as to why there is no "is" or "matches" operator in the language
17:36:42 <blackdog> unique high-value-added end-to-end service, hm?
17:37:33 <blackdog> nuffer: you could use "case x of { Leaf x -> blah; Node a b -> blah2; }"
17:37:44 <nuffer> ahh, that looks more useful
17:40:15 <SyntaxNinja> does hugs implement pattern guards?
17:56:58 <skew> nuffer: In response to your earlier question, there are large *languages* written in Haskell
17:57:05 <skew> for one, GHC is written in Haskell
17:57:06 <CosmicRay> cool, dominic is wanting to clarify the licencing on crypto
17:57:16 <nuffer> in what way is GHC a language and not a compiler?
17:57:22 <nuffer> / interpreter
17:57:23 <skew> okay, compiler
17:57:28 <skew> language processing thingy
17:57:43 <skew> as autrijus would tell you, Haskell is one of the best languages ever for writing that sort of thing
17:57:49 <SamB> I thought GHC was written in GHC
17:58:15 <skew> I thought GHC tried to keep most of itself to Haskell 98
17:58:21 <CosmicRay> scary words: "I'm developing an Eclipse plugin for darcs"
17:58:28 <SamB> skew: likely enough
17:58:32 <CosmicRay> skew: heh
17:58:43 <CosmicRay> skew: "try" being the important word in that sentence
17:58:44 <dons> @seen autirjus
17:58:45 <lambdabot> I haven't seen autirjus
17:58:48 <dons> @seen autrijus
17:58:49 <lambdabot> autrijus is in #haskell. Last spoke 5 hours 24 minutes 12 seconds ago.
17:59:08 <dons> autrijus: eval_ should be fixed in the latest tarballs. nibro spotted this a couple of days ago
18:00:11 <blackdog> dons: y'need least-edit-distance on names too...
18:00:22 <skew> autrijus implemented a great deal of perl6 in a few weeks, about three months after learning Haskell.
18:00:24 <dons> hmm!
18:01:04 <dons> @karma+ blackdog
18:01:05 <lambdabot> blackdog's karma has been incremented
18:01:10 <CosmicRay> sigh, autrijus does that 3 months after learning haskell.  6 months after learning haskell, I crank out only arch2darcs
18:01:19 * CosmicRay really needs to catch up :-)
18:01:36 <skew> I think Pugs is the only perl6 implementation at the moment, by the way
18:01:59 <skew> autrijus is pretty cool.
18:02:04 <CosmicRay> indeed
18:02:32 <skew> I haven't written anything really useful in years of knowing Haskell
18:02:41 <SamB> and they said nobody had written any serious programs in it
18:02:59 <CosmicRay> I have written some code for my employer that isn't public
18:03:01 <skew> I mostly just play with weird things you can do
18:03:13 <skew> I am writing some Haskell for my new (first real) job
18:03:27 <dons> cool!
18:03:58 <skew> they want a DSL -> C compiler
18:04:16 <SamB> do they have a DSL yet?
18:04:25 <skew> I already designed that part
18:04:26 <lispy> i'm in a class this term where we are using haskell for our projects
18:04:33 <SamB> cool
18:04:34 <skew> and they liked the interpreter I made
18:04:41 <lispy> i'm doing a DSL for email filtering
18:04:57 <skew> I like the embedding approach myself
18:04:59 <lispy> should be DSL -> procmail
18:05:43 <lispy> skew: my professor loves it.  I think it sounds cool, but i haven't tried it (yet)
18:06:12 <skew> lispy: embedding the DSL?
18:06:18 <SamB> skew: maybe you can figure out a way to load up the compiled C code and run it from within haskell?
18:06:35 <skew> I suppose I could
18:06:44 <CosmicRay> you know, you could use Language.Haskell to convert the DSL to Haskell
18:06:49 <CosmicRay> then just compile that with ghc
18:07:07 <SamB> CosmicRay: I don't think the output of GHC comes under most definitions of C
18:07:18 <CosmicRay> do you really have to get C source?
18:07:26 <CosmicRay> SamB: true, but then rarely would machine-generated C
18:07:30 <skew> But I don't know if Haskell has any special virtues as far as being a high performance server, or speaking wierd binary udp protocols
18:07:41 <lispy> skew: yeah, embedding the DSL, sounds great, but haven't fully tried it
18:08:08 <SamB> skew: buffer overflows are harder?
18:08:12 <skew> and the DSL code definitiely needs to run fast
18:08:37 <skew> this is like per-customer custom processing for lots of traffic
18:08:53 <blackdog> i pulled an evil trick in the ACM comp a year ago - they wanted C source, so don wrote a little app that turned a binary into a c program that wrote out a file from an array in the program then exec'ed it. they only caught me because my C programs were done in half the time of anyone else and multiple megabytes... :)
18:09:06 <dons> sigh.
18:09:27 <skew> what did you build the binaries with?
18:09:33 <blackdog> Hey, I was amused. I'm not a fast enough C hacker to beat the savants there anyway...
18:09:33 <SamB> blackdog: you didn't try the trick with char main[]?
18:09:49 <blackdog> SamB: which trick was thast?
18:09:50 <dons> hmm....
18:10:02 <SamB> blackdog: how many tricks are there with char main[]?
18:10:14 <blackdog> SamB: inordinately confused. What are you asking?
18:10:18 <dons> www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
18:10:26 <dons> that's the script.
18:10:40 <skew> you had a haskell compiler availible at the ACM competition?
18:10:46 <dons> and it produces: www.cse.unsw.edu.au/~dons/run_haskell.c
18:10:57 <SamB> blackdog: you define main as a char array filled with binary code
18:11:05 <skew> hah
18:11:06 <blackdog> skew: only because they didn't sanitise the environment particularly well.
18:11:10 <skew> and then it just runs that.
18:11:18 <SamB> I guess that only works if you write in position-independant ASM
18:11:21 <skew> don't you need to do the linking yourself then?
18:11:23 <dons> yeah.
18:11:36 <dons> SamB, so getting GHC to produce such object code might be tricky
18:11:48 <skew> somehow I doubt PIC TAL is easier to write than C...
18:12:22 <skew> if you thought about it before hand, you could probably write a tiny bit of assembly to get the base address your code is running at, and then somehow convice ld to do the linking at runtime
18:12:26 <dons> what's really stupid was that you could use things like yacc, wasn't that right blackdog?
18:12:30 <SamB> someone did that in tho IOCCC one year, and it ran on PDP-11 and VAX-11...
18:13:00 <SamB> I unfortunately have misplaced my lighter-weight PDP-11 emulator, so I didn't try it.
18:13:07 <blackdog> dons: yep. language fascists, the lot of them. What's the point of teaching ugrads a powerful language, then not letting them ever use it again?
18:13:09 <dons> so their concept of what counted as a code generating tool was a big fuzzy
18:13:30 <blackdog> basically it was a social thing: do it our way or not at all
18:13:42 <blackdog> which is why i felt very little guilt about trying to push the borders a little.
18:14:16 * SamB is a bit worried about the fact that he is seeing C-level probing going on when he configuring Yi
18:14:16 <skew> the C++ template system is a functional language :)
18:14:31 <dons> SamB, nah. needs to talk to ncurses and friends
18:14:45 <blackdog> skew: doesn't it have some limit on recursion? Something arbitrary and low?
18:14:54 <skew> it depends on the compiler
18:15:02 <skew> I think gcc has an option
18:15:06 <SamB> dons: does it really need those headers?
18:15:15 <skew> I know ghc has a similar limit on type class stuff, and an option to set that limit
18:15:27 <SamB> they forgot to add GC, though
18:15:46 <SamB> on the other hand, everything is memoized
18:15:54 <blackdog> but the template system is compile time only, isn't it?
18:15:55 <dons> SamB, I think so. I added them as they were required.
18:16:04 <dons> certainly if you find any that are unnec. let me know.
18:16:26 <dons> SamB: what editor do you use?
18:16:27 <blackdog> dons: did you hear from Wolfgang about the apple gui he knocked up?
18:16:43 <SamB> dons: as in emacs/vi? that would be emacs.
18:16:51 <SamB> emacs21.
18:17:06 <dons> blackdog: I've got an API sketch here. needs some work to reorganise the ncurses ui to use it though
18:17:26 <dons> SamB: feel free to augment the Yi emacs binding.
18:17:37 <SamB> okay, what is with this:
18:17:39 <SamB> config.status: error: cannot find input file: mk/config.h.in
18:17:47 <dons> autoreconf ?
18:17:50 <SamB> naesten@hydrogen:~/hacking/haskell/Yi/work% ls mk
18:17:50 <SamB> config.mk  config.mk.in  paths.mk  rules.mk
18:18:08 <blackdog> dons: the autoreconf dance is getting to be like an automatic neural response, hm?
18:18:09 <SamB> oh, wait. I see.
18:18:15 <SamB> .h is not the same as .mk
18:18:25 <dons> you need to use autoreconf, which generates config.h.in.
18:18:30 <dons> "Users of the darcs repo will require autoreconf"
18:18:52 <dons> blackdog, yep. it's in my spinal memory now.
18:18:56 <SamB> that is way far down!
18:19:05 <SamB> that is like, second or third screenfull
18:19:14 <dons> SamB: cause if you're using the darcs, then you know what you're doing...
18:19:22 <SamB> oh, right.
18:19:23 <SamB> okay.
18:19:28 <dons> i don't want to confuse the tarball users who don't care.
18:19:30 <blackdog> dons: elitist bastard. :)
18:19:38 <dons> :}
18:20:03 <dons> I'm not the one with the years of schoolboy latin ;)
18:20:16 <dons> :P
18:20:18 <SamB> maybe a nice big, capitalized warning to darcs users around line 20-23 would be good?
18:20:21 <blackdog> and has it helped me pick up even once?
18:20:29 <dons> SamB: good idea.
18:20:59 <dons> poor blackdog.
18:21:00 <SamB> just towards the bottom of the first screenfull, where it catches the eye and all ;-)
18:22:20 <dons> Try that, SamB
18:22:54 <dons> blackdog, up for the icfp contest? I'm keen this year :)
18:23:21 <SamB> dons: hmm, that is just below the first screen...
18:23:59 <dons> sigh. not on my laptop. I'll move it up. but seriously -- where in the ghc manual do you think it specifies that you need autoreconf? ;)
18:24:22 <SamB> dons: umm, how many people are going to try to rebuild ghc?
18:24:47 <dons> a few hundred, I guess
18:24:59 <SamB> out of how many users?
18:25:01 <dons> anyway, try that!
18:25:04 <blackdog> dons: when is it?
18:25:09 <dons> May sometime.
18:25:11 <Gahhh> june 24th
18:25:20 <dons> oh, that's right.
18:25:33 <SamB> that should be good
18:25:34 <Gahhh> I wish I knew haskell well enough to compete
18:25:35 <blackdog> bugger. Bugger bugger bugger.
18:25:43 <dons> ?
18:25:48 <blackdog> i'm on a plane on the 24th at midday to Thailand
18:25:49 <clausen> does anyone know of any languages in which the type system is Turing complete, and sets are first class?
18:25:50 <dons> you taking off on me?
18:25:52 <dons> doh.
18:26:05 <blackdog> I thought it was earlier in the month..
18:26:15 <SamB> clausen: and sets are first class?
18:26:31 <blackdog> man, i'm bummed. i really wanted to give it a crack this year.
18:26:34 <clausen> SamB: in Haskell, lists are first class
18:26:41 <clausen> (first class means "built in")
18:26:49 <dons> blackdog, well it is in 2 parts. the other being 2 weeks later..
18:26:55 <clausen> SamB: I would prefer sets to be fundamental, not lists.
18:26:57 <blackdog> i'll still be riding around thailand
18:27:03 <lispy> clausen: that's not the definition of first class that i'm familiar with
18:27:06 <SamB> clausen: but there are no lists in the type system
18:27:23 <SamB> not unless you build your own
18:27:46 <clausen> SamB: oops, you're right
18:27:46 <SamB> you could as easily build your own sets.
18:27:57 <lispy> clausen: and you want to be able to do computation using the type system?
18:28:05 <clausen> lispy: yes
18:28:11 <SamB> well, if you could implement equality
18:28:17 <SamB> perhaps ordering
18:28:22 <clausen> lispy: I want to be able to write a function, say, whose domain is the set of fixed points of another function
18:29:05 <skew> sounds like you need a theorem proving system
18:29:07 <clausen> (this would come in handy for game theory, say)
18:29:09 <clausen> skew: right
18:29:26 <skew> so check out Coq or Isabelle or metaprl
18:29:48 <skew> I don't know much about them, but I think some of them will let you do things like that
18:29:50 <clausen> I've tried playing with Coq, but it doesn't seem so good at computatoin...
18:30:05 <clausen> (it only does theorem proving, AFAICT)
18:30:11 <skew> or, will let you define a type theory that will let you do things like that, and assist you in writing down the proofs that your programs have those types
18:30:18 <dons> you could use twelf
18:30:29 <dons> plenty of people encode programming languages in twelf, and then run them
18:30:33 <skew> it might be possible to express things like your specific example in epigram
18:30:49 <dons> I've seen MinML and SystemF run that way. much fun
18:30:56 <dons> SystemF/Core
18:31:17 * clausen googles franctically
18:32:45 <SamB> @google franctically
18:32:48 <lambdabot> http://www.chantingmonks.com/cms.mv?ARTID=chancejournal
18:32:50 <dons> @google twelf
18:32:50 * SamB also googles franctically
18:32:52 <lambdabot> http://www-2.cs.cmu.edu/~twelf/
18:33:11 <blackdog> dons: sorry about that, don. Sean's keen, isn't he?
18:33:29 <dons> not sure. he's writing his thesis, but I could probably convince him.
18:33:34 <dons> and I'm going to try sjw too
18:33:58 <dons> he's usually up for diversion therapy of this kind
18:33:59 * SamB downloads hs-plugins
18:34:18 <dons> SamB, you can just "make way=static" if you only want to try it out
18:34:36 <dons> but i'm also hacking lambdabot to use hs-plugins as we speak, so you'll need it eventually
18:35:03 <SamB> dons: so, way=static just to tide me over until hs-plugins is downloaded/built
18:35:50 <SamB> yes, I actually have to wait a minute or so for hs-plugins to download
18:36:47 * SamB wonders what tex2page is, goes to page
18:37:13 <dons> it's a nice scheme-based tex 2 html translator. much better than latex2html
18:37:25 <SamB> runs on schemes AND CL? my my.
18:37:26 <dons> also marks up functional language code nicely
18:38:24 <SamB> aren't most things better than latex2html?
18:38:41 <SamB> I mean, except the ones that nobody uses because they aren't?
18:38:49 <dons> possibly. but it seems still in common use.
18:39:06 <SamB> true, true
18:47:22 <SamB> okay, I seem to have invoked yi in vi-mode
18:47:28 <SamB> how do I get out?
18:48:35 <dons> :q
18:48:42 <SamB> ah, thanks.
18:49:09 <dons> only the vim and vi modes are fully developed. nano has maybe 60% and emacs is only a few days old
18:49:40 <dons> yi --as=emacs is probably what you want
18:50:11 <lispy> is it just emacs key bindings that it gives?
18:50:17 <SamB> well, I'm rebuilding with hs-plugins
18:50:24 <dons> lispy, so far.
18:50:53 <dons> lispy, what were you wondering about?
18:51:05 <lispy> is is the goal to also provide the surrounding environment?  (I'm thinking of things like the emacs redraw system)
18:51:23 <lispy> hmm..i think i meant redisplay
18:51:33 <dons> not sure what that does, but my goal is to add a haskell scripting environment
18:51:36 <SamB> which yi do I want to run now that I've built it with no way?
18:51:44 <SamB> yi_ or yi-inplace?
18:51:44 <dons> ./yi-inplace
18:51:53 <SamB> okay
18:51:58 <skew> the wayless way of righteousness
18:52:07 <skew> good work Sam
18:52:28 <dons> yes, yi is certainly part of the no way movement
18:53:20 <SamB> No way!
18:53:22 <lispy> dons: one of the things that makes emacs nice is that you can create applications that run in X or on a terminal
18:53:35 <lispy> dons: actually, i don't really understand what Yi is
18:53:46 <lispy> dons: so i'm probably confusing things :)
18:53:59 <dons> oh, ok. I see what you mean. yes -- there's a gui model being developed, so that haskell code will run on either
18:54:11 <lispy> ah, very nice
18:54:24 <SamB> okay, I just typed in a lot of prefixes before I got an error message...
18:54:53 <dons> in emacs mode. I don't use it so I'm not sure what the problem is.
18:55:12 <SamB> this happens alot?
18:55:19 <dons> what?
18:56:20 <SamB> nevermind, I am confused about what you may or may not know...
18:56:29 <lispy> this is OT, but maybe someone will know the answer.  Is there a plugin for firefox to make the tabs behave like the tabs in Galeon?
18:56:47 <pimaniac> lispy: and how do the tabs in galeon behave?
18:57:06 <SyntaxNinja> lispy: trying to make the switch? :)
18:57:09 * SyntaxNinja is a galeon fan
18:57:32 <lispy> pimaniac: well, i can place them on the left (in rows) and loading pages are in red, unread pages are in blue
18:57:37 * SamB doesn't remember why he doesn't use galeon
18:57:56 <lispy> SyntaxNinja: i tried to build galeon on this machine (I don't have root) and it looks to be a pain, so i'm trying to get by with firefox
18:58:49 <lispy> galeon's configure script complained that i don't have some sort of embedded mozilla package installed
18:59:24 <SamB> ooh, a Lexer library that is actually used ;-). neat!
18:59:59 <dons> the lexer combinators for writing keymaps are one of the nicest parts of yi, I reckon.
19:00:53 <dons> and they quickly reveal some of the bizarre grammar of existing editors.
19:01:59 <pimaniac> lispy: i checked all the extensions that are tab related, and nothing about coloring loading or vertical stacking. sorry :-P
19:02:33 <lispy> pimaniac: ah, too bad.  I'm trying out https://addons.update.mozilla.org/extensions/moreinfo.php?id=158&application=firefox this one to see what enhancements i can get
19:05:56 <lispy> https://addons.update.mozilla.org/extensions/moreinfo.php?application=firefox&category=Tabbed%20Browsing&numpg=10&id=436  <-- this adds another feature of galeon i like, being able to resume after a crash
19:08:01 <pimaniac> i would like to ask questions about haskell, and i was wondering: is there was a #haskell "check here first to avoid yelling" website?
19:08:17 <SamB> pimaniac: what yelling?
19:08:41 <pimaniac> yelling at n00b yelling :)
19:08:54 <SamB> well, yes. but do we actually do that?
19:09:32 <blackdog> nah, we like noobs.
19:09:38 <pimaniac> yay!
19:09:44 <lispy> i have to say, this channel is the most polite language channel on freenode  ;)
19:09:47 * blackdog represses comment about a nice white-wine sauce
19:10:00 <SamB> I don't think we get all that many frequent questions... the most common seems to be people asking for others to do their homework
19:10:16 <pimaniac> well, i do have a large assignment due in about 30 seconds
19:10:24 <blackdog> and we respond by being incredibly helpful without actually telling 'em a line of code. it takes more effort, but we don't get overwhelmed...
19:10:48 <pimaniac> blackdog, great policy :)
19:10:53 <SamB> also, by saying "we don't do your homework for you" or something like that
19:11:34 * vincenz prefers saying "I'll do your homework, just give me 100 dollars"
19:11:39 <vincenz> make that 500
19:12:20 <pimaniac> ive been working through an older haskell book and have found no IO or monads.  Then I see an interview regarding PUGS about how monads were kinda recent.  Am I getting the whole picture?
19:12:44 <SamB> pimaniac: of course not. you probably don't want the *whole* picture.
19:12:46 <dons> I think we can shapr for the positive vibe of #haskell.
19:13:04 <SamB> pimaniac: what are you wondering about, though?
19:13:09 <dons> and maybe the larger haskell community, which is very friendly too
19:13:11 <pimaniac> SamB: on the contrary, i have much reknown among my peers for collecting whole pictures :)
19:13:17 <vincenz> dons: add a "thank"
19:13:42 <blackdog> i dunno, i quite like the use of 'shapr' as a verb
19:13:46 <dons> oh, oops. to shapr isn't a verb yet.
19:14:04 <blackdog> get out of my head, or i shall replace the tinfoil helmet.
19:14:47 <SamB> blackdog: maybe the tinfoil helmet is bugged
19:15:11 <dons> that's how I sneak in on my invisible wires
19:15:13 <pimaniac> SamB: well, monads seem nifty for pulling haskell out of a lisp-style repl.  was haskell always in a repl before 1998?
19:15:28 <blackdog> ... the tinfoil itself has bugs? Lordy lord, i'm going to need recursive tinfoil for this to work.
19:16:02 <blackdog> dons: i wouldn't be surprised. there must be some reason I keep hacking on your suggestions when i should be doing paying work.
19:16:03 <dons> you need your tinfoil on the type level
19:16:05 <SamB> blackdog: not programming errors. covert-collection-of-brainwaves kind.
19:16:23 <dons> you're highly suggestable, blackdog
19:16:27 <blackdog> SamB: that's what i was thinking, actually.
19:16:47 <blackdog> dons: <dazed> yes... yes, i am.. you're right, i _am_ suggestible! </dazed>
19:17:23 <dons> now, when I click my fingers, you'll be a zope hacker, and you'll love it. <click>!
19:17:35 <SamB> blackdog: perhaps Jedi training would work better than recursive tinfoil. alternatively, you could buy a droolbucket and become a Hutt.
19:17:44 <blackdog> alright. it's a beautiful day. i'm off to the beach to check out the fine ladies. (sotto voce, so mad doesn't hear me...)
19:17:56 <dons> hehehe
19:18:54 <SamB> pimaniac: I didn't use haskell before, oh, this century at least.
19:19:41 <vincenz> SamB: not even before this millenium???
19:19:50 <SamB> vincenz: are they not the same?
19:19:55 * vincenz grins
19:19:59 <vincenz> actually no
19:20:03 <SamB> the befores, I mean
19:20:09 <vincenz> no
19:20:10 <pimaniac> cool.  i shall refrain from history questions
19:20:21 <vincenz> millenium and century started in different years
19:20:35 <SamB> pimaniac: just ask people who are older than me ;-)
19:20:43 <vincenz> if I have it correct, the centuray started a year later than the millenium
19:21:02 <SamB> vincenz: I heard the millenium started in 2001...
19:21:54 <SamB> it might be because the romans had no 0.
19:22:01 <pimaniac> SamB: it was just a passing question :)  ill just work on my old book and then learn monads after
19:22:31 <SamB> pimaniac: you probably don't want to worry about whatever they used for IO back then, but I guess you knew that?
19:23:02 <vincenz> SamB: then the millenium started after the century
19:23:45 <SamB> vincenz: seriously. the first century and the first millenium would have both started in the year 1, right?
19:23:55 <dons> monads where in Haskell prior to '96 at least, btw.
19:23:56 <pimaniac> SamB: definitely.  probably something unspeakable
19:24:12 <pimaniac> dons: yay!
19:24:27 <blackdog> of course, given Jesus' divinely-inspired gestation time, year 1 isn't really year 1.
19:25:07 <vincenz> SamB: no century started in 0
19:25:18 <shrimpx> the 0 vs 1 argument is so retarded
19:25:19 <shrimpx> sorry
19:25:29 <pimaniac> i like my old book.  very little on haskell, but lots on lambda calculus and program proofs
19:27:10 <pimaniac> and since those two are hard to find tutorials on, the haskell lack is more forgivable
19:27:14 <dons> Gopher, v2.28, 1993: Added support for a simple selection of operators for monadic I/O
19:27:39 <dons> don't know why people have the idea that monads began with H98.
19:28:17 * SamB goes to look on meme
19:28:24 <pimaniac> dons: well, i did try to double check
19:28:31 <dons> Taking the approach outlined by Wadler in his paper `The Essence of
19:28:32 <dons> Functional Programming' (POPL '92), we introduce a constructor class of
19:28:32 <dons> monads
19:29:11 <dons> so, within a few months of that paper coming out, monads were in Haskell :)
19:30:29 * SamB does not understand vincenz's argument... does not even know what vincenz is trying to claim...
19:30:41 <dons> there's lots of interesting early discussion of monadic Haskell in the Gopher release notes, for anyone interested in the history.
19:31:21 <SamB> before that, they used something really painfull with lazy lists?
19:31:30 <vincenz> SamB: a century is between 0 and 99 a millenium is between 1 and 1000
19:31:39 <SamB> vincenz: sez who?
19:31:46 <vincenz> the definitions
19:31:50 <SamB> that makes no sense, there was no 0.
19:32:02 <dons> so, monads were in by Haskell 1.2
19:32:11 <SamB> are you telling me there was a century with only 99 years in it?
19:32:25 <SamB> or that there was no first century?
19:32:27 <skew> I think the lazy list thing is pretty neat
19:33:14 <pimaniac> lazy list thing?
19:33:33 <skew> you can download GHC versions back to 0.29, if you really want
19:33:53 <SamB> wow. Does that come in binaries?
19:34:18 <pimaniac> its GHC, Enterprise Version?
19:34:19 <skew> wow, they had the profiling tools tack then
19:34:26 <skew> and concurrent Haskell, apparently
19:34:26 <dons> "Gofer has been successfully compiled and used on a number of other
19:34:27 <dons> machines including Apollo, DecStation, Mips, MicroVax and Acorn ARM"
19:34:45 <skew> and only 5 sections under "Glasgow extensions to Haskell"
19:35:34 <SamB> so they didn't archive before they made it up to Haskell?
19:35:54 <skew> I guess not
19:36:07 <SamB> or did they extend early and often?
19:36:17 <skew> you check if the cvs history goes back that far, if you want to
19:36:29 <SamB> no thanks, I'm on dialup.
19:37:13 <skew> "Dialogue-style I/O -- still the default for GHC -- is on its way out"
19:38:31 <dons> when's that?
19:38:36 <skew> ghc 0.29
19:38:52 <dons> ok.
19:38:56 * SamB fails to understand the comment before Yi.Lexers.star, looks in a barely-hacked copy of Lexers.hs
19:38:58 <skew> there's also this bit about nifty new things in the Haskell 1.3 proposal, subject to change arbitrarily but you might want to use them
19:39:14 <skew> data Either a b = Left a | Right b deriving (Text,Eq,Ord)
19:39:26 <skew> data Maybe a = Nothing | Just a deriving (Eq,Ord,Test)
19:39:37 <skew> curry   :: ((a,b) -> c) -> a -> b -> c
19:39:42 <skew> uncurry :: (a -> b -> c) -> (a,b) -> c
19:39:44 <skew> monadic IO
19:40:27 <dons> SamB: " x `star` y corresponds to the regular expression x*y"?
19:40:35 <skew> it sounds like they assume that monadic style was being used for most of the Dialogue I/O code anyway
19:40:58 <SamB> dons: this much I remember. I just didn't find the definition in Yi.Lexers very confusing ;-)
19:41:17 <SamB> huh, it is the same as the original
19:41:40 <dons> you didn't find the Yi defn confusing. ok, that's a good thing, right?
19:42:06 <SamB> I thought it was more confusing! I am confused as to why I was not confused this time.
19:42:35 <dons> the ctk lexer combinators are the same, except i added a couple of alternative names, and modified the tables to handle collisions.
19:42:59 <SamB> dons: nice.
19:43:27 <dons> are you looking to hack on the emacs mode?
19:43:34 <SamB> I don't know yet
19:43:34 * dons hopes "yes"
19:45:33 <lispy> dons: do you mind summarizing why someone would want to use Yi in vi or emacs mode over using vi or emacs?
19:46:15 * lispy hopes dons knows that he's not picking on Yi and is genuinely curious
19:47:07 * SamB wonders what happened to his backspace key
19:47:09 <dons> at the moment, they wouldn't. in the longer term, it will be of interest to haskell hackers, as the editor is scriped with haskell. also, the syntax hl and other language features are more rigorous, as we intend to use parser plugins, typechecker hooks etc, not just regexes
19:47:26 * SamB suspects some program of remapping it
19:47:33 <vincenz> What is yi?
19:47:37 * SamB wishes programs wouldn't do that :-(
19:47:43 <dons> @google yi text editor
19:47:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
19:47:48 <lispy> dons: thanks
19:48:25 <dons> so i expect it to provide a excellent haskell coding support. that's enough for me to switch
19:48:38 <dons> and being scriptable in haskell is nice too
19:48:49 <lispy> on a semi related note, there is a group in the lisp community trying to write a replacement for emacs which is written in and uses common lisp.
19:48:54 <SamB> but actually working would also be nice
19:48:57 <dons> but it's a research project at the moment, that I'm trying to push out to the community
19:49:25 <SamB> what shall I debug my keymap with...
19:49:37 <dons> SamB, I'm a vim user, so the vim support is quite good.
19:50:44 <dons> the comment "actually working would also be nice" is not that constructive
19:50:44 <SamB> dons: yes, yes. that does me little good.
19:50:51 <SamB> I know, I know.
19:51:10 <SamB> the thing is, I don't know what the problem really is.
19:51:21 <dons> it's open source + you're an emacs user = hack hack hack!
19:51:32 <dons> ah, ok. then I can help maybe.
19:51:34 <SamB> actually working right under X is hard. I'll try the console, hmm...
19:51:43 <dons> working under X?
19:51:55 <SamB> I was trying
19:51:55 <dons> are you saying yi doesn't work properly in xterm?
19:52:05 <SamB> its not xterms fault, I think
19:52:17 <dons> what is going wrong?
19:52:32 <SamB> well, earlier backspace was working, but now it isn't.
19:53:21 <dons> I haven't seen this behaviour at all. I find it difficult to see how yi could be at fault too. we don't mess with that kind of stuff.
19:53:22 <SamB> C-h k doesn't seem to work, either.
19:53:39 <SamB> Yes, I rather suspect X is being to complicated for Yi or something like that.
19:54:05 <dons> no. it's a ncurses application. it runs via ncurses. X has nothing to do with it.
19:54:21 <dons> I exclusively use yi in an xterm, under X.
19:54:31 <dons> maybe you're just seeing bugs in the current emacs mode.
19:54:37 <SamB> could be.
19:54:40 <dons> do you get these problems with the default vim mode?
19:55:09 <SamB> uh, oh, no.
19:55:23 <dons> have a look at Yi/Keymap/Emacs.hs, see what's implemented and what isn't.
19:55:23 <SamB> okay, so X is not the problem...
19:56:31 <SamB> okay
19:59:54 <SamB> hmm, now what was I doing that had backspace working? this definately doesn't look like backspace should work...
20:00:37 <dons> note that there are different backspace chars: ['\BS', '\127', keyBackspace ]
20:00:54 <dons> possibly the emacs mode author didn't know this(?)
20:01:27 <pimaniac> i wonder if an elisp compatibility layer is possible :)
20:02:04 <dons> an elisp interpreter written in Haskell, or an ffi binding to lisp would both be possible
20:02:23 <pimaniac> i was thinking the first sounded funner
20:02:43 <dons> I think there's already a lisp interpreter.
20:02:55 <dons> but the idea is to write new code in Haskell, then we get stronger typing guarantees
20:03:07 <dons> it's not a 'yet another lisp editor'
20:03:35 <dons> SamB, maybe you want something like: k | isDel k -> leftE >> deleteE
20:03:43 <pimaniac> it would be a selling feature for emacs switchers, but your point is certainly more important
20:03:46 <dons> isDel '\BS'        = True
20:03:47 <dons> isDel '\127'       = True
20:03:47 <dons> isDel c | c == keyBackspace = True
20:03:47 <dons> isDel _            = False
20:04:07 <dons> pimanica: supporting existing lisp code would be cool though.
20:05:11 <pimaniac> well, time for me to seriously start learning haskell
20:05:54 <dons> yay!
20:06:11 <dons> @plugs map (+1) [1..5]
20:06:16 <lambdabot> [2,3,4,5,6]
20:06:52 <dons> @plugs foldr1 (*) [1..5]
20:06:53 <lambdabot> 120
20:08:05 <cm> peace
20:10:40 <pimaniac> @plugs foldrl (+) [1..5]
20:10:41 <lambdabot> Variable not in scope: `foldrl'
20:11:15 <pimaniac> oh, hehe.  one versus l.  ill go play in a terminal instead
20:11:48 <vincenz> @plugs map (\x map (*x) [1..5]) [1..5]
20:11:49 <lambdabot> parse error on input `)'
20:11:52 <vincenz> @plugs map (\x map (*x) [1..5]) [1..5])
20:11:53 <lambdabot> parse error on input `)'
20:12:03 <vincenz> @plugs map (\x -> map (*x) [1..5]) [1..5])
20:12:04 <lambdabot> parse error on input `)'
20:12:07 <vincenz> ?
20:12:52 <vincenz> @plugs map (\x -> x*x)
20:12:53 <lambdabot> No instance for (Show ([a] -> [a]))
20:12:53 <lambdabot>       arising from use of `show' at         v = (take 2048 (show (map (\
20:12:53 <lambdabot> x -> x * x))))
20:12:53 <lambdabot>     In the definition of `resource':
20:12:53 <lambdabot>         resource = let v = (take 2048 (show (map (\ x -> ...)))) in v
20:12:57 <dons> @plugs map (\x -> map (*x) [1..5]) [1..5]
20:12:58 <vincenz> @plugs map (\x -> x*x) [1..5]
20:12:58 <lambdabot> [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]
20:12:59 <lambdabot> [1,4,9,16,25]
20:13:04 <vincenz> oh finally!
20:13:35 <vincenz> what'd I get wrong?
20:13:46 <dons> @pl \l -> map (\x -> x * x) l
20:13:47 <lambdabot> map (s (*) id)
20:14:09 <SamB> @help pl
20:14:10 <lambdabot>  @pointless <expr> - play with pointfree code
20:14:19 <dons> there was a trailing ) in your code
20:14:20 <vincenz> what is pointfree?
20:14:31 <SamB> vincenz: code with no point ;-)
20:14:39 <vincenz> point?
20:14:56 <vincenz> I'll ask tomorrow
20:14:58 <SamB> nevermind, that is the joke meaning
20:14:59 <vincenz> I really have to hit the sack
20:15:00 <dons> it's a haskell coding style with a mimimum of 'points' (== named variables), and lots of theory
20:15:04 <vincenz> ah
20:15:06 <vincenz> nice
20:15:39 <dons> so:
20:15:47 <dons> @pl \f x -> f x
20:15:48 <lambdabot> id
20:15:58 <dons> @type \f x -> f x
20:16:00 <dons> @type id
20:16:03 <lambdabot> \f x -> f x :: forall t t1. (t -> t1) -> t -> t1
20:16:04 <lambdabot> id :: forall a. a -> a
20:16:10 <SamB> how does @pointless work?
20:16:30 <dons> it does syntactic transformations on the expression, using a set of transform rules
20:16:47 <dons> @pl 1 + "foo"
20:16:49 <lambdabot> 1 + "foo"
20:17:04 <dons> purely syntactic.
20:18:17 <SamB> dons: what are the characters for plain-old delete?
20:19:12 <SamB> or doesn't vi have one of those?
20:19:28 <dons> see my above list.
20:19:31 <dons> those 3.
20:20:01 <dons> grep for isDel in Keymap/Vim.hs
20:20:44 <dons> it's all a matter of working out what key you want, and what sequence of Core.hs actions produce the desired result
20:21:10 <SamB> hmm, when I press the delete key (under cat), I see ^[[3... which is... umm... escapeKey:"[3" or something like that...
20:21:38 <dons> can you type a literal delete in emacs and see what code it produces?
20:21:48 <dons> an escaped delete, I mean
20:21:59 <SamB> escaped delete?
20:22:07 <SamB> in emacs?
20:22:24 <dons> the ^[[3 is probable keyBackSpace
20:24:28 * SamB typed C-h k delete, got something beginning "<delete> runs the command delete-char"...
20:25:17 <dons> do any of the 3 keys I mentioned above produce the desired result in your binding?
20:25:25 <dons> it's surely one of those 3 you want.
20:26:19 <SamB> which one of those would delete the char to the *right* of (under?) the cursor in some programs?
20:27:29 <dons> depends on the program. just code that behaviour (can't you steal it from the nano mode?)
20:27:56 <SamB> oh, good idea.
20:28:09 <dons> 'key' -> deleteE
20:28:20 <dons> or 'key' -> rightE >> deleteE
20:28:25 <dons> not sure which one you want.
20:28:36 <dons> look at the cmdCharFM in Nano.hs
20:28:37 <SamB> the former.
20:28:59 <dons> the Nano mode is intended to be a tutorial on writing the emacs mode too. so you may find it useful
20:29:08 <SamB> only it will be more like char '\something' `action` Just $ deleteE
20:30:07 <dons> where something could be: alt ['\BS', '\127', keyBackspace ]
20:30:29 <dons> and just remove which keys aren't supposed to delete that way.
20:30:45 <SamB> those keys are apparantly all backspace keys
20:31:03 <dons> that's what I keep saying :}
20:31:33 <SamB> apparantly the one I want is \^D?
20:31:38 <SamB> I shall see.
20:39:10 <SamB> what does Yi use alex and happy for?
20:39:49 <dons> they are going to be used for writing accurate syntax highlighting (we need to parse the buffer)
20:40:10 <SamB> aren't they a bit too static?
20:40:13 <dons> a sketch of this is in the Syntax dir.
20:40:19 <SamB> or are they to be run at runtime?
20:40:35 <blackdog> dons: many fine ladies, many good waves. too much seaweed though.
20:40:44 <dons> depends. to get the full Haskell syn hl working, I want to grab the ghc parser as is.
20:40:50 <SamB> oh, right.
20:40:53 <dons> later rewriting it using combinators would be a good idea.
20:41:02 <dons> then users can augment the parser dynamically
20:41:13 <cm> you're gonna reparse the buffer every time its content changes, or are you thinking about something more sophisticated?
20:41:14 <SamB> so for most languages we can just use Parsec?
20:41:15 <dons> blackdog, :)
20:41:25 <dons> I would expect so, SamB.
20:41:34 <dons> full GHC Haskell is a special case atm.
20:41:36 <SamB> okay, thats cool then
20:41:46 <dons> you could even just use regexes if you want
20:41:52 <SamB> umm...
20:41:57 <blackdog> dons: let's not go back there... :(
20:42:02 <dons> cm, the Haskell parser has hooks for subexpressions.
20:42:02 <SamB> you *are* kidding, right?
20:42:15 <dons> so i'd hope to be able to reparse just the local expression
20:42:41 <dons> no. I expect some users may not want to write a parser, but instead adopt one of the regex syn hl from other editors
20:42:49 <dons> it's supported, is all.
20:42:53 <dons> not that  I'd do it that way.
20:43:17 <SamB> dons: I would not be so mislazy!
20:45:13 <dons> yeah, most haskell people would be fine with writing a parser.
20:45:34 <dons> but that's unusual in other editors. vim and emacs are both regex approximation parsers :/
20:45:42 <dons> why that is, I do not know.
20:45:42 <SamB> would rather do so than pull our hair out trying to use regexes, even
20:45:55 <SamB> because other languages do not have parsec
20:46:24 <dons> true.
20:46:57 <SamB> and not all of us are as mad smart as James Clark
20:47:39 <SamB> (who wrote the coolest thing, an XML mode that parses and validates as-you-go, all in elisp)
20:47:57 <SamB> nxml-mode, it is called
20:49:49 * SamB wishes someone else would say *something*
20:50:13 <dons> @vixen say something
20:50:15 <lambdabot> go on
20:50:16 <pimaniac> *something*
20:50:29 <dons> @vixen is SamB going nuts?
20:50:31 <lambdabot> have you ever made it with a man?
20:51:02 <blackdog> *grin*
20:51:02 <dons> @vixen you're very impertinent
20:51:04 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
20:51:33 <blackdog> @vixen I once used unsafeperformIO without proving it correct
20:51:34 <lambdabot> are you? how's it going?
20:51:42 <sh10151> emacs has semantic
20:51:48 <sh10151> that's not regex
20:51:49 <sh10151> :)
20:52:09 <lispy> semantic?
20:52:10 <dons> oh good. i'd hoped that they had a real parser lib for writing syntax hl
20:52:26 <dons> it seemed almost incomprehensible that they wouldn't.
20:52:32 <dons> but doesn't haskell hl still suck?
20:52:43 <SamB> sh10151: what is semantic?
20:52:50 <SamB> where can I get it/read about it?
20:52:58 <dons> see- you get proper indenting for (almost) free too if you use a parser
20:53:06 <dons> .hs indenting is woefull everywhere
20:53:07 <sh10151> http://cedet.sourceforge.net/semantic.shtml
20:53:30 <pimaniac> theres an unofficial haskell mode for emacs.  anyone try it before?
20:53:55 <lispy> heh, cool, i bet it's solw
20:53:57 <lispy> er slow
20:54:05 <pimaniac> even looks like it has inferior haskell support
20:54:05 <lispy> (semantic that is)
20:54:23 <pimaniac> like ilisp
20:54:26 * SamB runs hd and types delete at it, followed by enter and ^D
20:54:48 <SamB> pimaniac: ever tried slime?
20:55:04 <pimaniac> SamB: a bit.  its awesome :)
20:55:06 <SamB> that stands for superior-lisp-something-something-something
20:55:21 <SamB> it seems to work better ;-)
20:55:25 <pimaniac> SamB: superiour lisp interaction mode for emacs
20:55:30 <dons> superious lisp is mostly erroneous
20:55:42 <SamB> dons: say what?
20:55:48 <pimaniac> SamB: waaaay better than ilisp, but implemented as layer on ilisp
20:55:52 <dons> @spell superious
20:55:54 <lambdabot> superiors spurious Superior's superior's serious
20:55:59 <dons> almost.
20:56:25 <SamB> dons: are you talking about slime, or something else?
20:56:38 <pimaniac> s/superiour/superior/g.  I happen to be a horrible speller.
20:57:09 <SamB> pimaniac: actually, I wouldn't be surprised if that is a real (UK) spelling...
20:57:11 <dons> i'm talking silly talk
20:57:11 <lispy> i've tried to like slime about 4 times now, it's gotten better, but i still find it horrible :)
20:57:49 <pimaniac> SamB: yeah.  but i try to stick to one or the other. i read too much from the UK to spell consistently
20:58:00 <lispy> and i've discovered that if you have criticisms for slime in #lisp you will get attacked :)
20:58:09 <SamB> pimaniac: I don't really try
20:58:27 <SamB> lispy: what do you not find horrible?
20:59:09 <pimaniac> lispy: I'm kinda liking slime, but i have no serious objections to almost any programming environment.  Whats your take?
20:59:44 <lispy> i usually just use the lisp from the built in repl
20:59:49 <lispy> or run it inside of emacs that way
21:00:11 <lispy> slime tries to guess what i want to do, and often guess wrong
21:00:25 <lispy> which causes more work for me :)
21:01:01 <pimaniac> ah
21:01:25 <lispy> i've also had a lot of issues with slime getting confused and not letting me create a new repl
21:01:35 <SamB> new repl?
21:01:50 <pimaniac> interaction between the interpreter and the user
21:01:53 <lispy> yeah, if you kill the running lisp instance and start a new one, slime gets mad
21:01:57 <pimaniac> read eval print loop
21:02:03 <lispy> oh, yeah, sorry
21:02:19 <lispy> acronyms can be a bad thing
21:02:45 <SamB> lispy: oh really?
21:02:52 <SamB> I know what a repl is ;-)
21:02:56 <pimaniac> haha
21:03:02 <pimaniac> so i did interpret that wrong
21:03:09 <pimaniac> lispy 1 pimaniac 0
21:03:32 <lispy> SamB: yeah, on my system once i do that, i can't load files using the emacs keybindings
21:03:36 <SamB> I don't remember it getting mad at me when I did that... I think I did that...
21:03:55 <SamB> I did M-x slime again right after, though
21:04:20 <lispy> yeah, that's what i do, i kill the buffer with the repl and then M-x slime
21:04:49 * pimaniac is idling in #lisp and discussing lisp in #haskell.  The irony.
21:05:19 <lispy> another thing i don't like is that when you type the number for a restart, it automatically takes that restart.  I don't always hit the right key...
21:06:31 <lispy> i've also found that swank (the part of slime that runs on the lisp side) causes backtraces and debugger output to have extra confusing "stuff"
21:07:15 <pimaniac> what lisp did you use?
21:07:22 <lispy> sbcl
21:07:37 <lispy> but sometimes i use cmucl, clisp or lucid
21:07:45 <SamB> I use cmucl
21:08:08 <SamB> it seems to work fine, although what you think is "confusing" I may dismiss as irrelevant...
21:08:15 <SamB> although I don't really know much CL
21:08:19 <lispy> i'm hoping that after this term i'll know haskell well enough that i may stop using lisp for new projects
21:09:01 <lispy> but on the other hand, lisp is tried and true for me
21:09:12 <lispy> so i doubt i'll ever stop using it
21:09:51 <lispy> hmm...i think it's time to head home
21:10:32 <pimaniac> bye bye
21:13:07 <SamB> how refreshing... I can actually go into ghci and just type :l Yi.Yi and it actually works
21:13:50 <dons> :)
21:14:38 <SamB> also, I had the sense to look in the curses manpage for getch to see what they call the delete key...
21:14:55 <SamB> it looks like they call what I mean by the delete key KEY_DC
21:15:32 <dons> ok, that's keyDC
21:15:46 <SamB> yes, thats what I was using ghci for
21:16:09 <SamB> although I mistyped the c as lowercase
21:18:09 <SamB> hmm, I don't think backspace should do anything at the beginning of the buffer...
21:18:23 <SamB> oh well, another patch, another day
21:19:13 <dons> that behaviour can be programmed.
21:20:51 <SamB> okay, you should have it now
21:21:28 <dons> got it. thanks!
21:21:41 <Cale> what does backspace do at the beginning of the buffer?
21:22:05 <CosmicRay>  is there a darcs mirror anywhere of cvs.haskell.org?
21:22:12 <SamB> Cale: the leftE just does nothing, and the deleteE deletes the first character
21:22:49 <Cale> ah
21:23:07 <dons> you can work out if you are at point == 0, and handle that case
21:23:39 <SamB> dons: sounds complicated. another days hacking, that.
21:23:55 <dons> probable 5 or 6 chars of code
21:24:29 <dons> b <- atSofE ; if b then ... else ..
21:24:43 <dons> atSofE :: IO Bool, Is the point at the start of the file
21:24:59 <SamB> still, I am done hacking now
21:25:08 <SamB> it is about my bedtime
21:25:10 <dons> that's fine.
21:25:19 <dons> I won't tie you up and make you hack yi
21:26:14 * blackdog is skeptical
21:26:31 <Cale> blackdog: that he won't do it?
21:26:35 <dons> you watch out blackdog!
21:27:04 <blackdog> dons: you stay away. i'm hacking plone now.
21:27:56 <dons> <mr. mesmiro>I know you want to hack yi.. hmm. yi.. yes, it's yi you want to hack, isn't it</mr. mesmiro>
21:30:11 <blackdog> how's the syntax hl going? :)
21:30:50 <pediddle> hello haskellers
21:30:56 <Cale> hello
21:31:01 <lispy> dons: do you say it "why" or "Y-I" ?
21:31:12 <dons> yee
21:31:32 <lispy> ah, the people i heard about it from called it y-i
21:31:39 <dons> that's ok too.
21:31:43 <lispy> ah, okay
21:31:47 <dons> @eval Y I
21:31:50 <lambdabot> out of fuel - use @resume to continue
21:32:07 <dons> @get-def Y
21:32:08 <lambdabot> Y = \f.U(\g.f(U g))
21:32:09 <dons> @get-def I
21:32:10 <lambdabot> I = \x.x
21:32:14 <lispy> ah
21:32:59 <dons> @pointless (\f -> U (\g -> f (U g) )) (\x -> x)
21:33:00 <lambdabot> U U
21:33:07 <dons> hmm.
21:33:34 <dons> @get-def U
21:33:35 <lambdabot> U = \f. f f
21:33:42 <dons> very nice @pl
21:34:22 <dons> @pl (\f -> f f) (\f -> f f)
21:34:26 <lambdabot> s id id (s id id)
21:34:26 <lambdabot> optimization suspended, use @pl-resume to continue.
21:34:28 <dons> hehe
21:35:06 <Cale> @pl-resume
21:35:13 <lambdabot> s id id (s id id)
21:35:13 <lambdabot> optimization suspended, use @pl-resume to continue.
21:36:29 <pediddle> So, aside from all this silliness, I'm feeling particularly unimaginative tonight, but I'm looking for a new project to start hacking on
21:36:56 <pediddle> If y'all could think of any small-to-medium size project you wish could be invented/duplicated in Haskell, what would it be?
21:37:05 <dons> I know .. emacs binding for yi!
21:37:14 <pediddle> like i said, silliness :)
21:37:20 <dons> that's not silly.
21:37:31 <pediddle> well anyway i use VI
21:37:37 <pediddle> err, i spelled that wrong
21:37:38 <pediddle> vi
21:37:40 <dons> so you really want to use YI then.
21:37:56 <dons> you could finish off the vi emulation, it's fairly good.
21:38:03 <dons> then add syntax highlighting?
21:38:13 <lispy> hmm..i would have sworn i was going home :)
21:38:16 <lispy> and i'm still hree
21:38:25 <pediddle> I must apologize that I don't know what YI is
21:38:32 <pediddle> a link for the google-impared?
21:38:56 <dons> @google yi text editor
21:38:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
21:39:08 <lispy> i'm really impressed by how little memory compiled haskell programs consume
21:39:08 <pimaniac> notice the ~dons :)
21:39:12 <pediddle> thanks
21:39:16 <dons> :P
21:39:33 <dons> it's got to be hosted somewhere.
21:40:02 <pimaniac> dons: so its not entirely your project?
21:40:38 <dons> there's been a few people contribute. check the change logs
21:40:56 <dons> and a lot of the design has been established on #haskell
21:41:12 <pediddle> your wiki page is quite sparse
21:41:13 <pimaniac> so more like a #haskell project.  cool
21:41:16 <pediddle> but you already knew that
21:44:42 <dons> i wish ghci-produce types were compilable: load :: forall (m :: * -> *). (MonadLB m) => [Char] -> m ()
21:44:58 <dons> then i could just use ghci to insert all my types magically
21:45:05 <dons> currently they need a little editing
22:04:42 <SamB> dons: maybe it is because of the -fglasgow-exts that they are not compileable? I mean, mine would do that anyway, but yours is the newer one right?
22:05:59 <dons> ghci still adds explicit forall's though.
22:06:36 <dons> whereas hugs:
22:06:36 <dons> List> :t sort
22:06:37 <dons> sort :: Ord a => [a] -> [a]
22:06:49 <dons> Prelude List> :t sort
22:06:49 <dons> sort :: forall a. (Ord a) => [a] -> [a]
22:07:18 <dons> so a script to ask ghci for types of decls in src has to edit ghci's output
22:08:02 * dons wishes he had some chocolate cake
22:08:04 <dons> @yow
22:08:05 <lambdabot> ... I have read the INSTRUCTIONS ...
22:08:51 <dons> SamB, I have this script at the moment to insert decls automatically. you could adapt it to emacs:
22:08:54 <dons> FILE=$*
22:08:57 <dons> DECL=`cat`
22:08:59 <dons> ID=`echo $DECL | sed 's/^\([^ ]*\).*/\1/'`
22:09:02 <dons> echo ":t $ID" | ghci-6.4 -Onot -v0 -cpp -fglasgow-exts -w $FILE
22:09:04 <dons> echo $DECL
22:09:34 <dons> it takes the file name to look at as a command line arg, and the line containing the top-level decl to type on stdin
22:10:10 <dons> so I no longer write types, I hit 'ty' in vim, and let ghci infer them for me.
22:11:48 * sh10151 ponders implementing awk in haskell
22:11:59 <dons> ! nice idea.
22:12:07 <sh10151> s/in/on/
22:12:15 <dons> as a library.
22:12:24 <sh10151> awklike functions accessible from haskell
22:12:24 <dons> or an interpreter?
22:12:25 <sh10151> yep
22:12:30 <sh10151> not awk awk
22:12:36 <sh10151> kind of like scsh's awk macro
22:12:46 <sh10151> similar DSL/little language
22:12:46 <dons> that'd be fun
22:12:49 <dons> yep.
22:13:04 <dons> or you could write a binding to awk..
22:13:15 <sh10151> that's not nearly as much fun :)
22:13:20 <dons> :}
22:13:36 <sh10151> i actually just discovered awk a few months ago
22:13:49 <sh10151> i like it much better than perl for the stuff I do at work
22:14:32 <dons> it's good for some things. perl is shorter for some others. sometimes sed is better too
22:14:37 <sh10151> and i miss that particular pattern of programming in other languages
22:14:56 <sh10151> well, sed is more of straight-out text manipulation
22:15:05 <sh10151> awk has some actual programmatic meat to it
22:15:08 <sh10151> esp. gawk :)
22:15:30 <dons> sed has control flow, variables, labels, it's turing complete..
22:16:07 <dons> but, yes, awk is a more thought out text editing language
22:16:39 <sh10151> now here's the rub:
22:16:47 <sh10151> awk is a text editing language
22:16:55 <sh10151> but its pattern could be generalized
22:17:32 <sh10151> i think i have heard these things referred to as data flow languages
22:17:44 <sh10151> it's quite similar to the way haskell processes things too
22:17:46 <dons> it's monadic, like sed, and you have pure functions like s///. I think this wouldn't be too hard.
22:17:56 <sh10151> patterns, operations on lazy lists
22:18:15 <dons> so write some pure string functions, and have a top-level monadic loop for getting at input.
22:18:40 <dons> I was writing lambda-sed along these lines
22:19:08 <sh10151> well if nothing else it will let me explore haskell I/O pretty extensively :)
22:46:33 <andrw> hola, hay alguna mujer que quiera hablar
22:47:05 <andrw> vamos, es mejor que estar callados
22:47:27 <andrw> 123 usuarios y nadie dice nada
22:47:44 <andrw> porfavos que estamos haciendo...
22:47:51 <smott> english?
22:48:15 <blackdog> dons: hm, maybe lambdabot needs a babelfish function.
22:48:18 <blackdog> </karmawhore>
22:48:25 <dons> @babel en es hola, hay alguna mujer que quiera hablar
22:48:27 <lambdabot>   hola, quiera del que del mujer del alguna del heno hablar
22:48:31 <dons> @babel e en hola, hay alguna mujer que quiera hablar
22:48:32 <lambdabot> Error: Language e not supported
22:48:35 <dons> @babel es en hola, hay alguna mujer que quiera hablar
22:48:37 <lambdabot>   hello, there is some woman whom she loves to speak
22:48:39 <blackdog> wait, it's got it? man, that's cool.
22:48:57 <dons> babel isn't too clever in translating though.
22:49:18 <dons> but I'm not sure this guy's talking about Haskell..
22:49:27 <andrw> nadie habla espaÒol ?????
22:49:32 <blackdog> @babel es vamos, es mejor que estar callados porfavos que estamos haciendo.
22:49:33 <lambdabot> Error: Language vamos, not supported
22:49:40 <blackdog> @babel es en vamos, es mejor que estar callados porfavos que estamos haciendo.
22:49:42 <lambdabot>   we go, is better than to be shut up porfavos that we are doing.
22:49:47 <dons> @help babel
22:49:48 <lambdabot> usage: babel lang lang phrase
22:50:17 <andrw> hey men, i crazy
22:50:53 <dons> @babel en es I don't think we have any spanish speakers at this time
22:50:55 <lambdabot>   No pienso que tenemos cualquier altavoz espaÒol en este tiempo
22:51:37 <andrw> me voy ???
22:52:00 <dons> no, it's ok.
22:52:23 <andrw> bacano parce, como dice JUANES, se habla espaÒol,,,
22:53:09 <dons> @babel en es Do you have a question about Haskell programming?
22:53:11 <lambdabot>   øUsted tiene una pregunta sobre la programaciÛn de Haskell?
22:53:39 <blackdog> this is so doomed to failure
22:53:42 <dons> hhehe
22:53:53 <dons> at least I got somewhere.
22:53:53 <andrw> si, no se como poner una roon latina
22:54:37 <andrw> hey
22:56:07 <dons> and that is that.
23:07:52 <blackdog> dons: how did you find your latitude and longitude?
23:10:21 <dons> oh, for the wiki?
23:11:14 <dons> I googled for GPS coords for sydney, and found this guy's site where he lists GPS coords of his adventures, including Petersham train station. which is just round the corner ;)
23:15:58 <blackdog> got maroubra, so i guess that has to be close enough. :)
23:28:06 <blackdog> anyone know why ThingsToAvoid on HaWiki is so down on list comprehensions?
23:28:55 <dons> beginners tend to overuse them?
23:29:13 <Cale> blackdog: probably because of Henning Thielemann actually :)
23:29:49 <Cale> and possibly Remi Turk, I'm not sure... there seem to be a few people who are *very* opposed to syntax sugar
23:30:42 <blackdog> that's interesting... i used map, filter and friends almost exclusively for a long time, and only recently started using comprehensions. they seem to make some things clearer, at least to me.
23:31:28 <Cale> they do, in quite a few cases
23:33:17 <Cale> blackdog: you're a go person?
23:33:21 <Cale> :)
23:34:09 <jlouis> funny, I almost never use list comprehensions
23:36:02 <Cale> I use list comprehensions when I start thinking of my lists as sets, and sometimes I'll translate something into list comprehension syntax after writing it with map/filter, and find that (sometimes) it becomes more obvious what it does
23:36:20 <blackdog> Cale: yes. I'm not very good, though - i've only played 2 or 3 times on a real board. the problem is that i'm better than all the people I know in RL, and much, much worse than everyone i play online, so I either don't get any better or get my ego squashed regularly
23:37:26 <blackdog> yes, that's it exactly. If i'm thinking of the ordering of the list as being important, i wouldn't use a list comprehension. not because it doesn't work, just because it doesn't feel right. that might be silly.
23:37:48 <Cale> blackdog: I learned by playing against a 4 dan every day (on a real board) for 8 months or so. :) I know the feeling.
23:38:37 <blackdog> Cale: where do you play? I'm on itsyourturn.com as 'mrak'. it's not too bad...
23:38:38 <jewel> Cale, how strong are you?
23:39:21 <Cale> I'm somewhere in the single digit kyus.
23:39:55 <blackdog> dons: the new and improved lambdabot?
23:39:58 <Cale> I won to a 1-dan on 6 stones, that was some time ago now. I should play more even games.
23:39:58 <jewel> I've been playing for 3 years and I'm close to 1 dan
23:40:51 <Cale> jewel: perhaps we should have a game sometime
23:41:03 <Cale> blackdog: I play on kgs as Cale
23:41:29 <jewel> jewel/tgs004 on kgs
23:41:47 <dons> blackdog: yep! ripped out all the runtime loader stuff, and replaced it with a yi-style boot loader. so the whole bot is now dyn loaded, and a few hundred lines shorter
23:42:06 <dons> so it's all loaded with hs-plugins now, reading .hi files.
23:42:14 <dons> no depends list anywhere.
23:42:40 <dons> the goal is to add @reboot now, which reloads the bot's code, without dropping the connection, like :reboot in yi
23:43:32 <dons> not only are the plugins dyn loaded, the core of the bot is now dyn loaded.
23:43:41 <blackdog> sweet.
23:46:01 <lispy> is the lava source code available?
23:46:10 <lispy> i'm having a hard time tracking it down
23:50:35 <lispy> i heard they had some crazy thing where you could "evaluate" your haskell program (which represents a circuit) and it would generate a low level description that could be used in an FPGA.
23:50:52 <lispy> i wanted to borrow that same technique for compiling a haskell program to a procmail recipe
23:59:25 <Gahhh> you can convert C programs into FPGA's, too
23:59:55 <Gahhh> there are serious commercial software for that kind of stuff
