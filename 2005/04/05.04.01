00:01:52 <aheller> Well, that just made my fortune file.
00:03:39 <dons> sigh. looks like the PosixCompat needs some more work.
00:31:38 <dons> @plugs last [ 1 .. 100000000 ]
00:31:42 <lambdabot> Terminated
00:31:47 <dons> @plugs last [ 1 .. ]
00:31:51 <lambdabot> Terminated
00:31:58 <dons> @plugs head [ 1 .. ]
00:31:59 <lambdabot> 1
00:32:06 <dons> @plugs map foo bar
00:32:07 <lambdabot> bzzt
00:32:34 <dons> Just had to catch the exception. Haskell rules.
00:32:48 <lightstep> howcomes head (sort [1..1000000]) takes much longer (x1.5) than head (sort [1..900000]) ?
00:33:30 <polli> lightstep: you need to go through the whole list
00:33:53 <polli> and I believe that sort uses insertion sort
00:34:01 <dons> it's merge sort, isn't it?
00:34:29 <dons> > Quicksort replaced by mergesort, 14/5/2002.
00:34:29 <lightstep> it grow linearly (300ms/100000elts) until i try a million
00:34:41 <lightstep> i have ghc 6.4
00:34:59 <mflux> cache locality issues?
00:35:22 <dons> there's a decent amount of analysis in $fptools/libraries/base/Data/List.hs:sort, maybe have a look there
00:35:23 <Heffalump> @plugs product [1..]
00:35:28 <lambdabot> Terminated
00:35:34 <lightstep> page faults take 1.5 seconds?
00:36:01 <dons> @help plugs
00:36:02 <lambdabot> @plugs <expr>
00:36:02 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
00:36:04 <mflux> try a profiler?-)
00:36:23 <lightstep> i will
00:37:22 <dons> hmm. a 'time' arg to @plugs would be fun
00:37:35 <dons>  @time-plugs foo
00:37:40 <lightstep> the profiler is so slow
00:39:17 <lightstep> and it makes the performance even more unpredictable
00:39:32 <Heffalump> I'd like to know how much memory I used.
00:39:57 <Heffalump> @plugs scanr (*) 1 [1..]
00:39:59 <lambdabot> Stack space overflow: current size 1048576 bytes.
00:39:59 <lambdabot> Use `+RTS -Ksize' to increase it.
00:40:02 <Heffalump> ahah!
00:40:05 <Heffalump> I win :-)
00:40:22 <dons> :P
00:40:40 <dons> lambdabot lives to fight another day, though.
00:41:51 <det> http://ephemeral.info/sl/401.html
00:43:18 <lightstep> ok, it's either a gc delay, or a ghc anti-benchmark thingy
00:49:32 <lightstep> @plugs sort [1..10000]
00:51:00 * Heffalump pokes lambdabot
00:51:00 <dons> @version
00:51:11 <Heffalump> lightstep wins.
00:51:12 <lightstep> i think it's dead
00:51:28 <Heffalump> is there any limit on the size of the returned vaue?
00:51:42 <lambdabot> Terminated
00:51:45 <lambdabot> Fri Apr  1 17:37:18 EST 2005, GHC 6.4 (OpenBSD i386)
00:51:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:51:49 <shapr> yay
00:52:20 <lightstep> howcomes it answered the questions i asked it before it died?
00:52:34 <shapr> I'd say it got over being dead.
00:52:38 <dons> yeah.
00:52:38 <lightstep> (in pm)
00:53:30 <Itkovian> lightstep: it exists to plase you, therefore death does not obstruct it in its task
00:53:46 <lightstep> does it keep a journal?
00:57:59 <beschmi> how much cpu does gc normally use? when i record a big patch with darcs (initial import of the linux sources) the darcs process seems to hang with 1.5% cpu for a long time
00:58:34 <beschmi> strace only shows mmap2 and another signal related syscall the whole time
00:58:52 <ibid> there's a RTS option to show gcs, iirc
00:59:20 <beschmi> thanks, i'll try that
01:17:01 <nlv11757_> ok help
01:17:03 <nlv11757_>  mbinfo = (struct mbinfo *) malloc (mb_width*mb_height*sizeof(struct mbinfo));
01:17:12 <shapr> Is that Haskell source?
01:17:16 * shapr is amazed
01:17:22 <nlv11757_> is the variable declared here called mbinfo and is it a structure at the same time?
01:17:30 <nlv11757_> no im asking a C question here
01:17:30 <shapr> You've been seriously redefining some operators man!
01:17:34 * nlv11757_ ashamed
01:17:41 <nlv11757_> :P
01:18:18 <lightstep> you only need to define sizeof and struct to numeric functions
01:18:25 <pipe> hey shapr
01:18:44 <shapr> hiya pipe
01:19:02 <pipe> what's up?
01:19:42 <shapr> Hacking on pugs, trying to come up with a typesafe Penrose tile datatype, writing Python for work.
01:19:47 <shapr> What's up with you?
01:20:19 <nlv11757_> is the syntax above defining a variable with the same name as the struct...namely mbinfo?
01:20:25 <nlv11757_> im not sure, since im not such a C guru
01:21:24 <pipe> shapr: i've been recruited into the army
01:21:24 <Itkovian> nlv11757_: if you do not typedef struct mbinfo, then you can use that name as a  variable name
01:21:48 <shapr> Neat, do you get to play with the various Galil models, and maybe a Desert Eagle?
01:21:55 <Itkovian> so yes, you have got a variable named mbinfo whose type is (struct mbinfo*)
01:22:10 <shapr> I've read that the sniper version of the Galil is one of the best standard caliber sniper rifles in the world.
01:22:14 <lightstep> nlv11757_, it's an assignment statement. it allocates enough memory for mb_width*mb_height mbinfo structures, casts it into a pointer to an array of mbinfo structures, and assigns to the variable mbinfo
01:22:25 <dons> @plugs last $ sort [1..100000 ]
01:22:26 <lambdabot> 100000
01:22:32 <dons> @plugs last $ sort [1..1000000 ]
01:22:32 <Itkovian> well now ...
01:22:35 <pipe> shapr: just M16 and grenades
01:22:36 <lambdabot> bzzt
01:22:49 <lightstep> it depends on being able to define struct mbinfo and mbinfo (a variable) separately
01:22:52 <shapr> M16? Aren't you in .il?
01:22:58 <pipe> shapr: yes
01:23:18 <shapr> Strange, I thought the Galil was their standard rifle.
01:23:21 <dons> @plugs [1..]
01:23:30 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
01:23:30 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
01:23:30 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
01:23:30 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
01:23:30 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
01:23:30 <lambdabot> 118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
01:23:32 <lambdabot> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
01:23:33 <pipe> shapr: nope, M16 uzi machine-gun
01:23:34 <lambdabot> [58801 @more lines]
01:23:35 <Itkovian> omfg
01:23:41 <Itkovian> (sigh)
01:24:02 <lightstep> @more
01:24:07 <lambdabot> 154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,
01:24:07 <lambdabot> 172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,
01:24:07 <lambdabot> 190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
01:24:07 <lambdabot> 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,
01:24:07 <lambdabot> 226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,
01:24:07 <lambdabot> 244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,
01:24:09 <lambdabot> 262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,
01:24:11 <lambdabot> [58794 @more lines]
01:24:12 <dons> oh come on.
01:24:18 <wilx> :)0
01:24:24 <nlv11757_> ok lightstep i get it now
01:24:27 <shapr> Well, I guess that shows I spend more time learing Haskell instead of reading up on the military.
01:25:25 <shapr> @info Eq
01:25:26 <lambdabot> Sorry, I don't know the command "info", try "lambdabot: @listcommands"
01:25:30 <dons> the brown out that lightstep found before was a real bug. the 6.4 Posix.popen mapping to System.Process isn't quite perfect yet, and @plugs was idling on a pipe write
01:25:38 <shapr> neat
01:25:42 <dons> dropping back to true Posix.popen fixed it.
01:25:44 <nlv11757_> this is confusing though: "struct mbinfo *mbinfo"
01:25:59 <dons> shapr, you see we have @help now?
01:26:05 <shapr> @help
01:26:06 <lambdabot> @help <command>
01:26:09 <shapr> @help lambdabot
01:26:10 <lambdabot> @help <command>
01:26:16 <shapr> @help help
01:26:17 <lambdabot> @help <command>
01:26:24 <shapr> @help type
01:26:25 <lambdabot> @type: return the type of a value
01:26:25 <wilx> lambdabot, @help
01:26:26 <dons> yeah, come on, try a command ;)
01:26:30 <dons> @help eval
01:26:31 <lambdabot> @eval expr - evaluate the lambda calculus expression, expr
01:26:37 <shapr> @help seen
01:26:38 <wilx> lambdabot: @help
01:26:42 <lambdabot> Report if a user has been seen by the bot
01:26:44 <lambdabot> @help <command>
01:26:46 <shapr> @help plugs
01:26:46 <lambdabot> @plugs <expr>
01:26:48 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
01:26:53 <shapr> @help kind
01:26:54 <lambdabot> @kind: return the kind of a type (GHC)
01:26:58 <shapr> @help echo
01:26:59 <lambdabot> system: irc commands
01:27:03 <shapr> neato
01:27:06 <Itkovian> nlv11757_: I see nothing confusing about it.
01:27:08 <lightstep> @kind Monad
01:27:12 <dons> nah.
01:27:12 <lambdabot> bzzt
01:27:19 <shapr> @help lojban
01:27:19 <lambdabot> I perform dictionary lookups via the following 14 commands:
01:27:19 <lambdabot> @all-dicts .. Query all databases on dict.org
01:27:19 <lambdabot> @devils ..... The Devil's Dictionary
01:27:19 <lambdabot> @easton ..... Easton's 1897 Bible Dictionary
01:27:19 <lambdabot> @elements ... Elements database
01:27:20 <lambdabot> @foldoc ..... The Free On-line Dictionary of Computing
01:27:22 <lambdabot> @gazetteer .. U.S. Gazetteer (1990)
01:27:23 <shapr> yow
01:27:24 <lambdabot> [8 @more lines]
01:27:25 <Itkovian> nlv11757_: but usually one would use struct mbinfo_s as the type name
01:27:31 <dons> @yow
01:27:32 <lambdabot> Prelude.(!!): index too large
01:27:35 <dons> hehe
01:27:36 <shapr> whoops
01:27:38 <dons> @yow
01:27:39 <lambdabot> Prelude.(!!): index too large
01:27:43 <shapr> ok ok
01:27:48 <dons> there's a real bug in the random number code in @yow
01:27:49 <shapr> I'll send in the chooseR patch
01:28:01 <wilx> @version
01:28:02 <lambdabot> Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
01:28:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:28:03 <Itkovian> nlv11757_: and mbinfo_t for the typedef'd struct
01:28:06 <nlv11757_> lightstep, i see a separate definition "struct mbinfo {......}", then i see "struct mbinfo *mbinfo"
01:28:09 <shapr> That's because I didn't know about chooseR at the time.
01:28:20 <dons> okk
01:28:56 <shapr> A lot of the code I wrote was fifteen minute hacks that happened when I should have been working on other stuff.
01:29:01 <lightstep> Itkovian, actually, it's not typedef'ed. a typedef declaration creates a binding in the single-word namespace
01:29:24 <shapr> lambdabot is a lot of fun to hack on.
01:29:25 <Itkovian> lightstep: I never said it was typedef'd?
01:29:40 <lightstep> nlv11757_, it defines a type called `struct mbinfo', and then a variable `mbinfo' of type `struct mbinfo*'
01:29:48 <lightstep> Itkovian, sorry, i misread
01:29:57 <Itkovian> I said that mbinfo could have been a type name iif the code read 'typedef struct mbinfo {} mbinfo'
01:30:11 <lightstep> yes, i see it now
01:30:18 <Itkovian> :-)
01:30:27 <nlv11757_> so what does 'struct mbinfo *mbinfo' does then? cause there is already a 'struct mbinfo {.....}'
01:30:29 <shapr> I like this @help command, this is good stuff!
01:30:42 <dons> lots of hacks! hacks for all!
01:31:04 <dons> we could do with some better help msgs though - some of them I was pretty brief
01:31:07 <dons> @help moo
01:31:08 <lambdabot> vegan-friendly command
01:31:21 <shapr> haha
01:31:38 <lightstep> what does @info do?
01:31:48 <dons> @help info
01:31:52 <lambdabot> @help <command>
01:32:23 <dons> there's no @info now, we had it yesterday for ghci
01:32:25 <lightstep> it doesn't work with typesclasses, types or methods
01:32:28 <dons> but it's too verbose
01:32:35 <Khisanth> nlv11757_: re-read lightstep's replies :)
01:33:14 <Itkovian> nlv11757_: it is a declaration of a variable called mbinfo whose type is 'struct mbinfo*', i.e. a pointer to a 'struct mbinfo'
01:33:17 <Khisanth> nlv11757_: would struct mbinfo* foo look less confusing?
01:33:54 <nlv11757_> awwwww damn, this C syntax is hippycrap
01:33:59 <nlv11757_> thanks a lot all
01:34:06 <shapr> hippycrap?
01:34:06 <nlv11757_> im totally parsing it wrong
01:34:12 <lightstep> it's a shame that people aren't aware of the triple-namespace feature of c++
01:34:15 <Itkovian> nlv11757_: no, it's not. It's very understandable :-)
01:34:23 <shapr> To K&R?
01:34:26 <nlv11757_> C is treehugging business with all due respect
01:34:32 <Itkovian> C is cool.
01:34:34 * shapr snickers
01:34:43 <shapr> I agree.
01:34:46 <nlv11757_> C is cool....hahaha
01:34:48 <Itkovian> with who?
01:34:50 <lightstep> err, c has 3, c++ has 4
01:34:51 <nlv11757_> yeah......right
01:34:58 <shapr> I think C is old and crufty.
01:35:00 <cpage> "triple" namespace? What's the third one?
01:35:02 <Itkovian> ah
01:35:05 <Itkovian> I don't
01:35:11 <lightstep> enum (in c), class (in c++)
01:35:19 <Itkovian> depends on the task at hand imo
01:35:45 <nlv11757_> it may be suitable for a task, but still crappy at best.
01:35:53 <nlv11757_> imho of course :P
01:36:20 <Itkovian> nlv11757_: it built linux.
01:36:24 <lightstep> c has it's beauty. but b has more if it
01:37:08 <nlv11757_> linus built linux
01:37:12 <Itkovian> in C
01:37:22 <Itkovian> whatever.
01:37:39 <Itkovian> I like it, I understand it, I understand it can be error-prone if not used well, so ...
01:38:28 <nlv11757_> your opinion is that everybody that doesn't like it, don't understand it? cause if the did (like you) then they would like it?
01:38:31 <Khisanth> C is not that bad compared to C++ :)
01:38:44 <nlv11757_> Khisanth: i agree with that
01:38:46 <kzm> Hi all.
01:38:56 <kzm> Anybody with some Parsec experience?
01:38:56 <Itkovian> nlv11757_: no, that is not what I meant. I said I like it and it has its merits.
01:39:11 <Itkovian> kzn the parser or the 3d engine?
01:39:27 <kzm> parser (it's Haskell, isn't it :-)
01:40:12 <kzm> I've started using it - always felt that "Monadic Parser Combinators" sounded a bit intimidating for my small and almost-trivial tasks.  How wrong I was - and how easy it is!
01:40:21 <shapr> yay!
01:40:35 <kzm> But I have a small problem which I wonder if anybody have a good trick for.
01:40:41 <shapr> What's the problem?
01:40:47 <nlv11757_> Itkovian: ok, i agree it has its merits; but even then i still hate it. Not because i may not fully understand the monster that is C, but because i find the language crappy.
01:41:17 <shapr> Itkovian: do you think C is better for some tasks than C-- ?
01:41:20 <kzm> The problem is this: I have keywords ending in colon (FOO:) followed by an arbitrary number of words (without colon) supplying the value.
01:41:26 <dons> than C--?
01:41:34 <shapr> Yeah.
01:42:00 <dons> weird question. but C is surely better than a code generation language for some tasks
01:42:06 <kzm> So I want to read all non-colonized words -- I did this with a "try" with a word parser not accepting colon, and <|> string "" to return to the upper level accepting a new keyword.
01:42:11 <dons> not sure what though ;)
01:42:13 <Itkovian> nlv11757_: that's partly because you do not seem to understand its syntax.
01:42:40 <dons> I wouldn't want to write kernel code in C--
01:42:49 <shapr> why not?
01:42:49 <dons> just because it is too low level
01:42:51 * Itkovian doesn't know C--
01:43:00 <kzm> The problem is newlines -- I don't want to cross a newline, but I need newline to be included in the spaces to get the last word on the line.
01:43:08 <dons> it's fancy assembler, really
01:43:17 <shapr> Is that different from C?
01:43:20 <dons> so you get total control of everything
01:43:27 <kzm> (To clarify, the "try"ed word parser looks like "do {w <- word; many1 space; return w}"
01:43:34 <dons> it's lower level than C. let me find an example
01:43:47 <kzm> To ensure that the word ends with space and not :
01:44:07 <nlv11757_> itkovian: maybe the fact that i don't grasp the C syntax at all times is due to the bad syntax
01:44:09 <kzm> Perhaps it woudl be better to go the other way, always try to read a keyword, and fall back if it doesn't work
01:44:18 <kzm> But the performance may suffer.  Oh well - that should work.
01:44:20 <kzm> Thanks.
01:44:22 <kzm> :-)
01:44:22 <dons>  while:
01:44:23 <dons>   if (StgTSO_what_next(R1) == ThreadRelocated::I16) {
01:44:23 <dons>     R1 = StgTSO_link(R1);
01:44:23 <dons>     goto while;
01:44:23 <dons>   }
01:44:26 <Itkovian> nlv11757_: no, it's not. it's because you do not have enough XP in it
01:44:39 <Itkovian> dons: omg
01:44:50 <dons> the types make more sense, but it's too low level when it comes too specifying calling conventions and the like
01:45:20 <shapr> kzm: are you sure you can't get the last word on a line without parsing newline?
01:45:22 <kzm> Ah - the problem then becomes I've consumed the keyword, so I'd need to return it.  Not so good.
01:46:19 <kzm> shapr: I need to check that it's not followed by ':'.  I need a peek function or something, really.
01:46:26 <dons> for example, you distinguish between jump and goto.
01:46:32 <shapr> Isn't there a notFollowedBy function?
01:46:39 <dons> though I guess  C does that too.. hmm.
01:46:59 <dons> data decls are too low-level:
01:47:02 <dons> section "data" {
01:47:02 <dons>     ZCMain_main_closure:
01:47:02 <dons>         const ZCMain_main_info;
01:47:02 <dons>         const 0;
01:47:02 <dons>         const 0;
01:47:02 <kzm> shapr, yes there is.  I'll see if I can use it.
01:47:04 <dons>         const 0;
01:47:07 <dons> }
01:47:22 <dons> put some values in the "data" segment. that's too low level isn't it?
01:47:45 <shapr> dons: I think SPJ said that C is mostly used as cross-platform asm. I agree with him.
01:47:53 <nlv11757_> itkovian: on a syntax level, C is undeniably sick.
01:47:55 <dons> yep, I agree too.
01:47:57 <shapr> But I haven't used enough C to argue one way or the other, that's why my question.
01:48:02 <dons> but you wanted to know the other way, didn't you?
01:48:09 <dons> that C-- could be used as a C?
01:48:24 <dons> C is a superset of C--
01:48:38 <musasabi> not a proper superset.
01:48:47 <dons> no.
01:48:48 <musasabi> C-- has things C lacks.
01:49:00 <dons> i.e. section specifiers
01:49:08 <musasabi> and tail calls :-)
01:49:33 <cpage> C-- is meant to be a portable code-generation language. AFIAA, you're not expected to write C-- programs.
01:49:34 <dons> you can do that in C if you look at the asm ;)
01:49:46 <kzm> shapr: Yes!  Perfect!  Beautiful!
01:49:48 <dons> that's why I thought the question was weird.
01:49:54 <shapr> If C-- is better as cross-platform asm than C, and you have the option to do code generation, why use C?
01:49:57 <kzm> (in other words, that was just the ticket)
01:50:06 <dons> yes!
01:50:07 <shapr> kzm: I have some other cute Parsec tricks you might like.
01:50:12 <cpage> http://www.cminusminus.org/
01:50:22 <dons> but you wouldn't start using C-- for other things than code generation
01:50:42 <shapr> My wonder is whether C is worth using for anything more than code generation.
01:50:47 <kzm> shapr - okay?  URL?
01:51:00 <kzm> (Waitaminute - the Wiki?)
01:51:05 <dons> shapr: yeah, provocative, but probably right.
01:51:21 <musasabi> shapr: for low level code it is the easiest choice.
01:51:46 <shapr> Um, I don't have a collected file of Parsec tricks, but some are istring which does case-insensitive matching, and manyNtoM which does string{n,m} regex-like matching
01:51:49 <wilx> @version
01:51:49 <lightstep> isn't c-- non-free?
01:51:50 <lambdabot> Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
01:51:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:52:13 <musasabi> lightstep: the standard?
01:52:21 <kzm> Anyway, I've ad-hoc'ed parsers in the past (lines/words and friends), but Parsec is really nice - clean, easy, beautiful documentation.  If anybody sees Daan, give him a hug from me.
01:52:43 <lightstep> musasabi, the multi-platform code generator
01:53:00 <shapr> Yeah, Parsec r0xx
01:53:26 <cpage> "non-free"?
01:53:29 <kzm> I'm about to look into Data.Map -- looking forward to it, actually.
01:53:33 <cpage> http://www.cminusminus.org/faq.html
01:54:02 <musasabi> kzm: it is quite nice.
01:54:03 <shapr> kzm: nice Parsec goodies in Peter Simons' hsemail, including a full RFC2822 parser
01:54:11 <shapr> hiya hlafarge
01:55:34 <musasabi> the faq seems to say it is open source.
01:56:53 <shapr> someone just suggested @pugs on #perl6
01:57:03 <dons> hehe
01:57:09 <kzm> Sequences in bioinformatics are often stored in "Fasta format"; very vaguely defined -- in a couple of afternoons, I've working parsers for the most common variants.  (No other tools I know seem to bother parsing more than their home grown variant.)
01:57:13 <dons> but the IO type might be a problem..
01:57:19 * kzm is happy.
01:57:48 <shapr> Yeah, I was wondering how to make perl6 io-safe.
01:58:41 <dons> use Haskell's type system? ;)
02:02:07 <wilx> 11:58 < dons> but the IO type might be a problem..
02:02:10 <wilx> Ooops.
02:02:14 <wilx> Sorry.
02:07:16 <dons> hmm. you could run @pugs inside @plugs, if plugs-internal :: String -> PugsValue
02:07:26 <shapr> hm!
02:07:27 <dons>  @plugs (pugs "some perl")
02:07:44 <dons> and then show will do it's work to print the result of the interpreter
02:08:01 <shapr> I gotta try that.
02:11:43 <jadrian> hi
02:11:46 <shapr> hiya
02:11:55 <jadrian> hi there shapr!
02:12:47 <jadrian> question on terminology
02:12:58 <jadrian> are space leak and memory leak the same?
02:13:29 <shapr> um, not exactly
02:13:37 <jadrian> damn :-|
02:14:02 <jadrian> so memory leak is when you lose pointers to certain memory regions
02:14:04 <jadrian> right?
02:14:10 <shapr> Yeah, that's really for C
02:14:14 <shapr> space leak is unwanted laziness
02:14:15 <jadrian> right...
02:14:16 <jadrian> yeap
02:14:43 <AdmiralFreezbee> I to have a (very newbie) question
02:14:59 <AdmiralFreezbee> I'v got a datastructure data Color = Red | Blue  deriving Show
02:15:50 <AdmiralFreezbee> now I want to implement show in such a way that I can do some kind of pattern matching, when the color is red: I have to print something like ("red color")
02:16:02 <AdmiralFreezbee> I've tried to implement function show but I'm missing something
02:16:28 <AdmiralFreezbee> when I run it in Hugs it says Overlapping instances for class Show
02:16:45 <lightstep> `deriving Show' means that you want the automatic Show instead of your own
02:17:23 <AdmiralFreezbee> oh so just omitting deriving show will do the trick?
02:17:25 <lightstep> you don't need to declare anything on the type declaration to define an instance
02:17:31 <lightstep> yes
02:17:33 <AdmiralFreezbee> thanks!
02:29:31 <Itkovian> AdmiralFreezbee: either you derive from show by using 'deriving (Show)' or you declare your datatype to be an instance of class Show.
02:30:51 <AdmiralFreezbee> and I if I get it right: if I derive from Show all I can use is the automatic show function not a user-defined
02:38:36 <lightstep> yes
02:40:07 <shapr> hoi boegel
02:40:19 <boegel> hey shapr (and everyone else)
02:45:27 <Itkovian> boegel
02:46:03 <AdmiralFreezbee> sorry to bother you again: but I still can't get it to work
02:46:09 <Itkovian> AdmiralFreezbee: are you by any chance one of my students?
02:46:17 <AdmiralFreezbee> yes :-)
02:46:20 <Itkovian> ic.
02:46:29 <Itkovian> what seems to be the problem?
02:46:30 <AdmiralFreezbee> was it that obvious?
02:46:35 <Itkovian> yr from ghent
02:46:48 <Itkovian> and the color stuff gave you away :-)
02:47:08 <AdmiralFreezbee> :-) I tried so hard not to take the Orientation data type
02:47:08 <boegel> Itkovian caught you ! hehe
02:47:19 <Itkovian> you can always post on the minerva forum, with yr code.
02:47:27 <AdmiralFreezbee> Ok I'll do that
02:47:28 <boegel> AdmiralFreezbee: asking questions here means +2 on your project ;)
02:47:28 <AdmiralFreezbee> thanks!
02:47:30 <Itkovian> so what doesn't work here?
02:47:46 <AdmiralFreezbee> Well I want to print my data type Orientation
02:47:51 <Itkovian> yeah boegel, I'll deduct them from your thesis points
02:48:03 <Itkovian> sure.
02:48:14 <AdmiralFreezbee> so that I can use the pretty print method a little bit more efficiently
02:48:21 <Itkovian> ok.
02:48:24 <boegel> Itkovian: :'(
02:48:49 <AdmiralFreezbee> I've written the following
02:48:49 <AdmiralFreezbee> instance Show Orientation where
02:48:49 <AdmiralFreezbee> showsPrec _ Telescope.Left 	= show 'L'
02:48:49 <AdmiralFreezbee> showsPrec _ Telescope.Right	= show 'R'
02:48:49 <AdmiralFreezbee> showsPrec _ Down 			= show 'D'
02:48:49 <AdmiralFreezbee> showsPrec _ Up			= show 'U'
02:49:11 <AdmiralFreezbee> but the problem is when I run show I get a C stack overflow
02:50:48 <Itkovian> AdmiralFreezbee: hmm, afaik showsPrec needs to produce something of the ShowS type
02:50:54 <Itkovian> let me check
02:51:22 <Itkovian> and that means you should not use plain 'show' on the RHS iirc
02:54:15 <Itkovian> hang on ...
02:56:55 <Itkovian> AdmiralFreezbee: use 'shows' instead of show in the RHS
02:57:22 <Itkovian> "'L'"
02:57:25 <Itkovian> ouch
03:02:11 <nlv11757_> hahah lol itkovian recognized his own exercise :D
03:02:24 <nlv11757_> or did admiral know this upfront
03:12:04 <wilx> lamb, @help
03:12:04 <lamb> @help <command>
03:12:06 <lambdabot> @help <command>
03:12:06 <lamb> @help <command>
03:12:07 <lambdabot> @help <command>
03:12:08 <lamb> @help <command>
03:12:09 <lambdabot> @help <command>
03:12:10 <lamb> @help <command>
03:12:10 <lambdabot> @help <command>
03:12:11 <lamb> @help <command>
03:12:12 <lambdabot> @help <command>
03:12:12 <wilx> Omg
03:12:13 <lamb> @help <command>
03:12:14 <lambdabot> @help <command>
03:12:15 <wilx> Sorry.
03:12:47 * boegel slaps wilx on his bare bottom
03:13:11 <wilx> Eeek!
03:13:20 <wilx> lambdabot: @help
03:13:20 <lambdabot> @help <command>
03:13:23 <wilx> lambdabot, @help
03:13:32 <wilx> Oh.
03:13:34 <wilx> I see...
03:15:33 <boegel> @def max
03:15:34 <lambdabot> Sorry, I don't know the command "def", try "lambdabot: @listcommands"
03:15:36 * Itkovian hands boegel the bamboo
03:15:42 <Itkovian> for efficiency ...
03:15:46 <boegel> :D
03:16:20 <boegel> can I ask lambdabot for the definition of a simple Prelude function ?
03:16:53 <Itkovian> @type map
03:16:54 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
03:16:58 <Itkovian> like this?
03:17:21 * Itkovian is brwosing the lamdabot code
03:17:32 <Itkovian> and finds he is sorely lacking knowledge
03:17:55 <lightstep> where is the repository?
03:18:02 <boegel> Itkovian: no, I want the definition of a function, not just the type
03:18:31 <Itkovian> boegel: as in the API docs
03:18:48 <Itkovian> @version
03:18:49 <lambdabot> Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
03:18:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:19:07 <Itkovian> boegel: if it isn't there, it can be written, no?
03:19:21 <Itkovian> maybe a good test-case to polish our skills
03:19:59 * Itkovian is going to test enenmy territory on his shiny new FX5200
03:20:21 * boegel would like to join Itkovian
03:21:03 * shapr hops
03:22:27 * boegel is off
03:23:56 <shapr> salut antonix
03:24:06 <antonix> salut
03:24:41 <antonix> shapr: je suis là en curieux, enfin pour l'instant
03:24:55 <Itkovian> dons: is the feature boegel requested present in some form in lambdabot?
03:24:56 <shapr> c'est chouette :-)
03:25:20 <shapr> antonix: want to see the HaskellDemo?
03:25:38 <antonix> shapr: ok
03:25:41 <shapr> @wiki HaskellDemo
03:25:42 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
03:25:59 <shapr> Do you have experience with other functional programming languages?
03:26:14 <shapr> Caml seems popular in France.
03:26:36 <wilx> lamb, @type map
03:26:37 <lamb> map :: forall b a. (a -> b) -> [a] -> [b]
03:26:42 <wilx> lambdabot, @type map
03:26:42 <lamb> Sorry, I'm not a very smart bot yet, try "lamb: @listcommands"
03:26:43 <antonix> not at all, but it seems to be very efficient for signal traitement
03:26:45 <wilx> So.
03:26:58 <shapr> It can be, there are DSP libraries for Haskell.
03:27:13 <shapr> There are also dataflow libraries like Yampa.
03:27:22 <shapr> It depends on what kind of signal you want.
03:27:24 <antonix> and that is taht we want to do
03:27:31 <nlv11757_> I always thought signal processing is typical C stuff
03:27:34 <antonix> video signal
03:27:58 <antonix> chromatic traitment
03:28:00 <shapr> These are the DSP libraries I've seen - http://haskelldsp.sourceforge.net/
03:29:33 <wilx> dons, I've sent you patch that makes lambdabot react on [,.] too after its name.
03:29:57 <Itkovian> wilx can you add : to that?
03:30:17 <wilx> lamb: @type map
03:30:18 <lamb> map :: forall b a. (a -> b) -> [a] -> [b]
03:30:19 <shapr> antonix: For speed of execution, those libraries are wrappers around C libraries. For speed of development, I like Haskell.
03:30:21 <wilx> It is there.
03:30:54 <Itkovian> ah, I thought you just added [,.] to [] :-)
03:30:56 <wilx> I hope that using Text.Regex is ok.
03:31:29 <shapr> antonix: Are you doing video processing for your company? or for a school project?
03:32:37 <antonix> sharp: We don't need speed of execution, just facilities of devellopement. this is for an associative action
03:32:48 <shapr> For general #haskell consumption these urls just hit the pragprog list - http://www.cenqua.com/commentator/ and http://www.cenqua.com/pairon/
03:32:59 <shapr> Those urls are worth seeing.
03:34:31 <antonix> shapr: thanks
03:34:41 <shapr> antonix: I get easy development with Haskell. But it will take some time for imperative or procedural programmers to learn functional programming.
03:34:53 <shapr> I believe it's faster, but you should try it for yourself.
03:35:15 <shapr> If you have more questions, I'll do my best to answer.
03:36:35 <antonix> shapr: i'm a virgin in this! to me, the first language i'll get will be the best
03:36:44 <antonix> shapr:  ;)
03:36:50 * shapr laughs
03:37:48 <shapr> Learn Haskell! It's great!
03:38:56 * JaffaCake laughs at the PairOn
03:40:03 <nlv11757_> lol is that pairon for real?
03:40:24 * JaffaCake stares at nlv11757_
03:40:33 <shapr> nlv11757_: do you know the date?
03:41:12 <nlv11757_> i dont
03:41:27 <shapr> @timein brussels
03:41:27 <lamb> Sorry, I don't know the command "timein", try "lamb: @listcommands"
03:41:29 <lambdabot>   Friday, April 1, 2005 at 1:42:29 PM CEST
03:41:35 <dons> wilx: emailed? haven't received it yet.
03:41:40 <nlv11757_> owwwww right
03:42:02 <nlv11757_> my feeling for days/time/dates are a bit off since i started doing my thesis hehehe
03:43:54 <wilx> Hmm, I used darcs send.
03:44:26 <Igloo> JaffaCake: If an interface file shows "Worker: $wshift4 2" rather than "Unfolding: [...]", does that mean it was judged too large to be inlined?
03:45:23 <JaffaCake> if it has a worker, it is probably just a wrapper (the unfolding  is implicit)
03:47:05 <nlv11757_> darn, thinking back...i think i didnt get a bunch of other pranks as well. lmao :D
03:48:47 <Igloo> OK, thanks
03:51:19 <shapr> JaffaCake: so, what do you think about porting GHC to the hOp operating system?
03:51:44 <shapr> Maybe I should put more thought into my April 1st jokes...
03:51:45 <JaffaCake> hmm, isn't that a bit premature?
03:52:01 <JaffaCake> would be neat, though
03:52:04 <shapr> Well, GHC is hOp, so...
03:52:25 <shapr> Are any of the C-- compilers written in Haskell?
03:52:37 <JaffaCake> nope, QC-- is in Ocaml
03:53:38 <JaffaCake> unless you count GHC as a C-- compiler, which it sort-of is
03:54:10 <shapr> hmm
03:55:24 <Itkovian> shapr: lambdabot koos for /package.conf when it starts ... is this thing post 6.4 stuff?
03:55:30 <Itkovian> s/koos/looks/
03:55:53 <Itkovian> it doesn't seem to inject ghcLibraryPath correctly
03:56:02 <shapr> Itkovian: maybe you're using the old repo?
03:56:09 <shapr> I gotta ripout the old repo...
03:56:19 <Itkovian> Prelude GHCLibraryPath> ghcLibraryPath
03:56:19 <Itkovian> "/"
03:56:28 <Itkovian> I used the @version stuff
03:56:39 <Itkovian> I am using 6.2.2 tho
03:57:19 <shapr> oh
03:57:28 <dons> Itkovian: you got the latest patches?
03:57:34 <shapr> The @version stuff should be the latest. Did you darcs pull?
03:58:29 <dons> 6.2.2 is supported, btw.
03:58:33 <dons> @version
03:58:34 <lambdabot> Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
03:58:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:02:29 <Itkovian> I did darcs get, which amounts to the same the first time afaik
04:02:47 <shapr> hiya metaperl
04:03:02 <dons> from my repo, or shaprs?
04:03:06 <metaperl> hi shapr: pugs on Scanned? maybe learn Perl 6 instead
04:03:09 <Itkovian> dons: from yours
04:03:21 <shapr> metaperl: huh?
04:03:21 <Itkovian> let me check to make sure
04:03:42 <Itkovian> http://www.cse.unsw.edu.au/~dons/lambdabot
04:04:04 <dons> the relevant code is in SystemModuleNaming.hs
04:04:05 <Itkovian> It seemed an excellent tinkering thing for a Friday afternoon ...
04:04:11 <dons> yeah :)
04:04:59 <Itkovian> dons: yeah, but ghcLibraryPath returns "/" instead of the more l33t /opt/ghc/lib/ghc-6.2/
04:05:13 <lightstep> are files without a `module' declaration assumed to be in module Main?
04:05:36 <Itkovian> well, I'll be damned. I thought I emerge 6.2.2
04:05:40 <Itkovian> d
04:05:55 <dons> which means what? you have some other ghc?
04:05:58 <shapr> Is today Friday?
04:06:02 <shapr> huh, so it is.
04:06:16 <Itkovian> 6.2
04:06:23 <Itkovian> instead of 6.2.2, which I assumed.
04:06:31 <Itkovian> 6.2.2 is apparently on the machine at home
04:06:42 <Itkovian> let's see how fast this baby can compile 6.2.2
04:06:43 <dons> shouldn't make a difference - but I'm not sure. perhaps there is something I don't know about.
04:06:55 <Itkovian> at least it should return the correct path
04:06:58 <Itkovian> and not "/"
04:07:02 <dons> yeah
04:07:23 <Itkovian> Is there a random thing in lamdabot?
04:07:25 <dons> oh, that's hard coded.
04:07:28 <Itkovian> as in flipping a coin
04:07:35 <dons> (the path)
04:07:42 <Itkovian> well, then it's wrong :-)
04:07:48 <dons> not hardcode (I'm sleepy) -- generated
04:07:57 <dons> GHCLibraryPath.hs: GHCLibraryPath.hs.in
04:07:58 <dons>         @sed -e"s,@GHC_LIB_PATH@,`$(GHC) --print-libdir`," < $< > $@
04:07:59 <Itkovian> maybe kosmikus knows something about the gentoo config
04:08:13 <Itkovian> hmm
04:08:28 <shapr> \x: hiya
04:08:36 <\x> Hi
04:08:37 <Itkovian> ageorges@kweekvijver ~/downloads/lambdabot/lambdabot $ ghc --print-libdir
04:08:37 <Itkovian> /opt/ghc/lib/ghc-6.2
04:08:59 <dons> make distclean ; autoconf ; ./configure ; make GHCLibraryPath.hs
04:09:28 <dons> seems not too hard to fix. what's actually in the GHCLibraryPath.hs file atm?
04:09:32 <dons> just "/" ?
04:09:33 <Itkovian> erm
04:10:13 <Itkovian> ghcLibraryPath :: [Char]
04:10:13 <Itkovian> ghcLibraryPath = "/"
04:10:17 <Itkovian> yeah
04:10:23 <dons> now how did that get in there?
04:10:26 <Itkovian> i did the autoconf ... sequence
04:10:34 <Itkovian> I've no bloody idea
04:10:36 <Itkovian> let me check
04:11:03 <dons> gee Handles can be fiddly. esp when connected to networks.
04:11:50 <Itkovian> hmmm ... a lazy sniffer
04:14:00 <shapr> yow
04:15:35 * shapr throws lambdas
04:15:48 <shapr> rik: code?
04:15:53 <shapr> rik: want to work on perl6 =)
04:15:57 <shapr> hiya nibro
04:16:03 <nibro> hi :)
04:16:05 <lightstep> it seems every haskell project has a 6.4-Map/6.2-FiniteMap compatibility module
04:16:06 <shapr> vad händer?
04:16:15 <dons> do they?
04:16:31 <lightstep> yes
04:16:33 <dons> hs-plugins/yi/lambdabot have the same one.
04:16:38 <dons> who else?
04:16:40 <shapr> castaway on #perl6 just pasted - http://www.ietf.org/rfc/rfc4042.txt
04:17:19 <dons> "First cut at the x86_64 native code generator." yay!
04:17:51 <shapr> That RFC is from today, UTF-9 for the PDP-10 and other 36-bit word machines.
04:18:07 <lightstep> dons: pugs
04:18:10 <JaffaCake> :)
04:19:15 <shapr> oh there's more - http://www.ietf.org/rfc/rfc4041.txt
04:22:19 <Itkovian> dons: somehow a second run did the trick
04:22:24 <Itkovian> don;t ask why or how
04:22:29 <dons> :}
04:22:32 <Itkovian> ghcLibraryPath = "/opt/ghc/lib/ghc-6.2/"
04:22:39 <Itkovian> thx
04:22:39 <dons> cool.
04:22:43 <nibro> I'd be interested in that advertised cabalized HSQL lib, where can I get it?
04:23:04 <dons> never underestimate the power of 'make clean' :)
04:23:39 <shapr> jag har ingen aning.
04:24:25 <shapr> Wait, I think CosmicRay was working on that?
04:24:49 <nibro> dons: any chances of a cabalized hs-plugins? =)
04:25:26 <dons> replace the build system?
04:26:02 <dons> I'm only just learning Cabal, so eventually. I'll put it on the todo list
04:26:20 <dons> do you need it badly?
04:26:39 <nibro> well, not really, but I badly need hs-plugins to work with 6.4
04:26:44 <dons> oh it does!
04:26:49 <dons> grab the cvs snapshot :)
04:27:17 <nibro> ah, so then it must be half cabalized in any case..?
04:27:32 <nibro> with the new package-conf stuff...
04:27:36 <dons> well, it can read all the appropriate package.confs, and uses some Distribute.* stuff
04:27:58 <dons> so half-cabalised, yep :)
04:27:58 <nibro> nice =)
04:28:00 <Itkovian> hmm ..
04:28:01 <Itkovian> GHCi runtime linker: warning: looks like you're trying to load the
04:28:01 <Itkovian> same object file twice:
04:28:01 <Itkovian>    Map.o
04:28:05 <Itkovian> dang
04:28:15 <dons> ah! you need 6.2.2
04:28:29 <Itkovian> it's emerging
04:28:51 <Itkovian> ah well, back to JikesRVM on PowerPC it is then
04:28:57 <dons> yikes!
04:30:47 <Itkovian> no, jikes ;-)
04:41:58 <halcyon10> hi
04:42:50 <df_> 7
04:42:53 <halcyon10> can someone tell me how to make this function pointfree ? convolute u v = map (\x->(fst x) + (snd x)) (zip u v)
04:43:37 <Itkovian> use @pointsfree?
04:43:39 <dons> @pointless \u v -> map (\x->(fst x) + (snd x)) (zip u v)
04:43:40 <lambdabot> (map (uncurry (+)) .) . zip
04:43:44 <dons> hehe
04:43:44 <Itkovian> ah pointless
04:44:05 <dons>  @pointless is so cool
04:44:09 <Itkovian> it is.
04:44:14 <halcyon10> oh, i think i need a bit time to understand that function =)
04:44:43 <nlv11757_> why do you zip the elements to pull them apart using + ?
04:45:16 <nlv11757_> convolute = zipWith (+)
04:45:19 <nlv11757_> isnt that the same?
04:45:47 <araujo> Good morning.
04:45:50 <shapr> y0
04:45:54 <halcyon10> i couldn't come up with a different idea. I don't know the Prelude-functions very well yet, so that was my attempt
04:46:06 <nlv11757_> @type zipWith
04:46:07 <lambdabot> zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
04:46:15 <halcyon10> ah, so zipWith is what i need, that's good
04:48:08 <dons> anyone ever built ghc on interix?
04:48:17 <shapr> ves: greetings, looking for Haskell info?
04:48:30 <JaffaCake> oh no, Gmail has added fonts & colors
04:48:40 <ves> hi, yeah just checking this place out
04:48:56 <shapr> ves: do you want to learn Haskell? or looking for other users?
04:49:14 <shapr> Or just curious about Haskell itself?
04:49:20 <Itkovian> hehe
04:49:30 <JaffaCake> dons: not that I'm aware of
04:49:31 <Itkovian> somebody is about to receive a thorough intro me thinks
04:49:39 <shapr> Itkovian: am I so predictable? =)
04:49:41 <ves> I'm studying it in uni, I'm just looking about :)
04:49:55 <Itkovian> shapr: boegel told me you did that to one of my students ;-)
04:50:04 <shapr> ves: Ok, if you have any questions, feel free to ask.
04:50:06 <Itkovian> shapr: ever considered teaching full-time?
04:50:10 <shapr> hmm
04:50:14 <ves> sure, thank you
04:50:26 <dons> JaffaCake: ok.
04:50:41 <shapr> Itkovian: I enjoy teaching, but doing it for money would mean I'd have to do it consistently.
04:51:06 <shapr> Here on #haskell I can just teach when I feel like it.
04:51:29 <shapr> And I only  teach stuff that I'm already interested in.
04:51:41 <JaffaCake> interix would perhaps be difficult, because you can't use the Win32 subsystem from interix processes (I believe)
04:52:40 <dons> hmm. I've got an email from a guy at my uni attempting it.
04:52:43 <boegel> @senn samc
04:52:44 <lambdabot> Sorry, I don't know the command "senn", try "lambdabot: @listcommands"
04:52:49 <boegel> @seen samc
04:52:49 <lambdabot> I haven't seen samc
04:53:01 <dons> seems to have got the .hc build done with 6.4, but dies at
04:53:02 <dons> ghc-6.4: internal error: gen_map_mblocks: munmap failed
04:53:09 <dons> not sure of any other details.
04:53:20 <shapr> I used to teach the other programmers at my last job, but I stopped doing it when one of them said "You know, I don't really want you to teach me how to do this, I just want you to do it for me so I can go home."
04:53:36 <dons> and is interix based on openbsd? or just the userland?
04:54:38 <Itkovian> shapr: you should know by now that CS people are inherently lazy
04:55:13 <shapr> If I'm going to put the effort to teach something to someone, I expect them to put in the effort to learn it.
04:56:12 * halcyon10 agrees
04:56:12 <dons> hmm. MBlock stuff has been pretty easy to fix in the past, maybe this is doable.
04:56:34 <shapr> imho, true *long-term* laziness/selfishness means you put in lots of effort at the beginning. That way you put in the least amount of effort overall.
04:57:01 <wilx> Bah.
04:57:32 <wilx> How can anybody use sendmail as their MTA?
04:57:44 <wilx> It is freaking impossible to configure :/
04:58:07 <shapr> I'm lazy/selfish, I want to use programming languages that cost me the least amount of time to reach my clients' goals.
04:58:12 <Lemmih> wilx: I second that.
04:58:20 <shapr> So I selfishly put a lot of effort and energy into #haskell, the wiki, etc
04:58:22 <Lemmih> Anyone got a Language.Haskell.TH.Syntax.Dec pretty printer which outputs valid Haskell?
04:58:59 <Igloo> If the TH one doesn't then it's a bug
04:59:53 <JaffaCake> dons: it's possible interix doesn't support munmap
05:00:15 <dons> ok. he's offered me access to the box, i'll take a closer look.
05:00:27 * dons hopes there are man pages somewhere
05:00:33 * Lemmih compiles a bug report.
05:00:45 <shapr> Itkovian: So I think true laziness is where the student sucks up every word and learns the lesson right the first time. Then the student gets to go home early every day after that.
05:00:48 <JaffaCake> I believe the userland is a mix of BSD and GNU bits
05:01:02 <dons> :/
05:01:04 <Itkovian> shapr: right on!
05:01:30 <Itkovian> hmm, what's wrong with this:
05:01:41 <Itkovian>       3 instance Show Color where
05:01:41 <Itkovian>       4 showsPrec _ Blue = showString "B"
05:01:41 <Itkovian>       5 showsPrec _ Red  = showString "R"
05:01:42 <shapr> This also why I get irritated at people who think that PHP is good for writing desktop applications.
05:01:42 <dons> well, it might be ok. esp. if he already got the .hc build going somewhat.
05:02:06 <dons> desktop apps!
05:02:22 <shapr> Yes, sadly PHP is gaining popularity in desktop apps.
05:02:22 <Itkovian> Color is defined as data Color = Blue | Red, but show Red gives a segfault in hugs and a stack overflow in ghci
05:02:43 <Igloo> Itkovian: Lines 4 and 5 need to be more indented than 3
05:02:52 <Itkovian> ideed
05:02:53 <Itkovian> dang
05:02:58 <Itkovian> student code :-) grrr
05:03:02 <dons> wilx: mail problems?
05:03:09 <dons> the patch hasn't come through yet.
05:03:14 <JaffaCake> dons: yes, I guess for interix you just pretend it's a Unix environment, rather than a mixture of Unix/Win32 which the mingw32 port does
05:03:24 * Itkovian slaps himself with a large trout
05:03:34 <dons> JaffaCake: that's sounds a bit nicer.
05:03:58 <JaffaCake> but it means you can't use that compiler to build Win32 apps
05:04:34 <Janni> Hi.
05:04:37 <Lemmih> Hey Janni.
05:04:50 <Janni> Once again I'm back to Haskell. And struggeling with FFI...
05:04:58 <dons> JaffaCake: ok.
05:05:22 <Janni> Does anybody know, how to deal with unions/structs in C?
05:05:59 <lightstep> wrappers?
05:06:34 <Janni> A function for every member of the structure?
05:07:48 <lightstep> there are preprocessors, eg. haskell.org/greencard
05:07:53 <Lemmih> Or unmarshal the struct to a Haskell data type.
05:08:47 <JaffaCake> Janni: one option is to write an instance of Storable for your struct
05:09:43 * Janni is trying to figure these things out...
05:09:50 <dons> JaffaCake: seen the new bot?
05:09:51 <dons> @plugs let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 fibs
05:09:52 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
05:10:21 <JaffaCake> hmm, it runs plugs, not GHCi?
05:10:45 <lightstep> @plugs unsafePerformIO (return 42)
05:10:46 <lambdabot> bzzt
05:10:49 <dons> plugs, with a wrapper to prevent IO ;)
05:10:59 <dons> and restrict the module namespace
05:11:00 <JaffaCake> ah right
05:11:05 <dons> and limit it to 3 secs
05:11:31 <lightstep> how does it prevent io? does it check every subexpression?
05:11:44 <JaffaCake> what modules are allowed?
05:11:56 <dons> Prelude, and some Data.*
05:12:02 <dons> @plugs let loop () = loop () in loop () :: ()
05:12:06 <lambdabot> bzzt
05:12:17 <JaffaCake> does it have -fglasgow-exts turned on?
05:12:19 <lightstep> @plugs List.sort [1,3,2]
05:12:21 <lambdabot> [1,2,3]
05:12:26 <dons> it does.
05:12:37 <dons> there's a Show constraint as well
05:12:57 <JaffaCake> @plugs GHC.Exts.I# 1#
05:12:57 <lambdabot> bzzt
05:13:03 <dons> no no no.
05:13:15 <JaffaCake> no GHC.* then :(
05:13:21 <dons> nope. sorry ;)
05:13:31 <dons> don't want unsafeCoerce# sneaking through
05:13:38 * JaffaCake tries to think of ways to do IO
05:25:15 <Janni> Is it correct, that all the libraries/packages don't work with GHC anymore, because with 6.4 it changed to Cobol?
05:25:59 <Janni> s/Cobol/Cabal :)
05:26:10 <Lemmih> Yep.
05:26:16 <dons> oh, I thought it was an April 1 joke.
05:26:28 <Lemmih> But it's worth it. Cabal kicks ass.
05:26:31 <dons> GHC switches to Cobol, ditches C backend
05:26:54 <Janni> Hmm. The authors of the packages are quite slow updating.
05:27:02 <shapr> hii Janni!
05:27:11 <Janni> Maybe I should work this Cabal stuff out.
05:27:16 <Janni> And send in patches
05:27:21 <Janni> shapr: Hi.
05:28:09 <dons> wilx: patch arrived :)
05:28:16 <Janni> Oh. Hugs supports Cabal too...
05:28:37 <wilx> OMG!!!
05:28:48 <wilx> I have beaten the Sendmail!
05:28:49 <dons> hehe
05:29:05 <dons> @karma+ wilx
05:29:06 <lambdabot> wilx's karma has been incremented.
05:29:10 <wilx> :)
05:29:54 <lightstep> i never got to section 2 in the proposal
05:30:23 <shapr> aha, I found the logs where Darius cracked the @ghci plugin from long ago.
05:30:37 <dons> ah!
05:30:41 <Janni> Should I begin patching (and then using) greencard or c2hs? Never used one of them...
05:30:53 <shapr> http://www.scannedinavian.org/~shae/joyXlogs.txt
05:30:57 <jlouis> Janni: I prefer c2hs
05:31:27 <Janni> This is a poll. I will do the one, that's most wanted.
05:31:41 <shapr> dons: it includes such gems as "@ghci $( Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") [| putStr "heya" |] )"
05:32:00 <shapr> c2hs!
05:32:01 <dons> yeah, I was thinking about that.
05:32:11 <dons> maybe turning off -fglasgow-exts is wise..
05:33:08 <Janni> So, the poll results are 1:0 for c2hs. That's 100%. I think that's clear cut.
05:33:20 <shapr> yay c2hs!
05:33:32 <JaffaCake> hsc2hs :P
05:33:49 <shapr> JaffaCake: did you write hsc2hs?
05:33:54 <dons> I use hsc2hs too.
05:33:55 <JaffaCake> no
05:34:11 <dons> though my supervisor wrote c2hs, so maybe that's a conflict of interest
05:34:54 <JaffaCake> hsc2hs doesn't do as much as c2hs, but it has greater power-to-weight ratio
05:35:04 <Philippa> @pugs $( Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") [| putStr "heya" |] )
05:35:04 <lambdabot> Sorry, I don't know the command "pugs", try "lambdabot: @listcommands"
05:35:09 <Philippa> @plugs $( Language.Haskell.THSyntax.appE (Language.Haskell.THSyntax.varE $ "GHC.I"++"OBase:unsafePerformI"++"O") [| putStr "heya" |] )
05:35:10 <lambdabot> bzzt
05:35:11 <Philippa> (d'oh)
05:35:28 <dons> hmm.
05:35:34 <shapr> @type $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
05:35:35 <lambdabot> bzzt
05:35:38 <dons> @plugs $( [| 1 |] )
05:35:40 <lambdabot> 1
05:35:43 <dons> :/
05:35:46 <shapr> dons: ouch!
05:36:16 <shapr> @plugs $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
05:36:17 <lambdabot> bzzt
05:37:44 <shapr> @plugs $( Language.Haskell.THSyntax.runQ (putStr "heya") >> [| 3 |] )
05:37:45 <lambdabot> bzzt
05:37:52 <shapr> Maybe I should try this in a query
05:38:05 * shapr goes back to the old fallback, #joy
05:38:29 <JaffaCake> @type "xxx"#
05:38:30 <lambdabot> "xxx"# :: GHC.Prim.Addr#
05:38:33 <shapr> yow!
05:38:51 <Philippa> sure, but can you do anything with it?
05:38:52 <JaffaCake> now what can we do with that...
05:38:55 <dons> that's pretty nasty
05:39:09 <dons> s/pretty/very very/
05:39:20 <Philippa> GHC.*'s out of scope, so even if you can create it as a literal I imagine you can't do anything?
05:39:30 <shapr> Hal Daume pointed out a very special where a GHC extension causes an HM typecheck to do something like the Y combinator. I can't remember details, but I know it's there.
05:40:03 <Philippa> shapr: would imagine that just times out though?
05:40:03 <shapr> I think the response on the ghc-users list was "don't do that"
05:40:07 <Philippa> heh
05:40:41 <JaffaCake> you can cause the simplifier to go into a loop, maybe that's what you were thinking of?
05:40:53 <shapr> Maybe so.
05:41:01 <dons> @plugs $( [| 1 |] )
05:41:02 <lambdabot> <Plugins.Eval>:1: parse error on input `$'
05:41:06 <dons> hehe
05:41:09 <shapr> smart!
05:41:24 <JaffaCake> you turned off extensions? or just -fno-th?
05:41:37 <dons> I turned the lot off :}
05:41:51 <dons> though I could be convinced to reenable things selectively I think
05:42:14 <JaffaCake> there's gotta be a buffer overflow in ghc somewhere :)
05:42:20 <wilx> :)
05:42:35 <shapr> Would be fun to find. I wish I could figure out how to do IO stuff with QuickCheckM
05:42:46 <shapr> That would find a few bugs, I'm sure.
05:42:48 <dons> I want to be able to sleep tonight. Wondering if JaffaCake has hacked my machine yet won't help that.
05:42:52 * shapr laughs
05:42:59 <JaffaCake> lol
05:43:19 <shapr> On the good side, he's nice enough that he'll politely shutdown your machine so it won't be a risk.
05:43:23 <TheHunter> is it possible to do newtype declarations with @plugs?
05:43:30 <dons> nope
05:43:54 <shapr> At least, I hope he's that nice.
05:43:55 <dons> you've got the body of: let v = ... in v to play with.
05:44:32 <TheHunter> that is good cause otherwise unsafeCoerce could sneak back in through Data.Typeable.
05:44:55 <dons> yeah, I was worried about that.
05:45:13 <dons> string representations of types are a little dicey when you can derive them yourself
05:45:33 <TheHunter> and if MonadIO was in scope, IO could be done through TH...
05:45:50 <Igloo> Does anyone know how I can convince xmltex to process users_guide.fo?
05:46:05 <Igloo> (short of renaming it)
05:46:56 <JaffaCake> no, I couldn't get it to work
05:47:13 <JaffaCake> took me a whole morning to get fop to work, too
05:47:21 <TheHunter> @plugs listArray (minBound::Int,maxBound) (repeat 0)
05:47:23 <lambdabot> bzzt
05:47:36 <Igloo> :-/
05:48:13 <wilx> :)
05:48:17 <JaffaCake> don't worry, the printed output looks crappy anyway ;)
05:48:48 * Itkovian has ordered a powerbook. rejoice!
05:48:50 <wilx> @plugs Data.Array.listArray (minBound::Int,maxBound) (repeat 0)
05:48:51 <lambdabot> bzzt
05:48:58 <shapr> JaffaCake: hey would you take a Haddock patch that dumps name.haddock into Map files via show?
05:49:14 <dons> paprika$ ghci
05:49:15 <dons> Prelude> Data.Array.listArray (minBound::Int,maxBound) (repeat 0)
05:49:15 <dons> array (-2147483648,2147483647) [(-2147483648,zsh: segmentation fault (core dumped)  ghci -v0
05:49:29 <shapr> the former lambdabot had an @index command that turned name.haddock files into a FiniteMap so you could search for any name.
05:49:32 <JaffaCake> into Map files?
05:49:34 <wilx> Whee.
05:49:37 <wilx> Same here.
05:49:52 <JaffaCake> oh right - sure
05:50:25 <shapr> I could likely munge that into haskell-doc.el output as well.
05:50:27 <JaffaCake> dons: that bug is in sourceforge, I believe
05:50:31 <TheHunter> i'm sure you can exploit that if you're determined enough...
05:50:33 <dons> ok.
05:51:05 <dons> it's probably easier to attack lambdabot directly if we wanted to go that hard
05:52:11 <Itkovian> @seen kosmikus
05:52:12 <lambdabot> kosmikus is in #haskell. I don't know when kosmikus last spoke.
05:52:22 <wilx> @seen wilx
05:52:22 <lambdabot> wilx is in #haskell. Last spoke just now.
05:52:25 <wilx> :)
05:52:32 <TheHunter> @seen wilx
05:52:33 <Itkovian> anybody any idea why o why darcs requires xorg to be emerged?
05:52:33 <lambdabot> wilx is in #haskell. Last spoke 8 seconds ago.
05:54:38 <Itkovian> ok, forget that. why ghc needs xorg
05:55:01 <Itkovian> it's a bloody server machine, not a desktop ...
05:55:02 <Itkovian> :-(
05:55:31 * dons -> time for sleep.
05:55:42 <TheHunter> good night
05:55:59 <araujo> Itkovian, emerge -pv ghc
05:56:01 <wilx> Hmm, GHC has X11 bindings, can't you -nox11 or somethign?
05:56:01 <araujo> and see what you get
05:56:11 <araujo> i think you are emerging with opengl
05:56:24 <araujo> in that case, just do, -opengl
05:56:31 <Itkovian> araujo: yeah, i dropped opengl and X
05:56:38 <skew> Itkovian: try taking x out of the USE flags, at least for ghc
05:56:42 <Itkovian> there still is something amiss though.
05:56:50 <araujo> Itkovian, building with doc?
05:57:12 <araujo> what you get with -pv?
05:57:18 <Itkovian> when I emerge -pv plain ands simple it needs ghc-bin-5.04, but when I drop both X and opengl it suddenly doesn't need a bin ghc for 6.2
05:57:35 <Itkovian> anyway, I'm fetching 5.04 bin first ...
05:57:46 <Itkovian> I'm on powerpc atm
05:58:34 <araujo> yeah
05:58:41 <araujo> i think there is no 6.x for ppc
05:58:48 <Huschi> i wrote a low level interface to the sdl library and now want to create a higher level library. is there any paper on the web on this topic?
05:59:31 <shapr> You could look at the long discussions that happened on the GUI list in 2003
06:00:07 <Philippa> what do you want the higher level library to do?
06:01:31 <Huschi> Philippa, it shall provide the functionality of sdl but without the ugly impartiv style of a low level interface.
06:02:00 <Philippa> yampa-style?
06:02:26 <Itkovian> gotta go
06:02:27 <Itkovian> ttyl
06:03:30 <Huschi> Philippa, i've never hear of "yampa-style" before.
06:03:44 <Philippa> sooner or later you're going to have to deal with the fact it's a reactive system - so FRP and monads're the only reasonably-well-known ways to go, and it sounds like a monad isn't what you want
06:03:46 <Philippa> google yampa
06:03:51 <shapr> http://www.haskell.org/yampa/
06:06:21 <Huschi> ok, i see i've got to read a lot, maybe i'll come back later
06:07:00 <lightstep> @type Data.Map.lookup
06:07:01 <lambdabot> Data.Map.lookup :: forall a (m :: * -> *) k.
06:07:01 <lambdabot>                    (Ord k, Monad m) =>
06:07:01 <lambdabot>                    k -> Data.Map.Map k a -> m a
06:07:37 <shapr> Huschi: is your low level sdl wrapper online?
06:07:53 <Huschi> not at the moment.
06:08:10 <shapr> I'd like to see it when you have it online.
06:08:43 <Huschi> ok, at the moment there is not sll functionality of sdl covered but it will come in future.
06:09:57 <Philippa> how does it compare to Adrian Hey's?
06:10:13 <shapr> There's also Lemmih's and dark's SDL wrappers.
06:10:17 <Lemmih> Now I know of four SDL bindings to Haskell /-:
06:10:32 <shapr> And Nicholas Oury is writing one also, I think.
06:10:42 <shapr> So that's five.
06:10:58 <Lemmih> That lazy Hackage programmer should really get to work!
06:11:09 <Huschi> oh, when i asked some days ago nobody knew any sdl binding for haskell.
06:11:22 <shapr> Huschi: ask me!
06:11:38 <Lemmih> Huschi: Here or on the mailing list?
06:11:44 <Huschi> here.
06:12:13 <lightstep> isn't there a list of libraries on the wiki?
06:12:29 <Huschi> if there are several sdl bindings, wouldn't it be better if the developers work togheter?
06:13:25 <Philippa> Huschi: depends
06:13:55 <Philippa> shapr: do you know if any of them're ready-to-go?
06:14:11 <Lemmih> We all have different goals.
06:14:32 <Philippa> figures
06:14:35 <Philippa> what's yours?
06:14:42 * Lemmih only wants SDL to replace GLUT when using HOpenGL.
06:14:49 <shapr> Philippa: dark's SDL binding was going through the Prog'ing Linux Games book, he had Joystick support.
06:15:02 <shapr> it handled my Microsoft Sidewinder and its six zillion buttons just fine.
06:16:33 <Philippa> I'm after something suitable for 2D mouse+keyboard stuff atm, though I guess in a pinch I could render via HOpenGL
06:16:38 <Huschi> but wouldn't it be nice to have a general highlevel sdl library for haskell?
06:16:45 <shapr> Huschi: yes, it would
06:16:53 <Philippa> Huschi: probably, but nobody but you can be arsed to write it :-)
06:17:01 <lightstep> it's a real shame that the documentation of Data.Map.lookup doesn't say anything (such as what string is thrown)
06:17:17 <Philippa> or rather, two or three people'll write half of one while writing a game using yampa or something
06:17:29 <Philippa> but only half because it's easier to do all the setup stuff in the IO monad
06:17:57 <Philippa> there're times when imperative code's a good thing, like when you want to be able to usefully catch and handle errors...
06:17:59 <Lemmih> lightstep: It throws a string?
06:18:30 <lightstep> it fails (probably, it doesn't say anything)
06:18:45 <shapr> lightstep: details?
06:18:45 <lightstep> and fail gets a string
06:19:15 <lightstep> @plugs Data.Map.lookup 42 empty :: Maybe Int
06:19:16 <lambdabot> bzzt
06:19:21 * Philippa will most likely treat it as if in maybe most of the time anyway
06:19:29 <Lemmih> lightstep: fail "Data.Map.lookup: Key not found"
06:19:34 <Philippa> case (lookup...) of {Just foo ->...;Nothing -> ...}
06:19:50 <Philippa> I suspect it's not documented because it's not a reliable part of the interface
06:19:51 <Philippa> IYSWIM
06:20:14 <Lemmih> Huschi: Rendering with SDL is dog slow under X.
06:20:21 <Philippa> @plugs (Data.Map.lookup 42 empty) :: Maybe Int
06:20:22 <lambdabot> bzzt
06:20:23 <lightstep> yes, except that the whole point of a more general type is that you can use it without throwing in `case's all the time
06:20:52 <Philippa> @plugs case (Data.Map.lookup 42 empty) of {Nothing -> "whoops"; Just x -> "yay!"}
06:20:53 <lambdabot> bzzt
06:21:01 <Philippa> @plugs case (Data.Map.lookup 42 Data.Map.empty) of {Nothing -> "whoops"; Just x -> "yay!"}
06:21:02 <lambdabot> bzzt
06:21:11 <Philippa> lightstep: yeah, I know
06:21:21 <Philippa> and no doubt I'll make use of that sometimes
06:21:35 <Philippa> but if you want own-format errors, you're going to have to wrap the damn thing anyway
06:21:49 <Philippa> would be nice to have a generic version where you supply a fail result
06:22:25 <lightstep> there is (partially)
06:22:36 <lightstep> @type findWithDefault
06:22:37 <lambdabot> bzzt
06:22:52 <lightstep> but it doesn't let you wrap in case of a successful result
06:23:26 <Huschi> Lemmih, but what to use instead?
06:25:14 <Lemmih> Huschi: Haskell got an excellent binding to OpenGL.
06:25:18 <nibro> Lemmih: I'd be very interested in that advertised cabalized HSQL... =)
06:26:31 <Huschi> can i do 2D graphics and especially text with opengl?
06:28:03 <Lemmih> nibro: My cabalization is pretty dirty (: I think CosmicRay has a polished one.
06:28:44 * Lemmih tries to clean it up.
06:29:37 <nibro> no matter how dirty it won't be as dirty as having to do it myself... ;)
06:31:59 <Lemmih> My cabalization is building for Postgresql only.
06:33:00 <Lemmih> I'm still not sure how to do proper configuration or if it's even possible in Cabal right now.
06:35:34 <nibro> I don't know either, it seems like Cabal restricts configuration flags rather heavily
06:35:35 <Lemmih> Getting support for other databases than Postgres would require you to change the LD-Options and Exposed-Modules.
06:35:53 <nibro> that's where I was stuck
06:36:16 <nibro> just postgresql is fine by me for the time being
06:37:03 <Lemmih> You can get Setup.lhs and hsql.cabal from http://www.scannedinavian.org/~lemmih/
06:38:23 <Lemmih> Copy them to the HSQL dir and run make before building the cabal package.
06:38:49 <nibro> thankee =)
06:39:48 <Janni> Hmm. The ghc command-line flag -package-name is not documented...
06:40:26 <Lemmih> Janni: You use it when compiling modules for a given package.
06:42:10 <Lemmih> nibro: Hackage depends on HSQL so I'll probably bug the author of HSQL to cabalize it properly or do it myself. (:
06:42:59 <JaffaCake> Janni: -package-name is deprecated, use -ignore-package instead
06:46:54 <nibro> Lemmih: good idea :)
06:47:39 <nibro> Lemmih: I couldn't compile it though, there's stuff in the HSQL source that's not 6.4-compliant it seems... :(
06:48:05 <Lemmih> oh yeah... Forgot about that.
06:48:21 <Philippa> would be nice to have a list of code-breaking changes
06:48:36 <Philippa> I seem to've run across something subtle with TH, or maybe a bug
06:48:57 <Lemmih> nibro: CTime is not an instance of Integral or something, right?
06:49:18 <nibro> Lemmih: no, TyCon vs TyRep
06:49:56 <nibro> Lemmih: or rather TyCon vs TypeRep
06:51:36 <Lemmih> Issue s/mkAppTy/mkTyConApp/
06:52:42 <Lemmih> Around Types.hs:91.
06:54:35 <araujo> mm.. does hsql also have that problem?
06:55:30 <nibro> Lemmih: thanks, now I got the CTime Integral problem
07:04:13 <Lemmih> nibro: In what file?
07:06:26 <nibro> Lemmih: in Database/HSQL.hs. I changed fromIntegral to (fromIntegral . fromEnum) and it worked, will that screw anything up?
07:07:45 <nibro> Lemmih: line 302
07:09:21 <Lemmih> I think it's fine.
07:10:08 <nibro> goodie... now I just need to do the same for HaskellDB, you wouldn't happen to have cabalized that too? =)
07:10:50 <Lemmih> Actually I do. And that one is much nicer.
07:11:13 <nibro> ah, X-mas =)
07:11:30 <nibro> what's the link?
07:14:06 <Lemmih> Hmm I'm having problems uploading it.
07:14:34 <nibro> you could mail it to me at nibro@cs.chalmers.se
07:15:36 <araujo> nibro, you made it working for 6.-4?
07:15:43 <araujo> 6.4 8)
07:16:25 <nibro> well, yes, the parts for Postgresql
07:16:47 <Lemmih> nibro: Sent.
07:16:56 <nibro> Lemmih: gotten =)
07:17:15 <araujo> nibro, i suppose it fails in other parts?
07:17:18 <Lemmih> shapr: I can't ssh to scannedinavian.org anymore...
07:17:33 <Lemmih> shapr: Oh wait. Now I can (:
07:18:43 <nibro> araujo: I'm not so sure, the files I had to change was Types.hs and HSQL.hs, not PostgreSQL.hs
07:19:05 <nibro> araujo: so it might be that the other parts need no changes at all
07:19:45 <nibro> araujo: but you would still need to extend the cabal file (and probably the setup script as well)
07:21:06 <araujo> yeah
07:24:30 <Lemmih> I'm fairly sure that the other modules can compile without any changes. I have, however, only tested the MySQL and Postgresql interface.
07:26:52 <nibro> time to go home, thanks for the help!
07:26:59 <xti> Hi.
07:27:02 <xerox> @version
07:27:03 <lambdabot> Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
07:27:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:27:50 <araujo> Lemmih, the mysql interface works fine?
07:31:47 <chip> Hi ho.  I'm finally actually learning Haskell, and I have a Question.  Coming from Perl, I'm used to designing data structures where the ability for a given value to be undefined ("no value") is always available.  Haskell's typing system seems to make this a manual process.  Is there a standard pattern for such types?
07:32:09 <ibid> chip: the standard type Maybe
07:32:53 <ibid> chip: its values are Just <some value> and Nothing
07:33:06 <ibid> the type of Just x is Maybe a, where a is the type of x
07:33:49 <Lemmih> araujo: Yes. You just need to change the .cabal file a little.
07:34:38 <ibid> chip: so, a list of possible missing strings has the type [Maybe String]
07:34:55 <chip> ibid: well, I saw that in the documentation but then I saw it was an instance of Monad, which I figured meant it was esoteric and not particularly useful for usual data structures
07:35:01 <Lemmih> chip: You can use 'undefined', perhaps?
07:35:23 <ibid> Lemmih: unlikely
07:35:36 <ibid> chip: well, not all monads are esoteric
07:36:01 <ibid> chip: actually, the fact that Maybe is a monad is in my experience rarely used in practice
07:36:10 <chip> Shirley, it should be possible to express "maybe something good, maybe something bad" without enforcing order of evaluation
07:36:15 <ibid> chip: there are situations where it comes handy but it's not necessary
07:36:25 <ibid> chip: not all monads are about enforcing order of evaluation
07:36:30 <ibid> chip: Maybe is not one of them
07:36:31 <chip> Oh.
07:36:32 <Lemmih> How would an undefined value behave in Perl?
07:36:42 <ibid> Lemmih: you can test its presence
07:37:16 <chip> Lemmih: undefined values are in all ways but one equivalent to the empty string.  That one way is the defined() operator.  The undef operator creates undefined values, and variables default to undefined when declared.
07:37:18 <ibid> chip: Maybe is a monad so that you *can* use it monadically but it does not mean you *must* do so
07:37:38 <chip> ibid: OK
07:38:10 <chip> Lemmih: So undef is a distinct value from all scalar values (strings, numbers, references)
07:38:44 <ibid> chip: haskell has undefined but you can't use it beyond storing it
07:39:01 <ibid> chip: specifically, you can't test whether something is undefined or not
07:39:20 <chip> ibid: you're right, I can't use that.  good to know it exists though
07:39:22 <ibid> chip: for the kind of use that you'd use perl's undef, i'd use Maybe
07:41:12 <chip> One other question if I may: Perl hashes are associative data structures.  What Perl would call { 'a'=>1, 'b'=>2 }, I gather Haskell calls [('a',1), ('b',2)].  however, that implies a linear search.  Is there a standard data structure that uses hash/btree semantics for lookups?
07:41:52 <ibid> chip: hm, actually to be more precise, undefined can be stored and passed around safely but -as i said, you can't test for it and- if you try to use it like you'd use any other value of the type, you'll trigger an error (specifically, your expression becomes undefined)
07:42:05 <ibid> chip: semi-standard is Data.FiniteMap
07:43:32 <ibid> chip: it's not haskell 98 but it's supported by all the major implementations
07:43:57 <ibid> chip: and there is no literal syntax for it
07:44:14 <ibid> (you have to build a finite map by calling the functions)
07:45:46 <chip> ibid: Thanks for the pointer, and no literal syntax is OK
07:47:46 <chip> ibid: The ghc lib source code for FiniteMap refers to a constructor "Bag", which I can't find in the ghc lib code.  What is it?
07:48:02 <ibid> chip: haven't read the source code
07:48:15 <ibid> i've just used the interface docs
08:00:27 <lightstep> @paste
08:00:28 <lambdabot> Sorry, I don't know the command "paste", try "lambdabot: @listcommands"
08:00:31 <lightstep> @nopaste
08:00:32 <lambdabot> Sorry, I don't know the command "nopaste", try "lambdabot: @listcommands"
08:03:25 <lightstep> http://rafb.net/paste/results/VisIfe35.txt
08:03:47 <xerox> lightstep: it was http://www.haskell.org/hawiki/HaskellIrcPastePAge
08:04:12 <lightstep> i get "cannot match the rigid variable ..." on (sixth line in pastebin)
08:04:20 <lightstep> xerox, sorry, forgot about it
08:04:28 <lightstep> what does this error mean?
08:05:35 <xerox> (You should really not miss this: http://article.gmane.org/gmane.comp.lang.lightweight/3240 shapr, yay!)
08:08:28 <lightstep> guido didn't really harm anybody, did he?
08:08:36 * xerox hehs
08:11:19 <lightstep> oh, i got my problem. the error can be clearer, though. it isn't clear what rigid variables are, and where these specific `a' and `b' came from
08:11:30 <xerox> What was the error?
08:11:41 <xerox> err, the underlying problem.
08:12:00 <lightstep> @type (>>=)
08:12:02 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
08:12:02 <lambdabot>          (Monad m) =>
08:12:02 <lambdabot>          m a -> (a -> m b) -> m b
08:12:13 <lightstep> those a and b are called rigid variables
08:12:38 <lightstep> the type of the first parameter is _different_ from the type of the result
08:12:50 <lightstep> yet, in my code, i just passed the same value (g)
08:12:58 <xerox> Why don't you propagate the error string, tought?
08:13:23 <ibid> lightstep: ohh, i've been bitten by that more than once
08:13:28 <lightstep> i did. it was part of g. thatt's the as-pattern
08:13:39 <xerox> Hm.
08:13:56 <xerox> Does the compiler say what's the type, so?
08:14:54 <lightstep> huh?
08:14:54 <lightstep> oh, it doesn't
08:15:54 <lightstep> it gives the line, the bad definition, and that's all
08:16:03 <xerox> I mean the inferred type, or maybe I'm missing the point.
08:16:12 <lightstep> well, it says that T a conflicts with T b, but that doesn't help at all
08:17:03 <lightstep> and that a is bound by the definition of >>=, and that b is bound by the definition of >>=
08:22:31 <Janni> I have a problem using Cabal.
08:23:20 <Janni> While building with "runghc Setup.hs build" some MyModule_stub.c and MyModule_stub.h files are generated
08:24:11 <Janni> And then MyModule_stub.o lands in dist/build
08:24:34 <xerox> hiya boegel!
08:24:35 <Janni> But it is not included in the dist/build/libMyLib.a
08:24:44 <boegel> hi xerox
08:24:48 <Janni> Which results in a linkage error.
08:25:01 <Janni> So, have I forgot to do s.th. or is this a bug?
08:25:32 <Janni> If I include the stub files in the .a file manually the package works fine.
08:28:17 <Lemmih> Janni: You have to add it in C-sources.
08:29:09 <Janni> Oh right.
08:29:24 <Janni> But shouldn't they be included automatically?
08:30:02 <Lemmih> Yeah they should. Send patches to libraries@ (:
08:30:04 <chip> ghc source code: compiler/utils/Bag.lhs
08:30:06 <chip> \section[Bags]{@Bag@: an unordered collection with duplicates}
08:31:12 <chip> Funny thing, the online docs don't mention it
08:32:12 <Lemmih> You really don't wanna look in compiler/*
08:33:19 <chip> DON'T LOOK, ETHEL!
08:33:31 <chip> It was too late.  She'd already got a free shot.
08:34:09 <Lemmih> The libraries are located in libraries/ (:
08:43:46 <shapr> hiya Nafai, ltns
08:44:58 <chip> Does Haskell the language make any attempt at dealing with various character sets?  I haven't seen anything yet
08:45:16 <shapr> Nafai: what's up?
08:45:55 <shapr> chip: Yes, the H98 standard requires UTF-8 source compatibility.
08:46:08 <shapr> None of the implementations fully implement that though.
08:47:52 <autrijus> chip: haskell is great for unicode string processing
08:48:02 <autrijus> chip: but utf8 literals in programs must fit in the latin1 subset.
08:48:06 <autrijus> (like, perl6, pugs)
08:51:19 <chip> autrijus: And Unicode character attributes (word chars, etc) ... perhaps with Parsec?
08:55:15 <Heffalump> autrijus: is it any good at converting UTF-8 to and from other charsets?
08:57:27 <Nafai> shapr: Not much; busy with work and such.  I was reading your blog last night and thought I would jump in here.
08:57:56 <chip> autrijus: Why did you decide to take & change Parsec rather than using it as is?
08:58:56 <Janni> Hmm. Dorcs doesn't build with ghc-6.4 (configure script fails)...
08:59:00 <Janni> s/Dorcs/Darcs
08:59:03 <shapr> Nafai: Nice to see you! Have you ever tried Haskell?
08:59:04 <chip> "The Haskell report says that the Char type holds 16 bits. GHC follows the ISO-10646 standard a little more closely: maxBound :: Char in GHC is 0x10FFFF." - ghc6 docs
08:59:14 <chip> supports multiple planes(?)
08:59:35 <Janni> I already read, that the version I can get with darcs this is resolved
08:59:43 <Janni> But I can't build darcs.
09:00:10 <Nafai> shapr: Nope.  I honestly haven't have the energy or focus to learn a new language (other than this stupid C++-like scripting language for my game engine at work) for a few years
09:00:32 <shapr> This could be your lucky year!
09:00:33 <Janni> So, can somebody tell me, how the sources have to be altered?
09:00:52 <shapr> Janni: I'll put up a tgz for you, just a moment while I slurp the latest patches.
09:01:05 <shapr> Nafai: Today I wrote my first Perl6 code!
09:01:36 <Nafai> shapr: I'm not sure I would be proud of that. :)
09:01:53 <shapr> I am quite proud of it actually.
09:02:02 <Oejet> shapr: Did you compile and run it too?
09:02:28 <shapr> Oejet: yes I did!
09:02:49 <shapr> Janni: http://www.scannedinavian.org/~shae/darcsApril1.tar.bz2
09:03:02 <Janni> Thx.
09:03:03 <shapr> Nafai: The existing perl6 is written in Haskell.
09:03:15 <shapr> It's quite nifty.
09:03:27 <Nafai> shapr: Wow
09:03:40 <chip> by intent it's a prototyping / bootstrapping tool
09:04:14 <shapr> For my first code today I added chr() and ord() builtins, I'm trying to figure out the last detail for a hex() builtin.
09:05:27 <Lemmih> File names containing April1 makes me nervous.
09:05:34 * shapr grins evilly
09:08:04 <chip> The HXT module seems to include, as a minor add-on, UTF-8 decoding and other charset stuff.
09:08:16 <chip> It's unfortunate that you need an XML library to get Unicode translation(s)
09:09:27 <shapr> chip: I suspect that unicode does not require xml.
09:09:57 <shapr> I predict that google can point you to lots of Haskell unicode work outside of XML libraries.
09:11:07 <chip> shapr: Hm.  I'll bet you're right, now that I see e.g. pugs/src/UTF8.lhs
09:26:13 <shapr> hi timor
09:26:17 <timor> hi
09:26:24 <shapr> Want to join the revolution?
09:26:44 <_timor> revolutions are awesome
09:27:03 <basti_> the perl-6-is-written-in-haskell revolution?
09:27:05 <shapr> Yes, I enjoy the occasional revolution.
09:27:34 <shapr> basti_: sure, that's a good revolution.
09:28:07 * xerox is darcsgetting too.
09:28:21 <basti_> that would indeed be a stunning success for haskell
09:32:51 <shapr> and a stunning success for perl6
09:33:15 <xerox> shapr: would you do your python works in p6 then?
09:33:46 <shapr> From what autrijus says about p6, it's tempting.
09:34:12 <shapr> For one thing, I want to write a Zope replacement in Haskell, but I'd like to have an imperative scripting language for non-FP users.
09:34:27 <shapr> If there's a p6 implementation in Haskell, it's an easy choice.
09:35:10 <xerox> I don't like the complicated syntax, tought.
09:35:39 <shapr> I do like Haskell's minimum number of moving parts.
09:36:25 <basti_> the syntax is not that complicated i think.
09:36:39 <basti_> it's better than most languages.
09:36:43 <xerox> basti_: how do you say so?
09:36:58 <integral> there's the fiddly semantics of = vs. := vs. ::=, and == vs. eq vs. =:=
09:37:01 <basti_> haskell not perl
09:37:14 <xerox> Haskell syntax isn't complicated :)
09:37:19 <Si\> how does one get the TH Ppr to produce valid Haskell output?
09:37:23 <basti_> yes that was what i was thinking
09:37:29 <basti_> i thought you thought the opposite
09:37:50 <basti_> but maybe we can force those perl guys to let go of some bizarre constructs ;)
09:38:09 <xerox> shapr: what does autrijus say, making you think that's worth it?
09:38:32 <xerox> basti_: from some discussions I see on #perl6, syntax is kinda *weird*, sometimes.
09:38:44 <shapr> autrijus talks about how p6 was designed by people who see good things in other languages.
09:38:58 <shapr> And I think that's always the way to improve.
09:39:02 <xerox> But for write-and-run-once programs is usually usable.. as in sed <blink>
09:39:25 <shapr> Si\: Lemmih was just asking that, maybe he knows more?
09:39:54 <basti_> maybe one can take out a few things, keep the most, and gain a lot of simplicity.
09:40:15 <basti_> i mean, for example, some order to that "context" buisiness would be nice.
09:40:29 <Si\> I've tried pprint, but class instances are indented wrong
09:40:29 <xerox> Perl6 proposal: rethink the syntax, should I hide now?
09:40:41 <basti_> i dont know. ;)
09:40:48 <Si\> (not to mention string are char lists, but that doesn't really matter)
09:41:35 <shapr> In any case, whether I ever end up using perl6 or not, I *am* sure I want to get better at writing interpreters, compilers, languages, etc. So the best way to do that is to write them. And perl6 will likely be used by some people at some point.
09:41:43 <shapr> I'd much rather write code that people will use.
09:42:10 * basti_ nods
09:42:40 <shapr> So, jump in and help out on Perl6. It doesn't mean you have to totally agree with all of the design choices. But you will learn something about how to write better Haskell programs.
09:42:42 <xerox> I don't know.
09:42:57 <xerox> You kinda convinced me.
09:43:05 <basti_> oh and it will teach the perl people something about programming too
09:43:10 * basti_ runs and hides VERY QUICKLY no
09:43:11 <basti_> w
09:43:22 * shapr grins
09:43:43 <shapr> Some of the 'perl people' are enjoying purely functional programming.
09:43:45 <lightstep> apparently, some of them are very convenient with fp idioms (such as fold)
09:43:54 <basti_> i'd hope.
09:43:55 <lightstep> err, sorry
09:44:03 <shapr> And some of the 'haskell people' will enjoy perl programming.
09:44:13 <basti_> i do.
09:44:17 <basti_> now and then.
09:44:20 <basti_> when it has to be quick
09:44:25 <basti_> i get a little sick always, though
09:44:44 <CosmicRay> morning everyone
09:44:57 <CosmicRay> well I decided to see how *large* I could make my CSV parser, I guess.  only 91 lines.  shameful. :-)
09:45:03 <lightstep> wow, CosmicRay has ip6 too
09:45:03 <Lemmih> Si\: I've mailed template-haskell@ with the question and a source fix.
09:45:10 <CosmicRay> lightstep: for ages, yes :-)
09:45:15 <basti_> shapr: did you consider my tiling stuff btw.?
09:45:40 <CosmicRay> lightstep: if you use Debian, this may be useful: http://changelog.complete.org/node/61
09:45:42 <basti_> shapr: i found a problem in there though. My solution allows for the definition of traversal functions of this tiling.
09:46:01 <basti_> it doesnt say there is one, or it is infinite or something.
09:46:13 <CosmicRay> so here's my CSV parser :-)   http://arch.complete.org/archzoom/jgoerzen@complete.org--projects/missingh--head--0.7--patch-209/MissingH/Str/CSV.hs
09:46:20 <CosmicRay> (that's a regular web page)
09:46:44 <CosmicRay> who else around here is using ipv6?
09:46:46 <CosmicRay> shapr?
09:46:48 <CosmicRay> ah yes.
09:47:03 * CosmicRay idly wonders if the new ghc supports ipv6.
09:47:12 <basti_> CosmicRay: looking good :)
09:47:24 <CosmicRay> basti_: do you think I have it well enough commented? :-)
09:47:57 <Igloo> Hmm, you count comments in code size?
09:47:59 <basti_> well if someone knows parsecs...
09:48:09 <Si\> Lemmih: is it possible to get the Ppr to output Strings instead of Char lists?
09:48:17 <shapr> I learned my IPv6 from CosmicRay!
09:48:22 <CosmicRay> Igloo: I was being tongue-in-cheek, hence the smileys
09:48:26 <Si\> (syntactically I mean)
09:48:29 <basti_> you could expand the meaning of the parsec stuff.
09:48:35 <CosmicRay> basti_: heh
09:49:31 <shapr> CosmicRay: musasabi's network-alt supports IPv6
09:49:33 <CosmicRay> hmm, ghc 6.4 does not support ipv6.
09:49:38 <shapr> Not sure about multicast though.
09:49:44 <CosmicRay> oh, interesting
09:49:54 <CosmicRay> shapr: you are the only one in this channel that cares about multicast :-)
09:50:16 * shapr grins
09:50:22 <shapr> but I will EDUCATE THE WORLD!
09:50:23 <CosmicRay> shapr: not that that's a bad thing.  I'm the only one that cares about gopher :-)
09:50:24 <CosmicRay> hehe
09:50:30 <CosmicRay> shapr: me too!
09:50:40 <Lemmih> Si\: When?
09:51:25 <CosmicRay> you know the scary part about CSV parsing?  As simple as it is, both of the examples I found of doing it in haskell were fundamentally broken.
09:51:32 <CosmicRay> http://www.xoltar.org/languages/haskell/CSV.hs is really weird
09:52:01 <basti_> woha
09:52:03 <shapr> xoltar is Bryn Keller
09:52:16 <Igloo> CosmicRay: Isn't that going to parse"\"\n\"" incorrectly?
09:52:21 <Igloo> Well, not at all
09:52:26 <CosmicRay> Igloo: which, my code or his?
09:52:31 <Igloo> Yours
09:52:40 <CosmicRay> I support multiline cells
09:52:58 <CosmicRay> so theoretically that should result in [["\n"]]
09:53:03 <Igloo> What does endBy do?
09:53:20 <CosmicRay> it's like sepBy, but stops parsing when it encounters the end condition
09:53:35 <CosmicRay> err, no.
09:53:38 <ibid> shoo!
09:53:40 <CosmicRay> that is manyTill.
09:53:41 <Igloo> That doesn't help me  :-)
09:53:44 <ibid> rfc4042
09:53:45 <Igloo> Is it like lines?
09:53:46 <ibid> wow
09:53:53 <ibid> "UTF-9 and UTF-18 Efficient Transformation Formats
09:53:56 <ibid>                      of Unicode"
09:54:03 <CosmicRay> endBy will look for something that is separated by, and followed by, a particular delimiter.
09:54:06 <ibid> >> The current representation formats for Unicode (UTF-7, UTF-8, UTF-16)  are not storage and computation efficient on platforms that utilize  the 9 bit nonet as a natural storage unit instead of the 8 bit octet.    This document describes a transformation format of Unicode that takes  advantage of the nonet so that the format will be storage and  computation efficient.
09:54:19 <CosmicRay> ibid: heh
09:54:34 <shapr> I wrote my own cvs.py long ago.
09:54:36 <Igloo> Oh, sorry, I see what it's doing, I think
09:54:36 <ibid> that's (almost) useful!
09:54:41 <shapr> I could port it.
09:54:55 <xerox> Believe it or not, compiling pugs almost killed my laptop.
09:54:55 <CosmicRay> ibid: is this a 1 april RFC? :-)
09:54:59 <ibid> yeah
09:55:10 <ibid> just got the announcement
09:55:13 <CosmicRay> xerox: I believe it.  ghc used almost a gig of ram for pugs IIRC
09:55:22 <CosmicRay> shapr: what does it do?
09:55:25 <xerox> CosmicRay: Oh my..
09:55:42 <ibid> (i subscribed to the rfc announcement list somewhere in the late 90's. incredible that it still operates and reaches me)
09:55:46 <CosmicRay> xerox: I'm on amd64, an unregisterized platform, which may explain it
09:55:48 <CosmicRay> ibid: heh
09:56:07 <xerox> Sigh, sob.
09:56:19 <xerox> It froze my laptop, and didn't finish compile.
09:56:22 <CosmicRay> xerox: would love to try compiling pugs on my zaurus, eh? :-)
09:56:28 <CosmicRay> xerox: any hdd activity?
09:56:35 <xerox> CosmicRay: fulltime hdd activity
09:56:45 <CosmicRay> xerox: ah ha.  swap thrashing.
09:56:50 <xerox> ..but 0 responsivity, yep.
09:57:04 <CosmicRay> xerox: eventually ghc will either exhaust your swap space and die, or it will finish.
09:57:13 <CosmicRay> xerox: nono, it's just responding very, very slowly!
09:57:21 <CosmicRay> xerox: just like darcs :-)
09:57:29 <xerox> And I bet GHC itself.
09:57:35 <CosmicRay> heh
09:58:01 <CosmicRay> I was referring to that darcs spinning bug I reported where David said "that's not an infinite loop, your checkin will finish in a day or two"
09:58:03 <CosmicRay> :-)
09:58:49 <xerox> Yay :)
09:58:56 <CosmicRay> did ghc die?
09:59:19 <xerox> Dunno, no response :(
09:59:20 <ibid> apparently there is now also an rfc on "Requirements for Morality Sections in Routing Area Drafts"
09:59:22 <CosmicRay> oh heh
09:59:38 <shapr> Related to "Set The Evil Bit"
09:59:47 <CosmicRay> xerox: you will either have to wait or power it down in all likelihood, unless you have magic sysrq compiled in
09:59:49 <CosmicRay> shapr: bwahahahaha
09:59:59 <shapr> CosmicRay: my csv.py does full-on Excel-style csv parsing.
10:00:05 <CosmicRay> ah
10:00:11 <shapr> My clients required Excel compatibility.
10:00:16 <CosmicRay> oh, I must have misread it.  I thought you said cvs.py
10:00:31 <shapr> I did, thinko on my part.
10:00:44 <CosmicRay> ah ha :-)
10:01:09 <CosmicRay> does excel escape things in any way other than "" for one quote?
10:01:16 <shapr> I have difficulty typing the word 'sharp' nowadays.
10:01:31 <shapr> excel handles inline \n and other weird stuff.
10:02:19 <beschmi> CosmicRay: spinning with little CPU use on darcs record?
10:02:24 <shapr> inline \n escaped delimiters, etc etc
10:02:31 <CosmicRay> beschmi: spinning with heavy cpu use and little io use
10:02:45 <CosmicRay> beschmi: but yes.  it had something to do with files having been renamed in a prior patch
10:02:55 <CosmicRay> beschmi: it was like a 5-byte change to a .5K file
10:03:09 <CosmicRay> in a repository consisting of about 4 files of that size
10:03:18 <CosmicRay> shapr: ugh.
10:03:34 <beschmi> ah then it's something different, i'm trying to find out why an initial record of the kernel sources takes so long
10:03:51 <CosmicRay> perhaps because the kernel sources are fscking huge? :-)
10:03:54 <CosmicRay> just a wild guess :-)
10:04:24 <beschmi> it does no IO and cpu use is at 1.5 % for a long time
10:04:30 <CosmicRay> ah
10:04:33 <CosmicRay> weird.
10:04:42 <CosmicRay> what is it doing for the other 98% of the time?
10:04:44 <shapr> I can dig heavy IO use, but not 1.5% IO use.
10:04:50 <shapr> er CPU
10:04:51 <CosmicRay> so strace shows it doing nothing?
10:05:05 <beschmi> mmap2 and something signal related
10:05:14 <CosmicRay> huh.
10:05:19 <CosmicRay> well mmap is IO.
10:05:34 <CosmicRay> I didn't think fptools used mmap though
10:05:39 <CosmicRay> maybe david wrote somethign that does
10:05:56 <beschmi> i disabled mmap for writing the patches
10:06:02 <CosmicRay> hey, musasabi's network library is pretty cool.
10:06:04 <CosmicRay> I like it.
10:06:35 <xerox> I missed something.
10:06:43 <shapr> me too
10:07:05 <CosmicRay> I refer to the network-alt that you told me about, shapr
10:07:47 <CosmicRay> w00t!  ups has delivered my packages!
10:08:24 <Lemmih> SyntaxNinja: Hey
10:08:30 * CosmicRay afks
10:16:35 <Nafai> shapr: So...how would you compare Haskell to O'Caml?  (I hope this is an okay question to ask here)
10:16:41 <Si\> Lemmih; the problem is that when lifting expressions the instance of Lift used for string is of course the one for [a], meaning that Strings get converted to listE (charE), so for now I've used overlapping instances to cure the symptoms
10:17:35 <shapr> Nafai: OCaml is string, impure, and the syntax is not as nice as Haskell's
10:17:46 <shapr> Nafai: OCaml tends to produce really fast executables
10:18:20 <Igloo> "string"?
10:18:25 <Nafai> shapr: What do you mean by "string" and "impure"?
10:18:35 <shapr> sorry, *strict*
10:18:52 <shapr> I'm writing Perl6 code and chatting about concatenative languages in #perl6 and it's distracting me =)
10:19:11 <Nafai> shapr: Okay, what do you mean by strict and impure? :)
10:19:19 <desrt> perl 6 doesn't exist!
10:19:32 <shapr> desrt: are you sure?
10:19:41 <desrt> absolutely
10:19:53 <shapr> Nafai: in Haskell I can write "ones = 1 : ones" to define an infinite list of 1s
10:20:10 <desrt> â¢ Stable is 5.8.6.
10:20:11 <desrt> â¢ Latest is 5.8.6.
10:20:11 <desrt> â¢ Devel is 5.9.1.
10:20:15 <Oejet> desrt: Is Perl 6 dead? =-O
10:20:27 <desrt> Oejet; no.  it simply never existed :)
10:20:37 <Oejet> =-O
10:20:57 <SyntaxNinja> desrt: the next perl is an evolving standard that many refer to as perl 6
10:20:57 <shapr> Nafai: you couldn't do that in Python, right?
10:21:07 <shapr> desrt: http://pugscode.org/
10:21:14 <desrt> SyntaxNinja; ya.  i know.  i'm being obnoxious about it
10:21:21 <SyntaxNinja> desrt: ah OK.
10:21:38 <cathper> http://www.math.aau.dk/~caspert/misc/perl6.png ;-)
10:21:53 <desrt> shapr; surely this isn't the 'official' implimentation
10:22:07 <SyntaxNinja> it's the only implementation, afaik
10:22:24 <lightstep> desrt, 5.9.1 is the devel version of perl (perl5 implementation); 6.0.13 is the devel version of pugs (perl6 implementation)
10:22:26 <shapr> desrt: It's the most official implementation yet. And I just committed more code to the implementation :-P
10:23:04 <Oejet> cathper: lol
10:23:48 <shapr> Nafai: A purely functional languages is where functions must be described only by their inputs.
10:24:07 <shapr> No global variables, no side-effects, no surprises.
10:24:13 <Oejet> Wow, there are many Danes in this channel.  I don't know any place in Denmark where they teach Haskell.
10:24:25 <Oejet> *know of
10:24:51 <basti_> maybe thats why
10:24:52 <basti_> =)
10:25:02 <shapr> Nafai: Haskell doesn't have loops or variables either. But it doesn't need them.
10:26:33 <Oejet> Nafai: Haskell has what a famous news group person calls B&D.
10:26:36 <SyntaxNinja> there are a few loops on this channel, but that's another story
10:26:57 * shapr snickers
10:27:15 <basti_> awwww
10:28:04 <shapr> Nafai: still interested?
10:29:12 <Oejet> Nafai: The best thing about Haskell is that your head will explode more than once, when learning it.
10:29:28 * halcyon10 nods desperately
10:42:44 <_JusSx_> Oejet: not true
10:43:06 <Janni> Why? What's even better than that about Haskell?
10:43:26 * shapr grins
10:43:28 <Janni> I think the exploding heads are a quite delicate feature.
10:46:52 <desrt> mm
10:47:00 <desrt> you only get exploding heads when you mix haskell with undergrads
10:47:55 <lightstep> not necessarily. non-academic people learning haskell might also experience this
10:49:12 <shapr> like me!
10:49:44 * CosmicRay returns
10:50:19 <CosmicRay> as a non-academic person who is technically still an undergrad, I must say that my head didn't explode at haskell :-)
10:50:39 <CosmicRay> actually I found haskell to be more like a breath of fresh air
10:50:50 <CosmicRay> it's the language I always wanted but didn't know how to design :-)
10:51:01 <SyntaxNinja> lightstep: non-academic, and non-head-exploding here too
10:51:12 * Igloo met it as an UG, and I don't remember my head exploding either
10:51:23 <SyntaxNinja> and shapr's head is always exploding, so he hardly counts
10:51:27 * shapr laughs
10:51:27 <CosmicRay> haha
10:51:36 <lightstep> my head didn't explode, but i'm an undergrad
10:51:41 <SyntaxNinja> (in a good way)
10:51:48 <Igloo> I think Haskell would catch on a lot faster if people familiar with it didn't feel the need to go round telling everyone there are no variables or loops and they won't understand it
10:51:49 <lightstep> (assuming i know what that word means)
10:51:58 <SyntaxNinja> Igloo: haha
10:52:07 <aheller> I'm not, but the fibonacci list example really screwed with me for a while.
10:52:14 <SyntaxNinja> so one time, I was having a beer with a pretty smart computer programmer
10:52:15 <CosmicRay> Igloo: hey, I resemble 2/3 of that remark :-)
10:52:25 <SyntaxNinja> and he said, "can I ask a dumb question... what good is a language where you can't do IO"?
10:52:29 <SyntaxNinja> haskell has a bad rap
10:52:31 <shapr> Igloo: right, I'll try that in the future.
10:53:02 <CosmicRay> SyntaxNinja: it's because a majority of the stuff out there introducing haskell sucks
10:53:23 <shapr> oh hey, I bought Dator Magazine today, it has a Haskell article!
10:53:49 <CosmicRay> I completely agree.  as I read some of this stuff that doesn't even touch I/O until page 300 or whatever, I grow more and more impatient.... "when are they going to show me how to actually compile a program I can RUN?"
10:54:29 <CosmicRay> diveintohaskell would be awesome.
10:54:43 <shapr> yeah!
10:54:49 * wilx has to agree
10:54:56 <aheller> Not that I've read it, but isn't the Hudak book supposed to be a little better about that?
10:55:02 <shapr> It is better.
10:55:14 <CosmicRay> I haven't read it either...
10:55:35 <CosmicRay> personally, I want to get the feel of a language using free online resources before I purchase any dead tree material
10:55:37 <wilx> I have had looong pause in learning Haskell exactly because IO and monads were inadequately explained in all materials like three/four years back.
10:56:01 <CosmicRay> wilx: they're still inadequately explained, just not quite as poorly :-)
10:56:09 <wilx> :)
10:56:20 <shapr> I was lucky, my woman bought me both Hudak and Thompson for my birthday. That's how I got here!
10:56:34 <CosmicRay> so if I loko at a language and it looks like a toy language, because IO is not covered or is an "advanced" topic saved for the very end, I may not ever become interested enough in it to spend some money
10:56:35 <lightstep> when introducing pascal, no tutorial sees a need to explain the exact semantics of `program' or `uses'
10:56:52 <aheller> My strategy for dealing with monads has thus far proved not-so-fruitful...  But it turns out I didn't pick up enough Algebraic Topology...
10:57:25 <CosmicRay> but my #1 gripe is the horribly misnamed "gentle" introduction
10:57:57 <lightstep> i actually really like the gentle intro - i learned haskell from it
10:58:12 <aheller> Wasn't it a SIGPLAN article, originally?
10:58:15 <lightstep> when feeling like compiling, i just skipped forward
10:58:22 <CosmicRay> I think it is deeply wrong to cover recursive polymorphic types before ever showing people even one working program or putStr
10:58:54 <CosmicRay> gentle seems more like a reference to me, and it's fairly handy as that
10:59:05 <lightstep> but i was very interested in informal pl theory
10:59:47 <CosmicRay> here, for example, is the first sentence in the array chapter:
11:00:01 <CosmicRay> "Ideally, arrays in a functional language would be regarded simply as functions from indices to values, but pragmatically, in order to assure efficient access to array elements, we need to be sure we can take advantage of the special properties of the domains of these functions, which are isomorphic to finite contiguous subsets of the integers. Haskell, therefore, does not treat arrays as general functions with an application ope
11:00:02 <CosmicRay> ration, but as abstract data types with a subscript operation."
11:00:08 <CosmicRay> s/sentence/paragraph/ but it's almost the same
11:00:49 <CosmicRay> great for a theorist probably, but nowhere does it actually say what an array does in haskell
11:00:54 <lightstep> it's a good summary about arrays in haskell
11:01:07 <CosmicRay> no, it sucks
11:01:16 <wilx> Hehe, agreed :)
11:01:36 <lightstep> it was immidiately clear to me (although i had a lisp background)
11:01:36 * shapr agrees with CosmicRay
11:01:45 <CosmicRay> I don't care which function is isomorphic to what subset.  Tell me how an array is different from a list and ow to use it.  And give me a reference where I can learn all the other stuff if I want.
11:01:55 <shapr> I still don't know if I can make n-dimensional Ix instances.
11:02:09 <lightstep> they're automatic
11:02:26 <shapr> What is?
11:02:37 <CosmicRay> I read that first paragraph and I think "huh.  That told me nothing about how to actually use arrays."
11:02:39 <lightstep> array instances for tuple types
11:03:09 <Igloo> GI claims to be for those used to FP, doesn't it?
11:03:09 <shapr> Does that mean I can create an 3-dimensional array? If so, can you show me?
11:03:41 <lightstep> also, the array chapter is the last one
11:03:45 <lightstep> shapr, use array, not arrayList
11:03:57 <shapr> I want to see an example.
11:04:08 <CosmicRay> Igloo: just like any other kind of programming, one can use fp without being a theorist
11:04:16 <lightstep> i never used 3d arrays
11:04:26 <shapr> Nor have I. Mostly because I couldn't figure out how.
11:04:33 <Igloo> I think the first paragraph of my Dyson manual is more likely to tell me how it uses cyclones to minimise suction use than how to remove dirt from the floor with it
11:04:46 <Oejet> array ((0,0,0), (3,7,2)) [((0,1,3), 6) ...]
11:04:56 <shapr> Oejet: whoa!
11:05:05 <Igloo> s/suction/suction loss/
11:05:08 <CosmicRay> Igloo: you sure it's not more likely to use Chinglish to tell you how to use the power switch? :-)
11:05:41 <Igloo> Hey, I never said likely, just /more/ likely  :-)
11:05:50 <shapr> Oejet: I've been trying off and on for years to do something with triples of 2-tuples! doh!
11:06:24 <CosmicRay> Igloo: actually, it probably spells out, in broad strokes, the advantages of that particular model.  It doesn't tell you that they discarded the idea of a belt drive back in 1976, and decided to go with a high-voltage motor back in 1982...
11:06:31 <Oejet> shapr: ((0,0,0), (3,7,2)) is the bounds of the array indeces.
11:06:38 <shapr> Yes! I understand!
11:07:22 <CosmicRay> Igloo: When I read about an array, I want to know "what can it do for me?"  I don't care about all the implementation methods they discarded (unless this is somehow required to use the array) right now.   I want to learn how to do a basic use of the array, and *then* get all the details.
11:07:32 * shapr bounces happily
11:07:39 <shapr> yay! I have my first 3D-array!
11:07:46 <shapr> it wooorks!
11:07:52 * SyntaxNinja high-fives shapr
11:08:00 * Oejet gives himself a shapr point for actually teaching shapr something.
11:08:02 <shapr> Ok, next question. Can I create n-ary arrays?
11:08:08 <shapr> Oejet: definitely!
11:08:09 <CosmicRay> the other approach is like forcing me to learn the intracicies of the bitfields in the headers on TCP packets, plus the complexities of routing with GRE, just to write a simple datetime client that reads one line of text from the server.
11:08:12 <shapr> @karma+ Oejet
11:08:13 <lambdabot> Oejet's karma has been incremented.
11:08:20 <Oejet> Yay! :-D
11:08:35 <shapr> For example, can I create hexagonal 2D arrays? like all those wargames have?
11:08:53 <basti_> they are isomorphic to 2d arrays
11:09:00 <CosmicRay> I don't care about all of that.  I want to write a client, dammit.  Just warn me to check for errors in the return value from the functions, and tell me all the different ways a network program can fail later :-)
11:09:32 <shapr> basti_: I don't understand, how can I do a hexagonal neighbor check with a 2D array?
11:10:03 <basti_> hmm its like: imagine a pattern of squares, where each other line is shifted about half a square
11:10:18 <shapr> oh!
11:10:22 <shapr> neato
11:10:26 <lightstep> the real problen is a nice type for the indices
11:10:28 * basti_ got a shapr point too
11:10:28 <xerox> shapr: rotating a square matrix with lines shifted by half a square.. basti_ came first.
11:10:35 <basti_> ;)
11:10:40 <basti_> i thought everyone knew that.
11:10:43 <shapr> Not me.
11:11:04 <shapr> Does that work in 3D also?
11:11:10 <CosmicRay> is it just me, or are all the april 1 jokes on slashdot really non-funny this year?
11:11:11 <basti_> hexagonally?
11:11:13 <basti_> will be hard.
11:11:23 <Oejet> shapr: http://www.cis.upenn.edu/proj/plclub/contest/ants.html
11:11:28 <xerox> CosmicRay: did you see the Scheme one?
11:11:35 <CosmicRay> hmm no
11:11:46 <CosmicRay> I gave up when I saw paris hilton.
11:12:00 <CosmicRay> hmm, no scheme on the homepage...
11:12:16 <xerox> http://article.gmane.org/gmane.comp.lang.lightweight/3240
11:12:27 <CosmicRay> ahh, but that is not on slashdot :-)
11:12:29 <shapr> Oejet: neat!
11:12:41 <xerox> CosmicRay: and it's way better than slashdotted ones ;)
11:12:57 <CosmicRay> yes it looks good :-)
11:13:10 <CosmicRay> dropping filter and map because it's more clear in an imperative program :-)
11:13:22 <xerox> CosmicRay: it refers to.. let my find it..
11:13:44 <CosmicRay> The Fate Of LAMBDA in PLT Scheme v300
11:13:45 <CosmicRay> 				  or
11:13:45 <CosmicRay> 		   Lambda the Ultimate Design Flaw
11:13:45 <CosmicRay> heh
11:14:30 <lightstep> i think they should've kept the part that said some frustrated lisp hacker put it the source tree
11:14:32 <xerox> CosmicRay: That is: http://www.artima.com/weblogs/viewpost.jsp?thread=98196
11:15:04 * xerox wonders if lightstep is the frustrated lisp hacker..
11:15:18 <stepcut> http://dot.kde.org/1112318366/
11:15:29 <lightstep> i wish i were the one to introduce lambda into python
11:15:45 <CosmicRay> xerox: and the scary thing is that *this is not a joke*
11:15:52 <CosmicRay> dammit I thought it was for a minute :-)
11:15:55 * xerox frightens
11:16:10 <ned> Oejet: links to http://icfpcontest.org/ are brocken on http://www.cis.upenn.edu/proj/plclub/contest/ants.html
11:18:59 <CosmicRay> xerox: http://www.python.org/peps/pep-3000.html
11:19:10 <Oejet> ned: http://www.cis.upenn.edu/proj/plclub/contest/results.php
11:19:25 <CosmicRay> I used to really love python
11:19:41 <CosmicRay> I still think its exception handling is nicer than haskell's
11:19:59 <CosmicRay> but other than that, there's not a lot I will like about python 3, I think.
11:20:25 <CosmicRay> it seems it will be this sterile language, with about as much heart as java, and only slightly less verbose :-)
11:20:27 <xerox> Replacing print with write() and writeln() ... mmmh ...
11:21:02 <CosmicRay> if this doesn't smack of java, look at this under "to be removed":
11:21:07 <CosmicRay> input(): use eval(sys.stdin.readline())
11:22:57 <xerox> O_o
11:23:03 <SyntaxNinja> xerox: oh, so that scheme joke article that came out was making fun of a real article about python?
11:23:13 <xerox> SyntaxNinja: exactly.
11:23:20 <CosmicRay> SyntaxNinja: yes
11:23:54 <SyntaxNinja> that's really funny
11:23:57 <SyntaxNinja> poor python users
11:25:01 * xerox pokes shapr
11:25:13 <basti_> he's all excited about that hexagon thing prolly
11:25:42 <shapr> eh?
11:25:54 * basti_ ducks
11:26:04 <shapr> sorry, I've been trying to figure out which shape is next to which shape in n-dimensional space
11:26:10 * shapr 's head explodes
11:26:29 <basti_> o0
11:26:30 <basti_> next to?
11:27:13 <Oejet> shapr: What shapes are your shapes?
11:27:46 <xerox> n-dimensional shapes.
11:28:21 <monochrom> shapr's shapes are r-dimensional, not n-dimensional.
11:28:21 <Oejet> xerox: n-cubes are rather easier than n-hexagons.
11:28:48 <xerox> monochrom: r-dimensional?
11:28:57 <xerox> Oejet: probably :)
11:29:15 <monochrom> yeah, the r comes from the last letter of shapr.
11:32:28 <shapr> My next guess is that the n-dimensional tiles equation might have the logic I need to typecheck that sort of thing.
11:33:45 <shapr> Any other ideas?
11:33:56 <basti_> ooooooooo
11:35:27 <shapr> Strange, my mail didn't get to darcs-users.
11:35:38 * shapr has a temper-tantrum
11:36:31 <basti_> hmm shapr i thought about using penrose tilings for audio synthesis btw.
11:37:21 * shapr thinks about that
11:38:02 <shapr> How so?
11:38:27 <shapr> each tile as as a generator or filter? choose standard sides for in/out and modulate?
11:38:38 <shapr> A penrose surface of LADSPA plugins?
11:38:39 <basti_> mmh they could be perfect for waveguides of a drum skin for example
11:39:02 <basti_> they would not have the bizarre artifacts that a regular tiling would exhibit
11:39:17 <basti_> or, at least have bizarre artifacts that are evenly distributed ;)
11:39:17 <shapr> hm!
11:39:28 <shapr> you could use wang tiles for that.
11:39:41 <basti_> i dont understand what wang tiles are exactly yet.
11:39:56 <Muad_AFK> it's always the same people active in here :)
11:40:05 <basti_> yup.
11:40:15 <monochrom> you can make a difference
11:40:20 <shapr> https://www.cs.tau.ac.il/%7Esorkine/courses/sadna04/wang_tiles.html
11:40:34 <Lemmih> That Alexander Jacobsen guy is really starting to annoy me );
11:40:37 <basti_> ah.
11:40:41 <basti_> but ehy are square.
11:40:48 <shapr> That's the same sort of 'irregular distribution' you're talking about.
11:40:51 <basti_> <->/\ x th
11:41:23 <basti_> but in penrose tiles, for example the center points of each rhombus has the same property as the pattern itself
11:41:28 <basti_> in being nonperiodic
11:41:53 <basti_> i would just put delay lines from every center to the center of its neighbor cells
11:42:04 <basti_> or even on the vertices, to the next vertices
11:42:13 <basti_> and then have a high mode density
11:42:21 <SyntaxNinja> alex jacobson has a lot of energyy
11:42:25 <basti_> and the possibility to do the whole thing in 1/5th of "full time" ;)
11:42:32 * SyntaxNinja reads back to Lemmih; heh
11:42:47 <shapr> Does Alex produce as much as he does emails?
11:43:00 <shapr> basti_: you lost me.
11:43:06 <shapr> I got the first part, but not the rest.
11:43:11 <SyntaxNinja> shapr: no clue.
11:43:19 <monochrom> email is part of his production too.
11:43:20 <SyntaxNinja> I have a lot of trouble gathering enough context to understand his emails
11:43:21 <shapr> He did write HAppS.
11:43:46 <shapr> Though I think he should have taken advantage of monads.
11:43:48 <basti_> well the problem in evenly spaced delay lines would be that the "scattering junctions" are equally spaces... allowing build-up of undesired frequencies
11:43:49 <SyntaxNinja> where context == "what hasn't he heard" basically. we say things, he ignores them, we write documents, he ignores them, as far as I can tell, and the ideas don't hold together
11:44:13 <shapr> Well, he shows up here on #haskell as alexj, so you can argue with him directly :-)
11:44:16 <SyntaxNinja> on their own, they're good ideas, but when you look at them in the context of everything else going on, they're often not sound ideas
11:44:23 <Lemmih> @seen alexj
11:44:24 <lambdabot> I haven't seen alexj
11:44:33 <basti_> if you have a pattern that is everywhere almost the same, but does not have these exact scattering junctions as nodes, there is no single mode of vibration
11:44:45 <shapr> basti_: you're still over my head.
11:45:10 <basti_> in a sqare mesh of wires, any wire can vibrate with the "nodes" of a standing wave where the crossings with the other wires are
11:45:33 <basti_> :)
11:45:33 * shapr thinks about that
11:45:49 <basti_> (and of course, multiples)
11:46:07 <shapr> ohhh
11:46:08 <shapr> I get it!
11:46:11 <basti_> great.
11:46:29 <basti_> of course, one could go random too.
11:46:45 <basti_> but rhombes are well-understood
11:46:47 <shapr> That's wild and nifty. Sort of like using penrose patterns to cut down on crosstalk in wires.
11:46:49 <basti_> as opposed to random points
11:46:52 <basti_> o0
11:47:08 <SyntaxNinja> last time I got into it with alexj, several people emailed me and told me I should stop replying
11:47:11 <shapr> haha
11:47:21 <SyntaxNinja> though they were probably doing it more for their own sanity than for my time saving
11:47:41 <shapr> Last time he was here I told him his HAppS source would get dramatically smaller if he started using monads.
11:48:10 <shapr> I am not sure he believed me.
11:49:16 <basti_> that source code is bizarre.
11:49:47 <shapr> Are there higher order harmonics? Sort of like a down spiral of harmonics?
11:50:12 <basti_> hmm?
11:50:26 <basti_> actually there are many notes that overlap in many overtones but not in EVERY overtone
11:50:29 <shapr> Like, rather than straight up multiples, I would think that certain sets of multiple would end up producing what would appear to be chaotic behaviour.
11:50:37 <basti_> like for example the tone with 1.5*f
11:50:39 <SyntaxNinja> I'm not sure anyone is willing to even MENTION what a can of worms "import http://foo.Bar.Bas.hs" would be
11:50:41 <basti_> ("fifth")
11:50:43 <SyntaxNinja> let alone implement it
11:50:48 <Lemmih> I get the feeling that he hasn't got a clue of what Cabal/Hackage is doing (or will eventually do)
11:51:08 <shapr> I also think he has not sufficiently understood Cabal/Hackage..
11:51:19 <SyntaxNinja> Lemmih: yeah, every time I see 'cabal' in his email I have to remind myself that he's not talking about the cabal that I'm picturing.
11:51:29 <SyntaxNinja> ie, the one that exists ;)
11:51:49 <CosmicRay> heh
11:52:06 <basti_> shapr: actually the problem of finding a system that has a chaotic impulse reply is the holy grail search in audio processing ;)
11:52:30 <basti_> theres a theory around "feedback delay networks", that come close and have some provable properties
11:52:31 <shapr> really?
11:52:48 <basti_> not really, but it would be great if you could enlight people on that ;)
11:52:51 <shapr> haha
11:53:15 <basti_> a "noise" impulse response is somewhat the ideal reverb environment
11:53:36 <basti_> if you drop a coin (or something) in a good acoustic environment you will hear slowly decaying noise as it's echo.
11:54:16 <shapr> If you modified the square mesh idea... You'd need something like an odd number of rays from a common center that only reinforce every second next ray.
11:54:41 <basti_> hmm.
11:55:07 <basti_> i dont understand that now.
11:56:17 <shapr> The rays have two effects on each other, one via the common center and one via the harmonic / reinforcing thingy.
11:56:37 <basti_> oh.
11:56:50 <basti_> hmm its hard to do that way
11:57:13 <basti_> if you go like "travelling waves" then you can only connect (or not) two "waveguides" (as they are called)
11:57:39 <shapr> I'll have to read up on this sometime.
11:57:47 <basti_> its a cool topic.
11:57:53 <shapr> It sounds nifty.
11:58:05 <shapr> But I want to hack on pugs right now!
11:58:08 <basti_> ok.
11:58:08 <basti_> =)
12:01:12 <Lemmih> I think I'm just gonna ignore him and see if he goes away.
12:01:42 <basti_> huh?
12:02:16 <Lemmih> Oh sorry. Was refering to Alex.
12:02:22 <basti_> ah.
12:02:23 * basti_ nods
12:04:33 <CosmicRay> Lemmih: that didn't work on me :-)
12:15:24 * Lemmih has become addicted to 'flip map{M_}'
12:15:39 <basti_> flip map {M_}?
12:15:56 <shapr> flip {map,mapM,mapM_}
12:16:05 <Lemmih> Yepper.
12:16:05 <xerox> {} ?
12:16:07 <basti_> ah.
12:16:20 <basti_> that was regex talk for alternative
12:16:41 <xerox> Ah okay.
12:24:17 <tuomov> ghc --make is great
12:24:26 <xerox> It definitely is.
12:24:44 <CosmicRay> slow though, somehow
12:25:51 <shapr> JaffaCake says he'll take out the 'always link' part for next release.
12:25:58 <xerox> CosmicRay *cough*
12:26:32 * CosmicRay hands xerox some medicine
12:27:14 * Oejet 's head explodes.
12:28:14 <CosmicRay> shapr: that's only half of it.  For all the stuff it skips in an average build, it still takes a lot longer than make to find the one thing that needs recompiling
12:28:31 <CosmicRay> I can type "make" and poof, instantly it's compiling what needs it, no noticable delay
12:28:33 <CosmicRay> ghc takes 5-10 seconds
12:28:56 <shapr> We could always update Maak and use it for Cabal.
12:29:01 <Oejet> I'm trying to implement a stack.  The catch is that it should be imperative code and I'm drowning in details.  Anyone care to take a look at http://www.haskell.org/hawiki/HaskellIrcPastePage ?
12:29:57 <basti_> Oejet: i do not understand why your isEmpty is Stack a -> ST Bool.
12:30:03 <basti_> ...for example.
12:31:01 <Oejet> basti_: Me neither. :-P  Maybe it should just be Stack -> Bool since it only depends on the argument.
12:31:22 <Oejet> *Stack a
12:31:31 <basti_> i think so too
12:31:45 <Heffalump> if the stack is stored in STRefs it'll have to have that type
12:31:52 <basti_> oh
12:31:56 <basti_> i didnt know that
12:32:14 <basti_> but that made sense
12:32:31 <Heffalump> any computation that either (a) has a side-effect or (b) depends on other side-effecting computations has to return a value in the ST monad
12:32:31 <Oejet> Heffalump: Only the top pointer.
12:32:39 <Heffalump> otherwise you can't get correct sequencing of actions
12:32:52 * basti_ nods
12:32:55 <Heffalump> STArray counts too
12:33:00 * Oejet nods too.
12:33:01 <basti_> i just didnt know ST
12:33:01 <Heffalump> you can only read/write it in ST
12:33:16 <Heffalump> basti_: it's not really an ST property, it's a general issue with this kind of thing
12:33:33 <basti_> i would have seen it instantly if it had been IO instead of ST
12:34:07 <basti_> didnt reallize ST is the monad of stateful things
12:34:16 <Heffalump> it's true even of a functionally implemented state monad, although then you can cheat by escaping into the internal representation
12:34:17 <basti_> or.. uhm...
12:34:36 <basti_> ah i see
12:35:33 <Lemmih> @seen Hutchs
12:35:34 <lambdabot> I haven't seen Hutchs
12:36:11 <Lemmih> @seen Huschi
12:36:12 <lambdabot> I saw Huschi leaving #haskell 2 hours 24 minutes 52 seconds ago.
12:36:53 <Lemmih> Anyone got that guys email address?
12:37:46 <shapr> Lemmih: http://www.mail-archive.com/ffi@haskell.org/msg01018.html
12:39:38 <Lemmih> Thanks.
12:47:05 <Oejet> I've modified the data structure a bit and I get a strange error.  Pasted at the paste page.
12:47:25 <Oejet> Couldn't match the rigid variable `a' against `a1 i e'
12:55:38 <Heffalump> @type Data.Array.ST.newArray_
12:55:43 <lambdabot> Data.Array.ST.newArray_ :: forall e
12:55:43 <lambdabot>                                   (a :: * -> * -> *)
12:55:43 <lambdabot>                                   (m :: * -> *)
12:55:43 <lambdabot>                                   i.
12:55:43 <lambdabot>                            (Data.Array.Base.MArray a e m, GHC.Arr.Ix i)
12:55:44 <lambdabot> =>
12:55:46 <lambdabot>                            (i, i) -> m (a i e)
12:56:02 <Heffalump> new should have type Int -> ST (Stack s a)
12:56:58 <Oejet> Because of "m (a i e)", where m = ST.
12:57:49 <Oejet> new :: Int -> ST s (Stack s a)
12:58:31 <Heffalump> yes, sorry
13:04:06 <Oejet> isEmpty :: ST s (Stack s a) -> Bool
13:04:06 <Oejet> isEmpty arr =
13:04:06 <Oejet>     if (runSTArray arr)!0 == 0
13:04:06 <Oejet>        then True
13:04:06 <Oejet>        else False
13:04:15 <Oejet> Gives the same kind of error.
13:05:59 <Oejet> Doh.
13:09:25 <wilx> Gagh!
13:13:11 <basti_> huh?
13:14:36 <basti_> hmm
13:15:44 <SyntaxNinja> MegaMonad: huh?
13:15:44 <MegaMonad> SyntaxNinja: Tromp: huh! I missed the right argument of ^ extends.
13:15:59 <Heffalump> oejet: ST s in the wrong place, as I guess you realised.
13:17:03 <Oejet> Heffalump: Hm, then how about:
13:17:08 <Oejet> isEmpty :: (Stack s a) -> Bool
13:17:08 <Oejet> isEmpty (Stack arr top) =
13:17:08 <Oejet>     if (runST (readSTRef top)) == 0
13:17:08 <Oejet>        then True
13:17:08 <Oejet>        else False
13:17:19 <Heffalump> won't work.
13:17:28 <Oejet> Heffalump: I know. :-)
13:17:29 <Heffalump> you can't let the 's' type variable escape.
13:17:36 <Heffalump> you have to use Stack s a -> ST s Bool
13:17:44 <Heffalump> (read the original paper about ST to understand why)
13:18:03 <Heffalump> informally, what you are trying to do above would violate sequencing
13:18:07 <Heffalump> s/would/could/
13:18:45 <Oejet> Ah, because top could depend on arr and array is not considered there.
13:20:43 <Oejet> Wow: Quantified type variable `a' is unified with another quantified type variable s
13:21:11 <Oejet> Doh.
13:21:15 <Heffalump> you forgot an s somewhere
13:21:50 <Oejet> I wrote: isEmpty :: (Stack s a) -> ST a Bool    (should be ST s Bool)
13:21:52 <Heffalump> oejet: not just because top could depend on arr, but also because you have to keep all uses of the same STRef/STArray within the same runST
13:22:30 <Oejet> Yes, so I would have to make a runST on both at the same time somehow.
13:22:32 <wilx> Yup.
13:22:41 <wilx> And there doesn't seem to be lazy version of STArray.
13:22:59 <Oejet> wilx: Which means?
13:23:19 <wilx> That your only choice is strict ST :)
13:24:09 <Oejet> wilx: Ah, that was also my intent.
13:24:19 <Heffalump> oejet: that still wouldn't help.
13:24:32 <Heffalump> because other uses of the same Stack have to also be within the same runST
13:24:37 <Heffalump> and the construction of the Stack too
13:24:43 <Heffalump> it's all tied together by the 's' variable.
13:25:01 <Oejet> Like a red string.
13:25:17 <SyntaxNinja> does the new map module have better map & fold ops? like one like foldM
13:25:39 <SyntaxNinja> can I do that with the FiniteMap module? is there something based on functor I could use?
13:27:26 <gzl> hm
13:28:05 <shapr> The new Map is a lot faster at least.
13:29:55 <SyntaxNinja> it freaks me out that there's a 'map' function in Data.Map
13:30:12 <shapr> haha
13:30:17 <shapr> That is weird!
13:30:48 <gzl> so I'm writing this parser for wikitext, and I'm trying to figure out what a good type for wikitext should be so I can use it easily with parsec to handle nested tags. would it be better to do something like data Wiki = Bold [Wiki] | Underline [Wiki] | Text String or write data Text = Bold Text | Underline Text | Plain String and then data Bold = Bold Text or something? (the reason for the [Wiki] is that I want to be able to write stuff like *foo _bar_*, i.e. swit
13:31:18 <gzl> Oejet: I know you were helping me with this earlier, just trying to figure out the nicest way of handling the switching in and out
13:31:25 <basti_> gzl: how about using an existing xml/html/something type?
13:31:50 <Oejet> gzl: Just a moment...
13:31:59 <gzl> basti_: you mean, to see how their type is implemented?
13:32:34 <basti_> gzl: or maybe even utilize it
13:32:49 <basti_> you could write a parser that directly outputs that type
13:33:05 <basti_> so you have a nice abstraction layer
13:35:35 <gzl> hm, well, existing html types appear to be more complicated than what I need
13:35:55 <Oejet> Yay!
13:35:59 <basti_> maybe css + transformed xml? :)
13:36:22 <basti_> (xml is basically blank!)
13:36:44 <basti_> (so you would just "lift" what you got to the xml level and then apply a transformer)
13:36:59 <gzl> i think i'd really prefer to stick with my own simplified type
13:37:24 <basti_> :)
13:37:25 <basti_> k.
13:37:25 <basti_> ;)
13:37:27 <gzl> this stuff has to end up in WASH eventually anyway, it's not producing normal static HTML
13:37:30 <basti_> any monads?
13:38:19 <gzl> i mean, parsec uses monads, but i don't see the need for one in this part of the problem
13:38:37 * basti_ ducks
13:38:44 <araujo> what is the url to paste stuff?
13:38:52 <shapr> @wiki HaskellIrcPastePage
13:38:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:38:56 <basti_> lisppaste2: @url
13:38:56 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:38:58 <araujo> thanks
13:38:59 <shapr> Man, I want a shorter page name.
13:39:04 * xerox was writing it by hand, yays to shapr.
13:39:05 <Oejet> basti_, Heffalump and wilx: Thanks for your help, that was really educational.  See the paste page.
13:39:07 <basti_> tinyurl?
13:39:23 <Heffalump> oejet: for your next trick, use monadic quickcheck to write a test suite for it
13:39:51 <xerox> basti_: tinyurls appear to be not-persistent, I think.
13:39:55 <basti_> hmmk
13:41:12 <lisppaste2> araujo pasted "indent problems?" at http://paste.lisp.org/display/7094
13:41:32 <araujo> there it is..
13:41:33 <araujo> 8)
13:42:19 <Oejet> Heffalump: That could be cool.  I don't know anything about monadic quickcheck!  Is it QuickCheck by JH?
13:42:31 <shapr> QuickCheckM
13:42:36 <shapr> the paper is QuickCheckST
13:42:41 <xerox> araujo: "where q x =", maybe?
13:42:50 <shapr> It's not directly usable for the IO monad that I can see.
13:43:13 <shapr> Though I've seen some nifty code snippets by TheHunter that make me wonder what he's doing with QuickCheck :-)
13:43:18 <xerox> araujo: that applies to every other where expression = ... I think.
13:44:15 <araujo> xerox, yes, you are right
13:44:17 <araujo> thanks
13:44:26 <xerox> araujo: np, happy to help!
13:44:55 <Oejet> gzl: I like: data Wiki = Bold [Wiki] | Underline [Wiki] | Text String.  If you can say it out naturally then it's probably a good shot.  Like "a Wikitext is a list of Wiki's, a Wiki is either Bold Wikitext or...".
13:45:32 <gzl> right. the only problem there is getting Parsec to return a list of matches.
13:45:51 <gzl> hmm, or maybe that's not so bad.
13:47:16 <musasabi> one problem is that you cannot really use String for a production system.
13:47:33 <gzl> why?
13:47:41 <musasabi> gzl: memory consumption.
13:47:48 <gzl> oh. well this isn't a production system
13:47:55 <Oejet> gzl: Look for a function "many".
13:48:02 <gzl> yeah, I thought about many
13:48:14 <shapr> hei musasabi, how's code?
13:49:25 <musasabi> shapr: did a nasty hack in php (wiki group authentication from an existing db with very poor structure)
13:49:42 <musasabi> hopefully I can clean myself in haskell when the weekend comes.
13:49:44 <xerox> @index many
13:49:45 <lambdabot> Sorry, I don't know the command "index", try "lambdabot: @listcommands"
13:50:03 <shapr> hah
13:50:11 <basti_> np: Ugress - Manhattan Sapphire (Web Edit)
13:51:02 <gzl> hmm. so let's say I forget about Underline [Wiki] temporarily just to simplify it. then I have boldPat = between (char '#') (char '#')
13:51:16 <gzl> er, woops, didn't mean to paste that. I was thinking to myself
13:51:19 <gzl> ignore :)
13:51:33 * SyntaxNinja has bad coffee w/ too much sugar
13:52:08 <basti_> SyntaxNinja: i dont have sugar for my coffee tomorrow.
13:52:36 * shapr gets the stick out for beating up on extremeperl
13:52:49 <shapr> He just pulled the Turing Machine gambit.
13:52:52 <wilx> Mmm, coffee, good idea.
13:52:54 <shapr> I need a bigger stick.
13:53:16 <Oejet> shapr: Pointer?
13:53:34 <shapr> http://groups.yahoo.com/group/extremeperl/message/209
13:54:11 <gzl> Oejet: may I privmsg you for a minute?
13:55:14 <shapr> I bet I can prove a stick is turing complete.
13:56:00 <musasabi> shapr: maybe cobol or basic could serve...
13:57:02 <shapr> Yes, that's much more tactful than comparing Perl to a stick. Thanks.
13:57:41 <Khisanth> comparing Perl to a rope would be better :)
13:57:53 <basti_> like in "lord of the rings"?
14:03:33 <shapr> Maybe I should do something else until my disbelief expires somewhat.
14:03:54 <basti_> shapr: ? ;)
14:04:46 <shapr> The reply I've written so far is rather emotional, containing mostly incredulous disbelief. That's rarely helpful to the other party in a discussion.
14:05:24 <shapr> Do you ever write up a big long reply to an email, and then save the draft until tomorrow so you can recheck it when you're not in the heat of the moment?
14:06:11 <tmoertel> "a stick as actually a woody tape, upon which one can write or read symbols ... "
14:06:20 <basti_> uhhm i should do that more often
14:06:24 <shapr> tmoertel: right on!
14:06:58 <shapr> tmoertel: Hey, I've seen your name in the pugs AUTHORS file, which code have you written?
14:07:22 <basti_> whos that Rob?
14:07:56 <tmoertel> shapr: almost none; I found an error early on and helped one of the other authors a teensy bit on haskellish style
14:08:09 <shapr> Rob wrote a book about extreme programming in Perl. And he's convinced he can learn all the lessons of Haskell without leaving Perl.
14:08:23 <basti_> hm.
14:08:30 <CosmicRay> which rob is this?
14:08:33 <shapr> The book is fun to read. I disagree with his language learning beliefs.
14:08:39 * basti_ nods
14:08:50 <SyntaxNinja> who's asmd.... ?
14:08:51 <CosmicRay> shapr: indeed
14:08:54 <basti_> does he speak another language than Perl? ;)
14:08:56 <basti_> c prolly
14:09:03 <basti_> but thats like compiled perl anyway
14:09:06 * tmoertel thinks Rob should take a look a dominus's "Higher Order Perl," recently on bookstore shelves
14:09:06 <CosmicRay> heh
14:09:26 <CosmicRay> oh, is the rob under discussion the nick rob on this channel?
14:09:28 <shapr> HOP was mentioned on the list recently, though I forget the end of that thread.
14:09:48 <shapr> CosmicRay: nah, Rob in http://groups.yahoo.com/group/extremeperl/message/209
14:09:49 <tmoertel> while one can write fp-style in Perl, it *costs* more to do so than in Haskell
14:10:04 <CosmicRay> in terms of both programmer time and run time
14:10:05 <shapr> Right, and I'm trying to explain that tactfully.
14:10:05 <basti_> btw. i think we're living in interesting times. In my Perception, Hackerdom and Science come closer.
14:10:24 <CosmicRay> tmoertel: and then what about the laziness and haskell's type system?
14:10:27 <basti_> i mean, alone this channel here.... wow.
14:10:36 <shapr> He's just asked that if Perl can do turing machines, isn't that close enough?
14:10:37 <CosmicRay> tmoertel: those are integral parts of haskell and I don't think one could trivially simulate those in perl
14:10:47 <CosmicRay> shapr: hah
14:10:59 <tmoertel> CosmicRay: the type system is actually one of the big benefits that most people who come from untyped -- er, "duck" typed -- languges discount
14:11:12 <CosmicRay> tmoertel: I can see that
14:11:22 <shapr> Yeah, Rob said that strong typing is for programming in big companies who can't communicate.
14:11:28 <shapr> er "programmers"
14:11:30 <CosmicRay> tmoertel: it is one of the most unique features of haskell
14:11:42 <tmoertel> CosmicRay: you type too fast -- you typed my reply before I could! ;-)
14:11:45 <shapr> I pointed him to SPJ's financial combinators paper.
14:11:49 <CosmicRay> shapr: it sounds like this guy is not willing to put forth the intellectual energy to even trivially understand something
14:11:57 <CosmicRay> tmoertel: <grin>
14:12:05 <tmoertel> shapr: that is the *perfect* paper to use
14:12:14 <CosmicRay> tmoertel: it runs in the family.  grandma could type 120 words/min on a manual typewriter. :-)
14:12:42 <shapr> I also mentioned how HaskellDB can generate sane SQL, *and* does higher-order queries.
14:12:56 <CosmicRay> shapr: to put it a different way, this rob guy is the sort of person that used to make me frustrated with the perl community
14:13:02 <tmoertel> CosmicRay: I'm on a "decompression" break, and so I am enjoying a nice cup of tea and typing s l o w l y
14:13:03 <shapr> For the first part, he showed his own perl code to generate SQL. He hasn't responded to the second part.
14:13:07 <CosmicRay> tmoertel: heh
14:13:14 <Philippa_> shapr: static typing is because I fuck up and I want the compiler to tell me. Haskell actually lets me tell it usefully what's likely to be a fuckup and let it do the rest of the work.
14:13:27 <basti_> btw., perl has its own typings
14:13:32 <CosmicRay> Philippa_: well put
14:13:35 <shapr> Rob makes the point that you still need software testing with static typing, so why use static typing?
14:13:37 <CosmicRay> basti_: yes but much less useful
14:13:44 <basti_> yes.
14:13:48 <shapr> Personally, I want as many crutches as I can get.
14:13:57 <CosmicRay> shapr: if it costs nothing thanks to type inference, why not catch errors as early as possible?
14:14:06 <Philippa_> because it reliably and quickly catches multiple things at once that tests take a while about
14:14:08 <tmoertel> static typing frees you to break complex things into tiny pieces that can be glued together reliably
14:14:08 <shapr> Right, I mentioned compile-time dynamic typing.
14:14:17 <shapr> tmoertel: yes, but that's very hard to explain.
14:14:27 <CosmicRay> here's a concrete example.  I'm working on a webapp and had to make a logic change.  With Haskell, I can tweak my code and know that if it compiles, it will run
14:14:28 <Philippa_> and it doesn't so much unless you're coding in a pure language
14:14:33 <CosmicRay> may not produce the correct result but it will run
14:14:40 <CosmicRay> it gives me more confidence to hack-and-deploy
14:14:41 <tmoertel> shapr: in truth, maybe it cannot be explained but only experienced to be understood
14:14:48 <Philippa_> it /does/ allow you to reduce a big problem to a pile of verified and trusted code and a little problem
14:15:11 <CosmicRay> Philippa_: ocaml is not pure but has a similar typing system
14:15:15 <shapr> Rob also said that Letrotest is another reason to not learn Haskell :-)
14:15:21 <CosmicRay> shapr: this may be of interest http://merjis.com/developers/ocaml_tutorial/
14:15:23 <shapr> 'Lectrotest'
14:15:36 <CosmicRay> shapr: while it's for ocaml, it is designed for "C, C++, Perl, and Java programmers"
14:15:41 <Philippa_> CosmicRay: it also has a pile more ways for code to fuck up without you having a reasonable indication that particular fuckup can occur
14:15:44 <CosmicRay> shapr: and could help with the basic ideas
14:15:55 <CosmicRay> Philippa_: which "it", Haskell or Perl?
14:15:58 <Philippa_> cf an entire program in the IO monad
14:15:58 <tmoertel> shapr: what! he's using my own code against me!!!!  ;-)
14:16:03 <Philippa_> ocaml
14:16:10 <shapr> I get the impression that Rob doesn't want to step outside of the Perl world.
14:16:14 <CosmicRay> Philippa_: ah.  right.
14:16:18 <Philippa_> I was responding to the comment you'd addressed directly to me
14:16:22 <CosmicRay> shapr: the "perl 5" world.
14:16:26 <shapr> heh, true.
14:16:48 <CosmicRay> have to be specific.  I used to work with a guy that didn't want to step outside of the perl 4 world. :-)
14:17:16 <SyntaxNinja> oh my
14:17:20 <wilx> Huh, I haven't seen Perl4 but I have been told it was scary language :)
14:17:36 <CosmicRay> wilx: I've seen only small bits.  that was my impression too.
14:17:57 * tmoertel used to think only 6502 assembly was the "true" language
14:17:59 * Philippa_ just suggested on c.l.f that considering pure syntax as sugar for values of type m a (with a monad Pure and return :: (Monad m) => Pure a -> m a) would be better than ML + effect system
14:18:00 <CosmicRay> imagine if you can that perl5 is a much cleaner, saner language than perl4.
14:18:12 <basti_> tmoertel: -g-
14:18:24 <Philippa_> (with the implication that hey, go ahead and make the lang strict, or better yet have PureStrict and PureLazy monads...)
14:18:26 <CosmicRay> tmoertel: heh, that's not portable enough to run on my alpha, therefore it sucks :-)
14:18:27 <basti_> CosmicRay: lol
14:19:30 <tmoertel> CosmicRay: get an emulator from http://www.6502.org/
14:19:46 <CosmicRay> tmoertel: I was afraid that there would be an emulator somewhere :-)
14:20:19 <wilx> Huh.
14:20:44 <wilx> Assembler is like the worst thing that could have happened to me.
14:20:52 <basti_> aw no.
14:20:57 <basti_> its a bit like a puzzle
14:21:04 <basti_> teaches you patience.
14:21:07 <Darius> Assembly is fun
14:21:10 <wilx> I had to do a course on uni that forced me to do things in x86 asm.
14:21:14 <basti_> ----------- *type* *think* *think*
14:21:19 <shapr> I'm beginning to think there's nothing I can say to Rob that will encourage him to learn Haskell.
14:21:22 <wilx> It was horrid.
14:21:26 <Philippa_> I never /had/ to code in it - it's useful to've had happen to me, because I have a fairly holistic view of computational systems as a result (granted I've not done CPU design)
14:21:29 <wilx> I couldn't keep track of things.
14:21:35 <Darius> shapr: It's not just Haskell.
14:21:40 <Philippa_> shapr: quite possibly not
14:21:56 <SyntaxNinja> shapr: you should let him know that he's convinced you that he won't learn haskell, but not that he's in any way right ;)
14:22:00 <CosmicRay> wilx: I had to do one of those courses too.
14:22:02 <CosmicRay> wilx: in dos.
14:22:06 <wilx> Yup.
14:22:17 * basti_ started programming on a HP41c
14:22:21 <shapr> SyntaxNinja: that's a good approach.
14:22:39 <CosmicRay> basti_: nice.  does that use saturn asm?
14:22:49 * CosmicRay just guessing based on his hp48gx
14:22:50 <basti_> i'm talking the stack language.
14:23:03 <Philippa_> DOS wasn't too bad on the whole
14:23:03 <CosmicRay> ah
14:23:10 <Darius> It's even more fun in DOS or some equally unprotective system.  Programming assembly in Win32 or (likely Linux as welL) is like programming C but even more annoying (but you can do cooler things).
14:23:15 <basti_> it had a fabulous memory of a whopping 1000-something instructions
14:23:16 <Philippa_> I mean, x86 asm sucks these days, but back then it wasn't so bad
14:23:26 <CosmicRay> Philippa_: dos deserves to rot in hell with a special place next to a copy-protected copy of lotus 1-2-3
14:23:27 <Philippa_> Darius: agreed
14:23:37 <Darius> Using it by hand isn't that bad, compiling to it is a pain in the ass.
14:23:38 <Philippa_> CosmicRay: Nah. It's a great bootstrap
14:23:41 <CosmicRay> heh
14:23:46 <CosmicRay> ok it works for that. :-)
14:23:51 <CosmicRay> I prefer grub though :-)
14:24:00 <shapr> Speaking of copy-protected, the Linux demo of Darwinia ate my keyboard. I had to ssh in from another box and kill it.
14:24:11 <tuomov> dos was better than anything that has come from that company after it
14:24:18 * basti_ has no mercy with hanging systems.
14:24:21 <Philippa_> it's easier to check settings-type stuff in DOS than grub AFAIK
14:24:29 <tuomov> dos doesn't hang, the programs do :)
14:24:32 <shapr> tuomov: hey, I found a segfault in the ion3-be-really-scared deb :-)
14:24:48 <tuomov> backtrace?
14:24:51 <basti_> tuomov: my linux sometimes falls into helen keller mode
14:25:05 <shapr> would the backtrace be in .xsession-errors?
14:25:09 <Philippa_> tuomov: right :-) Back when everybody was on VGA it was a fun thing to write games for
14:25:19 <Philippa_> mode X and all that
14:25:25 <tuomov> it was cool
14:25:37 <tuomov> it was easy to write graphical programs even in asm back then
14:25:43 <Philippa_> I really resent the fact modern cards labelled 'Sound Blaster' aren't actually Sound Blaster compatible
14:25:45 <basti_> yup
14:25:52 <Philippa_> "here, have a frame buffer" :-)
14:25:53 <CosmicRay> Philippa_: really?  that is weird
14:25:56 <basti_> shift left & add  == *320 ;)
14:26:06 <basti_> int 13h
14:26:06 <Philippa_> it's been the case since the audigy was introduced
14:26:19 <CosmicRay> Philippa_: so SET BLASTER=A220 I5 D1 won't work, eh? :-)
14:26:23 <tuomov> mov es, 0xa000
14:26:26 <basti_> well we've got abstractions now.
14:26:28 <basti_> ugh yes
14:26:31 <shapr> tuomov: does this help? ion3: [294758] X_ConfigureWindow (12) 0x8078eb: BadMatch (invalid parameter attributes) \n ion3: Caught fatal signal 11. Dying without deinit. \n /home/shae/.xsession: line 3:  5705 Segmentation fault      ion3
14:26:33 * basti_ shudders
14:26:34 <tuomov> or how was hex written then..
14:26:42 <Philippa_> CosmicRay: bingo. Nothing requesting the relevant resources via PnP
14:26:46 <basti_> sometimes like in c, sometimes with a trailing h
14:26:47 <tuomov> shapr: no. I'd need gdb output
14:26:50 <basti_> different
14:27:01 <shapr> foo :-(
14:27:10 <CosmicRay> shapr: was yours the box that was running out of ram also?
14:27:14 <tuomov> badmatch it not necessarily a problem even
14:27:15 <shapr> yes.
14:27:20 <CosmicRay> shapr: I think your hardware is sick.
14:27:26 <shapr> Yes, I think so too :-(
14:27:35 <shapr> I had to pure ghc6 and reinstall to build pugs.
14:27:43 <shapr> something was *really* fuct
14:27:45 <CosmicRay> shapr: either that or this ion3 driver is doing some seriously bad juju
14:27:50 <CosmicRay> shapr: ah, that is a bad sign.
14:27:56 <CosmicRay> any errors in dmesg?
14:28:20 <shapr> No more than usual. I have ECC Scrub ram, and it reports an error corrected every few days.
14:28:37 <CosmicRay> nifty, I guess
14:28:41 <shapr> Expensive.
14:28:44 <CosmicRay> is that a usual pattern for that type of ram?
14:28:47 <basti_> mh
14:28:52 <shapr> I don't know.
14:28:54 <CosmicRay> or does this perhaps indicate that there are also undetected errors out there?
14:28:57 * basti_ takes the stochastic approach to computers.
14:29:06 <shapr> I've never had registered ECC ++ ram before.
14:29:16 <CosmicRay> me neither
14:29:20 <basti_> its okay if it works most of the time.
14:29:21 <basti_> ;)
14:29:37 <CosmicRay> basti_: if only microsoft could rise to those standards :-)
14:29:44 <basti_> -g-
14:29:48 <shapr> But I have some leftover cash from the recent work binge and months of saving up. Can I get quad amd64 box for ~2000 euro?
14:29:49 <basti_> and thats just for the hardware.
14:29:56 <basti_> because hardware issues are easy to trace.
14:29:59 <basti_> and to solve
14:30:02 <gzl> quad? blimey, what are you doing :)
14:30:07 <CosmicRay> shapr:  probably so
14:30:07 <basti_> software is on another shelf.
14:30:09 <shapr> gzl: web development of course!
14:30:14 <CosmicRay> hah
14:30:15 <Darius> gzl: He needs something to heat his house.
14:30:17 <basti_> a few notches higher demands there ;)
14:30:19 <gzl> Darius: haha
14:30:19 * shapr laughs
14:30:23 <Darius> It might as well be doing real work as well.
14:31:15 <CosmicRay> yeah,  box like that could crank out windows worms at a frightening rate.
14:31:28 <shapr> C'mon, I'll be using it to test SMP GHC!
14:31:29 <CosmicRay> just don't let it fall into a botnet
14:31:33 <CosmicRay> sure sure sure
14:31:40 <CosmicRay> we all know it's for grand theft auto :-)
14:31:51 <shapr> Does that run on Linux?
14:31:57 <CosmicRay> no
14:32:01 <shapr> Oh. too bad.
14:32:42 <Igloo> But DOTT does, so all is right with the world!
14:34:29 <CosmicRay> shapr: maybe it runs under hos :-)
14:35:06 <CosmicRay> MegaMonad: Hey, it's april 1!
14:35:07 <MegaMonad> CosmicRay: We're in chapter 72, subsection a.98.a.1 of the n+k patterns, what happens if you really have to be doing until april?
14:35:24 <shapr> wow, cool quote.
14:36:06 <shapr> yeesh, quad amd64 mobos are ~$1500 USD
14:36:12 <Heffalump> is that all?
14:36:15 <CosmicRay> heh
14:36:17 <Heffalump> how much more for the CPUs?
14:36:23 <CosmicRay> what is that in EUR, 1000?
14:36:28 <jlouis> We should agree on some style for lambdabot
14:36:34 <CosmicRay> are you speaking opterons here?
14:36:38 <shapr> jlouis: lambdabot has style already!
14:36:41 <CosmicRay> MegaMonad: lambdabot needs style
14:36:42 <MegaMonad> CosmicRay: I downloaded hugs for the new hopengl is supposed to give them each unique input, the function needs the parser needs to do a javadoc-style output.
14:36:53 <shapr> CosmicRay: sadly, quad mobos will require 8xx opterons
14:36:57 <CosmicRay> MegaMonad: I didn't mean javadoc style
14:36:57 <MegaMonad> CosmicRay: Are you in the style of the javadoc apis.
14:37:04 <CosmicRay> shapr: ahh so the cpus will cost ya too
14:37:47 <shapr> Yeah, you can get the 4xx series for a dualie, but only 8xx have two working connections to other CPUs.
14:39:19 <shapr> Pricewatch has 844s for 550-675
14:39:31 * tmoertel has a friend who is getting a few Sun Fire v20z
14:39:38 <CosmicRay> shapr: USD or EUR
14:39:41 <shapr> USD
14:39:52 <shapr> I wish I could get a Cell workstation.
14:39:59 <shapr> Can't find anything though.
14:40:40 <tmoertel> my next box will probably be an Athlon64; best bang for the buck
14:40:49 <CosmicRay> yeah I really like my athlon64 boxen
14:41:05 <tmoertel> the trick is getting a mobo w/ good ECC support
14:41:22 <tmoertel> and then stacking up the RAM to the ceiling
14:41:28 <CosmicRay> heh
14:41:58 <CosmicRay> shapr: I am getting really depressed about python.  I don't want to maintain my python code anymore.
14:42:04 <shapr> :-(
14:42:07 <CosmicRay> shapr: that means I have to write an IMAP library for haskell
14:42:09 <shapr> orphan it!
14:42:12 <CosmicRay> heh
14:42:14 <shapr> CosmicRay: I'm with you!
14:42:16 <CosmicRay> but I use it :-)
14:42:21 <shapr> rewrite it!
14:42:26 <shapr> It's good brain exercise.
14:42:28 <shapr> I do that too.
14:42:34 <CosmicRay> yes, but I have to write an IMAP library for haskell first :-)
14:42:38 <CosmicRay> yeah I know
14:42:40 <tmoertel> CosmicRay: solution: python -> haskell
14:42:42 <shapr> I port my Python/elisp/shell scripts to Haskell.
14:42:43 <CosmicRay> porting offlineimap to haskell would be fun
14:43:00 <CosmicRay> well offlineimap is a tad larger and more complex than a script :-)
14:43:05 <Darius> CosmicRay: What prompted the above comment?
14:43:06 <shapr> Or I port them to Joy, or something else. I've never finished a port to Joy, sadly.
14:43:19 <CosmicRay> Darius: the general direction python development is taking these days
14:43:32 <CosmicRay> Darius: the plans to eliminate some of my favorite features from Python 3
14:43:41 <CosmicRay> Darius: and the lack of anything useful happening in the 2.x series
14:44:24 <CosmicRay> shapr:  offlineimap does a multithreaded, bidirectional mail synchronization between imap servers, or between an imap server and a maildir hierarchy, and its configuration file can use python lambda functions
14:44:33 <CosmicRay> shapr: for things like selecting which folders to use and whatnot
14:44:43 <shapr> Hm, sounds workable.
14:44:57 <CosmicRay> shapr: I think it will actually be simpler to code in haskell thanks to its really nifty "threads"
14:45:06 <shapr> Why not use STM instead?
14:45:12 <CosmicRay> shapr: STM?
14:45:25 <CosmicRay> shapr: however an imap library is not an interesting problem, but a time-consuming one.
14:45:38 <shapr> Is concurrent based on STM in 6.4?
14:45:51 <CosmicRay> what's stm?
14:45:59 <shapr> I disagree, you've already written it in Python. Now you can do something cool!
14:46:08 <shapr> Software Transactional Memory
14:46:15 <Darius> We've had this discussion before; instead of making IMAP you make ProtocolGen and pop out SMTP,POP,FTP,HTTP, and IMAP.
14:46:27 <CosmicRay> shapr: no, I didn't write the imaplib.py in Python
14:46:36 <CosmicRay> shapr: I am a constant critic of it, in fact :-)
14:46:38 <shapr> question is, how to write ProtocolGen?
14:46:50 <CosmicRay> Darius: so, protocolgen takes an RFC and returns a CharParser? :-)
14:46:57 <shapr> I thought about a 'BNF-style' state machine that outputs arrows.
14:47:11 <shapr> CosmicRay: sure, why not?
14:47:18 * Philippa_ wonders if you could bastardise Parsec and Yampa together appropriately
14:47:24 <shapr> As long as the RFC declares a BNF state machine
14:47:31 <Darius> CosmicRay: Perhaps with some massaging of the RFC
14:47:38 <CosmicRay> Darius: actually someone (Peter?) wrote up a little module with parsec versions of a lot of the standard RFC primitives
14:47:39 <shapr> You'd want to port Parsec to an arrow-style parser first.
14:47:59 <Darius> Kleisli Parser
14:48:00 <CosmicRay> Darius: so it's not hard to convert an rfc to parsec.  but imap is a very detailed protocol, with all sorts of paths, so it just takes awhile.
14:48:09 <Philippa_> shapr: not necessarily, you could just stick Parsec on the input end?
14:48:21 <shapr> True
14:48:31 <Philippa_> with mebbe the output end getting to run in the same parsec 'instance' so it can frig with the state where needed
14:49:27 <Philippa_> so a signal function from parsec results to (parsec state modification, IO foo)
14:49:56 <Philippa_> (or rather, a stream thereof)
14:51:21 <Lemmih> Latest Hackage-Browser: http://www.scannedinavian.org/~lemmih/HackageBrowser03.png
14:52:11 <Igloo> Nifty
14:52:24 <Igloo> Do you have mostly the same code for the GTK and HTML frontends?
14:53:10 * Igloo wonders what happens when you click on the blue things
14:54:06 <Lemmih> Nothing atm. Integrating Haddock documentation is still in the works.
14:54:40 <Igloo> Oh, right, this is for local packages, not browsing the server?
14:55:46 <Lemmih> It will one day get packages from a Hackage server.
14:56:07 <Lemmih> using ghc-6.4/libraries/*/*.cabal for now.
14:56:22 <Igloo> OK, I get it now  :-)
14:56:39 <Lemmih> Check screenshot 02 for dependencies.
14:57:57 <Lemmih> black = installed, blue = installable, red = unknown. Those colors are of course changable from a config file.
14:58:55 <Igloo> Cool
14:59:31 <Lemmih> It currently doesn't check which packages are installed so they're all blue or red (:
15:08:31 * tmoertel thinks shapr's use of monad transformers here is awesome: http://groups.yahoo.com/group/extremeperl/message/193
15:09:02 * shapr cheers
15:09:09 <tmoertel> grrrr. it started to rain.... must. walk. the. dog. now.
15:09:23 * tmoertel leaves the keyboard momentarily to walk the dog
15:10:24 <tuomov> how do exceptions (in e.g. IO monad) work with transformer stacks btw?
15:11:10 <shapr> I don't understand the question?
15:11:56 <tuomov> it is probably not possible to catch stuff from IO with ErrorT etc.?
15:12:00 <Philippa_> tuomov: work out how the transformer stack translates into an IO computation
15:12:05 <Philippa_> no, it's not
15:12:22 <tuomov> so to catch IO error you would have to catch each IO call
15:12:26 <Philippa_> yep
15:12:28 <Darius> tuomov: You could catch an IO exception and then reify it as an ErrorT Exception
15:12:31 <Philippa_> which you could /do/, but it'd suck
15:12:43 <Darius> tuomov: This is related to the Representing Monads.
15:12:50 <tuomov> yeah, and extended liftIO could work..
15:12:55 <tuomov> -d
15:13:17 <tuomov> I'm thinking of some perverted ErrorT StateT IO ...
15:13:48 <shapr> You should see pugs internals.
15:13:55 <shapr> @quote autrijus
15:13:57 <lambdabot>   Parrot is fine except every time I build it, it fails
15:13:57 <tuomov> although I'd rather have StateT on the outside..
15:19:06 * rik pokes shapr 
15:19:20 <rik> shapr: i will write code when i' mnot in the office 9am to 9pm.
15:19:35 <shapr> w00
15:19:43 <shapr> go home! write code!
15:20:21 <rik> i am at home
15:20:22 <rik> but i'm tired.
15:20:30 <Igloo> What does `foo` mean in python?
15:20:32 <shapr> ok, next time
15:20:50 <shapr> I think backticks is show
15:21:11 <Igloo> OK, ta
15:21:20 <shapr> yes, that's it, show foo
15:21:27 <shapr> I forget whether it's str or repr though.
15:21:47 <Darius> @listmodules
15:21:48 <lambdabot> I have the following modules installed: ["babel","base","dict","dummy","
15:21:48 <lambdabot> dynamic","eval","help","karma","more","pl","plugs","quote","seen","state"
15:21:48 <lambdabot> ,"system","topic","type","version"]
15:21:53 <Darius> @help pl-resume
15:21:54 <lambdabot> @pointless <expr> - play with pointfree code
15:22:12 <shapr> str is show as text to humans, repr is show as text that can be eval'd to get back the same value.
15:28:14 <Darius> @help state
15:28:15 <lambdabot> @state - we all know it's evil
15:28:29 * shapr laughs
15:30:38 <Darius> @help cmafihe
15:30:39 <lambdabot> @help <command>
15:37:33 <Darius> @state
15:37:33 <lambdabot> nothing yet
15:37:36 <Darius> @state foo
15:37:44 <Darius> @state
15:37:45 <lambdabot> foo
15:39:53 <Igloo> Hurrah, final ghc-cvs hopefully building
15:40:07 <shapr> yay
15:57:14 <Khisanth> @quote ?
15:57:15 <lambdabot> ? hasn't said anything memorable
15:57:42 <Khisanth> @quote lambdabot
15:57:43 <lambdabot> lambdabot hasn't said anything memorable
15:59:16 <wilx> @yow
15:59:19 <lambdabot> Couldn't find yow file
15:59:22 <shapr> aww
16:00:42 <TheHunter> @pointless let x = const 3 y; y = const 2 $ z + x; z = const 1 y in x + y + z
16:00:46 <lambdabot> s (flip (s . flip ((.) . ((+) .) . (+)) fst) snd . fst) snd (fix (s (flip
16:00:46 <lambdabot> (s . flip ((.) . s ((.) . (,) . const 3) . flip ((.) . flip . ((,) .) .
16:00:46 <lambdabot> ((const 2 $) .) . flip (+)) (const 1)) fst) snd . fst) snd))
16:00:46 <lambdabot> optimization suspended, use @pl-resume to continue.
16:00:50 <TheHunter> @pl-resume
16:00:54 <lambdabot> 6
16:00:57 <dons> !
16:00:59 <dons> :)
16:01:35 <wilx> Huh.
16:05:00 <Oejet> Pointless, a standard tool in the Haskell obfuscators toolbox.
16:05:45 <Darius> dariusbot: @paste
16:05:46 <dariusbot> Sorry, I don't know the command "paste", try "dariusbot: @listcommands"
16:05:48 <TheHunter> hiya, dariusbot
16:05:49 <dons> now we just need @GHC.*-ify, @unsafeCoerce#-ify, and @THify
16:07:08 <dons> also, a module that rewrite all keywords with lambdas instead, and no-whitespace layout would be good
16:08:36 <Darius> Bah, just write a compiler to Perl.
16:08:52 <dons> ah! I've got ozone on that job ;(
16:08:58 <dons> s/ ;( / ;) /
16:12:14 <Darius> I sent you a simple patch with @paste, it compiles but it isn't tested (hopefully I didn't screw that up).
16:13:08 <dons> more untested patched :P
16:13:16 <Oejet> *Main> quickCheck punit
16:13:17 <Oejet> No instance for (Show (IO ()))
16:13:22 <dons> hehe. I've got it.
16:13:45 <dons> we need a regress framework.
16:14:00 <dons> tricky.
16:14:42 <Darius> dons: It would've been tested, but I forgot to statically load dummy.
16:14:56 <dons> just teasing
16:15:32 <dons> btw, I filled in the @help, but some of them were very brief.
16:15:34 <Oejet> How do I run QuickCheck from GHCi?  It errors like above, so that is clearly not the way.
16:15:47 <Darius> Yeah, I was browsing them earlier.
16:15:50 <dons> Oejet >>= print ?
16:16:02 <TheHunter> Oejet, usually, other instances are missing if it prints that message.
16:16:17 <TheHunter> do you have import Text.Show.Function(s)?
16:18:01 <Darius> @listcommands system
16:18:02 <lambdabot> Module system provides the following commands: ["listchans","listmodules"
16:18:02 <lambdabot> ,"listcommands","join","leave","part","msg","quit","reconnect","echo"]
16:19:08 <shapr> Oejet: quickCheck prop_Foo
16:19:15 <shapr> Oejet: or verboseCheck prop_Foo
16:20:09 <Oejet> punit x = reverse [x] == [x]
16:20:21 <Oejet> *Main> quickCheck punit
16:20:30 <Oejet> Shouldn't that be enough?
16:20:57 <Darius> @type \x -> reverse [x] == [x]
16:21:02 <lambdabot> \x -> reverse [x] == [x] :: forall a. (Eq [a]) => a -> Bool
16:21:06 <TheHunter> nope, you need to specify a type for x
16:21:08 <Darius> @type Debug.QuickCheck.quickCheck
16:21:09 <shapr> yeah
16:21:10 <lambdabot> Debug.QuickCheck.quickCheck :: forall a.
16:21:10 <lambdabot>                                (Test.QuickCheck.Testable a) =>
16:21:10 <lambdabot>                                a -> IO ()
16:21:24 <Heffalump> quick check generates random data to test with
16:21:39 <Heffalump> it can't make up data for an arbitrary type, and it's unaware of parametricity properties
16:21:56 <Oejet> Ah!
16:22:07 <Darius> If it were aware of parametricity properties it could avoid doing some tests altogether!
16:23:34 <Oejet> That makes sence.  My brain must be sleeping by now.  Thanks!  Good night.
16:27:08 <dons> now, I wonder, can we convince lambdabot to run out of ghci
16:30:25 * shapr watches lambdabot run right of ghci, off the edge of the desk and out into the night!
16:30:32 <shapr> um, "right out of "
16:31:16 <dons> hehe
16:31:24 <dons> away, freedom!
16:32:37 <dons> ddarius: gmake -j3 -Onot -fasm : 30.134 sec total. gmake -j1 -O2 -blah -blah 1:22.10 total
16:34:53 <shapr> how many cpus?
16:35:47 <dons> 1
16:36:11 <Cale> shapr: so you've been playing go?
16:36:11 <shapr> you halved the compile time with make -j3 ?
16:36:15 <shapr> Cale: not so far...
16:36:25 <dons> -fasm -Onot mostly, I'd suspect
16:36:41 <Cale> Simon Marlow added himself to the list of GoPeople?
16:36:53 <Darius> I'm building with -Onot currently.
16:37:07 <shapr> Cale: simon said he was 1k not too long ago
16:37:32 <SyntaxNinja> Cale: probably; he was here yesterday
16:37:59 <Darius> He was in the discussion when xerox suggested it.
16:39:00 <dons> @paste
16:39:01 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:41:07 <TheHunter> dons, i send you a PlModule patch, sorry if it's for the second time (i honestly don't remember...)
16:41:21 <dons> just arrived.
16:41:42 <dons> hehe. 4 cpus rock: make -j8 > /dev/null  34.40s user 5.97s system 276% cpu 14.593 total
16:41:53 <dons> 276%
16:42:01 <mflux> short of 400%
16:42:11 <dons> pity I have to share it with 224 users
16:42:11 <mflux> ;)
16:46:54 <TheHunter> man, that's fast. 4:01,72 total here
16:47:10 <shapr> is that lambdabot?
16:47:20 <TheHunter> yep
16:49:09 <shapr> Hm, only took twenty seconds for my build to crap out.
16:49:36 <shapr> something is seriously wrong with my hardware.
16:50:23 <TheHunter> what kind of hardware is that?
16:54:45 <shapr> dual Athlon MP 1544 MHz
16:55:09 <shapr> Which reminds me, this is the first night it's been above freezing. Maybe if I open the window...
16:55:51 <TheHunter> hehe.
16:56:22 <Darius> dariusbot: @paste
16:56:26 <dariusbot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:56:35 <Darius> dariusbot: @type 3
16:56:36 <dariusbot> Prelude.tail: empty list
16:57:06 <TheHunter> shapr, is that one of these "i don't need a fan" kind of things?
16:58:49 <shapr> I have five case fans right now. When do I reach ludicrous?
16:59:26 <dons> @dynamic-reload pl
16:59:27 <lambdabot> module reloaded
16:59:35 <Darius> @help pl-resume
16:59:36 <lambdabot> @pointless <expr> - play with pointfree code
16:59:46 <TheHunter> @pointless liftM2 (+) (return 1) (return 2)
16:59:47 <lambdabot> return 3
16:59:51 <TheHunter> yeah!
16:59:58 <dons> TheHunter: feel free to write detailed @help for Pl
17:00:12 <dons> it's in PlModule.hs:moduleHelp
17:02:18 <Darius> dariusbot: @type 3
17:02:34 <dariusbot> 3 :: forall t. (Num t) => t
17:02:38 <dons> :)
17:02:42 <dons> what's been the problem?
17:03:27 <Darius> The problem last time was just that there is no ghci-6.4
17:03:53 <Darius> The time above was the first time I've even loaded TypeModule (statically).
17:04:14 <dons> ok.
17:04:27 <Darius> But apparently it works on Win32
17:11:50 <dons> TheHunter, can you grab the latest patches. there's a conflict in the help patch.
17:12:13 <dons> I had to add another patch after your new plmodule patch, for -Werror.
17:12:44 <dons> not sure why darcs is complaining though. hmm.
17:13:12 <dons> oh, I see. you've added the same patch.
17:14:49 <TheHunter> did I send you a patch with a warning about an e in transformM?
17:15:08 <TheHunter> sorry about that.
17:15:19 <dons> yeah. I've dealt with it though.
17:15:28 <dons> all's good now. no need for resends
17:16:03 <dons> now, let's see if this works.
17:16:03 <TheHunter> note to self: always compile before darcs send
17:16:08 <dons> @dynamic-reload pl
17:16:09 <lambdabot> module reloaded
17:16:09 <dariusbot> module not loaded
17:16:26 <shapr> darcs record automatically executes darcs test, doesn't it?
17:16:28 <TheHunter> @help pl-resume
17:16:28 <lambdabot> @pl-resume - resume a suspended pointless transformation.
17:16:28 <dariusbot> @help <command>
17:16:29 <dariusbot> Sorry, I don't know the command "pl-resume", try "dariusbot: @listcommands"
17:16:29 <lambdabot> @help <command>
17:16:30 <dariusbot> @help <command>
17:16:30 <lambdabot> @help <command>
17:16:31 <dariusbot> @help <command>
17:16:32 <lambdabot> @help <command>
17:16:33 <dariusbot> @help <command>
17:16:33 <lambdabot> @help <command>
17:16:34 <dariusbot> @help <command>
17:16:35 <lambdabot> @help <command>
17:16:35 <dariusbot> @help <command>
17:16:36 <lambdabot> @help <command>
17:16:36 <dons> yikes!
17:16:37 <dariusbot> @help <command>
17:16:38 <lambdabot> @help <command>
17:16:38 <dariusbot> @help <command>
17:16:39 <lambdabot> @help <command>
17:16:40 <dariusbot> @help <command>
17:16:41 <lambdabot> @help <command>
17:16:41 <dariusbot> @help <command>
17:16:42 <lambdabot> @help <command>
17:16:43 <dariusbot> @help <command>
17:16:43 <lambdabot> @help <command>
17:16:44 <dariusbot> @help <command>
17:16:45 <lambdabot> @help <command>
17:16:45 <dariusbot> @help <command>
17:16:46 <lambdabot> @help <command>
17:16:47 <dariusbot> @help <command>
17:16:48 <lambdabot> @help <command>
17:16:48 <shapr> lambdabot: @part #haskell
17:16:50 <dariusbot> @help <command>
17:16:57 <shapr> that was fun.
17:17:06 <dons> we need a fix.
17:17:16 <shapr> Ther IRC RFC has a fix.
17:17:24 <shapr> don't use ircMsg, only use Notice
17:17:31 <shapr> it's specifically for that problem.
17:17:37 <dons> ok.
17:18:08 <dons> hmm, also, lambdabot help's could avoid returning valid lambdabot commands
17:18:18 <shapr> Yeah, that's what I did in the past.
17:18:45 <shapr> But the idea with notice is that automatic processes send notice feedback, and only take commands via ircMsg
17:19:08 <dons> ok, a little bit of lambdabot diving then.
17:19:40 <dons> but that sounds like a decent fix
17:20:09 <shapr> I meant to switch to notice long ago...
17:21:23 <Darius> dons: I was thinking about that when I first wrote @help, but decided to go for the more user friendly form, because there typically is only one 'bot on the channel.
17:21:32 * Darius should've killed dariusbot earlier.
17:21:42 <shapr> On the good side, switching to notice and only accepting msg inputs will mean no longer needing to check for own nickname.
17:21:50 <dons> adding a single space in front of @help should work for now.
17:22:04 <dons> yeah, sounds good.
17:22:11 <shapr> until the inline @@command format is finished!
17:22:30 <dons> he
17:23:58 <dons> @dynamic-reload help
17:23:59 <lambdabot> module reloaded
17:24:03 <dons> @hellp
17:24:03 <lambdabot> Sorry, I don't know the command "hellp", try "lambdabot: @listcommands"
17:24:04 <dons> @help
17:24:05 <lambdabot>  @help <command> - ask for help for <command>
17:24:59 <Darius> Is that with a leading space?
17:25:03 <dons> yeah.
17:25:24 <dons> '  @'
17:26:34 -TheHunter(~TheHunter@p54AB0B4D.dip0.t-ipconnect.de)- test
17:26:35 <shapr> check out #joy :_)
17:26:50 <shapr> lambdabot-shae does notice now :-)
17:27:05 <shapr> lambdabot: y0 y0
17:27:06 <lambdabot> Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:27:11 <shapr> lambdabot-shae: y0 y0
17:27:12 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- Sorry, I'm not a very smart bot yet, try "lambdabot-shae: @listcommands"
17:27:44 * shapr will send patch
17:27:56 <TheHunter> lambdabot-shae, @help
17:27:57 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- @help <command>
17:28:02 <shapr> @help
17:28:02 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- @help <command>
17:28:03 <lambdabot>  @help <command> - ask for help for <command>
17:28:16 <TheHunter> lambdabot-shae, @help
17:28:16 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- @help <command>
17:28:35 <TheHunter> hmm.
17:29:12 <TheHunter> any way that doesn't display -lambdabot-shae/#haskell-?
17:29:25 <shapr> I see -lambdabot-shae- @help <command>
17:29:39 * Igloo looks up, and thinks how apt it is for #haskell to discover recursion  :-)
17:30:09 <dons> yay!
17:30:21 <Darius> lambdabot: @eval "@foo"
17:30:22 <lambdabot> @foo
17:30:22 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- Sorry, I don't know the command "foo", try "lambdabot-shae: @listcommands"
17:30:32 <Darius> lambdabot-shae: @eval "@foo"
17:30:33 -lambdabot-shae(~lambdabot@c-08b1e253.014-109-626f6410.cust.bredbandsbolaget.se)- @foo
17:30:38 <shapr> no loop
17:30:39 <dons> that's good.
17:30:44 <dons> shapr: patches!
17:30:50 <shapr> right away
17:31:01 <shapr> lambdabot-shae: @quit
17:31:14 <Darius> shapr: Did you patch ircPrivmsg, HelpModule, or everything that uses ircPrivmsg, or something else?
17:31:27 <Darius> Well obviously not HelpModule.
17:31:36 <dons> I wonder.
17:32:36 <Darius> So, it only took a coupla years, but lambdabot will be (more) RFC compliant.
17:33:43 <shapr> I patched ircPrivmsg', I made the huge change of switching the word PRIVMSG to NOTICE
17:34:07 <dons> cool.
17:34:14 <dons> I wonder if anything breaks..
17:34:32 <shapr> Of course, I am now coming face to face with my past Haskillz as shown in lambdabot. And it's not very tasty.
17:37:44 <TheHunter> quick darcs question: how do I sync my repository with don's?
17:37:54 <dons> darcs pull
17:38:24 <TheHunter> yeah, but that produces unresolved conflicts.
17:38:37 <dons> hmm.
17:38:45 <TheHunter> i want exactly your version, i.e what happens if i darcs get everything again.
17:39:12 <ddarius> You get whatever is in dons darcs repo
17:39:38 <TheHunter> plus my proprietary patches.
17:40:24 <ddarius> Perhaps you should darcs get dons repo in a different directory then pull or push from your repo the changes you want.
17:41:11 <TheHunter> ok, I can do that.
17:41:21 <TheHunter> thanks.
17:41:40 <dons> now, is there anyway to dynamic-reload IRC.o
17:41:44 <dons> I'm not sure.
17:41:53 <TheHunter> @help
17:41:54 <lambdabot>  @help <command> - ask for help for <command>
17:42:04 <ddarius> TheHunter: I'm not a darcs expert, but that seems plausible.
17:42:11 <wilx> lambdabot, @help
17:42:58 <dons> ok, I think I'll have to restart the little bot to get  the new IRC.o
17:43:47 <dons> @version
17:43:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
17:43:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:44:47 <shapr> yay!
17:45:12 <autrijus> whew. aix bindist for ghc 6.4 coming soon
17:45:21 <autrijus> pugs is dropping 6.2.2 support and embracing GADTs.
17:45:27 <shapr> happiness!
17:45:30 <autrijus> happiness!
17:45:38 <shapr> I like GADTs.
17:45:40 <dons> poor 6.2.2 - it was a solid compiler
17:45:50 <autrijus> yeah but I got sick of maintaining #ifdefs
17:45:57 <autrijus> esp. for System.* and TH
17:46:02 <dons> yep.
17:46:48 <Heffalump> you've changed all lambdabot's responses to NOTICE?
17:47:08 <Heffalump> everyone ignores that bit of the RFC, and it looks horrible. So I disagree with doing that :-)
17:47:10 <shapr> hey autrijus, is there a way to test most/all the separate pugs subtests together in a single test? I'd like a test suite where I can run everything in less than ten seconds.
17:47:26 <TheHunter> Heffalump, using xchat, too?
17:47:31 <autrijus> shapr: say again?
17:47:35 <autrijus> "make test" does it for you
17:47:43 <Heffalump> no, irssi
17:48:03 <shapr> I'd like a make test that takes less than ten seconds. Do you think that's possible?
17:48:06 <dons> Heffalump, you can tweak your default.config.
17:48:21 <autrijus> shapr: uh. hrm. no.
17:48:28 <autrijus> you can speed up by "make optimized"
17:48:33 <autrijus> but the test suite is just huge :)
17:48:50 <shapr> does that do something like one functional test for each major subchunk instead of every unit test?
17:49:20 <autrijus> no, make test runs all subtests.
17:49:41 * Darius never thought he'd go to use.perl.org regularly.
17:49:45 <autrijus> if you'd like to have an "overview" test written, that's fine for me, but I'm not sure how would one go about to do that
17:49:57 <dons> @plugs reverse [0..10]
17:49:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [10,9,8,7,6,5,4,3,2,1,0]
17:50:07 <shapr> I think I can do the overview tests myself.
17:50:09 <dons> Heffalump:
17:50:10 <dons>   pubnotice_channel = "%K";
17:50:10 <dons>   pvtnotice_host = "%K";
17:50:14 <autrijus> Darius: some camelfolk never thought they'll go to hawiki regularly too :D
17:50:33 <shapr> I got The Monad.Reader quoted at me today on #perl6, I was entertained.
17:50:52 <Heffalump> dons: ta.
17:50:53 <TheHunter> @version
17:50:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
17:50:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:51:17 <Heffalump> but still, getting everyone stuck with this ugliness unless they go to extra work is not ideal
17:51:27 <TheHunter> @version
17:51:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
17:51:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:51:42 <Khisanth> why is lambdabot using notices?
17:52:09 <dons> to stop the bot battles
17:52:32 <Heffalump> @version
17:52:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
17:52:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:52:50 <shapr> autrijus: If I wrote acceptance tests for pugs, do you think the developers would actually use them?
17:53:03 <shapr> hm, well. I would.
17:53:11 <Heffalump> oh, was MegaMonad being stupid?
17:53:14 <Heffalump> I have MegaMonad ignored.
17:53:29 <dons> dariusbot vs lambdabot in the ultimate battle for channel domination
17:54:00 <autrijus> shapr: I would.
17:54:02 <Darius> dariusbot won! but then was killed
17:54:14 <shapr> autrijus: excellent.
17:54:20 <shapr> Darius: haha
17:54:28 <Darius> "Victories don't mean a thing if they don't last"
17:56:41 <dons> Heffalump, notice = "%K%n$*%K::%n "; might be even better.
17:56:58 <Heffalump> where does the setting go?
17:56:58 <dons> though you'd tweak it for your nick format.
17:57:09 <dons> ~/.irssi/default.config
17:57:19 <SyntaxNinja> why does lambdabot keep msging me?
17:57:19 <Heffalump> even if that's non-existent now?
17:57:22 <dons> default.theme
17:57:32 <shapr> dons: btw, you could just send me a repo with the synhl code in it, doesn't even have to work so well :-)
17:57:42 <shapr> SyntaxNinja: he loves you.
17:57:50 <dons> I intend to darcs add the patches today, shapr.
17:57:50 <shapr> You made Cabal happen.
17:57:55 <shapr> yay!
17:57:57 <TheHunter> @version
17:57:57 <SyntaxNinja> :)
17:57:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
17:57:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:58:24 <Heffalump> SyntaxNinja: you may be interpreting the public notices lambdabot is generating as msgs
17:58:24 <shapr> I'm so happy dons gets stuff done faster than I do.
17:58:31 <SyntaxNinja> oh, ok
17:58:47 <shapr> I intended to switch lambdabot to notice only two years ago.
17:58:56 <dons> maybe we should add @why-is-bot-using-notices
17:59:01 <shapr> haha!
17:59:02 <dons> which prints the rfc ref
17:59:22 <dons> or a transcript of some dueling bots ;)
17:59:46 <shapr> I wonder if I could work that into a lambdabot quote...
18:02:15 <shapr> dons: My reason for asking just then is thoughts of integrating Yi and lambdabot into the ultimate IRC client.
18:02:50 <dons> ah ha!
18:03:06 <shapr> but it would need pretty colors!
18:03:48 <wagle> 17:00 < ijuz_> they found water on Mars!
18:03:48 <wagle> http://antwrp.gsfc.nasa.gov/apod/image/0504/WaterOnMars2_gcc_big.jpg
18:04:10 <dons> yep. syn hl is the way to go. ok - commits coming soon.
18:05:55 <shapr> wagle: oj
18:08:54 <wagle> "oj"?
18:09:22 <shapr> painfully funny. Like a good pun.
18:10:08 <wagle> h, "oj" is a word..  (in american english, it could only be an abbreviation)
18:10:33 <wagle> s/h/ah/
18:10:59 <shapr> sorry, oy like "oy vey" but in swedish it's spelled "oj"
18:11:36 <gzl> for the following code, I get "non-exhaustive patterns in function evaluate," but i can't see what case i'm missing. any ideas? http://rafb.net/paste/results/QyGw9x85.html
18:12:43 <gzl> oh, crap.
18:12:45 <Igloo> It should tell you what
18:12:46 <gzl> of course.
18:13:02 <gzl> Igloo: it doesn't. but i don't do anything for evaluate []
18:13:13 <Igloo> What's the whole warning?
18:13:35 <gzl> *** Exception: Unwikify-HTML.hs:(89,0)-(96,32): Non-exhaustive patterns in function evaluate
18:13:46 <Igloo> Oh, if you compile with ghc -Wall it'll tell you
18:13:47 <gzl> but nevermind, adding evaluate [] = stringToHtml "" fixed it.
18:14:07 <gzl> I was thinking the incomplete match was on the datatype, but it was on the argument
18:14:16 <gzl> ah, good idea, I didn't think of that
18:14:21 <gzl> in any case, it's fixed now. :)
18:50:56 <metaperl> teehee: http://haskell.date.com/dating/oklahoma.htm
18:51:23 <metaperl> This free Haskell online dating site contains thousands of Haskell singles. Casual Haskell dating or serious Haskell relationships,
18:51:32 <metaperl> lolololol
18:51:54 <metaperl> Create a FREE Haskell singles ad and start dating online.
19:20:27 <metaperl> how do you write an average function for Haskell?
19:20:28 <metaperl> average nums = (sum nums) / (length nums)
19:20:32 <metaperl> type error from this
19:20:58 <monochrom> which type error?
19:21:06 <metaperl> @type sum
19:21:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- sum :: forall a. (Num a) => [a] -> a
19:21:11 <metaperl> @type length
19:21:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- length :: forall a. [a] -> Int
19:21:14 <metaperl> @type (/)
19:21:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (/) :: forall a. (Fractional a) => a -> a -> a
19:21:42 <metaperl> (/) expects its arguments to be fractional
19:21:43 <monochrom> I see the type error.  (length nums) gives an Int but / doesn't like that.
19:22:04 <monochrom> sum nums / fromIntegral (length nums)
19:22:14 <metaperl> but Num must be a subtype of Fractional
19:22:22 <metaperl> I dont think that is the proper terminology
19:22:29 <monochrom> No, Num is not a subtype of Fractional.
19:22:43 <monochrom> It is the other way round.  Fractional is a subtype of Num.
19:22:59 <metaperl> both args to (/) have the type restriction of being fractional
19:23:07 <metaperl> the sum could yield Int
19:23:20 <Darius> @type fromIntegral
19:23:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fromIntegral :: forall b a. (Num b, Integral a) => a -> b
19:23:41 <metaperl> @type sum
19:23:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- sum :: forall a. (Num a) => [a] -> a
19:23:54 <metaperl> Num is not required to be Fractional
19:24:19 <monochrom> Alright, I'm too lazy to find out what to do.
19:24:34 <metaperl> it may work, I'm just complaining about the type issue I see
19:25:07 <Darius> @type toRational
19:25:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- toRational :: forall a. (Real a) => a -> Rational
19:25:10 <Darius> @type fromRational
19:25:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fromRational :: forall a. (Fractional a) => Rational -> a
19:25:12 <dons> @plugs let nums = [1..10] in (sum nums) `div` (length nums)
19:25:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 5
19:25:27 <dons> if you're happy with Int
19:25:53 <metaperl> *Main> average [4,5,6.5]
19:25:53 <metaperl> 5.166666666666667
19:26:01 <metaperl> average nums = (sum nums) / fromIntegral(length nums)
19:26:14 <metaperl> it created Fractional results
19:26:53 <metaperl> is my question about the types passed to (/) valid?
19:26:57 <metaperl> @type (/)
19:26:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (/) :: forall a. (Fractional a) => a -> a -> a
19:27:01 <metaperl> @type sum
19:27:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- sum :: forall a. (Num a) => [a] -> a
19:27:15 <metaperl> @type length
19:27:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- length :: forall a. [a] -> Int
19:27:47 <metaperl> the result from sum() should be cast to something Fractional
19:28:39 <Darius> @type \xs -> fromIntegral (sum xs) / fromIntegral (length xs)
19:28:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- \xs -> fromIntegral (sum xs) / fromIntegral (length xs) :: forall a
19:28:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                   b.
19:28:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                            (Integral a,
19:28:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fractional b) =>
19:28:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                            [a] -> b
19:30:55 <Darius> @type \xs -> realToFrac (sum xs) / fromIntegral (length xs)
19:30:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- \xs -> realToFrac (sum xs) / fromIntegral (length xs) :: forall a
19:30:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                 b.
19:30:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                          (Real a, Fractional
19:30:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- b) =>
19:30:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                          [a] -> b
19:31:06 <Darius> That seems to be the most general type
19:34:47 <metaperl> THompson's book says that Haskell has support for Unicode by typine \uhhhh , where h is a hex digit... but ghci did not recognize that as valid
19:35:03 <metaperl> *Main> \u4444
19:35:03 <metaperl> <interactive>:1: parse error (possibly incorrect indentation)
19:35:03 <metaperl> *Main> '\u4444'
19:35:03 <metaperl> <interactive>:1: lexical error in string/character literal
19:35:04 <metaperl> *Main>
19:36:22 <dons> @plugs '\xfff'
19:36:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- '\4095'
19:36:28 <dons> @plugs '\4444'
19:36:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- '\4444'
19:36:44 <dons> the H98 report doesn't specify any 'u' prefix, afaik
19:37:18 <metaperl> I wonder why he wrote that
19:37:19 <dons> and numeric escapes outside of 16 bits are an error
19:37:22 <waltz> why the fuck is lambdabot noticing us?
19:37:26 <metaperl> does Haskell have unicode support
19:37:37 <metaperl> oh
19:37:41 <metaperl> I didnt see above sorry
19:37:44 * metaperl tries it out
19:37:48 <dons> waltz: RFC standard. Prevents bot recursion, which we had earlier today.
19:38:57 <dons> :/
19:39:30 <dons> " Usually notices are used in bots and scripts for
19:39:31 <dons>       different kinds of replies. The IRC protocol states that notices may not generate replies to
19:39:34 <dons>       avoid msg loops.
19:39:36 <dons> "
19:40:49 * Igloo doesn't know why clients feel the need to make it look so different by default
19:41:10 <dons> yeah. that's the silly part.
19:41:38 <dons> a couple of regexes do the job in irssi, at least
19:41:40 <Igloo> Still, maybe it'll prompt me to sort out a sane irssi config  :-)
19:41:56 <Igloo> regexes? That sounds backward
19:42:19 <dons> oh, it's not actually. sorry.
19:42:31 <dons> each msg type has a variable where you specify a format string
19:42:39 <Igloo> Right, that sounds better  :-)
19:43:09 <dons> regexes matching on network input would be a bit backward ;)
19:43:38 * Igloo wouldn't it past you to be piping irssi through sed
19:43:58 <dons> hmm. that's a GOOD IDEA!
19:44:26 <Igloo> I think you should write a sed backend for GHC, to increase portability
19:44:35 <dons> import Network.Sed
19:44:57 <dons> now that is a good idea. I could reuse the unlambda sed rts
19:45:24 <dons> though it sucks pattern matching the hold space instead of dereferencing a pointer
19:45:55 <dons> I'm so glad conventional hardware choose to use numeric addresses for memory location, and not regexes on the contents of memory ;)
19:46:15 <Igloo> Oh crap, the new timeout programming isn't killing the child in such a way the ghc process dies
19:46:56 <dons> hmm. I noticed some oddities a few months back, but it's been working for me recently.
19:47:28 <dons> though head failed for me last night for some reason
19:53:39 <TNKS> hey guys.  I'm impressed for the most part with Haddock, but I've found haskell-mode somewhat comment-management unfriendly.  Have any of you dealt with this?
19:55:33 <TNKS> What I miss most is M-q (which I think is comment-paragraph-fill).  However, this generally just smashes both code *and* comments together into one paragraph.
19:55:39 <Igloo> dons: You don't get lots of ghc processes if you do   make TEST_GHC=../../../../../ghc/compiler/stage2/ghc-inplace TIMEOUT=10   in the okeefe_neural directory?
19:58:14 <dons> currently only 1: 24819 dons      64    0 9000K   74M run      -        1:12 96.44% ghc-6.4
19:58:53 <dons> along with python, timeout, make
19:59:20 <Igloo> Oh, sorry, TIMEOUT=10 isn't in CVS, you'll hav to change the 300 in testsuite/driver/testlib.py
19:59:36 <dons> ok.
20:00:15 <dons> to 10?
20:00:20 <Igloo> Yup
20:00:55 <dons> hmm!
20:00:56 <dons>  8895 dons      52    0 8992K   62M run      -        0:15 39.36% ghc-6.4
20:00:56 <dons>  1828 dons      52    0 8988K   62M run      -        0:06 21.00% ghc-6.4
20:00:57 <dons> 16707 dons      51    0 9016K   24M run      -        0:01  6.35% ghc-6.4
20:01:02 <dons> now 4.
20:01:15 <Igloo> Good, it's not just me then  :-)
20:01:25 <dons> 5..6..
20:01:36 * Igloo is looking to see if I can do it with process limits again
20:01:50 <dons> and the test run has finished. hmm.
20:26:24 <Janni> Don't know what it does, but is there a replacement for the following that works also with hugs? finalizeForeignPtr :: ForeignPtr a -> IO ()
20:35:54 <dons> -- | Causes a the finalizers associated with a foreign pointer to be run
20:35:55 <dons> -- immediately.
20:45:33 <Igloo> So, is it bad I'm still up, or good that tomorrow's todo list is smaller than it was when I should have gone to bed?
20:47:01 <dons> both!
20:47:06 <Igloo> :-)
20:47:12 * Igloo vamouses
20:47:28 <Khisanth> it depends if you work better as a zombie
20:56:51 <Janni> Hmm. Strange: ./Main results in "Main in free(): error: chunk is already free; Abort" where "truss ./Main" runs just fine...
21:59:10 <mugwump> Where can I find programmatica?  I've googled around a bit for it but can't find anything...
22:09:28 <autrijus> mugwump: http://www.cse.ogi.edu/~hallgren/Programatica/download/
22:09:58 <autrijus> http://www.cse.ogi.edu/~hallgren/Programatica/HW2003/demoabstract.html
22:17:37 <dons> @plugs last [ 1 .. 100000000 ]
22:17:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:17:48 <dons> @plugs let loop () = loop () in loop () :: ()
22:17:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:17:58 <dons> @plugs scanr (*) 1 [1..]
22:18:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Stack overflow
22:18:43 <desrt> lambdabot; return ()
22:18:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
22:18:52 <desrt> uh. duh
22:18:57 <desrt> @plugs return ()
22:18:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No instance for (Show (m ()))
22:18:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       arising from use of `show' at v = show $ (return ())
22:18:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the definition of `resource':
22:18:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	resource = let v = show $ (return ()) in v
22:19:11 <dons> no IO types allowed, thanyou.
22:19:18 <desrt> well, it's not an IO type
22:19:26 <dons> no. close enough ;)
22:19:48 <dons> @plugs let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 fibs
22:19:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
22:20:00 <desrt> i was just wondering what instance of 'return' it would guess
22:20:06 <desrt> thinking maybe it would pick []
22:20:54 <dons> try out some more code.
22:21:31 <dons> @plugs ((error "throw me") :: ())
22:21:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: throw me
22:21:47 <dons> @plugs Random.randomRs (0,747737437443734::Integer) (Random.mkStdGen 1122)
22:21:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [342078620969566,48308706877090,572179348270332,549093210652565,704276426910945,
22:21:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 587942541619884,341430257819319,104095613367277,55087558676037,184438269089968,
22:21:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 685762763531656,246086558481717,396188596370292,342846242216622,300111653132464,
22:21:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 285367607965339,86579547029816,605794293093320,415091386176643,117193156303242,
22:21:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 430540419691810,157346535699280,632286819153018,556448837502717,43542865279899,
22:21:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 289057642498658,386083446753088,668792633247770,42339261019228,76471034417218,
22:21:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 583243346795817,530348913900557,636311217857346,698433183821199,230407919153900,
22:21:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [19 @more lines]
22:22:02 <dons> good bot
22:22:11 <dons> @plugs $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
22:22:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `$'
22:22:18 <autrijus> @plugs let x = x in x
22:22:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Ambiguous type variable `a' in the top-level constraint:
22:22:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at <Plugins.Eval>:1
22:22:21 <alex> Are there principal reasons that limit the maximum speed of Haskell?
22:22:34 <autrijus> @plugs let x = x in (x :: Int)
22:22:35 <dons> @plugs let f () = f () in f () :: ()
22:22:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: forkProcess: resource exhausted (Resource temporarily unavailable)
22:22:45 <dons> hehe. that's my box though.
22:22:56 <dons> hehe.
22:22:59 <autrijus> :D
22:23:01 <autrijus> sorry.
22:23:01 <dons> hmm.
22:23:07 <dons> no, it should have handled that.
22:23:18 <dons> @plugs let x = x in (x :: Int)
22:23:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: <<loop>>
22:23:22 <autrijus> alex: no.
22:23:27 <dons> @plugs let f () = f () in f () :: ()
22:23:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:23:45 <dons> yeah, so just ran out of space
22:23:59 <dons> I'm not going to buy more ram for the lambdabot server though..
22:24:13 <ozone> dons: you can run it on the G5
22:24:18 <ozone> 4GB of RAM should be enough, i hope :)
22:24:20 <dons> ah!
22:24:24 <dons> 8G?/
22:24:34 <ozone> nah, 4
22:25:00 <dons> wonder where I got the 8G idea.
22:25:15 <autrijus> 640GB of ram is enough for everybody.
22:25:26 <alex> autrijus: should it be expected that haskell would get close to c in performance (granted the algorithms are chosen correctly)?
22:25:31 <autrijus> alex: yes.
22:25:36 <alex> ok, that's great
22:25:39 <autrijus> GHC in particular let you write haskell code that works just like C.
22:25:46 <autrijus> including pointer arithmetic, unboxed types, etc.
22:25:54 <alex> I loved everything, but slowness of some code
22:26:15 <autrijus> you may wish to read the "Algorithms" book, or the web page on strict haskell
22:26:27 <autrijus> # http://users.aber.ac.uk/afc/stricthaskell.html
22:26:27 <alex> strict haskell?
22:26:49 <ozone> alex: just do what i do and put ! everywhere
22:26:50 <alex> thank you
22:27:10 <alex> ozone: :D
22:27:33 <alex> Is it possible to generate smaller binaries with ghc?
22:27:39 <alex> Mine are ~6M
22:27:42 <autrijus> yes, with dynamic loading
22:27:48 <ozone> alex: on the mac, yes
22:27:50 <autrijus> like, on win32, hello world is just 4k
22:27:51 <alex> isn't it only osx
22:27:52 <alex> yeah
22:28:03 <alex> nothing on linux or bsd?
22:28:06 <ozone> on the mac, you can also use the linker's dead code stripping, which _greatly_ reduces binary size
22:28:09 <autrijus> not sure. patches welcome
22:28:15 <alex> ok
22:28:18 <dons> ensuring you don't link unnecessarily against packages, and using strip are useful.
22:28:27 <alex> stripping wasn't very useful
22:28:32 <dons> also, make sure you compiled your ghc with SplitObjs
22:28:35 <autrijus> pugs is just 2mb stripped
22:28:36 <ozone> -rwxrwx---  1 andrep  andrep  6794204  1 Apr 14:22 uniqsort
22:28:36 <ozone> -rwxrwx---  1 andrep  andrep   470992  1 Apr 14:21 uniqsort.stripped
22:28:48 <dons> 2mb is probably normal
22:28:56 <ozone> (n.b. that's "dead code stripping", not "strip")
22:29:11 <dons> the linker option?
22:29:17 <ozone> yeah
22:29:29 <alex> I don't know very much about ghc.  I've read that it's based on translating to c/c++.  Is it true?
22:29:29 <ozone> wolfgang reckons GNU ld will do dead code stripping, but only if you don't use shared libraries
22:29:39 <ozone> i.e. practically, GNU ld's dead code stripping is pretty useless
22:30:01 <alex> I see
22:30:07 <dons> alex: it compiles to an intermediate form called C--, which is then printed out as C or native asm.
22:30:29 <alex> I see
22:30:35 <alex> Thank you
22:30:50 <dons> there's also a bytecode backend, used by the 'interpreter' environment, ghc --interactive
22:30:59 <autrijus> I'm still compiling ghc :-/
22:31:04 <autrijus> already took 2 days.
22:31:08 <dons> he!
22:31:14 <dons> what're you on, a mac68k?
22:31:16 <autrijus> dons: is it possible to gen bytecode into an exe with evaluator?
22:31:18 <autrijus> dons: AIX
22:31:23 <dons> close!
22:31:25 <autrijus> I'm the aix porter ;)
22:31:45 <dons> I think bytecode objects are on the todo list at ghc-HQ
22:31:50 <autrijus> cool.
22:31:53 <autrijus> all hail the HQ
22:32:14 <autrijus> like nethack devteam, they think of everything
22:32:28 <dons> autrijus, have you thought of @plugs (pugs "perl code") ?
22:32:30 <alex> btw, is there an emacs-like editor in haskell?
22:32:36 <dons> as long as pugs :: String -> Value
22:32:42 <autrijus> what's Value again?
22:32:49 <autrijus> pugs can do String -> String
22:32:55 <dons> imaginary type I made up for the final value of pugs.
22:32:56 <autrijus> that's Main.eval
22:33:06 <autrijus> the final val type is "Val"
22:33:09 <dons> assuming you can show the reduced abs syn tree.
22:33:10 <autrijus> but soon to be "Val a"
22:33:15 <autrijus> sure I can.
22:33:19 <autrijus> that's called "parse"
22:33:25 <autrijus> or "run"
22:33:48 <dons> yeah, so @plugs (parse "foo") would be pure, and safe? or is there a big bunch of IO happening in the background?
22:34:28 <autrijus> it's pure and safe for now.
22:35:06 <dons> ok. i figured that it would turn into a monad once things go complicated enough
22:36:49 <autrijus> no
22:36:53 <autrijus> it will become a TH :)
22:36:57 <autrijus> oh, btw
22:37:10 <autrijus> are you familiar on how to do on the fly compilation?
22:37:17 <autrijus> i.e. if I have a function of form
22:37:20 <autrijus> String -> ExpQ
22:37:28 <autrijus> let's call it "compile"
22:37:40 <autrijus> and that ExpQ is a IO ()
22:37:44 <autrijus> can I write a "run" that looks like
22:37:49 <autrijus> run :: String -> IO ()
22:37:52 <autrijus> and use compile inside?
22:37:54 <autrijus> I tried
22:38:05 <autrijus> run str = $(compile str)
22:38:08 <autrijus> but that's a stage error
22:38:13 <dons> yeah. hmm.
22:38:16 <autrijus> it seems that it only works if compile is of form
22:38:18 <autrijus> ExpQ -> ExpQ
22:38:27 <autrijus> run str = $(compile [| str |])
22:38:31 <dons> yep.
22:38:41 <autrijus> but then I can't retrieve the string from the [|str|] in compile
22:38:47 <autrijus> at least I don't see how
22:38:56 <dons> I'm not to familiar with the scary details, maybe try the TH list?
22:39:04 <autrijus> ok =)
22:39:04 <dons> or just haskell-cafe@
22:39:11 <autrijus> thanks
22:40:50 <dons> @plugs let f () = f () in f () :: ()
22:40:51 <dons> @plugs let f () = f () in f () :: ()
22:40:51 <dons> @plugs let f () = f () in f () :: ()
22:40:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:40:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:41:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
22:41:04 <dons> good bot!
22:41:42 <det> lambdabot is dead! Long live lambdabot!
22:41:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
22:42:26 <alex> :-(
22:43:59 <dons> @quit
22:45:37 <dons> @version
22:45:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
22:45:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:53:19 <jlouis> dons: I might have something for lambdabot ;)
23:13:03 <dons> jlouis ?
23:13:14 <dons> darcs send, if you have something.
23:13:21 <jlouis> dons: check
23:14:56 <dons> you sent something?
23:15:02 <jlouis> yup
23:15:48 <dons> nothing here yet. I'm heading out now, I'll have a look later tonigh.
23:16:42 <jlouis> sure
23:26:17 <Oejet> Good morning!  Is there a word for before noon that corresponds to afternoon in the morning?
23:27:25 <smott> dawn?
23:29:20 <Oejet> Hm, that's more morning, isn't it?
23:29:41 <dons> so > morning && < noon
23:29:54 <dons> hmm. late morning?
23:30:31 <Oejet> dawn <= morning <= late morning < noon.
23:30:59 <smott> ante meridiem
23:31:15 <smott> don't know if there's an english word for it
23:32:00 <mugwump> no.  in chinese they only use morning for before 10am, but in english it's fair game to be morning until noon
23:32:07 <mugwump> read what you like fro that :)
23:32:18 <mugwump> you could use "good day"
23:32:29 <Oejet> In Danish it's "beforenoon".
23:32:57 <Oejet> mugwump: Interesting.  Is 10am a hard limit?
23:33:29 <mugwump> well, I'm not sure, I'm just going by what's in the Lonely Planet Mandarin Phrasebook :)
23:35:02 <Oejet> smott: What language is "ante meridiem", Italian?
23:35:15 <smott> latin
23:36:30 <Oejet> Close.  :-)
23:38:15 <smott> it's used in english too, as in AM/PM (ante meridiem, post meridiam, meaning before and after noon)
23:39:58 <Oejet> Ah, I see now.
23:48:36 <autrijus> Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
23:48:49 * autrijus whews
23:51:14 <Gahhh> I've just learned more Visual Basic than I'd ever liked to
23:53:27 <Oejet> Gahhh: What is visual about it then?
23:55:23 <Gahhh> The whole "visual" thing with regards to Visual Studio is a few wizards that let you drag & drop some widgets and navigate to their pieces of code.
23:59:51 <Arafangion> For a given language, is it really limiting the programmer if they cannot recursively run a function? (ie, a function can't call itself, or cause another function to call the original function and loop that way)
