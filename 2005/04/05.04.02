00:00:03 <Arafangion> UNLESS tail-call recursion is used.
00:00:30 <Khisanth> Gahhh: VB actually generates code?
00:01:04 <Gahhh> Khisanth: It puts some function definitions that you need to fill in.
00:01:26 <Gahhh> It also removes functions with empty bodies heh
00:01:32 <Khisanth> Arafangion: how can it have tail call recursion if it can't have recursion at all?
00:01:34 <Gahhh> that editor is wicked
00:06:11 <Oejet> Arafangion: Recursive depth first search on a tree is not tail-recursive.
00:08:51 <Oejet> Arafangion: You could manage the stack yourself, though.
00:11:03 <Gahhh> Wow. Guido gave in and made and made an April 1st post. Argh.
00:11:55 <det> Gave in? Is he opposed to April first trickery?
00:13:35 <Gahhh> Umm. I guess I am opposed to April 1st stuff
00:16:58 <Khisanth> det: maybe he didn't want people to think he was joking
00:45:42 <musasabi> Grah. haskell really needs a better IO layer.
00:52:26 <Oejet> musasabi: Any suggestions?
00:53:01 <musasabi> Oejet: an easy way to inject transparent filter layers (compression, encryption, ...)
00:53:21 <musasabi> Oejet: this is very similar to the encoding/decoding issues.
00:54:00 <musasabi> Oejet: which have been discussed quite a lot :-)
00:55:21 <Khisanth> hmm decorators
01:00:38 <Oejet> musasabi: So readBZip2 :: Handle -> IO String, and writeBZip2 :: Handle -> String -> IO (), could be used with hPutStr and hGetStr?
01:02:18 <musasabi> Oejet: yes, although I wish to operate on a lower layer without strings ;)
01:10:02 <alex> is macro like expansion at compile time currently possible in haskell?
01:11:57 <Itkovian> all right! got my lambdabot up and running ... time to fool around with it.
01:12:42 <alex> @version
01:12:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fri Apr  1 19:19:54 EST 2005, GHC 6.2.2 (OpenBSD i386)
01:12:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:12:55 <alex> nice to see obsd here :-)
01:13:26 <musasabi> alex: yes, with template haskell (of course for small things cpp is easier)
01:13:59 <alex> musasabi: thank you
01:14:18 <xkb> hi all
01:14:33 <alex> good night
01:14:50 <musasabi> finally announced SerTH to libraries@ :-)
01:14:53 <xkb> does anyone here know how to "render" latex as a 2 page booklet on a4?
01:15:07 <xkb> i'm using documentclass report now
01:16:54 <Itkovian> xkb: can't up use psnup?
01:18:32 <xkb> Itkovian: hmm thats a good idea
01:18:42 <xkb> render to ps, then psnup
01:20:48 <Itkovian> xkb: or you could print it using kprinter with two pages per sheet
01:21:02 <xkb> im on os x now :D
01:21:20 <xkb> hmm perhaps os x also supports this
01:21:21 <Itkovian> nice :-)
01:21:27 <Itkovian> I hope to be on that in a week.
01:21:29 <xkb> could be.. I heard it's using cups
01:21:43 <xkb> Itkovian: powerbook?
01:21:53 <Itkovian> I think the apple tools allow you to do a whole array of stuff with ps/pdf
01:22:00 <Itkovian> xkb: ordered yesterday
01:22:08 <xkb> nice
01:22:11 <xkb> the new model?
01:22:13 <Itkovian> damn right it is!
01:22:24 <Itkovian> erm, the one they're offering atm ...
01:22:26 <xkb> I still got an older model 17" powerbook
01:22:31 <xkb> 1 Ghz only
01:22:36 <Itkovian> ah, well, mine will be 12"
01:22:39 <xkb> fast enough for me though
01:22:40 <Itkovian> 1.5 GHz
01:22:43 <xkb> nice
01:22:46 <xkb> very nice :D
01:22:50 <Itkovian> fastest machine in the house
01:22:52 <xkb> including airport and the like?
01:22:53 <Itkovian> :-)
01:22:59 <Itkovian> yeah, that's standard now
01:23:08 <xkb> ah that's better
01:23:15 <Itkovian> bluetooth as well, although I don't know for what I'll use that
01:23:17 <xkb> that's the reason I chose for the 17"
01:23:22 <xkb> at the time
01:23:23 <Itkovian> ic
01:23:39 <Itkovian> isn't that a tad overzised to drag around?
01:23:48 <xkb> a tad, yes
01:23:56 <xkb> it covers my whole back ;)
01:23:58 <Itkovian> heh
01:24:00 <xkb> in it's backpack
01:24:08 <Itkovian> bullet protection and such
01:24:13 <xkb> yeah :D
01:24:26 <xkb> The weight is not that much of an issue
01:24:30 <xkb> only 3 kg
01:24:36 <Itkovian> nice.
01:24:51 <Itkovian> ttyl
01:24:54 <xkb> working on the train with it is quite hard :D
01:24:56 <xkb> cya
01:37:42 <Oejet> lambdabot: You are nice!
01:37:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
01:49:01 <wilx> Huhu.
01:49:05 <wilx> Why the notice?
01:50:26 <Oejet> Somebody wrote an evil spam plugin.
01:56:03 <mflux> notice is something bots should use in replies
01:56:15 <mflux> and something bots should never react to
01:56:36 <mflux> the invariant being that bots never cause floods by responding to each others' messages :)
02:02:42 <Heffalump> all automated responses, including from normal clients are technically supposed to be notices
02:10:11 <Arafangion> Which is better, a *purely* functional language, or a *purely* object-oriented program?
02:10:40 <Arafangion> Now, my background is that I'm a student at a uni, and I'm disatified with OO paradigms, so... ;)
02:10:47 <Arafangion> I'm after explainations, in other words.
02:11:37 <musasabi> Which is better - an apple or an orange?
02:12:19 <Arafangion> musasabi, I'm starting to realize that C# and Java programs really do get messy.
02:13:10 <musasabi> Arafangion: for nicer OO systems look at ruby, smalltalk, self etc...
02:13:13 <araujo> Arafangion, i recommend you to look at smalltalk
02:13:18 <araujo> 8)
02:13:35 <Arafangion> I am most familiar with Python, which is sweet.
02:13:41 <Arafangion> Python 2.3, to be precise.
02:13:45 <musasabi> The paradigms are different and there is no really good metric to measure which is better.
02:14:10 <Arafangion> What's a good internet resource to read about it, then? :)
02:14:12 <araujo> It happened to me also, i was very dissapointed at OO until i played with smalltalk
02:14:32 <Arafangion> I must say that the only OO language I like currently is Python.
02:14:51 * musasabi does like functional languages like haskell better than OO languages, but that is just a subjective opinion.
02:14:53 <Arafangion> The other language I like is raw C...
02:14:57 <nmoore> functional programming in java: http://www-106.ibm.com/developerworks/library/j-fp.html?ca=dnt-528
02:15:09 <Philippa_> OO languages with block objects and the like are certainly much saner than those without
02:15:12 <Arafangion> But I just wish I could find time to learn Haskell properly (rather htan _just_ reading a book)
02:15:31 <Philippa_> but I find Haskell in the IO monad is nice for a lot of similar stuff
02:15:37 <shapr> Arafangion: if you want really pure OO check Self
02:15:45 <araujo> musasabi, i'd say that they approach different paradigms
02:15:52 <araujo> shapr, nah, smalltalk better
02:15:55 <Arafangion> shapr, Your the second person to mention that to me.
02:16:07 <shapr> araujo: I believe that Self is more OO than Smalltalk.
02:16:10 <Arafangion> araujo, Smalltalk is on the mac os x, right?
02:16:23 <araujo> shapr, no, as far as i know, the more OO is smalltalk
02:16:34 <shapr> In fact, that was the project motto for awhile, "Like Smalltalk, only more so"
02:16:35 <Philippa_> for Alan Kay's definition of OO? :-)
02:16:44 <musasabi> depends on the OO definition of choice :-)
02:16:48 <araujo> Arafangion, yes, there is an implementation, Abraham or something like that
02:17:06 * Arafangion thought that Smalltalk was a major mac scripting language long ago...
02:17:11 <araujo> :-P
02:17:17 <shapr> I think the dual class/instance hierarchy just distracts users from the focussing on the real problem.
02:17:19 <Philippa_> Arafangion: easiest way to learn is to pick a project and start hacking on it
02:17:19 <araujo> Smalltalk was actually an OS
02:17:22 <musasabi> I like the expliciteness of functional languages with regards to mutation.
02:17:23 <mflux> araujo, "appletalk"
02:17:25 <Arafangion> My laptop is a mac, btw.
02:17:27 <mflux> whops, arafangion
02:17:30 <Arafangion> Ahh, appletalk.
02:17:51 <Philippa_> musasabi: likewise
02:17:59 <Arafangion> shapr, Yes, in my pet language I remove that distinction altogether.
02:18:02 <araujo> Alan Kay inspired at Lisp to create Smalltalk anyways
02:18:08 <Philippa_> easier to throw away information than reconstitute it...
02:18:11 <shapr> So you already know about prototype oriented programming?
02:18:25 <Arafangion> shapr, Everything is an object, instances are only objects that have a re-executed "init" block.
02:19:11 <shapr> Well, that's closer to Smalltalk and the Zen OO koan "The metaclass object is an instance of an instance of itself"
02:19:25 <shapr> In my opinion.
02:19:41 <Arafangion> shapr, Nice.  I'm amazed at how much I'm learning by making my own language.
02:19:51 <shapr> I should try that.
02:19:54 <Arafangion> shapr, It's teaching me at least 3 languages at the same time.
02:19:55 <Philippa_> copy and change vs keep an initialised version and copy it...
02:19:57 <shapr> neat!
02:20:16 <shapr> araujo: have you used Self?
02:20:23 <araujo> I would never compare a _real_ OO language with a functional one
02:20:39 <Arafangion> Perhaps I aught to learn a *real* oo language.
02:20:49 <shapr> I've used Self more than Squeak, but neither enough to have really written something.
02:20:51 <araujo> shapr, not really, only read about it.. and used a few of the ideas on Squeak
02:21:19 <shapr> araujo: do you use x86 Linux?
02:21:21 <araujo> shapr, self uses morphic right?
02:21:26 <araujo> yes
02:21:31 <musasabi> with prototype based languages I am allways left wondering how deep in the chain a slot lived and what all did it mutate again.
02:21:50 <nmoore> sorry to dumb down the conversation, but should i introduce a numerical constant by just having a constant function?
02:22:08 <shapr> araujo: I think morphic came from Self
02:22:16 <araujo> shapr, yes, i think too
02:22:23 <shapr> nmoore: you can, with const
02:23:11 <shapr> araujo: http://gliebe.de/self/download.html
02:23:32 * araujo actually after one year re-installed Squeak a few days ago
02:24:32 <Philippa_> araujo: comparing 'real OO' and functional has some value just because they're so different yet so similar
02:24:36 <araujo> mm.. interesting.. i thought Self was already dead
02:24:37 <shapr> musasabi: Is there a way to find out how deep the slot is with JavaScript?
02:24:57 <shapr> I guess you'd have to know the whole instance hierarchy already.
02:25:19 <musasabi> shapr: I don't know a way, but I never took time to learn it really properly.
02:25:34 <Arafangion> Man, System.Windows.Forms is *kludgy*.
02:26:03 <araujo> Philippa_, of course you can compare, but imho, it'd be tough to say what approach is better
02:26:22 <Philippa_> depends what you're doing
02:26:36 <araujo> OO has been bastardized during the last decade (someone said java?)
02:26:41 <Philippa_> for what I'm doing, having serious static typing be tractable is worth a lot
02:27:07 <Philippa_> it was being bastardised the decade before, too (C++ anyone?)
02:27:19 <araujo> Philippa_, of course, depends on what you do , that is my point, for one task OO fits better, for another one functional programming
02:27:21 <shapr> nmoore: do you have a specific bit of code that needs const?
02:27:43 <Arafangion> At least C++ was intended to support multi-paradigm programming.
02:27:53 <araujo> Philippa_, No. Bjarne never said C++ was a pure object oriented language
02:27:57 <nmoore> shapr: the function const? i don't see the point, i was just using myConstant = 14
02:28:02 <araujo> Sun microsystem does 8)
02:28:17 <shapr> nmoore: oh, I thought you needed a function that returned the value, oops.
02:28:47 <Philippa_> araujo: I'm inclined to suggest that these days functional's probably more powerful - I'm not really seeing an equivalent to monads in OO, for example. But it may well partly be about research not happening
02:29:12 <shapr> nmoore: have you seen HaskellDemo?
02:29:16 <araujo> Philippa_, i agree with you on that, functional programming is doing very well nowadays
02:29:16 <shapr> @wiki HaskellDemo
02:29:17 <Philippa_> the capability to deal with dynamic systems is a biggie for OO though
02:29:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellDemo
02:29:20 <Arafangion> Philippa_, What *are* monads?  I can't seem to "grok" the entire idea/concept/thing
02:29:45 <Arafangion> Philippa_, It's a biggy for non-static OO, you mean?
02:29:45 <Philippa_> Arafangion: I'm not awake enough to give a really good explanation, but here goes...
02:30:12 <nmoore> shapr: that answers the question!
02:30:34 <araujo> shapr, back to self ... dude, i thought that was dead!!
02:30:40 <Philippa_> Arafangion: if you choose to restrict your OO to static that's your problem. FP loses a lot more by not being static than OO does
02:30:56 <Philippa_> anyway... you're familiar with the idea that languages have semantics?
02:31:08 <Arafangion> First define the word "semantics".
02:31:27 <Arafangion> (Because I'm not really that familiar with that word)
02:31:51 <Arafangion> Python and Java do appear to have a very different "flow", though... Is that it?
02:31:52 <Philippa_> 'the meaning of sentances/whatever in that language" will do for now
02:32:01 <araujo> shapr, in which way you say it is more OO than smalltalk?
02:32:11 <musasabi> Getting working subtyping (hard? in haskell) could solve many problems. (of course existential wrapping etc)
02:32:29 <Philippa_> musasabi: for what value of subtyping? I really need to write that damn paper
02:32:43 <xerox> 'morning
02:32:54 <Philippa_> existential wrapping's the relevant equivalent for a lot of common uses of it
02:33:09 <Philippa_> aaanyway
02:33:39 <_JusSx_> araujo> | Philippa_, No. Bjarne never said C++ was a pure object oriented language: YEAH
02:34:07 <musasabi> Philippa_: getting something working for common "a thing satisfying an interface" problem and add to that a partial ordering of types...
02:34:22 <Philippa_> Arafangion: monads are a means of embedding a different semantics in Haskell. Specifically, this new semantics a) supports the ability to call ordinary haskell code (which evaluates normally) and b) still supports some analogy of higher-order functions
02:34:24 <musasabi> Philippa_: as you can see I don't really know exactly what I want ;)
02:34:42 <araujo> _JusSx_, ?
02:34:46 <Arafangion> Philippa_, So, it's kind of a "special object"?
02:34:59 <_JusSx_> araujo: how are you?
02:35:03 <tuomov> a monad is a dsl
02:35:06 <Philippa_> Arafangion: there's no "object". It's a type constructor with a bunch of operations on it
02:35:07 <Arafangion> dsl?
02:35:13 <tuomov> domain-specific language
02:35:13 <araujo> _JusSx_, very well, thanks, yourself?
02:35:23 <_JusSx_> quite well but tired
02:35:23 <tuomov> the IO monad is a language for doing IO in haskell
02:35:27 <araujo> 8)
02:35:30 <tuomov> the List monad is al it processing language
02:35:31 <tuomov> etc.
02:35:36 <Arafangion> Philippa_, How is that difeferent from an ordanary object? (Let's ignore inheritance and etcetera)
02:35:37 <_JusSx_> so solved prob with HSQL?
02:35:47 <tuomov> s/al it/a list/
02:35:49 <araujo> _JusSx_, yeah... it worked fine
02:35:54 <_JusSx_> wow great
02:36:05 <_JusSx_> did you release the patch?
02:36:06 <Arafangion> tuomov, Ok, I think you just cracked my skull.
02:36:15 <Philippa_> Arafangion: it just doesn't act like one. It may help if you climb out of the 'everything's an object' box for a moment, mind
02:36:28 <araujo> _JusSx_, mm.. though i think there is a dependency giving problems yet... let me check
02:36:35 <araujo> _JusSx_, no, nothing yet
02:36:35 <Cale> the list monad is a language for nondeterministic computation -- it's not terribly useful for processing lists
02:36:41 <Arafangion> Philippa_, When I do that, I fall into the "everything is a struct and functions".
02:36:55 <tuomov> Cale: well, yeah, that's a better description of it
02:37:05 <Cale> it is useful for constructing lists
02:37:12 <Philippa_> Arafangion: that's closer to it. A type-parameterised struct-like thing, though you don't usually get to look inside it
02:37:31 * esap often uses the "everything is a queue or a stack" mentality :-)
02:37:38 <Arafangion> Philippa_, I am at the point that I fail to distingiush the two views, except for the inheritance.
02:37:43 <Philippa_> the actual values might be of type IO Int (an IO computation that returns an Int)
02:37:57 <_JusSx_> why speaking about OO?
02:37:59 <Oejet> [ANN] http://www.haskell.org/hawiki/ImperativeHaskell
02:38:05 <Philippa_> Arafangion: Immutability, lack of OO-style polymorphism, stuff like that
02:38:28 <Philippa_> if you're still going to call that an object then fine, start paying attention to what /kind/ of object
02:38:41 <Cale> Arafangion: for one view of things: http://www.haskell.org/hawiki/MonadsAsContainers
02:38:54 <Philippa_> (in particular, and this is important, a monad is /not/ an object. Computations 'within' the monad are)
02:39:03 <Philippa_> (class/object distinctions /are/ real ;-)
02:39:14 <musasabi> btw are list/monad comprehensions in haskell isomorphic to monoid calculus?
02:39:17 <Arafangion> Philippa_, I fail to see why they should be :)
02:39:33 <Cale> I think that looking at monads as an abstraction of container types is a good way to see them at first.
02:39:44 <araujo> _JusSx_, no need for a patch really, i just needed to specify the correct path for the libraries,
02:39:54 <araujo> _JusSx_, here, odbc is giving problems yet
02:39:57 <Philippa_> Arafangion: the distinction is relevant when you have static typing
02:40:06 <Cale> The way in which they represent computation is a little harder to grasp than the way in which they represent containers.
02:40:10 * Arafangion *hates* static typing.
02:40:22 <Philippa_> you never have a reified thing being passed around that is "a monad"
02:40:22 <Cale> Arafangion: why?
02:40:22 <musasabi> Arafangion: why?
02:40:23 <_JusSx_> araujo: i can remember wrong lib flie name in configure.ac
02:40:24 <Heffalump> bugger off and use Lisp, then :-
02:40:25 <tuomov> dynamic typing is shooting yourself in the foot with a big cannon
02:40:26 <Heffalump> )
02:40:27 <esap> The type vs. value distinction is very important.
02:40:50 <Arafangion> I suppose I've just become too used to Python.
02:40:51 <araujo> _JusSx_, yes yes, i tried that, but the problem is that libodbc seems broken, or something
02:40:55 <_JusSx_> stop speaking about type & value
02:41:04 <_JusSx_> everyday the samething
02:41:12 <musasabi> Arafangion: static typing can be very inconvenient in C-like languages.
02:41:13 <tuomov> Arafangion: note that haskell et all have type inference, so you don't need those annoying signatures
02:41:15 <Philippa_> Arafangion: don't confuse static typing with having to give explicit types for everything
02:41:21 <tuomov> Arafangion: and are polymorphic by default
02:41:23 <esap> JusSx: oh sorry, what term should I use?
02:41:35 <Philippa_> esap: Foos and Bars, duh
02:41:38 <Cale> esap: so you're against dependent types? :)
02:41:39 <Arafangion> Philippa_, Ok.
02:42:02 <esap> cale: No I'm not.
02:42:07 <Philippa_> Haskell makes far more use of types than any language you're likely to've used for any length of time
02:42:18 <_JusSx_>  esap> | The type vs. value distinction is very important. yes it's but stop speaking about that
02:42:29 <Philippa_> _JusSx_: it's relevant here and now
02:42:32 <Arafangion> Philippa_, I'm starting to think that it's a better use of object-oriented concept that way.
02:42:34 <Philippa_> so with all due respect, STFU
02:42:35 <esap> jussx: ah ok.
02:42:46 <_JusSx_> Philippa_: yesterday it was spaken
02:42:49 <_JusSx_> Philippa_: yesterday it was spoken
02:42:58 <Philippa_> and I'm guessing it was relevant then, too
02:43:06 <_JusSx_> last week it was spoken
02:43:10 <Philippa_> you'll find people talk about monads a lot too
02:43:11 <_JusSx_> you re boring me
02:43:19 <_JusSx_> monad is OK
02:43:27 <Philippa_> then find somewhere that interests you. We are not an entertainment service
02:43:34 <_JusSx_> lol
02:43:38 <Oejet> _JusSx_: Be nice.
02:43:41 <musasabi> Arafangion: with dynamic typing you are requiring that objects passed to you satisfy a specified interface - static typing just checks that it is so and documents the fact.
02:43:48 <_JusSx_> ok speak about the samething everyday
02:44:13 <Philippa_> _JusSx_: this channel helps out newbies. Therefore, certain issues will crop up regularly. Deal with it.
02:44:19 <Arafangion> musasabi, I was thinking of dynamic typing as checking to see if the attributes exist at whenever they are accessed/executed.
02:44:45 <musasabi> Writing types in haskell is much more a way of documentation for me than a laborous chore.
02:44:55 <musasabi> *rather than
02:45:04 <Oejet> Newbies make me feel smart. :-)
02:45:19 <Philippa_> seconded, with the occasional exception (ohgod I used the ST monad again and forgot which annotations it needs ;-)
02:45:22 <Cale> Arafangion: it's much nicer, in general, to have the compiler warn you that there's a bug than to have it occur at runtime
02:45:25 <shapr> _JusSx_: you could learn about arrows
02:45:34 <musasabi> Arafangion: catching errors earlier is usually a good thing.
02:45:50 <Philippa_> not least because you get to be shown several at once
02:46:06 <Philippa_> which is a good thing if they interact interestingly...
02:46:13 <musasabi> and those in infrequent codepaths also.
02:46:26 <Arafangion> musasabi, I find it more important to be able to easily test sooner.
02:46:27 <Philippa_> also, you can use static typing to eliminate wide classes of errors and thus checks
02:46:28 <shapr> _JusSx_: Once you understand arrows http://www.haskell.org/arrows/ then you can learn about Yampa! http://www.haskell.org/yampa/
02:46:38 <Arafangion> (But I'm quite a noob)
02:46:40 <Philippa_> Arafangion: interpreters exist. Your point?
02:46:49 <Philippa_> shapr: probably easier the other way round
02:46:55 <Oejet> Philippa_: Like newStack :: Int -> ST s (Stack s a)?
02:47:32 <Philippa_> Oejet: no, like "I've built another monad that wraps ST and the type of the transformer stack's a bastard" :-)
02:47:50 <Arafangion> Philippa_, I suppose that this is more of a distinction of wether or not it's aspect-oriented?
02:48:03 <musasabi> Arafangion: I haven't encountered that difficulty in haskell..
02:48:05 <Philippa_> Arafangion: I don't follow
02:48:07 <Cale> Arafangion: Having the compiler test some things for you relieves you of some work doing testing :) (but certainly not all of it)
02:48:29 * esap builds stacks using GADTs with 'data Stack a where { Frame :: f (Stack a) -> Stack (f a) }
02:48:41 <tuomov> testing sucks.
02:48:57 <Philippa_> careful construction of types makes it near-impossible to make really large classes of errors
02:49:08 <Philippa_> Oleg's branded array library springs to mind as an interesting example
02:49:15 <Oejet> esap: Tell me more about that.
02:49:19 <tuomov> dynamic typing is a maintenance nightmare
02:49:22 <shapr> But you can do easy test driven development in Haskell with just a type signature, undefined, and the TDD version of QuickCheck.
02:49:45 <tuomov> with static typing the compiler tells you that you need to change other places after having changed one
02:49:54 <tuomov> but with dynamic typing you'll have to figure it out by yourself
02:50:19 <ozone> this place is lively today
02:50:24 <esap> Oejet: I have basic stack stuff: push = curry Frame, pop (Frame x) = x, make_stack = Frame id.
02:50:26 <shapr> araujo: I'd say Self is more OO than Smalltalk because you're not distracted by the class hierarchy.
02:50:32 <Philippa_> also, static typing ala Haskell comes with a more powerful type system than most dynamically-typed languages - you get to express more interesting properties in types
02:50:51 <shapr> ozone: jump in!
02:50:59 <ozone> heh, no thanks
02:51:09 <ozone> i've had my fair share of haskell vs the world debates :)
02:51:18 <shapr> ozone: what's a good mac laptop?
02:51:30 <Arafangion> ozone, We're more talking about coding concepts.
02:51:33 <xerox> An iBook I think.
02:51:36 <Arafangion> shapr, What do you want to use it for?
02:51:39 <ozone> in the end, either they have to reconfigure their brain, you you just keep banging your head against a brick wall
02:51:49 <xerox> A 12'' iBook! ^__^
02:51:51 <ozone> shapr: i like the ibook 12" and powerbook 15"
02:51:51 <Arafangion> shapr, iBook's are excellent, *unless* you want to use it for presentations...
02:51:55 <shapr> I'm wavering between buying a dual opteron or getting a laptop.
02:52:15 <ozone> what do you need a dual opteron for?
02:52:27 <xerox> Compiling GHC && pugs fulltime!
02:52:35 * shapr snickers
02:52:40 <ozone> fair enough :)
02:52:43 <shapr> web development!
02:52:52 <Oejet> esap: Nice, but how would that generalize to queues?
02:53:18 <esap> Oejet: You can implement queues using two stacks.
02:53:29 <Janni> Hi.
02:53:33 <Cale> hello
02:53:33 <shapr> hiya Janni
02:53:34 <xerox> I'm thinking about buying an ibook after Tiger is out, too, they're probably going to get upgraded in some way to support the new features nicely.
02:53:59 <shapr> My point for a laptop would be the ability to program outdoors.
02:53:59 <ozone> heh, i wonder if apple's reserves will run even more dry after tiger's released
02:54:08 <esap> Oejet: something like: data Queue a where { Queue :: Stack a -> Stack b -> Queue (a,b) }  Though I haven't considered that fully.
02:54:08 <ozone> shapr: my personal opinion, get a laptop
02:54:17 <ozone> desktops are so 90s
02:54:37 <ozone> more seriously, ever since i got a mac, the only reason i ever touch my PCs now is for games
02:55:00 <shapr> But I can get a dual opteron 250 with 2gb of ram for 2000 euro
02:55:03 <Philippa_> I'd seriously consider a laptop if a) I had money and b) I could get one with a full-size keyboard
02:55:08 <shapr> so that's tempting
02:55:10 <Philippa_> what would you do with the horsepower?
02:55:11 * xerox has a PowerMac 8100 running OS 7.6.1 with a huge 21'' monitor ;)
02:55:28 <ozone> 2000 euro could probably book you a pretty nice ibook/powerbook
02:55:41 * xerox agrees with ozone.
02:55:45 <Philippa_> pe^Hrocessor extensions aren't that impressive
02:56:12 <shapr> Hm, I'll check out ibook/powerbook prices.
02:56:14 <ozone> shapr: plus, if you haven't used macs, you get an opportunity to learn a new OS
02:56:23 <ozone> which is far more interesting than a dual opteron :)
02:56:43 <shapr> I used macs from Mac 128k up to a PowerMac 8xxx
02:56:46 <shapr> but not since then
02:56:49 <Oejet> How about a dual G5. :-P
02:56:56 <Arafangion> Only reason I touch my desktop is for VS.NET, for Uni assignments.
02:57:12 <ozone> shapr: i was pretty much in the same camp as you, though i stopped a bit earlier
02:57:14 <Oejet> Arafangion: Poor you.
02:57:19 <xerox> Oejet: probably really fast/good, but not as handy as a laptop.
02:57:30 <Arafangion> Oejet, I consider myself lucky, I've only lost code once - in one week.
02:58:48 <shapr> ibook/powerbook is okay with debian?
02:58:50 * Philippa_ is quite looking forward to trying out the VS.net/Haskell integration stuff at some point
02:58:58 <Philippa_> (I get VS.net via MSDNAA now)
02:59:10 <ozone> Philippa_: it works, from the little i've played with it :)
02:59:22 <Arafangion> Does it compile haskell to CLR?
02:59:25 <xerox> shapr: yep, apart from the wireless card.
02:59:25 <Philippa_> how much do you get atm?
02:59:29 <ozone> shapr: the new albooks don't completely work, e.g. wireless doesn't work, since it's a broadcom
02:59:33 <Philippa_> Arafangion: it's IDE integration only atm
02:59:47 <Arafangion> Philippa_, What's the point, then?
02:59:54 <Philippa_> a good IDE for Haskell?
03:00:07 <Arafangion> ozone, Howcome? YOu installing linux on it? SHAME ON YOU!
03:00:28 <Arafangion> Philippa_, I'll piss on you before I let you call it "a good IDE" (!)
03:00:31 <Philippa_> (and it's being used as a research project into how GHC can provide good hooks for doing that kind of thing - access to stuff like the parser and typechecker is useful)
03:00:32 <ozone> Arafangion: lose the religious zealotry
03:00:37 <Philippa_> seconded
03:00:51 <ozone> and VS.NET is one of the best IDEs i've ever used, thank you
03:01:00 * Oejet need to read the QuickCheck and GADT papers.
03:01:00 <Arafangion> ozone, I didn't mind eclipse.
03:01:11 <Arafangion> Or Glade.
03:01:12 <Philippa_> yeah. There're many good things you can do with VS.net/haskell integration
03:01:14 <ozone> haven't used eclipse, though i hear it's quite good
03:01:19 <Arafangion> But the designer in VS.NET is pathetic.
03:01:31 <esap> Oejet: Btw, I also considered data C f g a = C (f (g a)) ; data FStack (f :: * -> *) where { FFrame :: f (FStack g) -> FStack (C f g) }
03:01:32 <Philippa_> SEP, it's not like haskell coders'll use it anyway
03:01:35 <ozone> Philippa_: at the very least, it'll stop pesky students emailing me about how to compile haskell programs on windows
03:01:39 <Philippa_> and it's largely a language/lib thing
03:01:40 <Philippa_> heh
03:01:54 <Philippa_> "there's this thing called the command line, right..."
03:01:56 <Arafangion> For instance: If you rename a widget, you should check the code to see if it changed, and if not, change it yourself.
03:02:09 <Philippa_> Arafangion: we giveth not a shit. It's somebody else's problem
03:02:15 <shapr> What about vendor support? if I buy a {power,i}book will it void my warranty if I install debian?
03:02:25 <ozone> shapr: neh
03:02:27 <Arafangion> shapr, Why install debian on it?
03:02:33 <ozone> and install ubuntu, not debian
03:02:38 <ozone> unless you want to go through serious pain :)
03:02:45 <shapr> Because closed source code is not valuable to me.
03:03:07 <Arafangion> shapr, Yes, but consider that: Fink is a port of debian to mac os x.
03:03:37 <Arafangion> shapr, Additionally, you loose the nice sleep mode the laptop has - the laptop completely wakes up *inside* of a second!
03:03:37 <shapr> Source code is primarily communication with humans.
03:04:02 <ozone> Arafangion: ubuntu works with powerbook's sleep mode out of the box
03:04:04 <shapr> I think that programmers who use windows are like mechanics who buy cars that have the hood welded shut.
03:04:09 <Arafangion> ozone, Nice.
03:04:28 <Philippa_> shapr: why thank you, dear :-)
03:04:37 * shapr grins
03:04:42 <ozone> shapr: if you're just going to run linux, get a pc laptop
03:04:43 <Arafangion> shapr, At least all the bolts are the same size ;) *ALL* the same size.
03:04:47 <ozone> cheaper
03:04:51 <ozone> (probably quite a bit cheaper)
03:04:56 <musasabi> the problem with mac os x, is that it is so nice and working.
03:04:57 <shapr> ozone: I may do that, thanks for the advice.
03:05:04 <Arafangion> shapr, Although it's a bit tricky to fit that huge nut on that tiny fuse...
03:05:13 <shapr> Mac hardware sure is sexy though.
03:05:19 <ozone> shapr: well, do a price comparison first
03:05:23 <musasabi> so it is hard to find a reason not to use it on a powerbook.
03:05:32 <ozone> shapr: depending on what features you need, the mac may come out better
03:05:35 <Arafangion> Mac os x is very, very nice.
03:05:48 <shapr> Arafangion: nut? fuse?
03:05:59 <ozone> e.g. if you want firewire, dvi out, etc, good luck finding all that in a pc laptop
03:06:35 <Arafangion> shapr, Nevermind.  A windows car wouldn't have a fuse anyway.
03:06:44 <Heffalump> what's useful about firewire?
03:06:45 <shapr> Arafangion: The greatest value to me in any computer is programmability. If I cannot modify the OS, that removes a large chunk of the programmability.
03:07:03 <Oejet> esap: You lost me there; that is shear voodoo.
03:07:06 <shapr> And yes, I know about OpenDarwin, etc :-)
03:07:25 <Philippa_> Heffalump: plenty if you already have firewire devices
03:07:33 <ozone> shapr: slashdot comment i read the other day sums mac os x nicely: "hack because you want to, not because you need to"
03:07:34 * Philippa_ used to have the original firewire Zen, for example
03:07:35 <Arafangion> shapr, then please, please port Enlightenment 17 to mac os x :)
03:07:55 <ozone> Arafangion: it already works
03:08:11 <ozone> Heffalump: tis rather useful if you have, say, a digital camera :)
03:08:11 <esap> Oejet: It's the same as the original stack, but the parameter has kind * -> *.
03:08:12 <Arafangion> It does? Wow.
03:08:13 <xerox> ozone: how is hacking the os "free" in osx?
03:08:22 <Heffalump> every digital camera I know of has a USB interface..
03:08:25 <ozone> xerox: not sure what you mean
03:08:30 <ozone> Heffalump: oops, i meant camcorder
03:08:35 <ozone> you know, those video fangled things
03:08:37 <Arafangion> Heffalump, Mine doesn't.
03:08:45 <shapr> ozone: wow, nice slashdot quote.
03:08:45 <ozone> that all these mac weenies use with this iMovie program and shtuff
03:08:51 <Arafangion> Heffalump, Came with a USB card reader!
03:10:16 <esap> Oejet: Note that the original version didn't use the type variable 'a' for anything. The second definition just makes that type to be of kind * -> *.
03:10:42 <Heffalump> my old Vaio has firewire, I think.
03:13:06 <esap> Oejet: Which means that the parameter can actually be used for specifying the type of the stack frame. The original version had existential quantification for the type of stack frame. The version with kind * -> * exposes the stack frame type.
03:13:58 <esap> Oejet: But it existentially quantifies the type of the *next* stack frame [but makes it recoverable using pattern matching].
03:14:03 <Philippa_> esap: this a bit like the encoding for tuples I keep playing with?
03:14:03 <Philippa_> yeah
03:14:06 <Philippa_> fair enough
03:14:35 <Philippa_> sort-of - um, doesn't this mean GADTs suddenly have to carry around more info than before?
03:14:47 <esap> philippa: what do you mean more info?
03:15:05 <Philippa_> the type of whatever's existentially quantified
03:15:20 <Oejet> Shouldn't it be: data Queue a where { Queue :: Stack a -> Stack a -> Queue (a,a) } ?
03:15:44 <tuomov> Arafangion: From what I've seen, I couldn't stand to use osx for five minutes..
03:16:14 <AdmiralFreezbee> hi
03:16:20 <esap> Oejet: No, I don't think so. The stack is already polymorphic and its type describes what kind of elements exist in the stack. But the queue, the types of the two stacks are not equal.
03:16:31 <Arafangion> tuomov, Each to his own.
03:16:58 <Oejet> esap: But they should be for all practical purposes?
03:17:07 <Arafangion> Although just about my only issue with the mac is it's inability to load more than one copy of a Gui program!
03:17:19 <Arafangion> (Or so it seems)
03:17:26 <esap> Oejet: No. When you read the queue, you only read one of the stacks.
03:17:40 <tuomov> I also do _not_ like apple hardware design. It's ugly.
03:17:53 <AdmiralFreezbee> little question: I have a function that returns a bool (let's say boolFun) I want to filter out all the elements of a list that don't make boolFun true
03:17:59 <tuomov> especially the white stuff is ugly, but I'm not too big on the silver fad either
03:18:05 <AdmiralFreezbee> I know the reverse is like this filter boolFun [......]
03:18:07 <Oejet> esap: You need to swap the stacks once in a while.
03:18:20 <esap> Oejet: The type for receive is: receive :: Queue (a,(b,c)) -> (b,Queue (a,c)) ; receive (Queue s1 (Frame (b,s2))) = (b,Queue s1 s2)
03:18:23 <xerox> AdmiralFreezbee: filter (not boolFun) ?
03:18:27 <esap> Oejet: yes.
03:18:30 <xerox> @type not
03:18:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not :: Bool -> Bool
03:18:37 <Arafangion> tuomov, The tibook is strong, though.
03:18:49 <AdmiralFreezbee> xerox: for some reason that doesn't work
03:18:50 <xerox> @type filter (not . (==))
03:18:51 <tuomov> tibook?
03:18:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
03:18:55 <Arafangion> tuomov, I had a friend drop it while riding a motorbike, and on another incident, droped a vacuum cleaner on it.
03:18:57 <Oejet> Someone fix lambdabot, please. :-|
03:18:58 <xerox> Hmpf
03:19:04 <xerox> @type filter (not . (==2))
03:19:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- filter (not . (==2)) :: forall a. (Num a) => [a] -> [a]
03:19:13 <esap> Oejet: reverse_queue :: Queue ((a,b),c) -> Queue (b,(a,c)) ; reverse_queue (Queue (Frame (s1,s2)) s3) = Queue s2 (Frame (s1,s3))
03:19:17 <Arafangion> tuomov, "That silver thing" is real titanium.
03:19:25 <xerox> Arafangion: boolFun = (==2) in that example.
03:19:36 <Arafangion> xerox, Pardon?
03:19:49 <xerox> Arafangion: filter (not . boolFun)
03:20:00 <AdmiralFreezbee> Arafangion: I think that's meant for me :-)
03:20:02 <Arafangion> xerox, Damn your crypitc!
03:20:09 <esap> Oejet: send :: a -> Queue (b,c) -> Queue ((a,b),c) ; send x (Queue s1 s2) = Queue (push x s1) s2
03:20:13 <xerox> whops, sorry Arafangion :)
03:20:19 <AdmiralFreezbee> ok thanks I'll give it a try
03:20:25 <Arafangion> xerox, Ahh, that makes much more sense :)
03:21:00 <AdmiralFreezbee> yep that works! Thanks xerox!
03:21:53 <xerox> AdmiralFreezbee: . compose functions, as in (f . g) x = f (g x) -- gotta go, lunchtime.
03:24:12 <esap> Oejet: Actually, I just realized it may be better to use 'data Queue a b where { Queue :: Stack a -> Stack b -> Queue a b } to distinguish the types of two queues. Makes it easier to understand, and might allow the queue to get an arrow type.
03:24:19 <ibid> wow:
03:24:21 <ibid> "Haskell dating. Find dates at Date.com's personals for Haskell,
03:24:24 <ibid> Oklahoma"
03:24:54 <ibid> hmm, nevermind :)
03:25:59 * Arafangion looks at it.
03:26:10 <Arafangion> ibid, btw, how far is Oklahoma from Australia?
03:36:28 <esap> Oejet: Btw, my reverse_queue was actually misnamed, it only does it for one element at the top of queue, should be doing it for all elements.
03:38:00 <ibid> Arafangion: i suppose your guess is as good as mine :)
03:38:27 <Arafangion> ibid, Dang.
03:39:02 <ibid> Arafangion: http://sequence.complete.org/node/45
04:14:34 <Janni> [A
04:33:40 <Janni> extern DECLSPEC int SDLCALL IMG_isPNM(SDL_RWops *src);
04:33:40 <Janni> extern DECLSPEC int SDLCALL IMG_isXPM(SDL_RWops *src);
04:33:40 <Janni> extern DECLSPEC int SDLCALL IMG_isXCF(SDL_RWops *src);
04:33:40 <Janni> extern DECLSPEC int SDLCALL IMG_isPCX(SDL_RWops *src);
04:33:40 <Janni> extern DECLSPEC int SDLCALL IMG_isGIF(SDL_RWops *src);
04:33:42 <Janni> extern DECLSPEC int SDLCALL IMG_isJPG(SDL_RWops *src);
04:33:44 <Janni> extern DECLSPEC int SDLCALL IMG_isTIF(SDL_RWops *src);
04:33:46 <Janni> extern DECLSPEC int SDLCALL IMG_isPNG(SDL_RWops *src);
04:33:48 <Janni> extern DECLSPEC int SDLCALL IMG_isLBM(SDL_RWops *src);
04:33:50 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadBMP_RW(SDL_RWops *src);
04:33:52 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadPNM_RW(SDL_RWops *src);
04:33:54 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadXPM_RW(SDL_RWops *src);
04:33:56 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadXCF_RW(SDL_RWops *src);
04:33:57 <dons> hmm..
04:33:58 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadPCX_RW(SDL_RWops *src);
04:34:00 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadGIF_RW(SDL_RWops *src);
04:34:02 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadJPG_RW(SDL_RWops *src);
04:34:04 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadTIF_RW(SDL_RWops *src);
04:34:06 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadPNG_RW(SDL_RWops *src);
04:34:08 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadTGA_RW(SDL_RWops *src);
04:34:08 <dons> Janni, you there?
04:34:10 <Janni> extern DECLSPEC SDL_Surface * SDLCALL IMG_LoadLBM_RW(SDL_RWops *src);
04:34:12 <Janni> Sorry!
04:34:17 <Janni> Yep.
04:34:38 <Janni> That was some paste!
04:46:53 <dons> @version
04:46:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sat Apr  2 22:43:47 EST 2005, GHC 6.4 (OpenBSD i386)
04:46:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:58:35 <metaperl> can I simplify this?
04:58:36 <metaperl> between a b c
04:58:36 <metaperl>         | a <= b && b <= c = True
04:58:36 <metaperl>         | a >= b && b >= c = True
04:58:36 <metaperl>         | otherwise        = False
04:58:36 <metaperl>  
04:59:54 <dons> well, the True stuff isn't needed, is it. between a b c = (a <= b && b <= c) || (a >= b && b >= c)
05:00:31 <dons> @type \a b c -> (a <= b && b <= c) || (a >= b && b >= c)
05:00:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- \a b c -> (a <= b && b <= c) || (a >= b && b >= c) :: forall a.
05:00:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                       (Ord a) =>
05:00:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                       a -> a -> a -> Bool
05:00:51 <metaperl> it seems unusual to have to provde the same a b and c and switch from >= to <=
05:01:01 <metaperl> but yes, I see that small optimization
05:01:12 <metaperl> maybe template Haskell is what I want
05:01:24 <metaperl> a 0 b && b 0 c
05:01:35 <metaperl> where 0 = <= and then >=
05:01:48 <metaperl> and we disjunct the two templates
05:02:25 <dons> between a b c = f a b c || f c b a where f x y z = x <= y <= z ?
05:02:48 <metaperl> ah yes!
05:02:59 <metaperl> thanks! I knew I could clean it up!
05:03:28 <dons> @pointless \a b c ->  b c = f a b c || f c b a where f x y z = x <= y <= z
05:03:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 16):
05:03:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected "="
05:03:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting variable, "(", operator or end of input
05:03:40 <dons> @pointless \a b c -> f a b c || f c b a where f x y z = x <= y <= z
05:03:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 44):
05:03:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected "="
05:03:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting variable, "(", operator, "||" or end of input
05:03:50 <Darius> let?
05:04:22 <Darius> metaperl: I think most people would find dons first version clearest
05:04:43 <dons> @pointless \a b c -> let f x y z = x <= y <= z in f a b c || f c b a
05:04:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 32):
05:04:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected "<"
05:04:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting variable, "(", operator, space, ";" or "in"
05:04:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ambiguous use of a non associative operator
05:04:49 <dons> bah.
05:05:05 <metaperl> I just hate repetition
05:05:15 <TheHunter> between a b c = compare a b /= compare b c ?
05:05:46 <TheHunter> @pointless \a b c -> let f x y z = x <= y && y <= z in f a b c || f c b a
05:05:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip flip (flip s (<=) . (((.) . &&) .) . (<=)) . (flip .) . s (s . ((s
05:05:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- . ((s . ((||) .)) .) . flip) .) . flip . flip id) (flip (flip . (flip .)
05:05:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- . flip (flip . flip id)))
05:05:50 <Darius> dons: x <= y <= z is not valid syntax.
05:06:03 <dons> oops.
05:06:09 <dons> thankyou TheHunter :)
05:06:23 <TheHunter> i probably should add where...
05:06:52 <metaperl> TheHunter, yes that is excellent
05:07:07 <metaperl> oh but what if a == b and b < c
05:07:09 <metaperl> hmm
05:07:23 <metaperl> just use f where f = (<=)
05:07:33 <dons> I agree with Darius, btw, the first version is idiomatic
05:07:40 <metaperl> now _that_ is pure beauty
05:07:52 <metaperl> but TheHunter's version has the least redundancy
05:08:16 <Janni> inRange (a,c) b || inRange (c,a) b
05:08:19 <TheHunter> but takes much longer to understand and I'm not even 100% sure it's correct yet.
05:08:29 <metaperl> lol
05:09:03 <metaperl> thanks Janni, I've never met you before
05:09:20 <xerox> TheHunter: it also doesn't support type decls, right?
05:09:36 <TheHunter> xerox, it's untyped.
05:09:42 <TheHunter> @pointless not $ not 4
05:09:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
05:09:50 <Janni> Is it that bad to meet me?
05:10:55 <Janni> Hello too, metaperl :)
05:11:03 <dons> xerox: it's just syntax, as we say round here.
05:12:44 <metaperl> no, thanks for your input
05:13:06 <dons> TheHunter: could you just use Language.Haskell.Parser.HsExp for @pointless parsing?
05:14:22 <xerox> :)
05:14:24 <TheHunter> that would have been simpler.
05:15:30 <dons> I think I'd like to add @pointless to Yi.
05:16:03 <dons> it's first plugin.
05:16:45 <TheHunter> hehe, go ahead
05:19:58 <Darius> Yes!  Just what's needed.  Editor support for point-free style programming.
05:20:31 <dons> hehehe
05:20:48 <dons> it _needs_ editor support ;)
05:22:21 <dons> I think @pointless pretty much has the last word on the recent "Is pointfree programming obfuscation?" thread on haskell@
05:22:56 * dons gets some sleep
05:24:24 <Darius> point-free style is not just the systematic eradication of the use of variables.
05:24:38 <Darius> Heck, it's not even the eradication of the use of variables.
05:31:13 <xerox> Shell.hs:60:2:
05:31:13 <xerox>     Warning: This binding for `error' shadows an existing binding
05:31:28 <xerox> Hm, maybe I know why.
05:31:39 <Darius> Anyways, @pointless compiles to a fixed set of combinators whereas in point-free programming you'd make relevant ones.
05:31:49 <Darius> error is a standard function in the Prelude
05:33:01 <TheHunter> any xchat guru around?
05:33:23 <xerox> launch' _ pName [] = error "Shell.pipe needs at least one element in argv."
05:33:31 <xerox> Shell.hs:52:10: Warning: Defined but not used: `pName'
05:34:03 <Darius> xerox: Yes, that should be obvious.  Note that dons has -Werror set which makes warnings into errors.
05:34:22 <xkb> Are there any Cocoa -> haskell bindings?
05:34:34 <xerox> Darius: ah, I tought was something I can't get.  It's just because of -Werror.. thanks.
05:35:43 <Cale> TheHunter: I use X-Chat at least.
05:36:07 <Janni> Bye
05:36:18 <xerox> No instance for (Integral ([Char] -> a)) arising from use of `fromIntegral' at Shell.hs:69:21-32   Probable fix: add an instance declaration for (Integral ([Char] -> a)
05:36:20 <Darius> xkb: There are definitely bindings to Objective-C stuff and I'm pretty sure there's at least someone who has done at least some work on Cocoa bindings.
05:36:21 <xerox> This is more complex :)
05:36:40 <TheHunter> Cale, ok do you know how to shorten the -lambdabot/#haskell- that is printed on every notice lambdabot sends to the channel
05:36:44 <xkb> Darius: ok, ill fire up trusty old google
05:36:50 <Darius> xerox: That's an actual error, but it looks like fromIntegral is being applied to something that's not fully applied.
05:36:50 <ozone> xkb: hoc.sf.net
05:36:54 <xkb> tu
05:37:08 <ozone> xkb: you'll need to check it out of CVS if you want to get it working with ghc 6.4
05:37:12 <xerox> Darius: I'd better resolve the "error" error.
05:37:24 <Darius> There's a do-binding to error.
05:38:06 <Cale> @pointless not $ not 4
05:38:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
05:38:11 <Cale> hmm...
05:38:30 <Darius> xerox: Ah, you probably changed the binding to error, but not the uses.
05:38:50 <xerox> Darius: In fact I didn't add code.
05:39:06 <xerox> Darius: I copied GHCiModule.hs to PugsModule.hs, trying to add @pugs.
05:39:20 <xerox> Modifying something, adding pugs to modules in the Makefile.
05:39:25 <TheHunter> "settings/advanced/text events" might be useful, but it seems like the value of the variable $1 is lambdabot/#haskell
05:40:56 <Cale> In my version it's $1/$2
05:41:07 <Cale> (plus other junk)
05:41:27 <Cale> but I can't save changes there for some reason, perhaps I'm using the global text events
05:41:54 <xkb> hoc looks promising
05:42:53 <Cale> @pointless \x y -> y x
05:42:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip id
05:42:54 <xerox> Hm I'd better use PlugsModule.
05:43:00 <Cale> yeah, that worked
05:43:11 <wilx> Hmf.
05:43:13 <wilx> Really.
05:43:18 <TheHunter> Cale, strange. I'm using the exact same version.
05:43:19 <wilx> This notice thingy is annoying.
05:43:24 <wilx> It keeps beeping.
05:44:00 <Cale> in .xchat2/pevents.conf change the event_text for Channel Notice to: %C12-%C13$1%C12-%O$t$3%O
05:44:33 <TheHunter> i'll try that, thanks
05:44:48 <metaperl> hi, I have coded up howManyEqual, but I think it can be done much better than I have done it: http://www.hcoop.net/~terry/haskell/craft-of-fp/ex/ex4.hs
05:45:27 <TheHunter> @versino
05:45:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "versino", try "lambdabot: @listcommands"
05:45:35 <TheHunter> ahhh.
05:45:38 <TheHunter> thanks.
05:48:43 <xerox> @version
05:48:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sat Apr  2 22:43:47 EST 2005, GHC 6.4 (OpenBSD i386)
05:48:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:53:39 <dons> it would be interesting for lambdabot to, if given a command it doesn't recognize, try permutations of the command to see if they match. that should solve most typos
05:54:07 <wilx> Hmm ;)
05:54:21 <dons> what do you think?
05:54:21 <xerox> dons: from what I can start to try to make @pugs ? GHCiModule or PlugsModule?
05:54:55 <wilx> Levenstein distance?
05:54:59 <wilx> Hmm, nice idea.
05:55:46 <dons> xerox; well, I reckon @pugs can be done, and kept safe, by running @plugs (pugs "foo"). but if you want to try to write a @pugs, the easiest way is to follow PlugsModule
05:55:58 <dons> popen "pugs", bascially
05:56:16 <dons> but that language doesn't have the typing guarantees that @plugs depends upon
05:56:22 * Darius isn't sure if he likes it, but has no particular arguments other than a general disdain for DWIM type systems.
05:56:36 <xerox> Do you mean using the Haskell interface to pugs?
05:56:47 <dons> yeah. I do too. but in the interests of reducing channel noise.
05:56:51 <Igloo> I think it's preferable to a page of typos when someone's having a bad day  :-)
05:58:19 <Igloo> Any Windows GHC users about?
05:58:36 <wilx> I use it on Windows.
05:58:47 <dons> xerox: the easiest way is to look at PlugsModule
05:59:15 <Cale> metaperl: well, that's an interesting idea, but the foldr (+) 0 is just sum, except that if you look at what you're summing, it's just the length of the list of things where that evaluates to true
05:59:51 <Igloo> wilx: Can you tell me if ":m + System.Posix.IO" then ":t fdToHandle" works in ghci please?
06:00:07 <metaperl> Cale, if one comparison is true, then the result == 2
06:00:13 <metaperl> because 2 are equal
06:00:49 <Cale> metaperl: so you can write it as hme a b c = sumToAmount $ sum [ 1 | [m,n] <- [[a,b], [b,c], [a,c]], m == n]
06:01:00 <wilx> Igloo, no System.Posix.IO here.
06:01:13 <Igloo> OK, ta
06:01:51 <metaperl> oh let me try that Cale
06:02:51 <Igloo> wilx: Is that 6.4?
06:02:54 <wilx> Yup.
06:03:16 <xerox> dons: the only part I miss is how runplugs work, simply running pugs would be enough? Maybe a --quiet version.. ?
06:04:40 <dons> PlugsModule just feeds the expression to runplugs on stdin. I don't know how pugs works - maybe they need a runpugs script, or command line flag?
06:06:52 <metaperl> Cale, unless I'm mistaken, you still must fixup the amount from the list comprehension: http://www.hcoop.net/~terry/haskell/craft-of-fp/ex/ex4.hs
06:06:55 <Darius> hme a b c = length (nub [a,b,c])
06:07:01 <Cale> metaperl: yes
06:08:11 <Darius> @plugs let hme a b c = length (nub [a,b,c]) in (hme 1 1 1,hme 1 1 2,hme 1 2 2,hme 1 2 3)
06:08:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (1,2,2,3)
06:08:43 <Cale> still requires some mangling
06:08:48 <Cale> but that's decent
06:09:20 <Darius> @plugs let hme a b c = length (nub [a,b,c]) - 1 in (hme 1 1 1,hme 1 1 2,hme 1 2 2,hme 1 2 3)
06:09:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (0,1,1,2)
06:09:31 * shapr tries recursive decent parsing
06:09:47 * Darius tries corecursive indecent unparsing.
06:09:57 <shapr> yow!
06:11:03 <metaperl> what pattern-matching allows me to get the first 3 elements of a list?
06:11:04 <metaperl> howManyEqual2 a:b:c:[] =
06:11:04 <metaperl>         fixAmount $ length [ 1 | (m,n) <- [ (a,b), (b,c), (a,c) ], m==n ]
06:11:04 <metaperl>  
06:11:12 <Darius> Oops, do (2 -) instead of (- 1)
06:11:20 <shapr> (x:y:z:rest)
06:11:42 <shapr> metaperl: your a:b:c:[] will only match a three item list.
06:12:08 <shapr> you're requiring that the rest of the list be empty.
06:12:28 <metaperl> yes
06:12:32 <Darius> metaperl: Also, you can pattern match [a,b,c]
06:12:33 <Igloo> You're also missing parens, so it would be parsed as (howManyEqual2 a):b:c:[]
06:12:46 <metaperl> that ws the point... oh yes a 3-tuple is better
06:12:46 <Darius> defining (:)
06:12:50 <metaperl> for data storage
06:13:27 <Igloo> No, (:) is a constructor, so can't be defined like that
06:14:06 <shapr> metaperl: How come Rob never responds to my email? Is it because my points are irrefutable? or because he hasn't finished reading all my references yet?
06:14:23 <Igloo> e.g., a:b:c = 5:6:[]   would define a, b and c, not (:)
06:14:32 <shapr> Haha, I like the data constructor on the Haskell dating site!
06:14:44 <metaperl> I'm not sure... he seems to be responding to everyone. Even when he got face-jobbed on the Perl for logic programming topic
06:15:03 <Darius> Igloo: You're right.
06:15:09 <metaperl> oh yes, that was hilarious
06:16:04 <metaperl> is there a way to convert a tuple to a list? how might I have looked this up?
06:16:08 <Darius> Anyways, idiomatically (for Haskell) one would use currying rather than a tuple unless there was some reason not to.
06:16:26 <Darius> metaperl: Pattern matching, threeTupleToList (a,b,c) = [a,b,c]
06:16:53 <Darius> Of course, that requires the tuple type to be of the form (a,a,a)
06:19:19 <RemiTurk> hello
06:19:43 <shapr> hoi Remi, hoe gaat het met jou?
06:20:18 <shapr> ik ben een tandeborstal!
06:20:35 <xkb> Ik wil schone tanden
06:20:38 <xkb> :D
06:23:17 <RemiTurk> shapr: goed hoor, lekker uitgeslapen vandaag: gister om 5u m'n bed uit voor 'n tentamen ;)
06:23:43 * RemiTurk wonders whether the Dutch Conspiracy has finally arrived without me even knowing
06:24:06 * basti_ liked the Van Gogh Museum
06:24:31 * RemiTurk has never been to the van gogh museum
06:25:03 <RemiTurk> though he probably passes it twice a day by tube
06:25:29 <RemiTurk> subway, whatever
06:50:18 <xkb> RemiTurk: your on the UvA?
06:50:23 <xkb> euhh
06:50:25 <xkb> bad spelling
06:50:26 <xkb> :D
06:57:06 * shapr throws unicycles
07:01:05 <xkb> anyone here using HXMLToolbox?
07:02:50 * RemiTurk comes back to his computer and notices he does indeed study at the UvA
07:03:01 <RemiTurk> but not right now
07:03:38 <xkb> lol
07:03:48 <shapr> You have HXT questions?
07:04:11 <RemiTurk> xkb: why?
07:04:52 <xkb> RemiTurk: I thought you meant not at this time, as in literally 17:05 pm on a saturday
07:04:59 <xkb> shapr: not yet
07:05:02 <shapr> ok
07:05:12 <xkb> I want to write a simple commandline app to test Xpath expressions
07:05:29 <xkb> and maybe lateron a simple gui that works on solaris a.w.a. Windows
07:41:52 * Darius wonders how to get the Windows IME to take romaji typed with dvorak with QWERTY as the default layout...
07:42:21 * basti_ doesnt
07:47:04 <TheHunter> hmm, seems like Data.Set is missing an O(1) way to get an arbitrary element out of the set.
07:48:38 <RemiTurk> to merely _get_ it or do you want it to return the remaining tree too?
07:49:15 <TheHunter> merely get one would be enough
07:50:13 <RemiTurk> *looks at base/Data/Set.hs
07:50:24 <RemiTurk> seems simple enough: -- | A set of values @a@.
07:50:24 <RemiTurk> data Set a    = Tip
07:50:24 <RemiTurk>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
07:50:51 <RemiTurk> though you'll have to use your own MySet.hs if you don't want to recompile the libraries I guess
07:50:55 <TheHunter> yes, it's simple. But still missing.
07:51:01 * TheHunter tries unsafeCoerce#
07:52:07 * RemiTurk keeps his phone ready, with 112 already typed
07:52:21 <basti_> should there be a haskell emergency line?
07:52:54 <mflux> aren't the spiritual hotlines already taking care of that?
07:53:07 <basti_> -g-
07:53:12 <basti_> we should try.
07:53:31 <Igloo> Hmm, does "hugs -Fcpp" work for anyone?
07:53:37 <basti_> the double meaning of "monad" could give some stuff for pranks
07:53:45 <RemiTurk> I doubt one line could be broad enough. there's a rather large difference between "how do I convert IO Int to Int?" and "I cut my hand off with unsafeCoerce#"
07:54:06 <basti_> -g-
07:54:51 <RemiTurk> Igloo: it gives me huge amounts of "unterminated charactar constant" errors and then dies with "FATAL ERROR: Unable to load Prelude"
07:55:33 <Igloo> Interesting - it gives me Syntax error in input (unexpected symbol "#")   in the Prelude
07:56:00 <Igloo> Anyway, looks like   hugs -F"cpphs --noline"   is my friend
07:56:13 <RemiTurk> I've got the November 2003 version here
07:56:17 <TheHunter> yeah! unsafeCoerce# even works.
07:56:36 <RemiTurk> using an isomorphic type to The Real one I guess
07:56:37 <RemiTurk> ?
07:56:50 <TheHunter> yes
07:57:36 <RemiTurk> sounds like someone considers that disgusting enough to leave..
08:08:32 * Darius curses.
08:19:35 * Darius uses his knowledge of German to try to figure out how to talk Japanese on an English system.
08:19:48 <RemiTurk> sounds like fun..
08:26:42 * sqrt just made an alias yow="/usr/games/fortune zippy" ... heh.
09:05:41 <Mowa> http://www.resellerads.com
09:06:12 <Lemmih> Stupid spam bot ):
09:06:33 <metaperl> fac :: Int -> Int --- this is not accurate. It should be Whole -> Whole. If you were building a software system how would you trap negative numbers or other inappropriately typed data sent to fac()
09:06:43 <metaperl> fac being factorial
09:08:39 <Igloo> You could use fac :: Word -> Word
09:10:44 <metaperl> @type error
09:10:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- error :: forall a. [Char] -> a
09:11:10 <metaperl> is the error function the same as what Haskell does when it has a type error
09:11:13 <metaperl> for instance
09:11:15 <metaperl> fac 0 = 0
09:11:17 <RemiTurk> tough probably not Data.Word.Word, as fac 13 already doesn't fit in a 32bit value :)
09:11:20 <Heffalump> no, because it happens at runtime
09:11:22 <metaperl> fac n = fac (n-1) * n
09:11:40 <Heffalump> if you define fac n as product [1..n] then it's well-defined on negative numbers
09:11:47 <metaperl> otherwise = error "invalid number passed to fac"
09:14:33 <Igloo> RemiTurk: It's better than Int...
09:15:56 <RemiTurk> Igloo: actually, it isn't...
09:17:19 <RemiTurk> both Int & Word go wrong when n>12 (or n>20 if 64bit)
09:17:37 <RemiTurk> although it is better from a typesafety point of view indeed
09:17:44 * RemiTurk slaps forehead
09:17:44 <Igloo> s/better/no worse/
09:18:41 <jlouis> dons: ?
09:18:54 * RemiTurk has code to use GMP's factorial function, which is rather fast :)
09:19:36 <Heffalump> in principle Haskell ought to generate as fast code, shouldn't it?
09:19:52 <Heffalump> I guess it has no access to the internal GMP representations
09:19:57 <RemiTurk> I doubt it
09:20:18 <RemiTurk> I suspect GMP uses some clever algorithms haskell doesn't
09:20:32 <RemiTurk> and in practice, parts of the GMP version may well be written in assembly
09:21:06 <Heffalump> does the FFI allow you to get at the GMP representation of Integer?
09:21:19 <RemiTurk> not really
09:21:38 <metaperl> Thompson is wrong: "The pattern of primitive recursion says that we can define a function from the natural numbers 0,1, ... by giving the value at zero, and by explaining how to go from the value at n-1 to the value at n."
09:21:39 <RemiTurk> I've written a few new primops to do more or less that some weeks ago
09:21:50 <metaperl> natural numbers start with 1 not 0
09:21:55 <metaperl> whole numbers start with 0
09:21:57 <Heffalump> not in CS.
09:22:00 * RemiTurk disagrees with metaperl
09:22:14 <metaperl> oh really?
09:22:16 <Heffalump> Mathematicians think they start at 1, computer scientists think they start at 0.
09:22:27 <metaperl> I didnt know that
09:22:33 <jlouis> lambdabot: @yow
09:22:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't find yow file
09:22:42 <jlouis> pretty close
09:23:03 * RemiTurk goes to mathworld
09:23:15 <RemiTurk> (mathworld.wolfram.com)
09:23:21 <ibid> i thought whole numbers were synonymous with integers
09:23:25 <RemiTurk> A positive integer 1, 2, 3, ... (Sloane's A000027). The set of natural numbers is denoted N. Unfortunately, 0 is sometimes also included in the list of "natural" numbers (Bourbaki 1968, Halmos 1974), and there seems to be no general agreement about whether to include it. In fact, Ribenboim (1996) states "Let P be a set of natural numbers; whenever convenient, it may be assumed that 0 in P."
09:23:27 <jlouis> There is no defined standard
09:24:03 <jlouis> Sometimes one writes (LaTeX notation) \mathcal{N}_0 for \mathcal{N} \cup \{0\}
09:24:14 <jlouis> \mathbb even
09:24:18 <ibid> the finnish word for integers, kokonaisluvut, is literally translated as whole numbers :)
09:24:47 <ibid> anyway, the only thing that matters is that your readers know what you mean :)
09:32:04 <metaperl> the web has not shown that Haskell has a generalized primitive recursion function... I would think it would have such a combinator somewhere
09:33:58 <Heffalump> sorry?
09:34:17 <xerox> iterate?
09:34:33 <ibid> you mean a function that transforms an element and a function into the set of its values?
09:34:54 <ibid> into the prec-set that it they generate
09:35:04 <metaperl> well yes. you know the primitive recursion pattern right?
09:35:11 <metaperl> I am reading it in Thompson's book
09:36:18 <TheHunter> http://www.eyrie.org/~zednenem/2004/hsce/Control.Recursion.html#v%3Apara
09:37:28 <ibid> metaperl: i don't know that such a combinator would me of much use
09:43:15 <metaperl> ibid, yes, para() looks like just as much work as writing the primitive recursive function :)
09:54:46 <xerox> Are you talking about folding?
09:58:36 <TheHunter> primitive recursion is a generalization of folding, yes.
10:10:46 <xerox> How do you generalize folding?
10:12:42 <ibid> primitive recursion is older than folding :)
10:14:24 * xerox personally likes folding
10:15:06 <xerox> Sometimes I think on how to use folding to solve some problem, tough I don't know if it's the best way for that particular job.
10:15:42 <xerox> Maybe because I know only some way to do things in Haskell.
10:18:39 * jlouis refactors lambdabot code in QuoteModule
10:18:57 <TheHunter> xerox, the "recursion schemes from comonads" paper discusses a lot of generalizations of folds, but is quite theoretical :)
10:28:23 <heatsink> Parsec likes to combine error messages from different <|> choices.  How do I make it print a specific error message and suppress the others?
10:28:50 <Heffalump> does it use String for errors?
10:28:53 <Heffalump> Or is it parametrised?
10:29:23 <Heffalump> if the latter, generate some kind of type that indicates priority, and filter the resulting list
10:29:39 <heatsink> it's not parametrised, but it's not a string.  It's a datatype defind by the library.
10:31:09 <Oejet> It annoys me a bit that GHC doesn't recompile when you just change the optimization options.
10:31:18 <heatsink> Oejet: yea
10:32:26 <Heffalump> don't rely on its inbuilt recompilation checking, then
10:32:35 * Heffalump uses ghc -M and Makefiles for anything complicated
10:33:01 <Heffalump> personally I think --make is nasty, though it's useful for getting started quickly
10:33:37 <jlouis> what should one check out from GHC HEAD? fptools?
10:42:31 <xkb> Im trying to build cabal's setup
10:42:51 <xkb> got the following error: "unkown package name: Cabal"
10:43:00 <xkb> any ideas what I can do to fix this?
10:43:09 <xkb> ghc 6.2.1
10:45:02 <xkb> anyway, time to upgrade ghc on this machine :D
10:52:52 <Oejet> a.out  2.08s user 0.03s system 98% cpu 2.136 total
10:53:46 <Oejet> a.out counts from 1 to 10^7 and prints out the last number.
10:59:29 <Oejet> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:59:53 <Oejet> I'll try to profile it.
11:00:20 <TheHunter> Oejet, change modifySTRef to readSTRef; writeSTRef .. $! ..
11:00:30 <Heffalump> ICK!
11:00:40 <Heffalump> can't you just make the modify function use $! ?
11:01:41 <TheHunter> or you can do that, but there's no modifySTRef' in the libs.
11:01:43 <Oejet> Hm, if I find out what $! is, then yes I suppose so.
11:02:03 <Heffalump> f $! x = x `seq` f x
11:02:04 <TheHunter> f $! x = x `seq` f x
11:02:20 <Heffalump> which means evaluate x to weak head-normal form, then pass it to f
11:02:20 <Oejet> Scary.
11:03:13 <metaperl> I want to internalize a function. It is at the top of this file: http://hcoop.net/~terry/haskell/craft-of-fp/ex/ex4.hs
11:03:35 <Heffalump> internalize?
11:03:46 <metaperl> intSqrt n = intSqrtInternal n n
11:03:47 <metaperl> intSqrtInternal n s
11:03:47 <metaperl>   | n == 0 = 0
11:03:47 <metaperl>   | n == 1 = 1
11:03:47 <metaperl>   | otherwise = if square(s) <= n then s else intSqrtInternal n (s-1)
11:05:52 <metaperl> also: if-then-else takes 3 arguments, but it doesn't appear that it can be written in prefix form. i.e.: (ifthenelse) test then_branch else_branch
11:06:49 <xkb> bah.. readline error
11:07:07 <xkb> another version of readline is already active.. hmm how to overwrite that
11:08:28 <Oejet> a.out  1.57s user 0.03s system 99% cpu 1.611 total
11:09:45 <Oejet> Paste updated.
11:15:07 <Oejet> modifySTRef c f = do{ n <- readSTRef c; writeSTRef c $! f(n) }
11:15:25 * Oejet compares with GHC in CVS.
11:15:51 <xkb> anyone using ghc on mac from darwinports?
11:16:06 <nmoore> is there any way that obtain information about the local Char type, i need to be able to list all the defined Chars
11:18:21 <Oejet> modifySTRef ref f = writeSTRef ref . f =<< readSTRef ref
11:18:31 <nmoore> no takers? i'll just assume that there are 256
11:18:37 <Heffalump> that's equivalent apart from the lack of $!
11:18:46 <Heffalump> nmoore: is it an instance of Enum?
11:19:13 <TheHunter> @plugs maxBound :: Char
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `Char' against `String'
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: Char
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: String
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the expression: show $ maxBound
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     When checking the type signature of the expression:
11:19:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	  show $ maxBound :: Char
11:19:27 <Oejet> Heffalump: Yes, so I guess lazyness has an evil laugh in this instance.
11:20:25 <TheHunter> @plugs fromEnum (maxBound :: Char)
11:20:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1114111
11:21:09 <nmoore> TheHunter: thanks
11:21:29 <TheHunter> nmoore, well that doesn't say much, it's just the last unicode codepoint.
11:22:23 <nmoore> TheHunter: it tells me how i can enumerate Chars
11:42:43 <basti_> shapr: -ping- so how would one generate a penrose tiling in a manageable way at all?
11:49:40 <mwc> I'm having some trouble with ghc, I'm using the Mac OS X binary from the GHC site...
11:49:40 <mwc> checking for ghc... ghc
11:49:40 <mwc> checking where GHC keeps its libraries... /usr/local/lib/ghc-6.4
11:49:40 <mwc> checking GHC.Handle.openFd... NOT old API
11:49:40 <mwc> checking GHC.Handle.openFd new API... failed
11:49:40 <mwc> configure: error: Couldnt figure out how to call GHC.Handle.openFd!
11:49:52 <mwc> What does that mean? The library isn't installed correctly?
11:51:36 <Lemmih> mwc: Try #darcs.
11:52:19 <mwc> Lemmih, asked in there, no response, think it's a compiler problem
11:52:42 <Lemmih> It's not. It's a problem with the darcs configure script.
11:54:01 <Lemmih> I think shapr solved it somehow, check out http://www.scannedinavian.org/~shae/darcsApril1.tar.bz2
11:54:28 <mwc> Lemmih, oh
11:58:32 <nmoore> thanks
12:02:36 <shapr> did he?
12:02:50 <shapr> basti_: seems most people use L-systems
12:03:18 <Lemmih> Didn't you?
12:03:25 <basti_> shapr: but those keep repeating themselves...
12:03:40 <basti_> i was thinking like an algorithm that gives you "layers" (or something) of tiles.
12:03:46 <basti_> i came across the projection method
12:04:16 <basti_> the pope is dead.
12:04:21 <shapr> oh
12:04:35 <basti_> not that we'd mind.
12:04:36 <basti_> ;)
12:04:59 * Heffalump 's opinion on the subject is verging on 'good riddance', but not quite
12:06:28 <Lemmih> I wonder how straightforward hacking import splicing would be.
12:07:52 <shapr> autrijus added sockets, threads, and removed 6.2 support today, yay!
12:08:28 <Philippa> Heffalump: at least it didn't interrupt Dr Who. Here's hoping the next one won't make the AIDS-in-Africa situation worse
12:08:44 * Heffalump has no TV
12:09:53 <Philippa> ouch
12:10:04 <Philippa> well, assuming you care :-)
12:10:25 <Philippa> oh, I may be in cam in a couple of weeks or so (exact date not yet set)
12:10:31 <Itkovian> well, every person dying is a tragedy in its own way ... so ...
12:10:54 <shapr> yeah
12:10:58 <Heffalump> I don't care. I'm sort of enjoying my fights with TV licensing.
12:11:06 <shapr> Philippa: you'll have a webcam? finally?
12:11:11 * shapr is joking
12:11:12 <Itkovian> btw, cnn repots he's still alive ...
12:11:32 <Heffalump> Itkovian: yes, I feel sorry abot any death on a personal level, but for me that's outweighed by the evil I believe he's caused. The counter balance is that they'll just replace him anyway.
12:11:46 <Philippa> shapr: I can start taking donations ;-)
12:12:00 <shapr> I owned a TV for a coupla months once. It was free. I never used it, so I gave it away.
12:12:04 <Itkovian> yeah, I agree with that. I also think they shouldn't make such a big fuss about it, but the truth is that the catholic church has a _lot_ of power still.
12:12:27 <Itkovian> meanwhile thousands die around the world, but nobody talks about them.
12:12:49 <Philippa> odds are somebody else's died since we all got the news. Unfortunate flukes aside, nobody here cares who /that/ person was
12:12:50 <shapr> People are born and die every day.
12:12:52 <Philippa> right
12:12:57 <shapr> We might care.
12:13:05 <Heffalump> I think talking about the deaths of important people is worthwhile, but for me the Pope is only important in a negative way.
12:13:09 <shapr> I have a very global view of economics.
12:13:26 <Itkovian> Heffalump: I agree with you there ...
12:13:37 <Heffalump> Philippa: I'll be in Iceland from 12th-20th April ish
12:13:53 <tuomov> nobody's important, only the position is
12:14:07 <Itkovian> no, everybody's important, the position isn't
12:14:14 <Philippa> Heffalump: 'k. Want me to yell if things happen in the couple of days or so either side of that?
12:14:16 <Itkovian> anyway ... ttyl
12:14:20 <shapr> Yeah, I like the second approach.
12:14:21 <tuomov> that's another way of looking at
12:14:24 <Heffalump> sure.
12:14:37 <Heffalump> I think I'm more likely to be free the weekend after than the weekend before.
12:14:45 <tuomov> but if you start listing just a few important persons, its the positions, not the persons that really matter
12:14:51 <Philippa> 'k
12:14:57 * Heffalump thinks it's the combination of person and position that matters.
12:15:10 <Heffalump> e.g. Jim Callaghan died recently and he was just another British Prime Minister
12:15:16 <Heffalump> bu Churchill was more than that
12:15:43 <tuomov> position has to be taken more generally than a title
12:23:40 <shapr> So, anyone written cool Haskell code today?
12:24:27 * Heffalump is thinking about making a (specialised to a specific application for now) SQL query constructor.
12:24:48 <Lemmih> I updated my SDL package to use hooks and a configure script.
12:24:51 <shapr> something based on the HaskellDB thingy?
12:24:55 <shapr> ah neat
12:25:11 <Heffalump> no, my own thing. Once I understand what the issues are I might start thinking about using haskellDB
12:26:09 <shapr> I like HaskellDB a lot. The simplicity I'm seeing in pugs encourages me to try hacking in a per-backend sql generation for HaskellDB.
12:27:27 * Janni is back for another hour
12:27:39 <Lemmih> Hey Janni.
12:27:41 <shapr> y0
12:29:29 <Janni> Lemmih: I don't like that configuring stuff. Now we have Cabal which makes everything clean and nice and then you start compromising all over again ;). But seriously, I don't like it.
12:30:32 <Lemmih> Janni: Cabal calls the configure script by itself. You wont even know it's there (:
12:30:57 <lightstep> if i have T::*->*, can i write a function f::T a->Int, where f (x::T ()) = g x, f (x::T Int) = h x ?
12:31:48 <Janni> I know, I know, but I think it could be possible to include system dependent information in the Cabal file itself in a reasonable way, not starting that whole scripting and autoconfing thing again...
12:31:53 <TheHunter> lightstep, no
12:31:59 <Janni> Or am I the only one, who thinks that way?
12:32:06 <TheHunter> you can write f :: Typeable a => T a -> Int, though
12:32:34 <shapr> Janni: I've wondered about that myself.
12:32:56 <shapr> I know there's a make-like Haskell product called Maak.
12:33:11 <Lemmih> Like shell escaping?
12:33:25 <lightstep> i want a `subprogram' type, which can represent either procedure or function. i figure classes are the only option?
12:34:18 <TheHunter> what's a procedure?
12:34:33 <TheHunter> data Fun a b = Pure (a -> b) | Impure (a -> IO b) ?
12:34:50 <lightstep> a subprogram that doesn't return a value (the object language is nonpure)
12:35:12 <lightstep> but i think i figured out a solution to my case
12:35:19 <shapr> sylvan: hej! I got your article! But I haven't read it yet.
12:35:20 <lightstep> i'll be back if it won't fit :)
12:38:30 <Janni> Hmm, what's the easiest OS independent way, to determine if "myfile" is a directory or a file?
12:38:41 <tautologico> anyone familiar with algorithmic subtyping ? (like in TAPL)
12:39:01 <Lemmih> Only having Debian boxes sucks for portability testing /-:
12:39:18 <shapr> Lemmih: you could install VMS
12:39:33 <shapr> or AIX, or BeOS, or..
12:39:54 <lightstep> Janni, System.does(File|Directory)Exist ?
12:41:10 <Janni> lightstep: thx
12:42:30 <wilx> Eeek! on VMS!
12:42:53 <wilx> Does anybody really use it?
12:42:59 <wilx> Well, except my uni :/
12:43:51 <shapr> What about CP/M ?
13:26:10 <lightstep> why does Cont have two type parameters? is `r' different from `a' sometimes? or is it to force threading the continuation, like in ST?
13:35:59 <Cale> lambdabot: A value of type Cont r a is a CPS computation that produces an intermediate result of type a within a CPS computation whose final result is r.
13:36:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
13:36:11 <Cale> er, lightstep, rather
13:36:37 <lightstep> final result? what does that mean? why should the computation care?
13:37:03 <TheHunter> @info Control.Monad.Cont
13:37:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "info", try "lambdabot: @listcommands"
13:37:28 <TheHunter> newtype Cont r a = Cont { runCOnt :: (a -> r) -> r }
13:37:34 <lightstep> yes
13:37:45 <lightstep> what function does r play?
13:38:09 <lightstep> all the actual values are polymorphic in r anyway, are'nt they?
13:38:13 <TheHunter> you "run" the computation like this: m `runCont` id
13:38:35 <TheHunter> they don't have to be polymorphic.
13:38:53 <TheHunter> For example, if you use shift/reset.
13:40:59 <lightstep> why would the library writer want to complicate the type in order to support running the continuation with something other than id?
13:41:14 <lightstep> you could apply your function to the result anyway
13:41:37 <TheHunter> @type callCC
13:41:42 <TheHunter> @type Control.Monad.Cont.callCC
13:41:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
13:41:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.Cont.callCC :: forall (m :: * -> *) a b.
13:41:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                              (Control.Monad.Cont.MonadCont m) =>
13:41:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                              ((a -> m b) -> m a) -> m a
13:42:29 <TheHunter> callCC couldn't be implemented using a single-parameter Cont type.
13:42:57 <TheHunter> this is roughly similar to the situation in ST.
13:43:27 <TheHunter> also, there are cases where you need a fixed answer type.
13:43:31 <lightstep> i can't understand why. i tried to implement it on paper, but failed. is there some simple argument why it can't be done?
13:44:04 <TheHunter> "forall r. Cont r a" and "a" are isomorphic because of parametricity.
13:44:11 <lightstep> yes
13:44:16 <lightstep> no
13:44:31 <lightstep> oh, yes. i see it now.
13:44:52 <TheHunter> so it's just an Identity monad.
13:45:32 <lightstep> yes, monads are alwauys CPS. but you have to care for interactions between >>= and callCC
13:48:12 <lightstep> which requires the type ((a->a)->a), which is similar to a, but i don't know if they're isomorphic
13:48:37 <TheHunter> they're usually not isomorphic.
13:49:23 <lightstep> yes, they aren't. but if you always run the continuation with id, does it matter?
13:50:49 <TheHunter> yes it matters, because something of type (a -> a) -> a can contain effects that are lost when you run the monad.
13:53:41 <lightstep> but Cont (the data constructor) isn't exposed to the user, and the implementation is polymorphic in a, so it can't introduce type-specific effects
13:54:09 <TheHunter> Cont is exposed to the user
13:54:17 <TheHunter> @type Control.Monad.Cont.Cont
13:54:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.Cont.Cont :: forall a r.
13:54:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                            ((a -> r) -> r) -> Control.Monad.Cont.Cont r
13:54:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- a
13:58:05 <lightstep> thanks, i'l go back to my notebool for a while again
14:00:33 <TheHunter> hehe, "Verlassend!!!", is that supposed to be German?
14:07:36 <tautologico> TheHunter: it could be
14:07:45 <tautologico> I think
14:17:05 <liquidengineer> hi
14:17:09 <shapr> y0
14:17:23 <liquidengineer> say I've got an enumerated type that contains three possible values
14:17:28 <liquidengineer> ONE, TWO, and THREE
14:17:33 * shapr says that.
14:17:38 <liquidengineer> I have a variable of that type in a function
14:17:46 <liquidengineer> I want to be able to do this
14:17:48 <liquidengineer> eNum == One
14:17:50 <liquidengineer> as a guard
14:18:11 <shapr> What does that do?
14:18:28 <liquidengineer> haskell is telling me Instance of Eq ExamNbr required for definition of updateRecord
14:18:40 <shapr> That makes sense.
14:18:46 <liquidengineer> do I just need to tell it to derive Eq when I define the data type?
14:18:50 <shapr> Sure.
14:19:03 <liquidengineer> how ... delightfully simpl
14:19:03 <liquidengineer> e
14:22:03 <Heffalump> assuming that structural equality is semantically correct for that data type.
14:26:09 <liquidengineer> it is
14:26:13 <liquidengineer> They're exam numbers
14:26:26 <liquidengineer> saying Exam 1 == Exam 1 is correct
14:26:37 <liquidengineer> slightly more complicated question
14:26:47 <liquidengineer> I've got a snippet of code I'd like to show ya'll
14:26:52 <liquidengineer> where is the paste bin again?
14:26:58 <shapr> @wiki HaskellIrcPastePage
14:26:58 * liquidengineer is going to bookmark it this time
14:26:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
14:29:31 <liquidengineer> can ya'll see it?
14:30:19 <liquidengineer> I need t to = the mean of s1, s2, and s3
14:30:56 <liquidengineer> I'm not quite sure how to pass it the tuple
14:31:08 <shapr> pass the tuple to what?
14:31:16 <liquidengineer> (I'm considering writing a tiny little function called averager
14:31:24 <liquidengineer> takes three numbers and returns the average
14:31:30 <shapr> Good idea.
14:31:33 <Cale> mean xs = sum xs / (fromIntegral $ length xs)
14:31:49 <Cale> would be one way to write it for lists
14:31:57 <liquidengineer> But I've got a tuple
14:32:05 <liquidengineer> it's no problem writing it
14:32:14 <shapr> Since it's a statically sized tuple, why not just hardcode it?
14:32:15 <Cale> yeah
14:32:20 <Cale> you could :)
14:32:25 <liquidengineer> I just got a little confused on how to tell it what values to take
14:32:45 <shapr> Like I've said before, no sane Haskell code would treat a tuple as a sequence.
14:33:12 <liquidengineer> I don't want to treat it as a sequence
14:33:18 <liquidengineer> the point is it's got three numbers in it I need
14:33:28 <liquidengineer> the rest of its content is moot for this part of the program
14:33:32 <Cale> extracting the right parts of a tuple and putting them in a list or passing them to a function isn't so bad
14:33:34 <liquidengineer> my question is this
14:33:49 <Heffalump> data Foo a = NoMore () | More (a,Foo a)
14:33:56 <liquidengineer> notice the gaurds that assign the updated scores based on the value of examNumber?
14:34:00 <Heffalump> there you go, tuple being used for a sequence
14:34:10 <Cale> ... eNum == One = (name, newScore, s2, s3, mean newScore s2 s3, A) ...
14:34:16 <Heffalump> now, are you claiming that Foo is an insane datatype?
14:34:25 <Cale> where mean a b c = (a + b + c) / 3
14:34:39 <Cale> is that what you want?
14:34:48 <liquidengineer> Cale: exactly how I want to define the mean function, yes
14:35:07 <shapr> Heffalump: I am in fact claiming that the homework assignment that liquidengineer got is not a good tool for teaching Haskell and/or FP. And that I would like to educate the teacher who assigned this homework. :-)
14:35:34 <liquidengineer> shapr: and that's really beside the point, and we both know it
14:35:38 <shapr> Yeah, we do.
14:35:40 <liquidengineer> It exists.  Therefore it must be solved
14:36:08 <shapr> But one of my goals is to teach stuff to people, and I like to teach Haskell via IRC.
14:36:40 <shapr> So I think I would be able to suggest different exercises that focussed on various points, tuples as types, lists as sequences, etc.
14:36:42 <liquidengineer> Cale: that's a really simple way of doing it...
14:36:49 <liquidengineer> Cale: I've been programming in Java too long
14:36:58 <liquidengineer> it's ruined my brain for simple stuff
14:37:01 <liquidengineer> which Haskell should be
14:37:13 <vegai> we got plenty of complex stuff here too ;)
14:37:19 <shapr> Yeah, fun stuff.
14:37:20 <Cale> liquidengineer: another would be if you had a general mean function on lists, you could just do  mean [newScore, s2, s3]
14:37:38 <vegai> quite fun, if you are so inclined
14:37:44 <liquidengineer> vegai: you know what I mean, though.  List comprehensions for an example, are something so simple but so foreign to a Java nerd
14:37:54 * vegai nods.
14:38:18 <Cale> If you end up needing to compute the mean elsewhere, you then save on code :)
14:38:59 <liquidengineer> indeed
14:39:11 <liquidengineer> I have a bad habit, though
14:39:47 <liquidengineer> Since I don't know if I'll ever be assigned something where I have to compute the mean, I'm reluctant to write it as a reusable function
14:39:54 <liquidengineer> if I were making my own function library, that'd be different
14:40:58 <liquidengineer> I have another question
14:41:03 <liquidengineer> notice the part that says A?
14:41:04 <shapr> oh me too!
14:41:12 <shapr> g = A
14:41:16 <liquidengineer> yeah
14:41:41 <liquidengineer> I had initally intended for g = to somehow assign the matching letter grade to the average
14:42:03 <shapr> huh?
14:42:31 <liquidengineer> if I call a function to do this (e.g.: setGrade) and pass it the tuple, will it be the new tuple updated with the new mean?
14:42:43 <liquidengineer> eg. g = setLetterGrade
14:42:59 <shapr> why not just partially apply updateRecord?
14:43:18 <liquidengineer> the more I can seperate it out the easier it is for me to understand
14:43:23 <shapr> Yeah, I agree.
14:43:26 <shapr> Same for me.
14:43:47 <liquidengineer> and I don't know haskell real well yet, so I like where statements because they really show you what's going on
14:43:49 <shapr> What does the g stand for?
14:43:53 <liquidengineer> grade
14:43:54 <liquidengineer> A
14:43:54 <liquidengineer> B
14:43:55 <liquidengineer> C
14:43:56 <liquidengineer> etc.
14:43:56 <shapr> what grade?
14:44:03 <shapr> target grade?
14:44:06 <liquidengineer> the equivilent letter to the mean
14:44:08 <shapr> received grad?
14:44:26 <shapr> Why do you need to know the grade? Where do you get the grade?
14:45:08 <liquidengineer> eg. if the mean is 95.5, the letter grade is an A\
14:45:20 <shapr> ohh
14:45:49 <liquidengineer> I think I just answered my own question
14:45:59 <shapr> Yes, you can make a getGrade function separately.
14:46:04 <shapr> That's a good idea.
14:46:31 <liquidengineer> instead of trying to pass the entire tuple to getGrade, I'll just pass it the result of mean a b c
14:46:43 <shapr> Right, exactly.
14:46:51 <liquidengineer> neat. :D
14:47:03 <shapr> getGrade should only receive a number, and return the letter.
14:47:24 <shapr> I wouldn't even put it into a where, I'd put it into a whole new function.
14:49:41 <liquidengineer> I just trashed the where
14:49:42 <liquidengineer> :D
14:50:26 <shapr> I mostly use where for fiddly details of the main function that are necessary, but don't contribute to understanding the code.
14:51:40 <liquidengineer> ah
14:51:45 <liquidengineer> can I post four lines in here?
14:51:53 <shapr> welll... ok.
14:51:57 <liquidengineer> I'm getting a type of type checking error (ha ha) I've never seen before
14:52:02 <liquidengineer> *** Term           : mean
14:52:03 <liquidengineer> *** Type           : Score -> Score -> Score -> Int
14:52:03 <liquidengineer> *** Does not match : Score -> Score -> Score -> Total
14:52:04 <liquidengineer> ERROR Davis#3.lhs:51 - Type error in explicitly typed binding
14:52:33 <liquidengineer> it's never complained about "explicitly typed binding" before
14:52:34 <liquidengineer> what is that?
14:52:58 <shapr> It's saying that you claim a Total is returned, but it sure looks like an Int to the compiler.
14:53:22 <liquidengineer> ah
14:53:25 <liquidengineer> I fixed it
14:53:34 <liquidengineer> Total is a type that = float
14:53:40 <liquidengineer> Score = Int
14:53:46 <liquidengineer> I can see where it wouldn't like that
14:53:51 <liquidengineer> changed Score to Float
14:54:05 <shapr> Good way to make it happy.
14:55:31 <liquidengineer> ...was there another way?
14:55:42 <shapr> Sure, several.
14:55:58 <liquidengineer> a way that lets score stay as an Int?
14:56:43 <Igloo> You might want to use fromIntegral to convert Score to Total
15:00:28 <liquidengineer> what's fromIntegral?
15:00:37 <xerox> @type fromIntegral
15:00:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fromIntegral :: forall b a. (Num b, Integral a) => a -> b
15:00:55 <liquidengineer> hmm....
15:00:57 <monochrom> fromIntegral is a function.
15:00:59 <shapr> fromIntegral is a smart function that can change types for you.
15:01:01 <monochrom> Hahaha
15:01:03 <liquidengineer> forall?
15:01:10 <shapr> liquidengineer: don't worry about forall.
15:01:20 <liquidengineer> what about this Integral type?
15:01:38 <liquidengineer> isn't an integral like, the antiderivative of a function?
15:01:48 <monochrom> fromIntegral coerces an integer to the right numeric type for the context.
15:02:00 <liquidengineer> lol
15:02:03 <liquidengineer> coerces
15:02:10 <liquidengineer> I love the implied violence
15:02:45 <shapr> Here's more detail on the term integral - http://en.wikipedia.org/wiki/Floor_function
15:03:49 <liquidengineer> thanks
15:03:59 <liquidengineer> but I don't think I'll keep at this much longer
15:04:11 <liquidengineer> there's a girl that wants to come over to my apartment to watch the Incredibles
15:04:22 <liquidengineer> that...is preferable to haskell, I'm sorry to say
15:04:25 <shapr> Hm, girl... haskell... why are you here?
15:04:36 <Heffalump> teach her Haskell instead.
15:04:42 * shapr blinks
15:05:19 <shapr> I prefer girls.
15:08:13 <liquidengineer> Heffalump: we can get you the help you so badly need...
15:10:26 <Heffalump> :-p
15:11:33 <Lunar^> *sigh* heterocentrism
15:11:52 <shapr> I'm definitely girl-centric.
15:12:00 <liquidengineer> too bad we can't all find a Karla
15:12:13 <shapr> karla?
15:12:16 * Lunar^ hides
15:12:37 <liquidengineer> Lunar^: I thought about that... but I'm honestly not good at phrasing sexual orientation-neutral nerd love jokes
15:12:40 <alex> Is there a good comparison between haskell and clean already written?
15:12:50 <liquidengineer> shapr: female lead in Microserfs
15:12:55 <shapr> Oh, haven't seen it.
15:13:07 <shapr> alex: I can tell you some of the distinguishing features, but I don't know of a comparison.
15:13:15 <liquidengineer> It's a Douglas Coupland book
15:13:18 <liquidengineer> highly reccomended
15:13:23 <liquidengineer> I've read it five times
15:14:02 <KrispyKringle> yeah, so...you chose haskell over a girl who wants to visit your apartment?
15:14:04 <KrispyKringle> hmm.
15:14:11 <alex> shapr: could you point out the problems of clean's type system?
15:14:16 <KrispyKringle> i site with shapr on this one.
15:14:20 <KrispyKringle> side
15:14:45 <shapr> alex: I don't know of any problems with Clean's typesystem. It is unlike Haskell's in that it uses uniqueness types.
15:15:14 <alex> What about community?  It doesn't appear to be very big.
15:15:41 <shapr> I haven't looked into Clean much, so what I have to say is just hearsay and my own experience, but...
15:15:57 <liquidengineer> http://www.amazon.com/exec/obidos/ASIN/0060987049/qid=1112483746/sr=2-1/ref=pd_bbs_b_2_1/104-2083207-0657532
15:15:57 <liquidengineer> shapr: check it out
15:15:58 <shapr> Clean's license was originally not open source.
15:16:03 <liquidengineer> what's clean?
15:16:15 <alex> it's lgpl + closed now (like mysql)
15:16:23 <shapr> From what I remember, it used to be you could get the binary for free, but that's all.
15:16:41 <alex> i saw sources on the site (under lgpl)
15:16:43 <liquidengineer> Krispy: Ha ha.  If I didn't finish this assignment, my grade in this course would become poo
15:16:45 <liquidengineer> I cannot allow that
15:16:56 <alex> s/sources/link\ to\ sources/
15:17:02 <shapr> Right, Clean's license was changed in the last year or so.
15:17:33 <shapr> Now you've got lgpl and pay-money-for-commercial-use licenses.
15:17:46 <liquidengineer> well
15:18:03 <liquidengineer> now, I'm off to put on some more presentable pants and call said girl
15:18:05 <liquidengineer> later days
15:18:09 <shapr> liquidengineer: cya
15:18:17 <alex> shapr: Do you know of any good papers which would help in comparing?
15:18:39 <shapr> No, but uniqueness types do have a bunch of papers available.
15:18:52 <alex> ok
15:19:13 <alex> shapr: does it have principal limits on maximum performance?  could clean be as fast as c in the future?
15:19:14 <shapr> From what I've seen, the Clean community stayed small because of the lack of OSS license for the earlier versions.
15:19:25 <alex> on the same order, that is
15:19:44 <shapr> Well, I think Haskell could be as fast as C in the future :-)
15:20:13 <shapr> But if you want heavy duty speed, you should check out FISh and other computational shape languages.
15:20:19 <shapr> Like Sisal, Nesl, etc
15:21:01 <alex> no, it's not speed that I want at this time, but I want to know that the language is not always going to be slow
15:21:22 <alex> otherwise, I'd have to accept some inconvenieces ;-)
15:21:42 <shapr> From what I've heard, Clean is strict, and that's primarily why some people say it's faster than Haskell.
15:22:01 <shapr> I haven't compared it myself, nor do I know of any up to date comparisons.
15:22:04 <tuomov> I thought it was lazy..
15:22:11 <shapr> Is it lazy?
15:22:17 <tuomov> I don't know
15:22:18 <alex> it's lazy afaik
15:22:29 <shapr> hm
15:22:35 <shapr> In that case, how could Clean be faster?
15:22:39 <alex> "Read all about our state-of-the-art pure and lazy functional programming language Clean"
15:22:44 <alex> http://www.cs.ru.nl/~clean/
15:22:50 <shapr> I've heard about better inline strictifying for Clean than for Haskell.
15:22:53 <XTL> Someone actually bothered to check :)
15:22:57 <shapr> XTL: shocking.
15:23:07 <KrispyKringle> Speaking of which, anyone look at Alice? It's some ML derivative, apparently.
15:23:09 <KrispyKringle> Looked kinda nice.
15:23:18 <alex> what about string representation in clean?
15:23:20 <KrispyKringle> http://www.ps.uni-sb.de/alice/manual/tour.html
15:23:52 <shapr> ObjectIO in clean is cool enough that it was ported to Haskell, so that's a plus.
15:23:54 <alex> thank you
15:24:11 <shapr> Not that ObjectIO in Haskell works on anything except Windows.
15:24:24 <alex> Does Clean have enough spin as Haskell?  Would it ever have (in your opinion, why?)
15:24:33 <shapr> spin?
15:24:45 <shapr> as in, political spin?
15:24:51 <alex> close, but not exactly
15:24:54 <alex> not hype
15:25:24 <shapr> I don't know. I can tell you what questions I'd have about Clean, if that helps any.
15:25:31 <alex> can't say this in english, sorry
15:25:40 <shapr> Which language do you want?
15:25:43 <alex> ok, tell it
15:25:50 <alex> russian
15:25:55 <shapr> Oh, sorry. No clue here.
15:26:02 <alex> ok ;-)
15:26:11 <shapr> My russian is limited to 'spasibo'.
15:26:21 <alex> ochen horosho :-)
15:26:23 <XTL> Probably some quantum property. Disappears if you try to measure it.
15:26:23 * XTL is tired
15:26:42 <tuomov> momentum?
15:26:59 <shapr> Haskell is BSD, so lots of companies have written products that modify Haskell implementations heavily. I'd want to know if Clean will have that option with a larger userbase than it has now.
15:27:00 <alex> It would be very good way to say that.
15:27:02 <alex> yes
15:27:34 <shapr> Dang, I had some other questions in mind a moment ago.
15:27:35 <alex> I wondered, if Clean would ever be as practical as Haskell in the future,
15:28:06 <shapr> What does practical mean to you?
15:28:24 <shapr> To my clients, practical means that they can fire me and hire someone else to work on the code I wrote.
15:28:32 <alex> Could be used for big real projects
15:28:47 <alex> real life
15:29:07 <shapr> I don't know enough about Clean to give a good answer.
15:29:09 <alex> I wouldn't care about the popularity, though
15:29:11 <alex> ok
15:29:36 <shapr> I can tell you everything you want to know about Haskell in that respect.
15:29:50 <shapr> What's good, what's bad, what's needed.
15:30:04 <shapr> Of course, just my opinions.
15:30:04 <alex> what's bad and what's needed ;-)
15:30:24 <alex> with pointers to further reading?
15:30:48 <alex> What are the biggest issues in the language itself, in your opinion?
15:31:28 <shapr> In my opinion, Bad for speed is that strings are slow. Bad for use is the lack of libraries and applications. Bad for development is space leaks.
15:31:42 <shapr> All those have possible solutions, but that's really part of further reading.
15:31:55 <shapr> And libs and apps are growing fast, look at darcs and perl6
15:32:36 <XTL> perl6?
15:32:38 <shapr> I can't think of any big issues in the language itself. I do wish the typeclass hierarchy were a bit cleaner.
15:32:39 <alex> could you tell more on space lieaks?
15:32:52 <alex> XTL: afair, one implemenenation of p6 is in haskell
15:33:04 <shapr> Is there another implementation of p6?
15:33:17 <XTL> I've heard something like that. I was wondering if there's anything real or is it just talk.
15:33:20 <tuomov> I'd like it to be easier to use existential wrapping..
15:33:34 <shapr> XTL: I just wrote and committed chr, ord, and hex yesterday.
15:33:41 <monochrom> http://pugscode.org/  perl6 in haskell
15:34:17 <monochrom> if there is another, I'd love to know too.
15:34:19 <XTL> I see.
15:34:41 <shapr> Space leaks are just unwanted laziness. Since Haskell garbage collects when something goes out of scope, it means something didn't automatically go out of scope as soon as you wanted.
15:34:43 <alex> Yesterday, somebody said that very simple syntax abstraction are more easily achieved with cpp.  Does it indicate any difficulties with using template haskell?
15:35:35 <shapr> The first version of the mailing list search webapp I wrote, it opened all the files, read all the files into memory, and then started parsing all the files.
15:36:01 <shapr> It would have closed all the files, after all the parsing was done, but seven seconds later, I had no ram left.
15:36:44 <shapr> Darius added one $! call in the right place, and suddenly my ram usage went down to about 35mb maximum.
15:37:33 <alex> I've read about a similar problem in darcs (when it was tested with linux source tree).
15:37:40 <jlouis> The virtues of laziness
15:37:43 <alex> It's not a show stopper, though imho
15:38:07 <xerox> @type ($!)
15:38:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ($!) :: forall b a. (a -> b) -> a -> b
15:38:16 <shapr> Lazy is more expressive than strict, in my experience. It can be more efficient and faster, but you have to use your brain more.
15:38:21 <xerox> Functor?
15:38:49 <jlouis> My general view is that templates are not the way to go with most code.
15:39:05 <alex> more brain is not a problem imho too (why would we need it otherwise (; )
15:39:14 * shapr laughs
15:39:17 <jlouis> I wonder if Haskell has something like the SML functors though. That could be nice
15:39:38 <shapr> I don't know about simple syntax abstraction with cpp.
15:40:10 <alex> the question, is whether it's easy (meaning w/o kludge) to achieve in template haskell?
15:40:14 <shapr> In my opinion, arrows are one good solution to laziness.
15:40:43 <shapr> syntax extension?
15:40:52 <alex> mostly
15:40:54 <alex> yes
15:41:11 <shapr> No, you can't do that in Template Haskell.
15:41:53 <alex> any development in this direction now?
15:42:09 <shapr> You can define preprocessors on the GHC command line, they can turn your source into whatever you want. That's best solution I know.
15:42:29 <alex> I see.  sad
15:42:30 <shapr> I don't know any other options for extending Haskell syntax directly.
15:42:45 <shapr> You should ask this on ghc-users, they'll probably know more.
15:42:50 <alex> ok
15:43:24 <shapr> I do wish GHC had full unicode in source code support.
15:43:26 <alex> is it possible with clean (extending syntax)?
15:43:30 <shapr> I don't know.
15:43:37 <alex> ok
15:44:06 <shapr> Since Clean is lazy, I would guess it will have the same issues with space leaks.
15:44:19 <shapr> But I have heard it's easier to force strictness in Clean.
15:44:21 <alex> nothing like macros in lisp?
15:44:58 <shapr> Part of lisp macros is in Template Haskell.
15:45:20 <shapr> I don't know about Clean.
15:45:29 <alex> ok
15:45:54 <alex> thank you.  I'll read on both now more :-)
15:46:07 <shapr> Ok, if you have more questions, feel free to ask me.
15:46:19 <shapr> I'd be interested if you find a speed comparison between Haskell and Clean.
15:46:30 <shapr> Oh wait, I can use the shootout!
15:46:31 <alex> :-)
15:46:36 <alex> alioth?
15:47:02 <alex> it's not very good, imho (look at the source code they provide)
15:47:13 <alex> and not all benchmarks are written for all languages
15:47:30 <alex> I even noticed incorrectness in number of lines for some benchmarks (some reported 0)
15:49:01 <shapr> I've thought about making a companion website for shootout.alioth, I'd like to have something that's more source code as literature.
15:49:14 <shapr> In my opinion, source code is primarily for communication with other humans.
15:49:25 <shapr> And I don't know any benchmark sites for that.
15:50:27 <shapr> I can give the best value to my customers if I can reach their goal in the least amount of time. I can usually do that by modifying existing source code. That means I want the language that communicates best with me so I can learn source code quickly.
15:52:35 <shapr> Most often the existing source code that I modify is source I wrote months or years before for the same customer.
15:54:00 <shapr> alex: I think a soon-to-be-important feature will be the ability to easily use multiple CPUs. There are rumors that GHC will use SMP soon.
15:55:11 <shapr> Do you have the state of your language comparisons online somewhere? I'd like to read it.
15:56:30 <Heffalump> shapr: rumours from where?
15:57:31 <shapr> From SPJ.
15:58:28 <shapr> He mentioned it on the mailing list, I forget exactly when.
16:00:41 <alex> shapr: not online.  If ever post it, I'll give the link
16:02:05 <shapr> cool, thanks.
16:03:10 <shapr> alex: You might also want to check out Mozart/Oz.
16:05:36 <shapr> alex: Any particularly interesting language comparisons so far? I'm fascinated by programming languages, so I'd like to hear if you've found some really good stuff.
16:07:57 <shapr> dons: yay! synhl! w00!
16:10:49 <shapr> hiya redlion
16:11:01 <stepcut> :p
16:11:04 <shapr> aha!
16:11:23 <stepcut> so, synhl -- too what extent ?
16:11:24 <shapr> stepcut: want to learn Haskell?
16:11:31 <shapr> building now..
16:11:32 * stepcut wants to learn haskell
16:11:39 * shapr grins
16:11:49 <stepcut> I am very interested, but i don't have any patience!!!!!
16:11:51 * stepcut runs around
16:11:53 <shapr> haha
16:12:02 * shapr tries not wake up the woman with laughter
16:12:48 <shapr> Some people want to learn new stuff for free.
16:13:06 * stepcut would pay for an injection
16:13:28 * shapr snickers
16:13:41 <stepcut> so, tell about synhl
16:13:43 <shapr> I might too.
16:14:08 <shapr> http://www.scannedinavian.org/cgi-bin/darcs.cgi/yi/?c=patches
16:14:13 <shapr> Top patch
16:16:27 <stepcut> neat
16:16:57 <shapr> completely off-topic poetry - http://www.people.cornell.edu/pages/elz1/clocktower/DrSeuss.html
16:16:58 <stepcut> I wonder how synhl and tab completion will tie in together
16:17:35 <stepcut> one of my life goals is to memorize the original version of that poem..
16:18:23 <shapr> How long will that take you?
16:18:53 <stepcut> years before I have time, and then a few weeks maybe ?
16:19:09 <stepcut> maybe a few days -- depends on how much time I have to devote to it
16:19:40 <shapr> Sounds realistic.
16:20:11 <stepcut> its a goal, but it is not very high on the list at the moment :)
16:20:35 <stepcut> First, I must make the ultimate command-line option parser for haskell ;)
16:20:58 <stepcut> one that automatically generates bash/eshell/etc completion code, among other things
16:21:00 <shapr> I'm having fun hacking on Pugs, it's neat.
16:21:10 <shapr> Oh that would be *neat*!
16:21:57 <stepcut> I think I know enough to be able to write it in a week or so, but I have a big deadline at work on the 17th... so I probably want even have a chance until may
16:22:48 <stepcut> on the plus side, I am currently working on some code that gives me a chance to do some minor fixes to my pipe code and haskelldb :)
16:22:53 <shapr> yay!
16:23:32 <stepcut> There is one grevious bug that I currently know of in my pipe code, and I may finally be able to track it down
16:24:22 <stepcut> And I have an idea for a hack that might solve the bug in haskelldb that prevents you from having a project that projects two columns with the same name from different tables
16:24:47 <stepcut> though, I think it will be a hack, and not a real fix
16:24:49 <shapr> alpha renaming?
16:25:34 <stepcut> no... something far less elegant
16:25:58 <stepcut> that introduces a different bug ;)
16:26:02 <shapr> haha
16:26:30 <shapr> man, I can barely wait to work on this synhl stuff.
16:26:39 <shapr> But I'll sleep, and then write part of want for pugs.
16:26:59 * shapr falls over asleep
16:27:05 <stepcut> Using my patch for removing subqueries, I don't think the generator ever needs to rename cols -- so i think I can tweak DBDirect so that it uses fully qualified fiels names
16:27:21 <stepcut> instead of, select col1, col1 from table1, table2;
16:27:37 <stepcut> it will just generate, select table1.col1, table2.col2 from table1, table2;
16:28:22 <stepcut> which would break (i think?) if this code was generated --> select table1.col1, table2.col from table1 as somethingeles, table2;
16:29:07 <stepcut> but, I don't think that will happen in practice -- or at the very least, will happen less than two tables having columns with the same names ;)
16:29:26 <stepcut> though, I do also have plans to do a major reworking of haskelldb based on a book i found
16:30:07 * stepcut goes back to reading about accounting
16:56:45 <dons> moin
16:56:52 <dons> heya stepcut
16:57:01 <Lemmih> @timein Sidney
16:57:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Sorry, don't know this city
16:57:09 <dons> @timein Sydney
16:57:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Sunday, April 3, 2005 at 10:58:10 AM EST
16:57:20 <dons> ;)
16:57:22 <Lemmih> ah (:
16:57:41 <Lemmih> Good morning, dons.
16:57:48 <dons> hey Lemmih :)
16:58:43 <Lemmih> @timein Copenhagen
16:58:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Sunday, April 3, 2005 at 2:59:45 AM CEST
17:00:43 <Heffalump> @timein Cambridge
17:00:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Saturday, April 2, 2005 at 8:01:44 PM EST
17:01:00 <Heffalump> HMPH!
17:01:14 * Heffalump excommunicates lambdabot
17:01:31 <dons> you people live in crazy timezones
17:01:40 <dons> ;)
17:02:00 * Heffalump objects, vociferously, to lambdabot
17:02:25 <dons> what's he done wrong?
17:02:34 <Heffalump> look closely at his response
17:02:52 <dons> EST?
17:03:06 <Heffalump> where do you think it thinks I was asking about?
17:03:12 <dons> hmm...
17:03:14 <Heffalump> and where do you think I was actually asking about?
17:03:23 <dons> not the right Cambridge ...
17:03:26 <dons> hehehehe
17:03:35 <dons> @timein help
17:03:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   http://www.timeanddate.com
17:04:06 <dons> oh . that's funny
17:04:07 <dons> Cambridge, Massachusetts, United States
17:04:16 <dons> there's only 1.
17:04:24 <Heffalump> HMHP!
17:04:27 <Heffalump> IM HMPH!
17:04:41 <dons> you'll have to work harder to get on the map ;)
17:04:48 <dons> hehehaha
17:10:35 <dons> @pointless \x y -> x . y
17:10:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (.)
17:10:42 <dons> thanks for the patch TheHunter
17:14:43 <TheHunter> 'morning dons.
17:15:26 <TheHunter> there's a small bug in @plugs:
17:15:27 <dons> I'll try to get profiling of the whole bot up today, which might help you in your quest
17:15:39 <TheHunter> @plugs 1 :: Int
17:15:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `Int' against `String'
17:15:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: Int
17:15:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: String
17:15:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the expression: show $ 1
17:15:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     When checking the type signature of the expression: show $ 1 :: Int
17:15:48 <dons> should wrap in parens, huh?
17:15:53 <TheHunter> yep.
17:15:57 <dons> ok. will do.
17:16:18 <df_> erk, does it have to notice the channel?
17:16:21 <jlouis> dons: got my patches too?
17:16:36 <dons> jlouis, just reading them now with my morning coffee :)
17:16:42 <jlouis> I am not entirely sure about the process
17:16:48 <jlouis> ;)
17:16:50 <jlouis> okies
17:16:59 <jlouis> mostly cleanup stuff
17:17:11 <dons> df_: the RFC says bots must use notices, to avoid loops
17:17:15 <jlouis> do test them though, I have not tried to run the bot in-depth with them on
17:17:30 <dons> df_: it's a pity most clients seem to render notices badly by default
17:17:31 <desrt> df; notice is required
17:17:52 <dons> jlouis: the clean ups are fine.
17:17:55 <monochrom> it's a pity there exist most clients.
17:18:12 <desrt> irssi power
17:18:29 <NYRanger`> hey all.  I am curious, in Haskell with Pattern matching. My terminology is bad since I am just a beginner at this.  I want to write a recursive function called everyother that returns every other element of the list.  My problem is that i cant figure out a definition for it.
17:19:01 <monochrom> you need a pair of recursive functions.
17:19:15 <monochrom> Ah, maybe you can evade it.
17:19:15 <NYRanger`> monochrom: could i paste the definition I *think* is right?
17:19:19 <dons> to pattern match on lists you use ( x : y : _ ) style patterns. This matches the list constructor ':' (also called cons)
17:19:43 <NYRanger`> everyother (a:b:t) = (a:everyother t)
17:19:54 <NYRanger`> thats the recursive definition i *think*
17:19:55 <dons> to match the empty list constructor, you use the empty list constructor: []
17:20:03 <monochrom> That is good.  But you also need the base cases.
17:20:06 <dons> think about the base case.
17:20:19 <NYRanger`> the base base is that everyother [x] = x
17:20:31 <dons> what if the list is empty?
17:20:33 <monochrom> what about everyother [] ?
17:20:44 <NYRanger`> i guess just the empty list ?
17:20:56 <NYRanger`> everyother [] = []
17:21:06 <monochrom> Your life is complete.
17:21:28 <dons> jlouis: do you get to test the patches at all, btw? it's always a good idea.
17:21:40 <NYRanger`> so i have: everyother [] = [] <linebreak> everyother [x] = x <linkebreak> everyother (a:b:t) = (a:everyother t)
17:22:10 <dons> you can adjust the BotConfig.hs to load you into some random channel #xyNMblahblha, and test your patches there
17:22:11 <jlouis> dons: Not these. The next thing I've planned to work on is a test setup
17:22:13 <df_> it is _not_ required
17:22:16 <df_> it is suggested
17:22:29 <desrt> hmm
17:22:41 <dons> well, it is required here, as we had dueling bots yesterday :)
17:22:41 <monochrom> looping is fun!
17:22:50 <NYRanger`> that gives me an error: express: a : everyone t , term t, type [a], does not match a, because: unification would give infinite type
17:23:41 <monochrom> typo? everyone != everyother?
17:23:56 * desrt comes up with something more interesting, for fun
17:24:12 <df_> 4.4.2 Notice:  `... This is typically used by automatons ...'
17:24:13 <jlouis> your second variant: [x] = x
17:24:16 <NYRanger`> monochrom: typo.  I was retying it instead of pasting.  I see the problem was everyother [x] = []. I should have said everyother [x] = [x]
17:24:29 <NYRanger`> yeah like jlouis said.
17:24:31 <monochrom> OH!  I missed that one too :)
17:24:39 <dons> df_: yep. lambdabot is an automaton, right?
17:24:41 <jlouis> monochrom: it is 03:25 here
17:24:42 <df_> dons :: how on earth did you manage that?
17:24:54 <dons> two bots.
17:25:01 <jlouis> monochrom: I should go to bed, but somehow my brain still works
17:25:02 <jlouis> odd
17:25:02 <df_> carry on
17:25:07 <dons> pretty simple to produce, if they take commands, or have a meta language
17:25:24 <dons> @eval "@help command"
17:25:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @help command
17:25:44 <jlouis> hehe
17:25:51 <df_> yes, that would be rather silly
17:25:58 <NYRanger`> this haskell stuff is cool.  But definately challenges the way one thinks.
17:26:00 <desrt> everyother = (map snd) . (filter (even.fst)) . (zip [1..])
17:26:05 <desrt> :D
17:26:19 <NYRanger`> desrt: what will that do?
17:26:28 <desrt> Prelude> ((map snd) . (filter (even.fst)) . (zip [1..])) "abcdef"
17:26:29 <desrt> "bdf"
17:26:46 <NYRanger`> desrt: I think if I submitted that the teacher would know i cheated.
17:26:48 <desrt> s/even/odd/ if you want "ace"
17:26:52 <monochrom> The introduction of numbers just for their parity is inefficient.
17:27:15 <desrt> NYRanger`; it's not a particularly good solution, either.  just looks neat :)
17:27:41 <NYRanger`> i would love another challenge in haskell.  But most stuff is too challenging ;-)
17:27:58 <dons> @plugs (((map snd) . (filter (even.fst)) . (zip [1..])) "abcdef")
17:27:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "bdf"
17:28:05 <dons> just checking.
17:28:24 <NYRanger`> you have an interpretor in the channel that can process haskell statements?
17:28:27 <desrt> @plugs [snd x | x <- (zip [1..] "abcdef"), odd (fst x) ]
17:28:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "ace"
17:28:32 <jlouis> dons: regarding lambdabot style, do we write module definitions like
17:28:34 <jlouis> , a
17:28:35 <jlouis> , b
17:28:37 <jlouis> , c
17:28:43 <jlouis> or with the comma in the end
17:28:46 <dons> module export lists, you mean?
17:28:46 <desrt> ^ same thing, using list comprehension instead of map/filter
17:28:55 <monochrom> (map snd) . (filter fst) . (zip (cycle [True,False]))  is preferrable
17:28:57 <jlouis> dons: yes, module export lists
17:29:16 <NYRanger`> monochrom: you are talkin gchinese to me.
17:29:36 <desrt> monochrom; hm.  good call
17:29:37 <monochrom> Don't worry I'm just responding to dones
17:29:49 <monochrom> err desrt
17:30:01 <dons> jlouis: I probably prefer the postfix ','.
17:30:10 <jlouis> dons: me too
17:30:20 <NYRanger`> do people actually write large systems in Haskell?
17:30:20 <desrt> is there some operator that would let you write for, isntance
17:30:27 <jlouis> foo bar baz =
17:30:28 <jlouis> or
17:30:28 <desrt> weird_cycle not True
17:30:31 <jlouis> foo bar baz
17:30:32 <jlouis>   =
17:30:33 <jlouis> ?
17:30:34 <desrt> to mean [True, False, True, False, True, False]...
17:30:48 <dons> NYRanger: yes!
17:31:22 <dons> jlouis: I'd prefer the = on the first line, also: foo = do
17:31:42 <dons> the body then hangs, indented, on the second line
17:31:46 <monochrom> try: iterate not True
17:32:01 <desrt> yes.  iterate is exactly what i mean
17:32:09 <jlouis> (be ready with C-c)
17:32:23 <hellish> Is there a cabalized version of HaXml floating around anywhere? Building the current one fails under ghc 6.4
17:32:30 <desrt> @plugs take 10 $ iterate not True
17:32:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [True,False,True,False,True,False,True,False,True,False]
17:32:36 <jlouis> dons: again we agree. Maybe I'll begin enforcing that in the code
17:32:43 <monochrom> It would be fun to hold a closed-book exam on the Haskell prelude. :)
17:32:50 <dons> jlouis: the style in lambdabot atm is quite diverse, reflecting the range of contributors. but a unified style would be nice.
17:33:01 <dons> check the haskell wiki for a style guide for more info
17:33:24 <jlouis> dons: I took quite a bite at the Quote module
17:33:37 <dons> jlouis: you could have a look at Yi src, or GHC src. basically that's the style I prefer.
17:33:48 <jlouis> Yi?
17:33:56 <desrt> vi in haskell :)
17:33:58 <dons> @version
17:33:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sat Apr  2 22:43:47 EST 2005, GHC 6.4 (OpenBSD i386)
17:33:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:33:59 <desrt> (and then some)
17:34:06 <dons> darcs get http://www.cse.unsw.edu.au/~dons/yi
17:34:23 <jlouis> ok
17:35:04 <dons> jlouis: a reall nice job would be to being adding haddock docs to everything
17:35:12 <desrt> is there any way to cause a [] to take an argument without lambda?
17:35:16 <dons> have a look in Yi/Core.hs for what I mean.
17:35:41 <dons> (in the yi src). And I'll add haddock generation support via 'make doc'
17:35:44 <monochrom> You mean like: return 1 :: [Int] ?
17:36:07 <desrt> i mean [] as in comprehension.  sorry :)
17:36:18 <dons> @kind [] Int
17:36:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [] Int :: *
17:36:26 <desrt> like foo = [x|x<-stdin]
17:36:31 <dons> oh, i was hoping it would 'take its argument for me' ;)
17:36:32 <desrt> where "stdin" means "first argument" :)
17:36:58 <monochrom> that's hard
17:37:02 <jlouis> dons: I'll think about haddock'ing parts of the code then, when I come by it
17:37:15 <desrt> i don't think it's possible
17:37:23 <desrt> it'd be some nice sugar, tho
17:37:25 <jlouis> I need to read most of it to get a clue about what is happening
17:37:33 <monochrom> @pointless \s -> [x|x<-s]
17:37:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (: []) . ((x | x) <-)
17:37:42 <monochrom> Hahahaahahahaha
17:37:44 <dons> jlouis: if you work out what a function does, add -- | This does foo, but, yeah, only if you work it out  :)
17:37:59 <desrt> wow
17:38:00 <monochrom> @smilify \s -> [x|x<-s]
17:38:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "smilify", try "lambdabot: @listcommands"
17:38:01 <desrt> totally readable
17:38:11 <dons> smilify?
17:38:26 <TheHunter> @wiki LambdaBot/Notices
17:38:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
17:38:32 <monochrom> We should set up lambdabot to accept "smilify" as synonym for "pointless".
17:38:40 <desrt> @pointless \x->x+1
17:38:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (1 +)
17:38:47 <desrt> evil.
17:38:49 <desrt> @pointless \x->x-1
17:38:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- subtract 1
17:38:52 <dons> thank you TheHunter!
17:38:55 <desrt> quite evil.
17:39:30 <desrt> monochrom; i didn't know about this
17:39:43 <desrt> does it always succeed?
17:39:48 <monochrom> I think lambdabot's pointless has done a wrong translation.  (x | x) makes no sense.
17:40:17 <desrt> @plugs ((: []) . ((x | x) <-)) 5
17:40:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `|'
17:40:21 <desrt> yuh
17:40:33 <desrt> maybe it doesn't know about comprehension
17:40:33 <monochrom> But hey, (: []) . ((x | x) <-) is a perfectly novel smiley!
17:40:59 <desrt> that interaction with the bot is almost quoteable
17:41:57 <monochrom> @pointless \s -> do { x<-s; return x }
17:41:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 10):
17:41:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected "{"
17:41:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting variable, "(", operator or end of input
17:42:20 <monochrom> @pointless \s -> s >>= \x -> return x
17:42:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- id
17:42:24 <desrt> yes!
17:42:30 <monochrom> Damn, it's too smart.
17:42:38 <monochrom> @pointless \s -> s >>= \x -> return (x+1)
17:42:38 <heatsink> @pointless \a b c d e -> e d c b a
17:42:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ((1 +) `fmap`)
17:42:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip
17:42:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- . flip id)))
17:43:03 <heatsink> well, that's quadratic in the number of variables.
17:43:05 <desrt> flipping great
17:43:27 <monochrom> I think generally you have to de-comprehension it before eliminating lambda.
17:43:43 <desrt> alas
17:44:14 <desrt> i'm trying to come up with the minimal possible functional form of everyother
17:44:23 <desrt> in terms of number of characters
17:44:25 <heatsink> it's a fair part of the way to getting a haskell-to-unlambda compiler.
17:44:33 <heatsink> what's everyother?
17:44:35 <monochrom> You can de-comprehension by monadifying, like I did.  @pointless understands >>= and return.
17:45:18 <monochrom> everyother [a,b,c,d,e,f,g] = [a,c,e,g]  for example.
17:45:23 <desrt> right, but then i have to say 'filter' explicitly
17:45:45 <monochrom> Or even monadplusify.
17:46:02 <desrt> i have: \y->[snd x|x<-(zip[1..]y),odd(fst x)]
17:47:26 <heatsink> e[]=[];e[_]=[];e(x:y:z)=x:e z
17:47:40 <monochrom> yeah you have to at least de-comprehension by using map, filter, return, concat.
17:47:48 <jlouis> ok, night. More work on this tomorrow maybe
17:47:58 <desrt> heatsink; no.  needs to be 'pointless' (plus or minus lambdas)
17:48:03 <desrt> ie: no pattern match allowed :)
17:48:14 <heatsink> hmm, ok
17:48:36 <monochrom> I think you should count tokens rather than characters.  It is not your fault that "filter" is six letters.
17:48:40 <desrt> eh.  i guess what i really mean to say is "anonymous"
17:49:12 <desrt> ya.  but then you get into arguments aobut if () counts as 1 or 2, etc
17:49:57 <TheHunter> join.zipWith($)cycle[(:[]),\x->[]]
17:50:14 <desrt> hot!
17:50:30 <desrt> er.
17:50:34 <desrt> join isn't in prelude, dude
17:50:43 <monochrom> concat
17:51:15 <monochrom> Neat.
17:51:17 <desrt> that's a nice solution
17:51:19 <heatsink> @pointless \x -> if x then Just x else Nothing
17:51:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip (s if' Just) Nothing
17:51:21 <desrt> *very* functional
17:51:33 <heatsink> @index if'
17:51:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
17:51:40 <dons> if' ?
17:52:29 <monochrom> I think @pointless needs some fix.
17:52:40 <TheHunter> sorry, there is no reasonably short pointless version of if in the prelude. That's similar to s.
17:52:48 <dons> ok.
17:53:06 <TheHunter> btw, join.zipWith($)(cycle[(:[]),\x->[]])
17:53:24 <monochrom> (:[])
17:53:36 <desrt> it doesn't like : right after [
17:53:49 <monochrom> Put in a space there.  It's no problem.
17:53:54 <dons> jlouis: when you refactor modules, you may introduce new dependencies on dynamically loaded modules. these have to be tracked in BotConfig.hs
17:54:01 <desrt> monochrom; no.  still a problem
17:54:13 <dons> (as we don't use hs-plugins to calculate dependencies magically)
17:54:17 <desrt> i have no idea why
17:54:23 <dons> jlouis: e.g. lambdabot: QuoteModule.o: unknown symbol `QuoteModuleziRandom_zdwgetRandItem_info'
17:54:33 <TheHunter> @plugs join.zipWith($)(cycle[(:[]),\x->[]]) $ [1..7]
17:54:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `join'
17:54:41 <TheHunter> @plugs concat.zipWith($)(cycle[(:[]),\x->[]]) $ [1..7]
17:54:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,3,5,7]
17:54:44 <desrt> @plugs concat$zipWith($)(cycle[(:[]),\x->[]]) [1..7]
17:54:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,3,5,7]
17:54:49 <desrt> see
17:54:51 <desrt> . doesn't work for me
17:54:58 <dons> jlouis: the above indicates the getRandItem isn't visible, due to a missing dependency not loaded
17:55:05 <monochrom> AH!  $ is right, . is wrong.
17:55:17 <desrt> lambdabot takes . though
17:55:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:57:36 <dons> jlouis: the soln is to add "QuoteModule/Random.o" to the getFileRequires for QuoteModule.o
17:57:53 <dons> so be careful of this when introducing new imports to dynamically loaded modules
18:01:36 <desrt> justMap x = [fromJust y | y <- x, x /= Nothing ]
18:01:40 <desrt> this would be a nice function
18:02:19 <TheHunter> this is almost msum.
18:02:59 <desrt> msum = combine the effects of two nested monads?
18:03:18 <TheHunter> @type Data.Maybe.catMaybes
18:03:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.Maybe.catMaybes :: forall a. [Maybe a] -> [a]
18:03:32 <desrt> ah.  perfect :)
18:03:36 <TheHunter> @type Control.Monad.msum
18:03:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.msum :: forall a (m :: * -> *).
18:03:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       (Control.Monad.MonadPlus m) =>
18:03:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       [m a] -> m a
18:04:10 <TheHunter> @plugs msum [[],[1,2],[1,2,3]]
18:04:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `msum'
18:04:22 <TheHunter> ==> [1,2,1,2,3]
18:04:36 <desrt> looks like concat?
18:04:41 <TheHunter> msum [Just 1, Nothing, Just 2] ==> Just 1
18:05:03 <TheHunter> yep. concat has many names :)
18:05:27 <desrt> i don't think catMaybes is possible in any generic sense
18:05:38 <TheHunter> hmm, concat, join, msum, mconcat. Did I miss one?
18:06:32 <monochrom> Queen of The United Kingdom And Other Terroritories and Realms, Head of The Commonwealth, Defender of Faith.
18:06:38 <TheHunter> MonadPlus m => [Maybe a] -> m a would be easy.
18:06:43 <monochrom> err Defender of The Faith.
18:07:03 <dons> s/Realms/Australia and New Zealand/ :/
18:07:18 <monochrom> Well there is also Canada.
18:07:30 <dons> yeah. but they can't vote in the UK can they?
18:07:41 <dons> I could even run for UK parliament!
18:07:42 <monochrom> Of course not.
18:07:48 <dons> it's great being a colonial
18:08:08 <dons> .au at least can still vote in UK elections
18:08:28 <monochrom> You have a common Queen of many countries, but there is no cross-over among the subjects.  A Canadian can't go do things in Australia.
18:08:51 <dons> not amongst the colonies, now. though there are of course reduced visa restrictions and the like
18:08:56 <dons> s/now/no.
18:09:33 <dons> my point is that .au and .nz are more dependent than places like Canada.
18:09:46 * TheHunter could never understand how someone could be ok with having a king/queen as their head of state.
18:09:51 <monochrom> Ah, I see.
18:10:24 <dons> I'm not sure the majority of people here at least are ok with it :/
18:11:19 <TheHunter> anyway, instead of trying to start a flame war, i should probably go to bed.
18:11:27 <TheHunter> good night, channel
18:11:32 <dons> hehe. night.
18:15:06 <dons> monochrom: why'd you write the "Queen of The United blah blah" stuff? It seemed random.
18:16:14 <monochrom> as other names of concat :)
18:17:05 <monochrom> Lambdabot Reloaded!
18:17:22 <dons> I think jlouis fixed the @yow issue
18:17:24 <dons> @yow
18:17:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't find yow file
18:17:25 <dons> @yow
18:17:26 <dons> @yow
18:17:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't find yow file
18:17:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't find yow file
18:17:29 <dons> good.
18:17:33 <dons> no Ixs
18:23:20 <dons> @plugs 1 :: Int
18:23:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1
18:25:11 <liquidengineer> how do you concencate a number into a string?
18:26:07 <dons> catenate? concatenate
18:26:09 <liquidengineer> like in Java you'd do System.out.println("Hello, my name is Johnny " + 5);
18:26:13 <liquidengineer> what's the equivilent?
18:26:22 <dons> @plugs "Foo" ++ (show 0xff)
18:26:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "Foo255"
18:26:23 <aheller> is it rude to do "foo" ++ (show 5)
18:26:24 <aheller> ?
18:26:35 <aheller> I guess not.
18:27:03 <liquidengineer> OH!
18:27:06 <liquidengineer> neato!
18:27:16 <dons> Haskell rules :)
18:33:15 <CosmicRay> good evening metaperl
18:42:04 <dons> GNU make is a fun functional language
18:42:21 <Cale> liquidengineer: it works with other types too
18:42:35 <Cale> @plugs "Hello " ++ show [1,2,3,4,5]
18:42:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "Hello [1,2,3,4,5]"
18:43:24 <Cale> @type show
18:43:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- show :: forall a. (Show a) => a -> String
18:44:35 * dons thinks of writing Data.List.Make for the gnu make string functions
18:44:46 <liquidengineer> the bot has an interpretter in it?
18:44:56 <dons> a compiler!
18:45:04 <liquidengineer> O.o;;
18:45:05 <liquidengineer> what?
18:45:07 <dons> @help plugs
18:45:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @plugs <expr>
18:45:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have Haskell, 3 seconds and no IO. Go nuts!
18:45:36 <dons> your expression will be compiled to native code
18:46:01 <monochrom> @plugs sum (repeat [1..])
18:46:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No instance for (Num [t])
18:46:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       arising from use of `sum' at v = (show (sum (repeat ([1 .. ]))))
18:46:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the definition of `resource':
18:46:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	resource = let v = (show (sum (repeat ([... .. ])))) in v
18:46:25 <monochrom> @plugs sum (repeat [1..]) :: Int
18:46:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `Int' against `[t]'
18:46:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: Int
18:46:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: [t]
18:46:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `repeat', namely `[1 .. ]'
18:46:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `sum', namely `(repeat ([1 .. ]))'
18:46:38 <monochrom> Ah!
18:46:42 <monochrom> @plugs sum (repeat 1) :: Int
18:46:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
18:46:51 <monochrom> hee hee
18:47:09 <desrt> @plugs repeat 1
18:47:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:13 <desrt> shit
18:47:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
18:47:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [22 @more lines]
18:47:20 <desrt> i didn't actually expect it to do that.  sorry :)
18:47:45 <dons> you actually only get 2048 bytes. I decided that "whatever can be output in 3 seconds" was unnecessary
18:47:57 <dons> hence 22 more lines, instead of maybe 60,000
18:48:31 <dons> please try and hack @plugs - I'd like to make it as stable as possible
18:48:53 <monochrom> @plugs foldl (+) 0 [1..]
18:48:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
18:49:03 <monochrom> @plugs foldl (+) 0 [1..10000]
18:49:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 50005000
18:49:07 <monochrom> @plugs foldl (+) 0 [1..100000]
18:49:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Stack overflow
18:49:15 <monochrom> @plugs foldr (+) 0 [1..100000]
18:49:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Stack overflow
18:49:19 <desrt> @plugs unsafePerformNetsplit
18:49:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafePerformNetsplit'
18:49:23 <desrt> :(
18:49:26 <monochrom> hahahaha
18:49:55 <monochrom> A memory bound makes it unfun...
18:50:13 <dons> there's no memory bound other than ghc's default.
18:50:31 <dons> you wouldn't normally get to hack a server by recompiling it, right?
18:50:37 <monochrom> Oh! Just the 2K bound on output!
18:50:39 <dons> so you have to try something else
18:50:57 <dons> oh, sorry. it still generates all the output locally.
18:51:08 <desrt> "in order to make this hax0r contest more fair, i demand you give me root on the server"
18:51:10 <dons> but it gets pruned.
18:51:24 <dons> desrt: i'm not sure if that is fair.
18:51:31 <Wetron> anyone can tell me a good msn sniffer ?
18:51:37 <desrt> hmm
18:51:49 <desrt> @plugs take 30 (show ([1..]))
18:51:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "[1,2,3,4,5,6,7,8,9,10,11,12,13"
18:51:57 <desrt> cool.  didn't know that worked :)
18:52:25 <desrt> @plugs printStr "hello"
18:52:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `printStr'
18:52:32 <monochrom> we should write an msn sniffer in haskell. submit to 2600.  all hackers will flock to haskell.
18:52:36 <desrt> wtf
18:52:40 <desrt> @plugs putStr "hello"
18:52:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No instance for (Show (IO ()))
18:52:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       arising from use of `show' at v = (show (putStr "hello"))
18:52:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the definition of `resource':
18:52:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	resource = let v = (show (putStr "hello")) in v
18:52:46 <monochrom> No IO.
18:52:55 <desrt> looks like it supports IO to me :)
18:53:03 <dons> it doesn't typecheck.
18:54:15 <dons> the whole @plugs concept would be infeasible if we didn't have a pure language
18:54:26 <desrt> hmm
18:54:29 <desrt> this is cool
18:54:44 <desrt> safety is ensured by me not being able to give it an instance of IO
18:54:53 <desrt> i assume unsafePerformIO is hacked out
18:55:07 <dons> yes, there are restrictions on the modules in scope.
18:55:09 <monochrom> @plugs const 4 5
18:55:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
18:55:19 <monochrom> @plugs const 4 unsafePerformIO
18:55:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafePerformIO'
18:55:26 <dons> you have the Prelude, and the usual Data.*
18:55:39 <dons> no System.* Control.* Foreign.* GHC.*
18:55:48 * desrt gets an idea
18:55:57 <dons> and it's just H98 too. no -fglasgow-exts
18:56:04 <dons> TH is too dangerous, for one.
18:56:09 <desrt> crap
18:56:14 <dons> also, SimonM pointed out this:
18:56:16 <desrt> unsafePerformIO isn't H98 is it?
18:56:18 <dons> @type "foo"#
18:56:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "foo"# :: GHC.Prim.Addr#
18:56:30 <dons> that's just scary.
18:56:50 <desrt> what if i look up the source for some sort of IO function and run it?
18:57:05 <dons> the src is going to infer to an IO type, right?
18:57:13 <desrt> ok
18:57:19 <desrt> say i look up the source for unsafePerformIO
18:57:22 <desrt> is it possible to run that in H98?
18:57:30 <monochrom> Probably not.
18:57:31 <desrt> (or rather, in H98 as ghc defines it)
18:57:56 <monochrom> You will run into yet another module not imported.
18:58:14 <dons> unsafePerformIO (IO m) = case m realWorld# of (# _, r #)   -> r
18:58:14 <monochrom> eventually you run into C code. :)
18:58:48 <monochrom> const 4 (case m realWorld# of (# _, r #)   -> r)
18:58:54 <monochrom> @plugs const 4 (case m realWorld# of (# _, r #)   -> r)
18:58:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `of'
18:59:08 <desrt> realWorld is a strange concept
18:59:12 <desrt> and these #s are weird too
18:59:17 <dons> unboxed tuple.
18:59:26 <dons> not H98
18:59:39 <desrt> (# #) you mean
18:59:45 <dons> yeah.
18:59:55 <desrt> does it just put the closures for the child objects in an array or something?
19:00:13 <monochrom> @index unsafePerformIO
19:00:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
19:00:27 <desrt> what is realWorld# though?
19:01:08 <desrt> something you can apply to an IO to cause it to occur?
19:01:16 <desrt> (looks like)
19:01:21 <monochrom> @plugs const 4 unzip4
19:01:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
19:01:38 * desrt plays in ghci a bit
19:01:40 <dons> nah, it's just a token representing the real world, something to thread to keep the sequencing
19:01:46 <monochrom> @plugs const 4 System.IO.Unsafe.unsafePerformIO
19:01:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `System.IO.Unsafe.unsafePerformIO'
19:03:09 <dons> data RealWorld
19:03:16 <dons> that's all, really.
19:04:03 <dons> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
19:06:40 <monochrom> @plugs runST (do x <- newSTRef ""; readSTRef x)
19:06:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `runST'
19:06:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `newSTRef'
19:06:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `readSTRef'
19:07:33 <ozone> dons: it's much better now you're using notices
19:07:47 <desrt> @eval 45
19:07:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 45
19:07:51 <desrt> excellent :)
19:07:52 <dons> ozone: it's better, you think?
19:08:00 <monochrom> @plugs cast "" :: String
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `String' against `Maybe b'
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: String
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: Maybe b
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the application `cast ""'
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     When checking the type signature of the expression:
19:08:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	  cast "" :: String
19:08:07 <monochrom> @plugs cast "" :: Maybe String
19:08:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Just ""
19:08:15 <monochrom> Hmm!!!
19:08:18 <dons> hmm...
19:08:18 <ozone> dons: definitely.  or maybe i'm just bias because notices come out purple in my irc client :)
19:08:37 <ozone> though it should really be a notice anyway, since then other bots won't reply
19:08:44 <ozone> (as much as i remember anything about irc protocol)
19:09:05 <dons> ozone: yep, that's the motivation
19:09:08 <monochrom> @plugs undefined :: RealWorld
19:09:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Type constructor or class not in scope: `RealWorld'
19:09:32 <Cale> what is cast?
19:09:33 <dons> stupid Typeable. hmm..
19:09:39 <monochrom> hee hee hee
19:09:44 <Cale> oh
19:09:46 <dons> -- | The type-safe cast operation
19:09:46 <dons> cast :: (Typeable a, Typeable b) => a -> Maybe b
19:10:00 <Cale> yeah
19:10:01 <dons> but it's type safe... + you can't define your own Typeable instances.
19:10:04 <ozone> import Typeable hiding (cast) ?
19:10:08 * monochrom knows which corners to look for holes :)
19:10:22 <dons> I'm not sure this is one yet..
19:10:52 <dons> that unsafeCoerce# in Typeable.cast bothers me though..
19:11:03 <ozone> oo
19:11:03 <dons> you still need to get typeOf x == typeOf (fromJust r) to be true.
19:11:21 <dons> which requires construction your own Typeable instance to break, I think.
19:12:04 <ozone> dons: could you could crash it by unsafecoerce#ing an arbitrary value, then using cast?
19:12:35 <ozone> (since cast requires Typeable values)
19:12:36 <dons> hmm. not sure it'd infer. you'd need a type annotation. then you'd crash plugs. but that wouldn't bring down the bot.
19:12:48 <ozone> ah
19:12:57 <monochrom> @plugs cast "" :: Maybe (IO Int)
19:12:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No instance for (Show (IO Int))
19:12:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       arising from use of `show' at v = (show (cast "" :: Maybe (IO Int)
19:12:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ))
19:12:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the definition of `resource':
19:12:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	resource = let v = (show (cast "" :: Maybe (IO Int))) in v
19:13:06 <ozone> yay for layereed design
19:13:07 <monochrom> @plugs cast "" :: Maybe Int
19:13:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Nothing
19:13:15 <dons> typesafe cast!
19:13:15 <monochrom> You see it's currently safe.
19:13:59 <ozone> @plugs cast ( unsafeCoerce# 4 :: String ) :: Maybe String
19:14:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafeCoerce'
19:14:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `#'
19:14:09 <ozone> daww
19:14:15 <dons> no gla-exts, not GHC.*
19:14:33 <desrt> @plugs (cast "" :: (IO () -> ())) (putStr "Hello")
19:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `IO () -> ()' against `Maybe b'
19:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: IO () -> ()
19:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: Maybe b
19:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     Probable cause: `cast' is applied to too many arguments in the call
19:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (cast "")
19:14:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     When checking the type signature of the expression:
19:14:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	  cast "" :: IO () -> ()
19:14:47 <desrt> heh
19:14:51 <monochrom> It also doesn't like IO a
19:14:51 <dons> really, I should restrict the IO type visible in runplugs further.
19:14:56 <desrt> so, cast is not magic afterall :)
19:15:04 <dons> not terribly.
19:15:20 <dons> the unsafecoerce# it employs is, however.
19:15:23 <dons> but it's wrapped up.
19:15:36 <desrt> but it imports a little piece of unsafety
19:15:45 <dons> yep.
19:16:21 <dons> the type system is still holding out though. I'm so glad this isn't perl.
19:16:51 <dons> see, just this wee drop of dynamic typing makes things a little scary
19:19:19 <dons> any more ideas?
19:21:32 <liquidengineer> question
19:21:41 <liquidengineer> I have a list of tuples and a function that converts these tuples to strings
19:22:04 <desrt> you want >>=
19:22:13 <liquidengineer> no
19:22:15 <liquidengineer> that function works
19:22:25 <liquidengineer> but now I need a way to iterate through the list and print each tuple
19:22:28 <liquidengineer> and my brain is blanking
19:22:33 <desrt> mapM_
19:22:39 <liquidengineer> .....
19:22:42 <liquidengineer> god, I'm a moron
19:23:07 <dons> @plugs map show [('a','b'), ('d','e')]
19:23:08 <ozone> mapM_ ( \t -> putStrLn (show t) ) listOfTuples
19:23:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ["('a','b')","('d','e')"]
19:23:12 <ozone> anyhoo
19:23:16 <ozone> -> lunching
19:23:36 <desrt> putStrLn.show   aka  print
19:25:34 <liquidengineer> does haskell have a while construction?
19:25:44 <liquidengineer> like, while list length > 0?
19:26:24 <dons> not very idiomatic, but you can define your own control structures using do-notation and Control.Monad stuff
19:26:52 <dons> you'd usually check list length > 0 by pattern matching anyway, and recursion
19:27:11 <dons> f [] = 0 ; f (x:xs) = g x : f xs
19:27:25 <dons> do 'g' while list length > 0
19:28:12 <dons> the above code isn't type correct or sensible, btw. it just illustrates the syntax
19:30:22 <KrispyKringle> assuming you were to write that type-sensibly, it'd probably turn out to look a bit like map.
19:30:25 <KrispyKringle> which means you could just use map.
19:30:44 <liquidengineer> yeah
19:30:50 <KrispyKringle> higher order functions are, frequently, quite a lot more intuitive than loop idioms anyway, once you get used to them. using recursion to emulate a loop tends not to be.
19:30:52 <liquidengineer> map recordToString over my list of tuple
19:30:55 <liquidengineer> then I get a list of list
19:30:58 <KrispyKringle> right
19:31:00 <liquidengineer> err.. list of string
19:31:09 <liquidengineer> and how do I putStr over a list?
19:31:18 <dons> recursion /= emulating a loop. it is the more general concept.
19:31:27 <monochrom> mapM_ putStr (map recordToString)
19:31:32 <monochrom> err
19:31:33 <KrispyKringle> dons: sure.
19:31:34 <Cale> mapM_ putStrLn ["Hello", "World"]
19:31:41 <monochrom> mapM_ putStr (map recordToString whatever)
19:31:50 <liquidengineer> what is mapM_?
19:31:53 <KrispyKringle> monochrom: what's theinner map doing?
19:31:55 <liquidengineer> I've only ever seen map
19:31:55 <KrispyKringle> liquidengineer: map monad.
19:32:05 <KrispyKringle> since putStr is an IO (), you can't just use map with it.
19:32:23 <Cale> mapM f as = sequence (map f as)
19:32:31 <KrispyKringle> i mean, you can, but you'd get a list of IO actions.
19:32:36 <Cale> mapM_ f as = sequence_ (map f as)
19:32:53 <monochrom> mapM_ putStr [x, y, z] = do { putStr x; putStr y; putStr y }
19:33:14 <monochrom> there is your while loop.
19:33:26 <Cale> or for loop, anyway
19:33:29 <liquidengineer> ah
19:33:31 <liquidengineer> thanks guys
19:33:52 <Cale> I suppose it might be a while loop if the list is creatively defined.
19:33:55 <KrispyKringle> anyway, the point i was making is that it's actually MORE intuitive to "do something to every element of a list" than it is to "do this to the i'th element of the list for all i's in the range of 0 to the list's length"
19:34:22 <KrispyKringle> the foreach construct in many languages seems like a poor "map." the .each construct in ruby is somewhat better.
19:34:32 <monochrom> and that is still more intuitive than "while the list is not empty yet do this".
19:34:42 <KrispyKringle> right
19:35:10 <KrispyKringle> it's pretty rare that what you are doing actually cares which element index it is on, or what condition the list happens to be in, so those idioms should be relatively rare as well.
19:35:37 <monochrom> At a BBQ you never say "while the bag of sausages is not empty, put a sausage on the grill".
19:35:43 <KrispyKringle>  hahaha
19:35:46 <KrispyKringle> i like that, monochrom
19:35:55 <monochrom> You don't even say "for i = ..."
19:36:00 <Cale> and you certainly never number the sausages
19:36:02 <Cale> yeah
19:36:27 <dons> the 'while not empty, keep emptying' is definitely easier than ( 0 .. sizeof bag)
19:36:42 <monochrom> Imperative programmers should go to more BBQs and hear how real people give instructions to each other.
19:36:58 <KrispyKringle> it is, dons, but it's still not as easy as "barbeque the bag of hot dogs"
19:37:11 <KrispyKringle> which is really only slightly easier, and smiilar, to the "foreach hot dog, barbeque it"
19:37:12 <dons> hence no one suggested a for loop. a recursive function is nice for a recursive type though.
19:37:23 <KrispyKringle> true
19:38:29 <liquidengineer> hmmm
19:38:31 <liquidengineer> this isn't working
19:38:38 <liquidengineer> >showGbk :: Gbk -> IO ()
19:38:53 <liquidengineer> err...
19:39:08 <monochrom> code? paste board?
19:39:26 <liquidengineer> it's only two lines
19:39:29 <liquidengineer> can I stick it in here?
19:39:32 <monochrom> yes
19:40:02 <liquidengineer> showGbk :: Gbk -> IO ()
19:40:16 <liquidengineer> did it show up?
19:40:28 <monochrom> No, I only see "showGbk :: Gbk -> IO ()"
19:40:50 <liquidengineer> showGbk grades = map putStr (map recordToString grades)
19:41:09 <monochrom> May I see the type of recordToString?
19:41:41 <monochrom> Err nevermind.  First of all showGbk grades = mapM_ putStr (map recordToString grades)
19:41:42 <liquidengineer> recordToString :: (Name, Score, Score, Score, Total, Grade) -> String
19:41:48 <Cale> http://lambda-the-ultimate.org/node/view/613 haha
19:42:02 <liquidengineer> monochrom: what's the difference?
19:42:23 <monochrom> map f [x,y] = [f x, f y]
19:42:29 <KrispyKringle> whoah. that's one crazy tuple.
19:42:36 <monochrom> mapM_ f [x,y] = do { f x; f y }
19:42:47 <monochrom> You want the latter here of course.
19:43:14 <monochrom> It does you no good to obtain [putStr x, putStr y].  Nothing is going to be printed by that!
19:43:28 <liquidengineer> indeed
19:43:31 <liquidengineer> it's a list of IO objects
19:43:33 <liquidengineer> grrr
19:43:59 <KrispyKringle> these chocolate covered espresso beans are fantastic.
19:44:02 <KrispyKringle> im never going to sleep.
19:44:08 <Cale> if you have a list of IO actions, apply sequence to them to run them in sequence
19:44:21 <Cale> (to turn them into a single IO action, really)
19:44:30 <liquidengineer> showGbk grades = mapM_ putStr (map recordToString grades)
19:44:38 <liquidengineer> that's what I should change it to, right?
19:44:42 <monochrom> Yes.
19:48:05 <liquidengineer> it works
19:48:12 <liquidengineer> thank you muchly
19:48:21 <monochrom> you're welcome
19:55:31 <monochrom> Don't forget http://www.mail-archive.com/haskell@haskell.org/msg16382.html
21:25:56 <Sonarman> how do you divide two Ratio's?
21:26:45 <Sonarman> if i have two (Ratio a)'s, x and y, i can't do x%y, because that would be of type (Ratio (Ratio a)), and i want another (Ratio a)
21:31:27 <Sonarman> i can't define (a%b) %% (c%d) = a*d % b*c
21:31:37 <Sonarman> because it can't match patterns with %
21:33:50 <Sonarman> oh, maybe i can use numerator and denominator for that
21:39:53 <heatsink> Sonarman: use the (/) operator
21:40:12 * Sonarman bangs his head
21:40:14 <Sonarman> thanks
21:40:23 <heatsink> :D
21:40:35 <heatsink> sure.
21:42:44 <LeandroManuel> qsqs
21:43:30 <LeandroManuel> alex?
21:43:33 <LeandroManuel> siri?
23:50:59 <Itkovian> which ghc _does_ compile on gentoo ppc?
23:55:57 <dons> :/
23:56:57 <dons> ppc linux is pretty well supported, I'd say, as far as ghc archs go.
23:59:02 <bd_> Itkovian: ghc-6.4 is ~x86 on ppc
23:59:11 <bd_> err
23:59:14 <bd_> Itkovian: ghc-6.4 is ~ppc
23:59:19 <bd_> But ghc-6.2 is -ppc
23:59:29 <bd_> so, unmask ghc-6.4 and it should [in theory] work
