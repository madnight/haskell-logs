00:34:23 <Pseudonym> I need to burn a single file to a CD.  What's the quickest and dirtiest program to do that?
00:34:53 <lispy> i like gcombust, but i've heard k3b is good...
00:35:47 <Pseudonym> Thanks.
00:35:57 * Pseudonym consults yum
00:35:57 <tuomov> mkisofs -r files|cdrecord -dev= -
00:36:16 <tuomov> plus the device there
00:36:54 <tuomov> multisession is a bit more difficult with just mkisofs and cdrecord, though..
00:37:53 * Lor likes burn.
00:38:10 * Lor also likes abcde. :)
00:38:35 <Pseudonym> Ah, even quicker and dirtier.
00:38:36 <nailbite1> it truly sucks that all CD-burning tools on linux are basically front-ends to the one utility, 'cdrecord'
00:38:41 <Pseudonym> Cool, thanks.
00:38:59 <Gahhh> it also sucks that cdrecord recognizes my drive's capabilities...
00:39:06 <Gahhh> ...wrong.
00:40:14 <nailbite1> anyone want to hack up a decent cd burning library in haskell?  :)
00:40:52 <Lor> cd burning requires some real-time guarantees. Not exactly haskell's forte.
00:40:53 <tuomov> hmm.. don't burning tools have real-time constraints?
00:41:39 <vegai> there's that libcoaster thingie, which might some day replace cdrecord
00:42:30 <nailbiter> yes, but what would stop a haskell program from setting scheduler options itself?
00:42:57 <vegai> do modern burning hardware require real-time behaviour?
00:43:23 <nailbiter> vegai: i think that's "libburn". :) "libcoaster" sounds a bit scary
00:43:50 <vegai> oh right, libcoaster is the GUI thingy
00:44:06 <vegai> those projects haven't really moved much lately, have they?
00:44:39 <nailbiter> vegai: most of the recent progress on libburn was from someone working on a thesis.  he's finished his thesis and moved on, unfortunately
00:44:51 <vegai> huh, thesis?
00:45:00 <vegai> is cd burning really thesis material?
00:45:07 <vegai> cd burning software*
00:45:12 <nailbiter> vegai: his thesis was on building ISO9660 filesystems. :) basically an excuse to hack on libburn
00:55:19 <tuomov> nailbiter: It's not the scheduling but the GC kicking in
00:55:44 <tuomov> and lazyness too, I guess
00:56:15 <tuomov> you really want to be as close to the hardware as possible in that kind of things
00:56:22 <nailbiter> tuomov: ah, right. :-\ does ghc use a stop-and-copy collector?
00:56:34 <tuomov> so you know exactly how much code is executed at each time slice
00:57:32 <tuomov> I don't know what kind of collector it uses, but any collector makes it more difficult to make guarantees of real-time performance
00:58:21 <musasabi> well one can have a real time collector..
00:58:56 <musasabi> and if you have program time + max gc time < deadline, then it can be considered realtime ;)
00:59:26 <Lor> Yes, real-time gc is certainly possible. Just hairy.
00:59:34 <Lor> But the real problem is the laziness.
01:00:23 <blackdog> tuomov: region inference buys you a bit, doesn't it?
01:00:38 <tuomov> I don't know what that is..
01:00:41 <blackdog> but yes, still more difficult
01:00:49 <musasabi> blackdog: not really - as it is hard know what will be inferred.
01:01:42 <blackdog> musasabi: isn't the idea that you can enforce collection with types?
01:02:23 <blackdog> i'm not even close to an expert in gc, so i might be wrong.
01:02:32 <musasabi> blackdog: region interference == freing memory when it is no-more used based on an analyzation of the source code program?
01:02:38 <dons> you can infer collection points, yeah.
01:02:54 <dons> s/collection/free()/
01:03:13 <blackdog> http://www.cs.cornell.edu/Nuprl/PRLSeminar/PRLSeminar99_00/Walker/nov8.html seems to suggest that you encode collection points in the types
01:03:25 <blackdog> so you can control it where you have to, i guess?
01:03:44 <dons> yeah, regions become values with special types, iirc
01:04:00 <dons> so you can have statically safe gc, for example (there's an appel paper on that)
01:04:15 <dons> (when the gc is written in the langugage with regions types)
01:04:49 * blackdog goes home. if i'm not back in an hour, assume i've been hit by a truck
01:04:54 <dons> !
01:06:20 <musasabi> region allocation has to be combined with GC...
01:07:22 <dons> in practice, yes.
01:07:56 <musasabi> because you can have code like: if read "True" then writeIOVar global (read "\"foobar\"") else return ""
01:08:07 <musasabi> where the readed strings come outside the program.
01:08:36 <musasabi> otherwise there is a space leak which is quite fatal for globals (or inside main) in a long running programn.
01:08:50 <dons> yeah, good point.
01:10:17 <musasabi> but region inferrence can greatly minimize the amount of data needed to GC.
01:11:04 <musasabi> so it will be more like the old generation collector.
01:31:14 * boegel starts shaking hands "Hello everyone
01:31:42 * Muad_Dibber waves to boegel
01:32:21 <dons> @yow
01:32:22 <lambdabot> I just remembered something about a TOAD!
01:53:56 <dons> moring nibro
01:54:09 <dons> morning/night/whatever
01:56:16 <a5> hi everybody
01:56:22 <boegel> hi Docter Nick !
01:56:25 <boegel> err, a5
01:56:53 <a5> dr. nick is ok
01:57:10 <boegel> woops, I wanted to be fast :) I meant to type Doctor
02:03:35 <nibro> morning over here =)
02:03:43 <boegel> noon over here
02:03:54 <nibro> how's the migration going? ;-)
02:04:58 <nibro> boegel: well, we're in the same time zone, so I guess morning is a matter of definition...
02:05:01 <bringert> morning nibro
02:05:20 <nibro> bringert: and what a good morning it is, don't you think? =)
02:06:56 <dons> nibro, hs-plugins is in darcs now, btw.
02:07:42 <nibro> dons: great, want a patch then? =)
02:07:48 <dons> sure!
02:07:59 <nibro> what's the location?
02:08:03 <dons> http://www.cse.unsw.edu.au/~dons/code/hs-plugins, I think
02:08:21 <dons> yep. that's it.
02:08:59 <bringert> nibro: yes
02:10:04 <nibro> bringert: I'm still waiting for some sort of official announcement, how did you find out?
02:12:04 <bringert> people walking into my office saying "congratulations"
02:12:12 <bringert> no official stuff yet
02:15:41 <boegel> bringert: inform us !
02:16:36 <bringert> boegel: phd positions
02:17:02 <a5> where?
02:17:38 * boegel leaves to work on his thesis text
02:18:01 <boegel> bye #haskell
02:20:04 <nibro> at Chalmers (Gothenburg), there were two positions announced and me and bringert got them =))
02:20:31 <dons> congrats!
02:20:42 <a5> congratulations
02:21:02 <Lor> Cool.
02:21:30 <a5> are you both undergraduates now?
02:22:05 <boegel> congrats nibro and bringert :)
02:22:35 <nibro> a5: we both graduated about a month ago
02:22:40 <nibro> thanks alot =)
02:23:02 <dons> is this the same kind of position that peteg got a couple of years ago?
02:23:59 <a5> i guess this means i didn't get in... oh well
02:24:31 <nibro> not sure what kind of position gammie had, but I have his old workplace ;-)
02:25:06 <dons> ha!
02:25:44 <dons> he left a phd here to do one at chalmers, i remember it was fairly competitive
02:25:58 <dons> so congratulations++
02:27:03 * dons now considers how to get nibro hacking on yi..
02:27:05 <nibro> ++thanks
02:27:53 <jlouis> No perverted C-syntax, please
02:27:57 <dons> so with that patch, I still need to import Language.Haskell.Hsx, right?
02:28:14 <boegel> @karma jlouis
02:28:14 <nibro> dons: by supporting haskell-src-exts in hs-plugins, then I can release hsp and get time over for other things ;)
02:28:15 <lambdabot> jlouis has a karma of 0
02:28:27 <nibro> dons: yes, that's one of the changes
02:28:52 <dons> ok.
02:29:01 <nibro> the interface is no longer identical to the old haskell-src
02:29:38 <nibro> I added support for parsing files containing #... lines, which is now in the top module Language.Haskell.Hsx
02:30:00 <nibro> that's why s/parseModuleWithMode/parseFileContentsWithMode/
02:30:31 <dons> ok.
02:31:43 <nlv11757_> hmm
02:31:45 <a5> hi ulph
02:44:58 <glimming> hi, what is the difference between value constructor and type
02:44:58 <glimming> constructor in
02:45:00 <glimming>     data List a   = Cons a (List a)
02:45:00 <glimming>                   | Nil
02:45:00 <glimming>  
02:45:24 <glimming> Is List a type constructor, and Cons,Nil value construtors?
02:46:13 <dons> yep.
02:46:23 <glimming> So for data Nat = Zero|Succ
02:46:27 <glimming> there are NO type constructors involved?
02:46:33 <jlouis> yep.
02:46:41 <jlouis> ehm, no
02:46:44 <jlouis> not sure actually
02:46:47 <dons> Nat is a type constructor, though.
02:47:05 <glimming> Ok, good.
02:47:07 <dons> if you use it anywhere, you get a type. hence it constructs types.
02:47:16 <glimming> Well Nat is nullary tycon.
02:47:17 <glimming> Ok.
02:47:18 <glimming> Good.
02:47:21 <glimming> Antoher question.
02:47:35 <dons> yep. nullary tycon.
02:47:37 <glimming> Is someone familiar with qualified types?
02:47:45 <dons> sure. shoot
02:48:00 <glimming> When Jones say "predicate" what does he mean?
02:48:08 <glimming> Predicate over what???
02:48:35 <dons> over types, I guess.
02:48:38 <glimming> I see nothing said about thast in a system of cons classes
02:48:43 <glimming> paper
02:49:26 <glimming> Also WADLER's initial paper on type classes did not use qualified
02:49:26 <glimming> types so what is the motivation for this work at all?
02:49:30 <glimming> Wadler used a translation.
02:50:36 <Philippa> the predicate in question with type classes is "has this set of operations available". The original motivation was to provide overloading
02:50:36 * musasabi is not sure what is meant with "qualified types". A set of types satisfying a predicate or restricted kinds?
02:50:56 <Philippa> musasabi: pretty much the former. A generalisation of type classes
02:52:04 <jlouis> now with a hugs2005Mar update pushed to the pkgsrc-database at NetBSD
02:52:31 <glimming> Yes, but predicate can be from many different logics...
02:52:44 <musasabi> The "Sat" thing?
02:52:48 <Philippa> or it can be a one place relation
02:52:55 <glimming> Ok.
02:53:01 <glimming> Many thanks!
02:53:03 <glimming> bye for now
02:59:39 <nlv11757_> why do some people prefer >>4 instead of dividing by 16
02:59:47 <Philippa> depends on the context
02:59:57 <Philippa> for some it's an old optimisation that dies hard
03:00:12 <Philippa> it's traditional when you're doing bit-twiddling though
03:00:29 <nlv11757_> use bitshifts where possible to squize performance
03:00:32 <nlv11757_> that kind of mindset?
03:00:38 <Philippa> yeah
03:00:47 <nlv11757_> yuk
03:00:52 <tromp> if you're using a byte as two 4bit fields, shift is more natural than divide
03:00:53 <nlv11757_> its makes code soooo unreadable sometimes
03:01:16 <musasabi> nlv11757_: if the semantic operation is "shift 4 bits" then that is better. If it is "divide by 16" then the latter is better of course.
03:01:22 <Philippa> tromp: agreed. Like I said, traditional when doing bit-twiddling
03:01:36 <nlv11757_> tromp, but if you use something occupying multiple bytes, then >>4 is not always divide the decimal version by 16
03:01:37 <nlv11757_> right?
03:01:56 <nlv11757_> depends on endianess
03:02:03 <Philippa> not usually
03:02:18 <tromp> depends on language whether >> is logical or arithmetical
03:02:25 <musasabi> another issue is signedness and how it affects the operations.
03:02:37 <tromp> some use >>> as logical version
03:20:29 <earthy> tromp: nlv11757 is talking about C
03:23:44 <tromp> in C it depends on whether the argument is signed or unsigned
03:23:56 * earthy nods
03:40:06 <nlv11757_> but doesnt it also depends on the endianess?
03:40:34 <nlv11757_> cause shifting bits to the right then suddenly dont mean dividing by e.g. 16 anymore
03:40:59 <Philippa> no, the operation's done on the in-register representation not the in-memory one if that makes sense
03:42:07 <nlv11757_> in-register representation is a kind of common representation over all platforms?
03:42:18 <Philippa> it's the one you'd expect
03:42:52 <nlv11757_> that sounds a bit subjective
03:43:15 <Philippa> short of swapping left and right round, there's not a lot you can do that doesn't violate an expectation, no?
03:43:43 * nlv11757_ takes a big sip of his coffee
03:44:00 <Philippa> bits ordered by significance
03:44:33 <Philippa> if a given processor does swap which end's left and which's right, the compiler can deal with it
03:45:23 <nlv11757_> so the compiler determines exactly on what >> works depending on the platform?
03:45:44 <nlv11757_> it may swap something if the underlying representation is not as expected by the compiler
03:46:22 <Philippa> yeah, though that'd just yield the same observable results once you translate from the underlying representation to the one C encourages you to think in (ie not caring about endianess)
03:46:27 <wilx> Hmm, I don't know any arch that would have >> do anything else than what you would expect, i.e. shift right/divide by 2.
03:46:52 <Philippa> wilx: somebody might be feeling mean and redefine shl/shr or the local equivalent
03:47:04 <Philippa> >>, being a C construct, shouldn't be affected
03:47:28 <nlv11757_> wow thats actually a nice thing in C, abstracting from that :)
03:47:56 <Philippa> you should see all the nasty stuff about rounding and so forth it covers you for :-)
03:48:48 <nlv11757_> i think i'll pass, i have a hard time enough trying to understand a piece of C software from someone else
03:49:59 <nlv11757_> is there a good approach to this besides just throwing oneself on the sourcecode?
03:50:13 <jewel> you should first remove your shirt
03:50:23 <jewel> take a marker and draw a cross just over the heart
03:50:30 <Philippa> depending on the code, alcohol, LSD or both may help
03:50:51 <nlv11757_> let me see if i can get my employer to pay for that
03:50:59 <Philippa> trying to sketch out what each function does, both in terms of what it returns and what its side-effects are, is a good start
03:51:12 <Philippa> once you've got that you've a reasonable hope of understanding the control flow
03:51:35 <Philippa> Lemmih: any advice on reverse-engineering C code?
03:51:47 <Philippa> preferably other than "don't"?
03:51:51 <nlv11757_> hehe
03:52:02 <jewel> also easier if you can write main methods and call the code and question
03:52:13 <jewel> (you can't a repl, but try emulate it)
03:52:32 <nlv11757_> you mean trying to execute parts of the code jewel?
03:52:39 <nlv11757_> if i understand you correctly
03:55:43 <ozone> hmm, any type experts around here?
03:56:14 <Philippa> what exactly do you need help with?
03:56:26 <ozone> hmm, hard to phrase the question
03:56:28 <ozone> i'll just paste in the code :)
03:56:30 <Philippa> (IANAExpert...)
03:56:35 <ozone> esssentially, what's the difference between:
03:56:35 <ozone> data EqRankN = Interface (forall a. Eq a => a -> a -> Bool)
03:56:36 <ozone> data EqExists = forall a. Eq a => Interface2 (a -> a -> Bool)
03:56:46 <ozone> so, one of them uses rank-n types, the other is an existential type
03:57:07 <ozone> both of them more-or-less do the same job, i think.  there's something i'm missing, though ...
03:57:17 <Philippa> assuming both're valid I'd say they're pretty much equivalent
03:57:20 <ozone> since i'm pretty sure the two aren't really isomorphic
03:57:53 <ozone> hmm, ok
03:58:03 * ozone still reckons he's missing something fundamental
03:58:07 <Philippa> give or take EqRankN and EqExists Interface and Interface2 have the same type when used as constructors, no?
03:58:17 <ozone> yep
03:58:42 <ozone> even if you had >1 data constructor, it'd still look the same i think
03:58:58 <Philippa> different syntax for the same thing, then
04:00:20 <Lemmih> Good morning, #haskell.
04:00:29 <ozone> thanks philippa
04:05:43 <nlv11757_> whats existential about  forall a. Eq a => Interface2 (a -> a -> Bool)
04:06:30 <Philippa> nlv11757_: it's isomorphic to an existential type
04:06:42 <Philippa> but yeah, that's perhaps not a wonderful piece of terminology
04:06:50 <ozone> nlv11757_: the 'a' is existentially quantified
04:06:58 <ozone> the 'forall' there should really be read as 'exists'
04:07:07 <ozone> (it's "just a syntax thing" :)
04:07:44 <musasabi> Personally I think forall is more readable.
04:07:55 * Philippa wants the upside-down A, but hey
04:08:05 <nlv11757_> existential types are more than just syntax afaik
04:08:56 <nlv11757_> i just really read TaPL again
04:08:57 <musasabi> \forall looks ugly in most fonts outside the latex land.
04:09:40 <musasabi> Tried adding haddock to support it but it didn't look very pretty in the browser - same with greek letters.
04:10:44 <ozone> Philippa: sent an email to the haskell list anyway, but cheers
04:11:10 <Philippa> just had a thought - they /wouldn't/ be equivalent if you wanted more than one parm to the constructor
04:11:16 <Philippa> as the scope of the a would vary
04:11:55 <ozone> ah, good point
04:15:26 <Philippa> nlv11757_: it's isomorphic (or close) to an existential type if you sit down and think it through
04:15:31 <Philippa> the relevant bit of the GHC docs explains
04:15:42 <Itkovian> aft'noon
04:16:06 <nlv11757_> hehe ok Philippa, i'll think about it sometime :D
04:16:16 <nlv11757_> btw
04:16:17 <nlv11757_> if i say 'ref0[0] = (unsigned char *) malloc (size)' would that only allocate space for ref0[0] or the complete ref0 array?
04:16:52 <Philippa> is it an array of arrays or pointers?
04:16:54 <nlv11757_> ow wait, it just allocates space and return the pointer to the beginning of that space right?
04:17:00 <Philippa> if not I'd expect that to be a type error
04:17:01 <Philippa> right
04:17:11 <ozone> nlv11757_: it would make ref0[0] a pointer to the newly allocated space
04:18:09 <nlv11757_> and doing ref[1] = ref[0] + (size >> 1) would make a pointer pointing in the middle (more or less) of that space?
04:18:23 <Philippa> don't shift size
04:18:29 <nlv11757_> ?
04:18:31 <Philippa> multiply it by size_of(whatever'sinthearray)
04:18:51 <Philippa> or half it, or
04:18:55 <Philippa> oh, wait, shifting /right/
04:18:56 <Philippa> fair enough
04:19:00 <Philippa> yeah, it would do
04:19:05 <Philippa> ref[1] would be that pointer
04:19:18 <ozone> crazy c constructs
04:19:18 <nlv11757_> alright
04:19:20 <Philippa> and if you did size << 1, you'd probably crash something when you dereference it :-)
04:19:34 <nlv11757_> being a weird address and all :)
04:20:22 <Philippa> you know that when you add to a typed pointer, 1 is the size of whatever it's a pointer to?
04:21:07 <Philippa> (thus you can use that for an array walk, though IMO that's bad style)
04:23:14 <ozone> GADTs hurting brain, ow ow
04:24:23 <Lor> Aren't GADTs essentially just syntactic sugar for the a <-> b type equality trick?
04:24:30 <wilx> Using shifts when you want *2 or /2 is wrong.
04:24:43 <wilx> It obfuscates the source.
04:24:45 <nailbiter> nlv11757_: you'll probably get a syntax error with that bit of C code.  if you want a pointer to element #1 (as opposed to element #0) of the array 'ref', use "ptr = &ref[1];" or just "ptr = ref + 1;"
04:25:09 <JaffaCake> wilx: I disagree :)
04:25:22 <JaffaCake> * and / are overloaded, and might not be O(1)
04:25:23 <nlv11757_> i agree also, but this is not my code lol
04:25:32 <wilx> Eh?
04:25:54 <nailbiter> nlv11757_: if you want a pointer into the middle of the array 'ref', use "ptr = (void *)ref + size / 2;".
04:26:30 <JaffaCake> oh sorry, you're talking about C
04:26:31 <wilx> JaffaCake, what do you mean by your second statement?
04:26:36 <wilx> Right.
04:26:40 <JaffaCake> I'll get me coat
04:26:57 <nlv11757_> nailbiter, i just have a piece of space where ref[0] point to the beginning, so adding size >> 1 gives you a pointer in the middle of *that space*
04:27:16 <nailbiter> nlv11757_: no, it won't. cast to (void *) first, otherwise your pointer arithmetic will go funny
04:27:36 <musasabi> nlv11757_: why not simply write &ref[0][nelems/2] ?
04:28:02 <wilx> Yeah :)
04:28:09 <nlv11757_> musasabi, what does the extra indexing do?
04:28:49 <wilx> Pointer arithmetics.
04:28:53 <wilx> Why do you care?
04:29:01 <integral> @pointless \n x -> f x (g 1 x)
04:29:02 <lambdabot> const (ap f (g 1))
04:29:13 <nailbiter> nlv11757_: i really suggest you avoid pointer arithmetic when you can. it's a great way to shoot yourself in the foot
04:29:14 <integral> @pointless \n x -> f x (g 1 n)
04:29:15 <lambdabot> flip f . g 1
04:30:31 <nlv11757_> nailbiter, again im studying code not written by myself.
04:30:34 <nlv11757_> i kinda have no choice here
04:30:50 <nailbiter> nlv11757_: can you shoot the author's foot for us, then? :)
04:30:57 <nlv11757_> gladly
04:31:12 <nlv11757_> im regretting ever having to do with this C stuff
04:33:05 <musasabi> C is not too bad.
04:33:40 <musasabi> most annoying is the lack of tail calls.
04:34:13 <nailbiter> by the way, i recently discovered GCC allows lambda functions. :)
04:35:04 <musasabi> GCC tends to be very annoying.
04:35:23 <vegai> gcc has tail-call optimization
04:35:36 <nailbiter> musasabi: how so?
04:35:42 <vegai> I don't know how good it is, but...
04:35:53 <nailbiter> vegai: wow, i didn't know that. :)
04:36:25 <musasabi> vegai: yes, but it is more or less random when it is applied to real code ;)
04:36:27 <nailbiter> aha -- -foptimize-sibling-calls: Optimize sibling and tail recursive calls. Enabled at levels `-O2', `-O3', `-Os'.
04:36:48 <vegai> and -mtail-call
04:37:11 <vegai> I bet it's not beautiful :)
04:37:12 <musasabi> nailbiter: It is very buggy with each version introducing a host of bugs, and the internal structure is orrible
04:37:16 <musasabi> *horrible
04:40:19 <d99mary> is anybody here a wiz on wx?
04:41:35 <d99mary> trying to paint in some way with semitransparent colour.
04:42:16 <wilx> musasabi, if you know any bugs you should submit them to GCC's bugzilla.
04:48:42 <dcoutts> vegai: which is why someone should write a C-- front end for gcc, since the gcc internal language does support tail calls
04:49:06 <Philippa> wilx: that's not much help when you're trying to code
04:49:27 <Itkovian> anybody happen to have a 32-bit libgmp for the opteron lying around?
04:49:40 <Itkovian> my ghc created binaries wish to link against it ...
04:49:42 <Itkovian> :-(
04:50:01 <bringert> chucky might
04:50:02 <Itkovian> and libgmp is refusing to compile decently with -m32
04:50:34 <Itkovian> he's been idle for 16 hours :-S
04:51:47 <JaffaCake> Itkovian: I've used one I took from an i386 machine, seems to work fine
04:52:03 <Itkovian> JaffaCake: ok, I'll try that, thx.
04:57:33 <dcoutts> JaffaCake, my experiments with GC options (re: emails the other day) reveal that "+RTS -H380m -M380m -A5m -T4 -RTS" does quite well
04:57:50 <dcoutts> but -G3 increased heap requirments enourmously
04:58:10 <JaffaCake> that's interesting
04:58:24 <dcoutts> -A5 was only marginally better than -A1
04:58:40 <JaffaCake> how much improvement did you get from -T4?
04:58:57 <dcoutts> which was only marginally better than the default -A value
04:59:06 <JaffaCake> right
04:59:11 <dcoutts> +RTS -H350m -M380m -A1m -RTS:		3m3.131s
04:59:16 <dcoutts> +RTS -H380m -M380m -A1m -T4 -RTS:	2m47.466s
04:59:27 <JaffaCake> hmm, that's handy to know
04:59:36 <JaffaCake> what happened with -G3?
05:00:07 <dcoutts> with -G3 it always ran out of heap, even when I increased -M to 650m
05:00:30 <JaffaCake> hmm, that could be a generation-size-tuning issue
05:00:33 <dcoutts> which is about as far as I can push things without swapping to death
05:00:59 <dcoutts> there isn't an option to control generation size, right?
05:01:19 <JaffaCake> -F<n>
05:01:30 <JaffaCake> but you can't fix the size of a generation
05:01:50 * JaffaCake goes to check the source
05:02:48 <dcoutts> and, -T3 is better than -T4 by a small amount (that run just finnished)
05:02:54 <JaffaCake> it's totally bogus
05:03:04 <dcoutts> ?
05:03:11 <JaffaCake> we set the size of all generations except 0 to be the same size
05:03:32 <JaffaCake> which is -F<factor> * live data
05:04:08 <JaffaCake> but you probably want something a lot smaller than that
05:05:55 <JaffaCake> did you get a chance to test that fix to the 6.4 branch yet?
05:06:10 <dcoutts> right, people tell me I want a large old generation and smaller yunger ones
05:06:53 <dcoutts> I'm about to test the 6.4 branch on amd64 now, I've checked out the 6.4 latest branch and got it to build
05:07:06 <JaffaCake> great
05:07:42 <dcoutts> I'll go offline now and come back in amd64 mode :-) ...
05:07:49 <JaffaCake> heh, ok
05:12:38 <Lunar^> damn... Alex still going on
05:12:50 <Lunar^> that thread really starts to bother me
05:14:04 <JaffaCake> is he?
05:14:09 * JaffaCake goes to check email
05:16:50 <Lunar^> JaffaCake: dunno, I am doing @haskell.org lists per 100 mails
05:17:06 <JaffaCake> ah ok
05:18:37 <Igloo> JaffaCake: Have you got a minute to clear up a bit of confusion I have about this selector business please?
05:18:58 <JaffaCake> sure.. you have 1 minute starting..... now
05:19:04 <Igloo> :-)
05:19:41 <Igloo> When you say thunks are a problem, do you mean that with S->P->S->P->S->T (S=selector, P=pair, T=thunk) you can't just replace all the selectors with indirections to the thunk?
05:20:05 <JaffaCake> no, you can
05:20:22 <Igloo> OK, so what's the problem case that needs the marks, then?
05:20:37 <JaffaCake> hang on a sec...
05:29:06 <JaffaCake> Igloo: sorry about that
05:29:19 <Igloo> np
05:29:39 <JaffaCake> right, the problem is this: you have to walk down the chain to find the value at the end, and then walk back up updating all the S closures
05:30:24 <JaffaCake> but you don't want to use recursion to do that, so do two traversals instead... that was your idea, I think?
05:30:30 <Igloo> Right
05:31:13 <Igloo> So we end up with the left 2 Ss above being replaced with indirections to the last S?
05:31:23 <JaffaCake> ok, but if the chain leads us into to-space, then we can't traverse any further
05:31:48 <Igloo> to-space?
05:32:06 <JaffaCake> i.e. data already evacuated during this GC
05:32:20 <JaffaCake> hmm, now I'm trying to remember why we need the marks
05:34:48 <JaffaCake> Igloo: re your last-but-one comment, I think the answer is yes
05:35:16 <JaffaCake> I'm getting mixed up between chains like S->S->S->T and S->P->S->P->S->T
05:35:37 <JaffaCake> the fist one can't be updated, but the second one you can update all but the last S
05:36:42 <Igloo> Ah, so with the first one, in the current scheme you do constant work for each entry point whereas if you chased to the end you'd do linear work for each entry point?
05:37:14 <JaffaCake> yes
05:37:30 <JaffaCake> the first kind, I don't think you can avoid recursion
05:37:45 <JaffaCake> because each one gets updated with a different value
05:38:07 <Igloo> When do you get the first one?
05:38:24 <JaffaCake> fst (fst (fst (1,(1,(1,2)))
05:38:43 <JaffaCake> ))
05:39:16 <JaffaCake> oops, fst (fst (fst (((1,(1,(1,2)))))
05:39:29 <JaffaCake> oh, sod it
05:39:34 <Igloo> I get the idea  :-)
05:39:36 * JaffaCake pulls out GHCi
05:39:59 <Igloo> Hmm, OK, I think you've convinced me marks are necessary to handle that case, anyway
05:40:04 <Igloo> thanks
05:40:27 <JaffaCake> I'm happy to just deal with the second case without a depth bound, if we can
05:40:58 <JaffaCake> the reason I haven't done it is because that bit of code is v. delicate, and a notorious bug farm
05:41:05 <Igloo> :-)
05:44:25 <Lunar^> seems like voodoo :)
05:45:52 <ozone> GHC RTS is all voodoo :)
05:46:47 * shapr sacrifices a redex to the RTS
05:46:59 <ozone> ok, my brain isn't working
05:47:11 <ozone> if i want to make a list that's strict in its elements
05:47:16 <ozone> something like
05:47:25 <ozone> data StrictList a = StrictListCons !a | StrictListNil
05:47:29 <ozone> would work, roight?
05:47:44 <Lunar^> @type (::)
05:47:49 <lambdabot> bzzt
05:47:51 <Lunar^> @type (:)
05:47:53 <lambdabot> (:) :: forall a. a -> [a] -> [a]
05:48:11 <ozone> hmm, normal lists are strict in their elements?
05:48:16 <Lunar^> StrictListCons :: foralall a. a -> StrictList a
05:48:17 <Lunar^> here
05:48:39 <ozone> oh duh
05:48:41 <ozone> *slaps head*
05:48:58 <ozone> ok, nevermind.  forgot the additional StrictList a type in the Cons constructor
05:49:27 <ozone> thanks Lunar^ (told you my brain isn't working)
06:04:54 <shapr> hej ulph
06:05:05 <ulph> hej shapr!
06:05:08 <Jerub> shapr!
06:05:19 <shapr> g'day Jerub
06:05:51 <shapr> ulph: I'm rollin! Great t-shirts.
06:06:46 <shapr> y0 CosmicRay
06:06:46 <ulph> shapr: Thanks! :P
06:06:52 * shapr hops cheerfully
06:06:56 <CosmicRay> morning shapr!
06:06:57 <shapr> good morning #haskell!
06:07:06 <CosmicRay> shapr: fptools is converted through 2003 at this point!
06:07:10 <shapr> w00!
06:07:31 <CosmicRay> fptools$ ls _darcs/patches | wc -l
06:07:32 <CosmicRay> 16622
06:07:37 <shapr> wow
06:07:46 <dons> cool!
06:07:56 <CosmicRay> so we're about 2/3 done
06:12:47 <Lor> Huh? fptools gets migrated to darcs?
06:13:01 <CosmicRay> as an experiment for now
06:13:12 <CosmicRay> my hope is that it works well and they switch to darcs for the real thing
06:13:24 <CosmicRay> I'm converting the entire CVS history for fptools to darcs at the moment
06:13:26 <Jerub> darcs looks kinda nice.
06:13:31 <CosmicRay> Jerub: it is
06:13:39 <Jerub> does it scale?
06:13:40 <Itkovian> nice
06:13:50 <Jerub> I mean, could it be used for the linux kernel?
06:13:54 <CosmicRay> Jerub: there's a darcs version of the kernel bitkeeper repo.  it is fast.
06:13:54 <Itkovian> Jerub: not atm afaik, but they're working on it
06:14:04 <dons> Jerub, faq.
06:14:10 <Itkovian> Jerub: I thought Linus discarded it in favour of GIT
06:14:24 <CosmicRay> Itkovian: actually it was quite speedy for the kernel bitkeeper repo in my experience
06:14:38 <Itkovian> dang
06:14:49 <CosmicRay> that one had about 20,000 changesets
06:14:57 <CosmicRay> so fptools will have more changesets but a smaller source tree
06:14:58 <Itkovian> ah well, insight will come with time
06:15:04 <Itkovian> ic
06:15:06 <Jerub> CosmicRay: okay.
06:16:40 <shapr> Does anyone here have experience with gpg web of trust for binary distribution? Or pointers to good info? I suggested to David Roundy that gpg-signed binaries would be better than moderated wiki pages, and now he wants detailed options.
06:17:19 <CosmicRay> shapr: it would indeed be better.  If he, or someone on a certain authorized keyring, would sign them, it would work well
06:17:29 <Jerub> shapr: I discussed this with the ubuntu guys last week, web of trust tools simply don't exist in a usable form was the answer.
06:17:41 <CosmicRay> shapr: convention is to make a "detached signature" so that you have, say, a tar.gz file and a .sig file
06:17:49 <CosmicRay> so people aren't forced to use gpg to extract it, but can if they wish
06:18:21 <CosmicRay> Jerub: that is odd.  we use this in debian.
06:18:46 <CosmicRay> in Debian, every upload must be signed by a Debian developer
06:18:51 <CosmicRay> whose key is in the Debian keyring
06:19:01 <Jerub> CosmicRay: yes, but there's no associtiveness, it's not a web of trust.
06:19:04 <Jerub> it's just a keyring.
06:19:16 <CosmicRay> on the mirrors, the index files (which cntain md5sums), are signed by a known key
06:19:24 <Jerub> I can't trust you just becuase I trust shapr and shapr trusts you.
06:19:40 <CosmicRay> Jerub: gpg has that feature already, doesn't it?
06:19:47 <Jerub> yeah, if you do it in the flat case, one keyring, a small set of magic keys, it works fine.
06:19:57 <CosmicRay> you can set whether someone is a trusted signer or something
06:20:15 <Jerub> CosmicRay: but does it work, and does anyone use it?
06:20:31 <CosmicRay> Jerub: I think the answer is yes to both of those, but I don't use it myself
06:20:32 <shapr> In this case, David is talking about a trusted developer keyring that's signed by a key other than his standard private key.
06:21:08 <Jerub> shapr: that works fine.
06:21:10 <wilx> Philippa, if they don't know what is wrong they can't fix it.
06:25:17 <CosmicRay> JaffaCake: Question for you, oh deity of fptools...  why is HaXml in fptools but not in the ghc distribution?
06:25:40 <shapr> It got split out of ghc recently.
06:25:42 <JaffaCake> we stopped shipping it, at Malcolm's request
06:25:48 <JaffaCake> he wanted to distribute it separately
06:25:59 <CosmicRay> oh, hmm.  so it was part of ghc at some point?
06:26:10 <JaffaCake> yeah, a few versions back.. can't remember exactly
06:26:15 <CosmicRay> before 6.2?
06:26:43 * JaffaCake checks the cvs logs
06:28:28 <JaffaCake> 5.04 had it
06:28:54 <JaffaCake> 6.0 dropped it, I think
06:35:30 <nlv11757_> does anybody know if making a dependency graph of a C application is feasible?
06:35:54 <earthy> it is
06:35:55 <earthy> why?
06:35:57 <nlv11757_> data dependency graph that is
06:36:24 <nlv11757_> ow otherwise the chances of me graduating would be slim lol
06:36:26 <earthy> you'll have to do some trickery when pointer calculations are involved ofcourse.
06:37:23 <nlv11757_> no doubt
06:55:26 <Igloo> CosmicRay: With a released darcs, didn't getting the kernel repo take you about a day? Do you really think of that as fast?
06:57:37 <Igloo> Signing darcs binaries is only useful if people have a trust path to the signing key
07:02:11 <Muad_Dibber> brb, reboot
07:03:47 <nlv11757_> hey Philippa, that approach of 'for every function write down/find out what it does and which side-effects it has' is working out a bit
07:04:15 <nlv11757_> im starting to make a bit sense of this code
07:15:52 <jlouis> nlv11757_: Philippa_ was not here when you said that
07:15:59 <jlouis> probably
07:16:28 <jlouis> anyway, the pencil and paper method is magnificient. Try to print out source code some day and read it with a pencil to take notes in the margin. It rocks
07:23:00 <shapr> I do that for research papers.
07:24:45 <nlv11757_> jlouis, that is exactly what i am doing right now, i printed relevant c files on paper and are reading them crossreffing them, seperately im writing in my noteblock what a function does, if it does dirty stuff like modifying globals etc.
07:24:56 <beschmi> i'm wondering if the warning in http://haskell.org/hawiki/HaskellIrcPastePage is wrong. the warning appears only with ghc-6.4
07:27:08 <nlv11757_> beschmi, it does strike me as odd since you've explicitly imported one of them qualified
07:27:20 <nlv11757_> at first glance anyway
07:27:36 <Igloo> Looks wrong to me. I have a vague feeling it might have been reported before, hang on
07:27:45 <nlv11757_> this is when using ghci or ghc?
07:27:54 <beschmi> ghc
07:28:42 <Igloo> Yup, http://www.haskell.org//pipermail/glasgow-haskell-bugs/2005-April/004931.html
07:29:25 <beschmi> thanks
07:30:06 <basti_> hi all
07:30:08 <Igloo> You could work around it by listing the things imported from DarcsRepo
07:30:43 <sond> is there a function to insert something in a list at a certain index, in Data.List that i haven't found?
07:31:18 <sond> I know you shouldn't treat lists as arrays, but still
07:31:39 <Igloo> Don't think so; you can splitAt and then put it back together
07:32:31 <sond> mmkay..
07:32:41 <sond> a bit weird since there is (!!)..
07:33:38 <blackdog> sond: where do you need to insert it? Perhaps there is a way to generate the list in the right order from the beginning...
07:33:56 <blackdog> and !! is usually a bad smell. :)
07:34:16 <nlv11757_> isnt here some compiler that warns when you use !! :P
07:35:46 <ozone> is there a proper maths name for a two-dimensional list?
07:36:01 <ozone> as in, like a matrix, but with an irregular shape
07:36:10 <ozone> i.e. inconsistent number of columns/rows
07:37:38 <sond> blackdog, I really need random access but it's ok speedways anyway
07:38:04 <sond> ah what the heck, i solved it with splitAt
07:40:50 <blackdog> ozone: need an impressive-sounding name for a paper? :)
07:41:05 <ozone> heh, actually, a name for a data structure
07:41:22 <ozone> ListOfLists or TwoDimensionalList is just a bit lame :)
07:41:24 <blackdog> [[a]] not good enough?
07:43:08 <ozone> hmm, though, the semantics of one axis is a bit different from the other
07:43:35 <ozone> it's a two-dimentional list, where one axis implies sequential composition, and the other axis implies parallel composition
07:44:19 <Cale> ozone: tree of depth 2 :)
07:44:26 <ozone> think of sound, where stereo sound == parallel composition of two mono channels
07:44:36 <blackdog> so it's really a list of sets, in a way - the order of the serial ops matter, but not the order of the parallel ones...
07:45:08 <ozone> ah, right
07:45:43 <ozone> or rather, a set of lists
07:56:06 * basti_ debated with a creationist during lunch and now needs to toy around with Yi-Emacs to cool down
07:56:47 <shapr> heh
07:56:57 <shapr> I'm a creationist, but I rarely debate.
07:56:59 <basti_> hardcore i tell you.
07:57:07 <basti_> o.0
07:57:20 <basti_> what a luck
07:57:56 <Muad_Dibber> I'm a debater, but rarely creative
07:58:01 * shapr grins
07:58:37 <ozone> blackdog: "hypermatrix", phear
07:58:46 <Lemmih> creationist == people who think God created earth and that evolution is completely wrong?
07:59:20 <shapr> I don't think that evolution is completely wrong, but I do think that God created the earth.
08:00:50 <ibid> creationist, in my mind, implies the opinion that creation happened literally as described in the bible and probably happened a few thousand years ago
08:01:20 <basti_> ibid: that was his persuation.
08:01:32 <vincenz> that's not the big issue, the big issue that biblists (or humanists in general) is that evolution says we are no more special than other animals
08:01:44 <basti_> so? =)
08:01:57 <vincenz> kinda conflicts with "we have a soul"
08:02:14 <vincenz> and then we were not created "in god's image"
08:02:17 <ibid> vincenz: biblists are not a subset of humanists; humanism is an arch-enemy of the (catholic) church
08:02:19 <boegel> shapr: you do ? then how do you explain stuff like war ?
08:02:29 <basti_> uh oh.
08:02:29 <vincenz> ibid: I know that was a set-union
08:02:49 <ibid> but i need to go to the bus, bbl (an hour)
08:05:34 <basti_> mmm wow this keybinding is much better now.
08:05:45 <basti_> this will be useful, i think
08:05:51 <jlouis> is this #haskell-religion?
08:06:04 <basti_> this is #haskell-backtotopic
08:06:05 <basti_> :)
08:06:08 <shapr> jlouis: hopefully, not :-)
08:06:22 <jlouis> I've always missed #haskell-politics too
08:06:46 <basti_> mm shapr did you hear what i was thinking loudly about structured editing lately?
08:06:52 <shapr> basti_: no?
08:07:13 <basti_> someone pointed out that structured editing would be way too slow to be feasible
08:07:30 <shapr> Someone said that here on #haskell?
08:07:30 * Lemmih mumbles something about the relationship between bad education and religion.
08:07:36 <basti_> yes.
08:07:42 <shapr> Lemmih: What's that relationship?
08:08:12 * basti_ mumbles about the relationship between "magic thinking" and bad education.
08:08:59 * basti_ curses himself for saying that bad bad word. Watzlawick is right in the end.
08:09:01 * Lemmih goes away before starting any flame-wars.
08:09:29 <basti_> the stupid thing is you can't NOT communicate at all
08:10:53 <tuomov> what's the purpose of basic education anyway? to brainwash you into the society.
08:11:00 <basti_> sure
08:11:07 <basti_> but there's many ways of education
08:11:22 <basti_> one is "believe, shut up". the other one is teaching people to open their eyes and have a look.
08:11:28 <tuomov> if the goal of education is to make you believe in the supernatural, then it is not bad in that sense
08:11:29 <shapr> Yeah, I like that second one.
08:11:32 <tuomov> although in other senses it may be
08:11:50 <shapr> I really like "Open your eyes and have a look, make up your own mind."
08:11:59 * basti_ nods
08:12:15 <basti_> its hard to be a good programmer without that way of thought.
08:12:17 <tuomov> basic education tends to be the former
08:12:47 <earthy> um
08:13:07 <earthy> is that qualifier `basic' necessary in that statement? :)
08:13:12 * shapr grins
08:13:13 <basti_> -g-
08:13:29 <tuomov> well, university at least is supposed to make you think.. although that is no longer always the case
08:13:45 <basti_> ohh sht, i forgot to buy salami.
08:13:47 <basti_> gna
08:13:56 <earthy> basti: substitute hame
08:13:58 <earthy> ham, even
08:14:01 <basti_> mmmk
08:14:12 <earthy> (it won't be quite as tasty, but you'll still have food)
08:14:16 <tuomov> but comprehensive school is purely about showing stuff into your head so you can become a wage slave
08:14:32 <basti_> not that the "stuff" taught would be of any use
08:14:38 <tuomov> religion ->Â politics loophole!
08:15:02 <basti_> in germany you learn for example, debating literature in 5 different perspectives or so
08:15:04 <earthy> tuomov: ever read Aldous Huxley's `A Brave New World'?
08:15:11 <tuomov> no
08:15:13 <basti_> (called "history", "sociology" etc. ;)
08:15:16 <tuomov> I guess I should
08:15:18 <earthy> go and do
08:15:21 <basti_> nice book
08:15:43 <earthy> I found it scarier than `1984'
08:15:50 <basti_> i found neither scary
08:15:56 <tuomov> I haven't even read 1984..
08:16:04 <kaol> @yow
08:16:05 <lambdabot> How many retired bricklayers from FLORIDA are out purchasing PENCIL
08:16:05 <lambdabot> SHARPENERS right NOW??
08:16:20 <earthy> but the premisse is that you *want* to do that to people, for the betterment of society
08:16:22 <basti_> 1984 has some of the most impressive passages about freedom in all the literature i read
08:16:38 <tuomov> the only orwell book I've read is homage to catalonia..
08:17:12 <tuomov> I got too long a backlog of books to read..
08:17:17 <basti_> hmm
08:17:23 <earthy> basically, modern society cannot function at its current level of productivity if not for wage slaves
08:17:40 <basti_> shapr: do you think it would be healthier fo yi-emacs to have several lexers or just one that does it all?
08:17:46 <earthy> and you do *not* want wage slaves to think too deeply, for that may well disturb the productivity
08:17:51 <tuomov> modern society is overproductive in many areas
08:17:55 <tuomov> who needs all the materialist junk?
08:18:06 <kaol> earthy: surely you mean profits, not productivity?
08:18:06 <earthy> the wage slaves that consume it. :P
08:18:14 <basti_> i think this is a very complex topic this is not at all debateable sensibly.
08:18:19 <tuomov> because they have no other live than to produce and consume
08:18:35 <shapr> basti_: I don't know. I do know I'm used to dealing with nested keymaps the way emacs already does it. I don't know if that means it's better or worse.
08:18:53 <basti_> i didnt say i dont want to nest keymaps.
08:18:55 <basti_> ;)
08:19:01 <basti_> I'm just talking about lexers -g-
08:19:03 <kaol> @vixen I'm bored.
08:19:04 <lambdabot> what can I do to un-bore you?
08:19:05 <earthy> tuomov: ah, but that's just it. what life do you want people to lead? people *must* produce in order to consume and people *must* consume in order to live
08:19:17 <earthy> so, why not optimize that process
08:19:19 <shapr> basti_: What's the difference?
08:19:35 <basti_> shapr: well one lexer could interpret different keymaps
08:19:44 <earthy> but that implies taking away free choice
08:19:47 <tuomov> there are certain necessities that must be produced, but consumerism is not good
08:19:48 <basti_> the keymap could be part of the state, or part of the lexer
08:20:05 <earthy> (and now we get back to religion: most religions state that you *have* free choice, but that it is your duty to use it well)
08:20:11 <tuomov> a very small portion of people work on producing those necessities
08:20:23 * shapr has the free choice to write code!
08:20:46 <earthy> shapr: but would you, if people wouldn't trade you for it so you can get yourself fed?
08:20:46 <tuomov> free choice is an illusion.
08:21:03 <tuomov> or so I tend to think
08:21:03 <shapr> earthy: Definitely.
08:21:04 * basti_ fears he kicked loose a debate.
08:21:08 * earthy is reminded of `time is an illusion, lunchtime doubly so'
08:21:20 <shapr> I wrote code before I got paid for it. I write code for free. I write code because I enjoy it.
08:21:21 <earthy> shapr: and starve doing it.
08:21:26 <earthy> ?
08:22:33 <shapr> Yes, I have gotten extremely hungry while writing code :-)
08:22:33 <kaol> @vixen What should I code?
08:22:33 <lambdabot> maybe you should :)
08:22:33 <shapr> But my approach is to continually develop two skills, one that pays well, and one that I love.
08:22:33 <tuomov> People like doing things. People will do even not so nice things when they really need to be done and there's no one else to command to do it.
08:22:33 <basti_> are we talking about sex now?
08:29:03 <shapr> Actually, one that I'm good at, and one that I love. In my opinion, I am not good at programming, but it is what I love to do.
08:29:03 <jlouis> @vixen what about sex?
08:29:03 <lambdabot> i dunno, what about?
08:29:03 <earthy> hm.
08:29:03 <shapr> So when I can't do the thing I love, I do the thing I'm good at so I don't starve.
08:29:03 <shapr> How do you do it?
08:29:03 <jlouis> We need a perversion plugin for vixen I think ;-P
08:29:03 <earthy> what's the thing you're good at then?
08:29:03 <shapr> @vixen perversion?
08:29:03 <lambdabot> Uh-huh
08:29:03 <jlouis> definitely need that module
08:29:11 <earthy> you seem to support yourself doing programming, right?
08:29:11 <boegel> @vixen titty's !
08:29:11 <lambdabot> Guys who can speak latin really turn me on.
08:29:15 <boegel> mwoeha
08:29:15 <shapr> earthy: I think creativity is my only real saleable talent. Creative art in the form of writing mostly, but some visual.
08:29:15 <shapr> Yes, I do support myself doing programming.
08:29:15 <shapr> tuomov: I think you're right.
08:29:47 * boegel thinks that if shapr doesn't consider himself good at programming, boegel isn't worth anything
08:29:47 <shapr> How about, 'I'm not naturally good at programming, but I am naturally good at being creative.' ?
08:35:40 <shapr> I have to work hard to be a good programmer, I don't have to work at all to be creative.
08:35:40 * boegel would love to be more creative
08:35:40 <basti_> i think creativity is very important in programming
08:35:40 * earthy nods
08:35:40 <basti_> plus, a certain kind of memory
08:35:40 * earthy nods
08:35:40 <tuomov> I'd also like to be more creative..
08:35:40 <earthy> plus, a certain kind of rigor
08:35:43 <basti_> intelligence not that much, but its also important
08:35:43 <shapr> I'd like to be less creative, please!
08:35:43 <basti_> hehehe
08:35:43 <boegel> plus being afraid to go outside and meet people :D
08:35:43 <earthy> you spawn too many ideas and don't have time to catch up? :)
08:35:43 <shapr> boegel: haha!
08:35:43 <shapr> earthy: yes!
08:35:43 <nlv11757_> money is making me doubt whether i should pursue an academic career (if im good enough) or pursueing a business career
08:35:43 <basti_> boegel: indeed.
08:35:43 <boegel> shapr: create an idea wiki or something like that
08:35:43 <tuomov> if you have even the slightest doubt, go academic
08:35:43 <shapr> boegel: I've already got one.
08:35:43 <boegel> tuomov: that's what I'll try
08:35:43 <tuomov> I went to business and hated it. Now I'm going back to uni
08:35:43 <vegai> you'll probably benefit most if you have experience from all
08:35:43 <boegel> at least try and get a Phd, I'll see from there-on
08:35:43 <nlv11757_> tuomov, i'd like that but i dont know if im good enough to do it and stuff
08:35:43 <earthy> nlv11757: money is a bad motivator
08:35:43 <earthy> at least for me it is
08:35:43 <basti_> i do not see buisiness being promising at all
08:35:43 <shapr> Ideas are no good if they distract you from implementing earlier ideas.
08:35:43 <tuomov> nlv11757_: you won't know if you dont' try
08:35:43 <vegai> earthy: better than nothing, eh :P
08:35:43 <tuomov> nlv11757_: and it'll keep nagging at you
08:35:43 <tuomov> and I'm talking from experience
08:35:43 <earthy> vegai: as long as I have enough of it to eat I really don't mind too much
08:35:43 <boegel> tuomov: that's what Im trying to avoid...
08:35:43 <boegel> but does anyone know what a Phd has as benefits over having none at all ?
08:35:43 <vegai> boegel: larger paycheck? :P
08:35:43 <earthy> I should restate that: as long as I have enough money so that I don't have to continually fret over having enough of it, I don't mind
08:35:43 <tuomov> no..
08:35:43 <boegel> besides the title (which is kind of a turn off for me)
08:35:43 <basti_> shapr: i think, with state being kept in the "state" part not in the lexer choice, it would be higher level, and thus better accessible from the outside, btw.
08:35:43 <tuomov> having more fun!
08:35:43 <basti_> (yi-emacs)
08:35:43 <boegel> vegai: that depends... :)
08:35:43 <tuomov> that's the only reason for doing a phd
08:35:43 <earthy> boegel: there are none, *unless* you want to go into academia
08:35:43 <nlv11757_> boegel, you are allowed to teach your children at home!!!
08:35:43 <shapr> basti_: sounds good to me.
08:35:43 <shapr> basti_: go for it! :-)
08:35:43 <vegai> one motivation for getting a PhD for me would be that there wouldn't be so much need to prove myself anymore
08:35:43 <earthy> where it really is a prerequisite these days
08:35:43 <basti_> shapr: thats just hermeneutics you know
08:35:43 <vegai> so one could relax a bit
08:35:43 <basti_> shapr: if i tell someone who understands, i'll understand my own thoughts better
08:35:43 <shapr> basti_: Who's Herman? ;-)
08:35:43 <basti_> -g-
08:35:43 <earthy> Herman was a cow. :P
08:35:43 <earthy> bull, actually
08:35:43 <shapr> I'd want a PhD only if I was guranteed to learn better/faster/something that way.
08:35:43 * boegel would go for a Phd because that would help him in seeing the world
08:35:43 <nlv11757_> earthy, i dont care that much about money, working on stuff that is related to D.'s compiler would seem very cool, but you have to be good i think
08:35:43 <shapr> Which is somewhat true, you get paid to sit around and thing.
08:35:43 <shapr> think
08:35:43 <tuomov> boegel: that's part of the having more fun..
08:35:43 <boegel> tuomov: I like that part
08:35:43 * basti_ likes to get his abilities acknowledged
08:35:43 <tuomov> I should start looking for a flat..
08:35:43 <basti_> not like parents do... "whats those letters?"
08:35:43 <boegel> also, I would earn enough money to get me and my gf started on our own (if she has a job aswell that is :) )
08:35:43 <earthy> nlv11757: you mean EHC?
08:35:43 <earthy> that's Atze's playground
08:35:43 <earthy> really
08:35:43 <nlv11757_> ow ok
08:35:43 <nlv11757_> well, something in that line for example.
08:35:43 <boegel> basti_: yeah, I tried letting my mom to read my thesis draft... that was a big no-no
08:35:43 * shapr goes to unicycle!
08:35:43 <basti_> -g-
08:35:43 <earthy> there's always more to explore
08:35:43 <boegel> "what's an algorithm ? can you eat it ?"
08:35:43 <basti_> hehehe
08:35:43 <boegel> well, it wasn't like that actually, but still, not a good idea
08:35:43 * basti_ has this uncertain feeling of living in an ivory tower now and then
08:35:43 <nlv11757_> hehe anyways, back to focussing at first finishing my thesis project lol
08:35:43 <earthy> good luch
08:35:43 <earthy> luck even
08:35:43 * earthy is getting hungry
08:35:43 <basti_> good lunch? :)
08:35:43 <boegel> that's why I would like someone in here to read my thesis draft and comment on it (besides Itkovian, because he's part of the official team already)
08:35:43 <basti_> lol
08:35:43 <earthy> time to go shop for food. ;)
08:35:43 <boegel> basti_: so do I !
08:35:43 <vegai> I took some courses in the English departement, and wrote a paper about programming languages. I tried to write it for 5-year olds
08:35:43 <earthy> vegai: that's hard
08:35:43 <vegai> and they apparently understood nothing of it
08:35:43 * earthy has tried to teach programming to 12 year olds
08:35:43 <basti_> the 5 year olds or your parents? :P
08:35:43 <vegai> it's my fault, of course. Should have tried something easier
08:35:43 <earthy> they have a hard time understanding abstraction
08:35:43 * boegel doesn't even try to teach
08:35:43 * earthy succeeded... with some
08:35:43 <vegai> the readers were in their 20s and 30s
08:35:43 * boegel leaves
08:35:43 <vegai> I would've thought that the teachers would've understood the basic concepts, but no..
08:35:43 <boegel> bye !
08:35:45 <basti_> cu boe
08:35:59 <Lor> vegai, can we see it?
08:40:24 <earthy> programming is not the easiest of occupations to understand
08:40:24 <earthy> or explain
08:42:32 <vegai> Lor: no.
08:42:32 <basti_> well seeing that other buisinesses live of what we construct... definitely not
08:42:32 <basti_> i mean, theres a data processing company in germany. They JUST do additions and backups.
08:42:32 <basti_> (and some data transfer and maintanance)
08:42:32 <earthy> sounds like SAP. :P
08:42:32 <basti_> no datev. SAP actually delivers software.
08:42:32 <basti_> datev just keeps your books... in the sense of the word "keeps"
08:42:32 <basti_> they dont do anything. they just add the numbers for taxation and keep backups.
08:42:32 <basti_> thats what earns their money
08:42:32 <basti_> (since you're obliged to keep the books like 20 years or something)
08:42:32 <basti_> well they deliver software too but it's marginal. mainly data entry and annoyance tools.
08:42:32 <earthy> 20 years is long
08:42:32 <tuomov> doing that sorta work would be absolutely mind-numbing
08:42:32 <earthy> for .nl for tax purposes it's 5 years
08:42:32 <tuomov> I'd rather dig ditches
08:42:32 <basti_> i think EVERYTHING is better than financial data entry.
08:42:32 <earthy> and one of the bigger dataprocessing employers in .nl is... *tada*... the tax service. :)
08:42:32 <basti_> but they dont do the entry. they just have people pay for keeping the data.
08:42:32 <basti_> oh and they lie for you.
08:42:32 <basti_> or, they make your books look good. whether they are or not.
08:42:32 <basti_> actually noone can check since noone understands bookkeeping besides bookkeepers. but i think thats purpose.
08:42:32 <earthy> bookkeeping isn't hard
08:42:32 <tuomov> like law..
08:42:32 <earthy> it's annoying
08:42:32 <basti_> that too.
08:42:57 <basti_> but i never understood what they mean with seperating "active" from "passive" "accounts"
08:43:13 <tuomov> It's written so cryptically that nobody understands it, but everyone thinks lawyers do and that's the point
08:43:13 <basti_> i mean someone told me what it means, but it didnt make sense.
08:43:21 <basti_> tuomov: yup.
08:43:55 <basti_> actually lawyers are my no. 1 ranted upon minority.
08:45:02 <earthy> basti: passiva and activa are not passive and active. :)
08:45:13 <basti_> oh they are called like that in english too? k
08:45:29 <earthy> no, they're called like that in dutch too. :)
08:45:33 <basti_> ahh.
08:45:40 <basti_> i know theyre not passive and active
08:47:04 <earthy> there's no direct translation IIRC
08:47:12 <earthy> anyway, I really should go shop for food
08:47:17 <earthy> cu
08:47:24 <nlv11757_> later
08:47:39 <basti_> cu
08:47:40 <nlv11757_> (shouldnt women do that job :P)
08:47:46 <basti_> lol
08:47:55 <nlv11757_> thats why i only eat microwave food
08:47:58 <nlv11757_> i refuse to cook
08:48:11 * basti_ is still pondering where to put the pickaxe for now actually implementing the first yi-emacs mode thing
08:48:21 <basti_> cooking is cool
08:48:30 <basti_> if you know what you're doing
08:48:39 <nlv11757_> sure, when it involves chocolate and women
08:48:41 <nlv11757_> hehe
08:48:52 <basti_> cooking women? o.0
08:48:55 <tuomov> I've also been cooking a lot since I've not had a job
08:49:37 <nlv11757_> i do have this proud feeling taking my meal out of the microwave every time lol
08:49:53 * basti_ sighs
08:49:53 <basti_> cooking is just like programming
08:50:10 <tuomov> a bit more handwavy..
08:50:19 <basti_> yes not as exact
08:50:30 <basti_> but sometimes you get catastrophes just as annoying.
08:50:30 <basti_> ;)
08:50:30 <Philippa_> there's no such thing as correctness in cooking
08:50:43 <Philippa_> well, beyond not giving yourself food poisoning
08:50:43 <basti_> thats right
08:51:08 <nlv11757_> noj, rather i have a solid plan for the coming future; living at home where my mom cooks :D
08:51:08 <basti_> but i mean... i get the same feeling of "flow" as in when a program runs
08:51:35 <basti_> shammah: ?
08:51:35 <Philippa_> yeah, cooking and hacking have things in common
08:52:03 <Philippa_> I need more effort to make sure I can hack safely than cook safely though
08:52:04 <tuomov> I'm not really at the hacking level at cooking, though. I just follow instructions.
08:52:10 <basti_> hehehe
08:52:18 <basti_> cooking is a thing anybody understands
08:52:18 <tuomov> kinda like doing programming assignments.
08:52:24 <Philippa_> yeah, I'm just as bad if in a different kind of way
08:52:26 <nlv11757_> you dont do instructionlevel parallelism in your cooking tuomov ? :D
08:52:31 <Philippa_> eg I use prepackaged sauces, but mix stuff in
08:52:53 <Philippa_> we have a cheddar+tomato+basil sauce we use for pasta a lot as a result
08:53:15 <basti_> oh i do that with frozen pizzas
08:53:58 <basti_> spikes up the taste ("use" value to speak with marx) about 100%
08:53:58 * Philippa_ nods
08:53:58 <nlv11757_> i sometimes pore some ketjap over my microwave meal for variation
08:53:58 <vincenz> cooking and hacking do not have things in common
08:56:07 <vincenz> with cooking you're stuck cleaning all the dishes
08:56:08 <Philippa_> I'd add toppings to mine but I CBA to cook them usually - having a vegetarian partner and few tuits means you don't eat much meat
08:56:08 <basti_> vincenz: do you want to have a look at my ~? ;)
08:56:08 <vincenz> besides, there's a lot more pressure (get this finished before that is done)
08:56:08 <vincenz> basti_: your?
08:56:08 <basti_> "home directory"
08:56:08 <basti_> abbrev ~ in the unix world
08:56:08 <vincenz> oh
08:56:08 <basti_> there's some serious need to clean that.
11:23:07 --- topic: 'Haskell... really.'
11:23:07 --- topic: set by SyntaxNinja on [Wed Apr 27 10:16:11 2005]
11:23:07 --- names: list (clog r3tex astrolabe _JusSx__ Oejet wilx SamB tic polli arjanb SyntaxNinja _Anders araujo sond basti_ Paltas beschmi Philippa_ Muad-AFK dcoutts vidvandre atom-z lisppaste2 CosmicRay iblechbot cptchaos foxkiki Cozminsky ulph ^buggler^ tintin Si\ jesse99 kpk lambdabot mflux theorbtwo metaperl_ reffie hefner Khisanth isomer dan2 perdix thebug CLxyz qmole PerlJam Maddas chucky esap norpan ex_nor eno-away cpage nailbiter Jerub waltz Tou[t]qen)
11:23:07 --- names: list (emu shapr sjanssen shawn_ cognominal gabor a5 rtega Lor XTL dbremner xerox skylan Cale sqrt juhp dons icb sylvan Matt-W integral Function jak autrijus KrispyKringle tbarkley tromp scw nibro_afk mattam aj eiz d` dcoutts_ asmodai cathper tuomov edwinb vincenz smott wli gdsx Taaus kosmikus tumm wagle kolmodin creichen cwest vegai shrimpx calvin_ sorje noj ozone ksandstr johs keverets ibid Squider aheller autark-jp integral|ZzZzz mornfall Lunar^)
11:23:07 --- names: list (musasabi earthy isomer_ ned jlouis Igloo chaven kaol cmeme zamez shammah gzl mauke rossberg lispy djw jiing df_)
11:23:13 <dcoutts> shapr, we're actually using WordPress which is blogging software but it can do static pages too which is why we're using it
11:23:40 <shapr> I'd use moin in that situation, because that's what I'm familiar with.
11:23:55 <shapr> Too bad we don't have a spiffy Haskell webdev system yet.
11:24:01 <dcoutts> we use the blogging stlye stuff for our news / anouncements and FAQ's and things
11:24:01 <shapr> Then I could fire moin.
11:24:17 * xerox looks forward to Flippi
11:24:21 <shapr> Oh, Flippi is nearing another release, with a much improved plugin architecture.
11:24:25 * shapr bounces cheerfully.
11:39:43 <sjanssen> is there a hashtable implementation that isn't in the IO monad?
11:42:10 <beschmi> i've got a version of HashTable that's in the ST Monad lying around somewhere
11:42:45 <stepcut> shapr: I won't be able to get my article done for TMR issue 2 because I found a grevious bug in my library :)
11:43:17 <shapr> aww
11:43:29 <sjanssen> beschmi: you ported the Data.HashTable to ST?
11:43:37 <beschmi> yes, but I ended up using Data.Map since it was faster for me
11:43:56 <stepcut> shapr: but, it will be twice as good when I write it for issue 3 :p
11:43:56 <shapr> stepcut: ok, I'll put you into the IssueThree page.
11:44:00 <shapr> stepcut: yay!
11:44:17 <stepcut> I need to write a variant of hGetContents :-/
11:44:49 <beschmi> sjanssen: http://www.stud.uni-karlsruhe.de/~ry102/STHashTable.hs
11:45:02 <sjanssen> beschmi: cool, thanks
11:49:35 <a5> stepcut: i did that. the semantics aren't perfect
11:49:59 <a5> i mean the semantics of the default hGetContents
11:50:47 <raver> hi all
11:53:22 <beschmi> sjanssen: just noticed that i changed some parameters in there for testing, there is a new version without these changes at the same URL now
12:01:34 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/ghc/survey/start.cgi"]' by shapr
12:02:40 <basti_> discrete mathematics homeworks unrule. but i 0wned them now.
12:02:51 <a5> why can i have overlapping instance declarations but not duplicate instance declarations? i just want it to choose the first one where the constraints work out...
12:03:34 * basti_ has to admit he doesn't fully understand the question
12:04:29 <a5> like i have "(Monad m, MonadPlus n) => MPlusLift m n" and "(MonadPlus m, Monad n) => MPlusLift m n"
12:05:07 <a5> it allows "Monad n => MPlusLift Maybe n" to coexist with either of the above, but i can't have both of the above
12:05:20 <basti_> hmm
12:05:34 <shapr> Happy Birthday #haskell! "Registered: 3 years 1 day (20h 43m 16s) ago"
12:06:02 * shapr boings
12:06:06 <basti_> shapr: cancer comes to mind... (145 people in 3 years)
12:06:32 <shapr> I'd rather grow up than die down!
12:06:50 <basti_> cf. various c++ programs? :)
12:06:57 * shapr grins
12:07:55 <PerlJam> a5: I believe that there's an extension to ghc that will do what you want.  Don't remember the details off hand though.
12:10:49 * arjanb remembers that about 80 people on average were here a year ago
12:11:33 <a5> PerlJam: thanks ... any idea where i would find it?
12:11:55 <PerlJam> a5: probably somewhere on haskell.org
12:14:40 <dan2> a5: is MonadPlus a subclass of Monad?
12:17:09 <a5> dan2: yes i think so why
12:18:11 <a5> it seems like i spend all my time redefining ways for various monads to interact with each other
12:18:24 <a5> standard monad transformers rarely fit the bill
12:18:39 <dan2> a5: why don't you just fix it so it always gets input the right way?
12:19:10 <dan2> sounds like a design error to me
12:20:32 <a5> design error in the standard libs? well i don't know
12:21:04 <a5> the problem is that "ErrorT e m" has its own MonadPlus structure, regardlesss of m
12:21:17 <a5> but i want to use the MonadPlus structure of m since it is a MonadPlus in my case
12:21:39 <a5> *shrug* i think most peoplee would prefer the former behavior though
12:21:45 <a5> people even
12:23:07 <a5> but i also have this feeling that a language that uses linear types (Clean?) might be ... cleaner
12:27:36 <a5> i feel like i'm programming with 's' and 'k' combinators when i compose monads
12:27:57 * shapr shoots an arrow at a5 
12:28:44 <a5> you disagree?
12:29:21 <shapr> Nah, I don't know how you feel better than you do :-) I was just suggesting arrows if you want a higher level structure.
12:29:33 <Paltas> a5, he may have a degree. :)
12:30:00 * basti_ brings yi-emacs closer to doing something useful
12:30:13 <shapr> w00
12:30:17 <a5> shapr: you're saying that arrows make monad composition easier?
12:30:40 <a5> it seems like you'd run into the same problems
12:30:50 <shapr> Nah, I'm saying you might enjoy arrows since they can do some stuff monads can't.
12:35:08 <shapr> Arrows are easier to compose as well.
12:35:26 <boegel> any dutch speaking people in here?
12:35:33 <shapr> ik begrijp het niet!
12:35:39 * shapr grins
12:36:00 * boegel laughs
12:38:01 <basti_> heh
12:38:17 * basti_ only speaks some allegedly dutch words ;)
12:38:22 <jlouis> jeg begriber det ikke?
12:38:51 <basti_> "waschverzachter" and "versnelling"
12:41:18 <boegel> basti_: wasverzachter :)
12:41:41 <boegel> jlouis: that's not dutch, is it ? :) but I think you asking "do you understand me"
12:41:44 <boegel> am I right ?
12:42:06 <basti_> ahh
12:42:17 <basti_> but it is authentic yes?
12:42:29 <basti_> i kinda supposed it was a joke.
12:42:39 <Lemmih> boegel: It's danish.
12:43:01 <boegel> basti_: wasverzachter is the stuff you put in a washing machine to soften your clothes :)
12:43:06 <basti_> yes i know
12:43:10 <boegel> Lemmih: and what does it mean ?
12:43:24 <boegel> btw s/you/you'red
12:43:26 <boegel> -d
12:43:28 <boegel> (argh)
12:43:36 <basti_> it sounds just like that to someone speaking german, but it has kind of a funny sound
12:43:45 <basti_> like... fake dutch
12:44:24 <boegel> nobody else speaks Dutch ? I know tromp does, but he's not active (and probably hasn't got time either)
12:44:25 <basti_> http://www.tenaciousd.com/fhg.html < did i ever mention THAT on here? [explicit, but funny as hell!]
12:44:39 <basti_> i dont. my mom was born dutch, but she never taught me
12:44:53 <boegel> basti_: that's a real shame, why didn't she ?
12:45:08 <Lemmih> boegel: (without any context) "I don't understand it?"
12:45:43 <boegel> basti_: I know that one, it's fantastic :)
12:46:00 <basti_> well actually she was only born there, juristically she was stateless, and later became german... she talked dutch only until she was 10 or something
12:46:11 <basti_> [do you say "stateless"?]
12:46:56 <boegel> basti_: do you know who's singing the song ?
12:47:13 <basti_> actually no. but they're mentioned in the end
12:47:57 <boegel> Jack Black, he does movies too (like the fantastic School of Rock)
12:48:12 <basti_> ahh.
12:48:25 <basti_> i heard about that movie
12:48:44 <boegel> you should see it :) it's kind of childish, but Black is just fantastic in it :)
12:49:09 <basti_> okay i will... probably it will run on tv some day...
12:49:18 <boegel> don't wait until then dude
12:49:27 <basti_> never saw it in our video store
12:49:44 <basti_> but never searched for it too
12:51:19 <boegel> you should :) it's funny (and educational)
12:51:35 <basti_> educational yes?
12:51:38 <basti_> -.o
12:53:30 <boegel> well, kind of :) musically
12:59:50 <boegel> hey Itkovian
13:08:00 <boegel> hi skew
13:09:21 <TFK> Can it be? The next language from Sun to have first-class functions?
13:10:06 <basti_> will it still be brain damaged?
13:10:08 <boegel> TFK: which language ?
13:10:18 <TFK> Fortress
13:11:01 <basti_> Guy Steele leads a small team of researchers in Burlington, Massachusetts, who are taking on an enormous challenge -- create a programming language better than Java.
13:11:05 <basti_> -.-
13:11:10 <TFK> http://lambda-the-ultimate.org/node/view/673 <--- I don't claim to understand half of it, though :-/
13:11:12 <Oejet> lol
13:11:15 <vegai> enormous challenge
13:11:27 <TFK> Can't blame them for believing their own hype.
13:11:30 * Oejet laughs out loud.
13:11:40 <TFK> Meanwhile, it's one of the most widely used languages.
13:11:42 * boegel doesn't see the joke
13:11:47 <basti_> it is.
13:11:51 <basti_> but its still not a good language
13:11:58 * TFK shrugs
13:11:59 <basti_> cobol was widely used too
13:12:08 <basti_> its successfull, not good.
13:12:12 <basti_> there is a difference
13:12:28 * TFK dunnos COBOL
13:12:39 <basti_> you should have a look
13:12:40 <Oejet> Java (1.4 at least) feels like assembler.
13:12:43 <boegel> imaginary numbers ? cool
13:13:11 <Oejet> Compared to something like Haskell of course. ;-)
13:13:36 <boegel> TFK: COBOL is horrible... placing a character on column x has a different meaning than placing it on column y (if x \= y)
13:13:39 <tic> Oejet, compared to Python, too.  Developing in Java feels like writing code with mittens on.
13:13:54 <TFK> We may have all the debates we want about how Java sucks (or not). But look at your favourite language (which may or may not be Haskell) and compare.
13:14:22 <basti_> from a design standpoint, haskell is at least 7 of 10 points.
13:14:53 <basti_> from the usefullness (buisiness applications) standpoint it might be close to 0
13:14:55 <vegai> boegel: better language than Java? Enormous challenge?
13:14:57 <basti_> java is the other way round
13:15:05 <vegai> nudge nudge
13:15:20 <tic> I think Python has a higher yield than Haskell, partially because of the "kitchen sink included" and it's acquired some cool things lately, but Haskell still feels cleaner.  But I have a hard time getting productive in it.
13:15:31 <TFK> Java has garbage collection. *ducks*
13:15:32 <boegel> vegai: well ok, the enormous challenge part is over the top, but I don't think Java is such a disaster
13:15:54 <boegel> TFK: it does :) *doesn't duck*
13:15:54 <basti_> java is not a disaster because it followed C++
13:16:09 <vegai> boegel: not if you look at the big picture. Personally, I don't like it
13:16:15 <boegel> basti_: the first PL we ever learned at uni is Java
13:16:22 <basti_> boegel: is that good or bad?
13:16:22 <Muad_Dibber> garbage collection ++
13:16:25 <TFK> Anyway, Fortress is looking very nice. You may as well read the PDF and explain to me what it's all about :D
13:16:27 <boegel> we don't even get to C/C++ until the 3rd year (of 4)
13:16:37 <tic> boegel, at Chalmers we were taught Haskell first, and then Java...  probably because of Hughes :)
13:16:38 <dan2> boegel: universitys don't teach you how to program, they teach you about programming
13:16:39 <basti_> thats definitely good.
13:16:40 <dan2> much different
13:16:55 <vegai> TFK: it's what Microsoft will clone in 5 years
13:16:58 <boegel> dan2: point taken
13:16:59 <Muad_Dibber> if you want to learn programming, go to highschool college :P
13:17:04 <TFK> vegai, ahahahaha.
13:17:05 <dan2> you learn how to program on the job, most cases
13:17:08 <Muad_Dibber> Fortress?
13:17:15 <boegel> basti_: I don't know really, depends :)
13:17:16 <TFK> http://lambda-the-ultimate.org/node/view/673
13:17:49 <TFK> Does "type inference; parametrized types" mean something like what Haskell has?
13:17:56 <basti_> probably.
13:18:12 <basti_> just, when the java guys think about it, probably something like C will come out ;)
13:18:13 <boegel> actually, the first thing I ever did at uni was working in vi, that was pretty scary
13:18:23 <basti_> with "int" and "char" being fcc's etc. ;)
13:18:30 <basti_> vi IS scary.
13:18:33 <basti_> ;)
13:18:36 <boegel> when I typed something wrong, I just reached for the backspace button, and then all kinds of strange things started happening :)
13:18:51 <TFK> Our Uni's editor is Emacs.
13:19:10 <basti_> my uni doesn't have an own editor.
13:19:17 <tic> vi rules.
13:19:22 <Oejet> emacs rules.
13:19:22 <tic> or well, vim.
13:19:32 <Oejet> tic: :-P
13:19:33 <basti_> no holy wars
13:19:39 <tic> yeah, I'll refrain.
13:19:40 <basti_> we had one of these this afternoon, almost
13:19:42 <TFK> Not even about Java?
13:19:47 <skew> hi boegel
13:19:53 <skew> ED!
13:19:58 <basti_> thats not a war
13:20:02 <Oejet> TFK: Nah, that would be a massacre. ;-)
13:20:06 <tic> funny when I sat at another person's computer which started Emacs as the standard editor, and I started doing dd, ZZ and all that :)
13:20:10 <basti_> java doesnt fight back
13:20:10 * TFK wonders about the meaning of contracts
13:20:10 <basti_> =)
13:20:25 <TFK> Yup, it doesn't have to.
13:20:31 <tic> TFK, non-formal interfaces á Python?
13:20:51 <Oejet> TFK: Yup, it just eats up all the garbage we throw at it.
13:21:06 <TFK> The non-formal interfaces lead to duck-typing, I think. How will that work in a statically typed language?
13:21:19 <TFK> Hmmm, will it actually be statically typed?
13:21:31 <skew> http://www.gnu.org/fun/jokes/ed.msg.html
13:21:35 <tic> there's some other language that does this by having a specific type that supports duck typing.
13:21:51 <tic> a python-look-a-like, but isn't python. the name slips me at the moment...
13:21:57 <skew> tic: like Dynamic, more or less?
13:22:13 <TFK> Ruby, Boo (a Python derivative, sort of)?
13:22:33 <skew> I know Ruby has no static types
13:22:50 <vegai> tic: that prothon thingie?
13:23:03 <TFK> What are "dimensions", then? Never heard of those in a PL context.
13:23:25 <tic> vegai, yah.
13:23:52 <basti_> checked array bounds? :)
13:23:57 <tic> wonder if I should _really_ learn VIM this summer..
13:24:02 <skew> TFK: monads? Let's go to the "State" dimensions for a bit, then step through this "runCont" portal into the "Cont" dimension
13:24:16 <TFK> Err, sorry?
13:24:38 <skew> You know, like monsters from the fifth dimension and stuff
13:25:07 <mflux> tfk, I believe it refers to Meter * Time = MeterTime
13:25:17 <mflux> or rather s/Meter/Distance/g
13:25:23 <mflux> or any other units ;)
13:25:28 <TFK> o_O
13:25:36 <Oejet> Explicit units are cool.
13:25:38 <basti_> isnt that sugar for normal types
13:25:39 <basti_> ?
13:26:33 <mflux> it would seem so, but if you have 4 types, would you need to have 4!*3!*2!*1! 'sum types'?
13:26:48 <mflux> hm, although you could of course compose the types, so I guess not
13:26:49 <skew> mflux: pretty neat, but I'd guess barely a tenth of an Oleg on the type-class hackery scale :)
13:27:03 <basti_> hmm.
13:27:57 <skew> Can everyone agree that the standard unit of difficulty of type class hackery should be the Oleg?
13:28:25 <pesco> Yes, and 1 Oleg should be pretty difficult.
13:28:39 <shapr> yeah, totally.
13:28:43 <skew> Like using c to measure speed
13:28:53 <pesco> Heh. Yes.
13:29:11 <shapr> something like "Wow, that typesafe shape code is worth half an oleg!"
13:29:19 <skew> or at least mach
13:29:36 <tic> What's Oleg?
13:29:45 <shapr> The Oleg.
13:29:47 <skew> He is a very clever man
13:30:02 <shapr> tic: http://okmij.org/
13:30:29 <skew> He does stuff like figuring out how to make Haskell mimic C++'s overloading resolution rules
13:30:33 <shapr> Oleg Kiselyov - http://c2.com/cgi/wiki?OlegKiselyov
13:30:50 <shapr> I once got an email from Oleg...
13:31:00 <pesco> Cool, what did it say?
13:31:07 <TFK> Sounds like an oligrach.
13:31:26 <shapr> He wanted to join the haskell-libs sourceforge project, and he included a short list of worthwhile things he had done, I guess so I would be persuaded to let him join.
13:31:27 <skew> I exchanged several mails when I was trying to put a fancy typeclass hack frontend on the JVM bridge
13:32:07 <shapr> Wow
13:32:07 <pesco> shapr: Which of course you didn't. ;-)
13:32:19 <shapr> pesco: Actually, I added him immediately.
13:32:23 * pesco laughs.
13:32:59 <shapr> Though at this point I'd rather move all of haskell-libs to some sort of HaskellForge with tighter connections to haskell.org
13:35:09 <shapr> skew: So it'd really be "that's half an oleg of code" when describing some intricate typeclass hackery?
13:35:24 <Muad_Dibber> ghci
13:35:24 <Muad_Dibber> ghc-6.2.2: not built for interactive use
13:35:28 <pesco> I think we just need a good infrastructure to  1. make libraries known  2. distribute them  and 3. make it cheap and safe to use them.
13:35:31 <Muad_Dibber> hmm, i'm missing something?
13:35:48 <pesco> Cabal and Hackage are doing most of that.
13:36:01 <shapr> Muad_Dibber: Are you using ghc inplace after building it?
13:36:13 <Muad_Dibber> what do you mean exactly?
13:36:18 <Muad_Dibber> wiht inplace i mean?
13:36:58 <shapr> It sounds like you've only build the first stage of GHC.
13:37:13 <pesco> I'd like to contribute to 3. with ECT.
13:37:15 <Muad_Dibber> so how t obuild the next stage then? :P
13:37:33 <Muad_Dibber> since i'm with gentoo, doing emerge ghc :P
13:38:42 <skew> shapr: I was thinking more "half an oleg of typeclass magic/type hackery". Maybe "that code rates a quarter Oleg". Oleg isn't particularly known for sheer volume of code, is he?
13:38:51 <TFK> Heh, Fortress will apparently use greek letters, too.
13:39:01 <shapr> skew: good point.
13:39:21 <skew> What is a good unit of code volume?
13:39:40 <boegel> TFK: scary
13:39:59 <shapr> I think an spj is a unit of research paper writing.
13:40:04 <shapr> A very large unit, mind you.
13:40:04 <TFK> Apparently, any ol' Unicode character will do.
13:40:26 <skew> MbJ - megabytes of Java, by analogy with megatons of TNT for rating significantly more powerful explosives?
13:41:01 <shapr> hmmm, interesting thought.
13:41:40 <Muad_Dibber> the point is
13:42:04 <Muad_Dibber> the tendens is towards having as much megabytes as possible (Java, xml)
13:44:19 <tuomov> How to calculate code mass index..
13:45:28 <shapr> I think I'd really want to calculate how much of the code is really doing something useful.
13:45:47 <shapr> Like, what percentage of the code has nothing to do with the problem the code solves?
13:45:49 <Muad_Dibber> How do you define that?
13:46:14 <shapr> I've heard it called the accidental difficulty versus the essential difficulty of a problem.
13:46:42 <Muad_Dibber> hmm
13:46:50 <Muad_Dibber> and how are those two defined? :p
13:46:52 <musasabi> actually usually in haskell very little of the code has to do with the actual problem.
13:46:53 <skew> Isn't that just the Kolmogorov complexity?
13:47:00 <shapr> Yeah, I just realized that.
13:47:07 <skew> and how much longer your program is, for the other bit
13:47:11 <shapr> Right, exactly.
13:47:38 <skew> I'm still trying to figure out just what Kolmogorov complexity has to do with the validity of induction
13:47:53 <basti_> :-o
13:47:58 <skew> like, the scientific kind with the philisophical debates around it
13:48:09 <shapr> I was impressed with the Curry-Howard page on wikipedia, it connected so much stuff together I'll be following references for weeks.
13:48:37 <xerox> @wikipedia Curry-Howard
13:48:41 <tuomov> wikipedia is nasty
13:48:43 <lambdabot> http://en.wikipedia.org/wiki/Curry-Howard
13:48:48 <shapr> tuomov: Addictive, you mean?
13:49:01 <tuomov> yes, for that reason
13:49:40 * musasabi goes to read
13:51:07 <shapr> The Curry-Howard page includes such highlights as, sequent calculus, Kolmogorov, Heyting algebras, intuitionistic logic, constructive logic, Peirce's law, and some other stuff.
13:52:19 <gzl> link chasing on wikipedia is addictive
13:52:47 <shapr> I also wish that people would sign their contributions so I can track down their homepages and find more connections.
13:53:21 <shapr> tromp's page is cool in that way, lotsa neat connections.
13:53:31 <Muad_Dibber> and so you can mark users as having only worthless connections :)
13:53:57 <skew> it might not be that hard to hack a wiki to put div tags with the author around all the text
13:54:07 <boegel> shapr: I think one of positive points of wikipedia is the anonimity
13:54:26 <shapr> Oh, I recently discovered origami math, I didn't know there was a folding math at all (except for protein folding).
13:54:33 <skew> or some kind of unobtrusive tag that gives you one of those little pop up things
13:54:46 <basti_> there's even knot algebra
13:54:59 <skew> There's that neat polyhedron that can bend a bit
13:55:01 <shapr> Yeah, I've been wondering if there's a generalization of knot theory and origami math.
13:55:15 <shapr> hiya pernod
13:55:22 <basti_> 2d knots?
13:55:29 <pernod> hiya shapr
13:55:31 <shapr> It would make sense that folding and knots would be connected.
13:55:42 * pernod is a newbie strolling around
13:55:44 <shapr> pernod: how's code?
13:55:58 <shapr> pernod: Looking for any particular information? Have any questions we can answer?
13:56:14 <pernod> Nope. I'll lurk and learn.
13:56:25 <shapr> basti_: Yeah, exactly.. 2D knots.
13:56:36 <pernod> But thanks anyway :)
13:57:29 <shapr> pernod: If you have any questions, feel free to ask.
13:57:47 <basti_> not much haskell theme right now?
13:58:26 <pernod> I will. Tonight I'm only exploring, but I've got some questions related to a tutorial that I'll ask when my mind is in code-mode.
13:58:33 <shapr> basti_: I'm exploring theories of folding in order to do typesafe Penrose Tiles in Haskell, that's my theme.
13:58:51 <skew> you'd better find some kind of algebra.
13:59:30 <basti_> ohh btw, penrose
13:59:34 <basti_> i thought about it...
13:59:50 <basti_> penrose tilings need backtracking (or are redundant) it seems to me
14:00:03 <skew> the way they are all curved around makes it a lot trickier than a grid.
14:00:05 <shapr> You mean to build penrose tiles?
14:00:12 <basti_> to build the tiling
14:01:06 <skew> Even my idea for doing a grid is based on something I think part of the HList internals does
14:01:38 <shapr> Oh hey, can you repeate it? or is it long enough that I should track down the logs?
14:01:59 <skew> no, it's pretty simple
14:02:21 <skew> so, rectangles are going to be composed horizontally or vertically into bigger rectangles
14:03:06 <shapr> Right.
14:03:16 <skew> the rectangle is something like a type constructor with four arguments describing the sides, just as a tuple (or list built of pairs) of the types of all the different connectors down that side
14:03:49 <skew> think like an IC where some pins are power, some ground, and others various sort of in/out data/clock lines
14:04:14 <skew> Make some class with fundeps that can concatenate two of these connector lists
14:04:29 <shapr> I started out with something like that, but I didn't see how to make it check for implied adjacency.
14:05:07 <skew> well, that's why I'm talking about composing rectangles of the same edge on the length where you stick them together
14:05:19 <skew> er, length on the edge
14:05:54 <skew> so every connection was made explicitly by some composition operation
14:06:25 <shapr> It sounds like a runtime check done at compile time.
14:06:28 <shapr> Will that really work?
14:06:44 * shapr hacks up some fundeps prototypes
14:06:45 <skew> sure, just use unification to make the types match
14:06:54 <shapr> huh?
14:07:10 <skew> like (a -> b) -> (b -> c) -> (a -> c) makes sure that the middle types of the two function arguments match up
14:07:38 <skew> it's a bit trickier because rectangles have sides and not just the ends being composed
14:07:41 <basti_> :-o
14:08:13 <skew> so the "top interface" to the slot analagous to (a -> c) has to be the concatenation of the top interface of a->b and b->c
14:08:22 <skew> same with the bottom side
14:08:49 <skew> But that's a negligble fraction of an oleg
14:09:01 <skew> trivial if you use HList, for that matter
14:09:36 <shapr> Obviously I need to read the HList paper first.
14:10:00 <skew> class CompPairLists a b c | a b -> c; instance CompPairList () b b; instance (CompPairList as b cs) => CompPairLIst (a,as) b (a,cs)
14:10:38 <shapr> I sort of understood that. Shocking.
14:11:08 <shapr> So, this is a lot like the BoundedList stuff in HaskellDB then.
14:11:13 <skew> it's just type level proglog, without backtracking
14:11:16 <shapr> Right, I see.
14:11:36 <skew> not that I know prolog
14:11:41 <basti_> prolog rules.
14:12:05 <skew> Unlambda was my first functional language, so it seems appropriate somehow that the Haskell typeclass system is my first logic language :)
14:12:21 * shapr grins
14:14:31 <basti_> how do you call this kind of hobby?
14:14:40 <basti_> using things for something they're not intended for?
14:14:46 <shapr> I call it hacking.
14:14:58 <basti_> hmmmk.
14:15:02 <basti_> :)
14:15:12 <shapr> "A cute hack" is an elegant or ugly but always unusual way of accomplishing the goal.
14:16:34 <shapr> If you read up on the history of the term, it started as a name for people who made furniture with an axe. You could have a usable chair in just a few minutes. The chair would never win awards for anything except useful functionality in the minimum amount of time.
14:17:22 <basti_> i know what "hacking" means
14:17:39 <shapr> Sorry, I'm used to talking to people who don't, I apologize :-)
14:17:49 <basti_> i was looking for something... maybe something starting with "anti" ;)
14:18:25 <shapr> I've noticed that the top end of ugly hacks wraps around to the bottom end of elegant solutions.
14:18:44 <basti_> hm
14:18:58 <basti_> maybe ugly hacks are elegant solutions in other contexts
14:19:43 <xerox> shapr, I did read the "You and your research" transcript today.. it is definitely worth it reading -- it makes you feel something.
14:20:03 <basti_> url?
14:20:36 <shapr> I think you're right. If you need the solution in the next thirty seconds before your boss goes on stage to give his talk, then any solution is elegant. But the solution found may not win any beauty prizes with your coworkers.
14:21:33 <shapr> basti_: http://lambda-the-ultimate.org/node/view/668
14:23:17 <shapr> dbremner recommend it to me.
14:25:55 <jlouis> Good idea: You terminal launcher should be in a corner of the desktop, as per Fitt's law
14:26:54 <tuomov> why would anyone want to launch the terminal -- a keyboard app -- with the mouse
14:27:10 <basti_> great talk
14:27:18 <reffie> everyone should be using os x
14:27:40 <Jerub> http://www.asktog.com/basics/firstPrinciples.html#fitts's%20law
14:28:01 <tuomov> my head would explode for 5 minutes of os x
14:28:04 <Jerub> reffie: no, everyone should be emulating OSX, otherwise we will stagnate.
14:28:07 <tuomov> s/for/from/
14:28:21 <SyntaxNinja> three cheers for Debian! The Universal Operating System!
14:28:27 <Muad_Dibber> if you donate me a ibook i'll start using os x :)
14:28:29 <skew> tuomov: I don't know, but then I use ion :)
14:28:30 <Jerub> tuomov: I used OSX for the first time last week, I was quite impressed.
14:28:30 <reffie> real men use freebsd
14:28:38 * shapr installs the ion3-scripts deb
14:28:45 <Jerub> wooo?! ion3 ?
14:28:47 <tuomov> all the flashy animations etc. just make me sick
14:28:59 <shapr> Jerub: yeah, tried it?
14:29:03 <reffie>  http://segfaulted.com/screenshots/Screenshot-30.png <- os x
14:29:04 <tuomov> and even after those disabled there's a poor excuse of a window manager under it
14:31:10 <tuomov> I can't use an OS that Ion doesn't run natively under anymore..
14:31:17 <Jerub> shapr: no, but I will!
14:31:20 <tuomov> or that doesn't have something equivalent to Ion
14:31:31 <Jerub> shapr: I was an ion2 junkie right up until I used the Gimp for non-trivial tasks.
14:31:45 <reffie>  used to run ion
14:31:55 <reffie> then i realized how much it suck
14:31:58 <reffie> +s
14:32:04 <skew> tuomov: I can generally manage to click on the pretty pictures if I have to..
14:32:26 <skew> reffie: why? It lays out my windows the way I had to lay them out by hand
14:32:46 <skew> Jerub: WFloatWS didn't cut it?
14:32:47 <tuomov> I also do find almost everything by apple ugly... revenge of the teenagers from hell stuff
14:32:59 <shapr> reffie: what sucks about ion?
14:33:00 <reffie> http://segfaulted.com/screenshots/Screenshot-11.png
14:33:05 <reffie> it looks like shit
14:33:07 <skew> reffie: I mean, that way I used to lay them out by hand
14:33:09 <SyntaxNinja> this is really the Anything But Haskell channel today, isn't it?
14:33:15 <shapr> I guess so.
14:33:22 <Jerub> skew: what's that? and when was it released?
14:33:39 <reffie> skew you still need to lay them out by hand
14:33:43 <shapr> reffie: I guess that's personal preference then.
14:33:49 <SyntaxNinja> reffie: is that you in the background? ;)
14:33:50 <shapr> So, any haskell window managers?
14:33:57 <SyntaxNinja> shapr: house uses one
14:33:58 <reffie> SyntaxNinja where?
14:34:05 <SyntaxNinja> reffie: on the first screenshot
14:34:07 <Jerub> I also used to be a ratpoison junkie
14:34:10 <xerox> SyntaxNinja, no :-)
14:34:15 <reffie> SyntaxNinja heh. no.
14:34:20 <skew> Jerub: if you hit the query-create-workspace key (default mod-F9 I think), then it asks you for the workspace type. If you type in WFloatWS it makes a traditional windows that you move around by hand thing
14:34:30 <SyntaxNinja> reffie: well, I didn't want to be sexist and say "is that your girlfriend" or something
14:34:31 <Jerub> okay.
14:34:46 <Jerub> SyntaxNinja: why is that sexist?
14:35:00 <reffie> she's not my girlfriend yet :<
14:35:00 <shapr> SyntaxNinja: Is it anywhere close to usable in Linux? I should try this myself...
14:35:00 <SyntaxNinja> sexist or heterosexist I guess
14:35:01 <TFK> Jerub?
14:35:04 <tuomov> what?!?!? do you mean there are girls on irc?!??
14:35:07 <SyntaxNinja> shapr: don't know.
14:35:15 <TFK> You a Haskell coder?
14:35:19 <reffie> FALSE ALARM GUYS, I'M NOT A GIRL!
14:35:22 <skew> reffie: I mean stretching out the little boxes so they cover all the screen with the stuff I'm working on
14:35:29 <SyntaxNinja> shapr: probably since it was developed before house
14:35:37 <SyntaxNinja> tuomov: there are. that's my point.
14:35:39 <Jerub> TFK: since birth
14:35:42 <mwc> basti_, you still around?
14:35:46 <basti_> yes
14:35:58 <shapr> So, anyone written any Haskell code lately?
14:36:00 <TFK> Jerub, heh. Nice to know :-)
14:36:11 <Jerub> shapr: I was hacking on Yi/Keymap/Vim.hs
14:36:21 <Jerub> shapr: didn't *achieve* anything
14:36:21 <reffie> i've started implementing AKS polynomial-time primality testing in haskell, yesterday
14:36:25 <reffie> i'll finish tonight.
14:36:42 <shapr> cool
14:36:57 <shapr> I know the author of ion3 also has some code in Yi.
14:37:03 <skew> Poof, there goes the canonical example of somthing maybe in NP intersect coNP but not P.
14:37:15 <tuomov> I have a semi-finished joe mode
14:37:18 * TFK didn't really do anything, but hey...
14:37:19 <tuomov> that I haven't sent
14:37:30 <skew> In NP intersect coNP but maybe not in P, to be more specific
14:37:35 <tuomov> so as not to bother dons with maintaining it
14:37:38 * Jerub goes to work
14:37:38 <reffie> skew what are you talking about?
14:38:07 <skew> complexity classes
14:38:14 <reffie> i mean
14:38:19 <beschmi> reffie: cool, i'll probably have to write some factoring code to understand the number field sieve
14:38:20 <reffie> what's this canonical example you are talking about
14:38:24 <skew> primality testing
14:38:36 <reffie> primality testing was long suspected to be in P
14:38:56 <reffie> it's factoring that we suspect to be in NP
14:40:05 <TFK> I think it was proven to be in P.
14:40:10 <reffie> it has
14:40:21 <basti_> its probabilistical P yes
14:40:28 <reffie> TFK google for PRIMES in P
14:40:39 <TFK> That's what I'm talking about, yes.
14:40:41 <basti_> with an exponent depending on riemann's
14:40:42 <basti_> =)
14:40:51 <reffie> basti_ even deterministic is in P
14:40:53 <CosmicRay> woo, I think fptools may finish converting tonight.
14:40:58 <basti_> oh it is?
14:40:59 <basti_> cool
14:41:00 <reffie> basti_ google for PRIMES in P
14:41:15 <xerox> @google PRIMES in P
14:41:15 <reffie> by agrawal, kayal and saxena
14:41:17 <lambdabot> http://www.cse.iitk.ac.in/news/primality.html
14:41:21 <reffie> yes
14:41:34 <skew> Yes, but for a long time it was known that primality testing was in NP and coNP, and could be done in probabilistic polynomial time, but nobody could show it was in P
14:41:52 <reffie> okay
14:42:28 <SyntaxNinja> CosmicRay: cool!
14:42:31 <skew> It's the only problem Papadimitriou specifically points out as being in NP and coNP but not yet known to be in P
14:42:33 <SyntaxNinja> CosmicRay: awesome work :)
14:42:47 <reffie> skew i see!
14:42:48 <CosmicRay> SyntaxNinja: thanks, but actually it's mostly just waiting for something to break then spending 5 minutes to fix it :-)
14:42:49 <skew> I tried searching for info, but intersect symbols and stuff confused google a bit
14:43:48 <SyntaxNinja> CosmicRay: unenviable no matter how you look at it.
14:43:51 <skew> Of course, nobody needs a proof that a problem in NP and coNP is not in P to believe that it might not be
14:44:11 <skew> Asking for a proof that P /= NP along the way is a little strong
14:44:21 <reffie> hehe
14:44:48 <Muad_Dibber> werent they a step closer to P = NP a while ago?
14:45:16 <reffie> i'd be surprised if P = NP
14:45:25 <skew> Though a professor here did ask for an argument why P /= NP on an exam a few years back...
14:45:45 <basti_> lol
14:46:22 <basti_> i think the P/=NP, but NP feasible through quantum computing.
14:46:28 <basti_> in like 100 years.
14:46:48 <skew> and for a unit in complexity asked a second year class to give an algorithm for some problem meeting a time bound that had just been attained in a preprint posted about a week before
14:47:29 <skew> I think a decent fraction of the class managed it, though :)
14:47:43 <reffie> as in 1/100?
14:47:57 <skew> basti_: I've seen some pretty convincing arguments that quantum compters can't do NP
14:48:07 <basti_> aww.
14:48:08 <basti_> ;)
14:48:16 <skew> at least short of P=NP
14:48:19 <reffie> quantum computers are deterministic, aren't they
14:48:32 <basti_> the theory is that they might not be
14:48:38 <basti_> due to bizarre quantum behaviour.
14:48:57 <reffie> i know nothing about quantum computing, anyway
14:49:00 <tuomov> depends on how you define deterministic and your interpretation of quantum mechanics
14:49:00 <skew> deterministic in the sense that superpositions evolve according to the wave equations
14:49:04 <basti_> noone knows if there are any limits to this stuff.
14:49:13 <xerox> Non-deterministic computer would be a theoretical problem!
14:49:23 <tuomov> you can also consider them being massively parallel
14:49:43 <skew> except you can only extract some strange functions of the result
14:49:58 <basti_> that might mean that it is not possible to build one that actually makes sense
14:50:18 <basti_> its possible in theory, but a REALLY far reach technologically
14:50:34 <skew> in particular, you can't just have one of the parallel processors find the correct answer and feed that back up
14:50:45 * basti_ nods
14:50:54 <basti_> its a very complex matter
14:51:08 <basti_> demonstrations of quantum computing were rather ridiculous so far
14:51:23 <skew> I think it's kind of like big grid of parallel computers where they can just compute on their own and xor their current guess with their neighbor or some limited operation like that, and then you get the average answer of all the machines
14:51:48 <basti_> like, factoring the number 15 in O(1), with a shitload of really expensive gear and lots of people doing lots of annoying fiddling work
14:52:00 <skew> randomness is like the machines don't get to talk to each other at all and you get just one of the answers
14:52:25 <skew> quantum computing is like they have really restricted communication, and you get a random answer
14:53:32 <skew> basti_: specifically, there is a theorem that quantum computers can't give you more than some subexponential speedup on a certain problem as long as quantum mechanics is linear and unitary and other stuff that physicists think it is
14:53:52 <basti_> okay.
14:54:27 <basti_> it's never easy :P
14:54:28 <skew> so if they can do NP it's not because they let you take the direct guess-the-right-answer implementation, but because NP has some more specific structure that QM can exploit
14:54:43 * basti_ nods
14:54:58 <basti_> lets talk about this again in 30 years.
14:55:42 <basti_> maybe we will be wiser then
14:56:26 <skew> I should try to figure out what the results about oracles mean
14:56:42 <basti_> basically that the answer won't be easy.
14:56:42 <basti_> ;)
14:56:57 <basti_> as far as i understood
14:58:02 <basti_> the argument is something like that: if there's an oracle A so that B^A != C^A, then somebody will have to find it and write it down explicitely so we know more about it
14:58:16 <basti_> and usually the results are just that this oracle exists
14:59:11 <basti_> mmm should go to bed now
14:59:26 <basti_> cu all
15:02:56 * mwc wades into the quantum computer debate far too late
15:03:28 <mwc> We have quantum algos that do amazing things, like factor numbers in O((log N)^3) time
15:03:59 <mwc> So far, we know how to factor, compute discrete logarithms, and search unordered data
15:04:17 <skew> note that the searching only goes as sqrt(N)
15:04:34 <mwc> A quantum computer makes use of superposition, each qubit is in both states.
15:04:53 <skew> with full nondeterminism you can search unordered data in O(log N) time
15:05:02 <mwc> So for a 500 qubit computer, you've got a state vector with 2^500 elements
15:05:26 <mwc> so it's like the universe carries that many variables around as you compute
15:05:40 <mwc> which is more information than is classically present in the universe
15:05:43 <mwc> booyah!
15:06:07 <skew> the random collapse at the end makes it hard to get what you want out, though
15:06:16 <mwc> Yep
15:06:44 <mwc> you do operations to make the correct answer the most likely
15:06:59 <mwc> checking is generally pretty easy to do classically anyways
15:07:34 <skew> although, there was a suggestion that any nonlinearity in QM that gives you locally exponential expansion is enough to do NP
15:08:29 * mwc chokes at the thought of nonlinearity in QM
15:09:00 <skew> something has to give in the grand unification
15:09:12 <mwc> I'm betting on GR ;)
15:10:04 <mwc> QM is too entrenched
15:10:19 <mwc> It's done in labs everywhere, GR is observed distantly
15:10:31 <skew> Maybe strings only do P but there are enough to simulate QM :)
15:10:43 <mwc> QM has ubiquitous applications, GR hasn't done squat for the average man
15:10:58 <mwc> So I'm betting GR is where the axe is headed
15:11:54 <skew> mwc: Not exactly no applications. The room where we usually work on physics has a nice little gravitiational wave generator sitting in the corner
15:12:16 <skew> flip a switch and a bar on top starts spinning, sending out nice quadropole waves :)
15:12:22 <mwc> hahaa
15:12:24 <mwc> Great.
15:12:38 <mwc> That's like claiming an incandescent light bulb is a QM application
15:12:49 <mwc> generates broad spectrum photons :P
15:13:11 <xerox> What is GR ?
15:13:21 <mwc> xerox, general relativity
15:13:30 <mwc> we should head over to #physics for that discussion though
15:13:54 * xerox joins
15:14:31 <skew> Actually, I'm pretty sure relativity is important in GPS, and I've heard MOLA corrects for the relatavisitc effects of jupiter
15:16:12 <lispy> creepy
15:16:21 <lispy> but cool :)
15:17:33 <mwc> it also managed to prove that Mercury's orbit didn't require an inner "Planet zero"
15:23:10 <skew> So, about that Haskell...
15:23:27 <SyntaxNinja> something about today...
15:23:29 * xerox was trying to implemente Conway's Life
15:25:58 <skew> How many people here have seen HoogÎ»e?
15:26:05 <skew> http://www-users.cs.york.ac.uk/~ndm/hoogle/
15:27:45 <xerox> skew, nifty!
15:28:15 <mwc_> xerox, because skew and I were discussing where a GUT was gonna cause giv
15:28:34 <mwc_> if quantum mech has a few properties we can do some reallly bitching stuff with quantum computers
15:28:54 <mwc_> but I don't think that QM is gonna break so easily
15:29:00 <skew> Every search by type seems to give results starting with undefined
15:29:17 <skew> and usually continuing with pi, minBound, and maxBound :)
15:30:16 <xerox> skew, yep, pi, minBound and maxBound appears to me every time :)
15:30:24 <skew> somebody should mix a type search like this with haddock
15:30:29 <xerox> mwc_, thanks much for the explanation, I'll try to go deeper.
15:30:37 <skew> or maybe the haddock parser and and ghc unifier :)
15:30:58 <skew> shapr: you missed a nifty link
15:31:03 <shapr> What was it?
15:31:06 <xerox> You did!
15:31:11 <skew> Have you seen HoogÎ»e?
15:31:16 <skew> http://www-users.cs.york.ac.uk/~ndm/hoogle/
15:31:28 <shapr> wha cool
15:31:46 <skew> it strongly recommends undefined :)
15:32:12 <shapr> Does it actually do type equivalence searching?
15:32:17 <skew> yep
15:32:35 <skew> that's why it always includes undefined if you search by type
15:32:39 <shapr> Too bad I can't get the source :-(
15:33:01 <skew> Maybe you could make one yourself from bits of haddock and ghc
15:33:08 <shapr> Yeah, tempting.
15:33:22 <shapr> I read about type-based searching when I wrote @index
15:33:28 <shapr> It's doable.
15:33:42 <xerox> @index pi -- is it back?!
15:33:43 <lambdabot> bzzt
15:33:47 <shapr> Anyway, I'm responding to a post on LtU, and have some questions...
15:33:50 <shapr> xerox: not yet.
15:34:01 <skew> just grabbing everything that unifies with the type you put in probably works well enough
15:34:05 <xerox> Aww  ^__^
15:34:07 <shapr> This guy wants signals and slots for MVC apps. What does that mean?
15:34:32 <skew> That's a good question.
15:35:06 <xerox> OK. Goodnight folks!
15:35:17 <skew> I've heard those terms before, but I've got them lumped with all the miscellaneous OO jargon
15:35:51 <shapr> Specifically - http://lambda-the-ultimate.org/node/view/663#comment-5758
15:35:54 <jlouis> This is a bet: An MVC app is a microsoft app. A signal is something a widget/controller raises. It signals a given slot which then does the action. For instance. the OK button will signal the OK_routines slot and remove the window.
15:36:10 <shapr> So, MVars then?
15:36:12 <skew> you are thinking MFC.
15:36:31 <skew> @google signals slots
15:36:33 <lambdabot> http://doc.trolltech.com/3.3/signalsandslots.html
15:36:51 <skew> MVC is actually a pretty sensible sounding idea for GUI architecture
15:37:00 <shapr> aha, publish subscribe?
15:37:24 <shapr> Hm, not really.
15:38:24 <skew> All the pages I know of get bogged down in discussions of which objects have hardcoded knowledge of which other objects and if that's bad
15:38:45 <skew> shapr: Haven't you heard of MVC before?
15:38:58 <shapr> Sure, used it too.
15:39:06 <skew> okay
15:39:30 <shapr> But I've stayed away from C++, and this guy is a very experienced C++ guy.
15:39:49 * esap thinks MVC needs signals and slots.
15:40:07 <shapr> The little bit of C++ I've written didn't impress me. I figured I could stick with Haskell and throw in some C code if I need more speed.
15:40:57 <jlouis> C++ is the swiss army knife of languages. The advanced version of ``when you have a hammer, everything looks like a nail''
15:41:51 <jlouis> It is not a bad language, you can often bend it to your will. But you might have to spend considerably more energy on bending than on programming
15:42:00 <esap> I think C++ is more like what you get when you try to support every conceivable way of writing programs.
15:42:34 <jlouis> esap: true
15:42:48 <jlouis> I am glad I now have a Haskell interpreter
15:42:50 <shapr> Signals and slots sure looks like a Channel in Control.Concurrent to me.
15:42:52 <jlouis> on NetBSD
15:42:58 <Lunar^> esap: what about Perl, then? :)
15:43:02 * TFK reraises awareness of Fortress, and goes to grab some chow
15:43:58 <esap> lunar: Perl is not quite like that, perl is clearly more specialized.
15:44:46 <Lunar^> esap: in Latin? :)
15:44:49 <jlouis> I tend to write in whatever language. If I can choose myself though...
15:44:55 <jlouis> Haskell
15:46:00 <esap> shapr: Signals and slots are pretty close to the Channel, but there are some differences. For example, signals and slots do not require you to have threads.
15:46:16 <skew> I think it's more like collecting a list of callback functions
15:46:44 <esap> shapr: Because there are callbacks. It's more like pretty simple way of setting up callbacks.
15:46:46 <skew> I don't get the bit on the trolltech page about callbacks not being type safe. I'm assuming that's an artifact of their choice of language
15:47:11 <esap> skew: there are type safe callbacks and type-unsafe callbacks.
15:47:20 <shapr> Ok, I'll just mention that.
15:47:29 <shapr> @google value classes
15:47:30 <lambdabot> http://construction.ecnext.com/coms2/summary_0249-610_ITM
15:47:38 <skew> esap: like what? callback :: Dynamic?
15:48:50 <shapr> Oh wait, a value class is like Integer vs int in Java?
15:49:10 <esap> skew: Some callback systems in C++ use casts on the type of the function to allow passing arguments from the invoker to the callback, and try to do it in such way that the intermediate code doesn't need to know about the types. Which makes it unsafe.
15:50:27 <skew> Pity the poor impoverished programs lacking parametric polymorphism.
15:50:44 <lispy> heh
15:51:18 <esap> skew: the problem is they try to generalize too much, and instead end up breaking type safety.
15:53:02 <esap> skew: And there are some bad examples in windows APIs for example about that, which is where some people get their ideas about design.
15:57:31 * esap supposes everybody here has read about libsigc++? which is another kind of signal/slot system for C++.
15:57:49 <shapr> If value classes really does mean int vs Integer, I don't see how that applies to Haskell.
15:58:00 <shapr> Maybe he mean support for unboxed values?
15:58:54 * esap missed some of the discussion. Value classes?
15:59:17 <shapr> I'm responding to - http://lambda-the-ultimate.org/node/view/663#comment-5758
15:59:26 <skew> He thinks Python and Haskell have wierd syntax?
15:59:35 <shapr> Yeah, kinda sad, isn't it?
16:00:18 <Jerub> python and haskell have non-C syntax.
16:00:22 <Jerub> therefore it is weird to some epople
16:01:31 <esap> shapr: Value classes could mean either Java int vs Integer (I don't know why anybody would want those), or it could mean value class concept from CORBA.
16:01:43 <shapr> I seriously doubt he's talking about CORBA.
16:01:58 <esap> shapr: He says Java doesn't support value classes....
16:02:28 <esap> shapr: Or maybe he means the stack-allocated variables from C++.
16:03:24 <esap> shapr: ah actually no. He's talking about different thing.
16:03:29 <shapr> What is it?
16:04:16 <esap> shapr: He's talking about newtype-like type aliases, such that different uses of values get different types.
16:04:31 <Jerub> type coercion?
16:05:02 <esap> jerub: well no, actually more like ensuring that compiler keeps distinct uses of types distinct.
16:05:36 <esap> Like having aliases for Float for Seconds and Milliseconds so that you can't mix those up.
16:06:03 <shapr> That's just newtype, right?
16:08:10 <esap> yes. There is a book "barton, nackman: Scientific and Engineering C++" that uses that kind of technique heavily with C++ overloading.
16:10:39 <shapr> The only thing I'm not sure about is details on memory mapped data structures. Is that sort of info in the FFI?
16:14:34 <shapr> g'day blackdog
16:14:44 <esap> hmm.. actually, maybe it's some extension to C++ by microsoft, that could be another meaning for value class :-)
16:17:20 <shapr> Aha, http://www.haskell.org/pipermail/glasgow-haskell-users/2004-December/007511.html
16:17:23 <SyntaxNinja> hey blackdog
16:17:51 <blackdog> good morning syntax.
16:18:20 <blackdog> hey, i was going to ask you stupid questions about cabal
16:18:34 <blackdog> is there an easy way to go from the old style package description to the new one?
16:24:41 <shapr> Thanks for your help, my reply is finished!
16:25:40 <shapr> I'll be happy with PIC is in GHC for all architectures.
16:27:08 <dcoutts> shapr, yep, shared libs for packages will be nice, no more custom linkers
16:27:08 <Igloo> Are there plans to do that, then?
16:29:23 <shapr> "The language has fast, unchecked integers because people demand performance (as evidenced by the other thread about C-class performance). But then we need to start retrofitting solutions to the problems which were created by the pursuit of performance. Sound familiar?"
16:29:33 <shapr> "This is not particularly a critique of OCaml itself, which is obviously fulfilling many people's wants. (Note I didn't say "needs".)"
16:29:49 <shapr> From Anton van Straaten
16:30:58 <shapr> Paul Snively say that OCaml, unlike other alternative languages, does not fetishitically abstract away from the word size on the machine you're using.
16:31:15 <shapr> That seem silly to me.
16:32:15 <shapr> Seems to me you'd want your software to behave the same way on all the hardware it can run on.
16:33:17 <shapr> But then, I chose speed of programming over speed of execution long ago.
16:34:16 <shapr> Oboy! an Oleg post!
16:34:53 <reffie> what does '@' mean, in a patter?
16:34:56 <reffie> pattern
16:35:07 <pesco> tuomov: By the way, I'm using ion on Mac OS X quite successfully. The only thing I'm missing is Thunderbird which for some bizarre reason failed to build. But I guess, you'd use mutt anyway? ;)
16:35:17 <reffie> "mkPolynomial' (t@(_,x):ts)" for example
16:35:25 <pesco> "as"
16:35:37 <reffie> so t is the (_,x) it matches?
16:35:39 <shapr> means let t = (_,x)
16:35:47 <reffie> that's what i thought, but i wasn't sure
16:35:48 <reffie> thanks
16:36:18 <stepcut> shapr: on which list ? (re, oleg)
16:36:28 <shapr> haskell@haskell.org
16:36:47 <reffie> why do you guys keep talking about oleg
16:36:52 <shapr> It's quite an interesting post, the Zipper as a delimited continuation.
16:37:00 <shapr> reffie: Read his writings and find out
16:37:10 <pesco> I need to go to bed.
16:37:12 <reffie> i can't understand anything in them
16:37:17 <reffie> or at least last time i did
16:37:22 <reffie> i tried
16:37:27 <shapr> Holy crap, he connects Huet's Zipper and SPJ's recent subcontinuations paper.
16:37:37 <shapr> I think I actually understand that!
16:37:41 <reffie> i guess he's really really smart?
16:37:55 <shapr> I think so.
16:38:03 <shapr> But you gotta make up your own mind.
16:38:10 <reffie> my goal is to become really really smart
16:38:15 <reffie> but i don't know if i can make it
16:38:22 <shapr> In that case, Oleg is a good person to emulate.
16:38:22 <reffie> my brain has been shrinking, lately
16:38:51 <shapr> eek, subcontinuations monad transformer!
16:39:10 <reffie> haskell terms are way too scary
16:39:21 <shapr> Nah, just really specific.
16:39:25 * esap starts reading oleg's mail.
16:39:49 <skew> shapr: did you post your post?
16:40:08 <shapr> yup
16:40:25 <shapr> Hard to find in amongst the OCaml advocacy, but it's there.
16:40:58 <shapr> Personally, I think OCaml is an excellent replacement for C++, it's like C++++.
16:41:41 <monochrom> D++
16:42:11 <skew> People say OCaml is pragmatic, but that's for a value of pragmatic that I don't particularly like
16:42:15 <shapr> But I'm not a speed fetishist, it's likely I'll never learn C++ or OCaml.
16:42:36 <reffie> i've never quite understood what pragmatic means
16:42:42 <shapr> No wait, I *am* a speed fetishist, and that's why I'll never learn C++ or OCaml.
16:42:58 <skew> OCaml isn't particularly bad
16:43:14 <reffie> at least OCaml's syntax is similar to haskell's
16:43:20 <reffie> kinda
16:43:27 <esap> I think pragmatic means that you think that keeping time schedules is important, as opposed to making the software work :-)
16:43:35 * shapr grins
16:43:35 <monochrom> I'm a speed fetishist, I do everything with transistors.
16:43:43 <reffie> heh, esap
16:44:10 <shapr> That's the thing, making the software work right the first time is far more important to me than making it work wrongly very quickly.
16:44:47 <skew> I think the O'Caml type system does not have many of the extensions like arbitrary rank types that Haskell does, just because that compromises type inference
16:44:49 <reffie> shapr whoever thinks otherwise is an idiot.
16:45:31 <skew> shapr: there is value in being able to make it work right fast enough, but that's not very fast for the kind of stuff we usually write
16:46:06 <skew> How fast you can make it with a given amount of effort is also an interesting metric
16:46:07 <esap> I guess the choice is usually between *knowing* that the software works, and not being absolutely sure, but keeping time schedules.
16:46:10 <shapr> skew: Yes, I agree. But if I need lots more speed, and my Haskell program already works right, I'll find the inner loop, and write a tiny chunk of C.
16:46:26 <shapr> g'day Pseudonym
16:47:52 <Pseudonym> G'day.
16:48:16 <skew> I'm surprised that nobody pointed out that the kind of linguistic abstraction that guy is talking about is a large part of why people like functional languages.
16:48:52 <shapr> skew: go for it :-)
16:49:29 * Pseudonym reads back in the logs
16:49:48 <Pseudonym> <reffie> haskell terms are way too scary
16:49:51 <Pseudonym> He has a point.
16:50:14 <Pseudonym> SPJ mentioned in the hair shirt presentation that Haskell's biggest mistake was calling them "monads" instead of "warm fuzzy things".
16:50:19 <skew> "subcontinuation monad transformer" sounds more like a string of random words than a valid english noun phrase
16:50:38 <lispy> heh
16:50:45 * Pseudonym has a bit of a problem with "Kleisli", too
16:50:49 <lispy> hair shirt?
16:51:02 <Pseudonym> Can you imagine if C++ called them "Peanos" instead of "integers"?
16:51:23 <skew> @google hair shirt haskell
16:51:24 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/haskell-retrospecti
16:51:24 <lambdabot> ve/
16:51:32 <Pseudonym> That's the one.
16:52:13 <shapr> This is interesting - http://adamconnor.org/?p=15 I bet I qualify as an explorer.
16:52:52 <skew> I think writing monads makes us all little gods
16:53:25 <lispy> is hair shirt a phrase?
16:53:36 <Igloo> Pseudonym: I bet if they were called "numbers" then you'd be saying 'Can you imagine if C++ called them "integers"?'
16:53:38 <esap> I think both Monads, Adjunctions, Functors, Categories etc. all would need a better name.
16:53:46 <shapr> "Wearing the hair shirt" is the phrase, I think.
16:53:52 <Pseudonym> Kind of.
16:54:10 <skew> warm fuzzies, pairs of fuzzies, soft fuzzies, fuzziness
16:54:13 <Pseudonym> http://www.newadvent.org/cathen/07113b.htm\
16:54:15 <Pseudonym> http://www.newadvent.org/cathen/07113b.htm
16:54:20 <Igloo> Part of the problem with monads is questions mentioning their name tend to get answered by Haskellers in category theorist mode rather than programmer mode
16:54:22 <shapr> I think we should call them chickens.
16:54:30 <Pseudonym> That's the background you need.
16:54:31 <shapr> Then we can talk about curried chickens!
16:54:42 <Pseudonym> To "wear the hair shirt" is to perform an act of penance.
16:54:45 <skew> yeah, that's the first google hit for hair shirt.
16:54:56 <monochrom> I answer monad questions in programmer mode.  "here is how you can use... here is how you can make..."
16:55:11 <Pseudonym> The Catholic Encyclopedia is fabulous, BTW.  Great resource, even if you're not Catholic.
16:55:27 <Pseudonym> Look up "Galileo" some time, for example.
16:55:37 <Pseudonym> monochrom: RIGHT.
16:56:13 <monochrom> I answer them as though I'm teaching C++ operator overloading.
16:57:33 <shapr> Igloo: what do you think about this? http://article.gmane.org/gmane.comp.programming.language-of-the-year/3286
16:57:49 <skew> I like to think about them like Moggi used them. I think that sort of stuff is where you need to go if you really want to learn them thoroughly, so that's where I want to start when somebody says they want to "learn monads"
16:59:03 <shapr> But most programmers don't want the theory, they want it to work.
16:59:15 <shapr> And then they want to understand details of how it works, and then maybe years later they want theory.
16:59:38 <skew> Hmm, I always start at the top
17:00:25 <shapr> I saw a learning steps description somewhere that was imitation, sythesis, and understanding. Or something like that.
17:01:21 <skew> first I try to figure out the general idea behind a language/library, shading into reading vast amounts of reference material, and then trying to write some code and crystalizing the understanding
17:01:25 <shapr> When I'm teaching people, I first show them that x will work, then I ask them to change what they're doing slighly so they can explore the edges.
17:01:47 <Igloo> skew: For your average programmer type, that just gives the impression monads are scary maths things they won't understand
17:01:54 <shapr> skew: I do that too, but I've never met anyone in person (except maybe at ICFP2003) who does.
17:02:06 <esap> I would normally go on and describe the concept in simplest possible way, then go on to explain what it means.
17:02:26 <monochrom> I need to learn more about imitation-synthesis-understanding.  Teaching and learning are one of my recurrent questions.
17:02:27 <skew> I don't mind following tutorials, but I can't stand fiddling with some code I don't understand to try to make something that "just works"
17:02:30 <Igloo> I think the best way is to start with how to use a state monad, then explain how an IO monad is basically the same, and then generalise if they want to know more
17:03:06 <monochrom> I start with the list monad.
17:03:12 <skew> Igloo: I may be misremembering, but I think Wadlers' "The essence of functional programming" was what made sense to me
17:03:51 <mwc> are we discussing how to teach?
17:03:59 <shapr> I think so
17:04:13 <mwc> Can I please plead for a Haskell tutorial that walks you through building a real app and explains why things are done?
17:04:23 <skew> I'm talking about how I learn stuff
17:04:31 <shapr> mwc: Sounds great.
17:04:33 <mwc> Like "doing it this way makes sense from a FP standpoint, because..."
17:04:42 <reffie> i hate the error messages ghc gives.
17:04:51 <mwc> shapr, once I get a handle on it, I'm gonna write that damn thing just to show up all the other tutorials
17:05:03 <mwc> I finally broke down/got unbroke and bought Hudaks' book
17:05:04 <SyntaxNinja> reffie: I once heard a talk where someone was researching how to do better error messages
17:05:16 <monochrom> mwc: does Hudak's book work for you?
17:05:26 <reffie> SyntaxNinja cool
17:05:34 <mwc> monochrom, I'll tell you when it arrives
17:05:45 <mwc> it just shipped yesterday from the USA so I'll have to wait
17:05:52 <shapr> I like to explain monads as types with a certain significance turned into a pipeline with the same significance.
17:05:58 <monochrom> Ah.  I think it's in the direction you describe.
17:06:01 <SyntaxNinja> reffie: for one thing, the type system makes it hard to give messages that are intuative for newbies
17:06:10 <reffie> SyntaxNinja indeed
17:06:23 <SyntaxNinja> reffie: one thing this guy said was that experienced haskell programmers don't even look at the error messages. they just look at the line that's wrong and fix it
17:06:31 <mwc> I read  something written by that guy at microsoft
17:06:32 <SyntaxNinja> reffie: and unexperienced programmers can't understand the messages :)
17:06:41 <mwc> about Monads and the awkward squad or something
17:06:49 <shapr> mwc: oh, I like that one.
17:06:53 <mwc> and that was a bloody brilliant explanation
17:07:04 <SyntaxNinja> that talk was related to this project: http://www.cs.uu.nl/helium/
17:07:04 <mwc> Hudak's book seemed to be what I was after
17:07:44 <Jerub> hey, GHC's messages are works of art imho.
17:07:50 <shapr> quote ghc
17:07:53 <shapr> @quote ghc
17:07:54 <lambdabot>   ARGH! Jump uses %esi or %edi with -monly-2-regs
17:07:54 <Jerub> I've never gotten clearer error messages.
17:07:59 <shapr> @quote ghc
17:08:00 <lambdabot>   adjustor creation not supported on this platform
17:08:06 <esap> I'd explain monads like this: "A monad (type) is a specific type of an action with a result. You can execute the actions in sequence.".
17:08:08 <SyntaxNinja> Jerub: I think they're as good as they can be.
17:08:15 <mwc> that first one looks like an x86 vomit
17:08:21 <monochrom> I have a warning however.  Programming in the small (writing one routine or one module) and programming in the large (architecting a lot of modules, doing a real application) are different.  The former is language specific, the latter much less so.  It doesn't sound quite tenable to ask for a book about doing real applications in language ____.
17:08:29 <shapr> esap: yeah, but I didn't understand the point then.
17:08:39 <SyntaxNinja> @quote shapr
17:08:40 <lambdabot>   I've tried to teach people autodidactism, but I've realized
17:08:40 <lambdabot> they have to learn it for themselves.
17:08:46 <stepcut> heh
17:08:47 <esap> shapr: heh  :-)
17:08:47 <mwc> monochrom, was that warning for me?
17:08:51 * shapr grins
17:08:54 <monochrom> Yes.
17:09:33 <mwc> monochrom, that's fine then. I understand that. Some of these tutorials are like reading the C++ ARM
17:09:46 <mwc> the ARM was great after I learned the lang
17:10:09 <mwc> but just telling you about the syntax leaves you not knowing where to go next, you have to reinvent all the idioms yourself
17:10:17 <shapr> esap: I usually start with the maybe monad, and tell them it's a way to abstract out a big stack of nested if-then-else statements.
17:10:27 <mwc> Reading about the typesystem while doing dick-all was in one ear-out the other
17:10:35 * SyntaxNinja throws an error monad at shapr
17:10:47 * shapr catches it in his Left hand
17:10:48 <SyntaxNinja> mwc: that was an image I could have done without
17:11:14 <shapr> Recent research shows that the best way to read a manual is after you've played with whatever it is first.
17:11:28 <mwc> SyntaxNinja, are you European? Those are pretty common North American (at least Canadian) idioms
17:11:31 <shapr> Then you have a vague idea of what's going on. If you read first and play after, the reading is almost always a waste of time.
17:11:43 <monochrom> I think my small set of notes at http://www.cs.utoronto.ca/~trebla/fp/ is also very helpful.
17:11:48 <SyntaxNinja> mwc: I understood them. it was just the combination, I think.
17:11:54 <mwc> Ah, hhahahaha
17:13:05 <monochrom> I start with the list monad because most readers already know Python list comprehension.
17:14:17 <mwc> monochrom, hmm, looks good, but I'm afraid this is just another lecture
17:14:24 <mwc> I rarely go to mine anyways, I learn nothing
17:14:28 <esap> Always you need to know what kind of background the person has before you can start explaining things. If he knows much C++, then references to design patterns probably help.
17:14:45 <mwc> I have a 90 average, and a 10% attendence rate :P
17:14:55 * esap would then describe Monads via the Command pattern.
17:15:16 <mwc> Although having ADHD probably is responsible for that
17:15:27 <mwc> monochrom, you teach at UoT?
17:15:29 * shapr knows that feeling
17:15:34 <skew> shapr: I just can't work without some understanding. I start with the theory for a skeleton, then pour on information from references and experiments until the theory is fleshed out enough to start making testable predictions, start playing with examples to test the model and help incorporate the bits I don't understand yet, and then set out to write stuff
17:15:40 <monochrom> Don't come to my lectures.  (I'm holding none anyway.)  But do gone through my slides; I think they make certain things clear.
17:15:57 <mwc> Yeah, I'm a learn by doing kinda guy
17:16:04 <shapr> skew: But, random playing does give some understanding. Sometimes it gives better understanding that the models.
17:16:10 <skew> shapr: I doubt playing with an interpreter before reading anything is very productive
17:16:14 <monochrom> My slides try to guide you to do things.
17:16:17 <shapr> I disagree.
17:16:27 <mwc> "Some folks can be told. Others have to see it. And then there's those that have to piss on the electric fence themselves."
17:16:29 <skew> shapr: I'm really bad at guessing syntax without any pointers
17:17:04 <shapr> But realize, I also take large and regular doses of Ritalin, so my preferences may not be the same.
17:17:23 <monochrom> I made those slides to practise teaching, using a few of my friends as guinea pig students.
17:17:41 <skew> I'm just to lazy to dig information out of an interpreter when it's all lined up in references
17:17:52 <skew> have you ever tried just playing with ed?
17:18:14 <shapr> ed is not a good example. You don't play with ed, you quickly try to banish it, even if it requires rebooting.
17:18:26 <mwc> monochrom, heh, they do look good, in fact, they'd probably be good lecture material
17:18:52 <shapr> skew: But in actuality, yes. One of my early experiences with programming was usin debug.com to write asm.
17:18:59 <mwc> It's just that if I was sitting in a class listening to this I'd be 10,000 miles away
17:19:01 <monochrom> Thanks.
17:19:16 <shapr> I think debug.com is a lot like ed. All the userfriendliness, all the verbose help...
17:19:26 <skew> that doesn't sound very productive...
17:19:41 <mwc> monochrom, i'm a difficult student
17:20:11 <skew> shapr: does lambdabot have the ghc message about existentials, pattern matches, and exploding heads?
17:20:21 <mwc> woah, that sounds like a good one
17:20:24 <shapr> I dunno, dons put in all the messages.
17:20:38 <monochrom> I want exploding heads.
17:20:39 <skew> is there any easy place to check?
17:20:57 <skew> monochrom: just try to pattern match and existential constructor in a let binding
17:21:07 <shapr> Yeah, check the darcs repo.
17:21:59 <shapr> @quote ghc
17:22:00 <lambdabot>   My brain just exploded.
17:22:05 <shapr> Guess so.
17:22:15 <monochrom> I'm satisfied now. :)
17:22:29 <reffie> <3 list comprehensions
17:22:49 <shapr> I swear, everytime I see that emoticon it looks like testicles to me.
17:22:59 <mwc> hahaha, you too?
17:22:59 <reffie> hahahah
17:23:05 <reffie> you sick bastards
17:23:13 <mwc> <===3
17:23:15 <monochrom> I love list comprehensions too.  It is at once a convenient practical tool and a deep theoretical elegance.
17:23:19 <mwc> yeah, it's pretty bad
17:23:21 <skew> monochrom: data T = forall a . T a; f x = let (T _) = x in ()
17:23:33 <mauke> <3 is an asshat
17:23:50 <reffie> heh.
17:24:40 <monochrom> You left-wing people of course all get it wrong.  You only turn your heads left, and you see the wrong picture.
17:25:21 <skew> monochrom: Don't you want to be on the bright side? ):)
17:25:23 <monochrom> If you even just turn your head a bit right, you'll see a heart.
17:25:24 <mwc> I voted Conservative last election
17:25:49 <mwc> Nah, still like balls to me
17:26:02 <monochrom> Theorem: The Left are dirty-minded. The Right have a heart.
17:26:03 <mwc> But then that meme is firmly entrenched now, thanks to shapr
17:27:12 <shapr> yay!
17:27:14 <skew> does anybody know much about ruby?
17:27:20 * mwc does
17:27:37 <shapr> I played with it some, it's quite nice. I missed sig whitespace and first class functions though.
17:27:38 <mwc> It's like python done right
17:27:50 <mwc> shapr, you have first class functions, kinda
17:27:59 <Jerub> shapr: really? i thought ruby had closures that were kinda like first class functions
17:28:05 <mwc> there's a class that takes a block and creates a functor
17:28:07 <skew> I've heard it claimed that it supports making domain specific abstractions, with its blocks and reflection and stuff
17:28:09 <Jerub> mwc: but with regexp as part of the language grammar.....
17:28:30 <shapr> mwc: yeah, but....
17:28:33 <mwc> The python library scared me off
17:28:37 <skew> I was wondering what somebody who knows Haskell and ruby thinks about that
17:28:56 <shapr> In my opinion a language is described by what it encourages. I really like HOFs.
17:29:03 <mwc> I don't know either well enough to comment out of any orfice above my belt, unfortuneatly
17:30:06 <skew> I've just written a few lines following a Ruby on Rails tutorial after somebody mentioned that here. Now I'm reading Why's tutorial, which I greatly enjoy.
17:30:41 <shapr> Yeah, I've decided to learn RoR so I can steal ideas.
17:30:47 <mwc> shapr, there's the method class http://www.rubycentral.com/ref/ref_c_method.html and the proc class: http://www.rubycentral.com/ref/ref_c_proc.html
17:31:22 <mwc> I got put off by the python tutorial when I got to lists]
17:31:34 <mwc> Some calls are in place, some operate on copy
17:31:45 <mwc> just a nightmare to learn what each does, imho
17:32:12 <mwc> Ruby has a method like reverse which is copying, and reverse! which is inplace, and uses that ! convention. much nicer
17:32:15 <skew> I like the idea of making easy things trivial, like the database object things finding their table automatically and populating their set of attributes from the database, and that scaffolding stuff for getting things started
17:32:37 <mwc> Yeah, that is pretty cool
17:32:43 <mwc> Have you watched the 10 minute demo vid?
17:33:10 <skew> That's one of the things I like about Haskell too, operator slices and a really short name for lambda and stuff like that makes it trivial to write easy things like map (1+).
17:33:46 <skew> as compared to something like (lambda (list) (map (lambda (item) (+ 1 item)) list)) in some other language
17:34:32 <Jerub> at least python is gaining currying.
17:34:34 <Jerub> *finally*
17:35:08 <stepcut> but dropping some other useful stuff...
17:35:34 <Jerub> *shrug*
17:35:39 <skew> powerful abstraction lets you make really interesting and complicated things like Parsec easy to work with, at the other end of the spectrum
17:35:41 <Jerub> I'm not sad to see lambda go.
17:35:52 <Jerub> not in python at least.
17:36:03 <mwc> I've started learning python 5 times now and never finished, so I'm betting it's never gonna happen
17:36:19 <mwc> I think the language I learned fastest was Ada, but that might just be prior C++ experience
17:36:20 <Jerub> I never learned python
17:36:29 <shapr> I get paid to write Python.
17:36:36 <Jerub> So do I.
17:36:51 <skew> Jerub: are you case-sensitive?
17:36:58 <shapr> I have decided it's time to fix Zope & Plone.
17:37:05 <shapr> And the solution calls for HASKELL!
17:37:07 <shapr> w00!
17:37:12 <Jerub> suu
17:37:14 <Jerub> er
17:37:14 <Jerub> wuu
17:37:18 <mwc> That sounds pretty cool, actually
17:37:41 <Jerub> last time I tried doing haskell based web stuff, I was turned off by the long compilation times
17:38:21 <skew> I wonder if runhaskell would help much?
17:38:56 <shapr> Jerub: now we have hs-plugins
17:39:55 <dvtoo> anyone successfully built 6.4 on any version of solaris?
17:40:05 <Jerub> shapr: yes, I saw that, I was ever so slightly excited.
17:40:33 <skew> hs-plugins doesn't seem like it would help with long compile times
17:40:34 <shapr> dvtoo: You may want to ask on ghc-users mailing list. I've seen discussion about 6.4 on Solaris, but I don't remember details.
17:40:36 <skew> long link times maybe
17:41:06 <skew> which you might be lumping under compile time
17:41:22 <dvtoo> well, I can' seem to get 6.2.2 to build on solaris 8, so trying 6.4 on solaris 10
17:41:28 <dvtoo> I'll check the mailing list if this doesn't work out
17:41:30 <skew> but it always seems to take me much longer to relink a program than to recompile a single module, even if I'm optimizing and everything
17:45:30 <dons> yep. hence @plugs is a bit faster than hmake.
18:05:12 <reffie> is there something like map for tuples?
18:06:11 <Igloo> no
18:06:24 <reffie> is there a way to convert a tuple to a list, then?
18:06:44 <reffie> [and then a list back to a tuple]
18:06:48 <Igloo> no
18:06:53 <mauke> that doesn't make sense
18:07:01 <reffie> why not
18:07:03 <mauke> different tuples have different types
18:07:19 <reffie> not in my case
18:07:29 <mauke> then they all have the same size?
18:07:32 <reffie> yes
18:07:35 <dons> you can write a function convert a specific tuple to a list
18:08:18 <reffie> that's what i'll do
18:08:41 <mauke> tuple4ToList (a, b, c, d) = [a, b, c, d] or something like that
18:08:55 <Igloo> You might as well just write the map-like function you want, though
18:10:21 <dons> @plugs (\f (a,b,c) -> (f a, f b, f c)) (+1) (1,2,3)
18:10:23 <lambdabot> (2,3,4)
18:18:38 <Pseudonym> Woohoo!
18:19:00 <Pseudonym> That's one arrow so-called axiom I managed to derive.
18:19:06 <Pseudonym> Only four to go.
18:19:54 <dons> managed to derive. using what?
18:20:05 <Pseudonym> You'll have to read my TMR article and find out.
18:20:26 <dons> ah!
18:21:18 <Pseudonym> My goal is to motivate the arrow axioms.
18:21:22 <Pseudonym> And I think I worked out a way to do it.
18:21:29 <Pseudonym> There is a leap of logic, though.
18:21:43 <dons> ok. cool. this sounds very interesting
18:31:04 <a5> these "rigid" error messages in 6.4 are weird
18:31:53 <skew> a5: maybe the "wobbly types" paper would make more sense of them?
18:32:07 <skew> if you are trying to figure out what they mean rather than complain about them
18:34:45 <a5> oh no they're interesting
18:34:45 <skew> I haven't seen those errors, though I have been surprised at how GADTs (fail to) propagate class constraints
18:34:48 <a5> i'll read the paper
18:35:19 <skew> There's nothing wrong with complaining about poor error messages
18:35:44 <skew> How are you getting them?
18:36:19 <reffie> god bless Pseudonym
18:36:39 <reffie> for his polynomial module
18:37:19 <dons> we usually use @karma+ for that, reffie ;)
18:37:29 <reffie> heh
18:39:45 <a5> skew: a bunch of monad composition stuff, i thought they were typical. i've been getting them everywhere
18:41:30 <a5> Left e -> return $ Left (((>>=f).e)::e->ErrorT2 e m a)
18:45:49 <reffie> the fact that Int and Integer are different sucks
18:49:38 <a5> haskell is starting to seem full of cracks to me. maybe i need to move to a "toy" language. are there any with good dependent types?
18:50:31 <dons> epigram, perhaps?
18:51:23 <Lemmih> reffie: How so?
18:51:48 <reffie> stuff like take doesn't take Integers
18:52:15 <Lemmih> @type Data.List.genericTake
18:52:20 <lambdabot> Data.List.genericTake :: forall a i.
18:52:20 <lambdabot>                          (Integral i) =>
18:52:20 <lambdabot>                          i -> [a] -> [a]
18:52:23 <reffie> ooh
18:52:32 <reffie> thakns.
18:52:42 <reffie> i just implemented my own
18:52:46 <Lemmih> You're welcome (:
19:12:20 <mwc> and then not unsplit
19:12:23 <mwc> there it goes
19:12:33 <a5> "it was jewel" :)
19:13:14 <a5> man this sucks "No instance for (SComposable IO (ErrorT ErrType (ErrorT2 [s] [])))"
19:13:40 <reffie> i don't know what data type to use to have very large "floating-point" numbers
19:13:59 <a5> Rational?
19:14:01 <mwc> reffie, hmm, ratio of Interger?
19:14:17 * mwc needs to go back to type school
19:14:18 <reffie> i need to be able to take logarithms of them
19:14:54 <mwc> Take a look at a *BSD math lib, and see what algo they use
19:15:07 <reffie> :/
19:17:46 <reffie> i guess double is enough
19:18:09 <reffie> my computer is not fast enough for numbers that are hundreds of digits long :P
19:27:06 <CosmicRay>  Say I have a darcs repo that has 21930 changesets in it.  What would be the best way to go back and tag/checkpoint at every, oh, 5000 changesets or so?
19:30:05 <Lemmih> Greetings, SyntaxNinja.
19:32:46 <SyntaxNinja>  coy0
19:33:06 <SyntaxNinja> how's everything going, Lemmih?
19:33:51 <CosmicRay> geez, it takes forever to make a checkpoint in darcs
19:34:06 <CosmicRay> 26292 pts/1    Rl+   16:59 darcs tag --checkpoint -m End of initial conversion
19:36:46 <Lemmih> SyntaxNinja: Everything's great. Done a lot of clean-up in Cabal-get.
19:37:33 <Lemmih> Thinking about finding some Windows user to test it.
19:42:39 <SyntaxNinja> Lemmih: I have an idea for a feature that would be pretty easy I bet :)
19:42:54 <SyntaxNinja> and it would help me w/ building hackage and such.
19:43:06 <Lemmih> Oh?
19:43:14 <SyntaxNinja> apt-get has a command "build-dep" which installs the build dependencies for the given package. so you could say "cabal-get build-dep hackage"
19:43:18 <dan2> CosmicRay: hey there
19:43:55 <SyntaxNinja> so since installing hackage isn't "normal" (doesn't go into /usr/local/bin) I can just get the build deps with one command
19:43:55 <dan2> CosmicRay: what makes you like darcs
19:44:06 <SyntaxNinja> then buil hackage separately
19:44:56 <SyntaxNinja> Lemmih: but there's one more thing...
19:47:24 <SyntaxNinja> can't find source for Network.Hackage.CabalGet.Info in ["."]
19:47:31 <SyntaxNinja> (but that's not the 'one more thing')
19:48:45 * SyntaxNinja taps microphone... "is Lemmih on?"
19:49:49 * Lemmih is working hard on getting 'build-dep' working before SyntaxNinja can come up with some feature requests.
19:49:53 <SyntaxNinja> haha
19:50:37 <SyntaxNinja> Lemmih: but there's one thing!
19:51:22 <SyntaxNinja> dammit, you're supposed to be like, "What is it?!"
19:51:27 <SyntaxNinja> becase you're going to do it wrong if you don't ask.
19:51:45 <Lemmih> What is it?!
19:52:27 <SyntaxNinja> Lemmih: instead of build-deps, it should be "cabal-get alexjs hackage" :)
19:52:43 <Lemmih> (:
19:56:22 <SyntaxNinja> aren't you glad you asked
19:56:42 <SyntaxNinja> you forgot to add Network.Hackage.CabalGet.Info
19:57:08 <Lemmih> Yeah. Gonna put it in the same patch as build-deps.
19:57:17 <SyntaxNinja> thanks.
19:57:48 <SyntaxNinja> maybe we should build a cabal-get self checker into it so that whenever you do a push, it'll go to /tmp and try to check itself out and build itself and its dependencies and tell you if you left out any files :)
20:02:18 <stang> SyntaxNinja, can you help out a haskell beginner real quick.  I'm just trying to get a little program using runhugs to call a function in another file.  I have module Main where    Import otherFile    main = do     func 100       func is defined as func :: Int -> Bool
20:02:49 <stang> it keeps giving me an error saying type: Bool     does not match: a b
20:02:54 <stang> where is the a b coming from?
20:03:00 <CosmicRay> a means IO in this case
20:03:12 <CosmicRay> you haven't told it what to do with the result of calling that function
20:03:18 <stang> ahhh
20:03:37 <CosmicRay> try print (func 100) to start with
20:03:40 <stang> I don't really care... I'm just using the GNU time program to see how long it takes to build the structure it builds
20:03:42 <stang> ok
20:03:44 <stang> thanks
20:04:10 <SyntaxNinja> stang: also import should be lower case
20:04:20 <stang> very nice... works like a charm!
20:04:22 <SyntaxNinja> and OtherFile should be upper case, referring to the module name
20:04:40 <stang> SyntaxNinja, yeah, I messed that line up, should have copied and pasted
20:04:45 <SyntaxNinja> @paste
20:04:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:04:51 <SyntaxNinja> paste there if you paste multi-line things
20:04:58 <stang> very handy
20:05:20 <stang> one more quick question, how is the best way to take in an Int arg from the command line?
20:05:35 <SyntaxNinja> you can use "read" to convert it from a string
20:05:46 <SyntaxNinja> and "getArgs" to get the list of arguments on the command line (as a list of strings)
20:05:57 <SyntaxNinja> @type System.Environment.getArgs
20:05:58 <stang> I was using getArgs, but didn't know how to convert
20:05:58 <lambdabot> System.Environment.getArgs :: IO [String]
20:06:09 <CosmicRay> args <- getArgs
20:06:14 <CosmicRay> let theint = read (head args)
20:07:08 <Lemmih> SyntaxNinja: Hacked, tested and pushed.
20:08:04 <stang> SyntaxNinja and CosmicRay, I really appreciate all of the help!
20:08:18 <SyntaxNinja> lemmih: Could not find module `System.FilePath
20:08:26 <SyntaxNinja> stang: np. good luck
20:09:06 <Lemmih> SyntaxNinja: I've put System.FilePath is a separate package. You can get it from scannedinavian.org/~lemmih/packages/
20:09:30 <Lemmih> (or just './cabal-get --user-install install FilePath' :)
20:09:34 <CosmicRay> does darcs tag --checkpoint go back and rebuild the entire tree from patches instead of just using what is checked out, for osme reason?
20:10:13 <SyntaxNinja> Lemmih: can you icat your /etc/cabal-get/pkg.list file for me? (priv msg if you want)
20:10:48 <Lemmih> It has data of type :: [String].
20:11:28 <SyntaxNinja> yeah?
20:11:45 <SyntaxNinja> oh no, that's not what I want...
20:11:55 <SyntaxNinja> serv.list
20:12:12 <Lemmih> So ["http://www.scannedinavian.org/~lemmih/cgi-bin/hackage/hackage?action=xmlrpc"].
20:12:46 <SyntaxNinja> cabal-get: user error (Error calling listPackages: Error parsing method response)
20:12:50 * Lemmih actually read serv.list instead of pkg.list before.
20:13:01 <SyntaxNinja> heh
20:13:10 <SyntaxNinja> probably my cabal-get and your hackage are not in sync
20:13:20 <SyntaxNinja> but since I want to use cabal-get to build it...
20:13:48 <Lemmih> The hackage server on scannedinavian is up-to-date.
20:14:15 * Lemmih is using it as secondary package server.
20:14:28 <SyntaxNinja> right, well my cabal-get isn't
20:15:26 <Lemmih> That might be a problem. (:
20:16:08 <Lemmih> I changed the protocol recently to do smarter and more efficient dependency resolution.
20:16:51 <a5> for starting template haskell, should i just read SPJ's first paper, or is there a better tutorial?
20:17:59 <SyntaxNinja> hm. getting linking errors...
20:18:05 <SyntaxNinja> @wiki TemplateHaskell
20:18:07 <lambdabot> http://www.haskell.org/hawiki/TemplateHaskell
20:18:26 <SyntaxNinja> a5: TH changes fast, so don't know if the wiki is still up to date
20:18:31 <SyntaxNinja> though I don't know what will be up to date if the wiki isn't
20:19:01 <Lemmih> no -fhide-all-packages => many build-depends mistakes.
20:19:41 <SyntaxNinja> Lemmih:  undefined reference to `NetworkziHackageziInterface_zdfEqFullDependency_closure
20:19:46 <SyntaxNinja> Lemmih: yeah, looking forward to that
20:19:52 <SyntaxNinja> don't see the problem here.
20:19:58 <Lemmih> You have to rebuild Hackage-client too.
20:20:01 <SyntaxNinja> that module is in hackage client;
20:20:02 <a5> SyntaxNinja: thanks. is it very incompatible with the original paper
20:20:03 <SyntaxNinja> yeah, I did.
20:20:07 <SyntaxNinja> a5: yes!
20:21:19 <SyntaxNinja> Lemmih: oh, just have to make clean
20:21:50 <SyntaxNinja> that is a bit of a worry actually. got bit by that before. there's no inter-pcakage dependency analysis for ghc of course.
20:22:01 <SyntaxNinja> so it doesn't know that it needs to rebuild some modules.
20:22:10 <SyntaxNinja> maybe alexj is right ;)
20:22:44 <SyntaxNinja> a5: if you can get Igloo's attention, I think he uses it a lot.
20:23:15 <SyntaxNinja> Lemmih: oops; I lied, still getting that problem.
20:24:07 <Lemmih> rm `find * -name '*.hi'` (:
20:24:31 <Lemmih> Did you reinstall Hackage-client?
20:24:44 <SyntaxNinja> Lemmih: yes. now I fixed it. had to remove old hackage-client first.
20:24:48 <SyntaxNinja> need to streamline this somehow. hm
20:25:08 <SyntaxNinja> oh, you called it build-dep! ;)
20:25:43 <Lemmih> Fooey. I introduced a bug in cabal-get with the latest patch /-:
20:29:24 <Lemmih> Bah. Stupid typo mistake.
20:29:50 <SyntaxNinja> it's not working for me; is that why?
20:30:03 <SyntaxNinja> cabal-get update no worky
20:30:22 <Lemmih> The typo made 'install' and 'info' stall.
20:31:01 <Lemmih> How doesn't it work?
20:31:41 <SyntaxNinja> cabal-get: user error (Error calling listPackages: Error parsing method response)
20:32:19 <Lemmih> Did you build the packages from the darcs repos?
20:32:40 <SyntaxNinja> yeah, and using your hackage
20:33:17 <SyntaxNinja> hm. if I use my hackage, it works.
20:33:29 <SyntaxNinja> (fresh from darcs repo)
20:33:56 <Lemmih> My hackage as in the server on shapr's box?
20:34:12 <SyntaxNinja> ja
20:34:40 <Lemmih> I blame old .hi files.
20:35:45 <SyntaxNinja> convenient excuse
20:36:20 <SyntaxNinja> is there some reason you're building a cabal-get library?
20:36:45 <Lemmih> Yes. I want other front-ends.
20:36:58 <SyntaxNinja> ok
20:37:19 <SyntaxNinja> this doesn't require an altered cabal, does it?
20:37:48 <Lemmih> It requires you to apply the cabal patch I mailed you.
20:39:10 <SyntaxNinja> I thought that just changed the verbosity
20:39:44 <Lemmih> It also exports some functions.
20:41:15 <SyntaxNinja> i got those I"m sure.
20:42:22 <SyntaxNinja> it wouldn't build if I didn't
20:42:37 <SyntaxNinja> your hackage server is the same as the code in darcs?
20:43:20 <Lemmih> Yeah. I built it some hours ago.
20:44:38 <SyntaxNinja> oh, did you change other dependencies?
20:44:41 * Lemmih ponders if he should've said 'build' instead of 'built'.
20:49:14 <Lemmih> hackage, hackage-client and cabal-get are the only packages that have changes.
20:50:17 <Lemmih> Oh wait. You probably also need to rebuild hemplate if you haven't already.
20:52:08 <SyntaxNinja> and where can I get that?
20:52:11 * Lemmih just built a fresh cabal-get on his laptop.
20:52:50 <Lemmih> darcs repo: /~lemmih/hackage
20:55:39 <Lemmih> *darcs repo: /~lemmih/hemplate
20:55:48 <Lemmih> But you shouldn't need hemplate for cabal-get.
20:57:15 <SyntaxNinja> but if your hemplate / hackage is different from mine?
20:57:30 <SyntaxNinja> I can update from my server, but not yours.
20:58:37 <Lemmih> I don't know what to do except removing hackage-client and cabal-get, and try again. /-:
20:58:48 <SyntaxNinja> formdata?
20:58:57 <Lemmih> formdata!
20:59:21 <Lemmih> Also available from the server on shapr's box.
20:59:26 <lispy> so, the io monad is consider the eye sore of haskell.  interesting
20:59:27 <SyntaxNinja> what changed in hemplate? could that effect the strings returned by the server?
20:59:34 <SyntaxNinja> lispy: by who?!
20:59:43 <SyntaxNinja> Lemmih: okok
20:59:55 <lispy> SyntaxNinja: the Simone Peyton Jones person
21:00:05 * SyntaxNinja gets ready to hand lemmeh "hardest program to build of the year" award
21:00:15 <SyntaxNinja> what does he know
21:00:44 <lispy> SyntaxNinja: are you suggesting there is a better example of an eye sore? :)
21:00:57 <SyntaxNinja> lispy: does there have to be an eye sore?
21:01:01 * SyntaxNinja doesn't have an eye sore, for instance ;)
21:01:45 <lispy> SyntaxNinja: no, but if the IO monad is haskell's only eye sore then it really is doing quite well :)
21:01:56 <SyntaxNinja> wod
21:01:57 <Lemmih> SyntaxNinja: How hard can it be? Don't try to build hackage yet.
21:01:57 <SyntaxNinja> er
21:01:58 <SyntaxNinja> word
21:02:04 <JohnMeacham> Hmm.. is the fptools darcs server hosed? it is just sitting there.
21:02:26 <SyntaxNinja> Lemmih: I can get everything to build just fine actually.
21:02:46 <SyntaxNinja> Lemmih: the hard part is that there are so many dependencies, and I don't know what to update
21:03:10 <SyntaxNinja> speaking of which, I just thought of something else we need :)
21:03:24 <Lemmih> Dependencies for cabal-get: hackage-client, FilePath, XmlRpc, HaXml.
21:03:34 <SyntaxNinja> and you haven't changed xmlrpc or haxml?
21:03:55 <Lemmih> You can get FilePath, XmlRpc and HaXml from the Hackage server (as .tgz files) and hackage-client is available from the repo.
21:04:11 <Lemmih> I've only cabalized them.
21:04:57 <SyntaxNinja> Lemmih: I'll try starting from scratch again... we should really find  away to streamline this, though. maybe we should put everything into the darcs repo and make a build script
21:05:12 <SyntaxNinja> Lemmih: I have to make a phone call, but I thought of something important.
21:05:43 <SyntaxNinja> Lemmih: if package B depends on package A, and I update package A, then I need to rebuild package B as well.
21:05:57 <SyntaxNinja> so we have to do a reverse-depends analysis too :(
21:06:07 <SyntaxNinja> but just for the packages installed.
21:06:59 <lispy> "Hackage", heh nice
21:08:30 <lispy> i kind of want to hack on something, and i sort of feel like i should veg out
21:09:31 <lispy> anyone know of a good way to learn 3d-modeling so that I can learn to make cool ray-traced scenes?
21:09:42 <Jerub> apt-get install k3b ?
21:09:56 <lispy> k3b isn't that a cd burning software?
21:10:19 <Lemmih> SyntaxNinja: ttyl. I'm going to bed.
21:10:26 <Jerub> hmm
21:10:28 <Jerub> maybe it is.
21:10:36 <Jerub> there'd a 3d modelling kde thingy...
21:10:38 <lispy> Jerub: kpov modeler?
21:11:04 <Jerub> kpovmodeller
21:11:06 <Jerub> that's the one
21:11:26 <lispy> hmm....i have terrrible luck with apt and kde, but i'll give it a try
21:11:38 <lispy> now i need a good source of learning material
21:11:45 <lispy> oh, look, google :)
21:14:37 <lispy> hmm..the documentation appears to be in french
22:52:08 <dons> @yow
22:52:09 <lambdabot> Should I do my BOBBIE VINTON medley?
22:52:11 <dons> @ghc
22:52:12 <lambdabot>   Occurs check: cannot construct the infinite type
22:52:27 <Pseudonym> @yow
22:52:28 <lambdabot> FROZEN ENTREES may be flung by members of opposing SWANSON SECTS
22:52:28 <lambdabot> ...
22:52:47 <Pseudonym> @arr
22:52:48 <lambdabot> Drink up, me hearties
22:53:28 <reffie> wooo
22:53:49 <reffie> my haskell AKS primality testing code takes 47 seconds to determine that 211 is indeed prime
22:54:01 <Pseudonym> Wooo.
22:54:06 <Pseudonym> I wonder how long mine takes...
22:54:20 <dons> why is it so slow?
22:54:45 <reffie> that's what i'm trying to figure out :)
22:54:55 <Pseudonym> Well it is a slow algorithm.  Constant factors.
22:55:02 <Pseudonym> But it has very good complexity.
22:55:06 <dons> ok.
22:55:11 <Pseudonym> But even so...
22:55:13 <reffie> Pseudonym still, it shouldn't be *THAT* slow
22:55:14 <Pseudonym> *Prime> isPrime 211
22:55:14 <Pseudonym> True
22:55:14 <Pseudonym> (0.01 secs, 3747452 bytes)
22:55:26 <dons> hehe
22:55:26 <reffie> Pseudonym AKS?
22:55:27 <Gahhh> 3 megs for that ??
22:55:38 <Pseudonym> Gahhh: Like I said, slow algorith,/.
22:55:44 <dons> reffie, ghc -O -prof -auto-all
22:55:51 <reffie> dons i'm doing it right now :P
22:55:52 <dons> ./a.out +RTS -p
22:56:02 <reffie> Pseudonym how do you display the time/memory?
22:56:10 <Pseudonym> In GHCi, I use :set +s
22:56:21 <reffie> thanks
22:56:36 <reffie> Pseudonym is yours AKS too?
22:57:20 <reffie> or is it miller-rabin or some other probabilistic algorithm
22:57:31 <Pseudonym> It's deterministic.
22:57:41 <reffie> yes AKS is
22:57:44 <Pseudonym> The one that's O((log n)^6) if the Sophie-Germain conjecture is true.
22:57:47 <reffie> but all the fast ones are probabilistic
22:57:52 <Pseudonym> And O((log n)^12) otherwise.
22:57:54 <reffie> oh, i see
22:58:02 <reffie> *Main> isPrime 211
22:58:03 <reffie> True
22:58:03 <reffie> (91.79 secs, 1611292868 bytes)
22:58:04 <reffie> :D
22:58:08 <reffie> ^- on my laptop
22:58:19 <reffie> something is _CLEARLY_ wrong.
22:58:20 <Pseudonym> I'm on a 2GHz Pentium.
22:58:30 <reffie> 1.25GHz G4
22:58:31 <Pseudonym> So it's not a super fast machine, but pretty good.
22:58:42 <dons> is it short code? how long does @plugs take?
22:58:54 <Pseudonym> Mine is about 100 lines.
22:59:01 <dons> ok. bit long for irc..
22:59:03 <Pseudonym> It requires polynomial arithmetic.
22:59:09 <reffie> mine is about 100 lines too
22:59:26 <Pseudonym> Unsurprising, since we're most likely using the same polynomial library...
22:59:47 <reffie> Pseudonym kinda, yeah
23:00:14 <Pseudonym> How are you computing p^n (mod m)?
23:00:22 <reffie> powerModIPoly a p mp m = foldr1 (\x y -> modIPoly (modPoly (mulPoly x y) mp) m) $ genericTake p $ repeat a
23:00:34 <Pseudonym> Aaaah.
23:00:39 <Pseudonym> Don't do that. :-)
23:00:43 <Pseudonym> You can do it O(log n).
23:01:03 <reffie> hm
23:01:03 <Pseudonym> Roughly:
23:01:47 <Pseudonym> powmod x n m | n `mod` 2 == 0 = let xn2m = powmod x (n `div` 2) m
23:02:00 <reffie> i've seen this somewhere
23:02:05 <Pseudonym>                                      in mod (xn2m * xn2m) m
23:02:07 <reffie> but i don't really understand it
23:02:13 <reffie> but i guess i'll try harder to understand
23:02:15 <Pseudonym> Well, it's based on this idea:
23:02:25 <Pseudonym> x^(2n) = (x^n)^2
23:02:32 <Pseudonym> x^(2n+1) = (x^n)^2 * x
23:02:43 <Pseudonym> And, of course, you need base cases.
23:02:49 <Pseudonym> x^0 = 1, x^1 = x
23:03:14 <Pseudonym> Similarly, x^(2n) mod m = (x^n mod m)^2 mod m
23:03:29 <Pseudonym> And x^(2n+1) mod m = ((x^n mod m)^2 * x) mod m
23:04:46 <reffie> hm
23:04:52 <reffie> ah i see
23:05:49 <Pseudonym> *Prime> isPrime 123887
23:05:50 <Pseudonym> True
23:05:50 <Pseudonym> (1.80 secs, 73598444 bytes)
23:05:54 <Pseudonym> Starting to take a bit longer there.
23:08:08 <Pseudonym> For small primes, like below 10 digits or so, it's still easiest just to factor.
23:08:18 <Pseudonym> Especially if you're careful about how you do it.
23:17:40 <Gahhh> what's its space efficiency ?
23:18:01 <Gahhh> neither wikipedia nor wolfram has it
23:18:03 <Pseudonym> Linear in (log n) I'm pretty sure.
23:18:27 <Pseudonym> It only ever deals in polynomials with degree at most n.
23:19:10 <Pseudonym> And the number of them that it needs is bounded, I'm pretty sure.
23:20:01 <Gahhh> yours looks like ~ 9*log(n) in bytes
23:20:20 <Gahhh> need a 3rd point tho
23:20:30 <Pseudonym> @plugs 73598444 / log 123887
23:20:32 <lambdabot> 6275915.2928773
23:20:53 <Pseudonym> Mind you, that's the amount of transient storage, not the peak heap size.
23:20:58 <Gahhh> ah
23:20:59 <Pseudonym> I think.
23:21:27 <Gahhh> well, either way it's eating up memory fast heh
23:21:41 <Pseudonym> Yup=.
23:22:20 <Gahhh> have you followed that hamming number thread on ltu till the end ? it's nuts imho
23:22:29 <Pseudonym> Compare this with:
23:22:34 <Pseudonym> Prelude WheelPrime> factor 1230719238733
23:22:34 <Pseudonym> [1230719238733]
23:22:34 <Pseudonym> (0.23 secs, 45670536 bytes)
23:22:43 <Pseudonym> Yeah, I contributed a bit, too.
23:22:56 * Pseudonym did the C++ version with the boost iterator adaptor
23:23:03 <Pseudonym> And I'm still sane, which is the bizarre part.
23:23:06 <Gahhh> when you posted the c++ code, it was around 20 comments or so
23:23:13 <Gahhh> now it's up to 110+
23:23:14 <Pseudonym> I did read on.
23:23:14 <mflux> ltu?
23:23:23 <mflux> ah, lambdaetc
23:23:33 <Gahhh> teh... ulti..
23:23:52 <mflux> they should provide nntp backend
23:23:55 <mflux> they don't, do they?
23:24:02 <Pseudonym> No, but they do have RSS.
23:24:13 <mflux> hmm, does gnus handle rss?
23:24:15 <Gahhh> One guy actually posted a mathematica file today. I was going to download mathreader to read it.
23:24:17 <Pseudonym> Without reading TFA, I actually expected more from Andrew Koenig.
23:24:34 <Pseudonym> "Without learning a new style of programming..."
23:25:08 <Pseudonym> Why in $DEITY's name are you computing Hamming numbers if you're _not_ trying to learn something.
23:25:11 <mflux> is this the old article about a c++ program and the matching haskell version, which is slower and less intuitive or something?
23:25:20 <Gahhh> allegedly slower
23:25:32 <mflux> I imagine the version they provided was
23:25:41 <Gahhh> no
23:25:44 <mflux> oh
23:25:48 <Gahhh> it was not allegedly slower
23:25:52 <mflux> never mind then ;)
23:26:00 <Gahhh> it was faster actually
23:26:09 <Gahhh> in O(n) sense
23:26:14 <Pseudonym> Welll... that's disputable.
23:26:21 <Pseudonym> TFA's version is O(n log n).
23:26:28 <Pseudonym> The Haskell version is O(n).
23:27:06 <Pseudonym> So eventually the Haskell version would overtake the C++ version in speed.
23:27:12 <Pseudonym> Assuming memory doesn't explode first.
23:27:19 <Gahhh> is that before the C++ runs out of bits ?
23:27:41 <Pseudonym> On a 128 bit architecture, no.
23:29:08 <Gahhh> bad choice of problem to compare languages
23:29:18 <reffie> ok, i improved it a bit
23:29:23 <reffie> (51.35 secs, 1199307208 bytes) :P
23:29:54 <Pseudonym> Cool. :-)
23:30:04 <reffie> still waaaay too slow, though
23:30:16 <Pseudonym> Gahhh: Well, the thing is, Haskell programmers kind of use it as an example.
23:30:27 <Pseudonym> "Look how cool it is!  Try doing THIS in C++!"
23:30:46 <Pseudonym> So the C++ people are only fighting fire with fire.
23:31:01 <Pseudonym> Kind of like the functional formulation of quicksort.
23:32:37 <reffie> it seems that multiplication is what is taking most of the time and space, now
23:34:46 <Gahhh> Pseudonym: That is true. If that's your only attack vector, they are going to defend it there. What needs to be demonstrated is a few pages (not lines) of haskell code surpassing c++ in many aspects.
23:34:53 <Pseudonym> Right.
23:35:12 <Pseudonym> There's really only one fair way to compare the two languages.
23:35:14 <reffie> it is a lot faster on my athlon 2200, though
23:35:21 <reffie> 4.87s user 0.02s system 76% cpu 6.394 total
23:35:23 <Pseudonym> Get a nontrivial application, and get two teams to write it.
23:35:33 <reffie> compiled.
23:35:34 <Pseudonym> Then compare the results on correctness, robustness and efficiency.
23:36:40 <Gahhh> Pseudonym: Are the entries to the ICFP compos public ?
23:37:41 <reffie> i wonder if it's because i don't mod the intermediate results
23:38:21 <Pseudonym> I don't think so.
23:38:27 <Pseudonym> It's up to the team, I believe.
23:38:32 <Pseudonym> reffie: Could be.
23:41:15 * Gahhh is designing a VB API for programming-impaired people...
23:42:03 <Pseudonym> I did one of those in Haskell
23:42:12 <Gahhh> ?
23:42:12 <Pseudonym> module Simple (drool) where
23:42:15 <Pseudonym> drool :: IO ()
23:42:28 <Pseudonym> The implementation is left as an exercise.
23:42:59 <reffie> moding the intermediate results improved it a bit more
23:43:00 <reffie> (40.11 secs, 741928356 bytes)
23:43:36 <Pseudonym> Did you change it to an O(log n) power-mod?
23:43:40 <reffie> yes
23:43:40 <Pseudonym> Rather than the one you had?
23:43:43 * Pseudonym nods
23:43:55 <reffie> 3.02s user 0.03s system 80% cpu 3.804 total
23:43:57 <reffie>  on my athlon
23:43:59 <reffie> much better
23:56:01 <Itkovian> meuning
23:56:28 <reffie> i think my O(log n) powerMod is wrong.
23:57:11 <reffie> because it does 1373 polynomial multiplications, while it's called 1000 times
23:57:25 <reffie> it should do at most 10 multiplications.
23:57:38 <Itkovian> hi boegel
23:58:03 <boegel> hi Itkovian
23:59:00 <reffie> err
23:59:02 <reffie> nevermind
23:59:18 <reffie> maybe i should go to bed.
