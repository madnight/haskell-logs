00:43:35 <scalopus> hi
00:44:15 <Lemmih> Hey
00:46:52 <Itkovian> hi
01:05:02 <sethk> ho
02:35:30 <shapr> good morning #haskell!
02:36:07 <Lemmih> Hey shapr.
02:36:16 <Lemmih> How's life?
02:36:25 <shapr> Anyone familiar with QuickCheck's internals? I think I know how to do unit testing with QuickCheck but I want to discuss it with someone else.
02:37:01 <shapr> oh, life is about the same. How's yours?
02:37:53 <Lemmih> Kinda sucks. Just realized how badly I need to learn more math.
02:38:30 <shapr> Me too.
02:38:44 <shapr> But there's a lot of math available directly on wikipedia.
02:39:34 <shapr> http://en.wikipedia.org/wiki/Logarithms
02:40:05 * Lemmih got many math books.
02:40:32 <Lemmih> But I find math hard to remember when I don't use it.
02:41:54 <shapr> At this particular moment, I'm trying to figure out how to produce a (Int -> StdGen -> a) that sensibly returns the next test value in a unit test series, no matter what seed it gets.
02:41:57 <tuomov> wikipedia isn't that good for learning math
02:42:08 <shapr> tuomov: what is good for learning math?
02:42:12 <tuomov> you want a book with exercises etc.
02:42:39 <shapr> Me personally, I do better with the background conceptual explanations and the big picture. Wikipedia gives me that.
02:43:09 <tuomov> the accessibility of the articles in wikipedia also varies considerably
02:43:48 <tuomov> of course, books are expensive, but the web is full of lecture notes as well
02:43:52 <tuomov> their quality also varies a lot
02:46:02 <tromp> i
02:46:05 <tromp> i
02:46:05 <tromp> i
02:46:18 <tromp> sorry:-(
02:46:44 <shapr> egotist!
02:47:11 <tromp> thought i was typing in my MUD window:)
02:48:07 * shapr grins
02:52:04 <nlv11757_> can you have ghc compile a file without requiring it to have a main function?
02:52:16 <nlv11757_> or should i use --make on the main file instead?
02:52:24 <sylvan> just compile it without make?
02:52:48 <nlv11757_> ghc -c blabla still complains about blabla not having a main function
02:53:24 <sylvan> that's strange
02:53:43 <nibro> nlv11757_: -no-hs-main or -hs-no-main, don't remember
02:53:53 <JaffaCake> if it's module Main, it should have a main function
02:54:37 <nlv11757_> its not module Main
02:54:54 <JaffaCake> if you omit the module declaration, it defaults to 'Main'
02:55:25 <nlv11757_> ah
03:04:50 <nlv11757_> can you tell ghc that a certain module is the main module, which has a different name
03:04:57 <nlv11757_> so it doesnt have the name Main
03:07:49 <nibro> nlv11757_: -main-is
03:07:51 <JaffaCake> nlv11757_: check out the -main-is flag
03:08:01 <nlv11757_> ok thanks
03:18:03 <poetix> Python, Reduce & Haskell: How They Are Related - http://codepoetics.com/poetix/index.php?p=107
03:18:15 <theorbtwo> Hm, any hs-plugins people about?  Does it have problems with recrusive dependencies?  (IE the existance of -boot files?)
03:19:23 <autrijus> poetix: nice!
03:19:34 <autrijus> oh no, -boot
03:19:46 <autrijus> will I be forced to shove everything back to AST.hs?
03:20:09 <autrijus> theorbtwo: there is an additional .hi-boot interface file generated
03:20:15 <theorbtwo> I know.
03:20:25 <theorbtwo> Perhaps I should try loading that explicitly.
03:20:44 <autrijus> nod.
03:20:51 <autrijus> in worst case I can just fold things back to AST.hs
03:20:59 <autrijus> and do away with recursive deps
03:21:27 <theorbtwo> Hm, not sure how to do that -- there's only an AST.o, no AST.o-boot, and it wants the name of the o file.
03:21:49 <autrijus> dons: help :)
03:21:55 <theorbtwo> @seen dons
03:21:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons is in #haskell. Last spoke 3 hours 34 minutes 28 seconds ago.
03:23:14 <JaffaCake> hs-plugins should ignore the .o-boot, I believe
03:23:33 <theorbtwo> The problem is that it's not picking up a bunch of dependencies.
03:23:50 <theorbtwo> In purticular, dependencies of the file that has a -boot version.
03:24:12 <JaffaCake> ah, then I don't know - how does hs-plugins normally figure out dependencies?
03:24:17 <theorbtwo> Yes.
03:34:53 <shapr> hiya poetix!
03:35:21 * poetix is meant to be working...
03:35:32 <shapr> me too
03:35:48 <shapr> poetix: I love the picture, that's great :-)
03:36:01 <tromp> does anyone know about layout of bitfields in C?
03:38:22 <theorbtwo> Try finding the ABI document for your arch.
03:51:16 <shapr> g'day blackdog
04:03:44 <blackdog> g'day shapr
04:04:56 <autrijus> gah. is there no lazy mode in IO monad?
04:05:12 <autrijus> can I run a ST.Lazy transfomer on top of IO?
04:05:50 <autrijus> wait... that would be unsafe.
04:06:08 <Lemmih> Lazy IO sounds evil.
04:06:54 <autrijus> no, I merely want to use STRef
04:06:58 <autrijus> inside IO
04:07:10 <shapr> Since the whole program is pulled by the horse of 'main :: IO a' wouldn't that break if IO were lazy?
04:07:17 <autrijus> not outside it as runST will have me
04:07:27 <autrijus> yeah, there's that.
04:07:31 <shapr> Maybe that's just my mental model that would break?
04:07:38 * autrijus ponders what will happen if one uses unsafeInterleaveIO on writeIORef.
04:07:46 * autrijus tries out
04:07:46 <shapr> I've seen it done.
04:07:52 <autrijus> oh. makes sense?
04:08:02 <shapr> I don't know, but some people do it :-)
04:08:19 <autrijus> hrmph.
04:08:54 <shapr> I stay away from unsafe*, I'm convinced I'm going to shoot myself in the foot if I start using them.
04:09:01 <JaffaCake> autrijus:  stToIO?
04:09:04 <Lemmih> @plugs do x <- newIORef [1..]; modifyIORef x (map succ); fmap head (readIORef x)
04:09:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `newIORef'
04:09:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `modifyIORef'
04:09:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `readIORef'
04:09:42 <shapr> I understand unsafeCoerce as "Haskell as untyped lambda calculus", so I can handle that part.
04:09:52 <autrijus> JaffaCake: no... I'm asking whether there's a safe way to do unsafeIOToST
04:09:59 <autrijus> then I reasoned it makes no sense
04:10:16 <JaffaCake> you're right, it doesn't :)
04:14:14 <Lemmih> shapr: Can I get you to setup another wiki on scannedinavian.org?
04:14:20 <shapr> maaaybe
04:14:22 <shapr> what for?
04:15:41 <Lemmih> For me and my Haskell projects. Continuously updating the static HTML page is tedious.
04:16:02 <shapr> Why not put your info on the Haskell Wiki?
04:16:52 <Lemmih> I would like a separate page for most of my projects.
04:18:07 <Lemmih> Using the hawiki as a development blog would be close to spam.
04:19:54 <shapr> I see your point. I think a Haskell project collective would be the best solution.
04:20:05 <shapr> snowblind is going down soon (though I've been saying that for months now).
04:20:39 <shapr> Weatherwax will be up... real soon now.
04:25:06 <shapr> Lemmih: Let me check the status of the possible collective.haskell.org first.
04:34:30 <dons> theorbtwo: did you solve your hs-plugins issue?
04:34:49 <dons> I'm not sure of the behaviour with .o-boot files. hasn't been tested yet...
04:38:44 <theorbtwo> Oh, hi, dons.
04:38:47 <theorbtwo> No, I haven't yet.
04:39:27 <theorbtwo> Part of the problem is that there isn't a .o-boot, only a .o-hi.
04:39:36 <tromp> seems C has no struct constants...
04:40:12 <shapr> I have often felt that C is inconstant. But that may be just my inattention to detail.
04:41:03 <theorbtwo> I'm not sure it makes sense for a struct to be const -- you can never change the entirety of a struct.
04:41:19 <theorbtwo> Ah, got it.
04:42:00 <theorbtwo> If I dump the .hi-boot file, and load the things that it's listed as requiring, then load the .o file, I survive.
04:42:25 <tromp> i wanted to simply assign {0,0} to a struct variable
04:42:33 <theorbtwo> Ah, that'd be a literal.
04:42:56 <tromp> yes, the Index of the C manual said "see Constants" when i looked up Literals:(
04:43:15 <theorbtwo> They exist in C99.
04:43:24 <theorbtwo> Try (struct foo){0,0}.
04:43:37 <tromp> that makes no sense
04:44:17 <tromp> a cast shld not affect the parsability of what follows
04:44:39 <theorbtwo> Except without a cast, there is no way for the compiler to know what struct that {0,0} is.
04:45:07 <tromp> the type of variable assigned to
04:47:27 * theorbtwo shrugs.
04:47:48 <theorbtwo> I'm just getting this out of the gcc manual -- 5.20 Compound Literals.
05:02:26 <tromp> you're right; it does compile, theorbtwo
05:02:40 <tromp> i still think it's weird though:(
05:04:39 <glimming> What's the best GUI library to use on Solaris for writing a game e.g. Tetris?
05:05:15 <glimming> Feedback for mini-projects kindly requested: http://www.nada.kth.se/kurser/kth/2D1456/
05:05:18 <shapr> OpenGL?
05:05:22 <Lemmih> SDL?
05:05:36 <glimming> Not sure, just "easy to use" and works with Haskell...
05:05:53 <Lemmih> SDL+OpenGL works great with Haskell.
05:05:55 <glimming> I liked the idea of using wxHaskell but the system administrators at my department says it does not work with Solaris.
05:06:04 <glimming> Aha, do you wrap them in some library?
05:06:10 <shapr> glimming: Not about the projects themselves, but having vCalendar info on there is quite nifty.
05:06:30 <glimming> Yeah, the things you do for your students...
05:06:54 <glimming> Btw, any additional project specifications are welcome if you have something you want done.
05:06:55 <shapr> Do you have vCalender Haskell source?
05:06:56 <Lemmih> glimming: GHC ships with a fine OpenGL binding and I'm about to release 0.2 of my SDL binding.
05:07:07 <glimming> Argh, Haskell source? Is there such? No I do not!
05:07:16 <glimming> Aha.
05:07:29 <glimming> Can you refer me to some URL which documents this OpenGL binding with some sample programs?
05:07:41 <glimming> Maybe OpenGL is enough for Tetris?
05:08:00 <Lemmih> You either need to use GLUT or SDL with OpenGL.
05:08:01 <glimming> (though the SOE textbook by Hudak uses some other library which is well-described in his books)
05:08:12 <glimming> Which come with GHC by default?
05:08:20 <Lemmih> GLUT but SDL is far more pleasant IMHO.
05:08:36 <glimming> The system administrators are reluctant to spend more time on installing stuff it seems.
05:08:49 <glimming> Hmmm. But is it "pure" so it has a flavor of Haskell, e.g. monads etc?
05:08:52 <glimming> do-notation?=
05:09:17 <Lemmih> Huh?
05:09:43 <glimming> Is GLUT for Haskell???
05:09:49 <shapr> glimming: if you're comparing FP and OO, there may be some useful info here - http://c2.com/cgi/wiki?FpVsOo
05:09:58 <glimming> The GLUT library has both C, C++ (same as C), FORTRAN, and Ada programming bindings
05:10:22 <glimming> thanks, that was nice
05:10:31 <glimming> the above line was a quote from opengl.org
05:10:48 <glimming> Ok.
05:10:53 <glimming> I found GLUT in hierarchical libs
05:11:31 <Lemmih> GLUT doesn't work in GHCi and doesn't supply any means of loading image files.
05:11:32 <shapr> TaPL is a good choice for reference literature there, I learned a lot about doing really useful stuff with lambda calculus from the beginning of TaPL.
05:11:53 <glimming> HGL is pronounced Haskell GL ?
05:13:42 <xerox> hi
05:13:47 <Lemmih> Hey xerox.
05:15:07 <glimming> [glimming@fire glimming]$ ghc test.hs
05:15:08 <glimming> test.hs:3:
05:15:08 <glimming>     Failed to load interface for `Graphics.HGL':
05:15:09 <glimming>         Could not find interface file for `Graphics.HGL'
05:15:09 <glimming>         (use -v to see a list of the files searched for)
05:15:17 <glimming> Something wrong with Graphics.GHL on Mac OS X?
05:15:28 <Lemmih> Try with -package HGL.
05:15:39 <Lemmih> Or --make
05:16:05 <theorbtwo> Try sticking {-# GHC_OPTIONS -package HGL #-} at the top of the file.
05:16:14 <nlv11757_> if i only want to use a key-value pair kind of datatype to do lookups (so the key-value pairs are static), is [(.., ..)] suitable then? or inefficient?
05:16:29 <glimming> [glimming@fire glimming]$ ghc -package HGL test.hs
05:16:30 <glimming> ghc-6.2: unknown package name: HGL
05:16:44 <shapr> nlv11757_: I think it'll be significantly slower than Data.Map, but why not try it to see what's significant to you?
05:16:55 <Lemmih> glimming: Upgrade to 6.4
05:17:09 <nlv11757_> because i might discover what is significant in a later stage :D
05:17:11 <shapr> nlv11757_: or even better, go ahead and use [(x,y)] and only change when you're done, if profiling shows you need to.
05:17:15 <dons> inefficent. use Map.fromList
05:17:28 <nlv11757_> but with Data.Map i cant go wrong i understand?
05:17:39 <shapr> Data.Map is faster than Data.FiniteMap
05:17:41 <dons> if it's static, you could encode it as a function, right?
05:17:48 <dons> f key = val
05:17:56 <nlv11757_> ow lol
05:17:57 <dons> even generate it with TH
05:18:03 <nlv11757_> didnt even struck my mind
05:18:10 <dons> well, if you're interested in speed..
05:18:20 <glimming> ghc-6.2.2 was installed by system administrators, will it work with it? HGL I mean.
05:18:26 <nlv11757_> well i just dont want to lose speed to simple things like this
05:18:41 <dons> i doubt Map will be a problem. profile later.
05:18:50 <nlv11757_> all these kind of small additions can have a significant impact in total
05:19:15 <nlv11757_> but use Map over [(..,..)] i understand?
05:19:28 <dons> [(,)] is slower than map. O(n) lookup vs O(log n)
05:19:51 <Lemmih> glimming: Not without installing HGL.
05:20:02 <nlv11757_> k thanks dons and shapr
05:20:05 <dons> it's very common to see: mytable :: Map x y ; mytable = Map.fromList [(,)... ]
05:20:43 <nlv11757_> that's for easy initialization
05:20:57 <shapr> If you want speed advice, listen to dons and JaffaCake
05:21:06 <glimming> Lemmih, so X11 support came with 6.4 --- can I tell this to my sys admin?
05:21:24 <dons> I say if it's static, write a function. let ghc and gcc optimise the association
05:22:52 <Lemmih> glimming: Yeah, GHC 6.4 comes with an binding to X11.
05:23:14 <glimming> many thanks
05:23:21 <glimming> Email me if you get any ideas on mini-projects.
05:23:28 <glimming> In particular, I have been sketching on this:
05:23:41 <glimming> http://www.nada.kth.se/kurser/kth/2D1456/view.php?arg=P9.h
05:23:58 <glimming> which should be a TeX preprocessor of sorts, similar to lhs2TeX but for lambda calculus mostly
05:24:04 <shapr> glimming: Oh, the Rabhi and Lapalme book is great! That's perfect for 'Program Transformations' Burstall & Darlington rock!
05:24:25 <glimming> Burstall & Darlington?
05:24:48 <shapr> Yeah, they're the guys who wrote transformation system that Rabhi & Lapalme use throughought the book.
05:25:06 <glimming> Nice, yes I have that book.
05:25:11 <shapr> "throughout" My spelling is broken today.
05:25:17 <glimming> I will use it, thanks!
05:25:50 <glimming> There are so many things you could do in Haskell. If anybody of you guys are interested in taking this course let me know and we can try to get you in.
05:26:02 <glimming> There is a take-home exam + mini-project so you can get credits for coding.
05:26:24 <glimming> However, the actual registration bussiness is to be done at KTH not me. This is probably the hard bit.
05:26:41 <glimming> Email me if you have any other proposals for mini-projects!
05:27:10 <glimming> You may even want to write your own mini-project specification...
05:27:19 <glimming> Good bye for today!
05:28:06 <Lemmih> shapr: Status on the collective wiki page?
05:29:12 <shapr> My corporate contact is not online at the moment.
05:30:38 * hellish is lost is the hslibs source.
05:31:00 <shapr> hellish: looking for something in particular?
05:32:55 <hellish> shapr: Text.Regex.
05:33:23 <shapr> libraries/base/Text/Regex.hs ?
05:33:40 <hellish> How do modules map to source files?
05:34:10 <JaffaCake> map (\c -> if c=='/' then '.' else c) . (++ ".hs")
05:34:29 <JaffaCake> or something
05:34:47 <shapr> hey, random GHC feature request, what about triple quoted strings?
05:34:55 <shapr> and what about trailing commas in lists?
05:35:08 <JaffaCake> triple quoted strings?
05:35:34 <shapr> With triple quoted strings in Python, anything between two sets of triples quotes is a literal, including \n
05:36:10 <shapr> Right now it's a real pain to build long strings with embedded \n chars in Haskell source.
05:36:11 <johs> You mean rawstrings?
05:36:18 <johs> Ah.
05:36:21 <johs> Sorry, I got it now.
05:36:44 <johs> But rawstrings are nice too, though.
05:36:46 <JaffaCake> seems plausible, but you'd get \r\n at the end of a line on Windows, right?
05:36:59 <johs> JaffaCake: Depends on the encoding of the file, I imagine.
05:37:11 <johs> You can save files with Unix-encoding on Windows, too.
05:37:17 <JaffaCake> yup
05:37:29 <shapr> For example, pugs has "\\n   Str       pre     hex     (Int)\" lines at the bottom of http://svn.perl.org/perl6/pugs/trunk/src/Prim.hs
05:38:04 <shapr> Anyway, as for the other feature request... I like to build lists such that I can comment out any item and it all still works.
05:38:19 <shapr> I can do that in Python because the last item in a list can have a trailing comma
05:38:29 <JaffaCake> I agree - in fact GHC used to have loads of little generalisations to the syntax like that
05:38:31 <shapr> [foo,bar,baz,]
05:38:38 <shapr> used to?
05:38:38 <JaffaCake> but over time, we removed them
05:39:14 <JaffaCake> because the other compilers don't support them, and it just means that souce code becomes less portable too ofen for no good reason
05:39:18 <shapr> oh
05:41:08 <shapr> So I guess the best bet is to suggest them for Haskell 2?
05:41:25 <JaffaCake> sure - or get the other compilers to agree to the change
05:41:35 <johs> shapr: ITYM "Haskell 2005"
05:41:43 <johs> ("Extreme Edition")
05:41:49 <shapr> johs: Right, exactly
05:42:25 <Lemmih> ITYM?
05:42:32 <xerox> "I think you mean"
05:42:45 <Lemmih> Ah.
05:42:50 <johs> Lemmih: Often followed by "HTH, HAND."
05:42:59 <johs> Lemmih: ("Hope this helps, have a nice day.")
05:43:13 <JaffaCake> anyone remember YHGMTPO..
05:43:29 <shapr> wtf doesn't know it.
05:43:37 <xerox> It does here.
05:43:40 <JaffaCake> you have greatly misunderstood the purpose of
05:43:41 <johs> JaffaCake: Did you just make that up?
05:43:48 <johs> :)
05:44:06 <xerox> Oh, no YHGMTPO sorry.
05:45:46 <nibro> dons, still awake?
05:46:22 <nibro> @seen dons
05:46:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons is in #haskell. Last spoke 24 minutes 58 seconds ago.
05:47:36 <dons> heya nibro.
05:48:10 <xerox> Who binds more tightly between (.) and ($) ?
05:48:21 <TheHunter> evening dons.
05:48:24 <tromp> $
05:48:30 <dons> hey TheHunter
05:48:44 <xerox> TY tromp.
05:48:59 <TheHunter> f . g . h $ x === f $ g $ h $ x
05:49:15 <nibro> dons, what happened to 'mergeToDir'?
05:49:35 <xerox> wouldn't "return $ VInt $ toInteger $ tdSec $ diffClockTimes clkt epochClkT" be nicer with (.) and a ($) ?
05:49:36 <nibro> your Plugins.Make has a comment in it
05:49:36 <tromp> oops, i was confused with plain application
05:49:38 <nibro> -- | Niklas wants mergeToDir
05:49:42 <nibro> ;)
05:49:52 <TheHunter> xerox, in my opionion: definitely yes.
05:49:57 <dons> oh. that comment..
05:50:01 <tromp> f g . h = (f g) . h
05:50:13 <dons> I think that means "implement this"
05:50:14 <dons> ;)
05:50:15 <xerox> tromp, yeah, and it's nice.
05:50:26 <nibro> I suppose it does... want my version?
05:50:41 <dons> it'll get in faster if you send me your code :)
05:51:03 <nibro> not sure it's the nicest way to implement it, but I'm sure you can refactor it if you want to ;)
05:51:26 <dons> yeah. I'll be sure to hack away at it :)
05:52:00 <shapr> does ($) vs (.) have any effect on the laziness?
05:52:44 <tromp> shldnt
05:52:50 <TheHunter> that stuff gets inlined anyway.
05:52:54 <dons> (.) f g x = f (g x) vs f $ x =  f x
05:53:06 <dons> {-# INLINE ($) #-}, {-# INLINE (.) #-}
05:53:29 <basti_> hi
05:53:58 <shapr> hi basti_
05:55:07 <nibro> dons, bombs away
05:55:59 <lightstep> they are inlined, but still effect the meaning of the source file
05:56:38 <dons> looks good nibro
05:58:23 <TheHunter> hmm, so what exactly does this mean "gaim considers notices to be personal messages". A popup each time a notice is sent?
05:59:02 <nibro> dons, in cvs tonight then? =)
05:59:16 <dons> have to be tomorrow, a bit busy atm.
05:59:28 <shapr> man, yi is *fast*
05:59:41 <dons> yay!
05:59:54 * shapr is playing with --as=emacs
06:00:39 <nibro> dons, no hurry, I've used my own files for a few months now, I can use them a while longer... ;)
06:00:41 <lightstep> where is yi?
06:00:55 <theorbtwo> TheHunter -- shows in a different tab, and pops up if you have gaim set to pop up on IMs but not chats.
06:01:04 <dons> @google yi text editor
06:01:05 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.cse.unsw.edu.au/~dons/yi.html
06:01:18 <xerox> We got @google? Yay.
06:01:21 <shapr> dons: you think ? as a postfix lambdabot command char is too bizarre?
06:01:44 <dons>  what would the syntax be?
06:01:44 <vegai> when will they release 0.2?
06:01:49 <vegai> they/you
06:02:06 <shapr> So that when people type something like "yi?" by itself on a line, it'd execute that lambdabot command.
06:02:10 <dons> vegai, probably in a couple of months, i'm scheduling some yi time.
06:02:11 <TheHunter> theorbtwo, does that mean it's annoying?
06:02:14 <shapr> basically, a factoid command
06:02:19 <xerox> @version
06:02:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p216, GHC 6.4 (OpenBSD i386)
06:02:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:02:26 <vegai> dons: all right
06:02:36 <theorbtwo> Annoying for me, hunter.
06:02:47 <vegai> I'll make packages for everything it depends on in the meanwhile
06:02:58 <dons> shapr, wouldn't that clash with lots of normal text. what about ?query
06:03:32 <dons> or @query?
06:03:33 <shapr> Yeah, it would clash. Hm.
06:03:35 <vegai> I once made a scheme bot that just interpreted s-expressions as commands to it
06:03:48 <TheHunter> ok, in this case, i think we should revert to the old lambdabot behavior, and perhaps implement our own "loop detection".
06:03:50 <vegai> it was pretty evil on #scheme
06:03:53 <lightstep> doesn't lambdabot answer private messages and more?
06:04:06 <dons> sure it does.
06:04:08 <vegai> lightstep: sure it does?
06:04:18 <xerox> Hm.. I think it would not be _that_ annoying if lambdabot doesn't repeat itself too often, e.g. doesn't repeat something if it was said in the last N lines.
06:04:21 <shapr> What about only responding to "command?" without whitespace and not showing a negative response if the command doesn't exist?
06:04:23 <lightstep> oh. so my client just sucks
06:04:42 <dons> shapr. hmm. that's doable.
06:04:56 <dons> would you like to grep the logs to see how often that pattern appears?
06:04:58 <shapr> I'm just trying to find some way to do auto-factoids.
06:05:05 <shapr> Good idea
06:05:24 <xerox> "where is ..?" "what is ..?" it's probably a common (case insensitive) pattern, I bet.
06:05:27 <shapr> I would guess that it only appears when someone wants to know what that thing is, but grep'ing the logs would give real proof.
06:05:52 <dons> I'd just like to see how often it clashes with responses to odd user statements.
06:06:11 <dons>   when someone says something MegaMonad-ish, and I say "what?"
06:06:28 <shapr> Yeah, good point.
06:06:44 <dons> "are you on crack?", etc.
06:07:21 <dons> ? foo
06:09:35 <lightstep> can't the @learn/@remember module be used?
06:10:00 <bourbaki> moin
06:10:14 <shapr> lightstep: it could, but that requires a specific command to activate.
06:10:15 <dons>  not @remember. but something similar, if we wanted to develop our own knowledge
06:10:37 <dons> esp now we have persistence. (did you know that shapr?)
06:10:47 <shapr> I'm thinking about something where you can put in factoids, but they automatically get spit out for something like "SICP?" or "SICP ?"
06:11:02 <shapr> yeah, I saw that in the patch log, haven't started to use it yet though.
06:11:20 <shapr> I am thoroughly curious how TheHunter got around "themodule"
06:11:32 <dons> yeah, so "@fact key some fact" and "key?"
06:11:37 <shapr> right, exactly
06:12:15 <lightstep> hm, the yi wiki isn't active
06:12:25 <shapr> lightstep: you can activate it!
06:12:53 <shapr> Of course, post-emacs stopped because all the discussion happened here on #haskell
06:13:04 <dons> yeah.
06:13:42 <bourbaki> hey boegel
06:13:51 <lightstep> does nhc support the mtl?
06:14:10 <dons> i'll check.
06:14:12 <bourbaki> shapr: reading about themodule thingy can id still like to get my IGing thingy into the haskell bot here
06:14:44 <shapr> I like the enthusiasm that gets generated from instant feedback, but I sometimes miss the permanent record and more careful thought of mailing lists. (or I could just think more carefully before saying stuff in IRC, I guess)
06:14:46 <lightstep> skimming through the yi source, i don't see monad transformers. but i did see a portability note about nhc
06:14:50 <shapr> bourbaki: send it to dons
06:15:31 <dons> lightstep, no mtl in yi. some thought on porting to nhc98. i've got a full porting list from discussion with malcolm
06:15:32 <bourbaki> dons: what is the modus operandi you would prefer me sending you my stuff via email or posting it to a site of your choice?
06:15:39 <dons> darcs send!
06:15:42 <dons> @version
06:15:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p216, GHC 6.4 (OpenBSD i386)
06:15:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:15:51 <dons> add your patches, darcs send.
06:16:08 <Igloo> dons: What porting list?
06:16:25 <dons> just what would have to be done to get yi ported.
06:16:31 <xerox> What does it mean "where Just uri = parseURI url" ?
06:16:32 <Igloo> Can I see it?
06:16:33 <dons> threads and dynamic linking
06:16:49 <Igloo> Ah, OK, likely to be very different to the darcs one, then
06:16:56 <xerox> What does the Just on the left hand side means?
06:17:20 <dons> really? wouldn't threads be the same problem?
06:17:31 <TheHunter> xerox, that's just usual (non-exhaustive) pattern matching
06:17:42 <xerox> TheHunter, ah! TY.
06:17:43 <dons> i'd think they'd be similar (if you disregard hs-plugins and just think about yi-static)
06:17:49 <TheHunter> @plugs let Just foo = Just 1 in foo
06:17:54 <xerox> 1
06:17:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1
06:17:55 <dons> Igloo, I'll forward you the mail.
06:17:56 <TheHunter> @plugs let Just foo = Nothing in foo
06:17:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Ambiguous type variable `a' in the top-level constraint:
06:17:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at <Plugins.Eval>:1
06:18:34 <xerox> No-exhaustive..
06:18:43 <basti_> what if i said "@plugs [1..]"?
06:18:53 <Lemmih> nibro: ("Cabal bug") Have you tried putting a comma between '-F' and '-pgm..'?
06:18:54 <TheHunter> @help plugs
06:18:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @plugs <expr>
06:18:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have Haskell, 3 seconds and no IO. Go nuts!
06:19:00 <bourbaki> if anyone is interested in helping me to port my iging thing to the bot http://rafb.net/paste/results/eeLgdF92.html
06:19:01 <basti_> ah.
06:19:02 <Igloo> Thanks
06:19:07 <bourbaki> moin TheHunter
06:19:12 <TheHunter> moin bourbaki
06:19:24 <xerox> Lambdabot question: where am I supposed to tell "load this module I'm writing, too" ?
06:19:28 <basti_> 3 seconds of [1..] goes up to about 18000 locally.
06:19:28 <basti_> ;)
06:19:33 <Igloo> There might be some overlap, but darcs' problems seemed to be mostly missing libraries/functions like hGetBuf
06:19:36 <shapr> xerox: BotConfig.hs
06:19:37 <dons> igloo, @earth.li?
06:19:41 <Igloo> Yup
06:20:11 * Igloo actually started making such a list for darcs a couple of days ago, as it happens  :-)
06:20:37 <TheHunter> bourbaki, look at IRC.hs => class Module where ...
06:20:39 <shapr> TheHunter: Is that a common usage of pattern matching? It looks really strange to me at first glance.
06:20:46 <shapr> I've seen that in QuickCheck, but nowhere else.
06:21:08 <bourbaki> TheHunter: i think i did that back then but didnt understand actually what i had to do really
06:21:23 <TheHunter> you'd usually use fromJust.
06:21:23 <xerox> shapr, there is a Config.hs file, no BotConfig.hs tough.
06:21:40 <TheHunter> bourbaki, does your module need state?
06:21:45 <dons> Igloo, ok. yeah missing libs are also a problem.
06:21:52 <shapr> xerox: right, sorry, Config.hs
06:21:59 <bourbaki> TheHunter: hm im not sure actually i dont think so no
06:22:22 <xerox> shapr, but.. modules aren't listed there, I'll grep.
06:22:29 <dons> shapr, actually, now you edit config.mk
06:22:33 <shapr> oh
06:22:37 <shapr> ok then
06:22:56 <shapr> That's much more sensible.
06:23:00 <dons> if you add a module, and want it loaded automatically, add it to the list of plugins in config.mk
06:23:57 * Igloo also needs to google for a discussion about thing like "import Data.Bits (shiftL)" not working in nhc98 as shiftL is in a class. I'm sure there was one, but don't remember the outcome and it still doesn't work in 1.18
06:24:19 <xerox> dons, what about getting it built?
06:24:37 <TheHunter> bourbaki, what's the parameter your command should take.
06:24:43 <dons> the build system will find it
06:24:50 <TheHunter> bourbaki, you'll also have to get rid of all the warnings.
06:24:53 <xerox> Good.
06:25:39 <dons> bourbaki, check the style guide "STYLE" before you submit it. and make sure it compile with both 6.2.2 and 6.4 (is possible)
06:25:43 <bourbaki> TheHunter: what warnings? i dont get warnings when i load my code *slightly confused*
06:25:55 <dons> when it compiles
06:26:09 <TheHunter> bourbaki, try -Wall.
06:26:22 <bourbaki> Compiling QuoteModule.IGing ( IGing.hs, interpreted )
06:26:22 <bourbaki> Ok, modules loaded: QuoteModule.IGing.
06:26:22 <bourbaki> *QuoteModule.IGing> main
06:26:59 <bourbaki> what does this wall thingy do? drive my code against the same ;)?
06:27:06 <dons> make sure it compiles into the lambdabot binary with 'autoconf;./configure;make' with no warnings
06:27:23 * boegel waves at bourbaki
06:27:35 <boegel> bourbaki: are you still up for a 3d modeller in Haskell ?
06:27:35 <TheHunter> bourbaki, -Wall turns on all possible warnings.
06:28:40 <vegai> has anyone got any example code that uses Cabal's runTests -hook?
06:28:43 <bourbaki> boegel: i would love to see something like that yes i am still on my math background for that though since i am a bit lazy lately i just read books :) and havent been writeing down the math stuff yet thouth i have a preliminary implementation in haskell
06:29:50 <boegel> you have ? that's great :)
06:30:14 <bourbaki> just for the basics thought the objects that is
06:30:17 <boegel> I have a very simple renderer :)
06:30:19 <bourbaki> and some of the transformations
06:30:59 <bourbaki> what i still need is something that does the integration and derivation plus the triangulaziation the latter is quite easy though since anything in my model is parameterized
06:32:08 <vegai> about modules; does the module Foo.Bar.Baz live in Foo/Bar/Baz.hs?
06:32:47 <boegel> I would like to help on a 3 modeller, but I guess I won't have time until September or so :s
06:33:02 <bourbaki> thats not much of a problem
06:33:33 <TheHunter> vegai, yes.
06:33:52 * xerox adapted GoogleModule to WikipediaModule
06:33:53 <xerox> ^_^
06:34:26 <blackdog> dons: did you get all my patches to lambdabot? I can't see Vixen.hs in the repo...
06:35:21 <dons> hmm. I see VixenModule.hs
06:35:27 <basti_> shapr: would you like to have a loose talk about emacs' "modes" (ui feedback stuff)? as in hermeneutics? ;)
06:35:41 <lightstep> does darcs get http://example.net/project create a directory project, or should i run darcs in an empty directory i create?
06:35:43 <dons> if there was other stuff, make sure you've got the latest repo and darcs send.
06:35:47 <blackdog> yeah, i split it off - VixenModule.hs is the lambdabot wrapper over Vixen.hs.
06:36:25 <blackdog> i can always go to the latest repo by doing darcs pull, right?
06:36:27 <basti_> or anyone?
06:36:41 <dons> blackdog, yep.
06:36:50 <blackdog> weird. ok, shall send again.
06:38:07 <shapr> basti_: what's hermeneutics?
06:38:17 <basti_> thats, when two people talk, and one of both learns something
06:38:18 <basti_> or both.
06:38:22 <shapr> oh, sure
06:38:51 <basti_> well the problem is, how to generalize emacs' wacko modes to something clean
06:39:11 <shapr> like what? major and minor buffer modes?
06:39:13 <dons> yi's lesson to us all: emacs is wacko
06:39:22 <basti_> no i was thinking about the user interface.
06:39:25 <basti_> vi is too.
06:39:41 <dons> at least you can code it using lexer combinators without brain explosions ;)
06:39:43 <shapr> can you give me an example?
06:39:44 <basti_> as in, I type C-x, "C-x" appears
06:39:47 <shapr> Oh that
06:39:58 <bourbaki> does anyone of you know subetheredit?
06:40:00 <shapr> I think that's easy enough, just define a show instance?
06:40:00 <basti_> you type "C-x C-f" and a "file load mode" appears
06:40:05 <basti_> i did that
06:40:20 <basti_> but would i memorize these keys just as keys?
06:40:24 <basti_> or as meta keystrokes?
06:40:31 <shapr> bourbaki: yes, SubEthaEmacs is in-progress, and I've been looking at the protocol to see if it's hard to do for Yi.
06:40:34 <basti_> like in "SuperControlKey"
06:40:43 * boegel moves outsideto enjoy the sun
06:40:45 <shapr> huh? keys versus meta keystrokes?
06:40:52 <shapr> ich verstehe nicht
06:40:57 <basti_> aww i meant meta like in "higher order"
06:40:57 <bourbaki> shapr: do you know if theres a haskell highlight thingy?
06:41:01 <bourbaki> boegel: pardon?
06:41:07 <basti_> like "C-x" would be the "command key 1" or something
06:41:13 <bourbaki> you cant go outside there are no computers and such
06:41:15 <basti_> "meta-x" be "command key 2" etc.
06:41:18 <bourbaki> and sun is bad anyway
06:41:22 <boegel> bourbaki: there are, my laptop will be there
06:41:38 <blackdog> the chips are all around me, they're everywhere i go
06:42:25 <shapr> I know that I can use Xkeycaps to set a 'meta' bit on a key, is that related to what you're talking about?
06:42:26 * shapr is so lost
06:42:52 <blackdog> i think by 'meta' he just means more abstract
06:42:56 <basti_> not really
06:43:10 <lightstep> yi's README tells about ./configure
06:43:14 <basti_> i was thinking like, there are different sets of commands or interfaces in emacs
06:43:15 <lightstep> is it available?
06:43:29 <basti_> like "the C-x feedback" or "the meta-x verbal command lookup"
06:43:34 <blackdog> lightstep: autoreconf should generate it for you
06:43:45 <shapr> oh I see what you mean.
06:44:04 <basti_> now C-x isn't always C-x maybe
06:44:21 <lightstep> blackdog, do you know which package in debian?
06:44:56 <shapr> I think the best approach right now is to just get the keymap working enough that people could switch entirely to Yi from Emacs.
06:45:03 <shapr> Of course, I'm saying this for entirely selfish reasons.
06:45:04 <lightstep> autoconf?
06:45:05 <basti_> hehe.
06:45:05 <basti_> ;)
06:45:12 <basti_> have you looked at my C-x feedback?
06:45:13 <blackdog> mwotton@magarak:~$ apt-cache search autoreconf
06:45:18 <basti_> i reworked it though
06:45:20 <Igloo> autoreconf is in autoconf, yes
06:45:21 <blackdog> give a man a fish...
06:45:29 <shapr> Yeah, it looks nice, any feedback at all is nice.
06:45:37 <basti_> -g-
06:45:48 <basti_> its now like "C-x" via a trivial show function
06:46:03 * theorbtwo pings dons.
06:46:04 <basti_> could one do some show thing with a "type"?
06:47:09 <hellish> is there an official haskell coding style for ghc? I found a C one, but not a haskell one.
06:48:06 <shapr> I'd like to have an emacsy way to define keys in my ~/.yi/Config.hs like: global-set-key "\C-x \C-f" fnewE
06:48:30 <shapr> Yes, a real show instance would make that code more general.
06:48:52 <blackdog> shapr: is there a proper emacs keymap for yi yet?
06:48:53 <basti_> i would think we would do that with ref arrays?
06:49:25 <dons> theorbtwo, yep?
06:49:41 <shapr> actually, I guess more Haskelly would be: global-set-key ['\^x','\^f'] fnewE
06:49:49 <theorbtwo> Any chance of making load in the face of *-boot Just Work.
06:49:59 <blackdog> dons: did you get my patches? I don't trust my mail daemon.
06:50:02 <dons> shapr: yeah there's room for improvements to the lexer concat dsl
06:50:19 <shapr> blackdog: not really proper, but basti_ wrote a beginning
06:50:20 <dons> bd, yep.
06:50:43 <blackdog> dons: ok. shall stop bugging you about it, then.
06:51:24 <basti_> i'm doing it as "pattern matching" now. this is quite inflexible huh
06:52:38 <shapr> My original thought was a keymapFM of :: finitemap keypress (keymapFM | Action)
06:53:17 <shapr> That way you could just update stuff on the fly and it would all just work. Was a bit harder than it sounds when I tried to write it.
06:53:42 <dons> basti_: what are you trying to do, do you want some help?
06:53:58 <basti_> dons: well any help is appreciated.
06:54:10 <basti_> we're currently talking about how to bind keystrokes?
06:54:15 <basti_> .
06:54:25 <dons> dynamically?
06:54:29 <basti_> for example, what to do with C-x...
06:54:36 <basti_> yes that would be definitely preferred.
06:54:36 <dons> C-x does?
06:54:57 <dons> is that the one that runs internal functions?
06:55:07 <basti_> it would "escape"
06:55:17 <basti_> you can issue single key commands after C-x
06:55:22 <basti_> or some with more keystrokes
06:55:26 <shapr> C-x C-f opens a file, C-x C-s saves a file, etc
06:55:27 <basti_> or some that lead you to the file interface
06:55:41 <dons> I don't see what the problem is.
06:56:17 <basti_> well let's say the user wants to rebind C-x
06:56:20 <basti_> generally.
06:56:28 <basti_> so that all C-x end up being C-o or something
06:56:33 <dons> oh, rebinding is pretty easy (relatively)
06:56:39 <dons> look in the Vim.hs
06:56:42 <dons> for :map
06:56:45 <basti_> hmm okay.
06:56:53 <basti_> but i s'pose it runs on a special lexer?
06:57:16 <dons> you just update the existing table in the simplest format
06:57:33 <dons> or you might keep a chain of lexers so you can :unmap
06:57:43 <basti_> hmm.
06:57:45 <basti_> aw
06:57:47 <basti_> i got something.
06:57:57 <basti_> maybe C-x would be a lexer in itself?
06:58:06 <basti_> with a dynamically changealbe regex?
06:58:21 <basti_> no this isnt possible is it?
06:59:16 <dons> I would think that C-x would cause a `meta` switch to a sub-lexer
06:59:20 <dons> normally
06:59:31 <dons> but it would be just one case of the top-level lexer
06:59:44 <basti_> oh no yesss i see
06:59:59 <basti_> i think C-x shouldnt change the mode
07:00:01 <basti_> but go "meta"
07:00:08 <dons> lots of examples of this kind of code in Nano.hs
07:00:11 <basti_> the "state" sorry
07:00:34 <dons> it's the signal to switch to a lexer that can lex the stuff that follows C-x, isn't it?
07:00:57 <lightstep> how can i activate yi a emacs?
07:01:00 <basti_> right now, yes.
07:01:10 <dons> yi --as=emacs
07:01:10 <basti_> btw. theres a new version
07:01:16 <basti_> dons: should i mail it to you?
07:01:29 <basti_> resp. darcs send
07:01:44 <dons> when you update your code, and you consider it stable, you should send it to me so the main repo is running good code.
07:01:51 <basti_> okay.
07:01:58 <basti_> as in how often? ;)
07:02:12 <dons> once a day is ok if there's lots of development
07:02:23 <dons> (might be 10 or more patches)
07:02:30 <dons> depends on how fast you work
07:02:50 <basti_> hmmm okay.
07:03:05 <basti_> shapr had something about an automated system
07:03:24 <shapr> for repo synchronization?
07:03:31 <basti_> yep
07:03:44 <basti_> we never got it to work though
07:03:48 <dons> but that's not for submitting patches to yi. I still like to inspect them.
07:04:20 <basti_> sure
07:05:28 <nibro> Lemmih, (Cabal bug) comma doesn't solve the problem :(
07:06:13 <basti_> anyone else want a darcs patch for my new and improved Emacs.hs? =)
07:14:36 <basti_> hmm
07:17:14 <theorbtwo> Is there a library for platform-nonspecific FilePath manipulation?
07:17:53 <basti_> that would be great indeed.
07:18:14 <TFK> You mean there isn't one?
07:18:23 <basti_> i dont know.
07:18:29 <wilx> Hmm, does Yi compile on Windows?
07:18:51 <wilx> Hmm, have you tried MissingH?
07:21:21 <autrijus> @type modifyIORef
07:21:22 <lightstep> are all the new debian haskell packages installed through cabal?
07:21:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
07:21:43 <autrijus> @type Data.IORef.modifyIORef
07:21:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.IORef.modifyIORef :: forall a.
07:21:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                           GHC.IOBase.IORef a -> (a -> a) -> IO ()
07:23:57 <Igloo> lightstep: I think some are
07:31:56 <nlv11757_> can you give names to subparts of a pattern match; f (Cons hd@.... tl@.....) = <<body referring to hd and tl>>
07:32:45 <lightstep> try it
07:32:59 <autrijus> @pointless \svList -> take sz (svList ++ repeat lazyUndef)
07:33:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- take sz . (++ repeat lazyUndef)
07:33:09 <autrijus> good.
07:34:50 <nlv11757_> it works!! kick ass
07:34:58 <nlv11757_> that is a real kickass feature
07:35:30 <theorbtwo> @pointed take sz . (++ repeat lazyUndef)
07:35:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "pointed", try "lambdabot: @listcommands"
07:35:40 <theorbtwo> Blast.
07:35:46 * shapr explodes
07:36:09 <wilx> @pointless take sz . (++ repeat lazyUndef)
07:36:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- take sz . (++ repeat lazyUndef)
07:40:11 <shapr> I'm looking at QuickCheck in hopes of extending it to do unit testing. The basic generator is "newtype Gen a = Gen (Int -> StdGen -> a)" My first thought is to fake unit tests with a generator that somehow returns the next value to unit test. Maybe I should combine that with a StdGen instance that just returns the succ of the seed? Any simpler approaches?
08:12:30 <nibro> @seen Lemmih
08:12:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Lemmih is in #haskell. Last spoke 1 hour 53 minutes 38 seconds ago.
08:13:36 <shapr> @seen Jaws
08:13:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen Jaws
08:14:24 <JaffaCake> @seen the light
08:14:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen the
08:14:44 * TheHunter wonders if it had been a better choice to use implicit parameters instead of a ReaderT in lambdabot.
08:15:16 * shapr votes for ReaderT
08:15:19 * JaffaCake thinks implicit parameters are never a good idea
08:15:52 <TheHunter> anyway, i'm making the change and let dons decide.
08:16:21 <TheHunter> it's a pretty trivial change now anyway, but it would have saved me a lot of porting work.
08:16:59 * TheHunter thinks implicit parameters are a good idea.
08:17:11 <TheHunter> linear implicit parameters are pure evil, though.
08:17:58 * ibid never found a use for non-linear implicit parameters, and linear implicit parameters were harder to use than an honest monad
08:18:24 * Darius dislikes implicit parameters.
08:19:02 <TheHunter> implicit parameters are just a nicer notation for reader monadic code.
08:19:11 <Darius> TheHunter: No they are not.
08:19:22 <TheHunter> why not?
08:19:30 <ibid> TheHunter: they're an unnicer notation for it
08:19:38 <shapr> What I don't like about implicit params is that I expect monads to do different things in different places, but everything else I expect to be the same in different places.
08:20:08 <Lemmih> nibro: Looking for me?
08:20:10 <TheHunter> if you write down type annotations, it's perfectly explicit what depends on an environment.
08:20:34 <nibro> Lemmih: I wanted to ask you about cabal and configure scripts
08:20:49 <Darius> TheHunter: Reader monads don't have the issues implicit parameters do and I believe can be used in ways implicit parameters can not.
08:20:55 <nibro> I send it to the libraries list :)
08:21:02 <shapr> I also like the option to not write down type annotations to get compile-time dynamic typing.
08:21:08 <nibro> s/send/sent
08:21:13 <Darius> TheHunter: Anyways, you could stay implicit state is just another way of writing a State monad, but that misses the point.
08:21:23 <TheHunter> class Module m s | m -> s where [...] process :: m -> ... -> ModuleT s IRC ()
08:21:50 <nibro> you told me before that you were able to use custom flags to configure, I wondered what I was doing wrong
08:21:59 <TheHunter> where for most modules, the ReaderT isn't needed at all (ModuleT s = ReaderT (IORef s))
08:22:25 <TheHunter> Darius, the reader monad is commutative, which makes it totally different from the state monad.
08:22:30 <Lemmih> nibro: I only used flags to enable/disable features /-:
08:23:00 <TheHunter> Darius, furthermore, the only "issue" i know of with implicit parameters is that polymorphic recursion thing, which could be fixed quite easily.
08:23:09 <nibro> aha, so then I figure you were perfectly happy with the behavior I'm witnessing. :-\
08:24:08 <Lemmih> nibro: It looks like a bug.
08:24:38 <nibro> Lemmih: that's what I thought :-(
08:24:56 <JaffaCake> TheHunter: there's the bad interaction with the monomorphism restriction, too
08:25:22 <Darius> TheHunter: Being a commutative monad only makes it less bad.
08:25:35 <TheHunter> JaffaCake, that could be "fixed" quite easily, too.
08:26:30 <JaffaCake> "fixed" indeed, there's still an interaction which is hard to explain to users
08:27:10 <TheHunter> Darius, i don't agree. do-notation (or using monadic combinators) is an overkill for commutative monads.
08:28:05 <Darius> TheHunter: Yes, but implicit parameters are underkill.
08:28:20 <JaffaCake> then allowing more flexible syntax for commutative monads is the answer, not implicit parameters
08:28:29 * shapr agrees
08:28:37 <Darius> The interaction with the monomorphism restriction is a result of the difference between commutative monads and pure code.
08:28:43 <JaffaCake> underkill, I like it :)
08:28:43 <shapr> Any ideas for commutative monad syntax?
08:29:09 <shapr> I've wondered about that off and on ever since I read the Hair Shirt Retrospective
08:29:10 <TheHunter> such a flexible syntax for commutative modads would immediately abused for non-commutative monads, too.
08:29:29 <TheHunter> i don't think there's a way to enforce commutativity statically in haskell.
08:29:50 <Darius> TheHunter: Simply have it require a CommutativeMonad class.
08:30:01 <Darius> It still -could- be abused, but so can anything else.
08:30:21 <JaffaCake> potential for abuse isn't a good criteria to reject a language feature, IMHO
08:30:38 <TheHunter> Darius, type annotations clarify the interaction with the mr. They could be simply required (or at least there could be a warning).
08:30:57 <shapr> JaffaCake: not unless you're working for Sun
08:31:05 <TheHunter> Darius, yes, but usually to abuse something, you are forced to write "unsafe" somewhere.
08:31:25 <Darius> TheHunter: Not in the way you are talking about.
08:31:44 <Darius> TheHunter: It's easy to make a Monad instance that isn't a monad, same for functor.
08:32:16 <TheHunter> Darius, yes, but that doesn't break referential transperancy.
08:32:40 <lightstep> neither does a special application syntax for a reader monad
08:32:48 <lightstep> s/neither/nor/
08:34:42 <shapr> hoi ikbent
08:34:51 <shapr> Are you learning Haskell?
08:35:33 <TheHunter> shapr, if you're searching for a nice syntax for commutative monads, i'd suggest reflect/reify-brackets and on the type level, something very much similar to implicit parameters.
08:35:54 <TheHunter> (without forall-hoisting, that is)
08:36:02 <shapr> Can you show me an example?
08:36:21 <TheHunter> suppose [] is commutative.
08:36:56 <TheHunter> reify (reflect [1,2] + reflect [3,4]) ==> [4,6,5,3]
08:38:18 <Darius> TheHunter: What does the reify do?
08:38:24 <TheHunter> where reify and reflect could just be fancy brackets like [< >], [> <].
08:39:13 <TheHunter> as in filinski's paper.
08:39:34 <TheHunter> incidently, i have a half-finished tmr article that emulates that stuff using linear implicit parameters.
08:39:44 <shapr> spiffy!
08:39:47 <Darius> TheHunter: Haskell doesn't have continuations and there's little reason to reify something that's already explicit.
08:39:53 <lightstep> it feels bad to add special syntax for specialized things. special syntax for reader monads might be too far
08:40:35 <lightstep> Darius, reify seems like runReader, no? which does reify things to a non-monadic value
08:41:00 <Darius> lightstep: I agree, but just use runReader, "reify" isn't a part of the "syntax".
08:41:44 <TheHunter> brb
08:42:34 <Darius> It seems the notation that would be needed beyond pure syntax is simply something that would separate f random and do r <- random; f r.  It seems that it could actually be type-directed and need no syntax, but I'm not too keen on type-directed transformations that change meaning.
08:43:35 <lightstep> but transforming [<f random>] to (random >>= f) is legitimite
08:45:09 <Darius> lightstep: You mean a type-directed transformation would preserve meaning or do you mean that that should be okay in general?
08:45:29 <lightstep> you can make <[ ( [<random>], [<random>] ) ]> mean liftM2 (,) random random
08:45:59 <lightstep> i mean that the transformation can be like `do': depends heavily on standard type classes
08:46:31 <lightstep> if you introduce new syntax, it doesn't change the meaning of the original code
08:48:18 <Darius> lightstep: I think however you can make a lighter syntax.  I made a TH hack a long time ago that lets you write f (! random) for random >>= f (as well as more complicated examples).
08:49:10 <Darius> I would use a different notation for an actual extension of course.
08:49:25 <lightstep> personally, i don't like syntax extensions, more so when they are used for a specialized thing
08:49:41 <Darius> lightstep: This would be analogous to do-notation.
08:50:01 <Darius> However, I'd agree that having a general mechanism for adding (minor) syntactic extensions would be nice.
08:51:29 <shapr> Anyone know of a gnu gettext parser in Haskell?
08:51:31 <lightstep> all the straws look alike, only one broke the camel's back
08:51:51 <shapr> How do I unit test straws?
08:53:29 <shapr> I like the ability to extend the syntax.
08:53:43 <theorbtwo> Suck fluid.  If you get the fluid at the top, and none at the sides, it passes.
08:53:51 <shapr> theorbtwo: excellent point
08:56:53 <TheHunter> reflect :: CommutativeMonad m => m a -> Monadic m a, reify :: CommutativeMonad m => Monadic m a -> m a, where Monadic is some rank-2-type alias, eg. type Monadic m a = &m => a.
08:57:20 <TheHunter> of course, under the hood, there's some type directed translation going on.
08:58:07 <TheHunter> hmm, that's too simple.
08:58:53 <TheHunter> reify must be specialized to something like CommutativeMonad m => Monadic m (a -> b) -> a -> m b.
08:59:47 * pesco appears.
08:59:53 * shapr explodes
08:59:57 * pesco mourns.
09:00:08 * shapr unexplodes
09:00:08 <lightstep> you do that very often
09:00:19 <xerox> Do you know what "Compiled, but didn't create object file" means? Talking about @plugs
09:00:23 <shapr> lightstep: yeah well, it's fun.
09:01:11 <TheHunter> xerox, it probably means you used th and something went wrong.
09:01:22 <shapr> I mostly explode when I'm reading some particularly convoluted code. When do you explode?
09:01:41 * tuomov 's head is about the explode from brain slime
09:01:50 <shapr> Do you have a cold too?
09:01:54 <tuomov> yeah
09:01:54 <xerox> TheHunter, strange, lambdabot does give this error for everything I try in @plugs
09:02:06 <TheHunter> @plugs 3 + 4
09:02:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 7
09:02:13 <xerox> My lambdabot :)
09:02:20 <xerox> Without motification, tough
09:02:33 <shapr> I've missed so many days of swedish class because of flu that I'm dropping out. I'll either pick it up again in september, or I'll self-study.
09:02:34 <lightstep> works here with pms
09:02:43 <TheHunter> xerox, did you compile the RunPlugs script?
09:03:11 <xerox> @listmodules
09:03:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- babel base dice dict dummy dynamic eval google help karma more pl plugs
09:03:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- quote seen state system topic type version
09:04:30 <xerox> script/RunPlugs.hs?
09:04:37 <TheHunter> yes.
09:04:42 <xerox> Not by hand.
09:05:32 <xerox> How should I do it?
09:05:59 <TheHunter> one sec.
09:06:06 <xerox> Thank you.
09:06:31 * TheHunter tries himself.
09:06:40 * shapr convicts himself
09:08:35 * xerox tries rebuilding hs-plugins
09:10:48 <TheHunter> no wonder that doesn't work when the bot wants to call itself "lambdabot"
09:11:35 <TheHunter>  ghc -package plugins --make scripts/RunPlugs.hs -o runplugs
09:13:13 <xerox> Hmpf..
09:14:01 <TheHunter> yep, works.
09:14:30 <xerox> Doesn't for me, mmh.
09:14:38 <TheHunter> what does it say?
09:15:01 <TheHunter> chances are runplugs only works with cvs snapshots of hs-plugins.
09:15:21 <xerox> Warning: Module `Data.FiniteMap' is deprecated: Please use Data.Map instead.
09:15:23 <xerox> Ah, now..
09:15:30 <xerox> Ok, I'll get the lastest hs-plugins.
09:16:01 <xerox> @google hs-plugins
09:16:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:19:51 <xerox> I'm rebuilding everything.
09:20:26 <autrijus> is there something like
09:20:31 <autrijus> [a] -> [Int]
09:20:41 <autrijus> where it is 0,1,2,3,4... ?
09:20:41 <xerox> That does what?
09:20:56 <autrijus> just return enumTo the length of [a]
09:21:04 <autrijus> but needs to work on infinite lists
09:22:00 * TheHunter doesn't understand.
09:22:04 <xerox> (map (fst) . zip [0..]) ?
09:22:21 <autrijus> yeah. ok. I'll use that
09:22:21 <autrijus> thanks
09:22:35 <xerox> Happy to help :)
09:22:39 <autrijus> :)
09:22:42 <TheHunter> zipWith const [0..]
09:22:49 <autrijus> ooh
09:22:55 <autrijus> even better
09:23:02 <xerox> As usual.. :)
09:23:18 <xerox> TheHunter, updating and rebuilding everything worked.
09:23:22 <TheHunter> yay!
09:23:32 <TheHunter> @pointless map fst . zip [0..]
09:23:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- map fst . zip [0..]
09:23:40 <xerox> Ops, didnt.
09:23:43 <TheHunter> hmm, i need a rule for that...
09:23:59 * autrijus marvels in the amazing pointlessness
09:24:06 <xerox> Warning: Module `Data.FiniteMap' is deprecated: Please use Data.Map instead.
09:24:09 <xerox> hmpf.
09:24:21 <TheHunter> what gives you that message?
09:24:27 <xerox> Every @plugs ..
09:25:02 <xerox> Using hs-plugins' runplugs or scripts/ one.
09:25:10 <theorbtwo> @type "\n"
09:25:12 <TheHunter> and no result?
09:25:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "\n" :: [Char]
09:25:16 <xerox> TheHunter, no result.
09:25:42 * TheHunter compiles hs-plugins/runplugs with ghc-6.5
09:26:17 <theorbtwo> Huh?  Couldn't match `Char' against `[Char]' In the first argument of `intersperse', namely `"\n"'.
09:26:23 <theorbtwo> Looks like a [Char] to me...
09:26:37 <xerox> @plugs intersperse ' ' "theorbtwo"
09:26:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "t h e o r b t w o"
09:27:17 <theorbtwo> God, I'm an idiot sometimes.
09:27:27 <shapr> me too!
09:27:35 * xerox raises his hand
09:27:46 <shapr> But I like to think that humbleness is the first step to learning.
09:27:57 <shapr> It's either that or I'll get really depressed ;-)
09:28:14 <theorbtwo> Wait, no, I'm not as much as an idiot as I thought.
09:28:22 <theorbtwo> LoadFailure errs -> error (intersperse '\n' (("Error loading "++symbol++" from "++path) : errs))
09:28:30 <theorbtwo> (errs is a list of strings.)
09:29:48 * theorbtwo is lost in a twisty maze of prelude functions, all alike.
09:31:10 <hellish> @plugs (\12 -> 13) 12
09:31:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 13
09:31:40 <theorbtwo> @pointless foldl (\a b -> a ++ "\n" ++ b) "" errs
09:31:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- foldl ((. ('\n' :)) . (++)) [] errs
09:32:43 <theorbtwo> Ah: unlines!
09:35:02 <hellish> point-free notation is scary sometimes.
09:37:08 * xerox finds it cute
09:39:43 <hellish> theorbtwo's original was way easier for me to read than the dulled version
09:39:58 <xerox> ^__^
09:40:34 <xerox> TheHunter, any clue?
09:43:00 <shapr> hiya dominic
09:43:04 <poetix> ji
09:43:12 <poetix> hi, that is
09:43:48 <shapr> j0
09:44:24 <TheHunter> xerox, ok, i can reproduce your behavior.
09:44:32 <xerox> Good (?)
09:45:13 <TheHunter> @pointless uncurry fst
09:45:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- uncurry fst
09:45:18 <TheHunter> @pointless curry fst
09:45:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- curry fst
09:45:53 <xerox> @version
09:45:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p216, GHC 6.4 (OpenBSD i386)
09:45:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:48:28 <poetix> @pointless p(q(r))
09:48:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- p (q r)
09:48:59 * poetix does not entirely understand
09:49:21 <poetix> @pointless p (q r)
09:49:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- p (q r)
09:49:47 <Lunar^> shapr: Do you know if someone made a RSS parser in Haskell?
09:50:10 <shapr> There are two RSS libraries I know, one in PLog and and one by stepcut.
09:50:15 <poetix> @pointless (p . q . r)
09:50:16 <TheHunter> xerox, i think it's an hs-plugins issue. ask dons about it.
09:50:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- p . q . r
09:50:32 <Lunar^> shapr: Any URL?
09:50:38 <xerox> TheHunter, do you get it with RunPlugs.hs shipped with hs-plugins or lambdabot?
09:50:52 <TheHunter> i tried lambdabot's.
09:51:26 <TheHunter> i gotta go, bye.
09:51:31 <xerox> Bye!
09:52:39 <poetix> @pointless p(q(r(s)))
09:52:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- p (q (r s))
09:52:56 <poetix> does @pointless do anything apart from strip needless parentheses?
09:53:03 <xerox> poetix, yup
09:53:08 <poetix> eg?
09:53:21 <xerox> @pointless \x -> f x
09:53:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- f
09:53:36 <xerox> It strips out explicit parameters.
09:53:45 <poetix> -> point-free style
09:53:52 * poetix slaps forehead
09:54:18 <aheller> What's the etymology of points-free?
09:54:19 <xerox> @pointless \f xs -> xs >>= return . f
09:54:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fmap
09:55:53 <poetix> @t fmap
09:55:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "t", try "lambdabot: @listcommands"
09:55:59 <poetix> @type fmap
09:56:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fmap :: forall (f :: * -> *) b a.
09:56:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         (Functor f) =>
09:56:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         (a -> b) -> f a -> f b
10:02:33 <poetix> I've heard it said that you don't /understand/ mathematics, you just get used to it.
10:03:59 <poetix> I tend to feel that way about the sort of mental origami involved in complex type signatures
10:04:42 <poetix> I /just barely/ understand what's going on in a simple monadic combinator library
10:04:50 <poetix> if I squint at it hard for a long time
10:06:06 <poetix> Some of the CT-based stuff seems to me like mental origami performed in several extra dimensions
10:06:32 <poetix> The most I can hope for is to get used to it
10:11:00 <jyasskin> Possibly that's because math is just _true_, so you can't mold/arrange it to fit your brain like biology. You have to mold/arrange your brain to fit it.
10:11:54 <hellish> Looks like GHC in cvs is broken. To compile this module, please use -ignore-package lang-1.0.
10:12:53 <poetix> I think it's "true" in the sense of "consistent" (I'm not convinced of the Platonic view of mathematical truth) - but the brain prefers to have more wiggle-room...
10:13:05 <TFK> The world is also true. People just get used to it.
10:14:03 <TFK> When was the last time you pondered about the oxygen factories in green leaves, ant colony behaviour, the butterfly effect, your own brain function, even?
10:15:07 <jyasskin> we can arrange the biology information into patterns. "Compress" it, I guess. Math is already as compressed as it can be.
10:15:20 <TFK> What do you mean?
10:15:27 <TFK> What is "the biology information"?
10:15:44 <shapr> TFK: I ponder that stuff all the time.
10:15:52 <nibro> SyntaxNinja: I'm calling cabal with Dist.Simple, defaultMainWithHooks defaultUserHooks
10:16:07 <jyasskin> We have a bunch of genotypes running around. But we've arranged all the different appearances into categories like "dog", "cat", etc.
10:16:08 <jyasskin> brb
10:16:24 <TFK> shapr, that list can go on for ages :-) but hey, someone's gotta do it for the rest of us :-P
10:16:43 <shapr> I was recently thinking about fads and 'memes' as spatial recursion.
10:16:45 <TFK> "dog" and "cat" are not genotypes.
10:16:48 <poetix> ~type [..]
10:16:52 <poetix> @type [..]
10:16:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
10:16:57 <shapr> And I was wondering about the similarities to ant colony behaviour.
10:16:59 <poetix> @type [1..]
10:17:00 <nibro> SyntaxNinja: The following line comes from -v4, quite telling:
10:17:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1..] :: forall a. (Num a, Enum a) => [a]
10:17:12 <nibro> SyntaxNinja: sh configure --prefix=/users/cs/d00nibro/tmp --with-sessiondb-driver
10:17:22 <TFK> I don't know what spatial recursion is o.o;
10:17:29 <shapr> Just what it sounds like.
10:17:49 <nibro> SyntaxNinja: ... while I wrote --with-sessiondb-driver=PostgreSQL
10:17:54 <TFK> It sounds awfully recursive...
10:18:02 * poetix was trying to make a lame joke about lists that could go on for ages..
10:18:33 <SyntaxNinja> nibro: yep, sounds like a bug
10:18:52 <shapr> You could conceivably count the pages in a book by tearing one out, and then to the next person you says "one" and hand them the book. And they tear out another page, and say "two" to the next person.
10:19:19 <shapr> Base case being no more pages :-)
10:19:33 <nibro> SyntaxNinja: will you please consider this a bug report then? =o)
10:19:53 <shapr> TFK: that makes sense as spatial recursion, right?
10:20:08 <TFK> It makes as much sense as book-burning :-/
10:20:29 <shapr> It's just an example.
10:20:41 <TFK> For evil deeds?
10:21:00 <shapr> You could count jellybeans in a bag by eating one, incrementing the number and handing the bag to the next person.
10:21:21 <shapr> aanway
10:21:34 <TFK> Why can't I eat all the jellybeans myself? Can't I count? :-\
10:21:36 <shapr> poetix: anymore thoughts on a Zope written in Haskell?
10:22:00 * poetix needs to master the nursery slopes first
10:22:15 <poetix> I want to get Yi compiled, and look in detail at hs-plugins
10:22:23 <shapr> good point
10:22:57 <SyntaxNinja> nibro: done
10:23:17 <poetix> task 2 is to look at a simple approach to templating / embedded scripting - needs to be as easy as PHP, but vastly less crap
10:23:46 <nibro> SyntaxNinja: great
10:23:48 <SyntaxNinja> nibro: can I see your Setup script actually? I don't really understand what you're doing
10:24:01 <SyntaxNinja> nibro: you're calling configure in a pre-hook?
10:24:42 <poetix> task 3 is to look at building a simple cgi handler that resolves a path to a reference into a Haskell code store, loads a module from the store, and handles an HTTP request
10:24:46 <nibro> SyntaxNinja: probably, if that's the behavior of defaultMainWithHooks :-)
10:24:49 <SyntaxNinja> and passing the command-line arguments in?
10:24:56 <SyntaxNinja> oh yeah...
10:25:03 <SyntaxNinja> an empty hooks, then?
10:25:07 <SyntaxNinja> hmmmm
10:25:11 <nibro> defaultUserHooks
10:25:19 * SyntaxNinja nods
10:25:22 <jyasskin> shapr: did you finish explaining my idea? Do we have the same idea?
10:25:42 <SyntaxNinja> nibro: so a work-around is to over-ride the pre-configure hook with a hook that parses the command-line args correctly. shouldn't be too hard, I think.
10:26:45 <shapr> jyasskin: about ontologies?
10:27:09 <jyasskin> mm, about math being more compresssed than other subjects
10:27:24 <SyntaxNinja> so defaultMainWithHooks defaultUserHooks{preConf=correctPreConf}
10:27:45 <shapr> The only thing I'm sure about with math is that I wish it used combinator-based names.
10:27:49 <SyntaxNinja> I'll try to fix this bug, but it won't get released right away, so you might want to do that as a work-around... then if you do, send me correctPreConf ;)
10:28:33 <jyasskin> shapr: lol, that's what you get when your naming scheme accretes over several centuries.
10:28:53 <nibro> SyntaxNinja: I might do that, but some people (or whatever shapr is) have other plans for me atm ;o)
10:29:09 * vegai wonders about the runTests hook
10:29:17 <shapr> I have other plans?
10:29:51 <shapr> nibro: Vad sger dig?
10:30:39 <shapr> Jag r s forvnad. :-P
10:31:05 <SyntaxNinja> vegai: it's a great hook that I don't think is getting run at all :(
10:31:25 <SyntaxNinja> dammit, I need to spend a few hours on cabal. too bad I keep going outside and scrambling all over huge rocks every weekend.
10:31:32 * shapr snickers
10:31:50 <shapr> jyasskin: I could learn math a lot faster if the names referred to the basis.
10:31:53 <vegai> yes, I agree
10:32:01 <vegai> that it's not getting run
10:32:11 <nibro> shapr: well, bringert keeps telling me you want that hsp code, so ...
10:32:16 <shapr> oh right!
10:32:18 <shapr> good point!
10:32:33 <shapr> As part of my evil plans to escape the overstatefulness that is Zope
10:32:52 <jyasskin> shapr: But then people working in the field would have to say more. They really just need `import` statements.
10:32:55 * nibro should probably have kept silent... ;)
10:33:00 <shapr> Haskell Server Pages using HaRP could be quite helpful.
10:33:21 * poetix googles some more
10:33:25 <shapr> jyasskin: I still wish for an "International Math Name" like the international chemical names.
10:33:54 <shapr> bicantor-deoxymandelbrot[2,2,4]-premonoid-freyd-categories.
10:34:04 <jyasskin> lol!
10:34:11 * shapr grins
10:35:27 <jyasskin> Unfortunately, math isn't as finished as molecular structure. So any scheme would be outdated in 50 years.
10:36:00 <poetix> shapr: One thing that matters for REST applications is to break the coupling of URLs to files. mod_rewrite gives you one way to do this, and there are other ways besides, but I'd like to see URL resolution happen inside the application in a highly controllable manner.
10:36:06 <shapr> At least I'd be able to understand things today.
10:36:09 <TFK> For each epsilon there is a delta... oh, how I wish it were true...
10:36:22 <shapr> poetix: zope does that, sort of.
10:36:47 <jyasskin> category theory is to set theory as bzip2 is to gzip
10:36:47 <shapr> You've used Zope, haven't you?
10:37:29 <shapr> hmm, how would you do that with Haskell?
10:37:34 <poetix> shapr: yes, I've done a few things with plone
10:37:46 <shapr> Ah, excellent. So you understand acquisition, et al
10:38:23 <poetix> Yes. I think that can still work in a Haskell environment, except that acquiring code and acquiring data would be separate operations.
10:38:50 <shapr> Yes, I think that's the most important point so far.
10:39:04 <shapr> And it would make web dev *so much easier*
10:39:39 <shapr> code shouldn't be persisted in a ZODB-like the same way data would be.
10:40:12 <shapr> This would totally get rid of stuff like in-servlet testing toolkits like Cactus for J2EE.
10:40:13 <poetix> The data should be persisted somewhere where other types of application can get at it (the ZODB is a roach motel...)
10:40:25 <shapr> yes, it is
10:40:28 * shapr laughs
10:40:40 <shapr> I'm going to quote that in my next blog entry.
10:41:57 <poetix> The code needs to be able to be moved in and out of the application - loaded, evaluated, edited, persisted, reloaded - which is where I think Yi will be helpful
10:42:33 <poetix> Although I'm still not sure whether all of the code needs to be Haskell code - some of it could be written in an interpreted sub-language
10:43:13 <shapr> Heffalump made a difference about the CGI Arrows recently that's interesting to me, he said that in Hughes' Arrows paper, the continuation is not persisted, but only the data for the continuation. I don't really know what he meant, but it sound like 'instances' of arrow objects.
10:44:39 <jyasskin> shapr: The continuation is part of your web app, so the client doesn't have to store the code itself, only a number (coded as Right^n(Left)), which is the address of the code.
10:44:54 <shapr> Right, that part I understand.
10:45:10 <jyasskin> sorry, what didn't you understand?
10:45:13 <shapr> The difference between storing a continuation and only its data in the original Arrows paper is what I do not understand.
10:46:11 <jyasskin> its data is the arguments ...
10:46:21 <jyasskin> I probably missed something if you're confused and I'm not.
10:46:25 <shapr> hehe
10:46:41 <shapr> Have you read John Hughes' paper "Generalizing Monads to Arrows" ?
10:46:43 <jyasskin> yeah
10:47:13 <shapr> Do you remember the sticking point of not being able to persist the CGI Arrow?
10:47:58 <jyasskin> He couldn't put the (Read a,Read b,Show a,Show b) (or maybe a subset) into the Arrow interface.
10:48:01 <shapr> right, exactly
10:48:13 <shapr> where was I going with this?
10:48:16 * shapr thinks
10:49:11 <jyasskin> rather, Haskell didn't infer those constraints in the arrow method from the CGI datatype's constraints.
10:49:18 <jyasskin> *methods
10:49:36 <shapr> Anyway, Josef Svenningsson showed up a coupla days ago and said he has another version of the Arrows framework that doesn't directly wrap a function, and so might be able to get around the CGI Arrow problem.
10:49:44 <shapr> Though at the moment I can't figure out how that helps.
10:49:55 * shapr blinks
10:50:04 <jyasskin> The Category class? Yeah, I don't see how that helps either.
10:50:43 <shapr> I do know that stepcut and a few others said that the black box of wrapped functions causes problems, though I don't remember any details there either.
10:50:44 <jyasskin> I pointed danb at it just in case.
10:50:45 <shapr> foo
10:51:05 <SyntaxNinja> I have a question for you guys... I have a bunch of functions in the IO monad, which carry some extra bit of "state" as input and output params
10:51:25 <SyntaxNinja> now in an IO function that calls these functions, I keep having the situation:
10:51:26 <jyasskin> But that's not what Hughes had problems with, I think
10:51:29 <SyntaxNinja> state <- f1
10:51:34 <SyntaxNinja> state' <- f2 state
10:51:40 <SyntaxNinja> state'' <- f3 state'
10:51:41 <SyntaxNinja> etc
10:51:45 <SyntaxNinja> not nice.
10:51:54 <jyasskin> SyntaxNinja: StateT s IO?
10:52:14 <SyntaxNinja> the main problem with this is that I might forget which state to pass in...
10:52:40 <SyntaxNinja> jyasskin: hm, but the function that calls f2, f2, f3 is in the IO monad
10:53:15 <shapr> hej Orangosaurus
10:53:27 <shapr> Orangosaurus: would you like to learn Haskell? :-)
10:53:54 <SyntaxNinja> so I'd have to put that function in StateT s IO, and then use 'evalState' or whatever?
10:54:07 <Orangosaurus> shapr: yup
10:54:18 <shapr> spiffy!
10:54:35 <jyasskin> SyntaxNinja: yeah. Or, more probably just use f_caller = evalState $ do
10:54:45 <Orangosaurus> shapr: you're not in #unicycling..?
10:55:04 <shapr> Orangosaurus: you have persuaded me.
10:55:32 <df_> what does ghc use perl for?
10:56:00 <shapr> Originally linking, but I think only manual register munging these days.
10:56:04 <jyasskin> shapr: Category still has those unconstrained universals in `comp`. I don't see how the lack of `pure` lets haskell infer anything extra.
10:56:09 <pesco> *spookytone* The evil MANGLER!
10:56:24 <SyntaxNinja> hm.
10:56:35 <jyasskin> So, I've been wondering: is the Mangler evil, or does it mangle evil?
10:56:47 <df_> ah.  can take quite a while on `static' lists
10:57:17 <pesco> I'm pretty sure the former. It being made from Perl and all.
10:57:35 <TFK> It is mangler than evil.
10:57:45 <SyntaxNinja> if it mangled evil, then it is good, right?
11:03:32 <stepcut> crap, I think it might be time to buy a mac
11:03:59 <pesco> Isn't there any Yi user here who's noticed it eating the keypress right after escaping back out of insert mode?
11:04:04 <jyasskin> stepcut: Yes, come to the light side.
11:04:32 <pesco> I'd like so much to take it into daily use, but this annoyance is a show-stopper!
11:04:35 <stepcut> jyasskin: as soon as I can afford the ticket
11:04:39 <shapr> pesco: fix it!
11:04:44 <pesco> (And I don't have time to fix it.)
11:04:45 <shapr> oh
11:04:49 <pesco> I would. I'm sorry. ;)
11:04:59 * shapr looks
11:05:03 <pesco> But actually, maybe I'll have a look at the lexer later.
11:05:20 <pesco> I'm almost out of all creative energy for today anyway.
11:05:23 <shapr> aww :-(
11:06:01 <jyasskin> great, now I'm going to have to try out Yi...
11:06:16 <pesco> Algebra seems to cause quite some consumption.
11:06:55 <pesco> Or maybe I'm missing some nutrition. And I'm too weak to go to the store. DOOM!
11:07:23 <jyasskin> stepcut: do you have some time to explain why the Category class (w/o pure) helps with CGI arrows?
11:08:11 <stepcut> I can give you the 10 second hand waving explanation
11:08:26 <Lunar^> stepcut: You've written a RSS parser?
11:08:30 <jyasskin> sure
11:08:44 <jyasskin> I've read Hughes' paper
11:09:22 <stepcut> the CGI arrows are basically a mechanism to capture a bunch of state and pass it from one invocation of the cgi script to the next
11:09:47 <stepcut> all of the state has to be turned into a string, because it is going to be passed around by webbrowsers as a string
11:09:53 <jyasskin> And it needs Read and Show on all of the data, yeah.
11:10:32 <jyasskin> But the class constraint doesn't infer from the Arrow type to the methods.
11:10:45 <stepcut> so, the problem is, Arrows require that you implement the pure function -- which basically means you would need some way to take every possible function and someone turn it into a function that takes a string and returns a string
11:11:06 <jyasskin> `comp` still has unconstrained types on its arguments though.
11:11:30 <jyasskin> s/on/in
11:12:04 <stepcut> Lunar^: no, I wrote some data types for representing RSS, and some code to generate XML, I have not gone the other way
11:12:22 <stepcut> jyasskin: I have not looked at Category in detail yet...
11:12:33 <shapr> class Category arr where
11:12:33 <shapr>   idA  :: arr a a
11:12:33 <shapr>   comp :: arr a b -> arr b c -> arr a c
11:12:56 <jyasskin> stepcut: thanks anyway then.
11:13:24 <Lunar^> stepcut: uh ok
11:14:11 <jyasskin> maybe ghc can infer extra stuff from just (arr a b) over from (a->b)->arr a b
11:14:25 * shapr dunno
11:15:00 <stepcut> I would have to go back and review, it has been a while since I tried to use arrows
11:16:15 * shapr looks at page 35 of the arrows draft paper.
11:17:06 * pesco makes.
11:18:42 <shapr> aha, middle of page 39 is where the problem is mentioned
11:20:02 * jyasskin looks
11:28:24 <nibro> huh?
11:28:31 <nibro> ghc --make HSPR.hs -o hspr -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances -F -pgmFtrhsx
11:29:34 <shapr> what?
11:29:43 <nibro> well, I hope my spam went through even if I went out
11:29:49 <jyasskin> nibro: http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
11:30:01 <jyasskin> nibro: -pgmF selects a preprocessor.
11:30:08 * jyasskin guesses that's what nibro was asking about..
11:30:16 <nibro> jyasskin: nope, it wasn't ;)
11:30:19 <jyasskin> oh well
11:30:31 <jyasskin> that's as far as the spam got
11:30:44 <nibro> check the list of compiled modules, and then check the missing modules in the error
11:31:11 <nibro> if I write --make, how can it choose to skip some modules?
11:31:37 <nibro> aha, so none of the rest got through
11:32:13 <nibro> so the idea is, I compile HSPR.hs which imports two modules
11:32:23 <nibro> one of these is HSPR.Server
11:32:52 <SyntaxNinja> hm. the docs for runStateT seem to be wrong
11:33:23 <nibro> ghc starts chasing dependencies from these imports and finds all modules imported by HSPR.Server, but it never compiles HSPR.Server itself
11:33:29 <nibro> how can that be?
11:34:15 <SyntaxNinja> nibro: it doesn't skip it because its already compiled? is it getting it from a package already installed?
11:34:37 <nibro> no, it doesn't say Skipping HSPR.Server
11:35:03 <nibro> and the linking error says /users/cs/d00nibro/tmp/lib/hspr-0.2/libHShspr-0.2.a(Server.o)(.text+0x1bf): In function `sdid_info':
11:35:04 <nibro> : undefined reference to `HSPRziRequestHandler_requestHandler_closure'
11:35:29 <nibro> so in this case it was HSPR.RequestHandler, which is not tracked either
11:36:06 <shapr> can you add an explicit -I ?
11:36:47 * shapr is just guessing
11:37:31 <nibro> doh, SyntaxNinja is right. There's a package installed in my --user conf from one of my earlier attempts with cabalizing the exec
11:38:12 <nibro> (runhaskell Setup.hs uninstall...)
11:38:18 <nibro> ;-P
11:39:42 <SyntaxNinja> :)
11:39:53 <nibro> thanks for the help :)
11:40:02 * SyntaxNinja starts to think that he's seen every packaging error possible while developing cabal
11:41:11 * nibro doesn't find that hard to believe at all
11:46:47 <SyntaxNinja> jyasskin: I guess what I really want to do is perform IO in a function that returns StateT s IO r
11:47:27 <nibro> SyntaxNinja: use lift
11:47:50 <nibro> @type lift
11:47:51 <jyasskin> SyntaxNinja: liftIO
11:47:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
11:48:46 <SyntaxNinja> ooh!
11:48:58 <SyntaxNinja> who wrote this shitty Control.Monad.State documentation?
11:49:08 <shapr> not me!
11:49:14 <nibro> @type Control.Monad.Trans.lift
11:49:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.Trans.lift :: forall (t :: (* -> *) -> * -> *)
11:49:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                    a
11:49:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                    (m :: * -> *).
11:49:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                             (Control.Monad.Trans.MonadTrans t, Monad m)
11:49:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- =>
11:49:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                             m a -> t m a
11:49:25 <nibro> @type Control.Monad.State.liftIO
11:49:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.State.liftIO :: forall (m :: * -> *) a.
11:49:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                               (Control.Monad.Trans.MonadIO m) =>
11:49:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                               IO a -> m a
11:49:40 <nibro> @type Control.Monad.Trans.liftIO
11:49:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.Trans.liftIO :: forall (m :: * -> *) a.
11:49:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                               (Control.Monad.Trans.MonadIO m) =>
11:49:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                               IO a -> m a
11:49:42 <SyntaxNinja> yeah, I already tried it out... it rulz
11:50:27 <SyntaxNinja> @type Control.Monad.State.runStateT
11:50:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.State.runStateT :: forall s a (m :: * -> *).
11:50:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                  Control.Monad.State.StateT s m a -> s -
11:50:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- > m (a, s)
11:51:00 <SyntaxNinja> but why does the documentation say runStateT :: (s -> m (a, s))
11:52:22 <jyasskin> ah, because StateT is a record, whose field is called runStateT
11:52:56 <jyasskin> I think it was a confusing way to write the MTL, but it's how they did it.
11:53:08 <SyntaxNinja> ahh
11:53:13 <SyntaxNinja> hohum
11:53:23 <SyntaxNinja> I think I'll update the documentation :)
11:54:09 * jyasskin doesn't know exactly how the ghc docs are generated, but guesses that you'll need to modify Haddock
11:54:31 <SyntaxNinja> nah, I won't be able to fix that, but at least I can mention it
11:54:53 <jyasskin> True, but the same problem shows up all over the MTL
11:55:32 <SyntaxNinja> yeah
11:56:14 <nibro> http://banded.medic.chalmers.se:22335/ClockTime/ClockTime.hsp
11:56:38 <nibro> it may not look much to the world, but I've finally gotten it all to work with 6.4 =)
11:57:23 <nibro> so a release is imminent, just need to clean up a bit =)
11:58:03 * nibro will celebrate this by going off to do the dishes...
12:03:28 <SyntaxNinja> fun!
12:11:03 <pesco> kosmikus: Are you there? There seems to be a problem withs lhs2TeX and pragmas. Are you aware of it?
12:16:47 <pesco> kosmikus: Actually it's not a problem with pragmas, but with comments.
12:17:33 <pesco> kosmikus: It seems, underscores in comments (as in "{- _ -}" or "-- _") result in a TeX error. (Missing $ inserted.)1;2~
12:17:41 <pesco> s/1;2~//
12:18:10 <pesco> (This is in poly mode.)
12:18:38 <scalopus> hi
12:21:56 <shapr> y0
12:22:49 <shapr> Anyone know of po-mode / gnu gettext code for Haskell?
12:24:28 <jyasskin> shapr: wouldn't all your strings have to be in IO? Or would this be at compile time?
12:24:40 <jyasskin> ... all your string are belong to IO ...
12:25:14 <nibro> jyasskin: lol!
12:25:25 <shapr> Actually, I want to write a po-mode webapp in Haskell.
12:25:48 <nibro> so who tried to sneak out more pages?
12:26:50 <shapr> like this one? - http://banded.medic.chalmers.se:22335/HelloWorld/HelloWorld.hsp
12:27:05 <nibro> aye, that's the most basic one
12:27:19 <nibro> you can try http://banded.medic.chalmers.se:22335/Counter/Counter.hsp
12:27:26 <jyasskin> I tried ClockTime.hs to see if your source was available
12:27:31 <shapr> neato
12:27:52 <jyasskin> hehe
12:28:03 <shapr> I actually have a project for which I'd like to use hsp right now.
12:28:09 <shapr> Or at least try it.
12:28:35 <nibro> well, the problem is it only works as a standalone right now
12:28:46 <shapr> what do you mean?
12:28:57 <shapr> It compiles to a binary?
12:29:02 <nibro> i.e. it only handles .hsp, which anyone who tried to ask for a raw dir found out
12:29:19 <nibro> no, I mean it's not a real web server
12:29:37 <shapr> ok?
12:29:41 <nibro> it needs to be integrated into e.g. Apache first (I'm hoping for Lemmih here)
12:29:51 <shapr> Why not hws?
12:30:02 <nibro> that would be nice as well
12:30:06 <shapr> Didn't Peter Thiemann just hack hs-plugins into hws?
12:30:25 <nibro> shapr: wouldn't know
12:30:31 <shapr> speaking of which, I forgot to send him an email and ask for a copy.
12:31:02 <nibro> anyway, I have a cgi mode for HSP, but you obviously lose some functionality
12:31:21 <pesco> Hrm. I wish hyphens were allowed in module names.
12:31:38 <nibro> you could try that if you like, just let me set up a source bundle
12:31:43 <shapr> hws-plugins would fix that, it'd compile on demand.
12:32:30 <nibro> well, hsp compiles on demand as well
12:32:43 <nibro> or what did you refer to?
12:32:58 <shapr> oh, ok
12:34:00 <nibro> the idea to use dynamic loading in hsp actually comes from the first hws-wp incarnation by Martin Sjgren (@ chalmers)
12:34:29 <shapr> yeah, Martin used to hang out here a lot.
12:34:52 <shapr> haven't seen him lately though.
12:35:01 <nibro> work does that to a guy
12:35:12 <nibro> :-)
12:35:55 <nibro> btw, try http://banded.medic.chalmers.se:22335/RequestVars/RequestVars.hsp?name= and fill in whatever name you like
12:35:58 <shapr> Well, I'm self-employed.
12:36:28 <nibro> shapr: does that mean you pay yourself to hang around here and teach others the wonders of Haskell?
12:36:36 <shapr> To some degree, yes.
12:37:00 <shapr> But I also teach stuff on #plone, #emacs, #jython, and a bunch of other channels.
12:37:11 <shapr> #unicycling for example
12:37:24 <nibro> does that make a lot of money?
12:37:36 <shapr> du brde lser lite http://enhjulingsfolket.se/ ;-)
12:38:00 <shapr> No, not really. I could make much more money if I spent more time working and less time talking.
12:38:05 <nibro> heh, I saw the pictures from eurohaskell (which I regrettably missed)
12:39:08 * pesco drops out of his chair.
12:39:11 <pesco> *snort*
12:39:33 <shapr> On the good side, all my talking means I end up being informed about all the best tools.
12:39:43 <shapr> At least, that sounds like a good rationalization from here.
12:40:23 <pesco> *snore* even
12:40:35 <xerox> @listmodules
12:40:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- babel base dice dict dummy dynamic eval google help karma more pl plugs
12:40:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- quote seen state system topic type version
12:40:53 <nibro> shapr: ok, here we go:
12:41:20 <nibro> shapr: darcs get http://www.cs.chalmers.se/~d00nibro/haskell-src-exts
12:41:25 <nibro> that's the first step
12:41:34 <jyasskin> Haskell is very nice for processing csv files
12:41:41 <shapr> do you have a csv module?
12:41:44 * pesco pulls himself up to the keyboard again.
12:41:45 <shapr> nibro: got it
12:41:50 <shapr> well, getting it
12:41:55 <pesco> G-Good night #haskell!
12:41:59 <shapr> g'night pesco
12:42:12 * pesco snores loudly.
12:42:24 <jyasskin> shapr: yeah, I stole the one from MissingH
12:42:32 <shapr> ah, ok
12:43:10 <jyasskin> The zoltar one didn't work
12:44:28 <shapr> hm, runhaskell isn't in $PATH with the ghc6.4 debs.
12:46:13 <nibro> that's stupid
12:46:23 <shapr> tis a bit surprising
12:46:25 <shapr> I shall file a bug.
12:48:25 <shapr> nibro: cannot satisfy dependency haskell-src-exts-any  \n zsh: exit 1 /usr/lib/ghc-6.4/bin/runhaskell Setup.hs configure
12:49:01 <xerox> Which module can I check do understand how to add language-choosing facility to my @wikipedia? (adapted from GoogleModule.hs)
12:49:50 <nibro> shapr: you need to start with haskell-src-exts or harp
12:50:06 <shapr> this is haskell-src-exts
12:50:12 <nibro> huh?
12:50:29 <shapr> It looks like haskell-src-exts depends on itself?
12:51:03 <nibro> well, the cabal file clearly shows that it doesn't, I have no idea where that comes from
12:51:24 <shapr> hm, strange
12:52:24 * shapr looks around for someone else to pick on
12:52:33 <nibro> I shouldn't ask, but are you sure that's haskell-src-exts you're building?
12:52:50 <nibro> if you are, I
12:52:52 <shapr> I'm in ~/build/darcs/haskell-src-exts/src/trhsx
12:53:01 <nibro> ah, that's trhsx
12:53:09 <shapr> doh
12:53:11 <nibro> cd ..; cd haskell-src-exts
12:53:16 * shapr blushes
12:53:27 <shapr> wow, it works!
12:53:55 <shapr> sensible question.
12:54:18 * nibro feels genuinly happy that this was only due to a random bout of stupidity ;)
12:54:23 * shapr grins
12:56:13 <shapr> ok! all three installed!
12:56:21 <shapr> Man, cabal r0xx
12:56:28 <shapr> it's so much easier than the standard approach.
12:56:29 <nibro> it sure does :)
12:57:07 <nibro> ok, to see that it works ok, create a file Foo.hs containing the line foo = [/ a* /]
12:57:15 <nibro> doh
12:57:17 <shapr> of course, now I wish for a metacommand that does configure && build && install
12:57:24 <nibro> I mean foo [/ a
12:57:31 <nibro> I mean foo [/ a* /] = a
12:57:40 <nibro> I mean a lot of things it seems
12:58:05 <nibro> and then ghci -F -pgmF trhsx Foo.hs
12:58:51 <shapr> hm, trhsx isn't on my $PATH
12:59:25 <shapr> weird, I don't have /usr/local
12:59:42 <shapr> oh yes I do
12:59:49 <shapr> but permissions are such that only root can execute
12:59:49 <stepcut> hehe
13:00:27 <nibro> hmm, hopefully that's cabal's fault and not mine :-p
13:00:42 <shapr> yay! "Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message) [Just (a) <- HaRPMatch.runMatch harp_match3 harp_pat0, a]"
13:00:55 <nibro> oh yeah, you need -fglasgow-exts
13:01:14 <nibro> I keep forgetting, I always have it on anyway ;-)
13:01:33 <shapr> I used to do that, but it caused debugging and teaching problems on #haskell sometimes.
13:01:50 <nibro> once I've gotten haskell-src-exts to handle pragmas I'll make trhsx add OPTIONS -fglasgow-exts to all harp files
13:02:03 <nibro> ok, so does it work now?
13:02:07 <nibro> foo "apa"
13:02:40 <shapr> det fungerar bra
13:03:17 <nibro> ok, next step then is darcs get http://www.cs.chalmers.se/~d00nibro/hsp
13:03:39 <nibro> now a word of caution, the former I consider stable
13:03:43 <nibro> this one I do not
13:03:45 <shapr> heh, ok
13:04:04 <nibro> and there's no install instructions so I'll have to guide you the first time
13:04:10 <shapr> fair enough
13:04:29 <shapr> the darcs repo is empty :-(
13:04:41 <nibro> oh?
13:04:54 <nibro> oh, wait
13:05:34 <nibro> darcs record is a good command I hear
13:05:37 <nibro> try again
13:06:35 <shapr> ah, start with hsp and then do hspr ?
13:06:47 <nibro> to install you need haskelldb with support for either postgresql or mysql
13:06:55 <nibro> yep
13:07:18 <nibro> hsp should work fine by just runhaskell Setup.hs {configure, build, install}
13:08:02 <nibro> hsp is the programming model, it defines everything that the HSP user can access
13:08:17 <nibro> hspr = HSP Runtime, i.e. the server executable
13:08:56 <nibro> first thing to do when installing hspr is runhaskell Setup.hs configure as before
13:09:14 <nibro> then comes the hack (due to the cabal bug)
13:09:59 <nibro> hur gr det?
13:10:08 <shapr> langsamt
13:10:29 <shapr> salut sebc
13:10:33 <sebc> hi shapr
13:11:10 <shapr> ah poo, I don't have HaskellDB installed.
13:11:57 <sebc> I am wondering how easy it is to include ghc in some arbitrary Haskell program (such as a web server ;-))...
13:12:47 <nibro> sebc: easy as import Plugins :-)
13:12:53 <shapr> You want to turn hws-plugins into an MSIE virus?
13:13:08 <sebc> :-)
13:13:08 <shapr> You'd have to save .hc files, and make sure to install MSVC++
13:13:13 * shapr snickers
13:13:55 <sebc> nibro: does this include the full compiler?
13:14:17 <nibro> sebc: no, not at this point
13:14:23 * sebc sighs
13:14:26 <sebc> a pity.
13:14:28 <shapr> poo, I don't even have HSQL installed.
13:14:33 <nibro> sebc: dons is still waiting for the -package ghc I suppose
13:14:49 <sebc> Yay!  That would be cool. :-)
13:15:23 <nibro> sebc: it should be doable, and dons has promised that that is his goal for the future :-)
13:16:13 <nibro> shapr: I thought you were the db guru of these parts ;-p
13:16:35 <shapr> me?
13:16:47 * sebc cheers for dons
13:16:50 <shapr> I think I'm just the one who never stops talking.
13:17:01 <nibro> yeah, you're the one with the only practical HaskellDB tutorial out there :-)
13:17:08 <shapr> good point
13:17:19 <shapr> But I only wrote that because I couldn't figure out how to use HaskellDB
13:17:37 <nibro> hehe, isn't that usually why tutorials get written?
13:17:50 <shapr> I think so. It's the best approach in my experience.
13:17:58 <shapr> sebc: instance Functor Packet! w00!
13:18:10 <sebc> :-)
13:18:30 <shapr> Have you tried that yet?
13:18:38 * shapr chats while waiting for HSQL to build
13:18:59 <sebc> not yet, I have been busy (still am...)
13:19:25 <shapr> I haven't tried it either. But, I hope to get QuickCheckM working so that I can find tcp/ip stack holes.
13:19:33 <sebc> heh
13:19:39 <shapr> I'm sure I can find a bunch.
13:20:15 <sebc> is there some sql (or other) database engine written in Haskell out there?
13:20:28 <stepcut> my computer keeps losing contact the with the D: drive :(
13:20:48 <nibro> sebc: is it the actual DBMS you're after?
13:20:57 <sebc> nibro: yes :-)
13:21:07 <nibro> If so I believe HAppS has one
13:21:51 <nibro> http://happs.org
13:22:10 <sebc> yes, I was looking at it; I am wondering about efficiency ;-)
13:22:52 <sebc> a DBMS would be a nice addition to House
13:23:00 <nibro> I don't think efficiency was his main concern when writing it, it would sure be interesting to see a full-blown DBMS written in Haskell though
13:23:07 <nibro> sebc: aye, definitely
13:23:45 <sebc> nibro: so would I, it could be quite interesting
13:25:05 * shapr fights HSQL
13:25:32 <sebc> though maybe not best as the persistent storage facility of choice for House...
13:26:07 * sebc hates files with a passion
13:26:51 <nibro> it would be cool to have a typed relational-algebraic DBMS as the "file system"
13:27:04 <sebc> nibro: precisely :-)
13:27:44 <nibro> shapr: I need to take a walk with the dog, be back in say 30 mins. Hopefully you'll have won over HSQL and HaskellDB by then ;-)
13:28:45 <nibro> sebc: http://banded.medic.chalmers.se:22335/RequestVars/RequestVars.hsp?name=Sebastian
13:29:17 <sebc> nibro_afk: :-)
13:30:09 <sebc> shapr: did you get Peter Thiemann's modified hws?
13:35:01 <shapr> No, because I just remember to send off the email.
13:35:30 <shapr> What about a HaskellDB backend for ReiserFS?
13:37:54 <sebc> backend?
13:38:35 <boegel> shapr: how tmr2 going ?
13:38:37 <shapr> HaskellDB can use ODBC, SQLite, PostgreSQL, and MySQL. Why not ReiserFS?
13:38:46 <shapr> boegel: people are writing, but I haven't set up the author's wiki yet.
13:39:21 <sebc> shapr: ah, so you mean a ReiserFS backend for HaskellDB
13:39:41 <shapr> er, yes.
13:40:16 <sebc> shapr: well, I don't know much about ReiserFS, but I suppose it is closer to other filesystems than to relational databases, so it will lack many of the required operations (e.g., joins)
13:40:17 <shapr> boegel: should I appoint you lieutenant and ask you to recruit people? ;-)
13:40:39 <shapr> Hans Reiser has said something about running databases on reiser directly.
13:41:00 <shapr> grr, the HSQL configure is broken
13:41:27 <xerox> Silly question, what is the () in "IO ()" ? Is it the empty tuple?
13:41:28 <stepcut> Argh! floating point rears it ugly head!
13:41:28 <SamB> did he say/imply "relational"?
13:41:35 <boegel> shapr: I don't think I'm frequent enough to recruit :p
13:41:46 <shapr> I explicitly unconfigured haddock, so now it's using the command "no" in the place of the haddock command.
13:41:47 * stepcut needs to write a decimal arithmetic module for haskell :-(
13:42:04 <sebc> shapr: http://www.ussg.iu.edu/hypermail/linux/kernel/9809.0/0459.html
13:43:24 <shapr> sounds like it's not ready yet
13:43:38 <shapr> but that is from six years ago
13:44:07 <sebc> shapr: yes, so it's probably worth have a look :-)
13:44:20 <sebc> s/have/having/
13:46:16 <CosmicRay> stepcut: what, Integer doesn't work?
13:48:16 <shapr> stoopid question, is there a Cabal for HSQL?
13:49:03 <SyntaxNinja> yeah somewhere
13:49:17 <SyntaxNinja> Lemmih made one at the very least; look in his home dir
14:00:54 <shapr> man, cvs.haskell.org is slow today.
14:01:33 <SyntaxNinja> so is www, methinks
14:05:40 <nibro> shapr: did you find a cabal for HSQL?
14:05:57 <shapr> I'm still looking
14:06:06 <shapr> You found one, I assume?
14:06:23 <nibro> otherwise HSP wouldn't be running ;)
14:06:29 <nibro> where shall I send it?
14:06:43 <nibro> btw, do you have PostgreSQL?
14:07:16 <shapr> Yes, I do.
14:07:31 <shapr> you can send it to shae@ScannedInAvian.com
14:07:38 <nibro> xerox: () could be seen as the empty tuple yes. We generally call it "unit", and it has a single value ()
14:07:39 <SyntaxNinja> shapr: ~lemmih/HSQL
14:07:41 <shapr> ah
14:08:11 <nibro> yeah, you can get Lemmih's, that's the one I'm using too. It only works for PostgreSQL tho
14:08:20 <shapr> that's fine with me
14:09:28 <SyntaxNinja> can someone (lemmih? shapr? nibro?) send the cabal-ized pieces to HSQL upstream, please?
14:09:39 <xerox> nibro, TY.
14:11:30 <nibro> SyntaxNinja: to the author you mean? didn't krasimir post on the list that he was working on one?
14:12:50 <xerox> Goodnight folks.
14:13:03 <shapr> g'night xerox
14:13:10 <nibro> night
14:13:30 <nibro> shapr: did you get it, or are you still waiting for me?
14:13:41 <boegel> g'night everyone
14:14:00 <shapr> I'm downloading it file by file
14:14:06 <shapr> and realizing that's pretty slow
14:14:31 <nibro> night boegel :)
14:14:42 * shapr tries scp -R
14:14:46 <shapr> g'night boegel
14:14:58 <nibro> well, you really only need the .cabal, don't you?
14:15:33 <nibro> of course, there's some 6.4 updates to do as well... maybe you should get it all after all
14:19:11 <shapr> ah, I think I got it installed
14:19:19 <shapr> yes!
14:19:44 <nibro> oki, haskelldb next :-)
14:19:47 <shapr> right
14:20:10 <CosmicRay> hi metaperl
14:21:46 <metaperl> hi CosmicRay
14:29:57 <shapr> so, is there is haskelldb cabal?
14:30:05 <jlouis> dons: you've got commits ;)
14:32:50 <jlouis> that vixenmodule is evil
14:32:51 <jlouis> hehe
14:32:57 <nibro> shapr: coming right up
14:33:46 <CosmicRay> shapr: I have one
14:34:32 <shapr> I'm having a build problem though, "build/ghc/Database/HaskellDB/FieldType.hs:76:24: Couldn't match `TypeRep' against `TyCon'"
14:35:58 <shapr> ah, I don't do DCC
14:36:04 <shapr> well maybe
14:36:30 <shapr> oh, guess not.
14:36:58 <shapr> CosmicRay: shae@ScannedInAvian.com ?
14:37:10 <CosmicRay> shapr: ok
14:37:15 <nibro> shapr: sent you a haskelldb.cabal, and a haskelldb.patch with info on how to patch it up
14:37:36 <CosmicRay> shapr: it's in my haskelldeb debian package too
14:37:48 <shapr> there's a haskelldb deb?
14:37:58 <CosmicRay> shapr: http://packages.debian.org/cgi-bin/search_packages.pl?version=all&subword=0&exact=1&arch=any&releases=all&case=insensitive&keywords=haskelldb&searchon=sourcenames
14:38:02 <CosmicRay> shapr: yes, in sarge even.
14:38:22 <CosmicRay> that's what I wrote my cabal file for.
14:38:28 <shapr> wow, how'd I miss that?
14:38:38 <CosmicRay> dunoo.  sleeping? :-)
14:38:59 <CosmicRay> ahh, knowing you -- unicycling.
14:39:08 <shapr> haha
14:39:47 * CosmicRay hands shapr a Unicycle monad.
14:39:57 <shapr> What's up with the TypeRep vs TyCon error? isn't that a 6.2 vs 6.4 problem?
14:40:09 * shapr :: Unicycle Shapr
14:40:23 <CosmicRay> are you using cvs haskelldb?
14:40:28 <shapr> yes
14:40:31 <shapr> just did cvs up
14:40:55 <shapr> any ideas?
14:41:02 <CosmicRay> hmm, I never had to patch it for 6.2
14:41:09 <nibro> shapr: I sent you a file with that info
14:41:10 <CosmicRay> are you building with:
14:41:14 <CosmicRay> Extensions: AllowOverlappingInstances, AllowUndecidableInstances
14:41:14 <CosmicRay> ghc-options: -fglasgow-exts -O2
14:41:16 <shapr> aha, a patch
14:41:25 <CosmicRay> so is it a 6.4 bug?
14:41:28 <nibro> well, it's not a real patch, I just called it that ;)
14:41:39 <nibro> no it's no bug, it's a name change
14:41:53 <CosmicRay> well I mean, haskelldb-is-broken-with-ghc-6.4 bug
14:42:10 <nibro> ah, aye :)
14:42:19 <CosmicRay> ok :-)
14:43:09 <nibro> you should change mkAppTy to mkTyConApp in a few places
14:44:23 <nibro> and add {-# OPTIONS -fallow-undecidable-instances #-} to the BoundedList module
14:45:39 <nibro> shapr: I need to crawl to bed, I wrote up an INSTALL file and added to the darcs repo
14:46:05 <shapr> thanks for your help
14:46:09 <nibro> if it won't work for you and you can't solve it I'll be here tomorrow again :-)
14:46:10 <shapr> I think I'll have this installed soon :-)
14:46:14 <shapr> sounds good
14:46:31 <nibro> np, I'd really like some users so I'll do what I can. ;-)
14:46:37 <shapr> haha
14:46:45 <nibro> g'night all
14:46:48 <shapr> I can be a demanding user I think, so... ;-)
14:46:55 <shapr> g'natt nibro
15:00:40 <df_> shapr, et al., a cut down version (ie with everything interesting stripped) of the mpeg unmarshal/marshal routines are at ftp://ftp.bbc.co.uk/incoming/mpeg-bs-simulation2-20050411.tar.gz (to compile, edit Makefile and then `make test')
15:00:49 <shapr> w00
15:00:55 <shapr> under what license?
15:01:21 <df_> at the moment, a `you may look but not redistribute'
15:01:25 <shapr> oh
15:01:28 <shapr> fair enough
15:01:31 <df_> it will all be published soon under an open license
15:01:38 <shapr> much happiness :-)
15:01:52 <df_> prob newBSD
15:01:59 <wilx> Huh, MPEG decoder in Haskell?
15:02:02 <shapr> For code that people don't want to open up, I'd rather not look.
15:03:50 <df_> wilx :: its for a simulation of a hardware system. it doesn't do a full decode/encode (ie to the picture stage), just unmarshalling the stream for poking with in the stream / frequency domain
15:04:01 <wilx> Oh.
15:04:09 <wagle> i've used a jpeg decoder that was written in haskell..  pretty slow, unfortunately
15:04:14 <df_> it wouldn't be too difficult to add full decoding / encoding, however it will be very slow
15:04:41 <wilx> I see.
15:04:43 <df_> its slow enough at the moment (but thats partly due to the hardware connection)
15:05:14 <shapr> There are a few leftover cvs files in the tgz, though nothing that reveals exciting information about the rest of yours ources.
15:05:34 <df_> gah .# files
15:06:12 <jlouis> ah, bed
15:07:59 <df_> currently there is an issue in MPEG.Marshalling (unmarshalMPEGthing) / MPEG.Sys (sysSCpartition) causing something not to be garbagecollected
15:09:04 <wagle> i wonder if haskell would be better suited to controlling hardware mpeg en/de-coding
15:09:05 <df_> the test will take a .m2v, unmarshal and marshal it again (./test flwr_015.m2v out.m2v)
15:09:43 <df_> well part of my research has been toying with using functional languages in the next generation of hardware `description' language
15:09:49 <wagle> how does this mpeg thing handle bit twiddling?
15:10:29 <df_> things like infinite lists (streams) map very well to hardware
15:10:49 <shapr> Have you seen Lava/Hawk/etc?
15:10:57 <wagle> (the jpeg thing i was using used [Bool] to represent the bits
15:11:02 <wagle> )
15:11:43 <df_> bit twiddling - as in decoding single bits? the stream is decomposed into [Bool]
15:11:58 <df_> although i've tried to create a stream class to simplify it
15:12:09 <df_> but have not succeeded that well
15:12:22 <shapr> cool error - "make: Warning: File `Makefile' has modification time 1.1e+03 s in the future \n you didn't mean to do that \n make: warning:  Clock skew detected.  Your build may be incomplete."
15:12:34 <df_> hehe
15:12:56 <df_> shapr :: i've read up on lava, howver they pulled the release at the time i was interested
15:13:19 <shapr> Yeah, I missed out on it too.
15:13:34 <shapr> Satnam Singh is working on a new version though.
15:13:38 <df_> i would like to try to take it further, not connecting to Boolean types
15:13:59 <shapr> Peter Gammie was working on something post-Lava that was based on dataflow languages like Lucid and Esterel.
15:14:15 <shapr> Have we already talked about this?
15:14:17 <df_> i was thinking about exploting very short term paralism
15:14:18 <df_> no
15:14:42 <shapr> Sometimes I think I repeat myself a lot.
15:14:52 <shapr> Anyway..
15:14:53 <df_> more research to do and a phd /me thinks, however i need to go and learn computer science properly first
15:15:11 <shapr> How do you know when you've learnt it properly?
15:15:28 <shapr> I only really got into learning CS about three years, when I started learning Haskell.
15:15:40 <df_> well, i'm an electronic engineer, i have only a broad appreciation of the subject
15:15:51 <shapr> I'm a web developer...
15:16:29 <df_> well one can never learn it properly, all you can get is a deeper understanding
15:16:35 <shapr> Yeah, I like that.
15:16:41 <shapr> Do you read lambda-the-ultimate.org ?
15:17:30 <df_> no, seen it mentioned here a couple of times recently though
15:17:58 <shapr> It's worthwhile, imho.
15:18:04 <shapr> Though frustrating at times.
15:18:16 <df_> thanks, shall take a look
15:18:40 <shapr> This sort of comment frustrates me - http://lambda-the-ultimate.org/node/view/630#comment-5390
15:19:02 <shapr> Because it'll be a coupla years until I understand what was being said there.
15:19:30 <shapr> What sort of short term parallelism?
15:22:40 <df_> spotting evaluations which could trivially happen in parallel on a fpga, ie, where threading would be ineffcient, but a single cpu doesn't have the resource to handle it.  ditto custom functions that a cpu is not efficient at implementing, but could be configured on an fpga and run very quickly
15:23:09 <shapr> I've thought about running Linux on an fpga
15:23:52 <df_> ?
15:24:16 <shapr> Even better, I've thought about running Linux on half an FPGA and using something like TransMeta's codemorphing software to find more efficient ways to configure the FPGA.
15:25:04 <shapr> Actually, I'd like to do asymmetric multiprocessing with Linux, where you can use something like one Intel cpu and one Alpha, fast Integer and fast FPU.
15:25:27 <SamB> with dynamic recompilation?
15:25:41 <df_> basically i see a ceiling in terms of making cpus run as-fast-as-possible.  the way to make things better is to make them highly parallel and offloading complex functions onto custom hardware
15:25:45 <shapr> Have you already looked at declarative parallelism like Nesl, Sisal, FISh, and MPMD in general?
15:26:00 <SamB> how would the kernel ever decide which processes to run on which architecture?
15:26:04 <df_> so yes, i think we will be seeing cpus with programable execution units and the like
15:26:09 <shapr> Well, I agree with the highly parallel part, I haven't considered custom hardware.
15:26:18 <shapr> SamB: profile
15:26:47 <SamB> how would it deal with data structures and alignment?
15:26:53 <shapr> That would be either the end of closed source, or the beginning of efficient morphing dotnet style VMs.
15:27:24 <df_> shapr :: a bit, not much.  these are only ideas i've had over the last 6 months or so. still working on a plan to be able to work in this area
15:27:52 <shapr> GHC is likely to have SMP ability with STM soon.
15:28:14 <shapr> PArr already does parallel arrays, though they're not really ready for SMP usage.
15:29:12 <df_> interesting
15:29:25 <shapr> Anyway, I've already mentioned most of this in one of the LtU threads.
15:30:19 <shapr> But if you want details, I can talk your ear off =)
15:31:44 <df_> :), i'll have a read first tomorrow (its 2332hrs)
15:31:54 <shapr> yeah, it's 0:32 here
15:31:58 <df_> but am always interested to hear what people have to say
15:32:03 <shapr> btw, I can make a guess about your space leak
15:32:10 <df_> oh?
15:32:23 <shapr> I don't see much usage of monads in your code
15:32:30 <shapr> actually I don't see any, but I haven't looked at all of it
15:32:31 <df_> try none
15:32:56 <shapr> I think that if you do pull the MPEGState out into a real monad (because, that's what it is) your space usage will be fine.
15:33:23 <shapr> I'm impressed you haven't had painful space leaks before this.
15:33:24 <df_> aah of course!
15:33:40 <shapr> I'd guess that somewhere, you're holding onto something just a little bit too long
15:33:44 <df_> the thing is, it was fine before i changed the streams
15:33:49 <shapr> but it'll be really hard to track it down
15:33:53 <df_> (with the MPEGstate)
15:33:57 <shapr> with a monad, it's all in one place
15:33:57 <df_> i feared so
15:34:31 <shapr> but this state and state' looks like step two of a monads tutorial :-)
15:34:45 <df_> heh
15:35:06 * esap suggests continuation passing monad for space problems.
15:35:21 <shapr> This is the best monads tutorial http://www.nomaware.com/monads/html/
15:35:53 <shapr> and I'd also suggest http://www.haskell.org/hawiki/MonadsAsContainers
15:35:54 <df_> thanks, will have a go
15:37:16 <shapr> From looking at this code, I think you'll really like monads.
15:37:28 <shapr> hei esap
15:38:14 <shapr> df_: have you used OCaml or some other ML derivative before this?
15:38:43 <shapr> Sure looks like it.
15:38:51 <df_> SML (and have looked at OCaml (i just can't remember the library reference which makes me very slow writing it))
15:40:04 <shapr> This is very clear code.
15:40:10 <shapr> totally unlike my own =)
15:42:06 <shapr> I look forward to an OSS release of this code.
15:42:29 * shapr peers suspiciously at Heffalump 
15:42:43 <Heffalump> yo. What is the correct way to migrate from Modules: in an old Setup.description file?
15:43:06 <df_> eek, i'm not overly happy with it (but thank you for saying so) - i'm sure there are more elegant (and proper) ways of doing things (i just don't know them)
15:43:16 <df_> that said, it did fit my design requirements
15:43:38 <SyntaxNinja> hi
15:43:49 <SamB> well, being able to kludge clearly takes talent
15:44:02 <SamB> that is, 'kludge with clarity'
15:45:11 <df_> hehe, erm `thank you' is the best thing i can think of to say to that
15:45:37 <shapr> Heffalump: stick them into a cabal file?
15:46:03 <Heffalump> err, yes, but the modules: field isn't recognised any more.
15:46:05 <shapr> Exposed-Modules: right?
15:46:10 <SamB> and it is my understanding that most people do things at least one wrong way (probably a few more) before they figure out how to do them the right way
15:46:49 <Heffalump> I already had both Modules: and Exposed-Modules:
15:46:59 <shapr> Heffalump: http://www.scannedinavian.org/~shae/haskelldb.cabal.txt
15:47:06 <waltz> shapr: can you please change the method which lambdabot responds to people from notices to pubmsgs?
15:47:19 <Heffalump> waltz: that was deliberately changed to avoid loops
15:47:25 <Heffalump> and comply with the IRC RFC
15:47:42 <Heffalump> shapr: is it no longer necessary to specify 'internal' modules then?
15:47:53 <shapr> waltz: Notices are part of the IRC RFCs for bots and lambdabot had a loop that flooded the channel, so that's why it got changed.
15:47:54 <waltz> :(
15:47:58 <shapr> waltz: I'm guessing you use gaim?
15:48:09 <waltz> mIRC on Win32 :(
15:48:11 * Heffalump would suggest some sensible defensive coding instead.
15:48:21 <Heffalump> notices may be technically correct, but they're bloody annoying
15:48:23 <shapr> oh, I haven't used mIRC in many years.
15:48:34 <shapr> What's annoying about them?
15:48:35 <waltz> heh, what os do you have?
15:48:48 <shapr> emacs ;-)
15:48:50 <waltz> they come up everywhere...
15:48:51 <monochrom> notices aren't annoying.  users of substandard irc clients are.
15:48:52 <Heffalump> they show up oddly by default in irssi
15:48:55 <waltz> emacs is an os?
15:49:01 <shapr> waltz: some people claim that.
15:49:05 <waltz> pfft
15:49:09 <shapr> I use emacs on Linux.
15:49:10 <waltz> I mean _real_ os ;)
15:49:15 <waltz> what distro
15:49:31 <shapr> debian
15:49:48 <shapr> debian/unstable, with bits of experimental
15:49:52 <waltz> nice
15:50:04 <df_> emacs is an entire eco system
15:50:12 <waltz> haha
15:50:20 <shapr> This is my cue to advertise for Yi
15:50:23 <waltz> 'ecosystem' hehe
15:50:25 * shapr gets out the pom-poms
15:50:42 <waltz> I've never heard that kind of analogy
15:50:51 <shapr> Heffalump: I don't know about specifying internal modules. I didn't write that cabal file.
15:50:59 <shapr> nibro wrote it, I just had it handy to show.
15:51:14 <shapr> yi yi yi! http://www.cse.unsw.edu.au/~dons/yi.html
15:51:14 <aheller> emacs is a powerful operating system with an acceptable text editor built in.
15:51:15 <shapr> w00
15:53:24 <shapr> Are you at oberlin?
15:54:22 <aheller> I am.
15:54:27 <df_> right, it is sleep time.  Good night all, thanks for the advice and comments
15:54:31 <shapr> g'night df_
15:55:09 <shapr> I gotta sleep too
15:55:23 <shapr> aheller: nice resume
15:55:29 <aheller> Might be a bit old.
15:55:32 <df_> heh, yes, work tomorrow
15:55:37 <aheller> and a little heavy on the word searches...
15:55:56 <shapr> I like the neural mindstorms part.
15:56:24 <aheller> I spent most of that summer trying to get the c cross compiler to work so I didn't have to deal with the mindstorm language.
15:57:03 <shapr> If only you'd had Haskell...
15:57:11 <shapr> Then you could have written your own compiler.
15:58:07 <aheller> if only...  since fritz left (before my time), noone really plugs haskell here
15:58:13 <shapr> ruehr?
15:58:30 <aheller> so I've been told
15:58:38 <shapr> Oh yeah, he was at oberlin.
15:58:41 <aheller> there's a picture of his daughter in the upstairs lab stil
15:59:00 <shapr> Fritz is really quite cool.
15:59:08 <shapr> I met him at ICFP2003
15:59:10 <aheller> it says under it "but daddy, I don't *like* the lambda calculus"
15:59:20 <aheller> never met him
15:59:20 <shapr> Hah, that sounds like him.
15:59:36 <shapr> Have you seen his Haskell art?
15:59:51 <aheller> nope...
16:00:13 <shapr> http://www.willamette.edu/~fruehr/logos/intro.html
16:00:20 <Igloo> Heffalump: Hidden-modules IIRC
16:00:29 <aheller> (how) are you related to oberlin?
16:00:53 <shapr> Nope, not related at all.
16:01:11 <Heffalump> igloo: no, tried that.
16:01:22 <Heffalump> but I can't find any recent .cabal files that uses it at all, so I've just deleted it
16:01:27 <Igloo> Oh. Prod SyntaxNinja then  :-)
16:01:34 <Igloo> Ah, fair enough
16:01:44 <shapr> My life history is 27 years in the southeast USA, then five years in finland/sweden.
16:02:27 <SyntaxNinja> `?
16:02:33 <shapr> `?'
16:02:39 <SyntaxNinja> '
16:02:49 <jlouis> shapr: met girl?
16:02:51 <SyntaxNinja> other-modules
16:03:06 <shapr> jlouis: On ircq even. How geeky is that?
16:03:23 <shapr> `?
16:03:57 <SamB> hmm... I do not remember what ircq is...
16:04:00 <jlouis> shapr: beats me.
16:04:25 <SamB> it sounds very obscure
16:04:31 <shapr> How can you get geekier than meeting a girl on irc or icq? ICQ ran an irc server for awhile, under ircq.com...
16:04:58 <Heffalump> SyntaxNinja: oh, right. Should I be listing them, or is it unnecessary?
16:05:22 * Heffalump just sent John an updated haskell-http btw :-)
16:05:24 <shapr> Admittedly, it wasn't as geeky as meeting a girl on an lpmud.
16:05:58 <SyntaxNinja> Heffalump: I think you should list them :)
16:06:17 <SyntaxNinja> they're used for the (broken) sdist at the very least; other stuff like preprocessing as well.
16:06:40 <SamB> oh, is that what it was.
16:06:55 <SamB> I don't think I ever really knew what ircq was...
16:13:57 <aheller> shapr: how did southwest turn into northern europe?
16:14:27 <shapr> I met this girl on ircq.com...
16:14:58 <shapr> g'day Pseudonym
16:15:03 <Pseudonym> G'day.
16:15:09 <aheller> Ah.  Scrollback confirms this...
16:15:12 <Pseudonym> Quick question.  Is TMR coming out this month?
16:15:15 <shapr> I sure hope so.
16:15:23 <Pseudonym> Guess you want some content, then, huh.
16:15:30 <shapr> would be nice, I admit
16:15:45 <shapr> but I'm sort of in that splinter in your eye, log in my own kind of situation.
16:15:46 * Pseudonym evaluates lazily.  Only does work when the result is required.
16:16:33 <skew> shapr: I enjoy seend you greet everyone in their native language, even when it's Australian.
16:16:37 <shapr> haha
16:16:41 <Pseudonym> :-)
16:16:47 <shapr> There are some I don't know.
16:17:00 <Pseudonym> I believe that there is some province in Canada where they also use "g'day".
16:17:02 <shapr> icelandic for example, no clue.
16:17:08 <Pseudonym> But I'm not sure if that's true or not.
16:18:21 * Heffalump is going to Iceland today.
16:18:26 <Pseudonym> I also respond to "saluton", incidentally.
16:18:29 <Pseudonym> In case you care.
16:18:37 <shapr> what's that?
16:18:45 <shapr> Heffalump: your vacation, right?
16:19:38 <Heffalump> yes
16:19:54 <Pseudonym> "Saluton" estas saluteco Esperanta.
16:19:58 <shapr> Cool, I've seen some great pix from Iceland. It looks like a gorgeous place.
16:20:27 <aheller> I heard that there was an argument on panix.flame about appropriate esperanto spelling...
16:20:49 <Pseudonym> aheller: That's kind of disturbing.
16:21:18 <Pseudonym> That someone would actually argue about Esperanto spelling.
16:21:27 <Pseudonym> Or that panix.flame was the appropriate forum for such an argument.
16:21:34 <aheller> the more I learn about panix, the less disturbing I find the particular things I hear.
16:23:09 <Pseudonym> I have thankfully been shielded from this.
16:24:07 <aheller> Eh, I didn't mean is as disparagingly as it looks.
16:29:40 <shapr> This Alex Peake guy on LtU is obviously a spy from Bill Gates.
16:30:09 <shapr> The Evil Empire Strikes Back!
16:30:32 <Heffalump> has anyone read higher-order perl, btw?
16:30:54 * Heffalump looked at the contents page ages ago and thought it'd be all pretty obvious stuff for an experienced functional programmer
16:33:42 <shapr> Silly question, does anyone here not learn new programming languages for fun?
16:33:58 <Heffalump> I don't
16:34:09 <Heffalump> I learn them if I think they would be useful.
16:34:11 <SamB> Heffalump: why not?
16:34:21 <Heffalump> no time, for one thing.
16:34:25 <shapr> How do you know if they'll be useful if you don't learn them?
16:34:58 <dons> moin
16:35:02 <Igloo> That wouldn't be learning them for fun
16:35:02 <shapr> g'day dons
16:35:15 <Heffalump> I learn a language if I have a problem to be solved that I think a new language might help with.
16:35:19 <Heffalump> That's why I learned perl, for example.
16:35:25 <shapr> ok
16:35:39 <Heffalump> I only really know Perl, Haskell, SML, Java, C(++)
16:37:46 <aheller> by the way, am I deficient or is the configure script missing from the head of the yi repository?
16:37:55 <shapr> aheller: autoreconf
16:38:08 <shapr> I'm not really sure which languages I can count as "knowing"
16:38:11 * aheller shows his ignorance
16:38:24 <shapr> aheller: s'okay, dons taught me about autoreconf too
16:38:51 <dons> i learnt autoreconf from sven panne
16:39:02 <dons> the wheel of autotools keeps turning
16:39:11 <shapr> I think I can claim Haskell, Python, Java, not sure what else I can claim to know well.
16:39:54 <shapr> I wonder where learning stuff like Self and Joy fits in there.
16:40:05 <shapr> It's not like I ever plan on doing commercially useful stuff with either of them.
16:40:57 <shapr> They're just so pretty :-)
16:44:29 <wagle> anyone know snobol?  8)
16:51:51 <dons> it would be nice if darcs had an automatic scheme for naming darcs patches sent via email
16:52:02 <dons> something sensible. foo.diff
16:52:17 <Heffalump> YM so you can apply a patch in a non-darcs manner?
16:52:28 <Igloo> Hmm, if you have something not entirely unlike Tree a = Node [Tree] | Leaf a then you won't get the constant space behaviour from walking over the tree that you get from code that walks over a [a], will you?
16:52:54 <dons> Heffa, no. mostly so my syn hl works without having to rename the file ;)
16:53:10 <dons> also, people end up sending me "f" or "dons"
16:53:20 <dons> should be automated.
16:53:28 <dons> "foo.darcs" would be fine.
16:53:30 <wagle> Igloo: constant space?
16:54:11 <Igloo> wagle: The tree you've already visited will stay in memory until you leave the root right at the end
16:55:17 <wagle> postorder traversal?
16:56:37 <Igloo> Oh, that's true, it'll depend on teh traversal type, and this ought to be doing the right one
16:57:51 <Heffalump> igloo: you'll probably end up with the spine of the tree stuck in memory
16:58:00 <Heffalump> but if you visit left children before right children, that should be all
16:58:04 <wagle> hmm..  actually, your nodes contain no data (only the leaf's do)
16:58:21 <Heffalump> if you don't care about any actions at the nodes, you could flatten the tree first
16:58:35 <wagle> all you need to remember is the the tail of the list of children not visited yet
16:58:39 <Igloo> I do care
16:59:12 <Heffalump> well, you'll end up with a bunch of Nodes that are the spine to your current position in the tree
16:59:13 <Heffalump> cos you need them to return to them
16:59:29 <Igloo> Yeah, I'll have to investigate it some more to work out what's going on, I think
16:59:44 <Igloo> Oh, the nodes aren't a problem
16:59:58 <Heffalump> if you only care about acting on the Node before you act on its children, you can probably pass around a [Tree] which is the trees remaining to be processed
17:00:09 <Heffalump> start with a singleton list of the tree you start with
17:00:37 <Heffalump> a processing step is to take the head of the list, act on its Node, and add the children to the beginning of the list in its place
17:00:50 <Heffalump> (if it's a Leaf, process the Leaf and don't add stuff to the list, obviously)
17:01:27 <Heffalump> certainly the Leafs should become garbage once processed in almost any traversal
17:01:38 <Heffalump> (assuming your processing of the Leafs themselves is strict)
17:04:11 <dons> @help wikipedia
17:04:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- search wikipedia and show url of first hit
17:04:21 <dons> @wikipedia lambda
17:04:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://en.wikipedia.org/wiki/Lambda
17:04:39 <dons> @listmodules
17:04:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- babel base dice dict dummy dynamic eval google help karma more pl plugs
17:04:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- quote seen state system topic type version wikipedia
17:04:45 <wagle> @wikipedia sikjfjhfj
17:04:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No matching header
17:04:54 <wagle> YAY!
17:05:09 <dons> hehe
17:05:24 <dons> patch away.
17:06:03 <dons> @karma+ xerox
17:06:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- xerox's karma has been incremented
17:06:40 * shapr cackles evilly
17:06:57 <dons> @karma- shapr
17:06:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- shapr's karma has been decremented
17:07:00 <shapr> this kills lambdabot --> @dice 9999999999999999999999999999d9999999999999999999999999
17:07:08 <dons> kills!
17:07:10 <dons> oh my.
17:07:11 <shapr> @karma shapr
17:07:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
17:07:14 <shapr> heh
17:07:15 <Heffalump> hah!
17:08:07 <dons> musasabi, you see that?
17:08:45 <dons> "runIRC: caught exception: stack overflow"
17:09:06 <wagle> whre, wha?
17:09:07 <shapr> Personally, I think lambdabot got squished under the flash flood of dice 9999999999999999999999999 sided dice.
17:09:14 <dons> yeah
17:09:21 <dons> only in Integer land, heh
17:09:21 * SamB wonders what has happened to his code of late, pulls patches
17:09:31 <wagle> oh,  recursion limit?
17:09:51 <jullur> hey if I have a list of integers, can I change an element in the list with some simple function ? i.e. if I want to change [1,2,3,4,5] to [1,2,3,4,2] ???
17:10:45 <wagle> @type map
17:10:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- map :: forall b a. (a -> b) -> [a] -> [b]
17:10:51 <dons> I wonder how I can ensure that a stack o.f. in a plugin doesn't kill the whole bot. hmm.
17:11:02 <jullur> k thnx
17:11:14 <shapr> Can you really separate it like that?
17:11:19 <Pseudonym> jullur: WHat are you trying to do?
17:11:34 <Pseudonym> There's a better than even chance that you're actually doing something that's not a good idea. :-)
17:11:38 <SamB> by running the plugin in a vm of some kind
17:11:56 <dons> that's how @plugs works (sort of) - just run it in its own address space
17:12:14 <dons> but it's too hard to partition all of the plugins as separate processes.
17:12:37 <shapr> Whyso?
17:12:40 <dons> maybe in DiceModule's case it is easier to just tidy the input
17:12:41 <SamB> fork first ;-)
17:12:42 <Heffalump> well, storing their state is the problem
17:12:56 <jullur> Pseudonym: hehe might be, I have to print out a certain number of stars according to some integers in a list that change in each round. Some game for a school projecrt
17:12:58 <SamB> which wouldn't work well for state...
17:13:00 <Heffalump>  @plugs doesn't store state from one call to the next
17:13:16 <SamB> but I was kidding about forking anyway
17:13:19 <dons> neither does Dice (I think).
17:13:21 <Lemmih> @seen SyntaxNinja
17:13:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SyntaxNinja is in #haskell. I don't know when SyntaxNinja last spoke.
17:13:31 <Heffalump> ok, so modules without state would be fairly easy
17:13:35 <dons> yep.
17:13:42 <wagle> i was figuring that jullur would try map for a bit, then either find it was or wanst what he wanted
17:13:44 <Heffalump> could probably make a combinator that just alters the way they run
17:13:52 <SyntaxNinja> hi Lemmih
17:14:00 <dons> a 'fuel' combinator?
17:14:00 <Lemmih> SyntaxNinja: Yo.
17:14:07 <Heffalump> why fuel?
17:14:22 <dons> trying to work out what you mean by "just alters the way they run"..
17:14:22 <shapr> just like @eval
17:14:25 <Heffalump> making module state serialisable where possible would be cool anyway
17:14:33 <dons> oh. but we have that!
17:14:47 <Heffalump> dons: I mean "make it run forked"
17:14:53 <wagle> in either case, he'd learn map, which would be useful
17:14:55 <Heffalump> as opposed to just running in the same process space
17:14:59 <dons> yep. ok.
17:15:03 <dons> runOverThere foo
17:15:11 <Heffalump> oh, there'd need to be a way to pass back the effects on the IRC monad
17:15:31 <Heffalump> (i.e. the IRC actions)
17:15:50 <Heffalump> hrrm. Not trivial, then.
17:15:57 <jullur> sleeping in classes isn't such a good idea after all :)
17:16:01 <dons> hmm. i wonder if something like @dice should run on @plugs..
17:16:11 <jullur> but thnx anyway I'll try to work this out myself :)
17:16:15 <dons> then it could reuse all the solid @plugs infrastructure
17:16:31 <wagle> force tail recursion, than add a stack monad..  (half joking)
17:16:32 <dons>  runOverThere == runInPlugs
17:16:33 <Heffalump> I thought @plugs was a lightweight interface to hs-plugins?
17:16:44 <wagle> s/than/then/
17:16:53 <dons>  it's an interpreter implemented via dynamic linking
17:17:16 <Heffalump> it doesn't compile the code?
17:17:26 <dons> yep, it does. via ghc, via hs-plugins.
17:17:45 <dons> but it's in another address space, over a fork.
17:17:48 <SamB> so why did someone copy and paste my google code into WikipediaModule.hs, make a tiny change, and expect it to work? hmm, even better, why did it work...
17:17:57 <Pseudonym> jullur: If you need an array, using a list is not the way to do it.
17:18:09 <Pseudonym> However, if it's a school project, then it's probably not an issue.
17:18:48 <dons> SamB, send a patch.
17:19:23 <wagle> shapr: you figure out how to typecheck tilings?
17:19:26 <Pseudonym> SamB: Go ahead.  Go debug someone else's code.
17:19:34 <jullur> Pseudonym: I could have used string(which seems the most simple way to do it) but the teacher told us to use lists, so I just have to live with that
17:19:41 * Pseudonym nods
17:19:43 <dons> I kind of like this idea of running potentially dangerous code on @plugs
17:19:47 <Pseudonym> THough a string is a list.
17:19:48 <SamB> but it actually should work...
17:19:50 <SamB> @wikipedia haskell
17:19:56 <Pseudonym> @plug fireNuclearWeapons
17:20:14 <dons> hmm..
17:20:28 <Pseudonym> @plug system "cat /etc/passwd"
17:20:34 <Pseudonym> How dangerous is dangerous?
17:20:45 <dons> anything with a large fold ;)
17:20:45 <SamB> might crash the interpreter hard?
17:20:59 <dons> more that it might eat up memory or time
17:21:19 <SamB> most people call that "expensive"
17:21:35 <dons> that was me. it was sitting on @wikipedia for some reason.
17:22:15 <wagle> @plug system "cat /etc/passwd"
17:22:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "plug", try "lambdabot: @listcommands"
17:22:22 <wagle> aww
17:22:32 <SamB> @plugs system "cat /etc/passwd"
17:22:32 <dons> guys. it's @plugs
17:22:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `system'
17:22:42 <jullur> yeah they say it is =)
17:22:42 <dons> why does anyone think that would work?
17:23:28 <monochrom> Because of my great success the other day.
17:23:29 <wagle> @plugs exec "adduser badguy"
17:23:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `exec'
17:24:01 <SamB> @plugs System.system "cat /etc/passwd"
17:24:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `System.system'
17:24:11 <Pseudonym> dons: We're just looking for ways to hAX0R your machine.  That all right with you?
17:24:20 <Igloo> @plugs letm3in
17:24:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `letm3in'
17:24:23 <dons> oh. please do carry on.
17:24:49 <wagle> @plugs eval "adduser badguy"
17:24:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `eval'
17:25:05 * wagle 's heart isnt in this
17:25:08 <dons> hehe
17:25:19 * Igloo goes to turn down my notice's purple obnoxiousness
17:25:26 <Darius> Can't you catch (in GHC) StackOverflow errors?
17:25:44 <dons> probably. if so that's easy.
17:26:00 <dons> Darius, what do you think of the idea of running things like @dice on @plugs
17:26:18 <dons> so we get the resource limits, and foreign addr space.
17:26:58 <Darius> dons: I think we should add an alias thingy so that @dice can simply be defined to use @plugs, unfortunately that limits the complexity of the expressions, but there are ways around that.
17:27:28 <Heffalump> igloo: let me know if you work out how to fix that (and the :#haskell thing). dons' advice last week didn't work for me
17:27:36 <dons> if we trust the author (so it's already part of lambdabot code) then we can relax the type and context restrictions
17:27:52 <dons> i mean, we already let @dice run inside lambdabot
17:28:09 <Igloo> I have   notice = "%K-%n%p$0%n%K-%n ";   in the "abstracts = {" section of my theme
17:28:41 <Darius> dons: The issue is stuffing everything in a single @alias line or building up libraries of plugs code via IRC.
17:28:51 <wagle> a good clean design for resource constraints for plugins would be a publishable paper, me thinks
17:29:02 <dons> hmm. that's interesting.
17:29:14 <Darius> We could just write stuff to a module (assuming it compiles) and have that be that, but that has issues.
17:29:21 <SamB> seriously, dons, look at http://naesten.dyndns.org:8080/lambdabot-google-wikipedia.diff...
17:29:25 <Heffalump> I think pubnotice_channel may be the setting that's relevant
17:30:07 <dons> I'm not thinking so much of adding stuff dynamically through irc via @alias, but just having an internal method of limiting resources, as wagle says
17:30:12 <Darius> wagle: Wouldn't you need the underlying systems help (though you could do it through similar means as Software Fault Isolation).
17:30:33 <Igloo> Oh, I also have that set to ""
17:30:43 <dons> SamB, I'm not sure what the point is? You're surprised that it works?
17:30:48 <Igloo> And now have pvtnotice_host = "%K%n"; too, having just msged lambdabot  :-)
17:31:01 <Darius> dons: @plugs should work (or at least work as much as it does now), no?
17:31:02 <Igloo> In fact, that's probably the same as ""
17:31:03 <SamB> dons: well, not anymore.
17:31:40 <dons> I think @plugs would work, possibly augmented with, say, --load Foo.o to run arbitrary objects in a restricted env
17:32:14 <SamB> now I just don't like the duplication...
17:32:28 <Pseudonym> This MJD interview is very amusing.
17:32:36 <Pseudonym> And bloody insightful, much like anything MJD writes.
17:32:41 <dons> true. we could merge wikipedia and google.
17:32:45 <wagle> Darius: i have biases, but no proofs
17:32:53 <SamB> what should we call it?
17:32:54 <wagle> MJD?
17:32:55 <Pseudonym> MJD is a very cool guy.  Met him once.
17:33:00 <Pseudonym> Mark Jason-Dominus.
17:33:04 <Heffalump> Pseudonym: insightful how?
17:33:09 <SamB> You tell me what to call it and I'll merge it ;-)
17:33:13 <wagle> where's the interview?
17:33:19 <Pseudonym> http://www.theperlreview.com/Interviews/mjd-hop-20050407.html?up
17:33:57 <Pseudonym> He's that rarest of beasts, a Perl hacker who gets seriously pissed off with the Perl community.
17:34:31 <SamB> dons: so what should it be called?
17:34:36 <dons> SamB. I don't know, think up something -- and come up with a better msg than "empty header" :)
17:34:45 <wagle> thx
17:34:47 <dons> but they should be merged for sure.
17:34:49 <SamB> dons: okay
17:35:07 <dons> I'll get some time in a few hours to hack. bit busy atm
17:35:07 <Darius> I'm not sure whether Lisp hackers might succeed.  There are a lot of people who get seriously pissed off with the Lisp community, but I'm not sure how many would be hard-core Lisp hackers.
17:35:52 <SamB> dons: I have to go help with dinner anyways.
17:35:53 <wagle> Darius: thats me
17:36:19 <Heffalump> Pseudonym: I read that interview before, and still don't see anything particularly insightful about it.
17:36:26 <dons> ok.  if you want to work on making both modules solid and stable, that'd be appreciated.
17:36:45 * Lemmih is amazed by how many erroneous statements Alex can make in only one mail.
17:36:59 <Pseudonym> Heffalump: You might have to have been a Perl hacker to appreciate it.
17:37:21 <Heffalump> I've hacked Perl and still do. Even written a bunch of code using HOFs in Perl.
17:37:41 <Pseudonym> I find it interesting that this comes at a time when Guido is considering removing lambda from Python.
17:38:05 <Pseudonym> Heffalump: Were you ever a part of "the Perl community"?
17:38:14 <Heffalump> nope.
17:38:14 <wagle> i think i mostly got pissed off by a growing trend to stop trying to give me the right tool for the right job, and just to try to stop me from doing "bad things"
17:38:17 <Pseudonym> Right.
17:38:31 <Pseudonym> Perl is actually the first language to take sociolinguistics seriously.
17:38:38 <Pseudonym> Or at least to admit it.
17:38:45 <wagle> hence "puritanical macros"
17:38:50 <wagle> (for example)
17:39:01 <Heffalump> @plugs foldr (\x y -> y ++ [x]) [] "Erewhon"
17:39:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "nohwerE"
17:39:17 <Heffalump> grr, I still have the purple :#haskell thing
17:39:23 <mugwump> Er, wasn't that an April Fool's joke?
17:39:30 <Pseudonym> Was it?
17:39:38 * Pseudonym can't keep up with these any more
17:39:42 <mugwump> Where's the URL to the announcement?  :)
17:39:49 <Darius> wagle: I'm more talking about the CL community than the Scheme one.  I have to say I agree (I think it actually was MJD that said it in the above interview) that (Common) Lisp's community is pretty dysfunctional.
17:39:51 <Pseudonym> Dunno.
17:40:08 <Igloo> Are you reloading the theme? I have to load another one then load the one I want again
17:40:16 <Pseudonym> Ah, well, guess I fell for it.
17:40:21 <wagle> Darius: i'm talking only about scheme..  ENOCLUE about common lisp
17:40:46 <Darius> wagle: Lurk c.l.l for a while and it's pretty easy to get tired of them.
17:40:50 <Pseudonym> Well, Common Lisp is fairly dysfunctional to begin with.
17:41:24 <wagle> Darius: you got a short summary to save me from that safari?
17:42:08 <Darius> Not really, one of the main things though, I guess, is that most seem horribly afraid of change.
17:42:41 <Darius> And of course, you have the "Lisp is the be-all end-all language", but that isn't particularly atypical.
17:42:51 <Darius> But they are more annoying about it than most programming communities.
17:43:14 <SamB> SearchModule? WebSearchModule? SearchEngineModule?
17:43:25 <wagle> Darius: thanks
17:43:35 <Darius> SamB: AssortedJunkModule?
17:43:50 <dons> SamB. yeah. Search isn't too bad.
17:44:12 <Heffalump> igloo: oh. that sucks.
17:44:22 <Heffalump> It did complain about a syntax error in it when I got it a bit wrong.
17:44:35 <Heffalump> how do you load a theme?
17:44:42 <wagle> @seen shapr
17:44:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- shapr is in #haskell. I don't know when shapr last spoke.
17:44:54 <Igloo> With /set theme igloo
17:45:03 <mugwump> http://www.artima.com/forums/flat.jsp?forum=106&thread=98196  # clearly, it wasn't an April Fool's joke.
17:45:43 <Pseudonym> Yup, that's definitely pre-April Fool's Day.
17:45:57 <Pseudonym> So there you go.
17:46:18 <mugwump> Well, it should have been
17:46:19 <Pseudonym> And it's not lambda, it's reduce, filter and map.
17:46:28 <araujo> Hello.
17:46:35 <hefner> Darius: you're suggesting that "Lisp is the be-all end-all language" is a meme infecting the lisp community rather than the logical conclusion reached by most of its members?
17:47:17 <mugwump> to be a "be-all and end-all language", all it needs to do is encourage language jihad
17:47:33 <Darius> hefner: That conclusion can't be derived logically, so I'm definitely not suggesting the latter.
17:47:48 <hefner> illogical conclusion, then?
17:48:48 <Darius> hefner: I'd say most of the "pillars" of the community have reached that conclusion not unreasonably.
17:48:53 <Pseudonym> The fact that we're still using Lisp, when mainstream Fortran and Cobol use has died, is certainly impressive.
17:49:01 <Darius> hefner: But that isn't too different than most language communities.
17:49:05 <Pseudonym> (For some definitions of "mainstream".)
17:49:12 <Heffalump> @plugs foldr (\x y -> y ++ [x]) [] "woot"
17:49:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "toow"
17:49:16 <Heffalump> ahah.
17:49:38 <dons> @pl foldr (\x y -> y ++ [x]) [] "woot"
17:49:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "toow"
17:49:43 <dons> too smart.
17:49:53 <wagle> you can convert fortran to C
17:49:58 <Darius> PseudonyM: I think Ralf Laemmel has a paper that cites COBOL as the most used language in the world as of when the paper was written (which wasn't that long ago).
17:50:07 <dons> @pl \l -> foldr (\x y -> y ++ [x]) []
17:50:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- const (foldr (flip (++) . (: [])) [])
17:50:16 <dons> much clearer
17:50:31 <Heffalump> clearly.
17:50:41 <Darius> And Fortran doesn't really appear that dead either.  I'm not sure if (by some objective methods) Lisp -is- more mainstream than Fortran.
17:50:42 <wagle> (i worked with a very large chemistry modelling system where mountains of fortran from the 60's and 70's had been so converted
17:50:48 <dons> learning to flip (,) was one of the best things @pointless has taught me
17:51:14 <Heffalump> @pl foldr (\x f -> f . (x:)) id "woot" []
17:51:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "toow"
17:51:21 <Heffalump> hah. the one true way
17:51:28 <wagle> @pl "woot"
17:51:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "woot"
17:51:45 * wagle feels disappointed, somehow
17:51:51 <dons> @pl \l -> foldr (\x f -> f . (x:)) id l []
17:51:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip (foldr (flip (.) . (:)) id) []
17:52:04 <Heffalump> you are a sick, sick monkey.
17:52:07 <wagle> @pl flip flip
17:52:08 <mugwump> @pl reverse "toow"
17:52:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip flip
17:52:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- reverse "toow"
17:52:10 <Pseudonym> Here's my reasoning.
17:52:20 <Pseudonym> 1. No _new_ systems are being written in Cobol.
17:52:20 <wagle> @pl swing swing swing swing swing
17:52:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- swing swing swing swing swing
17:52:27 <Pseudonym> You'd agree with that, Darius?
17:53:09 <wagle> there are still niches using cobol, i hear
17:53:10 <Darius> Pseudonym: I agree that Lisp is in a better place than Cobol.  I'm not sure whether Fortran should be counted out, but it seems more of a niche thing.
17:53:27 <Pseudonym> 2. Apart from numeric code, no new systems are being written in Fortran.
17:53:45 <Pseudonym> 3. Apart from numeric code, very few systems in Fortran are even being maintained.
17:54:15 <Pseudonym> So apart from legacy code (in both cases), and niche code (in the case of Fortran), the languages aren't really used.
17:54:19 <Pseudonym> That's my reasoning.
17:54:33 <wagle> http://www.pgroup.com/
17:54:42 <Pseudonym> Lisp, on the other hand, is not a niche or legacy language (though it does have niche code and legacy code).
17:54:44 <wagle> still does fortran
17:55:13 <dons> I think there are physics guys still in to fortran
17:55:31 <Pseudonym> Fortran isn't close to dead in its niche.
17:55:38 <dons> they scare me at parties when they tell me what programming they do.
17:55:38 <wagle> i had a friend who wrote CGI in fortran
17:55:46 <Pseudonym> But my point is that people aren't maintaining the compilers that used to be written in Fortran.
17:55:57 <Pseudonym> And LR parser generators.
17:56:02 <dons> some of the physics guys are discovering this language called ``C''
17:56:10 <dons> the new PhDs anyway.
17:56:20 <Pseudonym> Stuff that's outside the Fortran niche has been rewritten for the most part.
17:58:07 <wagle> optimization is probably easier in fortran than C
17:58:35 <wagle> much easier to write hard to optimize code in C than fortran
17:59:02 <wagle> pointers, for example
18:00:35 <Pseudonym> Actually, the only thing that makes C harder to optimise is pointer aliasing.
18:00:36 <dons> though pointers aren't the whole issue -- there's even more pointers in compiled haskell ;)
18:00:45 <Pseudonym> In Fortran, all values are passed by reference.
18:00:53 <Pseudonym> As can be verified by changing the value of 4.
18:02:18 <wagle> fortran has syntactic support for parallelism, i believe
18:02:25 <Pseudonym> HPF does.
18:02:32 <Pseudonym> I don't know about Fortran 90 or whatever it is.
18:03:12 <wagle> there was some support in the mid to late 80's, dunno which versions of fortran that was
18:03:31 <Pseudonym> My point remains that Lisp has outlived its contemporaries, in a sense.
18:03:49 <Pseudonym> And hence must have done something right.
18:04:04 <SamB> what do they call the first line of an HTTP result?
18:04:23 <Darius> Pseudonym: I think you'd agree that CL is more different from Lisp 1.5 than modern Fortran (as it's used) is from FORTRAN.
18:05:09 <Darius> Pseudonym: Lisp definitely did some things right.  Fortran did too, it just isn't really and never really was intended as a general purpose language.
18:05:34 <Darius> At least that's my impression though it was probably "general-purpose" when it was made.
18:05:35 * Pseudonym nods
18:06:01 <wagle> "FORmula TRANslation"
18:06:17 <Pseudonym> The thing is, it's the meme that Lisp is the be all and end all of programming languages that deserves a little more attention than out-of-hand dismissal.
18:06:25 <Pseudonym> It's wrong, obviously.
18:06:29 <wagle> "LISt Processing""
18:06:38 <Pseudonym> The assertion is incorrect.
18:06:39 <Darius> I don't dismiss it out of hand.
18:06:48 <Pseudonym> But Lisp definitely hit a sweet spot that no other language has.
18:06:57 <wagle> s-expressions
18:07:07 <wagle> the universal lego
18:07:10 <Pseudonym> Unless you count modern Lisp-like languages, of cours.e
18:07:12 <hefner> Darius: I could probably be accused of "lisp is the end-all of languages" thinking, but my objection would be due more to the syntax than the semantics to most other languages. That the stubborn insistence on s-exp syntax basically limits my choices to CL and Scheme is unfortunate, but I can make due. :)
18:07:41 <hefner> (underlying this is of course the belief that doing lispy things with s-exps is a fundamental good)
18:07:54 <wagle> s-expressions can be more useful than strings
18:07:56 <Pseudonym> It would be nice to have a language that has the advantages of s-expressions, but was more optimal for humans.
18:08:06 <Darius> Lisp has -evolved- to a relatively sweet spot, though it did a lot of things right in it's foundations as well admittedly.
18:08:13 <Pseudonym> Prolog comes close, but it's a bit archaic these days.
18:08:19 <Pseudonym> Its syntax, that is.
18:08:49 <Darius> However, when CL was set in stone it apparently was -set in stone- for many users.
18:08:58 * Pseudonym nods
18:09:04 <wagle> i've heard the claim that XML replaces and improves upon s-expressions
18:09:06 <Igloo> @index isRight
18:09:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
18:09:10 <Pseudonym> It's a shame that CL has such a crufty standard library.
18:09:27 <Darius> hefner: You can't possibly be a hardcore Lisper.  You wouldn't be here otherwise ;)
18:10:09 <Darius> wagle: Did this claim come from a producer of harddrives, RAM, or a supplier of bandwidth by any chance? :P
18:10:21 <wagle> Darius: hahahahaah..  but no
18:10:31 <hefner> wagle: similarly, I've heard that PL-1 has many of the same data types as Lisp
18:10:56 <wagle> PL-1 is huge, prolly has EVERYTHING
18:11:10 <hefner> (but last time I mentioned it, someone hit me with a stick..)
18:11:46 <mugwump> Pseudonym: so go put them into Perl 6 :)
18:11:53 <monochrom> if it has user-definable monads I won't hit you with a stick.
18:12:02 <Darius> Pseudonym: Forth or other concatenative languages (not sure if it's more optimal, but at least it's a lateral change)
18:12:39 <Pseudonym> Forth suffers fromt he same problem that Lisp does, syntax-wise.
18:13:27 <Darius> Pseudonym: What do you consider the largest problem with Lisp syntax?
18:13:30 <hefner> jeez. The only syntactic extension I really want in lisp is something that lets me switch to writing postfix, Forth-like code. =p
18:14:01 <Pseudonym> Darius: The impedance mismatch with the way that people want to program.
18:14:08 <Pseudonym> People want some syntactic sugar.
18:14:12 <Pseudonym> e.g. infix operators.
18:14:14 <wagle> nah
18:15:03 <wagle> i lived comfortably without infix for years
18:15:20 <Pseudonym> There's something to be said for Pascal's syntax, where every two identifiers are separated by at least one operator.
18:15:30 <wagle> takes some getting used to, but you can get used to it
18:15:43 <Darius> The biggest thing I wanted (and admittedly could have gotten) syntax-wise with Lisp is simply more concise function names and a shorter keyword for lambda.
18:15:49 <wagle> program main (...)
18:15:55 <Pseudonym> The other problem with Lisp's syntax is that parentheses are semantically overloaded.
18:16:14 <Pseudonym> The same syntax is used for conceptually quite different "things".
18:16:24 <wagle> i claim that there arent parens in scheme..  >)
18:16:56 <wagle> parens are just an artifact of the reader syntax
18:17:06 <hefner> Pseudonym: no it isn't, its always used to build lists and atoms. You're looking at the wrong layer of abstraction. =p
18:17:23 <wagle> gotta be able to convert strings to anbd from s-expressions
18:17:27 <Darius> Pseudonym: To an extent couldn't you argue that for many tokens?
18:17:51 <Pseudonym> Darius: Yes, and they're suboptimal too.
18:17:59 <Pseudonym> I don't claim that Lisp is unique here.
18:18:01 <wagle> i assert that scheme programs are not strings
18:18:12 <Pseudonym> But because its syntax is uniform, Lisp suffers from it more than many.
18:18:33 <Pseudonym> Forth, PostScript and Logo are arguably worse than Lisp in this respect.
18:18:36 <wagle> s/abnd/and/
18:18:54 <wagle> s/anbd/and/  (rather)
18:18:57 <hefner> Pseudonym: it may suffer, but at least it doesn't fall over and die when you run out of random characters to assign things to
18:18:59 <Darius> Pseudonym: To an extent I'd say they're better. ' ' always means the same thing.
18:19:11 <Pseudonym> But '(' doesn't.
18:19:18 <Pseudonym> Syntactically it means only one thing.
18:19:24 <Pseudonym> But semantically it means more than one thing.
18:19:36 <Pseudonym> Hmmm.
18:19:42 <Pseudonym> Maybe my beef here is the two-level grammar.
18:19:47 <Pseudonym> Three-level, actually.
18:20:12 <Pseudonym> Most languages are two-level: lexical and syntactic.
18:20:19 <Pseudonym> But Lisp has another layer of grammar on top of that.
18:20:27 <wagle> scheme is a hell of a lot more confusing if you identify the string representations with the s-expression (data structure) representations
18:20:29 <Pseudonym> (So does Prolog, for that matter.)
18:20:41 <Darius> Pseudonym: With Forth I'd say that the -words- behave dramatically different, but for Joy which is much more regular, ' ' really is the same syntactically and semantically for the most important forms of the language.
18:20:59 <Pseudonym> Given that I don't know Joy, I'll assume you're right. :-)
18:21:28 <Darius> It's like Forth, but pure and doesn't have 'compiling'-interpretations or 'parsing words' etc.
18:21:36 * Pseudonym nods
18:21:55 <Darius> Essentially, the white space between words always means (.).
18:22:02 <wagle> (s-expressions consist of pairs, nil, symbols, strings, numbers, etc)
18:22:39 <Darius> wagle: But Scheme source doesn't or rather the set generated from them is not the smallest set containing Scheme source.
18:23:04 <Darius> wagle: So one really can't complain about treating Scheme programs as strings if you are just going to do the same thing with lists.
18:23:15 <Darius> (add quotes to "lists" btw)
18:23:28 <wagle> Darius: i couldnt parse your first
18:24:01 <wagle> i can generate programs that never exist as stringds
18:24:03 <Darius> The set of S-expressions representing Scheme programs is a proper subset of S-expressions.
18:24:03 <wagle> i can generate programs that never exist as strings
18:24:15 <Darius> wagle: I can generate programs that never exist as lists.
18:24:54 <Pseudonym> Darius: Right, just like the set of sequences of C tokens representing C programs is a proper subset of sequences of C tokens.
18:25:12 <wagle> Darius: sure..  i claim that s-expressions (not strings) are parsed (maybe) into programs
18:25:23 <Darius> Pseudonym: Just like the set of strings representing Scheme programs is a proper subset of Strings.
18:25:32 <wagle> Darius: primitives
18:25:33 <monochrom> I can generate programs that never exist as executable code. :)
18:25:40 <Pseudonym> If you have S-expressions, additional parsing is needed to determine its Scheme program structure.
18:25:54 <wagle> monochrom: more of those in haskell than in scheme..  8)
18:25:55 <Pseudonym> If you have a C AST, you need no additional parsing to determine its C program structure.
18:26:07 <Pseudonym> Ergo, Scheme has more levels of grammar than C does.
18:26:15 <Pseudonym> (Ignoring the C preprocessor.)
18:26:20 <hefner> Pseudonym: I don't think its really as bad as that
18:26:43 <hefner> Either way you have some tree that needs to be walked with some intelligence to do anything useful with it
18:27:07 <Pseudonym> From a compiler implementor's point of view, you're right.
18:27:18 <Pseudonym> From a programmer's point of view, I don't think you're right.
18:27:25 <wagle> Darius: i'm pointing out that a number of odd things happen as strings are converted to s-expressions
18:28:25 <wagle> Pseudonym: yes, s-expressions are a datat structure that can be used for many things, including representing programs
18:29:21 <wagle> apparently, Pseudonym and i are violently agreeing?
18:30:13 <wagle> i'm claiming that the s-expression datastructure in the heap is the fundamental representation in scheme, and strings are secondary
18:30:28 <Pseudonym> I don't think I've mentioned strings. :-)
18:30:37 <Pseudonym> Cross-purposes and all that.
18:30:42 <hefner> Pseudonym: from a programmers point of view, you dispatch on the first symbol of a form the same as you'd dispatch on the type of an AST node in an OO language, only (sadly) there's no useful hierarchy of types or methods defined to help you. Sad, but easily remedied with some library code..
18:30:47 <Darius> wagle: My question is why did you bring it up?
18:31:01 <Pseudonym> hefner: So in a lambda expression, you dispatch on the lambda symbol?
18:31:26 <skew> Pseudonym: is your problem that the parens are printable symbols and clutter up the screen, and it's not necessarily easy for a human to extract the tree structure?
18:31:32 <wagle> Darius: to see what happens
18:31:59 <Pseudonym> No, my problem is that parentheses are used for everything, including semantically quite different things.
18:32:18 <Pseudonym> C, for example, uses braces for control structures and parentheses for expressions.
18:32:29 <wagle> Pseudonym: parens are only in the strings, which you now claim you didnt bring up
18:32:32 <Pseudonym> (Mind you, there's a stronger argument for that in imperative programming.)
18:33:03 <Pseudonym> wagle: OK, so maybe I want a different string representation.
18:33:11 <Pseudonym> But I want one that the compiler can check.
18:33:27 <Pseudonym> Because controlled redundancy is good if the compiler can check it.
18:33:59 <wagle> i claim that scheme compilers never seen strings
18:34:04 <wagle> i claim that scheme compilers never see strings
18:34:21 <Pseudonym> That's a problem, then.
18:34:21 <Darius> wagle: I claim that Scheme programmers do see strings.
18:34:25 <hefner> I say that brewing up random syntax for everything you need is cute, but only scales until you run out of punctuation or are no longer able to distinguish the symbols. Declaring that my language will only treat expressions and control structures on equal footing and locking out anything I think of later seems short-sighted.
18:34:31 <hefner> (I type too much..)
18:34:34 <Pseudonym> How, for example, would your Scheme compiler report an error?
18:34:39 <wagle> Darius: no i dont..  (sorta)
18:34:48 <Pseudonym> How would it relate that back to what the programmer typed?
18:35:00 <skew> It sounds like your problem is that the parens and all the rest of the code are at different levels of the grammar, but are both mixed into the text of the program
18:35:09 <wagle> i write scheme programas that write scheme programs
18:35:12 <Pseudonym> This reminds me of the Prolog compiler which had the helpful error message "Your program contains one or more syntax errors."
18:35:25 <Darius> wagle: But you still write Scheme programs.
18:35:37 <skew> maybe some kind of layout rule could help
18:35:42 <Darius> Pseudonym: Better than "zero or more" ;)
18:35:57 <Pseudonym> Yes. :-)
18:36:17 <Pseudonym> My problem is that the same syntax is used for semantically different things.
18:36:23 <Pseudonym> I do not see this as a strength,.
18:36:30 <Pseudonym> Because it hurts readability.
18:36:31 <Igloo> OK, I think I'm being dopey. I want to do essentially   foo xs = (filter p xs, filter (not . p) xs)    bar xs = (\(ys, zs) -> print ys >> print zs) (foo xs)   without keeping all of xs in memory until the first print finishes (ys being empty is a common case). Can I do this without massive restructuring?
18:36:48 <wagle> Darius: i write scheme programs that write scheme programs that write scheme programs
18:36:58 <wagle> coinductively..  8)
18:37:44 <skew> Pseudonym: the way I see it, it's "let" or "define" or "lambda" that's the real syntax, and the parens are just grouping. What would you suggest instead?
18:37:48 <wagle> half joke, but the string syntax really doesnt matter to me, since i spend most of the time in the s-expression data structures in the heap
18:38:05 <Pseudonym> skew: I'd suggest using some other language. :-)
18:38:14 <Pseudonym> I wouldn't touch Lisp because it's on a sweet spot.
18:38:23 <Pseudonym> Lisp/Scheme
18:38:31 <Pseudonym> If you changed it, it would be less useful than it is.
18:38:39 <Pseudonym> So I use some other language instead.
18:39:12 <wagle> Pseudonym: i claim that there is no spoon^H^H^H^H^H paren.  you keep saying that parens have diffent semantics..  what do you mean (give example?)
18:39:13 <hefner> (I'd like some syntactic niceties while coding lisp too, but I'd prefer they be done by my editor at the presentation level)
18:39:54 <skew> I don't want to just disregard the ability to effectively define new syntax in Lisp because the parens look funy
18:40:55 <Darius> Igloo: If you make a copy of xs it may work...
18:40:57 <skew> If uniform syntax with parens building trees is unacceptable, and macros only work with that syntax, then something has to give
18:41:16 <Darius> Luckily, the latter assumption doesn't hold.
18:41:29 <wagle> macros convert s-expressions to s-expressions
18:42:01 <Darius> wagle: Yeah, that's to an extent one of their problems, but I don't view it as a very significant one in practice.
18:43:00 <wagle> puritanical^H^H^H^H^H^H^H^H^H^H^H hygienic macros try to imagine that the s-expression is a static scope
18:43:38 <wagle> ... which is good if you are transforming programs, but bad if you are constructing programs
18:44:15 <Pseudonym> wagle: I'm talking specifically about what a typical Lisp/Scheme programmer writes.
18:44:22 <Pseudonym> When constructing a program.
18:44:37 <wagle> Pseudonym: i guess i could not claim that i'm typical
18:45:07 <Pseudonym> You could argue that the typical Scheme programmer programs in macros.
18:45:09 <Pseudonym> Which is somewhat true.
18:45:10 <wagle> i'm very atypical
18:45:27 <Pseudonym> They use macros that are built into the libraries that they use, certainly.
18:45:32 <Pseudonym> Which is more true in Lisp than in Scheme.
18:45:56 <wagle> i dont think that there are that many macros in scheme
18:46:15 <wagle> hmmm
18:46:51 <Pseudonym> It's certainly true in Lisp.  Even DEFUN is a macro in Common Lisp.
18:47:06 <wagle> (trying to remember, havent really programmed in scheme for quite a while, except when i write scheme interpreters in new languages as "helloworld"
18:47:13 <Pseudonym> But, for example:
18:47:17 <Pseudonym> (lambda (x) x)
18:47:25 <Pseudonym> The outer and inner parens mean different things.
18:47:34 <skew> I think we can all agree that doing let as a TH macro would be horrible. $(let [("a",[[ 10 ]]),("that takes a list of pairs of string
18:47:47 <wagle> Pseudonym: you seen 3-lisp/
18:47:49 <wagle> ?
18:47:51 <Pseudonym> Nope.
18:48:12 <skew> $(let [("a",[[10]]),("b",[[ a + 2 ]])] [[ a + 2*b ]])
18:48:38 <wagle> thats the language brian cantwell smith invented to demonstrate reflection in his 1984 dissertation
18:49:15 <wagle> he separates lists from rails
18:49:30 <wagle> ( is for lists, [ is for rails
18:49:40 * Darius hasn't finished reading the paper because it's scanned pages.
18:49:51 <Darius> I assume that's one of his "semantic rationalizations"
18:50:18 <wagle> Darius: yeah..  (i havent read it for a while)
18:50:44 <wagle> so (lambda (x) x) is (lambda [x] x)
18:51:09 <wagle> and (+ 1 2) is syntactic sugar for (+ . [1 2])
18:51:47 <wagle> i'm thinking that he might be talking about what you are
18:52:14 <Pseudonym> Interesting.
18:52:28 <Pseudonym> Yes, he might be.
18:52:32 <Pseudonym> Or something close to it.
18:53:01 <skew> Pseudonym: an example of what you are saying about semantic overloading might help
18:53:18 <wagle> he's got two shorter (ie readable) papers in addition to the dissertation
18:53:30 <Pseudonym> http://www.csse.monash.edu.au/~damian/papers/#Human_Factors_in_Programming_Languages
18:53:45 <Pseudonym> There's a rather good paper there, by Damian Conway.
18:53:56 <Pseudonym> "Seven Deadly Sins of Introductory Programming Language design".
18:54:07 <wagle> in your (lambda (x) x), the outer parens parse as an expression, the inner parse as a formals
18:54:37 <wagle> to wit, (lambda x x) is valid scheme (no inner parens)
18:55:44 <wagle> by the way, i've been claiming above that (among other things) scheme is taught wrong
18:56:46 <Darius> wagle: One line summary?
18:57:40 <wagle> Darius: hahaha
18:58:54 <wagle> old pet peeve, not recently much thought about, brought up here to see what reactions i get to use to evolve it to something better:
18:58:58 * Darius hasn't read the paper Pseudonym mentioned (just started) but doesn't view Haskell as a good language to teach programming with (alone) and suspects he'll be able to guess some of the issues that will come up.
18:59:24 <skew> Pseudonym: That's an interesting paper. I was hoping it would explain what you were talking, but it didn't seem to.
18:59:28 <Pseudonym> Yes, probably.
18:59:31 <Pseudonym> Although...
19:00:04 <wagle> (1) scheme programs are not strings, strings are just the primary way to get s-expressions into the heap..  (programmer still needs to be facile is mentally converting back and forth when possible
19:00:16 <Pseudonym> Haskell has been used successfullly as a first language.The secret is to only use the GHCi or Hugs command line.
19:00:20 <wagle> (2) the top-level context is REALLY WIERD
19:01:06 <Pseudonym> skew: Not specifically, but my concerns are along similar lines.
19:01:18 <wagle> (especially wrt continuations)
19:01:21 <Pseudonym> In particular, the Lisp family uses the same syntax for semantically different things.
19:01:28 <Pseudonym> And this does not help readability.
19:01:29 <Darius> Pseudonym: I'm not saying it can't be done, but that it has some things that I believe make it less than ideal (though some things seem very helpful unfortunately some of those things are some of the things that make it less than ideal).
19:01:45 * Pseudonym nods
19:01:56 <Pseudonym> There's an advantage to teaching first year students Pascal first.
19:02:30 <wagle> pascal?
19:02:41 <wagle> does that still exist?
19:02:41 <Pseudonym> Sure.,
19:03:07 <Pseudonym> It should. :_)
19:03:12 <wagle> does it has strings?
19:03:19 <wagle> (have)
19:03:27 <Darius> Worst case scenario, I believe Delphi is somewhat alive.
19:03:33 <wagle> (char arrays are not strings)
19:03:40 <Pseudonym> Ada and Modula-3 are very much alive.
19:03:49 <Pseudonym> Ada especially.
19:04:04 <wagle> ada took this long to get a compiler?  8)
19:05:48 <wagle> sorry, i believe i'm actually agreeing with you, despite being too busy wallowing in cynicism
19:06:21 <Pseudonym> Pascal (well, if it had strings!) has the advantage of not being too complex, but still being first-year useful.
19:07:06 <skew> Pseudonym: I still thing your objection is mixing semantic levels a bit, like "Hey, 'd' is used for too many different things in Haskell. "define" and "fold" are totally semantically different, and "find" and "fold" do different things but have the same letters"
19:07:07 <wagle> i saw some variants of pascal with strings in the late 1980's, then stopped seeing pascal altogether since then
19:07:48 <skew> So I don't understand what you are staying about semantics. I agree that the readability is not so good
19:08:17 <wagle> skew: (lambda _ _) is an expression.. (x) is a formals
19:08:31 <wagle> (as far as i can tell)
19:08:31 <Pseudonym> Right.
19:08:34 <Pseudonym> Like skew says.
19:09:03 <Pseudonym> skew: Overloading is one thing.  Not having the option _not_ to overload is something completely different.
19:09:12 <wagle> parens in haskell have different meanings in different contexts
19:09:25 <skew> The semantic problem I see is that meaningful parts of e.g. a let expression are only identified as "first subtree", or "first children of the children of the first subtree"
19:09:28 <Pseudonym> wagle: Not really.
19:09:37 <wagle> (1 + 2)
19:09:43 <wagle> ((1 + 2))
19:09:49 <wagle> (1, 2)
19:09:52 <skew> deriving (Eq,Ord)
19:09:53 <wagle> ((1, 2))
19:10:05 <Pseudonym> OK, you're right about tuples.
19:10:11 <Pseudonym> But that's the one exception.
19:10:24 <Pseudonym> Oh, and n+k patterns, but I don't like them anyway.
19:10:35 <wagle> dont see that as much different than (x)
19:11:09 <Pseudonym> I guess you can see (1,2) as being a grouping for the (,) operator.
19:11:33 <Pseudonym> Haskell is also a bit weird because of lazy evaluation.
19:12:00 <Pseudonym> The type (a,(b,c)) is not the same as ((a,b),c) because tuple products are lifted.
19:12:16 <wagle> i see the s-expression for (lambda _ _) as being parsed by a <expr> production, and the sexpression for (x) as being parsed by a <formals> prodution
19:12:18 <skew> I'm struggling to invent a semantic distinction without you explaining yours, Pseudonym, but maybe part of the problem is that some parentheses surround expressions and some are just used to package up arguments to macros
19:12:51 <skew> so, (let [[a (+ 1 2)] [b 10]] (+ a b)), for example
19:13:44 <Pseudonym> skew: I thought wagle already explained it...?
19:13:51 <Pseudonym> Like you say.
19:14:00 <skew> Well, what is a "formals"?
19:14:03 <Pseudonym> The let example is precisely the sort of thing.
19:14:14 <Pseudonym> (a b c) is not always an invocation of "a".
19:14:21 <Pseudonym> It depends where it sits.
19:14:22 * wagle has no clue as to how clear he's being
19:14:35 <Pseudonym> wagle; Well I understood you. :-)
19:14:55 <skew> but you already know what you are talking about!
19:15:19 <skew> I think it was Darius who said you can't just invent new syntax for each semantic role
19:15:27 <wagle> formals is a pattern representing how to name the (pieces of) the arglist
19:15:50 <skew> so if you mean "formals" as in "the formal parameters to a lambda", then you can't really give that special syntax without running out
19:16:15 <skew> because what do you do with "the base classes for the new class I'm defining"?
19:17:07 <wagle> skew: example?  (i'm not understanding)
19:17:14 <skew> If "formals" means some generic concept that can describe bits of the internals of any synatx-like macro, then it probably does deserve special syntax
19:17:23 <Pseudonym> Yeah, I'm not sure where classes came in.
19:17:48 <skew> Oh, I'm thinking of a macro "class" for some kinds of ad-hoc object system
19:18:26 <skew> like ("class" name (base classes go here) ("method" (formal parameters) body) ...)
19:18:41 <wagle> well ((lambda x x) 1 2) == '(1 2)
19:18:56 <wagle> well ((lambda (x y) y) 1 2) == '2
19:19:09 <wagle> well ((lambda (x . y) y) 1 2) == '(2)
19:19:18 <skew> Say "formals" means "formal parameters to lambda/define/method-like macros", and we decide to use [] for that
19:19:29 <skew> so, ((lambda [x] x) 1)
19:19:38 <wagle> i think there is a new "rest of the arguments" syntax these days, but i havent paid attention
19:19:58 <skew> now, parens are still being overloaded for surrounding a single clause in a let, and grouping all the definitions of a let
19:20:12 <skew> so, (let {<x 10> <y 12>} (+ x y))
19:20:48 <wagle> skew: "(" is still identical to "[" (except that ] has to match [, and ) has to match ( ?
19:21:09 <wagle> ooo..  < is a paren now?
19:21:11 <skew> yes to needing to match each other
19:21:22 <skew> I don't know about the internals
19:21:43 <skew> presumably  "let" specifies that the first argument needs to be grouped with {}, etc.
19:21:58 <wagle> (equal '(lambda (x) x) '(lambda [x] x))
19:22:03 <skew> But now what symbol do I use to surround the superclass list for my class macro?
19:22:13 <skew> wagle: that depends
19:22:31 <skew> It does little good to add lots of braces if people just randomly use them however they feel like
19:22:42 <skew> now there is a many-many mapping between grouping symbols and semantics
19:23:01 <skew> because any of () [] {} <> could group and expression, a list of formal parameters, a list of let bindings, etc.
19:23:37 <wagle> Petite Chez Scheme Version 6.9c
19:23:45 <skew> My point is that you can't use separate braces for separate semantics if you mean semantics relative to a particular macro
19:23:48 <wagle> > (equal? '(lambda (x) x) '(lambda [x] x))
19:23:49 <wagle> #t
19:23:58 <hefner> I suggest you hack the readtable to make () [] {} <> interchangable, then use them as you feel as appropriate :)
19:24:15 <skew> wagle: sure, I'm not talking about any particular scheme interpreteration
19:24:23 <wagle> style
19:24:24 <Pseudonym> BTW, I'm deliberately not suggesting a solution.
19:24:34 <Pseudonym> Because Lisp, as I say, is on a sweet spot.
19:24:52 <Pseudonym> I prefer my languages to use different syntax for things with different semantics, where practicable.
19:24:53 <CosmicRay> heh, you guys are still going on about lisp
19:25:00 <Pseudonym> Because it enhances readability.
19:25:07 <wagle> i like using []'s, etc..  would possibly interesting to have the style enforced, though]
19:25:24 <skew> I'm just trying to argue that braces can't reflect semantics at the level of the semantics of individual functions or macros
19:25:32 <skew> fold and map don't get a different call syntax, for example
19:25:54 <skew> I'm just about to get to the constructive part of my argument, where I outline a plan to make progress
19:26:06 <wagle> skew: i'm (radically) claiming that there are no parens at all..
19:26:19 <Pseudonym> OK.
19:26:25 <skew> wagle: I agree, but this is about readability
19:26:36 <wagle> skew: ok... go on
19:26:51 <Pseudonym> I disagree that the distinction between fold and map is the same thing.
19:27:05 <Pseudonym> I think the distinction between expressions and tuples was a better argument.
19:27:06 <Pseudonym> But do go on.
19:27:18 <skew> wagle: the meaning of the various stuff you write inside a macro depends on where it falls in the tree structure
19:27:33 <skew> (this is answering wagle's question rather than making progress, btw)
19:28:23 <skew> Anyways, I think there is enough syntax to go around if you identify semantic differences at the right level of the grammar
19:29:16 <skew> eg, "what is the significance of this piece of code in terms of the tree structure of the program and how macros will operate on it", rather than "what is the significance of this piece of code in terms of being at this position iside the "let" macro"
19:30:46 <wagle> macro expansion happens to s-expressions that are about to be parsed into programs
19:31:47 <skew> I think the semantic levels are something like tokenizing(uninetersting) -> s-expressions -> macros -> execution(uninteresting)
19:31:53 <wagle> if the s-expression is a pair whose car is a symbol that is the name of a macro, then that s-expression is not parsed, it is passed to the macro
19:32:33 <skew> wagle: I think we all know how that works, but I don't see why you are explaining it now. Please, explain
19:32:44 <wagle> the results are then still an s-expression that may be still a macro invocation
19:33:13 <skew> Hmm
19:33:28 <skew> I don't think that's particularly relevant to what I'm talking about
19:33:44 <skew> I'm looking at this from the programmer's point of view
19:34:13 <wagle> hygienic macros imagine that they can do a partial deep parse of the s-expression (giving up at (quote _), to imagine that the symbols encountered in this fashion are (statically scoped) identifiers
19:34:14 <skew> Writing some code, I see lexical syntax, I see an S-expression structure, I see macro applications, and I see execution
19:34:50 <skew> How a particular macro like let is possibly implemented in terms of other macros seems unrelated to the readability of the code
19:35:09 <wagle> i'm saying that macro applications are part of the parsing (s-expressions to program-expressions) algorithm
19:35:36 <skew> S-expressions are already perfectly well suited to compiler parsing, just not for Pseudonym parsing
19:36:16 <Pseudonym> Right.
19:36:21 <Pseudonym> And I'm more important.
19:36:35 <skew> Personally, I don't really case if case is one huge macro that does all the transformation itself, or if it uses SK combinators at the macro level to do it's work. It looks the same from where I'm sitting
19:36:37 <Pseudonym> Hell, you can write a compiler to parse C++.
19:36:58 <wagle> my scheme compilers received fully macro-expanded s-expressions parsed into program-expressions
19:37:09 <Pseudonym> If you can parse Perl and C++ automatically, you can parse anything automatically.
19:37:20 <skew> wagle: I really hope your Scheme programmers do not
19:37:25 <Pseudonym> It's my eyeballs which I'm concerned about.
19:37:50 <wagle> my scheme programmers are programs
19:38:04 <skew> wagle: @quit
19:38:10 <skew> hmm, maybe not all of them :)
19:38:10 <wagle> (which is the real source of impedance mismatch)
19:38:23 <wagle> @quit?
19:38:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "quit?", try "lambdabot: @listcommands"
19:38:45 <skew> unless you use Haskell programs to write the scheme programs that write programs
19:38:57 <skew> Anyway, I don't really care about Lisp here
19:39:33 <wagle> actually, i want to do with haskell what i could do with scheme (only better)
19:39:33 <skew> I like a macro system that lets you introduce new syntax
19:40:05 <skew> and I would like to resolve issues with the syntax so more languages can get them
19:40:10 <wagle> i wrote (compile-time) interpreters of dsls with macros
19:41:09 <wagle> algebraically very interesting to transform a run-time interpreter to a compile-time interpreter
19:41:39 <skew> Anyway, I propose that some parens represent expressions that the macro does not mangle, though it might recurse into it, and some parens are grouping structure for the macro itself, like in let
19:42:54 <skew> Pseudonym: how far would that go with your syntax problems?
19:43:22 <SamB> okay, I'm getting compile errors in StaticModules.hs
19:43:25 <wagle> the macro expansion system has no right (in general) to imagine that it can parse (even partially) the body of a macro expression
19:43:28 <SamB> ghc -Wall -Werror -cpp -fglasgow-exts -funbox-strict-fields -O2 -fvia-C  -package posix -c StaticModules.hs -o StaticModules.o -ohi StaticModules.hi
19:43:29 <SamB> StaticModules.hs:11: Variable not in scope: `baseModule'
19:43:29 <SamB> StaticModules.hs:12: Variable not in scope: `systemModule'
19:43:29 <SamB> StaticModules.hs:13: Variable not in scope: `dynamicModule'
19:43:39 <skew> wagle: that's not the idea here
19:44:20 <skew> I'm not proposing to restrict the power of macros to do arbitrary transformations
19:44:20 <wagle> skew: ok..  i'm riding my odd hobby horse, and hoping for some progress in fixing it
19:44:21 <Pseudonym> skew: Maybe.
19:44:38 <Pseudonym> Not being an experienced Scheme programmer, I can't really say.
19:44:56 <wagle> so-called hygiene is part of a solution, but not all of it.  i want to know what all of the solution is
19:45:08 <skew> I guess I'm suggesting distinct types of nodes in the tree, which the macros can process as they like, and some conventions on what they mean
19:45:34 <SamB> dons: what should I do about this?
19:45:58 <skew> so a () node in the s-expression tree is distinct from a [] node, and them macros make distinctions
19:46:06 * SamB mentions lambdabot in hopes that someone will be paged
19:46:31 <dons> you broke something?
19:46:39 <skew> Separately, I think some kind of layout rule might help prune down the parentheses
19:46:40 <SamB> dons: I don't think so
19:46:59 <dons> hmm. StaticModules.hs is obsolete, btw
19:47:05 <dons> why is it still in your tree?
19:47:09 <wagle> what i'm thinking now is that some macros might have a partial parser associated with them that could pick out the identifiers to enforce static scoping on
19:47:15 <SamB> good question
19:47:20 <Darius> skew: You have seen camlp4?
19:47:32 <wagle> s/now/at this instant in time/
19:47:34 <dons> SamB:: maybe pull the latest repo and merge your patch in
19:47:39 <skew> Darius: not really
19:47:45 <skew> you provide a parser for your construct?
19:47:48 <dons> (StaticModules is subsumed by Modules.hs)
19:47:54 <SamB> lambdabot: @version
19:47:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p220, GHC 6.4 (OpenBSD i386)
19:47:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:48:15 <dons> maybe 2p333 will be a good time to release lambdabot3.
19:48:23 <dons> @seen TheHunter
19:48:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen TheHunter
19:48:26 <Darius> skew: It has a general syntax to provide hooks into the parser which you can then transform into O'Caml AST.
19:48:44 <wagle> skew: i am wanting to hear your story, i'm just over-enthusiastic about hoping you'll help my progress on mine
19:50:17 * dons disappears for an hour or so
19:50:49 <wagle> skew: macros see []'s?
19:50:50 <skew> Darius: do they have some way of avoiding grammatical conflicts?
19:50:57 <skew> wagle: that's my idea
19:52:26 <skew> Darius: I know whenever I try to write a grammar I get all kinds of reduce conflicts. I don't expect it would be any easier to extend a grammar
19:52:36 <skew> maybe if you used all new keywords
19:52:39 <wagle> [x y z] ==> (rail-quote x y z) ?
19:52:44 <skew> wagle: so, what is your problem?
19:52:46 <skew> wagle: sure
19:53:03 <skew> where can I find this 3-Lisp?
19:53:20 <Pseudonym> Lunch.
19:54:17 <Darius> skew: The syntax to introduce a new construct is unambiguous, however inside it the parser can be whatever written in a Yacc like language.  I haven't really dealt with camlp4 or OCaml in general, so I'm not too sure of all the specifics.
19:54:50 <Darius> skew: But of course, you technically aren't worse off than you are in Lisp as you can simply use an S-expression syntax inside.
19:55:03 * CosmicRay has worked with camlp4 and perks up
19:55:07 <wagle> skew: http://library.readscheme.org/servlets/search.ss?pattern=Smith+Brian+Cantwell
19:55:17 <Darius> CosmicRay: Then answer skew's question.
19:55:39 <CosmicRay> about grammatical conflicts?
19:55:43 <wagle> seems to list them, though perhaps not in ideal form.//  might google harder for pdf's, etc
19:55:52 <skew> I'm wondering if there is any trouble in practice
19:55:53 <Darius> CosmicRay: Well about camlp4 in general.
19:56:02 <SamB> lambdabot_SamB: @google lambdabot
19:56:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:56:04 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- couldn't find a "Location:" header: maybe there were no results?
19:56:04 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- http status line was:"Location: http://cvs.sf.net/viewcvs.py/haskell-libs/
19:56:04 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- libs/lambdabot/\r"
19:56:06 <skew> something more involved like a case might be tricky
19:56:23 <SamB> okay, I did something wrong ;-)
19:57:02 <CosmicRay> Darius: I'm not sure what specific question you're referring to in my scrollback...  however I can say that the only thing to me that camlp4 does, that Language.Haskell.* doesn't, is make it easier to extend the existing parser for the language
19:57:05 <wagle> skew: my problem is that i want to write macros that construct programs
19:57:26 <SamB> lambdabot_SamB: @google lambdabot
19:57:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
19:57:27 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/
19:57:28 <CosmicRay> if you are transforming an entirely different language into an OCaml or Haskell AST, I don't think camlp4 will really have advantages over coding up a solution with Language.Haskell
19:57:28 <skew> wagle: what's the problem there?
19:57:41 <SamB> @wikipedia lambdabot
19:57:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "wikipedia", try "lambdabot: @listcommands"
19:57:45 <skew> CosmicRay: I am thinking in terms of being able to add new synatx
19:57:46 <wagle> hygienic macros prevent you from constructing scopes
19:57:56 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- couldn't find a "Location:" header: maybe there were no results?
19:57:56 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- http status line was:"HTTP/1.0 200 OK\r"
19:57:57 <CosmicRay> skew: camlp4 has a definite advantage there
19:58:16 <CosmicRay> skew: afaict, Language.Haskell.Parser is not extensible at all.  if you want to extend the language, you have to re-start from scratch
19:58:19 <skew> CosmicRay: say Haskell didn't have case, just pattern matching on clauses of functions
19:58:20 <wagle> s/macros/macro expansion/
19:58:44 <skew> or the other way around
19:59:00 <CosmicRay> skew: right, I understand...  and you would want to implement a parser, that would transform these constructs in terms of existing constructs in the AST
19:59:14 <CosmicRay> that's exactly the sort of thing that camlp4 makes easy
19:59:15 <skew> would it be feasible to do that sort of thing with camlp4?
19:59:19 <CosmicRay> yes
19:59:46 <wagle> skew: did you get to finish your story?
19:59:53 <skew> wagle: yes
19:59:58 <CosmicRay> skew: http://pauillac.inria.fr/caml/camlp4/
20:00:04 <CosmicRay> skew: the reference and tutorial there may prove interesting.
20:01:28 <CosmicRay> skew: here's a more specific reference http://pauillac.inria.fr/caml/camlp4/tutorial/tutorial007.html
20:04:50 <wagle> why are people talking about camlp4?
20:05:01 <wagle> (ie, what did i miss?)
20:05:15 <skew> wagle: to recap, if you want to use different sorts of grouping symbols to make the syntax more readable, they need to have meaning at the s-expression/definition of macroexpansion level
20:06:24 <skew> wagle: I am interested in lisp macros because they can be used to effectively extend the language that fits nicely with the old syntax
20:06:56 <skew> ... extend the language with *new syntax* that fits nicely ...
20:07:03 <Lemmih> Woot. I finally got around to make a decent HSQL cabalization.
20:07:43 <wagle> slight nitpick with a point of trivia: (lambda (or x y) x) isnt going to macro expand the formals (or x y)..  but (the trivia) at some points in time, there have been macros for expanding things other than expressions (ie, symbols, formals (?), etc)
20:08:07 <wagle> i dunno what the current state of scheme macros in this regard is
20:09:13 <wagle> hmm..  maybe scheme macros work because the syntax is so simple.
20:10:12 <skew> wagle: I don't see how that is a problem
20:10:25 <wagle> didnt say that last was a problem..
20:10:48 <skew> skew: anyway, camlp4 fits in because it seems to let you extend the syntax of OCaml pretty nicely
20:11:11 <SamB> @google lambdabot
20:11:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/
20:11:13 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/
20:11:24 <SamB> @wikipedia lambdabot
20:11:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "wikipedia", try "lambdabot: @listcommands"
20:11:29 <wagle> @plugs 1 + 1
20:11:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2
20:11:32 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- search: No result found
20:11:32 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- lambdabot: forkProcess: uncaught exception
20:11:48 <wagle> o_O
20:11:56 <wagle> @plugs 1 + 1
20:11:57 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- lambdabot: forkProcess: uncaught exception
20:11:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2
20:12:04 <wagle> ah
20:13:35 <wagle> skew: does modern scheme have macros for other production-contexts thasn "expression"?
20:14:28 <skew> The uniform syntax makes it easy to do macros, and a similar facility in a language like Haskell would require building s-expressions under the current syntax (deriving tree structure from layout, cleaning up some constructs, etc)
20:14:50 <skew> wagle: I think macros expand everywhere
20:15:20 <skew> except maybe with some primitives, like the formals to lambda, or the argument to quote
20:15:26 <wagle> ((lambda (or x y) (+ or x y)) 1 2 3) == 6
20:16:05 <wagle> (notice that "or" appears in two contexts)
20:16:31 <skew> wagle: do those contexts have any standing at the level of macro-expansion?
20:16:41 <skew> lambda might do something special, I suppose
20:16:49 <wagle> there have been symbol macros in the past
20:17:48 <SamB> @plugs 1+1
20:17:49 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- Sorry, I don't know the command "plugs", try "lambdabot_SamB: @listcommands"
20:17:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2
20:17:53 <wagle> at best, my scheme head is no newer than 1995)
20:18:10 <SamB> @wikipedia haskell
20:18:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "wikipedia", try "lambdabot: @listcommands"
20:18:12 -lambdabot_SamB(naesten@ts001d0578.wdc-dc.xod.concentric.net)- http://en.wikipedia.org/wiki/Haskell
20:18:39 <wagle> 8-p
20:27:13 <skew> camlp4 looks interesting.
20:27:29 <aheller> skew: I always thought so; has the long lost maintainer returned?
20:28:02 <SamB> @quit
20:28:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
20:33:09 <SamB> why is Depends.hs under darcs?
20:33:58 <SamB> again, I mention lambdabot
20:39:56 <skew> I had thought that extending a syntax like Haskell or OCaml by writing parsers would not work out very well, but camlp4 seems to do it
20:40:41 <SamB> skew: doesn't the plugins (whatever the name is) branch of ghc do that too?
20:40:56 <skew> I haven't heard about htat
20:50:23 * SamB gets an "impossible case" in darcs, so he trys apt-getting a new one
20:56:15 <Lemmih> SyntaxNinja: Hey again.
20:56:25 <Lemmih> SyntaxNinja: Did you get my mail?
20:57:24 <SyntaxNinja>  hi
20:57:24 <SyntaxNinja> yep
20:57:28 <SyntaxNinja> thanks :)
21:05:25 <Gahhh> whoa. the C++ standard dwarfes the scheme standard...
21:06:32 <dons> SamB: Depends.hs is under darcs as it isn't generated automagically always yet.
21:06:41 <SamB> Gahhh: well no kidding!
21:06:46 <SamB> most things do, really
21:06:48 <dons> there's a chicken-egg problem i'm solving.
21:06:56 <SamB> dons: oh.
21:07:08 <dons> 'can't build Depends.hs until lambdabot is built/ can't build lambdabot until Depends.hs is built'
21:07:14 <dons> soln: use a data file.
21:13:05 <Lemmih> shapr: Awake?
21:14:23 <dons> SamB, I think we want lambdabot to be as quiet as possible, so maybe "got absolutely no lines of HTTP response, something wierd is up." to "Hmm. Something weird is up" or so.
21:14:38 <SamB> sure.
21:14:46 <dons> people always think they've hacked the bot when it prints internal msgs ;)
21:14:57 <SamB> hah
21:15:17 <dons> yeah. good patch. thanks.
21:15:28 <SyntaxNinja> Gahhh: are you really surprised by that?
21:15:30 <dons> @karma+ SamB
21:15:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SamB's karma has been incremented
21:15:57 <SamB> Recording that patch seems to have taken out my working dir, too...
21:16:11 <dons> SamB, you want (c) 2005 Sam B ?
21:16:30 <dons> I'd like to get some kind of tracking of authors in the src. It's useful.
21:16:43 <SamB> dons: that would be Samuel Bronson, fine
21:16:46 <dons> yep.
21:16:52 <wagle> Gahhh: scheme is simple
21:18:17 <dons> hmm. not sure about these error :: String -> a calls.
21:19:10 <dons> no, it's ok.
21:27:32 <Gahhh> This looks weird:
21:27:33 <Gahhh> http://shootout.alioth.debian.org/benchmark.php?test=takfp&lang=all&sort=fullcpu
21:28:21 <Gahhh> Java uses 9.5Mb and beats Intel C ?
21:28:27 <dons> hmm..
21:29:13 <SyntaxNinja> the python implementation must suck
21:29:37 <SyntaxNinja> Haskell tied for shortest, of course :)
21:30:30 <Gahhh> Haskell's doing phenomenal at half the speed of C imho
21:32:20 <wagle> maybe java unrolled the recursion..
21:33:09 <dons> hmm. I wonder if that Haskell could be cranked up a bit.
21:33:52 <Gahhh> that is a lot of recursive calls. 2 secs for C.
21:34:10 <wagle> /usr/bin/ghc -O3 -fexcess-precision takfp.hs -o takfp.ghc_run
21:34:26 <Gahhh> what does -fexcess-prec do ?
21:34:31 <wagle> i dunno
21:35:01 <dons> keeps -fasm floats save, iirc
21:35:11 <dons> not sure why it is needed with -O3 (-fvia-C implicitly)
21:35:17 <SamB> Gahhh: presumably allows ghc to keep floating point values in registers on x86
21:35:31 <Gahhh> yes it looks like it
21:36:00 <SamB> the x86 having higher precision floating point registers than doubles
21:36:02 <Gahhh> it is faster and more accurate than standard
21:36:05 <wagle> http://shootout.alioth.debian.org/benchmark.php?test=takfp&lang=ghc&id=0&sort=fullcpu
21:36:08 <dons> "intermediate floating point values can have a greater precision/range than the final type."
21:38:21 <SamB> so is the haskell code overly lazy?
21:39:20 <Gahhh> is dynamic programming possible ?
21:39:35 <SamB> its supposed to be the naive algorithm
21:39:44 <wagle> the java is doing something wild to use all that memory
21:40:02 <SamB> wagle: java always uses a lot of memory
21:40:26 <SamB> also, it is not enough lines to be something wild, is it?
21:40:30 <wagle> yeah, i was starting to notice that (gcj, etc)
21:40:55 <SamB> you can't do much in 7 lines of Java, really
21:40:57 <wagle> unrolling, dynamic programming, jit, ...
21:41:20 <SamB>   public static float Tak (float x, float y, float z) {
21:41:20 <SamB>     if (y >= x) return z;
21:41:20 <SamB>     else return Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y));
21:41:20 <SamB>   }
21:41:28 <wagle> i can imagine a optimizer going nutz on 7 lines that it knows how to handle
21:42:04 <SamB> wagle: why would this, in particular, be well optimized? more so than in ICC?
21:42:04 <Gahhh> If something is possible, I'd first expect the intel compiler do it before java hotspot.
21:42:16 <dons> unboxing appears to halve the running time of that program.
21:42:28 <wagle> maybe they knew about the benchmark, and made sure to recognize it
21:42:34 <Gahhh> ahah evil
21:42:37 <Gahhh> quack.exe ?
21:42:48 <wagle> i dont mean cheating
21:43:07 <wagle> i mean just doing precisely the best known thing for the pattern
21:43:12 <SamB> is there any way to get GHC to unbox it without explicitly mentioning GHC.*?
21:43:13 <dons> www.cse.unsw.edu.au/~dons/t.hs
21:43:30 <dons> probably. the right ghc flags would most likely do it
21:44:30 <wagle> aww..  tcl DOES have a compiler
21:45:27 <wagle> i never heard of "scheme chicken"..
21:45:36 <wagle> i wonder how chez scheme would have done
21:47:46 <dons> not unboxing, but using -fliberate-case-threshold=100 cut it by 60%
21:47:56 <dons> i.e. just add -fliberate-case-threshold=100
21:49:57 <wagle> oh, bleagh..  chicken scheme compiles to C..  thats no test of scheme vs C
21:50:18 <dons> how does one update the test code to use an extra ghc flag?
21:53:53 <thou> howdy
22:07:32 <mayhem> yop
22:16:12 <dons> @yow
22:16:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
22:16:43 <thou> hehe
22:26:11 <SamB> @fortune
22:26:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- FORTUNE DISCUSSES THE DIFFERENCES BETWEEN MEN AND WOMEN:	#16
22:26:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Relationships:
22:26:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	First of all, a man does not call a relationship a relationship -- he
22:26:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- refers to it as "that time when me and Suzie were doing it on a semi-regular
22:26:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- basis".
22:26:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	When a relationship ends, a woman will cry and pour her heart out to
22:26:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [14 @more lines]
22:26:34 <SamB> @more
22:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- her girlfriends, and she will write a poem titled "All Men Are Idiots".
22:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Then
22:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- she will get on with her life.
22:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	A man has a little more trouble letting go.  Six months after the
22:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- breakup, at 3:00 a.m. on a Saturday night, he will call and say, "I just
22:26:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- wanted to let you know you ruined my life, and I'll never forgive you, and
22:26:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I
22:26:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [7 @more lines]
22:27:08 <SamB> @more
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- hate you, and you're a total floozy.  But I want you to know that there'
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- always a chance for us".  This is known as the "I Hate You / I Love You"
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- drunken phone call, that 99% if all men have made at least once.  There
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- are
22:27:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- community colleges that offer courses to help men get over this need; alas,
22:27:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- these classes rarely prove effective.
22:27:39 <mayhem> lambdabot : what is functor
22:27:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
22:27:51 <mayhem> @listcommands
22:27:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Commands: all-dicts arr babel define definitions del-definition devils dice
22:27:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dict dict-help dummy dynamic-load dynamic-reload dynamic-unload easton echo
22:27:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- elements eurohaskell eval foldoc fortune gazetteer get-definition google
22:27:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- help hitchcock jargon join karma karma+ karma- kind learn leave listchans
22:27:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- listcommands listmodules lojban moo more msg part paste pl pl-resume plugs
22:27:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pointless prelude quit quote reconnect remember resume seen set-fuel state
22:27:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- timein topic-cons topic-init topic-snoc topic-tail topic-tell type vera
22:27:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1 @more lines]
22:28:01 <Gahhh> wow
22:28:07 <mayhem> @more
22:28:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- version web1913 wiki wn world02 yow
22:28:45 <SamB> @listmodules
22:28:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- babel base dice dict dummy dynamic eval google help karma more pl plugs
22:28:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- quote seen state system topic type version
22:29:56 <mayhem> @help functor
22:29:56 <mayhem> @definitions functor
22:29:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  @help <command> - ask for help for <command>
22:29:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- []
22:30:17 <xerox> 'morning!
22:30:22 <xerox> @wikipedia foo bar
22:30:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "wikipedia", try "lambdabot: @listcommands"
22:30:31 <xerox> oh :(
22:30:46 <xerox> Gotta go to school! laters.
22:30:57 <dons> @dynamic-load wikipedia
22:30:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- couldn't load module WikipediaModule.o
22:31:09 <blackdog> @dynamic-load Vixen
22:31:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
22:31:15 <blackdog> aw. :)
22:31:22 <SamB> @dynamic-load search
22:31:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
22:31:29 <sjanssen> @dynamic-load YourMother
22:31:29 <blackdog> hey, are there good examples for doing cgi with haskell?
22:31:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
22:31:35 <dons> no dyn loading. i'm rebuilding the bot :P
22:31:39 <kaol> @pointless
22:31:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 1):
22:31:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected end of input
22:31:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting white space, natural, identifier, lambda abstraction or expression
22:31:40 <blackdog> That's right. You keep your hands off my mother
22:32:05 <sjanssen> blackdog: too late!
22:32:18 <blackdog> ...dad? is that you?
22:33:23 <SamB> dons: how long does it take to rebuild lambdabot?
22:33:35 <sjanssen> @wiki SyntacticSugar/Cons
22:33:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/SyntacticSugar/Cons
22:33:46 <dons> not too long. there's darcs'ing involved too
22:33:48 <sjanssen> does the person who wrote this hang out here?
22:34:02 <blackdog> dons: did you get Vixen.hs yet? I keep thinking i screwed up the submission...
22:34:19 <SamB> I mean, it doesn't take nearly forever even on a slow PII 450 (wich is misreported as a PII 16431.700)
22:34:19 <dons> I got it. Didn't apply properly. Seem my msg
22:34:29 <dons> it takes 20-30 seconds
22:34:39 <dons> let see... started now.
22:35:37 <dons> oh, bit slower if optimisation cranked up
22:36:23 <dons> done.
22:36:30 <dons> 108.42s real   100.10s user     6.49s system
22:36:31 <thou> i've got a bit of a chicken & egg problem; the darcs 1.0.2 release doesn't compile w/ ghc6.4, and I can't find more recent code that isn't in a darcs repository; can anyone help me (e.g., point me to a more recent snapshot that will compile w/ ghc 6.4)?
22:36:56 <SamB> thou: how did you try to compile it?
22:36:58 * thou is on FreeBSD, can't seem to find a darcs executable either
22:37:06 <thou> from FreeBSD ports tree
22:37:09 <SamB> oh, you said darcs.
22:37:21 <dons> @help wikipedia
22:37:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @wikipedia <expr>, search wikipedia and show url of first hit
22:37:24 <dons> @help goole
22:37:24 <SamB> I was thinking "lambdabot from darcs"...
22:37:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  @help <command> - ask for help for <command>
22:37:26 <dons> @help google
22:37:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @google <expr>, search google and show url of first hit
22:37:42 <thou> according to a mailing list posting, it's a known problem and was fixed after darcs 1.0.2
22:37:46 <SyntaxNinja> thou: is there a version that compiles w/ 6.4?
22:37:59 <thou> SyntaxNinja: supposedly the latest code does
22:38:33 <SamB> if they fixed it, someone with an up-to-date copy of the darcs repo for darcs can just tarball it and send it to thou...
22:38:35 <thou> http://www.abridgegame.org/pipermail/darcs-users/2005-March/006301.html
22:38:57 <mayhem> anyone working in TAL team ?
22:39:20 <mayhem> smerdyakov does if I remember well
22:39:22 <Gahhh> TAL = ?
22:39:28 <mayhem> typed assembly language
22:39:32 <SamB> they really ought to provide an interim tarball of the repo...
22:39:52 <mayhem> Gahhh its not directly haskell related
22:40:45 <thou> SamB: i may use wget on the web interface.  hehehe
22:40:46 <SyntaxNinja> thou: if you can't find one at the darcs web site, I'll make you a tarball of the latest source, or whatever tag you might like. just paste me the darcs command you want (I'm lazy) :)
22:40:47 <Gahhh> was it stepcut ? I don't remember who was doing the assembly stuff.
22:41:06 <SamB> thou: you don't need to use it on the web interface, actually...
22:41:15 <SamB> you can just use it on the repo URL
22:42:55 <dons> @wikipedia foobar
22:42:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://en.wikipedia.org/wiki/Foobar
22:43:03 <dons> huh
22:43:07 <dons> @wikipedia baafdjkle
22:43:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No result found.
22:43:15 <dons> nice.
22:44:06 <thou> @darcs get http://www.abridgegame.org/repos/darcs/
22:44:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "darcs", try "lambdabot: @listcommands"
22:44:14 <thou> just kidding
22:44:36 <SamB> @plugs System.system "darcs get http://www.abridgegame.org/repos/darcs/"
22:44:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `System.system'
22:44:58 <thou> whew, i'm glad that didn't work
22:45:00 <SyntaxNinja> ahh, lambdabot jokes
22:45:13 <SamB> what is the meaning of this error message, anyway? why is it "not in scope"?
22:45:39 <SamB> as opposed to, say, "module System could not be found" or something like that
22:45:52 <Gahhh> there was no import statement
22:46:04 <glimming> I am trying to compile GHC 6.4 for Stockholm University and I get
22:46:05 <glimming> Undefined                       first referenced
22:46:05 <glimming>  symbol                             in file
22:46:05 <glimming> DistributionziParseUtils_zdLr5WElvl7_closure ../../lib/compat/libghccompat.a(ParseUtils__106.o)
22:46:08 <glimming> DistributionziParseUtils_zdLr5Wulvl2_closure ../../lib/compat/libghccompat.a(ParseUtils__89.o)
22:46:11 <glimming> DistributionziCompatziReadP_polyzuzgzg_closure ../../lib/compat/libghccompat.a(ReadP__36.o)
22:46:14 <glimming> DistributionziParseUtils_StanzzaField_con_info ../../lib/compat/libghccompat.a(InstalledPackageInfo__210.o)
22:46:17 <glimming> DistributionziInstalledPackageInfo_zdLrrPZZa39_closure ../../lib/compat/libghccompat.a(InstalledPackageInfo__224.o)
22:46:21 <SamB> glimming: why are you trying to compile it?
22:46:21 <glimming> this is from Solaris...
22:46:22 <dons> yikes.
22:46:24 <SyntaxNinja> glimming: -package cabal
22:46:31 <SamB> you aren't supposed to compile it unless you are crazy
22:46:36 <SyntaxNinja> oh hm
22:46:44 <glimming> This is Solaris.
22:46:55 <SyntaxNinja> thou: do you want a tarball?
22:47:01 <glimming> SyntaxNinja, what package?
22:47:14 <SyntaxNinja> glimming: those symbols are in the cabal package.
22:47:20 <thou> SyntaxNinja: please, you are too kind
22:47:22 <glimming> Aha, can I remove that package?
22:47:24 <SyntaxNinja> do you have cabal installed elsewhere or something?
22:47:30 <SyntaxNinja> glimming: they come w/ ghc 6.4
22:47:36 <glimming> I do not know what cabal is...
22:47:36 <SyntaxNinja> I don't know why you'd be getting that error, though.
22:47:50 <glimming> I just extracted the ghc distro .src file
22:48:10 <SyntaxNinja> thou: do you want the latest?
22:48:32 <thou> SyntaxNinja: yes, i'll just hope it compiles and works OK  :)
22:49:14 <SyntaxNinja> glimming: is there no binary available for your platform?
22:49:24 <glimming> SyntaxNinja, no, solaris does not seem to be listed
22:49:29 <thou> SyntaxNinja: the command I joked with above should be what I want, I think
22:49:46 <glimming> can I not disable cabal?
22:50:06 <Gahhh> glimming: How are you building it, then ? bootstrap via C ?
22:50:12 <SamB> glimming: 6.4 is apparantly quite attached to it.
22:50:25 <glimming> I just typed make.
22:50:32 <glimming> There may be some dependencies such as the right C compiler etc.
22:50:46 <glimming> I have to insert "modules" in this UNIX environments with  proper versions of software
22:50:49 <Gahhh> glimming: you need ghc to build ghc. How did confiugure find one ?
22:50:53 <SyntaxNinja> ghc and cabal are like a horse and carriage ;)
22:51:19 <glimming> I am using gcc 3.3
22:51:27 <SamB> you do know that GHC is written in Glasgow Haskell, right?
22:51:36 <glimming> I have ghc 6,2,2 already installed in this system
22:51:40 <Gahhh> aha
22:51:48 <thou> hmmm
22:51:48 <SyntaxNinja> @impromptuLessonOnBootStrappingCompilers
22:51:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "impromptuLessonOnBootStrappingCompilers"
22:51:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- , try "lambdabot: @listcommands"
22:52:21 <Gahhh> Yeah there is a 6.2.2 binary for Solaris.
22:52:23 <SyntaxNinja> glimming: are you reading the building instructions on the web? :)
22:52:24 <SamB> what was the point of this?
22:52:45 <glimming> No just the README, simple enough: configure, then make
22:52:55 <Gahhh> it should work.
22:53:19 <Gahhh> maybe nobody tried a solaris build before.
22:53:19 <thou> glimming: you might try explicitly setting CC, LD and AS before running configure
22:53:41 <thou> e.g., try using gcc for everything, or ... I don't know
22:54:12 <Gahhh> it could be a name mangling problem
22:54:36 <Gahhh> uh
22:54:39 <Gahhh> what am I saying.
22:54:41 <SamB> seriously, doesn't he just need Cabal?
22:55:00 <Gahhh> no, it's with 6.4 and ghc 6.2.2 should build it all.
23:00:51 <SyntaxNinja> thou: http://www.syntaxpolice.org/tmp/darcs-snapshot-thou.tgz
23:01:00 <thou> gracias!
23:01:53 <SyntaxNinja> no problem
23:02:20 <SyntaxNinja> SyntaxNinja: causing and solving bootstrapping problems since 2003
23:06:40 <thou> SyntaxNinja: i've got it, thanks - you can remove it if you like
23:07:16 <musasabi> dons: saw the dice problem, will send a fix today.
23:07:26 <desrt> @love
23:07:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Unknown command.
23:07:32 <desrt> :(
23:07:46 <kaol> @yow
23:07:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I want EARS!  I want two ROUND BLACK EARS to make me feel warm 'n
23:07:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- secure!!
23:07:48 <musasabi> @version
23:07:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p246, GHC 6.4 (OpenBSD i386)
23:07:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:08:09 <dons> musasabi, thanks.
23:08:11 <kaol> strangely appopriate
23:08:54 <thou> ./configure --help
23:09:10 <dons> ./configure: no such file or directory
23:09:32 <thou> stupid window manager doesn't know where I'm looking
23:09:32 <SamB> ./configure: filesystem not found
23:10:07 <glimming> configure: WARNING: no OpenAL library found, so this package will not be built
23:10:15 <thou> that's no big deal
23:10:35 <glimming> I set CC and LD but got precisely the same problem after completing ./configure;make
23:10:41 <Gahhh> SyntaxNinja: Is Galois public ?
23:10:48 <glimming> ld: fatal: Symbol referencing errors. No output written to ghc-pkg.bin
23:10:48 <thou> glimming: :-(
23:11:32 <SyntaxNinja> thou: done. thanks.
23:11:49 <SyntaxNinja> Gahhh: publicly traded you mean?
23:12:15 <Gahhh> Yah
23:13:35 <KrispyKringle> Pseudonym: is that you by the same name on fark?
23:13:49 <KrispyKringle> if so, props on the Stones lyrics.
23:14:05 <SyntaxNinja> Gahhh: nope
23:14:48 <Gahhh> SyntaxNinja: job search on monster.com with keyword=haskell in Bay Area = 0 Hits heh.
23:15:49 <SyntaxNinja> portland is better anyway :)
23:15:59 <SyntaxNinja> how many hits in all of the US?
23:16:56 <SyntaxNinja> Gahhh: here's my former employer: http://www.aetion.com/jobs.html
23:17:09 <blackdog> is there a list of the packages you can get with Cabal?
23:17:13 <SyntaxNinja> but you may find the transition to columbus, OH from the bay area to be... a little disappointing
23:17:15 <SyntaxNinja> blackdog: not yet
23:17:18 <SyntaxNinja> blackdog: soon!
23:17:19 <Gahhh> sad
23:17:22 <SyntaxNinja> (thanks to Lemmih)
23:17:25 <Gahhh> SyntaxNinja: just this one : http://jobsearch.monster.com/getjob.asp?JobID=25310388&AVSDM=2005%2D04%2D08+16%3A05%3A16&Logo=1&q=haskell+ocaml&sort=rv&vw=b&cy=US&brd=1,1862,1863
23:17:33 * SyntaxNinja saw the computer that hackage will live on today :)
23:17:34 <Gahhh> included ocaml as well
23:17:50 <Gahhh> lol
23:17:57 <Gahhh> Check this one out: http://jobsearch.monster.com/getjob.asp?JobID=28993893&AVSDM=2005%2D04%2D11+11%3A41%3A48&Logo=1&q=haskell+ocaml&sort=rv&vw=b&cy=US&brd=1,1862,1863
23:18:06 <Gahhh> (obscure languages, e.g. haskell)
23:18:10 <blackdog> So WASH wouldn't happen to be there... oh well.
23:18:51 <SyntaxNinja> blackdog: hm. I cabalized wash a long time back, but I think wash-n-go was released since then
23:19:23 <musasabi> dons: a wrapper which would catch exceptions and print them could be nice for many modules (just add a throwIrcError :: String -> a)
23:20:28 <Gahhh> Lol, would you like to live here ? http://maps.yahoo.com/maps_result?ed=M7tNO.p_0TqT&csz=haskell%2C+ar&country=us&new=1&name=&qty=
23:21:07 <SyntaxNinja> Gahhh: I think monster stucks, btw
23:21:14 <SyntaxNinja> s/stucks/sucks
23:21:32 <SyntaxNinja> "Haskell City! Closer to roads than you think!"
23:21:35 <Gahhh> SyntaxNinja: Yes way too few hits.
23:23:16 <Gahhh> Well, there are 2 more hits from hotjobs.
23:24:11 <Gahhh> same hit at careers.msn.com
23:26:29 <SyntaxNinja> Gahhh: http://www.haskell.org/jobs.html
23:26:52 <musasabi> dons: Is the exception route sound i.e. would you accept a patch implementing it for all modules in IRC.hs ?
23:28:25 * SamB wonders why demos.su still resolves
23:30:26 <Gahhh> SyntaxNinja: I bet you submitted both Galois and Aetion :)
23:32:35 <SyntaxNinja> Gahhh: nah, neither
23:32:42 <SyntaxNinja> I used to help aetion interview, though
23:32:54 <gzl> Galois has such a good name.
23:33:03 * SyntaxNinja nods
23:33:13 <Gahhh> It's a french mathematician who died in a duel. Hardcore.
23:33:31 <gzl> a damn good mathematician, no less.
23:34:00 <gzl> galois theory is neat.
23:36:21 <thou> SyntaxNinja: BTW, thanks:  darcs get http://www.scannedinavian.org/repos/lambdabot  ...... Finished getting.
23:45:04 <SyntaxNinja> cool
23:50:18 <Gahhh> heh
