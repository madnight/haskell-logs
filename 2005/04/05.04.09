01:03:22 <vincenz> tomaeto
01:03:42 <shapr> pulp under my iron-soled boots!
01:03:59 <Lemmih> Morning, shapr.
01:04:38 <Lemmih> Hacking something nifty?
01:05:01 * shapr thinks
01:05:24 <shapr> Yeah, I want to add value testing to QuickCheck
01:10:27 * Lemmih is pretty close at a working cabal-get.
01:10:33 <shapr> neat!
01:13:07 <Itkovian> @seen boegel
01:13:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen boegel
01:15:41 <vincenz> cabal-get?
01:17:54 <Lemmih> vincenz: Heard of apt-get?
01:20:51 <vincenz> yes
01:22:00 <Lemmih> cabal-get downloads and installs cabal packages from Hackage servers.
01:23:18 <autrijus> @pointless \idx -> store av idx VUndef
01:23:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip (store av) VUndef
01:23:28 <autrijus> not clearer at all.
01:23:47 <sond> hi
01:23:52 <Lemmih> Hey sond.
01:24:23 <sond> if anyone wants to try a pre-alpha windows version of our editor, -> http://haste.dyndns.org:8080
01:25:22 <Lemmih> Woot!
01:26:00 <Lemmih> There are few things in life that can make me reboot, this is definitely one of them.
01:26:58 <autrijus> oh wow. wow.
01:27:06 <autrijus> sond++
01:28:30 <sond> heh :)
01:28:35 <sond> don't gett too excited
01:29:13 <autrijus> can't help.
01:29:15 * autrijus is excited
01:29:23 <shapr> That site got really slow suddenly. How many people are downloading?
01:29:50 <sond> dunno..
01:30:52 <sond> the app is hosted on sourceforge though
01:31:31 <autrijus> I'm downloading from the .tw mirror
01:31:36 <autrijus> so not likely to be affecting you
01:31:47 <shapr> I don't have a copy of windows :-(
01:33:23 <autrijus> @pointless \(idx, val) -> store av idx val
01:33:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- uncurry (store av)
01:33:30 <autrijus> that's good.
01:33:47 <Lemmih> Yo.
01:33:54 * shapr y0dels
01:34:00 <sond> hey
01:34:30 <Lemmih> "Can't find MSVCR71.dll" /-:
01:34:37 <sond> oops
01:34:55 <sond> that is the visual studio c runtime
01:36:28 <Lemmih> Is Haste supposed to depend on that?
01:37:04 <sond> well this particular windows version is built against wxHaskell compiled with visual studio
01:37:11 <sond> but we can just supply that dll in the installer
01:37:51 <sond> if you search for it on google you can probably get it too
01:38:56 <Lemmih> Ah yes.
01:40:00 <Lemmih> Hurrah. It's working.
01:47:06 * Lemmih ponders how to get auto-completion working.
01:50:19 <vincenz> <tab>
01:50:32 <Lemmih> vincenz: In Haste (:
01:52:25 <sond> ctrl-space
01:52:35 <sond> it sometimes don't work
01:53:33 <Lemmih> Ah, waiting a little helped.
01:53:46 <sond> okey, hmm
01:54:00 <sond> ctrl-d for a description of an identifier
01:54:06 <sond> ctrl-g for go to definition
01:54:29 <Lemmih> That's still failing.
01:54:36 <pesco> Morning
01:54:46 <sond> you need to have type signatures on your functions for it to work
01:54:54 <sond> and you might need to refresh the "source cache"
01:55:00 <sond> you can do that in the project browsr
01:55:39 <Lemmih> Yay (:
01:56:07 <Lemmih> Is it normal that it uses 100% CPU?
01:56:15 <sond> yes
01:56:17 <sond> ;D
01:56:33 <sond> that's a bug
01:56:42 <pesco> AFRP?
01:57:20 <Lemmih> pesco: Haste. Neat Haskell IDE.
01:57:38 <pesco> Ah, cool. Hello sond, you're one of the developers?
01:58:00 <pesco> sond: I meant, are you using AFRP which is causing the CPU load?
01:58:18 <sond> what's AFRP?
01:58:25 <sond> yeah, I'm one of the developers
01:58:33 <pesco> Arrowized Functional Reactive Programming, a.k.a. Yampa.
01:58:44 <Lemmih> How does that relate to a IDE?
01:58:53 <pesco> You can make user interfaces with it.
01:58:57 <Lemmih> *an IDE.
01:59:08 <sond> no..
01:59:17 <sond> we are programming imperatively
01:59:20 <sond> :/
01:59:30 <pesco> Ew. ;)
02:00:04 <sond> I don't think there are any AFRP libraries with the widgets that we need (like tree controls for example)
02:00:16 <sond> or am I wrong?
02:00:16 <pesco> That's true.
02:00:40 <pesco> Although you might be able to tack AFRP on top of an existing one.
02:00:43 <pesco> I've not tried that though.
02:00:54 <sond> ok, I found the source of the 100 % cpu bug now. it's just an onIdle-handler
02:01:31 <pesco> But making a good GUI based on the concept of AFRP is on my todowishlist.
02:01:39 <sond> on top of a tree control?
02:01:40 <vegai> I'd like a "for-dummies" sort of tutorial for Yampa. I wonder if anyone has time to do such a thing?
02:01:45 <Lemmih> Aren't Yampe and Fudgets like systems pretty separate?
02:01:52 <pesco> sond: On top of a widget toolkit.
02:02:04 <Lemmih> *Yampa
02:02:10 <sond> pesco, okay, but how would you AFRP-ify a tree control? :)
02:02:30 <sond> say that you want to AFRP-ify a whole widgets library
02:02:57 <pesco> sond: I don't know, I haven't spent any thought on it, but I feel it could be possible. Feel free to investigate! ;)
02:03:01 <shapr> There's Antony Courtney's Fruit thesis that talks about Yampa for GUIs.
02:03:13 <pesco> Hi shapr!
02:03:14 <sond> pesco, hmm ok.
02:03:18 <shapr> hiya pesco
02:03:55 <pesco> sond: No, actually I don't want to AFRPify an existing library. I want to build my own from scratch. I'm dissatisfied with current user interfaces alltogether.
02:04:05 <pesco> The closest thing to "good" that we have is the text terminal.
02:04:59 <sond> hehe, okay :)
02:05:06 <Lemmih> sond: Should I be able to build Haskell sources?
02:05:27 <sond> Lemmih, nope :/
02:05:38 <pesco> Sadly, I realise that design of a "better" UI is work for probably multiple theses and more.
02:05:52 <pesco> But hey, you never know how much it really takes until you've tried, right?
02:05:55 <sond> we have some problems with spawning new processes in wxhaskell
02:08:34 <shapr> Here's an example of an AFRP'd GUI - http://www.haskell.org/pipermail/gui/2003-January/000126.html
02:11:47 <shapr> A signal function for a tree control wouldn't be difficult, it'd just be like a machine powered by springs or something.
02:13:15 <blackdog> shapr: i'm sure that makes sense in context, but ... whert?
02:15:26 <shapr> With Yampa arrows, you set them up to react a certain way to a certain input, and that's what they do.
02:15:34 <shapr> Like...
02:16:30 <shapr> Sort of like finite state machines that run by themselves or something.
02:17:09 <shapr> Does that make any sense at all?
02:19:23 * shapr guesses not
02:21:53 <sond> shapr, I get it
02:21:59 <shapr> yay!
02:22:02 <sond> ;)
02:27:12 * Lemmih still dreams of a proxima-style editor.
02:31:16 <pesco> What's proxima?
02:31:30 <Lemmih> @google "haskell proxima"
02:31:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://igitur-archive.library.uu.nl/dissertations/2004-1115-104001/c7.pdf
02:31:49 <pesco> thnks
02:32:50 <Lemmih> @help google
02:32:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- search google and show url of first hit
02:36:48 <vincenz> 2google haskell proxima
02:36:53 <vincenz> @google haskell proxima
02:36:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://dirtsimple.org/2005/01/proxima-presentation-oriented-editor.html
02:36:55 <vincenz> hm
02:40:22 <Oejet> Wow, what a cool idea that Proxima editor.
02:50:48 <Lemmih> Oejet: Got time to get bzfragged?
02:54:55 <Oejet> Lemmih: I always have time to frag you.  Sniper map?
02:56:59 <Lemmih> Oejet: tavern.rklubi.ee:59151
03:30:41 * boegel greets his fellow haskellers
03:35:08 <TFK> "Haskelleers" sounds cooler, I think. Like "musketeers" ;-)
03:39:19 <Lunar^> Mhh.. Estonia
03:40:54 <boegel> omg, this is great ! http://www.eviltree.de/zoomquilt/zoom.htm
03:41:12 <Lunar^> Does anyone know if there is any returns from the Links meeting?
03:41:23 <shapr> Lunar^: see LtU
03:41:26 <shapr> slides, demo
03:41:35 <shapr> and it got me hacking on QuickCheck to add unit testing
03:41:43 <Lunar^> shapr: ohh cool
03:42:09 <Lemmih> Oejet: (:
03:42:13 <Lunar^> shapr: it got you?
03:42:13 <shapr> I've only see three people's slides, once I saw Xavier Leroy's comments on QuickCheck, I had to try it.
03:42:23 <vegai> Oejet: whoa.
03:42:24 <Lunar^> shapr: uhh ok :)
03:42:36 <vegai> s/Oejet/boegel/
03:42:50 <shapr> Read Xavier Leroy's slides and ideas about QuickCheck.
03:42:55 <Lunar^> shapr: I'm looking if there's cheap bus for Talinn
03:43:13 <shapr> I don't think I'm going to ICFP this year :-/
03:43:19 <boegel> vegai: I can't even begin to imagine how they pulled that of
03:43:28 <shapr> salut cognominal
03:43:39 <shapr> Lunar^: bea dit salut
03:43:43 <cognominal> hi shapr
03:43:49 <Lunar^> if that damn Eurolines website was not IE-only... :(
03:44:08 <Lunar^> shapr: cool :) Send her one back
03:44:21 <cognominal> shapr: as I told you are welcome to spread the fontionnal faith in French at #perlfr in irc.perl.org
03:44:21 <vegai> boegel: seems like they just change the picture quite often
03:44:38 <boegel> vegai, still, it's quite impressive
03:44:41 <shapr> cognominal: it's a kind offer, but I think it would confuse my swedish
03:44:43 <vegai> yes, it is
03:44:47 * shapr goes unicycling
03:44:58 * boegel is getting ready for squash
03:57:31 <blackdog> anyone got a link to xavier's slides?  I can't find them...
04:00:14 <blackdog> ah, got 'em.
04:00:45 <ozone> blackdog: the links slides?
04:02:57 <blackdog> yeah
04:03:06 <blackdog> http://homepages.inf.ed.ac.uk/wadler/linksetaps/
04:03:37 <ozone> blackdog: i liked odersky's talk the best so far
04:03:41 <ozone> though i'm just about to look at simonpj's :)
04:05:47 <blackdog> given that i'm a webmonkey now, i'd love to be able to do it in Haskell. Only problem is the enormous amount of boring library design and implementation involved in getting a framework like plone going...
04:06:12 <blackdog> er, this is in reference to xavier's talk, mostly
04:07:25 <wilx> So, I tripped bug in Darcs, it says.
04:10:06 <ozone> blackdog: ja
04:10:12 <ozone> and that's never much fun
04:10:26 <ozone> hopefully cabal will relieve much of that boredom
04:11:11 <blackdog> how would cabal help there? I thought it was just a way of distributing libraries
04:11:34 <ozone> it is
04:11:52 <ozone> but it'd actually encourage a social network of libraries to appear, ala CPAN for Perl
04:11:58 <ozone> or whatever-it's-called for Python
04:12:15 <TFK> PyPi.
04:27:51 <Lunar^> damn.. Wadler can't spell my teacher's name correctly
04:30:43 <Lunar^> lol... his name is liked spelled 4 times differently within 10 slides
04:31:01 <Lunar^> s/liked/like/
04:33:17 <yaarg> blackdog: were you at ETAPS?
04:33:44 * yaarg was
04:44:41 <ozone> does anyone here have experience with doing binary I/O in haskell?
04:44:55 <Lunar^> ozone: bits of them
04:44:56 <ozone> there's a couple of binary I/O libraries out there; am looking for any recommendations on which one to use ...
04:45:23 <Lunar^> ozone: CosmicRay should know that I think
04:45:23 <ozone> john goerzen's missingh looks quite nice, but the use of String types in his Binary I/O module seems a bit concerning
04:45:33 <ozone> i think cosmicray == john :)
04:45:39 <Lunar^> ozone: yep :)
04:46:17 <wilx> Hmm...
04:46:38 <ozone> might just go email him
04:46:40 <ozone> thanks Lunar^
04:46:53 <wilx> I use alloca/hGetBuf/Ptr a stuff to do binary IO.
04:47:11 <ozone> wilx: yeah, i'd rather not do all the grunt-work necessary to made a nice API for that, though ...
04:47:51 <wilx> Hmm, one polymorfic function aint that much work :)
04:48:57 * ozone notes he said 'nice' API :)
04:49:32 <wilx> Heh.
05:27:35 <ozone> hmm, i have a haskell package here which i just darcs get'ted
05:27:42 <ozone> it has a .cabal file, but no Setup.{lhs,hs} file
05:28:04 <ozone> any hints on how to compile this thing, before i start reading cabal docs?
05:28:49 <ozone> ah, nevermind, figured it out
05:29:27 <Igloo> I think that's a mistake, and it should hav a 2-line standard Setup.lhs
05:29:56 <ozone> nod
05:30:25 <ozone> now, if only missingh would compile, i'd be a happy boy
05:31:02 <Igloo> heh
05:34:27 * Igloo giggles at Isaac's     Previously[1]       [1] That is, currently.
05:43:07 <Igloo> Hmm, there's no nice way to show a string without getting the quotes at either end, is there?
05:43:27 <tromp> putStr
05:43:29 <Lemmih> 'id' (:
05:43:57 <tromp> it's the show function that puts them on:(
05:43:57 <Igloo> I need to get backslashes etc escaped
05:44:20 <tromp> then strip them from the result of show
05:44:36 <tromp> or write a show' :(
05:44:45 * Igloo points at the key word "nice"  :-)
05:45:03 <tromp> in that case, not that i know of:(
05:46:00 <tromp> lobby for inclusion of an escape function in prelude:)
05:46:17 * Igloo writes (init . tail . show) and feels dirty
05:47:24 <Lemmih> @plugs foldr Data.Char.showLitChar "" "hello\t"
05:47:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "hello\\t"
05:48:01 <tromp> maybe you'd feel less dirty defining a strip = init.tail :-?
05:48:06 <Lemmih> Tarda!
05:49:03 <tromp> nice, Lemmih
05:50:24 <Igloo> Nifty, thanks!
05:52:09 * boegel bounces
05:52:21 <boegel> hey tromp, had time to read my small piece of text ?
05:52:33 <tromp> not yet:(
05:53:29 <Lemmih> I wonder why it's slower than (init.tail.show) ...
05:54:04 <xerox> @type init
05:54:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- init :: forall a. [a] -> [a]
05:54:49 <Lemmih> @plugs init "I should be slow as hello"
05:54:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "I should be slow as hell"
05:59:54 <Igloo> Ah, it doesn't DTRT with " though
06:00:18 <Oejet> Lemmih: Maybe because of lazy evaluation, (init . tail . show) will be O(n).
06:00:22 * ibid read that first DIRT
06:00:47 <Igloo> Oejet: They'll both be O(n)
06:01:22 <Lemmih> Phew. It's only slower in GHCi.
06:03:25 <Oejet> Igloo: Maybe there are some uptimization tricks then.  At least there could be.
06:04:38 <shapr> party time! be back tomorrow
06:06:32 <theorbtwo> .oO(Party time!  MTV!  Somethingoranother!)
06:06:33 <Igloo> Oh bother. I need a -nocpp
06:08:21 * Lemmih found a bug in Cabal.
06:08:26 * boegel would love a party right now :(
06:10:44 <Lemmih> Is it a bug that showLitChar "\"" s = "\"" ++ s?
06:11:37 <Igloo> I was going to ask the same thing  :-)  By my reading of the docs it is
06:12:20 <ozone> huzzah, missingh compiling
06:12:30 <ozone> die cpp
06:18:33 <Lemmih> Oh it's not a bug. show '"' /= "'\\"'"
06:24:36 <dons> ozone, did you work out your binary io issues?
06:25:17 <dons> are you just looking to write bytes to handles, or do you want something more structured, like class Binary or SerTH ?
06:26:38 <ozone> dons: basically read/write bytes to handles
06:26:43 <ozone> wanted to see what libraries were around to do it
06:26:57 <ozone> there's a block IO library at cryp.to, but that looks quite primitive
06:27:19 <xerox> Any HaskellGoPeople in the mood for a game?
06:27:20 <ozone> john goerzen's missingh looks nice, though it's a bit odd that he's using Strings for his "binary" I/O
06:27:28 <ozone> i would expect Word8s
06:29:22 <dons> hGetBuf /hPutBuf work fine in Yi.
06:29:53 <dons> for structured io, I derive Binary in hs-plugins, for magic get and put ops.
06:30:37 <ozone> can't even remember what deriving Binary does anymore
06:30:58 <ozone> is that a magic deriving thing?
06:31:12 <dons> kind of like Storable, but for binary IO
06:31:26 <dons> .hi files are written this way.
06:31:55 <dons> class Binary a where
06:31:55 <dons>     put_   :: BinHandle -> a -> IO ()
06:31:55 <dons>     put    :: BinHandle -> a -> IO (Bin a)
06:31:56 <dons>     get    :: BinHandle -> IO a
06:32:24 <ozone> hmm, where's the info for BinHandle/Binary/Bin?
06:32:55 <dons> $fptools/ghc/compiler/utils/Binary.hs unfortunately.
06:33:07 <dons> but DrIFT can derive it for you too.
06:33:15 <ozone> dons: sounds like you can't get access to it from a normal module ...
06:33:32 <dons> you can import it.
06:33:43 <dons> cp a.hs ~/b.hs ;)
06:34:29 <dons> another option is SerTH,  musasabi's new TH deriver for similar functions
06:34:53 <dons> but if you can marshal you value  into a byte array, the hPutBuf should do the trick
06:35:16 <dons> (Binary just does the marshalling for you)
06:35:47 <dons> the lack of a Binary.hs in the hier labs is *something we should fix*
06:35:55 <dons> s/labs/libs/
06:36:12 <ozone> why can i see myself producing a multitude of libraries before i get 10% of my ph.d done
06:36:50 <dons> do you want to write all sorts of types out as binary? or is hPutBuf going to do?
06:38:16 <ozone> well, a Binary class where i can overload the equivalent of show/read would be great
06:38:29 <ozone> though i'll have to do some boring hPutBuf'ing at some points, i think
06:38:48 * ozone scratches head
06:39:01 <dons> yeah. so look at hs-plugins/src/hi/Hi/*.hs for which files to rip out of ghc's utils/
06:39:01 <ozone> why on earth am i having so many problems with cpp and ghc
06:39:21 <dons> then you'll get a damn fast Binary. SerTH is worth looking at too.
06:39:22 <ozone> now cpp is failing a #if __GLASGOW_HASKELL__ >= 630
06:39:31 <ozone> dons: ok, cheers
06:39:54 <Igloo> Should be 603
06:40:28 <ozone> Igloo: even if i'm using 6.4?
06:40:39 <Igloo> 603 means 6.3
06:40:43 <dons> checking for value of __GLASGOW_HASKELL__... 604
06:40:50 <dons> checking for value of __GLASGOW_HASKELL__... 602
06:40:59 <dons> so 603 should be in between :)
06:41:01 <ozone> weird
06:41:05 <ozone> but fair enough
06:41:10 <Igloo> So unless someone has some inside info on what'll be new in ghc 6.30  :-)
06:41:19 <dons> oooh!
06:41:29 <ozone> so, what would 6.2.2 be?
06:41:29 <dons> maybe we'll have Data/Binary.hs :)
06:41:32 <ozone> 6022?
06:41:35 <Igloo> 602
06:41:35 <ozone> :)
06:41:51 <Igloo> That's why you can' make interface changes in point releases
06:41:54 <ozone> no way to check for the minor minor version, then?
06:42:15 <dons> sure, you _could_ check for it, but not with __GLASGOW_HASKELL__
06:42:40 <dons> paprika$ ghc --numeric-version
06:42:40 <dons> 6.2.2
06:42:52 <dons> stick that in you configure.ac and smoke it ;)
06:43:00 <ozone> been there, done that :)
06:43:21 <ozone> dons: weird thing was that when 6.4 came out, i got two emails from HOC folks complaining it was broken with 6.4
06:43:28 <ozone> i thought nobody except wolfgang and me used it :)
06:43:32 <dons> hehe
06:43:46 <dons> break the code -- that's a good way to find out who your users are.
06:43:52 <ozone> schweet
06:43:54 <ozone> missingh installed
06:52:41 <TheHunter> @quote ghc
06:52:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   scavenge: unimplemented/strange closure type
06:53:42 <dons> not too sure about what happens to the State/ logs if lambdabot is killed (?)
06:54:16 <TheHunter> @eval and [True,True,False]
06:54:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unbound variable: and
06:54:43 <tromp> @index and
06:54:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
06:54:48 <TheHunter> it should save the state if it's SIGINTed.
06:55:08 <dons> ok.
06:55:21 <TheHunter> what do you think. When should the state be saved?
06:56:01 <TheHunter> i think you've lost the eval state. Probably killing lambdabot and darcs revert will fix that.
06:56:17 <dons> yeah. i lost the karma state too.
06:56:35 <dons> M ./lambdabot/State/eval -260 +1
06:56:45 <dons> but karma wasn't in darcs yet.
06:57:01 <TheHunter> right. I changed the format to multiple lines so that revision controlling the files is easier.
06:57:14 <dons> ok. yeah, that's a good patch.
06:59:42 <dons> good. the state got saved.
06:59:59 <TheHunter> @eval and [True,True,False,id,9]
06:59:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- False
07:00:10 <dons> :)
07:00:25 <dons> @karma TheHunter
07:00:26 <TheHunter> @eval and [True,False,fdjkaslfds]
07:00:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter has a karma of 1
07:00:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- False
07:00:44 <Igloo> Argh. I hate make. And cpp.
07:00:56 <TheHunter> hehe.
07:00:59 <TheHunter> @karma dons
07:01:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 1
07:01:21 <dons> so that's cool that the state got flushed in a sighup.
07:03:39 <ozone> Igloo: join the club
07:03:56 <dons> make's fun. cpp sucks. I'm really enjoying: $(filter-out $(patsubst $(filter $(filter ... ))))
07:04:06 <dons> it's like a stupid Data.List
07:04:07 <Igloo> Oh, I'm a long-standing member. Just wanted to reaffirm my membership.
07:04:32 <ozone> Igloo: i'm part of an orkut group named "autotools anonymous"
07:04:48 <dons> hehe
07:05:03 <dons> ozone needed strong help after runtime loader's automake code.
07:05:11 <Igloo> Doesn't that imply you are addicted to them? I have rather the opposite problem...
07:05:25 <dons> he's a recovering addict, now, I think
07:05:34 <ozone> i think it merely implies that you've suffered some significant damage from them
07:05:49 <ozone> then again, i am also part of the breadth-first-search, domo kun and victoria's secret communities on orkut
07:06:00 <ozone> make of that what you will
07:06:08 <dons> oh, you mean "victims of autotools" support group, ozone.
07:06:28 * Igloo reverts back to the rule-copying method of parameterising - yay
07:07:43 <Igloo> Hmm, actually, I could probably do it with $(GHCFLAGS_$@) or something
07:08:29 <dons> hehe. the queen doesn't have to sing 'god save the queen'
07:09:40 <ozone> schmexcellent
07:09:43 <ozone> "Finally, there are pipes. These pipes are analogous to the Unix pipes that are available from System.Posix, but don't require Unix and work only in Haskell."
07:09:55 <ozone> @karma+ CosmicRay
07:09:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- CosmicRay's karma has been incremented
07:11:23 * Igloo turns the TV on and thinks the ability to read lips would be useful
07:26:45 <yaarg> veas?
07:35:58 <ozone> dons: ahh, i found a library called NewBinary that seems to implement those Binary classes you were talking about
07:36:13 <ozone> mostly ripped from NHC's binary code, looks like it'll pretty similar to GHC's Binary stuff
07:49:15 * wilx surfs on his caffeine wave... 
07:49:17 <wilx> Wheee!
07:49:21 <metaperl> lol
07:55:12 <tschwinge> Hi!  Is this the right place to ask if someone has already tried to port the GHC to GNU/Hurd?
07:55:22 <autrijus> oh wow, hurd.
07:55:52 <tschwinge> :-)
07:55:54 <metaperl> ys, this is a good place... a post to sequence.complete.org or the haskell-cafe on GMANE is also good
07:56:20 <ibid> heh... haskell-cafe on GMANE...
07:57:10 <metaperl> it is on gmane... why are you laughing?
07:58:18 <ibid> GMANE is merely a mirror
07:58:24 <ibid> unless it's been moved recently
07:58:55 <metaperl> oh I see... yes. gmane is far more convenient for me as a gnus-user
07:59:17 <ibid> it's like talking about linux.debian.devel on Google :)
07:59:38 <ibid> i've never understood GMANE
08:06:06 <tuomov> gmane rocks
08:06:31 <tuomov> I read all my mailing lists through news.gmane.org (nntp, not a shitty web interface)
08:10:38 * Oejet too.
08:14:11 <ibid> okay, that makes some sense
08:14:24 * ibid never understood why anybody would use the web interface
08:14:52 <ibid> if one wasn't forced, of course
08:16:22 <TheHunter> back to the question, glasgow-haskell-users would probably be a better place to ask.
08:17:22 <tromp> my thunderbird says connection to news.gmane.org refused
08:18:14 <tromp> does it require ssl, or a port other than 119?
08:26:59 <tschwinge> Nobody here seems to know, the search engine of <URL:http://sequence.complete.org> didn't reveal anything, so I'll flip a coin and see where I'll post on haskell-cafe or glasgow-haskell-users.  :-)
08:28:04 <tuomov> I just run slrn -h news.gmane.org
08:28:16 <tuomov> so it shouldn't require anything special
08:43:08 * autrijus wishes mutual recursive modules can be easier to deal with :-/
08:59:37 <tschwinge> Bye and thanks so far!
10:05:28 <TheHunter> grrr, No instance for (Functor (Data.FiniteMap.FiniteMap String))
10:12:17 <Lemmih>  /me heads to bed.
10:12:29 <Lemmih> Bah. Stupid spaces.
10:19:55 <Oejet> Slow evening it seems.
10:20:32 <gzl> urgh, this is off topic, but does anyone here use mailman?
10:21:04 <jlouis> gzl: I have quite some experience wit it
10:21:09 <jlouis> why?
10:21:41 <gzl> ooh. ok, so these people have set up something where emails that get bcc'ed to the listserv are placed in a queue for the admin to explicitly approve (because 99% of it is spam)
10:22:03 <gzl> but it seems to make me click "discard" for each message in the queue individually, is there any way to just flush them all at once?
10:29:22 <gzl> jlouis: does the question make sense?
10:58:22 <gzl> Oejet: you around?
10:58:30 <gzl> oops.
10:58:33 <gzl> Philippa_: you around?
11:01:45 <wilx> .
11:02:40 <Oejet> gzl: Shure.
11:03:28 <gzl> for wikis that use CamelCase
11:03:30 <Oejet> gzl: Any progress on the Wiki parser?
11:03:36 <gzl> how do you handle one word titles?
11:04:13 <gzl> i mean, what if you wanted an article on "Haskell" or "Monads"?
11:04:59 <gzl> and no, not really, i've been working on some other parts of the wiki. if i finish them quickly enough i can get back to the parser.
11:07:59 <gzl> i guess i'm missing something about how camelcase works (?)
11:10:11 <gzl> Oejet: you see what I mean? it seems like the pattern for camelcase doesn't let you have one word page names
11:11:53 <TheHunter> gzl, MoinMoin uses ["Foo"]
11:13:35 <Oejet> References: JoinCapitalizedWords or use square brackets for a [page link] or URL [http://cool.wiki.int/].
11:13:54 <Oejet> Preventing linking: Prefix with "~": ~DoNotHyperlink, name links like [text | URL].
11:15:38 <gzl> hmm
11:16:08 <gzl> yeah, earlier I had [[link]] or [[link|alternate text]] where link need not be camelcase, but now I'm thinking of switching to it
11:17:26 <gzl> ok, maybe I can require that all links still be in [[ ]] and then allow one word links
11:17:30 <gzl> that soudns ok
11:27:41 <gzl> yeah, this is ok. thanks Oejet, TheHunter
11:27:53 <gzl> I put it in as [[Foo]] or [[Foo|alternate text]]
11:28:32 <Oejet> gzl: No problem.
11:28:59 <gzl> er, right now I'm requiring [[CamelCase]] too. is it worthwhile to allow just CamelCase to auto-link?
11:29:13 <gzl> i guess that's the usual way of doing things
11:32:41 <Oejet> Greetings, lisppaste2.
11:44:00 <smott> gzl: an option for either just CamelCase or [[CamelCase]] for links would be great
11:44:14 <gzl> ah, both?
11:44:21 <gzl> ok.
11:45:59 <smott> personally i prefer the latter because it's what wikipedia uses and you don't have to insert <nowiki> or whatnot everywhere, but a lot of wikis use the former
11:46:37 <gzl> i really don't like camelcase at all, but i think it'll simplify some things, and at least since it can do alternate text, at least i don't really have to look at it.
11:46:51 <gzl> but i find it really annoying to look at links in camelcase
12:09:38 <halcyon10> hi, what Class should i use for general operations on floating-numbers ?
12:10:51 <SyntaxNinja> what do you want to do with them?
12:12:48 <halcyon10> i want to write a general function to take a list of numbers and then divide it by the sum of its elements. So it normalizes the list. what is the most general Class i can use for that?
12:13:21 <Igloo> Look at the types of the things you need
12:13:25 <Igloo> @type (+)
12:13:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (+) :: forall a. (Num a) => a -> a -> a
12:13:31 <Igloo> @type (/)
12:13:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (/) :: forall a. (Fractional a) => a -> a -> a
12:13:44 <halcyon10> ah, thats a good tip, thanks
12:13:45 <Igloo> So (Num a, Fractional a) is needed
12:13:59 <SyntaxNinja> Floating or Fractional.
12:14:02 <Igloo> But Fractional will imply Num, so just Fractional will do
12:14:50 <halcyon10> ok, thanks for clearing that up.
12:16:07 * TheHunter has just messed up his fonts during an apt-get dist-upgrade. D'oh!
12:16:39 <TheHunter> There's dpkg-reconfigure fontconfig and x-ttcidfont-conf, anything else I'm missing?
12:17:27 <SyntaxNinja> fonts are a complete mystery to me; I used to understand them on Mac OS 7.
12:17:57 <TheHunter> yeah, to me too. I just want them to look pretty.
12:18:33 <SyntaxNinja> fonts and encodings are things that no human should have to think about ;)
12:18:40 <SyntaxNinja> except font designers, they're cool and all.
12:19:28 <wagle> ooo..  instead of typechecking tilings, typecheck typesettings (ala TeX)..
12:19:48 <TheHunter> hmm, that looks better, but veeery blurry.
12:20:54 <SyntaxNinja> TheHunter: blurry is totally in
12:21:17 <wilx> Seems to be true for *nix users :)
12:21:42 <wilx> I like Windows' rendering of fonts better though.
12:22:11 <wagle> the current things seems to be to have a font server these days
12:23:12 <wagle> linux has some access to the windows fonts, but (as of a year or two ago?) you had to get them from microsoft, i think..  though that might have changed
12:23:32 <wagle> "truetype" fonts, or some name like that
12:23:34 <TheHunter> wilx, yes, cleartype looks good on lcds. If you have a crt, you don't get proper antialiasing in windows.
12:24:10 <wagle> macosx does different antialiasing for lcd, crt, etc..  dunno what exactly the diffs are
12:24:25 <wilx> Either way the fonts seem to look less blury on Windows...
12:25:32 <wagle> wilx: lcd or crt?
12:25:38 <wilx> CRT.
12:26:38 <wagle> i was pretty happy with the fonts i was getting starting with rhat9 on lcd/tft..
12:26:53 <wagle> (i switched to a powerbook about  years ago)
12:26:58 <wilx> w00t!
12:27:04 <wilx> Gnome finished compiling and installing.
12:27:11 <wilx> 12 hours.
12:27:16 <wilx> brb
12:27:17 <wagle> how many weeks ago did you start?
12:34:06 <wilx> Wheee.
12:34:10 <wilx> Works.
12:34:20 <wagle> not blurry any more?
12:34:42 <wilx> Nah, still blurry but not WindowMaker anymore :)
12:34:49 <TheHunter> not blurry, but still ugly.
12:35:15 <vegai> wha, my windowmaker has totally excellent and rad fonts (, dude)
12:35:36 <wagle> it used to be that you had to do stuff to get the fonts to work right
12:36:19 <wagle> and fonts were easy to accidentily mess up
12:36:53 <wagle> but i dont remember any details, sorry..  have to ask around and surf for the answer
12:44:21 <basti_> hi
12:51:29 * tuomov things cleartype/subpixel rendering is also ugly mushroom haze
12:51:42 <tuomov> on tft, with any pixel order setting
12:53:25 <wilx> :)
12:54:28 <wagle> hmm..  actually, i think that, after lcd/tft, all crt's are blurry and fuzzy
12:55:08 <tuomov> yeah, once you've used a tft there's no going back
12:55:32 <tuomov> even a crappy tft with poor viewing angles
12:55:54 <tuomov> it's still so much better
12:56:03 <wilx> Really?
12:56:05 <wilx> Hmm....
12:56:39 <tuomov> I wouldn't want to switch back to a bulky blurry crt
12:57:38 <basti_> they are VERY pleasant to work on
12:57:47 <basti_> five star comfort
12:57:47 <smott> i wanted to buy a tft, but all the ones in the stores looked a lot more blurry than my crt
12:57:53 <basti_> almost like those OLD text displays
12:57:55 <basti_> amber or green
12:58:03 <basti_> VERY long "afterlight" time
12:58:19 <tuomov> smott: using vga cable without tuning?
12:58:33 <basti_> very comforting
12:58:35 * basti_ sighs
12:58:36 <tuomov> tft:s can look very blurry if you're using vga cable and haven't managed to tune it correctly
12:58:44 * basti_ and in the flickry light they saw
12:58:45 <wagle> stores run many lcds from a single, underpowered analog video signal
12:59:03 <smott> tuomov: no idea
12:59:05 <wagle> you dont want to run a lcd using analog video
12:59:24 <tuomov> I'm too cheap to buy a new graphics card so I'm using vga
12:59:49 <tuomov> the picture is crisp except when occasionally the display loses the settings, and goes automatically tune itself -- incorrectly
13:00:00 <basti_> the comforting factor still stays with vga
13:00:05 <basti_> a little wiggly now and then though
13:00:13 <tuomov> my standard X desktop isn't complex enough signal for tuning... the default X background is rather good
13:00:23 * wagle pats his $400 pair of glasses that years of crt use probably caused him to have to use now
13:00:47 <smott> i'll probably buy a tft once it gets hotter this year. this 19" generates far too much heat
13:00:52 <vegai> I don't think monitors cause myopia
13:00:59 <SyntaxNinja> where's cosmicray when I need to talk to someone about amtrax
13:01:02 <rtega> vegai: yes they do
13:01:04 <tuomov> umm... tft:s generate as much heat I think
13:01:05 <rtega> at least bad monitors do
13:01:07 <wagle> astygmatism
13:01:16 <vegai> rtega: is that a fact?
13:01:17 <wilx> Hm.
13:01:23 <wilx> Not from VGA cable?
13:01:32 <wilx> What else is there to use with LCD?
13:01:40 <rtega> vegai: have a look at all the people who spend far too much time in front of a bad monitor
13:01:52 <rtega> either they wear glasses or lenses
13:01:52 <vegai> well... yes
13:02:00 <smott> tuomov: around 40W, i think vs my 150W
13:02:07 <vegai> I don't like statistical "evidence" too much :)
13:02:26 <tuomov> smott: well, I haven't looked at the wattages, but this tft is also _hot_
13:03:00 <yome> Hi.
13:03:03 <SyntaxNinja> hi
13:03:08 <wilx> Hmm, I miss my Rainy Day theme from Windows.
13:03:54 <yome> Could anyone point me to a good paper on (monadic?) parser combinators that would be understandable by a schemer?
13:04:36 <wilx> @google Parsec
13:04:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.parsec.org/
13:04:46 <SyntaxNinja> yome: do you already understand monads?
13:04:52 <SyntaxNinja> parsec is a great example
13:05:01 <yome> SyntaxNinja: I think I have a basic understanding.
13:05:09 <wilx> Eh, that is not the url though :)
13:05:10 <yome> I'm still not totally at ease with it.
13:05:50 <SyntaxNinja> yome: read about parsec :) http://www.cs.uu.nl/~daan/parsec.html
13:06:28 <yome> SyntaxNinja: thanks a lot.
13:07:26 <SyntaxNinja> no problem.
13:07:34 <yome> Hmm. I can't find an implementation of parsec for Scheme.  Sounds like a good exercise :)
13:07:39 <SyntaxNinja> monadic combinator libraries are a great feature of Haskell
13:07:56 <SyntaxNinja> yome: sounds like quite a challenge ;)
13:08:03 * basti_ has just played around with fast lazy lexers.
13:08:05 <yome> I've heard many good things about it.
13:08:09 <basti_> (Yi related)
13:11:31 * stepcut needs to master the ctk lexers
13:12:06 <stepcut> I need to write a fast parser for /var/lib/dpkg/status
13:12:07 <basti_> stepcut: "master" how far?
13:12:10 <basti_> ohh.
13:12:15 <basti_> i guess we're the same boat then
13:12:42 <basti_> i think thats what Yi uses too.
13:12:46 <stepcut> my status file is 827564 bytes
13:12:53 * basti_ already understood `meta`
13:13:02 <stepcut> Yeah, yi uses the ctk lexer
13:13:38 <stepcut> basti_: are you adding a better emacs mode to yi?
13:13:41 <basti_> should be quite easy.
13:13:43 <basti_> i'm trying
13:13:53 <SyntaxNinja> basti_: cool! then I can use it!
13:13:55 <stepcut> I played around with that a bit a few months ago when I had time
13:14:09 <basti_> hmm i could maybe make a darcs repo
13:14:24 <stepcut> basti_: I made a list of the 'essential' things that have to be supported
13:14:40 <basti_> stepcut: aw cute where
13:15:05 <stepcut> (1) showing the 'C-x - ' stuff in the message bar
13:15:14 <basti_> trying to do so
13:15:17 <basti_> rudimentary support
13:15:23 <basti_> :)
13:15:35 <stepcut> (2) allowing tab completion of M-x commands
13:15:44 <basti_> thinking about it.
13:15:47 <stepcut> (3) supporting 'C-h k'
13:15:58 <stepcut> (4) rebinding keys (of course)
13:16:04 <basti_> (4) will be easy
13:16:15 <basti_> h k is ok.
13:16:29 <basti_> will be doable
13:16:51 <stepcut> I think there is one more thing... but I don't remember it yet
13:17:16 <stepcut> (5) C-u
13:17:32 <basti_> doing WHAT? ;)
13:17:47 * basti_ doesnt have that bound
13:17:56 <stepcut> C-u is bound by default...
13:18:07 <stepcut> try, C-u 20 a
13:18:16 <basti_> ah
13:18:20 <stepcut> it repeats a command
13:18:24 <basti_> hmm ok
13:18:30 <stepcut> C-u a will do it 4 times
13:18:59 <stepcut> or in a big buffer, you can do C-u 0 C-l to move the currently line to the top of the buffer
13:19:35 <basti_> hmmm.
13:19:38 <stepcut> it captures a number that is passed into the following command
13:19:40 <basti_> yup
13:19:45 <basti_> i see.
13:19:50 * basti_ just never used it
13:19:52 <stepcut> it is often, but not always interpreted as a repeat
13:20:01 <basti_> ah.
13:20:22 <basti_> we'll see.
13:20:22 <stepcut> also, capturing/replaying keyboard macros
13:20:35 <basti_> lets stay on the carpet.
13:20:47 <basti_> =)
13:21:08 <stepcut> the hard part with (4) is how to express the command you want to bind to at run-time
13:21:19 <basti_> hmm.
13:21:32 <basti_> is there some sort of eval function?
13:21:33 <stepcut> in the compiled code, you just bind the key to some code that is compiled
13:21:41 <basti_> i know
13:22:07 <basti_> we would need 2-way association
13:22:11 <stepcut> right
13:22:39 <basti_> hmm.
13:23:06 <stepcut> in any case, it seems wise to think of all the difficult things to support in emacs, and try to support them from the beginning, before getting to involved in writing too many default bindings
13:23:12 <basti_> yes.
13:23:13 <basti_> indeed.
13:24:02 <stepcut> but it is a fun project
13:24:14 <basti_> yes we'll just water it a bit now and then and it might grow.
13:25:25 <stepcut> yeah, once a solid core is in place for emacs, anyone can come along and add their favorite missing bindings
13:25:50 <basti_> hummm.
13:25:53 * basti_ ponders.
13:26:16 <basti_> there is this ui rule: none-one-infinitely many
13:26:35 <basti_> how many different "meta" modes are there in emacs?
13:26:51 <stepcut> not sure what you mean by that ?
13:26:56 <basti_> i mean: C-x
13:27:02 <basti_> gives an own kind of feedback
13:27:09 <basti_> M-x has an own kind of feedback
13:27:14 <basti_> there's filename feedback
13:27:19 <basti_> and various namespace feedbacks
13:27:25 <basti_> (dialogs, minibuffers, whatever)
13:27:30 <wagle> any key can be meta
13:27:45 <basti_> no i mean "meta" in the sense of "above" or something
13:27:50 <basti_> there is a normal editor mode
13:27:52 <basti_> type type
13:27:53 <basti_> delete
13:27:54 <basti_> enter
13:28:06 <basti_> and then you type C-x and your editor behaves like on crack
13:28:21 <basti_> and on different crack for each "special" keystroke
13:28:41 <wagle> (whereas vi starts out on crack until you manage to type "i"..  8)
13:28:43 <basti_> so there should be a "flat" list of these bizarro modes
13:28:48 <basti_> wagle: yup
13:28:59 <basti_> i mean every editor has to, i think
13:29:02 <basti_> hard to do without
13:29:03 <basti_> ;)
13:29:45 <wagle> yeah...  i just dont know the answer wrt emacs..  i think its fuzzy due to the programmability of emacs
13:29:45 <basti_> except... keystroke file navigation
13:29:46 <stepcut> basti_: but, just the act of openning a file can cause a new mode to be loaded from an .el file on the disk...
13:30:00 <basti_> yup
13:30:10 <basti_> we will NOT be writing an emacs emulation
13:30:11 <basti_> =)
13:30:15 <basti_> you got that right.
13:30:36 * wagle burns basti_ at the steak for heresy
13:30:49 * basti_ runs
13:31:09 <basti_> i think it would be wise to support a flat list of wacko modes
13:31:42 <basti_> each one with their own lexer... and well defined conditions...
13:32:14 <wagle> basti_: what are you working on?
13:32:36 <basti_> wagle: i'm playing with Yi.. trying to make some emacs-feel frontend
13:36:45 <theorbtwo> I'm having a problem (OK, another problem) using hs-plugins.  This one is probably down to my inexperince with Haskell.
13:37:05 <theorbtwo> I'm trying to use loadObject from Plugins, but can't get it to import.
13:38:20 <theorbtwo> External/Haskell.hs doesn't compile with {-# OPTIONS_GHC ... -package plugins #-} ... import Plugins (load, LoadFailure, LoadSuccess, loadObject).
13:38:55 <basti_> :-o
13:39:39 <theorbtwo> src/External/Haskell.hs:19:48: Module `Plugins' does not export `loadObject' (and likewise for LoadFailure, LoadSuccess).
13:41:36 <jdv79> is haskell like an ML?
13:41:49 <basti_> no its laz.
13:41:50 <basti_> y
13:42:02 <jdv79> what is it most like?
13:42:12 <theorbtwo> Any clue, basti?
13:42:18 <wagle> unique
13:42:20 <mflux> haskell is like something completely different ;)
13:42:22 <basti_> theorbtwo: not a single one
13:42:26 <jdv79> thanks:)
13:42:28 <basti_> jdv79: lisp on crack?
13:42:41 <mflux> but I suppose one would need to pick anything close to it, maybe it's ml then?
13:42:52 <basti_> maybe.
13:42:56 <mflux> atleast both have type inference and some similar syntax
13:43:00 <theorbtwo> It's closer to mathematics then any other language I've seen, but I've not seen a huge array of languages.
13:43:23 <theorbtwo> Well, I'm not sure about similar syntax, but they both have fairly minimal syntaxes.
13:43:33 <theorbtwo> (To the point of making them difficult to read, IMHO.)
13:43:53 <wagle> miranda went commercial in the mid to late 1980's, thus haskell was invented to be the replacement research programming language
13:44:05 <basti_> ml are pretty uhm... BIZARRE sometimes
13:44:12 <basti_> haskell is a little more relaxed.
13:44:16 <theorbtwo> Neither use commas to build argument lists, which is really a similar lack of syntax.
13:44:40 <basti_> o0
13:44:42 <basti_> lack
13:45:05 <theorbtwo> (LISP doesn't use commas for lists anywhere; Haskell denies that it's possible to have more then one argument.)
13:45:16 <basti_> hey hey hey hey hey
13:45:19 <basti_> lol
13:45:30 <basti_> thats not true
13:45:39 <basti_> haskell supports as many paramters as you like
13:45:46 <vegai> yes, it's all true
13:45:55 <basti_> even if you dont know the complete list yet :)
13:46:03 <vegai> Haskell sadly also lacks some very important syntactic elements of Intercal ;(
13:46:11 <basti_> yes.
13:46:15 <theorbtwo> But it's really a function that takes one argument and returns a function that may take more arguments.
13:47:12 <jdv79> scheme < haskell?
13:47:31 <vegai> are scheme and haskell part of Enum?
13:47:33 <wagle> max arity for tuples in ghc appears to be (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
13:47:57 <basti_> theorbtwo: thats a feature not a bug
13:48:00 <basti_> jdv79: not strictly.
13:48:07 <theorbtwo> I know, basti.
13:48:07 <basti_> jdv79: but knowledge of scheme could halb
13:48:07 <vegai> jdv79: yes, scheme often is smaller
13:48:11 <basti_> argh
13:48:12 <basti_> help
13:48:13 <wagle> no.. scheme can do things haskell cant, but template haskell closes some of that gap
13:48:20 <theorbtwo> But not having commas lowers readability.
13:48:45 <theorbtwo> Not having commas between arguments, that is.
13:48:51 <wagle> my favorite helloworld program is a scheme interpreter
13:49:01 <jdv79> i'm from the perl/c/c++/c# side of things - which should I check out first basically.
13:49:07 <basti_> theorbtwo: if you say so.
13:49:14 <wagle> doing that for haskell would be ummm a bit more adventurous
13:49:21 <theorbtwo> It does for me, leastways, basti.
13:49:26 <vegai> jdv79: it doesn't matter. Just focus on one first, then the other
13:49:35 <jdv79> ok, cool
13:49:35 <vegai> scheme is probably a bit easier to grasp
13:49:45 <vegai> focus is the most important thing
13:50:21 <jdv79> I can do that for about 30 seconds solid at a time, maybe a whole minute if its really interesting:)
13:50:23 <wagle> the main confusing thing about scheme (actually lisp, in general) is that there are TWO parsers
13:51:22 <jdv79> I thought it was just that one famous loop, read, something, something, something...
13:51:45 <wagle> one parsers inputs strings and outputs s-expression data structures in the heap..  the second parser inputs s-expression data structures in the heap and outputs (often implicitly) programs
13:52:15 <theorbtwo> REPL -- Read Eval Parse Loop.
13:52:40 <jdv79> yeah, that one - that's about the extent of my functional lang knowledge
13:52:41 <wagle> read does the first parse, eval does the second parse
13:53:24 <wagle> many subtleties make much more sense if you dont try to imagine that strings map to programs atomically
13:53:43 <wagle> but that its a two stage process
13:54:52 <jdv79> i'll check back here after my mind melts down a few times and i'm bordering on insanity but i gotta go get some dinner right now.  thanks for the pointers and all.
13:56:32 <wagle> if you visualize scheme programs as the data structures in the heap (that strings are just one of many ways to create), things make more sense
13:57:00 <wagle> modulo template haskell, haskell programs are just strings
13:58:28 * wagle wanders off
14:00:55 <ows> hi did you hear of MULTI 2005 conference?
14:08:22 <gzl> i want to use Dbconnect for something, but there doesn't appear to be any documentation. am I being stupid?
14:09:05 <gzl> ah, I am
14:09:07 <gzl> good, there is a litte
14:11:20 <gzl> * little
14:18:30 <stepcutHM> cripe
14:19:25 <stepcutHM> amazon has terrible reporting for sellers
14:19:47 <stepcutHM> there is no way for me to find out how much money the owe me or that I owe them
14:22:54 <stepcutHM> but, on the bright side, my cd is currently ranked at number 378818
14:31:30 <gzl> @type io
14:31:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
14:35:52 <stepcutHM> gzl: are you using wash/cgi ?
14:36:01 <gzl> yeah, i found the type.
14:36:11 <stepcutHM> ok, io is wash specific :p
14:36:27 <gzl> i know, i was just wondering if lambdabot looked at wash. pipe dream. :)
14:36:33 <stepcutHM> hehe
14:36:49 <stepcutHM> @type CGIInternal.io
14:36:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
14:36:56 <stepcutHM> maybe if was
14:37:08 <stepcutHM> wash gets integrated into the hierarchical libraries
14:38:10 <gzl> i'm not a huge fan
14:38:24 <gzl> i find it kind of annoying to use
14:39:56 <stepcutHM> indeed
14:41:22 <gzl> it's just inordinately complicated to do trivial things with it
14:41:26 <stepcutHM> heh
14:41:59 <stepcutHM> I hear there is a project in the works to do a new web/cgi interface based on 'generalized' arrows
14:42:05 <gzl> oh god
14:42:22 <stepcutHM> ?
14:42:32 <gzl> now they're generalizing *arrows*?
14:42:51 <stepcutHM> well, they just dropped the highly problematic pure/arr function
14:43:01 <gzl> i haven't really played with arrows yet
14:43:11 <stepcutHM> it's not exactly clear what the new thing is ...
14:43:34 <stepcutHM> but, everytime someone tries to do something with arrows, the damn pure function ruins the fun
14:43:50 <stepcutHM> which is probably part of why there is very little done that uses arrows
14:44:24 <gzl> huh
14:44:24 <gzl> ok
14:44:31 <gzl> the only thing i've really heard of is Yampa.
14:44:43 <stepcutHM> yeah
14:44:46 <gzl> only thing using arrows
14:44:59 <gzl> and i couldn't go to the talk on it, so i don't really know what it's doing. :)
14:45:06 <stepcutHM> heh
14:45:32 <stepcutHM> I think there might also be some parsing libraries based on arrows...
14:45:52 <stepcutHM> that is, atleast, one of the uses that was proposed in the paper
14:46:07 <gzl> so I want to get the current system time so it can be inserted with an entry into a database (via Dbconnect). what's the best way of getting the date/time in the right format?
14:46:11 <johs> Anyone using lhs2TeX here?
14:46:25 <stepcutHM> johs: i used it once...
14:46:43 <johs> With the --tt-option?
14:47:29 <KrispyKringle> gzl: can't you just have the database use the "now()" function? :P
14:47:39 <stepcutHM> johs: um, I may have
14:47:43 <gzl> oh, good idea.
14:47:50 <KrispyKringle> are you writing the queries themselves? no need to do anything else. just do "INSERT into FOO...time=now()"
14:47:59 <gzl> yeah.
14:47:59 <gzl> ok.
14:48:17 * stepcutHM intends to rewrite haskelldb this summer...
14:48:23 <gzl> you wrote haskelldb?
14:48:26 <stepcutHM> no
14:48:28 <gzl> oh.
14:48:34 <stepcutHM> but that doesn't mean I can't rewrite it :)
14:48:36 <KrispyKringle> try not to sound so disappointed, gzl
14:48:38 <KrispyKringle> ;)
14:48:39 <gzl> of course.
14:48:49 <gzl> why would I be disappointed
14:48:52 <stepcutHM> I have studied the code enough to know how broken it is ;)
14:49:05 <johs> stepcutHM: It mostly works, but for "<-" it inserts "\in"-symbols.
14:49:09 <johs> (Epsilon?)
14:49:54 <stepcutHM> johs: haskelldb ?
14:50:09 <johs> No, lhs2TeX.
14:50:25 <stepcutHM> sorry, short attention span
14:50:33 <johs> Maybe there's just something wrong with the font I'm using.
14:50:53 <stepcutHM> yes, I think I had issues with tt not being able to show fancy symbols correctly
14:51:09 <stepcutHM> I think there is only one mode of lhs2TeX that works correctly...
14:51:29 <gzl> oh
14:51:40 <gzl> maybe it's not being smart enough about the difference between <- in list comprehensions and do blocks?
14:52:21 <stepcutHM> dunno
14:52:35 <stepcutHM> it's been a long time since I used it, and I only used it once
14:52:57 <gzl> yeah, same
14:57:04 <johs> Hm, I guess that makes sense.
14:57:24 <gzl> yeah, because \in would make sense for list comprehensions.
14:57:42 <johs> Would have made sense, I mean.
14:57:46 <gzl> yeah.
14:57:54 <johs> But in poly-mode, they're both left-arrows.
14:58:21 <johs> So I don't think so.
15:27:32 <kosmikus> johs: %format <- = "\char''30"
15:28:41 <kosmikus> it's a sub-optimal default formatting, and it's there because of list comprehensions
15:50:20 <johs> kosmikus: Ah, thanks.
15:50:54 <johs> kosmikus: You're the lhs2TeX-developer?
15:51:40 <johs> (I don't have any more naggin to do.  It looks great now.)
15:51:43 <johs> "nagging"
16:54:59 <chr1s> hey, anyone experience with building wxhaskell?
17:02:38 <multi_io> does Haskell automatically define selectors for "data" type definitions?
17:04:26 <Cale> multi_io: with record syntax it does
17:06:08 <multi_io> Cale: ah
17:06:23 <blackdog> yaarg: no, but i wish i was. i'm a webmonkey now, and the boss is unlikely to pay to send me to an FP conference. :)
17:11:11 <chr1s> no one used wxhaskell ?
17:11:26 <Cale> I've used wxHaskell a bit
17:11:35 <Cale> you had a question?
17:11:35 <chr1s> did you compile it by hand?
17:11:41 <chr1s> I mean
17:11:46 <Cale> no, I just installed packages
17:11:48 <chr1s> build it from source?
17:11:49 <chr1s> hm
17:11:54 <chr1s> which distro?
17:12:01 <Cale> debian
17:12:04 <chr1s> hm
17:12:08 <chr1s> I'm running debian too
17:12:15 <chr1s> but I can't get the packages to install
17:13:12 <chr1s> I get this error: ldconfig: Can't link /usr/lib//usr/lib/libwxc-gtk2.4.2-0.8.so to libwxc-gtk2.4.2-0.8.so
17:13:46 <Cale> hmm
17:14:01 <chr1s> I don't have any clue how to solve it
17:14:16 <TheHunter> that's normal. But it doesn't do any harm other than annoy.
17:14:43 <chr1s> ok, so now my wxwidgets should work? becaus dkpg -i blah stops there.
17:15:32 <chr1s> and when I try to run this program I need to do for school I get the following error
17:15:44 <TheHunter> well try it. It worked with ghc-6.2.2
17:15:53 <chr1s> Failed to load interface for `Graphics.UI.WX':
17:16:09 <chr1s>  Could not find interface file for `Graphics.UI.WX'
17:16:19 <TheHunter> you need -package wx, maybe -package wxcore
17:16:41 <chr1s> what does that -package stand for?
17:17:10 <TheHunter> it's a command line option to ghc. it includes a package.
17:17:13 <multi_io> is there a way to check at runtime whether a given value was constructed using a specific constructor, and if so, extract its "sub-values"?
17:17:26 <multi_io> (short of defining a functions and using pattern matching)
17:18:25 <wilx> GADT?
17:18:30 <wilx> Dunno what you want.
17:18:48 <chr1s> hm, it doesn't find a wx package
17:20:08 <chr1s> and ghc-pkg -l doens't show any wx-package
17:20:19 <chr1s> s/ns/sn
17:20:29 <TheHunter> $ dpkg-reconfigure libghc6-wxhaskell-dev
17:20:30 <TheHunter> /var/lib/dpkg/info/libghc6-wxhaskell-dev.prerm: 3: /bin/ghc-pkg: not found
17:20:30 <TheHunter> /var/lib/dpkg/info/libghc6-wxhaskell-dev.postinst: 3: /bin/ghc-pkg: not found
17:20:57 <TheHunter> the package apperantly assumes that ghc-pkg is in /bin. I have no idea why.
17:21:02 <dons> multi_io, pattern matching is how you take apart data structures by inspecting constructors. it's the only way.
17:21:08 <dons> try case.
17:22:17 <dons> morning TheHunter
17:22:23 <multi_io> dons: thanks, case seems to do what I want
17:22:33 <TheHunter> morning dons.
17:23:40 <mwc> Quick, Linus is dropping BitKeeper! Start spamming the /. story with Darcs prosylitizing
17:25:13 <chr1s> TheHunter: do you no anything that could help?
17:25:29 <chr1s> s/no/know .
17:27:18 <TheHunter> hmm, i managed to register wxcore.
17:28:20 <TheHunter> it unfortunately still needs wx.
17:28:47 <mwc> TheHunter, are you trying to get wxHaskell working with Cabal/GHC6.4?
17:29:14 <chr1s`mrtypo> I'm running GHC6.2 btw
17:29:16 <TheHunter> no, the debian package for 6.2.2.
17:33:27 <TheHunter> chr1s`mrtypo, i guess you should try ghc6.4 and cabal. That's supposed to be easy.
17:33:48 <chr1s`mrtypo> ok...
17:34:11 <chr1s`mrtypo> I'm going to try to find out how to install that :) I'm quite new to debian :)
17:34:36 <chr1s`mrtypo> what does cabal stand for?
17:35:02 <chr1s`mrtypo> oh, nevermind.
17:35:24 <chr1s`mrtypo> I have to use wxwidgets for an assignment for school.
17:35:53 <mwc> chr1s`mrtypo, cabal is the new package system for haskell that GHC 6.4 uses
17:36:13 <mwc> I'm having some trouble getting wxHaskell to work wtih it but I haven't really dug into it'
17:36:22 <mwc> I probably just need to write port files
17:36:23 <SamB> mwc: BitKeeper was dropping Linus, last I heard...
17:36:31 <chr1s`mrtypo> oh, I thought it was a wxwidgets replacement ore something...have to learn to read
17:36:51 <chr1s`mrtypo> But I'll try GHC6
17:37:04 <mwc> SamB, BK stopped supporting a free BK client
17:37:13 <mwc> so then linux is dumping BK out of spite
17:38:09 <TheHunter> hmm, has wxhaskell even been cabalized?
17:38:15 <mwc> No, not at all
17:38:35 <chr1s`mrtypo> TheHunter: is it better to apt-get remove ghc6 first or can I just dpkg -i the new package?
17:38:36 <mwc> I'll have a go at it when I have some time to read the docs
17:39:28 <chr1s`mrtypo> Oh, it hasn't been cabalized.
17:40:26 <mwc> A wizard could probably do it in about 10 minutes but I'd have to start from square one so don't hold your breath on my acocunt
17:40:50 <chr1s`mrtypo> Do you guys know what that means? It means I should actually get out of my room, away from my boxes, to go to the university. with people and stuff. like omg.
17:41:06 <TheHunter> chr1s`mrtypo, i got it working.
17:41:12 <chr1s`mrtypo> phew.
17:41:17 <chr1s`mrtypo> how?
17:41:23 <TheHunter> wxhlibdir=/usr/lib ghc-pkg -ai /usr/lib/wx.pkg
17:41:41 <TheHunter> wxhlibdir=/usr/lib ghc-pkg -ai /usr/lib/wxcore.pkg
17:42:20 <TheHunter> now you should be able to run your program with ghci -package wx foo.hs
17:42:36 <chr1s`mrtypo> nice :) but the best thing is, I don't have a /usr/lib/wx.pkg
17:43:04 <TheHunter> do you have libghc6-wxhaskell-dev installed?
17:43:26 <chr1s`mrtypo> I'll reinstall it.
17:45:34 <TheHunter> @set-fuel 10000000000
17:45:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- can't set fuel above 500000
17:46:21 <dons> cool.
17:46:21 <wilx> @hepl set-fuel
17:46:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "hepl", try "lambdabot: @listcommands"
17:46:26 <wilx> @help set-fuel
17:46:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @set-fuel ticks - how many ticks before @eval runs out of fuel
17:46:32 <wilx> Heh.
17:46:33 <wilx> Nice.
17:46:46 <SamB> Sat Apr  9 14:51:11 EDT 2005  Thomas Jger <TheHunter2000@web.de>
17:46:46 <SamB>   * limit the @eval's fuel, disconnect signals upon unloading of modules.
17:47:15 <dons> SamB, any ideas on how to deal with .ghci without the configure issues?/
17:47:28 <TheHunter> well, actually 500000 is still quite much.
17:48:58 <SamB> dons: hmm...
17:49:55 <TheHunter> is it just my installation, or does lambdabot not compile on 6.4 anymore?
17:50:01 <dons> !
17:50:21 <dons> how so?/
17:51:27 <TheHunter> ok, 6.4 was a lie.
17:51:29 <TheHunter> Rebuilding dependencies ... ghc-6.5.20050324: Can't find Modules.hs-boot
17:51:31 <TheHunter>   (imported from DynamicModule.hs)
17:51:57 <SamB> where does Modules.hs come from?
17:52:13 <TheHunter> GenModules.hs generates it.
17:52:15 <dons> paprika$ ls Modules.*
17:52:16 <dons> Modules.hi-boot  Modules.hs       Modules.hs-boot  Modules.o-boot
17:52:36 <SamB> okay, so GenModules must have genned a bad one on me...
17:52:40 <dons> not quite.     @echo $(MODULE_HI_BOOT) > Modules.$(RECURSIVE_MODULE_SUFFIX)
17:52:56 <gzl> what's wrong with the following code using Dbconnect/WASH? it just gives me a 500 error when I try to load the cgi
17:53:00 <gzl> http://rafb.net/paste/results/G9onYl82.html
17:53:05 <dons> TheHunter, but we've got some bad ifeqs: eq "$(GLASGOW_HASKELL)" "604"
17:53:16 <TheHunter> ah, ok.
17:53:18 <dons> should be >=
17:53:32 <gzl> trying to do something fairly trivial here
17:53:56 <dons> just in config.mk and Makefile. The cpp tests should be fine - it's the make tests that are wrong.
17:54:09 <TheHunter> i see.
17:55:01 <SamB> dons: is there a problem with running `make ghci-flags' whenever someone starts ghci?
17:55:44 <SamB> might something more along the lines of `make -f ghci-flags.mk' be better?
17:56:41 <dons> possibly. try it out. it's the .ghci file causing trouble, so any way around that is fine. I'd prefer not to add a new .mk file if the input to ghci could be put in a variable instead
17:56:51 <chr1s`mrtypo> TheHunter: thanks, it seems to work
17:57:08 <dons> GHCI_GOO="blah blah" ; echo $(GHCI_GOO) | ghci $(HC_OPTS) Main.hs
17:57:09 <SamB> dons: what sort of trouble? people already have their own .ghci files?
17:57:14 <chr1s`mrtypo> although I'm not sure yet how to get the app to work. At least I don't get weird fault messages anymore :)
17:57:17 <dons> no. did you see my mail?
17:57:40 <SamB> no. I shall look.
17:58:03 <dons> ghci is invoked in ./configure to test a couple of values, __GLASGOW_HASKELL__ in particular. with the .ghci in your patch, these tests fail.
17:58:16 <chr1s`mrtypo> whoow! it works! thanks a lot!
17:58:25 <SamB> dons: oh, I see
17:58:46 <TheHunter> dons, so how do I write if>= $(foo) $(bar) properly?
17:58:54 <SamB> dons: It would be easy enough to make it check for the presence of the file...
17:59:05 * TheHunter feels stupid for asking such a question.
17:59:17 <dons> not sure. info make doesn't seem to tell us.
17:59:40 <dons> SamB, but I'd have to hide it from ghci.  I'd prefer to not have interactions like that
18:00:42 <SamB> hmm, my mozilla does not appear to like gmail (or vice versa)
18:02:06 <hellish> SamB: my firefox does. Do you have javascript disabled or something?
18:02:19 <SamB> we could rename it to .ghci.in and have ./configure generate .ghci from that... (removing it at the begining of the ./configure run if necessary)
18:02:29 <gzl> TheHunter: happen to have any ideas about my db issue?
18:03:13 <TheHunter> gzl, sorry i don't know wash.
18:03:23 <gzl> ok, np
18:03:59 <dons> SamB, what's wrong with providing a 'ghci' target in the Makefile: ghci:\n$(GHCI) $(HC_OPTS) $(PKG_FLAGS) ?
18:04:15 <dons> (another point is that this +:set -package posix
18:04:19 <dons> isn't 6.4
18:05:00 <dons> I just think this ghci stuff is trickier than it has to be.
18:06:09 <dons> TheHunter, the ./configure script could write the appropriate values into config.mk
18:06:57 <dons> for PKG_OPTS, RECURSIVE_MODULE_SUFFIX, MODULE_HI_BOOT.
18:09:41 <dons> hmm. maybe the tests could just become ifneq 602
18:10:07 <TheHunter> why doesn't this work? ifeq "`test $(GLASGOW_HASKELL) -ge 604 && echo yes`" "yes"
18:10:14 * Heffalump was about to play around with GADTs then realised that I don't have ghc 6.4 installed and can't install it if I want to also build .debs for sid on the same machine. Oops.
18:10:30 <stepcut> Heffalump: chroot!
18:10:38 <stepcut> hold on...
18:10:41 <Heffalump> no disk space
18:10:48 <dons> TheHunter, does it work?
18:10:57 <stepcut> Heffalump: hrm...
18:11:04 <dons> not sure you can use `` in a make conditional
18:11:05 <stepcut> Heffalump: delete some of those duran duran mp3s
18:11:07 <TheHunter> it appears not, but i don't even know how to test it.
18:11:39 <dons> is there any problem with reversing the tests, since there's only 1 "602" to support.
18:12:31 <TheHunter> i guess if lambdabot doesn't run on 6.0 anymore, it's ok.
18:13:05 <TheHunter> well, we don't really need to care about 600, do we?
18:13:14 <dons> I don't see why it wouldn't. but we don't really care, do we?
18:13:31 <dons> 6.2.2 was the a very stable, portable version.
18:15:31 <TheHunter> ok, lambdabot of course compiles fine with neq 602.
18:16:12 <dons> ok. I'll commit a patch in a minute
18:17:49 <TheHunter> but still, what were they smoking? including == but no >=. It's not that uncommon a task.
18:18:18 <dons> weird. i guess it's a singly-typed language: just strings.
18:18:49 <dons> did I just say "typed" when referring to GNU make??
18:19:03 <TheHunter> hehe
18:19:11 <TheHunter> anyway, gotta go to bed.
18:19:24 <dons> anyone who wants to come to unsw and work on haskell make, there's a thesis available ;)
18:56:41 * dons cranks up the coffee
19:01:41 <blackdog_> dons: working on .. ?
19:03:03 <dons> more 3161 assignment spec/code
19:21:53 <Lemmih> @seen SyntaxNinja
19:21:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen SyntaxNinja
19:25:16 <SamB> dons: where is ghci called by configure?
19:25:43 <wagle> Lemmih: I see him logging off almost 6 hours ago..
19:27:19 <dons> SamB: GLASGOW_HASKELL=`echo 'main' | "$WithGhc" --interactive -v0 -cpp t.hs`
19:27:46 <SamB> oh, no wonder I couldn't find it grepping for ghci
19:34:34 <dons> looks ok, SamB. thanks.
19:34:55 <SamB> nice.
19:42:41 <wagle> hmm..
19:42:52 * wagle dreams of "semantic grep"
19:44:57 <SamB> hmm, I've another patch now, but it depends on the latter of those two... it replaces the "echo 'main' |" with "-e main"...
19:46:05 <wagle> question: what did "natural programmers" do before there were computers?
19:47:04 <SamB> something else they were good at?
19:47:53 <wagle> you arent an intuitionist, i see
19:47:59 <wagle> 8)
19:48:19 <SamB> wagle: what is that supposed to mean?
19:48:28 <blackdog_> programming is just clear and structured thought, surely... that's useful almost everywhere
19:49:15 <wagle> intuitionism rejects existance proofs.
19:49:45 <SamB> what did any of that have to do with proofs?
19:50:05 <wagle> i did have a smiley?
19:50:34 <SamB> I still don't get it, joke or not ;-)
19:50:58 <wagle> i was hoping for examples, since the fact that such people existed and did _something_ is obvious
19:51:22 <wagle> i'm just blanking on what that something might be
19:52:01 <SamB> well, what are some of the other things that natural programmers do *now* that don't require a computer?
19:57:33 * SamB wonders how long it will take him to have used 1 MB of his gmail space, and how big it will be by then
20:00:33 <araujo> some pics of the eclipse we had here yesterday: http://www.es.gnu.org/~araujo/pictures/
20:03:44 <desrt> how's your camera doing?
20:04:53 <wagle> if you had gotten the right tree, ie one that let points of sunlight through, you could have photographed all the little eclipses...
20:04:53 <araujo> doing well, though i didn't have special lens, i used a special paper in front of it
20:06:22 <araujo> wagle, that is a tree in another house
20:06:22 <wagle> araujo: cool
20:06:49 <araujo> i actually had to evade several trees
20:06:57 <araujo> but wind didn't help also
20:07:16 <wagle> the specks of sunlight that shine on the ground all turn into little eclipses
20:08:33 <araujo> i didn't notice any.. i really wasn't in a good place
20:11:06 <wagle> ooo..  much nicer when reduced in size to fit on the screen..
20:11:24 <araujo> yeah, a little bit nicer
20:15:09 <wagle> the paper filter doesnt work well with 2 and 3, but the first is pretty cool
20:16:11 <araujo> 8)
20:16:23 <araujo> And those were my best shots
20:17:12 <araujo> After that, a bunch of clouds hidden the scene and i couldn't get any better
20:28:40 <yaarg> who msged me?
20:28:55 <yaarg> oh blackdog
20:42:11 <dons> I think in the future haskell programmers will have typecheckers embedded in their brains, along with brain modules encoding language semantics, all of which will float in vats of nutrients.
20:42:37 <yaarg> if they don't explode first
20:42:38 <autrijus> I think in the future, only haskel programs can be haskell programmers.
20:42:50 <yaarg> rofl
20:42:51 <dons> yes. autrijus is right.
20:42:59 <dons> you're brain must typecheck before you can start.
20:43:06 <dons> your.
20:43:16 <dons> I'd like all my thoughts to typecheck
20:43:25 <dons> crashing at runtime sucks
20:43:39 <yaarg> on that note
20:43:43 * yaarg crashs
20:43:53 <yaarg> (into bed)
20:43:53 <yaarg> nn
20:46:59 <SamB> umm... uh... brains only *have* runtime...
20:47:28 <wagle> the schemers will be banned for thinking thoughts about programs that cant be proven type safe, yet are
20:48:31 <SamB> If my program always typechecked, I would never have a program.
20:48:41 <SamB> It would just be an empty file.
20:49:02 <dons> I don't know about your brain, but mine is more like an interpreter, thoughts are compiled without my knowledge, then dumped on the runtime.
20:49:12 <dons> they appear magically in my runtime.
20:49:19 <dons> but they got compiled previously.
20:50:08 <dons> anyway, typechecking is more like 'ok, that makes sense', or 'no, that's stupid'
20:50:22 <dons> then it gets dynamically linked into the rest of the brain code.
20:50:31 <blackdog> dons: go outside.
20:50:36 <dons> blah!
20:50:41 <dons> too much assignment prep.
20:50:42 <SamB> I don't think most of my thoughts are distinct enough to be parsed, let alone typechecked...
20:51:02 * dons goes outside to see if the sun is still there.
20:51:16 <wagle> haskell typechecking is more like "i'm positive that this is correct, so i'll close my eyes when i run it"
20:51:17 <blackdog> it's falling into the sea, but you have time for one more compile
20:51:58 <wagle> anyone see the tv show "Firefly"?
20:52:05 <blackdog> yep
20:53:18 <wagle> remember the scene where the sister of the doctor peeks at the locations of the badguys, then pops out with her eyes closes, and rapidly shoots them all?  thats haskell typechecking
20:53:49 <wagle> if they'd moved, then, umm..
20:53:51 <dons> unless you use Typeable ;)
20:54:24 <dons> they're out there, and as long as they don't move too far, i'll check when I get there, otherwise I'll give up
20:54:35 <dons> and get shot myself
20:55:30 <wagle> if something else mangles a haskell program's datastructures, it wont notice, since it typechecks at compile time
20:55:54 <dons> yep. I agree with this metaphor.
20:56:27 <SamB> but nothing else would be fool enough to *touch* haskell heap *on purpose*...
20:56:35 <dons> though 'won't notice' could be equivalent to "sudden death"
20:56:53 * wagle twirls his handlebar mustache
20:57:43 <wagle> or "make the haskell program do anything I want"
20:58:25 <SamB> wagle: well, not by exploiting the Haskell...
20:58:58 <wagle> lots of code compiled from C running around in the same address space
20:59:03 <dons> you can write Haskell that modifies it's own heap, without the ffi even.
20:59:05 <SamB> it would be hard to make anything of the resulting assembly...
20:59:47 <wagle> overrun attacks attack the datastructures of _other_ code, not necesarily the code that permits the overrun
21:00:06 <dons> usually ;)
21:00:44 <wagle> all the type safety in the world wont protect you from having your datastructures overrun by someone elses code
21:01:02 <SamB> wagle: true. but how many different installations of a given program even have the same heap layout?
21:01:24 <wagle> SamB: i dont understand the question
21:01:47 <blackdog> you can't reliably subvert a system that way if you don't know the heap layout..
21:02:21 <wagle> dont need to be 100% reliable..  can keep trying until you succeed.
21:02:50 <wagle> and if you attack 1 million systems, getting 10000 of them might be ok
21:02:51 <SamB> wagle: nope. the program would have crashed the first time you tried it.
21:03:20 <wagle> SamB: programs dont necessarily crash
21:03:53 <SamB> are there a million systems running compiled haskell programs?
21:04:19 <wagle> SamB: someday..  beats a million systems running compiled C programs
21:04:58 <SamB> wagle: you would prefer interpereted C programs?
21:04:58 <SamB> perhaps with JIT?
21:06:37 <wagle> i've done a number of modifications to GCC and recompiled various redhat distributions with it
21:07:36 <wagle> that makes it harder to cause an overrun, but hardly makes it impossible
21:08:40 <wagle> actually, i detect overruns, i didnt prevent them
21:08:51 <wagle> actually, i detected overruns, i didnt prevent them
21:10:14 <wagle> the code detecting whether or not its datastructures have been overrun is completely unrelated to the code doing the overrun, except that they share memory
21:10:26 <wagle> you could get dma to overrun memory
21:11:48 <wagle> you could hold a 150 watt light bulb up to a memory chip and flip bits
21:12:57 <wagle> Using Memory Errors to Attack a Virtual Machine by Sudhakar Govindavajhala and Andrew W. Appel, 2003 IEEE Symposium on Security and Privacy, pp. 154-165, May 2003.
21:15:23 <wagle> self-stabilizing algorithms will eventually end up in valid states aqfter starting from ANY unacceptable state
21:16:07 <SamB> what if the unacceptable state had scrambled the algorithm itself?
21:16:24 <wagle> i wonder if type systems can direct a program to be self-stabilizing, or accept only self-stabilizing
21:16:56 <SamB> (or, more precisely, the code implementing the algorithm)
21:18:54 <wagle> state of the art a couple years ago appears to be that only data is considered to be corruptable..  handling the corruption of programs is "too hard"
21:20:19 <wagle> unfortunately, the stack contains a lot of control information, and I hold that code pointers are program, not data..
21:20:32 <wagle> and code pointers are mutable
21:21:07 <wagle> i doubt the algorithms handle corrupted code pointers, corrupted frame pointers, etc.
21:22:04 <wagle> corrupting program text is even harder to handle, but i can probably stick to mutable control structures
21:23:01 <wagle> sorry, i've been thinking about this in terms of C and GCC, and not so much about haskell's possible roles
21:23:34 <wagle> ("sorry", because I'm jumping around)
21:24:49 <wagle> ah..  heres the book I'm starting: http://www.amazon.com/exec/obidos/tg/detail/-/0262041782/qid=1113107119/sr=1-1/ref=sr_1_1/104-1620051-1126362?v=glance&s=books
21:27:08 <wagle> i'm most interested in code (instruction stream) repairing itself, but thats a bit large
21:28:02 <wagle> and Jay Lala was promoting going beyond mere repair to improvement
21:28:37 <wagle> i havent seen anyone run with that, but i havent looked hard enough
21:57:45 <blackdog> come back, gour, we can change...
22:56:23 <dons> @yow
22:56:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
22:56:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- my viewscreen is "USER-FRIENDLY"!!
23:24:33 <autrijus> say, I have a list and a int, and I'd like to write
23:24:40 <autrijus> length list `compare` int
23:24:45 <autrijus> except the list may be infinite
23:24:48 <autrijus> is there an idiom for this?
23:25:22 <skew> do you need the full ordering from compare?
23:25:33 <autrijus> I need GT and LT
23:25:39 <skew> maybe take int list == [] would be useful
23:26:06 <autrijus> null $ drop int list
23:26:08 <autrijus> you mean that?
23:26:13 <autrijus> and test drop int+1 too
23:26:27 <skew> length (take (int+1) list) `compare` int
23:26:33 <skew> that should do it
23:26:39 <autrijus> ah. right. thanks!
23:26:47 <skew> It would all work out very nicely if Int were Zero | Succ Int :)
23:26:56 <autrijus> indeed, wouldn't that be nice
23:28:01 <skew> actually, length (take (int+1) list) is hopefully not too inefficient either
23:43:50 <gzl> if I want to write a string that's kind of long, should I use a bunch of ++ or is there a better way?
23:44:30 <skew> gzl: ++ isn't bad as long as the left side is always something short
23:44:35 * _gour is away: busy atm
23:44:49 <gzl> ok.
23:45:01 <gzl> it's only two lines, that's not too bad.
23:45:11 <skew> oh, don't worry if it's that small
23:45:54 <skew> it's just that ++ takes time proportional to the length of the left argument, so it's bad for adding text to the end of 100K strings
23:46:22 <gzl> ah, right. no, this is quite short
23:46:39 <skew> autrijus: darn, looks like that does end up calling take
23:46:53 <skew> I was hoping inlining would eliminate the intermediate list
23:47:06 <autrijus> oh well.
23:47:32 <autrijus> data Int where { Zero :: Int ; Succ :: Int -> Int }
23:47:42 <skew> I think there are better place to look for speed if that length check is too slow, anyawy
23:48:01 <Cale> autrijus: you mean Nat :)
23:48:24 <autrijus> Pred :: Int -> Int :)
23:49:22 <skew> Why did you choose that synatx?
23:49:57 <autrijus> because it's more readable to me.
23:50:25 <skew> I guessed that would be it
23:50:57 <autrijus> I've never understood the idea of "data Foo = Foo Foo Foo" anyway.
23:51:13 <skew> It looks a bit odd to me because it's from a very fancy new extension
23:51:15 <autrijus> "data Foo where Foo :: Foo -> Foo -> Foo" at least makes some sense.
23:51:55 <skew> Giving constructors and types the same name is a bit odd, but I like the rest of the syntax because it brings out the algebra
23:52:03 <autrijus> right.
23:52:13 <autrijus> GADT++
23:52:45 <skew> Have you read e.g. "Comonadic Recursion Schemes"?
23:53:03 <autrijus> skimmed a bit.
23:53:36 <skew> data types as initial algebras makes a lot of sense to me
23:53:46 <autrijus> yup.
23:56:02 <skew> It would be useful if there were an easy way to get at the base functor of a recursive data tyle
23:56:45 <skew> How is work on pugs going?
23:57:59 <autrijus> 6.2.0, our 1st milestone, is due tomorrow
23:58:09 <autrijus> I'm in last-hour rush to get type classes in
