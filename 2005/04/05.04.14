00:00:16 <mwc> skew, no, just read more on concurrency and would like to tear down a real app and build it back up again
00:00:53 <skew> I think you should see if the threading will wor
00:01:15 <skew> If the threading will work for you before you do too much.
00:01:17 <mwc> From what I've read of concurrent haskell I think it will
00:01:36 <mwc> But you're right, I ought to test it
00:01:44 <skew> unless everything has to live on the same processor for some reason
00:01:44 <mwc> Something not to do at 3 AM :(
00:01:59 <mwc> that would be an OS limitation I would think
00:03:00 <skew> I could imagine the haskell runtime being unable to handle C calling back into its hooks from a different processor.
00:03:21 <mwc> probably
00:03:42 <mwc> What I'm envisioning is mostly stuff like matrix processing code writting in C
00:04:04 <mwc> So it would be a C function that does the compute as requested
00:04:44 <skew> Yeah, I guess Haskell implementors wouldn't set up some kind of processor affinity just to avoid something like that
00:06:14 <mwc> Yeah, so I'm trying to find a good real world app in Haskell to tear apart and rebuild
00:06:30 <mwc> I was thinking Darcs probably does too much pure text processing to really teach me something
00:07:34 <skew> webserving wouldn't require making actual OS threads at all. It's probably a pretty good example of how to do concurrency in Haskell, if that's what you are looking for
00:07:40 <skew> be sure to check out STM too
00:07:44 <mwc> STM?
00:07:57 <skew> the new concurrency stuff
00:08:01 <mwc> Ah
00:08:50 <mwc> skew, you in Europe or Cali?
00:09:08 <skew> california
00:09:15 <mwc> Heh, so it's only midnight there
00:09:32 <skew> though I often greet all the Europeans as they join, leave for coffee, etc.
00:09:38 <skew> go to lunch
00:09:49 <mwc> night hawk?
00:09:58 <mwc> It's 9 am there, they ought to be hard at work :P
00:10:15 <skew> my schedule varies
00:11:10 * Oejet is hard at work on $Â£@#! Java and Ant.
00:11:33 <mwc> Ugh, I never liked Java
00:11:54 <mwc> it takes all the bonehead mistakes of C++, covers the useful bits in bubble wrap, and tells you it's for your good :P
00:12:50 <skew> I suppose it did serve to advance editor enviroments, by being absolutely impossible to type in, edit, or navigate without massive tool support
00:13:00 <mwc> skew, heheeh
00:13:02 <mwc> that's about it
00:13:05 <Oejet> skew: Right on.
00:13:21 <skew> Oejet: could you check out Aardappel sometime?
00:13:27 <mwc> "Overloading is absolutely horrible and should never be used." + " Except by us, because we know better than you."
00:15:23 <mwc> I mean, if you want to make abusive code, that won't stop you
00:15:23 <skew> It's a wierd language designed by Wouter van Oortmerssen, also known as Aardappel, and implemented in Java
00:15:41 <mwc> ie: Add(x, y) { x * y }
00:15:45 <mwc> skew, oh? What class?
00:16:02 <skew> but bits of it don't quite seem to work
00:16:13 <skew> mwc: class?
00:16:28 <mwc> functional, object, stack-orientated
00:16:36 <mwc> you said it was wierd
00:16:43 <skew> concurrent tree-rewriting
00:16:50 <mwc> EH?!
00:16:55 <skew> crossed with Linda tuple-spaces
00:16:56 <mwc> Like mathematica kind of?
00:17:20 <skew> I don't really know. It's a nice simple language
00:17:56 <skew> the reduction rules is eager, so labels sort of divide into function-like and data/object like
00:19:43 <skew> The concurrency part comes because you can put trees in bags together, and reduction rules can require consuming siblings from the bag, and produce multiple trees.
00:20:22 <skew> Like I said, it's a strange language
00:20:32 <skew> Cube is a similar thing for shooter engines
00:20:56 <skew> think DOOM based on a LOD/mipmapping terrain engine
00:21:09 <mwc> Hmm...
00:21:41 * mwc has been drawing analogues between Haskell and linear algebra all night and can't work geometry into it now
00:25:12 <mwc> Well, 0330h, time for bed
00:25:18 <mwc> adios, all
00:44:48 <jlouis> @version
00:44:49 <lambdabot> lambdabot 2p303, GHC 6.4 (OpenBSD i386)
00:44:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:45:52 <Oejet> Orv, no notice anymore.  Good because Gaim is not fixed yet.
00:47:37 <dons> yep. all because of gaim :}
00:49:23 <nlv11757_> MonadReader question, why is it, that in '    local f c = Reader $ \e -> runReader c (f e) ' you can suddenly refer to runReader?
00:49:25 <Oejet> #haskell > #java
00:49:54 <nlv11757_> "newtype Reader e a = Reader { runReader :: (e -> a) }"
00:52:38 <jlouis> Mmmm, now with fact module ;)
00:52:43 <jlouis> dons: nice changes, I like them
00:54:09 <nlv11757_> nevermind
00:54:11 <dons> just a bit of column alignment, and use of case wasn't it?
00:54:55 <jlouis> dons: correct. But I did not think about using case there to reduce the clutter
00:55:27 <dons> ok. it's often nice. and the code is desugared into a case anyway
00:57:13 <jlouis> dons: exactly. I tend to use that a lot when coding SML
00:58:17 <nlv11757_> @type liftM
00:58:19 <lambdabot> bzzt
00:59:24 <dons> @type Control.Monad.liftM
00:59:26 <lambdabot> Control.Monad.liftM :: forall r (m :: * -> *) a1.
00:59:26 <lambdabot>                        (Monad m) =>
00:59:26 <lambdabot>                        (a1 -> r) -> m a1 -> m r
01:01:25 * dons looks at edit-distance implementations in a variety of languages and concludes that they all have ugly syntax
01:02:58 <dons> anyone know what this does in Erlang: lists:seq(0, length(Target)), 1). ?
01:04:32 <dons> actually, just: lists:seq(0, length(Target))
01:04:41 <dons> is that [0.. length t] by chance?
01:06:47 * earthy would guess so
01:11:54 <pesco> Good morning, #haskell...
01:12:01 * pesco blinks sleepily
01:19:02 <pesco> Oh my god.
01:19:07 <pesco> They're all dead...
01:19:12 <Lunar^> pesco: alive!!
01:19:24 * pesco screams in terror.
01:19:28 <pesco> It's alive!
01:19:43 <pesco> Ah, huh. It's you.
01:19:47 <Lunar^> :)
01:19:48 * pesco shakes Lunar^'s hand.
01:20:10 <pesco> What's up?
01:20:29 <Lunar^> pesco: I'm still late in HFuse release
01:20:38 <Lunar^> s/in/for/
01:20:47 <Lunar^> university takes time, in fattct
01:20:50 <Lunar^> fact
01:21:01 <pesco> HStupid thing,yeah. ;)
01:21:20 * Lunar^ is alive but still asleep in fact
01:21:54 <pesco> libHStupid-1.0.a
01:22:06 * pesco is struggling with his keyboard.
01:23:53 <pesco> Ugh, "a hello world filesystem is less than 100 lines long"?
01:24:45 <pesco> I hope not in Haskell! I can _conquer_ the world in 100 lines of Haskell. ;)
01:24:59 <Oejet> Is there any Hello World * which is more that 100 lines?
01:34:47 <nlv11757_> how does >>= associate?
01:36:00 <df_> infixl 1
01:39:15 <a5> is there a "a -> (a -> b) -> b" in the prelude?
01:40:14 <integral> flip $, a5?
01:40:46 <a5> yeah
01:40:56 <df_> Oejet :: have a look at the gnu hello world app?
01:47:22 <Oejet> df_: ]wc src/hello.c
01:47:22 <Oejet>  368 1132 8308 src/hello.c
01:47:48 <df_> there you go.
01:58:09 <nlv11757_> what is more esthetical correct; "mapM pGlobal globs >>= return . vlist" or "do { ppglobs <- pGlobal globs ;  return $ vlist ppglobs}"
02:02:06 <Lemmih> fmap vlist (mapM pGlobal globs)
02:02:42 <Lemmih> nibro: Greetings. Have you been able to get Cabal?
02:03:42 <nlv11757_> so typical for haskell people, you give them two options and they choose the third
02:03:44 <nlv11757_> :)
02:04:33 <pesco> Lemmih: What's up with the hackage running on scannedinavian?! It seems borken...
02:04:46 <Lemmih> It does?
02:05:29 <pesco> Inserting a new package doesn't work.
02:05:44 <Lemmih> [host].org/cgi-bin/hackage/hackage is pretty old. [host].org/~lemmih/cgi-bin/hackage/hackage is the way to go.
02:05:56 <pesco> oic
02:06:25 <pesco> I don't have access!
02:07:03 <Lemmih> Works fine for me...
02:07:20 <pesco> Oh wait, I'm an idiot, I asked for the cgi-bin dir listing.
02:08:16 <pesco> I get a 500 Internal Server Error on uploading my cabal file.
02:09:31 <pesco> Aha, but uploading the tgz works.
02:09:32 <Lemmih> That feature is actually gone. Just haven't had time to rebuild hackage.
02:09:41 <pesco> What feature?
02:09:48 <Lemmih> Uploading of .cabal files.
02:10:04 <shapr> Is it coming back?
02:10:10 <pesco> Then how should I make my cabal package public?!
02:10:11 <Lemmih> Nope.
02:10:14 <pesco> shapr: Hi!
02:10:21 <nibro> Lemmih: no, still no luck with that
02:10:22 <Lemmih> pesco: By uploading .tgz
02:10:30 <shapr> hiya pesco
02:11:00 <pesco> Ok... why did you remove it?
02:11:06 <Lemmih> pesco: pesco-cmdline-1.1 is now availble for download (:
02:11:16 <pesco> :) Yay
02:11:21 <pesco> I see.
02:11:23 <nibro> shapr: gotten in to work yet?
02:11:31 <Lemmih> pesco: SyntaxNinja told me to.
02:11:55 <pesco> Interesting. Did he say anything else? :)
02:12:05 <shapr> nibro: I got it all to build and install, but at this moment I'm preparing for Swedish class, be back in a coupla hours.
02:12:17 <pesco> Hm, I can't seem to finde my package via "View" or "Search"...
02:12:41 <nibro> shapr: :) Ha så trevligt på lektionen
02:12:43 <nlv11757_> shit, making my pretty printer using readermonad implies lifting all the operators from the pretty printing library
02:12:44 <nlv11757_> :S
02:13:28 <Lemmih> pesco: Yeah ): I've temporarily disabled the HTML interface.
02:13:41 <pesco> AAARGH.
02:14:12 <Lemmih> Hacking HTML is _so_ boring.
02:14:20 <Lemmih> But feel free to send patches (:
02:14:34 <pesco> Unfortunately, I don't have time.
02:14:40 <pesco> I shouldn't even be talking here.
02:15:54 <pesco> But hey, feel encouraged to take a peek at pesco-cmdline-1.1. It doesn't sport any new features but has some new text and uses Eternal Compatibility in Theory(TM) system for module versioning. ;-)
02:17:37 <pesco> I need to leave now. See you all.
02:17:54 <Lemmih> Bye.
02:19:32 <Lemmih> pesco: It doesn't have any build-depends?
02:20:43 <pesco> "Nothing special" I thought.
02:21:30 <Lemmih> It will probably fail when -fhide-packages hits the street.
02:22:12 <Lemmih> *-fhide-all-packages
02:22:34 <pesco> Well, which ones would you suggest I list there?
02:22:46 <Lemmih> base.
02:23:09 <Lemmih> The Prelude is in base.
02:23:11 <pesco> Why isn't that implicit?
02:23:31 <pesco> build-depends: base should be default.
02:23:40 <Lemmih> It's not always you wanna depend on base...
02:23:47 <pesco> Right, but it's the _default_.
02:24:21 <Lemmih> 'base', like many other packages, are not hidden by default.
02:24:49 <Lemmih> But that doesn't make it special. It's just a package like any other.
02:25:13 <pesco> Yes it is special, because it contains the Prelude, which is special by the Report.
02:25:41 <pesco> I'm not saying it should always be included, but I think it should be in build-depends by default.
02:26:01 <Lemmih> Prelude is special. 'base' is not (:
02:26:19 <pesco> base provides Prelude. I'd say that makes it equally special.
02:26:51 <pesco> Every user is going to stumble over this. You'll have to tell each one of them (in the docs) to remember to depend on base.
02:26:58 <pesco> Many will not notice.
02:27:20 <pesco> You might _just as well_ make build-depends: base the default.
02:27:31 <pesco> It doesn't hurt anyone but helps many.
02:27:52 <Lemmih> Forcing 'base' on people could annoy some.
02:28:26 <Lemmih> (if you don't actually use 'base', for example)
02:28:31 <pesco> And forcing everyone to list it explicitly _will_ annoy many and _is_ annoying one already. ;)
02:29:09 <Lemmih> Oh well, feel free to send patches if you want it changed d-:
02:29:28 <pesco> The unimaginally marginal minority who really doesn't even use the Prelude will know perfectly well what they're doing and, with a note in the right place of the docs, just explicitly leave base out of their build-depends.
02:30:03 <nlv11757_> if i do a 'import qualified Foo.Bar' i would have to refer to operator (>>-<<) with Foo.Bar.(>>-<<) right?
02:30:17 <pesco> No, (Foo.Bar.>>-<<)
02:30:27 <pesco> As far as I remember.
02:31:00 <pesco> OK, I'm gone this time. :)
02:31:24 <nlv11757_> thanks
02:31:26 <nlv11757_> bye
02:31:47 <pesco> Lemmih: I hope I've not sounded rude. Please consider my suggestion. ;-)
02:32:00 * pesco disappears in a puff of smoke.
02:34:44 <Lemmih> Will do. Using 'base' when nothing else is specified isn't a bad idea.
02:34:52 <nibro> nlv11757_,
02:34:56 <nibro> h
02:34:59 <nibro> gah :)
02:35:08 <nlv11757_> eeh?
02:35:32 <nibro> nlv11757_: in the places were you would write >>-<< you would have to write Foo.Bar.>>-<<
02:35:56 <nibro> and in the places where you write (>>-<<) you now have to write Foo.Bar.(>>-<<)
02:36:10 <nlv11757_> ok
02:36:37 <pesco> Lemmih: And that's just what I meant.
02:36:38 <nlv11757_> im doing it because im redefining every operator i use in module Foo.Bar, since im going to use the ReaderMonad and all these operators are non-monadic
02:36:39 * nibro moved his keybord, can't quite find the keys yet
02:36:42 * pesco 's voice drowns from another plane.
02:37:02 <pesco> drones?
02:37:04 <pesco> What's the word.
02:37:05 <pesco> Ah.
02:37:21 * pesco hides in a basket.
02:38:53 <nlv11757_> is there a smarter way btw, before i lift every operator in module Foo.Bar ?
02:39:35 <nlv11757_> Foo.Bar contains combinators for pretty printing, but i want to use the ReaderMonad in my pretty printer that uses module Foo.Bar
02:39:56 <skew> why do you need to lift the operators?
02:40:10 <nibro> nlv11757_: I assume you want to hide the lifts from the end user, then the answer is no. You need to lift them all.
02:40:28 <skew> are the operators already in some other monad?
02:42:07 <nlv11757_> no they are not monadic whatsoever i think
02:42:11 <nlv11757_> let me check
02:42:40 <nlv11757_> nope, these combinators are 'just' functions
02:43:08 <skew> Then I would think (with no context) that there is as little need to lift them in your code as there is need to lift (+).
02:43:26 <skew> Or is the idea that you are building a new pretty-printing library based on the other one
02:44:12 <skew> and your pretty type is somthing like  MyPrettyPrinterMonad (OldPrettyPrinterType)
02:44:26 <skew> ... pretty *printer* type ...
02:44:40 <nlv11757_> noj, i have made a pretty printer using this pretty printer library (which is non-monadic), BUT i dont want my function to return PP anymore, but 'Reader Env PP'
02:44:45 <nlv11757_> noj=no
02:45:29 <nlv11757_> so every call to a pretty printer function of my own suddenly dont return PP anymore, so i cant just use the combinators from the library to combine these function calls
02:45:42 <nlv11757_> so i thought....if i just lift all the combinators....i'd be home free
02:46:03 <skew> okay, so you want the combinators to be nice for putting together your new pretty printers
02:46:09 <nlv11757_> yeah
02:46:23 <skew> and using liftM is too much work?
02:46:36 <Itkovian> Hi all
02:46:49 <skew> Hi all
02:46:51 <skew> @seen all
02:46:52 <lambdabot> I haven't seen all
02:46:59 <nlv11757_> well, consider this; pp_foo >|< " = " >#< pp_dude >-< "etc."
02:47:18 <nlv11757_> its not nice to embed the liftM everywhere here (or liftM2)
02:47:19 <a5> what's 'r' for here? runCont :: Cont r a -> (a -> r) -> r
02:47:36 <skew> a5: the r type has to come from somewhere
02:47:55 <a5> but it could just be Cont a -> a
02:48:02 <a5> right?
02:48:12 <skew> I suppose so
02:48:27 <skew> except that's actually the field label
02:48:42 <skew> and the type of the field does need to be (a -> r) -> r, to wrap a bit of CPS code
02:49:08 <skew> so then r has to show through into the type of Cont unless you use existentials or something
02:49:54 <a5> field label? i actually don't understand Cont, couldn't find documentation. but i thought it's just applying the (a->r) thing to the result of the continuation
02:49:58 <skew> and just deciding that data Cont a = Cont ((a -> ()) -> ()) is useless, because all you can do with a pure function of type (a -> ()) -> () is feed it a function of type a -> () and get the value () out
02:50:25 <skew> a5: no, it's passing that (a->r) thing as the continuation to the computation wrapped up inside the Cont
02:51:03 <tromp> any function of type a->b where b has only one value, is pretty pointless
02:52:32 <a5> maybe i should look at the implementation. does it need a continuation to start out with..?
02:52:49 <skew> do you know the CPS transform?
02:53:40 <a5> no
02:54:08 <musasabi> Lemmih: pong
02:54:25 <Lemmih> musasabi: Can you mail me the STM HashTable?
02:54:28 <a5> it looks like it doesn't call the (a->r) when I'm running a returned continuation...
02:55:10 <skew> a5: the continuation passing type transform takes a function f(x) that returns some value v, and turns it into a function f(x,k) that tailcalls k with argument v instead
02:55:31 <skew> what to do with the result is made explicit, rather than just returning it to the surrounding cod
02:55:52 <a5> oh i see. yeah we did that in 134
02:56:33 <a5> so how does it fit into the monad?
02:57:03 <skew> A value of type Cont r a packs up a CPS value
02:57:25 <musasabi> Lemmih: one, moment  I'll look it up. (now @ home)
02:58:46 <nlv11757_> @pointless (\x y -> liftM (pp_wrap x y))
02:58:47 <lambdabot> (fmap .) . pp_wrap
03:00:31 <dons> @seen shapr
03:00:32 <lambdabot> shapr is in #haskell. Last spoke 48 minutes 26 seconds ago.
03:00:42 <shapr> dons: I'm not here, really.
03:00:54 <dons> shapr, should I write the hcar entry for lambdabot?
03:01:09 <musasabi> found it .
03:01:10 <dons> I just got a reminder mail.
03:01:12 <shapr> yeah, definitely
03:01:26 <dons> ok.
03:01:40 <a5> skew: ok thanks
03:02:03 <musasabi> Lemmih: http://youzen.b2.fi/~musasabi/stm-hashtable.tar.bz2
03:02:10 <Lemmih> Thanks.
03:09:47 <Lemmih> musasabi: Would you mind me putting it in a stm-base package?
03:10:04 <a5> the other thing, in order to get the continuation out without a infinite type error i had to define this: data X s = X s (X s -> ContT (X s) IO (X s)) (now using ContT) - should there be an easier way?
03:10:34 <skew> I think that is necessary
03:10:41 <skew> or something like that anyway
03:13:36 <musasabi> Lemmih: no, you can do what you want with that (if you want to put a licence to it, something like BSD would nice)
03:14:50 <musasabi> Lemmih: but please note the performance differences of the different aproaches (at least with 6.3 that was not the best solution)
03:34:42 <Itkovian> hmm .. sleeping laptops can be a nuisance when tracking conversations
03:48:43 <Itkovian> hmm
03:48:52 * Itkovian is bored
03:56:23 * kzm just woke up.
03:56:32 <kzm> Have you used Parsec?
03:57:59 <kzm> And is there a canonical way to parse multiple records from an input, so that the type is [Either ...] and not Either [...]?
04:09:57 <Itkovian> seems awfully quiet here ...
04:10:43 * Lemmih is busy hacking a HaskellDB style hashtable.
04:13:00 * kzm is busy tring to debug his &%#¤# broken Ubuntu installation.
04:13:12 <kzm> (or maybe it's (/%&¤%¤# Gnome, I'm not sure)
04:21:52 <Lemmih> Weee. In-memory typesafe database.
04:22:22 <kzm> Do go on?
04:23:30 <Lemmih> Compile-time list of hash tables == typesafe database.
04:24:17 <df_> %*%^& Gnome sounds right
04:25:08 <nibro> hmm... I try to do a darcs send (to myself just as a test) and darcs tells me patches were successfully sent, but no mail arrives. Anyone know what the deal is here?
04:25:35 <nlv11757_> @pointless  (\a b c d e f g -> return $ UU.Pretty.pp_ite a b c d e f g)
04:25:36 <lambdabot> (((((((return . ((UU . Pretty) .)) .) .) .) .) .) .) . pp_ite
04:25:38 <nlv11757_> lol
04:25:38 <dons> mail isn't configured?
04:26:03 <nlv11757_> @pointless  (\a b c d e f g -> return $ pp_ite a b c d e f g)
04:26:05 <lambdabot> ((((((return .) .) .) .) .) .) . pp_ite
04:26:28 <nlv11757_> looks nice
04:26:29 <nibro> dons: could you elaborate on that?
04:27:14 <nlv11757_> ((((((return .) .) .) .) .) .) . pp_ite                          VS                         (\a b c d e f g -> return $ pp_ite a b c d e f g)
04:27:29 <dons> it appears that many systems don't have mail set up to deliver properly, or mail sending/delivery is broken in other ways. many darcs users find darcs send doesn't work because of such configuration issues
04:27:38 <dons> s/broken/not set up/
04:28:04 <vincenz> What is @pointless?
04:28:22 <nlv11757_> it derives a pointfree notation
04:28:27 <vincenz> meaning?
04:28:37 <nibro> dons: know how to fix it?
04:28:38 <nlv11757_> not using names for parameters
04:28:42 <dons> re. your mail nibro - yeah, I didn't have a clear notion what mod_haskell does.
04:28:46 <nlv11757_> so instead of (\a b c d e f g -> return $ pp_ite a b c d e f g)
04:28:51 <nlv11757_> @pointless (\a b c d e f g -> return $ pp_ite a b c d e f g)
04:28:53 <lambdabot> ((((((return .) .) .) .) .) .) . pp_ite
04:29:00 <dons> nibro, well you can always work around it via: darcs send -o /tmp/foo
04:29:06 <dons> which writes the patch to /tmp/foo
04:29:08 <vincenz> seems very different
04:29:19 <nibro> ah, thanks that will do nicely =)
04:29:19 <vincenz> I would expect return (pp_ite . . . . . . . )
04:29:29 <dons> that file can then be attached and sent the usual way
04:29:42 <nlv11757_> the you have a misperception about the workings of (.)
04:29:51 <vincenz> nlv11757_: or just plain haskell :P
04:30:05 <nlv11757_> you're that geezer also on #ocaml arent you :D
04:30:08 <vincenz> @type (.)
04:30:13 <vincenz> nlv11757_: yip
04:30:14 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
04:30:20 * Oejet finally found the error. It was in the implementation of the dot product method. :-P
04:30:25 <nibro> dons re mod_haskell: Well, GK wasn't very clear on what he expected to do with it either, it might be that HSP is what he's looking for after all...
04:30:37 <nlv11757_> a . b $ c == a (b c)
04:30:57 <vincenz> @type ((return .) .)
04:30:59 <lambdabot> ((return .) .) :: forall (m :: * -> *) b a a1.
04:30:59 <lambdabot>                   (Monad m) =>
04:30:59 <lambdabot>                   (a1 -> a -> b) -> a1 -> a -> m b
04:31:04 <dons> nibro, or just hs-plugins perhaps, the paper shows how to load haskell plugins from foreign languages
04:31:12 <vincenz> @type (((return .) .) .)
04:31:13 <lambdabot> (((return .) .) .) :: forall (m :: * -> *) b a a1 a2.
04:31:13 <lambdabot>                       (Monad m) =>
04:31:13 <lambdabot>                       (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> m b
04:31:18 <vincenz> ah
04:31:34 <nlv11757_> see pp_ite takes one argument and return a function that needs six more....that function is then again the right hand side of the (.) takes another etc
04:31:43 <nlv11757_> until all seven args are taken and THEN return is called
04:31:46 <nlv11757_> 'called'
04:31:47 <vincenz> sick
04:31:51 * vincenz sticks to ocaml
04:31:54 <nlv11757_> pretty awesome actually
04:32:05 <nlv11757_> i regularly gag over ocaml actually :D
04:32:09 <vincenz> I don't
04:32:13 <vincenz> It's so pretty
04:32:19 <vincenz> only thing I really miss is typeclasses
04:32:23 <nlv11757_> pretty.....all that syntax and verbosity
04:32:27 <nlv11757_> yuck
04:32:30 <vincenz> ?
04:32:34 <nibro> dons: aye
04:32:41 <vincenz> what are you talking about
04:32:48 <vincenz> It's BE-UTIFUL
04:33:03 <nlv11757_> about the fact that an ocaml program usually asks for 6 times more syntax and verbosity in comparison to haskell
04:33:05 * Oejet is also among the few that likes OCaml's syntax.
04:33:19 <Lunar^> strange
04:33:22 <vincenz> nlv11757_: and haskell is so cryptic that you on't get what it's doing
04:33:37 <nlv11757_> cryptic to some maybe
04:33:44 <vincenz> besides....I sometimes see you hacking programs because suddenly you realize that you're building some sort of internal memory that is not freed properly
04:34:06 <vincenz> lazyness gone wrong?
04:34:07 <nlv11757_> talking about me in person?
04:34:18 <dons> hes WATCHING you
04:34:23 <nibro> nlv11757_: no overloading, that's really the only issue. makes ocaml ugly.
04:34:38 <nlv11757_> dons; obviously not, otherwise he would have made different statements :D
04:34:50 <kzm> Anybody using Parsec? Is there a canonical way to parse multiple records from an input, so that the type is [Either ...] and not Either [...]?
04:34:55 <vincenz> nlv11757_: no discussions in this channel
04:35:09 <nlv11757_> is that so
04:35:14 <vincenz> but I miss the community feeling in ocaml :/
04:35:16 <vincenz> so I hang out here
04:35:34 <nlv11757_> hahah he comes leeching of the community feeling in #haskell
04:35:36 <nlv11757_> :D
04:35:40 <vincenz> yip :D
04:36:29 <nlv11757_> lazyness is bliss
04:36:37 <nlv11757_> purity is bliss
04:36:49 <vincenz> eventually I intend to learn haskell
04:36:54 <vincenz> I just think that ocaml is a nice go between
04:37:11 <dons> vincenz, you must be picking it up via @type and @plugs right?
04:37:24 <dons> irc osmosis
04:37:26 <vincenz> I once saw people in here discussing over a zip or something, and they hardly noticed that internally they were building up data that wasn't being freeid
04:37:29 <vincenz> dons: yip
04:37:39 <vincenz> I love typing a la haskell and ocaml
04:37:48 <vincenz> you can tell what a function does almost uniquely by it's type
04:38:07 <nlv11757_> i think that hardly noticing internals is a plus in most cases
04:38:08 <dons> uniquely in some cases ;)
04:38:09 <vincenz> what is @plugs?
04:38:11 <dons> @type id
04:38:12 <lambdabot> id :: forall a. a -> a
04:38:17 <dons> @plugs id 'x'
04:38:20 <lambdabot> 'x'
04:38:30 <nlv11757_> plugs ~ ghci
04:38:37 <vincenz> nlv11757_: maybe but sometimes it goes so far that you cna't see what is going on and have something that keeps allocating data
04:38:51 <vincenz> I think ocaml is a pragmatic go between (well ml in general, though my fave is ocaml)
04:38:57 <vincenz> Alice looks nice too
04:38:59 <nlv11757_> thats when you profile your application
04:39:29 <dons> it's the haskell way! hack/profile/hack/profile ;)
04:41:38 <nlv11757_> i wouldnt say that :D
04:41:52 <dons> no, mostly we never profile
04:42:19 <nlv11757_> i was thinking of...it makes haskell look less superiour than it is
04:43:14 <dons> of course, who needs profiling when we do all our programming on the type level anyway
04:43:14 <nlv11757_> but on overal, functional people shouldnt kill eachother :D
04:44:09 <vincenz> ever looked at ocaml?
04:44:10 <vincenz> I mean
04:44:11 <vincenz> alic
04:44:14 <vincenz> ...alice
04:45:37 <vincenz> my biggest fear with haskell is performance
04:46:05 <vincenz> in fact, that's what keeping me
04:47:00 <nibro> people shouldn't worry so much about performance... not app writers anyway
04:47:06 <vincenz> well... depends
04:47:17 <vincenz> I write these tools to analyze certain logfiles
04:47:22 <nibro> yes, it does, there are always exceptions
04:47:26 <vincenz> originally it was in python, took 50 minutes
04:47:35 <vincenz> then I moved to ocaml.... 2-5 minutes
04:47:53 <Philippa> nibro: Haskell has many ways to get bitten really damn badly on performance
04:47:54 <nibro> how many lines of code?
04:47:54 <Oejet> nibro: I don't suppose you said that to the Eclipse developers?
04:48:03 <Philippa> like, asymptotically badly
04:48:37 <Oejet> Philippa: Yeah, and with a >300 constant factor.
04:48:59 <Philippa> nothing like a pile of (+1) thunks
04:49:14 <dons> it's not too hard to write fast software if you pay attention to the expensive code
04:49:19 <vincenz> my objection with lazyness....
04:49:25 <vincenz> usually it's not necessary
04:49:32 <vincenz> redundant code is rare
04:49:40 <Philippa> depends on what you're doing
04:50:04 <nibro> Philippa, Oejet: of course you can get bad behavior, but my experience is that you can often avoid it by rewriting
04:50:06 <Philippa> it's great for persistant data structures, for example, which I've ended up with several of in my code
04:50:30 <Philippa> this is true, but it takes a lot of lazy fu to figure out what needs rewriting sometimes
04:50:47 <Igloo> If you're looking to exercise your profiling skills, darcs provides many opportunities  :-)
04:51:03 <tromp> after many attempts, my haskell program is still over 20 times slower than C
04:51:07 <nibro> Philippa: aye, but then it's really a problem of understanding, not a problem of performance per se ;-)
04:51:23 <Igloo> tromp: What does it do?
04:51:37 <tromp> see http://homepages.cwi.nl/~tromp/c4/fhour.html
04:51:47 <nibro> tromp: I think you just issued a challenge... ;-)
04:51:55 <Philippa> nibro: having major and somewhat unpredictable performance pitfalls is a big deal for many people
04:52:07 <Philippa> it means that obtaining performance is potentially hard work
04:52:08 * Oejet agrees with SPJ in that laziness keeps you honest.  It's not a feature in itself.
04:52:30 <tromp> i'm using unboxed data and strictness wherever i can
04:52:37 <Igloo> tromp: Do you use arrays?
04:52:49 <Igloo> If so you'll need unsafe indexing to get near C's performance
04:53:34 <tromp> i didnt try that
04:53:46 <Philippa> Oejet: there're times I'm inclined to think it is - I'd have to do a lot of thinking re optimisation and default-strict vs default-lazy code though
04:54:02 <tromp> but i'd be surprised if it wld give even a factor of 2
04:54:23 * Philippa really wants a good way to do hotswappable semantics s.t. you can mark out code lazy or strict in large chunks
04:54:26 <nibro> tromp: so why is haskell so much slower in that example?
04:54:51 <Philippa> I think I know how to do it in principle, but getting it to run fast'd take a reasonably serious compiler which I don't have the ability to implement myself...
04:54:54 <tromp> i concluded that even a simple function of 64 bit ints is 10 times slower
04:55:18 <tromp> in particular the haswon function in my program
04:55:27 <tromp> no array access in there
04:55:36 <tromp> just some bittwiddling
04:55:49 <Igloo> Any shifts or rotates?
04:55:58 <tromp> lots of shifts:)
04:56:06 <Igloo> Turn up the inlining threshold, then
04:56:07 <tromp> which apparently hurt bad
04:56:30 <tromp> doesn't ghc -O inline small functions alrd?
04:56:44 <tromp> this is a really small function
04:56:44 <Igloo> Yes, but they aren't judged to be small
05:00:02 <tromp> is that -funfolding-use-threshold<n> ?
05:00:24 <Igloo> sounds right
05:00:39 <tromp> no idea what number to put there
05:00:42 <Igloo> Try 20
05:01:04 <tromp> defaults is said to be 45:)
05:01:14 <tromp> shldnt i make it bigger?
05:01:16 <Igloo> Really? Where?
05:01:27 <tromp> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
05:01:41 <tromp> sorry
05:01:49 <tromp> looking at previous flag:(
05:01:53 <tromp> default is 8
05:01:56 <Igloo> Heh, OK  :-)
05:03:00 <Itkovian> Any idea if tools exist to manipulate .wav files in Haskell?
05:03:41 <Philippa> I'm not specifically aware of them - I dare say you can FFI up a library somewhere that handles some of the common cases
05:03:46 <Philippa> what exactly do you need to do?
05:03:56 <Philippa> (bearing in mind that .wavs are RIFFed up chunks of multi-codec hell?)
05:04:40 <Itkovian> It's not dor me but for a student who does some funmath stuff with audio files etc.
05:04:52 <Itkovian> boegel's colleague
05:14:21 <tromp> doesn't help much, igloo
05:15:50 * Igloo hasn't got time to look at it myself
05:16:38 <Igloo> I assume you aren't changing immutable array, BTW?
05:17:21 <Igloo> If you are then using DiffArrays might help, or failing that mutable arrays
05:17:30 * Oejet gained 20% using -funfolding-use-threshold40.
05:19:47 <vincenz> time to learn haskell
05:20:08 <basti_> yay!
05:20:19 <vincenz> meh...
05:21:29 <vincenz> what do I do?
05:21:34 <basti_> what do you want to do?
05:21:45 <skew> get  GHC
05:21:45 <vincenz> learn haskell
05:21:50 <vincenz> I have ghci open
05:21:54 <basti_> oh thats good.
05:21:59 <basti_> did you load a file?
05:22:02 <vincenz> no
05:22:05 <Oejet> vincenz: Type something.
05:22:10 <vincenz> ...
05:22:13 <Oejet> He.
05:22:14 <basti_> like "3+4"
05:22:20 <basti_> maybe
05:22:21 <vincenz> something past simple expressions
05:22:31 <skew> let ones = 1:ones in ones
05:22:50 <skew> control-C aborts evaluation, by the way
05:23:10 <vincenz> I can do simple stuff...
05:23:19 <basti_> did you ever define a function yourself?
05:23:25 <vincenz> let f x = x
05:23:30 <basti_> thats id.
05:23:33 <basti_> nice.
05:23:34 <vincenz> yes
05:23:37 * vincenz rolls his eye
05:23:39 <basti_> do you know the type of id?
05:23:39 <vincenz> I know ocaml
05:23:41 <basti_> ahh.
05:23:44 <basti_> thats good.
05:23:46 <vincenz> for all 'a : 'a -> 'a
05:23:56 <blackdog> watch everyone ratchet up their expectations. :)
05:23:56 <basti_> so what do you trip on?
05:24:04 <vincenz> where to go from here
05:24:10 <basti_> ohh maybe laziness.
05:24:20 <vincenz> like how would I define a type so I can do tree stuff?
05:24:22 <basti_> ocaml doesnt do that as easy.
05:24:26 <basti_> with "data"
05:24:44 <vincenz> data 'a x = None | Some of 'a ?
05:24:45 <basti_> like, "data Tree a = Branch (Tree a) (Tree a) | Leaf a"
05:24:53 <vincenz> ah
05:24:57 <basti_> "data Maybe a = Nothing | Just a"
05:25:00 <basti_> thats the syntax
05:25:02 <vincenz> thx
05:25:04 <basti_> like an abstract data type
05:25:08 <vincenz> yip
05:25:15 <basti_> you can match these constructors in function definitions
05:25:17 <vincenz> (funcotrs!)
05:25:17 <basti_> as in:
05:25:49 <vincenz> hmm...ghci doesn't like data
05:25:50 <basti_> preorder (Branch a b) = (preorder a) *** (preorder b)
05:25:59 <basti_> you can't do this sort of stuff interactively.
05:25:59 <skew> To make a data type you will need to write a file and load that
05:26:06 <basti_> you need to read a file.
05:26:18 <vincenz> oki
05:26:23 * vincenz always hated that
05:26:28 <skew> ghci is actually treating the lines you type as statements in an IO do-block
05:26:31 <basti_> non interactivity?
05:26:34 * vincenz nods
05:26:38 <basti_> its okay in this part of the world.
05:26:52 <basti_> at the other end, haskell is very interactive if you want it to be.
05:26:56 <skew> which is why you can write let x = <expr> to bind something over the rest of your session
05:27:08 <basti_> but Types ought to be fixed.
05:27:11 <basti_> at least for now.
05:27:49 <vincenz> hmm
05:28:08 <vincenz> the syntax of types is dagnerous, it mixes data constructors with type construcotrs
05:28:24 <basti_> huh?
05:28:32 <vincenz> Branch (Tree a) (Tree a)
05:28:34 <basti_> how so?
05:28:38 <vincenz> Branch = data constructor
05:28:45 <vincenz> Tree = type constructor
05:28:52 <basti_> yes and it takes two arguments of type (Tree a)
05:29:01 <basti_> its a type declaration.
05:29:14 <vincenz> I know... but you're mixing apples and oranges
05:29:22 <basti_> no actually just different levels of abstraction.
05:29:29 <basti_> it's safe in this place though.
05:29:31 <shapr> mmm, fruit basket
05:29:38 <basti_> shapr: !
05:29:40 <skew> like 1 + 2 mixes functions and numbers?
05:29:42 <shapr> basti_: !
05:29:47 <basti_> shapr: update on tmr2?
05:29:57 <shapr> um, lemme get the wiki up
05:30:03 <tromp> it's not a really a mix, since the constructor only appears at front of each alternative
05:30:13 <vincenz> true enough
05:30:24 <basti_> tromp: right.
05:30:26 <vincenz> anyways I can't get it to load the file ... I wrote data.h do a :load test.h and tells me it can't load it
05:30:47 <basti_> huh?
05:30:48 <tromp> i like the way it looks natural like data Bool = False | True
05:30:49 <skew> if you make data.h and load test.h I'm not surprised
05:30:57 <basti_> -g-
05:30:59 <vincenz> ugh...same name of course
05:31:00 <Lemmih> haha
05:31:02 <skew> Haskell files are conventionally .hs, btw
05:31:03 <basti_> "stating the obvious"? ;)
05:31:11 <shapr> hiya machack666
05:31:14 <vincenz> and yes I renamed it to .hs
05:31:24 <basti_> shapr: so where would the wiki be then when it is "up"? ;)
05:31:29 <vincenz> hmm, changing the extension made it work
05:31:30 <skew> did you make the file in the directory you ran ghci in?
05:31:37 <shapr> basti_: that's my first question
05:31:42 <nlv11757_> hmmm
05:31:56 <vincenz> aha! my first real haskell problem
05:32:06 <vincenz> No instance for (Show (Tree a))
05:32:18 <skew> I know you don't need to give the extension to :load if the file has a .hs extension
05:32:20 <basti_> vincenz: that just means "i can't print trees"
05:32:21 <vincenz> so just having a data is not enough, I should make it extend the show typeclass
05:32:24 <vincenz> basti_: I know
05:32:26 <vincenz> :)
05:32:43 <basti_> vincenz: you can make the compiler create a default instance.
05:32:47 <skew> hmm, that thing with :load is wrong
05:32:49 <nlv11757_> whats logical when lifting "[PP] -> PP", either "m [PP] -> m PP" or "[m PP] -> m PP"
05:33:10 <nlv11757_> i'd say the last
05:33:17 <vincenz> nlv11757_: I'd say the first
05:33:21 <skew> By the way, :m + <module> adds a module to your session
05:33:25 <vincenz> or wait. yes, then last
05:33:27 <shapr> I'd say something else entirely.
05:33:28 <skew> without losing the old bindings
05:33:34 <nlv11757_> what would you say shapr
05:33:39 <nlv11757_> 'depends on the situation' ?
05:34:18 * shapr thinks
05:34:25 <shapr> @type Control.Monad.join
05:34:28 <lambdabot> Control.Monad.join :: forall a (m :: * -> *).
05:34:28 <lambdabot>                       (Monad m) =>
05:34:28 <lambdabot>                       m (m a) -> m a
05:34:39 <shapr> I'd use the last one.
05:35:01 <shapr> I have a suspicion that the first one is more like sequence.
05:35:08 <shapr> 'unrolling the loop'
05:35:08 <nlv11757_> i find it hard to exactly say why i'd prefer the last
05:35:37 <nlv11757_> instead of having a list of PP, we have a list of computations returning PP....it sounds logical
05:35:38 <shapr> What about "[m PP] -> m [PP]" ?
05:36:09 <nlv11757_> that doesnt really correspond with [PP] -> PP
05:36:17 <nlv11757_> does it
05:36:26 <vincenz> it's obviously [m PP] -> m PP
05:36:40 <vincenz> why?  if you have m [PP] then you can easily get m PP by running the function inside the m
05:36:49 <vincenz> now you're lifting the m outside of the []
05:37:09 * shapr shrugs
05:37:19 <nlv11757_> [m PP] -> m [PP] expresses sequencing the computation and pushing the list into the monad
05:37:19 <shapr> ik veit het niet.
05:37:24 <nlv11757_> weet
05:37:28 <shapr> whoops
05:37:29 <vincenz> idd, weet
05:37:33 <vincenz> or veet
05:37:36 <vincenz> but that is something different
05:37:39 <shapr> What's veet?
05:37:47 <vincenz> the stuff women put on their legs
05:37:51 <nlv11757_> something belgian probably
05:37:54 <vincenz> gets rid of all the hairs in a chemical way
05:37:55 * shapr laughs
05:38:03 <shapr> I definitely don't veet my legs.
05:38:04 <vincenz> nlv11757_: it's a brandname :P
05:38:27 <nlv11757_> ok stop there vincenz, i need not concern myself with women cosmetics :D
05:38:55 <vincenz> anyways... I think it's [m PP] -> m PP ....m [PP] -> m PP is nothing special
05:39:36 <vincenz> anyone have a drawing of what the category of a monad looks like/
05:39:41 <Philippa> veet's wonderful stuff, especially if you're allergic to it
05:39:46 <machack666> hey shapr (sorry for the delay...) :)
05:39:54 <Philippa> (used to be called immac)
05:39:57 <vincenz> Philippa: it just sounds bad....put it on and you can wipe your hairs off...
05:40:06 <Philippa> yeah. And then itch for the next 24 hours
05:40:13 <Philippa> like I said, great when you're allergic to it
05:40:36 <Philippa> it /does/ need a little time to weaken the hairs enough, but leaving it on too long is a really bad thing
05:40:49 <nlv11757_> hmmm wait, isnt 'm [PP] -> m PP' closer to '[PP] -> PP' ?? cause instead of reducing a list we are reducing a computation that returns a list....
05:41:20 <vincenz> nlv11757_: yes but you're not "lifting"
05:41:37 <vincenz> not much to it really
05:41:45 <skew> nlv11757_: that's just liftM
05:42:25 <nlv11757_> exactly skew, i used liftM now to lift a function [PP] -> PP to m [PP] -> m PP, but i was asking myself if that was the right choice
05:43:08 <vincenz> nlv11757_: well... the nice thing of [m PP] -> m PP is that you can reuse it
05:43:51 <vincenz> for instance... let's say [m PP] -> m PP is a fold....now you can put the result of this into another list and fold again
05:44:17 <shapr> machack666: learning Haskell?
05:44:21 <nlv11757_> i think im bumping into that problem right now actually.
05:44:30 <vincenz> o/
05:44:43 <nlv11757_> but i do want to reuse this old [PP] -> PP function
05:45:00 <shapr> Can you liftM it?
05:45:13 <vincenz> nlv11757_: what's it do?
05:45:14 <skew> nlv11757_: [m PP] -> m PP is the natural translation if you want to change your code from working on PP values to passing around m PP values
05:45:19 <blackdog> shapr: yes you can! (can i lift it?)
05:45:20 <nlv11757_> if i liftM it, i get m [PP] instead of [m PP]
05:45:30 <machack666> shapr: trying to wrap my head around it
05:45:33 <nlv11757_> skew, that is what im doing
05:45:35 <shapr> blackdog: work out those monadic muscles man!
05:45:47 <skew> well, then you should make it take [m PP] -> m PP
05:45:53 <nlv11757_> cause it used to return PP, but now it suddenly returns m PP and i have to adapt all other things
05:46:15 <shapr> machack666: have any questions? want pointers to intro docs?
05:46:35 * Lemmih just completed his in-memory, typesafe, HaskellDB-style, STM database.
05:46:38 <skew> return an m PP is just fine if you want to start working in the m monad, because you will just get the value out with bind and keep passing around PPs
05:46:39 <machack666> shapr: i've read some of the docs on haskell.org, and the type system is starting to make sense.
05:46:53 <shapr> machack666: spiffy, if you have questions feel free to ask 'em here.
05:47:21 <machack666> shapr: thanks.  The pugs source code still makes my head spin though... :)
05:47:42 <skew> shapr: vincenz is learning Haskell. He knows Ocaml.
05:47:46 <shapr> Yeah, autrijus has many brain cells, and he uses them well.
05:48:03 <shapr> skew: I know vincenz from Ward's Wiki
05:48:19 <shapr> Comment allez vous, Monsieur Poucet?
05:48:21 <nlv11757_> im going to have a strong coffee and then do it monad style
05:48:26 <nlv11757_> thanks for all the help
05:48:34 <basti_> hmm
05:48:47 <basti_> so does anyone know by now what a monad REALLY is, category theory wise?
05:48:57 <shapr> nlv11757_: http://www.cafepress.com/doitmonad
05:49:02 * basti_ still doesnt know the difference between a functor and a monad.
05:49:05 <Philippa> category theory wise, you can find the definition via google
05:49:13 <Philippa> basti_: join and return
05:49:20 <nlv11757_> that are some kickass shirts shapr :D
05:49:21 <Philippa> a functor just has fmap
05:49:27 <basti_> hmm.
05:49:29 <basti_> ahh.
05:49:34 <shapr> Yeah, I think I gotta order some of thos.
05:49:36 <Philippa> join is the m m a -> m a func (bind being expressible in terms of join and fmap)
05:49:37 <basti_> ah *donk*
05:49:39 <machack666> shapr: know of any good docs specifically on monads?
05:49:40 <skew> some of those shirts should have the diagrams
05:49:43 <basti_> yes i see.
05:49:56 <basti_> i confused join and fmap while thinking about it.
05:50:04 <shapr> machack666: http://www.nomaware.com/monads/html/ and http://www.haskell.org/hawiki/MonadsAsContainers
05:50:26 <machack666> thx
05:50:31 <Philippa> oh, and in Haskell it's all ending up in the same category in the end
05:50:55 <Philippa> though it's useful to separate out either ends still
05:50:56 <basti_> hmmm?
05:51:01 <shapr> machack666: Monads are way simple, they have three ingredients. A partially filled in type, and two functions. One function fills in the type with a value, the other function puts together two values to give a result of the same value.
05:51:13 <basti_> you mean as in there is a "base type" or something?
05:51:59 <basti_> :-O -reading the monad wikipedia entry-
05:52:16 <machack666> from what I understand, monads are the only way to isolate side effects or "state".  Is this correct?
05:52:33 <basti_> hmm.
05:52:36 <Lemmih> Monads are a nice way to do it.
05:52:38 <basti_> they are the preferred one way.
05:52:44 <shapr> Truthfully, you emulate state with monads.
05:53:26 <shapr> A pure function for a calculator with a one value memory could just pass around the memory as a separate parameter to the function.
05:53:28 <skew> There are monads provided in the libraries that do encapsulate actual side effects and mutation
05:54:08 <machack666> what does the syntax (Monad m) => a -> m a mean, specifically the class and "=>" ?
05:54:12 <basti_> it's just kind of a "markup" from the user's point of view
05:54:20 <machack666> (I get the type signature at the end)
05:54:31 <vincenz> shapr: je vais bien mais je ne suis pas francophone
05:54:39 <basti_> machack666: "if you got a monad called m, then we got a function of a type to that type inside a monad"
05:54:40 <shapr> quel dommage
05:54:55 <shapr> je suis un nokiaphone.
05:55:09 <machack666> could you look at it as defining additional interfaces to a defined class?
05:55:17 <basti_> uhm.
05:55:20 <basti_> no it's just a type
05:55:27 <basti_> respective, a visual representation of a type
05:55:30 <skew> you can kind of think of it like that
05:55:36 <basti_> the thing in front is a restriction of the variables
05:55:42 <Philippa> machack666: it's constraining a variable to belong to a particular 'type class'
05:55:59 <basti_> "m needs to be a monad", and if we got a monad, there might be a function "a -> m a"
05:56:05 <Philippa> 'type classes' just being bunches of types that fulfill a given property (eg having a notion of equality)
05:56:06 <skew> but if you want to look at it that way it's more about defining a new operation that only depends on the interface "Monad m"
05:56:28 <machack666> so "return :: (Monad m) => a -> m a" implies that return is only defined (at this point) for a Monad m?
05:56:36 <skew> yes
05:56:49 <machack666> ok. that makes sense.
05:56:58 <skew> Except "at this point" is really forever
05:56:58 <basti_> machack666: it means that it will need to be defined for anything that you declare a monad.
05:57:09 <basti_> it="return"
05:57:19 <basti_> you can declare things a monad.
05:57:25 <skew> When you see something like that in the definition of the class you need to provide it when you declare something a monad
05:57:28 <machack666> and do I remember that (Monad m) is just a way of shortening the "true" type signature of monads?
05:57:37 <basti_> like "instance Monad (MyType a) where"
05:57:55 <basti_> hmm?
05:57:59 * machack666 needs to read up on instance, data, and type again.
05:58:05 <basti_> no its a way of "mentioning" the monad.
05:58:15 <basti_> or "any" monad, in that case
05:58:30 <basti_> its an all-quantified variable
05:59:26 <basti_> "for all m, so that m is a "THING WE CALL MONAD", we will have a function called 'return', which would take some value, and then return this value "INSIDE THIS THING WE CALL A MONAD"
05:59:30 <basti_> or something
05:59:49 <basti_> (or, "return ANY value INSIDE..."
06:00:14 <basti_> some.
06:00:19 <basti_> return SOME value.
06:00:21 * basti_ nods
06:00:49 <machack666> ok, looking at the MonadsAsContainers page I think the concept I was missing was how to utilize the Monads.  i.e., the binding operator.
06:01:01 <basti_> well it's invisible most of the time.
06:01:01 <basti_> ;)
06:01:14 <basti_> sowwy. ;)
06:01:24 <basti_> thats what the "do" notation does...
06:01:35 <machack666> hmm..
06:01:45 <shapr> hej bringert!
06:01:47 <basti_> it carefully weaves a pattern of dataflows through your code.
06:01:56 <skew> shapr: did you look at Aardappel any more?
06:01:57 <bringert> hej shapr
06:02:10 <shapr> skew: not yew, paying work keeps interfering with my life.
06:02:12 <basti_> and in the end, you'd end up with a cute little notation that just does what you want...
06:02:21 <basti_> for example, you can use any list inside monads.
06:02:24 <nlv11757_> this monad stuff im doing just got so much simpler when i added type sigs :)
06:02:34 <Itkovian> wow. nice shirts
06:02:47 <shapr> hej bringert, what do you think about EuroHaskell?
06:02:53 <nlv11757_> the monad shirts itkovian?
06:02:55 <machack666> so with the wiki example:
06:02:55 <machack666> do x <- [10,20,30]
06:02:55 <machack666>    [x, x+1]
06:02:59 <Itkovian> yeah
06:03:04 <basti_> every variable that appears keeps a single element, and every function returns a list
06:03:10 <nlv11757_> :D if i only had a credit card
06:03:12 <Itkovian> u got some baby sizes of those?
06:03:14 <shapr> Itkovian: http://www.haskell.org/merchandise.html
06:03:15 <Itkovian> :-)
06:03:17 <shapr> lots of goodies
06:03:30 <nlv11757_> kids small probably does it itkovian :)
06:03:32 <basti_> machack666: do you understand why this is happening?
06:03:38 <Itkovian> like 9 months?
06:03:39 <machack666> does this effectively return the list [11,21,31] ?
06:03:50 <machack666> no.  :)
06:03:50 <basti_> [10,11,20,21,30,31] i think
06:04:07 <basti_> @plugs do {x<-[10,20,30];[x,x+1]}
06:04:09 <lambdabot> [10,11,20,21,30,31]
06:04:19 <basti_> we got a hugs bot now machack666.
06:04:23 <nlv11757_> hahah ok, make it a diper as well then itkovian
06:04:26 <machack666> cool
06:04:34 <nlv11757_> for the interaction with the outside world ;)
06:04:39 <Itkovian> nah, that's have to be thrown out after 4 hours at most
06:04:41 <basti_> so do you understand why this is happening?
06:04:46 <Itkovian> s/s/d/
06:04:49 <machack666> @plugs do {x<-[10,20,30],[x;x+1;x+2]}
06:04:50 <lambdabot> parse error on input `,'
06:04:54 <basti_> ";"
06:04:56 <basti_> semicolon
06:04:58 <Itkovian> ";"
06:04:59 <machack666> @plugs do {x<-[10,20,30],[x,x+1,x+2]}
06:05:01 <lambdabot> parse error on input `,'
06:05:07 <machack666> @plugs do {x<-[10,20,30];[x,x+1,x+2]}
06:05:08 <Itkovian> ];[
06:05:08 <lambdabot> [10,11,12,20,21,22,30,31,32]
06:05:10 <basti_> ah
06:05:13 <basti_> aup
06:05:15 <tromp> u can also understand it as
06:05:24 <tromp> do x <- [10,20,30]
06:05:29 <tromp>    y <- [x,x+1]
06:05:33 <tromp>    return y
06:05:36 <basti_> yup
06:05:43 <basti_> thats the same thing.
06:05:44 <tromp> it's just like nested for loops
06:05:54 <machack666> so is the concatenation of lists implicit?
06:05:57 <tromp> collecting everything returned
06:06:11 <basti_> no its coded in the "Monad" declaration of the Type "List a"
06:06:19 <basti_> (or "[a]")
06:06:21 <vincenz> what is @plugs?
06:06:31 <Itkovian> the haskel interpreter of lambdabot afaik
06:06:33 <skew> @help plugs
06:06:34 <lambdabot>  @plugs <expr>
06:06:34 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
06:06:40 <basti_> vincenz: the bot will feed your input to a hugs and return the output.
06:07:10 <machack666> so is the list Monad the most useful container, or are there others that come into play as well?
06:07:19 <vincenz> ah
06:07:37 <basti_> machack666: well there are as many as you want.
06:07:48 <basti_> machack666: for example, "Maybe" is useful for trading errors.
06:08:12 <basti_> it computes until there is "Nothing".
06:08:17 <basti_> this would be returned immediately.
06:08:32 <basti_> (or until the function is evaluated)
06:09:04 <basti_> and then, there is the remarkable use of the type "IO" to encapsulate interaction.
06:09:16 <basti_> (like, states, outside world, etc.)
06:09:47 <basti_> every function that does IO has an IO type.
06:10:14 <basti_> and you will find that you will not be able to do anything with an IO type, besides, connecting it to the outside world and let it do its thing.
06:10:32 <basti_> that keeps you from shooting yourself in the foot with unnecissary state.
06:10:33 <basti_> :)
06:10:47 <basti_> (permutate n, c, s counts)
06:10:48 <machack666> in some of the examples on nomaware.com, I see "Just" referenced.  Is Just a Monad as well?
06:10:57 <basti_> "Just" is a constructor for "Maybe"
06:11:01 <basti_> @type Maybe
06:11:02 <lambdabot> bzzt
06:11:08 <basti_> uhm
06:11:11 <Philippa> data Maybe a = Just a | Nothing
06:11:14 <basti_> yes.
06:11:32 <machack666> @type Nothing
06:11:35 <lambdabot> Nothing :: forall a. Maybe a
06:11:40 <skew> @kind Maybe
06:11:42 <lambdabot> Maybe :: * -> *
06:11:56 <basti_> a "Maybe x" value is either a value of the type x, marked with "Just", or "Nothing", without any value
06:12:01 <skew> wow, I didn't know that worked
06:12:03 <basti_> well any other value
06:12:10 <basti_> skew: its useless though... ;)
06:12:19 <basti_> @info Maybe
06:12:20 <skew> @info Maybe
06:12:20 <lambdabot> Unknown command, try @listcommands.
06:12:23 <lambdabot> Unknown command, try @listcommands.
06:12:24 <basti_> hehe
06:12:27 <Philippa> not always, though kinds generally aren't too hard to figure out
06:12:28 <basti_> we had this once
06:12:31 <basti_> but people flooded
06:12:32 <machack666> @type Just
06:12:34 <lambdabot> Just :: forall a. a -> Maybe a
06:12:43 <skew> basti_: well, it does tell you that Maybe is a type if @kind Maybe works
06:12:50 <basti_> yes.
06:12:53 * basti_ nods.
06:12:54 <basti_> it does.
06:13:19 <skew> which was why I typed @kind Maybe in the first place
06:13:26 <machack666> so does the case statement effectively switch on types?
06:13:34 <skew> machack666: no, on the constructors
06:13:42 <basti_> think abstract datatypes.
06:14:16 <Philippa> case (someMaybe) of {Just foo -> ...; Nothing -> ...;} <- note that there's no pattern for Maybe
06:15:30 <machack666> so we apply the first function if the someMaybe is not Nothing, and the second if it is?
06:15:56 <machack666> or more specifically, if it is the foo type.
06:16:26 <basti_> machack666: no rather like, there's a computation, that happily muggles along until it ends. if one of the call fails, nothing will break, it will just return "Nothing"
06:16:47 <basti_> (and everyone below there would be moralically, if not compiler-technically obliged to expect that)
06:17:45 <skew> can anybody tell me what the language \bar{SAT} is? (that's an overline)
06:18:02 <basti_> (with failing being returning Nothing, and functions that do not return a "Maybe" type, others being excluded for now)
06:18:38 <basti_> skew: it sounds like the language of satisfyable boolean formulas for sure
06:18:41 <basti_> or its complement?
06:19:17 <basti_> machack666: you can use as many steps as you want.
06:20:40 <machack666> can you have multiple class contexts defined as constraints, or would you just specify them separately?
06:20:46 <basti_> uhm.
06:20:55 <basti_> there's two questions in that question.
06:20:56 <machack666> (not related to the monad conversation)
06:21:08 <basti_> 1) a type can be instance of several types at once
06:21:27 <basti_> 2) these types might appear as constraints on some functions type, of course even many of them
06:21:58 <basti_> 3) it's rare that you'll need to bother. You will get away with it fine if you learn to read the errors.
06:22:11 <machack666> ok, so the junction of types is a vaild type
06:22:37 <basti_> that too.
06:22:43 <basti_> but thats something else.
06:23:09 <basti_> constraints are left of the turnstile :)
06:23:37 <basti_> a junction would be "either a or b"
06:23:39 <basti_> @type Left
06:23:42 <lambdabot> Left :: forall b a. a -> Either a b
06:23:55 <basti_> there's not much of a constraint there.
06:24:13 <machack666> @type Right
06:24:14 <lambdabot> Right :: forall b a. b -> Either a b
06:24:19 <basti_> @kind Either
06:24:20 <lambdabot> Either :: * -> * -> *
06:24:30 <basti_> ^ either needs two types to make sense.
06:25:02 <machack666> so is the turnstile "=>" ?
06:25:08 <basti_> yes.
06:25:08 * machack666 thinks he's being too literal
06:25:20 <basti_> actually its just an implication... as in "a->b"
06:25:29 <basti_> but its written differently for the sake of clarity
06:26:17 <basti_> (it happens on another level)
06:26:43 <basti_> (actually, functions are kind of like implications too. thats why we write them like implications when we talk about types.)
06:26:50 <machack666> so is most of this defined in the Prelude?
06:26:54 <basti_> (don't let that bother you ;)
06:27:04 <basti_> hmm actually => and -> are hard coded i think.
06:27:32 <Philippa> yes, they're part of the syntax of types
06:27:34 <basti_> (haskell can't talk about itself.)
06:27:57 <basti_> (but it talks a lot about its types, like lists)
06:28:02 <basti_> or, monads.
06:28:24 <basti_> thats a feature.
06:28:52 * basti_ is trying to give machack666 a complete brain upload.
06:29:27 * machack666 brain just exploded
06:29:31 <machack666> :)
06:29:38 <basti_> dont worry its really easy.
06:29:41 <basti_> @type (*)
06:29:43 <lambdabot> (*) :: forall a. (Num a) => a -> a -> a
06:30:03 <basti_> "you can multiply every two numbers to get a number of the same kind as the result"
06:30:11 <basti_> @plugs 5*3
06:30:12 <lambdabot> 15
06:30:23 <machack666> so the 'a' is completely arbitrary
06:30:24 <basti_> @plugs (1%4)*(6%3)
06:30:26 <lambdabot> 1 % 2
06:30:32 <basti_> its a placeholder
06:30:43 <machack666> it just stands in as an identifier for the same type throughout the function
06:30:46 <basti_> in this case, for any type that satisfies the constraint.
06:30:47 <vincenz> @plugs (1%3)
06:30:49 <lambdabot> 1 % 3
06:30:53 <basti_> yes right
06:31:00 <skew> more generally, any lowercase name in a type is a type variable
06:31:05 <basti_> yup.
06:31:22 <skew> Uppercase is reserved for type names, class names, and constructor names
06:31:33 <machack666> if you have a type defintition with an a and a b, are they necessarily different types, or can they be the same type?
06:31:40 <basti_> compilers will often give you lots of type variables. they might be named strange then.
06:31:50 <basti_> they may be the same
06:32:12 <basti_> i don't think haskells type system can express an "a not equal b" constraint.
06:32:25 <skew> basti_: want to make a bet with Oleg?
06:32:25 <basti_> would not know what that might be useful for, too.
06:32:31 <basti_> skew: about what?
06:32:31 <shapr> I think you could
06:32:36 <shapr> it would be evil, but possible.
06:32:39 <basti_> hehehe
06:33:22 <basti_> there are bizarre circumstances that might force you to make a type dependant on circumstances known only at runtime.
06:33:31 <machack666> so it's kind of like you define the highest order logic possible for given types.
06:33:31 <basti_> thats apocryphical to some people though.
06:33:38 <shapr> I took my sony mp3 player back today, and ordered an iRiver instead. People on livejournal and slashdot said iRiver works politely with Linux as a USB mass storage device.
06:33:43 <skew> I think all it takes is class NotEqual a b {- empty -}, with instances Fail => NotEqual a a and NotEqual a b
06:33:47 <basti_> hmm actually its not the highest order possible
06:34:01 <basti_> you can't match on types normally can you????
06:34:03 <shapr> machack666: there is much higher order logic, wait till you hit type theory and I can point you to dependent type systems.
06:34:15 <machack666> *boom*
06:34:22 <machack666> heh
06:34:32 <basti_> machack666: no worries.
06:34:36 <skew> shapr: does that do vorbis?
06:34:39 <shapr> There are *so many* shiny toys in this part of the knowledge world.
06:34:44 <basti_> machack666: much of the types you'll see are completely benign
06:34:50 <basti_> @type 5
06:34:51 <lambdabot> 5 :: forall t. (Num t) => t
06:35:02 <shapr> skew: yes it does, and it's cheaper =) and it does voice recording directly onto the iRiver, and a bunch of other stuff too.
06:35:02 <basti_> ^ "we can make this a number"
06:35:04 <skew> basti_: typeclass instances can pattern match on types, more or less
06:35:19 <basti_> skew: fundeps yes?
06:35:27 <skew> basti_: not even that
06:35:30 <shapr> the sony is >> the iRiver
06:35:33 <vincenz> type classes are just like oo without polymorphis
06:35:41 <basti_> skew: hmm
06:35:51 <skew> instance Show Int vs instance Show Char
06:35:52 <shapr> isn't >> shiftR in C?
06:35:53 <basti_> i always think type classes are somewhat "backwards" oo
06:35:59 <vincenz> me nods
06:36:10 <blackdog> i thought you were throwing away the sony and proceeding to the iRiver
06:36:12 <shapr> type classes are larger than OO, imho
06:36:16 <shapr> blackdog: you got it
06:36:32 <basti_> there are differences in the detail, but you might end up writing "oo style" in type classes.
06:36:35 <shapr> the iRiver is way better, and Linux friendly.
06:36:36 <blackdog> oh, you _were_ talking monads, not >> = much better than... goddamn we geeky.
06:37:00 <basti_> i think type classes are more powerful too.
06:37:03 <skew> I think that was "much more expensive than"
06:37:26 <basti_> skew: hmm but isnt that limited to recognizing a single type at compile time?
06:37:27 <shapr> blackdog: actually, it was an attempt at being way punny, less than >, really very much less than >>, and bit shift too. I hadn't noticed the monad pun in there, but you're absolutely right.
06:37:32 <basti_> as in "under the hood" too?
06:37:37 <basti_> (non-transparent)
06:37:39 <machack666> so is a Kind the Type of a specific instance? (say)
06:37:47 <skew> basti_: not if you make a multiparameter type class
06:37:53 <skew> like NotEqual a b
06:37:59 <basti_> i'm not sure about the clean definition of "Kind" machack666
06:38:05 <shapr> @kind 1
06:38:07 <lambdabot> 1 :: *
06:38:10 <basti_> skew: hmmm.
06:38:11 <Philippa> a Kind is unto a Type what a Type is unto a Value
06:38:14 <skew> My thing does need overlapping instances to work
06:38:14 <shapr> @kind (\x -> x + 1)
06:38:17 <lambdabot> bzzt
06:38:19 <basti_> ah.
06:38:28 <basti_> so Kind = Coq's Type, Type = Coq's Set?
06:38:32 <shapr> @kind Data.Maybe.Just
06:38:34 <Philippa> dunno
06:38:34 <lambdabot> bzzt
06:38:37 * shapr blinks
06:38:42 * basti_ flies away with soft featherstrokes
06:38:42 <Philippa> Coq never really appealed to me
06:38:47 <basti_> i kinda like it now
06:38:49 <basti_> its pervert
06:38:51 <basti_> but in a funny way
06:38:53 <shapr> Kinds are like metatypes, but I can't get it straight in my head at the moment.
06:39:03 <blackdog> PLs in raincoats, hm?
06:39:07 <skew> types are simply kinded
06:39:09 <basti_> they are not types of higher order, are they?
06:39:17 <machack666> @type 1.0
06:39:20 <lambdabot> 1.0 :: forall t. (Fractional t) => t
06:39:23 <Philippa> nah, a higher-order type would just have a type lambda
06:39:25 <skew> Kinds in Haskell are like the simply typed lambda calculus, one level up
06:39:28 <Philippa> think system F-omega
06:39:30 <basti_> machack666: audience generally agrees on your view.
06:39:30 <basti_> ;)
06:39:33 * basti_ nods
06:40:12 <basti_> in Coq there's Three Systems of Types of unrestricted order.
06:40:22 * basti_ grins
06:40:35 <nlv11757_> is there a reason not to allow; "class (Foo.Bar.PP a, Monad m) => PP (m a) where
06:40:35 <nlv11757_>   pp :: m a -> m PP_Doc"
06:40:37 <basti_> thats a bit like type amok but it's worth the experience
06:40:55 <nlv11757_> should i push the Monad m inside all the function sigs?
06:41:00 <basti_> nlv11757_: i do not know what you're heading at.
06:41:14 <nlv11757_> class PP (m a) where ... is not allowed
06:41:20 <basti_> nlv11757_: 1. the class "Monad" is defined already, you would be defining "instances"
06:41:20 <nlv11757_> i want to understand why
06:41:30 <shapr> nlv11757_: I think it's simpler to lift existing pure functions wherever possible.
06:41:49 <basti_> nlv11757_: 2. if you really want to define an instance of Monad, then you will need to supply a Type that has a parameter
06:41:56 <basti_> other things do not make much sense.
06:42:05 <machack666> well, thanks for all of your help.  I'm going to read "a Gentle Introduction" again and see if I can glean a little more out of it this time.
06:42:18 <basti_> (i.e. might be possible. you don't want to do it except for educational purposes, though.)
06:42:26 <Philippa> machack666: it's not the most gentle introduction by a long way
06:42:28 <basti_> machack666: the gentle intro is.not.gentle.
06:42:28 <basti_> ;)
06:42:33 <nlv11757_> i just want to define a class PP for monad types, is this not what im doing?
06:42:34 <Philippa> you might find YAHT helps
06:42:38 <machack666> is there a more gentle one?
06:42:40 <basti_> nlv11757_: uhm.
06:42:51 <basti_> nlv11757_: -swallows-.
06:42:55 <Philippa> (I wouldn't know - I had an intro course at uni, and as a gentle reintroduction it works)
06:42:55 <machack666> Gentle Introduction >> a
06:42:57 <skew> I like the gentle intro
06:43:03 * machack666 's first Haskell pun.
06:43:14 <nlv11757_> monad types of types belonging to Foo.Bar.PP, thats why i said 'class PP (m a) where'
06:43:39 <basti_> hmm.
06:43:41 <skew> Reading it along with the Haskell report with an interpreter handy was how I learned Haskell
06:43:55 <basti_> i still think you actually want to do "instance m PP where" ;)
06:44:03 <basti_> i do not say that what you're doing is impossible
06:44:16 <nlv11757_> hmm im not sure if that is what i want....
06:44:28 * nlv11757_ thinks 
06:44:30 <basti_> what do you want to do?
06:45:14 <autrijus> greetings lambdafolks.
06:45:29 <skew> hi
06:45:31 <basti_> hi au.
06:45:56 <machack666> @type 1
06:45:59 <lambdabot> 1 :: forall t. (Num t) => t
06:46:00 <nlv11757_> there exist a class PP with a method pp; class PP a where pp :: a -> PP......im not dealing with PP anymore but with m PP for any monad m.....so i want to lift this class thingy
06:46:33 <basti_> :-O
06:47:12 <basti_> welllll.
06:47:35 * basti_ thinks a lot
06:48:07 <nlv11757_> i wanted to do, instance (monad m) => PP (m a) where....pp = liftM oldpp
06:48:08 <nlv11757_> at first
06:48:54 * basti_ tries some things
06:50:43 <basti_> uhm
06:50:48 <basti_> class (PP a,Monad b) => Paris b a where
06:50:49 <basti_>     nook :: a->b a
06:50:51 <basti_> something like that?
06:51:13 <basti_> this just works with some extensions though.
06:52:11 <basti_> actually that seems to be a rather tasty combination of types.
06:52:19 <basti_> i now think this MIGHT have some use.
06:52:21 <autrijus> is there a common haskell platform that does not support such extensions?
06:52:36 <basti_> they might be disabled by default
06:52:37 <autrijus> multiparam classes, that is
06:52:41 <basti_> but hugs and ghci can do that.
06:53:26 <skew> is there a common platform other than hugs and ghc?
06:53:29 <autrijus> nhc
06:53:38 <autrijus> which may be able to do that too
06:53:42 <nlv11757_> basti_, maybe i should do it like this; class PP a where pp :: (Monad m) => m a -> m PP
06:53:46 <autrijus> so "non standard" probably doesn't matter :)
06:53:59 <skew> I don't think nhc is too common
06:54:10 <skew> and the next closest thing is hbc
06:54:25 <skew> which I think you need to find an lml compiler to build.
06:54:26 <basti_> nlv11757_: if you think you would want to use that, sure, go ahead :)
06:54:43 <nlv11757_> hehe im just trying to figure out the best
06:54:52 <basti_> nlv11757_: i can't think of many cases where "m a -> m PP" makes sense though.
06:55:09 <skew> actually, that almost certainly doesn't make sense
06:55:19 <basti_> never say never.
06:55:19 <basti_> :)
06:55:34 <skew> if you can pretty print an a while working inside any monad m, then you can't be using any of the semantics the monad gives you
06:55:34 <basti_> maybe its the missing part in the P=NP? problem ;)
06:56:03 <skew> so you might as well provide a pure function a -> PP that you can use outside of monads too
06:56:17 <skew> and just use fmap pp when you are woking with monads
06:56:24 * basti_ nods
07:04:28 <nlv11757_> skew and basti_, this class originally was meant for ease of use. So you could use a String where actually a PPDoc was expected....so instead of demanding a function of PPDoc -> PPDoc, we just demand; (PP a) => a -> PPDoc
07:05:12 <nlv11757_> buttt now im not handling PPDocs anymore but 'm PPDoc', so i want the same thing again
07:09:55 <dons> @plugs 1 + 2
07:09:57 <lambdabot> 3
07:09:58 <dons> @pulgs 1 + 2
07:09:59 <lambdabot> 3
07:10:02 <dons> he!
07:10:26 <dons> lambdabot does spelling corrections
07:10:31 <shapr> @vixen help
07:10:31 <mflux> it should rather answer like '4' or something
07:10:32 <lambdabot> Thank God for AOL that I could meet people like you!
07:10:39 <shapr> @vixen You're not very nice.
07:10:40 <lambdabot> i'd rather be naughty than nice :)
07:10:49 <shapr> @vixen Have you met MegaMonad?
07:10:50 <lambdabot> clarify...
07:10:55 <shapr> @vixen I said...
07:10:56 <lambdabot> Wouldn't it be funny if I really was a super model?
07:10:59 <dons> @vxine megamonad is a nice guy.
07:11:00 <lambdabot> (line 1, column 16):
07:11:00 <lambdabot> unexpected end of input
07:11:00 <lambdabot> expecting simple term
07:11:10 <shapr> How'd you do that?
07:11:21 <shapr> oh wow, it calls @eval by default now?
07:11:26 <shapr> @foo
07:11:27 <lambdabot>          (__)
07:11:27 <lambdabot>          (oo)
07:11:27 <lambdabot>    /------\/
07:11:27 <lambdabot>   / |    ||
07:11:27 <lambdabot>  *  /\---/\
07:11:28 <lambdabot>     ~~   ~~
07:11:30 <lambdabot> ...."Have you mooed today?"...
07:11:31 * shapr blinks
07:11:34 <dons> looks like that's the closest by my algo.
07:11:40 <shapr> whoa, nifty
07:11:50 <dons> @vixennn megamonad is a nice guy.
07:11:51 <lambdabot> niceness all the way around
07:12:05 <shapr> that's way cool
07:12:13 <dons> :)
07:12:25 <dons> papers on this subject are fairly easy to get into
07:12:33 <dons> so I managed to find a few useful ones.
07:12:39 <shapr> nif-tay!
07:13:08 <shapr> @timmay!
07:13:08 <lambdabot> Unknown command, try @listcommands.
07:13:12 <shapr> @timmay
07:13:13 <lambdabot> dummy
07:13:32 <shapr> lambdabot is getting quite interesting.
07:13:34 <dons> maybe it should print a msg if you make a mistake, as well as runnign the command.
07:14:02 <dons> atm, it gives up if the Levinshtein/edit distance is greater than 4
07:14:33 <shapr> wow
07:14:40 <shapr> Are you hacking this out into libraries at the same time?
07:14:52 <dons> it's just sitting in Util.hs
07:15:08 <dons> but some of our string functions would make a nice lib, yeah.
07:15:45 <shapr> Yeah, Text.Lambdabot :-)
07:15:51 <dons> hehe
07:15:54 <Philippa> @vixen is megamonad a cunning linguist?
07:15:55 <lambdabot> so, what made you want to message me?
07:16:02 <shapr> oh  hey!
07:16:12 <shapr> I found a crazy connection with lambdabot, smart child!
07:16:21 <Philippa> ?
07:16:23 <shapr> http://www.odannyboy.com/blog/new_archives/smarterchild_smarter_ui.html
07:16:44 <shapr> This is fascinating, because I think lambdabot has been slowly growing in this direction too.
07:17:32 <Philippa> yeah, it's been growing features aimed at helping discussion and thought about haskell etc
07:17:58 <shapr> Right, so I've been trying to figure out what else would fit into that sort of approach.
07:18:05 <shapr> I was surprised at how many people want @index back.
07:18:17 <dons> oh, we should add it for sure.
07:19:09 <shapr> I liked the "integrate into OS" possibility.
07:19:33 <shapr> I've considered hacking @index into :index for GHCi, but I wonder where else these two approaches could meet.
07:20:02 <dons> hmm.
07:20:13 <a5> shapr: you're easily fascinated
07:20:21 * shapr hugs a5 
07:20:46 <a5> fresh
07:20:50 <shapr> code
07:20:55 <shapr> delivered to your desktop daily!
07:21:05 <a5> good morning
07:22:01 <shapr> dons: what about ghc-{users,bugs} ? Maybe a @bayes command gets question word inputs, and looks for highest rated mailing list posts, and gives urls to replies?
07:22:20 <dons> that'd be cool.
07:23:16 <dons> I think that's the kind of place we're heading. Stuff for getting at the fragments of haskell knowledge spread around the place
07:24:22 <shapr> I thought about a 'gossip' service that integrates various feeds, nntp/smtp/http and lets the users choose the subject, and filter by condition.
07:24:58 <shapr> For example, subject haskell, search for type slicing
07:25:34 <shapr> searched inputs would include mailing lists, html-only like lambda-the-ultimate, comp.lang.functional, etc
07:25:41 <dons> hmm. yeah.
07:26:11 <shapr> I also realized CiteSeer should include an RSS feed.
07:26:29 <shapr> That way people could subscribe via keyword, citation in any direction, author, conference, whatever.
07:26:30 <dons> that would be nice
07:26:53 <a5> we should write a new prelude with fewer warts
07:27:08 <shapr> a5: look at semantic.org
07:27:28 <dons> ok, /me has to get some sleep.
07:27:32 <shapr> g'night dons!
07:27:33 <dons> so much code to write, so little time
07:27:35 <shapr> yeah, tru
07:29:27 <a5> is HBase better?
07:29:54 <shapr> It's different, that's for sure.
07:30:53 <a5> hmm. *shrug*
07:31:21 <musasabi> shapr: a citeseer rss feed would be catastrophic - we would just spend all the time reading interesting papers and never get any code out.
07:31:32 <shapr> musasabi: I can realllly fast.
07:31:35 <shapr> ahem "can read"
07:31:52 <shapr> It takes me a lot longer to write about stuff though.
07:32:05 <a5> i was thinking something more compatible. like the normal prelude, but where Monad derives Functor and various type signatures are fixed
07:32:11 <musasabi> true, especially if one just glosses over the text.
07:32:24 <a5> but i don't know what i was thinking...
07:32:35 <shapr> a5: have you seen @@wiki HaskellTwo?
07:32:45 <shapr> @wiki HaskellTwo
07:32:46 <lambdabot> http://www.haskell.org/hawiki/HaskellTwo
07:34:41 <shapr> I've been thinking about how I use email, and what existing services could replace my email use.
07:35:13 <shapr> gmane.org is the best thing going for mailing lists, that cuts out most of my email traffic.
07:35:26 <shapr> After that, it's personal email and sysadmin notifications.
07:35:40 <shapr> notifications could go the same way, via RSS or something similar.
07:35:51 <shapr> I'm not sure about personal email though.
07:36:11 * musasabi does not like the idea of turning everything into a web thingy.
07:36:25 <Philippa> I really don't
07:36:33 <Philippa> local caching matters
07:37:56 <a5> shapr: no, looking...
07:41:58 <shapr> musasabi: I'd like to find some general path to a pull system, I think email will continue to have more and more spam.
07:44:27 <a5> the ubiquitous "Org.Org.Semantic.HBase" qualification sure gets annoying...
07:44:32 * shapr agrees
07:45:37 <a5> there should be a way to remap module namespaces on the compile command line or something
07:45:42 <a5> "compiler"
07:47:04 <shapr> You've got import qualified Org.Org.Semantic.HBase as HB
07:48:04 <blackdog> shapr: i think email is a target because everybody has it. if everyone got everything through rss, you'd see a lot more spam there too.
07:48:27 <blackdog> it's like macos (pre X) not having many viruses, despite not being particularly robust security-wise
07:49:09 <shapr> It's hard to spam RSS when people can just unsubscribe.
07:49:19 <shapr> I can't unsubscribe to email because my domain names need updating.
07:49:36 <shapr> So maybe it's the ICANN/SMTP dependency loop?
07:53:35 <blackdog> shapr: if you want to participate in an unmoderated community, surely it's unavoidable?
07:55:05 <shapr> Not necessarily.
07:55:52 <shapr> You can develop with darcs and make your repos accessible via http, and then other people can pull changes from you.
07:55:56 <blackdog> ...thinking... you could always just subscribe to blogs, and add other blogs only by personal recommendation. that way you've got some kind of trust metric...
07:56:12 <blackdog> yeah, it's still a one-to-one kind of relationship, though.
07:56:19 <shapr> If you get a bunch of people developing with that pattern on the same project, they all read from each other.
07:56:44 <shapr> Now let's say that project isn't source code, but instead a bunch of text files like a wiki.
07:57:12 <shapr> Then you have that personal recommendation as you said.
07:57:18 <vincenz> Woah
07:57:26 <shapr> I only pull wiki updates from the people that I know on #haskell.
07:57:31 <shapr> But they know people that I don't know.
07:57:33 * vincenz just read the intro chapter on monads in "a gentle introduction"
07:57:37 <vincenz> the idea of computation fuel :)
08:00:46 <shapr> blackdog: think it could work?
08:01:22 <shapr> I think a peer to peer DNS would be required to totally break the ICANN/SMTP dependency.
08:03:24 <blackdog> shapr: maybe. i think you have to be very careful about closing off a community too much - everyone was a newbie once, and you don't start off trusted by anyone. you need to make sure your community stays reasonably open or it dies...
08:04:27 <shapr> I think you do start off trusted by someone.
08:04:54 <shapr> Social strategies usually involve giving a trust 'loan' to someone in the beginning.
08:04:59 <shapr> This my opinion, of course.
08:05:33 <shapr> greetings Darius
08:05:39 <Darius> heya shapr
08:06:03 <blackdog> So if an anonymous-ish person has a non-zero amount of trust, it's easy for a spammer to create an identity, spam, and leave.
08:06:19 <blackdog> i don't see how this changes anything.
08:06:21 <Darius> Hmm, freenode is not bothering me about a password, perhaps whoever registered Darius unregistered
08:06:51 <shapr> That whoever is Darius Bacon, and he's still registered.
08:07:04 <shapr> He also said that you could have the Darius nick if you want it.
08:08:11 <shapr> blackdog: I think newbies would have to have some content to get in.
08:08:27 <shapr> read-only is free, write privs require content.
08:09:12 <blackdog> taking #haskell as an example - does asking feckless homework questions count as content? That's at least half our newbies... :)
08:09:48 <shapr> hm, good point.
08:09:58 * shapr thinks about that
08:12:07 <shapr> hej nibro
08:13:08 <nibro> hej shapr :)
08:13:47 <nibro> ready to rock?
08:13:59 * Darius wonders what you guys are talking about.
08:14:01 <nlv11757_> get perpendicular
08:14:24 <shapr> nibro: yeah!
08:14:54 <nibro> shapr: so how far did you get before?
08:15:12 <shapr> um.. I have everything installed, but haven't tried the demos yet.
08:15:41 <nibro> I actually forgot one part of the installation, but as long as you won't use sessions that
08:15:48 <nibro> ... that's ok for now
08:16:21 <nibro> ok, then fire it up. hspr -p (some port nr)
08:17:28 <nlv11757_> @type uncurryM
08:17:30 <lambdabot> bzzt
08:17:42 <shapr> foo, permissions problems again, needs chmod ugo+x
08:17:55 <shapr> hmm
08:18:05 <shapr> hspr: /users/cs/d00nibro/tmp/etc/hspr/.filemap: openFile: does not exist (No such file or directory)
08:18:35 <blackdog> bah. annoying. I was doing one of the linuxonpower.com ports, and it turns out to be totally trivial. no g5 for me, i fear.
08:18:42 <nibro> doh, I wrote .pagemap in the instructions
08:18:58 <nibro> but... huh, why my path?
08:19:06 <nibro> didn't you do the .configure stuff?
08:19:17 <shapr> er, I did runhaskell Setup.hs configure
08:19:28 <nibro> ... which is broken
08:19:35 <shapr> oh
08:19:36 <nibro> do you have the INSTALL file?
08:19:51 <shapr> Yes, now reading it too. (oops)
08:21:40 <nibro> shapr: I updated the INSTALL file, do a darcs pull
08:22:06 <shapr> ok
08:23:31 <shapr> configure complains that it can't find install.sh, maybe autoconf version problem?
08:24:33 <nibro> could be, hang on, I'll add it
08:25:33 <nibro> done, pull again
08:25:55 <shapr> yay!
08:28:26 <shapr> I think you need "cp -r " in the INSTALL file.
08:29:44 <nibro> true
08:30:00 <nibro> and .o should be -o of course
08:30:29 <machack666> which haskell interpreter is best for interactive mode?  I've got hugs installed, but I cannot seem to define types and the like in the interactive mode.</newbie>
08:30:52 <shapr> The configure --with-server-root= seems to be failing. When I run hspr I get "hspr: /usr/local/etc/hspr/.filemap: openFile: does not exist (No such file or directory)"
08:31:01 <shapr> machack666: I'd recommend GHCi
08:31:15 <shapr> You can define functions interactively with GHCi, but not types.
08:31:44 <shapr> I use emacs' haskell-mode and C-c C-l in a Haskell source buffer loads that into GHCi.
08:31:47 <machack666> is that part of the ghc distribution?
08:31:53 <shapr> Yes it is.
08:32:00 <nibro> machack666: there's no interpreter that allows you to define types interactively, I second shapr's suggestion for ghci
08:32:05 <machack666> then I should have it installed already
08:32:24 <machack666> I guess that makes sense what with the type safety.
08:32:34 <araujo> Good morning.
08:32:50 <nibro> shapr: does the file exist then? :)
08:33:12 <shapr> when I run configure "checking for "/home/shae/public_html/"... yes"
08:33:32 <shapr> Though I also get "./configure: line 1380: DbSpec.hs: command not found"
08:34:02 <nibro> huh? wierd, let me look into it
08:34:10 * shapr gets a sandwich
08:36:00 <nibro> shapr: configure shouldn't even mention DbSpec
08:43:01 <nlv11757_> @plugs liftM2 (+) (Just 1) Nothing
08:43:07 <lambdabot> Nothing
08:43:31 <nlv11757_> what makes a lifted + behave like this
08:43:38 <Darius> machack666: It actually doesn't make that much sense, the only argument for it is Haskell allows mutually recursive functions to be written anywhere.
08:44:01 <nlv11757_> how does it know to use Nothing....(+) only knows about integers
08:44:20 <Darius> machack666: Which would be a bit tricky in a REPL.  I think the MLs which typically have (fuller) repls, require mutually recursive things to be declared together.
08:44:32 <nibro> @plugs lift (+) (Just 1) Nothing
08:44:40 <lambdabot> Variable not in scope: `lift'
08:44:59 <Darius> nlv11757_: liftM2 (+) (Just 1) Nothing = do x <- Just 1; y <- Nothing; return (x+y)
08:45:18 <nibro> @type liftM2
08:45:23 <nlv11757_> where is that definition darius?
08:45:23 <lambdabot> bzzt
08:45:44 <Igloo> nlv11757_: The liftM2 knows about the Nothings, and it calls (+) only if there are none
08:46:38 <nlv11757_> liftM2 always does the following then; liftM2 f a b = do x<- a; y <- b; return (f x y)
08:46:59 <nlv11757_> probably if i saw the definition of liftM2 it makes sense
08:47:58 <earthy> wel, probably not. :)
08:48:23 <nlv11757_> ow
08:48:34 <nlv11757_> then how will i know it has this behaviour
08:48:41 <earthy> actually, it does have that behaviour.
08:48:42 <earthy> \a b -> do { a' <- a; b' <- b; return (f a' b') }
08:48:52 <nlv11757_> ow it does
08:49:01 <earthy> liftM2 f          = \a b -> do { a' <- a; b' <- b; return (f a' b') }
08:49:02 <earthy> that is
08:49:25 <earthy> M3, M4 and M5 are defined accordingly
08:49:36 <nlv11757_> but its not defined like that, judging from your reaction '...well probably not. :) ...'
08:50:01 <earthy> it's monadic code
08:50:07 <earthy> that usually doesn't make any sense
08:50:11 <nlv11757_> ow hehehe
08:50:15 <earthy> however, in this particular case, it does. :P
08:50:36 <nlv11757_> you rather not use monads then?
08:50:42 <nlv11757_> if you feel the code usually doesnt make sense?
08:50:46 <shapr> hej Orangosaurus
08:51:12 <earthy> oh no, monads are *very* useful
08:51:22 <earthy> it just takes a lot of understanding to grasp some of the finer details
08:51:27 <shapr> nibro: too bad I can't set the root from the command-line.
08:51:45 <nibro> shapr: what root do you mean?
08:52:01 <nibro> you can use --prefix= to set the root dir of the installation
08:52:02 <shapr> the $PREFIX
08:52:09 <shapr> when executing hspr?
08:52:17 <nibro> no, when compiling it
08:52:24 <shapr> hm
08:52:25 <nibro> or configuring it rather
08:52:38 * machack666 successfully has haskell-mode working
08:52:42 <machack666> woo hoo!
08:53:00 <yaarg> in emacs?
08:53:00 <basti_> machack666: :)
08:53:06 <nibro> if you mean the virtual "root" of the server, that's --with-server-root
08:53:33 <machack666> yes
08:53:34 <Darius> earthy: There are no fine details in liftM2
08:53:35 <nibro> you hae to give the --prefix flag to ./configure, not to runhaskell Setup.hs configure
08:54:13 <machack666> basti_: thanks for all your help earlier
08:54:35 <basti_> machack666: no problem. i like helping educated people :)
08:54:57 * machack666 is glad he is educated
08:55:14 <basti_> where are you from?
08:55:14 <nlv11757_> im breaking my head over trying to *really* understand whats going on
08:55:25 <basti_> nlv11757_: where?
08:55:49 <nlv11757_> ow just when to decide that there's a monad in something
08:55:53 <nlv11757_> doing it, blablabal
08:56:07 <basti_> you rarely need to declare an own type
08:57:23 <Darius> nlv11757_: You had the definition of liftM2 right.
08:57:46 <Darius> You understand why do x <- Just 1; y <- Nothing; return (x+y) returns Nothing right?
08:58:44 <basti_> uhm monad i wanted to say
08:58:53 <earthy> darius: I saw that when looking up the definition :)
08:59:50 * basti_ lets emacs work for its own obsoletion.
08:59:52 <gzl> er, where is POpen?
09:00:59 <gzl> someone suggested using this yesterday for grabbing the output of an external command
09:01:07 <nibro> gzl: in -package unix I believe
09:01:36 <gzl> aha.
09:01:44 <nlv11757_> Darius, i didnt have the definition. So therefor i didnt get it why. After seeing the definition its logical
09:02:03 <gzl> nibro: er, 'ghci -package unix foo.hs' still doesn't find it.
09:03:11 <nibro> gzl: ah, sorry, should have been -package posix
09:03:21 <gzl> aha.
09:03:34 <gzl> ah, here we go. thanks.
09:04:51 <nibro> shapr: any luck
09:04:53 <nibro> ?
09:05:33 <shapr> It seems that Setup.hs clean wipes out everything, but then I can't just run ./configure, I have to run Setup.hs configure before Setup.hs build will work.
09:05:36 <nlv11757_> i call it a day
09:05:38 <nlv11757_> cu all
09:06:04 * shapr har lite frustration
09:06:38 * basti_ tickles yi
09:06:54 <nibro> shapr: I know, I know
09:07:22 <nibro> shapr: Lemmih says he fixed that bug in cabal though, it will be better in the next release... ;)
09:07:44 <nibro> but if you follow the instructions in the INSTALL file it should work fine
09:07:52 <shapr> spiffy
09:08:14 <shapr> oh, I left out a step, doh!
09:08:14 <basti_> does anyone know about a nice way to do dynamic (stateful) 2 way mapping?
09:08:20 * vegai has a simple Makefile to do the Cabalistic tasks
09:08:28 <basti_> hashtable? ioref alist (YUCK?)?
09:09:33 <basti_> @type \\
09:09:34 <lambdabot> bzzt
09:09:37 <basti_> @type (\\)
09:09:38 <lambdabot> bzzt
09:09:39 <nibro> vegai: I know, it's on the todo list ;)
09:09:52 <nibro> @type Data.List.(\\)
09:09:54 <lambdabot> bzzt
09:10:11 <vegai> nibro: hm?
09:10:26 <nibro> vegai: the cabalistic makefile
09:10:33 <vegai> I'm just too comfortable with saying 'make' instead of 'runghc Setup.ghc config && runghc Setup.ghc build"  ;)
09:10:46 * nibro agrees
09:10:47 <vegai> oh, right
09:11:19 <nibro> basti_: (\\) :: [a] -> [a] -> [a] iirc
09:11:33 <nibro> should be the intersection, right?
09:11:41 <nibro> sorry, set difference I mean
09:11:47 <basti_> setminus apparently
09:11:58 <nibro> @plugs [1,2,3] \\ [3]
09:11:58 <basti_> @plugs [1..5] \\ [2]
09:11:59 <lambdabot> [1,2]
09:12:00 <lambdabot> [1,3,4,5]
09:12:01 <basti_> hehe
09:12:05 <nibro> ;)
09:12:10 <nibro> beat ya! ;)
09:12:29 <shapr> nibro: same problem
09:12:30 <basti_> i'd need something along the lines of [(a,b)] -> a -> b resp. [(a,b)] -> b -> a
09:12:44 <shapr> still it asks for /usr/local/etc/hspr/.filemap
09:12:45 <basti_> dynamic.
09:13:08 <basti_> alist? -sighs-
09:13:11 <nibro> shapr: check if the file exists
09:13:11 <vincenz> basti_: you maen an assoc list
09:13:20 <basti_> yes but it would be bidirectional.
09:13:20 <nibro> ls -l /usr/local/etc/hspr/.filemap
09:13:41 <vincenz> basti_: what's so hard about that?
09:13:42 <basti_> and it needs to be run time modifiable
09:14:03 <basti_> should i really go the fun way and implement this as being passed?
09:14:08 <basti_> i  mean it would be rarely changed.
09:14:13 <nibro> shapr: it *should* ask for that file, assuming your $PREFIX is unchanged
09:14:23 <basti_> that would be a "pro" there.
09:14:25 <shapr> nibro: The problem is, that's not the prefix I set. I asked for /home/shae/public_html and created /home/shae/public_html/etc/hspr etc
09:14:38 <nibro> hmm...
09:15:09 <nibro> and you did run ./configure *after* setup configure?
09:15:28 <shapr> yes, this time I did.
09:15:34 <nibro> and gave the --prefix to the latter, not the former
09:15:40 <shapr> right
09:15:41 <nibro> eh, the later that is
09:15:46 <nibro> ./configure
09:15:55 <shapr> ./configure --with-server-root=/home/shae/public_html/ --with-sessiondb-driver=PostgreSQL --with-sessiondb-host=localhost --with-sessiondb-name=sessions --with-sessiondb-uid=www-data --with-sessiondb-pwd=''
09:16:14 <nibro> ah, but --with-server-root /= --prefix
09:16:14 <basti_> dons: are you there?
09:16:23 * shapr dohs
09:16:57 <machack666> do you guys have a pastebot?
09:17:05 <shapr> @paste
09:17:05 <nibro> --with-server-root=X means that the server will expect to find your web pages in X
09:17:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:17:16 <machack666> thanks
09:19:10 <basti_> hmm
09:19:31 <basti_> is it a good idea to "stack" types as in "Maybe (Either This That)"?
09:19:42 <basti_> or is this a sign of something going haywire.
09:19:45 <basti_> in my brain.
09:20:08 <basti_> but, i do'nt need at all!
09:20:08 <basti_> :)
09:20:10 <shapr> nibro: yay! it works!
09:20:32 <Cale> It might be neessary, but if it gets unwieldy, look at it carefully, and see if there's a better type for things.
09:20:51 <machack666> ok, baby steps here...
09:21:22 <machack666> I've got a fibbonacci sequence generator on the paste page
09:21:58 <machack666> where I pass an integer to the fib function and get back the corresponding sequence number
09:22:11 <machack666> when I do fib 7 or fib 13, it works fine
09:22:21 <machack666> but it starts to hang terribly when I do fib 99
09:22:32 <machack666> am I doing something naively?
09:22:49 <machack666> (or, should I say, what is it that I am doing naively?)
09:23:59 <gzl> shapr, got a minute? i'm trying to use POpen, WASH, and Parsec together, and I'm confusing myself over the types.
09:24:03 <shapr> well, I wouldn't use n+1 patterns first of all
09:24:08 <shapr> gzl: oooh scary
09:24:21 <gzl> what I'm trying to do is simple, though. not a lot of code involved.
09:24:39 <shapr> sure, hit me
09:25:33 <shapr> machack666: for one thing, you're recalculating everything for each subsequent call
09:25:47 <gzl> ok, so I have a String containing an argument to some external command. I want to run the external cmd with popen, grab the stuff it prints to stdout, parse some of the output into a String s, and then return (rawtext s).
09:25:51 <shapr> Since common subexpression elimination isn't done by default.
09:26:28 <gzl> so I'm not sure how to organize the functions so that all the monads don't step on each other.
09:26:52 <nibro> shapr: it works == you managed to request a page through a browser and got the correct page back?
09:27:09 <nibro> if so, then =oD
09:28:03 <basti_> ooo00000f.
09:28:11 * basti_ had a phase transition in his yi emacs stuff.
09:28:13 <shapr> Error specification: \n Error in server: mkstemps : couldn't create temp file please report as a bug to d00nibro@licia.dtek.chalmers.se
09:28:28 <basti_> 57 lines of errors
09:29:40 <shapr> wow, cool
09:29:49 <shapr> gzl: WASH has a liftIO equivalent
09:29:55 <gzl> shapr: yeah, it's called 'io'
09:30:14 <autrijus> io = liftIO ?
09:30:20 <autrijus> that's neat.
09:30:21 <shapr> In WASH at least.
09:30:25 <gzl> yeah.
09:30:26 <autrijus> maybe I should do that in pugs too
09:30:35 <gzl> io :: IO a -> CGI a or something
09:30:41 <shapr> imho, the significant name is better.
09:30:44 <autrijus> io :: IO a -> Eval a
09:31:04 <autrijus> you think so? ok then :)
09:31:11 <shapr> liftEval?
09:31:12 <shapr> I dunno
09:31:15 <autrijus> er no
09:31:22 <autrijus> liftEval means something Entirely Else.
09:31:22 <shapr> I'm just a great fan of significant names.
09:31:35 * shapr puts his eval into a backpack.
09:31:51 * TheHunter thinks stuff that's used frequently doesn't need a significant name.
09:31:59 <autrijus> liftEval :: (MonadEval m) => Eval a -> m a
09:32:07 <autrijus> but we actually want the reverse
09:32:11 <shapr> I think regular names are very important.
09:32:20 <shapr> I can't remember details, but I can remembers patterns and heuristics.
09:32:40 <autrijus> io :: IO a -> Eval a
09:32:57 <gzl> shapr: the problem is that I think the types still don't match. one is WithHTML blah and the other is CGI
09:33:15 <TheHunter> often, the type signature says everything anyway.
09:33:40 <shapr> But for the writing side instead of the reading side, regular names are important.
09:33:48 <shapr> Actually, I think it's important for reading also.
09:34:28 <shapr> In fact, I think that the more regular your names are, the more your software will be developed. I think that increased understandability and readability means lower barriers to entry for new developers.
09:34:40 <shapr> And Open Source is resource intensive, the resources are the minds of the developers.
09:34:40 <TheHunter> i always have a hard time coming up with names.
09:35:11 <shapr> There's a comment about this on LtU today, someone said the hardest part for him is understanding existing code well enough to modify it for his own purposes.
09:35:20 <TheHunter> yes, but I rather have short (or even meaningless) qualified names than verbose names.
09:35:35 <shapr> So I think simplicity, regularity, whatever allows readers to understand more easily, that is good.
09:36:05 <shapr> Qualified names definitely ease my reading.
09:36:06 <KrispyKringle> Can I pick someone's brain on haskellDB for a moment? Anyone here familiar with it?
09:36:12 <shapr> I've heard of it!
09:36:36 <tuomov> I prefer short qualified names too
09:36:57 <shapr> TheHunter: I don't mind verbose names like 'liftIO'. Can you give examples of what you consider overly verbose?
09:37:04 <KrispyKringle> shapr: were you talking to me?
09:37:06 <shapr> KrispyKringle: go ahead, ask
09:37:06 <tuomov> liftIO is short..
09:37:23 <tuomov> I mean somethine like gtk_foobar_do_something_please_now
09:37:28 <nibro> in HSP it's called doIO :)
09:37:39 <nibro> doIO :: IO a -> HSP a
09:37:53 <KrispyKringle> shapr: Well, I'm just trying to figure out how to do inserts, since the docs are kinda sparse. I've got a connection from genericConnect, so I want to do something like myConnection $ \db -> ... ?
09:37:54 <TheHunter> shapr, well Data.FiniteMap is an example for bad naming.
09:37:56 <shapr> There was a recent discussion on libraries@h.o about listToFM as opposed to Data.Map.fromList and Data.FiniteMap.fromList, I think that's interesting.
09:38:06 <shapr> TheHunter: yeah, it needs updating.
09:38:30 <tuomov> err.. hasn't it been updatd already?
09:38:36 <TheHunter> it's already deprecated.
09:38:37 <shapr> has it?
09:38:43 <shapr> The names were changed?
09:38:46 <tuomov> It's Data.Map now and the FM suffixes have been removed
09:39:03 <gzl> shapr: ok. well, I got it working with unsafePerformIO, which means it at least works, and now I can yank unsafe out. :)
09:39:04 <KrispyKringle> shapr: I did osmething like this (http://rafb.net/paste/results/Anm1Qz74.html), but it doesn't typecheck...
09:39:06 <shapr> KrispyKringle: Did you look at the examples in test/ and the tutorial on the Wiki?
09:39:19 <KrispyKringle> shapr: I read the wiki, yes. I'll check out test/
09:40:01 <KrispyKringle> shapr: what's going on with the line "import Dp037.Test_tb1
09:40:02 <shapr> tuomov: but that's a whole new module, isn't FM still around with the old names?
09:40:05 <KrispyKringle> ?
09:40:10 <shapr> that's the DBSpec
09:40:25 <shapr> You can define your own tables in a backend agnostic manner.
09:40:26 <tuomov> shapr: I don't know.. I just noticed when accidentally browsing the docs for 6.4
09:40:33 <KrispyKringle> shapr: so I have to generate a module using DBspec first? I thought creating the table via haskelldb means I don't need to worry about that?
09:40:38 <shapr> no, you don't
09:40:42 <shapr> but you can if you really want to.
09:40:58 <KrispyKringle> i don't want to worry about things i don't have to, i fthat's what you mean ;)
09:41:13 <shapr> HaskellDB swings both ways, create your own from inside HaskellDB, or just work with existing tables.
09:41:22 <KrispyKringle> but the problem with my demo code is that I was using a TInfo for my Table (for the insert). So where do I get the Table from?
09:41:58 <KrispyKringle> Does that make sense? I'll pase my complete code....
09:42:04 <TheHunter> my point is, if the barrier to understand a commonly used library function is high, the name doesn't really matter, so it might as well be short.
09:42:05 <shapr> look at insert-update-delete.hs
09:42:19 <KrispyKringle> right, but isn't it using the DBConnect-generated module?
09:42:25 <shapr> Nah, doesn't really matter.
09:42:33 <KrispyKringle> To avoid that, I neeed to generate a Test-type some other way, right?
09:42:36 <KrispyKringle> er, Table-type
09:42:57 <nibro> shapr: the mkstemp problem I don't know how to solve :(
09:43:11 <shapr> HaskellDB can generate the files to describe your tables and that's how you get your own file to import.
09:43:11 <nibro> that's from hs-plugins
09:43:29 <shapr> is it trying to create stuff in $PREFIX/etc ?
09:43:33 <KrispyKringle> Ah. OK. I didn't realize that was mandatory.
09:43:49 <nibro> no, it tries /tmp I think
09:44:02 <nibro> it's out of my hands, that's dons' stuff
09:44:13 <nibro> ah, no wait
09:44:24 * nibro is stupid
09:44:28 <shapr> Strangely, it gives a correct 404, and only gives the mkstemp error when I request an existing file.
09:44:58 <nibro> shapr: 404, you sure? not a 500 Internal server error then?
09:45:07 <shapr> that's correct.
09:45:23 <nibro> mkstemps should try to create the file in $PREFIX/etc/compiled
09:45:32 <nibro> do you have that dir?
09:45:43 <nibro> or rather
09:45:47 <nibro> mkstemps should try to create the file in $PREFIX/etc/compiled
09:45:49 <shapr> new error - "Error in server: /tmp/ghc27933.hspp:(21,4)-(41,37): Non-exhaustive patterns in case please report as a bug to d00nibro@licia.dtek.chalmers.se"
09:45:52 <nibro> gah
09:46:02 <KrispyKringle> ah, shapr, that's very much :)
09:46:03 <nibro> $PREFIX/etc/hspr/compiled
09:46:17 <TheHunter> also, you can often afford using non-meaninful names in haskell because type signatures are so expressive.
09:46:20 <KrispyKringle> i might harass you some more as i go, though. ;)
09:46:44 <nibro> shapr: gee, don't you just love the error messages from post-processed files ;)
09:46:46 <gzl> what's the simplest way of replacing every \ in a String with \\ ?
09:46:49 <shapr> nibro: I'd like to install hspr and the other binaries in /usr/local/ but I'd like the data files elsewhere.
09:46:50 * TheHunter wishes ghc allowed to declare types more than ones
09:46:56 <gzl> is there a built-in to do that escaping?
09:47:21 <basti_> data EmacsState a = ES CommandSequence (KeyBinding a)
09:47:25 <basti_> whats wrong with that?
09:48:24 <nibro> shapr: with data files you mean your pages? or the server internals?
09:48:33 <KrispyKringle> gzl: i can think of an ugly way to do it.
09:48:47 <gzl> KrispyKringle: I was hoping for a nice one.
09:48:48 <KrispyKringle> using two map calls and a concat
09:48:50 <shapr> I'd like to put the stuff in $PREFIX/etc/ into my home dir
09:49:10 <nibro> shapr: I've been lazy and haven't implemented that distinction
09:49:13 <shapr> ah, ok
09:49:20 <nibro> shapr: you can do it manually though
09:49:36 <nibro> just hack the file hspr/HSPR/Utils.hs and then recompile
09:49:43 <shapr> will do
09:50:35 <nibro> shapr: I'm really curious as to that non-exhaustive pattern, I wonder which file ghc27933.hspp is...
09:50:41 <gzl> there are usually things in the Prelude for this kind of thing. shapr, you happen to know of a nice way of replacing every \ in a String with \\ ? or am I stuck doing something nasty?
09:51:46 <shapr> nibro: it's gone, sadly
09:51:51 <TheHunter> gzl, to escape strings, show works fine.
09:52:08 <nibro> shapr: too bad :(
09:52:38 <nibro> gzl: escape "" = ""
09:52:56 <nibro> escape '\':s = '\':'\':escape s
09:52:58 <gzl> oh, nice.
09:53:09 <nibro> escape c:s = c:escape s
09:53:39 <nibro> @plugs show "\"
09:53:40 <lambdabot> lexical error in string/character literal
09:53:45 <nibro> @plugs show "\\"
09:53:46 <shapr> w00 "File did not compile: parse error in /home/shae/public_html//foo.html line: 1, col: 1"
09:53:46 <lambdabot> "\"\\\\\""
09:54:09 <nibro> shapr: did you try to add a !#/.... line or what?
09:54:20 <mwc> Is dons around?
09:54:30 <shapr> nah, foo.html is just a boring html file.
09:54:37 <shapr> @seen dons
09:54:37 <ozone> dons: it's 3am here, it's pretty likely that he's asleep
09:54:38 <lambdabot> dons is in #haskell. Last spoke 2 hours 27 minutes 4 seconds ago.
09:54:42 <nibro> mwc: he's aussie, so probably not ;)
09:54:47 <jlouis> hes probably sleeping
09:55:05 <nibro> shapr: the raw server only works for .hsp files :-\
09:55:15 <shapr> no worries, this is a step forward
09:55:47 <nibro> aha, did you get that "Non-exhaustive ..." stuff when requesting the same file?
09:56:15 <shapr> No, I get a blank page the next time I request the same thing. Weird.
09:57:04 <nibro> shapr: what browser?
09:57:37 <nibro> shapr: I get that error with IE, I think it has to do with keep-alives but not sure
09:57:42 <shapr> galeon
09:58:04 <nibro> heh, no idea what that is
09:58:09 <shapr> I haven't had a copy of windows in several years. That's also why I just returned today the Sony mp3 spelare I bought yesterday.
09:58:20 <nibro> time to have some dinner, bbl
09:58:21 <shapr> mozilla
09:58:55 <gzl> nibro: don't you need to write '\\' instead of '\' ?
09:59:09 <tuomov> I refuse to buy an mp3 player that doesn't show up as standard usb storage
09:59:22 <tuomov> It's absolutely brain-damaged to do it any other way
09:59:32 <shapr> Now I know.
09:59:57 <tuomov> unfortunately the majority of players seem to use proprietary mechanisms
10:00:09 <Lemmih> ozone: Why is a Apache Haskell module not a feasible option in GHC?
10:00:29 <shapr> I just ordered a 1GB iRiver. Surprisingly, it's cheaper and has more features than the Sony I brought back.
10:00:48 <KrispyKringle> hey shapr, would you mind looking at (http://rafb.net/paste/results/UFZJ7F50.html)? I get an error on line 6, "Expected type: String, Inferred type: Maybe a". Anything obviously wrong there?
10:00:51 <tuomov> I have a 20GB iRiver as well
10:00:58 <tuomov> well, not 20 anymore..
10:01:32 <tuomov> hd players are a bit too fragile, and others too small
10:01:49 <shapr> I want to unicycle with my player, that's why I got a 1GB flash.
10:02:02 <shapr> I am positive a hard drive will not survive.
10:02:32 <shapr> KrispyKringle: if you use NOT NULL on the column you don't need constant or constJust
10:03:09 <tuomov> It wouldn't. I accidentally dropped the player from my jacket's inside pocket and lost about 4GB in the process
10:03:18 <shapr> suck :-(
10:03:28 <shapr> I fully expect to land on my player at high speed.
10:03:40 <mwc> my iPod jumped out of my pocket while I was running to a cross walk
10:03:49 <mwc> totally fine, just a scratch on the aluminum
10:03:55 <mwc> 20 GB
10:04:02 <tuomov> depends on if it is trying to read the disk etc.
10:04:06 <mwc> True
10:04:12 <shapr> Was yours playing when it fell?
10:04:14 <gzl> nibro: yeah, this thing takes neither '\' nor '\\'
10:04:17 <mwc> I was playing at the time but it was probably cahced
10:04:28 <tuomov> the players only read the disk occasionally
10:04:33 <tuomov> otherwise they'd be broken in minutes
10:04:37 <tuomov> and out of battery too
10:05:08 <shapr> Well, iRiver does Ogg and works as a boring usb storage device, so I'm happy.
10:05:12 <ozone> Lemmih: it would need to be a dynamic library
10:05:27 <ozone> you can't compile haskell to a dynamic library yet, except on mac os x
10:05:29 <Lemmih> ozone: Why?
10:05:39 <ozone> as i said in the email, it doesn't have to be a dynamic library
10:05:42 <Lemmih> ozone: What about using hs-plugins?
10:05:50 <ozone> but it would mean building a custom version of apache
10:05:54 <KrispyKringle> shapr: nodeId = CInfo {cname = "nodeid", descr = (StringT, True)}
10:06:00 <Lemmih> ozone: How so?
10:06:03 <KrispyKringle> that boolean means NOT NULL, right/
10:06:04 <KrispyKringle> ?
10:06:13 <ozone> Lemmih: you can't use hs-plugins; that can't load .so's
10:06:16 <shapr> um, I forget
10:06:23 <ozone> apache requries the module be a .so
10:06:49 <ozone> unless, as i said, you build a custom version of apache that has mod_haskell statically linked in
10:07:02 <ozone> but that's probably not what graham had in mind
10:07:07 * Lemmih hacked a ModHaskell which loaded Haskell modules at run-time via hs-plugins.
10:07:31 <Lemmih> And it worked really well.
10:07:33 <ozone> hs-plugins won't load .so's
10:07:59 <ozone> and hs-plugins can't be a .so, since GHC doesn't generate PIC/dynamic code properly yet
10:08:10 <ozone> (it will sometimes work, sometimes not)
10:08:11 <KrispyKringle> shapr: because when i don't use constant and Just, it says it expected [Maybe String]
10:08:23 <shapr> tried using constJust instead?
10:08:34 <KrispyKringle> nope, but i will now
10:08:57 <Lemmih> I don't see why you want to load .so's...
10:09:03 <KrispyKringle> Expected type: String
10:09:03 <KrispyKringle>         Inferred type: Maybe a
10:09:09 <KrispyKringle> no luck
10:09:37 <ozone> Lemmih: so, your mod_haskell was a standard apache .so module?
10:09:41 <KrispyKringle> but it seems the expected type keeps changing. i can't figure that out.
10:09:50 <Lemmih> ozone: Yes.
10:09:58 <KrispyKringle> oh, wait
10:10:29 <ozone> Lemmih: that's interesting.  perhaps wolfgang's work on generating PIC code works well enough now to do that
10:10:34 <sylvan> Lemmih: You didn't need to compile a custom apache to get it to run haskell?
10:10:37 <sylvan> cool
10:10:45 <shapr> I don't think x86 PIC works yet.
10:11:10 <KrispyKringle> constJust works for the not null field, so i guess that makes sense.
10:11:26 <Lemmih> sylvan: Of course not. Haskell is just a macro language for C (:
10:11:37 <Lunar^> shapr: Does Wolfgang ever come here?
10:11:49 <shapr> twice
10:11:54 <ozone> Lemmih: ah, looks like it has indeed
10:11:55 <shapr> once long ago, once recently
10:12:01 <ozone> see http://haskell.org/hawiki/DynamicLinkingInGhc
10:12:09 <KrispyKringle> shapr: once again, thanks for your help. looks like im on the road to successfully inserting into SQLite :)
10:12:11 <Cale> You could probably reach him through desrt
10:12:20 <ozone> as long as you go via the NCG, it's OK
10:12:41 <ozone> well, more-or-less OK :)
10:12:52 <ozone> Lemmih: you may want to post an email correcting me, then
10:12:57 <wilx> Hmm...Can't it generate PIC code using underlying C compiler?
10:13:03 <Lunar^> shapr: I would be glad to talk to him, if he ever come again
10:13:19 <Lemmih> hs-plugins can't load a module compiled with -fvia-c?
10:13:35 <ozone> wilx: see the webpage, the mangler needs to be updated
10:13:52 <ozone> Lemmih: guess not
10:13:59 <wilx> Hm...
10:15:01 <Lemmih> Was there any x86 linux PIC code in GHC 6.2?
10:15:16 <ozone> Lemmih: no
10:15:29 <ozone> though, if you were lucky, it might've still worked :)
10:15:34 <shapr> Lunar^: better to send him an email.
10:15:37 <shapr> KrispyKringle: w00!
10:15:53 <shapr> KrispyKringle: make sure and thank stepcut for writing the SQLite backend for HaskellDB.
10:16:09 <Lunar^> shapr: maybe... I fear more e-mail than IRC, dunno why
10:16:09 <ozone> i had ye olde versions of RuntimeLoader which successfully loaded .so's as plugins
10:16:18 <ozone> most of the time, anyway
10:16:30 <ozone> anyway, off to bed
10:16:33 <shapr> Lunar^: I just get distracted while writing email.
10:16:35 <ozone> crap, have to be up in 5 hours
10:16:36 <ozone> noight!
10:16:42 <Lemmih> Night.
10:16:43 <shapr> g'night
10:16:45 <KrispyKringle> stepcut: thank you :)
10:17:15 * Lemmih is really confused about the whole dynamic linking thing.
10:17:19 * shapr too
10:17:25 <shapr> It seems to work.
10:17:38 <KrispyKringle> i've actually never used sqlite before, but MySQL 4.1 is masked in portage, and i didn't feel like mucking with postgres.
10:17:40 <shapr> I just use dons code and that fixes nearly everything.
10:17:40 <basti_> shapr: i'm now working at the yi abstraction issue
10:17:44 <shapr> basti_: yay!
10:18:01 <shapr> I've used HaskellDB with PostgreSQL a lot, I like it.
10:18:09 <Lemmih> shapr: Ever tried compiling with -fvia-c?
10:18:24 <shapr> For dynloading? Don't know.
10:20:44 <KrispyKringle> shapr: i've heard good things about postgres. but what im doing is pretty small, so sqlite seemed like it'd be fine.
10:21:33 <wagle> sendmail started out as a class project
10:21:45 <shapr> After painful experiences with MySQL in 97 or so, I switched to PostgreSQL.
10:21:55 <shapr> hoi Itkovian
10:22:04 <nibro> shapr: back, any new reports for me?
10:22:05 <Itkovian> hi shapr
10:22:07 <sylvan> nibro: How's HSP coming along?
10:22:30 <shapr> nibro: yeah, something's wrong :-/
10:22:37 <nibro> sylvan: well enough that I'm trying to get shapr to install and run it :-)
10:22:46 <sylvan> heh, okay!
10:23:10 <nibro> sylvan: I have a few bugs to work out obviously, but I should have a release within the week :-)
10:23:21 <sylvan> nibro: is it installed on dtek or some other system where one might try it out?
10:23:21 <sylvan> sweet
10:23:36 <shapr> http://thunderbird.scannedinavian.com:8080/HelloWorld.hsp
10:23:55 <Lunar^> shapr: Tell me more! :)
10:23:56 <shapr> Though BBB's router in LuleÃ¥ are fuqued as usual.
10:24:12 <Lunar^> shapr: Have you hooked hs-plugins with HWS ?
10:24:13 <nibro> sylvan: not yet, but I'll install it as soon as I think it works ;)
10:24:21 <sylvan> great
10:24:23 <shapr> Lunar^: not me, Peter Thiemann and nibro
10:24:32 <nibro> shapr: yeah, I get a server not found
10:24:36 <Lunar^> shapr: Waow! All we need is a TCP stack in House now
10:24:52 <shapr> We've already got one!
10:24:56 <nibro> so that couldn't be my fault ;)
10:24:57 * shapr grins
10:24:58 <Lunar^> Total World Domination is near
10:25:00 <shapr> w00
10:25:08 <shapr> Ok, time to start hOppix!
10:25:31 <Lunar^> By let's finish HFuse first
10:25:40 <Lunar^> s/By/but/
10:25:50 <shapr> I wish BBB would listen to me giving them tech support. :-|
10:26:38 <Lunar^> shapr: urg! http://www.cse.ogi.edu/~hallgren/House/kernel/pfe.cgi?Net.TCP
10:27:24 <shapr> Looks good.
10:28:38 <gzl> am I misreading the docs, or should (sepEndBy1 (many1 anyChar) (string "\n\n)) parse "foo\n\nbar" into ["foo", "bar"] ?
10:28:51 <shapr> I really wish QuickCheckM handled IO. Though I haven't gotten around to fixing it myself.
10:28:53 <gzl> because it doesn't seem to be.
10:29:56 <pesco> Moo.
10:30:19 <shapr> Baa
10:30:22 * shapr is a sheep
10:30:39 <pesco> Moo.
10:30:45 <gzl> I can do (sepEndBy (many1 (noneOf "\n")) (string "\n\n")) but this completely defeats the purpose
10:31:22 <shapr> I think your first one misses out because it requires something between the two '\n' chars.
10:31:44 <gzl> huh
10:31:45 <shapr> separated by many1 chars.
10:31:53 <shapr> many1 means "at least one"
10:31:59 <gzl> rihgt.
10:32:15 <gzl> well
10:32:22 <gzl> sepEndBy (many anyChar) (string "\n\n") does the same thing.
10:32:53 <shapr> Why does thet noneOf defeat the purpose?
10:33:20 <gzl> because I want to split up a bunch of paragraphs, which are separated by \n\n, but the stuff between the \n\n may contain a single \n.
10:33:28 <shapr> nibro: I get "File did not compile: parse error in /home/shae/public_html//RequestVars.hsp line: 1, col: 1"
10:33:36 <shapr> I wonder if the double slashes are the problem?
10:33:59 <gzl> no clue.
10:34:14 <shapr> Why not sepBy (string "\n\n") ?
10:34:26 <shapr> y0 CosmicRay
10:34:30 <CosmicRay> hi shapr
10:35:12 <gzl> oh, sorry, I misread the description. but regardless, sepBy does the same thing.
10:35:20 <shapr> What same thing?
10:35:47 <gzl> doesn't split up "foo\n\nbar" into ["foo", "bar"]
10:36:04 <gzl> (for either sepBy or sepBy1)
10:36:08 <nibro> shapr: try trhsx on the RequestVars.hsp file
10:36:31 <CosmicRay> gzl: what are you looking for?
10:36:44 <shapr> nibro: looks fine.
10:36:46 <CosmicRay> gzl: perhaps this? http://quux.org/devel/missingh/html/MissingH.Str.html#v%3Asplit
10:37:11 <gzl> hm, well, I'm using Parsec, so I assumed there was a way of doing it directly
10:37:25 <gzl> I just want to split up text separated by \n\n
10:37:49 <nibro> shapr: what's the first line of RequestVars.hsp?
10:38:06 <CosmicRay> ahh, using parsec.
10:38:07 <CosmicRay> one sec.
10:38:09 <shapr> It's the demo you sent me, so...
10:38:24 <shapr> <html> ?
10:38:28 <shapr> or do you mean the translated?
10:38:33 <nibro> wierd...
10:38:38 <CosmicRay> gzl: sepBy x (string "\n\n") perhaps?
10:38:45 <nibro> do you get the same error on HelloWorld.hsp?
10:39:07 <CosmicRay> but you don't need parsec to do that
10:39:09 <shapr> yes
10:39:11 <gzl> > parseTest (sepBy (many anyChar) (string "\n\n")) "foo\n\nbar"
10:39:11 <gzl> ["foo\n\nbar"]
10:39:19 <CosmicRay> with MissingH, (split "\n\n") will do it for you
10:39:22 <gzl> CosmicRay: I'm using Parsec for a lot of other stuff, this is just a small thing in the module
10:39:34 <CosmicRay> gzl: won't (many anyChar) match \n\n also?
10:39:47 <CosmicRay> ah, indeed it will.
10:39:50 <gzl> it will, but presumably the point of sepBy is to get around it
10:39:53 <gzl> like 'between'
10:39:58 <CosmicRay> no
10:39:59 <shapr> nibro: after trhsx, it looks fine, but I get the same error.
10:40:13 <CosmicRay> everything in parsec is greedy -- matches as much as possible
10:40:17 <CosmicRay> sepBy is just a convenience
10:40:26 <CosmicRay> for instance, to parse a line in a (simplistic) CSV file, you might use:
10:40:30 <shapr> nibro: oh hey, all the files in etc/hspr/compiled are size zero
10:40:37 <CosmicRay> sepBy (many (noneOf ",")) (char ',')
10:40:48 <shapr> that doesn't look right
10:41:25 <nibro> shapr: that's probably *because* the file did not compile. That's clearly a bug, but not the one that causes the problem
10:41:28 <CosmicRay> gzl: will your file have embedded \n by itself, or only \n\n in pairs?
10:41:30 <gzl> CosmicRay: nuts, ok. well, the main issue was that I wanted to allow a single \n but split on \n\n, so I wanted to avoid noneOf
10:41:35 <gzl> the former :)
10:41:41 <CosmicRay> right.
10:41:50 <nibro> shapr: try to delete everything from that dir and try again
10:41:55 <CosmicRay> so you need a bit more complex element parser.
10:42:27 <CosmicRay> perhaps x = try (char '\n' >> noneOf "\n") <|> noneOf "\n"
10:42:31 <pesco> gzl: You can use  try (optional newline >> noneOf "\n")  .
10:42:35 <CosmicRay> then, sepBy x (string "\n\n")
10:42:51 <shapr> nibro: same thing
10:43:02 <CosmicRay> actually you may need to say x = (try (char '\n' >> noneOf "\n")) <|> noneOf "\n"
10:43:06 <CosmicRay> I can't remember how tightly <|> binds
10:43:10 <nibro> shapr: recompile the exec with debug support:
10:43:26 <nibro> ghc --make HSPR.hs -o hspr -DDEBUG
10:43:32 <CosmicRay> gzl: does that make sense?
10:43:43 <nibro> oh and -fglasgow-exts
10:43:55 <gzl> yes, that makes sense
10:43:55 <gzl> thanks
10:44:00 <gzl> (pesco too)
10:45:07 * pesco nods.
10:46:01 <vincenz> @type $
10:46:02 <lambdabot> bzzt
10:46:05 <vincenz> @type ($)
10:46:06 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
10:46:19 <vincenz> what's so special about $?
10:46:26 <vincenz> order of evaluation?
10:46:34 <nibro> aye
10:46:47 <nibro> f $ g x == f (g x)
10:46:57 <vincenz> f $ g $ h x (f(g(h x))?
10:47:04 <nibro> yes
10:47:07 <vincenz> ah I see
10:47:12 <vincenz> how does that differ from .
10:47:19 <vincenz> never mindm I'm stupid
10:47:19 <shapr> nibro: and -ccp and -fallow-overlapping-instances, but it still wants src-exts for CGI.RequestHandler
10:47:30 <gzl> well, sometimes I've used f $ foo and it hasn't been the same as f (foo)
10:47:43 <gzl> or was that a side effect of something esle?
10:47:50 <CosmicRay> gzl: are you *sure*?  that should always be the same
10:47:54 <nibro> shapr: don't you have src-exts installed?
10:47:54 <CosmicRay> perhaps there was some other fluke of syntax
10:48:10 <shapr> yeah, but I the name I should put into -pgmF
10:48:12 * shapr is looking
10:48:16 <gzl> maybe. I remember try $ ... broke once and replacing with try (...) fixed it.
10:48:17 <nibro> ah, trhsx
10:48:19 <shapr> oh
10:48:29 <nibro> yeah, sorry, forgot that
10:48:32 <vincenz> how does f $ g x differ from f . g x
10:48:39 <nibro> I'm so used to just having them :-P
10:48:45 <shapr> hm, still error on <% %> parts of that handler.
10:48:52 <nibro> vincenz: f $ g x == (f . g) x
10:48:58 <vincenz> nibro: right
10:48:59 <shapr> "-pgmF trhsx" right?
10:49:02 <vincenz> so why have both?
10:49:09 <vincenz> what is the essential difference
10:49:14 <CosmicRay> @type ($)
10:49:14 <nibro> shapr: yes, assuming trhsx is in your path
10:49:15 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
10:49:17 <CosmicRay> @type (.)
10:49:18 <lambdabot> (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
10:49:23 <pesco> vincenz: f . g x = f . (g x) !
10:49:35 <CosmicRay> == f . g $ x
10:49:51 <CosmicRay> note that (g x) must itself be a function in that scenario
10:50:06 <vincenz> (a . b . c . d) x = a $ b $ c $ d x
10:50:19 <CosmicRay> vincenz: . takes two functions as parameters, and its return value is the function composed by feeding the output of the second into the first
10:50:33 <CosmicRay> vincenz: yes, but (a . b . c . d) != a $ b $ c $ d
10:50:33 <vincenz> CosmicRay: effectively they do the same....
10:50:42 <vincenz> hmmm hmm
10:50:45 <vincenz> true
10:50:49 <vincenz> still, the difference is slim
10:50:50 <gzl> hahaha
10:51:04 <CosmicRay> vincenz: think of: map (head . fst)
10:51:10 <CosmicRay> this creates a new function
10:51:14 <basti_> is there a reason why "IO ()" objects should not be EQ'able?
10:51:14 <CosmicRay> head $ fst is invalid
10:51:19 <CosmicRay> because head does not take fst as a parameter
10:51:21 <vincenz> map (\x -> head $ fst x)
10:51:25 <nibro> vincenz: how about "f $ do ..."
10:51:35 <CosmicRay> vincenz: right, that is how you could express is in terms of ($)
10:51:41 <CosmicRay> vincenz: but it's nicer to use (.)
10:51:44 <vincenz> oki
10:51:45 <Lemmih> basti_: Those are IO actions.
10:51:46 <basti_> isnt that the pointless problem? ;)
10:51:53 <CosmicRay> vincenz: of course, when it comes right down to it, both . and $ are syntactic sugar
10:51:59 <basti_> Lemmih: and they are not comparable?
10:52:02 <vincenz> yes, but very similar
10:52:03 <CosmicRay> vincenz: you can perfectly well write a Haskell program without using either of them.
10:52:07 <CosmicRay> vincenz: some find them helpful
10:52:12 <shapr> I'm doing something wrong, -pgmF trhsx doesn't work.
10:52:21 <Lemmih> basti_: How would you compare two functions?
10:52:27 <vincenz> CosmicRay: some people like reinventing the wheel :D
10:52:32 <nibro> shapr: ah, do you give the -F flag?
10:52:33 <CosmicRay> vincenz: think of ($) as meaning "the function is on the left, and the one parameter it takes os on the right)
10:52:37 <shapr> -F?
10:52:46 <vincenz> Would this be an accurate statement "any problem is only beautifully solved if it's done nearly solely with monads"
10:52:52 <CosmicRay> vincenz: think of (.) as meaning "there are functions on the left and the right, the the result of (.) on them is a new function"
10:52:57 <nibro> shapr: aye, -F turns pre-processing on, -pgmF selects a specific preprocessor
10:52:58 <shapr> vincenz: what?
10:53:08 <vincenz> CosmicRay: I know the dot operator :)
10:53:11 <shapr> nibro: and suddenly it works!
10:53:17 <CosmicRay> vincenz: well I'm trying to explain the difference
10:53:23 <CosmicRay> vincenz: I think it's larger than you do
10:53:34 <nibro> shapr: sweet!
10:53:36 <shapr> vincenz: monads are nice, but they're no silver bullet.
10:53:43 <vincenz> CosmicRay: I see the difference, just seems slim
10:53:57 <shapr> Arrows, on the other hand...
10:53:58 <vincenz> Anyways I have to get going
10:53:59 <vincenz> be back soon
10:53:59 * shapr grins
10:54:06 <vincenz> shapr: what's an arrow in code?
10:54:11 * vincenz has to catch a bus home
10:54:11 <shapr> I'll show ya later.
10:54:19 <vincenz> oki!
10:54:39 <shapr> so, what does -DDEBUG do?
10:54:57 <nibro> turns on debug output from hspr to stdout
10:55:38 <basti_> Lemmih: well i could look and them and see if they are the same object or not
10:55:51 <nibro> nothing magical, it won't solve anything but might help us pinpoint the problem
10:55:59 <basti_> main == main for example.
10:56:10 <shapr> oh that's nice, I like verbose debug output.
10:56:29 <shapr> having different threads writing the stdout is funny
10:56:45 <Lemmih> basti_: You don't know the memory address of a given value.
10:56:48 <shapr> Start connectioCno nltoroopl \n leCro nlnoeocpt \n ioWna ilto ofpo \n r Wraeiqtu efsotrs
10:56:51 * shapr grins
10:57:09 * basti_ frowns.
10:57:14 <nibro> shapr: I know, it only happens at startup
10:57:27 <shapr> nibro: it doesn't seem to be using trhsx - File did not compile: parse error in /home/shae/public_html/HelloWorld.hsp line: 1, col: 1 </p>  </body></html>
10:57:41 <basti_> maybe its for the better
10:57:45 * basti_ goes and changes things
10:58:02 * shapr watches basti_ fix the Entsheidungssproblem
10:58:19 <basti_> pffffttttt.
10:58:19 <Lemmih> basti_: Would 'id == id'? And what about 'id == \x -> x'?
10:58:29 <basti_> i know.
10:58:38 <basti_> i just need to associate strings to functions somehow
10:58:41 <araujo> Hello all
10:58:50 <basti_> as in "what does this thing do"?
10:58:51 <araujo> ghc6.4 includes cabal 0.6?
10:58:52 <nibro> shapr: there's no way it could not use trhsx, that's very hard-wired
10:58:52 <basti_> ?"
10:59:22 <Lemmih> araujo: GHC 6.4 comes with Cabal 1.0 by mistake.
10:59:31 <basti_> hmm are IORefs compareable?
10:59:35 <araujo> Lemmih, by mistake?!?
10:59:36 <shapr> weird, I get the same thing from RequestVars.hsp too
10:59:52 <Lemmih> araujo: Yes, it's actually just 0.6.
11:00:12 <nibro> shapr: ehm... I know the problem
11:00:22 * nibro bangs his head to the desk
11:00:24 <shapr> yeah?
11:00:40 <shapr> Checking for file: /home/shae/public_html/RequestVars.hsp ... True \n Merging file with stubfile ... HTTP/1.1 500 Internal Server Error \n Content-Type: text/html \n Content-Length: 204
11:00:59 <nibro> I've been bugging dons to incorporate src-exts into hs-plugins, and he said he would during the weekend
11:01:03 <Lemmih> basti_: Yes.
11:01:13 <nibro> I have the changes already so didn't think more of it
11:01:23 <nibro> seems he didn't after all
11:01:35 <nibro> so, feel like reinstalling hs-plugins? =)
11:01:40 <basti_> yaha :)
11:01:45 <basti_> now thats cute.
11:01:52 <shapr> nibro: sure no problem
11:01:59 <nibro> ok, the changes are simple
11:02:17 <shapr> I'm watching TV when my woman returns, so that's my deadline.
11:02:17 <nibro> first, change the file src/plugins/Plugins/Parser.hs
11:02:27 <Lemmih> basti_: But be careful: liftM2 (==) (newIORef 'c') (newIORef 'c') => False.
11:02:30 <nibro> shapr: understood =)
11:02:43 <basti_> yes thats ok.
11:02:49 <araujo> Ok, thanks Lemmih
11:02:53 <shapr> ok, what do I change?
11:02:54 <nibro> shapr: change the three imports of Language.Haskell.X to Language.Haskell.Hsx.X
11:03:17 <shapr> ok?
11:03:25 <nibro> second change is to change haskell-src to haskell-src-exts in plugins.pkg
11:03:49 <nibro> at least I think that's what it's called...
11:03:56 <nibro> the file with cabal info in any case
11:04:32 <nibro> and that's it, remake and install
11:04:57 <araujo> Lemmih, im still grasping at this cabal thing, now we are gonna have *.cabal instead of *.pkg right?
11:05:07 <Lemmih> Yeps.
11:05:25 <nibro> Lemmih: what was the cabal URL again?
11:05:38 <Lemmih> www.haskell.org/cabal/ ?
11:05:57 <nibro> no, I mean the repo
11:06:17 <basti_> awwww.
11:06:19 * basti_ ponders
11:06:20 <pesco> http://cvs.haskell.org/darcs/cabal/ I think.
11:07:01 <nibro> yes, that's it, thanks a lot :)
11:07:06 <shapr> hm, I get a bunch of linking errors
11:07:10 <araujo> anyone has a nice link to a cabal tutorial other than the one in haskell.org ?
11:07:29 <nibro> shapr: what are they?
11:07:31 <shapr> oh, I need to remake everything because of import changes, duh
11:07:49 <nibro> shapr: aye, unfortunately ):
11:07:56 * Lemmih wonders why his patch hasn't been applied to Cabal yet ):
11:07:58 * shapr starts it chugging
11:10:05 * nibro still has Lemmih's patch locally, if only the repo would come down alright...
11:12:02 <nibro> didn't work this time either :(
11:12:15 <nibro> same unapplicable patch
11:12:57 <Lemmih> Very weird.
11:16:45 <Philippa> oh, re cabal it seems to me that a little tool to make setup.lhs files easier to call from windows would be nice?
11:17:34 * shapr notices waltz 
11:17:50 <Philippa> and I can't get this damn SDL binding to install...
11:18:06 <shapr> nibro: w00! Hello World Works!
11:18:19 <Lemmih> Philippa: Start xterm?
11:18:34 <shapr> getRequestVar isn't in scope with RequestVars.hsp
11:18:56 <waltz> hey shapr
11:19:12 <Lunar^> shapr: url again?
11:19:16 <Lemmih> Philippa: Using the SDL binding I wrote?
11:19:46 <Philippa> yeah
11:19:54 <Philippa> doesn't work from msys either
11:20:24 <shapr> Lunar^: http://thunderbird.scannedinavian.com:8080/HelloWorld.hsp mais c'est marche seulement tu habite en mes environs.
11:20:24 <Lemmih> What's msys?
11:20:31 <Philippa> looking at it, I'd say it's more a Cabal-under-win32 problem
11:20:44 <pesco> Wow, http://www.pdos.lcs.mit.edu/scigen/ raised over $2200 in a day to go hold their autogenerated talk at WMSCI 2005.
11:20:49 <Philippa> a stripped down mingw32 setup that's just about enough to run makefiles and the like
11:20:52 <Lunar^> shapr: pourquoi tes environs? géographiques?
11:20:54 <pesco> (Or was it two days?)
11:21:09 <Lunar^> pesco: ./ effec
11:21:11 <Lunar^> t
11:21:20 <pesco> Oh, they were on slashdot. That explains it.
11:21:21 <shapr> Lunar^: mon ISP ne marche pas :-/
11:21:26 <shapr> Their routers are broken.
11:21:50 <shapr> So if you're further away than LuleÃ¥, you can't contact me.
11:22:02 <shapr> I've mentioned this to their tech support, but nothing changed.
11:22:13 <nibro> shapr: w00!
11:22:30 <nibro> shapr: s/getRequestVar/getParameter
11:22:32 <Lunar^> shapr: damn
11:23:30 <shapr> nibro: yay!
11:23:32 <wagle> kinda cool: http://i4a.pocketmovies.net/movies/3d/fiatlux_320x176.mpg
11:23:36 <Lunar^> shapr: snowblind can't access thunderbird, either?
11:23:46 <shapr> that's correct
11:23:58 <Lunar^> shapr: damn
11:24:00 <shapr> btw, snowblind is going down, the new box will be pidgin
11:24:14 <shapr> oh hey, there's one way you might be able to access me...
11:24:14 <Lunar^> shapr: You got yourself a new box?
11:25:12 <shapr> How do I put ::83.226.177.8/128 into an url again?
11:25:47 <shapr> ou 2002:53e2:b108::2/64
11:25:47 <Lunar^> shapr: poivron.org is on IPv6 now btw :)
11:25:50 <shapr> w00!
11:25:55 <shapr> that's cool!
11:25:56 * nibro keeps trying to parse the french above
11:26:11 <shapr> ingen fara ;-)
11:26:18 <Lunar^> shapr: 6to4 is really is to get working
11:26:29 <shapr> Yes, I agree. I used CosmicRay's HOWTO
11:26:41 * nibro thinks it says "but it's walk alone for live in my area"
11:26:47 <Lunar^> shapr: And I needed that because our whole campus has a WiFi network now, but it's full IPv6
11:27:31 <shapr> nibro: marche == fungerar
11:27:44 <shapr> cool!
11:28:13 <shapr> hej ski
11:28:21 <ski> hej shapr
11:28:28 <nibro> shapr: ah :)
11:28:53 <shapr> Counter.hsp explorbed
11:29:01 <shapr> An exception occured during page evaluation :unknown exception
11:29:07 <nibro> explorbed?
11:29:24 <shapr> That's a word I got from Riastradh
11:29:27 <nibro> did I send you the Application.hs file?
11:29:39 <shapr> yes
11:30:04 <nibro> hmm...
11:30:19 <nibro> is there a binding for Application.hs in your .filemap?
11:30:20 <shapr> where do I put it?
11:30:29 <shapr> my .filemap is empty last I checked
11:30:39 <nibro> ah, you put it in the same dir as Counter.hsp
11:30:45 <shapr> Right, it's there now
11:30:59 <nibro> check your .filemap again
11:31:11 <shapr> nope, even after cleaning compiled/
11:31:38 <nibro> clean .filemap as well
11:32:09 <nibro> then retry, and check .filemap afterwards
11:32:54 <shapr> .filemap is empty
11:33:25 <nibro> huh? there should be one entry for each file you've requested
11:33:30 <shapr> nope
11:33:51 <shapr> There is suddenly a Nothing in the xterm running hspr
11:34:16 <nibro> is your .filemap in the correct spot as indicated by HSPR/Utils.hs?
11:34:39 <shapr> yes
11:35:10 <nibro> I find it strange that you could view even a single file without something ending up in .filemap
11:35:25 <shapr> I deleted the file and retouched it
11:35:27 * nibro is truly puzzled
11:35:29 <shapr> I think that was not a good idea
11:35:39 <shapr> I bet if I shutdown hspr and restart it, it'll work
11:35:54 <shapr> yup
11:36:02 <nibro> aye, of course, the pagestore will still have the old info...
11:36:04 <shapr> the file handle was suddenly pointing nowhere
11:36:16 <nibro> thanks for solving that for me :)
11:36:30 <shapr> I'm sure more of your users will ask you that :-)
11:36:50 <nibro> well, my users shouldn't ever touch the .filemap ;-)
11:36:53 <shapr> yay! Counter.hsp works!!
11:36:55 * shapr boings
11:37:18 <shapr> well, I'm not convinced I'm the most technical of your users.
11:37:18 <ski> shapr : the example from the paper ?
11:37:21 * nibro boings to, not really knowing what it means
11:37:22 <shapr> Wait till Oleg hears about this.
11:37:57 <shapr> Oleg will do something terrifying like implementing type checking in tcp/ip checksums on the router level through some emergent property of BGP and he'll do it all with HSP!
11:38:00 * ski read a paper on hsp a few days ago (, haven't tried it though)
11:38:06 <Lunar^> shapr: lol
11:38:08 <CosmicRay> shapr: sweet!
11:38:17 <vincenz> arrows!!
11:38:24 <Lunar^> shapr: --> haskell quote page
11:38:33 <CosmicRay> shapr: which, incidentally, is what the electrician kept saying when he was at our house tuesday.  this was not a good thing.
11:38:35 <nibro> ski: not likely you would have since shapr is the first non-dev ever to try it ;)
11:39:08 <nibro> ski: what paper did you read?
11:39:14 <CosmicRay> metaperl: "Notice how the lights in this room are wired.  They cut the ends off extension cords and used them."  electrician: "sweet!"
11:39:18 <CosmicRay> s/metaperl/me/
11:39:30 <shapr> CosmicRay: Your electrician was talking about Oleg? You sure he wasn't a plainclothes member of the HSU?
11:39:34 <CosmicRay> heh
11:39:37 <CosmicRay> what's the hsu?
11:39:47 <shapr> The Haskell Secret Underground doesn't exist!
11:39:51 <shapr> And I'm not a member!
11:39:58 <CosmicRay> thank goodness for that
11:40:02 <CosmicRay> would hate for there to be a cabal
11:40:13 <shapr> Right, unless it installs software for me.
11:40:23 <CosmicRay> I prefer to install software myself, thanks.
11:40:31 <CosmicRay> things that install software for me usually install software I don't want.
11:40:32 <shapr> Did they really cut the ends off of extension cords and us that?
11:40:36 <CosmicRay> yes
11:40:45 <shapr> I find that hard to believe.
11:40:45 <CosmicRay> that is also how the furnace in that room was originally wired.
11:40:51 <CosmicRay> cut one end off an extension cord.
11:40:56 <shapr> Actually, I would find that and everyone nearby would hear me swearing.
11:40:56 <CosmicRay> the furnace then plugged into a wall outlet.
11:41:28 <Lunar^> damn... fuse's releases are as incompatible as GHC's
11:41:33 <shapr> :-(
11:41:38 <CosmicRay> they also added grounding to the electrical system sometime after the old part of the house was built.  at one point, the grounding wire exits the wall, runs 6 feet underneath a window, then goes back into the wall to ground the remaining outlets.
11:41:38 <vincenz> so
11:41:49 <CosmicRay> there are lots of weird things in the old part of our house.
11:42:18 <CosmicRay> we discovered our first winter that there were live water hookups at the back of a linen closet.
11:42:18 <wilx> Eh.
11:42:21 <shapr> that's, um, not confidence inspiring.
11:42:33 <CosmicRay> true.  that's why we're remodeling this part of the house. :-)
11:42:56 <shapr> I'd rip out all the wiring and redo it. I've had too many experiences with whacked out house wiring.
11:43:12 <CosmicRay> apparently the linen closet was originally a laundry area in the dim past, and at some point, it was converted into a clost, but the water hookups were never removed.
11:43:22 <ski> nibro : iirc erik meijer was an author
11:43:25 <CosmicRay> shapr: that is pretty much the plan
11:43:38 <ski> nibro : wasn't a recently downloaded paper, anyway
11:43:39 <shapr> The only 100% positive experience I had was with this alternating current once... Too bad the positive wire is the one with the real kick.
11:43:50 <CosmicRay> shapr: I already replaced the 75-foot run of flat phone cable, consisting of 20-foot sections connected with couplers, with Cat5
11:44:16 <shapr> that's seriously whacked
11:44:20 <CosmicRay> indeed.
11:44:41 <Igloo> Positive wire? AC? Err...
11:44:49 <CosmicRay> Igloo: I was wondering that too.
11:44:50 <shapr> Igloo: c'mon I thought it was funny
11:44:59 <shapr> Obviously my brains were scrambled in the process.
11:45:09 <CosmicRay> it seems they must have had a vast store of miscellaneous hardware that they just decided to use
11:45:25 <CosmicRay> either that, or a secret desire to spend extra money so things could turn out like crap.
11:45:26 <shapr> "Jury-Rigged" is the polite term where I come from.
11:45:50 <shapr> I suspect it was once "Jerry Rigged" and I hope I never meet Jerry.
11:45:53 <CosmicRay> but the thing is -- all that flat phone cable and couplers winds up being *more* expensive than a proper 75' length of cat3.
11:45:56 <CosmicRay> heh
11:46:52 <shapr> nibro: do you have a simpler state accessor?
11:47:55 * shapr changes all the top lines to <% -- -*- haskell -*-
11:48:09 <nibro> shapr: as in?
11:48:21 <nibro> shapr: what state do you want to access?
11:48:38 <ski> nibro : ok ?
11:48:41 <shapr> I was hoping a single call that replaces the three lines that save state.
11:48:49 <shapr> I'm hacking on Counter.hsp
11:49:57 <nibro> shapr: suggestions are welcome :)
11:50:16 <shapr> With more abstraction, counter would be something like "counter = modifyState toCtrTxt"
11:50:34 <shapr> Of course, you'd have to pass the type too, I guess.
11:50:53 <nibro> modifyApp :: (a -> HSP b) -> HSP b
11:51:04 <shapr> right, something like that.
11:51:19 <shapr> Where's the state saved?
11:51:31 <shapr> haskelldb?
11:51:40 <nibro> modifyApp f = do {x <- getApplication; r <- f x; return r}
11:51:48 <nibro> shapr: no, in the running server
11:52:07 <shapr> Oh, why does hsp/hspr rely on HaskellDB then?
11:52:15 <shapr> Or am imagining things?
11:52:23 <nibro> shapr: session state is saved in haskelldb, but application state is not guaranteed to be showable
11:52:39 <shapr> yeah, true.
11:52:42 <nibro> app state can be anything you like
11:53:08 <ski> no state is saved in cookie or hidden field ?
11:53:22 * shapr stuffs modifyApp into Applications.hs
11:53:24 <nibro> ski: the session id is stored in a cookie
11:53:31 <ski> ok
11:53:57 <nibro> there must be something :(
11:54:10 <shapr> Or you could do url rewriting
11:54:27 <shapr> not that I've noticed any urls yet.
11:54:37 * shapr thinks about that
11:54:47 <nibro> shapr: that's fairly apache-specific, is it not?
11:54:50 <vincenz> whatcha working on?
11:54:55 <shapr> No?
11:55:08 <shapr> You could do url rewriting to include whatever info you want.
11:55:15 <shapr> vincenz: Haskell Server Pages.
11:55:21 <shapr> nibro: have you seen Halipeto?
11:55:48 <nibro> shapr: I looked at it, but not very deeply
11:56:23 <shapr> I've used Zope a lot, in my experience the smoothest approach would be something like Halipeto and Haskell scripts using this dynamic loading.
11:56:57 <shapr> Of course, I'm just telling you what *I* would like to use for paying work.
11:57:04 <shapr> Others may have different reactions
11:57:15 <vegai> http://kosto.org/kostos/project.jpg
11:57:16 * shapr shows HSP to his webdev boss
11:58:08 <stepcut> HSP ?
11:58:09 <shapr> positive response from the boss =)
11:58:18 <shapr> boss == fiancee in my case.
11:58:25 <stepcut> shapr: that's just because you are sleeping with boss...
11:58:27 <nibro> shapr: so I figured ;)
11:58:42 <shapr> boss is snickering behind me ;-)
11:58:56 <shapr> Right, now for social time with the, um, boss...
11:59:27 <nibro> have fun :)
11:59:30 * nibro waves
11:59:30 <shapr> nibro: thanks for helping me set this up, I'd love to get hold of more example, and if I hack up some, I can send them to you, right?
11:59:32 * shapr disappears
11:59:40 * basti_ will probably need TH for that emacs thing
11:59:42 <nibro> shapr: send me all you can come up with
11:59:43 <vincenz> take care shapr
12:01:47 * basti_ 's brain is bound to explode then
12:10:04 <Lunar^> 0
12:10:12 <basti_> @pugs 0
12:10:18 <lambdabot> 0
12:18:07 <wagle> http://chriscoyne.com/cfdg/
12:20:50 <Lunar^> wagle: waow
12:22:09 <sond> wagle, sweeeet
12:25:19 <sond> wagle, is that cfdg interpreter written in haskell?
12:26:35 * nibro yawns
12:26:56 * basti_ mouth hangs open during a coarse mapping of the TH world
12:27:01 <wagle> sond: i dont think so..  but thought that some here might think it should be..  8)
12:27:08 <sond> oh
12:27:32 <sond> I think the haskell version woulde be and embedded language though ;)
12:29:28 <basti_> does anyone actually understand template haskell?
12:30:24 <Lemmih> basti_: Got a TH question?
12:30:41 <basti_> Lemmih: uhm I'm just measuring its diameter so to say.
12:30:59 <basti_> do i see it right that it can analyze any expression known at compile time?
12:32:44 * ski doesn't like that it apparently doesn't enforce welltypedness of code (generated by well typed TH-code), but then, this might possibly not fit into it's purpose .. dunno
12:33:14 * basti_ thinks he needs something different tough.
12:34:01 * basti_ might just use some verbosity
12:58:34 <Lunar^> HelloFS works again :)
12:58:43 <Lunar^> let's get to the real hairy stuff no
12:58:44 <Lunar^> w
13:02:00 <sylvan> HelloFS wut?
13:03:17 <lispy> perhaps a file system where every file contains, "Hello, World!"
13:03:24 <Lunar^> lispy: just one file actually
13:07:12 <rtega> lispy: maybe it contains "Hello, FS!"
13:08:04 <stepcut> Lunar^: does it preserve file encoding information ?
13:08:20 <Lunar^> stepcut: what do you mean?
13:09:03 <stepcut> Lunar^: if you have file that is encoded in, say utf-8, does the filesystem preserve that information ?
13:09:40 <Lunar^> stepcut: I'm just doing a wrapper around fuse, which ask for CChar
13:09:55 <stepcut> :p
13:10:02 <stepcut> I am just giving you a hard time
13:10:20 <Lunar^> the hard time is this reentrancy thing, here
13:43:56 <Lunar^> damn
13:43:59 <Lunar^> I still don't understand (
13:44:00 <Lunar^> :(
13:47:36 <RemiTurk> good evening
13:48:08 <shapr> wagle: LtU'd
13:48:30 <shapr> hoi Remi
13:49:06 <shapr> basti_: TH is straightforward, you can generate and manipulate code as value.
13:49:24 <shapr> Oboy, HXT5 has lots and lots of arrows! w00!
13:49:48 <sond> what's hxt5?
13:50:12 <poetix> shapr: howay
13:50:45 <Lunar^> shapr: *sigh* I still don't understand the mixture of locks in RTS, FUSE and so on... debugging doesn't help :'(
13:51:07 <shapr> sond: http://article.gmane.org/gmane.comp.lang.haskell.general/11371
13:51:19 <shapr> Lunar^: that's sad :-( Can you ask JaffaCake?
13:53:18 <Lunar^> shapr: I will now that I have some debug code to show
13:53:29 <Lunar^> shapr: FUSE seem to block on signals for its worker threads
13:53:41 <Lunar^> shapr: I wonder if that affects anything
13:53:42 <poetix> CFDG is startlingly lovely
13:53:47 <shapr> poetix: yes, truly
13:54:00 <shapr> wagle: thanks for mentioning that
13:54:09 <Lunar^> shapr: there's also a waitCondition in waitForReturnCapability that could made the whole thing block
13:54:27 <Lunar^> shapr: But I wasn't able to make a test case :(
13:54:48 <shapr> Could STM help?
13:55:06 <Lunar^> shapr: It's purely FFI related
13:55:19 <Lunar^> shapr: There's no explicit concurrency in my whole code
13:55:19 <shapr> It's sad, I always read /H as T in GNU/Hurd.
13:55:38 <gzl> haha.
13:55:40 <shapr> Oh, I see.
13:56:09 <wilx> :))
13:57:08 <wilx> I wonder if there would ever be usable GNU/Hurd OS.
13:57:22 <shapr> I hope so, I think variety is good.
13:57:44 <wilx> For too long it seems to be in rather unusable.
13:58:14 <shapr> Longer than Linux has been working, right?
13:58:58 <wilx> Huh, dunno.
13:59:44 <shapr> For some reason I think the Gnu/Hurd project started a few years before Linus started writing Linux.
14:01:37 <TFK> (Maybe because Linus laughed at Hurd right when he started his own project? :-)
14:01:59 <wilx> Hmm, googling reveals that you are right.
14:02:08 <wilx> GNU/Hurd seems to be a bit older.
14:02:14 <shapr> Lemmih: mind if I mention modhaskell on the mailing list?
14:02:52 <Lemmih> shapr: Not at all.
14:03:21 <Lemmih> Was about to do it myself but got confused by ozone (:
14:03:37 <shapr> Lunar^: do you know anything the status of Thiemann's hws-plugins?
14:04:59 <Lunar^> nope
14:05:22 <shapr> I wonder if he'll mind if I mention it on the mailing lists.
14:05:38 <shapr> I'll just assume that he won't mind, and hope I don't get flamed.
14:06:12 <vincenz> shapr!
14:06:15 <shapr> vincenz!
14:06:21 * shapr shoots an arrow at vincenz 
14:06:23 <vincenz> So... arrows :D
14:06:30 <shapr> message for you sir!
14:07:29 <shapr> Too bad Graham Klyne doesn't show up here.
14:08:18 <shapr> dons: hs-plugins is awesome! w00!
14:08:47 * Lemmih heads to bed.
14:08:51 <vincenz> so..
14:08:52 <shapr> g'night Lemmih
14:08:56 <vincenz> what is the definition of arrows?
14:09:11 <shapr> They're a generalization of monads.
14:09:28 <shapr> Have you used monads much? Specifically, have you used parser monads?
14:09:31 <RemiTurk> night Lemmih
14:09:45 <shapr> hej chucky
14:10:37 <shapr> vincenz: still there?
14:11:14 <shapr> I get a stupendous amount of spam.
14:11:37 <vincenz> yes
14:11:48 <vincenz> parser monads?
14:11:49 <vincenz> I fear not
14:11:52 <vincenz> you mean like ReadS?
14:11:56 <shapr> Ok, have you used parser monads? Do you understand the control flow that happens in Parsec?
14:12:04 <vincenz> euhm no
14:12:10 <vincenz> I don't evne know Parsec
14:12:25 <shapr> It's gorgeous, you should try it, but I'll give you the quick overview.
14:12:29 * vincenz nods
14:13:12 <shapr> A parser monad looks like input_string -> (usefultype,rest_of_string)
14:13:14 * sorje is lost in a maze of Readers and IOs
14:13:26 <vincenz> ah like ReadS
14:13:51 <shapr> When you apply several of those parsers, they end up nested in the rest_of_string part
14:14:13 * vincenz nods
14:14:14 <shapr> input_string -> (usefultype,(usefultype,rest_of_string))
14:14:19 <shapr> osv
14:14:19 <vincenz> I've always wondered about that
14:14:31 <vincenz> if an inner parser fails, you backtrack to a different choice for an outer parser
14:14:38 <shapr> that's correct.
14:14:43 * vincenz nods
14:14:46 <vincenz> like ocaml streams
14:14:54 <shapr> But, there's a problem with that.
14:14:58 <vincenz> yes
14:15:00 <vincenz> if x then y
14:15:03 <vincenz> if x then y else z
14:15:08 <vincenz> gotta take out the if x then y bit
14:15:18 <shapr> huh?
14:15:27 <vincenz> in the general case it's more complex when you have different parsers with the same prefix?
14:15:36 <shapr> that's one point, yes
14:16:10 <shapr> One problem is space leaks. You must hold onto the input string until one of the parsers has succeeded.
14:17:01 <shapr> that makes sense, right?
14:17:31 <shapr> You also must recurse into a parser until all of its options have failed.
14:17:50 <vincenz> nod
14:18:00 <vincenz> if you support backtracking
14:18:03 <shapr> In most cases, you immediately know which string will succeed, because common prefixes aren't that common.
14:18:16 * vincenz nods
14:18:26 <shapr> usually after the first character you know which options won't succeed.
14:18:33 <vincenz> yip
14:18:44 <vincenz> that's what parser generators are for :D
14:18:48 <shapr> but you still have to recurse into all that code, there's no way to shortcut fail.
14:19:12 <shapr> You know the type signature of monads?
14:19:18 <shapr> @type (>>=)
14:19:18 <vincenz> M a
14:19:21 <vincenz> yes I do
14:19:23 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
14:19:23 <lambdabot>          (Monad m) =>
14:19:23 <lambdabot>          m a -> (a -> m b) -> m b
14:19:33 <vincenz> return : for all a : a -> m a
14:19:46 <shapr> So a monadic parser is just a function, you can't ask it what it could parse, you just have to call it with input, and it has to fail all by itself.
14:20:07 <vincenz> cause monads are closed off from the outside world
14:21:01 <shapr> Swierstra and Duponcheel found out that if you did have static properties, you wouldn't have to recurse into all the code, you wouldn't have to hold onto input until all have failed or one has succeeded, you could save bunches of CPU time and memory.
14:21:29 <shapr> All you'd have to do is get these monad-like critters to export some static info about what they do parse.
14:21:41 * vincenz nods
14:21:49 <shapr> But they don't fit into the monadic interface, not at all. Monads don't do static properties.
14:22:19 <shapr> So John Hughes figured out a generalization of monads, something that can do more than a monad, including static properties.
14:22:23 <shapr> These guys are called arrows.
14:22:57 <shapr> This is the website where you can read all the goodies - http://www.haskell.org/arrows/
14:23:05 <wilx> Arrows seem to be hit of the day.
14:23:05 <Marios> hello, do you know a good text editor for haskell? im looking for a quite long time now but havent found something, thanx
14:23:10 <vincenz> thx
14:23:12 <wilx> ..week
14:23:13 <vincenz> so it's only for parsing?
14:23:15 <wilx> ...year.
14:23:15 <shapr> Marios: emacs? vim?
14:23:23 <shapr> vincenz: no, they can do everything a monad can do, and much more.
14:23:30 <shapr> With the downside that they're more trouble to work with.
14:23:53 <shapr> Monads are a special case of arrows.
14:24:25 <vincenz> ah
14:24:26 <vincenz> coolies
14:24:49 <shapr> I'd recommend starting with this paper - http://www.soi.city.ac.uk/~ross/papers/fop.html
14:24:57 <vincenz> arr :: (b -> c) -> a b c
14:24:58 <vincenz> I don't get it
14:25:06 <vincenz> what is an "a b c"
14:25:18 <shapr> You know how chat is a verb, but we can say "We had a chat" and it's noun, yeah?
14:25:52 <shapr> Arrows are similar in that they can 'noun a verb' by turning a function into a value you can manipulate.
14:26:21 <shapr> so a b c is an arrow a that's a first-class transformation from type b to type c.
14:26:47 <Igloo> vincenz: a takes 2 types and returns a type
14:26:56 <Igloo> vincenz: Like how Maybe takes a type and returns a type
14:27:02 <Igloo> e.g. Maybe Int is a type
14:27:58 <vincenz> woah
14:28:07 <vincenz> a b c is not an a of a b of a c?
14:28:10 <vincenz> a of b of c
14:28:14 <vincenz> but rather a of b and c
14:28:28 <Igloo> Err
14:28:39 <Igloo> a b c works in the same way as (+) 1 2
14:29:03 <vincenz> typewise?
14:29:10 <Igloo> No, application wise
14:29:18 <vincenz> I'm talking types
14:29:18 <vincenz> l
14:29:25 <Igloo> If you think (+) takes 2 Ints then a takes 2 types
14:29:27 <vincenz> (b -> c) -> a b c
14:29:36 <vincenz> what is the type "a b c"
14:29:45 <vincenz> type of two types or a type of a type of a type?
14:29:47 <Igloo> a b c /is/ a type
14:29:49 <vincenz> I know
14:29:52 <vincenz> eugh
14:29:54 <vincenz> m a
14:29:54 <Igloo> It has kind *
14:30:02 <vincenz> m is the typeconstructor
14:30:03 <Igloo> a has kind * -> * -> *
14:30:05 <vincenz> with parameter a
14:30:07 <Igloo> b and c have kind *
14:30:21 <Igloo> Right
14:30:26 <vincenz> so
14:30:29 <vincenz> m a b
14:30:32 <Igloo> m has kind * -> *, a has kind *, m a has kind *
14:30:38 <vincenz> m(a, b) or m(a(b))
14:30:45 <vincenz> hmm
14:30:46 <Igloo> (m a) b
14:30:48 <vincenz> ah alright
14:30:53 <lispy> is anyone here familiar with gnuplot?
14:31:02 <Igloo> Just like (+) 2 3 = ((+) 2) 3
14:31:03 <vincenz> Igloo: didn't know how the eval rules worked for types
14:31:10 <shapr> I'm unfamiliar with gnuplot, but have used it a bit.
14:31:13 <vincenz> Cause if you look at
14:31:30 <vincenz> data Tree a = Branch (Tree a)
14:31:39 <lispy> my data is in the form 1.0e-3 but gnuplot is reading that as 1.0 followed by some junk, but really it's scientific notation
14:31:43 <vincenz> though in that case... Tree is a type constructor and Branch data constructor
14:32:08 <lispy> i could write a perl script to fix it, but i'd rather not....
14:32:09 <shapr> salut poetix
14:32:19 <shapr> lispy: c'mon, a quick Haskell script...
14:32:29 <vincenz> have to afk a bit
14:32:31 <poetix> shapr: I don't believe you type that fast. You have an auto-hailer...?
14:32:33 <vincenz> to get cigarettes
14:32:35 <lispy> shapr: heh, i'm not good enough with Haskell for it to be quick :)
14:32:38 <vincenz> but thank you Igloo and shapr !
14:32:58 <shapr> poetix: I type much faster than that. I was doing something else at the same time :-P
14:33:11 <lispy> i was just hoping that maybe gnuplot would have an option for reading data that is in that format
14:33:42 <shapr> lispy: try "help format" in gnuplot
14:33:46 <lispy> and i'm not sure where to go looking for help other than the manual (which hasn't helped thus far)
14:33:52 <lispy> shapr: aight
14:34:09 <poetix> shapr: Well, I guess I type pretty fast too. But you're still mighty quick on the draw.
14:34:37 <shapr> I think I'm just quick to change focus.
14:35:01 <poetix> Setting up a darcs repo on my dreamhost account turned out to be fairly straightforward, although I don't have the CGI repo-browser script installed yet
14:36:51 * shapr gets random on CFDG
14:36:57 * boegel waves
14:37:07 <shapr> hoi boegel
14:39:10 <poetix> shapr: Do you have a copy of TaPL?
14:39:15 <shapr> japp
14:39:18 * RemiTurk thought about rewriting the perl cgi script to php just today as I found out php is supported at my university but general cgi not, then gave up almost immediately when I saw the forest of $#_*@*@*$&@&)(
14:39:23 <shapr> Not ATTaPL though.
14:39:48 <poetix> Is it worth attempting? Costs a bit...
14:39:53 <shapr> It's worth it.
14:40:18 <poetix> Seems to be very highly regarded by almost everyone.
14:40:22 <shapr> Assuming you want to learn Type Theory.
14:40:46 <shapr> It's really fun to read. I have bunches of scribbles and doodles in the margin of my copy.
14:41:22 <shapr> I treat books as a conversation with the author. I wrote my ideas about type systems in the first few pages before I started so I could see if anything changes while I read.
14:41:28 <poetix> I think a fun book on Type Theory would *make* me want to learn Type Theory.
14:41:54 <CosmicRay> well putt, poetix.
14:41:58 <poetix> I read some slides by Pierce giving an overview of the field. There's some strange and fascinating stuff out there. I'd like to get to the point where some of that was more accessible to me.
14:42:01 <shapr> I did come up with Jacko the Type Theoretic Rabbit of Doom, who inhabits the pages of my copy.
14:42:10 <CosmicRay> so many author's books give you the impression that having a conversation with the author would require liberal doses of caffeine
14:42:19 <CosmicRay> shapr: bwahahaha
14:42:20 <shapr> CosmicRay: you've been reading my writings again!
14:42:31 <CosmicRay> shapr: no I haven't, I swear!
14:42:34 * shapr snickers
14:42:45 <shapr> I require caffeine to talk to non-hyperactives :-/
14:42:55 * RemiTurk promises to buy shaprs JtTTRoD
14:43:03 <Lemmih> shapr: I'm Lemmih.
14:43:07 <poetix> I find CTM a very comfortable read, although having said that I still haven't finished it.
14:43:08 <shapr> There's also his pal, Wacko the Kangaroo Rat of Doom.
14:43:10 <RemiTurk> (in dead-Tree-form)
14:43:16 <shapr> Lemmih: :-P
14:43:27 <CosmicRay> ok.
14:43:31 <CosmicRay> I'm going to give darcs another try.
14:43:41 <shapr> poetix: I haven't finished TaPL, but everytime I read more I enjoy it.
14:43:51 <Lemmih> shapr: "David Himmelstrup" sounds so weird.
14:43:51 <shapr> But then, finishing a non-fiction book for me is something unusual.
14:43:54 <poetix> CosmicRay: What did it do you last time?
14:43:59 <shapr> Lemmih: Is that not your legal name?
14:44:07 <CosmicRay> despite my moral objection to it on the grounds that the author believes "requires 24 hours of cpu time to commit 15-byte change", arch is just ticking me off too much, and everything else sucks more
14:44:22 <CosmicRay> err, the author believes "requires 24 hours of cput time to commit 15-byte change" is not a serious bug
14:44:35 <Lemmih> shapr: Perhaps not for long.
14:44:39 <shapr> Lemmih: I'll make the same deal with you that my friends made with me, I'll call you by your legal name. If you want me to call you lemmih, change it :-P
14:44:55 <Igloo> CosmicRay: To /commit/? Are you sure?
14:45:03 <shapr> Though after having changed my name, I would strongly recommend something that does mostly fit in to the place you live.
14:45:03 <CosmicRay> hmmm.
14:45:06 <boegel> shapr: how's TMR2 going ?
14:45:08 <CosmicRay> perhaps it was a darcs pull.
14:45:09 <CosmicRay> hmm hmm.
14:45:15 <CosmicRay> I don't quite recall, igloo.  it was some time ago.
14:45:18 <Igloo> OK, that I can believe
14:45:19 <shapr> I knew this guy who changed his name to "Scraps" and that was just weird.
14:45:32 <CosmicRay> Igloo: but from what I hear, these sort of conditions persist in darcs.
14:45:42 <poetix> It's quantum, that's probably why
14:45:48 <shapr> Yeah, quantum.
14:45:49 <Igloo> DR is working on a fix, but yeah
14:46:04 <poetix> Normal space/time complexity calculations don't apply. You need to take account of several extra dimensions.
14:46:09 <shapr> poetix: You obviously Prachett.
14:46:12 <shapr> ahem "read"
14:46:15 <poetix> shapr: for sure
14:47:10 * boegel is going to bed to watch a movie
14:47:13 <boegel> bye everyone
14:47:35 <poetix> We use Perforce at work. It's OK. We used to use VSS. That wasn't.
14:47:55 <shapr> cya boegel
14:47:59 <shapr> VSS eats code. Don't use it!
14:48:08 <CosmicRay> haven't heard of vss
14:48:16 <CosmicRay> I used perforce at work 5 years ago.
14:48:17 <shapr> Microsoft Visual SourceSafe
14:48:21 <CosmicRay> I thought it was total crap.
14:48:21 <poetix> VSS keeps your code *very* safe...
14:48:31 <CosmicRay> shapr: ooo, the very name makes it sound evil
14:48:32 <Lunar^> damn
14:48:40 * Lunar^ is totally pissed off
14:48:42 <poetix> You may never see it again.
14:48:42 <shapr> poetix: Is CTM worth it?
14:48:47 <CosmicRay> shapr: a microsoft safe just sounds evil.  and "visual sourcesafe" sounds like crap.
14:48:58 <CosmicRay> I guess it must be evil crap then.
14:49:16 <shapr> We used VSS for our 65,000 line VB App. We only had the repo go totally belly-up four or five times a year.
14:49:21 <shapr> After which you'd have to reimport everything.
14:49:22 <CosmicRay> hah
14:49:28 <CosmicRay> that's worse than darcs 0.9!
14:49:36 <shapr> That's worse than darcs 0.7!
14:49:42 <CosmicRay> shapr: perhaps the lines were counted in a 16-bit int!
14:49:46 <poetix> shapr: I think so. It sort of tilts the world on its axis. My usual line about it is that it changes your perception of where the low-hanging fruit is.
14:49:52 <shapr> hm!
14:50:22 <poetix> Reading CTM is like entering a parallel (pardon the pun) universe in which Logic Programming had been the dominant paradigm for the last 20 years.
14:51:03 <shapr> That does sound like fun.
14:51:09 <poetix> I think the kernel language approach is fascinating. But it is a bit weak on types.
14:51:18 <shapr> TaPL is quite strong on types.
14:51:22 * CosmicRay does darcs get on the darcs linux kernel mirror without using --partial.
14:51:47 <Oejet> Concurrent programs are evil bugmares.
14:51:56 <stepcut> :p
14:52:06 <stepcut> especially if they use bash
14:52:06 <CosmicRay> Oejet: great, that's the kind of code I write anyway. :-)
14:52:10 <CosmicRay> stepcut: ewwww
14:52:27 <CosmicRay> Oejet: I have seen some very well-written concurrent programs.
14:52:34 <poetix> shapr: Do you find yourself writing type declarations in Haskell as documentation (or for specification purposes) even though they'd be inferred anyway?
14:52:44 <shapr> No, not me.
14:52:48 <Oejet> CosmicRay: In what fields?
14:53:00 <CosmicRay> Oejet: mostly for I/O performance reasons
14:53:08 <ski> hm, CTM ?
14:53:13 <shapr> poetix: Lately I've started writing type signatures beforehand in some cases, when I know more what I want than how to get it.
14:53:17 <Itkovian> gdnight\
14:53:21 <shapr> g'night Itkovian
14:53:22 <CosmicRay> Oejet: occasionally for user interface reasons
14:53:52 <poetix> shapr: Yes, that's it - a bit like sketching out an interface before writing the implementation.
14:54:04 <poetix> shapr: Similar idea to TDD in some ways.
14:54:22 * poetix is very bad at TDD
14:54:27 <CosmicRay> Oejet: for instance, web servers are typically concurrent to handle multiple simultaneous connections
14:54:30 <ski> poetix : what's CTM ?
14:54:47 <poetix> ski: Concepts, Techniques and Models of Computer Programming, by Peter van Roy and Seif Haridi
14:54:50 <shapr> You should try my fork of QuickCheck that encourages TDD!
14:54:58 <Oejet> CosmicRay: Where's the kernel repo?
14:55:03 <ski> poetix : aha, that one ..
14:55:06 <poetix> ski: http://www.codepoetics.com/wiki - CTM Wiki
14:55:30 <CosmicRay> Oejet: see instructions at http://www.darcs.net/linux.html
14:55:40 <CosmicRay> it appears to be the one major thing related to haskell that shapr doesn't host
14:55:51 * shapr laughs
14:56:20 <shapr> I'm moving ISPs soon, so that'll shake up some stuff.
14:56:25 <CosmicRay> hmm.
14:56:30 <shapr> DarcsWiki will have to go to darcs.net
14:56:34 <CosmicRay> darcs is using 442MB RAM and climbing
14:56:35 <shapr> and I'll start paying for bandwidth.
14:56:41 <vincenz> What is a comonad?
14:56:43 <CosmicRay> shapr: why move then?
14:56:48 <CosmicRay> 459M...
14:56:57 <CosmicRay> it appears to have downloaded all the patches in the kernel repo
14:57:05 <CosmicRay> and it now chewing away at about 50% CPU
14:57:08 <CosmicRay> and rapidly consuming ram
14:57:10 <CosmicRay> is this normal?
14:57:12 <CosmicRay> 524M...
14:57:12 <ski> vincenz : the dual of a monad
14:57:19 <shapr> CosmicRay: it is for that many patches.
14:57:26 <Oejet> CosmicRay: How many patches has it fetched?
14:57:27 <vincenz> ski: I figured as much but what should I envision it as?
14:57:33 <CosmicRay> Oejet: thousands, I'm sure
14:57:39 <CosmicRay> shapr: what exactly is it doing
14:57:43 <ski> vincenz : we're not totally sure
14:57:43 <Oejet> It should say.
14:57:55 <CosmicRay> last thing it said was Copying patch 20020205174040-69652-899a45f4d76864c88c5e532195cb91a93aa41b8f.gz
14:57:56 <shapr> first it gunzips the patches, then it turns them into PackedString instances, then it applies them all.
14:58:04 <Igloo> CosmicRay: Unfortunately so. I was working on it last night, but got distracted by hPutBuf playing up
14:58:08 <vincenz> How hard would it be to make a fully pervasive monad that is used everywhere so that at any time the entire state of the program can be saved and then be moved elsewhere to continue where you left off?
14:58:21 <CosmicRay> shapr: couldn't it just start at the most recent checkpoint?
14:58:28 <shapr> The current expert on tuning darcs is Igloo.
14:58:42 <ski> vincenz : it appears to me that e.g. the state-in-context comonad works correctly only if you have a linear/uniqueness typesystem ..
14:59:06 <ski> vincenz : pervasve, how ?
14:59:09 * CosmicRay gives igloo some trouble about converting patches into lists of bools in darcs... :-)
14:59:30 <vincenz> ski: break computation at any point "saveState"
14:59:32 <ski> vincenz : still in haskell ?
14:59:38 <vincenz> run program elsewhere "loadState"
14:59:54 <ski> vincenz : like the program is terminated, and later resumed ?
14:59:58 <vincenz> yes
15:00:06 <ski> vincenz : like in Hughes CGI Arrow ?
15:00:11 <vincenz> no idea
15:00:14 <CosmicRay> well time to leave for the evening, cyall
15:00:17 <shapr> cya CosmicRay
15:00:18 <poetix> vincenz: Sounds like you'd run into a problem I was discussing here the other day, about generic serialisation.
15:00:19 <Igloo> Please, I already have David coming down on me for reading files as Strings  :-)
15:00:26 <Igloo> Oh, he went
15:00:41 <ski> shapr : have a link to the arrow paper with the cgi arrow ?
15:00:58 <shapr> http://www.cs.chalmers.se/~rjmh/Papers/arrows.ps
15:01:03 <ski> shapr : ty
15:01:17 <poetix> Any intuition-boosting Arrow examples out there?
15:01:21 <shapr> The CGI Arrow shows up around Page 30, I think.
15:01:24 * poetix still doesn't get Arrows
15:01:29 <ski> vincenz : though there is a prob with that particular CGI arrow (mentioned in the paper)
15:01:31 <vincenz> poetix: how's that?
15:01:34 <shapr> poetix: oh you missed my description to vincenz
15:01:35 <KrispyKringle> is it just me, or is zvon.org kaput?
15:01:50 <vincenz> shapr: not sure how the arrow would make computation more visible... it seems to hide more inside the type
15:02:30 <ski> KrispyKringle : appears kaput
15:02:36 <poetix> vincenz: Somewhere along the line you have to do something like pickle a continuation.
15:02:42 <vincenz> poetix: yes
15:02:53 <KrispyKringle> damn domain squatters.
15:02:54 <vincenz> I looked at the example with computation fuel
15:03:00 <KrispyKringle> http://web.archive.org/web/20040621101822/www.zvon.org/other/haskell/Outputlist/index.html
15:03:03 <KrispyKringle> :-/
15:03:10 <vincenz> how much overhead would that entail?
15:03:22 <shapr> What's up with domain squatters? How do they steal domains?
15:04:07 <ski> vincenz : would what entail ?
15:04:32 <vincenz> the example in "a gentle introduction to haskell" with the computation fuel
15:05:15 * ski doesn't remember such exercise ..
15:05:38 <KrispyKringle> shapr: voodoo and evil.
15:05:59 <KrispyKringle> shapr: the registrar i use allows a grace period for the owner to register before registration is open to the public, but perhaps some done.
15:06:04 <KrispyKringle> or else the admin is simply careless.
15:06:53 <shapr> I'd like to switch to a peer to peer dns system where anyone can advertise whatever name they want and use an ant-like system for ranking.
15:08:11 <poetix> shapr: you jest
15:08:32 * poetix considers the example of googlerank, shudders
15:08:34 <shapr> No, I'm quite serious. I'm a fan of more peer to peer systems.
15:08:45 <shapr> Ah, but googlerank uses a ranking system on the server side.
15:09:12 <poetix> oh, I see. ant-like as in pheremone markers.
15:09:25 <shapr> In this case you would rank names yourself, "These are not droids I'm looking for." and then your friends would leech off of your ranks.
15:09:34 <KrispyKringle> shapr: so you're saying that the machine considered to be "foo" is the one that most people consider to be foo?
15:09:39 <shapr> exactly
15:09:46 <shapr> That's how names really work anyway.
15:09:46 <KrispyKringle> i think that's problematic, since the whole point of DNS is to be canonically "foo"
15:09:50 <poetix> There's nothing in principle to stop someone building that right now...
15:09:53 <KrispyKringle> not in the machine world.
15:09:54 <shapr> As I discovered when I change my own legal name.
15:10:16 <shapr> poetix: motivation enough to get off my butt and code?
15:10:19 <KrispyKringle> It'd be neat to *have* that system, I agree, but that's apart from the purpose of DNS, which is less to impart meaning that to impart easy remembrence to IP addresses.
15:10:43 <KrispyKringle> Look at it this way: Googlebombing would mean you could receive other people's mail, have people log into your system by mistake, etc, no?
15:10:52 <poetix> To some extent the whole "folksonomies" thing is treading the same path
15:11:03 <shapr> How would you googlebomb that sort of system?
15:11:13 <poetix> shapr: Give it a week, someone will find a way
15:11:19 <shapr> good point
15:11:25 <shapr> Still, would be lotsa fun to try.
15:11:30 <KrispyKringle> you can googlebomb google...
15:11:39 <shapr> But that's because it's server-side
15:11:43 <shapr> I think it makes a difference.
15:11:53 <KrispyKringle> i don't see how. if you were using the same algorithm...
15:12:13 <shapr> Name lookups increase rank when you find what you wanted by searching for a certain name.
15:12:15 <KrispyKringle> the point is, you're trusting other people to resolve the name for you. if someone could either convince other people or pretend to be many other people, he controls DNS.
15:12:20 <shapr> And decrease rank when you don't find what you wanted.
15:12:28 <KrispyKringle> canonicality (canonicalis?) is not democratic, nor should it be.
15:12:36 <shapr> For example, groklaw.net has a squatter doing free advertising on groklaw.com
15:12:39 <KrispyKringle> yeah, but DNS is not meant to be a search engine.
15:12:39 <poetix> P2P is not immune to automated attack, although its immunity is maybe better than strongly centralised system. But look at poisoning attacks on file-sharing systems.
15:12:56 <KrispyKringle> exactly. you could poison this system with bad data.
15:13:04 <SamB> hmm, peer to peer DNS ranking would definately be a good solution to Scientology's usurption of the Cult Awareness Network's domain name...
15:13:08 <shapr> You'd have to have bad friends.
15:13:10 <KrispyKringle> haha
15:13:16 <KrispyKringle> SamB: you gotta be kidding me. link?
15:13:31 <SamB> KrispyKringle: why would I be kidding?
15:14:07 <shapr> If I got my rankings from a combination of my friends and my own rankings, the only way to poison that would be to pay my friends to poison my ranks.
15:14:25 <poetix> How do I get to know about things my friends don't know about?
15:14:31 <shapr> In which case, when I found out which of my friends was poisoning my rankings, I'd just decrease their rank.
15:15:08 <KrispyKringle> SamB: i don't know. i don't know oyu that well.
15:15:08 <shapr> You'd have to open up somewhere to find that sort of info, and then you'd be open to poisoning.
15:15:27 <poetix> You would probably have to rely on wider trust networks, which would be increasingly vulnerable to infiltration the more widely the net was spread
15:15:29 <KrispyKringle> shapr: that wouldn't scale. what if oyu wanted to visit a url you nor your friends had ever been to before?
15:16:27 * shapr thinks
15:16:39 <tuomov> Just do away with names.
15:16:57 <poetix> I still think "folk DNS" could be worth building as an experiment - like Freenet or something
15:17:20 <tromp> http://rchi.raskincenter.org/aboutarchy/img/zoomdemo.swf is cool
15:17:28 <shapr> You could have totally open name caches where anyone could upload their lookups and rankings.
15:17:43 <tromp> even though his fractacl example uses a suboptimal language:)
15:18:14 <poetix> A firefox plugin to support browsing with reference to alterna-DNS...
15:18:16 <tuomov> people generate a public key for their machine, users can assign a name to this key locally, and use this key to find the machine
15:18:29 <SamB> okay, it looks like the problem with scientology and the cult awareness network runs a bit deeper than DNS...
15:18:30 <tuomov> and verify that they really found it too
15:18:30 <KrispyKringle> tuomov: you know, that's kinda a good idea. Instead of names, we should all use some sort of numerical representation--maybe we could group networks by the first x bits an use these bit groupings to provide finer-grained indication of networks (sorta like subdomains). I think this has a number of advantages, in being simpler, easier to type, and so forth...
15:18:36 <KrispyKringle> Wow! Genius!
15:18:43 <shapr> poetix: oh I know, in reference to squatters and complete open-ness, call it NickaName
15:19:05 <KrispyKringle> I'm thinking maybe...32-bit representations.
15:19:15 <poetix> shapr: Sounds like Knicker-Name
15:19:16 <KrispyKringle> split into 8-bit groups.
15:19:20 <SamB> 32 bits are not enough
15:19:22 <KrispyKringle> We could call them "octets!"
15:19:23 <shapr> I was thinking nick as in steal.
15:19:29 <KrispyKringle> And the whole thing "ip addresses!"
15:19:36 * KrispyKringle is just joking around
15:19:36 <shapr> knicker-name would actually be great advertising.
15:19:47 * shapr beats KrispyKringle with the "over use of sarcasm" stick
15:19:56 <KrispyKringle> shapr: i actually think you've got a really neat idea. But it wouldn't be a replacement for DNS.
15:20:04 <poetix> shapr: Yet another pr0n finding service...
15:20:05 <KrispyKringle> shit, i gotta change my terminal them eso i can see who's beating me.
15:20:09 <shapr> hahaa
15:20:15 <tuomov> IPs still need to be assigned by someone, and they change when the machine changes
15:20:29 <tuomov> a cryptocraphic key could stay the same for a long time
15:20:34 <shapr> interesting point
15:20:37 <KrispyKringle> ipv6 could stay the same for a long time.
15:20:44 <shapr> IP - Identity Protocol
15:20:58 <KrispyKringle> so you'd route things to people based on their key signature...?
15:21:03 <shapr> Why not?
15:21:04 <tuomov> if the machine is moved, the ip changes or else the system becomes complicated
15:21:09 <poetix> ef03b-27cf-11a2bce-b667a0: good point
15:21:22 <KrispyKringle> you know, i was thinking of doing a peer-to-peer key exchange system sorta like this for my senior design.
15:21:40 <shapr> Most of the p2p services do use a system like that.
15:21:48 <shapr> Though I've forgotten its name.
15:21:50 <KrispyKringle> th added advantage of this is that you can calculate the shortest (i.e. most trusted) method of exchanging keys)
15:21:52 <tuomov> instead of dns you'd have servers where everyone can advertise their public keys
15:21:55 <poetix> ef03b-27cf-11a2bce-b667a0: I am not a number - I am a *globally unique number*!
15:21:59 * shapr laughs
15:22:01 <KrispyKringle> shapr: not for identity verification.
15:22:17 <SamB> tuomov: what about truly p2p networks?
15:22:32 <shapr> I haven't thought about identity in p2p networks.
15:22:34 <tuomov> you create links by the public keys in web pages and so on, and the machine is found by looking for this key, and verified to be that machine too
15:22:53 <poetix> My utter heroine Verity Stob has the best line about GUIDs - sometimes she generates 3 or 4 at a time, and chooses the nicest-looking one...
15:22:57 <tuomov> SamB: the keys could be published in a p2p manner
15:23:24 <shapr> Ok, lots of good ideas, where do we get a p2p Haskell toolkit?
15:23:31 * poetix glances at his watch
15:23:32 <shapr> musasabi wrote SerTH, what else do we need?
15:23:48 <shapr> Oh, I know, an OpenSLP binding
15:23:53 * shapr digs around
15:24:02 <shapr> What else do you need for a p2p toolkit?
15:24:08 <poetix> lawyers
15:24:27 * shapr stares at poetix with the "that wasn't and I'm not about to laugh, really" look.
15:24:32 * shapr bursts out laughing
15:24:49 <shapr> shhh, the fiancee is sleeping!
15:25:09 <poetix> Speaking of which, my wife is about to come and start beating me about the head
15:25:12 * shapr grins
15:25:19 <KrispyKringle> shapr: thats my point--that you can exchange keys in the shortest-path manner. i actually saw an implementation of this for gpg somewhere...
15:25:23 <KrispyKringle> but it's not it's not p2p.
15:25:25 <poetix> So long for now...
15:25:29 <shapr> g'night poetix
15:25:59 <shapr> Man, I was gonna set up the Author's Wiki this last hour or so.
15:26:05 <shapr> Too many interesting people to talk to.
15:26:35 <KrispyKringle> what's the author's wiki?
15:26:46 <shapr> For The Monad.Reader part II, the Revenge.
15:26:54 <shapr> You're going to write your article, yes?
15:27:08 * shapr stares at KrispyKringle 
15:27:48 <KrispyKringle> Hahaha. I don't think I'm qualified ;)
15:28:03 <shapr> That's okay, I'm not qualified to be an editor.
15:28:07 <KrispyKringle> I'm a sort of monad monkey. I type arrow signs and bindings until things compile :P
15:28:24 <shapr> See, this means you have the perfect situation for writing a tutorial!
15:28:27 <KrispyKringle> The great thing about Haskell is that, unlike most other languages (and despite the opinion of the unwashed masses), a monkey can truly code in it.
15:28:30 <KrispyKringle> Because if it compiles, it works!
15:28:41 <shapr> So, write up something that you learned recently!
15:29:05 <KrispyKringle> Well, maybe after I finish this term. I've got about two weeks of hitting my head against a wall before I start work. ;)
15:29:06 <shapr> Discuss lessons learned, conclusions concluded, illusions eluded...
15:29:32 <shapr> C'mon, it'll be fun!
15:30:23 <KrispyKringle> eventually :P
15:30:37 <shapr> ok, I'll bug you tomorrow :-P
15:30:42 <KrispyKringle> haha
15:30:47 * shapr has a very small definition of eventually.
15:30:48 <ski> shapr : you're trying to lure him to write in monadreader ?
15:30:50 <shapr> yes!
15:30:55 <shapr> ski: do you want to write also?
15:31:00 <toomasr> shapr in action
15:31:03 <ski> not sure
15:31:04 <KrispyKringle> ski: should've kept your mouth shut ;)
15:31:08 <shapr> hiya toomasr!
15:31:10 <toomasr> hi :)
15:31:17 <shapr> You want to write too, don't you?
15:31:20 <ski> i don't know how to make pdfs or ps or latex or ...
15:31:29 <shapr> That's not necessary.
15:31:32 <toomasr> i always want to write
15:31:34 <toomasr> code
15:31:35 <shapr> If you can write into a wiki, you got it.
15:31:41 <ski> KrispyKringle : realized that afterwards ;)
15:31:49 <KrispyKringle> w00t! it compiles!
15:31:59 <toomasr> so it must work
15:32:05 <KrispyKringle> exactly!
15:32:10 <shapr> Man, I gotta upgrade various wikis to moin 1.3
15:32:16 <ski> shapr : hmm, when will it be out ?
15:32:21 <shapr> Too bad Flippi doesn't do everything moin does yet.
15:32:26 <ski> (i.e. how long time ?)
15:32:32 <shapr> ski: TMR should be release 1st of the month.
15:32:37 <ski> oki
15:32:42 <ski> ?
15:32:42 <shapr> grr
15:33:17 <ski> was that you from next month just going back in time for a while ?
15:33:22 <shapr> hah
15:33:26 <shapr> stoopid irc client
15:33:30 <KrispyKringle> hmm. it doesn't work.
15:34:02 <shapr> I need to fix my auto-connect-to-irc elisp code, but I really don't want to hack anymore elisp
15:34:07 * shapr wishes for Yi
15:34:08 <ski> shapr : i could try to keep in mind to see if i can find something that might be appropriate ..
15:34:14 <tromp> hi shapr
15:34:23 <shapr> hoi tromp, writing for TMR2?
15:34:29 <tromp> i'm reading the Archy FAQ
15:34:37 <tromp> it has this funny qst:
15:34:39 <tromp> Q. Why are you using Python, [insert favorite programming language here] is WAY better!
15:34:51 <shapr> Kolmorogov Complexity and how it applies to programming languages?
15:35:00 <ski> shapr : me ??
15:35:04 <lispy> hah, i was looking at the graph wrong, gnuplot was reading the data just fine
15:35:06 <lispy> stupid me
15:35:27 <shapr> tromp is the nearest expert on Kolmorogov Complexity that I know.
15:35:35 <ski> aha
15:36:24 <ski> shapr : i have lots of ideas lying around ..
15:36:33 <shapr> tell me!
15:36:39 <ski> shapr : but not sure if anything that fit TMR
15:36:45 <ski> now ?
15:36:52 * ski looks frightened
15:36:57 <shapr> Can you think of three or four ideas that might fit TMR?
15:37:00 <shapr> Something Haskell related?
15:37:08 <ski> maybe
15:37:22 <shapr> It's not like *I* have a clue how to run a magazine. I just hit buttons and hope it all works out.
15:37:50 <ski> i know i have old haskell notes from when i tested around when learning the lang
15:38:02 <ski> but those might be more or less obvious
15:38:07 <shapr> Not to everybody.
15:38:10 <ski> (now, i.e.)
15:38:15 <tromp> i think kolmogorov complexity may be a little too esoteric
15:38:51 <shapr> I doubt it.
15:39:01 <tromp> perhaps a story on connect4 in haskell wld be of more interest
15:39:08 <shapr> Sure, sounds great!
15:39:22 * ski confesses he hasn't actually read all of TMR1, yet
15:39:30 <shapr> I'm terribly interested in Kolmorogov Complexity, not sure who else.
15:39:45 <ski> why ?
15:39:48 <shapr> Not interested enough to buy the book yet. But that's more a lack of funding than anything else.
15:40:00 <tromp> you're that poor:-?
15:40:24 <tromp> Chaitin has several books online for free
15:40:32 <shapr> No, but I'd like to fly to the USA and see my family, and I'd like to buy new hardware, and I'd like to buy an expensive unicycle, and ...
15:40:54 <shapr> It gets hard to choose. Family or Category Theory?
15:41:00 <tromp> i have some links to them from my webpage
15:41:18 <ski> shapr : there was someone who has an "auto-stabilizing" unicycle, i saw somewhere (on web)
15:41:28 <shapr> Yes, that's Trevor Blackwell's Eunicycle.
15:41:45 <ski> that looked like real fun !
15:42:17 <shapr> Trevor is a truly fascinating person. His full emulation of a TV in the xscreensaver sources is a pinnacle of ... well, something.
15:44:12 <shapr> toomasr: want to write for TMR?
15:44:30 <RemiTurk> good night everyone
15:44:32 <shapr> Let's see, who can I pick on?
15:44:34 <toomasr> shapr: yay, but i'm not ready yet
15:44:35 <shapr> g'night remi
15:44:38 <ski> shapr : how many has signed up, yet ?
15:44:48 <shapr> Well, I have two definites.
15:44:52 <shapr> Three actually.
15:44:55 <ski> ok
15:45:21 <shapr> It seems that people jump in and drop out a lot before the publication date arrives.
15:46:03 <shapr> So it's very hard to say how many articles will really happen.
15:46:11 <ski> hm, swierstra ?
15:46:20 <ski> hm
15:46:21 <shapr> I hope
15:46:31 <ski> not *the* swierstra, or ?
15:46:38 <shapr> Nah, Wouter Swierstra his nephew.
15:46:43 <ski> ah, ok
15:46:50 <shapr> He has a possible article on Attribute Grammars.
15:46:55 * ski can't remember the first names
15:46:56 <ski> hm
15:47:00 <ski> hm
15:47:03 <ski> doaitse ?
15:47:08 <ski> cool
15:47:14 <shapr> That's very interesting to me, because most of the uu.nl guys think that Attribute Grammars get rid of the need for arrows.
15:47:26 <shapr> I just don't see it, so I want more details.
15:47:34 * ski would like to play around with attribute grammars
15:47:37 <shapr> Me too
15:47:40 <ski> mhm
15:47:45 <shapr> So if Wouter writes a demo article, I can.
15:47:45 <ski> i'm not sure of that
15:47:59 <ski> did they say so explicitely ?
15:48:07 <shapr> That's been my opinion also. I just don't see how AGs beats arrows.
15:48:24 <shapr> But they say that AGs do.
15:48:29 <shapr> So maybe I just don't understand something.
15:48:30 <ski> maybe there are at some overlapping areas
15:48:36 <shapr> There are some.
15:48:53 <shapr> But I still don't see it.
15:49:00 <shapr> Anyway, that's why I hope Wouter writes his article.
15:49:06 <ski> ok
15:50:11 <ski> i'm interested in how AGs help with the old assymmetry with methods in OO and pattern-matching-functions in FP
15:50:23 <ski> and also in how AGs are related to Logic Programming
15:50:52 <ski> s/help/solve similar problems in another way/  maybe
15:51:28 <shapr> There's obviously something nifty about AGs if the uu.nl guys like them so much. I want to play too!
15:52:18 <ski> :)
15:53:03 <ski> i think i read someone write somewhere that it can be considered to be another declarative paradigm (alongside functional and logic)
15:53:19 <shapr> I just don't see it yet. :-(
15:53:36 <shapr> It's like seeing a toy in the shop window that I can't buy yet.
15:53:38 <ski> anyway, it seems to allow better modularity in some ways
15:53:43 <ski> mhm
15:54:33 <ski> what we need in a hands-on-experience !
15:54:59 <shapr> yes!
15:55:12 <ski> (s/in/is/)
15:55:13 <shapr> And I checked out the UUAG library long ago, but could not get it working.
15:55:38 <shapr> So, if Wouter writes a demo article, I'll be able to try it!
15:55:46 <ski> some (at least) AG idioms can be used in haskell directly, anyways
15:55:59 <musasabi> AGs seem quite interesting..
15:56:14 <musasabi> Would be really nice to see more of them.
15:56:39 <ski> but the AG approach makes you think a bit differently about problems, so the programs gets different  (often more or less "cyclic", like the old repMin)
16:02:46 <ski> (shapr : a lot of my notes are more about questions than about answers, though ..  but maybe i can find something appropriate and large enough ..)
16:03:53 <shapr> Good questions make excellent articles also.
16:04:24 <ski> and some are dissatisfactions with typesystem, etc ..
16:04:53 <ski> (and some are about various logic, or category theory, .. :)
16:05:08 <ski> shapr : i'll try to keep it mind, anyway
16:18:28 <shapr> Igloo: truly, you got a good quote from darcsdevel
16:18:50 <shapr> "A lot of the commutation-using code tends to be pretty unreadable, but I think this one takes the cake." --David Roundy
16:19:25 <ski> commutation ?
16:19:50 <ski> in darcs source ?
16:20:04 <shapr> Of course, the earlier Igloo quote where David said "This reduces memory usage and cpu time by 20%" is also quite spiffy.
16:20:51 <ski> mhm
16:20:54 <shapr> recent post to darcs-devel
16:21:06 * ski tries to code AVL
16:21:58 <gzl> wow, this makes no sense
16:33:23 <dons> @yow
16:33:25 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
16:33:25 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know
16:33:25 <lambdabot> WHY!!
16:36:46 <ski> hello waltz
16:37:25 <waltz> hi
16:38:38 <ski> learning haskell ?
16:39:18 <waltz> no
16:39:23 <waltz> you?
16:39:57 <ski> heh
16:39:58 <ski> no
16:40:33 <ski> i'm trying to code AVL in haskell atm
16:40:46 <KrispyKringle> avl?
16:41:01 <ski> yeah
16:41:06 <waltz> ah
16:41:18 <ski> a kind of mostly balanced search tree
16:41:31 <waltz> I've heard of AL
16:41:33 <waltz> AVL*
16:42:21 <ski> but it goes a bit slow, atm
16:42:58 <ski> mostly because i've not coded it before so i need to develop each specific case, and also because i'm tired
16:46:01 <Khisanth> shapr: you around?
17:08:02 <jaredj> hello all, i'm seeking guidance on the Haskell Way. -
17:08:38 <jaredj> I've got two text files - one with expenses, in format "$5.00,supermarket,2005/04/02,card"
17:09:03 <jaredj> one with expense groups, e.g "supermarket,grocery", "asian store,grocery"
17:09:25 <jaredj> i want to print a summary of what i've spent by group.
17:10:12 <jaredj> i've read the things out and put them in tuples, and i'm trying to deal with the tuples, and getting nothing but type troubles
17:10:59 <jaredj> i'm using lookup to look things up associatively but it doesn't feel haskelly, it feels more pythonic
17:12:31 <ski> hm
17:12:48 <nuffer> hi, I'm trying to get ghc working, but I'm having problems
17:12:53 <nuffer> ghci works fine
17:13:11 <nuffer> but the file, for instance, test.hs 'main = putStr "Hello World!\n"' doesn't compile
17:13:24 <nuffer> add.h:1: error: `putStr' undeclared here (not in a function)
17:14:16 <KrispyKringle> jaredj: im sorry, so you have a list of tuples of the form (cost, store) and a list of stores and you want to see the sum costs for each store?
17:15:13 <jaredj> nuffer: you might need to import IO?
17:15:37 <nuffer> oh, I just realized, I had the .h instead of .hs file extension
17:15:40 <nuffer> that was breaking it for some reason
17:15:58 <jaredj> krispykringle: i have a list of (cost,store) and a list of (store,category) and i want to see the sum for each category
17:15:59 <nuffer> are there any good haskell IDEs?
17:17:11 <jaredj> nuffer http://haskell.org/libraries/#ide perhaps
17:17:28 <jaredj> haven't tried any of them.
17:18:14 <jaredj> doesn't look like they include debugging
17:18:52 <KrispyKringle> jaredj: ok. so here's what i'm thinking...
17:19:27 <KrispyKringle> we want to generate a list of costs for each category, right? so, you want to map some function across the list of categories, first.
17:19:57 <KrispyKringle> that function should take each store that's in the given category and filter out each entry for that store from the other list (using filter)
17:20:10 <KrispyKringle> then map across the result of filter a sum function that sums up all the costs.
17:20:20 <KrispyKringle> so its like, three or four maps and a couple filters and a fold. :P
17:21:02 <nuffer> what's the pattern for any non-empty list?
17:21:52 <jaredj> nuffer: (x:xs)
17:22:03 <nuffer> what if I want to access the list as a whole though?
17:22:10 <nuffer> do I need to reconstruct it as x:xs ?
17:22:40 <jaredj> nuffer: nah - just define the fn for [] first and then fn x = blabla
17:22:55 <jaredj> if it's empty it will match the [], otherwise go to the x part.
17:23:09 <nuffer> okay
17:23:44 <ski> nuffer : if you want both the whole and the parts you can do   f xs0@(x:xs) = ...
17:24:21 <nuffer> ah, thanks
17:24:55 <jaredj> ski: ? cool so xs0 == the whole list and x == head xs0 and xs == tail xs0?
17:26:09 <ski> right
17:26:43 <ski> can also be used nested, of course
17:26:51 <nuffer> if I'm writing a function of type [a] -> ([a], [a])
17:27:01 <nuffer> gah, I really don't understand a lot of the syntax
17:27:10 <nuffer> how do I access the return types of a function?
17:27:15 <nuffer> or rather return values
17:27:34 <jaredj> you might like to use a let or a where
17:27:44 <nuffer> basically, what I want to do is write a function that takes a list and splits it into two
17:28:06 <ski> and you want to access the result from the recursive call ?
17:28:10 <nuffer> yes
17:28:24 <nuffer> because, let's say I have [1, 2, 3]
17:28:24 <ski> f (x:xs) = let (a,b) = f xs in ....
17:28:28 <ski> or
17:28:34 <ski> f (x:xs) = ...
17:28:36 <ski>   where
17:28:41 <ski>   (a,b) = f xs
17:28:43 <nuffer> okay
17:29:46 <ski> (the 'where' can only be attached to the outermost of a definition-"line", while the 'let' can be attached to any subexpression)
17:32:45 <nuffer> could I see an example of using an if statement in haskell?
17:35:44 <ski> sure
17:36:04 <ski> fac n = if n == 0 then 1 else n * fac (n-1)
17:36:25 <ski> though, it's really an if *expression*, not statement
17:37:19 <ski> (or did you mean in do-expression ?)
17:38:06 <nuffer> expression rather, sorry
17:38:19 <ski> np
17:42:25 <nuffer> http://muer.njoerdba.com/paste/view.aspx?id=f33d194d-a2dc-401c-bff1-f7b9a1bf23c9
17:42:30 <nuffer> can you tell me, perhaps, why that won't work?
17:42:40 <nuffer> something about line 6, No instance for (Ord a)
17:42:53 <nuffer> but I really don't understand what's up with it
17:42:55 <ski> looking
17:44:06 <ski> merge and msort need an "Ord a =>" constraint in the type signatures
17:44:19 <nuffer> what does that mean?
17:44:24 <ski> because merge uses (<) and (>=), and msort uses merge
17:44:36 <nuffer> so where do I put that?
17:44:47 <ski> just after the ::
17:44:59 <lispy> nuffer: do you know what Ord a means?
17:45:08 <nuffer> I'm guessing that they can be compared
17:45:20 <lispy> yeah
17:45:23 <lispy> ordered
17:45:27 <ski> the Ord a constraint means that the function works for all types a, *provided* they have defined ordering
17:46:27 <juhp> is there an "easy" way to tell cabal setup "I want to install this package privately"?
17:47:09 <ski> nuffer : your merge seems weird
17:47:21 <jaredj> i have a function that takes a Maybe String, and a list of Strings. i want to map the function over the list. how do i do it?
17:47:30 <nuffer> ski, in what way?  the merge sort works
17:47:46 <jaredj> can i map Just my_list_of_strings?
17:48:38 <ski> nuffer : you don't exploit that y is also already sorted
17:48:51 <gzl> jaredj: yes
17:48:55 <nuffer> how do I know that y is sorted
17:49:11 <nuffer> I could call merge [1] [3, 2]
17:49:40 <dcoutts> juhp: isn't that what --user is for?
17:49:45 <ski> nuffer : usually, one steps through both lists at the same time, and doesn't need to use either of (++) and list comprehensions  (it's inefficient to put the y into it in that way)
17:49:53 <nuffer> yeah, you're right
17:50:12 <dcoutts> juhp: as in ./setup configure --user and ./setup register --user
17:50:19 <gzl> jaredj: Just :: a -> Maybe a, so it's just a function and you can map it like anything else
17:50:34 <ski> nuffer : you don't know that the second list is sorted, though you prolly don't care much about what happens if it is not sorted
17:50:34 <nuffer> let me try and rewrite this to something more sensible
17:50:55 <juhp> dcoutts: dunno, that's why I'm asking :)
17:51:05 <ski> nuffer : msort only passes sorted lists to merge (provided msort works)
17:51:12 <juhp> anyway doesn't seem to work for http for me anyway...
17:51:30 <juhp> http% ./setup register --user
17:51:30 <juhp> Registering HTTP-0.4...
17:51:30 <juhp> Reading package info from ".installed-pkg-config" done.
17:51:30 <juhp> ghc-pkg: /usr/local/lib/HTTP-0.4 doesn't exist or isn't a directory
17:51:34 <dcoutts> juhp: well ./setup configure --help and ./setup register --help claim that this is the case
17:51:48 <nuffer> this is true
17:52:17 <ski> got an idea of how to do it better now ?
17:52:37 * ski must leave now
17:52:47 <dcoutts> juhp: that error occured after you'd done ./setup copy ? (or install)
17:52:52 <ski> nuffer : good luck
17:54:36 <nuffer> merge x0@(x : xs) y0@(y : ys) = if (x < y) (x : merge xs y0) else (y : merge x0 ys)
17:54:41 <nuffer> why am I getting a parse error on "else"?
17:55:04 <juhp> dcoutts: guess one needs to pass an explicit prefix
17:55:52 <juhp> what would be nice is if there was a .ghc/version/ dir say where user package were install by default :)
17:55:57 <dcoutts> juhp: you mean ./setup configure --prefix=
17:56:07 <juhp> yes
17:56:31 <dcoutts> you say you're packaging the http package? as in the dep of HXT?
17:56:33 <juhp> dcoutts: afaics --user is only about deps
17:56:57 <nuffer> oh, I had just missed the then
17:56:59 <juhp> dcoutts: well ghc packaging, yes
17:57:19 <dcoutts> --user for the configure subcommand is for deps, --user for the register subcommand is for which package database to use
17:57:30 <juhp> right
17:57:34 <dcoutts> so yes, none of those affect the install lcoation
17:58:01 <dcoutts> I mean you're packaging this: http://www.dtek.chalmers.se/~d00bring/haskell-xml-rpc/http.html
17:58:11 <juhp> yes, exactly
17:58:18 <juhp> I mean that is right
17:58:24 <dcoutts> If so, I was wondering if there's a 'released' .tar.gz anywhere
17:58:46 <juhp> hmm, I didn't see one on the webpage
17:59:16 <dcoutts> it makes me a little nervous takeing a darcs snapshot (I'm was looking at packaging it for Gentoo)
17:59:30 <juhp> hehe, yea
17:59:36 <dcoutts> (since it is a dep of the new HXT)
17:59:41 <juhp> right
18:00:10 <dcoutts> so we just take a snapshot and mirror that ourselves. ho hum.
18:01:03 <dcoutts> so have you got a .cabal -> .spec script yet :-)
18:01:14 <juhp> nope
18:01:16 <juhp> :-/
18:01:36 <dcoutts> I should be helping write a .cabal -> .ebuild script
18:02:22 * juhp tries setup sdist
18:03:17 <dcoutts> why does ./setup sdist require ./setup configure to have been run?
18:04:47 * juhp wonders if it is ok just to call the package HTTP?
18:05:16 * juhp pondering googling for it
18:06:30 <wagle> googling for the keyword "http" should be easy
18:09:55 <dons> package HTTP?
18:10:03 <jaredj> lol
18:10:29 <dons> anything like MiniHTTP used by lambdabot? Oh - it is!
18:10:55 <jaredj> is there a minBy function?
18:11:08 <dons> @type List.minimumBy
18:11:13 <lambdabot> List.minimumBy :: forall a. (a -> a -> Ordering) -> [a] -> a
18:11:19 <jaredj> ah thanks
18:11:40 <jaredj> er
18:11:51 <jaredj> where's Ordering?
18:12:11 <dons> you use the compare function
18:12:13 <dons> @type compare
18:12:15 <lambdabot> compare :: forall a. (Ord a) => a -> a -> Ordering
18:12:22 <jaredj> oh ok
18:13:54 <jaredj> my main has a do with a let in it. is there any way i can get at the things let there, from the Hugs prompt?
18:14:12 <dons> @plugs List.minimumBy (\x y -> (fst x) `compare` (fst y)) [(1,'z'),(2,'o')]
18:14:13 <lambdabot> (1,'z')
18:15:16 <jaredj> can you say that in a point-free way?
18:15:37 <dons> @pl List.minimumBy (\x y -> (fst x) `compare` (fst y)) [(1,'z'),(2,'o')]
18:15:37 <jaredj> like List.minimumBy (compare . fst fst) or something?
18:15:37 <lambdabot> List . minimumBy ((. fst) . compare . fst) [(1, 'z'), (2, 'o')]
18:15:46 <jaredj> cool.
18:15:49 <dons> lambdabot knows all
18:16:08 <dons> though it gets hierarchical names confused with (.)
18:16:15 <jaredj> ah
18:16:40 <dons> @pl minimumBy (\x y -> compare (fst x) (fst y)) [(1,'z'),(2,'o')]
18:16:41 <lambdabot> minimumBy ((. fst) . compare . fst) [(1, 'z'), (2, 'o')]
18:16:48 <dons> interesting.
18:18:33 <bd_> @pl \x y z -> (x z) (y z)
18:18:34 <lambdabot> s
18:18:44 <bd_> s is a built-in?
18:18:59 <bd_> @type s
18:19:01 <lambdabot> bzzt
18:19:17 <dons> s is lambda calculuus
18:20:04 <bd_> yeah, I gave its definition in the @pl query. I just thought @pl restricted itself to Prelude functions
18:20:09 <dons> @get-definition S
18:20:10 <lambdabot> S = \f g x.f x (g x)
18:20:31 <dons> oh, oops. /me should read scroll back
18:20:38 <ibid> good early morning :)
18:21:16 <jaredj> @type thd
18:21:18 <lambdabot> bzzt
18:21:35 <bd_> @pl \x -> x x
18:21:36 <lambdabot> s id id
18:21:53 <jaredj> @type thrd
18:21:55 <lambdabot> bzzt
18:22:08 <jaredj> um is there nothing beyond snd?
18:22:37 <ibid> what's the third element of a pair
18:22:39 <ibid> ?
18:22:40 <dons> nope. we have case for that.
18:23:06 <jaredj> case?
18:23:14 <dons> i.e. roll your own ;)
18:23:33 <dons> @google MiniHTTP.hs
18:23:33 <jaredj> *slaps head* forgot patternmatching
18:23:34 <ibid> for fst, snd, thr etc to work for arbitrary tuples, there'd need to be a lot of type classes for that
18:23:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/lambdabot/MiniHTTP.hs
18:23:38 <dons> @google HTTP.hs
18:23:39 <lambdabot> http://hs-lug.tux.org/
18:25:43 <ibid> if that were, then we'd have fst :: OneTuple t => t a -> a, snd :: TwoTuple t => t b -> b, trd :: ThreeTuple t => t c -> c
18:26:01 <ibid> blah, not that
18:26:12 <ibid> if that were, then we'd have fst :: OneTuple t => t a -> a, snd :: TwoTuple t => t a b -> b, trd :: ThreeTuple t => t a b c -> c
18:26:53 <ibid> blah, and it can't even work that way
18:28:36 <Igloo> Does anyone know if there's anything about hPutBuf not being required to obey the buffering mode?
18:28:51 <bd_> ibid: trd :: (a, b, b) -> c ?
18:30:50 <jaredj> Duration: TimeDiff{tdYear=0,tdMonth=0,tdDay=0,tdHour=0,tdMin=0,tdSec=-5184000,tdPicosec=0}
18:31:04 <jaredj> argh
18:33:49 <nuffer> does haskell have any metaprogramming facilities?
18:34:24 <jaredj> Template Haskell perhaps?
18:34:43 <jaredj> monads :)
18:40:08 <ibid> bd_: yes, but then snd won't work on triples
18:40:31 <bd_> oh, I see.
18:41:33 <bd_> hm, why aren't tuples defined as a recursive data structure, allowing compiler optimization? it'd make things like this easier.
18:41:55 <ibid> because then they'd be just lists
18:42:44 <bd_> Not precisely; something like data Tuple a b = (,) a b
18:42:51 <bd_> so, the type of b need not be a tuple itself
18:43:11 <skew> You can use nested pairs if you like
18:43:20 <ibid> then a triple would be Tuple a (Tuple b c)
18:43:24 <bd_> And add a note the the spec that it is suggested that a right-nested tuple should be copied rather than referenced
18:43:25 <ibid> yeah, what skew said
18:43:39 <skew> but you still can't write a function to look up the nth element without dependent types
18:44:19 <bd_> Dependent types?
18:44:43 <ibid> bd_: something that haskell lacks :)
18:55:54 <Pseudonym> Could someone update LocalBadContent please?
18:56:09 <Pseudonym> More wiki spam.
19:25:26 <KrispyKringle> shapr: mind if i pick your brain on haskelldb again?
19:25:40 <KrispyKringle> im a little confused by what might be wrong with this, since I pretty much made it straight from an example: http://rafb.net/paste/results/k6ZpfG37.html
19:25:56 <KrispyKringle> Database.hs:39:
19:25:56 <KrispyKringle>     Couldn't match `Maybe String' against `[Char]'
19:25:56 <KrispyKringle>         Expected type: Maybe String
19:25:56 <KrispyKringle>         Inferred type: [Char]
19:27:30 <KrispyKringle> I think maybe I'll just use HSQL itself.
19:33:00 <blackdog> KrispyKringle: i don't know anything about haskelldb, but you can convert a [Char] into a Maybe String using 'Maybe.Just'
19:33:15 <ibid> Just is in the prelude
19:34:07 <blackdog> Is it? I'm used to having to import Maybe... oh well.
19:34:25 <ibid> isJust etc are in Maybe
19:34:30 <KrispyKringle> blackdog: yeah, sure, but that doesn't SEEM to be the problem.
19:35:49 <blackdog> you're getting it on the line:
19:35:50 <blackdog>  mapM_ (putStrLn . showNode) nodes
19:35:51 <blackdog> ?
19:40:04 <KrispyKringle> great. hsql isn't working, either.
19:40:59 <KrispyKringle> blackdog: line 39
19:41:01 <KrispyKringle> er
19:41:20 <KrispyKringle> so yeah
19:41:36 <KrispyKringle> i mean, yeah, that maeks sense. i just didn't think that was necessary.
19:41:40 <KrispyKringle> *shrug*
19:42:18 <KrispyKringle> guess ill try fromMaybe
19:43:12 <KrispyKringle> Database.hs:41:
19:43:12 <KrispyKringle>     Couldn't match `Maybe [Char]' against `Record vr'
19:43:12 <KrispyKringle>         Expected type: [Maybe [Char]]
19:43:12 <KrispyKringle>         Inferred type: [Record vr]
19:43:12 <KrispyKringle>     In the second argument of `mapM_', namely `nodes'
19:43:16 <KrispyKringle> so, no luck
19:45:55 <KrispyKringle> odd
19:46:01 <KrispyKringle> ive got back a Record. I'm just not sure how to get the value out.
20:14:56 <gzl> if I have (case x of ...), is there a way of treating two different cases of x (say 'a' or 'b') as a single case? i.e. doing the same thing in either case
20:15:33 <skew> gzl not in the case syntax
20:15:54 <skew> OCaml allows something equivalent to case x of Left x | Right x -> fun x
20:15:55 <gzl> so i'd have to do if (x == 'a' || x == 'b') or something to this effect?
20:16:07 <skew> as long as the patterns have the same variables
20:16:13 <skew> How complicated is the action?
20:16:31 <skew> I would probably repeat something trivial, or abstract it out as a function
20:16:39 <gzl> not complicated. essentially (return foo) where foo is one of two different strings.
20:17:00 <skew> is foo different between the two cases?
20:17:16 <dons> case () of {_ | x == 'a' || x == 'b' -> foo ; | otherwise -> dont foo }
20:17:35 <gzl> skew: yes.
20:17:38 <dons> what about pattern guards?
20:17:43 <gzl> hm.
20:17:55 <skew> I don't see how it is the same case if you want a different string
20:17:56 <dons> dox | x <- y, x == 'a' || x == 'b' = foo
20:18:21 <gzl> skew: sorry, let me restate. I have a string x that can take on, say, 10 values. for half the values I want to return foo. for the other half I want to return bar.
20:18:36 <gzl> dons: this is in the middle of a do block; I can't still do that, can I?
20:18:46 <gzl> er, I suppose I could just write an auxiliary function
20:18:52 <dons> with case () of {_ ..
20:18:57 <gzl> yeah
20:18:59 <gzl> ok.
20:19:00 <skew> oh, if it's like that, then you should probably be testing list membership anyway, rather than explicitly listing all the cases
20:19:17 <skew> if x `elem` fooStrings then foo else notFoo
20:19:27 <gzl> ah, that's kind of nice. maybe i'll do that.
20:19:36 <gzl> thanks.
20:20:38 <dons> main = do
20:20:39 <dons>     let s = 'a'
20:20:39 <dons>     let b = case () of {_
20:20:39 <dons>         | x <- s, x == 'a' || x == 'b' -> True
20:20:39 <dons>         | otherwise                    -> False
20:20:41 <dons>     }
20:20:50 <skew> I think pattern matching against constant strings is a bad idea anyway
20:21:19 <dons> pattern guards are so much fun.
20:21:55 <dons> hmm. don't even need the case () of .. in the above, since it's a bind
20:22:39 <skew> either the strings are pretending to be an algebraic data type and you should use a real algebraic data type, or the strings are being data and you should be getting the strings to compare against out of some data structure rather than hardcoding them
20:23:14 <dons> but it would seem that for the general problem of fall-throughs in switches, pattern guards seem appropriate
20:23:39 <dons> any thoughts on that?
20:24:30 <skew> what do you mean? like fall-through in a switch statement in C?
20:24:41 <dons> yes. that functionality.
20:24:58 <skew> I have no idea how to get that with pattern guards
20:25:05 <dons> rather than case x of A -> f ; B -> f ; C -> f
20:25:17 <skew> oh, you mean matching a bunch at once
20:25:26 <dons> you write: case () of {_ | y <- x, x == A || x == B -> f
20:26:08 <dons> case () of {_ | y <- x, y == A || y == B || y == C -> f }
20:26:14 <cm> "..it felt like springtime"
20:26:17 <cm> salut
20:26:35 <skew> I like something like maybe default id (assoc specialStrings x)
20:27:05 <gzl> I like the list element thing for this, actually.
20:27:12 <gzl> there are only 3 things in the list, so it's not too bad.
20:27:24 <dons> I'm thinking more of emulating a switch with a number of different fall throughs
20:27:39 <dons> not too common, sure.
20:28:01 <skew> I ask why your control flow depends on switching on strings
20:28:15 <dons> it doesn't have to be strings, see the above code.
20:28:36 <gzl> I have to use this weirdo command line utility, and it has weird output that indicates whether something succeeded or failed (whether it was able to produce HTML), so I need to check it to see whether I should output HTML or print an error.
20:28:48 <gzl> it's an odd situation.
20:28:52 <dons> the problem is how to write a switch with multiple fall throughs concisely
20:29:41 <skew> gzl: my third case where you might be pattern matching would have been parsing apart a string, but I thought that was a bit unusual
20:30:15 <skew> for that situation it's probably easiest to extract what you want with a regular expression rather than taking the output apart with list processing tools and pattern matchins
20:30:43 <gzl> I'm processing the full output with Parsec
20:30:54 <gzl> but I still need to switch on this one status character
20:31:16 <skew> You could parse that out in Parsec too
20:32:03 <cm> got a HaXml question. I just got the latest version from CVS and make'd/installed it (GHC 6.4). ghci -package HaXml works fine, but I can't find any interface
20:32:38 <gzl> skew: oh, do the whole condition and return stuff in parsec? i guess, but this seems more concise
20:32:47 <cm> (i.e. if I do  :m Text.XML.HaXml.Xml2Haskell, I get an error (module not found))
20:32:48 <skew> rather than data Output = ... inscrutableOutputCharacter :: Char ... , define data StatusOutput = Failed | Happy, and make your parser (chars "AQX" >> return ProcessingFailed) <|> (chars "asdfe" >> return Happy)
20:32:51 <cm> ..anyone got an idea?
20:33:05 <gzl> ah, I suppose I could do that.
20:33:22 <skew> chars "characters I like" >> return foo is much much simpler than case 'a' -> foo | 'b' -> '
20:33:33 <skew> 'b' -> foo | 'c' -> foo | 'd' -> foo, etc.
20:33:39 <Lemmih> cm: What does 'ghc-pkg describe HaXml' say?
20:33:59 <skew> and about as complicated as magicStatusCharacter `elem` happyStatusCharaters
20:34:09 <cm> ghc-pkg describe HaXml | grep Xml2
20:34:09 <cm>                  Text.XML.HaXml.Xml2Haskell Text.XML.HaXml.Xtract.Combinators
20:34:31 <skew> but it's the parsers job to turn whatever your tool outputs into nice and natural Haskell data structures, so I would turn a status character into some more meaningful type
20:34:47 <cm> Lemmih: but all the "-dirs" are empty
20:35:03 <cm> (library-dirs, import-dirs, etc)
20:35:20 <Lemmih> Good.
20:35:44 <cm> you know the solution? :)
20:36:02 <Lemmih> Are the modules exposed?
20:36:36 <cm> yes
20:36:43 <gzl> skew: you're right, ok.
20:36:46 <Lemmih> Is the package exposed?
20:36:58 <cm> exposed: False
20:37:18 <Lemmih> 'ghc-pkg expose HaXml' as root
20:37:48 <cm> done, same error
20:38:11 <Lemmih> Fix typo and try again.
20:38:14 <cm> (exposed is now True)
20:38:21 <cm> which error?
20:38:29 <cm> error->typo
20:38:45 <Lemmih> I don't know (: But you must have made one.
20:39:01 <cm> 'describe' now tells me that exposed is True.
20:39:20 <cm> but :m Text.XML.HaXml.Xml2Haskell still gives the same error
20:39:36 <Lemmih> Can you PM me the entire output from 'ghc-pkg describe HaXml'?
20:39:58 <cm> sure
20:48:48 <Kkaa> yo
21:01:57 <Lemmih> @seen bringert
21:01:58 <lambdabot> I haven't seen bringert
21:12:50 <Lemmih> Good morning, #haskell.
21:12:54 <SamB> I just noticed that NOTICEs don't show up on meme...
21:13:19 -Lemmih(~david@port97.ds1-oebr.adsl.cybercity.dk)- Really?
21:13:34 <Gahhh> I just noticed on meme that #haskell's been hugely active...
21:14:54 <SamB> okay, maybe they do, but they don't seem to show up in searches
21:16:08 <SamB> which makes it annoying when what I was trying to do was search for attempted invocations of @google.
21:17:53 <dons> try the clog logs: http://tunes.org/~nef/logs/haskell/05.04.13
21:18:32 <Lemmih> dons: Can hs-plugins load modules compiled with -fvia-c?
21:18:41 <dons> sure.
21:18:55 <dons> why wouldn't it? they all define the same symbols.
21:19:12 <dons> the exception being 6.4 on the mac, where things is busted for some reason :/
21:19:20 <dons> I blame wolfgang.
21:19:52 <dons> if ghci can load it, then hs-plugins can too -- they use the same rts code
21:19:54 <Lemmih> ozone told me otherwise. Or perhaps I just misunderstood him.
21:19:55 <musasabi> wolfgang seems to push deletion of stginit whenever possible :-)
21:20:33 <dons> I sit next to ozone at uni - i'll put a note on his computer telling him he's silly
21:21:48 <cm> do you always copy your homework from him? :)
21:22:31 <dons> no, I'm actually his tutor, so I get to set the homework.
21:23:27 <cm> grmpf :(
21:26:37 <skew> Okay, nobody is live on #java so I guess I'll ask this here.
21:26:53 <dons> @vixen what's your opinion of java?
21:26:54 <skew> I'm trying to build Aardappel, which has code split between src/ and src/r/
21:26:55 <lambdabot> i dunno...
21:27:04 <dons> @vixen what about Haskell
21:27:05 <lambdabot> church is my favourite computer scientist.
21:27:17 <dons> @vixen and Haskell programmers?
21:27:18 <lambdabot> church is my favourite computer scientist.
21:27:25 <Gahhh> @vixen what about church and state ?
21:27:26 <lambdabot> i dunno, what about?
21:28:06 <Gahhh> @vixen Are you well commented ?
21:28:08 <lambdabot> yes, i am
21:28:19 <skew> There's a file AardappelRuntime in src/ that doesn't declare a package, and everying in src/r/ declares "package r;", and tries to "import AardappelRuntime;"
21:28:32 <skew> the latter gives a syntax error complaining about an expected period after the name
21:29:05 <skew> I've played with classpath and stuff, read bits of tha Java language spec, and I've found no way to make this work.
21:29:32 * SamB gets to watch xerox looking at his code, even though xerox did that quite a while back
21:30:24 <skew> Come on, it's for a good cause. It's not like I'm actually working on Java code, just trying to rebuild an interpreter that happens to be written in Java :)
21:33:21 <SamB> so at 14:02 on 05-04-11, xerox saw @google in action
21:35:47 <SamB> and by 14:35, he had got @wikipedia working. Not bad, especially considering the fact that he was actually trying to understand the code. And I wonder how he knew wikipedia worked the same way as "I'm feeling lucky".
21:36:15 <dons> you're obsessing, SamB
21:36:36 <SamB> dons: hmm. probably.
21:39:23 <SamB> I just love this line every time I see it: <aheller> it says under it "but daddy, I don't *like* the lambda calculus"
21:44:19 <skew> "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
21:49:11 <skew> Does anybody know anything about that Java stuff?
21:50:04 <blackdog> Gahhh: Heh. Comments... I was going to add them in the next release, really I was...
21:50:23 <Gahhh> blackdog: But, but, I believed vixen !
21:50:36 <blackdog> More fool you, loverboy. :P
21:51:05 <SamB> @vixen, are you an idiot?
21:51:06 <lambdabot> i truely am
21:51:07 <blackdog> @vixen are you dishonest about your internal clarity?
21:51:09 <lambdabot> i never lie :)
21:51:22 <blackdog> So, dumb but honest
21:51:29 <Gahhh> and a spelling bee
21:51:43 <SamB> @vixen, are you an eliza?
21:51:44 <lambdabot> yes, i am
21:51:55 <blackdog> It's funny reading the regexes... it's all very artfully mis-spelled.
21:52:31 <Gahhh> like extra hyphens ?
21:52:41 <blackdog> ... grr.
21:52:51 <blackdog> sod's law\
21:52:55 <SamB> @vixen, have you a clue?
21:52:56 <lambdabot> what's the matter?
21:53:09 <SamB> huh?
21:53:24 <blackdog> @vixen, can you help me with my homework?
21:53:25 <lambdabot> of course i can
21:53:47 <blackdog> I think that's a default response to a question...
21:54:11 <dons> @vixen then can you help me write a list comprehension to sort some numbers?
21:54:13 <lambdabot> of course i can
21:54:27 <dons> @vixen can you help me encode it on the type level?
21:54:28 <lambdabot> of course i can
21:54:36 <blackdog> @vixen are you oleg?
21:54:37 <lambdabot> yes, i am
21:54:38 <dons> @vixen truly, you are the oleg of bots.
21:54:39 <lambdabot> why does everyone ask i'f on a bot?
21:54:43 <blackdog> hah!
21:55:39 <blackdog> dons: it might be nice to be able to load different personalities into vixen... if i can find some response libraries on the net, i might whack 'em in. :)
21:55:48 <dons> do n+k patterns rewrite like so: f (n+1) = g n ~> f n = g (n-1) ?
21:56:02 <dons> haddock doesn't parse  n+k
21:56:13 <skew> dons: I think they might pick up a guard too
21:56:16 <Gahhh> lol
21:56:37 <dons> skew?
21:56:40 <SamB> I would expect that they would involve lets in the general case...
21:57:08 <dons> oh sure. but is the above sound?
21:57:22 <dons> I never program in them, so I hate to break a piece of code I don't understand..
21:58:16 <skew> dons: your translation doesn't quite work
21:59:15 <skew> let f (n+5) = n ; f 0 = 12 in (f 0, f 6, f 2) => (12,1,*** Exception: <interactive>:1: Non-exhaustive patterns in function f
21:59:24 <SamB> does @vixen, <question> work because of the spelling-correction code?
21:59:53 <dons> hmm. ok.
22:00:07 <skew> I think f (n+k) = BODY => f x | x >= k = let n = x-k in BODY
22:00:14 <skew> but I haven't quite found that in the report
22:00:26 <skew> which is by the way the source of answers to questions like yours
22:00:36 <SamB> @google "n+k" site:haskell.org report
22:00:37 <lambdabot> http://haskell.org/pipermail/ffi/2004-January/001716.html
22:02:03 <dons> yeah, I know. I was just wondering if someone knew of the top of their heads ;)
22:02:21 <skew> usually anyway. I'm still looking
22:02:38 * dons trawls through S3.17 Pattern matching.
22:03:04 <skew> http://www.haskell.org/onlinereport/exps.html#case-semantics
22:03:18 <skew> 	case v of { x+k -> e; _ -> e' }
22:03:22 <skew>  = if v >= k then (\x -> e) (v-k) else e'
22:03:39 <dons> yep. got it.
22:03:49 <dons> bottom of page 29
22:04:29 <skew> If you do add n
22:04:50 <skew> support for n+k patterns you should also make your program print a warning admonishing the module author to remove them :)
22:04:57 <SamB> dons: yours has pages?
22:05:19 <SamB> do you have it, like, *on paper*?
22:05:45 <skew> firefox grepps better than gv, and much better than paper.
22:06:00 <dons> around here somewhere, but I'm reading the postscript
22:06:22 <dons> I'll add a big silly DEPRECATED warning on an id function with a good msg
22:07:29 <Gahhh> I still print out pdf files because shapr is too lazy to code Fermat's Last Margin ;)
22:07:51 <SamB> what is Farmat's Last Margin?
22:08:06 <KrispyKringle> 10em
22:08:26 <SamB> KrispyKringle: I didn't ask how wide it was, I asked what it was.
22:08:39 <KrispyKringle> i can't believe i'm making typography jokes, now.
22:08:42 <KrispyKringle> i need sleep.
22:08:57 <Gahhh> I didnt get the joke anyways
22:09:02 <KrispyKringle> figured
22:09:15 <skew> That was a joke?
22:09:19 <KrispyKringle> an em is a unit of distance in typographical layout, apparently. at least, it is in the CSS spec...
22:09:21 <skew> I wondered if you knew the actual figure
22:09:33 <KrispyKringle> heh
22:09:34 <Gahhh> It's a program shapr was talking about writing. It lets multiple people annotate documents, etc.
22:10:08 <KrispyKringle> ah, neat
22:10:26 <Gahhh> I wonder if a patent's been filed on that technology...
22:10:47 <machack666> fermat (a famous mathematician) had a statement where he wrote in the margin "I have a beautiful proof of this statement, but the margin is too small to contain it"
22:10:53 <machack666> people have tried to figure out what that proof would have been, as he died before he ever revealed it
22:11:22 <skew> But then Wiles figured it out.
22:11:36 <Gahhh> the last theorem business. They now dont think he could have possibly fit that proof in a margin ;)
22:11:40 <blackdog> wiles had a very  large margin
22:11:49 <machack666> I believe the theorem was that no integer solutions of the form x^p + y^p = z^p, where x, y, z are integers and p is prime exist where p > 2.
22:12:07 <skew> Gahhh: that's what Fermat said, wasn't it
22:12:19 <blackdog> does anything actually depend on FLT, or is it just a cute result?
22:12:38 <Gahhh> Of all things that he could have written there, he somehow chose the most annoying he could possible have heh
22:12:48 <skew> blackdog: the way Wiles proved it tells you all kinds of deep stuff
22:12:54 <machack666> pure mathematics, I believe, but so is public key cryptography (derived from algebraic group theory)
22:13:16 <machack666> ;)
22:13:36 <skew> blackdog: I suppose it's better to say that Wiles proved it by proving a conjecture that identifies two apparently unrelated sorts of mathematics, of which Fermat's Last Thereorem is just one consequence
22:13:38 <Gahhh> pretty much every mathematical discovery is cute.
22:14:09 <skew> I don't know if there's anything explicitly depending on it, to the extend of the Riemann Zeta Hypotheses, for example
22:15:14 <Gahhh> what blows my mind is that there is a show named NUMB3RS on CBS and it's a half decent show.
22:15:44 <skew> apparently some people in the math department here at Caltech are helping out
22:15:54 <Gahhh> are you at caltech ?
22:16:10 <Gahhh> ugh
22:16:20 <Gahhh> wtf is page-148 lol
22:16:33 <Lemmih> Hey Ninja.
22:16:53 <skew> I believe they work in the capacity of 1) making sure the math is reasonable, and 2) being able to write on the blackboard really fast for those shots of math-guy writing, because the actor can't.
22:17:30 <Gahhh> wow. equation editing stunt doubles.
22:17:38 <skew> I hear he is practicing
22:17:40 <SyntaxNinja> hi
22:17:44 <skew> like martial arts training for other shows :)
22:20:48 <a5> caltech does all sorts of movie stuff because of the location
22:21:28 <skew> Has anybody seen my earlier question, or do you all have auto-ignore filters keyed on the work J.4 V.A ?
22:21:31 <Gahhh> Isnt USC closer ;)
22:21:36 <skew> Caltech is pretty
22:21:50 <a5> did anyone read Hughes' paper on typed partial evaluation
22:21:52 <Gahhh> My Java is rusty
22:22:37 <a5> skew: what question?
22:22:47 <skew> a5: back a few pages.
22:22:57 <a5> skew: humor me
22:23:19 <a5> there should be a theory of typed functional program runtime self-modification
22:23:24 <skew> I grabbed this program that's split between code in src/ living in the unnamed package, and code in src/r/, living in "package r;"
22:24:10 <musasabi> Can haskell xml toolbox be called using the DOM model?
22:24:45 <musasabi> and should I use it or the HaXML packaged with GHC 6.4 ?
22:24:49 <skew> The files in src/r/ all try to "import AardappelRuntime", where AardappelRuntime was defined in src/. I get a syntax error on the import, but this program came with class files!
22:25:27 <skew> it's missing some RMI stub classes that I need to clear this up to generate, though, and some functionality is broken
22:26:21 <skew> a5: I think there is some kind of interpretation in terms of infinite stacks of interpreters
22:26:48 <skew> I don't know how well that works out with typing.
22:27:59 <skew> turning different values in the same Expr type into actual values of different types seems to require dependent types
22:36:29 <wilx> lol, I watch that Numb3rs show :D
22:36:39 <wilx> This is really interesting to hear :D
22:48:31 <autrijus> so, hs-plugins has the same dep as TH as ghci right?
22:48:36 <autrijus> namely dyloading of modules
22:49:25 <dons> same dep?
23:02:53 * Lemmih ponders how hard it would be to hack fast STM arrays.
23:06:56 <KrispyKringle> OK, so I'm having some difficulty with matching my types while using Dbconnect from WASH.
23:07:31 <KrispyKringle> So as an xample, I have something with a case statement that retrieves a Maybe node from the database, and does...
23:07:45 <KrispyKringle> Nothing -> addNewNode (an INSERT statement)
23:07:51 <KrispyKringle> Just x -> updateNode (an UPDATE statement)
23:08:07 <KrispyKringle> the problem appears to be that INSERT queries return a different IO type than UPDATE.
23:08:12 <KrispyKringle> So the case doesn't match...
23:08:35 <Lemmih> Prepend '>> return ()'?
23:08:59 <Lemmih> @type getLine >> return ()
23:09:01 <lambdabot> getLine >> return () :: IO ()
23:09:16 <KrispyKringle> ah, yeah
23:09:18 <KrispyKringle> that makes sense
23:09:22 <KrispyKringle> im sleepy :-/
23:09:25 <KrispyKringle> thanks, thouh
23:09:45 <Lemmih> No problem (:
23:09:49 <Gahhh> is there a unix program that runs a process for a given amount of time and then shuts it down ?
23:10:08 <blackdog> don't think so, but you can homebrew it with rlimit
23:11:17 <KrispyKringle>    Couldn't match `IO' against `[]'
23:11:17 <KrispyKringle>         Expected type: IO t
23:11:17 <KrispyKringle>         Inferred type: [()]
23:11:19 <KrispyKringle> wtf?
23:11:26 <KrispyKringle> oi
23:13:00 <blackdog> ...ok, that's really weird. My boss is importing something called "Chronic Candy".
23:13:05 <blackdog> It tastes like pot.
23:13:13 <KrispyKringle> hmm. anything obviously wrong here? http://rafb.net/paste/results/ahrIhO89.html
23:13:18 <blackdog> Does this strike anyone else as unutterably weird?
23:13:20 <KrispyKringle> blackdog: that IS weird! Where do you work?
23:13:25 <Gahhh> blackdog: neat,
23:13:48 <blackdog> A hosting/tech-support/random stuff company in Oz. infinet, it's called.
23:14:02 <KrispyKringle> cause I get this error: http://rafb.net/paste/results/qCPUrW22.html
23:14:17 <blackdog> Gahhh: it's less neat than you'd think...
23:14:46 <KrispyKringle> i can't figure out where the inferred [()] is coming from. Theres no list.
23:15:11 <Lemmih> KrispyKringle: What's the type of 'addNewNode'?
23:16:12 <KrispyKringle> ah, yeah, that might be a bit of a problem... :P
23:16:23 <Gahhh> blackdog: what does your company do ?
23:16:42 <dons> "hosting/tech-support/random stuff" it seems
23:16:50 <mwc> Did they ever replace the haskell.org webserver with hsweb?
23:16:56 <dons> ++ "irc vixens"
23:17:06 <mwc> hello dons
23:17:50 <blackdog> Gahhh: I've got cards saying that my position is "Senior Developer", which, given that I'm the only programmer in the building, strikes me as accurate but a little disingenuous.
23:17:58 <mwc> thanks for fixing the haskell plugins on Mac OS X
23:17:59 <dons> hehe
23:18:03 <dons> oh, I did?
23:18:09 <dons> mwc: when was that?
23:18:10 <Gahhh> blackdog: then you are the CTO as well. congrats.
23:18:10 <blackdog> he did?
23:18:16 <KrispyKringle> Lemmih: it's an IO ()
23:18:22 <mwc> dons, I don't know, 0.9.8 failed miserably
23:18:32 <mwc> 20050414 worked right out of the box
23:18:44 <blackdog> Gahhh: nah, i'm outranked by a network guy, an NT admin, and the business manager. outrageous, i call it.
23:18:44 <dons> oh. ok. but was that 6.4? I thought 6.2.2/0.9.8 always worked on the mac
23:18:54 <KrispyKringle> ah, updateNode is a problem
23:18:54 <dons> it worked for me, anyway.
23:19:07 <dons> mwc: more info: what compilers where used?
23:19:20 <mwc> dons, 6.4, GCC-3.3
23:19:43 <KrispyKringle> you all are my heros.
23:19:47 <KrispyKringle> thanks, Lemmih :)
23:20:08 <dons> mwc, is that with 0.9.8 and the latest snapshot?
23:21:29 <mwc> dons, yeah, 0.9.8 fails, 20050414 worked well
23:22:52 <mwc> dons, now you just need to fix yi ;)
23:22:54 <mwc> config.status: error: cannot find input file: mk/config.h.in
23:23:48 <dons> autoreconf!
23:23:54 <mwc> looks liek that file isn't being pulled
23:23:54 <shapr> @vixen
23:23:55 <mwc> Oh!
23:23:55 <lambdabot> i find it hard to masturbate when the lights are on.
23:23:56 <mwc> Hahaha
23:24:12 <mwc> I assumed an autoconf run would have fixed it all up
23:24:35 <KrispyKringle> wow :P
23:32:14 <blackdog> shapr: ah, you've hit the degenerate case. if she can't match something you say, she just says something totally random.
23:32:28 <sjanssen> (highly offtopic) woo!  I just uncovered my very first GCC bug
23:32:35 <mwc> sjanssen, wow
23:32:38 <mwc> What version?
23:32:39 <blackdog> There are a few buried in there, very unlikely, which are ... odd.
23:33:25 <sjanssen> mwc: well, g++ to be exact, 3.3.2 and 3.3.5 both seem to be effected (affected?)
23:33:42 <shapr> definitely degenerate ;-)
23:33:42 <mwc> Ah
23:33:52 <mwc> sjanssen, see if it's in 3.4 or 4.0?
23:34:22 <blackdog> there are actually a few cases in there which come out with something from postmodern crit, or something that suggests she's a 40yo balding male...
23:34:47 * shapr grins
23:35:03 <mwc> @foobar
23:35:16 <blackdog> the regexes + responses are a work of art. i really do take my hat off to those guys. they can't code for peanuts, but they had an acute insight into the psyche of your average horny AOLer
23:35:26 * shapr snickers
23:35:27 <sjanssen> mwc: if you have either installed: http://cse.unl.edu/~sjanssen/gpp_bug.cpp
23:36:24 <mwc> I didn't think that typename was required there
23:37:59 <shapr> Amazing, #haskell had more than a third as much traffic as #debian yesterday. We really *do* talk too much.
23:38:13 <sjanssen> mwc: I'm new to the templates, but gcc complains about "implicit typename" being deprecated if it's omitted
23:38:21 <mwc> shapr, hmm
23:38:25 <sjanssen> mwc: does g++ segfault when compiling that?
23:39:05 <blackdog> it's a more social channel than most, i think... you don't get slapped down for the occasional outbreak of silliness, unless it's all you ever do.
23:39:36 <blackdog> which is lucky, because i have difficulty remaining sensible.
23:40:05 <mwc> sjanssen, nope
23:42:41 <Gahhh> blackdog: there are channels that are almost never on topic. ##c++ for instance.
23:43:31 <segphault> probably because no sane individual would *want* to talk about c++. ;-)
23:43:58 <Gahhh> It's not the sane individuals who want to talk. It's the "needy, desperate" individuals with real problems ;)
23:45:16 <mwc> Gahhh, hahah, you think they're bad, drop in on #physics some time
23:45:22 <musasabi> argh @ java & dom, I hate it more each passing minute.
23:45:25 <mwc> It's like a seedy saloon
23:45:43 <Gahhh> mwc: really ? #math is pretty good, though.
23:46:15 <mwc> Gahhh, yeah. At #physics we're a smaller group so we tend to be on task when a question is asked but otherwise it's a lot of banter
23:50:33 <mwc> Gahhh, on a lighter note, it's probably because of the different mind sets. Mathematicians by temperment build and create things, physicists were the kids who disassembled or smashed open everything in sight to see how it worked and then moved on
23:51:33 <mwc> If science was a trailer park, the physicists would live in the trailer with a dozen scrap cars piled around and a bunch of kids running around blowing random things up with fire crackers.
23:51:53 <Gahhh> Umm, no. Mathematicians would have joined the channel, thus demonstrate that it's possible to join and chat, and then they would leave...
23:52:00 <mwc> Gahhh, hahaha
23:52:03 <mwc> is that it?
23:52:15 <mwc> I think it's because physicists are rednecks by temperment
23:52:59 <Gahhh> I met a few phycisists and they were working as programmers, so it's hard to say.
23:53:58 <KrispyKringle> My brother in law is a physicist. He's insane.
23:54:08 <KrispyKringle> I don't mean to imply that the two necessarily go together, but...
23:54:13 <mwc> true. Discoveries in physics tend to occur because we figured out how to "break" the existing model. So physicists run around trying thing on the edge of the current theory and that's how things move forward
23:54:21 <mwc> mathematicians build on what came before them
23:54:32 <mwc> KrispyKringle, as a physics major, I'd say you're spot on
23:54:58 <KrispyKringle> mwc: is that true? I would think that trying to break things leads to finding holes in existing theories, for instance, but not the formation of new theories. Theoretical physics would seem to me to be as creative as math.
23:55:05 <KrispyKringle> Though that's, I guess, not all physics?
23:55:07 <mwc> KrispyKringle, no, it's very important
23:55:23 <mwc> Classical EM was totally inept at dealing with things like the ultraviolet catastrophe
23:55:23 <KrispyKringle> I'm speaking from ignorance here. I was just surmising.
23:55:26 <mwc> so we went and did that
23:55:39 <mwc> and figured out quantum mech
23:56:00 <KrispyKringle> I'd have thought that that was still a creative act itself, though. That's all I was saying; that breaking goes together with creativity.
23:56:06 <Gahhh> engineers disassemble things until they no longer function as well.
23:56:19 <tuomov> my experiences with physics students is that they're very arrogant..
23:56:28 <mwc> Netownian mechanics couldn't explain some problems relating to light speed, so SR was posited
23:56:31 <mwc> KrispyKringle, yeah
23:56:31 <KrispyKringle> No, that would be business students.
23:56:47 <Gahhh> I think you can be arrogant in any major.
23:56:47 <mwc> but physics you have to be prepared to destroy recklessly to create
23:56:53 <mwc> Gahhh, I totally agree
23:56:54 <KrispyKringle> "When I grow up, maybe you can work for me."
23:57:13 <mwc> I'm specializing in theoretical physics, and we're a pretty elitist crowd, it's all in good fun though
23:57:32 <mwc> we're not really bastards about it but certainly there's some pretentiousness just as a sort of group bonding dynamic
23:57:38 <tuomov> KrispyKringle: In universities of technology in Finland almost everyone thinks like that... as it used to be so
23:57:39 <Gahhh> lol
23:57:50 <tuomov> not anymore with highly increased enrollment
23:57:55 <Gahhh> "yay we're elite, let's hold hands yay"
23:58:15 <KrispyKringle> mwc: probably that way everywhere. All us engineering students think we're smarter than those in the college ;)
23:58:24 <KrispyKringle> College of Arts and Crafts, as it were.
23:58:32 <mwc> heh
23:59:16 <Gahhh> There are a ton of smart people in every field.
