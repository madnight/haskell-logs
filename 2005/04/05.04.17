00:00:38 <lispy> i want to look at how you can simulate or compile the same code (or at least that's how i understand their system)
00:13:10 <dons> maybe you should google for papers on EDSLs and Haskell
00:13:42 <lispy> i've found a few papers about it, i was hoping to look at the source.  But that's still a good idea
00:14:24 <pediddle> Carl Ebeling of the University of Washington I believe is working on something like that
00:14:35 <pediddle> if you're looking for google fodder
00:14:57 <dons> I think it would be fairly easy to write a Haskell program that compiles to a binary, that when run prints your procmail recipe
00:15:38 <lispy> dons: right, and i was also hoping to be able to simulate the recipe interactively.
00:15:52 <lispy> but in some sense, that's just icing on the cake :)
00:17:52 <lispy> i wonder if the lava folks just have the code setup so that it always compiles to a lower level format and then they just know how to simulate that
00:18:01 <lispy> i bet i could figure out a way to do that
00:28:50 <shapr> According to the docs, one advantage of Lava is that it doesn't use VHDL(?) as an intermediate language. That means it can pack a lot more elements into the same space.
00:29:45 <lispy> hmm..
00:30:01 <lispy> i should read up on this more then
00:31:21 <shapr> Anyway, the reason you're having trouble tracking down Lava info is that Xilinx pulled everything.
00:31:31 <shapr> Well, most stuff.
00:31:59 <lispy> their site isn't very easy to navigate so i didn't spend much time there :)
00:32:08 <lispy> that's too bad tho
00:32:23 <shapr> There were two versions, the Xilinx version and the Chalmers version. The Xilinx version of Lava was designed to compile to their FPGAs, you can probably find more info by googling for Satnam Singh.
00:33:03 <lispy> thanks
00:33:40 <shapr> The Chalmers version had two goals, teaching and verification. It did dataflow-style circuit simulation, (see Lucid, Esterel, and other dataflow languages) and it had some integration with QuickCheck.
00:35:22 <shapr> Satnam Singh went from Xilinx to Microsift. Last I swapped emails with him he said he was working on a new version of Lava that would be really free. I dunno exacatly what that means though.
00:35:46 <shapr> You can find out more of the history by looking up Hawk and other hardware simulation programs in Haskell.
00:36:46 <lispy> thanks, you're full of all kinds of good info :)
00:37:02 <blackdog> i think you'll find he's full of caramel.
00:37:11 <shapr> If you have a particular goal in mind, I can probably point you to more useful info.
00:38:09 <shapr> g'day blackdog
00:38:20 <lispy> my goal is to write an edsl for rule based email filtering that can be tested interactively (say using ghci) and compiled to some email filtering system like procmail
00:38:49 <lispy> lava is in some sense, completely unrealted :)
00:38:54 <shapr> What sort of rules do you want?
00:39:16 <lispy> in the beginning i want it to be simple
00:39:25 <blackdog> shapr: have you looked at HAppS at all?
00:39:32 <shapr> blackdog: yes.
00:39:40 <blackdog> thoughts?
00:39:44 <lispy> probably have a small bit of control flow and pattern matching
00:39:45 <shapr> needs monads.
00:40:17 <blackdog> *grin* i can see you dipping a finger in the pot and crinkling an eyebrow before saying that.
00:40:23 * shapr grins
00:41:14 <shapr> I wrote a mailing list search webapp in Haskell, so I have some ideas on how it would work. I'm not sure about the EDSL part.
00:41:24 <shapr> What would it look like?
00:42:45 <lispy> shapr: i'm just starting to work on it, so i haven't made an examples, yet
00:43:00 <blackdog> Which EDSL? I tend to think that the zope guys were onto something with the html-compatible templates - realistically, this stuff needs to look pretty, and you can't get people to design in your format
00:43:01 <shapr> You could do something like emacs' nnmail-split-methods, that would be nifty.
00:43:35 <lispy> i've heard of those...
00:43:46 <blackdog> oh, wait. you were talking to lispy. :)
00:44:00 <shapr> blackdog: sorry, I'm not focussed yet.
00:44:06 <lispy> shapr: like this? http://www.gnus.org/manual/gnus_169.html
00:44:10 <blackdog> no wuckas.
00:44:31 <shapr> lispy: yes
00:45:02 <lispy> yeah, that doesn't look too bad
00:45:08 <blackdog> shapr: i want to talk to you about some backend stuff at some point, so let me know when you're firing on all cylinders.
00:45:11 <shapr> blackdog: I surely like the html-compatible templates.
00:45:43 <blackdog> so as far as i can see, we've got these components;
00:45:57 <shapr> lispy: but I would suggest a real DSL that you would be happy to 'teach to your mother', ya know?
00:46:09 <blackdog> web template system (ZPT, Halipeta, whatever)
00:46:49 <lispy> shapr: agreed :)
00:46:59 <blackdog> haskell web server
00:47:04 <blackdog> storage backend
00:47:31 <blackdog> and some kind of dynamicity (hs-plugins or whatever) in the webserver
00:47:52 <blackdog> have i missed anything? you'd want ACID, of course, but that goes without saying
00:48:57 <blackdog> i don't think that zope is fundamentally that complex - it's all the supporting code...
00:49:45 <blackdog> i haven't managed to find poetix on line to grill him yet. :)
00:51:34 <lispy> heh, i just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
00:53:10 <lispy> shapr: if this project goes well it could even turn in to research.  my school likes to do end-user software engineering, and email filtering is one of the areas they have thought about looking into
00:53:35 <lispy> currently the focus is on spread sheets
00:55:12 <dons> @remember lispy i just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
00:55:23 <dons> @quote lispy
00:55:24 <lambdabot>   i just remembered this dream i had the other morning.  I was trying to
00:55:24 <lambdabot> tell my alarm clock how to snooze by using a list comprehension
00:56:10 <blackdog> dons: how wide does lambdabot choose to print? it always seems to overflow the width of my screen by a word...
00:56:23 <dons> i know the feeling. when I was working on my 4th year thesis, i used to have dreams where I solved day to day problems with tail calls
00:56:36 <dons> blackdog, hmm. i'll look at it.
00:57:00 <lispy> dons: heh
00:57:39 <blackdog> the worst is when you can't get the code quite right. debuggers in dreams are even worse than in real life.
00:57:49 <lispy> true dat
00:59:48 <shapr> blackdog: control flow abstractions, Plone has workflow and FormController.
01:00:15 <shapr> Archetypes are a lot like ADTs with deriving WebPublish
01:01:15 <blackdog> I think i understand archetypes (to that level, at least). what's the deal with workflow and formcontroller? I don't really understand them
01:01:53 <shapr> There's also validation that works in form inputs, archetypes, etc (isURL, isSSN, etc)
01:04:02 <shapr> I haven't used workflow enough to give lotsa details, but it is a control flow abstraction
01:04:04 <blackdog> These are all fairly high-level things, though, right?
01:04:17 <blackdog> do they need thought before the base package is done?
01:04:19 <musasabi> morning
01:04:19 <shapr> You define states, transitions, variables, hooks, etc.
01:04:24 <shapr> g'mornin musasabi
01:04:40 <shapr> I think they do.
01:05:00 <musasabi> I had some dreams about parsers..
01:05:09 <shapr> Because the base package as it is now (Zope/Plone) has quite a bit of duplication.
01:06:24 <musasabi> From the grammar description one could generate both constructor and deconstructor functions for messages. If the parsing would be lazy then validity checks can be done in a compose-function wrapper.
01:07:33 <musasabi> shapr: This means that your "EBNF -> haskell parser (and writer functions)" idea should work.
01:07:36 <shapr> blackdog: but I'm just trying to track down the basic abstractions in Zope to see if I'm right or not.
01:07:46 <shapr> ah, spiffy!
01:08:45 <musasabi> Now only to understand whether it can be done with monads or are arrows needed.
01:09:10 <shapr> blackdog: Got any thoughts to support the "write the base package, YAGNI"?
01:10:25 <blackdog> shapr: ok, fair enough.
01:11:05 <blackdog> I'm still trying to work it out. loadable plugins is just about the only non-negotiable thing, i think.
01:11:18 <shapr> It's also possible that the easiest way to find the abstractions is just to write something simple and see what could be refactored out of it.
01:11:42 <shapr> I've seen some OOPSLA papers about refactoring to frameworks.
01:12:30 <blackdog> Yeah, there's that.  I'm still thinking about the idea of continuations - something Phil Wadler pointed out about the Orbitz site was that if you open a window, then another, then click submit in the first one, it uses the info from the second one, so you end up with the wrong flight.
01:12:40 <musasabi> refactoring brings out a clean interface eventually, but often work can be saved if one spends some moments on design beforehand.
01:13:20 <blackdog> shapr: also, we have this massive case study in Zope :)
01:14:42 <musasabi> Has anyonebody a "working non-escape continuations in haskell without explicit transformations" ?
01:15:35 <shapr> Yeah, I've been bugging the zope3 guys off and on to see what secrets they'll share.
01:26:53 <shapr> But really here's what I've got: control flow, persistence, transactions, typeclasses (and some sort of 'autocasting'), authorization, validation, versioning?, views, ADTs, I think that's it.
01:27:16 <shapr> Maybe I should start a wikipage to see if others can cut down some of those down to the bare essence.
01:27:41 <musasabi> managing authorization with capabilities would be nice.
01:28:04 <musasabi> but it might be hard to explain.
01:29:02 <shapr> I think someone who wants to use a Haskell webframework would be happy to learn about capabilities.
01:30:48 <shapr> There's a sliding scale of "willing to put in work ahead of time" from PHP on up to continuation based frameworks. I think everybody knows that investment of learning time gives you faster production of real work in the long run, but most people just learn the minimum they can to keep from getting fired.
01:31:06 <shapr> (or maybe I have post corporate stress syndrome ;-)
01:31:49 <shapr> In any case, I prefer the top end of the "learn much now, produce even more later" scale.
01:32:41 <shapr> musasabi: What do you think? Have you tried to explain capabilities to other programmers around you?
01:32:48 <musasabi> true, but for making a project popular the basic things need to be quite easy to explain.
01:33:43 <musasabi> shapr: understanding how capabilities work is easy, understanding why capabilities work very well is much harder.
01:34:27 <musasabi> Currently most web apps seem to have quite ad hoc authentication systems.
01:35:40 <shapr> Yeah, Zope's permissions are a real pain in the butt.
01:36:38 <shapr> Mostly because you have to integrate them with the workflow to get decent predictable behaviour.
01:36:50 <shapr> Oh, one abstraction I totally forgot to mention, i18n !
01:37:17 <shapr> I've thought about i18n a bunch, and I still don't have any great ideas.
01:39:47 <musasabi> Using templates helps to a part of the problem, but entirely.
01:39:53 <shapr> Best I've seen is LinguaPlone's two flavors of i18n. For the first flavor, navigation strings are kept in gnu gettext foo-{en,fi,sv}.po files. For the secand, documents are objects with collections of fields, when you translate a document it creates a new object that mirrors the original and lets you translate the fields while looking at the original values.
01:41:58 <blackdog> shapr: good idea - wanna set up the page?
01:44:01 <blackdog> shapr: autocasting?
01:44:17 <shapr> Intefaces/Adapters
01:44:46 <shapr> Python's honor system turned into ___implements___ = IThingy
01:45:02 <blackdog> Ok.
01:45:35 <shapr> You can give an object to an adapter and ask for an output interface, the adapter will try to convert it.
01:46:17 <shapr> implements is a lot like typeclasses, but I don't know if Haskell has anything to find a way to cast from what you have to the Y type you want.
01:46:20 <blackdog> sounds a little ad-hoc
01:46:41 <blackdog> what's wrong with just using typeclasses?
01:46:49 <shapr> Maybe nothing.
01:47:25 <shapr> I haven't used adapters enough to say.
01:47:51 <shapr> A bunch of Pythonistas like them, but I don't know any Pythonistas who like adapters and have used typeclasses.
01:48:33 <blackdog> yeah. it sounds to me like some dynamicists looking for some structure. i think the hard bit for us is more likely to be the dynamic side
01:51:55 <shapr> I'm not sure. I see what may be the same pattern in pugs. Autrijus uses some typeclasses to do autocasting to satisfy type signatures.
01:54:04 <ozone> autocasting?
01:54:11 <shapr> I think the simplest approach would be "deriving WebPublish", along the lines of Steve van Hoyweghen's thesis.http://home.tiscali.be/stevevh/
01:54:12 * ozone scrolls back
01:54:29 <musasabi> Creating reusable UI components would be nice.
01:54:46 <musasabi> But looking at other web-frameworks that is usually kind of hard.
01:56:09 <shapr> At the moment, I see two major 'flavors' of webdesign, the rolodex-style database i/o flavor, and the tree shaped navigation flavor.
01:56:46 <shapr> If you could derive WebPublish on an ADT, you'd get the first flavor.
01:57:04 <ozone> shapr: i don't get what you mean by autocasting
01:57:06 <ozone> duck typing?
01:57:20 * shapr googles for duck typing
01:58:11 <shrimpx> heh pythonists and their silly terminology
01:58:15 <shapr> That was the original idea behind interfaces and adapters, yes.
01:59:17 <shapr> I always called that 'the honor system' in Python.
01:59:24 <musasabi> So that is basically a "class DuckType a b where duckType :: a -> b" ?
02:01:13 <ozone> musasabi: yep
02:01:23 <shapr> ozone: I don't think that covers the autocasting bit though.
02:01:27 <ozone> except that the language does it automatically
02:01:57 <ozone> i'd quite like to see that feature.  i wanted it the other day ...
02:02:26 <shapr> The autocasting stuff is more like fromIntegral, since you can put that into most any math op in Haskell to shim two misfits together.
02:03:52 <ozone> yeah, exactly
02:04:12 <ozone> i'm sure that suggestion will be shot down nicely
02:04:22 <ozone> since all the anti-syntactic-sugar folks will hate it
02:05:57 <blackdog> ozone: what were you trying to do?
02:09:21 <musasabi> Well one can do all kind of nifty things without syntactic sugar.
02:09:25 <musasabi> like varargs ;)
02:12:07 <ozone> blackdog: i was writing a Word8 combinator library for Parsec
02:12:15 <ozone> like Parsec.Char, but, well, for Word8 (binary data)
02:12:42 <ozone> and it's really tedious, because if you want to match, e.g. a series of bytes
02:12:44 <ozone> you can't just write
02:12:57 <ozone> oggSignature <- word8s "OggS"
02:13:08 <ozone> since [Char] != [Word8]
02:13:31 <ozone> so, you have to write something like "oggSignature <- word8s (fromString "OggS")" instead
02:13:44 <ozone> and then you don't know whether GHC's optimising that away properly, or whether it's doing the conversion at runtime, etc
02:13:55 <ozone> and it's generally a syntactic annoyance
02:14:06 <ozone> arguably the proper solution is to have a defaulting mechanism for Chars, similar to Nums
02:14:19 <ozone> but i'd still like it, it'd be quite useful in plenty of other situations
02:14:28 <blackdog> so you'd like to have Char be an instance of Word8?
02:14:38 <blackdog> uh, you know what i mean.
02:14:56 <shapr> You'd like to write an adapter, a shim.
02:15:04 <ozone> i'd like 'x' and "foo" to be Word8s, rather than Chars
02:15:17 <blackdog> (speaking of which, i got a new website: www.shimweasel.com)
02:15:41 <ozone> i think whenever folks on the mailing list actually get a clue about unicode, a defaulting mechanism for Chars will be very nice, if not necessary
02:16:19 <ozone> since then you'll need to specify what encoding/charset a character belongs to, unless the totally non-existent unicode support we have now
02:16:23 <ozone> anyway
02:16:32 <ozone> shapr: yeah, i've written an adapter.  it still sucks
02:17:33 <shapr> So, is there a better way?
02:17:51 <ozone> yeah, defaulting for chars :)
02:18:35 <blackdog> how does the defaulting work for Nums?
02:19:07 <shapr> What port is mms?
02:19:28 <shapr> like, can I grab an mms:// url with wget to a certain port?
02:19:48 <ozone> blackdog: see http://www.haskell.org/onlinereport/decls.html#default-decls
02:19:59 <ozone> shapr: no, it's a different protocol, not http
02:20:02 <ozone> thus the mms:// prefix :}
02:20:16 <shapr> Suck, I want to hear these mp3s.
02:20:22 <ozone> blackdog: but basically, you put a line in your module 'default (Double)' or whatever
02:20:28 <ozone> shapr: there are some mms leechers around
02:20:32 <ozone> freshmeat should have them
02:20:40 <ozone> and mplayer can do it too, i think.  mplayer -dump or something
02:20:41 <shapr> Ah, good idea.
02:21:39 <ozone> i wonder if defaulting is necessary if there's no monomorphism restriction, hmm
02:24:23 <blackdog> ozone: ok, i see.
02:25:06 <blackdog> it seems like an odd special-purpose hack... why was it only done for Nums?
02:25:53 <shapr> Because newbies couldn't do math in GHCi?
02:26:52 <blackdog> ok, but why not make it general purpose?
02:27:06 * shapr laughs at mplayer's message - "everything done. Thank you for downloading a media file containing proprietary and patentend technology."
02:28:46 <blackdog> something like 'default (Num: [Double, Int], Char: [Word8])' would work, wouldn't it?
02:33:42 <Singlot24> Hello
02:33:50 <shapr> hiya singlot24
02:34:02 <shapr> How's code?
02:34:24 <Singlot24> :)
02:34:41 <Singlot24> yesterday i was using haskell to draw a turtle
02:34:46 <Singlot24> jeeje... and then
02:34:59 <Singlot24> the fucking error arrives
02:35:00 <Singlot24> XD
02:36:02 <Singlot24> It says that i have to define an instance of Integer floatable
02:36:16 <Singlot24> but i only have a cosinus :P
02:36:25 <Singlot24> shit!
02:36:30 <boegel> Singlot24: there's no such thing as a Fucking error, there is no Fucking monad
02:36:55 <Singlot24> you are true :)
02:37:00 * shapr has always wondered about typesignatures like m f a
02:37:33 <Singlot24> i have been working with haskell a few time ago
02:37:36 <Singlot24> and i like it :)
02:37:41 <shapr> me too!
02:37:57 * boegel joins
02:39:15 <Singlot24> but i'm so confused with type errors i haven't called
02:42:03 <shapr> hoi boegel
02:42:05 <Singlot24> what means this error : Instance of Integral Float required for definition of ....
02:42:37 <Singlot24> i only use sin and cos
02:42:45 <Singlot24> and i have defined the types like Float
02:43:36 <Singlot24> anybody can give me a little explaination please???
02:43:39 <Singlot24> thanks in advance!
02:44:14 <boegel> hey shapr
02:44:32 <Singlot24> you can redirect me to a web if you want...
02:44:32 <boegel> Singlot24: we really should see some of your code
02:44:39 <Singlot24> ok
02:44:46 <boegel> but don't paste it here :)
02:44:49 <boegel> @paste
02:44:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:44:56 <boegel> paste it on the wiki above
02:44:57 <Singlot24> its so simple
02:45:02 <boegel> how many lines ?
02:45:29 <Singlot24> 5
02:45:44 <boegel> hmm
02:45:50 <boegel> you should paste it then :)
02:45:58 <boegel> on the wiki I mean :)
02:46:29 <Singlot24> ok... i go to see how :P
02:48:20 <Singlot24> can i paste something if i'm not registered?
02:49:45 <boegel> yeah, sure
02:49:51 <boegel> you can edit the wiki
02:50:02 <Singlot24> ah ok
02:50:08 <Singlot24> edit yes but put new?
02:50:11 <boegel> click the text balloon on the upper right
02:50:39 <boegel> Singlot24: click edit and just add your stuff on the top, with similar syntax as the rest
02:50:41 <Singlot24> ah ok
02:50:42 <Singlot24> i see
02:50:43 <Singlot24> XD
02:50:44 <Singlot24> sorry
02:50:47 <Singlot24> i'm dummy :P
02:54:09 <Singlot24> ok
02:54:11 <Singlot24> there is
02:54:15 <Singlot24> the first called Krion
02:54:15 <Singlot24> xD
02:54:26 <Singlot24> boegel :D
02:55:00 <Singlot24> i added some types to verify
02:56:35 <Lemmih> What's a 'Color'?
02:57:47 <Lemmih> Works fine when Color = Float.
02:57:50 <Singlot24> a Color is type Color from libraries "import GraphicsUtils"
02:57:58 <Singlot24> yes?
02:58:41 <Singlot24> my teacher said me that Color is defined in GraphicsUtils
02:58:46 <Lemmih> GraphicsUtils isn't in the standard libraries.
02:58:52 <Singlot24> you are right
03:00:17 <Singlot24> ok... thank's a lot Lemmih
03:00:32 <Singlot24> i'll keep on searching... about what's wrong with this type Color
03:00:47 <Lemmih> Singlot24: You can try loading GraphicsUtils in an interpreter and type ':i Color'.
03:01:51 <Singlot24> mmm... thanks... i'm really pleased with your help
03:02:33 * TFK chuckles
03:02:49 <Singlot24> Color is a constructor
03:04:52 <Singlot24> it i change the Color for Float it gives me the same error
03:05:09 <Lemmih> Singlot24: What does the first line of ":i Color' say?
03:05:16 <Singlot24> DAta Color
03:05:56 <Singlot24> it have Black :: Color
03:06:04 <Singlot24> Blue :: Color ...
03:06:14 <Singlot24> and then the instances
03:07:03 <Singlot24> Ord, Eq, Bounded, Enum, Ix, Show and Read
03:07:16 <Lemmih> The code you pasted is valid for any implementation of Color.
03:07:29 <Singlot24> yes
03:07:34 <Singlot24> because i don't use collor
03:07:38 <Singlot24> color in this code
03:08:46 <Singlot24> if i change color for float i crushes
03:09:03 <Ioons> nas
03:09:11 <Singlot24> nas
03:09:32 <Singlot24> i think the error is from sin or cos
03:09:54 <Lemmih> Singlot24: Are you sure the code you paste is the code in fault?
03:10:24 <Singlot24> yes
03:10:54 <Lemmih> It works fine for me in both Hugs and GHCi.
03:11:01 <Singlot24> :***
03:11:19 <Singlot24> mmm...
03:11:23 <Ioons> but what librari of graphics you have ?
03:11:35 <Singlot24> GraphicsUtils
03:11:46 <Ioons> in windows ?
03:11:52 <Singlot24> http://ima.udg.es/Docencia/04-05/3105200736/GraphicsLib.msi
03:11:54 <Singlot24> yes
03:12:01 <Singlot24> ihave to do it in windows
03:12:11 <Ioons> are you sure you have in memory all modules of library ?
03:12:25 <Singlot24> yes
03:12:37 <Ioons> Lenninh: you have the same library ?
03:12:42 <Singlot24> i load all modules befor execute
03:12:53 <Lemmih> Ioons: I don't use Windows.
03:13:02 <Singlot24> fucking windows :P
03:13:09 <Ioons> jejejeje
03:13:20 <Ioons> but the library are the same
03:13:36 <Ioons> or are different
03:13:45 <Lemmih> I don't follow.
03:14:01 <Singlot24> i think he don't use this library... but it is not important
03:14:18 <Singlot24> well... i shut up... i'm not a crack
03:14:19 <Ioons> you say that the function of singlot24 run fine in your computer, no ?
03:15:10 <Lemmih> Ioons: His code isn't using anything from the library except Color.
03:15:58 <Lemmih> Singlot24: You're using Hugs, right?
03:16:00 <Singlot24> yes... Lemmih is wright
03:16:25 <Singlot24> i'm using
03:16:30 <Singlot24> winHugs ( haskell98 mode )
03:16:42 <Singlot24> but if i use hugs mode it give me the same error
03:17:04 <ozone> blackdog: yeah, i also think the defaulting mechanism is a bit ... weird
03:17:21 <ozone> it seems like an ad-hoc decision, compared to the rest of the language
03:17:23 <Lemmih> Would you mind pasting all the output from Hugs when you get the error?
03:17:39 <ozone> i'm all for pragmatics, but it's still odd to see such a solution being used
03:21:44 <Singlot> Hello
03:21:47 <Singlot> i'm here :)
03:22:01 <Lemmih> Greetings.
03:22:06 <Singlot> jajaja
03:22:12 <Singlot> i'm connected with the laptop
03:22:15 <Singlot> where i have haskell
03:22:25 <Singlot> now i'll paste the complete error
03:23:45 <Singlot> the code i use is more extensive than i pasted in the wiki
03:24:32 <Singlot> ok... i post it
03:24:48 <Singlot> and the line 29
03:25:04 <Singlot> is the next of calculaestat
03:25:10 <Singlot> after =
03:27:33 <Singlot> yeah!!
03:27:36 <Singlot> i have find the problem!!
03:27:40 <Singlot> Lemmih
03:27:49 <Lemmih> What is it then?
03:27:51 <Singlot> kin the library... exists an xnou and ynow
03:28:00 <Singlot> that conflicts with the names i put
03:28:49 <Singlot> ah.. not...
03:28:51 <Singlot> i'm wrong
03:28:53 <Singlot> :(
03:30:08 <Singlot> :(
03:33:35 <Singlot> ok thank's a lot Lemmih
03:33:39 <Singlot> i'll keep ontrying
03:33:41 <Singlot> thank's
03:41:38 <Singlot> how can i make a type cast?
03:41:53 <Lemmih> You can't.
03:42:19 <Singlot> well how can i write a float?
03:42:32 <Singlot> it says me that is a double but i wanna a float!!! :P
03:44:08 <shapr> Is there something like fromIntegral or fromRational that might work?
03:44:29 <Lemmih> Singlot: You can use 'realToFrac' for that.
03:44:42 <Singlot> ok.. thanks!!!!
03:44:48 <Singlot> Lemmih you are my salvation today :)
03:45:06 <TFK> My Hus says: Integer -> Double
03:45:16 <TFK> (realToFrac)
03:45:18 <blackdog> ozone: yeah, bit odd. glad it's not only my aesthetic sensibility that's offended.
03:45:48 <Singlot> i wanna (Double->Float)
03:45:53 <Singlot> or Integer->Float
03:46:13 <Lemmih> @type realToFrac (10::Double) :: Float
03:46:19 <lambdabot> realToFrac (10::Double) :: Float :: Float
03:46:37 <Lemmih> @type realToFrac
03:46:38 <lambdabot> realToFrac :: forall b a. (Fractional b, Real a) => a -> b
03:46:56 <TFK> What does 10::Double mean?
03:47:14 <Lemmih> Behold the wonder of type classes!
03:47:36 <TFK> It's a puzzle I can't quite piece together...
03:48:12 <Lemmih> TFK: You can read "::" as 'is of type'.
03:49:32 <TFK> So it coerces 10 to a Double and returns the result?
03:50:08 <TFK> Hmmm. Well, it does work :-)
03:50:34 <Lemmih> (::) is not a function.
03:51:03 <Singlot> can i use fromInteger?
03:51:09 <TFK> Then I have no idea what @type realToFrac (10::Double) :: Float means.
03:51:42 <Lemmih> TFK: Haven't you seen (::) is Haskell code before?
03:52:10 <TFK> Not in function signatures, I think...
03:55:14 <TFK> No, I lie. Obviously I've seen it in func :: ...
03:55:19 <TFK> Hmm.
03:58:09 <Singlot> ok...i left...
03:58:14 <Singlot> thank's a lot
03:58:19 <Singlot> Lemmih and all of you
03:58:22 <Singlot> c'ya!!!
03:58:32 <Lemmih> Bye.
04:23:42 <shapr> The Microsoft monopoly is a cute hack, but I wish someone would go ahead and fix the API.
04:27:35 <shapr> g'day mudshark
04:28:00 <mudshark> g'day yourself
04:29:13 <shapr> How's code?
04:31:18 <dons> shapr, see lambdabot is running on hs-plugins now?
04:31:43 <shapr> Saw you say that only @reboot is needed now.
04:31:44 <dons> and the whole bot from Main.hs upwards in dyn loaded (yi-style)
04:31:48 <shapr> awesome :-)
04:31:59 <shapr> I think that's a very powerful pattern that a lot of Haskell programs will be using in the future.
04:32:13 <dons> i'm writing a paper on it :)
04:32:19 * shapr cheers
04:32:52 <shapr> Did I suggest that idea?
04:32:59 * shapr isn't really sure.
04:33:01 <dons> lambdabot has more diverse state, so it will be a bit harder to keep track of, but if that can be done, than rebooting without dropping the connection seems possible
04:33:10 <dons> possibly, shapr. I think you did.
04:33:38 <dons> i remember hacking it up in yi a couple of hours after we talked about it
04:34:04 <shapr> I like the egoless idea sea of #haskell, just throw out your idea and see if it survives the competition.
04:34:25 <shapr> Yeah, I'm impressed with :reboot
04:34:28 <shapr> It's awesome stuff.
04:34:54 <dons> it'd be nice for lambdabot. it'd (almost) never have to disconnect
04:35:11 <TheHunter> @dynamic-unload pl
04:35:12 <lambdabot> module unloaded
04:35:16 <TheHunter> @pl 1 + 2
04:35:20 <lambdabot> 3
04:35:30 <shapr> I wonder if that's how Erlang-style runtime upgrading works?
04:35:31 <dons> hmm. that's a bit weird.
04:35:40 <TheHunter> hmm.
04:35:43 <TheHunter> @pointless 1 + 2
04:35:44 <lambdabot> Unknown command, try @listcommands.
04:35:50 <dons> @version
04:35:51 <lambdabot> Unknown command, try @listcommands.
04:35:54 <shapr> !
04:35:55 <TheHunter> @dynamic-load pl
04:35:56 <lambdabot> module loaded
04:36:00 <dons> @dynamic-load version
04:36:01 <lambdabot> module loaded
04:36:03 <dons> @version
04:36:04 <lambdabot> lambdabot 2p337, GHC 6.4 (OpenBSD i386)
04:36:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:36:08 <shapr> wild
04:36:08 <dons> @dynamic-unload version
04:36:09 <lambdabot> module unloaded
04:36:11 <dons> @version
04:36:12 <lambdabot> Unknown command, try @listcommands.
04:36:16 <dons> @dynamic-load version
04:36:17 <lambdabot> module loaded
04:36:20 <dons> @dynamic-reload version
04:36:21 <lambdabot> module reloaded
04:36:24 <dons> @version
04:36:25 <lambdabot> lambdabot 2p337, GHC 6.4 (OpenBSD i386)
04:36:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:36:39 <shapr> I look forward to reading that paper.
04:36:45 <dons> I wonder what is different about @pl, TheHunter.
04:36:59 <TheHunter> do i need a very recent version of hs-plugins to run lambdabot?
04:37:14 <TheHunter> I think that's just autocompletion.
04:37:28 <TheHunter> @dynamic-unload pl
04:37:28 <lambdabot> module unloaded
04:37:30 <dons> should only be 0.9.8, unless you want to use ghc 6.4, then you need the cvs version from the last couple of weeks
04:37:34 <TheHunter> @pl \x -> x
04:37:38 <lambdabot> No instance for (Show (t -> t))
04:37:38 <lambdabot>       arising from use of `show' at v = (take 2048 (show (\ x -> x)))
04:37:38 <lambdabot>     In the definition of `resource':
04:37:38 <lambdabot>         resource = let v = (take 2048 (show (\ x -> ...))) in v
04:37:40 <dons> ah ha!
04:37:46 <TheHunter> @dynamic-load pl
04:37:47 <lambdabot> module loaded
04:38:23 <TheHunter> dons, i see.
04:38:30 <dons> shapr, I think that's how we could do erlang, yeah.
04:38:46 <shapr> dons: I notice that both HSP and HWS are using / can use hs-plugins. Quick uptake is one hallmark of a cool tool.
04:39:39 <dons> yeah. i was happy today at how much simpler lambdabot's dyn loading got when replaced with hs-plugins
04:40:50 <shapr> That's four, HSP, HWS, lambdabot, and yi. Any others?
04:41:21 <dons> there's about 20 or so that I know of
04:41:28 <dons> from people who've submitted bug reports.
04:41:39 <shapr> wow, nice.
04:42:02 <dons> i know there's more users on this channel, but I don't know what they're doing with it
04:48:12 <wilx> ?
04:50:58 <shapr> !
04:51:30 <Lemmih> |
04:51:32 <musasabi> How suitable is haskell for writing games? (wx mainly)
04:51:51 <musasabi> Can it handle sound etc or is there an alternative on win32?
04:52:04 <Lemmih> What about using SDL and OpenGL?
04:52:17 <musasabi> Lemmih: how do they work on win32?
04:52:39 <Lemmih> Sure. Both are highly portable.
04:54:06 <musasabi> Lemmih: have you tested whether your? SDL binding works out of the box on win32?
04:56:47 <Lemmih> It should work under cygwin but I haven't tested it.
04:57:17 <vincenz> @pl (\x -> x) (\x -> x)
04:57:18 <lambdabot> id
04:57:26 <Lemmih> (It uses the same code to detect libSDL as a game I know works under windows)
04:59:17 <musasabi> cygwin is not something I would like to force for someone..
04:59:48 <musasabi> (a friend is asking what language he should pick for creating a game and he is using windows)
05:00:02 <Arsilan> Englih
05:00:12 <musasabi> :-)
05:00:13 * Lemmih has no idea of how to find and run sdl-config otherwise.
05:00:41 * musasabi has not even got a windows machine
05:00:45 * shapr doesn't either
05:00:50 <Arsilan> well he will figure it out
05:00:55 <Arsilan> he are talented
05:01:00 <shapr> I think we have a win98 cd around here somewhere.
05:01:03 <Arsilan> I have Windiws
05:01:06 <shapr> Arsilan: are you learning Haskell?
05:01:16 <Arsilan> No
05:01:29 <shapr> Do you already know Haskell?
05:01:33 <dons> least useful comment in lambdabot: -- TODO: Document
05:01:38 * shapr grins
05:01:47 <shapr> Who wrote that comment? (me?)
05:01:51 <Arsilan> hehe, no I don't
05:01:55 <TheHunter> in my defense, i was really planning to do that.
05:02:00 <dons> not sure. it's for IRC.hs:data GlobalPrivate
05:02:07 <shapr> Arsilan: so um, why join #haskell?
05:02:08 <dons> which sounds scary.
05:02:18 <Arsilan> Beacause David are here
05:02:21 <shapr> Ah, I see.
05:02:23 <Arsilan> He never goes in MSN
05:02:30 <shapr> I can understand that.
05:02:33 <dons> hehe TheHunter. ok, i'll work out what it does.
05:02:39 <TheHunter> GlobalPrivate is really a bad name.
05:02:47 <Arsilan> Does some of you go there, In msn
05:03:03 <shapr> I've never used msn.
05:03:10 <TheHunter> the idea being that private state is kept for every target we're interacting with.
05:03:25 <shapr> Arsilan: you realize that if you're here on #haskell, you have to at least try to learn Haskell, right?
05:03:33 <dons> ah!
05:03:44 * shapr gets out the thumbscrews
05:03:54 <Arsilan> Noh I go to HTX, and are bease at concentrating at it
05:04:05 <shapr> What's HTX?
05:04:19 * TheHunter wonders why he hasn't just used a list in GP.
05:04:26 <Arsilan> Highere tecnique ecsame
05:04:37 <shapr> I see.
05:04:48 <shapr> Arsilan: c'mon, try the kool-aid, it's great stuff.
05:05:40 <Arsilan> NAh its not for me, I rather wants to out and play footbal
05:05:53 <shapr> But you're at your computer right now, yes?
05:06:00 <shapr> You could expand your mind!
05:06:06 <shapr> You might even need a larger hat!
05:06:15 <Arsilan> I always ask David he never wants to do someting
05:06:42 <Arsilan> Perhaps I will sit with David and learn itin summer
05:06:48 <shapr> You might like it.
05:07:01 <Arsilan> There are about 2 months
05:07:27 <Arsilan> I give it a try if David are willing to sit with me and do it, in summer
05:07:39 <Arsilan> Idont want to do it alone
05:07:50 <shapr> Ok, if you say so.
05:27:53 <smott> is there any haskell cgi library that can handle binary http uploads (i.e. multipart/data-form)?
05:28:22 <Lemmih> Yeah. Hemplate got a module for that.
05:29:20 <smott> interesting. thanks
05:40:58 <smott> ok that's a little beyond me
06:03:30 * TFK gets Haste
06:04:08 <xkb> haste is that haskell ide?
06:04:12 <shapr> japp
06:04:15 * TFK nods
06:04:22 <TFK> Has anyone here looked at SPOJ?
06:04:35 <xkb> does it has anything to do with yi?
06:04:38 <Lemmih> What's SPOJ?
06:04:40 <TFK> (I pointed at it before, but was wondering if anyone cared)
06:04:45 <TFK> Oh, heh :-)
06:04:52 <TFK> https://spoj.sphere.pl/ <--- also has Haskell
06:04:57 <TFK> Algorithmic challenges.
06:06:16 <shapr> Interesting.
06:06:31 <shapr> Though I have enough realworld Haskell code to write at the moment :-)
06:06:57 <TFK> I have zero real world Haskell code to write at the moment, so...
06:07:32 <shapr> Lots of realworld tasks that could be done in the Haskell world.
06:07:59 <TFK> Hmm, the new-project dialog should really be a file dialog.
06:08:05 <RemiTurk> good afternoon
06:08:38 <shapr> There's the whole range from purely organizational stuff that requires zero Haskell understanding up to deep stuff like GHC improvements.
06:08:42 <xkb> 2bad haste isnt ready for os x yet
06:08:45 <TFK> Hmm, I wonder if I can submit patches to haste :D
06:08:46 <shapr> hoi RemiTurk
06:09:07 <TFK> xkb, Haste isn't ready for anything yet :-(
06:09:11 <TFK> (But testing!)
06:09:18 <xkb> TFK: lol
06:09:30 <xkb> it's looking quite good from the screenshots
06:09:39 <TFK> They're not going to upload their code, are they?
06:09:57 <TFK> Heh. So it's true what they say, pretty pictures account for 90% of the user experience..
06:10:03 <xkb> it's a sourceforge project, so one would think it's open source
06:10:23 <xkb> and there is a svn repos
06:11:33 <TFK> Guess I should get SVN...
06:13:12 <TFK> "New file" doesn't seem to work :D
06:18:42 <TFK> woot! Code! :D
06:18:58 <shapr> yay!
06:23:30 * RemiTurk hopes someone can help him with something that once was a homework exercise
06:23:38 <RemiTurk> @wiki HaskellIrcPastePage
06:23:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:24:33 <RemiTurk> forestUniq is meant to "efficiently" remove all duplicate states from a (game-state) forest
06:24:46 <TFK> Hmm, is it just me or is the Haste GUI hard-coded? o_O
06:25:16 <RemiTurk> but doesn't work for infinite forest (and I fear it /cannot/ work for infinite forests :()
06:26:40 <shapr> Finally, I got my first moin 1.3 wiki installed, whew.
06:26:58 <TFK> I got it! Does anyone want a Haskell-specific pastebin? Or are you content with the Wiki paste-bin like thingie?
06:27:19 <shapr> Do you know of a Haskell-specific pastebin?
06:27:28 <TFK> Nope.
06:27:35 <skew> the wiki already does syntax highlighting
06:27:38 <shapr> Are you going to write one?
06:27:55 <TFK> I know a PHP-specific one, Python-specific one, and an all-around pastebin (rafb.net/paste), and I bet there's lots more I don't know of.
06:27:57 <skew> I don't know what a Haskell specific one would add
06:28:10 <shapr> The wiki's syntax highlighting in pretty sad. I know because I hacked the syntax.py enscript plugin to handle Haskell.
06:28:15 <TFK> Well, wiki presents certain invonviniences, I'd think.
06:28:29 <skew> maybe something Haskell-specific could do something fancy with types
06:28:31 <shapr> I like the 'announce the paste' feature.
06:28:33 <TFK> shapr, I could hook your highlighting code, maybe.
06:28:48 <TFK> *inconviniences
06:28:58 <skew> and maybe hyperlink things to the library documentation
06:29:06 <TFK> Woah there..
06:29:07 <shapr> Enscript does the syntax highlighting, (poorly) syntax.py is just a wrapper for enscript.
06:29:12 <TFK> You know what Linus said, start small...
06:29:26 <shapr> Actually, yes, that's a cool idea. Hey, there's already something like that?
06:29:28 <shapr> Yes, there is!
06:29:34 <TFK> There is?
06:29:40 <shapr> Not proxima, what's the Hallgren editor?
06:29:44 <skew> The highlighting doesn't look too bad to me
06:29:46 <shapr> Programatica?
06:29:57 <shapr> skew: have you seen the -- output left in foo bug?
06:29:57 <skew> I haven't seen anything do much better with Haskell
06:30:21 <skew> no
06:30:21 <shapr> Programatica(?) is *way* better.
06:30:22 <TFK> Line-enumeration would be nice.
06:30:35 <TFK> Announces via lambdabot, aye.
06:30:45 <TFK> Unique links for unique posts...
06:31:02 <TFK> It's all more convinient, I'd say.
06:31:06 <shapr> Ah here we are, check this out - http://www.cse.ogi.edu/~hallgren/Programatica/tools/pfe.cgi?UTF8
06:31:34 <shapr> via - http://www.cse.ogi.edu/~hallgren/h2h.html
06:31:54 <shapr> That would be a totally kick-ass pastebin.
06:32:00 <TFK> UTF-8 is cool, I like it.
06:32:19 <jlouis> TFK: sure is
06:32:20 <TFK> hmmm
06:32:26 <skew> I hate the colors
06:32:31 <TFK> Colors can be changed.
06:32:43 <skew> the underlines should probably go doo
06:33:04 <skew> They really clutter it up
06:33:28 <TFK> I suppose it's hackable.
06:33:32 <shapr> I've discovered that some users are convinced you can't click on something if it doesn't have an underscore.
06:33:48 <shapr> Scary, but true.
06:33:49 <skew> yes, but we're talking Haskell users here :)
06:33:54 <shapr> good point :-)
06:33:59 <skew> what was that, pointy-headed user base?
06:34:02 <shapr> haha
06:34:09 <shapr> Something like that.
06:34:15 <skew> we can even right-click on things sometimes!
06:34:15 <TFK> You could have those appearing underscores when you move your mouse button over it.
06:34:35 <skew> I like the little alt text that pops up when you point at stuff
06:34:58 <skew> references to something in the same module could be a little more graphical somehow
06:35:12 <TFK> What could we stick here, signatures? They should be avaliable from the code, I think.
06:35:14 <skew> giving line:char and not numbering the lines isn't too nice
06:35:27 <TFK> line:char?
06:35:31 <shapr> One of our colleagues in a recent EU Project website was convinced we were overpaid and underworked, and he was (is?) getting a PhD in IT or something like that. So I gave him the short course on Zope and Plone. Now he wants his company to partner with ours.
06:35:54 <skew> adding type signatures to the popups would be nice
06:35:58 <shapr> Truly
06:36:06 <skew> TFK: point the mouse at "c", for example
06:36:27 <TFK> heh, wow
06:36:27 <skew> "c: a value defined in this module at 9:13"
06:36:38 <shapr> That's quite cool.
06:36:50 <TFK> Well, I should probably get it to work first, then beautify it or whatnot.
06:36:58 <skew> why not just steal this?
06:37:07 <TFK> Sure, that's what I'm going to do :3
06:37:11 * shapr grins
06:37:29 <TFK> But I'm assuming it's a bit too bloated for actual fixin', no? You talked about excessive underlines and the underscores thingie.
06:37:30 * shapr goes unicycling, bbl.
06:37:30 <skew> how do those popups work?
06:37:46 <TFK> a title="" attribute in the <a> tag.
06:37:52 <TFK> HTML ^_^
06:38:01 <skew> lots of these are "var" tags
06:38:50 <TFK> Err... not familiar with those. My knowledge of HTML stops with, well, HTML.
06:39:17 <skew> I don't know what they are either
06:39:43 <TFK> But I'll have to learn, eh? :-/
06:40:37 <TFK> I'll call it, "hbin"!
06:43:44 <skew> I was thinking that if they used something active like javascript to pop up the little box it could also highlight the actual definition
06:44:24 <TFK> Nah, I bet the var is a CSS thing or somesuch. Note that it also has a title attribute.
06:44:46 <skew> it's actually a standard html4 thing, like <em> or <strong>, or <abbr>
07:02:53 <RemiTurk> would anyone like to take a look at http://www.haskell.org/hawiki/HaskellIrcPastePage ?
07:03:16 <TFK> skew, oh, that's even better :-)
07:03:28 <basti_> hi all
07:13:02 <TFK> Hmmm, what's the difference in Hugs between Hugs mode and Haskell98 mode?
07:13:26 <basti_> hmm some extra features to haskell... fundeps for example
07:13:37 <basti_> (hugs mode is the non-standard, extended mode)
07:14:56 <CosmicRay> Does the Handle behind hGetContents automatically close when the entire contents have been read, or alternatively, when the string returned by hGetContents has been GC'd?
07:15:51 <TFK> basti_, thanks
07:16:00 <basti_> tfk hth :)
07:44:33 <shapr> Unicycling is so much fun!
07:44:48 <CosmicRay> @seen SyntaxNinja
07:44:49 <lambdabot> I haven't seen SyntaxNinja
07:46:01 <CosmicRay> does anyone else think these will be useful:
07:46:03 <CosmicRay> pipeFrom :: FilePath -> [String] -> IO (PipeHandle, String)
07:46:08 <CosmicRay> pipeTo :: FilePath -> [String] -> String -> IO PipeHandle
07:46:14 <CosmicRay> pipeBoth :: FilePath -> [String] -> String -> IO (PipeHandle, String)
07:46:16 <shapr> What's a pipehandle?
07:46:35 <CosmicRay> data PipeHandle =
07:46:36 <CosmicRay>     PipeHandle { processID :: ProcessID,
07:46:36 <CosmicRay>                  phCommand :: FilePath,
07:46:36 <CosmicRay>                  phArgs :: [String],
07:46:36 <CosmicRay>                  phCreator :: String -- ^ Function that created it
07:46:36 <CosmicRay>                }
07:46:43 <shapr> lets you write to a spawned process?
07:46:47 <shapr> Ah, I see.
07:46:48 <CosmicRay> right
07:46:57 <shapr> Sure looks handy to me.
07:47:15 <CosmicRay> in a nutshell, a PipeHandle carries all the information necessary to reap the process when it's finished, and to display an informative error message if there's an error
07:47:22 <shapr> I want it!
07:47:26 <shapr> I want it now!
07:47:32 <shapr> Actually, I don't have time to play with it now.
07:47:38 <shapr> But I surely need it for my darcs integration.
07:48:10 <CosmicRay> that's exactly wwhat I'm writing it for :-)
07:48:12 * CosmicRay runs darcs push
07:48:21 <CosmicRay> shapr: darcs get --partial http://darcs.complete.org/missingh
07:48:27 <CosmicRay> file MissingH/Cmd.hs
07:48:38 <CosmicRay> note: it's untested right now :-)
07:48:53 <CosmicRay> shapr: btw, hugs doesn't seem to support fork()
07:49:06 <CosmicRay> shapr: I posted on the hugs list but got no reply.  does anybody read that list?
07:49:30 <shapr> I dunno
07:49:42 <smott> is there any image manip library for haskell in which it would be very easy to resize images to thumbnail dimensions? :)
07:49:53 <shapr> ImageMagick? =)
07:50:08 <skew> why doesn't case let you match over multiple expressions?
07:50:14 <smott> oh, there's imagemagick? /me googles
07:50:18 <skew> what's wrong with case 1 2 of x y -> x + y ?
07:50:27 <CosmicRay> skew: because you could trivially put them in a tuple and match over that? :-)
07:50:29 <shapr> No, there's no Haskell binding for ImageMagick, but it's easy to use in a shell command.
07:50:34 <shapr> Can you do that?
07:50:34 <CosmicRay> skew: case (1, 2) of (x, y) -> x + y
07:50:40 <shapr> what?
07:50:42 <shapr> oh
07:50:44 <CosmicRay> heh
07:50:50 <TheHunter> @type 1 2
07:50:53 <skew> you can always do that
07:50:55 <lambdabot> 1 2 :: forall t. (Num (Integer -> t)) => t
07:51:06 <shapr> Oh, I thought you meant case x of 1 or 2 -> "less than three, more than zero"
07:51:09 <skew> I guess the ambiguitiy is with application?
07:51:47 <skew> I was just thinking that the function syntax lets you match on multiple values
07:51:53 <shapr> That's wild.
07:52:03 <skew> you could parse things as if case was a function, so it would get 1 and 2
07:52:25 <skew> I think it would make the language more symmetrix
07:52:43 <shapr> It would be a cool trick, that's for sure.
07:53:21 <skew> one of the great things about Haskell is how regular it is
07:54:29 <skew> you can treat all data the same, define infinte stuff just the same way as finite stuff, use the same application and infixing syntax at type and value level, etc.
07:54:36 <TheHunter> if case were to be made a function, i think the argument order should be reversed, i.e. "case (x, y) -> x + y end" should be equivalent to uncurry (+).
07:55:07 <skew> I don't mean make case a function
07:55:33 <skew> I mean parse "case 1 2" in case 1 2 -> x + y more like "add 1 2" than "case (1 2)"
07:56:52 * Lemmih smells a can of worms.
07:57:13 * shapr eats a can of worms.
07:57:27 <shapr> Yum! Just like octopi!
07:57:28 <skew> there's nothing wrong with the way functions work
07:57:28 * esap codes a can of worms.
07:59:18 <skew> let case_42 (x:xs) 0 = x; case_42 [] y = y; case_42 (x:xs) y = x+y in case_42 [1,2,3] 7
07:59:38 <skew> vs case [1,2,3] 7 of (x:xs) 0 -> x | [] y -> y | (x:xs) y -> x+y
07:59:47 <skew> I don't see the worms
07:59:52 <skew> I guess shap got them all
08:00:03 <skew> and my r too!
08:01:21 * shapr grins
08:01:42 <shapr> And remember, my name is shay - purr
08:01:59 <shapr> not shapp - err
08:02:10 * shapr waves the flag making shapes
08:03:31 <smott> is there anything like System.system but String -> IO String?
08:03:57 <Lemmih> smott: What should the resulting string contain?
08:04:29 <smott> the output of the command
08:04:43 <Lemmih> stdout or stderr?
08:04:48 <smott> stdout
08:06:59 <Lemmih> skew: It'll add complexity without adding new functionality.
08:08:48 <Lemmih> You would probably write 'case ([1,2,3],7) of ((x:xs),0) -> x; ([],y) -> y; ((x:xs),y) -> x+y' instead of the 'let' expression.
08:22:35 <Oejet> smott: What do you want the semantics to be in String -> IO String?  There is a buffer problem.
08:24:04 <smott> Oejet: all i really need is to find out the type of a file. so i thought calling file(1) would be a quick way to do so.
08:27:02 <Oejet> Ok, but I think making the roundtrip:  Haskell -> stdin -> program -> stdout -> Haskell, will open the beforementioned can of worms.
08:40:31 * basti_ just wrote his first template haskell program
08:41:21 * basti_ will try to crash ghc with it
08:41:26 <basti_> =)
08:41:55 <basti_> disappointing
08:41:56 <basti_> ;)
08:43:28 <smott> Oejet: i don't know how else to do it
08:45:41 <Oejet> smott: Do it in two steps: 1. System.system("file foo>file.tmp"). 2. readFile("file.tmp").
08:46:09 <Oejet> But there might be a right way to do it, that I don't know of.
08:46:51 <smott> system_ :: String -> IO String
08:46:51 <smott> system_ cmd = do { system (cmd ++ " > tmp"); c <- readFile "tmp"; return c; }
08:46:56 <smott> this totally doesn't work though
08:51:50 <Lemmih> @type do (inch,out,err,h) <- System.Process.runInteractiveProcess "file" ["someFile"] Nothing Nothing; r <- System.IO.hGetContents out; r `seq` System.Process.waitForProcess h; return r
08:51:55 <lambdabot> do (inch,out,err,h) <- System.Process.runInteractiveProcess "file" ["someFile"
08:51:55 <lambdabot> ] Nothing Nothing; r <- System.IO.hGetContents out; r `seq` System.Process.
08:51:55 <lambdabot> waitForProcess h; return r :: IO String
08:53:27 <smott> ouch
08:54:53 <Oejet> Ha, ha, lisppaste2 failed to PONG.  Basic stuff, really.
08:57:44 <TFK> Wow. With a bit editing options, Hugs and TextPad make a nifty IDE :-)
09:00:17 <sylvan> what's lisppaste2? Some sort of lisp-irc-client?
09:01:11 <basti_> sylvan: a backend to our pasting bin
09:01:22 <basti_> it will notify the chan if somebody posted something
09:02:52 <TFK> pastebin? what pastebin?
09:04:49 <basti_> hmm
09:04:55 <basti_> we could ask lisppaste if he were here
09:04:57 <basti_> :)
09:05:06 <TFK> :-/
09:05:42 <TFK> I was just getting all worked up about writing a pastebin in Haskell. Would be somewhat pointless if one already existed!
09:06:36 <basti_> ahh
09:06:47 <basti_> i dont know if its written in haskell
09:06:48 <basti_> i doubt
09:08:03 <TFK> Hmmm. I wonder how I can make TextPad display a grey line at the 80-th columb...
09:08:43 <TFK> Oh well ^_^
09:10:40 <Oejet> TFK: Maybe just resize to 80 columns?
09:10:52 <TFK> That's too easy.
09:11:06 <TFK> Besides, I'm pretty sure the resize is "fuzzy".
09:17:04 <autrijus> wow, three new papers from spj.
09:17:55 <musasabi> where?
09:18:21 <autrijus> http://research.microsoft.com/%7Esimonpj/#current
09:18:36 <autrijus> boxy types, scrap with classes, associated type synonyms
09:19:19 * musasabi starts reading
09:20:02 <ves> grrrr
09:20:05 <ves> http://uploadhut.com/upload/71034.hs
09:20:30 <ves> could anyone tell me why that isn't recusrivley building a tree containing the word in a list of words + the occurances of that word in the list? :/
09:20:40 <ves> spent upwards of 2 hours on this
09:24:18 <machack666> @type ($)
09:24:20 <lambdabot> ($) :: forall b a. (a -> b) -> a -> b
09:25:43 <machack666> anyone want to answer what "$" does?  googling for "$" doesn't really get you much... :)
09:25:45 <basti_> machack666: thats application, right associative
09:25:58 <basti_> like in: (sum (prods list)) = (sum $ prods list)
09:26:03 <skew> machack666: do you know about free theorems?
09:26:06 <basti_> confused me too
09:26:14 <basti_> "theorems for free"?
09:26:19 <skew> yep
09:26:35 <skew> if you have an (a->b), and an a, the only sensible way to get a b is to apply them
09:26:40 <skew> or use error
09:26:50 <skew> plus you can mess around with seq
09:26:56 <basti_> thats a buzzword from category theory i thought :P
09:27:00 <skew> but we pretend all the stuff doesn't matter
09:27:00 <machack666> so it just lets you not have to put as many parens?
09:27:04 <skew> yep
09:27:09 <machack666> ok
09:27:13 <machack666> thanks all
09:27:31 <basti_> lol
09:27:50 <Lemmih> @plugs zipWith ($) [cos,sin] [1,2]
09:27:50 * basti_ sees machack mutate to a haskell master within a few hours
09:27:55 <lambdabot> [0.5403023058681398,0.9092974268256817]
09:27:55 <skew> ves: you don't change the count when you add a word
09:28:12 <basti_> wah thats cool.
09:28:15 <ves> hmm
09:28:22 <skew> you match (Node y a t1 t2), where y gets the old could by that word, and put that same y back into the new node
09:28:27 <basti_> i didnt think about using $ THAT way ever hehe
09:28:38 <ves> ah, I see
09:29:16 <skew> I mean, you put the same a back in. I guess y is matching the word
09:29:26 <ves> yeah
09:29:34 <skew> Try Node y (a+x) t1 t2 in the s==y case
09:29:36 <ves> I've rewritten it so many times, am I using the right approach?
09:29:43 <skew> yeah, that looks good
09:30:08 <skew> Oh, except the stuff with count is kind of silly
09:30:33 <skew> you might as well just bump the count by 1 each time you add the word
09:30:49 <ves> yeah
09:31:25 <ves> ah, your a+x trick is helping, but it's only working for the first word in the list
09:31:55 <skew> if you do a+x, then at the end you end up with the word paired with the sum of all the x values you passed in
09:32:10 <ves> i see
09:32:29 <skew> count is wierd. You use words on the second argument, just so you have to use unwords on xs before you pass it to count
09:32:46 <ves> yeah
09:32:54 <ves> I'm sure there must be an easier way than this :)
09:33:10 <skew> it's a lot more natural to count the number of times something shows up in a list, than to always count on breaking up a string
09:33:34 <ves> hmm
09:34:25 <skew> if you have count x = length . filter (==x), then you can use words at the call if you do need to break up words, like count "hello" (words "hello world"), or you can use it for completely different things, like count 1 [1,2,3]
09:34:47 <ves> yeah, I get you
09:35:29 <ves> I'll probably have another go at rewriting it and count them as they come
09:36:08 <skew> this is pretty good as it is
09:36:18 <skew> I hopy you don't mean rewrite from scratch
09:36:31 <ves> to be honest, I've just entirely confused myself
09:36:36 <ves> :)
09:36:48 <skew> you don't need the maketree [x] case
09:37:18 <ves> ah
09:37:31 <skew> it's exactly like the rest of the recursion plus the insert x l Nil case
09:37:37 <ves> yeah
09:38:12 <ves> it seems to be miscounting some words now if they are appearing at the end
09:38:19 <ves> maketree ["what","hello","kefka","what","what","kefka"]
09:38:22 <ves> Node "kefka" 1 (Node "hello" 0 Nil Nil) (Node "what" 3 Nil Nil) :: BST a b
09:38:22 <ves> (2788 reductions, 5059 cells)
09:38:23 <skew> Why does the type BST have arguments s and a?
09:38:40 <skew> what does maketree look like?
09:38:46 <ves> it should be holding the value of the string, plus the number of occurences of that string in the list..
09:38:50 <ves> isn't that neccessary?
09:39:13 <skew> you never use them
09:39:33 <ves> hmm
09:45:11 <ves> I've cleaned it up and removed all that count nonsense then and it seems to be doing a bit better :)
09:46:33 <ves> hah, working perfectly actually
09:46:45 <ves> I appreciate your help, skew
09:47:20 <skew> what's the best way to turn [Maybe [a]] into [a]? I've got concat . catMaybes, but I'm thinking there's some monad function that could do this
09:47:37 <skew> ves: thanks
09:48:14 <skew> actually, I guess I want fmap concat . sequence
09:52:45 <jlouis> Category theory question: if C is a category, |C| is the objects of C and A,B \in |C| (A and B are objects of C). Then what is C(A, B) usually? The arrow from A to B?
09:53:54 <skew> there's more than one
09:54:09 <skew> but I think Hom(A,B) is usually used for the set of arrows from A to B
09:55:18 <jlouis> skew: thanks. It seems it is what I think it is
09:55:40 <skew> you have a category where there is only one arrow between two objects?
09:56:59 <jlouis> skew: you misunderstood me. I have a category where I have more than one arrow between 2 objects, so your definition works
09:57:11 <jlouis> I was simply not precise enough in my statement
09:57:21 <skew> oh, okay. What are you reading?
09:59:27 <jlouis> ``Denotational Foundations of functional programming'' -- Thomas Streicher
09:59:38 <jlouis> It is really cool in fact
10:00:10 <jlouis> He does not plunge that much into category theory though
10:12:27 <TNKS> hello everybody.  I was thinking.  I use interactive enviornments like Hugs and ghci for debugging and development, but I think it would be cool if there was some support for persistent memory in these enviornments.  Has anybody given this much thought?
10:13:14 <TNKS> If I had something like that, I might use a Haskell interactive enviornment for personal data-management.
10:13:32 <Lemmih> You got persistent state in the source files...
10:13:54 <TNKS> source files for ghci and hugs?
10:13:58 <TNKS> I'm not sure I'm following.
10:14:17 <basti_> I'm not, tool.
10:14:19 <basti_> -l
10:14:32 <Lemmih> myState = ["some data"]
10:14:59 <sylvan> TNKS, use emacs, load ghci in a separate buffer (haskell mode) and then you can write your defs in the source file, while testing them in ghci
10:20:21 <gzl> is there much to be gained from running a ghci buffer in emacs as opposed to in some term the usual way?
10:20:38 <TNKS> Okay, I guess I'll be more clear about what I was thinking of.  I was hoping to make a GUI knowledge representation and reasoning system that uses Haskell as it's framework (sort of the way Microsoft uses VBA for it's macros).
10:21:38 <TNKS> I'm tired of KR&R systems that are based on Lisp.  They're dirty, and I think it's largely because these communities 1) abandon type-checking and 2) abandon thinking functionally.
10:23:43 <TNKS> Anyway, I know it's probably a wild idea, but if anyone has thoughts about it, I'm interested in hearing them
10:24:16 * basti_ thinks the type system is one of the big successes in haskell
10:24:29 <TNKS> I'm right now thinking about making some sort of crude wrapper around ghci.
10:24:33 <basti_> and the simplicity
10:24:49 <sylvan> TNKS check out hs-plugins (and plugs)
10:25:13 <TNKS> where do I find hs-plugins?
10:25:21 <TNKS> is that a package name?
10:25:25 <sylvan> gzl: not really, I just think it's convenient to have it all in the same "window"..
10:25:32 <gzl> yeah, ok.
10:25:32 <basti_> TNKS: are you thinking like "eclipse"?
10:25:46 <gzl> well, tuareg mode for ocaml does some pretty cool stuff.
10:25:54 <sylvan> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:26:53 <TFK> Heh, while editing in Hugs, I can't click on the task bar xD
10:27:02 <TNKS> basti_, no because Eclipse is a coding enviornment.  I think KR&R systems are really more tied to old-school "frames-system" ideas.
10:27:40 <basti_> i do not see what you mean with Knowledge Representation and Reasoning then?
10:28:14 <basti_> i was thinking about features like, typing an identifier, and your editor finds out its type and helps you completing the expression
10:28:53 <TNKS> KR&R stems from old AI -- from the days when people strove to fit world-knowledge (with all it's complexity) into reasoning machines.
10:29:05 <basti_> uhm
10:29:11 <basti_> theres 2 ways to do that:
10:29:19 <basti_> 1) logic (which is worked out as far as things go)
10:29:22 <basti_> 2) doesn't work.
10:29:23 <TNKS> ultimately, though, the KR&R community made more technologies than really compelling systems.
10:30:06 <TNKS> basti_, I'm with you.  I'm right now working with a more modern frames-system which is very object-oriented in style.
10:30:21 <basti_> are you thinking like, computer asks: "does this mushroom have brown gills or yellow ones?" and you reply and the computer asks a sensible question next...
10:30:26 <basti_> whats a "frames system"?
10:32:02 <TNKS> Marvin Minsky wrote this crazy paper that would never be published today that abstractly proposed a system to do reasoning with that involved "frames" of things with "slots".   People tried to reify his vision in Lisp applications that ultimately have kind of an object-oriented feel.
10:32:51 <basti_> hm
10:32:59 <TNKS> basti_, but you're right, those kind of questions are along the right vein.
10:33:02 <basti_> i dont know specifically about this kind of systems
10:33:23 <basti_> but this sort of problem is tractable very well in prolog (or with a prolog like environment)
10:33:32 <basti_> (which would be not TOO hard to construct from scratch)
10:34:00 <TNKS> I know, but the scope of what I'm thinking of is more about semantic nets and searching sematic nets with lazy evaluation.
10:34:36 <TNKS> where semantic nets are linked with strongly typed links.
10:34:39 <basti_> i shun everything thats called "semantic something"
10:34:39 <basti_> ;)
10:35:04 <TNKS> wierd, I try to shun everything called "something net".
10:35:13 <TNKS> but I'm having a hard time shunning this one.
10:35:21 <theorbtwo> No meaning for you, basti?
10:36:18 <basti_> theorbtwo: no thick books about explaining the meaning of meanings
10:36:19 <basti_> ;)
10:37:10 <basti_> hmm no but honestly, most of everyday logics is already worked out.
10:37:24 <basti_> there is even statistical logic models.
10:38:15 <basti_> that would be enough for representation of all "denotational" human knowledge.
10:38:52 <basti_> there might be things that make it easier to work with
10:48:25 <TNKS> yeah, I hear you about the logics, but honestly, I'm not really interested in the logics part of things as much as the representation part.  So yeah, I guess I'm interested in having a system that can quickly erect interesting ontologies.
10:48:38 <TNKS> I think the reasoning aspect is pretty route.
10:50:39 <TNKS> All right guys, thanks for the conversation.  I think I need to get back to work.
11:02:36 <TFK> Can I stick an element to the end of a list in O(1)?
11:03:09 <basti_> hmm.
11:03:23 <basti_> can you stick elements to lists at all? =)
11:03:51 <Oejet> Can you element a stick? o_O
11:03:51 <TFK> Not sure. The reasoning is that I create a new list by doing a:[a], right?
11:04:12 <TFK> Good question...
11:04:16 <Oejet> TFK: No you cannot.
11:04:43 <Oejet> But you can keep the list in reversed form, and in the end reverse it back.
11:04:49 <TFK> Suckage. So to do that, I have to do [a]++[ch], where ch is my char?
11:04:54 <Oejet> Or you could do:
11:04:58 * TFK nods
11:05:02 <Oejet> @wiki Im
11:05:03 <lambdabot> http://www.haskell.org/hawiki/Im
11:05:13 <Oejet> @wiki ImperativeHaskell
11:05:14 <lambdabot> http://www.haskell.org/hawiki/ImperativeHaskell
11:05:32 <TFK> Horrible.
11:05:40 <TFK> I'll go with the slow and ugly version for now...
11:05:47 <TFK> But I'll be back >-)
11:06:05 <Oejet> TFK: Just profile and see if that is the biggest bottleneck.
11:06:18 <TFK> I have to get it to compile first :3
11:06:27 <Oejet> TFK: You do know how to profile, don't you?
11:06:40 <TFK> I did such a thing once in Python.
11:06:55 <TFK> Then I discovered it didn't register built-in functions :-/
11:07:30 <TFK> But I'm familiar with the concept, yes.
11:07:58 <TFK> Before I actually use the code, I must make sure it's not dead-ugly. Dead ugly code will run slow no matter the profiling. :-/
11:08:08 <Oejet> TFK: ghc -prof -auto-all
11:08:20 <Oejet> TFK: ./a.out +RTS -p
11:08:24 <TFK> Did I mention I'm inside hugs atm?
11:08:43 <Oejet> Oh, don't know how it works then.
11:09:09 <TFK> :-P
11:13:46 <TFK> Woot! It compiles!
11:16:01 <TFK> But now pattern matching error!
11:24:42 * TFK is baffled
11:27:35 <_JusSx_> what?
11:28:19 <TFK> Suppose I have a string, "x x". (' ':xs) fails, but right after that (x:xs) should match, right?
11:28:41 <TFK> i.e., foo :: String -> String; foo (' ':xs) = ...; foo (x:xs) = ...
11:29:29 <TFK> BAH!
11:29:41 <TFK> stupid typo in capitalizing some obscure name >_<
11:29:43 <TFK> sorry
11:30:30 <TFK> Woo! My htmlizer works.
11:32:51 <zugzwang> Is there an interface to select() in the hierarchical libraries (I can't find one), or is select frowned upon in the Haskell world? Should I be using concurrency where in C I'd use select()?
11:40:42 <Lemmih> Hey SyntaxNinja!
11:40:47 <SyntaxNinja> heya Lemmih
11:40:51 <SyntaxNinja> just who I was looking for :)
11:41:58 <SyntaxNinja> Lemmih: can you create an accurate web page for hackage that I can put online?
11:42:09 <SyntaxNinja> one that has the correct repository and URL for the prototype?
11:42:38 <Lemmih> Sure.
11:43:02 <Oejet> zugzwang: You can use orElse in STM, maybe.
11:43:19 <SyntaxNinja> is this the correct URL: http://www.scannedinavian.org/~lemmih/cgi-bin/hackage/hackage
11:43:29 <Lemmih> Yep.
11:43:48 <Oejet> zugzwang: http://web.mit.edu/ghc/www/hslibs/select.html
11:43:50 <Lemmih> Oejet: Nah, can't do IO in STM.
11:44:03 <SyntaxNinja> and this is the darcs repo? http://www.scannedinavian.org/~lemmih/hackage/
11:44:16 <Lemmih> Yep.
11:44:56 <SyntaxNinja> c00
11:45:44 <Oejet> Lemmih: Who needs IO? :-P
11:46:06 <SyntaxNinja> Lemmih: is it the case that there are only 4 lines in the hackage client?
11:46:10 <Lemmih> You do, if you want to query the state of a handle.
11:47:07 <Lemmih> SyntaxNinja: I haven't pushed patches for some days.
11:48:24 <SyntaxNinja> Lemmih: :)
11:49:30 * SyntaxNinja incessantly wiggles eyebrows at lemmih until he pushes patches
11:50:47 <Lemmih> Pushed the webpage updates.
11:50:48 <SyntaxNinja> Lemmih: when you fix up the web page, can you add links to the dependencies like xml-rpc?
11:51:22 <SyntaxNinja> cool
11:52:06 <Lemmih> Dependencies (and urls) are in the README file. I just need to catch bringert so he can host the GHC 6.4 compliant haskell-xml-rpc.
11:53:24 <SyntaxNinja> Lemmih: email him :)
11:55:31 <shapr> cha wow!
11:55:37 <Lemmih> He said I should mail the changes to him and I did (:
11:56:02 <SyntaxNinja> hi shapr :)
11:56:04 <SyntaxNinja> Lemmih: c00
11:56:21 <Lemmih> And it was about 20 days ago.
11:56:54 <Lemmih> No response yet. I'm wondering if I made a tyop in the address.
11:57:52 <shapr> hiya
11:57:59 <Lemmih> Hey shapr.
11:59:36 <zugzwang> Oejet: Hmm, I thought hslibs were deprecated?
12:00:08 <kolmodin> how far is hs-plugins from working on windows?
12:01:37 <Lemmih> SyntaxNinja: Only four lines in HackageClient?
12:02:03 <zugzwang> Oejet: and the source says '{-# DEPRECATED "This module is unmaintained, and will disappear soon" #-}'...
12:02:31 <shapr> kolmodin: as far I know it's only path translation that is the problem.
12:03:03 <SyntaxNinja> Lemmih: there are more now :)
12:03:22 <kolmodin> shapr: ok
12:04:43 <kolmodin> shapr: have you tried haste yet? :)
12:04:47 <shapr> Not yet.
12:05:04 <shapr> Mostly because I don't have any wxHaskell debs.
12:05:20 <kolmodin> runnix linux? which distro?
12:05:27 <shapr> debianix :-)
12:05:38 <chr1s> I have this function: foldr (\a b -> a + b/10) 0  [1.0,4.0,5.0]
12:05:39 <kolmodin> crap, spelling :)
12:05:43 * shapr grins
12:05:57 <chr1s> it turns a list like [1,2,3] into 1.23
12:05:58 <TFK> Are LicensedPreludeExts included with Hugs and/or GHC?
12:05:59 * cm unrolls shapr 
12:06:03 <Lemmih> shapr: haste needs a custom compiled wxHaskell.
12:06:10 <chr1s> but i want it to turn it into 0.123
12:06:10 <kynes> are there any hope that FP will dominate the market in the near future?
12:06:13 <shapr> TFK: no, but you can grab 'em from the wiki.
12:06:20 <TFK> Copy-paste?
12:06:24 <chr1s> I can just add / 10 to the whole function
12:06:26 <Cale> TFK: yeah
12:06:31 <SyntaxNinja> kynes: not dominate, no :)
12:06:32 <shapr> kynes: Dominate which market?
12:06:33 <chr1s> but is there a way to do it nicely in the foldr?
12:06:33 <RemiTurk> `near' on a geological timescale, yes
12:06:36 <Oejet> zugzwang: Then I'm out of suggestions.
12:06:37 <TFK> Didn't get to modules yet, but OK, will do that :-)
12:06:38 <kynes> entire..
12:06:56 <kynes> I couldn't find the exact word maybe..
12:06:57 <shapr> kynes: The software market only recently discovered automatic memory management.
12:07:28 <kynes> that's exactly why I'm asking..
12:07:42 <kynes> I want to react according to the future..
12:07:59 <shapr> Glacial is most active word I would use to describe the initiative of the average software company.
12:08:14 <chr1s> anyone?
12:08:20 <Cale> chr1s: foldr (\a b -> (a + b)/10) 0  [1,4,5,6]
12:08:22 <kynes> a language can be very complex but may become obsolete in say.. 5 years
12:08:23 <TFK> It has split and join, awesome :D
12:08:30 <kynes> if it's not designed properly
12:08:32 <shapr> kynes: What do you mean?
12:08:57 <TFK> Erm, hugs borks on it o_O
12:09:06 <shapr> On LicensedPreludeExts?
12:09:17 <kynes> I'm not talking about Haskell itself.. it's designed good. very good..
12:09:26 <kolmodin> I have made .ebuilds for gentoo so it's not much worse than 'emerge haste'
12:09:35 <kynes> so don't misunderstand
12:09:45 <TFK> ERROR "/haskell/hbin\LicensedPreludeExts.hs":27 - Haskell 98 does not support depen
12:09:46 <TFK> dent parameters <--- :O
12:09:50 <shapr> kynes: I'm starting to make money with Haskell. Functional Programming is slowly filtering into the mainstream, look at the recent "Higher Order Perl" book.
12:10:12 <kynes> thanks
12:10:23 <shapr> kynes: Do you have any specific questions?
12:10:41 <kynes> okay.. I've one I guess..
12:10:48 <kynes> but it may be out of scope
12:10:58 <shapr> well, try it
12:11:05 <kynes> you know, c#.. .NET  ..
12:11:39 <shapr> Heard of 'em, know some tech details.
12:11:47 <shapr> Haven't used 'em, don't have a copy of windows.
12:11:47 <kynes> some scholars say it's about time they become obsolete
12:11:54 <shapr> For what reason?
12:12:02 <kynes> that's good for sure ;)
12:12:06 <SyntaxNinja> Lemmih: so where do I get xml-rpc?
12:12:26 <SyntaxNinja> an updated version, I mean.
12:12:40 <kynes> but I have to play games.. so miki$oft is useful for some games for me..
12:12:42 <chr1s> Cale: thanks
12:13:01 <kynes> for what reason..
12:13:37 <kynes> okay, it's all about their basic design
12:13:47 <Lemmih> SyntaxNinja: http://www.scannedinavian.org/~lemmih/haskell-xml-rpc.tgz
12:13:48 <kynes> but I don't know these languages myself..
12:13:58 <kynes> so don't ask why they're bad
12:14:02 <Lemmih> But it's only temporary.
12:14:12 <kynes> I'm just asking
12:14:42 <kynes> whats temporary
12:15:05 <shapr> Nobody really knows. I know what I'd like the software industry to become, but I doubt it'll follow my wishes.
12:15:21 <shapr> Sun is happy that Java is so popular, but will it stay that way? They don't know.
12:15:31 <Lemmih> kynes: Sorry, it was meant for SyntaxNinja.
12:15:43 <kynes> np
12:15:45 <shapr> Microsoft made .NET, so they want it to keep going, will it?
12:15:57 <Cale> TFK: yeah it's that class Adjunction -- run hugs with -98
12:16:04 <kynes> maybe windows itself won't keep going
12:16:15 <shapr> Right, could be.
12:16:31 <shapr> In my opinion, the only way you can keep your knowledge from becoming obsolete is to keep on learning new stuff.
12:16:36 <kynes> design's making more and more problems
12:16:49 <SyntaxNinja> Lemmih: so cabal-get depends on haxml as well
12:17:04 <Lemmih> Nope.
12:17:07 <kynes> what's your opinion about Cobol? [I don't know it]
12:17:20 * basti_ couchs
12:17:21 <basti_> g
12:17:23 <SyntaxNinja> Lemmih: since xml-rpc depends on haxml
12:17:27 <shapr> I've read that COBOL was designed to be readable by managers.
12:17:36 * SyntaxNinja doesn't know cobol either
12:17:41 <Lemmih> SyntaxNinja: Oh right.
12:17:43 * basti_ doesn't want to know cobol
12:17:50 <shapr> I've written some COBOL some years ago, it's pretty weird.
12:18:01 <basti_> i heard its input file format is based on punchcards
12:18:07 <basti_> get that
12:18:24 <TFK> Cale, ERROR "/haskell/hbin/\LicensedPreludeExts.hs":148 - Undefined class "Monoid"  <--- this in "Hugs mode" of Hugs.
12:18:45 <kynes> heard some "guesses" about the reason of it's success though.. they can't just change every atm around the world..
12:18:45 * RemiTurk remembers learning cobol to help my girlfriend do hear homework
12:18:49 <RemiTurk> her
12:18:57 <kynes> it's costly
12:19:02 <shapr> I'm self-employed. My priorities for a programming language are to make solid programs in the smallest amount of time.
12:19:18 <Cale> TFK:  import Data.Monoid
12:19:38 <kynes> self-employment? it must be weird..
12:19:41 <kynes> how is it?
12:19:45 <shapr> Actually it's wonderful.
12:20:04 <RemiTurk> IMO cobol has an interesting data-model (though I wouldn't want it in any language for actual use) and is an excelent example why "let's make it look like natural language" makes for horrible programming languages
12:20:06 * Lemmih is too sick to appreciate the ramifications of dependencies dependencies.
12:20:07 <kynes> .. I guess making money is the hardest part of it, eh? :)
12:20:09 <shapr> You either have too much work, or not enough money. Or you can say lots of income or lots of vacation.
12:20:53 <shapr> Anyway, if it takes me too long or too much money to do what my clients ask, they find another programmer.
12:20:58 <TFK> Cale, thanks, but it seems like it's missing a bunch of other imports. Maybe they should be added to the code?
12:21:06 <shapr> So I have a vested interest in getting stuff right the first time.
12:21:39 <Cale> TFK: possibly -- most people treat the LicensedPreludeExts page like a place for snippets, but yeah, that would e handy
12:21:42 <Cale> be*
12:21:47 <RemiTurk> though I didn't really do anything in it for fear of ending in a mental instituation: I merely read a book about it (my girlfriend of that time was studying applied computer science and learned it as her first programming language...)
12:21:49 <kynes> .. and writing "modifiable programs" ? :)
12:22:05 <shapr> kynes: yes, that's very perceptive.
12:22:20 <shapr> I need to be able to change my programs quickly to follow what my clients need.
12:22:54 <kynes> clients always change their minds I hear.. :) human beings don't know what they want generally
12:23:02 <kynes> world domination... or pizza?
12:23:05 <kynes> pizza I take.. :)
12:23:07 <shapr> heh
12:23:23 <shapr> Clients don't know what they want until you don't give it to them.
12:23:44 <wilx> How big sw do you write in Haskell?
12:23:54 <shapr> For me, just small stuff so far.
12:24:07 <shapr> But other people have written larger stuff.
12:24:15 <kynes> RemiTurk: I heard Cobol is written by a woman
12:24:29 <Cale> shapr: broken the 100 line barrier into insanity? :)
12:24:40 <kynes> (not trying to discriminate..)
12:25:07 <RemiTurk> kynes: I heard that too
12:25:29 <shapr> Cale: hehehe, yes.
12:25:41 <kynes> coder && girl && 20.. that's impossible :)
12:26:27 <kynes> I mean.. possible but it may happen just out of some real necessities.. but "just out of necessities"..
12:27:26 <kynes> what can one do in 100 lines most?
12:27:27 <RemiTurk> *thinks* she was 17 at the time
12:27:35 <shapr> Grace Hopper?
12:27:55 <RemiTurk> (and was forced to learn visual basic & c++ after cobol)
12:27:58 <Cale> kynes: one can do quite a lot with 100 lines of Haskell code.
12:27:59 <RemiTurk> haha
12:28:10 <RemiTurk> no, my former girlfriend who I learned cobol for
12:28:25 <Cale> especially if you don't count comments.
12:28:32 <kynes> :)) that's an interesting approach for a date
12:28:51 <kynes> but if it works, I can try :)
12:28:51 <RemiTurk> she broke up shortly after I read that book ;)
12:28:57 <kynes> lol
12:29:06 <Cale> Having written an ~800 line program, I think there might be another such barrier of insanity at around 1000. :)
12:29:27 <RemiTurk> though we're still friends, even though she lives in another country
12:29:46 <Cale> (That was my pipeline scheduler)
12:30:05 <kynes> :) I want a girl who's away from computer..
12:30:18 <Cale> (and the register allocation stuff too, come to think of it)
12:30:26 <TFK> Cale, I like comments.
12:30:43 <Cale> TFK: use literate Haskell :)
12:30:45 <TFK> Coming from Python, which sacrificies conciseness for readability, it counts :-)
12:30:53 <TFK> Yeah, I'm interested with that idea.
12:30:57 <shapr> I think Haskell has both, surprisingly.
12:31:05 <kynes> yes
12:31:15 <Cale> I am counting comments in that number. It would probably be ~400 lines without comments
12:31:16 <kynes> it's very readable for me
12:31:20 <TFK> I'll take it up when I'll be able to find my way better around o.o
12:31:48 <TFK> *interested in
12:31:58 <TFK> My English is limping today :-/
12:32:08 <Cale> I love being able to write code which is also the source for a LaTeX document.
12:32:09 <shapr> My Hebrew has no legs.
12:32:14 <Oejet> TFK: Conciseness means that you don't say more than you have to.  That ought not to go against readability.
12:32:40 <TFK> It's the old Perl vs. Python debate, I suppose.
12:32:47 <TFK> I never coded in Perl, but I heard horror stories...
12:32:53 <shapr> TFK: Hey, did you try to get that paste highlighter working?
12:32:58 <wilx> Heh.
12:33:01 <kynes> :) "horror stories"?
12:33:04 <wilx> Perl horror stories are not true.
12:33:13 <TFK> Horror stories of abysmally unreadable code.
12:33:15 * Oejet wants to hear a horror story.
12:33:19 <wilx> Those who write it just do not know enough Perl :)
12:33:33 <mflux> stories such as "I coded a content management system as a perl-oneliner"?
12:33:34 <wilx> The same situation as with C++.
12:33:36 <TFK> Yup. And thus begins yet another language flame war ^_^
12:33:36 <wilx> IMHO.
12:33:36 <sorje> (or know too much i.e. golf ;-)
12:33:50 <TFK> I don't code in C++, either :-P
12:34:05 * RemiTurk once thought C++ was elegant
12:34:15 * RemiTurk once was a child
12:34:16 <gzl> I think a lot of them revolve around the fact that Perl is somewhat conducive to writing things in a nasty fashion
12:34:20 * shapr once thought Visual Basic was elegant.
12:34:26 <TFK> But it's hard to write unreadable code in Python. I mean, you have conciously try to succeed. There's still poor code, though...
12:34:27 * RemiTurk feels old
12:34:28 <gzl> though it doesn't require that they be done like that
12:34:31 <RemiTurk> (at 22)
12:34:43 <wilx> Eh.
12:34:47 * RemiTurk shouts at shapr
12:34:52 <wilx> C++ rocks.
12:34:52 <shapr> Um, I'm older than you.
12:34:57 <Cale> I have witnessed visual basic horror stories :)
12:35:00 <kynes> do you use "implicit variables" in haskell?
12:35:02 <wilx> And with that I boot back to Windows...
12:35:19 <RemiTurk> kynes: not since I heard about the laws it invalidates
12:35:22 <TFK> gzl, that's the idea of the Python vs. Perl debate. The philosophies differ, and Perl isn't on the side of readability. Or so the story goes...
12:35:48 <kynes> RemiTurk: such as?
12:36:12 <gzl> TFK: yeah.
12:36:31 * RemiTurk doesn't remember. some greek-letter-reduction?
12:36:44 <gzl> beta reduction?
12:36:50 <shapr> eta reduction?
12:37:01 <gzl> i would guess one of those two.
12:37:27 <TFK> Hmph, now I'm getting ERROR "/haskell/hbin/\LicensedPreludeExts.hs":132 - Undefined class "MonadPlus" <--- but I can't find MonadPlus in GHC's listing of modules.
12:37:32 <kynes> i gotta go now.. thanks and bye
12:37:48 <RemiTurk> bye
12:39:11 <Cale> TFK: it's in Control.Monad
12:39:48 * Cale recalls VB forms where the controls for 20 or so tabs were all stacked on top of one another and visibility properties were set all over the place at runtime in the code, which itself was a hideous incomprehensible mess, having been hacked on by at least 10 different contractors who didn't care about whether it made sense.
12:40:10 <shapr> scary
12:40:11 <Cale> Lucky I didn't have to work on them :)
12:40:28 <wilx> Wheee!
12:40:34 <Oejet> Cale: Nice story.
12:41:19 <Cale> I think there was one thing they got me to fix, some control wasn't appearing since the version of the VB runtime had changed.
12:41:35 * Oejet wants more stories.
12:41:56 <wilx> Heh, sounds like thedailywtf.com material.
12:42:34 <shapr> hoi goron
12:42:46 <goron> hej
12:43:02 * goron registered on LtU :)
12:43:18 <TFK> ERROR "/haskell/hbin/\LicensedPreludeExts.hs":103 - Undefined variable "mkRegex" <--- I'm getting this even though I have import Text.Regex
12:43:29 <TFK> Oh wait, that's 5.0
12:43:46 <TFK> Nope, still there in 6.2
12:44:22 <shapr> goron: Found anything interesting on LtU?
12:44:59 <TFK> any ideas?
12:44:59 <goron> shapr: Yes, the stuff on "do we need a new language".
12:45:08 <TFK> (Do we?)
12:45:13 <goron> shapr: And the GHC survey (thanks to you).
12:46:17 <shapr> :-)
12:48:41 <TFK> Heh, now it says that it "cannot build superclass instance", something with Adjunction...
12:49:17 * TFK violently comments out pieces of code
12:49:31 * shapr violently parses some text.
12:49:36 <TFK> I have six imports. Text.Regex is probably redundant, though.
12:50:07 <TFK> Yup. Make that five.
12:50:55 <goron> shapr: This is a must see, if you are interested in 3d stuff.
12:50:57 <goron> wget http://video.gprime.net/media/video/totalimmersion.wmv
12:51:52 <TFK> I can load LicensedPreludeExts but I can't browse it? o_O
12:52:10 <TFK> ah, :browse Main
12:52:57 <SyntaxNinja> meh
12:53:14 <SyntaxNinja> Lemmih: hackageclient won't build w/ ghc 6.3
12:53:16 <SyntaxNinja> 6.2 I mean
12:54:40 <Lemmih> SyntaxNinja: Yeah.
12:54:50 <TFK> Ah, joinList, split, it's heaven ^_^
12:54:59 <Lemmih> GHC >= 6.4 are amongst the dependencies.
12:56:41 <SyntaxNinja> I guess 6.4 is the most important thing to target. I still don't have it installed at home; I'll just work on shapr's machine
12:56:42 <Lemmih> SyntaxNinja: Why won't it build with GHC 6.2?
12:59:07 <TFK> Is there a replace for strings somewhere?
12:59:55 <RemiTurk> Data.PackedString
13:00:01 <RemiTurk> and darcs' FastPackedString
13:00:12 * RemiTurk goes on tea-hunt
13:00:27 <TFK> sankty
13:00:30 <TFK> *sankyu
13:00:38 <TFK> Even my Engrish doesn't work :-/
13:01:02 <Lemmih> Anyhow, I'm off to bed. Battling a cold and I think I'm losing judging by the amount of snot.
13:01:30 <SyntaxNinja> Lemmih:  hey
13:01:35 <SyntaxNinja> Lemmih: did you forget to commit hackage/Version.hs?
13:02:25 <shapr> goron: that is really awesome.
13:02:49 <Lemmih> SyntaxNinja: Nope. Are you looking at the right repo?
13:03:03 <SyntaxNinja> heh
13:03:19 <TFK> Erm, I don't see a replace in Data.PackedString...
13:03:20 <SyntaxNinja> darcs pull
13:03:20 <SyntaxNinja> Pulling from "http://scannedinavian.org/~lemmih/hackage/"...
13:03:20 <SyntaxNinja> No remote changes to pull in!
13:03:30 <SyntaxNinja> Lemmih: there's a version.hs in Client, but not in hackage itself
13:04:22 <Lemmih> SyntaxNinja: Oh right, pushing it now.
13:04:25 <Lemmih> (:
13:04:34 <TFK> So no replace built into Haskell? I can make my own, maybe, but just wondering.
13:04:45 <Cale> http://docs.info.apple.com/article.html?artnum=86816 :)
13:04:53 <Gahhh> doesnt replace imply mutable strings ?
13:05:15 <Lemmih> SyntaxNinja: Pushed.
13:05:30 <Cale> TFK: what sort of replace?
13:05:58 <SyntaxNinja> Lemmih: can you chill for 5 minutes while I build this?
13:06:06 <Cale> TFK: just to replace one character with another?
13:06:09 <pediddle> Lemmih: more snot means you're winning, I think
13:06:15 <TFK> Substrings, actually.
13:06:20 <SyntaxNinja> Lemmih: so how do I fix this again: Packages.hs:33:57: Module `DBInfo.StaticInfo' does not export `location'
13:06:37 <Lemmih> pediddle: Hurrah then (:
13:06:47 <Cale> there's subRegex from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text.Regex.html
13:07:03 <TFK> replace "foo" "bar" "foobar" => "barbar"
13:07:07 <TFK> A regex...
13:07:08 * TFK looks
13:07:09 <Cale> which might be overkill, but it will probably work well
13:07:30 <TFK> Can I add stuff to LicensedPreludeExts?
13:07:37 <Cale> yes, anyone can
13:07:58 <shapr> As long as you agree to the license, of course.
13:08:06 <Lemmih> SyntaxNinja: Run 'create' from DBSpec.
13:08:30 <TFK> Gotta read it, then :-) maybe it includes me agreeing for an amry of ninjas monitoring my every step...
13:08:36 <Lemmih> SyntaxNinja: You probably need to 'rm DBInfo*' first.
13:09:14 <SyntaxNinja> I'll have to add hooks for that...
13:09:30 <pesco> TFK: Ah, yeah, the ninja clause is in there.
13:09:49 * pesco winks at the army outside his window.
13:09:52 <TFK> Then I'll have to search for contractual loopholes!
13:09:58 <SyntaxNinja> Lemmih: is there an up-to-date TODO list that I can start working on?
13:10:59 <Lemmih> Nope.
13:11:06 <goron> shapr: Yes, I know. I only am not sure whether it's real or bogus. Well, even if it's bogus it's entertaining.
13:11:49 <Gahhh> goron: what is that ?
13:12:06 <SyntaxNinja> Lemmih: OK I can build it
13:12:23 <SyntaxNinja> Lemmih: I'm going to work on the dependency analyzer then, sound OK?
13:12:27 <Lemmih> SyntaxNinja: I promise I'll improve the hackability of Hackage once I get better. (:
13:12:36 <SyntaxNinja> Lemmih: cool
13:12:46 <goron> Gahhh: You mean "it"? See the wget stuff above.
13:13:13 <chr1s> Parser Combinators in haskell are so fucking sweet :D
13:13:17 <Gahhh> goron: I think I joined after the wget stuff. sorry.
13:13:25 <shapr> chr1s: truly
13:13:53 <chr1s> I can parse "repeat 5 [forward 10, back 100]" and stuff like that :D
13:13:58 * chr1s is proud of himself
13:14:04 <SyntaxNinja> what do folks think about the idea of having a default cabalSetup binary installed? one that implements defaultMain
13:14:12 <shapr> binary?
13:14:38 <goron> wget http://video.gprime.net/media/video/totalimmersion.wmv
13:14:50 <goron> Gahhh: There you go.
13:15:04 <Gahhh> goron: thanks
13:15:05 <SyntaxNinja> shapr: so you don't have to build Setup.lhs if it just uses defaultMain; all you need to do is run /usr/bin/cabalSetup
13:15:29 <shapr> Oh, I like that.
13:16:48 <SyntaxNinja> so for now, Setup.lhs is required, since that's the conservative choice; when we get more experience, maybe we can make it optional, idono.
13:18:23 <goron> SyntaxNinja: Is your first name really Ninja?
13:18:30 <SyntaxNinja> goron: no
13:18:37 <goron> SyntaxNinja: Isaac
13:18:39 * shapr grins
13:18:50 <SyntaxNinja> hi sh10151
13:18:57 <shapr> He was promoted from the SyntaxPolice to the SyntaxSpecialForces.
13:19:01 <goron> Some stupid webpage said Ninja Jones.
13:19:06 <SyntaxNinja> where?!
13:19:07 <SyntaxNinja> ;)
13:19:07 <shapr> That would be me!
13:19:27 <goron> Well, that certainly matches the stupid part ;)
13:19:30 * shapr laughs
13:20:13 <SyntaxNinja> oh goron be nice
13:20:56 * shapr has dutch humor armor on today.
13:21:05 <goron> shapr is not stupid :-) and I think shapr understands that.
13:21:31 <goron> I mean shapr was even in #stratego. :-D
13:21:41 <shapr> Yes, I understand. When joking with Dutch and Australians, make sure to wear your asbestos underwear.
13:22:01 <shapr> goron: and now I'm in #trace
13:23:04 * RemiTurk finally understands why everyone makes such a fuss about asbestos here in the netherlands
13:23:09 * shapr laughs
13:23:16 <Gahhh> goron: yeah that was a pretty cool video.
13:23:24 <goron> shapr: Does anyone say something in there anytime? I have been there a couple of times, but no one said anything.
13:23:33 <shapr> Yeah, some conversation today.
13:24:51 * goron got to go. Bye
13:24:56 <shapr> cya
13:28:41 <TFK> Now Hugs has gone beserk: ERROR "/haskell/hbin/\Hbin.hs" - Module "Main" already loaded <--- worked just fine the last 10 sessions...
13:29:30 <RemiTurk> hm
13:29:45 <RemiTurk> there is some nice haskell-guruness ranking system, isn't there?
13:29:57 <shapr> You mean on the Irc Channel wikipage?
13:29:57 <RemiTurk> what does one get for understanding http://research.microsoft.com/%7Esimonpj/papers/control/ ?
13:30:08 <TFK> ERROR "\haskell\hbin\Hbin.hs" - Module "Main" already loaded  <--- huh?...
13:30:23 <RemiTurk> I guess so
13:31:03 <RemiTurk> indeed: We've come up with a martial arts style colored belt grading system:
13:31:38 <Gahhh> TFK: I am not familiar with hugs. Is that Hbin.hs your file ?
13:32:04 <TFK> Yup. Doesn't matter, :load Prelude chokes just as well.
13:33:11 <TFK> At least the definitions from Prelude are there; Hbin's aren't.
13:34:35 <Gahhh> TFK: what does ":show modules" display ?
13:35:00 <TFK> command not found :-)
13:35:25 <Gahhh> ah. apparently it's ghci only.
13:37:04 * TFK loads GHCi...
13:37:37 <chr1s> TFK: how do you enter a command like that in ghc?
13:37:49 <chr1s> ah, nevermind
13:37:51 <TFK> Likr what?
13:37:53 <TFK> *like
13:37:58 <chr1s> nevermind
13:37:59 <TFK> :-(
13:39:42 <TFK> GHCi says, I can't copy-paste from the shell there >_<
13:40:10 <TFK> LicensedPreludeExts.hs: file name does not match name "Main"
13:40:12 <boegel> woops, didn't know I had another xchat open :)
13:41:45 <Gahhh> TFK: does the module name have to be Main ?
13:42:08 <TFK> I don't know, but I found this:
13:42:13 <TFK> ERROR "File2.lhs": Module "Main" already loaded
13:42:13 <TFK> This error happens if you load two anonymous modules into (Win)Hugs. The solution is to name the modules concerned and to set up the appropriate import/export structures.
13:42:28 <TFK> What the heck are anonymous modules?
13:42:41 <Gahhh> TFK: files without a top level Module statements
13:42:44 <Gahhh> err declarations
13:42:56 <TFK> Ah, I do have two of those. I think.
13:43:07 <boegel> TFK: modules without a name ? just guessing here...
13:43:22 <TFK> Meh. I'll just copy-paste what I need from LicensedPreludeExts... this is too painful.
13:43:40 <shapr> do it!
13:43:47 <Gahhh> just add a line that says "module Superhacks where"
13:44:55 <shapr> autrijus: speaking of RSS (Research SuperSyndicated), http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf "Why Dependent Types Matter" by Conor McBride, James McKinna and Thorsten Altenkirch
13:44:59 * TFK sobs
13:46:59 <TFK> WOO! IT COMPILES!
13:47:24 * shapr dances happily
13:50:15 * boegel dances with shapr
13:50:19 <TFK> Does Haskell keep a list of interesting groups of characters somewhere? Like all whitespaces?
13:50:45 * Oejet listens to Looptroop Rockers.
13:50:45 <Gahhh> must be in the haskell report. haskell.org
13:50:53 <shapr> TFK: We're all here on #haskell.
13:51:04 <shapr> Oh, you mean like letters?
13:51:08 * shapr snickers evilly
13:51:16 <TFK> o.o;
13:51:27 * shapr looks around at all the interesting characters on #haskell.
13:51:28 * boegel puts on his radio
13:51:37 * TFK fears the report
13:51:37 * shapr puts on his hat.
13:51:38 <Gahhh> haskell report. chapter 9.
13:51:46 * boegel waves at shapr, hoping to get noticed
13:51:52 <shapr> mwc: You're an interesting character, right?
13:51:56 * shapr notices boegel.
13:52:04 -shapr(~user@2002:53e2:b108:0:0:0:0:2)- hello boegel.
13:52:08 <Gahhh> mwc is a qubit hax0r
13:52:09 * boegel stops waving
13:52:24 * shapr grins
13:52:32 * boegel yawns
13:52:43 <Gahhh> ok stop emoting
13:52:51 <shapr> Right, ok then.
13:52:53 <TFK> gabor, uniWhite?
13:53:17 * cm rolls shapr 
13:53:21 <TFK> hmm, whitechar
13:53:28 <Gahhh> the standard supports unicode characters but the current implementations dont, afaik.
13:55:17 <TFK> Anyway, I'm not sure how all this relates to what I need...
13:57:40 <TFK> Aha! Char.isWhitespace!
13:57:48 <TFK> No wait, that's Java :-/
13:58:20 * Oejet tycker åt Looptroop er bra.
13:58:28 <shapr> Never heard of 'em
13:58:32 <Oejet> TFK: ws(). :-P
13:58:44 <TFK> o_O
13:59:15 <TFK> From I come from, "import string; if char in string.whitespace: ..." would do the trick :-P
13:59:42 <TFK> Aha! Char.isSpace !
13:59:42 <Oejet> TFK: Na, it's just C++'s magic whitespace eater.
13:59:51 <Gahhh> TFK: See csection 2.6 in the report.
14:01:13 <TFK> I don't see where 2.6 defines Char.isSpace or somesuch. I'm not interested in whitespaces as much as I'm interested in checking against them :-)
14:02:17 <mwc> shapr, define interesting
14:02:43 <shapr> mwc: math person!
14:02:51 <Gahhh> it doesnt define a function. you can write your own. "isspace a = a == ' '" ?
14:02:57 * shapr grins
14:03:13 <mwc> shapr, I'm actually a theoretical physics majro
14:03:18 <Cale> or just (== ' ')
14:03:29 <TFK> AHa, until I hit a tab.
14:03:33 <shapr> I suspect that qualifies as interesting character.
14:03:44 <Cale> (`elem` " \t\v\r\n")
14:03:50 <Cale> something like that?
14:04:16 <TFK> Maybe, but no. isSpace seems to do exactly what I want.
14:04:44 <TFK> The point is, I don't want to care about how whitespaces are written. I may not know that \t or \r exist ;-)
14:04:58 <TFK> Thanks nevertheless :-)
14:05:19 <Cale> You may not know that \t and \r exist?
14:05:26 <mwc> shapr, I'm actuall watching a documentary on american tank development before WW2 and doing assignments I should have done a month ago
14:05:52 <TFK> Yes.
14:06:05 <TFK> Not everyone knows his control characters.
14:06:14 <Cale> \a \b \f \n \r \t and \v are defined in the Haskell standard
14:06:34 <Cale> and are defined to be portable
14:06:35 <Gahhh> TFK: yeah you should use Data.Char anyways instead of rolling your own function. It makes your code more readable.
14:06:41 <Cale> but yes
14:06:43 <Cale> use isSpace
14:06:55 <TFK> I'm glad you agree with my decision ;-)
14:07:20 <Gahhh> the ninja squad is here to help you
14:07:34 <Gahhh> or was it the army of ninjas
14:07:35 <shapr> hiiiYAH!
14:08:13 <Gahhh> shiruken >>= shapr >> return ()
14:08:40 <shapr> oof!
14:08:42 <TFK> army :-)
14:11:46 <pediddle> If I may interrupt, does anyone know why Fink's GHC and Hugs packages are so woefully out of date?  Do they need a new maintainer?
14:15:24 <TFK> It's funny, for the past two hours I was merely trying to get this: htmlize = lambda html: "<br/>".join([line.rstrip().replace(' ', "&nbsp;") for line in html.split("\n")]) <--- but in Haskell.
14:15:40 <TFK> I actually succeeded: htmlize input = joinList "<br/>" $ map (replace " " "&nbsp" . rstrip) (lines input)
14:15:57 <TFK> Join us tomorrow, when we do... HTML and CGI!!
14:16:10 <TFK> Good night all, and thanks again.
14:16:15 * shapr is tired also.
14:16:22 <Gahhh> np. check out the text.html stuff in ghc
14:16:28 * TFK will
14:17:23 <Gahhh> I guess it's time for me to go shopping, then. Monads are indeed hard. Laterz.
14:17:43 <shapr> hah
14:17:59 * CosmicRay just woke up from a nap :-)
14:18:28 * xerox emulates the some-minutes-ago CosmicRay, goodnight folks ;-)
14:18:38 <CosmicRay> :-)
14:36:21 <boegel> b0gg1e_: you like my nick ? :)
14:42:51 <shapr> gah, I just wrote -> instead of > when piping to a file on the command line.
14:42:55 <shapr> I need sleep!
14:46:03 <RemiTurk> good night then
14:46:23 <RemiTurk> though it probably merely gave a type error?
14:46:40 <RemiTurk> uhuh, of course not
14:46:49 <RemiTurk> of course yes
14:46:59 <CosmicRay> heh
14:47:00 * RemiTurk needs sleep too
15:09:55 <RemiTurk> good night
15:10:13 <boegel> bye RemiTurk
15:11:56 <blackdog> morning.
15:15:03 <CosmicRay> hi blackdog
15:15:59 <blackdog> ah, monday morning. my cue to stop hacking haskell and start hacking python. :(
15:17:02 <CosmicRay> blackdog: bummer
15:17:52 <blackdog> 'spose i can always abuse the FP function in python - if for no other reasons than my own aesthetic satisfaction and just a smidgeon of job security.
15:18:54 <CosmicRay> blackdog: of course, guido is trying to remove those features
15:18:56 <CosmicRay> which sucks
15:19:07 <CosmicRay> he's doing his best to make python un-interesting, I think :-)
15:19:41 <blackdog> a slightly less verbose cobol, perhaps?
15:19:52 <CosmicRay> haha
16:01:29 <chr1s> hey, how do I check if a list of a type which isn't in Eq is empty?
16:01:48 <chr1s> when I do cmd == [] it complains that Command isn't in Eq
16:02:27 <chr1s> ah, null
16:02:28 <Lemmih> case list of [] -> True; _ -> False
16:02:28 <xerox> isEmpty [] = True; isEmpty _ = False ?
16:02:43 <Lemmih> Or just 'null'.
16:02:45 <Lemmih> @type null
16:02:51 <lambdabot> null :: forall a. [a] -> Bool
16:03:20 <Lemmih> lambdabot: You're getting a bit slow.
16:03:21 <lambdabot> Not a command (no @).
16:23:47 <blackdog> @vixen it's monday morning. cheer me up.
16:23:49 <lambdabot> what's the matter?
16:24:45 <blackdog> @vixen aliens have taken over the kitchen. plone won't do what i tell it to. my boss left a tack on my chair. nobody loves me.
16:24:46 <lambdabot> i dunno, what now?
16:33:31 <kaol> @yow
16:33:33 <lambdabot> I want the presidency so bad I can already taste the hors d'oeuvres.
16:35:18 * SamB wonders how to build/run lambdabot now
16:36:15 <desrt> @yow
16:36:16 <lambdabot> I'm having a tax-deductible experience!  I need an energy crunch!!
16:48:53 <dons> SamB: grab hs-plugins. that's all
16:49:17 <dons> if you're using ghc 6.4, you need hs-plugins cvs. otherwise hs-plugins-0.9.8 will do fine.
16:49:53 <awarth> hello. i was wondering if anyone here has used happy for parsing Java.
16:50:19 <dons> for parsing java, no. but it wouldn't be too hard if you have a grammar.
16:51:34 <awarth> I don't know if you've ever heard of the Polyglot project (www.cs.cornell.edu/projects/polyglot). It's this thing that lets you implement java extensions. but it's fairly complex, and hard to use. I'm pretty sure that a haskell version of the same sort of thing would be better. but it would take a fair amount of work.
16:52:35 <chr1s> I think it shouldn't be too hard to parse java
16:53:06 <dons> all those ; and { } are just made for parsing!
16:53:10 <awarth> so i've been thinking about maybe starting something like that. the thing is that, in addition to parsing java, polyglot also does a lot of static checks on the code, and typechecks everything. that way you can just write a tree transformer and implement the compiler for you java extension as a source-source translator (from your extended java to java). lots of work!
16:56:24 <Gahhh> is it worth extending java anyways ?
16:57:24 <awarth> yeah, actually. you know, people actually USE IT! I mean, if you are doing PL research, you can get a lot more users of your new "thing" by extending Java than, say, haskell. plus, java needs to be extended, and haskell is perfect! :)
16:58:46 <dons> but you condemn your soul to eternal damnation
17:00:46 <awarth> it's already damned anyway...
17:01:09 <blackdog> dons: so why did you do haskell in java as your honours? :)
17:01:33 <Gahhh> I dont really see how that holds. I think there are more users using haskell/ocaml/etc than are users using an extended version of an existing language. I dont even know any extensions to any popular languages.
17:02:11 <dons> blackdog: I don't want to answer that question
17:02:25 <awarth> gahhh: yes, that's right. but here's the thing. what percentage of those haskell users are going to use MY extension? wheras with Java, you've got a much larger number of users. So you end up with a bigger impact.
17:02:37 <awarth> just playing the numbers.
17:02:59 <awarth> for every haskell programmer, there are probably 200-300 java programmers.
17:05:29 <skew> yeah, but how many java programmers will try out new stuff?
17:05:57 <skew> If you can get your extension into GHC I think just about everybody who uses Haskell would try it out
17:07:33 <Gahhh> I'd say you would have a bigger chance with Perl extensions if you wanna play with numbers
17:08:31 <dons> it's nice that haskell is more portable than java these days. ghc too.
17:10:16 <SamB> dons: there is a small problem with 6.2
17:10:40 <dons> what's that?
17:11:09 <dons> I haven't tested 6.2.2 and hs-plugins yet. will do so now.
17:11:22 <gzl> it's more portable?
17:11:37 <dons> sure. ghc runs on 8-10 archs now.
17:11:50 <dons> just thinking of how hard it is to get java on an openbsd box makes me wince
17:11:58 <SamB> dons: I'm sending you a patch
17:12:03 <dons> let alone a non-x86 box.
17:12:16 <dons> yep. good patch.
17:12:19 <dons> :}
17:12:46 <gzl> ok, i see your point.
17:12:50 <dons> @karma+ SamB
17:12:51 <lambdabot> SamB's karma has been incremented
17:13:11 <gzl> yeah, and i suppose apple's jdk releases always end up lagging sun's by a fair bit too
17:13:45 <dons> and then nhc98 runs on 22 archs.
17:13:53 <dons> which java will probably never run on.
17:14:26 <SamB> considering how boring Java is, you are probably right ;-)
17:14:27 <johs> Is it possible to bootstrap GHC from Hugs or nhc98?
17:15:13 <dons> not anymore  (too many ghc extensions in the src), but from gcc is ok.
17:15:38 <dons> SamB: that's exactly right.
17:16:00 <johs> dons: You can bootstrap GHC from GCC?
17:16:13 <dons> that's the usual way
17:16:17 <johs> Oh.
17:16:24 <johs> I remember having to get GHC to bootstrap GHC.
17:16:29 <johs> Maybe I was doing something wrong.
17:16:42 <dons> it's a bit easier if there's already binaries for your platform
17:17:13 <dons> otherwise you partially compile ghc src on another box, down to C code, then finish the compilation on the new machine
17:17:21 <skew> johs: that's the easy way of building it from Haskell
17:17:37 <skew> johs: bootstrapping through C is if you are trying to port to a new machine
17:17:50 <johs> Ah, right.
17:19:18 <johs> (I'm not using it on any platforms for which there aren't binaries anyway.)
17:19:41 <johs> Not that there seems to be missing support for a lot of current platforms.
17:20:05 <johs> Some guy was complaining about not being able to run Darcs because GHC wasn't ported to some Cray system.
17:20:26 <SamB> whoa.
17:20:33 <SamB> and I thought windows looked bleak.
17:20:44 <dons> windows is alright, isn't it?
17:20:58 <johs> I've briefly tested it on Windows, and it _appears_ to work.
17:21:06 <johs> (When following the instructions on the Darcs wiki.)
17:21:27 <SamB> I had troubles with Cygwin's ssh when I tried to push (or pull via an scp-style path)
17:21:52 <dons> oh, ok. tool support is surely bleeeak
17:22:07 <SamB> never would have even tried it on windows if Zooko hadn't had trouble
17:22:08 <johs> SamB: Did you try the putty-tools?
17:22:30 <SamB> johs: I couldn't get cygwin to run those instead of its own :-(
17:23:14 <skew> does anyone here know how to match an unordered set of patterns against a bag of values?
17:23:20 <johs> Just write a shell-script wrapper where you put them before Cygwin's ssh in PATH.)
17:23:31 <SamB> johs: not a bad idea
17:23:37 <dons> skew: "set of patterns", of what type?
17:24:10 <skew> Well, I'm writing some tree processing stuff myself, so this is happening up in an interpreted language
17:24:38 <skew> the terms are trees labeled with strings at each node
17:24:56 <skew> the patterns are trees labeled with strings, that can have variable names or strings at leaves
17:25:14 <skew> The problem is, if I have patterns like ("a"
17:25:16 <skew> (
17:25:52 <skew> { "A"(X,1), "A"(2,1) } to be matched against values { "A"(2,1) "A"(3,1) }
17:27:05 <skew> then I can't just match the first pattern, pull out the tree it matched against and recurse
17:29:18 <skew> but I would like to do something a little smarter that trying every subset in every permutation
18:58:27 <cm> peace
18:59:11 <blackdog> war!
19:01:36 * blackdog can't sing low enough, so you'll have to imagine the "uh!"s.
19:08:10 <dons> morning blackdog
19:12:10 <blackdog> ...in my dimension, 12:09 is already the afternoon. :P
19:12:48 <blackdog> my boss has stocked the fridge with free energy drinks. This is either the best thing in the world, evah, or a certain death knoll.
19:13:15 <dons> hmm... that's almost criminally devious.
19:13:35 * blackdog runs around the room three times without touching the floor
19:13:40 <cm> nice
19:13:41 <dons> hackers + caffeine = trouble
19:13:53 <cm> i always have to go to the petrol station to get my energy drinks
19:14:33 <blackdog> these don't seem to make me as jittery as coffee. i think he may be adding speed to it.
19:15:08 <dons> hmm..
19:15:30 <dons> maybe he's been reading up on old WW2 productivity methods
19:15:41 <blackdog> amphetamines for all!
19:16:00 <dons> the future is ours! man and machine will triumph!
19:16:20 <dons> sleep is for weak flesh!
19:17:02 <blackdog> flesh is for sleep weak!
19:17:11 <dons> hello macabot, glad to see you could join us.
19:17:19 <dons> macabot: @version
19:17:20 <macabot> lambdabot 2p344, GHC 6.2.2 (Darwin Power Macintosh)
19:17:20 <macabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:17:30 <dons> macabot: @dynamic-unload version
19:17:31 <macabot> module unloaded
19:17:34 <blackdog> macabot: do you grok 6.4 yet? </wistful>\
19:17:34 <dons> macabot: @version
19:17:34 <macabot> Not a command (no @).
19:17:35 <macabot> Unknown command, try @listcommands.
19:17:44 <dons> macabot: @quit
19:17:52 <dons> haven't looked at it yet.
19:32:42 <cm> blackdog: http://www.flickr.com/photos/mikka/9726146/
19:33:09 <cm> HDR red bull can..!
19:42:29 <blackdog> HDR?
19:45:04 <cm> high dynamic range
19:52:30 <blackdog> i am no wiser.
19:52:47 <Pseudonym> It's a JPEG or something.  How H can the DR be?
19:53:53 <cm> it's tonemapped by my digital camera :)
19:54:47 <Pseudonym> So what you're saying is that the particular universe that the photo was taken in was HDR.
19:54:56 <Pseudonym> OK, I'll buy that,.
19:55:05 <cm> :)
19:55:40 <cm> the red bull can and you even share the same universe :)
19:55:59 <Pseudonym> Yeah, but the photo doesn't if it's not HDR.
19:57:15 <cm> :\
20:01:37 <cm> j brandon something guy is still in games, uhuh
20:01:43 * cm catches up with c.l.functional
20:02:25 <Gahhh> brandon van every
20:02:29 <Gahhh> avery ?
20:02:43 <blackdog> Gahhh brandon van every indeed. :)
20:02:51 <Gahhh> heh
20:02:52 <cm> yes
20:03:25 <blackdog> has he found another Best Language Evah yet?
20:04:09 <cm> i'm clueless, but he wants to push a shitload of geometry to the graphics card per frame
20:04:19 <cm> and he asks how FP helps him with that
20:05:28 <Gahhh> does FP promise/shows potential for insanely fast machine code generation ?
20:05:55 <cm> i don't recall such a promise
20:06:12 <cm> having seen*
20:06:35 <dons> programmable graphics cards provide map and fold as primitives: http://graphics.stanford.edu/papers/brookgpu/
20:07:00 <cm> this is so last year ;)
20:07:03 <dons> hehe
20:08:38 <Gahhh> looking at gcc's SSA, etc., one might think FP represents greater potential for optimized code, but I dont know for sure.
20:14:21 <Gahhh> would be nice if intel contributed a nice backend for ghc heh
20:16:51 <skew> why do you want to push lots of geometry per frame?
20:17:12 <skew> You are supposed to cache the geometry on the card just like the textures, I thought
20:17:51 <skew> Ah well, some people are just impossible
20:18:21 <skew> what was that quote? "I think the point to draw from this is that even idiots have heard of functional programming"
20:18:23 <Gahhh> I think there's a confusion in the terms used. but definitely a lot of 'stuff' gets pushed to the gfx card
20:19:10 <skew> Hmm, I wonder if Cube could be implemented entirely as a vertex shader
20:25:25 <cm> skew: yup, that's the idea.
20:25:54 <cm> skew: otherwise you'll die a slow performance dead.. unless you work on a platform with unified memory, ofc
20:42:51 <skew> so, the "push a shitload of geometry per frame" is a bad idea to begin with
20:48:00 <cm> ..which was my entire point, duh.
20:55:06 <cm> skew: i obviously agree, and have no idea why you would think i don't :)
21:33:54 <KrispyKringle> So I'm running a recursive algorithm on a graph, and it makes a number of identical recursive calls. Now, I'm assuming those calls aren't being cached in any way (I was thinking maybe Haskell was smart about it, but apparently not) because the running time is sucking. Is there a way to sorta cache these values in some sense? Can someone make some suggestions? Thanks. :)
21:34:37 <Gahhh> optimizations on ?
21:35:11 <dons> can you cache the results with a let?
21:35:12 <KrispyKringle> What do you mean? Optimizations on the algorithm. Basically, I don't want it to rerun for each time the identical call is made.
21:35:34 <KrispyKringle> dons: not really, beacuse some of the calls are deeper into the reccursion the first time than the second time, I'm assuming.
21:35:52 <KrispyKringle> What's going on, in more detail, is this:
21:36:06 <dons> so it's not a number of identical calls? are the values different each time?
21:36:07 <Gahhh> I mean the ghc optimization flags
21:36:07 <KrispyKringle> the algorithm generates a value for a node on the graph based on the value of the nodes it links to.
21:36:27 <KrispyKringle> And I generate values for all nodes in the graph.
21:36:42 <KrispyKringle> thus, for any given node that was connected to a previously computed node, it has also been computed.
21:37:01 <KrispyKringle> But since the call was made previously in the lower call, I can't seem to pass the value lexically back out.
21:37:06 <KrispyKringle> Gahhh: Oh, none.
21:37:15 <KrispyKringle> so dons, in answer to your question, identical values.
21:38:46 <dons> turn on -O, then if it's bad, you need to think about your algorithm
21:39:03 <KrispyKringle> yeah, well, i definitely need to think about my algorithm, but ill try ghc optimizations :P
21:39:37 <dons> there's probably a well-known graph algo out there you can reuse
21:40:01 <KrispyKringle> yeah, i suspect so. i can't remember mucch from when i took a course in this, though.
21:40:13 <KrispyKringle> whoah
21:40:17 <KrispyKringle> -O totally did it
21:40:22 <KrispyKringle> unless I'm using my old test, which I don't think I am.
21:40:27 <KrispyKringle> nope.
21:40:28 <KrispyKringle> spiffy.
21:40:35 <KrispyKringle> took my test down from 8 seconds to .5 seconds.
21:40:45 <Gahhh> Ship it
21:40:48 <KrispyKringle> which is comparable to my faster (wrong) implementation.
21:40:58 <KrispyKringle> thanks, fellas ;)
21:42:56 <KrispyKringle> still a bit slow on the server in the real environment, though. ill try to find a better algorithm.
21:43:10 <Gahhh> do you know how to profile ?
21:43:24 <KrispyKringle> Not in Haskell. I'm a noob/ ;)
21:43:30 <KrispyKringle> I'll go read some docs.
21:43:47 <KrispyKringle> But I mean, I'm fairly certain it's this algo, since I had an old simpler implementation in before and it ran way fast.
21:44:17 <Gahhh> you'll probably follow the ghc team route: profile, eliminate lazy evals, repeat
21:45:44 <KrispyKringle> hmm. in my real test, optimization doesn't seem to do a whole lot.
21:46:32 <yoda-> Hi, I am studying Haskell at university, Can anyone tell me the advantages of it?
21:46:35 <KrispyKringle> oh, crap. i broke my test. -O didn't do what I thought.
21:46:44 <KrispyKringle>  yoda- see the front page of haskell.org ;)
21:46:53 <KrispyKringle> plus, if you did your assignments in perl, the instructor'd fail you.
21:47:05 <yoda-> hehe
21:47:42 <yoda-> I dont know, like writing these assignments is different than any other language that i have seen
21:47:49 <Gahhh> how could you ask a question with a name like yoda ?
21:47:54 <Gahhh> you should tell us !
21:47:59 <yoda-> :)
21:48:23 <KrispyKringle> ok, so in my tiny test, -O makes it about 3s, versus 8s without. So that's a good improvement, but insufficient for my needs.
21:48:43 <KrispyKringle> yoda-: there are many features of haskell that are quite different than what you've likely seen, assuming it's Java/C/C++.
21:49:03 <yoda-> yer
21:49:07 <KrispyKringle> I'm still undecided on what's *better*, and I think it depends largely on the environment, but haskell is interesting, if nothing else.
21:49:26 <yoda-> the way haskell handles "loops" is quite...strange
21:49:29 <KrispyKringle> One really noticable feature is the typing, which can make Haskell both a pain to work with and a language which results in very few compilable bugs.
21:49:32 <heatsink> I'd say it depends larglely on the problem to be sovled.
21:49:38 <KrispyKringle> definitely
21:49:48 <yoda-> Like my university is preaching readability...
21:50:00 <yoda-> can i show u an example
21:50:05 <KrispyKringle> I think Monads are one of the most difficult features, in that they make sorta typical applications that are very IO driven sometimes challenging.
21:50:16 <Gahhh> show it
21:50:18 <KrispyKringle> Yeah, sure, but try not to flood the challenge. rafb.net/paste is a good thing to use.
21:50:25 <KrispyKringle> and by challenge i mean channel.
21:50:26 <yoda-> this is a really simple function
21:50:37 <yoda-> identityMatrix n = [[0 | i <- [1 .. k]] ++ [1] ++ [0 | i <- [1 .. n - k - 1]] | k <- [0 .. n - 1]]
21:51:10 <KrispyKringle> hmm.
21:51:21 <yoda-> is there any way i could make that more readable
21:51:29 <yoda-> cos in my opinion its ... not
21:51:37 <yoda-> readable that is
21:51:44 <Gahhh> it's not about a race on readability per se
21:51:59 <Gahhh> if the definition is mathematically correct, there may not be anything left to do
21:52:14 <yoda-> its correct
21:52:17 <KrispyKringle> So one thing I can do, dons, is pass a list of computed nodes down the recursion tree, so to speak, and at the termination of a recursion, it'll contain the results for all the nodes in a connected graph, at which point I can then do the computations for any other, unreached, unconnected portions.
21:52:37 <heatsink> KrispyKringle: are there any cycles in the graph?
21:52:43 <KrispyKringle> But that still results in some recomputation, since the recursion "forks" at places, resulting in recomputation.
21:52:58 <Gahhh> yoda-: you are a cs major, yes ?
21:52:58 <KrispyKringle> heatsink: yes, but i simply don't follow them. I couldn't think of a more reasonable policy.
21:53:16 <yoda-> Gahhh: yes, just a first year
21:53:30 <KrispyKringle> I need to cogitate some more.
21:53:54 <heatsink> yoda-: You can simplify the inner list comprehensions, since i is not actually used there.
21:54:14 <heatsink> yoda-: look at the definitions of 'take' and 'repeat'
21:54:49 <yoda-> ok
21:55:04 <Gahhh> yoda-: I wouldnt be surprised if you don't see what's special about haskell immediately. Thinking back, I dont recall being fed up with c++ when I was in college. But after a while in the industry, I'm getting somewhat unimpressed by the run of the mill, imperative languages. Haskell captures my interest because of that.
21:57:27 <KrispyKringle> So is it possible to define the results of this whole computation with a list, and evaluate it lazily, using lazy evaluation to cache the results for each node?
21:58:04 <heatsink> should be.
21:58:04 <KrispyKringle> like, can I define a list as being (node, compute(node)) and, as Icompute on a node and need the results of computing on its neighbors, retrieve that value from the list?
21:58:16 <KrispyKringle> Wouldn't that reuslt in the computation only being done once per node, and simply looked up in the list after that?
21:58:27 <KrispyKringle> or am i off my nut?
21:58:36 <heatsink> You probably want a Map isntead of a list
21:58:50 <KrispyKringle> hmm?
21:58:52 <heatsink> yes, it will be one computation per node
21:59:04 <yoda-> are there any nice ide's for haskell under windows?
21:59:24 <KrispyKringle> yoda-: vim or emacs ;)
21:59:34 <yoda-> but nothing that will help debug?
21:59:36 * KrispyKringle is partial to vim, but it's haskell mode is a bit rough on the edges
21:59:46 <Gahhh> I believe there's an eclipse plugin in the works.
21:59:47 <yoda-> cos notepad isnt helping much
21:59:52 <KrispyKringle> hehe
22:00:06 <Gahhh> yoda-: on windows you want to use notepad++ with scintilla controls anyways
22:00:22 <Gahhh> but it doesnt highlight haskell afaik
22:00:35 <yoda-> I am currently using editplus, with a haskell plugin
22:00:37 <yoda-> its not bad
22:00:38 <dons> KrispyKringle: maybe you want: http://www.haskell.org/libraries/#editormodes
22:00:48 <yoda-> does highlighting but doesnt help with errors or ne thing
22:01:28 <KrispyKringle> dons: ah, i think last time i looked there there was only one mode for vim. im using whatever the default is.
22:01:37 <KrispyKringle> its syntax highlighting is fine, but it does no indentation.
22:02:04 <dons> oh, same here. one useful thing is: ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/indent/haskell.vim
22:02:16 <KrispyKringle> sweetness!
22:02:20 <Gahhh> dons: does yi indent haskell?
22:02:21 <dons> sorry, i don't know if that actually works.
22:02:27 <dons> but you could hack on it a bit.
22:02:39 <yoda-> thanks for ur help guys, better get back to labs :)
22:02:53 <dons> KK, this is good:
22:02:53 <dons> set comments=bO:--
22:02:54 <dons> set formatoptions=tcqr
22:03:11 <dons> then you at least get comment prefixes done for you
22:03:16 <dons> Gahhh, not yet.
22:03:19 <KrispyKringle> dons: it requires that haskell.vim you linked to, right?
22:03:36 <dons> the two lines of vimscript don't.
22:03:44 <KrispyKringle> oh
22:04:02 <dons> the indent mode was partially working last time I hacked on it.
22:04:10 <dons> maybe you'd like to play with it if you have some time.
22:04:37 <dons> an alternative would be to pipe expressions through ghc's pretty printer...
22:04:39 <KrispyKringle> i dont know vimscript, but ill take a look.
23:08:32 <hellish> "<!ELEMENT body (#CDATA)>" causes DtdToHaskell to barf while the same with #PCDATA doesn't. Anyone know why?
23:30:14 <Lemmih> Good morning, #Haskell.
23:41:37 <TFK> Good morning indeed!
