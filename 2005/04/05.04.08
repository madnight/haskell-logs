00:00:07 <shapr> yay
00:01:45 <blackdog> @markov
00:01:46 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Sorry, I don't know the command "markov", try "fake_lambdabot: @listcommands"
00:01:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "markov", try "lambdabot: @listcommands"
00:07:17 <blackdog> dons: can you cache state information in lambdabot?
00:29:08 <shapr> hoi Itkovian
00:32:54 <Itkovian> meuning
00:32:58 <Itkovian> hi shapr
00:33:41 <Heffalump> blackdog: what do you mean by cache?
00:33:46 * Itkovian yawns
00:33:49 <Heffalump> modules can keep state information around while it's running
00:33:56 <Heffalump> but I don't think there's yet any mechanism to persist it
00:35:15 * Itkovian starts the moce toward 6.4 
00:35:20 <Itkovian> or rather move
00:36:15 <blackdog> Heffalump: i don't mind if it doesn't persist over restarts of lambdabot. Is the right thing to do to set up a global IO ref and write to that?
00:38:04 * shapr goes to work
00:38:31 * pesco waves after shapr
00:39:13 <Heffalump> blackdog: no, there's a ModuleState thing
00:39:13 <pesco> Greetings, #haskell wobblies.
00:39:34 * pesco waves his arms around in any elaborate manner.
00:39:41 <thou> hi pesco
00:39:47 <pesco> Hi thou.
00:39:49 <Heffalump> take a look at one of the existing modules
00:39:50 <thou> am i a wobbly?
00:39:56 <pesco> Yes!
00:40:01 <Heffalump> wossa wobbly?
00:40:05 * pesco shrugs.
00:40:13 <blackdog> a union member, i believe.
00:40:24 <blackdog> i don't know what they call struct members.
00:41:07 <thou> http://www.google.co.nz/search?q=%22chuck+a+wobbly%22&start=0&start=0&ie=utf-8&oe=utf-8&client=firefox-a&rls=org.mozilla:en-US:official
00:41:37 <blackdog> thou: ... .nz? Art thou the hated kiwi?
00:41:52 <thou> blackdog: for a year or so I am
00:42:08 <thou> living in auckland for a year ("normally" from Colorado, US)
00:42:23 <blackdog> ah, to come so close to paradise and miss
00:42:25 <blackdog> by so little
00:42:30 <pesco> Ah?
00:42:30 <pesco> Guh. *snigger*
00:43:16 <thou> hehe
00:46:44 <Heffalump> blackdog: what's so good about South Island?
00:47:35 <blackdog> an excellent question, and not one i could adequately answer
00:48:34 <blackdog> but really, if you like New Zealanders, wouldn't you go straight to the source and visit Bondi?
00:53:00 <pesco> I'm looking for input on my thoughts about import versioning. I'll write an article about it if it doesn't turn out to be nonsense. So I am maintainer of a module A. Here's what I do. The first release contains modules A and A_1. A_1 is the actual implementation, the 1 significes interface version 1. A reexports A_1 and contains a WARNING pragma saying "Blind import of A_1", so the user can then put the 1 in his source without knowing it beforehand. When
00:53:07 <pesco> Identical: nothing to do.
00:54:14 <pesco> Backwards compatible: Increment version number, move implementation to A_2, let A_1 reexport relevant portions of A_2. Let A reexport A_2 and WARN "Blind import of A_2".
00:54:23 <Khisanth> "Whe Identical"?
00:54:44 <vegai> so, what do you think: http://iki.fi/vegai/darcs/haskell-skeleton/
00:55:00 <Heffalump> I've visited Bondi, it seemed pretty boring.
00:55:17 <blackdog> It is, really. You get an awful lot of backpackers, though.
00:55:22 <pesco> Not compatible: Increment version number, move implementation to A_2, let A reexport A_2 and WARN accordingly. If possibly, implement a compatibliy-wrapper to A_2 in A_1.
00:55:26 <Heffalump> not in June.
00:56:09 <pesco> What do you think? This should not be any annoyance to the user, but gives him the opportunity to explicitly specify which version of a module he's refering to.
00:56:22 <blackdog> true. if you're going to shiver in the rain on the beach, you might as well not have left Blighty in the first place.
00:57:03 <vegai> pesco: hmm, perhaps version checking should be a job for the configuring phase?
00:57:04 <pesco> Thus eliminating a big part of what constitutes bit rot: module interfaces becoming incompatible.
00:57:20 <pesco> vegai: No.
00:57:25 <Itkovian> kosmikus: how can I try and emerge ghc-6.4 without fubaring my 6.2.2 installation?
00:57:37 <vegai> yes, it's obvious you don't think so :)
00:58:07 <Heffalump> it was warmer and drier.
00:58:09 <pesco> vegai: Notice that the specific interface version of a module one's importing is already inherent to the code.
00:58:18 <pesco> I believe it is necessary to be able to specify that.
00:58:33 <pesco> When I write code today, I'd like it to still work in a year.
00:58:42 <Heffalump> we left Heathrow on a cold rainy day and arrived in Sydney and there were no clouds in the sky
00:59:27 <pesco> To ensure that in the face of module evolution, there are only two possibilites: Keep modules backwards-compatible at all times (infeasable!) or keep old versions available and let the user specify which one he's refering to explicitly.
01:00:42 <vegai> yep, I see your point. Seems good
01:01:15 <pesco> vegai: Also the "system" I described above gives me as the implementor of a module freedom to completely throw over the interface with each revision, because I won't break old code (assuming it makes its version dependency explicit).
01:02:07 <pesco> Also, it hugely simplifies the issue of "interface versioning" because it basically _removes_ it. :)
01:02:21 <blackdog> I shan't bitch about sydney winters again - clearly i'm out of my league
01:02:46 <pesco> You notice this requires no extension to the language. Haskell knows nothing about module versions.
01:03:11 <pesco> A_1 and A_2 are different modules.
01:03:41 <pesco> But in this scenario, modules earn a new very comfortable property: They never change!!
01:04:05 <pesco> (Except for plain module A, which is OK, because it warns about it.)
01:05:01 <pesco> A is meant as an initial hook for the human user, so he doesn't need to remember and track every module's version numbers (which would be quite infeasable) while programming.
01:05:41 <pesco> Once a module compiles, all blind references can be replaced. This could be automated.
01:06:13 <pesco> I think I'm very happy with this.
01:06:53 <blackdog> Heffalump: i've just refactored my vixenlove lambdabot plugin, so it's got a command line front end and a lambdabot one. now the module brings in another. however, when lambdabot tries to load the frontend module, there's an unknown symbol error on randomWTreeElt (one of my functions). This worked fine when it was all in one module - any ideas what I might be doing wrong? (all compiles happily, it just won't laod at runtime.)
01:07:05 <pesco> I read an interesting article about the current shape of the programming craft once.
01:08:47 <pesco> I didn't agree with all of it, but the essence I took out of it was the fact that currently, we (as in humankind) seem unable to build the _real_ huge and complex programs because we cannot effectively work locally.
01:09:02 <dons> blackdog: probably you didn't add the dependency in Depends.hs
01:09:09 * boegel waves
01:09:15 <pesco> Hi boegel.
01:09:24 <dons> this can be done by hand, or automagically with 'make dynamic-depends'
01:09:25 <thou> hello, boegel
01:10:01 <blackdog> ah, gotcha. make clean doesn't trigger the need for another make dynamic-depends, then?
01:10:10 <ozone> @pointless \x y -> concat (List.intersperse x y)
01:10:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ((join . (List .)) .) . intersperse
01:10:14 <pesco> I.e. there can't be thousands of programmers chugging away at the same program structure because everything breaks as soon as one dependency breaks.
01:10:26 <dons> make dynamic-depends isn't run automatically, yet. probably in a day or two. it's a bit magic atm.
01:10:26 <ozone> stupid point-free style
01:10:49 <dons> (think about it -- it reimplements hs-plugins' dependency chasing...)
01:11:10 <dons> so, when you add a module, it's a good idea to run 'make dynamic-depends' to update the tree.
01:11:13 <blackdog> Yeah. sorta why i assumed lambdabot was hs-plugins dependent.
01:11:16 <dons> i'll make this automatic soon.
01:11:33 <dons> :)
01:11:55 <dons> I was trying to do it in sed yesterday, but gave up and wrote a parser for ghc --show-iface
01:20:14 <blackdog> dons: make dynamic-depends kills it on mac
01:20:22 <blackdog> /usr/local/lib/ghc-6.2.2/HSposix.o: unknown symbol `___stginit_SystemziPosix_'
01:21:21 <kosmikus> Itkovian: use quickpkg to "save" your ghc-6.2.2 installation
01:21:59 <kosmikus> Itkovian: you cannot currently have both at the same time, but if you create a binary package of both ghc-6.2.2 and then of ghc-6.4, it's pretty fast to switch between the two
01:22:16 <Itkovian> ok
01:27:07 <nlv11757_> ozone i'd define a ($2) for that function
01:27:30 <nlv11757_> uuh (.2)
01:27:36 <nlv11757_> ok im getting coffee
01:28:30 <vegai> pesco: there's the danger that programmers just import A instead of A_n and ignore the warnings
01:28:36 <vegai> but perhaps that's their problem
01:28:56 <pesco> vegai: Yes. Because that's precisely what they're doing now already.
01:29:21 <thou> but at least they could easily switch it later
01:30:01 <vegai> but can you redefine something in A_n+1 that was already defined in A_n without extensions to the language?
01:30:11 <pesco> I think "take the time to put in the numbers and you get eternal compatibility" is a good deal.
01:30:30 <vegai> also, what about those who like to do qualified imports?
01:30:48 <pesco> vegai: Of course, all of those are possible. A_1 and A_2 are just two different modules to the Haskell system.
01:30:49 <jlouis> dons: I have a lot for the SeenModule, but I have to clean it up first. I couple of bugs seems to have snug in. I want to kill them first ;)
01:31:25 <pesco> In fact, I'd advocate the view that they are two different modules (instead of versions of the same one) to _humans_ as well.
01:32:01 <vegai> hmm. Is it somehow a different case from e.g. if I have a=1;a=2 in foo.hs
01:32:27 <vegai> ghc says "Multiple declarations of Main.a"
01:32:33 <dons> blackdog: maybe you need to add the posix depend by hand.
01:33:25 <pesco> vegai: You have a=1 in A_1.hs and a=2 in A_2.hs! A_1.hs:"module A_1 where a=1" and A_2.hs:"module A_2 where a=2"
01:33:42 <thou> pesco: seems like you would eventually wind up with a LOT of modules; but I guess concerns about disk space and download times aren't really a big deal
01:34:06 <dons> jlouis: go for it.
01:34:09 <vegai> pesco: oh, right :-)
01:34:11 <pesco> thou: Especially not if most of the "back" modules are simple reexports of the later versions.
01:35:05 <pesco> A chain will build: A_1 -> A_2 -> A_3 => A_4 -> A_5 => A_6
01:35:13 <nlv11757_> @type join
01:35:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
01:35:23 <thou> pesco: right; it's really like some source code revisioning system
01:35:52 <thou> in a sense
01:36:17 <thou> you pick which version you want to look at, or you pick HEAD and take your chances
01:36:21 <pesco> Where "->" means "module A_x (...) where import module A_x-1" and "=>" means an adaptor module, i.e. "module A_x (...) where import module A_x-1 {- adapter code implementing A_x interface in terms of A_x-1 -}"
01:36:32 <dons> @type Control.Monad.join
01:36:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.join :: forall a (m :: * -> *).
01:36:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       (Monad m) =>
01:36:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                       m (m a) -> m a
01:37:02 <pesco> thou: There is a resemblence there, of course.
01:37:17 <thou> dons: is there a way to ask the bot 'whereis join' or some such?
01:37:17 <dons> pesco, have you looked at the papers on versioning in the context of dynamic linking?
01:37:26 <pesco> dons: No.
01:37:36 <dons> there used to be: @index, but it hasn't been ported to the new bot yet.
01:37:45 <thou> k
01:38:12 <pesco> dons: Maybe the behaviour I've described would (through "modules don't change") solve some of the issues?
01:38:47 <pesco> But you probably want guarantees for dynamic linking?
01:38:53 <^buggler^> Hi, how do I convert a [IO ()] into a single IO ()?
01:39:09 <dons> there's typing guarantees for example, that you need to check dynamically.
01:39:10 <thou> foldM
01:39:12 <Itkovian> kosmikus, I assume that does include the other gear that's been installed in e.g. /usr/lib/ghc-6.2.2?
01:39:21 <dons> but there's also much work on just handling library versions
01:39:26 <Itkovian> anyway, I see nothing of the kind in the tarball
01:39:38 <pesco> dons: Can you give me some pointers?
01:39:41 <^buggler^> thanks thou, is that in the IO library?
01:39:42 <dons> OCaml's dynlink does this, I think.
01:39:44 <^buggler^> wait, I'll check
01:39:47 <dons> let me find my reading list.
01:39:54 <kosmikus> Itkovian: no, it doesn't, that belongs to other packages
01:40:16 <kosmikus> Itkovian: you can quickpkg those as well, of course
01:40:18 <Itkovian> so I quickpkg these too ...
01:40:46 <thou> ^buggler^: i hope that's a good answer - i'm about as green as they come :-)
01:40:47 <dons> pesco: www.cse.unsw.edu.au/~dons/safe.html
01:40:48 <Itkovian> well, I guess portage does not wipe them when I upgrade to 6.4 ...
01:41:09 <dons> that's the reading list on dynamic linking, which contains a lot on static linking and separate compilation (which modules systems encode).
01:42:34 <^buggler^> Can't find it :(
01:42:47 <pesco> dons: Thanks.
01:42:51 <thou> ^buggler^: Monad.foldM
01:43:01 <thou> ^buggler^: but i think it's the wrong func for you :-)
01:43:06 <^buggler^> oh
01:43:22 <thou> maybe you could use mapM (>>)
01:43:37 <^buggler^> mapMM, is this in Monad too?
01:43:39 <^buggler^> mapM
01:43:52 * thou can't test it because he installed CVS version of ghc6.5 and ghci is hosed in it ;-)
01:44:08 <thou> it's in prelude
01:44:40 <thou> but, yes, it's from Monad
01:45:23 <pesco> dons: So, having read or looked at all those papers. Do you think what I've said is worthwhile / a good idea?
01:45:37 <thou> ^buggler^: ah, check out Monad.sequence
01:46:13 <pesco> ^buggler^: sequence is what you want, or sequence_.
01:49:15 <pesco> actually, it's sequence_. sequence would yield [()].
01:50:40 <nlv11757_> is the use of arrows efficient in a Haskell program ?
01:51:05 <pesco> Generally, probably.
01:53:50 <pesco> I'd suspect that the execution speed of your program has little to nothing to do with arrows/no arrows.
01:54:05 <pesco> Are you looking at something specific?
01:54:59 <nlv11757_> well sometimes Haskell doesnt provide enough abstraction over types for certain functions, that can be defined with Arrows. So i was asking myself whether this generic concept of arrows was implemented efficiently
01:55:12 <pesco> nlv11757_: Note that AFRP (/Yampa), one of the big "users" of arrows (I suppose), specifically used them to implement a system for efficient real-time simulation of signal networks, basically.
01:55:28 <pesco> _But_, they initially implemented it without arrows, just the same system.
01:55:36 <pesco> s/system/algorithms/.
01:55:48 <nlv11757_> ok
01:56:00 <nlv11757_> btw is that paper still only in draft version about arrows?
01:56:26 <pesco> nlv11757_: Arrow is a type class! Any specific arrow's implementation will have its own traits.
01:56:42 <pesco> For instance functions are arrows.
01:57:05 <pesco> nlv11757_: I don't know about the paper, I'd have thought it would be long finalised.
01:58:49 <nlv11757_> the final version is in Science of Computer Programming
01:58:56 * pesco shrugs.
01:59:35 <pesco> I think I've read the paper _quite_ long ago, actually.
02:00:03 <nlv11757_> the downloadable pdf is from 98
02:00:03 <pesco> And I got it online. Either I've read the draft you mention, or the final is online, too.
02:00:22 <pesco> Either way, it seems to have been well sufficient.
02:01:12 <nlv11757_> yeah, citeseer also has the so called draft version so it seems
02:01:26 <pesco> The current Arrow library is documented well in the GHC docs, and if you want to see a real example, the AFRP module is not long, and really interesting.
02:01:43 <pesco> (For some definition of "well" in the above...)
02:02:21 <pesco> nlv11757_: Probably, the draft is not much different from the final. It won't end up teaching you Monads instead. ;-)
02:03:09 <pesco> I've read pretty much all of module AFRP in what, a couple of hours? I think so.
02:03:39 <pesco> I wanted to make a small extension, and ended up reading all the relevant code. ;)
02:03:43 <nlv11757_> ow the arrows website also states the differences with the final version. They are VERY minimal
02:03:47 <nlv11757_> hehehe
02:03:54 <sethk> Are nomads the reproductive organs of Haskell?  After all, something does go in and something else usually comes out... ok, kind of lame, but it is 5 AM.
02:05:03 <thou> sethk: lol
02:05:04 <nlv11757_> you refer to monads i guess
02:05:50 <sethk> nlv11757_, yes, the last conversation was about monads.  I was watching it and just couldn't restrain myself...
02:05:50 <nlv11757_> hheheh hey sethk, in that case....what are functions?? cause sometimes more than one thing goes in
02:06:14 <pesco> sethk: Actually, no. Monads are Haskell's eyes, mouths, and tentacles. Arrows are the digestive tract, and functions the rest of the organs.
02:06:31 <sethk> nlv11757_, You'll have to consult a Mormon about that.  (Hope there aren't any here; just a joke, guys.)
02:07:08 <nlv11757_> accurate comparison pesco
02:07:23 * pesco waves his arms about in an elaborate manner.
02:07:34 <sethk> pesco, no, no, you wave your _hands_.  :)
02:07:47 <pesco> theorbtwo: Are you an object request broker, by any chance? :-P
02:07:58 <nlv11757_> no....i think pesco is actually waving its arms as far as i can see
02:08:01 <pesco> sethk: No, I'm waving my _arms_. :)
02:08:12 <pesco> See?
02:08:19 * pesco waves his arms about in an elaborate manner.
02:08:37 <sethk> pesco, you'll never get into the ACMHW that way.
02:09:23 <pesco> ACMHW? Is that the ACM's hardware division?
02:09:29 <^buggler^> Thanks everyone for the help, sequence_ was what I was after
02:10:02 <thou> it's alright
02:10:39 <sethk> pesco, no, handwaver division.  Hand waver is a common slang for bullshit artist.
02:11:07 <pesco> Aha, I see. Good thing I'm not a hand waver then.
02:12:33 <sethk> pesco, yes.  Arm wavers are definitely more respectable.  In NY, almost everyone is an arm waver.  :)
02:12:42 <pesco> :)
02:20:18 <pesco> Hah, fun! I accidently found out what a Kleisli arrow is yesterday (while writing some program on paper).
02:24:32 <sethk> pesco, well, tell us, then.
02:25:01 <Itkovian> yeah, enlighten us.
02:25:33 <pesco> sethk: For any Monad m,  a -> m b  is a Kleisli arrow, AFAICS.
02:26:12 <dons> that rings a bell
02:26:22 <pesco> The right side of the monad bind.
02:26:24 <musasabi> dons: ping.
02:26:28 <sethk> pesco, ok, but I don't see how that is much different from any other function.  What's the concept?
02:26:40 <dons> musasabi: ping
02:26:54 <dons> for some reason your patch didn't apply directly, btw
02:26:55 <pesco> sethk: It's just a name for that thing. And it happens to be an arrow.
02:27:11 <musasabi> dons: I think it was the config.mk.in then.
02:27:22 <dons> ok. I just merged it by hand.
02:27:24 <musasabi> What kind of changes are you planing in the near future to lambdabot.
02:27:45 <pesco> sethk: I stumbled across it, because I was building an arrow parameterised over another arrow.
02:27:48 * musasabi would be interested in working on it, but doesn't want to do difficult/hard to merge things.
02:28:04 <dons> ok. there's the TODO list
02:28:22 <dons> persitent @karam would be a good little job
02:28:36 <dons>  @karma, I mean
02:28:53 <dons> on a larger scale, a general framework for persistent state automagiically would be really cool
02:28:53 <pesco> sethk: I knew that, for instance, a -> IO b is an arrow (or rather, (Lambda a b. a -> IO b is).
02:29:11 <musasabi> I could do something on the persistence side..
02:29:15 <dons> yeah ;)
02:29:48 <musasabi> Have you thought about moving all the modules under a subdir?
02:30:15 <pesco> sethk: So, I needed to look at a specific instance of my presumed arrow, for that -> IO thing as its arrow parameter. Because you can't write (-> IO) or (-> . IO) or (Lambda a b. a -> IO b) as a type constructor, I needed a seperate name for it.
02:30:45 <dons> musasabi: yep .  i've called that job, as it's more build system hacking
02:30:55 <sethk> pesco, separate, not seperate.  I think I get the idea.
02:31:06 <dons> atm i'm solving dependency calculation once and for all, then partitioning the core and the plugins.
02:31:14 <pesco> Which I found as  newtype Kleisli m a b = Kleisli (a -> m b).
02:31:29 <musasabi> sounds nice :-)
02:32:11 <dons> re. persistence, I'd like to have the state component of (class Module m s | m -> s where), the 's', derive Binary/Serialisable
02:32:23 <pesco> sethk: wrt. separate, indeed. Thanks for the heads-up.
02:32:53 <dons> then we'd have typechecked persistence for modules using state.
02:33:12 <dons> which would requrie either SerTH or DrIFT/Binary for deriving the get/put functions
02:33:16 <sethk> pesco, one of the most common spelling mistakes of native english speakers.  Mostly because they also pronounce it incorrectly.  As I tell my kids ...   :)
02:34:00 <musasabi> dons: Making serialization an option could be better as not all modules will want it.
02:34:22 <dons> yeah, sure.
02:34:29 <dons> if state /= () for example :)
02:35:15 <dons> anyway, that's a medium sized project with a good design component, so any input youu provided there would be welcome :)
02:35:22 <dons> something to hack on right now, let me see..
02:36:49 <dons> oh, I'd like @google to also provide @google+ which returns @more matches from www.google.com/ie.
02:36:55 <dons> that'd be fairly quick.
02:37:51 <dons> otherwise, feel free to pick something and hack on it. just refactoring code is useful. also, documenting code with haddocks.
02:38:09 <musasabi> hmm, ok..
02:38:20 <musasabi> I'll send something your way later tonight.
02:38:24 <pesco> dons: But here's a challenge: Make it provide @gooogle for the 2nd set of results, @goooogle for the 3rd, and so on, for an arbitrary number of extra o's.
02:38:41 <dons> @google+ n
02:38:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "google+", try "lambdabot: @listcommands"
02:38:56 <dons>  @google+ n-m
02:38:58 <dons> etc.
02:39:34 <dons> arbitrary doesn't matter so much in the bot, it can have a limit of 10 without hurting anyone.
02:40:06 <pesco> True, it's a coding challenge, not a feature request.
02:40:09 <dons> just being able to index the top 5 urls would be useful
02:40:16 <dons> ok :)
02:46:20 <musasabi> btw is Text.Printf fair game for lambdabot code - or should I use 6.2 compatible things?
02:46:48 <dons> needs to run on 6.2.2
02:52:02 <Itkovian> what;s the difference between the Cabal included with ghc-6.4 (version 1.0?) and the one fetched from darcs (version 0.6) ?
02:53:47 <wilx`> Four tenths.
02:56:31 <nlv11757_> whats the alternative if i want to derive an instance of some class PP for all Nums
02:56:41 <nlv11757_> instance (Num a) => PP a where  ... is not gonna work
02:56:57 <Itkovian> Hmm ...
02:59:03 <wilx> Huh.
02:59:08 <wilx> Why is it not going to work?
03:01:36 <wilx> Hmm....
03:02:33 <wilx> No lightning bolts but I think that I finally know what shaper meant.
03:02:43 <wilx> ...after like two weeks...
03:02:50 <Cale> what did he say?
03:03:23 <wilx> I was asking how to do stream transformation.
03:03:36 <nlv11757_> its not going to work because it is not allowed wilx
03:03:38 <wilx> And today I realized it is similar to shows/ShowS.
03:06:23 <Cale> nlv11757_: it's not?
03:07:28 <Cale> ah
03:07:56 <Cale> yeah, you need a type constructor
03:13:57 <musasabi> Is there a reason diffClockTimes works in a weird fashion?
03:14:23 <musasabi> diffClockTimes t1 t0 => TimeDiff {tdYear = 0, tdMonth = 0, tdDay = 0, tdHour = 0, tdMin = 0, tdSec = 128, tdPicosec = -571947000000}
03:15:11 <musasabi> or should one just allways normalize them?
03:16:11 <basti_> hmm why is this wild?
03:16:26 <basti_> i think 1e12 ps = 1 s isnt it?
03:17:10 <theorbtwo> Yep.
03:17:16 <basti_> so it is normal
03:17:25 <musasabi> I was thinking it should have returned an usable value, now normalizing them.
03:19:24 <JaffaCake> musasabi: TimeDiff is fundamentally  broken anyway, I wouldn't use it
03:21:31 <musasabi> What is the preferred way?
03:22:00 * basti_ thinks, even the HP41c i was working on had a functioning time arithmetic 
03:23:15 <Arsilan> Haløjsa DAvid
03:24:33 <JaffaCake> musasabi: the representation of ClockTime is visible, you can use that
03:25:16 <JaffaCake> there's a new Time library in progress... it might be useable now
03:25:20 * JaffaCake goes to look up the link
03:25:59 <JaffaCake> darcs get "http://semantic.org/TimeLib/"
03:28:36 <basti_> dons: are you there?
03:28:51 <Arsilan> Davfid er di de
03:28:59 <Arsilan> David er du der
03:29:07 <basti_> uh?
03:29:21 <musasabi> JaffaCake: thanks.
03:29:32 <JaffaCake> np
03:33:24 <Arsilan> THis Scryt are wired: HIKTU ALUMSI FKFTLBBBABABABA #¤##nBHSNKsKS
03:33:41 <Arsilan> Do anyone no what it means
03:34:09 <basti_> Arsilan: uhm I'm not sure you are on topic here ;)
03:34:39 <lightstep> what's a scryt?
03:34:40 <Arsilan> Nop what  are your topic
03:35:10 <pesco> Nop?
03:35:18 <basti_> it is haskell.
03:35:24 <Arsilan> I meant, Scrypt
03:35:24 <lightstep> Haskell is the language of choice for discriminating hackers!
03:35:26 <basti_> a functional programming language
03:37:08 <lightstep> if i'm threading an array through a bunch of function, is ghc -O2 smart enough to change it in place, or should i use STArray?
03:37:23 <lightstep> s/change/modify/
03:45:44 <pesco> Is the hackage module not yet in lambdabot?
03:59:49 <Lemmih> pesco: Nope.
03:59:57 <pesco> :(
04:00:24 <nlv11757_> im sorry for asking this question twice, but maybe now people know what i am doing wrong
04:00:39 <nlv11757_> i want a kind of 'instance of (Num a) => PP a where ....'
04:00:42 <pesco> Quick darcs question: How do I display the list of patches making up my repository?
04:00:44 <nlv11757_> is that possible?
04:01:15 <pesco> Ah, darcs changes -s
04:01:44 <Lemmih> nlv11757_: Maybe with the right amount of extensions.
04:02:03 <nlv11757_> can you elaborate on that Lemmih?
04:03:29 <Lemmih> nlv11757_: Use AllowUndecidableInstances.
04:03:55 <nlv11757_> ow, that simple?
04:04:22 <Lemmih> Yeah.
04:05:20 <nlv11757_> nice
04:05:22 <nlv11757_> thanks
04:06:39 <nlv11757_> but won't it complain about the fact that there's no Type constructor at the place where now the 'a' is in PP a ?
04:08:32 <Lemmih> Fix that with a '-fglasgow-exts'.
04:10:09 <nlv11757_> aw damn, im opening up a can of overlapping instances here hehehe
04:17:32 <nlv11757_> hehe let me guess...use -fallow-overlapping-instances :P
04:32:29 <pesco> WHAT!? I just waded through 57 changes in a darcs revert and answering "Yes." to "Do you really want to do this?" makes it abort! This is outrageous.
04:32:54 <tromp> demand your money back!
04:33:42 <Oejet> Claim your warranty!
04:34:35 <pesco> I'm pushing a patch for this. Up David Roundy's rear! ;)
04:34:51 <tromp> patch? you've found the bug alrd?
04:35:27 <pesco> Er, no, I'm just going to hardcode "Yes." as a positive answer.
04:35:58 <tromp> oh, i see
04:36:11 <tromp> it doesn't grok the . after Yes ?
04:36:25 <pesco> Probably.
04:36:42 <tromp> if it doesn't recognize a yes or no it shld repeat the question
04:36:57 <pesco> Yes! Why didn't I think of that.
04:37:09 <pesco> This makes it an even better patch. Thanks!
04:38:51 <pesco> Wah! "yorn <- askUser 'Do you really...'; case yorn of ('y':_) -> ...; _ -> exitWith..."
04:39:23 <pesco> Damn, I don't have time for this, I must fix my _own_ code!
04:39:28 <tromp> so what if user answers "Yikes, no!" :)
04:39:34 <pesco> *grmblmbl*
04:40:15 <pesco> Or "You fucking bastard, take your filthy hands off my code, what the HELL were you THINKING?!"
04:40:33 <pesco> These are serious issues.
04:40:49 <theorbtwo> Or what if they enter "ja".
04:40:56 <theorbtwo> This is a somewhat more serious issue.
04:41:32 * Igloo thinks none of these are serious issues, but that it should ask again (telling you acceptable inputs) if you don't say y|yes|n|no case insensitively
04:41:33 <pesco> Well, darcs speaks English, so I wouldn't expect it to understand German.
04:42:14 * Itkovian sighs
04:42:18 * Itkovian is fiddling with Jikes RVM build scripts ...
04:42:22 <pesco> Igloo: My example is a serious issue to ME, I _routinely_ answer "You fucking..." to such questions.
04:42:48 <pesco> And I'll FIX it! ;)
04:42:52 <Itkovian> pesco: Well now ... I hope never to touch your code unasked then
04:43:09 <Igloo> Sounds like a serious bug in pesco and a normal bug in darcs to me  :-)
04:43:40 <pesco> Itkovian: Oh, I'm sorry, I only give such rude replies to machines!
04:44:35 <Itkovian> Ah, well, that's a relief ... (+1 point larry)
04:45:01 <pesco> Larry?
04:49:44 <Itkovian> Leisure Suit Larry.
04:49:54 <Itkovian> You get one extra point if you relieve yourself
04:49:58 <Itkovian> on the toiler
04:49:59 <Itkovian> toilet
04:50:59 <pesco> Ah, I remember!
04:51:14 <pesco> I didn't pay so much attention to the points.
04:53:42 <Itkovian> bloody bash
04:53:59 <Itkovian> Well, you might have earned more
04:54:23 <Itkovian> I can't seem to recall if flushing was required or if it drowned you
04:54:53 <Itkovian> I need a 5 1/4 " reader to get those games to modern storage
04:55:35 <theorbtwo> Hm, thinking in terms of flash storage?
04:55:42 <theorbtwo> 5 1/4" floppy drive.
04:55:48 <nlv11757_> surely emulator is possible
04:56:04 <theorbtwo> You can download most old games pretty easily anyway.
04:56:23 <pesco> Itkovian: Do you know homeoftheunderdogs.com (was that the name?)
04:56:54 <Itkovian> nope.
04:57:15 <pesco> Website archiving classic computer games. Ask Google about it.
04:57:20 <pesco> You can find wonderous stuff there.
04:58:31 <nlv11757_> its all abandonwarez now
04:59:11 <nlv11757_> using that searchword on google will get you anything (and legal)
05:00:28 <theorbtwo> Careful; not everyone who says that it's legal is correct.
05:00:32 <theorbtwo> In fact, most of them are wrong.
05:00:54 <Itkovian> that home... thing is about gambling :-(
05:01:54 <theorbtwo> If you can prove that you have a legal copy, downloading it is probably OK.
05:02:04 <theorbtwo> (IE you have floppies of the exact same game, but can't read them.)
05:02:08 <Itkovian> a hwta copy?
05:02:11 <Itkovian> what copy?
05:02:13 <Itkovian> legal?
05:02:34 <Itkovian> as if I had legal games when I was 12 years old ... ok, a few ...
05:02:39 <basti_> afaik, "abandonware" is the term for programs legally and officially freed of their copyright.
05:02:39 <theorbtwo> OTOH, you may simply not care if it's legal or not.
05:02:52 <Itkovian> I do care, now that I make money
05:03:01 <pesco> Itkovian: http://www.the-underdogs.org/
05:03:06 <theorbtwo> No, basti, that'd be public domain software.  (Another term that is often abused.)
05:03:48 <basti_> okay.
05:04:00 <theorbtwo> Even if software is no longer available for purchase does not mean that it's no longer under copyright.  There's no software that's old enough to have it's copyright expire; absent that the only way for it to not be under copyright is if they explicitly give up the copyright, in writing.
05:04:36 <basti_> in germany, copyright is kept 70 years after the author's death iirc.
05:04:46 <Itkovian> I guess I ought to have promoted the files to newer media
05:04:52 <basti_> :)
05:05:05 <Itkovian> They're prolly lying around on my 40MB Harddisk inside that old Philips XT
05:05:22 <Itkovian> s/old/ancient/
05:08:23 <theorbtwo> I really think that the abandonware concept ought to be put into law: Copyrights granted from this point forward should be subject to a fee to retain them, with a maximum retention time.
05:08:31 <theorbtwo> (See Lessig.)
05:10:46 <nlv11757_> is it inefficient to pass large records through functions?
05:11:05 <nlv11757_> large records are in my case maybe 20 fields in it?
05:11:20 <nlv11757_> of which these fields are mostly basic types
05:12:05 <Itkovian> pesco:thx.
05:13:14 <nlv11757_> theorbtwo, abandonware IS stuff that IS no longer under copyright....
05:14:16 <blackdog> isn't abandonware just any software you can no longer buy?
05:14:20 <nlv11757_> no
05:14:23 <smott> yes
05:14:33 <nlv11757_> its stuff that is free of copyright
05:14:37 <blackdog> I've seen abandonware sites that have been taken down because the owners complained...
05:14:40 <nlv11757_> which is mostly stuff that cant be bought anymore
05:14:44 <smott> nlv11757_: negative
05:14:51 <pesco> Maybe we should agree that it's stuff that has been abandoned.
05:14:51 <nlv11757_> then they are misusing the concept abandonware
05:14:55 <theorbtwo> In that case, point me at a piece of abandonware, and show me what makes it out of copyright?
05:15:31 <blackdog> From Wikipedia, the free encyclopedia.
05:15:32 <blackdog> Abandonware is computer software which is no longer being sold or supported by its copyright holder. Alternately, the term is also used for software which is still available, but on which further support and development has been deliberately discontinued.
05:16:03 <nlv11757_> i disagree with wikipedia
05:16:27 <smott> there is no software that is old enough to have its copyright expire
05:16:31 <blackdog> words, words, words. :)
05:17:04 <blackdog> it's all just definitions, but if you're going to use commonly used terms in a strange way, you're going to have to keep explaining yourself...
05:17:31 <Darius> nlv11757_: Everything is passed by reference in Haskell (at least that's how all current implementations work)
05:17:38 * Igloo has never heard abandonware used the way nlv11757_ uses it, nor does it make much sense to me to use it that way
05:18:12 <Igloo> Darius: That's not strictly true, with things like unboxed ints
05:20:38 <Darius> Igloo: I know, but decided not to complicate the picture
05:22:28 <Darius> Though I guess it may be an issue if a fully unboxed record is passed by value.
05:23:08 <Darius> I wrote a VM in Haskell once and when I {-# UNPACK #-}ed the fields holding the state it slowed down signficantly.
05:23:45 <Darius> Of course, that was probably more likely due to updating the state record.
05:25:37 <pesco> nlv11757_: When a copyright expires, the work reverts to the public domain. (According to Wikipedia)
05:26:40 <theorbtwo> The public domain, by definition, is all works that are not under copyright, and only those works.
05:26:53 <pesco> Yes.
05:29:39 <Arsilan> have som of you ever cinsidered to use hotmail
05:37:46 <blackdog> @seen dons
05:37:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons is in #haskell. Last spoke 2 hours 50 minutes 58 seconds ago.
05:56:02 <Darius> Hey autrijus, did you ever see Haskerl?
05:56:22 <autrijus> no.
05:56:26 <xerox> Erlang bindings?
05:56:38 <autrijus> oh, apr 1?
05:56:38 <autrijus> yes
05:58:48 <Darius> xerox: http://www.dcs.gla.ac.uk/~partain/haskerl.html
05:59:31 <xerox> Thanks.
06:00:21 <lightstep> i pasted an example that causes a type error in the paste page. can you help me with the problem?
06:00:38 <lightstep> it complains runST isn't polymorphic enough
06:01:24 * Darius idly wonders if anyone has been using @paste
06:01:37 <lightstep> @paste
06:01:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
06:01:43 <theorbtwo> It was yummy.
06:02:04 <lightstep> well, everyone knows where the page is, don't they?
06:02:19 <musasabi> except newbies.
06:02:25 <Darius> runST has a rank-2 type, use parens instead of (.) and ($)
06:02:44 <Darius> lightstep: It's mostly to quickly provide a clickable link when someone needs it.
06:02:56 <musasabi> Same as with @wiki.
06:02:58 <Darius> @wiki HaskellIrcPastePage does the same thing but takes more typing.
06:03:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage does the same thing but
06:03:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- takes more typing.
06:03:26 * Igloo never remembers where it is
06:04:05 <lightstep> can't ($) and (.) be given a more polymorphic type?
06:04:06 <pesco> Why, thanks lambdabot, for pointing that out!
06:04:17 <pesco> He's such a smart-ass.
06:04:18 <xerox> ahah.
06:06:16 <Darius> lightstep: If Haskell's type system were impredicative.
06:07:28 <Darius> (though ($) and (.) would actually still have the same type it'd just be used in a different way)
06:08:34 <lightstep> i don't understand higher-ranked types, but it seems that if the inferencer would juggle the foralls a little, it'll be solvable
06:10:41 <Darius> lightstep: The necessary "juggling" is what an impredicative type system would allow.
06:12:55 <Darius> lightstep: If I understand correctly, the problem is that in a predicative type system you can't instantiate a polymorphic type to a polymorphic type, i.e. id :: forall a. a -> a can't be instantiated to id :: (forall a. a -> a) -> (forall b. b -> b)
06:14:29 <lightstep> @plugs id id id 4
06:14:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
06:14:56 <Darius> lightstep: That's not a problem because it can fix id's type to a monomorphic type.
06:14:58 <lightstep> @plugs let f = id id in f 4
06:14:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 4
06:15:07 <lightstep> @plugs let f = id id in (f 4, f True)
06:15:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (4,True)
06:15:25 <xerox> @type id
06:15:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- id :: forall a. a -> a
06:15:36 <Darius> @type id :: (forall a. a -> a) -> (forall b. b -> b)
06:15:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- id :: (forall a. a -> a) -> (forall b. b -> b) :: forall b.
06:15:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                   (forall a. a -> a) ->
06:15:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- b -> b
06:17:16 * lightstep goes babysitting
06:17:23 <Darius> @type (id :: (forall a. a->a)->(forall b.b->b)) id
06:17:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (id :: (forall a. a->a)->(forall b.b->b)) id :: forall b. b -> b
06:18:41 <Darius> @type Control.Monad.ST.runST
06:18:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.ST.runST :: forall a. (forall s. GHC.ST.ST s a) -> a
06:20:55 <nibro> any cabal gurus around?
06:21:31 <nibro> if so, what's the Extension flag to give for pattern guards?
06:23:38 <dons> nibro, quick look in Cabal/Distribution/Extension.hs doesn't show a specific flag for pattern guards :/
06:24:04 <dons> maybe guards are "standard" :)
06:24:05 <JaffaCake> looks like we should add one
06:32:14 <Darius> CosmicRay: I was just reading the laziness, tail recursion, etc post on sequence and just thought a "wiki trail" might be useful.  I.e. a page that contains links to other wiki pages in some kind of mostly linear order so newbies would know where to start and where to go next, etc.
06:32:22 <nibro> dons: that was my assessment too ;)
06:32:35 <nibro> JaffaCake: might be a good idea :)
06:33:01 <nibro> dons: I found an ugly bug in your Makefiles
06:34:30 <dons> :) yeah?
06:34:41 <dons> hs-plugins, or something else?
06:35:19 <nibro> hs-plugins. when you cpp the $(PKG).conf.in.cpp files you say -Uunix
06:35:28 <nibro> I'd say -undef would be a better choice
06:35:51 <dons> much better, yes.
06:35:59 <dons> not a bug so much though?
06:36:01 <nibro> then I won't have to wonder why my libdir /..../linux ends up as /..../1 :)
06:36:08 <dons> ah!
06:36:27 <nibro> small bug, but it was a mess to find... ;)
06:36:41 <dons> yeah, it took me a while to work out the unix=1 problem too
06:37:05 <dons> I assume this is a general problem for people cpping cabal package files
06:37:06 <nibro> aye, I suspected you'd had the same problem since you gave that flag
06:37:18 <dons> yeah. i'll put -undef in now.
06:38:26 <nibro> I use a different approach, I have a separate file $(PKG).cabal and let the configure script choose the correct suffix for me
06:38:37 <nibro> then I don't need cpp
06:38:45 <dons> ok. that's a nice approach.
06:40:50 <dons> done. should make it into tonight's snapshot
06:41:24 <nibro> sweet :)
06:43:07 <CosmicRay> Darius: that's a good idea
06:43:18 <nibro> regarding the src-exts stuff, I was thinking I'd release it to the wider audience as a stand-alone package
06:43:22 <musasabi> A small problem with fundeps http://youzen.b2.fi/~musasabi/s.hs - why is this not correctly inferred?
06:43:32 <CosmicRay> Darius: feel free to implement it :-)
06:43:54 <nibro> which means that all you really need to do is to add a dependency to it, and change those three imports
06:44:54 <nibro> then people can dl it from me directly and you don't need to keep up with my releases at all
06:45:13 <nibro> (... as long as I don't break anything... ;)
06:46:25 <dons> yeah. that's a good idea.
06:47:13 <dons> i want to make sure it's easy to install hs-plugins. so depends on how easy it is, maybe importing it for you occasionally is not so bad.
06:48:29 <Darius> musasabi: Why is the written type for writeDiskMS not inferred?
06:48:49 <seb__> dons: hi! I am trying to use hs-plugins (2005-04-08) on MacOS X with ghc 6.4, and some of the examples (e.g., examples/eval/eval2) fail with an error (for instance, unknown symbol `_GHCziUnicode_toUpper_closure')... any idea why / what I should investigate first?
06:49:20 <musasabi> Darius: attached to whole error message there.
06:49:29 <dons> yeah. I don't know what's going on here yet. 6.2.2 seems to work fine.
06:49:47 <dons> seb__: but i'm aware of it.
06:50:19 <musasabi> hmm I think I understand why :-)
06:50:52 <nibro> dons: installing the src-exts package is really easy, at least with 6.4 since it's now fully cabalilized :)
06:51:33 <nibro> installing it for earlier versions shouldn't be simple, but requires make
06:52:51 <seb__> dons: ok, thanks!  I may find time to have a look at it, I'll let you know if I find something interesting.
06:52:52 <Darius> musasabi: The problem is definitely that to/fromPersistent in no way specifies m, whether it could be/is sensible to make such examples work is a question though.
06:54:13 <seb__> by the way, is there a version of hws-wp out there that uses hs-plugins already?
06:55:02 <dons> I have heard rumours of a couple of people hacking on it, but don't know what the results have been
06:55:55 <dons> actually, Peter Thiemann (Mr. WASH) hacked up a binding a few weeks ago. don't know if he made if public though.
06:56:12 <seb__> hmm
06:56:24 <Itkovian> gotta go
06:56:25 <Itkovian> ttyl
06:57:28 <seb__> Peter is giving a talk at ESOP this afternoon, I'll try to catch him :-)
06:58:05 <dons> :)
06:59:16 <seb__> I need to go too, ttyl
06:59:18 <boegel> @seen tromp
06:59:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- tromp is in #haskell. Last spoke 2 hours 19 minutes 49 seconds ago.
07:01:26 <Lunar^> that was the co-author of hOp, btw
07:01:55 * Darius was wondering if that was -that- sebc.
07:02:04 <Lunar^> Darius: himself :)
07:02:27 <Lunar^> might be his first time here
07:02:36 <Darius> Actually, I did a whois but never got around to looking at the result.
07:02:46 <dons> ah!
07:02:56 <Darius> Lunar^: He's been around a few times before at least.
07:03:13 <Lunar^> Darius: yes, I remember now
07:10:41 <dons> 200 lambdabot patches!
07:12:00 <xerox> Oh my.. :-)
07:12:01 <Darius> Yeah, I'm wasn't able to pull for a couple of days and had 78 patches coming in, then pulling yesterday had like 35, and today had a bunch but I forget how many
07:12:23 * Darius isn't even sure what all is changed now.
07:12:58 <Darius> @listmodules
07:12:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Modules: babel base dice dict dummy dynamic eval google help karma more
07:12:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pl plugs quote seen state system topic type version
07:13:20 <boegel> @google haskell
07:13:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/
07:13:27 <Darius> The #perl6 people probably wouldn't mind a @pugs
07:13:40 <Darius> @help google
07:13:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- search google and show url of first hit
07:13:45 <Darius> @listcommands google
07:13:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Module google provides the following commands: ["google"]
07:13:59 <boegel> can someone explain shortly what Pugs is ? I've heard a lot about it...
07:14:19 <Darius> boegel: A Perl 6 interpreter/compiler written very quickly in Haskell
07:14:28 <theorbtwo> boegel, pugs is an implementation of perl 6, written in haskell.
07:14:34 <dons>  Darius, I dicussed with autrijus how to implement @pugs via @plugs, such that the type remained pure. seems possible
07:14:37 <Darius> boegel: It's the first real and only implementation of Perl 6
07:14:41 <boegel> Darius: and what's so special about it ?
07:14:44 <boegel> oh, I see
07:14:54 <boegel> nice :) Haskell wins popularity
07:15:21 <Darius> boegel: Haven't you noticed all the perl people running around of late?
07:15:22 <dons> who knows what unsafe magic they can do in perl though - not me, so I won't be running @pugs on my box :}
07:15:33 * theorbtwo wonders if now is a good time to ask a pugs-related haskell question about hs-plugins.
07:15:37 <Darius> boegel: Also, autrijus' journal is enjoyable to read.
07:15:39 <dcoutts> the point being that you can help prototype and provide feedback on the deisgn of perl 6?
07:15:52 <dons> theorbtwo: yeah?
07:16:20 <pesco> Make no mistake, the situation is very delicate. We must still ensure to avoid success.
07:16:29 <boegel> Darius: where can I find it ? Is autrijus the developper of Pugs ?
07:16:32 <pesco> ;)
07:16:33 <theorbtwo> One of the points.  The other point is that perl6 is a useful-looking language, and it'd be nice if it took less then 10 years to get a working implementation of it.
07:16:48 <theorbtwo> boegel: it's autrijus' project, but we have lots of committers.
07:16:55 <theorbtwo> #perl6 is the channel.
07:17:21 <theorbtwo> dons: I can't get it to install.  Rather, I built it, did make install and make register... and it kept pugs from compiling at all.
07:17:42 <Darius> http://use.perl.org/~autrijus/journal
07:17:49 <dons> theorbtwo: any error msg?
07:17:54 <boegel> Darius: thanks
07:18:04 <theorbtwo> Hold on a second, let me get back to that state.
07:18:52 <pesco> I'd like to see Pugs run the first Perl 6 compiler.
07:19:15 <theorbtwo> pesco: It already is.  It's just incomplete.
07:19:24 <theorbtwo> Er, does, rather.
07:19:38 <boegel> I know a guy who's very much into Perl... I'll ask what he thinks of Pugs
07:19:39 <Darius> pesco: It's looking like Pugs will be the bootstrap compiler
07:19:49 <pesco> theorbtwo: There is a Perl 6 compiler? I didn't know.
07:20:51 <Darius> pesco: Do you mean "Perl 6 compiler" as in Perl 6 compiler written in Perl 6 or just a Perl 6 compiler.  Pugs is a compiler.
07:21:14 <theorbtwo> There we are: I get a bunch of src/Run.hs errors that things from Eval are not in scope, where Run imports Eval.
07:21:24 <pesco> I thought Pugs was an interpreter?!
07:21:34 <theorbtwo> pesco: It's both.
07:21:34 <Darius> pesco: It was.
07:21:45 <xerox> pesco, afaik it compiles to multiple backend "languages".
07:21:55 <theorbtwo> There's a pugscc script, which uses it as a compiler, at least for some definitions.
07:22:09 <boegel> the guy I know says Pugs will probably have it's drawbacks, because Perl is quite hard to interpret
07:22:26 <pesco> Wow. What does it currently compile to as backends?
07:22:43 <xerox> Template Haskell and some other think I don't know, if I remember correctly.
07:22:57 <dons> theorbtwo, not sure. possibly due to package conflicts between Eval.* in hs-plugins (badly chosen namespace) and any Eval.hs inside pugs. For now you could work around it with -ignore-package eval-0.9.8
07:23:16 <theorbtwo> OK, I shouldn't need eval.
07:23:21 <Darius> pesco: Haskell and Parrot at least as well as just sticking the AST with the evaluator.
07:23:47 <theorbtwo> Will it ignore that flag if there is no such package?
07:24:13 <theorbtwo> Is the CVS of hs-plugins public?
07:24:21 <dons> boegel: why is perl hard to interpret? doesn't seem like it would be - other than there being a lack of a formal spec. also can't be too hard, considering the speed in which pugs was whipped up.
07:24:49 <dons> theorbtwo: re the flag, not sure. cvs isn't public. nightly snapshots are. i'll move to darcs soon though
07:25:00 <boegel> does it interpret the full perl6 specification ?
07:25:09 <theorbtwo> dons: p6 has a semiformal spec, but it's incomplete and still being worked out.
07:25:15 <theorbtwo> No, boegel, but we're working on it.
07:26:00 <dons> ok. yeah, I knew there was a semiformal spec for p6. but nothing like ML's, for example.
07:26:22 <theorbtwo> Or even haskell's.
07:26:26 <lightstep> the semiformal spec is still in the draft stage
07:26:40 <dons> ok. better than p5, right :)
07:26:47 <lightstep> yes
07:29:24 <dons> "The Definition of Standard ML", is one of my favourite books. _that's_ how to write a spec (though even better would be twelf or isabelle checkable specs, these days)
07:30:46 <boegel> I just impressed the Perl-fanatic
07:30:48 * boegel cheers
07:31:21 * Darius needs to email Philip Wadler
07:31:38 <pesco> Wow, I'm in the Pugs credits!
07:31:56 <theorbtwo> boegel, dispite the worse characteristics of some people, the general perl way has always to been to try to emulate the good features of other languages, and not the bad features.
07:32:16 <theorbtwo> Of course, we haven't always guessed right on which features are good to emulate...
07:37:35 <dons> theorbtwo, mail me if you have any problems.
07:37:45 <dons> (w/ hs-plugins, that is :)
07:39:49 <basti_> hmm dons I'm trying to do some display feedback (through the bottom line) in my Yi Emacs keymap. Are meta-states the only way to get around the restriction of not being able to concatenate lexers (which can, other than regexes, cause actions)?
07:40:32 <TheHunter> arrggghh!
07:40:42 <basti_> did i cause a brain stroke?
07:40:43 <dons> TheHunter: ?
07:40:53 * TheHunter just realized that lambdabot's modules are just a fancy encoding of objects (in the sense of OO)
07:41:06 <dons> hmm. true.
07:41:58 <dons> basti_ : catenating lexers isn't too hard. you can do that with `meta`
07:42:21 <basti_> well thats what i did
07:42:23 <dons> you get to specify the next lexer to continue with
07:42:29 * basti_ nods
07:42:32 <dons> yeah. so `meta` is the right way.
07:42:39 <basti_> oh okay.
07:42:46 <dons> metaM is used when the result depends on an IO action.
07:42:47 <basti_> does it behave regex like?
07:42:59 <dons> I don't understand?
07:43:03 <basti_> as in, might match "nothing" or something
07:43:13 <Darius> TheHunter: I commented a bit back that lambdabot's modules (a while back at least) were very Olegesque (though lambdabot was written before most of Oleg's craziness).
07:43:16 <basti_> if something doesnt match in lexer 1 it will be carried over to lexer 2
07:43:31 <camio> Does anyone know what the "lookAhead" function in parsec does? It has no documentation either in the ghc documentation or parsec documentation.
07:43:41 <basti_> is that what that ominous (_,x,_) is for in the `meta` argument?
07:43:42 <dons> oh, the catenation of lexers you mean?
07:43:57 * basti_ thinks he's talking like a martian
07:44:00 <basti_> yes
07:44:01 <dons> `meta` gives you access to the lexer table, basically.
07:44:13 <Darius> @type Text.ParserCombinators.Parsec.lookAhead
07:44:13 <basti_> hmm that is a good thing.
07:44:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Text.ParserCombinators.Parsec.lookAhead :: forall a st tok.
07:44:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                            Text.ParserCombinators.Parsec.
07:44:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prim.GenParser tok st a
07:44:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                            -> Text.ParserCombinators.Parsec.
07:44:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prim.GenParser tok st a
07:44:48 <Darius> camio: It presumably runs the passed in parser and sees if it passes or fails, but doesn't actually consume the input.
07:44:50 * basti_ ponders a bit
07:44:50 <dons> basti_ >||< is the disjunctive combination of two lexers
07:44:55 <basti_> yes i knew that.
07:45:05 <dons> so you don't get 'look in one or the other', you just get one new lexer to work with.
07:45:15 <basti_> yup
07:45:18 <dons> bindings in the 2nd arg overwrite any in the first.
07:45:22 <dons> to >||<
07:45:30 <basti_> uhm
07:45:43 * basti_ .o° ( -?- )
07:46:14 <basti_> phewww.
07:46:20 <dons> so: regex `meta` \match state -> (action1, state', next_lexer)
07:46:33 <basti_> hmm i see.
07:46:44 <joey_> More info on Pugs if interested: http://www.perl.com/pub/a/2005/03/03/pugs_interview.html
07:46:49 <camio> Darius: Hrm, I was hoping it would give me some sort of non-determinism. I would like to run several parsers on the same input and do something with all of their results. Do you know of a way to do that?
07:46:59 <basti_> and the state would contain two strings... what are they for?
07:47:28 <dons> the state is specified per-keymap. depends on what you want to store in your keymap state.
07:47:41 <basti_> hmm okay.
07:47:51 <basti_> now i think i see
07:47:54 <dons> e.g. ViState, or type NanoState = Maybe (Char,String,String,OnlyMode)
07:48:06 * basti_ nods
07:48:27 <basti_> and OnlyMode is a "return pointer"?
07:48:31 <basti_> (continuation?)
07:48:46 <TheHunter> Darius, a bit olegesque perhaps, but nothing compared to that applicative translucent functor thingy.
07:49:28 <dons> basti_: -- We augment the echo keymap with the following bindings, by passing
07:49:29 <dons> -- them in the @OnlyMode@ field of the lexer state.
07:50:05 <dons> so any new bindings for the 'echo' keymap are stored inside the lexer state, and passed through to the particular lexer when they're requried.
07:50:21 <basti_> oof.
07:50:35 <dons> it's wrapped in an OnlyMode so the lexer has non-infinite type
07:50:51 <basti_> ahhh.
07:50:51 <basti_> -g-
07:50:52 <basti_> okay
07:50:59 <dons> that's kind of tricky stuff.
07:51:07 <dons> maybe even be vi specific.
07:51:25 <dons> scripting keymappings with lexer combinators is fun!
07:51:30 <basti_> yup.
07:51:38 <TheHunter> @listmodules
07:51:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Modules: babel base dice dict dummy dynamic eval google help karma more
07:51:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pl plugs quote seen state system topic type version
07:51:47 <dons> makes you realise how nuts most key bindings are.
07:51:55 <basti_> okay i will think about that stuff.
07:52:01 * basti_ nods
07:52:04 <dons> is the Nano mode useful?
07:52:06 * TheHunter wonders which of these modules "need" persistance and which need state for each user they're interacting with.
07:52:10 <basti_> as an example, yes.
07:52:16 <dons> TheHunter: ah!
07:52:19 <basti_> or for editing in a non-vi environment
07:53:31 <Darius> camio: You could mapM lookAhead theListOfParsers
07:54:05 <lightstep> what machine starts ghc this fast?
07:54:10 <dons> @version
07:54:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p200, GHC 6.4 (OpenBSD i386)
07:54:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:54:18 <dons> TheHunter: 200!
07:54:29 <TheHunter> yay!
07:55:02 <dons> lightstep, it doesn't run ghc, you're just seeing lambdabot quit and rejoin. the compilation happened prior
07:55:11 <dons> here's ghc running:
07:55:14 <dons> @plugs 1 + 2
07:55:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3
07:55:30 <camio> Darius: Thanks, I'll try that.
07:56:20 <Darius> camio: I think that assumes everything parses and I'm not sure if that was correct, but something along those lines may work.
07:56:54 <dons> TheHunter: do our persistence problems, for now, reduce to findings which modules use global state? or is it more complex?C
07:56:55 <Darius> @type \x -> x
07:56:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- \x -> x :: forall t. t -> t
07:59:00 <TheHunter> i don't think all modules with global state need persistence.
07:59:20 <TheHunter> Actually, I can only think of karma, seen and maybe state.
07:59:37 <dons> and quote/remember
07:59:43 <dons> which does it by hand atm.
07:59:50 <TheHunter> but seen is more complicated.
08:00:11 <dons> yeeah :/
08:00:13 <TheHunter> oh, and eval.
08:00:16 <camio> Darius, works perfectly. Thanks a lot. lookAhead is really useful for implementing looping in an interpreter, it's a shame it isn't documented.
08:01:04 <TheHunter> @help remember
08:01:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @remember <nick> quote - record some memorable phrase
08:01:24 <lightstep> parsec is supposedly used for finite-lookup grammets
08:01:27 <lightstep> *grammers
08:01:55 <dons> ok. that list looks about right.
08:02:03 <TheHunter> ah, quote is in Babel.
08:02:03 <camio> lightstep: what does that mean?
08:02:25 <dons> yeah. shouldn't be.
08:02:53 <lightstep> try and lookAhead are there, but they're not encouraged
08:02:53 <dons> feel free to move @quote into QuoteModule.
08:02:55 <Darius> dons: Just curious, but what were the last two lambdabot restarts changing/adding?
08:03:33 <lightstep> you're supposed to work only with parsers which consume their input
08:04:01 <dons> pull the last couple of patches from the official repo. compiled; restarted; forgot to make clean (so patch count was off); recompiled; restarted;
08:04:15 <dons> so version = 2p200 :)
08:05:01 <camio> lightstep: I think I see what you mean. Parsers aren't generally supposed to be turing machines?
08:05:03 <lightstep> is there listST in ghc 6.4?
08:05:14 <lightstep> i mean, liftST, or ST transformer?
08:05:18 <dons> TheHunter:
08:05:20 <dons> @dynamic-reload version
08:05:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- can't unload a static module
08:05:22 <dons> ?
08:05:37 <basti_> i ended up calling constructors Tokyo and Kyoto in my Emacs.hs
08:05:40 <TheHunter> @dynamic-reload pl
08:05:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- can't unload a static module
08:05:43 <basti_> is that a sign of madness?
08:05:44 <lightstep> camio, Parsec is optimized for the common case
08:05:51 <TheHunter> weird.
08:05:56 <lightstep> (which are deterministic parsers)
08:06:23 <basti_> haskell.is.the.best.language.in.the.world.
08:07:05 <dons> :) basti_, how far along is the emacs binding?
08:07:38 <camio> lightstep: I wonder if my language truely requires non-determinism to be executed. It has a for loop so I parse its contents for each value of i.
08:07:58 <basti_> its advancing.
08:08:05 <dons> hehe. ok.
08:08:16 <basti_> I'll have a halfway functioning control-key-escape-thingy-monitor
08:08:22 <basti_> soon
08:10:27 <Darius> camio: Typically, parsing is done before any evaluation
08:10:39 * dons sleeps
08:11:40 <camio> Darius: Just to make things easier on the coder?
08:13:47 <Darius> camio: I guess for interpreted implementations, technically.
08:14:47 <Darius> camio: Usually parsing doesn't depend on evaluation and therefore can be done completely before executing which allows it to be done once and for all (and makes it much simpler to implement the parser and evaluator).
08:17:44 <camio> Darius: Interesting. Funny how parsec's tutorial gives an example where it evaluates simple arithmetic expressions. That's probably where they think evaluation should end as far as the parser is concerned.
08:22:39 <Darius> camio: For something as simple as arithmetic expressions (and as an example) that isn't unreasonable, but for more complex languages it helps to generate an intermediate AST to keep the evaluator from depending on the parser or needing to deal with the parser and vice versa.
08:23:48 <Darius> camio: In other words, if I write eval (Num i) = i;eval (Add x y) = eval x + eval y; etc. I can use any parser I want with that.
08:24:35 <camio> Darius: I see what you're saying.
08:26:04 <boegel> hmm, language problem
08:26:28 <boegel> does "with d substituted for v" mean that you remove all d's and replace them with v's, or the opposite ?
08:26:56 <Darius> camio: Anyways you can't embed the IO (or any other monad) into the Parsers so you'd be limited in what you could do.
08:26:59 <theorbtwo> boegel, yes to your explicit question.
08:27:11 <Darius> boegel: The opposite.
08:27:26 <theorbtwo> Er, wait, yeah, the oppisiste.
08:28:04 <boegel> heh, confusion :D
08:28:17 <boegel> okay, thanks :)
08:28:29 <boegel> now I know I'm not the only one confused about this :p
08:28:51 <camio> Darius: For my case it doesn't matter . . . it's a language similar to the C pre-processor in that it doesn't need any input, just output.
08:29:11 <TheHunter> @dynamic-load foo
08:29:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- couldn't load module FooModule.o
08:32:22 <jlouis> yay!
08:32:56 <theorbtwo> ?
08:33:13 <sorje> lamgdabot doesn't have @index anymore?
08:39:04 <theorbtwo> How can I do a foo <- ... expression, and explicitly give the type of foo?
08:39:10 <theorbtwo> (Note that ... is fairly long.)
08:40:49 <TheHunter> (foo :: Int) <- ... is probably good enough.
08:54:22 <jlouis> sorje: not at the moment. @index is way spammy
08:55:43 <dons>  @index also, it requires a custom haddock, which I don't have yet.
08:56:25 <jlouis> why does vorbis take so long time to compile on a 500Mhz PII ?
08:56:26 <jlouis> heh
08:59:23 <ddarius> jlouis: @index is less spammy than a lot of other lambdabot commands
09:00:44 <dons> are there any you think are too noisy atm?
09:01:18 <Darius> dons: Not any that are (ab)used much.  The pretty printing is sometimes verbose in lines though.
09:01:18 <dons>  @info was too spammy by far, maybe you're thinking of that, jlouis?
09:01:47 <dons> yes. I don't have a nice idea for that yet. other than reparsing @type's output. hmm..
09:02:06 * dons adds this to the TODO list
09:09:15 <zooko> I'm trying to get darcs running in cygwin.
09:09:15 <zooko>  
09:10:04 <Darius> zooko: Building or executing?
09:11:12 <zooko> Well, I've already experimented quite a bit with the w32 darcs.exe, as recommended on darcs.net.
09:11:31 <zooko> ..  and I've reported a bug via bugs.darcs.net about how one can't enter long patch descriptions with it...
09:11:56 <ralejs> zooko: I've had that problem too
09:14:47 <zooko> A-ha!  Brainstorm.  I'll use the --logfile option instead.  :-)
09:29:51 <dons> @dynamic-reload version
09:29:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- can't unload a static module
09:30:13 <dons> oopps. forgot to pull the patch :/
09:30:41 <poetix> Is there a list of lambdabot commands anywhere?
09:30:50 <dons> @listmodules
09:30:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Modules: babel base dice dict dummy dynamic eval google help karma more
09:30:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pl plugs quote seen state system topic type version
09:30:54 <dons> @listcommands
09:30:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Commands: all-dicts arr babel define definitions del-definition devils dice
09:30:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dict dict-help dummy dump dynamic-load dynamic-reload dynamic-unload easton
09:30:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- echo elements eurohaskell eval foldoc fortune gazetteer get-definition google
09:30:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- help hitchcock jargon join karma karma+ karma- kind learn leave listchans
09:30:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- listcommands listmodules lojban moo more msg part paste pl pl-resume plugs
09:30:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pointless prelude quit quote reconnect remember resume seen set-fuel state
09:30:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- timein topic-cons topic-init topic-snoc topic-tail topic-tell type vera
09:30:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1 @more lines]
09:31:01 <dons> :}
09:31:09 <lightstep> @more
09:31:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- version web1913 wiki wn world02 yow
09:31:10 <poetix> thanks - lambdabot is cool
09:31:48 <poetix> @type StateT
09:31:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
09:32:03 <lightstep> @info StateT
09:32:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "info", try "lambdabot: @listcommands"
09:32:18 <poetix> @type foldr
09:32:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- foldr :: forall b a. (a -> b -> b) -> b -> [a] -> b
09:34:35 <dons> lambdabot: @quit
09:34:46 <dons> @dynamic-reload versioon
09:34:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unknown/static module
09:34:49 <dons> @dynamic-reload version
09:34:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- module reloaded
09:34:56 <dons> TheHunter: :) thanks.
09:35:18 <dons> @version
09:35:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p201, GHC 6.4 (OpenBSD i386)
09:35:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:35:35 * dons -> really sleeps.
09:38:57 * stepcutHM -> really goes to work.
09:40:40 * xerox -> really a
09:42:16 * kaol -> Maybe (Studying)
10:02:12 <SyntaxNinja> hi all
10:06:39 * Darius relaxes with some nanase
10:09:37 <SyntaxNinja> waht's nanase? sounds scary. I think i'll relax with some music.
10:10:08 <Darius> Nanase Aikawa
10:11:05 <SyntaxNinja> it's not some sort of imitation healthy condiment.
10:11:12 <Darius> @google "Nanase Aikawa"
10:11:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.nanase.gr.jp/
10:14:20 * Igloo mutters at bugs that disappear when you enable debugging
10:15:46 <Darius> Igloo: Haskell?
10:16:06 <Igloo> Yup
10:17:49 <basti_> thats a heisenbug.
10:18:37 <gzl> hahaha
10:18:48 <Darius> basti_: A Heisenbug should disappear at random independent of whether debugging is enabled
10:18:53 <basti_> :P
10:18:59 <Darius> Usually it's a memory or concurrency error.
10:19:14 <Darius> (Or both!)
10:19:16 <basti_> then, a Schrödinbug?
10:21:50 <Igloo> Oh great, and if I run it under strace I get a segfault
10:24:11 <Darius> Igloo is it crashing (originally) and what are you doing that would make it crash (if so)?
10:24:31 <Igloo> No, it's a concurrency thing
10:29:06 <Darius> Hmm, read about Forth or fibrations applied to logical predicates...
10:50:32 <CosmicRay> i hate friday afternoons.
10:51:00 <SyntaxNinja> CosmicRay: ?
10:51:27 <CosmicRay> somehow they always same waaaay slow.
10:51:31 <CosmicRay> nothing much happens.
10:52:22 <CosmicRay> hmm, I forget, is galois in the porland area, or was that seattle?
10:53:58 <CosmicRay> I almost planned a trip to that area but the unfavorable train connections meant we went to new orleans instead
10:54:06 <CosmicRay> but we might go there next time
10:54:20 <CosmicRay> s/went/will go/
10:55:54 <SyntaxNinja> portland, of course
10:55:58 <CosmicRay> ah
10:56:06 <SyntaxNinja> let me know if you come to town, we can get together.
10:56:19 <CosmicRay> that would be great.  we'll probably try to plan another train trip late fallish
10:56:25 <SyntaxNinja> if you forget again, just remember that I'm in the same building as OSDL
10:56:53 <SyntaxNinja> cool! let me know :)
10:56:57 <CosmicRay> SyntaxNinja: I do hope that you are the anonymous osdl-affiliated consultant who forced larry mcvoy to withdraw bitkeeper :-)
10:57:01 <Oejet> SyntaxNinja: Say hello to Linus for me then.
10:57:29 <CosmicRay> SyntaxNinja: ever been on the Coast Starlight or Empire Builder?
10:58:14 * basti_ approaches yi's concepts further
10:58:36 * CosmicRay likes to travel by rail when he has enough vacation time to do so
10:58:42 <SyntaxNinja> CosmicRay: no, what are those?
10:58:45 <SyntaxNinja> trains
10:59:17 <SyntaxNinja> CosmicRay: I wish I were said consultant.  we hvae no relationship w/ osdl.
10:59:19 <CosmicRay> SyntaxNinja: the two main trains that go through portland.  The Empire Builder is Portland/Seattle to Chicago.  The Coast Starlight is Seattle to Los Angeles (or farther south?)
10:59:32 <CosmicRay> SyntaxNinja: yeah, I know :-)
10:59:32 <SyntaxNinja> Oejet: I think I've seen Linux getting coffee downstairs a few times, but I'm not sure exactly what he looks like.
10:59:44 <SyntaxNinja> s/linux/linus
11:00:04 <CosmicRay> SyntaxNinja: I haven't been on either one of them, but both are supposed to be quite enjoyable trips.
11:00:14 <SyntaxNinja> I'm taking the portland-seattle train next week :)
11:00:49 <CosmicRay> SyntaxNinja: one of the Cascades?
11:01:26 * basti_ recommends through the odenwald and up the neckar for germany
11:01:34 <basti_> won't take much longer than a day though ;)
11:01:41 <CosmicRay> basti_: too short :-)
11:01:45 <SyntaxNinja> oh, I was thinking of emailing whoever that OSDL developer is and letting him know he can get free Haskell lessons right here in portland :)
11:01:52 <CosmicRay> SyntaxNinja: haha
11:02:15 <basti_> in germany we lack in the long distances department
11:02:26 <SyntaxNinja> CosmicRay: not sure the name.
11:02:30 <CosmicRay> basti_: can't you just go around the country in a circle a time or two? :-)
11:02:38 <CosmicRay> basti_: you also are cursed by having fast trains.
11:02:57 <basti_> yes.
11:02:58 <CosmicRay> basti_: here in the usa, we have no fast mode of transit. :-)
11:03:01 <basti_> -g-
11:03:14 <CosmicRay> basti_: which is ironic, considering we tend to have greater distances to travel
11:03:19 <basti_> yes indeed.
11:03:26 <basti_> why dont you just buy a few of these trains
11:03:28 <basti_> ;)
11:03:42 <CosmicRay> basti_: probably because we haven't had an integrated transit policy since 1890
11:03:53 <stepcut> we suck
11:03:55 <basti_> ah.
11:04:11 <basti_> well here we curse the train system, too.
11:04:13 <CosmicRay> basti_: though it should be noted that we have done a great job building railroads in Germany and Iraq.
11:04:26 <basti_> but BECAUSE it's unified and not because it's not
11:04:27 <basti_> ;)
11:04:28 <stepcut> haha
11:04:29 <CosmicRay> basti_: here there are a lot of people that say, "We have a train system?"
11:04:40 <CosmicRay> haha
11:04:52 <basti_> -g-
11:05:05 * stepcut grumbles
11:05:24 <CosmicRay> thing is, with all its faults, traveling by train is really the most enjoyable way to travel, imho
11:05:35 <basti_> the german railway system is extraordinary in fact
11:05:41 <CosmicRay> I hate long car trips, and flying is more annoying than anything these days
11:06:03 * basti_ nods
11:06:09 <basti_> with trains you travel comfortable
11:06:10 <basti_> y
11:06:28 <basti_> and quicker than any car
11:06:33 <CosmicRay> most energy-efficient, too.
11:06:41 <CosmicRay> basti_: here in the US, that does not always hold :-)
11:06:56 <basti_> :P
11:07:10 <CosmicRay> one reason is that most of our rail network is primarily used for freight
11:07:24 <CosmicRay> which moves slower, stops slower, starts slower, etc. than passanger movements
11:07:26 <basti_> oh in germany there's trucks for that -.-
11:07:30 <xerox> Hiya haskeller, any @wiki HaskellGoPeople present && in the mood for a game?
11:08:01 <CosmicRay> basti_: yeah, we have trucks too, but they are simply not as efficient for long distances, plus they mess up the environment
11:08:07 <basti_> i know.
11:08:10 <basti_> they do in germany too.
11:08:26 <CosmicRay> so that is one thing we have not yet managed to destroy: our freight railroad network.
11:08:32 <CosmicRay> we've certainly tried.
11:08:48 <basti_> hehe
11:09:18 <SyntaxNinja> CosmicRay: airplanes are pretty fast
11:09:23 <stepcut> hrm, I want to make a thread sleep until getProcessStatus returns, but I don't see how without adding a new primitive op in the compiler :-/
11:09:23 <CosmicRay> it's really the chinese imports that have been helping the railroads all these years
11:09:27 <CosmicRay> SyntaxNinja: once they manage to get in the air, sure
11:09:52 <basti_> in germany the "heavy industry" (do you say so? like, coal and steel) made a lot of buisiness for the freight railways, but theres no steel and coal industry anymore to speak of
11:09:57 <CosmicRay> SyntaxNinja: but you have to get there so far in advance, and spend so much time taxiing around the airport congestion when you land, that cars can still beat them :-)
11:10:06 <SyntaxNinja> yeah
11:10:08 <CosmicRay> basti_: you get it all from china like we do? :-)
11:10:21 <basti_> oh no we sell our heavy industry items to china now.
11:10:25 <basti_> no need to get new trains
11:10:25 <basti_> ;)
11:10:30 <CosmicRay> hehe
11:10:42 <basti_> lately they bought a whole steel plant
11:10:49 <CosmicRay> weird
11:10:50 <SyntaxNinja> man. I traveled all over the UK and Sweden in trains. it's such a civilized way to travel
11:10:51 <basti_> with like 14 steelovens
11:11:05 <basti_> each like 30 meters high or something
11:11:09 <CosmicRay> SyntaxNinja: you should try an overnight train with a sleeper room sometime.
11:11:13 <CosmicRay> (amtrak)
11:11:27 <CosmicRay> yeah, we have a couple of steel hotspots left in the US.
11:11:28 <SyntaxNinja> I ride a train every day, I get so much reading done, it's awesome. in the mornings I read a computer book, and in the evenings I read a novel
11:11:29 <basti_> they just numbered everything, took it apart, flied it to china and put it back together there
11:11:36 <basti_> flew
11:11:36 <SyntaxNinja> CosmicRay: did that in sweden with my girl. it was lovely.
11:11:48 <CosmicRay> basti_: wacky
11:12:01 <CosmicRay> basti_: nah, over here, we prefer the "urban decay" route.
11:12:07 <CosmicRay> just let the abandoned steel mills sit.
11:12:09 <basti_> ah.
11:12:40 <CosmicRay> SyntaxNinja: that's what we're doing next month.  Turned in my amtrak credit card points so we get a whole trip free.
11:12:46 <CosmicRay> meals and all.
11:12:49 <SyntaxNinja> nice :)
11:12:50 <basti_> gives nice backgrounds for movies with mel gibson
11:12:54 <CosmicRay> basti_: heh
11:13:25 <CosmicRay> Gary, Indiana is probably the last big steel town in the USA.  (Maybe pittsburg, pa too).
11:13:30 <CosmicRay> but that town *sucks*
11:13:32 <stepcut> oh oh! maybe I can use SIGCHLD
11:13:43 <CosmicRay> you can literally smell it when you approach chicago by highway or train
11:13:45 <basti_> at least they still have work...
11:13:54 <CosmicRay> and it was the murder capital of the world for years, probably still is
11:13:58 <basti_> it's said that it was like that 40 years ago
11:14:02 <SyntaxNinja> CosmicRay: I grew up in Youngstown
11:14:05 <mflux> btw, how are unix signals handled in haskell?
11:14:08 <basti_> in Essen for example
11:14:10 <CosmicRay> SyntaxNinja: ha.  gary's worse. :-)
11:14:22 <CosmicRay> mflux: I think there is a Posix signal module
11:14:29 <CosmicRay> mflux: you can handle them just like in C or PYthon
11:14:35 * SyntaxNinja believes it
11:14:43 <basti_> what about concurrency?
11:14:49 <basti_> signals would have to live with it wouldnt they?
11:15:07 <CosmicRay> my mother-in-law related a story about her co-worker in the gary office once.  witnessed two murders happening on the street outside her window within one week.
11:15:19 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Posix.Signals.html
11:15:25 <basti_> o.o
11:15:29 <CosmicRay> basti_: what sort of concurrency do you mean?
11:15:36 * Igloo sighs and gives up on ghc-cvs for sarge
11:15:53 <basti_> well if a signal comes in, this is concurrent by idea i think
11:16:02 <basti_> i mean, the program might be doing something
11:16:20 <CosmicRay> traditionally, if a signal comes in, current processing stops, the signal handler is called, and when it is done, current processing resumes.
11:16:34 <CosmicRay> this all becomes much more complicated if you are using threads.  I don't know what the semantics are then.
11:16:37 <basti_> yes but the signal handler might interfere with the rest of the program
11:16:57 <CosmicRay> yes, but it does not execute concurrently with it
11:17:04 <basti_> hmm okay
11:17:16 <CosmicRay> so the signal handler could modify , say, a global variable
11:17:23 <CosmicRay> but the main program is not executing concurrently
11:17:24 <basti_> yep
11:17:29 <basti_> i see your point
11:18:19 <IlyaM_>  /msg nickserv link IlyaM p4ssw0rd
11:19:00 <SyntaxNinja> heh
11:19:13 <SyntaxNinja> IlyaM_: nice password ;)
11:19:17 <IlyaM_> lol
11:19:32 <IlyaM_> I don't use that IRC thing too often
11:19:36 * SyntaxNinja has _never_ done that before
11:19:42 <SyntaxNinja> you should change it, if you care.
11:20:05 <IlyaM_> not really, in fact I want just ask one newbie question about haskell
11:20:13 <SyntaxNinja> go for it
11:20:17 <SyntaxNinja> want me to change it? ;)
11:20:22 <CosmicRay> heh
11:20:33 <Darius> SyntaxNinja: p4ssw0rd doesn't sound like a password someone uses for something they care about.
11:20:43 <IlyaM_> indeed
11:20:51 <SyntaxNinja> Darius: yeah
11:21:20 <CosmicRay> Darius: you overestimate the intelligence of many computer users.
11:21:21 <SyntaxNinja> most people will exchagne their passwords for chocolate, you know :)
11:21:33 <IlyaM_> anyway can anybody help me with probably simple problem - i have a list and I want to calc sqrt of its length
11:21:37 <Darius> mmm, chocolate
11:21:38 <CosmicRay> Darius: using numbers in the password is quite innovative, I assure you
11:21:54 <IlyaM_> i cannot figure how to convert Int to something sqrt doesn't complain
11:22:02 <Darius> @type fromIntegral
11:22:03 * SyntaxNinja dangles sweets in front of Darius
11:22:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fromIntegral :: forall b a. (Num b, Integral a) => a -> b
11:22:11 <skew> SyntaxNinja: sounds like a double win to me "hmm, the nice man gives me chocolate and I change my stale password"
11:22:15 * SyntaxNinja accidentally typed "sweets in" as "sweet sin"
11:22:18 <Oejet> @plugs sqrt(fromIntegral (length [1,2,3,4]))
11:22:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2.0
11:22:30 <CosmicRay> Darius: but sqrt wants a Floating, not just a Num...
11:22:33 <CosmicRay> how does that work?
11:22:35 <IlyaM_> Prelude> sqrt ( fromIntegral 1::Int)
11:22:35 <IlyaM_> <interactive>:1:
11:22:35 <IlyaM_>     No instance for (Floating Int)
11:22:35 <IlyaM_>       arising from use of `sqrt' at <interactive>:1
11:22:35 <IlyaM_>     In the definition of `it': it = sqrt (fromIntegral 1 :: Int)
11:22:39 <IlyaM_> it doesn't work
11:22:42 <CosmicRay> ah ha.
11:22:45 <IlyaM_> I already tried this :)
11:22:58 <SyntaxNinja> @type length
11:22:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- length :: forall a. [a] -> Int
11:23:17 <Darius> IlyaM_: fromIntegral 1 :: Int is parsed as (fromIntegral 1) :: Int
11:23:22 * CosmicRay looks up the definition of Floating
11:23:25 <SyntaxNinja> lambdabot can do it
11:23:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
11:23:28 <skew> IlyaM_: fromIntegral 1 :: Int means (fromIntegral 1)::Int, not fromIntegral (1 :: Int)
11:24:23 <IlyaM_> I see
11:24:28 <IlyaM_> thanks
11:24:43 <IlyaM_> bye
11:24:57 <Arafangion> skew, How about "Hmm, I get chocolate, don't bother to change passwords, and observe that the only way to login is via ssh keyfile"? :)
11:25:56 <SyntaxNinja> heh
11:26:34 <Arafangion> But hey, They kept their end of the deal, and I kept mine too!  Giving out your password to someone implies not changing it.
11:27:46 <Darius> Arafangion: That's narrow thinking. Think -service-.  You got a constant stream of chocolate in return for keeping them up-to-date on your password.
11:28:15 <Arafangion> Darius, I would say that clinches it.
11:28:32 <CosmicRay> heh
11:28:45 <CosmicRay> Darius: is that also why people try to sweet-talk misbehaving computers?
11:28:48 <Arafangion> Of course, nothing satisfys my choc addition than raw cocoa, with perhaps a bit of water and sugar :(
11:29:46 * SyntaxNinja lives next door to a "chocolate cafe"
11:30:00 <SyntaxNinja> they used to have eclairs, but they don't anymore, so I hardly go there.
11:30:24 <CosmicRay> heh
11:34:06 <Arafangion> I'm not sure what I prefer, cocoa or coffee.
11:34:32 <TheHunter> man, ExceptionErrorT is a bitch.
11:37:21 <Darius> TheHunter: My mild interactions with it seem to bear that out.
11:38:03 <TheHunter> thing is, it's not a monad transformer in the strict sense of the word, because it messes with bottoms.
11:38:54 <Darius> TheHunter: Yeah, I believe that was my problem.
11:39:36 <Darius> @listmodules
11:39:36 <TheHunter> i can't help it, moduleDefState now becomes m -> Maybe (LB s).
11:39:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Modules: babel base dice dict dummy dynamic eval google help karma more
11:39:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- pl plugs quote seen state system topic type version
11:39:55 <Lunar^> If only Ubuntu people would do Haskell instead of Python
11:39:57 <Lunar^> *sigh*
11:40:30 <Arafangion> Lunar^, In what way?
11:41:45 <Lunar^> Arafangion: they're doing a lot of work in making a perfect environment for Python
11:43:18 <xerox> True.
11:44:21 <Arafangion> Python, at least, is a decent language.
11:44:39 <Arafangion> Has a few annoying issues, though :(
11:45:29 <wagle> s/Python/______/
11:46:11 <Arafangion> wagle, At least you can recurse more than 20 levels deep in most other languages!
11:47:26 <wagle> i was amazed that most versions of scheme would crash trying to process /usr/share/dict/words as a list
11:47:36 <basti_> would anything break if we allow to pattern-match lambdas?
11:48:24 <wagle> chez scheme was the only one which could do it
11:48:52 * basti_ asks innocently
11:49:19 <skew> basti_: well, you have to figure out what to do with identifiers
11:49:39 <basti_> hm.
11:49:49 <basti_> pointless the function.
11:49:51 <basti_> :)
11:49:57 <basti_> unlambda it.
11:50:10 <Lunar^> basti_: But isn't that Template Haskell?
11:50:15 <skew> say f was defined by  let x = 10 in \y -> x, and then you do case f of (\arg -> body) ->??
11:50:51 <basti_> hmmm
11:50:54 <Darius> basti_: Heffalump's thesis is on higher-order matching.
11:51:17 <skew> maybe that's not a good example
11:51:19 * basti_ feels at eye level again. :)
12:09:15 * Igloo worries about this enthusiasm to gratuitously use GADT syntax, straying from Haskell 98
12:10:21 <basti_> why?
12:11:26 <ibid> because it strays from h98 :)
12:11:30 <esap> I think many people use GADTs just for being able to use existential types. Existential types are already an extension.
12:12:04 <esap> And GADTs happen to be relatively easy-to-understand syntax for it.
12:12:23 <esap> ... not to talk about powerful in type checking sense.
12:12:44 <wilx> Hm.
12:17:03 <esap> I think GADTs introduce one big leap towards object-oriented programming in Haskell. GADTs allow you to describe private data fields and class invariants.
12:18:25 <musasabi> GADTs are incompatible with haddock and template haskell to name a few problems.
12:31:51 <Oejet> Let the respective authors wrestle to settle it.
12:32:17 <wagle> h98 is evilllllll (i tell you)
12:32:22 <wagle> 8)
12:33:03 <wagle> musasabi: how is gadt incompatible?
12:33:38 <wagle> (more than just that haddock and th dont represent the new syntax?)
12:33:57 <musasabi> wagle: that is the exact issue.
12:34:08 <musasabi> wagle: should be true for most other tools ;)
12:34:14 <Darius> @version
12:34:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p201, GHC 6.4 (OpenBSD i386)
12:34:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:34:15 <wagle> seems a small thing
12:35:00 <musasabi> The lack of TH support is not trivially fixable before the next major version of GHC afaik.
12:35:32 <wagle> need extensible syntax
12:35:35 <wagle> heheh
12:36:49 <wagle> i still havent gotten around to installing 6.4 so i can play with gadt..  8(
12:37:02 <wagle> too many things i have to get done first
12:37:52 <wagle> (i guess i'm whining because I wanna do it right now, except i need to do other, more responsible, stuff)
13:01:19 <lightstep> where is the instance Ord (a, b) specified or defined?
13:01:19 <Darius> @plugs (1,2) < (3,4)
13:01:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- True
13:01:19 <autrijus> Prelude?
13:01:19 <Darius> lightstep: Presumably in the Report.
13:01:19 <lightstep> i presumed so too
13:03:25 <wagle> derived, i bet
13:04:00 <wagle> ( lightstep )
13:04:02 <lightste1> but not in chapter 10  Specification of Derived Instances
13:04:32 <wagle> i vaguely remember something about deriving dictionary orderings or something..
13:05:02 <lightste1> me too. but i seem to trip on this now, and i can't find the details - not even in the ghc docs
13:08:41 <wagle> i find this in the hugs prelude:
13:08:41 <wagle> -- data (a,b) = (a,b) deriving (Eq, Ord, Ix, Read, Show)
13:08:51 <lightstep> commented?
13:08:56 <wagle> yes
13:09:07 <Oejet> @plugs (1,2) > (1,3)
13:09:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- False
13:09:43 <lightstep> chapter 10 doesn't mention `pair' or `tuple'
13:10:21 <ksandstr> isn't this one of the things that are "just there" and not defined by any valid haskell syntax?
13:11:16 <musasabi> @info (,)
13:11:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "info", try "lambdabot: @listcommands"
13:11:21 <musasabi> @type (,)
13:11:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (,) :: forall b a. a -> b -> (a, b)
13:11:52 <musasabi> so you could say it is an infix constructor with nifty syntax.
13:12:01 <musasabi> becomes even more visible with (,,)
13:17:28 <wagle> However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show.
13:17:55 <wagle> http://www.haskell.org/onlinereport/basic.html#sect6.1.4
13:19:50 <lightstep> yes, but it doesn't say what the instances are
13:20:11 <lightstep> there isn't even a mention of lexicographic order
13:22:51 <wagle> i always had the impression that deriving was ad hoc and embarrassing
13:23:48 <Darius> wagle: Deriving isn't so bad, the fact that deriving is only for special classes is.
13:25:43 <Darius> lightstep: The only issue I see is that tuples aren't specified (that I saw) as using derived instances.  Derived instances of Ord definitely use lexicographical ordering for the product parts.
13:26:24 <wagle> people describing the state of the art in deriving seem embarrassed (all i meant)
13:26:25 <Darius> There may be a blanket statement somewhere that says all instances required are derived ones unless otherwise specified, but I don't feel like looking.
13:26:44 <Darius> wagle: "The state of the art"?
13:26:56 <wagle> sigh
13:27:26 <wagle> i'm trying to do six things at once
13:29:14 <wagle> "the current way things are done"
13:30:59 <Darius> wagle: I don't think anyone considers it "state of the art".  The generics stuff or Template Haskell are much closer.
13:31:21 <Darius> But I think I'm going to go eat something.
13:33:40 <wagle> haha..  technically, there are two definitions of "state of the art"
13:35:43 <wagle> whoa:
13:35:44 <wagle> data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
13:35:47 <wagle> ...
13:36:11 <wagle> (ghc supports tuples up to that arity, apparently)
13:36:28 <wilx> :)
13:38:53 <CosmicRay> wagle: that's it?
13:38:55 <CosmicRay> shocking
13:41:44 <wagle> i truncated it, just to show the arity..  it was followed by > 100 args, i thinl
13:42:01 <CosmicRay> ah
13:42:03 <wagle> ./ghc/compiler/typecheck/TcDeriv.lhs seems to discuss deriving
13:42:21 <wagle> but i dont think thats what i'm looking for
13:42:34 <wagle> (yoda advised me to use the source)
13:51:53 <mwc> Why when I try to compile wxHaskell to I keep getting COuld not fine module 'xxxx' errors
13:52:09 <mwc> Usually rerunning the make a few times will 'fix' it
13:52:18 <mwc> but I've hit one that won't push over so easily
13:52:25 <mwc> module 'DeriveTypes'
13:52:43 <mwc> Ooop, 4th times a charm... now it's classes
13:54:58 <mwc> If somebody from the wxhaskell team wants to investigate, I have a partial build log at http://www.nomorepasting.com/paste.php?pasteID=36940
14:19:06 <wagle> mwahahaha..  wxwidgets (wxMac) has syntax errors compiling with apple's latest C++ update
14:24:31 <boegel> why is that mwahahaha ?
14:27:03 <CosmicRay> wagle: that's weird, doesn't apple use gcc?
14:35:37 <mwc_> CosmicRay, yeah, apple does
14:35:44 <mwc_> GCC 3.3 atm I believe
14:35:53 <wagle> CosmicRay: yeah, but particular versions of gcc (i think they have their own obj-C fork, or something, but that was 2 years ago)
14:36:09 <mwc_> wagle, I just build wx2.5 yesterday
14:36:10 <wagle> gcc (GCC) 3.3 20030304 (Apple Computer, Inc. build 1671)
14:36:58 <mwc_> on the other hand wxHaskel is being difficult
14:37:16 <wagle> mwc_: you poked me into getting around to installing wxhaskell, but i hit the snag, and i dont have time to figure it out
14:37:25 <mwc_> Ah, thanks for the help
14:37:52 <mwc_> If you rerun the make it goes on to another thing
14:37:55 <wagle> i'd installed the november 2004 gcc update yesterday for something else, and i think its pickier, or something
14:38:08 <mwc_> so I just did while [[ $? != 0 ]] do make done
14:38:32 <mwc_> gcc -v
14:38:32 <mwc_> Reading specs from /usr/libexec/gcc/darwin/ppc/3.3/specs
14:38:32 <mwc_> Thread model: posix
14:38:32 <mwc_> gcc version 3.3 20030304 (Apple Computer, Inc. build 1671)
14:38:33 <wagle> make might be making "progress" while its emitting errors..
14:38:45 <mwc_> It's ghc complaining
14:38:56 <wagle> you really dont want something that was built that way
14:38:57 <mwc_> it originally complained Map didn't exist, then Set, the Class, then DeriveTypes, etc
14:40:03 <mwc_> wagle, heh, we'll see when it's dome
14:40:06 <wagle> (though its an interesting experiment to see what happens when you do build it that way)
14:40:24 <wagle> which ghc on my platform?
14:40:36 <mwc_> I'm using GHC 6.4
14:40:46 <mwc_> there was no binary for 6.4, just 6.2.2
14:41:06 <wagle> which ghc on _which_ (oops) platform?
14:41:21 <mwc_> Eh? GHC on Mac OS X
14:41:29 <mwc_> wxMac
14:41:37 <df_> mwc :: is gcc segfaulting?
14:41:40 <wagle> ah..  darwinports has ghc 6.4 now, by the way
14:41:44 <mwc_> df_, doesn't look like it
14:41:55 <wagle> oh well, i gotta go run errands now..  g'luck
14:42:00 <mwc_> df_, ghc -c wxcore/src/Graphics/UI/WXCore/WxcTypes.hs -o out/wxcore/imports/Graphics/UI/WXCore/WxcTypes.o -ohi out/wxcore/imports/Graphics/UI/WXCore/WxcTypes.hi -odir out/wxcore/imports/Graphics/UI/WXCore/  -fvia-C -package-name wxcore -iout/wxcore/imports -Iwxc/include
14:42:00 <mwc_> Could not find module `Graphics.UI.WXCore.WxcClassTypes':
14:42:00 <mwc_>   use -v to see a list of the files searched for
14:42:00 <mwc_>   (imported from wxcore/src/Graphics/UI/WXCore/WxcTypes.hs)
14:42:08 <mwc_> that doesn't seem to be any GCC error
14:42:15 <df_> ah k
14:45:56 <sebc> dons: I think know why hs-plugins fails on Mac OS X
14:46:39 <mwc_> sebc, what API does it use for loading?
14:46:51 <mwc_> dlcompat? mach-o objects?
14:47:02 <sebc> mwc_: I don't know, but that's not the issue
14:47:19 <sebc> it is trying to load HSbase.o, whereas it looks like it should be loading libHSbase_dyn.dylib
14:48:21 <mwc_> sebc, dlcompat isn't quite the same as on linux, there's a few idiosyncracies with unloading
14:48:28 <mwc_> but if it's a load problem then that's not it
14:48:42 <sebc> it's definitely a load problem
14:48:55 <sebc> no libraries are loaded, resulting in undefined symbols
14:49:03 <sebc> (ghc-6.4, hs-plugins-20050408)
14:49:20 <sebc> hi shapr
14:49:25 <shapr> salut sebc
14:49:30 <sebc> :-)
14:49:37 <shapr> how's it going?
14:49:47 * sebc is trying to use hs-plugins on Mac OS X
14:50:03 <shapr> Is it working?
14:50:13 <shapr> I've only used hs-plugins on linux.
14:50:20 <sebc> nope, but I'm trying to make it work...
14:50:34 <shapr> How's code?
14:50:48 <shapr> I  mentioned type error slicing today on ll1-discuss.
14:51:31 * sebc . o O (code ?)
14:51:46 <shapr> Have you written any neat code lately?
14:51:51 <sebc> ah
14:51:59 <shapr> It's like, if code is life, then "how's code?" is "how's life?"
14:52:06 <sebc> :-)
14:52:22 <sebc> some dual calculus stuff
14:53:00 <shapr> From wadler's paper?
14:53:06 * sebc nods
14:53:34 <sebc> some rewriting stuff too, I'm trying to make an interactive tool to do simple rewriting on terms
14:54:35 <sebc> I would like to use hws for that (so that I can use a web browser as a nice front end), so I need hs-plugins...
14:54:46 <shapr> That makes sense.
14:54:50 <sebc> :-)
14:54:54 * poetix is reading up on hs-plugins at the moment...
14:54:59 * jlouis is playing with cpo's posets and the like
14:55:05 <shapr> hws would be better with hs-plugins.
14:55:06 * xerox is playing go!
14:55:12 <shapr> hiya poetix
14:55:23 <poetix> shapr: I sent you an email...
14:55:33 <shapr> I've read your email a bunch of times, but haven't had anything to say yet.
14:55:42 <shapr> I'm trying to wrench my brain out of the Zope mindset.
14:56:01 <poetix> It was fairly off-the-cuff anyhow
14:56:25 <sebc> shapr: earlier today dons mentioned that Peter Thiemann has made a binding of hs-plugins for hws
14:56:34 * shapr asks google
14:57:20 <shapr> Nothing on his homepage.
14:58:22 <shapr> poetix: hs-plugins would allow you to type in a bunch of Haskell code and immediately use it. Look at Yi for a motivational example.
14:58:37 <sebc> shapr: I asked Peter after his talk at ESOP today, he agreed to send me the files (for some peculiar reason, it is not working on his laptop, but it is reported to work on other machines...)
14:59:06 <shapr> sebc: If Peter doesn't mind, I'd like to get a copy as well.
14:59:42 <sebc> shapr: you can send him an email; I just got a reply from him :-)
14:59:52 <poetix> I'm trying to work out how the typing works, how you access an imported value, and so on.
15:00:17 <shapr> Yi has the :reboot command for when Yi is editing itself. :reboot rebuilds the whole editor, and reloads the editor without exiting.
15:00:37 <shapr> That's more dynamic than emacs.
15:00:50 <sebc> shapr: neat...
15:01:13 <mwc_> woah
15:01:22 * sebc hasn't been able to try out dynamic Yi yet because of hs-plugins problems
15:01:32 <mwc_> I've gotten wxHaskell built by sheer bullheadedness
15:01:46 <mwc_> while [[ $? != 0 ]] do make done
15:02:05 <shapr> mwc_: does make -k do that?
15:02:15 <mwc_> shapr, didn't think about it
15:02:19 <df_> anyone got suggestions for http + html parsing libraries for haskell, and how they compare to perl's LWP and CGI.pm?
15:02:30 <mwc_> Doh: Reading package info from "config/wxcore.pkg" ghc-pkg: Line 1: Invalid syntax (no colon after field name)
15:03:02 <shapr> df_: the two most popular are HXmlToolbox and HaXml, HXT uses a generic tree structure with separate validation, HaXml generates 'significant datatypes' or whatever you call it.
15:03:33 <df_> how well does it cope with crap input?
15:03:36 <shapr> I don't know LWP and CGI.pm
15:03:55 <shapr> HXT should do fine as long as you don't ask for valid-only.
15:03:59 <df_> since the web page i'm going to parse will probably be rubbish (which is the point of me parsing it and cleaning it up)
15:03:59 <shapr> You'll just get a tree.
15:04:03 <df_> ok
15:04:21 <shapr> Of course, if the tags are seriously broken, it may not work either. Haven't tried that.
15:04:34 <df_> LWP allows me to make http queries, get results, deal with cookies
15:04:46 <mwc> :Okay, i'm getting an error:
15:04:46 <mwc> Reading package info from "config/wxcore.pkg" ghc-pkg: Line 1: Invalid syntax (no colon after field name)
15:04:51 <shapr> I did use HXT + OpenOffice to turn a large number of ms.doc files into a custom XML flavor, and I got paid to do it!
15:05:06 <df_> if the worst comes to the worst i can just regex the bits i want
15:05:42 <mwc> and I see nothing outwardly wrong with the wxcore.pkg file
15:05:44 <shapr> HTTP.hs and friends have a Browser monad, I think it handles cookies, etc. There's also darcs' libcurl binding.
15:06:04 <sebc> Oops... << GHCi runtime linker: fatal error: I found a duplicate definition for symbol _s3lX_info_dsp >>
15:06:17 <sebc> (but hs-plugins is finding libraries now...)
15:06:21 <shapr> yay
15:06:50 <df_> shapr :: thanks, will take a poke at them
15:07:06 <shapr> Is your MPEG decoder source online?
15:07:32 <mwc> Can somebody take a look at http://nomorepasting.com/paste.php?pasteID=36950
15:07:42 <df_> not yet, waiting for authorization at the moment
15:08:14 <shapr> Authorization? Did you write it for your company?
15:08:20 <df_> i've already pulled all the very interesting bits out
15:08:38 <df_> yes.  I work for the BBC
15:08:45 <shapr> mwc: ghc6.4 requires Cabal for packages. That looks like a pkg file for ghc6.2
15:08:55 <df_> (British Broadcasting Corporation)
15:08:58 <shapr> Is your project connected to the Dirac codec effort?
15:09:10 <df_> indirectly
15:09:18 <shapr> Interesting.
15:09:31 <df_> some of the results may go into the bitstream definition of dirac
15:10:03 <mwc> shapr, ah, I'll look into it
15:10:04 <shapr> I haven't looked into Dirac, but I have been curious why the BBC would want anoter open source codec. Why not work on Theora?
15:10:24 <df_> because xiph are incapable of being organised
15:10:32 <shapr> That's a good reason.
15:10:35 * shapr grins
15:11:05 <df_> there was lots of enthusiasm a good while back, but stupidness happened within xiph
15:11:34 <shapr> That's sad.
15:11:45 <mwc> You could always fork theora
15:12:15 <df_> we have dirac now, which afaik is further along than theora?
15:13:26 <shapr> I don't know. I do have theora debs, I don't have dirac debs.
15:13:35 <shapr> Not that I've particularly looked for dirac debs, mind you.
15:14:51 * boegel goes to bed, bye everyone
15:14:58 <shapr> g'night boegel
15:15:04 * shapr reads up on the dirac algorithm
15:15:09 <df_> boegel :: night night
15:15:32 <mwc> Ug, cabal won't get passed step-1 on Mac OS X
15:15:38 <poetix> shapr: Got to go. hs-plugins looks really cool, I'll have to give it a go sometime soon.
15:15:59 <poetix> shapr: If Pugs, why not phaskellp?
15:16:13 <mwc> wierd, you have to start with make build
15:16:23 <df_> i think there are a couple of white papers at http://www.bbc.co.uk/rd/
15:16:38 <shapr> poetix: I agree, I've been thinking about where it's going.
15:16:51 <mwc> df_, how far is dirac along?
15:16:55 <mwc> beta?
15:17:01 <poetix> bcnu
15:17:02 <shapr> poetix: As soon as I get my head out of Zope and into stateless web apps, I'll be able to talk more intelligently.
15:17:07 <shapr> cya
15:17:11 <mwc> shapr, hahahah
15:17:24 <shapr> Do you use Zope?
15:19:32 <shapr> It's hard to get my head out of Zope when I stare at it eight hours a day.
15:19:36 <df_> mwc :: something like that.  it is being used, there are various things going on for the reference code, bitstreams being fully defined
15:20:09 <mwc> Interesting
15:21:07 <shapr> I want a tool to convert my gigabyte of unicycling videos to an open format. I haven't been able to do that with theora yet.
15:21:10 <sebc> 'night all
15:21:15 <shapr> g'night sebc
15:21:33 <df_> shapr :: mpeg-{1,2,4} are open
15:21:47 <mwc> shapr, I never really know if you're serious or not
15:21:53 <mwc> What happened to Mpeg 3?
15:21:59 <df_> never was one
15:22:09 <mwc> or is it mpeg (1 << 0), (1 << 1), (1 << 2)
15:22:10 <mwc> ahhhh
15:22:16 <mwc> I'm betting mpeg-8 is next
15:22:21 <shapr> You could ask me if I'm serious. Though a non-serious answer to that question would mean...
15:22:38 <mwc> shapr, it's come up too often
15:22:47 <shapr> Whether I'm serious or not?
15:22:56 <mwc> No, the unicycle theme
15:23:25 <shapr> This is me. http://www.scannedinavian.com/images/uni-hop.jpg
15:24:16 <df_> mpeg-7
15:24:18 <shapr> This is me at EuroHaskell last year - http://andersca.org/gallery/eurohaskell?page=2
15:24:34 <astrolabe> Wow. Not just serious, but levitating.
15:24:45 <df_> the work that was in mpeg-3 became part of mpeg-2
15:25:10 <shapr> astrolabe: That's an important skill for getting up onto curbs.
15:25:20 <mwc> Who's the fellow gimp in the wheelchair in those pictures?
15:25:42 <shapr> ?
15:25:55 <mwc> http://andersca.org/gallery/eurohaskell/p1010015 wheelchair in the background
15:26:17 <mwc> Jesus, 2 wheel was hard enough to learn
15:26:19 <pesco> shapr: I think I'm going to write a TMR article about module versioning!
15:26:20 <shapr> Ah yes. Another #haskell denizen and chalmerite.
15:26:23 <shapr> pesco: cool!
15:26:53 <shapr> pesco: heeey, did you see Josef Svenningsson's version of Hughes' arrows that doesn't have arr/pure?
15:27:08 <mwc> So did you take lessons or was your father a circus performer or how does one get into unicycling?
15:27:09 <pesco> No?
15:27:30 <shapr> mwc: I just saw one in a store last year, so I got it and learned.
15:27:54 <mwc> Impressive... how many bruises and sprains in the process?
15:28:06 <pesco> shapr: What's the deal without arr/pure?
15:28:06 <shapr> pesco: darcs get http://www.cs.chalmers.se/~josefs/category
15:28:18 <mwc> I imagine the hardest part is to stay straight up
15:28:28 <pesco> Finished getting.
15:28:30 <shapr> pesco: the problem with the CGI arrow, with stepcut's unix pipe arrows, etc etc has always been the 'black box' of functions in arrows.
15:28:45 <mwc> isn't the black boxing a good thing?
15:28:54 <mwc> Hides you from implementation of the actual function?
15:29:00 <shapr> I was bemoaning this fact yesterday, or the day before, and Josef mentioned that he might have a solution.
15:29:20 <pesco> shapr: Interesting. I'll check it out soon!
15:29:27 <shapr> mwc: I did get my first stitches while learning.
15:29:38 <shapr> Oh, I should set up the TMR author's wiki while I'm sitting here.
15:29:46 <pesco> But I'm off to bed now. Just wanted to mention my article idea.
15:29:50 <shapr> spiffy
15:30:17 <shapr> Can you send me a summary when you have time?
15:30:19 <mwc> shapr, hehe, I'm a little overcautious lately since I dislocated and broke my ankle in the 100th ice slip of the winter
15:30:37 <pesco> I also want to get to an installment of Code Probe... But I can't _promise_ for sure, I'll have time for both things.
15:30:45 <shapr> I understand.
15:30:45 <mwc> got another 4 months until I'm back to Eival Kaneival mdoe
15:31:28 <shapr> I hope there are more articles in the next TMR.
15:31:32 <shapr> I could write one myself!
15:32:00 <pesco> shapr: Yes, I'll do that. An informal summary, or an abstract for publication?
15:32:06 <shapr> informal
15:32:16 <shapr> I just can't help being curious =)
15:32:27 <pesco> No problem. You left #haskell this morning right after I joined.
15:32:37 <shapr> Did you talk about it?
15:32:40 <pesco> I explained my ideas in some detail. Just have a look at the log.
15:32:42 <shapr> aha
15:32:44 * shapr looks
15:33:40 <pesco> And tell me what you think about it. But I need to go to bed now.
15:33:45 <shapr> ok
15:33:48 <shapr> g'nite
15:34:50 <shapr> Hm, interesting.
15:37:48 <shapr> pesco: This might be related http://lambda-the-ultimate.org/node/view/224
15:39:54 * SyntaxNinja folows up to alexj
15:40:27 * shapr pulls the pin and runs away
15:46:30 <shapr> Hiya rtougher, learning Haskell?
15:46:53 <rtougher> Yep, just thought I'd drop in.
15:47:22 <rtougher> It's my first functional programming language. Coming from C++, Java, Python.
15:48:01 <shapr> Python has some FP, have you used map/lambda/reduce?
15:48:36 <rtougher> Unfortunately not. I spent a few weeks writing a library of matrix funtions in Haskell, so that broke me in a bit.
15:48:39 <shapr> In any case, are you doing this as part of a course? Basically, do you already have learning materials?
15:49:30 <rtougher> Nope, not part of a course. I'm a working Java and C# programmer. I saw something on Slashdot a few months ao regarding a programming contest. I think the winners used Haskell. This made me curious.
15:49:32 <shapr> It sounds like you don't need the basic intro then.
15:50:01 * pesco waves good night.
15:50:06 <rtougher> I'm actually trying to figure out where Haskell fits into my toolset.
15:50:07 <shapr> g'night pesco
15:50:13 <rtougher> Night.
15:50:28 <shapr> I think the easiest and most immediate toolslot for Haskell is parsers.
15:50:44 <SamB> yes, parsers.
15:50:45 <rtougher> Funny, I was looking at the Happy library last night.
15:50:58 <SamB> Parsec is neat
15:51:59 <shapr> If you've written a library of matrix functions, I assume you've already read a bit about Haskell?
15:52:37 <shapr> Have you already found useful sites like the HaskellWiki, and the learning page on haskell.org?
15:52:38 <rtougher> Yes, I read through a bunch of online documentation. Haskell Report, Tutorial, etc.
15:53:13 <rtougher> The haskell wiki is great. this afternoon I found the "quotes" page, and I thought to myself "who's this shapr guy?". And, well, here you are :)
15:53:18 <shapr> hehe
15:53:24 <shapr> I am that shapr guy!
15:53:27 <shapr> It's true!
15:53:35 <rtougher> The wiki has a lot of great information for beginners.
15:53:37 <SamB> hehe
15:53:41 <rtougher> :)
15:54:04 <SamB> shapr: who else would you be, with a name like that?
15:54:12 <shapr> Just me.
15:54:52 <__mordechai> \u041d\u0438\u043a\u0438\u0442\u0430 \u0421e\u0440\u0433\u0435\u0435\u0432\u0438\u0447 \u041c\u0438\u0445\u0430\u043b\u043a\u043e\u0432
15:54:56 <shapr> So, do you have any particular questions about the good and bad points of Haskell?
15:55:15 * shapr suspects that was spam for google to index.
15:56:04 <__mordechai> no hsapr, sorry
15:56:08 <__mordechai> shapr*
15:56:16 <__mordechai> it was cyrillic and some typos
15:56:32 <__mordechai> (for an other channel anyway)
15:56:44 <rtougher> What makes Haskell particularly good at writing parsers?
15:57:07 <shapr> The monadic interface really.
15:57:22 <shapr> And the monadic interface isn't specific to Haskell at all.
15:57:32 <SamB> shapr: it isn't?
15:57:39 <SamB> what other languages have it?
15:57:40 <shapr> Nope, it's just an abstraction like 'objects'
15:57:46 <rtougher> See, I haven't figured out monads yet.
15:57:54 <rtougher> I haven't tried, really.
15:58:06 <shapr> There are monad implementations in scheme, perl, and some of the ML flavors.
15:58:09 <mwc>  rtougher understanding monads seems to be similar to achieving enlightenment
15:58:27 <SamB> rtougher: they are how a pure functional language like haskell can also be imperative, without being contradictory.
15:58:41 <mwc> See, that even sounds like a bloody Zen koan
15:58:47 <shapr> The monadic interface is *really* simple. The hard part is figuring out everything you can *do* with it.
15:58:57 <SamB> of course, I'm sure haskell is contradictory anyway, but in other ways
15:59:17 <shapr> Actually, side-effects don't contradict referential transparency.
15:59:25 <shapr> You can have both at the same time.
15:59:52 <shapr> But that's probably for a later lesson.
16:00:13 <rtougher> The same function can be both referentially transparent and contain side effects?
16:00:29 <shapr> err, sort of.
16:00:32 <mwc> shapr, will it require me to buy an orange robe and shave my head?
16:00:44 <SamB> why orange?
16:00:47 <shapr> No, but the unicycles are half price during such a lesson.
16:00:57 <mwc> SamB, I'm apeing Bhuddist munks
16:00:59 <mwc> *monks
16:01:54 <shapr> referential transparency just means "work like a math function, every output is entirely described by the input"
16:02:28 <shapr> Ya know, I'm not sure I'm awake enough for this discussion.
16:02:42 * SamB is somewhat surprised to note that the process that is using the most memory is CC1, and not GHC as he had suspected
16:02:48 <rtougher> Heh heh. Maybe we should stick with orange robes and head shavers. ;)
16:02:57 <mwc> shapr, that's okay, I realized that there's no such thing as a sideeffect
16:03:23 <shapr> rtougher: If you want to see the power of monadic parsers, try the Parsec tutorial - http://www.cs.uu.nl/~daan/download/parsec/parsec.html
16:03:24 <mwc> as long as you allow the input and output vectors to be a Hilbert-space like description of the entire computer
16:03:25 <SamB> mwc: next you will tell me that time flows not
16:03:59 <mwc> Side effects only arise as a narrowing of your input and output space
16:04:02 <SamB> rtougher: you probably already have Parsec itself, FYI
16:04:10 <shapr> Right, Parsec comes with GHC.
16:04:18 <rtougher> Will do, shapr. Besides parsing, what other problems is Haskell good at solving?
16:04:23 <SamB> mwc: if there is no side, there can obviously be no side effects
16:04:56 <mwc> If you have the input space I that is the entire computer and then O is the entire system, and then I' and O' are the explicit variables, then a sideeffect is merely an imperfect projection from I?O -> I'?O'
16:05:12 <mwc> did I just use linear algebra?!
16:05:14 <yaarg_> funtional progrmaming is hard :(
16:05:33 <mwc> rtougher, I was really skeptical of it too
16:05:35 * yaarg_ has an exam on fp in a few days and is very,very worried :-(
16:05:43 <shapr> Haskell has a reputation for being good for parsers, compilers, and language implementations in general. I'd say that's true.
16:05:57 <mwc> but when I actually understood the quick sort example that get' passed around like a $5 whore
16:06:05 <mwc> I realized that it was absolutely divine
16:06:29 <mwc> It required me to stop thinking in terms of turing machines and in terms of lambda calc
16:06:49 <mwc> which just removed a translation step as far as I'm concerned, since I'm an applied mathematician
16:07:06 <mwc> so the short answer is that I think haskell is better for writing down algorithms
16:07:09 <shapr> One of the neat tools you get is the type system. With Java and other statically typed languages, I was not impressed with the type system. But Haskell has really got something cool.
16:07:13 <SamB> but Self's directed resends are a real puzzler... I can't figure out how to not have the identifier part mistaken for a send...
16:07:17 <rtougher> I'll admit that moving away from imperative thinking was difficult.
16:07:31 <mwc> assuming you think in mathematical terms
16:07:53 <mwc> rtougher, I think you'll find that you've just gotten used to translating into imperitave terms to feed into the computer
16:08:07 <yaarg_> yeah that's what i'm finding hard
16:08:08 <shapr> mwc: Do you have the rabhi and lapalme FP Algorithms book?
16:08:20 <yaarg_> i can program in C, Java and Perl well
16:08:24 <mwc> shapr, no, Cormen's Introduction to Algorithms
16:08:41 <mwc> I'm not a computer scientist at all really, I'm a theoretical physics major
16:08:47 <shapr> From what you've said, I think you'd like the rabhi & lapalme book.
16:08:54 <mwc> but applied math is sort of a jack of all trades discipline
16:08:54 <rtougher> Thanks for helping guys. I'm going to experiment with Parsec and the monadic interface. I may drop in if I've got questions.
16:08:59 <mwc> shapr, I'll look into it
16:09:09 <shapr> rtougher: if you ask me when I'm awake, I can give you a lot more info.
16:09:14 <rtougher> Ha ha.
16:09:16 <shapr> Sadly, I'm rather slow today.
16:09:19 <SamB> there are actually people who can program in perl well? will wonders never cease?
16:09:50 <beschmi> i think it's nice that you can write down the obvious solution first, and have a good chance of optimising the critical code without dropping to C (compared to
16:09:55 <shapr> rtougher: you may want to read the first issue of The Monad.Reader as well, might be interesting.
16:09:58 <beschmi> eg Python or Perl)
16:10:09 <yaarg_> some things are easier though, like trees
16:10:15 <shapr> Anyway, nice to meet you, I hope to see you again.
16:10:36 * shapr is floating in the half-asleep world of fuzz
16:10:39 <rtougher> Thanks shapr. Night guys.
16:10:46 <SamB> in haskell, you don't have to write your C in C anyway.
16:10:57 <mwc> shapr, I've added it to my amazon.ca wish list, I'll grab it when I get payed
16:11:37 <shapr> mwc: oh, I reviewed it shortly on sequence.complete.org, I'll get the url.
16:12:02 * SamB wonders why compiling FXT is using so much RAM today
16:12:16 * SamB does not remember if it did before or not
16:12:23 <shapr> mwc: http://sequence.complete.org/node/17
16:12:43 <SamB> s/FXT/HXT/
16:13:05 * SamB does not think there is anything to compile in advance for FXT ;-)
16:13:11 <shapr> FXT?
16:14:15 <SamB> it seems to be a bunch of (barely) C++ header files that define a bunch of inline functions
16:14:36 <SamB> though I've only looked at the bit-twiddling ones
16:16:43 <shapr> SyntaxNinja: you should really tell him to code or shut up.
16:16:49 <Lemmih>  /me yarns.
16:16:56 <Lemmih> Good morning, #haskell.
16:17:01 <shapr> good night Lemmih
16:17:04 * shapr is about to fall over
16:18:38 <Lemmih> Talking about alex?
16:19:42 <shapr> I am, yes.
16:20:10 <shapr> I'm easily frustrated though, so maybe I'm overreacting.
16:21:20 <Lemmih> I don't think you're overreacting. He has said so many wrong things that it's not even funny anymore.
16:22:20 * Lemmih is off to find food.
16:22:39 <SyntaxNinja> hi Lemmih
16:22:42 <SyntaxNinja> shapr: yeah.
16:23:22 <SyntaxNinja> shapr: I'm going to limit myself to contradicting him when he makes random assertions like 'well actually -hide-packages isn't useful for some extremely complex reson that most readers won't understand'
16:23:47 <SyntaxNinja> I just want to go on record disagreeing so that people don't get the wrong impression.
16:23:52 <shapr> Yeah, I dig.
16:24:01 <shapr> I just gave up on extremeperl about going on the record.
16:24:25 <SyntaxNinja> I made the mistake last time of engaging him far too directly, but I think I was more worried back then because we didn't have as much code, and I didn't want to get derailed by lack of consensus
16:24:44 <SyntaxNinja> or the appearance of lack of consensus
16:24:46 <beschmi> http://homepages.inf.ed.ac.uk/wadler/linksetaps/ slides from the Links meeting
16:24:48 <shapr> Now you have ghc requiring Cabal, and that really helped.
16:24:57 <Lemmih> SyntaxNinja: Hackage (on shaprs server) will soon be able to upload packages. I just have to change the config file a little.
16:24:58 <shapr> beschmi: excellent! thanks!
16:25:25 <SyntaxNinja> Lemmih: sweet!
16:25:38 <beschmi> shapr: there is also a demo with code
16:25:42 <shapr> Is postgresql working for you guys?
16:27:05 <SyntaxNinja> shapr: at this point, I'm not even really undersatnding alex's posts anymore, I"m afraid, but the ones I have understood are based on flawed understanding about the way things work.
16:28:19 <shapr> I read the first one.
16:28:30 <shapr> some months back...
16:29:55 <mg_> Hi. Anyone saw haskell jabber protocol library ? ;)
16:30:15 <shapr> I haven't seen one, but you could use HXmlToolbox or HaXml to start one.
16:32:20 <mg_> well i wanted to start with haskell by writing jabber bot ;p
16:32:40 <shapr> That sounds like a good project.
16:32:46 <bd_> Is there a way to make Parsec.Token newline-sensitive?
16:34:06 <SamB> bd_: in what sense?
16:35:05 <SamB> bd_: in any case, the source for Parsec.Token should be interesting
16:35:55 <bd_> SamB: In the sense I don't want my expressions to extend across a newline
16:39:09 <bd_> hm, it seems it isn't possible; I'll have to write my own tokenizer
16:39:49 <SamB> bd_: hold on just a second there!
16:40:42 <bd_> Well, I could hack the source for it - is that allowed if my code is under GPL?
16:41:13 <SamB> -- License     :  BSD-style (see the file libraries/parsec/LICENSE)
16:41:41 <SamB> so yes
16:41:48 <bd_> okay
16:41:49 <bd_> thanks
16:43:02 * SamB wonders why the whitespace isn't redefineable in Parsec.Token -- nobody wanted it before?
17:15:15 <aheller> ]\
17:15:22 <aheller> ww, sorry
17:15:26 * SamB considers trying to force GHC to use gcc 2.95 when for -fvia-C, in an attempt to reduce RAM/swap usage...
17:26:34 <TheHunter> @seen dons
17:26:34 -thbot(~thbot@p54AB0941.dip0.t-ipconnect.de)- dons is in #haskell. I don't know when dons last spoke.
17:26:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons is in #haskell. Last spoke 7 hours 50 minutes 59 seconds ago.
17:59:38 <Lemmih> Hurrah.
18:38:14 <dons> moin
18:38:20 <Lemmih> Morning.
18:39:20 <mwc> moin?
18:40:50 <dons> moin moin
18:41:45 <mwc> I just get reference to a wiki system and a Pakistani artist
18:41:59 <dons> hehe. the wiki is pretty famous now.
18:42:03 <mwc> Also, an Iranian singer living in sweden
18:42:06 <mwc> dons, google
18:42:33 <Lemmih> Isn't it German for "good morning"?
18:43:13 <dons> or just 'good day', almost even 'hi' - used at any time of the day
18:43:19 <dons> moin moin for emphasis
18:43:23 <mwc> Ah
18:43:39 <mwc> As we say in my native tongue: Eh.
18:43:53 <mwc> Canadians use that pretty much as a swiss-army knife expresison
18:44:09 <monochrom> eh?
18:44:12 <mwc> eh?
18:44:15 <mwc> yeah, eh?
18:44:19 <monochrom> hahahahha
18:44:55 <mwc> monochrom, you have to be used to the word to understand it, it's 90% pronounciation
18:45:34 <monochrom> I'm among Canadians.  I know.  Actually, I think I understand it by having Americans explain it to me.
18:53:38 <dons> there's nothing better than reading really good patches in your inbox at breakfast
18:53:48 <dons> esp. when breakfast is chocolate cake
18:53:54 <dons> :}
18:57:58 <mwc> hehehe
19:01:10 <dons> wow. inria wants to employ a ghc hacker for post-doc work.
19:20:43 <dons> @quote
19:20:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prelude.(!!): negative index
19:20:45 <dons> @quote
19:20:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prelude.(!!): index too large
19:20:48 <dons> @quote
19:20:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prelude.(!!): index too large
19:20:52 <dons> hmm :/
19:22:15 <dons> @quote
19:22:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Prelude.(!!): index too large
19:23:28 <dons> sorry for that.
19:24:14 <dons> :/ grr.
19:28:53 <dons> @quote
19:28:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- HavocPennington says: Haskell is the least-broken programming language available
19:28:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- today.
19:28:57 <dons> @quote
19:28:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- hakko says: most programmers have a lot of religious issues about their
19:28:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- work, yes.
19:29:02 <dons> @karma TheHunter
19:29:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter has a karma of 0
19:29:07 <dons> @karma+ TheHunter
19:29:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter's karma has been incremented
19:29:24 <dons> @quit
19:29:33 <dons> @karma TheHunter
19:29:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter has a karma of 1
19:29:37 <dons> :D
19:29:49 <dons> now no one can escape hehehe
19:29:52 <Lemmih> Hurrah.
19:34:05 <dons> TheHunter gets much karma for implementing persistence in lambdabot. :)
19:35:37 <KrispyKringle> so i want to generate a graphviz file, run graphviz on it, and then include the resulting image in a WASH CGI. The first and last parts there sound easy enough, but how do I exec graphviz and get back the result in some reasonable manner?
19:35:48 <KrispyKringle> Anyone? Thanks.
19:36:31 <dons> how is the result emitted from graphviz?
19:36:35 <dons> stdout, write to a file?
19:37:20 <KrispyKringle> well, im not sure what options there are. if i can get it to output to stdout, can i capture that and use it internally (since WASH supports including internally-generated images)?
19:37:44 <dons> easier is if it just writes to file, then you can use
19:37:51 <dons> @type System.Cmd.system
19:37:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- System.Cmd.system :: String -> IO GHC.IOBase.ExitCode
19:38:12 <KrispyKringle> ah
19:38:38 <KrispyKringle> Yeah, but then I have to manage filenames in some reasonable way, in case of concurrent users.
19:38:41 <dons> if you want to read back the stdout, you need:
19:38:42 <KrispyKringle> *shrug*
19:38:43 <dons> @type System.Process.runInteractiveProcess
19:38:44 <KrispyKringle> uits not the end of the world.
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- System.Process.runInteractiveProcess :: FilePath
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                         -> [String]
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                         -> Maybe FilePath
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                         -> Maybe [(String, String)]
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                         -> IO (GHC.IOBase.Handle,
19:38:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                GHC.IOBase.Handle,
19:38:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                GHC.IOBase.Handle,
19:38:48 <KrispyKringle> ah
19:38:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                System.Process.Internals.
19:38:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ProcessHandle)
19:39:02 <dons> a reasonable way with files is to use mkstemps
19:39:10 <KrispyKringle> ah, nice.
19:39:18 <dons> there's a complete implementation here:
19:39:18 <KrispyKringle> not something i'd have expected Haskell to have, to be honest ;)
19:39:20 <KrispyKringle> yeah
19:39:24 <KrispyKringle> ?
19:39:42 <dons> http://www.cse.unsw.edu.au/~dons/yi/Yi/MkTemp.hsc
19:40:00 <KrispyKringle> nice
19:40:02 <KrispyKringle> thanks
19:40:07 <dons> mkstemps :: FilePath -> Int -> IO (Maybe (FilePath,Handle))
19:40:41 <KrispyKringle> looks like i can do stdout or files. hrm.
19:40:51 <dons> you can do either, yes.
19:41:22 <dons> System.Process is 6.4 only, for 6.2.2 you need Posix.popen. There's a compatibility layer in lambdabot/PosixCompat.hs
19:41:23 <KrispyKringle> ok, ill cogitate on this a bit. thbanks :)
19:41:27 <dons> @version
19:41:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p206, GHC 6.4 (OpenBSD i386)
19:41:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:41:31 <KrispyKringle> hrm
19:41:31 <dons> here.
19:41:46 <KrispyKringle> hehe
19:42:06 <KrispyKringle> does lambdabot supports a silly-quotes feature? :P
19:42:38 <dons> silly quotes. not yet. you mean like @silly KrispyKringle "foo bar" ?
19:46:49 <KrispyKringle> yeah
19:46:50 <KrispyKringle> exactly
19:47:07 <KrispyKringle> it's a proud IRC tradition :P
19:47:31 <dons> well, @quotes includes silly quotes, I guess.
19:47:33 <dons> @quote ghc
19:47:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Info table already?
19:47:48 <dons> @quote desrt
19:47:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   man... there's this whole dark side to haskell that dr. kahl didn't teach
19:47:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- us in 3e03
19:48:00 <KrispyKringle> what's the argument?
19:48:16 <dons> the nick.
19:48:19 <KrispyKringle> oh
19:48:22 <dons> no nick gives you a random quote.
19:48:25 <dons> @quote
19:48:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Gahhh says: monads are usually a personal experience.
19:48:33 <KrispyKringle> cool :)
19:48:33 <dons> @help quote
19:48:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @quote [nick] - quote somebody randomly
19:49:18 <KrispyKringle> @help
19:49:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  @help <command> - ask for help for <command>
19:49:23 <KrispyKringle> oh
19:55:32 <SamB> how do silly quotes normally work?
19:55:51 <SamB> @quote shapr
19:55:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Windows users are like the wives of alcoholics, they'll take any amount
19:55:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- of abuse and come right back.
19:56:13 <SamB> hmm, that one is silly all right ;-)
19:56:28 <SamB> how would a mere bot know if a quote was silly or not?
19:56:46 <dons> it doesn't. the ai module isn't that developed yet.
19:57:21 * SamB half expects someone to start spouting through lambdabot about how lambdabot is no mere bot
19:57:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I am not mere bot
19:58:02 <SamB> dons: what AI module? I see nothing like that in the repo!
19:58:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- It's unsurprising that I'm now sentient
19:59:17 <dons>  there's no AI module. jokes folks.
20:02:34 * SamB looks on meme to see what transpired after he lost connectivity
20:03:33 * SamB suspects he would get better results looking at the logs for #haskell than those for #lisp
20:05:37 * SamB discovers that it is already tomarrow wherever clog and/or meme is
20:06:30 <SamB> dons: Even if there *was* an AI module, it would *still* be a joke.
20:06:55 <dons> true. there's actually an eliza module  - vixenlove, by blackdog. I'm going to import it soon.
20:09:01 <blackdog> dons: i found a bug in it - needs to set case-insensitivity on the regexes.
20:09:10 <blackdog> send a patch, i know, i know
20:10:27 <dons> I haven't received any vixenlove code yet. did you darcs send anything?
20:10:40 <dons> or is it trapped in a sendmail realm of hell
20:11:14 <blackdog> yeah, i think so.. i'll send again. that dynamic-depends thing killed my copy of lambdabot, though
20:11:29 <dons> there's @karma points for anyone submitting a patch to lambdabot, btw ;)
20:11:39 <blackdog> ooh, goody. :)
20:11:42 <dons> blackdog, maybe just edit Depends.hs by hand.
20:12:36 <SamB> dons: do I get them even though karma was ephemeral when I submitted mine?
20:13:15 <dons> ah, true. I'll provide points for those who've submitted.
20:13:38 <SamB> oh, and do you think a .ghci file or {-# OPTIONS #-} pragmas everywhere is a more appropriate means to make GHCi usage less annoying?
20:14:08 <blackdog> dons: that typeOf script you sent to pls - any reason you didn't include the -cpp flag?
20:15:20 <dons> SamB: I replied on this matter. I think a make target: ghci: where the cmd is : ghci $(HC_OPTS) $(PKG_FLAGS) Main.hs for example
20:15:25 <dons> check the log for my full response
20:15:47 <dons> blackdog - yeah, it was silly. latest script:
20:15:48 <dons> FILE=$*
20:15:48 <dons> DECL=`cat`
20:15:48 <dons> ID=`echo $DECL | sed 's/^\([^ ]*\).*/\1/'`
20:15:48 <dons> echo ":t $ID" | ghci -Onot -v0 -cpp -fglasgow-exts -w $FILE
20:15:50 <dons> echo $DECL
20:16:05 <dons> there's still a problem with -package deps though.
20:16:07 <blackdog> okeydoke. handy little proggy, that.
20:16:20 <SamB> I suppose that would work well enough...
20:16:42 <dons> I'd like to stick them on the cmd line arg. :typeOf posix %
20:17:05 <blackdog> what would that mean?
20:17:14 <dons> blackdog, yeah. surprising. I don't even type decls my self now.
20:17:47 <dons> for your .vimrc: :map ty :.!typeOf %^M
20:18:10 <dons> oh, I'd like to add -package foo args if necessary.
20:18:21 <dons> otherwise some modules can't be typed for no good reason.
20:21:41 <dons> @karma+ shapr
20:21:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- shapr's karma has been incremented
20:21:56 <dons> @karma+ Heffalump
20:21:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Heffalump's karma has been incremented
20:22:12 <dons> @karma+ ddarius
20:22:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ddarius's karma has been incremented
20:22:23 <blackdog> @karma Heffalump
20:22:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Heffalump has a karma of 1
20:22:25 <dons> @karma+ jlouis
20:22:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- jlouis's karma has been incremented
20:22:30 <blackdog> @karma shapr
20:22:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- shapr has a karma of 1
20:22:43 <dons> @karma+ SamB
20:22:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SamB's karma has been incremented
20:23:17 <dons> no karma for blackdog till he submits the patch ;)
20:23:24 <dons> I like this reward and punishment system.
20:23:50 <blackdog> i have to test it first...
20:24:11 <blackdog> what do i put  in the Depends.hs file?
20:24:27 <desrt> welcome to the freakin weekend
20:24:57 <dons> blackdog, probably just getFileRequires "DictModule.o" = [ Object "DictModule/DictLookup.o" ]
20:25:07 <dons> s/Dict/Vixen/ whatever.
20:25:16 <blackdog> dons: yep, just saw it - didn't realise it was repeated for 6.4 and other
20:25:32 <dons> yeah, dependencies change slightly.
20:25:54 <dons> I'm going to kill this off tomorrow, and just run dynamic-depends at the end of the build into a data file
20:26:18 <blackdog> @vixen Do you like Haskell?
20:26:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
20:26:20 -fake_lambdabot(~fake_lamb@202.22.165.237)- Ooh, functional programmers are so hot!
20:26:35 <dons> oh yeah.
20:26:37 <blackdog> Ok. patch coming.
20:26:56 <blackdog> @vixen Where do you live?
20:26:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
20:26:58 -fake_lambdabot(~fake_lamb@202.22.165.237)- Huntington Beach California
20:27:00 <dons> fake_lambdabot: @vixen So Haskel is fun?
20:27:02 -fake_lambdabot(~fake_lamb@202.22.165.237)- I define fun
20:27:07 <SamB> dons: how am I supposed to use a make target with haskell-mode?
20:27:08 <desrt> dons; can you tell me what's the deal with Eq/Ord in Data.Map?
20:27:39 <desrt> does Map decide what internal format it uses based on the type of data you supply it with?
20:28:09 <dons> SamB: oh. emacs. I was thinking: $ make ghci, would run ghci with the right args. not sure about emacs.
20:28:22 <dons> couldn't you just write a little lisp thingo that supplies the right args to ghci?
20:28:55 <blackdog> dons: sent, let me know if you don't get it reasonably soon
20:28:59 <SamB> sounds complicated...
20:29:24 <dons> what you're asking for is a little complicated, as it requires duplication of build system values.
20:29:35 <blackdog> @vixen Didn't you used to be written in Visual Basic?
20:29:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
20:29:37 -fake_lambdabot(~fake_lamb@202.22.165.237)- Can you really catch syphilis from Visual Basic?
20:29:46 <dons> and you're going to need -package flags no matter what. they don't go in pragmas.
20:29:58 <dons> all we can put in pragmas is -cpp -fglagsow-exts
20:29:58 <SamB> dons: point.
20:30:17 <dons> s/all we/all that would be useful for us/
20:32:11 <dons> desrt: not sure. check the src.
20:32:16 <dons> instance (Ord k, Ord v) => Ord (Map k v) where
20:32:16 <dons>     compare m1 m2 = compare (toList m1) (toList m2)
20:32:20 <dons> instance (Eq k,Eq a) => Eq (Map k a) where
20:32:20 <dons>   t1 == t2  = (size t1 == size t2) && (toAscList t1 == toAscList t2)
20:32:54 <blackdog> dons: argh. my fault. not set up properly yet... *shame*
20:33:55 <desrt> dons; more refering to the fact that the restrictions on the acceptable types of keys seem to have been loosened
20:34:14 <desrt> FiniteMap required Ord.  Eq seems acceptable with Data.Map, but only sometimes.
20:34:37 <desrt> source is a good place to look, though :)
20:37:09 * SamB looks at ghci source to see how builtin commands are defined, sees that they are not defined with the same type as user-defined ones
20:39:16 * SamB discovers that user-defined ghci commands can indeed expand to contain other ghci commands
20:41:02 <SamB> @type system
20:41:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
20:41:11 -fake_lambdabot(~fake_lamb@202.22.165.237)- bzzt
20:42:11 <dons> @type System.Cmd.system
20:42:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- System.Cmd.system :: String -> IO GHC.IOBase.ExitCode
20:42:14 -fake_lambdabot(~fake_lamb@202.22.165.237)- System.Cmd.system :: String -> IO GHC.IOBase.ExitCode
20:44:36 <SamB> okay, what module is the function for getting the output of a command in?
20:45:16 <dons> scroll up to see a discussion with KrispyKringle on this -- System.Process ;)
20:46:27 <SamB> and which package is it in?
20:47:10 <dons> base.
20:47:21 <dons> in 6.2.2 you need Posix.popen, in "posix"
20:47:42 <SamB> oh, I see.
20:48:05 <SamB> don't suppose lambdabot has a wrapper for it?
20:48:15 <blackdog> dons: how do you resend patches? postfix ate the ones i sent you.
20:48:28 <SamB> and if it did, I wouldn't have the args set in ghci yet anyway...
20:48:50 <dons> darcs send shouuld work
20:49:02 <dons> SamB: yes. PosixCompat
20:49:09 <blackdog> no recorded local changes... i've sent them already, y'see...
20:49:28 <dons> hmmm... but it should still diff against the remote repo.
20:49:37 <dons> darcs changes | less ?
20:49:38 <blackdog> ...argh. my fault. too embarrassing to say what
20:49:59 <blackdog> gone
20:50:06 <blackdog> sent, i mean
20:50:18 <blackdog> @vixen I'm an idiot, aren't I?
20:50:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
20:50:19 -fake_lambdabot(~fake_lamb@202.22.165.237)- If you see this, gentle sir, know that you are being trolled by a poorly
20:50:19 -fake_lambdabot(~fake_lamb@202.22.165.237)- configured VixenLove program
20:50:29 <blackdog> yowch. That's not good...
20:53:19 <dons> got it  blackdog. thanks.
20:54:04 <blackdog> @vixen I'm an idiot, aren't I?
20:54:05 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
20:54:06 -fake_lambdabot(~fake_lamb@202.22.165.237)- don't be so hard on yourself!
20:55:04 <blackdog> one more, don - had an error in the config file
21:03:22 <SamB> dons: I came up with something rather different that should work okay
21:04:47 <SamB> it should be in your inbox by now
21:08:47 <dons> that's pretty cool SamB, thanks.
21:10:53 <hellish> matchRegex (mkRegex ".*") "foo" returns Just [], am I just doing something stupid or have I found a bug?
21:11:29 <SamB> yeah, I learned about that when I was sick of having to dig stuff out of modules to change directories. my ~/.ghci file defines :pwd and :cd commands for this purpose.
21:16:25 <SamB> hellish: try it with parentheses around the .*?
21:17:00 <hellish> SamB: shouldn't it return Nothing if it fails though?
21:17:33 <SamB> hellish: I assume so
21:17:39 <hellish> that worked...
21:18:39 <SamB> It seems to return only explicit groups, no implicit "group 0" like in certain other regex libraries in other languages...
21:21:00 <hellish> Oh, it returns Just the list of subexpression matches, or Nothing if the pattern doesn't match at all.
21:22:53 <Lemmih> Phew.
21:23:14 * Lemmih just pushed the first step towards cabal-get.
21:24:23 * hellish cheers
21:25:36 <blackdog> df
21:25:49 <blackdog> ... uh, sorry
21:26:33 <heatsink> /dev/hda1 16205M Used 12M Free
21:27:43 <blackdog> man, and i thought i was hard-done by with only 3 gigs left...
21:29:16 <heatsink> unless you store video, 3 extra gigs should be plenty...
21:38:48 <blackdog> music takes a fair whack of space, too.
21:44:58 <heatsink> under 1M per min tho...
21:45:48 <hellish> that depends on the encoding. FLAC for me averaged 1000 kbps.
21:46:05 <hellish> Vorbis at really high quality was 1/4 that
21:46:45 <heatsink> Isn't FLAC lossless?
21:47:14 <heatsink> yea.
21:47:26 <hellish> That would be why it costs so much
21:47:35 <hellish> in space
21:47:59 <heatsink> oh those costly space-age codecs.
21:49:38 <hellish> heatsink: you win one chuckle.
21:52:49 * hellish finds out that matching regexps in Haskell only returns the first subexpression match.
21:53:49 <heatsink> lossless image compression is below 1:3 for typical images.
21:58:07 <dons> @type Text.Regex.matchRegexAll
21:58:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Text.Regex.matchRegexAll :: Text.Regex.Posix.Regex
21:58:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                             -> String
21:58:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                             -> Maybe (String, String, String, [String])
21:58:51 <dons> last arg is all subexpression matches
22:00:01 <hellish> dons: not for me it isn't.
22:00:09 <hellish> *Main> matchRegexAll (mkRegex "(a)") "aaa"
22:00:09 <hellish> Just ("","a","aa",["a"])
22:02:46 <dons> hmm :/
22:02:54 <hellish> I think it returns all the subexpression matches, but only from the first regexp match. So, matchRegex (mkRegex "(.)(.)(.)") "aaa" returns ["a","a","a"] but only matches once
22:03:21 <dons> oh, yeah. true.
22:03:30 <dons> I think this is known too.
22:04:40 * hellish writes a helper function
22:05:40 <dons> Prelude Text.Regex> splitRegex (mkRegex ":") "a:a:a"
22:05:46 <dons> ["a","a","a"]
22:05:56 <dons> Text.Regex gets useful in 6.4 :;)
22:23:16 <blackdog> dons: where's my karma? :)
22:24:52 <dons> @karma+ blackdog
22:24:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been incremented
22:25:23 <Lemmih> @seen SyntaxNinja
22:25:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen SyntaxNinja
22:32:28 <blackdog> dons: did it work, btw?
22:34:36 <dons> haven't applied it yet - busy hacking up assignment release
22:34:54 <blackdog> which course?
22:35:22 <dons> 3161
22:35:57 <dons> getting a type checker into shape.
22:36:41 <Arafangion> dons, Do all american uni's use the same course numbers?
22:36:57 <dons> don't know.
22:37:00 <dons> doubt it
22:37:09 * dons lives in .au anyway
22:37:15 <Arafangion> dons, So why do people always refer to their course as "3161"?
22:37:37 <dons> oh, I'm talking to blackdog, who knows the course codes at my uni
22:37:59 * Arafangion doesn't even know his own course code.
22:38:13 <blackdog> 3161 is Gabi's course, right?
22:38:21 <dons> yeah.
22:38:32 <Arafangion> dons, Isn't it easier to just say "Eng in SE"? (THat's my course)
22:38:46 <blackdog> it's a complicated course name. :)
22:39:22 <Arafangion> blackdog, How complicated can they get? :)
22:39:36 <Arafangion> Mine's "Bach Eng specializing in SE"
22:40:25 <dons> anyway, you're talking about a degree name. I'm talking about a subject name
22:40:29 <blackdog> actually, it's not so bad. but 'course' means an individual subject in oz
22:40:34 <dons> which are also known as 'course's
22:41:02 <dons> 3161 == Concepts of Programming Languages, fwiw
22:41:26 <Arafangion> Ahh, that's what I'd say is a _subject_, not a course.
22:42:02 <blackdog> it's tomahto, dammit
22:42:25 <Arafangion> No, it's tomarto!
22:42:38 <Arafangion> (Idiot)
22:43:03 <Arafangion> ;)
