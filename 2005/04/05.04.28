00:00:46 <JohnMeacham> Yay. squashed nasty bug.
00:01:44 <Gahhh> write a unit test to celebrate
00:02:16 <jesse99> write a unit test before you fix the bug :-)
00:03:38 <Gahhh> can you prove with denotational semantics that you fixed a bug ?
00:04:21 <jesse99> can you automate a proof so that you can do regression testing?
00:05:33 <reffie> AKS sucks :P
00:06:11 <Gahhh> well, next time you edit the code, you will have to prove it again.
00:08:20 <reffie> my version is much faster than the ruby version i found online, it seems.
00:08:41 <jesse99> ruby is awfully slow
00:09:20 <reffie> yeah
00:10:03 <jlouis> Ruby is slower than Haskell I would think. Which is kind of funny, since people would claim the opposite
00:10:37 <jesse99> ruby must be an order of magnitude slower than c++, isnt haskell more like 2x as slow?
00:10:43 <dons> people would?
00:10:46 <Gahhh> Those people need to see the language shootout pages then.
00:12:24 <Gahhh> I think haskell versus java/c# in speed is more relevant
00:17:16 <vegai> haskell's weakness is more in the runtime space consumption, or that's the general belief
00:17:25 <reffie> 371.96s user 1.53s system 76% cpu 8:07.22 total
00:17:26 <reffie> to test every number from 100 to 500
00:17:27 <reffie> :/
00:43:41 <jlouis> Gahhh: those people do not believe in the language shootout
00:44:01 <jlouis> They only care for ``odd academic language''
00:44:13 <jlouis> ``I don't understand recursion''
00:44:15 <jlouis> etc.
00:45:20 <Gahhh> They don't understand OO either. That didn't stop them from trying to use it ;)
00:47:21 <jesse99> but they thought they understood oop...
00:47:43 <Gahhh> so the trick is to make them *think* they understand FP ;)
00:47:58 <jesse99> maybe :-)
00:48:48 <jlouis> Gahhh: I am pretty sure I do not understand many aspects of OO. I have seen operational semantics for some of the constructs and those I would say I understand.
00:49:14 <jlouis> Sometimes it just seem they are building an ivory tower of design patterns.
00:49:46 <Oejet> jlouis: I second that.
00:49:59 <dons> I think that would be the general opinion of the fp community :)
00:50:08 <tuomov> building the silver bullet atom by atom.. only the gunpowder is missing
00:52:24 <Gahhh> and then there's aspect oriented programming, which I have no clue about.
00:52:53 <Gahhh> maybe a name change is all that is needed: haskell oriented programming or something...
00:53:47 <tuomov> objective oriented programming..
00:57:18 <nlv11757_> when parallelizing loops iterations....control dependencies dont play any role anymore i think
00:57:56 <nlv11757_> just loop carried dependencies (and side effects)
00:58:33 <jlouis> Oh, that reminds me. In Appels ``Modern compiler implementation in ML'', the chapter of Objects starts out with the quote: ''To object - to feel distate for something''
00:58:38 <jlouis> I am not kidding you ;)
00:59:08 <jlouis> chapter on Objects
00:59:36 <dons> oh, that's too funny.
01:00:06 <jlouis> Oh, I am misquoting
01:00:18 <jlouis> it is not ``To object'' only: ''Object - ...''
01:00:38 <jlouis> heh
01:22:31 <JohnMeacham> If you want to see what running jhc is like, but don't feel like running it. This is a compile of hello world with both intermediate forms printed out http://repetae.net/john/computer/jhc/jhc-out.html
01:27:49 * boegel bounces
01:41:30 <jlouis> JohnMeacham: if it has a pretty well-built make-environment, I'll probably look at getting it into NetBSD as a package
01:41:43 <jlouis> ... After I have ported ghc, that is, heh
01:43:52 <JohnMeacham> jlouis: probably not too much point as it is mainly useful to people who want to hack on its internals at the moment.
01:44:31 <jlouis> JohnMeacham: Ah, ok.
01:44:34 <JohnMeacham> jlouis: I know someone got it to work on OpenBSD. there were some issues with wide character support though.
01:44:43 * jlouis points at dons 
01:44:47 <jlouis> probably him, heh
01:45:29 <jlouis> OpenBSD has far better support for Haskell than NetBSD due to Don Stewart working on it
01:46:05 <reffie> FreeBSD.
01:46:19 * JaffaCake likes FreeBSD
01:46:30 * reffie likes FreeBSD too
01:46:47 <JaffaCake> I think I like FreeBSD 4.x more than 5.x, though
01:46:49 <jlouis> Isn't FreeBSD part of the ghc development effort as a target? I believe it is so
01:46:56 <reffie> uuuh, jlouis why?
01:47:00 <reffie> err JaffaCake
01:47:08 <jlouis> JaffaCake: check out dragonflybsd then. It might prove interesting
01:47:14 <reffie> 5.x is so much better.
01:47:29 <JaffaCake> Yes, I think dragonfly might have a more sustainable model
01:47:34 <reffie> jlouis the problem with dfbsd is that there is way too much propaganda around it
01:48:12 <JaffaCake> just, MHO of course, and probably a not very well-informed O at that
01:50:44 <nlv11757_> what arguments could one have to choose freeBSD over a regular linux flavour? security?
01:51:10 <reffie> the fact that it's not written by adolescents?
01:51:16 <dons> hehe
01:53:07 <JohnMeacham> I was going to say hey! but then I remembered I was an adolescent when I worked on the linux kernel :)
01:53:30 <Oejet> :-P
01:56:48 <shevegen> hehe
01:57:33 <reffie> JohnMeacham: what did you work on?
01:59:12 <nlv11757_> not very confincing arguments thus
01:59:19 <nlv11757_> -f+v
02:00:18 <dons> the kernel source is simpler and cleaner in the BSDs, from what I've read of it.
02:01:08 <reffie> yeah, i can never understand anytihng, when i try to read the linux source
02:01:16 <JaffaCake> dons: it definitely is
02:01:31 <reffie> but maybe it's because i don't try hard enough
02:02:08 * JaffaCake really hates the Linux kernel configurator
02:02:26 <boegel> any Dutch people active ?
02:02:38 <boegel> or atleast, people who speak Dutch
02:03:38 <nlv11757_> active as in....
02:04:28 <boegel> active as in willing to reply to my question :)
02:04:48 <jlouis> The primary arguments are: Cleaner source code, more conservative adoption of features, fewer ``distributions'', better documentation, userland+kernel together, one CVS-repository with all in, etc
02:05:01 <jlouis> bug tracking
02:05:02 <jlouis> etc
02:07:20 <u1sf> dons: Have you ever thought of having a plugin archive system in hs-plugin, a little like jar where os, his, meta-data etc. are stored together?
02:08:01 <dons> can you elaborate?
02:09:15 <Si\\> Ok, well let's say I create a plugin that uses three modules
02:09:49 <Si\\> if I compile that, I end up with at least 9 files, and a directory structure
02:10:05 <dons> yeah.
02:10:39 <dons> so I'd archive those into a .a file, and load that in one go.
02:10:55 <dons> this is how yi and lambdabot work, for example.
02:10:58 <Si\\> not neccessarily a .a, but some sort of archive
02:11:02 <JohnMeacham> reffie: It was a long time ago. some scheduling stuff, an http filesystem, the GGI project.
02:11:25 <Si\\> because if it was .a it could only be binary data
02:11:31 <dons> yep. no .hi files.
02:11:37 <reffie> JohnMeacham cool
02:11:38 <Si\\> I might want to store configurations and his
02:11:43 <dons> his?
02:11:49 <Si\\> hi files
02:12:09 <dons> yep. currently you'd do this by creating a normal haskell package
02:12:33 <dons> i.e. a libFoo.a, HSfoo.o and a package.conf pointing to the .hi files
02:12:34 <Si\\> I did something similar a while back, when I created a Haskell application container
02:13:06 <Si\\> essentially it extracted the archive via tar/gz to /tmp and dynlinked them
02:13:16 <dons> yeah.
02:13:19 <dons> that'd be neat.
02:13:21 <mflux> can you dynlink stuff from memory?
02:13:28 <Si\\> that'd be even better
02:13:47 <Si\\> IIIRC someone created a native Haskell compression codec recently
02:13:50 <dons> as plugins are a little lighterweight than the haskell package system
02:14:18 <dons> mflux, we could probably hack the ghc linker to handle that -- it currently mmaps objects already
02:14:46 <mflux> that would be a much cleaner solution
02:15:03 <dons> as dynamically linked systems get bigger (like lambdabot) such an idea becomes attractive
02:15:30 <Si\\> plus, if you store source, plugins could be platform independant
02:16:08 <dons> so more support for make/load
02:16:21 <dons> i think this is really for hs-plugins-v2.
02:18:35 <skew> jesse99: I would not be surprised if many languages were faster than Haskell at string stuff
02:18:54 <skew> jesse99: at least when the Haskell uses [Char]
02:22:07 <skew> welcome back polli
02:22:33 <polli> thank you very much :)
02:30:18 <kowey> any xml-using haskellers out there?
02:30:32 <kowey> i'm using haxml to process some rather large files, but it is dog slow
02:30:55 <kowey> wondering if there are tips and tricks, or better libraries to use, or if i should just go write some sax code in some other language
02:32:40 <skew> kowey: I've never tried working with large files. Is it parsing or processing in particular that is slow, or just everything?
02:33:10 <kowey> i suspect that it's parsing the xml...
02:33:23 <kowey> but actually, another thing i don't know is how to get profiling working with some 3rd party lib like haxml
02:33:28 <skew> Personally I'd say that "rather large xml file" is your problem, but that's not very helpful :)
02:33:31 <kowey> so i can't 100% tell
02:33:36 <kowey> if it helps
02:33:54 <kowey> the task is to convert some tree-shaped data (no joke) from xml into some smaller text format
02:33:55 <skew> you might need to rebuild it yourself
02:34:21 <kowey> and scatter some switches around the makefile?
02:34:31 <kowey> sigh... does this affect performance when profiling is turned off?
02:35:22 <skew> kowey: there should be a lib<packagename>.a for normal operation and a lib<packagename>_p.a for profiling
02:35:29 <kowey> the other thing is that my program works not-so-slow when processing the same data in non-xml, but i guess that's not helpful either
02:35:38 <kowey> skew: ooh! just the answer i was hoping for
02:35:54 <skew> I don't remember exactly where HaXmL goes, but you could check if you have modules like that
02:36:22 * kowey looks
02:36:25 <skew> you might very well need to rebuild anyway if you want to change the cost centres for the profiling in the package
02:36:51 <kowey> well no, i was just hesistant to spend the effort twiddling around with Makefiles
02:36:56 <kowey> if it was going to cost me
02:37:12 <kowey> so your reassurance about there being two separate libs was very helpful
02:37:41 <skew> if you can compile with the profiling flag I think you are already linking against the profiling version
02:38:00 <skew> The profiling version may be designed more for letting your code run with profiling hooks than for profiling the library, though
02:38:13 <kowey> well that's already something
02:38:16 <skew> the User's Guide will inform me shortly
02:38:26 <kowey> because right now i run the haxml stuff in a seperate process
02:38:31 <kowey> just so i can profile the main stuff
02:38:57 <kowey> at least, it would be useful to know if i'm spending x% of my time in haxml... no matter where exactly
02:39:18 <skew> Have you tried building your program with profiling?
02:39:38 <kowey> yeah... but ghc complains
02:39:46 <kowey> and then when i take haxml away, it's happy
02:39:59 <skew> maybe haxml did not build a profiling version of the library
02:40:08 <kowey> yep
02:40:12 <kowey> like you mentioned
02:40:14 <skew> that would not be very nice of the distribution
02:40:30 <kowey> there is a .a, but no _p.a
02:40:43 <kowey> i guess i should do the requisite makefile twiddling and send the author a patch
02:40:52 <skew> Adding -prof to their HSFLAGS shouldn't be too bad, if all else fails
02:41:11 <skew> I think the _p is a naming convention and you don't need to otherwise do anything wierd to the library
02:42:01 <skew> That is, I'm guessing you could hack up the makefile, then just mv /HaXml/build/directory/libHaXmL.a /ghc/lib/dir/libHaXmL_p.a
02:42:31 <kowey> k... i'll look into this after lunch
02:42:46 <kowey> thanks much... i'll work out the profiling stuff and then think about this XML nonsense some more
02:58:19 <skew> hi TheHunter
03:08:18 <boegel> bye TheHunter :)
03:08:43 <nlv11757_> if i have '*ref0' and do 'localref = ref0' and start doing things like '*(localref++)', ref0 will still remain the same right?
03:08:59 <nlv11757_> maybe the thing he's pointing to has changed, but it is still pointing at the same stuff right?
03:09:03 <nlv11757_> address
03:10:33 <tromp> of course, u never changed ref0
03:12:22 <skew> nlv11757_: In here we ask "If I have 'ref :: Ptr Int' and do 'localref <- newIORef ref' and start doing things like 'do x <- peek =<< readIORef newref; modifyIORef (`plusPtr` 1) newref; return x', ref will still remain the same, right?"
03:13:35 <skew> nlv11757_: you have a pointer ref0?
03:13:55 <skew> '*ref0' is confusing me with the dereference syntax
03:16:55 <skew> hi blackdog
03:17:12 <skew> what are you working on?
03:40:53 <blackdog> skew: a haskell web environment. not right now, though - i just saw HHGTTG, and i'm mourning.
03:41:45 <skew> that bad?
03:41:54 <blackdog> worse
03:42:37 <blackdog> they ripped out almost all of his brilliant dialogue and replaced it with a meandering, unconvincing love story. even the dialogue that was in there had all the punch taken out
03:43:07 <blackdog> for instance, that wonderful line about the plans being in a cellar in a locked cupboard behind a sign saying "beware of the leopard"?
03:43:12 <skew> I thought the book wouldn't translate very well, but I was hoping they hadn't ruined it beyond that
03:43:22 <blackdog> It became "They were in the cellar."
03:43:37 <skew> that was the lead in before it got funny!
03:44:05 <blackdog> it was terrible. i'm sure there are worse movies, but i can't think of a more depressing one. it's hard when you actually care about the source
03:44:25 <skew> They didn't even get as far as "... and the stairs were out"
03:44:40 <blackdog> oh! oh!
03:45:03 <blackdog> and they replaced the bit where ford convinces the supervisor to lie down in front of the tractor!
03:45:16 <skew> what?
03:45:23 <blackdog> instead, he gives the workers a beer each and they all slope off! Why? Why would you do that?
03:45:35 <skew> huh?
03:45:57 <boegel> which movie are you guys talking about ?
03:46:08 <blackdog> hitch hiker's guide to the galaxy
03:46:15 <skew> Were the scriptwriters all just stupid?
03:46:20 <blackdog> i am sad and bitter
03:46:47 <blackdog> well, apparently adams wrote some of the script, but i guess being dead doesn't help when trying to get your point across in script meetings
03:47:34 <boegel> never heard about it
03:47:56 <skew> Where do they get off thinking they can do a better job with the scenes than adams?
03:48:09 <blackdog> i don't know.
03:48:34 <blackdog> the final indignity: after the final scene, a little caption comes up saying "for douglas".
03:49:20 <blackdog> boegel: you've read the book, though, right?
03:50:36 <skew> The bulldozer and the leopard have to be some of the most characteristic episodes in the early book
03:51:03 <nailbiter> blackdog: did they leave the giant whale in?
03:51:18 <skew> blackdog: I hope somebody had the good sense to wrap his corpse in cooper wire and stick some magnets around it. You could probably power a few small countries
03:51:39 <blackdog> nailbiter: yes. that bit was voiced by Bill Bailey and was quite cool.
03:51:52 <blackdog> but it was 30 seconds of funny in an ocean of crap
03:52:11 <blackdog> skew: yes, the thought occurred to me also. poor bastard.
03:52:24 <nailbiter> blackdog: oh well. you could wait two decades for a decent remake
03:52:46 <blackdog> it's funny, i wouldn't have minded if they'd just played with the plot. the plot wasn't ever important.
03:52:59 <blackdog> but why would you fiddle with his dialogue?
03:53:25 <blackdog> nailbiter: that's the depressing part. it kills the chances of anything else happening for about that long.
03:53:47 <skew> why do people make bad movies about popular books?
03:54:00 <nailbiter> skew: because movie studios tend to be risk averse
03:54:01 <blackdog> to other things before i get maudlin. Should I learn Lisp?
03:54:20 <skew> it might be fun
03:54:45 <skew> I just know Scheme, but macros can be pretty amusing
03:55:11 <blackdog> true. i suppose what i'm asking is are there any lispers here who could suggest ways in which it's (dare i say it) better than Haskell.
03:55:18 <skew> nailbiter: you would think the safe course of action would be to follow the proven book
03:55:20 <boegel> blackdog: no, I haven't... should I
03:55:37 <blackdog> boegel: yes. it's an absolute classic.
03:55:37 <skew> blackdog: I bet you could find plenty in #lisp
03:55:56 <nailbiter> skew: yeah, i know. but studios have focus groups and marketing people to tell them what's best
03:56:01 <blackdog> yeah, but i don't know how much weight to give to what they say. :)
03:56:06 <nailbiter> skew: it's so tragic
03:56:13 <boegel> blackdog: who wrote it ?
03:56:18 <skew> nailbiter: Lord of the Rings worked out pretty well
03:56:27 <blackdog> boegel: Douglas Adams
03:56:56 <blackdog> skew: yes, but Peter Jackson is a very strange man
03:58:05 <nailbiter> skew: well, Jackson was actually a Tolkien fanatic himself, and managed to gain a carte blanche for the production of the Lord of the Rings ..
03:58:57 <skew> hitch hiker's guide to the galaxy is a strage book
03:59:13 <skew> I don't know what else you should do, but get a bunch of fans to help
04:00:11 <skew> they are your core audience, right?
04:00:33 <nailbiter> dead right. :) maybe it would have been better as a fan-produced movie, like Star Wreck
04:00:46 <skew> blackdog: see what they tell you in #lisp and check out those parts
04:01:07 <blackdog> skew: i don't think so. a major league movie has to attract far more people than those who actually read habitually.
04:01:40 <skew> blackdog: even if they are sadly mistaken about them being better than Hakell, those are still the interesting bits
04:01:50 <skew> blackdog: ask them what's interesting in the language too
04:02:18 <skew> to see what the people who use the language a lot are interested in
04:03:39 <blackdog> yeah. i'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
04:04:33 <dons> hehe
04:04:39 <skew> from talking to somebody around here they seem to be big on being able to do stuff at compile time
04:04:44 <dons> that's a quotable quote.
04:05:51 <blackdog> Cheers don. :)
04:05:59 <Cale> I was actually pretty frustrated with CL -- for a functional language it sure is difficult to work with higher order functions.
04:06:09 * TheHunter wonders why the hell crappy network cabels make his notebook crash.
04:06:10 <nailbiter> blackdog: it's all relative. :) you could drop by MSDN, where they'll tell you all about how funky VB.NET is. :)
04:06:51 <skew> and not particularly appreciate how we tend to do the same sort of stuff by reifying the code into runtime structures with stuff like monads
04:07:48 <blackdog> Cale: ok, that's interesting. i'm just worried that i've become a little too comfortable with Haskell.
04:08:19 <skew> Cale: is it just the bit about using #' or whatever on function names?
04:08:59 <Cale> skew: well, that, and the need to use apply and funcall, and the arbitrary seeming distinction between function and value slots
04:09:37 <blackdog> nailbiter: sure. but i think you could reasonably say that haskell, lisp and C are three hills in PL design space
04:09:37 <Cale> and the libraries, though large, never seemed to have the functions I was looking for
04:10:04 <Cale> well, that's not quite true, but I recall having trouble finding various things
04:10:16 <dcoutts> JaffaCake, using the latest ghc-6-4-branch on amd64, I still get errors with the compacting garbage collector (though slightly different errors than before)
04:10:18 <dcoutts> internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
04:10:35 <JaffaCake> oh, bum
04:10:44 <Cale> I like scheme -- in comparison it seems much more natural
04:10:54 <JaffaCake> dcoutts_: thanks anyway
04:11:07 <JaffaCake> looks like I'll have to try to repro this myself
04:11:08 <dons> @remember ghc internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
04:11:20 <dcoutts> depending on the rts -H and -M I get different errors, or segfaults
04:11:40 <dcoutts> if I set the -M high enough then it works (probably because it never invokes the compacting GC)
04:11:49 <JaffaCake> right
04:12:28 <JaffaCake> I wonder if it really is 64-bit dependent, rather than just a generic bug in the compacting collector
04:12:55 <dcoutts> JaffaCake, you'll be wanting a gtk2hs snapshot tarball since we had so many autotools problems before
04:13:10 <JaffaCake> that'd be great, yes
04:16:12 <dcoutts> ok, btw I also get this sometimes, is this known:
04:16:13 <dcoutts> internal error: getMBlock: mmap: Invalid argument
04:16:57 <dons> I think i've seen mail about that one.
04:17:11 <JaffaCake> that rings a small bell
04:17:24 <JaffaCake> can't remember exactly, though
04:17:52 <JaffaCake> ah I remember - it was to do with old interface files left arond
04:18:10 <JaffaCake> I take it that isn't happening in your case?
04:19:30 <dcoutts> I did make clean, anyway, this is running a ghc compiled prog, not ghc itself
04:26:40 <nlv11757_> earthy, what do you think of using AG as an analysis medium?
04:31:40 <vincenz> Hello
04:32:59 <skew> nlv11757_: that can be pretty nice. What are you tring to do?
04:34:01 <nlv11757_> well skew, im trying to think how im going to realize analysis in my situation;
04:34:14 <nlv11757_> i currently have an AST of a C program in an AG
04:34:41 <nlv11757_> so now i want to for example do dependency analysis to see if there are loopcarried dependencies
04:35:07 <nlv11757_> but usually, people have a control flow graph and some dataflow framework that does the fixpoint stuff etc.
04:35:25 <nlv11757_> since im in the situation where i have the AST in an AG....im trying to figure out what my options would be
04:37:14 <nlv11757_> any suggestions/remarks?
04:38:47 <skew> you might want a graph if you want to transform it
04:39:21 <skew> if you are just interesting in extracting information from the AST then an attribute grammar should work fine
04:40:19 <nlv11757_> but would for example data dependencies be the kind of information that can be extracted from the AST
04:40:25 <nlv11757_> or is an AST not suitable you think?
04:40:27 <basti_> what would you want to do?
04:40:46 <skew> I think data dependencies would be pretty easy
04:40:46 <basti_> data dependencies are easily processable with attribute grammars i think
04:41:32 <skew> do some wiring so every bit of code has access to it's scope, mapping names to some kind of unique description of values
04:42:06 <basti_> did i mention that i find data flow languages a very natural but never seriously investigated approach to many many problems? =)
04:42:38 <skew> and each bit of code that introduces a value can synthesize a list of what it depends on
04:43:08 <nlv11757_> ah im glad you guys see some 'bread' in that approach, cause my first approach i wanted to try is just....if i need information....make attributes that will calculate it
04:43:23 <skew> yeah, that's how it goes
04:43:34 <skew> see, Haskell already does fixpointing for us
04:43:50 <skew> so you don't necessarily need any kind of fancy graph library to do what you want
04:45:19 <nlv11757_> ah cool
04:46:13 <nlv11757_> cause the popular approach is having a framework and instantiating a couple of transfer functions that tell how to compute the analysis results for basic blocks...and then just having some enginge do fixpoint until the analysis results stabilize
04:46:25 <nlv11757_> i want to just let the information flow over the AST
04:46:25 <skew> lazy evaluation == least fixed point
04:48:37 <nlv11757_> my only doubt was if the AST was a suitable treestructure to do it on
04:48:47 <nlv11757_> but i guess i will find out :)
04:49:45 <skew> blackdog: how it the lisp coming along?
04:50:09 <nlv11757_> thanks for the brainstorm skew and basti_
04:51:48 <blackdog> skew: stacks-on-the-mill. :)
04:52:18 <blackdog> i've got a list of a few flagship apps to look at.
04:52:32 <skew> nlv11757_: one fun trick that may be useful is incrementally building up a map by chaining it through the tree, then distributing it back down everywhere, and using the final map in its own construction
04:55:11 <nlv11757_> and then hoping your circular program has a sequential scheduling :D
04:55:27 <nlv11757_> i.e. only using something that doesnt completely rely on itself
04:56:37 <skew> it's not necessary to have a sequential scheduling, as long as no attribute ends up being defined as just itself
04:56:57 <skew> or strict in itself, at least
04:57:45 <TheHunter> what's ``foo'' in wikis?
04:58:47 <blackdog> skew: i think i might have to just wait for that lispy dude to turn up - i need someone who's tried both, and can be a bit objective.
04:59:10 <skew> blackdog: have you found anything to learn the language from?
04:59:22 <TheHunter> hmm. I'll just use ".
04:59:34 <skew> you might want to check out Paul Graham's book
04:59:36 <blackdog> a textbook? no.
04:59:58 <skew> there's one about lisp and using macros and stuff
05:00:05 <blackdog> perhaps. i might just jump in head-first and see how soon i drown
05:07:46 <nlv11757_> blackdog, lol thats the story of my thesis :P
05:08:48 <blackdog> :) hack, or do not hack. there is no think.
05:10:38 <nlv11757_> hehe i just thought, wow that sounds like a spanking interesting project, of course i didnt know what i got myself into :P
05:11:29 <blackdog> what are you working on?
05:12:19 <pipe> why are logs no longer on tunes.org?
05:12:49 <nlv11757_> doing analysis on C programs with the goal of making a tool to interactively help programmers to parallelize C programs
05:13:28 <blackdog> you like pushing pennies up everest with your nose? :)
05:14:10 <nlv11757_> hehe let's just say im interested in seeing how far i can push myself without ending in a mental hospital
05:20:17 <dan2> nlv11757_: use a compiler that supports OpenMP
05:22:20 <nlv11757_> dan2 i am going to use openMP directives for the user to communicate with my tool...so if i need the user to tell me a certain variable is private for example....and in the end i will produce a C program again augmented with openMP directives
05:22:37 <Maddas> blackdog: I can recommend Practical Common Lisp
05:23:06 <dan2> nlv11757_: is this your attempt at committing suicide?
05:23:28 <Maddas> blackdog: I think On Lisp might be a bit much for the start, it is also fairly un-idiomatic at parts, but whatever works best for you :-)
05:24:01 <blackdog> Maddas: are you a dual-classed lisp/haskell programmer?
05:24:18 <blackdog> if so, i'd love to hear some good reasons for learning lisp.
05:24:23 <nlv11757_> dan2, haha why would you say so?
05:24:47 <nlv11757_> i'd rather like to know if im trying to do the impossible as soon as possible :P
05:27:04 <dan2> nlv11757_: so basically you're creating a compiler?
05:27:24 <nlv11757_> nooo its wayyyy more restrictive
05:27:24 <dan2> I'm not sure anybody would want these tasks automated either
05:28:29 <nlv11757_> people want to parallelize a certain loop for example, my tool shows you the dependencies that stand in the way, but my tool is not AT ALL an automatic parallelizer, so it needs the help of the user to provide information about variables, pointers, etc.
05:28:47 <nlv11757_> then i basically have to create the generation of threads for every loop iteration
05:29:19 <blackdog> How do you get the dependencies? Surely if you're in C and potentially using pointer arithmetic, anything could depend on anything
05:29:24 <Maddas> blackdog: No, I'm neither. I'd like to be, though :-)
05:30:14 <Maddas> blackdog: The best reason to find out whether there is any reason to learn it (and what that reason is if it exists) is to learn it. I really think you won't regret learning either :-)
05:30:33 <nlv11757_> blackdog, thats when i need the user to help me out
05:31:03 <blackdog> Maddas: probably true. the other sneaky bit is that if i see any cool dynamic features i can't live without, i'll bug dons until he includes it in hs-plugins just to shut me up.
05:31:36 <Maddas> :-)
05:31:42 <blackdog> you know that "step 1: x. step 2: y. step 3: ... step 4: profit" meme?
05:31:49 <Maddas> Me?
05:32:02 <blackdog> I reckon step 3 can almost always be implemented by "Bug Don"
05:32:08 <Maddas> Haha
05:32:56 <blackdog> so you've used lisp and are learning haskell, or the other way around, or are equally good at both ... ?
05:34:05 <Maddas> I haven't used either for anything serious, I don't know either very well. I think I know CL better than Haskell right now
05:36:34 <blackdog> nlv: so it's a one-time use thing that changes his source code? an automatic notation would seem to be nicer... but maybe that's just my biases showing.
05:36:49 <Maddas> I like learning, I just tend to, uh, get distracted and forget about things quickly, so progress isn't as fast as I'd like :-)
05:37:25 * Maddas leaves to hunt down some cake
05:37:39 <blackdog> i'm a bit more motivated than i used to be: if i get off my arse, i might be able to deliver code at work in haskell/lisp/ocaml rather than python and php.
05:37:52 <skew> blackdog: work is web stuff?
05:37:53 <nlv11757_> blackdog, i only change the source code once, that's in the end of the interaction cycle with the user that results in an application that is sufficiently parallelized if all goes well.
05:38:01 <nlv11757_> but what do you mean with automatic notation?
05:38:51 <skew> blackdog: what did you think of Ruby on Rails? any good ideas to steal for the Haskell web stuff?
05:38:55 <blackdog> skew: yep. using Plone at the moment, as well as patching crappy legacy php/tomcat apps
05:39:23 <blackdog> i haven't really grokked RoR yet. I'm not seeing what's so wonderful about it yet.
05:39:54 <skew> I've just gotten as far as the bit where it automatically figures out stuff from the database with me writing no code
05:40:09 <skew> which is nifty, but says nothing about how it scales to doing complicated things
05:40:19 <blackdog> the scaffolding stuff?
05:40:40 <skew> that, and how the data objects give themselves attributes and stuff by looking at the table of the same name
05:40:42 <blackdog> yeah. it's nice to have a running start at it, i guess, but i'm not yet convinced it's that important.
05:40:53 <skew> I think that sort of stuff is pretty nice
05:41:34 <nailbiter> blackdog: actually, is there some sort of web programming framework for Haskell?  i'm maintaining a pile of creaky old PHP applications at the moment, and i need something more pleasant to work with
05:41:40 <blackdog> haskelldb might offer something helpful there. i haven't really looked at the backend stuff yet - i've been focusing on acquisition, page templates, that sort of thing.
05:42:31 <blackdog> nailbiter: there's hemplate, and WASH. I'm not totally happy with either of them, which is why i'm writing my own, but it's not even close to being halfway thinking about being ready. :)
05:42:42 <blackdog> oh, and halipeto, but that's not dynamic.
05:43:08 <blackdog> i'd be really interested to know what you think are killer features for a web programming framework, though.
05:43:13 <nailbiter> blackdog: thanks. i guess i'll check them both out
05:46:13 <skew> blackdog: part of what makes Haskell an exceptionally pleasant language is the combination of really powerful tools for abstraction so you don't have to write much code, and all the little niceties like currying and lightweight lambdas and operator definition so what little code you have to write is easy
05:47:34 <skew> It's leverage all up and down the spectrum
05:48:06 <blackdog> preaching to the choir. :)
05:48:36 <Maddas> b
05:49:07 * Maddas fades away again
05:52:31 <skew> I could build similar sorts of things in other languages (e.g. Java) and get similar asymptotic savings in the complexity of my programs, but the pain of actually using them (simulating lambda with anonymous classes, etc.) is prohibitive
05:52:47 <skew> It's like a ladder starting ten feet off the ground
05:53:08 <blackdog> perhaps not the best metaphor, that one. those ladders are hard to climb. :)
05:54:09 <skew> sure you can do all kinds of fancy things with objects and reflection and stuff, but that gap between the code you type and the level where you can do abstraction makes it "a little hard to climb"
05:54:44 <skew> I'm thinking there might be a useful analogy for web frameworks
05:55:17 <skew> blackdog: I thought the metaphor was pretty good - once you're on the ladder you can reach that stars, but getting up to it can be tricky
05:55:34 <blackdog> Ah, I see. Makes some sense.
05:55:39 <skew> the other way around, I think php is more like a step ladder
05:55:45 <skew> easy to get on, but it only goes ten feet up
05:55:54 <Maddas> I like this quip from Joe Armstrong's thesis: "It is extremely important that the mapping is exactly 1:1. The reason for this is that it minimizes the conceptual gap between the problem and the solution. If this mapping is not 1:1 the program will quickly degenerate, and become diecult to understand."
05:55:58 <blackdog> i grok you better now
05:56:11 <Maddas> He was talking about concurrency, but I think the idea applies for many things :-)
05:56:50 <Maddas> (Talking about the mapping of a problem to the program that deals with it)
05:57:46 <blackdog> yes. as soon as you start encoding rather than mapping you get into big trouble
05:58:58 <Maddas> Right. I just got reminded of that when skew talked about simulating lambda with anonymous classes :-)
05:59:27 <skew> somebody once wrote a set of parser combinators in Java
05:59:46 <nlv11757_> i think Atze Dijkstra did that also and Doaitse
05:59:48 <nlv11757_> let me check
06:00:14 <nlv11757_> yep
06:00:14 <nlv11757_> http://citeseer.ist.psu.edu/dijkstra01lazy.html
06:00:25 <nlv11757_> Lazy Functional Parser combinators in Java
06:01:04 <skew> I just realized why I prefer using @google to get links in here - I don't have to grab the mouse to copy them over
06:01:16 * basti_ nods
06:01:21 <basti_> the mouse is SLOW
06:01:27 * shapr agrees
06:01:47 <nlv11757_> i just rightclick and it opens my browser, works fine for me :)
06:02:07 <basti_> nlv11757_: he was talking the other way round
06:02:23 <nlv11757_> ow lol
06:02:30 <nlv11757_> i read to fast
06:12:44 <nlv11757_>  /to/too/
06:13:15 <skew> hi shapr
06:13:19 <blackdog> nlv11757_: btw, i've been meaning to ask. Why do you use such a long and incomprehensible nick?
06:13:24 <skew> how is the Haskell web stuff going?
06:14:08 <earthy> well, the nlv I can place
06:14:11 <earthy> but the 11757_...
06:14:13 <Philippa_> it looks like a username
06:14:42 <earthy> but he is niels@...
06:15:05 <shapr> One thing that pisses me off most about xpdf vs gv is that the keys they use to go backwards and forward are different.
06:15:34 <shapr> The eVince deb doesn't have keyboard navigation at all, by default. I don't know if I can configure it or not.
06:16:05 <shapr> I just want to page through the docs and not have to remember which app I'm using. grr.
06:16:40 <Maddas> What annoys me most about gv is that I never understood what it does when I press space :-)
06:16:51 <Maddas> (Or why it does it, for that matter. Yes, I should just read the manual)
06:17:04 <blackdog> as mr jagger says, you can't always get what you want
06:17:18 <shapr> space takes you to the next 'section', but f takes you to the next page.
06:17:49 <shapr> Why the heck can't I dynamically reflow a document to fit my screen shape? Sticking with book shape is a real waste of screen real estate.
06:18:37 <blackdog> bit high-level for pdf or ps, isn't it? they're page-level description languages
06:18:49 <Maddas> shapr: Hmm, I see. I often to use the mouse to scroll down in a page, and space never did what I wanted after that. Thanks for the tip
06:19:07 <shapr> Web browsers may have a lot drawbacks, but at least they by default use all of my screen. (except for irritating layouts that nail down the layout)
06:19:28 <skew> I don't like reading really wide text
06:19:37 <blackdog> skew: agree doubleplus
06:19:40 <shapr> Maddas: of course, that doesn't work in xpdf, it's n and b instead of f and b
06:19:40 <reffie> i hate having fullscreen windows.
06:19:44 <reffie>  don't know why
06:19:46 <reffie> but i do
06:20:01 <reffie> so even though my browser is on adesktop by itself, it's nto fullscreen :(
06:20:07 <Maddas> shapr: Eek. The only reason why I always used space was also that it Just Worked in the other PDF reader I use.
06:20:59 <blackdog> it's weird that more text-heavy websites don't use columnar text. there's a reason newspapers do it that way.
06:21:00 <shapr> reffie: In my opinion, the point of having screen size is to use it all :-)
06:21:17 <Maddas> (And the reason why I use gv is that the other reader doesn't display a class of PDF/PS files as well as gv does)
06:21:35 <reffie> shapr i like being able to look at my background :P
06:21:39 <Cale> I don't like fullscreen windows either.
06:21:40 <shapr> why?
06:21:44 <reffie> i don't know
06:21:51 <reffie> i guess it makes the screen less boring
06:21:53 <Cale> but I can almost never see my background
06:21:54 <shapr> Why not put your background into the app?
06:22:12 <Cale> I generally have 15-20 windows open :)
06:22:18 <reffie> i use pseudo-transparent terminals, if that's what you mean
06:22:20 <shapr> emacs, gnome-terminal, etc all support image backgrounds.
06:22:33 * shapr used to have a NiN theme for emacs
06:22:47 <nlv11757_> can i do a kind of 'test: SRCS += extrafile.hs' rule in Makefile?
06:22:52 <reffie> http://segfaulted.com/screenshots/Screenshot-29.png <- example
06:22:54 <nlv11757_> its not taking it
06:22:58 <Maddas> Cale: I usually like fullscreen windows, but sometimes I don't, and I always go back to not having them fullscreen for some reason ;-)
06:23:01 <blackdog> shapr: you bring me closer to swapspace?
06:23:09 <shapr> blackdog: bwahaha
06:23:14 <Maddas> Haha
06:23:35 <Cale> I like to always be able to see my web browser and irc client
06:23:44 * blackdog makes same tired old emacs joke. eight megs and constantly swapping is kinda obsolete when 512-1gb is standard
06:23:46 <Cale> at least see whether something has changed
06:23:49 <shapr> reffie: I can switch to any app I'm running in less than three keystrokes.
06:23:58 <earthy> cale: I like always to be able to hide my web browser and IRC client
06:24:03 * Maddas envies shapr for that
06:24:06 <earthy> that way at least I can get some work done. ;)
06:24:06 <reffie> shapr i can, without a single keystroke :)
06:24:09 <shapr> Cale: Ah, my irc client is part of emacs, and notifies me when something changes.
06:24:13 <blackdog> if i'm trying to work, having irc going in the background is deeply counter-productive
06:24:13 <reffie> [by using the mouse]
06:24:22 <Maddas> earthy: That's true, too.
06:24:23 <reffie> blackdog i garee
06:24:31 <shapr> I have a single keystroke that takes me to the most recently updated irc channel.
06:24:41 <skew> shapr: how do you get three?
06:24:42 <Cale> shapr: I'm using X-Chat -- It also notifies me of changes with a beep and by colouring the channel tab, but I like to be able to see it anyway
06:24:45 * Maddas eyes Matlab window partially hidden behind ERC
06:25:23 <skew> shapr: even if you don't count modifiers
06:25:24 * CosmicRay pops in
06:25:31 <CosmicRay> shapr: instead of a NiN theme for emacs, you need a NIH one
06:25:39 <Maddas> heh
06:25:48 <shapr> skew: I have S-n to switch to the next workspace, and H-n to switch to the next app in that workspace.
06:26:08 <skew> and not very many apps?
06:26:10 <shapr> I usually have two workspaces, a fullscreen and a floatWS.
06:26:14 <Cale> and I can't live without multiple desktops
06:26:38 <Maddas> Hm, actually, I think I could switch to any window with four to five keystrokes. Lately, though, I've just been using the mouse
06:26:44 <Cale> This was a huge problem I had with Mac OS X until I found the appropriate apps :)
06:26:52 <shapr> skew: I do run a lot of apps, but nearly everything works from inside emacs :-)
06:26:56 <Maddas> Cale: Out of interest, what do you use?
06:27:09 <blackdog> Cale: it's funny, i thought i couldn't live without it, but quicksilver + expose does an awful lot.
06:27:12 <Maddas> Not just X11, I hope ;-)
06:27:18 <Maddas> blackdog: I agree, QS rocks.
06:27:29 <Cale> Right now I'm on a Debian machine
06:27:44 <Maddas> Cale: I meant to solve your problems on OS X.
06:27:53 <Cale> Oh
06:27:56 <Maddas> Er, I meant to ask what you use for that, I didn't mean to solve them.
06:28:06 <Cale> what was it called...
06:28:26 <shapr> For example, I have F12 bound to compile in emacs, so when I'm working on a pythonscript, zpt, or whatever, I add a line at the bottom that calls galeon with the url to the file (wherever in the world it is) so that means a single keypress saves the file onto the remote server, and then loads it up in galeon.
06:28:54 <Cale> http://desktopmanager.berlios.de/
06:28:57 <Cale> there it is
06:29:14 <Cale> and quicksilver
06:29:26 <blackdog> shapr: i never remember to set that kind of thing up until you remind me. Cheers.
06:29:44 <Cale> and basically I had a million terminals and emacs or vim
06:30:08 <shapr> What apps do you guys normally run? For visible apps I have xemacs and galeon in my fullscreen workspace, and a multi-tabbed gnome-terminal and gkrellm in my floatWS
06:30:14 <Maddas> shapr: What do you mean with 'add a line at the bottom'? Add an entry to a menu in Emacs?
06:30:20 <Maddas> shapr: That sounds really nifty anyway, though.
06:30:23 <shapr> Nah, Local Variables
06:30:27 <shapr> @wiki HaskellMode
06:30:29 <lambdabot> http://www.haskell.org/hawiki/HaskellMode
06:30:34 <Maddas> O
06:30:35 <Maddas> k
06:30:37 <Cale> Firefox
06:30:57 <Cale> gkrellm is nice, but I usually only run it when I need the temperature monitors
06:31:09 <Cale> I'm running gnome + enlightenment
06:31:42 <Cale> I used to use gnome terminal, and Eterm before that, but I'm currently using uxterm
06:32:08 <skew> on my visible desktops, I've got gkrellm2, gaim, lyx, xpdf, firefox, thunderbird, and six terminals
06:32:12 <Maddas> I use QuickSilver to start pretty much anything other than itself. I mostly have an instance of Emacs and Terminal running, most other things I just start when needed.
06:32:37 <skew> I should learn to seriously use emacs sometime
06:32:44 <basti_> yes you should
06:32:51 <shapr> Or just switch to Yi
06:32:56 <Cale> TeXmacs is nice
06:33:01 <blackdog> emacs on mac is a bit sucky. at least, xemacs is.
06:33:07 <Cale> For quick TeX documents :)
06:33:12 <blackdog> shapr: surely you jest.
06:33:15 <shapr> I think Yi is going to flatten emacs in terms of both power and customizability.
06:33:18 <basti_> shapr: btw. is there ANY advantage in using these fast lazy lexers in Yi?
06:33:27 <shapr> basti_: sure yeah, read the paper.
06:33:31 <basti_> no i mean
06:33:36 <Maddas> blackdog: I use Carbon Emacs.
06:34:02 <basti_> when they're all customizeable (at runtime), they would not be able to benefit from the technology at all
06:34:04 <Maddas> Cale: I like TeXShop for that, too.
06:34:12 <blackdog> shapr: sure. it's not really there yet, though.
06:34:27 <skew> basti_: why not?
06:34:29 <shapr> Yeah, I agree. But how else to get there?
06:34:50 <basti_> well currently i basically built my own lexer...
06:34:51 <shapr> blackdog: As you said yourself (I paraphrase here) "shae, if you want to get Yi moving, delete emacs."
06:34:53 <blackdog> i'd like to invoke my rule 3 answer from earlier. :)
06:35:17 <basti_> the only connection to Yi/Lexer.lhs is the entry call and the way things are arranged...
06:35:30 <basti_> theres no actual optimisation going on, and i do not think it's possible easily
06:35:31 <Cale> I should get into Yi :)
06:35:34 <blackdog> ... so i'm occasionally inconsistent. :)
06:35:52 <basti_> i do not think regexes fit editor commands all that well, too.
06:36:02 <basti_> (at least not like how yi handles that stuff)
06:36:05 <xerox> yo
06:36:05 <blackdog> basti_: doesn't it load it using hs-plugins? Presumably it's being compiled at runtime...
06:36:06 <shapr> basti_: take it up with Mr Architect himself.
06:36:14 <basti_> hehe
06:36:15 <shapr> y0 xerox
06:36:20 * basti_ shrugs ;)
06:36:50 <skew> which lexers are these anyway?
06:37:15 <shapr> I just want it to work enough that I can use it for my daily work, after that, I'm willing to argue about internals.
06:37:28 <basti_> I see why they would be better in a static context. but a) an editor's keymapping is not, b) ot
06:37:33 <blackdog> skew: keymaps for yi
06:37:37 <shapr> I want to switch to an arrow-based parser library myself, but I won't even think about that until Yi 1.0 is online.
06:37:42 <basti_> it's not that an editor's state would be a really complicated affair
06:37:53 <skew> I mean, what do they do just at compile time?
06:38:07 <basti_> skew: the problem is that the keymap isn't known at compile time.
06:38:14 <shapr> skew: CTK's Fast Lazy Lexers
06:38:22 <basti_> or, it is known, but it's no help since it's thought to be muteable.
06:38:31 <skew> okay, that's enough to find them
06:38:52 <blackdog> oh, i didn't know that. it's using chak's lexers? that's kinda cool.
06:38:59 <blackdog> UNSW posse represent.
06:40:07 <skew> now I'm sure that these things are not doing anything fancy at compile time
06:40:37 <skew> these build some kind of table when you use them
06:40:52 <shapr> Even better, each table entry is only built the first time you use it.
06:40:55 <skew> even if you assembled the lexer at runtime
06:41:12 <skew> the only issue would be if you continually discarded and recreated the lexer
06:41:22 <shapr> Yeah, I think that's basti_'s question.
06:42:02 <skew> I don't see any reason to do that, unless Yi is wierd
06:42:14 <shapr> Basically, "Does a mutable keymap imply flushing the lexers all the time?"
06:42:43 <skew> as long as you are not flushing the lexer after every keystroke it seems they have plenty of time to work
06:42:47 <basti_> Well for example, what do you do when you want to bind "C-p" something... you'd have to build a new lexer
06:43:10 <basti_> but how do you get the new lexer to accept every single key and act variably to it?
06:43:35 <basti_> either write a lexer with a hell of a lot of parameters, or you make it map every key to the same function, which then decides
06:43:40 <basti_> (poof optimisation gone)
06:44:06 <skew> why not build a lexer that maps different keys to different functions?
06:44:30 <basti_> like how? the function that recognizes a given key will only accept a key known at compile-time
06:44:47 <basti_> (i think)
06:44:55 <basti_> it may not, for example, depend on IO
06:45:22 <skew> sure, you build primitive lexers that match each individual keystroke
06:45:55 <skew> then you compose those and other stuff together at runtime to build a lexer that maps keys to the functionality you want
06:45:56 <reffie> (3317.46 secs, -2105162188 bytes)
06:46:01 <basti_> hmm.
06:46:04 <shapr> CosmicRay: w00! darcsync!
06:46:09 <reffie> yay ghci
06:46:15 <skew> reffie: I like the memory usage. Can I get one too?
06:46:18 <Cale> yeah, it seems to do that
06:46:30 <reffie> :D
06:46:41 <basti_> but then there's the problem of recognizing the lexer.
06:46:54 <skew> why do we need to recognize it?
06:46:54 <basti_> i mean i'd want to have some feedback of my keymap
06:47:10 <skew> so you keep a data structure describing the keymap alongside the lexer
06:47:11 <basti_> for example, showing which function is bound to a key
06:47:30 <basti_> ...replicating every key and every function...
06:47:34 <skew> you need a description like that to build the lexer from in the first place anyway
06:47:43 <basti_> hmm
06:47:51 <shapr> Hey, why not build the lexers from a separate Map?
06:48:06 <shapr> Then you can get the C-h w functionality for free.
06:48:09 <skew> it's not duplication when you don't have to write the lexer and the map too
06:48:24 <nlv11757_> is it possible to compile a hs module that uses a function, that is only available at linktime?
06:48:36 <nlv11757_> i.e. im calling a function that is present in some .o file
06:48:57 <skew> and when we are talking about creating new lexers at runtime we are certainly not talking about writing the code that assembles the lexer ourselves (though I guess hs-plugins does blur that a bit)
06:49:34 <skew> If different edit modes have different keymaps that might flush the lexer
06:49:54 <shapr> Maybe I'm stuck in the emacs mindset, but wouldn't it be simpler to modify a Map of key to function, and then rebuild a single top-level lexer that's build from the map?
06:50:05 <skew> shapr: that's what I'm talking about
06:50:06 <shapr> Oh, hm.
06:50:12 <skew> when you go into a mode, rebuild the lexer
06:50:30 <skew> if it really matters you might try to cache them...
06:50:37 <shapr> Or just stick it into a node on the keymap tree.
06:50:45 <shapr> and then rebuild the global lexer
06:50:48 <skew> but we have plenty of CPU to waste these days, right?
06:51:09 <shapr> At least until Yi 1.0 is out, sure.
06:51:09 <skew> shapr: or have an already-constructed lexer at each node on the keymap tree
06:51:10 <shapr> :-)
06:51:52 <shapr> I just want to be able to easily change my keymap the way I can do it in emacs. At the moment, I don't care how slow that is.
06:52:03 * basti_ thinks this is top priority
06:52:26 <shapr> Because once I've ported my life into Yi, I can always optimize stuff. Bootstrapping my life into Yi is the hard part for me.
06:52:39 * boegel fears he will drink too many beers tonight
06:52:41 * basti_ does not need to bootstrap any lives
06:52:56 * earthy fears he will drink too many beers over the weekend
06:53:07 * shapr fears he will work too much over the weekend.
06:53:10 <earthy> given that it'll be queensday next saturday. :)
06:53:50 <shapr> I have to get TMR2 out this weekend.
06:54:25 <shapr> Means I'll do some heavy editing the next few days, and have to change permissions.
06:55:39 <xerox> Can you resolve mail.nectarine.it ?
06:55:44 <kosmikus> some of you should also finish their HCAR entries until next Tuesday ;)
06:56:47 <shapr> er, yes.
06:57:09 <shapr> That would be me.
06:57:44 * Lemmih got a couple of HC&AR entries in the works.
06:58:42 <Lemmih> Probably wont send any of them, tho /-:
07:09:19 <nlv11757_> can anyone help me out, im trying to accomplish that a haskell module calls a function which is in a .o file....so after linking it will all work, but how do i compile this haskell module?
07:09:39 <nlv11757_> its not typesafe i guess
07:09:46 <nlv11757_> ok not at all
07:10:27 <Cale> hm?
07:10:42 <Cale> You can include the .o on the commandline to ghc
07:11:02 <Cale> if you need to know how to import the functions then you should read up on the ffi
07:12:45 <musasabi> nlv11757_: have you looked up hs-plugins?
07:12:52 <nlv11757_> the .o is a compiled haskell module
07:12:57 <nlv11757_> so i thought it neednt use ffi
07:15:17 <skew> nlv11757_: why can't you compile your module?
07:15:28 <skew> do you not have the .hi file?
07:18:29 <nlv11757_> this is the deal; AG file A.ag includes (including means pasting) B.ag. I have a C.hs module that uses B.hs (B.ag -> B.hs) and is imported into A.ag......which gives type errors because B.ag and A.ag where merged so all the types in B.ag (C.hs uses them) are also defined in the merged file
07:18:36 <nlv11757_> while in essence they are exactly the same
07:20:04 <skew> the problem is the C defines functions for B.Type, which don't work on A.Type?"
07:20:18 <nlv11757_> ow its all haskell now ;)
07:21:14 <nlv11757_> C.ag = A.ag + B.ag, i want to import D.hs in C.ag but D.hs uses types from B.ag that are also in C.ag defined....so it complains that it gets a File instead of C.File
07:21:19 <nlv11757_> but they are the same types
07:21:35 <skew> but they are not
07:22:03 <skew> I think this is why uuagc has flags for controlling what to generate
07:22:57 <skew> only generate the type in one of the .hs file, and makes sure all the other .ag files that need the type include that file
07:22:58 <kosmikus> Lemmih: why not?
07:23:13 <nlv11757_> that doesnt solve it, i will make the D.hs into a D.ag so it will inline that file too. So D doesnt have to use the types of B.ag but them in C.ag
07:23:26 <skew> nlv11757_: I think it does
07:23:36 <skew> make "MyTypes.ag" that actually defines the data types
07:24:16 <skew> run uuagc -dm MyTypes.ag to generate MyTypes.ag that just defines the data types
07:24:28 <kosmikus> I think skew is right; I use a similar approach for GH
07:25:05 <skew> now you have a module MyTypes.hs that's something like "module MyTypes where data Tasty = Unicycle | Badger"
07:25:30 <nlv11757_> but i have a seperate file Ast.ag
07:25:39 <Francy> hallo
07:25:39 <skew> then you are already set up for this!
07:25:43 <skew> hi
07:26:05 <nlv11757_> the problem is, i use Ast.hs in D.hs, and inline Ast.ag in C.ag, then importing D.hs in C.ag gives these type problems
07:26:14 <skew> nlv11757_: continuing with my example,
07:26:31 <earthy> nlv11757: you're making things *way* too complicated for yourself
07:26:41 <skew> nlv11757_: now suppose that Compute.ag inlines MyTypes.ag, and defines an attribute grammar
07:26:50 <Francy> i have an easy question regarding my omework ;)
07:26:55 <Francy> homework
07:27:23 <skew> say, ATTR Tasty [ | | name:String], SEM Tasty | Unicycle lhs.name = "name" | Badger lhs.name = "badger"
07:27:31 <nlv11757_> and Compute.ag would also use a module that uses MyTypes.hs then you have a problem
07:27:43 <earthy> Francy: shoot
07:27:45 <xerox> @type \f g x y -> f (g x) (g y)
07:27:51 <lambdabot> \f g x y -> f (g x) (g y) :: forall t t1 t2.
07:27:51 <lambdabot>                              (t -> t -> t1) -> (t2 -> t) -> t2
07:27:51 <lambdabot> -> t2 -> t1
07:27:55 <xerox> Is there an Arrow for that?
07:28:00 <Francy> it says: give example functions for the following:
07:28:03 <skew> this is where you say that you run uuagch on Compute.ag and it makes a Compute.hs that redefines the type and it doesn't work. *cry*
07:28:14 <Francy> function 1: Integer->Integer->Integer
07:28:26 <Francy> unction2: (Integer->Integer)->Integer
07:28:40 <Francy> function3: (Integer->(Integer->Integer)
07:28:44 <skew> Here is where you run something like uuagc -mcfsp Compile.ag
07:28:52 <TFK> That's a bit too easy, no?
07:28:55 <kosmikus> nlv11757_: you should let uuagc generate the datatypes exactly once
07:28:56 <Francy> function 4: (Integer,Integer)->Integer
07:29:06 <earthy> Francy: Functions 1 and 3 can be the same
07:29:07 <skew> which generates a Compile.hs that *does* *not* *define* the data type again
07:29:08 <Francy> im just starting haskell
07:29:20 <Francy> the : should be :: ;)
07:29:30 <smott> Francy: for 1-3 the example would be (+)
07:29:34 <earthy> as Integer->Integer->Integer is shorthand for Integer -> (Integer -> Integer)
07:29:45 <Francy> earthy i found out that they could be add a b = add a+b
07:29:48 <earthy> function2 and 4 would be different
07:30:06 <Francy> 2 could be add(a,b)= a+b
07:30:11 <earthy> no.
07:30:18 <earthy> 4 could be that.
07:30:24 <Francy> ok
07:30:31 <skew> so, Compile.hs is something like sem_Tasty t = case t of Unicycle -> sem_Unicycle t ; Badger t -> sem_Badger t, sem_Unicycle _ = "unicycle", sem_Badger _ = "badger"
07:30:36 <earthy> function2 would be add f = f 1
07:30:39 <earthy> e.g.
07:30:43 <Francy> ah
07:30:54 <Francy> like incr a = a 1
07:31:16 <Francy> cool thanks a lot!
07:31:17 <earthy> as (Integer -> Integer) -> Integer is a function taking a function that takes an integer to an integer and resulting in an integer
07:31:58 <Francy> i think i got it :)
07:32:00 <skew> but Compile.hs does not define it's own data type Tasty, and it does import MyTypes (pretend I remembered that). So, all the references to the type Tasty refer to MyTypes.Tasty, and everybody is happy
07:33:09 <skew> nlv11757_: have you ever read a uuag generated module? the uuag --help output? the module generated for each of the different output flags?
07:33:35 <skew> nlv11757_: do all of the above and you would understand your problem and how to solve it
07:33:36 <nlv11757_> yes, yes and yeas
07:33:53 <skew> okay, well I understood the problem and have solved it for myself
07:34:09 <nlv11757_> i dont think you have, because my situation is different....
07:34:26 <skew> explain again then
07:34:43 <skew> are you extending the data type in the different modules or something?
07:34:45 <shapr> He said unicycle.
07:34:57 <shapr> Do you actually have a semcycle?
07:35:01 <earthy> cue beavis & butthead giggle
07:35:45 <shapr> I asked Surlybikes if they'd sell me a custom EndoGoiter, but they won't :-(
07:35:49 <Francy> bye and thanks for your help!
07:36:29 <shapr> It's still a sexy looking unicycle though - http://www.surlybikes.com/blogimages/Goiter.jpg
07:36:35 * vincenz ordered his laptop !!
07:37:18 <skew> nlv11757_: you have Ast.ag that defines the type, Helpers.hs that imports Ast.hs and defines stuff for it's type, and then Compile.ag that includes Ast.ag and defines a bunch of processing for the Ast
07:37:28 * boegel stole vincenz laptop from the store *grin
07:37:37 <nlv11757_> skew, no. im not redefining anything. Simply defining something in A.hs of type Foo that is defined in B.ag. Then C.ag which includes B.ag also import A.hs and then suddenly that something in A.hs is of B.Foo and not of the Foo defined in C.ag and they NEED to be defined in C.ag because they are used in the AG
07:38:50 <skew> nlv11757_: you didn't follow what I said
07:39:12 <skew> the problem is that when you compile C.ag it generates it's own version of the data type, right?
07:39:56 <skew> So add an import A, and tell uuagc not to generate a data type definition
07:40:05 <xerox> Today is sunny!  I'll surely skate.
07:40:12 <nlv11757_> then i still get a lot of not defined blabalba
07:40:39 <skew> like what?
07:40:54 * boegel dances around
07:41:04 <shapr> Today is sunny! I'll surely unicycle!
07:41:24 <vincenz> how difficult is unicycling,
07:41:25 <earthy> Today is gray. I'll surely cook.
07:41:25 <vincenz> ?
07:41:32 <skew> I have set up the situation you describe, an AG for the data type, an Hs of helpers that imports from that AG, and then a fancy AG that includes the first and imports from the HS
07:41:37 <vincenz> Today is .*, I'll surely code.
07:41:42 <boegel> does anyone in here know Flogging Molly ?
07:41:58 <Maddas> Heh heh.
07:42:14 <shapr> vincenz: It takes about ten hours of training to learn how to ride without hanging onto a wall., but it's not any harder than bicycling after that.
07:42:44 <vincenz> impressiv
07:42:49 <vincenz> why do you enjoy it so much?
07:43:14 <skew> nlv11757_: makes sure that the presence or absence of the -r option between different runs matches up
07:43:40 <skew> otherwise one module defines the constructor Tasty_Unicycle and the other is trying to pattern match on Unicycle
07:44:01 <nlv11757_> i always use renaming of dataconstructors
07:44:17 <skew> nlv11757_: paste in an error message or too
07:44:32 <nlv11757_> Ambiguous occurrence
07:45:08 <skew> between data types?
07:45:15 <nlv11757_> yep
07:45:17 <skew> then you didn't exclude the -d option like I suggested
07:45:31 <skew> note that -d is implied by -a which is the default if no options are given
07:45:35 <shapr> vincenz: It's elegant, meditative, much more agile than a bike, scales from just riding up to very complex tricks, easy to store, easy to carry, excellent exercise...
07:46:14 <nlv11757_> i compiled the big ag without -d
07:46:30 <skew> does it have any data type declarations in it now?
07:46:35 <skew> open it up and see!
07:47:44 <skew> oh, I guess -a isn't default
07:47:55 <nlv11757_> it does have the T_ types, but not the other types
07:48:15 <skew> are those the types that are being ambigous?
07:48:23 <shapr> vincenz: I tend to choose options that require more work to learn, but have a greater payoff for the effort. I'd say emacs, Haskell, and unicycling all fit into that. (At least in my head they do)
07:49:20 <nlv11757_> i need to export Ast.hs types from that haskell module right>
07:49:22 <nlv11757_> ?
07:49:35 <nlv11757_> otherwise big ag doesnt have them at all
07:49:43 <skew> right
07:51:20 <nlv11757_> so now the T_ types, sem_funs and signatures of sems are still ambigous
07:51:40 <nlv11757_> since this haskell module exports Ast.hs AND big ag has them since it includes Ast.ag
07:51:41 <skew> you should leave out all that stuff when you are just compiling the data type
07:52:09 <nlv11757_> data type doesnt get compiled, it gets included in big ag
07:52:20 <skew> uuagc -d Ast.ag
07:52:26 <skew> uuagc -md Ast.ag, I guess
07:52:49 <skew> or, import just the data type
07:52:57 <skew> import { import Ast(Ast(..)) }
07:53:03 <skew> I think
07:53:46 <skew> to me this is a simple question of what uuagc generates, and the Haskell import rules. I don't understand what's so confusing
07:54:17 <vincenz> shapr: how does unicycling pay off?
07:54:39 <nlv11757_> if it was so simple i would have it working here
07:55:21 <kosmikus> I still don't see the problem either
07:55:43 <nlv11757_> then its just me i guess
07:56:20 <kosmikus> or there's something special about your situation which I've not yet understood
08:00:54 <nlv11757_> thanks for explaining and patience though kosmikus and skew
08:12:01 <Muad_Dibber> bah
08:14:48 <skew> just when I finish my example too
08:16:36 <skew> somebody point him to http://page-148.caltech.edu/~brandon/ if he comes back and I'm away
08:19:20 <shapr> vincenz: I lost fifteen kilos of weight, I think/sleep/eat better, I have better balance, both physically and mentally. More muscles, easy way to meet people. I think you can get the same benefits from any other regular out-of-the-house exercise, but for me it's important to find something that's addictively fun.
08:22:45 <shapr> vincenz: I can't stand exercise that's 'real work', all the joggers I see look totally miserable. But I can unicycle for hours trying to do a new trick, or trying jump higher or further.
08:23:02 * basti_ does neither have weight nor muscles.
08:23:30 <|Lupin|> Hi folks.
08:23:33 * Muad_Dibber has his muscles covered with wieght :)
08:24:11 * Lor likes to practice hand-standing. Same thing, I guess.
08:24:29 <shapr> salut |Lupin|
08:24:36 <|Lupin|> pls
08:24:45 <basti_> slp.
08:24:47 <|Lupin|> does someone know if there is a .deb for haxml ?
08:24:52 <|Lupin|> (version 1.12 if possible)
08:25:26 <|Lupin|> or an RPM, maybe ?
08:25:39 <shapr> I've seen a Cabal file for haxml
08:25:49 <shapr> That will let you install haxml on ghc6.4
08:26:08 <shapr> basti_: Because of my body shape, I have the choice between being fat or muscly.
08:26:09 <musasabi> Is there no cabalized version of HList available?
08:26:20 <basti_> ;)
08:27:17 <Muad_Dibber> anybody knows if i have to do something special again to install ghc on gentoo? or is ghci just not possible?
08:27:38 <shapr> I'm sure it's possible, but I don't know any details.
08:28:35 <basti_> strictly speaking, on a turing complete machine, everything should be possible.
08:28:41 * basti_ ducks and runs
08:29:38 <shapr> Muad_Dibber: you could send an email to ghc-users.
08:31:48 <CosmicRay> Muad_Dibber: what platform?
08:33:49 <Muad_Dibber> gentoo amd64
08:34:26 <musasabi> Muad_Dibber: are you trying the ebuild or a manual build?
08:34:48 <Muad_Dibber> ebuild
08:35:01 <CosmicRay> Muad_Dibber: there is not yet ghci for amd64 on any platform
08:35:05 <CosmicRay> Muad_Dibber: but ghc should work
08:35:11 <CosmicRay> s/platform/os/
08:35:30 <musasabi> i386 ghci should work on amd64 inside a 32bit environment.
08:35:36 <CosmicRay> musasabi: it doesn't.
08:35:45 <CosmicRay> I think it looks at uname for something or other at runtime
08:35:58 <CosmicRay> well, it does work if you have a 32-bit kernel
08:36:00 <Muad_Dibber> CosmicRay : a full 32bit chroot refers in nothing to amd64
08:36:19 <CosmicRay> Muad_Dibber: I know, and I have such a thing, but you can still tell you're running on amd64 even in that chroot
08:36:25 <CosmicRay> uname gives it away, for instance
08:36:34 <CosmicRay> that's why kernel compiles in that chroot, and various other compiles, break
08:36:42 <Muad_Dibber> actually it doesnt
08:37:04 <Muad_Dibber> inux chani 2.6.9-gentoo-r14 #3 SMP Sun Mar 27 22:06:38 CEST 2005 i686   GNU/Linux <- where to make amd64 from this?
08:37:06 <CosmicRay> yes, it does.  it thinks you're trying to build a 64-bit kernel.
08:37:35 <CosmicRay>  uname -a
08:37:35 <CosmicRay> Linux katherina 2.6.11 #1 Tue Apr 26 16:21:40 CDT 2005 x86_64 GNU/Linux
08:37:36 <Muad_Dibber> i'm not building a kernel
08:37:42 <CosmicRay> that's from my 32-bit chroot
08:37:48 <CosmicRay> note x86_64
08:38:01 <CosmicRay> uname -m in particular will return x86_64
08:38:12 <CosmicRay> and of course the various files in /proc will indicate this
08:38:46 * CosmicRay wonders why a 50MB+ nofib/spectral/awards/awards.slowstdout was checked in to fptools :-)
08:38:46 <Muad_Dibber>  # uname -m
08:38:46 <Muad_Dibber> i686
08:38:55 <CosmicRay> well then gentoo must have hacked uname
08:39:03 <CosmicRay> because that is not what /proc is saying in a 32-bit chroot
08:39:35 <Muad_Dibber> use the linux32 program to change 'uname -m' into 'i686'
08:39:51 <Muad_Dibber> even more specific: it allows me to run ghci :P
08:40:23 <CosmicRay> ahh well now, you didn't mention this :-)
08:40:30 <CosmicRay> a normal chroot won't do this
08:41:39 <Muad_Dibber> :D i did mention it in the end didnt i :)
08:47:37 <jlouis> 12
08:47:39 <jlouis> bleh
08:50:52 <skew> jlouis: ?
08:53:21 <skew> oh, noise
09:01:57 <jlouis> skew: exactly. There should have been a goto_window macro before that. But I, somehow, only managed to think about typing it, not actually use my motor/kinetic skills.
09:02:25 <jlouis> The worst thing is it often happens to me while coding. I leave out words and control blocks
09:02:41 <jlouis> quite hard to read
09:03:51 <Gahhh> lol
09:05:31 <jlouis> Gahhh: It can be rather funny. About 1/50 of the times you end up with type checking code.
09:06:07 <skew> jlouis: are you near any schools that do neuroscience research? Maybe they could squeeze you in the next time they implant electrodes in a batch of monkeys
09:06:52 <skew> Actually, eye tracking might be feasible and useful
09:07:00 <skew> focus-follows-eyes
09:07:44 <jlouis> nono, focus-follows-thought
09:08:02 <CosmicRay> [1]metaperl_: don't you think you can add more punctuation to your nick? :-)
09:08:11 <skew> I think you can manage that with monkeys
09:08:29 <[1]metaperl_> i think it ... i dont know why it does that
09:09:58 <jlouis>  /nick _||_()|S
09:10:14 <skew> if it has perl in it, it should at least have a $
09:13:47 <jlouis> Heh, do you reckon one can detect the language used by frequency counting the ascii alphabet in the source code?
09:14:10 * CosmicRay gripes at JaffaCake for checking in a 60MB test result file to fptools :-)
09:18:07 <skew> it looks like eye tracking systems are a little too expensive for me :(
09:26:30 <musasabi> Can HLists be mutually recursive?
09:26:31 <Oejet> jlouis:  I think so because it can more or less be done by comparing the ratio of zip compression, so I've read.
09:28:00 <Igloo> CosmicRay: If you run linux32 then you should be able to use ghci for i386 inside that on amd64
09:28:15 <Igloo> Oh, Muad_Dibber said that later on
09:31:50 <Muad_Dibber> :D
09:39:06 <dcoutts_> Muad_Dibber: the ghci on amd64 is simply lacking, is ordinary amd64 ghc not working for you? or is is just GHCi that was at issue?
09:40:12 <dcoutts_> ghc-6.4 is masked on gentoo atm but it does work mostly (though many other packages break with 6.4 at the moment hance why 6.4 is masked)
09:41:39 <Lemmih> SyntaxNinja: Hey. You're up early.
09:49:15 <SyntaxNinja> Lemmih: not so early, really.
09:50:55 <Lemmih> Don't you live in GMT-9 or something?
09:52:26 <SyntaxNinja> gmt - 8 I think; it's 10:AM here
09:52:40 <markstos> Is it possible to build ghc 6.4 without the X11 dependency? I don't care if HGL doesn't work.
09:53:33 <SyntaxNinja> it is surely possible :)
09:54:09 <markstos> That's a start. I I couldn't find any readily available documentation to do so. I was hoping for a low-hassle solution.
09:54:29 <skew> markstos: did you check for a ./configure option?
09:54:53 <markstos> skew: Yes I did.   I want to use it on a  FreeBSD server which has no other reason to have X installed.
09:57:07 <Igloo> markstos: If you don't have hte libraries I think it should Just Work
09:57:32 <Igloo> Or are you building it somewhere other than where you will use it?
09:57:39 <markstos> Igloo: Maybe I need to try a manual configure instead of using the port...
09:58:22 <markstos> All: Thanks for your help, I gotta run to a lunch appt now.
10:07:21 <skew> markstos: if you can grab a binary package everything should work except programs that you explicitly compiled with -package x11
10:08:54 <Muad_Dibber> dcoutts : afaik now normal ghc works properly :)
10:09:10 <autrijus> wow, I'm writing a monad transformer before I know it. :)
10:09:24 <autrijus> a IO/STM bridge
10:09:25 <skew> autrijus: did you just accidentally code up a monad transformer?
10:09:33 <autrijus> skew: yeah
10:09:56 <skew> that's when you know the Haskell is really starting to sink in :)
10:10:09 <skew> what does it do?
10:10:31 <SyntaxNinja> JaffaCake: haddock doesn't handle recursive modules :(
10:10:42 <SyntaxNinja> maybe I should just get rid of all the recursive modules :(
10:15:01 <autrijus> skew: it let you freely use STM and IO
10:15:02 <autrijus> and mix them
10:15:20 <autrijus> doing atomically() automagically
10:15:26 <autrijus> and once you mix it the wrong way
10:15:34 <autrijus> i.e. when you require a unsafeIOToSTM
10:15:48 <skew> how do you scope retry then?
10:15:48 <autrijus> then it shiftT's to the nearst resetT boundary
10:15:52 <autrijus> and raise an exception there
10:16:08 <autrijus> by putting things in retryT
10:16:19 <autrijus> things in retryT are composed with liftSTM
10:16:28 <autrijus> if you put liftIO there, same exception is thrown
10:16:58 <skew> this mixes STM and subcontinuations?
10:17:01 <autrijus> yes.
10:17:10 <autrijus> and also trying to make it serializable
10:17:33 <autrijus> type Eval x = EvalT (ContT Val (ReaderT Env IO)) x
10:17:35 <autrijus> is the type
10:17:43 <autrijus> it will change to
10:17:50 <skew> my current prize for most imposing Haskell term goes to "subcontinuation monad transformer"
10:18:14 <autrijus> allow both ReaderT Env IO and ReaderT Env STM
10:18:18 <autrijus> (that's what I'm coding now)
10:18:22 <autrijus> and trying to implement resetT myself ;)
10:18:36 <autrijus> using the CPS/Prompt code
10:18:43 <skew> what is the T for?
10:18:58 <autrijus> in " A Monadic Framework for Subcontinuations"
10:19:09 <autrijus> the T is because it operates on the transformed version
10:19:19 <autrijus> reset is for Cont, resetT is for some sort of ContT
10:19:19 <skew> right, reset is already taken
10:19:57 <skew> why do you shift to the reset before raising the exception?
10:20:11 <Arsilan> hva så ske
10:20:24 <Arsilan> w
10:20:32 <autrijus> skew: because the exception is raised as returning an "error" value on that prompt
10:20:39 <autrijus> that prompt may choose to catch it or rethrow
10:20:53 <Arsilan> halo Skew
10:21:02 <autrijus> all exception handling is done in the prompt
10:21:23 <skew> okay, I thought you were using the IO exceptions, or had a separate transformer mixed into the stack
10:21:27 <skew> hi
10:21:39 <autrijus> skew: EvalT (ContT Val (ReaderT Env IO))
10:21:43 <autrijus> or
10:21:46 <autrijus> EvalT (ContT Val (ReaderT Env STM))
10:21:49 <autrijus> it's IO/STM underneath
10:21:59 <autrijus> upon that, a lexical pad to read environment from
10:22:11 <autrijus> upon that, a ContT that accepts Val as values
10:22:19 <autrijus> the environment is the lexical pad etc.
10:22:54 <skew> I have no idea what you have hidden inside that EvalT, though
10:23:42 <autrijus> basically a different implementation of liftIO; a liftSTM
10:23:48 <autrijus> a different fail""
10:23:56 <autrijus> that uses ContT to propagate
10:24:02 <autrijus> and a >>= that analyzes IO/STM boundary
10:35:28 <autrijus>     val <- (`runReaderT` env) $ (`runContT` return) $ runEvalT $ resetT eval
10:35:30 <autrijus> eww.
10:48:30 <autrijus>     callCC f = EvalT . restorePrompt . callCC $ \c -> runEvalT (f (\a -> EvalT (c a)))
10:48:54 <autrijus> this is more an more beyond my intuition :-/
10:49:05 <autrijus> i.e. throwing in code just to make typechecker happy
10:50:14 <skew> that's not as bad as it sounds
10:50:49 <skew> at least there is some theory so making typechecker happy == making type system happy == making program happy
10:51:13 <autrijus> but I don't like the feeling that my intuition is not up to par :-/
10:51:30 * autrijus feels some borderline insanity kicking in in this type of programming
10:52:34 <skew> I don't know about restorePrompt, but the rest looks mostly reasonable
10:52:47 <autrijus> they are reasonable.
10:52:51 * autrijus codes some more
10:53:04 <autrijus> I keep getting this, though
10:53:05 <autrijus>     Couldn't match `EvalT (ContT Val (ReaderT Env IO))'
10:53:05 <autrijus>            against `ContT Val (ReaderT Env IO)'
10:53:10 <autrijus> evidently I forgot a EvalT somewhere.
10:53:27 <autrijus> or a return somewherel
10:56:48 <skew> what is the type of EvalT?
10:56:57 <skew> definition, I guess
10:57:00 <tintin> .
10:57:05 <jlouis> Oejet: hehe, information theory?
10:57:07 <skew> EvalT : *, or I'm really confused
10:57:14 <autrijus> newtype EvalT m a = EvalT { runEvalT :: m a }
10:57:31 <skew> jlouis: hey, where?
10:57:46 <shapr> autrijus: I did not yet email SPJ about whether it's okay to use subcontinuations in Pugs, did you do it? If not, I'll do it right now :-)
10:57:59 <skew> autrijus: what's that good for?
10:58:10 <Oejet> jlouis: I think so.
10:58:14 <autrijus> shapr: please do so
10:58:19 * shapr does so
10:58:33 <skew> something nefarious with type classes?
10:58:33 <autrijus> skew: that's basically a glorified IdentityT
10:58:49 <autrijus> well, yes.
10:59:13 <autrijus> I'll sound more coherent when I make this actually run :)
11:00:57 <skew> The only use I can think of is so you have a place to change the monad without changing any types, but that's not an issue if you have a definition like type GloriousPugsMonad a = EvalT (ContT Val (ReaderT Env IOorSTM)) somewhere.
11:03:04 <autrijus> yes.
11:03:15 <musasabi> What is the best way to get open record types in Haskell? I want to specify things like "a record with at least fields foo of type T and bar that is a member of class C1".
11:03:49 <autrijus> that is not used as a general purpose transformer
11:03:58 <autrijus> it assumes its underlying thing is of the correct structure.
11:04:15 <autrijus> to wit:
11:04:15 <autrijus> instance (MonadReader r m, MonadCont m, Monad m) => Monad (EvalT m) where return a = EvalT $ return a
11:04:18 <autrijus> etc.
11:04:44 <autrijus> MonadSTM comes later
11:05:45 <skew> Okay, so EvalT is used to impose some constraints on things. It still doesn't look like you can mix code over IO and STM with just >>= or do, unless you are replacing the Prelude definitions
11:06:09 <skew> shapr: you might like to think about the UI applications of eye tracking systems, if you haven't already
11:06:16 <autrijus> er, of course you need to use liftSTM and liftIO
11:06:19 <autrijus> respectively
11:06:21 <autrijus> to bring them into scope
11:06:33 <autrijus> all the EvalT does is remember whether it's being tainted by IO or not
11:07:03 <skew> autrijus: yes. I mean it looks like your stack is build on either IO or STM, and it looks like you get different monad types depending on which you use
11:07:19 <shapr> skew: Yeah, I've thought about it. There's lots of them. But I've had enough ideas in that area that I can't continue unless I get eye-tracking hardware.
11:07:31 <autrijus> skew: oh. no, I plan to let it carry an additional type later
11:07:52 <autrijus> here "it" being the underlying type that unifies IO and STM via constructor
11:08:25 <autrijus> data EvalType where { EvalIO :: IO a -> EvalType a; EvalSTM :: STM a -> EvalType a }
11:09:09 <autrijus> and case both sides when >>= happens
11:09:17 <autrijus> or let EvalType bring in another type param. not sure
11:09:20 * autrijus is still thinking
11:09:57 <autrijus> data EvalType m a where { EvalIO :: IO a -> EvalType IO a; EvalSTM :: STM a -> EvalType STM a }
11:10:05 <autrijus> data EvalType m where { EvalIO :: IO a -> EvalType IO; EvalSTM :: STM a -> EvalType STM }
11:11:04 <skew> shapr: unfortunately it seems to be quite expensive
11:11:27 <shapr> yes, sadly.
11:28:17 <shapr> y0 3ch0
11:29:07 <hellish> shapr: hi.
11:29:20 * hellish has to leave immediately
11:29:32 <shapr> well ok then.
11:30:03 <autrijus> shiftT :: ((Val -> Eval Val) -> Eval Val) -> Eval a
11:30:07 <autrijus> resetT :: Eval Val -> Eval Val
11:30:10 <autrijus> callCC :: ((Val -> Eval a) -> Eval Val) -> Eval Val
11:30:13 <autrijus> hm. I thought it makes sense.
11:33:32 * autrijus gives up for tonight
11:33:49 <skew> autrijus: that doesn't work out?
11:33:53 <autrijus> skew: nope
11:33:57 <skew> why not?
11:34:01 <autrijus> worse yet I can't tell why.
11:34:19 <skew> I thought the paper wrote callCC?
11:34:19 <autrijus> I think I'll rethink this whole thing when I am more awake
11:34:41 <autrijus> callCC :: (K ans a -> M ans a) -> M ans a
11:34:45 <autrijus> yeah, but I want a callCCT
11:35:06 <autrijus> i.e. a MonadTrans kind of callCC
11:57:02 * basti_ was debating with a linguist, and said linguist claimed a fundamental difference between a turing machine and a computer would be that the computer could do "video telephony"
11:59:04 <CosmicRay> uh, what?
11:59:27 <basti_> well it didnt make sense to me first, too
11:59:37 <CosmicRay> glad I'm not the only one :-)
11:59:48 <basti_> but apparently he imagined that a tm would be kind of restricted because of the "missing" i/o
11:59:52 <skew> there is a slight possibility he actually meant something sensible and insightful
12:00:25 <shapr> Someone gave me citeseer urls to papers on searching by type, but I can't find them in the logs.
12:00:28 <shapr> Any clues?
12:00:33 <basti_> skew: like what?
12:01:50 <shapr> Aha!
12:01:56 <shapr> It was JaffaCake!
12:02:17 <skew> oh, maybe something about computers being physically embodied, and confusing abstractions with implementations, and stuff like that
12:02:28 <basti_> ohhh no he wasnt talking about that
12:03:26 <basti_> im pretty sure he wasn't percieving a TM as some sort of abstracted computer
12:03:50 <skew> of course, if he meant that a Turing machine modified with stream IO in any of the standard ways couldn't do videoconferencing he's just wrong
12:03:50 <basti_> rather like a "precomputer" or something... a primitive predecessor
12:03:56 <skew> though it might be a bit slow....
12:04:24 <basti_> thats what i said too.
12:04:59 <basti_> depends on your tm though
12:05:17 * shapr finally tracks down the papers.
12:05:27 <shapr> Man, I gotta write FLM just so I can find stuff I'm looking for, geez.
12:05:28 <basti_> maybe it has a 5 THz step frequency and a 1024 channel tape
12:06:21 <basti_> ...helium cooled motor coils...
12:06:40 <shapr> Why not just use josephson junctions?
12:06:56 <basti_> you mean those "cool-hot" metal connections
12:07:06 <shapr> You even get the benefit that you can teleport signals among parts of the chip without needing wires.
12:07:12 <skew> no, superconducting magnetic flux gates
12:07:13 <basti_> ohh
12:07:46 <skew> like a SQUID, but for logic
12:08:27 * basti_ just stumbled over the description of SQUIDs
12:08:37 <basti_> "Squids have been used to measure the magnetic fields in mouse brains to test whether there might be enough magnetism to attribute their navigational ability to an internal compass."
12:08:48 <shapr> I still thought up with a good way to make a josephson junction based workstation smaller than a PDP-11
12:09:05 <shapr> er, "stil haven't"
12:09:13 <shapr> Maybe when magnetic heat pumps get more efficient.
12:09:44 <basti_> did i mention that mouse labyrinth orientation experiments not disabling smell, daylight, sound, tactile sensorics can not say anything about a mouse's navigation?
12:10:42 <basti_> (which incidentally might be the cause that most mouse orientation experiements give the result the experimentator expects)?
12:10:57 * shapr prefers keyboard experiments
12:13:24 <basti_> wow.
12:13:56 <basti_> the josephson effect can yield an instrument that measures macroscopic voltages to a precision of 10^-10
12:14:30 <shapr> A josephson junction takes about one thousandth of the time and one thousandth of the energy that semiconductors require.
12:14:44 <shapr> Tells you why Seymour Cray wanted to use them.
12:15:07 <basti_> well the question is if it's feasible to build processors out of them
12:15:17 <shapr> Sure, they're commercially available.
12:15:28 <shapr> And they have *gobs* of processing power.
12:15:41 <basti_> so why is there no superfast CPU?
12:16:06 <skew> basti_: not enough places to buy liquid helium
12:16:15 <basti_> hmm.
12:16:46 <shapr> But the only market that needs that much power and doesn't have a problem with the installation of large amounts of cooling equipment is seriously heavy signal processing stations like microwave base stations.
12:17:43 <shapr> @google rapid single flux quantum
12:17:45 <lambdabot> http://pavel.physics.sunysb.edu/RSFQ/RSFQ.html
12:18:25 <basti_> microwave base stations? as in radio astronomy?
12:20:01 <shapr> Nah, like very large mobile phone base stations.
12:20:08 <basti_> oh.
12:21:11 <shapr> If you google for rsfq base station you'll find places selling the equipment.
12:21:24 <andersca> shapr!
12:21:27 <shapr> I vaguely recall that the cooling equipment by itself was 30,000 euro.
12:21:29 <shapr> andersca!
12:21:50 <shapr> basti_: see, that would let you overclock your CPU a bit.
12:21:58 <shapr> andersca: wasssup?
12:22:05 <basti_> hmmmk
12:22:06 <andersca> shapr: not much
12:22:32 <shapr> basti_: josephson junctions are far better, but we just don't have the technology to put them into laptops.
12:22:56 <basti_> yes i see that
12:23:12 <shapr> Though I have had the idea to use an extremely endothermic reaction for processing 'chunklets'.
12:23:22 <basti_> uhhhhhh
12:24:28 <shapr> Basically, you setup a big batch process on your laptop, then you put thirty bucks into a vending machine to get out something that looks like a glowstick. When you plug it into your laptop, it sucks up a lot of heat and lets you temporarily overclock your CPU to some insane number.
12:26:42 <shapr> It would be particularly nice if you could recycle the glowstick so the vendor could recharge it.
12:26:50 <basti_> ahh no that won't work... heat is not only the only problem in overclocking
12:27:13 <qmole> lol
12:27:13 <skew> shapr: it sounds like RFSQ is a bit fancier than you really need to just do computing
12:27:14 <shapr> I know, but if laptops/desktops were setup to take advantage of that sort of system, it would work.
12:27:40 <basti_> mmm i would rather use unoccupied cycles
12:27:51 <shapr> skew: yeah, but why drive a volkswagon? =)
12:27:57 <basti_> i mean, for every cycle i use my computer does 10 or 50 that i don't use
12:28:17 <basti_> and that it uses for the computer equivalent of saying "uuuuh."
12:28:25 <skew> shapr: if the alternative requires a few tanker trucks to make it a mile
12:28:40 * shapr laughs
12:28:48 <basti_> we'd need a common distributed computing network structure
12:29:21 <skew> it's not hard to reach liquid nitrogen temperatures - http://www.conectus.org/images/HTS_mobil_2.jpg
12:29:25 <basti_> i mean, for example, in our uni, there's about 200 basically unused computers running all the time
12:29:45 <basti_> its not hard at all... its just expensive and hard if you need lots of energy flow
12:29:52 <basti_> (which you wouldn't with superconductors)
12:29:58 <shapr> I think they got 350GHz or so out of RSFQ chips.
12:30:42 <shapr> I think I read they had problems going over 390GHz.
12:31:34 <basti_> btw, at higher frequencies, "strange and beautiful" things tend to happen
12:31:49 <basti_> computers got slower as they went faster so we don't notice that much
12:32:25 <basti_> but for example a pci bus can't extend a certain reach without the cycle becoming too fast for reaching it's end before the next cycle starts.
12:32:57 <shapr> Right, which is why they've considered um, what's it called? not quantum tunneling...
12:33:10 <integral> entanglement?
12:33:18 <basti_> "speed of light"? ;)
12:33:22 <basti_> [its not ;)]
12:33:26 <shapr> Where you totally fill up the wire with power, and treat it like a long string of billiard balls...
12:33:35 <basti_> thats what always happens
12:33:41 <basti_> a wire is never devoid of power
12:33:47 <shapr> So you smack the ball on this end to send a signal to the other end without waiting for the balls to fill up the tube.
12:33:51 <basti_> electrons are really slow.
12:33:59 <basti_> like, centimeters/sec or something
12:34:23 <basti_> its the field that makes them move
12:34:33 <basti_> and this spreads pretty quick. not at light speed though
12:34:53 <basti_> (of course there might be nonlinear effects at higher potentials)
12:35:02 <basti_> (which might be or not what you're talking about)
12:35:15 <shapr> I don't know, I can't remember the name of it.
12:35:31 <shapr> I really should keep all this stuff in a personal wiki. :-/
12:35:33 <basti_> :)
12:36:03 <skew> shapr: are you just talking about signaling with wavelengths shorter than your cables?
12:36:18 <skew> or something fancier?
12:36:34 <shapr> skew: Er, that's not at all how it was described, but that does sound similar.
12:36:38 <skew> I think stuff like PCI express is pretty close to that territory already
12:36:40 <basti_> wavelengths shorter than your cables is definitely possible, just a little complicated
12:37:07 <basti_> thats the reason why twisted pair cables are twisted, btw.
12:56:27 <skew> shapr: with switching frequencies shorter than your cables, I suppose, if you are using oscillating signals
13:12:12 * SyntaxNinja pokes JaffaCake with recursive modules and haddock
13:15:09 <shapr> hiya poetix
13:15:19 <poetix> aloha
13:15:25 * poetix has been backsliding
13:16:10 <poetix> I...I can't help it...I *need* my mutable state...
13:16:14 * shapr grins
13:16:26 * poetix mutates into a more comfortable state
13:17:56 <poetix> I don't think there's any reason in principle why I couldn't write a triplespace server in Haskell, but there are would be a few big hurdles to clear.
13:18:04 <shapr> Like what?
13:18:22 <poetix> i ) Getting my head round concurrent Haskell
13:18:31 * basti_ mutates
13:18:46 <poetix> ii) Getting the hang of threading IO and other monads (State, etc.) together comfortably
13:19:23 <poetix> iii) Is there a iii)?
13:19:35 <shapr> finding the spare time?
13:19:41 <poetix> There is always that.
13:20:49 <poetix> Right now there are some things Haskell is genuinely faster for, in terms for development time, for me; but there are others where I know I can hack stuff out in Python much more quickly just because I know the patterns/idioms that go with the language.
13:21:40 <TFK> That's always the case, innit? The devil you know and all.
13:22:18 <poetix> Haskell is still quite unsettled in terms of patterns and idioms - there are fewer recognised Ways To Do It, more experimental approaches (arrows & stuff) that haven't yet solidified into common practice.
13:22:33 * TFK wouldn't know
13:22:41 <mr-onionhead> Hey, I'm looking for any easy way to execute a shell command from a haskell program and get the output as a string.  I'm using an update to version of hugs, and can't seem to get load the System.Process library.  Ideally I would like find a function of type String->IO String, which I could use without playing iwth file handles.  Any suggestions?
13:23:19 <TFK> Last time I tried, Hugs couldn't import System.Process :-/
13:23:20 <Lemmih> mr-onionhead: There's no such function in the standard libraries.
13:23:32 <poetix> TFK: how's the Haskell-learning going? I notice you're still here...
13:23:51 <TFK> Yeah, I don't think I'll ever give up, although the actual learning activity may come and go as a wave.
13:24:02 <mr-onionhead> Lemmih: I thought that's what I was seeing.  So how do I go about writing one?
13:24:06 <TFK> The pastebin I started kidna works :-)
13:24:12 <poetix> Cool.
13:24:21 <TFK> *kinda
13:24:25 <poetix> Nothing succeeds like success.
13:24:44 <Lemmih> mr-onionhead: I would suggest moving to GHC 6.4. (:
13:24:46 <TFK> Hopefully success will only be succeeded by more success.
13:24:57 <poetix> Two steps forward, one step back.
13:25:26 <poetix> Right now I'm clinging to a few patterns I'm comfortable with, like a liferaft, but will eventually have to let go of them and start swimming upstream again.
13:25:30 <TFK> That's still progress.
13:25:51 <TFK> I've read some horrible Python code today :-(
13:25:58 <poetix> Where?
13:26:04 <mr-onionhead> Lemmih: I would rather not switch horses right now (I'm prototyping some code for a meeting tomorrow), but do plan to start picking up ghc soon.
13:26:05 <Lemmih> mr-onionhead: You could do some dirty stuff with 'system "cmd > file" >> readFile "file"'.
13:26:19 <TFK> pY! thingie, a voice chat proggie for a Yahoo! client.
13:26:23 <poetix> I think my Python code's getting nicer since I started writing Haskell. Also weirder, though...
13:26:33 <TFK> Not your code :-) just some code.
13:26:54 <TFK> The author had a "don't bug me with support questions" notice on her website :-/
13:27:01 <Lemmih> mr-onionhead: Not sure how portable that would be.
13:27:07 <TFK> Yup, higher-order functions open your eyes :-)
13:27:08 <mr-onionhead> Lemmih: I was hoping to avoid that, but i'll give it a shot.
13:27:19 <metaperl> same here: Haskell has done untold wonders for my Perl programming
13:27:22 <mr-onionhead> Lemmih: yeah i'm a bit afraid of race conidtions
13:27:57 <poetix> Perl's big enough to have a nice functional subset hidden away in it somewhere
13:28:05 <mr-onionhead> Do you know any reason why the prelude shouldn't include at Shell Command->IO String function?
13:30:48 <Lemmih> Because it's over-specified?
13:32:24 <mr-onionhead> Lemmih: yes.  but, it's something you do alot in genreal hacking.  Run a shell command and process the output is a very common task.
13:34:23 <mr-onionhead> Lemmih:  The redirection trick (cmd <in >out; readFile out) seems to work.  thanks
13:35:13 <Lemmih> It's apparently not very common in Haskell (:
13:43:45 <Philippa> not enough to be in the prelude, certainly
13:43:51 <Philippa> feel free to supply your own prelude to GHC :-)
13:44:34 <musasabi> What is the best way to get open record types in Haskell? I want to specify things like "a record with at least fields foo of type T and bar that is a member of class C1".
13:45:01 <Philippa> pick a record system, encode it with multiparm classes and fundeps
13:45:25 <poetix> http://homepages.cwi.nl/~ralf/HList/
13:45:28 <Philippa> field names're a sod though, you might end up with a new class for each field
13:46:07 <musasabi> Philippa: how should one encode constraints "field X is a member of class C", I know how to make the plain type based variant.
13:46:20 <Lemmih> Yay. Mail from alexj!
13:47:31 <musasabi> Of course I could use existentials for that, but it seems unclean.
13:50:07 <Philippa> musasabi: being an instance of C implies having field X?
13:50:33 <musasabi> Philippa: no. (I guess my explanation was not very clear)
13:51:18 <musasabi> something like "a record which has a field named foo with a type that is a member of typeclass Bar".
13:52:17 <Philippa> so the type of the field is (forall a.Bar a => a)?
13:52:37 <Philippa> (or at least, can unify with that)
13:52:53 <Paltas> Hi lkz :)
13:53:28 <musasabi> yes. (more like Bar a => Record { foo :: a, ... } with pseudosyntax)
13:54:10 <lkz> Hi Paltas :)
13:54:11 <musasabi> but lifting the forall inside the value could solve the problems (although that will lose some expressiveness)
13:57:00 <musasabi> I think I should just take a piece of paper and work out something sensible tomorrow.
13:58:30 <Paltas> Oejet, BTW Did you make further on your bzlib article? I didn't get a chance (read: time) to try out your FFI but my self, but it seems quite interestning. :)
13:59:57 <Lemmih> Oejet: Is the libbz binding cabalized and online?
14:00:16 <Paltas> Lemmih, at his DTU site somewhere, don't know if it's public for real
14:00:18 <Oejet> Lemmih: You'd wish.
14:01:15 <Lemmih> You made a secret binding? (:
14:01:30 <Oejet> Lemmih: I'd like to learn how to package with Cabal, but I haven't found the right starting point.
14:01:48 <Oejet> Lemmih: Well, TMR2 is out soon.
14:01:49 <kolmodin> I'm trying to write a .cabal file for one of my projects. How should I specify the -DDATADIR to ghc?
14:02:16 <Lemmih> It's really simple actually (: You put the name, version, module-names and dependencies on a .cabal file.
14:02:31 <Lemmih> kolmodin: GHC-Options: -D...
14:02:46 <Paltas> Oejet, Do you have a clue of when it will be public for "beta" test?
14:02:49 <Oejet> Paltas: The article should be more or less complete.  It's up for review now with the other authors.
14:03:21 <kolmodin> Lemmih: Currently, that option is generated in my makefile by the ./configure script.
14:03:36 <kolmodin> So I don't know it in advance
14:03:37 <Oejet> Paltas: You can be my beta tester. :-)
14:03:41 <Paltas> Oejet, That's cool. :) I hope it will open some eyes for some people. :)
14:04:23 <Lemmih> kolmodin: See the Cabal documentation about generating build-info from a configure script.
14:04:30 <kolmodin> ok
14:04:46 <Oejet> Paltas: Do you have Darcs installed?
14:05:03 <Paltas> Oejet, I'll be glad too, darcs: not yet
14:05:18 <Paltas> never got further than the thought. :)
14:13:02 <autrijus> I figured it out!
14:13:27 <autrijus> shiftT e = EvalT . ContT $ \k -> runContT (runEvalT . e $ lift . lift . k) return
14:13:30 <autrijus> resetT e = lift . lift $ runContT (runEvalT e) return
14:13:32 <autrijus> callCC f = EvalT . callCCT $ \c -> runEvalT . f $ \a -> EvalT $ c a
14:13:39 * autrijus dances happily
14:14:32 <basti_> autrijus: whats that? callCC in haskell?
14:14:45 <autrijus> basti_: callCCT :-)
14:15:01 <autrijus> callCC, in perl 6 space, in haskell
14:15:07 <basti_> o.0
14:15:26 <basti_> i dont know if to call that pervert.
14:16:24 <jlouis> call/pp?
14:16:36 <autrijus> :D
14:17:02 <basti_> call/never/return?
14:17:17 <jlouis> goto?
14:17:27 <basti_> reboot!
14:17:54 <monochrom> call/pp is like you crank call people and say "time to p p hahahaha"?
14:18:53 <monochrom> I and my sisters did that when we were kids.  There was no such thing as call display.
14:19:43 <jlouis> monochrom: I thought of it as call/pompously perverted, but nevermind
14:20:14 <basti_> lol
14:20:32 <basti_> it should be called pallCC
14:21:22 <Paltas> Good evening mr. louis. :)
14:21:47 <kaol> @yow
14:21:48 <lambdabot> Remember, in 2039, MOUSSE & PASTA will be available ONLY by
14:21:48 <lambdabot> prescription!!
14:22:30 <Philippa> damn, pasta's like 70% of my diet...
14:22:45 <TFK> And mice?
14:22:57 <Philippa> er, mousse != mouse
14:23:15 <Philippa> we might have a couple of chocolate mousses in the fridge, I'm no big fan though
14:23:31 <kaol> I don't expect they are good anymore in 2039
14:25:52 <jlouis> Hmm, it seems I have to do a complete re-work of the GHC port to NetBSD
14:26:25 * SyntaxNinja has constructed a far-too-complex mess of types and classes
14:26:54 <jlouis> SyntaxNinja: pencil, paper, boxes, hierachies and arrows
14:27:41 <SyntaxNinja> malcolm: jlouis is telling me how to write a haskell compiler ;)
14:27:58 <malcolm> Cool - how is it done?  :-)
14:28:15 <SyntaxNinja> (14:27:17) jlouis: SyntaxNinja: pencil, paper, boxes, hierachies and arrows
14:28:23 <jlouis> malcolm: once you define the types I laid out, you know what to do.
14:29:02 <malcolm> I'm great at blobology - I wish they'd told me how to use it for compiler construction at college...
14:30:24 <jlouis> fate-o-matic programming. You take a brush, dip it in paint, close your eyes and throws paint at the layout sketch. At some point you begin to see the pattern your program must abide
14:30:29 <Paltas> jlouis, Are you not using OpenBSD only?
14:30:44 <jlouis> Paltas: I have OpenBSD and NetBSD machines
14:30:56 <Paltas> jlouis, And still Redhat at DIKU? :)
14:31:04 <malcolm> Before I forget, someone was asking here recently about the HaXml/fptools repository story - was it CosmicRay?
14:31:15 <SyntaxNinja> yeah, and I was wondering too
14:31:35 <jlouis> thee 60Mb commit?
14:34:16 <jlouis> Paltas: even worse: -f-unroll-loops-linux
14:34:25 <malcolm> JaffaCake was almost right - I did request that HaXml be removed from fptools/hslibs, but that was back in the days when I had no write access to fptools, and there was a separate repository for HaXml.  Inevitably my master repo was at version 1.08 or something whilst new versions of ghc were still shipping 0.99 or thereabouts.
14:34:53 <JaffaCake> ok, thanks for the clarification
14:35:17 <Igloo> But the plan is still to remove more from fptools/libraries rather than put more in, right?
14:35:28 <jlouis> can GHC be bootstrapped with nhc98?
14:36:00 <JaffaCake> Igloo: that's my plan, but people keep stuffing it with more stuff :)
14:36:09 <malcolm> My request was mainly to reduce confusion between versions.  Now that HaXml has only one master CVS repo in fptools, I'd be perfectly happy for ghc to distribute it again.  Oh, how darcs could have helped back then!
14:36:13 <Igloo> heh
14:36:53 <malcolm> jlouis: nope, ghc is not written in Haskell!  It's written in ghc, which is substantially different.
14:36:59 <jlouis> no -- http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg07525.html -- to answer my own question
14:37:08 <Paltas> jlouis, hmm.. unroll loops seems to be optimization stuff, what does it have to do with a distribution?
14:37:20 <jlouis> coincidentially from a Malcolm, heh
14:37:52 <SyntaxNinja> but that malcolm is lame compared to our malcolm
14:37:57 <JaffaCake> I'd be interested to know how many ghc-isms have crept into the GHC sources, actually
14:38:16 <JaffaCake> I know there's lots of pattern guards - I use them all the time
14:38:23 <malcolm> JaffaCake: yeah, so would I.
14:38:48 <jlouis> Paltas: Gentoo linux
14:39:02 <Igloo> Sometimes I think more Haskell98isms should creep in, like do notation  :-)
14:39:02 <malcolm> I'm quite keen on getting pattern guards into nhc98, but then there are a lot of things I'd like to add...
14:39:06 <JaffaCake> It would be great if we could bootstrap with nhc98, but I have a feeling it's not practical
14:39:23 <Paltas> jlouis, Ahh.. I can imagine of what a hell with a lot of servers..
14:39:29 <JaffaCake> not just that it would require changing a lot of things, the main problem is keeping it working
14:39:34 <jlouis> Paltas: not my problem ;)
14:39:37 <Paltas> jlouis, At IMADA it's even worser, Mandrake. :)
14:39:50 <Paltas> jlouis, Oh you are going to ITU so no sys.adm anymore?
14:40:02 <malcolm> JaffaCake: I build nhc98 with four different compilers every night...
14:40:10 <jlouis> Paltas: something like that
14:40:11 <SyntaxNinja> JaffaCake: hopefully we'll get hackage up soon and people will stop adding stuff to fptools
14:40:19 * SyntaxNinja points out that it was JaffaCake that added cabal to fptools ;)
14:40:39 <Paltas> jlouis, Aha. :) So now we got a happy and satisfied jlouis ?
14:40:40 <Paltas> :)
14:40:43 * JaffaCake self-administers  40 lashes
14:40:57 <Igloo> If you don't have cabal with the impls then you have a problem, though
14:41:01 <malcolm> So has hackage gone live yet?
14:41:04 <SyntaxNinja> JaffaCake: you can stop at 20; that was the plan all along. as Igloo is pointing out.
14:41:34 <SyntaxNinja> malcolm: it is very far along! Lemmih has implemented "cabal-get" which downloads & installs packages and their dependencies
14:42:40 <SyntaxNinja> you can upload a tarball of a cabal package here, and it'll get put in hackage's belly: http://www.scannedinavian.org/~lemmih/cgi-bin/hackage/hackage?action=submit
14:42:50 <JaffaCake> malcolm: yeah, we could add it to the nightly builds... but it's yet *another* way to build things, and I'm getting the feeling recently that we have too many
14:42:57 <SyntaxNinja> and then "cabal-get install foo" fetches the stuff
14:43:13 <SyntaxNinja> but there's no documentation for building and using cabal-get yet.
14:43:25 <malcolm> SyntaxNinja: how can I see what packages are already available via hackage?
14:43:43 <Lemmih> SyntaxNinja: There's a bit of info on the TMR wiki.
14:43:44 <SyntaxNinja> I think Lemmih disabled the html interface, so the only way is via cabal-get
14:44:10 <SyntaxNinja> malcolm: but that'll come back soon.
14:44:24 <malcolm> JaffaCake: heh, I remember when my nightly Solaris build of ghc was taking longer than 24 hours, so the next build had started before the first had finished  :-(
14:44:59 <CosmicRay> while we're speaking of lashes, /me points out that JaffaCake single-handedly made fptools 60MB larger with one particular add yesterday :-)
14:45:05 <jlouis> malcolm: been there done that. Log processing though.
14:45:15 <JaffaCake> we do have a bit of leeway with the nightly builds at the moment... but I'm about to add the SMP way which will soak up another couple of hours
14:45:48 <shapr> Is expected to run? Can I check it out and test it on my SMP box?
14:45:50 <JaffaCake> my x86_64 box finishes two nightly builds before midnight though :)
14:46:03 <JaffaCake> shapr: sure
14:46:06 <shapr> w00
14:46:40 <JaffaCake> it's reasonably stable at the moment (but Simon PJ just destabilised the compiler, so you might be advised to wait a couple of days, or check out yesterday's source)
14:47:04 <CosmicRay> shapr: perfect opportunity to exercise darcs :-)
14:47:11 <JaffaCake> but you basically build programs with the -smp flag, and then run with +RTS -N2 (for 2 CPUs)
14:47:17 <CosmicRay> sweet
14:47:41 <JaffaCake> and you take a perf hit for just building with -smp at the moment, I've been measuring it today
14:47:54 <JaffaCake> anywhere from 0 to 80% :(
14:48:18 <JaffaCake> but that'll improve
14:48:38 <JaffaCake> oh, and STM isn't done yet
14:48:59 <jlouis> that -smp change is nice
14:49:20 <jlouis> Maybe I should try it on the 24-way sparc64 ;)
14:49:26 <Igloo> Is there a description of what it does anywhere?
14:49:37 <JaffaCake> yes, in the source code ;)
14:49:47 <Igloo> uh huh  :-)
14:49:58 <JaffaCake> I'm going to write it up... probably for the Haskell workshop
14:50:01 * shapr grins
14:50:09 <Igloo> Cool
14:50:44 <JaffaCake> Tim Harris will be on the case with STM support shortly
14:51:20 <JaffaCake> I want to parallelise GHC --make, I think it'll be fairly easy
14:51:54 <stepcut> To benefit from -smp, do I have to do special things in my code ? Like use threads ?
14:52:05 <JaffaCake> just use forkIO
14:52:23 <CosmicRay> couldn't one forkOS and get the same benefits today?
14:52:24 <JaffaCake> later, we'll do par
14:52:25 <stepcut> forkIO is for haskell level threads ? (as opposed to OS level?)
14:52:54 <JaffaCake> CosmicRay: no, you still only get one thread running Haskell code at any one time, at the moment
14:53:02 <JaffaCake> stepcut: yes
14:53:15 <stepcut> cool
14:53:38 <shapr> Very cool. I must try this with Yi.
14:53:51 <shapr> I want to go over to #emacs and ask them if they have SMP support.
14:53:59 <JaffaCake> hehe
14:54:35 <shapr> Hm, this also increases my motivation to use Haskell for webdev instead of Python.
14:54:42 <CosmicRay> shapr: emacs is lucky to have support for these modern fixed disk thingies
14:54:53 * JaffaCake chuckles
14:54:55 <stepcut> shapr: haha
14:55:15 <shapr> Python's global interpreter lock means it actually gets slower on SMP unless you latch the interpreter to one cpu.
14:55:59 <JaffaCake> it'll be nice to have parallel compilation in GHCi, come to think of it
14:56:43 <JaffaCake> hmm, that means making the byte code interpreter work in SMP mode, though
14:56:49 <jlouis> hmmm, nhc98 is getting an upgrade 1.16 -> 1.18 before I attack ghc
14:57:39 <shapr> JaffaCake: Thanks for the new toys! w00!
14:57:41 <CosmicRay> jlouis: can I interest you in any cvs->darcs conversion services for the nhc98 tree? :-)
14:57:48 <JaffaCake> shapr: enjoy ;)
14:58:18 <jlouis> CosmicRay: for the time being, no. I still need to upgrade all haskell tools to the newest ones
14:58:38 <CosmicRay> jlouis: ok, well the offer stands if/when you're interested.
14:59:11 <JaffaCake> shapr: if you build from source, you need to add 'GhcLibWays += s' to mk/build.mk to get SMP libraries
14:59:26 <JaffaCake> the libraries are built another "way", like profiling libs
15:00:13 <Igloo> Does s_prof work too? Or does it get confused?
15:00:31 <JaffaCake> s_prof should work in principle... I haven't tried
15:01:10 <JaffaCake> oh, except that there's lots of locking of profiling data structures required
15:01:24 <JaffaCake> I take it back, it won't work (yet)
15:01:40 <Igloo> *nod*
15:09:21 * shapr cheers for wikipublishing
15:10:18 <TFK> Oh boy...
15:10:45 * TFK points at Lulu
15:11:00 <shapr> hej andersca
15:23:06 <shapr`> grr
15:23:16 <shapr> have I mentioned lately how much emacs irritates me?
15:25:21 <basti_> shapr: no you haven't.
15:26:16 <Jerub> shapr: Tell me how emacs irritates you.
15:27:58 <shapr> I should probably put my emacs irritation energy into Yi instead.
15:30:24 <stepcut> heh
15:30:42 <TFK> Or Haste.
15:30:56 * stepcut must first finish putting bash to rest before working on yi again
15:34:41 * TFK wonders if Lulu has anythong *good*
15:34:52 <TFK> Just good would be interesting, too.
15:37:37 <Jerub> TFK: I think it's a matter of getting content.
15:37:51 <Jerub> I was considering republishing a BSD licensed python book through lulu at once stage.
15:37:59 <Jerub> but we found a local printer who did it for better prices.
15:38:08 <Jerub> but now the dollars much better against the american, we'll reconsider it.
15:38:42 <TFK> They have a lot of content. But there's also the stigma of "anyone can get published".
15:39:00 <TFK> I guess I'm somewhat of a prude in that regard :-/
15:39:06 * TFK fights himself
15:39:12 * TFK wins! Hurray!
15:39:17 <shapr> Does anyone know if aspect oriented programming is any different from a monad?
15:40:18 <SyntaxNinja> monads are good
15:41:57 <Jerub> holy dooly.
15:42:02 <Jerub> I wonder what shipping costs are.
15:42:22 <shapr> Aha, "The whole point of AOP is arbitrary uncontrolled side effects: the standard logging examples etc. Composing a function with an "aspect" that only modifies the parameters or value is pointless and is not going to work with multiple "aspects". At the monadic level, many uses of AOP are more controllably implemented with HOFs and monad transformers. This obviously doesn't allow arbitrary aspects, but that's the point of doin
15:42:22 <shapr> g it this way."
15:42:28 <Jerub> 93 page book perfect bound comes to $6.80 or something
15:42:39 <shapr> Can I actually send email to a slashdot username somehow?
15:43:16 <Jerub> there are blogs at slashdot...
15:50:12 <shapr> greetings tibbetts
15:50:18 <tibbetts> Good evening.
15:50:21 <shapr> Looking for Haskell info?
15:50:34 <tibbetts> No, I typoed #hanson
15:50:37 <tibbetts> :)
15:51:02 <tibbetts> Thanks for asking. I'm in the process of learning and have either a simple or a complex question.
15:51:05 <shapr> Ah right, I've heard the hansons hang out on freenode.
15:51:19 * shapr snickers
15:51:20 <dcoutts> @seen bogel
15:51:21 <lambdabot> I haven't seen bogel.
15:51:26 <dcoutts> @seen boegel
15:51:27 <lambdabot> I saw boegel leaving #haskell 7 hours, 21 minutes and 18 seconds
15:51:27 <lambdabot> ago.
15:51:36 <tibbetts> GIven tuples with type (a,b,c) and (d,e,f), can I write a polymophic function that will two one of each and return a tuple (a,b,c,d,e,f)?
15:51:37 <dcoutts> @ta
15:51:38 <lambdabot> Maybe you meant: pl wn
15:51:46 <tibbetts> s/two/take/
15:51:55 <TFK> Why not?
15:52:02 * TFK tries in Hugs
15:52:04 <shapr> tibbetts: try it.
15:52:22 <tibbetts> Sorry, I was unclear. I mean one function that will do this for tuples of any size.
15:52:23 <monochrom> bwahaha (a,b,c) (d,e,f) = (a,b,c,d,e,f)
15:52:30 <shapr> Ah, no.
15:52:32 <monochrom> No.
15:52:35 <SyntaxNinja> NO
15:53:01 <dcoutts> pl wn? I think lambdabot needs to be able to accept thanks. :-)
15:53:11 <tibbetts> I thought I might lose. I seek enlightenment about why I should use.
15:53:22 <tibbetts> It seems like this is a reasonable function to want to write.
15:53:27 <TFK> Prelude> :t \(x1, x2, x3) (y1, y2, y3) -> (x1, x2, x3, y1, y2 ,y3)
15:53:27 <TFK> \(x1,x2,x3) (y1,y2,y3) -> (x1,x2,x3,y1,y2,y3) :: (a,b,c) -> (d,e,f) -> (a,b,c,d,e,f)
15:53:37 <Cale> tibbetts: what is the type of that function?
15:53:37 <dcoutts> me: ta. lambdabot: no probs!
15:53:45 <TFK> But oh boy is it large...
15:54:08 <TFK> But why tuples?
15:54:13 <shapr> tibbetts: You can do that with Generic Haskell though.
15:54:15 <tibbetts> I dunno, it is higher order or something.
15:54:20 <monochrom> dcoutts: pl is Yiddish for "problem", wn is Hebrew for "no".
15:54:23 <tibbetts> Generic Haskell. Interesting.
15:54:23 <TFK> Oh, any size.
15:54:35 <dcoutts> monochrom: :-) nice
15:54:38 * TFK reddens in the face
15:55:26 <Cale> You should also be able to write some template haskell that does it in any particular case.
15:55:27 <shapr> tibbetts: But Generic Haskell isn't the standard everyday GHC.
15:55:32 <tibbetts> I'm probably too used to thinking of polymorphic pattern matching as leading to case by case code generation, as it does in C++, where this function is fairly possible.
15:55:51 <tibbetts> Sure. I'm assuming Generic Haskell is some whack-job theoretically pure thing.
15:56:15 <shapr> Hm, I actually like Generic Haskell.
15:56:26 <tibbetts> I could take the nasty approach and write a perl script to define functions over tuple from 1 to N members, but that is pretty dirty.
15:56:28 <shapr> I'd say that it's about as whack-job theoretically pure as Perl.
15:56:29 <TFK> But, what would be the use of such a function?
15:57:16 <tibbetts> Well, if you are using lists of tuples to represent relations, then this function is required to do a join.
15:57:36 <tibbetts> Maybe there is a more appropriate way to represent relations.
15:58:18 <shapr> What relations do you want to represent?
15:58:33 <tibbetts> arbitrary relations, like in a relational database.
15:58:46 <shapr> Ok, what's the problem?
15:59:01 <tibbetts> You mean what am I really trying to do?
15:59:05 <shapr> yup.
15:59:18 <TFK> Somehow that question is always asked last :-)
15:59:23 <Cale> If we had subtyping then it would be pretty easy to have a type of all tuples, and your function would be a map Tuples -> Tuples -> Tuples
15:59:29 <shapr> That or, equally 'why do you need to join tuples to model a database?"
15:59:43 <Cale> tibbetts: you might be interested in HLists
15:59:48 <tibbetts> Implement (or reallly prototype) a relational database in Haskell, such that I can play around with it.
16:00:04 <tibbetts> HLists? Where would I find TFM?
16:00:06 <shapr> You could use HSQL and/or HaskellDB.
16:00:30 <Cale> http://homepages.cwi.nl/~ralf/HList/
16:00:40 <tibbetts> I don't want to use a database, I want to play around with concepts. This may not be well formed.
16:00:41 <shapr> S. Alexander Jacobson recently wrote an in-memory database, but I haven't tried it.
16:00:59 <Jerub> I don't like the idea of in-process databases.
16:01:31 <shapr> If you have a library nearby the Rabhi & Lapalme functional algorithms book may help.
16:01:39 <Jerub> better to have a completely different process you communicate with, just for memory management reasons.
16:01:48 <Cale> tibbetts: they're type-safe heterogeneous lists -- there's a lot of type-level programming that goes on to make it work, but once you see the basic idea, it's not so bad
16:02:53 <tibbetts> HList definitely looks interesting.
16:03:11 <Cale> With things like multiparameter typeclasses and functional dependencies, the Haskell type system becomes somewhat prolog-like :)
16:06:36 <tibbetts> I hear all programming is secretly a typesystem.
16:07:01 <shapr> I thought all typesystems were secretly programming?
16:08:13 <dcoutts> Cale, what worrys me is that it'll go the way of c++ "holy **** its a turing complete language on the type level! But it's incomprehensible. If only we'd designed it rather than discovered it, things might have been ok"
16:09:03 <shapr> You could use Epigram, where functions and types have very little difference.
16:09:19 <monochrom> all brains are secretly computers
16:10:01 <shapr> Guten Abend kriga
16:10:09 <SyntaxNinja>  heh
16:10:16 <shapr> bah
16:27:36 <skew> tibbetts: one thing that is pretty easy to do is work with nested tuples
16:28:06 <skew> like (a , (b, c)) -> (d, (e, (f, g))) -> (a, (b, (c, (d, (e, (f, g))))))
16:28:39 <tibbetts> Lispy.
16:28:58 <skew> the problem with typeclasses and tuples is that there isn't really a very natural way to take a part a tuple that's all typesafe
16:29:24 <skew> If you use a number you might go past then end
16:29:32 <wagle> (a , (b, c)) -> (d, (e, (f, g))) -> (a, (b, (c, (d, (e, (f,
16:29:36 <wagle>               g))))))
16:29:39 <tibbetts> caaadr :)
16:29:43 <wagle> stupid paste
16:30:05 <skew> It's maybe acceptable at runtime if that's an error you want to allow and catch with exceptions, but it's not so nice in the types
16:30:20 <wagle> dont mind me..
16:31:00 <tibbetts> Yeah. If you do caaadr and friends you can make the typing work, but at the expense of having to declare N functions or so.
16:31:17 <tibbetts> And of course not being all that readable.
16:31:22 <skew> as far as compile time turing-complete type magic by accident goes, I think the Haskell way is much nicer than the C++ way, beacuse it looks like prolog as opposed to total insanity
16:31:28 <skew> tibbetts: that's not what I'm talking about
16:31:46 <skew> you can't exactly do a caaaaaadr that works on all tuples
16:32:04 <skew> and even if you could, you still couldn't really figure out how many elements to pull out or anything
16:32:05 <tibbetts> Sure, it would fail to typecheck if you tried to hand it (a,(b,c))
16:32:41 <TheHunter> or, you can do the continuation thingy and represent the tuple (a,b,c) by (a -> b -> c -> r) -> r. Then merging tuples is just function composition.
16:32:46 <skew> yeah, but just some kind of tuple-car and tuple-cdr isn't enough to hit all the elements of (a,b) and (a,(b,c))
16:32:53 <wagle> pi1 = (a, b) -> a
16:33:07 <wagle> pi1 :: (a, b) -> a
16:33:17 <skew> because if you figured out at runtime what to do, then it looks like a hole as far as the typesystem can see
16:33:20 <TheHunter> @type ($ '1') . ($ "a") . ($ (1::Int,2::Int))
16:33:25 <lambdabot> ($ '1') . ($ "a") . ($ (1::Int,2::Int)) :: forall b.
16:33:25 <lambdabot>                                            ((Int, Int) -> [Char]
16:33:25 <lambdabot> -> Char -> b) -> b
16:33:26 <wagle> pi12 :: ((a1, b1)a, b) -> b2
16:33:28 <wagle> pi12 :: ((a1, b1)a, b) -> b1
16:33:32 <wagle> .. etc
16:33:39 <tibbetts> Why not? You get (a,b) with car and cdr, and (a,(b,c)) with car, caar and cadr.
16:33:39 <wagle> pi12 :: ((a1, b1), b) -> b1
16:33:51 <skew> tibbetts: how do you decide which to do, though?
16:33:58 <TheHunter> ok, so (a,b,c) is (c -> b -> a -> r) -> r.
16:34:17 <skew> you need to bring in the type classes
16:34:18 <tibbetts> Ah, I see your point.
16:34:31 <skew> What I was thinking of doing was using that type-level prolog stuff to generate these functions for you
16:34:32 <tibbetts> You could represent (a,b,c) as (a,(b,(c,_)))
16:34:51 <tibbetts> ie, properly lispy.
16:34:58 <skew> tibbetts: yes, something like that is much nicer than leaving a type at the end
16:35:19 <wagle> why not as [a,b,c] then?
16:35:34 <tibbetts> a b and c can be of different types.
16:35:37 <skew> the typeclass looks like class TupleAppend a b c | a b -> c where tupleAppled :: a -> b -> c
16:35:41 <wagle> ok
16:35:55 <wagle> hlists  (bwahaha?)
16:36:08 <tibbetts> I in fact have the HLists paper open right over here.
16:36:18 <skew> with instance TupleAppend () b b where tupleAppend a b = b
16:36:20 <wagle> still havent gotten around to grokking hlists, hence the bwhaha
16:36:53 <tibbetts> But I might opt for making the domain of my system Ints rather than use HLists, since they aren't seeming very easy to use.
16:37:09 <wagle> yeah,  reading the hlists paper keeps rising to the top of my todo lists, but hasnt quite happened yet
16:37:13 <skew> and instance (TupleAppend as b c) => TupleAppend (a,as) b (a,c) where tupleAppend (a,as) b = (a,tupleAppend as b)
16:37:22 <skew> Actually, this is a lot like a tiny little bit of HList
16:37:25 <tibbetts> skew: You've pretty much lost me.
16:37:43 <skew> except they made their own HCons and HNil types instead of reusing pairs and ()
16:37:54 <tibbetts> Probably because "class" and "instance" are still unfamiliar to me.
16:37:58 <skew> tibbetts: I missed the part where you said how much Haskell you knew
16:38:01 <tibbetts> Yeah, I can see that relation.
16:38:06 <wagle> i think there is a time/space difference between (a,b,c) and (a,(b,c))
16:38:17 <skew> wagle: yeah
16:38:36 <TheHunter> there's also a semantic difference...
16:38:39 <skew> but I think with enough pragmas you can convince GHC otherwise
16:38:39 <tibbetts> wagle: Yeah, you have to unbox multiple time and chase pointers, rather than something cleaner.
16:39:38 <tibbetts> I'm on my third time around trying to grok haskell. I tend to approach programming languages from a strange direction. But I only have about 10 hours of actual time working with Haskell. A bit more working with ML derivatives.
16:39:38 <skew> I think something like data TyCons a b = TC a {-# UNBOX #-} !b gives you equivalent memory layout, and the ! alone gives you the same semantics
16:39:47 <skew> tibbetts: that's a good start
16:40:10 <wagle> well, if the heap dsign were really clever, (b,c) could be a pointer into the middle of an (a,b,c) data structure (ala C pointers)..  8)
16:40:25 <skew> what ML were you using that lets you append tuples like that?
16:40:43 <skew> Actually, I don't know of any typesafe language that lets you really append tuples
16:40:45 <tibbetts> None, as far as I know. THe appending tuples thing is a new iproblem.
16:40:59 <skew> Epigram doesn't give you any data structures to start with...
16:41:14 <tibbetts> I was mostly going in with "You should be able to do this" and trying to sort out precisely why.
16:41:39 <skew> but I bet you could end up with a type you could use like "typle (suc (suc (suc zero))) A B C"
16:41:51 <tibbetts> The pragmatic side of my brain wants to go write the perl script to generate the haskel for tuples of up to 10 elements and get on my with my work, but that is probably wrong. :)
16:41:57 <skew> the suc and zero because you have to define your own number too :)
16:42:32 <skew> tibbetts: the use of typeclasses in my code or HList is pretty wierd
16:42:35 <tibbetts> I'm all set with languages that don't let me say "3"
16:42:36 <Cale> tibbetts: there's the template haskell option :)
16:43:21 <skew> tibbetts: I would suggest giving up and moving on to some other excercise if things like type-class programming will make you decide that the language is too wierd
16:44:01 <skew> tibbetts: but if you're the start that likes to start with the most generic form of a feature then this might be just the thing
16:44:05 <tibbetts> Well, my goal is to find a good method for prototyping relation manipulation (ie, SQL-like stuff). The C++ I work in at my day job isn't doing it for m.e
16:44:09 <TheHunter> at the risk of repeating myself, forall r. (c -> b -> a -> r) -> r is a nice and underappreciated way to represent tuples. You won't need any type class magic but you might run into higher-rank polymorphism.
16:44:32 <tibbetts> TheHunter: Actually, I was just going back and thinking about that one.
16:44:58 <skew> tibbetts: a completely different approach is to make your relations runtime data
16:45:04 <tibbetts> I'm not sure I really follow it though.
16:45:25 <skew> tibbetts: the tuple thing is the pure lambda calculus way of doing things
16:45:44 <tibbetts> Relations as runtime data was actually the first approach  I thought about, but a Haskell-loving coworker got me going with using tuples, until Join reared its ugly head.
16:46:05 <wagle> yeah, we dont number numbers either..  church numerals!
16:46:15 <wagle> yeah, we dont need numbers either..  church numerals!
16:46:31 * wagle is only paying half of half attention
16:46:50 <skew> if t is a tuple with that type, then you pass it a three argument function that is going to use those values
16:47:08 <tibbetts> Ah. That's actually quite cute.
16:47:20 <tibbetts> Let me go play with that.
16:47:26 <skew> sort of like doing (1,"A",False) (\number name alive -> ...), rather than pattern matching
16:47:53 <tibbetts> Hmm, I think the typing breaks down two steps from here. But lets take the two steps.
16:49:16 <stepcut> this live gnu/hurd cd does not have emacs on it... :-/
16:49:36 <tibbetts> Yeah, because I don't see how to have the type of all functions that take some number of arguments to use in a filter operation over a list of these lamdba calculus tuples.
16:50:17 <tibbetts> Hmm, though maybe I just have to take one more step down the lambda calculus rabbit hole and remember that all functions only have one argument.
16:50:34 <TheHunter> @type ($ \_ x -> x)
16:50:36 <lambdabot> ($ \_ x -> x) :: forall t t1 b. ((t -> t1 -> t1) -> b) -> b
16:51:06 <tibbetts> Or maybe I need to go read my haskelll tutorial more. I think taht is really the answer right now.
16:51:31 <TheHunter> @type ($ \x _ -> x) :: (forall r. (a -> b -> r) -> r) -> b
16:51:33 <lambdabot> bzzt
16:52:26 <TheHunter> @type ($ \_ x -> x) :: (forall r. (a -> b -> r) -> r) -> b
16:52:28 <lambdabot> ($ \_ x -> x) :: (forall r. (a -> b -> r) -> r) -> b :: forall
16:52:28 <lambdabot> a b.
16:52:28 <lambdabot>                                                         (forall
16:52:28 <lambdabot> r. (a -> b -> r) -> r) -> b
16:53:19 <vincenz> @type (<|>)
16:53:20 <lambdabot> bzzt
16:53:58 <Cale> tibbetts: anyway, tuples of sizes other than 0 and 2 are actually pretty rare in Haskell code.
16:54:08 <_metaperl> @type length
16:54:10 <lambdabot> length :: forall a. [a] -> Int
16:54:52 <TheHunter> @index <|>
16:54:54 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
16:55:06 <TheHunter> @type (Text.ParserCombinators.Parse.<|>)
16:55:08 <lambdabot> bzzt
16:55:10 <TheHunter> @type (Text.ParserCombinators.Parsec.<|>)
16:55:11 <lambdabot> (Text.ParserCombinators.Parsec.<|>) :: forall a st tok.
16:55:11 <lambdabot>                                        Text.ParserCombinators.
16:55:11 <lambdabot> Parsec.Prim.GenParser tok st a
16:55:11 <lambdabot>                                        -> Text.ParserCombinators.
16:55:11 <lambdabot> Parsec.Prim.GenParser tok st a
16:55:12 <lambdabot>                                        -> Text.ParserCombinators.
16:55:14 <lambdabot> Parsec.Prim.GenParser tok st a
16:55:16 <Cale> Usually you'll define a new datatype for anything larger, because you'll have specific meanings in mind for the various positions in the data.
16:55:37 <TheHunter> hmm, lambdabot needs to use a cvs ghc...
16:55:59 <Cale> TheHunter: has that type changed since 6.4?
16:56:25 <Cale> @type Map.fromList
16:56:26 <lambdabot> bzzt
16:56:37 <TheHunter> Prelude> :t (Text.ParserCombinators.Parsec.<|>)
16:56:37 <TheHunter> (Text.ParserCombinators.Parsec.<|>) :: forall a st tok.
16:56:37 <TheHunter> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:56:37 <TheHunter> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:56:37 <TheHunter> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:58:28 <_metaperl> it's so easy to resume your place in Haskell code. It has probably been 3 weeks since I stopped in the middle of chapter 6 in Thompson's book... the code was so logical, I just had to read it and make more logical statements
16:59:52 <stepcut> _metaperl: haha
17:00:05 <_metaperl> :)
17:03:40 <skew> wow, it is painful trying to learn a new OO language after Haskell
17:03:51 <stepcut> haha
17:03:52 <skew> can't modularize code
17:03:57 <stepcut> which OO language ?
17:04:00 <skew> ruby
17:04:03 <skew> which looks pretty nice
17:04:23 <skew> I decided to rewrite a little substitution cipher program I made in Haskell the other night
17:04:57 <stepcut> I keep meaning to learn some other languages, but there is too much I have not learned about haskell
17:05:16 <skew> it prints the message under your current (partial) substitution, printing the unsubstituted text in reverse video (with ansi terminal escapes)
17:05:41 <skew> I really want the unsubstitution code to return [Either Char Char]
17:06:08 <skew> but I think I'm going to have to lump doing the substitution in with sticking in the esacpes
17:06:42 <skew> and use a mutable variable to track whether there is already an escape going, horrors
17:07:40 <autrijus> skew: do you enjoy monadic puzzles? :-)
17:07:49 <skew> sure
17:08:01 <autrijus> skew: can you pull a copy of Pugs?
17:08:05 <skew> autrijus: I forgot to ask, does perl 6 have subcontinuations build it?
17:08:15 <skew> or do you just want them internally in pugs?
17:08:27 <autrijus> skew: I'll try to get them in pugs before I can expose them
17:08:37 <autrijus> anyway, in src/Pugs/AST.hs line 731
17:08:40 <autrijus> runEvalIO (EvalSTM y) = morph y
17:08:42 <skew> sure, where from?
17:08:56 <autrijus> darcs is http://wagner.elixus.org/~autrijus/pugs
17:09:03 <autrijus> svn is http://svn.openfoundry.org/pugs
17:09:19 <autrijus> now I'm as close as
17:09:20 <autrijus>     morph (ContT c) = morph' (c (\_ -> return $ undef))
17:09:30 <autrijus>     morph' (ReaderT r) = do { env <- ask; morph'' (r env) }
17:09:46 <autrijus>     morph'' stm = do { _ <- liftIO $ atomically stm ; ... }
17:09:56 <autrijus> but it's 8am now, my brian is fried
17:10:01 <autrijus> so I can't figure out how to put the prompt back
17:10:11 <skew> I get a 404 on http://wagner.elixus.org/~autrijus/pugs/_darcs/inventory
17:10:24 <autrijus> the goal is to create a
17:10:24 <autrijus> morph :: ContT Val (ReaderT Env STM) a -> ContT Val (ReaderT Env IO) a
17:10:30 <autrijus> http://wagner.elixus.org/~autrijus/darcs/pugs/
17:10:31 <autrijus> sorry
17:10:57 <skew> okay. Actually, I think darcs prefers not to have the trailing slash
17:11:02 <autrijus> k.
17:11:21 <skew> at least, it just slaps "/_darcs/inventory" on the end without checking for an existing slash
17:11:39 <autrijus> ContT b STM a -> ContT b IO a
17:11:45 <autrijus> is basically where I'm stuck at
17:11:52 <skew> although that shouldn't be a problem under any sane webserver
17:12:08 <beschmi> skew, i'm just trying to fix that ;)
17:12:36 <autrijus> so both the prompt type (b) and return type (a) are invariant
17:12:37 <beschmi> it's a real problem with "darcs get host:"
17:12:53 <autrijus> but I need to "pull out" the transformed monad
17:12:55 <skew> I suppose if your pugs repository was dynamically created by some kind of object publishing system it might look for an object named ''
17:12:59 <TheHunter> autrijus, you sure that is possible?
17:13:12 <autrijus> TheHunter: I have this feeling that it should be.
17:13:15 <autrijus> because we have
17:13:20 <autrijus> atomically :: STM a -> IO a
17:13:31 <skew> it's possible that the type of tags prevents that sort of thing
17:13:39 <skew> but I'll see
17:13:46 <skew> I'll have to read up on the subcontinuations
17:13:48 <TheHunter> ContT r m a = (a -> m r) -> m r.
17:13:56 <skew> autrijus: any suggestions on the cipher editing thing, by the way?
17:14:16 <autrijus> skew: sorry, havn't been backlogging
17:14:29 <autrijus> TheHunter: you're suggesting that the 'm' is inviolable :)
17:15:06 <autrijus> skew: oh, and in this:
17:15:07 <autrijus> ContT b STM a -> ContT b IO a
17:15:09 <autrijus> you can assume
17:15:21 <autrijus> castV :: a -> b
17:15:24 <autrijus> vCast :: b -> a
17:15:25 <skew> I have ciphertext, a hash with a partial assigment of characters to characters, and want to print out the cipher under that substitution, using ansi esacape sequences for reverse video on unsubstituted ciphertext
17:16:22 <TheHunter> i'm pretty sure mapCont :: (r -> s) -> ((a -> r) -> r) -> (a -> s) -> s is unimplementable.
17:16:46 <autrijus> bummer.
17:16:57 <skew> It feels a bit clunky not to modularize that into String -> Map Char Char -> [Either Char Char], and [Either Char Char] -> String
17:17:21 <skew> TheHunter: I'm pretty sure you use r with two variances there
17:17:46 <skew> mapCont :: (r -> s) -> (s -> r) -> ((a -> r) -> r) -> ((a -> s) -> s) should be easy
17:17:57 <TheHunter> yeah, that's easy.
17:18:12 <TheHunter> but there's no IO -> STM.
17:18:16 <skew> you could always used undefined for the conversion :)
17:18:24 <autrijus> there is.
17:18:30 <autrijus> if needed, please use unsafeIOToSTM
17:18:38 <autrijus> but I'm not sure why it would be needed
17:18:45 <autrijus> oh, you mean IO -> STM
17:18:48 <autrijus> not IO a -> STM a
17:18:54 <autrijus> or am I missing something?
17:19:02 <skew> TheHunter: it's a transformer, so IO and STM are not return types
17:19:04 <TheHunter> sure, i menat IO a -> STM a, was just being lazy.
17:19:11 <skew> TheHunter: I don't know about the return type stuff, though
17:19:25 <autrijus> basically, I'm hoping that with both
17:19:28 <autrijus> unsafeIOToSTM :: IO a -> STM a
17:19:33 <skew> It might be easier just to make the EitherIOOrSTM monad
17:19:34 <autrijus> atomically :: STM a -> IO a
17:19:54 <TheHunter> with unsafeIOToSTM it's totally possible.
17:20:13 <autrijus> skew: I thought about that too
17:20:17 <skew> I don't know if that gives you semantics any better than using undefined :: IO a -> STM a, though
17:20:33 <skew> okay, I've got source. What now?
17:20:56 <autrijus> TheHunter: nice to hear that. :)
17:21:15 <autrijus> skew: well, if you want to build things, "perl Makefile.PL; make" will do it; "make ghci" gets you into ghci
17:21:24 <autrijus> skew: but really, just look at the code in src/Pugs/AST.hs
17:21:30 <autrijus> line 721
17:21:36 <autrijus> er, 731
17:21:48 <skew> I think I'm going to need a typecheker for this
17:22:08 <skew> src/Pugs/Cont.hs is where the continuation monads are defined?
17:22:14 <autrijus> yeah.
17:22:30 <autrijus> but the shiftT/resetT inside it is not used
17:22:34 <skew> and you say the problem is restoring the prompt?
17:22:45 <autrijus> well, twofold
17:23:09 <autrijus> one is that the "Val" type is fixed there
17:23:22 <skew> oh, b is one of those existential types tricks to keep prompts in their own monad?
17:23:51 <autrijus> b?
17:24:01 <autrijus> from the outside, b == Val here
17:24:10 <skew> oh
17:24:18 <autrijus> but you can freely use callCCT
17:24:18 <skew> What was that about prompts then?
17:24:51 <skew> I bet you could find a better quote for continuations
17:25:07 <autrijus> possibly.
17:25:25 <autrijus> I'm sorry, I really hate to drop this conversation now, but my brain is on strike
17:25:47 <autrijus> I agree that it is maybe easier to do the STMorIO monad thing.
17:25:48 <skew> It doesn't have right the feeling of insanity behind it
17:26:01 <autrijus> but I'm curious about how making this works
17:26:31 <autrijus> skew: oh, there is an insane, non-transfomer version in Cont/CPS.hs and Cont/Prompt.hs
17:26:33 <skew> wait, is Cont just plain continuations?
17:26:38 <autrijus> I tried to adapt that but not quite succeeding
17:26:39 <skew> I meant the quote
17:26:41 <autrijus> uh, sure, yes
17:26:53 <autrijus> Cont' ?
17:26:57 <skew> yeah
17:27:41 <autrijus> yeah, it's plain, I think
17:27:59 <autrijus> please type away and/or mail to autrijus at autrijus dot org :)
17:28:06 <autrijus> thanks so much for helping me out
17:28:11 <autrijus> but I really need to sleep.
17:28:13 <skew> what's this data (Typeable a) => Eval a where EvalIO :: (type) ...
17:28:14 * autrijus waves &
17:28:20 <skew> bye
17:28:21 <autrijus> that's my main monad
17:28:31 <autrijus> EvalIO / EvalSTM are two constructors
17:28:34 <autrijus> it's GADT syntax.
17:28:35 <autrijus> &
17:28:43 <skew> Oh, I read class, not data
17:29:03 <skew> I was wondering if class associated types sneaked into GHC 6.4 while I wasn't looking
17:31:11 <dons> not yet.
17:32:57 <TheHunter> hmm, now that autrijus is gone, i wonder if it was a requirenment that the thing be built on top of shiftT.
17:33:33 <skew> TheHunter: not yet, it seems
17:33:41 <skew> subcontinuations are phase two
17:34:18 <TheHunter> because i'm not even sure that it is possible with this formulation of shiftT.
17:34:39 <TheHunter> "shiftT :: Monad m => ((a -> m s) -> ContT s m s) -> ContT s m a" would be fine, though.
17:34:43 <skew> I think it's pretty neat how other languages struggle and sweat to add new stuff like contunations, and in Haskell somebody just applies about 20,000 IQ-years and invents another monad
17:45:37 <Cale> tibbetts: http://www.haskell.org/hawiki/HaskellIrcPastePage -- I wrote a little Template Haskell program to generate the code to join tuples :)
17:46:57 <tibbetts> cute, thanks.
17:48:13 <tibbetts> What do I need to do to run that?
17:48:37 <tibbetts> ghci doesn't like it, which I guess should have been obvious.
17:48:39 <Cale> oh, right, you should pass the parameter -fth
17:48:56 <Cale> I should have included that in the source :)
17:49:03 <tibbetts> Ah.
17:49:25 <tibbetts> That's actually quite cute. Is there a catch?
17:50:53 <Cale> Not really, though your haskell implementation will have to support template haskell to use it
17:51:09 <Cale> I'm not sure of the level of standardisation of template haskell.
17:51:38 <tibbetts> That's fine for playing around and just using ghc.
17:51:45 <Cale> yeah
17:53:30 <Cale> I suppose there's the catch that you have to write $(joinTuples 3 2) and not joinTuples 3 2, but it's probably a good thing to be aware of where you're splicing in code that will be generated at compile time :)
17:54:32 <wagle> practice first, standardization second.  standards that preceed practice never last.
17:55:09 <Cale> wagle: I agree
18:03:24 <monochrom> and standards that follow practice stick forever
18:05:24 <Jerub> wagle: unforutnatley you're wrong
18:05:33 <Jerub> standards that preceed practice always haunt.
18:06:34 <monochrom> I'll just sum up the situation with: the humankind sucks
18:06:53 <ozone> template haskell folks -- how do i reify a class declaration?
18:10:12 <Lemmih> "reify ''ClassName"?
18:10:26 <ozone> oh
18:10:28 <ozone> it's two quotes
18:10:31 <ozone> sigh, thanks lemmih
18:11:09 <Lemmih> No problem. Someone should really write an up-to-date TH tutorial.
18:27:49 <skew> does anybody know much about the generics stuff in ghc? The User's guide warns that it is "currently broken in GHC 5.02", so I doubt its accuracy
18:39:44 <Cale> Lemmih: I agree :) I don't really know very much about TH, I read the original paper, and can sort of find the things I'm looking for in the GHC documentation, though they seem to be renamed.
18:42:39 <dons> I think you have to know someone who knows TH :}
18:42:57 * Lemmih wrote a big (4000+ lines) TH program some time ago and _really_ wished for proper documentation while doing so.
18:59:55 <juhp> Atom.hs:22:53: Not in scope: `hashPS'
19:02:38 <juhp> with ghc-6.4
19:27:47 <beschmi> juhp: what are you trying to compile?
20:16:12 <blackdog> i'm guessing this is haskell sleepytime
20:17:35 <dons> @yow
20:17:36 <lambdabot> NEWARK has been REZONED!!  DES MOINES has been REZONED!!
20:17:41 <dons> @ghc
20:17:42 <lambdabot>   adjustor creation not supported on this platform
20:17:47 <dons> yow!
20:22:47 <blackdog> hey don. may i say, i love your minimalist progress reports.
20:23:02 <dons> oh, thanks :) it's a zen thing.
20:23:23 <Jerub> yeah, saying nothing with lots of words people are good at.
20:23:30 <Jerub> saying lots with nothing is an art.
20:23:46 <blackdog> Sean tends to write soap operas :)
20:23:57 <dons> that's very true.
20:24:15 <dons> I think I might just send diffs in future.
20:28:43 <ozone> blackdog: i write science fiction novels!
20:28:46 <blackdog> Don: what the hell does @ghc do?
20:28:55 <Jerub> random ghc error message
20:29:01 <Jerub> @ghc
20:29:02 <lambdabot>   Illegal polymorphic type signature in pattern
20:29:03 <dons> let @ghc = @quote ghc
20:29:31 <blackdog> ozone: perfect. now we just need the slash fanfic writer.
20:29:52 <dons> hehe
20:39:07 <Lemmih> I suck at describing my projects. All my HCAR entries are like 2-3 lines long /-:
20:45:51 * Lemmih ponders why shapr limits his 'myconst' function to Strings.
21:33:30 <hellish> Good evening #haskell!
21:54:03 <lispy> i have a function here, degree a p = length (legalMoves a p)  I was hoping to rewrite this as degree = length . legalMoves, but this fails (I think because legalMoves is looking for two parameters but . is only prepared to give it one) how should i fix this?
21:58:19 <Lor> e.g. degree = curry . length . legalMoves . uncurry, but that's admittedly not too pretty.
21:58:33 <lispy> yeah
21:58:45 <lispy> perhaps the argument way is better her
22:00:32 <Lor> degree = length . (legalmoves $)
22:00:38 <Lor> not very pretty either.
22:01:04 <lispy> hmm...not sure i understand how that works
22:01:15 <lispy> $ changes the associativity right?
22:01:44 <Lor> Oops, sorry.
22:04:06 <Lor> (length .) . legalMoves
22:07:11 <Gahhh> @pointless  degree a p = length (legalMoves a p)
22:07:12 <lambdabot> degree = (length .) . legalMoves
22:09:26 <Lor> Oo, cool.
22:10:26 <lispy> heh
22:16:28 <blackdog> the fascination @pointless holds is very odd. you wouldn't put that kind of code into a real app in a screaming fit, but it's such fun to look at...
22:16:40 <blackdog> lispy: you're a lisp hacker, right?
22:16:46 <lispy> aye
22:17:03 <blackdog> what do you think is better about lisp than haskell, from what you've seen?
22:17:23 <lispy> s/better/different/ :)
22:17:29 <blackdog> i'm thinking about learning it, and want some suggestions on techniques/source code to look at.
22:17:50 <blackdog> nah, i'm not interested in just different. surely they're better at something. :)
22:17:53 <lispy> macros in lisp add a lot to the language (they are not perfect, tho)
22:18:14 <lispy> with macros you can tell the compiler how to generate code
22:18:23 <lispy> which can be very handy
22:18:34 <lispy> the OO support in lisp is very good
22:18:35 <blackdog> ok. have you had a chance to check out TH and see how it compares?
22:18:44 <lispy> TH?
22:18:54 <blackdog> template haskell. compile-time metaprogramming
22:19:07 <lispy> ah, sounds interesting, i've not seen it tho
22:19:15 <blackdog> it doesn't seem to be as mainstream in haskell as macros are in lisp, though
22:19:38 <lispy> another thing in lisp is dynamic type CAN be very nice at times
22:20:11 <lispy> lisp is multiparadigm, and that can be nice as well
22:20:42 <blackdog> i hear that a lot (about dynamic types). what's it useful for, there? I've used it for runtime plugins in haskell (via don's stuff)
22:20:45 <lispy> blackdog: macros have allowed lisp to implement just about any feature found in other languages
22:20:48 <dons> added a bunch of ghc quotes. playing the ghc game TheHunter suggested might be feasible now.
22:20:52 <dons> @ghc
22:20:54 <lambdabot>   Kinds don't match in type application
22:21:21 <lispy> blackdog: with the exception of lazy evaluation
22:21:36 <blackdog> lazy evaluation lets you implement a lot of other features, too. :)
22:21:36 <Gahhh> dons: This could turn into a game. "Write a pience of code that gives the following error!" heh
22:21:58 <lispy> blackdog: parametric polymorphism (is that what they call it in haskell?) is very nice and comes very close to dynamic type
22:22:35 <lispy> but, i think dynamic type wins when you are "scripting"
22:22:37 <dons> Gahhh. yep. that was TheHunter's idea too.
22:22:54 <lispy> small, simple programs that just want to manipulate the data we care about and ignore the rest
22:23:15 <dons> some of the errors are easy, some very hard, or require you to find a ghc bug.
22:24:25 <blackdog> lispy: tree processing code, or more like regex based stuff?
22:24:25 <lispy> blackdog: modern lisp has great performance via imperative features as well.  So you can use functional all day long preserving referential transparency, then when it comes time to find and fix the preformance issues you have things like setf
22:24:58 <lispy> blackdog: i'm thinking more regex stuff, like reading in data and writing it out after minimal modification
22:25:18 <lispy> oh, that's another thing, you can reuse read and eval
22:25:26 <lispy> but perhaps haskell supports that
22:25:31 <boggy> what makes a PL functional?  syntax?
22:25:35 <blackdog> i don't see how static types get in your way there...
22:25:38 <Gahhh> lispy: what does lisp have over scheme ?
22:25:52 <lispy> Gahhh: scheme is lisp :)
22:25:56 <blackdog> (re simple regex-like stuff)
22:26:13 <lispy> Gahhh: scheme doesn't have CLOS
22:26:33 <Gahhh> lispy: does lisp have call/cc and stuff ?
22:26:43 <lispy> boggy: higher order functions is the main thing in my mind, others have different definitions
22:26:58 <lispy> Gahhh: not in the general sense that scheme does
22:27:07 <lispy> i don't really know scheme tho
22:27:39 <Gahhh> I tried to learn scheme for a bit. It feels weird after learning haskell.
22:27:40 <hellish> scheme = tiny and elegant, Common Lisp = Big and powerful.
22:27:42 <boggy> i'm just curious about what you meant re: the "imperative features" of lisp
22:27:46 <hellish> As I understand it.
22:27:54 <lispy> blackdog: one thing is that lisp has been around a very long time, and before haskell and ML there was virtually as nice as lisp
22:28:45 <lispy> boggy: ah, well you can get down and dirty and specify each action in your code and use destructive things like assignments and loop variables
22:29:06 <lispy> hellish: yeah, that's how i see it as well
22:29:21 <Lor> Note that loop constructs in scheme (do, named let) are not imperative.
22:29:40 <boggy> i'm guessing you mean, program state and side effects
22:29:47 <lispy> blackdog: i had a typo in that, i was trying to say that before Haskell and ML lisp was probably the best language (at least in my mind)
22:30:12 <lispy> boggy: yes, but there is a style to it as well
22:30:20 <blackdog> lispy: you're probably right. that history is what i'm interested in, too: i keep hearing stories about it being very easy to patch code while it's running. have you any experience with that?
22:30:21 <lispy> boggy: and i'm not explaining it well over irc :)
22:30:37 <lispy> blackdog: yes, and it's true
22:30:49 <lispy> blackdog: but it's a two-edged sword
22:30:58 <lispy> blackdog: and this is where macros fall apart also
22:31:34 <lispy> well, that and macros syntactily look like functions, but cannot be called (they are not first class)
22:39:54 <blackdog> ...thinking... don, can you call template haskell in code for hs-plugins?
22:40:13 <blackdog> i can't think of any good excuse to do so yet, but it sounds cool.
22:40:29 <ozone> blackdog: i'm pretty sure don's already got some examples of that in the hs-plugins distribution
22:40:47 <ozone> TH code is used for runtime metaprogramming
22:48:40 <dons> blackdog: yeah. can be done.
22:49:39 <dons> I don't actually use the TH code in the plugins though, ozone (i'm pretty sure). But I've heard of people doing it.
22:49:53 <dons> just for having splices in their plugins, for example
22:50:20 <dons> the runtime metaprogramming stuff uses TH to represent eval source, rather than just using raw strings.
22:52:32 <ozone> dons, nod
22:59:57 <mr-onionhead> hi folks.  In sml I'm used to annotating helper functions in the style let fun f(x:int):char = ... in ... end.  Is there a way to do this in haskell?
23:00:49 <skew> mr-onionhead: it's more natural to do the anotation like
23:00:54 <skew> let f :: Int -> Char
23:01:02 <skew>     f x = ...
23:01:07 <dons> @plugs let f x = x in f 1
23:01:10 <lambdabot> 1
23:01:19 <mr-onionhead> ahh... i don't realize you could that inside a let
23:01:20 <mr-onionhead> thanks
23:01:32 <dons> @plugs let f :: Int -> Int ; f x = x in f 1
23:01:33 <lambdabot> 1
23:01:41 <skew> @plugs let (f (x :: Int) ::Int) = x in f 1
23:01:43 <lambdabot> Parse error in pattern
23:02:00 <skew> well, you can at least write
23:02:00 <dons> @plugs let f x :: Int -> Int = x in f 1
23:02:02 <lambdabot> Illegal signature in pattern: Int -> Int
23:02:02 <lambdabot>         Use -fglasgow-exts to permit it
23:02:08 <skew> @plugs let f (x :: Int) = x in f 1
23:02:09 <lambdabot> Illegal signature in pattern: Int
23:02:09 <lambdabot>         Use -fglasgow-exts to permit it
23:02:24 <skew> if you pass -fglasgow-exts like the nice man says
23:02:55 <dons> @plugs let f x = x :: Int in f 1
23:02:57 <lambdabot> 1
23:02:58 <skew> why doesn't plugs load up on -fglasgow-exts -fgenerics -ftemplate -fallow-undecidables-instances etc.
23:03:02 <mr-onionhead> i'm using hugs, but i'll try w/o the haskell 98 compatibility
23:03:19 <dons> skew: seriously, there's a reason ;)
23:03:27 <reffie> @ghc
23:03:28 <lambdabot>   Cannot desugar this Template Haskell declaration
23:03:55 <dons> skew: along the lines of @plugs $(do something evil)
23:04:22 <mr-onionhead> are local functions definitions, btw, not considered good hakell style? none of the code i remember seeing online uses them
23:05:14 <dons> usually you'd put them in a where-clause
23:06:42 <mr-onionhead> right... (shouldn't be learning new lanauges past 2am)
23:06:58 <skew> it's better than copying code
23:09:36 <skew> using an inner function for recursion mostly goes away relative to something like Scheme, from using higher order functions, and because tail recursion with accumulating parameters isn't quite the same under lazy evaluation
23:10:21 <mr-onionhead> how does tail recursion change?
23:10:43 <skew> for one, it's not necessarily what you want
23:11:23 <skew> if you are generating a list or some other data structure, usually you can produce the first part of the result without needing your entire input
23:11:52 <skew> like incrementList (x:xs) = (x+1):incrementList xs; incrementList [] = []
23:12:36 <mr-onionhead> hmm... it seems like you'd have to allocate a memory cell.  Is it only one cell or order n?
23:12:59 <mr-onionhead> let me clarify
23:13:09 <skew> the usual tail recursion with an accumulating parameter would look like incrementList (x:xs) acc = incrementList xs (x:acc); incrementList [] acc = reverse acc
23:13:34 <skew> except now the function has to get through the entire list to produce any result
23:13:42 <skew> which is infinitely slower for infinite list
23:13:53 <mr-onionhead> got that:)
23:14:08 <skew> map (1+) [1..] happily counts away, but if it had to get to the end of [1..] first it would take a bit longer
23:14:55 <skew> also, the operation in x:acc doesn't actually get evaluated untill we try to look inside the accumulating parameter
23:14:57 <hellish> Haskell gives you a good excuse to not think about accumulators :)
23:15:01 <mr-onionhead> but for a fold over a finite list, do you have to allocate length of list thunks, or only 1?
23:15:51 <skew> so even if it were +, instead of doing the additions right away and taking constant memory like you might expect, it could instead just make a tree of thunks, and not evaluate them till the end anyway
23:16:52 <mr-onionhead> so that sound like a downside to me, but maybe a sensible one in order to get transparent behavoir over infnite structures
23:19:23 <mr-onionhead> hmm, i still don't have my head nearly arround lazyness
23:19:24 <skew> you can say that something should be done strictly if you really care
23:19:30 <skew> but usually you don't
23:19:40 <mr-onionhead> what's the syntax for that?
23:20:16 <skew> there's just a primitive  seq :: a -> b -> b  where they lied to the compiler and said that the result depends on a and b
23:20:24 <Cale> mr-onionhead: the transparent behaviour over infinite structures is quite nice. You eventually begin to look at data structures as ways to structure control flow :)
23:20:55 <skew> also, you can say that a field should be strict when you define a data structure
23:21:17 <mr-onionhead> cale: that's sounds terrifyingly close to lambda calculus hacks:P
23:21:35 <skew> Cale: yeah, I'm learning ruby right now and their use of generators is really annoying compared to lists
23:22:29 <skew> no zip I can find, etc.
23:22:38 <mr-onionhead> cool, i didn't know ou had the choice to be strict...
23:23:15 <Cale> yeah, seq is slightly evil, but it comes in handy sometimes. :)
23:24:57 <skew> well, ghc detects strictness and optimizes
23:25:03 <Gahhh> I missed zip while writing an iteration over STL types. Weird thoughts to have.
23:26:18 <reffie> http://fun.sdinet.de/pics/windoof/longhorn.jpg
23:27:11 <gzl> hahaha
23:27:19 <gzl> "Did you know? It is now 8:22 in London."
23:27:29 <Gahhh> lol nice one
23:28:00 <skew> But if you use + polymorphically somebody could always come along and define a Num instance where + isn't strict
23:28:22 <Cale> "My Mr. Rogers Network Neighourhood Area Places Collective"
23:28:55 <skew> numeric code explicitly given type Int should compile down to code that actually manipulates raw machine integers.
23:29:24 <skew> no thunks, no boxes
23:31:08 <mr-onionhead> skew: that's just an optimization though, right?  Like this change can never effect the terminiation behavior of a program?
23:31:19 <skew> right
23:31:30 <skew> it only does that to things that it can tell are strict
23:31:49 <mr-onionhead> makes sense
23:31:53 <skew> which is why telling it that things are strict with seq or various other tricks can make a difference
23:32:02 <skew> if it just did that everywhere then you would have a strict language
23:33:10 <skew> but there is some promising research into making not quite so lazy languages, that actually try to evaluate something for a tiny bit before getting tired and making a thunk
23:33:45 <mr-onionhead> that very cool, i am worried about overhead from thunking
23:34:05 <skew> rather than the inhuman procrastination of putting off the effort of computing 1+1 until you are sure you actually have to
23:34:15 <mr-onionhead> do you have link reference where i could read the not a lazy lazyniess?
23:36:23 <skew> there is Eager Haskell, which is not quite the one I'm thinking of
23:38:30 <dons> you could also try -fnumbers-strict ;)
23:38:39 <hellish> Anyone have a link to the paper discussed here a while ago? It was something about the algebraic properties of regexps.
23:38:58 <dons> nothing in the logs?
23:39:22 <skew> This is more what I was thinking about http://citeseer.ist.psu.edu/ennals03optimistic.html
23:39:27 * hellish checks
23:39:35 <skew> hellish: not for you
23:41:10 <hellish> Why do I have to register to search? Grr...
23:41:51 <mr-onionhead> thanks skew
23:41:52 <dons> try clog
23:42:08 <dons> http://tunes.org/~nef/logs/haskell/
23:42:37 <mr-onionhead> anyhow, i'm outa here. goodnight all
23:45:40 <autrijus> hi.
23:45:44 <skew> hi
23:46:03 <Gahhh> grr $300 for adobe acrobat standard...
23:46:20 <skew> what does that do for you?
23:46:35 <hellish> Gahhh, if you just want to output pdf's, use TeX
23:46:44 <Gahhh> hehe
23:46:52 <Gahhh> I was looking into it for annotating pdf's.
23:47:35 <dons> $300! I'm so glad we have free software
23:47:53 <Gahhh> well, do you know a OSS app that annotates pdf's ?
23:48:03 <Lor> Annotates how?
23:48:12 <Gahhh> comments
23:48:12 <skew> dons: computers would be nearly useless otherwise
23:48:16 <hellish> I think he wants to scribble in the margins
23:48:19 <Lor> pdftex can do quite a bit of stuff.
23:48:38 <Gahhh> converts pdf to TeX ?
23:48:51 <earthy> generates pdf from TeX
23:49:02 <gzl> wow, converting pdf -> tex would be weird.
23:49:06 <Gahhh> I'm not trying to generate pdf's heh.
23:49:35 <skew> I think a cross compiler would be weirder
23:49:45 <Gahhh> I have this 600+ page pdf, and I can't print it out and try to take notes in the tiny margins. Oh well.
23:50:29 <skew> take all those postscript programs with names like "A Monadic Framework For Subcontinuations" you have lying around and port them to Java 5!
23:50:45 <Gahhh> lol
23:50:47 <Gahhh> java 5
23:50:54 * hellish found it
23:51:11 <Gahhh> why don't I start writing a BSD licensed Fortress compiler while I am at it...
23:52:36 <skew> why not just write a few libraries for Epigram?
23:53:15 <pimaniac> Gahhh: i see something in java.  http://multivalent.sourceforge.net/
23:54:05 <Cale> Create a functional language F and an imperative language I, and write compilers f: F -> I and i: I -> F such that f.i.f = f and i.f.i = i :)
23:54:45 <Gahhh> pimaniac: Thanks. That looks interesting. You have out-googled me.
23:54:54 <Cale> I'm tired
23:54:55 <skew> Cale: sounds pretty trivial if you cheat with comments
23:54:58 <Cale> time to sleep
23:55:04 <pimaniac> Gahhh: i got the m4d sk1llz at digging up random crap :)
23:55:05 <Cale> skew: heheheh
23:55:11 <Cale> no comments!
23:55:34 <skew> I bet you could encode church numerals in your control structure and go from there
23:57:38 <jlouis> skew: hehe
23:59:49 <awarth> hello
