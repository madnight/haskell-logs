00:00:06 <dons> oh. you never said that!
00:00:28 <monochrom> you can copy from a famous paper
00:00:58 <Pseudonym> @plugs putStrLn "Hello"
00:00:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No IO allowed
00:01:02 <Pseudonym> Damn.
00:01:03 <desrt> oh
00:01:07 <desrt> that's a much nicer message
00:01:12 <Gahhh> @plugs show "yay"
00:01:12 <Pseudonym> @plugs unsafePerformIO (putStrLn "Hello")
00:01:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "\"yay\""
00:01:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafePerformIO'
00:01:19 <dons> :P
00:01:22 <Pseudonym> :-)
00:01:37 <Pseudonym> @plugs unsafeCast 1 :: String
00:01:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafeCast'
00:01:49 <dons> there's an unsafeCast now?
00:02:04 <Pseudonym> Oh, it's unsafeCast#, isn't it?
00:02:08 <Pseudonym> @plugs unsafeCast# 1 :: String
00:02:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafeCast'
00:02:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `#'
00:02:12 <dons> unsafeCoerce#
00:02:15 <Pseudonym> That's it.
00:02:19 <dons> @type GHC.Base.unsafeCoerce#
00:02:20 <monochrom> yeah, it unsafely casts anything to the error message "variable not in scope..."
00:02:20 <Pseudonym> @plugs unsafeCoerce# 1 :: String
00:02:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- GHC.Base.unsafeCoerce# :: forall b a. a -> b
00:02:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafeCoerce'
00:02:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `#'
00:02:25 <dons> :P
00:02:27 <Gahhh> how are infinite lists handled in plugs ?
00:02:29 <desrt> what do you think a human voice would sound like if you inverted the frequency of all of the waves between 0 and 3kHz?
00:02:31 <Pseudonym> @plugs GHC.Base.unsafeCoerce# 1 :: String
00:02:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `GHC.Base.unsafeCoerce'
00:02:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `#'
00:02:38 <Pseudonym> Ah well.
00:02:44 <Pseudonym> Shows you how often I use it,.
00:02:52 <dons> very pious.
00:02:54 <xerox> dons: my last use of sed: lynx --dump checkip.dyndns.org | sed -ne '2s/.*: \(.*\)/\1/p'
00:02:55 <xerox> ^__^
00:03:11 <dons> good good, xerox.
00:03:48 <dons> i'm fairly sure the @plugs is tied down now, but I could still be surprised.
00:04:14 <Pseudonym> Not that I have any desire to hAX0R your box.
00:04:34 <dons> no, but I like to sleep at night.
00:04:44 <monochrom> @plugs unsafePerformIO (putStrLn "Variable not in scope: `unsafePerformIO'")
00:04:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `unsafePerformIO'
00:04:52 <dons> omg!
00:04:52 <monochrom> Hehehehe it "works"
00:04:56 <Gahhh> ...CERT announces new GHCi vulnerability...
00:05:02 <xerox> Ahah!
00:05:05 <dons> monochrom wins lambdabot hack of the day.
00:05:09 <monochrom> "self-printing program" hahahah
00:05:21 <dons> Gahhh: but it's not ghci, it's ghc/hs-plugins :)
00:05:40 <dons> ghci is way to vulnerable, I think. that's why @ghci was pulled
00:05:49 <Gahhh> heh
00:05:58 <Gahhh> distinguished haxors
00:06:45 <Pseudonym> @plugs let q x = x ++ show x in "@plugs let q x = x ++ show x in "
00:06:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "@plugs let q x = x ++ show x in "
00:06:55 <Pseudonym> @plugs let q x = x ++ show x in q "@plugs let q x = x ++ show x in q "
00:06:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "@plugs let q x = x ++ show x in q \"@plugs let q x = x ++ show x in q \
00:06:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ""
00:07:10 <Pseudonym> Close.
00:07:15 <xerox> ;)
00:08:47 <desrt> Pseudonym; how easy would it be to code up some filters in haskell?
00:08:50 <desrt> (in the signal processing sense)
00:08:58 <Pseudonym> No idea.
00:09:05 <Pseudonym> I know that FFT is very easy (if a bit slow).
00:09:06 <desrt> say i want a passband of 0-3kHz and everything above that is hard cutoff
00:09:23 <desrt> i was thinking that, but doesn't FFT have really bad time-accuracy characteristics?
00:09:23 <Pseudonym> You're asking the wrong person.  As me about video.
00:09:29 <desrt> (ie: since you're sampling an entire window)
00:10:23 <desrt> hmm
00:10:44 <desrt> soo.... how's video doing these days?
00:10:47 <desrt> :)
00:10:50 <Pseudonym> :-)
00:10:57 <Pseudonym> never done much audio stuff.
00:11:15 <desrt> i have a friend in electrical who just wrote up a project proposal for his final thesis thing
00:11:29 <desrt> it's really neat.  it's a phone scrambling system
00:11:33 <desrt> and i want to do it in software
00:11:58 <Gahhh> much easier in s/w
00:11:58 <desrt> i wonder what happens if i pick a good windowing function for the fourier transform
00:12:05 <desrt> and then convolve the output
00:12:19 <Gahhh> why not just use AES-256 ?
00:12:20 <desrt> Gahhh; well, it's an analog system...
00:12:33 <desrt> i need to write my software to match his hardware
00:12:53 <desrt> the approach is something like this:
00:13:05 <desrt> 1. filter so that we only have from 300 to 3kHz
00:13:21 <desrt> 2. invert all the frequencies around 3.3kHz
00:13:37 <desrt> ie: if a frequency component at x Hz existed before, it now is at 3.3kHz-x
00:13:58 <desrt> actually, it's really just those 2 steps, basically
00:14:06 <desrt> then the remote end does the opposite
00:25:30 <Itkovian> meuning
00:29:20 <Igloo> dons: What is your /bin/sh?
00:46:19 <nlv11757_> if i want to manually make a libxxx.a file, can i just pack them with ar?
00:47:36 <ibid> that's how a files are made
00:47:57 <ibid> for compatibility, running ranlib is recommended, though it is not necessary with gnu ar
00:48:19 <ibid> (this for c language libraries)
00:48:32 <nlv11757_> nice, i'll give it a try, ty
01:00:52 <nlv11757_> yeahhhhhhhhh, profiling works
01:01:50 * nlv11757_ sees a ray of light burning its way through the window
01:11:12 <Cale> Does anyone know details about the implementation of Data.{Set, Map}, and in particular, whether it should be possible to efficiently implement, say restrict :: Set a -> Map a b -> Map a b, which would restrict the domain of the map to the given set.
01:13:40 <Cale> That seems like it would be a nice addition to the library, along with something along the lines of  finiteMap :: Set a -> (a -> b) -> Map a b, since (perhaps) the set's tree structure could be used directly in building the map.
01:16:19 <Cale> perhaps I'll post to libraries
01:35:55 <nlv11757_> hmm ghcprof not part of ghc-6.4 ?
01:42:15 <nlv11757_> anyone else using the fedora packages and missing stuff like hp2ps, ghcprof, etc.
02:24:44 <dons> Igloo: /bin/sh == pdksh
02:27:07 <Igloo> ta
02:30:08 <Itkovian> boegel.
02:30:29 <boegel> Itkovian.
02:39:10 <nlv11757_> is -px broken in ghc 6.4?
02:39:25 <nlv11757_> i get: "*** glibc detected *** double free or corruption: 0x082c9998 ***"
02:39:35 <nlv11757_> (-px the profiling arg)
02:45:34 <basti_> I'm trying to do stuff in hopengl but i get segfaults. Maybe because i use a single IORef in 2 callbacks?
02:46:19 <basti_> (one would write it when the mouse is moved, and one reads from it to draw while being idle)
02:49:14 <dons> basti_: bad! why don't you use Chans?
02:49:21 <basti_> chans?
02:49:42 <dons> Control.Concurrent.Chan
02:49:54 <dons> or just MVars.
02:49:55 <basti_> im reading up about concurrent haskell right now
02:51:32 <basti_> ah yes.
02:51:39 <basti_> i guess MVars is what i'm looking for
02:52:35 <jlouis> dons: Does GHC 6.4 use sprintf and strcpy?
02:54:22 <basti_> hmm
02:54:29 <basti_> with mvars it doesnt crash anymore.
02:54:33 <basti_> it doesnt draw, too though.
02:54:59 <basti_> to be more specific, it locks up
02:54:59 <basti_> ;)
02:56:49 <Igloo> You might need to link with -threaded
02:56:58 <basti_> hmm.
02:57:54 <basti_> doesnt draw, too, but doesnt die as bad.
03:06:58 * jlouis ponders next move on lambdabot
03:07:20 <nlv11757_> how can i force this str <- readFile "agcildump.ast"
03:07:20 <nlv11757_>           ; let ast  = (read str :: File)
03:07:39 <jlouis> readFile is lazy per default
03:08:17 <nlv11757_> makes my profiling a pain in the behind
03:09:22 <basti_> why? its a good profile when nothing is happening.
03:09:23 <basti_> :)
03:09:46 <nlv11757_> i want to know if this 'read ...' is the bottleneck
03:10:07 <nlv11757_> but i process the result of the read later on
03:10:43 <Cale> you can replace the readFile with an IO action that uses hGetLine repeatedly to read the whole file at once.
03:11:11 <nlv11757_> but will the let ast = (read str :: File) then happen?
03:11:24 <nlv11757_> probably not
03:15:37 <dons> jlouis, strcpy is used in 5 places in the rts. sprintf is also used.
03:16:55 <basti__> hmm well okay. it's nothing about concurrency.
03:17:16 <basti__> it's probably a hardware problem. Haskell just seems to be extraordinary sensitive
03:17:27 <basti__> (just had a crash because of the program runnign)
03:18:38 <basti__> seems to be thermal in nature
03:19:46 <Cale> ah
03:20:29 <Cale> hehe, open up that case and get some extra fans pointed in there :)
03:33:27 * boegel just read an article on Echelon, and is stunned
03:34:09 <mflux> great, not you've tagged the channel
03:34:12 <mflux> s/not/now/
03:34:51 <boegel> try and join #nsa, what's happening there ?
03:36:09 * boegel can't help feeling being watched
03:37:34 * boegel says: echelon, al-qaeda, bomb, bin laden, 9/11, wtc <- have fun nsa !
03:38:21 <mflux> nsa should start selling spam filtering software
03:38:31 <boegel> :D
03:38:58 <boegel> the article I've read says they don't have the manpower nor means to spy on everyone
03:39:07 <mflux> suuure..
03:39:20 <boegel> just on the people they want to: members of the UN, and so on
03:39:27 <boegel> mflux: you think they do have the means ?
03:39:29 <TFK> So the little guy is spared.
03:39:34 <TFK> "spared".
03:40:08 <boegel> TFK: depends on how you look at it... taking away everyone's privacy is not my idea of sparing the little guy
03:40:21 <TFK> Hence the quotation marks :-)
03:40:22 <mflux> boegel, dunno.. how much resources it would take to spy for example a whole university?
03:40:32 <TFK> That's probably quite illegal, too.
03:40:42 <TFK> Anyway, if all this is as big as claimed, they probably have quite sophisticated AI to filter out all the interesting stuff.
03:40:53 <boegel> mflux: I think quite much... think about the email traffic alone
03:40:56 <TFK> *filter out all the uninteresting stuff
03:41:21 <mflux> boegel, I suppose it depends on what one means by 'spying'
03:41:22 <boegel> like sentences containing C4 ? :)
03:42:09 <boegel> mflux: you mean that when I sent an email containing the words 'airplane' and 'new york', the nsa can read it ?
03:42:26 <TFK> I'm guessing they have to be picky with explosives. They're used a lot in engineering, for example.
03:43:04 <mflux> boegel, I don't know, but it should be possible for some third party (your isp, university) to inspect it
03:43:27 <TFK> It would also be illegal for them to do so, no?
03:43:29 <mflux> and of course most (all?) international connections are owned by private companies so nsa shouldn't have access to those
03:43:41 <boegel> I think no-one should be able to read my private messages ! (even though email isn't all that private anyway)
03:44:15 <TFK> I think the point of Echelon is that intercepts all communication, private or not.
03:44:46 <mflux> boegel, in that case use encryption?
03:44:52 <boegel> within 10 years, we'll think it's normal that anyone can read our messages
03:44:53 <basti__> i think the point about nsa conspiracy theories is that they are conspiracy theories
03:45:14 <boegel> mflux: when they have the means to spy on everyone, they have the CPU power to break encryption, any encryption
03:45:18 <TFK> That too :-)
03:45:27 <basti__> if you want them not to listen, use a Diffie Hellman key excange to exchange a Blowfish key
03:45:28 <TFK> boegel, not really.
03:45:42 <basti__> nobody, really NOBODY has the means to break "any" encryption
03:45:48 <basti__> especially not, ciphers with large keys.
03:45:51 <boegel> basti__: not yet :)
03:46:01 <basti__> and when they got, we got better encryption again
03:46:03 <basti__> we are not stupid.
03:46:13 <mflux> boegel, but you think in 10 or 100 years there will be a breakthrough?
03:46:15 <TFK> Say the sheep...
03:46:17 <basti__> and they are just as good as we are when it comes to decrytpion.
03:46:27 <basti__> maybe they are a little better but not that much better.
03:46:34 <boegel> no, butI think it's easy to underestimate the possible CPU power (think of the supercomputers)
03:46:51 <TFK> boegel, super computers can't break good-enough encryption.
03:46:53 <basti__> even CPU power wont help you decryptiong.
03:46:54 <TFK> Not in practical time, anyway.
03:47:01 <basti__> this is FUD
03:47:02 <boegel> mflux: a breakthrough in what ?
03:47:16 <mflux> boegel, in understanding how to break encryption
03:47:44 <boegel> mflux: that depends on the kind of encryption
03:48:03 <boegel> I think no-one can imagine where we will be within 10 years
03:48:12 <boegel> think about where we were 10 years ago
03:48:16 <TFK> Factorization in practical time will break a lot of encryption devices, afaik.
03:48:27 <jlouis> TFK: it will break RSA
03:48:29 <TFK> We had Windows 95.
03:48:41 <mflux> I don't think in the last 10 years much interesting has happened in the field of cryptography..
03:48:47 <TFK> jlouis, I think that's one of the most popular ones, right?
03:48:59 <mflux> well, maybe something in the theory regarding prime numbers
03:49:13 <TFK> Primes are in P :D
03:49:15 <mflux> but nothing too crucial? that is, to get better encryption, use longer keys ;)
03:49:17 <boegel> mflux: I don't mean in cryptography, I mean in IT in general
03:49:50 <jlouis> TFK: indeed is. Together with El-gamal they are the most often used for asymetric chiphers
03:50:30 <TFK> boegel, Java choked IT. ;-)
03:50:35 <jlouis> You have quite a host of possibilities for symmetric chipers: Blowfish, Serpent, MARS, AES (rijndael), DES, 3DES, IDEA, GOST etc
03:52:00 <jlouis> TFK: that we can check a number for being prime in P doesn't help that much when we want a factorisation ;)
03:52:11 <boegel> TFK: what do you mean ? why did it choke IT ?
03:52:31 <TFK> It's a flame-war thing. n/m...
03:52:45 <TFK> jlouis, yeah, but it's nice by itself ;-)
03:52:45 <boegel> TFK: inform me pls :)
03:53:16 <TFK> Java? The sucky language? Language flame wars. Paul Graham?
03:54:12 <TFK> Pretend that period is a question mark.
03:55:08 <boegel> TFK: why is Java sucky ?
03:55:38 <TFK> I'm not going to answer that. It was a humorous remark.
03:55:59 <boegel> I just don't get why everybody always says Java sucks
03:57:58 <Itkovian> boegel: Java has merits, but drawbacks as well, and it sure as hell isn't to be used for everything. Notheless, I like it.
03:58:15 * boegel joins Itkovian
03:58:34 <autrijus> I think Java 5 is finally more like a real language.
03:58:43 <TFK> Java peculiarities: (1) dichotomy of "primitives"/Objects. (2) The OOP straight-jacket, everything is a class, besides the things that aren't (see 1). (3) Verbosity, a la System.out.println("") (4) No operator overloading, but String is an exception?
03:59:20 <Itkovian> well yeah
03:59:35 <Itkovian> My work is usually inside a VM, so I really don;t care ;-)
03:59:50 <TFK> What do you mean "inside a VM"?
04:00:03 <Itkovian> Well, I hack in the Jikes RVM
04:00:17 <Itkovian> for my research
04:04:12 <TFK> Well, many people have to write Java production code for years ;-)
04:08:11 <boegel> how does one call the lower part of a fraction ? divisor ?
04:09:03 <Itkovian> the demoninator
04:09:07 <Itkovian> denominator
04:09:11 <Itkovian> afaik
04:09:27 <TFK> The demoniser?
04:09:31 <Itkovian> lol
04:09:50 * TFK was inspired by "demoninator" :-)
04:09:55 <Itkovian> i know
04:27:04 * TheHunter explodes
04:27:15 <TheHunter> "g x is sugar for f >>= (\x -> g x)"
04:27:20 <TheHunter> no, no, no and no
04:27:22 * boegel picks up the pieces and puts together a whole new TheHunter 
04:28:50 <TheHunter> how can one possibly argue against the do notation?
04:29:24 <Igloo> Is that a real quote? Where did f come from?
04:30:18 <Igloo> Or are you missing a "do x <- f"? In which case, why the exclamation?
04:30:22 <TheHunter> the quote is "do x <- f; g x is sugar for f >>= (\x -> g x)"
04:30:32 <TheHunter> http://www.haskell.org/hawiki/SyntacticSugar
04:30:57 <TheHunter> because that's not the translation for do notation. In this case, yes, but in general no.
04:31:19 <TheHunter> s/yes/it's equivalent/
04:34:11 <Igloo> I guess it /could/ confuse someone
04:37:15 <nlv11757_> does "a `seq` b" always force *full* evaluation of a even if b is totally unrelated?
04:37:43 <TheHunter> it forces evaluation to weak head normal form.
04:37:55 <TheHunter> so, [undefined] `seq` 1 ==> 1
04:39:28 <nlv11757_> (read str :: File) `seq` 1
04:39:49 <nlv11757_> would that force the complete parsing of str
04:39:54 <Svrog> hi everyone
04:40:19 <Itkovian> hi
04:40:49 <TheHunter> nlv11757_, possibly yes, but in general you can't rely on that.
04:40:56 <Svrog> ive got a few questions (as usual :) I was hoping someone might be able to answer
04:41:08 <Itkovian> shoot!
04:41:11 <Svrog> why does ghci treat fully qualified imports as normal imports?
04:41:38 <nlv11757_> hunter can i show you a piece of code so you can comment on it, if im doing it correct for profiling?
04:41:45 <nlv11757_> couple of lines
04:41:50 <TheHunter> sure.
04:42:02 <nlv11757_> it should go on the wiki or ...?
04:42:07 <TheHunter> @paste
04:42:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
04:42:54 <Si\> is there a reason why there's no instance of Exception for Error, or instance of Exception IO for MonadError?
04:42:58 <Svrog> like if I do Import Data.Map as Map it doesn't seem to import it as such - in fact it complains if I call filter for example, saying that it can't figure out if I'm trying to use Data.Map.filter or GHC.List.filter
04:43:28 <autrijus> import qualified Data.Map as Map
04:43:33 <Svrog> read above
04:43:38 <Svrog> thats exactly what I did
04:43:45 <Svrog> and ghci ignores it
04:44:01 <TFK> What does the => notation mean in context of typing? for example "data RealFloat a => Complex a = !a :+ !a"?
04:44:09 <Svrog> oh crap.. i think i forgot 'qualified' hehe
04:44:17 <autrijus> ...
04:44:17 <Svrog> thanks autrijus
04:44:19 <autrijus> np :)
04:44:43 <nlv11757_> ok its the upper one hunter
04:44:57 <JaffaCake> TFK: it's a constraint on the constructor function: it doesn't actually do much else
04:45:51 <nlv11757_> hunter: my aim is to discover how many time is consumed by the 'read' function
04:45:52 <TFK> So there is either one => or none, and everything before => is a constraint on the types of the type constructor following => ?
04:45:57 <nlv11757_> to see if it is my main slowdown
04:46:10 <Svrog> another question I've had is is there any way to check for equality between functions? Or rather to check for identity.
04:46:32 <JaffaCake> TFK: yes, the constraint becomes part of the type of the constructor
04:46:38 <TheHunter> nlv11757_, the ast == ast will force complete evaluation.
04:47:08 <nlv11757_> ok but will the actual comparison take up a lot of time compared to the parse?
04:47:50 <JaffaCake> @type (Data.Complex.:+)
04:47:50 <TFK> JaffaCake, ok, thanks. It'll sink in some day :-)
04:47:51 <TheHunter> probably not, but chances are, it'll show up in the profile output.
04:48:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (Data.Complex.:+) :: forall a.
04:48:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                      (RealFloat a) =>
04:48:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                      a -> a -> Data.Complex.Complex a
04:49:06 <nlv11757_> lol, my readit takes up 84.3% of the application time
04:49:24 <nlv11757_> i guess the read *is* the bottleneck
04:49:40 <JaffaCake> nlv11757_: read is *usually* a bottleneck :)
04:49:54 <nlv11757_> heheh, but i wanted to know for sure it wasnt my attribute grammar
04:50:04 <TFK> Svrog, Gentle suggests there isn't.
04:50:19 <nlv11757_> and defining a parser for myself would take ages in this special case
04:50:28 <Svrog> TFK: yeah thats what I thought but I thought I'd ask anyway :)
04:50:47 <Svrog> I guess the only alternative is to assign unique ids to functions
04:51:02 <Svrog> or use a data structure instead
04:51:04 <TFK> Svrog, yeah... since there are no pointers or similar notions, afaik.
04:51:09 <Svrog> yeah
04:51:14 <TFK> Aren't names unique enough?
04:51:35 <Svrog> what do you mean?
04:51:41 <nlv11757_> well thanks in any case hunter
04:51:48 <TFK> Well, why do you want to check functions for 'equality'?
04:52:34 <Si\> hmmm, why is there a fundep "m -> e" on MonadError?
04:53:01 <TheHunter> nlv11757_, DrIFT can derive Read instances. There's a sight chance their translation is different from the report and more efficient.
04:53:32 <TFK> What does :+ mean?
04:53:52 <nlv11757_> ow, cool
04:53:58 <nlv11757_> where can i look into that hunter?
04:54:13 <TheHunter> http://repetae.net/john/computer/haskell/DrIFT/
04:54:18 <TheHunter> i've never used it, though.
04:54:50 <Svrog> well im currently writing a function dispatch loop.. I first started with a really large data structure but then I started thinking that pattern matching that at run time is going to be slower then simply using a smaller data structure and functions composed at run time - either way i need to be able to test for equality between the functions
04:55:07 <Svrog> large data structure as in lots of constructors
04:55:29 <Svrog> hey shammah
04:55:32 <Svrog> oops
04:55:34 <Svrog> shapr i meant
04:55:38 <shapr> hiya Svrog
04:55:50 <TFK> Erm, premature optimizations?...
04:56:06 <Svrog> yeah yeah i know i know - i couldnt help it hehe
04:56:29 <TFK> :-/
04:56:31 <shapr> Man, I love this IOCCC Hamming number implementation. It's disturbingly gorgeous.
04:57:39 <Svrog> although getting rid of a data structure with more then 30 constructors would be a pain later on anyway and it just seems like a pretty bad way to start
04:59:37 <shapr> Wow, LtU r0xx. I posted a comment on a pi-calculus + region allocation research paper and the author responded!
05:00:49 <Svrog> cool
05:02:03 <TFK> How do you create functions in runtime, though?
05:02:42 <shapr> with a STICK!
05:03:32 <Itkovian> a large one
05:03:51 <shapr> hi smoot
05:04:00 <shapr> are you related to smott?
05:04:09 <shapr> hoi Itkovian, wazzap?
05:04:42 <Svrog> TFK: I meant composing two or more functions together - basically create a closure
05:05:17 <smoot> was i using smott before? honestly i keep changing my nick because i can never remember my passwords
05:05:40 <TFK> What does !$ do?
05:06:00 <shapr> smoot: you could use a password that is algorithmically related to the nickname.
05:06:19 <_JusSx_> so you can forget your algorith
05:06:20 <_JusSx_> so you can forget your algorithm
05:06:57 <shapr> _JusSx_: hey, have you hacked on lambdabot any?
05:07:25 <_JusSx_> not yet
05:08:07 <Svrog> TFK: http://users.aber.ac.uk/afc/stricthaskell.html
05:08:21 <musasabi> shapr: wouldn't a list of users which are required to have +e be one solution?
05:08:28 <_JusSx_> shapr: sorry but i'm really busy at moment
05:08:37 <musasabi> or then hack a script for common irc clients to automatically authenticate.
05:08:40 <Svrog> scroll down a bit - it talks about seq, $! and how to use them
05:09:03 <musasabi> writing passwords in irc is just asking for them to land in the wrong window.
05:09:08 <shapr> Yeah, I agree.
05:09:24 <shapr> My irc client has a script to do auto-auth.
05:10:01 <TFK> Svrog, sankyu
05:10:07 <Svrog> np
05:12:33 <Svrog> anyway im off - cyas
05:22:26 <nlv11757_> can it be, that some functions applications are so fast, that they contribute 0.0 time and 0.0 space allocation to the profiling....
05:22:44 <nlv11757_> or is this a sign that im not profiling correctly
05:22:47 <musasabi> nlv11757_: yes.
05:23:04 <nlv11757_> yes nr1 or yes nr2 :)
05:23:06 <musasabi> nlv11757_: it might be a sign that you run your program for too short a time.
05:23:38 <nlv11757_> cause i parse this structure, then i apply a couple of function compositions on the structure which only synthesize some strings....but still
05:23:52 <nlv11757_> 0.0 feels a bit too small
05:23:57 <musasabi> nlv11757_: functions might really take 0.0 of both, but in some cases this can be seen as a sign that there are too few profiler snapshots so they are not distributed in a good fashion.
05:26:49 <nlv11757_> well, only synthesizing information from a large structure should probably be lightning fast. Its just a bunch of function compositions that return values stored in this large structure.
05:39:13 <Si\> is it possible to convert Control.Exception.catch to work on any MonadIO monad with just liftIO, or do I need unliftIO?
05:44:08 <Si\> hmmm actually, I bet you can't do that safely
06:07:07 <pesco> Greetings.
06:07:26 <shapr> y0!
06:07:30 <pesco> Hey shapr.
06:07:48 <xerox> conichiwa
06:10:21 <pesco> I'm looking for some book tips. For instance, has anybody here read "First-order logic and automated theorem proving" by Fitting?
06:11:26 <pesco> I don't fully trust my University profs wrt. their book recommendations. So I look to #haskell for help! :)
06:11:42 <Itkovian> :-)
06:11:49 <shapr> heh
06:12:59 <pesco> This semester I need to take courses on "Logic and Semantics", "Automata and Complexity",  and "Neuronal Networks".
06:13:57 <pesco> What about J.C. Raynolds, "Theories of Programming Languages"? Anybody?
06:14:45 <shapr> Hm, I've heard of that one.
06:14:53 <pesco> OK.
06:14:57 <shapr> Not that I remember anything.
06:15:00 <shapr> hiya rifleman
06:15:17 <shapr> rifleman: What can we do for you? Looking for Haskell info?
06:15:26 <pesco> Anyhow, the logic/sem. books are not really so important, the literature list is long and I can look through them at the library.
06:15:42 <shapr> pesco: hey, have you heard about perl6?
06:15:59 <pesco> But does anybody know a good book about neural networks?
06:16:21 <rifleman> just lurking for now.
06:16:34 <pesco> shapr: For which sense of "heard about"? I know it exists, for a certain sense of existence.
06:16:38 <shapr> I started reading Kohonen's original work on neural networks a long time ago. Mikhail Zak's work on metaneural networks is really cool, but doesn't seem very popular.
06:17:04 <TNKS> Hello all, I was wondering, how does an Array accomplish constant time lookup in Haskell.  I'm so used to thinking in terms of Lists and data structures that it's difficult for me to imagine how Arrays are implemented in Haskell.
06:17:18 <TNKS> Is there something unique to the Array implementation?
06:17:29 <TNKS> Is it coded at a low-level?
06:18:07 <Igloo> Lookups are exactly as in C
06:18:09 <jlouis> TNKS: when allocating an array, you just allocate n words of memory next to each other.
06:18:14 <shapr> pesco: btw, if you're looking for a laugh, you should see the extremeperl discussion where someone told me that Perl can do as much as Haskell because both of them can implement a Turing machine.
06:18:17 <Igloo> Unfortunately, writes may require copying the whole array
06:18:26 <jlouis> And in haskell it is a pointer to this array
06:18:31 <shapr> er, 'is effectively the same as'
06:18:47 <shapr> I am incensed!
06:18:52 * shapr swings around on a chain
06:18:57 <Itkovian> shapr: great! just what we needed to know!
06:18:59 <jlouis> shapr: where is that extremeperl discussion ;)
06:19:16 <shapr> It is here - http://groups.yahoo.com/group/extremeperl/messages
06:19:28 <pesco> shapr: "Perl is effectively the same as Haskell"? That's comedy.
06:19:39 <shapr> Happily, I think the ashes has almost cooled to room temperature.
06:19:42 <shapr> er "Have"
06:19:54 <pesco> shapr: But what were you going to say about Perl 6?
06:20:00 <shapr> Oh, perl 6 is nifty!
06:20:16 <TFK> jlouis, "next to each other"? Doesn't that fail?
06:20:22 <shapr> The Pugs implementation is in Haskell. I've written a few builtins, and the internals are quite nice.
06:20:34 <TFK> Or rather, can't it fail?
06:20:49 <pesco> Of course I know about Pugs, but I've not tried it, or had a closer look.
06:21:21 <Philippa> TFK: only in the same way any memory allocation can
06:21:43 <Philippa> most haskell values take up more than one word anyway
06:21:45 <shapr> It's cool to see stuff like Template Haskell, GADTs, and an attractive stack of monad transformers in a codebase that has 60 committers and a bunch of spectators.
06:21:53 <TFK> Philippa, afaik, when there are no free consecutive n words, malloc() breaks it into chunks. Thus RAM -> Random Access Memory.
06:22:04 <Philippa> no
06:22:10 <Philippa> when they're not consecutive, malloc fails
06:22:21 <shapr> I like seeing all that 'theory in motion'.
06:22:24 <Philippa> because what you've /asked for/ is n consecutive words
06:22:29 * shapr hugs autrijus
06:22:46 <Philippa> it's "Random Access" because you can demand any given word at any given time (at least on the hardware level - the OS may argue)
06:23:23 <TFK> Hmm, OK.
06:24:19 <TFK> Then the question stands, are Arrays implemented in Haskell or more low-level?
06:24:37 <jlouis> also, while being O(1), the factor is not the same for all memory. Cache is playing around with you
06:24:43 <Philippa> lower level
06:24:53 <Philippa> you can't get an O(1) implementation in Haskell
06:24:53 <jlouis> Definitely lower level
06:25:16 <jlouis> Philippa: For reading? Why not? For writing, I know it bombs.
06:25:57 <TFK> How is that possible? Surely with enough magic you can, even if it will have a large constant?
06:29:44 <Philippa> jlouis: How're you going to represent the array internally? No possible structure in the absence of arrays or vectors has the O(1) lookup - you could try tupling but it won't type
06:30:20 <shapr> pesco: and there's #perl6, where it all happens.
06:30:28 <shapr> pesco: but that has nothing to do with your classes :-)
06:30:40 <Philippa> nor could it without dependant types, because arrays get allocated at run-time
06:31:23 <Philippa> (minor lie, but the alternative involves being able to encode tuples in the type system and find a way to parameterise on length - it's just as big a deal)
06:37:40 <TNKS> if a function has a both a let block and a where block, are the let bindings visible to the where block?
06:37:57 <shapr> it would make sense.
06:38:00 <shapr> I wonder if that works both ways.
06:38:03 * shapr tries
06:39:36 <shapr> TNKS: this works fine - foo x = let y = x + 1 in z + y where z = x + 2
06:40:01 <Philippa> shapr: no, it wouldn't
06:40:01 <wilx> Hm....
06:40:19 <Philippa> the stuff in the where is visible throughout the function, the stuff in the let is only visible within the let (and the where's outside it)
06:40:27 <wilx> Isn't the where part a part of the "in" expression?
06:40:35 <Philippa> lets are just plain ol' expressions, they nest and stuff
06:40:39 <wilx> Oh.
06:40:42 <wilx> Never mind then.
06:40:50 <shapr> This is beginning to sound like mdo
06:41:44 <kzm> I see there's some discussion about Data.Map/AVL/dessy on the mailing lists.
06:41:57 <kzm> Anybody try to actually compare them?
06:42:12 <kzm> (Or other experiences I need to know about?)
06:43:49 <wilx> dessy?
06:45:26 <TNKS> shapr, but I don't think this does:   foo x = let y = x + 1 in z + y where z = y + 2
06:46:02 <TNKS> shapr, but honestly, I don't see why it's a violation of anything, other than maybe just an idiosyncrasy of Haskell.
06:46:26 <TNKS> Is there a reason we want to separate the let bindings from the where bindings?
06:47:28 <Philippa> TNKS: yes
06:47:41 <Philippa> you can nest let, where goes with the function
06:47:49 <Philippa> if you want something visible throughout the function, it goes in the where
06:48:06 <Philippa> if you want something visible only in a subexpression, you use a let statement to delimit that subexpression
06:48:38 <Philippa> and special-case rules (which is what you're effectively proposing here) have a habit of building up into one big messy pile
06:57:35 <CosmicRay> type ApplyFunc a b = [a] -> ApplyFunc a b
06:57:42 <CosmicRay> Is there any way I can make that work?
06:57:49 <CosmicRay> hugs is giving me a recursive typing error
06:57:57 <CosmicRay> I can use newtype, but the type constructor is awkward here.
07:00:31 <CosmicRay> ahh sweet.  this is working.  See if you think this is useful:
07:00:36 <CosmicRay> newtype ApplyFunc a b = ApplyFunc ([a] -> (ApplyFunc a b, [a], [b]))
07:00:40 <CosmicRay> wholeMap :: ApplyFunc a b -> [a] -> [b]
07:00:45 <CosmicRay> fixedWidth :: [Int] -> ApplyFunc a [a]
07:00:50 <CosmicRay> Main> wholeMap (fixedWidth [1, 2, 3, 4]) "This is a test"
07:00:50 <CosmicRay> ["T","hi","s i","s a ","test"]
07:01:47 <Oeje1> CosmicRay: Looks neat.
07:01:47 <Itkovian> nice
07:04:21 <CosmicRay> it's basically like concatMap, but it is allowed to consume a variable number of items from the input list (or even transform the input list) each time through, and specify a different function to handle the "next" part of the list.
07:06:52 <Itkovian> CosmicRay: can you post the implementation somewhere?
07:07:35 * pesco waves and makes a rushed escape.
07:08:09 <bourbaki> moin
07:08:17 <shapr> y0
07:08:22 <bourbaki> :)
07:08:48 <CosmicRay> Itkovian: yes
07:08:58 <CosmicRay> Itkovian: give me about 10 minutes to properly document it
07:11:04 <CosmicRay> Itkovian: hell, I can paste it here.
07:11:17 <CosmicRay> newtype ApplyFunc a b = ApplyFunc ([a] -> (ApplyFunc a b, [a], [b]))
07:11:23 <CosmicRay> wholeMap :: ApplyFunc a b -> [a] -> [b]
07:11:23 <CosmicRay> wholeMap _ [] = []
07:11:23 <CosmicRay> wholeMap (ApplyFunc func) inplist =
07:11:23 <CosmicRay>     let (nextfunc, nextlist, output) = func inplist
07:11:23 <CosmicRay>         in
07:11:23 <CosmicRay>         output ++ wholeMap nextfunc nextlist
07:11:38 <CosmicRay> fixedWidth :: [Int] -> ApplyFunc a [a]
07:11:39 <CosmicRay> fixedWidth len =
07:11:39 <CosmicRay>     ApplyFunc (fixedWidthFunc len)
07:11:39 <CosmicRay>     where fixedWidthFunc _ [] = ((fixedWidth []), [], [])
07:11:44 <CosmicRay>           fixedWidthFunc [] x = ((fixedWidth []), [], [x])
07:11:48 <CosmicRay>           fixedWidthFunc (len:lenxs) input =
07:11:48 <CosmicRay>               (fixedWidth lenxs, next, [this])
07:11:48 <CosmicRay>               where (this, next) = splitAt len input
07:11:56 <CosmicRay> that's it.
07:13:16 * boegel hits CosmicRays with a stick: not more than 3 lines of code ! :p
07:13:23 <CosmicRay> heh
07:13:31 <CosmicRay> I did omit the comments :-)
07:13:38 <bourbaki> its not more then 3 lines of code
07:13:58 <bourbaki> just like 10 times 3 lines ;)
07:14:11 <boegel> that will be my excuse next time then :)
07:14:15 <CosmicRay> heh
07:17:50 <Lemmih> Good morning, #haskell.
07:18:08 * Igloo wonders where the 3 lines of code rule came from
07:18:17 * CosmicRay hadn't heard of it
07:18:20 <CosmicRay> morning lemmih
07:18:39 <CosmicRay> hell, I spouted off less than lambdabot does with @listcommands :-)
07:18:59 <Igloo> :-)
07:19:13 <Igloo> I think much more than that wouldn't be reasonable, but more than 3 lines is commonplace here, I think
07:19:15 <shapr> Igloo: actually, the 3 lines of code rule came from homework problems being pasted on the channel, sometimes the same problem several times a day.
07:19:47 <CosmicRay> heh
07:19:58 <Igloo> The rule should match the problem better, then :-þ
07:20:05 <shapr> any suggestions?
07:20:43 <Igloo> "Don't paste homework problems"?
07:20:48 <Igloo> Not that I think that should be banned
07:21:09 <Igloo> Homework problems are fine as long as the person in question actually wants to learn, IMO
07:21:16 <CosmicRay> Igloo: agreed
07:21:20 <shapr> sadly....
07:21:36 <bourbaki> depends if you just want the solution or if you wanted to be asked clever questions
07:21:57 <shapr> Right, the second flavor is great.
07:22:06 <Igloo> I think you're saying essentially the same as me, bourbaki
07:22:09 <Si\> anyone got any suggestions for how I can use catch to build a function catchIO, which which allows you to perform a catch in a transformer monad encapsulating an IO?
07:22:11 <bourbaki> yes
07:22:24 <Oejet> Lets go on a banning frenzy.
07:22:24 <Igloo> So I propose "Don't be an ass" as a replacement rule  :-)
07:22:32 <bourbaki> :)
07:22:53 <shapr> Or as I put it "Be nice"
07:22:56 <Igloo> Anyway, I need to go to the library before the politics explode - laters  :-)
07:22:59 <shapr> with the implied "or else"
07:23:14 <Oejet> Let's go on a banning frenzy.
07:23:20 <TNKS> just curious, is there a predefined function for (\a b -> (take a (repeat b)))
07:23:29 <TNKS> something like repeatN?
07:24:17 <TNKS> ah, I just found it.  replicate.
07:26:23 <Oejet> @plugs replicate (\x -> x*x) 10 9
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `[a]' against `t -> t1'
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: [a]
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: t -> t1
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     Probable cause: `replicate' is applied to too many arguments in the
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- call
07:26:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	(replicate (\ x -> x * x) 10 9)
07:26:30 * Lemmih wonders if he should write some Haskell, go to the library or just sleep in.
07:26:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `show', namely
07:26:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1 @more lines]
07:26:43 <nlv11757_> fastmem: FATAL: Assertion failed (dtl_if.cc:3118): "ddr_block_number(): addr must be LOCAL or NOMAP" == 0
07:26:47 <nlv11757_> just the way i like it
07:26:52 <Oejet> Lemmih: Library.
07:29:52 <nlv11757_> Lemmih: why not eat some pizza
07:31:14 <Lemmih> Got no pizza and no money (:
07:31:44 <Itkovian> the real problem being the latter
07:33:53 <nlv11757_> no no no, pizza is far more important
07:35:00 * Lemmih goes to the library which won with one vote.
07:35:23 <nlv11757_> why not go to the gym
07:35:48 <chip> @get-definition $
07:35:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- $ not defined
07:36:12 <xerox> chip: I think it gives definition of lambda calculus operators.
07:36:23 <nlv11757_> @get-definition ($)
07:36:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ($) not defined
07:36:37 <nlv11757_> @get-definition fix
07:36:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fix = \f.f (fix f)
07:44:37 <andrei> Anyone have a working amd64 ghc with OpenGL/GLUT?
07:44:57 <andrei> I haven't the time to fix their segfaults
07:45:18 <nlv11757_> not me
07:45:31 <nlv11757_> i would settle for a working amd64 though
07:45:43 <andrei> The fedora works nicely
07:45:58 <andrei> Well.. kinda
07:52:50 <juhp> andrei: have you tried the ghc.x86_64 package in Fedora Haskell?
07:54:10 <andrei> juhp, Yup, it doesn't compile opengl code
07:54:34 <andrei> juhp, missing accelerator support, or something of the sort, it was added to CVS now
07:54:42 <juhp> oh
07:54:52 <juhp> ok
07:56:38 <andrei> Unfortunately I can't even fix their segfault if I had time to do us (finals).. because I run a hardened gentoo
07:56:51 <andrei> I can't debug things, so I have to use a different machine which isn't here
07:57:07 <andrei> And my non-hardened chroot isn't complete yet
07:57:18 <juhp> hmm
07:57:50 <TheHunter> dons, still awake?
07:58:38 <Itkovian> ttyl
08:01:28 <xerox> hiya basti_
08:01:33 <basti_> hey
08:01:39 * basti_ got a cool graphics card now
08:06:31 <basti_> -.-
08:06:38 <shapr> |.|
08:06:42 * basti_ STILL has problems related to the Graphics card.
08:06:45 <shapr> me too!
08:06:50 <shapr> I hope TechSource gets a move on!
08:06:53 <basti_> first i thought it was thermal. But it is not.
08:11:12 <basti_> i learned after installing a 25 € heatpipe
08:14:27 <autrijus> hrm. why can't GADTs derive Show again?
08:18:50 <TheHunter> because of existential quantification?
08:21:01 <TheHunter> oh, it's just not implemented, i guess.
08:21:24 <autrijus> sigh. :-/
08:21:36 <autrijus> that means I need to use some sort of automatic script to generate the instance.
08:21:48 <autrijus> there's nothing unShowable about existentials
08:22:46 <kosmikus> in general, existentials are of course unshowable
08:22:58 <kosmikus> but in the context of GADTs, not all of them are
08:24:32 <kosmikus> also, it's not trivial to derive class instances for GADTs in general, but "Show" is one that would be relatively simple
08:33:51 <basti_> hmm. is there "reflection" features in haskell? :)
08:34:41 <Oejet> @type replicate
08:34:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- replicate :: forall a. Int -> a -> [a]
08:35:56 <ozone> basti_: hmm, basically, no
08:36:08 * autrijus invokes the TH hammer
08:36:21 <autrijus> I'd say yes :)
08:36:25 <rlaager> @type replicate
08:36:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- replicate :: forall a. Int -> a -> [a]
08:36:35 <ozone> basti_: very little (no?) type information is kept in the compiled program, unfortunately, so it's impossible to have reflection
08:36:45 <basti_> hmm i see.
08:36:57 <musasabi> There are two mechanisms for reflection.
08:37:05 * basti_ listens
08:37:12 <Paco-Paco> @type replicate
08:37:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- replicate :: forall a. Int -> a -> [a]
08:37:22 <musasabi> 1) compile time template haskell, 2) Data & Typeable (scrap your boilerplate)
08:38:40 <elb> @type replicate
08:38:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- replicate :: forall a. Int -> a -> [a]
08:39:33 <xerox> Why are you all doing @type replicate ?
08:39:40 <Oejet> Heh, sorry for the @type replicate flooding. :-/  I'm trying to fix the Gaim bot notice issue with the guys in #gaim.
08:39:56 <xerox> Np :-)
08:40:06 <basti_> musasabi: thanks for the reference to boilerplate...
08:40:19 <basti_> musasabi: do you have experience in any of those two techniques?
08:40:42 <ozone> man, who wrote the hawiki page on SyntacticSugar/Cons
08:40:48 <ozone> some of it is serious crackheadedness
08:40:49 <Si\> Oejet: on behalf of Gaim users, thanks
08:41:13 <Oejet> ozone: lol
08:41:26 <musasabi> basti_: Yes, I have used both and they have their own good and bad sides.
08:41:36 <basti_> i see.
08:41:39 <ozone> Oejet: was it you?  are you the man i have to pick a bone with? ;)
08:42:11 <TheHunter> ozone, that's Henning Thielemann. And I'm the one arguing with him all the time ;)
08:42:15 <ozone> i'm tempted to edit the wiki page and write "P.S.  I wrote this when I was on serious crack" to it
08:42:27 * Oejet fetches his crack from under some pillow and start attacking ozone.
08:42:41 <musasabi> template haskell is not very readable (and currently adds superfluous object code but this should be fixed in the future) - on the other half it is a better solution for many things.
08:42:41 <ozone> so it's you then?
08:42:44 <basti_> henning? -g-
08:42:56 <basti_> hennig knows my boss' boss
08:43:04 <basti_> and my boss via mail
08:43:20 <basti_> why are you arguing with him? -g-
08:43:44 <TheHunter> because he wants to take away all the syntactic sugar that makes my life easier.
08:43:49 <ozone> TheHunter: about syntactic sugar?
08:43:55 <basti_> hehe
08:44:02 <Philippa> musasabi: I find the readability varies somewhat - but yeah, it's not good for sugaring expressions
08:44:06 <basti_> henning is one of a kind... or how do you say?
08:44:19 <TheHunter> ozone, http://www.haskell.org/hawiki/ThingsToAvoid_2fDiscussion
08:44:23 <ozone> basti_: "on crack"?
08:44:48 <basti_> lol
08:44:55 <basti_> i read his pyramide homepage
08:45:00 <TheHunter> he even disputes the do-notation.
08:45:11 <musasabi> Philippa: it just seems very complicated as compared to e.g. lisp macros - but then again that can be a feature too.
08:45:12 <basti_> but he seems to be quite ok with haskore
08:45:29 <basti_> if you don't come to close, he's quite open i think... ;)
08:46:04 <basti_> this boilerplate typecast thing is crack.
08:46:24 <ozone> TheHunter: i presume from reading that page that you're Thomas?
08:46:36 <TheHunter> ozone, yep.
08:46:44 <basti_> did anyone ever think about the implications of plugins in the fundep world?
08:47:04 <ozone> basti_: not sure what you mean.  plugins in the fundep world?
08:47:10 <ozone> TheHunter: mmmmmm :)
08:47:15 <basti_> well theres haskell plug ins
08:47:39 <basti_> and then theres fundeps, where the type of a function return in a class might depend on its parameters.
08:47:54 <ozone> ooo, i like the syntacticsugar/pros page
08:48:02 <ozone> quite obviously written by henning :)
08:48:11 <basti_> i like the c critic page :)
08:48:26 <basti_> *(a++)=a++ etc. ;)
08:48:36 <ozone> geez, and if henning thinks haskell has a lot of syntactic sugar ...
08:48:43 <basti_> lol
08:48:54 <basti_> probably he wants to live in an all-assembler world
08:48:58 <ozone> might as well drop point-wise function definitions
08:49:02 <ozone> and just use lambda expressions everywhere
08:49:11 <basti_> actually, unlambda-expressions!
08:49:51 <basti_> that would be cool
08:49:53 <basti_> and so CLEAN
08:49:53 <basti_> :)
08:50:12 <Oejet> Gaim users: It seems to be a bug i Gaim's handling of channel notices, which it cannot differentiate from private notices.  A fix is not trivial, so we have to wait some time.
08:50:23 <ozone> hmm, i best go to sleep and get out of this rant mode
08:50:30 <ozone> ranting is bad for the soul and karma
08:51:29 <ozone> basti_: still don't understand what you mean about plugins and fundeps
08:51:34 <basti_> hmm
08:51:38 <ozone> you have an idea how about to combine them?
08:51:48 <vegai> @karma ozone
08:51:48 <Oejet> ozone: If you are ranting to a tune under a full moon, you might feel better soon.
08:51:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ozone has a karma of 0
08:52:01 <basti_> lets see we have a class MyClass a b | a -> b
08:52:13 <basti_> where testfun::a->b
08:52:31 <basti_> now we have a certain number of instances of this class
08:53:06 <basti_> now when we plug in an instance (these plugins are instances arent they?), will this work?
08:53:09 <basti_> always?
08:53:26 <ozone> plugins aren't instances, no
08:53:43 <basti_> oh.
08:53:48 <basti_> values?
08:54:18 <xerox> ozone: Modules are instances, aren't they?
08:54:48 <ozone> basti_: plugins can add new values (though the host program will have to know how to call those new values, somehow), or modify existing values
08:55:03 <ozone> xerox: umm, unless i'm missing something, no
08:55:34 <ozone> basti_: though ... it maay be possible to add a new instance to a class
08:55:34 <basti_> hmmmmmmm.
08:55:51 <basti_> worth a scribble or two?
08:55:58 <Si\> Is there a way of getting Cabal to build with an increased context stack?
08:56:19 <Si\> or should I say supply "-fcontext-stack100" to ghc
08:56:21 <ozone> lemme see.  if you load a plugin with that defines a new data type that's an instance of a class, and pass a value of that type to an overloaded function in the host, that should work, i think
08:56:26 <TheHunter> basti_, are you talking about lambdabot?
08:56:37 <basti_> no.
08:56:44 <xerox> Ah. I was.
08:57:02 <ozone> basti_: interesting idea, i'll email dons about it
08:57:09 <basti_> i was thinking hs-plugins, but these actually might not be THE response to the question "plugins?"
08:57:15 <TheHunter> ozone, no need to, i'm already working on that...
08:57:16 * basti_ smiles
08:57:23 <ozone> TheHunter: oh?
08:57:28 * basti_ feels on eye level with people
08:57:29 <JaffaCake> Si: you can add -fcontext-stack100 to ghc-options in your .cabal file
08:57:36 <ozone> TheHunter: ah, hang on
08:57:40 <ozone> i don't think it'll work
08:57:56 <ozone> i remember trying this in the first versions of runtime loader, and it diedeth
08:58:14 <TheHunter> class Module m s | m -> s where [...]; process         :: m -> IRCMessage -> String -> String -> String -> ReaderT (IORef s) IRC ()
08:58:27 <ozone> i think it's got something to do with the typeclass directories ... i can't quite remember what
08:59:09 <TheHunter> provided that's what basti_ was talking about.
08:59:23 <basti_> hmm
08:59:36 <ozone> basti_: i think if you use that fundep'ed typeclass inside an existential type, it should work
08:59:48 <ozone> easy to find out, i guess :)
09:01:02 <basti_> if i would now understand what an existential type is
09:09:59 <CosmicRay> cpp question... how would I differentiate an old hugs library from the current one, and how would I differentiate ghc 6.2 from 6.4?
09:13:10 <Lemmih> #if __GLASGOW_HASKELL__ >= 6.4 ... ?
09:13:29 <Lemmih> s/6.4/604/
09:13:34 <CosmicRay> nice
09:13:42 <CosmicRay> now, where could I have found that for myself, and what about hugs? :-)
09:16:05 <Lemmih> Users guide, options-phases.html#c-pre-processor
09:16:58 <kosmikus> oh, is this /Cons page new?
09:17:20 <CosmicRay> danke lemmih
09:17:34 <Igloo> @wiki Cons
09:17:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/Cons
09:17:36 <CosmicRay> with cabal, should I be naming files .cpphs or specifying the CPP Extension?
09:18:17 <Igloo> Does .cpphs even work?
09:18:32 <CosmicRay> Igloo: I don't know.  the docs say it does.
09:18:57 <Igloo> I thought it was discarded before being implemented, BICBW
09:19:21 <CosmicRay> there is code in cabal 0.5 to do it
09:19:27 <CosmicRay> don't know if it is ever called though
09:21:06 <CosmicRay> also I can't find what macros are predefined with hugs
09:22:06 <kosmikus> TheHunter, ozone: argh, this proposal is really strange indeed ...
09:22:16 <Lemmih> Is it possible to use GHC on Haskell sources which don't end on .hs?
09:25:40 <CosmicRay> Lemmih: .lhs works :-)
09:26:33 * Lemmih wants to use GHC as a preprocessor.
09:31:58 <TheHunter> yay, my lambdabot changes type check for the first time. Die, Dynamics, die!
09:32:11 <CosmicRay> heh
09:32:26 <CosmicRay> I'm turing up nothing about stuff that Hugs would define to cpp/cpphs
09:33:14 <Igloo> It certainly defines __HUGS__. At worst, try grepping for that in its source
09:33:31 <CosmicRay> Igloo: I've done that, but it seems that only ffihugs and hugs-hc define it
09:33:46 <CosmicRay> Igloo: its cpphs certainly doesn't, and I don't see how it would when it calls cpp
09:33:59 <CosmicRay> and where it does define it, it's not versioned
09:34:07 <CosmicRay> so I can't test from the old to the new version anyway
09:34:18 <CosmicRay> sigh
09:34:46 <SyntaxNinja> y0
09:35:10 <SyntaxNinja> I don't think hugs defines a CPP version number.
09:35:22 <Igloo> You can preprocess udring package building, then?
09:35:41 <CosmicRay> SyntaxNinja: should I be using the CPP extension or naming my files .cpphs?
09:35:42 <SyntaxNinja> you might double check, though
09:35:42 <SyntaxNinja> are you trying to fix the debian unstable problems?
09:36:05 <SyntaxNinja> CosmicRay: I think either one should work.
09:36:10 <CosmicRay> SyntaxNinja: yes
09:36:24 <CosmicRay> SyntaxNinja: and if I'm going to do that, I might as well make it work for as many others as possible, too.
09:36:25 <SyntaxNinja> using the CPP extension is going to use -cpp in ghc, I think.
09:36:34 <CosmicRay> SyntaxNinja: what about hugs?
09:36:47 <Igloo> BTW, if anyone knows the answer to http://lists.alioth.debian.org/pipermail/debian-xml-sgml-pkgs/2005-April/000847.html then that would be useful
09:37:22 <SyntaxNinja> Igloo: dono
09:37:30 <SyntaxNinja> CosmicRay: I can't remember what hugs does, but I think it works :)
09:37:36 <CosmicRay> heh
09:37:51 <SyntaxNinja> CosmicRay: I think it just runs cpphs.
09:38:06 <SyntaxNinja> CosmicRay: I had implemented it one way for hugs 2003, but ross reimplemented it, so I don't remember how it works.
09:38:11 <CosmicRay> oh, and *you* conveniently define __HUGS__ for me
09:38:18 <SyntaxNinja> oh, that was nice of me
09:38:26 <CosmicRay> indeed it was
09:38:35 <CosmicRay> couldn't be troubled to add the version number, eh? :-)
09:38:44 <SyntaxNinja> didn't know how
09:38:55 <SyntaxNinja> maybe configure figures it out?
09:39:04 <CosmicRay> hcDefines Compiler { compilerFlavor=NHC, compilerVersion=version }
09:39:04 <SyntaxNinja> if it's in the configure information, then we can add it
09:39:04 <CosmicRay>   = ["-D__NHC__=" ++ versionInt version]
09:39:04 <CosmicRay> hcDefines Compiler { compilerFlavor=Hugs }
09:39:04 <CosmicRay>   = ["-D__HUGS__"]
09:39:04 <CosmicRay> hcDefines _ = []
09:39:16 <CosmicRay> I dunno if configure detects that or not
09:39:48 <Lemmih> Hey RemiTurk.
09:39:54 <RemiTurk> hi Lemmih
09:40:00 <CosmicRay> yeah it looks like you are using cpphs for the CPP extension.
09:40:01 <RemiTurk> and everyone else
09:40:04 <CosmicRay> ok, that makes things easy enough
09:40:18 <CosmicRay> well I guess I can just declare that people must have the latest hugs.
09:41:09 <SyntaxNinja> CosmicRay: I'm thinking that we didn't have the compiler version; not sure if there's a way to get it from hugs. although I can't remmeber how we're getting it for ghc either
09:41:16 <SyntaxNinja> maybe i didn't write any of that code. hmm
09:41:47 <CosmicRay> SyntaxNinja: ghc sets the macro itself, apparently.
09:41:50 <CosmicRay> heh
09:42:12 <SyntaxNinja> CosmicRay: yeah, so that means we can detect which version of GHC we're built *with* but how do we know which we're building *for*?
09:42:34 <CosmicRay> I mean, ghc's cpphs or -cpp should set that macro automatically, I hope
09:42:47 <SyntaxNinja> ah, yeah probably true.
09:46:54 <CosmicRay> SyntaxNinja: in this help text:
09:46:59 <CosmicRay> Usage: setup haddock [FLAGS]
09:47:05 <CosmicRay> does [FLAGS] let me pass arbitrary flags to haddock?
09:47:47 <SyntaxNinja> CosmicRay: no, only the flags listed below
09:47:50 <CosmicRay> rats.
09:47:54 <SyntaxNinja> sorry.
09:47:56 <CosmicRay> I thought you had added that feature at some point.
09:48:12 <SyntaxNinja> no. patches accepted, though :)
09:48:27 <SyntaxNinja> and if there's something you need in cabal in unstable, then I can accept patches *and* upload it :)
09:49:00 <CosmicRay> ooo :-)
09:53:37 <TheHunter> @echo foo
09:53:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- echo; msg:IRCMessage {msgPrefix = "TheHunter!~TheHunter@p54AB0B5A.dip0.t-
09:53:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ipconnect.de", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo foo"
09:53:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ]} rest:"foo"
09:54:41 <CosmicRay> heh
10:07:23 <RemiTurk> has anyone read the new wiki-page about SyntacticSugar?
10:08:12 <RemiTurk> or even, is Henning Thielemann (who I suspect of writing it ;)) here (ever)?
10:13:38 <esap> I think syntactic sugar is essential. I can't believe somebody would not want syntactic sugar. It's essential for being able to communicate effectively with code.
10:14:01 <esap> The only alternative for syntactic sugar is macros, and I think that's even worse.
10:14:16 <RemiTurk> "But it can be reduced to the question whether syntactic sugar shall be used by default or only when it improves the functional notation, which seems to be rather a matter of taste."
10:14:23 <RemiTurk> (quote from the wiki)
10:14:30 <sorje> and syntactic sugar sounds so much nicer than macro
10:14:44 <esap> Functional notation is not relevant for syntactic sugar.
10:15:21 * RemiTurk waits for an explanation of the exact meaning of "functional notation"
10:15:24 * Lunar^ wonders what does mean "wibble"
10:15:34 <df_> wobble
10:15:41 <esap> RemiTurk: I suppose it means the functional style of program organization.
10:15:46 <df_> ... jelly on the plate?
10:15:47 <musasabi> haskell would be quite painful without syntactic sugar like the do-notation.
10:16:29 <RemiTurk> hm, "functional style of program organization", I'm not sure that really helps me ;)
10:16:55 * RemiTurk googles
10:17:13 <esap> RemiTurk: It's the result of OO vs. functional discussion. It means you model everything in terms of run-time system, e.g. functions.
10:17:39 <esap> RemiTurk: As opposed to organizing the program around data, as in OO.
10:17:41 <CosmicRay> @index ceil
10:17:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
10:17:48 <CosmicRay> @find ceil
10:17:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "find", try "lambdabot: @listcommands"
10:17:50 <CosmicRay> hmm
10:17:53 <RemiTurk> esap: thx :)
10:17:55 <CosmicRay> weren't those lambdabot commands?
10:18:38 <RemiTurk> in which case I think I can only agree with the quote, except the "can be reduced part"...
10:18:52 <xerox> CosmicRay: @info was banned for verbosity
10:19:18 <xerox> I suppose the rest had the same..
10:19:20 <esap> RemiTurk: Well I disagree with the quote, because I don't think functional style is the only reasonable style of programming.
10:19:20 <RemiTurk> that is, it's totally obvious to me that syntactic sugar shouldn't be used "by default" but only if it actually has an advantage
10:19:57 <Igloo> I think @index just hasn't migrated over to the new lb yet; not sure why
10:20:16 <Igloo> dons or shapr presumably know
10:20:41 <RemiTurk> esap: now that I understand it, I'm not sure the phrase "functional notation" has all that much importance in the whole sentence
10:21:54 <esap> RemiTurk: I'm not sure which part is important there.
10:22:47 <esap> RemiTurk: Because improving the functional notation doesn't seem important. Using syntactic sugar "by default" doesn't mean anything to me.
10:23:02 <esap> RemiTurk: Because all languages have syntactic sugar.
10:23:50 <RemiTurk> that "by default" phrase is basically what I almost suspect I don't understand as it seems so obvious I cannot imagine that's what he meant
10:23:58 * RemiTurk doesn't even try to parse that sentence
10:24:07 <RemiTurk> (my own)
10:24:23 <RemiTurk> the "by default" thing _seems_ to have an obvious answer: Occam's Razor
10:25:27 <esap> RemiTurk: Well I suspect that's what is intended by it. But Occam's razor is not a good argument for avoiding syntactic sugar.
10:27:37 <RemiTurk> I think it is, in the sense that Occam's Razor protests against unnecesary compliexity, and UC is always to be avoided in programming
10:28:15 <RemiTurk> so I'd shave [ f x | x <- xs ] back to map f xs
10:28:26 <esap> RemiTurk: Ah, but syntactic sugar is not complexity in programming. It's complexity in the parsers.
10:29:09 <esap> RemiTurk: Syntactic sugar is why people can understand the code. Try understanding combinator programs written in less than 4 combinators.
10:29:39 <esap> RemiTurk: I think complexity in tools is small price to pay for being able to understand the code.
10:29:48 <RemiTurk> *isn't sure he understands that one* do you mean something like "only S, K and I"?
10:30:29 <RemiTurk> I definitely agree that complexity in (probably few) tools is to preferred to complexity in (understanding) (many) programs
10:31:12 <esap> RemiTurk: Yes. S, K, and I is what you get when you have no syntactic sugar. Even assemblers have syntactic sugar... :-)
10:32:58 <RemiTurk> as in "I = S K K" is syntactic sugar for actually typing S K K everywhere?
10:33:25 * esap nods.
10:33:40 <RemiTurk> though I agree in theory, I think that may be stretching the meaning of synsugar a bit too far to keep it useful :)
10:34:12 <esap> Well syntactic sugar is everything that is not essential for expressing the desired semantics.
10:34:32 <esap> And it's surprising actually how little is enough.
10:34:59 <RemiTurk> but that's not the (admittedly vague and undefined) meaning it's usually used with
10:35:11 <RemiTurk> AFAICS
10:35:26 <RemiTurk> s/undefined/underdefined/
10:36:20 <esap> I'm thinking a language without syntactic sugar is just the "core" language, e.g. the "optimized" parse tree of the language. You don't have anything unnecessary in that.
10:38:15 <RemiTurk> like the "haskell kernel" ( http://www.haskell.org/onlinereport/intro.html#sect1.2 )
10:39:13 <esap> RemiTurk: Note it says "lthough the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus ..." Even the kernel is a sugared lambda calculus :-)
10:39:29 * RemiTurk has a suspicion we're not really arguing about anything but terminology
10:39:43 * esap agrees. Terminology is everything. :-)
10:39:53 <RemiTurk> *and actually agreeing*
10:40:53 * RemiTurk decides to postpone thinking about an adequate reply to the synsugar/cons 'till after bzflag
10:41:51 <RemiTurk> Lemmih: do you happen not to have anything better to do? ;)
10:45:59 <Oejet> RemiTurk: Me not.
10:47:49 * Lemmih is already playing bzflag.
10:47:58 <Si\> can the latest version of Haddock cope with TH splices?
10:48:35 <TheHunter> @babel en de foo
10:48:35 <Lemmih> thbot: How are you different from lambdabot?
10:48:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   foo
10:48:51 <Oejet> I'll call Wadler's law on the syntactic sugar discussion.  I must admit, that I find (1:2:3:4:End) bearable compared to [1,2,3,4].
10:48:57 <TheHunter> ok, not my fault...
10:51:37 <gzl> Oejet: btw, I got that stuff working
10:52:26 <gzl> Oejet: (with the parser)
11:04:21 <Oejet> gzl: Great!
11:04:32 <Oejet> Oh, let me see!
11:05:04 * RemiTurk comes back from some bzfragging
11:05:28 <Oejet> RemiTurk: I like the sniper maps.
11:07:36 <Lemmih> Hurrah for team Haskell.
11:07:51 <RemiTurk> :)
11:08:16 <RemiTurk> hm, wadlers law, about the time devoted to different parts of the discussion, wasn't it?
11:08:54 <RemiTurk> Oejet: I think 1:2:3:4:End would indeed have been okay (or perhaps Nil, or some other short word)
11:09:58 * RemiTurk doesn't see any Lemmih or Oejets
11:12:30 * Lemmih is busy working/playing with OpenGL.
11:13:51 <RemiTurk> well, it doesn't matter anyway, as I'm supposed to eat my dinner in a few minutes
11:13:59 <RemiTurk> have fun btw
11:20:03 <Oejet> RemiTurk: Thanks.
11:39:33 <CosmicRay> well.
11:39:39 <CosmicRay> I have a new appreciation for cpp suckage.
11:40:16 <basti_> is that good?
11:40:22 <CosmicRay> probably not :-)
11:45:05 <SyntaxNinja> cpp sucks
11:45:24 <CosmicRay> SyntaxNinja: didya get my bug report? :-)
11:45:41 <CosmicRay> if I put CPP on the Extensions line in .cabal, -cpp gets passed to ghc, but not if it's in a LANGUAGE pragma
11:47:28 <SyntaxNinja> CosmicRay: yeah
11:47:38 <CosmicRay> works fine for hugs though, go figure
11:47:57 <CosmicRay> oh, I just remembered the other thing.  setup haddock isn't using cpp-processed files.
11:48:06 <SyntaxNinja> tell me more about LANGUAGE pragma? it's at the top of source files?
11:48:13 <CosmicRay> second line
11:48:18 <SyntaxNinja> CosmicRay: hm. it should be?
11:48:23 <CosmicRay> I just wrote {-# LANGUAGE: CPP #-}
11:48:31 <CosmicRay> yeah, haddock barfs otherwise
11:48:38 <CosmicRay> haddock can't parse cpp stuff itself
11:48:54 <SyntaxNinja> CosmicRay: setup haddock will cpp it if it the package uses the CPP extension
11:49:03 <SyntaxNinja> cabal doesn't parse pragmas like that, AFAIK
11:49:17 <CosmicRay> SyntaxNinja: the doc/user-guide says otherwise :-)
11:50:08 <CosmicRay> file x29.html in the 0.5 sourceball mentioned it
11:50:20 <CosmicRay> I thought this was a very cool new feature :-)
11:50:44 <SyntaxNinja> hm
11:51:01 <SyntaxNinja> yeah, forgot about that. I think ross added it. I'll fix that.
11:52:59 <Oejet> Philippa: gzl and me wants to know why Parsec gives the error "unexpected end of input".  Do you think you could help us?
11:59:01 <wilx> Because it expects more input? :)
12:01:59 <Oejet> data Wiki = Bold WikiText | Underline WikiText | Text String
12:01:59 <Oejet> type WikiText = [Wiki]
12:01:59 <Oejet> wiki = boldPat <|> underlinePat <|> textPat
12:01:59 <Oejet> wikiText = many wiki
12:01:59 <Oejet> boldPat = between (char '*') (char '*') wikiText
12:02:23 <Oejet> He, that was more than three lines. :-P
12:03:26 <Oejet> textPat = many1 (noneOf "*_") >>= return . Text
12:03:41 <Oejet> *boldPat = between (char '*') (char '*') wikiText >>= return . Bold
12:03:56 <tuomov> what's popen called?
12:04:15 <Oejet> So on *Main> parseTest wikiText "*blob*" get the error:
12:04:19 <tuomov> (why can't this posix stuff have the same names as on c side...)
12:04:42 <Oejet> Parse error at (line 1, column 7): unexpected end of input, expecting "*" or "_".
12:06:14 <Lemmih> Oejet: You might want some try's in there.
12:07:09 <Philippa> Oejet: yo. You wanted a hand?
12:07:22 <Oejet> Philippa: Very much.
12:08:41 <wilx> Mmm.
12:08:49 <Philippa> what's underlinePat look like?
12:08:59 <wilx> I remember reading something about <|> in the Parsec paper...
12:09:11 <Philippa> wilx: you mean about the early commit?
12:09:12 <Oejet> Philippa: Same as boldPat.
12:09:14 <wilx> But I cannot check since my FFox doesn't work at the moment.
12:09:35 <wilx> Philippa, I am not sure what it was.
12:10:36 * Philippa blinks
12:10:39 <Philippa> of *course*
12:11:14 * Oejet is sharpening his ears.
12:11:20 <Philippa> Oejet: it's treating the second * as the start of another boldPat
12:11:44 <Philippa> which is why closing brackets're usually not the same char as opening ones
12:12:10 <Philippa> incidentally, last time I got working on Flippi's parsing model to make it pluggable that led me to a neat hack using state...
12:12:10 <Oejet> Ha!  I understand.
12:12:31 <Philippa> s.t. you have all the parsers that constitute wikiText named and can add and remove them
12:12:50 <Oejet> Ah!
12:13:15 <Philippa> so boldPat'd become between (char '*') (char '*') (without BoldParserName wikiText)
12:13:33 <Philippa> I rigged up a quick monad to generate unique IDs so there'd be no namespace clashes too
12:13:50 <Philippa> (there's the Unique type already, but it goes in IO and I figured allowing IO in parser plugins is a bad move)
12:14:25 <Philippa> FWIW, I never did get round to a WikiText datatype, not least on the grounds that extensibility sort of holes it - you end up with an existential instead, and then if you want renderer plugins things get icky
12:14:48 <gzl> ah, that 'without' thing is what I basically simulated manually
12:15:33 <Philippa> yeah. I nearly explained it all to Alistair Bayley back when Flippi 0.02 was released but hadn't figured out I could do it using Parsec's state so it was still a bit icky to explain
12:16:10 <Philippa> incidentally you'll find you need a separate list for escaped out stuff - if _'s the escape character, "_*Foo" is valid...
12:16:20 <gzl> I basically have "boldChildren," "underlineChildren," etc and then I use that with 'between' and such
12:16:34 <gzl> oh, hm. I didn't think of adding an escape character.
12:16:37 <Philippa> what happens with bold underlined text?
12:16:48 <gzl> it shows up as bold underlined text.
12:17:07 <gzl> *_foo_* or _*foo*_ both parse
12:17:42 <Philippa> how about *_foo_ bar _baz_*?
12:17:53 <gzl> works
12:17:59 <Philippa> or worse yet, *_foo* bar_?
12:18:09 <gzl> that won't
12:18:15 <Philippa> yeah. In fairness I reject that too
12:18:38 <eq> hi, I'm trying to use the X11 interface with GHC. Can someone explain why this programm gets no events? http://eq.homelinux.org/~eq/Codes/xlib.hs
12:18:48 <gzl> er, i'm actually not sure what happens in that situation. let me try that
12:19:17 <gzl> yeah, it fails.
12:19:39 <Philippa> yep, eats the second * as part of an underlined (or worse, as the start of a second bold patch)
12:19:57 <gzl> it starts doing that, but once it can't find the closing *, it fails
12:20:19 <Philippa> right. Probably an innermost closing * too
12:20:32 <Philippa> *_foo * bar * baz_*?
12:20:45 <Philippa> I intentionally reject that one
12:21:00 <Philippa> (OTOH, if it don't parse it gets treated as raw text)
12:21:08 <gzl> that one is allowed
12:21:20 <Philippa> with bar effectively being double-bold
12:21:38 <gzl> yes
12:22:03 <Philippa> actually, waitaminute, I don't reject (but it's single-bold and the *s show)
12:22:24 <Philippa> point is it sort of yells "stupid markup here!" when you preview it :-)
12:22:34 <gzl> yeah, that's clever, I didn't think of that
12:22:47 <gzl> I need to work on other modules for a while, but if I have time, I'll come back to the parser and try doing that
12:22:50 <gzl> is it hard?
12:22:54 <Philippa> I really ought to polish what I have a little and get a new version of Flippi out
12:23:14 <Philippa> no, though it's mildly hard work if you're enforcing unique identifiers for parsers everywhere
12:23:29 <gzl> want to see my code?
12:23:38 <chip> @paste
12:23:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
12:23:41 <Philippa> otherwise you just keep a list of (ID, Parser) pairs and wikiText is fold <|> pzero list
12:23:46 <TFK> Any small projects you may suggest doing in Haskell for self-teaching purposes? Nothing really comes to my mind :-(
12:23:55 <gzl> write a wiki. :)
12:24:19 <gzl> Philippa: is there a reason you chose not to use WASH for yours?
12:24:22 <TFK> I thought about that one, actually, but then I'd have to stick to an HTML reference or something :-/
12:24:31 <TFK> But there are no wikis written in Haskell, are there?
12:24:34 <Philippa> gzl: the persistence mechanisms suck
12:24:43 <Philippa> TFK: I've written one (it's pretty barebones though)
12:24:45 <gzl> Philippa: yes they do!
12:24:50 <chip> At the top of that page is some code which does not compile.  I don't understand why ... I'm defining a given function for two type constructors, but ghc is refusing to let me specify the function type as a class, which confounds me
12:25:04 * esap suggests writing a program to visualize structure of software.
12:25:06 <chip> I wish to say "I'm going to return a Num but I don't want to be more specific"
12:25:10 <Oejet> Philippa: Wow, that is clever  (fold <|> pzero).
12:25:13 <TFK> Well, since I'm aiming at something pedagogical, it would probably be bare-boned as well...
12:25:13 <gzl> Philippa: that's what I'm having to use right now, but I'm going to try getting away from the persistent module and use a database instead
12:25:29 <chip> (function _return_ type, I should say)
12:25:40 <TFK> esap, isn't that a tad too hard for a beginner? ;-)
12:25:57 <gzl> (fold <|> pzero)?
12:26:02 <Philippa> Oejet: actually thinking about it I probably used choice (map (\(id,parser)->parser) parserlist) instead
12:26:12 <esap> TFK: Well, it depends on what kind of pre-build components he uses.
12:26:22 <Philippa> but I'm guessing that's how choice is defined
12:26:40 <chip> http://www.haskell.org/hawiki/HaskellIrcPastePage  <- First code segment
12:26:42 <Philippa> and I goofed the syntax a little anyway :-)
12:27:09 <gzl> Philippa: yeah, this is for a class, so I have to use WASH
12:27:12 <Philippa> gzl: if you have a list of parsers, and you fold <|> over it with pzero ("fail") as the zero element, you have a parser that tries each parser in the list 'til one consumes something
12:27:24 <TFK> Well, what kind of pre-built components are avaliable to him (=me)? Since the problem seems mostly difficult logically.
12:27:26 <gzl> oh, of course
12:27:44 <Darius> lambdabot: @version
12:27:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p124, GHC 6.4 (OpenBSD i386)
12:27:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:28:02 <Philippa> TFK: Parsec's great for doing the parsing aspect, Network.CGI just about works well enough to get it talking to the web, I used the filesystem as my database which was nice and simple
12:28:14 <chip> I'm not doing homework, I'm actually learning .... <- trolling
12:28:20 <chip> trolling for help, that is
12:28:58 <Philippa> chip: type classes aren't types, they're constraints on types
12:29:07 <Philippa> (Num a) => a
12:29:21 <Philippa> ("some type (a here) with the constraint that a is in Num")
12:29:36 <Philippa> read :: (Read a) => String -> a
12:29:40 <Philippa> you get the idea?
12:29:49 <chip> Hm.
12:30:22 <TFK> Philippa, I was talking about visualizing structure of software, but thanks for the tip ;-)
12:30:29 <Philippa> ah, sorry :-)
12:30:30 <chip> Philippa: I get what you're saying ... but if that's true then the code should work, as the constraint is redundant with the actual definitions I've provided
12:30:39 * chip is still confused
12:30:42 <Philippa> chip: no, an over-general type isn't allowed
12:30:50 <Philippa> nor an incorrect one
12:31:09 <Philippa> you can't do myread = read with myread :: String -> a
12:31:25 <Oejet> chip: xval returns both an Int and a Float, which is an error.
12:31:44 <Philippa> TFK: there's some general ideas - you've got ASTs and modules as basic ways to show stuff. And of course there's that bastard UML thing
12:31:55 <Philippa> IIRC Rational Rose can translate code in various langs into UML
12:31:59 <TFK> What are ASTs?
12:32:04 <Philippa> Abstract Syntax Trees
12:32:08 <chip> Oejet: Oh ... so the pattern matching on the parameters happens later, after the return type must be known?
12:32:14 <Philippa> subexpressions under expressions, that kind of thing
12:32:18 <TFK> See? Too complicated for me already :-(
12:32:31 <Philippa> 2+3 might be visualised as a tree with + as the root node and 2 and 3 as its children
12:32:34 <Oejet> chip: All types a know at compile time.
12:33:22 <chip> Hm.
12:33:31 <Oejet> TFK: http://www.student.dtu.dk/~s022018/Temporary/Parser.hs  has an AST.
12:33:37 <TFK> A Wiki sounds much less complicated logically, but then again everybody does a Wiki so I wouldn't want to duplicate efforts :-)
12:33:47 <Oejet> *are known.
12:33:48 <monochrom> types can be inferred. type inconsistencies can be inferred too.  everyone sees that "if whatever then 1 else False" has a problem.
12:34:14 <Philippa_> monochrom: or "if 1 then...". Well, unless they're a C coder
12:34:34 <chip> monochrom: and there's an implied "if parameter is XInt ... else if parameter is XFloat ..."
12:34:39 <chip> monochrom: I start to understand
12:34:45 <monochrom> Yeah, don't use C as the standard of well-typing.
12:34:57 <chip> monochrom: I'm trying not to.  :-,
12:36:04 <Oejet> chip: What do you want the value of xval to be?
12:36:05 <Philippa_> chip: there's never an implied pattern-match. If a function is polymorphic but restricted to a type class, the necessary instance info gets passed in as a parameter
12:36:24 <Philippa_> and if you write an explicit pattern, there's (unsurprisingly) a pattern-match
12:36:38 <chip> Oejet: This is a language experiment; but I think my design pattern actually requires XInt and XFloat to be distinct types
12:38:15 <Philippa_> pretty much, yes
12:38:19 <Philippa_> well, not quite
12:38:21 <Oejet> Oh, I meant, what type do you want xval(x) to be?
12:38:26 <Philippa_> more it requires you to pattern-match on them often
12:38:26 <chip> Oejet: .. because I actually wanted distinct return types, and that's apparently not possible unless you have different types on the parameters, not just different constructors for the same type
12:38:48 <Philippa_> chip: bingo. Otherwise the return type would be dictated by a value and not a type
12:38:58 <chip> Oejet: I want xval (XInt i) -> Int and xval (XFloat f) -> Float
12:39:02 <Philippa_> this is called dependant typing, and Haskell doesn't do it
12:39:19 <Philippa_> you /can/ write toInt and toFloat funcs that fail if it's not actually an Int
12:39:29 <Philippa_> but that's only useful when you actually know
12:39:37 <Oejet> Then you cannot decide the type of y = xval(x) at compile time.
12:39:40 <Philippa_> oh, and you can eg write a Num instance for xval
12:39:45 <chip> Maybe Int -- I learned that
12:40:24 <chip> Oejet: well, you could (hypothetically) decide it if the constructor is right there in the code, but not in Haskell per se
12:40:46 <Philippa_> right. So, when do you need to get the actual values?
12:41:10 <Philippa_> and is it really going to be too painful doing the pattern-match all the time?
12:42:13 <chip> Philippa_: well, the idea was to learn about the language; now that I know how to make this example work, I don't actually have to *do* it; thanks all
12:42:49 <chip> "Theoretical physicist: Physicist never actually observed, but whose existence is postulated to balance the budget."
12:43:33 <esap> chip: That could be used to derive a definition for theoretical physics.
12:44:23 <chip> Theoretically...
12:47:07 <esap> Something like: "Theoretical physics: A reseach subject that is actually never observed to produce results, but whose existence is postulated to balance the costs of all other research" :-)
12:47:29 <monochrom> dark physicists :)
12:47:48 <CosmicRay> heh
12:49:48 <Darius> esap: Theoretical physics is what theoretical physicists do, which is balance the budget, which is what accountants do, therefore theoretical physicists = accountants. QED
12:50:51 <esap> "proof by generalization"? :-)
12:52:04 <Darius> Nah, I just changed the meaning of '=', \subseteq would be better.
12:52:27 <esap> ok right.
12:52:34 <CosmicRay> Darius: ooo, so if I just hide the definition of '==' in the Prelude, all my proofs will work? :-_
12:53:00 <Darius> CosmicRay: Yes, up to (==).
12:53:34 <TheHunter> man, SeenModule is a mess.
12:54:14 <esap> Speaking of equivalence classes, I think recursion is the way to build new equivalence classes. What do you think of this, is this trivially true?
12:54:16 <CosmicRay> Darius: heh
12:55:42 <monochrom> Trivial.
12:56:57 <TFK> So, any other programming katas other than the two mentioned above come to mind?
12:58:09 * Darius doesn't know the "above two mentioned ones", but how about take your old language and implement an interpreter and compiler for the next revision of it?
12:58:15 <Darius> It worked for autrijus.
12:59:36 <TFK> It was a wiki and software-visualization. ;-)
13:00:16 <Philippa_> Darius: heh
13:00:29 <Philippa_> you know my chosen variant :-)
13:00:45 <Philippa_> (am discussing the possibility of a strict haskell for gamedev in another chan atm, too)
13:01:02 <TFK> Yup. If no other ideas come, I think I'll go with the wiki. But I really, really don't want to mess with HTML :-/
13:01:19 <TFK> Gamedev is interesting, I'm already in the process of making a PyReversi game :-)
13:01:30 <TFK> "strict haskell"? As in, without the lazy part?
13:01:33 <Philippa_> the Text.Html module makes that part easier than it could be at least, and you won't have to parse any HTML
13:01:44 <Philippa_> TFK: more without the laziness-everywhere part, but yeah
13:02:52 <TFK> Well, depending on the game, laziness doesn't sound so bad :-)
13:02:56 <Philippa_> there're a pile of other notables about haskell by now
13:03:05 <Philippa_> the performance unpredictability is bad
13:03:20 <Philippa_> certainly if you want to use it for eg commercial console games
13:03:47 <TFK> Well, why not use O'Caml for that, since it's all strict and made for performance anyway?
13:04:25 <esap> Hmm.. for the performance unpredictability, doesn't Control.Concurrent.Chan help?
13:04:50 <Philippa_> TFK: type classes, monads, all the other funky type system stuff
13:05:21 <TFK> Ah, fair enough.
13:05:29 <Philippa_> esap: it's good for concurrent stuff, but you've still got things like the piling up (+1) thunks problem
13:05:41 <Philippa_> oh, and the syntax doesn't suck
13:07:19 <esap> philippa: I guess that's the space usage unpredictability problem :-)
13:07:54 <Philippa_> it's also a performance issue
13:08:24 <Philippa_> on at least two levels - +1 thunks are way slower than executing strictly, and building up that much space will kill your cache
13:08:50 <esap> philippa: But the performance problem disappears, if you fix the space leak, I suppose. Object-oriented programming is the correct solution for the space leak problem.
13:09:18 <Philippa_> nah, strict evaluation and TCO works well enough
13:10:02 <esap> philippa: well it works, but it's too hard to use to be useful. Fortunately, OO is possible to implement as a library.
13:10:17 <Philippa_> may be too hard to use in haskell as it stands...
13:10:45 <SamB> how do people do lexing in haskell, normally?
13:10:56 <Philippa_> depends on the person. Me, I'd grab Parsec for it
13:11:04 <Philippa_> many would accuse me of overkilling the problem :-)
13:11:47 <Cale> I'd do the same. Parsec is fun to use. :)
13:12:17 <SamB> well, I would be using Parsec for the parsing in any case
13:12:32 <SamB> well then, backtracking it is
13:12:37 <Philippa_> in that case IMO you don't bother with a lexer, you just have parsers for the individual tokens
13:12:46 <Philippa_> (ones that use try where appropriate)
13:15:42 <TheHunter> @type id
13:15:42 -thbot(~thbot@p54AB0B5A.dip0.t-ipconnect.de)- Prelude.tail: empty list
13:15:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- id :: forall a. a -> a
13:16:06 <Cale> Yeah, the separation into steps where you do lexing and parsing separately with entirely different tools seems a bit unnatural in the context of parser combinators.
13:16:25 <tic> argh, why does lambdabot and thbot broadcast to everyone in the channel? extremely annoying.
13:16:39 <Cale> tic: they're just sending notices
13:16:45 <Philippa_> it's irritating how many clients react to notices though
13:16:48 <esap> Cale: I don't find it at all unnatural.
13:16:50 <Darius> TheHunter: Do you have a ghci-6.4?
13:16:59 <TheHunter> lambdabot, @wiki LambdaBot/Notices
13:17:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
13:17:06 <tic> Cale, which is extremely annoying; I didn't ask for them.
13:17:21 <TheHunter> Darius, not exactly, some ghci-6.5
13:17:41 <TheHunter> sorry to put thbot in the channel, i had to test @seen
13:17:50 <Philippa_> tic: in theory it's no different to them sending PRIVMSGs
13:17:58 <Cale> tic: It's expected that IRC bots produce notices rather than PRIVMSGs (ordinary talking), and not respond to notices so as to not get into infinite loops.
13:18:15 <TheHunter> @part thbot
13:18:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- not enough privileges
13:18:29 <Philippa_> cue kill -9 thbot?
13:18:33 <tic> and I notices don't have an address, right?
13:18:54 <kosmikus> normal talking doesn't have an address either
13:18:56 <xerox> tic: lambdabot's features are intended for both personal and community usage
13:19:10 <Cale> If your irc client treats notices significantly differently from talking, consider getting a new irc client, or reconfiguring the one you use.
13:19:44 <tic> no, not really different from talking, it's just braindead to let the bot send messages to _everyone_ when there's only really a single user asking.
13:19:56 <Cale> esap: it's just that it's so natural to build parser combinators that do the lexing bits and combine them into parsers
13:20:07 <Philippa_> tic: they're often used in the middle of a conversation to provide an answer
13:20:08 <kosmikus> I'd actually revert to the old lambdabot behaviour; I think this it's nice that we can implement the RFC, but it's just not practical, as obviously most clients are broken
13:20:09 <tic> especially when I'm in another channel.  so that's client-related, but I suppose that's generally how notices work.
13:20:39 <esap> cale: ok, but then there is no interface between lexing part and parsing part, is there?
13:20:40 <Cale> tic: they respond in private to messages sent to them directly, and not to the channel
13:20:58 <Philippa_> tic: it /shouldn't/ be how they work, but hey
13:21:01 <kosmikus> tic: notices are still addressed to a specific channel
13:21:17 <Philippa_> the problem is that they seem to've been co-opted for a different purpose - something of an abuse
13:21:21 <Cale> esap: no explicit interface -- the parser just uses the lexing parser combinators directly
13:21:30 <Philippa_> tbh, notice was misnamed
13:21:42 <Philippa_> the abuse is understandable, it /looks/ like it's for grabbing attention 'til you read the RFC
13:21:49 <SamB> esap: which is kind of the point
13:22:00 <tic> oh well, then the client I'm using needs to be fixed, for some definition of fixed....
13:22:31 <esap> cale: I suppose the point is, you can use combinatoric parsers in a way that has a nice interface between lexer and parser. But if you don't have any interface, then you can't distinguish those. Well maybe it is the point, though I'd consider interfaces as good thing there.
13:22:57 <Cale> tic: what exactly does it do?
13:23:25 <SamB> well, it would be a pain to eat the tokens after you had gotten them, if they came in a list
13:23:40 <Darius> esap: The distinction between lexer and parser is artificial (but usually useful).  In Parsec, they aren't different things so there's no need for an interface.
13:23:44 * chip uses tokens to play Time Crisis
13:23:53 <tic> [%H:%M] -%nick- %message
13:23:56 <kosmikus> most other irc bots I know don't send notices, and I think there haven't ever been any problems with lambdabot sending privmsgs, so why not make it a configuration option, but use privmsgs again?
13:23:57 <tic> in whichever channel I'm in.
13:24:11 <chip> Separate lexer and parser are inadequate for some tasks.  M.D. Smith M.D.  <- is "M.D." one token or two?
13:24:14 <Philippa_> Darius: it's occasionally useful if you want to rule out somebody playing silly buggers with char or something
13:25:06 <Philippa_> so you'd lex to MyToken then use the GenParser interface with a bunch of appropriate one-token parsers
13:25:19 <tic> TheHunter, version works better.
13:26:15 <TheHunter> tic, ok, thanks.
13:26:28 <esap> philippa: yes. It's also possible to use a type class as the interface.
13:26:57 <Philippa_> well yeah, if you get that far all the usual tricks apply
13:27:27 <Philippa_> it's certainly something I'd consider in a parser for an existing standard that's defined in terms of a specific token set
13:31:02 <esap> The continuation passing way of constructing lexers is also interesting.
13:31:11 <TFK> What are +1 thunks?
13:31:30 <TFK> (I kinda know what a thunk is, wondering what the +1 stands for)
13:32:19 <wilx> Partially applied +?
13:32:42 <esap> TFK: Those are intermediate data structures generated by the compiler from use of a section (+1) :: Int -> Int  [a function that adds 1 to the number passed in]. If you do much computations that partially apply (+), you may get many intermediate thunks.
13:33:31 <esap> TFK: that's related to the way lazy evaluation is implemented.
13:33:48 <SyntaxNinja> can someone please follow up to alex jacobson with a resounding 'huh?' I can't bring myself to do it.
13:34:14 <esap> SyntaxNinja: Where?
13:34:15 <TFK> Hmm, thanks
13:34:38 <Lemmih> heh.
13:34:41 <SyntaxNinja> http://www.haskell.org//pipermail/libraries/2005-April/003524.html
13:34:56 <TFK> But why exactly +1 ? Don't other partially-applied functions create thunks as well?
13:37:27 <SamB> why is haskell supposed to support source in unicode?
13:37:51 <esap> TFK: yes, all partially applied functions create thunks, +1 was example.
13:37:53 <basti_> because unicode will r3wl dah w0rld.
13:38:10 <Darius> Philippa will correct me if I'm wrong, but I'm pretty sure she was referring to instances like length = length' 0;length' acc [] = acc;length' acc (x:xs) = length' xs (acc+1) (aka foldl (\acc _ -> acc + 1) 0).  Sections or partial application don't have anything to do with it.  As for +1 the aforementioned case is just "archetypical".
13:38:41 * TFK can't read that...
13:38:49 <Darius> SamB: Because the Report says so, or are you wondering why the Report says so?
13:38:58 <SamB> Darius: the latter
13:39:14 <basti_> isnt that a catamorphism?
13:39:37 <Darius> SamB: The same reason anything else is done, it seemed like a good idea at the time :P
13:39:45 <Darius> basti_: foldr is a catamorphism.
13:39:58 <basti_> hmm ok.
13:40:09 <Darius> foldl can be written in terms of foldr, but...
13:40:16 <SamB> Darius: do you think they will take it out of the next version (mostly)?
13:40:37 <Maddas> So is everybody using Yi already? :-)
13:40:48 <SamB> what is Yi?
13:40:54 <TFK> What's wrong with Unicode source?
13:40:58 <Maddas> http://www.cse.unsw.edu.au/~dons/yi.html
13:41:06 * basti_ shudders
13:41:28 <SamB> TFK: Parsing nightmare?
13:41:50 <SamB> What is the point outside of comments and string literals?
13:41:51 <SyntaxNinja> SamB: fwiw, simon m. added unicode support to alex in order to support this, if I recall.
13:41:56 <Darius> Samb: It more looks like the implementations will support it and real Unicode support will be standardized in the next revision, but that won't be for a bit
13:42:02 * basti_ darcs get yi
13:42:03 <basti_> =)
13:42:14 <basti_> an editor in haskell? i'm with it
13:42:26 <TFK> Maddas, ah, you don't have win32 binaries? :-(
13:42:52 <Maddas> Me? No, I didn't even install the latest version on my own machine yet
13:43:26 <TFK> Hmmm. It says that vi/etc. can be used as frontends. So Yi doesn't come with its own GUI?
13:43:31 <Maddas> I mainly wanted to solicit opinions about it :-)
13:43:48 <musasabi> TFK: Yi has a frontend which looks like vi.
13:44:04 <basti_> i do not consider vi a masterpiece of a frontend
13:44:10 <TFK> That sounds like a bad thing.
13:44:32 <Maddas> Hm, no ed frontend? :-(
13:44:33 <TFK> But let's compile and see...
13:44:36 <basti_> yes.
13:44:46 <SamB> Maddas: Might as well use ed
13:44:53 <basti_> modal interfaces are a nightmare.
13:45:10 <musasabi> basti_: the frontend stuff is modular.
13:45:13 <Maddas> SamB: Don't worry, I wasn't being serious :-)
13:45:15 <basti_> thats good
13:45:21 <musasabi> basti_: it should be easy to use an another frontend...
13:45:41 <SamB> Maddas: I couldn't imagine you were.
13:45:50 * basti_ will have a look. 
13:45:56 <Maddas> Heh. Surely *some* people must like ed.
13:46:18 <TFK> Huh? Yi doesn't work on win32 atm?...
13:47:04 <TFK> Ah, there's a porting checklist.
13:48:47 <beschmi> hi all
13:49:18 <tuomov> STArrays don't work with state transformer monads?
13:51:41 <Darius> tuomov: ?
13:52:21 <tuomov> I get 'undefined instance' complaints from use of writeArray
13:52:48 <tuomov> I have an ErrorT StateT IO kludge, and am currently using IOArrays
13:53:09 <tuomov> I wanted to try if STArray would be a little faster, since there's one lift less
13:53:31 <Darius> ST arrays work with ST.  They require "magic" and therefore couldn't work with State(T) because that's just plain Haskell.
13:54:04 * SamB notices that oneOf doesn't supply a nice error message
13:54:32 <Darius> SamB: What error message does it provide?
13:55:26 <SamB> Darius: it doesn't provide one at all
13:56:27 <SamB> I just get the "unexpected 'c'" one
13:56:49 <SamB> I guess it won't matter, though
13:56:49 * RemiTurk returns from tv
13:57:12 <RemiTurk> Maddas: ken thompson is said to still use ed
13:57:36 <Maddas> :-)
13:58:44 <Darius> dons appears to be a sed fanatic, but he's writing Yi and it mostly supports vi-ish behavior at this point, so whatever that implies.
13:59:20 <TheHunter> ok, no more dynamic state in lambdabot.
14:02:59 * RemiTurk is willing to negotiate with SyntaxNinja about a distributed "huh" message to haskell-libraries
14:05:57 <SyntaxNinja> RemiTurk: what are your terms?
14:08:38 <RemiTurk> I guess I'll just ask for it to be distributed for now ;)
14:09:33 * RemiTurk wonders what the Real Proposal is going to be, given the strawman proposals
14:09:47 <RemiTurk> something with XML/SOAP...?
14:10:09 <SyntaxNinja> distributed meaning "sent", or distributed meaning "multiply sent" :)
14:10:19 <SyntaxNinja> hackage already has xml-rpc!
14:11:20 <RemiTurk> then what's stopping us from using that for our great centralized module name repository?
14:11:33 <RemiTurk> we could also make it p2p?
14:12:41 <RemiTurk> distributed as in: I don't intend to have to answer all replies, as I didn't read the thread all that seriously
14:13:05 <RemiTurk> (uhm, that's still not an anwer:) multiply sent)
14:14:03 <SyntaxNinja> RemiTurk: I think that he wants it to be decentralized, and he wants to alter import statements
14:14:15 <SyntaxNinja> I just have no idea wha this objection to build-depends is, and I'm afraid to ask
14:15:11 <SyntaxNinja> presumably hackage could build a reverse mapping from module names to sets of packages (since packages can have the same module names) but I don't think cabal should give a crap about it
14:15:29 <RemiTurk> then we could use soulseek/kazaa/whatever for it? (which would also give the p2p community new ammo in their "it's legal!" battle ;))
14:15:30 <SyntaxNinja> I don't think cabal or ghc or anyone else should try to determine which package a module belongs to at build time.
14:16:23 <SyntaxNinja> you might want to query hackage like "hey, what package should I depend on for module FOO" but it should be then added by hand.
14:16:39 <SyntaxNinja> looking up the package based on the module name is just Too Much Magic, imo
14:16:43 <RemiTurk> I'm not going to like any connection errors during compiling for the next few decades
14:16:58 <SyntaxNinja> word
14:17:35 <SyntaxNinja> well, for now, I think there will be only one hackage, but I definitely think that eventually cabal-get or whatever interfaces iwth hackage should have a list of "cabal sources"
14:17:59 <SyntaxNinja> I don't know how to translate that into a p2p thing, but I think it should be legal, so that would be cool by me ;)
14:18:44 <poetix> Anyone got a moment to critique some newbie Haskell code?
14:19:17 <RemiTurk> only if it isn't too much work to shoot holes in it ;)
14:19:25 <poetix> That's the spirit.
14:19:38 <poetix> http://codepoetics.com/poetix/index.php?p=104
14:19:53 <poetix> I wrote a sukodu solver, then rewrote it using a state monad
14:20:39 <RemiTurk> I guess you'll first have to explain a little about what Su Doku is
14:20:59 <poetix> Sort of number crossword game
14:21:12 <poetix> See http://codepoetics.com/poetix/index.php?p=103
14:21:28 <poetix> which has the pre-monadic version, and a link to the Times page on Su Doki
14:21:38 <poetix> Doku
14:21:38 <SyntaxNinja> whew your web page renders slow on my machine
14:22:08 <poetix> Slow on mine too. I may ditch the transparency sometime soon.
14:22:41 <RemiTurk> SyntaxNinja: (justincase:) my p2p idea was a parody. I don't really have any serious hackage/cabal yet as looking at them hasn't left my todo list yet
14:23:09 <poetix> I think hackage should use rss/bittorrent, for maximum buzzword compliance
14:23:13 <SyntaxNinja> RemiTurk: noted
14:23:29 <SyntaxNinja> startGame = [[0 | x <- [0..8]] | y <-[0..8]]
14:23:29 <RemiTurk> poetix: I'd also like the contrast of the spiralling thingy to be a little less (it'd read easier for me)
14:23:34 <SyntaxNinja> you might look at 'replicate'
14:24:27 * poetix googles, nods
14:24:41 <SyntaxNinja> poetix: google for "haskell hierarchical libraries"
14:24:45 <SyntaxNinja> that'll give you the libraries API
14:24:49 <Darius> @type replicate
14:24:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- replicate :: forall a. Int -> a -> [a]
14:25:09 <SyntaxNinja> also, I always use qualified imports: import List (foo, bar)
14:25:17 <SyntaxNinja> poetix: it looks reasonable at a glance.
14:26:24 <RemiTurk> not really any code style thing, but (according to some) softtabs work better with layout based languages like haskell
14:26:33 <poetix> I thought it was mostly OK - mainly looking for style tips & shortcuts
14:26:41 <poetix> softtabs?
14:26:56 <RemiTurk> spaces
14:27:10 <RemiTurk> usually with an editor that understands what to do when you press tab/backspace etc
14:27:21 <SyntaxNinja> play :: [Move] -> SudokuGame ()
14:27:21 <SyntaxNinja> play ms = do	update ms
14:27:21 <SyntaxNinja>                         solve
14:27:30 <SyntaxNinja> I usually write that as "play ms = update ms >> solve"
14:27:44 <poetix> On win32 I use jEdit, on Linux emacs. emacs is smarter with tabs.
14:27:53 <RemiTurk> it prevents screwups when you mix tabs/spaces and/or you set up tabs to not display as 8 spaces
14:27:53 * SyntaxNinja only uses 'do' when I have to introduce an intermediate symbol
14:28:48 * poetix uses do as a kind of nervous twitch, but will get over it
14:29:30 * RemiTurk never (except in GHCi) puts commands on the same line as the "do"
14:29:35 <SyntaxNinja>  			if (length forcedMoves==0)
14:29:39 <SyntaxNinja> you don' tneed parens there
14:29:43 <Darius> poetix: One minor style thing that I recommend is starting code following a 'do' on the next line to avoid layout issues if you fiddle with the name/parameters/etc.
14:29:49 <RemiTurk> nor do you need length/==0
14:29:57 <RemiTurk> if null forcedMoves
14:30:15 <RemiTurk> (I suppose you don't use the length to force evaluation of the whole list)
14:30:17 <Darius> Yeah, that is ugly use null as RemiTurk suggests (or pattern matching if that's convenient)
14:30:34 <poetix> :)
14:30:44 <SyntaxNinja> update :: [Move] -> SudokuGame ()
14:30:44 <SyntaxNinja> update ms = mapM_ move ms
14:30:51 <RemiTurk> in which case you might also want to look at
14:30:53 <SyntaxNinja> you can of course write that as "update = mapM_ move"
14:30:54 <RemiTurk> @wiki ThingsToAvoid
14:30:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/ThingsToAvoid
14:31:12 <RemiTurk> (which also proves that lambdabot should talk to everybody)
14:31:19 <RemiTurk> hi shapr
14:31:21 <shapr> hiya
14:31:35 <poetix> hi (it's Dominic)
14:31:36 <shapr> poetix: greetings!
14:31:46 <shapr> Nice to meet you in realtime!
14:31:48 <Darius> poetix: On a more pragmatic basis, using the predefined monad (transformers) would be more sensible.
14:32:01 <SyntaxNinja> hi shapr
14:32:22 <shapr> poetix: I'm still not sure what happened with comments on your blog, sorry for spamming.
14:32:22 <poetix> Darius: agree. I was trying to build from scratch in order to understand better.
14:32:31 <shapr> y0 SyntaxNinja, wassup?
14:32:41 <Darius> poetix: I thought so.
14:32:53 <poetix> shapr: I think WordPress is a bit eager about putting stuff in the moderation queue
14:33:23 <RemiTurk> for simple functions like isEmpty I'd probably write isEmpty p = (==0) `liftM` getValueAt p
14:33:26 <shapr> poetix: oh, I was going to ask you about your polyominoes. I've been in pursuit of a type-safe Penrose tile implementation. But I'm not sure they're related.
14:33:27 <Darius> Quite a few unnecessary parens
14:33:35 <RemiTurk> or even entirely point freed
14:33:41 <poetix> Darius: another nervous twitch
14:34:07 <poetix> shapr: The polyominoes code is *very* inefficient at the moment. Needs revisiting.
14:34:16 <RemiTurk> the set-functions?
14:34:42 <shapr> poetix: did you ever get HaskellDB built?
14:34:46 * RemiTurk just noticed you're using intersect/union and just might get a huge performance improvement by switching to e.g. Data.Set
14:34:55 <poetix> Polyomino tiling is interesting - don't know to what extente related to penrose tiling
14:35:15 <poetix> RemiTur: union is between list of between 0 and 10 members' size - not likely a big issue
14:35:35 <Itkovian> night :-)
14:35:39 <poetix> shapr: HaskellDB built, but didn't like my version of MySQL much
14:35:44 <SyntaxNinja> shapr: nomuch; just hacking around
14:35:50 * RemiTurk hadn't noticed _that_ yet
14:37:01 <shapr> SyntaxNinja: cool code?
14:37:35 <SyntaxNinja> shapr: yuppers
14:38:10 <shapr> I just posted an LtU article about Pugs.
14:38:36 <shapr> poetix: hey, have you thought about a Zope in Haskell?
14:38:42 <RemiTurk> tryAllMoves = msum . map (\m -> move m >> solve)
14:38:42 <poetix> thanx guys for suggestions
14:38:56 <RemiTurk> or, the sugared version: tryAllMoves moves = msum [do move m; solve | m <- moves]
14:39:03 <SyntaxNinja> poetix: you might get more in-depth suggestions if you post to haskell-cafe
14:39:05 <poetix> shapr: Yes, I want to do a RESTful web application server in some cool language
14:39:12 <SyntaxNinja> poetix: how long have you been learing haskell?
14:39:19 <poetix> shapr: when I get about a million years' spare time to do it in
14:39:39 <poetix> shapr: I've been dabbling on and off for a couple of years, but seriously only recently
14:39:42 <shapr> I work with Zope for a living, so my motivation to implement something comparable in Haskell is quite high.
14:40:06 <poetix> I like Twisted myself
14:40:36 <shapr> zope2 is difficult to unit test/modify. zope3 isn't really ready for production use.
14:40:58 <shapr> Twisted is nifty, I agree.
14:41:12 <Lemmih> SyntaxNinja: Are there plans for building profiling libraries with Cabal?
14:41:17 <RemiTurk> poetix: allPositions= liftM2 (,) allCols allRows
14:41:20 <SyntaxNinja> Lemmih: for some value of plans, yes
14:41:44 <shapr> I'm not sure what they're calling the twisted persistence broker these days, but that was a very cool feature.
14:41:52 <poetix> I found Zope a bit bloated and crufty. They've had to work really hard on refactoring it. More unit tests sooner might've helped (he says hypocritically)
14:42:27 <shapr> I think I would agree with your opinion of Zope, though likely with more fervor.
14:42:55 <poetix> Twisted might go well into a pure functional framework - lots of little handlers
14:43:07 <shapr> My fiancee (and business partner) can usually tell when I'm working on deep internals by the volume of the cursing :-/
14:43:54 <SyntaxNinja> Lemmih: I'm wondering if I should spend time on Hackage or cabal...
14:44:09 <shapr> Using HaskellDB reminds me of Twisted, you never get to see the DB directly, but you do get to write database handlers that work sort of like callbacks.
14:44:27 <shapr> That's sort of like Yampa's usage of Signals.
14:45:06 <poetix> Where does this happen? (I've only got as far as building queries using the relational-monadic-query-building-embedded-compiler-thingy
14:45:08 <KrispyKringle> shapr: you're writing a web application framework in haskell?
14:45:11 * Lemmih hands a coin to SyntaxNinja. (:
14:45:39 <KrispyKringle> sorry. i just got here.
14:46:19 <shapr> KrispyKringle: Not directly, not just yet. But I am in search of ways to do such a thing well in Haskell.
14:46:31 <poetix> Concurrent Haskell any help
14:46:32 <poetix> ?
14:46:46 <RemiTurk> perhaps
14:46:57 <shapr> Yes, concurrent is good for multithreading.
14:47:14 <poetix> Lightweight or heavyweight threads?
14:47:20 <Lemmih> SyntaxNinja: I writing some really neat OpenGL code now, so going back to the ugles of Hackage might take some time/courage.
14:47:26 <RemiTurk> very lightweight
14:47:28 * poetix dreams of Oz, Erlang et all
14:47:38 <shapr> My major problem with Zope is that the statefulness is huge. Can I write a Haskell webapp framework without a ZODB equivalent?
14:47:53 * RemiTurk has zero experience with Oz, Erlang
14:47:59 <KrispyKringle> shapr: WASH is a bit of a pain in the ass.
14:48:02 <KrispyKringle> imo.
14:48:19 <KrispyKringle>  it's the best I've seen--out of, what, two competitors?--but the types get to be REALLY overbearing.
14:48:26 <KrispyKringle>  you end up fighting with the typechecker half the time.
14:48:29 <poetix> shapr: You need some way to load modules dynamically, for starters
14:48:30 <shapr> Concurrent has lightweight threads, they're fast. You can also get a pool of OS threads that can run a waiting coroutine.
14:48:45 <poetix> shapr: mmm, coroutines
14:48:46 <shapr> poetix: That exists, dons' hs-plugins is great.
14:49:01 <shapr> KrispyKringle: I've used WASH for a few projects, and I agree.
14:49:45 <shapr> andrew cooke made a zope page templates clone called Halipeto, and lemmih extendend that into Hemplate.
14:50:06 <poetix> shapr: I don't think that stateful objects as handlers is a good way to go. Better to decouple persistance from application logic anyhow. So no ZODB, but a dynamic handler lookup and a neato DB API
14:50:18 <beschmi> do you think it would be hard to modify WASH to use something like fastcgi or mod_lisp?
14:50:36 <shapr> I think there's a way to get a type-safe version of Halipeto/Hemplate, but I haven't had the tuits to try it out.
14:51:37 <shapr> poetix: problem is, my brain has been polluted with years of Zope work. I can't visualize what you're describing. Can you give more detail?
14:52:57 <poetix> shapr: Zope persists objects as handlers, coupling state and logic. I think a handler is just a function - HttpRequest -> HttpContext -> IO HttpResponse - and state should go somewhere else
14:54:33 * shapr thinks about that
14:55:02 <shapr> Oh, I think I get it!
14:55:31 <poetix> Scales better...(asserted without any evidence whatsoever)
14:55:40 <shapr> The ZODB allows code to pretend that Zope is an application that never shuts down. Haskell code just doesn't care.
14:56:21 <poetix> We Can Remember It For You Wholesale
14:56:27 * shapr snickers
14:57:16 <shapr> It's strange to think of a webapp with as little state as possible.
14:57:43 <poetix> I wrote a webserver in C# recently (dayjob), and it's pretty close to stateless - it builds a tree of handlers that resolve URLs, but all the state is in the DB.
14:58:19 <poetix> (although there are some temporary resources in memory or on the filesystem, now I think about it)
14:58:38 <shapr> The minimum amount of state would be just the client request.
14:58:53 <shapr> As you said, only handlers.
14:58:55 <poetix> it's the RESTful way...
14:59:18 <poetix> Put on your Roundhead helmet and march with me, brother...
14:59:30 <TFK> http://en.wikibooks.org/wiki/Programming:Haskell <--- join the effort!
14:59:33 * shapr is too restful to march
14:59:42 * shapr grins
14:59:55 * poetix salutes, laconically
15:00:29 <shapr> poetix: By the way, where are you from?
15:00:45 <shapr> I guess given the choice between C# and Python for my day job, I'm happier with Zope/Plone.
15:01:10 <poetix> shapr: Where I'm at is Northampton, UK. Where I'm from is Ross-on-Wye, Herefordshire, UK
15:01:26 <poetix> C# is bearable, but I prefer Python
15:01:44 <Maddas> TFK: Did you write part of that?
15:02:00 <shapr> I have only a vague idea of UK geography, I've never visited that area. I'm originally from Alabama, but I liven in Sweden.
15:02:03 <TFK> I was going to, until I realized that I ought to be sleeping.
15:02:46 <Maddas> I wonder whether referring to the PLEAC examples to learn is helpful
15:02:59 <shapr> There's also CosmicRay's haskell-v8
15:03:05 <shapr> and YAHT
15:03:09 <TFK> There isn't much to read that, anyway.
15:03:17 <TFK> YAHT is a ~300 page PDF mamoth.
15:03:18 <poetix> Time I vacated the computer so my spouse can browse (we're still a one-computer household...)
15:03:23 <Maddas> TFK: No, but what is there seems rather confusing :-)
15:03:25 <Maddas> (er, I meant PLEAC)
15:03:34 <shapr> poetix: How would you build dynamic websites with such a pure system?
15:03:43 <shapr> poetix: nice meeting you!
15:03:47 <TFK> And since it requires registration, google probably can't reach it and thus didn't convert it. I ought to try, though.
15:03:58 <poetix> shapr: put the dynamic bits in the DB...
15:04:02 <poetix> cya all
15:04:08 * TFK googles pleac
15:04:11 <shapr> I'll have to think about that.
15:04:19 <shapr> Is it really that easy?
15:04:29 <shapr> anyway, I should go do more work.
15:04:31 * shapr &
15:04:32 <poetix> shapr: probably not. I'll have to think about it too.
15:04:42 <TFK> http://64.233.183.104/search?q=cache:EwUca2jqRC4J:www.isi.edu/~hdaume/htut/tutorial.pdf+%22yet+another+haskell+tutorial%22&hl=en&client=firefox-a <--- am wrong, google rocks.
15:04:44 <Maddas> And I should just go to bed. Night :-)
15:04:58 <TFK> g'night!
15:05:22 <Itkovian> night
15:05:23 <RemiTurk> night
15:06:07 <TFK> The html conversion only goes up to page 75 or so :-/
15:07:17 <TFK> pleac calls Python lists array? O_o
15:09:27 <Maddas> TFK: What bothers me is that the examples redefine standard (Prelude) functions for no good reason, I'd consider that quite confusing as a newbie since the redefined versions are hidden in the "Helpers" section
15:10:22 <TFK> What bothers me is that it makes little sense, it's like throwing all this syntax on a newbie without explaining anything.
15:12:15 <TFK> I had no idea you could do s.unpack, s.match where s is a string (isn't . the function composition operator anyway?)
15:13:22 <monochrom> I feel I am in #ocaml rather than #haskell :)
15:14:01 <TFK> O'Caml beginners are also complaining all the time? ;-)
15:14:44 <monochrom> No, don't worry.  I am referring to s.unpack, s.match.
15:14:59 <TFK> Are those really valid?
15:15:24 <monochrom> If you re-define (.).  x . f = f x
15:15:48 <monochrom> some people do it to appeal to oop morons.
15:15:57 <monochrom> oop morons think everything is o.m
15:16:15 <TFK> Unless they code in Smalltalk :3
15:17:12 <TFK> Ah, so the examples in PLEAC (http://pleac.sourceforge.net/pleac_haskell/strings.html) redefined . ?...
15:17:14 <monochrom> some oop moron actually told me he prefers a.add(b.add(c)) to a+b+c.
15:17:18 <ddarius> The Haskell PLEAC is crack-headed.
15:17:30 <TFK> That's what I was thinking, too ;-)
15:17:37 <TFK> monochrom, must be a Java guy :-/
15:17:45 <monochrom> yes absolutely
15:18:04 <monochrom> it is hard these days to distinguish between education and brainwashing.
15:18:10 <TFK> Java doesn't have operator overloading, so they don't really have a choice ;-)
15:19:04 <TFK> So anyway guys, contribute to Programming:Haskell on Wikibooks if you can :-)
15:19:24 * RemiTurk thinks he's probably too young to be awake at this time, reading all this nasty OOPstuff
15:20:08 <RemiTurk> goodnight
15:20:22 <TFK> night
15:22:12 <TNKS> hi all, how do you increase the stack size in GHCi?
15:22:40 <TFK> Well, I guess I'll call it a night as well. Good night people.
15:23:34 <ddarius> TNKS: The context reduction stack or the actual run-time stack?  If the latter, it's extremely unlikely you want to do that and instead need to fix your code.
15:28:32 <basti_> making Yi:
15:28:33 <basti_> CWString.hsc:69:0:
15:28:33 <basti_>     Warning: Module `GHC.Exts' is imported, but nothing from it is used
15:28:33 <basti_>              (except perhaps instances visible in `GHC.Exts')
15:28:59 <putter> is there a way to portably (ie, on windows as well) determine the size of a file?  (ghc6.4)
15:29:03 <basti_> commented out "import GHC.Exts" in said line, compiles fine, result unknown
15:29:22 <Lemmih> putter: Open it and use hFileSize.
15:30:27 <basti_> yi works.
15:30:31 <basti_> and it IS like vi.
15:31:19 <Maddas> TFK: (.) is redefined under "Helpers"
15:31:20 <putter> Lemmih: thanks.  but nothing which doesnt require opening it?
15:31:33 <Maddas> TFK: Now you know why I find it confusing; I think it shouldn't be linked to from Wikibooks
15:31:41 <Maddas> But I also don't think I have any authority to change that :-P
15:33:27 <Lemmih> putter: Not to my knowledge.
15:33:34 <putter> My thanks.
15:35:21 <Maddas> monochrom: The comment there says "object notation for object fan, use it if function have more than one parameter or if you want make an "oo-line" (ex o.words.reverse.unwords)". ($) and (!!) and many other things are also redefined.
15:35:40 <Maddas> basti_: Did you try the nano or other frontends?
15:35:51 <basti_> Maddas: not yet.
15:35:55 <basti_> Maddas: how would i?
15:36:19 <monochrom> object fans have a perverted world view.
15:36:45 <Maddas> Many people do.
15:36:50 * basti_ makes the doc
15:37:01 <Maddas> basti_: I think it's documented somewhere in... yeah :-)
15:37:10 * Maddas really goes to bed.
15:37:12 <basti_> =)
15:37:15 <basti_> 'night
15:37:25 <Maddas> Morning, technically ;-)
15:43:12 <basti_>         Bad interface file: /usr/local/lib/yi/imports/Yi/Yi.hi
15:43:12 <basti_>             mismatched interface file versions: expected 6021, found 6030
15:43:18 * basti_ shrug
15:43:51 <monochrom> clean rebuild!  clean rebuild!
15:44:07 <basti_> hmm
15:46:10 <basti_> didnt help
15:46:18 <musasabi> basti_: that means that the .hi was produced by ghc 6.3 (cvs?) and you tried to compile with 6.2.1
15:46:22 <basti_> "make clean" "make" "make install"
15:46:27 <basti_> ahhhhh.
15:59:09 <basti_> yup, after regetting i could cut away the .hi's (except for some .hi-boot, which cant be regenerated?) and now I'm rebuilding
16:00:00 <basti_> didnt help though :/
16:01:00 <basti_> hmm
16:01:03 <basti_> im going to bed
16:04:56 <multi_io> hmm, is there a function that maps a two-arg function to a function with those args reversed?
16:06:50 <gzl> multi_io: flip?
16:06:52 <multi_io> I mean to *that* function, just with reversedarguments
16:06:59 <multi_io> gzi: ah
16:07:54 <multi_io> gzi: thanks
16:07:56 <gzl> np
16:10:21 <multi_io> gzl, actually. Sorry :)
16:10:43 <gzl> np. :)
16:15:44 <metaperl_> is there a HTML slide generation program written in Haskell?
16:16:05 <gzl> not that I know of. check haskell.org
16:28:09 <Lemmih> SyntaxNinja: Are you going to spend time on Hackage or Cabal?
16:28:54 <SyntaxNinja> Lemmih: idono.
16:29:09 <SyntaxNinja> Lemmih: I want hackage to move faster, so I should probably spend time on that, but there is a lot I want to do w/ cabal
16:30:48 <Igloo> It might be better to concentrate on hackage given everything's just shipped a cabal 0.7
16:33:01 <SyntaxNinja> everything?
16:33:04 <SyntaxNinja> what's cabal 0.7?
16:33:16 <Igloo> Am I confused?
16:33:22 <Igloo> everything = hugs, nhc98, ghc6
16:33:52 <SyntaxNinja> oh. yeah, the version numbers are fscked up :( 'everything' shipped 1.0, but they should have shipped 0.6, if I recall
16:33:57 <SyntaxNinja> so now we're stuck and cabal is 1.0
16:34:05 <SyntaxNinja> no big deal, though.
16:34:23 <SyntaxNinja> aaaanyway, yeah, I should probably concentrate on hackage; it's hard to resist working on cabal, though when I have a TODO list of low-hanging fruit
16:35:01 * Lemmih starts hacking on Hackage.
16:35:04 <Igloo> :-)
16:35:07 * Igloo sleeps
16:35:58 <Lemmih> The HTML interface will have to wait for awhile, though.
16:39:49 <Lemmih> SyntaxNinja: Would it be desirable to add new packages via the XML-RPC interface? Maybe in conjunction with a 'hackage-ize' command in the Setup script?
16:43:06 <SyntaxNinja> i'm not sure that we should add hackage commands directly to cabal
16:43:45 <SyntaxNinja> I don't think adding new packages via xml-rpc is a high-priority thing, since we can use a put; if it's easy, though I say go for it
16:43:55 <SyntaxNinja> is uploading tgzs done yet? in the HTML interface?
16:43:59 <SyntaxNinja> what's wrong w/ html interface, btw?
16:44:22 <Lemmih> Boring to hack (:
16:44:32 <SyntaxNinja> heh
16:45:39 <Lemmih> And yes, uploading tgzs is working.
16:46:49 <SyntaxNinja> can yo uget shapr to push the latest version, or is there no interface yet?
16:46:53 <SyntaxNinja> push to the web server, I mean.
16:47:45 <Lemmih> There is. But downloading the tgzs from the server is not done yet.
16:48:18 <Lemmih> shapr: Can I put cgi stuff in scannedinavian.org/~lemmih/cgi-bin/ ?
16:51:35 <Lemmih> SyntaxNinja: http://212.242.49.100/cgi-bin/hackage/hackage <- hackage on my work PC.
16:52:40 <SyntaxNinja> cool
16:52:58 <SyntaxNinja> so the only problem is that after uploading the tarballs, it doesn't know the tarball url to report for download/
16:55:09 <Lemmih> I'm currently placing packages in the packages/ subdir which is bad because Apache thinks it's a cgi script.
16:56:08 <SyntaxNinja> and so tries to execute it on a get or something?
16:56:28 <Lemmih> Yep.
16:58:35 <shapr> Lemmih: I think so
16:58:54 <shapr> If not, I'll see what I can do.
17:09:30 * shapr swears fiercely at emacs
17:10:22 <heatsink> I have error-checking code of the form (if x then error "Message" else ()).  How do I run a list of these, and ensure that they are actually evaluated?
17:10:31 <Pseudonym> Use yi.  It swears back.
17:10:55 * heatsink is waiting for synhl and autoindent in yi
17:11:28 <shapr> I would really like to use WebDAV to edit stuff in Zope, but eldav gives unexplainable errors. Reading the source and doing debugging gives no information.
17:11:42 <TheHunter> heatsink, you might use `seq`.
17:12:06 <Lemmih> I should be able to run 'runghc Setup.lhs install --user' without being root, right?
17:12:17 <heatsink> TheHunter: thx.
17:12:57 <TheHunter> there's also Control.Exception.assert.
17:13:18 * SamB feels the urge to paste an entire darcs repo
17:14:11 <SyntaxNinja> Lemmih: as long as the configure location is OK
17:14:50 <SamB> How can I get a repo where you guys can comfortably get code from it, keeping in mind that I'm on dialup?
17:16:10 <shapr> do you have a public ip?
17:16:29 <SamB> shapr: well, yes
17:16:38 <shapr> You can also upload it to a website somewhere and we can grab via http
17:16:58 <shapr> It's easier to update if you have darcs on the server.
17:17:28 <SamB> I don't happen to own any servers...
17:18:31 * heatsink imagines another programmer's confusion about my code :3 runTests :: [()] -> ()
17:20:07 <shapr> SamB: If it's nifty Haskell code, you can ask me to host a darcs repo on my server.
17:20:09 <Heffalump> @seen CosmicRay
17:20:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- CosmicRay is in #haskell. Last spoke 4 hours 25 minutes 54 seconds ago.
17:20:25 <Heffalump> lambdabot and my client disagree.
17:20:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:20:28 <TheHunter> that feels awfully wrong. You could make your tests in a monad or use HUnit.
17:20:30 <SamB> shapr: does it have to work to be nifty?
17:20:49 <shapr> I don't know. Tell me about it.
17:21:22 <SamB> Well, its a parser which currently parses a very small subset of Self
17:21:38 <shapr> interesting
17:21:57 <shapr> Can I see the code?
17:22:26 * SamB plays with webserver
17:22:35 * Heffalump is confused by the behaviour of the Debian BTS. Anyone understand it?
17:22:48 <Heffalump> (it's about a Haskell package, just to keep things mildly on topic)
17:23:10 <TheHunter> @seen TNKS
17:23:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TNKS is in #haskell. Last spoke 2 hours 58 seconds ago.
17:23:26 <Heffalump> @seen my arse
17:23:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen my
17:23:33 <Heffalump> boring.
17:24:05 <SyntaxNinja> Heffalump: what behavior?
17:24:27 <TheHunter> @seen TheHunter_
17:24:27 -thbot(~thbot@p54AB0B5A.dip0.t-ipconnect.de)- I saw TheHunter_ leaving #haskell 4 seconds ago.
17:24:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter_ is in #haskell. I don't know when TheHunter_ last spoke.
17:24:53 <beschmi> darcs should be pretty useable with some free webspace with ftp access, you can use something like lftp mirror to push your changes
17:25:25 <TheHunter> ok, that was also due to dynamics not working properly.
17:26:03 <SamB> http://ts001d0662.wdc-dc.xod.concentric.net:8080/hSelf/base/ should work until I change IP addresses
17:26:32 <cevans> I am trying to build HTTP, and when doing ./setup configure it can't find Setup.description. Does anyone have this file?
17:26:37 <Heffalump> SyntaxNinja: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=303073
17:26:49 <Heffalump> why did it email unknown-package@qa.debian.org instead of me?
17:26:58 <shapr> SamB: alternatively, you could use dyndns, and then your repo would be available when you're online.
17:28:04 <SamB> hmm, there are a lot of junk file in that repo...
17:28:33 <shapr> Are you sure that's chmod ugo+r ?
17:29:38 <shapr> oh, I think I have an extra slash
17:29:48 <shapr> yes, that's it.
17:30:12 <SamB> shapr: the webserver is running under my uid anyway
17:30:53 <SamB> the trouble I'm having is with how Self.Parse.bTest1 and Self.Parse.bTest2 come out...
17:30:54 <SyntaxNinja> can I tell you what's wrong with the package instead? ;)
17:31:19 <Heffalump> I know what's wrong with the package.
17:31:34 <Heffalump> It spent 3 months sitting in incoming before it went into the archive, so naturally it's out of date.
17:31:48 <Heffalump> So now it doesn't build against latest Cabal and has a pissed off maintainer.
17:32:17 * SyntaxNinja nods
17:32:21 <Heffalump> And said pissed off maintainer also wants to know why the BTS doesn't think that emailing him about reported bugs might be a good idea.
17:32:24 <SyntaxNinja> no idea why it wasn't sent to you.
17:32:33 <SyntaxNinja> http://packages.qa.debian.org/h/haskell-http.html
17:32:35 <SyntaxNinja> that looks fine
17:33:01 <shapr> SamB: what about them?
17:33:44 * shapr stabs emacs with a sphere
17:34:16 <metaperl> shapr, what do you think of freepan.org?
17:34:21 <metaperl> as a haskell repository
17:34:29 <SamB> they are supposed
17:34:30 <metaperl> it is svn-based, but ingy is serious about buildling it
17:34:51 <SyntaxNinja> Heffalump: did you ask on #debian-devel?
17:34:52 <SamB> whoops, I was trying to delete that... anyay
17:35:11 <SamB> I wanted something more like ESend (EDirectedResend "foo") "*" [ESend ESelf "a" []]
17:35:18 <SyntaxNinja> heffalump: you might not want to point out how pissed off you are, that will tend to get you ignored or flamed :)
17:35:53 <shapr> metaperl: reading
17:36:42 <shapr> metaperl: not much detail on the site.
17:36:44 <metaperl> they exist in #freepan here on freenode
17:36:52 <aheller> so, do all the cool kids use ghc?
17:37:03 <metaperl> aheller, I love ghc
17:37:08 <SamB> I might be doing something incredibly stupid, or maybe jecel just wrote it wrong, who knows (he did say that his grammar was untested...)
17:37:11 <metaperl> ghci for interpretive development
17:37:17 <SyntaxNinja> aheller: for "serious" work, ghc is the choice
17:37:23 <SyntaxNinja> depending on your definition of serious
17:37:38 <SyntaxNinja> hugs is useful, portable, and convinient.
17:37:46 <aheller> metaperl: see, hugs came up first in whatever I was looking to learn haskell in, so I started with that, because it came up first.
17:37:56 * SamB tries apt-getting hugs to see if the current version actually works
17:38:23 <SamB> aheller: I think most people start with hugs
17:38:30 <SyntaxNinja> SamB: why the heck wouldn't it?
17:38:44 <dons> TheHunter: lots of tasty patches, thanks!
17:38:46 <SyntaxNinja> the hugs maintainer rulz
17:38:48 <aheller> But it lacks the word "Glasgow" for starters...
17:39:13 <dons> hugs is pretty cool though. For one, it is really portable.
17:39:20 <dons> and it implements the ffi.
17:39:32 <aheller> cool.
17:39:46 <aheller> so now I need to see if it will build on my osx box.
17:39:59 <dons> yeah, for sure it does.
17:40:10 <dons> it _just builds_ on anything as far as I've seen.
17:40:24 <aheller> hugs built after only a little pain... I meant ghc.
17:40:33 <dons> at least 6 archs. not the vax though. not sure what's happening there.
17:40:45 <SamB> well the one I have now (or some version I once had, maybe...) gets confused and can't really find any modules after some incredibly simple set of actions that I kept doing
17:40:48 <dons> oh. ghc... that's more difficult, but more satisfying.
17:41:13 <SyntaxNinja> heh
17:41:36 <aheller> see?  all the cool kids like ghc.
17:41:58 <aheller> But then again, someone bulit a binary... and after watching ghc build on gentoo once, I might chicken out.
17:42:09 <aheller> no scheme pun intended.
17:42:11 <dons> blackdog!
17:42:18 <blackdog> dons!
17:42:43 <dons> @version
17:42:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p124, GHC 6.4 (OpenBSD i386)
17:42:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:42:47 <dons> blackdog: ;)
17:43:06 <dons> don't tell chak ;)
17:44:08 <blackdog> you've been hacking lambdabot? You know these logs go up on the net, right? :)
17:44:19 <dons> yeah, I know hehe.
17:44:47 <dons> @plugs map (+1) [1..10]
17:44:53 <blackdog> so what tricks is it doing now?
17:44:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [2,3,4,5,6,7,8,9,10,11]
17:45:17 <dons> @help plugs
17:45:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @plugs <expr>
17:45:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have Haskell, 3 seconds and no IO. Go nuts!
17:45:17 <blackdog> all nicely sandboxed?
17:45:17 <dons> @pl \x -> x . x
17:45:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s (.) id
17:45:17 <blackdog> of course. shouldn't have asked. :)
17:45:20 <jlouis> blackdog: no IO
17:45:28 <dons> yeah. secure by default :)
17:45:35 <blackdog> sounds like a challenge.
17:45:46 <dons> please hack away.
17:45:57 <wagle> @plugs let x = x in x
17:45:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Ambiguous type variable `a' in the top-level constraint:
17:45:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at <Plugins.Eval>:1
17:46:04 <jlouis> dons: My subconsiousncess is playing around with some module generalisations in a ModuleUtility package
17:46:18 <heatsink> I don't understand:  why is (\x -> x `seq` return ()) >> anything strict in x?
17:46:25 <jlouis> It needs a couple of days to mature. Then I am going to fire away
17:46:33 <blackdog> yi is languishing, then?\
17:46:37 <dons> ok. cool.
17:46:45 <dons> blackdog, well, got yi-0.1.0 out last week.
17:46:51 <dons> and the syn hl is in, not finished though
17:47:01 <wagle> ambig type var a?
17:47:03 <dons> I'm trying to get yi into a paper for this year's HW.
17:47:06 <blackdog> ooh, 21 patches. i retract that question.
17:47:10 <jlouis> heatsink: it evaluates x, throws it away and returns IO ()
17:47:13 <dons> wagle: there's a Show constraint on the value.
17:47:15 <heatsink> wagle: It can't figure out what type a is, so it can't show a.
17:47:28 <dons> @plugs let x = x  in x :: ()
17:47:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: <<loop>>
17:47:33 <wagle> @plugs let x = x in x :: Integer
17:47:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: <<loop>>
17:47:55 <dons> lambdabot survives a blackhole!
17:47:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:47:56 <wagle> @plugs let x =  x+ 1 in x :: Integer
17:47:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: <<loop>>
17:48:30 <dons> @plugs let f () = f () in f () :: ()
17:48:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
17:48:35 <wagle> was trying to blow the stack
17:48:43 <dons> no problem.
17:48:43 <blackdog> dons: what external modules can it load?
17:48:53 <dons> @plugs scanr (*) 1 [1..]
17:48:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Stack overflow
17:48:58 <jlouis> @plugs let x = 1 : x in x
17:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:49:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [22 @more lines]
17:49:10 <jlouis> hehe
17:49:11 <heatsink> @plugs let f () = case f () of _ -> ()
17:49:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `)'
17:49:17 <dons> blackdog, safe parts of Data.*, Prelude, Control.{Monad,Arrow}.
17:49:29 <heatsink> @plugs let f () = case f () of _ -> () in f ()
17:49:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ()
17:49:32 <SamB> @plugs let x = 1 : x in sum x
17:49:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
17:49:58 <wagle> @plugs 1 + 1
17:49:59 <heatsink> hmm, case gets optimized away.
17:49:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 2
17:50:11 <SamB> @plugs sum [1..]
17:50:12 <heatsink> wagle: that won't stress lambdabot, silly
17:50:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Terminated
17:50:30 <wagle> existance proof
17:50:41 <heatsink> ?
17:50:53 <wagle> "see it can do possible things!"
17:50:54 <dons> proof of lambdabot's continued existence
17:51:05 <dons> hehe
17:51:17 <Heffalump> SyntaxNinja: actually, I guess I'm more apathetic than pissed off.
17:51:42 <Heffalump> If it takes three months to accept the package into the archive, I'll allow myself 3 months to fix the bug ;-)
17:52:08 <dons> @plugs ((error "throw me") :: ())
17:52:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: throw me
17:52:37 <Heffalump> @plugs (Just $ error "throw me") :: Just ()
17:52:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Type constructor or class not in scope: `Just'
17:52:48 <Heffalump> @plugs (Data.Maybe.Just $ error "throw me") :: Just ()
17:52:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Type constructor or class not in scope: `Just'
17:52:55 <wagle> Maybe
17:53:05 <Heffalump> duh
17:53:09 <Heffalump> @plugs (Just $ error "throw me") :: Maybe ()
17:53:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: throw me
17:53:12 <Heffalump> ta :-)
17:53:30 <wagle> i caught it because i keep trying to do the same thing..  8)
17:53:39 <Heffalump> dons: you're forcing evaluation at the right point, then? :_0
17:53:42 <Heffalump> s/_0/-)
17:54:15 <jlouis> dons: I just mailed some minor nitpicks to ya. More coming in a couple of days possibly
17:54:23 <dons> I'm not forcing anything. you get: resource = let v = show (your expr) in v
17:54:49 <Heffalump> and what does it do with resource?
17:55:18 <Heffalump> oh, I see.
17:55:25 <Heffalump> You can catch exceptions around resource.
17:55:28 <dons>                 s <- unsafeEval ("(take 2048 (show ("++s++")))") context
17:55:28 <dons>                 when (isJust s) (putStrLn (fromJust s))
17:55:49 <SyntaxNinja> Heffalump: punish your users for the failings of the ftp masters?
17:56:56 <dons> hmm. lambdabot seems to have lost some weight: 27158 lambdabo   2    0 4080K 4756K
17:57:01 <blackdog> SyntaxNinja: yea, down unto the seventh generation
17:57:06 <Heffalump> I'll worry about that when I get some users ;-)
17:57:11 * blackdog mangles quote badly
17:57:18 <Heffalump> (but no, I'll fix it, I'm just not going to give it any priority right now)
17:58:08 <SyntaxNinja> Heffalump: you can't get any users if it don't build ;)
17:58:42 <Heffalump> can't they get the binary on i386?
17:58:49 <blackdog> dons: ":wq" in the vim binding for yi ought to grumble if you haven't set a filename, right?
17:58:53 <SyntaxNinja> it's an easy fix, just do it and make an upload; now that it's accepted, the round-trip time will be faster
17:59:32 <Heffalump> I can't upload, I'm not a DD
17:59:43 <dons> blackdog, yeah.  I think so. please send a patch.
17:59:45 <SyntaxNinja> you know what I mean :)
17:59:58 <Heffalump> and I know it's easy to fix, but it's hassle remembering how the package works and stuff
18:00:08 <Heffalump> and finding where I kept my latest version etc.
18:00:20 <Heffalump> feel free to NMU if you feel strongly :-)
18:00:41 <Heffalump> otherwise I'll do it this weekend if I have time, and in three weeks if I don't, cos I'm going on holiday inbetween
18:01:06 <SyntaxNinja> apt-get source ... cd foo .. mv foo.description foo.cabal.. email your sponsor
18:01:17 <SyntaxNinja> OK
18:01:43 <Heffalump> I have to check I've upgraded cabal on whatever machine I build it on, and build it, too...
18:02:07 <SyntaxNinja> true
18:02:52 <Heffalump> and upgrade the cabal build-dep
18:03:12 <Heffalump> and think about all the other things I might need to check too :-)
18:04:17 <shapr> SamB: hSelf is a cool project, want me to mirror it?
18:04:32 <SamB> shapr: um, sure
18:04:49 <SamB> how would that work?
18:05:33 <Heffalump> what is it?
18:05:55 <shapr> You can use dyndns and I can cron a regular pull, or I can create an email accessible repo an you can send me a public gpg key so you can send signed patches.
18:07:02 <SamB> hmm, where would I get a dyndns name?
18:07:11 <shapr> dyndns.org?
18:07:15 <shapr> or other places.
18:07:37 <wagle> inquriing minds need to know what hSelf is..  8)
18:09:36 * wagle tries to fall on top of shapr as he dies dramatically of curiousity
18:09:38 <SamB> hSelf currently contains a parser for a very small subset of Self; I hope to get it into a state where it can compile and possibly run real Self code some day...
18:10:07 <wagle> ah..  i was hoping it was related to Self
18:10:40 <dons> ghc patch of the day: "get the SMP mode at least building"
18:10:56 <shapr> !!!
18:10:58 * shapr panics
18:11:04 <SyntaxNinja> don't panic!!
18:11:06 <Heffalump> dons: ooooh!
18:11:26 <wagle> find your towel
18:11:34 <shapr> I have two cpus! They're cold in this wintry land. They need to burn up some wattage!
18:11:43 <dons> all under the heading "multi-processor hackery"
18:11:49 * Heffalump wonders if SMTP support will make proper pre-emptive multitasking feasible too
18:11:51 <shapr> much happiness.
18:11:57 <Heffalump> s/T//
18:12:17 <shapr> STM?
18:12:54 * wagle hunts for STM
18:13:24 <Heffalump> I mean SMP.
18:13:47 <shapr> Yeah, but... I think the SMP support is just STM, right?
18:14:51 <Heffalump> isn't that a higher level concurrency abstraction than the low-level support you'd need to use SMP?
18:15:10 <Heffalump> s/than/rather than/
18:15:31 <Heffalump> ICBW.
18:18:37 <blackdog> dons: bit tricky - you set a random filename in /tmp/yi.$ at the beginning. I can't see a good way of determining if a real filename has been used yet - there isn't anything in Buffer.hs to suggest it. D'you ken me?
18:19:05 <shapr> Martin Sjgren wrote mkTempFile, didn't he?
18:19:58 <blackdog> shapr: not sure how that helps... i can always do a regex match against /tmp/yi.*, but that's majorly nasty
18:20:19 <shapr> Oh, I don't know the problem.
18:20:20 <dons> shapr: I wrote a portable .hs implementation of mktemp,mkstemp,mkstemps,mkdtemp for hs-plugins that's used in yi.
18:20:24 <shapr> oh, cool
18:21:16 <dons> blackdog: sounds like we need a flag.  I'll put it on the list. Either FilePath FilePath perhaps
18:21:43 <blackdog> dons: is don. is good.
18:23:50 <dons> TheHunter, great patches. thanks. >1000 lines! :)
18:30:22 <SamB> shapr: would polling just involve checking the inventory, if nothing had changed?
18:30:48 <shapr> yup
18:34:48 <Cale> someone should redo the Haskell PLEAC sanely
18:35:04 <metaperl> Ok Cale, I nominate you
18:35:15 <Cale> I would if I didn't have exams
18:35:18 <metaperl> Cale, Cale he's our man. If he can't do it. Nobody can
18:35:30 <metaperl> we will wait until exams finish.... :)
18:35:46 <metaperl> probably you can do them as a break from studying
18:35:50 <metaperl> instead of so much IRC
18:35:55 <Cale> yeah
18:37:18 <metaperl> you could probably have problem #1 done by now...
18:37:24 * metaperl taps his foot impatiently
18:37:30 <Cale> hehe
18:38:32 <SamB> so which client should I use for dyndns?
18:41:08 * SamB tries ddclient
18:43:46 <gzl> what OS?
18:43:51 <SamB> Debian
18:43:54 <gzl> ah, i dunno.
18:48:33 <arjanoosting> SamB: ez-ipupdate
18:49:02 <SamB> I'll try that if ddclient gives me grief
18:49:18 <SamB> its next in the alphabet anyway
18:54:44 <metaperl> in GHC, where in the libraries are the functions for testing character case and up-casing characters located?
18:55:55 <stepcut> Data.Char.toUpper ?
18:57:56 * metaperl looks for Data.Char
18:58:17 <metaperl> yes thanks
18:59:30 <metaperl> CosmicRay , hi
18:59:32 <metaperl> question
18:59:52 <CosmicRay> hi metaperl
18:59:59 <metaperl> during my 6-8 hours as a fedora user, the people on #fedora said one reason not to use Debian was that it had not had a stable release in 2 years
19:00:35 <CosmicRay> that is a fact, though whether or not it is a reason not to use Debian is not that clear
19:00:59 <metaperl> looks like the last update was 1/14/2005... that's fairly recent
19:01:03 <CosmicRay> clearly it is our chief weakness, and also in the eyes of some, a strength (though overdone perhaps)
19:01:13 <CosmicRay> updates to stable debian are extremely conservative
19:01:27 <CosmicRay> generally critical bugfixes only: security fixes or things that could cause data loss
19:01:48 <CosmicRay> occasionally a less severe bugfix, if the change is minor and has been tested thoroughly
19:02:01 <CosmicRay> almost never are new features introduced into stable
19:02:15 <CosmicRay> whe we say stable, we mean fossilized :-)
19:02:27 <CosmicRay> so, iow, stable is excellent to run on a server
19:02:43 <CosmicRay> not so great for a desktop workstation, since it may not support some of the more recent hardware
19:03:08 <CosmicRay> however I have generally found testing to be about as stable as the most linux distros, and more stable than gentoo
19:03:26 <CosmicRay> even our unstable is usually more stable than gentoo :-)
19:03:29 <metaperl> i see
19:03:32 <CosmicRay> testing is pretty much current
19:03:45 <metaperl> yeah, we use testing on hcoop.net
19:03:51 <CosmicRay> you can get ISOs for it and stuff, we are finally, and We Mean It This Time, nearing a release :-)
19:04:31 <metaperl> debian binaries are compiled for 386 instead of the server's architecture ,correct?
19:04:47 <CosmicRay> debian binaries are compiled for every debian architecture
19:05:21 <CosmicRay> as an example, check out http://ftp.debian.org/debian/pool/main/h/hugs98/
19:05:39 <CosmicRay> or http://packages.debian.org/hugs
19:06:06 <metaperl> what I meant is that 386 is not always the fastest binary for intels running debian
19:06:13 <CosmicRay> ah.
19:06:15 <metaperl> but 386 is the only intel binary for debian
19:06:27 <CosmicRay> i386 is a little misleading.
19:06:45 <CosmicRay> it is our architecture name, as gentoo uses x86
19:07:05 <CosmicRay> most packages are compiled with at minimum 486 optimizations, and many with pentium or better optimizations
19:07:32 <CosmicRay> many apps that are performance-critical have .so's for each subarch with specific optimizations, and they are selected at runtime
19:07:45 <metaperl> I see
19:07:51 <CosmicRay> we do not really support a genuine 386 anymore
19:08:15 <CosmicRay> it is probably possible to use one, we even have a "486 emulation" kernel patch out there for that
19:08:23 <CosmicRay> but I suspect it is not really tested
19:08:29 <CosmicRay> newer x86 hardware is so cheap.
19:08:49 <CosmicRay> now, having said that, it is true that our packages don't have the aggressive system-specific optimizations that one could tickle out of, say, gentoo
19:09:07 <CosmicRay> however, it hasn't ever really been shown that we're that much worse than gentoo in terms of performance
19:09:52 <CosmicRay> it is still possible to install debian packages from source quite trivially, and there are tools out there for the overclocker crowd that help automate the building of debian packages with very specific optimization settings
19:09:56 <metaperl> "tickle" --- I like that term
19:10:05 <CosmicRay> you just won't find binaries out there pre-built with those settings
19:10:26 <metaperl> I see
19:11:37 <CosmicRay> hrmmph.  people.debian.org is still down with its dud disk I guess.  I was going to point you at my Debian installer, DFS
19:11:59 <CosmicRay> http://www.nl.debian.org/devel/debian-installer/ has installation ISOs for testing
19:12:22 <CosmicRay> usually what you would need is the netinst image
19:12:33 <CosmicRay> it will install a base system, enough to install the remaining part over the network
19:13:17 <CosmicRay> you could always download all 14 ISOs for a every-deb-under-the-sun set :-)
19:19:33 <CosmicRay> so anyway, debian is not perfect, and isn't the best for everyone.  it's almost certainly not the best for the "just work, dammit, I don't care how" crowd, or the overclocker/script kiddie crowd :-)
19:19:50 <CosmicRay> I think it is great for the professional sysadmin or serious developer though
19:20:51 <metaperl> Debian is very adaptable. Even to those crowds.
19:21:45 <CosmicRay> it is just so versatile... a lot of the "plug in and go" distros focus on one desktop environment, one mail server, etc.  you can probably use others if you wish, but they won't necessarily play nice with the config system or work through upgrades, etc
19:22:19 <CosmicRay> yes, that is true, though it is not as easy to get a basic desktop going as, say, ubuntu or mandrake; and not as easy to use custom compilations as gentoo
19:22:30 <TheHunter> dons, glad you liked it. I hope I didn't break anything.
19:23:07 <CosmicRay> otoh, you can install and run it a million different ways... in a chroot under a different distro, via a "convert this RPM machine to Debian without having console access" script, from a live CD, etc.
19:23:32 <CosmicRay> and apt/dpkg aren't pretty but they are rock-solid and fast.
19:32:50 <Lemmih> Funny HOpenGL code: http://www.scannedinavian.org/~lemmih/Collision.hs
19:33:36 <cm> hello there
19:33:44 <CosmicRay> hi cm
19:33:57 <cm> hey mr. ray :]
19:34:05 <CosmicRay> new to haskell?
19:34:44 <cm> not really, although dons would disagree ;)
19:34:52 <CosmicRay> heh
19:35:09 <CosmicRay> well then, I'll stop offering to help, and settle for "hiya" :-)
19:35:21 <cm> :D
19:52:51 * CosmicRay releases missingh 0.10.0
19:57:46 * cm watchs 24 :-)
19:58:09 <Pseudonym> Oh, you should have heard the talk in this office over the second season of 24.
19:58:17 <Pseudonym> They mentioned us. :-)
19:58:26 <Pseudonym> Well, our product, anyway.
19:58:48 <Pseudonym> We suspect it's a coincidence, but still.
20:00:26 <CosmicRay> heh
20:01:40 <Pseudonym> The thing is: It's called what they called it, and it does what they said it did.
20:02:13 <cm> Pseudonym: I'm watching the 2nd :)
20:02:27 <Pseudonym> Ah, well we write "SIM".
20:02:32 <Pseudonym> Only it's called "TeraText" now.
20:02:33 <cm> Pseudonym: which episode & product is it?
20:02:40 <Pseudonym> First one, I think.
20:02:57 <cm> You are into nuclear bombs? :)
20:03:04 <Pseudonym> Uhhh, no.
20:03:07 <Pseudonym> We're into information retrieval.
20:03:41 <Pseudonym> And it really is used by government agencies.
20:03:50 <Pseudonym> I don't think we've ever sold to anyone called CTU, though.
20:04:03 <cm> Hah, thats cool :)
20:04:18 <Pseudonym> And we don't conform to the MovieOS interface guidelines.
20:04:29 <Pseudonym> We don't, for example, display 24 thumbnails a second while searching through records.
20:04:37 <cm> :)
20:04:41 <Pseudonym> :-)
20:05:04 <Pseudonym> But yeah, we thought it was cool.
20:06:03 <Pseudonym> Lots of pointing, and "oooh!  we're on the telly!"
20:06:20 <cm> hehe :) is it a small company?
20:06:32 <Pseudonym> Yeah, but we sell our stuff in the US through a big company.
20:06:41 <Pseudonym> We're about 20 people or so.
20:06:49 <Pseudonym> Might be close to 30 now.
20:08:13 <cm> What kind of information retrival is that?
20:08:28 <Pseudonym> Text, mostly.
20:08:30 <cm> +e. I guess no spyware? :D
20:08:34 <Pseudonym> www.teratext.com.au
20:08:36 <Pseudonym> No, nothing like that.
20:09:07 <Pseudonym> More like a search engine, only not necessarily for web data.
20:09:22 <cm> Ah k
20:09:36 <Pseudonym> And tailored for more dynamic collections, like a relational DBMS,
20:10:06 <cm> any kind of information classification/processing (extracting stuff, producing reports, ..)?
20:10:23 <Pseudonym> Sure, but that's mostly application-level.
20:10:28 <Pseudonym> Which we also do.
20:10:43 <Pseudonym> But that tends to be tailored for the customer.
20:11:57 <cm> Ah k
20:14:24 <Pseudonym> Anyway, lunch.
20:14:25 <Pseudonym> BBL
20:14:33 <Pseudonym> And when you see "SIM" mentioned, think of me fondly...
20:14:33 <Pseudonym> :-)
20:15:05 <cm> :D
20:15:07 <cm> Will do
20:15:33 <cm> (of course I expect you to acquire a legal copy of Splinter Cell 3 ;)
21:26:45 * dons hacks lambdabot
23:06:52 <SyntaxNinja> Lemmih: hi
23:07:02 <Lemmih> Hey (:
23:07:16 <SyntaxNinja> Lemmih: stil can't build hackage
23:07:26 <skew> mozilla&
23:07:31 <Lemmih> I'm trying to install it on shapr's box.
23:07:35 <SyntaxNinja> Compiling Packages         ( ./Packages.hs, dist/build/./hackage-tmp/Packages.o )
23:07:35 <SyntaxNinja> Packages.hs:103:28: Not in scope: `added'
23:07:35 <SyntaxNinja> Packages.hs:105:28: Not in scope: `description'
23:07:46 <SamB> skew: this is not a shell!
23:07:59 <SyntaxNinja> Lemmih: what's with the hemlate fork?
23:08:05 <SyntaxNinja> SamB: shush
23:08:11 <Lemmih> Hemplate fork?
23:08:11 <SyntaxNinja> skew: password:
23:08:23 <SamB> SyntaxNinja: extortionist!
23:08:35 <SamB> phisher, anyway
23:08:40 <SyntaxNinja> lemmih: http://www.cs.helsinki.fi/u/ekarttun/hemplate/
23:08:46 <SyntaxNinja> he has changes you don't have and vice-versa
23:08:59 <Lemmih> Oh right.
23:09:05 <SyntaxNinja> it seems anyway. his builds with the latest HaXml that I pulled from fptools
23:09:14 <SyntaxNinja> and his changelog seems to indicate changes after yours
23:10:38 <Lemmih> He got to Hemplate while I was cut off from it.
23:10:49 <SyntaxNinja> Lemmih: I thought you had this all built on shapr's box, that's why I watned to use it
23:11:00 <SyntaxNinja> anyway, what's with the 'added' and 'description' symbols? where are they from?
23:11:22 <Lemmih> Did you run 'create' from DBSpec.hs?
23:11:53 <SyntaxNinja> no
23:11:57 <SyntaxNinja> how do Id o that?
23:12:20 <Lemmih> 'ghc -e "create" DBSpec.hs' or use GHCi.
23:12:54 <SyntaxNinja> you should add a build hook or osmething
23:13:27 <Lemmih> Feel free to send patches (:
23:13:49 <SyntaxNinja> what about emptyState?
23:14:42 <SyntaxNinja> if you qualified all your inputs, this would be easier to figure out :)
23:14:46 <Lemmih> I'll look into once I've installed all of the dependencies.
23:15:00 <SyntaxNinja> and I wouldn't get this error: Hackage.hs:71:21:
23:15:00 <SyntaxNinja>     Ambiguous occurrence `gets'
23:15:07 <SyntaxNinja> I've got them all in my home directory
23:15:12 <SyntaxNinja> and I justr asked shapr to isntal them system-wide
23:15:18 <SyntaxNinja> unless you have sudo, you might just wait for him to do it
23:16:10 <Lemmih> Isn't shapr sleeping?
23:17:25 <Lemmih> And how did you get the XML-RPC package?
23:17:28 <SyntaxNinja> who knows with him.
23:17:33 <SyntaxNinja> I copied it from your home directory
23:17:36 <SyntaxNinja> did you get my emial?
23:17:37 <Lemmih> Oh.
23:17:40 <Lemmih> Yeah.
23:17:48 <SyntaxNinja> damn his hemplate won't build emptyState
23:17:53 <SyntaxNinja> dammit
23:18:17 <Lemmih> Use mine. I'm not supporting forks (:
23:18:39 * Lemmih is compiling Hemplate now.
23:18:51 <Lemmih> Installed.
23:19:00 <SyntaxNinja> which haxml did you use?
23:19:06 <Lemmih> 1.12
23:19:23 <SyntaxNinja> where did you get it?
23:19:55 <Lemmih> I really don't remember.
23:20:10 <Lemmih> It was like four months ago (:
23:20:52 <SyntaxNinja> did you get this error:
23:20:53 <SyntaxNinja> src/Network/Hemplate/HemplateXml.hs:24:12:
23:20:53 <SyntaxNinja>     Constructor `Text.XML.HaXml.Types.Document' should have 4 arguments, but has been given 3
23:20:53 <SyntaxNinja>     In the definition of `haxmlToXml':
23:20:53 <SyntaxNinja>         haxmlToXml (Text.XML.HaXml.Types.Document pl st elt)
23:20:53 <SyntaxNinja>                      = Document pl st (haxmlElementToElement elt)
23:20:56 <SyntaxNinja> did you fix that?
23:21:44 <Lemmih> Where did you get Hemplate?
23:22:24 <Lemmih> The stuff in /var/www/repos/ is dated because I don't have push access there.
23:22:32 <SyntaxNinja> I got one from   http://www.scannedinavian.org/repos/hemplate/
23:22:40 <SyntaxNinja> well what are you supporting then?
23:22:55 <Lemmih> [same-host]/~lemmih/hemplate/
23:24:00 <SyntaxNinja> you should coordinate with musasabi to bring these versions back into line
23:24:23 <Lemmih> I'm not very happy with some of the changes he has made ):
23:24:39 <Gahhh> you need a benevolent dictator
23:25:48 <SyntaxNinja> yeeesss
23:25:54 <Heffalump> oh, do I need to install ghc 6.4 to get a later cabal than 0.5 ?
23:27:05 <Heffalump> oh, I guess I need to anyway to be up to date with sid.
23:27:36 <SyntaxNinja> cabal > 0.5 basically == cabal 0.5
23:27:43 <SyntaxNinja> and comes w/ ghc 6.4
23:28:06 <SyntaxNinja> Lemmih: bah, hemplate still no buildy
23:28:36 <Lemmih> Then you're doing it wrong (: I'm building hackage now.
23:28:50 <SyntaxNinja> did you record and push your changes?
23:29:28 <SyntaxNinja> where is the HaXml you're building it with?
23:29:31 <Lemmih> To hemplate? No, I just installed what I had in public_html/
23:29:44 <Lemmih> You can get it from my home dir.
23:30:48 <SyntaxNinja> in ~lemmih/public_html/hemplate?
23:30:57 <Heffalump> how come 6.4 isn't removing libghc6-cabal-dev ?
23:31:39 <SyntaxNinja> Heffalump: ghc 6.4 from haskell-unsafe? I think it conflicts w/ it, not sure
23:31:57 <Heffalump> oh, duh, it's not in sid.
23:31:59 <Heffalump> was confused.
23:32:07 <Heffalump> so I shouldn't build against 6.4, I'm just confused.
23:32:32 * SyntaxNinja nods
23:32:33 <Lemmih> SyntaxNinja: I've built Hackage.
23:32:43 * SyntaxNinja high-fives Lemmih
23:32:56 <SyntaxNinja> I'm still stuck w/ an incompatible HaXml
23:33:02 <SyntaxNinja> I wonder why HaXml is in the fptools tree and not in GHC
23:33:12 <Lemmih> SyntaxNinja: But my /cgi-bin/ dir isn't doing what it should ):
23:33:18 * Lemmih goes to bug shapr.
23:34:12 <SyntaxNinja> I beg you... tell me where your version of HaXml is
23:34:17 <Gahhh> lol
23:34:44 <SyntaxNinja> I count at least 4 locations for hemplate, btw.
23:34:44 <Lemmih> SyntaxNinja: I my home dir. /home/lemmih/HaXml-1.12/
23:37:50 <Lemmih> The religion of Hemplate. Follow the true path to avoid the hellfire.
23:38:23 <Lemmih> Tsk Tsk. Hackage is such a mess ):
23:38:42 <SyntaxNinja> but how do I choose between scannedinavian.org/repos/hemplate, ~lemmih/hemplate, musasabi's hemplate, and scannedinavian.org/~lemmih/hemplate
23:39:50 <Lemmih> Don't use anything from /repos/, don't use musasabi's version and the two others are identical.
23:39:54 <ibid> what *is* hemplate?
23:40:40 <Lemmih> ibid: Template system used by Hackage to generate HTML on the fly.
23:41:33 <ibid> ok
23:42:07 <Heffalump> gah, no free disk space
23:42:27 * Heffalump gives up on trying to fix haskell-http quickly
23:43:16 <Lemmih> SyntaxNinja: /home/lemmih/public_html/hemplate is the repo, and /home/lemmih/hemplate is where I actually built the library (to keep the repo clean).
23:57:24 <SyntaxNinja> oh yay! another hemplate!
23:57:31 <SyntaxNinja> HaXml-1.12/lib/hemplate-0.1/
23:59:27 * Heffalump wants a new HaXml release
