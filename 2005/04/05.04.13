00:03:32 <blackdog> shapr: around?
00:06:12 <blackdog> @seen shapr
00:06:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- shapr is in #haskell. I don't know when shapr last spoke.
00:06:23 <blackdog> damn you, this is no time to be sleeping
00:36:18 <dons> yay. calculating all depends automagically works :)
00:36:53 <Itkovian> heh
00:37:11 <dons> after 3 failed attempts
00:46:51 <jlouis> mmm
00:46:54 <jlouis> morn
00:47:55 <theorbtwo> Cool, dons!
00:50:19 <theorbtwo> Oh, of course, not yet in any snapshot.
00:52:27 <dons> oh, you referring to hs-plugins?
00:52:47 <dons> that already does dependency calculating. lambdabot does it now too, though I haven't comitted yet
00:53:47 <theorbtwo> Ah, OK.
00:54:35 <dons> it's my assertion that dynamic linkers are not practical until they figure out dependencies on their own.
00:54:41 <theorbtwo> I thought you were talking about /re/writing the hs-plugins dep tracking, so it takes into account /all/ depends.
00:54:44 <theorbtwo> I tend to agree.
00:54:52 <dons> /all/ , as in the C libs too?
00:55:07 <dons> extra_libs sometimes get lost, as we don't know all the C search paths.
00:55:09 <theorbtwo> (Though I did have it faked with ModuleLoader for a bit, using nm and a perl script to figure out the depends.)
00:55:21 <theorbtwo> Aye, as in C libs too, and -boot.
00:55:28 <dons> ah. yes. -boot.
00:55:31 <dons> havn't looked at that yet.
00:56:05 <theorbtwo> Load the deps in the .hi-boot, then the module, then the other deps, then the module itself.
00:56:07 <theorbtwo> I think.
00:56:26 <dons> that sounds about right, yes.
00:56:36 <dons> is hs-plugins working for you?
00:56:53 <theorbtwo> Aye.
00:56:55 <theorbtwo> Much thanks.
00:57:30 <dons> that's cool. send bug reports, feature requests.
00:57:48 <dons> i'm quite open to suggestions, esp. if you're using it in some heavy duty manner
00:58:29 <theorbtwo> Not heavy-duty yet, but will become heavier, I expect.
00:58:56 <theorbtwo> Only feature request I can think of is -boot, and that's static enough that the hack I'm doing is usable.
00:59:26 <dons> yeah, i see. ok. i'll stick it on the list.
00:59:57 <theorbtwo> Don't mean to nag; you asked.
01:00:05 <dons> :)
01:00:30 <blackdog> dons: any good bands playing sydney soon? i'm totally starved for live music...
01:00:34 <boegel> dons: so glad to see me ?
01:01:12 * boegel waves at the cheering crowd
01:01:20 <boegel> sorry, moment of weakness :p
01:02:07 <blackdog> boegel! boegel! boegel!
01:02:31 <boegel> hehe
01:03:00 <boegel> it should be: "boe-gel ! boe-gel ! boe-gel !" probably ;)
01:03:11 <boegel> but maybe I should learn how to play the guitar first
01:04:28 <blackdog> or it could be the oi! oi! oi! version...
01:04:46 * boegel likes oi
01:04:57 <dons> blackdog, i was just thinking this today. seems nothing much. maybe the local bands
01:05:12 <boegel> man, I really should go to a live concert too, it's bean too long
01:05:22 <blackdog> oh, wait. interpol are coming, aren't they?
01:05:30 <boegel> but the upcoming big festival (Rock Werchter) is soo damn expensive :(
01:05:35 <blackdog> they can sound just like their record again. </bitchy>
01:05:55 <dons> hehe
01:06:14 <blackdog> boegel: the trick is to like bands that no-one else likes, and to ditch them before they get too popular. You don't think we're indie fans because we _like_ Sonic Youth, do you?
01:06:32 * blackdog subtly baits dons.
01:06:38 <blackdog> ok, maybe not that subtly.
01:06:59 <dons> :p
01:07:08 <blackdog> dons: the problem is that it's such a very good record, it's hard to get too annoyed
01:07:23 <dons> interpol? yeah.
01:07:50 <blackdog> we should totally start a haskell hacker band, if only to see Sean rap. :)
01:08:05 <boegel> blackdog: my top band was KoRn the last few years, but I feel like that has tempered since I've seen 'em live
01:08:08 <dons> oh, I'm worried now.
01:08:25 <boegel> the concert was fantastic, but I guess my goal (seeing them live) is gone with them
01:08:30 <dons> seafood rapping is very worrying
01:09:23 <pesco> Please, just out of personal taste, I like not to associate Haskell with any rap!
01:09:51 <boegel> how about a rock band with Sean head-banging ?
01:10:09 <blackdog> dons: i have proof.
01:10:09 <pesco> That would be better for me. But who's Sean?
01:10:45 <blackdog> i think el-producto would be a haskell hacker.
01:11:19 <boegel> perdix: ow, I was aiming for shapr, but that's Shae, not Sean
01:11:30 <boegel> s/perdix/pesco
01:11:33 <perdix> ^^
01:11:43 <pesco> Oh, OK!
01:11:59 <blackdog> Aes Rock would be Perl, De La Soul would be Python, Vanilla Ice could be COBOL...
01:12:10 <tic> ajs ajs bäjbi
01:12:32 * boegel wonders what the Backstreet Boys would be
01:12:33 <perdix> btw, good morning, #haskell
01:12:40 <blackdog> shell scripts
01:12:49 <blackdog> VB, maybe?
01:12:51 <blackdog> i can't decide
01:13:05 <boegel> watch it, because they're making a comeback ;)
01:13:28 <jlouis> @version
01:13:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p270, GHC 6.4 (OpenBSD i386)
01:13:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:13:31 <theorbtwo> Again?
01:13:39 <theorbtwo> God, the first comeback was bad enough.
01:14:14 <blackdog> boegel: got mixed feelings about Korn. That insane thing that the singer does with his voice is very cool, but the music itself seems pretty much angry-young-man by the numbers.
01:15:36 <boegel> blackdog: he has a lot of anger in him because of his wicked child hood, he was abused by his father, worked in a funeral home (washing dead bodies) for some extra money, and so on
01:15:46 <boegel> but I've heard rumors about them splitting up :s
01:15:52 * boegel is glad to have seen them live
01:16:54 * pesco looks quietly at his NIN tickets.
01:17:17 * pesco hums to himself.
01:17:43 <tic> nine icky newbies?
01:17:44 <boegel> I would love to see Rammstein live one of these days
01:17:53 <boegel> tic: nine inch nails
01:17:57 <tic> boegel, they're nice. watch out to get your nosehair burnt.
01:18:07 <boegel> tic: thanks for the warning :D
01:18:32 <tic> boegel, [nin] omg, are you serious? ;)  Why would I say _nine_ icky... if I didn't knew of them? :)
01:18:48 <shapr> pesco: I really want to go see NIN this year, but ...
01:19:15 <pesco> boegel, tic: But beware, Rammstein become next to unbearable once you get the lyrics.
01:19:45 <pesco> shapr: But what?
01:19:48 <pesco> ;)
01:20:01 <boegel> pesco: why ? what's wrong with the lyrics ?
01:20:06 <tic> yeah?
01:20:14 <pesco> boegel: They're fscking _cheesy_!
01:20:27 <pesco> boegel: And not in the funny and cool way of cheesy.
01:20:27 <tic> I'm a hermaphrodite! One for you, one for me!
01:20:46 <tic> punish me!
01:20:59 * tic switches from neofolk to Rammstein.
01:21:09 <boegel> pesco: I like the power of their music, don't really care about the lyrics
01:21:26 <pesco> boegel: That's good. Just make sure to never learn any German. ;)
01:21:53 <tic> d'you guys like :wumpscut: ?
01:21:54 <shapr> boegel: truly
01:21:54 <boegel> pesco: alrighty then
01:21:55 <tic> also pretty nice
01:21:56 <tuomov> the latest album has one song mostly in english..
01:22:15 <shapr> I like Rammstein's music. But I liked it a lot more before I asked someone to translate the lyrics for me.
01:22:25 <tuomov> It's ok
01:22:37 * boegel has to go, humming "Keine Lust" in his head
01:22:39 <tic> shapr, don't you guys read foreign languages in the US?
01:22:51 <shapr> tic: Yeah, but I did French.
01:22:59 <tic> shapr, sucker. ;)
01:23:03 <shapr> And nowadays I do Swedish :-P
01:23:06 <tic> shapr, attending this year's EP?
01:23:14 <tuomov> hm.. moonsorrow gig today
01:23:15 <shapr> it's entirely possible
01:23:19 <tic> shapr, sweet.
01:23:32 <shapr> Are you going to EuroPython?
01:23:44 <pesco> tic: I feel most of Wumpscut's music is too simple. But it might be personal taste, because there is simple music which I love. ;)
01:23:58 <tic> hopefully, yeah.  the plan is that I write the travel direction page, which is due, uhm, a month ago. ;)
01:24:01 <shapr> Have you guys tried Dillinger Escape Plan?
01:24:15 <tic> pesco, okay. I like the energy :)
01:24:20 <tuomov> dillinger escape plan rocks
01:24:39 <shapr> Yeah, I actually quite like them. I didn't expect to though.
01:24:45 <shapr> mathcore is a very weird idea.
01:24:46 <pesco> I've had the Dillinger Escape Plan on my "to hear" list. Could someone spare an MP3?
01:25:00 <shapr> I got mine from their website, they have two tracks.
01:25:06 <pesco> shapr: What in the is mathcore?
01:25:12 <pesco> Ah.
01:25:23 <tuomov> technical hardcore/metal/whatever
01:25:31 <shapr> http://en.wikipedia.org/wiki/Mathcore
01:26:14 <pesco> Oh, I have a Converge button on my Uni bag.
01:26:28 <shapr> Wikipedia says there are rumors that Dillinger Escape Plan comes up with their timing by using dice.
01:26:30 <pesco> Alongside "Initial State" and "Void".
01:30:29 <shapr> Recently I downloaded everything by Brother Machine, http://www.thebrothermachine.com/ . If you like Beck-style vocal music, it's really nice.
01:31:46 <shapr> I've been idly working on a version of http://irate.sf.net/ written in Haskell, but the irate docs aren't detailed enough, and it's not much fun to dig through the java sources.
01:32:02 <dons> @quit
01:32:19 <dons> @version
01:32:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p273, GHC 6.4 (OpenBSD i386)
01:32:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:36:09 <musasabi> shapr: I think the most important thing with apps like irate is getting a good gui.
01:36:53 <musasabi> shapr: Personally I would be more interested in iRate but for images.
01:37:25 <shapr> Interesting thought.
01:37:42 <shapr> My problem with irate is that it choked permanently once I had 3gb of tracks.
01:39:09 <musasabi> e.g. I have ~20000 pics sitting on my hd, most of which are pictures from various occasions with friends etc
01:39:23 <musasabi> Trying to find something is getting more and more annoying.
01:39:48 <shapr> So you'd want to be able to search for pictures above a certain rating?
01:40:01 <shapr> hi wli
01:40:36 <musasabi> shapr: yes, but more like categorization.
01:41:00 <shapr> you could link them into a local wiki for 'backlink' cagetorization.
01:41:34 <shapr> I can't think of anything else off the top of my head.
01:42:39 <musasabi> shapr: yes, except that would not make sharing the information with friends any easier.
01:42:44 <mflux> musasabi, I wrote this some time ago, but I imagine there may be others like it: modeemi.fi/m-arkisto
01:42:58 <mflux> (c++)
01:43:04 <shapr> unless you could do sharing of subwikis like we discussed before
01:43:13 <mflux> cyanide means a category and purple means an author
01:43:15 <shapr> oh I had an idea for subwiki snipping before
01:43:22 <dons> cyanide?
01:43:27 <mflux> and darked cyanide means a dataset
01:43:28 <mflux> the color
01:43:31 <dons> cyan
01:43:32 <mflux> cyan
01:44:38 <dons> @web1913 cyanide
01:44:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "Cyanide" web1913 "Webster's Revised Unabridged Dictionary (1913)"
01:44:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Cyanide \Cy"a*nide\ (s?"?-n?d or -n?d; 104), n. [Cf. F. cyanide.
01:44:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-    See {Cyanic}.] (Chem.)
01:44:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-    A compound formed by the union of cyanogen with an element or
01:44:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-    radical.
01:44:44 <mflux> the user interface could perhaps be more pretty..
01:44:45 <musasabi> mflux: that looks quite pretty, is it large?
01:44:53 <mflux> musasabi, the code?
01:44:57 <musasabi> yes
01:45:08 <musasabi> most of the picture thingys I have found have been quite horrible php.
01:45:18 <mflux> quite large infact, 9k lines
01:45:39 <mflux> well, propably larger than some average gallery software
01:45:54 <mflux> it also has a background process that generates thumbnail images for uploaded images
01:46:15 <mflux> and it handles uploads of single jpeg-files or tars made of many such files
01:46:40 <mflux> I've been planning to take some idea from the new caml humps on how the ui should look like..
01:46:53 <shapr> it seems quite fast too
01:47:13 <mflux> it caches all the queries in the database. it uses postgresql backend.
01:47:35 <shapr> After years of using Zope, I'm not used to fast anymore.
01:47:42 <mflux> ;)
01:50:32 <pesco> kosmikus: Are you awake?
01:51:08 <boegel> pesco: the question is not are you there, but are you awake ? that's funny :)
01:51:21 <pesco> :)
01:51:44 <mflux> I've tried it with 440k images, but becomes quite s-l-o-w at that point
01:53:44 * boegel leaves to continue working on his thesis
01:53:48 <boegel> bye everyone
01:53:55 <shapr> cya boegel
01:54:37 <pesco> kosmikus: I've hacked Typewriter.lhs to always put pragma text into mboxes and escape the special characters in it (non-mathmode style). That fixes my problem and seems reasonably, since the content text of pragmas is not freeform (where the user might want to include his own formatting, as in comments) and we don't know the particular syntax of most pragmas (the only ones in the report being INLINE and SPECIALIZE IIRC).
02:03:00 <nlv11757_> is there a kind of 'maybe' functions for lists, so base case for [], a function for x:xs case.
02:04:46 <Lemmih> @type \d f -> maybe d f . Data.Maybe.listToMaybe
02:04:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- \d f -> maybe d f . Data.Maybe.listToMaybe :: forall b a.
02:04:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                               b -> (a -> b) -> [a] -> b
02:04:54 <Lemmih> @pointless \d f -> maybe d f . Data.Maybe.listToMaybe
02:04:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- flip flip (Data . Maybe . listToMaybe) . ((.) .) . maybe
02:05:25 <nlv11757_> listToMaybe, interesting :D thanks
02:05:54 <Lemmih> @plugs (\d f -> maybe d f . Data.Maybe.listToMaybe) 'c' toUpper ['b']
02:05:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 'B'
02:06:01 <Lemmih> @plugs (\d f -> maybe d f . Data.Maybe.listToMaybe) 'c' toUpper []
02:06:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 'c'
02:06:15 <Lemmih> @karma+ lambdabot
02:06:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot's karma has been incremented
02:08:01 <nlv11757_> Haskell has got so many more standard things than caml i discovered
02:08:06 <shapr> really?
02:08:34 <nlv11757_> well i had to define my own ($) and (.) in ocaml for example
02:09:01 <nlv11757_> it could also be that people in #ocaml didnt know the ocaml equivalent, but this is something i experienced more and more.
02:09:10 <mflux> there aren't
02:09:16 <nlv11757_> in ocaml it was always; define it yourself
02:09:27 <mflux> but infact ($) is not a good idea, because it is used by the language extensions mechanism
02:09:36 <shapr> ?
02:09:37 <nibro> nlv11757_: ocaml has no overloading, so it's hard to define a lot of standard operators
02:09:45 <mflux> someone suggested I should use ++, but that of course means something else in haskell ;)
02:10:11 <nlv11757_> you are probably right nibro, there has to be a reason. But it is annoying
02:10:36 <mflux> let ($) a b = 42 and try to compile it with ocamlc -pp camlp4o -> failure
02:11:03 <nlv11757_> i think i used (@) for it in my ocaml prog
02:11:30 <musasabi> The problem with ($) in Haskell is that it will bite you sometimes (think runST).
02:11:31 <mflux> ok, but @ is already in use
02:11:40 <nibro> nlv11757_: aye, ocaml is annoying ;-)
02:11:42 <musasabi> of course it is still very convenient.
02:12:01 <kosmikus> pesco: I'm not sure yet if I see this solution as an improvement, but you can certainly send me the patch.
02:12:28 <musasabi> But having "foo $ bar baz" <=> "foo (bar baz)" identical is what I expected as a newbie.
02:12:48 <kosmikus> pesco: wouldn't treating pragmas as code just have worked?
02:13:20 <pesco> kosmikus: What exactly does "treating [them] as code" mean? Use the convert function?
02:13:47 <nlv11757_> is @ already in use mflux :D
02:13:50 <nlv11757_> oops
02:13:53 <kosmikus> pesco: if you think I know all the function names in all lhs2TeX modules just so, you're wrong :)
02:13:58 <nlv11757_> i redefined it then? accidently?
02:14:00 <mflux> nlv11757_, list concatenation
02:14:03 <mflux> yes
02:14:11 <mflux> you could maybe use @@
02:14:17 <nlv11757_> hehehe
02:14:40 <kosmikus> pesco: I have two papers to submit today ... if you send me your patch, I'll try think about a solution tomorrow
02:14:47 <nlv11757_> aw its not that a big of deal, its just some extension i wrote to some existing app. Everything still worked :P
02:14:50 <mflux> or just define let (++) a b = a @ b let (@) a b = .. ;)
02:15:02 <pesco> kosmikus: I'm sorry, in Typewriter.lhs, AFAICS, the code fragments are turned into Docs by a function called "convert" which, essentially escapes special characters in a way appropriate for the current mode (math or not).
02:15:12 <nibro> musasabi: as a newbie, foo $ bar baz <=> foo (bar baz) holds since newbies don't do higher-ranked stuff ;-)
02:15:35 <nibro> if you start using runST you're by default no newbie anymor
02:15:51 <pesco> kosmikus: Anyway, since in poly mode, code is set in math mode, for concrete example, the '-' characters in {-# OPTIONS -fglasgow-exts #-} turned out as long minuses.
02:15:55 <nlv11757_> mflux, how annoying it never warned me about accidently redefining an existing operator
02:15:56 <nibro> (e) :)
02:16:30 <mflux> redefining operators isn't that uncommon in ocaml.. Int32 and Int64-modules do that too.
02:16:51 <pesco> kosmikus: In general, the problem is, if we were to say "a pragma is code", we'd mean "haskell code" by that. And that's generally false. Parts of the pragma might be, or nothing at all.
02:17:10 <pesco> But I'll send you the patch, get on with your papers. ;)
02:17:34 <nlv11757_> mflux, still i think it would be nice if i got notice i was doing it
02:17:58 <nlv11757_> cause an innocent haskell man like myself might be redefining stuff without knowing it
02:26:37 <dons> nlv11757_: use -Wall -Werror
02:26:41 <dons> that'll let you know
02:31:45 <nlv11757_> k
02:32:04 <nlv11757_> not that im touching ocaml within the next few weeks :)
02:37:29 <jlouis> @version
02:37:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p273, GHC 6.4 (OpenBSD i386)
02:37:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:37:38 <jlouis> hrmf, darcs bzzzts ups
02:39:25 <dons> ?
02:40:32 <dons> you working around the patch problem?
02:40:37 <jlouis> trying to, hehe
02:41:04 <dons> yeah. does it work just to darcs get;replace TopicModule with your latest one, darcs record ?
02:41:11 <dons> so just one patch, one file change.
02:41:38 <jlouis> I have pulled a number of patches, which doesn't get darcs into an infinite loop
02:41:49 <jlouis> If this doesn't work out, I am going to do what you suggest
02:47:52 <jlouis> dons: 2nd time is bliss. Now with a new patch against the TopicModule.hs
02:48:13 <jlouis> I must have hit a couple of darcs bugs. Maybe I should take time to hunt them down
02:49:57 <pesco> Anyone knowledgeable about TeX: How do I do (\(x:xs) -> x : map toLower xs) in TeX?
02:50:16 <jlouis> pesco: so it is nice?
02:50:30 <pesco> jlouis: What do you mean?
02:50:44 <jlouis> The ugly starter is \begin{verbatim}(\(x:xs) ...)\end{verbatim
02:50:45 <jlouis> }
02:51:08 <jlouis> If you want the lambda to be a \lambda, you need packages.
02:51:31 <pesco> No, sorry, I meant I need a TeX macro that does what (\(x:xs) -> ...) does in Haskell in TeX.
02:51:46 <theorbtwo> Hm, what would the SOURCE in import {-# SOURCE #-} AST be in glasgow-extended haskell?
02:51:56 <theorbtwo> I don't see it in the manual at all...
02:52:18 <pesco> jlouis: I.e. \newcommand[1]{\uncap}{...} or something like that.
02:52:54 <pesco> So I can write \textsc{\uncap{DEPRECATED}} and get Deprecated set in small caps.
03:39:44 <JaffaCake> straw poll: raise your hand if you use GHC on Sparc
03:39:49 <df_> is there any way of mmap'ing a file in haskell (using ghc)
03:39:50 * df_
03:39:56 <df_> (raises hand that is)
03:40:16 <JaffaCake> df_: are you using 6.4?  did you compile it yourself?
03:40:50 <df_> prebuilt 6.2.2.  i keep considering building 6.4, but it is a hell of a lot of effort
03:41:07 <JaffaCake> right, thanks
03:41:11 <JaffaCake> noone else?
03:41:29 <JaffaCake> raise your hand if you would *like* GHC on Sparc
03:41:29 <df_> especially since i can't use gcc3 with the binary 6.2.2
03:41:42 * df_ raises mit
03:42:34 <JaffaCake> thanks - it's probably a fair bit of effort on my part to fix the outstanding issues with 6.4 on Sparc, but if enough people want it then it's worthwhile
03:42:48 <JaffaCake> unfortunately I'm not seeing the demand right now
03:43:19 * df_ understands
03:44:04 <df_> i was meaning to ask a while back, is 6.4 capable of running on sparc? or does it need tweaking
03:44:40 <JaffaCake> someone else has reported that it crashes sometimes.. could be a problem with gcc 3, though
03:45:46 * pesco raises his head.
03:45:50 * pesco raises his hand.
03:45:55 <pesco> I use GHC on Sparc.
03:46:18 <pesco> :)
03:46:55 <JaffaCake> thanks pesco :)
03:46:59 <pesco> My Uni has Sparcs almost exclusively.
03:47:10 <JaffaCake> and you're still using 6.2.2?
03:47:13 <pesco> Yes.
03:47:19 <JaffaCake> ah yes, I remember
03:47:40 <pesco> I use it for work there. I'm the only one in the department, too, currently, but hey.
03:47:51 <pesco> (the only one in the department using it, that is)
03:49:10 <pesco> I'm pretty sure people from the theoretical department use it occasionally, but I think they all have iBooks or something. ;)
03:49:44 <JaffaCake> hehe, right
03:51:47 <pesco> So, anyway, it would probably be a turndown to stay stuck at 6.2.2 forever, but we can hold up.
03:53:30 * JaffaCake has a whole box of gold stars for anyone who volunteers to maintain GHC on Sparc
03:54:20 <JaffaCake> and a "I maintain GHC on Sparc" badge
03:54:24 <pesco> :)
03:55:15 <pesco> Sorry, I wouldn't have the time, even if I had the skill.
03:55:29 <pesco> Tempting as it is... ;)
03:55:36 <df_> i would offer, but don't know the internals of ghc at all - main reason why i havn't got round to actually compiling 6.2.2 myself
04:01:02 <basti_> hi all... how would i do a 2-way assiciation in a clean way?
04:12:10 <pesco> Oh my god, how hard can it be, in TeX to turn a word into titlecase!?
04:18:36 <Cale> \sc ?
04:18:45 <Cale> That might be just LaTeX
04:19:27 <ibid> that's obsolete latex
04:19:30 <Cale> or \textsc possibly
04:19:31 <ibid> \textsc
04:19:36 <Cale> yeah
04:21:19 <pesco> Cale: No, \textsc just selects another font. I need a macro to turn the first letter of a word into upper case and the rest into lower case.
04:21:41 <pesco> So, for example DEPRECATED becomes Deprecated, so I can set that in \textsc which will look nice in the printed output.
04:22:05 <pesco> \textsc{DEPRECATED}, however, looks just like DEPRECATED by itself.
04:22:23 <Cale> Are you marking up a text file or something?
04:22:40 <pesco> I'm writing literate Haskell with lhs2TeX
04:22:44 <Cale> (Why not just type "Deprecated"?)
04:22:59 <Cale> oh, hmm... so perhaps there's code which you want to appear that way?
04:23:28 <pesco> Yes. I'm looking at a DEPRECATED pragma.
04:23:40 <ibid> pesco: there is a way to do it, but it requires some wizardy
04:23:45 <ibid> +r
04:24:05 <pesco> ibid: From some googling and some manual-reading, that's the impression I get, too..
04:24:34 <pesco> I think that's pretty sad. I mean, it (\(x:xs) -> toUpper x : map toLower xs), for god's sake!
04:24:45 <pesco> s/it/it's/
04:25:04 * pesco sighs.
04:25:43 <ibid> pesco: tex was not supposed to be a programming language
04:25:52 <pesco> OK.
04:27:31 * pesco hacks at lhs2TeX.
04:29:31 <pesco> Hah!
04:35:03 <pesco> kosmikus: Now, /those/ are pretty pragmas! I let the lexer split out the pragma name (first word) and pass it on title-cased (in addition to the original). So now I can set it in small caps. The result is astoundingly prettier than what we had before.
04:51:49 <nlv11757_> eek, listToMaybe is not quite what i expected it to be
04:51:58 <nlv11757_> it just rips off the first list element
04:52:43 <nlv11757_> listToMaybe [1,2,3] should be Just [1,2,3] imo
04:53:19 <Cale> that's not what listToMaye is for
04:53:27 <Cale> Maybe*
04:54:33 <nlv11757_> apparently not
04:54:35 <Cale> Maybe is included into the List type by Just x <-> [x], Nothing <-> [] -- listToMaybe is a (one-sided) inverse to the inclusion map.
04:55:01 <nlv11757_> i see your point, but i think my use for listToMaybe is not so weird either is it
04:55:07 <nlv11757_> even if it isnt the inversion
04:55:16 <Cale> Well, that's just Just
04:55:26 <nlv11757_> no its not, because [] becomes Nothing
04:55:36 <nlv11757_> instead of Just []
04:55:54 <Cale> oh, okay -- I've never needed that though
04:56:04 <nlv11757_> well ok, i just did
04:56:19 <nlv11757_> for esthetical reasons mostly
04:58:47 <pesco> What was it you were looking for originally? Something like  listmaybe x xs = if null xs then [x] else xs  ?
05:02:17 <dons> @quit
05:02:29 <dons> @version
05:02:30 <lambdabot> lambdabot 2p280, GHC 6.4 (OpenBSD i386)
05:02:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:02:31 <pesco> lambdabot: re
05:02:32 <lambdabot> Not a command (no @).
05:02:45 <pesco> cptchaos: Moin!
05:02:57 <cptchaos> pesco: moin!
05:03:04 * Itkovian has just received his powerbook. rejoice.
05:03:11 * pesco cheers.
05:03:42 * pesco pets his powerbook.
05:04:42 <pesco> *Pat Pat Pat*
05:04:48 <dons> @type 1
05:04:50 <lambdabot> 1 :: forall t. (Num t) => t
05:05:03 <pesco> @moo
05:05:04 <lambdabot>          (__)
05:05:04 <lambdabot>          (oo)
05:05:04 <lambdabot>    /------\/
05:05:04 <lambdabot>   / |    ||
05:05:04 <lambdabot>  *  /\---/\
05:05:05 <lambdabot>     ~~   ~~
05:05:07 <lambdabot> ...."Have you mooed today?"...
05:05:53 <TheHunter> @state @foo
05:05:54 <lambdabot> nothing yet
05:05:57 <_JusSx_> @bitch
05:05:58 <lambdabot> Unknown command, try @listcommands.
05:06:00 <TheHunter> @state @bar
05:06:01 <lambdabot>  @foo
05:06:11 <jlouis> _JusSx_: vixen?
05:06:15 <pesco> @vixen
05:06:16 <lambdabot> why do you look like ham?
05:06:17 <TheHunter> @vixen bitch
05:06:18 <lambdabot> Too much cussing.
05:06:29 <pesco> @state karma
05:06:30 <lambdabot>  @bar
05:06:50 <dons> is the bot still noticing? i think it isn't.
05:06:59 <dons> or maybe my config hasn't been reloaded..
05:07:08 <pesco> Right, he's privmsging.
05:07:08 <Igloo> It isn't
05:07:14 <dons> ok.
05:07:19 <dons> TheHunter supplied a nice patch
05:07:26 <dons> @karma+ TheHunter
05:07:27 <lambdabot> TheHunter's karma has been incremented
05:07:27 <pesco> @state Garrgl
05:07:28 <lambdabot> karma
05:07:37 <pesco> What patch?
05:07:48 <dons> @version
05:07:49 <lambdabot> lambdabot 2p280, GHC 6.4 (OpenBSD i386)
05:07:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:07:49 <TheHunter> the noticing obviously pissed some people off.
05:07:51 <dons> #290.
05:07:54 <dons> 280.
05:07:58 <dons> yes.
05:08:39 <pesco> :(
05:08:46 <dons> ?
05:08:47 <pesco> Ah well.
05:08:49 <TheHunter> btw, sed seems to work differently on your system than on mine.
05:09:01 <pesco> @karma TheHunter
05:09:02 <lambdabot> TheHunter has a karma of 1
05:09:09 <TheHunter> @karma dons
05:09:10 <lambdabot> dons has a karma of 0
05:09:18 <dons> I saw that. gnu sed has too many extensions.
05:09:25 <dons> hmm. where'd the karma go?
05:09:55 <Itkovian> down the drain
05:10:03 <TheHunter> @eval id 3
05:10:04 <lambdabot> unbound variable: id
05:10:25 <pesco> @eval (\x. x) 3
05:10:26 <lambdabot> 3
05:10:31 <dons> hmm. it's in the State/ db.
05:11:20 <dons> @quit
05:11:49 <dons> @karma TheHunter
05:11:50 <lambdabot> TheHunter has a karma of 0
05:11:54 <dons> hmm...
05:12:31 <dons> it's getting saved on quit, TheHunter, but not inited.
05:12:33 <TheHunter> probably my fault, i go check...
05:12:56 <nlv11757_> @karma lambdabot
05:12:56 <lambdabot> lambdabot has a karma of 0
05:13:17 <jlouis> I'll revamp FactModule to use the new state tracking system
05:13:28 <jlouis> getting rid of postgresql in the process
05:13:43 <xerox> @karma xerox
05:13:44 <lambdabot> You have a karma of 0
05:13:58 <xerox> :( ..anyway, lunchtime.
05:19:36 <pesco> I'm wondering, what does e.g. stand for, exactly?
05:19:59 <TheHunter> exemplum gratum, iirc.
05:20:23 <TheHunter> well, "exempli gratia"
05:20:51 <pesco> Can you explain the cases?
05:22:03 <TheHunter> gratia might ablativus instrumentalis
05:22:37 <TheHunter> actually i, have no idea.
05:22:52 <TheHunter> seven years of latin and i remember nothing.
05:23:02 <pesco> :( I've had three.
05:23:11 <Narrenschiff> Me neither. Though it was only two years for me.
05:23:24 <Cale> It is exempli gratia, http://www.bartleby.com/61/23/E0272300.html has an explanation :)
05:23:28 <Narrenschiff> Though I did date a classicist, so I'm adding an extra year for... osmosis.
05:24:23 <pesco> Cale: Ah, thanks. ;)
05:25:18 <blackdog> shapr: dillinger escape plan is right up there with Fantomas as the awesomest band I can't stand to listen to.
05:27:22 <blackdog> is there any point to continuations in haskell?
05:27:41 <pesco> Continuations are sometimes useful.
05:28:12 <pesco> I've not used tho Cont monad though, but I've found myself pass continuation functions around on occasion.
05:28:12 <dons> they're good when you have to emulate continuations in other languages
05:28:53 <merkurie> hi, i've got a (i think) quick question
05:29:03 <merkurie> just trying to hack a friend's code
05:29:04 <Cale> merkurie: hello
05:29:14 <merkurie> trying to use putStr in a let in loop
05:29:22 <merkurie> hehe
05:29:25 <merkurie> can't figure it out
05:29:30 <merkurie> first time using haskell
05:29:47 <merkurie> *hopeful*
05:29:51 * Philippa_ often passes around a value of type IO thingy (or a func yielding one) as a continuation
05:29:59 <Philippa_> merkurie: what kind of loop?
05:30:08 <blackdog> how is it different to jjust specifying a computation lazily, though?  I don't understand the distinction.
05:30:09 <Philippa_> what're you trying to do exactly?
05:30:09 <merkurie> um actually
05:30:14 <Cale> putStr is an IO action, so you'd probably want do-notation.
05:30:18 <Philippa_> blackdog: in Haskell? Not really
05:30:34 <Philippa_> it's distinctly different in an impure language though
05:30:51 <merkurie> so, let var = blahblah in tree { a = var }
05:31:00 <blackdog> Yeah, I can grok that. Just curious as to whether it meant anything in the One Language to Rule Them All.
05:31:19 <Philippa_> Cale: assuming it's not a one-liner, eg mapM putStr stuff
05:31:30 <merkurie> hmmm ok
05:31:31 <Cale> Philippa_: yeah
05:31:45 <Philippa_> merkurie: what exactly are you trying to print?
05:31:51 <Cale> merkurie: what are you trying to accomplish?
05:31:57 <TheHunter> @eval id 3
05:31:58 <lambdabot> 3
05:32:06 <merkurie> i was just trying to print another var to figure out what was happening
05:32:07 <blackdog> merkurie: learn the simple do-notation stuff first. mapM and friends are cool, but it can obscure your understanding if you don't understand what it's actually doing...
05:32:20 <merkurie> how do i put do in let - in
05:32:22 <TheHunter> @karma dons
05:32:23 <lambdabot> dons has a karma of 0
05:32:33 <dons> nope. karma wasnt in darcs
05:32:36 <dons> @quote
05:32:36 <merkurie> er, i've been looking for a site or some examples in the code i've got here
05:32:38 <Philippa_> merkurie: it's probably not a matter of how you do it in a let statement
05:32:38 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
05:32:46 <merkurie> but... oooh
05:32:52 <merkurie> ok i'll try
05:32:56 <merkurie> be back in a sec ^_^
05:32:57 <Cale> merkurie: the way that IO works in Haskell is that functions build things called IO actions, which eventually get pieced together as "main"
05:33:15 <Philippa_> and thus the let statement's mostly-irrelevant
05:33:39 <Philippa_> but you /can't/ do IO in a function that doesn't return something of type "IO something" or similar
05:33:53 <Cale> (and this is a good thing)
05:33:58 <merkurie> it doesn't return a type IO
05:34:10 <merkurie> i've been getting type errors ^_^
05:34:22 <merkurie> or parse error on input tree
05:34:39 <Cale> If you just want a trace for debugging you can use the stuff in Debug.Trace, but don't use it for anything other than debugging
05:35:33 <merkurie> ok... i didn't even look at Debug hehe
05:35:34 <merkurie> i'll try that
05:35:37 <merkurie> thanks
05:35:41 <merkurie> =)
05:39:19 <Philippa_> the alternative is to change the type of the entire function (this is why Debug.Trace exists)
05:41:21 <merkurie> um agh sorry bout all the dumb ?s but do i have to do an import Debug?
05:41:29 <merkurie> i typed import Debug (trace)
05:41:35 <XTL> Firewall panic :(
05:41:43 <merkurie> but it says can't find module 'Debug'
05:41:49 <Cale> import Debug.Trace
05:42:10 <Cale> you can then use  trace :: String -> a -> a
05:42:39 <Cale> to print a string when the value is evaluated (which might be randomly)
05:45:28 <merkurie> !!&@#!?#
05:46:11 <merkurie> i put it under "in" so i've go
05:46:21 <merkurie> in trace "blah" var
05:46:32 <merkurie>    tree{ }
05:46:43 <merkurie> is that bad?
05:46:49 <merkurie> getting matching problems again
05:48:25 <Cale> well, rather than tracing, if the program is short, paste it on the paste page and let us have a look :)
05:48:35 <Cale> @paste
05:48:36 <merkurie> haha
05:48:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:50:20 <Cale> Prelude Ratio> let a = (maxBound :: Int)%1 in 1 < a && a < 1/2
05:50:21 <Cale> True
05:50:49 <Cale> comparisons at the boundary of Int seem to be messed up (or some interaction with Ratio?)
05:51:26 <merkurie> ok, it's up under jackie
05:51:39 <merkurie> i don't think i knew how i was supposed to do it, but it looks alright
05:51:42 <merkurie> haha
05:51:48 <merkurie> there are colors!
05:52:04 <Cale> :)
05:52:31 <merkurie> i tried trace in parens, didn't work either >.<
05:52:48 <Cale> is al a function?
05:52:54 <merkurie> just a var
05:52:56 <Cale> no, it's a list
05:52:58 <Cale> yeah
05:53:06 <Cale> so you can't apply it to te{...}
05:53:36 <Cale> perhaps you want trace (show al) te { ...}
05:53:56 <merkurie> kay...
05:55:02 <merkurie> the show turns it into a String?
05:55:06 <Cale> yeah
05:55:19 <Cale> @type show
05:55:31 <lambdabot> show :: forall a. (Show a) => a -> String
05:56:14 <merkurie> that is cool
05:56:27 <Cale> yeah
05:57:38 <merkurie> yay, it does something
05:58:17 <merkurie> is there any way to filter this output
05:58:24 <merkurie> i don't really understand how this trace works
05:59:03 <Cale> Well, it prints a value whenever that closure gets evaluated, which, since Haskell is lazy, is sort of random.
05:59:50 <Cale> You'll get some printouts of the value of al at various points if it's at all useful
06:00:41 <Cale> That code looks somewhat confusing.
06:00:41 <merkurie> hmmm ok, aaah can i put trace in the let?
06:00:54 <merkurie> well it's a small part of a lot of code
06:00:57 <merkurie> =/
06:00:58 <Cale> yeah, if you attach it to one of the definitions there
06:02:29 <merkurie> eg let al = ...; x = ...; trace (show al) x; in ...
06:02:53 <Cale> not like that
06:03:11 <Cale> you can attach it to a definition there, like, say the definition of x
06:03:33 <Cale> or the definition of al
06:03:41 <Cale> since that seems to be what you're interested in
06:03:47 <merkurie> mm... hehe
06:03:59 <merkurie> so that's not what i did?
06:04:12 <merkurie> i was trying to print al when x got defined
06:04:15 <merkurie> or evaluated
06:04:28 <Cale> x is that te {...} thing?
06:04:35 <merkurie> no, just some random thing
06:04:40 <merkurie> just added it
06:05:20 <Cale> oh, well, the things in the let part of a let statement must all be declarations
06:05:21 <merkurie> could i do trace "boo" al = map ...
06:05:26 <Cale> no
06:05:35 <Cale> because that would define trace :)
06:05:42 <merkurie> hahahaha
06:06:03 <merkurie> does that mean i'd have to use the string "boo" every time i called trace too?
06:06:38 <Cale> yeah, or the pattern wouldn't match
06:06:47 <Cale> (unless you made further definitions)
06:07:02 <merkurie> you couldn't have a variable ot anything called "boo", right?
06:07:06 <Cale> declaring something called trace inside the let would shadow the definition from Data.Trace
06:07:18 <merkurie> shadow?
06:07:40 <Cale> as in, you couldn't see the version from Data.Trace inside the let statement anymore
06:09:10 <merkurie> oh ok
06:13:39 <dustin`> okay, I want to do something like "instance Eq ((Eq a) => MyParameratizedType a) where ..."
06:14:26 <Lemmih> 'instance Eq a => Eq (YourType a) ...'
06:14:48 <merkurie> yay! the guy who wrote the code is back
06:14:54 <merkurie> thanks for helping out
06:15:03 <Cale> no problem
06:15:08 <merkurie> ^_^
06:15:19 <dustin`> Thanks!
06:15:27 <Cale> what was the error that you were getting anyway?
06:15:39 <Cale> (or was it a logical problem)
06:16:28 <dustin`> Though this confuses me, since from my view, instance shows that a certain type inhabits a certain typeclass, and it would seem that ((Eq a) => MyParamType a) *is* a type.
06:16:55 <Lemmih> (=>) is not a type constructor.
06:17:20 <dustin`> What is it?
06:18:05 <dons> just syntax!
06:19:00 <dustin`> Well then.
06:19:23 <Cale> it can occur in types
06:20:10 <Cale> "forall a. (Show a) => a -> String"
06:20:23 <merkurie> Cale: were you asking me?
06:20:24 <xerox> @version
06:20:25 <lambdabot> lambdabot 2p281, GHC 6.4 (OpenBSD i386)
06:20:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:20:31 <Cale> merkurie: yeah
06:20:36 <merkurie> Cale: i don't know yet, what error i was getting
06:20:43 <Cale> merkurie: ah
06:20:43 <merkurie> Cale: i'll let you know when we figure it out
06:21:18 <TheHunter> xerox:
06:21:20 <TheHunter> @pointless map fst . zip [1..]
06:21:21 <lambdabot> zipWith const [1..]
06:21:32 <xerox> Great :-)
06:21:52 <dustin`> Cale: instance still doesn't like that form, though IMO, that form makes it much more obvious and clear what is actually going on
06:22:47 <Cale> dustin`: yeah, in Haskell 98, explicit foralls were not around.
06:23:18 <Cale> dustin`: You can see it as saying when the instance will be defined.
06:23:40 <xerox> dons, hi! A question: which runplugs should I use for lambdabot? hs-plugins one, or the lambdabot bundled one?
06:24:02 <dons> the one in lambdabot is the one that is in cvs hs-plugins
06:24:27 <dons> best would be to install hs-plugins, compiled with 6.2.2
06:24:42 <dons> and then use the runplugs that comes with lambdabot
06:24:43 <basti_inf> wah
06:24:50 <basti_inf> forgot to logout my client at home
06:25:04 <dustin`> Cale: That makes some sense, thanks.
06:25:59 <basti_> luckily there's ghost!
06:28:54 <xerox> dons, I get an error in @plugs using last cvs snapshot and just-pulled lambdabot (both built with 6.4): "Compiled, but didn't create object"
06:29:11 <dons> yep. I know. i don't know what's going on there.
06:29:20 <dons> it's rather mysterious.
06:29:26 <dons> hence you need 6.2.2 with runplugs for now.
06:29:44 <dons> 6.2.2-compiled runplugs
06:29:51 <xerox> okay, I'll get a 6.2.2 binary for it.
06:40:24 <merkurie> Cale: so, i was having problems with looping too much and not being able to stop it. the al variable was a list that contained stop conditions, but wasn't working, so i was trying to see how to check out the stop conditions to see why. the trace worked, because i got to see what was in al, but that eventually didn't solve the problem, the stop conditions weren't thought out well enough... so, logic problem i guess. probably more info than you wanted. =P
06:40:57 <Cale> merkurie: cool
06:41:07 <Cale> good to hear it's solved
06:41:22 <merkurie> Cale: hehe, yeah, it's getting there =P
06:41:28 <Cale> what does the program do?
06:41:57 <merkurie> it's a generator for sentences using tree grammars, lexicons and semantics
06:42:21 <merkurie> which works, and i just wanted to make it work without needing semantics
07:08:39 <araujo> Hello people
07:13:29 <boegel_> hey araujo
07:22:13 <chr1s> hey, does anone know if I can convert an Int to a Float
07:22:27 <Darius> fromIntegral
07:22:43 <Darius> @plugs fromIntegral (1 :: Int) :: Float
07:22:53 <lambdabot> 1.0
07:23:39 <chr1s> thanks :)
07:25:48 <sond> does anyone know what name the gtk2hs guy goes by on irc?
07:25:51 <sond> :)
07:26:28 <sond> or should I say guys
07:27:10 <Darius> sond: What's their real names?
07:27:39 <sond> don't know.. wait
07:28:43 <sond> agh.. I'll just mail them instead
07:33:10 <TheHunter> grrr, ghc -D__HADDOCK__ -E -cpp. Why doesn't that define __HADDOCK__ ?
07:34:24 <TheHunter> ah, i see, probably -optP replaces arguments instead of appending them...
07:35:44 <TheHunter> ok, i got it. I need sed.
07:43:23 <nlv11757_> hmmm, i have a vast amount of functions calling eachother etc....but now im confronted with a big datatstructure needed somewhere down the tree.....is there an alternative to passing it as a parameter to allll those functions?
07:44:23 <TheHunter> have a look at implicit parameters.
07:44:31 <nlv11757_> k
07:44:32 <musasabi> or StateMonad.
07:44:54 <TheHunter> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html, section 7.4.5
07:47:30 <Itkovian> Which way do you recommend to install GHC on MacOSX? Fink or the ghc paclage from the ghc website?
07:48:08 <nlv11757_> statemonads would probably be the nicest way because it hides the passing of this datatstructure under water
07:48:22 <nlv11757_> hopefully making all my functions monadic wont be a pain in the behind
07:49:25 <jlouis> lambdabot question: how do I add a new module? Depends.conf?
07:49:41 <TheHunter> if you really need state, a state monad is your only option. Implicit paramters only provide a reader monad.
07:51:21 <tromp> or you canpass it by scoping
07:51:25 <Darius> nlv11757_: As TheHunter suggests, it sounds more like you want a reader monad than a state one.  If it turns out later that you need a state monad changing from a reader monad will be easy.
07:52:08 <musasabi> Just making the code use a monad with a descriptive name and use well named lifting operators..
07:52:25 <musasabi> then changing the monad (transformer stack) will be easy,
07:53:41 <TheHunter> somebody got an idea what's wrong with $(GHC) -D__HADDOCK__ -E -cpp -fglasgow-exts "$${i}" -o "$${i}pptmp"
07:53:53 <TheHunter> it ignores an #ifndef __HADDOCK__ ...
07:54:24 <nlv11757_> Darius, i will compare both to see which one im actually requesting
07:54:26 <nlv11757_> thanks
07:56:10 <nlv11757_> hunter, maybe using -optc-D__HADDOCK__ helps, im just guessing
07:57:25 <TheHunter> yeah, I'll try -optP.... thanks. Still, that's exactly the code that was on the mailing list.
07:59:07 <TheHunter> it shouldn't be that goddam hard.
07:59:53 <nlv11757_> wow, looks like ReaderMonad is exactly what i want
08:00:06 <nlv11757_> i should brush up my monad knowledge
08:00:19 <nlv11757_> i totally forgot about Readers, etc
08:01:57 <TheHunter> oh, it was my own fault... The code at two places looked to similar.
08:02:42 <nlv11757_> :D
08:03:07 <nlv11757_> so -D__HADDOCK__ worked after all?
08:03:13 <TheHunter> yes.
08:03:15 * TheHunter ducks.
08:05:02 <nlv11757_> :D
08:05:22 <nlv11757_> btw, why is the type of >>= 'm a -> (a -> m b) -> m b' and not 'm a -> (a -> b) -> m b'
08:05:28 <nlv11757_> is there a reason?
08:05:38 <TheHunter> there are liftM and fmap
08:05:40 <TheHunter> @type fmap
08:05:42 <TheHunter> @type liftM
08:05:47 <lambdabot> fmap :: forall (f :: * -> *) b a.
08:05:47 <lambdabot>         (Functor f) =>
08:05:47 <lambdabot>         (a -> b) -> f a -> f b
08:05:47 <lambdabot> bzzt
08:05:56 <TheHunter> @type Control.Monad.liftM
08:05:58 <lambdabot> Control.Monad.liftM :: forall r (m :: * -> *) a1.
08:05:58 <lambdabot>                        (Monad m) =>
08:05:58 <lambdabot>                        (a1 -> r) -> m a1 -> m r
08:06:27 <tromp> because you can do a lot morewith a->m b
08:06:38 <nlv11757_> explain
08:06:40 <nlv11757_> pls
08:06:40 <nlv11757_> :D
08:06:47 <tromp> for example list comprehensions
08:07:08 <tromp> it is crucial that you give a function mapping an item to a list of items
08:07:34 <tromp> otherwise you're stuck doing maps
08:08:01 <nlv11757_> but the 'm' in 'a -> m b' has to be the same one as the 'm' in 'm a'......so whats the extra freedom then?
08:09:09 <integral> if you're thinking of monads as countainers, a -> m b is returning a container, and so can contain more than one item,  a -> b can only return one item
08:10:25 <df_> oh, lambdabot is mumbling in channel again
08:10:49 <nlv11757_> that does make a little sense to me integral
08:10:58 <nlv11757_> im still not sure what tromp means though
08:11:01 <Igloo> Does anyone know what this would mean from FBSD? http://urchin.earth.li/~ian/truss.txt
08:11:07 * boegel jumps and shouts
08:11:37 <integral> nlv11757_: if m is [], then you can return a list rather than a single item.   If you're just returning a single item you've got a map rather than a concatMap
08:11:49 <boegel> if you guys would have to describe all the progress that Haskell made in the past few years, what topics should you mention ?
08:12:28 <boegel> I already have bindings for graphical libraries as OpenGL en GTK, and language features as arrows
08:12:31 <boegel> any more ?
08:13:21 <TheHunter> haddock doesn't support existentials?
08:13:40 <Lemmih> boegel: STM, GADTs.
08:13:42 <nlv11757_> integral: if m is [], why couldnt 'b'  in 'a->b' be [a]?
08:13:46 <JaffaCake> Igloo: what platform?
08:13:52 <Igloo> x86
08:14:04 <integral> nlv11757_: you'd be left with a [[a]] at the end then
08:14:07 <JaffaCake> strange, I thought bus error was an alignment problem
08:14:31 <integral> nlv11757_: remember that >>= :: m a -> (a -> m b) -> m b
08:14:58 <Igloo> I'm lead to believe (rom Linux people, admittedly) you only get SIGBUSs on x86 if you throw them yourself
08:15:16 <JaffaCake> on Linux, yes
08:15:25 <JaffaCake> on FreeBSD, you can get bus errors
08:15:35 <Igloo> Ah, OK
08:16:02 <JaffaCake> they have a specific meaning, but I can't remember exactly what it is
08:16:05 * nlv11757_ suddenly sees the light
08:16:39 <nlv11757_> i see its less restrictive now integral
08:16:42 <boegel> Lemmih: I have no idea what those are
08:16:57 <boegel> Lemmih: and I mean stuff that comes extra besides the Haskell 98 standard
08:17:26 <integral> nlv11757_: iirc in another formulation of monads with different basic operations there is a "flatten"-like function :: m m a -> m a
08:17:33 <Lemmih> Both GADTs and STM are new in GHC 6.4
08:17:35 <Philippa> yep, that's join
08:20:01 <nlv11757_> alright, enough monadism for today, time for leisure, cu all
08:22:06 <boegel> Lemmih: that's a bit to recent :)
08:22:24 <boegel> what are the most important applications/tools written in Haskell ? darcs, ...
08:22:44 <JaffaCake> GHC!
08:22:57 <boegel> oh, right :p :)
08:23:10 <boegel> I've mentioned that already, but I should mention it is written in Haskell too
08:23:46 <boegel> JaffaCake: anymore ?
08:23:50 <boegel> or is that it ? :p
08:24:47 <JaffaCake> boegel: hierarchical modules, and the package system?
08:25:10 <JaffaCake> concurrency, exceptions, async exceptions
08:25:17 <jlouis> Igloo: Bus errors are hardware generated, whereas segfaults are kernel generated.
08:25:38 <jlouis> So you usually see bus errors when alignment hits you on non-x86 CPUs
08:26:38 <JaffaCake> jlouis: is that true? I mean the page fault that triggers a SEGV is hardware generated too
08:27:48 <Igloo> jlouis: That's how I understood it, but that x86 hardware never did the things that would cause a SIGBUS. Like I say, though, my knowledge is Linux-based, so FBSD may use different definitions
08:28:19 <jlouis> JaffaCake: Well, the names originate from PDP-10, where they more or less had these meanings. FBSD blurs the distinction by returning bus-errors in other cases too
08:28:19 <Darius> Does any operating system turn on the x86's alignment checking?
08:28:24 * JaffaCake goes to check the kernel sources on his FBSD box
08:28:48 <jlouis> Cannot remember what my OpenBSD boxes do in fact
08:30:30 <jlouis> and it is clearly implementation specific on non PDP-10s so you may choose what you like
08:30:41 <JaffaCake> from i386/trap.c:trap_pfault():
08:30:42 <JaffaCake>  return((rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV);
08:30:42 <jlouis> You could just handle it as signal 11
08:31:20 <JaffaCake> so I'm guessing you get a SIGBUS if you try to write to read-only page, but a SIGSEGV if you try to access a non-existent page
08:32:23 <jlouis> in OpenBSD it traps SIGBUS on alignment and tss
08:33:02 <jlouis> and SIGSEG on the common case, protection and non-existence
08:33:18 <jlouis> /usr/src/sys/arch/i386/i386/trap.c
08:33:48 <JaffaCake> right, it's pretty OS-specific
08:34:05 <JaffaCake> I remember it being due to alignment on Solaris
08:34:10 <jlouis> JaffaCake: true
08:59:46 <jlouis> Now with a preliminary FactModule for lambdabot
09:18:09 <autrijus> is there a version of `rem` that always return positive number?
09:18:51 <autrijus> I have
09:18:51 <autrijus> until (> 0) (+ sz) idx
09:18:56 <Lunar^> autrijus: `mod` ?
09:19:05 <autrijus> Prelude> -1 `mod` 3
09:19:06 <autrijus> -1
09:19:31 <autrijus> but that "until" fails to positive numbers
09:19:35 <autrijus> I'd like a case that works for both.
09:20:21 <Lunar^> *sigh* I know... I don't remember how I solved that
09:20:45 <autrijus> and my junior high school math has left me already
09:21:40 <smott> use abs?
09:22:27 <autrijus> how?
09:23:03 <araujo> Hello haskell'ers
09:24:48 <smott> rem' x y = abs $ rem x y
09:24:52 <smott> like that i guess ..
09:25:13 <autrijus>  abs $ rem (-1) 3
09:25:14 <autrijus> 1
09:25:15 <autrijus> but I want 2.
09:25:37 <df_> thats mod
09:25:41 <Cale> @plugs (-1) `mod` 3
09:25:42 <df_> mod (-1) 3 = 2
09:25:46 <elmex> hm, is Haskell
09:25:46 <lambdabot> 2
09:25:47 <elmex> von Simon Thompson
09:25:49 <jlouis> heh, now we have @fact, @fact-set, @fact-cons and @fact-snoc
09:25:52 <elmex> a good foundation?
09:26:00 <autrijus> oh god.
09:26:03 <autrijus> Prelude> -1 `mod` 3
09:26:04 <autrijus> -1
09:26:10 <autrijus> I see that the precedence has failed me.
09:26:15 <autrijus> thanks.
09:26:57 <autrijus> whose idea is that to unify unary - and binary - under the same symbol?
09:27:01 <autrijus> ;)
09:27:50 <scalopus> hi
09:49:26 <Igloo> Hmm, there doesn't seem to be much in the way of docs in the STM hierarchial library docs. Anyone got a good pointer?
09:52:07 <pesco> Igloo: Have you read the paper?
09:52:13 <Igloo> No
09:52:54 <pesco> @google simon stm.ps
09:52:55 <Igloo> DYM http://research.microsoft.com/~simonpj/papers/stm/ ?
09:52:55 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/stm.ps
09:53:00 <pesco> :)
09:53:03 <Igloo> OK, ta  :-)
09:53:15 <pesco> np
09:58:56 <Oejet> Hej.
10:02:57 <Lemmih> Hey Oejet.
10:04:02 <xerox> @help search
10:04:04 <lambdabot>  @help <command> - ask for help for <command>
10:08:12 <xerox> dons, I got another kind of error, on @plugs: "0: Warning: Module `Data.FiniteMap' is deprecated: Please use Data.Map instead."
10:08:18 <xerox> (If it helps)
10:11:11 <Lemmih> sond: dcoutts is the gtk2hs guy, iirc.
10:11:25 <dcoutts> Lemmih: yep
10:12:18 <basti__> back
10:13:08 <dcoutts> Lemmih: was there a gtk2hs question I missed?
10:14:13 <Lemmih> dcoutts: sond asked for your irc handle some hours ago.
10:14:38 <dcoutts> oh, ok
10:16:37 <juhp> <sond> does anyone know what name the gtk2hs guy goes by on irc?
10:16:37 <juhp> <sond> :)
10:16:37 <juhp> <sond> or should I say guys
10:18:21 <Lemmih> musasabi: Was it you who ported Data.HashTable to STM?
10:19:33 <musasabi> Lemmih: yes, I did have some code to that effect I think.
10:19:50 <musasabi> I can look it up in a few hours when I get back to my machine.
10:28:54 <musasabi> JaffaCake: about the idea of sending signals to threads (on ghc-cvs), that won't work as signals are sent per process rather than per thread. (Broken linux implementation supports it but no other pthreads implementation does)
11:13:33 <KrispyKringle> anyone here use HaskellDB, by chance?
11:13:40 <Lemmih> Yeah.
11:13:54 <KrispyKringle> I'm having some trouble. I'm working on setting it up, and my connection is like:
11:13:58 <KrispyKringle> dbConnection = genericConnect "SQLite" ["localhost", "foo", "", "bar"]
11:14:06 <KrispyKringle> but when I run it, I get Fail: Database driver not compiled in or invalid driver
11:14:24 <KrispyKringle> Now, HSQL was configured with SQLite enabled, so what might be the problem?
11:14:51 <KrispyKringle> and on the output of the haskelldb configure, it says sqlite is supported for ghc
11:20:40 <KrispyKringle> i guess i wont be using haskelldb after all.
11:23:06 <Lemmih> It's called "sqlite" and now "SQLite".
11:24:01 <Lemmih> s/now/not/
11:24:05 <KrispyKringle> ihmm. i trie that, too.
11:24:33 <Lemmih> Then compile HaskellDB with sqlite support (:
11:24:38 <KrispyKringle> i did :P
11:24:47 <KrispyKringle> well, i thought i did. the config output says i did.
11:25:17 <KrispyKringle> ill redo it one more time, though.
11:25:58 <Lemmih> Wait. I see the error.
11:26:03 <KrispyKringle> yes?
11:26:13 <Lemmih> You can only give sqlite two arguments.
11:26:38 <KrispyKringle> being..the database name and...?
11:26:39 <Lemmih> Oh wait. That's not it.
11:26:52 <KrispyKringle> damn, ya got my hopes up, Lemmih ;)
11:27:18 <KrispyKringle> hey, that seems to be it
11:27:19 <KrispyKringle> now it runs
11:27:25 <KrispyKringle> *shrug*
11:27:29 <KrispyKringle> thanks, Lemmih :)
11:27:47 <Lemmih> It should bitch about wrong argument number.
11:27:55 <KrispyKringle> because i only gave it two?
11:28:23 <KrispyKringle> wel, it created the database.
11:28:42 <KrispyKringle> oh, wait.
11:28:44 <KrispyKringle> shit.
11:29:21 <KrispyKringle> im a moron.
11:29:39 <KrispyKringle> ajnyway, i got it working. my demo was bad. thanks for the help, and sorrt for the trouble.
11:29:44 <KrispyKringle> oi, and i can't type over ssh.
11:31:21 <_JusSx_> hey can i use emeac haskell-mode and ecb?
11:32:06 <svens> yes
11:44:21 * CosmicRay discovers hat.
11:44:23 <CosmicRay> looks useful.
11:44:27 * CosmicRay considers packaging for sid.
11:44:51 <CosmicRay> is anyone still maintaining it?
11:59:02 <Oejet> CosmicRay: Do you mean Haskell-mode?
12:00:04 * Lemmih stops himself from bashing Alexander Jacobsen.
12:03:03 <Oejet> Lemmih: Bash at Java instead.
12:05:24 <chucky> @seen bringert
12:05:25 <lambdabot> I haven't seen bringert
12:05:33 <chucky> :(
12:05:36 <CosmicRay> Oejet: no, I mean the hat debugger
12:06:28 <wagle> people keep restarting lambdabot
12:08:51 <chucky> I guess I *could* just call him, but I don't want to bother him that much
12:08:52 <Lemmih> Shouldn't the seen state be saved?
12:12:29 <Lemmih> Alex's complete misconception of Cabal is kinda sad considering all the improvements he want.
12:57:57 <jjang> hey
12:58:26 <jjang> when i use the monadic notation i get weird errors
12:58:41 <jjang> with x <- line of functions i can define a var right?
12:59:37 <juhp> jjang: can you show us? :)
12:59:46 <jjang> eh whats the local PB ?
12:59:49 <jjang> paste bin
13:00:01 <smott> @paste
13:00:02 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:02:12 <jjang> well i used pb: http://www.pastebin.com/270900
13:03:57 <jjang> http://www.pastebin.com/270901
13:04:03 <jjang> with the type definition
13:04:54 <juhp> jjang: let posX = round $ x - ((cos  angle) * (fromIntegral a) )
13:05:01 <jjang> ok
13:05:11 <Lemmih> jjang: 'round $ ...' isn't a monadic action.
13:05:22 <jjang> i need to use ()?
13:06:01 <juhp> jjang: either "do let ..." or "let .... in do"
13:06:07 <jjang> ok
13:06:23 <Lemmih> I don't see the use of an empty tuple in this case.
13:06:49 <elmex> hm, i haven't written haskell for a long time now... but i used to write some code in it... does anyone know how i get a new entrance quick? some examples? for example small networking examples?
13:07:32 <jjang> thanks kinda works
13:08:04 <beschmi> elmex: what about http://kyagrd.dyndns.org/wiki/HaskellServerProgramming ?
13:08:31 <elmex> beschmi: thats great, exactly what i searched ;)
13:31:15 <CosmicRay> I think I am in need of some monad mojo.  I'm writing some code that consists of a series of tests.  Each test will either generate one item that should be added to a list, or it may generate 0 items.  I thought of using the List monad at first, but it seems highly clumsy in this situation
13:31:21 <CosmicRay> am I missing some helpful construct?
13:31:58 <Cale> Writer monad?
13:33:10 <wilx> But you also need to first results come first, right?
13:33:21 <wilx> Maintain order.
13:33:42 <wilx> If so it sounds a bit like my problem :)
13:34:09 <Cale> It's probably better just to reverse the list afterwards
13:34:09 <Igloo> What do the tests do?
13:34:29 <wilx> Sounds easy if you know how long it will be.
13:34:40 <wilx> But what if it is infinite or very near that? :)
13:35:00 <Igloo> Why not just concatMap (do_test :: Test -> [Item])?
13:35:38 <Igloo> Or catMaybes $ map (do_test :: Test -> Maybe Item)
13:35:55 <Igloo> s/\$/./
13:43:08 <jlouis> I would go for catMaybes
13:44:04 <CosmicRay> hmm
13:44:09 <CosmicRay> got to afk, argh
13:44:10 <CosmicRay> brb
13:56:39 <chr1s> what's the difference between . and $
13:56:59 <chr1s> and where do I find answers to questions like that
13:57:45 <kaol> @google Prelude.hs
13:57:47 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
13:57:48 <zamez> iirc the difference is just precedence
13:59:02 <Igloo> No, they have different types
13:59:27 <Igloo> Intuitively, with . you are leaving the argument off the end
13:59:41 <Igloo> foo . bar   vs   foo $ bar xs
13:59:51 <chr1s> ah
14:00:26 <chr1s> Really fun, I have a haskell exam tomorrow morning
14:00:48 <chr1s> I really like haskell, on the computer. But when I have to do everything on paper and remember every type
14:00:54 <chr1s> It's not that fun.
14:01:51 <SamB> I know what you mean...
14:02:24 <chr1s> define blablbal in terms of foldr
14:02:41 <SamB> that isn't so bad...
14:02:42 <chucky> chr1s: Writing Haskell on paper is a breeze compared to say writing OpenGL programs in C on paper
14:02:48 <chr1s> lol, yeah.
14:02:58 <Igloo> They probably won't care if you get the arguments in the wrong order or something
14:03:01 <chucky> and I have this example because I have done it. :)
14:03:07 <Igloo> As long as you're consistent
14:03:14 <chr1s> they do. The teacher is really precise.
14:03:37 <chr1s> He's a teacher with the high-school mentality
14:03:40 <chucky> ouch
14:04:09 <SamB> yeah, really. typecheckers are comparatively kind.
14:04:18 <chr1s> I'm studying at the university, but he treats us as if we where 16 or something
14:04:25 <chr1s> :s/whe/we
14:04:31 <SamB> (you get to fix and try again with typecheckers ;-)
14:05:02 <chr1s> SamB: I'm Dutch.
14:05:14 <jjang> university of utrecht?
14:05:16 <chr1s> oh, nm
14:05:19 <chr1s> jjang: yes
14:05:23 <jjang> tentamen morgen?
14:05:26 <chr1s> jup.
14:05:29 <jjang> ik ook ;p
14:05:32 <chr1s> wie ben jij?
14:05:39 <jjang> Tom
14:05:43 <SamB> chr1s: by typecheckers, I mean the part of a Haskell compiler that infers/checks the type of your program
14:05:54 <SamB> well, types
14:06:04 <chr1s> SamB: I got it after I pressed <CR>
14:06:16 <jjang> ik heb nog nie geleerd
14:06:25 <chr1s> jjang: ik heb een hekel aan die Prolog en Parser Combinators.
14:06:32 <jjang> niet leren
14:06:33 <RemiTurk> hi guys
14:06:37 <jjang> krijg je toch niks over denk ik
14:06:39 <RemiTurk> niet leren? waarom niet?
14:06:40 <_JusSx_> http://www.masturbateforpeace.com
14:06:50 <chr1s> RemiTurk: je hebt toch niet ook toevallig morgen tentamen?
14:06:54 <RemiTurk> nopes
14:06:59 <_JusSx_> have a good reading
14:07:14 * RemiTurk vraagt zich af waarover & aan welke univ?
14:07:19 <chr1s> haskell @ uu
14:07:27 <jjang> morgen haskell tentamen
14:07:37 * RemiTurk vraagt zich af waarom de UvA niks aan haskell doet ;)
14:07:45 * RemiTurk will stop writing in dutch
14:07:47 <jjang> wees blij
14:07:52 * jjang too
14:08:13 * RemiTurk thinks it would be great to get a few "vrijstellingen" for haskell courses ;)
14:08:20 <jjang> lol
14:08:26 <skew> what's the "af" in vraagt zich af?
14:08:39 <RemiTurk> the verb is "afvragen"
14:08:47 <chr1s> to ask yourself
14:08:55 <skew> Oh. I recognized the vragen part
14:08:57 <RemiTurk> zich = your (in this case)
14:09:13 <chr1s> ik vraag me af is I ask me af
14:09:20 <skew> Okay. sich is yourself in german, if I recall correctly
14:09:22 <chr1s> I ask myself af
14:09:28 <chr1s> yes
14:09:32 * RemiTurk thinks it's actually pretty weird to split a verb in two halves
14:09:50 <skew> if_then_else?
14:10:06 <RemiTurk> I wouldn't mind if `if' were a regular function :P
14:10:13 <RemiTurk> @wiki ThingsToAvoid/Discussion
14:10:14 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid/Discussion
14:11:02 <RemiTurk> (the bottom)
14:11:12 <jjang> damnit
14:11:27 <jjang> cant i use a do after a guard check?
14:11:47 <RemiTurk> show us the code...
14:11:58 <RemiTurk> btw, does anyone use ddata's MultiSet?
14:12:14 * boegel bounces
14:13:14 <jjang> oh it were just some retarded no sense making errors from the compiler
14:14:23 <jjang> chr1s: already started on the turtle?
14:15:03 * RemiTurk asks boegel whether bouncing implies MultiSet-usage
14:15:08 <chr1s> I've finished the assignment
14:15:15 * boegel has no idea
14:15:20 <chr1s> I've add color and penWidth and goto and mouseclicks.
14:15:30 <jjang> finished?
14:15:37 * boegel can speak Dutch too: stomme Hollander !
14:15:39 <chr1s> yeah, I really like it
14:15:42 <boegel> :p
14:15:44 <jjang> you did?
14:15:47 <jjang> i hate it
14:15:54 <jjang> i can draw that kubus almost
14:15:59 <chr1s> it's really cool
14:16:07 <chr1s> when you get the hang of it
14:16:23 <jjang> i think i finished the hard part
14:16:39 <chr1s> If I pass the exam, this will be the first course I pass without going to college at all
14:17:01 <chr1s> practical assignments are no problem, but the exams are though.
14:17:27 * RemiTurk makes boegel a compliment about his name-calling ability in dutch
14:17:31 <skew> chr1s: without going to class at all?
14:17:36 <chr1s> yeah.
14:17:41 * Philippa doesn't really speak Dutch, but was in a dutch pub on monday - does that count?
14:17:44 <Philippa> (the beer was good)
14:17:53 <chr1s> I did half of the course last year
14:17:56 <jjang> i can have a 1 for the exam ;p
14:18:01 * RemiTurk guesses it wasn't Heineken then
14:18:03 <chr1s> There's like this combined course of prolog and haskell
14:18:11 <Philippa> RemiTurk: damn right it wasn't
14:18:19 <Philippa> though a fair amount of what they had was belgian too
14:18:21 <chr1s> Philippa: Grolsch?
14:18:22 <boegel> Can I have sex for peace?
14:18:22 <boegel> Up to you. But remember, there's no reason you can't masturbate with a friend. Or two. Or three.
14:18:24 <boegel> hehehe
14:18:35 <chr1s> boegel: wtf?
14:18:52 * Philippa didn't catch what the peach beer was called...
14:18:54 <boegel> boegel is just checking the website _JusSx_ mentioned
14:19:14 * RemiTurk once held a poll on a belgian forum about the relative merits between Heineken and dish water
14:19:24 <Philippa> I'm guessing dish water won
14:19:31 <RemiTurk> it ended 50-50
14:19:50 <Philippa> hrmm... I guess Heineken makes a slightly more efficient toilet cleaner?
14:19:55 <jjang> damn penalty shootouts
14:20:04 <jjang> anyone watches soccer here?
14:20:04 <RemiTurk> which was grand, as a friend of mine (who set up the forum) loves Heineken
14:20:10 <Philippa> poor bastard :-)
14:20:23 <boegel> jjang: yeah, but I don't like it
14:20:24 <RemiTurk> nopes *watched inspector frost*
14:20:34 <jjang> oh to bad
14:21:01 <jjang> psv kicked lyon
14:21:04 <boegel> actually, the whole idea to run after the ball until you have to put it in the middle of the field again is quite stupid
14:21:05 * RemiTurk will just bother Daan about his MultiSet bug
14:21:21 <musasabi> Philippa: please no heineken into a toilet it will reek of bad beer (not that good beer exists).
14:21:26 <RemiTurk> I don't mind running after the ball so much
14:21:36 <chr1s> soccer is so boring
14:21:45 <RemiTurk> it's especially watching other people run after the ball that irritates me
14:21:55 <RemiTurk> especially when that prevents me from watching tv
14:22:24 <Philippa> musasabi: I know a few people thought that 'til I dragged them to the right pub :-)
14:22:35 <mattam> jjang: yeah that's sad.
14:22:46 <jjang> its a good thing
14:23:26 <jjang> psv won and my friggin turtle app works
14:23:36 <jjang> and feyenoord lost
14:23:41 <jjang> this they cant be better
14:23:50 <jjang> they= day
14:24:35 <chr1s> I spent like a day or something getting wxwidgets to work under debian. all for the turtle app
14:25:31 <jjang> ye
14:25:35 <jjang> terrible documentation
14:25:47 <chr1s> well, I mean getting it installed
14:25:47 <jjang> also that compiler bugs my pc like hell
14:25:49 <jjang> ye
14:25:57 <jjang> i spent a few hours installing it
14:26:09 <sond> what's the turtle app?
14:26:23 <mattam> jjang: actually the game wasn't fair, the referee missed way to much things
14:26:25 <jjang> some bullshit app which draws lines and a turtle
14:26:34 <jjang> mattam: ye, in advantage for lyon
14:26:41 <sond> aha.. a logo program
14:26:46 <chr1s> yes
14:26:50 <jjang> diara or however its spelled should have a red card
14:26:50 <RemiTurk> jjang: be happy you don't have to do it in java ;)
14:27:00 <jjang> i like java more
14:27:04 <jjang> requires less brain
14:27:11 <sond> chr1s, taking a course in functional programming?
14:27:12 <chr1s> sond: something like http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/old/solutions/arjan/
14:27:12 <RemiTurk> heresy! heresy!
14:27:14 <RemiTurk> ;)
14:27:16 <chr1s> sond: yes
14:27:16 <mattam> jjang: like when it missed the penalty ? are you kidding ?
14:27:18 <pesco> Logo rocked!
14:27:26 <sond> chr1s, okay.. i've done that course :)
14:27:39 <chr1s> yes
14:27:40 <jjang> u mean when gomez wanted to grab the ball?
14:27:59 <mattam> nilmar
14:28:00 <chr1s> I really dislike java
14:28:11 <pesco> I remember cramming a COMAL cartrige into a Schneider PC to run Logo on it.
14:28:15 * RemiTurk considers dropping haskell for ocaml when #haskell starts about dutch soccer
14:28:17 <chr1s> The idea is good, but they make things way too complicated
14:28:20 <musasabi> Philippa: yes, some people say that.. I have learned that different kinds of beer taste bad in different ways ;)
14:28:46 <mattam> the referee didn't even see a foul... anyway i'm not that much a soccer fan
14:28:55 <jjang> but you are french?
14:29:05 <mattam> yes
14:29:08 <jjang> ok
14:29:29 <chr1s> soccer     :s/occ/uck
14:29:31 <chr1s> I think.
14:29:33 <jjang> well it always sucks seeing your country lose
14:29:53 <chr1s> Victory est nous
14:29:58 <chr1s> or something like that
14:29:59 <metaperl_> isn't it asking a lot to have 3 referres oversee the actions of 22 people?
14:30:13 <metaperl_> the math does not quite work ot in my eyes...
14:30:26 <chr1s> metaperl_: simplify it. 3 referrees are watching one ball
14:30:28 <mattam> but i was not happy when france won against brazil at the world cup for example, so don't judge my opinions on that ;)
14:30:39 <chr1s> that's just overkill
14:30:40 <jjang> why not happy?
14:30:47 <jjang> dont you have some french pride?
14:30:55 <mattam> nope not at all
14:31:05 <jjang> ok
14:32:11 <mattam> i'm glad i'm not alone in this case actually ! When you see how hateful people can get for just soccer...
14:32:39 * CosmicRay finally returns
14:32:53 * RemiTurk almost had lost hope
14:33:01 <boegel> mattam: people can get hateful over a lot less than soccer too
14:33:11 <CosmicRay> RemiTurk: heh
14:33:15 <chr1s> let's talk about Monads
14:33:25 <RemiTurk> people can get hateful about Monads too
14:33:27 <mattam> metaperl_: that's right, commentators talk about more referees for a long time, but nothing happens
14:33:29 <Philippa> I'm told it really hurts if you get kicked in them?
14:33:30 <chr1s> those really are way more interesting than soccer
14:33:33 <RemiTurk> then again, Monads are quite a bit more than soccer
14:33:39 <chr1s> ./join #soccer
14:33:59 <chr1s> Monads are way more complicated. Especially in the beginning
14:34:15 <Philippa> I dunno. The monad laws're simpler than the offside rule
14:34:18 * pesco reappears.
14:34:20 <mattam> they are much more elegant in general
14:34:44 <CosmicRay> hey, its RegexMan!
14:34:53 <pesco> @quote mattam [Monads are] much more elegant [than soccer] in general.
14:34:54 <lambdabot> mattam [Monads are] much more elegant [than soccer] in general. hasn't said
14:34:54 <lambdabot> anything memorable
14:35:03 <CosmicRay> heh
14:35:13 * pesco mumbles something.
14:35:18 <CosmicRay> lambdabot apparently thinks nicks can contain spaces
14:35:22 <mattam> :)
14:35:38 <pesco> CosmicRay: Today I'm Command Line Man again.
14:35:39 <CosmicRay> this could be fun.
14:35:42 <CosmicRay> pesco: heh
14:35:45 <pesco> @quote mattam "[Monads are] much more elegant [than soccer] in general."
14:35:47 <lambdabot> mattam "[Monads are] much more elegant [than soccer] in general." hasn't
14:35:47 <lambdabot> said anything memorable
14:35:50 <CosmicRay> @quote George Bush
14:35:52 <lambdabot> George Bush hasn't said anything memorable
14:35:55 <CosmicRay> true.
14:36:18 <CosmicRay> though I'm partial to "There's rumors in the internets" myself.
14:36:40 <pesco> @remember mattam [Monads are] much more elegant [than soccer] in general.
14:36:41 <musasabi> Monad laws are simple but the resulting interactions are not always very simple.
14:37:12 <RemiTurk> neither is trying to predict the interactions of 22 players on a field with one ball ;)
14:37:26 <jjang> cant i do let x | bla ; | otherwise = ?
14:37:28 <jjang> in a do?
14:37:52 <RemiTurk> why not?
14:38:10 <xerox> Maybe without ';' ?
14:38:13 <jjang> because it gives errors
14:38:23 <jjang> ; is supposed to mimic a new line in irc
14:38:26 <chr1s> the ; is needed in a do when you use {}
14:38:50 <chr1s> what are you trying to accomplish?
14:39:10 <RemiTurk> foo b = do
14:39:10 <RemiTurk>     let x
14:39:10 <RemiTurk>             | b     = ()
14:39:10 <RemiTurk>             | otherwise = ()
14:39:10 <RemiTurk>     return x
14:39:12 <RemiTurk> works fine
14:39:23 <jjang> i want to execute a function if a var is true
14:39:28 <jjang> otherwise i dont wanna do anything
14:39:43 <RemiTurk> perhaps you didn't get the layout correct?
14:39:44 <chr1s> when var blabalbal
14:40:03 <jjang> when var function ?
14:40:05 <chr1s> @type when
14:40:07 <chr1s> yes
14:40:11 <lambdabot> bzzt
14:41:23 * chr1s is afk
14:41:29 <jjang> mm
14:41:35 <jjang> weird errors
14:42:53 * RemiTurk finally understands why his changes don't seem to have any effect: he's two files in different directories
14:43:13 <skew> that's all it takes to implement RemiTurk?
14:44:43 * RemiTurk doesn't understand skew (I had a file in 2 directories and edited one and GHCIed the other)
14:44:51 <_JusSx_> http://www.sextutor.com
14:45:17 <skew> I read "he's ..." as "he is two files in different directories"
14:46:25 <pesco> "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
14:47:06 <RemiTurk> LOL :)
14:47:44 <RemiTurk> hm, my english tutor didn't like people abbreviating has to 's, this is probably why ;)
14:47:55 <xerox> Do you know how to load HaddockModule to lambdabot? Adding Haddock to the PLUGINS= list in config.mk.in and autoreconf seems to not be enough.
14:48:32 <skew> I don't know when that works out
14:48:43 <skew> I think anything you can "has" you can "is"
14:49:56 <RemiTurk> hm, I doubt it
14:50:20 <RemiTurk> inspired by the strange links some people keep posting here...* "She has sex" => "She is sex"?
14:50:30 <skew> hmm
14:50:42 <skew> The latter is a bit odd.
14:51:02 <gzl> what would HaddockModule for lambdabot do?
14:51:33 <skew> That only happens with verbs, though
14:52:11 <skew> hmm
14:52:19 <musasabi> Any opinions on keyboard layouts for coding ?
14:52:29 <xerox> gzl, it provides the @index feature
14:52:56 <xerox> gzl, btw I found my problem, adding the name there _is_ enough, I needed to actually _install_ haddock :-)
14:55:10 <Oejet> musasabi: They are invaluable to me. :-P
14:55:59 <Oejet> musasabi: Danish qwerty keybord sucks.
14:56:02 <xerox> @version
14:56:03 <lambdabot> lambdabot 2p281, GHC 6.4 (OpenBSD i386)
14:56:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:56:54 <musasabi> Oejet: currently I am using english qwerty + tweaks to get finnish letters out, but I am trying to decide whether to learn dvorak or not.
14:57:10 <skew> I've been thinking about dumping keylogger output into a layout generator to see what I get
14:57:43 <chr1s> A friend of mine has the follow problem:
14:57:58 <skew> I wonder how it would work to have the keys on the keyboard map to some kind of MRU ordering over characters typed
14:57:59 <chr1s> he does something like this in a function
14:58:19 <chr1s> | radius == (Just x) = function x
14:58:49 <chr1s> but ghc complains that you can't use x in the part after =
14:58:54 <chr1s> why's that?
14:59:05 <skew> That's trying to use an x from outside, and only work for one case
14:59:30 <skew> like let x = 1 ; myfunction radius | radius == (Just x) = function x
14:59:43 <skew> is equivalent to let myfunction radius | radisu == (Just 1) = function 1
14:59:59 <skew> Why put radius in a guard like that?
15:00:13 <skew> is sounds like they want to pattern match
15:00:14 <chr1s> don't know, but that's the way he wanted to solve it
15:00:31 <Oejet> musasabi: Get a keylogger and log your keys for the next week.  Then see if the key frequencies fit Dvorak.
15:00:33 <skew> myfunction (Just x) = function x ; myfunction Nothing = ???
15:00:35 <chr1s> yes, I think he should use a helper function
15:00:48 <skew> wait, where is radius coming from
15:01:03 <chr1s> well, radius is in a where
15:01:14 <chr1s> so he can't do that with pattern matching
15:01:18 <chr1s> he should use an extra function
15:01:21 <skew> oh. That's what pattern guards are for
15:01:32 <skew> | (Just x) <- radisu = function x, I think
15:01:45 <skew> as long as he renames the variable to radisu
15:01:47 <chr1s> hm
15:01:53 <gzl> xerox: are you sure you were talking to me about it? :)
15:02:00 <chr1s> why rename it?
15:02:10 <skew> so it matches my code
15:02:18 <chr1s> lol
15:02:40 <musasabi> Oejet: will try that :-)
15:02:51 <skew> I don't think I've actually used pattern guards, but there's a paper about them (by Peyton-Jones), and maybe a tiny bit in the user's guide
15:02:53 <xerox> <gzl> what would HaddockModule for lambdabot do?  I answered to that
15:03:28 <gzl> oh, I meant about your second statement. but I guess it follows from the first one
15:04:17 <xerox> Do anybody know where I can find "HsSyn" ?
15:04:44 <skew> chr1s: okay, for a pattern guard the stuff between | and = is a comma separated list of either Bool expressions, or pattern "<-" expression
15:05:01 <xerox> hiya shapr!
15:05:05 <shapr> hiya xerox
15:05:27 <skew> matching goes down each in turn, evaluating the booleans, trying the pattern matches, and giving up on this guard if a Bool is False or a pattern match fails
15:05:32 <shapr> I just bought one of the Sony mp3 players are mentioned on Slashdot. Doesn't work so well with Linux though :-(
15:05:35 <skew> hi shapr
15:05:44 <shapr> greetz skew
15:05:52 <RemiTurk> hi
15:06:01 <skew> is "greetz" in my native tounge?
15:06:14 * shapr was wondering that also
15:06:17 <skew> greetz shapr
15:06:31 * kosmikus is slowly realizing that the world is still turning
15:06:41 <shapr> kosmikus: did you get them in under the deadline?
15:06:46 * RemiTurk wonders what made kosmikus forget it
15:07:11 <xerox> shapr, do you know what and where HsSyn is?
15:07:14 <kosmikus> shapr: yes, both
15:07:26 <boegel> hi shapr
15:07:29 <shapr> hoi
15:07:45 <shapr> xerox: I'm guessing either PrettyPrint or Template Haskell, am I right?
15:07:57 <shapr> kosmikus: awesome!
15:08:14 <skew> shapr: did you ever get the concurrent reduction stuff working in Aardappel?
15:08:21 <shapr> So, anyone know how to initialize one of these Network Walkman critters in Linux?
15:08:26 <xerox> shapr, dunno really, I tried removing Haddock from EXCLUDED_MODS=, and I get an error about it.
15:08:33 <shapr> skew: no, I got stuck on the "install Java" part.
15:08:42 <shapr> xerox: oh yeah!
15:08:59 <musasabi> Isn't HsSyn the thing that GHC uses internally?
15:09:14 <skew> shapr: is that a problem?
15:09:15 <xerox> shapr, I'm probably doing something wrong.
15:09:28 <skew> Haven't you ever needed to do some web stuff in Java?
15:09:30 * boegel is bored
15:09:39 <shapr> xerox: HaddockModule is actually Haddock's Main.hs with some changes.
15:10:00 <shapr> skew: Yes, I had a job doing J2EE for awhile. I still have flashbacks.
15:10:24 <skew> I see.
15:10:36 <xerox> shapr, I added it to config.mk.in's PLUGINS=, but it compares under EXCLUDED_MODS= in the Makefile.
15:10:37 <Oejet> shapr: Great, then the nightmares have finally stopped?
15:10:57 <shapr> Oejet: just don't wake me up with that coffee cup with Duke on it.
15:11:02 <skew> It shouldn't be too hard to generate J2EE code with the right set of combinators
15:11:26 * shapr has a conniption
15:12:19 <shapr> This is the first time in a looong time I've wished I had a copy of Windows handy.
15:12:47 <shapr>  Likely I'll take the easy way out, and just take the Walman back to the store.
15:13:22 <shapr> boegel: you could write code!
15:13:36 <RemiTurk> shapr: so could you!
15:13:39 <shapr> skew: do you think playing with Aardappel is worth installing Java?
15:14:18 <shapr> RemiTurk: true, I could set up the Author's wiki for TMR2
15:14:18 <skew> boegel: I had a great idea for a keyboard mapping with some order over the buttons, and characters mapped MRU to that
15:14:25 <skew> shapr: if it worksw
15:14:31 <skew> it's pretty cool
15:14:38 <shapr> fair enough
15:14:40 <skew> the ordinary reduction part seems to work fine
15:14:57 <boegel> skew: what has that got to do with me ? :)
15:15:10 <skew> the bags that are supposed to make trees reduce concurrently seem to just make them sit there and turn red
15:15:24 <skew> boegel: well, somebody suggested you could code something to be less boring.
15:15:32 <shapr> I guess it won't work with jrvm and classpath?
15:15:33 <skew> and I gave you an idea for something to code
15:15:41 <Oejet> shapr: Yay, authors wiki for TMR.  :-)
15:15:43 <skew> shapr: what's that?
15:15:47 <skew> jr?
15:15:49 <shapr> open source java stuff
15:15:52 <shapr> jikes research vm
15:16:03 <skew> I don't know. Does that do RMI and classloader stuff?
15:16:09 * shapr doesn't remember
15:16:15 <skew> I think those are the wierdest bits Aardappel uses
15:16:38 <skew> RMI for distribution if you run it distributed (probably don't need it standalone), and classloader for evaluation
15:16:44 <musasabi> shapr: the thing does not work as an USB storage device?
15:17:05 <boegel> skew: I have lot's of work to do, but I don't feel like it right now
15:17:07 <skew> because it compiles trees to bytecode in memory, and grabs them with a custom classloader
15:17:32 <shapr> musasabi: it does, actually
15:17:56 <shapr> musasabi: But, none of the other files mentioned in FILE_FORMAT.txt are there, and I can't get the clicky ui to work.
15:18:04 <musasabi> aah.
15:18:11 * boegel gave a lesson on RMI last year, it's quite tricky
15:18:28 <shapr> The demo in the store worked fine, so I think it wants to install software on the player before it'll work.
15:18:43 <musasabi> we have just a cheap mp3 player and just mount the usb-storage device and cp/rm files there.
15:19:01 <musasabi> of course a working UI sounds nice.
15:19:06 <skew> boegel: I remember it being pretty easy if you don't care about getting it right :)
15:19:17 <shapr> This network walkman sure does *look* sexy. Too bad it can't actually play music.
15:19:42 <skew> turn off security, don't do anything intelligent with RMIExceptions, etc.
15:20:06 <skew> shapr: I don't need windows much either
15:20:13 <shapr> Did you see the slashdot article from a few hours back? A guy in Ireland figured out the obfuscated MP3 format the Network Walkman uses. I thought that would be enough :-/
15:21:00 * RemiTurk is looking (in vain, obviously) for a portable ogg-vorbis player working with linux I can actually pay too
15:21:46 <skew> ocassionally I get nostalgic over some old Dos game, but I find dosemu is better at running old dos programs than modern windows
15:21:53 <skew> RemiTurk: How about a neuros?
15:22:16 <skew> too pricy?
15:22:17 <shapr> Huh, I have excellent karma on Slashdot. How high can it get?
15:22:37 <shapr> skew: truly, same for wine.
15:23:14 <skew> wine doesn't seem to work very well for me
15:24:20 <RemiTurk> skew: looks
15:26:17 <Philippa> skew: damn right the emulators are - just getting SB-compatible hardware these days is hell
15:26:34 <Philippa> it occurred to me recently that somebody should port UFO:Enemy Unknown to the GBA...
15:26:54 <skew> the website may not mention anything about vorbis, but monty himself wrote vorbis code for it
15:26:58 * RemiTurk waits for interest on his almost empty bank account to be payed out ;)
15:27:42 <skew> hmm, some of those things are bigger than my hard drive!
15:27:55 <RemiTurk> same here
15:28:24 <RemiTurk> at least the bundled version talks about linux
15:28:28 <RemiTurk> s/linux/ogg/
15:28:33 <chr1s> RemiTurk: http://www.ipodlinux.org
15:29:00 <awarth> so can anyone explain to me how doing i/o with monads preserves referential transparency?
15:29:15 <shapr> awarth: everything is explicitly passed.
15:29:37 <musasabi> awarth: think code in io-monad generating a program that is then interpreted by the runtime system.
15:30:06 * Philippa likes the State (World) a explanation, but hey
15:30:28 <Philippa> awarth: you can theoretically have a functional program that passes around and modifies a World value - that is, the state of the universe the computer running the program belongs in
15:30:46 <Philippa> the problem with this is that duplicating World values does weird things we can't model accurately
15:30:55 <skew> RemiTurk: Well, a friend bought one a few years back, and has firmware for that the does ogg
15:31:15 <skew> RemiTurk: and there is open source work on firmware, so there's probably still support
15:31:16 <Philippa> the IO monad lets you preserve that model while never seeing the World itself
15:31:17 <musasabi> Philippa: isn't the World model more suitable for languages like Clean which have uniqueness typing.
15:31:19 <awarth> philippa: right, right, I've heard that before, and I understand the problems with (1) duplicating the world, and (2) "throwing away" the world
15:31:31 <awarth> (it's like the world is of a linear type)
15:31:45 <shapr> In fact, Clean uses uniqueness types.
15:31:47 <musasabi> btw are there any good papers on the semantics of uniqueness typing vs monads?
15:31:56 <Philippa> musasabi: it's a lot more visible there, but it still gives a good explanation re "why is it still a pure function?" - you can translate the IO monad to a hypothetical unwrapped World
15:31:57 <shapr> wait, he just that
15:31:57 <shapr> doh
15:32:04 <shapr> I obviously need sleep.
15:32:06 <awarth> but still, it seems like when you start thinking about modifying the world and such you really lose all of the nice things related to referential transparency... you can't really reason about your program like you could w/o that stuff.
15:32:15 <RemiTurk> skew: it looks good, so I'll save the link and shut up till I've got enough money ;)
15:32:31 <musasabi> awarth: think about the world as just a value that is passed around.
15:32:40 <skew> RemiTurk: you should hunt around and make sure you can find ogg support
15:32:41 <Philippa> awarth: that's the other place where the monadic model's nicer than you might think - because of return, you get to spend a lot of time doing stuff you know's pure
15:32:45 <musasabi> awarth: and code in IO monad returning a new world..
15:32:55 <xerox> goodnight folks.
15:33:01 <RemiTurk> night
15:33:03 <shapr> g'night xerox
15:33:05 <musasabi> So getChar :: IO Char, is actually getChar :: World -> (World, Char)
15:33:08 <musasabi> night.
15:33:27 <chr1s> goodnight
15:33:57 <skew> (\world -> let { w1 = invest world ; w2 = party world } if happiness w1 > happiness w2 then w1 else w2)
15:37:16 * shapr would rather party.
15:38:17 * Philippa would love to have the money to invest...
15:38:22 <awarth> ok, i get what you guys are saying about monads and passing the world around. but there's no question that the world is a "funny" sort of value. if you've got a function f of type, say, Integer -> Integer, you know that f(3) = f(3). but if you've got a monad, you can't really think like that. since i/o code changes the world, you don't really have an analog to f(world) = f(world), because you can't really talk about the world like that, because you c
15:38:22 <Philippa> as-is, party is thus mandatory ;-)
15:38:22 <awarth> an't ever "hold the world in your hands". that just doesn't seem right.
15:38:49 <Philippa> it's no worse than any other abstract data type in practice
15:38:51 <awarth> granted, doing i/o with infinite lists (the stream model) was annoying, but at least it seemed a lot more pure.
15:39:03 <skew> awarth: You do have f(world) = f(world), though
15:39:10 <skew> it's not the same world all down the line
15:39:13 <Philippa> and there're certainly implementations of a World type you /could/ do that with
15:39:13 <awarth> yes it is, because with adts, you can always create a value, store it somewhere, and test for equality.
15:39:21 <Philippa> no, you can't
15:39:26 <Philippa> not all types support equality
15:39:41 <awarth> right, fine. but instances of Eq.
15:39:59 <Philippa> did I say it was an instance of Eq? :-)
15:40:00 <skew> getchar(world0) = ('c',world1), getchar(world1) = ('a',world2), getchar(world2) = ('t',world3)
15:40:27 <skew> and the way the IO monad feeds around the world, you don't ever get the chance to go back and try getchar(world0) again
15:40:35 <shapr> right, that's part of the secret
15:40:46 <pesco> Huh? So hyphens are OK in Cabal package names but underscores are not? The documentation states the opposite.
15:40:49 <skew> just like in Clean the linear typing prevents you from applying the same IO function twice to the same world
15:40:49 <pesco> What should I fix?
15:40:51 <awarth> so what didn't you functional folk like about streams?
15:40:52 <shapr> if you force the monad to wind forward only, you know you won't have to screw around with the world.
15:41:03 <skew> streams don't compose
15:41:18 <skew> compositionality is just about the greatest good in functional-land
15:41:18 <awarth> that's true... good point.
15:41:31 <Philippa> I'd been about to phrase that as "they're a PITA" :-)
15:41:37 * shapr gives skew the golden lambda award for today's great truth
15:41:48 <skew> well, I suppose you could package up the stream in a monad and use that :)
15:41:50 <awarth> huh?
15:41:51 <awarth> pita?
15:42:00 <shapr> Actually, compositionality is the great truth in all software.
15:42:13 <shapr> Pain In The Ass
15:42:16 <Philippa> awarth: Pain In The Arse (or Donkey if you're american)
15:42:28 <awarth> ahhh :)
15:42:37 <skew> yes, but I think functional programmers recognize that more
15:42:52 <shapr> That's an excellent point.
15:43:05 <shapr> hm!
15:43:21 <Philippa> many other languages have shitty compositional tools in comparison
15:43:27 <shapr> In fact, I think it's because FP programmers often write code where you don't "hold it in your hand"
15:43:40 <jlouis> especially the lack of higher-order functions makes it hard
15:43:41 <shapr> point-free code, inductively defined code, etc
15:43:46 <jlouis> lacking currying hurts
15:44:01 <Philippa> code that's more about the structure of what you're doing
15:44:12 <jlouis> And the ability to pass an anonymous function down into a more general outer layer
15:44:32 <shapr> In the FP world you don't explicitly handle stuff, you implicitly handle stuff. And regular and predictable compositionality is necessary for that.
15:44:34 <musasabi> What functional languages still lack is composationality of space/time behaviour.
15:44:42 <jlouis> Another point is that many languages have rather primitive return value possibilities (eg one)
15:45:01 <RemiTurk> like haskell (to nitpick ;))
15:45:04 <shapr> Hm, too bad he left, he made some good points.
15:45:07 <jlouis> RemiTurk: ;)
15:45:26 <shapr> musasabi: yes, I agree.
15:45:55 <shapr> Cale made some points where he persuaded me that lazy/non-strict eval can be more compositional than strict eval.
15:45:56 <RemiTurk> though I don't really see how they _could_ be made compositional (which doesn't mean they cannot / we shouldn't try of course)
15:46:00 <shapr> But I forget what he said :-(
15:46:20 <skew> you mean space/time doesn't compose nicely in lazy functional languages?
15:46:52 * shapr tries to make "forever and a day" work in Haskell.
15:47:13 * RemiTurk stares
15:47:30 <skew> writing a cardinal arithmetic package?
15:47:40 <musasabi> STM goes a long way to make concurrency composable, but space/time behaviour is harder.
15:47:40 * shapr watches RemiTurk's eyes begin to water.
15:47:40 <jlouis> skew: hehe
15:48:11 * shapr adds two cardinals together, with the result being a group of very interested cats.
15:49:36 <shapr> I am far too silly for this discussion. I shall sleep instead.
15:49:44 * RemiTurk gives up
15:49:57 <skew> shapr: how about map Just [0..]++[Nothing]
15:50:16 <shapr> I thought cardinals were small birds.
15:50:26 <skew> and stuff in set theory
15:50:32 <shapr> Right okay, that too.
15:50:33 <skew> it's where you get if you start with zero and succ
15:50:38 <shapr> And they're religious figure, yeah?
15:50:57 <shapr> Maybe if you add two cardinals you get a pope?
15:50:58 <Philippa> yep. Currently trying to elect a pope, and not in the hentai sense
15:51:10 * shapr doesn't want to know what that means.
15:51:52 <skew> and then decide that you can also construct numbers by taking the upper bound of any other set of numbers
15:52:06 * RemiTurk does, to prevent the earth from becoming unbalanced
15:52:15 <skew> so you build your ordinary peano numbers like 0,1,2,3, etc.
15:52:26 <Philippa> RemiTurk: bad engrish joke
15:52:33 <Philippa> do I need to carry on?
15:52:58 <skew> Then the first wierd number you get is infity, or omega, or aleph_0, which is the least upper bound of the natural number, the first infinite number
15:53:09 <skew> then you make infinity plus one, infinity plus two, etc.
15:53:18 * RemiTurk worries
15:53:22 <skew> and infinity plus infinity, and infinity times infinity, etc.
15:53:28 * shapr pokes skew with a lambda
15:53:35 * RemiTurk remembers some book about aleph and the kaballa
15:53:40 <musasabi> shapr: I'll mail you tomorrow.
15:53:44 <shapr> musasabi: spiffy
15:54:33 <chr1s> are there any standard modules for integrating haskell with, let's say, apache?
15:54:54 <shapr> yes!
15:55:02 <shapr> at least, for some definition of standard.
15:55:23 <chr1s> It would be great to do that sort of things in haskell
15:55:27 <chr1s> dynamic webpages
15:55:50 <chr1s> mod_haskell
15:55:51 <shapr> Try Haskell Server Pages!
15:56:01 <shapr> or HWS with hs-plugins!
15:57:11 <shapr> Or just ask me tomorrow.
15:57:21 * RemiTurk goes to bed
15:57:34 * shapr goes to bed too, but a *different* bed mind you.
15:57:40 * chr1s will get some sleep too
15:57:45 * RemiTurk thanks $DEITY
15:57:49 * shapr laughs
15:58:13 <RemiTurk> good night sond
15:58:18 <RemiTurk> and everyone else too
15:58:20 <shapr> g'night RemiTurk
15:59:21 * boegel also goes to bed
15:59:44 <vegai> Deity::Beginning->End
16:00:26 <pesco> Hm. I'm trying to cabalize this package. When I run ./Setup.lhs configure --ghc, I get "rawSystem: interrupted (Interrupted system call)" every time. (Right after "configure: found ghc at /opt/local/bin/ghc".)
16:00:29 <pesco> Has anyone seen this?
16:00:37 <pesco> Or any idea why it could be happening?
16:01:01 <pesco> This is on MacOS X.
16:05:49 <pesco> Hm, it seems rawSystem doesn't work for me at all!
16:06:01 <pesco> Bummer.
16:06:46 <musasabi> pesco: you are probably getting some signal which results in a call returning EINTR.
16:06:56 <musasabi> pesco: as to why - no idea.
16:07:16 <musasabi> pesco: if it has something similar to strace it might be a good idea.
16:08:41 <pesco> Aha! It's only happening in interactive mode.
16:10:00 * pesco finds ktrace.
16:14:31 <pesco> Hah, I can run it in hugs. ;)
16:14:34 <gzl> what's the easiest way of executing a system command and grabbing its output into a String?
16:14:43 <pesco> popen I think.
16:15:27 <pesco> (Which is one of the prettiest names for a routine, don't you agree?) "popen"
16:16:03 <gzl> i suppose. :)
16:17:37 <pesco> Next only to "strrchr".
16:18:59 <gzl> um, is Posix different from System.Posix?
16:19:22 <gzl> one page suggests using Posix.runProcess or POpen.popen, but I see neither in GHC. or I'm an idiot.
16:20:44 <pesco> They probably moved around a bit in the module hierarchy.
16:22:03 <skew> I think all the stuff then used to be under Posix is now under System.Posix
16:22:46 <skew> you might need -package posix to
16:23:27 <skew> the old posix libraries and the POpen module are documented under "(Old) Haskell Libraries"
16:23:34 <skew> http://www.haskell.org/ghc/docs/latest/html/hslibs/index.html
16:25:00 <gzl> yeah, i was looking at that, and not seeing this "runProcess" one page recommended.
16:25:32 <skew> runProcess here: http://www.haskell.org/ghc/docs/latest/html/hslibs/Process-Primitives.html
16:25:45 <gzl> ah, there it is
16:25:52 <gzl> thanks.
16:26:10 <skew> but as the little note says, this stuff is scheduled to go away in 6.6
16:26:33 <gzl> that's ok for now
16:26:57 <gzl> what are they planning on replacing that function with? I didn't see an equivalent in System.Posix
16:45:06 <Igloo> runProcess? It's in System.Process
16:45:41 <Igloo> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html has an index of HL functions
17:06:35 <bC> hi everyone
17:07:13 <beschmi> hi bC
17:08:25 <bC> i was referred here by a friend, said i might be able to get some haskell help here :)
17:09:26 <sylvan> lies!
17:09:41 <sylvan> uh.. I mean.. how can we help you?
17:10:29 <bC> lol, im just starting to get into it, was wondering how to apply an operand of a function to a function
17:11:25 <bC> i.e. f1 (f2 (+) [1,2,3]) 5 will yield [6,7,8]
17:12:53 <bC> i was thinking of using map to put + in front of the numbers in the list, then somehow passing that to the 2nd parameter in f1
17:13:49 <bC> but all im getting are a errors :\
17:15:33 <bC> any ideas?
17:17:53 <vegai> what do you want to accomplish there?
17:18:58 <bC> i want to apply the number from f1 to f2
17:20:19 <vegai> well duh
17:20:26 <skew> why do you need to break it up as f1 and f2?
17:20:28 <vegai> but seriously, on a higher level
17:21:01 <bC> i just wanted more practice with higher order functions
17:21:17 <bC> and i found that particular problem, and i've been stuck for a while
17:21:19 <skew> there are a lot of ways of doing this
17:21:25 <vegai> ok, so what's f2's type?
17:21:42 <vegai> and f1's?
17:21:54 <bC> all are Int -> Int
17:22:00 <vegai> can't be
17:22:01 <skew> umm
17:22:04 <vegai> f2 takes two parameters there
17:22:10 <skew> (+) isn't an Int
17:22:29 <skew> and even if (f1 (+)) were, you can't apply and Int to a list
17:22:44 <bC> uhh...i havent quite delved into types yet :\  i kinda just let hugs do its thing atm
17:22:50 <skew> f1 has to have type (a->b->c) -> [a] -> X fpr some X
17:23:02 <Pseudonym> f2 x y z = map (x z) y
17:23:03 <skew> or (a -> b -> c) -> [b] -> X
17:23:04 <Pseudonym> f1 = id
17:23:07 <Pseudonym> That's one possibility.
17:23:51 <skew> in general some mix of f1 passing the number down to f2 to do stuff, and f2 passing some of its arguments up in a tuple for f1 to finish off
17:24:07 <Pseudonym> @type map
17:24:12 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
17:24:32 <Pseudonym> @type (\f -> map (f :: a -> b -> c))
17:24:34 <lambdabot> bzzt
17:24:57 <Pseudonym> @type (\f :: a -> b -> c -> map f)
17:24:59 <lambdabot> bzzt
17:25:06 <Pseudonym> @type (\(f :: a -> b -> c) -> map f)
17:25:07 <lambdabot> (\(f :: a -> b -> c) -> map f) :: forall b c a.
17:25:07 <lambdabot>                                   (a -> b -> c) -> [a] -> [b -> c]
17:25:10 <Pseudonym> There.
17:25:13 <Pseudonym> Does that help?
17:25:19 * vegai boggles
17:25:25 <bC> yeah, wow
17:25:35 <vegai> it does? =)
17:26:17 <bC> i mean, it helps in that i can begin to see how it was done, but a slight explanation would also be nice :)
17:27:15 <Pseudonym> Here's the type of map:
17:27:17 <Pseudonym> @type map
17:27:19 <lambdabot> map :: forall b a. (a -> b) -> [a] -> [b]
17:27:20 <dons> @seen xerox
17:27:21 <lambdabot> xerox is in #haskell. Last spoke 1 hour 54 minutes 25 seconds ago.
17:27:24 <Pseudonym> You foloow that?
17:27:33 <bC> yeah
17:28:16 <Pseudonym> OK.
17:28:22 <Pseudonym> That's for all types a and b.
17:28:29 <Pseudonym> For example, suppose b == c -> d
17:28:38 <Pseudonym> Then map can have the type:
17:28:51 <Pseudonym> forall a c d. (a -> c -> d) -> [a] -> [c -> d]
17:29:11 <skew> f1 = ((uncurry map).) ; f2 op list = flip (,) list . op
17:29:12 <Pseudonym> Which, after a renaming, is the type you want for f1 (if that's the right X).
17:29:43 <Pseudonym> skew, shame on you for having points in f2.
17:29:55 <Pseudonym> @pointless \op list -> flip (,) list . op
17:29:56 <lambdabot> flip ((.) . flip (,))
17:30:01 <Pseudonym> That's more like it.
17:30:13 <skew> hey, that's kind of nice
17:30:18 <dons> xerox: the FiniteMap error from runplugs is because it tries to use "ghc" to compile the code, which is ghc-6.4 in your case. you could make sure that 'ghc' points to ghc-6.2.2, or edit hs-plugins/src/plugins/Plugins/Make.hs:build to use "ghc-6.2.2" instead of ghc.
17:32:11 <bC> ok, i didnt quite follow the 2nd part of that convo...sorry, i'm kinda slow at this :\
17:32:35 <Pseudonym> @type flip ((.) . flip (,))
17:32:36 <lambdabot> flip ((.) . flip (,)) :: forall b a a1.
17:32:36 <lambdabot>                          (a -> b) -> a1 -> a -> (b, a1)
17:32:38 <bC> the flip (,) stuff
17:32:50 <Pseudonym> bC: Ignore that.
17:32:53 <Pseudonym> skew is being silly.
17:33:03 <skew> mine is a slightly strange solution where f1 passes 5 down to f2, which returns a pair of (+5) and the list, and then f1 puts them together with map
17:33:04 <bC> k
17:33:14 <Pseudonym> @pointless \ f a1 a -> (,) (f a) a1
17:33:15 <lambdabot> flip . ((,) .)
17:33:25 <Pseudonym> There you go, skew.  Even more concise.
17:33:57 <Pseudonym> There's something deeply wrong with a function when you have to use the free theorem to work out what it does. :-)
17:34:07 <dons> hehe
17:34:13 <skew> at least we have free theorems
17:34:17 <Pseudonym> True.
17:35:00 <skew> error "No Free Theorems for YOU!" :: (a->b) -> a1 -> a -> (b,a1)
17:35:36 <Pseudonym> True!
17:36:31 <Pseudonym> Though your function satisfies the free theorem too, of course.
17:37:51 <bC> i am so in a completely different league right now...u guys are awesome
17:38:00 <skew> just read a few papers
17:38:04 <Pseudonym> bc: "Awesome" isn't exactly the word I'd use.
17:38:41 <bC> awesome in that you take time to help others :)
17:39:27 <skew> we're not exactly helping now either.
17:39:36 <skew> Pseudonym was
17:39:43 <skew> before I distracted him
17:41:26 <a5> yo. i'm writing a shell and using Parsec for the parser and i'm wondering how to do the part where you can entere heredocs and multiline quote literals. i tried making a special 'newline' parser which calls getLine (in unsafePerformIO) and setInput if it sees eof...
17:41:58 <a5> but it seems what you specify with setInput is forgotten when a 'try' is backtracked. at least that's what it looks like is happening
17:42:17 <skew> The useful thing to be learned from my strange example is that there are lots of ways to do stuff like your little problem
17:42:49 <skew> it's all about understanding how functions work, lambdas really
17:43:19 <bC> my lambda exps are a little weak :\
17:43:44 <skew> you can work on that, and types help
17:43:59 <a5> ... i was also thinking about continuations (but i'm not sure how that would work) or using laziness and getContents (but then when there's an error you don't know how many lines were parsed)
17:44:13 <skew> a5: how is your parser getting at the input?
17:44:58 <skew> unsafePerformIO getLine at every newline and setInput?
17:45:06 <skew> there has to be a better way
17:45:11 <a5> yeah. initially i call getLine and pass the result to the parser
17:45:29 <bC> im gonna go work on some more exercises...thanks everyone...i'm sure i'll be back ;)
17:45:52 <a5> but i want it to read a new line when it sees eof and expects a newline
17:48:14 <skew> when is it ever expecting a literal newline?
17:48:28 <a5> i could have my token type be Either Char (IORef (Maybe String)) or something .. then the end of input will be "Right ref" and it could store any extra lines read in case it gets restored on backtracking ...
17:49:15 <a5> when you see 'eof' inside a quote expression for one... the other is heredocs - cat <<EOF\nstuff\nEOF\n
17:49:35 <skew> oh, you already have a fancy newline parer that recognizes eof and makes a newline, and you use it everywhere
17:49:55 <a5> well, that was the idea but it's only half working
17:50:02 <skew> the problem is that sometimes you use it inside another parser that gets backtracked?
17:50:11 <skew> why don't you just use hGetContents?
17:50:46 <a5> yes, that's the problem. i tried hGetContents but when there's an error i have no way to figure out how much of the input is still unread...
17:51:28 <a5> this only matters for interactive stuff, when i'm reading from a file i'll just have the special 'newline' parser revert to the normal semantics
17:52:28 <a5> another possibility was to try to parse the error message and see if it indicates that another line should be read - then read a line, concatenate it with the current one, and try to parse again. but that's quadratic
17:52:42 <a5> and hacky
17:57:30 <a5> i think the ioref thing would work but it'd be a pain because i'd have to redefine the CharParser functions to work on the new token type.
18:31:47 <pesco> Yay, I've made my first Cabal package!
18:41:51 * pesco goes to sleep
18:44:18 <bC> hello again guys :)  i've come across 2 more problems im getting stuck on
18:45:31 <bC> the first is writing an isMember function using foldr and a lambda expression
18:46:47 <bC> i've tried using the lambda exp to compare the head of the list with the target, then i foldr it all together, but i think that line of thinking may be fundamentally flawed
18:48:05 <Pseudonym> So what have you got?
18:48:07 <Pseudonym> Let's see code.
18:48:53 <bC> i've been erasing, but lets see if i have enough undo history
18:53:35 <bC> ugh, i dont even know what i did, but i think it was something along the lines of > mem ex (b:x) = foldr ((\tar hd -> (tar == hd)) ex b) : mem x...this wont even compile, it at least compiled b4 :\
18:58:33 <bC> any ideas?
19:02:03 <a5> bC: what are you trying to do? it looks like you mistakenly put parenthesis around the arguments to foldr...? and the type of the first argument needs to be a->b->b...
19:03:28 <bC> im trying to write a generic member function where ex is compared to list (b:x), and if its there, return true.  im just complicating things by using foldr and a lambda exp
19:03:47 <skew> bC: do you understand foldr?
19:03:59 <skew> (foldr is the catamorphism for lists)
19:04:34 <skew> foldr f x [] is x and foldr f x (y:ys) is f y (foldr x ys)
19:05:14 <Cale> lists are built of two things: conses (:) and nil [] -- what foldr does is to replace each cons with a function, and nil with a particular value.
19:05:34 <bC> my knowledge of foldr is: something like foldr (-) 3 [4,5,6] yields 4-(5-(6-3))
19:05:45 <Cale> On lists, foldr (:) [] is the identity function.
19:06:01 <Darius> bC: Compare that with foldr (-) 3 (4:5:6:[])
19:06:02 <skew> so if you want to find some f1, x1 so that foldr f1 x1 is your isMember b function, then pick x1 = isMember b [] and pick f1 so that f1 y (isMember b ys) calculates isMember b (y:ys)
19:06:13 <skew> I'm saying the most important thing here :)
19:06:31 <skew> it's like equational reasoning and theory and stuff
19:06:32 <Darius> bC: Or more clearly, foldr (-) 3 (4:(5:(6:[])))
19:07:24 <bC> skew: can u explain that again?
19:07:28 <Cale> if you can write your function with two cases which are the empty list and a recursive case of a nonempty list, then you can write your function as a foldr.
19:07:34 * Darius parodies skew: "foldr is the mediating arrow of an initial algebra, I'm saying the most important thing here" :)
19:07:57 <SamB> The most important thing?
19:08:05 <skew> Cale just explained it
19:08:10 <Darius> SamB: initiality characterizes folds
19:08:45 <skew> foldr describes the pattern of recursion where you start with some value for the empty list, and then combine in the list elements one at a time
19:09:05 <bC> k, i can follow that
19:09:15 <Cale> bC: would you like to see a solution?
19:09:18 <skew> so, foldr f x [] = x, foldr f x (y:ys) = f y (foldr x ys)
19:09:35 <bC> k, still good
19:09:37 <skew> if you want to express your function as a foldr, you have to put it in that pattern of recursion
19:09:55 <bC> Cale: sure?  it can't hurt any
19:10:04 <skew> so, whatever your function returns for the empty list, that will be your base value x
19:10:09 <Cale> member x xs = foldr (\y r -> x == y || r) False xs
19:10:18 <skew> what should isMember b [] return?
19:10:31 <bC> false
19:10:51 <bC> only if b is in a list containing b, should it return true
19:11:12 <skew> okay, so isMemeber b xs = foldr <f1> False xs, where you still need to decide what f1 is
19:11:13 <bC> Cale: thanks for that, very easy to reason out :)
19:11:50 <skew> now, isMember b (y:ys) = f1 y (foldr f1 x ys) = f1 y (isMember b ys)
19:12:25 <skew> say b is found in ys, so isMember b ys is True
19:12:36 <skew> what should isMember b (y:ys) give you?
19:13:28 <bC> what do u mean?  what recursion takes place?
19:14:26 <skew> imagine we have figured out how to define isMemeber b with foldr
19:14:38 <bC> ok
19:14:47 <skew> so isMember b ys = foldr <f> <x> ys
19:15:06 <skew> except we don't know what <f> and <x> are
19:15:20 <bC> k
19:15:59 <skew> so I'm showing how to figure out what <f> and <x> are from two things: 1) the definition of foldr and 2) how we want isMember to behave
19:16:20 <skew> looking at the base case [], you said that isMember b [] should be False
19:16:41 <bC> yeah
19:16:44 <skew> because foldr f x [] is defined to be x, that means that <x> in the definition of isMember has to be False
19:17:08 <skew> (this is why purely functional languages are nice to reason about)
19:17:26 <skew> now the other case is when the list isn't empty
19:17:55 <skew> if isMember b ys = foldr <f> False ys, then isMember b (y:ys) = foldr <f> False (y:ys)
19:18:15 <bC> ok
19:18:16 <skew> and this is the other case in the definition of foldr
19:18:22 <dons> @version
19:18:23 <lambdabot> lambdabot 2p301, GHC 6.4 (OpenBSD i386)
19:18:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:18:43 <skew> so foldr <f> False (y:ys) = <f> y (foldr <f> False ys) = <f> y (isMember b ys)
19:19:30 <bC> ok
19:19:31 <skew> there are four interesting cases here, either y==b or not, and isMember b ys is True or False
19:20:00 <Darius> dons: Anything new that's interesting?
19:20:12 <dons> @help fact
19:20:13 <lambdabot>  @fact <fact>, Retrieve a fact from the database
19:20:20 <dons> @fact lambdabot
19:20:21 <lambdabot> lambdabot: lambdabot is an irc bot implemented in haskell.
19:20:33 <dons> @listcommands fact
19:20:34 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
19:20:44 <Darius> @help fact-update
19:20:45 <lambdabot> Define a new fact, overwriting
19:20:51 <Darius> @help fact-set
19:20:52 <lambdabot> Define a new fact, guard if exists
19:20:54 <dons> thanks to jlouis for porting fact to the new persistence framework
19:21:49 <skew> bC: this is a decent paper http://www.cs.nott.ac.uk/~gmh/bib.html#semantics
19:21:53 <dons> a few infrastructure issues have been sorted to. for one, lambdabot calculates its own plugin dependency tree now.
19:22:03 <skew> I think this might be the one where I learned the stuff I'm talking about
19:22:03 <Darius> I noticed that patch.
19:22:24 <bC> cool, thanks, i'll read it tonight
19:22:35 <cm_> peace
19:22:44 <bC> grr, i just got a nosebleed :P
19:22:51 <dons> I think we're approaching a stable point, so tagging v3 is probably not too many days away.
19:23:10 <skew> bC: back to the example, now you decide what isMember b (y:ys) should return when 1) y==b, b is in ys 2) y /= b, b is in ys 3) y==b, b not in ys, 4) y /= b, b not in ys
19:23:46 <skew> and then you make some function that does the same thing and call it <f>, and you are done
19:23:47 <bC> k
19:24:14 <skew> one example is Cale's isMember b ys = foldr (\y bInRest -> b==y || bInRest) False ys
19:24:34 <bC> cool, thanks for taking the time to explain it to me :)
19:25:01 <skew> the other main way of doing is bInRest || b==y, which checks the rest of the list first
19:25:35 <skew> except you don't really want to do that because that doesn't take advantage of lazy evaluation (that's why foldr is used a lot in Haskell)
19:25:51 <skew> I mean, foldr is used a lot because it can take advantage of lazy evaluate
19:26:02 <skew> I'm being confusing :(
19:26:04 <skew> or confused.
19:26:20 <bC> nah, ur doing great
19:26:26 <skew> foldr f x (y:ys) = f y (foldr f ys)
19:26:56 <skew> so if f can give a result just from looking at y, the recursive case isn't even computed
19:28:00 <skew> or, if it can return part of a data structure with the recursive answer buried inside, the recursive case doesn't need to be computed until somebody looks that deep in the data structure
19:28:09 <skew> like fold (:) [] copies a list
19:28:41 <bC> k
19:29:21 <skew> but when you apply (:) you get a value without evaluating either argument
19:29:40 <skew> try something like let x = (:) (error "no head") (error "no tail") in GHCi
19:30:04 <bC> ghci?
19:30:16 <skew> a Haskell interpreter
19:30:21 <skew> you are using Hugs? Or paper?
19:30:28 <bC> hugs
19:30:33 <skew> hmm
19:30:45 * Darius recommends GHC (or NHC) over Hugs.
19:30:51 <skew> I agree
19:31:22 <bC> what are the benefits?
19:31:27 <skew> The last time I looked at hugs it didn't let you write a let like that that defines new variables that you can keep on using
19:31:34 <dons> though hugs is highly portable. it's all you'll get on a vax ;)
19:31:50 <skew> you can type in let x = <something big and complicated>
19:31:58 <Darius> bC: GHC tends to have better error messages.
19:32:01 <bC> yeah, that let stmt results in a syntax error
19:32:06 <skew> and then do all sorts of different things with it
19:32:18 <skew> like type in print x, and on the next line x**2-2, etc.
19:32:22 <Darius> bC: GHC is a compiler (but has an interactive mode) so it produces -much- faster code.
19:32:24 <bC> darius: thats reason enough :P
19:32:35 <Darius> bC: I agree very seriously.
19:33:25 <Darius> bC: I said on one of the mailinglists that GHC's better error messages would be reason enough to use GHC all other things equal (which they are not).
19:33:40 <skew> Okay, try case (1 + error "no 2") of 0 -> "zero" ; _ -> "not zero"
19:33:43 <bC> so yeah, i have a feeling haskell is going to have a slightly steeper learning curve than other pl's i've used...should be quite the adventure
19:33:59 <Darius> bC: What other PL's do you know?
19:34:01 <skew> case has to evaluate a value enough to figure out what it is, at least
19:34:09 <bC> "
19:34:13 <bC> Program error: no 2
19:34:18 <skew> yep
19:34:28 <skew> that meant that it tried to evaluate the second argument to +
19:34:38 <skew> Actually, just try typing in error "any string you like"
19:34:46 <bC> darius: i've played around in prolog, know c, c++, java, some others too probably
19:34:58 <skew> points off for using "any string you like" as your string.
19:35:39 <skew> bC: any of the scripting languages, Python, Ruby, Lua, etc?
19:35:53 <Darius> bC: As you might guess, Prolog is closest to Haskell, but even then Haskell is -quite- different from all the ones you  mentioned.
19:36:09 <bC> no scripting languages
19:36:38 <bC> yeah, definately different the OO languages i'm used to
19:37:03 <skew> Okay. Those usually have higher order function, and they don't have any static type system, which I think puts them closer to Haskell's type system than OO languages are
19:37:30 <skew> maybe lazy evaluation is something to learn another day
19:38:04 <bC> lol, i think i have a grasp (albeit amateur at best) on lazy evaluation
19:38:36 <bC> i think it was covered briefly in a programming languages book i was reading
19:38:41 <skew> bC: okay, do you see how foldr can take advantage of it?
19:39:41 <skew> maybe true infinities make more sense than errors. Consider the infinite list [1..]
19:39:58 <bC> wow, i just got a case of deja vu....but yeah, foldr can hold off from evaluating the recursion until it needs to
19:40:02 <skew> foldr (:) [] [1..] will work, and give you a copy
19:40:18 <skew> because it doesn't try to do the recursive case until it needs it
19:40:38 <skew> They should have examples like that in some of the speed contests :)
19:43:33 <bC> thanks for the quick tutorial on foldr, making more sense already
19:45:29 <bC> could u maybe also explain to me how to calculate binomial coefficients incorporating list comprehension?  i'm looking at this, and im hardly making sense of what it means :\
19:45:35 <Darius> bC: What does foldr (+) 0 [1..] do?
19:46:31 <bC> it adds an infinite list?
19:46:46 <bC> or attempts to
19:47:16 <bC> it wont ever get to the 0 will it?
19:47:43 <Darius> bC: Try it in Hugs and see what happens.
19:48:00 <bC> stack overflow
19:48:40 <dons> @plugs foldr (+) 0 [1..]
19:48:42 <lambdabot> Stack overflow
19:49:01 <Darius> @plugs fraggle
19:49:02 <lambdabot> Variable not in scope: `fraggle'
19:49:20 <Darius> dons: Did it reply with error messages before?
19:49:47 <dons> yep. but they used to be far more verbose
19:50:01 <dons> (I now process ghc's output)
19:50:27 <Darius> bC: You can intuitively see that that example doesn't work, but do you think you can figure out what specific technical property about that example causes it to fail?
19:51:03 <Darius> dons: Okay.  I was thinking about using @plugs, but I didn't think "bzzt" would be very helpful.
19:51:28 <dons> oh, that's right. sorry - it used to just say bzzt.
19:51:52 <dons> then I let it return ghc's msgs, and now it's polished up ghc msgs.
19:52:01 <dons> @plugs 1 2
19:52:02 <lambdabot> No instance for (Num (t -> a))
19:52:02 <lambdabot>       arising from the literal `1' at v = (take 2048 (show (1 2)))
19:52:04 <bC> darius: the recursion can't unwind because there is no end to the list...and 0 has to be added with the end of the list for the recursion to unwind...that right?
19:52:57 <Darius> bC: There's no end of the list for foldr (\x xs -> 2*x:xs) [] [1..], but it behaves differently (try it).
19:53:58 <Darius> dons: What kind of things does it do to shorten the output?
19:54:49 <dons> it only returns the first 'not in scope', and it applies a number of other regexes to clean up the output:
19:54:55 <dons> @plugs putStrLn "yep"
19:54:56 <lambdabot> No IO allowed
19:55:13 <Darius> @plugs [1..]
19:55:14 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
19:55:14 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
19:55:14 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
19:55:14 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
19:55:14 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
19:55:14 <lambdabot> 118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
19:55:16 <lambdabot> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
19:55:18 <lambdabot> [22 @more lines]
19:55:25 <dons> @plugs last [1..]
19:55:29 <lambdabot> Terminated
19:55:37 <Darius> dons: Yeah, better example.
19:57:12 <bC> err...the [] lets it calculate as its going?
19:58:11 <Darius> bC: foldr (\x xs -> Just x) Nothing [1..]
19:58:44 <bC> Just 1
19:59:19 <Darius> bC: As you said, it never got to the '0' in the first example, so the [] is moot, for example you could also write foldr (\x xs -> 2*x:xs) (error "Foo!) [1..]
19:59:29 <dons> other msgs just return the most important text:
19:59:30 <dons> @plugs let f () = f () in f ()
19:59:32 <lambdabot> Ambiguous type variable `a' in the top-level constraint
19:59:34 <dons> @plugs let f () = f () in f () :: ()
19:59:38 <lambdabot> Terminated
19:59:55 <Darius> (uh, closing the "'s)
19:59:57 <Pseudonym> @plugs undefined
19:59:58 <lambdabot> Ambiguous type variable `a' in the top-level constraint
20:00:04 <Pseudonym> @plugs undefined :: String
20:00:05 <lambdabot> Fail: Prelude.undefined
20:00:26 <Pseudonym> @plugs let f = f in f :: ()
20:00:27 <lambdabot> Fail: <<loop>>
20:02:06 <bC> darius:  whats letting it compute a value?
20:02:48 <seba> why this not work:
20:02:58 <seba> scanlr :: (b -> a -> b) -> b -> [a] -> [b]
20:03:02 <seba> scanlr f e = [foldl f e]
20:03:12 <seba> not compile
20:03:16 <Pseudonym> @type \f e -> [foldl f e]
20:03:16 <Darius> @type \f e -> [foldl f e]
20:03:18 <lambdabot> \f e -> [foldl f e] :: forall b a. (a -> b -> a) -> a -> [[b] -> a]
20:03:18 <lambdabot> \f e -> [foldl f e] :: forall b a. (a -> b -> a) -> a -> [[b] -> a]
20:03:33 <Pseudonym> Great minds and all that
20:03:48 <Pseudonym> Yup, looks like a different type to me.
20:04:04 <Darius> bC: As you pointed out [] and 0 is irrelevant.  So the only relevant difference between the (+) example and the (\x xs -> 2*x:xs) example are those functions.
20:04:04 <seba> what is the problem?
20:04:25 <bC> oh
20:04:29 <Pseudonym> The problem is that the type of your definition of scanlr doesn't match the type that you declared.
20:04:35 <bC> gotcha
20:04:53 <seba> but i cant see the problem!
20:04:55 <Darius> bC: So the question is, what's the relevant difference between those?
20:05:45 <bC> the lambda function?
20:05:55 <seba> what is the solution?
20:06:22 <bd_> seba: What is the function supposed to do?
20:06:28 <Darius> @plugs foldr (\x y -> x + y) 0 [1..]
20:06:29 <lambdabot> Stack overflow
20:07:06 <bC> darius: is it the + operator?
20:07:29 <seba> bd: in the final, i need a recursive function that apply the foldl function to all the elements of a list
20:07:42 <Darius> bC: What about the (+) operator, certainly using (*) instead wouldn't make a difference.
20:08:32 <seba> the function scanlr that I posted is only a test
20:08:36 <bd_> seba: I see. I'll give you a hint, since it's homework :) There is a function that will apply something to all elements of a list...
20:09:30 <seba> bd_: yes ia a homework :( and yes... a function that apply the foldl function to all the elements of a list
20:09:48 <seba> db_: but I have a type problem
20:09:53 <bC> darius: does the lambda exp do some kind of inlining? or am i getting it confused with something else
20:10:26 <bd_> seba: your function isn't the best way to approach it. you're making a list of one element, which is the partially applied foldl function.
20:10:44 <bd_> seba: you want to transform a list. there is a prelude function for transforming a list :)
20:11:29 <seba> bd_: the post is only a test, my solution was:
20:11:30 <Darius> bC: lambda notation is just a way to write a function without naming it, writing let f x xs = 2*x:xs in foldr f [] [1..] would make no difference.
20:11:34 <seba> canlr :: (b -> a -> b) -> b -> [a] -> [b]
20:11:34 <seba> scanlr f e = (foldl f e) : (scanl f tail e)
20:11:49 <bC> ok
20:12:08 <seba> bd_: not work! and I dont know why!
20:12:14 <bd_> you're not applying foldl to enough arguments there. also, e is apparently a list, but you tag it simply with b
20:13:05 <bC> darius: its evaluating the tail of the list
20:13:15 <Darius> bC: Yes, why.
20:13:52 <bC> because after x, xs is called by f, and it it keeps going
20:13:54 <seba> bd_: I cant see the solution
20:14:02 <bd_> seba: what list manipulation functions have you learned so far?
20:14:40 <seba> bd_: tail, head, init, foldr, foldl, map
20:15:07 <bC> darius: that about right or am i still missing something?
20:15:16 <bd_> seba: one of those will help immensely :) think of the problem: you wish to apply foldl to each element of a list... what function applies something to each element of a list, and returns a list of the results?
20:16:13 <seba> bd_: map is perfect, but I the solution must be recursive
20:16:21 <seba> bd_: map is perfect, but the solution must be recursive
20:16:23 <bd_> Oh, it must be recursive?
20:16:35 <Darius> bC: Depending on what you were referring to by f, you may have it.  Can you say what the difference is between (+) and (\x xs -> 2*x:xs) that makes one overflow and the other "stream"?
20:16:39 <seba> bd_: yes
20:16:48 <SamB> is map not recursive enough for you?
20:17:11 <seba> Samb: I cant use map
20:17:36 <SamB> seba: not even if you bind it yourself?
20:18:42 <bd_> seba: In that case, take a look at your type declaration. You've got more parameters listed there than you're using. Since you're not returning a partially applied function, you must bind all parameters in your function declaration. Also, foldl takes three parameters :)
20:18:49 <Darius> bC: Evaluating by hand often helps.  Just remember that Haskell is lazy.
20:19:26 <seba> db_: I cant see what is the third parameter
20:20:16 <bC> darius: the plus is essentially waiting til the end to evaluate, but the expression calls x, and then it called with xs, and it keeps going like that, taking an eager rather than lazy approach
20:20:24 <bd_> seba: Look at the arrows: (b -> a -> b) is the first parameter, b is the second, [a] the third.
20:20:29 <bd_> actually
20:20:39 <bd_> oh, nm
20:21:33 <seba> bd_: but here: scanlr f e = (foldl f e) : (scanl f tail e) I cant see what is the posible parameter
20:21:43 <seba> to resolve the problem
20:21:46 <Darius> bC: And the \x xs -> 2*x:xs example?
20:21:49 <bd_> you have to add it.
20:21:57 <bd_> the first parameter is a function. you've got that right
20:22:07 <bd_> the third is a list. what is the second?
20:22:43 <seba> bd_: I am very nervous i cant see it
20:23:47 <bd_> Based on your type signature, I'd guess that's the initial value passed to foldl, right? So you need to insert an additional parameter between f and e, and make sure it gets to foldl and the recursive call as well (note that your recursive call seems to be a typo)
20:23:56 <bd_> also don't forget a base case for an empty list
20:24:08 <bC> darius: it multiplies the head by 2, then its recursion takes it through each next element, and it doesnt stop b/c of the 1..
20:24:25 <seba> bd_: i going to try
20:24:26 <bd_> there are a few more problems, but see if you can solve it from there by yourself
20:24:50 <bd_> and if you still have problems, come back here. I have to go now, though.
20:26:03 <Darius> bC: Why does it not overflow?
20:28:01 <bC> darius: probably not the best wording, but its not trying to be lazy?  its not trying to wait until the end
20:29:07 <Darius> bC: Actually it's the opposite.  (+) is being too eager and the (\x xs -> 2*x:xs) is being lazy.
20:29:31 <bC> oh
20:29:51 <bC> brb, quick load of laundry
20:33:42 * cm is eager to cons Darius
20:35:46 * Darius actually has to go now.
20:43:58 <bC> ok darius left :\...can anyone help me with write a solution to compute binomial coefficients employing list comprehension?
20:45:28 <bC> im essentially being given bc n k = bchelp !! n !! k and i need to define bchelp
20:50:51 <bC> any ideas?
20:52:05 <bC> i've been staring at that one for a while, took a while to get the !! o_O
20:52:30 <skew> how do you go from one list to the next? Remember Pascal's triangle
20:52:52 <skew> have you learned the nice library list functions?
20:53:17 <bC> i'd have to say no to that one
20:54:02 <bC> what do u mean go from one list to the next?
20:54:18 <skew> if you are using !! twice, then bchelp must be a list of lists
20:54:28 <bC> yeah
20:54:33 <skew> where the first element of bchelp is a list of all the binomial coefficients for exponent n
20:54:42 <skew> i.e [1,0,0...]
20:54:56 <bC> k
20:55:08 <skew> the next is a list of n=2, [1,1,0,0..], then [1.2.1.0,...], etc
20:55:42 <skew> You should browse through the standard prelude and Data.List sometime
20:55:44 <bC> ok
20:55:56 <skew> there are many many useful things in there
20:57:07 <bC> this haskell book im reading has a little bit of that, but i havent found the main text on it yet
20:57:34 <skew> the main haskell webpage is a www.haskell.org
20:58:32 <skew> www.haskell.org/onlinereport/ is the language definition
20:58:41 <skew> www.haskell.org/ghc is the GHC site
20:58:58 <skew> download link will get you a copy of GHC.
20:59:38 <bC> my reading list has grown quite a bit since i came here a couple of hours ago ;)
21:00:18 <skew> most importantly, their documentation page links to "Hierarchial Libraries", and "User's Guide"
21:00:34 <skew> the former is pretty documentation for all the libraries that come with GHC
21:01:02 <bC> the main thing im having trouble with is i don't really know how to start.  the problem is kind of vague.  it gives the bc n k line, tells me to use list comprehensive notation, and it just leaves off
21:01:35 <skew> the latter describes how to use GHC and has a brief introduction to their numerous language extensions (almost all are very cool), which isn't that useful now but will be if you use more Haskell
21:01:51 <skew> bC: types structure programs a lot in Haskell
21:02:16 <skew> the type of bchelp in the line they give you tells you it has to be a list of lists
21:02:29 <skew> and it has to be an infinite list if it will work for any n
21:03:18 <bC> im not quite sure what to do with that
21:03:20 <skew> So you already have a fair bit of pattern - think about how to make a list where the nth element is a list of the binomial coefficients for n
21:04:11 <bC> err...
21:04:34 <bC> im not even sure why this is using lists
21:06:04 <skew> I think part of the reason is because the provided code and the way it uses lists give you some constraints to work inside
21:07:33 <bC> yeah, but the problem does a very poor job of explaining how lists are even used to determine the bin. coef.
21:08:24 <skew> From where I'm standing it seems like a nice way of providing some guidance, better than I've done in excercises I've written. I guess it isn't helping much, though.
21:08:37 <skew> Do you even know any data structures other than lists?
21:08:41 <skew> maybe pairs, I suppose
21:09:32 <skew> So the three basic ways of building a binomial coefficient function are the trivial way with factorials that doesn't teach anything about factorial
21:09:41 <bC> in haskell, i cant even profess to know lists very well, in regards to data structures in general, ive studied the basics
21:09:56 <skew> recursively computing the binomial coefficients, which is horribly slow
21:10:03 <skew> or building up a table of them using lists
21:11:08 <bC> yeah, i did one recursively, slow is an understatement :\
21:12:42 <skew> using the slow recursive one, could you write down an expression that gives you the list of binomial coefficients for n=4?
21:13:01 <Pseudonym> There are other ways, BTW.
21:13:10 <bC> > b n k
21:13:14 <bC> >  | k == 0       = 1
21:13:14 <bC> >  | n == k       = 1
21:13:14 <bC> >  | otherwise    = ((b (n-1) (k-1)) + (b (n-1) k))
21:13:18 <bC> thats what i have for the recursive
21:13:19 <skew> Pseudonym: this actually isn't the way I was trying to lead at..
21:13:30 <skew> bC: looks good.
21:13:57 <skew> now, how do you define that list I mentioned?
21:14:17 <bC> what do u mean
21:14:20 <skew> I mean, I want you to use your b function to fill in the values
21:14:34 <skew> Actually, I should use a bigger number
21:15:13 <skew> say I want x to be a list with the 100 binomial coefficients for a binomial raised to the 99th power
21:15:57 <bC> k
21:16:01 <skew> so I start writing x = [1,99,
21:16:05 <skew> but that would just be horrible
21:16:30 <skew> Look, b computes binomial coefficients. I want a list of them.
21:16:34 <skew> Do you know what "map" is?
21:16:47 <bC> yeah
21:17:00 <bC> i've used it a couple of times today
21:17:04 <skew> how about list comprehensions?
21:17:20 <bC> yeah, don't really know what that is
21:17:47 <bC> one of the main problems since the solutions calls for it to be used...
21:18:03 <skew> well, they turn into calls to map and filter and stuff in the end, they are just a prettier way of writing it all down
21:18:25 <bC> k
21:19:18 <skew> I don't think they have too much of a difference on figuring out how to solve the problem, unless the simpler notation helps you think better.
21:19:39 <skew> anyway, [1..10] is a list of number. Say I want a list of twice those numbers
21:19:48 <skew> you can write down an expression with map to do that
21:21:06 <skew> now say I want a list of the binomial coefficients with n=12 and those numbers as k. How do you write that?
21:21:44 <skew> remember, there's nothing special about built in functions in Haskell. (*) is a function just like b
21:22:05 <skew> (even the infix notation is something you can do yourself, actually)
21:23:45 <skew> how about you just write the expression for twice the list [1..10], to have something to start from
21:24:20 <bC> sorry, had to step out for a sec
21:24:24 <skew> ah
21:24:25 <skew> oky
21:25:14 <bC> map (\x -> 2*x) [1..10] ?
21:25:19 <skew> sure
21:25:28 <skew> now how about the binomial coefficients?
21:26:23 <bC> of those numbers?
21:26:23 <skew> I mean, get [12C1, 12C2, 12C3, 12C4 ... 12C10] with [1..10], map,Â and a lambda that uses your b function
21:27:05 <skew> Actually, I kind of like the way this is going because this leads the the magic lazy evaluation solution
21:27:10 <skew> but carry on
21:27:54 <bC> im not even quite sure how to use my b function, i kinda just converted it from an equation
21:28:07 <skew> well, try out your b function in an interpreter then
21:28:42 <bC> yeah, i've done that, i dont know what the n and k stand for though
21:29:02 <skew> those are just the conventional names in the binomial coefficients
21:29:34 <skew> because (a+b)^n = Sum k=0 to n of a^k*b^(n-k) * nCk
21:29:48 <skew> where I'm writing nCk for the binomial coefficient n choose k
21:30:00 <bC> k
21:30:16 <skew> English is your native language, right?
21:30:24 <bC> yeah
21:30:33 <bC> i think i would be alot worse off it wasnt
21:30:34 <skew> I'm hoping I'm not assuming you know the english words for lots of math stuff
21:30:53 <bC> nah, im on the same page as you
21:31:28 <skew> anyway, the n and k arguments to your b are the same n and k in the description of the binomial coefficient, or in their bc function
21:31:51 <bC> ok, so if i wanted the bc for n=10, what would i use for k?
21:32:23 <skew> n=10?
21:32:27 <bC> or does that not matter
21:32:44 <skew> no, I want the coefficients with n=12, and the ks taken from the list [1..10]
21:32:53 <bC> oh
21:32:56 <skew> so [b 12 1, b 12 2, b 12 3, ... b 12 10]
21:32:58 <bC> ok, that makes more sense
21:33:18 <bC> ok
21:34:05 <bC> map (\k -> (b 12 k)) [1..10]
21:34:21 <skew> or just map (b 12)[1..10]
21:34:35 <bC> or that ;)
21:36:01 <bC> that gives me this list: [12,66,220,495,792,924,792,495,220,66]
21:36:28 <skew> Now that should be easy to change to generate all the coefficients
21:36:35 <skew> just use [0..12]
21:37:03 <bC> k, [12,66,220,495,792,924,792,495,220,66,12,1]
21:37:07 <skew> Oh, I see how the list comprehensions come it
21:37:22 <skew> I think it's time to talk about them a tiny little bit
21:37:31 <bC> k
21:37:36 <skew> [ e | p <- l ] means the same thing as map (\p -> e) l
21:37:49 <skew> okay, that's it :)
21:37:57 <bC> lol, k
21:38:29 <skew> that's really all you need (well, with a bit of nesting)
21:38:49 <skew> so in that notation the list of binomial coefficients for 12 is [ bc 12 k | k <- [0..12]]
21:39:37 <bC> how does the !! work with that?
21:39:53 <skew> This is just syntax for making a list
21:40:01 <skew> and !! is a function for accessing a list
21:40:03 <bC> oh
21:40:17 <bC> gets u the nth element right?
21:40:23 <skew> yes
21:40:32 <skew> well, whatever you use as the argument
21:40:44 <bC> let me try to write this out :)
21:41:11 <skew> using "n" for any random number gets kind of confusing when you have binomial coefficients that really are in terms of n and k
21:42:03 <bC> so bchelp's parameters are just n and k? not lists?
21:42:17 <skew> huh?
21:42:22 <skew> bchelp doesn't have any parameters
21:42:29 <skew> you didn't figure out the types?
21:42:32 <bC> oh
21:42:46 <bC> no?
21:42:46 <skew> bchelp :: [[Integer]], or some kind of number anyway
21:42:56 <skew> (!!) :: [a] -> Integer -> a
21:43:02 <skew> and is associates left
21:43:49 <skew> if I write  getElement for !! in prefix, then
21:43:59 <skew> bc n k = (getElement (getElement bchelp n) k)
21:44:20 <skew> if you didn't notice that you must have been very confused
21:45:06 <bC> still kinda am, but maybe for diff. reasons
21:45:45 <skew> I think now you are where I thought you were, with maybe a little bit of not understanding how you can define infinite lists as constants
21:46:38 <skew> try sticking naturals = [0..] into a program and loading that up in Hugs
21:46:39 <bC> ok, so what does bchelp do again? ...please forgive me, im not usually this slow
21:47:19 <skew> bchelp is a list of lists, a big giant table, where the nth element of the outer list is a list whose kth element is the n,k binomial coefficient
21:47:30 <skew> You have to figure out how to define such a list
21:48:02 <mwc> Anybody know what the story is on "real" multithreading in haskell right now?
21:48:08 <bC> yeah...i think thats where im getting lost
21:48:31 <mwc> AFAIK, ghc just runs them as cooperative subthreads in a single thread
21:48:46 <mwc> is there another compiler that does real concurrency?
21:48:46 <skew> mwc: Simon Marlow was in here earlier reporting he had a haskell program running in 8 OS threads
21:48:55 <mwc> skew, beautiful
21:49:06 <skew> they're working on making GHC take advantage of SMP machines
21:49:09 <blackdog> didn't actually speed it up, IIRC. :)
21:49:12 <skew> there's really no reason if you just have one processor
21:49:14 <mwc> Yeah, that's a killer feature for me :P
21:49:36 <mwc> skew, yeah, but most of the machines I'd use it on are multihead
21:49:55 <skew> the one thread story isn't quite complete, if you are worried about making foreign calls
21:50:01 <mwc> My personal notebook isn't, but the workstations and the cluster are SMP
21:50:15 <mwc> skew, I was actually more concerned about effeciently breaking up parallizable tasks
21:50:26 <mwc> <-- applied math major
21:50:38 <mwc> I'd like to use haskell for my scicomp projects next year
21:50:42 <skew> just checking
21:51:09 <skew> You can always fork multiple Haskell processes, if you really want to
21:51:32 <bC> oh, so this is like a dynamic programming solution
21:51:34 <mwc> skew, yeah, but that's a really ugly hack
21:51:43 <skew> If you are really serious you could probably even get the to communicate with mmap
21:52:00 <mwc> I may as well just do the code in cpp if I'm gonna do that
21:52:18 <skew> I bet you could wrap it up in a nice interface pretty quickly
21:52:27 <blackdog> mwc: do you want the haskell runtime to automatically split tasks up for you? load balancing, that sort of thing?
21:52:38 <blackdog> that's kinda nontrivial
21:52:40 <skew> Are you going to be calling fast optimized C to do your math?
21:52:49 <mwc> blackdog, if I fork off some concurrency, I want it to run them simultaneously
21:52:56 <mwc> skew, haven't looked into it, I'd assume so
21:53:14 <mwc> I have to do a lot of coding next year, and I'm wondering if I should invest time to become a haskell guru for that
21:53:17 <skew> mwc: that's what they are working on. No fancy automatic parallelization stuff, load balancing left to the OS.
21:53:26 <blackdog> mwc: i was under the impre
21:53:37 <skew> mwc: if you are going to do the heavy lifting in C then you might have enough concurrency as is.
21:53:49 <mwc> I figure a good FFI will make it easy to call something like Blitz++ or the like
21:54:07 <skew> I'm pretty sure that if you use forkOS instead of forkIO your new haskell thread gets a little pet OS thread that it uses for all foreign calls
21:54:13 <mwc> skew, ahah
21:54:16 <blackdog> bah, sorry. Mean to say that i thought the idea behind forking was concurrency, not parallelism - i don't know what it's like now, but wasn't there a GpH project with explicit 'par' and 'seq' commands?
21:54:17 <mwc> let me look into that
21:54:32 <mwc> I was just looking at some stuff on the ghc page, I'm not that proficieint in Haskell yet
21:54:41 <mwc> that material might be out of date though
21:54:47 <blackdog> don't know if it's still going
21:54:49 <skew> the haskell code still runs under the Haskell scheduler in the main Haskell thread, but I think your C code will run in its own thread
21:55:14 <skew> This is just what I understood from reading the docs, I've never tested that bit of it
21:55:27 <blackdog> what's nice about that stuff is that it clearly indicates to the runtime "I think this is a good place to split, but if you know better you don't have to". IF you fork, that's a more direct command...\
21:55:34 <mwc> Hmm, I'd like to parallelize at a higher level though, that's my qualm
21:55:37 <skew> not that I have an SMP machine anyways, although it is multiheaded if you count three monitors :)
21:55:41 <blackdog> i'm never going to get used to this mac keyboard.
21:56:36 <mwc> A Concurrent Haskell program implies multiple `threads' running within a single Unix process on a single processor.
21:56:39 <wagle> blackdog: you have it easy..  first mac keyboard i tried to use was encrypted with dvorak
21:56:49 <mwc> that use of 'threads' has me a little worried
21:57:06 <blackdog> I'm almost there - it's actually a french keyboard. If I couldn't touchtype, I'd be screwed.
21:57:10 <skew> mwc: where do you see that?
21:57:15 <wagle> seems odd to have to worry about allocating threads in a functional program
21:57:17 <mwc> skew, http://www.haskell.org/ghc/docs/latest/html/users_guide/concurrent-and-parallel.html
21:57:55 <lispy> i'm really struggling with monads.  I have a function 'time' that runs another function inside a monad and returns a IO String, but I can't display the result...
21:57:57 <skew> hmm
21:58:06 <skew> I think the forkOS thing is worth a shot anyway
21:58:23 <skew> would it be that hard to try?
21:58:27 <lispy> ghc complains that there is no instance for (Show (IO String))
21:58:39 <mwc> No, not at all
21:58:43 <dons> >>= print
21:58:44 <mwc> I'll give it a shot now
21:58:48 <bC> hey skew, can u give me an idea of what bchelp would look like?  im having a hell of a time even trying to figure out what such a thing would look like in haskell :\ im c++ i'd be using vectors, but here im a little lost
21:58:49 <mwc> or tomorrow morning
21:58:56 <skew> bC: that's one way to do it.
21:59:14 <skew> bC: you get the lazy evaluation bit?
21:59:17 <lispy> dons: i'm not sure i understand that
21:59:37 <lispy> dons: i need to catch the IO String and then use >>= print on it?
21:59:42 <bC> skew: umm...dunno?
21:59:50 <skew> bC: I mean, why do you say "dynamic programming"?
22:00:19 <bC> just the term i learned in my algorithms class a couple years ago
22:00:36 <bC> wasnt really paying attention back then
22:00:40 <dons> Prelude> show (return "foo" :: IO String)
22:00:40 <dons> <interactive>:1:
22:00:40 <dons>     No instance for (Show (IO String))
22:00:44 <dons> Prelude> (return "foo" :: IO String)  >>= print
22:00:44 <dons> "foo"
22:00:45 <skew> Just figure out how to build that big table with your slow recursive b, and I will show you a magic trick
22:01:04 <dons> @type print
22:01:05 <lambdabot> print :: forall a. (Show a) => a -> IO ()
22:01:09 <blackdog> bC: better hurry up, the rabbit in skew's hat is getting testy\
22:01:14 <bC> magic is always nice
22:01:23 <skew> blackdog: it's a very lazy rabbit ;)
22:01:48 <bC> ...does the rabbit know how to build a big table in haskell?
22:02:07 <blackdog> old joke, but anyway: "Today's lecture is on laziness."
22:02:07 <skew> let's go back to map (b 12) [0..12]
22:02:09 <blackdog> *pause*
22:02:12 <blackdog> "any questions?"\
22:02:42 <skew> that's exactly the list you need for the 12th element of bchelp
22:03:00 <bC> ok
22:03:32 <skew> next step, make a function that takes an argument called n and gives you that appropriate list for that n
22:04:01 <skew> so coeffs 12 would give you the same list as map (b 12) [0..12]
22:04:08 <skew> or whatever you want to call it
22:04:13 <Pseudonym> @wiki HaskellIrcPastePage
22:04:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:04:22 <Pseudonym> Some code I have for computing binomial coefficients the fast way.
22:06:52 <Pseudonym> Well, one of the fast ways.
22:07:07 <bC> pseudonym: thanks, i wish i knew what it meant :\
22:07:29 <lispy> maybe i was over simplifying, i have a function runTest :: [(Integer, IO String)], when I type runTest in ghci, it says No Instance for (Show (IO String)), how should I be calling this function?
22:07:37 <Pseudonym> bC: You don't want to see my last attempt, seriously.
22:08:14 <bC> i dont think u want to see my current attempt :P
22:08:23 <skew> How about the one from comonadic recursion schemes?
22:08:37 <skew> well, the factorial from there at least
22:09:27 <skew> wait, that one didn't require full course of values recursion.
22:09:56 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2003-August/004978.html
22:09:57 <Pseudonym> That's it.
22:10:00 <Pseudonym> My previous attempt.
22:10:42 <skew> InfTable is for sharing?
22:11:16 <Pseudonym> Yes, it's for memoing.
22:11:18 <lispy> so i changed it to runTest :: [IO String] then typed map (>>= print) runTest and I get the same error message
22:11:24 <Pseudonym> swing is actually factorial.
22:11:32 <lispy> i'm so stumped
22:11:50 <lispy> i just want print out the values that my program generates....
22:11:51 <skew> lispy: you have a list there
22:12:09 <skew> and runTest is just a list so far
22:12:17 <skew> try mapM print runTest
22:12:19 <bC> skew: so i should have a function like > coeff n = map (b n) [0..n]?
22:12:27 <skew> bC: yep, that looks good
22:12:39 <skew> now, do you see how to make bchelp?
22:12:55 <lispy> skew: no instances for (Show (IO String), Show (IO [()]))
22:13:05 <bC> bchelp calls that for the n and the k?
22:14:00 <skew> lispy: Oops. How about sequence runTest >>= print
22:14:18 <skew> bC: not quite. bchelp is just a list
22:14:30 <skew> bC: and how do you call coeff with a k anyway?
22:14:33 <lispy> skew: we'll know in a second, it's running :)
22:14:47 <skew> lispy: then it's already right :)
22:15:13 <bC> skew: i havent a clue, i've just been looking at this for such a crazy long time im becoming stupid
22:15:16 <lispy> skew: wow, thanks
22:15:39 <lispy> skew: is there a way to force it to print as it goes, incase i need to interrupt it?
22:15:47 <lispy> the algo i'm timing is NP-complete....
22:15:52 <skew> lispy: you should read about IO and monads, Control.Monad, so you understand what's going on
22:16:14 <skew> mapM (\act -> act >>= print) runTests should do the trick
22:16:30 <skew> or mapM (>>=print) runTest, I suppose
22:16:42 <bC> also, how do i even construct a table?  not sure how to make a list of lists
22:16:56 <skew> bC: like [[1,2], [3,4], [5]]
22:17:05 <skew> it's just a list with lists for elements
22:17:16 <bC> ok
22:17:25 <skew> The Haskell designers don't just arbitrarily exclude things like that
22:17:46 <lispy> skew: thanks for your help
22:17:58 <skew> as long as all the elements are the same kind of list, it will work
22:18:38 <bC> how do i get the list from coeff into bchelp?
22:19:04 <skew> okay, start a bit slower
22:19:22 <skew> try to make a list with just the first three rows
22:19:28 <skew> like [[1],[1,1],[1,2,1]]
22:20:15 <skew> Writing down constants doesn't work, so we need to abstract up a bit
22:20:29 <skew> write that list down using coeffs to make the elements
22:20:41 <bC> ok
22:21:11 <skew> see how coeffs does the job of making the lists that belong as elements of bchelp?
22:21:34 <bC> yes
22:22:14 <bC> how do i get coeff to put the generated lists into bchelp?
22:22:29 <skew> you don't get coeff to do anything
22:22:37 <skew> you define bchelp using coeff
22:22:46 <skew> remember, it's your job to define bchelp
22:22:49 <bC> oh
22:23:55 <bC> so it'll be something like bchelp = [[coeff x][coeff y]]?
22:24:01 <bC> be back in a sec
22:24:16 <skew> you don't need those inner brackets, coeff already makes a list
22:29:19 <bC> sorry about that, im back
22:29:47 <skew> define b and coeff in a file and load in an interpreter
22:30:08 <skew> so you can play around with things like that and see if they look right
22:30:32 <skew> just try to get an expression for the first three rows
22:30:45 <skew> start with [[1],[1,1],[1,2,1]], and see what you can do
22:30:50 <bC> how do i get the x and y values of coeff?
22:30:56 <skew> huh?
22:31:03 <skew> I don't think coeff has x and y values
22:31:18 <bC> i mean the 2 coeff values
22:31:44 <skew> hun?
22:31:52 <skew> do you have that interpreter ready?
22:31:54 <bC> i dont know where im calling coeff from
22:32:00 <bC> yeah
22:32:12 <skew> okay, type in [[1],[1,1],[1,2,1]]
22:32:20 <skew> and coeff 0, coeff 1, and coeff 2
22:33:04 <bC> ok
22:33:30 <skew> notice anything?
22:33:44 <bC> im typing the manual list into a file or the prompt?
22:34:00 <skew> try those expressions at the prompt
22:34:22 <bC> yeah, coeff gets me the list at that position
22:34:40 <skew> how?
22:34:46 <skew> Oh
22:34:46 <skew> right
22:34:47 <skew> nm
22:35:23 <skew> okay, so in Haskell you can always replace any expression with any other expression that has the same value
22:35:34 <skew> so stick the calls to coeff in a list
22:36:04 <bC> k
22:36:20 <skew> this is the same list
22:36:39 <bC> yeah
22:36:45 <skew> look at [coeff 0, coeff 1, coeff 2, coeff 3, coeff 4]
22:37:03 <skew> what list processing function does that remind you of?
22:37:12 <skew> (peek back at the definition of coeff)
22:37:34 <bC> map?
22:38:06 <skew> Yes. Now rewrite [coeff 0, coeff 1, coeff 2, coeff 3, coeff 4] to take advantage of map
22:38:49 <bC>  map coeff [0,1,2,3,4]
22:39:06 <skew> okay, that gives you the first five rows.
22:39:15 <skew> What should give you the first 101 rows?
22:39:29 <bC>  map coeff [0..100]
22:39:37 <a5> is this somewhere in the standard libs?
22:39:37 <a5> fmap2 :: (Functor m, Monad m) => (a -> b -> c) -> m a -> m b -> m c
22:39:37 <a5> fmap2 f x y = fmap fmap (fmap f x) >>= ($ y)
22:39:48 <skew> now, what does bchelp need to be?
22:40:06 <a5> (and is there a shorter way of writing it)
22:40:18 <skew> a5: whoa, what are you doing with that?
22:40:20 <bC>  map coeff [0..n]?
22:40:29 <skew> bC: that only goes up to n
22:40:39 <skew> bC: type in "[0..]"
22:40:48 <a5> skew: i forgot
22:41:04 <blackdog> @pointless  fmap fmap (fmap f x) >>= ($ y)
22:41:05 <lambdabot> ($ y) =<< fmap fmap (fmap f x)
22:41:05 <a5> seems useful though right?
22:41:26 <a5> what's pointless?
22:41:26 <bC> i want bchelp to be map coeff [0..]?
22:41:39 <skew> bC: try it and see
22:41:44 <blackdog> a plugin to lambdabot to make programs shorter and more confusing
22:42:09 <skew> a5: but yours was already short and confusing enough for it
22:42:09 <Gahhh> aka point free style
22:42:11 <blackdog> it didn't seem to make yours shorter, but i think it's more confusing...
22:42:22 <cm> :P
22:42:32 <a5> is it sophisticated?
22:42:50 <Gahhh> lambdabot is beyond sophisticated.
22:42:55 <bC> its working, but it feels slow
22:42:56 <dons> @help pointless
22:42:57 <lambdabot>  @pointless <expr> - play with pointfree code
22:42:58 <skew> a5: it eliminates variable names
22:42:58 <blackdog> lambdabot is money, baby.
22:43:04 <skew> bC: now for the magic trick
22:43:05 <dons> Gahhh, thank you :)
22:43:17 <dons> @remember Gahhh lambdabot is beyond sophisticated.
22:43:41 <bC> nice, nothing like a little magic to end the night :)
22:43:46 <skew> bC: do you have the definitions of bc and bchelp in your file?
22:43:50 <skew> @quote
22:43:51 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsib
22:43:51 <lambdabot> le for hastening the adoption of functional programming languages by providing
22:43:51 <lambdabot> a caricature of procedural OO.
22:43:58 <skew> @quote
22:43:59 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from england
22:43:59 <lambdabot> just to kill me if I did that
22:44:07 <bC> > bc n k = bchelp !! n !! k
22:44:11 <bC> >  where
22:44:11 <bC> >  bchelp = map coeff [0..]
22:44:11 <bC> > coeff n = map (b n) [0..n]
22:44:34 <skew> I guess not having any quotes was a problem of lost data?
22:44:58 <skew> bC: okay, now change b to bc and try it out
22:45:21 <Pseudonym> @quote
22:45:22 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsib
22:45:22 <lambdabot> le for hastening the adoption of functional programming languages
22:45:25 <Pseudonym> @quote
22:45:26 <lambdabot> samc says: monads are hard, let's go shopping
22:45:34 <Pseudonym> Oooh, I like that one.
22:45:41 <Gahhh> that one is on the wiki as well
22:45:43 <dons> it's a good'n
22:46:37 <theorbtwo> Yey, lambdabot no longer talks in NOTICEs and confuses my poor witless gaim.
22:46:50 <bC> works, how long would u estimate it would take to do b 100 40?
22:47:00 <skew> bC: a long time
22:47:10 <skew> bC: just a minute, I need to think a little more about the magic
22:47:20 <bC> k
22:47:33 <skew> bC: Okay, go in and change the recursive calls to b inside of b to calls to bc
22:47:44 <Pseudonym> It takes 0.01 seconds on my version. :-)
22:48:03 <bC> hehe
22:48:12 <bC> skew: already did
22:48:18 <Pseudonym> And 0.01 seconds to compute binomial 1000 400
22:48:25 <skew> bC: okay, that should speed it up
22:48:42 <a5> @pointless \x y -> x + y
22:48:45 <bC> still chugging along on 100 40
22:48:47 <skew> I hope
22:48:48 <skew> hmm
22:48:58 <bC> ...on 3.6Ghz
22:49:02 <Pseudonym> BTW, mine is actually fairly easy to understand.  factorialFactorisation computes the prime factorisation of n!
22:49:06 <skew> see if bchelp prints any faster
22:49:08 <Pseudonym> That's really the only tricky bit.
22:49:13 <Pseudonym> The rest is manipulation of prime expansions.
22:49:30 <bC> skew: what do u mean?
22:49:36 <a5> where is lambdabot?
22:49:37 <skew> Pseudonym: that's faster than the bigint math because of all the cancelation?
22:49:44 <Pseudonym> Probably.
22:49:50 <dons> hmm..
22:49:53 <Pseudonym> And because I'm working on machine words most of the time.
22:49:58 <Pseudonym> GHC optimises small Integers.
22:50:11 <Pseudonym> Also, the final multiplication is done divide-and-conquer.
22:50:21 <Pseudonym> So the faster bigint multiplication kicks in.
22:50:27 <skew> bC: hmm, bc 100 40 computes just about instantly for me
22:50:44 <bC> really?  i must be doing something wrong
22:50:53 <skew> at least after letting bchelp print for a bit
22:51:01 <skew> bc 1000 400 took a few secongs
22:51:01 <bC> i have this:
22:51:07 <bC> > bc n k
22:51:07 <bC> >  | k == 0       = 1
22:51:07 <bC> >  | n == k       = 1
22:51:07 <bC> >  | otherwise    = ((bc (n-1) (k-1)) + (bc (n-1) k))
22:51:11 <bC> > bc n k = bchelp !! n !! k
22:51:11 <bC> >  where
22:51:11 <bC> >  bchelp = map coeff [0..]
22:51:11 <bC> >  coeff n = map (bc n) [0..n]
22:51:15 <skew> no!
22:51:28 <skew> bc n k = bchelp !! n !! k
22:51:54 <skew> b n k | k == 0 = 1 | k == n = 1 | otherwise = bc (n-1) k + bc (n-1) (k-1)
22:52:06 <skew> bchelp = map coeff [0..]
22:52:12 <skew> coeff n = map (bc n)[0..n]
22:52:54 <skew> err, coeff n = map (b n) [0..n]
22:55:32 <bC> oh, there we go
22:55:52 <bC> it kept going slow, then i took out the where and it just blazed
22:56:12 <bC> is that strange?
22:57:01 <skew> that's a bit odd, but it isn't the where that's making it go fast
22:57:38 <blackdog> skew: if  you don't define bchelp at the top level, isn't it going to be recomputed each time?
22:57:48 <skew> that could be it
22:57:58 <bC> yeah, the where shouldnt have affected it like that should it?
22:57:58 <skew> depending on lifting
22:58:07 <skew> Maybe it should have
22:58:19 <skew> I think blackdog is right here
22:58:54 <a5> shorter: fmap2 f x y = return f `ap` x `ap` y
22:58:58 <blackdog> you have no idea how rarely i hear that. dons, how much would it take to bribe you to put that in the quotes file?
23:00:14 <dons> what's that?
23:00:20 <Gahhh> blackdog, what is 2+2 ?
23:00:21 <bC> skew:  thanks so much for your patience :)
23:00:29 <skew> personally, I like defining bchelp = iterate (\l -> zipWith (+) l (0:l)) (1:repeat 0)
23:00:30 <dons> oh, hehe.
23:00:46 <skew> yeah, I looked around for a while too.
23:01:09 <dons> @remember skew I think blackdog is right
23:01:36 <blackdog> Gahhh: give me a minute... *looks for an interpreter*
23:01:38 <Gahhh> dons: you appear to be typing rather than pasting it ?
23:01:39 <blackdog> @plugs 2+2
23:01:40 <lambdabot> 4
23:01:44 <blackdog> huzzah!
23:01:52 <skew> how did I get this while printing repeat 0?  ",0,0,0,0,,0,0,0"
23:02:04 <dons> I just chopped the end off that quote for clarity
23:02:18 <Gahhh> blackdog: Oh, you are absolutely, irrefutably correct on that one.
23:02:23 <Gahhh> There.
23:02:48 <blackdog> gonna print out a few pages of this channel and show my boss
23:03:00 <Gahhh> oh the b-word
23:03:34 <mflux> gahhh, "boss is a four-letter word"?
23:04:00 <skew> now this ",0,0,0,00,0,0,". I guess the ^C to interrupt is doing something strange
23:04:11 <Gahhh> I told my boss that I had learned Haskell and it made me a better programmer, he gave me the puzzled look you give to homeless people claiming to be Jesus.
23:04:44 <blackdog> thankfully, my boss knows nothing about programming languages, so if I put some haskell in, he almost certainly won't notice. :)
23:04:44 <skew> Gahhh: just tell him that he too can follow the one true path to pure functional programming
23:04:49 <Cale> skew: hmm, might have something to do with your terminal?
23:04:57 <Pseudonym> If someone will do @quote, I'll do the QuotesPage, okay?
23:05:03 <skew> it could be. Do you see anything like that?
23:05:36 <Gahhh> lambdabot should automatically submit it to wiki simultaneously.
23:05:37 <mflux> which reminds me, just yesterday I wrote a partial evaluation-module for C - although using it is a bit risky, using void*-casts and all. so I can say atleast ml/haskell has changed my way of coding ;)
23:05:46 <bC> everyone, thanks for all your help tonight!
23:05:52 <bC> good night!
23:06:31 <Cale> skew: nope, haven't seen anything like that
23:06:33 <skew> that sort of defect seems to consistently show up in the last few lines of output under mlterm, my usual terminal
23:06:35 <dons> blackdog: `runghc "\my lovely -> lambdas"` right? ;)
23:06:51 <mflux> skew, tried xterm, rxvt?
23:06:58 <skew> It still happens under a plain old xterm, so I doubt it's the terminal
23:07:03 <blackdog> dons: :) perhaps.
23:07:09 <skew> it was fairly far back
23:07:28 <dons> or we could always use hsinc ...
23:07:35 <blackdog> actually, i've been thinking about some haskelly webserver stuff. I'd really like to be able to do flexible resource allocation - like you've got with fuel in lambdabot
23:07:35 <mflux> skew, maybe a write() is interrupted because of ^C, but the actual signal is handled later
23:07:46 <Cale> skew: I use gnome terminal, it's quite slow, but seems to work :)
23:08:02 <blackdog> that way, i could put some haskell cgi programs on the web and have an easy way of restricting how much cpu time they can take.
23:08:21 <skew> maybe a third of a a screen back with "Small" characters at 1280x1024
23:09:12 <skew> I doubt there is anything that will take more CPU running to completion written normally that it would take being interpreted in a fuel monad in Haskell
23:09:14 <dons> blackdog, ah! loading them in runplugs over a pipe would be enough for that.
23:09:31 <dons> then it doesn't need fuel too
23:09:34 <skew> so that's probably not the way to go :)
23:09:44 <dons> just let the OS chop it off
23:09:55 <dons> @plugs [1..]
23:09:57 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
23:09:57 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
23:09:57 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
23:09:57 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
23:09:57 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
23:09:57 <lambdabot> 118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
23:09:59 <lambdabot> 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,
23:10:01 <lambdabot> [22 @more lines]
23:10:02 <dons> oops.
23:10:05 <Gahhh> lol
23:10:07 <dons> @plugs last [1..]
23:10:07 <blackdog> perhaps. what's the fuel module for, then?
23:10:11 <lambdabot> Terminated
23:10:39 <dons> fuel is used in eval for one, in a couple of other plugins too I think.
23:11:06 <blackdog> The other thing I was hoping to do was write it in such a way that it takes all the time it's allowed, then returns the best answer it's come up with - chess/scrabble on the net, that kind of thing.
23:11:26 <blackdog> you'd just return a stream of incrementally better results, until you came to the end or ran out of time.
23:12:12 <blackdog> also want to be able to sandbox them, but i guess runplugs does that for me anyway...
23:12:28 <dons> yeah. that's the best we have at the moment.
23:12:29 <blackdog> basically i want zope in haskell. :) monomaniac.
23:13:05 <dons> you run your code in a tiny little app, and tear it down after each run.
23:14:04 <dons> and let the type system handle most safety properties
23:14:32 <blackdog> so that's how fuel works?
23:14:46 <skew> is it?
23:15:12 <dons> fuel increments a value on each computation, up to a limit, iirc
23:15:27 <blackdog> on every single reduction, you mean?
23:15:27 <skew> I just remember @eval running out of fuel
23:15:49 <blackdog> @eval last [1..]
23:15:50 <lambdabot> (line 1, column 9):
23:15:50 <lambdabot> unexpected "."
23:15:50 <lambdabot> expecting simple term
23:15:53 <skew> I though @eval was a mini interpreter that counted its operations
23:16:16 <dons> yep.
23:16:28 <blackdog> @eval last [1..5]
23:16:29 <lambdabot> (line 1, column 9):
23:16:29 <lambdabot> unexpected "."
23:16:29 <lambdabot> expecting simple term
23:16:45 <blackdog> ok, so it's not all of haskell... ?
23:17:00 <skew> blackdog: not very much at all, I think
23:17:03 <skew> @help eval
23:17:04 <lambdabot>  @eval expr - evaluate the lambda calculus expression, expr
23:17:09 <dons> no. it's an interpreter
23:17:15 <blackdog> oh, right. lambdacalc.
23:17:19 <skew> @eval (\x -> x x) (\x -> x x)
23:17:21 <lambdabot> out of fuel - use @resume to continue
23:17:25 <skew> @resume
23:17:26 <dons> with a 'step' function that threads a fuel counter
23:17:27 <lambdabot> out of fuel - use @resume to continue
23:17:28 <skew> @resume
23:17:31 <lambdabot> out of fuel - use @resume to continue
23:18:08 <dons> for time limits in plugs I use unix cpu rlimits
23:18:08 <blackdog> ok, gotcha. so a more pragmatic way would be to set an external timer that signals the haskell process, and have a handler installed that can do something reasonable with the main computation...
23:18:25 <dons> yep
23:18:45 <blackdog> @plugs (\x -> x x) (\x -> x x)
23:18:46 <lambdabot> Occurs check: cannot construct the infinite type: t = t -> t1
23:18:46 <lambdabot> 	Expected type: t
23:18:46 <lambdabot> 	Inferred type: t -> t1
23:18:46 <lambdabot>     In the first argument of `x', namely `x'
23:18:46 <lambdabot>     In a lambda abstraction: \ x -> x x
23:19:02 <blackdog> ... ok, that should have been obvious. :)
23:27:07 <Lemmih> musasabi: Ping.
23:59:22 <mwc> anybody know where to find the Haskwell Webserver?
23:59:38 <mwc> I've googled, but nothing but dead links and all that good stuff :(
23:59:50 <skew> mwc did you test that threading?
