00:00:00 <desrt> how do i exploit the hot haskell capabilities?
00:00:11 <desrt> or do i need hs-plugins for that?
00:00:13 <dons> you'd have to install hs-plugins
00:00:34 <dons> then you can write a ~/.yi/Config.hs and start tweaking stuff on the fly
00:00:54 <desrt> hs-plugins isn't apt-getable.  how upsetting
00:00:58 * desrt utilises google
00:01:15 <desrt> oh.  i see
00:01:25 * desrt takes a wild guess and invokes darcs
00:01:30 <dons> nah..
00:01:31 <dons> sorry.
00:01:49 <dons> http://www.cse.unsw.edu.au/~dons/hs-plugins for the main page.
00:01:58 <desrt> ya.  there now.
00:03:14 <desrt> hm.  hs-plugins isn't "-j"-safe
00:03:14 <dons> yi's got a nice undo mode too, and it's also nice the editing a split buffer works :)
00:03:17 <dons> nah.
00:03:25 <dons> it doesn't use my new-age build system.
00:03:31 <dons> it's back in cvs/ghc--make world
00:03:38 <dons> not darcs/ghc-M
00:03:43 <desrt> can you get a split buffer with one editor interface in the top and another in the bottom?
00:03:52 <dons> not at the moment.
00:04:02 <desrt> do you know how i add to the ghc package path?
00:04:14 <dons> -package-conf foo/bar/package.conf
00:04:32 <dons> you can use the plugins.conf.inplace I think.
00:04:45 <desrt> i installed to /opt
00:05:31 <dons> oh, you're on a mac?
00:05:35 <desrt> no
00:05:44 <dons> ok.
00:05:46 <desrt> i'm just freakishly neat about /usr
00:06:27 <dons> me too - that's why there's an inplace package.conf file :)
00:06:44 <desrt> oddly, it didn't install a package.conf file
00:07:02 <desrt> just plugins.conf.in
00:07:19 <dons> which is a .conf file for ghc-pkg use
00:07:45 <desrt> right.. but shouldn't autoconf have de-.in-ified it?
00:07:52 <dons> there's a 'make register' target. but seriously, at this point, use the inplace package.conf, otherwise you'll have to register it
00:08:04 <dons> nope. it's for package install time.
00:08:18 <dons> at package install time it gets merged into ghc's package.conf
00:08:46 <dons> different to configure time. makes things work for port systems
00:09:53 <desrt> ghc -Wall -Werror -funbox-strict-fields -O2 -fasm -Icbits -Imk  -package-conf /home/desrt/hs-plugins-0.9.8/plugins.conf.inplace -DLIBDIR=\"/opt/yi/lib/yi\" -main-is Boot.main -c Boot.hs -o Boot.o -ohi Boot.hi
00:10:00 <desrt> right idea?
00:10:12 <dons> yep. it's just building the static component.
00:10:20 <dons> the dynamic component is in HSyi.o
00:10:27 <desrt> Boot.hs:54:
00:10:27 <desrt>     Failed to load interface for `Plugins':
00:10:27 <desrt>         Could not find interface file for `Plugins'
00:10:27 <desrt>         (use -v to see a list of the files searched for)
00:10:29 <desrt> bewm
00:10:37 <desrt> same for Plugins.Utils
00:10:49 <dons> you need to add: -package plugins
00:11:00 <dons> after the -package-conff arg
00:11:07 <desrt> oh.  i guess i shouldn't have removed that
00:11:14 <dons> ;)
00:11:59 <desrt> i thought that -plugin-conf was an explicit way of giving a path to a plugin :)
00:12:10 <desrt> s/plugin/package/g
00:12:15 <dons> oh. nope.
00:12:22 <desrt> more like -I
00:12:50 <dons> once it builds, and ./yi-inplace works, you can cp examples/AddBind.hs ~/.yi/Config.hs and see if ./yi-inplace opens up with the new settings
00:14:00 <desrt> yi rulesyi rulesyi rulesyi rules-- Copyright (c) 2004 Don Stewart - http://www.c
00:14:03 <desrt> hmm
00:14:06 <dons> then you could: ./yi-inplace ~/.yi/Config.hs , edit it, save, and :reload should bring in the new values
00:14:24 <dons> without having to quit and recompile ~/.yi/Config.hs
00:14:46 <dons> so, changing the colours for example
00:14:48 <desrt> :reload doesn't handle the file starting with "yi rules" very well :)
00:15:04 <dons> :reload has no args I think
00:15:16 <desrt> right.. but it doesn't handle errors well
00:15:20 <desrt> like if Config.hs is invalid
00:15:40 <dons> oh, it should just print some errors. what do you see?
00:15:53 <desrt> prints some errors :)
00:16:00 <dons> ok. that's 'well' in my def
00:16:44 <desrt> it's ok.  the lack of ^L sort of made it annoying.
00:16:48 <desrt> this is neat
00:16:58 <dons> ^L ?
00:17:03 <dons> refresh?
00:17:07 <desrt> refresh screen in just about any curses app
00:17:17 <dons> hmm. should work...
00:17:21 <dons> works nicely for me.
00:17:30 <desrt> maybe it was confused by me breaking the config file
00:18:06 <dons> oh, not in vi mode.
00:18:26 <dons> change ~/.yi/Config.hs to import Keymap.Vim not Keymap.Vi
00:18:47 <dons> that's a bug in the vi mode. thanks!
00:18:54 <dons> should have :     ,('\^L',    const refreshE)
00:19:01 <dons> in the keybinding lexer.
00:20:02 <desrt> hum.  still no ^L
00:20:06 <desrt> lemme try to exit/restart
00:20:41 <desrt> ok.  i have it now.
00:20:45 <dons> :reload
00:20:49 <desrt> for some reason :reload didn't do it
00:21:09 <desrt> also, i get this more than i should: No write since last change (add ! to override)
00:21:17 <dons> oh, the HSyi.o wasn't reloaded. a :reboot would probably have done it.
00:22:02 <dons> yeah, I seem to remember that there's a bug in the vi 'write since last change' test somewhere
00:23:09 <dons> oh, I see, the error msgs get dumped to the screen. hmm.
00:23:17 <dons> when Config.hs doesn't tycheck
00:23:38 <desrt> is yi self-hosting?
00:23:52 * shapr uses yi to compile yi
00:24:07 <desrt> The "make" command is unknown.
00:24:15 <shapr> yishell isn't that great just yet.
00:24:17 <desrt> not quite what i meant :)
00:24:17 <dons> no. you still need to jump back to a shell.
00:24:30 <desrt> i mean, "do you guys use yi to hack yi?"
00:24:38 <dons> oh, I do sometimes. I just did then.
00:24:42 <dons> grab the new page
00:24:46 <dons> s/page/patch/
00:25:06 <dons> I just love how responsive it is. makes vim look slow.
00:25:18 <shapr> I'll use it once it has pretty colors. Happily dons has just added the synhl preview edition.
00:25:21 <desrt> darcs up?
00:25:26 <shapr> It's now my job to make it a reality!
00:25:28 <shapr> darcs pull
00:25:30 <dons> darcs pull
00:25:54 <desrt> excellent
00:28:21 <ozone> hehe, you said pull
00:30:29 <shapr> A lispy mode should be an easy target for a parser.
00:32:06 <desrt> save detection is broken in all modes
00:32:21 <desrt> they all call isUnchangedE
00:32:28 <dons> yeah. I looked at  the code. it's not obviously wrong, is it?
00:32:31 <desrt> which returns if the document has changed since it was open
00:32:35 <desrt> not since the last save
00:32:41 <dons> hmm..
00:33:03 <desrt>     isUnchangedB (FBuffer _ _ mv _) = do
00:33:03 <desrt>         ur <- readMVar mv
00:33:03 <desrt>         return $ isEmptyUList ur
00:33:27 <dons> yeah. so the undo list should be emptied on save.
00:33:34 <dons> I think I remember this issue.
00:33:35 <desrt> that's evil, though
00:34:13 <dons> yep. hence not implemented.
00:34:26 <desrt> do you have a generic record type for the document?
00:34:40 <desrt> or just a data?
00:34:46 <dons> ??
00:34:55 <desrt> isUnchangedB (FBuffer _ _ mv _)
00:35:04 <desrt> looks like you have a named 4-tuple to represent document state
00:35:16 <dons> yeah. look in FastBuffer.hs
00:35:20 <desrt> there now
00:35:39 <dons> the general interface is in Buffer.hs
00:35:55 <desrt> is fastbuffer the only one right now?
00:36:02 <dons> yep.
00:36:09 <dons> used to have slowBuffer, but it was slow
00:36:13 <desrt> :)
00:36:25 <desrt> so
00:36:34 <desrt> is there a reason that you use a data instead of a record?
00:37:06 <dons> is there a reason I don't explicitly label the fields?
00:37:10 <dons> no , verbosity perhaps
00:37:26 * desrt blinks in confusion
00:37:30 <dons> i do in Window.hs for example
00:37:51 <desrt> ya.  that's what i mean
00:38:01 <dons> I don't understand what you mean by "data vs record" -- they're all datas, but one has named fields
00:38:25 <desrt> ya.  sorry about that.   i had forgotten that you use 'data' to declare record types
00:39:10 <desrt> i guess left-side pattern matches are a lot nicer if you assume a fixed number of args
00:39:18 <dons> yeah.
00:39:33 <desrt> i'm just looking for somewhere to shoehorn in a "modified since last save" flag
00:39:37 <dons> I used to have named fields for FBuffer, but they obfuscated the code in FastBuffer I thought
00:40:15 <desrt> is undo infinite?
00:40:19 <dons> yeah.
00:40:26 <desrt> do you have Eq defined on the datatype?
00:40:41 <shapr> Is there a library of happy parsers somewhere?
00:40:48 <shapr> I don't see one in fptools.
00:40:56 <dons> desrt, nope.
00:41:02 <desrt> hmm
00:41:05 <dons> shapr, I don't think there's a lib anywhere
00:41:22 <desrt> yi is fun
00:41:45 <dons> Eq doesn't make sense on Undos.
00:41:50 <shapr> yeah, yi is fun!
00:41:54 <desrt> it could
00:41:59 * Oeje1 wants to run fun Yi, but couldn't get HS-Plugins to compile. :-(
00:42:03 <desrt> my idea was on save you save a copy of the undo list
00:42:04 <dons> it could, true.
00:42:17 <desrt> then on exit, you check if undo list is eq the undo list at save time
00:42:29 <desrt> that way it would even handle the case of saving, undoing some changes, then quiting
00:42:33 <dons> undo's could have Uniques
00:43:04 <desrt> but in the case of doing something then undoing back to the point of last save, you'd still want it to be equal
00:43:54 <Oeje1> Is there an arraw based parser combinator library somewhere?  I can't seem to find one, but it's mentioned in the arrow paper that it's a good idea.
00:43:58 <dons> I've thought about this, I think my plan was to find out how other editors do it..
00:44:16 <dons> Oeje1: why didn't hs-plugins compile? that sounds bad.
00:44:24 <dons> it should at least compile.
00:44:41 <dons> 6.4 needs the cvs snapshot of hs-plugins, btw.
00:44:41 <Oeje1> dons: Snapshot from yesterday.
00:44:50 <dons> what OS?
00:44:54 <Oeje1> GoboLinux.
00:45:02 <dons> which ghc?
00:45:09 <Oeje1> 6.4.
00:45:27 <dons> ok, it gets nightly regressed on 6.4/linux. I'll check again
00:45:38 <dons> in general, you should send me the log of the build if something like this happens
00:46:28 <dons> hs-plugins-20050404.tar.gz  ?
00:46:42 <desrt> dons; you could always take the md5 sum of the content and hope that the user doesn't get extremely unlucky :)
00:46:50 <Oeje1> 20050403.
00:47:21 <dons> desrt: yeah, I was thinking about that. using uniques and concat.show them would probably be ok too.
00:47:31 <dons> oh, sorry, the content... hmm...
00:47:35 <dons> :/
00:47:51 <desrt> that was meant sort of as a joke :)
00:48:05 <dons> hehe. I know ;)
00:48:21 <dons> Oeje1: in what way didn't it compile?
00:49:03 <dons> builds for me on Linux
00:49:06 <Oeje1> dons: Making logs now.
00:49:43 * dons thinks hs-plugins should lose some weight and grow a build system.
00:50:33 <dons> it's weird how the build system influences my opinion of software
00:52:01 <desrt> yi has some evil in it
00:52:17 <dons> desrt: no!
00:52:26 <dons> where? ;)
00:52:29 <desrt> you use ForeignPtr CChar instead of String
00:52:36 <dons> oh, you _need_ that
00:52:44 <desrt> ridiculously slow otherwise?
00:52:49 <dons> otherwise performance sucks sooo bad
00:53:00 <desrt> what about a Char array?
00:53:16 <dons> ForeginPtr CChar is like a fast Char array
00:53:26 <desrt> that doesn't have Eq :P
00:53:42 <dons> anyway, the FFI has its own report. it's not that evil
00:53:58 <dons> and it's good when you have a huge mutable state you don't want copied all over the place
00:54:12 <desrt> sigh
00:54:19 <dons> instance Eq FBuffer where
00:54:19 <dons>    (FBuffer _ u _ _) == (FBuffer _ v _ _) = u == v
00:54:25 <dons> that's an Eq ;)
00:54:43 <dons> it proved impossible early on not to use mutable state
00:54:44 <desrt> i'm looking here
00:54:48 <desrt> data URAction = Insert !Point !Size !(ForeignPtr CChar)
00:54:48 <desrt>               | Delete !Point !Size
00:54:52 <dons> hence SlowBuffer became FastBuffer
00:55:00 <dons> same problem
00:55:19 <dons> if you want an undo that works on large chunks, String is no good.
00:55:21 <Lunar^> dons: the FFI report is where is unsafePerformIO is defined, and you are saying that it's not evil ?! ;)
00:55:26 <dons> hehehaha
00:55:37 <Oeje1> dons: http://www.student.dtu.dk/~s022018/Temporary/log ...It build fine this time. (?).
00:55:46 <desrt> Lunar^; unsafePerformIO isn't that bad
00:56:24 <desrt> i'm one of the many who is of the mind that unsafePerformIO should be allowed to be a part of any language that has a foreign C interface that lets you import random C symbols and call them pure
00:56:39 <desrt> since the latter is much worse than the former :)
00:56:45 <Lunar^> desrt: At this rate, we are soon going to say that unsafeCoerce# should be used in every Haskell module
00:56:50 <dons> I did originally use just String for the undo list, but I couldn't do feasible undo of more than a few 10s of lines. All that boxing from content->String->content too
00:57:40 <Lunar^> dons: I hope you'll write a book on Yi afterward
00:57:46 <desrt> hmm
00:58:00 <dons> Oeje1: that's not my bulid log. what's this Recipe stuff?
00:58:01 <desrt> what if you make a FastString.hs to encapsulate the evil
00:58:08 <desrt> and export a datatype that has Eq
00:58:22 <Lunar^> dons: about turning Haskell upside down to make it, I mean
00:58:32 <dons> yeah, the Foreign stuff for buffer types should be abstracted, I guess.
00:59:01 <desrt> if you don't like the name FastString, i also recommend EvilString
00:59:14 <dons> Lunar^: hmm true. i alway think there should be an advanced haskell book for getting good performance
00:59:53 <Oeje1> dons: It's the GoboLinux source building system at work.  Those control characters are colour codes.
01:00:44 <dons> it appears to build correctly from what I can see.
01:00:46 <dons> I see: find: invalid argument `UNKNOWN' to `-user'
01:00:50 <dons> but that's not my code.
01:01:06 <dons> I see: chown: `UNKNOWN:UNKNOWN': invalid user
01:01:08 <Oeje1> dons: That's just Compile quirking. ;-)
01:01:33 <dons> it even seems to register correctly. what's wrong with it?
01:01:47 <Oeje1> dons: Nothing it seems.
01:02:01 <dons> ok...
01:02:21 <dons> but it did break yesterday?
01:02:38 <dons> weird.
01:02:57 <Oeje1> Yay!  Yi compiled!---Yes it broke yesterday.  GHC does that sometimes.
01:03:18 <dons> hehe
01:03:26 <desrt> mallocForeignPtrBytes
01:03:30 <desrt> man.  i love this.
01:03:45 <dons> oh. boo hoo. :)
01:03:53 <desrt> no.  seriously.  it's hot.
01:04:00 <dons> one of the main goals is to be fast. really fast.
01:04:07 <desrt> is this garbage collected?
01:04:15 <dons> no one should go around saying "look haskell is slow"
01:04:42 <dons> withForeignPtr
01:05:53 <desrt> man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
01:05:59 <Oeje1> dons: The registration of hs-plugins is it only setting environmental variables?
01:06:29 <Oeje1> desrt: lol.
01:06:33 <dons> desrt!
01:06:46 <dons> @remember desrt man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
01:06:50 <dons> @quote desrt
01:06:51 <desrt> i see malloc() free() memcpy()
01:06:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   man... there's this whole dark side to haskell that dr. kahl didn't teach
01:06:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- us in 3e03
01:06:53 <desrt> this is exciting
01:07:32 <desrt> you could practically transliterate a C program to this
01:07:53 <dons> it used to be scarier. than my supervisor encouraged me to stick to the known report adenda, and not use random GHC.Prim stuff
01:08:33 <dons> I think shapr remembers lines like "Please forgive me" as we unsafeCoerce# random objects all over the place
01:08:33 <desrt> crickey, mkInsert is evil
01:08:40 <desrt> advancePtr is basically just +, right?
01:08:57 <dons> + sizeof(type)
01:08:59 <dons> yeah.
01:09:11 <desrt> + on pointers does that :)
01:09:29 <desrt> k.  i don't understand this
01:09:32 <desrt>     withForeignPtr fptr $ \fp -> copyBytes fp (ptr `advancePtr` off) n
01:09:36 <desrt> why not just:
01:09:48 <desrt> copyBytes fptr ((ptr `advancePtr` off) n
01:10:04 <desrt> with less (
01:10:28 <dons> isn't it so the ptr eventually gets garbage collected ?
01:10:43 <musasabi> desrt: because you need a Ptr not ForeignPtr for copyBytes.
01:10:50 <desrt> ah
01:11:17 <dons>  the compiler
01:11:17 <dons> can only track usage of the ForeignPtr object, not a Ptr object made from it.
01:11:38 <dons> which is the other side of the story. musasabi has the first side.
01:11:38 <desrt> oh.  i see
01:11:48 <desrt> so you use ForeignPtr so that you get GC
01:11:55 <desrt> and because you use ForeignPtr you have to use withForeignPtr
01:12:02 <desrt> that's actually *really* nice
01:12:18 <dons> yep. I don't want to do my own memory management -- come on! this is Haskell.
01:12:25 <desrt> so
01:12:39 <desrt> i'm thinking that FastString.hs will make extensive use of unsafePerformIO
01:12:41 * musasabi uses a slightly modified foreignptr that can only live in haskell land.
01:12:50 <desrt> since it will want to call all of this malloc stuff but it will also want to be a pure datatype
01:13:12 <musasabi> desrt: look at the FastString in darcs.
01:13:20 <desrt> oh.
01:13:22 <desrt> this already exists?
01:13:27 <musasabi> yep.
01:13:30 <dons> yeah. and PackedString in ghc
01:13:30 <desrt> how upsettings
01:13:34 <dons> :}
01:13:36 <desrt> blah
01:13:40 <desrt> NIH is my middle name
01:13:42 <desrt> i'm going to bed
01:13:58 <Oeje1> dons: So, what does "make register" do?  It looks like it's just setting some variables.  The build is sandboxed, so it can't write to files outside of it's build directory and installation directory.
01:13:59 <shapr> Truly, yi used to be have x-files quality internals.
01:14:21 <dons> ah. 'make register' updates ghc's package.conf file
01:14:24 <musasabi> taking the ropes from boehm-gc to haskell would be very nice.
01:14:25 <shapr> The truth was out there but heck if I could find it.
01:16:05 <shapr> musasabi: I wonder if there's a generalization.
01:16:15 <musasabi> shapr: hmm?
01:16:42 <musasabi> shapr: yes, they should work for other types than Word8 if that is what you mean.
01:16:51 <shapr> ShowS is sort of like that, and so is ++ because of its O(1) behaviour.
01:17:15 <musasabi> ShowS and ++ are kind of unpredictable.
01:17:32 <Itkovian> meuning
01:17:33 <shapr> ropes/cords seems to be a special case of lazy concatenation.
01:17:49 <shapr> Itkovian: howdy pardner
01:18:07 <musasabi> shapr: and they offer the ablities for cheap edits in the middle...
01:18:51 <Oeje1> Ok, so Yi is running; now how do I turn on syntax highlighting for Haskell sources?
01:19:45 <shapr> cheap edits as part of the concat process?
01:19:56 <dons> Oeje1: there's no syn hl yet.
01:20:00 <musasabi> as part of the tree-structure.
01:20:13 <Itkovian> hi shapr
01:20:19 <shapr> hoi Itkovian
01:20:30 * shapr chews on some tasty code
01:20:31 <Oeje1> Ah, that's what synhl means.  I've seen that on the channel alot.
01:20:37 <Itkovian> hmm ... darcs ... checking GHC.Handle.openFd new API... failed
01:20:54 <dons> isn't that the 'tried to build with 6.4' error?
01:21:05 <musasabi> with lists something like "take 50000 list ++ something ++ drop 50001 list" is not very cheap ;)
01:21:24 <Itkovian> dons: maybe, googling for it
01:21:37 <Oeje1> Itkovian: Build 1.0.2 with 6.2 and current with 6.4.
01:21:38 <musasabi> Itkovian: you need to use darcs from the darcs repository with ghc 6.4.
01:22:05 <Itkovian> ic.
01:22:10 <Itkovian> iok, fetching
01:23:50 <Oeje1> Man, that's scary...a sandboxed compile writing to a file outside of the sandbox.
01:24:15 <dons> it should only write on install, shouldn't it?
01:24:20 <dons> that's how I do it on OpenBSD.
01:24:27 <dons> it's bizarre that it would do it earlier.
01:24:48 <Oeje1> dons: Oh, the install is also sandboxed.
01:26:12 <Oeje1> This program packages as seperate directories idea is really a pain with central configuration/registration.
01:28:00 * boegel waves at everyone in #haskell
01:28:00 * Oeje1 walks around in the room with a big sign: "Can't you see, we need synhl in Yi!".
01:28:13 <musasabi> hello boegel
01:28:18 <Itkovian> boegel.
01:28:28 <Oeje1> Hej, boegel.
01:28:35 <boegel> can someone explain me what the difference is between 'data Foo = Bar x y' and 'newtype Foo = Bar x y' N
01:28:41 <boegel> s/N/?
01:28:53 <musasabi> getting acme like mouse would be cool ;)
01:30:00 <jlouis> morn
01:30:07 <Cale> one is valid, and the other isn't? :)
01:30:07 <Itkovian> ing
01:30:24 <boegel> Cale ? the newtype is wrong ?
01:30:35 <shapr> musasabi: acme like?
01:30:37 <Oeje1> boegel: It depends on the context.
01:31:02 <Cale> newtypes don't create real data constructors
01:31:07 <boegel> I sense the difference is subtle, but I would like to know what the difference really is
01:31:29 <shapr> I've heard that newtype doesn't make a wrapper.
01:31:30 <Cale> They create tags which are boiled away by compilation.
01:31:48 <shapr> Crap, I have school in fifteen minutes, yipes!
01:31:52 <Cale> newtype MyInteger = MI Integer
01:31:52 <boegel> Cale: when using newtype, I can't pattern match on (Bar x y) ?
01:31:53 * shapr disappears quickly
01:31:57 <musasabi> shapr: the plan9 editor of choice :-)
01:31:58 <Cale> boegel: that's right
01:32:18 <musasabi> shapr: it has very nice mouse bindings.
01:32:26 <boegel> Cale: and then the (Bar x y) is make use of a data constructor ?
01:33:00 <Cale> A declaration of the form
01:33:00 <Cale> newtype cx => T u1 ... uk = N t
01:33:00 <Cale> introduces a new type whose representation is the same as an existing type.
01:33:50 <boegel> and what about type then ?
01:34:14 <Cale> type produces a type synonym
01:34:15 <Itkovian> type defines an alias
01:34:25 <boegel> hmm, kay
01:34:37 <Itkovian> which sucks because it allows type 'conflicts' to pass unnoticed
01:34:41 <boegel> since I need data constructors, I should keep using 'data' then
01:35:04 <Cale> the type created by newtype is still a different type, but the representation in memory is the same as the original type.
01:35:53 <boegel> okay, I understand... thanks !
01:35:56 <Cale> if you write  data Dollars = Dollars Integer  on the other hand, work will have to be done to convert from Integer to Dollars.
01:36:09 <musasabi> Does curses support mouse (as xterm does on e.g. some text-mode browsers support it there) ?
01:38:23 <boegel> Cale: can newtype take more than 1 'argument' ? because like you represent it, it's just a redefinition of one type
01:38:40 <tuomov> musasabi: yes, but why anyone would want to use it escapes me
01:39:02 <musasabi> tuomov: actually it can be quite convenient.
01:39:14 <Cale> boegel: no, the tag thereby constructed can only have one parameter
01:40:21 <boegel> oh, then I certainly need 'data'
01:40:23 <Cale> yes
01:40:40 <boegel> except maybe for some stuff...:)
01:40:47 <boegel> anyway, this helped me a lot :)
01:41:43 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.3 for more details on newtype (and around there, info about type and data as well)
02:06:38 <vegai> oh, new version of nhc98
02:08:57 <Oeje1> So what cool things can I do in Yi now?
02:11:33 <wilx> Edit files, isn't that cool enough? :)
02:12:12 <Oeje1> Bah, editing file is 0ld sch00l.
02:12:50 <wilx> And old school ain't cool?
02:13:01 <wilx> I consider many old school things cool :)
02:13:37 <wilx> For example ABBA  and .MOD files :)
02:13:39 <vegai> it's ubercool, but unfortunately 8-bit, so it wraps around to being super-lame
02:14:03 <vegai> (like that joke)
02:14:22 <wilx> Hehe.
02:14:55 <Oeje1> The Vi binding for Yi is not quite like Vim.
02:15:10 <dons> no. the Vim binding is like Vim ;)
02:15:36 <jlouis> dons: I am glad you like my changes. There are more coming your way in half an hour, when I have tested them, heh
02:16:03 <dons> cool :) much appreciated.
02:16:17 <nlv11757_> can i use -package in combination with -prof ? cause im getting undefined references in the linking process
02:16:22 <tuomov> I should finish my joe keymap some day...
02:16:29 <tuomov> there's no selection support yet?
02:16:44 <dons> nope.
02:16:55 <Oeje1> Well, the command 'A' places the cursor before the last character and in Vim it places the cursor after.
02:17:48 <dons> are you in vim mode?
02:18:01 <dons> 'A' works for me.
02:18:13 <Oeje1> dons: I haven't changed from the default.
02:18:56 <dons> maybe your confused by the explicit \n chars yi currently displays.
02:19:02 <Oeje1> Man, Yi is slooow.
02:19:10 <dons> ! really? how so?
02:19:33 <Oeje1> I could try to profile it.
02:19:55 <dons> send me a reproducible editing sequence
02:20:31 <Oeje1> yi-inplace test.hs, 'j'.
02:20:32 <dons> yi's already been highly profiled, for what it's worth. there's plenty of unchecked sequences though, that I might not have considered.
02:20:57 <dons> ?
02:21:06 <dons> moving down 1 line is  slow?
02:21:25 <Oeje1> Profile build is "make -p"?
02:21:29 <dons> noticeably faster than vim on my machine.
02:21:35 <dons> no. make way=p
02:21:50 <dons> it's static only, so you need to use ./yi-static +RTS -p -RTS
02:21:51 <Oeje1> Well, test.hs contains a very long first line.
02:22:10 <dons> I guess it's possible. how long?
02:22:37 <dons> I haven't looked at long lines so much, as horizontal scrolling isn't implemented
02:22:54 <dons> large files themselves have been tested fairly well.
02:23:04 <Oeje1> http://www.student.dtu.dk/~s022018/Temporary/test.hs
02:25:37 <dons> how fast is vi on the same file?
02:25:39 <Si\> hmmm how can you stop TH instance functions being fully qualified by pprint, GHC isn't liking them
02:25:58 <dons> Oejel: nice test case, btw.
02:27:38 <Oeje1> dons: Thanks, that's from the "let's punish GHC" test collection.
02:28:19 <dons> hehe
02:29:45 <nlv11757_> no-one with experience in compiling an application with -prof and -package ?
02:30:18 <dons> you need to have _p versions of your packages
02:30:38 <nlv11757_> i have
02:30:52 <nlv11757_> but i still get undefined references while linking
02:31:20 <jlouis> dons: you've got mail ;)
02:32:01 <dons> Oeje1: yep. slow. looks like vim does a little optimisation when linewrapping is off. but yi's about the same speed as vim with linewrapping.C
02:32:15 <dons> i'll think about it.
02:32:44 <Si\> is there any function in TH for namespace unqualifying a Name?
02:32:56 <dons> yi starts up much faster on that file though :) instant vs 7sec startup.
02:33:09 <dons> jlouis: got it.
02:33:13 <Oeje1> dons: My Vim is much faster even when linewrapping.
02:34:22 <dons> hmm. try 'k' in vim.
02:34:34 <Oeje1> dons: make clean; configure; make way=p gives: make: *** No rule to make target `Yi.o', needed by `Main.o'.  Stop.
02:34:47 <dons> yeah. me too. that's new. not sure what it is yet.
02:36:09 <Oeje1> dons: It seems to be a tiny bit slower moving up than down.  Could just be that it's filling the terminal with pluses.
02:36:47 <dons> ok. maybe my vim is older. seems much slower (3-4s) going up.
02:37:07 <dons> anyway, i'll look at this. it's a good bug.
02:37:21 <Oeje1> Yay!
02:37:35 <dons> takes around 7s down in yi.
02:37:43 <Oeje1> dons:  VIM - Vi IMproved 6.2 (2003 Jun 1, compiled Sep 28 2003 23:49:28)
02:38:06 <dons> oh, that's quite old. hmm. VIM - Vi IMproved 6.3 (2004 June 7, compiled Jan 28 2005 06:59:37)
02:41:00 <nlv11757_> could my undefined references have anything to do with the new features regarding packages in ghc 6.4?
02:46:41 <Oeje1> dons: Some data points regarding test.hs.  Consecutive key presses after opening the file: j: 40s, j: 13s, k: instant, k: 10s.
02:47:03 <dons> 40. wow. thanks.
02:48:28 <Oeje1> Got to go.  Bye.
03:34:18 <boegel> any maths people in here ?
03:34:26 <ibid> depends
03:34:35 <ibid> (on the question, as always)
03:34:38 <Itkovian> whadda ya wanna know
03:35:06 <boegel> I wanna know how I should normalize a vector when it's length is zero
03:35:26 <Itkovian> you can't
03:35:39 <ibid> well, it's the identity transformation :)
03:35:41 <boegel> but I have to :)
03:35:46 <Itkovian> a vector with length 0 is (0 0 0 0 ... 0)
03:35:50 <Itkovian> by definition
03:35:53 <boegel> Itkovian: not always
03:36:00 <Itkovian> example?
03:36:03 <ibid> actually, not an identity transformation
03:36:04 <boegel> err
03:36:28 <boegel> heh, damn :)
03:36:51 <Itkovian> idib: how would you define a consistent metric that given length 0 for something non-zero in a vector space?
03:37:17 <ibid> Itkovian: i don't
03:37:18 <tuomov> itkovian: depends on whether your working in a normed or semi-normed (or was it pseudo- or do people use both..) space
03:37:33 <boegel> Itkovian: I think I'm looking to hard for possible problems ;)
03:43:15 <jlouis> tuomov: semi-normed I think is the usual definition
03:45:05 <shapr> ok now!
03:45:23 <shapr> ibid: I tried that identity transformation, it was fun.
03:45:47 <ibid> shapr: but it was wrong :)
03:45:54 <ibid> shapr: how is the id fun?
03:46:08 <shapr> I changed my identity.
03:46:15 <ibid> heh
03:47:43 <nlv11757_> can i use haskell@haskell.org to mail questions? or is that unsuitable for that?
03:47:58 <dons> try haskell-cafe@
03:48:42 <dons> unless it's a nasty technical question.
03:52:44 <nlv11757_> no, its this profiling problem which i cant get solved
03:52:53 <nlv11757_> probably some trivial mistake from my side
03:54:36 <dons> it's a ghc question though? glasgow-haskell-users@ is more appropriate then
03:55:20 <nlv11757_> ow hehe, I'll sign up with that one too also then :)
03:55:49 <shapr> nlv11757_: btw, if you like nntp, signup, turn off delivery, and then use gmane.org
03:57:27 <nlv11757_> newsgroup interface to the lists?
03:57:37 <shapr> yop
03:57:41 <nlv11757_> niiiice
03:57:52 <shapr> http://news.gmane.org/index.php?prefix=gmane.comp.lang.haskell
03:57:55 <nlv11757_> i was just thinking...this emailing thing is not so convenient :)
03:58:23 <shapr> gmane.org also means you instantly have access to all the history
03:58:51 <nlv11757_> thanks shapr
03:59:27 <shapr> hiya Entro-P! would you like to learn Haskell?
03:59:40 <Entro-P> why not :)
04:00:01 * boegel feels a tour coming up
04:00:04 <shapr> Awright! Do you have any prior experience with functional programming? Scheme? Lisp? ML?
04:00:34 <Entro-P> no
04:00:35 <shapr> First I'll give you the tour of the #haskell channel.
04:00:59 <shapr> Here on the left we have the channel guardian and all around assistant, lambdabot
04:01:03 <Entro-P> many languages, none functional though
04:01:18 <nlv11757_> shapr: quick interruption of the tour...do i need to subscribe to that gmane also?>
04:01:21 <shapr> lambdabot was recently exported in a "live vicious animals" box back to his land of origin, so he's pretty calm this week.
04:01:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
04:01:30 <nlv11757_> if im already subscribed at haskell.org
04:01:46 <Entro-P> well, they all work, just not categorised as 'functional programming' ;)
04:02:06 <shapr> Anyway, next we have the channel topic, which links to the logs of channel history, and might even mention the next stop, the Haskell wiki! w00!
04:02:21 <shapr> @wiki FundamentalConcepts -- the wiki has lots goodies!
04:02:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/FundamentalConcepts -- the wiki has lots goodies!
04:02:49 <shapr> If you'd like to have the Baskin-Robbins one free spoonful of ice cream  style tutorial, check out...
04:02:53 <shapr> @wiki HaskellDemo
04:02:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellDemo
04:03:08 <boegel> does Haskell have a "cond ? case1 | case2" notation ? (without using if .. then .. else )
04:03:10 <shapr> That's the introduction for impatient people, by impatient people.
04:03:15 <beschmi> hi all
04:03:25 <shapr> boegel: case x of 1 -> foo ; 2 -> bar
04:03:57 <boegel> shapr: case isn't meant for that purpose, right ? then I'd better use if..then..else
04:04:21 <shapr> Entro-P: As you can see from the HaskellDemo, Haskell is sigificantly less scary than is assumed by the average slashdotter.
04:04:25 <ibid> boegel: if is defined in terms of case
04:04:30 <shapr> boegel: actually if then else is written via case.
04:04:51 <boegel> oh
04:05:17 * boegel just gained a learning point (current learning points: 19294)
04:05:30 <shapr> Entro-P: after this short introduction, if you'd like to start learning haskell, I can point you to the learning page on haskell.org, useful pages on the wiki, and lots of other stuff.
04:05:41 <shapr> boegel: wow! you're a level five functional programmer!
04:06:17 <boegel> shapr: which level are you ? :)
04:06:27 <shapr> I'm nearly level six!
04:07:04 <shapr> I keep trying to squeeze the last few learning points out of Arrows and Attribute Grammars, but it just hasn't clicked yet.
04:07:35 <shapr> Entro-P: So whaddya think? The first lambda is free!
04:07:38 * shapr tokes on a lambda
04:07:44 <boegel> if you're at level six, then I'm at level -3
04:08:24 <shapr> C'mon, think of how many points a TMR article gives you!
04:08:42 <shapr> beschmi: have you already had the tour?
04:08:54 <boegel> that doesn't say anything about my functional programming skills :)
04:09:20 <beschmi> shapr: yeah
04:09:39 <smott> learning points? what is that?
04:10:04 <dons> boegel: regarding cases, sometimes people use guards: case () of {_ | some test -> x ; | another test -> y; | otherwise -> z }
04:11:03 <boegel> dons: I think if ... then ... else will do for me.. I was just wondering if there was a construction like .. ? .. | .. in C and Java
04:11:16 <shapr> guard and case are nearly the same, you have a bunch of pairs of condition :: (x -> Bool) and body.
04:11:50 <shapr> I think guards and case are implemented differently though. iirc case is easier to optimize.
04:12:15 <nlv11757_> learning points....
04:12:17 <nlv11757_> whats that
04:12:27 <shapr> hej niklas
04:12:31 <shapr> vad h√§nder?
04:12:31 <boegel> nlv11757_: points you gain with learning new stuff
04:12:39 <dons> guards desugar to case. there's only case in the back end. big cases produce C switches
04:12:48 <shapr> oh, ok then.
04:12:58 <shapr> boegel: see, dons is at least level seven.
04:13:14 <nlv11757_> boegel: there exist a system that rewards points and stuff?
04:13:27 <shapr> level seven functional programming, what sort of THAC0 is that?
04:13:27 <boegel> nlv11757_: yes, we just created it :p
04:13:37 <nlv11757_> lol, where
04:13:45 <boegel> in here, you witnessed it
04:13:48 <jlouis> shapr: THAC0 is dead in AD&D Ver 3 AFAIR
04:13:55 <shapr> oh nooo
04:14:05 <nlv11757_> ok im not getting it i guess
04:14:08 <shapr> I used to play D&D, years before AD&D.
04:14:54 <boegel> AD&D ? Analogous Dungeons & Dragons ? :)
04:15:01 <shapr> dons: hey have you heard from Pete lately? His website is down and his email bounces.
04:15:10 <shapr> boegel: Advanced
04:15:12 <boegel> nlv11757_: we're just kidding around
04:15:16 <dons> oh! no, haven't heard anything.
04:15:32 <jlouis> Ok, case 101: Guards desugars to case. if then else desugars to case condition of True -> then_banch False -> else_branch
04:15:47 <shapr> I was gonna ask him about his dataflow language he's writing. Just curious where's got to. And I'd like PLog updates of course :-)
04:16:02 <shapr> and otherwise = desugars to True =
04:16:17 <jlouis> A case is either simple, if it works on Integers or single datatype.
04:16:19 <shapr> Languages with few moving pieces are nice.
04:16:37 <jlouis> Or advanced, if it works on tuples or more advanced datatypes
04:17:05 <jlouis> The advanced types needs pattern matching. This can pattern match compiled into simple case blocks (which the STG-machine in the backend has)
04:17:13 <jlouis> this can be
04:17:23 * boegel feels like he created a storm
04:17:31 * shapr rains on boegel 
04:17:36 * shapr throws lightning bolts
04:17:47 * boegel throws them back
04:17:52 <shapr> ouch!
04:17:59 <shapr> Where's my anti-static wrist band?
04:18:03 <ibid> boegel: there is no ... ? ... | ... in C or Java
04:18:17 <shapr> hiya Ruller
04:18:22 <shapr> Ruller: what does your nickname mean?
04:18:22 <jlouis> The STG-machine then builds switch statements out of this, which is optimized by the C compiler to either if-then-else paths or jump tables, The latter if the switch is big
04:18:31 <ibid> boegel: C's and Java's ... ? ... : ... is called if ... then ... else ... in Haskell
04:18:53 <shapr> jlouis: any ideas what size of if stack is too big?
04:18:57 <boegel> ibid, then what is C's and Java's if...then...else in Haskell? :)
04:19:10 <jlouis> shapr: come again
04:19:15 <ibid> boegel: if ... then ... else ... with monadic type :)
04:19:15 <jlouis> I do not understand that
04:19:24 <shapr> jlouis: what size is big? when do you swich to jump tables?
04:19:42 <ibid> boegel: ie. if ... then do ... else do ...
04:19:43 <ibid> :)
04:19:43 <dons> the Core to Cmm transformation builds switch statements, jlouis, not the STG machine, which is an abstract model of the runtime system.
04:20:17 <shapr> We really need to have scheduled irc talks.
04:20:22 <boegel> ibid: confusing for newbies :)
04:20:24 <shapr> Something like real-time TMR articles.
04:20:45 <ibid> boegel: not really
04:20:58 <jlouis> shapr: it depends. Usually one just tries various breakover points and notes which one produces fast code
04:21:15 <jlouis> Cache plays a big role
04:21:36 <ibid> boegel: the real confusion in that case comes from the fact that java and c have a syntactic separation between statements and expressions, but in haskell the separation is type-based
04:22:56 <boegel> I see
04:23:32 <jlouis> dons: ah, that is right. the STG-machine is abstract and has a simple case expression on either integers or STG-datatypes (which are quite basic). Core->Cmm then transforms to Cmm switch statements. I guess this is 6.4 then
04:24:03 <dons> confusingly, the final Core code is also known as STG code.
04:24:06 <smott> ls
04:24:21 <dons> as it's the language that would be executed by the STG machine
04:24:43 <jlouis> dons: exactly. You could execute that on the Operational semantics of the STG machine
04:24:50 <dons> yep.
04:24:53 <jlouis> (Quite an interesting paper)
04:25:12 <dons> excellent paper. ~80 pages too
04:25:59 <jlouis> exactly
04:26:05 <dons> all the hard magic happens when Core (a functional language) is tranlated to C or Cmm (imperative languages).
04:26:57 <jlouis> What is core? Higher order, polymorpic?
04:27:47 <dons> System F, a polymorphic lambda calc extended with primops, constants, case and let
04:28:03 <dons> System F type system.
04:28:08 <jlouis> ah, yes
04:28:23 <jlouis> This is quite different from MLton.
04:28:27 <dons> case is the only construct for inspecting data, let is the only op for doing allocations
04:28:42 <dons> they don't have a typed intermediate language?
04:28:55 <jlouis> oh, they do. But it is first-order, simply typed
04:29:13 <dons> ah! so they need to do some compilation to get there.
04:29:34 <dons> whereas all Haskell is translated to the kernel, which is just Core basically.
04:29:58 <jlouis> They arrange to it always have the SSA-property.
04:30:02 <jlouis> it to
04:30:03 <jlouis> gr
04:30:59 <jlouis> One pass removes the module language. One pass expands polymorphic uses to monomorphic ones and one pass closure converts, yielding the language on which most of the optimizations are done
04:31:44 <dons> ok.
04:31:44 <jlouis> then a little blob of around 30 SSA-transformations are run and the code is transformed to RSSA (SSA with explicit registers) before the code generator outputs i386 assembly
04:32:09 <dons> so they actually do SSA optimisations on their intermediate language? it's just SSA?
04:33:44 <Igloo> Hey Jaffa - just the person I was looking for  :-)
04:35:18 <JaffaCake> hi Igloo, what have I done now? :)
04:35:42 <Igloo> JaffaCake: Adjustor.c on ia64 uses BYTE_ARR_CTS, which seems to be defined in Cmm.h. However, gcc isn't too happy about me #including that as it redefines things like NULL  :-)   What's the answer here?
04:36:04 <JaffaCake> hang on...
04:36:31 <Igloo> I'm in no rush
04:37:57 <boegel> 10^(-10) doesn't work in Haskell ? is there something similar ?
04:38:15 <Igloo> 10 ** (-10)
04:38:15 <JaffaCake> you could either write (P_)arr + SIZEOF_StgArrWords, or  &(arr->payload)
04:38:46 <JaffaCake> I like the last one, I think
04:38:57 <dons> @plugs 10 ** (-10)
04:38:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1.0e-10
04:39:07 <Igloo> Cool, thanks
04:40:36 <Lunar^> JaffaCake: Have you seen this one ? http://research.sun.com/techrep/2005/abstract-143.html
04:40:44 <boegel> thanks dons
04:41:05 * boegel just gained a learning point (current learning points: 19295)
04:41:55 <shapr> Is it possible to use Template Haskell or something similar to check that sort of breakpoint per-machine?
04:42:01 <JaffaCake> Lunar^: looks interesting, thank for the pointer
04:42:10 <Lunar^> JaffaCake: :)
04:42:31 <Igloo> JaffaCake: Is "`mallocBytesRWX' defined but not used" something I should worry about?
04:42:40 <Lunar^> JaffaCake: I'm dying to see an hardware STG
04:43:01 <shapr> JaffaCake: do you know if Parr will be developed further? I think an SMP GHC via STM with Parr would be excellent for the Cell CPU. Add in some region allocation and you'd likely have tasty, efficient Cell code.
04:43:28 <JaffaCake> Igloo: if the ia64 has a no-execute bit, then you should probably use mallocBytesRWX
04:43:34 <shapr> Lunar^: have you seen the optical graph reduction hardware?
04:43:43 <JaffaCake> Igloo: you'll find out soon enough, anyway :)
04:43:47 <Lunar^> shapr: nope, URL ?
04:44:10 <shapr> umm, I found it on scholar.google.com under combinator, I'll see if I can find it again.
04:44:30 <JaffaCake> shapr: I don't know, you'd have to ask Manuel
04:44:32 <Igloo> OK, as long as it'll break if it's bad that's fine  :-)
04:44:35 <dons> we added mallocBytesRWS to solve non-exec malloc stuff on openbsd. the ia64 adjustor code was in before then, and wasn't updated to use it. it probably doesn't need it.
04:45:02 <dons> i see this comment:  we allocate on the Haskell heap since malloc'd memory
04:45:07 <dons>  isn't executable - argh
04:45:09 <tuomov> http://www.cenqua.com/commentator/
04:45:19 <shapr> tuomov: have you seen their Pairon chair?
04:45:27 <dons> Igloo, so it might work with mallocBytesRWX if you want to try it.
04:45:34 <tuomov> ?
04:45:49 <shapr> tuomov: http://www.cenqua.com/pairon/
04:46:23 <shapr> Those are two of the better urls from the beginning of this month.
04:47:30 <Igloo> dons: I'd just like to get it to work rather than trying to do anything clever  :-)
04:47:46 <dons> hehe, sure.
04:47:50 <shapr> I thought #haskell people are supposed to do clever stuff by reflex?
04:47:57 <JaffaCake> dons: mallocBytesRXW is slow, we should cache a page of executable memory
04:48:15 <shapr> "ricky_clarkson: Is Haskell an interface between programming languages and academics?"
04:48:31 <shapr> unsurprisingly, that's from #java
04:48:48 <dons> JaffaCake: is it slow on non-openbsd machines? it's just stgMallocBytes then.
04:48:59 <dons> or is that still slow. guess so.
04:50:14 <JaffaCake> mprotect is used on linux too, now
04:50:20 <JaffaCake> it was needed for x86_64
04:50:45 <jlouis> ;)
04:51:06 <jlouis> So is the life of a dynamic environment
04:51:12 <dons> ok. and itanium should probably use it too.
04:51:23 <jlouis> itanium is not important ;)
04:51:57 <JaffaCake> I tend to agree
04:52:05 <dons> so Jaffa-"I hope it disappears"-Cake says.
04:52:06 <shapr> The Itanic?
04:52:26 <JaffaCake> if I pretend it doesn't exist long enough, it'll go away
04:52:31 <dons> :)
04:52:47 <shapr> I think that's true with itanium. You could even pretend it does exist, and it'll likely go away.
04:53:04 <JaffaCake> hehe
04:53:31 <shapr> I hope the Cell makes it, I think Haskell/GHC will kick butt on Cell.
04:53:41 <dons> Simon Marlow, Mon Jun 21 08:41:37 EDT 2004, I'm afraid I'm completely IA64-ignorant (and hoping to remain that way
04:53:44 <dons> until IA64 goes away :-)
04:53:50 <dons> hehe
04:53:57 <JaffaCake> at least I'm consistent :)
04:54:11 <dons> lol
04:54:24 <shapr> @remember JaffaCake I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
04:54:44 <JaffaCake> what does that do?
04:54:53 <dons> @quote JaffaCake
04:54:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   I'm afraid I'm completely IA64-ignorant (and hoping to remain that way
04:54:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- until IA64 goes away :-)
04:54:58 <shapr> @quote dons
04:54:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons hasn't said anything memorable
04:55:00 <shapr> !
04:55:01 <dons> @quote ghc
04:55:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Implicit-parameter bindings illegal in a parallel list comprehension
04:55:12 <dons> @quote shapr
04:55:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   I encourage my competitors to use Windows.
04:55:22 <Itkovian> lol
04:55:48 * shapr snickers
04:57:35 <shapr> It's funny, I think I'm such a nice guy, but so many of my quotes are evil.
04:57:56 <Entro-P> heh
04:58:18 <kzm> The road to hell is paved, etc.  Perhaps it's also vice-versa?
04:58:30 <shapr> haha!
04:59:30 <shapr> Hiya Ketil! wassup?
04:59:53 <kzm> I'm bored, of course.  Why else would I be checking out IRC? :-)
05:00:01 <shapr> Hm, I show up here to learn stuff.
05:00:08 <kzm> (Just a break from programming, that's all)
05:00:12 <shapr> JaffaCake: hey, have you seen the perl6 implementation in Haskell?
05:00:27 <kzm> And yes I know - but I don't have any questions right now.
05:00:36 * kzm was only joking.
05:00:38 <JaffaCake> I've been watching autrijus's blog, but haven't delved into the code
05:01:18 <shapr> It's quite nice actually.
05:01:37 <JaffaCake> yes, amazing stuff
05:01:42 <shapr> Surprising that something can have so many committers and still have nice internals.
05:01:48 <Igloo> Oh, that reminds me; there's no (sane) way to munmap something with the portable finalizers is there?
05:02:03 <Igloo> I couldn't see how you would get the finalizer freed after it had run
05:03:02 <JaffaCake> Igloo: not quite following you
05:03:55 <Igloo> OK, darcs currently has code that does this: Foreign.Concurrent.newForeignPtr p (do {c_munmap p l; return (); })
05:04:10 <Igloo> Can this be done with Foreign.ForeignPtr.newForeignPtr instead?
05:04:42 <Igloo> (I can make a FunPtr that I guarantee is attached only to a single mmapped block)
05:04:55 <JaffaCake> should be fine, no?
05:05:10 <Igloo> Won't it leak memory?
05:05:44 <JaffaCake> I assumed there is some other mechanism to manage the address space
05:06:18 <Igloo> Now I don't follow you  :-)
05:06:27 <shapr> hiya mwc
05:06:44 <mwc> shapr, good morning'
05:06:45 <nlv11757_> could it be the case, that the package im using was not installed properly causing the link errors when using -prof?
05:06:57 <JaffaCake> hmm, disregard that - mmap() can grab an unallocated block
05:07:35 * Igloo is confused
05:07:36 <JaffaCake> so I don't see the problem - you're just using mmap()/munmap() instead of malloc()/free()?
05:07:42 <Igloo> It's not the mmap memory I'm worried about
05:07:59 <Igloo> In order to do the munmap I need to have a finalizer that knows the length of the mmaped region
05:08:02 <musasabi> Isn't using mmap quite problematic for haskell (soft threads & blocking behaviour) ?
05:08:19 <Igloo> So I need to make a FunPtr with one of the FFI constructs, passing the length as a parameter
05:08:32 <Igloo> I don't see how I can get that FunPtr freed after the finalizer is run
05:09:05 <shapr> mwc: how's code?
05:09:56 <JaffaCake> Igloo: you want the munmap() to happen *after* the finalizer?  please elaborate a bit
05:10:20 <Igloo> The munmap /is/ the finalizer
05:10:27 <JaffaCake> that's what I thought :-S
05:10:48 <Igloo> Hang on, let me go write the code I'm talking about
05:10:57 <JaffaCake> good idea ;)
05:11:24 * JaffaCake probably needs more coffee
05:11:41 <shapr> If you can't float a horseshoe on it, it's too weak.
05:12:28 <mwc> shapr, confusing I'm afraid, Monads confuse the hell out of me, but haven't gotten to that chapter yet
05:12:28 <JaffaCake> good rule of thumb
05:12:31 <Entro-P> :R
05:12:43 <Entro-P> :O even
05:12:50 <shapr> I've discovered social equality. I feed my guests coffee that's about twice as strong as normal. Then I fit in just fine without Ritalin.
05:12:51 <mwc> My morning brew in highschool used to be jet fuel, triple strong, triple sugar
05:13:03 <Entro-P> shapr: ??? i thought i was the only one using that expresion ;)
05:13:05 <shapr> mwc: whoa, I love it.
05:13:07 <mwc> shapr, ADHD?
05:13:13 <shapr> mwc: what were we saying? =)
05:13:17 * shapr snickers
05:13:27 <mwc> I grew out of my need for stimulants
05:13:37 <mwc> I find exercise does me better than ritalin ever did anyways
05:13:49 <shapr> I do exercise too.
05:13:59 <mwc> Ritalin was only ever good for zombiemode, which I admit given public school was probably the easiest way to get through it
05:14:00 <shapr> I agree, I've found that exercise is necessary for me.
05:14:17 <shapr> Is GHC available over darwin ports?
05:14:19 <Entro-P> me too, i regularly get up walk to the kitchen, and make coffee
05:14:21 <mwc> shapr, I broke my ankle in feb so I've been couchbound
05:14:24 * shapr is proselytizing on #plone
05:14:31 <mwc> shapr, yeah, but the port file is kinda buggered
05:14:44 <mwc> It will only install if you install darwinports to the default prefix
05:14:45 <shapr> Anything I can fix?
05:14:56 <shapr> What's the name of the package?
05:14:59 <mwc> shapr, just the portfile is hardcoded to /opt/local
05:15:05 <mwc> shapr, lang/ghc I believe
05:15:45 <mwc> shapr,
05:15:45 <mwc> ghc             lang/ghc        6.4             The Glorious Glasgow Haskell Compilation System
05:15:45 <mwc> ghc-devel       lang/ghc-devel  6.5             The Glorious Glasgow Haskell Compilation System (development version)
05:15:55 <shapr> ah, thanks.
05:18:16 <kzm> Actually, I do have a question.
05:18:37 <shapr> oh what is it ?
05:18:44 <shapr> Where's the FFI example on the wiki?
05:19:00 <kzm> ISTR on the list, somebody or other was discussing a separate test module (for each regular module)
05:19:12 <mwc> shapr, so anyways, broke my leg, exercise is a nogo, so learning haskell as an intellectual exercise
05:19:22 <kzm> The problem was the need to export more for testing than for regular use.
05:19:24 <mwc> I'm amazed how easily it's writable
05:19:53 <kzm> I wonder if it's a good idea to do it the other way around, and just import the testing module into the module proper.
05:20:17 <shapr> mwc: I can dig it.
05:20:35 <shapr> kzm: good idea.
05:20:39 <kzm> Right now, I have Module and a separate Test.Module storing the bulk of the testing stuff.
05:20:39 <shapr> kzm: you should suggest that.
05:20:54 <shapr> I use Test_Module.hs for my Module.hs files.
05:21:10 <kzm> Well - I still have the problem that the test can't access Module contents...
05:21:36 <Igloo> JaffaCake: OK, http://urchin.earth.li/~ian/munmap.txt
05:21:37 <kzm> I do 'import Test.Module as Test', which I think is a nice way to do it.
05:21:41 <Igloo> foo is what currently happens
05:21:53 <Igloo> bar is how I think it would need to work with Foreign.ForeignPtr
05:22:04 <Igloo> My problem is I don't see how funptr gets freed
05:22:11 <kzm> Anyway, I still need to have testing stuff in the main module, but at least I can move the bulk of it to a separate dir.
05:22:12 <shapr> Does TH handle FFI well enough for autogeneration of wrappers from specifications?
05:23:13 <JaffaCake> Igloo: I see, it's to do with passing parameters to the finalizer
05:23:27 <JaffaCake> you need the finalizer to be a closure, in effect
05:23:44 <mwc> I'm looking under the Haskell reference under Types looking for something like Int -> [Char] or Int -> String trying to figure out how to convert a number to a string, what's the correct way?
05:24:23 <smott> mwc: show
05:24:37 <JaffaCake> Igloo: can't you freeHaskellFunPtr in the finalizer?
05:24:56 <Igloo> But I don't have it at the point I create it
05:25:41 <JaffaCake> use fixIO?
05:25:49 <Igloo> Is there no possibility of a race condition?
05:26:16 <JaffaCake> don't think so, it's fine to free a FunPtr from inside the function itself
05:27:03 <JaffaCake> BTW, you're better off just using the Foreign.Concurrent version anyway
05:27:16 <Igloo> hugs doesn't have it
05:27:29 * Igloo assumes nhc98 doens't either, but hasn't looked yet
05:27:31 <JaffaCake> using foreign import "wrapper" with portable finalizers is explicitly defined as not portable
05:27:42 <JaffaCake> see the FFI spec
05:27:43 <Igloo> Oh
05:28:53 <Igloo> So there's no portable way to do this then?
05:29:18 <JaffaCake> there's newForeignPtrEnv
05:29:42 <JaffaCake> but for some unknown reason it doens't seem to be supported by GHC
05:31:41 <Igloo> Ah, and hence not in the haddock docs; that'll be why I missed it
05:33:09 <Igloo> So I guess that is something that can be fixed when ghc 6.4.1 comes out then  :-)
05:33:51 <JaffaCake> well, that would constitute a library API change...
05:34:54 <Igloo> Hmm, I guess fixing it would break some cpp fixes for it being missing  :-/
05:35:44 <mwc> if I have a do construct that takes a list, how should I end it with the empty list? I have printNums (n:ns) = do ...
05:35:57 <mwc> how should I match printNums [] ?
05:36:12 <ibid> mwc: in the usual way
05:36:26 <mwc> ibid, an empty do construct chokes ghc
05:36:43 <ibid> mwc: ah, that's not an issue of matching :)
05:36:54 <mwc> well, what should I do to end the recursion?
05:36:58 <ibid> mwc: that's an issue of what you want it to do once matched
05:37:06 <mwc> nothing, ideally
05:37:17 <ibid> mwc: what type is printNums?
05:37:39 <mwc> [Int] -> _|_
05:37:49 <mwc> where _|_ is absolutely notthing
05:38:01 <mwc> it's a procedure, doesn't return a value
05:38:07 <mwc> which might be a mistake in itself
05:38:17 <ibid> _|_ is not a haskell type
05:38:21 <ibid> do you mean IO ()
05:38:21 <ibid> ?
05:38:28 <ibid> if so, then return () is appropriate
05:38:32 <mwc> ibid, I mean, NULL or someting
05:38:37 <mwc> ibid, ah.
05:38:49 <ibid> NULL is neither a haskell type :)
05:38:56 <mwc> yeah, I know
05:39:04 <mwc> What do you call "this is not a value at all"
05:39:11 <ibid> mwc: there is no such thing
05:39:19 <mwc> ah, so that's the mistake
05:39:19 <ibid> mwc: everything is a value in haskell
05:39:28 <shapr> Haskell has values!
05:39:34 <ibid> mwc: () is the trivial type, containing the trivial value ()
05:39:40 <mwc> ah
05:39:42 <shapr> Unlike those amoral other languages!
05:39:47 <brainZzZ> weigh 5 coins against 5 coins (if they match, you are lucky this is the trivial solution). if they dont match, replace one coin in each tray with the two you didnt weigh. if they match this time you weigh the two replacements with the two substitues (since you know they are legit). if they do not match again, then i cant do this in 3.
05:39:58 <shapr> brainZzZ: homework?
05:40:02 <ibid> mwc: similar to C's void type, except that there is one value and not zero values
05:40:06 <brainZzZ> homework help?
05:40:10 <mwc> ibid, works for me
05:40:24 <shapr> We help with Haskell, but we won't do your homework for you. That would be unethical.
05:40:38 <mwc> printFacts [] = () ?
05:41:06 <mwc> does the fact that printFacts (n:ns) is a do construction change how that would have to be defined?
05:41:38 <ibid> mwc: if printFacts return type is (), then that's correct
05:41:55 <ibid> mwc: i'm guessing that the return type is not in fact plain ()
05:42:02 <mwc> Well, it should be
05:42:05 <ibid> mwc: i'm guessing that your function has side-effects
05:42:15 <ibid> mwc: in which case, it should be an IO type
05:42:16 <mwc> ibid, yeah, it's a printFunction
05:42:20 <ibid> mwc: as i said, IO ()
05:42:25 <mwc> IO ()?
05:42:27 <mwc> ah
05:42:39 <ibid> mwc: in which case the appropriate "do nothing" thing is return ()
05:42:49 <mwc> do return () ?
05:43:07 <ibid> yes, but you don't need the do if you have only one "statement"
05:44:22 <mwc> Okay, now it's complaining that the expected type is () but the inferred type is IO ()
05:44:31 <ibid> what did you write?
05:44:39 <mwc> printFacts [] = do return ()
05:44:39 <mwc> printFacts (n:ns) = do
05:44:39 <mwc> 	let outStr = "The factorial of " ++ (show n) ++ " is " ++ (show (fact n))
05:44:39 <mwc> 	putStrLn outStr
05:44:39 <mwc> 	return (printFacts ns)
05:45:13 <ibid> heh
05:45:18 <ibid> lose the return from the last line
05:45:43 <mwc> I thought that was needed for a do block
05:45:49 <shapr> Lunar^: would StringIO solve the template haskell in hOp problem?
05:45:52 <mwc> Guess that's a problem with how I read the YAHT
05:46:04 <ibid> your mental model is flawed, which is not surprising :)
05:46:30 <ibid> the monadic mental model is a little strange at first
05:46:47 <mwc> I think it's more a problem with it being presented in full way late
05:47:02 <mwc> but just kinda "introduced" fairly early
05:47:04 <ibid> mwc: the important thing to realize is that there are two kinds of values: side-effectful values and side-effect-free values
05:47:26 <ibid> mwc: side-effectful values have type IO something
05:47:53 <ibid> mwc: and what return does is turn a side-effect-free value into a side-effectful value
05:48:01 <mwc> Ah
05:48:05 <mwc> That makes a lot of sense now
05:48:06 <ibid> (whose side-effect is "do nothing")
05:48:27 <ibid> mwc: your mistake was to try to convert a side-effectful value into a doubly-side-effectful value
05:49:09 <mwc> yeah, I'm a little irked by these tutorials, but YAHT is the best i've found so far
05:49:48 <ibid> mwc: another thing: the only things you can do with side-effectful values are moving them around and using them in a do construct, either as a line themselves or in a line x <- sideEffectfulValue
05:50:11 <ibid> (i'm simplifying of course, in fact there are other things you can do with them but that's advanced stuff:)
05:50:22 <mwc> ibid, heh, it covers Monad in the second last tutorial
05:50:29 <mwc> which is why I'm griping about this tutorial
05:51:19 <ibid> mwc: the effect of x <- sideEffectfulValue is to turn the sideEffectfulValue into a side-effect-less value, which you can then access as the variable x
05:51:32 <ibid> mwc: well, it is correct in treating full monads late
05:51:52 <ibid> mwc: the full stuff requires one to already have adjusted to the proper mode of thinking
05:52:06 <ibid> (functional mode, that is)
05:52:29 <mwc> yeah, it's just hard to do the exercises earlier
05:53:32 <ibid> mwc: the problem is probably that we're (the haskell community, that is) still trying to figure out how to do a baby-size monads tutorial, enough to write simple programs without confusing the beginner unduly
05:55:10 * ibid will probably be teaching haskell again next academic year
05:55:23 <ibid> so i'll have to start thinking about that again :)
05:55:35 * shapr thinks about teaching Haskell to a bunch of first year students.
05:55:36 * shapr faints
05:56:30 <ibid> these will probably be third-year students
05:56:54 <ibid> i think it'd be easier to teach first-years, actually
05:56:59 <ibid> they have a lot less baggage
05:57:13 <Matt-W> I did haskell as a first-year student
05:57:24 <Matt-W> I wouldn't have wanted to teach my lot
05:57:26 <mwc> I think it's pretty easy to pick up functional programming, at least as an applied math major
05:57:32 * ibid was the first to teach haskell here :)
05:58:06 <mwc> Just use a Lambda calc mental model instead of a turing machine (or Van Nuemann if you must)
05:58:34 <mwc> Which is probably beyond most first years anyways
05:59:09 <mwc> I tried reading a gentle introduction to Haskell and found it was worthless, I like the Hal Daume tutorial better because it actually presents code for you to write and understand. The Gentle Introduction didn't
05:59:55 <mwc> If I was going to write a tutorial I'd build a complete app in Haskell
06:00:28 * ibid learnt haskell from the gentle intro
06:00:34 <mwc> I'm impressed
06:00:36 * tuomov too
06:00:42 <mwc> I found it was a lot of talk with no real application
06:00:43 <kzm> mwc, I liked the Gentle Introduction, but I'd just read SICP
06:01:14 <kzm> so it served to map Haskell idioms to functional programming, instead of Scheme's.
06:01:21 <mwc> SICP?
06:01:25 <mwc> Oh, Structure and Interpretation
06:01:29 <kzm> right.
06:01:34 <kzm> (beat me to it)
06:02:27 <kzm> As for teaching, well - here we use Java, and I'm not convinced it's any easier than Haskell.
06:02:45 <mwc> I started learning Scheme and didn't much care for it's lack of typing to I tried Ocaml, didn't find it that special, and now am learning Haskell
06:03:47 <mwc> I think the problem with Java is that forces you to start OO'ing right away
06:04:09 <mwc> hello world you have to hand wave around public class HelloWorld extends etc
06:04:25 <mwc> so starting out there's a lot of handwaving
06:04:36 <brainZzZ> with a lot of protective gear...
06:04:47 <ibid> no need for extends in a helloworld
06:05:13 <mwc> kzm, the purely functional aspect of haskell is exceedingly simple to understand
06:05:27 <mwc> it's just this monad stuff that's dropped strip tease that throws me
06:14:47 <shapr> _JusSx_: hiya, have you tried lambdabot?
06:15:10 <mwc> lambdabot, hello
06:15:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
06:15:19 <mwc> lambdabot, @listcommands
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I react to the following commands: ["all-dicts","arr","babel","define","
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- definitions","del-definition","devils","dict","dict-help","dummy","dump"
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements"
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","help"
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"hitchcock","jargon","join","karma","karma+","karma-","kind","learn","leave"
06:15:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"listchans","listcommands","listmodules","lojban","moo","more","msg","part"
06:15:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"paste","pl-resume","plugs","pointless","prelude","quit","quote","reconnect"
06:15:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3 @more lines]
06:16:17 <musasabi> Is there a way to make notices nicer in irssi?
06:16:39 <TheHunter> @wiki LambdaBot/Notices
06:16:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
06:19:57 <musasabi> thanks :-)
06:20:32 <vegai> lambdabot: @eval last [1..]
06:20:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (line 1, column 9):
06:20:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unexpected "."
06:20:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- expecting simple term
06:20:51 <vegai> hmm, it didn't change at all
06:20:59 <tuomov> @arr
06:21:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I'll keel haul ya fer that!
06:21:04 <tuomov> yeah, it didn't
06:24:02 <tuomov_> @arr
06:24:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Yeh scurvy dog...
06:24:19 <tuomov> yeah, restart seems necessary
06:24:27 <Itkovian> anybody participating: http://www.linuxonpower.com/challenges.php?tier=2&PHPSESSID=13458d2cdea06ff803d6c03e1078ce69
06:24:28 <Itkovian> ?
06:25:08 <Igloo> Hmm, irssi doesn't seem to have theme documentation yet
06:25:18 <Entro-P> are there any html haskell tutorials besides the so called 'gentle' one ?
06:25:47 <shapr> Entro-P: yeah, there's YAHT
06:25:57 <tuomov> @arr
06:25:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Avast!
06:26:00 <CosmicRay> morning tuomov
06:26:26 <Entro-P> in html ?
06:26:34 <shapr> Um, I don't think so.
06:26:49 <CosmicRay> morning shapr
06:26:53 <Entro-P> :P thats what i asked ;)
06:27:00 <brainZzZ> that's not what i asked
06:27:04 <shapr> oh right.
06:27:10 <shapr> brainZzZ: what did you ask?
06:27:17 <brainZzZ> why did you ask?
06:27:45 <shapr> because you implied that you had asked something other than what Entro-P asked, and I like to be helpful, so...
06:28:27 <jlouis> @yow
06:28:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't find fortune file
06:28:33 * shapr sniffles
06:28:36 <shapr> should I check it in?
06:28:38 <jlouis> Bleh, dons should update it
06:28:53 <jlouis> shapr: no, the YowModule is gone. It uses fortune strfile format now
06:29:21 <jlouis> So you could s/\00/%\n/ the file and check it in, but OpenBSD actually has a zippy section in the fortunes
06:29:40 <shapr> Yeah, but the *real* zippy quotes are in emacs!
06:29:41 <jlouis> Why have 2 formats when one can do?
06:29:43 <shapr> Ok, not really.
06:29:57 <jlouis> shapr: yeah, hehe
06:29:58 <shapr> Well, mostly because I like M-x yow
06:30:14 <jlouis> We have a problem with @fortune though
06:30:21 <shapr> what?
06:30:38 <jlouis> We do not select fortunes with equal probability
06:30:41 <shapr> oh
06:30:47 <shapr> so?
06:31:00 <Si\> How do I write a type signature for a list of pairs, where the first pair is of type [Int] and the second is defined by a type-parameter, the overall type should have kind * -> *?
06:31:03 <jlouis> imagine 2 fortune sections, 1 with 1 fortune and one with 100.
06:31:29 <shapr> Sure, I understand. I remember the code. But I figured it was good enough for irc quotes.
06:31:31 <jlouis> Since you select a section with 50% probability, there is 50% probability that that the single fortune comes up
06:31:51 <jlouis> It probably is
06:31:55 <shapr> In the interests of correctness (and seeing what solution you propose) I think we should change it!
06:32:19 <Si\> I've tried ([] ((,) [Int])) but I get "(,) is not supplied enough arguments"
06:32:31 <shapr> Si\: well, what kind is foo :: (a,b) -> (b,c)  ?
06:33:07 <shapr> Wait, it's just a list of pairs, right? Isn't that kind * ?
06:33:10 <shapr> @kind 1
06:33:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1 :: *
06:33:19 <Si\> no, it isn't a pair of lists
06:33:21 <brainZzZ> shapr: that kind of ****
06:33:28 <Si\> sorry I'm getting confused
06:33:29 <shapr> brainZzZ: oh you're learning arrows?
06:33:37 <brainZzZ> its cool and fun, lets not pretend you're learning it for practical reasons
06:33:40 <jlouis> Read in the total number of fortunes, N, calculate probabilities, select fortune-section based on non-uniform probabilities
06:33:49 <shapr> brainZzZ: what are you talking about?
06:34:05 <shapr> brainZzZ: I learned Haskell for totally practical reasons.
06:34:11 <Si\> I'll explain, if I want a Map of kind * -> *, I simply write Map [Int]
06:34:16 <brainZzZ> what are you talking about verushka?
06:34:22 <shapr> Who's verushka?
06:34:25 <brainZzZ> i told her i learned it from the internet
06:34:38 <shapr> brainZzZ: whatever drugs you're on, I wish you'd share.
06:34:47 <jlouis> mmmmm, mushrooms!
06:34:51 <shapr> Work is hard, let's go shopping.
06:34:52 <brainZzZ> i wish i could do that
06:34:57 <Si\> but if I want a map built as a list of pairs, how would I type that with kind * -> *?
06:35:14 <autrijus> what's wrong with  [([Int], a)]  again?
06:35:23 <Si\> it has kind *
06:35:45 <shapr> brainZzZ: Are you part of the methylphenidate crowd?
06:35:56 <brainZzZ> remember to leave out that removing the missles from turkey part of the story
06:36:11 <Si\> I want that, but with kind *, so I can supply it a type signature to give the element type
06:36:33 <autrijus> I see.
06:36:48 <jlouis> kind * -> * you mean, right?
06:37:10 <Si\> obviously I could create a type with type List a = [([Int], a)] which would have the correct king
06:37:15 <Si\> \s\king\kind
06:37:41 <jlouis> Ah, when you spell really bad, you are not typo kinf, but type kind
06:37:58 <Si\> but, I can't use that in an instance head
06:38:13 <jlouis> Si\: what are you trying to do?
06:39:14 <TheHunter> Si\, you'll have to use a newtype.
06:39:24 <Si\> right, if I have a class, which takes a variable of kind * -> *, how do I use a type there which a list of pairs where the type parameter supplies the type of the second element of the pair
06:40:42 <Si\> there must be a way of doing this, it's only syntactic
06:41:00 <jlouis> points free type annotations? Just because one can?
06:41:03 <kosmikus> Si\: you can only do this using newtype, as TheHunter said
06:41:07 <TheHunter> There's a good reason that's impossible.
06:41:35 <shapr> brainZzZ: are you a bot?
06:41:43 <brainZzZ> are you a bot?
06:42:12 --- mode: ChanServ set +o shapr
06:42:17 --- kick: brainZzZ was kicked by shapr (Kicked by shapr)
06:42:27 <shapr> ah, I think he is a bot.
06:42:29 <shapr> ok then.
06:42:44 --- mode: shapr set -o shapr
06:43:23 <TheHunter> http://www.haskell.org/pipermail/haskell-cafe/2005-March/009486.html
06:43:24 <Si\> So what's the good reason that it's impossible?
06:45:59 <Si\> yeah I understand why you can't do it for type synonyms, but why can't you write it point free?
06:47:15 <autrijus> because the type calculus is not real lambda calculus?
06:47:32 <TheHunter> well, you can define stuff like newtype Flip f a b = Flip { runFlip :: f b a }.
06:48:27 <shapr> That's mind-twisting
06:48:55 <Si\> oh well, I'll just have to assume people won't be using [(i, e)] maps, they shouldn't really anyway
06:49:28 <TheHunter> the alternative would be to just use multi-parameter type classes
06:50:56 * kosmikus just decided that Friday, April 29 will be the deadline for the May 2005 edition of the HC&A Report
06:51:42 <kosmikus> I'll send a mail to the mailing lists shortly, but you already start writing ;)
06:52:13 * shapr has to do $work, <sigh>
06:53:21 <CosmicRay> kosmikus: it is published every month?
06:53:27 <CosmicRay> I thought it was once a year
06:53:32 <Igloo> 6 months
06:55:09 <kosmikus> yes
07:34:22 <TNKS> hey guys, what the function to grab the fractional part of a Double?
07:35:12 <autrijus> @type properFraction
07:35:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- properFraction :: forall a b.
07:35:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                   (RealFrac a, Integral b) =>
07:35:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                   a -> (b, a)
07:36:46 <TNKS> sorry, I misstated, I think.  I looking for a function that returns 0.14 for an input of 3.14.
07:37:45 <TheHunter> @type snd . properFraction
07:37:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- snd . properFraction :: forall a. (RealFrac a) => a -> a
07:38:31 <TNKS> sorry, I misinterpreted.
07:39:27 <TNKS> I thought properFraction approximated a Float to some fraction with an integer denom and numerator.
07:39:30 <TNKS> I get it now.
07:39:31 <TNKS>  thanks.
07:51:00 <Oejet> Good afternoon.
07:51:06 <Lemmih> @plugs (snd.properFraction) 3.14
07:51:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 0.14000000000000012
07:51:31 <wilx> Is there a symbolic pi?
07:51:32 <boegel> Lemmih: wtf ?
07:51:36 <wilx> @eval pi
07:51:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- unbound variable: pi
07:51:41 <wilx> @eval Math.pi
07:51:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- <<EM Dynamic -> EM Dynamic>>
07:51:43 <Lemmih> @plugs pi
07:51:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3.141592653589793
07:51:57 <wilx> Huhuhu.
07:52:02 <wilx> What's EM Dynamic?
07:52:04 <Lemmih> boegel: Pretty close, eh (:
07:52:21 <boegel> Lemmih: how come ?
07:52:38 <chip> Is it possible to explain briefly the unique characteristics / fundamental nature of Monads?  "Gentle Introduction" pretty much punted
07:53:01 <Oejet> chip: No, it's not. :-P
07:53:02 <chip> (oh, and good morning, gentle lambdans)
07:53:11 <CosmicRay> chip: http://www.nomaware.com/monads/html/
07:53:21 <CosmicRay> chip: http://www.engr.mun.ca/%7Etheo/Misc/haskell_and_monads.htm
07:53:30 <CosmicRay> chip: http://www.cs.pdx.edu/%7Eantoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
07:53:33 <CosmicRay> try those
07:53:37 <chip> OK
07:53:38 <wilx> boegel, some numbers cannot be expressed as finite sum of 1/2^n parts.
07:53:47 <TheHunter> @plugs 1.1 + (-13.1) + 13.2 == 1.1 + ((-13.1) + 13.2)
07:53:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- False
07:53:55 <CosmicRay> chip: the first will probably be most useful to you
07:54:50 <boegel> wilx: are you sure ? I thought that was always possible
07:55:02 <boegel> as with binary numbers
07:55:13 <wilx> Well...n < |mantisa| :)
07:55:46 <chip> CosmicRay: tx
07:55:56 <wilx> So make that sum of 1/2^n where n = 1..|mantisa| :)
07:55:58 <wilx> I guess.
07:55:59 * boegel remembers some classes on floating numbers
07:56:53 * boegel fails to remember, and lose a learning point (current total: 19294)
07:56:58 <boegel> s/lose/loses
07:56:59 <basti_> in fact, very many numbers can not be expressed as a sum of 1/2^n's
07:57:11 <boegel> basti_: ?
07:57:19 <basti_> even some rather unsuspicious numbers can't.
07:57:28 <basti_> well first there are many transcendental numbers.
07:57:29 <basti_> ;)
07:57:31 <wilx> Yeah, I wasn't sure. My math is bad.
07:57:37 <basti_> like, pi, and e, and the like.
07:57:44 <basti_> theres lots more of these than normal numbers.
07:57:52 <basti_> but this (rather stupid) example aside...
07:57:53 <boegel> there are ?
07:58:08 <basti_> you can't even say 0.2 in binary.
07:58:13 <basti_> its periodic
07:58:16 * boegel gains a learning point
07:58:52 <Itkovian> boegel, you had that course _3_ years ago.
07:58:54 <Oejet> boegel: You have broken even now. :-)
07:59:01 <Itkovian> yuou clearly didn't pay attention ;-)
07:59:17 <boegel> Itkovian: I had, but we had so many stuff to remember
07:59:19 <basti_> (i think, while it is true that there are more transcendental numbers than rationals, or irrationals, while true, is a rather stupid statement)
07:59:21 <Itkovian> it's called Numerical Algebra, chapter 1
07:59:38 <boegel> we we're taught how to write 0.2 in binary numbers, and now I hear it's not possible
07:59:43 <Itkovian> cmon it's one of the more important concepts to remember
07:59:54 <basti_> i mean it IS possible but not with a finite number of places
07:59:56 <Itkovian> heh, it is possible, only not _exact_
08:00:02 <basti_> its periodic
08:00:08 <boegel> Itkovian: it isn't when you don't use it
08:00:25 <basti_> a few people were killed because of that fact.
08:00:34 <Itkovian> anyway ...
08:00:39 <Itkovian> gotta go
08:01:11 * boegel realises now he was confusing 0.5 with 0.2 (with the binary numbers and all :s)
08:01:32 * boegel loses 10 learning points because of his huge mistake
08:01:38 <basti_> there was an US-american "patriot" "defensive missile" system in iraq that failed to fire because 0.2 is periodic in binary
08:01:51 <boegel> omg :)
08:02:08 <basti_> it was "never intended" to run longer than a few hours...
08:02:13 <boegel> heh
08:02:18 <basti_> this one system was running 5 days
08:03:07 <basti_> and over the 5 days the differencies in some timer calculation, which had a period of 1/5 of another timer, had accumulated to a point where the system would seek to fire a few km in front of the attacker
08:03:29 <basti_> of course it didnt see anything there so it didnt fire
08:04:25 <basti_> i mean not that i support wars or weapons...
08:04:44 <boegel> funny stuff :)
08:04:46 <basti_> but this is certainly a thing that shouldnt happen
08:13:49 <lightstep> is there any "original paper" on the damas-milner type system (that i can quote)?
08:14:04 <ibid> there are several
08:14:24 <ibid> there is hindley's original, then milner's, and finally damas and milner's
08:14:52 <lightstep> i couldn't find any old paper on citeseer, and milner's homepage doesn't give any link
08:14:57 <dustin`> ibid:  Which one is canonical?  I'm interested in reading up on that myself.
08:15:18 <ibid> dustin`: all of them
08:15:31 <ibid> dustin`: well, hindley's is of lesser importance
08:15:33 <dustin`> ibid: I suspected this answer.
08:15:54 <ibid> i think the usual cite is the milner paper for hm
08:16:11 <ibid> and damas & milner if you are talking about the specific algorihm
08:16:30 <ibid> lightstep: they are not online
08:16:56 <lightstep> are they copyrighted? available in some old journal collection?
08:17:09 <ibid> all papers are copyrighted
08:17:28 <lightstep> i meant, the opposite of copylefted
08:17:30 <ibid> except some very old papers, but that does not concern computing much :)
08:17:45 <ibid> lightstep: i know of no scholarly papers that have been copylefted
08:18:13 <lightstep> yes, but some are available for free
08:18:14 <ibid> lightstep: anyway, i've seen the milner paper on dead-tree form in the local library
08:18:21 <ibid> lightstep: yes, but that's not copylefting :)
08:18:30 <ibid> (necessarily)
08:18:37 <lightstep> but also not the opposite of it
08:19:17 <ibid> depends on how you define opposite
08:19:26 <ibid> anyway, the milner paper was published in Journal of Computer and System Sciences in 1978
08:19:38 <lightstep> thanks
08:20:02 <ibid> http://portal.acm.org/citation.cfm?id=582153.582176 <- this is a conference paper that probably is the damas-milner reference
08:20:25 <ibid> R. Milner, A theory of type polymorphism in programming (1978), JCSS 17,3, pp 348--375.
08:20:34 <ibid> R. Hindley, The principal type-scheme of an object in Combinatory Logic, (1969), Trans AMS 146, pp 29--60.
08:21:19 <ibid> according to the acm bibliography
08:39:49 <TheHunter> @quote ghc
08:39:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Unexpected strictness annotation
08:40:29 <basti_> haskell's type system rules the world.
08:40:39 <TheHunter> basti_, wanna play a game?
08:40:47 <basti_> sure
08:41:12 <TheHunter> we @quote ghc, and whoever finds some code that produces this error first, wins.
08:41:29 <basti_> hmm?
08:41:31 <basti_> make an example
08:41:55 * Igloo precomputes a table of solutions  :-)
08:42:01 <autrijus> the "my brian exploded" is interesting too
08:42:05 <autrijus> s/brian/brain/
08:42:13 <xerox> Poor brian :\
08:42:20 <TheHunter> ghc says: Couldn't match `(a, b)' against `[Char]'
08:42:34 <TheHunter> so you have to come up with: fst "a"
08:42:50 <basti_> phew.
08:42:56 <xerox> Maybe @plugs it? :-)
08:43:02 <basti_> uhm.
08:43:06 <basti_> so, what is the point of this game?
08:43:08 <basti_> teaching me haskell?
08:43:17 <TheHunter> doesn't work for all errors, but yes.
08:43:18 <nlv11757_> guessing a program that generates that error
08:43:28 <TheHunter> allright, let's start
08:43:31 <basti_> hummm.
08:43:35 * basti_ ponders
08:43:41 <TheHunter> @quote ghc
08:43:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Illegal binding of built-in syntax
08:43:57 <basti_> uhm? why is it another error now?
08:44:03 <basti_> i dont think i understand.
08:44:21 <xerox> @quote shapr
08:44:22 <psi> random quotes from ghc :)
08:44:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   I encourage my competitors to use Windows.
08:44:41 <jlouis> @quote jlouis
08:44:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Q: When does one know he has programmed too much Haskell? A: When he uses
08:44:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- == and /= in everyday IRC chat or when he tries to fix a relationship by
08:44:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- passing himself as a continuation
08:44:46 <basti_> ahhh
08:44:53 <basti_> i think i understand.
08:45:32 <nlv11757_> what kind of bs is this: " No rule to make target `mpeg2enc.c', needed by `mpeg2enc.o'" he doesn't have to make mpeg2enc.c :S
08:45:50 <TheHunter> "Illegal binding of built-in syntax" <-- never seen this before...
08:45:53 <jlouis> nlv11757_: each file is a target in make(1)
08:46:28 <sylvan> me neither.. strange error =)
08:47:37 <kosmikus> probably something that occurs with -fno-implicit-prelude only
08:48:10 <TheHunter> probably... ok, next one.
08:48:13 <TheHunter> @quote ghc
08:48:13 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   GHC internal error
08:48:20 <jlouis> LOL!
08:48:29 <jlouis> now you have to find a bug in GHC
08:49:50 <nlv11757_> jlouis: im kinda surprised that it wants to built that c file...its there already
08:50:16 <basti_> sorry gf intervention
08:50:28 <basti_> bug in ghc yes? -.-
08:51:13 <TheHunter> i don't have one right now :)
08:53:23 <TheHunter> well, next one...
08:53:25 <TheHunter> @quote ghc
08:53:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Unexpected strictness annotation
08:54:28 <TheHunter> @plugs (id :: forall a. !a -> a)
08:54:33 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `.'
08:55:04 <TheHunter> @plugs id :: !a -> a
08:55:05 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `!'
08:55:23 <TheHunter> ok, needs -fglasgow-exts.
08:55:30 <TheHunter> @quote ghc
08:55:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Info table already?
08:55:33 <basti_> awww.
08:55:36 <basti_> -thinks-
08:55:39 <basti_> my
08:55:41 * Igloo doubts that's the right way to get that error
08:55:42 <basti_> this is HARD
08:56:14 <TheHunter> Igloo, what's the right way?
08:56:22 <jlouis> Even with the Haskell sources by your side, this is hard ;)
08:56:46 <Igloo> Not sure; core is more likely IMO
08:57:07 <TheHunter> is that in the evil mangler?
08:57:28 <Igloo> Oh, google hasn't heard of it
08:58:40 <TheHunter> @quote ghc
08:58:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   There must be at least one non-type-variable in the instance head
08:59:18 <TheHunter> easy, instance Show a => Eq a
09:00:02 * basti_ head explodes
09:00:14 <musasabi> :-)
09:00:18 <musasabi> that is quite evil.
09:01:39 <jlouis> @quote ghc
09:01:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Can't splice the polymorphic local variable
09:20:21 <basti_> mmmh how would i catch "mouse drag" events with Graphics.UI.GLUT?
09:20:42 <basti_> KeyboardMouseCallback seems to only deliver clicks...
09:21:07 * TheHunter gives up.
09:21:19 <basti_> can't splice it?
09:21:35 <TheHunter> yep
09:21:38 <basti_> :P
09:22:24 <TheHunter> @quote ghc
09:22:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   even with cunning newtype deriving the newtype is recursive
09:22:35 <TheHunter> that's a nice one.
09:23:33 <basti_> lol
09:23:45 <basti_> out of context they make quite an impression
09:23:55 <basti_> sounds like an eternal truth...
09:24:12 <basti_> some tao verse or something
09:24:14 <TheHunter> newtype Foo a = Foo (Cont (Foo a) a) deriving Monad
09:24:58 <basti_> "Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain."
09:25:39 <TheHunter> hehe
09:31:57 <xerox> Ahah.
09:32:09 <xerox> @remember <basti_> "Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain."
09:32:15 <xerox> ;)
09:35:05 <sorje> hi
09:35:26 <Lemmih> SyntaxNinja: Hey.
09:39:29 <SyntaxNinja> heya Lemmih
09:59:32 <basti_> hmm
09:59:36 <basti_>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
09:59:39 <basti_> o0
10:03:55 <xerox> You find it before TheHunter !!!
10:03:59 * xerox proclaims basti_ the winner
10:04:24 <basti_> lol
10:04:26 <basti_> -g-
10:04:43 <basti_> no but, uhm, in what depth are my elaborations expected to be?
10:17:08 <sorje> None at all ;-)
10:23:40 <metaperl_> when a lazy value or a list has not been created by the computer, it is, in my terminology, abstract... once the value is created, I consider it reified... is there two better terms for these two modes in which data exists?
10:24:32 <TFK> "Binding and evaluating values", if I understood Gentle properly.
10:32:45 <Lemmih> @pointless \x -> g =<< f x
10:32:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (g =<<) . f
10:33:20 <Lemmih> Neat.
11:09:43 <xerox> @pointless \f xs -> xs >>= return . f
11:09:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- fmap
11:10:13 <Philippa_> *claps*
11:11:03 * xerox bounces happily
11:21:34 <desrt> 24317 desrt     25   0  650m 643m  764 R 99.9 63.6  42:12.71 yi_
11:21:35 <desrt> hmm
11:24:40 <Cale> yi spinning?
11:26:18 <jlouis> desrt: hehe
11:26:58 <desrt> yi_ spinning
11:27:37 <desrt> i have discovered the true nature of bragging about uptime
11:27:56 <desrt> typing uptime every now and then forces you to see your load averages so you know if anything has gone amiss
11:28:30 <jlouis> desrt: xload &
11:28:49 <desrt> if i was going to do something like this, i'd find a well-behaved panel applet
11:29:11 <jlouis> desrt: yeah, that is a good option
11:29:20 <desrt> cool
11:29:27 <desrt> the gnome cpu monitor applet is a history graph
11:29:30 <desrt> but you can make it quite thin
11:29:37 <desrt> so now it only uses up like 10 pixels of panel space
11:29:40 <desrt> i can deal with that
11:40:59 <mugwump> I've got a haskell question
11:41:11 <xkb> cool
11:41:21 <xkb> You've come to the right place then
11:42:15 <mugwump> Why is it, while I'm going through the tutorials, every thing I learn seems to correspond to many times repeating doing that same thing in another language thinking, "there must be a better way"?
11:42:46 <xkb> could you give an example?
11:43:28 <mugwump> divMod, for instance
11:43:41 <TFK> He's either saying that Haskell has solved all his problems, or that Haskell has stolen the worst mis-features from other languages.
11:44:04 <TFK> I suspect the former, but not sure :-)
11:44:37 <mugwump> Like, every time I write some code that splits up a number using divide, I'm thinking boy, I hope the optimiser's smart enough to spot I'm dividing the same thing twice and only actually issuing one divide
11:45:05 <xkb> So you place the divide into a function
11:45:07 <Lemmih> Wheee. I'm playing with RemiTurk (:
11:45:08 <xkb> and call that
11:46:53 <mugwump> But then I see functions like divMod as a core function, and I'm like, yeah, that's the way to do it
11:47:14 <mugwump> s/core/member of Int/
11:47:39 <zamez> is performance av
11:47:43 <xkb> aha! So you do think Haskell solved all of your problems
11:47:45 <zamez> -av
11:47:49 <zamez> actually a problem?
11:47:59 <zamez> or does it just feel bad to divide twice? ;)
11:48:09 <TFK> Python has divmod() btw o.o
11:48:20 <mugwump> it feels bad to write it twice.  the performance is only a minor discomfort
11:48:27 <zamez> :>
11:48:27 <TFK> 5$ saying Ruby has one too :-)
11:48:36 <mugwump> I mean, it's not like you *can't* do this in an imperative language
11:49:08 <TFK> Python is imperative.
11:49:36 <xkb> hence the not :d
11:50:31 <xkb> mugwump: so you like the elegance of Haskell?
11:50:36 <TFK> Heh, fair enough :-)
11:50:37 <zamez> vector<int>::iterator new_end = remove_if(V.begin(), V.end(), compose1(bind2nd(equal_to<int>(), 0), bind2nd(modulus<int>(), 2))); V.erase(new_end, V.end());
11:50:58 <TFK> What is that (C++?) horror?
11:51:00 <zamez> when I see that, I really like Haskell :>
11:51:07 <xkb> haha
11:51:09 <TFK> :D
11:51:25 <mugwump> look, I'm still learning.  All I can say is before abstracting things too far with functions was like, oh no there's another stack frame that's going to make a new scope and all that.  but now, it just seems so ... right
11:51:30 <xkb> what an evil template name bind2nd
11:51:48 <xkb> mugwump: good to hear :D
11:52:09 <TFK> Namescopes are good.
11:52:20 <TFK> Haskell has let...in ^_^
11:52:42 <xkb> oh its a function, not a method
11:52:57 <karingo> let (a,b) = divMod c d in (a * d + b) == c => True ?
11:52:57 <TFK> Mmm?
11:56:21 <TFK> I can't say I fully understand any of it, though o.o
12:01:22 <lightstep> karingo, see section 6.4.2 in the standard
12:01:59 <lightstep> karingo, (you'll find that they chose the logical solution, like you'd expect)
12:02:07 <TheHunter> Prelude> :i >>
12:02:08 <TheHunter> [..]
12:02:08 <TheHunter> infixl 1 >>
12:02:15 <TheHunter> wtf?
12:02:28 <basti_> huh?
12:02:42 <TheHunter> how can >> be left-associative?
12:02:52 <basti_> what does >> mean?
12:02:58 <basti_> some arrow thingy?
12:02:59 <TheHunter> @type >>
12:03:02 <TheHunter> @type (>>)
12:03:02 <lightstep> it shouldn;t be
12:03:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
12:03:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
12:03:14 <lightstep> @info (>>)
12:03:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "info", try "lambdabot: @listcommands"
12:03:22 <basti_> is that arrow "bind"?
12:03:51 <lightstep> no, monad bind, but losing the result
12:03:59 <TheHunter> it's like bind, but discards the result of the first computation
12:04:00 <basti_> ah
12:04:14 <basti_> hmm
12:04:16 <lightstep> arrows have >>>
12:04:31 <basti_> yes is should not be left associative
12:06:03 <lightstep> it's a real shame that haskell has names like Array.Array or Maybe.maybeToList, and not like the ML naming conventions
12:07:39 <SyntaxNinja> lightstep: which is what?
12:08:03 <jlouis> karingo: Array.t
12:08:04 <SyntaxNinja> lightstep: that's probably due to the fact that there USED to be no hierarchical namespace, so things had to be disambiguated
12:08:05 <jlouis> Maybe.t
12:08:10 <jlouis> Array2.t
12:08:27 <jlouis> karingo: misstell
12:08:31 <SyntaxNinja> the new Map module, for instance, has more "generic" sounding names.
12:09:07 <lightstep> import qualified Data.Map as Map; f :: Map.Map -> a
12:09:07 <jlouis> When coding SML, I often let the type be t. It is easier that way. I also code in fully functorized style often
12:09:32 <Igloo> I don't see how the hierarchial namespace matters
12:09:33 <jlouis> is there any equivalent to SML functors by the way (parametric modules)
12:10:02 <lightstep> System.Exit.exitWith and System.Exit.exitFailure are also unpunning
12:10:08 <SyntaxNinja> Igloo: well, before the hierarchical namespace, you wouldn't want to have a "toList" function, you'd want a fmToList function, right?
12:10:37 <lightstep> it depends mostly if you like `qualified', or want to have a single namespace
12:10:38 <Igloo> Why does it matter if it's Data.FiniteMap.toList or just FiniteMap.toList?
12:11:50 <SyntaxNinja> Igloo: oh yeah, you're right
12:13:23 <TheHunter> jlouis, ask that on the mailing list and you'll probably get this answer: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
12:13:34 <TheHunter> so, no :)
12:13:38 <Lemmih> Hey RemiTurk (:
12:13:46 <RemiTurk> hi all
12:13:51 <RemiTurk> except Lemmih of course ;)
12:13:51 <TheHunter> hi RemiTurk
12:14:16 <jlouis> TheHunter: oh, an oleg@ mail ;)
12:14:16 * RemiTurk thinks Lemmih should spent a little more time on Haskell instead of bzflag ;0
12:15:45 * mugwump quacks
12:17:09 * RemiTurk throws a piece of loaf to mugwump
12:17:25 <jlouis> mugwump: MUD?
12:17:40 * mugwump swims over and grabs it before the other ducks close in to inherit what's left
12:18:08 <astrolabe> Is a mugwump something from William Burroughs?
12:18:13 * RemiTurk warns mugwump to be careful crossing roads
12:18:59 <mugwump> sure is, astrolabe
12:19:57 <astrolabe> I hope it is one of the less disgusting things :)
12:20:02 <mugwump> there's a great "duck crossing" triangular warning sign near my parent's house, I've had to completely stop the car to allow a line of ducks just like the warning sign cross before
12:21:17 <RemiTurk> I have a pool a few hundred metres from my house, where a bunch of huge ducks walk around and cross the road a few times a day
12:21:54 <RemiTurk> I regularly see a small traffic jam because of them :)
12:22:09 <keygjones> Can anyone help me with replacing elements within a list :s
12:22:34 <Cale> keygjones: sure
12:23:18 <Cale> keygjones: Which sort of replacing?
12:23:42 <keygjones> is it possible to work with single elements, extrcact an element [1,2,5,6] lets say 5 with 3 ??
12:24:02 <Oejet> Lemmih: I play BZflag a lot.
12:24:06 <lightstep> List.map does just that
12:24:20 <lightstep> or List.!!
12:24:21 <Lemmih> Oejet: Cool. We should play once.
12:24:22 <Oejet> s/a lot/too much/
12:24:28 <keygjones> alright ,
12:24:34 <Lemmih> Oejet: Under what alias?
12:24:35 <RemiTurk> Lemmih just completely smashed me with bzflag :-/
12:24:37 <jlouis> hmmm, what is the easiest way to create a persistence layer in Haskell? Say I have a given Data.Map I wish to store on-disk
12:24:42 <keygjones> thank you very much ill check it out :)
12:24:52 <lightstep> np
12:24:53 * RemiTurk just doesn't have his day today ;)
12:25:07 <Lemmih> jlouis: Show/Read.
12:25:19 <Oejet> Lemmih: Oejet. ;-)
12:25:24 <jlouis> Lemmih: thought so.
12:25:37 <Lemmih> jlouis: You can also check out SerTH.
12:25:44 <jlouis> ok.
12:27:07 <Lemmih> Oejet: Got time to play?
12:27:16 <Oejet> Lemmih: Yep. :-)
12:27:27 <Lemmih> Great!
12:27:55 <RemiTurk> oh well, there goes the haskell community to pieces...
12:28:26 <lightstep> ugh. this oleg message it too hard for me to grasp.
12:28:39 * RemiTurk waits for a servername
12:29:49 <keygjones> lightstep: what about replacing an element in a list [2,5,3,5] , take element number 2 and add 2 to it so I would get [2,7,3,5] ??
12:31:06 <lightstep> keygjones, linked lists are not the best type for random access. for that, records and arrays are a lot better
12:31:20 <lightstep> you can do it with pattern matching, though
12:31:25 <TheHunter> keygjones, check out take and drop.
12:31:45 <lightstep> case [2,5,3,5] of (x:y:z) -> (x:y+2:z)
12:32:05 <keygjones> allright, thanx allot
12:32:40 <TheHunter> alternatively: changeIndex f n = zipWith ($) (replicate n id ++ f: repeat id)
12:33:04 <lightstep> TheHunter++
12:33:05 <TheHunter> which has nice property wrt laziness.
12:35:07 <keygjones> massive,, now how can I copy and paste this info from the mirc window so I can study this good advise :)
12:35:26 <Lemmih> RemiTurk: sinon.homelinux.org:5154, up for a game with me and Oejet?
12:36:00 <jlouis> TheHunter: that is a pretty one
12:36:06 <lightstep> keygjones, if you mark an area in a mirc window, it copies (a la X)
12:36:16 <keygjones> gotit , thanx
12:39:41 <xerox> @kind Arrow
12:39:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
12:40:02 <lightstep> @kind Control.Arrow.Arrow
12:40:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
12:43:31 <jlouis> in the old Data.FiniteMap, I had addToFM_C. What is the equivalent in the new Data.Map ? fromListWith and union?
12:43:43 <jlouis> or a fold and insertWith?
12:43:49 <jlouis> or is there a function I overlooked
12:45:21 <jlouis> blah, solved
12:45:33 <jlouis> I did not want what I thought I wanted
12:45:57 <xerox> TheHunter: how was those "both" "swap" etc.. defined by Arrows?
12:46:24 <TheHunter> both f = f *** f
12:46:34 <TheHunter> swap = arr (\(x,y) -> (y,x))
12:47:05 <TheHunter> dup = arr (\x -> (x,x))
12:47:06 <lightstep> swap = snd &&& fst
12:47:35 <lightstep> dup = id &&& id
12:47:48 <lightstep> by the axioms, these are the same
12:47:51 <xerox> f *** f  and  snd &&& fst  are what I was searching for, thanks both
12:48:12 <TheHunter> not really, swap = arr snd &&& arr fst, dup = arr id &&& arr id
12:48:31 <lightstep> err, yes, that's it
12:49:12 <xerox> @plugs let swap = arr snd Control.Arrow.&&& arr fst in swap (1,2)
12:49:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (2,1)
12:49:30 <TheHunter> @plugs let swap = arr snd &&& arr fst in swap (1,2)
12:49:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (2,1)
12:49:34 <xerox> Hmm.
12:49:52 <lightstep> @help plugs
12:49:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @plugs <expr>
12:49:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have Haskell, 3 seconds and no IO. Go nuts!
12:49:59 <xerox> Just "let swap = arr snd Control.Arrow.&&& arr fst" gives an error in GHCi, tough
12:50:15 <TheHunter> hmm, dup = returnA &&& returnA
12:50:27 <lightstep> @please tell me which options @plugs takes
12:50:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "please", try "lambdabot: @listcommands"
12:50:43 <xerox> lightstep: I think it doesn't take "options"
12:51:01 <lightstep> yes. i meant which options it gives
12:51:04 <Ruller> Hello, my dear friends!
12:51:06 <lightstep> to ghci, that is
12:51:26 <xerox> Hello, Ruller!
12:51:30 <TheHunter> it uses hs-plugins instead of ghci.
12:51:56 <lightstep> with `eval' and all that?
12:52:18 <xerox> The error is: Ambiguous type variable `a' in the constraint: `Arrow a' arising from use of `&&&' at <interactive>:1:19-21  Probable fix: add a type signature that fixes these type variable(s)
12:52:37 <TheHunter> lightstep, yep.
12:52:52 <xerox> let swap = arr snd &&& arr fst :: (a,b) -> (b,a)  --  works
12:53:09 <TheHunter> xerox, what code gives that error?
12:53:33 <xerox> That line without the type declaration.
12:54:26 <lightstep> monomorphism restriction of some sort?
12:54:32 <TheHunter> lightstep, yes.
12:54:39 <TheHunter> just turn it off in ghci.
12:55:39 <xerox> But, what is it about?
12:56:49 <TheHunter> http://www.haskell.org/onlinereport/decls.html
12:57:35 <lightstep> xerox, it wants to protect you from `let x = read "1"'
12:58:17 <Cale> keygjones: you could also write something like update n a xs = take n xs ++ a : drop (n+1) xs, but this isn't too efficient in general.
12:58:41 <TheHunter> hmm, i guess i should fix lambdabot to compile with -fno-monomorphism-restriction.
12:58:56 <jlouis> hmmm, what happens if f :: a -> b, g :: c -> d -> a, and we do f . g? I mean, how should function composition be looked at intuitively when composing curried funcitons?
12:59:07 <xerox> lightstep: is it wrong because 1 could be of many types?
12:59:58 <RemiTurk> good night oejet
13:00:01 <TheHunter> @type \(f :: a -> b) -> (g :: c -> d -> a) -> f . g
13:00:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
13:00:07 <TheHunter> @type \(f :: a -> b) (g :: c -> d -> a) -> f . g
13:00:07 <lightstep> xerox, yes. the problem is that the type is polymorphic and qualified. this means that `swap' should be stored with the Arrow dictionary, which threatens both common sense and lazyness
13:00:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
13:00:12 <waltz> stfu!
13:00:18 <waltz> stop the noticing :|
13:00:26 <TFK> ah, waltz
13:00:29 <Oejet> RemiTurk: Good night, and thanks for the game!
13:00:33 <lightstep> @type (f :: a -> b) (g :: c -> d -> a)
13:00:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
13:00:42 <Lemmih> Sleep well, Oejet.
13:00:45 <RemiTurk> Oejet: thanks for saving me from Lemmih ;)
13:00:54 <TheHunter> jlouis, they can't be composed. you want (f .) . g
13:01:14 <xerox> If only @pointess was typed :-)
13:01:24 <jlouis> TheHunter: well, i just want to find out what happens when one composes curried functions
13:01:39 <jlouis> @type (.)
13:01:40 <lightstep> it's generally nontrivial
13:01:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (.) :: forall c a b. (b -> c) -> (a -> b) -> a -> c
13:02:06 <jlouis> lightstep: sure, but there must be trivial rules
13:02:17 <lightstep> @wiki LambdaBot/Notices
13:02:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/LambdaBot/Notices
13:03:15 <xerox> @pointless (\x y -> x) (\x' y' z' -> x')
13:03:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- const (const . const)
13:03:23 <xerox> Doesn't make sense, sorry.
13:16:29 <Oejet> How do I setup Gaim to handle notices in a sane way?
13:18:18 <Cale> Oejet: I'm not sure, but there ought to be a way, and if not, there's always X-Chat :)
13:19:24 <Cale> Notices should be treated mostly like talking.
13:19:40 <Oejet> Cale: I'm on Jabber, ICQ, IRC, Yahoo and MSN, so having a client for each would be a mess.
13:19:54 <lightstep> aren't notices private?
13:20:00 <Cale> lightstep: no
13:20:13 <Cale> not necessarily
13:20:48 <lightstep> so what is <msgtarget> ?
13:21:06 <Oejet> @plugs 2+3
13:21:08 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 5
13:21:43 -TheHunter(~TheHunter@p54AB142C.dip0.t-ipconnect.de)- i'm a notice
13:22:06 <Cale> the name of a channel or user, same as PRIVMSG, which is the command used to talk in channels and in private
13:22:50 <TheHunter> @plugs 3 + 4
13:22:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 7
13:23:05 -TheHunter(~TheHunter@p54AB142C.dip0.t-ipconnect.de)- 7
13:23:46 <RemiTurk> @plugs 1 * 42
13:23:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 42
13:24:30 <TheHunter> @quote ghc
13:24:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Implicit-parameter bindings illegal in a parallel list comprehension
13:24:39 <TheHunter> haha!
13:24:58 <lightstep> @quote TheHunter
13:24:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- TheHunter hasn't said anything memorable
13:25:19 <RemiTurk> @quote lambdabot
13:25:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot hasn't said anything memorable
13:26:19 <TFK> @quote basti_
13:26:19 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- basti_ hasn't said anything memorable
13:26:31 <TheHunter> @plugs [?foo | let ?foo = 1 | _ <- [1,2,3]]
13:26:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- parse error on input `?'
13:27:09 <TheHunter> i bet noone has ever got that error message.
13:27:47 <RemiTurk> I doubt it
13:27:57 <lightstep> it's always better to include superfluous error messages than miss patterns
13:29:12 <Ruller> you are cool!
13:29:20 <Ruller> I love you all!
13:29:33 * Ruller is washing himself
13:30:10 <lightstep> in front of the keyboard?
13:32:33 <Ruller> yeeeah :)
13:32:42 <RemiTurk> did anyone ever miss Data.Array.ST.Lazy?
13:37:38 <jlouis> @pointless \f x -> (flip . f x)
13:37:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ((flip .) .)
13:38:46 <CosmicRay> @quote MegaMonad
13:38:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- MegaMonad hasn't said anything memorable
13:38:54 <CosmicRay> @karma CosmicRay
13:38:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
13:38:56 <CosmicRay> @help
13:38:57 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  @help <command> - ask for help for <command>
13:39:01 <CosmicRay> @commands
13:39:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "commands", try "lambdabot: @listcommands"
13:39:06 <CosmicRay> @listcommands
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I react to the following commands: ["all-dicts","arr","babel","define","
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- definitions","del-definition","devils","dict","dict-help","dummy","dump"
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements"
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","help"
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"hitchcock","jargon","join","karma","karma+","karma-","kind","learn","leave"
13:39:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"listchans","listcommands","listmodules","lojban","moo","more","msg","part"
13:39:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"paste","pl-resume","plugs","pointless","prelude","quit","quote","reconnect"
13:39:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3 @more lines]
13:39:15 <CosmicRay> @eurohaskell
13:39:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- less talks, more code!
13:39:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/EuroHaskell
13:39:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- EuroHaskell - Haskell Hackfest - Summer 2005 - Gothenburg, Sweden
13:40:50 <xerox> Whooo..
13:40:53 <TheHunter> RemiTurk, never missed it. But I'm wondering if it breaks purity, now.
13:44:39 <jlouis> @pointless \x a b c d e -> a b d c e
13:44:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- const (flip .)
13:44:48 <jlouis> @type const
13:44:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- const :: forall a b. a -> b -> a
13:48:26 <jlouis> @type const (flip .)
13:48:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- const (flip .) :: forall a b c a1 b1.
13:48:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                   b1 -> (a1 -> a -> b -> c) -> a1 -> b -> a -> c
13:48:40 <jlouis> bleh
13:48:48 <jlouis> @pointless \a b c d e -> a b d c e
13:48:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (flip .)
13:51:18 <SyntaxNinja> @hitchcock
13:52:17 <ibid> @karma ibid
13:52:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
13:52:25 <ibid> wow, it's forgotten
13:52:30 * ibid dances the happy dance
13:52:46 <jlouis> ibid: guess what I am working on ;)
13:52:56 <SyntaxNinja> what does hitchcock do?
13:52:59 <ibid> jlouis: do tell
13:53:10 <CosmicRay> @help hitchcock
13:53:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I perform dictionary lookups via the following 14 commands:
13:53:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @all-dicts .. Query all databases on dict.org
13:53:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @devils ..... The Devil's Dictionary
13:53:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @easton ..... Easton's 1897 Bible Dictionary
13:53:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @elements ... Elements database
13:53:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @foldoc ..... The Free On-line Dictionary of Computing
13:53:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @gazetteer .. U.S. Gazetteer (1990)
13:53:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [8 @more lines]
13:53:18 <CosmicRay> ah.
13:53:25 <ibid> @gazetteer haskell
13:53:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "Haskell" gazetteer "U.S. Gazetteer (1990)"
13:53:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Haskell, AR (city, FIPS 30640)
13:53:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Location: 34.50546 N, 92.63664 W
13:53:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Population (1990): 1342 (485 housing units)
13:53:28 <CosmicRay> @hitchcock babylon
13:53:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Area: 8.5 sq km (land), 0.0 sq km (water)
13:53:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Haskell, NJ
13:53:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [11 @more lines]
13:53:36 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "Babylon" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)
13:53:36 <TFK> @moo
13:53:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "
13:53:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Babylon, same as Babel
13:53:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-          (__)
13:53:46 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-          (oo)
13:53:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-    /------\/
13:53:50 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   / |    ||
13:53:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-  *  /\---/\
13:53:52 <CosmicRay> heh
13:53:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     ~~   ~~
13:53:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ...."Have you mooed today?"...
13:54:11 <ibid> if it can do that, then it probably can do this...
13:54:22 <ibid> @update ; @dist-upgrade
13:54:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "update", try "lambdabot: @listcommands"
13:54:28 <ibid> darn
13:54:29 <CosmicRay> heh
13:54:41 <ibid> this lambdabot has super cow powers?
13:54:57 <TFK> Naturally.
13:56:01 <Oejet> @plugs 42
13:56:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 42
13:56:19 <CosmicRay> @help dynamic-load
13:56:20 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- @dynamic-(un|re)?load: interface to dynamic linker
13:58:01 <ibid> "This is a simple transparent wallpaper in png. It features the vectorised Debian logo and the Debian cow."
13:58:10 <ibid> (http://gnome-look.org/content/show.php?content=22002)
13:58:35 <CosmicRay> I didn't nkow debian had a cow.
13:58:53 <ibid> me neither
13:59:23 <ibid> well, that's probably our next logo, after we get tired of the swirl
13:59:32 <ibid> we once had the chicken, we will one day have the cow!
13:59:48 <ibid> (i liked the chicken, btw)
14:00:00 <CosmicRay> ibid: that's another flamewar waiting to happen
14:00:13 <TFK> Doom. Lord...
14:00:26 <kaol> polygen pythoniser | b1ff | cowsay (apt-get install polygen polygen-data cowsay filters)
14:01:32 * kaol is aware that that has nothing to do with haskell
14:02:01 <CosmicRay> yet you have pointed me to polygen, which looks like an excellent new way to waste time
14:02:02 <CosmicRay> thank you
14:02:13 <SyntaxNinja> cowsay is very powerful, read the man page... you can make evil cows, dragons, etc.
14:02:25 <Lemmih> Anyone got irssi >= 0.8.9?
14:03:02 <psi> i do
14:03:11 <ibid> i seem to
14:03:39 <SyntaxNinja> cowsay -f /usr/share/cowsay/cows/vader.cow "I find your lack of faith disturbing"
14:03:43 <jlouis> anyone that knows what happens when you in a GHC 6.4 Data.Map inserts first (1, 1) and then (1, 2)? Does it raise some exception, or does it overwrite the value? The old Version of the library Data.FiniteMap stated explicitly that it overwrites the value
14:04:21 <Lemmih> How do you configure it to display notices nicer? The wiki text is apparently outdated.
14:04:41 <SyntaxNinja> jlouis: if the behavior is not documented, please post something about that to the mailing list! that's an important case to handle
14:04:52 <ibid> Lemmih: no idea
14:04:53 <jlouis> SyntaxNinja: indeed, what mailing list?
14:04:56 <SyntaxNinja> jlouis: best guess is that it overwrites the value.
14:05:12 <jlouis> SyntaxNinja: I think so too, but I'll bug people if I knew the mailing list
14:05:13 <SyntaxNinja> jlouis: libraries@haskell.org if you're subscribed, or just haskell or haskell-cafe if that's inconvinient
14:05:35 <ibid> sleep time, bbl :)
14:05:46 <jlouis> http://www.haskell.org/ghc/docs/latest/html/users_guide/introduction-GHC.html#mailing-lists-GHC
14:05:53 <jlouis> ;)
14:06:17 <SyntaxNinja> those are the GHC mailing lists
14:06:37 <SyntaxNinja> http://www.haskell.org/mailinglist.html
14:08:36 <jlouis> SyntaxNinja: yeah, found them
14:10:55 <RemiTurk> TheHunter: I hope it doesn't: 1) If it would break anything, Data.STRef.Lazy would too, I think and 2) it can be implemented on top of the strict version + strictToLazyST, which doesn't sseem to have any warnings attached
14:16:25 <CosmicRay> I'm parsing a file that has about 25 fixed-length fields on each line.  What do you think is the proper Haskellish way to do this?  I could do a bunch of valn <- count 5 (anyChar) with Parsec, or a complicated series of splitAt with let, etc.
14:17:18 <CosmicRay> is there a nifty way to use a monad for this?
14:17:27 <CosmicRay> (combined with splitAt somehow maybe?)
14:19:08 <jlouis> SyntaxNinja: mail sent to libraries@
14:19:35 <SyntaxNinja> jlouis: OK; hope it goes through. I think JaffaCake has to approve them if you're not subscribed
14:20:12 <jlouis> SyntaxNinja: I am subscribed
14:20:13 <SyntaxNinja> oh good, I see it :)
14:20:18 <jlouis> ;)
14:20:45 <jlouis> in fact, I just subscribed to 3-4 mailing lists, heh
14:20:55 <SyntaxNinja> fun!
14:20:58 <jlouis> ;
14:20:59 <x3n0n> CosmicRay: parseLine = sequence . map (\n -> count n anyChar) -- untested ?
14:21:11 <xerox> Tell me what you think about this: I was arguing with a friend about how "ascii art" combinators are nice, instead of alphanumeric ones. We finished talking about how programming in Haskell is more about thinking in a funcitonal way, that for most people seem more natural than imperative way (I agree with this hypotesis). When I tryed to explain to him how (.) worked, he drove nuts on the type declaration. I tried explaining a -> b -> c is ri
14:22:11 <jlouis> right associative
14:22:14 <jlouis> ...
14:22:15 <jlouis> go on ;)
14:22:33 <xerox> Ahah.
14:23:11 <xerox> I said "a -> b -> c  equals a -> (b -> c)" the reply was "ooh, the parens makes it clear, but I don't want.." you know the rest.
14:23:35 <jlouis> yeah, it is quite fun
14:23:43 <jlouis> been there many times
14:24:25 <xerox> jlouis: I'm very hangry with him, I happened to say intelligent things in that discussion. At least, I think :-)
14:25:43 <xerox> Like: you think about `+' as an operator between numbers from when you're at elementary school - try to image applying the same to those ascii combinators, completing it with types: it gives you a nice way to think about / implement algorithms.
14:25:59 <mwc> xerox, use the C-word. I look at it as currying across the left most parameter to specialize the function, then currying again, etc. instead of calling the function with x-parameters
14:26:14 <mwc> that put it all on better mathematical ground for me when I realized that
14:27:23 <CosmicRay> x3n0n: interesting.  I like.
14:28:28 <jlouis> Can I get a couple of people to join #jlouis-lbot? I need to check the SeenModule for testing, now I have cleaned some of it up ;)
14:28:59 <mwc> jlouis, beat you there?
15:04:40 <mwc> I don't understand data constructors, apparently. If i have defined data Tuple a b c d = Quadruple a b c d
15:05:02 <mwc> then t = Quadruple 1 'a' (4.0, 'b') "foo" fails
15:06:02 <wagle> what does it say when it fails?
15:06:11 <mwc> No instance for (Num (Char -> (a1, Char) -> [Char] -> a))
15:06:11 <mwc>       arising from the literal `1' at Tuple.hs:34:16
15:06:19 <mwc> I don't understand taht num though
15:06:54 <wagle> you are trying to use it in a numeric (Num) context..  what is the context?
15:07:02 <mwc> I recongize the callee type signature but where does that Num come from?
15:07:06 <mwc> I'm using it just in a module
15:07:36 <mwc> t = Quadruple etc right after I've defined functions on this Tuple class
15:08:04 <wagle> lets see the entire line and the line or two before it
15:09:19 <wagle> looks like its trying to treat the Quadruple constructor as a Num, and not finding a way to do that
15:09:40 <mwc> http://www.nomorepasting.com/paste.php?pasteID=36564
15:09:46 <mwc> There's the entire file
15:10:27 <Lemmih> Heh (:
15:10:33 <Lemmih> Remove the parentheses.
15:10:43 <wagle> remove the parens from line 34
15:10:48 <mwc> Lemmih, what? I had them on befoer and get a problem too
15:10:57 <Lemmih> You're trying to use '1' as a function.
15:11:07 <wagle> yeah
15:11:50 <wagle> t = Quadruple 1 'a' (4,'b') "Hello"
15:11:52 <mwc> Why is that?
15:12:06 <mwc> Why am I trying to use 1 as a function?
15:12:25 <wagle> the stuff inside the parens is a single expression
15:12:37 <mwc> Oh, right
15:12:44 <wagle> the first thing in the expression is 1
15:12:49 <wagle> ok
15:15:21 <wagle> mwc: does it work now?
15:16:05 <martin_> is there any way to compile ghc6.4 without readline4?
15:16:29 <wagle> why not get readline4?
15:17:06 <mwc> wagle, yep, works fine
15:17:09 <martin_> because i compiled my linux from scratch and i can't install readline 4 and 5 at the same time
15:17:12 <wagle> mwc: cool
15:17:34 <wagle> oh, you want to use readline5 instead?
15:17:34 <mwc> On another note, is there a less verbose way of specifying all those functions?
15:17:42 <martin_> yes
15:18:02 <mwc> or do I have to match against all the constructors?
15:18:18 <wagle> martin_: ugh
15:19:27 <wagle> mwc: my understanding is that haskell is clumsy with tuples..  there is a way around with template haskell, but that's pretty overkill
15:19:29 <martin_> on debian ghc6 only depends on libreadline5
15:20:06 <mwc> wagle, yeah, this is just an exercise so I don't really care at this point
15:20:13 <mwc> just wondering if there's a better way to do it
15:20:16 <wagle> martin_: i dunno..  there are hacks to install both..
15:20:30 <Lemmih> mwc: You can name the fields and only do error checking.
15:21:06 <wagle> martin_: a dirty fix is to compile, but not install readline4..  then go in and statically link the readline4 libs to the ld commands
15:21:21 <wagle> martin_: there's probably a better way
15:21:34 <keygjones> is there a function wich changes Char to Int ??
15:21:56 <Lemmih> @type Data.Char.Ord
15:21:59 <Lemmih> @type Data.Char.ord
15:22:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
15:22:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.Char.ord :: Char -> Int
15:22:44 <martin_> @type Data.Char.digitToInt
15:22:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.Char.digitToInt :: Char -> Int
15:23:02 <keygjones> allright thnx
15:23:07 <wagle> martin_: ahh..  named fields (which i dont use, so dont think of) is the thing to check into
15:23:27 <martin_> wagle, what?
15:23:52 <wagle> martin_: what Lemmih said
15:24:58 <wagle> something like data Foo = {Bar :: Int, Moo :: Char, ...}
15:25:08 <wagle> i dont even know the syntax, sigh
15:25:31 <Lemmih> wagle: s/martin_/mwc/ (:
15:26:05 <martin_> it has to be data Foo = Foo { bar :: Int, moo :: Char, ... }
15:26:06 <wagle> I hear Mark Jones uses it a lot to great effect, but i havent seen examples
15:26:20 <xerox> Goodnight folks.
15:26:38 <wagle> thats gross..  m<tab> completes to martin_
15:27:01 <Lemmih> mwc: data Tuple a b c d = Single { first :: a } | Double { first :: a, second :: b} | ...
15:28:01 <wagle> what maniac decided that martin_ and mwc didnt make m<tab> ambiguous?
15:28:54 <Cale> named fields are useful when you have more than a couple of fields that you need to work with
15:34:00 <astrolabe> Night xerox
16:03:30 <dons> moin
16:19:17 <mwc> wagle, you just gotta double tab :P
16:19:23 <mwc> at least for xchat
16:22:35 <dons> @type GHC.Base.Unit :: 1
16:22:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- GHC.Base.Unit :: 1 :: GHC.Base.Unit
16:22:49 <dons> weird. what's this then?
16:23:52 <dons> ah. generics? data Unit = Unit. hmm.
16:35:42 <dons> gday Pseudonym
16:35:45 <dons> seen this:
16:35:52 <dons> @type GHC.Base.Unit :: 1
16:35:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- GHC.Base.Unit :: 1 :: GHC.Base.Unit
16:35:59 <dons> @kind 1
16:36:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 1 :: *
16:38:36 <Pseudonym> G'day.
17:03:55 <wagle> mwc: irssi does the same..  >-p
17:08:06 <stepcut> suck, haskelldb is too broken for me to fix in the next 2 hours :-/
17:11:07 <Lemmih> Do you think it's broken or just has a too limited use?
17:11:32 <stepcut> I know it is really broken, and has been for a long time
17:12:14 <Lemmih> How so?
17:12:28 <stepcut> it requires that all your column names be unique to work properly
17:12:58 <stepcut> :p
17:13:22 <stepcut> so, if you have many tables with the column 'id' you are screwed
17:13:24 <Lemmih> Isn't that intentional?
17:13:44 <Lemmih> Oh.
17:14:05 <stepcut> when you try to project the 'id' columns, you will just get the first one
17:14:56 <Lemmih> What about changing the static/generated database info?
17:14:58 <stepcut> that is not a very clear explanation... but you get the idea -- it is not what you expect
17:15:19 <stepcut> I was going to try that, but I ran into a problem, which I may or may not be able to work around
17:15:44 <stepcut> I can have it generate the field ids fully qualified, (like, table1.id table2.id)
17:15:49 <Lemmih> You can change the fieldName to whatever you want.
17:16:25 <stepcut> I don't think you can
17:17:08 <Lemmih> Oh right.
17:17:48 <stepcut> so, I tried to change them to just be fully qualified, but that causes two problems:
17:18:16 <keygjones> how do you work with two lists in a tuple ([1,2,3],[4,5,6]), for example how do I drop an element from the second list and add a new element to it?? anyone
17:18:20 <stepcut> (1) haskelldb renames tables,   --> select table1.id from table1 AS T1;
17:18:45 <stepcut> I can supress the 'AS T1' part, and then it generates a valid SQL query
17:19:11 <stepcut> but, when it reads the fields back from the resulting row, you can't use the fully qualified field name
17:19:20 <Lemmih> keygjones: Checkout (!!) and (:)
17:19:24 <Lemmih> @type (!!)
17:19:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (!!) :: forall a. [a] -> Int -> a
17:19:27 <Lemmih> @type (:)
17:19:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (:) :: forall a. a -> [a] -> [a]
17:19:34 <stepcut> that is the part I am working around now, if possible
17:19:52 <keygjones> allright , thank you
17:19:59 <stepcut> but really, that is still a bad hack
17:20:17 <Lemmih> Rewriting large parts of HDB would be cool.
17:20:18 <stepcut> the real problem is the assumption that schemas always contain unique field names
17:20:35 <stepcut> I hope to rewrite large parts this year... but we will see how much time I have
17:21:07 <Lemmih> stepcut: Make sure to include backend specific behaviour (:
17:21:16 <stepcut> I am not yet convinced that queries need to be, or even should be, generated in monads
17:24:20 * wagle waits for the paper titled "Monads Considered Harmful"
17:32:49 <stepcut> well, I will just not use multiple tabs in the same query :p
17:35:09 <stepcut> I can even do it without it looking like a hack in my code ;)
17:37:44 <wagle> how does lambdabot's @pointless transform work?
17:38:44 <Lemmih> Magic.
17:42:15 <dons> @version
17:42:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- lambdabot 2p124, GHC 6.4 (OpenBSD i386)
17:42:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:42:19 <dons> have a look!
17:42:24 <dons> it's in PlModule/*
17:44:44 <wagle> egad. CPP directives!  8)
17:45:13 <wagle> i cant escape C!  its following me!
17:46:07 <TheHunter> wagle, the transformation itself is extremely simple.
17:46:45 <TheHunter> actually, two pointless transformations are implemented, the simpler of which is transformM in Rules.hs
17:46:48 <wagle> TheHunter: yeah, i expect so
17:47:10 <dons> TheHunter, see my little commit:
17:47:15 <dons> @pl \x -> x . x
17:47:16 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s (.) id
17:47:45 <wagle> s?
17:47:48 <dons> @pointless \x -> x . x
17:47:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s (.) id
17:48:06 <TheHunter> most of the code deals with simplifying pointless expressions
17:48:20 <TheHunter> @pointless foo f g x = f x (g x)
17:48:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- foo = s
17:49:06 <TheHunter> actually, the libraries define s (it's ap for the reader monad), but i thought that'd be a little too much.
17:49:25 <wagle> @index s
17:49:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "index", try "lambdabot: @listcommands"
17:49:47 <wagle> @listcommands
17:49:47 <dons> custom shapr hack. he needs to send me the code.
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I react to the following commands: ["all-dicts","arr","babel","define","
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- definitions","del-definition","devils","dict","dict-help","dummy","dump"
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"dynamic-load","dynamic-reload","dynamic-unload","easton","echo","elements"
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"eurohaskell","eval","foldoc","fortune","gazetteer","get-definition","help"
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"hitchcock","jargon","join","karma","karma+","karma-","kind","learn","leave"
17:49:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"listchans","listcommands","listmodules","lojban","moo","more","msg","part"
17:49:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ,"paste","pl","pl-resume","plugs","pointless","prelude","quit","quote","
17:49:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3 @more lines]
17:49:59 <wagle> eep
17:50:29 <putter> @more
17:50:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- wrong type (<<[] Char>>) in ModuleState
17:50:38 <wagle> @more
17:50:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- wrong type (<<[] Char>>) in ModuleState
17:50:52 <dons> blah.
17:50:53 <wagle> ahh, one state for everyone
17:51:03 <TheHunter> the @more module must be static
17:51:13 <dons> _must_ be? ah!
17:51:14 <TheHunter> (at least until there's a decent solution to handle state)
17:51:44 <dons> so that's what the comment "the more module must be static" meant :}
17:51:50 <wagle> huh..  what IS the command to find which module s is in?
17:51:51 <TheHunter> wait, no, it must be dynamic
17:51:57 <TheHunter> i don't remember.
17:52:11 <dons> isn't this a module init issue?
17:52:28 <TheHunter> no, it's a Data.Typeable issue.
17:52:31 <dons> I'll have a look at this in a few hours.
17:52:33 <dons> ah!
17:52:51 <dons> maybe I already have  a fix. I think I came up with a fix last year, in my fork.
17:52:54 <dons> i'll merge.
17:52:57 <wagle> lambdabot: where is s?
17:52:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
17:52:58 <TheHunter> Typeable tries to be as efficient as possible and does some agressive caching.
17:53:14 <dons> ?
17:53:24 <dons> isn't it that typereps aren't shared between modules?
17:53:37 <dons> so if they're compiled separately, they'll have different keys for the same type.
17:53:55 <TheHunter> yes, exactly that's the problem.
17:54:12 <dons> string comparison on canonical type reps solves this.
17:54:24 <dons> for now. until we hack the rts to store type rep keys.
17:54:57 <TheHunter> @type Control.Monad.Reader.ap ::  (t -> a -> b) -> (t -> a) -> t -> b
17:54:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Control.Monad.Reader.ap ::  (t -> a -> b) -> (t -> a) -> t -> b :: forall
17:54:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- t
17:54:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:54:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- a
17:54:58 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                         
17:54:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- b.
17:55:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                    (t ->
17:55:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- a -> b)
17:55:05 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                    -> (t
17:55:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- -> a)
17:55:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                    -> t
17:55:11 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                                                                    -> b
17:55:17 <wagle> what IS the command to find which module s is in?
17:55:23 <wagle> (ewww)
17:55:31 <TheHunter> there is no module that defines s
17:55:39 <TheHunter> @get-definition S
17:55:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- S = \f g x.f x (g x)
17:56:01 <wagle> @pl \x -> x . x
17:56:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s (.) id
17:56:09 <wagle> ^ that s
17:56:40 <wagle> or is s == S?
17:57:07 <TheHunter> yeah, s = S.
17:57:22 <wagle> i'm more wondering about the general issue of getting lambdabot to tell me which module(s) something is in
17:57:43 <wagle> @get-definition ap
17:57:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ap not defined
17:58:00 <wagle> @get-definition App
17:58:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- App not defined
17:58:03 <wagle> ...
17:59:40 <dons>  @index would normally do this, but it is implemented in a patch that shapr has, but isn't yet part of the main lambdabot branch.
17:59:49 <dons> requires a hack to haddock
18:02:19 <wagle> ah
18:27:48 <wagle> does plbbt mean something in the acronymspeak?
18:31:47 <TheHunter> dons, so what about making Module a multiparameter type class with the type of the module state as a second parameter and handling state in a typesafe way?
18:36:18 <dons> typesafe state sounds good. using Typeable seems super hacky.
18:36:44 <heatsink> for Map.insertWith, what is the order of parameters to the combining function?
18:36:58 <dons> TheHunter: sketches, or patches! (I won't have time this week to implement it, I think)
18:37:03 <heatsink> Does the value being inserted come first or second?
18:37:13 <dons> @type Data.Map.insertwith
18:37:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- bzzt
18:37:20 <dons> @type Data.Map.insertWith
18:37:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Data.Map.insertWith :: forall a k.
18:37:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                        (Ord k) =>
18:37:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-                        (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.
18:37:21 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Map.Map k a
18:37:32 <dons> f key elem map
18:37:34 <heatsink> I'm talking about the parameters to the function (a -> a -> a) there
18:37:57 <dons> better check the src
18:38:15 <heatsink> I'll test it.
18:40:19 <TheHunter> so do you think process :: m -> .. -> ReaderT (IORef s) IRC () would be sensible?
18:44:43 <dons> ok, that's nice. yes.
18:45:04 <dons> yes, I like this idea.
18:45:10 <TheHunter> ok, i'll try to do that.
18:45:34 <dons> death to dynamic typing!
18:45:57 <flippo> ideologue!
18:49:19 <mwc> Dynamics typing is alright, as long as you only have one type.
18:50:03 <heatsink> as in Python.
18:51:17 <mwc> er, Ruby, I hope you mean :P
18:51:30 <wagle> death to typing!  up with direct neural input.
18:51:34 <mwc> I don't think in python that int > Object
18:51:50 <mwc> just program genetically
18:51:53 <dons> long live static neural typing
18:52:02 <dons> I want my thoughts type checked before I run them!
18:52:19 <mwc> create thosands of random executables and select towards your desired application
18:52:32 <dons>  @dynamic-load-into-my-brain isabelle
18:52:33 <heatsink> The Python typesystem isn't the real type system.  All python objects implement the same set of methods.
18:52:35 <wagle> why should i wait until after i have entered my program to find out whether is type checks or not?
18:52:46 <heatsink> Most of those methods' default behavior is to raise an exception.
18:52:54 <heatsink> e.g. AttributeError.
18:53:01 <mwc> heatsink, isn't it done with hashtables?
18:53:14 <heatsink> mwc: yes AFAIK.
18:54:39 <heatsink> For those who use emacs haskell-mode, where do you put comments?  I get frustrated by the way emacs indents when there is a comment-only line in the middle of a function.
18:55:14 <mwc> heatsink, Vim's haskell mode doesn't indent, try that :P
18:55:25 <TNKS> hey guys.  I was wondering if someone could give me an idea for how good Haskell is at dodging needless recomputation.
18:55:35 * heatsink gets tired of typing fifty spaces every line
18:55:52 <wagle> my xemacs haskell mode seems to suck more as time passes
18:57:05 <TNKS> Say, if have non-primitive arguments to a function that has already been evaluated with the exact same arguments (expressions that have already been evaluated).
18:57:08 <heatsink> TNKS: haskell only evaluates values that are used to control if/then/else or sent to IO.
18:57:34 <heatsink> TNKS: the language doesn't perform redundancy elimination.
18:57:44 <heatsink> Although the compiler can do some of that.
18:57:52 <wagle> really need hybrid parsers that (1) know the complete syntax and (2) arent driven insance by regions of arbitrary text
18:58:19 <wagle> ... insane ..
18:58:22 <heatsink> wagle: yea, u right.
18:58:29 <heatsink> dons: how's that coming, anyway? ;)
18:58:35 <Lemmih> heatsink: case expressions force evaluation.
18:58:57 <Pseudonym> Lemmih: You're talking about core, not Haskell, right?
18:58:57 <heatsink> Lemmih: case and if/then/else are the same thing.
18:59:19 <TNKS> heatsink, I guess I'm driving at memoization, which I seem to understand somewhat, but I'm not yet comfortable with completely.
18:59:32 <Lemmih> heatsink: if/then/else is just rewritten to case expr of True -> .. ; False -> ...
18:59:58 <wagle> i'm still looking for a way to turn that into a doable project
19:00:02 <heatsink> TNKS: yes, that is what I was referring to with redundancy elimination.  You can write code using memoization using @wiki MemoizingCAFS ...
19:00:09 <heatsink> @wiki MemoizingCAFS
19:00:10 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/MemoizingCAFS
19:00:37 <heatsink> wagle: you mean the hybrid parser thing?
19:00:37 <wagle> @wiki foobeebooblatz
19:00:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/foobeebooblatz
19:00:48 <wagle> heatsink: yeah
19:00:50 <jesse> ha
19:00:59 <heatsink> aw, I misspelled it.
19:01:03 <Pseudonym> @wiki MemoisingCafs
19:01:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/MemoisingCafs
19:01:18 <Lemmih> Pseudonym: There's a difference in this context?
19:01:35 <wagle> i think lambdabot just tacks the prefix onto whatever you wiki for
19:01:58 <Pseudonym> Yes.
19:02:19 <wagle> whats the point of the @wiki command?
19:02:20 <Pseudonym> Prelude> case undefined of { _ -> "Hello" }
19:02:20 <Pseudonym> "Hello"
19:02:28 <heatsink> @wiki ../learning.html
19:02:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/../learning.html
19:02:38 <heatsink> :)
19:03:06 <Pseudonym> wagle: Bot-side macro.
19:03:09 <Pseudonym> Saves typing.
19:03:35 <Lemmih> *Case expresions _can_ force evaluation.
19:03:39 <wagle> should at least check to see if the page exists?
19:04:05 * heatsink realizes that redundancy elimination and memoization are different
19:04:08 * heatsink smacks itself
19:04:10 <Pseudonym> In Core, they _always_ force evalyation.
19:04:23 <Pseudonym> The above expression is translated into something like:
19:04:30 <Pseudonym> let _ = undefined = "Hello"
19:04:36 <Pseudonym> let _ = undefined in "Hello"
19:07:31 <Lemmih> But I don't care about Core...
19:07:45 <Pseudonym> Thast's why I didn't understand.
19:08:06 <Lemmih> It at least, I can't see it's relevance.
19:08:13 <Lemmih> *its
19:08:28 <Pseudonym> Case expressions _do_ force evaluation in Core, hence I thought you might be talking about Core.
19:15:06 <Lemmih> I just thought it was weird that 'if' expressions were said to force evaluations when they're just syntactic sugar for a case expression.
19:27:58 <heatsink> I thought that the meaning of "if/then/else" would be more recognizable than "case" to someone who might not be familiar with the language.
19:32:38 <TNKS> all right. I think I'm still stuck in my imperative programming mindset, but I'd like to figure out something.  I have a set of three functions that recursively reference each other, and they take in as input an instance of an abstract datatype.  I'd like to memoize these functions, but they evaluate differently for each instance of the ADT.
19:33:14 <TNKS> Is there anything I can do to memoize for each instance?
19:34:00 <monochrom> the datatype is abstract... how abstract is abstract?
19:34:26 <heatsink> What is the subset of the computation that repeatedly is evaluated with the same inputs or parameters?
19:35:13 <TNKS> monochrom, I know what you're getting at. . . I'm just driving at the fact that it's not primitive at all ("data" declared with multiple constructors).
19:35:28 <monochrom> I mean for example if you can obtain hashcodes (like in many other languages) then it is not so abstract, and it will help your memoization.
19:35:59 <TNKS> Calculating one function forces an evaluation of the other two functions, but I potentially may need values from all three functions.
19:36:13 <TNKS> I'd like to not burn through the entire computation three times.
19:36:29 <TNKS> (because it already takes long for just one). . .
19:36:33 <heatsink> oh, I see.
19:38:20 <TNKS> hashcodes would be nice, but I'm not sure.  my ADT is a "network" with lists of "devices," some of which have behavior defined by a function specified to the constructor.
19:40:41 <heatsink> For a given calculation, if it were memoized properly, would each function be called only once?
19:40:56 <heatsink> ...zero or one times?
19:41:38 <TNKS> heatsink, I'm not exactly sure. . . I'm trying to code for some flexibility here.
19:41:55 <monochrom> You need either hashcode or an ordering.  Some way that you can search and answer the question "have I seen this before".  The design of the hashing or ordering is, of course, specific to the actual data you have, on which I can't really comment, of course, unless *I* get to design your whole system.
19:41:55 <TNKS> But I can imagine only needing to have results from each function only once.
19:42:43 <heatsink> What I'm thinking is that if you only need answers to persist during mutually recursive calls, and no longer, then you can probably use a recursive let to get what you want.
19:45:08 <heatsink> It's hard to say without knowing just how the functions call one another.
19:45:12 <TNKS> heatsink, my functions right now take each take in a Network as an argument.  Will this mess up recursive lets?
19:45:44 <heatsink> No.
19:46:28 <TNKS> So If I call a function with this weird argument, the interpreter will remember that I've used it before?
19:47:19 <heatsink> Not really... it's just remembering the answer without bothering to remember the arguments, if you already know that the arguments will be the same for each call.
19:47:52 <heatsink> so it's simpler than memoization.
19:48:38 <TNKS> heatsink, I think I'm confused about this issue of persistence.
19:49:33 <heatsink> TNKS: it's a memoization table of size 1 that always returns the value stored in it :)
19:49:52 <heatsink> what about persistence?
19:51:08 <TNKS> persistence is a "memoization table"?
19:52:28 <heatsink> no, i was making an analogy there.
19:55:41 <TNKS> heatsink.  I'm just really confused when Haskell will remember an answer.
19:56:30 <heatsink> Haskell remembers an answer when it is assigned to a variable.
19:57:27 <heatsink> When the variable is assigned, it gets the unevaluated answer.
19:57:43 <TNKS> and when it's evaluated, the answer sticks?
19:57:45 <heatsink> The first time the variable is used (in a case expression for example), the answer is evaluated.
19:58:04 <heatsink> Now the variable refers to the evaluated answer, so the next times it is used, it doesn't need to be reevaluated.
19:58:59 <wagle> evaluated enough to do the pattern match
19:59:05 <heatsink> right.
19:59:30 <TNKS> okay, I think that' the impression I had.
19:59:42 <TNKS> But now I'm left with somewhat of the same problem I had, I think.
19:59:50 <TNKS> I understand now, how memoizing can work.
20:00:05 <TNKS> But that's hard given that I don't have a hashcode yet for my ADT.
20:00:46 <wagle> i was wondering whethe compiler/interpreter might do the same expression more than once, not eliminating common expressions..  i've seen that come up, but i have no grasp of what the rules are
20:01:59 <heatsink> wagle: count the number of times an argument is applied to the function; that is how many times it is evaluated.
20:02:46 <wagle> let x = y + 1 in fo x x x
20:02:59 <wagle> 3 adds?
20:03:08 <heatsink> no, one add.
20:03:24 <wagle> (what i thought, but not what you seemed to say)
20:03:26 <heatsink> This is three adds: let x = (y+) in fo (x 1) (x 1) (x 1)
20:03:40 <wagle> ah
20:04:15 <heatsink> TNKS: if you wnat to hash, you may have to give unique IDs to each node in the graph.  Especially if the graph is not acyclic.
20:04:37 <wagle> that example doesnt have the shape/feel of the example i've failing to remember
20:04:47 <heatsink> ?
20:05:48 <wagle> (neural recall is by "shape" or "feel" or "similarity"
20:05:51 <wagle> )
20:06:28 <wagle> i think your example is close to what i was trying to think of, but not quite
20:06:55 <wagle> if you dont have any alternatives, dont worry about it
20:10:04 <jesse> whats wrong with HGL? its non-functional in the windows installer binaries, and now i cant get it to build from ports on bsd? or is it just me?
20:10:25 <jesse> of ghc that is
20:12:48 <gzl> has anyone noticed any differences between the text one would get from a textarea in WASH versus static text like "foo\n\nbar" that one might manually pass to some function?
20:17:24 <heatsink> Is there an efficient way to get the union of maps and identify duplicate keys?
20:19:54 <heatsink> or symmetric difference?
20:22:18 <wagle> you check okasaki?
20:22:24 <monochrom> if the keys are ordered or hashed, yes.
20:26:33 <gzl> er, never mind
20:28:51 <heatsink> I can do the symmetric difference with (union a b) \\ (intersection a b)
20:29:14 <heatsink> what's okasaki?
20:29:56 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/0521663504/qid=1112671343/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/104-1620051-1126362?v=glance&s=books&n=507846
20:30:19 <wagle> also rabhi:
20:30:22 <wagle> http://www.amazon.com/exec/obidos/tg/detail/-/0201596040/ref=pd_sim_b_4/104-1620051-1126362?%5Fencoding=UTF8&v=glance
20:31:14 <heatsink> seventy dollars?!
20:31:22 <wagle> i havent mastered haskell well enough yet to worry about efficiency, so i own the two book, but havent only lightly skimmed them
20:31:33 <wagle> wow
20:31:40 <wagle> (the $70)
20:31:53 <heatsink> looks good though, I want to see some functional graph algorithms
20:32:05 <wagle> addison-wesley usually is more reasonable
20:33:37 <wagle> s/havent/have/
20:33:46 <gzl> is in Parsec, is there any nice way of simplifying (try (string "\r\n\r\n") <|> try (string "\n\n") <|> try (string "\r\n") <|> string "\n") ?
20:33:53 <wagle> ugh..  my typing is getting worse
20:35:58 <heatsink> let nl = (string "\r\n" <|> string "\n") in try ((nl >> nl) <|> nl) -- if you don't care about what gets returned
20:37:49 <gzl> hmm
20:37:58 <gzl> yeah, i guess that's a bit nicer
20:38:02 <gzl> thanks
20:38:09 <gzl> and yeah, i don't care about the return value
20:54:46 <gzl> is there any simple way of forcing emacs to line up the = of separate functions?
20:55:42 <heatsink> you can set a minimum indentation for the =
20:56:03 <heatsink> functions with short LHS will have their = aligned
20:56:38 <heatsink> (custom-set-variables '(haskell-indent-rhs-align-column 22)
20:56:41 <heatsink> )
20:57:13 <gzl> hm, ok.
20:57:14 <gzl> thanks.
22:13:18 <heatsink> Hmm, fixpoint code is kinda messy.
22:28:59 <hellish> @seen shapr
22:29:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I haven't seen shapr
22:29:34 <hellish> lambdabot, What? Yes you have!
22:29:35 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
22:35:18 <andrei> Hi, I have a really wierd error with ghc, while trying to compile any OpenGL-related code
22:35:36 <andrei> It compiles fine, but when it gets to the linking stage
22:36:01 <andrei> It complains it can't find functions, yet they're there, I dumped the .o file that it's linking against to make sure that the functions are present
22:36:16 <andrei> Any ideas? this is on amd64
22:38:36 <andrei> http://pastebin.ca/8832
22:38:41 <andrei> For the actual error messages
22:41:05 <heatsink> andrei: did you link the libraries in the correct order?
22:41:52 <andrei> It did it automatically
22:42:01 <andrei> That's just the output from ghc -v
22:42:36 <andrei> Umm.. acutally.. never mind :p
22:42:45 <andrei> ghc --make did the trick
22:42:50 <heatsink> ok
22:42:54 <andrei> Thanks, i've only used ghci before
23:52:53 <dons> @yow
23:52:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I represent a sardine!!
23:53:23 <dons> @yow
23:53:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Uh-oh!!  I'm having TOO MUCH FUN!!
23:53:33 <desrt> @dons
23:53:34 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "dons", try "lambdabot: @listcommands"
23:53:39 <desrt> @yow
23:53:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- A wide-eyed, innocent UNICORN, poised delicately in a MEADOW filled
23:53:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- with LILACS, LOLLIPOPS & small CHILDREN at the HUSH of twilight??
23:53:43 <alex-ii> @kill
23:53:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "kill", try "lambdabot: @listcommands"
23:53:52 <alex-ii> @bash alex-ii
23:53:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "bash", try "lambdabot: @listcommands"
23:54:07 <dons> blah. jlouis will thank me for getting @yow working. he's been hacking on the code for a couple of days now.
23:54:17 <dons> and I was lazy not to install a fortunes file.
23:54:23 <alex-ii> Who?  lambdabot?
23:54:33 <desrt> math is so cool!
23:54:34 <dons> who? lambdabot?
23:55:14 <dons> alex-ii: lambdabot's @yow has been broken since he moved home. now it isn't :)
23:55:23 <alex-ii> aah
23:55:28 <alex-ii> I though, lambdabot was hacking.
23:55:48 <dons> let he = jlouis in he's hacking
23:56:00 <monochrom> haha
23:56:05 <desrt> haskell should have good support for arbitrary precision reals
23:56:11 <Gahhh> yes
23:56:26 <desrt> you should be able to write an infinite series and print it out
23:56:38 <dons> you should be able to print it out? are you sure you have enough time?
23:56:43 <desrt> and have it only eval as many terms as it needs
23:57:06 <mornfall|work> lambdabot, yow!
23:57:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:57:08 <monochrom> nevermind time. get enough paper first.
23:57:10 <desrt> have a takePlaces function or something :)
23:57:14 <Gahhh> @yow
23:57:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Hello.  I know the divorce rate among unmarried Catholic Alaskan
23:57:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- females!!
23:57:30 <Gahhh> umm, why not one line ?
23:57:40 <desrt> takePlaces 5 (infite_pi_series) == 3.14159
23:58:03 <dons> I think I can do that in 1 line... hmmm
23:58:32 <Gahhh> desrt: you dont need arbitrary precision for that tho
23:58:46 <desrt> Gahhh; s/5/5000/
23:59:14 <monochrom> For pi there is a shortcut.  O(1)-space algorithm.
23:59:37 <dons> @plugs take 35 (let g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in g(1,180,60,2))
23:59:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8]
23:59:51 <desrt> uh.  lame.
23:59:57 <dons> :P
23:59:59 <desrt> no copying from iohc
