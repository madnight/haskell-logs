00:11:04 <Oejet> Good morning.
00:15:44 <xerox> 'morning
00:18:17 <ibid> shapr: it's ISSN and i didn't say the pay rate is *directly* based on the number of publications
00:18:48 <ibid> shapr: publications, their quality, their "prestige" and their number are a contributing factor
00:19:09 * Oejet struggles with basic Russian grammar.
00:19:23 <ibid> shapr: for example, to qualify for professorship, one needs to have done and published a lot of research
00:19:56 <ibid> shapr: same for any academic job
00:20:49 <Oejet> ibid: And you have to be old to be a professor.
00:21:56 <ibid> Oejet: no, you don't
00:22:19 <ibid> Oejet: but oldness correlates with having done a lot of research :)
00:22:43 <ibid> among academians, of course
00:23:38 <Oejet> ibid: Heh, I know, but I only know very few young professors.
00:24:11 <ibid> Oejet: as i said, there is a correlation :)
01:12:32 <xerox> How is it called that feature to define selectors upon fields in a type?
01:12:54 <xerox> Err, better, to do not have to manually write those selectors.
01:52:03 <Lor> Morning, folks.
01:52:39 <xerox> jii-aah!
01:53:26 <Itkovian> @seen boegel
01:53:27 <lambdabot> I haven't seen boegel.
02:10:59 <a5> hello!
02:11:19 <xerox> Hi!
02:13:10 <a5> do people here often do term-interpreter derivations as in Hughes' pretty-printer paper?
04:00:37 <Lemmih> Good morning, #haskell.
04:01:16 <kaol> @seen morning
04:01:18 <lambdabot> I haven't seen morning.
04:01:46 <ozone> @seen my socks
04:01:47 <lambdabot> I haven't seen my.
04:01:51 <ozone> @seen my_socks
04:01:52 <lambdabot> I haven't seen my_socks.
04:15:30 <dons> @yow
04:15:31 <lambdabot> Alright, you!!  Imitate a WOUNDED SEAL pleading for a PARKING
04:15:31 <lambdabot> SPACE!!
04:16:35 <ibid> xerox: i'd call it named fields :)
04:21:37 <Lor> ibid, I take it that that was an answer to something older than two and a half hours?
04:21:57 <ibid> 11:13  <xerox> How is it called that feature to define selectors upon fields in a type?
04:22:00 <ibid> 11:13  <xerox> Err, better, to do not have to manually write those selectors.
04:22:26 <ibid> Lor: hi lor, no time long see :)
04:22:27 <ibid> err...
04:22:30 <ibid> :)
04:22:53 <Lor> Yeah, I moved and haven't had a net connection at home for two months or so.
04:23:22 <Lor> And it's been busy enough at work.
04:23:34 * Lor graduated on friday, btw.
04:24:06 <ibid> conga rats :)
04:24:25 <Lor> Thanks.
04:24:36 <ibid> Lor: how did it take so long? you had the thesis a long time ago, iirc
04:25:35 <Lor> I went to one more math exam (just to get a better grade), and it took quite a long time to get the results from that one.
04:28:00 <TFK> Good morning all
04:29:15 <ibid> Lor: oh
04:29:28 <ibid> TFK: good afternoon :)
04:29:51 <Oejet> Good afternoon also from Copenhagen.
04:29:53 <TFK> afternoon shmafternoon! Morning, I say! :-/
04:30:11 * TFK is in denial
04:30:29 <ibid> where are you, TFK?
04:30:48 <TFK> Israel
04:31:01 <ibid> isn't that +0300 too?
04:31:24 <TFK> +0200, but as I said, I'm in denial.
04:32:59 <ibid> heh
04:33:13 <ibid> no daylight saving time?
04:33:13 <Oejet> TFK: –ì–¥–µ —Ç—ã?
04:34:30 <TFK> –ù–∞ —Å–≤—è—Ç–æ–π –∑–µ–º–ª–µ —è...
04:34:49 <tuomov> ?? ??? ? ?? ?????
04:34:55 <ibid> Lor: pit√§isik√∂ meid√§n alkaa puhua vastineeksi suomea= :)
04:35:02 <ibid> tuomov: sun merkist√∂ on rikki
04:35:02 <TFK> tuomov, try UTF-8
04:35:06 <tuomov> Vallataan t√§√§ kanava!
04:35:14 <TFK> Oh my.
04:35:36 <tuomov> My irssi understands utf-8 but my terminal isn't in utf-8 because too few programs support it well
04:35:58 <TFK> Sissy programs.
04:37:18 <tuomov> so I just lots of question marks because irssi can't map all the utf-8 to latin-1
04:38:50 <tuomov> if/when jed supports utf-8 or Yi is in a usable state, I might be able to switch completely to utf-8
04:39:53 <tuomov> one of the reasons I'm looking forward to Yi is, though, that jed development has slowed down considerably
04:39:58 <Oejet> TFK: So, you say "Ha" when you are in a land?
04:39:58 * ibid has considered writing a charset-translating proxy terminal program to handle those programs
04:40:23 <ibid> so that you could say for example
04:40:31 <ibid> myprogram utf8 irssi
04:40:35 <ibid> in a latin-1 terminal
04:40:44 <ibid> or myprogram latin-1 slrn
04:40:48 <ibid> on an utf-8 terminal
04:40:54 <TFK> Oejet, yup. –ù–∞ = in. Although when applied to non-countries, it means "on", I think. –ù–∞ —Å—Ç–æ–ª–µ, –Ω–∞ —Å—Ç—É–ª–µ...
04:41:47 <TFK> Although "in a plane" = –≤ —Å–∞–º–æ–ª—ë—Ç–µ, but "in a ship" = –Ω–∞ –∫–æ—Ä–∞–±–ª–µ. Weird, innit?
04:42:37 <Oejet> TFK: I understand.  It's the same in Danish.
04:43:07 <df_> eeek, utf8 hits ther channel
04:43:14 <tuomov> No knowing exactly what you're talking about, but isn't it "on a ship" in english?
04:43:27 <TFK> Really?
04:43:47 <TFK> Yeah, I suppose you're right.
04:44:00 <tuomov> hmm.. also in finnish: "lentokoneessa" and "laivalla"
04:44:13 <tuomov> (:ssa=~in, :lla=~on)
04:44:23 <TFK> "on a plane to Reno"... so wasn't I wrong there as well?
04:44:42 <tuomov> hmm..
04:45:40 <tuomov> but you're "travelling in a plane" and "on a ship", I think
04:45:59 <tuomov> not sure, though, prepositions are complicated..
04:46:07 <tuomov> there's no consistent usage
04:46:28 <TFK> Funky. Now when I think about it, that phrase would be translated with "–Ω–∞" as well, although when you want to say you're sitting in a plane, you'd use "–≤". Oh boy... better ask you teacher and report back! o_O
04:46:42 <TFK> I wonder how my teachers managed, then.
04:48:26 <tuomov> hm.. actually, it might be that you travel on something, but you are in a plane and on a ship
04:49:06 <theorbtwo> I think tuomov may have it.
04:49:32 <vegai> you could travel on a plane
04:49:38 <vegai> you just need some ducttape
04:50:04 <theorbtwo> .oO(I'm flying, on a jetplane, don't know, when I'll be back again.)
04:50:45 <TFK> You can also travel by air, by ship.
04:50:49 <vegai> but seriously, I think there are many cases where not just one preposition is correct
04:50:58 <vegai> English is not a programming language :)
04:51:24 * TFK 's interest in Lojban reawakens
04:51:33 <tuomov> in finnish whether your "in" or "at" a city depends on the city in question..
04:51:48 <TFK> In what city are you "at"?
04:52:25 <vegai> Hyvink‰‰ => Hyvink‰‰ll‰
04:52:36 <tuomov> Tampere => Tampereella (ll=at)
04:52:42 <tuomov> Helsinki => Helsingiss√§ (ss√§=in)
04:52:54 <vegai> yep, there indeed is no rule :)
04:53:06 <vegai> that must suck for foreigners learning Finnish
04:53:27 <tuomov> There was somewhere a huge list of all the municipalities
04:53:53 <tuomov> Most foreign places are ssa/ss√§ I think
04:54:38 <TFK> Funky...
04:57:36 <theorbtwo> In English, most cities don't take a definite article -- except for the Hauge.
04:57:52 <TFK> Hauge?
04:57:55 <tuomov> finnish doesn't have the distinction definite/indefinite
04:57:58 <tuomov> hague?
04:58:21 <theorbtwo> Quite possibly Hague; my spelling is atrocious.
04:58:48 <TFK> heh
04:59:27 <vegai> the Vatican or Vatican?
04:59:50 <theorbtwo> the Vatican.  Forgot that one, though I tend to think of it more as a country then a city.
05:00:09 <vegai> wikipedia says "The State of the Vatican City"
05:00:10 * kaol loves to know a language that you can scare small children with. Mmm, haskell. Wait, no...
05:00:11 <theorbtwo> Most countries don't take a def. article either, but the Vatican and the Netherlands do.
05:00:13 <tuomov> maybe it's used to emphasise a particular place with that name?
05:01:07 <theorbtwo> No, tumov, it's always "York" and not "the York", even though there are a fair number of different cities around the world named York.
05:01:45 <tuomov> but none are much more significant than the other?
05:03:15 <GunZ> hey guys what is the difference between a .hs and .lhs file?
05:03:59 <TFK> You think Haskell would scare small children? Try C++...
05:04:01 <theorbtwo> .lhs is "literate haskell"; it's a mixture of documentation (in LaTeX), and code (beginning with "> ").
05:04:03 <TFK> Or APL o_O
05:04:39 <GunZ> theorbtwo: ahh ok thx
05:05:38 <theorbtwo> That's all very IIRC; I've never used the Literate sort.
05:06:04 * kaol was referring to the fact that he was from .fi too. But never mind.
05:08:08 <TFK> oh ^_^;
05:13:30 <xerox> ibid, can you point me to some doc about them? I don't recall the syntax.
05:14:20 <JaffaCake> is dcoutts(_?) around?
05:14:36 <kaol> @seen dcoutts
05:14:37 <lambdabot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
05:14:44 <kaol> @seen dcoutts_
05:14:45 <lambdabot> dcoutts_ is in #haskell. I don't know when dcoutts_ last spoke.
05:17:29 <dcoutts_> kaol, hia
05:17:54 <dcoutts_> oh JaffaCake I was just about to ask you something...
05:17:58 <xerox> Or even, does anybody know where the doc about named fields is ?
05:18:05 <JaffaCake> hi dcoutts_
05:18:29 <dcoutts_> JaffaCake, did you have a Q or shall I go first?
05:18:39 <JaffaCake> I've just committed a fix that might fix your gtk build crash
05:18:47 <dcoutts_> oooh! :-)
05:19:09 <JaffaCake> if you could build STABLE with the fix, and let me know, that would be great
05:19:11 <dcoutts_> what was wrong do you think? (and which ghc branch do I check out to test the fix?)
05:19:21 <JaffaCake> ghc-6-4-branch
05:19:23 <dcoutts_> ok, STABLE
05:19:39 <JaffaCake> the commit message has the details
05:19:58 <dcoutts_> ghc-6-4-branch or STABLE ? or are they the same
05:20:03 <JaffaCake> I'm not certain, because I still haven't repro'd it
05:20:09 <JaffaCake> they're the same
05:20:12 <dcoutts_> ok
05:23:49 <bourbaki> moin
05:24:09 <dcoutts_> my Q was, would it be possible for ghc to pass the -optc flags to gcc when it is doing the .S -> .o bit?
05:27:09 <dcoutts_> We have a problem on sparc where you say: ghc -c foo.c -optc-mcpu=ultrasparc  and this does not work because ghc only passes -mcpu=ultraspace to gcc when doing the .c -> .S part and so gcc generates ultrasparc assembly instructions but when it invokes gcc to do the assembling it omits the -mcpu=ultraspace and so the assembler complains that the .S file contains instructions that are not appropriate to the arch version
05:27:38 <TFK> Hmm. Can I say create a new function by currying alone to say something like, "greater or equal to five and less than 10"?
05:28:11 <tromp> sure
05:28:19 <Lor> You can create any  function by currying alone.
05:28:23 <dcoutts_> I beleve that gcc will simply ignore flags that are not relevant to the assmeply phase so it should be safe to pass all -optc flags to gcc when doing the assembling
05:28:25 <TFK> Really?
05:28:54 <Lor> Pretty much, yeah.
05:29:10 <Lor> In principle, the S and K combinators alone suffice for everything.
05:29:23 <TFK> Dunno what those are but,
05:29:28 <ozone> dcoutts_: is there an equivalent optS flag?
05:29:37 <ozone> (i guess not, from how you phrased things)
05:29:37 <dcoutts_> JaffaCake, I should file a bug report about this really (just wondering if you agree if its a ghc bug or if using ghc to compile .c files it not the thing to do)
05:29:46 <TFK> ((&&) (>=5) (<10)) <-- didn't quite work, and I'm not sure why. I can't quite figure out how to make non-trivial functions by currying.
05:29:50 <JaffaCake> dcoutts_: just reading up, hang on
05:30:01 <TFK> Hmmm.
05:30:10 <TFK> ah, worked!
05:30:14 <tromp> inrange (5,9)
05:30:23 <dcoutts_> ozone, there is a thing to pass flags to the linker and maybe even the assembler but that doesn't help since we don't know which flags are for which phase
05:30:28 <TFK> I'm trying to make my life a bit harder now
05:30:56 <JaffaCake> dcoutts_: you can't use -opta?
05:31:04 <dcoutts_> we just get a set of CFLAGS that are appropriate to the platform, if we say gcc $(CFLAGS) -c foo.c then it works
05:31:12 <dcoutts_> if we say ghc $(CFLAGS) -c foo.c then it does not work
05:31:22 <JaffaCake> ah, I see
05:31:36 <TFK> ((&&) ((>=5) (<=10))) <--- doesn't really work, too. I'm getting "unresolved overloading" when trying to filter a list with it.
05:31:52 <TFK> Hmmm.
05:31:54 <tromp> && doesn't work on functions
05:32:09 <JaffaCake> I don't think ghc $(CFLAGS) should work in general
05:32:11 <TFK> Isn't it a function in itself?
05:32:26 <tromp> it's a function on bools
05:32:35 <dcoutts_> so either ghc could invoke gcc one to do .c directly to .o (without intermediate .S) or pass -optc flags to gcc when doing assembling
05:32:42 <TFK> Yes.
05:33:03 <dcoutts_> sorry, I mean ghc $(addprefix -optc,$(CFLAGS))
05:33:08 <JaffaCake> right
05:33:21 <TFK> But it passed the type check, although maybe hugs doesn't spot these errors off the bat.
05:33:34 <JaffaCake> so then you could just ghc $(addprefix -optc,$(CFLAGS)) $(addprefix -opta,$(CFLAGS)) $(addprefix -optl,$(CFLAGS))
05:33:39 <JaffaCake> no?
05:33:40 <dcoutts_> this is what darcs does for all its .c files (and hence does not compile on sparc)
05:34:19 <dcoutts_> I could modify the darcs makefiles to do this, right but I was wondering if there was a better fix that work work in general for this situation
05:34:47 <JaffaCake> the problem is, I'm not sure whether adding the optc flags to the assembler pass might break something else
05:34:58 <Igloo> dcoutts_: sparc/Linux or sparc/Solaris?
05:35:04 <JaffaCake> at the moment, we have the maximum flexibility
05:35:09 <dcoutts_> Igloo, sparc/Linux
05:35:32 <JaffaCake> but if you added optc flags to the assembler, there'd be no way to pass a flag just to the .c->.S phase
05:35:36 <dcoutts_> JaffaCake, is there any need to do the .c -> .o going via .S ?
05:35:57 <Igloo> Is -mcpu=ultraspace essentially the same as either "32 bit" or "64 bit"?
05:36:00 <JaffaCake> no, it just makes the internals a bit easier
05:36:44 <Igloo> JaffaCake: It's not necessary to do the evil mangling?
05:36:53 <JaffaCake> not on plain .c, no
05:37:15 <JaffaCake> the evil mangler doesn't get its grubby fingers on innocent .c files :)
05:37:17 <shapr> swiert: Greetings! Do you think your article will be ready by the first?
05:37:25 <dcoutts_> Igloo, it's not quite the same, it selects the processor generation (I believe that getting the wrong generation can make all the code go via slow emulation)
05:37:29 <Igloo> Oh, duh
05:37:35 <theorbtwo> Is there a better way to write concatMap (\x -> case x of {'.' -> "/"; c -> [c]}) human ?
05:37:37 <ibid> xerox: do you still need to know? :)
05:37:46 <swiert> shapr: Hi - I got you're e-mail. I'll try to have everything ready by the first.
05:37:51 <theorbtwo> That is, take the string human, and change dots to slashes.
05:37:56 <xerox> ibid, I do :-)
05:38:24 <shapr> swiert: Excellent. If you put your interim content into the wiki, it's likely you'll get grammar fixes and useful comments from other authors.
05:38:43 <shapr> At least, that's the hope with the wikipublishing experiment.
05:38:44 <Igloo> dcoutts_: So is the flag actually necessary?
05:39:05 <swiert> I just created a wiki page this morning.
05:39:08 <tromp> do c<-str; return $ if c=='.' then '/' else c
05:39:10 <ibid> xerox: i learned them from the report, sorry :)
05:39:21 <dcoutts_> JaffaCake, I believe that gcc will ignore any flags that are not appropriate to the assembly phase but I've not found a definitive statement of this
05:39:35 <chr1s> TFK: filter (\x -> (X>=5) && (x<10))
05:39:45 <Igloo> dcoutts_: Assuming you're talking about Gentoo, can't you just set teh C compiler to include that flag when building ghc on an ultrasparc?
05:40:00 <dcoutts_> Igloo, I believe so (or pretty much necessary) let me find the email...
05:40:52 <JaffaCake> dcoutts_: that's probably true, but I still have a slightly uneasy feeling about making that change
05:41:05 <Igloo> Hmm, OK. I've never heard anything about this WRT Debian (but we do build all packages in linux32, I believe)
05:41:05 <JaffaCake> 1. it means adding a special case
05:41:19 <JaffaCake> 2. it means you can't pass flags only to the .c->.S phase
05:42:08 <JaffaCake> (unless we added another flag to do that)
05:42:29 <_JusSx_> of course you can
05:42:31 <dcoutts_> Igloo, here we are: http://dev.gentoo.org/~ciaranm/docs/rants-to-dev/cflags.txt
05:42:34 <_JusSx_> of course you can
05:42:35 <_JusSx_> of course you can
05:42:58 <TFK> chr1s, yes, but I want to do it with currying alone.
05:42:58 <shapr> _JusSx_: I think your irc client got hung up in a scratch on that record.
05:43:23 <TheHunter> TFK, import Control.Monad.Reader, then liftM2 (&&) (>=4) (<3) will work.
05:43:40 <_JusSx_> shapr: it's my keyboard
05:43:44 <TFK> Can I do it without importing funky modules?
05:44:00 <chr1s> you want to take a list of ints and check if they're all 5<=x<10
05:44:04 <xerox> ibid, oh :) OK, thanks anyway.
05:44:07 <TFK> I can't quite figure out how to use the same parameter in two different parts of the function, basically, without naming it.
05:44:13 <dcoutts_> JaffaCake, I see your concern. I was just wondering if you thought ghc should be able to work in place of gcc for compiling .c files or if we should tell darcs upstream to use gcc instead
05:44:25 <chr1s> TFK: don't know if it's possible
05:44:44 <chr1s> you can do this to check it for one int: (\x -> (x>=5) && (x<10))
05:44:45 <TFK> Hence my earlier question, can every function be expressed by currying alone of other functions :-)
05:44:57 <chr1s> but that's with ->
05:44:58 <TFK> Well yes, that's a lambda, and surely enough it'll work.
05:45:09 <JaffaCake> my view on this is that ghc should be just like gcc except that it adds -I flags to get at GHC's include files
05:45:13 <chr1s> I don't think it's possible
05:45:26 <chr1s> but I'm not a haskell-expert
05:46:23 <TheHunter> TFK, there are no prelude functions that give you the S combinator in an easy way, therefore you can't really do it pointfree without importing stuff.
05:46:25 <Igloo> dcoutts_: Fair enough. I don't know what stuff gets emulated to know if it's a real problem or not, but anyway it sounds like having the flags baked into ghc on a v9 sparc would be the way to go
05:46:49 <dcoutts_> and the point there is that gcc does pass on the appropriate things when it does the .c -> .S -> .o all in one go. Of course if as the user you split that into .c -> .S, .S -> .c then you have to pass the right options to gcc again
05:47:32 <JaffaCake> yes
05:47:44 * JaffaCake scratches his chin a bit
05:48:05 <dcoutts_> Igloo, we should think about that. Though it means that if the user changes their CFLAGS it will not get updated in ghc
05:48:34 <TFK> TheHunter, oh, OK then, thanks.
05:49:33 <JaffaCake> dcoutts_: ok, we can give it a go.  If anyone complains, we can add another flag.
05:49:43 <dcoutts_> perhaps, ghc should work in the same way, if you use ghc to go .c -> .S -> .o all in one go then you cannot specify different options for the .S -> .o phase
05:50:03 <dcoutts_> though you can specify extra options via -opta ?
05:50:51 <Igloo> It would be easy enough to fix darcs so it added $(addprefix -opta,$(CFLAGS)) as well as $(addprefix -optc,$(CFLAGS)) to the commandline, FWIW
05:50:54 <JaffaCake> the simplest meaning is just this:  -optc adds flags to -opta too
05:51:15 <JaffaCake> (but what about -optl?)
05:51:23 <dcoutts_> if the -opta options come after the -optc ones then they override which effectively gives you the ability to specify different flags for the .S -> .o phase (the differenc ebeing thet the .S -> .o phase inherits the default flags from the .c -> .S phase)
05:51:56 <dcoutts_> Igloo, sure it would, I was just wondering if it was the "Right Thing" to fix
05:52:05 * Igloo thinks it is
05:52:20 <dcoutts_> Igloo, in the short term I'll hack the darcs makefile to do just that
05:53:53 <dcoutts_> JaffaCake, "-optc adds flags to -opta" yes, I agree with the -opta ones overriding the -optc ones (you don't have to do this explicity since gcc will to that itself, later options overried earlier ones - at least I think it was that way arround!)
05:54:14 <TheHunter> @pl filter (\x -> (X>=5) && (x<10))
05:54:14 <thbot> filter ((X >= 5 `&&`) . (< 10))
05:54:15 <lambdabot> filter ((X >= 5 `&&`) . (< 10))
05:54:21 <TheHunter> @pl filter (\x -> (x>=5) && (x<10))
05:54:22 <thbot> filter (liftM2 && (>= 5) (< 10))
05:54:22 <lambdabot> filter (s (&& . (>= 5)) (< 10))
05:56:33 <dcoutts_> JaffaCake, "but what about -optl?"  you could do the same and have the -optl be passed in addition to the -optc ones or keep the existing behaviour of dropping all -optc flags for the link phase. There are some gcc flags that affect both compilation and link phases, eg -pthreads on some arches springs to mind
05:56:55 * JaffaCake nods
05:58:01 <dcoutts_> JaffaCake, I'll send a propper bug report then since this is not obviously not-a-bug :-)
05:58:10 * TFK tried to wiki/google S combinators but that didn't yield anything useful :-(
05:58:17 <JaffaCake> heh
05:58:23 <TheHunter> @get-definition S
05:58:24 <lambdabot> S = \f g x.f x (g x)
05:58:53 <TFK> O_O
05:59:09 <TheHunter> it's something different from what you wanted, but equivalent, in a sense.
05:59:13 <Oejet> shapr: How do I mark up LaTeX in the Wiki?
05:59:26 <TFK> What's the \ doing there?
05:59:42 <Itkovian_> TFK: that's a lambda expression definiton
05:59:50 <TFK> Where's the ->, then?
05:59:51 <smott> S f g x = f x (g x)
05:59:57 <Itkovian_> as in lambda x y z . x z ( y z )
06:00:20 <TFK> . is still function combination, right?
06:00:39 <xerox> @wiki HelpOnFormatting
06:00:39 <lambdabot> http://www.haskell.org/hawiki/HelpOnFormatting
06:00:46 <xerox> Oejet, there you go!
06:00:57 <Itkovian> @type \x y z -> x z ( y z )
06:01:02 <lambdabot> \x y z -> x z ( y z ) :: forall t t1 t2.
06:01:02 <lambdabot>                          (t2 -> t -> t1) -> (t2 -> t) -> t2 ->
06:01:02 <lambdabot> t1
06:01:56 <Oejet> xerox: Thanks!
06:02:31 <xerox> YW!
06:02:37 <TFK> Hmm.
06:03:25 <xerox> TFK, lambda calculs' . is Haskell's ->
06:03:35 <TFK> I figured that, but thanks.
06:43:47 <xerox> ibid, OK, it passed enough time for the next question (heh) - where are those in the report?
06:52:53 <ibid> xerox: "labelled fields" under 4.2.1
06:54:02 <theorbtwo> Does anyone know where I can find a complete example of the use of the State monad?
06:55:21 <theorbtwo> I'm trying to convert a modToDot' :: String -> IO String into one that is gaurenteed to only run once per input, and return "" after that.
07:00:03 <bourbaki> does anyone of you use Subethaedit?
07:00:45 <ozone> does using ghc -O imply -funbox-strict-fields?
07:01:31 <ibid> shapr: what would you say if i offered to write a literate program for tmr? :)  (based on the no-literate draft at http://kaijanaho.info/tmp/VoteCount.hs)
07:21:21 <xerox> ibid, thanks! So, it does have something in common with the word "record" I was remembering.
07:21:45 <shapr> ibid: I think it'd be cool,
07:22:55 <shapr> ibid: You could explain the goal, interim steps, what worked and what didn't, and why you ended up with what you have. That would be helpful for people learning Haskell. Was that the sort of literate program you were considering?
07:25:25 <ibid> shapr: perhaps :)
07:28:50 <shapr> nibro_afk: want to write about HSP for TMR2? :-)
07:29:06 <shapr> Let's see, I think I've picked on just about everybody now.
07:29:27 <shapr> Anybody I missed? Anybody wants to volunteer for a TMR2 article?
07:30:42 <TFK> how many people have you got so far?
07:32:24 <shapr> 14 possible articles, but no idea how many will actually be ready by the first.
07:34:55 <ibid> shapr: when's the deadline?
07:35:48 <xerox> ibid, May the first.
07:36:16 <ibid> i may not be that fast, shapr :)
08:04:18 <xerox> What does exactly mean ``modulo'' in "m is added to function results (modulo currying)" on the page <http://www.haskell.org/onlinelibrary/monad.html> ?
08:07:24 <Lor> sort of "when ignoring"
08:07:48 <xerox> I see, thanks.
08:09:09 <SamB> @listcommands dict
08:09:10 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements
08:09:10 <lambdabot> foldoc gazetteer hitchcock jargon lojban prelude vera web1913
08:09:10 <lambdabot> wn world02
08:09:19 <SamB> @jargon modulo
08:09:22 <lambdabot> *** "modulo" jargon "Jargon File (4.3.1, 29 Jun 2001)"
08:09:22 <lambdabot> modulo /mod'yu-loh/ prep. Except for. An overgeneralization of
08:09:22 <lambdabot> mathematical terminology; one can consider saying that 4 equals
08:09:22 <lambdabot> 22
08:09:22 <lambdabot>    except for the 9s (4 = 22 mod 9). "Well, LISP seems to work
08:09:22 <lambdabot> okay now,
08:09:24 <lambdabot>    modulo that {GC} bug." "I feel fine today modulo a slight headache.
08:09:26 <lambdabot> "
08:13:49 * Lemmih finally got Hackage to show pkg versions nicely.
08:27:30 <shapr> dbremner: Truly this is an inspirational talk.
08:28:14 <shapr> Let me reiterate for those who didn't see it yesterday. If you want to do great research, this advice is for you - http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
08:39:45 <mwelsh> what channel is appropriate for asking questions about the RSA algorithm?
08:41:00 <Lor> Apparently a channel named #crypto exists.
08:41:13 <mwelsh> thanks
08:41:19 <Lor> Of course it could be about Superman's dog instead of cryptography.
08:41:23 * TFK bookmarks "You and your Research"
08:41:27 <shapr> He had a dog named crypto?
08:41:39 <Lor> Ah, sorry, that was "Krypto".
08:41:39 <shapr> TFK: Read it first! Bookmark after!
08:41:50 <TFK> I have many, many things to read!
08:41:55 <TFK> And even more things to write >_<
08:41:58 <shapr> Lor: oh right, kryptonography.
08:42:15 <TFK> I think I said I was being torn apart by indicisiveness o_O
08:42:21 <shapr> Read faster =)
08:42:23 <shapr> write faster
08:42:44 <shapr> In fact, get off IRC for a part of each workday
08:42:45 * TFK recalls the Red Bull advertisements
08:43:03 <TFK> Yeah, but there's always something in the way. grr
08:52:18 <df_> @eval randomR (False,True) (mkStdGen 4354)
08:52:20 <lambdabot> (line 1, column 15):
08:52:20 <lambdabot> unexpected ","
08:52:20 <lambdabot> expecting end of "False", operator, simple term or ")"
08:53:09 <df_> TFK :: flip a coin, its a wonderful way to solve indicisiveness
08:53:24 <TFK> Coins, noted.
08:53:37 <df_> if you find that you were wanting the other option to happen, then do the other option
08:54:05 <TFK> Ha, fair enough
09:06:49 <basti_> hi
09:06:54 <Lemmih> Hey
09:07:48 * basti_ will upload his tmr2 article now.
09:09:26 <basti_> hm.
09:12:02 <basti_> so how does that latex support work? =)
09:18:28 <funboy765> well
09:18:31 <funboy765> hello folks
09:18:43 <funboy765> so what kinda apps can I make with haskell
09:18:45 <funboy765> ?
09:19:09 <Palle> funboy765, what you can do in all other programming language
09:19:36 <basti_> its turing complete.
09:31:27 <jlouis> what people said
09:37:50 <funboy765> hey is there a haskell IRC client
09:37:51 <funboy765> ?
09:38:18 <TFK> http://haskell.org/hircules/ <--- oh my...
09:38:19 * basti_ coughs
09:38:39 <TFK> Looks pretty old, though...
09:40:43 <mwelsh> what is the easiest way to take the sqrt of an Integer?
09:41:03 <Igloo> sqrt . fromIntegral
09:41:32 <mwelsh> thanks
09:45:28 <dcoutts_> TFK, I think wli was looking to update it, I was helping him build the cvs version of gtk2hs (******* autotools).
09:49:43 <mwelsh> for taking powers of larger values (i.e. 405^14), wouldnt it calculate faster to take the product of each factor of the base to that power?
09:49:51 <mwelsh> fasterPow :: Integer -> Integer -> Integer
09:49:52 <mwelsh> fasterPow x exp = product (map (\n -> n^exp) (factor x))
09:49:54 <mwelsh> like that?
09:51:08 <TFK> How are you going to efficiently factor numbers?
09:51:17 <mwelsh> well, i dont know about efficiently
09:51:34 <mwelsh> but i have a function that does it
09:51:41 <TFK> Factorizes numbers?
09:51:41 <df_> i still see n multiplies in there
09:52:00 <mwelsh> TFK: yes
09:52:22 <TFK> I don't see how it can be remotely better if you're not going to come up with an efficient way to factorize numbers, and afaik, they haven't been found yet (or don't exist at all?)
09:54:09 <df_> ignore that, /me missread expression
09:58:19 <sjanssen> mwelsh: Your idea is somewhat similar to binary exponentation, which does Theta(log n) multiplies
09:58:54 <mwelsh> does it perform better than standard exponentiation?
09:59:52 <mwelsh> once again, if there is a better way to factor it...
09:59:58 <sjanssen> mwelsh: yes, especially for large exponents, the naive way is linear, the binary exponentation method is log based
10:00:43 <mwelsh> sjanssen: is there an already existing implementation of it for haskell?
10:02:54 <sjanssen> mwelsh: http://www.cs.bris.ac.uk/Teaching/Resources/COMS12100/lectures/9-complexity/complexity8.pdf try page 4 of those lecture slides
10:03:04 <mwelsh> thanks
10:03:08 <Lemmih> SyntaxNinja: Hiya.
10:08:15 <SyntaxNinja> hey
10:09:21 <_JusSx_> bored
10:09:42 <basti_> can anyone tell me how this latex support in the tmr2 wiki is supposed to work?
10:09:44 <basti_> "by hand"?
10:12:09 <mwelsh> is there a way to measure the execution time of a haskell program (other than with a stopwatch)?
10:13:05 <Lemmih> 'time ./your-binary-here'?
10:13:05 <df_> compile it, run it as time foo (requires unix)
10:13:38 <df_> i believe ghci provides some form of timing information too
10:13:44 <mwelsh> df_ thanks!
10:13:54 <mwelsh> i wish i knew about that during school
10:30:33 <Banedon> how do i set my path on windows xp?
10:30:43 <Banedon> I installed ghc but its asking me to set the path
10:30:45 <Banedon> ?
10:30:46 <Banedon> anyone
10:30:47 <Banedon> ?
10:30:56 <TFK> Hold on.
10:31:06 <smott> system, environmental variables
10:31:19 <TFK> Right click on My Computer; choose Properties -> Advanced -> Environmental Variables
10:31:33 <TFK> Under system variables there will be a Path variable; end ghc's path to the end of it.
10:31:39 <SyntaxNinja> Banedon: you should give people a chance to answer
10:43:46 <Oejet> Mmm, quiet.
10:44:26 <Muad_Dibber> Yeah, hush.
10:44:34 <SyntaxNinja> :
10:44:36 <SyntaxNinja> )
10:45:43 * TFK drops a pin
10:46:08 * SyntaxNinja uses ninja skills to catch it, silently, before it hits the ground
10:47:15 * TFK wonders if he'll hear the sound only five minutes after the fact, and then suddenly a bunch of orcs will come barging in a la LotR
10:48:18 * Oejet –≥–æ–≤–æ—Ä—é –ø–æ —Ä—É—Å—Å–∫–∏.
10:48:38 <SyntaxNinja> Niet!
10:49:03 <Oejet> SyntaxNinja: Pashalusta.
10:50:17 <TFK> Acutally, that should be –≥–æ–≤–æ—Ä–∏—Ç, since you're refering to yourself in third-person.
10:50:46 <Oejet> TFK: Doh.  Good point.
10:51:11 <TFK> On the bright side, Russian has only three tenses.
10:53:05 <Oejet> And six casus(abc?): Nominativ, akkusativ, genitiv, dativ, instrumentalis and lokativ.
10:53:50 <TFK> A-what?!
10:56:22 <Oejet> Six cases.
10:57:35 * TFK will pretend to know about those :D
11:45:33 <jlouis> 2 secs, need to enable UTF-8
11:45:46 <jlouis> heeh
11:52:48 <TFK> Is it just me or is the mvLift2 as defined in Gentle is zipWith?
11:53:45 <derelm> i have a do block, where i want to assign a String to a variable and print that, but i get a type error about couldn't match IO against []. i am a bit lost here
11:54:18 <Lemmih> 'let s = "hello world" in putStrLn s' ?
11:55:28 <derelm> it's more like `var1 <- processInput myinput; print var1`
11:55:39 <TFK> What's processInput?
11:56:01 <SyntaxNinja> derelm: unless processInput is in the monad, then you son't want to use "<-" you want to use let instead
11:56:14 <SyntaxNinja> that is, use let for pure functions "let var1 = processInput"
11:56:32 <TFK> What do you mean, "in the monad"?
11:56:37 <derelm> ah, ok, i'll try that
11:56:54 <derelm> SyntaxNinja: err, it's in the monad (do block)
11:57:05 <SyntaxNinja> TFK: what's the type of processInput
11:57:21 <TFK> Dunno, that's what I asked derelm
11:57:21 <derelm> mompl
11:57:23 <TFK> (kinda)
11:57:39 <SyntaxNinja> processInput itself is either monadic or not, reguardless of where it comes in the code.
11:57:45 <SyntaxNinja> tfk: sorry, I meant to ask derelm
11:58:11 <TFK> If it's not monadic, you can do: var1 <- return $ processInput myinput; print var1
11:58:12 <derelm> hmm, it should be Result -> String
11:58:28 <SyntaxNinja> derelm: in that case, it's "pure", and you can use let, as Lemmih said
11:58:40 <TFK> Is let considered better than return $ ?
11:58:41 <SyntaxNinja> only use <- for types like "Result -> IO String" or "IO String"
11:58:53 <SyntaxNinja> TFK: I think it's better.
11:59:08 <TFK> Hmm, OK
11:59:10 <SyntaxNinja> it's a matter of style, I guess.
11:59:12 <derelm> so, i should use let instead?
11:59:23 <SyntaxNinja> or you don't have to use the let at all, you can just say "print (processInput my input)"
11:59:27 <SyntaxNinja> derelm: yeah
11:59:28 * SyntaxNinja lunch &
12:01:11 <derelm> i can't use let inside a do block right?
12:01:20 <basti_> yes you can.
12:01:33 <basti_> just in the "in" clause you don't "do" anymore
12:01:48 <derelm> i'll see if that works ..
12:12:44 <Lemmih> @plugs do let {x = 'c'}; return x :: [Char]
12:12:45 <lambdabot> "c"
12:13:01 <H0lyD4wg> [newbie question] how is it that [] :: [a] forall a ?
12:13:06 <Lemmih> Greetings, RemiTurk.
12:13:48 <Lemmih> @type []
12:13:49 <lambdabot> [] :: forall a. [a]
12:14:02 <RemiTurk> hi Lemmih
12:14:06 <RemiTurk> and the rest of you ;)
12:16:01 <H0lyD4wg> i know that it is so, but how is it possible?
12:16:35 <gzl> isn't it kind of intuitive?
12:17:00 <gzl> you need some notion of empty list for lists of any type
12:17:00 <dcoutts_> H0lyD4wg, you can think of it in two ways (which ever makes more sense to you): for every type of list there is an end of list value which we write [], or you can think of it as there being a single end of list value but you can use it with a list of any type
12:17:41 <gzl> it seems very odd to think of [] as an end of list value
12:18:02 <gzl> how is it an end of list value?
12:18:06 <Lemmih> @plugs 'a':'b':'c':[]
12:18:09 <lambdabot> "abc"
12:18:28 <H0lyD4wg> ah! there are multiple []s!
12:18:29 <gzl> you're concatenating those on, it's not the end of the list
12:18:56 <dcoutts_> so you can either believe that there are many empty list values and that "[]" is overloaded for each one, or that there is a single emtpy list value but it has a "generic" type (we would call it polymorphic rather than generic)
12:18:58 <gzl> there's one [], it's just polymorphic
12:19:32 <H0lyD4wg> there are multiple. 1:(tail "f") gives me a type error.
12:19:48 <gzl> Lemmih: in that notation, it appears at the end, but it still seems weird to call it an end of list value. you're just concatenating those things
12:19:55 <H0lyD4wg> (i think it's a type error, not sure.)
12:20:16 <dcoutts_> gzl, I think you can take either perspective, it depends on what you think about types/values
12:20:59 <gzl> H0lyD4wg: well, yeah, because (tail "f") :: [Char] and 1 isn't a Char
12:21:59 <dcoutts_> if you come from an untyped language then its easy to see that there is just a single value but you use it in different type contexts
12:22:05 <H0lyD4wg> but (tail "f") is [], isn't it?
12:22:41 * H0lyD4wg is trying to figure out how typing works
12:22:44 <gzl> H0lyD4wg: it happens to be, but (tail s) where s :: [Char] yields a [Char], so the typechecker still sees a mismatch
12:23:33 <dcoutts_> but if you've been doing a lot of coding in a typed language it is sometimes more helpful to believe that the type is a fundamental property of a value (since you can do all sorts of type class things to distinguish 'equal' values of different types)
12:23:34 <gzl> you can't do 1:"" either; "" is isomorphic to [] but "" :: [Char] still
12:26:11 <H0lyD4wg> (+):(tail [1]) gives me the same error as 1:(tail "f") . so i think there are multiple []s and they just look alike.
12:26:37 <arjanb> @type tail
12:26:38 <lambdabot> tail :: forall a. [a] -> [a]
12:27:37 <xerox> @plugs 1:(tail [1])
12:27:38 <lambdabot> [1]
12:28:18 <Lemmih> H0lyD4wg: Overloading is pretty common in Haskell.
12:28:43 <gzl> H0lyD4wg: um
12:29:03 <gzl> H0lyD4wg: (+) is a function, and [1] :: [Num], so that makes no sense for the same reason as before
12:30:43 <H0lyD4wg> gzl, actually, that makes perfect sense. there's a [] for [Num] and a separate one for Num a => [a -> a -> a]
12:33:15 * RemiTurk proves there is Only One True Empty List
12:33:26 <RemiTurk> Prelude> :m +Foreign
12:33:26 <RemiTurk> Prelude Foreign> a <- newStablePtr ()
12:33:26 <RemiTurk> Prelude Foreign> b <- newStablePtr ([] :: [Int])
12:33:26 <RemiTurk> Prelude Foreign> c <- newStablePtr ([] :: [Int])
12:33:26 <RemiTurk> Prelude Foreign> d <- newStablePtr ([] :: [Char])
12:33:27 <RemiTurk> Prelude Foreign> castStablePtrToPtr a == castStablePtrToPtr b
12:33:29 <RemiTurk> False
12:33:31 <RemiTurk> Prelude Foreign> castStablePtrToPtr b == castStablePtrToPtr c
12:33:33 <RemiTurk> True
12:33:35 <RemiTurk> Prelude Foreign> castStablePtrToPtr b == castStablePtrToPtr d
12:33:37 <RemiTurk> True
12:33:39 <RemiTurk> (proof by intimidation)
12:34:51 <H0lyD4wg> what exactly does that prove?
12:35:13 <Lemmih> That []::[Int] and []::[Char] is the same thing.
12:37:36 * RemiTurk cannot even found anything about instance Eq (StablePtr a) in the manual... ;)
12:38:13 <H0lyD4wg> if they were truely one and the same 1:"" wouldn't be an error.
12:38:30 <RemiTurk> I don't think that's necessarily true
12:38:38 <RemiTurk> types (usually) don't exist at runtime in haskell
12:38:57 <RemiTurk> (except for existentials, foralls etc)
12:39:02 <Lemmih> You gotta understand the difference between values and types.
12:40:01 <RemiTurk> so 1:"" might actually (in some sort of distorted way) be said to be "valid" at runtime. fortunately, the typechecker prevents us from doing such evil things
12:40:18 <gzl> H0lyD4wg: [] is polymorphic, but it can get instantiated with certain more specific types in certain situations. "" is one of them
12:40:21 * RemiTurk goes looking for unsafeCoerce :)
12:41:22 <Lemmih> 'c':unsafeCoerce# (tail [False])
12:41:22 <Lemmih> "c"
12:41:28 <Lemmih> Bwhaha (:
12:41:46 <RemiTurk> :)
12:41:51 <gzl> what's with the #?
12:41:57 <RemiTurk> Q.E.D. :D
12:42:27 <xerox> @index unsafeCoerce#
12:42:28 <lambdabot> bzzt
12:42:32 <Lemmih> gzl: That's because it's a GHC prim op, iirc.
12:42:33 <xerox> @index unsafeCoerce
12:42:33 <lambdabot> bzzt
12:42:37 <Oejet> gzl: It marks internal functions in GHC.
12:42:37 <gzl> ah, I see
12:42:50 <RemiTurk> the # usually means (in GHC) that it's either a primitive or works with unboxed types (and, quite often, both)
12:42:52 * Oejet is too slow.
12:42:54 <RemiTurk> IIRC
12:43:30 <basti_> <
12:43:39 <RemiTurk> (you'll need to start ghci with -fglasgow-exts and import GHC.Exts)
12:43:47 <Lemmih> 'c':unsafeCoerce# ([False])
12:43:47 <Lemmih> "cSegmentation fault
12:43:54 <RemiTurk> (and make sure you have enough disk-quota for the core file :))
12:44:08 <RemiTurk> has that one here too...
12:44:13 <H0lyD4wg>  (\x -> (1:(x 1),'f':(x 1)))(\x -> []) gives an error. does that mean that [] is always instantiated and never used as-is?
12:44:16 <basti_> seen shapr
12:44:28 <Lemmih> unsafeCoerce# is the king of all evil.
12:44:30 <basti_> whats up with shapr? is his fiancee in heat or something?
12:44:52 * RemiTurk mumbles something about impredicate types and looks very strange out of his eyes
12:45:22 * RemiTurk throws a cool type at shapr
12:46:07 <gzl> H0lyD4wg: no, it's because you're doing both at the same time.
12:46:27 <sellingMyCamry90> hi haskellers
12:46:38 <basti_> hi sellingMyCamry.
12:46:41 <basti_> whats a camry?
12:46:41 <RemiTurk> hi sellingmy
12:46:45 <Oejet> sellingMyCamry90: Hello.
12:46:47 <tromp> a car
12:46:56 <tromp> toyota
12:47:02 <basti_> ahh.
12:47:10 <basti_> maybe it has a different name in europe
12:47:11 <derelm> hGetContents closes my socket, can i prevent it from doing so, as i want to transmit data after reading from the socket?
12:47:20 <H0lyD4wg> gzl, what is the thing that i don't understand but need ot?
12:47:43 <RemiTurk> you could perhaps try some dup-ing?
12:47:47 * RemiTurk isn't sure at all
12:47:52 <gzl> i think the main thing is simply that [] is polymorphic, but in certain situations it gets instantiated with a more restrictive type
12:48:00 <sellingMyCopyOfG> Doh.
12:48:11 <Lemmih> G?
12:48:27 <H0lyD4wg> gzl, can you define "certain situations"?
12:49:08 * RemiTurk wonders how much value the word "copy" has in a pure language ^o)
12:49:25 <gzl> in situations like the ones you brought up, e.g. when it's been created as the result of previous computations that may make the typechecker give it a more restrictive type
12:49:25 <RemiTurk> I mean, we can just _share_ it without fear of anyone disturbing our state :)
12:50:35 <H0lyD4wg> are there situations that are different?
12:51:27 <gzl> maybe, but that's the main thing I can think of offhand. you would only run into a problem if it's been given some more restrictive type
12:51:38 <sellingMyCamry90> hey guys
12:51:41 <sellingMyCamry90> well
12:51:55 <sellingMyCamry90> I cant get this like IRC client going on windows XP
12:52:07 <sellingMyCamry90> cuz i need like ghc 6.2.2
12:52:09 <sellingMyCamry90> with gtk
12:52:11 <gzl> ah, ok, maybe this will help. there are not separate []'s, there is one polymorphic [] that can have many instances if it's given a more restrictive type
12:52:11 <sellingMyCamry90> or something
12:52:25 <gzl> so it can behave as if there are different []'s
12:52:32 <sellingMyCamry90> right nwo im using a tcl irc client called roxirc wich is impressive
12:52:33 <gzl> in certain situations like the thing i named
12:52:35 <sellingMyCamry90> now that is
12:53:16 <SamB> wait a minute, why would [] have many instances?
12:53:20 <H0lyD4wg> ok. i still don't understand it completely, but now it's clear enough not ot lose sleep about.
12:53:37 <gzl> SamB: because you get junk like (tail "f") :: [Char]. maybe it's not the best way of phrasing it
12:54:18 * RemiTurk missed the junk
12:54:32 <gzl> well, I have some fresh junk here. :)
12:55:10 <RemiTurk> well, I was specifically talking about "junk like (tail "f") :: [Char]"
12:55:25 <shrimpx> it's [], but has a definite type
12:55:29 <Cale> [] is not just one value, but the name of a value in many different types (every type of the form [a])
12:55:51 <Cale> similarly, id is not just one function
12:55:57 <SamB> Isn't [] actually a value of many different types?
12:56:36 <gzl> that's what I thought.
12:56:38 <xerox> A [] appearing in a program should be of _one_ type, I think.
12:56:52 <gzl> rather, one type, but a polymorphic one
12:56:57 <Cale> Well, yes, in exactly the sense that I mentioned. But for example, 3 : 5 : ([] :: [Char]) is a type error
12:57:03 <xerox> But speaking on IRC, it is a name of a value of many different types, I think.
12:57:07 <shrimpx> it can remain polymorphic, albeit useless
12:57:20 <shrimpx> any value that remains polymorphic is useless =)
12:57:39 <Cale> What about existential types? :)
12:57:42 <RemiTurk> for what definition of "remains"?
12:57:45 * RemiTurk thinks about generics
12:58:18 <shrimpx> hah
13:01:24 <shrimpx> eg when running the program let a = [] in 'c', a remains polymorphic (type [a]) at the end of the typechecking phase. if you have let a = [] in 'c':a then a has type String
13:01:49 <shrimpx> some people use that property to declare those values which "remain polymorphic" garbage
13:01:56 <shrimpx> and collect them
13:02:49 <SamB> shrimpx: huh?
13:02:55 <RemiTurk> let l = [] in (():l, True:l)
13:03:01 <RemiTurk> does l remain polymorphic or not?
13:03:07 <SamB> how would you case on them if they were collected?
13:03:12 <RemiTurk> s/es// ;)
13:03:34 <SamB> @plugs let l = [] in (():l, True:l)
13:03:42 <lambdabot> ([()],[True])
13:04:02 <SamB> @type let l = [] in (():l, True:l, l)
13:04:08 <lambdabot> let l = [] in (():l, True:l, l) :: forall a. ([()], [Bool], [a]
13:04:08 <lambdabot> )
13:04:52 * RemiTurk garbage collects l
13:06:31 <H0lyD4wg> Prelude> let l = [] in (():l, 'f':l, 1:l,l)
13:06:31 <H0lyD4wg> ([()],"f",[1],[])
13:06:31 <H0lyD4wg> wtf? no error?
13:06:34 <sellingMyCamry90> is there a irc over a web page program written in haskell?
13:06:38 * H0lyD4wg is confused
13:06:52 * RemiTurk too
13:07:08 <RemiTurk> a haskell irc client as cgi?
13:07:55 <gzl> yeah, i'm not sure why that one works and the other one doesn't
13:07:58 <H0lyD4wg> a cgi irc client doesn't sound very usable..
13:08:25 * RemiTurk agrees
13:08:42 <H0lyD4wg> a cgi interface that controls a bot, OTOH, could make sense in some situations.
13:09:04 <xerox> CGI::IRC makes sense in some situations, too.
13:09:10 <SamB> as far as I can see, anything that refers to an evaluated [] ends up pointing to GHCziBase_ZMZN_static_info
13:10:05 * RemiTurk is enlightened
13:10:14 <sellingMyGHC> TFK: Ping.
13:10:21 * RemiTurk wonders what SamB did to see that
13:10:24 <SamB> at least, thats what I get from running objdump -D -r NilTypes.o, where NilTypes.hs contains:
13:10:25 <SamB> module NilTypes where
13:10:25 <SamB> nil     = []
13:10:25 <SamB> nilInts = nil :: [Int]
13:11:24 <SamB> I admit the disassembly itself looks silly everywhere but .text
13:11:25 <SyntaxNinja> w00t
13:11:51 <RemiTurk> ahh :)
13:12:10 * H0lyD4wg is still in the dark
13:12:18 <dcoutts_> SamB, though there is a difference between how we can model the thing semantically and how it is actually implemented. Yes of course in an implementation [] is a single shared thing but that doesn't mean it is not helpful to think of []'s of different types as being non-equal
13:12:57 * RemiTurk usually doesn't think about equality on different types :)
13:13:13 <SamB> dcoutts: well, obviously [] :: a and [] :: b cannot be compared
13:13:20 <SamB> @type (==)
13:13:22 <dcoutts_> [] :: [Char] = [] :: [Int]  ?  what does the Haskell semantics say about this?
13:13:22 <lambdabot> (==) :: forall a. (Eq a) => a -> a -> Bool
13:13:39 <dcoutts_> no, no (==) but semantic =
13:13:44 <xerox> @plugs [] :: [Char] == [] :: [Int]
13:13:45 <lambdabot> parse error on input `=='
13:13:58 <RemiTurk> @plugs ([] :: [Char]) == ([] :: [Int])
13:14:00 <lambdabot> Couldn't match `Char' against `Int'
13:14:03 <SamB> haskell semantics don't say anything about semantic equality between types, do they?
13:14:27 <basti_> semantics is an hallucination.
13:14:32 <dcoutts_> SamB, I'm not sure but my Q was about equating two values
13:15:04 <SamB> haskell isn't even formally defined, really
13:15:14 <SamB> most of the standard is in english
13:15:41 <H0lyD4wg> so, how does this whole "instantiation" thing works? maybe it'll answer the other question i had.
13:15:46 <dcoutts_> not fully formally no, but even our informal sematics should be able to answer the question
13:16:14 * RemiTurk wonders how many languages _are_ "formally defined" then ;)
13:16:17 <basti_> H0lyD4wg: well different to imperatives/OO languages
13:16:20 <basti_> RemiTurk: SQL is.
13:16:35 <SamB> RemiTurk: well, probably SKI.
13:16:38 <dcoutts_> some version or other of ML is formally defined
13:16:38 <RemiTurk> in therms of relational algebra?
13:16:40 <basti_> H0lyD4wg: in haskell, types are instances, not objects
13:16:54 * RemiTurk doesn't know SKI
13:17:13 <SamB> lambda calculus?
13:17:31 <basti_> RemiTurk: and in terms of temporal stuff.
13:17:39 <basti_> because of "state"
13:17:44 <SamB> okay, so nothing really
13:17:52 <dcoutts_> SKI is the combinator language (with combintors S, K and I), equivalent to lambda calculus IIRC
13:17:59 <RemiTurk> dcoutts_: ahh, of course
13:18:01 <basti_> dcoutts_: i agree
13:18:28 <RemiTurk> hm, though I didn't really mean "_formal_ models of computation" when I said "language"
13:18:34 <sellingMyCamry90> so what do you gents use as an irc client
13:18:35 <sellingMyCamry90> ?
13:18:37 <RemiTurk> (which I didn't say, of course)
13:18:43 <RemiTurk> xchat, and not really happy about it
13:18:52 <dcoutts_> me too
13:19:20 <Lemmih> irssi.
13:19:40 <H0lyD4wg> dcoutts, isn't I superfluous? (a shorthand for SKK / SKS)?
13:20:04 <RemiTurk> it is
13:20:13 <dcoutts_> H0lyD4wg, yes that is true (I can't remember what it is equal to exactly)
13:20:30 <RemiTurk> I is equal to SK(anything)
13:20:44 <tromp> and also to S(SK)
13:20:55 <sellingMyCamry90> hmm
13:20:57 <dcoutts_> H0lyD4wg, there are combinator languages equilavent to SKI with only a single combinator
13:21:03 <tromp> by extensionality
13:21:06 <sellingMyCamry90> what kinda of programs are you haskelling lately gents?
13:21:14 <sellingMyCamry90> kinds
13:21:30 <H0lyD4wg> heh, kinds.
13:21:34 * H0lyD4wg giggles
13:21:40 <RemiTurk> right now, a homework assignment
13:21:42 <dcoutts_> sellingMyCamry90, a type inference algorithm and gtk2hs (totally unrelated!)
13:21:55 <tromp> but that single combinator X=<K,S,K> doesn't have a simple rewrite rule
13:22:35 <H0lyD4wg> X = KSK ?
13:22:43 <tromp> and only serves to reproduce K and S
13:23:04 <tromp> no, <K,S,K> = \x -> x K S K
13:23:23 <basti_> anyone ever programmed unlambda?
13:23:34 <RemiTurk> I've stared at it for a while
13:23:36 <tromp> so XX = K K
13:23:46 <tromp> making XXX=K
13:23:54 <xerox> @get-definition K
13:23:55 <lambdabot> K = \x y.x
13:24:03 <tromp> and X(XX)=KK K S K = S
13:24:04 <xerox> @get-definition X
13:24:05 <lambdabot> X = \x.x K S K
13:24:05 <SamB> unlamda is probably harder to read than GHC's assembly output
13:25:02 <beschmi> anyone already added cabal support to hsql and haskelldb?
13:26:06 <CosmicRay> hsql, yes.
13:27:12 <Lemmih> haskelldb, yes.
13:27:27 <H0lyD4wg> so, if there's a function f::(Monad m => a -> m b), where does m come from?
13:27:56 <dcoutts_> it comes from the context in which you use f
13:28:01 * Lemmih is working on making his cabalization of haskelldb not suck.
13:28:04 <SamB> what m
13:28:08 <beschmi> cool, are there patches online somewhere?
13:28:50 <SamB> actually, m comes from inside f.
13:29:06 <dcoutts_> SamB, huh?
13:29:13 <Lemmih> beschmi: The .cabal file is available from scannedinavian.org/~lemmih/
13:29:19 <SamB> or maybe the type declaration
13:30:04 <dcoutts_> H0lyD4wg, maybe you could be more specific in your question, SamB and I are thinking of different things I think
13:30:21 <wagle> yay/finally!
13:30:24 <beschmi> Lemmih: thanks
13:30:27 <SamB> f never needs to know what m is, it just needs the implementation of the Monad typeclass for it };->
13:30:31 <wagle> The Glorious Glasgow Haskell Compilation System, version 6.4
13:30:52 <Lemmih> beschmi: You still have to use make to configure the package.
13:30:57 <H0lyD4wg> dcoutts, i don't think i understand my question well enough to be more specific.
13:31:28 <H0lyD4wg> SamB, but i need a concrete m to run it, no?
13:31:39 <SamB> whatever calls f gets to use any m it wants
13:31:45 <dcoutts_> SamB, right, so what I meant was that the 'concrete' type m that you might end up with in a run of a program using f comes from the context in which you use f
13:32:00 <SamB> dcoutts: very true
13:32:13 <dcoutts_> SamB, so we were saying the same thing :-)
13:32:16 <H0lyD4wg> how do contexts work?
13:33:47 <dcoutts_> H0lyD4wg, eg if I'm doing some IO and I use your function f, eg f "blah" >> putStr "blah"  then the 'm' type variable will be instanciated to IO
13:33:50 <SamB> H0lyD4wg: basicly, you can use any type m which has a Monad instance declared. or you can just keep calling it Monad m => m
13:35:04 <SamB> also, the only implementations of f I can think of look like f = return (error "[...]")
13:35:21 <SamB> or possibly...
13:35:24 <SamB> @type fail
13:35:26 <lambdabot> fail :: forall (m :: * -> *) a. (Monad m) => String -> m a
13:35:37 <SamB> er, I forgot a const
13:36:03 <SamB> f = const (return (error "[...]"))
13:36:18 <SamB> f = const (fail "[...]")
13:36:51 <dcoutts_> in my example, putStr "blah" :: IO () and since we're combining (f "blah") and (putStr "blah") using >> :: Monad m => m a -> m b -> m b  then the 'm' gets unififed with 'IO' giving us the overall type IO ()
13:36:51 <wagle> i like this theory: http://www.ucomics.com/tomtoles/2005/04/25/
13:37:15 <dcoutts_> @type (>>)
13:37:17 <lambdabot> (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m
13:37:17 <lambdabot> b
13:37:36 <H0lyD4wg> SamB, are you saying that the only function that'll work with multiple monads is the one that fails?
13:38:12 <SamB> H0lyD4wg: no, thats more because of the a and the b than because of the m
13:38:15 <H0lyD4wg> dcoutts, can i use f with different monads in different parts of the program?
13:38:31 <dcoutts_> H0lyD4wg, exactly
13:39:59 <H0lyD4wg> so, if i want to run f in the Foo monad i have to "chain" it with g::(b -> Foo c) ?
13:40:18 <dcoutts_> H0lyD4wg, there are many functions that work with any monad, which is nice since it means if you create a new monad, theres already a load of helpful functions that will work with it
13:41:04 <H0lyD4wg> but to actually run them in need to throw into the mix a function that only works with that specific monad?
13:41:30 <dcoutts_> H0lyD4wg, yes that's more or less right
13:42:25 <H0lyD4wg> where am i "less right"? i really want to understand that..
13:43:11 <dcoutts_> I tend to think of it as whenever you use a feature of a specific monad, you end up getting that monad (and only that monad)
13:45:10 <dcoutts_> so you're right, it's just a question of emphasis. You don't need to work hard to force some code to use a specific monad, just use a feature/function thats unique to that monad. If you never do so your code remains 'generic' in its monad.
13:45:50 <H0lyD4wg> and code that remains 'generic' never runs?
13:47:48 <dcoutts_> you can see it that way, yes
13:48:51 <H0lyD4wg> (can i "force" eg. the list monad by doing (f x) ++ [] or does the forcing have to happen in a >>=/>> chain?)
13:48:53 <dcoutts_> though there is the interesting case of values like [] which really are evaluated but are never the less still 'generic' in some parameter
13:50:09 <dcoutts_> I think (f x) ++ [] would be type correct, f x :: Monad m => m a, which we can instanciate to [a]
13:50:29 <CosmicRay> sheesh, the fptools repo is massive
13:51:02 <RemiTurk> ~/d/cvs% du -hs fptools
13:51:02 <RemiTurk> 106M	fptools
13:52:27 <CosmicRay> the rcs files take up 3x that
13:54:26 <RemiTurk>                       5.0G  4.8G  244M  95% /home
13:54:31 <RemiTurk> isn't going to try getting that ;)
13:55:00 * CosmicRay is starting work on converting the whole thing to darcs
13:58:03 <SyntaxNinja> CosmicRay: woohoo!
13:58:48 <CosmicRay> :-)
13:59:05 <CosmicRay> SyntaxNinja: wanna trade?  I'll hack in some haddock args to cabal if you do this :-)
13:59:55 <SyntaxNinja> CosmicRay: hm. I could get paid for converting it to svn ;)
14:00:19 <TFK> Err, Oejet left :-(
14:00:42 <CosmicRay> SyntaxNinja: well, if you do that, then converting to darcs is trivial :-)
14:04:40 <SyntaxNinja> CosmicRay: why's that?
14:04:44 <SyntaxNinja> why's that eaiser than cvs?
14:05:11 <CosmicRay> tailor.py does a very good job of migrating svn stuff over, I've found
14:05:20 <CosmicRay> svn already has a notion of changesets, etc.
14:08:44 <CosmicRay> I'm trying cvs2darcs first.
14:08:52 <CosmicRay> if that doesn't work, then I'm trying tailor.
14:09:03 <CosmicRay> if that doesn't work, then I'm trying cscvs to convert it to arch, then arch2darcs.
14:09:11 <CosmicRay> and if that doesn't work, then I'll take you up on converting to darcs
14:09:19 <CosmicRay> ah ha.
14:09:32 <CosmicRay> cvs rlog: Logging fptools/ghc/compiler/specialise
14:09:33 <CosmicRay> malformed revision
14:09:33 <CosmicRay> Conversion Complete
14:09:33 <CosmicRay> cvs2darcs: deleting CVS directories in fptools
14:09:33 <CosmicRay> cvs [rlog aborted]: received broken pipe signal
14:09:33 <CosmicRay> Done converting module fptools in directory fptools
14:09:42 <CosmicRay> methings cvs2darcs doesn't check exit codes.
14:09:45 <CosmicRay> bad cvs2darcs, bad.
14:10:01 <xerox> jii-aah shrimpx
14:10:06 <xerox> err, shapr!
14:10:22 <shapr> y0 xerox
14:10:30 <tuomov> My experiences with tailor are quite different..
14:10:52 <tuomov> I had to manually step it through and add files that it failed to move
14:11:14 <TFK> shapr, they always come back...
14:11:17 <shapr> Igloo: Do I just send darcs patches to darcsdevel?
14:11:28 <tuomov> then, although this isn't the fault of tailor but svn architechture itself, I had to manually reconstruct branches and tags
14:11:34 <shapr> TFK: I know, you try to escape them, but student loans will always find you.
14:11:37 <tuomov> with some scripting support
14:11:51 <TFK> :-D
14:12:51 <shapr> Anyway, I have a coupla darcs patches for stable, and was wondering where I should send them.
14:22:59 <CosmicRay> shapr: use darcs send http://www.abridgegame.org/repos/darcs
14:23:09 <shapr> ah, ok
14:23:21 * TFK glares at hOp, House
14:23:33 <shapr> Wait, my local sendmail is broken, will that show the email address used?
14:25:29 <shapr> aha
14:25:30 <wagle> shapr: what os you running?  linux?
14:25:33 <shapr> Yup
14:25:42 <wagle> you found the log?
14:25:49 <shapr> what log?
14:25:54 <wagle> there is also a mailq command
14:26:13 <beschmi> shapr, if you have recent darcs, you can use --sendmail-command and something like mstmp
14:26:16 <wagle> something like /var/log/mail
14:26:19 <SyntaxNinja> shapr: !!
14:26:27 <shapr> My mail problem is that I can't get SASL working between my local sendmail and scannedinavian.org
14:26:31 <wagle> see your /etc/syslog.conf file
14:26:31 <shapr> SyntaxNinja: !!
14:26:44 <wagle> shrimpx: you around?
14:27:00 <wagle> shapr: firewall?
14:27:05 <SyntaxNinja> CosmicRay: if you convert it to svn first, you might get some interest from JaffaCake, fwiw, and some help too
14:27:13 <shapr> No, I just can't figure out how to get SASL to work.
14:27:36 <shapr> I've spent about fifteen hours of work on it so far, and finally gave up in disgust.
14:28:00 <shapr> SASL in debian is way too hard to figure out.
14:28:11 <shapr> (Or I'm just totally clueless, which I hope is not the case)
14:28:15 <JaffaCake> SyntaxNinja: I set up CosmicRay's account so he could play with converting fptools to darcs
14:28:21 <xerox> OK, goodnight folks.
14:28:35 <wagle> whats SASL
14:28:46 <JaffaCake> I've gone off svn, darcs is clearly the way forward :)
14:28:51 * wagle gets confused and doesnt google first
14:29:13 <shapr> SASL is a remote authentication thingy.
14:29:15 <SyntaxNinja> JaffaCake: sweeeeet
14:29:24 <shapr> JaffaCake: w00!
14:29:24 <beschmi> shapr: sasl should be pretty easy with http://msmtp.sourceforge.net/
14:29:27 <CosmicRay> JaffaCake: yeah, and that's helpful, there are some bogons in the ,v files
14:29:33 <CosmicRay> I'm hacking around them on my downloaded copy
14:29:39 <beschmi> if it's already configured on the server
14:29:50 <SyntaxNinja> CosmicRay: if you get a 'clean' CVS version of the fptools tree, let me know :)
14:29:55 <SyntaxNinja> clean == no bogons, obviously
14:29:56 <wagle> the usual problem in my experience is firewalls at one end or the other
14:30:13 <SyntaxNinja> of course, you should be operating on a copy of the fptools tree anyway, I hope
14:30:20 <shapr> beschmi: Yeah, but... the only point of using SASL is if I can get my local and remote postfix servers talking to each other. Otherwise I can continue to send mail directly from emacs to my ISP's mail server.
14:30:21 <JaffaCake> CosmicRay: we should clean up those bogons in the main tree
14:30:23 <SyntaxNinja> fpotools repo, that is
14:30:32 <wagle> watch at both ends to see if the packets are actually getting from both ends to the other ends
14:30:42 <wagle> (ethereal)
14:31:27 <wagle> next thing for mail is to ensure that the mail server isnt rejecting the client
14:32:02 <wagle> i got tired of having to relearn sendmail every year, so gave up on running my own mail server several years ago.. sorry
14:32:32 <RemiTurk> JaffaCake: thanks for the quick "readIORef (mc ! k)" analysis. My current version doesn't suffer from it (and in the original version I could work around with it by exporting the thing) and it (the homework assignment) blasts my colleagues java-versions to pieces :)
14:32:39 <shapr> I have learned much about SASL, my problem is that I can't get it working on the server side. At this point, I think my server can find the SASL database, but it still won't positively auth the user/passw, even though a hex editor shows the user and password is in the database file correctly.
14:33:03 <JaffaCake> RemiTurk: no problem, I hope we can fix it properly though
14:33:23 <shapr> wagle: But now there's Postmaster!
14:33:32 <RemiTurk> JaffaCake: I'm afraid I won't be an element of "we" for awhile ;)
14:33:54 <shapr> It's the ultimate mail server, it's written in Haskell! (and very likely faster than anything but sendmail)
14:34:03 <JaffaCake> RemiTurk: you already helped, remember ;)
14:35:15 * JaffaCake slaps gdb with a wet fish
14:35:17 <beschmi> shapr: i see, for now you could just use darcs send -o patch and send the patch-bundle with emacs to the address in http://www.abridgegame.org/repos/darcs/_darcs/prefs/email
14:35:30 <shapr> beschmi: I'll do that, thanks.
14:35:38 * RemiTurk will remember ;)
14:36:24 <CosmicRay> JaffaCake: ok, will do, I'm still trying to track down all the weirdness
14:36:27 <SyntaxNinja> JaffaCake: what kind of fish? haddock?
14:36:33 * shapr snickers
14:36:52 <CosmicRay> JaffaCake: so far I've found malformed dates in fptools/ghc/driver/split/ghc-split.lprl,v
14:36:52 <JaffaCake> definitely not a cod, since they're endangered
14:36:57 <CosmicRay> JaffaCake: which, erm, you committed :-)
14:37:03 * shapr puts the fear of cod into gdb
14:37:11 * JaffaCake laughs
14:37:23 <SyntaxNinja> heh
14:37:38 <JaffaCake> CosmicRay: yes, I came across those before
14:37:54 <CosmicRay> nothing a little nudging with vim couldn't fix :-)
14:38:15 <CosmicRay> wow shapr, the darcs wiki looks... nice :-)
14:38:18 <CosmicRay> what did you do to it/
14:38:33 <shapr> It got moved to darcs.net and upgraded from moin 1.2 to moin 1.3
14:38:35 <shapr> Also, hey!
14:38:41 <shapr> Do you see a blue theme or a tan theme?
14:38:47 <JaffaCake> CosmicRay: send me a patch, and I'll apply it to the master repo :-o
14:39:46 <CosmicRay> JaffaCake: done
14:40:00 <JaffaCake> cheers
14:40:27 <CosmicRay> shapr: blue
14:40:39 <CosmicRay> shapr: actually, more gray :-)
14:40:39 <shapr> foo :-( I'll need to patch themes again then.
14:40:48 * shapr will do that tomorrow.
14:40:57 <JaffaCake> so... here's what's entertaining me right now, in case anyone here has any bright ideas:
14:41:11 <JaffaCake> I have a program that crashes only with 16+ threads
14:41:12 <SyntaxNinja> JaffaCake: let me guess, you're redesigning the package and import system in GHC?
14:41:31 * JaffaCake runs away
14:41:39 <SyntaxNinja> :P
14:41:39 * shapr sniggers
14:41:41 <RemiTurk> you're working on ghc's distributed stuff?
14:42:02 <JaffaCake> and the crash is caused by a word in a data structure being overwritten (from 0 to 1)
14:42:14 <JaffaCake> gdb's watchpoints don't work over multiple threads
14:42:33 <JaffaCake> I have no idea how to track this down.
14:42:47 <CosmicRay> JaffaCake: I wonder if there's a gdb list you could post to?
14:43:02 <RemiTurk> hm, you are able to get multiple core-dumps?
14:43:04 <CosmicRay> I've never written pthreads stuff at a low level, so I don't erally know how to debug it unfortunately
14:43:29 <JaffaCake> I can get a core dump, but that doesn't help - it just tells me the corruption has happened
14:43:40 * RemiTurk remembers a lot of gdb-multi-threading-hell long ago on linux-kernel I think
14:44:16 <shapr> JaffaCake: Is there any pattern to where the word is when overwritten?
14:44:36 <JaffaCake> shapr: yeah, it's always the same one :)
14:45:04 <JaffaCake> which helps, but I've stared at the code and can't find anything obviously wrong
14:45:40 <shapr> Is it possible that the number of threads somehow only holds a maximum of 0xF and that word is where 0x10 would be?
14:45:48 <RemiTurk> @wiki HaskellIrcPastePage
14:45:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:45:50 <RemiTurk> ;)
14:46:25 <RemiTurk> well, it does indeed sound like some hardcoded limit somewhere, but that's probably not really helpful :-/
14:46:26 <JaffaCake> shapr: don't think so, it's at the end of a struct
14:47:00 <shapr> The word is at the end of a struct?
14:47:07 <JaffaCake> yep
14:47:20 <JaffaCake> I checked that the malloc is reserving enough space
14:47:24 * RemiTurk has never used http://valgrind.org/, but can imagine it would useful
14:47:35 <JaffaCake> hmm, there's a thought
14:47:50 * shapr notes that valgrind happened because of GHC anyway...
14:47:52 <gzl> i used it once. it seemed pretty good.
14:48:10 <RemiTurk> wow, it even talks about threads: programs. With the tools that come with Valgrind, you can automatically detect many memory management and threading bugs, avoiding hours of frustrating bug-hunting, making your programs more stable.
14:48:28 * RemiTurk asks shapr to tell a story
14:48:51 <shapr> Any way to figure out what's past the end of the struct? My guess is that whatever is there is overflowing.
14:49:14 * JaffaCake crashes valgrind
14:49:19 <JaffaCake> valgrind: vg_scheduler.c:3570 (scheduler_sanity): Assertion `mx->__m_count > 0' failed.
14:49:23 * pesco cheers.
14:49:38 <shapr> RemiTurk: http://builder.com.com/5102-6375-5136747.html
14:50:10 <JaffaCake> shapr: I'll take a look
14:50:45 <SyntaxNinja> JaffaCake is powerful.
14:50:51 <shapr> If you found a good bug in valgrind because of GHC, I suspect Julian Seward will be entertained.
14:51:53 <RemiTurk> shapr: thx :)
14:52:41 <JaffaCake> shapr: I can't wait to tell him :)
14:53:05 <JaffaCake> it's probably an oldish version of valgrind, though
14:55:50 <shapr> JaffaCake: btw, do you often work at midnight?
14:56:24 * CosmicRay notes it's probably not midnight where he is
14:56:46 * RemiTurk thinks it (almost) is
14:56:54 <JaffaCake> shapr: it's only 11pm :)
14:56:56 <shapr> Ah right, it's 11pm
14:56:58 * pesco yawns.
14:57:08 <CosmicRay> huh.  I thought you were in cambridge, jaffacake.
14:57:15 <JaffaCake> I am
14:57:19 <RemiTurk> there are 2 cambridges..
14:57:31 <CosmicRay> oh.  doh.
14:57:41 <CosmicRay> all this time, I was thinking cambridge, MA
14:57:52 <JaffaCake> heh
14:58:03 <RemiTurk> http://en.wikipedia.org/wiki/Cambridge_%28disambiguation%29
14:58:04 <gzl> I don't think there's a MSR outfit in Cambridge MA
14:58:31 <RemiTurk> is MA Maine, Maryland or Massachusetts? :)
14:58:32 <CosmicRay> gzl: well it would be a logical place for it though, so it didn't occur to me as odd
14:58:37 <pesco> Mass.
14:58:39 <gzl> Mass
14:58:40 * SyntaxNinja always thinks of Mountain Safety Research...
14:58:58 <gzl> yeah, it would be a good place
14:59:08 <SyntaxNinja> CosmicRay: you're forgiven for thinking that JaffaCake is cool enough to be an american.
14:59:37 <CosmicRay> heh
14:59:59 * JaffaCake hefts the wet fish, aiming it at SyntaxNinja
15:00:15 <CosmicRay> hmm, well tailor has started at work :-)
15:00:26 <CosmicRay> I think this will be going for quite some time
15:00:28 <SyntaxNinja> JaffaCake: and here I thought I was bestowing upon you a great complement ;)
15:00:57 * RemiTurk locks SyntaxNinja away, so JaffaCake can go on debugging
15:01:09 * pesco stows away some complements.
15:01:21 <pesco> These things get _heavy_!
15:01:22 <JaffaCake> yeah I'm only just cool enough to be an american, thanks SyntaxNinja ;)
15:01:41 * CosmicRay waves
15:02:16 <SyntaxNinja> for all our faults, you all must admit that we're cool ;)
15:02:34 <SyntaxNinja> now cosmicray is gone, not sure if I can stand up to you all...
15:02:53 <wagle> shapr: http://www.scannedinavian.org/~shae/haskellers.png is COMPLETELY OUT OF DATE!  8) 8) *<8-)
15:03:42 * RemiTurk thinks europe should be bigger on that map for clarity :P
15:03:42 <tuomov> you need a bigger map to fit all those names in europe..
15:03:51 <tuomov> some kind of lens effect..
15:04:42 * RemiTurk goes to sleep
15:04:56 <RemiTurk> night everyone
15:05:12 <shapr> wagle: quick make a new version and link to it!
15:05:17 <pesco> Yeah, and real-time zooming around and blinking based on IRC activity and statistic displays of darcs patch activity on various repositories.
15:05:26 <shapr> pesco: whoa, that would rock
15:05:29 <pesco> :)
15:05:42 <SyntaxNinja> pesco: and arches for trusted key relationship
15:05:48 <shapr> yow!
15:06:07 <pesco> Yes.
15:06:10 * RemiTurk will see what the map has become tomorrow :)
15:06:52 <wagle> shapr: i got stuck for 8 hours last night compiling ghc 6.4
15:06:58 <tuomov> cell phone tracking of actual location
15:07:02 <pesco> haha
15:07:11 <shapr> wagle: did it finish?
15:07:30 <JaffaCake> wagle: all your cycles are belong to us
15:07:38 * shapr laughs
15:07:52 <SyntaxNinja> JaffaCake is actually part of the seti@home project...
15:08:42 <wagle> yeah..  apparently apple's latest gcc is rather exuberant about optimizing for space at run-time by using EXPSPACE at compile-time
15:09:22 <pesco> "Computer, locate shapr. Establish audio line to tuomov and perform full anomaly scan of surrounding IP-ranges, Burrows alpha-filter."
15:10:25 * shapr still can't hear anyone, he has his headphones turned up too loud.
15:11:01 <wagle> thats you?
15:13:17 <SamB> pesco: are you working on @get-shapr?
15:15:00 <pesco> SamB: I don't have time right now, sadly. ;)
15:15:04 * shapr wonders how that would work...
15:15:45 <SamB> shapr: someone mentioned modules BlackCandle and Pentagram, iirc
15:15:52 * shapr laughs
15:16:04 <SamB> @todo
15:16:05 <lambdabot> 0. dons: Release lambdabot 3.0
15:16:05 <lambdabot> 1. SamB: A way to get multiple results from a google search
15:16:05 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
15:16:05 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
15:16:05 <lambdabot> the command was given on
15:16:05 <lambdabot> 4. SamB: stop mangling long urls
15:16:07 <lambdabot> 5. dons: improve formatting of @dict
15:16:15 <tuomov> Shouldn't that be @summon-shapr?
15:16:16 * pesco summons a lesser GHCi
15:18:20 <wagle> @dwim
15:18:20 <lambdabot> Unknown command, try @listcommands.
15:19:17 <kaol> @yow
15:19:18 <lambdabot> I just forgot my Social Security number.
15:19:26 <shapr> @arr
15:19:28 <lambdabot> Aye Aye Cap'n
15:20:10 <pesco> Fsck. I just killed my browser window.
15:20:14 <shapr> whoops
15:21:07 * pesco copies the Wiki document into vim.
15:21:16 <shapr> hiya skew!
15:21:21 <skew> hi shapr
15:21:35 <shapr> pesco: truly, we need an external editor plugin or something.
15:21:45 <shapr> I do cut'n'paste like that too
15:21:49 <skew> isn't there a web browser in emacs?
15:22:04 <pesco> Right...
15:22:07 <skew> You've said that you use ERC
15:22:35 <skew> I don't think that helps pesco much, though...
15:23:23 <skew> It shouldn't be that hard to make a firefox plugin that fires up $EDITOR...
15:24:09 * skew checks if it's already been done
15:24:42 * pesco mumbles something about darcs and old times.
15:24:59 * shapr grins
15:25:07 <shapr> pesco: well, this is an experiment :-)
15:25:17 <pesco> Yeah, I'm just being a grumpy old fart.
15:25:55 <shapr> I want feedback about the easy and hard bits, hopefully we'll find a process that has most of the good points.
15:26:34 <pesco> What the hell, I thought Moin Moin had some sort of auto-save on preview feature?!
15:26:50 <shapr> Er, no.
15:27:03 <shapr> Oh wait
15:27:14 <shapr> yeah, it has editor backups.
15:27:32 <tuomov> There should be an universal editor plugin architechture..
15:27:45 <tuomov> for embedding the editor as well, not just launching it
15:27:52 <skew> hmm, how about this "Scribe: Adds Word Processor like functionality to web forms, including opening and saving form entries as files."?
15:28:15 <pesco> Oh great, but it lost my cookie and the backup seems to have expired with my editing lock.
15:31:44 <skew> does this have anything to do with TMR?
15:31:57 <pesco> Yes, I'm writing an article. ;)
15:33:48 <JaffaCake> I found it - shapr, you were pretty close
15:33:51 * SamB doesn't think darcs and old times go in the same sentance
15:33:59 <shapr> JaffaCake: oh what was it?
15:34:07 <shapr> skew: want to write an article?
15:34:23 <skew> hmm, maybe
15:34:38 <JaffaCake> the 16 threads had bumped the size of a table, and old pointers were left pointing to where the table used to be
15:34:44 <skew> well, I'm already writing an article for this technical writing class
15:35:01 <skew> but I might be able to make something with it
15:35:17 <JaffaCake> one gold star to valgrind
15:36:10 <SyntaxNinja> JaffaCake: cool!
15:37:03 <skew> I'm not sure how well it is going to work, but the idea is to introduce a lot of the different aspects of the Haskell type system and describe what they are good for
15:39:29 <skew> pesco: it looks like Scribe isn't what you want. It's about saving all the data on a form and being able to restore it. It uses an xhtml file with some odd classes to remember the fields
15:42:53 <JaffaCake> later folks... time for bed
15:43:09 <shapr> g'night JaffaCake
15:43:27 <df_> nini all
15:43:49 <shapr> df_: you going to sleep too?
15:43:49 <dan2> how the hell does one interpret this
15:43:51 <dan2> qsort (x:xs) = qsort [y | y<-xs, y<=x] ++ [x] ++ qsort [y | y<-xs, y>x]
15:44:01 <shapr> Man, all these people take so much time..
15:44:12 <shapr> dan2: check out the HaskellDemo for a short syntax intro
15:44:15 <shapr> @wiki HaskellDemo
15:44:16 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
15:45:40 <pesco> shapr: Well, it is cool how fast the TmrWiki is growing already.
15:45:44 <shapr> Yeah, it is.
15:45:48 <shapr> It's very motivating for me.
15:45:54 <dan2> shapr: I can't figure it out whats in those brackets there
15:46:06 <shapr> dan2: do you have hugs or ghci installed?
15:46:07 <mauke> list comprehension syntax
15:46:21 <dan2> yes
15:46:23 <dan2> both
15:46:37 <pesco> shapr: The fact that it's all instantly visible probably adds a great deal to the effect.
15:46:37 <shapr> I'd suggest you put small bits of that code into ghci to see what it does.
15:46:46 <dan2> hmm
15:46:50 <dan2> I think I get it now
15:46:50 <JohnMeacham> [ y | y <- xs, y <= x] means take each element of xs and produce a new list containing just those that are less than or equal to x
15:47:26 <shapr> pesco: Yes, that's the great advantage of wikipublishing.
15:47:53 <pesco> Too bad, it doesn't look as good as PDF.
15:47:59 <shapr> @plugs [x | x <- [1..5]]
15:48:04 <pesco> Or LaTeX for that matter.
15:48:05 <lambdabot> [1,2,3,4,5]
15:48:18 <blackdog> shapr: did you have a look at shim?
15:48:20 <shapr> @plugs [(x,y) | x <- [1..5], y <- [5..7]]
15:48:22 <lambdabot> [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(
15:48:22 <lambdabot> 4,6),(4,7),(5,5),(5,6),(5,7)]
15:48:45 <shapr> blackdog: Nah, not yet. I've been busy moving DarcsWiki and setting up TmrWiki. Want to write a TMRticle?
15:48:53 <blackdog> You keep asking. :)
15:49:16 <blackdog> Big deadline this week... anything i could write would be so slapdash as to not be worth it
15:49:21 <shapr> Ok
15:49:27 <blackdog> next one. cross my heart and hope to use cobol.
15:49:27 <dan2> shapr: so the last thing occuring is a comparison operation to see if it can be done like that
15:49:29 <shapr> I keep forgetting who I asked and who I didn't
15:49:30 <dan2> alright I get tit now
15:49:55 <shapr> @plugs [x | x <- [1..9], x < 6]
15:49:57 <lambdabot> [1,2,3,4,5]
15:50:20 <pesco> OK, sleepy sleepy.
15:50:28 <pesco> Good night, #haskell!
15:50:30 <shapr> pesco: maybe we can improve on the look next issue
15:50:32 <shapr> g'night pesco!
15:50:46 <shapr> hiya JohnMeacham!
15:51:02 <shapr> I don't know if I've been awake at the same time as you yet.
15:51:07 <blackdog> shapr: what do you use for wiki, anyway? I had a rather gorgeous looking Instiki right up to the point I made a #haskell entry and it keeled over - this channel is bad luck, i tell you.
15:51:18 <JohnMeacham> shapr: Heya!
15:51:29 <shapr> blackdog: I'm using Moin 1.3, but wishing for Flippi
15:51:48 <JohnMeacham> This is an unusual time for me to be awake. (it's friggen daylight here!)
15:52:01 <shapr> Gee, it's almost daylight here.
15:52:03 <pesco> shapr: Yes, basically, we need proper margins and line breaks.
15:52:08 <shapr> The sun will be up in an hour.
15:52:14 * pesco falls asleep.
15:52:48 <shapr> @time EST
15:53:10 <JohnMeacham> I am PST
15:53:13 <shapr> oh
15:53:24 <shapr> I don't think that plugin exists anyway.
15:54:38 <shapr> JohnMeacham: What do you do for a living anyway?
15:55:37 <tuomov> hm.. not long until it is almost daylight 24h
15:56:36 <tuomov> longest day of the year in about two months
15:57:51 <JohnMeacham> I write perl code for a finance company.
15:58:18 <JohnMeacham> Not terribly exciting. but it is a block from my house and leaves time for my own projects like jhc.
15:58:29 <shapr> Do you have a unicycle?
15:58:53 <blackdog> lots of people here seem to think of themselves as having day jobs. :)
15:59:07 <shapr> I'm just waiting for my lambda to come in.
15:59:29 <shapr> They keep saying "The lambda is in the mail!", and I keep believing them.
15:59:37 <blackdog> it's too early for haskell jokes
15:59:43 * shapr snickers
15:59:56 <blackdog> it's always too early for haskell jokes. let that thunk remain unevaluated, ok?
15:59:59 <dan2> how would one writing a reversing list function?
16:00:12 <shapr> @plugs reverse [1..5]
16:00:14 <lambdabot> [5,4,3,2,1]
16:00:17 <dan2> nah
16:00:19 <dan2> I want to write my own
16:00:21 <mauke> myreverse = reverse
16:00:21 <dan2> reverselist :: Ord a => [a] -> [a]
16:00:21 <dan2> reverselist [] = []
16:00:21 <dan2> reverselist [x] = [x]
16:00:21 <dan2> reverselist (x:xs) = reverselist xs ++ x
16:00:27 <dan2> not working
16:00:36 <blackdog> dan2: how would you reverse the order of a pack of cards?
16:00:40 <mauke> yeah, you mean ++ [x]
16:00:43 <dan2> oops
16:00:44 <mauke> and why Ord a?
16:00:50 <dan2> dunno
16:01:13 <mauke> reverselist [x] = [x] doesn't look like it's needed
16:01:31 <dan2> heh
16:01:49 <blackdog> dan2: once you make mauke's change, it should work, but it does much more work than it has to.
16:02:58 <JohnMeacham> I prefer 'foldl (flip (:)) []' it is faster too.
16:03:00 <dan2> blackdog: because it creates a new list each time
16:03:04 <dan2> ?
16:03:48 <shapr> JohnMeacham: so, want to write an article for TMR?
16:04:14 <JohnMeacham> TMR?
16:04:19 <shapr> The Monad.Reader
16:04:21 <dan2> blackdog: why is it so slow?
16:04:27 <blackdog> dan2: yep. ++ looks at every element of the first list, so you do way more work than necessary.
16:04:36 <blackdog> Think about a physical pack of cards. How would you reverse it?
16:04:56 <dan2> blackdog: swap adjacent elements until the last card was first
16:05:16 <JohnMeacham> I am not to great at writing prose. composing the email about jhc was by far the hardest part.
16:05:29 <Igloo> :-)
16:05:44 <dan2> blackdog: or create a new array and run through the array backwards swapping the order
16:06:08 <blackdog> dan2: do you mean swap the last and first, and move in? Swapping adjacent cards as you move through will just move the first card to the end.
16:06:22 <dan2> blackdog: the former
16:06:27 <blackdog> dan2: you have arrays of physical cards? :)
16:06:52 <blackdog> the way i would do it is to start off with the pack in one hand, and an empty other hand.
16:07:09 <blackdog> then, i'd take the top card out of my left hand, and put it on top of the pack in my right hand.
16:07:14 <blackdog> when my left hand is empty, i'm done.
16:07:27 <dan2> blackdog: the left/right method is what i usually use
16:07:29 <Igloo> blackdog: Using your middle hand to move the cards across?
16:08:43 <SamB> Igloo: that is what thumbs are for!
16:08:49 <blackdog> Igloo: the third ring of hell is reserved for literalists, y'know.
16:09:00 <Igloo> :-)
16:09:29 <dan2> blackdog: while(left < right) { tmp = i[right]; i[right--] = i[left]; i[left++] = tmp; }
16:10:16 <JohnMeacham> its the gripping hand.
16:10:23 <Igloo> dan2: blackdog's asking you to think about physical cards to explain the way this is normally done in Haskell
16:10:34 * shapr loves this quote "Lets just say that if a new "silver bullet" is on its way now, I sure hope it will be FP - it has marvelous lessons to teach any programmer." from http://www.perlmonks.org/?node_id=450955
16:10:40 <Igloo> dan2: I bet you wouldn't do that if I gave you a pack of cards and asked you to reverse them
16:11:23 <dan2> Igloo: I'd sit at a desk and take the top card and move it on the open space and repeat
16:11:25 <skew> it would look pretty neat if you did it fast enough, though
16:11:31 <shapr> Btw, at the end of this article - http://www.perlmonks.org/?node_id=450922 this guy says "They pull basically the same kind of trick by treating the user input stream as a list where all the values are theoretically defined as soon as the program starts, but we don't have to prove it for any specific item of input until the user actually types it in."
16:11:50 <shapr> Is he talking about pre-monad continuation(?) input?
16:11:59 <skew> no, getContents
16:12:22 <blackdog> shapr: yi's keymap interface works that way too, doesn't it?
16:12:37 <Igloo> dan2: Right. The cards accumulate in the new pile; a Haskell idiom for this sort of thing is to use an accumulating parameter
16:12:58 <JohnMeacham> I'd start with a deck of double-sided cards and just flip it over.
16:13:01 <dan2> Igloo: whats that
16:13:06 <SyntaxNinja> JohnMeacham: heh
16:13:18 <Igloo> dan2: So we write a function that takes both the cards left to be reversed and the accumulating parameter, and returns the reversed list
16:13:59 <Igloo> dan2: So if we run out of cards left to be reversed, then the acc param (equivalent to the second pile you created) is all the cards reversed, i.e.   foo [] acc = acc
16:14:13 <SamB> JohnMeacham: the problem with those is that the other players can see your cards if you use those
16:14:20 <dan2> Igloo: I see
16:14:28 <Igloo> dan2: So can you work out what you would do when at least one card still remains? i.e. what is   foo (x:xs) acc = ?
16:15:19 <dan2> Igloo: not sure
16:15:51 <Igloo> dan2: OK, take a concrete example, foo (1:2:3:[]) []
16:16:20 <dan2> hold a sec
16:16:23 <dan2> I'm thinkingt
16:16:28 <Igloo> OK
16:17:00 <dan2> reverselist [] acc = acc
16:17:00 <dan2> reverselist (x:xs) acc = reverselist xs ([x] ++ acc)
16:17:02 <dan2> ?
16:17:29 <Igloo> Right, although you can write   [x] ++ acc   as just   x:acc
16:17:38 <dan2> oh alright
16:18:02 <Igloo> And you would normally have an outer function that just says   reverselist xs = foo xs []
16:18:04 <dan2> Igloo: does the compiler optimize it to the same form either way
16:18:11 <Igloo> No
16:18:25 <dan2> I mean use ++ or :
16:18:26 <Igloo> Oh, wait, you mean [x] ++ acc? Probably
16:18:45 * Igloo thought you meant your original reverse function, sorry
16:18:57 <dan2> hmm
16:19:06 <dan2> can I overload the function so it can accept a version with only one parameter
16:19:10 <Igloo> Actually, I'm not sure it will, but it's a tiny overhead
16:19:16 <Igloo> No
16:19:34 <Igloo> But you can make foo local by putting it in a let binding or a where clause
16:19:48 <mauke> huhu, each function accepts only one parameter
16:20:41 <mauke> you'd need to overload the return value based on context. can typeclasses do this?
16:21:33 <dan2> Igloo: the irony is that, I think this is still slower than left right
16:21:39 <blackdog> dan2: basically, don't do this. it's major type theory artillery and it's not necessary.
16:22:06 <dan2> Igloo: because left/right ends up with n/2 in loop times
16:22:15 <dan2> this is linear
16:22:33 <Igloo> The acc param solution is linear too
16:22:43 <dan2> yes, I know
16:23:11 <Igloo> The left/right one does 3 operations n/2 times
16:24:09 <dan2> Igloo: well.... that could be debatable, since it might be thrown in registers and swapped there
16:25:10 <dan2> Igloo: this method also requires the creation of another array
16:25:14 <dan2> (accu method)
16:26:07 * Igloo doesn't have time to go into this now
16:26:23 <blackdog> dan2: you're talking micro-optimisation a bit early, i think.
16:26:52 <blackdog> the basic assumption of most code in haskell is that you don't change things in-place.
16:27:27 <blackdog> which means you'll quite often create temporary data structures. They might get optimised away, they might not, but wait tilli they're actually a performance problem before you start fretting. :)
16:30:04 <dan2> well I was seeing _decent_ performance on logarithmic fibonacci
16:30:11 <dan2> in haskell with optimizations turned on
16:30:28 <SamB> what is decent performance on fibonacci?
16:30:37 <SamB> since when is fibonacci usefull?
16:30:41 <mauke> O(1)
16:30:56 <SamB> mauke: heh
16:30:58 <dan2> SamB: fibonacci search is my prefered over binary search tree
16:31:15 <dan2> anybody going to care if I paste it all here
16:31:19 <shapr> @paste
16:31:21 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:31:26 <SamB> oh, I thought you were talking about something else
16:33:04 <shapr> In my opinion, changing the abstractions used is the most effective optimization.
16:33:36 <dan2> alright pasted
16:33:37 <dan2> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
16:34:19 <shapr> fib = 0 : 1 : zipWith (+) fib (tail fib)
16:34:50 <dan2> thats so slow its not even funny
16:34:58 <shapr> What's so slow?
16:35:03 <dan2> thats linear
16:35:35 <SamB> dan2: linear is downright fast
16:36:01 <blackdog> dan2: it computes a list of fibs - you can amortise it
16:36:04 <dan2> SamB: logarithmic is fucking speed then
16:36:08 <dan2> :)
16:36:22 <Igloo> blackdog: Only if you want all of them
16:36:29 <SamB> how can you do it logarithmic without cheating?
16:36:38 <dan2> SamB: http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
16:37:02 <blackdog> SamB: you cheat
16:37:05 <blackdog> with maths.
16:37:07 <dan2> fib(n)^2 + fib(n+1)^2 = fib(2n+1)
16:37:59 <blackdog> dan2: what do you use it for? I haven't heard of fibs being used in search trees.
16:38:32 <dan2> blackdog: http://www.auto.tuwien.ac.at/~blieb/woop/fibsearc.html
16:40:12 <blackdog> I'm missing some intuition here. Why is it more precise to use fibs?
16:40:51 <dan2> blackdog: the guessing is more logical
16:41:18 <blackdog> but why?
16:41:34 <blackdog> how can you do better than the middle of the array?
16:42:00 <dan2> blackdog: fibonacci is able to discard more data at a time
16:42:01 <SamB> blackdog: it starts in the middle anyways
16:43:42 <blackdog> dan2: it can throw away more than half the array?
16:44:01 <dan2> blackdog: it subtracts distances between fibonacci numbers
16:44:01 <Igloo> It's been too long since I did this, but I think it's merging 2 heaps together when fib helps
16:44:51 <skew> I remember something about storing a heap as a forest of fibbonacci sized trees so inserts and deletions don't result in cascading changes
16:45:34 <JohnMeacham> Because the minimum is more likely to be closer to the smaller of your two endpoints.
16:49:19 <dan2> an even faster way to calculate fibonacci is using sqrt(5)
16:49:22 <dan2> (((1+sqrt(5))**6-(1-sqrt(5))**6)/(sqrt(5)*2**6))
16:49:32 <dan2> in this case, swap 6 for the fibonacci number
16:49:56 <dan2> then truncate the result
16:50:24 <dan2> the problem with this is it depends on a floating arithmetic library
16:50:37 <dan2> and wouldn't work for numbers say 200000
16:51:03 <dan2> but for a fibonacci search, its probably what I'd use
16:53:35 <dan2> how would I memoize a function in haskell
16:54:23 * SamB wonders what happened to his /dev/net/tun
16:54:28 <dan2> modprobe tun
16:55:05 <SamB> I'm actually missing /dev/net, too
16:55:16 <SamB> and I' checked
16:55:34 <SamB> s/I'/'m not using devfs -- I/
16:55:43 <SamB> err, whatever
16:56:04 <dan2> use udev like the rest of us
16:56:44 <SamB> oh, maybe I am
16:57:03 <dan2> CosmicRay: hey
16:57:09 <CosmicRay> egening dan2
16:57:15 <CosmicRay> err evening
16:57:19 <SamB> using udev, that is
16:57:32 <SamB> yes, I am
16:57:49 * SamB just upgraded to 2.6
17:02:06 <JohnMeacham> yeah, devfs was obsoleted before it even got stable :)
17:02:32 <CosmicRay> well.  in two hours, tailor.py has processed only one year of fptools history :-)
17:10:26 <shapr> Greetings scaldwell
17:10:36 <scaldwell> hi
17:10:59 <shapr> Learning Haskell? long time user?
17:11:46 <Igloo> CosmicRay: Do you know why it's slow?
17:11:49 <Touqen> Actually, I've been idling here for weeks.
17:12:06 <shapr> Touqen: I know, but I thought I'd ask you anyway.
17:12:09 <Igloo> (or is it not slow? How many patches does that mean?)
17:12:13 <shapr> You haven't said so much :-)
17:12:18 <Touqen> Heh.
17:12:22 * shapr invites participates
17:12:31 <shapr> er 'participation'
17:12:32 <Touqen> Yea. I've been meaning to learn but I've been distracted lately.
17:12:36 <SamB> @dict participates
17:12:37 <lambdabot> Supported dictionary-lookup commands:
17:12:37 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock
17:12:37 <lambdabot>  @jargon @lojban @prelude @vera @web1913 @wn @world02
17:12:37 <lambdabot> Use "@dict-help [cmd...]" for more.
17:12:46 <SamB> @all-dict participates
17:12:48 <lambdabot> No match for "participates".
17:12:57 <shapr> SamB: Sorry, I'm asleep... it was a typo on my part.
17:13:30 <SamB> shapr: I have not known many who could do as well
17:13:36 <SamB> (asleep)
17:13:38 * shapr invites precipatate
17:13:59 <shapr> That one is a real word :-)
17:14:07 * SamB throws salt at shapr
17:14:32 <Igloo> participates is a real word too, just not a root form
17:14:39 <shapr> If you're not part of the solution, you're part of the precipatate.
17:14:50 <JohnMeacham> Ack. S Alexander isn't a troll is he?
17:14:58 <shapr> Not purposefully, I think.
17:15:06 <shapr> I still don't get point 4 though.
17:16:02 <skew> @devils participate
17:16:04 <lambdabot> No match for "participate".
17:16:06 * SyntaxNinja is scared to check mail
17:16:09 <JohnMeacham> I think he is just reading stuff into the haskell report that isn't there. He is taking the absence of a specification of how module names are mapped to code as a specification that there should be NO external mapping system.
17:16:30 <shapr> He has an original interpretation of many things.
17:16:37 <CosmicRay> Igloo: the tailor.py process is using a lot of cpu
17:16:38 <JohnMeacham> rather than the correct interpretation, that it is up to the implementation.
17:16:40 <CosmicRay> Igloo: I don't know why
17:16:55 <SamB> doesn't Heirarchical spec specify explicitly in the affirmative?
17:17:04 <SyntaxNinja> JohnMeacham: as someone who probably recently read the report, maybe you should follow up ;)
17:17:11 <SyntaxNinja> if you want to start getting CC'd a lot.
17:17:12 <JohnMeacham> I just did.
17:17:15 <shapr> JohnMeacham: I haven't understood his point yet. Though I do understand what malcolm explained to me.
17:17:18 <CosmicRay> Igloo: also it calls cvs individually on each file in each changeset
17:17:44 <JohnMeacham> I believe I have figured out his misunderstanding, but not his point :) but we shall see.
17:17:50 <SyntaxNinja> oh JohnMeacham. thanks.
17:17:54 <Igloo> CosmicRay: OK, if calls to darcs aren't the dominating factor then I'm not really interested  :-)
17:17:55 <SamB> CosmicRay: profile tailor.py somehow!
17:18:09 <CosmicRay> SamB: I don't care that much :-)
17:18:23 <CosmicRay> Igloo: heh, I was trying to figure out why you were interested
17:18:35 <CosmicRay> SamB: I plan to do this once, really
17:18:39 * SyntaxNinja has seldom found much of a 'point' left over after all misunderstandings are removed
17:19:45 <SamB> yeah, points based on misunderstandings are not generally very pointed
17:20:01 <SyntaxNinja> SamB: good point ;)
17:20:29 <JohnMeacham> The Hierchical Modules report does contain a section about how it maps to the filesystem, but it specifically says that this is not a part of the specification and just a possible implementation.
17:20:46 <SyntaxNinja> JohnMeacham: that's interesting. I didn't realize that.
17:20:53 <JohnMeacham> This is why I felt okay about jhc breaking it :)
17:21:03 <SamB> nobody is crazy enough to implement it elsehow, though
17:21:16 * SamB likes to make up words
17:21:20 <CosmicRay> SamB: some crazy people hang out here
17:21:30 <SyntaxNinja> haha
17:21:43 <JohnMeacham> For Control.Monad.Writer jhc accepts Control/Monad/Writer.hs, Control/Monad.Writer.hs, or Control.Monad.Writer.hs
17:22:14 <skew> CosmicRay: kcachegrind with hotshot2cachegrind is nice for profiling python, and the only way I know of to use the line-level events
17:22:44 <SamB> okay, so nobody is crazy enough to implement the "read in everything and sort it out after" method
17:23:06 <SamB> because it would be so very inconvenient
17:23:22 <skew> what method is that?
17:23:36 <skew> read the entire filesystem and compile all the Haskell you can find?
17:23:37 <JohnMeacham> so not that different. The main use is so that you can easily distribute single modules from web sites named something like Data.Tree.hs and people can just drop it in their source dir rather than worrying about creating the appropriate subdirectories. I find it is also sometimes more clear when you have a deep hiearchy with only a single module at the end.
17:24:29 * SamB can imagine a C program supporting that style by accident
17:25:15 <JohnMeacham> (or when using a broken version of autoconf that can't deal with subdirectories)
17:25:16 <shapr> JohnMeacham: yeah, I agree.
17:25:19 <SamB> skew: not quite the entire fs
17:40:59 <dons> @yow
17:41:00 <lambdabot> I'm a nuclear submarine under the polar ice cap and I need a Kleenex!
17:41:18 <musasabi> The Foo.Bar.Baz.hs is a very nice thing/
17:41:35 <SyntaxNinja> (17:21:25) SamB: nobody is crazy enough to implement it elsehow, though
17:45:14 <skew> (17:21:16) JohnMeacham: This is why I felt okay about jhc breaking it :)
17:47:26 <Lemmih> 03:39 < dons> @yow
17:47:45 <SyntaxNinja> :)
17:48:02 * Lemmih is now a member of the paste-random-quotes-from-irc group.
17:48:45 <skew> We were actually pasting carefully selected quotes :)
17:49:47 <skew> I was amused that SamB said "nobody would be crazy enough ..." after JohnMeacham already said he had :)
17:50:22 <dons> you people are strange
17:50:25 <SamB> skew: it still maps names to modules!
17:50:43 <SamB> by filename
17:50:45 <skew> oh, filenames to module names
17:50:48 <skew> I see
17:51:12 <skew> but there's really no other place to get the package structure
17:51:15 <dons> @uptime
17:51:16 <lambdabot> uptime: 21 hours, 4 minutes and 42 seconds
17:51:25 <skew> unless you can write "module Data.Tree where"...
17:51:35 <skew> and then you can scatter the code all around the filesystem
17:52:05 <skew> I wonder how O'Caml handles things
17:52:34 <SamB> as most of you are probably aware, C and Lisp and Scheme do not handle things
17:52:46 * SyntaxNinja hands a handle to SamB
17:53:30 <SamB> SyntaxNinja: I mean modulename->path mapping
17:54:19 <SyntaxNinja> yeah.
17:54:29 <SyntaxNinja> that doesn't mean that Haskell shouldn't ;)
17:54:56 <SamB> and Java, Python, and most Haskell implementations do it in basicly the obvious way
17:55:32 <SamB> and Smalltalk has neither files nor modules anyway
17:56:14 <skew> I kind of like the idea of running some kind of updatedb-like program every night to crawl the filesystem and update the module->file mapping database
17:57:57 <SamB> skew: so you don't ever create new modules?
17:58:19 <skew> oh, you would probably have some delimited form you could run
17:58:50 <skew> I meant nice as in webserver-written-in-postscript, not nice to use :)
17:59:09 <SamB> ah
18:00:20 <skew> but I don't know how else to handle multiple modules defined in a file (which is why I mentioned O'Caml)
18:00:52 <skew> Not that that is necessarily something we want in Haskell
18:02:25 <blackdog> unless modules are first class objects, there doesn't seem much point
18:03:08 <skew> blackdog: I think it makes sense for O'Caml because they use modules and functors where we use classes and instances
18:04:32 <blackdog> skew: exactly. if it can be defined and passed around, if it's dynamic, you should be able to define it anywhere. if it's static, it's a bit pointless.
18:05:36 <blackdog> not to say that there's anything wrong with being pointless.
18:05:36 * blackdog averts wrath of lambdabot
18:05:38 <skew> blackdog: are you familiar with OCaml?
18:06:07 <skew> I'm pretty sure the modules are a compile-time thing
18:22:43 <Cale> How is Control.Exception.evaluate implemented? Is it primitive?
18:24:48 <dons> evaluate :: a -> IO a
18:24:48 <dons> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
18:26:51 <JohnMeacham> I always wanted an evaluateWithStats:: a -> IO (a,Stats) where Stats had things like the number of reductions performed and memory allocated.
18:27:38 <Jerub> I'm trying to build yi ( http://www.cse.unsw.edu.au/~dons/yi.html )
18:27:42 <Jerub> but it gives me an error:
18:27:45 <Jerub> ghc-6.2.2: unknown package name: plugins
18:28:03 <mauke> is there a built-in "replace" function?
18:28:06 <mauke> something like replace a b = map (\x -> if x == a then b else x)
18:28:33 <beschmi> Jerub: do you have installed hs-plugins?
18:29:41 <mauke> @pointless \a b -> map (\x -> if x == a then b else x)
18:29:42 <lambdabot> (map .) . flip flip id . (s .) . flip . (if' .) . (==)
18:29:47 <mauke> haha
18:31:16 <Jerub> I don't see hs-plugins in my apt repository
18:31:20 <Jerub> where can I download them?
18:31:37 <dons> @google hs-plugins
18:31:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:31:48 <Jerub> hah
18:31:50 <Jerub> that'd be right
18:32:11 <dons> if you just want to try out yi, then build: make way=static
18:32:18 <dons> and you don't need hs-plugins.
18:32:42 <dons> (you won't be able to dynamically reconfigure anything, but that's ok if you're just trying it out)
18:32:54 <Jerub> dons: I'm a hardcore vim user.
18:33:14 <Jerub> dons: will Yi be useful to me, do you think?
18:34:07 <dons> not yet. but it does a pretty good vim so faar
18:34:19 <dons> in a few months it'll be more useful (I'm a hardcore vim user too)
18:34:30 <Jerub> good
18:34:33 <dons> for one, there's no syntax highlighting yet.
18:34:41 <Jerub> i'm capable of reading and writing haskell too ;)
18:34:42 <dons> but you can get a feel of the thing
18:34:45 <dons> cool!
18:34:48 <dons> send patches!
18:34:58 <dons> check out the vim and vi modes, and see what you think.
18:35:08 <dons> ./yi-static --as=vim or --as=vi
18:35:19 <Jerub> I would have switched to emacs years ago if emacs had a vim mode.
18:35:33 <Jerub> (i'm building your plugins, so it'll be non-static)
18:35:46 <dons> ok. make sure to 'make install ; make register'
18:35:50 <Jerub> okay
18:36:01 <Jerub> make install register; should work too
18:36:03 <Jerub> ;)
18:40:48 <dons> everything working?
18:41:18 <Jerub> dons: unfortunately, my new machine hasn't arrived yet.
18:41:22 <Jerub> so I'm still compiling.
18:45:24 <JohnMeacham> Does yi run into the same FFI bug ginsu does with ghc 6.4?
18:49:19 <dons> what bug's that?
18:49:24 <dons> haven't seen anything yet.
18:51:23 <maXlo> hi
18:51:50 <maXlo> does anyone one knows where is the ':' operator definded? is it an internal operator?
18:52:10 <maXlo> I need to do pattern matching similar to x:xs. i need something like xs:x, i.e., tail(list) : head(list)
18:52:30 <Jerub> dons: I'm already finding bugs.
18:52:32 <Jerub> dons: this is fun!
18:52:43 <Jerub> maXlo: : is known as 'cons
18:52:52 <Lemmih> maXlo: Why would you do that?
18:52:54 <dons> data [] a = [] | a : [a]
18:53:35 <maXlo> Lemmih: i need to do right-recursion, it is not _estrictly_ necessary, but i would prefer it
18:53:40 <maXlo> so far i have done:
18:53:49 <Jerub> and I'm already finding features I need to implement.
18:53:51 <Jerub> dons: I love you.
18:53:51 * dons -> gotta run. Jerub, send a bug report, or even better - tweak Yi/Keymap/Vim.hs and darcs send
18:53:54 <maXlo> function [] = something
18:54:07 <dons> Jerub, thank you :)
18:54:25 <maXlo> function xs = .. ys .. y
18:54:25 <maXlo>         where y =last xs
18:54:25 <maXlo>                   ys = init xs
18:54:49 <maXlo> Jerub: didnot undertand you
18:56:15 <Jerub> maXlo: the : thingy
18:56:19 <Jerub> it's called "cons"
18:56:43 <maXlo> ah, ok
18:57:14 <maXlo> so, the question is, how can i define a similar cons operator? i need to do pattern matching, but not as cons does
18:57:25 <Lemmih> Reverse the list.
18:57:46 <maXlo> no, that's to expensive
18:58:20 <maXlo> i just simply thaught that there should exist a dual ':' operator
18:58:43 <Lemmih> So is continously taking the last element.
19:00:05 <Lemmih> *continuously
19:00:27 <maXlo> yeap, that's true
19:00:49 <maXlo> so, the x:xs pattern matching is faster, correct/
19:00:57 <maXlo> correct? *
19:00:57 <JohnMeacham> reversing a list is the same complexity as last.
19:01:09 <JohnMeacham> but you only have to do it once.
19:01:38 <maXlo> yeap, true
19:01:49 <maXlo> ok, thanks you all.
19:01:57 <JohnMeacham> dramatically faster. pattern matching is a constant operation. last is O(n) where n is the size of the list. not only that, but now you got this evaled list in memory...
19:02:14 <maXlo> go 2 sleep now :)
19:02:18 <maXlo> mmm
19:02:28 <maXlo> doesnt it depends on the list implementation?
19:02:30 <maXlo> i mean,
19:03:05 <JohnMeacham> Lists in haskell are exactly implemented as data [x] = x : [x] | []
19:03:10 <maXlo> if the list has a pointer to head(list) and a pointer to last(list)... you get O(1) for xs:x pattern matching...
19:03:34 <maXlo> ok then. i see...
19:03:46 <maXlo> well, thanks a lot
19:03:49 <maXlo> good night
19:05:38 <JohnMeacham> Anyone have any hard data on the speed of Data.IntMap vs Data.Map? I stopped using IntMap when the class assosiated types paper came out, assuming the performance would eventually magically come back. I am just curious how much I pay for this.
19:25:59 <JohnMeacham> Yay. jhc now has basic "pre-compiled" library support. This should help people on smaller machines that don't want to go through the bootstrap process.
19:55:36 <musasabi> JohnMeacham: IntMap was iirc faster.
19:55:56 <musasabi> but things are not very simple.
19:56:02 <JohnMeacham> Yeah, I was just curious how much faster.
19:56:28 <musasabi> I think it was noticeable.
19:56:46 <musasabi> but I don't have the numbers at hand and it is 05:58 am...
19:59:05 <musasabi> How hard would it be to make "import IO" to work?
19:59:27 <musasabi> it was dying somewhere in the libraries...
19:59:48 <JohnMeacham> I just noticed that was broken a few minutes ago. shouldn't be hard, it used to work. I just need to figure out how I broke it.
20:03:13 * musasabi tries sleeping for a few hours 
20:11:53 <JohnMeacham> Hmm.. it is not realising Ptr is a newtype of Addr.
20:15:45 <SamB> JohnMeacham: what isn't? jhc's optimizer?
20:26:39 <JohnMeacham> It's just a bug in jhc. sorry, I was rambling to myself.
20:32:17 <JohnMeacham> musasabi: Okay! IO bug fixed with latest patch (the one about passing the full data table)
20:33:39 <JohnMeacham> Actually, that fike
20:33:52 <JohnMeacham> fixed another bug too. excellent.
20:37:33 <mauke> @pointless \a b -> compare (length a) (length b)
20:37:34 <lambdabot> (. length) . compare . length
20:38:07 <skew> mauke: I think it's worth writing a function for that patter
20:38:32 <skew> \a b -> g (f a) (f b) is also useful for sortBy, and some other stuff
20:39:49 <JohnMeacham> I was just thinking it was because taking the length of both lists will fully evaluate both, when in actuality you only need to evaluate up to one past the length of the shortest one to determine the answer.
20:40:51 <mauke> JohnMeacham: in this case I don't really care because the lists are known at compile time
20:40:59 <skew> Hah, even unintended interpretations of my suggestions are correct :)
20:41:29 <skew> I'm not sure what to call the combinator, though
20:41:36 <skew> sortBy (compare `on` length) ?
20:42:05 <JohnMeacham> on = ?
20:42:23 <skew> on binop f = \x y -> binop (f x) (f y)
20:42:42 <JohnMeacham> Ah. I see. cool. will add that to GenUtil
20:43:12 <skew> I'm not sure that's a very good name
20:43:20 <heatsink> on = S
20:43:28 <skew> !
20:43:35 <heatsink> oh, I missed something
20:43:55 <skew> anyway, S is almost certainly a worse name
20:43:57 <mauke> sBy :-)
20:44:00 <heatsink> (on a b c d) = a $ s b c d
20:44:03 <Pseudonym> @pointless \binop f x y -> binop (f x) (f y)
20:44:05 <lambdabot> flip s id . ((flip . ((.) .)) .) . (.)
20:44:10 <Pseudonym> Just use that.
20:44:15 <heatsink> :)
20:44:20 <skew> unless, like me, you are coming to Haskell from Unlambda :)
20:44:51 * heatsink has some unlambda background.
20:44:54 <Pseudonym> @type \binop f x y -> binop (f x) (f y)
20:45:00 <lambdabot> \binop f x y -> binop (f x) (f y) :: forall t t1 t2.
20:45:00 <lambdabot>                                      (t -> t -> t1) -> (t2 ->
20:45:00 <lambdabot> t) -> t2 -> t2 -> t1
20:45:44 <JohnMeacham> unlambda has too much syntatic sugar. I prefer http://ling.ucsd.edu/~barker/Iota/
20:46:40 <skew> The richer semantics of Unlambda makes writing an interpreter more interesting
20:46:45 <SamB> sugar?
20:47:15 <SamB> I thought unlambda programs were 50% syntactical thistles!
20:49:27 <JohnMeacham> I always wanted to design a PLCC to execute Jot programs, then set it running on all possible ones, eventually converging (at infinity) to the value of omega.
20:51:16 <JohnMeacham> Or, as i call it "Lothar the innumerable one"
20:52:21 * SamB can't understand how you are supposed to do the fibonaccian search for array sizes not in the fibonacci sequence
20:52:30 <SamB> s/can't/doesn't/
20:52:54 <heatsink> wow, "syncategorematically"... another word that sounds like it doesn't mean anything, but does.
20:53:14 <SamB> @all-dicts syncategorematically
20:53:16 <lambdabot> No match for "syncategorematically".
20:54:02 <skew> I still don't get the point of searching from a fibbonacci pattern. What kind of problem and input distribution are we assuming?
20:54:35 <JohnMeacham> finding the minima of a continuous function.
20:54:52 <JohnMeacham> it is slightly better than just always using the golden ratio.
20:55:28 <JohnMeacham> I belive "Numerical Recipes" has a chapter on this sort of thing.
20:55:43 <skew> Oh, for function minimization it makes sense
20:55:54 <skew> at least, some kind of offset thing
20:56:29 <SamB> I don't see it either, actually.
20:56:43 <skew> I thought the same code was about searching in an ordered array
20:56:56 <SamB> it seems to be only slightly faster than a uniform binary search (whatever that may be), and then only sometimes
20:57:18 <SamB> I gave up on that webpage...
20:57:26 <SamB> I couldn't really decipher the code
20:57:49 <SamB> the (Fn-?) stuff didn't make sense to me
20:58:08 <SamB> and the language was confusing
20:58:41 <SamB> I googled it and found a reference to Knuth, section 6.2.1
20:58:50 <skew> there is a theorem about minimizing functions from gridpoints to the unit interval that says every algorithm does an equally good job of finding the minimum, on average
20:59:36 <skew> I think it's about algorithms that examine all the neighbors of their position and pick a direction to move
21:00:19 <SamB> I think nobody uses the fibonaccian search because the setup is complicated
21:00:36 <skew> the idea is that a random function is spiky and strange enough that a hill climber has just as much chance of discovering the minimum when it is peeking at its neighbors as a hill climber does of finding it on purpose
21:01:23 <skew> that should be a hill descender trying to find the minimum on purpose
21:01:28 <SamB> wouldn't it be a valley descender?
21:03:44 <JohnMeacham> Optimization in discrete space (where you only have certain gridpoints to consider) is much much more difficult than when you are just dealing with straight functions with continuous domains.
21:03:44 <skew> I suppose it would be both
21:05:01 <skew> Yes, which is why I thought it didn't make much sense to do anything for searching a sorted array other than optimizing your worst case bound with a binary search
21:06:44 <SamB> why blow up your brain on something that may or may not save you a few cycles?
21:07:16 <SamB> especially if it only actually saves cycles on an obsolete imaginary computer?
21:07:59 <SamB> which has been replaced with a "modern", even more imaginary computer?
21:08:46 <Pseudonym> skew: That depends, actually.
21:08:48 * SamB doesn't know of a usable implementation with kernel-space
21:08:57 <JohnMeacham> Actually, I do this for work optimizing stock portfolios, and it can make a signifigant difference.
21:09:11 <Pseudonym> If you have a memory hierarchy, then, reducing cache I/Os pays.
21:09:42 <JohnMeacham> finding the minima of complex functions I mean.
21:09:42 <Pseudonym> But how you can do that depends on your data.
21:09:53 <Pseudonym> I'm talking about searching arrays.
21:10:02 * SamB too
21:10:12 <JohnMeacham> I see.
21:10:56 <Pseudonym> If it matters that much, building a simple B-tree over your array might be enough.
21:11:06 <SamB> Chapter 6 of TAoCP is on "Searching", you know.
21:11:18 <Pseudonym> Yes.
21:11:22 <skew> Pseudonym: sure (same for data from disk too), but I mean there's no point trying to take advanage of fancy structure in your array
21:11:28 <Pseudonym> Though I don't think TAoCP talks about memory hierarchies that much.
21:11:32 <skew> Not unless you assume it's there
21:11:34 <Pseudonym> skew: Well, it depends.
21:11:39 <Pseudonym> Right.  Sometimes it IS there.
21:11:44 <Pseudonym> Here's an example.
21:11:46 <SamB> Pseudonym: I don't think they had been invented at the time of writing
21:11:59 <Pseudonym> If you're doing a merge phase.
21:12:01 <skew> But you can't say "this is faster for a nice distribution, so it must be better for all possible input"
21:12:02 <Pseudonym> e.g. merge sort
21:12:23 <Pseudonym> Then sometimes it makes sense to just linearly scan both arrays, and sometimes it makes sense to binary search.
21:13:35 <skew> binary search?
21:13:39 <Pseudonym> SUre.
21:14:04 <Pseudonym> If list A is much shorter than list B, it can make sense to binary search in B for the head element of A.
21:14:22 <skew> Oh
21:15:09 <Pseudonym> I had to solve a performance problem related to this recently.
21:15:10 * SamB would compare the heads first
21:15:13 <Pseudonym> In our database server.
21:15:22 <skew> I'm writing a cute little program for working with substitution ciphers
21:15:33 <Pseudonym> What I ended up doing is linearly searching for N elements, and then if you don't find it, binary search.
21:15:38 <Pseudonym> Where N ended up being about 16.
21:15:44 <SamB> ah
21:15:47 <Pseudonym> Because linear searches tend to compile into very tight loops.
21:16:02 <Pseudonym> skew: Any particular reason?
21:16:05 <Gahhh> linear searches also have nice cache access
21:16:05 <Pseudonym> Or just for fun?
21:16:09 <Pseudonym> Right.
21:16:13 <SamB> true
21:16:37 <Pseudonym> But you want sublinear search time when you can.
21:16:41 <Gahhh> I spent a whole week on a mathematical proof to linearize memory access for an algorithm. It's worth it :)
21:16:41 <Pseudonym> In some applications.
21:17:09 <SamB> Gahhh: did you suffer head-explosion?
21:17:50 <Gahhh> SamB: No, I do that sorta stuff pretty regularly. I felt dumb, tho, coz it took me too long. Blah.
21:18:14 <skew> tr works reasonably well, but I thought it would be neat to distinguish unsubstituted ciphertext and characters that you've guessed with color or something
21:18:28 <Pseudonym> Ah, cool.
21:18:28 <SamB> Gahhh: what are you comparing yourself to? geniuses?
21:18:33 <Gahhh> skew: what evil application are you writing ?
21:18:35 <Pseudonym> I usually use just upper and lower case.
21:18:41 <Pseudonym> On the occasions that I do this.
21:18:50 <skew> That doesn't work so well when the ciphertext uses uppercase and lowercase already
21:19:03 <Pseudonym> That's true.
21:19:07 <Pseudonym> But in my case, it doesn't.
21:19:08 <Gahhh> SamB: hardly. It was college level but I was losing myself in the paper.
21:19:18 <skew> it turned out the plaintext was some C, so they needed some characters for {} and = and whitespace
21:19:36 <dbremner> Gahh - what sort of applications do you write?
21:19:53 <Pseudonym> I've been working on ways to defeat incidence counting in old-school cyphers.
21:20:02 <Pseudonym> So you generally use only letters.
21:20:12 <skew> I found a nice-sounding C program that would do dictionary searches and things, but it was apparently WRITTEN FOR DOS AND IGNORED CASE DISTINCTIONS.
21:20:32 <Gahhh> dbremner: signal processing functions for my company.
21:20:34 <SamB> skew: english!
21:20:37 <SamB> not dos.
21:20:49 <skew> whatever
21:20:51 <SamB> also, classic, caseless ciphers.
21:20:58 <skew> not written for code anyway
21:21:12 <SamB> if it was written for DOS, it would have been an .exe!
21:21:26 <skew> well, it came in a zip file with uppercase names
21:21:27 <Pseudonym> Or a .BAT
21:21:40 <Gahhh> or a .com
21:21:40 <SamB> Pseudonym: bats can't do that
21:21:46 <Spark> there was no difference between the .com .bat and .exe handling was there
21:21:48 <skew> I guess it was portable
21:21:50 <Spark> either of them would cause it to execute
21:21:54 <Spark> and then it would work out what it was
21:21:55 <dbremner> Gahh - I'm curious, because the idea of proving linear memory access intrigues me. Any reading suggestions?
21:21:56 <Spark> or something like that
21:21:59 <Gahhh> .bat had precedence
21:22:02 <skew> SamB: what about a recursive .bat ?
21:22:02 <SamB> Spark: .com .bat and .exe are all different formats
21:22:11 <dbremner> Spark - the order of execution was .com, .exe, .bat, IIRC.
21:22:14 <Spark> SamB: not talking about formats
21:22:15 <SamB> skew: I kind of doubt it
21:22:26 <Pseudonym> main = do
21:22:32 <Pseudonym>        dict <- fmap lines . readFile $ "dict"
21:22:35 <Pseudonym> :-)
21:22:43 <Pseudonym> That's from my program.
21:23:01 <Pseudonym> You can probably guess the rest.
21:23:08 * SamB would say .bat, .com, .exe, or maybe .bat, .exe, .com
21:23:27 <Gahhh> dbremner: This was very specific to the proposed algorithm. It was not a general proof. I just demonstrated that I could very closely approximate the same value with a linear traversal of memory.
21:23:34 <dbremner> SamB - .com is before .exe, because that's how spawning viruses work.
21:23:52 <SamB> dbremner: ah
21:24:11 <SamB> that would be a *lot* easier than injecting code into the .exe
21:24:16 <Gahhh> Bill Gates would be proud if he saw all of us trying to remember DOS program execution precedences...
21:24:32 <SamB> Gahhh: of what?
21:24:48 <Gahhh> SamB: His work ?
21:24:52 <SamB> he wants everyone on longhorn yesterday, doesn't he?
21:25:32 <dbremner> SamB - infecting .com files was relatively straightforward. IIRC, you just copied the first 7 bytes and then overwrote it with a jump to the start of the virus code.
21:25:38 <SamB> anyway, gates didn't even write DOS
21:26:02 <SamB> dbremner: first 7?
21:26:09 <SamB> that sounds excessive
21:26:53 <Gahhh> infecting files is straightforward if you have permission to modify it :)
21:27:12 <dbremner> SamB - 3 bytes, my bad.
21:27:15 <SamB> Gahhh: exe format is complicated isn't it?
21:28:10 <Gahhh> SamB: It is not. See UPX, the compressors for executables
21:28:58 <Gahhh> I should write something in haskell...
21:28:59 <skew> is there a library function for unescaping characters in a string?
21:29:18 <SamB> Gahhh: don't EXEs have sections and segments and such complicated things?
21:29:30 <SamB> not that sections by themselves are very complicated
21:29:55 <Gahhh> SamB: Right, it's not trivial bulk loading of data. But it's not supposed to create a nightmare for the loader of the OS, either.
21:30:04 <SamB> true
21:31:09 <lispy> i'm not familiar with exe and com but i looked at elf once.  I thought it was pretty complicated
21:31:18 <SamB> I wonder about the relative complexity for PE, COFF, and ELF
21:31:34 <SamB> (that is, for infecting them)
21:31:37 <Gahhh> I believe PE is almost exactly the same as COFF
21:31:42 <Gahhh> oops
21:31:44 <SamB> maybe
21:31:46 <Gahhh> I meant the object format
21:31:47 <Gahhh> not the exe
21:31:57 <SamB> I think they call that OBJ
21:32:02 <SamB> but I don't know
21:32:07 <Gahhh> Yeah, but it's 99% coff compliant
21:32:29 <Gahhh> innovative micros... never mind.
21:33:19 <SamB> did you know .lib files are apparantly the same as ar archives?
21:33:36 <Jerub> which are the same as what .deb uses ;)
21:33:52 <SamB> Jerub: well true, but that is advertised
21:34:28 <Gahhh> Yeah, but dll's are quite different from .so's
21:34:30 <SamB> % file /home/naesten/_/dxsdk/lib/ddraw.lib
21:34:30 <SamB> home/naesten/_/dxsdk/lib/ddraw.lib: current ar archive
21:34:44 <SamB> Gahhh: true!
21:34:58 <SamB> I suppose it is a good thing, really
21:35:15 <SamB> symbol collisions would be SO painful if in a closed-source setting
22:23:56 <Gahhh> Isn't a traditional GUI an ad-hoc implementation of an interpreter for an informally defined language ?
22:24:48 <skew> that sounds about right
22:26:31 <hefner> what isn't?
22:28:04 <Gahhh> gzip isn't, imho. It has no grammar. Strictly input -> output.
22:28:33 <skew> the gzip format is pretty well specified
22:28:53 <Gahhh> I mean the user land grammar.
22:29:07 <skew> try talking to it yourself sometime, and see what it thinks of your grammar
22:29:15 <Gahhh> You don't ask yourself "could I gzip this file or not".
22:30:00 <skew> well, in that sense a GUI doesn't exactly have grammar either
22:30:14 <Jerub> a GUI is often an event based model.
22:30:29 <Gahhh> Well, there are buttons you can press, and some are greyed out under some circumstances, etc.
22:30:32 <skew> you don't ask yourself whether it is possible to click the mouse when the pointer is over a particular pixel on the screen either, just whether the action has any effect
22:31:11 <Jerub> and, more formally.
22:31:23 <skew> It doesn't die with a message like "unexpected mouse press at (253,219), expecting mouse press at (252,220), (270,113), or (117,102)"
22:31:57 <Gahhh> Well, I was past the physical pixel level access. Assume there's a lexical analyzer that turns clicks into events.
22:32:09 <skew> but that gives me a great idea for an evil program
22:32:34 <skew> don't let anybody tell you Parsec isn't for making a GUI!
22:32:53 <Gahhh> There are already tools to autogenerate GUI's from XML files and such.
22:33:03 <Gahhh> thanks google.scholar.
22:33:13 <skew> that's not what I mean...
22:33:38 <Gahhh> ?
22:33:49 <skew> think Parser Event (IO ())
22:34:07 <Gahhh> I'm not familiar with Parsec
22:34:32 <skew> Okay, think of making a lazy list of user input events, and running that through a traditional parser
22:35:07 <Gahhh> ok
22:41:00 <Gahhh> If a GUI had a formal grammar, then you could in theory interface it from the command line as well. You would just pass in the clicks, etc.
22:42:05 <vdrab> Hi #haskell, a quick question. Is there a function that takes a tuple and an Int, and returns the Int'th element of the tuple?
22:42:16 <blackdog> just having a formal grammar wouldn't make it all that tractable...
22:42:34 <blackdog> vdrab: not in the general case.
22:42:53 <vdrab> blackdog: thought so. thanks.
22:42:55 <Gahhh> blackdog: formal grammar and a real interpreter, I mean.
22:42:56 <blackdog> you can't write a function that works over different-sized tuples.
22:43:24 <dbremner> Gahhh - looked at NeWS?
22:43:37 <blackdog> Gahhh: a mouse sends formally defined electrical signals, and a device driver is an interpreter... :)
22:43:51 <Gahhh> dbremner: No, that word is un-googleable. Link ? :)
22:44:07 <dbremner> Gahhh - Sun's Network Windowing System.
22:45:38 * blackdog is hot and sweaty and contrary. stupid aircon.
22:46:32 <dbremner> Gahhh - it uses an OO Postscript for widgets and programs can add widgets at runtime. It lost to X11.
22:47:21 <Gahhh> dbremner: I see. I was reading http://starynkevitch.net/Basile/NeWS_descr_oct_1993.html
22:47:30 <Gahhh> Oh well
22:48:32 <skew> vdrab: there's also a problem if different elements of the tuple have different types
22:49:13 <skew> foldr f x ls == mconcat (map f ls) x
22:49:50 <skew> am I missing a standard function for mconcat (zipWith f ls1 ls2) x ?
22:50:10 <dbremner> Gahhh - SGI was the only licensee.
22:50:14 <Jerub> isn't OSX using a pdf kinda thing
22:51:16 <dbremner> Jerub - yes. It uses Display PDF, an updated version of Display Postscript.
22:52:29 <Gahhh> dbremner: But from what I read, I still don't think that NeWS was describing the user interface with a grammar.
22:54:09 <skew> personally I would rather see text input as the default than try to script GUI actions
22:54:24 <dbremner> Gahhh - there's Adobe's declarative GUI libraries. http://opensource.adobe.com/
22:54:29 <Gahhh> skew: I'd rather have both being run by the same backend.
22:54:31 <skew> I think LyX is a great example for UI design
22:55:55 <skew> Gahhh: internally everything should translate to the same interface, emacs works that way I think, but calling the internal API of another program is not a nice way of hooking programs together
22:56:37 <Gahhh> skew: It's not internal anyway. The user knows (after live experience) what buttons he may or may not press.
22:57:19 <skew> what's the point of this, making it easy to control from another program or on the command line?
22:57:34 <Gahhh> I was more testing oriented at first.
22:57:42 <skew> Oh, that's a totally different story
22:57:43 <nailbite1> hi there.  would a kind soul be able to point me at an explanation of monads that won't make my head explode?  :)
22:57:44 <Jerub> I like the idea of gui agnostic coding myself.
22:57:46 <Gahhh> But you can define all sorts of macros.
22:57:58 <Jerub> nailbite1: any explanation I give will be funamentally flawed.
22:58:00 <Gahhh> nailbite1: have you seen the haskell wiki ?
22:58:00 <Jerub> so ignore me
22:58:01 <skew> I can see needing to issue clicks all day long for testing
22:58:07 <nailbite1> Gahhh: there is a Wiki? :)
22:58:08 <skew> nailbite1: there's the nomaware tutorial
22:58:16 <Jerub> I've finally found a good web testing framework
22:58:17 <Jerub> :)
22:58:22 <Gahhh> http://www.haskell.org/hawiki/
22:58:26 <skew> Jerub: which one>?
22:58:30 <nailbite1> Gahhh: danke
22:58:37 <Gahhh> nailbite1: nichts zu danken.
22:58:40 <nailbite1> skew: ok. i'll google for that
22:58:42 <Jerub> skew: pbp, aka python browser posuer.
22:59:16 <wli> so
22:59:21 <skew> Jerub: I've had good results with one of HttpUnit and HtmlUnit
22:59:39 <Gahhh> Well, testing aside, many editors give you a macros anyway. If you had full access, you'd have it built-in.
23:00:05 <skew> I needed to fix a bug or two, but that's what the source is good for. Does pbp do javascript?
23:00:12 <skew> Jerub: I forget which of those I used
23:00:25 <skew> Gahhh: I think scripting GUI actions is totally the wrong way to build macros
23:00:53 <Jerub> skew: okay, pbp was the first that just felt right.
23:01:04 <skew> javascript was the big thing I looked for
23:01:09 <Jerub> righto
23:01:11 <Jerub> I didn't need js
23:01:22 <skew> If it was just a matter of tracking down buttons I would have been happy with HaXml
23:01:42 <Jerub> skew: pbp makes the act of tracking down buttons assertions in your testcases.
23:01:49 <skew> after all, being ill-formed XHTML is certainly a bug in the page being tested :)
23:01:55 <skew> Jerub: yeah, the thing I wrote did that too
23:02:09 <Jerub> also, filling out forms, etc. every action is an assertion
23:02:18 <Jerub> okay, cool
23:02:44 <skew> Actually, I structured mine so there was a page description, mapping nice names to the ugly id or whatever you actually locate a button by
23:02:59 <skew> then scripts used the nice names, and mentioning controls in the description was an assertion
23:04:53 <Kkaa> do any of you guys program Haskell in Windows?
23:05:47 <Gahhh> Kkaa: I use ghc on winxp but I don't do anything win32 specific.
23:06:52 <Kkaa> what editor do you use?  I'm using EditPlus right now-- it supports syntax highlighting of haskell, but i was looking for something better.
23:07:03 <pimaniac> emacs is good :)
23:07:09 <Jerub> vim
23:07:11 <Kkaa> ha ha
23:07:17 <Jerub> or Yi, which would be a fun adventure.
23:08:01 <skew> I have written Haskell in ed
23:08:03 <pimaniac> Kkaa: i dunno about the Haskell support, but SciTe is a great editor that supports many languages
23:08:27 <pimaniac> Kkaa: by better, what exactly do you mean?
23:08:43 <Kkaa> not sure
23:08:54 <Kkaa> just looking for recommendations
23:09:13 <Gahhh> Kkaa: I use emacs. I dont think Scintilla based editors have haskell support yet.
23:09:22 <skew> Jerub: I used the libraries from Jython, though :)
23:11:17 <pimaniac> 1.63 has a Haskell lexer
23:12:25 <pimaniac> it wont do the neato emacs stuff, but i use it a lot for ruby code, and it works great
23:13:09 <Gahhh> oh
23:13:38 <Gahhh> pimaniac: Does it assist with haskell indentation ?
23:14:10 <pimaniac> gahhh: havent used with haskell.  it kinda has problems with ruby though, and thats much less complicated than haskell
23:14:30 <blackdog> pimaniac: lexically speaking?
23:14:32 <pimaniac> best indentation support for anything ive worked in is emacs
23:15:07 <pimaniac> blackdog: im not sure why they say lexer.  I think its primarily for folding, indentation, and syntax coloring
23:15:24 <pimaniac> to be fair, the ruby stuff would be written by a different person than the haskell stuff.
23:15:39 <Kkaa> thanks, pimaniac
23:16:34 <pimaniac> Kkkaa:  no problem.  i collect advice, and dispense when asked/not asked. :-P
23:19:37 <pimaniac> Gahhh: do you use haskell-mode in emacs?
23:19:49 <blackdog> pimaniac: i'm just interested why you think haskell is so much more complicated than ruby from an editing perspective. Do you mean things like the layout rule?
23:20:19 <Gahhh> pimaniac: Yes
23:20:26 <pimaniac> blackdog:  ruby is two spaces in, two spaces out.  haskell has guards, etc, to look pretty.  whats the layout rule?  (n00b alert)
23:21:16 <blackdog> Ah, for indentation. Gotcha.
23:21:44 <blackdog> layout rule is specified in the report, probably. it's what makes indentation semantically significant in haskell...
23:22:04 <pimaniac> haskell seems pretty simple syntactically, im just having problems reading code where every variable is one letter
23:22:39 <blackdog> the variables aren't the important bit. that's why you see so many people writing pointless code.
23:22:45 <Gahhh> pimaniac: I believe that's because it's more academical. It's more like mathematics than Java when it comes to variable names.
23:22:50 <blackdog> as in @pl pointless
23:23:02 <pimaniac> yes, i get the pointless bit :)
23:23:21 <blackdog> Gahhh: yeah, but you still see good function names.
23:23:27 <pimaniac> Gahhh: yes, but im not familiar with the conventions yet, tis all.  im sure theres some sort of convention
23:23:39 * pimaniac crosses fingers.
23:24:00 <Gahhh> blackdog: I agree. But if you look at even the language itself, functions named like "fst, snd". come on now. I'd be beheaded at work if I ever named anything like that.
23:24:20 <pimaniac> Gahhh: those are obviously car and cdr replacements, right?
23:24:37 <Gahhh> pimaniac: yes.
23:24:46 <dbremner> pimaniac - T used hd and tl.
23:24:48 <blackdog> pimaniac: not quite. they work on tuples, not lists.
23:25:05 <dons> @plus fst (1,undefined)
23:25:06 <Gahhh> scheme lists are tuples IIRC
23:25:07 <lambdabot> 1
23:25:11 <blackdog> Gahhh: what if you started using names like 'vsprintf' ? :)
23:25:14 <pimaniac> 1) damn tuples.  2) T?
23:25:17 <dons> @plugs snd (undefined,2)
23:25:19 <lambdabot> 2
23:26:19 <Gahhh> blackdog: yeah, I suppose older api interfaces have really short names. There are too many api's today.
23:27:14 <blackdog> Gahhh: maybe. partly core stuff can be shorter too, as it's used more often. 'map' wouldn't be used much if it were called 'apply_me_to_every_element_of_this_list'
23:27:33 <blackdog> efne, come back! we're sorry for all those mean things we said.
23:27:50 <pimaniac> APL would simply add a map key to the keyboard :-)
23:28:54 <Gahhh> blackdog: Java libraries seem to be verbosely named, tho.
23:29:49 <pimaniac> Java names only seem verbose until you look at Smalltalk methods
23:31:10 <blackdog> Gahhh: java's not a very good model to follow, though.
23:31:43 <blackdog> it makes sense to me to have a core language which is reasonably concise
23:32:31 <dbremner> one of the more colorful features of K is that implicit variables within functions. If you don't specify parameters x, y, and z are default.
23:40:24 <skew> pimaniac: the short variable names are not just because it's academical. Consider compose f g = \x -> f (g x)
23:40:45 <skew> what else would you call them?
23:42:39 <mauke> compose outer inner = \argument -> outer (inner argument)
23:42:40 <pimaniac> exactly.
23:42:49 <pimaniac> to skew, not to mauke
23:42:55 <skew> I suppose
23:42:57 <pimaniac> f and g are traditional function names
23:44:06 <skew> but it's a different story than most code, where you need a name to tell you what some int means
23:45:03 <Gahhh> skew: you have those problems in programs in any language tho. Perl aggravates it a little more than others ;)
23:45:53 <skew> all compose cares about is that it is getting two functions, and they are getting composed
23:46:43 <Gahhh> skew: "compose" is ok. Our problem is when "compose" itself is named "c" or something.
23:48:37 <skew> pimaniac said short variable names were annoying, blackdog said function names are usually good
23:49:18 <skew> I'm trying to explain the short names a bit
23:49:24 <pimaniac> i didnt say annoying.  i said i was having problems.
23:49:40 <pimaniac> i have problems with many things :)
23:50:00 <skew> compose makeCustomerFromOrder makeOrderFromItem = \item -> makeCustomerFromOrder (makeOrderFromItem item) would just be misleading
23:50:09 <pimaniac> the short names bit explaination is helpinging, however
23:50:33 <skew> The names also make more sense in the context of documentation
23:51:08 <mflux> skew, it wouldn't make sense for that function to be called 'compose' anymore
23:51:36 <Gahhh> Yay, I've written 10 lines of haskell.
23:51:43 <skew> "Map takes a function called function_to_be_applied and a list called list_to_be_mapped, and returns the list formed by applying function_to_be_applied to every element of list_to_be_mapped"
23:51:46 <mflux> skew, makeCustomerFromItem maybe - of course then you would annotate the types to reflect that
23:53:21 <skew> mflux: but that function is the same as compose. I'm saying that variables don't often deserve that sort of name because they don't usually have that sort of significane
23:53:39 <pimaniac> Gahhh: congrats!
23:53:51 <skew> Maybe the documentation should use short names and the code should use longer names?
23:54:05 <mflux> skew, it wouldn't be the same if it were makeCustomerFromItem :: Item -> Customer ;) - but yes, I agree, of course the names should be _correct_
23:54:17 <mflux> however I do think that 'inner' and 'outer' are better than 'f' and 'g'
23:54:33 <mflux> 'argument' could be just plain 'arg' or even 'x' ;)
23:55:01 <skew> Hmm, part of it is probably thinking with types
23:55:01 <pimaniac> i like documentation long names and code short names
23:55:17 <pimaniac> im finding that some of the previously indecipherable haskell code seems to do that
23:55:18 <skew> I realized I'm probably internally carrying around the types
23:55:32 <mflux> I don't mind long identifier names, emacs has dynamic completion \o/
23:55:52 <mflux> of course, there is a limit..
23:56:20 <pimaniac> the types.. aye, theres the rub.
23:56:22 <skew> if it's "f::(b->c)", "g::(a->b" and "x::a", then there is no ambiguity to be resolved by changing the identifiers to "outer" and "inner"
23:56:31 <pimaniac> ive worked with nothing but loosely typed languages
23:57:05 <Gahhh> loosely typed languages are fun
23:57:24 <skew> I mean, if you say "f" and "g" but think "f::(b->c)" and "g::(a->b)", it works out
23:57:59 <mflux> skew, but later in the code if you just have 'f', you might wonder its purpose. doesn't matter in a short function such as compose though
23:58:25 <skew> mflux: part of my point is that f has no purpose beyond being an arbitrary function of type a->b
23:58:27 <blackdog> mflux: exactly. but haskell encourages short functions anyway.
23:58:34 <blackdog> there shouldn't be a "later in the code".
23:58:39 <skew> that too
23:58:51 <skew> Or, if you are writing a longer function you should use longer names
23:59:39 <skew> although that is at least as much because a longer function starts to impose some significance on the arguments beyond their types
23:59:58 <Gahhh> you could define a short named function whose job is not obvious: let f x y z = XML.yadda x (blah y z) or something. Just "f" may not cut it.
