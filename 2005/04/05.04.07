00:02:18 <SyntaxNinja> Lemmih: please email me with any progress on how to create the database easily; hopefully I can spend sime time tomorrow hacking
00:02:25 <SyntaxNinja> I almost have a working setup ;)
00:02:28 <SyntaxNinja> 'night all
00:03:17 <Lemmih> SyntaxNinja: I'm done.
00:03:21 <Lemmih> Damn it! (:
00:20:55 <mflux> shapr, well, there is the potential, but ghc will need a lot of work before the advantages can be taken.. I imagine the current usage model is that the developer will write code for those sidekick cpu's with some different language (propably assembler)
00:23:01 <Heffalump> morning all
00:23:18 <metaperl> gm Heff
00:29:09 <Itkovian> meuning
00:29:13 <shapr> hoi Itkovian
00:32:05 <dons> Si\: latest hs-plugins snapshot should have the eval_ code.
00:32:34 <dons> hs-plugins-20050407.tar.gz
00:34:00 <Heffalump> does that do anything exciting?
00:34:32 <dons> filled in a gap in the api for eval.
00:34:51 <dons> you can control the flags to ghc, and get the error msgs back in an Either.
00:35:05 <dons> Si\ wanted it.
00:35:35 <Heffalump> oh, I should send you my patches
00:35:45 <Heffalump> is hs-plugins availble by darcs or CVS or anything?
00:36:05 <dons> not yet. hope to move to darcs when I get time.
00:36:21 <dons> best to diff -ruN --exclude=CVS -u against the latest snapshot.
00:44:13 <basti_> hi guys, I'm circling my yi errors =)
00:45:44 * boegel bows at everyone
00:45:52 * shapr knots at everyone
00:46:19 <dons> basti: "circling"?
00:46:29 <dons> patches are better ;)
00:46:33 * theorbtwo yodels at everone.
00:46:40 * shapr y0dels back
00:46:46 <shapr> the hiiilllls are alivee!
00:47:20 <basti_> dons: no its local reasons
00:47:39 <dons> ok.
00:48:19 <basti_> i have 2 versions of ghc installed (since i wasn't able to remove one i compiled by hand)
00:48:55 <basti_> and apparently (despite my attempts to ./configure --with-ghc) both yi and hs-plugins are a little undecided about this topic
00:49:00 <boegel> with the sound of haaaaaaaaaaaskel
00:49:14 <basti_> /usr/local/lib/yi/HSyi.o: unknown symbol `DataziTypeable_go_entry'
00:49:14 <basti_> Fail: user error (resolveObjs failed with <<False>>)
00:49:20 <basti_> this is what i'm getting now
00:49:21 <basti_> =)
00:49:24 <dons> ghc --version ?
00:49:35 <basti_> 6.3
00:49:53 <dons> 6.3 is not well tested with yi. i recommend 6.4 or 6.2.2
00:49:59 <basti_> hmmok.
00:50:25 <dons> it's possible hs-plugins doesn't know how to parse the package files of whichever 6.3 you've got
00:50:36 <vegai> dons: were you able to build happy on ghc-6.4?
00:50:40 <dons> it all depends on which 6.3 you have, in relation to the timing of Cabal commits.
00:50:45 <basti_> i see.
00:50:57 <dons> vegai: not sure, think so.
00:51:02 <basti_> so in versioning we're still at the state of the art of 1970?
00:51:02 <basti_> ;)
00:51:04 <Si\> dons: re: eval_; thanks
00:51:33 <dons> basti_; no. you get 6_3_XXXYYYY, but I don't have #ifdefs for each different 6.3 version.
00:51:44 <basti_> i see
00:52:21 <dons> "you'll stay stable, if you use ghc stable!"
00:52:47 <basti_> sadly my 6.2.something couldn't build hs-plugins
00:53:03 <dons> 6.2.2 is what's needed. or 6.4.
00:53:15 <dons> are you on a mac? or something even weirder?
00:53:38 <basti_> ah i got 6.2.1
00:53:40 <basti_> -.-
00:53:55 <basti_> no plain pc infrastructure here
00:54:06 <dons> linux, windows?
00:54:10 <basti_> linux
00:54:12 <basti_> debian
00:54:27 <dons> should run fine. well tested. has nightly regress tests.
00:55:14 <basti_> except for if someone has ghc-cvs, and, parallel to it, ghc-6.2.1, manually installed ;)
00:56:09 <dons> I have ghc-cvs, ghc-6.4, ghc-6.X, x >= 0.0
00:56:46 <dons> but you're problem is really 6.3 - I make no attempt to support nightly changes in unstable apis.
00:59:47 <Lemmih> Greetings, Oejet.
01:00:30 <basti_> dons: i understand that, so i'm cvs'ing 6.4 atm
01:00:54 <basti_> is odd version numbers a marker for "in development"?
01:01:01 <dons> yep.
01:01:04 <basti_> i see
01:01:26 <dons> even numbers == stable.
01:02:13 <blackdog> dons: "even weirder" !?!?!
01:02:38 <dons> that's what I said ;)
01:02:59 <dons> I point you to Mr. WolfgangT's cvs commits for proof of my assertion
01:03:08 <blackdog> you just wait till the avenging Mac army storms the barricades, resplendent in their designer eyewear and elegantly restrained clothing, hurling lattes with a steady aim...
01:03:37 <blackdog> been a while since i was up to date with ghc-cvs. :)
01:03:44 <dons> hehehe
01:03:50 <ozone> blackdog: http://apple.slashdot.org/comments.pl?sid=134742&cid=11246218
01:03:51 <ozone> re
01:04:06 <dons> and you too ozone. it's a conspiracy.
01:04:26 <ozone> dons: hey, apple just gave me a free trip to san francisco
01:04:35 <dons> ! cool.
01:04:40 <ozone> so, i think it's only fair to pay respectZ
01:04:45 <ozone> (with a capital Z)
01:04:59 <blackdog> ozone: did he treat you good?
01:05:03 <dons> jobs is monitoring this channel RIGHT NOW!
01:05:16 <ozone> blackdog: not as good as yo momma
01:05:32 <blackdog> that's not what she said.
01:05:38 <dons> ouch!
01:05:59 <blackdog> ... hm, reparsing that in my mind, it makes less and less sense.
01:06:20 <dons> hehehaha
01:06:23 <blackdog> blame way too many free energy drinks and a steady diet of plone...
01:06:35 <ozone> you're hacking plone now, blickdawg?
01:06:50 <dons> siith afrikan?
01:07:20 <blackdog> kinda. "getting majorly confused by plone" is probably closer to it. it's sorta big, y'know? haskell libraries, they small, easy to get your head around...
01:08:32 <shapr> plone, has a bit of state
01:08:45 <shapr> Bigger than California in fact.
01:08:50 <basti_> lol the template haskell logo is funny
01:08:55 <blackdog> shapr: what's a place like you doing in a girl like this?
01:09:37 <ozone> @karma blackdog+
01:09:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog+ has a karma of 0
01:09:42 <shapr> outside of a dog, a book is a man's best friend, inside of a dog, it's too dark to read.
01:09:42 <ozone> @karma+ blackdog
01:09:44 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been incremented
01:10:14 <boegel> @karma boegel
01:10:15 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
01:10:23 <boegel> @karma+ boegel
01:10:24 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You can't change your own karma, silly.
01:10:29 <boegel> :D
01:10:30 <blackdog> @karma blackdog
01:10:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 1
01:10:38 <blackdog> booya.
01:10:48 <blackdog> @karma- blackdog
01:10:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You can't change your own karma, silly.
01:11:08 <boegel> @karma- blackdog
01:11:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been decremented
01:11:11 <boegel> @karma- blackdog
01:11:12 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been decremented
01:11:14 <blackdog> oh well. modesty is unappreciated, it seems.
01:11:17 <boegel> @karma blackdog
01:11:18 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog has a karma of -1
01:11:21 <boegel> :p
01:11:21 <blackdog> oh, thanks very much.
01:11:27 <boegel> @karma+ blackdog
01:11:28 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been incremented
01:11:30 <boegel> @karma+ blackdog
01:11:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- blackdog's karma has been incremented
01:11:32 <blackdog> i'll be coming back as an earthworm or a php hacker, it appears.
01:11:38 <boegel> just kidding duuuuuuuuude
01:11:51 <blackdog> :) no wuckas.
01:11:53 <Itkovian> @karma Itkovian
01:11:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
01:12:00 <Itkovian> right on track
01:12:00 <boegel> poor Itkovian
01:12:08 <boegel> @karma- Itkovian
01:12:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Itkovian's karma has been decremented
01:12:10 <boegel> there you go
01:12:19 <Itkovian> why thank you
01:12:23 <boegel> np
01:12:36 <blackdog> ok, enough silliness. shapr, is it reasonably easy to do batch stuff with zope? I managed to get the acl_users thing going - just had to set a whole lot o membership_source
01:12:46 <blackdog> bah. membership_source to null.
01:13:13 <wilx> @karma wilx
01:13:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- You have a karma of 0
01:13:25 <blackdog> @karma dons
01:13:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- dons has a karma of 0
01:13:36 <shapr> blackdog: yes, you can do batch ops
01:13:37 <dons> don't we have a Prelude function g f = f . f ?
01:13:42 <Lemmih> @karma JaffaCake
01:13:42 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- JaffaCake has a karma of 0
01:13:53 <blackdog> hah! i'm better than a simon!
01:13:59 <blackdog> </boastful>
01:14:32 <dons> I thought there was a compose()? hmm.
01:15:16 <Lemmih> Have Peyton-Jones ever visited #haskell?
01:15:20 <shapr> Lemmih: yes
01:15:42 <Lemmih> When? And using what handle?
01:15:50 <shapr> heh, my LtU particle was mentiond on ll1-discuss, yay!
01:15:56 <shapr> um 'article'
01:15:58 * shapr is brainfried
01:17:08 <blackdog> with a nice chianti? or is that liver...
01:17:30 * dons writes contiues reimplementing hs-plugins for lambdabot in sed. :/
01:17:50 <blackdog> ...
01:17:51 <dons> surprising how much info you can extract from .hi files without resorting to a real parser
01:19:09 <Lemmih> nibro: You're Niklas Broberg!
01:19:28 <ozone> dons: and you wonder why i call you crazy don
01:19:35 <shapr> At least he doesn't harp on about it. *badum*
01:20:25 <Itkovian> sequence complete down?
01:20:42 <nibro> Lemmih: that would be me yes =)
01:20:50 <dons> heya nibro
01:21:01 <nibro> morn' dons
01:21:16 * Lemmih hops to bed.
01:22:31 <basti_> hmm
01:23:09 <Oejet> Hello, Lemmih.
01:23:57 <basti_> in making ghc6, not even the first compile would succeed :(
01:31:00 <df_> urgh
01:31:55 <basti_> I'm going to download a binary now.
01:31:56 <basti_> ;)
01:32:31 * df_ wonders what is leaking memory
01:37:53 <Oejet> Has the parr library been removed from GHC 6.4?  If not what is the package called. I forgot.
01:41:27 <boegel> does anyone know a good dictionary website to translate English terms into Dutch ?
01:42:24 <nibro> dons: http://www.cs.chalmers.se/~d00nibro/haskell-src-exts-0.2.tar.gz
01:43:42 <blackdog> anyone know if you can do "let [a,b,c,_] = some_list" in python?
01:44:12 <dons> nibro: got it. I'll merge it  in over the weekend.
01:45:04 <nibro> dons: cool =)
01:46:06 <nibro> dons: you probably want to skip the harp and trhsx parts and keep just the core hsx package
01:46:48 <dons> ok.
01:49:13 <Itkovian> howcome show $ read "f" is not working?
01:49:57 <Itkovian> imo, read :: String -> a, and show :: a -> String, so, can the problem be that the type inference does not know what to make of the type a?
01:51:47 * basti_ will burn some cycles now =)
01:52:06 <Itkovian> ah! a sacrifice on the altair of computing
01:52:22 * shapr waves his blackened and burnt heatsink
01:52:58 <dons> @plugs show . read $ "f"
01:53:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- /tmp/MOESO10645.hs:1:
01:53:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     Ambiguous type variable `a' in these top-level constraints:
01:53:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at 1
01:53:25 <dons> @plugs show ((read "f") :: Char)
01:53:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: Prelude.read: no parse
01:53:36 <dons> @plugs show ((read "f") :: String)
01:53:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: Prelude.read: no parse
01:53:50 <theorbtwo> @type read
01:53:52 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- read :: forall a. (Read a) => String -> a
01:54:09 <theorbtwo> Oh, yeah, try embedded quotes:
01:54:20 <theorbtwo> @plugs show ((read "'f'") :: Char)
01:54:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "'f'"
01:54:46 <dons> yeah, f alone looks like a var. not a data value that can be parsed with read.
02:01:41 <Itkovian> yes, but it is inside a String ...
02:01:46 <Itkovian> so it _is_ a Char
02:01:47 <Itkovian> no?
02:02:18 <Itkovian> furthermore, in this piece of code: putStrLn $ unlines $ map prettyPrintBoard $ doMoves (map head moves) $ board
02:02:32 <Itkovian> it works, where doMoves :: [Char] -> Board -> [Board]
02:02:53 <Itkovian> and moves is (boardDescriptionFileName:moves) <- getArgs
02:04:05 <Itkovian> erm that should be map read
02:04:08 <Itkovian> not map head.
02:04:18 <Itkovian> head words as well ... but I wrote read originall;y
02:07:13 <Itkovian> so basically, the doMoves (map head moves) board works.
02:07:18 <Itkovian> so basically, the doMoves (map read moves) board works.
02:07:28 <Itkovian> where moves :: [String]
02:07:34 <blackdog> i've had enough python now. i want some static typing :(
02:07:43 <shapr> yay! static!
02:07:48 <theorbtwo> head says "take the first element of the array".
02:08:00 <theorbtwo> read says "take this string, and parse it as a bit of data".
02:08:14 <theorbtwo> If you want ['f'] -> 'f', you want head.
02:08:30 <theorbtwo> If you want ['4', '2'] -> 42, you want read.
02:08:50 <Oejet> blackdog: Couldn't Python in principle have a static type checker, which warns about problems?
02:09:01 <shapr> @google pypy
02:09:02 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No matching header
02:09:08 <Itkovian> theorbtwo: I know that, the moves are given on the command line as a bunch of chars, i.e. a b c d e a d a e a c b
02:09:25 <theorbtwo> So you have a [String], or [[Char]]?
02:09:32 <Itkovian> hmm
02:09:36 <Itkovian> that's the same afaik
02:09:52 <Itkovian> but maybe not for read purposes?
02:09:58 <Itkovian> isn;t String an alias for [Cha]?
02:10:01 <Itkovian> [Char]
02:10:04 <smott> yes
02:10:07 <Itkovian> well then
02:10:14 <theorbtwo> Yeah.  They're identical, I just gave both spellings.
02:10:23 <blackdog> Oejet: maybe. depends how heavily it uses introspection, i'd guess...
02:10:32 <Itkovian> that means moves would be: ["a","b","c","d","e", ... ]
02:10:38 <Oejet> Found it!  It's in GHC.PArr.    Just type ]ghci -fglasgow-exts followed by :m GHC.PArr.
02:10:45 <Itkovian> and map read should yield a [Char]
02:11:00 <blackdog> Oejet:  still, it'd be easier than reimplementing a behemoth like Plone in Haskell.
02:11:12 <theorbtwo> No, reading "f" will get you an error.
02:11:19 <Itkovian> I've seen that ;-)
02:11:21 <shapr> blackdog: I dunno...
02:11:26 <theorbtwo> If you just want the first Char from a [Char], then you want head.
02:11:33 <Itkovian> ah well...
02:11:41 <theorbtwo> But really, a move should probably be a Move, and not a Char.
02:12:05 <theorbtwo> And you should have a String -> Move function, and bury this detail there.
02:12:22 <theorbtwo> (And it should probably check that the length of the string is 1 before heading it.
02:12:44 <blackdog> shapr: you don't think so? at least compilers/language tools have some conceptual groundwork - i've got no idea why half of plone is the way it is...
02:13:01 <shapr> I think it'd be easier to reimplement Plone.
02:13:20 <blackdog> theorbtwo: the nicer way would be
02:13:32 <blackdog> foo (x:xs) = x
02:13:44 <blackdog> foo _ = error "I wanted at least a letter, you fool!"
02:13:53 <blackdog> shapr: crazy man. :)
02:14:29 <Itkovian> theorbtwo: that should be the case by construction
02:14:55 <theorbtwo> Hm, g'point.
02:15:31 <Itkovian> which is why I found read to be kinda nice
02:16:51 <theorbtwo> Hm, I'm not actually that sure.
02:16:54 <theorbtwo> @type head
02:16:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- head :: forall a. [a] -> a
02:17:01 <theorbtwo> @plugs head []
02:17:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Ambiguous type variable `a' in the top-level constraint:
02:17:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-       `Show a' arising from use of `show' at <Plugins.Eval>:1
02:17:12 <theorbtwo> @plugs head ""
02:17:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Fail: Prelude.head: empty list
02:17:21 <theorbtwo> OK, yeah.
02:17:37 <Oejet> shapr: I can't seem to construct arrays by typing e.g. [: 5, 2, 7:] in GHCi.  Do you know why?
02:17:39 <theorbtwo> Perhaps that was first... whatever.
02:17:56 <shapr> no clue
02:33:49 * shapr throws pragmas
02:34:36 * Itkovian tries to catch
02:37:59 <TFK|Uni> http://haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage <--- wow. Someone wrote my bitchin' for me.
02:40:33 * TFK|Uni will try :edit filename trick in hugs when he gets home
02:40:35 <vegai> heh, well said
02:41:49 <vegai> if I wasn't so lazy, and perhaps a bit more experienced, I'd write a tutorial that wasn't written to impress English majors
02:42:00 * vegai takes English only as a minor, you see :P
02:42:45 <TFK|Uni> Yup. If I ever master Haskell, I'll try to write comperehensive documentation that is accessible to the Average Joe Programmer.
02:42:53 <shapr> yay!
02:42:55 <vegai> TFK|Uni: join my party!
02:42:57 <TFK|Uni> (That doesn't mean you should wait for me to do so, though ;-)
02:43:18 <TFK|Uni> vegai, hmmm, do you provide free milk and chocolate chip cookies?
02:43:29 <vegai> umm
02:43:45 <vegai> umm, sure. Expect that I'm not sure about the free milk and cookies
02:44:27 <TFK|Uni> :-/
02:44:55 <vegai> but I can half-guarantee a flamefest directed at us by more senior Haskellers :)
02:45:08 * shapr waves his cane
02:45:14 <shapr> I'm a senior!
02:45:34 <vegai> yes, sir
02:46:02 * TFK|Uni looks for an asbestos suit
02:46:27 <TFK|Uni> Anyway, it'll be a long time before I master Haskell for any meaningful definition of "master", so don't hold your breat ;-)
02:46:43 <vegai> writing a tutorial is one way to master it, you know
02:46:57 <vegai> you'll be forced to do some rewrites anyway, so...
02:47:20 <TFK|Uni> Good idea. But the problem with asbestos suits is that they will, eventually, heat up ;-)
02:48:33 <jlouis> You cannot master Haskell in My opinion
02:49:15 <vegai> Haskell: The beast inside.
02:49:23 * vegai wonders.
02:49:24 <jlouis> You can always learn more about it as a language. The goal of a tutorial must be to make a programmer unknown to Haskell more fluent in it by moving him up the ladder of mastery
02:49:41 * vegai nods.
02:49:43 <TFK|Uni> jlouis, unfortunatelly, programmers with to write programs :-)
02:50:06 <TFK|Uni> *wish
02:50:20 <shapr> TFK|Uni: what about the HaskellDemo?
02:50:20 <vegai> dvorak? =)
02:50:42 <jlouis> h and s is far apart on dvorak
02:50:44 <TFK|Uni> shapr, the Haskell demo lacks context. You have to read it alongside with something.
02:50:47 <jlouis> thats not a typical typo
02:50:59 <shapr> oh
02:51:02 <TFK|Uni> No, a Freudian-like slip ;-)
02:51:04 <vegai> jlouis: closer than in qwerty :)
02:51:13 <Arafangion> Hmm, with monads... Could you summarize them as "a right peculiar data structure"
02:51:14 * TFK|Uni reads the Prelude List Functions on the wiki
02:51:54 <vegai> jlouis: also, it was t and s
02:52:15 <TFK|Uni> Is !! constant in time or linear?
02:52:32 <TFK|Uni> (I'm guessing linear)
02:52:58 <vegai> hmm
02:53:10 <Igloo> linear
02:53:11 <vegai> @type (!!)
02:53:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- (!!) :: forall a. [a] -> Int -> a
02:53:24 <vegai> since it works on lists..
03:00:15 <Cale> Arafangion: they're a certain class of data types which have particular operations defined on them which somewhat make them seem somewhat like containers
03:00:39 <Cale> Arafangion: Have you read my article? http://www.haskell.org/hawiki/MonadsAsContainers
03:01:08 <Arafangion> Cale, I should do so.
03:01:39 <Arafangion> Cale, Be great if you could find something for me that reviews monadic langauges with 'classic types' that are familiar with C-based languages?
03:04:38 <shapr> There are monad implementations in Perl, Scheme, and some other languages.
03:09:55 <Oejet> What is the type constructor for parallel arrays?  Neither (Parr e) nor [:e:] works.
03:11:23 <TFK|Uni> Are there built-in functions like join() and split() in Python? Something more general than lines/unlines/words/unwords?
03:11:32 <Cale> I think that introducing monads as an abstraction of computation right off the start is a bit harsh. Thinking of them as containers is, I think, a bit easier. Once you're used to that, then you can start to see the computation side of things and how (>>=) is putting inputs into a computation.
03:12:16 <Itkovian> TFK: you can use the LicensedPreludeExtension stuff which contains a splitRegex function
03:12:53 <TFK|Uni> splitRegex?...
03:13:00 <TFK|Uni> LicesndesPreludeExtension?!
03:13:21 <shapr> yes?
03:13:29 <TFK|Uni> *Licensed
03:13:36 <Cale> BSD licensed
03:13:54 <TFK|Uni> And the standard Prelude is unlicensed?
03:14:10 <ibid> it is licensed
03:14:13 <shapr> it's just that the wiki does not have a default license
03:14:19 <shapr> I should really add one.
03:14:22 <ibid> but there are unlicensed prelude *extensions*
03:14:50 <TFK|Uni> I think I'll just write my own ;-) those functions in Python take strings, not regexes
03:15:04 <TFK|Uni> Not sure if I'll ever need them, but who knows...
03:17:57 <bringert> does anybody have any ideas for a haskell-related project for 6-8 students? it will be 7 weeks of full-time work / person, over one academic year
03:18:27 <bringert> this is the same project course in which which did the haskelldb project a year ago
03:18:46 <bringert> is there anything of the right size that you would like to have in haskell?
03:18:59 <Lemmih> What about a remake of haskelldb? (:
03:19:07 <bringert> it could be an application or a library, a totally new project or extending an existing one
03:19:10 <bringert> Lemmih: :-P
03:19:22 <bringert> or something else
03:19:28 <bringert> as long as it is haskelly
03:21:49 <Oejet> Wow, 6-8 man years just offered for your service, Lemmih. :-P
03:22:04 <Oejet> *to your
03:22:45 <TFK|Uni> Cheap slave labour to help one implement one's plan to take over the world!
03:23:27 <TFK|Uni> bringert, whatever you will be doing, I suggest you familiarize yousrelf with http://joelonsoftware.com/ for painless development :-)
03:23:41 <vegai> bringert: a Twisted Haskell
03:24:59 <bringert> Oejet: only about 1 man-year
03:25:01 <bringert> but still
03:25:07 <Lemmih> bringert: Some kind of language extension neutral debugging tool, perhaps.
03:25:16 <Lemmih> Hat for Core.
03:25:31 <TFK|Uni> http://haskell.org/hawiki/HaskellNewbie_2fStringParsing <--- split was implemented for me :D
03:25:40 <bringert> TFK|Uni: I don't think I'd be managing the project, jsut trying to come up with suggestions for a good project
03:26:03 <shapr> dons' department's student projects has a nifty list of ideas.
03:26:05 <theorbtwo> Make hat able to cover all the functionality of ghc 6.4 that pugs uses?
03:26:16 <bringert> shapr: url?
03:26:19 <TFK|Uni> bringert, imho every programmer should familiarize himself with these concepts, manager or not.
03:26:19 <Oejet> bringert: Doh, 7 students times 7 weeks is 49 weeks, which is a man year.
03:26:20 <shapr> uhhh
03:26:24 * Oejet feels stupid.
03:26:48 <TFK|Uni> The mythical man month? :-P
03:27:28 <theorbtwo> Hm, you want something that's complete from-the-top implementation, don't you, so your students have to design the whole framework?  Or do you want something where there's already existing cruft to work around or fix, and existing project hackers in place to...
03:27:33 <theorbtwo> ...well, work around, or fix?
03:27:38 <theorbtwo> Both have their advantages.
03:28:06 <shapr> bringert: you could port Parsec to arrows
03:28:21 <bringert> theorbtwo: normally the projects are of the "do-everything-from-scratch" kind, I think the haskelldb project was one of the first projects that wasn't like that
03:28:39 <bringert> but people seem to think that the haskelldb project was successful
03:28:40 <Lemmih> shapr: That should hopefully take less than a man year (:
03:28:41 <TFK|Uni> Hmmm. That split function splits only once.
03:28:49 <shapr> Lemmih: depends :-)
03:29:00 <shapr> I'd call the HaskellDB project successful.
03:29:13 <shapr> I've gotten paid to use it. How much more successful can you get?
03:29:39 <Itkovian> TFK: that can easily be changed, no?
03:29:43 <bringert> shapr: where's my cheque?
03:29:51 <shapr> um, I owe you beer =)
03:30:16 <TFK|Uni> Itkovian, yup.
03:30:17 <shapr> I can't figure out where the url went for the nifty projects on www.cse.unsw.edu.au
03:30:19 <bringert> shapr: I regret that we didn't go with madry's suggestion and change the license to the beer license
03:30:26 <shapr> haha!
03:30:28 <bringert> mardy's
03:30:36 <bringert> we discussed that in a meeting
03:30:38 <TFK|Uni> Unfortunatelly, we don't have a haskell compiler on our Uni's Linux machines :-(
03:31:06 <bringert>  * "THE BEER-WARE LICENSE" (Revision 42):
03:31:06 <bringert>  * <phk@FreeBSD.ORG> wrote this file. As long as you retain this notice you
03:31:06 <bringert>  * can do whatever you want with this stuff. If we meet some day, and you think
03:31:06 <bringert>  * this stuff is worth it, you can buy me a beer in return Poul-Henning Kamp
03:31:51 <shapr> that's a good license
03:31:57 <theorbtwo> You know, he should really add the no-warranty boilerplate there.
03:32:51 <Cale> Henning Thielemann is strange
03:32:54 <Cale> :)
03:32:57 <TFK|Uni> Is warranty always implicitly assumed?
03:33:10 <bringert> "There is no warranty, implied or otherwise, that I will accept your beer, get drunk or think that you are my best friend in the whole world."
03:33:33 <bringert> vegai: Twisted Haskell?
03:34:30 <theorbtwo> It is in some juristictions, bringert.
03:35:04 <Cale> !! is not linear in time relative to the length of the list, it's linear relative to the index to look up
03:35:16 <shapr> vegai: you should check out HAIFA and CASHEW by Si\ if you want Twisted Haskell. I think you'll have similar challenges for the object codec.
03:35:34 <vegai> hmm, ok
03:35:59 <bringert> shapr: so, what else do you need to do more haskell coding for money?
03:36:01 <shapr> I know this because I hacked on a TwistedHaskell implementation already long ago :-)
03:36:07 <TFK|Uni> Ah, well, edit it out, then :-)
03:36:25 <bringert> chalmers, shapr's own internal development deparment
03:36:25 <shapr> bringert: I *want* a Zope replacement.
03:36:28 * shapr laughs
03:36:43 <shapr> and in fact, HaskellDB is one of the pieces required for such a critter
03:37:04 <bringert> shapr: ah, that's actually what our original plan was, but haskelldb proved to be enough work in itself
03:37:08 <shapr> Dominic Fox had some surprising idea for a Zope replacement with very little running state.
03:37:35 <shapr> Philippa has some cool ideas on a Hope as well.
03:37:37 <bringert> shapr: have to looked at nibro's stuff?
03:37:41 <shapr> which stuff?
03:37:46 <shapr> HaRP?
03:37:47 <bringert> haskell server pages
03:37:56 <bringert> which uses HaRP
03:38:05 <bringert> and lots of other things
03:38:05 <shapr> oh, no
03:38:13 <shapr> I have used Halipeto, but I wish it did static checking.
03:38:32 <shapr> I think that could be accomplished by passing in the DTD as the 'type' and using HaXml to check it.
03:38:41 <bringert> nibro: is your haskell server pages code available for download yet?
03:38:48 <shapr> http://www.dtek.chalmers.se/~d00nibro/ :-P
03:39:02 <bringert> "Please return later..."
03:39:20 <shapr> aha - http://www.cs.chalmers.se/~d00nibro/thesis.pdf
03:39:29 <shapr> doesn't give me the code though.
03:40:10 <bringert> it looks like he's in the office from his hostname
03:40:32 <shapr> huh, Joel on Software comments talking about Haskell? - http://discuss.joelonsoftware.com/default.asp?joel.3.102713.5
03:41:01 <Itkovian> nibro: condier lining out the right side of the text!
03:41:08 <Itkovian> s/condier/consider
03:41:13 <Itkovian> /
03:41:20 * bringert got his degree certificate in the mail today
03:41:47 <theorbtwo> Congrats.
03:42:11 <shapr> yay!
03:42:15 <Matt-W> well done
03:42:32 <theorbtwo> What degree of degree is it?
03:42:41 <shapr> bringert: I still think you should have done common subexpression elimination and written your thesis about parsing russian grammar in haskell.
03:43:31 * shapr snickers evilly
03:44:15 <shapr> bringert: If you seriously want more detail on a Hope, I can get it together.
03:44:25 <bringert> theorbtwo: MSc in Computer Science and Engineering
03:44:45 <theorbtwo> Oooh, sounds fancy.
03:44:47 <shapr> oh we had fun using your stoneage grammar :-)
03:44:54 <bringert> bringert: I'm doing a BA thesis about russian morphology in haskell
03:45:00 <bringert> that close enough for you?
03:45:19 <bringert> shapr: what did you do with it?
03:45:31 <shapr> Bea and I sat around and played with it.
03:46:05 <shapr> The funniest part was when it would make up sentences where the words were used in truly bizarre ways and we would have to guess which swedish word was meant.
03:46:20 <shapr> It was quite cool.
03:46:44 <bringert> shapr: did you ever write a web-based translation quiz app?
03:46:56 <shapr> I did, but I haven't hacked it to use stoneage, haven't even looked at it in months.
03:47:11 <bringert> it would be a cool application
03:47:14 <shapr> It would.
03:47:28 <shapr> Can't be worse than what SFI is using now.
03:48:07 <shapr> At this point, I'd recommend university Swedish courses to immigrants instead of SFI.
03:48:20 <bringert> there are now stoneage grammars for swedish, norwegian, english and french
03:48:25 <shapr> wow, cool!
03:48:33 <bringert> I'm updating the darcs repo right now
03:48:35 <shapr> no russian?
03:48:59 <bringert> I was planning to write one, but the russian resource grammar is not up-to-date with the API changes
03:49:02 <Itkovian> bringert: how about using HSP to build a CMS like system? for that student project...
03:49:05 <shapr> ah, too bad.
03:49:07 <bringert> so that needs to be done first
03:49:24 <bringert> Itkovian: yeah, that could be interesting
03:49:35 <shapr> My major problem with Zope is that there's *so much state*. California is nowhere close!
03:49:54 <bringert> and you could couple it with making whatever changes to HSP/HaskellDB etc. that are neded to make it work
03:50:01 <bringert> shapr: :-)
03:50:14 <shapr> Hey, did you see HaskellDB on the extremeperl mailing list?
03:50:21 <bringert> nope
03:50:27 <bringert> what's extremeperl?
03:50:33 <shapr> Sadly, the discussion fell into the turing tarpit.
03:50:54 <shapr> Have you seen pugs, the perl6 implementation?
03:51:13 <bringert> I've heard talk about it here
03:51:22 <shapr> extremeperl is a mailing list about a book that discusses XP with Perl.
03:51:35 <Itkovian> nibro: Have you done any significant performance tests using HSP?
03:51:42 <Igloo> "turing tarpit"?
03:51:50 <shapr> I wrote about pugs on LtU - http://lambda-the-ultimate.org/node/view/620
03:52:02 <bringert> @define turing tarpit
03:52:03 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- turing defined
03:52:09 <bringert> http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=turing+tarpit&action=Search
03:52:14 <shapr> Igloo: "Perl is just as good as Haskell because they can both run turing machines"
03:52:22 <shapr> @foldoc turing tarpit
03:52:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "turing" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)
03:52:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "
03:52:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Turing
03:52:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-      
03:52:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         1. {Alan Turing}.
03:52:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-      
03:52:31 <shapr> hmm
03:52:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [19 @more lines]
03:52:37 <bringert> @foldoc "turing tarpit"
03:52:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- *** "turing tarpit" foldoc "The Free On-line Dictionary of Computing (27
03:52:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SEP 03)"
03:52:39 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Turing tar-pit
03:52:41 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-      
03:52:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         A place where anything is possible but nothing of interest is
03:52:45 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-         practical.  {Alan M. Turing} helped lay the foundations of
03:52:47 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- [29 @more lines]
03:54:06 <shapr> So I said "Sure, Haskell and Perl are both Turing complete, and that's useless for comparison."
03:54:41 <bringert> shapr: gf darcs repo is now up-to-date
03:54:45 * shapr pulls
03:55:41 <musasabi> morning
03:55:47 <shapr> hei musasabi
03:55:51 <autrijus> gninrom
03:55:53 <musasabi> hello shapr
03:56:04 <musasabi> Anyone used HAppS ?
03:56:05 <shapr> autrijus: olleh
03:56:18 <shapr> musasabi: Er, I've looked at it.
03:57:14 <musasabi> how did it look?
03:57:21 <shapr> like it needed monads.
03:57:50 <boegel> does anyone here know who helps Anakin Skywalker transform into Darth Vader in SW3 ?
03:57:52 <shapr> I don't want to handle my own transactions.
03:58:07 <boegel> Chancellor Palpatine, Mace Windu or Obi-Wan Kenobi
03:58:16 <shapr> don't tell me! I don't want to know!
03:58:24 * theorbtwo thinks it'd be pretty obvious.
03:58:27 <boegel> pm me who knows:)
03:58:30 * musasabi was trying to figure a way to implement time-sensitive actions into lambdabot and got sidetracked..
03:58:43 <boegel> it's for some contest, and I have no clue :)
03:59:50 <musasabi> of course I could just add timeout based events to lambdabot...
04:00:11 <shapr> I would like to hear an independent opinion of HAppS
04:00:13 <musasabi> but I am looking for a clean event model.
04:00:44 <shapr> I think I'm biased by what S. Alexander has posted on the libraries list recently.
04:02:26 <musasabi> The dependencies thing?
04:08:16 * Oejet is not impressed with the perfomance of GHC.PArr.  GHC 8199ms, C 11ms.
04:09:06 <musasabi> Oejet: shootout has ugly fast haskell array code..
04:09:25 * Oejet looks.
04:09:54 * musasabi wrote some of it - it is very ugly and inelegant but fast.
04:10:32 <musasabi> but => home.
04:10:49 <Itkovian> what's  GHC.PArr?
04:11:54 <Oejet> musasabi: Which benchmark?
04:14:05 <shapr> musasabi: does shootout use Parr?
04:15:52 <Oejet> Itkovian: An implementation of parallel arrays (strict semantics).  See http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/GHC/PArr.hs?rev=1.8 and http://www.cse.unsw.edu.au/~chak/papers/papers.html#afp-arrays .
04:19:20 <Oejet> To load the special syntax (which is not essential) give -fparr to GHC(i).
04:21:29 <TNKS> is anyone here proficient enough in hat to field a question?
04:23:14 <theorbtwo> TNKS: We'll never know unless we try.
04:24:52 <theorbtwo> What is the question?
04:31:58 <theorbtwo> GHC internals question: I'm trying to load bits and pieces, as it were, with DynamicLoader.  Does anybody know where I might find the symbol __stginit_AST_?  grep __stgint_AST_ `find /usr/lib/ghc-6.4 -type f` didn't find anything.
04:32:10 <Oejet> shapr: So there isn't a usable arrow parser library in the works?
04:40:32 <theorbtwo> Nevermind, figured it out.
05:07:32 <shapr> Oejet: Not that I know of. swiert sent me a minimal parser lib that's halfway between attribute grammars and arrow-style.
05:07:52 <shapr> It's pretty cool, but hard for me to read. I don't get AGs yet.
05:09:08 <shapr> Oejet: I had the urge to hack up a purely Hughes-style arrow parser lib and call it 'ParrowT'
05:17:40 * shapr stares at SPJ's message about restricted types.
05:17:58 <shapr> When did GHC get recursive dictionaries?
05:18:19 <shapr> Does that mean I can add a (Read, Show) => to an existing typeclass?
05:18:57 <Oejet> shapr: I think Parsec is a nice real world application of monads.  ParrowT would be the same for arrows, I think.
05:19:14 <musasabi> back.
05:19:35 <shapr> Yeah, I totally agree. Especially since ParrowT would likely be faster/thinner than Parsec.
05:19:48 <shapr> Is there a single word for 'less space using' ?
05:20:01 <musasabi> shapr: shootout doesn't currently use PArr as it has ghc 6.2.2 (should bug them to upgrade) which has PArr with fatal bugs.
05:20:07 <shapr> ah, right
05:20:21 <shapr> Is Parr actually faster?
05:21:05 <musasabi> I would say STUArray > STArray > PArr > Array.
05:21:15 <shapr> ok
05:21:28 <shapr> That could change with an SMP GHC =)
05:21:36 <musasabi> but monadic array code is very ugly in haskell...
05:22:03 <tromp> not so much ugly, as verbose
05:22:25 <tromp> each array access is a separate action
05:23:03 <musasabi> Arrays would really someone wise to look at them.
05:24:06 <musasabi> Are arrays a monad?
05:24:11 <Oejet> musasabi: That sentence looks broken to me.
05:24:30 <tromp> no, arrays are not monads
05:24:40 <musasabi> why?
05:24:45 <tromp> but array operations need to reside in a monad
05:24:53 <musasabi> in particular why are lists monads but not arrays.
05:25:03 <musasabi> if we speak about immutable arrays for a while.
05:25:12 <shapr> interesting point
05:25:34 <shapr> lists represent backtracking usually, array could as well?
05:25:35 <musasabi> And if arrays are a monad is an STArray a monad transformer?
05:25:44 <Oejet> From PArr.hs in CVS: "The current implementation is quite simple and entirely based on boxed --  arrays".
05:27:15 <musasabi> (and if arrays are monads they should be monadplus and thus one could use a kind of generic monad comprehensions (like list comprehensions) with them.
05:27:33 <tromp> currently, one is expected to use getelems to convert an array to list
05:27:52 <Oejet> And: "The implementation is not very optimised."
05:29:13 <tromp> some functions like amap duplicate the monadic list functionality
05:30:38 <shapr> that's a good point.
05:31:28 <shapr> Sure sounds like arrays would be better with monad instances.
05:32:12 <basti_> hmm
05:32:31 <basti_> shapr: I'm approaching the build of yi.
05:32:31 <basti_> ;)
05:33:35 <shapr> yay!
05:33:46 <basti_> it's running fine, apparently.
05:33:46 <basti_> :)
05:34:10 <basti_> yes it is.
05:34:16 <basti_> do you want to know what the problems were?
05:34:53 <shapr> sure!
05:35:13 <basti_> a) two versions of ghc installed, ./configure didnt realize it was using the wrong hsc2hs
05:35:40 <shapr> ah
05:35:53 <basti_> b) one of the versions (6.3) is not thought to compile yi, 6.2.2 should, but didn't in my case
05:36:13 <basti_> (hs-plugins didn't compile - might be related to a) though)
05:36:22 <shapr> likely
05:37:18 <basti_> c) cleaning up the installation (removing EVERYTHING ghc ;), reinstalling 6.2.2, then compiling 6.4 with it (the 6.2.2 i installed couldnt compile hs-plugins again, because it didnt have templates) yielded a compiler that would compile yi.
05:37:49 <shapr> wow
05:37:57 <basti_> long way huh
05:38:10 <shapr> I had a similar problem recently, I had to remove everything ghc and install only the ghc6.4 deb.
05:38:27 <basti_> related to a manually installed ghc? ;)
05:38:32 <shapr> I suddenly couldn't build pugs, and then couldn't build any other Haskell code.
05:38:46 <shapr> I don't know what happened. Maybe my evaluation license of GHC expired?
05:39:03 <basti_> maybe aptitude (or dselect) upgraded things without thought? ;)
05:39:19 <shapr> nah, I'm way paranoid about upgrading.
05:39:25 <basti_> I'm too
05:39:29 <basti_> but it's nice now and then
05:39:36 <basti_> (when you got some time to lose ;)
05:39:57 <basti_> there's a MUCH better sans serif font now :)
05:40:46 <shapr> Oh, I'm up to the minute, but I'm always careful about it.
05:40:58 * basti_ sighs
05:41:11 <shapr> I've had so few problems I'm now getting packages from experimental to keep from getting bored.
05:41:56 <basti_> did you ever realize that there is a huge problem in packet management as it is?
05:42:04 <bourbaki> moin
05:42:09 <basti_> hi bourbaki
05:42:17 <shapr> er, no? what problem?
05:42:46 <bourbaki> does anyone of you happen to know a good latex editor for mac os x?
05:42:46 <basti_> for example, there's no packet management i know of that keeps different versions of the same package at the same time
05:42:58 <mflux> rpm?
05:43:09 <mflux> ..some packets may conflict though..
05:43:11 <basti_> or, allows for packages to be marked "manually installed"
05:43:19 <shapr> I keep multiple version of the .deb files around so I can downgrade.
05:43:33 <shapr> you can do manual installations with apt-get.
05:43:37 <mflux> I believe aptitute marks which packets were installed to satisfy dependencies and which not
05:43:43 <basti_> and, passing metadata to ./configure
05:43:50 <basti_> i know shapr & mflux
05:44:15 <basti_> but what i want is to say "you do not know, but THIS package is installed (i did it myself)"
05:44:25 <shapr> you can do that.
05:44:27 <basti_> "do NOT touch it. ever."
05:44:29 <basti_> like how?
05:44:43 <basti_> apparently there is a reference to that in the aptitude doc
05:44:46 <shapr> there's a fake package generator, though I forget the name atm.
05:44:49 <basti_> but it doesnt work like i think it should
05:44:50 <basti_> ah.
05:44:52 <basti_> -.-
05:44:52 <basti_> ;)
05:45:20 <shapr> you just say "$PACKAGE is installed now"
05:45:22 <shapr> and it's done
05:45:36 <basti_> hmm i didnt think about doing it that way.
05:45:41 <basti_> but i'll read it up, then.
05:47:05 <basti_> hmm the emacs binding for yi is br0ken.
05:47:10 <shapr> yes it is
05:47:17 <shapr> and it's MY fault!
05:47:22 <basti_> aww
05:47:24 <shapr> blame me, everyone else does ;-)
05:47:30 <Itkovian> bourbaki: vim?
05:47:35 <basti_> what did you do with it?
05:47:44 <basti_> I'm getting: Couldn't match `[Yi.Editor.Action]' against `IO ()'
05:47:45 <shapr> actually in this case I really did commit to making the emacs binding happen. But it hasn't happened yet.
05:47:47 <bourbaki> Itkovian: i thought about something more wysiwyg like
05:47:54 <Itkovian> hmm
05:47:59 <bourbaki> otherwise my chioce would be emacs ;)
05:48:10 <Itkovian> bourbaki: I'll let you know when my powerbook arrives.
05:48:30 <basti_> which i understand, since Yi.Emacs.keymap is really not -> IO ()
05:48:31 <bourbaki> Itkovian: cool :)
05:49:07 <bourbaki> i still want to pin down my differential geometry idea but am a bit tired of the latex typeing though i did so much of it for homework
05:50:07 <shapr> basti_: check out the Nano binding, it's nearly an entire keymap tutorial.
05:50:33 <basti_> ok i will have a look
05:50:37 <bringert> shapr: did you have anything on Hope?
05:50:50 <shapr> nothing collected in one place
05:51:18 <shapr> I have a large number of scattered writings about it, including libs/apps where I might be able to steal Haskell source for direct use.
05:51:19 <bringert> we have decided that the project will be creating (some components of) a framework for haskell web apps
05:51:28 <shapr> I am *very* happy to hear thta.
05:52:10 <bringert> we need to get a project description together. nibro and I will write a prototype description, and we thought we'd put it on the wiki
05:52:14 <bringert> hej ralejs
05:52:17 <shapr> hej josef!
05:52:24 <shapr> sorry I haven't replied to your email yet, I got distracted.
05:52:25 <ralejs> hej bringert, nej shapr
05:52:30 <bringert> nej?
05:52:30 <df_> in http://davidf.woaf.net/test-hr.png i believe it shows that i'm leaking something is the sysSCpartition function, does any one have any advice on actually spotting what in that function is causing the issue?
05:52:36 <ralejs> Ooops, I meant hej....
05:52:40 <shapr> haha
05:52:50 <shapr> freudian slip because there was no April TMR :-)
05:52:50 <ralejs> shapr: what about Monad Reader
05:52:58 <ralejs> :-) ...
05:53:04 <shapr> I had too much contract work!
05:53:14 <shapr> I spent many hours hacking on Plone instead of organizing TMR.
05:53:35 <shapr> But this month, I'm going to set up an author's wiki so that a) I'm not the bottleneck and b) I'm not the only reviewer.
05:53:47 <shapr> Would you like to be an author for the march issue?
05:56:28 <shapr> bringert: ah, here's something Zope-oriented: two major abstractions are control flow and data persistence, and, Transactions let your code pretend that it never fails. interfaces/adapters.  these let your code pretend to be what others think it should be. authorization policy.  this lets your code not care about what's allowed and what isn't.
05:56:38 <Philippa> shapr: you mean march next year?
05:56:41 <shapr> greetings ralejs, how's the sausage?
05:56:49 <shapr> Philippa: sorry, I live in a nonlinear timeline.
05:57:07 <ralejs> shapr: what sausage, you mean the one on my homepage?
05:57:09 <shapr> ok honestly I can never remember which month goes where
05:57:11 <shapr> ralejs: yes!
05:57:34 <ralejs> Well, it's doing good I guess. It still looks good on my homepage doesn't it?
05:57:38 <Philippa> bringert: I'd done some thinking about it as well
05:57:49 <Philippa> though I suspect what I had in mind would be a bit difficult to get running fast atm
05:57:56 <shapr> bringert: dominic fox said that zope stores objects as both logic and data, meaning lots of state is really important. He also said that a Hope wouldn't require that.
05:58:12 <shapr> I am unable to visualize such a critter, but I sure wish I could.
05:58:18 <shapr> ralejs: Yes, very decorative.
05:58:39 * shapr laughs
06:00:04 <shapr> Dominic Fox also makes the point that databases have two different goals, persistence, and data management.
06:00:55 <shapr> ralejs: want to write for TMR2?
06:02:07 <ralejs> shapr: I wished I had the time. I have a lot of ideas for what to write, but I also have a thesis to finish...
06:02:45 * basti_ got Ctrl-X Ctrl-C working
06:02:57 <theorbtwo> Put the beginning of your theses in TMR?
06:03:28 <shapr> heh
06:03:34 <ralejs> Yes, that's an idea! But I will probably write the beginning last so it
06:03:40 <ralejs> it going to take a while.
06:03:43 <shapr> What's your thesis about?
06:03:52 <ralejs> Program analysis
06:04:10 <ralejs> More specific, I analyse haskell programs and try to do it very precisely
06:04:26 <boegel> ralejs: so do I, but I managed to write an article too
06:04:57 <ralejs> boegel: what article? Have I read it?
06:05:22 <shapr> Boegel wrote the gtk2hs tutorial.
06:06:09 <ralejs> Oh, right. Well, I have to finish my thesis in two months so the schedule is pretty tight for me right now.
06:06:17 <shapr> Oejet: I like your FFI article, I only wish I could publish it immediately. I know some people on #perl6 would like to read it.
06:06:21 <boegel> ralejs: how on earth should I know if you read it :)
06:06:29 <ralejs> :-)
06:07:14 <shapr> Oejet: There are a few spelling mistakes, but I didn't notice anything worse than my own spelling. :-)
06:08:25 <shapr> I wish I could find someone willing to do an arrows intro for TMR.
06:08:37 <shapr> And one for Template Haskell too.
06:08:49 <shapr> (this would get *me* out of doing it :-)
06:08:50 <ralejs> shapr: There is nothing saying that you couldn't publish it now. You could have a STABLE TMR in which you put things as they come in.
06:09:01 <shapr> Hm, that's an idea.
06:09:06 <ralejs> Once a month you could tag it as a release.
06:11:13 <shapr> That would be spiffy.
06:11:21 <shapr> And I could let lots of people proofread stuff then.
06:11:30 <ralejs> Indeed.
06:12:22 <shapr> Some authors have said that they'd rather evolve their behind curtained windows as it were.
06:12:33 <shapr> 'their article'
06:13:02 <CosmicRay> good morning everyone
06:13:03 <shapr> y0 CosmicRay
06:13:16 <ralejs> shapr: Well, that would be fine. It doesn't have to be mandatory to evolve you article in this fashion.
06:13:28 <Lunar^> CosmicRay: Hi!
06:13:35 <CosmicRay> hi shapr, lunar
06:13:40 <df_> hello</marvin-voice>
06:13:51 <Lunar^> CosmicRay: You've been featured on DWN ;)
06:14:02 <CosmicRay> df_: marvin the martian voice?  If so, I refuse to be disintegrated :-)
06:14:06 <CosmicRay> Lunar^: oh?  why? :-)
06:14:14 * CosmicRay reads for himself :-)
06:14:36 <df_> no, paranoid-android with pains in all the diodes down is left side
06:14:44 <CosmicRay> ah
06:14:47 <Lunar^> shapr: I have some ideas that might interest you by the way
06:14:52 <shapr> yes?
06:14:59 <CosmicRay> df_: from hhgtg, eh?
06:15:04 <df_> yes
06:15:05 <Lunar^> shapr: Marc Espie is working on a new package system for OpenBSD
06:15:44 <shapr> That name sounds familiar.
06:16:04 <Lunar^> shapr: and he's system is radically different from the other package system because it uses symbolic calculus on files (and other stuff) to check if a package is installable instead of trying to rollback if anything goes wrong
06:16:19 <Lunar^> s/he's/his/ (I need another coff)
06:16:50 <Lunar^> shapr: this made me think of something like a SecureIO monad, with an excecute :: SecureIO a -> IO a
06:17:09 <Lunar^> shapr: execute would check if everything would be fine before actually doing it
06:17:28 <Lunar^> shapr: I don't know if I'm clear :(
06:18:32 <shapr> It sounds a lot like STM.
06:18:49 <CosmicRay> shapr: hey shapr, have you got about 2GB of disk space and a little bit of bandwidth to spare on your server?
06:18:51 <Oejet> Lunar^: I think that would require either a) a lock on the system or b) transactions like STM.
06:19:04 <shapr> CosmicRay: why?
06:19:05 <Oejet> STM also requires a lock.
06:19:19 <CosmicRay> shapr: people.debian.org is down and I'm looking for a place to store my Debian From Scratch ISOs
06:19:42 <shapr> I've got the space, not sure about the bandwidth
06:20:01 <Oejet> shapr: Thanks w.r.t. the article.  My speling will improve eventually, I hope.
06:20:03 <CosmicRay> I have the opposite problem
06:20:14 <Lunar^> Oejet: Yes, I've looked at Linux fnctl and stuff to see if this is possible
06:20:29 <Lunar^> shapr: But I think that would be great for server shell scripts
06:21:04 <Igloo> CosmicRay: Is it worth moving and readvertising just until gluck comes back?
06:21:08 <shapr> STM allows for more reliable servers.
06:21:12 <Oejet> Lunar^: Then you would have to lock the kernel, interupts and all.  How far have you thought it?
06:21:27 <bringert> anybody got a good name for a Haskell web app framework?
06:21:27 <CosmicRay> Igloo: well I just asked on debian-devel when gluck will be back and the word seems to be post-sarge
06:21:28 <CosmicRay> so yes
06:21:36 <CosmicRay> since I'm already getting e-mails about it
06:21:40 <CosmicRay> I hate getting e-mails
06:21:41 <CosmicRay> :-)
06:22:06 * Igloo thinks that's rubbish, BICBW
06:22:13 <CosmicRay> Igloo: the post-sarge bit?
06:22:16 <Lunar^> Oejet: For filesystem manipulations ?
06:22:18 <Oejet> bringert: Webby?
06:22:20 <Igloo> yup
06:22:32 <Oejet> Lunar^: Yes.
06:22:41 <Lunar^> bringert: Isn't that Haifa?
06:23:03 <Lunar^> Oejet: I don't see why. Could you explain? :)
06:23:04 <CosmicRay> bringert: btw, ParseDate rocks.  it should be in fptools.
06:23:09 * shapr agrees
06:23:17 <shapr> ParseDate is awesome.
06:23:36 <Oejet> Lunar^: I mean, what did you find out about Linux fnctl?
06:24:03 <Lunar^> Oejet: that I can't spell it right :)
06:24:13 <Oejet> Is ParseDate better than the Java one?
06:24:29 <CosmicRay> ParseDate is basically the same as strptime() in C
06:24:33 <CosmicRay> I don't know what Java has
06:25:20 <Lunar^> Oejet: there is a mandatory locking system in Linux
06:27:23 <Oejet> Date DateFormat.parse(Stringsource) .
06:28:18 <shapr> bringert: schvung?
06:29:40 <Lunar^> Oejet: but it doesn't seem to fit with my idea
06:29:54 <Oejet> bringert: Boomerang.
06:31:05 <shapr> Harrow, SilkShirt, Kombinator, Wugs, funkcore, ChurchAndSTate, ...
06:31:22 <shapr> STate is too funny =)
06:33:27 <Oejet> Man, ChurchAndSTate is way overloaded.
06:33:32 * shapr snickers
06:34:16 <shapr> ralejs: hej, do you know if recursive typeclass dictionaries means that John Hughes' CGI Arrow problem is solved?
06:34:36 <shapr> Does that mean extra constraints can be applied to a typeclass like Cale was asking on the mailing lists?
06:36:02 <ralejs> shapr: no, I don't think it solves the problem, but I haven't looked into it.
06:36:07 <shapr> foo
06:36:40 <shapr> I dearly wish I could get a continuation based web app framework in Haskell. Without the cheesy log problems that WASH has.
06:37:01 <ralejs> shapr: Talk to nibro
06:37:15 <CosmicRay> shapr: yes indeed
06:37:15 <shapr> Haskell Server Pages?
06:37:21 <ralejs> Indeed
06:37:26 <CosmicRay> shapr: I find myself not really taking advantage of wash because of that.
06:37:35 <shapr> Is the code online? I could only find nibro's thesis.
06:37:36 <CosmicRay> I'm actually rather frustrated with it.
06:37:40 <shapr> CosmicRay: you and me both.
06:38:04 <shapr> I like writing Haskell, but I don't want to use WASH.
06:38:08 <ralejs> nibro started on a web app framework on top of HSP. He didn't get as far as he hoped though
06:38:33 <ralejs> Before finishing his Masters thesis that is.
06:38:43 <shapr> Is his code online?
06:38:46 <shapr> nibro: yello? statue?
06:39:38 <musasabi> shapr: Wouldn't that require restricted kinds?
06:39:52 <ralejs> shapr: No, I can't find his code online.
06:39:57 <shapr> I don't remember.
06:40:26 <shapr> CGIArrow and SerTH together sure would be nice though.
06:41:26 <ralejs> Well, to be honest I think the arrows framework is flawed.
06:41:53 <shapr> ?
06:41:55 <shapr> how so?
06:42:29 <ralejs> The 'arr' or 'pure' combinator require every arrow to include the function arrow.
06:42:38 <ralejs> This is a bit too strong.
06:43:05 <ralejs> But throwing out 'arr' is a pretty big thing since it's used everywhere in arrow programs
06:43:26 <musasabi> instead of class Monad m where return :: a -> m a, one would need something like class (Sat e a) => Monad m | m -> e where return :: a -> m a or something similar.
06:44:35 <shapr> I really like arrow-style parsers.
06:44:49 <shapr> And I think darcs patches as arrows would be a useful optimization.
06:45:05 <ralejs> I'm not saying arrows aren't useful. I just say that they could be better.
06:45:09 <shapr> any ideas?
06:45:16 <ralejs> Throw out 'arr'.
06:45:29 <shapr> How do you lift functions then?
06:45:32 <musasabi> shapr: The fundamental problem is how to limit the values that can get "inside".
06:45:35 <ralejs> With lift.
06:45:45 <Oejet> shapr: Why do you think Darcs patches couldn't be optimized easily with monads?
06:45:52 <shapr> Oejet: no static properties.
06:46:28 <shapr> ralejs: There really aren't many arrow programs out there. I've looked.
06:46:43 <Oejet> shapr: And the static properties of patches are what?
06:47:08 <shapr> How a patch could conflict, to whatever level of detail you want
06:48:07 <shapr> darcs ops are expensive because they're recursive, and done patch by patch. If you could stick together two patch arrows to get a new arrow that has the conflict properties of both, you could sort/grade the incoming patches and the repository quickly.
06:48:13 <shapr> Make sense?
06:48:28 <shapr> Heffalump accuses me of crack-smoking in this idea, but I'm sure it will work.
06:49:10 <shapr> It helps that David came up with the same idea of sorting patches independently.
06:49:28 <Oejet> shapr: Crystal.  It's like in parsec where you have to use try, and arrows would solve that by bringing lookahead information back.
06:49:30 <shapr> ralejs: Does John Hughes agree with you?
06:49:36 <shapr> Oejet: you got it.
06:50:51 <musasabi> shapr: actually wouldn't a TH based parser generator be better for most tasks (with static grammar) ?
06:51:20 <shapr> ralejs: I can't intelligently discuss the idea of getting rid of arr/pure. But from what I've heard from other people on this channel, it would fix a lot of user problems with arrows.
06:51:22 <ralejs> sorry for the delay, I had a visitor.
06:51:50 <shapr> In my view, IRC is inherently asynchronous. It's like fast email.
06:51:56 <ralejs> shapr: I haven't talked with John about this directly but from what I've heared he's no alien to the idea
06:51:58 <shapr> musasabi: how so?
06:52:21 <shapr> musasabi: which tasks?
06:52:25 <shapr> musasabi: oh! yes!
06:52:35 <musasabi> shapr: one can create a much more efficient parser that way, of course that does not apply if the grammar is dynamic.
06:52:40 <shapr> mix that with duncan's partial evaluator...
06:52:50 <musasabi> Something like happy/alex from TH.
06:53:12 <shapr> arrows, TH, duncan's partial eval code, I like this idea!
06:53:42 <bringert> Lunar^: I thought HAIFA was mostsly about SOAP
06:53:42 <shapr> ralejs: I and others would like to have really usable arrows, who do we push?
06:53:59 <bringert> we are a talking about web apps in general, not just web services
06:54:15 <Oejet> So you write a Happy-like specification in Template Haskell which gets compiled to an optimized parser?
06:54:16 <ralejs> shapr: me :) I have a prototype library which I think solves many problems with arrows
06:54:41 <shapr> ralejs: Would you like to write an artitcle about arrows and possible changes for TMR2?
06:54:47 <shapr> Is your code online?
06:55:01 <shapr> Have you decided to call your combinators spears?
06:55:11 <shapr> (nobody say britney)
06:55:20 <theorbtwo> Bows?
06:55:24 <CosmicRay> shapr: pickle?
06:55:31 <shapr> sauerkraut?
06:55:42 <ralejs> shapr: The library, call Category, is a direct haskellization of category theory. It's not onle.
06:55:53 <ralejs> Online, I mean...
06:56:09 <ralejs> I mean NOT online.
06:56:13 <shapr> Would getting it online require a gift certificate for systembolaget?
06:56:24 <ralejs> I don't drink alcohol.
06:56:36 <shapr> You could bribe others with it =)
06:56:43 * shapr grins
06:56:47 <ralejs> :)
06:57:04 <bringert> shapr: nibro is sitting right next to me here
06:57:10 <shapr> bringert: attack!
06:57:21 <ralejs> Well, I should put it online. I'll do it before the weekend.
06:57:22 <bringert> he says he will release the code soon...
06:57:22 <shapr> What does he say about HSP?
06:57:25 <shapr> yay!
06:57:34 <Itkovian> i'm off
06:57:36 <Itkovian> ttyl
06:57:39 <ralejs> nibro has said that a long time.
06:57:49 <ralejs> I don't believe him.
06:57:53 * shapr snickers
06:58:03 * CosmicRay wonders why people want to wait to release code
06:58:17 <CosmicRay> put it up in darcs somewhere, people get what they get if they download it
06:58:18 <shapr> CosmicRay: They write papers about it, and that's how they get paid.
06:58:23 <mflux> cosmicray, maybe because.. then they'll get those darn things.. users
06:58:36 <CosmicRay> mflux: they can always use the most helpful key on the keyboard:
06:58:38 <CosmicRay> delete
06:58:39 <ralejs> Because they are pedantic and afraid of releasing something halfbaked.
06:58:45 <mflux> it'll wear out
06:58:57 <ralejs> Yes, I suppose.
06:58:59 <CosmicRay> ralejs: yeah I know.  they shouldn't be.
06:59:02 <shapr> I just want cool code.
06:59:06 <CosmicRay> yeah
06:59:18 <CosmicRay> who knows, maybe it's halfway cool and some helpful people will finish it.
06:59:22 <CosmicRay> worked for linus. :-)
06:59:31 <mflux> because it's their own precious baby, and don't want others prodding her
06:59:32 <shapr> Yeah, I really wish I could hack on QuickCheck2
06:59:35 <shapr> really very much
06:59:44 <shapr> I think I shall mailbomb Koen.
06:59:52 <shapr> ok not really.
07:00:13 <CosmicRay> well then hack on it, and if he doesn't take your hacks, you release ShaprCheck2
07:00:31 <shapr> Actually, I'm tempted to do that, but I really don't want to piss off guys who write such amazingly cool code.
07:00:44 <CosmicRay> I would hope they wouldn't be pissed about that.
07:01:09 <CosmicRay> frankly, if somebody took me code and made it better, I'd be thinking "Great!  Free help!"
07:01:25 <shapr> I wrote the test-driven-development hack into quickcheck, and I'd like to add static value HUnit style testing to that hack.
07:01:46 <shapr> I'd also like to extend QuickCheck{ST,M} to handle full IO values as TheHunter suggested.
07:02:55 <CosmicRay> people that are all posessive about their code annoy me.
07:03:08 <CosmicRay> it would be great if there were some people itnerested in hacking on missingh, for instance
07:03:25 <shapr> It's not really like that. Jus that the academic world has a conflict of interests in some ways. The first to publish an idea gets lots of credit, so if you share everything someone else may beat you to it.
07:03:38 <CosmicRay> hmm.
07:03:51 <CosmicRay> I suppose I can see that
07:04:32 <shapr> Your yearly pay can go up dramatically if you publish a dramatic scientific improvement.
07:05:52 <shapr> I can't think of a better system, sadly.
07:05:59 <ralejs> Alright then! darcs get http://www.cs.chalmers.se/~josefs/category
07:06:13 <shapr> w00
07:07:37 <shapr> You can make a CGI Category with this?
07:08:15 <ralejs> shapr: don't know, but I think so.
07:08:23 <ralejs> Gotta split. See you.
07:08:26 <shapr> ok, cya
07:08:28 <shapr> thanks for the code!
07:08:30 <shapr> doh
07:08:47 <musasabi> Any idea why I get with darcs lambdabot "Loading package Cabal lambdabot: /usr/lib/ghc-6.4/HSCabal.o: unknown symbol `__stginit_Prelude_'" ?
07:11:18 <theorbtwo> It's looking for the Prelude.
07:11:19 * Philippa laughs
07:11:33 <Philippa> too bad he left
07:11:45 <bringert> here's a first shot at a project description for a web app framework: http://www.haskell.org/hawiki/WebAppsFramework
07:11:50 <bringert> please edit
07:11:55 <bringert> if you want
07:12:13 <Philippa> shapr: any of that look mildly familiar? Cool to see somebody's playing with the same idea(s)
07:12:16 <musasabi> theorbtwo: yes, I know but I am more interested whether it is something I am doing or is it expected to be broken.
07:12:16 * tmoertel needs espresso N O W
07:12:28 <shapr> Philippa: yes, terribly familiar.
07:12:34 <theorbtwo> You need to load HSbase first.
07:12:38 <shapr> Philippa: you better get on it with that paper.
07:12:43 <theorbtwo> It's expected, AFAIK... what loader are you using?
07:13:51 <shapr> bringert: and pugs, would make a good layer on top for those who do not wish to use Haskell.
07:14:30 <Philippa> shapr: I suspect ralejs knows the maths well enough to do a better job than me...
07:14:33 <bringert> shapr: haha
07:16:05 <musasabi> reordering packages in Depends.hs helps.
07:17:27 * shapr stabs Plone with a stick
07:19:37 * shapr will never try to argue with Frank Atanassow
07:20:28 <bringert> CosmicRay: I posted ParseDate to the libraries list at some point I think. nobody seemed very enthusiastic about it.
07:20:35 * bringert goes to have lunch
07:21:10 <shapr> I sure was enthusiastic when I found it.
07:21:58 <basti_> hmm does yi have a "incremental regex search" feature?
07:22:21 <basti_> because this is mondo important
07:24:27 <shapr> Yi keymap lexers are built from the lazy regex combinators of CTK/CTKLight, I bet you can add that feature pretty easily.
07:24:50 <basti_> :))
07:25:35 <shapr> There's a paper by Manuel Chakravarty on "fast lazy lexers", worth reading.
07:26:20 * shapr tries to read his own code from two years ago.
07:26:39 * shapr thinks "What kind of crap is this? Who wrote this pile of ... oh."
07:29:08 <shapr> The fast lazy lexers are really quite spiffy. Rather than using the standard optimization of creating a table-based fast regex matcher at startup, the table entries are created the first time each regex is called. Then you have a) fast startup b) table entries for second time calls, c) no wasted space for unused regexes.
07:30:03 <nlv11757_> why will you never argue with F. Atanassow shapr?
07:30:31 <basti_> i heard about that...
07:30:32 <shapr> nlv11757_: Mostly because I'd get squished. Have you seen him discuss on LtU?
07:32:28 <nlv11757_> LtU?
07:32:53 <vegai> http://lambda-the-ultimate.org/
07:32:56 <nlv11757_> ah
07:33:15 <nlv11757_> no i havent seen him argue there, i think i attended a talk of him once
07:33:39 <nlv11757_> quite some catagory theory as i recall
07:33:48 <nlv11757_> or category
07:38:12 <musasabi> shapr: that fast lexers stuff seems nifty for implementing regexs in pure haskell...
07:38:33 <shapr> I haven't compared it to the other implementations.
07:38:49 <shapr> I do like the fast and lazy part.
07:42:59 <JaffaCake> afternoon, #haskell
07:43:06 <shapr> hiya JaffaCake
07:43:31 <xerox> Hiya
07:43:41 <vegai> heh, did you read "Fold Must Fold!" on LtU?
07:44:13 <vegai> http://lambda-the-ultimate.org/node/view/613
07:45:59 <shapr> bringert: Ruby On Rails may give more inspiration for a Haskell Web App Framework.
07:46:03 <shapr> I haven't yet tried it though.
07:47:43 <Philippa> shapr: I have a stinking suspicion RoR relies on having an easy time persisting continuation-like things
07:48:48 <shapr> I suspect so.
07:55:24 <Philippa> anyway, that's pretty much why I sorta wanted to (ab)use hs-plugins to build a typeful object database - thus conveniently making code persistable
07:57:32 <musasabi> RoR looks very nice and I don't think it requires persistent code, but I could be wrong.
08:00:05 <Philippa> I should probably look it over thoroughly at some point
08:10:21 <TFK> Woo! :e <file> kinda worked!
08:10:34 <shapr> yay!
08:12:13 <TFK> Only it apparently fires up the default editor, which is notepad, which sucks. I will now looks into the options of WinHugs.
08:19:04 <basti_> these fast lazy lexers seem wonderfully clean :)
08:26:12 <basti_> would they be able to dynamically change from an "associative list" to "array" node?
08:26:40 <shapr> ?
08:27:29 <basti_> they'd store the states in two kinds of nodes: one uses an associative list to map a character to a transition, the other one uses an "array"
08:28:29 <shapr> Are you trying to build nested keymaps?
08:28:36 <basti_> ah no.
08:28:44 <basti_> i'm just thinking myself into these fast lazy lexers
08:28:49 <basti_> for fun
08:28:56 <shapr> I don't know the answer to your question.
08:29:08 <shapr> dons might, if he's awake.
08:29:13 * basti_ nods
08:30:49 <basti_> this is hard compiler construction crack.
08:31:38 * shapr laughs
08:32:21 <TFK> How cute. JCreator corrupts the screen image.
08:32:24 <basti_> incremental search would be cool.
08:32:49 <basti_> i'm wondering if that could be done with Laziness...
08:33:38 <TFK> Is Haste going to be open source/otherwise free?
08:35:01 <basti_> hmm.
08:35:11 * basti_ .o ( -wonders- )
08:35:21 <basti_> phew.
08:35:55 <basti_> but.
08:36:13 <basti_> "incremental search" is a fixed-text algorithm
08:36:17 <basti_> thats why it's so quick
08:36:28 <basti_> or, should be.
08:36:55 <basti_> this in haskell... mmmmhhhhnnnggh
08:37:34 * basti_ 's brain implodes.
08:41:48 <Oejet> That happens a lot.
08:43:17 * TFK reads Flippi code
08:43:45 * basti_ reads Yi code
08:43:46 <TFK> ('e':'d':'i':'t':'=':[]) -> Default -- isn't this the same as ("edit=") -> Default ?
08:44:06 <xerox> I think so.
08:44:13 <TFK> And why are parentheses there?
08:44:20 <xerox> Dunno really.
08:44:24 <TFK> *why are the parentheses ...
08:44:47 <basti_> i think because sometimes pattern matching sucks without.
08:45:00 <basti_> but i think not in "case of"
08:45:03 <TFK> What do you mean?
08:45:14 <TFK> Well, this is in a "case of" statement
08:45:20 <TFK> Still, a string is a string... no?
08:45:22 <basti_> like "testfuc 'h':'a':[] = 109"
08:45:34 <basti_> this might provoke an error in some circumstances
08:45:38 <basti_> parsingwise
08:45:55 <TFK> Ah, ok, I got it
08:46:22 <TFK> Still, I wonder why the strings are built char-by-char like that.
08:46:26 * basti_ shrugs
08:46:28 <basti_> n00b? ;)
08:46:29 <Oejet> TFK: I think could be related to that you cannot match like this: case s of "edit=":rest ->...
08:46:45 <Igloo> Pattern matching doesn't suck, you just have to remember the golden rule: juxtaposition binds tightest
08:47:02 <TFK> Speak English, people.
08:47:12 <basti_> juxtaposition?
08:47:28 <TFK> That word I kinda know, but the rule makes no sense.
08:47:41 <Igloo> Next to, roughly
08:47:55 <Igloo> testfuc is next to (juxtaposed with) 'h'
08:48:01 <basti_> ah.
08:48:02 <Igloo> So it's like there are parentheses around it
08:48:09 <Igloo> "(testfuc 'h'):'a':[] = 109"
08:48:13 <basti_> ahh.
08:48:17 <TFK> I got the parentheses thing already :-/
08:48:34 <basti_> hmm okay.
08:48:47 <basti_> and everything with no blanks in it is not juxtaposition yes?
08:49:01 <Igloo> "no blanks"?
08:49:15 <basti_> no whitspace
08:49:19 <Igloo> "x+y" and "x + y" are the same
08:49:19 <TFK> I'm wondering about the peculiar string building, and this is Philippa's code, so blame her :-P
08:49:21 <basti_> ehr
08:49:25 <basti_> non-whitespace
08:49:43 <basti_> so "x \n\r x" would be juxtaposed
08:49:51 <basti_> whereas "x    .    x" wouldnt?
08:49:55 <Igloo> Right
08:50:30 <Igloo> In the second case it's the . joining the 2 xs rather than the nothingness
08:50:54 * basti_ nods
08:51:01 <basti_> okay this makes sense.
08:51:24 <Igloo> You might prefer to think "function application" instead of juxtaposition; in fact, I was going to say that, but it doesn't make as much sense when you're thinking about patterns
08:51:34 * basti_ nods
08:51:52 <basti_> juxtapositions is a formal grammars term where function application is coding theory.
08:52:40 <Igloo> An UG question that people often get wrong tells you to put all the parens in some expression containing things like   f x+y + z + g w
09:12:33 <Oejet> I am stuck defining the zeroArrow for the arrow based parser library described in Hughes paper.   This is how far I've got:  zeroArrow = P (SP True []) (DP (\(a,s) -> (???,s))).  Any suggestions?
09:17:19 <df_> does anyone have any advice for finding out what is causing memory to be lost (i assume through non evaluation).  I have profiled the code (results at ftp://ftp.bbc.co.uk/incoming/test-h.png )? I can't see what in that function could be causing it
09:17:27 <shapr> Oejet: have you read Ross Paterson's Fun of Programming chapter?
09:17:55 <Oejet> shapr: Maybe, but I don't recall it.
09:19:54 <Oejet> shapr: "Arrows and Computation"?
09:20:11 <shapr> sounds right
09:20:53 * xerox 's teatime
09:22:44 <TheHunter> Oejet, zeroArrow = P (SP False []) undefined ?
09:26:13 <Oejet> TheHunter: It compiles, but I don't really know, because I haven't understood the types a and b in data Parser s a b = P (StaticParser s) (DynamicParser s a b).
09:28:33 <TheHunter> Oejet, seems like the dynamic part isn't invoked if the static part fails to hold. Therefore, it doesn't matter what you write there and you might as well set it to undefined.
09:29:24 <TheHunter> hmm, perhaps DP (const undefined)
09:31:34 <Oejet> TheHunter: That's it!  It will never be invoked because the starters set is always empty, [].
09:37:45 <TheHunter> Oejet, you know RP's Arrow transformer library?
09:39:26 <Oejet> Nope.
09:39:27 <TheHunter> @google haskell "arrow libraries"
09:39:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/arrows/arrows/
09:41:11 <TheHunter> i think it's a nice exercise to break the Parser into pieces and implement it with those transformers.
09:42:15 <TheHunter> it's the static version of a kleisli arrow
09:43:32 <Oejet> That is way over my head right now.  So far I've got arr, >>>, zeroArrow, <+> and token.
09:53:06 <SyntaxNinja> does anyone remeber the details of a cabal bug mentioend here yesterday?
09:53:13 <SyntaxNinja> I was in the middle of filing it when I got interrupted :(
09:55:50 <SyntaxNinja> NM
09:56:15 <Oejet> Yay, now I've also got runParser.  That makes a minimal library.
10:22:49 * basti_ is ruling heavily
10:36:17 <gzl> how would one best describe Hudak's contribution to Haskell?
10:36:32 <gzl> i know he contributed to the haskell 98 report
10:38:53 <SyntaxNinja> gzl: he's a yale professor, leads a research team there that does a lot of haskell work
10:39:07 <SyntaxNinja> he also wrote The Haskell School of Expression, one of the  main haskell books
10:39:14 <SyntaxNinja> and he edits the journal of functional programming
10:39:28 <gzl> yeah, i know all that
10:39:43 <gzl> sorry, i'm not describing this well.
10:39:54 <gzl> for stroustrup, one could just say "inventor of C++"; i'm looking for something equally quick and snappy
10:40:11 <Heffalump> you won't find it, IMO
10:40:23 <gzl> ok, then that's fine.
10:40:31 <gzl> just making sure there wasn't one if i wasn't going to give one
10:41:04 <gzl> (i got him to give a talk here, so i needed to give some info about it)
10:43:33 <shapr> gzl: he's one of the foremost researchers in DSLs
10:43:49 <shapr> gzl: look at Haskore, Dance, Yampa, etc
10:44:03 <metaperl_> what are Dance and Yampa?
10:44:26 <Heffalump> it's possible he invented the concept of EDSLs.
10:44:46 <gzl> shapr: no, i know all of this, i just wanted to know if there was a snappy line like that :)
10:44:53 <gzl> shapr: he already came and give a talk on Haskore and Yampa
10:44:57 <gzl> * gave
10:44:59 <shapr> wow
10:45:02 <shapr> Did you record it?
10:45:08 <gzl> no, they didn't have the equipment :(
10:45:11 <shapr> suck
10:45:49 <basti_> hey shapr I'm currently working at Emacs-mode
10:45:51 <SyntaxNinja> gzl: is 'guru' snappy enough?
10:45:51 <shapr> metaperl_: Dance is a DSL for humanoid movement, it's based on Labonotation
10:45:55 <shapr> basti_: awesome!
10:45:56 <basti_> for fun & learning
10:46:07 <SyntaxNinja> basti_: ! you know about the emacs-mode 2.0, right?
10:46:17 <basti_> Ctrl X prints !!! but doesnt do anything
10:46:24 <basti_> SyntaxNinja: sorry Emacs.hs, not emacs-mode.el
10:46:29 <basti_> but do tell, i haven't heard
10:46:33 <SyntaxNinja> oh, for Yi? that's good too
10:46:46 <shapr> metaperl_: Yampa is the next iteration in Functional Reactive Programming, this time it uses signal transformers and you can't get hold of the signals directly
10:46:46 <gzl> SyntaxNinja: yes. but not descriptive enough. but don't bother. i'll just tell the person who he is and then they can figure out how to snappify it
10:46:48 <SyntaxNinja> basti_: just check out the haskell-mode web page; there's a link there.
10:46:49 <basti_> uh haskell-mode.el
10:46:54 * basti_ nods
10:47:31 <metaperl_> perhaps the intro to haskell on haskell.org should have more links to the power of Haskell in DSLs?
10:48:34 <shapr> gzl: what about "Paul Hudak is one of the original contributors to the Haskell 98 Report and one of the foremost researchers in the field of Domain Specific Languages. His embedded languages do such things as produce musical scores, direct industrial robots, and power purely functional aliens in a version of Space Invaders."
10:48:51 <gzl> yeah, what I had is very similar to that
10:48:51 <gzl> thanks
10:49:01 <gzl> btw, he's WAY nicer than stroustrup. ;p
10:49:04 <shapr> heh
10:51:52 <Khisanth> purely functional aliens ... o_O
10:52:04 <gzl> actually, he was the primary organizer and chairperson of the haskell committee (which wrote the report). so even better. :)
10:52:22 <Heffalump> which version of Haskell?
10:52:44 <Heffalump> not Haskell 98
10:52:54 <shapr> oh, 1.3, 1.4?
10:52:59 <gzl> the original thing.
10:53:08 <gzl> i don't know which one exactly. it doesn't say.
10:53:22 <gzl> does "The Haskell Committee" refer to any version in particular?
10:53:36 <gzl> I'm just going by this. http://www.cs.yale.edu/people/faculty/hudak.html
10:55:12 <gzl> anyway, have to run for a bit, but thanks for the suggestions.
10:55:23 <Heffalump> yes, each revision has its own committee
10:55:26 <Heffalump> there's a lot of continuity though
10:58:53 <Oejet> @paste
10:58:54 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://www.haskell.org/hawiki/HaskellIrcPastePage
11:02:39 <Oejet> shapr: Would an arrow parser library look roughly like on the paste page?
11:07:05 <shapr> hm, looks neat.
11:07:09 * shapr tries
11:09:20 <shapr> seems to work too
11:10:36 <shapr> spiffy!
11:11:53 <df_> humph
11:20:00 * TheHunter wonders what Hughes meant with the line "if empty1 then p1 (a, s) else p2 (a, s)". Shouldn't that just be undefined?
11:20:50 * Oejet has stopped wondering and just accepts the black magic. :-P
11:23:00 <TheHunter> the precondition for the dynamic parser to be executed is that x `elem` starters if the input starts with x. That means that line never gets executed doesn't it?
11:33:39 <Oejet> Sorry, my screen jammed.
11:34:26 <SyntaxNinja> only one man would DARE give me the strawberry!
11:36:42 <vegai> oh wait. Does ghc-6.4 include Cabal?
11:37:11 <vegai> seems so
11:37:35 <SyntaxNinja> vegai: yes!
11:37:45 <SyntaxNinja> as does the most recent hugs AND nhc98
11:38:58 <Igloo> Hurrah!
11:39:55 <SyntaxNinja> :)
11:39:56 <vegai> oh bugger
11:40:13 <vegai> or good, but I just built an extra version ...
11:40:38 <vegai> ah, now it's removed for good
11:42:00 <SyntaxNinja> Oo
11:42:34 <vegai> I had 0.5 from haskell.org/cabal and 1.0 from GHC, and that obviously wasn't good
11:43:02 * SyntaxNinja nods
11:43:12 <vegai> has anyone made yet a Cabal skeleton?
11:43:26 <vegai> you know, a clean slate
11:43:48 <vegai> I guess it's not as important as for autotools...
11:45:04 <SyntaxNinja> whadoyamean?
11:45:58 <vegai> oh, I guess it would contain a dummy .cab and Setup.hs
11:46:21 <vegai> so you would just fill in the fields in the .cab and *bam* Cabalized Haskell program.
11:46:42 <SyntaxNinja> makes sense
11:46:50 <SyntaxNinja> where should they live?
11:47:02 <SyntaxNinja> I mean, there's at least a dummy Setup.lhs in the documentation
11:47:28 <vegai> I'll probably put one up in my darcs repo, I at least will have use for it
11:48:08 <vegai> not a huge time-saver, but ... perhaps might make adopting Cabal a bit easier?
11:48:39 <vegai> I'm also thinking of making the skeleton so that it supports HUnit and QuickCheck tests
11:49:20 <vegai> whatever that means, I'm not sure yet
11:50:13 * vegai wanders off to the sauna, muttering along the way.
11:50:28 <SyntaxNinja> heh
11:53:30 <TFK> Can <- binding be used everywhere?
11:54:26 <gzl> only in do blocks
11:55:05 <TFK> So how come here: http://www.haskell.org/tutorial/stdclasses.html <--- ReadS and reads don't seem to be defined in terms of do blocks or IO types...
11:56:01 <gzl> oh
11:56:10 <gzl> that's a list comprehension
11:56:18 <TFK> So it's OK in a list comprehension?
11:56:29 <gzl> yes, and a List is a monad anyway
11:56:38 <TFK> Dirty talk :-/
11:56:44 <SyntaxNinja> in a list comprehension, you can read it as "set membership" rather than "bind"
11:56:50 <gzl> yeah, think of it as set membership
11:56:54 <TFK> What's "set membership"?
11:57:14 <gzl> in math, you can write "x in {1,2,3}" meaning that x is in the set {1,2,3}
11:57:16 <SyntaxNinja> sorta like the (- symbol in math
11:57:25 <gzl> the "in" symbol is an epsilon which looks kind of like <-
11:57:51 <TFK> But it's a binding, not a boolean...
11:58:02 <Igloo>  for the unicode-enabled
11:58:07 <TFK> They get values that can be accessed in the scope, no?
11:58:14 * TFK is UTF-8 compliant :D
11:58:18 <ibid> oy
11:58:22 <ibid> unicode rocks
11:58:36 <Lemmih> SyntaxNinja: Hey.
11:58:39 <SyntaxNinja> y0
11:58:45 <gzl> TFK: not boolean. it's like "let x in {1,2,3}"
11:58:52 <gzl> TFK: it's a binding in this case too
11:58:57 <gzl> "binding"
11:59:06 <TFK> But x can be any value for those, then.
11:59:19 <TFK> That <- is more like a pattern match.
11:59:28 <SyntaxNinja> sorta like "x such that x is a member of {1,2,3}.   that is, "x | x <- [1,2,3]"
11:59:53 <TFK> Hmm. That makes sense.
11:59:55 <gzl> yeah, [ x | x <- [1,2,3] ] = [1,2,3] and { x | x \in {1,2,3} } = {1,2,3}
12:00:50 <shapr> Man I love unicycling.
12:01:17 <TFK> OK, and in monads <- means a different thing? Or is it exactly the same?
12:02:07 <gzl> if you have
12:02:23 <gzl> do { x <- foo; return (f x) }
12:02:27 <gzl> it's the same as
12:02:51 <gzl> foo >>= \x -> return (f x)
12:03:00 <TFK> You do realize I'm a newbie, right?
12:03:19 <TFK> (I have no idea what >>= is, or what that lambda is doing there.)
12:03:32 <gzl> oh, i assumed since you were talking about monads you knew about >>=
12:03:35 <TFK> I'm guessing foo is sending a value to the lambda, i.e. x, which gets returned. somehow.
12:03:47 <TFK> A "monad" is a word that I repeat because I want to sound smart :-)
12:03:52 <TFK> And also because the tutorials talk about it.
12:03:56 <gzl> yes, the <- thing is different in monads, and it's sugaring for writing stuff with >>=
12:04:02 <ibid> monads are just warm, fuzzy things
12:04:10 <gzl> with sharp edges at the front.
12:04:20 <ibid> in do notation, <- is roughly "assignment"
12:04:25 <yaarg> it's also the new ms shell
12:04:38 <TFK> OK, thanks.
12:04:44 <gzl> for example, if foo produces an IO String
12:04:54 <gzl> then if you do x <- foo, x will be a String
12:05:02 <gzl> it'll yank it out of the monad
12:05:25 <gzl> (and then return will put the IO back.)
12:05:45 <TFK> Really? x won't be IO String?
12:05:51 <gzl> no, that's the whole point.
12:06:14 <SyntaxNinja> foo is the IO string, x is the string
12:06:36 <TFK> Hmm, ok, thanks.
12:08:25 <yaarg> badgers
12:10:21 * df_ sighs
12:10:27 <shapr> df_: yes?
12:10:34 <shapr> yaarg: snake, it's a snake!
12:10:40 <gzl> TFK: http://www.nomaware.com/monads/html/ is a good monad tutorial.
12:10:55 <gzl> and http://haskell.org/hawiki/ThatAnnoyingIoType is useful too.
12:11:05 <TFK> Thanks, but I'm still only in chapter 8 of Gentle
12:11:17 <gzl> well, then read it later.
12:11:41 <df_> 226MB resident set size - leaking memory
12:11:44 <TFK> I found that with enough determination, after some finite number of readings, it begins to make some sense.
12:12:12 <shapr> df_: long running process?
12:12:31 <gzl> are you new to haskell or FP in general?
12:12:32 <df_> no, very short running process
12:12:40 <df_> 5mins sofar
12:13:01 <shapr> loading a bunch of stuff into memory?
12:14:28 <df_> ftp://ftp.bbc.co.uk/incoming/test-h.png
12:14:41 <df_> (an earlier profiling)
12:15:05 <df_> no, its processing a stream, i think something isn't being evaluated and is just sticking around, but i've got no idea what
12:15:17 <CosmicRay> df_: is your code published somewhere?
12:15:24 <CosmicRay> df_: what did you use to generate that graph?
12:15:31 <df_> hp2ps
12:16:06 <df_> the code isn't at the moment, i'll try and get a tarball up
12:16:16 <CosmicRay> it looks pretty and I think it's interesting and odd that you have bursts of activity all along that gradually increasing slope
12:16:25 <shapr> yeah, that's a strange pattern.
12:16:30 <df_> ah, thats because you have not asked what the program is
12:16:43 <CosmicRay> df_: well then.  what is it? :-)
12:17:05 <CosmicRay> microbursts in the steady periods too.
12:17:15 <CosmicRay> always 3 of them.
12:17:17 <df_> its an attempt at an MPEG decoder / encoder in haskell.  It is only concerned with marshalling / unmarshalling
12:17:23 <shapr> neat!
12:17:30 <CosmicRay> sweet!
12:17:43 <df_> those would be the different frame types i think
12:17:53 <CosmicRay> when this gets fast enough to play back a HDTV stream from MythTV, I will be incredibly impressed :-)
12:18:19 <df_> hah, its increadibly non real time.  Its a software simulation of the hardware implementation
12:18:20 <CosmicRay> are you processing the file with the binary (block) I/O features?
12:18:24 <df_> no
12:18:26 <df_> its streamed
12:18:30 <CosmicRay> using hGetContents then?
12:18:33 <df_> yes
12:18:46 <df_> that way it behaves like the fpga
12:19:23 <CosmicRay> it would be interesting to see this memory usage graphed against cpu time.
12:19:34 <df_> i am certain there are far better ways to do this
12:19:42 <CosmicRay> and against I/O.
12:19:47 <shapr> It's hard to say what's being lazy without seeing the code.
12:19:58 <CosmicRay> does this graph cover the entire lifespan of the program in question?
12:20:18 <shapr> hiya jeff
12:20:33 <df_> no, its terminated during the processing
12:20:59 <CosmicRay> df_: in situations like this, it is easy to force "read-ahead" into the stream, or not let old elements be deallocated.
12:21:14 <CosmicRay> df_: was there output generated at the time you terminated it?
12:21:26 <df_> yes
12:21:37 <CosmicRay> hmm.
12:21:51 <df_> it was working fine a while ago, however i refactored the stream code, and that has broken it
12:21:55 <CosmicRay> then you're probably not forcing the entire input to be evaluated...
12:22:09 <shapr> Can you rollback your refactoring one step at a time to see what's changed?
12:22:23 <CosmicRay> shapr's probably right, without seeing the code it's going to be hard to suggest much
12:22:28 <df_> shapr :: its too big a change unfortunately
12:22:40 * CosmicRay smells the lack of a good version control system :-)
12:22:40 <shapr> sucks
12:22:42 <df_> cosmicray :: i'll try and get the code out tomorrow
12:22:53 <df_> cvs at the moment
12:22:57 <CosmicRay> df_: this discussion may possibly be of some use: http://sequence.complete.org/node/50
12:23:00 * CosmicRay was correct :-)
12:23:13 * CosmicRay notes: better than nothing, though
12:23:13 <shapr> df_: are you using pure Haskell? or FFI? or what?
12:23:21 <df_> pure haskell
12:23:24 <shapr> nifty
12:23:41 <df_> cosmicray :: ta for the url
12:23:52 <CosmicRay> df_: fwiw, JaffaCake in that discussion is Simon Marlow
12:24:02 <df_> ah, ta
12:24:31 <shapr> hey stepcut!
12:24:37 <CosmicRay> df_: if you are using recursion or fold* to process your input stream, that discussion could well be quite relevant
12:24:58 <shapr> stepcut: Arrows without arr / pure --> darcs get http://www.cs.chalmers.se/~josefs/category
12:25:09 <stepcut> oh nice!
12:25:26 <CosmicRay> shapr: do you know who Gour is?
12:25:31 <shapr> Yes
12:25:33 <CosmicRay> the name rings a bell, can't quite place it
12:25:35 <stepcut> darcs get http://www.cs.chalmers.se/~josefs/category/
12:25:35 <stepcut> darcs: command not found
12:25:36 <stepcut> :(
12:25:48 <shapr> :-(
12:25:51 * stepcut apt-get's darcs
12:26:02 <CosmicRay> ahh, relief
12:27:01 <shapr> I've seen Gour on the Haskell mailing lists and in the darcs community.
12:27:13 <CosmicRay> shapr: he's also here http://sequence.complete.org/node/50
12:27:18 <shapr> I think he's from Croatia, but I'm not sure.
12:27:23 <shapr> Yeah, I saw his comments on sequence.
12:27:28 <CosmicRay> I must have seen him on the ml
12:27:30 <shapr> Did you see that Fritz joined sequence as well?
12:27:37 <df_> what timezones are people in here?
12:27:42 <shapr> I'm CET.
12:27:46 <CosmicRay> df_: GMT-5
12:27:49 <CosmicRay> (US-CDT)
12:27:54 <shapr> GMT+1 I think
12:28:01 <stepcut> shapr: have I missed the deadline for TMR v.2 ?
12:28:06 <CosmicRay> shapr: do you switch for summer?
12:28:09 <shapr> stepcut: no! tell me?
12:28:12 <shapr> CosmicRay: yeah we do
12:28:19 <ibid> GMT+3
12:28:30 <CosmicRay> shapr: I suspsect you are GMT+2 now then
12:28:34 <shapr> oh
12:28:35 <shapr> ok then
12:28:35 <ibid> shapr: sweden should be GMT+2 now?
12:28:38 <CosmicRay> date -u and compare
12:28:45 <df_> summer time switched 2weeks ago
12:28:51 <df_> (easter weekend)
12:28:52 <shapr> if you say so. I have trouble remembering what month it is, much less what time it is.
12:28:54 <CosmicRay> yup, you are GMT+2
12:29:06 <shapr> ibid: hey, wanna write about Z & QC?
12:29:13 <ibid> not now :)
12:29:15 <CosmicRay> shapr: May. :-)
12:29:20 <shapr> ibid: awww
12:29:30 <ibid> i'm letting my subconscious work on it
12:29:35 <shapr> sounds good
12:29:37 <Igloo> Time is just a crutch people like to believe in. Much like state, really.
12:29:49 <ibid> i'm not a very fast writer for anything that's supposed to be good :)
12:29:56 <df_> CET is actually GMT+1, CEST is GMT+2
12:30:02 <df_> (always)
12:30:17 <CosmicRay> CEST?  What's the S stand for?
12:30:21 <df_> Summer
12:30:22 <shapr> I'm in Sweden. Whatever that means.
12:30:22 * ibid is in EEST
12:30:29 <CosmicRay> df_: damn, confusing.
12:30:32 <stepcut> shapr: is there a paper for this category thing ?
12:30:36 <CosmicRay> here in the USA, S is Standard (winter) time
12:30:42 <CosmicRay> D is Daylight (summer) time
12:30:47 <CosmicRay> so I'm in CDT now, CST in winter
12:30:48 <shapr> stepcut: not that I know of, I just heard about it a few hours back.
12:31:01 <shapr> stepcut: Josef Sveningsson wrote it, his name's probably in there.
12:31:11 <CosmicRay> Indiana is in EST year-round, most of eastern usa is in EDT now
12:31:12 <df_> cosmicray :: not as bad as (i can't remember, but they use the same TLA for both)
12:31:17 <shapr> I was asking about CGI Arrow, as usual, and he said that arr / pure is the real problem.
12:31:19 <CosmicRay> df_: heh
12:31:26 <ibid> shapr: what's the length requirement?
12:31:37 <shapr> stepcut: since that's also what you said, and what other people said (musasabi I think)
12:31:47 <shapr> I figured it's likely he's right.
12:31:57 <stepcut> heh
12:32:02 <shapr> Oh Philippa mentioned that arr / pure are a problem also, and esap I think.
12:32:37 <shapr> In any case, bringert wants to do a student project with team the same size as the HaskellDB team
12:32:48 <shapr> and I suggesed continuation based webapp, of course :-)
12:32:57 <stepcut> heh
12:33:19 * esap gets very strange double-panic message from GHC ! It panics while trying to output information about another panic :-)
12:33:21 <shapr> ibid: Start at the beginning, go to the end, then stop. Whatever you think covers the subject.
12:33:43 <ibid> shapr: even if it's 200 pages? :)
12:33:49 <shapr> ibid: works for me.
12:33:52 <ibid> wow
12:33:53 <shapr> I'm not paying for bandwidth on haskell.org.
12:33:57 <CosmicRay> heh
12:34:11 <ibid> how's the issn thing?
12:34:19 <shapr> I got distracted, but I sure like the idea.
12:34:20 <stepcut> shapr: cool
12:34:30 <CosmicRay> shapr: if you publish it in a wiki, how will we be able to know, when reading it, that we are reading the same content that was originally published?
12:34:39 <shapr> stepcut: anyway, Josef said it's possible a CGI arrow can built with Category. What do you think?
12:34:40 <stepcut> bbiab
12:34:52 <shapr> CosmicRay: it'll be read-only once it's published
12:34:56 <stepcut> i gotta phone call, bbiab
12:35:00 <CosmicRay> ah ok
12:36:06 <shapr> Speaking of which, I gotta put the wiki up tomorrow.
12:36:46 <shapr> Then I can go be really rabid about recruiting.
12:37:48 <jlouis> Is there a (formal as well as informal) introduction to arrows
12:38:03 <shapr> I'd recommend Ross Paterson's FoP chapter.
12:38:17 <Heffalump> <aol>
12:38:17 <Itkovian> url?
12:38:20 <Itkovian> book?
12:38:33 <Heffalump> FoP is a book, but his chapter is online
12:38:34 <shapr> http://www.haskell.org/arrows/biblio.html
12:38:43 <Itkovian> got that
12:38:49 <Heffalump> http://www.soi.city.ac.uk/~ross/papers/fop.html
12:38:52 * Itkovian surfs
12:39:50 <shapr> I am hopeful that Josef's Category will allow a CGI Arrow.
12:40:28 <shapr> It makes a lot of sense to change the way functions are done in arrows. The 'black box' has been the problem.
12:40:33 <zamez> the Monad Reader article forgot to explain what Pugs actually is
12:40:38 <shapr> heh
12:40:40 <SamB> shapr: CGI arrow?
12:41:30 <shapr> SamB: An arrow is a first class transformation, it's one step above a monad. If there were some way to add Read/Show => Arrow  after the fact, then you could serialize continuations
12:41:48 <SamB> shapr: is that CGI as in cgi-bin?
12:41:51 <shapr> that's right.
12:42:08 <shapr> zamez: http://pugscode.org/
12:42:12 <SamB> Isn't CGI a near-complete mess?
12:42:21 <zamez> yep, found it shapr
12:42:42 <shapr> SamB: it's not so much about CGI itself as it is that HTTP is stateless.
12:42:59 <shapr> two different requests have nothing to do with each other.
12:43:12 <Heffalump> shapr: huh?
12:43:26 <TheHunter> shapr, will TMR2 be wiki-only or wiki and latex?
12:43:32 <Heffalump> (re Read/Show => Arrow allowing you to serialise continuations)
12:43:48 <shapr> Heffalump: it's in Hughes' paper.
12:44:14 <shapr> TheHunter: it'll be wiki with LaTeX as far as I know.
12:44:20 <Heffalump> I doubt it was expressed like that.
12:44:27 <shapr> Heffalump: read it
12:45:20 <musasabi> Heffalump: the paper speaks about why classic Arrows don't work for CGI (because of the typeclass dependency)
12:45:28 <musasabi> and it is quite easy to read.
12:46:01 <SamB> shapr: doesn't CGI refer to a specific way of communicating an HTTP request through command-line arguments, environment variables, and/or stdin?
12:46:07 <shapr> SamB: yes it does.
12:46:41 <SamB> is not that way messy? why are we naming something that is supposed to be relatively clean after it?
12:46:53 <shapr> You know how cookies, url rewriting, and ?JSPSESSION=LOTSOFCRAP are used to connect separate requests together?
12:47:01 <Heffalump> musasabi: So how does an appropriately declared typeclass help with serialising continuations?
12:47:19 <SamB> shapr: basicly, yes
12:47:27 <shapr> Do you know how continuations work?
12:47:31 <Heffalump> presumably the idea is to have a CGI arrow and to have Read/Show a,b and somehow that lets you serialise CGI a b
12:48:17 <musasabi> Heffalump: yes, it helps, and the paper describes how.
12:48:22 <Heffalump> fairy nuff.
12:48:35 <SamB> shapr: mostly. isn't that sort of what the right argument to (>>=) is?
12:48:42 * musasabi could try to explain it but would most likely make tons of mistakes and not be very clear.
12:49:08 <shapr> SamB: yeah, sort of
12:49:51 <shapr> A continuation represents the future of execution from a certain point.
12:50:07 <shapr> Sort of like hitting the sleep button on a laptop, but only for a thread, a piece of a program, or whatnot.
12:50:30 <SamB> I get all confused when I try to think about Scheme's continuations, but I suspect that that is normal.
12:51:21 <shapr> So the idea with using continuations for web design is that each request makes a continuation, allowing you to hit back as many times as you want, with the next click still reacting as if you never did that other stuff.
12:52:55 <shapr> I'm not really sure if John Hughes was the first to suggest that, but he sure got a lot of references in CiteSeer because of that suggestion.
12:52:59 <SamB> hmm... I'm not sure how much I would like that...
12:53:22 <musasabi> shapr: but if we start curing arrows then syntax could be one point.
12:53:35 <musasabi> the current arrow syntax is not very userfriendly.
12:53:35 <shapr> how so?
12:53:44 <shapr> what would be better?
12:53:55 * esap thinks the arrow syntax is exactly right.
12:54:01 <musasabi> shapr: well it just doesn't look very readable.
12:54:40 <shapr> I have no opinion one way or the other. If I had to choose between two or more, I'd have more opinion.
12:54:51 <Heffalump> I very much doubt John Hughes was the first to have that idea
12:55:02 <shapr> Heffalump: I don't know, you could ask citeseer.
12:56:01 <Heffalump> right, I get how this works.
12:56:07 <shapr> musasabi: If you have some improvements in mind, can you write up some simple examples that would demonstrate other syntax?
12:56:10 <Heffalump> It's not serialising continuations at all, it's serialising the state needed by them.
12:56:29 <Heffalump> and the structure of arrow code means that you have to make it explicit what values you'll want again, so it can do that
12:56:31 <musasabi> the whole "x <- y -< z" is not very pretty.
12:56:38 <Heffalump> (Ross Paterson's arrow notation hides that, conveniently)
12:56:46 <shapr> Have you seen the new ~> syntax for arrows?
12:57:07 <Heffalump> what John's paper doesn't make clear is how it ties specific 'ask's to specific CGI pages, but it's not out of the question for the library to take care of that.
12:57:15 <musasabi> shapr: no, what should I read?
12:57:41 <Heffalump> as the paper also points out, you could just as well play the game with monads, except that you'd have to save more state than was necessary
12:58:06 <shapr> I think it's only a few days old in ghc-cvs, TheHunter pointed it out. The ~> is an infix replacement for a in the a b c part of arrows.
12:58:13 <shapr> So it's "b ~> c"
12:58:31 <musasabi> so that is an infix type constructor?
12:58:40 <Heffalump> infix *type* constructors? Scary.
12:58:53 <SamB> is -> scary?
12:58:59 <musasabi> Well haskell has [] and ->.
12:59:10 <SamB> [] isn't infix, it is outfix
12:59:25 <Heffalump> oh, is ~> defined internally?
12:59:34 <TheHunter> it's an infix higher-kind type variable
12:59:39 <Heffalump> rather than being defined using a generally usable piece of syntax support
13:00:01 <TheHunter> Arrow (~>) => a ~> b is the same as Arrow ar => a `ar` b
13:00:42 <shapr> Heffalump: want to write for TMR2?
13:00:50 <TheHunter> isn't that in 6.4? it's perfectly documented: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
13:00:52 <Heffalump> when's the deadline?
13:01:00 <Heffalump> TheHunter: oh, ok.
13:01:11 <shapr> You need to have your article ready to go a week before the end of the month.
13:01:17 <SamB> what if you need two type vars?
13:01:37 <shapr> That may not be so important if everything is wiki published with inline latex.
13:01:37 <Heffalump> I think it's unlikely I could manage that. Can you suggest a topic?
13:01:43 <TheHunter> (Arrow (~>), Arrow (>->)) => .. will work fine...
13:01:59 <shapr> Heffalump: what do you know best?
13:02:30 <shapr> hei Squider
13:03:07 <Heffalump> right now? The scheduler and register allocator in armcc :-)
13:03:10 <shapr> heh
13:03:42 <shapr> Well, pick something you know and like.
13:03:58 <shapr> That's the best recipe for a 'zine article.
13:04:17 <shapr> I gotta go to sleep, I'll be back tomorra
13:07:10 <Igloo> Heff: That sounds good. We can get a bidding war for it going between Intel and Mips
13:07:11 <df_> night night, thanks for earlier
13:07:58 <Heffalump> :-p
13:23:43 <martin> can i ask questions about wxhaskell here?
13:25:12 <Lemmih> You can try.
13:26:05 <Huschi> how can i create a non-static label?
13:26:42 <basti_> a non-static label?
13:27:28 <basti_> I would think wx-widgets would be IORefs or something?
13:27:56 <Lemmih> Huschi: You know that you can change the text of a StaticText, right?
13:28:50 <TFK> But it's... static :o
13:29:02 <Huschi> well, i can change the the text of a static-text control? that will fix my problem.
13:29:10 <Lemmih> TFK: It's called static because the user can't edit it.
13:29:17 <Huschi> thx
13:29:26 <Lemmih> Unlike a TextEntry.
13:29:27 <TFK> (j/k...)
13:29:33 <TFK> TextCtrl, actually.
13:30:01 <Lemmih> Oh right.
13:42:24 * boegel boings
13:46:07 * esap just submitted a GHC bug report: http://sourceforge.net/tracker/index.php?func=detail&aid=1178851&group_id=8032&atid=108032
13:56:19 <TheHunter> esap, appears fixed.
13:57:24 <esap> fixed?
13:58:19 <TheHunter> ghci esap.hs <-- this should generate the error, right?
13:59:27 <esap> no, only plain ghc does that. ghci seems to work.
14:00:03 <esap> which is strange anyway
14:00:06 <TheHunter> oh, that's weird.
14:03:53 <esap> hmm.. maybe it's the code generator that crashes there.
14:04:19 <esap> which could explain that the error only occurs in ghc and not ghci.
14:04:30 <TheHunter> it's annoying that ghc doesn't compile core anymore.
14:21:55 <SamB> Wow. Apparantly if you put code into lambdabot and wait a day or so, it looks nicer. Neato.
14:24:25 <desrt> @pointless y (\f n -> if (n==0) then 1 else n * f (n-1))
14:24:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- y (s (flip if' 1 . (0 ==)) . s (*) . (. subtract 1))
14:24:30 <desrt> wow.
14:24:51 <desrt> uh.  what's if'?
14:25:10 <desrt> and surely 's' is cheating
14:25:34 <Igloo> s is just to stop the output being ridiculously large
14:25:41 <gzl> what is @pointless?
14:25:48 <TheHunter> s could be replaced with ap.
14:25:48 <gzl> something to do with fixed points?
14:25:50 <desrt> gzl; removes \s
14:26:09 <desrt> Igloo; so what is if'?
14:26:12 <gzl> sorry, what do you mean? there's no \s there.
14:26:18 <Igloo> No idea
14:26:19 <desrt> "\"s
14:26:24 <Igloo> @get-definition if'
14:26:25 <gzl> oh, oh
14:26:25 <TheHunter> if' b x y = if b then x else y
14:26:26 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- if' not defined
14:26:43 <gzl> ok, that makes sense
14:27:29 <desrt> @get-definition s
14:27:30 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- s not defined
14:27:33 <desrt> pfft
14:27:39 <TheHunter> @get-definition S
14:27:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- S = \f g x.f x (g x)
14:27:56 <jlouis> ah, yes, the S-combinator
14:28:03 <desrt> s f g x = f x ( g x )
14:28:09 <desrt> oh.  ya.  that too :)
14:28:09 <TheHunter> anyway, s = ap
14:29:06 <TheHunter> @pointless if'' b x y = [x,y] !! fromEnum b
14:29:07 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- if'' = flip (flip . ((!!) .) . (. (: [])) . (:)) . fromEnum
14:31:49 * boegel goes to bed, g'night everyone
14:32:00 <TheHunter> g'night, boegel
14:32:01 <SamB> dons: do you think it would make more sense to put {-# OPTIONS #-} pragmas in lambdabot source files, or use a .ghci file to make GHCi usage easier?
14:33:38 <desrt> combinators are neat
14:33:44 <xerox> desrt, they are!
14:33:52 <desrt> b = .
14:33:52 <xerox> @get-definition Y
14:33:53 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Y = \f.U(\g.f(U g))
14:33:54 <xerox> @get-definition I
14:33:54 <desrt> c = flip
14:33:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- I = \x.x
14:34:00 <desrt> w = something weird
14:34:03 <desrt> k = const
14:34:04 <desrt> i = id
14:34:35 <desrt> the w, s, y combinators should have names in haskell
14:34:40 <desrt> y should be called 'y'
14:35:34 * SamB wonders what time it is in .au
14:35:38 <TheHunter> if y were called 'y', there'd be a lot of confusing name-shadowing warnings
14:35:39 <SamB> which Y?
14:35:45 <TheHunter> @timein Syndney
14:35:48 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Sorry, don't know this city
14:35:55 <TheHunter> @timein Sydney
14:35:56 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-   Friday, April 8, 2005 at 7:36:56 AM EST
14:36:44 <SamB> what do you guys think? .ghci or {-# OPTIONS #-}?
14:37:13 * TheHunter uses alias ghci = ...
14:38:02 <desrt> the only t that matters.
14:38:05 <desrt> *y
14:38:43 <stepcut> running a process and processing the output lazily is weird -- because you can't check the return status until the process exits -- but the process often won't exit if you are not consuming the output -- so it is easy to deadlock
14:39:03 <stepcut> unless you force evaluation of the output before checking the status
14:39:13 <stepcut> but then you are getting lazy output
14:39:21 <SamB> TheHunter: I don't know how to record shell aliases in darcs ;-)
14:39:30 <stepcut> or I need to do something like check the status in a seperate thread
14:41:49 <stepcut> consuming all the output is not always possible.. so that is not a good solution...
14:49:45 <jlouis> grrr, Yet another futile attempt at attacking SeenModule.hs
14:50:01 <wagle> stepcut: you dont want to consume any output of an abnormally terminating process?
14:50:02 <jlouis> It is soaked into monads
14:50:57 <wagle> @seen lambdabot
14:51:00 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Yes, I'm here
14:52:05 <Heffalump> jlouis: what's the problem?
14:53:53 <jlouis> Heffalump: Well, I would love to have a more functional approach to the callbacks, but I am afraid that is not possible
14:54:20 <Heffalump> how much of the code actually uses the monad?
14:54:37 <jlouis> That is, I wanted a cleaner separation between the functional part and the Seen IRC monad
14:54:43 * TheHunter wonders how ghc transforms "proc x -> case x of MutableVar ref -> do deref -< ref"
14:55:12 <jlouis> Heffalump: Well, when one suddenly does do { ct <- time; ... } ...
14:55:39 <jlouis> ah, take that as a parameter then
14:56:18 <Heffalump> jlouis: right.
14:56:20 * basti_ added Ctrl-X support (with Emacs style visual feedback) to Yi.Emacs
14:58:08 <stepcut> wagle: I think I do want to consume output of an abnormally terminated process
14:58:36 <TheHunter> esap, the bug was already in 6.2
14:58:40 <stepcut> wagle: I just have not figured out what to do about detecting abnormal termination
14:59:34 <stepcut> I think I need to use forkOS
15:00:56 <wagle> i had a couple solutions years ago..  monads affect that thinking..
15:01:14 <wagle> but i gotta run now..  be back tomorrow or so
15:04:46 <wagle> one conclusion was to keep termination separate from the output
15:05:57 <stepcut> right
15:06:16 <stepcut> but if I check termination before enough output is consumed it will deadlock
15:06:39 <wagle> mdo
15:07:06 <wagle> how does it deadlock?  (going offline in less than 60 seconds)
15:07:24 <stepcut> I am checking the status of a program that has not finished running
15:07:31 <stepcut> the return code of the program
15:07:43 <stepcut> but the program does not finish running because I am not consuming its output
15:08:04 * wagle is offline
15:20:06 <Huschi> in wxhaskell, what's the difference betwee the strecth and the expand layout?
15:20:36 <jlouis> ``In the hall of the mountain king'
15:20:43 <jlouis> Edvard Grieg rules
15:23:11 <SyntaxNinja> word
15:24:55 <Lemmih> SyntaxNinja: Did you hack the Setup.lhs script for Hackage?
15:25:13 <SyntaxNinja> no. I"ve been at work.
15:25:23 <Lemmih> ah.
15:47:02 * Huschi thinks layout in wxHaskell sucks!
15:47:54 <yaarg> :(
15:48:08 <wxHaskell> you suck! :P
15:48:42 <Huschi> hey, im trying a very simple app and i cant get the right layout.
15:49:18 <Huschi> there a three buttons above each other and the are gluing in the top left corner.
15:49:27 <Cale> hmm... I don't recall having that much trouble with it, but I can see how for some things it could get complicated.
15:50:02 <Huschi> i'm finding no way to center and expand them
15:51:40 <Lemmih> How's your high level SDL interface going, btw?
15:51:46 <Cale> It looks like perhaps  stretch :: Layout -> Layout  is what you're looking for?
15:51:53 <Huschi> yeah, now it works. but where is the fucking difference between stretch and expand.
15:52:33 <Cale> sounds like stretch tries to maintain aspect ratio and expand doesn't
15:53:26 <Huschi> i think shape is for keeping the aspect ratio
15:56:34 <Lemmih> Isn't the documentation pretty clear about this?
15:57:24 <Huschi> my english is not good enough to understand it :(
15:58:11 <Cale> The documentation isn't all that clear. They do sound like they do the same thing.
15:58:40 <Cale> (maybe they do?)
15:59:59 <Lemmih> stretch: "[..] can be assigned a larger area [..]", expand: "[..] fill the assigned area entirely [..]".
16:00:30 <Huschi> ah, the difference is the "fill" and the "assign"?
16:05:27 * stepcut scratches his head
16:48:22 <mwc> Scale of one to ten, how hard is it to add a backend to ghc?
16:48:40 <mwc> one being an afternoon project, ten being as much work as writing a compiler from scratch
16:51:45 <jlouis> depends on the backend I guess
16:52:31 <jlouis> You have to translate Core into something that can be executed. Core is a lazy language where the 2 most prominent backends are C and C--
16:53:03 <jlouis> If you are willing to go with C-compilation, this is probably much easier, than to build an explicit native code generator
16:58:51 <mwc> jlouis, I was thinking of targeting the JVM
17:00:13 <Philippa> that could well be tricky
17:00:22 <Philippa> ISTR the JVM having a bunch of problems expressing the sorts of things Core does
17:02:25 <mwc> Philippa, ahhh, I was afraid of that
17:06:45 <Lemmih> shapr: Ping.
17:13:45 <Philippa> btw, if anybody wants me over the next few days I'll be at best intermittent - I'll be looking after a friend in london for a while
17:13:54 <jlouis> @seen lambdabot
17:13:55 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Yes, I'm here
17:18:03 <jlouis> mmmm, SeenModule looks better now
17:20:16 <SyntaxNinja> the european edition of cnn.com uses the word "row" here there, like "row over chelsea star with cell phone" or whatever
17:20:48 <SyntaxNinja> but I think it only uses that word when they talk about stuff like european sports or tabloid stuff, never when they talk about american stuff
17:20:54 <SyntaxNinja> it's the 'international' edition. kinda funny.
17:21:38 <mwc>  Heh, SyntaxNinja, we use the word in canada too
17:21:43 <mwc> but we don't pronounce it as row
17:21:46 <mwc> like as in a row of stones
17:22:03 <mwc> we say it to rhyme with cow
17:22:08 <SyntaxNinja> huh
17:22:18 <humasect> ~_?
17:28:46 <blackdog> good morning, haskell...
17:29:04 <beschmi> hi blackdog
17:39:09 <metaperl> is this how you would handle this?
17:39:10 <metaperl> concat [ [pixel,pixel ] | pixel <- "#.#" ]
17:39:26 <metaperl> two scale up a "picture"
17:39:33 <metaperl> to scale up a "picture"
17:41:53 * Pseudonym doesn't understand the question
17:43:23 <metaperl> just is that how you would take a string and blow up each element
17:43:34 <metaperl> the original string is "#.#"
17:43:48 <metaperl> the list comprehension creates ##..##
17:43:51 <metaperl> # -> ##
17:43:53 <metaperl> . -> ..
17:43:55 <metaperl> # -> ##
17:44:05 <metaperl> it scales it up by a factor of 2
17:44:22 <Pseudonym> OK...
17:44:25 <metaperl> I should've used replicate
17:45:17 <Pseudonym> foldr (\c -> (c:).(c:)) "#.#" ""
17:45:23 <Pseudonym> @plugs foldr (\c -> (c:).(c:)) "#.#" ""
17:45:29 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "#.#"
17:45:32 <Pseudonym> Hmmm.
17:45:59 <metaperl> concat [ replicate 2 pixel | pixel <- "#.#" ]
17:46:04 <beschmi> @plugs foldr (\c -> (c:).(c:)) "" "#.#"
17:46:04 <Pseudonym> Oh!
17:46:06 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "##..##"
17:46:06 <Pseudonym> Duh.
17:46:07 <Pseudonym> Yes.
17:46:08 <metaperl> no , I need to be able to scale up by any amount
17:46:31 <stepcut> if I use forkProcess, and then raise an exception in the parent process if the child dies... but I am not sure how to do this :-/
17:46:32 <metaperl> scaleup n = concat [replicate n pixel | pixel <- pic ]
17:46:35 <Pseudonym> @plugs foldr (\c -> iterate (c:) id !! 2) "#.#" ""
17:46:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Couldn't match `[a]' against `a1 -> a1'
17:46:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Expected type: [a]
17:46:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 	Inferred type: a1 -> a1
17:46:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the second argument of `iterate', namely `id'
17:46:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)-     In the first argument of `(!!)', namely `iterate ((c :)) id'
17:47:08 <Pseudonym> @plugs foldr (\c -> iterate ((c:).) id !! 2) "#.#" ""
17:47:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "#.#"
17:47:16 <Pseudonym> @plugs foldr (\c -> iterate ((c:).) id !! 2) "" "#.#"
17:47:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "##..##"
17:47:20 <Pseudonym> @plugs foldr (\c -> iterate ((c:).) id !! 3) "" "#.#"
17:47:22 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- "###...###"
17:47:36 <Pseudonym> Ugh.  Pointless style.
17:48:04 <beschmi> metaperl: scale n = concatMap (replicate n)
17:48:14 <Pseudonym> Oooh, that works.
17:48:19 <metaperl> that's nice beschmi
17:48:29 * metaperl goes to read about concatMap
17:49:16 <Heffalump> (>>=)
17:49:32 <Heffalump> (just to be obfuscated about it)
17:49:46 <Heffalump> scale n = (replicate n >>=)
17:52:01 <metaperl> ok, now for the complete problem... which I dont know how to solve. I am trying to scale up a picture (represented as a list of Strings) both horizontally and vertically... we have seen how to handle the horizontal scaling... but how about the vertical scaling?
17:52:33 <metaperl> *Main> exPic
17:52:34 <metaperl> ["#.#","..#"]
17:52:34 <metaperl> *Main> printPicture exPic
17:52:34 <metaperl> #.#
17:52:34 <metaperl> ..#
17:52:48 <metaperl> I want to scale up this picture by a factor of n
17:53:06 <metaperl> both horizontally and vertically but can't figure out how to handle the vertical part
17:53:49 <Pseudonym> @plugs let scale n = concatMap (replicate n) in scalen 3 . map (scalen 3) $ ["#.#","..#"]
17:53:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `scalen'
17:53:51 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Variable not in scope: `scalen'
17:53:57 <Pseudonym> @plugs let scale n = concatMap (replicate n) in scale 3 . map (scale 3) $ ["#.#","..#"]
17:53:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ["###...###","###...###","###...###","......###","......###","......###"
17:53:59 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- ]
17:54:04 <Pseudonym> Like that, you mean?
17:55:51 * metaperl tries it out
18:14:43 <Arafangion> In a nutshell, what's currying?
18:15:37 <neilc> a curried function is a function that takes "multiple parameters" and has a type of a -> b -> c -> d
18:15:47 <neilc> whereas the uncurried version would have a type of (a, b, c) -> d
18:16:25 <gzl> in other words, it's a way of writing a multi argument function as a single argument function that takes the first argument and produces a function taking the remaining arguments
18:16:26 <Arafangion> neilc, I'll understand that someday, I'm sure.
18:16:41 <Arafangion> gzl, Now I understand it :)
18:18:15 <gzl> good
18:19:05 <ozone> Arafangion: possibly the other answer you're looking for is that it allows you to not pass all the parameters to a function, so you can "fill them in" later
18:19:24 <Arafangion> ozone, That's wierd.
18:19:27 <ozone> Arafangion: e.g. the + function takes in two numbers, but you can give it only one number
18:19:46 <Arafangion> ozone, How would you 'fill them in _later_"?
18:19:50 <ozone> Arafangion: if you give it only one number, it returns you a new function that only expects one number
18:20:09 <ozone> are you familiar with haskell's type signatures?  e.g. Int -> Int -> Int
18:20:29 <Arafangion> ozone, I know of it, having read the various books on it, but no, I am not inherently familiar with it.
18:20:36 <Arafangion> ozone, I can read and understand them, though.
18:20:40 <ozone> right
18:20:50 <ozone> so, say (+) has a type signature of Int -> Int -> Int
18:21:00 <ozone> so it expects two ints and returns an int
18:21:02 <skew> Arafangion: currying will make sense if you use map a bit (or other higher order functions)
18:21:04 <ozone> if you give it only one int
18:21:14 <ozone> it will return you a new function, of type Int -> Int
18:21:32 <neilc> Arafangion: this is called "partial application"
18:21:34 <gzl> Arafangion: it's called partial application.
18:21:37 <ozone> so, if you define a new function called, say, incrementByFive = (+) 5
18:21:39 * gzl stares at neilc.
18:21:47 <Arafangion> I see.
18:21:52 <ozone> yeah, what they said
18:22:07 <Arafangion> So, this is essentially what's emulated when imperative languages pass a tuple to a function?
18:22:13 <ozone> formally known as partial application, but lots of people i know call it currying too
18:22:29 <gzl> Arafangion: currying is a way of emulating multi-argument functions when you only really have single argument ones
18:22:39 <skew> Arafangion: sort of, but the interesting thing here is that Haskell has first class function
18:22:46 <gzl> Arafangion: by taking advantage of higher order functions
18:23:27 <skew> Arafangion: consider some function like lookupFM :: FiniteMap a b -> a -> Maybe b
18:23:30 <Arafangion> skew, Your aware I'm attempting to make my own language?
18:24:06 <Arafangion> So far I am developing a prototype in Python.
18:24:30 <Arafangion> WOuld it suffice to emulate currying via the "pass all functions as a tuple"?
18:24:32 <skew> Arafangion: no, but currying is still mostly useful in a language with first class functions
18:24:41 <creichen> ozone: My understanding is that "currying" (or "Schnefinkeling") referst to the process of transforming a function of type "t_1 * ... * t_n -> t_k" to type "t_1 -> ... -> t_n -> t_k", whereas "partial application" is any function application whose type is a function type.
18:24:55 <ozone> creichen: yeah, sure
18:25:09 <gzl> Arafangion: say f = \x -> \y -> x + y. so f 1 2 = 1 + 2, but f 1 = \y -> 1 + y, i.e. a function that takes *one* argument and adds 1 to it (because by passing only a single argument, you've produced a new function that takes only one argument because the other one has been "filled in")
18:25:12 <ozone> though informally i tend to say currying instead of partial application
18:25:19 <Arafangion> creichen, Yes, thanks for the other guys for simplifying that ;)
18:25:23 <ozone> since it's shorter, and everyone knows what you mean
18:26:15 <Arafangion> I suppose for good currying, I should develop a good type system.
18:26:18 <Arafangion> First.
18:26:19 <skew> Arafangion: anywyas, suppose we have lookupFM. if you apply lookupFM to a lookup table you get a function of type a -> Maybe b. If you just immediately apply that to the value you want to look up it's not so interesting, as in (lookupFM employees) "bob"
18:27:01 <skew> Arafangion: but that intermediate function proves it's worth when you save it and e.g. map it over a list, like map (lookupFM empolyees) listOfEverybody
18:27:37 <skew> you can't do that if you pass all the arguments as a tuple (at least not without making a lambda)
18:29:01 <Arafangion> I may have been thinking of a lambda as well.
18:29:05 <Arafangion> Hmm.
18:29:38 <gzl> more interesting example than x + y :)
18:29:55 <skew> lambda is a good thing to put in a language
18:30:04 <skew> especially with a nice short name like \
18:30:40 <creichen> ozone: Ah, so it's like banter (As in "List of boxed primitives coming over the RPC! Grab your closures and let's get the catamorphism curried!")
18:31:39 <Pseudonym> Jolly pure of you, creichen.
18:31:41 <ozone> creichen: yeah, something like that :)
19:15:31 <dons> @dice 3d6+2
19:15:32 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3d6+2 => 13
19:15:36 <dons> @dice 3d6+2
19:15:37 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3d6+2 => 13
19:15:42 <dons> @dice 3d6+2
19:15:43 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- 3d6+2 => 14
19:17:03 <dons> @seen SamB
19:17:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- SamB is in #haskell. I don't know when SamB last spoke.
19:21:49 <dons> SamB, re lambdabot and ghci, I'm inclined not to use pragmas now, but to have a 'make ghci' target, that just runs "ghci $(HC_OPTS) $(PKG_OPTS) Main.hs"
19:22:10 <dons> it's just a matter of getting the proper flags from config.mk to the command line
19:23:51 <blackdog> morning don
19:25:21 <dons> heya blackdog
19:26:49 <dons> blackdog, feel like turning vixenlove into a lambdabot module?
20:00:03 <blackdog> dons: hell yeah.
20:00:42 <blackdog> i've been meaning to for ages... just never sure of the API, so it went into the "later,maybe" basket
20:01:49 <dons> free free to send me a patch. there's been a lot of cleaning, so it might be a bit easier now.
20:05:09 <Lemmih> vixenlove?
20:05:34 <blackdog> http://www.cse.unsw.edu.au/~mwotton/software.html
20:05:59 <blackdog> should it be ivorytowerlicious instead of ivorytowericious, do you think?
20:06:58 <blackdog> ar. bastards. they've taken the domain over...
20:29:52 <dons> SamB, did you see my response above regarding lambdabot/ghci ?
20:34:51 * dons keeps typing 'darcs' when he really means to type 'cvs'
20:39:31 <blackdog> the rest of the world keeps typing cvs when they should be typing darcs...
20:40:31 <blackdog> dons: bah, annoying. the nice simple mkRegex call i had turns out to be a wrapper over an IO function which likes nothing more than bombing out with an uninformative error on bad input...
20:41:22 <dons> is that Text.Regex you're talking about?
20:41:34 <blackdog> yeah
20:41:42 <blackdog> bombs in regcomp
20:41:47 <dons> yeah, at least if it doesn't compile to a valid regex, you get a sucky msg
20:42:08 <blackdog> and given that i read all my regexes from a file... :( i could call regcomp directly, i suppose.
20:42:35 <dons> can't you wrap it in a catch, and print your own message?
20:43:07 <blackdog> i think it just calls "error" - that's uncatchable, i think.
20:43:11 <dons> you could then print the problematic regex, and a line number even.
20:43:16 <dons> nah. you can catch error.
20:43:34 <blackdog> really? well, that changes everything...
20:43:42 <dons> might need GHC.Exception to match it exactly
20:44:57 <dons> error :: String -> a
20:44:58 <dons> error s = throw (ErrorCall s)
20:45:40 <dons>   | ErrorCall           String
20:45:40 <dons>         -- ^The 'ErrorCall' exception is thrown by 'error'.  The 'String'
20:45:40 <dons>         -- argument of 'ErrorCall' is the string passed to 'error' when it was
20:45:40 <dons>         -- called.
20:45:54 <dons> IOBase.lhs:data Exception
20:47:16 <blackdog> dons: where can i find info on using exceptions in haskell? </showing my ignorance>
20:48:15 <dons> the haddock docs are good, and the src, or maybe the Awkward Squad paper.
20:48:25 <dons> I'd go for the haddocks first
20:52:22 <dons> Control.Exception.catch (error "gawd damn") (\e -> print $ "got you: "++show e)
20:53:30 <dons> Control.Exception.catch (error "gawd damn") (\(ErrorCall s) -> print $ "got you: "++show s)
20:53:35 <dons> even better.
20:56:52 <blackdog> man, i'm confused. if error has type [Char] -> a, how come it fits into the first argument of catch?
20:57:20 <blackdog> ah. a is IO b. got it.
20:59:24 <blackdog> but if the error is buried inside the function, i can't catch it from several layers up. is that right?
20:59:50 <dons> it's propagated. you'll catch it in the innermost catch that doesn't throw it further.
21:00:20 <dons> catch (parse my file) (\(ErrorCall s) -> return msg)
21:00:55 <dons> handle (\e -> do something) $ do some big chunk of code
21:03:42 <blackdog> Prelude> let foo l = case l of {1 -> "ergh"; _ -> error "blah" }
21:03:54 <blackdog> Control.Exception.catch (foo 3) (\ e -> print $ "got you:")
21:03:59 <blackdog> won't compile, though...
21:04:35 <blackdog> do i just move everything into the IO monad?
21:06:02 <dons> liftM (foo 3) would do. does it do IO?
21:06:21 <dons> it's purely functional and you want to catch the error?
21:06:30 <blackdog> yeah, i think so - mkRegex hides a call to regcomp which is an IO function
21:06:49 <blackdog> eh, i'll just go straight to regcomp. naughty interface, though.
21:06:53 <dons> evaluate (foo 3) would be nice I think.
21:07:10 <dons> -- For catching exceptions in pure (non-'IO') expressions, see the
21:07:10 <dons> -- function 'evaluate'.
21:07:50 <blackdog> yeah, but i think it's a real one... i think there must be an unsafePerformIO buried somewhere in there.
21:08:12 <dons> try not to be too naughty. but why can't you use evaluate?
21:09:15 <dons> -- | Forces its argument to be evaluated, and returns the result in
21:09:15 <dons> -- the 'IO' monad.
21:09:44 <dons> mkRegex s = unsafePerformIO (RE.regcomp s RE.regExtended)
21:14:17 <blackdog> ok, that seems to work
21:39:00 <blackdog> dons: still not quite sure how you can always convince me to stop doing paying work and start writing haskell toys.
22:04:05 <blackdog> dons: are you around? I want to whinge about your typeOf function and it's non-handling-of-your-code. :)
22:32:43 <blackdog> does anyone know how to add modules to lambdabot? I've got one building, but I'm buggered if I know how to test it.
22:33:23 * blackdog watches tumbleweeds, listens to sighing breeze
22:43:16 <blackdog> @google
22:43:17 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No matching header
23:04:19 <wilx`> blackdog, isn't there enough examples in lambdabot's source?
23:08:14 <blackdog> well, as far as I can see, they're all statically included modules - I don't know how to tell the lambdabot on the channel "hey, load this module". actually, i probably shouldn't be allowed to anyway - there are some security issues there, i guess.
23:10:03 <vegai> http://news.com.com/Teachers+leave+grading+up+to+the+computer/2100-1032_3-5659366.html?part=rss&tag=5659366&subj=news
23:13:13 <blackdog> @vixen hello
23:13:14 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:13:15 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Sorry, I don't know the command "vixen", try "fake_lambdabot: @listcommands"
23:13:32 <blackdog> fake_lambdabot: @listcommands
23:13:33 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Commands: dynamic-load dynamic-reload dynamic-unload echo join leave listchans
23:13:33 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- listcommands listmodules more msg part quit reconnect state version
23:13:53 <blackdog> bah. lambdabot is broken on mac.
23:22:24 <dons> @google lambdabot
23:22:25 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- http://cvs.sf.net/viewcvs.py/haskell-libs/libs/lambdabot/
23:22:29 <dons> @google
23:22:31 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- No matching header
23:22:34 <dons> SamB ?
23:22:48 <dons> lambdabot is broken on the mac?
23:22:49 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:25:48 <blackdog> hey don. tried lambdabot on the mac, and get a whole lot of stg_init failures. i'm rebuilding hs-plugins in case that changed, but i had a pretty recent version.
23:26:01 <dons> lambdabot doesn't use hs-plugins??
23:26:01 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet, try "lambdabot: @listcommands"
23:26:16 <blackdog> ... doesn't it? okay, guess it's not that then.
23:26:36 <dons> i'm looking on ozone's box right now
23:35:55 <shapr> good morning #haskell!
23:36:08 <desrt> good morning(?)
23:36:13 <ozone> good moaning
23:36:16 <ibid> morning!
23:37:15 <desrt> it's very early AM in this part of the world and desrt can not sleep.
23:37:22 <desrt> it will be a bad morning.
23:37:35 <dons> blackdog: you need 6.2.2, or some ghc without magic linking
23:38:26 <dons> mac-a-bot :@version
23:38:27 -mac-a-bot(~mac-a-bot@stealth.CeNTIE.NET.au)- Sorry, I'm not a very smart bot yet, try "mac-a-bot: @listcommands"
23:38:32 <dons> mac-a-bot: @version
23:38:32 -mac-a-bot(~mac-a-bot@stealth.CeNTIE.NET.au)- lambdabot 2p0, GHC 6.2.2 (Darwin Power Macintosh)
23:38:32 -mac-a-bot(~mac-a-bot@stealth.CeNTIE.NET.au)- darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:38:54 <dons> blackdog: you looking? 6.2.2 is what you need for now, until I solve the magics
23:39:38 <dons> mac-a-bot: @quit terminate yourself
23:40:27 <shapr> bok gour
23:40:53 <shapr> gour: written any cool Haskell code lately?
23:42:04 <Lemmih> Hey shapr.
23:42:13 <shapr> good mornin Lemmih
23:42:31 <Lemmih> shapr: I'm having problems with Hackage and the DB.
23:42:50 <shapr> like what?
23:43:01 <Lemmih> It fails when I try to use 'lemmih' as username.
23:43:40 <shapr> did you run createdb to create a database you own?
23:44:12 <Lemmih> Yepper, and it worked great when I ran it myself.
23:44:33 <shapr> ohh
23:44:34 <Lemmih> But it fails when Apache runs the hackage binary.
23:45:04 <shapr> I had to 'grant all to public' to get www to talk to the database
23:45:17 <shapr> I'm sure there's some way to do it for just www instead, but I couldn't figure it out.
23:45:18 <gour> i'm still learning from 'craft' :-(
23:46:13 <shapr> I like learning.
23:46:30 <gour> 7th chapter :-(
23:46:39 * dons is tired. ./configure --with-ghc=/home/dons/code/lambdabot
23:46:49 <blackdog> yow
23:46:54 <gour> but  i like it
23:47:01 <dons> unless someone put a patch in that I didn't see ;)
23:47:23 <blackdog> there are two dons?
23:47:32 <dons> could be :}
23:47:44 <blackdog> it'd explain how you get so much done... :)
23:47:47 * shapr laughs
23:48:42 <blackdog> shapr: quick off-topic q: what are the best refs for zope and CMF? Got a long bus ride home, thought i might as well learn some background...
23:49:44 <shapr> read the zope-book, read the plone-book, then hit the documentation sections on zope.org and plone.org
23:49:58 <blackdog> ok, got plone-book. there's no special CMF stuff?
23:50:04 <blackdog> ooh goodie
23:50:09 <blackdog> @vixen hello
23:50:09 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:50:10 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Sorry, I don't know the command "vixen", try "fake_lambdabot: @listcommands"
23:50:12 <shapr> not that I can think of
23:50:17 <blackdog> damn.
23:50:51 <shapr> There may be CMF docs, I've never actually looked.
23:51:07 <blackdog> nah, i was just annoyed that vixenbot isn't recognised yet...
23:51:24 <Lemmih> shapr: Yay. Now it works.
23:55:26 <blackdog> @vixen A/S/L
23:55:27 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Yeah
23:55:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:55:37 <blackdog> @vixen a/s/l?
23:55:38 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:55:38 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- 19/f/California
23:56:07 <shapr> haha
23:56:18 <blackdog> @vixen Where do you live?
23:56:20 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- maybe. do you?
23:56:23 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:56:24 <blackdog> ...hm
23:57:03 <blackdog> @vixen where you live
23:57:04 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:57:04 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- Huntington Beach California
23:57:26 <blackdog> @vixen can i call you?
23:57:27 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I don't know the command "vixen", try "lambdabot: @listcommands"
23:57:28 -fake_lambdabot(~fake_lamb@astlan1.syd.ranzco.edu)- maybe i'll give you my number later
23:57:47 <blackdog> ok, i'm done. don's got the source, he can include it later...
