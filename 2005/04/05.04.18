00:07:01 <a5> does Yi have the best version of Curses.hsc now?
00:12:46 <dons> the best version of Curses.hsc?
00:14:50 <dons> what other versions where you thinking about?
00:17:28 <a5> well Yi's is based on Ginsu's curses so i thought something might be based on Yi's
00:37:03 <dons> I know that Stefan Heimann was working on a libcurses based on yi's.
00:37:18 <dons> here: http://www.stefanheimann.net/darcs/hscurses/
00:37:51 <dons> which might have a couple of extra patches. but Yi's is quite up to date, and contains new code that isn't in Ginsu's binding.
00:49:53 <dons> @yow
00:49:54 <lambdabot> Should I do my BOBBIE VINTON medley?
00:53:07 <shapr> @quote
00:53:08 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files
00:53:08 <lambdabot> in Different Directories!"
00:53:19 <shapr> @quote
00:53:20 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from england
00:53:20 <lambdabot> just to kill me if I did that
00:53:20 <kaol> @fortune
00:53:21 <lambdabot> Madness has no purpose.  Or reason.  But it may have a goal.
00:53:21 <lambdabot> 		-- Spock, "The Alternative Factor", stardate 3088.7
00:53:40 <shapr> @quote
00:53:41 <lambdabot> samc says: monads are hard, let's go shopping
00:54:07 <dons> morning shapr
00:54:12 <shapr> g'day dons
00:54:17 <dons> how's code? ;)
00:54:29 <dons> (i feel like a shapr when I say that)
00:55:06 <shapr> Today's code is Python.
00:55:19 <shapr> It's a monday, time to get off IRC and do some paying work.
00:55:46 <dons> :/ oh well. money is important, yes.
00:55:52 <shapr> Yeah, I like to eat.
00:55:57 <dons> food is good
00:56:11 <dons> almost as good as tasty code
00:56:39 * dons casts an eye over lambdabot's todo to see if we're ready to tag
00:56:48 <shapr> But code is always tasty. Food is only tasty when I'm hungry.
00:57:07 <dons> ah! shapr is wise.
00:57:15 <shapr> I added a preview image - http://www.haskell.org/hawiki/HaskellUserLocations
00:57:44 <Lemmih> shapr: The lighting kinda sucks (:
00:58:10 <shapr> That does happen at night.
00:58:27 <dons> nice.
00:59:40 <dons> maybe the names should be tagged to the dots?
00:59:44 <Gahhh> isnt Cale shown ?
01:00:09 <shapr> dons: Yeah, they should be, but I couldn't figure out how to do that.
01:00:34 <shapr> Gahhh: Cale added himself after I made the preview.
01:01:43 <shapr> Dang, I was going to ask Gahhh to add himself too :-)
01:01:58 * shapr updates the image
01:02:30 <Lemmih> I wonder when maps.google.com will get detailed images of northen Europe.
01:02:42 <shapr> Am I doing something clueless? Is there an obvious arg that makes the text labels show up?
01:03:59 <a5> why is all the Yi code under the Yi namespace? is this necessary?
01:05:01 <dons> I guess it's not neceessary, but I don't see any harm. helps us not clash with future plugins too.
01:05:54 <a5> oh are you the author?
01:05:59 <dons> yep ;)
01:06:07 <a5> fancy that.
01:06:07 <dons> @google yi text editor
01:06:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
01:06:42 <dons> feel free to continue your analysis :)
01:06:42 <a5> there's got to be a better way.
01:07:19 <a5> like modules should be able to have different views of the namespace. 'chrooted modules'
01:07:32 <shapr> ?
01:08:07 <a5> like the Yi plugins could be imported from Yi's perspective under "Plugins.". but they'd think that that was the root
01:08:21 <a5> and Plugins.Yi would be an alias for Yi
01:08:29 <shapr> What's the advantage?
01:09:04 <a5> well for one it makes it easier to share code. like i have to rename things to use the yi curses
01:09:12 <dons> ah!
01:09:17 <dons> that's what you're up to ;)
01:09:32 <dons> yeah, renaming is annoying
01:09:53 <dons> I share the same Map compat module between lambdabot, yi and hs-plugins, and they have to be renamed to slot under new namespaces
01:09:58 <dons> so a little annoying.
01:10:13 <a5> it might make it harder for people to follow the code but well frankly programming in haskell can do that too :)
01:10:39 <a5> and haskell is all about modularization and composability and whatnot
01:11:37 <shapr> g'day blackdog, ready for some Python code?
01:12:04 <a5> ... oh wait isn't it already possible to import something as something else...?
01:12:20 <shapr> import Foo.Bar.Baz.Quibble as Q
01:13:12 <dons> but if he takes Yi.Map over to Foo.Map, it has to be renamed if it lives under Foo/ dir, doesn't it?
01:13:27 <dons> just a tiny little change, though.
01:13:46 <shapr> I wish the Python-style directory as import had been picked up.
01:13:55 <a5> you could "import Curses as Yi.Curses"... or "import ThePlugin as Plugins.ThePlugin" right? although i think the second might not have the right semantics
01:13:59 <shapr> Then you could just have Map.hs under Foo and it would be Foo.Map
01:14:13 <hellish> @version
01:14:14 <lambdabot> lambdabot 2p349, GHC 6.4 (OpenBSD i386)
01:14:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:14:17 <shapr> @aversion
01:14:18 <lambdabot> lambdabot 2p349, GHC 6.4 (OpenBSD i386)
01:14:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:14:27 <shapr> @quote
01:14:28 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl
01:14:28 <lambdabot> didn't teach us in 3e03
01:14:35 <hellish> shammah: is there a difference?
01:14:42 <a5> shapr: ah that would be nice
01:14:44 <hellish> Gah! shapr
01:14:52 <shapr> Actually Gahhh, just left ;-)
01:15:04 <hellish> X-chat's autocomplete is evil
01:15:09 <shapr> @quote jjuggle
01:15:10 <lambdabot>   I was riding around town and this cop on patrol on a bike rode up next
01:15:10 <lambdabot> to me and said, "There's always a show off." I offered to teach him to ride
01:15:10 <lambdabot> and help set up a unicycle patrol squad, but he declined.
01:15:39 * shapr just got a unicycle tshirt, yay!
01:16:26 <shapr> hellish: dons put in autospellcorrect, so the real command is @version, but @aversion is a short distance away, so gets autocorrected.
01:17:00 <hellish> shapr: ah. Thanks.
01:18:14 * shapr jumps up and down on his xearth binary hoping to squish some sense into it.
01:19:17 <shapr> Any idea how to get text onto xearth?
01:21:02 <shapr> aha!
01:21:47 <vegai> btw, might xplanet give out nicer pictures?
01:21:59 * shapr dunno
01:22:12 <vegai> I don't know if it supports the longitude/latitude file format of xearth's
01:29:17 * shapr improves the picture
01:29:35 <shapr> You can tell I'm just dying to do paying Python work.
01:29:39 <shapr> hej nibro
01:30:50 <vegai> freeciv-2.0 stable!
01:31:29 <mflux> freeciv is great. haven't played it for months though..
01:32:25 <nibro> hey shapr
01:32:44 <shapr> How's HSP? Closer to a release?
01:32:51 <nibro> had any fun/non-fun with hsp?
01:33:22 <nibro> aye, much closer
01:34:52 <shapr> Nah, I've been doing other stuff. Mostly socializing or cogitating on how to do an whole-hog  Haskell webapp server.
01:35:14 <shapr> Did you get a chance to look at Halipeto?
01:36:53 <hellish> Halipeto would be nicer if it were more dynamic.
01:37:04 <Lemmih> Hurrah for Hemplate then.
01:37:06 <shapr> nibro's HSP is very dynamic.
01:37:22 <hellish> @google Hemplate
01:37:23 <shapr> I stil haven't tried Hemplate, I should do that next.
01:37:23 <lambdabot> http://www.scannedinavian.org/repos/hemplate/
01:37:42 <Lemmih> Eeek. That repo is dated.
01:37:47 <Lemmih> shapr: Can you remove it?
01:38:23 <Lemmih> hellish: http://www.scannedinavian.org/~lemmih/hemplate is up-to-date.
01:39:11 <shapr> I can redirect it.
01:39:18 <Lunar^> Lemmih: is this my FormData?
01:39:44 <Lemmih> Lunar^: That may well be.
01:40:00 <Lunar^> code spreads, it's fun :)
01:40:18 <shapr> Ok, now both urls work.
01:41:19 <shapr> Does Hemplate have any examples other than Hackage?
01:41:58 <Lemmih> Not yet.
01:42:53 * hellish meant more dynamic as in not having to write a new executable for every new template. Hs-plugins for new code and simple html templates.
01:44:07 <nibro> hellish: as shapr said... :)
01:44:15 <shapr> Right, that's what Haskell Server Pages does.
01:44:58 <hellish> Perhaps I have an english problem.
01:45:06 <hellish> I don't really need CGI. Just templating
01:45:18 <Lunar^> halipeto, then?
01:47:36 <hellish> Lunar^: Halipeto just seems overgrown. Having to write your own executable to build your pages seems too complicated for the task
01:50:41 * hellish is attempting to write yet another templating engine
01:50:52 <blackdog_> hellish: wow, me too. :)
01:51:10 <shapr> I would strongly suggest hacking Halipeto, just because the same ideas have been so successful in Zope Page Templates.
01:51:29 <blackdog_> well, not really. i'd rather see this stuff tied together a bit, that's all.
01:51:52 <shapr> Halipeto and Zope Page Templates both put all the codey bits inside tag attributes, meaning that any HTML aware editor can handle that flavor of scripting.
01:52:40 <shapr> I agree that it would be nice if it were more dynamic, more like hs-plugins loading of a scripting file, but I still think the in-tag-attribute code bit is really useful.
01:53:02 <shapr> Anyway, Andrew Cooke wrote Halipeto, and he said he'd like to make it dynamic at some point, but he got frustrated before it got that far.
01:53:04 <blackdog_> shapr: hell yeah. you'd be dumb to do it any other way.
01:53:54 <hellish> editors are generally changeable. Most of them allow <?php sections.
01:54:08 <hellish> s/editors/html editors/
01:54:32 <blackdog_> Sure, but if you use in-tag-attributes, you don't need to alter the editor.
01:54:35 <blackdog_> also, php sucks. :)
02:00:49 <nibro> how can I apply a darcs patch that will lead to conflicts?
02:03:30 <a5> dons: why did you change the key constructors into functions?
02:04:54 <shapr> nibro: you can set a conflict editor and use that to resolve the conflict
02:05:59 <nibro> shapr: what's the command?
02:07:50 * shapr is looking
02:12:58 <shapr> I can't remember where I found the information on resolving conflicts.
02:13:15 <dons> a5, line number?
02:13:53 <dons> are you referring to:
02:13:54 <dons> keyBreak :: Char
02:13:54 <dons> keyBreak        = chr (#const KEY_BREAK)
02:13:58 <dons> ?
02:14:04 <xerox> Is there anyone able to translate: ÊºèÊ¥ûÊèê‰æõËÄÖ ?
02:14:10 <xerox> (hello!)
02:14:33 <dons> what language?
02:14:39 <xerox> I think it's Chinese
02:15:01 <shapr> nibro: there's "darcs resolve" to resolve conflicts, but you should really experiment first with a copy of your repo.
02:15:16 <shapr> Happily, it's cheap to make a repo copy.
02:15:24 <dons> @babel zh en ÊºOÊ¥^ÊOP‰æ[Ë@E
02:15:25 <lambdabot>   can't parse this language
02:15:29 <dons> oh well.
02:15:42 <xerox> @babel zh en ÊºèÊ¥ûÊèê‰æõËÄÖ
02:15:44 <lambdabot>   can't parse this language
02:16:07 <dons> thanks for the patch hellish.
02:16:42 <xerox> Babelfish says: Loophole tenderer
02:16:44 <xerox> O_o
02:17:05 * shapr doesn't know what that means.
02:17:18 <xerox> Thanks :)
02:18:03 <shapr> nibro: http://www.darcs.net/manual/node7.html#SECTION00710030000000000000
02:18:21 <a5> dons: yes
02:19:12 <a5> john has a data Key = ... so you can do matching on the keys
02:19:21 <dons> they're bound to variables so I can refer to them nicely in keymappings.
02:19:36 <dons> you can still do matching: | k == keyFoo
02:20:19 <a5> keymappings?
02:20:30 <dons> keybindings, sorry.
02:20:36 <a5> keybindings?
02:20:41 <dons> also, I needed Key=Char for some reason, can't remember.
02:20:45 <shapr> keybindings!
02:21:02 * shapr waves the Yi pom-poms and bangs the drums.
02:21:06 <dons> Yi/Keymap/*
02:21:09 <a5> why wouldn't the constructors work...?
02:21:09 <hellish> dons: it was just there, I was trying to add a listener for * is * to the factoid system, but it required more work than I thought.
02:22:47 <dons> a5, oh -- i was using alex to write key bindings, and it required [Char] input
02:22:49 <a5> (i've never actually used Yi, sorry! i probably should)
02:23:08 <dons> shouldn't be too hard to revert to the old behaviour if you want.
02:23:11 <dons> hack away!
02:23:18 <a5> yeah, i've already done so
02:23:33 <a5> so uh... why not parsec or? i've never heard of alex
02:24:20 <dons> @google alex haskell lexer
02:24:22 <lambdabot> http://www.haskell.org/libraries/
02:24:29 <dons> @google alex haskell lexer generator
02:24:30 <lambdabot> http://www.haskell.org/libraries/
02:24:35 <dons> http://www.haskell.org/ale
02:24:35 <shapr> Enter the mysteries of Haskell!
02:24:36 <dons> x
02:24:51 * shapr shoots an arrow combinator at lambdabot
02:25:32 <a5> was alex better than parsec?
02:25:53 <shapr> In some cases, yes.
02:26:13 <nibro> shapr: thanks, it worked :)
02:26:17 <shapr> yay!
02:26:39 <shapr> a5: Do you have a unicycle tshirt?
02:26:47 <Philippa_> shapr: I assume the main gain was speed? Though that makes sense enough for reading keyboard input
02:26:52 <a5> shapr: no
02:27:10 <a5> shapr: in which cases? i'm curious. i'm writing a parser
02:28:16 <dons> alex is a lexer generator. parsec is a parser combinator library. they're quite different
02:28:17 <shapr> I don't remember. I used know why/when to use one of Happy/Alex/Parsec.
02:28:40 * shapr sucks down some methylphenidate
02:29:17 <dons> also, alex generates fast lexers (that's why ghc uses it)
02:29:42 <a5> shapr: i ran out of adderall and started taking some concerta i found in my closet.
02:29:59 <shapr> What do you think? You like it better?
02:30:29 <a5> dons: but you're processing user input...
02:30:52 <dons> with a lexer. I don't understand what the problem is.
02:31:18 <dons> the key bindings aren't complicated enough to require a full parser.
02:31:48 <dons> they're [Char] -> [Action] functions, which is the type of a lexer
02:31:48 <shapr> ADDerall and Concerta both use similar tricks in their time-delay form. They both use methylphenidate salts that your body takes time to break down into methylphenidate directly. I think one of them uses a small dose of amphetamines to jump start the focus. I don't like the amphetamines side effects much though.
02:32:16 <dons> whereas a parser would be more like [Token] -> SynTree, which is quite different
02:32:24 <a5> shapr: i think my appetite is less now. i'm not sure what else to look for. ... oh, adderall has no methylphenidate! it's two amphetamine stereoisomers
02:32:28 <shapr> Pure Ritalin is nice, too bad it only lasts about three hours for me.
02:32:34 <shapr> !
02:32:46 <a5> shapr: i'm also on wormwood so it's harder to disambiguate effects
02:33:31 <a5> dons: hmm. you also seem to just give it an infinite list of input chars?
02:33:56 <a5> i wonder if that would be harder with a parser, or if extracting the output would be
02:34:23 <a5> well i think i can see why it'd be less natural
02:34:32 <shapr> Have you ever tried taking a small dose just before sleep? Oh probably not, you're on the minimum dose already, right?
02:34:55 <shapr> I have an easier time sleeping with a small dose of focus meds.
02:35:24 <a5> shapr: sorta. i've tried that. john agrees with you. maybe i should have tried a smaller dose but i wake up thirsty => hung over
02:35:33 <a5> and it gives me crazy dreams
02:35:48 <shapr> When I was in Seattle I used to take amphetamines just before bedtime to get better sleep. How whacked is that?
02:36:09 <dons> a5, yep, a map to actions over a lazy infinite list perfectly models the keystrokes entering an editor invoking editor ops
02:36:50 <a5> shapr: it's not whacked. amphetamines withdrawal causes mood swings. it's a mood stabilizer. mood stabilizers help you sleep.
02:37:07 <shapr> Hadn't thought of that. Does Concerta work the same way?
02:37:25 <shapr> I get more mood swings without meds than with.
02:37:29 <a5> dons: could it really be that hard to modify alex to accept other types? or i guess modifying curses was easier for you
02:37:48 <a5> yeah concerta is the same
02:39:00 <a5> shapr: it seems intuitive to me - you're just elevating dopamine levels by some constant. but that pushes you farther out on the finite response curve which is probably convex so the slope is smaller
02:39:51 <shapr> Yeah, I see what you mean.
02:40:00 <a5> whereas SDRIs like bupropion multiply by a factor. and they also elevate mood swings
02:40:23 <shapr> Sounds like a nightmare.
02:40:45 <a5> it's similar to cocaine i believe.
02:41:02 <a5> you get horny and confident
02:41:25 <dons> modifying alex wasn't really an option
02:41:40 <dons> this is all moot anyway
02:42:32 <a5> dons: oh i don't mean to be critical
02:42:40 <a5> i'm just trying to get a better understanding.
02:43:11 <dons> :)
02:49:04 <a5> so why should i use yi?
02:51:29 <shapr> Because you like parse tree macros.
02:52:23 <shapr> emacs is single-threaded, and has a bunch of deadlock problems when you fake it out by calling subprocesses.
02:53:56 <shapr> regex based modes are difficult to extend, and don't generalize nicely to working with the code for more intelligent purposes.
02:54:59 <shapr> emacs' real power is that it's just an elisp implementation that hooks down to the C level, and the editor is written on top of that.
02:55:29 <a5> can multiple people edit the same file at once and see their changes in realtime?
02:55:48 <a5> that's my feature request :)
02:55:54 <shapr> Yi takes that even further because Yi can edit its own implementation and :reboot will save the editor state, rebuild the editor, and reload both the editor and the state.
02:56:20 <shapr> and it takes about 0.2 seconds and looks like the same editor.
02:56:26 <a5> cool!
02:57:11 <shapr> Yi cannot yet do virtual pair programming, though I am in contact with the the SubEthaEmacs team. They're working on support for SEE, which I think I'll be able to steal.
02:57:37 <itior> hi all, could someone please explain the (^) function from Prelude (ie. I've looked at the definition of the function and some of the syntax i haven't seen before) where can i paste?
02:57:44 <shapr> @paste
02:57:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
02:57:52 <itior> cheers
02:58:22 <Lemmih> @plugs 2^8
02:58:27 <lambdabot> 256
02:58:31 <itior> lol
02:58:33 <shapr> a5: anyway, Yi isn't ready for general use yet, but it's getting closer.
02:58:36 <itior> i understand how to use it
02:59:18 <itior> ok, pasted, can someone please put a few comments on to explain
02:59:24 <nibro> shapr: added some new changes to the hsp repo, there's a cgi handler there now that you can use if you like
02:59:29 <shapr> ah, spiffy
02:59:48 <nibro> shapr: I can't get it to work with my apache installation, but I think that's more to do with apache than hsp
03:00:13 <nibro> shapr: if you could try it out I'd be most grateful =)
03:00:21 <shapr> After lunch :-)
03:00:28 * shapr runs off to lunch
03:00:34 <nibro> aye, sounds like a plan
03:00:41 * nibro runs off to lunch too
03:01:38 <a5> itior: what is the question?
03:01:51 <itior> a5: i dont really understand the syntax
03:02:12 <itior> x ^ n | n > 0 = f x (n-1) x
03:02:45 <a5> what part don't you understand?
03:03:01 <itior> | isn't or in this case is it?
03:03:19 <itior> or is that like a where clause
03:03:29 <itior> x ^ n when n > 0?
03:04:37 <a5> yeah
03:04:44 <a5> it's called a "guard" i think
03:05:14 <itior> and what does it mean by f x (n-1) x
03:05:20 <itior> like, what is f in this case?
03:05:29 <a5> or "guarded pattern" or something. you can put "| some_boolean_expression" in patterns
03:05:37 <itior> ah ok
03:06:01 <a5> f is defined in the first two lines of the first where clause
03:06:18 <itior> ohh i see
03:06:26 <a5> _ matches anything
03:06:37 <a5> without binding it to a variable
03:06:51 <itior> so it eliminates x^1 straight away
03:07:06 <a5> yeah
03:07:21 <itior> what does quot do?
03:07:46 <a5> quotient
03:08:01 <itior> as in / ?
03:08:14 <a5> yeah. "otherwise" is syntactic sugar for True
03:08:39 <Lemmih> 'otherwise' is not suntactic suger.
03:08:48 <itior> so g x n has a different definiton depending on whether or not n is even?
03:08:57 <hellish> :type RefChar
03:08:59 <a5> yes.
03:09:18 <itior> i see
03:09:21 <itior> crazy
03:09:25 <itior> ok, thanks for your help
03:09:27 <hellish> @type RefChar
03:09:32 <Lemmih> @plugs otherwise
03:09:34 <lambdabot> bzzt
03:09:34 <lambdabot> True
03:10:02 <a5> any day
03:10:23 <nlv11757_> anyone know ecos here?
03:11:11 <Lemmih> s/suntactic suger/syntactic sugar/
03:11:21 <a5> Lemmih: whatever. i'm using "syntax" loosely
03:11:42 <nlv11757_> what is it then Lemmih?
03:12:03 <Lemmih> nlv11757_: It' just a normal function.
03:12:06 <nlv11757_> an alias?
03:12:18 <nlv11757_> ow you just didnt agree with the term 'syntax'
03:12:39 <nlv11757_> because its not really part of the language
03:21:04 <a5> but very little is part of the language...
03:23:43 <TheHunter> shit!
03:31:34 <Philippa_> a5: this is exactly /why/ we maintain that distinction - so that that remains true :-)
03:32:06 <Philippa_> now, it might be fair to talk about sugaring an EDSL...
03:51:55 <nlv11757_> vi/vim or emacs?
03:52:19 <nlv11757_> i dont really know either, but before i put in time to get to know one of them, what are your advice
03:52:42 <dons> either is fine.
03:52:48 <Philippa_> do you want a text editor or an OS with a built-in editor? :-)
03:52:58 * Philippa_ really ought to learn one or both someday
03:53:07 <dons> Philippa_ makes a good point
03:53:30 <nlv11757_> cause i have these people telling me vim equals sh1te and emacs is the way to go etc etc.
03:53:32 <earthy> pick one, really
03:53:51 <earthy> they are both quite advanced, and learning them will improve your editing speed *lots*
03:53:59 <nlv11757_> good vim it is
03:54:03 <nlv11757_> or should i really do vi :P
03:54:14 <Philippa_> dons: you mean that I should actually learn one or both, or the OS bit?
03:54:26 <nlv11757_> im out for lunch
03:54:31 <earthy> well, matter of preference really, but vim really is a lot better than straight vi
03:54:32 <dons> that one is an OS with a built-in editor ;)
03:54:33 <hellish> nlv11757_: My choice is emacs, but that's really only because modes confuse me too much. Pick one.
03:55:01 <earthy> better, as in has a shitload more functionality
03:55:12 * Philippa_ is in two minds about modal stuff but has always ended up having to kill vim from another terminal when she's tried it without docs
03:55:23 <Philippa_> emacs you can at least find out how to kill it from the inside if you don't know anything
03:55:23 <dons> :q!
03:55:35 <dons> :help quit
03:55:52 <Philippa_> dons: it'd be nice if it raised some kind of newbie screen on first execution
03:55:53 <dons> ;)
03:56:29 <Philippa_> if you need a text editor that anybody can use, pass 'em pico or nano and explain the ^key convention to them quickly
03:56:32 <blackdog> that would taint its fearful purit
03:56:37 <blackdog> purity
03:56:43 <Philippa_> purity is no fun :-)
03:56:49 <dons> exactly right, blackdog
03:57:01 <dons> so yi has no help whatsoever.
03:57:06 <blackdog> philippa: are you sure you're in the right channel?
03:57:18 <Philippa_> blackdog: monads are great
03:57:20 <blackdog> "you have source code, don't you?"
03:57:21 <hellish> one plus for vi(m) is that typing ^X into the wrong terminal doesn't break it
03:57:25 <dons> who needs help when the src has type decls?
03:57:34 <hellish> err... typing colon.
03:57:47 <blackdog> Philippa_: it's still pure, of course. :)
03:58:07 <Philippa_> yeah, but the fun's in making it do things that sure as hell don't look that way
03:58:18 <blackdog> "
03:58:33 <blackdog> "I'm not as dirty as i look", perhaps?
04:00:37 <musasabi> vi has verbose errors as compared to ed ;)
04:01:01 <shapr> *beep* *beep*
04:01:20 <dons> who needs visual editors when you've got sed?
04:01:31 <dons> 2 dimenions are for wimps
04:01:35 <Philippa_> who needs sed when you can hardwire the code?
04:01:51 <shapr> lambda sed!
04:01:56 <dons> lambda sed!
04:02:13 * shapr waves the lambda and sed pom-poms
04:02:34 <blackdog> you make an extraordinarily unlikely cheerleader
04:02:43 <shapr> You should see me in fishnets.
04:02:58 <shapr> Seafood would love it.
04:03:02 <shapr> What's he doing these days anyway?
04:03:02 <Philippa_> don't forget the corsetry
04:03:06 <dons> heheha
04:03:17 <blackdog> ... and i push the image way down deep inside so that i never need think of it again
04:03:22 * shapr laughs
04:03:44 <shapr> blackdog: When you and I were running around at ICFP2003 I realized we looked sort of like a two person biker gang.
04:04:05 <dons> seafood's in conclave while he writes his thesis
04:04:26 <shapr> Ah, good idea
04:04:36 <hellish> bah, screw code reuse!
04:04:41 <blackdog> shapr: the least scary hell's angels in the world.
04:04:42 * hellish reinvents the wheel
04:04:55 <shapr> hellish: what are you trying to reuse?
04:05:54 <hellish> shapr: halipeto.
04:06:19 <shapr> oh
04:07:09 <shapr> What sort of difficulties are you having?
04:08:37 <glimming> Is someone familiar to HAL from Paulson's book on the working ML programmer?
04:08:56 <chr1s> morning everyone
04:09:06 <glimming> If so, an you estimate how much time you would need for porting the book example into Haskell while making use of some Haskell specific features such a type classes, and using state monad for the proof state,  and parser monads for parsing.
04:09:11 <blackdog> they're getting cranky with me in #plone for pining publicly for haskell. :)
04:09:12 <glimming> an/can
04:09:14 <chr1s> I'm making a logo interpreter in haskell
04:09:25 <chr1s> and I want to add support for variables
04:09:37 <chr1s> but I don't know how to store them
04:09:51 <dons> a Data.Map is a fairly easy way to do that
04:09:59 <chr1s> hm
04:09:59 <glimming> HAL = small theorem prover, here restricted to intuitionistic  prop. logic.
04:10:24 * Philippa_ seconds dons' suggestion
04:12:06 <hellish> shapr: Weird stuff. I think HaXml is CVS is a lot different from what he wrote it against, because once I deleted the code copied from HaXml and used the package, it broke.
04:12:18 <hellish> shapr: and I can't figure out what he was doing.
04:13:07 <shapr> You could ask him, Andrew is very helpful.
04:13:34 <shapr> I made http://www.ScannedInAvian.org/ with Halipeto, and I had to email him a few times. I think that's because I was the first person to use Halipeto other than Andrew.
04:15:18 <shapr> glimming: I don't know anything about HAL, but I think there are some logic/proof assistants written in Haskell. Could you adapt one of them to do HAL stuff?
04:15:41 <glimming> Interesting! I suppose i'll find em on www.haskell.org?
04:15:59 <shapr> Possibly, or ask google.
04:17:09 <dons> agda/alfa is written in haskell
04:19:11 <shapr> Oh, I was just reading about AGDA in the Epigram paper from .. yesterday?
04:25:06 <glimming> Yes, but I need a much simpler example, I found one for FOL.
04:34:04 <jlouis> Where the f... does glimming go when I am familiar with HAL from Paulsons book
04:34:15 * shapr grins
04:34:45 <jlouis> It is particulary easy to port it. Just forget about modules at the start and then see what you can put into type-classes. Monads will show themselves as the IO-monad
04:35:19 <jlouis> But if I remember correctly, it uses the REPL loop of ML for a lot of stuff. I do not think the REPL of eg Hugs can assign values, can it?
04:35:28 <jlouis> anyway, He is going to have fun ;)
04:37:36 <jlouis> There is NIH-syndrome in wanting to port that though. Isabelle (written in SML), HOL (written in SML), Twelf (Written in SML) and coq (Written in SML) serve a bit different purposes, but they are there and first-order intuitionistic first order logic is certainly their game
04:37:41 <jlouis> oh, well.
04:38:12 <jlouis> blackdog: about plone. I looked at it for 3 days last week. Conclusion: ARGH!
04:38:23 <shapr> jlouis: There's some neat stuff about those guys in the Epigram paper.
04:39:52 <jlouis> shapr: those guys?
04:44:44 <shapr> The paper talks about how to successfully mix dependent types and sanity.
04:45:02 <jlouis> oh
04:45:15 <shapr> It talks about limitations of Coq, and other theorem provers, why those limitations are there, and how Epigram does things slighly differently to good effect.
04:45:52 <itior> guys
04:46:02 <itior> i wrote my own exponent function called fastExp
04:46:08 <shapr> Is it faster?
04:46:13 <itior> a little
04:46:14 <itior> anyway
04:46:22 <itior> if i run fastExp 25000 25000
04:46:24 <itior> it takes about 17x
04:46:26 <itior> 17s*
04:46:27 <earthy> shapr: url?
04:46:39 <shapr> http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf "Why Dependent Types Matter" by Conor McBride, James McKinna and Thorsten Altenkirch
04:46:50 <itior> however, if i do (25000^25000) == (fastExp 25000 25000) it takes 0.05s to do the comparison
04:46:51 <earthy> tnx.
04:46:52 <itior> how can this be?
04:46:52 <jlouis> shapr: thanks
04:47:48 <vegai> itior: could some of the results be cached?
04:47:58 <dons> @plugs length $ show (25000^25000)
04:48:03 <vegai> perhaps that's too advanced for ghci
04:48:04 <lambdabot> Terminated
04:48:07 <itior> vegai: don't think so
04:48:29 <itior> even if i close/restart ghci
04:48:56 <jlouis> itior: what is the type of fastexp?
04:49:04 <vegai> hmh
04:49:06 <itior> Integer -> Integer -> Integer
04:49:08 <vegai> check this out
04:49:18 <vegai> @plugs (50000^50000) == (50000^50000)
04:49:21 <lambdabot> True
04:49:26 <vegai> haha
04:49:30 <TFK> heh, C stack overflow...
04:49:35 <vegai> @plugs (50000^50000) == (5000000000^50000000)
04:49:39 <lambdabot> Terminated
04:49:49 <itior> vegai: my function is different though
04:49:54 <itior> but it obviously isnt running it
04:49:57 <vegai> yeah
04:49:59 <dons> looks like.
04:50:00 <itior> so it's somehow working it out from the type sig?
04:50:18 <vegai> @plugs (2^100000000000000000000) == (2^100000000000000000000)
04:50:22 <lambdabot> Terminated
04:51:04 <shapr> Is -fcse-on the default for GHC?
04:51:28 <shapr> Ah, only with -O
04:52:03 <itior> anyone know why?
04:53:01 <shapr> itior: maybe common subexpression elimination?
04:53:03 <vegai> itior: perhaps it's the generating of the string for the output
04:53:08 <nibro> does anyone know why runghc gives me the following message when I try run a haskell cgi-script: HOME: getEnv: does not exist?
04:53:22 <TFK> Woo! Circular infinite patterns implemented!
04:53:34 <vegai> I mean... it doesn't have to show anything when doing a comparison
04:54:06 <vegai> @plugs (5000^5000) == (5000^5001)
04:54:08 <lambdabot> False
04:54:24 <vegai> could it really eliminate something from that
04:54:29 <vegai> @plugs (5000^5000) == (5001^5000)
04:54:32 <lambdabot> False
04:54:52 <itior> vegai: nah, but it still has to do the calculation?
04:54:55 <itior> or so you'd think
04:55:03 <shapr> Not necessarily.
04:55:12 <itior> shapr: how could it not?
04:55:19 <shapr> Common Subexpression Elimination
04:55:35 <vegai> damned clever
04:55:41 <vegai> perhaps..... too clever!
04:55:52 <Lemmih> Too clever?
04:56:05 <vegai> I kid.
04:56:15 <shapr> Sometimes CSE is too clever, and you have to turn it off.
04:56:24 <vegai> it would've sounded funnier irl.
04:56:29 <shapr> Look at the bottom of http://haskell.org/hawiki/EfficiencyHints
04:56:42 <itior> so if i turned it off it would take ages to exec?
04:56:55 <shapr> I don't know, try it.
04:57:12 <shapr> This is a fun experiment :-) I want to know too!
04:57:22 <Lemmih> itior: It's slower to print the result than calculating it.
04:57:37 <itior> how do i turn it off?
04:57:39 <vegai> yeah, that's what I figured too
04:57:52 <shapr> -fno-cse
04:58:34 <vegai> should ghci accept that?
04:59:22 <itior> shapr: i did
04:59:25 <itior> ghci -fno-cse
04:59:25 <shapr> I don't think ghci can do CSE, but I could be wrong.
04:59:28 <itior> and ran it, same result
04:59:29 <shapr> and?
04:59:31 <shapr> huh, wow.
04:59:36 <vegai> it's still pretty darned fast. I tried it too
04:59:39 <vegai> with 10000^10000
04:59:59 <vegai> now... 1000000^1000000 takes a while
05:00:00 <itior> C:\Documents and Settings\Evan>ghci -fno-cse <- is that correct?
05:00:00 <vegai> 5 seconds
05:00:10 <shapr> Yeah, that looks right to me.
05:00:15 <vegai> itior: yes, it would complain if the flag was wrong
05:00:30 <itior> so how else could it be doing it so fast?
05:00:31 <TFK> 4 lines. Woot!
05:00:59 <vegai> it's got some sort of super
05:01:12 <skew> doesn't that use GMP to do the math?
05:01:51 <shapr> TFK: Hey, what about that spiffy paste page? What happened with that?
05:01:53 <shapr> hiya skew
05:02:01 <skew> hi
05:02:25 <TFK> I have to make the form. I already got Nvu. I also must install Apache and get some kind of simpleton CGI thing going. So I'm on it :-)
05:02:34 <shapr> spiffy
05:02:37 <Lemmih> Perhaps: {-# RULES "==/==" forall x. (==) x x = True #-} ?
05:03:02 <itior> Lemmih: but the functions are completely different?
05:03:08 <itior> how can it evaluate it like that
05:03:31 <Lemmih> Because 'x == x' is always True.
05:03:57 <vegai> and the program still evaluates them -- when x=10000000, it takes a whole lot longer to finish
05:04:12 <itior> yeah, but how does it know (25000^25000) == (fastExp 25000 25000) without evaluating each?
05:04:14 <vegai> ok, when x is ten million, it segfaults in 27 seconds
05:04:28 <vegai> itior: it does evaluate each. It just isn't that expensive
05:04:49 <vegai> I mean come on
05:05:03 <vegai> even my python can do 25000**25000==25000**25000 in less than a second
05:05:22 <shapr> vegai: it segfaults?
05:05:22 <itior> vegai: but on my pc it takes about 17s to run 25000^25000
05:05:25 <vegai> shapr: no
05:05:30 <itior> so it doesnt make sense that it could do it that quickly
05:05:31 <vegai> it returns True
05:05:55 <vegai> shapr: oh, when x is ten million? Yes, then it does
05:06:00 <blackdog> jlouis: why so? Granted, it sucks, but it sucks less than any other cms i've seen...
05:06:10 <vegai> shapr: might be my faulty hardware causing it rather than ghc
05:06:17 <Lemmih> @plugs 25000^25000 `seq` True
05:06:19 <lambdabot> True
05:06:22 <blackdog> then again, i've seen way too many php scripts in cms's clothing. :)
05:06:26 <Lemmih> @plugs 250000^250000 `seq` True
05:06:28 <lambdabot> True
05:06:40 <vegai> otoh, it *does* segfault at 27 seconds every time :)
05:06:45 <Lemmih> @plugs 2500000^2500000 `seq` True
05:06:51 <lambdabot> Terminated
05:07:19 <Lemmih> So lambdabot can calcuate 250000^250000 in less than three secs.
05:07:23 <jlouis> blackdog: well, I have a problem with the ZODB of Zope behind it. I cannot get proper versioning into that database
05:07:40 <jlouis> blackdog: and I miss tools for manipulating the database directly
05:07:41 <blackdog> versioning of what?
05:07:45 <jlouis> blackdog: CVS, etc
05:08:20 <blackdog> oh, right. Yeah, i think if you're going to do plone seriously, you really have to do almost everything on the filesystem and use your revision control tools on that.
05:08:40 <blackdog> you should really only have configuration and user data in the ZODB if you can.
05:08:58 <jlouis> blackdog: That makes good sense
05:09:01 * boegel waves at everyone
05:09:09 <blackdog> It's still possible to manipulate the zodb with scripts. granted, they could make it easier.
05:09:38 <jlouis> I tried to play with some CVS<->ZODB gateways, but they suck.
05:09:59 <jlouis> Unfortunately, I do not have the time to think about and build a system in Haskell
05:10:33 <blackdog> i think it's a category error to do a whole plone system in CVS - it's more like a linux install: a whole bunch of loosely related packages.
05:11:34 <jlouis> blackdog: your idea of building most of the stuff in the backend and store it with CVS is appreciated. It is a good idea
05:12:00 <blackdog> cheers, but it's not my idea.\
05:12:07 <blackdog> @google best practices plone
05:12:09 <lambdabot> http://plone.org/documentation/tutorial/best-practices
05:12:12 <TFK> http://haskell.org/hawiki/HaskellIrcPastePage <--- what do you guys think?
05:12:20 <blackdog> check it out.
05:12:25 * blackdog strikes b-boy pose
05:14:49 <rtega> what can one do to fix the following?
05:14:49 <TFK> I wrote the same thing with a Python generator, 8 lines (vs. 5 in Haskell)
05:15:33 <skew> TFK: do you want me to squeeze that down a bit?
05:15:56 <rtega> ambiguous occurence to  'Maybe'
05:16:06 <rtega> It could refer to either etc.
05:16:09 <TFK> Not "squeeze", but perhaps comment about the (un)idiomatic nature of that code.
05:16:22 <TFK> I'm not a minimalist, personally...
05:16:58 <Philippa_> 'lo cm
05:17:20 <boegel> cm an in centimeter ? :)
05:17:57 <skew> I'm suspicious of defining recursion on (x:xs) and (x:[])
05:18:27 <jlouis> blackdog: thanks
05:18:56 <TFK> (x:[]) doesn't seem recursive.
05:19:06 <skew> yeah, makePattern pattern [] action = pattern should give the same results
05:19:07 <TFK> But yes, the idea is to use recursion.
05:19:21 <TFK> oh, you mean like that
05:19:22 <skew> TFK:(x:[]) is your base case
05:19:29 <skew> but it's almost always wrong
05:19:42 <TFK> Yup, you're right, [] should be my base case. :-)
05:19:44 * TFK fixes
05:20:37 <sqrt> sometimes you need to have the cases [], x:[] and x:y:xs .... (i mean in general, haven't seen the particular code)
05:20:40 * TFK edits the paste page
05:20:49 * TFK nods
05:20:51 <skew> foldr1 (++) is concat
05:21:01 <TFK> No, you're right. [] is the best base-case.
05:21:18 <TFK> Wow. Heh, wonder how I missed that, thanks #2 :-)
05:21:33 <skew> found it. concat . repeat is cycle
05:22:15 <TFK> Hmmm, it's not in the Prelude, right?
05:22:21 <skew> I think it is
05:22:22 <TFK> heh, it is...
05:22:23 * Muad_Dibber pokes kosmikus 
05:22:37 <TFK> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html <--- doesn't show up here :-(
05:23:29 * TFK fixes and edits
05:23:30 <skew> "... most of Bernie Pope's ..."
05:23:44 <skew> personally, I just read the report
05:23:47 <jlouis> dons: are you close to GHC6.4 on OpenBSD?
05:23:56 * boegel whistles
05:24:06 <TFK> Hmph.
05:24:18 <TFK> Guess I'll have to start reading it, then...
05:24:30 <TFK> It was the first thing that googled for "haskell prelude", though...
05:24:43 * TFK is a lazy bastard
05:24:56 <skew> you should read the report once or twice, so you actually know how Haskell workds
05:25:18 <TFK> Heh, the report's prelude defintion is second in google xD
05:25:25 <skew> I had to read the bit about layout three times or so before I got it, but it helped a lot
05:25:30 <TFK> Ah, but will I understand?
05:25:39 <TFK> heh
05:25:54 <skew> Before I was always surprised about when layout worked and when I got syntax errors
05:25:58 <TFK> I have to reread every chapter in Gentle a few times before I (partiall) get it, so...
05:26:09 <TFK> Well, I'm coming from Python. Whitespace is natural :-)
05:26:29 <skew> I did too
05:26:39 <TFK> Still got syntax errors? Hmmm.
05:26:46 <skew> but intuition doesn't tell you about the corner cases
05:26:54 <TFK> So far all indentation makes sense.
05:27:01 <TFK> Ah, yes, the dreaded corner cases...
05:27:08 <skew> The translation to { ; } is really enlightening
05:27:25 <skew> and the lack thereof a failing of Python
05:27:36 <TFK> Python has ;
05:27:53 <skew> I think it's easier reading the report along with the gentle introduction that either alone
05:28:19 <TFK> And how is a lack of explicit {;} a failing of Python?
05:29:11 <skew> IIRC, the gentle introduction was too fuzzy about things, while the report didn't really explain how to use any of the constructs it was describing
05:29:51 <skew> I like having symbols for grouping
05:29:52 <TFK> The Gentle isn't exactly that high on examples, for the practical programmer. I guess it makes sense since it's an introduction, after all.
05:30:10 <kosmikus> Muad_Dibber: yes?
05:30:15 <TFK> Heh, you write your own {;} in Haskell? :-P
05:30:34 <skew> no
05:31:08 <skew> but I think having symbols is much more helpful for talking about grammar, and for cases where you do have some kind of visible marker
05:31:27 <Muad_Dibber> kosmikus :  waiting for Haskell packages to get ported to ghc-6.4 <- any ETA? :)
05:31:32 <skew> Plus, you can write stuff like let {x = 1; y = 2} in x + y in IRC
05:31:38 <TFK> A whitespace is a graphic-enough symbol.
05:33:17 <TFK> Hmm, due to lazy evaluation, that code won't create more than an n-length list when I do take n on it, right?
05:33:34 <skew> it won't run forever, anyway
05:33:50 <skew> you will end up with an n-length list
05:33:52 <TFK> Well, I  already made sure of *that* ;-)
05:33:58 <TFK> Yes, but I mean behind the scenes.
05:34:12 <skew> makePattern builds some intermediate lists
05:34:30 <skew> in particular, using ++ like you do in makePattern does quadradic amounts of copying
05:35:14 <TFK> What should I do, then?
05:35:21 <kosmikus> Muad_Dibber: we're working on it; you can unmask ghc-6.4 (package.unmask) and use it, but I can't give you an ETA for it to get officially unmasked right now
05:35:27 <skew> I'm still looking over that definition
05:35:30 <skew> what is action used for?
05:35:35 <TFK> hehe
05:35:48 <TFK> Hmm, I should call 'action' a 'token', I think.
05:35:58 <skew> it looks like it should mostly just be one bit, except it can start as something else
05:36:02 <Muad_Dibber> kosmikus : going to do AFP course, so i will probably need a working version so was just looking into it ;)
05:36:13 <TFK> Yup, it is a single bit., 0 or 1
05:36:18 <kosmikus> Muad_Dibber: I have very little time currently, and this will remain so for the next couple of months; I have people helping me now, but I can't judge how much progress we'll make in which period of time
05:36:26 <TFK> I should call it a bit, then!
05:37:15 <skew> then how about makePattern rule action = concat (zipWith replicate rule (cycle [action `mod` 2, (action+1) `mod` 2]))
05:37:38 <Muad_Dibber> kosmikus : thats okay, was just curious :)
05:38:21 <kosmikus> Muad_Dibber: not sure if AFP actually requires ghc-6.4; I've discussed the schedule with Bastiaan a while ago, and from what I remember, GADTs are only a small part, and I wouldn't know about any other major ghc features that aren't in ghc-6.2.2 already
05:40:58 * TFK ponders about that line
05:41:26 <skew> I heard you say that something took 5 lines in Haskell and only 8 in Python with generators, and I knew something had to be wrong :)
05:42:11 <TFK> hehe :-P
05:42:18 <TFK> But it has to be readable. Lesse if I can figure it out.
05:42:35 <skew> I think it makes more sense this way than what you had
05:42:39 <skew> at least to me
05:42:51 <skew> rule is telling you how many times to repeat is one or zero
05:43:02 <TFK> Very possible, if you grok Haskell (I don't, yet)
05:43:07 <skew> which was buried in the recursion a bit before
05:43:45 <skew> and the numbers to be repeated that many times are coming from alternations of action and (action +1)`mod`
05:43:48 <skew> 2
05:44:09 <skew> zipWith replicate list1 list2 says "repeat the things in list2 as often as specified by the thing in list1"
05:44:47 <shapr> jlouis: I think the tools to do something like a Haskell version of Zope are reaching critical mass right now, so if you have any ideas or suggestions for such a thing, I'm very interested.
05:45:08 * TFK nods
05:45:11 <skew> iterate (\x -> mod (x+1) 2) first may be clearer than the thing with cycle, and corresponds exactly to your code
05:45:27 <TFK> Well, I understood your suggestion :-) awesome!
05:45:51 <skew> I think the style with list processing is generally to use the stuff from Data.List as much as possible
05:46:08 <skew> never write a recursive function if you could just call a higher order function
05:46:26 <machack666> what does an empty parens after a type signature indicate, ie:
05:46:35 <TFK> I've read that one before, on the HaWiki. That solution just occured to me!
05:46:39 <shapr> machack666: unit type, pretty much 'nothing'
05:46:44 <machack666> setVar :: String -> Val -> RuleParser ()
05:46:45 <TFK> Thanks again. Wow, such a one-liner :-)
05:46:53 <skew> so, I count 100 chars of code and a line of type
05:47:10 <machack666> why do you need the parens then?
05:47:45 <skew> Haskell has the best library of list functions of any language I've seen
05:47:54 <shapr> @type Just ()
05:48:05 <shapr> wha?
05:48:06 <TFK> skew, replace, join, strip are not in it! :O
05:48:07 <shapr> @type Just ()
05:48:09 <lambdabot> Just () :: Maybe ()
05:48:33 <skew> I didn't say string processing. That's a rather different issue
05:48:49 <shapr> Yeah, I'd like to see more string processing functions in the Prelude.
05:48:52 <machack666> so it's part of the Maybe Monad?
05:49:09 <shapr> No, Maybe is a parameterized type. data Maybe a = Nothing | Just a
05:49:18 <shapr> @type Nothing :: Maybe ()
05:49:19 <lambdabot> Nothing :: Maybe () :: Maybe ()
05:49:48 <shapr> @type Just 'a'
05:49:50 <lambdabot> Just 'a' :: Maybe Char
05:49:56 <machack666> so is saying Just () a way of saying we don't want to return anything special, but we don't want to return Nothing?
05:50:05 <shapr> Er, yeah, I guess so.
05:50:12 <TFK> Well, the signature of Lemmih's replace is replace :: Eq a => [a] -> [a] -> [a] -> [a]
05:50:37 <shapr> Top level main functions are almost always IO () because the valuable part of main is not its return value, but instead its side-effects.
05:50:40 <TFK> Strictly speaking, join could also be defined in terms of [a] only. How useful that would be, I don't know, but still :-)
05:50:47 <TFK> err, [[a]], that is.
05:51:15 <TFK> Well, joinList from LicensedPreludeExts, basically.
05:51:28 <shapr> But I think the type of main is usually "main :: IO a" so you could have a return value if you really wanted to.
05:52:01 <machack666> I see.  It's a way of us ignoring the return value of the function.
05:52:20 <machack666> kind of like ignoring the return value of printf
05:53:13 <TFK> Kinda like Python functions returning None by default.
05:53:46 <shapr> Sometimes m () is used as a base case for monad types also.
05:54:08 <shapr> Hm, I guess that's the same as what I just said.
05:54:41 <nlv11757_> why on earth do some people write "if ..... then true else false"
05:54:51 <TFK> hehe
05:55:16 <tromp> if ((a==5)==True)==True just to be sure...
05:55:21 <shapr> nlv11757_: for more information on that culture, see http://thedailywtf.com/
05:55:25 <TFK> http://rinkworks.com/stupid/cs_programming.shtml <--- :D
05:55:42 <nlv11757_> is there a reasonable use for that kind of things?
05:56:22 <shapr> Yes, it's a quick way to figure out who to fire.
05:56:33 <TFK> :D
05:57:08 <nlv11757_> haha indeed
05:57:18 <nlv11757_> but this code is from a very very smart person lol
05:57:27 <TheHunter> hmm, did I miss any common places where important files may be except /etc and /home ?
05:57:28 <TFK> "Difficult childhood, wooden toys, elevated balcony..." <--- loose translation from Russian
05:57:58 <TFK> I'm not sure about the "evelated balcony" bit, though. I don't quite remember the phrase :-(
05:58:32 <nlv11757_> :D
05:58:47 <shapr> nlv11757_: it's possible that the true and false cases are defined in a where clause like that for ease of reading the if/then/else.
06:03:22 <skew> some of these examples look like fun. I particularly like int i; memset(&i,0,sizeof(int));
06:03:53 <nlv11757_> my C knowledge is not sufficient to laugh about every piece of code there :D
06:04:06 <TFK> nlv11757_, consider yourself lucky :-P
06:04:12 <nlv11757_> i do
06:04:18 <TFK> ^_^
06:04:41 <nlv11757_> although my innocense will be lost a bit in my current project where i HAVE to deal with C
06:04:42 <shapr> Being a professional programmer with a bunch of other professional programmers motivated me to become self-employed.
06:05:13 <shapr> I will say that #perl6 has restored my faith in professional programmers though.
06:05:44 <nlv11757_> i dont want to program C for a living
06:06:12 <skew> What do they know? "your program can't print correct results before they're computed"
06:06:15 <skew> hah
06:06:15 <blackdog> shapr: i wouldn't mind working with some other programmers for a little while. i miss pair programming.
06:07:16 <shapr> blackdog: Depends on the person in the pair. I miss pairing with smart people.
06:07:36 <shapr> blackdog: obviously we should add SubEthaExxxtensions to Yi.
06:07:48 <ozone> blackdog: i'll work with you!
06:07:48 <Philippa_> I wouldn't miss dumb people were I forced to pair with them. Well, not before I'd emptied the magazine.
06:07:59 <scalopus> Hi
06:08:07 <shapr> hola scalopus
06:08:34 <blackdog> ozone: sure. What do you want to work on? I want a dynamic haskell zopealike.
06:08:36 <xerox> SubEthaYi! That would be good.
06:08:49 <blackdog> Phillipa_: that sounded rehearsed.
06:08:54 <blackdog> or at least practiced
06:09:05 <shapr> xerox: yeah, it would rock.
06:09:11 <skew> spoken from experience, I think
06:09:12 <Philippa_> blackdog: it's a variant on an old joke
06:09:24 <xerox> I _love_ online collaborative programming/editing.
06:09:47 <ozone> shapr: have you found any SubEthaEdit-like editors on linux?
06:10:02 <ozone> blackdog: how about my ph.d?  you can write that for me, i'll do your zopealike thing
06:10:03 <shapr> ozone: http://www.emacswiki.org/cgi-bin/wiki/SubEthaEmacs
06:10:06 <blackdog> shades of Olin Shiver's preface. :)
06:10:22 <xerox> shapr, is it the one using Twisted Matrix as backend?
06:10:32 <shapr> nah
06:10:36 <blackdog> ozone: with all due respect, you can get effed. :)
06:10:52 <ozone> shapr: neat.  not usable yet though, i imagine
06:11:19 <shapr> They've got enough to do test runs with the real thing.
06:11:50 <shapr> So many cool projects to work on...
06:12:05 <ozone> sheesh, no interest in supporting rendezvous?  oh well
06:12:30 <shapr> rendezvous is a special case of OpenSLP
06:12:36 <blackdog> do you use rendezvous much?
06:13:10 <ozone> blackdog: sure
06:13:32 <blackdog> I haven't found it terribly useful. it's possible that i just don't have any friends.
06:13:35 <ozone> using it right now to get to itunes on my other mac
06:13:54 <ozone> plus, it sure beats typing in IP addresses when you have a bunch of people trying to share files or something
06:14:29 <blackdog> it doesn't seem to have much takeup outside the mac world
06:14:59 <ozone> *shrug*
06:15:04 <ozone> certainly makes my life easier
06:15:11 <ozone> linux can go catch up when it feels like it :)
06:15:18 <shapr> It's already got one.
06:15:25 <blackdog> well, i'm in kind of a mac ghetto, y'know? I spend my life trying to fit into slightly alien environments.
06:15:44 <blackdog> wait, not in a mac ghetto. in an anti-ghetto. or a windows ghetto.
06:15:53 * blackdog is very confused, and has no-one to blame but himself.
06:15:54 <shapr> See RFC2614, Service Location Protocol.
06:16:16 <sqrt> blackdog: what are you trying to say?
06:16:20 <TFK> OK, and now for some Useful Code (TM).
06:16:31 <shapr> TFK: yeah, totally...
06:16:42 <blackdog> shapr: sure. it's there. the problem is that it's not pushed, so it's not part of the culture, and it's one of those techs which is most useful when it's ubiquitous
06:16:48 <TFK> :O
06:16:51 <ozone> shapr: so, i can ping foo.local.?
06:17:01 <TFK> shapre has left the building...
06:17:06 <TFK> *shapr
06:17:22 <blackdog> sqrt: i don't know. Also, the adult personals ads have just come on tv, which is my cue to go to bed. g'night, all.
06:17:30 <ozone> bye dawg
06:17:49 * sqrt waves
06:20:36 <TFK> POST is for large data, right?
06:21:21 <earthy> um
06:21:33 <earthy> POST is for data outside of the URL
06:22:59 <TheHunter> grrr, installing debian is a pita.
06:23:15 <ozone> TheHunter: try ubuntu
06:23:27 <ozone> (don't take that as ubuntu advocacy in any way, shape, or form :)
06:24:23 <TheHunter> hmm, is there an advantage in ubuntu if i don't care much about a recent kde?
06:24:44 <ozone> well, i found it a crapload easier to install
06:25:20 <ozone> and it comes with a decent desktop out-of-the-box, none of this apt-get yaddayadda crap just to get X running
06:25:25 <xerox> TheHunter, it works very well.
06:25:38 * earthy did the knoppix trick for ease-of-install
06:25:56 <earthy> ofcourse, it turned out to be not quite that easy
06:26:04 <xerox> TheHunter, it's nicely integrated with GNOME, and GNOME itself is doing very well so far.
06:26:07 <TheHunter> earthy, debian?
06:26:23 * earthy nods
06:26:31 <TheHunter> i'm currently trying to do it with knoppix and a chroot (i don't have a cd here)...
06:28:45 <TheHunter> ah, ubuntu doesn't have a sane way of installing it either.
06:29:08 <TheHunter> but I found this: http://www.burgettsys.com/stories/59455/
06:29:56 <ozone> TheHunter: ah, in that case, disregard my advice
06:30:14 <TheHunter> and configuration shouldn't be much of a problem, as i can just copy my old /etc/ files.
06:30:53 <TFK> Hmm, I have to install Apache, too.
06:31:02 <TheHunter> ozone, thanks anyway.
06:34:17 <nlv11757_> hmmm porting ocaml code to Haskell doesn't do the readability good
06:38:56 <earthy> and no wonde
06:38:58 <earthy> +r
06:39:40 <ozone> what's the definition of a combinator again?  a function with no free variables?
06:41:41 <tromp> yep
06:45:21 <earthy> nor mention of any constants, right?
06:46:08 <tromp> constants are fine too, i think
06:46:28 <tromp> after all, a function like id is a constant
06:46:52 <earthy> point.
06:47:26 <tromp> in untyped combinatory logic, anything you make from S and K is a combinator
06:48:02 <sqrt> what does S and K stand for?
06:48:18 <earthy> S == \x \y \z -> x z (y z)
06:48:26 <earthy> K == \x \y -> x
06:48:56 <earthy> (yup, those have been drilled into my brain quite well)
06:49:16 <ozone> earthy: what about I? ;)
06:49:19 * sqrt mmkays
06:49:22 <earthy> \x -> x
06:49:29 <xerox> @get-definition S
06:49:30 <lambdabot> S = \f g x.f x (g x)
06:49:58 <earthy> ozone: our \-calculus teacher would yell `name a lambda-term' to which the initial answer would be `I'
06:50:07 <ozone> earthy: hehe
06:50:10 <tromp> I = SKK=SKS
06:50:15 <earthy> `name another' `K'. `and....' `S'
06:50:39 <earthy> ofcourse, there's K* == \x y. y
06:51:36 <tromp> extensionally, also I=S(SK)
06:51:52 <ozone> what would i do without existentials
06:52:03 <nlv11757_> hey i had to read about S and K too in some course :D
06:52:15 <tromp> K stands for the german konstant
06:52:43 * earthy always memorized it as `K' for `Keuze' (which is dutch for choice)
06:54:07 <tromp> how does K give you choice?
06:54:35 <nlv11757_> maybe he rememberes it that way, because it doesnt :P
06:54:54 <TheHunter> earthy, did you use debbootstrap?
06:55:05 <tromp> KM is the constant function that on any argument gives the same: M
06:55:16 <earthy> thehunter: nope
06:56:52 <TheHunter> ok, so i'll install a base woody first...
06:57:05 <chaven> thehunter: http://cdimage.debian.org/pub/cdimage-testing/sarge_d-i/i386/rc3/sarge-i386-netinst.iso
06:57:56 <TheHunter> chaven, thanks, but i'm trying to install through a chroot.
06:59:03 <earthy> tromp: it's they way I managed to memorize it
06:59:07 <chaven> mea culpa
06:59:15 <earthy> K `chooses' between it's first and second arguments
06:59:48 <earthy> thus, to encode booleans, you can just take K and K*
07:00:08 <TheHunter> hmm, maybe if i can find a debian mirror that has _all_ packages.
07:00:10 * boegel keeps hearing his second nick K and wonders what the fuss is about
07:00:11 <tromp> K and SK
07:00:12 <earthy> and the encoding of if then else becomse simple application.
07:00:39 <tromp> K is like true and SK is like false
07:01:03 <tromp> and I is like if-then-else:)
07:01:03 * earthy nods
07:02:06 <boegel> combinators, right ?
07:02:10 <TheHunter> @pl s const
07:02:10 <lambdabot> const id
07:02:11 <earthy> combinators. ;)
07:02:26 <boegel> that's what I said ? :s
07:02:29 <tromp> and SSK(S(K(SS(S(SSK))))K) is like Y :)
07:02:35 <boegel> impressive )
07:02:50 <earthy> tromp: 'fess up, you're using a combinator-calculator. ;)
07:03:04 <tromp> no, i'm checking my source:)
07:04:17 * boegel _was_ impressed, but not anymore
07:05:12 <nlv11757_> didnt they do that in pierce's book also, built up everything from just very simple lambda calculus
07:05:19 <nlv11757_> encoding if then else, booleans, etc
07:05:46 <nlv11757_> that was cool to read
07:05:55 <nlv11757_> even a bit of OO
07:08:20 <earthy> um, possibly. never read TAPL myself
07:08:47 * earthy was taught typed lambda calculus from the chapter in the handbook of logic in computer science by barendregt
07:09:14 <earthy> `straight from the horses mouth' ... or the firehose, given the speed of introduction of the concepts presented
07:09:54 <earthy> but after that simple lambda calculus was truly... simple. :)
07:10:39 <nibro> @seen shapr
07:10:40 <lambdabot> I saw shapr leaving #haskell 54 minutes 3 seconds ago.
07:14:02 <TFK> He'll be back!
07:14:05 <TFK> Maybe...
07:14:32 <nlv11757_> in what course was that earthy?
07:14:41 <nlv11757_> or it wasnt on UU?
07:16:10 <TFK> Woo! Apache works!
07:17:15 <sqrt> TFK: did you find it difficult to use?
07:17:37 <TFK> Apache? Not at all. Works out of the box.
07:17:48 <sqrt> i thing so too.
07:17:51 <sqrt> think.
07:17:52 <TFK> Had to do some editing on my other (Gentoo) partition, though.
07:18:30 <sqrt> are you a gentoo user or a gentoo hacker?
07:18:55 <TFK> User.
07:19:09 <TFK> Doing OS-related work isn't for me...
07:19:17 <boegel> sqrt: I'm using you in my code :p
07:19:27 <boegel> hey Oejet
07:19:43 <Oejet> Hoi, boegel.
07:20:09 * sqrt bows proudly, "Just don't feed me negative numbers, it makes me so surreal."
07:20:24 <TFK> Now I have to configure Apache to work with Haskell in cgi-bin/ :D
07:20:45 <TFK> It makes you unworldly.
07:20:49 <sqrt> (somebody tell me if it's not ok to ask inhere, but) why do you use gentoo?
07:20:50 <boegel> sqrt: should I pay you now I'm using you ? or are you for free ?
07:21:10 <TFK> Correction: why did I use. I'm on win32 now. Going for Ubuntu next.
07:21:19 <TFK> Back in the day I figured it's the best thing since sliced bread.
07:21:47 <TheHunter> for one, gentoo is much much easier to install than debian...
07:21:50 <boegel> Ubuntu scares me
07:23:12 <sqrt> boegel: now would be a really bad time for the "hey, that was also what he said yesterday." remark.
07:23:21 <Oejet> Some people feels good when compiling from source.
07:24:53 <TFK> Lesse... Mandrake was annoying. Debian stable was ancient. So I was inspired with the *BSD way of package management.
07:25:13 <TFK> *inspired by
07:25:29 <smott> why not just use (free)bsd then?
07:25:40 <Oejet> Gentoo has updated Haskell ebuilds/packages?
07:26:57 <TFK> Does ATI supply Radeon 9200 drivers for any BSDs?
07:30:10 <TheHunter> finally, after more than an hour, a chrootable base installation!
07:30:26 <boegel> TFK: what about Fedora ?
07:30:50 <TFK> I heard horror stories about FC2. Dunno about FC3.
07:31:10 <Oejet> Oh, would it be cool to have profiling data, where the program text was rendered in a fontsize dependent on the times spend in that that block?
07:31:44 <TFK> Yup. You know you have a prolem if a single letter can fit barely on your screen.
07:31:49 <TFK> *barely fit
07:32:07 <TFK> So I hope Ubuntu will be good.
07:32:24 <nlv11757_> TFK, im wrestling with FC2 and ATI Radeon 9700 Pro
07:33:00 <nlv11757_> but there are quit new drivers out, which i will try this week. Hopefully i can get acceleration working
07:33:24 <TFK> Heh, that sounds peculiarly familiar... on Gentoo the ATI drives worked out-of-the-box (if you don't count the setup scripts).
07:33:31 <boegel> TFK: I have FC3 and am pretty pleased with it
07:33:44 <TFK> AFAIK, good hardware acceleration is provided only by ATI.
07:33:49 <nlv11757_> boegel: me too, but the ATI support is poor
07:33:54 <TFK> How pretty is "pretty"?
07:34:23 <nlv11757_> with new drivers, i meant the one by ATI TFK
07:34:27 <TFK> Does FC3 have a (big) central repository of up-to-date RPMs, a la apt or Portage?
07:34:34 <nlv11757_> yeah
07:34:36 <TFK> ah, ok ^_^;
07:34:38 <nlv11757_> lots of repositories
07:34:47 <TFK> Lots of repositories?... uh-oh...
07:34:57 <nlv11757_> even a haskell repository
07:35:46 <TFK> Well, I'll see how pleased will I be with Ubuntu.
07:35:55 <TFK> How much time did you spend in /etc ?
07:36:05 <boegel> TFK, it has yum
07:36:12 <nlv11757_> yeah, yum kicks behind
07:36:27 <nlv11757_> put the right repositories in yum.conf
07:36:30 <nlv11757_> voila
07:36:37 <nlv11757_> as the french say
07:37:10 <nlv11757_> im very satisfied about the user friendlyness of Fedora
07:37:29 <boegel> so am I
07:37:39 <boegel> but I should really resize my partitions and all that :(
07:37:45 <boegel> my hd is 82% full
07:37:49 <nlv11757_> hehe
07:38:09 <nibro> TFK: had any luck with Haskell cgi in apache?
07:38:17 <boegel> problem is I have a Windows installation too, and some NTFS partitions which I'd have to remove
07:38:25 <nlv11757_> i reserved too little space for my fedora as i discovered, shouldnt have been so conservative
07:38:28 <boegel> which are _in front_ of my Fedora partition
07:38:41 <TFK> nibro, nope, but I just started. Plus I spent more time here talking about various Linux distros :-/
07:38:43 <nlv11757_> ntfsresize doesnt help you out there i guess
07:38:59 <nlv11757_> and fiddling around with partition magic once cost me quite some stuff
07:39:22 <nlv11757_> of course you can always recover with data recovering software as in only messes up the fat tables, but still
07:39:26 <nlv11757_> its bloody anooying
07:39:27 <boegel> nlv11757_: suggestions what the best way is to solve this ?
07:39:29 <nlv11757_> -o+n
07:39:58 <TFK> nibro, why, is it hard?
07:40:07 <nibro> TFK: what interpreter will you use? I've been having some really tough problems with runghc
07:40:13 <xerox> Why ntfsresize doesn't help?
07:40:43 <TFK> nibro, interpreter? Hmmm. Can't I compile it once and be done with it?
07:40:47 <nlv11757_> im not sure if ntfsresize helps in resizing the linux as well xerox?
07:41:01 <nibro> TFK: ah, of course :)
07:41:19 <nibro> TFK: won't work for me unfortunately :-\
07:41:24 <xerox> nlv11757_, oh sure, but after resizing the NTFS partition you add a Linux one.
07:41:28 <nlv11757_> i used ntfsresize to shrink my ntfs partition so i could install fedora, im not sure how ntfsresize would fit in when you already have a linux partition
07:41:58 <nlv11757_> true, but ideally you would want the linux thing to stretch right
07:42:24 <TFK> nibro, how come?
07:42:29 <xerox> I think I made the same mistake, windows: 28G   24G  4.4G, Linux: 9.2G  8.1G  585M.
07:42:30 <nlv11757_> cfdisk doesnt do that while preserving data right?
07:42:45 <nlv11757_> :)
07:43:01 <nlv11757_> mistake in allocating to much for linux or too little?
07:43:03 <nibro> TFK: I'm doing a haskell server pages implementation, with compile-on-demand for pages
07:43:10 <xerox> nlv11757_, too little!
07:43:24 <nibro> TFK: which means I must let apache (or whatever server) call ghc, as nobody
07:43:27 <nlv11757_> nibro, isnt there already some apache mod like that?
07:43:35 <nlv11757_> mod_haskell, or is that different?
07:43:39 * boegel swears on this transparency stuff
07:43:50 <nibro> nlv11757_, mod_haskell is ages old, and never really worked
07:43:55 <nlv11757_> hehe
07:43:59 <nlv11757_> some student project right?
07:44:08 <nlv11757_> UU even I think
07:44:20 <nibro> nlv11757_: and its main purpose was to let you write *modules* in haskell, not pages
07:44:34 * earthy nods
07:44:44 <nibro> nlv11757_: think so yes
07:44:45 <nlv11757_> ah I see, I didn't quite know the exact goal of mod_haskell
07:44:49 <earthy> Eelco Dolstra && Armijn Hemel were the two perpetrators, IIRC
07:45:09 <nibro> earthy: sounds familiar
07:45:14 <nlv11757_> Wow armijn worked on that
07:45:18 <earthy> and it's bitrotted quite a lot, last time I checked
07:45:19 <nlv11757_> how old is that mod_haskell?
07:45:28 <earthy> 2001-ish?
07:45:32 <kolmodin> does anyone know if haskelldb works with sqlite and wxhaskell?
07:45:40 <kolmodin> or should I use hsql instead?
07:45:46 <nibro> kolmodin: wxhaskell yes, sqlite no
07:45:46 <nlv11757_> ow that's not *that* old
07:45:49 <CosmicRay> err
07:45:55 <CosmicRay> kolmodin: doesn't it work with anything hsql does?
07:46:03 <boegel> hey wilx
07:46:04 <CosmicRay> err s/kolmodin/nibro/
07:46:15 <CosmicRay> kolmodin: haskelldb is itneresting but I had some issues with it
07:46:22 <CosmicRay> you may prefer hsql as a more traditional approach
07:46:32 <kolmodin> ah, ok
07:46:33 <nlv11757_> i promote haskelldb :P
07:46:39 <nlv11757_> its the best
07:46:40 <nibro> CosmicRay, kolmodin: haskelldb works for everything that hsql does, plus wxhaskell
07:46:41 <nlv11757_> :P
07:46:56 <nibro> nlv11757_: I agree, but that has more to do with lack of competition...
07:46:57 <CosmicRay> nibro: it doesn't yet provide a way to do a SELECT without DISTINCT, for one :-)
07:47:06 <kolmodin> so... does wxhaskell work with sqlite? :)
07:47:19 <nibro> CosmicRay: aye, I have a bunch of issues with it as well
07:47:31 <CosmicRay> that one was ashowstopper
07:47:37 <nibro> kolmodin: don't think so, I think it's just an ODBC binding
07:47:39 <CosmicRay> kolmodin: wxhaskell has its own sql layer, right?
07:47:50 <wilx> Yo.
07:48:02 <boegel> no, Yi!
07:48:04 <nibro> yI
07:48:14 <nibro> gah, boegel beat me to it ;)
07:48:21 * boegel yaays
07:49:03 <TFK> A design question: I'm writing a pastebin. Is it OK to store all the posts as files, or should I start worrying about databases?
07:49:31 <nibro> TFK: you should *always* start worrying about databases :-P
07:49:55 <kolmodin> wxhaskell works with odbc
07:50:16 <nibro> TFK: but seriously, I suppose that has to do with the intended size of the bin
07:50:23 <smott> why is 1/0 Inf and 0/0 NaN? shouldn't both be NaN?
07:50:23 <kolmodin> I don't think sqlite support odbc, at least it isn't stable
07:50:30 <nibro> kolmodin: aye, that's what I figured
07:51:04 <kolmodin> so I should use haskelldb with hsql or just hsql... I have to look into that
07:51:14 <nibro> smott: 0/0 is NaN because you can't tell if it's Inf or -Inf
07:52:07 <kolmodin> i'm wondering since i want to make the autocompletion in haste a bit faster. thought it might be a good idea to put everything in a database and query it whenever needed
07:52:18 <smott> nibro: same with n/0 for any n
07:53:54 <nibro> smott: no, with only the denominator as 0, you know the direction the computation will diverge in
07:54:33 <nibro> for n>0 that's Inf, and n<0 -Inf
07:55:25 <nibro> kolmodin: do you want an external dbms to bind to, or should it be shipped with haste?
07:55:54 <smott> um no, as x->0 in C/x, it's Inf at x+ and -Int at x- (i.e. right and left limit aren't the same) hence division by zero is always undefined
07:56:29 <nibro> kolmodin: if the latter, perhaps the DBMS from HAppS would be nice? =)
07:56:40 <TFK> smott, shouldn't they be _|_?
07:56:59 <TFK> Ah, no...
07:57:00 <TFK> hmmm.
07:57:18 <nibro> smott: you're right of course, I guess I'm just used to the Inf definition of 1/0
07:57:22 <TFK> nibro, just a pastebin for code. Each file is a separate post, so I expect them to be small.
07:57:52 <nibro> TFK: the number of posts should have a larger effect than their individual size
07:58:13 <sqrt> a/0 =x <=> x*0 = a. So for a=0 it is anything in the world.... but for other a's it is nothing, doesn't exist ;)
07:58:21 <TFK> nibro, why? I'll just generate an .html file when a user posts.
07:58:56 <nibro> TFK: do you intend to show every file every time?
07:59:03 <kolmodin> nibro: it should be shipped with haste, that's why i want to use sqlite
07:59:09 <TFK> What do you mean?
07:59:19 <kolmodin> windows users won't ever know what happened
07:59:38 <nibro> kolmodin: ... HAppS? =)
07:59:48 <kolmodin> linux users will know better since they have to compile it :)
08:00:03 <kolmodin> nibro: don't know what that is... yet. give me a minute :)
08:00:09 <nlv11757_> hmmm, whats more correct esthetically; "case (a, b) of ...." or "case a of ...case b of ..."
08:00:22 <jlouis> nlv11757_: I prefer the former
08:00:26 <nlv11757_> me too
08:00:38 <nibro> TFK: will all the posts show up every time a user requests the pastebin page?
08:00:58 <TFK> No, of course not. But I may want to keep a static list to index all the posts made so far.
08:01:09 <jlouis> You will end up with |a| * |b| clauses anyway, but in the latter case you will have |a| ``case b of'' constructions
08:01:16 <TFK> It's basically a per-post basis; a user posts something, gets a URL, and posts it here.
08:01:23 <nlv11757_> i thought maybe there is some obscure efficiency drawback that outweighs the better look
08:01:46 <jlouis> nlv11757_: Match compilation will take care of that
08:01:57 <nibro> TFK: then the number of posts will matter, since when a user requests a particular post you will have to retrieve that post from the FS/DB
08:02:08 <jlouis> nlv11757_: more specifically: Pattern match compilation
08:02:08 <nibro> that's where the DB wins out
08:02:13 <TFK> What do you mean?
08:02:14 <nlv11757_> jlouis, in that case i will definitly go for the former, thnks
08:02:29 <TFK> Why will I have to retrieve it? Apache will do it for me :-)
08:02:40 <TFK> It's all pretty static after the user clicks "Submit"
08:02:41 <jlouis> nlv11757_: basicly, it transforms the former into something which somewhat looks like the latter
08:02:53 <skew> it's not so simple to use nested cases if you want some cases with _ on the left and some with _ on the right
08:03:07 <nibro> TFK: aha, so each post will be a static .html file?
08:03:26 * nibro wonders why he didn't see that sooner
08:03:55 <nibro> TFK: if you want apache to do it for you, then a separate file for each is a lot easier
08:04:13 <TFK> nibro, <TFK> nibro, why? I'll just generate an .html file when a user posts. <--- :-P
08:04:53 <nibro> TFK: I read that as "... when a user asks for a page". I must be tired
08:04:59 <TFK> :-)
08:05:58 <nibro> TFK: still, if you have a slew of posts apache will have to rely on the (slow) file system to find the pages
08:06:58 <nibro> TFK: one single page that looks up entries in a database would have the chance to be faster, but only marginally so and for very large quantities of posts
08:07:18 <TFK> Well, I may have hundreds, maybe thousands. I didn't think about too many pages...
08:07:38 <nibro> TFK: and the maintenance would be on you ;)
08:08:11 <TFK> Ha! The only maintenance required is the rm command (or del on Windows) >-)
08:09:39 <TFK> Well, I'll do it with flat files. The pastebin will probably live through a few life cycles anyway.
08:10:13 <TFK> *pass through
08:10:53 <nlv11757_> im going to fire up that old C64 typinggame to improve my blind typing skills
08:12:28 <TFK> Should module files be suffixed with .hi for ghc?
08:13:50 <nibro> TFK: hi == haskell interface
08:13:57 <nibro> TFK: module files are .o
08:14:23 <nibro> TFK: unless you mean the modules themselves, i.e. the source, that's .hs as always
08:14:27 <TFK> Well, I have Hbin.hs and Misc.hs, and it complains when I do "ghc Hbin.hs"
08:14:35 <TFK> Yes, that's what I mean. Hmmm.
08:15:23 <nibro> TFK: what does it complain about?
08:15:59 <TFK> Failed to load interface for `Misc': <--- and some details
08:16:06 <TFK> Hugs did it just fine, Thank You :-)
08:16:13 <TFK> Or rather, thank it.
08:16:19 <TFK> erm, n/m..
08:16:29 <nibro> TFK: that's because when you invoke ghc, you invoke it on one file only
08:16:44 <nibro> TFK: I think you want ghc --make Hbin.hs
08:16:48 <kolmodin> nibro: have you used HAppS.DBMS?
08:17:19 <nibro> kolmodin: no, just heard of it... no idea if it even suits your purposes
08:17:29 <TFK> nibro, ah, thanks :-)
08:18:01 <nibro> kolmodin: but to use a DBMS written in Haskell has to have some value, right? ;-)
08:18:05 <nibro> TFK: np :)
08:18:06 <kolmodin> sure :)
08:18:36 <kolmodin> as long as it is as fast or faster than sqlite through hsql :)
08:19:02 <nlv11757_> :O
08:19:08 <nibro> kolmodin: well, you'd have no external call, it'd be compiled into your app
08:19:34 <nibro> kolmodin: but still, I don't think efficiency was the primary purpose of the author :-\
08:19:40 <Lemmih> An entire database seems overkill for just auto-completion, IMHO.
08:19:50 * Lemmih pokes bringert.
08:20:10 <bringert> hi Lemmih
08:20:11 <kolmodin> nibro: mm.. it's still version 0.3 so it isn't finished yet...
08:20:29 <nibro> bringert: ah, you come to work when I'm planning to go home ;-)
08:20:41 <bringert> nibro: we should talk about the project
08:20:53 <kolmodin> Lemmih: yes. a bit.. but it's pretty easy and we will than use it for more things (like the calltip)
08:20:57 <kolmodin> :)
08:20:57 <nibro> bringert: should I come up?
08:21:03 <bringert> nibro: mkay
08:21:18 <bringert> afk?
08:21:28 <xerox> The part saying: "Huh? It's logical what the right solution is, and the computer should reorder the instructions the right way." of: http://rinkworks.com/stupid/cs_programming.shtml seems to me to be a guy doing Haskell in Pascal (imagine a let/where clause somewhere) :)
08:22:17 <kolmodin> afk means away from keyboard
08:22:20 <Lemmih> bringert: Going to make the GHC 6.4 compliant haskell-xml-rpc available on your haskell-xml-rpc homepage any time soon?
08:22:56 <bringert> linking problemt
08:23:00 <bringert> will get to it
08:24:28 <kolmodin> using a database for auto completion is perhaps overkill, but it will be easy to get it right and i don't think i can get faster hits than using a real database than doing it on my own. it will be more memory efficient too
08:25:16 <kolmodin> so i still think is a good option
08:25:49 <kolmodin> if anyone has comments on this i realy would like to hear them
08:26:22 <Lemmih> Really? I'd think a modified Data.Map would be faster and less of a memory hog.
08:27:11 <kolmodin> the thing is that i need to search on incomplete strings. "foo" should match "foobar" and "foobaaar"
08:27:33 <Lemmih> Yes. That's why you'd have to change the map a little.
08:28:22 <kolmodin> i'm using Data.Tree now
08:28:44 <Lemmih> Generating SQL, marshalling the SQL to a char*, parsing the SQL, getting the result and unmarshalling the char* result sounds heavy.
08:30:48 <kolmodin> a database can be shared among all open files, one could just specify which values are allowed in a column in the table
08:31:19 <kolmodin> where the coulumn describes the module name
08:31:29 <kolmodin> -u
08:32:02 <kolmodin> if i'm using Data.Map i think i have got to have a map per open file
08:34:24 <kolmodin> I don't think contacting the db and getting the result costs so much. I think the cost is when the database goes through tens of thousands haskell functions
08:39:20 <kolmodin> it's also easy to keep updated for all files since the table is shared
08:40:10 <bringert> should you really have to put haskell98 in build-depends in the cabal file?
08:40:49 <kolmodin> I guess i'll have to try it to see if it is fast enough
08:41:57 <kolmodin> well... bye for now
08:43:14 <Lemmih> bringert: I think so...
08:58:23 <nlv11757_> does Haskell have a printf :P
08:59:43 <smott> how would you pass the data to it?
09:00:16 <Lemmih> @type Text.Printf.printf
09:00:21 <lambdabot> Text.Printf.printf :: forall r.
09:00:21 <lambdabot>                       (Text.Printf.PrintfType r) =>
09:00:21 <lambdabot>                       String -> r
09:01:16 <tromp> http://www.haskell.org/ghc/docs/6.2.2/html/libraries/index.html has no Text.Printf
09:01:26 <Lemmih> @plugs printf "can I use printf from plugs" :: String
09:01:31 <lambdabot> Variable not in scope: `printf'
09:01:37 <Lemmih> tromp: It's new in GHC 6.4
09:02:57 <CosmicRay> There is also a printf in MissingH that will work with older GHC
09:03:02 <CosmicRay> http://quux.org/devel/missingh
09:03:11 <CosmicRay> Igloo also has a printf implemented with template haskell
09:04:49 <tromp> ah, thx, removed the old bookmark
09:08:44 <nlv11757_> sweeet thanks
09:11:49 <df_> Printf from ghc6.4 seemed to work with ghc6.2 and hugs
09:12:05 <df_> 6.2.2 thatis
09:25:17 <sond> should hs-plugins build on windows?
09:25:55 <autrijus> afaik it currently does not
09:26:14 <sond> i tried to build the stable version and it didn't work
09:26:31 <sond> but i might have done something wrong so i thought i should ask
09:27:02 <sond> i just got the ide of using hs-plugins to build your project in our IDE :)
09:27:19 <autrijus> wow. that's a crazy idea :)
09:27:28 <autrijus> you want the cutting edge nightly, tho
09:27:32 <autrijus> the stable doesn't bulid for me either.
09:27:45 <autrijus> mmm perl6-scripted IDE
09:27:46 <sond> i think it would be really cool.. really good turn-around times.. so maybe the IDE could live up to it's name ;)
09:27:56 <sond> yeah, i'm getting it now
09:31:08 <autrijus> what's the name of your ide again?
09:31:55 <sond> Haste :)
09:32:37 <CosmicRay> sond: oh, that was you?  it looked very slick
09:32:49 <Narrenschiff> haskell?
09:34:00 <sond> hm.. got the same error again when building the nightly build: dependency 'base' doesn't exist
09:34:37 <sond> cosmic, i'm part of the project group. thanks but it could look much better. we're thinking of using gtk in the future instead of wxWidgets
09:35:05 <sond> narrenschiff, yes it's for Haskell, if that's what you mean
09:35:10 <Maddas> Wow, nifty :-)
09:37:55 <Narrenschiff> sond: Sorry. Ill. I'm not quite making sense today. Words keep falling into holes.
09:38:28 <autrijus> sond: is gtk nicer to use than wx?
09:39:30 <sond> autrijus, well.. i haven't really tried gtk but it is sort of the only option if we want to have more advanced widgets.
09:39:47 <autrijus> advanced?
09:39:52 * autrijus ponders the viability of XUL
09:40:03 <sond> there's some libraries out there that extend gtk with widgets that are not in gtk itself..
09:40:20 <sond> wich we really would like to have :)
09:40:26 <sond> like, for instance, dockable windows
09:40:49 <sond> autirjus, is XUL some markup-language for guis, lika XAML?
09:41:06 <TFK> Is there any HOWTO for Network.CGI and Haskell? I can read code (Flippi code, actually), but I was wondering if there something in plain English.
09:41:09 <CosmicRay> sond: I really wish somebody would do something that kick-ass for emacs.  haskell-mode sucks
09:41:12 <CosmicRay> :-)
09:41:27 <CosmicRay> morning SyntaxNinja
09:41:32 <sond> cosmic, i'm not an emacs user so i won't do it ;)
09:42:00 <sond> but i guess a good IDE should have emacs and vim modes..
09:42:13 <autrijus> sond: well, yeah. Komodo is built on XUL with python
09:42:20 <CosmicRay> sond: I know, you're solving a different problem and that is great too
09:42:28 <autrijus> sond: and Komodo is quite impressive as IDEs go.
09:42:28 <CosmicRay> sond: I just like things I can run in a terminal when I have to :-)
09:42:41 <autrijus> CosmicRay: aalib!
09:42:52 <CosmicRay> heh
09:43:00 <sond> autrijus, i have to check it out
09:43:04 <TFK> Something like CGI For Simpletons...
09:43:06 <sond> cosmic, hmmh yeah.
09:47:10 <SyntaxNinja> hi CosmicRay!
09:47:22 <CosmicRay> morning
09:47:32 <Lemmih> Greetings, SyntaxNinja.
09:47:58 <CosmicRay> SyntaxNinja: I got all fired up about darcs this weekend :-)
09:48:11 <TFK> How does anyone get CGI programming done, then?
09:48:28 <TFK> Does the knowledge pass verbally, father-to-son? :-P
09:49:12 <CosmicRay> TFK: simon-to-simon :-)
09:49:17 <SyntaxNinja> CosmicRay: cool. what does that mean? :)
09:49:31 <Lemmih> The Simons do CGI programming?
09:49:32 <CosmicRay> SyntaxNinja: http://darcs.complete.org/, and especially arch2darcs :-)
09:49:33 <TFK> All CGI programmers are called Simons? :O
09:49:34 <SyntaxNinja> Lemmih: how's it going; hope I'm not annoying you.
09:49:38 <CosmicRay> Lemmih: nah, just kidding
09:49:43 <TFK> *Simon
09:49:44 <SyntaxNinja> CosmicRay: yeah, as you know, I saw arch2darcs
09:49:50 <CosmicRay> oh, right.
09:50:00 <CosmicRay> too much going on this weekend
09:50:28 <CosmicRay> SyntaxNinja: I forget too, did you agree to write something for HCAR about debian?
09:50:40 <SyntaxNinja> CosmicRay: under duress, yes ;)
09:50:42 <Lemmih> TFK: I'm using Hemplate which takes care of the CGI parts for me.
09:50:49 <CosmicRay> <burns> excellent </burns>
09:50:52 <SyntaxNinja> there's  not much to say, though. I guess I could talk about the sarge plan.
09:51:10 <TFK> Ah, it's 3rd party module?
09:51:15 <TFK> *it's a
09:51:15 * xerox splashes some wather ontop of CosmicRay
09:51:39 * CosmicRay suddenly wakes up!
09:53:11 <Lemmih> TFK: It's a collection of modules (aka package).
10:03:54 <CosmicRay> can I use guards in some way other than in a function declaration?  With case, perhaps/
10:04:38 <Lemmih> Like 'case x of y | isValid y -> True; _ -> False'?
10:05:43 <CosmicRay> right
10:05:50 <CosmicRay> something like that anyway
10:10:40 <TFK> OK, but say I want to use Network.CGI only?
10:10:48 <TFK> It seems to be simple, only three functions defined...
10:13:41 <TFK> So that's a no, then? :-(
10:14:47 <Lemmih> import Network.CGI?
10:15:01 <TFK> Descriptive.
10:31:41 <TFK> Doesn't WASH/CGI have any html docs?...
10:37:21 <gzl> TFK: what do you mean html docs?
10:37:49 <TFK> Documentation lynx can view.
10:37:54 <gzl> yes.
10:38:03 <gzl> look in doc/ ;p
10:38:39 <TFK> I'm in the website.
10:38:48 <gzl> oh, i don't think it's on the website.
10:39:20 <gzl> however, there is stuff here
10:39:20 <gzl> http://www.cis.upenn.edu/~bcpierce/courses/advprog/resources/washdoc/
10:40:20 <TFK> ah, coo, haddoc-generated docs :-)
10:48:04 <skew> TFK: zipWith $ replicate (cycle rule) (iterate (\x -> (x+1)`mod` 2) start)
10:49:27 <TFK> Thanks, but right now I have to think about CGI :-/
11:02:58 <gzl> TFK: WASH is a pain in the ass, by the way
11:03:14 <TFK> Do you know of docs for Network.CGI, then?
11:03:25 <gzl> those should be on haskell.org, I assume
11:03:48 <TFK> A lot of things should be on haskell.org.
11:04:08 <gzl> i've never used it, i dunno
11:04:17 <gzl> but at least Text.Html's docs were pretty straightforward
11:05:00 <TFK> The Network.CGI functions aren't even annotated.
11:05:28 <skew> that hopefully means the source is easy to read :)
11:05:35 <TFK> Right.
11:06:16 <TFK> If reading the source is the only option, Haskell has no future.
11:06:23 <SyntaxNinja> TFK: haha
11:06:41 * TFK shrugs
11:06:43 <SyntaxNinja> TFK: the type sigs are illuminating
11:06:48 <TFK> Yes, very.
11:06:52 <SyntaxNinja> TFK: but it could definitely be better.
11:07:01 <TFK> That's an understatement...
11:07:17 <SyntaxNinja> TFK: if you write little explanations for functions either in the source or just in a text file and send me the diff or the text file, I'll make sure they get into the documentation.
11:07:28 <SyntaxNinja> TFK: so as you learn it, take notes to help others!
11:07:51 <TFK> That's the author's job.
11:07:56 <SyntaxNinja> TFK: you have found the haskell hierarchical libraries, right?
11:08:00 <TFK> Yes.
11:08:18 <SyntaxNinja> TFK: it's a collaborative effort; that's what open source is about.
11:08:28 <SyntaxNinja> actually, most haskell libraries are pretty well documented.
11:08:56 <SyntaxNinja> there's also a wiki
11:08:58 <TFK> No. Open Source is just another way of writing software. Software may eventually suck or not. The method is just means to an end.
11:08:58 <SyntaxNinja> @wiki
11:08:59 <lambdabot> http://www.haskell.org/hawiki/
11:09:02 <TFK> I saw the wiki.
11:09:08 <TFK> Which is written in Python.
11:09:51 <skew> open source is about being able to make software suck less by yourself
11:09:56 <SyntaxNinja> TFK: I'm not trying to talk you into anything. i'm not interested in changing your rash opinions.
11:10:17 <TFK> I'm not trying to talk you into talking me into anything.
11:10:35 <TFK> I'm just trying to find Network.CGI docs in plain English.
11:12:09 <SyntaxNinja> TFK: I'm not the author, and don't know that information.  I've offered to add the docs if anyone creates them since I have cvs access.
11:12:33 <gzl> WASH has documentation, but it's wildly overengineered at times, IMHO
11:12:51 <gzl> and the documentation is not always so helpful
11:12:53 <TFK> Thank you. If I ever write anything, and I will write it if I ever get to actually grok it. Meanwhile, I don't grok it, I don't even know how to approach it.
11:13:10 <TFK> gzl, didn't you say that WASH was a PITA? :-P
11:13:11 <gzl> Flippi uses Network.CGI, maybe look at that source
11:13:16 <gzl> it is a PITA
11:13:40 <gzl> it has documentation and is a PITA, i don't think they're mutually exclusive
11:14:03 <TFK> I am looking at the source, but it's probably not exhaustive of what Network.CGI does.
11:14:36 <SyntaxNinja> TFK: if I had to guess, I think wrapper's argument is a dictionary of the current environment, like from getEnv
11:14:40 <Philippa> TFK: sadly it is :-(
11:14:58 <TFK> Philippa, exhaustive? Flippi's handling of CGI is all there is to it?
11:15:10 <sylvan> TFK: I think it's just a "wrapper" to turn an HTML value into a page that's displayed... Look at wrapper, it seems like it takes a function that will interpret a set of key/value-pairs and produce an HTML (that's the function YOU write) and it wil use this to produce an executable (or script) which works according to CGI
11:15:16 <gzl> Network.CGI seems to only have 3 functions unless I'm looking at the wrong page
11:15:21 <gzl> so it seems entirely possible that Flippi uses all 3
11:15:22 <TFK> Yup.
11:15:28 <Philippa> SyntaxNinja: bingo. Well, for values of "environment" that consist of the standard CGI vars and whatever's in the query string or post data
11:15:36 <Philippa> gzl: it doesn't, but it doesn't really matter either
11:15:41 <gzl> ok.
11:15:45 <Philippa> it covers all the relevant functionality - no cookies, no non-HTML output
11:15:51 <gzl> ok.
11:15:52 <Philippa> no file uploads either
11:15:59 <skew> in about 5 minutes of reading the source, wrapper seems to feed your functinon a list of name/value pairs for the CGI input and display it's output
11:16:09 <Philippa> right
11:16:34 <Philippa> the only other relevant details are that the output's an Html value and the name/value pairs're derived from the CGI environment variables and the query
11:16:54 <skew> pwrapper makes a program that listens on a port handling a bunch of CGI queries, and connectToCGI script makes a program that would actually be run for each CGI connection, which connects to that server and sends the actual query over
11:17:10 <SyntaxNinja> Philippa: ja
11:17:32 <skew> like a really simple version of whatever those fancy standards are for running CGI in other processes. FastCGI and something, I think
11:18:02 <Philippa> skew: CGI itself uses environment variables and then shoves POST data on stdin
11:18:39 <Philippa> ah well. The docs situation does bug me a bit as it doesn't feel like there's anywhere sane for me to contribute notes or anything of that ilk
11:19:29 <skew> I think SyntaxNinja just volunteered as acceptor-of-patches and holder of the sacred CVS access
11:20:01 <SyntaxNinja> Philippa, skew: yup. I'll update any library docs that are sent to me. and libraries@haskell.org has always happily integrated patches.
11:20:25 <skew> I should have mentioned libraries@haskell.org
11:20:33 <Philippa> is that mentioned anywhere in the docs themselves?
11:21:24 <skew> See, I'm really good at pointing out whatever people are ignoring right in front of their faces, but not so good about thinking a step or two ahead
11:21:29 <SyntaxNinja> you could also make notes here: http://www.haskell.org/hawiki/LibraryDocsNeedingHelp
11:21:46 <SyntaxNinja> Philippa: it lists libraries@haskell.org as the maintainer, right?
11:21:56 <skew> that it does
11:22:16 <skew> hey, Network.CGI is even listed on that wiki page
11:22:40 <SyntaxNinja> yup
11:22:43 <Philippa> SyntaxNinja: to somebody not used to an OSS environment that's not much encouragement - a "notes and patches happily accepted" note'd help
11:23:07 <TFK> I searched the wiki, didn't really have much on CGI :-/
11:23:29 <skew> TFK: It is listed under the list of libraries that need better documentation
11:23:32 <SyntaxNinja> Philippa: would it be sufficient to have that on the front page of the hierarchical libraries?
11:23:39 <TFK> All the CGI env vars are generic, right? Independent of Haskell and all?
11:23:46 <skew> That's what I meant.
11:24:05 <skew> TFK: as far as I know it's just the standard CVS stuff
11:24:09 <skew> er, CGI
11:24:16 * TFK nods
11:25:50 <Philippa> SyntaxNinja: that'd do fine, yeah
11:25:58 <SyntaxNinja> Philippa: I'll make a note of that.
11:26:27 <Philippa> I figure anybody who cares enough to want to help is at least going to scan the front page for an "if you want to help" section
11:26:36 <SyntaxNinja> if you have any notes, please pass them along.
11:28:20 <Philippa> I don't at present, but will do next time I end up reverse engineering a lib (or explaining one well enough in here that I can turn it into a set of notes)
11:28:35 <pesco> cptchaos: Moin moin.
11:29:27 <SyntaxNinja> Philippa: great!
11:33:07 * TFK tries doing as advised
11:45:31 <TFK> Well, it compiled :3
11:46:59 <TFK> Wow. It even works :-)
11:47:25 <Philippa> yeah, Network.CGI's pretty simple
11:47:26 <skew> didn't anybody tell you it goes like that?
11:47:49 <TFK> Like what?
11:47:51 <skew> it works once it typechecks
11:47:57 <Philippa> well, trivial programs do
11:48:02 <TFK> Heh
11:48:09 <Philippa> once there's more than one valid program for the type in question there's some room for error :-)
11:48:15 <skew> wait till we have dependent types :)
11:48:17 <TFK> I already encountered a "can't match pattern" error.
11:48:25 <Lemmih> So unsafeCoerce# is the ultimate bug fixer (:
11:48:55 <Philippa> yeah, case is sort of like core haskell's unsafe bit
11:49:06 <skew> main = unsafeCoerce# undefined
11:49:30 <Lemmih> skew: Beautiful.
11:49:39 <TFK> From where I come from, only sissies use type-checking :-P
11:50:23 <Philippa> heh
11:50:37 <TFK> Well, sissies and polymorphism.
11:50:41 <Philippa> talking of which, my boyfriend got to choose between reading TaPL and being tied up and buggered earlier. No prizes for guessing why
11:50:46 <Philippa> *which
11:50:58 <TFK> What's TaPL?
11:50:58 <skew> the macho men can grunt and sweat all they like, I'd still rather dig a ditch with a backhoe than with my bare hands
11:51:04 <SyntaxNinja> TFK: if you wrote a little example program, it would be great if you paste it on the wiki or mail it to me: ijones@syntaxpolice.org
11:51:33 <SyntaxNinja> Philippa: can we guess anyway? ;)
11:51:52 <TFK> I'm writing a pastebin. I dare not say what will happen when I release this abomination on the unsuspecting populace, but I guess the populace will tell me that when the time comes >-)
11:52:04 <Philippa> SyntaxNinja: sure
11:52:08 <TFK> And sure, I'll divulge any information I'll gather.
11:52:14 <Philippa> TFK: Types and Programming Languages by Benjamin Pierce
11:52:27 <Philippa> good intro-to-type-theory book
11:52:27 <skew> It's a great book. Everybody should have a copy!
11:52:37 <Philippa> yeah, self-defence for all!
11:52:53 <TFK> skew, we don't dig ditches, we assault frontally and without mercy.
11:53:10 <Philippa> TFK: that's a big way of saying "suicidally"
11:53:11 * pesco waves
11:53:29 <SyntaxNinja> Philippa: I'm thinking of reading that book too. I just have 5 books to read first ;(
11:53:35 <skew> TFK: whatever. As long as you don't automate away your puny human limitations we have nothing to fear
11:53:49 * Philippa nods
11:53:52 <TFK> hehe
11:53:59 <Philippa> in a full frontal assault, your kneecap's one hell of a liability
11:54:05 <TFK> I want to print envVars now.
11:54:14 * SyntaxNinja notes that this is the 2nd time I've seen Philippa point out that fact
11:54:36 <Philippa> SyntaxNinja: in how long?
11:54:44 <TFK> So I do, do return (toHtmlFromList envVars). Oops! envVars is [(String, String)], not [a]! The horror. :-)
11:54:52 <rtega> someone in here has any knowledge about the numeric prelude?
11:54:53 <SyntaxNinja> hm. maybe 4 months? idono
11:55:07 <SyntaxNinja> [(String, String)] is [a], right?
11:55:14 <TFK> (And no, don't tell me how to solve it. I'll solve it myself, thank you very much.)
11:55:20 <Philippa> TFK: try stringToHtml (show envVars)?
11:55:25 <Philippa> oops, sorry
11:55:28 <TFK> heh
11:55:30 <Lemmih> haha
11:55:44 <TFK> Well now, I won't pass on good advice!
11:55:46 <skew> TFK: try unsafeCoerce#
11:56:02 * TFK shrugs
11:56:03 <skew> Is it okay if I tell you how not to solve it?
11:56:07 <lightstep> why is there an # in the name?
11:56:11 <TFK> There's Twisted, no? ;-)
11:56:14 <Philippa> TFK: if you want to get fancy, turn it into a table
11:56:36 <Philippa> lightstep: it's a compiler thingy
11:56:44 <Philippa> a bit like the unboxed types and stuff
11:56:45 <Lemmih> @type GHC.Base.unsafeCoerce#
11:56:50 <lambdabot> GHC.Base.unsafeCoerce# :: forall b a. a -> b
11:56:51 <TFK> I actually had a more subtle point, but it'll get lost in static vs. dynamic typing flame war that will ensue.
11:57:09 <SyntaxNinja> Are there any haskell libraries in the fptools tree that are not open-source software?
11:57:12 <skew> lightstep: all the things that are not really meant to see the light of day get that #
11:57:13 <Philippa> TFK: go for it, I think the flame war went down in macho, er, flames already
11:57:57 <skew> TFK: we fully understand why untyped languages are better than abominations like Java.
11:58:18 <TFK> Well, there's Perl and BASIC...
11:58:21 * SyntaxNinja lunch &
11:58:39 <TFK> And with all due respect, Java has, what
11:58:40 <TFK> err
11:58:48 <TFK> Java has, what's it called, documentation!
11:58:56 * TFK rubs salt into wounds
11:58:59 <skew> Philippa: Tied up and buggered with a copy of TaPL?
11:59:06 <vegai> TFK: and BOY does it need it!
11:59:07 <autrijus> Perl is a strongly typed language! ;)
11:59:12 * autrijus fuels more flames
11:59:48 <Philippa> skew: not quite, I didn't have enough lube handy...
12:01:02 <Philippa> well, that and I'd rather like to be able to read the book afterwards
12:01:27 <skew> yeah, it would be a shame
12:01:34 <Philippa> besides, he wants to read the book later
12:01:40 <Philippa> (oops, I just gave it away, right? :-)
12:02:10 <skew> TFK: what happened to that point?
12:03:47 <TFK> The point?
12:03:48 <TFK> Oh, the point.
12:03:58 * Philippa pulls it back out of TFK
12:04:06 <Philippa> (sorry, too easy ;-)
12:04:50 <TFK> meh, brb (10 minutes)
12:05:00 <TFK> I'll get back to the point!
12:05:22 <Philippa> it'll be waiting ;-)
12:08:44 <skew> there was a time when the Real Men didn't even use assemblers.
12:09:39 <skew> and all that's left is "I don't need a machine to check my types"?
12:09:48 <TFK> OK, back.
12:10:00 <skew> point
12:10:04 <TFK> Oh yeah, they wrote in Lisp.
12:10:14 * skew jumps up and down, carefully
12:10:28 <Philippa> nah, Lisp's never been a Real Man's language
12:10:41 <lightstep> lisp begat forth
12:10:42 <TFK> See, my point was that in Python, all I'd need is... str().
12:10:47 <Philippa> Real Men don't use conditional statements
12:10:49 <lightstep> so it's at least as manly
12:11:08 <skew> str() to do what?
12:11:19 <TFK> To nothing. It occured to me there's no IO Html in Python.
12:11:27 <TFK> It's just strings. o_O
12:11:37 <skew> or trees of wierd objects representing an HTML document
12:12:05 <TFK> Actually, there's an HTML parser and an SGML parser in the stdlib.
12:12:07 <lightstep> IO Html isn't a very useful type, it seems to me
12:12:22 <TFK> But all I want is to spit a string to a browser.
12:12:35 <skew> yeah, HTML is a bit wierd here
12:12:35 <Philippa> lightstep: a computation doing IO and returning Html? It's the result of a CGI or other webapp, naturally
12:12:47 <Philippa> but yeah, the Html lib's a little weird
12:13:22 <skew> TFK: so your problem is that the interface specifies that your function needs to return some funny HTML representation
12:13:23 <lightstep> Philippa, yes, but there won't be any top-level value with this type: you're only interested in (t -> Html) for various ts
12:13:31 <skew> I didn't know that str() did HTML parsing in Python!
12:13:43 <TFK> It didn't! But I don't need any parsing.
12:13:58 <skew> it's a design issue with CGI
12:14:00 <lightstep> Philippa, unless you're writing a CGI cat program, which is silly
12:14:15 <Philippa> so you want an arrow or what?
12:14:33 <skew> If the return type were IO String you would need a string, which you can make just as easily with show in Haskell as with str in Python
12:15:06 <TFK> Sure. Which is why Philippa's example of stringToHtml (show envVars) should work.
12:15:12 <TFK> I haven't tried it yet because you keep bugging me!
12:15:17 <lightstep> M Html is useful for many monads: nondeterminism and exceptions come to mind. but interleaving the html creation with IO actions seems unhelpful
12:15:30 <skew> I thoughty you were bugging us?
12:15:36 <TFK> But look here: there's toHtml, fromListToHtml, stringToHtml...
12:15:40 <TFK> And I say, huh?
12:15:44 <TFK> No, I wasn't.
12:15:48 <skew> oh, okay
12:15:50 <TFK> You got it all upside down, see?
12:16:10 <lightstep> TFK, fromListToHtml is an artifact of haskell not having strings
12:16:29 <Philippa> lightstep: it doesn't necessarily mean that at all, insofar as the interleaving can be "do all your IO, give me some Html"
12:16:49 <lightstep> yes
12:16:55 <TFK> Well, it's there.
12:17:07 <skew> lightstep: allowing IO while creating HTML can be useful, e.g. hitting a database
12:17:13 <Philippa> at that point, what the hell kind of CGI doesn't do IO? That's a static page
12:17:34 <Philippa> right
12:17:51 <Philippa> (oh, and previous point retracted because obviously you can take in a program in the query string or POST data, but geez)
12:18:18 <TFK> Even with an HTML parser, nothing but html.build() (or somesuch, I've never worked with HTML parsing).
12:18:26 <TFK> err, nothing but ... would be required.
12:18:52 <TFK> Which would return a string anyway, and then you can .write() it to a file or a file-like object.
12:19:10 <TFK> The wonders of duck-typing ^_^
12:19:30 <Philippa> so, writeFile <filename> (show html)?
12:19:39 <skew> yes, and here I believe it's just "show html"
12:19:50 <TFK> html :: IO Html, right?
12:20:02 <TFK> Notice how I said, "file-like object" :-)
12:20:03 <skew> html :: Html for my thing, actually
12:20:11 <lightstep> skew, many uses of Network.CGI.wrapper are of the form (wrapper (return . f))
12:20:36 <TFK> Dunno how writeFile is defined though.
12:20:46 <lightstep> so allowing IO is good, but limiting yourself to no IO is even better
12:20:59 <Philippa> writeFile :: IO ()
12:21:01 <TFK> Hmmm. It appears that the form-data is not submitted with the envVars.
12:21:07 <Philippa> er, FilePath -> String -> IO ()
12:21:14 <pesco> :)
12:21:26 <Philippa> so writeFile <filename> (show html) :: IO ()
12:21:26 <pesco> "Write me a file, already!"
12:21:30 <skew> lightstep: that's good if you can do it, but allowing IO seems to be necessary sometime
12:21:56 <TFK> In Python, .write() is just a method. It's nice because you can substitute files with "streams" (stdout), StringIO objects, whatever.
12:21:57 <lightstep> yes
12:22:00 <Philippa> html is of type Html, but if the computation that built it was IO Html that's no problem
12:22:04 <pesco> What are you people cooking up, if I may jump into the conversation?
12:22:17 <TFK> I was going to start a flame war, but it's not really working :-(
12:22:20 <skew> TFK: this "duck-typing" corresponds to type classes
12:22:21 <Philippa> a lamewar on static vs dynamic tyopping
12:22:32 <lightstep> TFK, in haskell you have PrintfType, which you can instantiate yourself, ad-hoc
12:22:33 <pesco> Oh, I see.
12:22:53 <skew> in Haskell we can add a show method or whatver to a type long after the type was first defined
12:22:55 <TFK> skew, yes, somewhat.
12:23:30 <lightstep> PrintfType being string/file/whatever you can printf to
12:23:33 <Philippa> FVO "somewhat" meaning once in a while somebody declares an instance somewhere
12:23:36 <Philippa> that's about it really
12:23:39 <pesco> What's duck-typing?! Define a type and duck-tape stuff on later?
12:23:58 <TFK> Oh wait, it does pass the form data.
12:24:10 <skew> in Python I suppose you could mutate the base class
12:24:24 <TFK> Yes, introspection allows that.
12:24:36 <TFK> Haven't seen this in practice, besides mix-ins.
12:24:39 <pesco> Intramutation.
12:24:47 <Philippa> pesco: "looks like a duck, fucks like a duck, must be a duck"
12:24:48 <TFK> Also there are metaclasses, but I've never used them (So far).
12:25:06 <Philippa> metaclasses're not far off monads
12:25:11 <pesco> Philippa: Hah.
12:25:24 <tic> oh, thought this was #python for a while
12:25:28 <skew> how often have you seen somebody define some new type of fowl in a library, the go back and cram the appropriate methods into built in objects like lists and things to make it work?
12:25:29 <Philippa> pesco: it /could/ be a furry, but associated furries and python would be bad
12:25:52 <TFK> "cram the appropriate methods"?
12:25:53 <skew> furry == yummy
12:26:01 <skew> at least to the big snakes
12:26:08 <Philippa> skew: "yiffy" is usually more like it
12:27:13 <Philippa> mentioning big snakes would be a bad idea, too
12:28:01 <TFK> Are packed strings interchangable with normal strings?
12:28:45 <skew> I think it's hard to start flamewars here because flamewars require both sides to be a little insecure
12:28:55 <Philippa> TFK: No. I don't think many of us miss that though
12:29:02 * TFK shrugs
12:29:05 <skew> TFK: sadly no
12:29:12 <Philippa> we get a lot out of our lack of coercion
12:29:20 <TFK> Peanuts, peanuts. Wait until I sniff out more of the stdlib.
12:29:34 <skew> there is periodic talk about redesigning the IO libraries, but nothing has come of it yet
12:29:49 <skew> I think MissingH has your notion of file-like-object
12:30:00 <TFK> Maybe!
12:30:23 <Philippa> yeah, there'll be a big redo come Haskell 2/200x, there's a lot can be done with the existing abstractions that hasn't happened so far
12:30:49 <skew> There's a lot that can be done just with fundeps
12:30:57 <TFK> When's the redo?
12:31:01 <Philippa> when it happens
12:31:09 <TFK> Ah, like Python 3000 :-)
12:31:10 <Philippa> when's python3000? :-)
12:31:29 <TFK> I dunno, but the longer they'll put it off, the longer I'll have my lambda.
12:31:49 <skew> it'll probably be the next redo before we figure out how to put those GADTs to good use
12:31:58 <TFK> GADT?
12:32:19 <skew> generalized algebraic data type, aka indexed family. Halfway to depenent types
12:32:32 * TFK blinks
12:32:33 <Philippa> skew: I'm just hoping like hell I publish the stuff on Tyop before Haskell 2 happens
12:32:48 <skew> Tyop?
12:33:03 <Philippa> the same old bunch of type system extensions I've been talking about since I got here
12:33:10 <Philippa> subtyping on ADTs, basically
12:33:18 <skew> hmm
12:33:20 <Philippa> (Tyop was the little language I implemented to test the idea)
12:33:50 <skew> The main thing I remember from TaPL is that subtyping makes type systems hairy
12:35:30 <skew> does this have anything to do with data types associated to classes?
12:35:51 <Philippa> I'm pretty sure this bit works out okay, there're a lot of restrictions on how you can form anything in a sub/supertyping relationship just to maintain the usual properties of ADTs
12:35:56 <Philippa> er?
12:36:22 <skew> did you ever read "associated data types with class"?
12:36:25 <Philippa> (not a lot if I've understood you correctly - there's a coherance issue to deal with, making sure the instance on a subtype and the instance on a supertype do the same thing in the relevant circumstances)
12:36:35 <Philippa> possibly, it's slipped my mind for now though
12:36:55 <lightstep> does A stand for abstract or for algebraic?
12:37:27 <Philippa> algebraic
12:37:48 <Philippa> and one of the consequences is that any given type is closed-world - you can add a new supertype at will, but not a new subtype
12:38:03 <Philippa> otherwise you screw up everybody's pattern-matching
12:38:26 <lightstep> the page about the collection framework says that algebraically defined types are tempting, but bad
12:39:15 <Philippa> they seem to work well in Haskell? Or do you mean in a specific situation?
12:39:28 <Philippa> you probably don't get what you'd normally expect to from subtyping here
12:39:29 <skew> that sounds about right. I think a collection type needs to be a bit wierd inside to give good performance
12:39:36 <skew> balancing info in trees, etc.
12:39:44 <skew> I doubt they meant that generally
12:40:05 <lightstep> they didn't, i overstated it
12:40:20 <skew> I wasn't sure how you meant that
12:40:33 <skew> some of McBrides papers about quotient types are interesting
12:40:53 <lightstep> they said the algebraic data types should not be the default mechanism. or something such, i accidentally purged my elinks package since then, so i lost the history
12:40:54 <skew> I think that's the first time I've seen Kan extensions uses in papers applying category theory to data types
12:41:33 * Philippa really ought to track Conor down and say hi one day
12:41:49 <Philippa> I would've done by now if I hadn't had to suspend my course again - he's on campus often enough
12:41:56 * lightstep really ought to sleep
12:52:49 <TFK> Wonderful. I actually have to *use* Text.Html to make HTML :-/
12:53:03 <TFK> And there I thought I'd roll my own string-building htmlizers :-P
12:53:09 <Philippa> yeah, that didn't impress me overly either
12:53:25 <TFK> I like winging it, ya know?
12:53:29 <TFK> Oh well.
13:00:02 <pesco> cptchaos: Re.
13:00:24 <cptchaos> pesco: Re?
13:00:34 <pesco> You got disconnected or something... ;-P
13:00:58 <cptchaos> cptchaos: reloaded gnome
13:04:41 <skew> why doesn't Network.CGI just ask for a string, and leave it up to you to build HTML however you like, or return something else if you prefer
13:05:00 <skew> seems to violate compositionality
13:05:41 * skew goes off to prove things about manifolds
13:05:48 <TFK> Everything has to be a new and cool type, no?
13:06:53 <pesco> TFK: Surely. We'd never use anything if it doesn't introduce 30 fashonable new types.
13:07:08 <TFK> Yup. Just ain't worth it.
13:07:43 <vegai> plus couple of now abstractions of Monads
13:07:49 <vegai> now->new
13:15:16 <poetix> help!
13:15:35 <poetix> ghc objects when I try to compile with -prof and -auto-all along with --make
13:16:40 <boegel> anybody here knows some cg ?
13:16:52 <poetix> as in: ghc -prof -auto-all -o profile --make profile.hs
13:16:57 <boegel> in particulary Snell's Law (refraction)
13:16:57 <poetix> Is this simply incorrect?
13:17:20 <boegel> poetix: what is the error you recieve ?
13:17:36 <poetix> Failed to load interface for "Prelude"...
13:17:52 <poetix> (note: it works just fine if I leave out the -prof and -auto-all options)
13:18:10 <poetix> (GHC version 6.4, on Suse Linux 9.1)
13:18:37 <SyntaxNinja> anyone know offhand the right makefile target for building the haddock docs in the fptools tree?
13:18:43 <Igloo> You need to install the profiling libraries
13:18:56 <vincenz> Question about monads
13:19:16 <vincenz> Monads are one way...meaning something goes in and doesn't come back out, this allows one to see where IO happens through the types
13:19:20 <vincenz> However
13:19:25 <vincenz> what if a some code does
13:19:34 <vincenz> let a = (Do IO stuff) in ()
13:19:40 <vincenz> the return type is not IO ()
13:19:45 <SyntaxNinja> vincenz: it won't type check
13:19:47 <vincenz> cause a is not used in the return value
13:19:55 <SyntaxNinja> it must be let a = (do io stuff) in return ()
13:20:02 <vincenz> why's that?
13:20:03 <poetix> Igloo: thanks, I'll look into that
13:20:42 <SyntaxNinja> Igloo: someone sent me a patch for building prof libraries w/ cabal, btw.
13:20:42 <vincenz> SyntaxNinja: let a = (do io stuff in return () in true
13:20:48 <Igloo> Ah, nifty
13:20:58 <SyntaxNinja> vincenz: have you tried it?
13:21:03 <Igloo> vincenz: That expression never does any IO, so doesn't need an IO type
13:21:41 <vincenz> SyntaxNinja: no I haven't but if I look at it, why won't it typecheck?  a has type IO ()...but a is not used in return value
13:22:00 <wagle> "let a = ___ in x" wont evaluate a if x doesnt refer to a
13:22:21 <vincenz> oh true
13:22:23 <wagle> .. and the type of a has nothing to do with the type of x
13:22:38 <vincenz> so thereby....using typing, one can be SURE no io happens in a piece of untrusted code?
13:22:42 <SyntaxNinja> yeah true
13:23:04 * SyntaxNinja wasn't replying to vincenz
13:23:09 <SyntaxNinja> since there's unsafePerformIO
13:23:31 * vincenz nods
13:24:05 <TFK> IT IS WORKING!
13:24:09 <vincenz> so...if you dynamically load modules, how can you ensure they don't access your hd?
13:24:14 <wagle> hmm..  i think the top-level actually does the IO actions, so it has to see values of that type for that to happen
13:24:44 <vincenz> let's say you allow people to email modules to lambdabot, but don't want him infecting your harddrive
13:24:51 <wagle> i'm not clear on exactly how the IO actions happen
13:25:27 <wagle> people do feel that types can enforce things like "no IO" and/or separation of state
13:27:06 <Philippa> vincenz: you set your dynamic loader up to ensure modules can't see unsafePerformIO and other such hacks, and then it does work
13:27:46 <Philippa> if you hand a module nothing but the Prelude, it can't do IO without you letting it
13:28:27 <Philippa> wagle: types coupled with not providing operations that break the abstractions in question
13:29:08 <SyntaxNinja> Philippa: how can you make it so they can't see unsafePerformIO?
13:30:33 <Philippa> SyntaxNinja: in the context of a dynamic loader? Depends how much control you have over the loader
13:30:49 <Philippa> (you can't the rest of the time, granted)
13:31:29 <wagle> Philippa: example?
13:31:36 <Philippa> mind you, the rest of the time it's easy enough to check that it doesn't import the ability
13:31:48 <Philippa> wagle: er, I think the hs-plugins docs have an example of how to do that, BICBW?
13:32:05 <poetix> Philippa: are you at Nottingham uni?
13:32:07 <Philippa> yep
13:32:24 <poetix> I'm in Northampton - used to be in Leicester
13:32:30 <poetix> (not at uni)
13:33:13 <wagle> yeah, i know i'm wrong, hence the hope for examples..  8)
13:35:28 <wagle> Philippa: dons's doc?  what am i looking for?
13:35:55 <Philippa> wagle: don't know, it's a while since I went through it. He may've done something filthy like prepending something to incoming plugins
13:36:08 <wagle> ok, thanks
13:36:34 <Philippa> certainly more generally you could give the loader a list of modules to fail on
13:37:18 <SyntaxNinja> Igloo: do you know the makefile target to make the API documentation?
13:37:34 <vincenz> Philippa: and not unsafe io?
13:38:41 <TFK> Does the <- operator do any more magic than assignment?
13:39:14 * SyntaxNinja rolls eyes at libraries@haskell.org (again)
13:39:18 <Philippa> vincenz: the module with unsafePerformIO in it would be one of the ones you banned
13:39:22 <Philippa> TFK: it does no magic whatsoever
13:39:25 * vincenz nods
13:39:26 <vincenz> thx
13:39:32 <SyntaxNinja> TFK: it performs a "side-effect" and assigns the result, if any to the LHS
13:39:40 <Philippa> it's all syntactic sugar - you can look up the translation in the Haskell 98 report
13:39:47 <SyntaxNinja> whereas "let x = b" has no "side-effect"
13:39:49 <TFK> Hmmm.
13:39:55 <TFK> Yea yeah, to an arrow.
13:39:59 <Philippa> the "good enough for most purposes" version is this:
13:40:13 <TFK> It's just that it doesn't pass type-checking, and I have no idea why.
13:40:22 <Philippa> "do foo <- bar; ..." => bar >>= (\foo -> ...)
13:40:36 <TFK> Hmmm... are there any special types the right expression must have?
13:40:52 <Philippa> it has to be in the appropriate monad
13:41:15 <TFK> Well, it's in a monad alright...
13:41:21 <Philippa> >>= :: (Monad m) => m a -> (a -> m b) -> m b
13:41:27 <SyntaxNinja> @paste
13:41:28 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:41:41 <TFK> Maybe it's me on crack and I've made a typing mistake somewhere, but it's plaing weird...
13:41:56 <Philippa> that is, "takes a monadic computation yielding an 'a' and a function from 'a' to a computation yielding 'b', gives a computation yielding 'b'"
13:41:58 <SyntaxNinja> Philippa: I'm not sure how helpful the do; translation is to a newbie.  maybe TFK is more advanced than I think? :)
13:42:11 <Philippa> SyntaxNinja: he did ask about 'magic' :-)
13:42:19 <TFK> It isn't helpful at all.
13:42:26 <SyntaxNinja> Philippa: yeah I know :)
13:42:33 <Philippa> TFK: what're you doing?
13:42:40 <TFK> Trying to make a title :-)
13:42:49 <Philippa> we can't tell how you screwed up without seeing the code at this point
13:42:51 <Igloo> OTTOMH I think the debs just do install-docs
13:42:59 <SyntaxNinja> Igloo: thanks
13:42:59 <TFK> It's too ugly :-(
13:43:00 <theorbtwo> OTTOMH?
13:43:03 * Lemmih has an overwhelming urge to tell Alexander to code more and talk less.
13:43:19 <TFK> For example, I made my own lookup because I didn't have to time to mess with Maybe :-/
13:43:30 <SyntaxNinja> Lemmih: at least I haven't heard anyone else say that build-depends are bad.
13:43:37 <theorbtwo> Oh, Off The Top Of My Head?
13:43:44 <SyntaxNinja> theorbtwo: bingo
13:43:58 <SyntaxNinja> TFK: maybe rulz
13:44:05 <SyntaxNinja> TFK: what do you do if it's not there?
13:44:08 <TFK> Maybe it does!
13:44:14 <TFK> It's guaranteed to be there.
13:44:26 <TFK> If the devil made them disappear, I return "".
13:44:30 <Philippa> <TFK> Maybe it does! <- that's a kind error, surely? ;-)
13:44:41 <TFK> I don't want to think about kinds >_<
13:44:50 <Philippa> they're just types of types. Maybe only takes one parm
13:44:56 <SyntaxNinja> heh
13:45:06 <Philippa> so if "it" and "does" are type variables, "Maybe it does" is malformed. HTH HAND :-)
13:45:11 <SyntaxNinja> TFK: the "simplest" way to use it is to say "isNothing" and "isJust" and "fromJust"
13:45:34 <TFK> Too late, I'm already using lookup2...
13:45:43 <SyntaxNinja> so you can say: let l = lookup a b in if isNothing l then error "foo" else print (fromJust l)
13:45:51 <SyntaxNinja> but that's not how I usually do it.
13:46:02 <TFK> Hmmm.
13:46:20 <SyntaxNinja> better is to say: case l of
13:46:20 <SyntaxNinja> Nothing -> error foo
13:46:20 <SyntaxNinja> Just a -> print a
13:46:32 <SyntaxNinja> er 'case lookup a b of'
13:46:49 <Philippa> from a certain POV the case analysis is 'simpler'
13:46:52 <Philippa> fewer new parts
13:47:22 <TFK> I'll post to the wiki, hold on...
13:47:24 <SyntaxNinja> yeah, I think case is simpler. what do you think TFK? which is simpler?
13:47:31 <TFK> I think I need food.
13:47:40 <Philippa> good call
13:47:57 * boegel bounces up and down
13:48:19 * poetix sways rhythmically
13:48:23 <SyntaxNinja>  boegele: excited?
13:48:27 * Philippa keeps meaning to write an intro to haskell where first she covers the parts of the language that do stuff at runtime (there're essentially five moving parts and loads of sugar) and then explains the type system on top
13:48:50 <poetix> instance SoftFluffyThing IO where...
13:48:59 <Philippa> heh
13:49:10 * asmodai spots an autrijus 
13:49:11 <itior> ive learnt haskell for uni in the past 6 weeks or so
13:49:22 * SyntaxNinja high-fives itior
13:49:27 <asmodai> oh
13:49:28 <itior> omg cyber me~
13:49:46 <itior> the thing i've found hard is more the algorithms and stuff, coming from an OO and imperative background
13:49:48 <TFK> [br] is the MoinMoin newline, right?
13:49:49 <Philippa> yeah, I had a course a few years back. Eighteen months later, the Gentle Introduction was readable for me
13:49:50 <asmodai> and wli
13:50:19 <Philippa> itior: it's tricky at first, especially when you've got an algorithm which makes pretty much essential use of state
13:50:34 <TFK> [[BR]], ok
13:51:17 <TFK> http://haskell.org/hawiki/HaskellIrcPastePage
13:51:31 <Philippa> itior: IMO it gets *much* easier when you find where all the useful data structures went in the libs
13:51:39 <TFK> As you can see, both author and description are guaranteed to be strings.
13:51:45 <Philippa> Data.Map is very, very much your friend :-)
13:53:07 * poetix has developed an unhealthy addiction to the use of the State monad
13:53:18 <poetix> It's like my little imperative teddy bear
13:53:19 <Philippa> TFK: lookup2's not a monadic op
13:53:40 <TFK> I knew there was magic involved...
13:53:41 <Philippa> however, its return type is "String", or [Char], which you can think of as "List Char"
13:53:47 <Philippa> List is a monad
13:54:14 <Philippa> (which is great, but /wonderful/ at confusing people in this situation)
13:54:22 <Philippa> what you want is author <- return $ lookup2 ...
13:54:33 <TFK> But still you tell me it's a monad ^_^
13:54:34 <Philippa> or similarly, author <- return (lookup 2 ... )
13:54:44 <Philippa> the fact it's a monad is why it didn't fall apart earlier
13:55:07 <Philippa> it *thinks* you've given it a computation yielding a Char, and by the third line you've not given it any reason to believe you're trying to use a monad other than the List monad
13:55:25 <Philippa> so the 'most likely' error from its POV is that you've tried to append a char to a string
13:55:27 <TFK> I hope you realize this doesn't register with me.
13:55:35 <poetix> IO is a bad example of a monad in some ways, because its internals are obscure and it's one-way only
13:55:43 <Philippa> poetix: bad timing
13:56:03 <Philippa> TFK: Okay. How much do you know about a) the do notation, b) monads and c) Haskell IO?
13:56:40 <Philippa> oh, and possibly d) Haskell's type system?
13:56:54 <TFK> a) I know that <- means assignment, and I must return (). b) a do is a monad. c) I might be pressed to answer something sensbile, but I'd be parroting Gentle anyway.
13:57:16 <TFK> d) I'm not sure if I like it or hate it.
13:57:28 <Philippa> okay. So really all you've got is hazy handwaving and I get to do the whole intro. Damn.
13:57:37 <itior> i <3 asp's type system
13:57:40 <itior> there isn't one ;)
13:57:41 <TFK> ^_^
13:57:48 <TFK> ASP, heh.
13:57:54 <skew> I can try to help.
13:57:55 <Philippa> First up, "a do" is /not/ a monad. It's a bunch of syntactic sugar for building a 'computation' that's 'in a monad'
13:58:11 <Philippa> the syntactic sugar bit's important. You can write it another way
13:58:22 <TFK> But I don't want to!
13:58:29 <TFK> (Do I?)
13:58:31 <poetix> But it helps if you know how
13:58:32 <Philippa> sure, and I'm not telling you to
13:58:47 <TFK> poetix, not at my stage it doesn't...
13:58:50 <skew> I think it might help to get some intuition about what a monad is
13:58:50 <Philippa> however, you need to know that to understand things properly - if it's all 'magic', you'll keep getting stuck
13:58:55 <skew> or at least what IO is
13:58:57 <Philippa> skew: I was about to go there
13:59:43 <Philippa> Okay. A monad is a parameterised type (so you'd see values of type SomeMonad a, SomeMonad Int etc etc) with a collection of operations on it
13:59:58 <Philippa> Values of that type are 'computations' and are said to be in the monad they belong to
14:00:07 <Philippa> with me so far?
14:00:27 <skew> More specifically, a value of type "SomeMonad a" is a "computation" that does some work and returns an a
14:00:41 <Philippa> right. FCVO "work", etc etc
14:01:11 <skew> (where the monad type bascially tells you the FCVO)
14:01:36 <TFK> OK, suppose I understand. :-)
14:01:58 <skew> IO is the monad where the computation is allowed to do IO to the outside world and play with mutable variables
14:02:08 <Philippa> Now, there're two main operations defined on every monad. One is return, the other is >>=. I'll explain them quickly then we can do the rest in terms of the do notation, 'k?
14:02:39 <Philippa> return takes a value (which can be a function, for example - this /is/ Haskell), and returns a computation that yields that value
14:02:48 <TFK> So IO is a special kind of monad?
14:03:00 <skew> TFK: yes
14:03:01 <Philippa> yeah, though the only special thing about it is that you can't implement it in Haskell
14:03:14 * TFK nods
14:03:32 <skew> Philippa: the do notation might make more sense than >>= if TFK isn't very comfortable with higher order functions
14:03:37 <Philippa> unfortunately, lists are also a monad, which is why your code confused the typechecker and got you a silly error message
14:04:15 <TFK> To recap, a list [a] is a computation that returns a?
14:04:27 <Philippa> right. When you treat it as a monad
14:04:41 <TFK> But I don't usually treat it as a Monad?
14:04:46 <skew> where the "work" that lists describe is nondeterminism, having several possible results
14:04:55 <Philippa> not usually, no
14:05:10 <TFK> How is it nondeterminate?
14:05:22 <Philippa> because your list of as is a list of all possible results
14:05:24 <TFK> (*undetermined?)
14:05:43 <Philippa> and when you try to do something to the result, you do it to everything in that list and generate all possible results, etc etc
14:06:01 <Philippa> we can tell you what the bug in your code is here and now, btw
14:07:29 <TFK> Hmmm.
14:07:31 <Philippa> want us to do that, or would you prefer it if we explain more?
14:09:06 <TFK> I don't understand why what I did wouldn't work for <- if it would work for =.
14:09:50 <SyntaxNinja> a simplification is that <- is for monads and let = is for non-monads
14:09:53 <TFK> ='s aren't allowed in do statments, as I gather.
14:09:57 <Philippa> the short version is that <- doesn't do quite what you think
14:10:04 <Philippa> the RHS is a computation, not just any value
14:10:21 <poetix> x <- f; y is sugar for f >>= \x -> y
14:11:12 * SyntaxNinja is still trying to understand why people explain the (>>=) sugar to newbies
14:11:23 <Philippa> now, the type of lookup2 "name" envVars is String, which is synonymous with [Char]
14:11:38 <Philippa> so, author <- lookup2 "name" envVars is a valid statement in the list monad
14:11:39 <TFK> Yes, which is a list, which is a Monad, a computation.
14:11:50 <TFK> What do you mean, "in"?
14:11:57 <Philippa> computations are not monads
14:12:07 <TFK> But monads are computations.
14:12:10 <SyntaxNinja> but is it your monad? is List the monad type in your function?
14:12:12 <Philippa> again, no
14:12:15 <SyntaxNinja> or are you in the IO monad?
14:12:16 <Philippa> the monad is the type
14:12:30 <TFK> I'm in a do statement :-/
14:12:33 <Philippa> SyntaxNinja: can I walk him through what the type checker sees please?
14:12:45 <Philippa> TFK: yes. And a do statement doesn't give you a monad either, it gives you a computation
14:12:51 <SyntaxNinja> Philippa: why are you asking me?
14:12:56 <TFK> OK. So <- is a valud Monad operation, like + is for strings.
14:12:59 <TFK> *valid
14:13:13 <Philippa> TFK: nearly. It (within the do syntax) is syntactic sugar for one
14:13:34 <TFK> OK. And what does it do, as a Monad operation?
14:14:04 <Philippa> it takes the computation on the right, binds its result to the pattern on the left, then does whatever's in the next part of the do statement
14:14:18 <Philippa> (so inherantly it carries out the computation on the RHS)
14:15:08 <TFK> So the "result" of the list monad [a] is a?
14:15:12 <Philippa> right
14:15:22 <TFK> OK, so that's why it was binding Char and not [Char].
14:15:24 <Philippa> so author::a, or Char in this case
14:15:25 <Philippa> yep
14:15:50 <Philippa> now, what you /want/ to do is make the result of lookup2 "name" envVars an IO computation, right?
14:16:00 <TFK> Why into IO?
14:16:33 <Philippa> because processCGI yields an IO Html, and all the sub-computations of a computation have to be in the same monad
14:16:44 <Lemmih> nhc98 == Malcolm Wallace?
14:16:51 <nhc98> Correct
14:17:11 <Philippa> does that mean JaffaCake should change his nick to GHC? :-)
14:18:00 <Philippa> TFK: the whole point of monads (from one point of view) is to prevent you mixing your computations together without explicitly bridging the gaps
14:18:20 <nhc98> This is my first time using IRC - just thought I ought to pop in and see what it is like.
14:18:25 <Philippa> fair enough
14:18:43 <Philippa> as you've probably noticed, you've caught me explaining monads to somebody while helping explain a problem
14:19:02 <Philippa> TFK: this making any sense?
14:19:07 <SyntaxNinja> nhc98: hey! it's Isaac here.
14:19:19 <TFK> I'm not sure what "mixing your computations" and "bridging gaps" means.
14:20:01 <TFK> *mean
14:20:08 * poetix found http://www.nomaware.com/monads/html/ very helpful
14:20:14 <Philippa> TFK: in a do statement you've effectively got a sequence of computations passing data down the line, right?
14:20:39 <TFK> poetix, yup, I got it bookmarked, but didn't get around to reading it yet...
14:20:44 <Philippa> you can't have a list computation followed by an IO computation, to give an example
14:20:59 <TFK> Why not? They are sequential.
14:21:01 <Philippa> 'bridging the gaps' would be doing things like running computations to give ordinary values as results
14:21:44 <Philippa> because monads effectively form self-contained little languages and many of the things they're used for rely on that
14:22:01 <Philippa> non-deterministic IO would be more than a little hard to implement, for example
14:22:10 <TFK> Yes, but the computations are sequential. Aren't they independent of each other?
14:22:14 <Philippa> no, they're not
14:22:15 <poetix> TFK: I think you need a frame of reference in order to understand the explanation - a few months ago I would have been completely baffled by everything anybody's tried to say to you here
14:22:35 <SyntaxNinja> nhc98: we're glad to have you appear on IRC :)
14:22:37 <Philippa> the reason they're not is that under the hood, computations pass each other info other than their apparent results
14:22:46 <TFK> poetix, you don't say ;-)
14:23:06 <Philippa> for example, the list monad has to maintain an entire list, not just the one answer
14:23:22 <Philippa> the state monad keeps a state under the hood as well as whatever answers you're giving
14:23:38 <Philippa> the IO monad goes a step further and passes an entire universe around, but you probably didn't want to know that, right? :-)
14:23:53 <TFK> I don't have a choice in the matter, do I? ;-)
14:24:25 <Philippa> all the sequencing's being done with that >>= operation I mentioned earlier - that does most of the under-the-hood work
14:24:34 <skew> TFK: A function that just returns an a in another language is a lot like IO a in Haskell - when you get the value out it can do all kinds of side effects and then come up with an a
14:24:47 <poetix> TFK: Also bookmark http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing - introduces monads in the context of a specific application, parsing. YMMV, but this was the paper that made it make sense for me.
14:25:14 <Cale> (or play around with parsec :)
14:25:18 <skew> TFK: Using the <- in Haskell is like calling one of those functions, the = just passes around values
14:25:21 <TFK> Why does nobody like HTML?
14:25:34 <skew> for papers?
14:25:40 <skew> papers look pretty in TeX
14:25:48 <poetix> Academic prestige.
14:25:50 * TFK shrugs
14:25:57 <TFK> And tutorials? Documentation?
14:26:05 <TFK> Anyway, back to Monads...
14:26:15 <Philippa> TFK: does not being able to mix and match monads make more sense looking at >>= than at do?
14:26:37 <Cale> TFK: have you read http://www.haskell.org/hawiki/MonadsAsContainers yet? :)
14:26:41 <TFK> I have no idea what >>= does.
14:26:55 <TFK> Nope...
14:27:08 <Philippa> TFK: For now, it's an operation on monads that does all the plumbing - the do notation translates to something in terms of >>=. Can go further if you want?
14:27:26 <Philippa> (an operation on monadic values aka computations, that is - my bad)
14:27:29 <TFK> Is it worth it?...
14:27:34 <Cale> @type (>>=)
14:27:39 <lambdabot> (>>=) :: forall (m :: * -> *) b a.
14:27:39 <lambdabot>          (Monad m) =>
14:27:39 <lambdabot>          m a -> (a -> m b) -> m b
14:27:55 <Philippa> let's take the Haskell98 version for now...
14:27:55 <skew> confusing <- and = is sort of like defining x = 'TFK' and then writing y = 'hello '+x() vs. y = 'hello'+x
14:28:14 <Philippa> (>>=) :: (Monad m) m a -> (a -> m b) -> m b
14:28:29 <Cale> TFK: Well, it's my article on monads :)
14:28:40 <Cale> But other people seem to have enjoyed it
14:28:47 <TFK> So I *must* read it? ;-)
14:28:54 <TFK> Well I'll have to read it all, I suppose.
14:28:58 <Philippa> that is, given that m is a monad, it takes first a computation m a, then a function from an a to an m b, then it gives an m b. To put it another way, it glues two computations together, passing the result of the first to the second
14:29:08 <TFK> But it's somewhat weird that it's so hard to understand.
14:29:26 <Philippa> it's a bit much when all you wanted to do was some IO, yeah
14:29:36 <TFK> I didn't even want IO :-)
14:29:43 <TFK> But you said I did, heh...
14:29:56 <Philippa> well, you're trying to create an IO computation to get a working CGI, no?
14:30:15 <Philippa> so you're kinda stuck with it
14:30:25 <TFK> I didn't know that until you've told me that the right side of <- must be a monadic function.
14:30:43 <Philippa> no, but you can tell it from the type of processCGI
14:30:47 <TFK> Which in turn must be IO because the processCgi function already returns IO.
14:30:50 <Philippa> right
14:30:51 <Cale> It must be something of type (m a)
14:30:57 <Cale> where m is a monad
14:31:14 <TFK> I can't read that type notation...
14:31:19 <TFK> Hmmm.
14:32:20 <Philippa> TFK: <a> -> <b> is a function that takes an <a> and returns a <b>. <a> <b> is an application of a 'type constructor' or 'parameterised type' <a> to a type <b> - [Char] is sort of equivalent to that, you can think of it as List Char
14:32:32 <Philippa> Parentheses do what you think they do
14:33:03 <Cale> for example m could be IO or [] and a could be something like Integer, giving the types IO Integer and [Integer], respectively
14:33:11 <TFK> Oh, right, I remember now... I didn't get to use type constructors yet, just read about them.
14:33:30 <Philippa> lowercase-starting things're type variables (can be anything), uppercase-starting things're named types or type constructors
14:33:50 <TFK> Well, in some cases they signify functions, in other tuples, and in other still type class restrictions...
14:34:03 <TFK> (in type signatures)
14:34:26 * TFK nods
14:35:01 <Philippa> yeah, I left out the type class bits because the stuff on the LHS of a => looks different IYSWIM
14:35:44 <TFK> IYSWIM?
14:35:49 <Philippa> aaaanyway. You've got a bunch of monads, all of which have their own >>= and return operations. >>= lets you do computations in sequence, with the LHS computation happening first and passing its result to the RHS - shall we ignore the type for now so we don't get hung up on it?
14:35:52 <Philippa> If You See What I Mean
14:35:54 <Cale> If You See What I Mean
14:35:57 <TFK> heh
14:36:03 <TFK> ok :-)
14:36:16 <Philippa> The do notation translates to a bunch of uses of >>=
14:37:10 <Philippa> so what we have left is return to give us computations that give ordinary Haskell values, the do notation or >>= to sequence stuff, and any other computations we have access to (for example, getChar :: IO Char)
14:37:36 <Philippa> we get that little lot for each monad
14:37:58 <Philippa> what we /don't/ have is anything that lets us sequence, say, a list computation together with an IO computation. So we can't do that - doesn't make sense
14:38:37 <Philippa> so, to go back to your code, the first line wants to be author <- return (lookup2 "name" envVars)
14:39:37 <Philippa> and you'll need to do the same to the other lines because they're not IO computations being sequenced in either. In fact, you could rewrite all of it as an ordinary function f, then write processCGI as return (f envVars)
14:40:18 <Philippa> the only reason this isn't more immediately obvious is that the first line atm looks like a list computation to the typechecker - otherwise it'd be telling you off for not giving it a computation
14:40:37 <Philippa> all that make any sense at all?
14:40:48 <TFK> I'm afraid not...
14:40:50 <Cale> The computational view of monads I find is a bit strange to understand at first.
14:41:05 <Philippa> TFK: how far do you get before you get stuck?
14:41:08 <TFK> But it's 00:40 over here, so I can't really blame you :-P
14:41:17 <TFK> I'm not sure.
14:41:27 <Philippa> heh. I'm tired enough here at 22:40, I swear I'm not sleeping right...
14:41:51 <TFK> Nah
14:42:09 <TFK> I'll have to sleep on it.
14:42:12 <Philippa> yeah, but I've not got a job or anything and I don't usually get up before 11am
14:42:14 <Philippa> fair enough
14:42:45 <Cale> TFK: you might read my article at least to the point where (>>=) gets defined in terms of join and fmap, and see if the completely different perspective helps
14:42:47 <TFK> And read up on my moands. Later. Right now I have to create a table with line enumeration.
14:42:59 * TFK will do that
14:43:00 <Philippa> gimme a yell tomorrow? I tend to leave my client logged in overnight, but I'll prolly be up by 11 (that'd be 1pm your time) assuming my b/f doesn't grab my attention
14:43:37 <TFK> Sure thing. Thanks a bunch!
14:43:56 <Philippa> I probably deserve to interpret that sarcastically, but hey :-)
14:44:28 <TFK> Nah #2 :-)
14:45:08 <Philippa> What, you're saying I was shit? ;-)
14:45:09 <SyntaxNinja> Philippa: you did a good job :)
14:45:27 <TFK> Nah #3 >-)
14:45:39 <Philippa> eww, I'd need a new hole for that...
14:46:05 <Philippa> (so it's probably blood?)
14:46:14 <TFK> lol...
14:46:59 <TFK> Well, I'll get back to my table.
14:47:06 <TFK> Everything seems like such a struggle...
14:48:16 <TFK> Heh. I remember back in #python, I asked a certain person about the nature of functional programming. He said that if I knew map(), I knew it all. Oh boy...
14:48:21 <Philippa> yeah. If it helps any, it took me a year or two to really get a hold on exactly what monads were and did - partly because nobody had written up the explanation I gave you
14:49:03 <Philippa> yeah. The good news is that once you grok this properly you get some really powerful toys to play with
14:49:20 <Philippa> one of the reasons you can't intermix computations is that monads can modify control flow
14:49:27 <Cale> map is a good 1/3 of what monads are about though :)
14:49:58 <Philippa> (to give a simple example, the Maybe monad does exceptions - if a computation's Nothing, stop working, if it's Just an answer, do the next bit)
14:50:08 <TFK> A Python Zen koan states, "if the implementation is hard to explain, it's a bad idea." But hey, Tim Peters can't always be right, can he?...
14:50:18 <Cale> (well, 1/3 of the definition anyway)
14:50:35 <TFK> heh..
14:50:42 <Philippa> TFK: considering just what you get implemented it's not too bad - remember what I told you the IO monad does?
14:50:50 <vegai> it's rather derogatory towards Zen to call those koans, imho
14:51:19 <TFK> vegai, I see the humour is lost on you.
14:51:21 <Philippa> yeah. The one about it being done when you remove the last feature might count...
14:51:39 <vegai> TFK: there's no humor.
14:51:45 <vegai> mu.
14:51:54 <TFK> vegai, only the black, deep void of non-existance.
14:52:01 <vegai> which doesn't exist
14:52:05 <TFK> Naturally.
14:52:21 <skew> TFK: monads are about encapsulating every possbile notion of computation under a single conceptual framework
14:52:23 <Philippa> there's no humour. mu mu mu mu mu mu mu. this haiku is bad.
14:52:48 <TFK> I'm pretty sure that's not a haiku...
14:52:48 <Philippa> skew: nah, that's what arrows are about surely? ;-)
14:52:59 <Cale> non-existence isn't black :)
14:53:09 <vegai> there's no humour. mu mu mu mu mu mu mu. this is not a haiku.
14:53:10 <skew> TFK: given that, I'd say stumbling for a while over definitions that are simple in retrospect isn't too bad
14:53:11 <TFK> But the void of it is! I think.
14:53:42 <skew> The explanation of monads that made the most sense of me was "computations" with a side order of "computations can be really wierd"
14:53:51 <Philippa> vegai: old macdonald's farm. mu mu mu mu mu mu mu. Please, please shoot me now.
14:54:01 <TFK> I'm still not sure what "computations" are.
14:54:10 <Philippa> TFK: "things your computer can do"
14:54:17 <Cale> TFK: which is why I like the container definition
14:54:19 * vegai does mime over the IRC.
14:54:20 <TFK> Well that's anything under the sun, no?
14:54:21 <skew> TFK: depends on the monad
14:54:37 <TFK> Three different answers :D
14:54:44 <skew> IO is just the plain old "print some strings", "malloc some memory and mess with it"
14:55:00 <Philippa> TFK: 'read in a line, call it X, print "Hello <X>!"' is one in the IO monad (not in Haskell, mind)
14:55:29 <Philippa> but a computation might be "search for this", "get that"... anything you can make a computer do
14:55:34 <skew> I don't think containers explain IO or ST or stuff like that very well
14:55:42 <TFK> Then what is "take 10 [1..]" ? Not a computation?
14:55:53 <skew> that's just a plain old function in Haskell
14:55:54 <Philippa> you can think of it as a 'pure computation'
14:55:57 <TFK> Aren't I already making computer do stuff?
14:56:10 <skew> you can think of that as living in the "identity monad" if you want, where <- and = are the same thing
14:56:13 <Philippa> though it's just a plain value/function in Haskell
14:56:13 <TFK> What is the difference between a "pure" and "impure" computation, then? Side-effects?
14:56:22 <TFK> Yes, but it's a computation, per definition.
14:56:51 <Philippa> Side-effects. Oh, and no "pure" computation is pure once you actually run it - it does things in the real world that eg a debugger might see
14:57:11 <Philippa> which is one of the reasons it makes sense to have every Haskell program be a computation in the IO monad
14:57:33 <sylvan> TFK: The IO monad is a just a way of _modelling_ a computation, the compiler then generates the code to actually run it. This is needed since Haskell doesn't allow side effects. Thus we "model" the IO-stuff and call the pure haskell functions from there, then we leave it to the compiler to execute the IO-model that we've built, and set up everything we need for our pure functions to actually "do something"
14:57:33 <Philippa> (GHCi is itself in the IO monad, so when /it/ does impure things with your pure code that's to be expected, no?)
14:57:57 <Philippa> sylvan: yes. no. The representation is that which is represented, etc etc.
14:58:22 <Philippa> (*there's* zen)
14:58:42 <sylvan> which is true for, say, the State monad. You model a stateful thread of computations, and then you use the "run" function to actually run it.. with the IO monad it's the Haskell Runtime System that has the "run function", the Haskell programmer doesn't have access to it
14:58:46 <sylvan> well, except for unsafePerformIO =)
14:58:47 <tuomov> the IO monad is a way of constructing instructions for an IO interpreter to interact with the real world
14:59:04 <Philippa> right. So the IO computation "means" the entire program still
14:59:33 <TFK> In other words, a monad can have any ol' piece of code that would otherwise be unacceptable in Haskell.
14:59:42 <Philippa> potentially, yeah
14:59:47 <sylvan> yep, but you can't call such code from a pure function
14:59:56 <Philippa> if you don't mind having to write it in another language then the IO monad can do exactly that via the FFI
15:00:08 <sylvan> so you end up with a thin "impure skin" and a large "pure core"
15:00:10 <TFK> So you shove it in a monad and call the monad.
15:00:21 <Philippa> if you can write fuckUpTheComputer() in C, you can import it as fuckUpTheComputer :: IO () in Haskell
15:00:24 <skew> TFK: it's a little more than that. A monad can be written to describe a language with any particular set of side effects you want to allow too
15:00:31 <skew> IO is the kitchen sink
15:00:38 <blackdog> I think ghci muddies the waters a little bit... given that it treats 'print "blah"' and '"blah"' the same...
15:00:44 <blackdog> at least at the repl
15:00:51 * esap would like to have more than one kitchen sink IO interpreter.
15:00:53 <tuomov> The code that constructs the instructions for the IO interpreter is "pure".. the IO interpreter (within the haskell compiler or interpreter) itself is impure
15:00:57 <skew> State just lets you have one variable of one fixed type that you can "get" and "set"
15:01:14 <Philippa> TFK: you see why Haskellers have no truck with Python "Zen" now? :-)
15:01:27 <sylvan> It's basically a way of sequencing computations.. You model your computations with some datatype, and then define the sequencing operators and voila, you can use do-notation to sequence them and end up with datatype representing this sequence. Then, if you have a "run-function", you can evaluate it.
15:01:30 <skew> ST lets you make a bunch of mutable variables that you can change
15:01:44 <TFK> I can also see why Python is much more wide-spread :-/
15:01:56 <Philippa> you guys realise he's going to have some really weird dreams tonight now, right?
15:02:10 <Cale> heheh
15:02:15 <TFK> That's allright, you already introduced holes and blood...
15:02:24 <skew> STM lets you write database-style transactions that try to change some variables at the same time as STM transactions running from other threads, and roll themselves back if anybody else got in and changed their variables in the meantime
15:02:37 <Philippa> then this is the perfect time to mention what my boyfriend's doing having walked into the room and sat down next to me
15:02:54 <skew> List lets you model computations with many possible answers
15:03:02 <vegai> something pure, Philippa?
15:03:08 <Philippa> not exactly :-)
15:03:20 <skew> you can wire up a reversed State monad where get gives you the value put into the variable by the *next* set operation
15:03:22 <TFK> heh...
15:03:25 <Philippa> he can't fall back on "but, but, the IO monad has a pure translation" :-)
15:03:35 <vegai> unsafePerformIO!
15:03:56 <vegai> this is getting out of hand
15:03:58 <vegai> eep, again
15:04:05 * vegai shuts up.
15:04:06 <sylvan> A neat way to view the IO-monad is as a simple state monad which carries "The World" as a state. Each IO-computation just modifies this state.
15:04:14 <Philippa> vegai: funny you should say that...
15:05:31 <tuomov> Parsec is a good comparison to IO.. it more clearly shows the instruction-constructing nature of both
15:05:53 <TFK> Now I really need food. And tea.
15:06:10 <Philippa> and alcohol. And whatever does the exact opposite to LSD. But you knew that, right?
15:06:15 <TFK> Thanks all, Philippa, sylvan, skew, poetix, vegai... :-)
15:06:41 <skew> I don't know, I think hit should take some acid and sit back down for an explanation of lazy evaluation
15:06:56 <TFK> I don't drink, and don't have drugs next to me. :-/
15:07:14 <TFK> What's wrong lazy evaluation
15:07:18 <skew> I guess we'll have to explain laziness some other time then :(
15:07:22 <poetix> Oh, just to screw you up some more...
15:07:55 <skew> Oh, filling out data structures by looking up values in the final version of the data structure we are in the process of constructing
15:08:01 <poetix> http://codepoetics.com/poetix/index.php?p=94 - Monadic Parser Combinators in Python!
15:08:05 <skew> least fixedpoints in a pointed CPO, that sort of thing
15:08:36 <skew> great fun once you have your head warped around it
15:08:49 <TFK> Hmmm, Python code.
15:08:52 <skew> actually, that goes for all of Haskell
15:09:05 <TFK> Why not use code from a different language to explain Monads, really?
15:09:20 <skew> repeating for shapr, great fun once you have your head warped around it
15:09:20 <shapr> Anyone have a clue about typesafe adjacency?
15:09:24 <vegai> because they're quite a lot harder in other languages
15:09:35 <TFK> shapr, how much work did you get done?
15:09:46 <shapr> TFK: some, but then I got distracted by this crazy idea.
15:09:47 <TFK> Why? Aren't Monads just computations?
15:09:53 <TFK> Other languages get impure computations for free, no?
15:10:01 <skew> Lambda is spelled "lambda" rather than "\" in most other languages. That alone makes it harder to describe
15:10:06 <skew> TFK: I guess you can do that
15:10:09 <vegai> TFK: well... you can do object-oriented programming in C...
15:10:15 <Philippa> TFK: getting them in a language that's nevertheless pure is quite some trick, and the purity comes in handy
15:10:18 <skew> but then all you can describe is "the monad of the impurities that Python allows"
15:10:26 <skew> or "the monad of the impurities that Scheme allows"
15:10:36 <shapr> I think that my typesafe penrose tiles kata is related to region allocation, and efficient FPGA layout.
15:10:38 <TFK> Thus, if Monads are there to separate, it may be possible to show, right there, with code, what is being separated from what.
15:10:42 <skew> really, "the monad of the semantics of Python"
15:10:50 <skew> "the monad of the semantics of Scheme", etc.
15:10:53 <skew> that's the easy one to to
15:11:04 <Philippa> TFK: one example might be separating parsing from IO. That happens in my wiki clone
15:11:11 <skew> That might be worth talking about, actually
15:11:13 <shapr> But I don't know who to ask about this.
15:11:15 <sylvan> I had a "wth are monads anyway" document I typed up somewhere but never posted, I should try to find it
15:11:16 <Cale> TFK: this explanation of monads has been a bit vague, not incorrect, but also seems to miss some basic properties :)
15:11:19 <skew> just think of functions that take no arguments in Python
15:11:31 <TFK> OK.
15:11:40 <TFK> What about them? :-)
15:11:55 <TFK> Cale, well... teaching is hard, innit? ;-)
15:11:56 <skew> they are a value you can pass around a stick in lists and stuff, that represent a computation that will maybe have some side effects and then return a value
15:12:03 <Cale> TFK: Well, yes
15:12:05 <Cale> :)
15:12:05 <TFK> Cale, say, are you teaching anything (math)?
15:12:13 <Cale> I'm studying math
15:12:18 <skew> me too
15:12:21 <TFK> But not teaching?
15:12:28 * shapr is studying his belly button.
15:12:34 <TFK> IIRC, you were a PhD student? (or post-doc?)
15:12:37 <skew> that does warp the approach to monads
15:12:42 <Cale> I'm an undergrad
15:12:44 * Philippa is trying to drag herself next door into bed before the b/f does it for her
15:12:49 <TFK> Oh, hehe...
15:12:54 <sylvan> TFK: interested in "previewing" a short intro to monads (with emphasis on IO)?
15:12:57 <Cale> 4th year at Waterloo
15:13:15 <TFK> sylvan, gimme the link and maybe I'll do tomorrow!
15:13:20 <skew> when you just go "Ahh, a monad is an endofunctor with such and such natural transformations. It's all so *clear* now!"
15:13:31 <Cale> skew: :)
15:13:37 <sylvan> sure, I'll just upload it somewhere
15:13:57 <skew> TFK: anyways, to get the value out of such a function you need to call it, which makes it actually do stuff
15:14:08 <TFK> Indeed.
15:14:08 <Cale> skew: It's not so bad that way if you have a good perspective on endofunctors and natural transformations. :)
15:14:15 <tromp> i used to be at waterloo
15:14:25 <skew> TFK: but passing it around and stuff doesn't make the side effects go, and doesn't get any return value out
15:14:38 <TFK> "passing it around"?
15:15:05 <Philippa> TFK: you have this value which is a computation. You can pass it to a function, that function can return it, etc etc
15:15:08 <skew> for example, you might def then(a,b): {def f(): {a(); return b()}; return f}
15:15:23 <TFK> passing around functions, oke.
15:15:32 <skew> which takes two of these function values, and makes a new one that will do one then the other
15:15:40 <TFK> {} is shorthand for dicts o_O
15:15:41 <Cale> Actually, I had a really easy time explaining monads in the context of programming to my philosophy of mathematics prof, because she used to be an algebraic topologist, and had used monads before in an altogether different context :)
15:15:45 <sylvan> TKF: http://www.dtek.chalmers.se/~sylvan/monad_io.pdf
15:15:59 <skew> TFK: I was using it for grouping, like in Haskell
15:16:02 <TFK> pdf ;_;
15:16:10 <TFK> Will it be up tomorrow, too?
15:16:12 <skew> it's situations like this where grouping symbols are nice
15:16:13 <sylvan> keep in mind it was written a while ago, without really proofreading it too much, and it has some minor references to a haskell lab
15:16:17 <sylvan> yeah sure, I'll leave it up there
15:16:43 <TFK> coo
15:16:49 <skew> TFK: so you see how one of these functions might do something like prompt the user for their name and then say "hi <name>"
15:17:02 <skew> TFK: or increment a global variable and return the next value
15:17:30 <skew> and you can use "then" to stick two of these together into a function that will do one and then the other
15:18:36 <TFK> OK, that might actually work, as a closure.
15:18:49 <Philippa> 'night all
15:18:53 <TFK> night!
15:18:57 <skew> have a good night
15:19:03 <TFK> More like morning, but ok...
15:19:14 * poetix waves
15:19:43 <pesco> Night.
15:20:09 * pesco drags himself into bed, too.
15:20:12 <pesco> *thunk*
15:20:17 <shapr> So, I think that one dimensional adjacency is related to region allocation.
15:20:29 <shapr> And two dimensional adjacency is popular in VHDL layout.
15:20:32 <skew> how does that go?
15:20:37 <skew> "adjacency"?
15:20:41 <skew> like in graph coloring?
15:20:53 <shapr> But I can't find anyone who's tried to encode that into types.
15:21:13 * shapr quickly googles for graph coloring and VHDL
15:21:15 <skew> I would be happy to, if you would explain what "adjacency" means
15:21:51 <shapr> skew: Say you have two values, both of which are two squares, one on top of the other. How can you infer at compile time that placing the top two squares next to each other means that the bottom two squares are also next to each other?
15:22:05 <skew> TFK: so, "then" is ">>". "return" is def return(x): def f(): return x; return f
15:22:24 <shapr> hiya poetix
15:22:39 <skew> shapr: I think I can see how to check that the connections match up, if that's what you want
15:22:49 <poetix> shapr: salut
15:23:04 <shapr> Comment ca va?
15:23:11 <shapr> skew: oh tell me!
15:23:14 <Lemmih> Good night, #haskell.
15:23:37 <poetix> skew: I also am agog...
15:23:37 <skew> well, at least how to compose squares into bigger rectangles where the edge types are some arrangement of nested tupels
15:23:55 <shapr> I'm listening intently.
15:23:58 <skew> and type classes associate the pairing to get the shape of the tuples to match up
15:24:15 <skew> so you would have something like data Box left right top bottom
15:24:59 <skew> and then horiz ::  Box left mid top bottom -> Box mid right top bottom -> Box left right top bottom
15:25:30 <shapr> ?
15:25:55 <skew> or i guess (TupleAppend topL topR top, TuppleAppend bottomL bottomR bottom) => Box left mid topL bottomL -> Box mid right topR bottomR -> Box left right top bottom
15:26:07 <skew> the idea being that you compose rectangles together into bigger and bigger rectangles
15:26:27 <shapr> I thought rectangle composition was a good approach, but I couldn't see how to make it work.
15:26:43 <skew> and those edge types like "left", "top" represent the types of the free connectors on the intividual boxes
15:27:03 <skew> maybe you have a primtiive component of type Box Int Int Bool Bool.
15:27:21 <skew> then stick for of them together to make Box (Int,Int) (Int,Int) (Bool.Bool) (Bool,Bool)
15:27:49 <skew> I think that sort of idea might work, depending on what you want to get out
15:28:22 <skew> If you want a big hammer I'm pretty sure you can code it up however you like in Epigram
15:28:47 <shapr> Yeah, dependent types keep popping up in this problem.
15:28:49 <skew> they just need to give Epigram some kind of an FFI
15:29:01 <skew> I don't see how the types here are depenednt
15:29:10 <skew> at least, not if your componenets all start out with distinct types
15:29:29 <skew> you should be able to do just about any kind of type-combining with typeclass magic
15:29:35 <TFK> How do other pure languages handle this impurity thing? Is Haskell the only thing to have monads?
15:29:45 <shapr> TFK: aren't you asleep? =)
15:29:51 <TFK> Nope, eating.
15:30:05 <shapr> Monads have been implemented in ML, Perl, Scheme, and probably other languages.
15:30:22 <skew> Is Clean the only other pure language?
15:30:38 <skew> Clean has something called uniqueness types that check that you only have one reference to a value
15:30:41 <TFK> What are monads in Perl and Scheme, then?
15:30:58 <skew> the same scheme in Haskell
15:30:59 <shapr> I think there are a bunch of pure languages, but I don't know of anything with as many users as Haskell.
15:31:22 <skew> What I was describing was the simple thing where you pass around functions to encapsulate the standard side-effects that your language allows
15:31:37 <poetix> TFK: I could point you to a paper on monads in Scheme, but I don't think it would help you much...
15:31:39 * shapr tries to understand skew's typesafe adjacency solution.
15:31:57 <sond> how dynamic is ghci compared to hs-plugins when reloading modules?
15:32:01 <skew> if you translate the Haskell thing with a return and bind operator and lambdas and stuff then you can model monads in other languages exactly like in Haskell
15:32:04 <TFK> poetix, I want to find out which other language uses them. Are they actually part of scheme?
15:32:24 <poetix> No, but Scheme can be extended to include them
15:32:27 <skew> TFK: they are something you defined in a library in Scheme, just like they are in Haskell
15:32:45 <TFK> Moands are implemented in Haskell?
15:32:52 <poetix> You can make your own monads
15:33:02 <sylvan> TKF: Yes, but with syntactic sugar (the do-notation)
15:33:14 <sylvan> Monads themselves are just regular Haskell code
15:33:15 <skew> TFK: IO and the do syntax is provided by the compiler (but do is no different than what you can do with macros in Scheme)
15:33:21 <dons> sond, in what sense do you mean?
15:33:32 <shapr> sond: hs-plugins can trace its ancestry directly to GHCi. ozone wrote the RuntimeLoader that was just a simple programmatic wrapper around GHCi's :load code, Hampus Ram wrote the SmartLoader, then dons blew it all away with hs-plugins.
15:33:45 <skew> but the typeclass and return and >>= are plain code you could write yourself
15:34:10 <skew> It's just that Monads are part of the standard library in Haskell
15:35:04 <dons> yeah, so the both bind to the ghc rts' dynamic linker. hs-plugins can do a few extra things not in ghci, like typecheck interfaces, and unload packages
15:35:07 <TFK> OK. So there's no language that actually *uses* moands :3
15:35:14 <poetix> The IO monad is an oddity, because it's really a something-else (something from Outside) that just incarnates itself, so to speak, as a monad
15:35:19 <TFK> I feel so lucky ^_^
15:35:32 <skew> shapr: It's easy to write the type of a function that will take two rectangles that have the same type on their common edge
15:35:33 <TFK> That's the idea, no?
15:35:39 <sond> shapr, ok so that means that there is no win to use hs-plugins to reload modules "faster" than ghci
15:35:46 <sond> or..? :)
15:36:03 <skew> TFK: well, loads of Haskell code uses monads. Also, any language interpreter written in Haskell uses monads to interpret that language
15:36:04 <shapr> sond: There is a win there, have you seen make, eval, etc, in hs-plugins?
15:36:10 <sond> shapr, yeah
15:36:20 <sond> they skip the linking phase somehow
15:36:22 <skew> and in a sense the denotational semantics of any language are build on monads too
15:36:35 <TFK> skew, that's not interesting. What I'm looking for is "outside" perspective. That wouldn't be "ouside", but circular :-/
15:36:59 <skew> what would be "using" monads from "outisde" then?
15:37:04 <shapr> sond: Nah, they do the same thing GHCi does, but with a lot less work on your part.
15:37:25 <dons> sond, it's doesn't actually load modules faster. the basic load code can't be made much faster - it's the linker in the rts that is the bottleneck
15:37:35 <TFK> A different language, made by different people.
15:37:39 <sond> aha okay..
15:38:07 <dons> but hs-plugins is under user control, whereas you can't get at ghci very easily
15:38:27 <poetix> moiell (sp) is a language based on monads...
15:38:29 <shapr> skew: I don't see it.
15:38:36 <skew> TFK: oh, does any language but Hakell use monads.
15:38:39 <dons> sond, what where you thinking of doing?
15:38:44 <sond> i was thinking of integrating hs-plugins in our IDE so that we can use it to build projects
15:38:45 <shapr> skew: but maybe just because I'm tired after hours of fighting with Zope.
15:38:49 <TFK> skew, heh, yes...
15:38:59 <skew> shapr: how about just in one dimension
15:39:05 <shapr> yes please
15:39:07 <SyntaxNinja> shapr:  you missed nhc98 :)
15:39:13 <dons> sond, it would be kind of fun to use it to build code, yeah.
15:39:16 <shapr> SyntaxNinja: maybe he'll come back.
15:39:24 <dons> but faster would be to use ghci (which uses the bytecode interpreter)
15:39:32 <skew> (>>>) :: Arrow a b -> Arrow b c -> Arrow a c
15:39:43 <sond> dons, yeah i guess so..
15:39:45 <dons> if it does have to be compiled to object code, then hs-plugins would be fine for that.
15:39:52 <skew> that sticks two one-dimensional boxes together, making sure that the middle types like up, and gives you back a bigger box
15:40:11 <dons> i'm working on a binding to the bytecode interpreter at the moment
15:40:44 <shapr> skew: interesting point
15:41:32 <skew> I'm just doing the same thing in two dimensions, assuming some typeclass sticks together the top-side types of the left and right boxes into some type that represents that sequence of connections
15:41:51 <skew> alternatively, you could just use pairs and then canonicallize with a typeclass when you want to check if things match
15:42:26 <shapr> I'll have to reread what you've said when I'm awake.
15:42:50 <skew> like horizontalCompose :: (ConnectionsMatch midL midR) => Box left midL topL bottomL -> Box midR right topR bottomR -> Bot left right (topL,topR) (bottomL,bottomR)
15:42:57 <sond> dons, it should be able to compile to object code but if we have ghci (which we want to integrate) then the only reason to compile to object code will be to generate an executable, so that means we don't need hs-plugins I gues
15:43:07 <sond> hmm
15:43:32 <sond> though hs-plugins is a bit easier to interface like you said
15:43:38 <sond> than ghci..
15:43:41 <sond> hm hm :)
15:44:50 <shapr> skew: Still don't get it %-| but I'll stare at it again tomorrow. The arrows type matching does make sense to me though. Thanks.
15:45:10 <skew> shapr: can you describe an application>
15:45:33 <shapr> Originally, I just wanted to make typesafe Penrose tiles.
15:45:39 <skew> It sounds interesting but I don't have enough to go on to write some toy example of a region inferencer or a VHDL thing, or something
15:46:08 <shapr> But now I think that type shape will let you layout memory in neat ways, like region allocation.
15:46:35 <skew> how do composable 1-D boxes give you region allocation?
15:46:37 <shapr> And it will let you do neat calculations of component layout on dies.
15:46:41 <TFK> skew, heh, self.generator=(item for item in generator) <--- this is actually an iterator ;-)
15:47:06 <skew> there's an interpreter out that does those?
15:47:33 <skew> of course, in Haskell-land we just use an ordinary list and let lazy evaluation sort out ininities :)
15:47:48 <TFK> err
15:48:01 <TFK> Sorry, that's not your code o_O
15:48:10 <TFK> Bah. I must sleep.
15:48:20 <skew> is there an interpreter for those out yet, though?
15:48:24 <blackdog> shapr: do you think the pseudo-filesystem approach of ZODB is worth keeping?
15:48:40 <blackdog> i'm inclined to do it all on disk, but if there's a good reason not to...
15:48:44 * poetix thinks acquisition in some form is worth keeping
15:48:59 <blackdog> poetix: how did you know I was working on acquisition? :)
15:49:10 <shapr> blackdog: Runaway from the ZODB. *Everything* should be on the filesystem.
15:49:18 <poetix> I've been having this discussion with shapr...
15:49:28 <skew> maybe somebody needs to write one in Haskell. I wonder if autrijus wants to take on the task of writing the first Python->Parrot compiler too
15:49:37 <poetix> Not every URL should be directly mapped to a filesystem location, tho'
15:49:51 <blackdog> poetix: any thoughts on that, btw? I've been thinking of doing acquisition in haskell: just take the first function in the route to the root that fits typewise...
15:50:23 <blackdog> shapr: thank you for confirming my prejudices. I'll do it on the fs.
15:50:49 <poetix> All sorts of schemes are possible. That being the case, YAGNI is probably a good startiing position.
15:51:08 <shapr> My nightmare project right now is to port the data for 1300 users to a new Zope instance.
15:51:24 * poetix must go
15:51:30 * poetix going cheap
15:51:34 <shapr> The data is incompatible with the new i18n format, so I have to either do it by hand, or find some smart way to dump it out.
15:51:34 * poetix going, going
15:51:37 * poetix gone
15:51:37 <shapr> cya poetix
15:51:37 <blackdog> poetix: ok. talk to you later...
15:51:40 * shapr grins
15:51:49 <blackdog> dammit, he goes away every time i want to talk to him...
15:52:03 <SyntaxNinja> hey blackdog how's life?
15:52:31 <blackdog> G'day isaac. not too shabby...
15:54:01 <SyntaxNinja> blackdog: coo. going to icfp this year?
15:54:24 <blackdog> Where is it? I'm not with the uni any more, so it'll be out of my own pocket if I do.
15:55:55 <SyntaxNinja> blackdog: Estonia
15:57:16 <blackdog> ... hell no. I would if work would pay, but i'm in shapr's boat now - python for work, haskell for fun
15:58:00 * SyntaxNinja nods
15:58:20 <SyntaxNinja> shapr's boat must be an interesting place, what with the unicycle and all ;)
15:58:40 <blackdog> hopefully there'll be an Australian ICFP some time - then you guys can put up with the 24 hours in transit.
15:58:53 <blackdog> shapr's boat has a very small velodrome
15:59:02 <skew> shapr's boat should be a unicycle with floats tied to the wheele
15:59:18 <skew> I don't know how he manages to sleep and balance, but it must work out somehow
15:59:56 <SyntaxNinja> hehe
16:00:14 <shapr> I actually do sleep next to a unicycle :-P
16:00:20 <blackdog> SyntaxNinja: still hacking haskell for mad benjamins, you lucky bastard?
16:01:09 <stepcut> shapr: is same some slur about your fiancee ?
16:01:21 <shapr> Er, no. I just don't have a better place to store my unicycle.
16:01:57 <shapr> It's my 20" training unicycle. I only use it to teach others now.
16:05:18 <skew> SyntaxNinja: what are you doing with Haskell for money?
16:05:26 <SyntaxNinja> blackdog: hehe
16:05:50 <SyntaxNinja> blackdog: what can I say, it's in my blood (US Citizen ;) )
16:05:54 <SyntaxNinja> skew: www.galois.com
16:08:29 <skew> oh, you are with galois
16:08:41 <dons> why doesn't cvs behave more like darcs? <grumble>
16:08:46 <skew> I knew they were doing Haskell
16:08:48 <SyntaxNinja> dons: heh
16:09:34 <skew> sounds interesting, but I doubt I could get a job there
16:09:49 <skew> none of that "significant industry experience" ...
16:10:50 <SyntaxNinja> skew: you never know if you don't try
16:11:57 <skew> I thought John Launchbury was one of the names on the Report!
16:12:31 <SyntaxNinja> yup
16:12:40 <skew> I've already got a job for the immediate future using Haskell
16:12:47 <shapr> Lucky you.
16:12:47 <SyntaxNinja> we've also got andy moran, andy gill, sigbjorn finn, among others
16:13:26 * shapr falls over asleep
16:13:27 <SyntaxNinja> skew: what are you doing?
16:13:30 <skew> it's not necessarily all Haskell, but certainly for my first project
16:13:32 <SyntaxNinja> shapr: wake up!
16:13:33 <skew> building a DSL compiler
16:13:41 <SyntaxNinja> sweeeeeeet
16:13:54 <skew> handwritten Perl just wasn't cutting it anymore
16:14:08 <skew> hopefully they use this instead of rewriting it all in C
16:14:23 <skew> which reminds me, I should work on it a bit
16:14:47 <skew> I've got to remember to hack on this some along with my class work
16:17:22 * blackdog stops thinking and hacks
16:19:49 <skew> Hmm, wouter still hasn't gotten back to me about Aardappel. Maybe I will have to reimplement it in Haskell. I thought "here are some patches that make your code work on modern Java" would be enough to defuse the disclaimer "I have a busy job so don't bug me for bug fixes"
16:20:34 <skew> So, does anyone here know anything about pattern matching an unordered set of patterns against a set of values?
16:23:27 <skew> the best I've got is brute force
16:23:47 <blackdog> don't forget bloody ignorance. bloody ignorance is tops.
16:24:17 <skew> that's not a bad idea
16:24:31 <skew> at least *one* STM transaction is guaranteed to make progress, right?
16:26:03 <skew> see, I'm going to have a bunch of rewrite rules with different sets of patterns fighting over a bag of values
16:26:41 <skew> so I'm thinking running over the entire bag is a coarse enough to get lots of rollbacks
16:47:36 * boegel goes to bed
17:08:18 <SyntaxNinja> I hate the point in refactoring when everything is on the floor in pieces
17:11:03 <dons> :}
17:12:16 <SyntaxNinja> especially when it's like quarter after five
17:13:52 <SyntaxNinja> OMG it compiles
17:18:29 * SyntaxNinja conveniently forgets all the things he was going to clean up when it worked...
17:18:53 <Cale> SyntaxNinja: what are you working on?
17:20:28 <SyntaxNinja> work stuff in haskell; moving stuff from IO into a StateT monad
17:27:09 <blackdog> dons: where do I import the Type that pdynload wants from?
17:29:50 <dons> :/ type Type        = String in Load.hs
17:30:06 * Oejet reduced a thirty line Java function to two lines, and made it more general and more numerical stable at the same time.
17:30:29 <blackdog> ah. fair enough - thought it was some clever Data.Dynamic thingamabob
17:30:36 <dons> hs-plugins-v2
17:31:05 <dons> nah, Data.Dynamic don't allow no polymorphics, which isn't good for pdynoad
17:31:14 <dons> @spell pdynoad
17:31:16 <lambdabot> pudenda Pernod pardoned pond payload adenoid poniard panda synod Dyna
17:31:20 <blackdog> is there a darcs repo for it yet? I'm sick of these cvs snapshots littering my src dir
17:31:22 <dons> yeah, pudenda
17:31:31 <dons> soon. later this week
17:31:34 <hellish> what does BOUNCE! mean in lambdabot output?
17:31:34 <blackdog> your code is ass. :P
17:31:35 * dons hates cvs.
17:31:51 <blackdog> cvs hates you too. cvs hates EVERYONE
17:32:33 <dons> hellish, it's harmless. just a waiting thingo I think.
17:32:48 <hellish> dons: ah.
17:33:17 <dons> it's in the irc rfc probably
17:33:32 <dons> anyway, if lambdabot gets one, it does: doRPL_BOUNCE _msg = debugStrLn "BOUNCE!"
17:33:45 <dons> what are you hacking on?
17:34:42 <hellish> dons: Factoids.
17:35:17 <hellish> dons: My idea is to add a function to the MODULE class that takes messages as returns Maybe aResponse
17:36:07 <dons> ok.
17:36:11 <hellish> dons: and then add one to the Factoid plugin that listens for x is y, or what is x and so on.
17:36:31 <dons> it's the Module class, btw. MODULE is an existential thingo holding a module
17:36:45 <dons> ok, that's quite interesting
17:36:55 <dons> hmm. yes. go for it.
17:50:53 <blackdog> dons: so how do i rep a type as a string, then? Standard "Foo -> Bar a String"  kind of thing?
17:54:51 <dons> fully qualified names, normal syntax -- it's spliced into a src fragment. like so: "Foo.Type"
17:55:16 <dons> I would think the arrow would work too, but I usually wrap plugins values in a data type.
17:55:58 <dons> check the code in src/plugins/Plugins/Load.hs, and examples/pdynload/*
17:56:20 <dons> you up to something?
18:01:11 <blackdog> <innocent> No sir! </innocent>
18:01:27 <blackdog> Actually, i'm hacking a little acquisition demo together. Wanna see?
18:01:57 <dons> sure!
18:02:05 <blackdog> @paste
18:02:06 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:03:50 <blackdog> hm, that looks ugly as. give me a minute
18:05:05 <blackdog> does that look sensible?
18:06:25 <dons> yeah.
18:07:20 <dons> this is pretty cool
18:08:07 <blackdog> What's the API module? Do i need to write a new one for each file i want to load?
18:09:12 <blackdog> ah, cheers.
18:09:50 <blackdog> i should probably move it over to make or something, rather than pdynload, but i figured a simple case first would be best
18:11:13 <hellish> what does "class Module m s | m -> s where ..." mean? things of the type s contained in m are modules where the following functions exist? What does the second half mean?
18:11:55 <dons> it's a functional dependency
18:12:42 <hellish> dons: hmm?
18:12:56 <dons> see here: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
18:13:14 <dons> you get an extra type to play with in the class defn
18:13:25 <dons> we use it to have polymorphic state
18:13:40 <dons> so that each module can have it's own state defined
18:14:26 <dons> yay, explicitly kinded quantification!
18:15:01 <dons> @type (1 :: (Int :: *))
18:15:02 <lambdabot> (1 :: (Int :: *)) :: Int
18:15:42 * hellish stares at it some more.
18:16:06 <dons> so any module type m can also provide a state type s, of it's own choosing.
18:16:10 <dons> that's the effcet
18:16:37 <hellish> dons: ah, that helps a lot.
18:16:38 <dons> e.g. instance Module KarmaModule KarmaState where
18:16:44 <dons> type KarmaState = M.Map String Integer
18:16:49 <dons> s == a Map
18:17:05 <dons> and the type gets statically checked.
18:17:24 <dons> formally internal state was a Typeable,Dynamic scariness
18:17:53 <KrispyKringle> So anyway, I've decided that if I could do memoization, that would solve most of my efficiency problems (if any of you remember my bitching last night). But I can't seem to be able to find a module for this, though my prof was fairly certain there was one. Any help?
18:18:20 <desrt> i need some buzzword help
18:18:29 <desrt> is what C++ does called parametric polymorphism?
18:18:36 <desrt> or is that what haskell does?
18:18:54 <dons> parametic polymorphism, versus ad hoc polymorphism?
18:19:08 <desrt> is c++ ad hoc, then?
18:19:13 <dons> haskell's is parametric, whereas when you have to write your own overloading, that's ad hoc
18:19:16 <blackdog> what c++ does is template metaprogramming, isn't it?
18:19:19 <dons> you only get it for the ccases you write.
18:19:21 <desrt> dons; thanks :D
18:19:24 <blackdog> plus ad-hoc for the class system
18:19:32 <desrt> so parametric is like polymorphism for free
18:19:43 <dons> sort of, a -> a will work for all types
18:19:58 <blackdog> it's a different type of polymorphism: you use parametric when the function works the same over all types
18:20:11 <blackdog> uh, i'm gonna let don talk. he's less verbose.
18:20:39 * dons -> off to uni
18:20:55 <desrt> ::a->a is sort of boring, though
18:20:59 <desrt> not many things that that can be :)
18:21:18 <desrt> really, i can only think of 2 things
18:21:31 <dons> 2 things?
18:21:44 <desrt> 3 actually
18:21:44 <Igloo> I think there are 3
18:21:58 <desrt> except 2 are equivilent from a mathematical standpoint
18:22:16 <KrispyKringle> Anyone? Memoization? :P
18:22:21 <desrt> your 3 choices:
18:22:23 <desrt> 1. id
18:22:24 <desrt> 2. y id
18:22:36 <desrt> 3. \x -> if false then x else undefined
18:22:57 <Igloo> Oh, 4
18:23:02 <desrt> what's 4?
18:23:10 <dons> :t \x -> error "foo"
18:23:20 <dons> @t \x -> error "foo"
18:23:20 <Igloo> id, y id, _|_, const _|_
18:23:21 <lambdabot> Maybe you meant: timein topic-cons topic-init topic-snoc topic-tail topic-
18:23:21 <lambdabot> tell type pl wn
18:23:22 <desrt> dons; that's type a -> b
18:23:40 <dons> true.
18:23:56 <desrt> Igloo; y id is _|_
18:24:05 <dons> @eval Y I
18:24:08 <lambdabot> out of fuel - use @resume to continue
18:24:12 <dons> yi!
18:24:15 <desrt> heh
18:24:29 <Igloo> Oh, good point
18:24:50 <desrt> and const _|_ isn't a->a
18:24:52 <desrt> it's a->b
18:25:04 <desrt> where b is the type of _|_
18:25:20 <KrispyKringle> ah, envermind me. i found it.
18:25:23 <Pseudonym> @type const undefined
18:25:24 <lambdabot> const undefined :: forall a b. b -> a
18:25:26 <Igloo> That's just a difference of definitions
18:25:26 <Pseudonym> So it is.
18:25:55 <Igloo> If my module exports a function of type a -> a then its body can be const undefined
18:26:32 <desrt> @type y id where y f x = f (y f x)
18:26:33 <lambdabot> bzzt
18:26:48 <desrt> *head scratch*
18:26:53 <desrt> @type y
18:26:54 <lambdabot> bzzt
18:26:55 <desrt> @type Y
18:26:56 <lambdabot> bzzt
18:26:58 <desrt> lame
18:27:14 <desrt> anyway.  y id :: a->a but it never returns :)
18:27:50 <desrt> actually, that's sort of an interesting question... in haskell it never returns
18:27:57 <desrt> but does it in straight-up math?
18:27:59 <Pseudonym> No, y id :: a
18:28:06 <Pseudonym> @type let y f = f (y f) in y id
18:28:08 <lambdabot> let y f = f (y f) in y id :: forall a. a
18:28:32 <Pseudonym> Which, by the free theorem, doesn't return.
18:28:34 <KrispyKringle> So anyone ever used the Memo library?
18:28:43 <desrt> weird!
18:29:37 <desrt> i'd love to know why that's the case
18:30:27 <desrt> since you can use mathematical induction to prove that id.id.id.id n times will have type a->a for all n
18:30:58 <Pseudonym> Anything of type forall a. a must not return.
18:31:13 <desrt> although, that being said, you can use induction to prove that for( i = 0; i < n; i++ ); will terminate for all n (assuming i and n are actual integers, not machineints)
18:31:25 <desrt> but that doesn't mean that while(1); will also return
18:31:34 <desrt> s/return/terminate/
18:32:05 <Pseudonym> KrispyKringle: It's been a while, but yes.  I tend to write my own these days.
18:32:33 <KrispyKringle> Pseudonym: you don't use util?
18:32:37 <desrt> well
18:32:44 <Pseudonym> KrispyKringle: I used to.
18:32:45 <desrt> technically, y id :: a -> a
18:32:53 <Pseudonym> No, y id :: a
18:32:53 <desrt> since a->a is a valid instance of a
18:33:08 <KrispyKringle> Pseudonym: So, it says that the arguments are compared using pointer comparisons, meaning that they have to be the same instance, not just the same value.
18:33:16 <Pseudonym> The free theorem says that for every type, there is a theorem that all functions of that type must satisfy.
18:33:18 <desrt> i mean, if you wrote y id :: a->a then haskell would take it
18:33:22 <Pseudonym> Right.
18:33:42 <Pseudonym> For example, if f :: a -> a, then it satisfies the theorem that for all functions g, f . g == g . f
18:34:09 <KrispyKringle> Pseudonym: So I'm using this on an algorithm that recurses over a graph. Since the graph, as passed down as an argument, remains the same, it's the same instance? Thus, if it's called on the same node of a graph, that same node is the same instance and same pointer?
18:34:15 <KrispyKringle> Or will this break pointer equality?
18:34:33 <Pseudonym> I'm not sure.
18:34:43 <Pseudonym> The way I'd do that is to use an environmental CAF.
18:34:54 <desrt> Pseudonym; so anything with type 'a' has to satisfy *all* of the theorems defined for *any* type
18:34:54 <KrispyKringle> CAF?
18:35:21 <Pseudonym> desrt: Yes, I think that's right.
18:35:34 <desrt> interesting
18:35:36 <Pseudonym> Sorry, haven't had caffeine today, but I believe you're right.
18:35:49 <desrt> once i'm out of exams i'll have to look into this
18:36:00 <KrispyKringle> So anyway, what's a CAF?
18:36:01 <desrt> summer is a great time for haskell
18:36:07 <Pseudonym> @wiki MemoisingCafs
18:36:08 <lambdabot> http://www.haskell.org/hawiki/MemoisingCafs
18:36:12 <Pseudonym> And also:
18:36:17 <Pseudonym> @wiki AvoidingParameterPassing
18:36:18 <lambdabot> http://www.haskell.org/hawiki/AvoidingParameterPassing
18:36:23 <Pseudonym> Between them, that should be all the info you need.
18:36:44 <Pseudonym> Oh, this might also help:
18:36:48 <Pseudonym> @wiki TyingTheKnot
18:36:48 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
18:36:59 <KrispyKringle> thanks
18:38:01 <CosmicRay> nice page name :-)
18:38:04 <desrt> @wiki StatisticsSucks
18:38:05 <lambdabot> http://www.haskell.org/hawiki/StatisticsSucks
18:38:08 <desrt> awesome!
18:39:17 <KrispyKringle> Pseudonym: well, I was going to do this just with a lazily-evaluated list, as in the isUppercase example (more or less), but it's dependent on the same by reference/by value question, really...
18:39:36 <KrispyKringle> In a different way, actually; it depends on the list of resultsthat is passed around being a pointer back to the same list for each call.
18:40:14 <Pseudonym> The thing about AvoidingParameterPassing is that you can create a CAF for each outer call.
18:40:36 <Pseudonym> And then use that CAF in a worker.
18:40:49 <Pseudonym> TyingTheKnot has a good example of this.
18:40:57 <Pseudonym> Using a CAF to create a cyclic structure.
18:41:05 <KrispyKringle> Pseudonym: right, but then i need to nest all my functions in the same scope, which is a little oogly ;)
18:41:11 <Pseudonym> CAFs are handy for implementing dynamic programming algorithms.
18:41:20 <Pseudonym> You set up the CAF, then let lazy evaluation do the rest.
18:41:22 <KrispyKringle> i guess ill give that a shot, first, though. the lazily-evaluated list approach seems most intuitive.
18:41:25 <KrispyKringle> at least, to me.
18:41:31 <Pseudonym> Right.
18:41:42 <KrispyKringle> but this works with any list, right?
18:49:20 <KrispyKringle> Fail: <<loop>> ?
18:49:24 <KrispyKringle> wtf does that mean? :P
18:50:01 <Igloo> Your code does an infinite loop
18:50:06 <Igloo> Like foo x = foo x
18:50:17 <KrispyKringle> hrm
18:51:18 <KrispyKringle> i guess my attempt at memoization was flawed.
18:51:18 <tibbetts> Can anyone recommend a Haskell tutorial that focusses on interpreting a domain specific language? I'm thinking something similar to http://www.venge.net/graydon/talks/mkc/html/ (which is for ML)
18:52:19 <KrispyKringle> So I did something like this:
18:53:00 <KrispyKringle> foo xs = somelist where somelist = map (foo' xs)
18:53:36 <KrispyKringle> and foo' is defined in that where clause as a lot of nasty stuff with a base case and, in the recursive calls, the value for that argument retrieved from somelist rather than by running foo' again.
18:53:43 <KrispyKringle> Which, conceptually, looks right to me.
18:54:04 <KrispyKringle> you know, at a high level. it looks just like recursion, but with lazy evaluation on the recursive calls to allow this sort of memoization.
18:55:47 <KrispyKringle> where could that loop be? it's just the list lookup that i added.
18:55:51 <KrispyKringle> it works simply recursively.
18:58:20 <hellish> @type get
18:58:22 <lambdabot> bzzt
19:18:53 <Cale> tibbetts: hmm
19:19:58 <Cale> tibbetts: there's the parsec documentation :)
19:20:33 <tibbetts> Right... :) I'm planning to read heavy docs, but I wondered if there was a nice cookbook to start with.
19:21:52 <Cale> well, the http://www.cs.uu.nl/~daan/download/parsec/parsec.html documentation is fairly tutorial in style
19:53:51 <tibbetts> using the option function in Parsec, is there a convention for what to reeturn for the default value if you don't actually care what gets returned? Comparable to Perl's undef or Python's None?
19:56:49 <Cale> Well, it has to be a value of the same type as what you're returning otherwise.
19:58:50 <Cale> The whole point of the option combinator is to catch failures, specifying a default value. If you don't care about catching them, you can just not use option.
19:59:28 <tibbetts> Ah. But how to I specify "zero or one instances" of a parser?
20:00:37 <Cale> well, that would be option, wouldn't it :)
20:01:15 <Cale> because if it catches the case when the parser fails to parse, providing a default value, that's the same as parsing 0 or 1 times.
20:01:33 <tibbetts> Hmm. But I'm just putting it as an entry in a do {} block, and do I'm throwing away the return value anyway.
20:02:15 <Cale> then make it whatever you want/whatever seems natural, with the only restriction being that it has to be the right type
20:02:23 <Cale> @type undefined
20:02:25 <lambdabot> undefined :: forall a. a
20:02:40 <tibbetts> This is kind of like permute with the <$?> modifier.
20:02:57 <Cale> undefined will work, but if you ever try to evaluate it, it will cause your program to quit (by definition)
20:03:06 <tibbetts> That's cool, and probably what I want.
20:03:40 <tibbetts> so then I could write a skipZeroOrOne function.
20:03:48 <Cale> What return type does the parser you're applying option to have?
20:04:02 <tibbetts> a character.
20:04:09 <tibbetts> I want to notice an optional comma and throw it away.
20:04:10 <Cale> ah :)
20:04:14 <tibbetts> I'm just playing around.
20:04:53 <Cale> I suppose you could return something like ' ' as a default value
20:05:26 <Cale> or even just ','
20:05:32 <tibbetts> In the specific case, retuning ',' as a default value was fine.
20:05:43 <tibbetts> But since I'm learning, I wanted to solve the general problem.
20:09:18 <Cale> maybeOption p = do { a <- p; return (Just a) } <|> (return Nothing)
20:09:25 <Cale> you could also do that
20:14:47 <Cale> How are you finding Parsec so far?
20:15:51 <tibbetts> Amusing. Nice to be doing grammar development in the native language.
20:17:10 <Cale> Yeah, having parsers be values is very nice. Things like   choice ps = foldl (<|>) pzero ps   are quite fun to have around.
20:22:34 <Cale> I once wrote a little program for parsing musical chords (like "F# major, dominant seventh") and printing out lists of chords which could be seen as subchords, or reinterpretations of the same notes with a different root, and being able to build parsers at runtime from a data file for each of the musical terms and then stick them all together was nice.
22:10:16 <bC> hey everyone
22:11:40 <Cale> hello
22:12:22 <bC> hows it going tonight? :)
22:12:28 <Cale> okay
22:12:41 <Cale> studying for an exam and working on my cognitive modelling assignment
22:12:49 <Gahhh> sure sure ;)
22:12:52 <Cale> http://www.student.math.uwaterloo.ca/~cdalmost/pdfs/pm444_lec.pdf -- the course notes :)
22:13:07 <bC> that sounds like quite the bit of fun :P
22:13:36 <Cale> I'll be okay if I just keep telling myself it'll all be over soon :)
22:13:49 <Gahhh> you take notes in latex ?
22:14:16 <Cale> My friend Chris does.
22:14:23 <Gahhh> ah
22:14:32 <Cale> I would, if I had a laptop :)
22:14:33 <Gahhh> impressive
22:14:42 <Cale> Actually, I'd probably just use TeXmacs. :)
22:14:50 <bC> thats just kind of hardcore
22:14:58 <Gahhh> texmacs is too slow to keep up with the prof
22:15:24 <Gahhh> well, on my laptop anyways
22:16:08 <bC> i had a question i was hoping someone could render me a little assistance with
22:16:21 <Cale> I find that after a couple of weeks of using it, it's a good deal faster to key things in it than typing out the LaTeX code for things, especially for things like matrices and such.
22:16:31 <Cale> bC: sure, I suppose I could have a look
22:17:09 <bC> i've recently (tonight) started exploring trees in haskell, and i came across this one thing which i just cant get to work
22:17:58 <bC> im given foldTree :: (a -> a -> a) -> Tree a -> a, and im only slightly sure what to do with it.  i need to apply a function f to a tree
22:18:44 <mflux_> cale, so how did you handle the drawings?
22:19:30 <bC> so i try mapping the function on to v l and r, that didnt work, then i started just messing around after like 40 min of staring at it
22:19:39 <Cale> mflux_: it's fairly easy to add drawings in eps format (I don't have a laptop, so I've never done this)
22:20:51 <mflux_> yes, but does chris open/have a vector drawing program open already, there might be some hurry during lectures?-)
22:21:27 <Cale> mflux_: He usually does the diagrams after the lecture is over
22:25:32 <Gahhh> my wacom tablet works great for diagrams but I dont know if there's software that lets you take notes with a tablet
22:26:36 <Cale> bC: what is the type of f?
22:26:47 <Gahhh> a -> a -> a
22:27:00 <bC> yeah
22:27:20 <Gahhh> ugh
22:27:23 <Gahhh> sorry
22:27:26 <Cale> bC: so you want to actually write foldTree?
22:27:42 <Cale> or you just want (foldTree f) ?
22:28:02 <bC> yeah, and something like foldTree (-) (Node 8.0 (Node 2.0 Nil (Node 7.0 Nil Nil)) (Node 9.0 Nil Nil)) should yield 4.0
22:28:19 <Cale> ah, okay
22:30:04 <bC> so im thinking its like foldr with a tree instead of a list
22:30:33 <bC> i just cant quite get it right :\
22:30:47 <Cale> well, what should foldTree f Nil be?
22:31:10 <bC> Nil im assuming
22:31:25 <Cale> but Nil is a tree
22:31:40 <Cale> you need a parameter for the base case
22:32:07 <bC> yeah, the directions for the exercise are horrendously lacking
22:32:17 <bC> maybe 0?
22:32:44 <bC> half my battle is trying to figure out what the thing actually wants of me
22:33:24 <Cale> foldTree (-) (Node 8 Nil Nil)
22:33:29 <Cale> what does this return?
22:33:59 <bC> -8
22:34:17 <Cale> hmm... :)
22:34:18 <Gahhh> foldr takes an initial arg, doesnt it ?
22:34:30 <Cale> it should, that's what I'm complaining about
22:34:32 <Gahhh> which is what it returns on empty lists
22:35:09 <Cale> May I alter the exercise?
22:35:52 <bC> yeah, its not quite foldr as this is only 3 args incl. the function name, but the v should act like the 3rd arg of foldr
22:36:22 <Cale> Also, it should be (a -> a -> a -> a)
22:36:24 <bC> cale: that takes the challenge out of it ;)  i've managed to do variations of foldtree, but this particular one is driving me insane
22:36:35 <Cale> I don't think this one is well-defined
22:36:40 <Cale> at least, not with that type
22:36:45 <Gahhh> Cale: why ?
22:36:56 <bC> yeah, you would think that, i dont know if its a typo, or if this is what i should work with
22:37:30 <Cale> Well, at least, foldTree f Nil must be bottom
22:37:49 <Cale> because there's no other value which is of type forall a. a
22:38:48 <Gahhh> that is actually ok. Python's reduce (which is living its final months) throws a runtime error on empty lists ;)
22:39:01 <bC> i was kinda thinking of doing something like this before: > foldTree f (Node v l r) = f v (foldTree f l) (foldTree f r), but types dont match, and im not quite sure how to get it to eval
22:39:59 <bC> that was before i realized its kind of mimicking foldr though
22:41:53 <Cale> what is foldTree (-) (Node 1 (Node 4 Nil Nil) (Node 8 Nil Nil))? I'm not sure in what order it's supposed to apply that function of only 2 arguments
22:42:47 <Cale> you're not giving it a base case
22:43:01 <bC> 4-(8-1)
22:43:47 <Cale> hmm...
22:45:09 <Cale> okay
22:45:56 <Cale> I think you'll never be able to deal with foldTree (-) (Node 8 Nil Nil)
22:46:01 <Cale> but you could do some things
22:46:39 <Cale> well, you could have that be 8
22:47:05 <Cale> which is probably sensible given your examples so far
22:47:36 <bC> yeah, the interpreter does that (that hasnt been explained to me yet)
22:48:30 <Cale> foldTree f (Node v Nil r) = f (foldTree f r) v
22:48:37 <Cale> agreed?
22:49:02 <Cale> foldTree f (Node v l r) = f l (f (foldTree f r) v)
22:49:06 <Cale> otherwise
22:49:50 <Cale> what is foldTree (-) (Node 8 (Node 5 Nil Nil) Nil) ?
22:50:13 <bC> 3
22:50:32 <bC> or rather it should be -3, but it shows up as 3
22:51:03 <Cale> so foldTree f (Node v l Nil) = f v (foldTree f l)
22:51:27 <Cale> and we already had foldTree f (Node v Nil Nil) = v
22:51:28 <bC> yeah
22:51:46 <Cale> so reorder those into decreasing specificity and that should work
22:52:12 <bC> ok, lemme try that out real fast
22:54:28 <bC> for foldTree f (Node v l r) = f l (f (foldTree f r) v), i'm getting  unification would give infinite type
22:54:40 <Cale> foldTree f (Node v l r) = f (foldTree f l) (f (foldTree f r) v)
22:54:42 <Cale> yeah
22:54:46 <Cale> noticed that just now
22:54:54 <Cale> need to recurse left
22:56:13 <Cale> *Main> foldTree (-) (Node 8 (Node 2 Nil (Node 7 Nil Nil)) (Node 9 Nil Nil))
22:56:13 <Cale> 4
22:57:21 <bC> err...what exactly do u mean by recurse left
22:57:27 <bC> i think im donig it wrong
22:57:40 <Cale> foldTree f (Node v Nil Nil) = v
22:57:41 <Cale> foldTree f (Node v Nil r) = f (foldTree f r) v
22:57:41 <Cale> foldTree f (Node v l Nil) = f v (foldTree f l)
22:57:41 <Cale> foldTree f (Node v l r) = f (foldTree f l) (f (foldTree f r) v)
22:58:29 <bC> yip...forgot one of the foldTrees :P
22:59:24 <bC> nice, thanks!
23:00:10 <bC> wow, i feel so liberated
23:01:07 <Cale> basically, the trick is to figure out what it will do for some small cases which indicate various patterns of recursion
23:02:16 <bC> yeah, i was trying to be fancy and get it all done in 2 lines...which failed quite miserably
23:02:56 <Cale> well, the definition isn't terribly natural.
23:03:10 <bC> tell me about it
23:04:04 <bC> im going to have to start some kind of log on different techniques
23:04:42 <Cale> I'd probably give foldTree a type something like (a -> b -> b -> b) -> b -> Tree a -> b
23:05:42 <bC> yeah, the first one i did was like that, and the solution was relatively elegant, then i came across it's bastard stepchild which robbed hours of my life
23:06:12 <bC> sorry for taking you away from studying
23:06:34 <bC> i really appreciate the help though
23:06:47 <Cale> no problem
23:09:24 <bC> i think im going to try to tackle bastard stepchild's sibling, so i'll probably be back tomorrow night...or rather tonight
23:10:28 <bC> good night everyone
23:10:40 <bC> cale: gl with the studying and the project, thanks again
23:49:53 <a5> how do i get the terminal dimensions with Curses.hsc?
23:50:08 <a5> (other than by reading the code more :) )
23:55:56 <a5> ah scrSize
