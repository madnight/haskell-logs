00:00:14 <mflux> but I'm off to work, to code in C ;-) ->
00:00:20 <skew> Gahhh: well, does XML.yadda define some interpretation of its argument?
00:00:30 <skew> does that x have to be a well-formed x?
00:01:00 <skew> Gahhh: oh, and of course f should have a longer name if it has a purpose
00:01:19 <skew> I'd say that the things that have a purpose should have a name
00:01:28 <Gahhh> skew: x could be anything. The point is that you dont wanna read XML.yadda's documentation to understand what f is supposed to do. I agree that we agree :)
00:02:22 <skew> the thing that's different between Haskell and some other languages is that sometimes in Haskell it's the *function* that has the purpose, and the arguments have little to no significane on their own
00:04:04 <Gahhh> True. But it's partly because the scope is generally small. C functions do get over 200-300 lines, and you don't want your arg to be named "c".
00:04:43 <skew> I think short functions are sometimes used as an excuse to use a short name and let the reader figure it out
00:05:08 <Lor> C functions should be at most one screenful long, imnsho.
00:05:37 <skew> I could say the same about Haskell programs :)
00:05:43 <Gahhh> Lor: Sometimes you just can't split a function due to performance reasons.
00:05:57 <Lor> Uh.
00:05:58 <dbremner> skew - this came up in a discussion at work last week. I challenged one of the interns to write a function to reverse a null terminated string in place. He called the input variable InputLineString or some such. Maybe it's just me, but it seems like overkill for a 10 line function.
00:06:05 * Lor can't think of any situation like that.
00:06:11 <Lor> Small static functions get inlined anyway.
00:06:33 <skew> dbremner: this is a challenge for your intern?
00:07:10 <dbremner> skew - he's leaving next week and wanted to prep for interviews.
00:07:17 <Gahhh> Lor: I'm writing a performance critical piece and function calls cost time.
00:07:44 <skew> Gahhh: maybe inline could help?
00:08:00 <Gahhh> dbremner: I am familiar with that interview question. Doesn't the answer involve using the NULL character as a temp ?
00:08:02 <blackdog> skew: a Haskell function a whole page long is a bit of a monster. :)
00:08:14 <skew> blackdog: I said Haskell *programs* :)
00:08:30 <blackdog> Ah. Alles klar. :)
00:08:43 <Lor> The zero character is called NUL with one L.
00:08:55 <Gahhh> Wow
00:09:06 <Lor> And there's no need for it when reversing a string.
00:09:09 <Gahhh> I offended the zero character :)
00:09:11 <skew> Lor: or a null, in my usage
00:09:34 <skew> Gahhh: why not just us a register as a temp
00:09:46 <dbremner> Gahhh - what architecture/compiler?
00:10:02 <skew> I suppose if you only have one
00:10:11 <Gahhh> dbremner: ?
00:10:26 <wilx`> Hmm...
00:10:39 <dbremner> Gahhh - if you have performance critical code, most compilers have always_inline pragmas.
00:10:59 <skew> I suppose it could have been a NULL terminated string if it was some kind of linked list
00:11:10 <wilx`> There is this trick that I don't remember that uses xor to swap contents of two places.
00:11:14 <skew> Lor: you should turn your case-sensitivity on if you want to get very far with Haskell :)
00:11:44 <mauke> wilx: a ^= b; b ^= a; a ^= b;
00:12:10 <Gahhh> dbremner: Of course. I just didn't even consider splitting that function, though. I could split and force inline to make it look neat.
00:12:54 <skew> Gahhh: what needed to go so fast?
00:13:01 <dbremner> Gahhh - did you profile it?
00:13:09 <wilx> Hm.
00:13:32 <Lor> When optimizing, a compiler will inline functions even if you don't ask for it specifically.
00:13:56 <Lor> Frankly, performance is a really lousy reason for avoiding splitting code into functions.
00:14:20 <Gahhh> dbremner: Not yet. I did some timestamping tests. I can't spend much time on optimizations nowadays, tho. I'll get to it later.
00:14:22 <Lor> (Better reasons exist, though)
00:14:44 <skew> I'd say aesthetics is a really lousy reason to fail to meet your performance requirements, if they're hard
00:14:59 <Gahhh> skew: it's a proprietary algorithm that runs on expensive hardware and cpu time costs a lot.
00:15:16 <dbremner> skew - ah, but profile first. Intraprocedural optimization is pretty common nowadays.
00:15:24 <pimaniac> really big gifs?
00:15:38 <skew> dbremner: sure, I'm assuming Gahhh knows what he's doing
00:15:59 <Gahhh> dbremner: I will eventually use the Intel compiler so serious optimizations will come in later.
00:16:11 <wilx> Still, I'd try to make it neat first than optimize.
00:16:24 <skew> of course
00:16:35 <Gahhh> wilx: It was neat. I wrote it in python first. This is the C++ port :)
00:17:06 <wilx> roflmao
00:17:12 <Gahhh> I wish I could have written the proto in haskell.
00:17:36 <skew> Gahhh: I remember porting something from Java to Python and making it quite a lot faster by picking up the order reduction I was too lazy to code up in Java
00:17:36 <wilx> I don't like Python.
00:17:59 <skew> wilx: there are things to be learned from that sort of language
00:18:12 <wilx> Like?
00:18:19 <Gahhh> skew: Was that without psyco ?
00:18:30 <skew> Gahhh: that helped too
00:18:47 <wilx> Sorry but I have never found anything interesting in it that would make it worth learning.
00:18:53 <skew> but constant factors don't matter too much in the face of an order reduction
00:19:11 <Gahhh> wilx: There's nothing interesting in python if you already know perl, if that's what you mean.
00:19:21 <wilx> Exactly :D
00:19:34 <pimaniac> ruby is interesting
00:19:48 <Khisanth> well there IS the whitespace...
00:19:50 <pimaniac> especially for those without exposure to smalltalk
00:19:51 <wilx> Dunno Ruby, seems like crippled Smalltalk.
00:19:57 <skew> wilx: oh, that's a different story. I said "that kind of language", like dynamically typed, objects are more or less dictionaries, etc.
00:20:07 <blackdog> ruby doesn't seem that great - sort of an evolutionary python. Ruby on Rails is interesting, though.
00:21:56 <Gahhh> Has anyone played with F# ?
00:22:09 <wilx> What is that?
00:22:19 <Gahhh> Microsoft's .NET OCaml-alike language
00:22:19 <skew> I haven't tried anything#, except for Int# and friends :)
00:22:26 <df_> Gb?
00:22:30 <wilx> Huhu, interesting.
00:23:11 <Khisanth> what happened to D# and E#?
00:23:24 <skew> wilx: one interesting idiom in Python is sticking attributes in other objects with data for them
00:23:59 <skew> wilx: well, I'm not quite sure why you do it. But it makes for interesting code
00:24:01 <Gahhh> Khisanth: passed in favor of a more marketable name that suggests "F"unctional...
00:25:01 <dbremner> blackdog - RoR is neat and there isn't really a python equivalent.
00:25:11 <Cale> E# would be a stupid name anyway, that's just F
00:25:53 <df_> :)
00:25:59 <blackdog> dbremner: have you used it much? I've just done the todo app, like everyone else...
00:26:15 <blackdog> what do you like about RoR? What features can I steal?
00:27:10 <dbremner> blackdog - http://malaprop.org/ a friend came to this conclusion. I'm still looking for an excuse to use it in anger, there's always another fire to fight at work. :-(
00:29:40 <dbremner> blackdog - are you writing a framework?
00:30:31 <blackdog> dbremner: kinda. very larval stage, might not get off the ground - the idea is to use acquisition, like Zope, and whatever else occurs to me as a cool idea.
00:31:51 <blackdog> i'd take issue with "syntax not heinously ugly". :)
00:32:46 <blackdog> anyway, i basically want to be able to write persistent haskell apps for the web in a reasonably rich environment.
00:33:59 <Gahhh> is publishing on the web that hard ?
00:34:56 <blackdog> using haskell? Yeah. I want a bit more functionality than cgi.
00:37:31 <dbremner> blackdog - I'd heard lots of good things about Zope, but the hello world seems awfully verbose.
00:37:33 <Gahhh> So is it a library problem ?
00:41:53 <blackdog> Gahhh: it's a bit more than a library problem. you need a haskell runtime hanging around, otherwise you have to load the whole thing every time a cgi comes in.
00:42:07 <dbremner> blackdog - fastcgi?
00:42:17 <blackdog> dbremner: haven't seen it. How does that work?
00:43:22 <dbremner> blackdog - IIRC, it's sort of a persistent CGI. http://www.fastcgi.com/#Docs
00:43:22 <blackdog> dbremner: about zope - yes, it is a bit. that's kind of inevitable if you want separation of concerns, though. I need to be able to work on pages, hand them to the web designer, and have him be able to work on them without threading his way through piles of script logic.
00:43:37 <mflux> one would need to use haskell apache modules and a haskell daemon
00:44:08 <mflux> not much unlike java servlets work
00:44:18 <blackdog> looks interesting. might be useful...
00:44:46 <dbremner> blackdog - it's occurred to me that a lot of technologies are intended to work with seperation of roles that don't exist at my employer.
00:45:15 <mflux> can you serialize and deserialize function continuations in haskell?
00:45:36 <blackdog> dbremner: there is that. The separation does exist at my workplace, though, so it's important to me.
00:45:42 <skew> mflux: not really
00:45:54 <skew> mflux: like, you can't just package up an arbitrary thread and serialize that
00:46:14 <mflux> ocaml infact supports it, except that the serializing and deserializing binaries must be the same (checked with a hash)
00:46:27 <mflux> which is of course a big limitation, atleast for some applications ;)
00:47:00 <skew> mflux: you might be able to approximate things with some kind of arrow of resmuable computations, but I doubt it would be very nice
00:47:10 <Lor> You might want to try Alice.
00:47:12 <skew> mflux: you are talking about saving the state of a computation?
00:47:50 <mflux> yes
00:48:20 <dbremner> blackdog - we've only got one web designer who also codes.
00:48:25 <mflux> well, a function returning a closure containing 'the rest of the function'
00:48:29 <skew> What do you propose to do about file handles and stuff?
00:49:50 <mflux> those can be tricky. maybe they would be invalidated.
00:50:29 <mflux> unless provided by the deserializer too, somehow
00:54:54 <svens> hi
00:54:56 <skew> mflux: what do you want this for?
00:55:32 <skew> mflux: saving and resuming computations is an interesting problem in full generality, although I have a vauge idea that purity might help somewhere
00:56:02 <skew> hi sven
00:56:15 <skew> svens too
00:56:43 <mflux> skew, a haskell web services system could for instance after providing the page return a continuation describing the options the user may choose from and the actions for them
00:57:27 <mflux> and if there are multiple processes (which is the case with apache) that state would need to be stored somewhere
00:57:29 <skew> I think that's a bit different from capturing a full continuation
00:58:33 <skew> I think this is the sort of special case that makes it feasible that I was fishing for
01:00:04 <skew> This isn't about interrupting another thread and wrapping it up - you just want to serialize values
01:00:24 <skew> possibly with thunks and closures and stuff inside them
01:00:56 <musasabi> JohnMeacham: nice :-)
01:03:58 <Lor> In the original arrows paper there's an example on how to use arrows to serialize the state of a web computation.
01:04:28 <skew> mflux: what about spliting the function into data and code yourself, and loading functions with hs-plugins
01:05:37 <skew> that is, mostly depending on a bit map from names to functions and occasionally using hs-plugins to grab a new function
01:09:10 <musasabi> Lor: isn't that "this is like arrows but with an added typeclass dependency" ?
01:09:51 <skew> musasabi: I think we can fake that with new toys
01:10:10 <skew> like GADTs
01:11:26 <nlv11757_> whats the use for known_hosts server side?
01:11:31 <nlv11757_> good morning btw
01:11:34 <Lor> musa, ah, right.
01:12:05 <musasabi> skew: is that really enough?
01:12:51 <musasabi> skew: people speculate it could be done, but I haven't seen anyone actually doing it and many people are interested in how it could be done...
01:13:02 <Lor> The syntactic sugar for arrows can be used with any class, right? It just uses whatever's the current binding for >>> and friends?
01:13:19 <Lor> (Just like do-notation can be used with a custom class that redefines >>=)
01:13:28 <skew> If you write data T a = T :: (Show a) => a -> T a, then any function that actually works on a (non-bottom) T will learn Show a by unpacking it
01:14:00 <skew> but the type will still be something like forall a . T a -> String, because it can handle any T
01:14:19 <skew> it's just that you can only make a value of type T a when a has a show instance
01:14:28 <Lor> skew, that's just a plain class-qualified existential type, and those have been supported for ages.
01:14:36 <a5> callCC :: ((a -> m b) -> m a) -> m a ..... why not callCC :: ((a -> b) -> m a) -> m a
01:14:42 <skew> Wasn't something like this an example in the GADT paper?
01:14:43 <musasabi> skew: that is not enough.
01:14:47 <skew> no?
01:15:15 <Lor> a5: because it would be wrong.
01:15:31 <musasabi> skew: you have T inside your arrow function. and there you have the unqualified type a. So the compiler will tell you, that you cannot get "forall a. Show a" from "a".
01:15:38 <Lor> Jumping to a continuation is a side effect, it cannot be done with a pure function.
01:15:51 <skew> I guess return gets the wrong type
01:18:34 <musasabi> The basic problem is that you can lift a value of any type into an arrow. What would be needed would be "a value of any type satisfying X".
01:20:29 <a5> Lor: i don't understand. I could have: callCC f = \k -> f k k
01:20:33 <skew> why don't constraints on data types propagate up through the types that mention them?
01:20:52 <skew> a5: then you can just call the continuation to get a value in the pure part of the computation
01:21:14 <skew> a5: but you can't actually go to it and skip the next m action in your do block
01:22:22 <musasabi> Lor: do you think "class (Sat s v) => Arrow a s v | a -> s where arr :: (v -> d) -> a v d ..." would be enough for the general case?
01:22:57 <a5> but isn't "((a -> m b) -> m a) -> m a" a special case of "((a -> b) -> m a) -> m a"?
01:23:20 <skew> no
01:23:28 <skew> it's that contravarience again
01:23:49 <a5> substitute b = m b
01:23:49 <skew> ((a -> b) -> m a) is a special case of ((a -> m b) -> m a)
01:24:31 <Lor> musa, what's class Sat?
01:24:49 <skew> because any function that can do useful work with any argument of type a->b can work with an argument of type a->m b, but there are some things you can do with an (a -> m b) that you are not allowed to do with any (a -> b)
01:25:19 <musasabi> Lor: just "class Sat a b" for encoding constraints.
01:25:41 <Lor> Ah, right.
01:25:41 <musasabi> Lor: so e.g. "instance Show s => Sat WebArrow s"
01:25:43 <skew> musasabi: I think those fundeps are a bit off
01:25:56 <Lor> a -> s ?
01:25:59 <skew> hmm
01:26:23 <musasabi> skew: hmm, true.
01:26:25 <skew> maybe you don't need to constrain the result types
01:26:41 <skew> I thought you had a determining v
01:26:59 <a5> skew: return.f :: (a -> b) -> (a -> m b) right?
01:27:30 <skew> sure
01:28:16 <skew> let's go operational. How is the monad's return supposed to look at this a->b function it is getting and know to translate it into going to a continuation?
01:29:50 <a5> \x k -> k x
01:31:09 <skew> that's return, so return <magic a->b from callCC> = \k -> k <magic a->b from callCC>
01:31:23 <skew> looks like we're still following the continuation of our expression, not the saved one
01:33:47 <a5> return "." f. composition
01:34:36 <a5> or where am i returning f?
01:34:53 <skew> okay, so return . <continuation> $ x -> \k -> k (<continuation> x)
01:35:09 <skew> a5: you said you would use return to make an a -> mb from the a->b you wanted
01:35:25 <skew> and presumably if you are using a continuation monad you want to have code like
01:35:29 * Jerub compiles Yi
01:36:01 <skew> callCC (\cont -> do <something>; <something else>; when <condition> <somehow go to cont>; <keep doing stuff>)
01:36:45 <skew> at a minimum you need callCC (\cont -> <somehow invoke cont on 0> >> return 1) to give 0, not 1
01:36:53 <a5> ok another angle. the definition callCC in the libraries is (paraphrasing) \f k -> f (\a -> \_ -> k a) k
01:37:11 <skew> yes
01:37:13 <a5> ... but f can easily construct (\a -> \_ -> k a) from k
01:37:36 <skew> only if the definition of the continuation monad is exposed
01:37:59 <skew> because all those k are the plumbing that the "m" in MonadCont m hides
01:38:04 <Jerub> hmm, darcs Yi is broken, missing module.
01:38:12 <a5> still my type \f k -> f k k can be given an 'f' that produces the same semantics
01:39:09 <skew> consider data Cont r a = Cont ((a -> r) -> r)
01:40:33 <skew> so \x k -> k x turns into \x -> (Cont (\k -> k x))
01:40:49 <skew> now suppose you don't have the definition
01:41:01 <skew> how to you turn your k into (\a -> \_ -> k a) now?
01:41:16 <skew> I'm assuming you are talking about the MonadClass cont, or something similar, by the way
01:42:37 <a5> MonadCont class? :) ... thinking
01:42:58 <skew> any particular monad could very well expose a function with a type of ((a -> r) -> r) -> M r a, or (forall r. ((a -> r) ->r)) -> M a, or something like that
01:43:34 <a5> but "runCont :: (a -> r) -> r" exposes some interface
01:43:38 <skew> I'm really basing this whole discussion off the case of the m you typed hours ago
01:44:23 <skew> mflux: Could you explain how serialization and multiple apache processes interact?
01:44:31 <a5> er runCont :: Cont r a -> (a -> r) -> r
01:44:45 <skew> a5: that's for getting a function of that form out
01:44:49 <skew> very different
01:45:11 <mflux> skew, the data would be serialized into some separate process at the end of handling the request
01:45:34 <mflux> skew, although I guess overall a better design would be to just pass the actual request (and maybe filehandle) to the separate process
01:45:58 <skew> mflux: you hope the serialized data reaches the other apache by the next request?
01:46:48 <mflux> skew, well that's an interesting problem, but that could be done
01:47:09 <mflux> by making the 'continuation' request tagged so that it will wait for the continuation to arrive
01:47:44 <dons> Jerub: what's missing?
01:47:46 <mflux> and realistically there'd be no wait at all, as the network latency is surely going to be larger than serializing/deserializing small amounts of data
01:47:52 <skew> a5: Text.Read exposes a function of type (String -> [(a,String)]) -> Read a. Parsec can't
01:47:54 <mflux> (locally)
01:48:04 <dons> Jerub: got it. pushing now.
01:48:55 <dons> Jerub: try that.
01:51:45 <Jerub> dons: thankyou :)
01:52:33 <skew> a5: even though parsec does basically give you Parer a -> (String -> [(a,String)])
01:55:39 <a5> skew: so the current form of callCC is for hiding the interface?
01:56:23 <basti_> hi
01:58:03 <basti_> lambdabot is not intended to manage +o flags is it?
01:58:30 <musasabi> basti_: you could add a module for that.
01:58:35 <musasabi> I would use it ;)
01:58:53 <basti_> is it already written?
01:59:09 <Jerub> dons: I'm a vim user, and I don't know vi.
01:59:20 <Jerub> dons: would it be best if I just hacked on Vim.hs and ignored Vi.hs ?
01:59:40 <basti_> ahh dons... I'm making progress on the key binding issue
02:00:30 <musasabi> no, I don't think so.
02:00:53 <basti_> musasabi: i see.
02:03:28 <dons> Jerub: adding bindings to the vim mode is ok.
02:03:42 <dons> the vi mode is intended to be an exact vi emulation
02:03:52 <dons> basti_: cool. send patches!
02:04:21 <Jerub> dons: if only i still understood syntax.
02:04:27 <Jerub> I'm just trying to figure out how to make '0' work properly.
02:06:09 <musasabi> The thing with auto-opping is that one needs a delay between the join and the op.
02:06:40 <bourbaki> moin
02:06:44 <basti_> dons: not yet. its does not make sense right now.
02:07:07 <musasabi> Basically "upon join if nick matches /oppable on current channel/; then op after random delay".
02:07:21 <basti_> hmm
02:07:46 <musasabi> the delay part makes things nontrivial..
02:08:16 <basti_> you would need a timer to accomplish that the right way.
02:08:43 <musasabi> because one needs to act sensible if things happen during the delay (part/nick changes/quits/...)
02:09:02 <basti_> well after the delay, another check should occur
02:09:16 <basti_> preferably the same check as before
02:09:23 <musasabi> hmm, true.
02:09:35 <musasabi> but would that work for nich changes too?
02:10:01 <basti_> ideally, the "handle" for "the guy to op" would refer to the new nick then
02:14:05 <Jerub> awesome. :))
02:14:15 * Jerub is hacking on the vim keymap
02:15:46 <dons> Jerub, doess it make sense?
02:16:00 <dons> also, the vi map is very similar ('0' is vi too, for example)
02:16:15 <Jerub> dons: it does make sense.
02:16:22 <Jerub> dons: but I'm not a very good haskellite.
02:16:42 <dons> 0 isn't implemented, btw, as it classes with numeric arguments to commands.
02:16:46 <Jerub> dons: so I'm confused about how to do things like "unless there's numbers in the accumlator, map '0' to solE")
02:16:46 <dons> working around that would be useful
02:17:02 <Jerub> yes, 0 is a troublesome one, and I'm hacking on it.
02:17:14 <Lemmih> '0'?
02:17:23 <Jerub> Lemmih: it means the same as <home>
02:17:28 <dons> you can't do it that way, you can: '0', if stuff in accum then count else solE
02:18:10 <Jerub> so you reckon it's easier to do it in lex_count ?
02:18:44 <Jerub> becuase that's a scary line there
02:18:55 <Jerub> lex_count = digit
02:18:56 <Jerub>     `meta` \[c] st -> (with (msg (c:acc st)),st{acc = c:acc st},Just $ cmd st)
02:19:38 <dons> that might be fairly easy.
02:20:20 <dons> yeah, lex_count could handle it.
02:23:06 <Jerub> dons: I'm going to bed, my back is killing me.
02:23:24 <Jerub> dons: this looks like a great start.
02:23:31 <dons> ok. cool.
02:23:50 <Jerub> dons: I don't think 'c' belongs with 'C'
02:24:10 <Jerub> I'll look at it some other time.
02:24:24 <dons> no, it's a different thingo really
02:24:29 <dons> todo.
02:24:48 <Jerub> dons: how easy is it to recompile and install changes?
02:25:13 <dons> go to a shell; type make; type :reboot in yi.
02:25:20 <Jerub> :reboot
02:25:20 <Jerub> okay
02:25:22 <Jerub> thanks :)
02:26:58 <Jerub> dons: once this gets visual block mode, and syntax highlighting, it'll be BetterThanVim
02:27:39 <dons> I reckon so!
02:37:38 <shapr> y0 Jerub
02:45:03 <a5> skew, Lor: thanks. sorry if i'm being dense, i just want to have a more thorough understanding.
02:45:28 <a5> i still don't understand the contravariance thing.
02:48:39 <skew> a5: do you have a copy of TaPL?
02:48:57 <a5> maybe, depending on what that stands for :)
02:49:20 <a5> oh, yeah
02:50:24 <dons> [darcs-users] Announcing darcs 1.0.3rc1, yay!
02:50:32 <a5> are you saying "m b" is more general than "b" by itself? because i have a function "b -> m b" but not vice-versa
02:54:06 <vegai> dons: does it come with 23% more sparkle?
02:54:07 <musasabi> Has anyone got a haskell98 formulation of Control.Monad.Reader?
02:55:03 <dons> vegai, I hope so!
02:58:26 <dcoutts> dons, does it work with ghc 6.4?
02:59:50 <a5> skew: in "((a->b)->m a)->m a", "b" is in a contravariant or covariant position? it looks covariant to me
02:59:58 <dons> I think so, duncan
03:01:06 <dcoutts> dons, oh good, i'll update the ebuild and give it a go
03:04:14 <Philippa_> a5: I missed the original context, but if we're talking subtyping I would've thought b is contravariant in that - you can treat the return type as if it's more general safely, but not less general
03:04:46 <Itkovian> @seen boegel
03:04:48 <lambdabot> I haven't seen boegel.
03:05:55 <TheHunter> a5, it's in a covariant position.
03:06:26 * Philippa_ wonders if she's got her terminology backwards or is just being stupid
03:06:49 <Philippa_> oh, I read the parens wrong
03:10:28 <a5> thanks. so then "((a->b)->m a)->m a" should be more general than "((a->m b)->m a)->m a" from a type perspective right? (assuming "b->m b" exists)
03:11:43 <TheHunter> @type (.(.(return.))
03:11:48 <lambdabot> bzzt
03:11:48 <TheHunter> @type (.(.(return.)))
03:11:50 <lambdabot> (.(.(return.))) :: forall (m :: * -> *) b a c c1.
03:11:50 <lambdabot>                    (Monad m) =>
03:11:50 <lambdabot>                    (((a -> b) -> c) -> c1) -> ((a -> m b) -> c)
03:11:50 <lambdabot> -> c1
03:12:09 <Philippa_> a5: in the context of what kind of type system, with what kind of assumptions?
03:12:24 <Philippa_> ordinarily, a 'b' is not an 'm b'.
03:16:37 <a5> Philippa_: this was a conversation about continuation monads. i was saying, why doesn't callCC have the type callCC'::((a->b)->m a)->m a
03:17:10 <a5> i thought that was more general than callCC::((a->m b)->m a)->m a (although i thought so for the wrong reason)
03:17:22 <a5> but skew said it wasn't more general
03:17:42 <TheHunter> hmm,
03:17:57 <TheHunter> @type runContT . fmap return . ContT
03:17:58 <lambdabot> bzzt
03:18:12 <TheHunter> @type Control.Monad.Cont.runContT . fmap return . Control.Monad.ContT
03:18:14 <lambdabot> bzzt
03:18:18 <TheHunter> @type Control.Monad.Cont.runContT . fmap return . Control.Monad.Con.ContT
03:18:20 <lambdabot> bzzt
03:18:20 <TheHunter> @type Control.Monad.Cont.runContT . fmap return . Control.Monad.Cont.ContT
03:18:22 <lambdabot> Control.Monad.Cont.runContT . fmap return . Control.Monad.Cont.
03:18:22 <lambdabot> ContT :: forall (m :: *
03:18:22 <lambdabot>  
03:18:22 <lambdabot> -> *)
03:18:22 <lambdabot>  
03:18:22 <lambdabot> a
03:18:24 <lambdabot>  
03:18:26 <lambdabot> [15 @more lines]
03:18:31 <TheHunter> d'oh.
03:18:51 <dons> hmm.
03:19:23 <dons> that :t pretty printer could do with some tweaking
03:19:41 <TheHunter> dons, the good news is that the problem will probably go away in 6.4.1
03:19:42 <dons> (in ghci, that is, or we could reparse the output perhaps)
03:19:52 <TheHunter> Prelude> :t Control.Monad.Cont.runContT . fmap return . Control.Monad.Cont.ContT
03:19:52 <TheHunter> Control.Monad.Cont.runContT . fmap return . Control.Monad.Cont.ContT :: forall (m :: * -> *) a (m1 :: * -> *) r.
03:19:52 <TheHunter> (Functor (Control.Monad.Cont.ContT r m1), Monad m) =>
03:19:52 <TheHunter> ((a -> m1 r) -> m1 r) -> (m a -> m1 r) -> m1 r
03:19:56 <dons> ah!
03:20:02 <TheHunter> from cvs
03:20:23 <dons> there's enough complaining type hackers out there, I guess.
03:20:36 <dons> well now, I have cvs on lambdabot's box..
03:20:58 <skew> a5: check the section on subtyping in TaPL
03:21:16 <a5> skew: i've done that
03:21:36 <skew> I thought that should explain everything
03:21:37 <TheHunter> s/fmap return/fmap (return .)/eg
03:22:03 <a5> if you generalize something in a covariant position, you get a more general type, right?
03:22:43 <skew> It's supposed to vary in the same way
03:23:17 <a5> TheHunter: what's this? C r a -> C r (m a)?
03:24:18 <TheHunter> if fmap return :: C r a -> C r (m a), then C r is a covariant functor.
03:24:50 <a5> skew: so why isn't "((a->b)->m a)->m a" more general than "((a->m b)->m a)->m a"
03:25:15 <skew> Oh, maybe I'm horribly confused and Philippa said the right thing
03:26:00 <skew> Just a minute and I'll be back to this
03:27:41 <skew> Okay, so ((a -> b) -> m a) -> m a is a more general type than ((a -> m b) -> m a) -> m a, in the sense that you can do more things with a callCC of the first type
03:28:50 <skew> Okay, that's enough of this. I'm not going to talk about ordering any more
03:29:00 <a5> but in the sense that 'return' embeds 'b' values in an 'm b' value, 'm b' is more general, is that it?
03:29:41 <skew> The problem is the free theorems
03:29:54 <skew> say your code gets a function of type (a -> b), what can it do with it?
03:30:13 <skew> Haskell doesn't have continuations, so pure Haskell code can't do continuation things
03:30:49 <skew> continuations are coming from the monad, so you need an m x value to do continuation things
03:32:26 <a5> i think the problem isn't that you can't get from one type to the other, it's that there's no way of doing so that has the correct behavior (at least not without getting internal)
03:32:54 <skew> the only values you can get from the (a -> b) is a b that you know nothing about
03:33:18 <skew> and the only way to make a monad value from an arbitrary value is return, which only makes monad values that don't have any continuation effects
03:34:20 <skew> so if you get a "continuation" of type (a -> b) for an unknown b, you can't actually use it to invoke a continuation
03:34:46 <a5> right, "which only makes ... effects" is a nice way of putting it.
03:34:51 <a5> however, what if a function (a->r)->(a->b->r) were added?
03:35:01 <a5> or some variant thereof
03:35:21 <skew> The ordering stuff I was talking about was your code. callCC' :: ((a->b)->m a)->m a is more general than callCC :: ((a->m b)->m a)->m a
03:35:51 <a5> that's what i thought i said...
03:37:23 <TheHunter> maybe the lack of explicit foralls is confusing you forall b. ((a->b)->m a)->m a is more general than forall b. ((a->m b)->m a)->m a, but when b is bound to some fixed type, this is no longer true.
03:38:24 <a5> i see
03:38:47 <TheHunter> and if you then assume that b is a subtype(?) of m b, it's the other way round.
03:39:12 <skew> I'm confusing different things
03:39:37 <skew> there are fewer programs of the more general type
03:39:53 <skew> their implementation is more constrained because they know less about their argument
03:40:40 <skew> A more general type corresponds to a subset of programs
03:40:44 <a5> skew: now you're reducing my understanding :)
03:41:04 <skew> a is more general than Int
03:42:05 <skew> but the only value of type forall a . a is undefined, and there are lots of values, including undefined, of type Int
03:42:29 <a5> the important part is that you can get from callCC' to callCC.
03:42:47 <skew> how?
03:42:53 <a5> i mean type-wise
03:43:46 <skew> sure, just like you can get from Char to IO Char with return, but you can't make getChar with return
03:44:20 <TheHunter> "there is a function transforming callCC' to callCC" or, "if callCC' is used somewhere I can replace it by callCC somehow" ?
03:44:44 <a5> the former. but never mind, that's wrong anyway. 'b' is tied to 'm' in callCC' as you pointed out
03:45:10 <skew> If you mean the universally quantified b, then they are different bees anyway
03:46:06 <skew> consider withOutputProcedrue :: String -> ((String -> IO ()) -> IO ()) -> IO () defined by
03:48:13 <skew> withOutputProcedure filename act = do h <- openFile filename AppendMode; act (hPutStr h); hClose h
03:49:29 <skew> sure, withOutputProcedure :: String -> ((String -> b) -> IO ()) -> IO () would be a more general type, but you can't get the same behaviour
03:49:52 <skew> well, maybe you can cheat with unsafe stuff
03:50:52 <skew> "what pure function can we pass that will write to the file?" is the same question as "what pure function can we pass that will invoke the saved continuation?"
03:52:20 <a5> well in this case that pure function invokes the saved continuation, the problem is that it returns from the invocation as well. and if the value is ignored then nothing has been done
03:52:43 <a5> or is this wrong?
03:53:10 <skew> I think I was confused about foralls a bit too, because I'm pretty sure that a higher rank type like (forall b . ((a -> b) -> m a)) -> m a changes the story about b vs. m b
03:53:30 <skew> a5: I said it's the same question
03:53:45 <skew> "how can I pass them a pure function that will reach out and do stuff in the monad?"
03:54:25 <skew> and the answer is that you can't, except you can sort of cheat with IO because of unsafePerformIO and such
03:59:47 <a5> so T is contravariant in "forall a . T"?
04:00:01 <skew> I don't know, check pierce
04:01:45 <skew> I think that's right, though.
04:02:22 <a5> i don't think Pierce says...
04:02:30 <TheHunter> it's definitely not contravariant.
04:02:34 <skew> If T is a more general type than S, then a forall a . T can be used anywhere a forall a . S is needed
04:03:04 <skew> There should be a chapter on mixing universals and subtyping
04:03:11 <Philippa_> there is
04:05:15 <skew> I've apparently decided that covarient == contravarient, so don't ask me that sort of stuff until I've got some sleep
04:06:26 <TheHunter> a5, i don't think your question is meaningful.
04:07:13 <TheHunter> you can speak about type variables occuring at covariant and contravariant argument positions.
04:08:38 <a5> not just variables, types as well...?
04:10:19 <a5> skew: i see the chapters in Pierce now
04:10:24 <a5> "bounded quantification"
04:10:54 <a5> p. 395 it seems that "forall a . b" -> "a" is in a contravariant spot, "b" in a covariant...
04:11:07 <a5> that makes more sense. the "forall" is just like a lambda
04:11:15 <skew> how about unbounded qunatification, I think that comes later
04:13:35 <a5> don't see "unbounded" in index or TOC
04:13:38 <musasabi> you could have a pure function which returns [IO ()]
04:14:22 <a5> musasabi: yes, well, what is a pure function anyway?
04:16:09 <a5> oh, here:
04:16:10 <a5> 5) s' <= s and t <= t' implies t->s <= t'->s';
04:16:11 <a5> 6) s <= t implies Aa s <= Aa t;
04:16:15 <skew> musasabi: getting an argument of that type doesn't do you any good when your function has the signature (a -> b) -> IO ()
04:16:19 <a5> http://www.seas.upenn.edu/~sweirich/types/archive/1995/msg00168.html
04:17:14 <Philippa_> unbounded quantification is just plain ol' System F-style quantification
04:17:18 <Philippa_> it comes first
04:17:23 <a5> there should be a function "abort :: r -> m b", then you could define callCC from callCC'
04:18:17 <skew> a5 your callCC' is something like one of the shift/reduce things
04:18:37 <a5> shift/reduce?
04:18:48 <skew> Oh, I mean shift/reset
04:19:13 <musasabi> true.
04:20:13 <skew> It's sort of like call/cc, except you mark some level with "shift", and then somehow (maybe at the reset?) you get access to the function that's like the part of the continuation that takes you from the "reset" out to the "shift"
04:20:21 <skew> I may be switching shift and reset in the description
04:20:36 <skew> Did you look at SPJ's paper on monads and continuations?"
04:21:52 <TheHunter> shift :: ((a -> r) -> Cont r r) -> Cont r a
04:22:06 <TheHunter> callCC' :: ((a -> b) -> m a) -> m a
04:22:41 <skew> I thought shift was the delimiter?
04:22:54 <TheHunter> reset is the delimiter
04:23:04 <TheHunter> eg. reset :: Cont r r -> r
04:23:47 <a5> skew: no, will do
04:24:00 <skew> TheHunter: why does shift have that type Cont r r?
04:24:26 <skew> what happens if that code returns a value of type r rather than invoking the continuation it was passed
04:24:26 <TheHunter> shift is basically the same as Cont.
04:24:54 <TheHunter> that's the value reset returns, then.
04:25:45 <skew> a5: it's not entirely relevant, it's just that your thing would be like one of the varients that doesn't remove the current continuation at either capture or invoke time
04:26:33 <skew> I'm not sure if thats -F- or +F+ in their system because I can't keep polarity straight right now, but they talk about it
04:26:40 <skew> also, the runCont would be your delimiter
04:26:44 <a5> "A Monadic Framework for Subcontinuations"?
04:26:48 <skew> that's it
04:27:33 <skew> you would need to use runCont and the definition of Cont to tie together a larger computation with continuations
04:28:31 <a5> these shift/reset things are in the paper?
04:29:57 <skew> the paper talks about a lot of confusing things, but they mention shift/reset
04:30:06 <a5> so does the bare Cont monad - not ContT - have any value? can you use it for novel computation styles or something?
04:30:20 <skew> I think it's one of the degenerate cases of their framework
04:30:42 <a5> i like my "abort" function
04:30:50 <skew> a5: it's useful if you need continuations for some reason and don't like writing your code in CPS style
04:31:16 <skew> I don't think it's really all that useful for pure code, though
04:32:06 <a5> so on an entirely different note, my computer spent an hour or so compiling ghc and when i run ghci it says "ghc-6.5: not built for interactive use"
04:32:16 <a5> how do i configure it to build ghci?
04:32:28 * TFK hugs Hugs
04:42:55 <a5> anyway i was asking about continuations because i want to add them to this parser i wrote. but it's based on Claessen's parallel parsing processes paper, and everything uses continuations already
04:43:32 <a5> so i figured if i understood it better i'd be able to add a term that returns the current continuation
04:43:53 <a5> (adding it to the simplified term representation)
04:44:06 <skew> okay, so just about nothing I told you was relevant, I think
04:52:18 <Bo> hey Oejet :)
04:52:45 <a5> well i had to get my bearings
04:52:53 <TFK> Oejet, "наша" ;-)
04:59:38 <Oejet> Hej, Bo.
05:00:47 <Oejet> TFK: Why not -y?
05:34:55 <shapr> a5: I need new ones..
05:36:30 <Lemmih> Greetings, JaffaCake.
05:36:39 <shapr> Good morning JaffaCake!
05:36:41 <JaffaCake> afternoon
05:37:05 * shapr throws lambdas
05:51:42 <Lemmih> A latency of 1-2sec is so annoying when installing lots of cabal packages.
05:54:35 <shapr> JaffaCake: For months I assumed alexj had English as a second language. I was surprised to discover it's his native language.
05:55:13 <JaffaCake> hmmm, I thought the same
05:55:41 <shapr> I think he said he's from New York.
05:56:23 <TheHunter> shapr, about tmr, is tmr3 going to be wikipublishing, too, or will that be reconsidered after issue2?
05:56:51 <shapr> TheHunter: At the moment wikipublishing seems to have more advantages, but I want to hear from the authors.
05:57:28 <TheHunter> my humble opinion: latex just looks so much better, and is easier to edit.
05:58:07 <shapr> Truly, I think editing in a textfield is, um, suboptimal.
05:58:30 <Philippa_> yeah. A good offline previewer would help
05:58:38 <Philippa_> that's the only thing that makes it actually harder IMO
05:58:57 <shapr> But on the other hand, the ability to see how everyone else is doing is motivational (for me at least).
05:59:22 <shapr> And all the authors can proofread the other articles immediately.
05:59:22 <TheHunter> yeah, i installed a firefox extension for editing forms, but it's still much more complicated.
05:59:26 <TFK> Oejet, I'm not sure. However - "наша учительница хорошая" vs. "нашу учительницу зовут Наташа"
05:59:29 <Philippa_> it's a lot easier to get feedback on the wiki
05:59:50 <shapr> TheHunter: You do have inline LaTeX on the Wiki
06:00:10 <TheHunter> shapr, otoh, the wikipages could just be the latex source.
06:00:19 <TheHunter> s/be/contain/
06:00:24 <shapr> That's an excellent point
06:00:48 <shapr> Someone would just need to whip up a plugin to do that.
06:01:19 <Philippa_> I'd prefer it if that wasn't the case on all pages myself
06:01:35 <Philippa_> though I wouldn't complain at somebody for just inlining their entire (written in LaTeX) article
06:02:45 <shapr> Still, my goal for TMR is not so much about looking pretty, but more about making information easily accessible to people learning Haskell for the first time, or just extending their Haskell knowledge.
06:02:59 <TheHunter> plus, we have nice style guidelines for the latex stuff.
06:03:04 <shapr> So being able to select a bunch of text on a wikipage and pasting it into an editor buffer is an advantage.
06:03:33 <TheHunter> that's a good point.
06:04:37 <TheHunter> i wonder if it would be practical to automatically convert a wiki text into latex using some regexes.
06:04:44 <shapr> On the other hand, pretty LaTeX with 'click here to download the sources' would have both advantages.
06:04:51 <shapr> TheHunter: that would be *cool*
06:05:49 <tuomov> planetmath.org uses a latex-like wiki..
06:05:52 <shapr> Admittedly, click to download isn't as simple as select'n'paste, but I doubt the single extra step is significant. And you don't have to worry about whitespace issues.
06:06:22 <shapr> That is, click to download won't have whitespace issues, s'n'paste might.
06:08:34 <xerox> Good afternoon :)
06:09:47 <shapr> hiya xerox
06:10:05 <TheHunter> arg! so tmr2 is to be out on sunday.
06:10:57 <Oejet> shapr: The PDF format enables both pretty typesetting and cut and paste.
06:11:39 <Philippa_> acrobat viewer doesn't do cut and paste properly
06:11:43 <Philippa_> that's most people's viewer
06:12:30 * CosmicRay provides an update on the fptools cvs -> darcs conversion
06:12:39 * shapr waits impatiently for the update
06:12:46 <CosmicRay> at this time, 6237 changesets have been converted, representing approximately 1/3 of the repository
06:13:03 <Oejet> Philippa_: Heh, I didn't know that, because I mostly use Xpdf myself.
06:13:30 <CosmicRay> that much has been converted in the past 15 hours
06:13:32 <TheHunter> how are people supposed to do their bibliography on the wiki?
06:13:38 <CosmicRay> so I figure it will be a few days yet before the real thing is ready
06:13:52 <TheHunter> Oejet, xpdf has select'n'paste?
06:13:54 * TheHunter tries.
06:14:32 <TheHunter> yay! i didn't know that.
06:20:57 * Lemmih ponders how to get GHC to pick a package from the local package.conf instead of the global package.conf.
06:22:06 <CosmicRay> anyway, now that I know which Cambridge Simon is at, I understand why he's setting default papersizes to that evil A4 in fptools :-)
06:22:52 <TheHunter> hmm, the translation latex --> wiki is probably easier.
06:24:29 <TheHunter> shapr, anyway, if i find the time, i'll try to hack up some evil script for wiki --> latex, so that we can release both.
06:26:21 <shapr> TheHunter: That would be spiffy, though for TMR2 I'd rather have your 'Implicitly Fun' article.
06:26:28 <shapr> I think that'll be a real blast :-)
06:28:03 <JohnMeacham> Say what you will about the metric system, but metric paper sizes are great. Now if I can just get california to switch...
06:28:26 * shapr prefers to use paper size 'one kilo'
06:29:26 <TheHunter> shapr, no way i'm going to be able to finish the article till sunday.
06:29:37 <shapr> TheHunter: ok, no worries.
06:29:59 <shapr> I hope I can finish my TH article...
06:37:09 * Lemmih has been bitten by the Cabal mis-versioning /-:
06:38:00 <Lemmih> shapr: I need some divine intervention on scannedinavian.org.
06:43:11 <shapr> tell me about it
06:53:00 <shapr> Lemmih: what intervention?
06:54:21 <Lemmih> shapr: Install Cabal 0.6.1 instead of Cabal 1.0
07:03:32 <TFK> Ah, mldonkey is written in O'Caml.
07:06:20 <Oejet> TFK: It _is_ наша учителница хорошая.
07:07:04 <TFK> Oejet, am I good or what? :D
07:10:45 <Oejet> TFK: Вы хороший.
07:11:37 <xerox> shapr, what was your iRiver that supports linux? IFP999?
07:12:25 <TFK> Спасибо, но со мной можно и на "ты".
07:15:29 <shapr> xerox: IFP-899T, F meaning Flash, I think.
07:15:55 <shapr> xerox: I got the 1GB flash because I seriously doubt a harddrive version will survive a unicycle crash.
07:16:13 <xerox> Hmm, I do really need a portable music player, do you suggest it?
07:17:08 <xerox> ...and Linux compatibility is a must.
07:18:34 <vidvandre> http://www.digitalnetworksna.com/shop/_templates/item_main_Rio.asp?model=261
07:19:13 <Oejet> TFK: Ok. :-)
07:19:35 <TFK> ^_^
07:20:19 <xerox> vidvandre, it probably cost much more than the flash ones..
07:21:03 <shapr> My 1gb iriver was about 200 euro (I don't know the current conversion from kronor to euro)
07:21:49 <shapr> It has two flavors of firmware, I installed the UMS flavor that gets it to act like a USB mass storage device, and now I just plug it in, mount it, and copy ogg music onto it.
07:24:04 <CosmicRay> JaffaCake: what would you say to just blowing away the two PRIVATE directories in the fptools repo?
07:24:30 <JaffaCake> no problem
07:24:39 <CosmicRay> oh, sweet.
07:24:42 <JaffaCake> we can save 'em away
07:25:29 <basti_> back
07:25:32 <basti_> shapr: are you there?
07:25:39 <vidvandre> xerox, that's true.. it doesn't look like they're selling it anymore.. it has no "buy now" button
07:26:07 <vidvandre> xerox, I also read somewhere else: "a java application is provided to transfer songs to/from the player via ethernet, there is no driver provided for Linux users to make use of the USB 2.0".. doesn't sound good to me
07:26:10 <CosmicRay> JaffaCake: it would surely make life easier for people that use cvs to connect to pserver.  those unreadable directories lead to a lot of spurious errors
07:26:38 <JaffaCake> yes
07:26:56 * CosmicRay discovers a case of deadlock in tailor.py
07:27:16 <JaffaCake> so how's the conversion to darcs coming along?
07:27:44 <CosmicRay> JaffaCake: up to march 2000, about 6500 changesets converted so far
07:27:53 <CosmicRay> and tailor just hung for the firs ttime about 5 minute sago.
07:28:06 <xerox> vidvandre, oh :-(( It is a nice toy.. but no Linux driver.. argh!
07:28:10 <vidvandre> xerox, http://www.mp3players.co.uk/site/uk/rio_karma/specification/000000.html <- "not linux compatible".. what a joke.. it plays ogg vorbis and flac and it's not linux compatible. hehe
07:28:28 <xerox> Grumble, I do like it, tough...
07:31:24 * Philippa curses loudly
07:31:32 <Philippa> I just found a bug in Network.CGI
07:31:38 <Philippa> or rather, confirmed that it was one, at least AFAIC
07:31:44 <Lemmih> shapr: Can you add me to the sudo file?
07:32:15 <Philippa> it doesn't decode CRLFs to \n
07:32:28 <Philippa> when it decodes application/x-www-form-urlencoded
07:32:50 <Philippa> which can lead to all kinds of fun
07:33:36 <JohnMeacham> I have a Karma. works great from linux. I love it. so glad I got it over the iPod
07:33:50 <xerox> JohnMeacham, really?
07:34:02 * Philippa had a bug in a CGI where new lines entered into a form and fed back to the user as a new form would multiply on each iteration
07:36:47 <JaffaCake> Igloo: ping
07:36:56 <JaffaCake> @seen Igloo
07:36:57 <lambdabot> Igloo is in #haskell. Last spoke 14 hours, 19 minutes and 2 seconds
07:36:57 <lambdabot> ago.
07:37:05 <Igloo> Hello
07:37:20 <JaffaCake> I just found something that broke after your suggested -optc change
07:37:35 <Igloo> YM dcoutts' suggested change  :-)
07:37:42 <JaffaCake> ah oops
07:37:58 <JaffaCake> yes, right you are
07:38:01 * Igloo only steals credit for things that work
07:38:09 <JaffaCake> :)
07:38:35 <JaffaCake> dcoutts_: hello?
07:39:01 <nlv11757_> anyone here i can ask a question to about bringing programs in ssa form?
07:40:33 <wilx> Huh, what are you optimizing?
07:41:23 <nlv11757_> my analysis can benefit from a program being in ssa, im trying to reuse a module that brings program into ssa form...but i find the usage of this module a bit odd
07:41:37 <nlv11757_> possibly because i dont fully understand about bringing a program into ssa form
07:42:17 <JohnMeacham> There is a good paper about the coorespondence between SSA form and functional programming. jhc's GRIN is also intimatly related to SSA form.
07:42:42 <shapr> Lemmih: I don't have a sudo file. Snowblind is my business server more than it's a Haskell community resource.
07:42:58 <nlv11757_> in this module theres only a function to transform a function to ssa form....
07:43:03 <nlv11757_> but why would that suffice....
07:43:19 <nlv11757_> because you always have a main function as entry point?
07:43:43 <JohnMeacham> http://citeseer.ist.psu.edu/appel98ssa.html
07:44:05 <nlv11757_> ty john
07:44:31 <shapr> Lemmih: I mean, I do have a sudo file, but I'm the only one in the file.
07:44:48 <Lemmih> Oki.
07:46:21 * CosmicRay sends his patch to the cvsync author and restarts the update process.
07:47:22 <CosmicRay> simonPJ had a commit back in 2000 that modified some 200 files and had an 8-page log message
07:47:34 <CosmicRay> tailor was trying to pipe everything to darcs before reading a reply back
07:47:39 <shapr> yow
07:47:40 <CosmicRay> normally that worked due to buffering
07:47:45 <CosmicRay> but it deadlocked this time
07:47:50 <basti_> shapr: !
07:47:56 <shapr> basti_: yes!
07:48:00 <CosmicRay> I set it up to use threads, and it seems happier now.
07:48:05 <basti_> shapr: did you say anything about latex support in the tmr wiki?
07:48:09 <basti_> or was that a hallucination?
07:48:42 <shapr> Check out the FormatDemo
07:49:09 <basti_> ahh.
07:49:29 <shapr> Lemmih: Shall I just grab the latest cabal from the repo and install it systemwide?
07:49:41 <basti_> hmm...
07:49:48 <basti_> let's see.
07:50:31 <basti_> probably I'll have to export the score as graphics.
07:50:48 <Lemmih> shapr: Nope, I got the modified Cabal repo at ~/lemmih/cabal/
07:51:15 <shapr> What's the difference?
07:51:15 <CosmicRay> anyway, only 15749 changesets to go :-)
07:51:22 <nlv11757_> JohnMeacham, do you have an idea, why there's only a 'function definition to ssa' function.....surely thats not enough to bring a program in ssa form....
07:52:10 <basti_> shapr: the score is not pure latex... lilypond is an ugly tex/latex/etc. hack
07:52:17 <shapr> Oboy
07:52:25 <basti_> it imports some files etc.
07:52:33 <basti_> i think i won't bother.
07:56:18 <basti_> whats the tmr wiki convention for writing types in text? I would use monospace, i didn't find yet how to do monospace though
07:56:30 <shapr> {{{monospace}}}
07:56:34 <basti_> ah
07:57:26 * Igloo gets a problem that allows you to use any language except perl, and wonders how easy it would be to get perl to accept reasonable Haskell source
07:57:48 <Igloo> Not easy enough, I suspect  :-(
07:58:02 <shapr> The guys on #perl6 recently added inline Haskell support.
07:58:11 <Igloo> That's cheating
07:58:45 <shapr> What's the details of the problem?
07:59:04 <Igloo> Write a simple compiler
07:59:22 <shapr> And don't use perl to do it?
07:59:26 <Igloo> Yup
08:00:03 <nlv11757_> writing a simple compiler and not being able to use perl is a problem?
08:00:09 <shapr> Yeah, I don't understand.
08:00:15 <JohnMeacham> nlv11757_: it is possible to do the transformation locally depending on the formulation of your input and output terms.
08:01:26 <Igloo> nlv11757_: If the problem specifies that you can't use perl, then clearly one of the goals should be to produce something that works in perl anyway
08:02:13 <nlv11757_> JohnMeacham, maybe this guy just dont want to grade perl apps
08:02:18 <nlv11757_> which i cant blame him for
08:02:27 <nlv11757_> sorry the JohnMeacham part wasnt supposed to be there
08:02:34 <nlv11757_> i was typing two responses at once
08:03:28 <nlv11757_> JohnMeacham, i would expect a function that takes a control flow graph and then spits out the ssa form.
08:06:25 <JohnMeacham> I could imagine a function that takes an input function and spits out a bunch of SSA nodes. assuming no global variables.
08:06:52 <nlv11757_> it transforms a C application to ssa
08:08:31 <JohnMeacham> Perhaps it just deals with a sort of simplified SSA where it renames locals but doesn't worry about globals or arguments or goto statements.
08:10:24 <dcoutts_> JaffaCake, you rang?
08:10:26 <nlv11757_> yeah, cause in that case, i think the reason it takes a function definition is that it just takes the main function
08:10:55 <nlv11757_> but in the setting of a C application,....that simplified ssa would be pretty useless i guess
08:11:05 <nlv11757_> ignoring globals and all
08:11:54 <dcoutts_> JaffaCake, so what broke then ?
08:12:45 <JaffaCake> see the commit message - basically passing -g to the .c->.s phase resulted in a broken object file
08:13:06 <JaffaCake> I've been tracking this down for an hour or two :(
08:13:18 <dcoutts_> sorry about that :-(
08:13:25 <JaffaCake> not your fault!
08:13:32 <JaffaCake> probably a bug in gcc or binutils
08:13:33 <dcoutts_> does this happen if we get gcc to go .c -> .o directly I wonder?
08:14:02 <JaffaCake> certainly that would be fine... but it's more than a 1-line change to GHC
08:14:02 <dcoutts_> oh, it's in the .c -> .s phase
08:14:22 <JaffaCake> sorry, I meant .s->.o
08:14:33 <dcoutts_> I was about to be confused
08:14:48 * JaffaCake hopes excessive confusion is averted
08:14:53 <dcoutts_> :-)
08:15:03 * shapr excessively confuses the nearest IRC denizen
08:15:45 <dcoutts_> so the point is, some gcc options should not be passed duing a .s -> .o phase and we can never know which ones
08:16:17 <dcoutts_> however, gcc does know which ones are appropriate and does the right thing when told to do the whole thing .c > .o
08:16:39 <dcoutts_> then the Q is: is it worth the change for this corner case?
08:17:47 <dcoutts_> If've we're encouraging Haskell build systems to compile .c files using ghc then perhaps so, otherwise we tell people to use gcc -I $(ghc --print-libdir)
08:18:06 <dcoutts_> does cabal deal with packages that use .c files? what does it do?
08:18:22 <JaffaCake> I'm leaning towards the other solution now: use -opta if you need it
08:18:36 * shapr wishes for -optopia
08:19:02 <JaffaCake> I don't know whether Cabal uses ghc to compile C files or not..
08:19:11 <dcoutts_> and change the ghc driver to invoke gcc to do .c -> .o in one go you mean?
08:19:42 <JaffaCake> Cabal uses ghc
08:19:57 <basti_> shapr: how do i keep the wiki from thinking something written in CamelCase is a reference to another wiki page?
08:20:00 <shapr> I have a completely random Cabal question, what about slurping in code from Maak or Nix, the make / package systems in development at uu.nl ?
08:20:02 <dcoutts_> JaffaCake, if cabal uses ghc for these things it would be a good reason to make ghc do the expected thing
08:20:28 <shapr> basti_: there's the 0ldsk00l cheesy hack of Foo''''''Bar but there's something simpler for MoinMoin that I forget.
08:20:39 <basti_> ugh
08:20:39 <basti_> -g-
08:20:43 <shapr> hoi martijn923
08:21:59 <JaffaCake> dcoutts_: hmm, your argument is that ghc -c -optc<blah> foo.c should behave just like gcc -c <blah> foo.c, right?
08:22:00 <martijn923> hoi
08:22:24 <JaffaCake> apart from the extra -I options that ghc throws in for you
08:22:36 <JaffaCake> the argument has some merit, I grant you
08:22:48 <shapr> martijn923: What do you think of CTM? Is it worth buying?
08:22:49 <dcoutts_> JaffaCake, so what's the rule?  ghc $(addprefix -optc,$(CFLAGS)) foo.c = $(gcc-that-ghc-was-configured-to-use) $(CFLAGS) -I $(ghc --print-libdir)/include
08:22:57 <martijn923> shapr: you speak dutch? (i think 'hoi' is only dutch?)
08:23:10 <shapr> martijn923: ik begrijp het niet!
08:23:32 <shapr> No, only enough dutch to buy beer, get a taxi, that sort of stuff.
08:23:34 <JaffaCake> dcoutts_: not quite that simple, you can pass -package flags to ghc too, and it'll inject the -I options from those packages
08:23:54 <martijn923> hehe ;)
08:24:06 <shapr> I can vaguely understand research papers written in Dutch, but I get confused about the from/to/etc details.
08:24:17 <dcoutts_> JaffaCake, sure (though for the rule I have there were no ghc options, only gcc passthru options)
08:24:33 <JaffaCake> ok
08:25:15 <JaffaCake> then the rule is probably right
08:25:19 <martijn923> my progress in CTM is going very slowly, currently at section 4.1
08:25:20 <dcoutts_> and I'm right in thinging that it invokes whichever version of gcc ghc was configured with?
08:25:30 <JaffaCake> yep
08:25:45 <JaffaCake> override with -pgmc if you like
08:25:52 <dcoutts_> right
08:26:06 <martijn923> shapr: but I'm reading the draft PDF printed at university, did not buy the book
08:26:38 <shapr> I wonder if I have a copy of the draft...
08:26:49 <shapr> I'm tempted to buy the whole thing, I've heard lots of good stuff about it.
08:26:58 <dcoutts_> so it will work like that, then it probably is the right thing to encourse packagers / build systems to use since it will pick the version of gcc correctly (especially an issue on win32 I think)
08:27:05 <shapr> And I am sorely lacking in the area of logic/constraint programming.
08:27:41 <martijn923> shapr: may I ask why you linked me to CTM? (LtU -> my homepage?)
08:27:42 <dcoutts_> JaffaCake, I've got to go for a lecture, I'll write this up in a bug report :-)
08:27:53 <shapr> martijn923: yup.
08:28:22 <martijn923> wow, you're a detective :o
08:28:34 <shapr> I saw your posts on LtU, checked your user page, and read your homepage.
08:28:38 <JaffaCake> dcoutts_: ok.  I'm just looking at DriverPipeline - it might be possible to hack in a direct .c->.o pass
08:29:21 <nlv11757_> not understanding something is pissing me off
08:31:59 <martijn923> shapr: send me an e-mail if you'd like to have the draft PDF (I think that's legal). I don't know if much has changed though.
08:32:06 <shapr> ok
08:32:47 <martijn923> I assume you'll have no trouble finding my e-mail address ;)
08:37:14 <shapr> Hei Esa!
08:37:22 <shapr> Want to write for TMR2?
08:37:26 <esap> Hei shapr!
08:38:27 <basti_> shapr: article is now up, graphics will follow in a minute
08:38:33 <esap> shapr: I wrote some more during weekend, but I need to wrap it up to make it coherent. I'll probably have to just take out all the cruft.
08:39:16 <shapr> basti_: spiffy!
08:40:59 * shapr zipWith ($) [shapr] [unicycle]
08:42:13 <xerox> zipWith ($) [shapr] [unicycle] :: Fun
08:42:25 <Oejet> xerox: :-P
08:43:33 <basti_> why dont you just write (shapr unicycle)
08:43:52 <basti_> its not that there are many objects of type shapr.
08:45:13 <kosmikus> basti_: obviously, Fun is a list type
08:46:04 <basti_> http://www.haskell.org/tmrwiki/Haskore?action=show < are the graphics there broken in your browsers too?
08:47:09 <vincenz> you know, I've been thinking about it...without laziness, monads dno't work so well...
08:47:21 <vincenz> cause you can do IO and still get back a non IO monad
08:48:25 <basti_> anyone? =)
08:48:46 <xerox> basti_, I think they're not so bad.  Maybe.. too spaced!
08:48:57 <basti_> thats what i was referring to i think.
08:49:07 <basti_> why does that happen?
08:49:36 <earthy> the graphics are very much black with one note each
08:49:49 <basti_> uhhh
08:50:03 <basti_> the graphics ARE that large i see
08:50:08 <earthy> sometimes 2 notes
08:50:11 <basti_> that was not what i was trying to do
08:50:11 <xerox> Ah!
08:50:13 <earthy> yeah, they are
08:50:22 <basti_> now how did i do that lol
08:50:40 <vincenz> I've briefly looked at it...
08:50:51 <basti_> thats bizarre... on my hd, they have the size i want them to be
08:50:58 <vincenz> what about a halfnote...that also has a parallel quarternote?
08:51:15 <basti_> vincenz: yes what about it?
08:51:16 <vincenz> parallel to it's second leg
08:51:20 <vincenz> how would you od that?
08:51:35 <basti_> in haskore? ((quarter1 :+: quarter2) :=: half)
08:51:54 <basti_> haskore is NOT about note typesetting.
08:51:56 <vincenz> I dno't want a quarter1
08:52:24 <basti_> ((qnr :+: quarter) :=: half) like that?
08:52:30 <vincenz> qnr is
08:52:33 <vincenz> ?
08:52:35 <basti_> quater note rest
08:52:42 <vincenz> ooh, nice
08:53:03 <basti_> but, does anyone have an explanation for the graphics exploding?
08:53:12 <basti_> the .gifs themselves are the right size.
08:53:12 <Arsilan> HVA så david
08:53:25 <Arsilan> hej basti
08:53:28 <basti_> hi Arsilan
08:53:43 <Arsilan> nice to se you again
08:53:45 <Arsilan> basti
08:54:02 <basti_> the pleasure is all mine
08:57:17 <basti_> does that wiki manipulate graphics???
08:57:54 <Arsilan> hej
08:58:05 <kowey> in case this interests anybody,
08:58:16 <kowey> i've written a little script to produce a graphical representation of your dependencies
08:58:23 <kowey> http://www.loria.fr/~kow/ghcdep2dot.py
08:58:52 <basti_> no it doesnt
08:59:16 <basti_> my gif is a SHIT format =)
09:00:29 <xerox> Maybe that's due to the fact that <img>'s are inside <p>'s... alogn with some CSS rubbish?
09:00:42 <basti_> no
09:00:51 <basti_> its transparency & gif's idea of the world
09:01:04 <basti_> gif has a possibility of specifying "nothing" around the actual image
09:01:05 <xerox> Metaphysical
09:01:14 <basti_> which happened here due to import, apparently
09:02:42 <basti_> "crop automatically" in gimp helps
09:07:06 <basti_> how would one center something in the wiki?
09:09:53 <CosmicRay> t's kinda fun to watch fptools commit messages slowly scroll by
09:09:59 <CosmicRay> I just watched parsec get imported :-)
09:12:39 <wilx> o_O
09:13:43 <CosmicRay> what does "wibble" mean in fptools commit messages?
09:14:11 <integral> @jargon wibble
09:14:13 <lambdabot> *** "wibble" jargon "Jargon File (4.3.1, 29 Jun 2001)"
09:14:13 <lambdabot> wibble [UK, perh. originally from the first "Roger Irrelevant"
09:14:13 <lambdabot> strip in
09:14:13 <lambdabot>    "VIZ" comics, spread via "Your Sinclair magazine in the 1980s
09:14:13 <lambdabot> and early
09:14:14 <lambdabot>    1990s"] 1. n.,v. Commonly used to describe chatter, content-
09:14:16 <lambdabot> free remarks
09:14:18 <lambdabot> [13 @more lines]
09:16:19 <nlv11757_> @more
09:16:20 <lambdabot>    or other essentially meaningless contributions to threads in
09:16:20 <lambdabot> newsgroups.
09:16:20 <lambdabot>    "Oh, rspence is wibbling again". 2. [UK IRC] An explicit on-
09:16:20 <lambdabot> line no-op
09:16:20 <lambdabot>    equivalent to {humma}. 3. One of the preferred {metasyntactic
09:16:20 <lambdabot> variable}s
09:16:22 <lambdabot>    in the UK, forming a series with `wobble', `wubble', and `flob'
09:16:24 <lambdabot> [6 @more lines]
09:16:28 <nlv11757_> @more
09:16:30 <lambdabot> (attributed to the hilarious historical comedy "Blackadder").
09:16:30 <lambdabot> 4. A
09:16:30 <lambdabot>    pronounciation of the letters "www", as seen in URLs; i.e.,
09:16:33 <lambdabot> www.{foo}.com may be pronounced "wibble dot foo dot com" (compare
09:16:34 <lambdabot> {dub
09:16:36 <lambdabot>    dub dub}).
09:17:10 <Lor> "web" would have been a much, much, _much_ better choice for the default name of a www server.
09:21:48 * nlv11757_ decides to read some more on ssa before trying to use some ocaml module supposedly generating a ssa C program that is not documented.
09:22:21 <vincenz> A question about monads
09:22:36 <vincenz> is the fact that when once you've actualyl done IO, you msut always be in the IO monad a fundamental part of it?
09:22:47 <Lor> Yes.
09:22:57 <CosmicRay> a fundamental part of the IO monad.
09:23:01 <CosmicRay> other monads aren't necessarily like that.
09:23:06 <nlv11757_> only way to enforce a monad is within a do...but escaping a do is not possible without stamping the monad on it again
09:23:20 <xerox> It is a one-way monad.
09:23:22 <nlv11757_> im discarding unsafeIO ofcourse
09:23:29 <tromp> zer iz no ezcape!
09:23:29 <CosmicRay> nlv11757_: some monads aren't opaque
09:23:38 <vincenz> xerox: yes but if a language is not lazy....you can escape it
09:23:41 <CosmicRay> nlv11757_: for instance, there's the Error monad, which just returns an Either String a value
09:23:47 <vincenz> let x = doIO in ()
09:23:47 <nlv11757_> CosmicRay, they have "m a -> a"
09:24:20 <xerox> CosmicRay, what do you mean by "opaque"?
09:24:28 <Lor> I think Id is the only monad that provides a _total_ function of type m a -> a.
09:24:42 <CosmicRay> xerox: a data type where you can't access its internal data
09:25:01 <CosmicRay> xerox: for instance, if I said data Maybe a = Nothing | Just a, and exported only Maybe
09:25:06 <xerox> Does that mean you can't pattern-match IO ?
09:25:11 <CosmicRay> you would have no way to construct or destruct Maybe values
09:25:14 <nlv11757_> i.e. not transparent so you can have a looksy inside from outside the box
09:25:23 <CosmicRay> but if I export Maybe(..), then you could construct and destruct Maybe values.
09:25:37 <CosmicRay> IO is opaque.  You can pass 'em around but you can't twiddle inside 'em.
09:26:24 <nlv11757_> inside a do you can
09:26:27 <nlv11757_> right?
09:26:28 <Lor> newtype IO a = IO (World -> (a, World))
09:27:53 <CosmicRay> no, even there you don't know the details of the IO
09:28:08 <CosmicRay> maybe they said data IO a = IO World Int64 a
09:28:11 <CosmicRay> all you see is the a
09:28:33 <CosmicRay> and that you can only get at in the IO monad
09:29:35 <nlv11757_> im getting my mind off things, cu later
09:29:40 <tall_white_man> hi
09:29:56 <CosmicRay> hello
09:33:24 <xerox> How much is a " in metrics?
09:33:35 <Lor> 2.54 cm
09:33:47 <CosmicRay> that is an inch, btw.
09:34:31 <vincenz> so what about the case
09:34:37 <xerox> Thanks much
09:34:43 <vincenz> let x = doIO in ()
09:35:04 <SyntaxNinja> 'morning
09:35:11 <vincenz> if the language is not lazy
09:36:48 <tall_white_man> so is there a spreadsheet for windows in haskell yet
09:38:26 <vincenz> CosmicRay: then you're no longer forced to return a type IO even when a function does IO, doesn't that destroy part of the use of monads?
09:39:59 <SyntaxNinja> vincenz: unless you use 'x', then you're not performing IO.
09:40:16 <vincenz> SyntaxNinja: For non lazy languages
09:41:44 <SyntaxNinja> vincenz: maybe I missed something. thought we were talking about getting out of the IO monad in Haskell.
09:43:16 <vincenz> no no, I was considering the use of monads in a non lazy language
09:43:22 <vincenz> whether it's possible or not
09:43:47 <vincenz> and whether the fact that when you perform IO you msut return an IO monad is part of the monad-idea or just part of haskell and being pure
09:44:20 <SyntaxNinja> vincenz: it's sorta part of any type if you think about it
09:44:40 <SyntaxNinja> the thing about IO is that there's no function like "foo:: IO -> Int"
09:44:49 <SyntaxNinja> (well, there is, but we don't talk about that)
09:45:05 <SyntaxNinja> and unless you can 'convert' one type to another, you can't change the return value of the function
09:45:26 <vincenz> oh I know
09:45:45 <vincenz> but is the fact that let x = doIO in () returns () and not IO () against monads, or just aganist being pure?
09:45:47 <SyntaxNinja> but for other monads, there are ways out.
09:46:04 <SyntaxNinja> against?
09:46:17 <Lor> vincenz, neither. You just don't perform any IO.
09:46:43 <vincenz> Lor: in a NON LAZY language
09:47:01 <Lor> You still don't perform any IO.
09:47:05 <vincenz> sure you would
09:47:11 <Lor> Not if you have an IO monad.
09:47:19 <vincenz> well...have it print
09:47:21 <vincenz> return ()
09:47:23 <vincenz> you get IO () in x
09:47:30 <Lor> If doIO is an IO action, then just evaluating it doesn't execute it.
09:47:45 <vincenz> Lor: we assuem that it's something that does {doIO; return ()}
09:48:11 <vincenz> let x = doIO >> return () in ()
09:48:13 <vincenz> there
09:48:33 <vincenz> doIO was not an action, just pseudocode
09:48:37 <Lor> Yes. Evaluating that expression doesn't perform any IO, even in a non-lazy language.
09:48:54 <Lor> If we are talking about monadic IO, that is.
09:49:09 <shrimpx> just binds stuff to x =)
09:49:11 <Lor> Monadic IO can be and has been implemented in strict languages as well.
09:49:28 <vincenz> how?
09:49:37 <shrimpx> Prelude> let x = putStrLn "hi" >> return ()
09:49:38 <shrimpx> Prelude>
09:49:42 <shrimpx> Prelude> x
09:49:43 <shrimpx> hi
09:49:49 <vincenz> shrimpx: haskell is lazy
09:49:58 <vincenz> we're assuming non lazy languages
09:49:59 <Muad_Dibler> like me.
09:50:32 <vincenz> so x pritns "hi
09:50:34 <vincenz> thereofre
09:50:36 <Lor> shrimpx, that's because the interpreter has special treatment for IO values. It implicitly runs them.
09:50:47 <shrimpx> Lor: yea..
09:50:53 <vincenz> let x = putStrLn "hi" >> return () in let a = x in ()
09:51:05 <vincenz> the point still remains,y ou can bypass the IO () due to nonlazyness
09:51:09 <vincenz> bsically toss it away
09:51:50 <Lor> No.
09:52:02 <Lor> If a strict language only provides a monadic interface to side effects, you cannot bypass it.
09:52:03 <vincenz> Lor: yes, in nonlazylangues...
09:52:22 <vincenz> Lor: look at shrimpx's example
09:52:30 <Lor> It was a non-example.
09:52:38 <vincenz> hmm
09:52:43 <shrimpx> i agree with lor
09:52:44 <shrimpx> =)
09:53:19 <vincenz> Lor: yes you can go into the monad, do it and then due to nonlazyness "forget" about the return type by sticking it into a variable you do not use in the returnvalue of the outer let ...
09:53:26 <vincenz> unless you change the way let's work
09:53:50 <Lor> No.
09:53:55 <Lor> How do you "go into the monad"?
09:53:59 <Lor> I.e. run its code?
09:54:08 <vincenz> >>
09:54:11 <Lor> No.
09:54:14 <Lor> Sorry.
09:54:20 <Lor> @type >>
09:54:25 <lambdabot> bzzt
09:54:26 <vincenz> oh
09:54:27 <Lor> How did this thing work?
09:54:28 <vincenz> go into
09:54:32 <SyntaxNinja> @type (>>)
09:54:32 <vincenz> return
09:54:34 <lambdabot> (>>) :: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m
09:54:34 <lambdabot> b
09:54:50 <shrimpx> he means that in let x = foo in (), foo will get run before being bound to x, and then the type of the whole expression won't reflect the IO
09:55:03 <vincenz> yes
09:55:07 <basti_> :-O
09:55:11 <Lor> That won't matter, since evaluating the expression won't run any IO commands.
09:55:18 <vincenz> Lor: what will then?
09:55:31 <Lor> What runs IO commands in Haskell?
09:55:42 <Lor> Just some magical thingy that calls main.
09:55:53 <SyntaxNinja> vincenz: I think it depends on how the language implements the evaluation of monads.
09:56:11 <vincenz> SyntaxNinja: yes but in a typical language... (let's take an ML variant)...
09:56:19 <vincenz> I just don't see how it would happen
09:56:25 <vincenz> I have to afk for 30 mins, gotta take the bus home
09:56:26 <SyntaxNinja> vincenz: I have no idea how or whether ML implements monadic IO. sorry.
09:56:29 * vincenz runs and eetaches
09:56:37 <vincenz> SyntaxNinja: it doesn't but I was thinking it'd be nice
09:57:53 <shrimpx> so greg morrisett at harvard is implementing the language of doom, which is strict but its IO stuff is reflected in types (dunno if it's monadic, but that seems likely)
09:58:26 <Lor> I have tried out monadic IO in scheme and ML. I'm not making things up from my head.
09:59:46 <SyntaxNinja> Lor: you are clearly making things up ;)
10:12:25 <shapr> y0 PerlJam
10:12:34 <PerlJam> greetings
10:12:41 <SyntaxNinja> shapr: y0
10:12:43 <shapr> y0 SyntaxNinja
10:13:06 <PerlJam> shapr: do you still hang out on #python?
10:13:13 <shapr> No, why?
10:13:30 <shapr> I do hang out on #plone, #archetypes, and sometimes #zope
10:13:57 <PerlJam> just curious.  The times I've been back it hasn't seemed the same and I think it's because the people I was used to were gone.
10:14:05 <shapr> Yeah, I agree.
10:14:13 <shapr> But I left because the place was taken over by trolls.
10:14:41 <shapr> Which is one reason I'm rather pushy about removing trolls from #haskell when they crop up.
10:14:52 <PerlJam> yeah, I left when the S/N ratio started a downward trend that I'd seen before :)
10:14:53 <shapr> I don't want to see the same thing happen here.
10:15:40 <SyntaxNinja> shapr: here here
10:15:44 <sqrt> #archetypes? Like in psychology?
10:16:13 <CosmicRay> speaking of that, heffalump was making a lot of noise about actually learning patch theory last weekend
10:16:27 <shapr> Heh
10:17:05 <shapr> It's good to also be aware of the new patch theory that David is developing on the conflict list.
10:17:22 <CosmicRay> oh, he's completely redoing patch theory?
10:17:24 <CosmicRay> interesting
10:18:33 <CosmicRay> here's an interesting darcs data point: once fully converted, the fptools darcs repository will have tracked slightly more changesets than the kernel bkbits repo.
10:18:46 <shapr> wow
10:19:25 <CosmicRay> yeah
10:19:34 <CosmicRay> somewhere between 25,000 and 30,000 I figure
10:19:48 <CosmicRay> it will take several more days for tailor to finish with its thing though
10:20:00 <shapr> yow!
10:20:09 <CosmicRay> yeah
10:20:18 <SyntaxNinja> @yow
10:20:19 <lambdabot> If I am elected no one will ever have to do their laundry again!
10:20:20 <CosmicRay> it calls /usr/bin/cvs individually for each file in each changeset
10:20:35 <CosmicRay> and also uses a fair bit of cpu itself for some purpose I haven't yet worked out :-)
10:20:52 <CosmicRay> otoh it seems that nobody has tried to use tailor to convert something on this magnitude before
10:26:46 <basti_> shapr: y0. the graphics are online and work now. just the formatting is a little ugly.
10:27:16 <basti_> and the .tar.gz is not the newest one, and there's some stuff i did but didn't yet write about.
10:27:22 <basti_> but then it's done.
10:28:48 <shapr> basti_: excellent!
10:30:01 <shapr> sqrt: #archetypes is about a kind of object publishing in Plone
10:30:22 <sqrt> shapr: that would've been my second guess.
10:30:28 <basti_> i'd want to know how to do tables without borders ("<border="0">" didnt work), centering and custom image tags (there is one for adjusting an image relative to the line, which is what i'm looking for)
10:31:21 <shapr> I don't know, but I'll check it out later.
10:31:35 <shapr> There may not be any support for centering, custom image tags, etc
10:31:43 <shapr> But I can always whip up a simple 'literal insert' plugin.
10:31:52 <basti_> oh that would be great.
10:32:07 <shapr> You'd have to be careful to not explode the page, but you'd also get to do anything you like.
10:32:22 <basti_> yes of course...
10:32:31 <basti_> i can live without centering or the tables
10:32:49 <basti_> the image tags would give about 90% of the maximum i think.
10:36:35 <vincenz> re
10:36:57 <vincenz> Lor: how did you do it?
10:37:52 <Lor> Just by coding. It's trivial.
10:41:29 <vincenz> Lor: And how did you take care of the thing I told you?
10:41:49 <shapr> Lor: Ahem, want to write for TMR2? Have I already asked you this several times?
10:43:12 <Lor> vincenz, the thing you told about doesn't exist.
10:43:34 <Lor> shapr, give me a subject and I'll see what I can do.
10:45:48 <vincenz> Lor: the fact that if you do IO, you're forced to return an IO monad
10:47:05 <Lor> A monadic value, yes.
10:47:20 <Lor> It is "done" simply by not giving any other interface to doing IO besides the monadic one.
10:48:11 <vincenz> Lor: yes but I can bind this in a let to an unused variable
10:49:59 <Lor> So what?
10:51:13 <vincenz> So you do the IO, but then the return type of that let is no longer an IO mona
10:51:19 <vincenz> monad
10:51:51 <vincenz> someIOFun : String -> IO ()   (* this function prints the string*
10:51:59 <shapr> Lor: How about limitations of type-safe dynamic loading in Haskell?
10:52:01 <vincenz> let _ = someIOFun "test"
10:52:08 <vincenz> in ()
10:52:18 <shapr> Lor: Proof carrying code seems to be your expertise. But, what would you like to write about?
10:52:35 <vincenz> Hi shapr !
10:52:39 <shapr> salut vincenz
10:52:46 <vincenz> shapr: how do you say "I am" in your language?
10:53:05 * shapr tries to translate into redneck
10:53:15 <shapr> Probably "I have beer."
10:53:19 <vincenz> thought you were finish
10:53:21 <basti_> did i mention i gave the "that stupid IO thing" talk a few times now?
10:53:28 <shapr> Heck no, I'm from Alabama, USA.
10:53:39 <Lor> vincenz: http://haskell.org/hawiki/HaskellIrcPastePage
10:53:40 <shapr> Guten Abend swape
10:53:43 <basti_> swedish, if at all.
10:53:48 <vincenz> oops
10:53:50 <vincenz> right swedish
10:54:00 <shapr> Lor is Finnish.
10:54:03 <Lor> There's an ocaml example. A monadic IO interface with two operations is provided. See if you can break it.
10:54:20 <shapr> Most of the swedish people on the channel have been quiet recently.
10:54:29 * shapr looks at nibro_afk: 
10:54:45 <jlouis> ... while the danish people just generally have messed around ;)
10:54:46 <vincenz> Lor: yes... let _ = read >>= fun s -> print ("You said " ^ s) in (
10:54:46 * basti_ can type swedish letters
10:54:49 <vincenz> ()
10:54:54 <basti_> æ
10:55:01 <shapr> That's Danish :-)
10:55:05 <basti_> shit.
10:55:09 <shapr> That and ø
10:55:19 <vincenz>  heilikopter
10:55:21 <shapr> My sister was bit by a møøse once.
10:55:22 <Lor> vincenz, try it out.
10:55:23 <jlouis> what encoding? UTF-8?
10:55:33 <shapr> jlouis: Yeah, that's the standard here.
10:55:42 <basti_> but a with ° is swedish isnt it?
10:55:48 <shapr> Yes, it is.
10:55:51 <vincenz> Lor: but you see what I mean right?  I guess you can do monads, but you can still have side effects in functions (in this case IO) in a function that does not return a monad
10:55:52 <jlouis> shapr: cool, have to set up the terminal then
10:55:53 <shapr> Åsa
10:56:16 <jlouis> and now... good UTF font sought
10:56:17 <jlouis> hehe
10:56:20 <Lor> If the language provides you with non-monadic side effects, then it provides them. That's not very insightful.
10:56:37 <vincenz> Lor: hmm...so how do you execute it?
10:56:48 <basti_> actually møse would be a naughty word in german if it was written with a "ö"
10:57:06 <basti_> which is the analog
10:57:27 <basti_> but we won't write it with ö, so...
10:57:49 <Lor> vincenz, you can't, that's the point.
10:57:59 <vincenz> Lor: and note how you're forcibly introducing lazyness
10:58:06 <vincenz> which goes back to my point "you need lazyness for monads"
10:58:55 <Lor> It uses closures. That's different from laziness (which usually implies memoization of some sort).
10:59:03 <Lor> Anyway, the language itself is strict.
10:59:07 * vincenz nods
10:59:48 <Lor> In any case, the actual implementation of the IO monad shouldn't concern us here. It might be some magic thing provided by the language primitively.
11:00:19 <Lor> The point is that the interface itself is just as safe as in Haskell.
11:00:27 <vincenz> actually....
11:00:36 <vincenz> yip
11:00:37 <vincenz> ok :)
11:02:59 <vincenz> hmm...odd
11:04:20 <vincenz> Basically if you use this in haskell-like programs you'll get a huge closure at the end
11:07:27 <Lor> Yes.
11:07:33 <Lor> There are ways to optimize it.
11:07:47 <Lor> Hm, well, no, actually.
11:08:17 <Lor> The closures are allocated pretty much the same speed as they are called and ignored.
11:08:35 <Lor> Note that in the definition of >>=, the call to f is a tail call.
11:08:40 * vincenz nods
11:09:19 <Lor> So m gets called, then its value is passed to f, and though f will probably allocate new closures, m can already be freed.
11:09:34 * vincenz nods
11:09:40 <vincenz> you could prolly optimize a GC for that
11:09:55 <Lor> Ooops, sorry.
11:10:05 <Lor> The call to f is _not_ a tail call.
11:10:34 <vincenz> yeah gotta go into m
11:11:20 <shapr> data Work a = W (Effort -> a)
11:11:22 <vincenz> but presumably the m's are IO actions so there won't be much functions to call in em
11:11:35 <shapr> day :: Work Shapr
11:11:45 <shapr> Hm, that's not right...
11:16:36 <vincenz> shapr: Work -> Shapr?
11:16:45 <shapr> Yeah, obviously wrong.
11:16:55 <shapr> It should be Shapr -> Effort -> Work?
11:17:07 <shapr> Bah, I dunno...
11:17:14 <shapr> Monads are hard, let's go unicycling.
11:19:04 <Maddas> shapr: @yow!
11:19:48 <Maddas> Maybe something like Maddas -> Work -> Procastrination? :-)
11:20:25 <Maddas> Uh, maybe not.
11:20:27 * Maddas goes shopping
11:20:34 * esap thinks Shapr is not a type. It's an instance. Maybe:   Person -> Effort -> Result ?
11:20:58 <vegai> Vegai::Maybe Work
11:22:44 <basti_> basti_ :: Unit
11:22:46 <basti_> =)
11:26:40 <Heffalump> CosmicRay: you about?
11:29:23 <vincenz> Person -> Maybe Effort -> Maybe Result
11:29:36 <tall_white_man> is there a spreadsheet in haskell?
11:29:39 <tall_white_man> free?
11:34:11 <Heffalump> (fixes #303073) in a Debian package changelog should cause the bug to be marked as fixed by the BTS, shouldn't it?
11:36:01 <SyntaxNinja> closes:
11:36:10 <SyntaxNinja> not sure about fixes
11:36:17 <Heffalump> ah, bugger.
11:36:17 <SyntaxNinja> if you use emacs mode, it'll get colored
11:36:24 <Heffalump> I thought it was just the #foo it recognised.
11:36:37 <Heffalump> should I just close the bug manually, then?
11:36:58 <SyntaxNinja> yeah
11:37:12 <SyntaxNinja> with a verbose explanation saying what a bad person you are for getting the syntax wrong ;)
11:37:51 <CosmicRay> Heffalump: yes, sorta
11:38:18 <Heffalump> cosmicray: I was just going to ask if you knew why the bug hadn't closed itself.
11:38:22 <Heffalump> but I know why now :-)
11:38:28 <CosmicRay> heh
11:39:04 <SyntaxNinja> CosmicRay: the cabal project is flat broke!
11:39:31 <CosmicRay> SyntaxNinja: that's ok, because there is no cabal!
11:40:53 <SyntaxNinja> oh, good.
11:41:41 * SyntaxNinja mutters something about slashdot spin because I can't get enough of complaining about it
11:43:02 <Heffalump> I just email 303073-done@bugs.debian.org with the explanation, right? (Just to make sure I don't do anything else stupid..)
11:48:08 <SyntaxNinja> I think that's right :)
11:48:17 <SyntaxNinja> there's a cheat sheet oneline somewhere, but it's not too good.
11:48:36 <Heffalump> http://www.debian.org/Bugs/Developer is what I'm going by
11:50:14 <SyntaxNinja> yeah
11:52:09 * stepcut ponders
12:06:40 <stepcut> hrm, I want to fork off a child process and consume all of its output. But I also need to do a waitpid on the child process to (a) determine if it exited sucessfully, and (b) remove it from the process table so I don't end up with lots of zombie processes
12:07:17 <stepcut> but, the trick is, how do I know when all the output has been consumed so that I can safely check the status
12:07:18 <Heffalump> can you use multiple threads?
12:07:30 <Heffalump> or can you look for EOF on the output stream?
12:07:34 <stepcut> I would *like* to avoid using OS level threads
12:07:38 <Heffalump> (/me is guessing)
12:07:42 <Heffalump> I meant Haskell-level threads.
12:07:45 <stepcut> because ghci (in debian) does not support OS threads
12:08:07 <stepcut> using haskell-level threads, when I call getProcess, it seems to block the whole process, not just the one thread
12:08:27 <Heffalump> what about with the threaded-rts?
12:08:48 * Heffalump doesn't really understand this stuff properly, I just have some random guesses
12:08:54 <stepcut> I think it works with the threaded-rts, but that requires OS level threads, yes ?
12:09:20 <Heffalump> quite possibly
12:09:49 * stepcut ponders EOF
12:10:51 <dcoutts_> stepcut, so compiling your program using "ghc -threaded bla bla" does not work?
12:10:51 <stepcut> I am currently using hGetContents, but maybe I should make my own version of hGetContents
12:11:11 <stepcut> dcoutts_: that works, but then I can use my code in ghci
12:11:46 <Heffalump> dcoutts_: how was the Strachey lecture, btw? (for the benefit of everyone else, it was a talk in Oxford by Wadler)
12:11:48 <stepcut> I could make a hGetContents that takes a function to run when EOF is reached
12:11:52 <dcoutts_> oh, right, ghci itself is not using the threaded rts, that's probably right
12:12:21 <dcoutts_> Heffalump, well as Oege said, it started slowly and then went up at a steep angle :-)
12:12:29 <Heffalump> :-)
12:13:09 <dcoutts_> he was talking about the Curry-Howard isomorphism and then about various other similar examples where logic and computaion have close links
12:13:33 <stepcut> If I try to do a blocking check on the return status, before I have read all the output, then I risk deadlocking, because the child will be blocked on stdout, and the parent will be blocked on the getProcess
12:13:46 * stepcut looks into hGetContents
12:19:58 <tall_white_man> is haskell faster than php for website development?
12:20:28 <cptchaos> I have some sort of maybe esoteric question: i need to make an instance of class monad of a type Show a => m a, is there a way to do that?
12:20:36 <stepcut> tall_white_man: sometimes -- but with better libraries sometimes could be most of the time
12:20:37 <vegai> tall_white_man: about 425% faster
12:20:57 <Heffalump> instance Show a => Monad (Foo a), do you mean?
12:21:17 <Heffalump> or do you mean m a only works if a is in Show?
12:21:21 <Heffalump> if you mean the latter, you can't do it.
12:21:35 <cptchaos> the latter
12:21:48 <Heffalump> @type return
12:21:53 <lambdabot> return :: forall (m :: * -> *) a. (Monad m) => a -> m a
12:22:01 <Heffalump> see, that's why.
12:22:14 <Heffalump> the operations have to be of that type for all a, not just for a in Show.
12:22:30 <cptchaos> Heffalump: thanks
12:22:49 <Heffalump> you can make your own ShowMonad class, but of course you then don't get do notation.
12:23:04 <Philippa> vegai: there's one slight minus there, which is that you're unlikely to get the GHC RTS cached for you
12:23:07 <Philippa> but yeah, that aside
12:23:14 <Philippa> Haskell's great for web dev
12:23:18 <Philippa> well, good
12:23:22 <Philippa> it'd be great with better libs
12:23:31 <Philippa> (Text.Html's not wonderful and Network.CGI sucks, for example)
12:23:59 <dcoutts_> Philippa, cahced? you mean like the way mod_php works
12:24:03 <tall_white_man> hey
12:24:18 <tall_white_man> what is diff between lisp and haskell
12:24:20 <Philippa> dcoutts: right
12:24:29 <Philippa> "immense" is the short answer
12:24:30 <dcoutts_> tall_white_man, about 30 years
12:24:37 <gzl> what, it's 425% faster?
12:24:40 <gzl> ??
12:24:52 <Philippa> lisp is impure as hell, dynamically typed and strict by default
12:25:26 <cptchaos> Heffalump: I doing that to make somekind of a compiler of a monadic domain specific language ..
12:26:01 <dcoutts_> Haskell is pure as (something pure), statically types and lazy by default
12:26:17 <dcoutts_> types/typed
12:26:53 <tall_white_man> well
12:27:00 <tall_white_man> to develop moden biz apps
12:27:10 <tall_white_man> haskell or lisp or what is best
12:27:19 <dcoutts_> Philippa, so this mod_ghc thing I've heard about (or was it mod_haskell) that doesn't do the apache-in-process cache stuff thing?
12:27:20 <tall_white_man> like ebay or yahoo
12:27:40 <vegai> lisp is definitely not bad
12:28:19 <dcoutts_> you know what Paul Graham would say (so I shan't repeat it)
12:28:27 <tall_white_man> f graham
12:28:30 <dcoutts_> :-)
12:28:35 <tall_white_man> his book is un readible
12:28:36 <TFK> To develop modern business applications, it is first necessary to get your resume read by the Joel Spolskys of the world.
12:28:44 <tall_white_man> who
12:28:45 <Philippa> dcoutts: I merely don't know if it's in a usable state yet. If it is, that's cool
12:28:48 <tall_white_man> billy joel?
12:28:53 <TFK> http://www.joelonsoftware.com/articles/ResumeRead.html
12:29:08 <dcoutts_> Philippa, I don't know if its usable either
12:29:40 <Philippa> tall_white_man: you're even more likely to get fired for using haskell than for using lisp
12:30:19 <Philippa> that aside, it depends on exactly what you're doing - haskell 98 isn't really suitable for business apps IMO, a pile of GHC extensions makes for a nice language though
12:30:35 * stepcut is typically forced to choose between ocaml and haskell at his job ;p
12:30:55 <tall_white_man> death to hr people
12:31:10 <tall_white_man> scum
12:31:18 <Philippa> stepcut: lucky you
12:31:50 <Philippa> mind you, I simply don't have a job
12:31:53 <stepcut> heh
12:33:27 <boegel> @yow
12:33:27 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
12:33:27 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
12:33:40 <stepcut> @arr
12:33:42 <lambdabot> Ahoy mateys
12:34:04 <kaol> @vixen
12:34:05 <lambdabot> Have you ever killed a hobo?  Ive found eating their liver gives
12:34:05 <lambdabot> me strength.  I think i may just be short on b vitamines.
12:34:07 <TFK> @look behind you! A three-headed monkey!
12:34:08 <lambdabot>          (__)
12:34:08 <lambdabot>          (oo)
12:34:08 <lambdabot>    /------\/
12:34:08 <lambdabot>   / |    ||
12:34:08 <lambdabot>  *  /\---/\
12:34:09 <lambdabot>     ~~   ~~
12:34:11 <lambdabot> ...."Have you mooed today?"...
12:34:18 <TFK> @monkey
12:34:19 <lambdabot> Unknown command, try @listcommands.
12:34:26 <TFK> o_O?
12:36:57 <Lemmih> SyntaxNinja: Hiya.
12:42:06 <TFK> stepcut, if you don't mind me asking, what kind of a job do you have? I'd think that ML languages were pretty rare.
12:42:47 <jlouis> TFK: I believe I can point to many places where you could use a functional language
12:43:20 <TFK> Sure, I'm not saying about potential usage, I'm talking about actual usage, where your job *requires* ML languages.
12:43:47 * shapr boings frantastically
12:43:50 <shapr> I love unicycling!
12:43:56 <jlouis> haha
12:43:56 <TFK> At least over here the requirement is usually C++ or something :-/
12:44:18 <jlouis> Most requirements will be Java, C, C++, C#, PHP or Perl
12:44:23 <jlouis> occasionally Python
12:44:39 <zamez> the only functional language we use at work is XSL
12:44:47 <zamez> and that doesn't really count
12:44:51 <zamez> 'cos it sucks
12:44:54 * zamez hides
12:45:16 <TFK> Python <3
12:45:30 <jlouis> The reason for this is simple: It gets the job done and most people do not grasp functional programming
12:45:46 <TFK> Too stupid?
12:45:59 <shapr> @quote Darius
12:46:01 <lambdabot> Darius hasn't said anything memorable
12:46:04 <shapr> @quote darius
12:46:06 <lambdabot>   I imagine XSLT programmers say "It's a one pager" the way most
12:46:06 <lambdabot> other programmers say "It's a one liner".
12:46:14 <dcoutts_> TFK, people just arn't taught FP
12:46:16 <zamez> :>
12:46:24 <shrimpx> haha
12:46:27 <TFK> I dunno. How many percent of programmers have CS degrees? They usually dedicate at least one course to FP.
12:46:36 <zamez> most people are just reluctant to change from their favourite language
12:46:42 <TFK> In our Uni there is such a course, or more, I reckon.
12:46:43 <dcoutts_> but people present FP as a toy
12:47:07 * TFK would not like to start a debate
12:47:27 <dcoutts_> I know they do at my uni, the students don't take it seriously (Heffalump will laugh at me for saying so)
12:48:11 <dcoutts_> TFK, err, yes good idea [drops subject]
12:48:39 <Philippa> dcoutts: it's certainly presented that way at UoN, you don't get to see it being useful for anything. "Oh look, we can do graphics with fran!"
12:48:59 <TFK> I was just wondering about the present employment of a person who already stated the requirement of an ML language.
12:49:04 <Philippa> (which doesn't look great at the best of times and draws sniggering from the amateur gamedev crowd)
12:49:13 <TFK> But anyway I must burn Hoary LiveCD now. Tata!
12:49:17 <zamez> dcoutts_: that's not what I found when I was there a few years ago
12:49:42 <zamez> all the people I knew well doing the course were very interested in FP
12:49:55 <boegel> shapr: how's TMR2 ?
12:49:55 <dcoutts_> zamez, there are a few people entheused each year but not many
12:50:04 <shapr> boegel: it's rockin, want to join the review team?
12:50:14 <Philippa> generally it's the smart crowd who're seeing potential to encode all the stuff they can't in other languages
12:50:29 <Philippa> HOFs are like crack if you're used to C++ and Java
12:50:45 * shapr grins
12:51:00 <Philippa> ADTs and pattern-matching are great if you're into stuff like compilers and interpreters, too - the sheer amount of pain involved in faking them in Java is...
12:51:10 <Philippa> well, lemme put it this way: I have masochistic tendencies. That /still/ wasn't fun.
12:51:20 <Heffalump> I know very few students at Oxford who have taken Haskell seriously.
12:51:37 <Heffalump> I think zamez is one of the very few that have but haven't gone on to do a DPhil.
12:51:48 <Philippa> I think Jimbo would do if he thought it were worth his while
12:51:52 <jlouis> Philippa: hehe. The problem though is that even when you teach people FP, they do not get it
12:51:55 <Philippa> oh, and didn't have to prove the monad laws held on something
12:52:01 * Philippa nods
12:52:03 <shapr> I met a bunch of students at the nearby university who had taken Haskell courses and said "You can't do anything useful with recursion."
12:52:13 <Philippa> I only really 'got it' a year or so later when I gave myself a serious crash course
12:52:22 <jlouis> shapr: typical argument
12:52:22 <noj> hey. is the darwinports ghc maintainer in here?
12:52:36 <shapr> noj: Is that Sven Moritz Hallberg?
12:52:48 <Heffalump> well, he volunteered to do the epigram course, didn't he? That's got to show some kind of dedication.
12:52:52 <Philippa> and only properly once I'd learnt to bend purity into something resembling complete impurity at will
12:53:03 <jlouis> coming NetBSD ghc maintainer here. I have not looked into it yet
12:53:05 <Philippa> that, or not wanting to do a course on XML
12:53:08 <noj> shapr, gwright@opendarwin.org
12:53:08 <Heffalump> :-)
12:53:15 <noj> that's what the Portfile says
12:53:16 * Philippa wants to do the epigram course
12:53:20 <shapr> noj: No clue about that person, sorry.
12:53:26 <Philippa> but at the rate I'm going I won't be able to 'til Conor's moved again
12:53:26 * shapr wants to do the epigram course too.
12:53:40 <Philippa> (I really ought to track him down, corner him and force a conversation...)
12:53:42 <SyntaxNinja> w00t
12:53:54 <shapr> Philippa: yes you should, Typo and FlippaCat
12:53:59 <shapr> ahem Tyop
12:54:24 * SyntaxNinja squints at shapr
12:54:29 * shapr waves the Tyop and FlippaCat pom-poms
12:54:32 * shapr leers at SyntaxNinja 
12:54:38 <noj> argh. anyone know of ghc-binaries for OS X 10.4? it'll take forever to build on my powerbook
12:55:05 <shapr> noj: I've seen some mentioned on the ghc-users list, no clue if urls were included.
12:55:18 <shapr> SyntaxNinja: wassup?
12:55:20 <wagle> noj: having just built ghc from darwinports the day before yesterday, i'm curious as to why you are looking for the maintainer
12:55:28 <Philippa> shapr: I suspect he'd find Tyop fairly boring
12:55:39 <Philippa> I mean, if you're off having fun with dependant types it is rather...
12:55:42 <wagle> noj: (like if its anything i should know)
12:55:53 <Philippa> but yes, I'd like to talk about his idioms and stuff like that
12:55:54 <noj> wagle, it doesn't build on 10.4 and I would like some help from someone with more darwinports-fu
12:56:03 <Philippa> (which're related to what I'd been playing with)
12:56:22 <wagle> noj: what happens?
12:56:23 <noj> shapr, thanks, I'll check
12:57:06 <shapr> hiya jyasskin, how's code?
12:57:34 <wagle> i guess it'll be a bit before i upgrade to 10.4
12:58:20 <noj> wagle, it pulls in dlcompat, but it's shipped in base on 10.4
12:58:35 <noj> but I'll fix it :)
12:58:45 <wagle> ah,, that sort of thing
12:59:30 <wagle> my main problem is all the non-free software i'd have to probably upgrade at the same time
13:01:33 * Lemmih would be one happy boy if local package.conf overruled the global package.conf.
13:01:47 <Lemmih> *if the
13:02:19 <shapr> It should...
13:03:09 <Lemmih> I get lots of errors about modules exposed in both Cabal-1.0 and Cabal-0.6.1.
13:04:41 <CosmicRay> Noooooooooooooooooooooooooooooooooooooooooooooooooooooooo
13:04:51 <CosmicRay> tailor crashed again
13:05:51 <wagle> tinkerinf with the tailor?
13:05:59 <wagle> tinkering with the tailor?
13:06:22 <CosmicRay> converting fptools to darcs
13:07:23 <wagle> anyone thinking of converting darcs to use git?
13:07:39 <CosmicRay> wagle: already in the works, see darcs-devel
13:08:08 <SyntaxNinja> Lemmih: what's cabal 0.6.1?
13:08:16 <SyntaxNinja> maybe you shouldn't go around making up cabals
13:08:48 <SyntaxNinja> Lemmih: anyway, make sure everything is built with the same version of cabal.
13:09:51 <Lemmih> SyntaxNinja: Cabal 0.6.1 is 0.6 with patches for cabal-get.
13:10:38 <Lemmih> (it's not official, just something for me to tell them apart)
13:10:47 * SyntaxNinja knows it's not official ;)
13:11:03 <wagle> is there an irc channel for darinwports?
13:11:07 <Lemmih> Then why shouldn't I go around making up cabals?
13:11:29 <SyntaxNinja> Lemmih: well, maybe you shuoldn't go around talking about made-up cabals as if everyone can see them.
13:11:33 <SyntaxNinja> ;)
13:12:39 <Lemmih> (generalized statement) I get lots of errors about modules exposed in both [some-package]-[some-version] and [same-package]-[different-version].
13:13:28 <SyntaxNinja> Lemmih: make sure everything is built with the same version of [some-package]
13:13:43 <SyntaxNinja> Lemmih: I think there might be a bug in GHC, though. JaffaCake :)
13:14:52 <Lemmih> One of the modules depends on both [some-package]-[some-version] and [same-package]-[different-version] even tho I compiled with '-ignore-package [some-package]-[some-version]'.
13:15:05 <Lemmih> All the other modules are fine.
13:16:04 * jlouis tries a rebuild of hugs/NetBSD for the 300th time
13:17:09 * SyntaxNinja pokes JaffaCake
13:17:15 <Lemmih> But I can load the module in GHCi without problems...
13:17:20 * Lemmih is very confused.
13:17:42 <SyntaxNinja> what do you mean that a module depends on some package?
13:18:23 <Lemmih> 'ghc --show-iface' shows dependencies.
13:19:00 <boegel> shapr: I'm afraid I don't have time, unfortunatly
13:19:00 <SyntaxNinja> it might depend on some library that was built with Cabal-1.0
13:19:05 <shapr> boegel: ah, too bad
13:19:09 <boegel> shapr: what are the subjetcs ?
13:19:39 <shapr> Um, varied
13:20:29 <boegel> heh :) you don't have a list or so ?
13:20:59 * boegel is shocked too see there is no IssueTwo page of TMR
13:21:27 <shapr> boegel: separate wiki
13:23:04 <wagle> whoa..  i can get around to figgering out gadt's now
13:23:07 <wagle> (found the old todo)
13:23:09 <shapr> jiihaa
13:23:34 <wagle> s/$/d/ ?
13:24:26 <shapr> no, j is y in Swedish and Finnish.
13:24:37 <wagle> ahh
13:24:39 <shapr> so that's 'yeehaa'
13:24:56 <basti_> is j y then?
13:24:58 <basti_> eh
13:25:00 <basti_> y j
13:25:01 <basti_> =)
13:25:16 <shapr> Nah, y is actually oo in Finnish
13:25:28 <shapr> hiya Marios
13:25:38 <basti_> o.0
13:25:54 <CosmicRay> heh:
13:25:57 <CosmicRay> Changeset 2000-11-20 16:51:35 by simonmar:
13:25:57 <CosmicRay> wibble
13:26:05 <shapr> basti_: It's not really that sound, but I don't think I can describe it easily.
13:26:25 <wagle> yeee haw!
13:26:25 <basti_> uhm okay.
13:26:29 <SyntaxNinja> CosmicRay: is that what made it crash?
13:26:42 <CosmicRay> SyntaxNinja: no
13:26:43 <jlouis> CosmicRay: What are ghci developed in?
13:26:46 <jlouis> darcs?
13:26:50 <CosmicRay> jlouis: CVS
13:26:56 <CosmicRay> jlouis: ... for now ... :-)
13:27:05 <wagle> (yeehaw)
13:27:27 <jlouis> CosmicRay: Yes, but since simonmarlow is the only one comitting at this time I wondered if he just shifted stuff in from others
13:27:37 <CosmicRay> SyntaxNinja: the things that have made tailor crash, in order, are: malformed dates in RCS files, deadlocking with piped data to/from darcs, and filenames with spaces in them
13:27:51 <CosmicRay> jlouis: afaik there is no other fptools repo
13:27:59 <tuomov> y in finnish is like german ü
13:28:05 <basti_> ah.
13:28:22 <basti_> thats the problem that shapr had.
13:28:30 <basti_> in german y is like ü sometimes too.
13:28:35 <shapr> Oh, cool
13:29:08 <tuomov> infact, it would be quite logical to have ü in finnish too
13:29:08 <basti_> its funny how the brain plays tricks on people.
13:29:34 <tuomov> as the front vowels aou and back vowels åöy are mutually exclusive groups
13:29:38 <shapr> My brain isn't smart enough to play tricks on me. I always see the tricks and am not amused!
13:29:40 <RemiTurk> hi all
13:29:44 <shapr> hoi RemiTurk
13:29:45 <tuomov> s/å/ä
13:29:53 <basti_> shapr: :P
13:29:55 <tuomov> so the backvowels would be just front vowels with dots
13:29:57 * shapr snickers
13:29:59 <jlouis> CosmicRay: ok. Thanks
13:30:19 <shapr> I am very silly! w00!
13:30:32 <basti_> shapr: but growing up learning american probably messed up your ü recognition and doch/ich distinction forever ;)
13:30:50 <jlouis> again, what font are you using for displaying unicode?
13:31:07 * basti_ had to look for it some time
13:31:07 * shapr laughs
13:31:14 <shapr> basti_: I think you're probably right.
13:31:16 <basti_> its called "terminus"
13:31:49 <xerox> jlouis, I do use terminus too.
13:32:10 <basti_> its quite readable. The 0 sucks a bit, though.
13:32:11 <jlouis> xerox: that is my preferred font for writing code too yes
13:32:22 <jlouis> terminus owns
13:32:41 <basti_> oh theres a rule about english spelling i found out!
13:32:41 <CosmicRay> question.  why is HaXml in fptools but not in ghc 6.4?
13:32:55 <CosmicRay> what?  there are rules about english spelling? :-)
13:33:00 <tuomov> a rule? in english?!?
13:33:02 <basti_> when an english word has "gh", its almost always because the german equivalent has an "doch ch"!
13:33:03 <wagle> shapr: you get the tiling typechecking to work?
13:33:25 <shapr> Nah, I need to go back and reread skew's typeclasses suggestion.
13:33:36 <shapr> I did find some papers that might help, but haven't read them yet.
13:33:55 <skew> basti_: yeah, there was some kind of thing where English branched off of german or stole a lot of german or something, and then mutated all the sounds a bit
13:33:59 <shapr> I also discovered that region allocation is considered to be something like 'shape based type safety'
13:34:09 <wagle> i was thinking the next task would be typechecking typesettings..  >)
13:34:21 <CosmicRay> I read that as "shapr based type safety" at first
13:34:25 * shapr grins
13:34:29 <basti_> skew: english and german have common roots. English has latin and celtic influences, though.
13:34:30 <shapr> well, shapr is short for shaper
13:34:34 <shapr> wagle: huh?
13:34:37 <shapr> oh!
13:34:42 <shapr> Oh that's a neat idea.
13:34:46 <skew> basti_: yeah. I think ch -> gh was one of the trasitions
13:34:48 <SyntaxNinja> CosmicRay: I've been wondering about HaXmL. let me know if you find out.
13:34:50 <wagle> hTeX
13:34:59 <skew> basti_: also all the vowel sounds kind of moved over a spot
13:35:05 <basti_> skew: "gh" is mainly a hole full of air in today's english though.
13:35:08 <shapr> wagle: two dimensional type checking of typesetting... wow.
13:35:31 <basti_> yes, similar to what they did in dutch and in "nether german" accents
13:35:32 <shapr> I gotta think about that.
13:35:45 <wagle> cool
13:36:27 <Heffalump> anyone want to sponsor my Debian packages with a view to advocating me for N-M if happy with them (so far there's just haskell-http, though I plan to do HaXml once I've got haskell-http where I want it)
13:37:49 <SyntaxNinja> Heffalump: is haskell-http built with cabal and dh_haskell? ;)
13:37:57 <Heffalump> yes
13:38:21 <Heffalump> and it'll be integrated with darcs-buildpackage when I get a round tuit (and understand precisely what darcs-buildpackage does)
13:38:36 <SyntaxNinja> I could do that. always good to have another haskell-debian hacker :)
13:39:31 <Heffalump> cool, thanks. How much stuff do you want to look at before (possibly) being read to be my advocate?
13:39:34 <Huschi> if you are talking about haskell and debian. is anyone planning a to create a debian package for wx-haskell?
13:39:50 <CosmicRay> someone has, it's in haskell-unsafe
13:39:55 <CosmicRay> might be old and/or broken tho
13:40:09 <SyntaxNinja> probably. I haven't taken care of it in a long time...
13:40:13 <Huschi> oh, yes i remember, but it's version 0.8
13:40:18 <Igloo> IIRC it needs someone to work out what to do about its shared library
13:41:22 <SyntaxNinja> Heffalump: not sure. we should talk about it over email. it always looks better if you want to do stuff besides maintain packages, too.
13:41:27 <Huschi> isn't it possible to create two packages, maybe wxhaskell and wxhaskell-dev?
13:41:39 <Heffalump> ok. And I don't, TBH :-)
13:42:32 <SyntaxNinja> TBH?
13:43:08 <Heffalump> "to be honest"
13:43:29 <Heffalump> I want to see more Haskell packages in Debian and being a DD seems like the best way to help that happen.
13:43:34 <Igloo> Huschi: There was something odd about it. I don't remember the details; I was hoping SyntaxNinja might jump in as the person who was working on it  :-)
13:43:44 <wagle> DD?
13:43:52 <wagle> 8)
13:44:24 <Heffalump> debian developer :-)
13:45:01 <SyntaxNinja> Huschi:  Igloo: I sorta lost interest in wxhaskell; haven't been using it, and been kinda busy. maybe we should force Heffalump to take it over ;)
13:45:19 <CosmicRay> heh
13:46:07 <wagle> SyntaxNinja: i tried to install it, but got stuck when the compile of wxMac barfed
13:46:11 <wagle> (using fink)
13:46:11 <Heffalump> I don't mind doing it once I've done haskell-http and haxml.
13:46:18 * Igloo would really like either gtk2hs or wxhaskell to get in; I don't think I mind much which
13:46:21 <Heffalump> but it wouldn't be something I actually used, so I wouldn't be an ideal choice.
13:46:56 <SyntaxNinja> Heffalump: yeah... you might touch base w/ fptools folks about haxml, if they're planning to include it in compiler distros or what.
13:47:18 <Heffalump> yeah. I've been waiting for a release that is cabalized before doing much abotu it anyway.
13:47:38 <Heffalump> though I thought the world was moving towards shipping stuff separately from compilers
13:48:20 <SyntaxNinja> Heffalump: yeah. hope so.
13:49:15 <SyntaxNinja> oh well. we should have recruited huschi while we had the chance
13:50:14 <basti_> o0
13:50:15 <shapr> look he's back!
13:50:25 <basti_> thats timing
13:50:32 <Huschi> shapr: you mean me?
13:50:36 <shapr> yes!
13:50:47 <Huschi> it was an accident :)
13:50:58 <SyntaxNinja> Huschi: I was saying we need to recruit you to package wxhaskell :)
13:51:43 <Huschi> but i do not know much about packaging. but i'm using debian for several years.
13:52:17 <Huschi> i would do it, but i need some resources on packaging.
13:52:50 <SyntaxNinja> Huschi: wxhaskell is a bit of a tricky package, actually, but fwiw, the packaging howto is here: http://www.debian.org/doc/maint-guide/
13:52:52 <Heffalump> join the debian-haskell mailing list
13:53:02 <SyntaxNinja> that too
13:53:24 <Heffalump> grab the latest attempts from haskell-unsafe, and start asking questions (here or on the list)
13:53:46 <wagle> http://story.news.yahoo.com/news?tmpl=story&cid=1516&ncid=1516&e=2&u=/afp/20050423/od_afp/germanytoadsoffbeat_050423161657
13:57:21 * Lemmih runs around screaming and pulling out his hair.
13:57:34 <Jerub> shapr: yo
13:57:42 * RemiTurk ties Lemmih in a straightjacket
13:57:49 * Philippa has a thought...
13:57:50 <Huschi> where can i subscribe to the debian-haskell mailing list? on debian.org or on haskell.org?
13:58:12 <SyntaxNinja> @google haskell debian mailing list
13:58:15 <lambdabot> http://urchin.earth.li/mailman/listinfo/debian-haskell
13:58:23 <Philippa> does cabal let you note that a program relies on the NO-INLINE unsafePerformIO IORef trick?
13:58:37 <Heffalump> urchin.earth.li is clearly the union of the two. Or the intersection?
13:58:41 <SyntaxNinja> Philippa: is that an extension? :)
13:58:53 <Heffalump> lol
13:58:56 <Philippa> I'd say unsafePerformIO and NO-INLINE are extensions
13:59:06 <esap> and IORef :-)
13:59:24 <Heffalump> isn't IORef standard in some form?
13:59:27 <Philippa> well yeah, but at least you fail on something sane like the type not being in scope with that one
13:59:31 <SyntaxNinja> Philippa: though I doubt it's one of the enumerated extensions, so it's probably unnamed, and so no, not really.
13:59:38 <SyntaxNinja> Philippa: but we could name it if you want ;)
13:59:57 <Philippa> it just occurred to me because I've a semi-good use for a TLTWI in Flippi
14:00:16 <SyntaxNinja> maybe I should name it after you
14:00:21 <Philippa> heh
14:00:35 <Philippa> that would be a little unfair on whoever thought it up
14:00:51 <SyntaxNinja> Philippa: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution.Extension.html
14:00:53 <Philippa> and it might make people think I do dirty things ;-)
14:01:21 <SyntaxNinja> Philippa: it'll get out sooner or later.
14:02:58 <Philippa> anyway, I'd've thought the relevant extension was something simple like NoInlinePragma
14:03:05 <SyntaxNinja> Philippa: maybe you can just come up with a name for it that evokes complex, dirty kinkiness.
14:03:08 <SyntaxNinja> bah
14:03:33 <Huschi> where can i find some files on the haskell-unsafe page?
14:04:02 <Philippa> SyntaxNinja: "TLTWI". Sounds so much like a BDSMer's acronym
14:04:44 <SyntaxNinja> @google haskell unsafe debian repository
14:04:46 <lambdabot> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
14:05:33 <SyntaxNinja> Huschi: if it's not there, I might have to dig it up from elsewhere
14:06:04 <SyntaxNinja> Philippa: hm. what's TLTWI, then?
14:14:54 <Philippa> Top Level Things With Identity (as per the lengthy mailing list thread on them)
14:16:00 <Philippa> anyway, 'mbeing dragged bedwards
14:16:05 <Heffalump> I thought you were talking perl-ish.
14:16:08 <SyntaxNinja> Philippa: good luck.
14:16:10 <Heffalump> (as in TMTOWTDI)
14:16:29 <Philippa> There's Loads To Wreck It?
14:18:49 <xerox> How can I make a Show instance for a matrix encoded as an Array ((Integer,Integer)), defining show ?  I'm lost on the syntax.
14:18:56 <Huschi> who was the last maintainer of wxhaskell?
14:19:09 <SyntaxNinja> for some value of maintainer... me I guess
14:19:21 <SyntaxNinja> for debian, that is
14:19:39 <Lemmih> xerox: Isn't 'Array ix a' already an instance of show?
14:19:48 <Huschi> yes i meant for debian :) have you build the 0.8 release packages?
14:20:05 <xerox> Lemmih, I'd like to change it to a less verbose version, I'm trying to make conway's Life.
14:20:33 <RemiTurk> you'll have to define a newtype then...
14:20:40 <RemiTurk> or implement local instances :P
14:20:45 <SyntaxNinja> I have some packages with a version of 0.8, yes.
14:20:49 <Lemmih> Or just 'showMatrix'.
14:20:51 <RemiTurk> or use your own showConway
14:21:24 <Huschi> SyntaxNinja: if i've got some questions on that topic, can i ask you?
14:21:57 <SyntaxNinja> Huschi: yes, but post to the debian-haskell list so that others can answer them too :)
14:22:09 * RemiTurk votes for xerox to implement local instances
14:22:37 <xerox> Lemmih, is showMatrix defined somewhere?
14:22:40 <xerox> RemiTurk, yay!
14:22:42 <Huschi> but for starting, i would prefer to ask you here because the answer arrives me much faster.
14:23:10 <SyntaxNinja> Huschi: sure.
14:24:40 * RemiTurk implemented (with a friend learning haskell) conways gol a week ago or so
14:24:52 <xerox> ``gol'' ?
14:24:55 <xerox> Aaah :)
14:25:11 <Huschi> SyntaxNinja: first of all, isn't there a bug in the makefile that always puts the "libwxc-...so" in the same directoy as the static "libwx.a" library?
14:26:30 <SyntaxNinja> Huschi: hm. during install you mean? Never noticed. what's wrong with installing them into the same directory?
14:27:41 <Huschi> SyntaxNinja: i alway decided to install "libwx.a" into "/usr/lib/ghc-6.2.2" right to the other static haskell libraries, but the shared library should reside in "/usr/lib"
14:28:21 <xerox> How do I pattern-match an Array?
14:28:27 <Heffalump> xerox: turn it into a list
14:28:33 <Heffalump> (you don't)
14:31:48 <SyntaxNinja> Igloo: do you remmeber the static library issues?
14:32:15 <Igloo> I thought the issue was the shared library
14:32:35 <Huschi> Igloo: yes, the shared library is the issue.
14:32:43 <Igloo> Not updating its SONAME every release, but not being sharable across releases, or something like that?
14:34:09 <Huschi> Igloo: currently we were discussing about another issue concerning the makefile. i would place "libwx.a", "libwxcore.a" and so on in "/usr/lib/ghc-6.2.2" and  the "libwxc-...so" in /usr/lib"m but the makefile doesn't do this.
14:36:11 <Igloo> That's trivial to fix if it's broken, though
14:36:32 <Huschi> i found no way how to do it.
14:37:07 <SyntaxNinja> Igloo: oh right.
14:38:33 <SyntaxNinja> Huschi: you can alter the makefile, right/
14:38:55 <Huschi> SyntaxNinja: i haven't found the place to change.
14:39:20 <SyntaxNinja> packaging stuff for debian means getting more intimate with Make than most people would like.
14:39:31 <Huschi> i noticed :)
14:41:00 <xerox> showConway :: Conway -> String
14:41:00 <xerox> showConway = unlines . map (map (snd)) . groupBy (\((x,_),_) ((x',_),_) -> x == x') . assocs
14:41:02 <xerox> yay :-)
14:41:29 <Huschi> SyntaxNinja: furthermore i realized that the libghc6-wxhaskell-dev_0.8-2 package makes no entry in the package.conf file for wx and it doesn't install the wxcore interfaces.
14:43:30 <SyntaxNinja> Huschi: it doesn't do anything in the postinst script?
14:43:41 <SyntaxNinja> what do yu mean wxcore interfaces?
14:43:46 <Huschi> SyntaxNinja: it just runs ldconfig.
14:43:47 <xerox> Now, how can I instantiate showConway as show for Conway values?
14:44:10 <Huschi> xerox: instance Show Conway where
14:44:19 <Huschi> xerox:   show = showConway
14:44:38 <xerox> I argued it.. but GHC says:
14:44:39 <xerox>     Illegal instance declaration for `Show Conway'
14:44:39 <xerox> 	(The instance type must be of form (T a b c)
14:44:39 <xerox> 	 where T is not a synonym, and a,b,c are distinct type variables)
14:44:39 <xerox>     In the instance declaration for `Show Conway'
14:45:01 <Huschi> xeqi: Conway seems to by a type synonym.
14:45:02 <SyntaxNinja> Huschi: is there a package.conf file in the package for ghc-pkg to install?
14:45:13 <wagle> whats a Conway?
14:45:20 <xerox> type Conway = Array (Int,Int) Char
14:45:34 <Huschi> SyntaxNinja: yes, there are wx.conf and wxcore.conf
14:46:00 <Huschi> SyntaxNinja: so i have to do ghc-pkg -a wx[core].pkg in postinst?
14:46:24 <Lemmih> SyntaxNinja: I've updated the Hackage server on shapr's box.
14:46:56 <Huschi> xerox: you have to use a newtype for Conway, maybe newtype Conway = Conway (Array (Int,Int) Char)
14:47:19 <Huschi> xerox: or you can use -fglasgow.exts to ghc, to my mind.
14:47:23 <xerox> Huschi, oh yes, but it's really awful to have to type the constructor everywhere, it also kills points-freeing of some functions :-\
14:48:42 <Huschi> xerox: you can use functions of type Conway -> Array ... and Array ... -> Conway to make it point free again.
14:48:43 <SyntaxNinja> Lemmih: I thought the goal was to send me email and patches so I can update the server here?
14:49:04 <SyntaxNinja> Huschi: use update, -u I think.
14:49:22 <Huschi> SyntaxNinja: to which program?
14:49:23 <xerox> Huschi, with -fglasgow-exts I get an Overlapping instances error.
14:49:34 <SyntaxNinja> Huschi: ghc-pkg
14:49:57 <Huschi> xerox: thats because there is also an instance of Show for Array.
14:50:14 <Lemmih> SyntaxNinja: Installing Hackage is much easier with a working Hackage server.
14:50:15 <xerox> Huschi, is there a way to impose mine?
14:50:19 <wagle> so it is the GoL?
14:50:34 <Huschi> xerox: I dont't know.
14:50:41 <xerox> wagle, it wants to be :)
14:50:50 <xerox> Huschi, thanks much for the help, anyway!
14:51:07 <wagle> i did a grid of [Bool] once
14:51:15 <wagle> streams
14:51:16 <Huschi> SyntaxNinja: what's the difference between -a and -u?
14:57:43 <SyntaxNinja> one of them updates it if it's already there.
14:58:04 <Huschi> ok.
14:58:20 <SyntaxNinja> Lemmih: I need to be able to install it.
15:00:38 <Lemmih> Install what?
15:00:48 <SyntaxNinja> Lemmih: install hackage
15:01:27 <Huschi> yeah, i found the "bug" in the makefile.
15:03:52 <vincenz> re
15:04:12 <SyntaxNinja> Huschi: cool.
15:06:25 <Lemmih> SyntaxNinja: You aren't able to install Hackage?
15:07:29 <Huschi> SyntaxNinja: wouldn't it be nice to call the static libraries libHSwx.a and libHSwxcore.a?
15:07:35 <Lemmih> SyntaxNinja: You can get all the dependencies from the Hackage server.
15:07:36 <SyntaxNinja> Lemmih: you told me that there are altered dependencies and some patches to cabal
15:08:08 <SyntaxNinja> Lemmih: send me the cabal patches at least.
15:09:37 <SyntaxNinja> Lemmih: also, have you sent any changes to the upstream authors?
15:09:52 <Lemmih> I'm not sure you'll like them (: I've changed the verbosity and exported Distribution.Compat.FilePath
15:11:07 <Lemmih> I've tried but people tend to ignore me /-:
15:11:16 <SyntaxNinja> changed the verbosity?
15:11:34 <SyntaxNinja> just make a copy of filepath and use it locally.
15:11:48 <SyntaxNinja> call it CompatFilePath or something
15:13:47 <Lemmih> I'm using it in like 5 different projects so I'll probably make a package out of it.
15:15:33 <SyntaxNinja> that's fine, but I don't want you using a forked version of cabal, and definitely can't install one on this server here.  can you do somethign about that in the short term?
15:25:26 <Lemmih> I can send you patches?
15:28:13 <SyntaxNinja> Lemmih: I don't want to patch cabal to expose FilePath, that's why I'm asking you to make a copy of it.
15:28:45 <xerox> Goodnight folks
15:29:02 <SyntaxNinja> Lemmih: what's the verbosity change you made?
15:30:43 <Lemmih> Can't remember, pretty such it was redundant tho. I'll look it up when I get cabal-get to compile again.
15:31:14 * mwc grumbles as his Haskell book just shipped today
15:31:40 * RemiTurk says goodnight
15:31:51 <Huschi> SyntaxNinja: what about the haskell-devscripts package. does it help me anyway?
15:32:50 <SyntaxNinja> Huschi: you'd have to cabal-ize wxhaskell to use that. might not be hard.
15:34:11 <Huschi> is there a tutorial about cabal?
15:35:18 <SyntaxNinja> @google haskell cabal user's guide
15:35:21 <lambdabot> http://www.haskell.org/cabal/
15:43:44 <kaol> @google debian cabal
15:43:47 <lambdabot> http://tinc.debian.net/
15:45:33 <mwc> @google Cabal Cocaine
15:45:34 <lambdabot> http://cabalofstyle.blogspot.com/
15:45:52 * shapr snickers
15:51:20 * Jerub *waves* at shapr
15:51:27 * shapr particles back
15:51:41 <Jerub> oooh, duality.
15:52:08 <Jerub> shapr: yi looks funky.
15:52:15 <shapr> Oh no, not another dualing category theory experience...
15:52:23 <shapr> Yeah, it r0xx
15:52:28 <shapr> dons is da man
15:52:33 <shapr> @karma+ dons
15:52:34 <lambdabot> dons's karma has been incremented
15:53:00 <Jerub> shapr: the issue I find is, that when I'm using it, i think "drat, it's missing feature XXX, time to implement"
15:53:12 <shapr> Yes :-)
15:53:16 <Jerub> but my haskell is wasting away :(
15:53:16 <shapr> That's a good issue.
15:53:26 <Jerub> I don't know how to do things like update state.
15:53:33 <mwc> @karma dons
15:53:34 <lambdabot> dons has a karma of 3
15:53:40 <shapr> Now's your chance to do some lambda lifting and stop wasting those Functional muscles!
15:53:55 <SyntaxNinja> @google haskell debian cabal
15:53:55 <Jerub> help me with this function.
15:53:57 <lambdabot> http://packages.debian.org/testing/source/haskell-cabal
15:53:59 <SamB> @todo-add @karma+ should report total karma
15:54:00 <dan2> are there any professional jobs taht use haskell
15:54:01 <lambdabot> Entry added to the todo list
15:54:02 <SyntaxNinja> muahahahaha!
15:54:09 <Jerub> lex_count = digit
15:54:10 <Jerub>     `meta` \[c] st -> (with (msg (c:acc st)),st{acc = c:acc st},Just $ cmd st)
15:54:10 <Jerub>     where
15:54:10 <Jerub>         msg cs = msgE $ (replicate 60 ' ') ++ (reverse cs)
15:54:23 <Jerub> dan2: I'm a professional, my job involves hacking on Yi becuase i feel like it.
15:54:25 <Jerub> does that count?
15:54:31 <SyntaxNinja> dan2: yes
15:54:33 <dan2> Yi?
15:54:40 <SyntaxNinja> because he wants to!
15:54:47 <shapr> Jerub: I can't help you right now, when I'm done with this email I'm going to update the wiki links in darcs-stable.
15:54:58 <Jerub> okay
15:55:18 <shapr> I'll probably be able to help in about an hour.
15:55:36 <Jerub> I'm here all day ;)
15:55:43 <shapr> dan2: I've been paid to do Haskell work.
15:55:46 <shapr> twice!
15:55:54 <dan2> for what?
15:55:56 <dan2> what field even
15:56:40 <shapr> Webdev.
15:56:56 <dan2> as in Web development, or as in Web DAV
15:57:11 <shapr> Web development. I don't live in just your average ivory tower, you know.
15:57:25 <mwc> shapr, there's a market for Haskell web dev?!
15:57:35 <SyntaxNinja> shapr owns the market
15:57:45 <shapr> Yeah, why not? If I can hack up an app in a few hours where it takes the ASP guys a month, I get the cash.
15:57:49 <mwc> yeah, both contracts ;p
15:57:50 <dan2> shapr: I specialize in voip... haskell has nothing here
15:58:08 <shapr> dan2: Shall I smash your assumptions? Or would you rather read and do it yourself?
15:58:24 <dan2> shapr: if you can make the former true, I will bow down to you
15:58:32 <dan2> even Java has no place in the field
15:58:32 <mwc> Ooh ooh! smashy smashy!
15:58:49 <dan2> java got shot down for SIP because its so slow in the parsing area
15:58:55 <shapr> dan2: Ok, you're in line after Jerub ;-)
15:58:57 <dan2> and jmf is terrible
15:59:06 <shapr> Plus I read your blog entry, so I can find you even if you're not here.
15:59:24 <mwc> just let me restart and then start in on him shapr , okay?!
15:59:46 <dan2> shapr: heh
15:59:56 <dan2> shapr: kind of interesting that my blog was found so quickly
16:00:00 <dan2> since it was only up for 2 days
16:00:05 <shapr> I read Debian Planet, it wasn't hard. :-P
16:01:32 <SyntaxNinja> dan2: did you like the evolution of a haskell programmer link?
16:02:22 * shapr tries to explain monads in terms of metaclassing
16:02:41 <dan2> SyntaxNinja: funny
16:02:45 <dan2> but doesn't have a faster fibonacci
16:02:46 <dan2> :)
16:02:57 <SyntaxNinja> dan2: yeah... not exactly the point ;)
16:03:11 <mwc> since when did a fast fibonacchi become a good benchmark?
16:04:29 <mwc> speed really isn't that important
16:04:35 <mwc> what's noticible is leaness
16:04:52 <mwc> Java apps are fast enough, just take forever to start up and suck up huge amounts of RAM
16:05:18 * mwc says that's why Java is doomed
16:05:18 <SamB> sounds like another way to say "slow" to me
16:05:24 <mwc> SamB, not really
16:05:32 <dan2> java is tooo slow for voip
16:05:36 <mwc> you can use NetBeans or Eclipse
16:05:39 <SamB> fast apps in Unix are apps that start quick, too
16:05:44 <mwc> exactly
16:05:47 <Jerub> java is fast enough for anything where you don't mind the long waiting time for application start.
16:05:56 <Jerub> so basically,
16:05:58 <mwc> The JVM is a bloody beast
16:06:02 <dan2> Jerub: I'm talking actual runtime performance...
16:06:16 <SamB> Javamacs?
16:06:25 <Jerub> runtime performance, yep, most languages have fast enough runtime performance, thanks to moores law.
16:06:30 * SamB already has to wait for Emacs to start
16:06:35 <mwc> dan2, what do you need runtime preformance for VoIP for?
16:06:45 <mwc> Are you trying to implement the codecs?
16:06:47 <dan2> mwc: to handle 12000 sip messages at a time?
16:07:13 <mwc> seems to me that's mostly a question of getting a really good network hardware setup
16:07:13 <SamB> for some reason my computer doesn't comply with moore's law. its still got the same 450 MHz processor it had in 2003.
16:07:33 <dan2> mwc: and as I said, it chews up memory and is slower than molasses going up
16:07:39 <mwc> dan2, yeah
16:07:51 <dan2> mwc: I wrote the same app in C++ using resiprocate (most complete, fastest sip stack in the world)
16:07:54 <mwc> if you had a single java app doing it, you could probably get away
16:08:16 <dan2> the total amount of memory used didn't exceed 3 mb
16:08:21 <mwc> heh
16:08:26 <SamB> dan2: impressive!
16:08:29 <dan2> it used virtually no cpu
16:08:32 <mwc> You could do that with Haskell, I bet
16:08:36 <dan2> it was bound to network i/o
16:08:49 <SamB> I hope it continues not to leak
16:08:55 <mwc> but given that our compilers aren't as good, it might use 5 MB of ram
16:09:10 <dan2> mwc: thats ok, try implementing a sip stack in haskell
16:09:20 <dan2> it took 6 _years_ for resiprocate
16:09:26 <dan2> over 700pgs of rfc drafts
16:09:30 <SamB> well, C++ is nasty
16:09:35 <dan2> C++ is fine
16:09:38 <mwc> I would have to look up the SIP protocol
16:09:55 <dan2> mwc: you can't get away with just SIP, you need to support other stuff surrounding it
16:09:59 <mwc> dan2, I've all but given up on it. I like haskell for development, Ada for embedded now
16:10:14 <dan2> I like Ada too
16:10:54 <dan2> none of my favorite languages can do SIP: Python, Haskell, OCaml, C(osip is incomplete)
16:11:06 <dan2> oh, and tack on Ada
16:11:08 <mwc> if C++ got the same anal retentive checking capability it would be great.
16:11:12 <mwc> in fact, it would be basically the saem thing as Ada :P
16:11:29 <dan2> heh
16:11:31 <dan2> Ada is great
16:12:03 <dan2> C was meant for operating systems, not general purpose programming
16:12:04 <mwc> As I said, I think it's the greatest thing for embedded
16:12:10 <dan2> thus the failures of C trailed with C++
16:12:19 <mwc> Ever since I moved on from 6811 8-bitters, I've been doing Ada for it instead of C
16:12:22 <Jerub> dan2: I assume you've looked at erlang?
16:12:25 <dan2> no
16:12:45 <Jerub> dan2: erlang was written by ericsson for telecoms servers.
16:12:55 <dan2> interesting
16:13:03 <SamB> dan2: I guess you aren't crazy enough to claim that the fact that Linux is written in C is a bad thing, huh?
16:13:07 <Jerub> dan2: it's a highly concurrent programming language with pattern matching and single assignment.
16:13:23 <Jerub> dan2: it even supports zero downtime code upgrades.
16:13:31 * SyntaxNinja thinks stuff like operating systems should be written in Haskell :)
16:13:32 <dan2> interesting
16:13:35 <JohnMeacham> Too bad SISAL never took off...
16:13:36 <dan2> but concurrency is not interesting
16:13:39 <mwc> SamB, of course not... he just said C was meant for OS programming
16:13:52 <SamB> SyntaxNinja: we do not want to have to recompile the kernel everytime we sneeze!
16:13:53 * mwc wonders if dan2 is on the pipe
16:13:58 <dan2> my C++ app using resiprocate is 100% nonblocking with epoll
16:14:01 <Jerub> dan2: erlang is *all* concurrency, and its highly interesting there.
16:14:07 <SyntaxNinja> SamB: ?
16:14:12 <mwc> concurrency not interestin.... handle 12000 sip connectosns
16:14:19 <dan2> SIP doesn't have connections
16:14:22 <dan2> its UDP
16:14:29 <dan2> well UDP is defacto at least
16:14:32 <SyntaxNinja> JohnMeacham: I don't notice you following up on the libraries thread ;)
16:14:45 <SamB> SyntaxNinja: you go ahead and try writing an OS in haskell, then
16:14:50 <Jerub> anyway, look at erlang
16:14:58 <SyntaxNinja> @google haskell house
16:15:00 <lambdabot> http://www.essexheritage.org/visiting/placestovisit/listofsitesbycommu
16:15:00 <lambdabot> nity/hall_haskell.shtml
16:15:03 <SyntaxNinja> hm
16:15:11 <stepcut> heh
16:15:18 <SyntaxNinja> @google haskell house hbm ogi
16:15:18 <dan2> mwc: nonblocking > concurrency
16:15:20 <lambdabot> http://www.xs4all.nl/~jtv/GPL_TLA_FAQ
16:15:25 <SyntaxNinja> bah
16:15:38 <dan2> mwc: even if I were developing for tcp sip
16:15:43 <dan2> mwc: I'd still use epoll
16:15:49 <mwc> dan2, if it's UDP, why do you need to worry about blocking?
16:15:57 <mwc> just block on the port
16:16:01 <mwc> and wait for something to arrive
16:16:03 <dan2> mwc: session state management
16:16:11 <SyntaxNinja> samb: http://lambda-the-ultimate.org/node/view/299
16:16:12 <SamB> dan2: would you say nonblocking > concurrency across hordes of CPUs and hosts?
16:16:31 <mwc> dan2 seems to me that would be good to do concurrently
16:16:34 <dan2> SamB: concurrency doesn't help when you're bound by network i/o
16:16:38 <mwc> each session would be a seperate "thread"
16:16:45 <dan2> mwc: bad bad bad
16:16:54 <dan2> mwc: imagine 12000 threads each with a vm of 4mb
16:17:03 <mwc> dan2, wrong
16:17:11 <mwc> concurrency means 1 vm,
16:17:18 <mwc> 12000 highly parallized threads
16:17:20 <SamB> dan2: no way!
16:17:27 <mwc> it's not the same as an OS level thread
16:17:33 <mwc> think more like coroutines, they chain
16:17:38 <dan2> mwc: context switching threads then?
16:17:39 <SamB> never heard of weightless threads?
16:17:53 <mwc> SamB seems to have better explanation ready
16:18:06 <SamB> mwc: not really!
16:18:51 <dan2> mwc: so like crappy python threads eh
16:18:55 <mwc> ]no
16:18:58 <mwc> not at all
16:19:04 <dan2> then explain
16:19:12 <mwc> concurrent programming languages are designed to have 1000s of "threads" going at once
16:19:27 <dan2> of course some go into a sleeping state
16:19:28 <dan2> I know
16:19:43 <dan2> mwc: if you mean thread pooling, I've done it before, synchronization becomes a mess
16:20:25 <Jerub> erlang doesn't have syncronisation
16:20:29 <Jerub> it doesn't need it ;)
16:20:29 <JohnMeacham> SyntaxNinja: Which libraries thread?
16:21:04 <SyntaxNinja> JohnMeacham: i'm just teasing.  the one you posted on yesterday, alex replied to you.
16:21:16 <mwc> Erlang: superb support for concurrency (it is no problem to create hundreds of thousands of threads)
16:21:19 <dan2> Jerub: then its synchronizing at a hidden level
16:21:30 <JohnMeacham> Ah, yeah. seeing as how he seems to be quoting everyone else I figured I'd let them respond.
16:21:32 <dan2> mwc: which means its doing internal threadpooling or something
16:21:37 <mwc> yeah
16:21:41 <mwc> which isn't a bloody mess
16:21:46 <mwc> since that's done beneath you
16:22:02 <dan2> any languages other than erlang that do this
16:22:34 <Jerub> dan2: hah, but is it?
16:22:36 <SamB> probably haskell does it nicely?
16:22:36 <mwc> http://en.wikipedia.org/wiki/Concurrent_programming_language
16:22:39 <Jerub> dan2: erlang is single assignment.
16:23:07 * dan2 loves threads in ocaml
16:23:11 <dan2> ocaml was great for threads
16:23:19 <dan2> all immutable types, had nothing to worry about
16:23:27 <Jerub> oh, sorry, context.
16:23:38 <Jerub> i'm one of those crazy anti-thread twisted-python people.
16:24:00 <mwc> Jerub, that's okay, we call people like you "single CPU only."
16:24:02 <dan2> Java isn't concurrent
16:24:08 <dan2> well not really
16:24:15 <dan2> java has an upper bound on threads ~3000
16:24:19 <Jerub> mwc: we're working on it!
16:24:20 <Jerub> ;)
16:24:24 <Jerub> mwc: well, badly.
16:24:27 <dan2> you have to do thread pool management yourself in java
16:24:41 <mwc> dan2, read it
16:24:57 <mwc> it says Java is a horrid example of a concurrent lang
16:25:17 <dan2> :)
16:25:42 <SamB> java is a wonderful example of a language which doesn't actually have a point
16:26:23 <SyntaxNinja> @pointless java
16:26:24 <lambdabot> java
16:26:27 * SyntaxNinja nods
16:27:09 <dan2> the syntax of erlang looks similar to haskell
16:27:11 <SamB> it does not, in fact, run everywhere.
16:27:18 <Jerub> dan2: yes.
16:27:27 <SamB> perl, C, Python, and many others do that
16:27:38 <SyntaxNinja> haskell
16:28:02 <SamB> does haskell run on plan9?
16:28:16 <mwc> Java the language is total garbage
16:28:29 <SyntaxNinja> idono. i'd be surprised if there was someplace python runs that Haskell doesn't though, and if so, it's probably through sheer lack of interest.
16:28:30 <mwc> it's an attempt at an HLL that repeats all the mistakes of using C as one
16:28:42 <dan2> mwc++
16:28:43 * SamB wants a garbage collector that can collect Java itself
16:28:56 <Jerub> but java the bytecode machine was a good prototype of a generic machine target ;)
16:29:01 <SamB> SyntaxNinja: plan9!
16:29:11 <JohnMeacham> JVM is hard to target from Haskell.
16:29:16 <mwc> The only thing that makes the Java platform palatable is the library
16:29:27 <dan2> java standard library is huge
16:29:29 <JohnMeacham> Jerub: no, it has horrible flaws as a generic machine target.
16:29:31 <SamB> JohnMeacham: jvm doesn't run that many places anyhow
16:29:33 <mwc> dan2, bingo
16:29:39 <SyntaxNinja> SamB: have you tried to compile hugs or nhc98?
16:29:48 <dan2> mwc: its like anything anybody would ever want in a language
16:29:49 <Jerub> SamB: the jvm does run many places.
16:29:51 <mwc> that's the saving grace
16:29:58 <Jerub> SamB: you can even get embedded jvm enabled chips.
16:30:06 <mwc> mind you, if I was gonna use the java platform, I'd use something like JRuby
16:30:06 <Jerub> SamB: its the environment that doesn't run everywhere.
16:30:11 <dan2> the embedded jvms are fast
16:30:12 <Jerub> the jvm is teensy.
16:30:23 <SamB> I actually haven't managed to get plan9 installed properly
16:30:39 * dan2 couldn't figure out how to use plan9's editor
16:30:40 <JohnMeacham> .NET has some improvements over the jvm. but it is still no walk-in-the-park to target from a language like haskell.
16:31:10 <SamB> it isn't really a walk in the park at all, IMO
16:31:17 <Jerub> ;)
16:31:28 <mwc> JohnMeacham, isn't the CIL or the JVM meant to implement OO langs?
16:31:53 <SyntaxNinja> SamB: haskell is quite portble
16:32:03 <SamB> SyntaxNinja: yes, I suppose
16:32:08 <dan2> SyntaxNinja: esp. if you use nhc98 or so
16:32:10 <SyntaxNinja> even ghc
16:32:15 <SamB> more than Java, anyway
16:32:17 <mwc> SyntaxNinja, hugs is compilable anywhere, isn't it? :P
16:32:24 <Igloo> ghc is more portable but harder to port IME
16:32:30 <SyntaxNinja> hmm
16:32:34 <JohnMeacham> mwc: Yeah, which is part of what makes it very hard to target it from other types of languages.
16:32:41 <SyntaxNinja> mwc: almost :)
16:32:42 <Igloo> Where harder really just means "takes more CPU cycles"
16:32:42 <SamB> mwc: it might need a fairly ANSI C.
16:32:46 <JohnMeacham> mwc: or even other OO languages with slightly different assumptions like sather.
16:33:31 <SamB> plan9 has its own ideas about C
16:33:47 <SamB> I mean, really, it is from Bell Labs, the home of C.
16:35:16 <SamB> then again, I think the UNIX compatability layer infolves another C compiler
16:35:47 <JohnMeacham> The C wasn't that different. I liked some of their extensions, I was surprised they didn't make it into gcc.
16:36:26 <SamB> I think plan9 C has mostly simplifications?
16:37:28 <JohnMeacham> they had some nice features dealing with unions that let you do OO style stuff in a exceedingly lightweight simple way.
16:38:06 <shapr> g'day Pseudonym!
16:38:13 <Pseudonym> G'day.
16:44:03 <stepcut> suck! I booted gnu/hurd/l4, but it does not recognize my shift key so I can press '?' for help
16:44:19 <Jerub> hah
16:44:35 <stepcut> well, maybe in another 10 years
16:44:35 <SyntaxNinja> stepcut: free software...
16:44:37 * SyntaxNinja shakes head
16:44:45 <SyntaxNinja> heh
16:45:06 <stepcut> granted, it is from 3/01/2005, so there might be a commit since then
16:45:26 <SamB> I thought you spelled help --help in GNU?
16:46:03 <ibid> only on the command line
16:46:23 <SamB> how about F1?
16:46:32 <SamB> C-h?
16:47:03 <stepcut> i hit escape to enter the debugger and now things seem to work
16:47:15 <dan2> mwc: I looked at all of the highly concurrent languages
16:47:18 <dan2> no were too appealing
16:47:21 <dan2> maybe erlang
16:50:47 <dan2> how does erlang know when to drop the crap out of memory
16:51:06 <Jerub> dan2: you mean garbage collection?
16:52:35 <JohnMeacham> I never saw the point in erlang, it is like Haskell without the wonderful type system.
16:52:43 <dustin`> I have a typeclass that is parameratized by two variables, 'a' and 'b', with 'a' in Eq.  I wanted to make the declaration of a method of type 'a -> a'.  I then wanted to use this in the default implementation of a method of type 'Intersections b -> a -> a'.  I get a type error....
16:52:57 <shapr> Erlang does have some goodies that aren't yet present in Haskell. But Haskell approaches quickly.
16:53:30 <dustin`> The error is 'Could not deduce (Reducable a b1) from the context (Reducable a b) arising from use of `optimize' at ./Quandle.hs:41:40-47'.  Reducable is the name of my two parameter type class.
16:53:44 <dustin`> Any clues?
16:54:20 <shapr> For example, Erlang is the king of runtime code upgrading. Rather than just allowing you to upgrade code at runtime, it also keeps the older version in memory as long as any code still has handles to it.
16:54:28 <SamB> JohnMeacham: well, haskell can apparantly only use one CPU...
16:54:30 <shapr> But, hs-plugins approaches...
16:54:33 <JohnMeacham> I also have a natural aversion to implementation defined languages. (rather than specification defined)
16:54:41 <shapr> SamB: That's soon to change also.
16:54:52 <JohnMeacham> SamB: that is a ghc thing. be assured, jhc will have no such limitation.
16:54:54 <SamB> shapr: how did they manage it?
16:55:11 <SamB> JohnMeacham: are you thunkless or something?
16:55:16 <shapr> Heck if I know. I looked at the code changes, but I don't yet understand them.
16:55:25 <shapr> JaffaCake is the person to ask.
16:55:46 <JohnMeacham> SamB: indeed. all thunks, higher order functions, and indirect jumps are transformed away before code generation.
16:55:56 <blackdog> shapr: could that just be a case of representing code as gc-ed data?
16:56:03 <shapr> I can barely wait to use it on my two cpu desktop!
16:56:23 <shapr> blackdog: If you mean keeping old code around until done, then yes.
16:56:28 <SamB> JohnMeacham: no wonder it takes so long to compile Hello World
16:57:04 <Pseudonym> The benefit of Erlang is that each thread has its own heap.
16:57:17 <Pseudonym> Which means they can be garbage collected or reaped separately.
16:57:32 <shapr> blackdog: dons said that something like Erlang-style upgrading is part of where hs-plugins is headed.
16:57:35 <Pseudonym> Or migrated across machines transparently.
16:57:46 <dustin`> My description might have been opaque.  Here is what breaks: http://www.cs.rit.edu/~dem5302/stuff
16:58:27 <blackdog> shapr: yeah, that'd be cool. :)
16:58:52 <shapr> dustin`: Do you have -fglasgow-exts or something else that allows multiparameter typeclasses?
16:59:02 * SamB is happy that he finally darcs got pugs
16:59:16 * SamB waits for patches to finish applying
16:59:27 <dustin`> shapr: I am.
17:00:18 <JohnMeacham> SamB: Indeed. however, a lot of that is due to a quadratic or perhaps exponential type inference algorithm.
17:00:50 <JohnMeacham> Sounds a little like the 'hoard memory allocator'.
17:00:57 * SamB wonders about pentadic algorithms
17:01:19 <Pseudonym> Hoard is broken,
17:01:21 <Pseudonym> Seriously broken.
17:01:29 <Pseudonym> We've been testing allocators here, and Hoard is definitely broken.
17:01:46 <JohnMeacham> Psuedonym: in what way?
17:02:10 <Pseudonym> In that it's not scalable.
17:02:13 <shapr> dustin`: Sorry, I don't know.
17:02:19 <shapr> dustin`: I'd ask on ghc-users if I were you.
17:02:20 <Pseudonym> And on rare occasions, crashes. :-)
17:02:39 <Pseudonym> BTW...
17:02:43 <Pseudonym> www.cs.utah.edu/~wilson/compilers/papers/pldi04-michael.pdf
17:02:45 <Pseudonym> Really nice paper.
17:03:14 <Pseudonym> It's an allocator which doesn't use locking at all.
17:03:25 <Pseudonym> And hence has less contention when you add more threads.
17:03:57 <JohnMeacham> Interesting. I will read it.
17:04:27 <Pseudonym> Google's tcmalloc also looks very interesting, but it's broken in the sense that it crashes a lot.
17:04:34 <Pseudonym> But it's very, very scalable.
17:05:30 <dustin`> shapr: okay, thanks anyway =)
17:05:50 <JohnMeacham> I am still debating the best way to do concurrency in jhc. my philosophy dictates that the primitives shall be simple wrappers around pthreads calls and a static analysis will determine where to place locks. I love those static analysises, but am getting a little tired of inventing new ones :)
17:05:52 <Pseudonym> Now the real test would be to also have concurrent lock-free garbage collection.
17:05:58 <shapr> dustin`: I think I've seen that error on ghc-users sometime in the last few months, but I don't remember anything about it.
17:06:09 <Pseudonym> JohnMeacham: I don't think you need locks.
17:06:12 <Pseudonym> Except perhaps for FFI.
17:06:30 <Pseudonym> Most CPUs support an atomic compare and exchange or compare and store operation.
17:07:17 <JohnMeacham> Psuedonym: that is what I mean by locks. an atomic compare and exchange still locks the cache line on the memory bus.
17:07:19 <Pseudonym> The only time concurrent threads touch each other is if they want to evaluate the same expression.
17:07:20 <SamB> isn't it pretty much necessary for reentrancy that they have one?
17:07:30 <Pseudonym> Ah, I see.
17:07:38 <Pseudonym> Well, I think it's the same as update analysis.
17:07:51 <mwc> JohnMeacham, well you're at it, how's the autovectorization support coming :P{
17:08:06 <JohnMeacham> It may be that jhc will accept some duplicated work if two threads try to "eval the same thunk". I wil
17:08:08 <Pseudonym> The circumstances under which you need locks are, in general, the same as those under which you need updates.
17:08:18 <JohnMeacham> have to see if this is a problem in practice.
17:08:27 <Pseudonym> Yes, I think it's a problem in practice.
17:08:34 <Pseudonym> If you use, for example, unsafeInterleaveIO.
17:08:48 <Pseudonym> Suppose you have the result of a readFile, and two threads try to evaluate a cons cell.
17:08:53 <Pseudonym> You'd have to be pretty careful there.
17:09:43 <JohnMeacham> Perhaps now you remember that huge war on the list I started because I was thinking of program transformations that might break the standard unsafePerformIO tricks :)
17:09:50 * Pseudonym laughs
17:09:55 <Pseudonym> :-)
17:10:02 <Pseudonym> Yeah, I remember being in that.
17:10:34 <Pseudonym> I think an easy option is if a thread atomically "acquires" the redex.
17:10:49 <Pseudonym> In a similar way that GHC does black hole detection.
17:11:08 <JohnMeacham> Yeah, there are definitly some real problems I will have to think about in order to get concurrency working the way I want. but I do believe something similar to update analysis combined with an escape analysis (to determine when a value can 'escape' to a different thread) will do the trick.
17:11:29 <Pseudonym> Then the other thread can either wait or do something else.
17:11:34 <mwc> JohnMeacham, personally, I'd say go ahead and make those transformation
17:11:56 <mwc> unsafe ops are unsafe
17:12:11 <Pseudonym> I _think_ that the transformations are fine so long as the compiler respects NOINLINE
17:12:11 <mwc> you shouldn't be using them and counting on them working even between point releases of a compiler
17:12:16 <JohnMeacham> mwc: I may. jhc is meant to research new ground. and I am perfectly okay with pursuing things that might turn out to be dead ends.
17:12:24 <Pseudonym> (And so long as it does let floating.)
17:12:35 <Pseudonym> (WHich you almost certainly do if you compile to supercombinators.)
17:13:04 <JohnMeacham> Yup.
17:14:01 <dan2> too bad haskell isn't a highly concurrent language
17:14:08 <Pseudonym> dan2: It could be.
17:14:14 <Pseudonym> This is the point. :-)
17:14:29 <mwc> I hate the news. "He was shot 4 times in the chest after a dispute over stolen marijuana. A post morterm confirmed he died of gunshots wounnds."
17:14:33 <mwc> No. FUcking. Shit.
17:14:48 <Pseudonym> He could have been strangled first.
17:14:52 <Pseudonym> You don't know that for sure.
17:14:59 <mwc> He happened to be out living it up until he got 4 holes in his chest.
17:15:09 <Pseudonym> It's not illegal to shoot a dead body AFAIK.
17:15:18 <mwc> Pseudonym, it is
17:15:19 <mwc> it's not a felony
17:15:30 <mwc> it's something about "desecrating a corpse"
17:15:36 <Pseudonym> Ah, OK.
17:15:57 <JohnMeacham> It is worse if there was a possible homicide. then you have evidence tampering too.
17:16:08 <mwc> true
17:16:12 <shapr> dan2: What counts as highly concurrent language to you?
17:16:13 <Pseudonym> Yeah.
17:16:40 <JohnMeacham> I am just trying to figure out what desecrating corpses has to do with concurrent languages.
17:16:49 * shapr doesn't want to know
17:16:51 <mwc> shapr, we've just been trying to convince him that single-process multiplexing
17:17:02 <mwc> isn't the be all end all
17:17:14 * dan2 likes single-process multiplexing
17:17:41 <mwc> It's an inefficient use of your time, IMHO
17:17:50 <mwc> then again,  I tend to write-run-discard
17:17:51 <dan2> its clean, its simple, its fast, and it enforces you to make your designs simpler
17:18:06 <mwc> It's clean and simple?
17:18:10 <shapr> dan2: Control.Concurrent has several options, some of which you may very much like.
17:18:28 <dan2> mwc: much easier than synchronizing threads
17:18:37 <dan2> then you bring on the ugly topic of IPC
17:18:37 <JohnMeacham> Personally, I'd like to leave it up to the OS to decide how to do concurrency and would hope it uses all the CPUs that are available.
17:18:44 <shapr> dan2: Especially after seeing what you liked about Erlang in the scrollback, I think you'll like Control.Concurrent.
17:19:16 <shapr> I'd rather go for declarative concurrency myself, explicit doesn't scale.
17:19:17 <mwc> dan2, that's the point of a currency-orientated language
17:19:18 <dan2> shapr: which parts of Control.Concurrent
17:19:44 <mwc> I'm going to go do some more illegal walking
17:19:44 <shapr> dan2: http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz
17:19:49 <mwc> against doctors orders
17:19:53 <mwc> adios
17:19:56 <Pseudonym> I agree that concurrency should be declarative.
17:20:03 <Pseudonym> Implicit concurrency doesn't really work.
17:20:06 * shapr was *not* tempted to say "break a leg"
17:20:14 <shapr> Really, I promise.
17:20:19 <Pseudonym> However, you still have the problem, in a lazy language, that two threads might want to evaluate the same thing.
17:20:29 <shapr> STM!
17:20:33 <Pseudonym> And that's what I've been thinking about.
17:20:37 <Pseudonym> No, that doesn't help/
17:20:44 <shapr> Why not?
17:20:45 <Pseudonym> Lazy evaluation.
17:21:00 <dan2> shapr: yes, I see it, which parts
17:21:01 <SamB> @vera STM
17:21:02 <Pseudonym> That's the problem.
17:21:04 <lambdabot> *** "stm" vera "Virtual Entity of Relevant Acronyms (Version 1.
17:21:04 <lambdabot> 9, June 2002)"
17:21:04 <lambdabot> STM
17:21:04 <lambdabot>      Synchronous Transfer Mode (ATM, SDH)
17:21:04 <lambdabot>  
17:21:05 <lambdabot> *** "stm" vera "Virtual Entity of Relevant Acronyms (Version 1.
17:21:07 <lambdabot> 9, June 2002)"
17:21:09 <dan2> shapr: forkIO looks interesting
17:21:09 <lambdabot> STM
17:21:11 <lambdabot>      System Master Tape
17:21:24 <Pseudonym> VERA isn't very R today.
17:21:38 <SamB> I see
17:22:00 <Pseudonym> Software Transactional Memory
17:22:16 <Pseudonym> STM is a good solution to the problem of data structures being concurrently updated, amongst other things.
17:22:23 <Pseudonym> But it doesn't solve the lazy evaluation problem.
17:22:30 <SamB> @google Software Transactional Memory
17:22:32 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
17:23:28 <shapr> dan2: You may also notice that the good points you described about Erlang are present, along with other options.
17:23:33 <Pseudonym> And here's another thought.
17:23:55 <dan2> shapr: where?
17:23:57 <Pseudonym> If you've done your strictness analysis, then when you enter some part of a supercombinator, you have a _set_ of things to evaluate.
17:24:52 <JohnMeacham> But after the worker-wrapper transform, when you enter a supercombinator everything you know you need to evaluate already has been.
17:24:54 <Pseudonym> If one of those is being evaluated by another thread, then you want to keep going evaluating what you can rather than waiting.
17:25:02 <Pseudonym> JohnMeacham: Yes.
17:26:24 <Pseudonym> No matter where you do it, you still have the same situation.
17:26:29 <shapr> dan2: Check out forkOS - http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
17:26:40 <Pseudonym> You almost always have more than one thing that needs to be evaluated.
17:26:57 <JohnMeacham> I'd say, after a case examination, you now have a new set of things to evaluate (based on the branch taken). Hmm.. I wonder if a program transform moving all evalutions to the beginning of case branches will be useful... (rambling)
17:27:00 <Pseudonym> Ideally, you only want to wait on other threads until after there's no more work you can do.
17:27:02 <SamB> okay, where can I apt-get ghc 6.4 from again?
17:27:18 <Pseudonym> And there's also the issue of thread cancellation.
17:27:28 <shapr> SamB: deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable
17:27:32 <dan2> shapr: thats for a system thread, which means 4mb vm stack and fork pain
17:27:48 <shapr> dan2: what's the difference between forkOS and forkIO?
17:27:49 <Pseudonym> If a thread is cancelled, it should release any shared redexes that it is working on.
17:27:53 <JohnMeacham> Hmm.. no higher order functions would ruin that transformation... at least at the core stage (still rambling)
17:28:27 <dan2> shapr: haskell runtime loses control of scheduling of operating system threads, as well as it has OS assigned memory and OS cost to fire up a thread
17:28:39 <dan2> shapr: thats why thread pooling is important for OS threads
17:29:18 <Pseudonym> I don't see why Haskell has to bother with scheduling.
17:29:24 <Pseudonym> The runtime, that is.
17:29:35 <Pseudonym> So long as it deals with synchronisation correctly.
17:29:37 <dan2> Pseudonym: if you're using ghc, it does nonblocking io for you
17:29:43 <dan2> which is a major benefit
17:29:53 <Pseudonym> But you can get that with OS threads, too.
17:29:53 <dan2> thus you need ghc doing the scheduling
17:30:13 <Pseudonym> The thread blocks, and another thread runs.
17:30:24 <dan2> Pseudonym: the os doesn't see it that way
17:30:37 <JohnMeacham> dan2: but ghc's concurrency primitives could just as well be implemented on OS threads. then it need not do scheduling.
17:30:37 <dan2> Pseudonym: most cases, OS schedules them all same priority
17:30:56 <Pseudonym> Sure it does.  If a thread is blocked on I/O, then it is made not runnable by the OS, and something else runs instead.
17:31:01 <Pseudonym> OK, thread priorities are a different matter.
17:31:29 <dan2> Pseudonym: the big bite in the ass is the costs of firing up and destroying os threads
17:31:35 <dan2> and their runtime costs
17:31:50 <Pseudonym> That's a fair point.
17:32:03 <Pseudonym> So yes, you do want to keep a pool of threads.
17:32:07 <dan2> right
17:32:08 <SamB> you know, that 4mb of stack could be mostly the zero page.
17:32:08 <shapr> GHC has an OS thread pool, any thread ready to run can grab one.
17:32:15 <Pseudonym> But you don't necessarily want to multiplex Haskell threads on OS threads.
17:32:25 <dan2> :)
17:32:29 <dan2> shapr: wheres that?
17:32:46 <shapr> But, that causes problems with stuff like OpenGL where TLS is required.
17:33:28 <Pseudonym> AH, that's another issue.
17:33:34 <Pseudonym> OpenGL is not a declarative API.
17:33:50 <dan2> shapr: alright so where is the ghc thread pool
17:33:54 <shapr> That's why forkOS was added, so you can deal with TLS requirements.
17:34:09 <SamB> shapr: nasty!
17:34:22 <SamB> nothing like that should require TLS
17:34:57 <shapr> dan2: It's mentioned in the docs of Control.Concurrent - http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Concurrent.html
17:35:01 <dan2> the most decent thing you get from system threads is that it can take use of smp
17:35:24 <Pseudonym> Here's the way I'd model OpenGL, by the way.
17:35:30 <SamB> @docs Control.Concurrent
17:35:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.
17:35:31 <lambdabot> Concurrent.html
17:35:38 <shapr> Oh, handy command.
17:35:50 <Pseudonym> A new synchronisation primitive, which runs some code in a specific thread context.
17:35:50 <shapr> Too bad it gets split
17:36:13 <JohnMeacham> I am a big anti-fan of user level threads. I think they cause more problems than they solve, especially when you have these nice system threads.
17:36:20 <Pseudonym> Say this...
17:36:29 <Pseudonym> newRendezvous :: IO Rendezvous
17:36:46 <Pseudonym> rendezvous :: Rendezvous -> IO a -> IO a
17:36:53 <Pseudonym> That's the basic set of operations.
17:37:14 <Pseudonym> When you call rendezvous, it suspends the current thread, and then runs the IO operation passed in the context of ANOTHER thread.
17:37:20 <SamB> @todo
17:37:21 <lambdabot> 0. dons: Release lambdabot 3.0
17:37:21 <lambdabot> 1. SamB: A way to get multiple results from a google search
17:37:21 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
17:37:21 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
17:37:21 <lambdabot> the command was given on
17:37:22 <lambdabot> 4. SamB: stop mangling long urls
17:37:24 <lambdabot> 5. dons: improve formatting of @dict
17:37:26 <lambdabot> 6. SamB: @karma+ should report total karma
17:37:33 <Pseudonym> So it's like a mutex.
17:37:42 <dan2> JohnMeacham: system threads are expensive if you don't manage them well
17:37:43 <Pseudonym> You can implement it using MVars and Concurrent.Chan.
17:37:44 <shapr> SamB: ah, I see.
17:37:59 <Pseudonym> By passing the IO operation down the channel.
17:38:21 <JohnMeacham> dan2: I think that is a common myth.
17:38:37 <Pseudonym> I think it was true once.
17:39:02 <Pseudonym> Especially in the open source world, back when OSes were immature.
17:39:16 <Pseudonym> Linux never had real threads until 2.6, for example.
17:39:19 <SamB> JohnMeacham: in the thousands they seem likely to be expensive
17:39:21 <dan2> its only a myth until recently when linux got a major smp upgrade in 2.6
17:39:32 <dan2> erm it became a myth recently
17:39:53 <dan2> nptl has good threads
17:39:59 <Pseudonym> But threads in Solaris and Windows haven't been expensive for a LONG time now.
17:40:12 <Pseudonym> Unless you had thousands of them, as SamB said.
17:40:32 <Jerub> mmmsmp
17:40:45 <Pseudonym> Mmmm... ccNUMA.
17:40:59 <dan2> L4 Pistachio has _AMAZING_ SMP
17:41:00 <Pseudonym> Free cakes.  BBL
17:41:01 <JohnMeacham> dan2: and the huge complexity increase of user level threads is not worth just working around an OS problem. it would make more sense to work on making OS threads faster.
17:41:18 <Jerub> dan2: does it? is it any good on >100 cpus?
17:41:33 <SamB> so how do I get these nptl threads? do I need to do anything beyond run 2.6?
17:41:43 <dan2> Jerub: I'm not sure its been tested that far yet, but the entire kernel was written to run lots of lwp
17:41:58 <dan2> Jerub: it has a kernel integrated IPC system which is defined as the best
17:42:11 <JohnMeacham> Which is why we link against the super-secret alternat solaris threads library that just does a straight one-to-one mapping of progam to OS threads and see immediate performance improvements.
17:42:13 <dan2> lowest latency IPC... ever
17:42:39 <dan2> alright
17:42:40 <Jerub> dan2: interesting.
17:42:55 <Jerub> dan2: I might suggest to the correct people that they attempt to run it on their altix.
17:42:56 <dan2> Jerub: gnu hurd is being ported to it
17:43:10 <Jerub> yeah, I spent most of last week hanging around imajica.
17:43:20 <Jerub> and he was being a hurdish person.
17:43:45 <dan2> if hurd actually went somewhere... it would be a decent os
17:43:50 <JohnMeacham> This is a good book: http://www.amazon.com/exec/obidos/tg/detail/-/0201633388/002-8320632-1048038?v=glance
17:43:53 <Jerub> dan2: yes.
17:43:54 <shapr> I think ccNUMA is a waste.
17:44:10 * shapr kicks his ccNUMA box
17:44:22 <shapr> ow
17:44:24 <Jerub> dan2: but unfrotunately, people like that are the complete opposite to people who run ubuntu
17:44:31 <Jerub> hurd+ubuntu would kick arse.
17:44:45 <dan2> hurd needs a lively community
17:44:57 <dan2> I don't think I've seen anybody lazier than hurd developers and users
17:45:41 <SamB> Ubuntu GNU/Hurd, huh.
17:46:33 <Jerub> SamB: consider that the ubuntu cds mention the word linux twice, and gnu zero times. ;)
17:46:37 <dan2> microkernels are supposed to be a good thing, however, the most known microkernel, is also the largest failure
17:46:39 <dan2> NT
17:47:09 <Jerub> bah, the NT microkernel is fine.
17:47:16 <SamB> dan2: NT is not a microkernel, it is a failed attempt at a microkernel
17:47:17 <Jerub> its everything ELSE that sucks.
17:47:22 <dan2> SamB: as I thought
17:47:24 <Jerub> ;)
17:47:35 <Jerub> OSX is a good example of a microkernel in action
17:47:45 <Jerub> (speaking of which, tigertigertiger)
17:48:05 <SamB> sure, there might be the makings of a microkernel in there somewhere, but its not micro if it is monolithic, which it is
17:48:28 <dan2> Jerub: OSX isn't a microkernel
17:48:41 <dan2> OSX is 95% BSD and 5% Mach
17:48:49 <SamB> now plan9's kernel, might be a microkernel, but the plan9ers could care less one way or the other
17:49:43 <JohnMeacham> Eh, micro vs. monolithic is a nonsense issue nowadays. like RISC vs. CISC. the best ideas cross polinate between paradigms and the result cannot really be classified.
17:49:51 <SamB> dan2: what about the NeXTStep and Aqua and Other percents?
17:50:38 <JohnMeacham> OSX is very much NeXTStep on the inside. which is nice. I still have my NeXTCubes.
17:50:51 <Jerub> yay ubuntu
17:51:03 <Jerub> the irc channel doesn't care that the latest kernel in hoary doesn't boot on my system.
17:51:43 <shapr> I very much wish that I could get a Cell workstation. I'd love to get some GHC declarative parallelism working on that.
17:51:45 * SamB wonders when he is going to get his free ubuntu CDs
17:52:09 * dan2 has a dual opteron with 4G of ram
17:52:11 <dan2> any questions?
17:52:12 <dan2> :)
17:52:20 <Jerub> SamB: they were handing them out at linux.conf.au
17:52:20 <shapr> dan2: bah, only two cores?
17:52:25 * shapr grins evilly
17:52:30 <dan2> shapr: for a workstation, yes
17:53:10 <SamB> Jerub: mine are coming in the mail, and .au is a bit far from home for that to be "free" for me
17:53:14 <shapr> I think 2304 is a fine number of cores for a workstation.
17:54:16 <SamB> shapr: I don't even have 2304 procs
17:54:26 <shapr> Right, that's part of my point in recent emails.
17:54:36 <shapr> Thread based parallelism doesn't scale.
17:54:50 <SamB> Tasks: 129 total,   1 running, 127 sleeping,   0 stopped,   1 zombie
17:55:09 <SamB> shapr: on what list?
17:56:02 <shapr> The Cell cpu has nine cpu cores in a 'single core' design. The Cell roadmap goes up to 64 'single cores'. Now, what about 64 'single cores' on a four socket motherboard?
17:56:47 <Jerub> dan2: my wife works for the geology dept at UQ now.
17:56:56 <Jerub> dan2: they have a 208cpu altix...
17:56:58 <shapr> So, how would you change the software industry so that it can happily deal with 2304 cores in less than ten years?
17:56:59 <dan2> I don't think multi core cpus are quite as good multiple cpus
17:57:09 <Jerub> dan2: I'm seriously interested in l4 now
17:57:09 <shapr> dan2: how so?
17:57:14 <Jerub> dan2: huh?
17:57:25 <Jerub> multicore cpus allow for faster communication between processors
17:57:29 <shapr> It's not cache stuffing like hyperthreading...
17:57:34 <dan2> shapr: limitations on the processor itself
17:57:38 <shapr> Like what?
17:57:52 <dan2> you lose bus speed between processors no?
17:57:56 <dan2> cores even
17:58:01 <shapr> No, you get better speed between cores.
17:58:29 <dan2> not if they're using the same bus to get to the memory banks
17:58:40 <shapr> The first Intel designs are forced to use the external bus to talk to each other, but the AMD designs talk to each other on their internal bus, which is much faster.
17:58:58 <Cale> 2^8 3^2?
17:59:26 <dan2> 256 * 9?
18:01:19 <shapr> dan2: AMD designs don't use the same bus for memory and neighbors.
18:02:01 <shapr> The Cell does, only the strawboss talks directly to memory, though the sidekick cpus can talk to memory via DMA
18:04:55 <shapr> SamB: Actually, on lambda-the-ultimate.org and on perlmonks.org
18:39:40 <monochrom> @plugs 1+1
18:39:45 <lambdabot> 2
18:40:02 <monochrom> Damn, it is no longer using notify? :)
18:42:17 <dons> no longer. is that a problem?
18:42:31 <dons> (it causes too many people configuration issues unfortunately)
18:44:06 <monochrom> It is not a problem for me.
18:44:48 <Cale> I'm quite surpised that so many IRC clients could be that broken.
18:44:56 <Cale> surprised*
18:45:01 <dons> I think it was gaim in particular
18:45:11 <monochrom> I wonder what kind of "people" are in "too many people".
18:45:25 <dons> and there was a general consensus that newbies shouldn't have to reconfigure stuff to use #haskell
18:45:41 <monochrom> newbies need not use lambdabot...
18:45:41 <Cale> gaim is free software isn't it? Could it just be fixed?
18:45:43 <JohnMeacham> How would people feel about a pointless case? where 'case of Foo -> x' is equivalant to '\z -> case z of Foo -> x' for some unique z.
18:46:15 <Cale> monochrom: I think that whenever anyone used lambdabot they got an annoying popup box or something
18:46:22 <dons> monochrom, they still see the output, then complain.. anyway, I wanted notices originally. but it doesn't matter that greatly
18:47:03 <Cale> does anyone know what exact behaviour is caused in gaim? I'll submit a bug
18:47:24 <monochrom> newbies can also complain about the purity of haskell.  We will also succumb to their will yeah.  You see the value of a barrier to entrance?
18:47:45 <Cale> hehe
18:49:17 <Sonarman> JohnMeacham: sounds nice :)
18:49:23 <monochrom> I don't mind the ways lambdabot outputs.  I mind the opinion of the dumb majority.
18:49:44 <Sonarman> then you could also do someAction >>= case of ...  instead of do x <- someAction; case x of
18:50:03 <Sonarman> the first do isn't part of the code, of course :)
18:50:26 <Cale> well, it's not really that the people are dumb, it's that their IRC clients are
18:50:26 <JohnMeacham> Yeah, on the right side of >>= is where I always want this sort of thing.
18:50:40 <dons> yes. it's the clients that we have problems with.
18:51:15 <dons> as soon as gaim is fixed, and is reasonably easy to configure, I'll probably turn notices back on
18:51:32 <JohnMeacham> "IRC is a pretty dumb protocol."
18:51:43 <monochrom> Let me sum it up by saying: I admire the OCaml people when they say: we won't make everything to work on Windows, Windows is broken, so what if everyone uses it.
18:51:44 <dons> :D
18:52:22 <dons> monochrom, I'm of that opinion as well ;)
18:52:27 <dons> @version
18:52:27 <lambdabot> lambdabot 2p428, GHC 6.4 (OpenBSD i386)
18:52:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:53:47 <JohnMeacham> Well, I might as well implement and see who complains more, people missing it in ghc, or people complaining of vanity syntatic sugar in jhc.
18:54:21 <monochrom> notify was invented to break an infinite loop.  I'm thinking it's a poor solution.
18:55:40 <SamB> they should take notify out, neither the "rough consensus" nor the "running code" part is really there...
18:55:53 <SamB> or at least, change what it is supposed to be fore
18:55:58 <Pseudonym> back.
18:56:25 <Igloo> JohnMeacham: If you do implement that sort of thing can it require a flag to enable it or have a flag to disable it please? (a single flag to disable the whole lot if you go that route)
18:56:38 * Pseudonym reads back
18:56:49 <Pseudonym> NT isn't a microkernel.  Microsoft has come out and admitted it.
18:57:03 <Pseudonym> OTOH, WinCE, QNX and ChorusOS are doing just fine as microkernel OSes.
18:59:00 <Jerub> so is L4/pistachio from what I've been told.
18:59:27 <JohnMeacham> Igloo: definitly.
18:59:37 * SamB wonders how to find all the Haskell packages he has compiled which will no longer work and remove them?
18:59:40 <Igloo> Cool, thanks
19:01:13 <JohnMeacham> Igloo: Although, I wish I were using a monadic parser rather than a happy one. it is sort of hard to have alternate parse strategies in happy... this is an easy one to just check for since it doesn't conflict with valid haskell, but other extensions are not so easy...
19:01:32 <Pseudonym> L4 I don't think has a lot of commercial use at the moment.
19:01:36 <Igloo> happy can give you a monadic parser
19:01:37 <Pseudonym> But it's a very clever design.
19:01:42 <Pseudonym> And I think it will go far.
19:02:05 <Igloo> Although I'm not sure OTTOMH if it can fail in the way you'd want
19:02:36 <SamB> @google L4/pistachio
19:02:38 <lambdabot> http://l4ka.org/
19:03:44 <JohnMeacham> Oh, I meant a hand-written one that I can modify. like a Parsec one.
19:05:22 <JohnMeacham> Does anyone behind EHC hang out here?
19:05:47 <JohnMeacham> I heard it also uses boquist's evaluation model, but there isn't a lot of info on the compiler.
19:06:46 <JohnMeacham> In particular I heard rumblings they extended boquist's GRIN with exceptions, which i would be very interested in.
19:10:04 <monochrom> I can hand-write monadic parsers for you at US$5 per token.
19:10:23 <JohnMeacham> I am also a little unclear on the relationship between UHC, EHC and Helium..
19:10:50 <JohnMeacham> I can write my own parsers thank you :)
19:11:23 <monochrom> I need a fair measure of the complexity of parsers so I can charge fairly.  Counting tokens isn't fair.
19:11:23 <SamB> monochrom: $5 per token written by you?
19:11:49 <monochrom> Yes, but I understand it isn't fair.
19:11:57 <Igloo> UHC got rewritten as EHC, I think
19:13:59 <JohnMeacham> I see. Hmm. Perhaps I need to figure out what an 'attribute grammar' is.
19:14:43 <JohnMeacham> uu.nl seems keen on them.
19:17:15 <JohnMeacham> hmm.. 'ag' files everywhere...
19:18:42 <reffie> hi
19:18:51 <reffie> is there a way to do non-integral powers in haskell?
19:19:02 <reffie> like 5^2.3, for example
19:19:41 <Igloo> **
19:19:43 <monochrom> @plugs 2.0**2.0
19:19:44 <lambdabot> 4.0
19:20:14 <reffie> ah, thanks
19:20:26 <monochrom> My example is designed to prove nothing.
19:20:39 <reffie> i guess i should read the prelude more carefully
19:21:25 <JohnMeacham> In fairness Haskell does have an unusual preponderance of exponentiation operators.
19:21:35 <monochrom> We should host a prelude contest.
19:22:29 <monochrom> prelude contest = see who can recall the most of the prelude.
19:24:36 <NooKe> evening (Or maybe morning) all
19:25:05 <NooKe> And I guess nobody but me is alive in here. :(
19:25:17 <monochrom> That is correct.
19:25:24 <NooKe> Oh,hi
19:25:45 <NooKe> I was in need of some help so I (stupidly) though I might find some in here at this tme
19:26:54 <JohnMeacham> Well, this time is different for most of us here, being an international group of folks.
19:27:46 <NooKe> OK. I just needed an answer to a question I stumbled upon to programming at the moment, maybe some of you might help
19:29:05 * Lemmih wonders when NooKe is gonna ask the question.
19:29:29 <JohnMeacham> Ask and see.
19:29:50 <NooKe> Well I'll ask feel free to answer. I have a [IO [FilePath]] and a function ([String] -> Int), I need to map them (map function list)
19:30:03 <NooKe> I have been trying to fix that but no luck
19:30:49 <Pseudonym> @type fmap
19:30:50 <lambdabot> fmap :: forall (f :: * -> *) b a.
19:30:50 <lambdabot>         (Functor f) =>
19:30:50 <lambdabot>         (a -> b) -> f a -> f b
19:31:12 <NooKe> Nice. Will try it right away
19:31:16 <Pseudonym> let f :: [String] -> Int = undefined in fmap f
19:31:25 <Pseudonym> Note that IO is a Functor.
19:31:31 <Pseudonym> @type let f :: [String] -> Int = undefined in fmap f
19:31:33 <lambdabot> let f :: [String] -> Int = undefined in fmap f :: forall (f ::
19:31:33 <lambdabot> *
19:31:33 <lambdabot>  
19:31:33 <lambdabot> -> *).
19:31:33 <lambdabot>                                                   (Functor f)
19:31:33 <lambdabot> =>
19:31:35 <lambdabot>                                                   f [String] -
19:31:37 <Pseudonym> Eeek.
19:31:37 <lambdabot> > f Int
19:31:39 <Pseudonym> That layout
19:32:22 <ozone> printing the expression you just entered in seems kind of redundant, no?
19:32:33 <ozone> in the result of the @type (or :t), i mean
19:34:48 <NooKe> not in scope f?
19:34:54 <Pseudonym> Errrr.
19:35:07 <Pseudonym> "and a function ([String] -> Int)"
19:35:14 <Pseudonym> OK, quick question.
19:35:26 <Pseudonym> You said you have [IO [FilePath]]
19:35:27 <SamB> ozone: maybe, but getting the rest of the output to look nice would still need to be done
19:35:33 <Pseudonym> What do you want the result to be?
19:35:40 <NooKe> Here is the code. Simple
19:35:40 <NooKe> let rightList = map (\a -> "./" ++ a) list
19:35:40 <NooKe> 	      let finalList = map (\b -> getDirectoryContents b) rightList
19:35:40 <NooKe> 	      let f :: [String] -> Int = undefined in fmap f
19:35:40 <NooKe> 	      let bigger = f getFileLength finalList
19:35:55 <NooKe> list is [String]
19:36:01 <Pseudonym> Errrr.
19:36:07 <Pseudonym> I only meant that as an example.
19:36:12 <Pseudonym> Of the type system.
19:36:16 <NooKe> Oh sorry
19:36:20 <NooKe> Newbie here
19:36:24 <Pseudonym> 'Sokay.
19:36:25 <Pseudonym> OK.
19:37:27 <Pseudonym> What you have is a list of FilePaths.
19:37:41 <Pseudonym> What do you want to turn that into?
19:38:57 <NooKe> Yes, a list of strings which are filepaths. Every path has inside a file and I need to find the longgest filename of all of them
19:39:21 <NooKe> That is why getFileLength will simply check the filename length and return as Int
19:39:31 <Pseudonym> @type maximum
19:39:34 <lambdabot> maximum :: forall a. (Ord a) => [a] -> a
19:39:36 <NooKe> Yes I know
19:39:40 <Pseudonym> OK.
19:39:49 <NooKe> But first I need a list with all the files lengths
19:40:01 <Pseudonym> Hang on, you said "the longest filename".
19:40:04 <NooKe> And that is where I am stuck
19:40:07 <Pseudonym> Did you mean that or the largest file?
19:40:17 <SamB> what is this, homework?
19:40:29 <NooKe> No homework, own project
19:40:32 <Pseudonym> SamB: Seems unlikely if it uses IO heavily.
19:41:14 <Pseudonym> So are you after the largest file or the longest filename?
19:41:19 <NooKe> I have 200 folders in my pc, every folder has one file inside I simply want to know which of the files has the longest filename
19:41:36 <Pseudonym> Aaaah, okay.
19:41:40 <Pseudonym> @type getDirectoryContents
19:41:40 <SamB> Pseudonym: well, that was with the filename length thing...
19:41:41 <lambdabot> bzzt
19:41:44 <Pseudonym> Hmmm.
19:41:46 <NooKe> Btw do you really think I'd sit with homework at this time. :P
19:42:05 <Pseudonym> NooKe: It's 1pm here.
19:42:05 <Pseudonym> So maybe.  Depends where you are.
19:42:12 <Pseudonym> @type Control.Monad.mapM
19:42:12 <Pseudonym> Try that.
19:42:13 <lambdabot> Control.Monad.mapM :: forall b (m :: * -> *) a.
19:42:13 <lambdabot>                       (Monad m) =>
19:42:13 <lambdabot>                       (a -> m b) -> [a] -> m [b]
19:42:15 <NooKe> Oh, forgot that. it is almost 5:00 here
19:42:16 <Pseudonym> Look at the type.
19:42:27 <Pseudonym> It's pretty close to what you want.
19:42:36 <Pseudonym> (Substitute IO for m everywhere in the type.)
19:43:04 <Pseudonym> What's the type of getFileLength?
19:43:14 <NooKe> [String] -> Int
19:43:21 <Pseudonym> Really?
19:43:23 <Pseudonym> Hmm.
19:43:36 <Pseudonym> getFileLength = maximum . map length
19:43:38 <Pseudonym> Is that right?
19:44:16 <NooKe> Not really. It looks for the right filename and gets size, but if you wanna see how I did it.....
19:44:22 <NooKe> getFileLength :: [String] -> Int	
19:44:22 <NooKe> getFileLength [] = 0
19:44:22 <NooKe> getFileLength (x:xs)
19:44:22 <NooKe> 	  |isSuffixOf ".xml" x = (length x) - 4
19:44:22 <NooKe> 	  |otherwise = getFileLength xs
19:44:38 <SamB> NooKe: why is that?
19:44:50 <NooKe> Why is what?
19:45:03 <reffie> hm
19:45:12 <reffie> what's the difference between Int and Integer?
19:45:34 <Pseudonym> reffie: Integer is unlimited precision.  Int is a machine word (I think).
19:45:37 <NooKe> Not really sure either, but length returns Int so I used it instead of integer
19:45:37 <SamB> NooKe: well, I meant about the type of getFileLength, but it works with the code too ;-)
19:45:39 <Pseudonym> (It might be bigger.)
19:46:05 <SamB> Pseudonym: Int is generally a machine word, I'm sure
19:46:11 <Pseudonym> I agree.
19:46:18 <Pseudonym> But, for example, it might be 32 bits on a 64 bit CPU.
19:46:26 <Pseudonym> Depending on the implementation.
19:46:28 <Pseudonym> But this is details.
19:46:46 <reffie> can you have an unlimited precision float?
19:46:48 <Gahhh> min 29 bits per the report iirc
19:46:52 <NooKe> Anyway I am still stuck here, you said to put m, but what exactly is m? Do you mean to change getFileLength to [String] -> m Int?
19:46:57 <SamB> would a filesystem support 4 GiB filenames anyway?
19:47:00 <Pseudonym> reffie: Yes, but you can't compare them for equality.
19:47:16 <reffie> Pseudonym i just need to make sure that it isn't an integer
19:47:19 <Pseudonym> (By "float", I assume you meant "real number".)
19:47:41 <Pseudonym> NooKe: What does getFileLength do?
19:47:44 <reffie> SamB the name itself is 4GB long?
19:47:49 <reffie> SamB or the file?
19:47:54 <Pseudonym> Ooh, I see.  Duh.
19:48:04 <SamB> reffie: the name!
19:48:19 <Pseudonym> getFileLength xss = [ length xs - 4 | xs <- xss, isSuffixOf ".xml" xs ]
19:48:20 <SamB> although with 29 bits, it would be a bit smaller than that
19:48:22 <Pseudonym> Right.
19:48:27 <Pseudonym> Uhm...
19:48:28 <Pseudonym> No!
19:48:30 <SamB> like, 512 MiB
19:48:30 <reffie> SamB the path name can't be more than 256 bytes long, in unix
19:48:33 <Pseudonym> Not quite.
19:48:39 <reffie> iirc
19:48:42 <ozone> reffie: maybe a Rational would be suitable for you
19:48:44 <Pseudonym> NooKe: Let me ask again, what does it do?
19:49:01 <reffie> ozone i need to be able to raise them to some non-integer power, though
19:49:14 <NooKe> It takes a [String] which is the list of all files inside the directory, looks the xml file and returns it's length
19:49:16 <ozone> reffie: ah
19:49:31 <Pseudonym> You're assuming there's only one xml file in the directory, right?
19:49:39 <NooKe> There is only one
19:49:47 <Pseudonym> OK.
19:49:57 <reffie> "filter isInteger [n^(1/k) | k <- [1.. log_2(n)]]" is what i'm trying to do
19:49:58 <Pseudonym> What's the type of getDirectoryContents?
19:50:15 <Gahhh> IO [string]
19:50:20 <reffie> where isInteger x returns true when x is an integer
19:50:34 <NooKe> That is Haskell's inbuilt in the Directory package, It returns IO [FilePath] I think
19:50:40 <SamB> reffie: that only seems to apply to individual path components
19:50:46 <Pseudonym> What's the type of the function as a whole?
19:50:49 <Pseudonym> Not just what it returns.
19:50:58 <SamB> >>> f2 = file('/tmp/' + 'x'*256, 'w')
19:51:04 <SamB> Traceback (most recent call last):
19:51:04 <SamB>   File "<stdin>", line 1, in ?
19:51:04 <SamB> IOError: [Errno 36] File name too long: '/tmp/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
19:51:04 <SamB> >>> f2 = file('/tmp/' + 'x'*255, 'w')
19:51:05 <SamB> >>>
19:51:13 <Pseudonym> @type getDirectoryContents
19:51:15 <lambdabot> bzzt
19:51:22 <Pseudonym> @type GHC.IO.getDirectoryContents
19:51:23 <lambdabot> bzzt
19:51:26 <Pseudonym> Hmmm.
19:51:35 <NooKe> Filepath -> IO [FilePath]
19:51:39 <Pseudonym> Right.
19:51:43 <Pseudonym> OK.
19:51:48 <reffie> SamB my bad
19:51:53 <Pseudonym> So looking at mapM above.
19:51:54 <reffie> the pathname limit is 1024
19:51:59 <Pseudonym> @type Control.Monad.mapM
19:52:01 <lambdabot> Control.Monad.mapM :: forall b (m :: * -> *) a.
19:52:01 <lambdabot>                       (Monad m) =>
19:52:01 <lambdabot>                       (a -> m b) -> [a] -> m [b]
19:52:04 * SamB would like to point out that he is downloading GHC 6.4 over dialup and is therefore lagged
19:52:05 <NooKe> Yeah got that
19:52:19 <Pseudonym> What module is getDirectoryContents in?
19:52:23 <reffie> SamB at least here on FreeBSD
19:52:25 <NooKe> Wia ti Get getFileLength :: [String] -> Int	
19:52:25 <NooKe> getFileLength [] = 0
19:52:25 <NooKe> getFileLength (x:xs)
19:52:25 <NooKe> 	  |isSuffixOf ".xml" x = (length x) - 4
19:52:25 <NooKe> 	  |otherwise = getFileLength xs
19:52:30 <NooKe> Damn sorry
19:52:42 <NooKe> I get
19:52:43 <NooKe> ((a -> m b) -> [a] -> m [b]))
19:52:43 <NooKe> `print' at Top level
19:52:52 <Pseudonym> Right.
19:53:15 <NooKe> What is m?
19:53:22 <NooKe> That's what I don't get it?
19:53:35 <Pseudonym> Hang on and I'll show you.
19:53:38 <Pseudonym> What module is getDirectoryContents in?
19:53:43 <NooKe> Directory
19:53:55 <NooKe> Oh m is monad isn't it? Damn I never got around those
19:54:05 <Pseudonym> m is a polymorphic type variable
19:54:09 <Pseudonym> Just like a or b
19:54:16 <NooKe> oh I see
19:54:28 <Pseudonym> @type Control.Monad.mapM System.Directory.getDirectoryContents
19:54:30 <lambdabot> Control.Monad.mapM System.Directory.getDirectoryContents :: [FilePath]
19:54:30 <lambdabot> -> IO [[FilePath]]
19:54:34 <Pseudonym> Bingo.
19:54:44 <Pseudonym> Does THAT help?
19:54:58 <Pseudonym> mapM getDirectoryContents :: [FilePath] -> IO [[FilePath]]
19:55:17 <SamB> hmm, Linux doesn't have a 1024 pathname limit
19:55:42 <SamB> hydrogen:/home/naesten# mkdir -p $(python -c 'print ("/"+"x"*255)*4')/x
19:55:43 <NooKe> Sorry just thinking here
19:55:46 <NooKe> One sec
19:55:50 <SamB> hydrogen:/home/naesten#
19:56:36 <NooKe> You know. I t just might. Give a me sec to test
19:58:09 <NooKe> Nicde
19:58:16 <NooKe> Nice, It did compile
19:58:55 <SamB> in fact, "mkdir -p $(python -c 'print ("/"+"x"*255)*128')/x" ran just fine just now
19:59:02 <NooKe> Oh, I see. IO is also a type (I supposed) which is where m comes in
19:59:12 <SamB> which is
19:59:32 <SamB> @plugs 256*128
19:59:33 <lambdabot> 32768
20:00:03 <Pseudonym> Right.
20:00:15 <Pseudonym> NooKe: The difference between "m" and "a" is its "kind".
20:00:20 <Pseudonym> Kinds are the types of types.
20:00:22 <SamB> and then two more
20:00:28 <Pseudonym> But that's another topic.
20:00:40 <Pseudonym> Intuitively, "m" needs an argument to make it a full-fledged type.
20:00:54 <Pseudonym> Anyway, lunch.
20:00:55 <NooKe> Thanks. Always nice learning.
20:00:55 <Pseudonym> BBL
20:01:01 <NooKe> Thanks a lot. Cya
20:01:51 * SamB cleans up all these xxxxx* directories
20:18:43 <stang> Hey guys!  Can someone help me out with the runhugs program?  I'm trying to create a standalone program to test different implementations of a data structure written in haskell by using the GNU time program.  However, I'm not too familiar w/ haskell...
20:20:46 <stang> I have the data structure implementations (in .hs form) saved in /usr/lib/hugs/libraries, along with a .lhs file that they rely on.  I am just having trouble getting a seperate program to work with runhugs so that I can test the implementations.
20:23:25 <Cale> stang: hm? What are you trying on the commandline?
20:23:52 <stang> ./myexe.hs
20:23:53 <Cale> (or what do you mean by "getting a separate program to work with runhugs")
20:24:08 <stang> well... I only have one command to run
20:24:28 <stang> haha... it's really very simple, I'm just too dumb to figure it out
20:24:30 <Cale> and the first line of ./myexe.hs looks like "#! /usr/bin/runhugs" or some such?
20:24:36 <stang> it does look like that
20:25:14 <stang> and then the next line is:  import SearchTree
20:25:35 <Cale> do you get an error message?
20:25:35 <stang> the SearchTree.hs file is what contains the implementation
20:25:52 <stang> Module "main" already loaded
20:26:21 <stang> all i have to do is run:  btst 100
20:26:35 <stang> which is in the SearchTree.hs file
20:26:50 <Cale> what does the start of SearchTree.hs look like?
20:26:56 <Cale> module SearchTree where ?
20:27:26 <stang> it imports an .lhs file
20:28:13 <stang> and then it has a bunch of definitions and such... no modules or anything
20:28:20 <Cale> If your program has multiple modules then you have to start them with module declarations.
20:28:32 <Cale> (otherwise, the module name defaults to Main)
20:28:34 <Gahhh> I dont think it's his program
20:29:09 <stang> it's not my implementation
20:29:17 <Cale> so try adding "module SearchTree where" as the first line of SearchTree.hs
20:29:22 <stang> ok
20:30:30 <stang> Gahhh, we have to play around with the different implementations and graph the differences, and I was just trying to come up with a fancy way to time the execution (the others are using stopwatches)
20:31:12 <Gahhh> stopwatches and haskell are at the opposite ends of the spectrum heh
20:31:18 <Cale> stang: you could write a Haskell program to test them too
20:31:43 <stang> Well I would like to, but like I say, I haven't dove into haskell too much
20:32:21 <stang> The professor uses haskell notation and the such, but we don't really use haskell past that
20:32:35 <Gahhh> I think you can also call runhugs directly like "runhugs myprog.hs".
20:32:49 <Gahhh> or "time runhugs myp.hs"
20:33:04 <stang> yeah, time runhugs myp.hs was my plan
20:33:42 <stang> but i needed a file to execute the test portion of the .hs file he supplied us
20:33:56 <stang> and I didn't know that runhugs existed until earlier today
20:34:16 <Gahhh> ah
20:34:39 <stang> does all that make sense? haha
20:34:54 <Gahhh> yeah
20:36:09 <Cale> You could do something like import System.CPUTime and then have main = do { t <- getCPUTime; ...tests...; t' <- getCPUTime; putStrLn ("Computation took " ++ show (t' - t) ++ "+-" ++ cpuTimePrecision ++ " picoseconds.") }
20:36:32 <stang> well... i added "module searchtree where" at the top of the SearchTree.hs file and it's giving the error: ERROR "/usr/lib/hugs/libraries/SearchTree.hs":8 - Syntax error in input (unexpected symbol "searchtree")
20:36:47 <Gahhh> oops
20:36:53 <Cale> SearchTree with capital S and T.
20:37:25 <Gahhh> Bad hugs. That's a bad error message. lol.
20:37:36 <stang> yeah, forgot to mention that i tried that first, it gave the same response, but capitalized the s and t
20:37:36 <stang> haha
20:37:54 <Gahhh> ok
20:37:56 <stang> Cale... very interesting, so what is System.CPUTime?
20:38:03 <Cale> it's a library
20:38:08 <Gahhh> you can't say "module SearchYadda" because it already is a library module
20:38:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.CPUTime.html -- it's in the standard Hierarchical libraries that Hugs, GHC and other haskell implementations use.
20:39:32 <Gahhh> his file seems to be named SearchTree.hs as well, if I understand correctly.
20:39:54 <mwc> http://developers.slashdot.org/comments.pl?sid=147458&cid=12354841
20:40:02 <stang> Gahhh, the implementation is called SearchTree.hs
20:40:42 <stang> my program to test it was just called tree.hs
20:40:52 <mwc> He's a bloody GRAD STUDENT
20:40:57 <mwc> How could he not know to tab?
20:41:15 <Gahhh> mwc: it's not part of the curriculum
20:41:32 <Gahhh> stang: so this "btst" you need to run is in your file named SearchTree.hs ?
20:41:45 <stang> gahhh, that is correct
20:42:02 <mwc> Gahhh, I'd expect that if it wasn't an undergrad
20:42:26 <stang> it's def:  btst :: Int -> Bool
20:42:39 <Gahhh> stang: apparently that file is a bit problematically named for running like that. I recommend renaming it to "MyST" and adding a "module MyST where" at its top. Then, from your test.hs, do "import MyST" and call btst.
20:42:56 <stang> ok
20:43:00 <Gahhh> like "MyST.btst"
20:43:23 <stang> rename the implementation MyST.btst?
20:43:42 <Gahhh> stang: no. in test.hs, call it as "MyST.btst 100"
20:43:48 <stang> oh
20:43:50 <stang> gotcha
20:44:42 <Gahhh> mwc: I know a google employee who wasn't comfortable launching Firefox *under linux*.
20:45:01 <mwc> please tell me he was a web designer
20:45:06 <Gahhh> no
20:45:14 <Gahhh> UC Berkeley CS grad
20:45:17 <Jerub> Gahhh: huh? he preferred internet explerer?
20:45:29 <Gahhh> Jerub: preferred Windows.
20:45:38 <Cale> Gahhh: hm? "Wasn't comfortable?"
20:45:41 <stang> Gahhh.... still having trouble with the MyST part of "module MyST where"
20:45:49 <Gahhh> apparently firefox experience is a lot different between linux and winxp
20:45:51 * mwc equips +90% Sword of Painful Truth
20:45:52 <SamB> preferring internet explorer under linux would be... rather odd ;-)
20:45:57 <mwc> okay, now where did he lieve again?
20:46:07 <stang> don't worry about it... i'll give Cale's solution a go
20:46:08 <Gahhh> mwc: san jose
20:46:22 <Gahhh> stang: are these two files in the same dir ?
20:46:32 <SamB> Gahhh: I am continually frustrated by the need to actually type Ctrl-C to copy under windows
20:46:50 <stang> No, but MyST.hs is in my hugs path
20:47:02 <stang> for instance, i can run the hugs interpreter
20:47:07 <Gahhh> stang: when you're running runhugs, I dont think that works.
20:47:11 <stang> :l MyST
20:47:16 <stang> btst 100
20:47:19 <stang> and it works
20:47:32 <Gahhh> stang: I think runhugs takes a few switches for additional module search paths.
20:48:54 <stang> still doesn't work... I'm done with trying to be fancy... preparing to get out the stopwatch haha
20:49:07 * SamB recompiles hs-plugins with ghc 6.4
20:51:23 <SamB> okay, how come I can't get hs-plugins 0.9.8 to compile with ghc 6.4?
20:51:34 <Gahhh> This very same google employee would launch a separate Xemacs window for every file. heh.
20:51:56 <SamB> (cd /home/naesten/hacking/haskell/hs-plugins-0.9.8 ;\
20:51:56 <SamB>  if [ ! -f plugins.conf.inplace ]; then echo [] > plugins.conf.inplace; fi;\
20:51:56 <SamB>  env PREFIX=`pwd` ghc-pkg -g -f plugins.conf.inplace -u < \
20:51:56 <SamB>         src/altdata/altdata.conf.inplace.in)
20:51:56 <SamB> Reading package info from stdin... ghc-pkg: Line 1: Invalid syntax (no colon after field name)
20:52:15 <SamB> @google hs-plugins
20:52:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:53:14 <SamB> dons: !
20:53:50 <heatsink> huh?
20:54:19 <SamB> I'm exclaiming about the build error
20:54:21 <SamB> not the URL
20:54:34 <heatsink> oh.  Okay then.
20:54:41 <stang> i appreciate all of your help Gahhh and Cale
20:54:51 <Gahhh> no prob
20:54:58 <SamB> the URL is exactly what I would have remembered, had I remembered it
20:55:10 <Gahhh> SamB: doesnt that feel nice
20:55:40 <SamB> I don't know. It would feel nicer if hs-plugins compiled.
20:55:58 <SamB> when does dons wake up, anyway?
20:56:03 <Gahhh> it
20:56:08 <Gahhh> it is 2pm in aussieland
20:56:12 <SamB> isn't he usually up by now?
20:56:18 <SamB> @timein sydney
20:56:21 <lambdabot>   Wednesday, April 27, 2005 at 1:57:20 PM EST
20:56:38 <Gahhh> what does EST stand for in au ?
20:57:03 <SamB> I suspect the EST may be extraneous
20:57:07 <Gahhh> heh
20:57:40 <Gahhh> weird. the date is right. extraneous est. heh.
20:58:35 * SamB imagines something involving date -d '{n} hours {ago/from now}'
20:58:55 <Gahhh> ewww. not haskell code ?
21:00:01 <Gahhh> Hmm, System.Time
21:00:29 <Gahhh> contrary to popular belief, you do find stuff in haskell libraries.
21:00:50 <SamB>         process _ _ src "timein" s =
21:00:50 <SamB>           if s == "help"
21:00:50 <SamB>             then ircPrivmsg src "  http://www.timeanddate.com"
21:00:50 <SamB>             else do (o,_,_) <- liftIO $ popen "timein" [s] Nothing
21:00:50 <SamB>                     ircPrivmsg src $ "  " ++ o
21:01:34 <Gahhh> is that the corresponding lambdabot code ?
21:01:44 <SamB> it certainly seems to be
21:01:49 <SamB> @help timein
21:01:50 <lambdabot>  @timein <city>, report the local time in <city>
21:01:54 <SamB> @timein help
21:01:55 <lambdabot>   http://www.timeanddate.com
21:02:32 <SamB> hmm, I suppose visiting the URL would not be a bad idea
21:02:41 <Gahhh> you need to get the timezone name for a given city, but you can do the rest in haskell.
21:03:08 <mwc> @timein London
21:03:10 <lambdabot>   Wednesday, April 27, 2005 at 5:04:09 AM BST
21:03:12 <Cale> stang: I put some working code which times a computation up at http://www.haskell.org/hawiki/HaskellIrcPastePage
21:03:16 <mwc> there are a dozen londons
21:03:17 <Gahhh> oh my, that EST is indeed the aussie EST.
21:03:23 <mwc> @timein London, Ontario
21:03:30 <mwc> @timein St. Petersburg
21:03:40 <mwc> Florida or Russia?
21:03:41 <Gahhh> haha
21:03:47 <SamB> @timein London, England
21:03:59 <Gahhh> I think it eats the input which has commas
21:04:10 <mwc> @timein London Canada
21:04:23 <SamB> so where is dons?
21:05:10 <Gahhh> full name is AEST
21:05:25 <Gahhh> @timein boston
21:05:27 <lambdabot>   Wednesday, April 27, 2005 at 12:06:26 AM EDT
21:05:35 <mwc> It's Chowda' Time!
21:05:56 <Gahhh> have a Sam Adams
21:06:03 <mwc> @timein Heaven
21:06:05 <lambdabot>   Sorry, don't know this city
21:06:19 <Gahhh> @timein Saskatchewan
21:06:20 <lambdabot>   Tuesday, April 26, 2005 at 10:07:20 PM CST
21:06:27 <mwc> Wow, a province worked?!
21:06:38 <mwc> and you knew how to spell Saskatchewan?
21:06:41 <mwc> Native?
21:06:42 <stang> Does this bot exist in all rooms?
21:06:53 <mwc> stang, no, just #haskell
21:06:54 <SamB> stang: nope, only here
21:07:00 <Gahhh> mwc: lol.
21:07:02 <mwc> you might be able to convice hhim to join
21:07:07 <mwc> @help join
21:07:08 <lambdabot> join <channel>
21:07:12 <Gahhh> rofl
21:07:25 <mwc> @join #physics
21:07:25 <lambdabot> not enough privileges
21:07:41 <SamB> @get-shapr
21:07:42 <lambdabot> Unknown command, try @listcommands.
21:07:44 <stang> @timein Norman
21:07:46 <lambdabot>   Sorry, don't know this city
21:07:51 <stang> @listcommands
21:07:52 <lambdabot> all-dicts arr babel define definitions del-definition devils dice
21:07:52 <lambdabot> dict dict-help docs dummy dynamic-load dynamic-reload dynamic-
21:07:52 <lambdabot> unload easton echo elements eurohaskell eval fact fact-cons fact-
21:07:52 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer
21:07:52 <lambdabot> get-definition ghc google help hitchcock index jargon join karma
21:07:52 <lambdabot> karma+ karma- kind learn leave listchans listcommands listmodules
21:07:54 <lambdabot> lojban moo more msg part paste pl pl-resume plugs pointless prelude
21:07:56 <lambdabot> [4 @more lines]
21:08:08 <Gahhh> @moo
21:08:09 <lambdabot>          (__)
21:08:09 <lambdabot>          (oo)
21:08:09 <lambdabot>    /------\/
21:08:09 <lambdabot>   / |    ||
21:08:09 <lambdabot>  *  /\---/\
21:08:09 <lambdabot>     ~~   ~~
21:08:11 <lambdabot> ...."Have you mooed today?"...
21:08:15 <stang> haha
21:08:31 <stang> @hitchcock
21:08:32 <lambdabot> module "dict" screwed up: Prelude.cycle: empty list
21:08:36 <Gahhh> lol
21:08:49 <stang> @easton
21:08:50 <lambdabot> module "dict" screwed up: Prelude.cycle: empty list
21:08:56 <mwc> @cynic
21:08:57 <lambdabot> Unknown command, try @listcommands.
21:09:02 <mwc> @listcommands
21:09:03 <lambdabot> all-dicts arr babel define definitions del-definition devils dice
21:09:03 <lambdabot> dict dict-help docs dummy dynamic-load dynamic-reload dynamic-
21:09:03 <lambdabot> unload easton echo elements eurohaskell eval fact fact-cons fact-
21:09:03 <lambdabot> delete fact-set fact-snoc fact-update foldoc fortune gazetteer
21:09:03 <lambdabot> get-definition ghc google help hitchcock index jargon join karma
21:09:03 <lambdabot> karma+ karma- kind learn leave listchans listcommands listmodules
21:09:05 <lambdabot> lojban moo more msg part paste pl pl-resume plugs pointless prelude
21:09:07 <lambdabot> [4 @more lines]
21:09:10 <mwc> @dict
21:09:10 <stang> @devils
21:09:10 <Gahhh> @more
21:09:11 <lambdabot> Supported dictionary-lookup commands:
21:09:11 <lambdabot>   @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock
21:09:13 <lambdabot>  @jargon @lojban @prelude @vera @web1913 @wn @world02
21:09:15 <lambdabot> Use "@dict-help [cmd...]" for more.
21:09:17 <lambdabot> more: empty buffer
21:09:19 <lambdabot> module "dict" screwed up: Prelude.cycle: empty list
21:09:21 <mwc> lojban?
21:09:28 <mwc> Who's the Lojbaner?
21:09:33 <blackdog> shapr
21:09:47 <mwc> shapr, you're kidding
21:09:48 <stang> @pointless
21:09:49 <lambdabot> (line 1, column 1):
21:09:49 <lambdabot> unexpected end of input
21:09:51 <lambdabot> expecting white space, natural, identifier, lambda abstraction
21:09:52 <mwc> I learned it once as a kid
21:09:53 <lambdabot> or expression
21:09:59 <mwc> just to piss of my grade 7 teacher
21:10:08 <blackdog> there are easier ways.
21:10:23 <Gahhh> @spell saskatchewan
21:10:23 <lambdabot> Saskatchewan Saskatchewan's Saskatoon
21:10:36 * blackdog thinks of duckman episode: "We communicate in a private binary language." "How delightfully adolescent"
21:10:45 <mwc> heheheh
21:11:06 * mwc shakes fist at ongoing Ethereal build
21:11:39 <Gahhh> the truly paranoid surely doesn't use rpms ?
21:11:53 <mwc> The enlightened use some form of ports
21:12:53 <SamB> so, does anybody know how to compile hs-plugins on ghc 6.4?
21:13:00 <mwc> SamB, yeah
21:13:03 <mwc> you need to get a recent version
21:13:07 <mwc> and it's broken according to dons
21:13:11 <SamB> mwc: which?
21:13:22 <SamB> recent version of which?
21:13:22 <mwc> the latest nightly pack
21:13:28 <mwc> of hs-plugins
21:13:44 <SamB> which is where?
21:14:26 <SamB> ooh, there is a darcs repo now!
21:14:38 <mwc> ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/snapshots
21:14:40 <pimaniac> yay!
21:15:24 <SamB> darcs get http://www.cse.unsw.edu.au/~dons/code/hs-plugins
21:18:28 <stang> Out of curiosity, have any of you heard of the Beseme Project?
21:18:40 * pimaniac hasn't.
21:18:45 * SamB neither
21:18:56 * mwc wonders if that's suppost to sound like a french surname
21:19:17 <Gahhh> does it involve martians ?
21:19:28 <mwc> Or lesbian ninjas?
21:19:30 <stang> Not that I'm aware of
21:19:32 <stang> I hope not
21:19:56 <SamB> lesbian ninjas sound extremely dangerous
21:20:13 <mwc> Yeah, nevermind, wrong channel
21:20:16 <Gahhh> hmm. Oklahoma Uni ?
21:20:17 <mwc> that's #physics meme
21:20:26 <stang> yeah
21:20:31 <stang> did you google or have you heard of it
21:20:44 <Gahhh> I just googled
21:21:21 <stang> i was just wondering how popular it was in the functional programming world and if anyone had heard of it
21:21:37 <stang> i didn't mean functional
21:22:11 <Gahhh> Uh. why not ?
21:22:14 <stang> wait... haha
21:22:16 <stang> yeah i did
21:22:30 <stang> my mind is on lesbian ninjas now
21:22:31 <stang> haha
21:22:37 <stang> that's a bad thing
21:22:40 <Gahhh> Yeah it's highly relevant.
21:22:48 <Gahhh> reminds me of Inria's Coq
21:22:50 <SamB> sleepytime?
21:23:31 <mwc> stang, if you want the full story, it involves a script for an NC-17 movie about a pair of lesbian ninja's killing zombies in a post apocalyptic wasteland
21:23:51 <Gahhh> stang: Does Beseme work anyways ?
21:23:59 <Gahhh> I couldnt load the pdf. Thank you acrobat.
21:24:50 <mwc> What does it do exactly?
21:24:55 <dons> moin
21:25:12 <mwc> I'd observe that it sounds like pure mathematicians trying to be relevent, but then I'm an applied mathematician
21:25:16 <SamB> dons: hello! you are too late to help me get hs-plugins to compile on 6.4
21:25:51 <mwc> SamB, the Darcs sources worked for you?
21:25:53 <dons> it compiles. I think you are seeing a bug where by you didn't make distclean between ghc-6.2.2 and ghc-6.4 (?)
21:25:55 <stang> mwc... thanks for filling me in!  sounds interesting
21:26:00 <dons> i know that that scenario produces the error, anyway
21:26:03 <SamB> yes, they compiled fine
21:26:17 <stang> Gahhh... I think it helps quite a bit
21:26:32 <mwc> I built it too in between trying to find thicker and thicker socks
21:26:34 <SamB> dons: hmm, distclean? I'm not sure if I did distclean or just the plain clean
21:26:52 <dons> one wipes out configure stuff too, the other doesn't
21:27:03 <stang> It lets you look at programming in a different way
21:27:28 <Gahhh> stang: of course. Is it applicable for imperative languages as well ?
21:27:45 <SamB> (cd /home/naesten/hacking/haskell/hs-plugins-0.9.8 ;\
21:27:46 <SamB>  if [ ! -f plugins.conf.inplace ]; then echo [] > plugins.conf.inplace; fi;\
21:27:46 <SamB>  env PREFIX=`pwd` ghc-pkg -g -f plugins.conf.inplace -u < \
21:27:46 <SamB>         src/altdata/altdata.conf.inplace.in)
21:27:46 <SamB> Reading package info from stdin... ghc-pkg: Line 1: Invalid syntax (no colon after field name)
21:27:52 <SamB> that is what I was getting
21:28:14 <mwc> Out of curiosity, why hasn't anyone written a haskell compiler around GCC?
21:28:18 <SamB> well, it looks like I did, in fact, run make distclean
21:28:23 <mwc> Seems to me a lot of good free optimization could come from it
21:28:31 <mwc> Not to mention free portability
21:28:33 <SamB> mwc: heard of -fvia-C?
21:28:42 <mwc> SamB hmm
21:28:51 <mwc> Seems inefficient
21:28:54 <Gahhh> ghc mingw actually ships gcc mingw
21:29:09 <Gahhh> and perl.exe mingw heh
21:29:10 <stang> Yes, we have done some loop induction, proofs on data structures (such as trees), etc
21:29:15 <mwc> I'm just jonesing for autovectorization when I get around to GCC 4.0
21:29:35 <SamB> mwc: more inefficient would be trying to get it to work with actually calling into GHC code at the C level
21:29:49 <mwc> brb, gotta close down some stuff to run a network sniff
21:29:50 <stang> It's really pretty general
21:29:50 <SamB> it would be a game of catch-up and binary incompatability!
21:29:59 <SamB> s/GHC/GCC/
21:30:04 <mwc> SamB, yeah, waht about generating to RTL like any other front end?
21:30:05 <Gahhh> stang: It didn't seem to have made a huge difference for students with GPA's over 3.7
21:30:40 <Gahhh> I bet he will find out that his neighbor's running wireless with no wep.
21:32:08 <stang> There's either not too many students w/ over a 3.7 or maybe they already have a pretty good understanding of programming
21:32:22 <stang> I would actually expect it to help those students the most though
21:32:39 * pimaniac will definitely look into Beseme when he starts discrete math.
21:32:43 <reffie> GPAs are stupid
21:33:02 <stang> Because they are the majority of the students that actually realize how induction is useful
21:33:12 <SamB> hmm, hs-plugins works better when you remember to make register, just as Pugs's Makefile.PL says.
21:33:47 <stang> pimaniac, you are going to teach discrete?
21:34:14 <dons> SamB, heh!
21:34:23 <pimaniac> stang: to myself :)
21:34:42 <SamB> dons: heh?
21:35:06 <dons> your quote about, "just as Pugs' Makefile.PL says"
21:35:33 <stang> I see... well I'll warn you that the book doesn't do much for you
21:35:45 <SamB> oh, okay, I was wondering if for some strange reason you thought it funny that I would try to build Pugs
21:36:16 <pimaniac> stang:  ill have to get a teacher to get the stuff for me, it looks like
21:37:03 <Gahhh> pimaniac: get what for you ?
21:37:12 <gzl> discrete math classes are too all over the place
21:37:35 <pimaniac> Gahhh: the materials from the Beseme login
21:37:46 <pimaniac> Gahhh: or, i can make up a position, and fill it.
21:37:55 <stang> I'm not sure pimaniac, if you contact Page, I'm sure he'll work with you
21:38:00 <stang> he's very personable
21:38:44 <pimaniac> cool.  will try then
21:40:17 <Gahhh> mwc: I thought you were a physics major.
21:42:42 * SamB decides to go do something on that idle windows box while haskell code compiles
21:42:47 <mwc> Gahhh, theoretical physics
21:43:00 <mwc> That's an automatic double major in applied math here
21:43:12 * SamB has lambdabot, Yi, and pugs compiling with 6.4 right now
21:43:33 <mwc> It's a neat system, actually, you take an applied math major and then another major that applies the math you learn, like theoretical physics, continuum mechanics, or something like that
21:44:19 <Gahhh> ah
21:45:28 <SamB> mwc: it does seem pretty silly to major in something called "applied math" and not actually have anything in particular which you apply math to
21:45:37 <mwc> SamB, it's that double major
21:45:46 <mwc> the applied math major deals with the actual math
21:46:06 <mwc> so things like numerical analysis, finite element methods, that sort of thing
21:46:23 <mwc> the partner major deals with the actual subject
21:47:09 * SamB_XP wonders how he got to http://www.btselem.org/
21:47:20 * SamB_XP wanted to go to bobandgeorge.com
21:48:01 * mwc stifles kneejerk 'blame windows' responce
21:48:33 <SamB_XP> mwc: I'm using Firefox!
21:48:57 <pimaniac> on windows?
21:49:11 <Gahhh> it's a truly different experience ...
21:49:13 <SamB_XP> I blame windows for the different copy-and-paste, not for freaky things happening with things I type in the address bar
21:49:27 <mwc> heh
21:49:36 <SamB_XP> I probably misspelled it or something
21:49:42 <mwc> Gahhh, XP actually stands for Chi Rho
21:49:51 <mwc> well, is actually Chi Rho
21:50:01 <mwc> since windows XP was the second coming of jesus
21:50:04 <SamB_XP> Cairo?
21:50:04 <mwc> yes, it was that good!
21:50:18 <mwc> SamB_XP, the greek letters Chi and Rho
21:50:28 <mwc> as in, the first two letters of "Christ"
21:50:32 <SamB_XP> oh
21:50:39 <SamB_XP> that makes no sense...
21:50:48 <mwc> XP is used to abbrevirate Jesus Christ
21:51:01 <Gahhh> Wasnt windows 95 codenamed Cairo ???
21:51:03 <mwc> it's like a first century thing
21:51:08 <mwc> Gahhh, hahahah
21:51:10 <SamB_XP> Gahhh: chicago, actually
21:51:15 <Gahhh> right, chicago
21:51:18 <Gahhh> maybe 98 ?
21:51:36 <pimaniac> the new linux gui backend is named cairo, iirc
21:51:56 <Gahhh> ah
21:51:57 <Gahhh> http://c2.com/cgi/wiki?WindowsXpNameDiscussion
21:52:53 <Gahhh> cairo never materialized.
21:53:06 <mwc> SamB, On the top of the whole was fixed a wreath of gold and precious stones, and within this the symbol of the Saviour's name, two letters indicating the name of Christ by means of the initial letters, the letter X intersection P at the centre."
21:53:09 <mwc> http://www.newadvent.org/cathen/08717c.htm
21:53:46 <mwc> Hence I liken Windows XP name to the Beatles' bigger-than-jesus statement
21:54:02 <SamB_XP> ah yes, Whistler is what they called it, isn't it?
21:55:15 <SamB_XP> Some would speculate that it stands for eXtra Price. Both humorous and accurate.
21:55:29 <SamB_XP> </quote>
21:56:32 <Gahhh> "X-P" as a smiley lol
21:56:45 <SamB_XP> more of a dead-face, really
22:02:57 <reffie> i'm guessing there isn't a polynomial module
22:03:21 <reffie> to do polynomial multiplication etc
22:03:31 <reffie> or is there? :P
22:25:27 <pimaniac> phenotype:  that sucks.
22:25:33 <pimaniac> phenotype: should be faster :)
23:01:20 <lispy> hmm...the wiki page for "lifting" is a bit hard to follow
23:01:29 <lispy> http://haskell.org/hawiki/Lifting
23:01:56 <lispy> perhaps it just needs a better motivation...
23:10:50 <lispy> liftL2 :: Liftable f => (a -> b -> c) -> (f a -> f b -> f c)
23:10:53 <lispy> liftL2 f x y = fmap (uncurry f) $ zipL x y
23:11:04 <lispy> heh, that's pretty complex
23:11:17 <Pseudonym> reffie: Not built in.
23:11:31 <lispy> i've used haskell for a few classes and i've yet to run into uncurry and $
23:11:35 <reffie> Pseudonym well, is there one available online? :P
23:11:40 <reffie> or should i write my own
23:11:42 <Pseudonym> reffie: http://cvs.sf.net/viewcvs.py/haskell-libs/libs/maths/euclidean/
23:11:49 <reffie> thank you
23:11:52 <Pseudonym> But you should write your own, because you'll learn stuff that way.
23:12:20 <reffie> maybe
23:12:39 <ozone> anyone know of any fixed-point numeric libraries for haskell?
23:12:54 <ozone> googling for fixed-point haskell turns up stuff like the Y combinator :)
23:13:16 <lispy> heh
23:13:46 <lispy> i bet implemeting fixed point in haskell would be pretty straight forward
23:14:01 <lispy> but why not use floating point?
23:14:14 <ozone> it would be, but implementing it (1) fast and (2) again is no fun :)
23:14:34 <ozone> lispy: i'm manipulating a few data structures which are expected to be fixed-point, so i don't have much choice ...
23:14:51 <lispy> ah, weird
23:15:10 <Pseudonym> Rational is not a bad alternative for many situations.
23:15:31 <ozone> not really, fixed-point is used pretty heavily on lower-performance devices
23:15:57 <Pseudonym> Yes, but Haskell is usually not used on such devices.
23:16:01 <lispy> which is why it may be hard to find a fixed-point module for haskell :)
23:20:16 <ozone> nod, understood.  off to make my own library, then ...
23:20:40 <lispy> ozone: in that case: http://www.gameprogrammer.com/4-fixed.html
23:21:13 <ozone> lispy: cheers
23:21:14 <lispy> perhaps that discussion will be helpful
23:23:41 <cakoose> I just read about NTFS getting support for file system transactions.
23:24:05 <cakoose> Would this allow Haskell to do away with the unsafe IO operations?
23:24:07 <lispy> cakoose: i was under the impression it has supported that for a while (several years)
23:24:37 <cakoose> lispy: Hmm...I know it's had journaling for a while, but I think the user-defined transactions are new.
23:24:59 <lispy> alrighty then :)
23:25:41 <wilx> Interesting.
23:25:45 <wilx> Link?
23:26:03 <cakoose> http://blogs.msdn.com/because_we_can/
23:26:11 <cakoose> Second post from the top.
23:26:18 <wilx> Thanks.
23:26:42 * Pseudonym is assembly programming
23:26:44 <Pseudonym> It's been a while.
23:26:57 <reffie> user defined transactions?
23:27:00 <cakoose> When I first read about the unsafe IO operations, I though they were only there because file systems lacked transaction support.
23:27:21 <reffie> can they be arbitrarily long?
23:27:34 <cakoose> That's what it looks like.
23:27:48 <reffie> i'm guessing it's just a snapshot hack
23:27:52 <cakoose> So when you commit, it looks like an instant operation.
23:28:18 <reffie> takes a snapshot of the filesystem, does whatever, merges the snapshot back in
23:28:33 <reffie> but it's a very interesting idea
23:28:49 <reffie> maybe i should try to implement it in freebsd :P
23:29:07 <cakoose> I think Reiser4 has the capabilities.
23:29:14 <cakoose> Just no API to access it.
23:31:51 <lispy> already time for ext4 is it? :)
23:42:51 <lispy> i'm having trouble googling for this one.  What does the $ do in haskell?
23:44:23 <Gahhh> lispy: search the haskell mailing archives for more detail. It saves you from typing parens all the time. e.g. : putStrLn (head lines) == puStrLn $ head lines
23:44:45 <cakoose> It's just apply, right?
23:44:49 <cakoose> With lower precedence.
23:44:50 <lispy> Gahhh: okay
23:45:09 * lispy checks his nick.
23:45:18 <lispy> Well, i have no problems with parens :)
23:48:21 <Pseudonym> (((neither))(do)((((i)))))
23:49:36 <Pseudonym> (p((a)r)((e))(n(s))(e(n)((h)))a(((n))c)e((r)e)((a))d(a(b)i)l((i)t)y)
23:49:51 * Pseudonym feels like a spammer typing that
23:53:30 <lispy> just think of the little boy in the matrix holding the spoon, "There are no parens."
23:56:37 <lispy> hmm...why does applying sequence to a list have the effect of taking the cartesian product...(trying to see why this is reasonable)
23:56:49 <Pseudonym> @type sequence
23:56:51 <lambdabot> sequence :: forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:57:36 <lispy> sequence is a lifting function me thinks
23:57:52 <lispy> so many concepts, so little time :)
