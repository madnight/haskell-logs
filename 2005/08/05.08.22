00:01:24 * boegel is seeing double
00:01:35 <Korollary> you are right
00:01:44 <Korollary> except for the _
00:03:37 <boegel> Korollary: ;)
00:04:02 <Itkovian> hi boegel
00:04:03 <Korollary> where's work ?
00:04:56 <boegel> Korollary: Ghent uni
00:05:54 <Korollary> is that in Belgium ?
00:06:34 <boegel> Korollary: yes
00:12:05 <boegel> Korollary: why do you ask ?
00:26:06 <Korollary> just wondering
00:28:34 <boegel> alrighty then
00:29:26 * Korollary acts nervously while he tries to signal his fellow agents that are tailing boegel...
00:30:51 * boegel looks around frantically and starts running
01:20:10 <kosmikus> dblhelix: no talk at dgp?
01:21:25 <dblhelix> kosmikus: nope... no suitable subject (except for views maybe :))
01:22:05 <kosmikus> ok, if you think so ;)
01:23:19 <dblhelix> kosmikus: what's yours going to be? just an exploration of possible research directions or already some spectacular results?
01:25:47 <kosmikus> dblhelix: nothing spectacular, no
01:29:18 <kosmikus> in fact, I'm afraid it's going to be quite bad; I have quite some ideas, but I can't get them organised properly
01:31:34 <dblhelix> well, make it into a discussion session then :)
01:50:08 <boegel> yo Oejet
01:56:40 <dcoutts> xerox, ping
02:07:51 <Oejet> boegel: Hey.
02:11:59 <boegel> hey ndm
02:12:05 <ndm> hey boegel
02:49:19 * shapr yowls
02:49:41 <shapr> boegel: hoi!
02:53:39 <musasabi> morning shapr
02:55:03 <boegel> shapr: yo !
02:57:04 <musasabi> Well be going through Norrbotten in a few days - although unfortunately not through Luleå.
02:59:17 <shapr> musasabi: Aw, too bad.
03:17:07 <xerox> 'morning
03:17:17 <dcoutts> xerox, good morning
03:17:44 <dcoutts> code's looking good, it's all working for me
03:17:50 <xerox> Great :)
03:24:42 <dcoutts> xerox, so, what's next?
03:27:42 <xerox> dcoutts: btw, did you try cairo-demo/png/star_and_ring.c ?  It's as slow as this Haskell version.
03:27:54 <dcoutts> hmm, let me try
03:32:42 <xerox> Too bad when Emacs crashes.
03:32:49 <dcoutts> hmm
03:32:57 <dcoutts> well it's about the same speed
03:33:01 <xerox> Yep
03:33:07 <dcoutts> the C version takes 1.1 sec or so
03:33:13 <dcoutts> the haskell version 1.3 sec or so
03:33:56 <dcoutts> so not too bad
03:34:03 <dcoutts> I could try building with ghc -O
03:34:04 <xerox> Yeah
03:35:12 <xerox> Ah, I didn't try.
03:35:21 <dcoutts> me neither
03:48:22 <boegel> yo xerox
03:48:57 <xerox> Heyla boegel
04:36:46 <boegel> yo oplog4
04:38:00 <arjanb> it seems a bot, boegel
04:40:03 <boegel> arjanb: oh O_o
04:40:07 * boegel rubs his eyes
04:44:14 <Oejet> A very intelligent one at that.
04:45:18 <Itkovian> yeah it ignores weird people, eh
04:45:41 <xerox> "weird" ?
04:47:55 <Itkovian> don't we all qualify as that?
04:48:16 <xerox> Prolly
04:48:20 <kaol> "weird" is a matter of perspective
04:49:28 <dblhelix> Itkovian: apparently
04:50:08 <boegel> Itkovian: thanks man
04:50:16 * boegel kicks Itkovian in the ass
04:50:25 <Itkovian> ouch hey watch it!
04:50:31 <Itkovian> I need to sit a few more hours
04:50:42 <dblhelix> people are really getting along in Ghent
04:50:45 <boegel> you should try a sitting ball, that's nice on the ass
04:50:58 <boegel> dblhelix: you'd be surprised ;)
04:56:54 <yeti> i know i can do arithmetic sequences easily with [1,3..11] or [1..10], or even [func 1 param..func x param], but [func 1 1 param..func 1 x param,func 2 1 param..func 2 x param,..,func x 1 param..func x x param] does not work - is there any easy way to do that?
04:57:35 <yeti> (don't know how to describe it... listing all elements of a x*x square?)
04:59:46 <resiak> [func x y param | x <- [1..x], y <- [1..x]]
05:00:18 <yeti> cool, thanks :)
05:00:43 <resiak> I would tell you what that construct is called, but right now I can't remember.
05:07:12 <Itkovian> resiak: do you mean a list comprehension?
05:11:36 <resiak> Itkovian: That is exactly what I mean. This is what happens when I don't use a computer for two weeks :)
05:13:13 <Itkovian> Lemmih: on my linux box, hs-plugins looks fine ... no make check failings so far ... hmm, some fail but not with unknows symbols ...
05:16:13 <dons> Itkovian, a couple of merges fails. only due to using the non-hsx parser.. harmless.
05:16:44 <dons> others i'd  like to know about though
05:18:20 <tuomov> Building plugins-0.9.10...
05:18:21 <tuomov> Chasing modules from: AltData.Dynamic...
05:18:29 <tuomov> ghc-6.4: module `AltData.Dynamic' is a package module
05:18:29 <tuomov> make: *** [build] Error 1
05:18:47 <tuomov> what is that error now?
05:18:50 <dons> hmm. with latest darcs?
05:18:52 <tuomov> yep
05:19:08 <dons> which ghc? i'll try to reproduce it
05:19:17 * Lemmih got around that by taking a clean snapshot.
05:19:18 <dons> could be I'm using a different cabal
05:19:19 <tuomov> ghc64 in debian/testing
05:19:27 <tuomov> maybe ghc in testing is just totally broken or something
05:19:54 <dons> maybe try Lemmih's advice?
05:20:03 <tuomov> I took a clean snapshot
05:20:09 <tuomov> darcs had some problems with pull
05:20:14 <dons> make sure any old hs-plugins is not registered before you start?
05:20:22 <tuomov> Fail: /share3/home/tuomov/src/hs-plugins/_darcs/current/src/plugins/Makefile: openBinaryFile: does not exist (No such file or directory)
05:20:27 <dons> tuomov, yeah, other people reported this too. apparenly a known bug in darcs
05:21:15 <dons> ok, i'll try hs-plugins with 6.4 on linux and seee what happens. i've been testing with  6.4.1 and 6.5
05:21:26 <tuomov> Could not find module `Language.Hi.Binary':
05:21:27 <tuomov>   it is hidden (in package hi-0.9.10)
05:21:43 <tuomov> after unregister hs-plugins and altdata
05:21:56 <dons> this seems weird. for one, there is no package hi anymore
05:22:11 <xerox> brb
05:22:23 <tuomov> unregistering hi seems to have fixed the problem
05:22:35 <dons> right. make sure altdata and hi are gone
05:22:48 <tuomov> why does it mess the build process?
05:23:29 <tuomov> I didn't use to have any problems building hs-plugins..
05:23:31 <dons> cabal does the build now, when it finds the src altdata (now in the plugins package) it thinks they clash with the old hi and altdata packages
05:23:54 <dons> it should only happen once, when upgrading hs-plugins without unregistering the old version
05:24:02 <dons> in future you shouldn't have any trouble
05:24:30 <dons> the pain is worth it I think, as the build system is way simpler now
05:25:19 <tuomov> I wish I could simplify Riot's build system.. does Cabal handle the plugins hack yet?
05:25:30 <tuomov> anyway, riot seems to build now with hs-plugins
05:25:46 <dons> goood :)
05:25:54 <dons> what plugins hack are you referring to?
05:26:10 <dons> the Boot stuff?
05:26:11 <tuomov> the bootloader stuff
05:26:58 <dons> hmm. just trying to think what kind of support cabal could possibly provide.. ?
05:27:47 <tuomov> anything to get rid of awful makefiles
05:28:09 <dons> ok, the main applicationn could almost certainly be built with cabal I think.
05:28:25 <Itkovian> dons I'll give you a load i  a PM, a sec.
05:28:34 <Itkovian> a load of errors that is
05:29:01 <tuomov> without hs-plugins and with hscurses build separately it probably could
05:29:10 <tuomov> I haven't managed to make ti build with hscurses, though
05:30:32 <dons> almost certainly could. cabal has good inbuilt support for all the different rules hacked into the makefiles in riot/yi/et al but i haven't quite got the courage yet to rewrite the yi build system in cabal.
05:31:38 <bourbaki> moin
05:37:37 <tuomov> make depend complains that it can't find module HSCurses. adding -package hscurses doesn't help
05:37:47 <tuomov> I wonder if it is correctly registered
05:40:02 <sylvan> what does "ghc-pkg -l" give you?
05:40:15 <shapr> hm, it lists pizza-1.0
05:40:39 <tuomov> it lists hscurses-1.0
05:42:10 <Lemmih> Can you load it in GHCi?
05:44:13 <tuomov> ah.. it's HSCurses.Curses
05:49:34 <Lemmih> Yes! I've finally replaced hsx and trhsx with the GHC parser in HSP.
05:49:58 <dons> cool!
05:50:02 <dons> @karma+ Lemmih
05:50:03 <lambdabot> Lemmih's karma raised to 2.
05:50:16 <dons> so, now, ghc's lexer is out and about?
05:50:26 <Lemmih> @where ghc-src
05:50:27 <lambdabot> I know nothing about ghc-src.
05:50:37 <dons> @where ghc
05:50:38 <lambdabot> http://haskell.org/ghc
05:50:51 <Lemmih> @where+ ghc-src http://scannedinavian.org/~lemmih/ghc-src
05:50:52 <lambdabot> ghc-src ~> http://scannedinavian.org/~lemmih/ghc-src
05:52:28 * dons gets
05:55:03 <dons> paprika$ pwd
05:55:03 <dons> /home/dons/tmp/ghc-src/Language/Haskell/GHC
05:55:03 <dons> paprika$ ls -1 * | length
05:55:04 <dons> 37
05:55:07 <dons> not too bad!
05:56:05 <Lemmih> I'll probably clean it up after HSP is released.
05:56:36 <dons> yeah, it would be cool if I could just depend on this for yi's syn hl
05:57:07 <dons> just forwarding  the link to my research group :)
05:57:31 <dons> i think many people will want to use this, Lemmih. you could do an ANNOUNCE once it's stable
05:58:49 <Lemmih> 'length' == h4sh?
05:59:04 <dons> yup
05:59:09 <Lemmih> Neat (:
05:59:30 <dons> h4sh now with improved mmapped io
05:59:32 <dons> :)
06:02:59 <Lemmih> CosmicRay will probably mention it tomorrow.
06:03:51 <dons> paprika$ time cat tmp/tests/200M > /dev/null
06:03:51 <dons> cat tmp/tests/200M > /dev/null  0.00s user 0.15s system 2% cpu 6.382 total
06:03:51 <dons> paprika$ time ~/h4sh/i tmp/tests/200M > /dev/null
06:03:51 <dons> ~/h4sh/i tmp/tests/200M > /dev/null  0.00s user 0.01s system 2% cpu 0.356 total
06:04:06 <xerox> whoa!
06:04:08 <dons> FastPackedStrings for all!
06:04:29 <xerox> @karma+ dons
06:04:30 <lambdabot> dons's karma raised to 11.
06:04:39 <xerox> Your karma is way too high :-)
06:05:08 <dons> well, this is really due to the really nice darcs FastPackedString.hs from David Roundy and Igloo
06:05:24 * dons gets some sleep
06:06:33 <xerox> Goodnight dons
06:15:25 <Oejet> And here I thought that cat would be near optimal speedwise because of it's long time in the wild.
06:31:13 <erommer> any idea on what type of error this is
06:31:14 <erommer> parse error on input `='
06:31:36 <Lemmih> It's a parse error. (:
06:31:51 <vikasg> are you trying to define a function at the prompt?
06:32:40 <erommer> yea
06:33:24 <vikasg> doesn't work :)
06:33:41 <erommer> lol
06:33:42 <Lor> It works in ghci.
06:33:59 <erommer> the function works in ghci
06:34:15 <shapr> @karma+ dons
06:34:16 <lambdabot> dons's karma raised to 12.
06:34:25 <xerox> erommer: you do have to do "let <name> = <expr>"
06:34:34 <erommer> but when i add it with the IO code we were given i get an error, sum1 said it could be incorrect indenting
06:34:34 <shapr> @where h4sh
06:34:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
06:34:46 <xerox> erommer: in GHCi you an omit the "in <expr>" part and have the new binding in the current namespace, for future use.
06:35:32 <erommer> xerox: yea, the error is in the line below the 'let ...'
06:35:45 <xerox> erommer: which is?
06:36:19 <erommer> when i try to compile using ghc, i get a parse error on the line below let...
06:36:41 <xerox> erommer: I think you need to provide more information if you aim to useful help.
06:37:14 <shapr> dons: Can I map a shell command over a bunch of dirs?
06:38:03 <xerox> dons it would be handy to have `type` to get the type of the h4sh-utility, a-la :type :-)
06:38:09 <shapr> for example, map 'darcs pull -a' [yi,hs-plugins,bts,h4sh]
06:38:31 <tuomov> xargs -n 1?
06:39:15 <tuomov> although, xargs has problems with spaces
06:39:40 <marcot> Is there a lot of difference between miranda and haskell?
06:50:42 <dblhelix> marcot: you mean "is there a lot of difference between miranda(*) and haskell?" "(*) miranda is a trademark (tm) of research ltd." ;)
06:52:23 <dblhelix> /s/research/research sw.
06:53:11 <marcot> dblhelix: I didn't know this.
06:53:33 <dblhelix> nevermind :)
06:53:58 <dblhelix> marcot: anyway, I'm sorry, I don't know that much about Miranda
06:54:42 <earthy> no, there is not a lot of difference
06:54:46 <earthy> some syntactic differences
06:55:10 <earthy> but miranda skills mostly translate to haskell quite easily
06:57:12 <marcot> earthy: hum... what about mercury? This is very different, isn't it?
07:01:04 <shapr> Yes, definitely.
07:01:20 <shapr> Mercury is more logic/constraint programming.
07:02:44 <kosmikus> the main reason for Haskell's existence is that Miranda is commercial
07:04:14 <vikasg> boy, passing around state by meself is hard
07:05:13 <alar> @help state
07:05:13 <lambdabot>  @state - we all know it's evil
07:05:26 * boegel taps Itkovian on the shoulder
07:06:24 * shapr grins
07:06:51 * Muad_Dibber looks around
07:07:11 * boegel pokes Muad_Dibber in the eye
07:07:24 * Muad_Dibber looks around with only one eye
07:07:46 * vikasg panics ... uh oh, what did I START here?
07:08:36 * boegel tackles vikasg 
07:10:15 * vikasg takes out a state monad
07:11:14 * vikasg throws it at boegel, it breaks into two pieces, and comes back
07:12:59 * Muad_Dibber fires some arrows at vikasg
07:14:16 * vikasg runs to read the "Generalizing monads ..." paper
07:14:47 * boegel is confused
07:15:29 <Muad_Dibber> no offense, but it isn't hard to confuse you boegel :)
07:17:19 <boegel> Muad_Dibber: that because I don't know much about arrows and monads :)
07:17:38 <boegel> I don't have the time to dig into them, although I'd like to
07:18:11 * boegel takes a sledgehammer and taps Itkovian on the shoulder
07:20:23 * boegel sees perspectival coming and going
07:21:09 * boegel taps Itkovian on the shoulder with the sledgehammer
07:22:06 * vikasg picks up the arrow and gives it to boegel to poke
07:26:38 * boegel drops the arrow and screams: "Yuk, wtf is this ?!?"
07:28:50 * boegel is seeing triple
07:29:02 <boegel> Cale, Cale`, Cale`` : wtf ? :)
07:29:09 <xerox> @type (,,,)
07:29:25 <boegel> @yow
07:29:27 <lambdabot> forall d c b a. a -> b -> c -> d -> (a, b, c, d)
07:29:28 <vikasg> boegel, they're just recompiling the matrix
07:29:32 <lambdabot> We just joined the civil hair patrol!
07:32:14 <Itkovian> omg
07:38:58 <shapr> Isn't the Mozilla calendar format called ical?
07:39:08 * shapr is missing about four hours of sleep.
07:39:20 <Itkovian> hmm shthat's more like iCal, on my mac
07:40:17 <boegel> shapr: missing ?
07:40:58 <shapr> boegel: I went to sleep at 4am, and was precipitously awakened at 8am.
07:41:08 <shapr> Plone died again and I had to kick it a few times.
07:41:16 <Philippa_> yuck. PITA.
07:41:25 <boegel> yo Philippa_
07:41:37 <Philippa_> 'lo boegel
07:41:49 <Philippa_> 'fraid I won't be around long - my b/f's just got back from a week-long absence
07:41:52 <shapr> Aha, iCalendar is an XML format.
07:42:14 <Itkovian> Philippa_: then what the heck are you doing here?
07:42:30 <Philippa_> Itkovian: he's on the phone
07:43:20 <Philippa_> make that /was/ on the phone...
07:43:23 <Philippa_> seeya :-)
07:44:14 <shapr> I want to export my DateBook5 info in icalendar format.
07:45:05 <shapr> I really liked the way Exchange and Outlook worked together such that I could request a meeting with included vcalendar info, and the recipient could accept with a single click and it showed up on their calendar immediately.
07:45:25 * boegel smells Philippa_'s having sex
07:45:41 <shapr> Does mozilla handle that sort of scheduling already?
07:45:42 <boegel> shapr: how's FLM ?
07:45:53 <shapr> boegel: um, nothing recently.
07:47:52 <shapr> And I'm not sure I'll have time to work on it before I move.
07:48:26 <boegel> shapr: shame :(
07:49:21 <xerox> shapr: where are you moving to?
07:54:56 <shapr> xerox: Next town over, LuleÃ¥
08:16:03 <Itkovian> boegel: we do not want to smell that
08:16:30 * boegel leaves for home (and local festivities)
08:23:14 <dcoutts> xerox, ping
08:29:16 <xerox> shapr: are you on some trip?
08:30:04 <shapr> Not really. I'm a US Citizen living in Europe for the last six years. I guess you could call that a really long trip.
08:30:32 <dcoutts> shapr, ha I'm a US Citizen living in Europe for the last twenty four years!
08:30:48 <dcoutts> shapr, hmm come to think of it, I'm only 24.
08:31:06 <shapr> How'd you get that? Are your parents US Citizens?
08:32:15 <dcoutts> shapr, yeah
08:32:23 <dcoutts> one of them is
08:32:48 <shapr> Nifty
08:33:34 <dcoutts> but as soon as they bring back the draft I'm going to head down to the US embassy to burn my pasport :-)
08:33:43 <shapr> After living here for five years I can apply for citizenship. If I get it, I won't lose my US Citizenship.
08:33:46 <xerox> hehe
08:33:47 <shapr> dcoutts: Do what?
08:33:59 <shapr> Are they bringing back the draft??
08:34:09 <dcoutts> there are often rumours
08:34:42 <dcoutts> hopefully it'll never happen
08:35:30 * xerox was teaching haskell to a friend via collaborative-editing
08:36:11 <xerox> It's fun.
08:38:26 <shapr> I was thinking about the @pointless golf game, and wondering... Do you think a lambda cal reduction game would be fun?
08:38:55 <xerox> What is it about?
08:39:16 <shapr> Maybe players get points on efficiency and correctness. Input is reduction rules.
08:40:11 <shapr> Might be interesting to limit the rules to a certain small number or maximum complexity/chars/whatever.
08:40:37 <shapr> Hm, what about lambda corewars? I wonder if that would work?
08:41:20 <xerox> heh
08:41:59 <xerox> Pointless golf game starts! @pl \f g x y = f x (g y)
08:42:36 <xerox> O_o written like that it's a bunch of (.)
08:42:37 <Itkovian> draft as in the military?
08:42:50 <xerox> @pl \f g x y = f x (g y)
08:42:51 <lambdabot> (line 1, column 10):
08:42:51 <lambdabot> unexpected "="
08:42:51 <lambdabot> expecting pattern or "->"
08:42:52 <Itkovian> can't you refuse, as when being a consientious objector
08:42:59 <xerox> @pl \f g x y -> f x (g y)
08:43:00 <lambdabot> flip . ((.) .)
08:43:04 <shapr> I think you get jailed if you refuse.
08:43:06 <xerox> Difficult :-P
08:43:16 <xerox> @pl \x y -> f x (g y)
08:43:17 <lambdabot> (. g) . f
08:43:21 <Itkovian> yeah, but can't you do a community service instead?
08:43:38 * Itkovian would rahter go to jail than kill
08:47:15 <shapr> I wish I could perform CSE on my bookmarks... somehow I have dupes.
08:47:39 <xerox> What's CSE?
08:47:49 <shapr> common subexpression elimination.
08:47:54 <shapr> @jargon cse
08:47:55 <lambdabot> No match for "cse".
08:48:09 <shapr> @all-dicts cse
08:48:11 <lambdabot> *** "CSE" wn "WordNet (r) 2.0"
08:48:11 <lambdabot> CSE
08:48:11 <lambdabot>   n : Canadian agency that gathers communications intelligence
08:48:11 <lambdabot> and
08:48:11 <lambdabot>    assist law enforcement and security agencies [syn: {Communications
08:48:13 <lambdabot>    Security Establishment}]
08:48:15 <lambdabot>  
08:48:17 <lambdabot> [5 @more lines]
08:48:44 <shapr> um, no.
08:49:30 * shapr stabs the acm
08:49:47 <shapr> Full-Text is a controlled feature. <br/> To access this feature: <br/> * Please login with your ACM Web Account.
08:49:57 <shapr> But scholar.google.com shows the results :-(
08:50:16 <xerox> :(((
08:50:25 <xerox> I hate when it happens too
08:50:26 <kosmikus> scholar searches a lot of restricted sites
08:51:04 <shapr> I've sent them email asking for a preferences button like "I have no subscriptions to anything, don't show me for-pay results"
08:53:29 <Itkovian> shapr: what article do you need?
08:56:24 <shapr> I was just looking for articles on optimal lambda calculus reduction, but I'll stick with freely available articles.
09:06:18 <pejo> shapr, optimal in what sense?
09:08:25 <pejo> Personally I find scholar a huge time saver. Lets one easily see who refers to a certian article, regardless of where it's published, and so on.
09:09:30 <Itkovian> dons: would those errors I pasted occur at compile or at runtime?
09:10:17 <shapr> pejo: I was just thinking about a lambda calculus game where players put in reduction rules. But if the problem is solved so well that there's a complete and simple answer, the game won't be fun.
09:12:00 <Igloo> I'm fairly sure it'll be undecidable
09:12:46 <shapr> What? Optimal reduction is undecidable?
09:12:58 <Igloo> Think so
09:13:07 <Lemmih> Hi SyntaxNinja.
09:13:23 <shapr> It's easy to measure if you throw in a few randomly generated lambda terms.
09:13:23 <Igloo> Your game would have to make sure all of its problems were solvable, don't forget
09:13:56 <shapr> It's more about the relative score of the reduction rules the players give.
09:14:21 <shapr> Especially if time and space are given different weights, or if number of reduction rules are limited.
09:14:34 <Igloo> But if I have the right gist you require that the terms have a normal form
09:14:48 <shapr> Hm, good point.
09:15:30 <shapr> Still, I could write a QuickCheck generator to do it.
09:15:56 <shapr> The game results could even come from instrumented quickcheck tests.
09:17:13 <shapr> Any idea how lambda corewars would work?
09:18:24 <SyntaxNinja> hiya
09:21:37 <rt> hard to imagine how it would work, since corewars sort of relies on an "addressable memory with modifiable cells" semantic.
09:31:42 <shapr> Yeah, I'm not sure how to approach that with lambda cal.
09:31:51 <basti_> hi all
09:32:26 <SyntaxNinja> shapr: dija get to try cabal-get?
09:32:59 <Lemmih> YGM, SyntaxNinja.
09:35:01 <SyntaxNinja> YGM?
09:35:09 <shapr> SyntaxNinja: No, not yet.
09:35:12 <SyntaxNinja> FrederikEaton: be nice, would you?
09:35:45 <Lemmih> You've got mail.
09:35:49 <lispy`> yay!
09:36:15 <lispy`> heh, my friend is posting a link to my site on the linux game tome....now i'm worried my server won't be able to take the load :)
09:37:12 <SyntaxNinja> Lemmih: YGM
09:46:24 <basti_> is there a possibility to implement unsafeInterleaveIO "safely" (yielding some IO type)
09:47:28 <Igloo> It does have an IO type
09:47:36 <basti_> uhm
09:47:40 <basti_> @type unsafeInterleaveIO
09:47:46 <lambdabot> bzzt
09:47:52 <Igloo> @type System.IO.Unsafe.unsafeInterleaveIO
09:47:54 <lambdabot> forall a. IO a -> IO a
09:47:56 <basti_> ahh
09:47:58 <basti_> hmm yess.
09:47:59 <basti_> k.
09:48:42 <basti_> so basically it is safe. except for failures.
09:49:27 <Igloo> And destroying things it uses before it has used them
09:49:41 <basti_> how could that happen? "rm"?
09:50:45 * SyntaxNinja uses Igloo quick before someone destroys him
09:54:43 * rt will probably buy a hybrid in the next year or so.
09:54:53 <rt> doh.  wrong window *again*
09:55:29 <Lemmih> lispy`: In which thread?
09:57:29 <basti_> rt: good idea though, anyway.
09:59:35 <kosmikus> SyntaxNinja: is there a reason why Cabal still build-depends on util?
10:00:36 * basti_ is waiting for some c zealot to replicate the functionality of http://pastebin.com/343136
10:03:00 <rt> basti: any particular reason?
10:03:21 <basti_> oh he just opened his mouth too far.
10:03:44 <basti_> he's taking nearly a quarter hour now.
10:04:35 <kosmikus> SyntaxNinja: I'm sending you a patch, then you can decide what to do ...
10:04:42 <basti_> i needed a few minutes to look up the exact syntax of readFile (mainly to find out that it doesn't take a file handle as its argument)
10:04:44 <rt> doesn't this program just reproduce the input?
10:05:08 <rt> (in a relatively confusing way?)
10:05:10 <basti_> yes it does. the basic idea was "splitting a string"
10:05:26 <dcoutts> kosmikus, I sent SyntaxNinja that patch a couple weeks ago! :-)
10:05:38 <basti_> of course he did something with while first, and then used strtok. and then i said, what if i read the string from a file.
10:05:45 <basti_> He's busy with that part now.
10:05:57 * rt sighs.
10:06:01 <kosmikus> dcoutts: ok, now he's got it twice :)
10:06:11 <basti_> rt i know, it's stupid.
10:06:34 <rt> exercises like this are fairly meaningless.  We know that C string handling, well, sucks.  That has relatively little to do with either language's virtues.
10:06:46 <basti_> well he's using c++
10:06:53 <basti_> and its stl
10:07:00 <rt> oh, well, then he's obviously braindamaged.   Ignore him.
10:07:27 <basti_> http://pastebin.com/343147
10:07:33 <vegai> apparently not everyone knows it, rt
10:07:54 <rt> everybody who isn't braindamaged knows it. :-)
10:08:07 <lispy`> Lemmih: it's still awaiting moderator approval i think.  he submitted it as news
10:08:08 * rt tosses matches while standing in a pool of gasoline.
10:11:07 <vegai> basti_: challenge him to create functions that handle infinite lists :P
10:11:28 <basti_> thats for later.
10:11:49 <SyntaxNinja> damn, I can't remember why it build-depends on util; I feel like I keep taking i tout and putting it back, though. probably has to do w/ ghc 6.2 or something
10:12:02 <vegai> you're doing the Palpatine -style of converting there?
10:12:30 <rt> as i understand it, the prius runs electric at speeds < 10mph, and recharges at highway speed (or whenever charging is needed)
10:12:31 <basti_> palpatine?
10:12:52 <rt> damnt, two conversations in two windows leads to confusion on mondays.
10:13:06 <vegai> oh, sorry. Not everyone saw those crappy movies
10:13:24 <rt> well, it depends....
10:13:33 <SyntaxNinja> shapr: how's your elisp?
10:16:53 <dcoutts> SyntaxNinja, build-depends on util breaks many other programs, eg happy, ghc ... the list goes on and on
10:17:12 <basti_> can i apply readFile to stdin?
10:17:52 <SyntaxNinja> dcoutts: the question is, why is it there?
10:17:52 <dcoutts> SyntaxNinja, if cabal build-depends on util, then it effectively exposes it. And util is not exposed by default for a good reason. Every other prog that uses GetOpt.hs clashes with it.
10:17:53 <vegai> rt: sounds like you need to buy that new Lexus hybrid :P
10:18:24 <dcoutts> SyntaxNinja, I don't know, it doesn't seem to be necessary. But I've not checked ghc-6.2.2
10:21:10 <dcoutts> SyntaxNinja, but even if 6.2.2 needs it we need another solution because it's just not ok to expose util-1.0. It really does break everything.
10:21:17 <SyntaxNinja> eh, it's all well-and-good to tell me why it should be gone and to send me a one-line patch, but the real time-killer is figuring out why its there, what will break if I remove it, and how that can be worked around. that's what sucks about my job ;)
10:21:30 <rt> well, except for the money, a lexus would be nice. :-)
10:21:33 <dcoutts> poor SyntaxNinja :-(
10:21:45 <dcoutts> let me try with ghc-6.2.2
10:21:51 <SyntaxNinja> dcoutts: thanks :)
10:21:53 <dcoutts> would that make you happier? :-)
10:21:55 <SyntaxNinja> yeah
10:22:09 <SyntaxNinja> also, check the vc logs to see if they say anything
10:24:29 <kosmikus> is there an easy way to find all darcs patches that affect a certain file?
10:26:14 <Igloo> darcs changes filename
10:27:10 <shapr> SyntaxNinja: rudimentary, why?
10:28:52 <SyntaxNinja> there's some stupid function Ive been meaning to write for a while, but haven't got around to it. a guru would be able to write it in 5 minutes, but it'll take me a half hour probably.
10:29:45 <dcoutts> SyntaxNinja, heh :-). It doesn't build with ghc-6.2.2 with or without util in build-depends
10:29:49 <dcoutts> linker errors
10:30:20 <dcoutts> /usr/bin/ar: creating dist/build/libHSCabal-1.1.2.a
10:30:20 <dcoutts> dist/build/libHSCabal-1.1.2.a(Directory.o)(.text+0x61): In function `__stginit_DistributionziCompatziDirectory_':
10:30:20 <dcoutts> : undefined reference to `__stginit_SystemziPosix_'
10:30:20 <dcoutts> dist/build/libHSCabal-1.1.2.a(Directory.o)(.text+0x6e8): In function `DistributionziCompatziDirectory_copyFile_srt':
10:30:23 <dcoutts> etc...
10:30:24 <basti_> SyntaxNinja: probably, the guru would make it look like (.).(liftM2 (*))...
10:31:05 <lispy`> basti_: or hide all the details of how it accomplishes it's job inside a stack of monad transformers :)
10:31:17 * basti_ nods
10:31:21 <basti_> thats entirely possible
10:32:13 <lispy`> heh, someone should write a factorial monad for that page thet describes all those ways to implement factorial
10:33:07 <basti_> *g*
10:33:32 <basti_> i think hiding the function inside the type system is far more disgusting ;)
10:34:01 <lispy`> or evil :)
10:34:48 <basti_> actually it MIGHT make some sense. at some point in time.
10:35:26 <kosmikus> SyntaxNinja, dcoutts: the "util" has been added on January 16 in a patch labeled * CVS commits from Krasimir and Ross
10:36:51 <SyntaxNinja> dcoutts: did you make clean?
10:37:04 <SyntaxNinja> I use it w/ 6.2.2 pretty often
10:37:11 <dcoutts> SyntaxNinja, with the latest version from darcs it seems to be ok
10:37:27 <shapr> SyntaxNinja: What's the function?
10:37:29 <SyntaxNinja> kosmikus: is there more data in -v?
10:37:40 <dcoutts> SyntaxNinja, and the latest darcs version seems to have the util dep removed too
10:38:05 <SyntaxNinja> shapr: I have a function to open a file based on today's date... I also want one to open the most recent file from the past, so converting to ints, counting backward of dates
10:38:20 <SyntaxNinja> dcoutts: which versino are you using that breaks?
10:38:45 <shapr> Oh, you want "open-yesterday" ?
10:38:54 <shapr> Can I see the code for open-today ?
10:39:08 <kosmikus> dcoutts: you're not using the ebuild, are you?
10:39:15 <dcoutts> it was a snapshot we were using for our ebuild, it was a snapshot taken on 20050816
10:39:18 <SyntaxNinja> shapr: sure.
10:39:22 <dcoutts> kosmikus, yep
10:39:33 <kosmikus> dcoutts: the ebuild removes the util, of course
10:39:36 <dcoutts> using ghc-6.2.2
10:39:38 <dcoutts> yes I know
10:39:40 <SyntaxNinja> shapr: but it's not quite "open yesterday
10:39:41 <SyntaxNinja> "
10:39:55 <_metaperl> can a haskell algebraic type start with a number? eg: data BannerSource = BannerSource Direct | 3rdParty
10:40:10 <shapr> SyntaxNinja: The most correct approach would use the calendar code.
10:40:13 <dcoutts> kosmikus, it doesn't work with util left in either (ie commenting out the sed bit)
10:40:21 <lispy`> _metaperl: not that i know of
10:40:29 <lispy`> _metaperl: do you get an error?
10:40:47 <_metaperl> lispy: i'm lazy. havent tried it .prolly shoulda instead of writing here...
10:41:20 <dcoutts> SyntaxNinja, oh so you did apply my patch to remove util (I see from darcs changes Cabal.cabal)
10:41:32 <shapr> SyntaxNinja: send code?
10:41:54 <dcoutts> SyntaxNinja, well I can report that the latest version does build and like with ghc-6.2.2
10:42:02 <dcoutts> like/link
10:42:03 <SyntaxNinja> shapr
10:42:05 <SyntaxNinja> @paste
10:42:07 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
10:42:21 <kosmikus> dcoutts: no, I can't see your patch applied
10:42:38 <shapr> SyntaxNinja: haha, cute comment!
10:42:39 <SyntaxNinja> dcoutts: so the latest darcs is All Good?
10:42:44 <dcoutts> kosmikus, darcs changes Cabal.cabal
10:42:51 <dcoutts> Thu Jul 28 18:06:41 BST 2005  Duncan Coutts <duncan.coutts@worc.ox.ac.uk>
10:42:51 <dcoutts>   * Remove old hslibs package util from Build-Depends
10:43:01 <dcoutts> SyntaxNinja, seems so :-)
10:43:12 <kosmikus> must be local in your repo
10:43:21 <dcoutts> $ darcs revert
10:43:21 <dcoutts> There are no changes to revert!
10:43:33 <dcoutts> oh wait...
10:43:44 <kosmikus> revert is for unrecorded changes
10:43:57 <dcoutts> right (I just realised that, oops)
10:44:20 <SyntaxNinja> yeah, don't think it's in the repo
10:44:30 <dcoutts> SyntaxNinja, in that case I can report that should you apply my patch, it'll still build with ghc-6.2.2 :-)
10:44:49 <kosmikus> er, but why did you get linker errors then?
10:45:07 <dcoutts> kosmikus, not sure, it was an older snapshot
10:45:31 <kosmikus> which one? 0816? that should be current
10:45:53 <kosmikus> at least I don't have any other changes in the darcs repo since then
10:47:21 <dcoutts> kosmikus, yeah true. I don't see any changes either
10:49:00 <shapr> SyntaxNinja: What about (days-to-time (- (date-to-day (current-time)) 1)) ?
10:49:01 <SyntaxNinja> dcoutts: ok
10:49:19 <SyntaxNinja> never heard of that :)
10:49:54 <shapr> That turns current-time into days since year one, subtracts one day, then turns it into a time.
10:50:06 <shapr> Can you cast that into a date?
10:51:33 <shapr> hiya exa
10:51:59 <exa> hi
10:57:35 <exa> shapr: yesterday, we were discussing whether there were any real bots on #haskell.
10:57:41 <exa> I concluded that we are all bots.
10:59:13 <stepcut> @exa eval S K K K S I K S I
10:59:14 <lambdabot> Maybe you meant: eval vera
10:59:54 <exa> hehe
11:01:29 <exa> so did haskell have an eval function?
11:01:41 <exa> i remember something like a generic programming tool that allowed you to construct syntax trees but i'm not sure
11:02:04 * exa loves genericity!
11:02:04 <exa> +1 for type classes :)
11:02:26 <stepcut> exa: dons wrote a hsplugins thing that has an eval function
11:05:23 <Philippa_> and template haskell effectively has compile-time eval
11:05:45 <autrijus> and you can load hsplugins during compile time too.
11:05:50 <autrijus> (via runIO)
11:05:54 <Philippa_> and use TH in plugins
11:06:12 <autrijus> and generally become dangerously close to insanity
11:06:13 <Philippa_> I mean really, once we have boxy types and proper existentials... what'll the point of smalltalk /be/? :-)
11:06:51 <Philippa_> IMO getting a good grip on using staged computations well'll be a big deal for software design in the future
11:06:54 <Philippa_> but I could just be nuts...
11:07:13 <dcoutts> Philippa_, and will let us use nice partial evaluators for some cool results :-)
11:07:25 <Philippa_> that aside, I should be next door playing games with Damien now
11:08:29 <autrijus> Damian?
11:08:52 <Heffalump> autrijus: you were wondering about that nasty bit of perl I wrote?
11:08:53 <Philippa_> my boyfriend. He got back earlier after being away for a week
11:08:57 <Philippa_> other playing has happened already ;-)
11:09:02 <greenrd> yuck. I think generative programming is a hack.
11:09:06 <autrijus> Heffalump: yeah, the infinite loop thing
11:09:22 <Heffalump> it never infinite loops for me, but it wouldn't surprise me if you found a case where it did :-)
11:09:26 <Philippa_> greenrd: it's anything but. It /can/ be hard to control, but Haskell's in a better place to use it than most languages
11:09:51 <Philippa_> and really, what do you think's happening when you use a deriving clause? Or do you never derive Eq?
11:10:17 <greenrd> OK OK
11:10:27 <autrijus> Heffalump: nvm, I think I misread things :)
11:10:30 <greenrd> deriving is one of a few special cases
11:10:37 <Heffalump> ok :-)
11:10:50 <Philippa_> also, some systems pretty much have to take on new code during execution - content management systems for web sites're one example
11:10:54 <Heffalump> I haven't made much more progress on making it work without MULTIPLICITY, I'm afraid, too much other stuff to do.
11:11:07 <autrijus> nod. that's fine
11:11:18 <Heffalump> I've done a bit more to make it listen to the local perl config, but I may not have pushed that yet.
11:11:20 <Philippa_> greenrd: deriving generalises to a large number of typeclasses. Sure, you shouldn't use it all everywhere, but those special cases're a big area IMO
11:11:29 <Philippa_> anyway. Gaming.
11:11:35 <Heffalump> also some stuff trying to make it work with ghci properly.
11:14:37 * Oejet misses his girlfriend.
11:16:44 * lispy` feels Oejet's pain
11:17:02 * lispy` hasn't seen his gf in weeks
11:19:06 * basti_ 's gf moved out with bizarre rationalisations
11:19:07 <stepcut> mmmm.... grammatical framework
11:19:39 <Oejet> basti_: Ouch, that must have hurt.
11:19:55 <basti_> its not that we were fighting or anything
11:20:11 <basti_> i plainly don't understand the "why".
11:20:38 <lispy`> basti_: that is weird (of her)
11:20:53 <lispy`> stepcut: heh, i are don't needs grammars
11:20:54 <basti_> thats what i thought too.
11:20:57 <basti_> lol
11:21:33 <basti_> i thought, maybe i'm the one who's behaving bizarrely, but i don't think so
11:40:50 <dcoutts> SyntaxNinja, want a couple minor bug reports for cabal with ghc-6.2.2 ?
11:40:59 <lispy`> so i have some ideas how what we should do to hack the quake3 engine
11:41:16 <dcoutts> SyntaxNinja, actually it's only one problem, which causes other problems
11:41:56 <lispy`> 1) add the bohem&weiser gc 2) make sure that the qvm is getting automatically gc'd 3) double check performance 4) retarget some existing haskell compiler to generate qvm bytecode
11:42:16 <lispy`> then quake3 could be scriptable in haskell!
11:42:22 <dcoutts> SyntaxNinja, on ghc 6.2.2 you need to depend on the unix package in addition to the base package. The System.Posix.Files module moved from the unix package to the base package in ghc 6.4.
11:42:41 <dcoutts> SyntaxNinja, so for ghc 6.2.2 you still need the unix dep.
11:42:50 <SyntaxNinja> dcoutts: can you email me?
11:42:55 <dcoutts> sure
11:47:33 <SyntaxNinja> thanks
11:55:24 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday.html
11:55:28 <Beelsebob> woo yay
11:55:32 * Beelsebob is back
11:56:03 <Itkovian> hi
11:56:17 <Itkovian> all is cool, except for the singing ;-)
11:56:19 <Itkovian> brb
12:05:40 <xerox> @hoogle Int -> Double
12:05:42 <lambdabot> Prelude.toEnum :: Enum a => (Int -> a)
12:05:42 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
12:05:42 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
12:32:23 * SamB wonders how one would build a parser on top of a monadic scanner...
12:33:36 <xerox> Initial font support in cairobindings!
12:33:50 <xerox> Demo output: http://haskell.galois.com/~paolo/Text.png
12:33:52 <exa> a monadic parser of course :P
12:33:57 <xerox> Expected output: http://haskell.galois.com/~paolo/text.png
12:34:03 <xerox> heh.
12:34:11 <autrijus> oooh!
12:34:18 <autrijus> xerox: you are the hscairo person?
12:34:32 <SamB> exa: well yeah, but I don't know of any monad transformer-supporting parsing combinators...
12:34:40 <xerox> autrijus: the new one, yeah
12:34:49 <autrijus> I've been meaning to play with it, but with gecko/cairo moving somehow I wonder if generating xhtml/svg is easier.
12:34:49 <xerox> autrijus: founded by Google!  For the SoC thing
12:35:02 <Heffalump> samb: run the scanner to produce a list of tokens, feed this into parser
12:35:06 <autrijus> wow. google funded haskell projects?
12:35:08 <autrijus> didn't know that
12:35:10 <xerox> !!!
12:35:15 <xerox> http://haskell.org/gtk2hs/
12:35:21 <exa> Now's a good time to meditate on one, then, SamB :)
12:35:46 <Heffalump> no, don't :-) The right interface here is a lazy list.
12:35:55 <SamB> Heffalump: unfortuntately the language in question seems to just about require some rather nasty feedback from the parser to the scanner...
12:35:55 <autrijus> xerox: excellent.
12:35:59 <exa> summer code cool
12:35:59 <exa> i wish i knew about that
12:35:59 <exa> fool
12:36:00 <xerox> autrijus: indeed!
12:36:08 <jlouis> xerox: cool
12:36:11 <Heffalump> SamB: ah.
12:36:14 <autrijus> xerox: so, with deadline in a week... how's stuff? :)
12:36:20 <xerox> hehe
12:36:24 <xerox> Let me find it...
12:36:29 * jyp needs a hs-plugins guru
12:36:35 <xerox> http://haskell.org/gtk2hs/archives/2005/08/17/code/#comment-35
12:36:42 <xerox> Gtk integration is working.
12:36:47 <SamB> the language is Self, the particular construct responsible for this mess is resends...
12:37:00 <Heffalump> how does the lexer receive the feedback?
12:37:01 <xerox> http://haskell.galois.com/~paolo/StarAndring.png
12:37:11 <xerox> Image-writing backends are working
12:37:20 <xerox> The last thing is Fonts, somewhat complex :-)
12:37:25 <autrijus> eggcellent
12:37:31 <jyp> xerox: 404'ed
12:37:40 <xerox> jyp: hmm you could darcs get and try yourself :-)
12:37:43 <xerox> @cairo
12:37:45 <lambdabot> Unknown command, try @listcommands.
12:37:45 <xerox> @where cairo
12:37:46 <autrijus> hm, can this be decoupled with x11?
12:37:46 <lambdabot> I know nothing about cairo.
12:38:09 <xerox> darcs get http://haskell.galois.com/~paolo/darcs/gtk2hs
12:38:32 <xerox> ...and it's inside the gtk2hs sources as you see :-)
12:39:11 <jyp> Anyone know what AltData.Typeable.Typeable is and why it exists (and is /= from regular Typeable) ?
12:39:21 <jyp> ... this is from hs-plugins
12:39:36 <xerox> demo/cairo/MonadicStarAndRing.hs  is an example of actual usage of the bindings
12:39:44 <xerox> (as Text.hs but it's in developing)
12:39:47 <dcoutts> autrijus, yes its completely independent of x11
12:39:50 <xerox> ..any feedback is higly appreciated.
12:39:58 <dcoutts> autrijus, x11 is just one of the cairo backends
12:40:07 <autrijus> right, but I mean the gtk2hs part.
12:40:07 <Heffalump> what is cairo?
12:40:18 <xerox> Heffalump: a vector graphic library www.cairographics.org
12:40:28 <xerox> autrijus: yep, there are different backends
12:40:30 <dcoutts> autrijus, we're just building it with gtk2hs at the moment, it'll be distributed seperately eventually
12:40:31 <autrijus> does it mean I can draw a gtk dialog and print it as pdf?
12:40:40 <dcoutts> autrijus, not quite
12:40:45 <xerox> You can get a surface with the PDF backend
12:40:49 <xerox> and draw on it
12:40:57 * SamB digs through the original Self parser/scanner to try and figure out how this is supposed to work
12:40:59 <autrijus> yeah, I understand that much
12:41:00 <dcoutts> autrijus, but you can draw in a window and then draw the exact same to a png/ps/pdf
12:41:06 <autrijus> but it's must lower level than (say) thru gecko
12:41:10 <autrijus> s/must/much/
12:41:16 <autrijus> dcoutts: aha. that's better.
12:41:23 * SamB is beginning to wonder if there is any such strange feedback after all
12:41:36 <Heffalump> how does cairobindings differ from the hscairo referred to on that page?
12:41:38 <dcoutts> autrijus, right, drawing widgets to a pdf is not very usefuly anyway :-)
12:42:02 <Heffalump> it'd be very useful when making a user manual.
12:42:11 <SamB> dcoutts: also, for printing screenshots!
12:42:12 <autrijus> just look at quartz :)
12:42:31 <dcoutts> Heffalump, that's what the screen capture thingy is for!
12:42:42 <SamB> dcoutts: that looks ugly!
12:42:45 <dcoutts> autrijus, yes it's got quartx backend too
12:42:46 <Heffalump> does that capture vectors?
12:43:07 <autrijus> wouldn't be fun if it doesn't :)
12:43:20 * autrijus waves and sleeps &
12:43:24 <xerox> Goodnight autrijus
12:43:41 <dcoutts> Heffalump, ok, no it's not yet a fully vector gui. Gtk does now use cairo, but I don't think it qualifes as a fully vector widget set yet
12:48:08 <SamB> huh, it looks like my Self parser just got several orders of magnitude easier to write... there doesn't seem to be any wierd feedback after all.
12:48:47 <SamB> though the scanner will still need to look two characters ahead...
12:49:42 <SamB> so I will probably need to use a hand-coded scanner for the present
12:50:32 <dcoutts> Heffalump, the point is, this is not for making gtk vectorised, but to allow gtk gui apps to use nice vector graphics
12:50:46 <Lemmih> @seen CosmicRay
12:50:47 <lambdabot> I saw CosmicRay leaving #haskell 10 days, 40 minutes and 54 seconds
12:50:47 <lambdabot> ago, and I have missed 5 days, 12 hours and 49 minutes since then.
12:51:00 <dcoutts> Heffalump, and indeed in non-gui apps, and targeting printed output too (png/ps/pdf)
12:52:03 <SamB> isn't it more the province of particular themes and engines to be vectorised or not, for the most part?
12:52:10 <dcoutts> SamB, indeed
12:55:11 <SamB> of course, certain types of widgets presumably render on their own, such as the GL widgets...
12:55:39 <SamB> probably the HTML widgets...
12:56:19 <Heffalump> dcoutts: right
12:56:48 <Heffalump> I was just pointing out that being able to turn dialogs into vector graphics isn't such a silly idea :-)
13:29:06 <Beelsebob> @seen Philippa
13:29:07 <lambdabot> I saw Philippa leaving #haskell 8 hours, 49 minutes and 10 seconds
13:29:07 <lambdabot> ago.
14:01:53 <Itkovian> Beelsebob: het bf just got home ...
14:01:57 <Itkovian> s/het/her/
14:02:04 <Beelsebob> i c
14:02:07 <Beelsebob> :)
14:06:39 * Itkovian is tired
14:06:46 <Beelsebob> so am I
14:07:04 <Beelsebob> was it you asked if I was doing the west highland way itkovian?
14:07:09 <Itkovian> nope
14:07:19 * Beelsebob wonders who it was
14:07:25 <Itkovian> for all I care you can go eastward too
14:07:34 <Beelsebob> heh
14:07:45 <FrederikEaton> has anyone used the hughes pretty printer? how do i insert a blank line between docs, in such a way that if there is already a blank line it gets eaten?
14:08:02 <Itkovian> erm
14:17:28 <FrederikEaton> hrm
14:18:22 * boegel_ yawns
14:19:00 <Itkovian> dons: afaik all symbols are present in the ghc libs
14:19:03 <Itkovian> hi boegel
14:19:08 <boegel_> hi Itkovian
14:19:18 <Itkovian> I'm moving my gear to the couch
14:19:59 <boegel_> hmm, nick coloring doesn't seem to work, strange...
14:20:45 <boegel_> someone say "boegel" !
14:20:50 <Itkovian> boegel!
14:21:59 <boegel_> Itkovian, yaay, it works now :)
14:22:17 <boegel_> Itkovian: shouldn't you be in bed by now ? ;) it's an early day tomorrow
14:23:44 <Itkovian> i know ...
14:23:53 <Itkovian> watching the news
14:24:17 <Beelsebob> mmm... news
14:24:26 <Beelsebob> why's it an early day tomorrow?
14:25:10 <Itkovian> I have to go to work
14:25:20 <Beelsebob> don't we all?
14:25:23 <Itkovian> however, I was up earlier today than I will be tomorrow
14:25:30 <Itkovian> I worked at home today
14:27:20 <yeti>    No instance for (Num (Field a)) <= how can i define an instance for (Num (Field a)) ? (Field is a datatype i defined myself)
14:27:40 <Heffalump> instance Num (Field a) where
14:27:41 <Heffalump>   ...
14:27:44 <Beelsebob> instance Num (Field a) where ...
14:27:49 <Beelsebob> damn... beaten to it
14:27:50 <Heffalump> you may find that
14:27:55 <Heffalump> instance Num a => Num (Field a) where
14:27:57 <Heffalump>   ...
14:28:00 <Heffalump> is what you actually want
14:28:03 <Beelsebob> or... just deriving Num micht work
14:28:07 <Beelsebob> might*
14:28:13 <Heffalump> is that derivable?
14:28:25 <Beelsebob> I thought it just stripped off the constructors
14:28:30 <Beelsebob> but I might be being stupidh
14:28:31 <Heffalump> another good question is why you are getting the lack of instance.
14:28:48 <Heffalump> Beelsebob: if its defined by newtype Field a = a , then there's a ghc extension that would let you do that
14:28:58 <Beelsebob> ah, okay
14:29:03 <Heffalump> but it's not standard H98 and it's not particularly useful in the general case.
14:29:10 <Beelsebob> so probably deriving wont work then
14:29:15 <Beelsebob> you'll need an instance
14:29:16 <yeti> oh, that's too advanced for me :)
14:29:24 <Beelsebob> no it isn't
14:29:35 <Beelsebob> all you need to do is specify a few functions
14:29:39 <Heffalump> though often that error comes about because you have used something of type Field a as an argument to an arithmetic operator by accident.
14:29:45 * Beelsebob goes and looks up what for Num
14:29:54 <Heffalump> so check if you really want Field a to behave like a number
14:30:06 * TheHunter finds generalized newtype deriving extremely useful.
14:30:30 <Heffalump> saves a bunch of boilerplate, but doesn't actually save any real work
14:30:36 <Beelsebob> you need to define... (+), (-), (*), negate, abs, signum and fromInteger
14:31:22 <yeti> is there any really good haskell book? i bough hudak's haskell school of expression off ebay, but it doesn't help me much
14:31:25 <yeti> Beelsebob: ah okay thx
14:31:31 <TheHunter> but the work it does save makes it worthwhile to use newtypes instead of types in some cases.
14:31:39 <Beelsebob> yeti: Simon Thompson's book
14:32:09 <Beelsebob> I learned from Tony Davie's book... but that's mostly because he was my dad and there was a copy lying around
14:32:18 <Heffalump> TheHunter: fair enough
14:32:27 <TheHunter> and there are (more or less contrived) cases, in which you can do stuff with newtype deriving you couldn't do otherwise.
14:34:39 <yeti> Beelsebob: oh, thompson's book is EUR 44,50 from amazon... i guess it's worth it though?
14:34:56 <Heffalump> there are some good online tutorials
14:35:07 <yeti> i'm reading one of them atm
14:35:08 * boegel_ wishes everyone goodnight
14:35:13 <yeti> good night boegel_
14:35:15 <Heffalump> I think different people are suited to different styles of book.
14:35:15 <Lemmih> 'night boegel_.
14:35:16 <Beelsebob> yeti: very much so, it's a good read even if you already know the language (or at least a good chunk of it)
14:38:10 <yeti> Beelsebob: where did you look up which functions you need to define for Num?
14:38:20 <Beelsebob> @google Haskell Num
14:38:22 <lambdabot> http://www.zvon.org/other/haskell/Outputprelude/Num_c.html
14:38:25 <Beelsebob> :)
14:38:31 <yeti> ah :)
14:44:48 * TheHunter wonders if newtype-deriving is indeed evil.
14:45:40 <dcoutts> no! newtype-deriving is from the gods
14:45:51 <dcoutts> why evil?
14:46:12 <monochrom> whether evil can be from the gods is theological
14:46:35 <monochrom> there are theology theories that says yes :)
14:47:05 <monochrom> (there are theology theories that says anything you want :) )
14:47:17 <TheHunter> i'm still investigating, but it might be able to subvert type-safty if the nice interplay between gadts and fundeps is implemented.
14:48:00 <monochrom> that would be interesting
14:49:29 <xerox> Because it makes GHCi give an exception with my code? :-P
14:51:47 <TheHunter> ok, one of those things is evil, i'll write to the mailing-list about this this evening, but first of all, i gotta grab some food.
14:52:50 <yeti> http://yeti.yefx.net/Field.hs <= i think i messed up the Eq instance for Possibly a, but i don't know in what way
14:54:03 <Cale> yeti: why not just write  Possibly a == Possibly b = a == b
14:54:27 <Cale> or just derive Eq
14:54:48 <Cale> or do you want to check set equality?
14:54:55 <yeti> cause i want  ( Possibly [5,4] == Possibly [4,5] ) => True
14:54:55 <Cale> yeah, that's probably what you're doing, sorry
14:54:59 <Cale> okay
14:55:26 <Cale> You're going to need (Ord a, Eq a) => Eq (Field a) then
14:57:24 <Cale> You may also find it convenient to use Set a instead of [a] for sets.
14:57:36 <Cale> It's a good deal more efficient for many operations
14:58:09 <xerox> TheHunter: which ml?  I'd like to follow the discussion.
14:59:06 <yeti> do i have to import any modules to use Set?
15:00:17 <xerox> Data.Set
15:00:23 <xerox> @docs Data.Set
15:00:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Set.html
15:15:12 <jlouis> it takes some time to build your own set implementation. In SML you have to do that and it always takes a couple of hours and is inefficient
15:16:30 <TheHunter> xerox, not sure yet, there was a related discussion sometime ago. Probably haskell-cafe.
15:16:42 <xerox> OK.
15:23:10 <TheHunter> will probably become an answer to http://www.haskell.org/pipermail/haskell-cafe/2005-August/010974.html.
15:24:19 <xerox> Thanks :-)
15:28:02 <xerox> Oh, I was reading this thread on GMane some days ago.
15:33:51 <Heffalump> why not do a source-to-source transformation removing foralls from types where functional deps allow?
15:41:33 <lispy`> does haskell have loop construct for the IO monad?
15:41:55 <lispy`> sometimes i want to loop on an anonymous IO computation
15:42:05 <lispy`> i could write it, but only if it doesn't exist :)
15:42:24 <Lemmih> @type Control.Monad.replicateM_
15:42:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
15:43:26 <SamB> what is a good parser combinator library to use with a scanner?
15:44:42 <Lemmih> Parsec?
15:45:10 <shapr> jiihaa
15:45:13 <SamB> I got the sense that a lot of the combinators were needlessly typed with Char...
15:46:46 <lispy`> Lemmih: i the analog of while (true) { .... }
15:47:33 <lispy`> right now i'm using mapM_ with an infinite list, which is why i think my program getts axed by the oom killer in linux
15:48:05 <lispy`> something like, forever :: forall (m :: * -> *) a. (Monad m) => m a -> m ()
15:48:28 <xerox> replicateM_ (-1) ? :-P
15:48:30 <lispy`> but the looping mechanism needs to consume constant space
15:48:37 <lispy`> xerox: does that work?
15:48:40 <xerox> Dunno.
15:48:52 <lispy`> i'm guesing it gives an pattern match error
15:48:57 <lispy`> or similar
15:49:19 <lispy`> @eval Control.Monad.replicateM_ (-1) [1]
15:49:22 <lambdabot> [()]
15:49:28 <lispy`> hm....
15:49:34 <lispy`> not sure what that means :)
15:50:01 <lispy`> forever m = m >> forever m
15:50:18 <lispy`> i think that would work
15:50:20 <xerox> mdo ?
15:50:31 <Heffalump> mapM_ with an infinite list should use constant space
15:50:51 <Heffalump> unless the list elements grow, or the monad itself consumes space as it runs
15:50:51 <lispy`> i use: mapM_ (\_ -> do ... ) [1..]
15:51:02 <Heffalump> oh, well [1..] will have growing list elements..
15:51:04 <lispy`> so the list elements grow
15:51:09 <Heffalump> though they will only grow very slowly
15:51:10 <lispy`> i use: mapM_ (\_ -> do ... ) ones
15:51:26 <lispy`> Heffalump: well, the iteration happens very quickly
15:51:28 <Heffalump> what is the monad and what is the body of the do ?
15:51:44 <Heffalump> lispy`: even so, you'd need a lot of iterations for the list element to fill physical memory..
15:52:17 <lispy`> the monad is IO, and the do checks a Chan, optionally processes what it finds and put it into another Chan.  The other ones check sockets, process anything they find in a Chan and then loop
15:53:05 <lispy`> i'm guessing the ones that check for socket activity are the ones that are causing the oom
15:53:18 <lispy`> oh, maybe i need to do it differently
15:53:31 <lispy`> i could have two threads for each client
15:53:41 <lispy`> one that sleeps on the socket, and the other processes events
15:53:50 <Beelsebob> @seen Spherical
15:53:51 <lambdabot> I haven't seen Spherical.
15:54:00 <Beelsebob> @seen Spherical`
15:54:01 <lambdabot> I saw Spherical` leaving #haskell 19 days, 22 hours, 11 minutes and
15:54:01 <lambdabot> 3 seconds ago, and I have missed 9 days, 9 hours, 6 minutes and 30
15:54:01 <lambdabot> seconds since then.
15:54:09 <Beelsebob> odd
15:54:10 <lispy`> Beelsebob: hi, i had something i wanted to talk to you about...but it escapes me now
15:54:26 <Beelsebob> :/
15:54:40 <lispy`> Beelsebob: oh, delta debugging.  How is that going?
15:54:43 <Beelsebob> was it you asking if I was doing the west highland way lispy?
15:55:02 <Beelsebob> lispy: just back from holiday, and I'm gonna find out in a few days
15:55:09 <lispy`> sorry, i live in the US and have on ideas about the west highland
15:55:21 <lispy`> Beelsebob: cool, is there a place where i can watch your progress?
15:55:22 <Beelsebob> fair enough
15:55:48 <Beelsebob> lispy: not really, when I make it work I'll add it to hat
15:56:00 <Beelsebob> hat-detect works again though
15:56:03 <lispy`> we might be implementing delta debugging in a functional environment (spreadsheet instead of normal PL)
15:56:03 <Beelsebob> which is good :)
15:56:11 <lispy`> cool
15:56:17 <lispy`> i should learn to use hat
15:56:30 <lispy`> i bet it would help me debug my server problems i was just describing
15:56:59 <Beelsebob> possibly... depends how much non H98 you use
15:58:28 <lispy`> well, the spreadsheet is written in lisp :)
15:58:38 <lispy`> so very much non-H98
15:58:47 <Beelsebob> probably wont help you then ;)
15:58:54 <lispy`> we still have lazy eval
15:59:04 <Beelsebob> although the tracing system it's self is a good design for all functional languages
15:59:07 <lispy`> are you writing a paper about it?
15:59:14 <Beelsebob> the delta debugging?
15:59:15 <Beelsebob> yes
15:59:19 <lispy`> okay
15:59:38 <Beelsebob> I'm gonna present something at IFL... if I write it soon enough
15:59:46 <lispy`> okay
15:59:47 <Beelsebob> that seems to be tomorrow's work
16:00:08 <lispy`> i don't know how soon we'll get around to implementing it
16:00:22 <lispy`> could be another year, or it could start next fall
16:00:28 <Beelsebob> well, I should be implementing the first part of the delta stuff this week
16:00:38 <Beelsebob> and the comylicated bit by the end of the month
16:00:50 <lispy`> okay
16:02:41 <Beelsebob> anyone fancy admiring my crap photography?
16:03:04 <lispy`> of the west highlands?
16:03:12 <Beelsebob> indeed
16:03:18 * lispy` waits for the url
16:03:43 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday.html
16:04:05 <Beelsebob> particularly proud of http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday-Pages/Image4.html and http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday-Pages/Image9.html
16:04:38 <Oejet> Beelsebob: Wow.
16:04:51 <lispy`> those are nice
16:05:18 <Beelsebob> the sunset took about 60 takes to get
16:05:29 <lispy`> heh
16:05:41 <lispy`> that waterfall is amazing
16:05:51 <Pseudonym> That's one of the secrets of photography, though.  Take a lot of pictures and throw away a lot.
16:06:04 <Pseudonym> It's not the _whole_ story, of course.
16:06:11 <Beelsebob> that or get really really good at taking the *one* shot that works
16:06:21 <Beelsebob> I know a couple of guys that do that
16:06:36 <Pseudonym> They must be either very very VERY clever, or very very VERY lucky.
16:06:48 <Beelsebob> the earlier I think
16:06:50 <Pseudonym> There were these taken?
16:07:18 <Pseudonym> Sorry, WHERE
16:07:27 <Beelsebob> the first few were taken in Torridon, the one in the building is in Edinburgh, and the last few around Loch Lomond
16:07:41 <Beelsebob> the last one is conic hill looking down the fault
16:07:46 <Heffalump> http://urchin.earth.li/photopub/range?range=/users/ganesh/monkeynut/119-125,140,147&style=/users/ganesh/across # cool waterfalls in Iceland
16:07:58 <Pseudonym> Cool.
16:08:02 <Beelsebob> nice
16:08:05 <Pseudonym> Never been to Scotland.
16:08:24 * lispy` has never left the US :(
16:08:33 <Pseudonym> I've been to the Grampians in Australia.  Does that count?
16:08:35 * Heffalump has only been to Scotland twice, I think.
16:08:42 <lispy`> not even canada or mexico
16:08:53 <Heffalump> and one of those times I was a baby.
16:09:52 <Beelsebob> this burn actually goes up the path of a fault http://www.cs.kent.ac.uk/people/rpg/tatd2/Albums/Holiday/Holiday-Pages/Image5.html
16:10:03 <Beelsebob> the fault carries up into the mountain behind
16:10:10 <Beelsebob> and leaves a massive gash in it
16:10:15 <Beelsebob> about 1500 feet deep
16:10:28 <Pseudonym> Wow.
16:10:48 <shapr> Pseudonym: tmr poke?
16:10:54 <Pseudonym> Yeah, I know. :_)
16:10:57 <Heffalump> Beelsebob: cool
16:11:00 <Pseudonym> Thanks for the poke, though.
16:11:08 <Pseudonym> Almost done.  I just have to write a bit more theory.
16:11:12 <Heffalump> oh, this waterfall is on the Mid-Atlantic Ridge: http://urchin.earth.li/photopub/display?photo=/users/ganesh/monkeynut/134&thumb=640x640
16:11:15 <Beelsebob> http://www.gillean.demon.co.uk/Images/Alligin1.jpg someone elses photo of it... http://www.gillean.demon.co.uk/Images/Alligin1.jpg
16:11:21 <Beelsebob> bah... stupid
16:11:33 <xerox> What do you think about a cool example of using Maybe, for a beginner?
16:11:35 <Beelsebob> that one's really pretty
16:11:51 <Pseudonym> xerox: I'm not sure that Maybe can really be called "cool".
16:11:52 <shapr> Philippa_: Think you'll have an article for the next issue?
16:12:05 <shapr> Definite articles are Oleg's article, and Pseudonym's article...
16:12:05 <Pseudonym> Maybe using it as a monad?
16:12:18 <xerox> Pseudonym: I'm teaching Haskell to a friend, now he can understand type signatures and define functions.
16:12:25 <Pseudonym> Ah, right.
16:12:32 <Pseudonym> What about boegel?
16:12:41 <Pseudonym> How's his article coming?  Do we know?
16:12:53 <shapr> Says he won't be able to finish his HRay article for this issue.
16:12:58 <Pseudonym> (It would actually be kinda cool if I could coordinate my article with his.)
16:13:03 <xerox> Pseudonym: what do you think I could teach him now?
16:13:16 <shapr> And I'm moving to another city and starting college, not sure if I'll be able to continue with TMR.
16:13:23 <Pseudonym> Oooh.
16:13:25 <Pseudonym> Where to?
16:13:31 <shapr> Next city over, LuleÃ¥
16:13:42 <Pseudonym> That's a strange capitalisation for a city.
16:13:51 <shapr> ?
16:13:57 <Pseudonym> I see it as LuleAY
16:14:03 <shapr> Oh, it's a-ring
16:14:06 <Pseudonym> Right.
16:14:10 <shapr> lule&aring;
16:14:11 <Pseudonym> Curse you, UTF-8!
16:14:19 <shapr> It's the way of the present.
16:14:22 <Beelsebob> nothing wrong with UTF
16:14:35 <Pseudonym> No, nothing wrong with it, except my terminal doesn't like it.
16:14:45 <Pseudonym> Curse you, bad terminal!
16:14:46 <shapr> Anyway, does someone want to take over TMR? Or at least co-lead in case I have little or no time?
16:15:41 * shapr delegates...
16:15:57 <Pseudonym> I would volunteer, but I can't even seem to get articles out on time.
16:15:57 <shapr> I'll just ask in the editorial then.
16:16:12 <Pseudonym> I can't imagine how much I'd procrastinate over a whole journal.
16:16:14 <shapr> Being editor is easier in some ways, you just have to bug other people :-)
16:16:57 <lispy`> heh
16:17:04 <shapr> I hope to clean out haskell-libs before I start classes.
16:17:36 <lispy`> clean out?
16:17:52 <Heffalump> from sourceforge?
16:17:59 <shapr> Yup
16:18:03 <Pseudonym> Can anyone recommend a good Linux terminal-like application that CAN handle lots of character sets?
16:18:15 <shapr> uxterm?
16:18:18 <lispy`> Pseudonym: there is aUTF-8 xterm
16:18:19 <Pseudonym> Every time shapr writes in Russian I think someone is trying to hack my machine remotely.
16:18:28 <Pseudonym> xterm is a bit of a kludge these days, though.
16:18:28 <lispy`> heh
16:18:41 <lispy`> i'd be surprised if gnome-term can't
16:18:43 <shapr> I don't write Russian! ÐÐ´ÑÐ°Ð²ÑÑÐ²ÑÐ¹ÑÐµ!
16:18:51 <Igloo> IWW, Pseudonym?
16:18:51 <Pseudonym> I was hoping for something a bit more modern like eterm, konsole or gnome-term.
16:18:53 <lispy`> all i see are ????????? makes
16:18:55 <lispy`> er marks
16:19:04 <Pseudonym> Industrial Workers of the World?
16:19:10 <shapr> In What Way
16:19:12 <Igloo> In What Way
16:19:12 <Pseudonym> Here's what I saw:
16:19:17 <Pseudonym> DWDDWD'N@DoD2NAND2NCD1NDm!
16:19:30 <Pseudonym> Well, I'd like to select my colour scheme and fonts via menus and dialogs.
16:19:33 * Beelsebob just discoverd that a russian phonetic layout doesn't work well if you don't know qwerty
16:19:38 <Cale> ÑÑÐ°Ð½ÑÐ»Ð¸ÑÐµÑÐ°ÑÐµÐ´ ÑÑÑÑÐ¸Ð»Ð¸Ñ
16:19:39 <Pseudonym> That sort of way.
16:19:46 <shapr> Cale: exactly!
16:19:50 <Beelsebob> looked russian to me
16:19:55 <Pseudonym> <Cale> NN@DoD2NAD>D,NDmN@DoNDmD' NFNKN@N@D,D>D,NF
16:20:04 <Cale> hehe
16:20:04 <lispy`> <Cale> ÑÑÐ°Ð½ÑÐ»Ð¸ÑÐµÑÐ°ÑÐµÐ´ ÑÑÑÑÐ¸Ð»Ð¸Ñ
16:20:07 <shapr> What about Thai? à¸ªà¸§à¸±à¸ªà¸à¸µà¸à¸£à¸±à¸, à¸ªà¸§à¸±à¸ªà¸à¸µà¸à¹à¸°
16:20:08 <lispy`> that's with emacs
16:20:08 <Pseudonym> Some of those letters were highlighted, though.
16:20:26 <lispy`> well, emacs+putty
16:20:36 <Igloo> The impression I have is that xterm is the well written one, and the others are less correct by varying degrees (in things like their VT100 emulation, and how well they match the xterm terminal type if they claim to), but they have gimmicky features like transparency and matching themes etc
16:20:47 * Beelsebob tries out chinese é½«é½é½´é»»éº
16:20:52 <shapr> Beelsebob: ooh!
16:21:08 <shapr> Japanese? ããã«ã¡ã¯, ï½ºï¾ï¾ï¾ï¾
16:21:18 <Cale> à¹à¹à¸£à¸à¸à¹à¸·à¸à¸²à¸ªà¸
16:21:36 * lispy` likes rxvt
16:21:38 <Pseudonym> Mi deziras tajpi Esperanton, sen x-oj.
16:21:47 <shapr> EÄ¥oÅanÄo ÄiuÄµaÅ­de
16:21:48 <Beelsebob> korean? ã¿ã¼ããã¶
16:22:01 <xerox> You should provide translation to english :)
16:22:04 <shapr> Beelsebob: Can't see it, what about ìëíì¸ì, ìëíì­ëê¹
16:22:16 <Beelsebob> that came out fine here
16:22:17 <xerox> Martian?
16:22:19 <Cale> I don't have canna installed, so I can only type in katakana.
16:22:22 <Pseudonym> Oh, dear.  Just heard that Bob Moog died.
16:22:28 <Pseudonym> Sad day.
16:22:29 <shapr> Of Moog synthesizer?
16:22:32 <Cale> yeah
16:22:33 <stepcut> :(
16:22:33 <Pseudonym> Yup.
16:22:59 <stepcut> accidently strangled himself on a patch cord
16:23:01 * Pseudonym wishes he had his Wendy Carlos albums here to comfort him
16:23:02 <liyang> ãªãã§ããªã?!
16:23:03 <Cale> I should get japanese support working again.
16:23:23 * Beelsebob gets support for just about everything by default
16:24:00 <liyang> Cale: uim is the way forward. :)
16:24:25 * shapr had a virtual theremin for his Palm IIIx
16:24:34 <Pseudonym> Oooh.
16:24:35 <Cale> liyang: I'll check it out
16:24:37 <Pseudonym> Do you still have it?
16:24:48 <shapr> Not sure, do you have a palm?
16:24:56 <Pseudonym> I gave my IIIx to my mother, but I still have an m500.
16:25:00 * Pseudonym couldn't survive without it
16:25:17 <stepcut> Pseudonym: i think you mean ..ooOOOoo.ooOOooo...oooOOOoooh
16:25:23 * Pseudonym points the IR sensor at the screen
16:25:25 <Heffalump> my Vx is dying :-(
16:25:25 <Pseudonym> Ready when you are.
16:25:29 <shapr> Pseudonym: http://www.palmsource.com/interests/emulators/
16:25:38 <Pseudonym> Ah, thanks.
16:25:46 <shapr> My IIIx just won't die. I ended up giving it to someone.
16:26:01 <shapr> My IIIc is flakier than the IIIx
16:26:28 <shapr> I want one of those T5 models with 128mb of ram. There's a nice Linux kernel version that runs on those.
16:26:32 <Pseudonym> The only catch with the IIIx is the thing where you have to crack it open and fix the cable to the screen.
16:26:53 <shapr> My only catch was scratching the graffiti area so badly I couldn't write anymore.
16:27:01 <shapr> Never install NetHack for PalmOS :-(
16:27:12 <shapr> I went through *lots* of batteries.
16:27:15 <Igloo> Does anyone know if I can assume that a filename of "" in a CGI request means no file was sent?
16:27:16 <stepcut> :p
16:27:32 <Heffalump> my gf has an old IIIx I could nab, actually.
16:27:35 <Pseudonym> Actually, there are really only two reasons why I ditched the IIIx.  One was the batteries.
16:27:45 <Pseudonym> The other was that you couldn't get a PDF reader for it.
16:28:08 <Heffalump> a new Palm would have the advantage of having a CPU designed by the company I now work for
16:28:16 <Heffalump> so I could play with it
16:28:16 * stepcut really wants a good ebook reader with ps/pdf support...
16:28:31 <shapr> Wow, ScummVM runs on PalmOS!
16:28:35 <xerox> SummVM!
16:28:42 <Pseudonym> stepcut: thout it
16:28:42 <liyang> Heffalump: ARM? Or TI?
16:28:42 <Pseudonym> <stepcut> Pseudonym: i think yo
16:28:50 <Heffalump> liyang: ARM
16:28:51 <Pseudonym> stepcut: http://www.adobe.com/products/acrobat/acrrpalmdload.html
16:28:55 <Pseudonym> Sorry, mispaste.
16:28:56 <xerox> I do have Acrobat Reader on my Nokia 6630 :-D
16:29:17 <shapr> I like being able to recharge and sync my Palm IIIc by smacking it on the cradle.
16:29:21 * liyang had a play with an OMAP developer kit for a whole summer in 2003...
16:29:25 <stepcut> Pseudonym: neat
16:29:37 <shapr> I'd rather have a Palm clone that ran purely open source code though.
16:29:39 <Heffalump> shapr: that's nice, until the battery gives out like on my Vx
16:29:41 <stepcut> Pseudonym: pdf only though ?
16:29:48 <Pseudonym> Right, but I have pdf2ps.
16:29:53 <Pseudonym> Errr...
16:29:56 <Pseudonym> No, other way.
16:29:59 <stepcut> true..
16:29:59 <shapr> Well, the battery is doing okay so far. I've had it for a year or two.
16:30:00 <Pseudonym> :-)
16:30:01 <Heffalump> liyang: do anything interesting?
16:30:02 <liyang> shapr: I built a charger into my Palm III cradle. :)
16:30:10 <Heffalump> the Vx is 5 years old or so
16:30:17 <shapr> liyang: smart!
16:30:18 <liyang> Heffalump: porting an H.264 decoder to it. :)
16:30:22 <liyang> Rechargeables!
16:30:28 <Heffalump> ah, assembly programming? :-)
16:30:35 <liyang> (It's a huge conspiracy, the batteries market...)
16:30:40 <Heffalump> or using the DSP?
16:30:49 <liyang> Heffalump: well, C and optimised DSP asm.
16:30:59 <Heffalump> what C compiler did you use?
16:31:16 <liyang> Um... TI's. :-/
16:31:31 <liyang> I didn't do much ARM.
16:31:43 <Heffalump> I don't know much about their compiler.
16:32:02 <liyang> I can't remember much about their compiler.
16:32:27 <liyang> :o)
16:32:59 <Heffalump> :-)
16:34:23 <samx> anyone aware of a chart drawing library for haskell?
16:35:56 <xerox> The Java thing does something like that... let me find it
16:37:02 <shapr> samx: You could export gnuplot data.
16:45:19 <Cale> uim is nice :)
16:45:55 <Cale> I can type ã²ãããª and æ¼¢å­ again :)
16:46:07 <xerox> What do they mean?
16:46:15 <Cale> hiragana, kanji
16:46:35 <xerox> How do you type that? :)
16:47:10 <Cale> (Shift-space hiragana Enter) produces ã²ãããª
16:47:32 <Cale> (Shift-space kanji Enter) produces æ¼¢å­
16:47:57 <Spark> heh cool
16:47:57 <xerox> Emacs?
16:48:05 <Cale> (at first, I had to distinguish between a few other options for "kanji")
16:48:20 <Cale> X-Chat + uim for gtk2
16:48:34 <Spark> what does uim stand for?
16:48:37 <Cale> + uim-anthy
16:48:37 <Spark> unicode input method?
16:48:48 <Cale> Probably universal input method or something
16:49:02 <Spark> music to my ears
16:52:01 <Cale> I'm changing that to ctrl-space, since whenever I type "I ...", I have the habit of holding shift a little too long.
16:52:21 <Spark> heh
16:53:14 <liyang> Snap. >.<;;
16:53:19 <Cale> I can also type in Î³ÏÎµÎµÎº, by pressing both alt keys at the same time to switch keyboard maps :)
16:56:00 <lispy`> @type (>.<)
16:56:01 <lambdabot> bzzt
16:56:13 <lispy`> hmm...that really looks like it should be a haskell operator
16:56:52 <Pseudonym> It can be.
16:56:58 <xerox> @type ((>).(<))
16:57:00 <lambdabot> forall a. (Ord (a -> Bool), Ord a) => a -> (a -> Bool) -> Bool
16:57:04 <lispy`> haha
16:57:36 <lispy`> @eval ((>).(<)) 1 (\_ -> True)
16:57:37 <lambdabot> <Plugins.Eval>:1:19:
16:57:37 <lambdabot>   No instance for (Ord (a -> Bool))
16:57:37 <lambdabot>   arising from use of `>'
16:57:54 <liyang> Cale: how do you set that up?
16:57:56 <xerox> hehe.
16:58:16 <lispy`> (Ord (a -> Bool)) ?
16:58:20 <lispy`> hmm..
16:59:46 <Cale> liyang: apt-get install uim uim-anthy uim-gtk2.0
17:00:09 <Cale> oh, and apt-get install uim-applet-gnome
17:00:15 <liyang> Cale: no no, I already have uim/anthy &c. I was wondering about the Greek thing. :)
17:00:19 <Cale> ah
17:00:29 <TheHunter> xerox, expect some delay of the post due to the gov't mule cds i just discovered.
17:00:53 <xerox> TheHunter: "gov't mule cds" ?
17:01:22 <TheHunter> i can't really concentrate while listening to them.
17:01:38 <xerox> :-)))
17:02:03 <xerox> I wrote the best code while listening to Shpongle <grin>
17:02:12 <Cale> in the gnome Keyboard Preferences dialog, under Layout, I added a "Greek Eliminate dead keys" layout below the usual "U.S. English", and then under Layout Options, "Group Shift/Lock Behaviour" tick the box that says "Both Alt keys together change group"
17:02:22 <yeti> 'gov't mule cds' sounded to me like the government found your secret collection of emule-pirated CDs ;)
17:02:45 <Cale> while you're at it, under "Miscellaneous compatibility options" there's a setting for "Caps lock is compose" which is quite nice :)
17:03:38 <lispy`> almost anything is more useful than capslock
17:04:03 <lispy`> i like having ESC where ctrl is, having ctrl where capslock is, and not having capslock at all
17:04:27 <lispy`> when you're using vi/vim having a small reach for escape is nice
17:05:10 <yeti> takes some time to get used to though, no?
17:05:22 <liyang> Cale: ah, I have right-Alt set to compose, which probably interfered with both alt => switch group... (so it wasn't working.)
17:05:23 <lispy`> indeed
17:05:35 * liyang changes Caps to switch group.
17:17:27 <shapr> TheHunter: Gov't Mule is great! Do you have the live shows from bt.etree.org?
17:25:51 <TheHunter> what i have here is "With a Little Help from my Friends".
17:26:38 <TheHunter> is this legal?
17:30:53 <xerox> Parametric types are difficult to teach to C people
17:31:46 <greenrd> How many kinds of polymorphism are there in Haskell?
17:34:09 <TheHunter> wow, apparently they allow everybody to tape their shows. This is a great source I'll have to further investigate.
17:35:18 <xerox> Like Grateful Dead!  I should try listening to them.
17:41:11 <dons> xerox, about `type` in h4sh. individual commands have types you get by the --help flag
17:42:37 <xerox> dons: oh, OK, thanks :_)
17:47:52 <SyntaxNinja> FrederikEaton: alive?
18:00:06 <Pseudonym> greenrd: THere are a few.
18:00:14 <Pseudonym> Parametric polymorphism is the most obvious.
18:00:47 <Pseudonym> But thereÅ also typeclass polymorphis, and module-based ad-hoc polymorphism.
18:01:23 <Pseudonym> Errr...
18:01:23 <xerox> module-based ad-hoc polimorphism?
18:01:28 <Pseudonym> Sure.
18:01:36 <xerox> poly, even
18:01:38 <Pseudonym> You can have two functions with the same name if you put them in different modules.
18:01:39 <xerox> What does it mean?
18:01:52 <xerox> Right, qualified imports?
18:01:55 <Pseudonym> Same name, two things == polymorphism
18:02:27 <xerox> I didn't think it would work without qualified imports
18:02:45 <TheHunter> xerox, http://www.haskell.org/pipermail/haskell-cafe/2005-August/011053.html
18:05:14 <xerox> TheHunter: thanks!
18:05:30 <xerox> Lost on Leibniz-equal
18:15:19 <TheHunter> this paper explains that kind of equality: http://www.cs.uu.nl/people/arthurb/dynamic.html
18:18:02 * xerox hopes to have the necessary background to understand it
18:18:11 <xerox> Thank you for the link TheHunter.
18:18:12 <TheHunter> chapter 3.
18:18:22 <TheHunter> it's a simple idea.
18:27:11 <SamB> hmm, I wonder if I will get a different answer if I ask this again:
18:27:16 <TheHunter> fwiw, in the days of GADTs on can also define data Equal :: * -> * -> * where E :: Equal a a
18:27:16 <SamB> what is a good parser combinator library to use with a scanner?
18:27:59 <lispy> SamB: didn't you ask that this morning too? :)
18:28:03 <xerox> TheHunter: "Note that function arrows map to implications and pairs to conjunctions."  I can't get the subjects/objects of the phrases :-)
18:28:24 <lispy> "function arrows"
18:28:27 <SamB> lispy: notice the line before?
18:28:29 <lispy> "map to"
18:28:50 <lispy> xerox: hm.m..that is hard to pares
18:28:52 <lispy> parse*
18:28:57 <SamB> and it was afternoon or early evening over here...
18:29:03 <lispy> SamB: ah
18:29:13 <TheHunter> function arrows ~> implications
18:29:19 <lispy> SamB: i was just teasing, not criticizing
18:29:20 <TheHunter> pairs ~> conjunctions
18:29:30 <SamB> even a more complete answer would be nice...
18:29:40 <xerox> TheHunter: ah.  Makes sense.
18:30:00 <SamB> lispy: oh, thats nice ;-)
18:30:00 <xerox> And it's rather cool :)
18:31:58 <xerox> newtype Equal a b = Equal (forall f. f a -> f b)  -- f is some kind of Functor/Monad/* -> * type, right?
18:32:35 <TheHunter> it's neither a Functor nor a Monad, just has kind * -> *.
18:32:44 <xerox> OK.
18:33:02 <TheHunter> |forall f. Functor f => f a -> f b| would be harmless.
18:33:29 <TheHunter> then you could have something of type Equal Int Bool without a problem.
18:33:29 <xerox> What do you mean?
18:33:36 <xerox> Ouch.
18:33:49 <TheHunter> fmap (const False) or whatever.
18:34:00 <xerox> Got it.
18:34:33 <TheHunter> the beauty is that f could be Foo as in newtype Foo r = Foo (r -> Int)
18:35:24 <TheHunter> or even Foo r = Foo (r -> (Foo r, r))
18:35:32 <xerox> Uhm.
18:35:53 <xerox> Now what if r is Bool ?
18:36:34 <TheHunter> we quantify over f.
18:36:57 <TheHunter> the only way to get an inhabitant of Equal is to take the identity function.
18:37:24 <xerox> I can't completely get why
18:38:06 <TheHunter> because f can be anything.
18:38:26 <TheHunter> try constructing a function of type |forall f. f Int -> f Bool|
18:38:46 <xerox> a and b suggested me it was possible
18:39:39 <TheHunter> it's impossible unless a and b are equal.
18:39:40 <xerox> You'd need unsafeCoerce to do it, imho
18:39:57 <TheHunter> you can always use unsafeCoerce, but that's cheating.
18:40:23 <xerox> Maybe the point is "we quantify over f" ?
18:40:47 <xerox> Oh
18:40:58 <xerox> forall, I think I understand.
18:41:11 <xerox> Cool :)
18:44:13 <xerox> TheHunter: what about _|_ ?
18:45:05 <xerox> I never really understand this "bottom" idea
18:45:39 <TheHunter> if an Equal a b is _|_, any attempt to convert an a to a b will result in a run-time-error.
18:46:06 <xerox> Gasp.
18:49:11 <xerox> @kind (->)
18:49:12 <lambdabot> ?? -> ? -> *
18:49:27 <TheHunter> an Equal a b carries the prove that a and b are equal, or undefined in which case we know nothing about a and b.
18:49:31 <TheHunter> *proof
18:49:58 <xerox> IIUC we cannot know nothing about a and b in either case
18:50:10 <xerox> Ah no!
18:50:24 <xerox> There can't be a conversion function because it wouldn't know about them
18:50:33 <xerox> because it can't know nothing about f.
18:50:53 <xerox> i.e. it couldn't know about how to unpack the a and b and such
18:51:03 <TheHunter> right.
18:51:28 <xerox> Getting things right is satisfactory.
18:53:40 <xerox>   newtype Bar = Bar Int deriving Foo
18:53:49 <xerox> This deriving what does exactly do?
18:54:32 <TheHunter> instance Foo Bar where foo = unsafeCoerce (foo :: ...)
18:54:51 <TheHunter> where ... is the type of foo in the instance declaration of Int.
18:55:28 <TheHunter> remember: the internal representations of Int and Bar are identical.
18:55:54 <TheHunter> so this can never result in a run-time error.
18:56:27 <TheHunter> *in a segfault, even.
18:56:34 * xerox mumbles
18:58:14 <xerox> Oh, right.
18:58:26 <xerox> It's just a newtype over Int.
18:58:52 <TheHunter> so we've constructed leibniz-equality of Int and Bar
18:58:59 <xerox> Yep.
19:03:31 <xerox> class Dep a b | a -> b
19:03:43 <xerox> This is a way to say?
19:04:32 <TheHunter> this is just a fundep.
19:06:13 <xerox> I did lookup the GHC docs but they aren't really explained
19:10:17 <liyang> It says b is determined by a. So supposing you had a declaration instance Foo Bar. This prohibits you from having instance Foo Bar' as then the fundep a -> b would fail to hold.
19:10:41 <TheHunter> the documentation links to this: http://www.cse.ogi.edu/~mpj/pubs/fundeps.html
19:12:14 <xerox> @wiki FunDeps
19:12:15 <lambdabot> http://www.haskell.org/hawiki/FunDeps
19:12:16 <xerox> :)
19:13:15 <xerox> It seems to be exactly what I want for Matrix.chs
19:13:43 <xerox> This way I could avoid scalarMultiply :: Int -> Matrix -> Matrix
19:14:20 <xerox> But no, because (*) isn't in a fundep-ped class
19:18:59 <xerox> OK I think I mostly understand
19:19:06 <xerox> I need some sleep (04:20 AM) :-)
19:19:10 <xerox> Thanks people, goodnight.
19:20:27 <TheHunter> good night.
19:54:21 <dons> @seen shapr
19:54:22 <lambdabot> shapr is in #haskell. Last spoke 2 hours, 36 minutes and 55 seconds
19:54:22 <lambdabot> ago.
19:54:58 <dons> shapr, your suggestion for a map in h4sh that takes shell commands as arguments is cool. maybe it should be mapM so the side effects of arbitrary shell commands are clear
19:55:18 <dons> or maybe mapS for the `shell monad'
19:56:23 <dons> i think, e.g., echo yi h4sh lambdabot | mapS 'darcs pull'  has enough side effects that just overloading map isn't so nice ;)
20:08:27 <dons> actually, h4sh-style: words yi h4sh lambdabot | mapS 'darcs pull'
20:09:24 <stefanw> so mapS is xargs?
20:11:13 <dons> roughly, I think.
20:11:59 <dons> however, xars is a little strange:
20:12:01 <dons> $ words one two three | xargs echo
20:12:01 <dons> one two three
20:12:13 <dons> $ words one two three | map id
20:12:13 <dons> one
20:12:13 <dons> two
20:12:13 <dons> three
20:12:26 <dons> $ words one two three | i
20:12:26 <dons> one
20:12:26 <dons> two
20:12:26 <dons> three
20:12:53 <stefanw> yeah, that's for efficiency I guess. xargs doesn't start a new process of every argument
20:13:34 <lispy> i could have sworn xargs starts a new process for each line
20:13:44 <lispy> but maybe not
20:13:51 <dons>  The utility is repeatedly executed until standard input is
20:13:51 <dons>      exhausted.
20:13:58 <lispy> ah
20:14:20 <lispy> wait, that doesn't really tell us when it gets executed tho
20:14:39 <lispy> which i beleive to be on each new line
20:14:47 <stefanw> I think xargs breaks the line at arbitrary points, so that the commandline of the program to be executed doesn't get too long
20:14:48 <lispy> http://www.codersbase.com/Quake3
20:14:59 * lispy shamelessly plugs his own site again
20:15:05 <dons> $ words one two threee | xargs -l1 echo
20:15:06 <dons> one
20:15:06 <dons> two
20:15:06 <dons> threee
20:16:07 <lispy> sh: line 1: words: command not found
20:16:20 <lispy> hmm...oh well, /exec never seems to work :)
20:16:20 <dons> you need to install h4sh ;)
20:16:29 <lispy> i have it, but /exec doesn't know my path
20:17:24 <Korollary> what's today's project, lispy ?
20:17:31 <lispy> Korollary: http://www.codersbase.com/Quake3
20:19:47 <Korollary> lispy: What is Foo ?
20:20:18 <lispy> Korollary: a placeholder for Haskell ;)
20:20:27 <lispy> is that sentence too confusing?
20:20:46 <Korollary> "Retarget an existing Foo compiler to support the qvm. I'm thinking of using Haskell for Foo."
20:20:54 <Korollary> this sounds like Haskell and Foo are distinct entities
20:21:32 <Korollary> as if you are going to retarget GHC to produce Foo-code or something
20:21:33 <dons> $ words one two three | ./mapS echo
20:21:33 <dons> one
20:21:33 <dons> two
20:21:33 <dons> three
20:21:55 <lispy> Korollary: i see, i better just combine the sentences and get rid of foo
20:22:33 <dons> fun: $ words *.hs | ./mapS cat
20:22:35 <lispy> alright, all better
20:22:56 <Korollary> lispy: I still don't quite get what you want to do. Are you going to write a haskell-bridge to the engine ?
20:23:44 <lispy> no, just modify a haskell compiler so that the machine code it generates runs on the qvm
20:23:55 <dons> yay, no more echo: $ show show at last
20:23:57 <dons> show at las
20:24:05 <dons> oops. mis-paste
20:24:10 <lispy> so then you could write some haskell, and it would run on the qvm, allowing you to script the qvm
20:24:19 <Korollary> ah
20:25:29 <Korollary> then you can extort money from John Carmack, heh.
20:25:45 <Korollary> "pay me, or else your engine gets it"
20:25:47 <lispy> heh
20:26:11 <lispy> i'm not sure how it will work out, the bytecode isn't allowed to use malloc/free
20:26:24 <lispy> so the haskell code would have to compile in a weird way
20:26:31 <lispy> using only static structures
20:26:57 <lispy> so....i'm wondering what would happen if you made it so that the qvm was garbage collected, and then try it....
20:27:22 <SyntaxNinja> dcoutts: alive?
20:27:23 <Korollary> I'd rather wait until someone else cleans that engine code up.
20:28:42 <lispy> Korollary: it's not messy
20:29:02 <lispy> Korollary: plus, adding a GC is as easy as dropping in boehem&weiser garbage collector
20:29:32 <lispy> but first i want to understand the ramifications of doing that
20:30:06 <lispy> another problem with the qvm is that it doesn't support the standard C library
20:30:28 <lispy> even though they provide a C -> qvm bytecode compiler
20:34:25 <Korollary> lispy: I played with the sdk a bit back in the day. I wouldn't want to go near it again unless someone cleaned it up and commented and took out the asm blocks.
20:34:54 <lispy> are you thnking of quake2?
20:35:01 <FrederikEaton> what's the overhead to putting a bunch of stuff in a package? like why shouldn't i just put all of WASH's code into one package?
20:35:07 <lispy> carmack said that the asm that is there can just be delete
20:35:11 <FrederikEaton> ghc just grabs the modules it needs, right?
20:35:18 <FrederikEaton> without looking at the others?
20:58:26 <Korollary> @index readDec
20:58:28 <lambdabot> Numeric
21:01:19 <Korollary> @pl liftM (fst . head . readDec . head) getArgs
21:01:21 <lambdabot> fmap (fst . head . readDec . head) getArgs
21:02:22 <Korollary> is there a neater looking version ?
21:08:02 <Korollary> doh
21:08:11 <Korollary> fmap (read . head) getArgs
21:09:51 <lispy> @pl \x -> fmap (read . head) x
21:09:53 <lambdabot> fmap (read . head)
21:10:01 <lispy> well, it was worth a try :)
21:55:03 <SyntaxNinja> @wiki
21:55:03 <lambdabot> http://www.haskell.org/hawiki/
21:55:29 <lispy> @syntaxnijitus
21:55:30 <lambdabot> Unknown command, try @listcommands.
21:55:34 <lispy> @syntaxnijitsu
21:55:35 <lambdabot> Unknown command, try @listcommands.
21:55:51 <lispy> SyntaxNinja: hows it going?
22:04:57 <Korollary> @index unsafeWr
22:04:59 <lambdabot> bzzt
22:05:01 <Korollary> @index unsafeWrite
22:05:03 <lambdabot> bzzt
22:05:09 <Korollary> @hoogle unsafeWr
22:27:49 <SyntaxNinja> FrederikEaton: check your msgs :)
22:37:12 <Pseudonym> Well.
22:37:16 <Pseudonym> That was bizarre.
22:37:32 <Pseudonym> Do you know how rare white gloves are?
22:48:14 <lispy> i'm not sure the email i set to ghc bugs list made it
22:48:43 <lispy> i was sent a mail saying that it was awaiting moderator approval, but i never heard after that
22:55:04 * rt twiddles his thumbs.
23:44:01 <ramkrsna> vikasg, ping!
23:45:37 <vikasg> ramkrsna, pong
