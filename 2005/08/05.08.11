00:22:18 * kehoste thinks Monad is a poor choice of name for a attempt for a Windows shell
00:22:25 <boegel> woop
00:22:26 <boegel> +s
00:24:12 <Thu3387> wtf
00:24:32 <Thu3387> how can it be...that the first time i run 'make test' i get "*** No rule to make target `/home/nlv11757/nlv11757/build/tests/ICPanal/1.test.anal" but the second time...it works
00:24:47 <boegel> because you changed something :) simple :p
00:24:51 <Thu3387> how can there suddenly be a rule the second time
00:25:40 <Heffalump> hello
00:26:52 <Thu3387> this doesnt make sense to me
00:26:53 <Thu3387> hello
00:31:53 <Thu3387> ffs
00:32:08 <boegel> hey Heffalump
00:34:29 <Thu3387> look at this....i have a rule 'test: makedirs <<somepattern>>' that one complains the first time and runs the second time.....if i change the rule to 'test:<<somepattern' and first call 'make makedirs' followed by 'make test' IT WORKS!?!?
00:37:33 <lispy> well, lesson09 is finished
00:37:47 <lispy> i should probably comment better tho
00:42:37 * Thu3387 sighs
00:45:36 <Lemmih> lispy: Did you write your own bitmap loader?
00:46:01 <lispy> Lemmih: yup
00:46:14 <lispy> Lemmih: even wrote my own endianness detector :)
00:46:41 <lispy> but actually my bitmap loader is a translation of some C code I found
00:47:03 <lispy> one of the NeHe translations gave the code, so I just translated it to C
00:47:11 <Lemmih> dblhelix: ACK?
00:47:15 <Thu3387> isnt like an endianness detector just shifting and comparing the result?
00:47:25 <dblhelix> hi Lemmih
00:47:53 <lispy> Thu3387: i used Foreign.Ptr to poke some bytes, but yes that could work as well
00:48:35 <Lemmih> dblhelix: At home?
00:48:55 <lispy> if the bytes were a list, I just poke the values [1,2,3,4] and check the value when it is cast to an Int32
00:48:58 <dblhelix> Lemmih: at work
00:49:57 <lispy> Lemmih: did you find that the code is very slow?
00:50:14 <lispy> Lemmih: I did the one with the stars that spiral, and it's very, very slow
00:50:35 <lispy> Lemmih: it's fast enough to watch it just fine, but it sputters at times
00:50:55 <lispy> and it has a sluggish feel
00:51:48 <Lemmih> I haven't encountered any speed issues.
00:52:09 <lispy> maybe i should do a comparison with the C version
00:52:58 <lispy> oh, actually compiling with -O3 made a HUGE difference compared to runghc
00:54:51 <lispy> Lemmih: do you use a lot of IORefs?
00:54:57 <lispy> Lemmih: I find that I have them all over
00:56:48 <Lemmih> lispy: A few.
00:57:16 <lispy> I don't really like having to pass so much data to functions
00:57:41 <lispy> but i expect the later tutorials will intrudce more data structures and reading scenes
00:57:59 <lispy> it's all been so very lowlevel so far
00:58:32 <Thu3387> can anyone explain what .hi files are and why they are used...because im getting the feeling those files are causing weird linking errors that SOMETIMES occur
00:59:33 <Lemmih> Thu3387: They are interface files containing information about a compiled Haskell file.
01:01:05 <Thu3387> could using -hidir in combination with --make and -main-is cause linking errors because it doesnt update hi files correctly when doing changes because of the -hidir flag
01:05:24 <Lemmih> I doubt it.
01:06:55 <Lemmih> Cabal uses -hidir and --make, and it works just fine.
01:07:19 <Lemmih> Thu3387: What kind of linker errors are you encountering?
01:12:06 <Thu3387> i think its this
01:13:32 <Thu3387> i have an app Compare....another app ICP uses the Main.hs from Compare....to disambiguate which the main function is i give the flag -main-is ICP.Main.main.....After ICP is built....i built the app Compare...but *then* saying -main-is Compare.Main.main
01:14:12 <Thu3387> i think the first time the Compare.o and Compare.hi were generated (when the flag was -main-is ICP.Main.main) it changed something with the main function in Compare.o (renamed it or so)
01:14:38 <Thu3387> so the second time when i really want to built Compare...it doesnt recompile the .o but this time it *does* have to use the Compare.Main.main as a main function
01:15:08 <Lemmih> Is it reproducible?
01:15:26 <Thu3387> ill make a small example that reproduces it
01:15:31 <Thu3387> give me a minute
01:18:03 <Thu3387> yep i reproduced it
01:18:07 <Thu3387> is it actually a bug?
01:18:35 <Thu3387> or just bad use on my part?
01:27:11 <Itkovian> meuning
01:27:16 <Itkovian> gawd bloody java
01:50:28 <dons> @yow
01:50:29 <lambdabot> I'm having an EMOTIONAL OUTBURST!!  But, uh, WHY is there a WAFFLE
01:50:29 <lambdabot> in
01:50:29 <lambdabot> my PAJAMA POCKET??
01:56:29 <dons> @code
01:56:30 <lambdabot> ForeignPtr.hs: newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
01:57:00 * dons hacks yi during class
02:03:27 <Thu3387> shame on you
02:08:03 * Itkovian hacks AWT crap
02:08:43 <dons> hehehe
02:09:23 <paolo> Psedunym did build up that machine?
02:09:29 <paolo> (morning :-)
02:14:41 <Thu3387> Itkovian, why would you bother with AWT?
02:15:27 <Itkovian> well, because other people require me to.
02:15:52 <Thu3387> jeeeej, I caused a priority 3 bug to be submitted
02:15:54 <Itkovian> we need a GUI on a J2ME enabled device and I'm told swing is out of the question.
02:15:54 * Thu3387 cheers
02:16:00 <Itkovian> congrats
02:16:04 <boegel> AWT isn't that bad
02:16:15 <Thu3387> i'd rather use SWING anytime
02:16:24 <Itkovian> ah well, maybe not, but I'm very inexperienced in it, to say the least
02:16:24 <tuomov> I'd rather not touch any widget set...
02:16:35 <Thu3387> hehe console IS the way to go :P
02:17:03 <tuomov> not necessarily, but I want to work at a much more abstract level then, not with stupid wimp controls
02:17:57 <Thu3387> true
02:21:52 <Thu3387> not very stimulating work
02:23:38 <wilx> Does anybody use/have working haskell-font-lock-symbols in (X)Emacs?
02:24:02 <Lemmih> What's haskell-font-lock-symbols?
02:24:34 <wilx> It should change the \ in \ x -> foo x into lambda character.
02:24:41 <wilx> And some other changes.
02:25:11 <wilx> haskell-font-lock-symbols is customization variable.
02:32:04 <musasabi> Lemmih: how is the 64-bit ops thing for GHC going?
02:33:19 <Lemmih> Badly. My assembly-fu on sparc and powerpc is weak (:
02:34:48 <Lemmih> An assembly guru could probably finish the patch in an hour.
02:40:04 <autrijus> new $work project starting... using WASH for this time.
02:40:40 <autrijus> type-directed scaffolding via "class WebEditable" really feels like cheating.
02:57:28 <musasabi> Lemmih: I can take a look at it - although it is some years since I have done such stuff.
02:59:06 <mflux> wilx, did you get it working? it sounds cool ;)
02:59:14 <boegel> @seen shapr
02:59:14 <lambdabot> I saw shapr leaving #haskell 8 hours, 37 minutes and 33 seconds ago.
02:59:27 <mflux> hmm, haskell-mode for texmacs..
02:59:45 <Lemmih> musasabi: I just need the ability to jump to a label.
03:01:33 <Lemmih> Hm. Am I being stupid here?
03:02:01 <Lemmih> It be done with a NEWBLOCK and a jump table, perhaps...
03:03:10 <wilx> mflux, I didn't. That is why I am asking.
03:05:13 <mflux> wilx, yeah, but it's been a while
03:05:18 <mflux> 30 minutes!
03:06:08 <pejo> Lemmih, what level are you trying ot perform the jump on?
03:06:48 <musasabi> Lemmih: jump to a label like "b label" ? (on ppc)
03:07:25 * Lemmih knows almost nothing about assembly.
03:07:52 <musasabi> i386 "jmp foo" -> ppc "b foo"
03:08:54 <musasabi> i386 jump indirect with eax "jmp %eax" -> ppc jump with link register (lr) "blr"
03:11:21 <takuan_> huh?
03:11:29 <takuan_> asm in #haskell?
03:11:30 <takuan_> ;)
03:14:22 <paolo> It's becoming #lisp!
03:14:24 * paolo hides
03:26:25 <shapr> peti: y0! ltns!
03:26:39 <shapr> @quote tromp
03:26:40 <lambdabot>  the number of 13x13 go positions is 372497923076863964422949047670245
03:26:40 <lambdabot> 17674249157948208717533254799550970595875237705
03:26:45 <shapr> @quote tromp
03:26:46 <lambdabot>  the number of 14x14 Go positions is 212667732900366224249789357650440
03:26:46 <lambdabot> 598098805861083269127196623872213228196352455447575029701325
03:26:52 <shapr> mmmm, big numbers!
03:27:21 <Lemmih> Hey shapr.
03:28:16 <tromp> hi shapr& Lemmih:)
03:28:27 <tromp> and paolo
03:28:46 <paolo> Hi!  Did you buy the RAM? :-)
03:29:06 <tromp> nope:(
03:29:47 <tromp> 15x15 will be done either with files, or distributed
03:30:15 <tromp> the first being very slow, and the second hard to program
03:30:20 <paolo> I would take part for the latter hypothesis
03:30:54 * paolo sees Erlang in the distance, through the fog
03:34:41 <Lemmih> dons: ACK?
03:36:33 <peti> shapr: Yo shapr! It's nice to see you're around. I thought the channel was just dead. ;-)
03:39:20 <peti> shapr: You know a thing about Wikis or two, right? Is there any light-weight solution that I can use to give readers of my web page the chance to edit the contents (and to have these changes e-mailed to me)? Preferably something written in Haskell? I've looked at MoinMoin, but the thing is way too big for what I need. Any ideas?
03:39:48 <tuomov> emailed? darcs?-)
03:41:28 <peti> tuomov: I wouldn't mind, but the designated target group is computer illiterate, I'm afraid. Anything that's more complicated than pressing a button in the web browser is too complicated already.
03:51:44 <shapr> peti: There's a wiki written in Haskell, called Flippi.
03:51:51 * Itkovian is back
03:52:01 <shapr> hoi Itkovian
03:52:05 <shapr> hiya Lemmih
03:53:35 <shapr> peti: Hey, you want to write a TMR article about Fast IO or something?
03:54:57 <Itkovian> hi shapr
03:55:24 <kzm> shapr, peti: fast IO would be great.  I could follow the list discussion a while ago, but I think the topic does deserve a nice, comprehensive document that details the hows and whys a bit more.
03:56:50 <Itkovian> A TMR article about HSP?
04:08:39 <shapr> Itkovian: Sounds good, want to write it?
04:09:05 <Itkovian> haha, no thx. I merely suggest subjects ;-)
04:09:38 <Itkovian> my knowledge about webpages is rather limited to the PHP stuff I did, and HTML really isn't my thing
04:10:38 * Beelsebob yawns
04:11:06 * boegel returns too
04:11:13 <Itkovian> Hmm, how long should a TMR article be, in pages that is
04:11:15 <peti> shapr: That's one amazing idea, actually. ;-) What can I say? I have a neat implementation, I just don't get my act together to document it properly.
04:11:49 * peti just found the Flippi web page.
04:12:07 <peti> Does anyone have first-hand experience with that software?
04:12:22 * boegel is happy to see shapr hunting for articles again
04:13:21 <peti> Why is it that _everything_ I look for is hosted at scannedinavian.org?
04:13:42 * peti believes shapr is secretly trying to build a monopoly on Haskell software. 
04:16:41 <Beelsebob> shapr: what does a TMR article have to be on?
04:16:49 <Beelsebob> anything Haskell related?
04:20:02 <Philippa> heh
04:20:28 <Philippa> it's only the running version of Flippi that's on scannedinavian, and that because I don't fancy all the messing around with my hosting provider right now
04:20:39 <boegel> peti: that's nice, isn't it ? it's better than C/Java stuff that's spread all around, try looking for something :s
04:20:47 <boegel> Beelsebob, yeah sure
04:20:59 <Philippa> incidentally, the darcs version does have code to store a version history (unlike the running one), though you'd need to add a means of viewing it and reverting where need be
04:21:12 <Beelsebob> when's the next TMR appearing?
04:21:19 <Philippa> "when it's done"
04:21:22 <Beelsebob> cool
04:21:32 <Philippa> I should think about which of my potential articles to actually write
04:21:35 <boegel> 1st of September
04:21:45 <Beelsebob> right... well if it's not done when I get back from holiday, I'll do you one about Hat
04:21:50 <Philippa> was going to run with the idea that Haskell as a language has few moving parts and that this is a good thing
04:21:52 <Beelsebob> and it doesn't sound like it will be
04:21:55 <boegel> shapr envisiones one issue at the start of the month
04:21:59 <boegel> so far, he succeeded
04:22:08 <Beelsebob> k
04:22:16 <Philippa> IssueTwo was a month late IIRC?
04:22:18 <Beelsebob> it might end up in the October issue, but hey
04:22:18 <boegel> but it's not easy, not a lot of people have time to write an article
04:22:22 <boegel> Philippa, no way
04:22:28 <boegel> IssueFour is out already
04:22:32 <peti> Philippa: Version control of the contents would be very nice in my case. Just wondering: How is the software hooked into the web server? Through CGI?
04:22:40 <Philippa> yeah, it's a plain CGI at the moment
04:23:01 <Philippa> shouldn't be too hard to change that, though there're a few bits that would need abstracting out
04:25:13 <peti> Philippa: I think CGI is a pretty good choice, actually. Let's the software work independently from the HTTP server software. I believe in keeping things separated if possible.
04:25:24 <Philippa> yeah, FastCGI also works though
04:25:47 <peti> Philippa: Very nice. Now all we need is a web server that can speak FastCGI. ;-)
04:26:23 <Itkovian> well issueFour certainly isn't on the main wiki page
04:26:37 <Itkovian> should I update the page? or isn't issuefour ready for the public yet?
04:26:41 <Philippa> it's been out a while
04:26:44 <Itkovian> peti: apache?
04:27:00 <Itkovian> peti: I installed mod_fastcgi yesterday
04:27:19 <Itkovian> Philippa: yes, but on the main wiki page it says three is the lastest issue
04:27:22 <peti> Itkovian: I don't know about the 2.x version, but FastCGI mod_fastcgi is pretty poor, unfortunately.
04:27:27 <Itkovian> hmm
04:27:35 <Itkovian> but it should work, right?
04:27:50 <peti> Itkovian: It doesn't do keep-alive and request multiplexing, for example. At least it didn't back when I looked at it.
04:28:01 <Itkovian> hmm, shit
04:28:22 <peti> Itkovian: It does work though, yes, and it's still better than ordinary CGI, of course. As I said, I haven't looked at it in a while. Maybe the new version has been improved a lot?
04:28:31 <boegel> it's in the topic, so I'm guessing it's ready
04:28:40 <Philippa> Itkovian: update the page
04:28:56 <Itkovian> doing right now
04:28:56 <boegel> shapr forgot apparently
04:29:04 <boegel> strange nobody noticed before :)
04:29:14 <boegel> did he post it on the Haskell lists ?
04:29:41 <Itkovian> http://www.haskell.org/hawiki/TheMonadReader?action=show
04:29:45 <Itkovian> it's been updated
04:29:56 <Itkovian> I feel like having made a positive contribution today :-)
04:31:23 * peti thinks shapr is dead on about the need for a standard parser library. 
04:32:15 <Beelsebob> philippa... is the choice of letters in "or "wmmf mmf bmf?" as the case may be" deliberate?
04:32:23 <peti> What is the state of Hackage? I reckon having that repository online might go a long road towards reusing each other's code more easily.
04:33:02 <peti> Hmm. The link at <http://www.haskell.org/cabal/hackage/> doesn't work anymore.
04:35:49 <peti> Lemmih: Has there been any progress on Hackage recently? I notice the URL doesn't even seem to work anymore.
04:35:57 <peti> Lemmih: Oh, hi, by the way. ;-)
04:36:04 <Lemmih> Hi peti (:
04:36:18 <Lemmih> There will be very Soon(TM).
04:36:29 <peti> Lemmih: I see. ;-)
04:36:41 <Lemmih> I'm about to install a usable version on haskell.galois.com.
04:37:23 * Lemmih should stop playing with HSP.
04:37:25 <peti> What about this entire encryption/signature/key management issue? Has that been resolved already?
04:37:35 <Lemmih> Yep.
04:37:55 <peti> Is there a document about that topic available somewhere?
04:38:08 <peti> Or is it all documented in the code? ;-)
04:38:38 <Lemmih> I've documented cabal-get a bit.
04:39:04 <peti> Lemmih: You mean the page on the Wiki?
04:39:32 <Lemmih> Yeah. Granted, it's more of a users guide /-:
04:40:58 <peti> Does some form of API to GPG exist already? I know darcs has some code for that, but it's a bit ad-hoc'ish.
04:41:58 <Lemmih> I've made a library which is almost as hackish as the Darcs code.
04:42:31 <Lemmih> Also write a binding to libgpgme but that didn't work out.
04:42:37 <peti> I'll find that in the cabal-get Darcs repository?
04:43:20 <Lemmih> peti: No, it's separate from cabal-get since it's also used by HackageDB and cabal-put.
04:44:01 <peti> Lemmih: libgpgme is a mess, IMHO. I have no idea what the guys who designed that API thought, but I have trouble following their thoughts. I saw that one guy actually started re-implementing OpenPGP in Haskell, but the project seems to have hit a wall a while ago. It's a shame.
04:44:21 <Lemmih> dons: Is it possible to create a timeout in a single process?
04:44:44 <peti> Lemmih: Can I find that library somewhere? I'd like to have encryption and signature support in one of my programs; it would be nice if I wouldn't have to start from the scratch with that.
04:45:33 <shapr> peti: Dominic Steinitz' cryptolib has PKCS#11 support.
04:47:09 <Lemmih> peti: http://scannedinavian.org/~lemmih/gpg
04:47:11 <boegel> shapr: forgot to update the main TMR page ?
04:47:17 <Lemmih> peti: It's pretty hardcoded, though.
04:47:35 <shapr> boegel: Actually, I refuse to release a TMR with less than five articles, and then I got distracted by life issues.
04:47:42 <Lemmih> peti: Feel free to change/extend it.
04:47:52 <peti> Lemmih: Got it, thanks.
04:48:07 * Lemmih stops playing with HSP and starts installing HackageDB.
04:48:12 <boegel> shapr: oh, we changed the main page... actually, Itkovian did :p
04:48:18 <shapr> cool :-)
04:48:42 <peti> Lemmih: Your source code is indented the same way I do it. So it must be good. ;-)
04:48:55 <shapr> I'd like to get one or more TMR staff members to help out.
04:48:55 <Lemmih> heh (:
04:49:00 <paolo> I was thinking of applying ECC effectively -in an OpenPGP way- using Haskell.
04:49:48 <paolo> No time to do it, but it would be nice, I think.
04:50:17 * peti thinks that the problem with cryptography in Haskell is the lack of performance. 
04:51:12 <peti> It doesn't matter much when you test the programs, but in production it makes one hell of a difference whether the software handles a datastream of 10kb/s or 50kb/s.
04:51:37 <peti> In the end, binding to OpenSSL for the low-level crypto routines might be the best course of action. That wins you support for various crypto hardware too.
04:54:26 <shapr> I think the greatest benefit of Haskell is the ability to adapt the code, so I'd like to have more pure implementations of whatever.
04:56:28 <shapr> For example, maybe dcoutts_ partial eval code greatly increases the speed of pure Haskell, or someone finds a cool memoization trick, or Oleg comes up with some amazing type trix... Haskell source can be quickly hacked to use the new ideas, but wrappers are slow to change.
04:58:50 <shapr> peti: What do you think? Where's the current sweet spot in the tradeoff?
05:01:48 * Lemmih wonders if there'll be a EuroHaskell this year.
05:02:24 * shapr doesn't know
05:06:21 <boegel> shapr: if you're not there, it's not Haskell-worthy
05:06:30 <shapr> :-P
05:06:45 * shapr /= Haskell
05:06:55 <Beelsebob> reduces to False
05:07:04 * shapr throws monads at Beelsebob 
05:07:07 <Beelsebob> :P
05:07:10 * Beelsebob wonders if he should take his unicycle on holiday
05:07:19 <peti> shapr: I think the power of Haskell comes from the extremely short and concise notation, mostly. It's just fun to write the code, because I can do in 3 lines what takes 30 lines in C++. In the end, however, you can do anything you can do in Haskell in C++ (or C) too, so I figure that the best way to do it is to write a prototype of the software entirely in Haskell, and then you can port the important functions to a more low-lev
05:07:19 <peti> el language.
05:08:19 <Beelsebob> peti: I tend to write the prototype in Haskell, discover that it's way easier than C and write the final version in Haskell
05:08:22 <metaperl> does anyone know how to change the tempo of example2 given here: http://www.haskell.org/tmrwiki/Haskore
05:09:09 <shapr> In my experience, change of abstraction is the best way to optimize a program. In Haskell I can change my optmizations quickly.
05:09:46 <peti> Beelsebob: Same here. ;-) Haskell is just a beautiful language. Given how _easy_ it is to mix C and Haskell though, I don't see any harm in using C functions whenever performance really matters.
05:09:56 <shapr> Beelsebob: Where are you going for holiday?
05:10:20 <Beelsebob> shapr: here... http://www.users.zetnet.co.uk/gshaw/torridon_over_beinn_liath_mor.jpg
05:10:36 <shapr> Wow, ultimate Muni!
05:10:37 <Beelsebob> certainly a challenge... *g*
05:10:41 <Lemmih> Happy doesn't compile with GHC 6.4?
05:11:37 <Beelsebob> hopefully not here... http://www.craggy.org.uk/torridon_27-3-04/Torridon-March-2004-023.jpg ... because that one's just silly
05:11:59 * peti is off to work. 
05:12:03 <peti> See ya around!
05:12:04 <shapr> Would be excellent terrain for the Large Marge / Endomorph combo.
05:12:06 <shapr> peti: cya!
05:12:09 <Lemmih> Bye perspectival .
05:12:14 <Lemmih> Tsk.
05:13:35 <sylvan> [x1,x2] in ML is x1++x2 in Haskell right?
05:14:12 <Igloo> I doubt it
05:14:25 <Igloo> I'd have thought it was [x1,x2] in Haskell
05:14:41 <sylvan> hmm...
05:14:46 <CosmicRay> yeah, I'm with Igloo.
05:14:51 <sylvan> ah yeah that's probably right
05:15:02 <CosmicRay> sylvan: do you come from ocaml or sml?
05:15:05 <mauke> unless it's OCaml
05:15:20 <CosmicRay> mauke: why does that make a difference?
05:15:38 <kosmikus> [x1;x2] in OCaml, isn't it?
05:15:39 <mauke> # [1,2];;
05:15:40 <mauke> - : (int * int) list = [(1, 2)]
05:15:42 <Lor> In ocaml [1,2] is short for [(1,2)]
05:15:52 <CosmicRay> kosmikus: oh right.
05:15:56 <Lor> Since the list element delimiter in ocaml is ;
05:16:07 * CosmicRay forgot about that
05:16:15 <Lor> Ocaml syntax is pretty awful.
05:16:16 <shapr> CosmicRay: You're losing fluency!
05:16:21 <CosmicRay> heh
05:16:37 <Lor> I should finish my haskell syntax preprocessor for ocaml.
05:16:38 <CosmicRay> shapr: In my defense,  only used ocaml for a couple of months before I discovered Haskell
05:16:49 <CosmicRay> Lor: yes, indeed it is.
05:17:10 <CosmicRay> Lor: I think I once made a remark somewhere along the lines that OCaml feels like a mix of Fortran, Lisp, and Python
05:20:47 <CosmicRay> sylvan: I might add that if you are coming from OCaml, an OCaml Stream is the most direct equivolent of a Haskell list
05:21:24 <shapr> hoi goron
05:25:29 <Lemmih> Greetings JaffaCake.
05:25:44 <JaffaCake> afternoon :)
05:26:27 <Igloo> Yo JaffaCake
05:26:36 <Igloo> What's the status of the 6.4.1 release?
05:27:00 <JaffaCake> need to do one last sweep through the outstanding bug reports, then I think we're about ready
05:27:08 <Igloo> Cool
05:27:17 <JaffaCake> I'm just looking at that Yi bug report
05:27:17 <paolo> Great.  Ubuntu guys will include it and darcs will finally build.
05:27:41 <Lunar^> JaffaCake: good news! :)
05:28:15 <JaffaCake> I'm pleased with 6.4.1, we've caught some good bugs, and made some nice improvements
05:28:16 <Beelsebob> mornin Jaffa
05:28:37 <JaffaCake> in other news, I nearly have shared libs on amd64 working
05:29:45 <shapr> yay!
05:30:27 <Lunar^> CosmicRay: HWN is really cool
05:30:52 <Lunar^> CosmicRay: finally, I'm able to mark 500 Haskell ML messages read without feeling guilty
05:30:57 <CosmicRay> thanks Lunar
05:30:59 <CosmicRay> <grin>
05:31:23 <Lunar^> Is there any curves of the mailling-lists traffic?
05:31:28 <shapr> Is -fmax-simplifier-iterations used like -fmax-simplifier-iterations30 ?
05:31:36 <CosmicRay> Lunar^: but all those PhD positions you're missing out on!  And all those conferences on using lisp to do something nobody cares about that you'll never hear about!
05:31:40 <Lunar^> I feel that it has increased a lot for the past 6 months
05:31:48 <CosmicRay> hmm, I wonder if gmane might have that
05:32:06 <Lunar^> CosmicRay: I will care about PhD position next year :)
05:32:11 <JaffaCake> shapr: yes
05:32:15 <shapr> JaffaCake: thanks
05:32:15 <CosmicRay> ahh, gmane does indeed have a graph
05:32:19 <CosmicRay> http://dir.gmane.org/gmane.comp.lang.haskell.general
05:32:20 <JaffaCake> or with an = before the 30
05:32:24 <Lunar^> CosmicRay: thx
05:32:36 <CosmicRay> bug spike in about february 2003 for some reason
05:32:44 <shapr> JaffaCake: Doesn't work for me that way with ghc-6.4.1.20050801
05:33:19 <JaffaCake> which way?
05:33:24 <shapr> JaffaCake: -fmax-simplifier-iterations30 works, -fmax-simplifier-iterations=30 fails with unrecognised flag
05:33:38 <shapr> specifically "ghc-6.4.1.20050801: unrecognised flags: -fmax-simplifier-iterations=30"
05:34:10 <CosmicRay> Lunar^: I think we ought to start jobs-and-irrelevant-conferences@haskell.org ;-)
05:34:48 <JaffaCake> hmm, looks like I broke that
05:34:55 <Igloo> CosmicRay: Is that graph of the list or a newsgroup to which the list is gated?
05:35:09 <CosmicRay> Igloo: both
05:35:17 <CosmicRay> Igloo: they are one and the same
05:35:47 <Igloo> Not if you can have posts to the newsgroup which don't reappear on the list
05:35:49 <CosmicRay> It looks like the February spike was an anomoly though, possibly caused by renumbering
05:35:53 <CosmicRay> Igloo: you can't
05:36:03 <CosmicRay> Igloo: posts only appear in gmane if they come in from the list
05:36:03 <shapr> JaffaCake: w00! I found a bug! Before a release for once...
05:36:17 <CosmicRay> Igloo: to a nntp reader, all gmane groups look moderated
05:36:32 <shapr> I like the spam marking feature of gmane.
05:36:49 <CosmicRay> Igloo: when someone posts to a gmane group, it first sends them a cookie (as a spam-prevention measure), and then sends the post on to the mailing list submission address
05:36:59 <CosmicRay> nothing further happens on the gmane side unless the message makes it onto the mailing list
05:37:01 <Igloo> It doesn't look like it agrees with haskell.org archives, anyway
05:37:02 <shapr> I like the haskell-cafe growth - http://dir.gmane.org/gmane.comp.lang.haskell.cafe
05:37:30 <CosmicRay> Igloo: specifically in 02/2003 or in general?
05:37:45 <Igloo> Specifically
05:38:02 <CosmicRay> Igloo: yes, I agree...  I looked at the raw data and said it looks like they had a renumbering
05:38:07 <boegel> heh, the spam statistics are cool too :)
05:38:14 <CosmicRay> <CosmicRay> It looks like the February spike was an anomoly though, possibly caused by renumbering
05:38:36 <metaperl> defCon may be the worst abbreviation I have ever seen for something else (defaultContext)...
05:38:51 <metaperl> a parameter to perform() in Haskore
05:38:51 <CosmicRay> haha
05:39:26 <CosmicRay> that makes me want to run a port scanner on my machine
05:39:57 <JaffaCake> any Yi experts around?
05:40:11 * shapr points to dons 
05:40:20 <shapr> What's your Yi question?
05:40:53 <JaffaCake> hmm, it's ok - I'm just following up a bug report when building Yi and I couldn't repro it, but I think I've spotted what I'm doing wrong now
05:41:52 <JaffaCake> I take it back, I still can't repro it
05:43:03 <shapr> Is the bug in the sf.net tracker?
05:43:22 <JaffaCake> yup
05:43:32 <JaffaCake> https://sourceforge.net/tracker/index.php?func=detail&aid=1251699&group_id=8032&atid=108032
05:44:55 * boegel swears on his non-working sound in FC4
05:46:13 <metaperl> heheh - fedora is nothing to mess with. M-x all-hail-debian
05:48:53 <boegel> I've always had this problem in linux, multiple sound sources = misery
05:49:17 <Lunar^> JaffaCake: btw, Wolfgang did not pick my bug report about a strange Linux PPC bug related to Yi and riot
05:49:22 <tuomov> hmm... dmix or whatever its current names is in also works just fine back home
05:49:29 <tuomov> s/also/alsa/
05:49:44 <tuomov> mplayer needs some sync tuning, though
05:49:53 <JaffaCake> Lunar^: I don't remember that - you have a URL?
05:50:16 <Lunar^> JaffaCake: let me find it back
05:50:22 <shapr> Ok, it's time to write a Cabalink tool that can build all the deps in order from a given list of directories of cabal packages.
05:51:48 <Lunar^> JaffaCake: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg07478.html
05:52:57 <Lunar^> JaffaCake: I did not have the time to test it on the last STABLE branch
05:54:50 <JaffaCake> ok, wolfgang is away on vacation, I'm not sure we'll be able to look into that
05:55:36 <Beelsebob> Wolfgang maintains HOC doesn't he?
05:56:13 <JaffaCake> hoc?
05:56:24 <Beelsebob> Haskell Objective-C bridge
05:56:31 <Beelsebob> hoc.sourceforge.net
05:56:51 <Beelsebob> ah... I just answered my own question
05:56:57 <Beelsebob> The authors of HOC are Wolfgang Thaller and André Pang.
05:57:38 * Beelsebob hopes that a tiger compatible release appears some time
05:57:50 <Beelsebob> ... because XHoogle written in that would be shiny
06:02:31 <Lunar^> JaffaCake: anyway, the -fvia-C is fixed in GHC 6.4.1 IIRC, so that's not a big problem anymore
06:02:54 <sylvan> quickcheck rocks, that is all
06:02:56 <JaffaCake> pl
06:03:16 * JaffaCake hates the sf.net bug tracker
06:03:24 <Beelsebob> sylvan: hehe, it'll rock more once I'm finished with it
06:03:32 <Igloo> Me too
06:03:50 <Lunar^> JaffaCake: I thought it was the GHC team wish to keep it
06:04:00 * Igloo has half a Haskell bug tracker, but I need to find time to write the e-mail half
06:04:01 <JaffaCake> whatever gave you that idea?
06:04:45 <JaffaCake> Igloo: I'll buy you a few beers if you finish it ;)
06:04:58 <Igloo> :-)
06:05:45 <JaffaCake> Igloo: any comments on the latest revision of the Cabal dependency proposal?
06:05:56 <shapr> Igloo: Is your half a tracker online?
06:06:15 * shapr also dislikes the sf.net bug tracker.
06:06:28 <CosmicRay> shapr: yes.  HATE HATE HATE the sf.net tracker.
06:06:31 <shapr> The worst problem for me is that replies don't show up in order.
06:06:47 <shapr> As every Haskeller knows, order is occasionally very important.
06:07:03 <CosmicRay> shapr: what ticks me off is that there is no e-mail interface
06:07:10 <Igloo> http://urchin.earth.li/cgi-bin/ian/Index or darcs get http://urchin.earth.li/darcs/ian/bts depending on what you mean
06:07:24 <JaffaCake> shapr: I'd say the slowness is issue #1 for me, followed by the ugliness
06:07:25 <musasabi> Are the -xc related crashes fixed ?
06:07:26 <shapr> cute name!
06:08:01 <shapr> Igloo: Wow, spiffy!
06:08:31 <Igloo> JaffaCake: It feels like the wrong answer to me, but I don't really object to it. Especially as I've realised it needs to be left-biased anyway so we can make Debian dependencies correctly
06:08:33 <shapr> Igloo: It's fast too
06:08:54 <paolo> wow! it needs CSS hackery ;)
06:08:57 <Heffalump> igloo: remember what I told you about those cgi-bin URLs not being very long-lasting (though we can probably do some redirecting)
06:09:30 <Igloo> Heffalump: I won't shed a tear if that URL breaks at some point in the future. It'll randomly break when I start working on it again anyway  :-)
06:09:38 <Heffalump> ok :-)
06:09:57 <Igloo> If I want to put a real BTS somewhere at some point I'll find a permanent URL one way or another
06:10:30 <JaffaCake> Igloo: (re dependencies) thanks... any idea what you'd change?
06:11:05 <JaffaCake> is it going to be a pain to connect this up to Debian?
06:11:22 <Igloo> shapr: It's not really fast. It could really do with an SQL backend, so queries and updates are efficient
06:11:55 * Beelsebob prods chris in the ribs with a sharp stick
06:12:03 <shapr> hiya Lucinda, learning Haskell?
06:12:04 <Igloo> JaffaCake: What you said about not going for the lowest common denominator, I'm not sure that's the best idea
06:12:13 <Igloo> Do we actually have cases where we need something more complex?
06:12:26 <Beelsebob> shapr: chris is at least a blue belt
06:12:28 <Lucinda> Beelsebob: Hi
06:12:34 <shapr> Beelsebob: excellent
06:12:53 <Lucinda> Beelsebob: what are these belt thingies again?
06:12:57 <Igloo> If not then I don't see what we gain by making it more complex
06:13:12 <kosmikus> JaffaCake: re my -odir mail from a few days ago: seems to me like the latest Cabal still gets it wrong
06:13:35 <JaffaCake> Igloo: well, I was trying to combine it with the idea of configurations - like having HUnit as a dependency in debug mode
06:13:38 <Beelsebob> http://www.haskell.org/hawiki/HaskellIrcChannel
06:13:44 <Igloo> JaffaCake: Is   hunit1 | hunit2   the same as hunit with your switch semantics?
06:13:45 <shapr> Lucinda: greetz, how's code?
06:14:00 <Igloo> the same as hunit1, I mean
06:14:02 <Lucinda> hiya shapr. Yeah I'm always learning Haskell! I work in the same office as Beelsebob but I work on a different project
06:14:34 <JaffaCake> Igloo: you can't write that - it has to be   a?b | c?d
06:14:49 <shapr> Lucinda: Cool, what sort of project?
06:14:58 <Lucinda> HaRe? the Haskell Refactorer
06:15:06 <Igloo> JaffaCake: Sorry, what I mean is it would be nice if I could use Distribution.* to read the deps, tell it what options I've chosen and get back something representable in my distro's dependencies
06:15:07 <shapr> Lucinda: Whoa cool! Do you work for Claus?
06:15:13 <Lucinda> lol yep!
06:15:14 <Beelsebob> hahahahahahahahahahaa
06:15:18 <Beelsebob> ROFL
06:15:24 <Lucinda> and Huiqing Li and Simon Thompson
06:15:33 <shapr> I haven't kept up with HaRe lately, is it really usable?
06:15:34 <Igloo> JaffaCake: OK, so there is no actual choice at all?
06:15:45 <Lucinda> I work WITH Claus I dont work FOR him
06:15:55 <shapr> The original refactoring browser required unit tests for proof of correctness, does HaRe support that too?
06:16:04 <JaffaCake> Igloo: sure there is - I changed to be (more or less) what you were asking for the other day
06:16:17 <Igloo> If I have a cabal package and {debug, ghc} are set then I can get a list of deps that must all be satisfied (well, I will be able t choose the version number within some constraints)?
06:16:32 * Igloo is confused
06:16:35 <Beelsebob> shapr: did you just use proof and test in the same sentence?
06:16:41 <boegel> Oejet = female ?
06:16:44 <Lucinda> not really, it does support some limited correctness checking, but that may be something I intend to work on
06:16:48 <shapr> Does HaRe do regex-style matching on the abstract syntax tree like the original refactoring browser?
06:16:51 <Igloo> What list was this discussion on again?
06:16:58 <JaffaCake> libraries
06:17:07 <Lucinda> Im not sure what you mean?
06:17:38 <Lucinda> which original refactoring browser are you talking about?
06:17:43 <shapr> The first refactoring browser extended the built-in Smalltalk parser to allow 'regex-style matching' sort of.
06:17:45 <Lucinda> the small talk one?
06:17:48 <Lucinda> ah
06:17:49 <JaffaCake> Igloo: yes, we should have a library API to convert build-depends into OS-package  dependencies
06:17:54 <shapr> Yeah, there's only one original refactoring browser.
06:18:06 <boegel> what kind of systems do you guys use to maintain your paper collection ? any apps for that ?
06:18:07 <shapr> More like regex-style match and replace though.
06:18:11 <shapr> boegel: FLM!
06:18:20 <boegel> shapr: online yet ?
06:18:22 <tuomov> mkdir, cp
06:18:28 <boegel> tuomov :)
06:18:30 <JaffaCake> Igloo: but it will probably need more info than just Cabal's build-depends
06:18:33 <tuomov> and naming things by their title
06:18:37 <Igloo> "we take the leftmost branch for which x is true.  It's a case statement." - how does that permit choice?
06:18:39 <shapr> boegel: No, but I made a bunch of progress yesterday.
06:18:42 <tuomov> I'd like something better semi-integrated with riot
06:18:47 <Lucinda> well we use Strafunski to traverse the trees, and we just use Haskell to check for matches and do replacing
06:18:54 <tuomov> but I'll start thinking of such a system more only after I've finished ion3
06:19:23 <boegel> shapr: great ! can't wait
06:19:25 <JaffaCake> a case is a choice, is it not?
06:19:42 <tuomov> of course, the FLM functionality would be cool to have in that too
06:19:44 <JaffaCake> you'd like it to be a disjoint choice, maybe?
06:19:44 <shapr> Lucinda: do you plan on adding ATerm export/support?
06:19:55 <Beelsebob> hmm, time to find my washing
06:20:10 <Igloo> debug?(foo) | debug?(bar) == foo if debug is set, not foo | bar, right?
06:20:21 <JaffaCake> right
06:20:22 <Lucinda> whats an ATerm?
06:20:23 <Igloo> So given we know what flags are set there is no choice
06:20:40 <shapr> boegel: I got most of the ReadMacro hack finished, after that only darcs integration is left.
06:20:41 <JaffaCake> ah I see what you mean
06:20:54 <boegel> shapr: cool !
06:21:01 <shapr> Lucinda: ATerm is what the MetaEnvironment uses.
06:21:04 <JaffaCake> you can also write (ghc>=6.4 ? [ghc64] | ghc >=5.04 [ghc54])
06:21:10 <boegel> so, by tomorrow, stuff is up ad running ? :p
06:21:25 <JaffaCake> the thing on the left of ? doesn't have to be a flag
06:21:32 <boegel> shapr: do you have a list or something with FLM's functionality ?
06:21:42 <Lucinda> do you mean to allow people to describe their own refactorings using a meta-language?
06:21:49 <Itkovian> boegel: shapr is gone
06:22:29 <Igloo> So when we're building a Debian package or whatever, we know debug is off, gtk-bindings is on, what version of ghc we have etc, so we can get a simple list of deps that are exactly what must be satisfied. So although cabal's deps are inexpressible, we can always get something expressible in any dep language
06:22:49 <JaffaCake> that's the idea
06:22:51 <Beelsebob> chris: is the emacs stuff working?
06:22:57 <Lucinda> yeah
06:23:01 <Igloo> Sounds reasonable to me then  :-)
06:23:01 <Lucinda> pretty wuch
06:23:04 <Beelsebob> :)
06:23:07 <Beelsebob> and the SEE?
06:23:10 <Lucinda> no
06:23:12 <Beelsebob> :(
06:23:15 <Lucinda> I cant test that in the office
06:23:16 <JaffaCake> except you can actually write deps that aren't expressible in debian...
06:23:19 <Lucinda> need my mac
06:23:20 <Beelsebob> good point
06:23:25 <Igloo> eh?
06:23:29 <Lucinda> might try an eclipse plug in
06:23:31 <boegel> Itkovian, woops :)
06:23:35 <Igloo> Like what?
06:23:37 <Beelsebob> haha, I'll slap you if you do
06:23:57 <Lucinda> i can use it to prove a point to claus
06:24:06 <Beelsebob> :)
06:24:06 <JaffaCake> like (a>=1.0 ? b>=1.0 | c>=1.0 ? d>=1.0)
06:24:16 <Beelsebob> true
06:24:22 <JaffaCake> or would you just take the left branch in that case?
06:24:26 <Beelsebob> and you slapping him is better than me slapping you
06:24:35 <CosmicRay> Beelsebob: was that agreement or did you evaluate the expression? ;-)
06:24:51 <Beelsebob> cosmic: I'm a very fast evaluator ;)
06:24:56 <CosmicRay> hehe
06:24:58 <Beelsebob> ... or I just agreed
06:25:07 <Lucinda> haha!
06:25:18 <Igloo> If a>=1.0 is true then we'd probably translate that to a>=1.0, b>=1.0. Otherwise c>=1.0, d>=1.0.
06:25:27 <Beelsebob> I should replace lambdabot with speed like that
06:25:49 <CosmicRay> Igloo: I have a debian packaging question for you whenever you have a moment
06:25:58 <Igloo> Go on?
06:26:13 <CosmicRay> Igloo: OK, so this problem arises whenever I package up a Haskell binding to a C library
06:26:22 <JaffaCake> Igloo: so how do you know which of those alternatives to pick?
06:26:28 <Lucinda> beelsebob: you heard of this ATerm thing?
06:26:29 <CosmicRay> Igloo: I can't get the Depends: line for the GHC package to be as specific as it needs to be
06:26:33 <Beelsebob> nope
06:26:41 <Igloo> JaffaCake: We look at the system state when we're building the package
06:26:41 <CosmicRay> Igloo: dpkg-shlibdeps doesn't find dependencies inside .a files
06:26:47 <vikasg> Haskell server pages seem way cool
06:26:50 <Lucinda> shapr said it had something to do with the meta-environment
06:26:51 <JaffaCake> i see
06:26:51 <Beelsebob> google says it's a terminal for AfterStep :)
06:26:55 <CosmicRay> Igloo: and I have a suspicion that the libghc6-* package needs to depend on a -dev package anyway
06:26:57 <Lucinda> I see
06:27:15 <CosmicRay> Igloo: so I'm just manually inserting things like Depends: libldap2-dev in there and hoping for the best
06:27:16 <Igloo> CosmicRay: You need to read the libs from the cabal file, link return 0 with it and have dpkg-shlibdeps look at that
06:27:47 <CosmicRay> Igloo: ahh, ok.  so the ghc6 packages don't really need to depend on the -dev packages?
06:27:48 <Igloo> Oh, right, yes, you'll need the dev packages
06:28:32 <JaffaCake> Igloo: thanks, I feel slightly more confident that this is reasonable now
06:28:42 <Igloo> Well, we should check, but I'd have thought we'd need the -dev packages. But that's no harder than making build-deps of non-Haskell stuff
06:28:50 <Lemmih> vikasg: Indeed.
06:29:01 <Igloo> JaffaCake: Cool  :-)
06:29:11 <CosmicRay> Igloo: well, usually with non-haskell stuff, you aren't building .debs that depend on -dev packages
06:29:36 <Igloo> CosmicRay: No, normally you put them in one line. Now you just put the same thing on two lines.
06:29:41 <vikasg> Lemmih, the regex patterns are especially neat
06:29:48 <CosmicRay> Igloo: I don't follow
06:30:12 <Igloo> Rather than build-depends: foo you have build-depends: foo\ndepends: foo
06:30:43 <Igloo> There was a discussion a little while ago about easier ways to get from library to dev-library, but it didn't meet with approval IIRC
06:30:44 <CosmicRay> ok, and that's what I'm doing now.  But my concern is that this is not a versioned dependency
06:31:10 <Igloo> I don't think it needs to be
06:31:49 <CosmicRay> well, here's an example.  From libhugs-ldap:
06:31:53 <CosmicRay> Depends: hugs (>= 98.200503.08), libc6 (>= 2.3.5-1), libldap2 (>= 2.1.17-1)
06:32:01 <CosmicRay> and from libghc6-ldap-dev
06:32:06 <CosmicRay> Depends: ghc6 (>= 6.4), ghc6 (<< 6.4-999), libldap2-dev
06:32:23 <CosmicRay> now, for the hugs package, dpkg-shlibdeps derived libldap2 (>= 2.1.17-1) for me automatically
06:32:28 <Lemmih> vikasg: Haven't found use for them yet.
06:32:38 <Igloo> But for the -dev we only need the API to be the same, which is guaranteed by the package name, no?
06:32:43 <CosmicRay> I would assume that the versioned dep should also be there for libghc6-ldap-dev, as part of the dep on libldap2-dev
06:33:20 <CosmicRay> Igloo: AFAIK, the only guarantee the package name gives us is that things that existed in the API as of one version will still exist as of a later version
06:33:33 <CosmicRay> so in the hugs case, for instance, we aren't guaranteed that a package earlier than 2.1.17-1 would work
06:33:43 <CosmicRay> perhaps 2.1.17 added some new function that is used
06:33:52 <Igloo> AFAIK the above is fine. You'll have to speak to someone who knows more about shared libs than me to get anything more definitive  :-)
06:33:59 <Beelsebob> hmm, how pleaant... someone's left their thong in the middle of the floor in the washing room
06:34:22 <Lucinda> nice
06:35:21 <CosmicRay> Igloo: hmm.  It just doesn't seem right to me that the hugs package, with a .so, would have a tighter versioned dep than the ghc6 one
06:35:40 * shapr returns with Option "DontZap" "true"
06:35:54 * CosmicRay ZAPs shapr
06:35:59 * Beelsebob wonders what the hell that means
06:36:07 <paolo> moo
06:36:13 <shapr> Beelsebob: I can press C-M-BS with one finger, and sometimes do.
06:36:15 <Beelsebob> oink!
06:36:24 <CosmicRay> heh
06:36:52 <Beelsebob> random
06:37:09 <Beelsebob> only key near C and M here is `
06:37:33 <CosmicRay> aw crap, comment spammers have found the sequence
06:37:44 <Beelsebob> hnuh?
06:37:46 <shapr> I'm using a Kinesis Contoured.
06:37:46 <Lemmih> Is it possible to implement timeouts in Haskell without spawning a new process?
06:37:59 <paolo> I want one :-(
06:38:03 <CosmicRay> Lemmih: what sort of timeout
06:38:32 <Beelsebob> problem here is mashing cmnd-Q
06:38:44 <Beelsebob> or hitting cmnd-w rather than cmnd-v
06:38:52 <Lemmih> "do this for n time units and then kill it"
06:39:20 <CosmicRay> Lemmih: but what is "this"?  IO or CPU?
06:39:39 <CosmicRay> dammit drupal
06:39:55 <Lemmih> CosmicRay: 'this' is an arbitrary piece of Haskell code.
06:40:15 <Itkovian> I'm off
06:40:24 <Igloo> Lemmih: I don't believe so
06:40:35 <shapr> Man, people on lambda-the-ultimate sure do get pissy with each other.
06:40:54 <Beelsebob> lambda the ultimate?
06:41:06 <CosmicRay> Lemmih: there is code to do that in Peter's Threads.Child library
06:41:11 <paolo> shapr, do you have the *new*triple-action*foot*switch* too?
06:41:12 <CosmicRay> Lemmih: which is also included in MissingH.
06:41:21 <vikasg> shapr, wrt?
06:41:30 <shapr> paolo: Nah, I prefer to sit cross legged with my keyboard on my lap.
06:41:34 <CosmicRay> timeout :: Timeout -> IO a -> IO (Maybe a)
06:41:35 <CosmicRay> Wrap an IO computation to timeout and return Nothing after n microseconds, otherwise Just a is returned.
06:42:06 <shapr> vikasg: I'm reading the concatenative languages thread.
06:42:06 <Lemmih> CosmicRay: But that fails if the IO action doesn't do any memory allocations.
06:42:10 <paolo> shapr, I do usually sit cross legged too :-)
06:42:12 <dblhelix> @code
06:42:12 <lambdabot> Graph.hs: cross g pre post   = mapT select g
06:42:19 <paolo> @index mapT
06:42:21 <lambdabot> bzzt
06:42:23 <CosmicRay> Lemmih: eh? why?
06:42:33 <shapr> vikasg: The part where Slava Pestov gets pissy at Anton von Straaten.
06:42:45 <Beelsebob> interesting
06:43:06 <Lemmih> CosmicRay: Because then the other threads aren't allowed to execute.
06:43:09 <shapr> I think many people on LtU need a dose of http://c2.com/cgi/wiki?KillYourDarlings
06:43:17 <Igloo> CosmicRay: Test it with    let f () = f () in f ()
06:43:43 <shapr> I do wish Greg Buchholz would show up on #haskell more though, he has interesting things to say.
06:45:09 <shapr> Ah, John Cowan chimed in on that thread. That's interesting.
06:45:31 <CosmicRay> Lemmih: are you *sure* that threadDelay is vulnerable to that problem?
06:45:38 <paolo> shapr, you know every single cool page of that wiki.
06:45:48 <CosmicRay> Lemmih: normally delays on Unix are implemented by arranging to receive a signal after a certain period of time
06:46:11 <CosmicRay> speaking of which, you could also go that route manually via http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.Posix.Signals.html
06:46:12 <Lemmih> CosmicRay: threadDelay is implemented via select in GHC.
06:46:52 <CosmicRay> I guess it would have to, given its precision
06:47:12 <Lemmih> How do you do it with signals?
06:47:23 <CosmicRay> you would call scheduleAlarm
06:47:26 <shapr> paolo: Nah, I just know some of them. Anyway, I read through most of that wiki's content in the late 90s, I'm sure it's changed by now.
06:47:32 <CosmicRay> then set a signal handle for SIGALRM
06:47:48 <CosmicRay> or rather, set the handler first, then call scheduleAlarm
06:48:14 <CosmicRay> then go off and do whatever you want
06:48:28 <CosmicRay> when the specified time has elapsed, SIGALRM is sent to your process and your handler is invoked
06:48:53 <Lemmih> And it's safe to call 'threadKill' from the handle?
06:49:15 <CosmicRay> Lemmih: I would hope so.  if these are IO threads, they should be
06:49:27 <CosmicRay> easy way to find out: try it
06:49:38 <Lucinda> shapr: what is this meta-environment? do you mean creating a meta-language to describe refactorings?
06:50:01 <shapr> Lucinda: Nah, I mean the language agnostic parsing/refactoring framework called "The MetaEnvironment".
06:50:22 <Beelsebob> oh, sounds like the COPE
06:51:10 <dblhelix> Lemmih: btw, the using a small C wrapper for a Haskell SDL program on Mac OS indeed works fine: http://www.cs.uu.nl/~stefan/downloads/gameloop.html
06:52:43 <Lemmih> dblhelix: Neat (:
06:53:06 <Beelsebob> argh, he's upside down!
06:53:52 <Beelsebob> gyah, I'm in impatient mood today
06:53:57 <shapr> dblhelix: Want to write a TMR article about making simple SDL games? :-)
06:54:05 <shapr> Beelsebob: Well get patient, and do it now!
06:54:18 <Lemmih> shapr: haha.
06:54:19 <Beelsebob> heh
06:54:36 <Beelsebob> I might go do all my washing up
06:54:39 <Beelsebob> see you all in a bit
06:54:40 <Beelsebob> \
06:54:50 <dblhelix> shapr: do you want that before or after I can get to writing an article about constraint-based typing?
06:54:53 <dblhelix> :)
06:54:54 * ape wants to right a NES emulator in haskell & SDL
06:55:12 <tromp> that's better than lefting it
06:55:17 <tromp> or wronging it:)
06:55:35 <dblhelix> ape: I can really recommend Lemmih's binding then
06:56:15 <ape> sorry i am totally ultimately messed up right now
06:56:20 <shapr> dblhelix: Which one can you have ready by the 1st of September?
06:56:57 <dblhelix> shapr: I'll try and see if I can have the one on cbt ready by then, okay?
06:57:10 <shapr> Cool!
06:57:14 <Lemmih> dblhelix: May I distribute your game as a Haskell/SDL example?
06:57:34 <shapr> Next issue comes out September 1st, and it'll have an article by Oleg in it.
06:58:21 <dblhelix> Lemmih: you can, but would you mind to mention Joost when you distribute it?
06:58:47 <dblhelix> Lemmih: it's really not much of a game... more a proof of concept
06:59:01 <Lemmih> Sure.
06:59:06 <Lemmih> That's great.
07:00:10 <boegel> dblhelix, that would be cool !
07:00:40 <dblhelix> boegel: what exactly would be cool? :)
07:00:56 <boegel> writing an article on making simple SDL games :)
07:01:15 <dblhelix> ah, yes it would
07:02:39 <boegel> could you pull it off ?
07:02:53 <dblhelix> but I'm really not sure whether my solution is elegant enough... I just hacked this together in an hour or so, last night...
07:04:07 <dblhelix> I decided to implement the game engine as some kind of state monad, but maybe that's just too contrived... well, maybe not... comments are welcome, that's for sure
07:04:58 <boegel> that's why you should write the article for :) get people's opinion :) it make out to be a good (understandable ?) monad discussion
07:05:30 <dblhelix> maybe Lemmih should write about implementing an SDL binding first :)
07:10:37 <basti_> hi
07:10:59 <dblhelix> should go now... see you guys tomorrow
07:23:21 <boegel> yeah Lemmih, you should =-
07:23:47 <Lemmih> /-:
07:24:13 * Lemmih got way too many things to do.
07:26:14 <boegel> like what ? I don't believe you :p
07:26:22 <Lemmih> CosmicRay: Hurrah. It's works!
07:26:28 <CosmicRay> Lemmih: the alarms?
07:26:44 <Lemmih> Yeah. And I was almost giving up before (:
07:26:49 <CosmicRay> sweet
07:27:24 <Lemmih> HSP will have timeouts now. (:
07:28:00 <musasabi> Lemmih: is your HSP API compatible with the old HSP (and do you support post-requests) ?
07:28:54 <Lemmih> musasabi: post-requests? As in method="post" thingy?
07:29:14 <musasabi> yes.
07:30:07 <Lemmih> musasabi: I'm using FastCGI so it even supports file uploads.
07:30:54 <musasabi> hmm nice :-)
07:31:11 <musasabi> Are you planning of integrating it with the upstream?
07:31:38 <Lemmih> Most of HSP is intact. It's HSPR I've really buthered.
07:31:41 <autrijus> hm, HSP uses normal session-db model?
07:32:28 <Lemmih> autrijus: I removed the DB dependance. It now defaults to a hashtable.
07:33:09 <Lemmih> musasabi: I'm not sure nibro agrees with some of the design changes I made.
07:35:50 <autrijus> Lemmih: oh cool.
07:36:12 <autrijus> I'm giving myself two days to make WASH work for my $job
07:36:25 <autrijus> if it doesn't, then I'll look into HSP (with Catalyst as the ever-ready fallback)
07:36:57 <Lemmih> Catalyst?
07:37:06 <autrijus> http://www.cs.helsinki.fi/u/ekarttun/hsp/hsp ?
07:37:15 <autrijus> Catalyst is catalyst.perl.org
07:37:31 <Lemmih> http://scanninavian.org/~lemmih/hsp
07:37:41 <autrijus> thx
07:37:58 <autrijus> scann_ed_inavian :)
07:38:07 <Lemmih> oh, right.
07:39:18 <Lemmih> It's installed just like moinmoin.
07:40:25 <autrijus> hspr?
07:40:40 <Lemmih> Yes.
07:40:42 <autrijus> standalone httpd?
07:40:55 <Lemmih> Nope. FastCGI application.
07:40:58 <autrijus> aha.
07:41:45 * autrijus sees withContinuations
07:42:12 <autrijus> this doesn't mean what it means in WASH, right.
07:43:17 <Lemmih> I don't know.
07:43:28 <Lemmih> I don't even know what they are in HSP.
07:43:35 <autrijus> withContinuations :: Cont a => (a -> HSP XML) -> HSP XML -> HSP XML
07:43:36 <autrijus> withContinuations f def = do
07:43:51 <autrijus> (maybe def f . fmap read) =<< getRequestVar contVar
07:43:58 * autrijus doesn't know what it means either.
07:45:36 <Lemmih> Timeout test: http://212.242.49.100/hsp/Timeout
07:46:29 <Lemmih> This is getting really close to PHP.
07:46:45 <autrijus> type-safe PHP is not a bad thing.
07:47:00 * boegel leaves !
08:00:59 <shapr> Igloo: Is there a TODO list for Bark?
08:03:02 <Igloo> The big things are an SQL backend to replace the file-based on and a mail frontend (probably means writing decent MIME libraries)
08:03:21 <shapr> Did you find any MIME code better than WASHMail?
08:03:33 <Igloo> Np
08:03:36 <Igloo> No even
08:04:15 <Igloo> The other things on the list are either tiny tweaks or depend on the SQL backend I think
08:05:12 <shapr> It occurs to me that autrijus' approach to Pugs would help us in the Haskell world. I shall solicit HUnit and QuickCheck  MimeLib tests.
08:05:27 <Igloo> I did look for a testsuite but didn't find one
08:05:46 <shapr> No MIME testsuite of any flavor?
08:06:09 <Igloo> No
08:06:50 <Igloo> WASH seems to get it wrong in http://urchin.earth.li/cgi-bin/ian/MIME - what I expect to be the body still have "Content-Type: text/plain\nContent-Transfer-Encoding: quoted-printable\n" at the top
08:07:11 <Igloo> It also doesn't take account of comments and things when parsing (neither do mutt or anything else I looked at)
08:07:48 <Igloo> I didn't see anything in RFC2822 saying all headers were case insensitive either
08:08:01 <shapr> I think RFC822 does say that.
08:08:06 <shapr> But I haven't read it in years.
08:08:14 <Igloo> Prove it
08:08:30 <Igloo> Oh, 822. I haven't read that one yet
08:08:49 <Igloo> But I plan to, in the hopes it will be clearer than 2822
08:09:02 <shapr> iirc, it is.
08:10:23 <shapr> Line 1003 of RFC822: When matching any other syntactic unit, case is to be ignored. For  example, the field-names "From", "FROM", "from", and even "FroM" are semantically equal and should all be treated identically.
08:11:24 <ibid> 822 was very un-clear
08:11:33 <ibid> on a lot of things
08:12:24 <shapr> Anyway, a good MIME library would be useful for many applications, including vegai's rumored libsilc binding.
08:12:24 <Igloo> shapr: Where does it say header names aren't one of the things listed above that?
08:12:44 <musasabi> RFC822 is outdated on many areas.
08:13:22 <musasabi> RFC2822 seems the most sensible one.
08:13:33 <Igloo> 2822 is definitely unclear, to me at least
08:13:44 <shapr> Igloo: Line 424 of RFC822: Each header field can be viewed as a single, logical  line  of ASCII  characters,  comprising  a field-name and a field-body.
08:13:45 <ibid> Igloo: you should read the abnf rfc, it defines case insensitivity
08:14:35 <ibid> Igloo: any abnf rule that contains literal characters is case insensitive wrt that literal
08:14:36 <Igloo> e.g. which of these are equivalent to   text   te\xt   te"x"t  "text"  ?
08:14:52 <Lemmih> Which extension do you need for derving Typeable?
08:14:55 <Igloo> ibid: But what about headers it doesn't know about?
08:15:14 <Lemmih> *deriving
08:15:16 <ibid> Igloo: then its's unspecified, i'd imagine
08:15:37 <shapr> field-name  =  1*<any CHAR, excluding CTLs, SPACE, and ":">
08:15:44 <Igloo> Right, that's what I was saying. I can't see anywhere it says all headers are case insensitive, but WASH lower-cases them all
08:16:08 <shapr> Where should I solicit test cases?
08:16:26 <Igloo> No idea. The WG is disbanded.
08:16:27 <shapr> I could fork the MIME parts of WASHMail I guess.
08:18:01 <musasabi> I vaguely think that they are case insentive.
08:18:05 <ibid> Igloo: text is one atom, te"x"t is semantically three atoms, te, x and t; "text" is one atom and equivalent to text
08:18:34 <Igloo> ibid: And te\xt?
08:18:56 <Igloo> (my intuition agrees with you, but I didn't think 2822 told me that)
08:19:33 <sylvan> Design question: I'm writing a priority queue. Should I have "insertBy" "deleteMinBy" etc. Or should I have the "standard" versions (using "compare") and also allow the user to create a general version in which he supplies the comparison function (emptyBy :: (k->k->Ordering) -> PriorityQueue k v)? The latter seems safer in that you can't delete something with a different comparison function than you inserted it with, however that woul
08:20:07 <ibid> Igloo: i read that almost directly from 2822
08:20:29 <ibid> Igloo: i'm not sure about te\xt; it looks to me like a syntax error
08:21:03 <Igloo> \x is a quoted pair, isn't it?
08:21:24 <Igloo> Which bit of 2822?
08:21:53 <ibid> Igloo: syntax error as an atom or quoted-string at least
08:22:15 <ibid> Igloo: yes but quoted pairs are allowed only in certain productions
08:22:38 <ibid> Igloo: 3.2.2, 3.2.4, 3.2.5
08:25:05 <Igloo> Ah, you're right, it would probably need to be "te\xt"
08:26:15 <ibid> yes
08:26:59 <ibid> 3.6.8 seems to indicate that unspecified fields should be treated as octet streams
08:27:11 <Igloo> I'm still not entirely clear what sort of token to look for when 2045 says discrete-type := "text", though
08:27:16 <ibid> and not interpreted unless defined out of band
08:30:34 <ibid> aiui, that means a literal, ie case-insensitive text without the quotes
08:31:20 * Igloo is just skimming 2234 again
08:31:47 <Igloo> Right, so "text" or "te\xt" would be wrong ni a content-type line, right? it needs to be just text
08:32:47 <Igloo> And likewise MIME-Version: \1.0 is wrong
08:33:09 <Igloo> As is MIME-Version: 1\.0
08:33:25 <Igloo> Thanks, I think I have a better grasp of what's going on now  :-)
08:33:26 <ibid> that's my understanding
08:36:16 <Igloo> Hmm, I'm not sure how to understand 'x-token := <The two characters "X-" or "x-" followed, with no intervening white space, by any token> though
08:36:34 <Igloo> I can't tell if "any token" is refering to token := 1*<any (US-ASCII) CHAR except SPACE, CTLs, or tspecials> or not
08:37:15 <Igloo> I guess it must be
08:38:08 <ibid> probably
08:38:21 <ibid> i trust you've read 2049, btw :)
08:39:26 <Igloo> Oh, I think I might have forgotten about that one when I got bogged down in 2045!
08:39:55 <Igloo> I'm almost scared to read it now that I have a consistent image in my mind of how things should work, though  :-)
08:42:07 <ibid> i don't think it will destroy your work :)
09:15:23 <bourbaki> moin
09:15:36 <shapr> y0
09:15:43 <basti_> moo.
09:27:47 <CosmicRay> ping
09:28:05 <shapr> pong
09:28:15 <basti_> paloo
09:42:11 <shapr> I'm getting a linking problem with cryptolib 2.0.2 "/usr/bin/ld: cannot find -lHSNewBinary-0.1" even though ghc-pkg -s NewBinary shows "library-dirs: /usr/local/lib/NewBinary-0.1" and I have /usr/local/lib/NewBinary-0.1/libHSNewBinary-0.1.a, any ideas?
09:43:26 <basti_> uhmm, -0.1 is not the same as 0.1.a?
09:44:17 <shapr> doh, I think I found the problem.
09:44:43 <shapr> Is this a bug in Cabal? --> "-rw-------  1 root 225504 2005-08-11 14:49 /usr/local/lib/NewBinary-0.1/libHSNewBinary-0.1.a"
09:45:23 <shapr> Specifically, shouldn't Cabal set ugo+r ?
09:47:07 <shapr> chmod ugo+r fixed it.
09:47:08 <CosmicRay> it should, but not in violation of umask
09:47:23 <CosmicRay> I'd say that just opening the file for writing should do the right thing
09:47:28 <shapr> How do I see my umask?
09:47:32 <CosmicRay> type umask
09:47:37 <shapr> too easy :-)
09:47:51 <sylvan> how do I tell haddock where to look for the standard hierarchical libraries (Prelude etc.)?
09:50:12 <shapr> g'bye ehuber
09:50:39 <ehuber> hii
09:50:41 <basti_> wb ehuber
09:50:45 <shapr> hiya ehuber
09:50:49 <basti_> hold on tight to these handrails
09:50:53 <basti_> floor is slippery here
09:50:57 <ehuber> :p
09:51:47 <basti_> can we help you?
09:53:08 <ehuber> not at the moment
09:53:16 <basti_> :)
09:53:19 <ehuber> ive figured out everything that puzzles me about haskell up to this moment
09:53:27 <shapr> Want some new puzzles?
09:53:31 <basti_> :D
09:53:33 <ehuber> not yet
09:53:35 <ehuber> :p
09:54:02 <ehuber> but you can point me where i should look to be blinded, once i am done with what i am doing (an html parser)
09:54:20 <shapr> Have you seen HaXml and HXmlToolkit?
09:55:07 <ehuber> well, im doing it mostly to learn myself
09:55:14 <ehuber> what's special about these libraries?
09:55:47 <shapr> HaXml constructs algebraic datatypes for each DTD, meaning you can only construct legal code.
09:56:12 <shapr> HXmlToolkit uses a generic tree datatype and does validation as a separate step using regexes (not sure how that works).
09:56:31 <basti_> @plugs do {a<-"MLK" ; return (chr $ ((65 +).(`mod` 26).(13+).(65-)) (ord a))}
09:56:38 <lambdabot> "BCD"
09:56:39 <basti_> rot 13 in a like :)
09:56:40 <basti_> line
09:56:43 <shapr> neat
09:57:44 <ehuber> sick (:
09:57:59 <ehuber> well, i would be writing this for a web spider
09:58:10 <shapr> Oh, interesting.
09:58:27 <ehuber> so my goal is to make it allow any html it might encounter... so its not allowed to blow up or give error messages, only construct the most likely interpretation
09:59:07 <basti_> @pl map (chr.(65 +).(`mod` 26).(13+).(65-).ord) "GJCCZ"
09:59:08 <lambdabot> map (chr . (65 +) . (`mod` 26) . (13 +) . (-) 65 . ord) "GJCCZ"
09:59:14 <basti_> oops
09:59:20 <basti_> @plugs map (chr.(65 +).(`mod` 26).(13+).(65-).ord) "GJCCZ"
09:59:23 <lambdabot> "HELLO"
09:59:56 * shapr runs ghc --make Flippi -fcase-merge -fdicts-strict -fdo-eta-reduction -fdo-lambda-eta-expansion -fexcess-precision -fliberate-case-threshold15 -fmax-worker-args30 -fno-state-hack -funbox-strict-fields -funfolding-creation-threshold30 -funfolding-fun-discount30 -funfolding-keeness-factor30 -funfolding-update-in-place -funfolding-use-threshold30 -fmax-simplifier-iterations90
09:59:59 <ehuber> now basti, make a huffman encoder (:
10:00:07 <basti_> ahh.
10:00:12 <basti_> that would need a fold.
10:02:30 <shapr> Surprisingly, the many options makes a larger binary than just ghc --make Flippi
10:02:53 <ehuber> is it true huffman encoding is patented ? that would be lame
10:02:54 <shapr> Maybe that's because of -fexcess-precision?
10:03:39 <wilx> Isn't excess precision related to the 80bit Intel FP?
10:04:04 <shapr> I think it's about excess GHC internal precision.
10:07:34 <Lemmih> You more than triple the maximum size for inlining so it's not too surprising that the resulting binary is bloated.
10:07:35 <shapr> Are there detailed descriptions of the GHC optimizations somewhere?
10:08:25 <jaap> has anyone written something to read RSS in Haskell? I imagine it should be doable on top of the various xml things out there, but I was just wondering if it's been done
10:08:28 <Lemmih> -fexcess-precision and -fno-state-hack will only make things slower, I think.
10:08:47 <wilx> Hm.
10:08:55 <shapr> jaap: I haven't seen anything.
10:09:12 <shapr> @google filetype:hs syndication
10:09:13 <lambdabot> No result found.
10:09:17 <shapr> @google filetype:hs rss
10:09:19 <lambdabot> http://abridgegame.org/cgi-bin/darcs.cgi/darcs/win32/Posix.hs?c=rss
10:09:25 <wilx> Heh.
10:09:26 <shapr> Yeah right.
10:09:28 <jaap> shapr: thanks. if you google it you get lots of blogs with the words haskell on them ;-)
10:09:29 <wilx> RSS sucks.
10:09:32 <jaap> thanks for the superior googlage
10:09:38 <wilx> No DTDs :/
10:10:35 <shapr> jaap: filetype: is a powerful tool.
10:11:46 <wilx> Hm, from what I read -fexcess-precision shouldn't really make things slower.
10:12:03 <wilx> Intel FPU does everything in 80bits internally anyway.
10:12:13 <shapr> -fexcess-precision doesn't change the binary size that I can see.
10:14:06 <shapr> Not that my experiments are terribly scientific :-)
10:14:44 <ehuber> well, it'll save you up to 80-32 bits on every float value
10:14:59 <ehuber> which is not much, depending on your number of constants and whether GHC will reuse constants
10:15:42 <ehuber> and alignment
10:15:45 <paolo> perspectival, nice nick
10:15:45 <ehuber> and bla bla
10:15:55 <shapr> I haven't found a combination of options that does better than -O2
10:16:09 <ehuber> shapr: they probably set it up that way
10:16:21 <ehuber> (: i dunno
10:19:27 <ehuber> is ghc an interpretater haskell->c that uses gcc ?
10:20:29 <shapr> I wish I could send darcs patches to cvs.haskell.org, I've found various GHC docs bugs and inconsistencies in the options-optimise.html
10:21:35 <sylvan> Anyone want to try out my priority queue implementation? http://www.dtek.chalmers.se/~sylvan/PriorityQueue/
10:21:36 <shapr> But I am not motivated enough to figure out who I need to contact to get a cvs.haskell.org account.
10:22:04 <Lemmih> shapr: You can talk to JaffaCake about it.
10:22:09 <Lemmih> Hey SyntaxNinja.
10:22:52 <pejo> ehuber, you can compile with -fvia-C
10:23:04 <shapr> JaffaCake: GHC in darcs? Or maybe a darcs -> cvs gateway?
10:26:42 <Heffalump> a two-way gateway is hard to implement
10:29:23 <SyntaxNinja> hi Lemmih. things working for you?
10:30:25 <Lemmih> Kinda. hs-plugins is difficult to install as user so I'm stuck until dons awake.
10:30:58 <Lemmih> But haskell.galois.com is by far the cooles machines I've ever ssh'ed! (:
10:30:59 <SyntaxNinja> I can install things as root if you need... why is it hard to install? does it use cabal?
10:31:15 <SyntaxNinja> heh
10:31:29 <Lemmih> Nah, it uses a nasty make-based system.
10:31:47 <Igloo> What's cool about h.g.c?
10:31:54 <Lemmih> I think Cabalizing it on dons TODO list.
10:32:21 <SyntaxNinja> Igloo: don't spoil his fun ;)
10:33:05 <ehuber> gotta move
10:33:11 <ehuber> be back in a half hour or so
10:33:19 <SyntaxNinja> @seen JaffaCake
10:33:21 <lambdabot> JaffaCake is in #haskell. Last spoke 4 hours, 4 minutes and 47
10:33:21 <lambdabot> seconds ago.
10:34:04 <Lemmih> SyntaxNinja: It would be great if you could install hs-plugins globally.
10:35:34 <SyntaxNinja> Lemmih: what version do you need?
10:36:05 <paolo> do you know how to get a font-string of an X window?
10:36:09 <Lemmih> I've pulled the darcs repo in my home dir.
10:36:23 <paolo> xprop doesn't lis it - but I think there is a tool which does, I don't remember what is, tough :-(
10:37:41 <SyntaxNinja> Lemmih: do you want the version in darcs?
10:38:09 <Lemmih> SyntaxNinja: Yeah.
10:39:42 <SyntaxNinja> Philippa: I hear you're interested in splitting up the IO monad.
10:47:19 <Philippa> SyntaxNinja: yeah
10:47:28 <Heffalump> implementing it as a tower of monad transformers?
10:47:30 <SyntaxNinja> Philippa: have you read teh H monad paper?
10:47:41 <Philippa> OTOH, right now I'm probably more interested in carrying on my game of Chrono Cross ;-)
10:47:47 <_deepfire> is there a place where one can snatch gtk2hs 0.9.8 .deb`s from?
10:48:02 <Philippa> Heffalump: I wasn't going to do it that way, as if you've got the type classes you may as well make plain IO an instance of all of them and work from there
10:48:03 <_deepfire> haskell-unsafe.alioth.debian.org doesn`t resolve...
10:48:11 <Philippa> SyntaxNinja: don't think so
10:48:13 <Philippa> URL?
10:50:13 <SyntaxNinja> Philippa: hm. don't know. it's an icfp paper by the ogi guys
10:50:44 <shapr> It's here - http://www.cs.pdx.edu/~apt/icfp05.pdf
10:51:26 <Heffalump> doesn't that mean you need to define each function in each split up monad, though?
10:52:21 <Philippa> or implement them all as wrappers on top of "raw" IO, as they have to be implementation-supported anyway
10:53:45 <Heffalump> you still need one wrapper for each monad
10:54:02 <Philippa> yeah, but that's really no big deal
10:54:32 <Philippa> use a bit of TH to simplify it to "this monad has this list of features" if you're really worried
10:54:55 <pejo> shapr, ohh. Nice paper.
10:55:05 <Philippa> actually thinking about it... no, use the monad transformers, it exposes extra functionality
10:55:17 <Philippa> an STT transformer'd be great on top of List, for example
10:55:51 <Philippa> not sure what to do about fundamentally-IOish things though, you can't expose those as transformers
10:56:31 <Philippa> (STRefs are safe in that context with some work, but disk access and so forth isn't)
10:57:07 <SyntaxNinja> Lemmih: OK hspluggins should be installed now (as well as cabal and haskell-src-exts)
10:57:32 <shapr> JaffaCake: Will -fPIC be implemented for IA32?
10:59:12 <Lemmih> SyntaxNinja: Great. Gotta sleep now so I'll look at it tomorrow.
11:00:21 <SyntaxNinja> Lemmih: OK l8r
11:05:41 <paolo> how was it called that hemming speech...
11:05:45 <paolo> ...it appeared on LtU
11:05:48 <_deepfire> there are two repositories which contain gtk2hs 0.9.6, but unfortunately 0.9.6 debs require that i downgrade ghc
11:06:34 <pejo> paolo, Hamming? You and your Research. http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
11:06:53 <paolo> danke!
11:06:59 <SyntaxNinja> does anyone know anything aobut linux-based pda phones?
11:08:26 <shapr> No, but if you find out, I want to know!
11:08:33 <shapr> I'd be happy enough with a linux-based pda.
11:11:42 <SyntaxNinja> it seems that they exist, in europe and china
11:12:26 <shapr> Really? Europe?
11:12:57 <_deepfire> Nokia is known to engage periodically into linuxy-phone stuff
11:13:30 <_deepfire> afaik up to recently there were only top-tier models with linux onboard
11:15:29 <paolo> 770?
11:16:14 <musasabi> shapr: what about zaurus?
11:17:14 <_deepfire> 770 isn`t a phone
11:17:25 <paolo> right
11:17:35 <shapr> Oh right, zaurus. Hm.
11:18:15 <musasabi> but I hear it is quite battery hungry.
11:18:28 <_deepfire> my mistake, not nokia, motorola
11:19:24 <_deepfire> http://www.gizmodo.com/gadgets/smartphones/motorola/motorola-e680i-linux-smartphone-037206.php, high-end though
11:20:13 <_deepfire> http://www.linuxdevices.com/news/NS3664493962.html
11:20:33 <shapr> Mmm, wireless stereo Bluetooth.
11:20:45 <_deepfire> also http://www.mobiletechnews.com/info/2005/06/27/115819.html
11:21:10 <SyntaxNinja> like I said... china
11:36:44 * Lemmih is having a hard time sleeping knowing that timeouts can't be done in a single process.
11:38:12 <lispy> Lemmih: why can't a timeout be done in a single process using alarm?
11:38:23 <lispy> because of signal badness?
11:40:20 <Lemmih> The handler doesn't even get executed.
11:41:02 <lispy> what is the timeout surrounding?
11:41:11 <lispy> a read, a write, a computation?
11:41:11 <CosmicRay> Lemmih: huh?
11:41:11 <Lemmih> Probably makes a small allocation and jumps right back the blocking thread.
11:41:17 <Lemmih> CosmicRay: It doesn't work.
11:41:19 <CosmicRay> slarms are by nature a single-process thing
11:41:27 <CosmicRay> Lemmih: I thought you said it did
11:42:09 <Lemmih> Yeah, but I accidently compiled the test program with -O
11:42:22 * lispy gets all confused
11:42:24 <CosmicRay> what would that have to do with it?
11:43:00 <Lemmih> The optimizer turns 'let f () = f () in f ()' into something which allocates memory.
11:43:13 <Lemmih> Probably 'let f = f in f' or something.
11:43:39 <CosmicRay> Lemmih: alarms are the canonical way to do this on unix for a cpu-bound computation
11:43:42 <Igloo> Oh, use f :: Int -> Int; f i = f (i+1) then
11:44:18 <CosmicRay> Lemmih: the only other single-process way is to poll the system clock.
11:44:27 <CosmicRay> Lemmih: either you or haskell must be using one approach or the other.
11:44:30 <Lemmih> Igloo: 'f ()' is great example.
11:44:34 <Igloo> I'm a bit confused if you don't see a blackhole exception, though
11:44:42 <lispy> CosmicRay: well, it's not as general but there are task specific was also
11:44:58 <lispy> CosmicRay: epoll and select come to mind
11:45:15 <CosmicRay> lispy: that is only useful if you have some io giong on
11:45:41 <Heffalump> lemmih: do you mean "something which doesn't allocate memory"?
11:45:59 <lispy> CosmicRay: indeed.  I don't understand what he's going so I recommneded it just in case :)
11:46:09 <Lemmih> Heffalump: No.
11:46:22 <Heffalump> in my experience, let f () = f () in f () is uninterruptible
11:46:31 <Heffalump> (using Haskell threads, that is)
11:46:34 <CosmicRay> Igloo: btw, iirc, heffalump disagrees with my depends: approach, but I don't remember why
11:46:44 <CosmicRay> Heffalump: right?  don't you maintain that haskell-hsql has a buggy depends: line?
11:47:06 <Heffalump> CosmicRay: yes. I forget precisely why, but it had to do with needing the -dev libraries.
11:47:27 <Heffalump> oh yes, because you need the -dev libraries for each database to be able to actually link against haskell-hsql.
11:47:33 <CosmicRay> Heffalump: yes.  perhaps we can discuss this on the haskell list.  I'm not convinced that I know how to do it right
11:47:40 <Heffalump> libraries@haskell.org ?
11:47:41 <CosmicRay> Heffalump: oh so that was a special case for haskell-hsql then
11:47:47 <Igloo> That's orthogonal to what we were talking about
11:47:52 <CosmicRay> no the debian one, I forget the address
11:47:53 * Heffalump isn't reading the lists regularly at the moment, because of messed up mail routing. I should sort that out.
11:47:57 <Heffalump> ah, I read that one.
11:48:00 <Heffalump> the one on urchin
11:48:04 <CosmicRay> yes
11:48:18 <shapr> Heffalump: gmane.org offers RSS feeds of the Haskell lists.
11:48:30 <CosmicRay> and several thousand others.
11:48:36 <Heffalump> I could read the mail archvies if I wanted to use the web
11:48:46 <CosmicRay> .. or a newsreader...
11:49:02 <shapr> RSS is easier than web for me.
11:49:04 <shapr> Less clicy.
11:49:06 <shapr> clicky*
11:49:10 <Heffalump> in fact I do want to use a newsreader, Agent, to read my list mail.
11:49:14 <Heffalump> or at least high-traffic lists.
11:49:21 <CosmicRay> shapr: it's not easier than nntp for me
11:49:31 <CosmicRay> Heffalump: well then, point it to news.gmane.org
11:49:47 <Heffalump> or I could just fix my mail routing..
11:49:54 <CosmicRay> actually I don't know if gmane has the urchin list
11:49:57 <Heffalump> I'd have to add news.gmane.org to nntpcache anyway.
11:50:04 <Heffalump> the urchin list is nice and low traffic, anyway.
11:50:14 <CosmicRay> I run newsx and a local inn2 installation ;-)
11:55:46 <shapr> hey mwc, how's code?
12:01:51 <paolo> http://www.guardian.co.uk/arts/gallery/0,8542,1543331,00.html yay
12:02:45 <paolo> @karma+ Banksy
12:02:46 <lambdabot> Banksy's karma raised to 1.
12:02:50 <Heffalump> yeah, those are cool
12:22:39 <jlouis> banksy does a lot of cool stuff I think
12:25:24 <mwc> shapr, not bad, just have to do work in C++ now :(
12:25:32 <mwc> But I am looking into the Boost FP stuff
12:28:07 <jlouis> I am coding perl. Now that is scary
12:29:12 <mwc> At least it's not a steaming hot pile of... java.
12:30:03 <lispy> i'd rather do java than perl, personally
12:30:41 <jlouis> actually some of the code makes thedailywtf.com look rather nice ;)
12:30:42 <Heffalump> jlouis: hah. Perl's not scary.
12:31:57 <jlouis> is (isn't) is (isn't)...
12:33:02 <mwc> Ever seen that periodic table of all the Perl6 operators? Enough said.\
12:33:45 <mauke> I bet it's not up to date
12:34:16 <mwc> the fact that there's that many is enough to make me weep
12:34:27 * jlouis weeps
12:34:44 <mauke> haskell has potentially infinitely many operators
12:34:50 <jlouis> Hmmm, there was something i promised to hack into lambdabot. see you on the other side
12:34:54 <jlouis> ;)
12:36:06 <paolo> the dark one!
12:50:26 <lament> does perl have potentially infinitely many operators?
12:50:28 <lament> or are they fixed?
12:51:06 <mauke> perl5's operators are fixed
12:51:20 <mauke> perl6 will have a user-mungable grammar
12:53:34 <lament> sounds scary
12:54:16 <paolo> sounds better onlines and ascii-programmatic-art
12:54:17 <mauke> on the other hand, perl5 has source filters
12:54:22 <paolo> oneliners, even
12:54:40 <jlouis> nej det er overhovedet ikke scary naar sprog pludselig kan laves helt om, bare fordi man har lyst.
12:54:57 <jlouis> det er faktisk utroligt rart.
12:55:02 <wagle> @babelfish jlouis
12:55:03 <lambdabot> Unknown command, try @listcommands.
12:55:08 <wagle> darn
12:55:12 <shapr> jlouis: hvilken kanal har du?
12:55:14 <paolo> indeed.. what‽
12:55:21 <jlouis> shapr: I am proving a point
12:55:35 <paolo> @help babel
12:55:37 <lambdabot> usage: babel lang lang phrase
12:55:44 <jlouis> notably that perl6 user-mungable grammar is scary ;)
12:55:52 <paolo> @babel nl en  nej det er overhovedet ikke scary naar sprog pludselig kan laves helt om, bare fordi man har lyst
12:55:54 <lambdabot>  nej det overhovedet ikke scary to sprog pludselig are possible
12:55:54 <lambdabot> laves there tend for, bare fordi man har lyst
12:56:00 <lament> vodka, vodka vill jag drikka
12:56:00 <shapr> paolo: That was danish.
12:56:01 <mauke> see http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm
12:56:12 <paolo> @babel dk en  nej det er overhovedet ikke scary naar sprog pludselig kan laves helt om, bare fordi man har lyst det er faktisk utroligt rart.
12:56:13 <lambdabot> module "babel" screwed up: Error: Language dk not supported
12:56:24 <wagle> @babel danish english nej det er overhovedet ikke scary naar sprog
12:56:25 <lambdabot> module "babel" screwed up: Error: Language danish not supported
12:56:25 <wagle>                pludselig kan laves helt om, bare fordi man har lyst det er                faktisk utroligt rart
12:56:38 <wagle> bah!
12:56:44 <wagle> lol
12:57:12 <wagle> ioplam r sa!
13:02:05 <wilx> Why is it that Control.Concurrent.Chan and Control.Concurrent.STM.TChan do not share interface/methods through type class even though they are virtually the same?
13:09:01 <pejo> For real world use a source filter could be really usable. Terrible hack, but usable.
13:09:20 <mauke> source filters are inherently broken
13:09:47 <mauke> because they work linewise, and perl's syntax isn't line based
13:17:25 <lament> it scares me how many #haskell peolpe are knowledgeable about perl
13:17:51 <Heffalump> well, a lot of people are here cos of pugs
13:18:14 <pejo> And the rest of us get paid to write it!
13:18:25 <TheHunter> \\
13:18:38 <TheHunter> sorry.
13:18:53 <lament> both reasons are scary in themselves :)
13:18:55 <mauke> heh, I'm actually a perl guy that likes to play around with haskell
13:19:30 <liyang> (while the rest of us are trying to wean ourselves off Perl. :)
13:20:07 * Heffalump tries to decide between working on antibuddha and going to bed
13:23:02 <Beelsebob> hehe, you know you've got a good peice of camping kit when it says suitable for -60°C and above
13:26:18 <Itkovian> evening
13:26:28 <Beelsebob> lo
13:26:32 <Itkovian> Beelsebob: well, it should be tested of course
13:26:42 <Beelsebob> haha... no chance
13:26:58 <Beelsebob> I'll be pissed off if I have to use that... it's my space blanket
13:27:37 <ape> you should see idf military blankets... they are make the furnace
13:28:11 <Beelsebob> ?
13:28:14 * Beelsebob missed that
13:31:01 <Beelsebob> argh... bloody thermarest... I might get it in it's bag on the 4th go
13:37:42 <SyntaxNinja> Beelsebob: do you know you're supposed to store them inflated?
13:37:57 <Beelsebob> syntax: yeh... that's why I'm having to deflate it
13:38:08 * SyntaxNinja didn't know that.
13:38:08 <Beelsebob> going away tomorrow
13:38:14 <Beelsebob> :)
13:38:31 <Beelsebob> they're bloody irritating when you need to get them into a bag
13:38:44 <SyntaxNinja> never had much trouble with mine, as long as you start out real slow
13:39:00 <Beelsebob> I have a system... but it doesn't seem to want to work tonight
13:39:24 <CosmicRay> Beelsebob: is this a sleeping bag
13:39:31 <Beelsebob> I usually fold it into four, sit on it, roll it up, sit on it, fold it down the middle, roll it up as tight as I can, sit on it, and repeat the last stage
13:39:33 <CosmicRay> I hate trying to fit sleeping bags back into their case
13:39:35 <Beelsebob> then it normally goes it
13:39:46 <Beelsebob> cosmic: no, it's a thermal air bed
13:40:05 <Beelsebob> they're only half an inch thick, but they're the comfiest things ever and keep you warm
13:40:15 <Beelsebob> ... or at least you don't lose heat to the ground
13:40:35 <CosmicRay> ah.  probably similar problem though
13:40:46 <Beelsebob> yeh, a little more structured
13:40:57 <Beelsebob> with a sleeping bag you can usually get away with just shoving
13:41:03 <Beelsebob> this you have to carefully roll
13:43:30 <CosmicRay> I can't get away with just shoving, at least with the sleeping bags I have
13:43:46 <CosmicRay> but then these are backpacking sleeping bags, designed to be very light and pack up into small spaces
13:44:12 <CosmicRay> but the damn things expand back in fractions of a second, and poof out under your (hand/knee/whatever you're using to compress them)
13:44:44 <Beelsebob> sounds pretty similar then
13:44:53 <Beelsebob> my sleeping bag is silly and over the top
13:45:04 <Beelsebob> ... and could never be taken walking
13:45:50 <CosmicRay> heh
13:46:12 <Beelsebob> on the plus side... it's fiine down to -15
13:46:36 <CosmicRay> mine is good down to about freezing
13:46:42 <CosmicRay> but then that's fine, I don't go camping in the winter anyway
13:46:46 <CosmicRay> and wouldn't want the extra weight
13:47:02 <Beelsebob> yeh, I don't particularly either
13:47:12 <Beelsebob> this has actually only come in useful once
13:47:25 <Beelsebob> ... when it managed to get down to -10 randomly in spring
13:51:35 <Itkovian> Beelsebob: I just roll themn up, squeezing the air out in the process, always fits in the original bag
13:51:51 <Beelsebob> itkovian: do you have one of the original ones?
13:51:59 <Beelsebob> that you don't have to fold in half?
13:52:11 <Itkovian> well, you mean in hakf lengthwise?
13:52:22 <Beelsebob> no, widthwise
13:52:23 <Itkovian> yes I do that, but then I roll it up
13:52:39 <Beelsebob> oh, okay... mine you wouldn't stand a chance doing that first time
13:52:42 <Itkovian> I fold it in halkf along the longest axis
13:52:48 <Beelsebob> yeh
13:52:51 <musasabi> We currently have smaller bags to about +5 to freezing and warm winter bags (to -18C) which are very warm :-)
13:52:54 <Itkovian> then I roll it up
13:52:57 <Beelsebob> maybe mine just has a slightly tighter bag
13:53:00 <Itkovian> haha
13:53:03 <Itkovian> yeah yeah
13:53:13 <Beelsebob> :P
13:53:19 <Itkovian> maybe your slightly less competent in it that yhou are in programming Haskell
13:53:26 <Itkovian> s/your/you're/
13:53:51 <Beelsebob> maybe
13:54:03 <Beelsebob> I've been doing this a lot longer than I have programming haskell
14:03:30 <Itkovian> hmm ...
14:08:17 <jlouis> dons: is 6.2.2 GHC support dropped from lambdabot?
14:09:12 <jlouis> my problem is that the newest hs-plugins requires GHC 6.4 and well... no support for that in OpenBSD ;)
14:09:24 <jlouis> in the official ports tree at least
14:09:43 <jlouis> So now I am hacking this picture gallery thing I should have finished in May
14:13:52 <SyntaxNinja> jlouis: ooh, a picture gallary?  I have a little program in haskell that mounts my camera and copies its contents to a directory based on today's date. you should integrate them :)
14:15:36 <icb> how do i properly quote tex commands in String?
14:16:03 <icb> while i can do a = "\frac", it complains on b = "\Longrightarrow"
14:16:33 <shrimpx> you want "\\foo"
14:18:14 <jlouis> SyntaxNinja: sounds rather nice. Mine should handle the EXIF information and JPEG resizing while building nice HTML ;)
14:18:39 <jlouis> but its not very nice yet, so I am thinking on restructuring most of the code
14:18:42 <shrimpx> jlouis: you used to hang out in #openbox, no?
14:18:57 <jlouis> shrimpx: that must have been a very very long time ago, but maybe
14:19:05 <jlouis> I think I actually did
14:19:17 <shrimpx> i found this perl script that has a bug fix by you!
14:19:28 <shrimpx> !!!
14:19:31 <shrimpx> perl?!
14:19:45 <jlouis> perl script... hehe. Where?
14:20:27 <shrimpx> http://www.cs.pdx.edu/~marius/files/code/misc/bbkeys2epist
14:20:29 <shrimpx> haha
14:20:55 <icb> \\ actuall produces \\
14:21:01 <shrimpx> icb: no
14:21:10 <shrimpx> Prelude> putStrLn "\\Longarrow"
14:21:10 <shrimpx> \Longarrow
14:21:38 <shrimpx> try putStrLn "\frac" =)
14:21:43 <icb> what's weird, then it must has something to do with ++
14:21:55 <shrimpx> it's just that ghc{i} shows you the string with backslashes
14:22:01 <jlouis> shrimpx: haha
14:22:09 <icb> ahhhh
14:22:28 <jlouis> I also have some old patches in fluxbox I think
14:22:35 <shrimpx> the good ol days
14:22:37 <icb> thanks
14:39:34 <interferon> is the craft of functional programming or the hudak text a better book to get started with haskell?
14:40:30 <ape> i think hudak is available free on the web
14:40:57 <shrimpx> imo, the craft is the vastly superior book
14:41:07 <shrimpx> but free is free :)
14:41:41 <Cale> Are you referring to SOE?
14:41:44 <jlouis> grrr, I just wanted to hack. Now I've updated programs for 2-3 hours. Hehe
14:42:06 <Cale> I didn't think that was available online.
14:42:31 <Cale> I like http://www.isi.edu/~hdaume/htut/tutorial.pdf
14:42:43 <Cale> as far as free materials go, it's pretty good
14:43:01 <Cale> I don't know too much about the non-free books.
14:45:15 <jlouis> hdaume's tutorial is one I have used at times when I needed to look something up I forgot.
14:47:28 <metaperl> interferon: i'm enjoying using Craft
14:47:40 <interferon> free is indeed free, shrimpx :)
14:47:46 <interferon> i'll take a look at hudak's book online
14:47:57 <maihem> Why does foldl (+) 0 [1..100000] have to build up a thunk ((((1+2)+3)+4)+5)... so that I must use foldl' instead?1 is not required after two is evaluated, and 2 is not required later either so the 1+2 can be done and the 1 and 2 gc'd. What am I missing that means the compiler can't make this run in constant time?
14:48:01 <interferon> are a lot of haskell folk lispers?
14:48:06 <metaperl> the free resources for haskell (besides this IRC channel, which is excellent) are poor
14:48:21 <metaperl> oh TMR is good too... but beginner-level stuff _must_ be bought.
14:48:25 <maihem> I've read the wiki page, but it doesn't say why.
14:48:40 <musasabi> maihem: because (+) is polymorphic.
14:48:42 <metaperl> interferon: I'm a professional perl programmer who enjoys the way that Haskell approaches problems
14:48:56 <musasabi> and in general the compiler cannot prove that it is strict.
14:48:57 <interferon> does hudak's book focus only on his multimedia research?
14:49:00 <metaperl> maybe one day I will be good enough to work as a haskellographer, but not for 1-3 more years
14:49:22 <metaperl> interferon: you might look at some amazon reviews of his books, but as a user of craft, I strongly recommend it
14:49:36 <maihem> musasabi, can you direct me to an example?
14:49:51 <maihem> I'll add it to the wiki once I understand it
14:49:57 <Itkovian> shapr: hmm, maybe nibro can write a summary of his thesis on HSP?
14:50:07 <interferon> metaperl: all right, thanks
14:50:20 <interferon> metaperl: i'm leaning toward craft at the moment
14:50:38 <metaperl> interferon: I'm usng Craft, and cannot say enough for it
14:51:35 <interferon> metaperl: some of the reviews i read earlier said that he didn't go over monads too deeply.  do you agree?
14:51:59 <shrimpx> the craft covers monads much better than SOE
14:52:01 <shrimpx> (imo)
14:52:07 <interferon> SOE?
14:52:10 <shrimpx> and has a generally more down-to-earth attitude toward programming
14:52:12 <metaperl> interferon: they are the last chapter I believe... when I make it to monads , there are 2 good free tutorials. One by Cale and one by nomaware
14:52:33 <shrimpx> SOE == hudak's book
14:52:43 <metaperl> interferon: the algorithms book written in Haskell is impressive but only very sharp people like autrijus can learn from such a book
14:52:58 <jlouis> maihem: foldl' is a strict version of foldl so it is forced to be strict. The compiler has an easy job there. In the general case, foldl is not strict so the strictness checker has to come to work in order to be able to run it strictly. The strictness checker doesn't always succeed even if the function can be evaluated strictly.
14:53:04 <metaperl> it's a beginner book too... for undegrads in computer science, but I found the approach to sharp for my dull mind :)
14:53:15 <tic> The Craft doesn't really cover monads at all, I thought.
14:53:24 <metaperl> tic: it does... i have the text
14:53:26 <interferon> metaperl: what book is that?
14:53:42 <tic> metaperl, The Craft of Functional Programming?
14:53:44 <metaperl> at least there is a chapter so-named... Sethi is the author... hold
14:54:25 <metaperl> tic: yes. it has a monads chapter... oops 2 sections: 18.8 and 18.9
14:54:43 <tic> :-)
14:54:54 <metaperl> interferon: http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
14:55:08 <maihem> jlouis, yes, so I gather from musasabi, but I don't understand how to tell when the compiler can determin the strictness and when it can't. Otherwise there is no point in having foldl. you may as well combine reverse and foldr to get the same behaviour.
14:55:25 <shrimpx> i remember it does some useful stuff with monads -- like showing you how to build an imperative tree traversal or some crap. that helped me :)
14:56:01 <metaperl> shrimpx: do you work at Galois?
14:56:04 <shrimpx> maihem: welcome to lazy programming
14:56:09 <shrimpx> metaperl: no
14:56:18 <jlouis> maihem: In general it depends on the compiler and the kind of strictness checker.
14:56:18 <metaperl> student at pdx? undergrad?
14:56:30 <shrimpx> metaperl: graduated in spring
14:56:36 <metaperl> congrats
14:56:40 <shrimpx> thanks
14:56:45 <metaperl> what are your plans?
14:56:47 <maihem> jlouis, so I should just pretend Haskell never had foldl?
14:56:47 <shrimpx> not much of an accomplishment =)
14:56:54 <shrimpx> metaperl: going to UW in 2 weeks
14:57:43 <jlouis> maihem: no. foldr and foldl has different orders when considering memory-space consumption
14:57:59 <jlouis> foldl being the more efficient in lazy settings
14:58:03 <maihem> but I should always use foldl' instead of foldl?
14:58:16 <jlouis> if you want the strictness enforced, yes
14:58:53 <maihem> Okay, what I want to be able to do is work out when I want the strictness enforced. Any examples that would demonstrate this?
14:59:07 <jlouis> I would consider foldl' a performance optimization to be added when profiling shows the code to be too slow in the spot of the foldl. You also have to know strict execution doesn't change the outcome
14:59:28 <musasabi> maihem: think about instance Num Foobar where a + b = someConstant
14:59:38 <maihem> I would consider it changes the whole algorithm from linear to constant space
14:59:52 <maihem> musasabi, right
15:00:13 <musasabi> now what should foldl (+) someValue [undefined :: Foobar] do ?
15:01:21 <basti_> give a type error if Foobar isn't Num, and someValue isn't Foobar.
15:01:49 <maihem> raise an exception in the IO monad describing the computation that the result of foldl (+) someValue [undefined ::Foobar] is required for
15:02:38 <shrimpx> turn off your computer and run away with your hard drive
15:02:42 <basti_> i fear that was not the answer he wanted.
15:02:56 <shrimpx> :\
15:03:21 <shrimpx> damn bottoms
15:03:32 <maihem> oh wait, should it simply be someConstant?
15:03:39 <jlouis> bingo ;
15:03:41 <jlouis> )
15:03:58 <jlouis> now, what about foldl' (+) someValue [undefined :: Foobar]
15:04:03 <musasabi> http://youzen.b2.fi/~musasabi/a.hs for an example.
15:04:11 <basti_> everything that involves undefined is undefined.
15:04:21 <basti_> except things that dont evaluate undefined
15:04:22 <shrimpx> haha
15:04:32 <shrimpx> that's a great statement about laziness
15:04:45 <basti_> :)
15:05:06 <paolo> everything that actively involves undefined is undefined
15:05:33 <maihem> shrimpx, isn't laziness just one strategy for non-strict evaluation?
15:05:45 <musasabi> That is an example why foldl != foldl' and thus the compiler is forced to create the thunks unless it can infer more specific types.
15:05:59 <paolo> @type foldl
15:06:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:06:06 <paolo> @type foldl'
15:06:08 <lambdabot> bzzt
15:06:13 <paolo> @index foldl'
15:06:14 <lambdabot> Data.List
15:06:18 <paolo> @type Data.List.foldl'
15:06:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:06:27 <shrimpx> maihem: it's call by name with sharing
15:06:30 <paolo> @libsrc Data.List
15:06:32 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
15:07:16 <paolo> -- | A strict version of 'foldl'.
15:07:18 <paolo> foldl'           :: (a -> b -> a) -> a -> [b] -> a
15:07:18 <paolo> foldl' f a []     = a
15:07:18 <paolo> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:07:22 <maihem> musasabi, thanks, so the b of a + b is Foo? foldl' tries to evaluate the undefined unnecessarily?
15:07:23 <paolo> ... it explains :-)
15:08:24 <musasabi> maihem: yes, although it is not unnecassary but in the semantics of foldl'.
15:09:16 <musasabi> The difference is something I had difficulty grasping when learning haskell.
15:10:08 <maihem> so the $! f a b inside foldl forces evaluation of both a and b rather than just forcing evaluation of f a b?
15:11:43 <maihem> I still don't see how that stops the f a b in the first recursion of foldl (ie foldl f (f a bhead) btail) from being evaluated when it is possible to do so.
15:11:50 <jlouis> maihem: http://haskell.org/hawiki/StackOverflow is a good read on folds
15:12:20 <musasabi> maihem: how does the compiler know when it is possible to do so?
15:12:35 <maihem> I read that just before asking here tonight, that led me to ask the slightly more sophisticated question than I asked at about the same time last night :)
15:13:25 <maihem> firstly, if it is an Int :) But what I was hoping somebody could explain is how come the compiler can't tell when it is possible to do so?
15:14:02 <musasabi> maihem: that reduces to strictnress analysis which does work in some cases :-)
15:14:40 <maihem> And how do I tell, because the foldl' has undesirables that I want to avoid sometimes, while foldl has undesirables that I want to avoid sometimes, and I need to be able to work out which to use, and when :/
15:15:24 <basti_> thats where voodoo comes into play
15:15:46 <maihem> (ie, foldl' evaluates things that don't need to be evaluated to perform the IO that needs to be done, and foldl doesn't evaluate things that allows constant space algorithms
15:16:00 <maihem> basti_, pleas don't say anything beginning with "unsafe"
15:16:13 <basti_> no no - no unsafe
15:16:49 * musasabi usually just writes foldl and if it shows up in profiling then go back and change it.
15:17:36 <jlouis> maihem: The thing that matters is if the foldl' ends up working on undefined values (ie infinite (tail) recursions) etc
15:18:15 <musasabi> -> sleep
15:18:29 <maihem> or if there is any undefined value present in the list, even if the function given ignores it :/
15:19:40 <musasabi> maihem: no. "if the function produces undefined values which are then discarded by future evaluations".
15:20:14 <maihem> but the example you gave me doesn't produce an undefined value does it?
15:20:33 <musasabi> yes it does.
15:20:54 <maihem> oops, missed the ", Foo" at the end of the list :) heh!
15:21:24 <maihem> I thought the arguments were given to (+) the other way around to cause the output I was seeing with foldl :)
15:21:54 <maihem> well, thanks for your help musasabi
15:22:36 <musasabi> np, good luck figuring the folds
15:24:24 <stepcut> ugh... 'dupTo fdOut stdOutput' affects 'hPutStrLn stdout "hello"' in ghci, but not in compiled applications :-/
15:32:25 * SyntaxNinja points out that profiling support in cabal is DA BOMB!
15:32:32 <SyntaxNinja> it's way better than profiling support in darcs!
15:32:42 <shapr> yay!
15:32:44 <maihem> I suppose the problem is that, when the compiler can't determine that its strictness analysis will terminate, it can't do strictness analysis.
15:33:20 <stepcut> SyntaxNinja: yeah! screw darcs and their crappy profiling!"
15:33:57 <SyntaxNinja> darcs profiling support is to cabal profiling support as dos is to zsh
15:34:18 <Igloo> Dude, darcs has done profiling since you were in diapers
15:35:06 <shrimpx> why the beef about strictness analysis anyway? haskell is lazy
15:35:08 <SyntaxNinja> Igloo:  no way! we totally had a solution way before they did, they just decided to implement it in a non-compatible and sloppy way!
15:35:08 <maihem> Um, isn't cabal for package management, while darcs is for source control? What am I missing?
15:35:10 <shrimpx> use ML =)
15:35:38 <Igloo> maihem: A pointless, contrived rivalry
15:35:52 <metaperl> blasphemy :)
15:36:07 <Igloo> shrimpx: Because strictness analysis can allow you do things much faster and in less space
15:36:43 <maihem> shrimpx, I thought laziness is just a strategy for evaluating programs written with constructs that don't carry strictness semantics
15:37:13 <SyntaxNinja> Igloo: if it's so stupid and pointless, then why don't you stop wasting valuable energy on darcs and start contributing to cabal?
15:37:28 <metaperl> basti_: your article dumped sound to midi...
15:37:36 <basti_> metaperl: is that bad?
15:37:38 <metaperl> is tempo not a part of the dumped example?
15:37:49 <basti_> csound has default tempo 60
15:37:55 <metaperl> is tempo controlled by the midi player instead of the midi file we build per your example?
15:38:04 * shapr declares that Igloo and SyntaxNinja must dual
15:38:10 <maihem> ie, C has constructs with some non-strict semantics, and laziness can be used by the compiler, but they normally do strictness analysis. C uses sequence points to "collapse" the non-strictness wave function, in Haskell it happens when you want to do IO, or use a strictness annotation
15:38:12 <Igloo> SyntaxNinja: Because I heard the leader of the cabal project is a real loser  :-þ
15:38:16 <jlouis> opposed to duel
15:38:16 <basti_> there is some control in the midi file, but the tempo issue is pretty wacko in midi
15:38:24 <Igloo> In fact, I think it was shapr who told me that
15:38:32 * Igloo walks away whistling
15:38:55 <metaperl> basti_: I see
15:38:57 * jlouis puts Igloo into the opposite category and watches SyntaxNinja come out
15:39:33 <basti_> metaperl: it should come out at 60 bpm per default, and i'm not seeing any problem there.
15:39:42 * SyntaxNinja throws shapr's new unicycle at igloo
15:40:09 <SyntaxNinja> (dm: that this event causes shapr also to hurl himself at igloo)
15:40:20 <metaperl> basti_: I need one note played every second... the Events in your example came out at 0, 0.5, 1.0, 1.5 ... how does that correspond to seconds?
15:40:21 <Igloo> shapr: Did you see that! He threw your unicycle! Your *new* one!
15:40:35 <basti_> thats every half a second
15:40:43 <metaperl> Commonmusic.sf.net (for scheme and lisp) was very precise about creating tempo - even for midi files
15:41:18 <metaperl> basti_: I am going to modify it so the event times are 0, 1,2,3 but I dont think that will play every second...
15:42:07 <basti_> i mean, i see the problem. but still, the default tempo should be 60. that is, every quarter note = 1 second.
15:42:32 <basti_> i didn't try it, though.
15:43:22 <Igloo> Grr. RFC 2045 refers to SPACE in 822. 2822 supercedes 822 and reexports SP from 2234. So what am I meant to call the function?
15:43:36 <shapr> Igloo: Wow, that's cruel
15:43:36 <Igloo> I swear they're deliberately trying to make this as twisted as possible
15:44:05 <SyntaxNinja> shapr: I was just trying to get you to do a trick.
15:44:51 * shapr throws monads at SyntaxNinja and Igloo 
15:46:26 * jlouis fires arrows at Igloo and SyntaxNinja 
15:46:46 * SyntaxNinja catches arrows and in a thunk. stops evaluation by throwing an exception at Igloo
15:47:32 * jlouis adds undefined to SyntaxNinja 
15:47:44 * SyntaxNinja evaluates jlouis
15:47:44 <jlouis> Igloo! Evaluate the thunk!
15:48:16 <jlouis> repeats "Igloo! Evaluate the thunk!" infinitely
15:48:47 <Igloo> Gnkk. CHAR changes definition between RFCs 822 and 2822.
15:48:49 <jlouis> ok, got hit by a SIGSLEEP. Later all
15:48:57 <paolo> 'night jlouis
15:53:10 <SyntaxNinja> l8r
15:57:47 <ehuber> hihi
16:00:15 <interferon> xb
16:01:51 <shapr> What's the best Go client in debian/unstable? cgoban?
16:02:18 <paolo> shapr, http://kgs.kiseido.com/ CGoban2
16:02:43 <paolo> I think it doesn't ship with debian, but you could press "Play Go Now!" and have fun anyway.
16:03:01 <shapr> I don't have Java installed.
16:03:34 <shapr> Will cgoban1 connect to kgs?
16:03:47 <paolo> Nope
16:03:57 <paolo> KGS has its proprietary client :-(
16:04:23 <shapr> suck
16:04:25 <paolo> cgoban1 will connect you to IGS/NNGS I think.
16:04:47 <paolo> But KGS is a better place to learn, I think.  On the other server there isn't as much discussion.
16:05:14 <paolo> Because people on IGS are mostly oriental and don't know english well - and they also seem to not like to talk :-)
16:08:05 <shapr> Ok
16:09:11 <paolo> There is no way to you for having a java vm on your machine?
16:09:23 <shapr> Not since I wrote Java for a few years :-)
16:09:43 <paolo> Aww :-)
16:13:24 <paolo> shapr, don't let the proprietary software stop you from learning Go, tough.  I could try to go on IGS and teach you the basics if you want.
16:14:41 <shapr> I played it once before.
16:16:14 * Beelsebob burps
16:16:56 * shapr ribbits
16:17:07 <Beelsebob> how goes shapr?
16:17:28 <shapr> Trying to find some multiplayer games that work on both Linux and Windows.
16:17:33 <shapr> That aren't FPS.
16:17:44 <wilx> NWN.
16:17:53 <shapr> Free/OSS?
16:17:56 <Beelsebob> was about to say that
16:17:58 <Beelsebob> no
16:18:03 <shapr> Something I can just grab.
16:18:07 <wilx> Ah.
16:18:08 <wilx> Free.
16:18:14 <wilx> Free isn't always good :)
16:18:17 <wilx> Especially for games :)
16:21:16 <Philippa> games require content. Content is not generally fun to produce at high quality
18:10:32 <dons> @seen jlouis
18:10:33 <lambdabot> jlouis is in #haskell. Last spoke 2 hours, 21 minutes and 43 seconds
18:10:33 <lambdabot> ago.
18:11:02 <dons> jlouis, support for 6.2.2 lambdabot may have rotted a little bit, but I'll have a look
18:32:02 <dons> hi TheHunter
18:33:30 <paolo> @index CForeign
18:33:32 <lambdabot> bzzt
18:33:38 <paolo> Uh-oh.
18:33:59 <paolo> From c2hs sources: import CForeign (CInt)
18:34:08 <paolo> @docs Foreign.C
18:34:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.html
18:34:51 <paolo> @index CInt
18:34:53 <lambdabot> Foreign.C.Types, Foreign.C
18:35:30 <TheHunter> hey dons
18:35:32 <dons> CForeign is an old-style name
18:35:50 <paolo> Argh, neither Foreign nor Foreign.C seem to work...
18:36:02 <shapr> Man, I want to get Greg Buchholz, Dave Menendez, Derek Elkins and a few other people together to write a statically typed concatenative language halfway between Joy and Haskell.
18:36:14 <dons> paolo, what are you looking for?
18:36:36 * shapr looks at musasabi 
18:36:42 <paolo> dons: building last c2hs - it breaks on that thing: he searches for CInt
18:37:08 <dons> oh. I personally know the author, so if you want to research the bug a bit, I can pass it on
18:37:29 <paolo> dons: sure, thank you.
18:37:32 <dons> CInt lives in Foreign.C.Types, I thought
18:37:42 <paolo> So it seems
18:37:59 <paolo> This should work, right?  import Foreign  (toBool,CInt)
18:38:01 <dons> paolo, you building the brand new release of c2hs?
18:38:09 <paolo> dons: yes 0.14.3
18:38:11 <dons> it was released yesterday, or the day before?
18:38:20 <paolo> The latter
18:38:51 <dons> CIint isn't in Foreign, it seems
18:39:04 <dons> Prelude Foreign Foreign.C.Types> :k CInt
18:39:04 <dons> CInt :: *
18:39:21 <dons> what ghc are you using? how does the bug appear?
18:39:21 <paolo> import Foreign (toBool)
18:39:35 <paolo> import Foreign.C.Types (CInt)
18:40:32 <paolo> It appears when I do runghc Setup.hs build
18:40:48 <paolo> (I'm xerox btw)
18:41:09 <dons> shapr, what do you think of my idea that the unix shell utilities: head,tail,grep,cut,tr,uniq,paste and sed make up an ad hoc Data.List library
18:41:22 <dons> and that we should instead provide a real unix sh cmd set based on List
18:41:29 <shapr> um
18:41:31 <dons> paolo, I know you're xerox!!
18:41:43 <shapr> dons: that's awesome!
18:41:47 <paolo> OK, just to make sure ;)
18:41:52 <shapr> I've wanted that a bunch of times now that I think about it.
18:42:14 <dons> head,tail==take,drop. grep == filter, uniq==nub, cut==!!, tr is a map,  so is sed. paste is zip.
18:42:24 <paolo> dons: the problems is that it doesn't find "Foreign" itself.
18:42:26 <shapr> dons: What about a shell that's GHCi with utilities?
18:42:26 <dons> oh, and wc is length/fold
18:42:38 <dons> that's the more heavy-weight option
18:42:54 <shapr> That one would appeal to me most because I'd have all my spiffy tools handy.
18:43:08 * shapr thinks
18:43:12 <dons> it really needs to be able to mix both haskell tools and unix
18:43:17 <shapr> Yeah, exactly.
18:43:21 <shapr> eshell does that in emacs.
18:43:33 <shapr> You get cool tricks like redirecting to and from emacs buffers.
18:43:45 <dons> another issue is that really all data should be in read/show form. however we'd have to be able to deal with data where listts are \n separated lines, for example
18:44:01 <dons> so: take 4 f == head -4 f
18:44:02 <shapr> And elisp functions are transparently shell commands, and can pipe data to/from buffers or other functions/shell commands.
18:44:06 <paolo> You talked about this redirecting other times, what is the syntax?
18:44:40 <shapr> Didn't Oleg make unix shell pipes an instance of the Monad typeclass?
18:44:48 <dons> another issue is that both grep and sed can index a list based on a regex.
18:44:56 <shapr> ?
18:44:57 <dons> can't do that easily in List atm
18:45:08 <shapr> Sounds like HaRP
18:45:36 <dons> if a file is a [String], then: cut -fn gives you a column, and sed -n np gives you a row, by and index
18:45:57 <dons> however, we can also index based on a patter: grep foo or sed /.*\(foo\)/\1/
18:46:04 <shapr> Isn't that if file is a [[String]] ?
18:46:09 <dons> so I would like List utilities to index based on patterns
18:46:25 <shapr> Is that like filter?
18:46:36 <shapr> How does this fit into \sed ?
18:47:00 <dons> I  am thinking \sed might be the way to do some of the regex based stuff in a more lambdaish way
18:47:17 <dons> > Isn't that if file is a [[String]] ??
18:47:45 <dons> oh, you mean like [ [a,b,c], [d,e,f] ]
18:47:56 <dons> i.e. rows are say whitespace separated
18:48:42 <dons> anyway, I think I'll start by creating tiny binary wrappers over the common List functions, and then consider regex tools
18:48:59 <shapr> Sounds nifty
18:49:40 <dons> so we can say: cat f | take 20 | map "s/a/b" | ..
18:50:58 <Igloo> map "s/a/b"? Sheesh, you're almost as bad as PHP with its lambdas as strings  :-)
18:51:19 <dons> ok, so I made that up on the spot.
18:51:23 <paolo> :)
18:52:02 <dons> it's just that sed should be called map, I think. and sed s/a/b/g is map map
18:52:39 <shapr> yup
18:53:08 <paolo> Why is it map map?  Maybe you mean something particular with a and b?
18:53:39 <shapr> nah, /g
18:53:55 <paolo> Got it.
18:53:56 <shapr> that means replace every 'a' on one line with 'b'
18:54:11 <shapr> and sed itself work on every line in the file.
18:54:52 <dons> then there's folds. not many in unix for some reason.
18:55:04 <paolo> tr?
18:55:13 <dons> nah, tr is a map
18:55:14 <paolo> nah..
18:55:24 <paolo> wc, as you said before.
18:55:52 <shapr> Most pipelines are folds.
18:56:04 <shapr> or are they?
18:56:05 <Igloo> yes is an unfold. Not many of them in Haskell  :-)
18:56:13 <dons> hehe
18:56:24 <paolo> I didn't get it :-)
18:57:27 <Igloo> It wasn't really a joke
18:57:34 <paolo> dons: hmm, any idea about that Foreign module?  I can load it from ghci, Setup.hs build can't find it, instead.
18:57:43 <paolo> Igloo: what is an unfold exactly?
18:57:54 <Igloo> The opposite of a fold
18:57:56 <dons> I'm not sure who this is due to, but unix sh cmds really illustrate that all programming languages of sufficient complexity approach haskell in the limit
18:58:25 <heatsink> paolo: search for Foreign.hi
18:58:42 <Igloo> yes = unlines $ unfoldr (\x -> Just (x, x)) "yes"
18:59:01 <metaperl> perl was developed because Unix pipes were too small, perl Larry Wall in Issue 1 of the Perl Journal
18:59:26 <metaperl> and the shell as a database is a poor representation for large datasets, hence SQL databases with binary indexed keys... am I off-base here?
18:59:42 <dons> lovely Igloo
18:59:49 <paolo> heatsink: /usr/lib/ghc-6.4.1.20050801/imports/CForeign.hi /usr/lib/ghc-6.4.1.20050801/imports/Foreign.hi
19:00:20 <paolo> @type unfoldr
19:00:21 <heatsink> paolo: what does ghc-pkg describe base say?
19:00:21 <lambdabot> bzzt
19:00:30 <Igloo> People should write more unfolds. I'll have to keep an eye out for ways to squeeze one into a MIME parser
19:00:37 <heatsink> @type List.unfoldr
19:00:39 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
19:00:43 <paolo> heatsink: want me to paste it in pm?
19:01:03 <heatsink> just the library-dirs: line
19:01:12 <paolo> library-dirs: /usr/lib/ghc-6.4.1.20050801
19:01:12 <dons> we can start a campain for the underappreciated unfold
19:01:33 <dons> campaign
19:01:34 <shapr> I'd like to do that, but I'd have to understand it first.
19:01:38 <heatsink> well, that's where it's supposed to be. I dunno.
19:01:43 * paolo is with shapr 
19:01:51 <paolo> heatsink: thank you anyway :-)
19:02:15 <heatsink> unfold generates a list from an initial value and a function (current value -> next value)
19:02:23 <Igloo> Not even ghc uses it
19:02:27 <dons> huh
19:02:53 <heatsink> hmm... more like (current state -> maybe (value, next state))
19:03:09 <shapr> Sounds like Template Haskell
19:04:05 <TheHunter> unfoldr is pretty much what in iterator in an imperative language is.
19:04:22 <shapr> Yeah, good point.
19:04:58 <dons> yeah. so sh' seq and jot == unfoldr (\x -> Just (x, x+1)) 1
19:05:58 <dons> the unix shell -- the world's most successful functional programming language
19:06:08 <paolo> @plugs let powersOfTwo = unfoldr (\x -> Just (x,x*2)) 2 in take 10 powersOfTwo
19:06:10 <lambdabot> [2,4,8,16,32,64,128,256,512,1024]
19:06:36 <shapr> Looks like a list comp.
19:06:44 <shapr> How's unfold different from a list comp?
19:06:52 <paolo> @pl \x -> Just (x,x*2)
19:06:53 <lambdabot> Just . ap (,) (2 *)
19:07:10 <dons> a list comprehension is a map though, it needs a generator
19:07:21 <dons> unfoldr is the generator
19:07:24 <shapr> oh
19:07:39 <lispy_> @type unfoldr
19:07:40 <paolo> I was thinking "you don't feed the unfoldr as you need to feed a list comprehension with lists"
19:07:41 <lambdabot> bzzt
19:07:43 <shapr> How's unfold related to iterate then?
19:07:52 <dons> TheHunter, I think you need to put more unfolds into @pl ;)
19:08:06 <TheHunter> iterate f = unfoldr (\x -> Just (x, f x))
19:08:21 <lispy_> @hoogle unfoldr
19:08:22 * shapr thinks about that.
19:08:23 <lambdabot> List.unfoldr :: ((a -> (Maybe (b, a))) -> a -> [b])
19:08:31 <TheHunter> dons, like what?
19:08:41 <paolo> We will be observing a raise of the number of unfoldrs in Haskell code :-)
19:08:47 <shapr> TheHunter: Thanks, I'll meditate on that FP koan :-)
19:09:01 <lispy_> why is it called unfoldr?
19:09:02 <dons> ok. so maybe unfoldr is too verbose for @pl
19:09:10 <dons> it is the dual of foldr
19:09:27 <lispy_> dual in which sense?
19:09:35 <shapr> Hm, now that I think of it, there are a bunch of times I've wanted a 'limited iterate' and unfold sounds like just the thing.
19:09:38 <lispy_> (I don't get it yet)
19:09:42 <dons> the logical sense. let me see..
19:09:59 <lispy_> @type foldr
19:10:00 <Igloo> foldr takes a list to a thing. unfoldr takes a thing to a list.
19:10:01 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
19:10:01 <shapr> Hey, maybe I can finally finish lazy key promotion in my bayesian spam filter code.
19:10:26 <dons> unfoldr can undo a fold, for example (sometimes)
19:10:30 * paolo growls at c2hs
19:11:39 <lispy_> so , how does it unfold it?
19:11:47 <lispy_> i guess i don't understand why it's named unfold
19:12:04 <dons> unfoldr f' (foldr f z xs) == xs
19:12:10 <Igloo> Do you understand why fold is named fold?
19:12:26 <lispy_> Igloo: yeah, it folds a list down to one value
19:12:50 <lispy_> dons: so how are f' and f related?
19:13:04 <Igloo> Given that and my previous line, I don't see why you can't see why unfold is so named, then
19:13:31 <TheHunter> grrr
19:13:34 <paolo> lispy: f' is the inverse function of f
19:14:14 <TheHunter> @type \f' f z xs -> Data.List.unfoldr f' (foldr f z xs) == xs
19:14:16 <lambdabot> forall b a.
19:14:16 <lambdabot> (Eq [a]) =>
19:14:16 <lambdabot> (b -> Maybe (a, b)) -> (a -> b -> b) -> b -> [a] -> Bool
19:14:18 <paolo> I don't know how to track down the "bug" into the Cabal process of building...
19:14:47 <dons> so it seems to me we have HsShellScript for doing shell in Haskell, but what is missing is a way to do haskell in shell.
19:15:13 <dons> so should list functions become individual binaries, or maybe shell alises to runhaskell calls. hmm
19:16:13 * paolo looks at the dons isomorphism and grins
19:16:23 <heatsink> are you writing a new shell?
19:16:42 <lispy_> f' isn't the inverse of f in the normal way
19:16:51 <lispy_> is it?
19:17:04 <dons> heatsink, nope. i'm writing a suite of wrappers over List functions, so we can use Haskell functions as shell utilites
19:17:14 <heatsink> can't be since f ain't one-to-one
19:17:21 <lispy_> Igloo: to answer you question, it's because i don't understand f'
19:17:48 <paolo> GHC says "use -v to see a list of the files searched for", do you know how to add it to a Cabal-building package?
19:18:08 <Igloo> It's a bit like the inverse if you wave your arms vigorously and shout "Look! A Mongoose!"
19:18:34 <lispy_> in this example, what would be a natural function to use for f'?  unfoldr f' (foldr (+) 0 xs)
19:18:38 <heatsink> XD
19:18:57 <Igloo> There is no f' if you want that to be == id
19:18:59 <paolo> It isn't unfoldale
19:19:02 <lispy_> and let xs = [1..10]
19:19:05 <paolo> blargh, I can't type.
19:19:30 <lispy_> what would be a more natural example then?
19:20:05 <lispy_> TheHunter: said, iterate f = unfoldr (\x -> Just (x, f x))
19:20:25 <lispy_> oh i see
19:20:37 <lispy_> so \x -> Just (x, f x) is what dons meant by generator
19:21:04 <TheHunter> hmm, maybe the identity follows from |mabye (uncurry f) (f' b) z === b|?
19:21:47 <paolo> s/mabye/Just/ ?
19:22:07 <TheHunter> @type maybe
19:22:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:22:15 <paolo> Didn't know, thank you.
19:22:35 <paolo> Does it go backwards in time? D'oh.
19:22:46 <TheHunter> so I should say |maybe z (uncurry f) (f' b) === b|
19:23:43 <paolo> that maybe is sort of >>=, right?
19:23:54 <lispy_> @type (>>=)
19:23:56 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m
19:23:56 <lambdabot> b
19:24:00 <TheHunter> not at all.
19:24:05 <TheHunter> it's Maybe's fold.
19:24:25 <paolo> Uhm
19:24:42 <paolo> I got fooled by the "(a -> b) -> Maybe a" part
19:24:49 <lispy_> @eval maybe (+1) Nothing
19:24:50 <lambdabot> 29:
19:24:50 <lambdabot>   Expecting a function type, but found `Maybe a'
19:24:50 <lambdabot>   Expected type: a -> a1 -> a1
19:24:50 <lambdabot>   Inferred type: Maybe a2
19:24:56 <paolo> @type foldr
19:24:58 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
19:25:07 <paolo> @type maybe
19:25:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:25:49 <lispy_> @type maybe (+1)
19:25:50 <lambdabot> forall a a1. (Num a) => (a1 -> a -> a) -> Maybe a1 -> a -> a
19:25:52 <paolo> The first argument is what is returned if the third is Nothing?
19:26:04 <TheHunter> yes.
19:26:06 <paolo> Cool.
19:26:11 <lispy_> oh, i didn't see the b
19:26:26 <lispy_> @eval maybe 100 (+1) Nothing
19:26:28 <lambdabot> 100
19:26:34 <paolo> I happen to understand Haskell better at four o'clock in the morning.
19:26:43 <ape> the time is 5:30 am
19:26:52 <TheHunter> @timein Rome
19:26:55 <lambdabot>  Friday, August 12, 2005 at 4:27:58 AM CEST
19:26:59 <shapr> @timein Stockholm
19:27:00 <lispy_> @time in LA
19:27:01 <lambdabot>  Friday, August 12, 2005 at 4:28:03 AM CEST
19:27:20 <paolo> shapr: you're ahead of one minute!  how is it going in the future?
19:27:20 <lispy_> @timein Los Angeles
19:27:22 <lambdabot>  Thursday, August 11, 2005 at 7:28:25 PM PDT
19:27:43 <Korollary> what the
19:27:46 <paolo> err, 5 secs in fact
19:27:47 <ape> @timein Jerusalem
19:27:49 <lambdabot>  Friday, August 12, 2005 at 5:28:52 AM
19:28:31 * paolo screams at c2hs again
19:29:29 <lispy_> dons: how would we use haskell from the shell?
19:29:38 <lispy_> dons: ghc -e 'some haskell code' ;)
19:30:06 <dons> oh, you can already do all that. but I want first class shell utilities
19:30:40 <dons> that just happen to run head,tail,take,drop,map,fold,zip,sort,nub,intersperse
19:30:48 <heatsink> Is there a shell equivalent of 'let'?
19:30:49 <paolo> Could somebody try building c2hs 0.14.3 ?
19:30:56 <lispy_> dons: i've thought about this with lisp before, and you can use clisp as your shell.  But at least with clisp it was unpleasant because the default was lisp, but in reality when you use a shell 90% of the time you just want to navigate and run stuff
19:30:57 <dons> heatsink, x=foo
19:31:02 <paolo> heatsink: yup foo=x
19:31:16 <paolo> dons: haha, I'm your f' :-P
19:31:17 <dons> paolo, heh
19:31:18 <heatsink> That's eager, though
19:31:31 <heatsink> I meant more like assigning a name to the output of a pipe
19:31:45 <dons> oh, you want a thunk. > foo
19:31:46 <paolo> fifo/lifo ?
19:32:14 <dons> lispy_, right. so we should stick these in the shell. they'll just be smarter shell utils
19:32:42 <dons> cat f | map intersperse | sort | unzip ... fun fun fun :)
19:33:01 <lispy_> @type intersperse
19:33:03 <lambdabot> bzzt
19:33:04 <paolo> map intersperse sounds fun
19:33:10 <paolo> @type List.intersperse
19:33:12 <lambdabot> forall a. a -> [a] -> [a]
19:33:27 <lispy_> @eval List.intersperse [1..4]
19:33:27 <paolo> @plugs intersperse 'Z' "zzzzz"
19:33:28 <lambdabot> <Plugins.Eval>:1:12:
19:33:28 <lambdabot>   No instance for (Show ([[a]] -> [[a]]))
19:33:28 <lambdabot>   arising from use of `show'
19:33:29 <lambdabot> "zZzZzZzZz"
19:33:37 <lispy_> man, i can't read types today
19:34:00 <Korollary> the types are not always enough anyways.
19:34:03 <heatsink> @eval intersperse 'a' "bnns"
19:34:05 <lambdabot> "bananas"
19:34:18 <lispy_> heatsink: heh, cute
19:34:21 <heatsink> :)
19:34:52 <paolo> @pl \x -> you x $ \y -> off y
19:34:53 <lambdabot> flip you off
19:34:57 <Korollary> hah
19:34:59 <lispy_> heh
19:35:06 <lispy_> paolo: where did you get that one ;)
19:35:10 <paolo> © lisppy_
19:35:44 <lispy_> paolo: you're xerox right?
19:35:47 <paolo> my code and your creativity :-)
19:35:48 <paolo> Yup
19:36:02 <paolo> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/c2hs-0.14.3.tar.gz
19:36:08 <paolo> ^- anybody could try to build it?
19:36:57 <TheHunter> iirc, when I last tried to build it, I failed miserably, but then it turned out it wasn't needed for hs-plugins.
19:37:27 <lispy_> dons: so i only have two other objections to that. 1) cat would have to return a list of lines for that to work the way you expect 2) people might object if the shell shadows too many existing things
19:37:28 <paolo> .2 compiled last time I tried, hmpf!
19:38:00 <lispy_> dons: otherwise it's pretty cool
19:40:05 <lispy_> i think ordinary people object pretty strongly to the level of type checking that haskell does.
19:40:12 <lispy_> otherwise it would be interesting to add types to sh
19:41:06 <sh10151> why do people object to type checking?
19:41:40 <lispy_> sh10151: the objection is commonly uses phrases like "straight jacket"
19:41:44 <dons> lispy, cat does return a list of (\n separated) lines
19:42:02 <dons> secondly, yes. shadowing is a problem. maybe they should  all be hzip hfold hsort etc
19:42:02 <sh10151> but...
19:42:14 <lispy_> dons: so your shell would use \n to separate elements of a string list?
19:42:43 <dons> well, it has to, otherwise everything would have to be in Haskell Read/Show notation
19:42:53 <dons> more likely, you get to specify delimiters
19:43:20 <lispy_> sh10151: to defend haskell style typing here, you'd be preaching to the choir.  But the object does seem to happen quite often when i mention haskell to non-haskell programmers :)
19:43:21 <dons> so Hsakell uses [] and , but we'd probably have \n and \s* by default
19:43:39 <sh10151> but how is a poorly typed program going to get anything done? :)
19:43:49 <Korollary> sheer luck
19:43:59 <sh10151> i can see complaining about java-style keyboarding exercises..
19:44:24 <lispy_> dons: what is \s*?
19:45:01 <dons> regex for whitespace 0 or more times. (so it should actually be \s+)
19:45:18 <lispy_> dons: ah
19:45:44 <lispy_> i'd like PATH to be more powerful
19:45:58 <lispy_> for example if it took a list of regular expressions instead of a list of directories
19:46:48 * paolo falls back to 0.14.2 ...
19:47:03 <lispy_> paolo: is it in darcs?
19:47:17 <lispy_> paolo: if so you could do |darcs trackdown "make"|
19:47:27 <lispy_> and then find the first version that builds :)
19:47:28 <paolo> I have no darcs here, sigh.
19:47:55 <paolo> Gee .2 doesn't compile too, maybe that's a problem of my installation.
19:50:45 <dons> paolo, can you send me an email of the problem, and I'll talk to Manuel about it in an hour or so
19:51:02 <paolo> dons: OK, writing it
19:53:40 * dons >>= out and about
19:53:44 * Lunar^ can't agree more with http://www.mail-archive.com/haskell@haskell.org/msg17020.html
19:54:34 <TheHunter> what's with the "n=" in front of usernames?
19:54:52 <Guerin> not identified
19:54:57 <Guerin> as in
19:55:00 <Guerin> no identd running
19:55:28 <TheHunter> omg, why would anybody would have an identd running?
19:55:47 <Guerin> hence why people are all n=
19:56:09 <lispy_> and how many people would bother to open up a port on their nat/firewall for identd
19:56:26 <TheHunter> what's N= ?
19:56:38 <Guerin> same, i think
19:56:42 <Guerin> not sure about that
19:57:14 <lispy_> it would be more useful to show if they were logged in via nickserv
19:57:49 <lispy_> but i guess freenode already has a system for that
19:58:16 <lispy_> time to switch to oftc i guess ;)
19:58:33 <paolo> dons: sent
19:58:39 <TheHunter> no netsplits and random disconnects there?
19:59:06 <lispy_> TheHunter: no, it's still an irc server ;)
19:59:11 <lispy_> actually i don't know how stable they are
19:59:58 * paolo passed some time on silc - very stable IIRC
20:00:10 <lispy_> smooth as....
20:01:45 <paolo> It's probably early enough to get some sleep.
20:01:59 <lispy_> it's only 20:00 here
20:02:07 <paolo> dons: mail me anything if you happen to know some answers :) Thank you.
20:02:13 <paolo> Goodnight folks.
20:02:18 <lispy_> 'night
20:02:19 <TheHunter> probably, yes. Good night.
20:02:24 <Cale> why do so many IRC networks seem to connect up their servers in a hub-and-spoke topology?
20:02:38 <Cale> or are they not, and I'm missing something?
20:02:39 <ape> hm... already past sunrise here :=
20:02:43 <vegai> paolo: I've been thinking about a binding for the silc toolkit
20:03:13 <lispy_> Cale: they like bikes?
20:03:16 <Cale> heh
20:05:04 <Cale> It would seem to me that something with a vertex connectivity of at least 2 would be appropriate.
20:05:51 <lispy_> i've learned a lot from the NeHe tuts, for example, spinning cubes wouldn't make good deathmatch opponents
20:05:58 <Cale> heh
20:06:08 <lispy_> no really, it tells you that :)
20:06:16 <Cale> hey, maybe they would...
20:06:39 <lispy_> yeah, i have to admit, it seemed like a challenge and i'm tempted to try it ;)
20:06:43 <ehuber> sharp edges
20:06:51 <ehuber> infinitely sharp
20:06:56 <Cale> if there was some physical simulation, a spinning cube might be quite a formidable opponent
20:06:58 <ehuber> can kiss your ass goodbye
20:07:17 <lispy_> Cale: yeah, specially if all you had was a gun and it was made of steel
20:07:50 <lispy_> with a rocket launcher things could be different....
20:09:21 <lispy_> does identd prove anything?
20:11:04 <Cale> identd seems stupid to me
20:11:28 <Cale> I suppose it means something on multi-user machines with respectable sysadmins
20:12:28 <lispy_> so it means something on freeshell and that's it? ;)
20:12:42 <Cale> heh
20:13:24 <Lemmih> Good morning, #haskell.
20:13:59 <lispy_> Lemmih: hi
20:14:14 <Cale> It basically only means something when the user doesn't have control over it. In those cases, it can be used to filter out users on multi-user machines without filtering the machine as a whole.
20:14:32 <metaperl> Lemmih: good morning (good night here)
20:14:51 <metaperl> Lemmih: have you met Oejet in person?
20:15:11 <Cale> or to refer to users with a specific ident when a sysadmin is contacted.
20:15:46 <Cale> but when most people are connecting from home machines and running their own ident servers it's less meaningful
20:15:57 <Lemmih> metaperl: Nope.
20:16:32 <lament> so basically
20:16:38 <lament> ident is dumb
20:16:41 <Lemmih> But chances are he's a guy.
20:16:49 <lament> and has been dumb for the past 7 years or so
20:22:49 <TheHunter> the i= is a nice way to find out who potentially doesn't have a firewall running.
20:25:10 <lispy_> @type hGetContents
20:25:11 <lambdabot> bzzt
20:25:19 <lispy_> @type System.IO.hGetContents
20:25:21 <lambdabot> GHC.IOBase.Handle -> IO String
20:26:29 <lispy_> @hoogle GHC.IOBase.Handle -> IO [String]
20:26:30 <lambdabot> No matches, try a more general search
20:26:37 <lispy_> @hoogle a -> IO [String]
20:26:38 <lambdabot> Prelude.ioError :: (IOError -> (IO a))
20:26:39 <lambdabot> System.exitWith :: (ExitCode -> (IO a))
20:26:39 <lambdabot> Prelude.readIO :: Read a => (String -> (IO a))
20:27:03 <lispy_> hmm...those aren't really relevant...
20:28:07 <lispy_> @type split
20:28:09 <lambdabot> bzzt
20:28:12 <lispy_> @type break
20:28:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:28:42 <TheHunter> that being said, SamB, are you running some kind of honeynet?
20:28:54 <lispy_> @eval break (=='\n') "This is a \nTest\nso there"
20:28:56 <lambdabot> ("This is a ","\nTest\nso there")
20:34:53 <lament> TheHunter: are you nmaping him or sometihng?
20:36:09 <TheHunter> hope he doesn't mind..
20:39:36 <lispy_> oh, dear hGetLine returns an exception at end of file
20:40:17 * TheHunter realizes he's never nmapped himself in order to check if his firewall is working...
20:40:21 <lispy> which makes it a pain to use
20:41:19 <TheHunter> lispy, do you know what happens if you write to a closed handle?
20:41:38 <lispy> TheHunter: i'm guessing an exception
20:41:45 <TheHunter> you wish.
20:42:00 <TheHunter> unless you ignore SIGPIPE, the program crashes instantly.
20:42:07 <lispy> ouch
20:42:14 <lispy> why would they design it like that?
20:42:32 <lispy> so how do i handle this EOF exception?
20:42:45 <lispy> why not just make hGetLine return IO (Maybe String)
20:43:01 <lispy> or Maybe (IO String)
20:43:20 <lament> TheHunter: be sure to nmap yourself from the outside
20:43:25 <Cale> you could catch the error and do that, since it's IO anyway
20:43:25 <lispy> I have no idea how to deal with exceptions
20:43:38 <TheHunter> @index try
20:43:39 <lambdabot> Control.Exception, System.IO.Error, Text.ParserCombinators.Parsec.
20:43:39 <lambdabot> Prim, Text.ParserCombinators.Parsec
20:43:42 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
20:43:47 <TheHunter> @type Control.Exception.try
20:43:49 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
20:44:07 <lispy> @type Either
20:44:08 <lambdabot> bzzt
20:47:14 <lispy> @type unless
20:47:16 <lambdabot> bzzt
20:47:21 <lispy> @type until
20:47:22 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:47:34 <TheHunter> @type Left `either` Right
20:47:36 <lambdabot> forall b a. Either a b -> Either a b
20:47:44 <TheHunter> @type Control.Monad.unless
20:47:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:47:58 <lispy> unless was a typo, i meant until ;)
20:48:24 <Cale> tryJust ioErrors (hGetLine h)
20:49:04 <Cale> will return (Right str) with the line if successful, and (Left err) with the IOError if it fails
20:50:24 <lispy> geez, it's probabyl just a lot easier to map (break (=='\n')) =<< hGetContent h
20:50:42 <lispy> but that's not right either
20:50:54 <TheHunter> lament, does that mean there's an open port besides ssh on my box?
20:50:58 <lispy> @type map (break (=='\n'))
20:50:59 <lambdabot> [[Char]] -> [([Char], [Char])]
20:51:04 <Cale> you're trying to get the lines of the file?
20:51:11 <lispy> Cale: yup
20:51:22 <TheHunter> @type lines
20:51:22 <Cale> cs <- hGetContents hdl
20:51:24 <lambdabot> String -> [String]
20:51:25 <Cale> lines cs
20:52:07 <lispy> @type (\h -> hGetContents h >>= lines)
20:52:08 <lambdabot> bzzt
20:52:09 <Cale> just don't close the file before you use the lines
20:52:20 <TheHunter> @type fmap lines . hGetContents
20:52:21 <lambdabot> bzzt
20:52:30 <TheHunter> @type fmap lines . System.IO.hGetContents
20:52:32 <lambdabot> GHC.IOBase.Handle -> IO [String]
20:52:56 <lispy> Cale: what about evaluaate?
20:53:11 <lispy> @index eval
20:53:12 <lambdabot> bzzt
20:53:16 <lispy> @index evaluate
20:53:16 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
20:53:31 <lispy> @type Control.Exception.evaluate
20:53:32 <lambdabot> forall a. a -> IO a
20:53:57 <TheHunter> @type Control.Exception.evaluate . length
20:53:58 <lambdabot> forall a. [a] -> IO Int
20:54:01 <Cale> well, you'd probably just use let
20:54:11 <Cale> let ls = lines cs
20:54:19 <Cale> or what TheHunter suggested
20:54:45 <TheHunter> that will read the handle at once and keep the contents in memory.
20:54:45 <lispy> i can't just use evaluate on the result of lines?
20:55:03 <Cale> well, you could, but I don't know why you'd want to
20:55:30 <Cale> the point isn't to ensure that pure computation is run, it's just to get the lines
20:55:39 <TheHunter> evaluate [1, _|_] === return [1, _|_]
20:56:04 <lispy> TheHunter: er?
20:56:23 <TheHunter> you want to use evaluate to force the handle to be closed?
20:56:39 <lispy> no
20:56:50 <TheHunter> then forget what I said and don't use evaluate.
20:56:50 <lispy> just to force the file to be read and converted to lines
20:57:41 <TheHunter> the question you have to ask yourself is if that should happen immediately or lazily.
20:58:24 <lispy> TheHunter: I don't care as long as my program reads the data and usesit
20:58:54 <TheHunter> ok, no evaluate then.
20:59:41 <Cale> lispy: just use the list produced by hGetContents and lines, and it will read the values out of the file as needed, but you need to keep the handle open
21:00:22 <lispy> Cale: okay, I won't even use closeFile
21:00:22 <Cale> (just don't hClose it until you can be sure that you've outputted whatever results you were going to use from that file)
21:00:56 <lispy> this is for a simple nehe tut, letting the os clean up is prefectly fine :)
21:01:05 <Cale> It would be nice to have an antidote for unsafeInterleaveIO
21:01:29 <Cale> I suppose evaluate does that somewhat.
21:02:02 <Cale> You could  mapM evaluate ls
21:02:05 <Cale> and then hClose
21:02:36 <Cale> which would force the file to be read completely
21:03:34 <TheHunter> doesn't hGetContents close the handle automatically?
21:04:11 <Cale> I think it just semi-closes it
21:04:29 <Cale> yeah
21:04:46 <TheHunter> but that means it closes it when it hits eof, rihgt?
21:04:52 <Cale> oh
21:04:53 <Cale> yes
21:04:55 <Cale> sorry
21:05:09 <Cale> when you evaluate the last cell, it should close the handle for you
21:05:43 <lispy> @type (\h -> IO.hGetContents h >>= lines)
21:05:44 <lambdabot> bzzt
21:05:56 <lispy> @type (\h -> System.IO.hGetContents h >>= lines)
21:05:58 <lambdabot> bzzt
21:06:05 <lispy> so that really is a type error i guess
21:06:15 <TheHunter> @type (\h -> IO.hGetContents h >>= return . lines)
21:06:16 <Cale> @type (\h -> System.IO.hGetContents h >>= return . lines)
21:06:17 <lambdabot> GHC.IOBase.Handle -> IO [String]
21:06:17 <lambdabot> GHC.IOBase.Handle -> IO [String]
21:06:32 <TheHunter> @pl \h -> hGetContents h >>= return . lines
21:06:34 <lambdabot> (lines `fmap`) . hGetContents
21:07:12 <lispy> ah,that's basically what i was hopping to see
21:07:28 <Cale> @type fmap lines . hGetContents
21:07:30 <lambdabot> bzzt
21:07:35 <Cale> @type fmap lines . IO.hGetContents
21:07:37 <lambdabot> GHC.IOBase.Handle -> IO [String]
21:07:45 <Cale> as was mentioned previously :)
21:07:51 <lispy> right
21:08:17 <lispy> so return . lines is basically liftM lines?
21:08:21 <lispy> @type return . lines
21:08:23 <lambdabot> forall (m :: * -> *). (Monad m) => String -> m [String]
21:08:29 <lispy> @type liftM lines
21:08:31 <lambdabot> bzzt
21:08:43 <Cale> @type fmap lines
21:08:45 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f [String]
21:09:11 <lispy> @type Control.Monad.liftM lines
21:09:12 <lambdabot> forall (m :: * -> *). (Monad m) => m String -> m [String]
21:09:30 <Cale> I'm not quite sure why liftM is exposed
21:09:45 <Cale> I suppose to disambiguate types a bit
21:10:13 <lispy> @type  (\h -> System.IO.hGetContents h >>= Control.Monad.liftM lines)
21:10:14 <lambdabot> bzzt
21:10:17 <Cale> It's sort of annoying to me that map isn't just the class method of Functor.
21:10:49 <lispy> Cale: yeah, since [] is a monad
21:10:52 <Cale> right
21:11:01 <Cale> and any monad is a functor
21:11:03 <lispy> they should fix that in haskell2
21:12:02 <TheHunter> they should also get rid of that stupid fail.
21:12:11 <Cale> I think the monad class ought to look like  class (Functor m) => Monad m where ...
21:12:33 <Cale> and monad comprehensions are a nice idea
21:12:35 <lispy> @type (liftM lines) . System.IO.hGetContents
21:12:36 <lambdabot> bzzt
21:12:43 <Cale> sometimes you really want to think of things that way
21:13:11 <lispy> so if i had used liftM to lift lines, how would I have do nit?
21:13:35 <lispy> then I would have IO String -> IO [String]
21:13:41 <Cale> liftM is fmap
21:13:45 <Cale> just less general
21:14:10 <lispy> hGetContents returns IO String
21:14:34 <lispy> so shouldn't i just beable to do (liftM lines) . hGetContents?
21:14:37 <Cale> liftM lines . hGetContents
21:14:38 <Cale> yes
21:14:51 <Cale> note the similarity of types:
21:14:54 <lispy> oh, i forgot to qualify liftM
21:14:55 <Cale> @type fmap
21:14:56 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
21:14:56 <lambdabot> b
21:15:04 <Cale> @type Monad.liftM
21:15:06 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
21:15:06 <lambdabot> r
21:15:16 <lispy> @type (Control.Monad.liftM lines) . System.IO.hGetContents
21:15:17 <lambdabot> GHC.IOBase.Handle -> IO [String]
21:15:45 <Cale> I prefer seeing fmap to liftM for some reason.
21:15:56 <lispy> Cale: ah, yes, that is frighteningly similar, i'll have to start using fmap where i normally think to use liftM
21:16:23 <Cale> lispy: have you seen my MonadsAsContainers thing?
21:16:29 <TheHunter> Cale, hehe, same here.
21:16:41 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers :)
21:16:44 <lispy> Cale: i don't know if i've seen yours, but i'm familiar with the idea
21:17:11 <lispy> Cale: that was the first way i made sense of monads ;)
21:17:26 <lispy> it could be that there is wisdom in that, that i've not retained
21:18:10 <Cale> lispy: yeah, it was the first way that I understood them as well, and I found that I have a much easier time teaching people about them from that perspective
21:19:19 <Cale> when using do-notation, it's rather easy to forget that you're not just writing an imperative program, but actually building this container-like thing.
21:19:55 <lispy> yeah
21:19:56 <Cale> Which is sort of why I like the idea of having monad comprehensions around, since they seem to take the dual view of the monad.
21:20:07 <Cale> Even if it is just syntax
21:20:14 <lispy> what is an example of a monad comprehension?
21:20:30 <Cale> they're just like list comprehensions, but generalised to other monads
21:21:09 <lispy> @type filter
21:21:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:21:14 <Cale> so you could write that as [lines cs | cs <- hGetContents hdl]
21:21:28 <lispy> ah, nice
21:21:45 <monochrom> not implemented, but a Wadler paper writes [ f x | y <- whatever; x <- blah y ]  instead of do { y <- whatever; x <- blah y; return (f x) }
21:21:59 <Cale> I heard that they were in Haskell 1.4
21:22:00 <lispy> so the lhs of | is like the last line of the monad, and the rhs is like all the previous lines
21:22:03 <Cale> is that true?
21:22:41 <lispy> monochrom: why didn't they use commas?
21:22:50 <Cale> lispy: yeah, with some interpretation of guard conditions
21:22:56 <monochrom> oops it was comma.
21:23:05 <lispy> monochrom: ah, okay
21:23:20 <Cale> in Monad, there's a function called guard for that
21:23:32 <Cale> I suppose it has to be a MonadPlus for guards
21:23:33 <lispy> @type Monad.guard
21:23:34 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
21:23:54 <lispy> so what does a guard do?
21:24:13 <Cale> guard p          =  if p then return () else mzero
21:24:50 <TheHunter> of course, this could be done with the stupid fail as well...
21:24:53 <Cale> which in the case of the list monad, is exactly what a guard in a list comprehension does
21:25:59 <lispy> because when you return mzero it keeps trying to find something that is not mzero?
21:26:09 <Cale> mzero for the list monad is []
21:26:31 <Cale> [] >>= f = []
21:26:53 <lispy> right but i guess i don't see why you want to return either () or mzero
21:27:16 <Cale> if you return (), then the computation gets to possibly return a value
21:27:16 <lispy> what happens with the value that guard returns?
21:27:36 <lispy> hmm..that's counter intuitev
21:27:51 <Cale> You should think about it until it is intuitive
21:27:52 <Cale> :)
21:28:13 <Cale> the () is sort of a stub in the tree of computation which will expand out into some possible values
21:28:20 <Cale> in the container
21:28:41 <monochrom> [] >>= f  is the same as [], that is, f will not matter.
21:28:45 <Cale> since (return ()) >>= f  may return something nontrivial
21:29:08 <monochrom> whereas [()] >>= f  will actually continue with f.
21:29:18 <monochrom> So [] is a way to say "abort".
21:29:47 <lispy> okay, i figured there was an msum going on, in which case [] would mean keep looking
21:29:49 <monochrom> return () is a way to say "move on, nothing to look here".
21:30:43 <lispy> @eval [()] >>= head
21:30:44 <lambdabot> Couldn't match `[a]' against `()'
21:30:52 <Lemmih> Anyone know the C code for killing a Haskell thread and putting 'Nothing' in a MVar?
21:30:54 <lispy> @hoogle () -> a
21:30:55 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
21:30:55 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
21:30:55 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => (a -> b)
21:31:14 <monochrom> In [()]>>=f  you need f :: () -> [a]
21:31:27 <Cale> @eval [()] >>= (\x -> return 5)
21:31:28 <lambdabot> [5]
21:31:34 <Cale> @eval [(),(),()] >>= (\x -> return 5)
21:31:36 <lambdabot> [5,5,5]
21:31:43 <lispy> okay
21:31:46 <Cale> as a simplistic example
21:31:49 <lispy> that makes a lot more sense
21:32:20 <lispy> that could correspond to [5 | _ <- [1..3]]
21:32:34 <Cale> yes
21:33:12 <lispy> but actually, that example wouldn't need a guard would it?
21:33:17 <Cale> right
21:33:33 <Cale> I didn't actually show the guard producing the ()'s
21:33:35 <lispy> [5 | x <- [1..], x < 4]
21:33:46 <Cale> yeah
21:33:50 <monochrom> Yes this one will need MonadPlus.
21:37:19 <Cale> [1..10] >>= \x -> guard (x < 4) >> return 5
21:38:03 <Cale> noting that we really still have access to x here, so the fact that () is returned from guard is not a problem for us
21:38:12 <Cale> [1..10] >>= \x -> guard (x < 4) >> return x
21:38:21 <Cale> works just as well to produce [1,2,3]
21:39:39 <lispy> so that is the translation that list comps use?
21:39:58 <Cale> not quite, it's presently defined in terms of the list specific operations
21:40:39 <Cale> but there's not much reason to restrict it like that, except that new users might not want to get monad error messages when working with list comprehensions
21:41:33 <lispy> phew, new users, who needs 'em ;)
21:41:54 <Cale> I don't see why this can't be handled with some special options to the compiler. --newbie or something to simplify the language a bit
21:42:31 <Cale> actually, one could usually automatically detect the list monad and special-case the errors
21:43:09 <lispy> yeah, and that seems like it would be reasonable given the type information that is available
21:46:21 <lispy> fmap is my new fiend
21:46:23 <lispy> er friend
21:46:29 <TheHunter> i don't think it's all that simple.
21:46:34 <lispy> now if i could just master foldM ;)
21:47:16 <TheHunter> especially if type signatures are ommitted things are forced to have a more general type, and then the monad type errors can't be avoided any more.
22:25:38 <blackdog> g'day ozone
22:25:47 <blackdog> how was the cafe?
22:30:52 <ozone_> cafe?
22:31:00 <ozone_> oh, brunchness
22:31:22 <ozone_> yes, brunchness was the goods.  nothing quite like sitting on bondi beach taking in the scenery (of both sorts) + sun
23:00:02 <Cale> argh, incompatible packages in unstable
23:00:25 <Cale> they want to remove ghc6, so I'd better not upgrade
23:10:13 <blackdog> ozone: you old lech. :)\
23:10:36 <blackdog> man, i hate PB keyboards. think different indeed.
23:14:52 <Korollary> pb = packard bell ?
23:22:21 <lispy_> powerbook
23:22:30 <lispy_> apple.com is all about thinking different
23:23:37 <Korollary> and paying premium
23:56:22 <boegel> @seen shapr
23:56:23 <lambdabot> shapr is in #haskell. Last spoke 4 hours, 29 minutes and 24 seconds
23:56:23 <lambdabot> ago.
23:56:32 <boegel> shapr: any news on FLM ?
