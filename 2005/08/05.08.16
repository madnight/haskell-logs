00:09:25 <smott> hm okay make installing h4sh might've been a bad idea...
00:10:44 <seafood> smott: How'd you come up with that name?
00:11:50 <Itkovian> meuning
00:12:30 <smott> seafood: "smott"? i don't remember. i just needed a new nick
00:12:53 <seafood> Just really interesting.  I know person in real life called Samantha Mott and she calls herself smott.
00:13:16 <seafood> I'm assuming you're not her
00:13:29 <smott> unfortunately not
00:19:16 * boegel wonders if shapr managed to finish FLM...
00:20:44 <dons> smott, why is make install a bad idea?
00:25:22 <smott> dons: it replaces head, tail and probably others
00:26:14 <paolo> dum de dum
00:26:36 <dons> well, they're installed to a different location
00:26:55 <dons> head, tail, sort and id are probably the only ones
00:27:07 <dons> these can be renamed without anything breaking
00:28:10 <dons> I'll think about how to deal with this issue
00:30:46 <shapr> boegel: not yet
00:30:56 <autrijus> "hd tl st identity" ?
00:31:04 <autrijus> car cdr? ;)
00:31:48 <dons> head' tail' sort' id' ;)
00:32:03 <autrijus> I don't think shells like single quotes ;)
00:32:09 <tuomov> hd tl srt I
00:32:16 <autrijus> yeah
00:32:17 <dons> hd tl srt i
00:32:27 <dons> ?
00:32:32 <autrijus> why do we need "id" anyway
00:32:38 <dons> == cat
00:32:46 <dons> but cleaner.
00:32:50 <paolo> testa coda ordina ^_^
00:32:57 <autrijus> ok, then "i" sounds good
00:33:04 <autrijus> i /etc/passwd
00:33:16 <dons> ok. hd tl srt i sounds good
00:33:58 <paolo> car cdr would have been nice heh
00:34:11 <tuomov> just got a ring a while ago that network should be working back home... I can try h4sh today!
00:34:26 <dons> :)
00:35:57 <boegel> shapr: I think we have a different idea of 'soon' :p
00:53:22 <musasabi> Has anyone thought of using cdbs with Cabal to build debian packages?
00:57:54 <musasabi> hmm /usr/share/cdbs/1/class/hbuild.mk does exist.
01:13:40 <boegel> hello Muad_Dibber
01:16:39 <Muad_Dibber> hey boegel
01:17:56 <Muad_Dibber> how are you?
01:18:28 <boegel> great  ! :) you ?
01:18:39 <Muad_Dibber> fine as well
01:18:41 <Muad_Dibber> not that great
01:18:49 <Muad_Dibber> gentoo wont boot anymore and i dont feel like fiddling with it right now
01:18:53 <Muad_Dibber> so i happen to be in windows again ;(
01:19:08 <boegel> oh no ! the horror ! :)
01:21:37 <Muad_Dibber> so what are you up to?
01:21:57 <Tue21130> morning
01:22:16 <Tue21130> too bad there's no Debug.Trace.trace that writes to a file
01:25:33 <Cale> Tue21130: you could write one
01:25:50 <dblhelix> too bad there's not Debug.Util.fixBugs that etc.
01:26:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System.IO.Unsafe.html
01:26:39 <yosemite> looks like you need something like hPutTraceMsg or something
01:27:09 <Itkovian> How feasible would a HSP page be that implements some kind of agenda to plan AD&D dates? It would need to keep track of people that are available and mail all participants if all have checked a date as being 'free'
01:28:09 <yosemite> ooh unsafePerformIO  I wondered how that was done in trace
01:28:25 <musasabi> Quite easy I think, the only problem would be ensuring state validity in face of concurrency if you would not be using haskelldb.
01:28:54 * Itkovian has just found a new challenge
01:29:48 <yosemite> has anyone done much HTML parsing in haskell here?  I've been messing with HaXml and it's Html parsing is a bit broken
01:40:23 <Tue21130> Cale, i will look at the unsafe stuff..maybe its not that hard
02:45:47 * boegel does a little dance
02:46:48 * Muad_Dibber takes photographs of boegel dancing
02:47:44 * boegel puts his pants back on and sues Muad_Dibber 
02:49:42 <Muad_Dibber> hah
02:49:43 <Muad_Dibber> i'll win
02:49:51 <Muad_Dibber> i was just taking pictures of the nice view in #haskell
02:50:05 <Muad_Dibber> and some weirdo started dancing with his pants of in front of the camera, which was on autoshooting mode
02:50:15 <Tue5608> nice view....and #haskell.....
02:50:19 <Tue5608> weird combo
02:51:00 <boegel> Muad_Dibber: I saw you, you were aiming at me !
02:51:24 <boegel> give me $,000,000 and I we'll call it a deal, mmkay ? :)
02:51:29 <boegel> woops
02:51:33 <Muad_Dibber> sure
02:51:36 <boegel> s/$,/$1,
02:51:38 <boegel> :D
02:51:39 * Muad_Dibber hands over $,000,000
02:51:40 <Muad_Dibber> :P
02:53:25 * Itkovian eats
02:54:09 <Tue5608> when is it decided that a trace has to be evaluated?
02:54:18 <Tue5608> as soon as it is encountered?
02:54:29 <dcoutts> as soon as it's value is demanded
02:54:37 <vikasg> can I define my own "show" for one of the data constructors while deriving Show for the others?
02:55:18 <dcoutts> vikasg, no, you can derive for the all the constructors of a data type or do it all youself
02:55:19 <Tue5608> ah and trace probably then uses seq to dump the string before returning the value
02:55:32 <Tue5608> @hoogle seq
02:55:34 <lambdabot> Prelude.seq :: (a -> b -> b)
02:55:34 <lambdabot> Prelude.sequence :: Monad a => ([(a b)] -> (a [b]))
02:55:34 <lambdabot> Prelude.sequence_ :: Monad a => ([(a b)] -> (a ()))
02:55:48 <vikasg> dcoutts, bummer
02:55:49 <dcoutts> Tue5608, yes, probably a combination of seq, unsafePerformIO and putStrLn
02:56:15 <dcoutts> Tue5608, which is why it's evil! :-) and should only be used for debugging
02:56:29 * aleator gets frustrated at all the c coders. Why must they pack all their options in obscure 8 bit sequences..
02:56:50 <Tue5608> hahaha im writing the same combination but then with hPutStrLn to be able to do tracing to files :D
02:56:56 <Tue5608> evil, but useful i reckon
02:57:28 <dcoutts> vikasg, if you've got a data type with loads of constructors you can use DrIFT to derive show and then just customise the ones you want
02:58:23 <paolo-> dcoutts!  Hi!
02:59:00 <dcoutts> paolo-, hello! you're no longer xerox?
02:59:01 <vikasg> dcoutts, ok. I've got only 5-6 so I'll just do it myself
02:59:11 <paolo-> dcoutts: prolly :-)
02:59:34 <dcoutts> paolo-, so how's gtk+cairo going now?
02:59:58 <paolo-> No blog updates, I know.  I mostly talked privately with Abraham these days.
03:00:21 <paolo-> I think I have a "mostly" complete IO-functions interface to cairo.
03:00:28 <dcoutts> I'm looking forward to Gtk2Hs 0.9.10 with Gtk+ 2.8 support and cairo support :-)
03:00:36 <paolo-> I'll be darcspushing today.
03:00:51 <dcoutts> cool, remind be where the repo is
03:02:46 <paolo-> Just a note...
03:03:19 <paolo-> I've written it externally from Gtk2Hs sources hierarchy now
03:03:36 <Itkovian> anybody succeeded in building haskell-src-ext 0.2 ?
03:03:47 <Itkovian> I get a shift/reduce error ...
03:03:48 <paolo-> I don't think it's difficult to replace the cairo/ you put with mine, but I didn't try yet.
03:03:55 <dcoutts> paolo-, no probs
03:04:23 <paolo-> Also, as now there is nothing new on the darcs side: http://haskell.galois.com/~paolo/darcs/
03:04:33 <dcoutts> paolo-, so axel is working on the pango+cairo bits that you need I think
03:04:39 <paolo-> I think I'll add a cairo/ repo there before putting it in gtk2hs.
03:04:48 <paolo-> Hmm, yes!
03:04:52 <Itkovian> Setup.hs: internal error: stg_ap_v_ret
03:05:21 <paolo-> afk brb
03:06:30 <paolo-> dcoutts: there is a thing I asked on the ml but you prolly didn't see - why should I avoid {#fun ..#} hooks?
03:11:24 <dcoutts> paolo-, well if you've got them working ok then fine, it's just we found they didn't quite do what we wanted. We don't use them anywhere else in Gtk2Hs. But if you're using them sucessfully then that's fine.
03:13:41 <dcoutts> paolo-, so how about the attributes then? it's using the attributes api from glib now?
03:13:43 <musasabi> Itkovian: that is a known bug on Mac OS X. can you try compiling the Setup.{hs,lhs} manually?
03:14:04 <musasabi> Itkovian: ghc --make Setup.lhs -o setup
03:14:09 <Itkovian> as in manually, you ... ok
03:14:16 <Itkovian> sure thing
03:14:58 <Itkovian> heh, cool. the first time I try the runhaskell approach it fails me ...
03:16:37 <paolo-> dcoutts: I have hooked get_ and set_ functions, I'm trying to understand how to make use of the attributes API.
03:17:07 <dcoutts> right, you can see how we do it in other Gtk2Hs modules
03:17:47 <dcoutts> it's basically: attrFoo = newAttr getFoo setFoo
03:18:50 <paolo-> and readAddr writeAddr for readonly and writeonly, right
03:18:58 <dcoutts> yep
03:20:16 <vikasg> I can't define a type as an intersection of two types, right?
03:20:58 <Itkovian> musasabi: thx
03:21:45 <bourbaki> moin
03:22:13 <vikasg> um, I meant union of two types
03:23:26 <ibid> not an untagged one
03:23:33 <ibid> but you can define a tagged one
03:23:48 <vikasg> tagged?
03:24:17 <ibid> data TaggedUnion a b = TagA a | TagB b
03:24:17 <ibid> :)
03:24:32 <ibid> vikasg: a tagged union is one that always knows which type it holds
03:24:57 <vikasg> here's what I'm trying to do
03:28:19 <vikasg> I have a type of Scheme expressions --- data ScmData = ScmSymbol ... | ScmPair ... etc.
03:29:35 <vikasg> now if I write a fold for Scheme lists, I'd ideally want its type to be (ScmPair -> [a] -> [a]) -> [a] -> ScmData -> [a]
03:29:54 <vikasg> but there's no way to say that without breaking a lot of other stuff
03:30:43 <vikasg> sorry, the type (ScmData -> [a] -> [a]) -> [a] -> ScmPair -> [a]
03:30:50 <Lemmih> Have a look at GADTs.
03:31:02 <vikasg> Generalized ADTs?
03:31:11 <Lemmih> Yep.
03:31:17 <vikasg> will do
03:32:53 * vikasg should really read type theory
03:38:34 <vikasg> Lemmih, thanks
03:57:11 <boegel> yo bourbaki
03:57:37 <bourbaki> hey
03:57:44 <bourbaki> did you try the landscape?
04:22:17 <boegel> bourbaki: yeah, it kinda crashed on me... but my windows machine isn't really installed properly, that was the problem I think... isn't there any way I can compile it myself ?
04:22:22 <ndm> how do i export an instance in Haddock documenation?
04:22:38 <ndm> i have instance Show a => Show (RegExp a) in one of the modules
04:22:52 <ndm> but the haddock documentation doesn't seem to be exporting it and sending it onwards
04:23:06 <ndm> its not in the export list at the top of the module, but i've no idea how to put it in there...
04:23:33 <Lemmih> ndm: Instances are kept with the structure.
04:23:49 <ndm> Lemmih, is there any way to put it with the module it comes from as well?
04:24:10 <Lemmih> I doubt it.
04:24:18 <ndm> the structure is meant to be an abstraction, so ideally not something people look at
04:24:21 <ndm> ok, never mind
04:27:52 <ndm> does that mean i can't attatch a comment to an instance?
04:34:04 <Itkovian> hsp -> cannot satisfy dependency fastcgi-any ... I do have fastcgi in /usr/local
04:37:01 <Itkovian> nevermind
04:37:05 <Lemmih> Does 'ghc-pkg list' show fastcgi?
04:37:09 <Itkovian> I'm ...
04:37:12 <Itkovian> well, exactly ...
04:37:20 <Itkovian> dumb ol' me
04:39:22 <Itkovian> for the fastcgi cgi dependency, is that http://www.janweb.net/laitenbe/haskell/CGI/ I need?
04:41:40 <Lemmih> Itkovian: I've just pushed some changes to my version of HSP.
04:42:03 <Itkovian> Lemmih: I still need to get the deps in order ...
04:43:02 <Lemmih> The changes includes a detailed INSTALL file.
04:43:10 <Itkovian> aha ;-)
04:43:30 <Itkovian> well, I've gone 1 dir up in bringert's tree, and there it was : haskell-cgi :-)
04:50:46 <Itkovian> @hoogle getInputs
04:52:45 <Lemmih> Having problems compiling fastcgi?
04:56:05 <Itkovian> yeah ... some ...
04:56:17 <Itkovian> the printinput.hs example, more specifically
04:57:36 <Lemmih> I just removed the examples from the cabal file. Will definitely fix it before a stable HSP is released.
04:57:56 <Itkovian> examples/printinput.hs:19:10: Not in scope: `getInputs'
04:57:59 <Itkovian> ah, ok
04:59:09 <roconnor> diffPolynomial p = zipWith (*) (tail p) (map fromInteger [1..])
04:59:50 <Itkovian> aargh: can't find source for HSP.Persistent in ["."]
05:00:18 * Itkovian is rereading the INSTALL file
05:00:37 <Lemmih> Itkovian: Ops, I forgot to add that file /-:
05:00:52 <Itkovian> hurray for boobies ... erm testing
05:01:04 <Lemmih> Itkovian: You can pull it now.
05:01:07 <Itkovian> thx
05:01:12 <Itkovian> erm ...
05:01:29 <Itkovian> that sounds a tad dubious rereading it
05:02:45 <Itkovian> still complains though
05:02:55 * Tue7525 cheers
05:03:18 <Tue7525> my own Debug.Trace.trace writing to files works
05:03:19 <Tue7525> :D
05:03:21 * shapr yawns
05:03:35 <Itkovian> can't find source for HSP.Data.Persistent in ["."]
05:03:36 <Tue7525> i know, its trivial...but still :D
05:03:36 <Itkovian> :-)
05:04:43 <Itkovian> Lemmih: can you add HSP/Data/Persistent.hs too?
05:04:50 <dons> Data.Persistent sounds fun
05:04:58 <Itkovian> I have no idea ...
05:05:05 <shapr> Related to musasabi's SerTH?
05:05:14 <Lemmih> shapr: Nope.
05:05:29 <Lemmih> Itkovian: Pushed.
05:05:37 <Itkovian> thx. pulled.
05:05:52 <Lemmih> Itkovian: Everything should be there now (:
05:06:22 <Itkovian> yeah ... I'm getting to the point where ghc requests trhsx, which is installed, but cannot be found it seems
05:07:08 <Lemmih> Make sure that 'trhsx' is in PATH and is executable.
05:07:45 <Itkovian> grmbl
05:08:09 <Itkovian> it seems like haskell-src-exts' Makefile doesn't have an install part, so it's sudo make all the way
05:08:13 <Itkovian> bummer
05:09:13 <Itkovian> furthermore trhsx hgets installed as -rwxr--r-- root:wheel
05:09:15 <Itkovian> grrr
05:09:25 <shapr> Itkovian: oh I have an idea!
05:09:35 <Itkovian> yeah yeah
05:09:37 <Itkovian> TMR right
05:09:46 <shapr> I had a similar problem where ghc-pkg listed the package, but I couldn't build with it.
05:09:50 <Itkovian> ah ...
05:09:54 <shapr> Itkovian: No :-P a helpful idea :-P
05:09:58 <Itkovian> haha
05:10:10 <Itkovian> well, I sdhould be all go now
05:10:19 <Itkovian> but please elaborate
05:10:52 <shapr> When I looked in /usr/local/lib/NewBinary-0.1/ I discovered that root's umask was set to 022, so I needed to chmod ugo+r libHSNewBinary-0.1.a as well as chmod **/*.hi in that directory.
05:11:03 * Lemmih logs Itkovian's troubles in HSP's ToDo file.
05:11:30 <Itkovian> shapr: ok
05:11:34 <shapr> Maybe you have the same problem? Maybe you're building as a user when you've used 'runghc Setup.hs install' with a umask of 022?
05:12:03 <Itkovian> shapr: maybe I should just start with extracting the install part of the src-ext makefile into a decent install item
05:12:11 <Itkovian> or whatever that's called in a makefile
05:12:37 <Itkovian> well, my umask is indeed 0022
05:13:36 <Itkovian> I always build as a user ...
05:13:42 <Itkovian> at least on my mac
05:13:58 <shapr> But do you install haskell-src-exts as a user or as root?
05:15:27 <roconnor> Heh, I like that I can guess how to compute a list of factorials, and it works.
05:15:47 <Itkovian> shapr: as root ...
05:17:09 <shapr> Itkovian: And root's umask is 022?
05:17:16 <roconnor> factorials = fact 1
05:17:17 <roconnor>  where
05:17:19 <roconnor>   fact n = 1:(map (n*) $ fact (n+1))
05:17:19 <Itkovian> I have no idea ;-)
05:17:38 <Itkovian> well ... actually I'm using sudo mostly ... so I guess it retains my umask
05:18:52 <shapr> Are the installed files set ugo+r ?
05:19:27 <Itkovian> yeah
05:19:38 <Itkovian> http://www.theregister.co.uk/2005/08/16/fotw_1608/
05:19:39 <Itkovian> lol
05:19:48 <Itkovian> especiialy the part about the typos I can relate to very well
05:19:57 <Itkovian> (that one was on purpose)
05:20:07 <Itkovian> ah darn, there were two in there
05:25:39 <Itkovian> Lemmih: Could not find module `HSPR.PluginLoader':
05:25:42 <Itkovian> :-)
05:27:34 <ndm> I am getting some Haddock warnings I don't understand
05:27:43 <ndm> Warning: Unsafe: the following names could not be resolved: IO
05:27:44 <Lemmih> Itkovian: One moment...
05:28:01 <ndm> thats in a module called Unsafe, that has as a type sig something containing IO
05:28:12 <vikasg> rconnon, another way: facs = fac 1 2 where fac i j = i : fac (i*j) (j+1)
05:28:13 <dons> ndm, doesn't it mean that haddock can't see the prelude (which is usual?)
05:28:17 <ndm> it obviously can't link to IO, but thats not something i defined so no surprise
05:28:35 <ndm> dons, yeah, i guess so - does that mean its a warning I just have to live with?
05:28:36 <Lemmih> Itkovian: Pushed.
05:28:43 <Itkovian> thx. pulled
05:28:46 <vikasg> roconnor, even
05:28:49 <dons> yeah, I think it is no problem. yi's haddocks do the same thing
05:28:52 <ndm> i would rather get down to no warnings, so i can see the bad ones earier
05:29:03 <dons> 2> /dev/null ;)
05:29:23 <ndm> but some of the warnings are actually useful...
05:29:33 <roconnor> vikasg, even?
05:29:39 <roconnor> oh
05:29:51 <Igloo> shapr: If you're still interested in MIME tests, I moved all the MIME stuff to Messages/ and fixed compilation with ghc 6.4, so it should be easier now
05:29:52 <vikasg> :)
05:30:08 <shapr> Igloo: thanks for the update.
05:31:03 <roconnor> vikasg, missing 0!, but still good.
05:31:30 <vikasg> roconnor, 1 : (fac 1 2)
05:31:39 <roconnor> ;-)
05:32:18 <roconnor> (fac 1 1) also works
05:32:43 <vikasg> the other day I was wondering, in fact, if there was a general way to take any recurrence relation and turn it into an infinite list
05:33:32 <roconnor> vikasg, may I steal you code?
05:33:50 <roconnor> s/you/your/
05:33:56 <dcoutts> juhp, ping
05:34:01 <vikasg> sure, that hardly counts as code ;)
05:34:19 <roconnor> It is way more clearly correct than mine.
05:34:29 <dcoutts> juhp, I was wondering how you deal with registering/unregistering cabal packages with your rpms
05:34:37 <vikasg> roconnor, thanks
05:35:40 <dcoutts> Igloo, sae question to you too actually, you use the register/unregister --gen-script option right?
05:36:41 <dcoutts> Igloo, so how does upgrading a package work? suppose you've got foo-1.0 and you upgrade to foo-1.0-r1, but both provide Foo-1.0
05:37:36 <dcoutts> Igloo, what order do the pre/post install/uninstall actions take place in?
05:37:39 <Itkovian> Lemmih: Could not find module `System.Plugins' -- should that be anywhere in my standard ghc distrib?
05:38:02 <Lemmih> Itkovian: No, it's provided by hs-plugins.
05:38:03 <juhp> dcoutts: hmm, I haven't packaged that many cabalized packages yet
05:38:09 <dcoutts> juhp, ok
05:38:10 <juhp> let me see
05:38:22 <dcoutts> juhp, any ideas on who you're going to do it
05:38:25 <juhp> dcoutts: but more than zero :)
05:38:27 <Itkovian> Lemmih: hmm, then I should have it somewhere
05:38:55 <dcoutts> juhp, now is the time to get cabal fixed so that it's usable by packaging people such as youself
05:38:56 <juhp> dcoutts: any particular one in mind?
05:39:07 <juhp> dcoutts: nod
05:39:13 <Lemmih> Itkovian: You need a fairly recent hs-plugins.
05:39:20 <dcoutts> juhp, well the general problem of how do you register an cabal package
05:39:44 <dcoutts> you can't use ./setup register since it has to be run on the target machine, not the build machine
05:39:59 <juhp> right
05:40:06 <dcoutts> cbal provides a ./setup register --gen-script option
05:40:22 <dcoutts> that gives you a shell script that you can run on the target machine
05:40:26 <juhp> dcoutts: maybe I haven't packaged any cabal libraries
05:40:49 <dcoutts> and ./setup unregister --gen-script gives you one to use to unregister
05:41:03 <juhp> ok cool
05:41:08 <dcoutts> is that going to be acceptable to you, and is it sufficient?
05:41:14 <juhp> dcoutts: are those options new?
05:41:21 <dcoutts> not very new
05:41:28 <juhp> sounds ok to me
05:41:40 <dcoutts> we worry about running these scripts as root on the target machine
05:41:49 <juhp> guess I would have to try them first though
05:42:03 <juhp> dcoutts: why?
05:42:10 <dcoutts> we normally only run bits of the build system code in a sandbox
05:42:36 <dcoutts> and then all that is done "live" is merging into the filesystem and that's under the control of the package manager, not the build system
05:42:59 <juhp> dcoutts: are the generated scripts so complicated?
05:43:18 <musasabi> Why doesn't Foreign.C.String have pokeCString and pokeCStringLen ?
05:43:42 <dcoutts> juhp, not terrbily but we can't guarantee that they will always be the same since the Setup.lhs doesn't have to use the Distribution.Simple system
05:43:50 <dcoutts> so they could contain anything
05:44:13 <juhp> dcoutts: I guess an alternative would be to generate a cabal pkg file and pass that to ghc-pkg?
05:44:25 <dcoutts> exactly
05:44:44 <dcoutts> we would like exactly that but apparently this breaks the cabal abstraction
05:44:53 <juhp> hmm
05:45:08 <dcoutts> so I'm looking around for moral support :-)
05:45:25 <dcoutts> and/or a better suggestion/comprimise
05:45:32 <juhp> dcoutts: in what sense does it break it?
05:45:54 <juhp> ah, it is ghc specific_
05:45:55 <dcoutts> the user of cabal is not supposed to be troubled with the details of how to invoke ghc-pkg
05:45:55 <juhp> ?
05:46:08 <dcoutts> since cabal is supposed to support ghc, nhc hugs ...
05:46:23 <dcoutts> we're supposed to remain blissfully unaware
05:46:23 <Igloo> dcoutts: unregister in prerm, then register in postinst
05:46:32 <CosmicRay> reminder: HWN comes out today, send me any submissions you may have now
05:46:53 <Igloo> dcoutts: I haven't packaged any cabal packages myself, incidentally
05:46:58 <dcoutts> Igloo, right, and you just use the register/unregister scripts
05:47:00 <juhp> dcoutts: ok, but cabal still can generate pkg files, no?
05:47:04 <dcoutts> Igloo, oh right
05:47:07 <Igloo> dcoutts: That's the plan
05:47:20 <dcoutts> juhp, no it doesn't, it calls ghc-pkg itself directly
05:48:04 <dcoutts> juhp, or generates a script that calls ghc-pkg
05:48:13 <juhp> dcoutts: oh, nm - ghc-pkg can read the cabal package files directly right?
05:48:28 <juhp> so there is nothing to generate?
05:48:44 <dcoutts> juhp, not quite, the format accapted by ghc-pkg is similar but different to the .cabal files
05:48:51 <juhp> ah
05:49:02 <dcoutts> cabal produces the .pkg file but it's inline inside the script
05:49:05 <Itkovian> Lemmih: surely the latest hs-plugins should work, no?
05:49:22 <Lemmih> Itkovian: Pretty sure.
05:49:36 <dcoutts> juhp, ie the script looks like: cat "....." | ghc-pkg -blah -bla
05:49:38 <Itkovian> I've got that installed ...
05:49:44 <juhp> dcoutts: so in the script it is in the right form?
05:49:51 <dcoutts> juhp, yes
05:50:14 <Lemmih> Itkovian: Latest as in recent pull from the darcs repo.
05:50:24 <dcoutts> juhp, but you can't easily get your hands on the actual .pkg file itself and register it yourself
05:50:26 <Itkovian> yeah ... reinstalled it, same result
05:50:33 <Itkovian> hspr complains
05:51:04 <dcoutts> juhp, of course we know that the package managers are already quite intimate with ghc-pkg and know all too much about it's calling syntax etc
05:51:04 <juhp> dcoutts: ok, but so it shouldn't be that hard to get it to output it to a file then one would think
05:51:17 <juhp> heh
05:51:40 <Igloo> juhp: Why do you want to do that?
05:51:59 <dcoutts> juhp, no indeed it's not hard to modify cabal to produce the .pkg file that we can pass to ghc-pkg, but apparently this breaks the abstraction
05:52:05 <juhp> dcoutts: but you're saaying that it is going to be hard to audit scripts generated by cabal?
05:52:47 <dcoutts> juhp, I can write a Setup.lhs that produces any script I like when you invoke ./Setup.lhs register --gen-script
05:52:54 <juhp> dcoutts: understood - presumably they want an "opaque api"
05:53:05 <dcoutts> juhp, yes
05:53:29 <dcoutts> in my opinion we're already on the messy side of the cabal abstraction
05:54:01 <juhp> dcoutts: thanks for the headsup btw - since I haven't been following cabal recently
05:54:58 <dcoutts> juhp, ok, no probs. I'm hoping you'll wade in on the side of use poor packaging people :-)
05:54:58 <juhp> Igloo: so you don't have any quibbles about these generated scripts?
05:55:20 <juhp> dcoutts: is the discussion on the libs list?
05:55:29 <dcoutts> I've sent an email with a summary of the problems we're having to the libs list
05:55:44 <juhp> ok
05:55:47 <dcoutts> juhp, yes cabal discussion goes on on the libraries list
05:55:48 <Igloo> juhp: What about them?
05:56:41 <juhp> Igloo: I don't really know any more than what Duncan has been telling me now...
05:56:44 <roconnor> can I use @hoogle to find all functions that have (a->Bool) as a parameter?
05:57:13 <roconnor> ah, just found what i was looking for the normal way.
05:57:20 <roconnor> until. ... it was near the end of the list
05:58:05 <Igloo> juhp: Are you worrying about them possibly doing rm -rf / or something else?
05:59:53 <juhp> dcoutts: I have long thought the cabal "api" to be a bit of an "eccentric" design
06:00:24 <Igloo> juhp: Did you explain why?
06:00:33 <dcoutts> juhp, well now it's time to make it work for us before it sets in stone
06:00:59 <juhp> Igloo: emm, more just I'd like to know what it is going to do without having to read the script
06:01:05 <juhp> Igloo: no :)
06:02:01 <dcoutts> juhp, otherwise we'll never be able to build the automation tools that will help us build .ebuild/.deb/.rpm packages without lots of manual checking / hacking
06:02:03 <Igloo> Well then  :-)
06:02:20 <juhp> Igloo: I guess I sympathise with dcoutts' point that there is quite a difference what is run as root
06:02:40 * Itkovian feels dumber with the minute
06:02:50 <juhp> and I really want to know what exactly the install scripts are going to do
06:03:00 <Igloo> The design is really wrong if you want to disallow user-supplied register scripts
06:03:12 <juhp> Igloo: mostly due to lack of time alas....
06:03:26 <Igloo> You'd want a global cabal program that interprets a data file, I think
06:04:18 <Igloo> s/disallow/be able to disallow/
06:04:19 <juhp> Igloo: this scripts thing is kinda of new to me - quite likely the default scripts are just fine :)
06:04:52 <juhp> guess I need to try it anyway
06:05:19 <juhp> dcoutts: any suggestions for a cabal library to try?
06:05:33 <dcoutts> juhp, c2hs
06:05:41 <dcoutts> oh that's not a lib...
06:05:49 <dcoutts> wait a sec
06:06:05 <juhp> well it used to have a lib too - but not much used anymore i guess
06:07:05 <dcoutts> juhp, yes the lib is now gone
06:07:08 <dcoutts> try http://www.haskell.org/crypto/
06:07:15 <juhp> ok
06:07:23 <dcoutts> or HaXML is now cabalsied
06:07:35 <juhp> ok thanks
06:07:56 <juhp> it will probably be tomorrow though - going to get some rest
06:10:57 <dcoutts> Igloo, here's my problem with pre_uninstall/post_install; you may laugh but on gentoo when upgrading a package the pre/post_inst actions happen before the pre/post_remove actions, so just using the register/unregister scripts provided by cabal will not work (i'll unregister on upgrade)
06:12:56 <Igloo> I think I'd rather cry
06:13:17 <Igloo> At what point are the binaries overwritten?
06:13:33 <Igloo> Are you sure that's the case?
06:14:00 <dcoutts> yes it's definately the case
06:14:15 <dcoutts> the binaries are overwritten on the intial merge
06:14:37 <Igloo> So you overwrite the old binaries, and then call uninstall with the new binaries installed?
06:14:59 <dcoutts> yes, and only unmerge the things that were not just merged
06:15:18 <dcoutts> so for an upgrade that usually means removing exactly nothing
06:15:42 <dcoutts> unless the set of files has changed in the upgrade in which case some things might be removed
06:15:46 * shapr is surprised
06:15:52 <Igloo> viva la Debian
06:15:56 <CosmicRay> shapr: http://darcs.complete.org/magic-haskell/
06:16:16 * shapr hugs CosmicRay 
06:16:23 <vegai> anyone checked darcs-git?
06:16:28 <dcoutts> I think rpm does the same thing, it means thare there is a minimum amount of time when the files are not there at all
06:16:42 <CosmicRay> Igloo: When I write up some small utilities that are not performance-critical (say, darcs-buildpackage), would you recommend that I build them with ghc6, or instead use hugs, when packaging them for Debian?
06:16:47 <CosmicRay> morning shapr!
06:16:54 <shapr> CosmicRay: So, where do I contribute the John Goerzen flagrant library creation fund?
06:17:01 <CosmicRay> hehe
06:17:03 <Igloo> dcoutts: You can uninstall, overwrite, remove unneeded, install
06:17:24 <CosmicRay> shapr: I found I needed this for http://darcs.complete.org/media-index ;-)
06:17:43 <Igloo> There will admittedly be a period where the thing is not "installed", but you also have a period of oddness if the meaning of "install" changes
06:17:55 <CosmicRay> shapr: which is itself a tool to build a searchable index of files on DVD-R/CD-R/whatever replacable media
06:18:26 <Igloo> CosmicRay: For haskell-utils I taught it how to build for each of ghc6, nhc98, hugs, and have it build with the best it finds
06:18:28 <juhp> dcoutts: it is the same with rpm - %post happens before %preun
06:18:32 <dcoutts> Igloo, I didn't write the thing obviously but I beleive it is suppoed to running programs less doing it that way
06:18:50 <dcoutts> juhp, right, so you'd be screwed too
06:18:54 <CosmicRay> shapr: it turns out that my chosen text indexer (hyperestraier) doesn't use magic (but just extensions) to determine filetype.  not very good, since all sorts of things use .doc (not just wod docs)
06:19:09 <CosmicRay> Igloo: so you have one .deb, arch: any, and it will compile if possible, and dep on hugs otherwise?
06:19:21 <Igloo> Yup
06:19:25 <dcoutts> juhp, you can't just run the ./unregister script in %preun and ./register in %post
06:19:29 <CosmicRay> Igloo: I received a complaint that darcs-buildpackage takes up too much space (5MB) when installed.  It currently uses ghc6 only.
06:19:36 <Igloo> I think it compiles for hugs with a bit of echo and cpp
06:19:39 <CosmicRay> Igloo: it would use about 50K if it were to use hugs, probably.
06:19:52 <Igloo> 5M? That sounds high
06:19:53 <juhp> dcoutts: but wouldn't you only run the unregister script when removing the package?
06:19:53 <CosmicRay> Igloo: otoh hugs is 11MB installed
06:19:58 <Igloo> Oh, on x86 or strange arches?
06:19:58 <CosmicRay> Igloo: it's got several bins
06:20:03 <CosmicRay> x86
06:20:04 <Igloo> Ah, hmm
06:20:32 <dcoutts> juhp, im not sure we get to know the distinction between removal and upgrade
06:20:32 <CosmicRay> /usr/bin$ ls -l darcs-buildpackage dbp*
06:20:33 <CosmicRay> -rwxr-xr-x  1 root root 963756 May 31 12:05 darcs-buildpackage
06:20:33 <CosmicRay> -rwxr-xr-x  1 root root 959372 May 31 12:05 dbp-get
06:20:33 <CosmicRay> -rwxr-xr-x  1 root root 952588 May 31 12:05 dbp-importdsc
06:20:33 <CosmicRay> -rwxr-xr-x  1 root root 954956 May 31 12:05 dbp-importorig
06:20:33 <CosmicRay> -rwxr-xr-x  1 root root 953100 May 31 12:05 dbp-markdeb
06:21:22 <juhp> dcoutts: I mean it is the same for ghc-pkg --remove (?) in preun script, no?
06:21:24 <musasabi> What is the status of the cdbs haskell support? And how is it related to dh_haskell?
06:21:38 <Igloo> Hmm, OK
06:22:00 <Igloo> It sucks that it's necessary, but you could see how it compares to have a single binary that little scripts call
06:22:08 <dcoutts> juhp, yes, so we've got to do more complicated things like taking the set difference to find what actually needs to be removed
06:22:44 <dcoutts> juhp, this would all be much simpler if ghc could use a directory of package files...
06:22:50 <juhp> dcoutts: ah right, since the scripts may do more than ghc-pkg?
06:22:55 <CosmicRay> Igloo: yeah, but that's ugly and I'd prefer not to do that.  I'm not really worried about 5MB, but if we start having a bunch of utils written in Haskell -- and I think we might -- perhaps it would be useful to have a policy to use Hugs for such things
06:22:58 <CosmicRay> where possible
06:23:15 <CosmicRay> musasabi: I haven't heard of anyone using cdbs with haskell
06:23:15 <juhp> dcoutts: ah yeah, that would indeed be nice
06:23:16 <Igloo> Or make noise about it on g-h-u. I wonder what stops the RTS being a dynamic library
06:23:35 <CosmicRay> musasabi: my own opinion is that cdbs is unnecessary given the plethora of tools like darcs-buildpackage
06:23:48 <CosmicRay> musasabi: I figure, why use some nasty hack to keep track of patches when darcs can do that for me
06:24:02 <Igloo> Hmm, but that is at most 300k
06:24:05 <kaol> looks like someone was packaging fudgets for debian 3 years ago, but I don't see those packages anywhere. I'm considering doing that myself...
06:24:05 <dcoutts> juhp, you know how RedHat have converted many programs use use conf.d dirs of conf files since this "Just Works"TM with a package manager thats based on files
06:24:15 <CosmicRay> musasabi: as far as dh_haskell is concerned, it is mostly used for building Haskell libraries.  If you are building a Haskell program, you probably don't need dh_haskel.
06:24:31 <CosmicRay> Igloo: really?  hmm.
06:24:44 <juhp> dcoutts: nod - it seems the Right Thing indeed
06:25:10 <CosmicRay> -rw-r--r--  1 root root 649018 2005-05-21 19:08 libHSrts.a
06:25:12 <juhp> dcoutts: probably not possible for 6.4 series, but maybe 6.6?
06:25:14 <CosmicRay> is that the file?
06:25:31 <Igloo> -rw-r--r--  1 root root 302702 May 21 15:59 /usr/lib/ghc-6.4/libHSrts.a
06:25:34 <dcoutts> juhp, I mentioned this during intial cabal discussions, it was turned down, I can't quite remember why
06:25:37 <juhp> though we really need it now...
06:25:43 <CosmicRay> oh oops, I ran that on amd64
06:26:07 <dcoutts> I think it we becasue it wouldn't allow ghc-pkg to check for inconsistencies at install time (but of course this is what a package manager already does)
06:26:11 <juhp> dcoutts: could it be done as an extension of the main pkg file?
06:26:12 <CosmicRay> these programs probably also involve libHSposix and libHSparsec
06:26:28 <Igloo> Getting a breakdown by size of where the bits of the executable come from would be interesting
06:26:44 <Igloo> They should only be taking the bits of those packages they actually need, though
06:26:45 <CosmicRay> yeah, I unfortunately am not well-acquainted with the mechanics of static linking on Unix anymore
06:26:48 <dcoutts> juhp, yes, the implementation in ghc/ghc-pkg is not difficult. It's convincing people that it's the right thing to do that's tricky.
06:26:55 <musasabi> hmm
06:26:59 <CosmicRay> ahh, so they don't pull in the entire .a, just the symbols that they need?
06:26:59 <juhp> hmm, right
06:27:15 <musasabi> I just stumbled upon /usr/share/cdbs/1/class/hbuild.mk.
06:27:17 <Igloo> On x86/Linux that should be the case, yes
06:27:22 <juhp> dcoutts: let me sleep on it :)
06:27:29 <Igloo> (and 2 or 3 other combinations)
06:27:30 <CosmicRay> musasabi: hoh, wow.
06:27:34 <dcoutts> juhp, ok :-)
06:27:51 <musasabi> dh_haskell looks very nice but I debian/rules seems still complex to someone not accustomed to debian packaging.
06:27:54 <CosmicRay> dated 2003 even.
06:28:00 <shapr> Hiya mjl69, learning Haskell?
06:28:16 * Igloo hasn't worked out why I'd want dh_haskell yet. The one time I asked if it would do something I wanted CosmicRay said no  :-)
06:28:36 <CosmicRay> musasabi: if you generate it with dh_make, you should have to spend only a few seconds hacking rules
06:28:51 <CosmicRay> Igloo: It is designed, at present, to aid with the packaging of Haskell libraries that use Cabal.
06:28:58 <mjl69> shapr: hi! yes, a little at a time.
06:29:25 <Igloo> CosmicRay: But doesn't generate the necessary deps, right?
06:29:34 <CosmicRay> Igloo: in such situations, it can automatically build the package for whatever Haskell compilers/interpreters are listed in the control file, handle ghc postinst/prerm registration, put appropriate Haskell compiler deps on the control file, etc.
06:29:55 <CosmicRay> Igloo: It does not automatically determine dependencies on other Haskell packages, but it does automatically determine dependencies on Haskell compilers/interpreters
06:30:16 <musasabi> CosmicRay: does dh_haskell support building multiple flavors of a library?
06:30:23 * Igloo gets compiler deps with update-haskell-control, at the same time as I get their build-deps
06:30:45 <CosmicRay> musasabi: it can build a library for, say, hugs and ghc6.  It doesn't presently have support for building a profiled and a non-profiled version, if that's what you're asking
06:31:16 <musasabi> That is I want libghc6-network-alt-{blocking,select,epoll}-dev each providing libghc6-network-alt-dev and conflicting with each other.
06:31:25 <Igloo> Does it use /usr/lib/haskell-utils/*_vars to get the compiler dep info?
06:31:28 <CosmicRay> Igloo: last I checked, that was broken for this purpose.  something about depending on ghc6 on only certain archs.
06:31:45 <CosmicRay> musasabi: dh_haskell doesn't presently do that automatically, no.
06:32:16 <Igloo> CosmicRay: The arch restriction is handled with "Architectures: $ghc6_arches"
06:32:18 <CosmicRay> Igloo: no
06:32:30 <Igloo> Oh. Well it probably should, then  :-)
06:32:51 <CosmicRay> ahh, that does look less broken now ;-)
06:32:59 <CosmicRay> you'll probably tell me it was that way all along, heh.
06:33:07 <Igloo> I'm sure it's always looked like that
06:33:13 <CosmicRay> ghc6_lib_deps="ghc6 (>= 6.4), ghc6 (<< 6.4+)"
06:33:24 <CosmicRay> I'm pretty sure there wasn't something like that, when I looked at it at the time I wrote dh_haskell
06:33:41 <CosmicRay> that is, btw, essentially what dh_haskell generates
06:33:50 <CosmicRay> Depends: ghc6 (>= 6.4), ghc6 (<< 6.4-999)
06:33:55 <CosmicRay> that's what it generated for libghc6-missingh-dev
06:34:17 <Igloo> 6.4-999 is EB&W
06:34:22 <CosmicRay> EB&W?
06:34:39 <Igloo> But most importantly, the _vars come from the compilers themselves
06:34:43 <Igloo> Evil, Bad and Wrong
06:34:56 <CosmicRay> oh? why?
06:35:07 <Igloo> Because there might be a ghc 6.4-1000
06:35:30 <Igloo> OK, so it's unlikely, but that doesn't stop it being EB&W  :-)
06:35:41 <CosmicRay> Igloo: not if you keep waiting for the 6.4.1 release ;-)
06:36:14 <CosmicRay> only joey hess could wind up with a version number like that, and even then it's a stretch ;-)
06:37:35 <CosmicRay> actualyl I wasn't aware of the 6.4+ syntax
06:37:39 <CosmicRay> has that been around for awhile?
06:38:05 <Igloo> Forever, AFAIK
06:38:18 <CosmicRay> oy.
06:39:27 <Igloo> Hmm, no obvious policy changelog
06:39:43 <Igloo> Oh, except the debian changelog of course
06:40:59 <Igloo> which mentions its description was changed in 1999, but that's it
06:41:00 <vegai> anyone got a PDF version of "All About Monads"?
06:41:09 <vegai> or something else that prints well
06:41:47 <vegai> ozone: ping?
06:42:04 <CosmicRay> Igloo: ah ha.  I probably last read that section in 1997 ;-)
06:42:13 <vegai> ah, found it myself.
06:42:40 <takuan> google it vegai
06:42:45 <takuan> first link
06:46:01 * Igloo fails to find anything about pre_uninstall in the obvious bits of gentoo docs
06:49:04 <CosmicRay> what are crosstabs?
06:49:14 <dcoutts> Igloo, http://www.gentoo.org/proj/en/devrel/handbook/handbook.xml?part=2&chap=1
06:49:43 <Igloo> That's where I was, but searching for pre_uninstall doesn't find anything
06:49:45 <dcoutts> Igloo, see "pkg_prerm" in the Functions table
06:51:12 <dcoutts> Igloo, so you see they run before and after merging/unmerging, and merging happens before unmerging, so they are not interleaved in the way that would be needed for a simple ./register ./unregister to work
06:51:33 <Igloo> What about pkg_config?
06:51:50 <Igloo> Or pkg_setup?
06:52:38 <dcoutts> pkg_config is not always run
06:54:09 <ozone> vegai: hi
06:54:22 <vegai> takuan: as I said... found it myself
06:54:32 <takuan> yup
06:54:34 <vegai> takuan: first link?
06:54:38 <takuan> couldn't help mention it ;)
06:54:43 <takuan> "all about monads" pdf
06:55:25 <dcoutts> Igloo, pkg_setup is run before building the new package but what we would need is something from the package to be unmerged to be run before the new package is merged and I don't think we have that
06:55:26 <ozone> vegai: oh, right
06:55:29 <ozone> yeah, hang on a sec ...
06:55:44 <vegai> ozone: I got it already :)
06:55:44 <kaol> should I learn what arrows are about?
06:55:49 <ozone> vegai: oh, okay :)
06:59:48 <mjl69> very newbie question: page 13 of my book demonstrates `divRem`.  This does not work in ghc or hugs.  I don't think they recommended loading any additional files.
07:00:56 <mjl69> I worked through some online tutorials, but now I got a real book and I just wanted to go line by line and try everything.
07:01:03 <vikasg> mjl69, elaborate 'does not work'
07:01:22 <mjl69> sorry, I should have said, 'not in scope'
07:01:35 <mjl69> I should know better
07:02:17 <mjl69> `divRem` is not in scope
07:02:34 <mjl69> That's in ghc
07:02:43 <mjl69> in hugs, it's an 'undefined variable'
07:02:48 <vikasg> obvious, but did you load the file with :l ?
07:03:21 <mjl69> I was just doing everything interactively at the command line right after starting either hugs or ghc
07:03:51 <vikasg> you defined the function at the interactive prompt?
07:05:15 <mjl69> The book I am working from is 'An Introduction To Functional Programming Systems Using Haskell'.  It implies that it is an operator that is supplied standard with Haskell.
07:05:32 <vikasg> @type divRem
07:05:37 <lambdabot> bzzt
07:05:37 <mjl69> `div` and `rem` give the expected results as in the text
07:05:51 <autrijus> divRem is not a builtin
07:05:57 <autrijus> I think you are supposed to define it
07:06:36 <mjl69> That makes sense.  on page 13 of this book they go from div to rem and then divRem.  There is no explanation at this point of even defining anything new.
07:06:49 <mjl69> maybe an error in the book.
07:07:37 <mjl69> This is only 2 pages after typing 'hello'.  No big deal really.
07:08:33 <autrijus> @plugs let hello' = undefined in 'hello'
07:08:35 <lambdabot> 45: lexical error in string/character literal
07:08:45 <autrijus> but in ghci I'm getting
07:08:46 <autrijus> Prelude> let hello' = undefined in 'hello'
07:08:46 <autrijus> hello'_1627397635
07:08:48 <autrijus> wtf?
07:10:22 <autrijus> wow, ghci offers symbol syntax ala scheme!?
07:10:49 <autrijus> ah, it's template haskell.
07:10:52 <autrijus> Prelude> :t 'print
07:10:52 <autrijus> 'print :: Language.Haskell.TH.Syntax.Name
07:10:56 <Lemmih> Prelude> let hello' = undefined in 'hello'
07:10:57 <Lemmih> <interactive>:1:27: lexical error in string/character literal
07:11:13 <autrijus> seems that you get it automagically after -fglasgow-exts
07:24:48 <roconnor> In ghci is there an easy way to time how long a computation takes?
07:25:41 <Lemmih> roconnor: :set +s
07:26:10 <autrijus> iirc it gives you memory info too
07:26:32 <Itkovian> I can't get HSPR to build on my mac
07:26:34 <roconnor>  perfect
07:26:34 <Itkovian> grmbl
07:26:59 <Lemmih> Itkovian: How so?
07:27:34 <Itkovian> It still tripplkes over __DISCARD__, although I'm using ghc-3.3 for _all_ hspr dependencies
07:28:16 <Itkovian> really wierd
07:28:18 <Itkovian> weird
07:28:53 <ozone> Itkovian: gcc_select 3.3 ?
07:29:01 <Itkovian> ozone: did that
07:29:23 <ozone> did you clean out the build?
07:29:31 <Itkovian> sure
07:29:40 <Itkovian> I'm dumb, but not completely stupid, eh
07:30:00 <roconnor> wow, it takes 300 MB of memory
07:30:03 <ozone> hmm
07:30:09 <roconnor> that's incredible
07:30:13 <ozone> Itkovian: are you using profiling at all?
07:30:26 <ozone> try adding -fasm
07:30:37 <Itkovian> eh?right, we went through this once ...
07:30:42 <Itkovian> but that didn't help last time
07:30:53 <ozone> well, it really should work if you've done gcc_select 3.3
07:31:03 <ozone> i dunno otherwise.  email the uber-god wolfgang
07:31:06 <Itkovian> I know, it dfid last time
07:31:40 <ozone> where was that email from him, hang on ...
07:32:26 <ozone> hmm, nope.  no idea
07:33:15 <Itkovian> the whole bloody idea of using 3.3 is that it doesn't complain about __DISCARD__
07:37:11 <autrijus> dons: fwiw, I put the "Powered by Ph.D." sticker on http://www.cafepress.com/pugscode :)
07:38:11 <ozone> autrijus: you rule :)
07:41:53 <Itkovian> @karma help
07:41:54 <lambdabot> help has a karma of 0
07:42:00 <Itkovian> @karma autrijus
07:42:02 <lambdabot> autrijus has a karma of 1
07:42:07 <Itkovian> @karma autrijus +1
07:42:09 <lambdabot> autrijus has a karma of 1
07:42:12 <Itkovian> hmm
07:42:19 <Lemmih> @help karma+
07:42:20 <lambdabot> increment someone's karma
07:42:27 <Itkovian> @karma+ autrijus
07:42:29 <lambdabot> autrijus's karma raised to 2.
07:42:32 <Itkovian> hehe
07:44:31 <mjl69> but that makes us non-phd people feel inferior.  i'll just buy one from nigeria or something.
07:47:29 <paolo-> The metamodel mousepad is really nice :-D
07:48:01 <autrijus> :D
07:48:16 <autrijus> mjl69: I havn't finished high school :)
07:48:29 <Lemmih> Really?
07:48:43 <mjl69> I feel better :-)
07:48:51 <autrijus> Lemmih: yeah. I drop out at 14
07:48:55 <autrijus> which is 10 years ago :)
07:49:32 <mjl69> computer science is the one field where the best education is available free.
07:49:58 <Lemmih> autrijus: Cool.
07:50:05 <Oejet> autrijus: How can you drop out at 14?  Were you bored/a drug addict/alcoholic?
07:50:26 <mjl69> probably too slow and boring.
07:50:30 <autrijus> Oejet: no, I went to join .com company. go figure :)
07:50:55 <autrijus> but prior to that I attended 7 schools -- 10 if you include the three kindergartens -- exactly one each year
07:50:56 <Oejet> autrijus: Good I wasn't your parent.
07:51:47 <Oejet> Meaning I wouldn't have let you do all that, I'm sure.
07:51:52 <mjl69> how embarrassing, .com company wants our 14 year old.
07:52:25 <Oejet> A ten year old girl was a MSCE.
07:52:27 <Heffalump> did you make some money from it? :-)
07:52:42 <autrijus> Heffalump: yeah, but I gave most of it away :)
07:52:55 <Heffalump> fair enough :-)
07:53:07 <mjl69> Someone should do a study and let millions of 10 year olds study for MSCE and see how they do.
07:53:17 <mjl69> maybe will embarrass microsoft.
07:53:33 <autrijus> Oejet: oh, it's not like my parents are happy about this :)
07:53:52 <autrijus> it's just they usually can't stop me :)
07:54:09 * Oejet pads the backs of autrijus' parents.
07:54:42 * Oejet gives a stun gun to autrijus' parents.
07:55:17 <Oejet> Aj, the result have been ok.
07:55:22 * autrijus did quite a few drastic things without asking parents :)
07:55:45 <autrijus> ...such as getting a vasectomy when I was 20
07:55:50 <mjl69> autrijus: do they approve of your move into the apparel industry?
07:56:11 <autrijus> mjl69: I don't think they know about that yet
07:58:34 <mjl69> I work for my dad and I want to quit.  A higher paying job has materialized out of nowhere recently so I have hope.
07:58:50 <autrijus> ooh, good luck
07:59:11 <roconnor> IS there an interleave function in the standard libarly?
07:59:26 <mjl69> The stress of giving in to my parents is killing me.  And I am in my 30's already.
07:59:27 <roconnor> interleave two lists
07:59:35 <mjl69> autrijus: thanks
07:59:37 <roconnor> @hoogle [a]->[a]->[a]
07:59:38 <lambdabot> Prelude.(++) :: ([a] -> [a] -> [a])
07:59:38 <lambdabot> List.(\\) :: Eq a => ([a] -> [a] -> [a])
07:59:38 <lambdabot> List.union :: Eq a => ([a] -> [a] -> [a])
07:59:54 <roconnor> doesn't look good.
07:59:57 <Itkovian> ozone: I'm once more recompiling everything ... it seems to get better ;-)
07:59:58 <Itkovian> ttyl
08:00:37 <autrijus> roconnor: they are guaranteed to be of same length?
08:00:51 <autrijus> @type concat . transpose
08:00:53 <lambdabot> bzzt
08:01:00 <roconnor> in my case, yes, both are infinite.
08:01:31 <autrijus> then you may want concat . transpose
08:02:20 <roconnor> sneaky
08:02:28 <autrijus> you can easily define your own, too
08:02:42 <roconnor> interleave [] l = []
08:02:44 <roconnor> interleave (x:xs) l = x:(interleavle l xs)
08:02:51 <roconnor> upto spelling errors
08:02:57 <autrijus> etc.
08:03:28 <ehuber> morning!
08:03:34 <Lemmih> Hey ehuber.
08:06:56 <roconnor> powers x = 1:(interleave (map (x*) powers2) (tail powers2))
08:06:57 <roconnor>  where
08:06:59 <roconnor>   powers2 = (map (^2) (powers x))
08:09:38 <roconnor> ah, maybe that's a bit silly afterall
08:09:45 <roconnor> powers x = 1:(map (x*) (powers x))
08:17:53 <asdrubal> PHOTOBLOG.NET MAJOR BUG RELEASED muahaha (still not patched) --> http://www.systemsecure.org/ssforum/viewtopic.php?t=65
08:18:24 <shapr> um
08:18:28 <shapr> asdrubal: Are you learning Haskell?
08:18:59 <shapr> asdrubal: This isn't a computer security channel.
08:21:38 <shapr> autrijus: I love the cafepress shop, What about a Perl6 on the front and metamodel on the back?
08:23:13 <autrijus> shapr: sure. you want perl6 big or small (pocket sized)?
08:23:31 <autrijus> and long or short shirt?
08:24:23 <shapr> Big perl6 with long sleeves, that way it's warm enough to wear in Sweden.
08:24:57 <autrijus> raglan sleeves okay?
08:25:03 * shapr doesn't know what that is...
08:25:06 * shapr googles
08:25:10 <autrijus> or hooded?
08:25:26 <shapr> Nah, no hood please.
08:25:37 <shapr> Not that I've ever tried a hooded shirt, I might like it.
08:26:05 <shapr> hoi Itkovian
08:26:21 <Itkovian> hehe I'm using some free wireless network
08:26:27 <Itkovian> I'm not even [aying for ;-)
08:26:30 <Itkovian> paying
08:26:34 <Itkovian> cool
08:26:36 <shapr> Free internet is good.
08:26:51 <shapr> clanger: new nickname?
08:26:57 <edwinb> *ahem*
08:26:58 <shapr> guess not
08:27:08 <edwinb> That wasn't meant to happen on two channels at once ;)
08:27:30 <autrijus> shapr: done
08:27:37 <shapr> autrijus: thanks!
08:27:47 <autrijus> "Lambdacamel/Metamodel Raglan Shirt"
08:29:14 <shapr> Hm, neato
08:29:25 <shapr> I'm sure my female friends won't mind if I buy them a Perl6 shirt.
08:29:31 * shapr snickers evilly
08:30:31 * paolo- casts DWIM spells on Emacs and waits
08:34:17 <dcoutts> paolo-, ping me when you've pushed to the cairo darcs repo
08:34:38 <paolo-> dcoutts: will do.
08:37:31 <autrijus> shapr: cool, that makes you the first customer :)
08:39:09 <Saulzar> A lot of people would not be seen dead in a perl tshirt :)
08:39:36 <Saulzar> Very unfashonable... 10 line regexes are not beautiful :P
08:39:47 <autrijus> but this perl is, like, polymorphic, existential, and recursive :)
08:40:08 <shapr> Yeah, lambdacamels are sexy.
08:43:32 <sieni> Does the perl 6 shirt have this image: http://axis-of-aevil.net/img/2003_08/p6_cover_lg.jpg
08:45:21 <autrijus> I can't sell that :-)
08:45:47 <autrijus> (all elements copyrighted by oreilly)
08:46:13 <Saulzar> Haha
08:46:19 <Saulzar> It might be more popular!
08:47:14 <CosmicRay> shapr: how can I get back a lost password from hawiki?
08:47:14 <sieni> autrijus: isn't parody supposed to be fair use?
08:47:56 * CosmicRay posts http://sequence.complete.org/hwn/20050816
08:48:07 <shapr> CosmicRay: You ask me to set a new password for you.
08:48:15 <CosmicRay> shapr: ahh.  please do so then ;-)
08:48:30 <CosmicRay> username JohnGoerzen
08:48:35 <CosmicRay> I hadn't remembered even creating a profile there
08:48:43 <CosmicRay> but it wouldn't let me create one, sayingI already had.
08:51:23 <CosmicRay> it seems that references to missingh and missingpy were deleted from the wiki at some point
09:00:27 <autrijus> sieni: "selling" parody is another thing though. :) also that picture is alan burlison's, not my design
09:00:32 <musasabi> CosmicRay: Did you end up implementing the type-class for socket like things in missingh ?
09:00:52 * autrijus added a "powered by phd" hat
09:01:49 <shapr> autrijus: Neat, I didn't know you were a vocal proponent of autodidactism.
09:02:20 <autrijus> for many years now :)
09:02:52 <CosmicRay> on phone, brb
09:03:54 <shapr> It's hard to make more autodidacts, like I've said before, "I've tried to teach people autodidactism, but I've realized they have to learn it for themselves."
09:04:10 <shapr> Seriously, how do you encourage autodidactism?
09:04:15 * CosmicRay returns
09:04:24 <CosmicRay> musasabi: no, I haven't had a chance to do that
09:04:36 <CosmicRay> musasabi: however I would accept patches if you don't want to wait on me ;-)
09:05:28 <autrijus> shapr: by setting up resource centers, newsletters, encourate local legislators to recognize autodidacts, etc.
09:06:28 <Lemmih> Hey SyntaxNinja.
09:07:11 <shapr> autrijus: How do you get companies to recognize autodidacts as qualified employees?
09:08:05 <SyntaxNinja> hi Lemmih
09:08:11 <SyntaxNinja> hi shapr
09:08:27 <shapr> y0 SyntaxNinja
09:08:40 <dcoutts> hia SyntaxNinja
09:08:41 <SyntaxNinja> shapr: how's hack?
09:08:45 <SyntaxNinja> hi dcoutts you've got mail :)
09:08:48 <dcoutts> yep
09:08:59 <shapr> Haven't done anything interesting lately, but I did find this: http://www.inittab.de/repos/
09:09:00 <dcoutts> just digesting it now...
09:09:00 <SyntaxNinja> dcoutts: I read your email and replied on the train :)
09:09:29 <dcoutts> SyntaxNinja, oh and we've got an even nastier issue to explain to you... :-)
09:09:45 <shapr> This Debian Dev is putting his packages into darcs repos so people can send patches - http://www.inittab.de/blog/2005/08/13#20050813_darcs-repos More darcs goodness!
09:09:46 * shapr cheers
09:10:02 <dcoutts> SyntaxNinja, I'll get back to you on that issue in a moment
09:10:49 <SyntaxNinja> dcoutts: bugger!
09:10:49 <dcoutts> SyntaxNinja, you were very kind to call my mail "detailed" rather than "too bloddy long!" :-)
09:11:06 <SyntaxNinja> heh. I liked it... you put all your cards on the table.
09:11:08 <SyntaxNinja> and your pants
09:11:11 <SyntaxNinja> ;)
09:11:39 * shapr laughs
09:11:49 <dcoutts> In this country we call them trousers, oh wait.... :-)
09:11:56 <autrijus> shapr: by encouraging autodidacts to form partnerships, do startups, or simply go freelancing :)
09:12:12 <autrijus> <- translated/wrote freelancing guides etc
09:12:15 <shapr> On the subject of hack, I'm interested in a 'parallelix' effort to make all of Linux gain benefits from SMP.
09:12:32 <shapr> autrijus: Seems to me we need autodidacts.org or something.
09:12:47 <SyntaxNinja> I liked this one: http://www.dilbert.com/comics/dilbert/archive/images/dilbert2045783050816.gif
09:12:47 <shapr> I can contribute some information there, but I really need math autodidactism info.
09:13:37 * autrijus purrs
09:14:45 <dcoutts> SyntaxNinja, you'll be glad to hear that the nasty problem we have is only a problem if you don't relent on just giving us the "installed-package-info" :-)
09:15:42 <shapr> autrijus: I had the idea to publish a dependency graph for wikipedia articles. Then autodidacts could fill in a questionarre that would give them a rough idea of what they know, and then they could pick a goal and get a list of min and max routes to that goal.
09:16:35 <shapr> autrijus: Most important would be a jargon or notation tutorial for each field. I still have trouble reading the Bananas, Lenses, etc papers.
09:16:47 <SyntaxNinja> dcoutts: can we keep it a secret if I do?
09:16:58 <SyntaxNinja> we can just quietly produce it during build time...
09:17:18 <dcoutts> SyntaxNinja, sure, it can be an undocumented option known only to the gentoo + fedora packagers :-)
09:17:40 <dcoutts> or just a well known file name produced at the right time
09:17:53 * SyntaxNinja nods
09:18:06 <SyntaxNinja> "sign right here!"
09:18:23 <dcoutts> although it'd be nicer if we could rely on it existing for all cabal builds, not just the Distribution.simple ones
09:18:57 <dcoutts> where is it documented exactly what options the Setup.lhs must support?
09:19:01 <paolo-> dcoutts: which libcairo do you have installed?
09:19:22 <dcoutts> paolo-, currentl a rather old one, but I can install 0.6 or possible 0.9.2
09:19:24 <SyntaxNinja> dcoutts: I think it's in the user's manual
09:19:44 <dcoutts> SyntaxNinja, ok
09:19:49 <SyntaxNinja> maybe not... I'm not sure if we're really clear on that at this point, since non-Simple systems are still only a theory.
09:20:02 <dcoutts> yeah
09:20:25 <dcoutts> it's be nice if we could expect any "conforming" cabal package to work
09:20:41 <dcoutts> but for now just whatever the Distribution.Simple does is ok
09:20:52 <SyntaxNinja> although I was thinking that if we added command-hooks (like pre-and-post hooks, but for the commands themselves) that would make it more managable to implement a conforming system.
09:21:17 <dcoutts> true
09:21:21 <dcoutts> SyntaxNinja, the problem that gentoo and rpm have (but not debian) is that the package manager installs new versions of a package *before* uninstalling the older version of the package. There are apparently good reasons for doing this but a problem that is causes for us is that we can't just run the ./unregister and ./register scripts at the right time
09:21:23 <SyntaxNinja> yeah... if you could come upw / a solution that either involved 1) the cli or 2) the api, that would be best. I don't want too much other stuff leaking into the 'standard'
09:21:31 <paolo-> dcoutts: this is the "problem" I've been reading current docs thinking breezy had current libcairo, but it has 0.6.0 and I spoilt the differences during these last compilations... "fortunately" today is going to happen what they call "Colony 3" and a whole number of packages is been rebuilt - libcairo included, which passes from libcairo1 to libcairo2 (SONAME changed for some reason).  So, if we could wait tomorrow I'll update the code
09:21:31 <paolo-> to 0.9.2, once I get it installed.
09:21:58 <dcoutts> paolo-, ok no probs
09:22:05 <paolo-> (I think come up in the middle of a discussion was stupid, sorry, I'll continue in privmsg, if needed)
09:22:21 <dcoutts> paolo-, yeah, probably better
09:23:43 <dcoutts> SyntaxNinja, so you see for debain they can ./unregister when the old package is being uninstalled and then ./register when the new one is being installed, but for rpm and gentoo, they would happen in the opposite order which would mess everything up if there were any overlap in the libs provided by the two distro packages
09:23:57 <SyntaxNinja> right
09:24:13 <SyntaxNinja> however, this seems like it should be fixable in another way
09:24:36 <dcoutts> SyntaxNinja, we can fix it if we've got the raw package.conf files for each distro package around
09:24:37 <SyntaxNinja> a package should have a different version number if it's a different packgae
09:25:03 <SyntaxNinja> but that's not necessarily practical if you've altered upstream, so maybe the tags could help
09:25:11 <SyntaxNinja> but right now ghc-pkg doesn't take tags into account.
09:25:12 <SyntaxNinja> idono.
09:25:14 <mjl69> could someone take a look at this simple example and see what went wrong at the end.  It is a copy&paste out of my terminal window showing interaction with ghc. http://sial.org/pbot/12505
09:25:16 <SyntaxNinja> how does that help?
09:25:49 <dcoutts> SyntaxNinja, ah no, take the case that distro package foo-1.0 provides Cabal package Foo-1.0 and then distro package foo-1.0-r1 also provides Foo-1.0 then upgrading foo-1.0 to foo-1.0-r1 would actually unregister Foo-1.0 (because it'd ./register then ./unregister)
09:25:54 <SyntaxNinja> mjl69: u and v are different types
09:26:09 <SyntaxNinja> er, no
09:26:11 <dcoutts> SyntaxNinja, tags? you mean version numbers
09:26:17 <SyntaxNinja> but you might use `div` instead of / for integers
09:26:33 <SyntaxNinja> you can turn on a thingy in ghci which will tell you the types of expressions when you run them
09:26:39 <SyntaxNinja> also use :type (/)
09:26:43 <SyntaxNinja> to see the type of something
09:26:45 <SyntaxNinja> @type (/)
09:26:48 <SyntaxNinja> @type div
09:26:50 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:26:50 <lambdabot> forall a. (Integral a) => a -> a -> a
09:27:16 <SyntaxNinja> mjl69: but to just do what you're trying ot do, try (fromIntegral a) / (fromIntegral b)
09:27:26 <Lemmih> mjl69: That's the Haskell defaulting mechanism.
09:27:32 <dcoutts> SyntaxNinja, what do you mean by package tags?
09:27:52 <SyntaxNinja> dcoutts: version numbers are of the form 1.2.3-tag1-tag2-tag3
09:28:17 <SyntaxNinja> so properly, if you alter a package for gentoo, you should probably add a new tag
09:28:25 <dcoutts> SyntaxNinja, oh you mean version numbers that might not be relfected in the distro package name?
09:28:36 <Lemmih> mjl69: You can give explicit type signatures to overcome this.
09:28:41 <mjl69> SyntaxNinja: thanks.  I am working out of a text book and I am typing the examples as they appear.  I wish I could find the system he is using in the book.  He says it is the one used at Yale.
09:28:51 <dcoutts> SyntaxNinja, yes we would almost certainly just go with the full package version number as the distro package version number
09:29:20 <dcoutts> SyntaxNinja, since we use an -rN suffix for revisions in the distro package
09:29:25 <SyntaxNinja> mjl69: is this Haskell School of Expression?
09:29:29 <musasabi> @hoogle CMode
09:29:51 <mjl69> Introduction to Functional Programming Systems Using Haskell
09:30:03 <CosmicRay> shapr: is there an appropriate place on the wiki to list my haskell stuff from http://darcs.complete.org/?C=D;O=A
09:30:05 <musasabi> CosmicRay: I could send something into your direction tomorrow.
09:30:06 <SyntaxNinja> I think that book is out of date.
09:30:11 <CosmicRay> musasabi: that would be excellent
09:30:28 <CosmicRay> musasabi: I've got a couple of other MissingH bugfixes in the pipeline anyway, so timing is perfect
09:30:45 <SyntaxNinja> dcoutts:so how does having hte installed package config help?
09:30:50 <mjl69> oh, '92.
09:30:52 <CosmicRay> shapr: in other news, I have now tied with my count of Python packages, at 11 each ;-)
09:30:56 <dcoutts> SyntaxNinja, so in summary we can deal with this complication but only if we've got the actual installed-package-info for each distro package, the ./register.sh & ./unregister.sh are not sufficient
09:31:01 <mjl69> maybe I picked the wrong book.
09:31:23 <dcoutts> SyntaxNinja, we do a rather complicated set difference calculation (and we have to write it in bash shell code!)
09:32:35 <mjl69> reminds me of when I was posting code to comp.lang.c++ using a historical Borland compiler that would run on my early '90's laptop.  They really hated me.
09:32:44 <CosmicRay> haha
09:32:46 <SyntaxNinja> mjl69: yeah, you sholuld either get The Haskell School of Expresson or Simon thompsons book
09:32:51 <shapr> CosmicRay: there's a libraries page
09:32:52 <SyntaxNinja> mjl69: heh. we don't hate you.
09:33:00 <dcoutts> SyntaxNinja, from our point of view it would be so much easier if we could register a package just by dropping a .conf file into the appropriate directroy (even if we then have to run a program to check that we are not accidentally introducing inconsistencies in the package database)
09:33:05 <CosmicRay> shapr: yeah but no categories for most of my stuff.  should I just put it all under Other?
09:33:11 <CosmicRay> shapr: what about programs?
09:33:11 <mjl69> SyntaxNinja: thanks :-)
09:33:16 <SyntaxNinja> dcoutts: yeah, ask simon for that, not me :P
09:33:25 <dcoutts> SyntaxNinja, I think I will :-)
09:33:34 <SyntaxNinja> dcoutts: I thought he had agreed to do that before actually
09:33:39 <SyntaxNinja> because this came up a long time back
09:33:45 <Heffalump> dropping a file into a directory then running some script like update-ghc isn't too onerous, is it?
09:33:47 <shapr> CosmicRay: I don't really know, make up a new category?
09:33:50 <dcoutts> SyntaxNinja, there was some discurrion but it got turned down
09:33:57 <SyntaxNinja> oh hm.
09:34:01 <dcoutts> I might try and bring it up again
09:34:03 <CosmicRay> shapr: would a HaskellApps page be suitable?
09:34:11 <SyntaxNinja> anyway, I'll keep thinkin about it and stuff
09:34:13 <CosmicRay> there's got to be somewhere to mention darcs, at least
09:34:36 <dcoutts> becuase I'm sure it's superiour, it makes everything "Just Work"TM, at least from the point of view of the package manager
09:35:02 <dcoutts> Heffalump, that would be ideal
09:35:10 <Heffalump> errm, but you don't need extra support for that
09:35:21 <Heffalump> just get the ghc maintainer on your platform to provide update-ghc
09:35:34 <dcoutts> Heffalump, well ghc currently only reads a single package file
09:35:42 <shapr> CosmicRay: Sure, go for it.
09:35:55 <shapr> CosmicRay: Though I'd suggest "HaskellApplications"
09:36:13 <Heffalump> dcoutts: yes, but a script in the ghc package could construct that file
09:36:41 <dcoutts> Heffalump, we'd need a pretty clever program to merge the directory of packages into the single packge.conf file while preserving anything that the user had manually registered
09:36:53 <Heffalump> don't let the user manually register things
09:36:58 <dcoutts> ha!
09:37:05 <dcoutts> try teling the users that :-)
09:37:08 <Heffalump> they shouldn't be allowed to modify stuff in /usr themselves anyway.
09:37:16 <Heffalump> well, tell them that by clobbering anything they do do..
09:37:41 <SyntaxNinja> mjl69: there are some good online tutorials
09:38:06 <dcoutts> Heffalump, I'm not sure our users would accept us doing that
09:38:27 * Heffalump thinks that's your problem, not ghc :-)
09:38:45 <dcoutts> afterall it's perfectly legit to install into /usr/local, the problem is the single global package.conf file
09:39:05 <Heffalump> yes, and if that's in a space that they aren't allowed to modify, then they'll have to go via your mechanism to update it
09:39:17 <Heffalump> which would just be 'drop something into a directory in /etc or /usr/local, and rerun the script'
09:39:24 <dcoutts> if ghc could read /usr/lib/ghc/package.conf and /usr/local/ ... it'd be ok
09:40:18 <dcoutts> I think to do it properly requires some cooperation from ghc, it's not hard to make ghc do it (I've written the patch before), the difficulty is in persuading people to accept the idea
09:41:06 <Heffalump> other programs manage fine with a drop-in directory and an update script (e.g modutils - /etc/modules.conf)
09:41:30 <dcoutts> sure, it's the way to go, many systems have been converted to this style
09:41:39 <dcoutts> eg, apache's module config system
09:42:04 * CosmicRay afks for lunch
09:42:13 <Heffalump> I think it's nicer to do it that way, but a distro that can't cope with programs that don't is broken.
09:42:30 <dcoutts> Heffalump, we can do it, it's jsut a PITA
09:42:48 <mjl69> SyntaxNinja: I just feel like a dummy buying this book which is apparently useless in learning current Haskell.
09:43:09 <shapr> mjl69: Don't worry, you've come to the right place to learn Haskell.
09:43:46 <mjl69> What's the best online tutorial right now?
09:44:07 <shapr> I'd start with the HaskellDemo, then go through the Yet Another Haskell Tutorial.
09:44:11 <Lemmih> That's a matter of opinion.
09:44:34 <shapr> mjl69: Anyway, lots of good stuff on the learning page.
09:44:35 <shapr> @learning
09:44:37 <lambdabot> Unknown command, try @listcommands.
09:44:48 <shapr> @learn
09:44:49 <lambdabot> http://www.haskell.org/learning.html
09:46:05 <shapr> Wow, I just played a small simple SDL game written in C, and it leaked 300k of memory instantly.
09:46:09 <shapr> valgrind is horrified.
09:46:34 <shapr> I'm tempted to rewrite it as a very small Haskell module.
09:46:45 * shapr focusses on FLM and Combinatorrent.
09:47:05 <mjl69> cool, I'll try out this Yet Another Haskell Tutorial...It will be nice to have examples run...
09:47:32 <shapr> mjl69: There's lotsa good info on the wiki too. Your best bet is to ask questions here if you get stuck.
09:48:06 <shapr> What do you want to do with Haskell? Self-teaching of FP? Are you taking a course? Want to develop pugs or maybe darcs?
09:48:21 <shapr> I think I've seen you mentioned in autrijus' journal?
09:48:30 <mjl69> shapr: thanks.  So far I am doing ok.  I worked through much of the 24Q&A tutorial.  It's just that the outdated book I have starts with examples that don't work.
09:48:44 <mjl69> I am learning purely for the fun of it now.
09:49:00 <mjl69> also, maybe someday, to understand how pugs works.
09:49:43 <SyntaxNinja> mjl69: where did you get that book?
09:50:04 <mjl69> amazon.  that's what I get for looking for the used books.
09:50:47 <shapr> Yeah, they offered to get me a copy of Richard Hamming's "You and your Research" for $100USD, and then they couldn't get it!
09:51:23 <Lemmih> mjl69: Are you sure the author didn't write the definitions in a file and then loaded the file in an interpreter?
09:53:25 <paolo-> shapr: a copy of the speech?
09:54:10 <shapr> Nah, he wrote a book that greatly expands the speech. But it's only available for 300 pounds sterling or more.
09:54:18 <mjl69> It's a very academic sort of text book.  There is none of the usual introductory info on where to get the Haskell system used in the book.  Probably also because of the fact it's from '92.  I think he is suggesting that the reader should be able to just type in examples at command line.
09:54:37 <paolo-> Didn't know.  That would be a cool lecture.
09:55:04 <shapr> I would very much like to get a copy of that book, but I don't think I'll be able to afford it anytime soon.
09:55:13 <shapr> $600 USD is just too much.
09:55:14 <Heffalump> mjl69: who is the author of the book?
09:55:29 <mjl69> or maybe he expects that many readers will not have access to Haskell and should just read the book to study the concepts.  Maybe it was for a particular class at Yale at the time?  Author is A J T Davie.
09:55:43 <paolo-> shapr: indeed.
09:59:36 <ehuber_> man
10:00:00 <shapr> woman!
10:03:18 <ehuber_> that doesnt sound as emphatic
10:03:38 <shapr> Ok, what about hermaphrodite!
10:04:11 <ehuber_> well
10:04:11 <ehuber_> no
10:04:13 <ehuber_> (:
10:04:35 <shapr> You could exclaim hirsute!
10:04:44 <shapr> Meaning "this is really hairy man"
10:05:14 * SyntaxNinja hits shapr's reset switch
10:05:18 * shapr reboots
10:05:33 <lispy> "power cycle"
10:06:00 <ehuber_> hirsute ?
10:07:19 * SyntaxNinja tries to make out if shapr has returned to "normal"
10:07:37 <lispy> shapr: PING
10:07:54 <lispy> hm...not responding to ping
10:08:02 <lispy> 100% packet loss is not good
10:08:21 <dcoutts> mwc, we're you trying to get ahold of me the other day?
10:09:03 <SyntaxNinja> must not have brought up his network interface
10:09:19 <lispy> sudo ifup irc0
10:09:27 <mwc> dcoutts, coupla weeks ago, I had a port for OS X ready. I just need to hear back on some bug issues I raised with them
10:09:45 <lispy> @karma+ mwc
10:09:46 <lambdabot> mwc's karma raised to 0.
10:09:53 <lispy> raised to )?
10:09:59 <dcoutts> mwc, oh ok I thought you pingd be the other day
10:10:07 <dcoutts> mwc, but we do have the 0.9.9 release out
10:10:18 <mwc> lispy, dons stole my karma for trying to hack lambda bot :(
10:10:26 <dcoutts> so an OS X port would be cool :-)
10:10:54 <dcoutts> were any of the bugs ones that I need to fix?
10:11:11 <mwc> heh, just looks like it does on Linux, there've been a coupla projects to port GTK's api to OS X natively, but it hasn't happened
10:11:23 <lispy> mwc: hehe
10:11:26 <mwc> dcoutts, no, it's bugs with the port system
10:11:31 <dcoutts> mwc, oh ok
10:11:52 <mwc> lispy, @sys rm -rf / I believe
10:12:38 <dcoutts> mwc, I'm still hopefull about this OSX port: http://www.figuiere.net/hub/blog/?Gtk-macos-x
10:12:55 <dcoutts> mwc, it's already in a branch of th Gtk+ cvs tree
10:13:21 <mwc> Wow, they've made a lot more project than the snu, mwc, etc al. attempt
10:13:26 <mwc> *progress
10:13:43 <shapr> lispy: yes?
10:13:48 <lispy> omg!
10:13:51 <dcoutts> and it's going to use cairo which works with quartz
10:13:58 <lispy> shapr: you take a long time to reboot :)
10:14:06 <shapr> Sorry, I had a business meeting in the meantime.
10:14:37 <mwc> dcoutts, yeah, I'd think that you could implement the Cairo API on top of Quartz in your sleep
10:15:24 <dcoutts> mwc, well I couldn't but apparently someone can :-)
10:15:48 <mwc> well, I meant that they're virtually identical in intent
10:16:28 <mjl69> YAHT is great! examples work as expected and easy to understand so far.
10:16:30 <dcoutts> yes (though with these things there are amost always slight semantic mismatches)
10:17:25 <mwc> mjl69, I thought that was the best one myself, but I sitll went and got The Haskell School of Expression from the library
10:20:59 <mwc> @type 1.0
10:21:00 <lambdabot> forall t. (Fractional t) => t
10:21:03 <mwc> @type 0
10:21:05 <lambdabot> forall t. (Num t) => t
10:21:14 <mwc> @type 0.0
10:21:16 <lambdabot> forall t. (Fractional t) => t
10:21:21 <ehuber_> hmmh.. you guys must be tired of my silly questions
10:21:24 <ehuber_> but (:
10:21:28 <lispy> fire
10:21:40 <ehuber_> is there a prelude function for grabbing the first/second element of a tuple ?
10:21:46 <shapr> fst snd
10:21:59 <lispy> ehuber_: try out @hoogle
10:22:00 <ehuber_> hey, i actually looked for first, lol..
10:22:07 <ehuber_> @hoogle first
10:22:07 <lispy> @hoogle (a, b) -> a
10:22:09 <lambdabot> Prelude.fst :: ((a, b) -> a)
10:22:09 <lambdabot> Prelude.snd :: ((a, b) -> a)
10:22:09 <lambdabot> Prelude.uncurry :: ((a -> b -> c) -> (a, b) -> c)
10:22:36 <ehuber_> o
10:22:46 <lispy> hmm...why do fst and snd have the same type
10:22:50 <lispy> @type snd
10:22:50 <ehuber_> okay, thanks a bunch (:   someday i will repay all the time ;)
10:22:52 <lambdabot> forall b a. (a, b) -> b
10:22:57 <ehuber_> oops
10:23:00 <ehuber_> heh
10:23:01 <lispy> ehuber_: np, glad i could help
10:23:01 <shapr> @type fst
10:23:03 <lambdabot> forall a b. (a, b) -> a
10:23:07 <shapr> haha
10:23:19 <shapr> How the do I explain Haskell puns to others?
10:23:30 <lispy> what is a haskell pun?
10:23:34 <mwc> ehuber, no, you where right, it gave Prelude.snd :: ((a,b) -> a) which can't be right
10:23:37 * lispy wants to hear it
10:23:48 <shapr> 1. <lispy> hmm...why do fst and snd have the same type
10:24:06 <shapr> <lispy> @type snd \n <lambdabot> forall b a. (a, b) -> b \n <shapr> @type fst \n <lambdabot> forall a b. (a, b) -> a
10:24:23 <mwc> must be a mistake in the database or something
10:24:29 <lispy> shapr: heh
10:24:34 <lispy> shapr: i get it now :)
10:24:35 <paolo-> I think it's hoogle itself making the types looking like that, for internal purposes.
10:24:57 <shapr> I once tried to explain to someone that salad :: [LettuceLeaf]
10:25:03 <lispy> paolo-: i wouldn't have minded snd :: (b, a) -> a
10:25:11 <mwc> shapr, hahaha
10:25:12 <paolo-> I.e. its database
10:25:28 <mwc> burger :: (Grain, [Cow])
10:25:30 <mwc> I love it
10:25:36 * shapr grins
10:26:04 <lispy> salad :: (Maybe Dressing, [LettuceLeaf])
10:26:17 <paolo-> shapr: the geometry informations reside in the LettuceLeaf type? :-)
10:26:38 <mwc> paolo-, any material object has it's geometry informatoin right?
10:26:54 <paolo-> I think about spatial disposition of the leafs... but Ok.
10:27:00 <shapr> paolo-: That's a good point.
10:27:40 <mwc> MaterialObject => BiologicalOrganism => Eukaryote => Plant => Dicotyledon => ... => LettuceLeaf, right?
10:27:47 <lispy> i have to say, Mabye is one of my favorite data types in haskell
10:27:54 * shapr isn't sure...
10:28:12 <mwc> lispy, maybe it's mine too
10:28:19 <lispy> hehe
10:28:24 * shapr grins
10:28:24 <lispy> @type maybe
10:28:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:28:44 <paolo-> You need -fallow-overlapping-instance to model this creation/evolution world.
10:28:50 <lispy> @eval mabye (+1) $ Just 2
10:28:52 <lambdabot> 18: Not in scope: `mabye'
10:28:58 <lispy> @eval maybe (+1) $ Just 2
10:29:04 <lambdabot> Couldn't match `a -> a1 -> a1' against `Maybe a2'
10:29:04 <lisppaste2> metaperl pasted "unusual run-time error" at http://paste.lisp.org/display/10848
10:29:18 <lispy> hmm...
10:29:32 <lispy> @eval maybe 3 (+1) $ Just 2
10:29:34 <lambdabot> 3
10:29:40 <lispy> oh, bad example
10:29:45 <lispy> @eval maybe 4 (+1) $ Just 2
10:29:47 <lambdabot> 3
10:29:54 <lispy> @eval maybe 4 (+1) $ Nothing
10:29:56 <lambdabot> 4
10:30:00 <paolo-> I thought it was good enough to made it into @quotes.  But I know I shouldn't say that ;-)
10:30:22 <shapr> @quote
10:30:23 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a
10:30:23 <lambdabot> bike rode up next to me and said, "There's always a show off." I
10:30:23 <lambdabot> offered to teach him to ride and help set up a unicycle patrol squad,
10:30:23 <lambdabot> but he declined.
10:30:40 <metaperl> is there a reason that people dont help when you paste at paste.lisp.org? I have a question posted here: http://paste.lisp.org/display/10848
10:30:46 <shapr> I think QuotesPage should be in the right format so that @quote can import the content.
10:31:00 <mwc> Hmm, looks like Xegl is dying... we need to write our own X server in Haskell
10:31:05 <mwc> "HeX11?"
10:31:25 <lispy> metaperl: i'm getting connection refused
10:31:36 <metaperl> hmm
10:31:48 <paolo-> badger badger badger badger badger
10:32:03 <metaperl> reposted here: http://rafb.net/paste/results/t6zm4863.html
10:32:14 <lispy> metaperl: i prefer paste.lisp.org, but it never likes my browser
10:32:18 <metaperl> I could use some help with this unusual run-tiime error: http://rafb.net/paste/results/t6zm4863.html
10:32:33 <metaperl> lispy: I use firefox just fine... what do you use?
10:32:41 <lispy> metaperl: fire box
10:32:45 <lispy> rafb is also rejecting me
10:32:51 <lispy> er firefox not fire box
10:32:59 <mwc> lisspaste works fine for me
10:33:02 <lispy> i wonder if google likes me
10:33:03 <shapr> metaperl: getLineWhites is a partially applied filter function, it wants a list as its next input.
10:33:07 <mwc> using Mozilla FireBadger
10:33:21 <lispy> mwc: it only works 1/4 from my school,  i think there is a proxy issue
10:33:53 <lispy> even google is refusing me
10:33:57 * metaperl re-examines the code in light of comments
10:34:02 <lispy> *sigh* i guess it's time to reboot
10:34:08 <lispy> stupid winders
10:35:15 <metaperl> shapr: I dont underststand. makePicture is sending whites to getLineWhites and whites is a list... so the partially applied function is geting what it wants
10:35:50 <shapr> metaperl: What's the type of getLineWhites according to ghci?
10:36:37 * mwc is too cool for school
10:36:45 <mwc> and also too cool for windows
10:36:47 <metaperl> getLineWhites :: forall a t. (Eq a) => a -> [(t, a)] -> [(t, a)]
10:37:14 <ehuber_> hey basti_
10:37:20 <basti_> hi
10:38:02 <lispy> mwc: yeah, i'm too cool for windows and some how ended up stuck on windows again
10:38:34 <lispy> weird, weird, weird
10:38:51 <lispy> a large portion of the net is unreachable, but not all of it
10:39:01 <lispy> MR_KETCHUPHEAD: can i have some mustard please?
10:39:14 <MR_KETCHUPHEAD> just dont squirt me on your tofu dog
10:39:38 <MR_KETCHUPHEAD> there's a guy on #debian causing trouble named MR_MUSTARDHEAD, so I thought I'd spoof him :)
10:40:03 <lispy> ah
10:40:08 <lispy> ah, #debian
10:40:10 <mwc> #debian is almost the same wretched hive of scum and villany that #gentoo is
10:40:20 <MR_KETCHUPHEAD> no, #debian is very helpful
10:40:32 <lispy> mwc: yeah, except debian users don't have as long between installs to cause trouble :)
10:40:32 <MR_KETCHUPHEAD> especially after suffering with #fedora for a few weeks
10:40:45 <mwc> lispy, hahah!
10:40:47 <MR_KETCHUPHEAD> lispy: lol
10:41:17 <shapr> MR_KETCHUPHEAD: Ok, Where's pictures.hs ?
10:41:36 <MR_KETCHUPHEAD> that is standard with craft-of-fp code
10:41:50 <MR_KETCHUPHEAD> on Scanned it is in ~metaperl/haskell/craft-of-fp/Code
10:41:59 <metaperl> time to get serious again
10:42:10 <shapr> Ok, I have that.
10:42:36 <metaperl> this error message really gives me no clues as to what I did wrong
10:43:27 <metaperl> oh, maybe there is a makePicture in Pictures.hs? if so, it should have warned me about redefining. Does ghci warn about re-definitions?
10:43:42 <shapr> No, that's not it.
10:43:53 <shapr> It looks something like type escaping.
10:44:06 <metaperl> type escaping?
10:44:15 <metaperl> i will remove import for a sec
10:44:21 <shapr> Look at :t renderLine
10:44:22 <metaperl> I just needed the printPicture func there
10:45:34 <metaperl> renderLine :: forall a. (Enum a, Num a) => a -> [a] -> [Char]
10:45:55 <shapr> Something is forcing whites to be a list of the same type as width.
10:46:20 <shapr> Oh, you're using elem
10:46:37 <ehuber_> is there a more elegant way to use fst and snd than    fxnBla (fst fxnToGetTuple) (snd fxnToGetTuple)
10:46:45 <ehuber_> because the two calls are a waste ?..
10:46:50 <paolo-> ehuber yes
10:46:53 <metaperl> ehuber: pattern match in head of function?
10:46:56 <Heffalump> it'll probably get CSEd
10:47:05 <Heffalump> but let (a,b) = fxnToGetTuple in fxnBla a b
10:47:07 <paolo-> @type (Control.Arrow.&&&)
10:47:09 <lambdabot> forall (a :: * -> * -> *) c' c b.
10:47:09 <lambdabot> (Control.Arrow.Arrow a) =>
10:47:09 <lambdabot> a b c -> a b c' -> a b (c, c')
10:47:11 <shapr> ehuber_: You can use let (a,b) = fxnToGetTuple
10:47:16 <Heffalump> (or in this case, uncurry fxnBla fxnToGetTuple)
10:48:07 <ehuber_> oh... forget about let again
10:48:10 <ehuber_> thanks.. heh
10:48:57 <metaperl> shapr: so using `elem` is causing problems somehow?
10:49:00 <basti_> metaperl: i forwarded your/neil mitchells IOExtensions fix to henning, which is the person who appears to be caring about csound.
10:49:06 <basti_> and, who is neil mitchell?
10:49:11 <shapr> metaperl: Yeah, because that means you want whites to be a list of numbers, but it's a list of tuples, see?
10:49:19 <shapr> basti_: probably ndm
10:49:27 <shapr> They guy who wrote Hoogle and is ndm here on #haskell
10:49:33 <basti_> mmk
10:49:33 <metaperl> basti_: I didnt write it... I forgot his pseudonym on here
10:49:36 <metaperl> shapr: oh
10:49:39 <basti_> that might be.
10:49:39 <lispy> ehuber_: if you don't like let, there is also where, which i find to be a bit nicer in many cases
10:49:46 <basti_> we were talking about csound and the article
10:50:00 <shapr> metaperl: this is a case where type error slicing would help.
10:50:12 <metaperl> what is type error slicing?
10:50:20 <metaperl> these are great things for you to publish in TMR
10:50:40 <shapr> Haskell doesn't have type error slicing yet, so it wouldn't help much.
10:50:48 <metaperl> :)
10:51:28 <metaperl> i need a map fst in my getLineWhites
10:51:41 <shapr> Types propagate from certain locations in the source. If you can see sources and the place where two sources collide, it's a lot easier to debug your code.
10:51:56 <ehuber_> lispy: i dont mind using let, especially since im even less familiar with where
10:51:59 <shapr> That's type error slicing.
10:52:42 <lispy> ehuber_: the nice thing about where is that you put it after the fact.  I find that given good use of naming, where is faster to read than let
10:52:43 <mwc> I find that I use where almost exclusively, and only use let when I need a 1 line variable swizzel: let x' = fromIntegral x in foo x'
10:52:44 <basti_> we should have an editor thing that shows types of expression.
10:52:46 <KrispyKringle> HAHAHA
10:52:59 <lispy> the wiki has a page about it
10:53:04 * ski .. hm, i wonder if there's a connection between type error slicing and declarative debugging ..
10:53:04 <KrispyKringle> I googled "hoogle," curious to see what shapr was talking about. And it brought me to a bondage page.
10:53:05 <lispy> but i can't remember enoguh to find it
10:53:09 <metaperl> [ renderLine width (map fst $ getLineWhites n whites) | n <- [0..height-1] ] --- the fixed line
10:53:13 <basti_> KrispyKringle: lol
10:53:26 <mwc> KrispyKringle, that's what shapr really was talking about :P
10:53:34 <ski> @hoogle (a -> b) -> ([a] -> [b])
10:53:36 <lambdabot> No matches, try a more general search
10:53:54 <mwc> Those crazy guys above the arctic circle have a lot of time to pass
10:54:02 <lispy> i can't access the wiki
10:54:27 <lispy> this is wery odd.  some sites work, most don't.
10:54:37 <metaperl> shapr: thanks for the help
10:54:38 * mwc takes a wild guess involving "firewall" and offers a mumbled suggestion that involves "sysadmin's orfice."
10:54:41 <paolo-> How do you fill an allocaArray space with members of a list?
10:54:47 <paolo-> (an Haskell list)
10:54:57 <shapr> metaperl: sure, no worries.
10:55:26 <paolo-> pokeArray.
10:59:19 <lispy> yeah, telnet foo 80 is getting refused, but i can ping the host
10:59:59 <paolo-> shapr: I do enjoy more that monkey eek eek eek every time I hear it.
11:01:09 <shapr> :-)
11:02:37 <paolo-> The only way to do [Double] -> *doubles marshalling is |\xs -> withArray (map (cFloatConv :: Double -> CDouble) xs $ ...| right?
11:03:14 <paolo-> Err, "xs)" sorry.
11:04:18 <paolo-> I mean, marshal the single elements (hence the map).
11:15:43 <paolo-> @index peek
11:15:44 <lambdabot> Foreign.Storable, Foreign
11:15:51 <paolo-> @type Foreign.Storable peek
11:15:52 <lambdabot> bzzt
11:16:03 <paolo-> @type Foreign.Storable.peek
11:16:05 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO
11:16:05 <lambdabot> a
11:16:06 <paolo-> @type Foreign.Storable.poke
11:16:08 <lambdabot> forall a.
11:16:08 <lambdabot> (Foreign.Storable.Storable a) =>
11:16:08 <lambdabot> GHC.Ptr.Ptr a -> a -> IO ()
11:17:31 <ski> @index perk
11:17:33 <lambdabot> bzzt
11:17:59 <lispy> paolo-: what are you using peek and poke for?
11:18:13 <paolo-> Ptr CDouble -> Double
11:22:41 <Itkovian> @seen Lemmih
11:22:42 <lambdabot> Lemmih is in #haskell. Last spoke 1 hour, 31 minutes and 18 seconds
11:22:42 <lambdabot> ago.
11:22:45 * Lemmih is down to 39 modules dependencies.
11:22:51 <Lemmih> Itkovian: Hey (:
11:23:08 <Lemmih> *module dependencies.
11:23:21 <Lemmih> Itkovian: Is it working?
11:23:27 <Itkovian> Lemmih: I'm getting there. Everything compiles, but I thought hspr was standalone ... seems wrong ... so I've got to find where Apache resides on this mac
11:24:53 <lisppaste2> paolo pasted "Do you think it's messy?" at http://paste.lisp.org/display/10850
11:27:37 <lispy> so, i have irc, but no web
11:27:52 <lispy> so much for getting any work done :)
11:27:57 <Itkovian> got to go bathe the little fellar ... brb
11:30:40 <CosmicRay> lispy: but you have lambdabot and @google! ;-)
11:32:04 * Lemmih hopes to hack something newsworthy for the next HWN.
11:34:54 <CosmicRay> Lemmih: excellent
11:35:15 * paolo- yummys toasts
11:35:48 <Heffalump> HWN is cool.
11:35:50 <CosmicRay> wow, ftpmaster is really processing the new queue fast these days.  magic-haskell has been accepted into sid already.
11:35:54 <CosmicRay> Heffalump: thanks
11:39:46 <SyntaxNinja> is ghc in sid working?
11:40:20 <CosmicRay> yes, if you install gmp from sarge.
11:40:38 <paolo-> You mean 6.4.1?
11:46:43 <Igloo> I was quite disappointed with magic-haskell. I don't know what it should do, but it's a bit of an anti-climax after the name  :-)
11:47:01 <stepcut> hehe
11:47:02 <Igloo> Then again, that all stems from libmagic being rather anti-climactic itself
11:47:31 <Igloo> 6.4.1 isn't released, right?
11:47:32 <Heffalump> :-)
11:48:05 <Heffalump> I just wondered "isn't that an tautology"?
11:50:19 <CosmicRay> Igloo: haha
11:50:29 <Igloo> Isn't what? (do you really think agrammatically?)
11:50:39 <Heffalump> I mistyped :-p
11:50:42 <Heffalump> magic-haskell
11:50:47 <Igloo> Ah
11:53:45 <marcot> Hello, What's the difference of Data.IntSet and Data.Set Int?
11:54:04 <Lemmih> IntSet is optimized for Int's.
11:54:57 <marcot> Lemmih: so it's just an optimization difference?
11:55:06 <Lemmih> marcot: Yep.
11:55:33 <marcot> Lemmih: thanks.
12:03:44 <Heffalump> has anyone benchmarked it, OOI?
12:13:20 <musasabi> SyntaxNinja: Why is it not possible to depend on a module using c2hs in an executable stanza ?
12:13:27 <musasabi> that is using Cabal.
12:41:49 <cyanite> Hi ... uhm... now, I am _sure_ there already is a function like this?
12:41:49 <cyanite> writeEm (str:strs) = do putStr str; putChar '\n'; writeEm strs
12:41:49 <cyanite> writeEm strs       = return ()
12:42:01 <cyanite> writeEm :: String -> IO ()
12:42:15 <cyanite> somewhere in prelude or something?
12:42:43 <musasabi> cyanite: like mapM_ putStrLn ?
12:42:43 <Heffalump> writeEm strs = mapM_ putStrLn strs
12:42:43 <Lemmih> @type mapM_ putStrLn
12:42:45 <lambdabot> [String] -> IO ()
12:42:55 <Heffalump> (you've got the type wrong)
12:43:01 <cyanite> putStrLn ah.  good start
12:43:05 <cyanite> yeah the type I cited was wrong.
12:43:11 <cyanite> mapM ?
12:43:16 <cyanite> let me look that up....
12:43:18 <Heffalump> @type mapM_
12:43:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:43:27 <cyanite> ....
12:43:27 <Heffalump> mapM_, which throws away the result
12:43:30 <Heffalump> @type mapM
12:43:32 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:43:41 <Hatchetman> @type unlines
12:43:43 <lambdabot> [String] -> String
12:43:50 <Heffalump> but since you don't need a list of ()s, mapM_ is better
12:43:52 <cyanite> i'll just eh...
12:44:05 <Hatchetman> @hugs unlines ["string", "one", "another"]
12:44:06 <lambdabot> "string\none\nanother\n"
12:44:18 <Hatchetman> maybe unlines is usable?
12:44:26 <Heffalump> mapM_ putStrLn works fine here.
12:44:27 <musasabi> mapM action list == Apply the action to each list element and return the list of results. mapM_ is like mapM but discards the result values (but keeps the side effects).
12:44:35 <Heffalump> putStr . unlines would also work
12:44:51 <Hatchetman> thats what i said :D
12:44:56 <cyanite> I am _not_ very used to haskell... so I am still guessing what mapM does.. from the type alone it's not easy.
12:45:10 <Heffalump> mapM f [] = return []
12:45:28 <Heffalump> mapM f (x:xs) = do { a <- f x ; as <- mapM f xs ; return (a:as) }
12:45:33 <Heffalump> mapM_ f [] = return ()
12:45:47 <Heffalump> mapM_ f (x:xs) = do { f x ; mapM_ f xs }
12:46:12 <Hatchetman> i dont think cyanite really want the monad in there....just use unlines and then you can always use some function to put it on screen
12:46:14 <Heffalump> basically abstracts the pattern you'd written manually
12:46:18 <Hatchetman> i.e. delivering an IO
12:46:30 <cyanite> so eh it's like a monad-version of map..
12:46:31 <Heffalump> Hatchetman: maybe. Doesn't make much difference either way, probably.
12:46:35 <Heffalump> cyanite: precisely.
12:46:49 <Heffalump> Though the order matters because of the monad, and it acts left-to-right.
12:46:54 <cyanite> right... ok.  got it, I think.  ish ;).
12:46:55 <cyanite> *nod*
12:47:11 <cyanite> so .. to make sure... in  mapM :: Monad a => (b -> a c) -> [b] -> a [c]
12:47:12 <Heffalump> you seem to understand Haskell pretty well, really :-)
12:47:32 <cyanite> Monad a =>   is a class requirement on a?
12:47:35 <Heffalump> yep.
12:47:40 <cyanite> alright...
12:47:43 <cyanite> thanks :).
12:48:52 <cyanite> aah ok now I get it. hehe.  cool :-p.   gotta start somewhere after all, so I just made 'writeEm' even when I was sure there was a way to do it already ;)
12:49:08 <paolo-> Somebody once complained about the use of "a" in "Monad a" heh ;)
12:50:06 <cyanite> heh
12:50:21 <cyanite> did Monada mean something bad in his or her language? :p
12:50:51 <paolo-> Monad m is appealing to the eye, don't you think? heh
12:51:06 <CosmicRay> I think Monad x has a nice ring to it.
12:51:12 <cyanite> yeah... I guess :p.
12:54:33 <paolo-> Haha in the film showin' up in the television in this room, GIMP was used to zoom into a pic and show up some interesting bit - funny.
12:55:05 <sieni> well somebody has cleverly chosen "pylly" as the name of a python lexer generator and the name happens to mean ass or butt in Finnish
12:55:14 <cyanite> cool :p
12:55:21 <basti_> heh
12:55:26 <shapr> sieni: What about Paskalle for a spam filter?
12:55:31 <cyanite> just like UltraPIK's will never be marketed in denmark.
12:55:38 <basti_> http://americaninlebanon.blogspot.com/2005/07/backstroke-of-west.html
12:55:41 <cyanite> or waterpik showerheads for that matter.
12:56:02 <cyanite> given that pik = dick in dk...
13:00:55 <Lemmih> boegel!
13:01:01 <boegel> yeah !
13:03:55 <cyanite> soo ehm...    any IO that I want to actually take place must in some way be chained into the "IO monad chain" ending in being returned from main, right?... because if such a chain where to be discarded, it would never be invoked in the first place, because of the lazy evaluation..  is this correct? :p
13:04:00 <cyanite> ish? :p
13:04:14 <Heffalump> cyanite: correct.
13:04:21 <cyanite> cool.
13:04:24 <jlouis> korrekt
13:04:28 <cyanite> kool.
13:04:34 <cyanite> thanks.  tak.
13:04:44 <cyanite> jesper
13:04:45 <basti_> the hard pard about that is to figure out the rest.
13:04:49 <cyanite> I presume.
13:04:52 <jlouis> No problem Sune ;)
13:04:53 <cyanite> basti_: hehe :p
13:04:56 <cyanite> clever ;)
13:05:01 <basti_> :D
13:05:06 <basti_> no honestly, its quite easy
13:05:29 <cyanite> yeah so far it's fine.    I like it better than ML that's for sure.
13:05:42 <jlouis> ML has its warts, definitely
13:05:45 <basti_> just an unusual way to put it, and the ways you can use abstractions of this are surprising.
13:05:49 <boegel> yo Itkovian
13:05:57 <boegel> Lemmih, whay about me ?
13:06:04 <jlouis> Haskell has too, but they are far harder to find
13:06:14 <cyanite> Takes some time to wrap your mind around monads but....   worth the effort.
13:06:15 <basti_> i only know ocaml a little, and i think its a great thing, but it makes an "unfinished" impression
13:06:27 <cyanite> I never tried any OO ml.
13:06:34 <cyanite> only standard ml @ university.
13:06:42 <Itkovian> hi boegel ... got the guitar?
13:06:50 <basti_> i never dived into the object orientation stuff too, assumed it was not that unusual.
13:06:55 <Lemmih> boegel: Nothing. Just haven't filled out my weirdness quota.
13:07:35 <lispy> i'd say the learning curve for monads is a wart of haskell
13:07:43 <lispy> seq is another one
13:07:58 <basti_> i hardly ever use seq
13:08:11 <cyanite> seq I didn't look at.   yeah monads.. fortunately I had a semantics course where the concept was.. well... at least briefly superficially touched ;)
13:08:12 <lispy> sometimes IO monad is cumbersome, seq and learning curve of monads are the warts i've encountered in haskell.
13:08:17 <musasabi> Reasoning about performance is sometimes hard.
13:08:30 <musasabi> mostly space usage.
13:08:51 <basti_> yes
13:08:57 <cyanite> Yeah... I bet
13:08:59 <lispy> if yo uwant to touch on performance, mutable unboxed arrays are much slower than I anticipated
13:09:02 <paolo-> What about seq?
13:09:11 <boegel> Itkovian, yeah, I did
13:09:12 <lispy> paolo-: it's evil
13:09:19 <boegel> it's a lefty, like me ;)
13:09:28 <musasabi> lispy: they can be fast if you discard index checks etc.
13:09:30 <lispy> @eval (\x -> f x) undefined `seq` Nothing
13:09:32 <lambdabot> 25: Not in scope: `f'
13:09:56 <lispy> @eval (\x -> id x) undefined `seq` Nothing
13:09:58 <lambdabot> <Plugins.Eval>:1:12:
13:09:58 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:09:58 <lambdabot>   `Show a' arising from use of `show'
13:10:05 <lispy> @eval (\x -> id x) undefined `seq` 1
13:10:07 <lambdabot> Prelude.undefined
13:10:10 <Itkovian> good, cos the train was old and rusty, without airco
13:10:11 <paolo-> @plugs unidefined `seq` 1
13:10:13 <lambdabot> 18: Not in scope: `unidefined'
13:10:16 <paolo-> err, you got it.
13:10:20 <lispy> @eval (\f x -> f x) id undefined `seq` 1
13:10:22 <lambdabot> Prelude.undefined
13:10:29 <lispy> i guess that's the wrong example
13:10:41 <lispy> it's something like thta
13:10:59 <boegel> Itkovian, heh :) I got a nice one ;)
13:11:01 <lispy> @eval (\x f -> f x) undefined id `seq` 1
13:11:02 <paolo-> @plugs const $ undefined `seq` 1
13:11:03 <lambdabot> Prelude.undefined
13:11:03 <lambdabot> <Plugins.Eval>:1:12:
13:11:03 <lambdabot>   No instance for (Show (b -> a))
13:11:03 <lambdabot>   arising from use of `show'
13:11:09 <Lemmih> @eval (\f x -> f x) undefined `seq` 1
13:11:11 <lambdabot> 1
13:11:11 <paolo-> err :-)
13:11:12 <Lemmih> @eval (\x -> x) undefined `seq` 1
13:11:14 <lambdabot> Prelude.undefined
13:11:18 <cyanite> ...
13:11:28 <Itkovian> anybody got any idea where the apache serverroot resides on Tiger?
13:11:35 <lispy> Lemmih: yeah, that's it
13:11:47 <lispy> Itkovian: /opt?
13:11:50 <jlouis> Itkovian: how about find / -type d -name htdocs ;)
13:11:52 <cyanite> Itkovian: hmm ... I used to, but I forgot  :/
13:11:54 <boegel> Itkovian: check httpd.conf ?
13:11:55 <Lemmih> Itkovian: You can read it in your apache conf.
13:12:04 <Itkovian> right
13:12:11 <Itkovian> my brain is still in vacation mode it seems
13:12:18 <boegel> wow, 5 different reactions :)
13:12:31 <lispy> and mdfind (or whatever the spotlight command is) should be must faster than find
13:12:50 <cyanite> mdfind is teh stuff
13:12:52 <paolo-> haha you have spotlight and don't know how to search :-P
13:12:52 <Itkovian> jlouis: it's not always called htdocs :-)
13:13:06 <ehuber_> yay for brainfuck
13:13:33 <Itkovian> paolo-: I know how to search ...
13:13:38 <paolo-> :-P
13:13:41 <jlouis> well, the perl I am sitting with is a lot like brainfuck
13:13:42 <Itkovian> ah whatever ... see a few lines up
13:13:49 <jlouis> everything looks like FORTRAN70
13:14:10 <lispy> i can't figure out perl, were functions cobbled on top?
13:14:20 <lispy> because it has them, but they're borked
13:14:21 <ehuber_> lol
13:14:24 <boegel> short HWN this week...
13:14:30 <ehuber_> thank god i dont know perl
13:14:44 * Itkovian is watching The Thin Blue Line
13:14:53 * boegel is yawning like crazy
13:15:00 <boegel> man, I'm tired
13:15:06 <cyanite> I am watching swordfish... good with a little update on my cryptography knowledge ;)
13:15:12 <lispy> one thing that really disturbs me about perl is that it cannot enforce that you are calling functions correctly
13:15:14 <jlouis> cyanite: haha
13:15:24 <boegel> cyanite: swordfish is a crappy movie
13:15:33 <cyanite> so far, it is for sure :p
13:16:12 <Heffalump> lispy: perl is kind of like machine code that way (functions cobbled on top)
13:16:25 <ehuber_> @hoogle Int -> Char
13:16:26 <Heffalump> though at least it provides a proper implicit stack
13:16:26 <lambdabot> Char.chr :: (Int -> Char)
13:16:26 <lambdabot> Char.intToDigit :: (Int -> Char)
13:16:26 <lambdabot> Prelude.toEnum :: Enum a => (Int -> a)
13:16:36 <musasabi> How does one check for installed GHC packages using autoconf (any handy macros) ?
13:16:53 <lispy> @eval Char.intToDigit 10
13:16:55 <lambdabot> 'a'
13:17:04 <lispy> @eval Char.intToDigit 99
13:17:05 <lambdabot> Char.intToDigit: not a digit 99
13:17:11 <ehuber_> that's hex ?
13:17:13 <basti_> but a is yes?
13:17:14 <basti_> .)
13:17:21 <basti_> @eval Char.intToDigit 40
13:17:21 <ehuber_> suppose i just want int -> ascii rep
13:17:22 <lambdabot> Char.intToDigit: not a digit 40
13:17:27 <basti_> @eval chr 65
13:17:29 <lambdabot> 'A'
13:17:31 <ehuber_> ooh
13:17:34 <ehuber_> thanks (:
13:17:43 <basti_> appeared above, quite an usual name
13:17:50 <lispy> didn't meant to confuse you, i was curious about intToDigit
13:18:11 <ehuber_> lispy: no problem, everyone's so helpful :p
13:18:50 <lispy> yeah, the haskell community is better than most PL communities
13:18:54 <ehuber_> anyway bfuck.hs is done :p im sure this is the 1000th time someone has made a brainfuck interpreter in haskell :p
13:19:12 <lispy> ehuber_: where is the spec?
13:19:19 <lispy> ehuber_: i haven't made one yet :)
13:19:26 <ehuber_> http://www.muppetlabs.com/~breadbox/bf/
13:19:28 <ehuber_> (;
13:19:43 <ehuber_> it took me a long time because i dont know haskell too well
13:19:46 * lispy was afraid to google it at work :)
13:19:52 <ehuber_> heh
13:19:58 <ehuber_> do they monitor you ?
13:20:04 <lispy> probably not
13:20:07 <lispy> but i'm not sure
13:20:10 <ehuber_> b/c if they dont im sure they dont like you using irc either (:
13:20:19 <ehuber_> & irc isnt encrypted.. or is it
13:20:25 <KrispyKringle> no, it's not
13:20:41 <KrispyKringle> lispy: where do you work that googling is forbidden?
13:20:42 <ehuber_> that's what a i thought :p
13:20:42 <lispy> i'm using irc over ssh
13:20:48 <KrispyKringle> lispy: that's what i used to do at work :P
13:20:49 <ehuber_> ahhh
13:20:52 <ehuber_> pretty smart (:
13:21:05 <lispy> the irc client is runnnig on my home network :)
13:21:20 <lispy> KrispyKringle: heh, it was the search time i was concerned with :)
13:21:32 <ehuber_> but they probably see the connection, and see the port, and wonder what you could be doing over ssh (:
13:21:46 <lispy> ehuber_: yeah
13:21:50 <KrispyKringle> lispy: oh, i thought maybe you worked at Yahoo! or something :P
13:21:50 <lispy> that's possible
13:21:57 <lispy> haha
13:22:12 <ehuber_> anyway it's a pretty simple little language.. i didnt implement input ',' because i wanted to keep it simple
13:22:49 <cyanite> how would one fold [1,2,3] into (1,(2,(3,()))) ?   can't use foldr since types must match. hm.
13:22:54 <boegel> anyone know any guitar websites to learn chords for a lefty ?
13:23:09 <ehuber_> boegel, they are the same, just flip them over
13:23:10 <lispy> cyanite: you want a crazy tuple?
13:23:23 <cyanite> lispy: no I am just experimenting really  .. ;)
13:23:25 <ehuber_> unless you have some crazy tuning ?
13:23:30 <boegel> ehuber_ yeah, but I mean for a _real_ beginner
13:23:36 <ehuber_> oh
13:23:41 <basti_> cyanite: the problem is that tuples are on "type level".
13:23:43 <ehuber_> sorry, i dont then (: ill shut up
13:23:44 <boegel> so basically a chords website for beginners :)
13:23:50 <ehuber_> well
13:23:54 <lispy> cyanite: you can't return tuples of different sizes without creating a special type to hold them in
13:24:06 <ehuber_> if you just want chord diagrams, try just searching 'guitar chords' on google
13:24:17 <cyanite> lispy: right... I was beginning to think so.   ok, thanks :)
13:24:18 <ehuber_> if they are for righties, then mirror x and y
13:24:46 <lament> guitars are eeevil
13:24:59 <lament> boegel: don't flip anything.
13:25:00 <jlouis> cyanite: you would hit the circularity constraint with that ;)
13:25:07 <lament> boegel: play it like everyone else does.
13:25:08 <cyanite> yeah.  ..
13:25:18 <boegel> lament: I bought a lefty guitar...
13:25:24 <jlouis> ie, the occurs think I think
13:25:26 <lament> boegel: that was a bad move
13:25:27 <lispy> boegel: don't listen to lament
13:25:28 <jlouis> occurs check
13:25:51 <boegel> lispy, ok, why ? :)
13:26:03 <lament> boegel: it's a lot more fun to be able to play on any guitar, whenever you are
13:26:05 <lispy> boegel: because i'm a lefty and i hate the "assumed right" :)
13:26:08 <boegel> lament: I don't think it is, a lot of people told me to buy a lefty since I am left
13:26:20 <lament> I think it is. I'm a lefty and I play guitar.
13:26:24 <boegel> lament: don't care 'bout that :
13:26:27 <Lemmih> cyanite: You could define a 'listToTuple :: [a] -> Tuple a' for 'data Tuple a = Pair (a, Tuple a) | Nil'.
13:26:43 <goron> boegel: hi (I saw your last message two hours after you said it)
13:26:53 <cyanite> Lemmih: yeah.  well.. it's nothing I need, was just bascially experimenting.  but thanks    :).
13:26:56 <lament> lispy: do you play guitar? :)
13:27:06 <basti_> Lemmih: that would be isomorphous to List with (:) and [] though.
13:27:07 <lament> it just doesn't make that much of a difference
13:27:16 <boegel> goron: which message ? :D
13:27:21 <lispy> lament: no, i'm musically challenged.  I can barely appreciate the stuff
13:27:39 <Lemmih> basti_: Indeed.
13:27:44 <lispy> lament: but i do things left handed when there is a choice.
13:27:51 <boegel> lament: anyway, for starters, since I'm a real beginner, I think it's easier to learn
13:28:12 <lament> boegel: i don't think it would make much of a difference in any case
13:28:21 <basti_> i think it'd be easier to coordinate the notes, and harder to strum
13:28:52 <boegel> lament: your using your good hand to do the hard work, so I'm guessing it does make a difference
13:29:08 <lament> boegel: no
13:29:13 <lament> both hands do the hard work :)
13:29:16 <boegel> nobody has a good website to teach myself coord ?
13:29:20 <boegel> +s
13:29:28 <basti_> chords or coords? .)
13:29:42 <lament> I would say fingering is harder than strumming, in any case
13:29:48 <lament> so that's what should be done with the left hand :)
13:30:31 <boegel> basti_, chords, sry :D
13:30:52 <boegel> lament: bull, then all the right people are playing it wrong
13:31:03 <lament> but being able to play only on your own guitar and not on anyone else's is a real impediment :)
13:31:07 <basti_> i was so lazy that i learned barree just not to have to memorize all the stupid fingerings ;)
13:31:33 <lament> boegel: both hands work about equally hard
13:31:48 <lament> look at pianos, how come there're no left-handed pianos? (that i know of)
13:32:02 <lament> and the two hands often have to play stuff of equal difficulty
13:32:03 <boegel> because those would look just the same ? :)
13:32:15 <basti_> i think the main reason why the guitar is played like that is that it descended from spanish guitars
13:32:29 <basti_> where hard thumb plucks are important, which are not possible with the weak hand
13:32:54 <lament> um
13:32:58 <lament> what do you mean not possible
13:33:05 <basti_> inconvinient
13:33:10 <lament> i seem to do them just fine :)
13:33:22 <basti_> its just a guess though
13:33:38 <ehuber_> yeah, finger style is definitely much harder (& more rewarding) then strumming
13:33:43 <lament> i'm not the greatest guitar player ever, but the technical difficulties i have are certainly not due to being left-handed
13:34:20 <ehuber_> http://www.andrew.cmu.edu/user/ehuber/code/bfuck.hs
13:34:24 <lament> (and more due to hating the damn instrument and being too lazy to practice :) )
13:34:52 <ehuber_> lament: what's wrong with your guitar ?
13:35:25 <Igloo> If you're playing the guitar upside down I'd have thought you'd find different chord shapes easier sometimes
13:35:28 <lament> ehuber_: i just don't like them in general. All the good stuff is too hard :)
13:35:33 <boegel> ehuber, it a normal guitar and he's left :D
13:36:12 <lament> anyway, aren't guitars symmetrical?
13:36:16 <ehuber_> lament: what sort of music do you like to play
13:36:19 <lament> well, classical guitars
13:36:21 <lament> ehuber_: classical
13:36:28 <ehuber_> lament: well, the chords arent but everything else is, on a classical guitar
13:36:36 <ehuber_> cords..
13:36:43 <ehuber_> strings.. whatever they're called (:
13:36:50 <lament> strings :)
13:36:50 <ehuber_> cuerdas (:
13:37:05 <lament> so i'm not sure what a "lefty guitar" is
13:37:31 <ehuber_> maybe he has a nonclassical guitar
13:37:33 <Spark> one wired in reverse? :)
13:37:35 <ehuber_> with the weird hole
13:37:37 <Spark> erm, stringed
13:37:52 <lament> yeah, maybe it has that plate to bang the pick against
13:37:59 <lament> and the plate is on the other side of the hole
13:38:10 <Spark> i have seen guitars strung in reverse
13:38:18 <Spark> they remind you what it was like to first learn
13:38:25 <Spark> i.e. painful and confusing :)
13:38:28 <ehuber_> Spark: for classical, this is how 'lefty' guitars are 'made' (:
13:38:37 <lament> right
13:38:59 <boegel> Spark, yeah, mine is stringed in reverse, because you hold it in reverse
13:39:19 <lament> boegel: but the actual guitar is normal?
13:39:31 <lament> if you reverse the strings again
13:39:40 <boegel> also, there's something with the thingie that holds the strings... on some guitars it not 'straight', because one string should be a little bit shorter than the other
13:39:46 <boegel> so that has to change too
13:39:48 <Spark> the pick guard or whatever its called needs to be changed too
13:39:52 <Spark> but other than that theyre symetrical
13:39:53 <boegel> lament, no, I don't think it is
13:40:04 <Spark> boegel: the bridge?
13:40:18 <boegel> Spark, dunno what's it called, as I said, I'm a total newbie :)
13:40:26 <Spark> i think i have seen them like that, not sure :)
13:40:33 <gzl> anyone here tried h4sh?
13:40:33 <lament> heh... bizarre
13:40:34 <ehuber_> hey boegel
13:40:35 <Spark> i cant see any reason for it
13:40:35 <ehuber_> http://www.geocities.com/xulfrepus/folder/guitar.html
13:40:42 <gzl> alternatively, is dons around?
13:40:45 <ehuber_> select 'Lefty' instead of 'Righty'
13:40:55 <paolo-> @where h4sh
13:40:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
13:41:07 <ehuber_> know all the major and minor chords :p
13:41:09 <gzl> paolo-: no, I know where it is
13:41:13 <gzl> just having trouble compiling it
13:41:13 <paolo-> gzl: I didn't :-)
13:41:18 <gzl> ah ok
13:41:18 <ehuber_> and open
13:41:33 <lispy> gzl: do you have hsx and hs-plugins?
13:41:41 <gzl> hm, hsx
13:41:44 <gzl> I do have hs-plugins
13:41:45 <lispy> iirc those are the pre-reqs
13:42:00 <ehuber_> ooh, i gotta go
13:42:09 <ehuber_> picking up gf (: off to see 'die edukators' :p
13:42:12 <ehuber_> bye bye
13:42:16 <gzl> lispy: the README doesn't mention hsx
13:42:21 <ehuber_> good luck with the guitar
13:42:25 <lispy> gzl: hmm...
13:42:43 <lispy> gzl: well, if installing hsx fixes it, then send in a patch to the README :)
13:43:02 <lispy> gzl: can you build yi?
13:43:08 <gzl> I haven't triedf
13:43:20 <lispy> if you can build yi you should be able to build h4sh
13:43:24 <boegel> ehuber, thanks
13:43:25 <lispy> that's what dons said
13:43:28 <gzl> is hsx in dports?
13:43:46 <lispy> i grabbed it of fa website, it's tiny
13:43:53 <gzl> ok
13:44:08 <gzl> my concern was more the possible annoyance of installing it myself
13:44:16 <lispy> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
13:44:22 <gzl> yeah, I got it already
13:44:22 <gzl> thanks
13:44:26 <lispy> np
13:44:27 <lispy> ;)
13:44:43 <lispy> i didn't think it was that bad to install
13:45:29 <gzl> have you seen this error before?
13:45:31 <gzl> runhaskell: waitForProcess: interrupted (Interrupted system call)
13:45:44 <lispy> try it again
13:45:52 <lispy> seems like i saw that once
13:46:01 <gzl> I get that consistently when I try to compile h4sh or hsx
13:46:06 <lispy> maybe you need a make distclean?
13:46:18 <lispy> oh, hmm...talk to dons i guess
13:46:42 <gzl> % make clean
13:46:42 <gzl> runhaskell Clean.hs
13:46:42 <gzl> runhaskell: waitForProcess: interrupted (Interrupted system call)
13:46:43 <gzl> :)
13:46:44 <boegel> http://elis.ugent.be/~kehoste/guitar.jpg -> my new toy
13:47:12 <Lemmih> gzl: Compile Setup.lhs instead of interpreting it.
13:47:44 <gzl> you mean Setup.hs in hsx?
13:48:03 <Lemmih> Oh, right.
13:48:43 <CosmicRay> boegel: nice
13:49:01 <boegel> CosmicRay, thanks :) I got it from my mom for graduating
13:49:03 <gzl> Lemmih: that doesn't really do any good. runhaskell still complains.
13:49:24 <lispy> gzl: type it manually
13:49:34 <lispy> ghc --make Setup.hs
13:49:37 <gzl> I did that
13:49:40 <lispy> oh
13:49:44 <gzl> then just run the executable?
13:49:45 <lispy> then why did you get a runhaskell error?
13:49:51 <gzl> oh, duh
13:49:54 <lispy> yeah after it builds
13:49:54 <gzl> I'm an idiot
13:50:06 <gzl> I just scrolled up in history and reran the runhaskell command :)
13:50:10 <lispy> eheh
13:50:12 <lispy> nice!
13:50:51 <gzl> ok, cool
13:50:53 <gzl> that works
13:51:31 * lispy cheers
13:51:46 <gzl> hmm
13:51:49 <gzl> or does it
13:52:34 <gzl> ok, well, src/harp went through
13:52:41 <gzl> but now I'm trying src/haskell-src-exts
13:53:02 <gzl> and while it configures successfully without happy, it complains when building
13:53:08 <gzl> do I need happy then?
13:53:16 <Lemmih> Yes.
13:53:18 <gzl> ok.
13:53:25 <lispy> yeah, iirc i used dports to get happy
13:53:25 * boegel leaves for bed, g'night everyone
13:53:30 <gzl> yeah, that's what I'm doing
13:53:30 <lispy> boegel: night
13:53:40 <lispy> "to get happy"
13:53:57 <gzl> dports has gotten pretty nice since I last tried it
13:53:58 <Lemmih> Cabal isn't yet advanced enough to specify dependencies on external tools.
13:54:20 <goron> boegel: You said "hi" to me a a week back or so... I didn't say anything, because I didn't notice it. Nothing special.
13:55:56 <boegel> http://www.yehey.com/exgame.htm
13:56:01 <boegel> wahahaha :D gotta love it
13:56:17 <boegel> I knew what would happen, and I still jumped :D great stuff
13:56:27 <boegel> night everyone !
14:10:00 <paolo-> What is the proper semantic for an IO action which writes to file?
14:10:07 <paolo-> Exception-wise, I mean.
14:11:48 <gzl> lispy: ok, I installed hsx, but now what do I do about h4sh?
14:11:50 <lispy> paolo-: can you be more specific?
14:12:21 <lispy> gzl: did you do a make distclean and h4sh is still not compiling?
14:12:58 <lispy> paolo-: are you asking about the Error monad?
14:13:16 <lispy> paolo-: like try/catch sort of stuff?
14:13:28 <gzl> yes. should I just compile the haskell files and run them directly here too?
14:14:01 <lispy> paolo-: http://www.nomaware.com/monads/html/errormonad.html
14:14:18 <lispy> gzl: yeah, if you're getting the same error it's what i'd try
14:14:29 <paolo-> lispy: yes, sure.
14:14:31 <paolo-> http://rafb.net/paste/results/zXtnYN24.html
14:14:51 <lispy> paolo-: this isn't going to break my internet again is it?
14:15:00 <paolo-> I hope not
14:15:28 <Hatchetman> is mirrorring a site illegal?
14:15:40 <mwc> Without permission, yeah
14:15:57 <Hatchetman> so if i wget a site...its illegal?
14:16:03 <mwc> you can't redistribute copyrighted material
14:16:12 <Hatchetman> its free material
14:16:16 <mwc> Hatchetman, no, you can't wget -R it and then put it on your own website
14:16:32 <mwc> oh, if it's CC or GFDL or whatever, yeah, you can drop it from airplanes
14:16:34 <Hatchetman> im not putting it up at all, pure backup purposes
14:16:41 <mwc> then it's totally legitimate
14:16:52 <Hatchetman> even thought it generates a shitload of bandwidth :D
14:16:54 <mwc> Well, it's fair use
14:17:06 <mwc> Doesn't matter, they're providing it to you
14:17:11 <Hatchetman> true
14:17:20 <mwc> it's only a crime if they've forbidden you to spider it
14:17:35 <paolo-> So.. haskell :-P
14:17:35 <Hatchetman> (y)
14:17:38 <Hatchetman> thanks
14:18:08 <lispy> paolo-: hmm
14:18:31 <lispy> paolo-: there was no haskell at that url :)
14:18:42 <lispy> only java and c :)
14:18:43 <paolo-> lispy: underneath is full of it :-)
14:18:51 <lispy> underneath?
14:19:10 <lispy> maybe you didn't give me the url you meant to?
14:19:13 <paolo-> I'm writing an haskell binding to that functions.
14:19:25 <lispy> i have 38 lines on my scheen
14:19:27 <lispy> er screen
14:19:29 <paolo-> Right.
14:19:42 * lispy tries to peel the website like an onion
14:20:11 <kosmikus> SyntaxNinja: afaics, the latest version of cabal works fine. thanks again
14:20:48 <lispy> paolo-: cairo_surfice_write_to_png_stream :: Cairo_Surface -> Cairo_Write_Func -> Closure -> IO a  ?
14:21:48 <Lemmih> paolo-: Wont the Foreign.C.Error utils do just fine here?
14:21:52 <lispy> IO Either CairoError
14:22:09 <paolo-> @docs Foreign.C.Error
14:22:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.Error.html
14:22:25 <gzl> huh!
14:22:27 <gzl> Could not find module `System.Eval':
14:22:29 <lispy> what is cairo?
14:22:29 <gzl> ?!
14:22:42 <lispy> @index System.Eval
14:22:43 <lambdabot> bzzt
14:22:52 <lispy> @doc System.Eval
14:22:54 <lambdabot> System.Eval not available
14:23:04 <paolo-> lispy: www.cairographics.org
14:23:20 <paolo-> Lemmih: I'm reading, it seem to be the case - I could avoid using the callback functions with it.
14:26:43 <gzl> lispy: it's part of hs-plugins
14:28:14 <SyntaxNinja> kosmikus: sweet!
14:28:43 * SyntaxNinja subtly points out that he was the one who approved the creation of the haskell cairo hooks
14:29:48 <gzl> yeah, this waitForProcess crap isn't going away. so annoying.
14:31:20 <kosmikus> SyntaxNinja: so, how long until cabal-1.1.2 is released? :)
14:36:20 <paolo-> Lemmih: hmm - are you suggesting to use throwErrnoIf with the non-callback function?  I can't completely understand the advice given on the bottom of the paste.
14:36:40 <Itkovian> Lemmih: succes!
14:37:01 <Itkovian> I've got hsp pages in my local user webdir
14:37:10 <Itkovian> night all
14:39:59 <lispy> paolo-: errno is a very specific thing, is that really what cairo uses?
14:40:58 <paolo-> Those function returns a cairo_status_t - which is an enum, I could probably do a test against precise values of it.. hmm.
14:41:25 <lispy> or throw your own errors
14:41:47 <lispy> paolo-: http://www.nomaware.com/monads/html/errormonad.html
14:44:31 <paolo-> Hmm!  I think I got it.
14:48:03 <lispy> paolo-: congrats
14:51:12 <mwc> Ugh, another "best programming language for..." AskSlashdot
14:51:40 <mwc> and another swarm of Perl/C apologists and Python nuts
14:51:51 <stepcut> heh
14:53:53 <lament> mwc: what's the difference between apologists and nuts?
14:54:23 <tuomov> hmm..
14:54:33 <tuomov> h4sh still complains of System.Eval not being found
14:54:37 <mwc> lament, in this case, my distaste for Python. I decided to try learning it again this weekend and got thoroughly frustrated
14:55:10 <mwc> This time it's because of methods which require an explicit (self,... ) parameter. WTF?!
14:55:16 <lament> haha
14:55:48 <zamez> what's so bad about that?
14:56:01 <zamez> at least it makes it clear what are object variables
14:56:24 <tuomov> oops. my bad. old version of hs-plugins
14:56:38 <tuomov> darcs should fail when the target directory exists for get instead of appending with _0 etc.
14:56:50 <tuomov> many times I've fallen into that
14:57:29 <mwc> zamez, it's redundant noise
14:57:55 <mwc> before that, it was the mishmash of list functions/methods that have no consistency
14:58:11 <mwc> ie: some are in place, some are copying, some functionality is a list method, some is a function of a list
14:58:34 <mwc> Take ruby as a counterpoint: reverse() is copying, reverse!() is in place. Same for sort, sort!, etc.
14:59:51 <zamez> in a language without declarations, there has to be a way to distinguish object variables and locals
15:00:20 <monochrom> It is consistency.  Either it should insist self to be explicit, or it should insist self to be implicit.
15:01:14 <lispy> tuomov: yes
15:01:22 <lispy> tuomov: i've been bitten by it also
15:01:25 <mwc> Well, if you're doing def myMethod:
15:01:55 <mwc> inside a class scope, you should be able to infer that it's a member function
15:01:56 <tuomov> debian ghc seem to be in a borken state or something
15:02:11 <tuomov> complains of multiple versions of many libraries
15:02:15 <mwc> What ver in what branch?
15:02:23 <lispy> tuomov: i install from unstable
15:02:37 <lispy> tuomov: it was the only way i colud get a recent ghc
15:02:38 <tuomov> testing 6.4
15:02:48 <tuomov> ghc-6.4: Error; multiple packages match altdata: altdata-0.9.8,
15:02:48 <tuomov>                                         altdata-0.9.10
15:02:54 <tuomov> ghc-6.4: Error; multiple packages match hi: hi-1.0, hi-0.9.10
15:03:05 <Spark> i spent a good few minutes today trying to decide whether or not it would be a problem if class fields couldnt be of void type
15:03:33 <tuomov> I appended the versio nto package name and it stopped complaining, but not it can't find Language.Haskell.Hsx. But was that something extra you had to install?
15:03:57 <lispy> tuomov: yes
15:04:05 <lispy> @google hsx haskell
15:04:07 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
15:09:01 <ehuber> im about to go see 'die edukators'
15:09:58 <tuomov> is there some way to rebuild ghc package db easily or something?
15:10:14 <tuomov> now h4sh build is complaining of altdata, although it doesn't have direct references to it
15:12:31 <lispy> tuomov: dons should be awake in a few ours
15:12:33 <lispy> er hours
15:12:40 <lispy> i bet he'd be the most helpful
15:12:44 <tuomov> ghc-pkg unregister
15:12:44 <lispy> @timein sydney
15:12:48 <lambdabot>  Wednesday, August 17, 2005 at 8:13:50 AM EST
15:13:06 <lispy> not sure if that's his timezone...
15:13:24 <tuomov> h4sh seems to be building again..
15:13:32 <tuomov> sigh. still System.Eval
15:14:47 <SamB> well I hope lambdabot can find the time in sydney...
15:20:35 <tuomov> hmm.. the shell needs more ways to mark strings :)
15:48:22 <dons> moin
15:48:41 <paolo-> Hello dons :-)
15:49:18 <lispy> dons: hi
15:49:30 <lispy> dons: tuomov was here having problems with System.Eval
15:50:31 <dons> I see. maybe he has two versions of hs-plugins installed (forgot to unregister the old version?)
15:51:44 <lispy> maybe he'll be back in a bit
15:58:12 <dons> @seen gzl
15:58:13 <lambdabot> gzl is in #haskell. Last spoke 1 hour, 28 minutes and 23 seconds ago.
16:16:38 * dons has to teach perl today :/ and not even perl6!
16:16:50 <dons> maybe I'll slip some haskell in anway
16:17:24 <paolo-> Do you teach?
16:17:36 <Pseudonym> Obviously.
16:17:52 <paolo-> :-\  Didn't know.
16:17:54 <Pseudonym> :-)
16:18:00 <Pseudonym> He just said he did. :-)
16:18:07 <Pseudonym> Or at least he just said he will today...
16:18:08 <goron> ...
16:18:17 <paolo-> ==> True
16:18:20 * Pseudonym clearly needs caffeine
16:18:21 <dons> :) "software construction" this session, sh, perl, C, make and cvs .... blrgh!
16:18:42 <Pseudonym> Teach h4sh, FFI, hmake and darcs.
16:18:43 <goron> cvs? Never heard of it ;)
16:18:49 <dons> when what I want is to teach h4sh, haskell, cabal, and darcs!
16:18:53 <paolo-> I would like to be there, I need to understand Makefile hackery.
16:19:08 <Pseudonym> Cabal isn't standard!
16:19:17 <dons> true true. make is very useful.
16:19:18 <goron> It should be!
16:19:24 <Pseudonym> It will be eventually.
16:19:33 <Pseudonym> Actually, make really REALLY annoys me.
16:19:37 <Pseudonym> It's the CVS of build tools.
16:19:41 <dons> yes
16:19:48 <Pseudonym> It's only useful because it's ubiquitous.
16:20:30 <Pseudonym> If SCons was everywhere, make would be gone.
16:20:56 <tuomov> dons: got it to build
16:21:10 <goron> Can you use TH to code generic traversals over ASTs?
16:21:10 <dons> tuomov, what were the issues in the end?
16:21:29 <tuomov> many :)
16:21:37 <goron> dons: Yi is a pain to build, btw.
16:22:04 <dons> goron, please elaborate, I try to make it easy.. :)
16:22:33 <dons> tuomov also. anything that was hard and should be fixed or clarified?
16:22:33 <goron> dons: Well, the biggest problem is that you need to find in textfiles that you need to other dependency.
16:22:48 <tuomov> no, I don't think so
16:23:03 <goron> dons: So, on the page where you can get the darcs code, please add the other relevant links.
16:23:05 <tuomov> besides having too many dependencies that are not debian packages :)
16:23:06 <dons> goron, you want ./configure to detect hs-plugins and hsx etc.
16:23:08 <goron> dons: or provide a script.
16:23:15 <dons> goroon, good idea.
16:23:26 <dons> tuomov, sigh. yes
16:23:35 <dons> well, isn't it just hsx that isn't in debian?
16:23:39 <goron> dons: yy
16:23:43 <goron> dons: ty
16:23:59 <tuomov> hs-plugins too..
16:24:00 <dons> ?/
16:24:06 <dons> oh.
16:24:39 <goron> How sinfull is it to code PHP?
16:24:49 <dons> I should also switch hs-plugins to cabal. it's build system is too tricksy, esp, since it is just building three libs
16:25:16 <dons> goron, so yi is hard because finding dependencies was difficult? 
16:25:42 <dons> btw, you do lose karma when you `code' in php
16:25:46 <Pseudonym> goron: Coding PHP isn't a sin, it's a penance.
16:25:46 <tuomov> sigh. do I really need to install window$ to upgrade the firmware on my adsl router..
16:25:53 <dons> I would say `eat spaghetti' instead of `code'
16:26:10 <tuomov> it supports tftp put of the firmware, but it doesn't do anything after that
16:26:11 <goron> dons: Well, that was the biggest problem, yes. Manageable, but a pain.
16:26:26 <goron> dons: No, not my karma!
16:26:30 <dons> ok. I will make dependencies easier to find. cheers.
16:26:43 <Pseudonym> Mmmm... spaghetti...
16:27:17 <LFH> Pseudonym: penance for which sin? Not having an apache module that understnds hskell? Is there sucha thing?
16:27:56 <goron> dons: I installed FreeBSD on the workstation. That sure would make up on the karma :D
16:28:21 <dons> goron ,definitely!
16:28:26 <dons> @karma+ goron
16:28:27 <lambdabot> goron's karma raised to 2.
16:28:35 <dons> ex_nor, hi!
16:28:44 <goron> @karma shapr
16:28:45 <lambdabot> shapr has a karma of 0
16:28:52 <dons> ex_nor, are you in sydney?
16:29:30 <dons> poor shapr. that doesn't sound right.
16:29:41 <Pseudonym> LFH: I think that coding in PHP is its own punishment.
16:30:01 <Pseudonym> Actually, that's not entirely true.
16:30:13 <Pseudonym> The punishment for coding in PHP is administering an insecure PHP application.
16:30:26 <LFH> Pseudonym: I prfere writing PHP when the only alternative is HTML
16:30:42 <paolo-> PHP and HTML comes for different purposes.
16:30:46 <Pseudonym> Surely.
16:30:54 <goron> LFH: you are not well informed.
16:30:55 <Pseudonym> PHP is slightly superior to SSI.
16:31:06 <LFH> Yes, but PHP can make life easy in the context of HTML
16:31:09 <Pseudonym> But like SSI, it's a very thin layer of glue.
16:31:28 <goron> LFH: There's a module for haskell. You may guess how it's called.
16:32:00 <LFH> goron: apache module? I am interested
16:32:19 <goron> Well, at least there was. I think I saw a current page <2 months ago.
16:32:57 <goron> http://losser.st-lab.cs.uu.nl/mod_haskell/
16:33:03 <goron> My great university :D
16:33:04 <paolo-> @index liftM
16:33:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
16:33:06 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
16:33:06 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
16:33:28 <goron> No, it's not *that* great, but neither are others.
16:33:40 <LFH> Pseudonym: sepcially since CSS 2.0 is not implemented corretly by any respectable brwoser, you *have* to hack PHP eg if you want to translate latex to html
16:34:15 * goron doesn't respect browsers :)
16:34:17 <Pseudonym> Translate latex to html?!
16:34:20 <Pseudonym> Yikes!
16:34:25 <lispy> hmm...we should be fixing the browsers instead of hacking the websites :)
16:34:31 <goron> My page only work with Konqueror for now.
16:34:43 <goron> Firefox doesn't implement some element.
16:34:49 <lispy> goron: does it work with safari transitively?
16:34:59 <goron> lispy: I'd guess so.
16:35:17 <lispy> goron: /msg me with the url and i'll try it the next time i'm in safari
16:35:30 <SyntaxNinja> what's Philippa's wiki called?
16:35:32 <goron> lispy: It's on an intranet.
16:35:35 <Heffalump> flippi?
16:35:36 <lispy> ah
16:35:44 <lispy> goron: heheh, send me the link anyway ;)
16:35:46 <LFH> thanks goron, I will look at it. Do you use it?
16:35:48 <lispy> i'll get in :)
16:35:48 <SyntaxNinja> Heffalump: thanks
16:35:49 <goron> lispy: Maybe I will put it out in the wild someday.
16:35:58 <goron> lispy: Nah, you won't.
16:36:13 <lispy> goron: i have no interest in being an intruder, i'm just teasing
16:36:16 <goron> lispy: Pretty secure environment. Professional people.
16:36:19 <goron> lispy: I know.
16:36:58 <goron> lispy: I do have a website with empty content on it. :D
16:41:03 <goron> Is it possible to express generic traversals in Haskell with some standard extensions?
16:41:28 <LFH> goron: Do you know if it works with apache2? Teh latest cvs version seems to be 3 years old...
16:41:40 <lispy> i herd someone mention generic traversals and GADTs
16:42:11 <goron> lispy: Hmm, to bad I didn't hear that person. Seems an interesting person :)
16:42:30 <goron> LFH: Will look.
16:42:56 <dons> my first non-testing problem solved with h4sh: echo $PATH | map "map (\c -> if c == ':' then '\n' else c)" | grep -v dons | intersperse ':' | concat
16:43:09 <goron> 18 Apr 2002: you can now try out the experimental Apache 2.0 / GHC version of mod_haskell. The source code is in our CVS repository, branch ghc.
16:43:25 <goron> LFH: looks Apache 2.0 to me...
16:43:32 <dons> intersperse should have a shorter name.
16:43:32 <LFH> goron: anu idea what Eric Meijer does at Microsoft?
16:43:37 <lispy> dons: what does that do it truns : into new line?
16:43:39 <goron> LFH: making money?
16:43:47 <goron> LFH: Burning research papers?
16:43:59 <goron> I guess both.
16:43:59 <dons> lispy, filters out my home directory from my $PATH
16:44:18 <lispy> dons: hehe, nice
16:44:34 <lispy> dons: but how is that useful?
16:44:36 <goron> LFH: I know some stuff he had done in the past. He's not really "in the picture" any more.
16:44:52 <LFH> goron: I meant hasdkell-wise? Why did they employ him and loads of other haskell guys?
16:45:07 <dons> lispy, oh, I need to test if hsx really needs happy, and happy is in my homedir, so I want to make it invisible.
16:45:18 <goron> LFH: I can only guess.
16:45:29 <goron> LFH: Talk to strategic management of MS.
16:45:42 <dons> lispy, export PATH=`the above function`
16:46:20 <lispy> dons: heheh, you really are criminally insane :)
16:46:23 <goron> LFH: MS-boss:"Buy all the smart people, and keep them busy, so they can't interfere with our masterplan".
16:46:29 <goron> LFH: something like that?
16:46:36 * Heffalump wonders what happened to his copy of the CC '03 proceedings
16:46:55 <stepcut> dons: howabout, putBetween :p
16:47:26 <dons> its a pity I have to use grep, and also that intersperse has such a long name
16:47:40 <dons> (filter doesn't work on regexes, oh well)
16:47:58 <stepcut> putBetween is a whole letter shorter than intersperse :p
16:48:00 <LFH> goron: thanks about that apache2 . should have read the NEWS, somehow missed the first line...
16:48:05 <dons> stepcut :p
16:48:18 <dons> how about: sprinkle
16:48:23 <goron> LFH: Missing stuff is sometimes efficient, sometimes it's not.
16:48:26 <stepcut> hrm, sprinkle sounds random
16:48:51 <stepcut> why doesn't filter work on regexs ?
16:49:15 <dons> oh, well, it does. but not easily
16:49:17 <dons> @type filter
16:49:19 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:50:01 <stepcut> couldn't you make a filterRegex or something that does ?
16:50:20 <dons> so it would be: filter '\s -> let r = mkRegex "dons" in case matchRegex r ...
16:50:43 <stepcut> or maybe a a builtin function like 'rgx' --> filter (rgx ".*")
16:50:45 <dons> stepcut,  i'm thinking that a more List like interface to Text.Regex might be useful
16:50:58 <dons> yes. rgx :: String -> Bool
16:51:07 <stepcut> yeah
16:51:26 <dons> and then maybe sub :: String -> String -> String
16:51:39 <stepcut> to replace sed ?
16:51:51 <stepcut> well, not all of sed, but what most people do with sed
16:52:09 <dons> it would do s/// and s///g, but also for use in the other commands.
16:52:36 <dons> another thing we lack is slicing lists easily
16:52:52 <dons> I want to say slice :: Int -> Int -> [a] -> [a]
16:53:19 <wilx> What is the meaning of the ints?
16:53:23 <wilx> Bounds?
16:53:35 <dons> yep.
16:54:07 <LFH> slice m n = drop m $ take n
16:54:30 <wilx> What about more than one continuous range? Think perl.
16:54:41 <wilx> @foo[1,3,5..10];
16:54:42 <lambdabot> Unknown command, try @listcommands.
16:54:47 <wilx> Heh.
16:55:09 <dons> hmm.
16:55:24 <dons> LFH, yep sure. I think I'll add it to a ListPlus.hs for use in h4sh
16:56:06 <lispy> @todo
16:56:06 <dons> or MissingList.hs (isn't that the convention?)
16:56:07 <lambdabot> 0. SamB: A way to get multiple results from a google search
16:56:07 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
16:56:07 <lambdabot> 2. SamB: stop mangling long urls
16:56:07 <lambdabot> 3. dons: improve formatting of @dict
16:56:07 <lambdabot> 4. dons: write Haskell Manifesto
16:56:09 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @
16:56:11 <lambdabot> foo across lines
16:56:13 <lambdabot> [5 @more lines]
16:56:20 <lispy> @more
16:56:21 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
16:56:21 <lambdabot> 7. TheHunter: @type 1 :: Int
16:56:21 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.
16:56:21 <lambdabot> It would be nice if it also let you find functions in the given
16:56:23 <lambdabot> module that use a type.
16:56:44 <lispy> dons: oh, look room on the todo list :)
16:57:16 <lispy> dons: BTW what is the haskell manifesto?  I'm assuming that's an inside jobke...
16:57:50 <dons> um. i'd have to check the logs. I think it was some grand plan for how we'd take over the world
16:57:53 <LFH> @get-shapr
16:57:55 <lambdabot> Unknown command, try @listcommands.
16:59:03 <Igloo> Hmm, the Hacker Manifesto is longer than I remember
16:59:05 <LFH> what is number 6 about? who is a priviledged user?
16:59:27 <dons> a lambdabot developer
16:59:33 <Igloo> To long for me to bother trying to spoof right now  :-)
17:02:06 <LFH> @listcommands
17:02:07 <lambdabot> use listcommands [module|command], please. Modules are:
17:02:07 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
17:02:07 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
17:02:07 <lambdabot> spell state system todo topic type version vixen where
17:02:50 <LFH> @listcommands todo
17:02:51 <lambdabot> todo provides: todo todo-add
17:05:26 <lispy> so how do you remove things from the todo list?
17:05:42 <dons> privledged users can todo-del, I think
17:05:47 <lispy> ah
17:06:40 <cyanite> Why isn't stuff like getLine of type IO String and not IO (Either IOError String)  ?
17:06:50 <cyanite> s/isn't/is
17:07:16 <dons> because that would be annoying
17:07:46 <lispy> so what happens where getLine has an error?
17:07:48 <paolo> @index bracket
17:07:50 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.
17:07:50 <lambdabot> Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
17:07:57 <paolo> @type Control.Exception.bracket
17:08:00 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:08:26 <lispy> weird, what is braket for?
17:08:27 <paolo> @docs Control.Exception
17:08:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
17:09:16 <cyanite> so eh...
17:09:24 <cyanite> IO is a 'magic' in that way?
17:09:32 <lispy> ah, okay
17:09:35 <cyanite> i.e. you couldn't write something yourself like that?
17:09:49 <lispy> why not?
17:10:02 <cyanite> uhm..
17:10:36 <cyanite> it seems getLine is really IO  Either IOError String   but masquerades... or what?
17:10:36 <lispy> the idea behind bracket is really successful in lisp. they use macros.  They have things like with-open-file
17:11:51 <cyanite> does it make sense what I am saying? seems the IO monad is magic as far as its returnvalues go.
17:12:17 <lispy> would it be that getLine uses exceptions?
17:12:28 <lispy> @doc getLine
17:12:30 <lambdabot> getLine not available
17:12:34 <paolo> @index getLine
17:12:35 <lambdabot> System.IO, Prelude
17:12:35 <lispy> @index getLine
17:12:37 <lambdabot> System.IO, Prelude
17:12:39 <cyanite> well..  getLine :: IO String
17:12:48 <cyanite> with that signature, how could it return errors?
17:13:10 <lispy> @eval let { x :: Int; x = undefined } in x
17:13:12 <lambdabot> Prelude.undefined
17:13:18 <lispy> that's an exception
17:13:22 <lispy> at least in ghci it is
17:13:22 <cyanite> we have:  try            :: IO a -> IO (Either IOError a)
17:13:33 <lispy> cyanite: head can throw an exception
17:13:38 <lispy> @eval head []
17:13:39 <lambdabot> <Plugins.Eval>:1:12:
17:13:39 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:13:39 <lambdabot>   `Show a' arising from use of `show'
17:13:47 <lispy> hmm...
17:13:53 <lispy> @eval head ([]::[Int])
17:13:55 <lambdabot> Prelude.head: empty list
17:14:16 <lispy> @doc System.IO
17:14:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html
17:14:27 <cyanite> im just saying.. given try's type:     try            :: IO a -> IO (Either IOError a)                 what IO call will ever return an (Either... ) ?
17:15:05 <cyanite> like:   readFile   :: FilePath -> IO String
17:15:12 <cyanite> how would it be able to error if the file isn't there?
17:15:17 <cyanite> it has to return a IO String
17:15:17 <paolo> Argh, I can't read your pastes.
17:15:28 <paolo> @index try
17:15:30 <lambdabot> Control.Exception, System.IO.Error, Text.ParserCombinators.Parsec.
17:15:30 <lambdabot> Prim, Text.ParserCombinators.Parsec
17:15:30 * lispy either
17:15:35 <paolo> @docs Control.Exception
17:15:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Exception.html
17:15:42 <cyanite> I know how try is defined.
17:15:58 <cyanite> it expects something that can return an IO (Either IOError a)
17:16:03 <cyanite> but what can return that?
17:16:08 <cyanite> nothing I can see in the IO lib.
17:16:08 <lispy> cyanite: i dont' think it uses errors
17:16:09 <paolo> cyanite: nope.
17:16:13 <lispy> cyanite: i think it uses Exceptions
17:16:26 <cyanite> what is 'it' here?
17:16:34 <lispy> head, hGetLine
17:16:39 <lispy> take your pick :)
17:16:44 <lispy> @type head
17:16:46 <lambdabot> forall a. [a] -> a
17:16:51 <lispy> @eval head ([]::[Int])
17:16:52 <cyanite> but this is a pure language right?  so how are they done?
17:16:53 <lambdabot> Prelude.head: empty list
17:17:08 <paolo> @type Control.Exception.catch
17:17:10 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
17:17:12 <paolo> @type Control.Exception.try
17:17:14 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
17:17:41 <cyanite> yes... I know... but...
17:17:50 <lispy> we can't do IO here or else it may be possible to try to catch an exception from head
17:18:06 <paolo> It _returns_ and Either result which is (Right a) if no exception was raised, or (Left e) if an exception was raised and its value is e.
17:18:37 <cyanite> right ok soo...
17:18:40 <cyanite> the magic part is catch then?
17:18:44 <cyanite> which is internal?
17:19:07 <paolo> catch runs the handler if an exception occurs.
17:19:15 <lispy> @eval case head ([]::[Int]) of Left e -> e; Right v -> v
17:19:16 <lambdabot> Couldn't match `Int' against `Either a b'
17:19:24 <cyanite> how does this connect to a pure functional language?
17:19:27 <cyanite> catch      ::  IO a -> (IOError -> IO a) -> IO a 
17:19:27 <cyanite> catch      =   primCatch
17:19:41 <paolo> @libsrc Control.Exception
17:19:42 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Exception.hs
17:20:07 <lispy> i'm curious now how to catch the exception thrown by head
17:20:52 <cyanite> use evaluate
17:20:53 <cyanite> I think
17:22:06 <paolo> Control.Exception.catch (head [] >> return ()) (putStrLn.("I found: "++).show)
17:22:13 <paolo> lispy: try that in GHCi.
17:23:17 <Cale> or:  try (evaluate (head [])) >>= print
17:23:40 <paolo> Right.
17:23:43 <paolo> err, Left ;-)
17:23:59 <lispy> ah yeah
17:24:31 <lispy> so how is that defined in head?  head [] = error "empty list"?
17:24:38 <lispy> @libsrc Prelude
17:24:38 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
17:25:14 <paolo> @index error
17:25:16 <lambdabot> Prelude
17:25:20 <lispy> @index head
17:25:20 <paolo> @type error
17:25:21 <lambdabot> Data.List, Prelude
17:25:21 <lambdabot> forall a. [Char] -> a
17:25:33 <paolo> heh
17:25:48 <lispy> @libsrc Data.List
17:25:49 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
17:26:34 <lispy> i can't find the place where head is defined
17:26:37 <lispy> oh well
17:26:40 <cyanite> so... to sum up:   exception information is internal to the monad.  correct?
17:26:55 <cyanite> and handled by IO's implementation of >> and >>= etc.
17:27:07 <cyanite> *to the IO monad, I meant.
17:27:10 <lispy> did you see the type of error?
17:27:29 <lispy> it has any type
17:27:35 <cyanite> ?
17:27:38 <lispy> so when you return an error it just propagates up
17:27:40 <lispy> @type error
17:27:42 <lambdabot> forall a. [Char] -> a
17:27:56 <cyanite> right ehm.. yeah but that's not really...
17:28:05 <cyanite> the point is IO String can carry exception info in it.
17:28:17 <lispy> not really
17:28:18 <cyanite> if for instance it results from readFile
17:28:32 <cyanite> if not, where does this exception info magically come from?
17:28:38 <cyanite> readFille :: IO String
17:28:44 <lispy> from things like error
17:28:51 <cyanite> .... I mean in the language
17:28:53 <paolo> cyanite: the exception handling is magically brought to you by the compiler/interpreter, it seems.
17:29:03 <lispy> @type undefined
17:29:05 <lambdabot> forall a. a
17:29:14 <cyanite> I don't think so paolo... I am sure it's captured inside the IO monad.
17:29:17 <Cale> @type error
17:29:19 <lambdabot> forall a. [Char] -> a
17:29:21 <paolo> cyanite: it is not
17:29:26 <cyanite> How do you know?
17:29:39 <paolo> cyanite: see the type of error Cale just requested.
17:29:52 <cyanite> yes, and?
17:29:59 <paolo> No IO showing up there.
17:30:00 <lispy> cyanite: so error returns something.  And it happens to be something that further computation in the monad until it is caught
17:30:28 <lispy> "...something that aborts..."
17:30:40 <lispy> it behaves like mzero
17:30:52 <cyanite> well... error IS magic.
17:31:09 <cyanite> doesn't mean that the IO monad doesn't carry exceptions in it. those aren't errors.
17:31:13 <paolo> cyanite: yes.
17:31:19 <cyanite> no they aren't.
17:31:21 <cyanite> the repport say so.
17:31:27 <cyanite> since you can recover from them.
17:31:32 <paolo> I was answering "error IS magic".
17:31:38 <cyanite> ah
17:31:39 <cyanite> yes :p
17:31:41 <cyanite> I agree.
17:31:47 <cyanite> defined:
17:31:48 <cyanite> -- error stops execution and displays an error message
17:31:48 <cyanite> error            :: String -> a
17:31:48 <cyanite> error            =  primError
17:31:51 <cyanite> pretty magic :p
17:32:20 <cyanite> catch, I guess, just taps into the internals of the IO <whatever> monad and extracts the error if any.
17:32:39 <cyanite> and if you try to use an IO String which carries an exception, it fails..  that must be in >> and >>=
17:32:55 <cyanite> hm.. makes sense.
17:33:34 <cyanite> and if an IO a ever reaches the top level, error is invoked i guess.
17:33:56 <Cale> hm?
17:34:35 <lispy> http://www.haskell.org/onlinereport/io-13.html#io-exceptions
17:34:50 <cyanite> it prolly just calls fail at the top level, which calls error.
17:34:50 <lispy> "Any I/O operation may raise an exception instead of returning a result."
17:35:04 <cyanite> yes lispy, but that doesn't explain the mechanics.
17:35:10 <Cale> It's possible (behind the scenes) to have values with pure types whose evaluation has effects.
17:35:11 <cyanite> i.e. how it works at the monad level.
17:35:44 <Cale> For instance, through unsafePerformIO
17:35:55 <cyanite> yes but my guess is that exceptions are in the IO monad.  and composing IO a >>= IO b where IO a carries an exception, will propagate that to IO b without performaing any new operations.
17:36:07 <cyanite> and so on.
17:36:27 <Cale> well, there's one easy way to find out :)
17:36:32 <paolo> How does something propagate if nothing is been done afterwards?
17:37:43 <cyanite> IO a >> IO b   will just construct an IO b carrying the same exception as the IO a did.
17:37:57 <cyanite> not performing the actions of the original IO b.
17:38:32 <lispy> usually exception handling systems use unwinding
17:38:44 <paolo> I think exceptions break the execution.  That's why they exist?
17:38:46 <cyanite> I don't think exception handling is magic in haskell
17:38:49 <lispy> when an exception is raised, the stack is unwound back to the handler
17:38:53 <cyanite> I think it's implemented with monads.
17:38:54 <Cale> does cvs.haskell.org seem down to anyone else?
17:39:10 <paolo> Cale: it does work here.
17:39:15 <Cale> I'm fairly sure exception handling is at least somewhat magic.
17:39:31 <cyanite> I know it CAN be done with monads.  there are examples, see for instance: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm     under "Exceptions, exception handling, and backtracking"
17:39:33 <lispy> Cale: i was able to get to the website
17:39:39 <cyanite> so it CAN be fone.   pretty sure it IS also.
17:39:41 <paolo> I'm with Cale, I didn't tell you about unsafePerformIO before, but it is prolly the magic you're thinking og.
17:39:41 <cyanite> *done
17:39:43 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
17:39:44 <paolo> of, even.
17:39:50 <Cale> does that link work?
17:39:59 <paolo> Cale yes
17:40:03 <Cale> hmm..
17:40:06 <Cale> not for me
17:40:43 <dons> hmm. does $_ behave like a state monad state?
17:40:46 <dons> $_ in perl.
17:40:56 <cyanite> no unsafePerformIO in prelude or IO lib.
17:41:05 <paolo> @index unsafePerformIO#
17:41:06 <lambdabot> bzzt
17:41:09 <paolo> IIRC...
17:41:11 <paolo> @index unsafePerformIO
17:41:12 <lambdabot> System.IO.Unsafe, Foreign
17:41:23 <paolo> @docs System.IO.Unsafe
17:41:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.Unsafe.html
17:41:46 <cyanite> still... not too magic.
17:41:56 <cyanite> welll. .yeah
17:41:58 <cyanite> that part is a bit ;)
17:42:03 <cyanite> breaking the normal usage.
17:42:10 <cyanite> but... that's hardly related to exceptions.
17:42:47 <paolo> The rest of the magic are GHC internals.
17:43:04 <cyanite> I still maintain that exceptions can be done with monads without any magic.
17:43:09 <cyanite> there are examples of that.
17:43:14 <lispy> cyanite: alright, you convinced me with that url, exceptions probably are propogated that way
17:43:22 <cyanite> :)
17:43:23 <paolo> The fact that they can be done doesn't mean it is the best/used solution in GHC.
17:43:28 <Cale> I'm sure they could be, but I don't know whether they are
17:43:33 <paolo> I don't know, tough.
17:43:37 <cyanite> Ah.. me neither..
17:43:42 <cyanite> but conceptually. they are.
17:43:48 <paolo> They could.
17:43:48 <cyanite> so we don't need to believe in magic :)
17:44:07 <cyanite> just like conceptually IO contains the entire environment and me, the user.
17:44:11 <cyanite> although... it really doesn't.
17:44:17 <Cale> Well, actually, there is a bit of magic involved in exceptions from pure values
17:44:29 <cyanite> that I don't know.  was also talking about them in monads.
17:44:46 <lispy> Cale: well, everything happens inside the IO monad
17:44:46 <Cale> for example, you can have a value of type () which when evaluated causes the program to crash :)
17:45:00 <lispy> Cale: whether from main or ghci
17:45:07 <cyanite> yeah.
17:45:15 <Cale> lispy: But you don't want to think of it that way semantically
17:45:26 <cyanite> funny..
17:45:30 <cyanite> I feel the opposite :p
17:45:36 <lispy> yeah, me to
17:45:44 <cyanite> I don't care HOW it's done, but it _seems_ to be to be done using normal monad things.
17:45:57 <cyanite> i.e... it's well known that you can do it yourself, with monads.
17:45:59 <cyanite> and no magic.
17:46:05 <Cale> @type error "Hello"
17:46:07 <lambdabot> forall a. a
17:46:15 <Cale> @type error "Hello" :: ()
17:46:16 <cyanite> the only magic in 'catch' is that it taps into the monad, like >>= and >> also do.
17:46:17 <lambdabot> () :: ()
17:46:21 <paolo> :-)
17:46:24 <cyanite> I agree that error IS magic.
17:46:30 <cyanite> but that's not exceptions.
17:46:38 <Cale> yes it is :)
17:46:53 <cyanite> ehm no... exceptions may _result_ in a call to error
17:46:56 <cyanite> if they reach the top level.
17:47:08 <cyanite> that's still easily done within the monad.
17:47:12 <Cale> errors can be caught by try
17:47:26 <cyanite> yes, try is just sugar around catch and catch just taps into the IO monad.
17:47:46 <cyanite> errors from error?
17:47:47 <cyanite> ehm..
17:47:52 <Cale> yes
17:48:07 <lispy> there was an example earrlier
17:48:07 <Cale> try (error "Hello") >>= print
17:48:09 <lispy> i tried it myself
17:48:48 <cyanite> and?
17:48:52 <Cale> of course, that's evaluating to an IO action there, so not surprising
17:49:01 <Cale> try (evaluate (error "Hello" :: ())) >>= print
17:49:13 <Cale> same result
17:49:25 <cyanite> try isn't magic, for sure.
17:49:29 <cyanite> evaluate.. what does it do?
17:49:37 <Cale> @type evaluate
17:49:39 <lambdabot> bzzt
17:49:40 <lispy> evaluate is magic, iirc
17:49:44 <Cale> @type Control.Exception.evaluate
17:49:46 <lambdabot> forall a. a -> IO a
17:49:59 <paolo> It evaluates its argument
17:50:11 <Cale> Just lifts values into the IO monad, and forces evaluation to whnf when executed.
17:50:12 <cyanite> so... evaluate evaluates a and returnes an IO whatever possibly carrying an exception.
17:50:15 <paolo> You use it to enforce order of IO operations.
17:51:00 <cyanite> doesn't seem too magic to me though.
17:51:01 <Cale> catch is magical, iirc
17:51:15 <cyanite> just lifts to IO, possibly with an exception in it.
17:51:37 <cyanite> catch could also just tap into the IO given to it and extract the exception if any.,
17:51:50 <cyanite> sicne catch is only defined on IO a
17:51:57 <cyanite> wouldn't need magic I think.
17:52:01 <paolo> I think it does
17:52:20 <cyanite> I can make a catch and try system working with my exception-monad.
17:52:30 <paolo> Where would it get `Exception' from, if not?
17:52:31 <cyanite> so it wouldn't be magic.  they did partially in that link I gave.
17:52:47 <cyanite> exception is just an internal thing.  non-exported
17:53:05 <cyanite> I don't see what you mean... hm.
17:53:07 <paolo> Yes but..
17:53:48 <paolo> Bah, I don't see it now, but I think it's magical in some way.
17:53:54 <paolo> It's 02:55 AM, too :-)
17:54:40 <cyanite> consider this:   catch   gets the IO a.  unfolds the IO monad (since it can do this, it's internal to IO), if there is an exeption in it, invokes the handler.  if not, returns the monad unchanged
17:54:48 <cyanite> this is not magic at all..  just monad-private operations.
17:55:03 <Cale> catch is written using catchException, which is written using catch# and which manipulates the inside of an IO data structure directly.
17:55:26 <Cale> catchException (IO m) k =  IO $ \s -> catch# m (\ex -> unIO (k ex)) s
17:55:27 <cyanite> yes but you can write stuff that manipulates your own monad's insides also
17:55:40 <wilx> Hmm, about the slice, assuming data SliceRangeUnit = forall a. SliceRange a => MkRange a and existing SliceRange type class, is there some Template Haskell magic that would allow me to generate list of MkRange a values from list mixed of Ints and (Int, Int)'s?
17:55:40 <Cale> note the use of unIO :)
17:56:02 <cyanite> unIO is magic, catch isn't
17:56:03 <paolo> unIO _is_ magical :-)
17:56:07 <cyanite> of course IO needs magic things.
17:56:10 <cyanite> but catch is clearly not.
17:56:17 <Cale> huh?
17:56:20 <cyanite> can't call everything magic because it uses magic stuff
17:56:24 <cyanite> then all haskell programs are magic
17:56:29 <Cale> no
17:56:31 <cyanite> since they eventually use unIO
17:56:55 <paolo> You miss the difference between potential and effective :-)
17:57:01 <Cale> by "magic", I mean that it does things beyond what an ordinary user can do.
17:57:11 <cyanite> yes but I can make magic then
17:57:17 <Cale> You can't write catch in Haskell 98
17:57:20 <cyanite> I can make a monad, make private stuff for it, and not expose it
17:57:26 <Cale> (without using catch)
17:57:28 <paolo> Try!
17:57:38 <cyanite> It's trivial, paolo, see my link.
17:58:02 <cyanite> you just pasted catch's implementation in haskell, right?
17:58:02 <Cale> There's no way to do it.
17:58:08 <paolo> I'd like to see your code.
17:58:13 <Cale> That was from GHC's source code
17:58:22 <cyanite> source code in haskell?
17:58:25 <Cale> yes
17:58:29 <cyanite> hence not magic.
17:58:51 <Cale> ugh
17:59:07 <paolo> Magic isn't non-haskell code.  Magic is something the ordinary user can't do.
17:59:14 <cyanite> paolo: you're missing the point...  I can make my _own_ monad, having state or whatever, and having a concept of exceptoins.  and I can make a function like catch to catch those like catch does.
17:59:28 <paolo> GHC isn't an ordinary user.
17:59:31 <Cale> cyanite: but you can't catch exceptions generated by error
17:59:39 <cyanite> Cale: never claimed I could.
17:59:43 <cyanite> Of course I can't
17:59:45 <Cale> so catch is magic
17:59:47 <cyanite> catch is at any rate internal to IO.
17:59:51 <cyanite> no it's internal
18:00:00 <cyanite> you wouldn't be able to catch exceptions in MY monad either
18:00:05 <cyanite> cause I wouldn't expose those things.
18:00:05 <paolo> cyanite: catch can "catch" exception from pure computations
18:00:11 <Cale> It's magic because you can't write it.
18:00:16 <cyanite> You miss the point.
18:00:30 <cyanite> I can write a myCatch which works on myMonad, catching myExceptions from it.
18:00:30 <paolo> Too much for me, have fun.  Good night!
18:00:43 <cyanite> and since I don't expose the internals of myMonad, you wouldn't be able to write it
18:00:46 <cyanite> so it's magic then?.
18:00:50 <cyanite> no, it's just module internal.
18:00:52 <Cale> Except that there are exceptions in types like ()
18:00:55 <Cale> which are nonmonadic
18:01:01 <Cale> which you can never catch
18:01:04 <Cale> but catch can
18:01:12 <cyanite> how?
18:01:20 <Cale> by being part of the RTS
18:01:20 <cyanite> that's would violate its signature, m?
18:01:32 <cyanite> signature for catch clearly demands an IO a
18:02:28 <Cale> sure, but there's no way for, say, evaluate, to tell that an error will be thrown by pure code
18:02:35 <cyanite> IF catch works on non-io monads, then it violates its signature.
18:02:42 <shapr> g'night paolo
18:02:48 <cyanite> evaluate is magic, I agree.
18:02:58 <Cale> evaluate is less magical than catch is
18:03:04 <cyanite> ehm no.
18:03:09 <cyanite> catch only works on IO a?
18:03:13 * shapr throws monads at cyanite 
18:03:15 <cyanite> as its type implies?
18:03:29 <cyanite> catch ::  IO a -> (IOError -> IO a) -> IO a
18:03:38 <Cale> all that evaluate does is to force evaluation to WHNF, and then return.
18:04:04 <cyanite> evaluate is magic since it captures 'errors' of some kind, and lift them into an IO a manod.
18:04:07 <cyanite> monad.
18:04:09 <Cale> no
18:04:14 <Cale> it doesn't do anything like that
18:04:20 <cyanite> so what does it do?
18:04:23 <paolo> shapr: hi, still shutting things down.  I would have liked to put the cairo code I have on the darcs repo today but I didn't succeed.  I've like 10 function to go to have a complete binding tough.  :-)
18:04:32 <shapr> paolo: awesome!
18:04:37 <cyanite> it's  evaluate :: a -> IO a   right?
18:04:43 <Cale> It merely forces its argument to be evaluated and returns the result in the IO monad.
18:04:51 <cyanite> ok
18:04:57 <paolo> Then, monadic interface and gtk2hs integration.  Afterwards: eat icecream like a king.
18:04:59 <Cale> It doesn't touch the exceptions.
18:05:07 <cyanite> what exceptions?
18:05:13 <paolo> Keep throwing monads| - I need sleep :-)
18:05:22 <Cale> any that are affected by that evaluation
18:05:42 <cyanite> what makes you think those are exceptions?  and not just 'error'?
18:05:56 <Cale> error produces exceptions.
18:06:14 <cyanite> not from what I can read in the prelude.
18:06:41 <shapr> paolo: g'night!
18:06:50 * shapr contributes to paolo's ice cream fund.
18:07:07 <cyanite> prelude states nothing about exceptions, it says stops the program.
18:07:40 <cyanite> how would you catch an exception from error?
18:08:16 <Cale> try it:  try (evaluate (error "Hello" :: ())) >>= print
18:08:30 <cyanite> yes but that only proves that error and evaluate are magic
18:08:49 <cyanite> i.e. evaluate magically catches the error, wraps it into an IO exception and returns that monad
18:08:54 <cyanite> for catch to unmagically process.
18:09:08 <Cale> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
18:09:18 <Cale> It doesn't do anything regarding exceptions
18:09:27 <cyanite> and error?
18:09:45 <TheHunter> cyanite, try (print =<< error "Hello") <-- same thing, no evaluate involved.
18:10:00 <cyanite> so error is magic.   error must return an IO monad
18:10:05 <cyanite> with the exception packed in.
18:10:13 <cyanite> otherwise it would violate the type of catch
18:10:35 <cyanite> and thus also try.
18:10:40 <cyanite> since it just uses catch.
18:10:43 <cyanite> and catch is typed  catch      ::  IO a -> (IOError -> IO a) -> IO a
18:11:07 <Cale> error s = throw (ErrorCall s)
18:11:13 <Cale> throw exception = raise# exception
18:11:35 <cyanite> well... catch has a type
18:11:41 <cyanite> which must be upheld. true?
18:12:06 <cyanite> so whatever error 'returns' it must be able to mimic as IO a
18:12:31 <cyanite> unless they just put catch      ::  IO a -> (IOError -> IO a) -> IO a   for fun.
18:12:55 <Cale> sure, you have to obey that type when using catch
18:13:00 <cyanite> yes
18:13:03 <Cale> that doesn't mean that catch isn't primitive
18:13:05 <TheHunter> well, at the level where error and catch are implemented, there is no IO. You're living in the world of magic there where evaluating something can have a side effect.
18:13:18 <cyanite> this doesn't prove anything except that error is magic.
18:13:25 <cyanite> error can return stuff that can mimic as IO a
18:13:31 <cyanite> an IO carrying an exception.
18:13:35 <Cale> catch has to be magic in order to stop error from halting the program
18:13:39 <cyanite> no
18:13:45 <cyanite> error has to be magic for that.
18:13:49 <Cale> what?
18:13:57 <cyanite> error is what is fed into catch
18:14:01 <cyanite> catch _only_ accepts IO a
18:14:02 <Cale> error has to be magic in order to halt the program
18:14:11 <cyanite> so error must return IO a to catch
18:14:16 <Cale> catch has to be magic in order to tell that error will do that and prevent it
18:14:31 <cyanite> unless error just checks its context
18:14:35 <cyanite> and decides what to do.
18:14:43 <Cale> you can't write an ordinary IO action which prevents error from halting the program.
18:14:52 <Cale> (without using try or catch)
18:14:55 <cyanite> no, because I can't reach into IO
18:14:57 <cyanite> but this is normal
18:14:58 <Cale> right
18:15:02 <Cale> this is magic
18:15:05 <cyanite> I can make a module you can't reac into either.
18:15:07 <cyanite> no
18:15:13 <Pseudonym> ~http://www.theonion.com/news/index.php?issue=4133&n=2
18:15:23 <cyanite> doesn't prove it's magic.  more than my un-exposed module code is.
18:15:26 <dons> cabal  rules. $ filter 'match "zygy$"' /usr/share/dict/words
18:15:26 <dons> syzygy
18:16:11 <Cale> error isn't part of IO though. It has nothing to do with the IO monad.
18:16:17 <cyanite> Cale: but I agree with this:  either error checks depending on context what to do -- magic!    _or_ catch tells error what to do -- magic!!
18:16:28 <cyanite> Cale: but I believe in the former, since error is magic already.
18:16:41 <Cale> they're both magical, if you look at how it's done
18:16:53 <cyanite> They wouldn't need to be.  error would 100%.
18:17:00 <cyanite> how is catch done then?
18:17:19 <Cale> Essentially via a primitive which compiles to some C code.
18:17:32 <Cale> afaict
18:17:54 <Cale> It's right down at the level of evaluation.
18:18:01 <cyanite> if so, it could or could not be magic.   the point is, it wouldn't 100% need to be, if error was more so. :).   but it comes down to internals here
18:18:14 <Cale> It's not implemented as Haskell code in the IO monad.
18:18:23 <Cale> which means that it's using magic
18:18:30 <cyanite> it means it could.
18:18:37 <cyanite> my main point in all this is...
18:18:41 <Cale> and really, it must
18:18:48 <cyanite> nope. I disagree.
18:18:51 <cyanite> my main point is though..
18:18:54 <Cale> because not even an ordinary IO action could stop error
18:19:09 <cyanite> unless error was magic enough to know it was in an io context.
18:19:14 <cyanite> my main point...
18:19:21 <Cale> error in an IO context still halts the program
18:19:35 <cyanite> if uncaught.. but that proves nothing
18:19:38 <cyanite> if I may ...
18:20:09 <cyanite> it's possible in haskell to write a monad encapsulating state and exceptions.  AND.. make a 'catch' function (called something else obviously) which would behave like catch on MY monad.  also resulting in 'error' if exceptions are left uncaught.
18:20:29 <Cale> sure, but what will the type of error look like?
18:20:36 <cyanite> what error
18:20:38 <cyanite> the final one?
18:20:39 <Cale> yours
18:20:41 <cyanite> just the error call
18:20:49 <cyanite> error... the normal one.
18:20:52 <Cale> ah
18:21:01 <cyanite> that catch would not be able to catch 'error' things, of course.  since error is magicly bound to the real catch.
18:21:07 <cyanite> whether by magic in error, catch, or both.
18:21:09 <Cale> I mean, the call which produces exeptions in your monad
18:21:17 <cyanite> yes I can do that of course.
18:21:26 <cyanite> those are my exceptions.. not IOexceptions.
18:21:36 <cyanite> or whatever error produces.
18:21:56 <Cale> You could, but if your errors have type forall a. a, then you won't be able to catch them without magic.
18:22:20 <cyanite> my errors would be monad errors
18:22:22 <cyanite> obviously.
18:22:24 <Cale> yes
18:22:41 <cyanite> errors from 'error' requires magic in either error or catch or both.
18:22:52 <Cale> I'm saying both :)
18:23:04 <cyanite> yes... but one can implement haskell so it doesn't.
18:23:21 <cyanite> how it is now, I don't know and it's largely irrelevant
18:23:30 <cyanite> error-catch are magicly bound.
18:24:45 <cyanite> anyways....
18:24:47 <cyanite> gotta jet.
18:24:49 <cyanite> take care :p
18:24:52 <Cale> okay, later :)
18:24:57 <cyanite> l8r
18:26:08 <TheHunter> sigh, i was just about to explain why both 'error' and 'catch' clearly need magic.
18:26:50 <shapr> Go for it, enlighten us!
18:27:31 <Cale> I think that he's saying that it would be possible to implement error in such a way that it's able to detect being caught as an upvalue or something.
18:27:53 <Cale> but I don't think that's possible to implement
18:28:05 <shapr> upvalue? like a top value?
18:28:47 <Cale> like, in some languages based on pattern matching  you can define a value "a" such that cos(a) = 2, for instance, and it's part of the definition of "a" and not of "cos"
18:28:48 <TheHunter> actually, every basic IO operation needs magic to be implemented, so what's the point?
18:29:29 <shapr> Yeah, I was thinking that too.
18:29:29 <Cale> If catch is really implementable without magic, then it would require a test for functional equality if error is to detect that there is an upward catch.
18:29:33 <shapr> You can't write IO in Haskell.
18:29:53 <Cale> so it's not possible even with upvalues
18:30:06 <Cale> (unless catch is special)
18:34:10 <TheHunter> Cale, that's a weird thought, indeed.
18:34:38 <Cale> yeah :)
18:34:56 <Cale> I think that Control.Parallel.Strategies should be made to use the Data class rather than NFData -- is there any reason except history that it isn't?
18:35:35 <TheHunter> kinda like bending the rules of what is to be considered as magic, although what is really done stays the same.
18:35:38 <shapr> Send a patch!
18:35:51 <Cale> to where?
18:35:54 <TheHunter> performance?
18:36:00 <shapr> I still haven't quite understood why IO can't be implemented in Haskell directly.
18:36:07 * shapr forks GHC
18:36:15 <CosmicRay> Where can I learn about interfacing from C to Haskell?  For instance, I am writing a C module that I want to call from haskell, and I must have the same _FILE_OFFSET_BITS as the Haskell environment
18:36:19 <Cale> libraries@haskell.org?
18:36:36 <CosmicRay> my ghc environment has an include file that defines it in ghcautoconf.h
18:36:41 <CosmicRay> obviously this is not standard
18:36:44 <CosmicRay> is there a standard?
18:36:58 <Igloo> Is it in HsFFI?
18:37:12 <CosmicRay> HsFFI.h does eventually wind up including that file, yes.
18:37:21 <Igloo> I think that's standard, but I'm not sure
18:37:26 <CosmicRay> I have seen some examples of people using it, but I don't know if it's the "correct" way to go
18:37:31 <CosmicRay> I also want to be portable to hugs
18:38:43 <Igloo> The FFI spec would be the splace to look
18:39:56 <Igloo> Bah, dealing with the identity case of   data Foo a = Foo (a Int) (a Char) ... is a PITA
18:40:21 <CosmicRay> ah, sure enough, under C-Specific Marshalling near the end.
18:40:32 <mwc> a is a parameterized storage type?
18:40:58 <Igloo> Yeah; Id or Maybe in particular
18:41:19 <mwc> hmm, is there a way to limit that to a member of some class?
18:41:35 <mwc> (FooStorage a) => a ?
18:41:58 <Cale> rnf x = everything seq (\y -> y `seq` ()) x -- should that always work? (It seems to, I'm not entirely comfortable with Data.Generics though)
18:42:07 <Igloo> I don't see how that would help?
18:42:32 <mwc> Dunno, what do you mean with the identity case?
18:42:37 <mwc> Id?
18:42:44 <Igloo> newtype Id a = Id a
18:42:48 <mwc> Ah
18:42:57 <Igloo> It means I have fromId's and suchlike all over the place
18:43:22 <TheHunter> Cale, that's awfully slow, unfortunately.
18:43:24 <mwc> Why can't you do: data Foo = Foo Int Char | Foo2 Char
18:43:25 <mwc> etc
18:43:33 <Cale> TheHunter: slow?
18:43:47 <TheHunter> factor 5 in my little toy program.
18:43:57 <Cale> hmm
18:44:03 <mwc> Igloo, use seperate Foo data constructors for the different cases
18:44:40 <Igloo> I think you're misunderstanding the problem
18:45:00 <mwc> It's ugly to have all the maybe/id boxing
18:45:01 <mwc> ?
18:45:01 <TheHunter> can also make the factor 10 by tweaking the parameters.
18:45:13 <Cale> hmm...
18:45:49 <Cale> I get the impression that maybe it is applying seq needlessly in many cases (though this won't actually reevaluate, it may still cost some time to noop)
18:46:35 <TheHunter> there are many levels of indirection involved in 'everywhere', i guess.
18:46:43 <Cale> TheHunter: what's your toy program?
18:46:51 <TheHunter> one sec
18:47:00 <Cale> I think everywhere breaks up the structure a bit too much.
18:47:27 <Cale> er, everything rather
18:48:14 <TheHunter> http://hbin.dyndns.org/pastebin/75.html
18:49:04 <CosmicRay> Can I pick somebody's brain regarding large file support?
18:49:10 <CosmicRay> anyone acquainted with that?
18:51:54 <Cale> rnf :: (Data a) => a -> ()
18:51:54 <Cale> rnf x = everywhere (\y -> y `seq` y) x `seq` ()
18:52:01 <Cale> try that version, it seems faster
18:52:12 <TheHunter> y `seq` y ?
18:52:23 <Cale> er
18:52:27 <Cale> yeah, that's unnecessary :)
18:52:31 <Cale> hmm
18:52:50 <Cale> perhaps just y `seq` ()
18:53:15 <Cale> hrm
18:53:51 <Cale> oh, that doesn't work at all
18:53:56 <Cale> hmm.
18:54:03 <Cale> yeah, I see why
18:55:10 <Cale> y `seq` y is clearly silly :)
18:55:36 <lispy_> @pl \y -> y `seq` y
18:55:37 <lambdabot> join seq
18:55:44 <thebug> @yow
18:55:45 <lambdabot> Here I am at the flea market but nobody is buying my urine sample
18:55:45 <lambdabot> bottles ...
18:55:51 <thebug> :P
18:56:11 <Cale> hmm... so now I doubt it can be done with everywhere
18:56:29 <Cale> but everything seems to trace over the structure too much
18:56:38 * TheHunter doesn't even know what everywhere does.
18:56:58 <lispy_> @type join seq
18:56:59 <lambdabot> bzzt
18:57:04 <lispy_> @index join
18:57:05 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
18:57:05 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
18:57:05 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
18:57:11 <CosmicRay> metaperl: know anything about large file support in C?
18:57:12 <lispy_> @type Control.Monad.join seq
18:57:14 <lambdabot> forall a. (Monad ((->) a)) => a -> a
18:57:21 <metaperl> CosmicRay: I do not. sorry
18:57:25 <lispy_> @typ seq
18:57:26 <lambdabot> forall b a. a -> b -> b
18:57:42 <lispy_> hmm...so why did @pl suggest join?
18:58:14 <TheHunter> @type Control.Monad.Reader.join seq
18:58:16 <lambdabot> forall a. a -> a
18:59:19 <TheHunter> so, join :: (r -> r -> a) -> r -> a
18:59:38 <lispy_> ah
19:00:16 <dave_m> More generally, join :: Monad m => m (m a) -> m a
19:01:18 <lispy_> how do you read this? Monad ((->) a)
19:01:45 <lispy_> monad of type function taking something of type a?
19:02:00 <Cale> functions from a form a monad
19:02:37 <dave_m> it's easier to see with a type synonym: type Arrow a b = a -> b; then you have Monad (Arrow a)
19:03:24 <monochrom> You will have return :: b -> (a->b)
19:03:38 <lispy_> dave_m: that's not a valid type synonym is it?
19:04:09 <lispy_> monochrom: yeah, that's the same as my "english-ized" version right?
19:04:23 <monochrom> (>>=) :: (a->x) -> (x -> (a->y)) -> (a->y)
19:04:28 <monochrom> Yes.
19:04:52 <dave_m> lispy_: It is.
19:05:24 <dave_m> You couldn't use it in an instance declaration, though
19:05:47 <shapr> dave_m: hiya!
19:05:52 <TheHunter> with extensions, you should be able to.
19:06:11 <shapr> dave_m: Nice to meet you realtime, I'm Shae Erisson.
19:06:28 <dave_m> Hi Shae
19:07:47 <gzl> dons: still here?
19:09:04 <shapr> dave_m: Have you been here before?
19:09:42 <dave_m> shapr: not really; I just started playing with IRC a few days ago
19:10:07 <lispy_> dave_m: ah, welcome to freenode
19:10:17 <lispy_> free round of drinks on me!
19:11:06 * shapr grins
19:11:48 <dave_m> if I knew there were free drinks, I would have come sooner
19:12:00 <shapr> I think you'll like it here. The only downside is that discussions are so interesting they distract from productive work.
19:12:42 <monochrom> Monad ((->) a) is very unusual indeed.
19:12:53 <dave_m> shapr: it's 10:15pm where I am, so productivity is not an issue
19:13:14 <mwc> WOOO! EDT RULES THE WORLD!
19:13:36 <shapr> dave_m: Once you start irc'ing from work, it's time to start the 12 step program.
19:13:36 <monochrom> I am in EDT.
19:13:41 <monochrom> I am the centre of the world.
19:13:47 <shapr> Edinburgh time?
19:13:54 <monochrom> haha
19:14:01 <mwc> shapr, uh oh, that's the first thing I do when I get to work :(
19:14:16 <lispy_> heh
19:14:18 <lispy_> work?
19:14:22 <shapr> Yeah, me too
19:14:23 <monochrom> what are the 12 steps?
19:14:26 <dave_m> actually, I doubt IRC would get through our firewall. Pity.
19:14:28 <lispy_> oh, that thing between irc...
19:14:38 * Pseudonym thought the centre of the world was mostly molten iron
19:14:55 <shapr> Hi, my name is Shae and I'm an ircholic. I started irc'ing in 1989.
19:15:04 <lispy_> Pseudonym: well, how many colors is molten iron....
19:15:14 <monochrom> haha
19:15:15 <dave_m> "Hi, Shae"
19:15:23 <Pseudonym> I believe it's a black body radiator when you heat it enough.
19:16:02 * lispy_ takes a seat oat ircholic
19:16:22 <lispy_> "I'm just here to see a friend."
19:16:41 * shapr grins
19:17:27 <shapr> dave_m: Are you one of those lucky people who has a paying FP gig?
19:18:06 <dave_m> shapr: I wish; where I work we're lucky if we can use Perl
19:18:21 * Pseudonym is an algoholic
19:18:25 <lispy_> with the modern wonder that is the internet, why can't the FP geeks just found a company together -- even if they never meet in RL :)
19:18:27 <Pseudonym> Is that related?
19:18:48 <monochrom> they can meet at the molten iron
19:18:57 <Pseudonym> lispy_: That'd be great, assuming that actually making money wasn't an issue.
19:19:01 <Pseudonym> What would we do?
19:19:34 <lispy_> Pseudonym: sell services based on opensource FP software
19:19:42 <lispy_> that we build
19:20:25 <mwc> When I graduate, I've toyed with the idea of doing applied math related technical consulting work
19:20:29 <monochrom> You can turn Haskell into One Language to Rule Them All.  With the help of the heat from the Molten Iron.
19:20:30 <Pseudonym> Yes, I gathered that much.
19:20:30 <mwc> Models `R` Us
19:20:52 <dave_m> Sounds like something for Paul Graham's Y Combinator
19:20:57 <Pseudonym> Don't you need a market?  A business plan?  That sort of thing?
19:21:06 <Pseudonym> An identified need, or something?
19:21:09 <mwc> "One monad to rule them all, and in the darkness BIND them"
19:21:19 <Pseudonym> Or am I thinking too pre-dot-com-boom?
19:21:51 <Pseudonym> "LambdaNet: We do stuff!"
19:22:04 <dave_m> Pseudonym: we could start some sort of pyramid scheme: Have all the functional programmers sell functional programming tools to each other
19:22:10 <shapr> There are a bunch of things that Haskell would do well, first and foremost is 'sewage treatment', where you clean up messes in other languages.
19:22:12 <lispy_> "One monad to rule them all and in the darkness (>>=) them"
19:22:14 <Pseudonym> Oooh, I like that!
19:22:22 <monochrom> I donate my suggestion of using .\ as the company logo.
19:22:43 <mwc> Nah, too much traffic from stoned geeks trying to get to slashdot :P
19:22:46 <monochrom> haha lispy_ creepy!
19:22:49 <shapr> backslashdot
19:23:02 <monochrom> .\ looks like lambda
19:23:08 <mwc> yah
19:23:34 <lispy_> we could me mzero
19:23:40 <dave_m> This is the 21st century. Can't we just write λ?
19:23:44 <Pseudonym> Lambda the Penultimate
19:23:53 <lispy_> dave_m: hey, you cheated :)
19:23:58 <Pseudonym> I> looks like a dumb smiley.
19:24:00 <mwc> We could rent programmers out to software houses to stand behind their coders and make snide remarks about their progress
19:24:08 <Pseudonym> mwc: Great idea!
19:24:10 <lispy_> haah
19:24:34 <dave_m> don't they have managers for that?
19:24:56 <Pseudonym> Yes, but managers don't have clever arguments as to why progress is slow.
19:24:59 <monochrom> manager remarks are not snide enough
19:25:13 <Pseudonym> LambdaCom: Because we're smarter than you.
19:25:18 <monochrom> also managers speak in a language no programmer understands
19:25:22 <mwc> "Man, I could have done that in 2 lines."
19:25:46 <lispy_> "Lol, did you write that all by yourself?"
19:25:47 <monochrom> yeah, that one is only conceivable by programmers
19:25:49 <Pseudonym> LambdaCom: We could have done it so much better.
19:25:59 <mwc> "You could refactor this into a novel arrow construct you know."
19:26:13 <Pseudonym> LambdaCom: We have an infix operator for that.
19:26:28 <mwc> that one's really good
19:26:36 <dave_m> "You call that a coalgebra?"
19:26:38 <Pseudonym> LambdaCom: Sorry about the monomorphism restriction.
19:26:55 <lispy_> "Heh, that's not polymorphism"
19:27:21 <lispy_> "Oh, runtime error!  Guess you should have static typing..."
19:27:31 <Pseudonym> LambdaCom: We get it done... at most once, on demand.
19:27:39 <shapr> That one's good
19:28:04 <mwc> LambdaCom: Lazy coders with lazy tools
19:28:22 <lispy_> LambdaCom :: Business -> Demand -> IO (Solution)
19:28:45 <Pseudonym> OK, _that_ sounds like a manager.
19:28:48 <shapr> Oh I thought of an excellent use for Haskell, AI for games!
19:28:49 <lispy_> hehe
19:29:04 <lispy_> Pseudonym: yes, i meant that one for marketing
19:29:43 <mwc> Is there any distinction in haskell between a 1-tuple and a normal value?
19:29:54 <Pseudonym> mwc: Not in Haskell.
19:30:10 <mwc> Yeah, I was wincing in anticipation of a python style hack if there was one
19:30:22 <dave_m> shapr: I wonder if someone could weld hs-plugins into the Quake source code to replace Quake-C
19:30:30 <lispy_> @eval (,) 1 2
19:30:32 <lambdabot> (1,2)
19:30:44 <mwc> @type (,,)
19:30:44 <lispy_> @eval (1)
19:30:45 <lambdabot> 1
19:30:45 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
19:31:07 <mwc> hmm, I guess I forgot data constructors are functoins
19:31:12 <mwc> that should have made perfect sense
19:31:12 <shapr> dave_m: Probably, but I'm waiting for the Quake 3 source release.
19:31:23 <mwc> Learning Haskell is kind of like learning Tao in some ways
19:31:28 <Pseudonym> LambdaComMarketing :: [Buzzword] -> IO Code
19:31:43 <mwc> You have to give up all the kludges you've learned
19:32:07 <Pseudonym> The lambda that is seen is not the true lambda.
19:32:10 <lispy_> mwc: to learn new ones? ;)
19:32:43 <mwc> not really, I'm a mathematician
19:32:54 <Pseudonym> To program what can be programmed is not constant programming.
19:33:28 <lispy_> mwc: i hear you here
19:33:30 <lispy_> er there
19:33:32 <mwc> <voice persona="Neo">Whoa!</voice>
19:33:57 <Pseudonym> The state never changes.  This is called "fathomless purity".  The channel of the fathomless purity: This is call the basis of the calculus.
19:34:21 <mwc> Man, you oughta put those on the Wiki
19:34:26 <lispy_> we have a name for the void, ()
19:34:26 <mwc> Haskell Koans
19:34:34 <Pseudonym> The Tao of Haskell.
19:34:47 <lispy_> Pseudonym: it should be part of the haskell manifesto :)
19:35:34 <Pseudonym> Create it and fail to consume it: its name is "lazy".
19:35:53 <mwc> anybody else here ever caught themselves trying to contort their face into an emoticon?
19:36:01 <Pseudonym> mwc: No.
19:36:10 <lispy_> mwc: hehe
19:36:30 <mwc> damn, I need a reality check sometimes
19:36:41 <Pseudonym> Terminate state, junk side-effects, the people will benefit a hundred-fold.
19:36:59 <mwc> I used "ROFL" in an actual "in the meat" conversation today
19:37:16 <dave_m> mwc: did you spell it out, or try to pronounce it?
19:37:16 <mwc> a hundred-foldl?
19:37:21 * lispy_ whistles innocently
19:37:26 <mwc> dave_m, "Row-Full"
19:37:40 <lispy_> i'd say "raw-full"
19:37:56 <lispy_> but that's probably due to my west coast accent
19:38:27 <shapr> lol and rofl have become part of the standard language of teen swedes.
19:38:34 <dave_m> as long as you make it distinct from "ruffle"
19:38:37 <shapr> lol is even a verb.
19:38:42 <mwc> Nice
19:39:08 <Pseudonym> Worthy tallying doesn't use algorithms.
19:39:15 <Pseudonym> That's actually FROM the Tao Te Ching.
19:39:26 <mwc> really?!
19:39:30 <Pseudonym> Yup.
19:39:47 <lispy_> what does it use?
19:39:51 <mwc> The chinese had a derivative of an Arabic name 5000 years ago?!
19:40:01 <Pseudonym> I suspect it's the Chinese equivalent.
19:40:07 <mwc> Ahhh :P
19:40:17 <lispy_> but how can we know that the algorithms are equivalent?
19:40:22 <Pseudonym> To know its 'white'
19:40:22 <Pseudonym> and preserve its 'black'
19:40:23 <lispy_> that's undecidable
19:40:23 <Pseudonym> is to act as the world's paradigm.
19:40:45 <lispy_> para-dig-um
19:40:53 <Pseudonym> Indeed.
19:40:55 <mwc> who says that?
19:41:16 <lispy_> there was a really bad taco bell commercial where the guy pronounced it that way
19:41:22 <lispy_> he said they had to "change the para-dig-um"
19:41:30 <Pseudonym> I had a lecturer who pronounced it that way.
19:42:08 <mwc> People who say that should have their "fa-kade" rearragned by fist
19:43:02 <mwc> yeah, I was stretching it :(\
19:43:03 <Pseudonym> One of the rules of Usenet is that every language flame should contain at least one grammatical or spelling error.
19:43:11 <Pseudonym> "rearragned"
19:43:13 <Pseudonym> :-)
19:43:26 <monochrom> The monad that can be explained is not the real monad.
19:43:37 <mwc> damn, should of run spell check :(
19:43:49 <Pseudonym> Perhaps if Unix is Zen, Haskell is the Tao.
19:44:01 <Pseudonym> I think that might be a good analogy, actually.
19:44:20 <lispy_> heh, so what is christianity?
19:44:28 * lispy_ fears the response
19:44:35 <Pseudonym> Windows is Catholicism.
19:45:10 <dave_m> Umberto Eco once wrote that Mac OS was Catholic and Windows was Protestant
19:45:16 <Pseudonym> Perl is third-wave non-fundamentalist Evangelicalism.
19:45:22 <Pseudonym> Hmmm.
19:45:24 <mwc> Wouldn't that make Mac OS Unitarian?
19:46:05 <Pseudonym> Larry Wall constantly finds it interesting that his religion and his language have so much in common.
19:46:17 <lispy_> i would think linux would be universal unitarian since it combines so many unicies and runs anywhere
19:46:47 <Pseudonym> Isn't Linux only used it by unwashed long-haired hippies?
19:46:53 <dons> gzl: i'm here for about 10 mins
19:46:53 <Pseudonym> It's practically a love-in.
19:47:03 * mwc voted Tory and sports a crew cut
19:47:08 <gzl> dons: ok
19:47:26 <gzl> do you know what this is? keep getting it when I try to make h4sh
19:47:27 <gzl> runhaskell: waitForProcess: interrupted (Interrupted system call)
19:47:33 <mwc> there goes the long haired hippy theory
19:47:47 <Pseudonym> mwc: And you contort your faces into emoticons, so you're hardly one to talk.
19:47:53 <Pseudonym> Well, face.
19:48:12 <Pseudonym> mwc is multi-faceted, not two-faced. :-)
19:48:13 <gzl> dons: and as far as I can tell I have all the deps
19:49:34 <mwc> hahaha, I'm polymorphic
19:50:04 <Pseudonym> Parametric, subtype or ad-hoc?
19:50:13 <dons> gzl, you on the mac?
19:50:28 <Pseudonym> On that note, lunch time.
19:50:41 <dons> gzl, if so, that's a known bug on the mac. you need to compile Setup.hs: ghc --make -o setup Setup.hs
19:50:42 <gzl> dons: yes
19:50:53 <gzl> I see
19:51:02 <gzl> do you mean Build.hs?
19:51:07 <gzl> there is no Setup
19:51:18 <dons> oh. sorry. runhaskell in general is broken. umm. let me see.
19:51:34 <dons> $ ghc --make -o build Build.hs
19:51:37 <dons> ./build
19:51:49 <gzl> running
19:51:59 <dons> I'll switch the makefile over, as relying on runhaskell is a bit fancy
19:52:07 <gzl> ok
19:52:17 <lispy_> dons: yeah, mr. fancy pants ;)
19:52:38 <dons> in fact, I think i'll dump the mapM build and *just use cabal*
19:52:49 <Revision17> is there a word/phrase that means "higher order function", but doesn't sound so snobbish?
19:52:57 <gzl> near the end:
19:52:59 <gzl> Chasing modules from: map.hs
19:52:59 <gzl> Could not find module `System.Eval':
19:52:59 <gzl>   use -v to see a list of the files searched for
19:52:59 <gzl>   (imported from map.hs)
19:53:04 <gzl> after drop.hs
19:53:07 <dons> gzl, you need to install hs-plugins
19:53:10 <dons> check the README
19:53:11 <gzl> I already did
19:53:17 <dons> did you: make register
19:53:17 <Revision17> oops wrong channel
19:53:21 <gzl> hmm
19:53:31 <gzl> I installed it via dports, I assumed it did that automatically
19:53:45 <dons> ah, maybe it is hs-plugins 0.9.8, not 0.9.10 ?
19:53:54 <gzl> checking
19:54:01 <monochrom> higher-order function does not sound snobbish
19:54:10 <gzl> 20050407
19:54:22 <dons> gzl, darcs get the latest version
19:54:28 <Revision17> monochrom:  my functions are higher-order; they're better than your lower order ones
19:54:28 <gzl> ok, I'll do that
19:54:31 <dons> or just install 0.9.10 by hand
19:54:47 <dons> Revsion17: "fancy functions" ?  ;)
19:54:52 <Revision17> ;)
19:54:56 <gzl> if I darcs get it, doesn't that imply installing by hand?
19:55:00 <dons> yep
19:55:15 <dons> hmm. or you could hack Build.hs
19:55:26 <dave_m> Revision17: There's always "functions which take other functions as arguments"
19:56:08 <dons> gzl, sed 's/System\.Eval/Eval/' Build.hs > Build1.hs ; mv Build1.hs Build.hs
19:56:09 <Revision17> dave_m:  true; I was looking for a cute word, like currying for this.  Guess one doesn't exist :(
19:56:16 <monochrom> Not snobbish if you don't say rude things like that.
19:56:20 <dons> gzl, might save you having to install 0.9.10
19:56:49 <gzl> ok, trying that
19:56:56 <monochrom> For the record we all say "high-level languages" all the time.  All of us.
19:58:21 <monochrom> And the gist of the snobbishness is in the word "better".
19:58:43 <monochrom> If you delete "better" from the English language, there will be no snobbishness expressible.
19:58:43 <dave_m> Revision17: Well, currying is named for Haskell Curry, so we could find out who developed higher-order functions
19:59:03 <gzl> dons: cool, that makes map.hs work
19:59:42 <Revision17> monochrom:  yea, but almost everyone uses high-level langauges.  I was just thinking about it because of a snide comment a VB6 person made to me when I was telling them about higher order functions
20:00:40 <gzl> dons: so I should also ghc --make -o install Install.hs; ./install ?
20:00:41 <monochrom> Did he/she say something uncalled for?  Putting words into your mouth?  You can't expect everyone to be rational.
20:01:48 <dons> gzl, yep
20:02:03 * gzl scratches head
20:02:04 <Revision17> yea, it wasn't really a rational person; everytime someone suggests they learn another language, rather than start to explore, they always make nasty comments about what they've been told and how vb6 is better
20:02:05 <gzl> install: Prelude.head: empty list
20:02:23 <gzl> that happens when I run ./install. am I missing something?
20:02:34 <dons> hmm. you need to set  PREFIX
20:02:37 <Revision17> me calling them "higher order functions" just set that off sooner rather than later
20:02:44 <gzl> I thought I did
20:02:46 <gzl> weird
20:02:47 <dons> ./install $PREFIX
20:02:47 <gzl> let me do it again
20:03:03 <dons> since you're doing it by hand, the Makefile isn't going to thread the var for you anymore
20:03:09 <gzl> ah, right
20:03:13 <gzl> ok, that works
20:03:13 <gzl> cool
20:03:21 <gzl> thanks
20:03:56 <dons> cool. /me teaches perl now
20:04:53 <monochrom> We have 1st-order, 2nd-order, 3rd-order, ... for nth-order, n>1, we grossly call it higher-order, that's it.  higher-order logic, higher-order differential equations, ...  the term is standard and free of value judgement.
20:05:34 <monochrom> higher != better, this is obvious, e.g., higher cost.
20:05:56 <SamB> monochrom: probably because most things that support orders higher than one support all of them?
20:06:31 <monochrom> My policy is I avoid irrational, over-defensive, knee-jerk people.  I hope you can do the same.
20:07:10 <lispy_> LambdaCom: Obviously you don't know the difference between isomorphism and homomorphism.
20:07:36 <Revision17> that explaination has changed my perspective on things :)
20:07:38 <dave_m> higher-order functions/kinds/polymorphism can be a source of great power, but along with that power comes great responsibility
20:07:41 <Revision17> monochrom:  he's my boss :\
20:07:51 <Cale> monochrom: but something can be said for tricking these people into being less over-defensive and less knee-jerk
20:08:18 <dave_m> Revision17: In that case, call them "proactive functions" or something
20:08:29 <lispy_> power corrupts and absolute power corrupts absolutely.
20:08:32 <Revision17> :D
20:08:55 <lispy_> or "functions of functions"
20:09:05 <lispy_> some people find that easier to understand
20:09:10 <lispy_> "some"
20:09:14 <Cale> hehe
20:09:20 <lispy_> it's hard to know your audience
20:09:21 <dave_m> how about 'funkyfunctions"
20:09:25 <Cale> metafunctions
20:10:21 <lispy_> has anyone ever implemented a lambda calculator in hardware instead of the normal processor approach?
20:10:29 <Revision17> lispy:  I think I'll use functions of functions; however funkyfunctions have a certain appeal :)
20:10:39 <Revision17> s/have/has
20:11:00 <lispy_> Revision17: both ways make sense :)
20:11:05 <lispy_> have and has :)
20:11:28 <gzl> dons: some of your docs are out of date, they refer to things like "map f" rather than "map -e f"
20:11:28 <Revision17> I think has sounds better though
20:11:43 <lispy_> gzl: map f is the new way
20:11:51 <lispy_> gzl: map -e f was the old way
20:11:54 <gzl> what? but I just got this source
20:11:58 <Revision17> if you say it aloud; Not that it matter on IRC
20:11:59 <gzl> did he change it today?
20:12:13 <gzl> dons: never mind, I guess
20:12:18 <lispy_> gzl: he changed it last night
20:12:26 <dave_m> With "has" you're referring to the word; with "have" you're referring to the functions
20:12:28 <gzl> strange, I thought i checked this out today
20:12:52 <lispy_> dave_m: yeah, that's why i thought it made sense both ways
20:13:17 <lispy_> high order functions have appeal, but so does the term funkyfunctions
20:13:19 * Revision17 regrets having written that regex replacement
20:13:22 * lispy_ leaves for the store
20:13:28 <lispy_> Revision17: heehe
20:14:03 <lispy_> what is that line from the wedding singer?
20:14:12 <lispy_> "My mother died when I was 12 do yo want to talk about that too?"
20:16:31 <gzl> well, map f is much better anyway
20:16:34 <gzl> :)
20:30:20 <TheHunter> dons, just assuming you want to make some of your expressions as short as possible: ap 'unlines.zipWith((.(" "++)).shows)[1..].lines
21:45:04 <Lemmih> Good morning, #haskell.
21:45:58 <Lemmih> paolo: Yes.
21:49:07 <lispy_> morning
21:50:02 <lispy_> Lemmih: if i put my nehe conversions into a darcs repo and give you a link would that be okay?  I find that i keep going back and changing the ones i've already done as a learn new tricks
21:50:14 <lispy_> (this is contrasted to just sending you a copy of them)
21:50:41 <Lemmih> Sounds good.
21:50:51 <lispy_> how did you do the fonts one?
21:50:57 <lispy_> iirc that's #12
21:51:11 <lispy_> i'm guessing you use SDL?
21:51:21 <Lemmih> Nope. Only did up to 7 or 8, I think.
21:51:28 <lispy_> ah,okay
21:51:33 <lispy_> i've done 1-11
21:51:38 <Lemmih> Cool (:
21:51:44 <lispy_> i have to change 11 quite a bit
21:51:49 <lispy_> in the C code they update an array
21:52:04 <lispy_> but that was way to slow in haskell, so i made it rotate the indexing
22:04:40 <klztt> *
22:05:34 <klztt> -----------------------------*+/
22:05:58 <Lemmih> klztt: eh?
22:06:04 <klztt> --*
22:06:21 <klztt> +++++++++++++++++++++++++++++++++++++++/+
22:06:50 <klztt> sorry bout that m8s
22:16:49 <joelk> lispy, I'd like to see that darcs repository too, when you have it set up.
22:29:31 <dons> gzl, map -e is the old way.
22:29:44 <dons> darcs get if your version of h4sh doesn't do that.
22:30:45 <dons> TheHunter, cheers
22:44:40 <lispy_> joelk: okay
22:44:49 <lispy_> joelk: what is the best way to reach you?
22:44:54 <lispy_> i was going to email Lemmih
23:05:27 <vikasg> I think I finally understood monads
23:05:39 <vikasg> monad = taking control of function application
23:07:08 <vikasg> normally, we can think of application being done with the identity monad
23:07:20 <lispy> vikasg: yeah, they let you do "stuff" behind the scenes during function application.  Also, they can serve as containers
23:07:31 <vikasg> but we can define our own monad and thread a piece of data through all the applications
23:07:56 <vikasg> Wadler's "Essence of FP" is mind-blowing
23:10:09 <lispy> vikasg: have you seen the writer monad?
23:10:20 <lispy> that's a great example of what yo ucan do behind the scenes
23:10:31 <vikasg> no, I haven't
23:11:16 <vikasg> I'll take a look
23:12:15 <lispy> vikasg: http://www.nomaware.com/monads/html/writermonad.html
23:12:29 <lispy> vikasg: that's a great site to flush out your monad understanding
23:12:42 <lispy> good reference with decent examples
23:13:00 <vikasg> lispy, yes, I've tried to read that before
23:13:11 <vikasg> I think it'll all make sense now
23:20:05 <vikasg> it does indeed
23:34:58 <lispy> is @index broken?
23:35:05 <lispy> @index ReadMode
23:35:06 <lambdabot> System.IO
23:35:31 <lispy> import System.IO (ReadMode) complains that ReadMode is not exported
23:35:39 <lispy> but i've used it in code before
23:36:23 <lispy> @libsrc System.IO
23:36:24 <lambdabot> http://darcs.complete.org/fptools/libraries/base/System/IO.hs
23:38:27 <lispy> @libsrc Graphics.Rendering.OpenGL
23:38:29 <lambdabot> http://darcs.complete.org/fptools/libraries/OpenGL/Graphics/Rendering/OpenGL.hs
23:40:01 <lispy> oh
23:40:02 <lispy> i see
23:52:33 <lispy> how do i import RelativeSeek?  it's part of the alg. data type SeekMode whichis in System.IO
23:52:49 <lispy> I tried import System.IO (SeekMode) but i'm still getting errors
23:56:09 <lispy> ah, i needed SeekMode( RelativeSeek)
