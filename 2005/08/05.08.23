00:02:48 * boegel waves at Itkovian
00:05:14 * Itkovian waves back
00:25:30 <Itkovian> omg: http://www.thedailywtf.com/forums/41408/ShowPost.aspx
00:27:38 * boegel was just reading about that too, and is stunned
00:28:46 <vikasg> type EnvM a = Env -> (Env, a)
00:28:57 <vikasg> instance Monad (EnvM a) where ...
00:29:19 <vikasg> error: Expecting kind '* -> *' but EnvM a has kind '*'
00:29:30 <vikasg> what's wrong?
00:29:52 <dblhelix> instance Monad EnvM where ... is what you want
00:30:06 <dblhelix> a monad has kind * -> *
00:30:31 <dblhelix> EnvM has kind * -> *, EnvM a has kind *: there you go
00:30:48 <vikasg> but if do that I get 'type synonym EnvM should have 1 argument, but given 0'
00:31:12 <dblhelix> yep, type synonyms can only appear fully applied
00:31:29 <dblhelix> try newtype EnvM a = EnvM (Env -> (Env, a))
00:31:40 <dblhelix> and then instance Monad EnvM where ... etc.
00:31:42 <vikasg> ok
00:39:53 * boegel yawns
00:40:45 <Itkovian> then get to work, you lazy bum
00:42:00 <boegel> shut up you ****
00:44:09 <boegel> I am working
00:47:42 <vikasg> is there something like "kind theory" as well?
00:51:08 <dblhelix> vikasg: well, I guess it's just type theory, but lifted one level up
00:51:31 <dblhelix> vikasg: you see, kinds are to types, what types are to values
00:51:50 <dblhelix> vikasg: superkinds are to kinds what kinds are to types what ... etc.
00:52:28 <dblhelix> vikasg: however, in haskell the kind language is much simpler than the type language
00:52:39 <vikasg> because there are only two kinds?
00:52:59 <dblhelix> vikasg: well, there are infinitely many kinds
00:53:12 <dblhelix> vikasg: but there are only two kind constructors
00:53:18 <vikasg> ah
00:54:05 <dblhelix> vikasg: the superkind language is even simpler (one can argue that there is not even a superkind language in haskell): it has only one superkind constructor and there is only one superkind
00:54:36 <vikasg> so, a type constructor that is fully applied gives the kind '*'
00:54:42 <dblhelix> vikasg: consequently, all kinds that are formed with the two kind constructors (* and (->)) are well formed
00:54:53 <dblhelix> vikasg: yes, you're right
00:54:58 <Lor> (And, in ghc, #)
00:55:32 <dons> superkinds? ren't they usually known as `sorts'?
00:55:33 <dblhelix> Lor: well, let's not get into dirtiness :)... besides, # is a kind constructor in ghc
00:55:53 <dblhelix> dons: I've seen both terms used
00:56:03 <vikasg> Lor, what is '#'?
00:56:12 <Lor> No, terms, types and kinds are all sorts.
00:56:20 <dons> ah, ok. at least in the theorem prover stuff i've done they're always referred to as `sorts'
00:56:25 <Lor> A "sort" is a generic name for a level in the kind hierarchy.
00:56:42 <dblhelix> dons: iirc, I've even seen people use the term sorts for the set of values, types, kinds, superkinds, supersuperkinds, ....
00:56:44 <Lor> So, superkinds would be yet another sort.
00:57:06 <Lor> vikasg, it's the kind of unboxed types.
00:57:07 <dblhelix> Lor, dons: indeed, that's the interpretation of the term I was referring two
00:57:14 <dblhelix> /s/two/to
00:57:50 <dblhelix> Lor, dons: but dons was right as well, that some use the 'sort' as a synonym for what I just called 'superkind'
00:58:09 <dons> also, sometimes you see `families', though this may be twelf-specific
00:58:56 <dblhelix> furthermore, I believe I've seen a box symbol used for the superkind constructor
00:59:29 <dons> in twelf, the sort/superkinds use: O (a bit like a box ;)
01:00:12 <dblhelix> dons: yes, but instead of four, it has an infinite number of corners :)
01:10:46 <boegel> hey arjanb , goron
01:16:12 <boegel> hi iblechbot ^_^
01:25:40 * boegel signs
01:39:38 <boegel> hey Oeje1
01:42:26 <Oeje1> Hej, boegel.
01:42:50 <boegel> anyone here who uses BiBTeX and is willing to help a BiBTeX-newbie ?
01:48:14 <tuomov> what's the prob?
01:49:52 <boegel> tuomov: I don't know where to start :)
01:50:01 <boegel> is there a tool for creating the needed .bib file ?
01:50:18 <boegel> I understand the whole \cite stuff and such, no prob there
01:50:21 <tuomov> emacs/jed/joe/vi/...
01:50:29 <boegel> but I don't feel like creating the .bib file by hand
01:50:40 <tuomov> I don't know any tools, but it's quite easy
01:50:43 <tuomov> for example,
01:50:44 <erommer> does anyone know how i can install ghc on cygwin (win xp)
01:50:51 <tuomov> @article{cite-with-this,
01:50:53 <lambdabot> Unknown command, try @listcommands.
01:50:53 <dblhelix> boegel: I maintain my .bib files by hand: it's not that bad, actuallly
01:50:58 <tuomov>     title = "Foo"
01:50:59 <pejo> boegel, http://liinwww.ira.uka.de/bibliography/index.html
01:51:02 <tuomov>    author = "Bar"
01:51:03 <tuomov> }
01:51:04 <tuomov> and so on
01:51:06 <dblhelix> boegel: but there are some tools, indeed
01:51:44 <boegel> normally you can get the BibTeX entry when you find the article, right ?
01:51:50 <nibro_> @seen Lemmih
01:51:51 <lambdabot> Lemmih is in #haskell. Last spoke 10 hours, 7 minutes and 8 seconds
01:51:51 <lambdabot> ago.
01:51:53 <tuomov> then you need e.g. \bibliographystyle{plain} \bibliography{my_file_without_extension} in the .tex
01:51:58 <pejo> boegel, citeulike can export bibtex files if you want it to. And there's a chance that someone has put together a huge .bib for a certain area of yours. The link I gave you usually list where the bib comes from.
01:52:00 <Lemmih> Hey nibro_ (:
01:52:10 <nibro_> ah, hello there :)
01:52:11 <tuomov> there are various bibliographystyles, and there's a tool for generating custom files, iirc custom-bib
01:52:38 <boegel> pejo: cool, thanks
01:52:44 <nibro_> Lemmih: I'm looking through your version of hsp, lots of changes in there
01:52:54 <nibro_> Lemmih, care to give me a rundown?
01:53:02 <vikasg> boegel, citeseer too has BibTeX entries
01:53:19 <tuomov> anyway, the hardest part of writing bibtex entries is looking up all the information once you get used to it
01:53:37 <nibro_> btw, anyone know how I can get rid of my evil twin?
01:53:49 <pejo> vikasg, I normally find those broken/incomplete. Is it just bad luck?
01:54:21 <pejo> nibro, can't you just kill the client, if thats what you want?
01:54:53 <vikasg> pejo, never used it; I've seen them, that's all
01:55:00 <nibro_> pejo, the client has been dead for the past 5 weeks afaik :)
01:55:14 <arjanb> nibro_ if you registered your nickname you can do /msg NickServ ghost nibro password
01:55:19 <tuomov> have you registered your nick?
01:55:25 <nibro_>  /msg NickServ ghost nibro annelill
01:55:28 <tuomov> iirc nickserv has some features for this
01:55:32 <boegel> vikasg: I know, but it's quite hard to collect all of the articles you want...
01:55:42 <nibro_> doh, stupid spaces...
01:55:47 <erommer> does anyone know how i can install ghc on cygwin (win xp)
01:55:52 <boegel> nibro: I know your password ! :p
01:55:55 <nibro_> eh, he joined again??
01:56:15 <nibro_> boegel, not for long :p
01:56:25 <Lemmih> nibro_: YGM.
01:56:38 <pejo> nibro, what do you mean dead? It's obviously alive. ;)
01:56:46 <boegel> heh ! :)
01:56:47 <tuomov> heh
01:56:53 <boegel> this is funny
01:56:53 <nibro> gah
01:57:05 <nibro> I have no idea where that client lives then
01:57:24 <tuomov> irssi can sometimes go in a state when it is connected twice
01:57:56 <nibro> I'm using a thin client, the xchat client was alive when I went on vacation 5 weeks ago, and my session was dead when I got back
01:57:57 <tuomov> if that's what you're using
01:58:22 <nibro> so I'm guessing that the xchat session is alive somewhere on the mainframe, just that I can't access it
01:58:55 <tuomov> ps doesn't list it?
01:59:25 <vikasg> the state monad is beautiful
01:59:26 <nibro> ls
01:59:42 <nibro> tuomov, nope, not on ps
01:59:54 <tuomov> plain, or e.g. ps -U yourusername?
02:00:12 <boegel> ps -a ?
02:00:27 <tuomov> -a lists a lot of stuff on a server..
02:00:33 <tuomov> -U might suffice
02:00:53 <nibro> aha :)
02:00:57 <boegel> aha ! :)
02:01:15 <nibro> -U did the trick, thanks a lot :)
02:01:35 <tuomov> plain ps only lists the processes in your current session or something like that
02:01:49 * boegel thinks nibro should throw a party to celebrate
02:02:01 <tuomov> invite your evil twin :)
02:04:11 <boegel> well, I'm not sure if he'll want to join...
02:05:35 <boegel> oh, there he is ! :)
02:07:45 <nibro> don't dare throw a party, what if my evil twin decides to show up? >:-[
02:09:05 <boegel> oh, there he goes !
02:16:51 <shapr> whee
02:18:11 <boegel> yo shapr
02:24:59 <Muad_Dibber> goed morning
02:25:30 <Itkovian> mm
02:26:49 <nibro> Lemmih, YGM back :)
02:26:56 <boegel> Muad_Dibber: hi
02:29:34 <boegel> any people here who collect stuff ?
02:29:49 * Oeje1 collects boegels.
02:30:36 <boegel> Oeje1: how many do you have ? :)
02:31:04 <Oeje1> Three so far; they are very rare.
02:31:20 <boegel> three ? can I see them ?
02:31:53 <Oeje1> No!
02:32:26 <Muad_Dibber> stuff like what boegel?
02:32:55 * Oeje1 collects books.
02:34:25 <boegel> Muad_Dibber: anything
02:34:33 <Muad_Dibber> like coins? :P
02:34:43 <boegel> stuff like this: http://elis.ugent.be/~kehoste/collection
02:34:51 <boegel> Muad_Dibber: yeah sure, why not
02:34:56 <boegel> stamps, women, whatever
02:35:01 * nibro tries to collect his salary every month...
02:35:13 <boegel> nibro: yeah, sure, money, why not
02:35:40 <boegel> does anybody know how to do vector graphics with gimp ?
02:35:53 <Muad_Dibber> so i do collect coins and backnotes :P
02:36:03 <Itkovian> boegel: you can't afaik
02:36:10 <Oeje1> boegel: Haha, that's cute.  The girls must love it. ;-)
02:36:51 <Itkovian> boegel: try sodipodi
02:36:58 <Muad_Dibber> if there was a nice wxHaskell XML editor, maybe you can create a collection administration application in haskell :P
02:37:19 <Itkovian> Muad_Dibber: mysql does the trick just fine :-)
02:37:41 <Muad_Dibber> Itkovian: I had more in my mind to make an application that is usefull for normal people
02:37:46 <Itkovian> lol
02:38:13 <boegel> Oeje1: I don't collect it for the girls, I collect it for myself ! :)
02:38:16 <boegel> I love those movies
02:38:25 <Oeje1> Closed source software sucks.
02:38:28 <Muad_Dibber> I have a pc entirely devoted to mysql and samba, so for me it's not a problem :P
02:38:36 <Itkovian> Muad_Dibber: well, you could describe the collection in a CollectionConfig.hs file, load it, a la HSP ... and some such
02:38:41 <Oeje1> boegel: Yeah, but the girls like it, right?
02:39:12 <Muad_Dibber> Oeje1: depending on their age...
02:39:16 <boegel> Oeje1: there's only 1 girl in my life, that's enough
02:39:48 <boegel> Oeje1: but she likes it yes, she helps me with collecting
02:40:08 <boegel> of any of you guys have stuff lying around, don't hesitate to send it over ! :)
02:40:08 <Itkovian> she does the shopping part?
02:40:19 <Muad_Dibber> my girl doesnt like me collecting the coins and such, thinks its a waste of money :(
02:40:38 * Itkovian collects the books he read
02:40:47 <boegel> Itkovian: no, she helps wathcing out for stuff on *err, how do you call those things where people sell all of the stuff they don't need anymore
02:40:50 <boegel> yard sales?
02:41:03 * Itkovian would love to collect comics, but that might get very expensive
02:41:12 <boegel> Itkovian: marvel stuff ?
02:41:15 <Itkovian> street sales
02:41:32 <musasabi> my gf collects rocks.
02:41:32 <Itkovian> boegel: more like XIII and some such, the more mature stuff
02:41:37 <Oeje1> boegel: I bet you're really obsessive with the items, like when a girl says "oh, boegel, that animal is sooo cute", you say in a harsh voice, "no, give it back. Now!".  :-P
02:41:45 <sieni> what is this "girl" thing you people talk about so much? anyone actually observed one?
02:41:45 <Itkovian> musasabi: nice. soon you can build yr own cave ;-)
02:41:55 <boegel> Itkovian: sodipodi is a whole new program, I'm looking for a the gimp plugin or something
02:41:59 <Itkovian> sieni: it's a strange species
02:42:12 <Itkovian> but required nonetheless
02:42:14 <musasabi> (she studies geology, mining and such things ;)
02:42:24 <boegel> Oeje1: nah, I'm not that bad actually
02:42:50 <Itkovian> they used to have affinity for dishes, but current specimen are less inclined toward that
02:42:58 <boegel> Oeje1: I'm not that kinda freak who would go out of his mind because somebody takes a toy out of the package (like the guy in Toy Story)
02:43:18 <Itkovian> boegel: all life's answer are on tv, eh
02:43:29 <boegel> Itkovian: nah :)
02:43:41 <boegel> Itkovian: I bet Veerle wouldn't like to hear that :D
02:43:54 <Itkovian> what? the dish part?
02:44:23 <Itkovian> I'm usually doing them - she's not really a housy type
02:46:13 <sieni> In Finland we have this thing called dishwasher
02:47:00 <Muad_Dibber> so do we have in holland
02:47:06 <Muad_Dibber> but beware of the belgians....
02:47:20 <boegel> Itkovian: strange species, current specimen...
02:47:33 * boegel balls his fists
02:47:40 <boegel> Muad_Dibber: what about the belgians ?
02:48:03 <Muad_Dibber> for one they ussually immediatly ball their fists if they do not like something
02:48:20 <Itkovian> we will have one in our new kitchen ... but there's a few years delay on the delivery ;-) (my inlaws produce them ... hence ...)
02:48:27 <Lor> More importantly, in Finland we have this thing called the drying rack.
02:48:51 <Itkovian> Lor: we have that too, but one still needs to have a towel drying session too
02:49:12 * boegel unballs his fists and pets Muad_Dibber 
02:49:22 <earthy> actually, even stuff coming out of the dishwasher needs towel drying
02:49:32 <earthy> not much, but a little nonetheless
02:49:38 <shapr> In the USA we just buy new dishes.
02:49:38 <Itkovian> earthy: you need to place the glasses upside down!
02:49:40 <Lor> Only if you are picky about cosmetics. :)
02:49:56 <sieni> earthy: crappy dishwasher?
02:50:00 <earthy> itkovian: yes, and then there's dimples on the bottom of the mugs that still collect a teensy bit of water
02:50:00 <Muad_Dibber> earthy: depending on the thing you put in, and how long you wait before taking it out after its finished ;)
02:50:11 <Itkovian> earthy: i know ...
02:50:31 <Lemmih> nibro: YGM.
02:50:44 <Muad_Dibber> so put the mugs slanting
02:50:47 * Itkovian advises emptying the bottom shelf of the dishwasher first
02:50:52 <earthy> muad: true, and depending on how much 'glansspoelmiddel' you put in. (dang, I really really don't know that word in languages other than dutch)
02:50:56 <Itkovian> Muad_Dibber: doesn't always help
02:51:13 <Muad_Dibber> since i under stand dutch perfectly well thats no problem earthy ;)
02:51:15 <earthy> itkovian: that's the order i use, indeed.
02:51:17 <Itkovian> so, how does this relate to Haskell?
02:51:23 <Muad_Dibber> well
02:51:30 <Muad_Dibber> a dishwasher is a very functional thing
02:51:35 <Itkovian> true
02:51:44 <earthy> it allows you to spend more time playing with code
02:51:50 <Itkovian> true as well
02:51:52 <boegel> earthy: ;:D
02:52:15 <earthy> heck, my gf tended to not do the dishes, even though we agreed that I'd cook and she'd do the dishes
02:52:32 <earthy> which meant that I'd cook and do the dishes, as food is somewhat important
02:52:56 <earthy> so the dishwasher freed up some good time
02:53:39 <Muad_Dibber> so you not wearing the pants at home eh earthy
02:53:52 <earthy> actually, I am. I get to decide what's for dinner...
02:54:07 <earthy> power, there.
02:54:23 <earthy> b'sides, the gf travels ~1h one way to get to work
02:54:27 <earthy> I travel about 10 minutes
02:54:55 <Muad_Dibber> hehe
02:55:05 <Muad_Dibber> i travel about 1h30 to get to UU
02:55:16 * boegel travels 45m
02:55:21 <earthy> slight diff. :)
02:55:29 <Muad_Dibber> so i let mom do the cooking and let dad put the stuf into dishwasher ;)
02:55:33 <boegel> no, an hour actually, when you count from home to uni
02:55:37 <Itkovian> well we still walk for 15-20 mins boegel
02:55:44 <earthy> and yeah, I did that before we moved as well. but I got to do the cooking and washing myself...
02:55:51 <boegel> Itkovian: yeah, I always forget about that part
02:56:09 <Itkovian> earthy: same here ... mostly
02:56:23 * Itkovian eats
02:56:26 <Itkovian> at last
02:57:01 <Muad_Dibber> only think i can cook is some fries , microwave pizza, and some fish
02:58:34 <Itkovian> the whole office smells like salami
02:59:05 <earthy> hm. salami!
02:59:09 * boegel smells salami aroma coming through the door
03:00:42 * Beelsebob comes through the door with a salami
03:01:15 * earthy thinks about arrow representations of recipes...
03:01:18 <earthy> hmmm...
03:04:08 <earthy> haskell, arrows and http://www.anthus.com/Recipes/CompCook.html could conceivably lead to a nice recipe dsl...
03:05:36 <Itkovian> hehe maria sharapove is nr 1 ...
03:05:48 <Itkovian> at last a pretty chick
03:06:38 <earthy> *baaad* mental image
03:17:07 <wilx> lispy`, are you using/hacking the Q3A code somehow?
03:17:54 <FrederikEaton> http://ofb.net/~frederik/washng/
03:18:37 <dcoutts> FrederikEaton, I sent you more bumpf about the cabal & package.conf issue
03:22:36 <FrederikEaton> yeah i saw that
03:23:07 <FrederikEaton> you need to stick to your guns man
03:24:22 <dcoutts> heh
03:24:51 <dcoutts> I think the more comprimising approach works ok :-)
03:25:13 <dcoutts> FrederikEaton, do you think such a solution would work for you?
03:25:17 <FrederikEaton> 10 years from now your kids will be like, "today we learned in school about this great tool called autoconf that let you install things in arbitrary locations. how come cabal can't do that?" and you'll be like, well kids, it's because i'm not assertive enough.
03:26:08 <FrederikEaton> dcoutts: what about the part where you have to specify package databases during build?
03:26:18 <FrederikEaton> do you do this via the environment?
03:26:25 <dcoutts> well you can install stuff with an arbitrary prefix, but every system still needs some way of getting registered, getting on ther path or whatever
03:26:43 <dcoutts> FrederikEaton, oh, well we're only using a global package database
03:27:01 <tuomov> there should be a user db too
03:27:27 <dcoutts> tuomov, there is, but it's not managed by gentoo :-)
03:27:34 <FrederikEaton> dcoutts: huh? i thought we were talking about using package dbs in arbitrary locations
03:27:42 <dcoutts> FrederikEaton, it's just that we need to do the package registration ourselves
03:28:00 <FrederikEaton> for install/uninstall?
03:28:05 <dcoutts> FrederikEaton, and we need to retain copies of the package file so we can re-register and do other funky things
03:28:13 <FrederikEaton> right
03:28:24 <dcoutts> but we don't need the arbitrary prefix thing like you do
03:29:14 <FrederikEaton> i would prefer not to do your hack. i think cabal should give a full interface to everything ghc can do with packages
03:29:31 <FrederikEaton> and that it should support environment variables as well
03:29:35 <dcoutts> I'm not so sure
03:29:50 <dcoutts> you can support env vars youself quite easily with a wrapper script
03:29:57 <FrederikEaton> perhaps. but i've given good arguments for these things which have not been responded to
03:30:19 <FrederikEaton> anyway, about the full interface part
03:30:26 <dcoutts> yep?
03:30:30 <FrederikEaton> i see absolutely no reason why not to do it
03:30:41 <FrederikEaton> isaac has not explained his reason
03:30:48 <dcoutts> it doesn't fit the cabal interface, it is a back door
03:31:06 <dcoutts> so unless it's really necessary (and I think it is) then it should be avoided
03:31:10 <FrederikEaton> well, yeah, he says "compiler abstraction" but
03:31:48 <musasabi> FrederikEaton: if Cabal provides full interface to GHC how should it work with other Haskell compilers?
03:31:57 <FrederikEaton> ... you don't need to switch between compilers if only one supports your feature
03:32:03 <musasabi> That may not even have package database files like GHC does.
03:32:13 <nibro> Lemmih, bombs away.
03:32:20 * nibro goes for lunch
03:32:24 <dcoutts> I sort of agree, as the package manager, we're already underneath the cabal abstraction and so I find that cabal currently doesn't give us enough information because it's trying to keep us on the clean side of the abstraction
03:33:28 <FrederikEaton> if you need a feature, and so you're stuck with ghc anyway, so it's either ghc without cabal, or ghc with cabal, then ghc with cabal is the lesser of 2 evils, right? leaving out the feature just to make an even playing field for the other compilers is silly
03:34:09 <FrederikEaton> so...
03:34:24 <Igloo> What do you mean by arbitrary prefix?
03:34:38 <FrederikEaton> Igloo: who me?
03:34:41 <Igloo> Yes
03:34:56 <musasabi> FrederikEaton: What about the third solution - finding a compiler neutral abstraction to do what you need.
03:35:01 <FrederikEaton> autoconf lets you install things anywhere
03:35:01 <dcoutts> Igloo, FrederikEaton wants to install into an arbitrary prefix *including* ghc's package.conf database
03:35:47 <Igloo> But ghc-pkg knows where package.conf is, surely?
03:35:49 <FrederikEaton> musasabi: what do you mean? besides, it's not necessary. my argument holds water.
03:35:51 <musasabi> FrederikEaton: would a --with-ghc-package-conf=filepath solve your problems ?
03:36:01 <dcoutts> FrederikEaton, then your system has some way of specifying all the package.conf files whenever you build anything?
03:36:09 <Igloo> Why isn't cabal's --prefix good enough?
03:36:10 <FrederikEaton> musasabi: yes
03:36:27 <dcoutts> Igloo, because it still uses a global ghc package.conf db
03:36:29 <FrederikEaton> dcoutts: i'd like to do that with env vars, but arguments would work too
03:36:32 <Igloo> Or do you mean you want a different package.conf for each package?
03:36:50 <FrederikEaton> no
03:36:58 <FrederikEaton> it's many->many
03:37:02 <dcoutts> Oh, then I misunderstood
03:37:33 <FrederikEaton> isaac's "--in-place" proposal was a different package.conf for each package
03:37:56 <Igloo> What is this for, OOI?
03:37:57 <FrederikEaton> i want to be able to group a bunch of packages into various package.conf's
03:38:03 <FrederikEaton> modularity
03:38:06 <dcoutts> and it was also for registering in a build tree, not an install location
03:38:09 <Igloo> What system?
03:38:34 <FrederikEaton> Igloo: you can read the thread, or read about wigwam:  http://www.wigwam-framework.org/doc/overview.html to get an idea of an application
03:38:51 <FrederikEaton> but in general modularity and virtualization are good things which should be sought at all levels
03:39:11 <shapr> Though simplicity means it's more likely people will actually use your code.
03:39:30 <FrederikEaton> general is often more simple
03:39:38 * Lemmih goes to the post office.
03:39:46 <FrederikEaton> but that's cliche
03:40:37 <shapr> hiya poetix
03:40:42 <poetix> hi shapr
03:41:07 <poetix> I still boggle at the shortness of the interval between my logging in and you saying that
03:41:23 <Itkovian> it's automated
03:41:32 <poetix> This is what I have always suspected
03:41:48 <Itkovian> that or he has a shortcut form his eyes to his hands
03:42:01 * FrederikEaton goes horizontal
03:42:07 <Itkovian> erm ...
03:42:12 * kosmikus has just read up on the "cabal design" discussion
03:42:28 <dcoutts> kosmikus, confused yet then?
03:42:33 <FrederikEaton> to sleep
03:42:37 <Itkovian> ah.
03:42:46 <shapr> it isn't!
03:42:50 <kosmikus> dcoutts: not yet
03:42:53 <poetix> Not horizontal jogging, then.
03:42:55 <shapr> That is, it's not automated.
03:43:07 <Itkovian> then your brain gets shortcicuited
03:43:13 <Itkovian> erm shortcircuited
03:43:15 <shapr> That sounds more likely.
03:43:24 <FrederikEaton> oh, but people should look at my wash fork and tell me if i'm a good forker: http://ofb.net/~frederik/washng/
03:45:32 <poetix> That's forking great.
03:46:12 <Beelsebob> you need SPOOOOOOONGUARD!
03:46:18 <FrederikEaton> should i fork harder?
03:46:34 <poetix> Harder *and* faster.
03:46:59 <kosmikus> dcoutts, FrederikEaton: isn't all what's needed that ghc itself gets a flag to configure the location of the global package configuration file?
03:47:08 <kosmikus> nothing to do with Cabal
03:47:24 <musasabi> FrederikEaton: you might want to look at Lemmih's HSP fork code too.
03:47:32 <kosmikus> when building a package, we could say "--with-ghc='/usr/bin/ghc --global-conf here'"
03:47:39 <dcoutts> kosmikus, true, but how do you specify that when doing ./setup configure
03:47:46 <poetix> http://www.eecs.harvard.edu/~mdw/proj/seda/ <- interested in this at the moment, as it's an interesting design
03:47:47 <dcoutts> ok, I see, hmmm
03:47:53 * musasabi thinks the various Haskell web projects could maybe consider sharing some common components.
03:48:10 <poetix> musasabi: Sure. I really don't want to write my own HTTP parser, for example...
03:48:34 <Beelsebob> kosmikus: maybe you want that to be --with-hc=...
03:48:42 <kosmikus> Beelsebob: whatever :)
03:48:48 <Beelsebob> so that nhc or jhc can go there
03:49:15 <dcoutts> FrederikEaton, it's worth a try, see if cabal can work with that, and if not suggest it to Isaac
03:49:29 <poetix> I was suggesting LYME the other day as an acronym for an alternative FOSS web application stack
03:49:31 <dcoutts> it seems like it ought to work
03:49:40 <poetix> (alternative to LAMP, that is)
03:51:09 <FrederikEaton> kosmikus: oh yeah. well, abstraction over compilers is still an important goal. cabal should provide an interface which makes it possible to achieve in the future
03:51:36 <FrederikEaton> kosmikus: although it's embarrassing that i missed that
03:53:04 <FrederikEaton> poetix: oh, i saw a talk on SEDA at caltech. the guy was wearing a suit
03:53:07 <kosmikus> it seems to me that you're requiring something that's specific to one compiler (ghc), and I'd argue that this should then be something not provided by cabal, but by the compiler itself; all that Cabal has to provide is the facility to pass the option through, which should be possible in this context
03:54:04 <kosmikus> of course, the option has to exist; it exists for ghc-pkg, but not for ghc, I think; ghc uses the -B option to set the topdir, and I'm afraid it assumes that a lot more things reside in the topdir than just the package.conf file -- but I'm not sure
03:54:26 <dcoutts> FrederikEaton, so the --wtih-(g)hc  option for configure should get the deps and the feature to just get the package file and register manually using ghc-pkg should deal wit registering at the other end
03:56:30 <dcoutts> kosmikus, I think it's just -package-conf to use an extra package.conf file (ie in additio to the global one)
03:56:39 <FrederikEaton> what is wanted is a case statement that will turn the --prefix option into a package.conf location for ghc, or a whatever for other compilers
03:57:07 <FrederikEaton> hmm, no
03:57:18 <FrederikEaton> i guess you'd have to specify it separately
03:57:50 <dcoutts> because you're trying to register multiple packages together, not just one package each file
03:58:06 <poetix> FrederikEaton: Is suit-wearing advocacy an indicator of whackness?
03:59:01 <dcoutts> kosmikus, so no need to use ghc -B I think
03:59:12 <FrederikEaton> you still want a case over compilers though. i think cabal should try to make it partially abstract so that you can just point to the root of your "playpen" with a package database option, and it will figure out what to do
04:00:10 <FrederikEaton> otherwise 'toast' or whatever package management tool is invoking cabal will have to figure out which compiler is being used, which takes away part of the advantage of using cabal
04:00:36 <FrederikEaton> poetix: i think it's weird, especially for someone from UCB. maybe it's a java thing
04:00:52 <kosmikus> dcoutts: it's something different; the global file is always there even if you specify other -package-conf options; you might not want that
04:00:56 <FrederikEaton> poetix: he freaked me out with his java-ness
04:01:07 * FrederikEaton really goes to bed now
04:01:28 <kosmikus> FrederikEaton: the concept of having multiple completely independent package databases could probably be generalised to all compilers, even though they might not all have package.conf files
04:01:42 <dcoutts> kosmikus, true, but in this case I think that is what is wanted, replacing the whole global package file is not required (or wanted) here
04:02:02 <dcoutts> FrederikEaton, I think so far you're the only person who wants to do this stuff, so cabal doesn't really support it (and ghc only supports it by accident)
04:03:34 <dcoutts> I think this stuff would be much easier if ghc used a dir of package files and allowed ${prefix} or something in them so that the could be relocated easily (rather than having to hard-code paths)
04:04:31 <dcoutts> then all FrederikEaton would have to do is specify a path of package config dirs
04:04:50 <dcoutts> much like he does with LD_BLA_BLAH for C packages
04:06:22 <shapr> That would be nifty.
04:06:26 <kosmikus> possibly; I still think though, that the process must be to first say what the correct solution on the ghc side is, then to think about how other compilers might solve the issue, and only as a last step think about how to integrate this functionality (if then required) into cabal
04:06:37 <shapr> Yeah, I agree.
04:06:45 <dcoutts> me too
04:06:53 <shapr> hiya poetix, long time no see.
04:07:08 <poetix> Chatzilla crashed, twice in a row
04:07:19 <shapr> Yow fun.
04:07:25 <dcoutts> kosmikus, otherwise it's a great deal of work for poor Isaac!
04:08:25 * shapr finds a weird apt bug(?)
04:09:14 <poetix> Anyhow, SEDA, YAWS &co - I'm thinking about scalability-thru-distribution, the sort of thing J2EE (*shiver*) is supposed to be for
04:10:06 <poetix> Network transparency is one interesting problem...
04:18:55 <greenrd> Network transparency is bad, because you need to be able to design a system in view of performance and reliability characteristics of the network.
04:19:27 <poetix> Does network transparency prevent you from taking account of those things?
04:19:53 <poetix> I'm thinking of Erlang and Oz here, which implement network transparency as part of their design.
04:19:55 <greenrd> At the very least an RPC call must be able to throw an exception that an in-process call would not possibly throw (total network failure); hence, not transparent.
04:20:18 * Itkovian is hit by post-lunch tiredness
04:20:23 <Itkovian> and no coke
04:20:43 <greenrd> Itkovian: I think the Spanish are onto something with siestas
04:21:06 <boegel> Itkovian: try lsd or speed ;)
04:21:20 <Itkovian> no thx
04:21:25 * Itkovian doesn't do drugs
04:21:36 <greenrd> caffeine is a drug
04:21:48 * greenrd doesn't do _any_ drugs, including caffeine ;)
04:22:41 <boegel> Itkovian: you do coke ?
04:22:54 <boegel> Itkovian: alcohol is a drug too
04:23:03 <Itkovian> I rarely drink
04:23:16 <Itkovian> hmm, caffeine may also qualify. shit
04:23:28 <tuomov> define drug
04:23:37 <Itkovian> anything that gets you addicted to
04:23:41 <Itkovian> potentially
04:23:47 <Itkovian> and that messes with yr senses
04:23:47 <boegel> Itkovian: women
04:23:52 <boegel> Itkovian: women !
04:23:54 <Itkovian> erm
04:24:10 <tuomov> chocolate?
04:24:17 <dcoutts> boegel, I agree :-)
04:24:30 <greenrd> women are metaporically a drug, but they aren't a chemical substance
04:24:31 <Lemmih> Haskell?
04:24:43 <tuomov> chili?
04:24:51 <boegel> sweets ?
04:25:00 * boegel was addicted to sweets for a long time
04:25:02 <xerox> THC? :-P
04:25:35 <Beelsebob> hula hoops
04:25:37 <poetix> Oxytocin.
04:25:41 <Beelsebob> as I am currently discovering
04:25:41 <greenrd> OK, you have to exclude food from drugs, just by fiat, otherwise that would be really problematic
04:26:13 <Beelsebob> food in general, yes, but individual foods, no
04:26:21 <poetix> Nutmeg
04:26:44 <tuomov> oxygen!
04:26:48 <greenrd> heh
04:26:51 <poetix> Hot chilli stimulates production of endorphins, gets you high
04:27:01 <tuomov> yep, and it's addictive too
04:27:07 <poetix> Nutmeg in sufficient quantities will get you high all by itself
04:27:10 <Lemmih> Some people have a hard time telling soft drugs from hard drugs.
04:28:03 <poetix> Strenuous exercise also stimulates endorphin production - people get addicted to rowing
04:28:13 <greenrd> Hard drugs are the ones that are really really dangerous class A drugs, like cannabis.
04:28:24 <poetix> Or flagellation, for that matter
04:28:40 <poetix> greenrd: ???
04:28:42 <Lemmih> greenrd: heh (:
04:28:52 <greenrd> Actually cannabis has recently been downgraded in the UK, so maybe it's not so dangerous any more.
04:28:55 <xerox> poetix: dangerous in what sense?
04:29:03 <tuomov> gets you jailed?
04:29:13 <greenrd> I was being sarcastic.
04:29:32 * poetix activates sarcasm detector, sees world through green-tinted spectacles
04:29:33 <greenrd> For decades cannabis was classified as a class A drug in the UK.
04:30:05 <shapr> greenrd: But your body produces addictive drugs, what about endorphins?
04:30:47 * poetix wonders if anyone's looked at the brain chemistry of a meditating buddhist monk, or a monotheist engaging in devout prayer
04:31:01 <poetix> Not to mention the effect that fasting has on consciousness
04:31:22 <poetix> (once the initial grumpiness wears off)
04:31:22 <shapr> poetix: Yes they have, and supposedly pinpointed the part of the brain responsible for religious bliss.
04:31:30 <greenrd> shapr: Drugs are something that people consume from outside their body. Therefore endorphins don't count. Unless you can "take" endorphins directly.
04:32:11 <shapr> Rats that live on 80% of 'normal' food live about 20% longer.
04:32:21 <poetix> How about artificially stimulating production of endorphins, e.g. through a bout of flagellation?
04:32:24 <Beelsebob> greenrd: there are some steroids produced in the body
04:32:29 <Beelsebob> are they drugs or not?
04:32:42 <shapr> greenrd: What about chemicals that get your body to produce the actual goodies?
04:32:53 <greenrd> Beelsebob: Sure... when they're taken. That would the sport definition, I assume.
04:33:12 <shapr> poetix: Yes, autistic children sometimes bite their fingers to stimulate endorphins, sometimes so much that they bite their fingers off.
04:33:32 <Beelsebob> and what if you take something that just happens to increase your bodies production of said substance?
04:33:33 <poetix> Prozac doesn't create serotonin, it inhibits the brain chemistry that clears up the serotonin you've already got in your system
04:33:40 * boegel thinks water can get him high too
04:33:55 <greenrd> boegel: You want to be careful not to overdose on that.
04:33:55 <boegel> ever drunk _really_ cool water ? it get's to my head for a few seconds...
04:34:06 <poetix> shapr: ouch. But non-autistic people do this too: people who cut themselves, for instance.
04:34:06 <Beelsebob> haha
04:34:07 <shapr> Right, much like lithium is a balancing agent, but still an effective treatment for chemical depression.
04:34:23 <shapr> poetix: If they're teenagers wearing black, that's just peer pressure ;-)
04:34:28 <vikasg> boegel, drinking anything really cold hits you in the head
04:34:40 <Beelsebob> poetix: cutting is for a physical release of 'mental pain'
04:35:03 <greenrd> poetix: But does self-cutting cause a physiological or physchological reaction?
04:35:07 <shapr> both
04:35:24 <shapr> You can't really separate the parts, even though western medicine tries.
04:35:31 <poetix> "Release" is the metaphor; in addition to purely psychological effects, it also has a physical and mood-altering effect.
04:35:36 <tuomov> capsaicin releasing endorphins is also based in it creating a sense of pain
04:35:41 <tuomov> (=chili etc.)
04:36:11 <greenrd> ah, so, does this explain S&M?
04:36:23 <greenrd> Or at least the M part
04:36:39 <poetix> Not entirely, but partly
04:36:56 * poetix learned the hard way not to be reductive about S&M
04:37:10 <xerox> S&M = ?
04:37:19 <shapr> The chemical motivation behind Tetris is interesting, I think it's the same motivation behind Perl Golf and optimizing code.
04:37:21 <greenrd> xerox: sado-masochism
04:37:22 <vikasg> xerox, Sadism/Masochism
04:37:33 <poetix> shapr: Self-hypnosis.
04:38:00 <greenrd> I'm not sure that Tetris addiction can be reduced to chemicals.
04:38:03 <greenrd> Now we're just getting silly.
04:38:09 <shapr> poetix: I read it was chemical pleasure reward for learning. Self-hypnosis is an intersting thought though.
04:38:38 <shapr> greenrd: Nah, the 'click' when someone realizes something does have a chemical reward.
04:38:56 <tuomov> I just feel bad in my stomach after having played tetris for a few hours..
04:38:59 <vikasg> shapr, cycle-counting assembly optimization can be addictive
04:38:59 <shapr> heh
04:39:00 <greenrd> heh
04:39:14 <poetix> All the zen stuff about "flow" applies here: intense absorption in reading or coding has a hypnotic effect
04:39:20 <shapr> vikasg: Yup, but it's not for me... I can get permanently hooked on that sort of thing.
04:39:20 <greenrd> Yes, well, you could say that all happiness is chemical, and you'd probably right, but that misses the point.
04:39:31 <boegel> greenrd: gambling addiction can be reduced to chemicals, I'm sure Tetris addiction can be too
04:39:41 <poetix> Civilisation addiction
04:39:50 <shapr> greenrd: I don't think so, I think we live in a macrosystem, and the chemical part is just one facet.
04:39:59 <poetix> Zangband addiction - that constant cycle of exploration and reward
04:40:02 <greenrd> It's like saying "You're sad because of chemicals in your brain" to someone who's just lost his wife.
04:40:10 <greenrd> No, he's sad because he's just lost his wife.
04:40:20 <vikasg> shapr, maybe that's why people do needless optimizations
04:40:25 <shapr> Right, but if he took heroin he wouldn't be sad anymore.
04:40:28 <greenrd> hehe
04:40:35 <poetix> He's sad because he has chemicals in his brain because he's lost his wife
04:40:39 <greenrd> Yes.
04:40:42 <shapr> vikasg: Interesting idea!
04:41:05 <earthy> haskell addiction is due to chemicals?
04:41:08 <shapr> In any case, chemical signals are just one part of the big picture.
04:41:15 <poetix> It's generally a bad idea to reduce any of these systems to one component
04:41:42 <poetix> Whichi is what the rhetoric of "drugs" rather tends to do, as if the drug were the only active agent in the process of addiction
04:41:42 <shapr> Yeah, because the only fully accurate simulation has the same complexity as the original system.
04:41:57 <greenrd> poetix: Agreed.
04:41:58 <poetix> To some degree, one has to addict oneself to drugs
04:42:25 <poetix> I remember starting smoking, for instance. It was almost as hard in some ways as stopping.
04:42:40 <earthy> ick
04:42:41 <earthy> yeah
04:42:42 <vikasg> poetix, true enough
04:42:47 <tuomov> I didn't use to like coffee...
04:42:56 <earthy> I still don't like coffee
04:43:09 * Beelsebob goes to do some needless optimisations and feed his earl grey habit
04:43:10 <tuomov> I'm not addicted to it, though.
04:43:13 <greenrd> Why would anyone voluntarily drink something as foul as coffee?
04:43:14 <boegel> who likes beer the first time he/she tries it ? not many people do
04:43:16 <greenrd> I don't get it.
04:43:20 <shapr> poetix: Same for me, starting smoking was almost as hard as stopping.
04:43:23 <vikasg> poetix, a friend of mine couldn't stand smoke for a long time, and one day suddenly started to
04:43:43 <shapr> boegel: I still don't like beer or wine. Tastes like something died in there.
04:44:05 <tuomov> yeasts?
04:44:09 <shapr> Yeah :-)
04:44:16 * poetix goes to find some food
04:44:24 * shapr goes to find an apartment
04:44:50 <shapr> Oh hey, can I make my own weebl & bob flashtoon wish OpenLaszlo?
04:45:02 <shapr> Is there some Open something that'll let me make my own flashtoons?
04:45:34 <shapr> poetix: oooh You have a pic on your blog now!
04:45:56 <tuomov> boegel: the beer you taste the first time is usually piss-lager?
04:46:16 <tuomov> Such still don't taste all that good, only drinkable
04:46:18 <boegel> poetix: blog url ?
04:46:39 <boegel> tuomov: I live in Belgian, we don't have any piss-lager here ;)
04:46:46 <boegel> s/Belgian/Belgium
04:46:53 <shapr> poetix' blog is at http://codepoetics.com/poetix/
04:47:14 <tuomov> boegel: lucky you
04:47:28 <tuomov> in .fi we have to go to the state monopoly alko for real beer
04:47:42 <tuomov> shops can't shell anything with over 4.7% alcohol
04:48:20 <boegel> tuomov: sucks ! omg :)
04:48:21 <shapr> Sweden has a state monopoly also, and Europe's highest alcohol tax.
04:48:26 <tuomov> and it's mostly imports. most finnish beer is piss-lager
04:48:34 <boegel> the best beers over here have 7-8% alcohol
04:48:46 <tuomov> the real beer is imports, I mean
04:48:54 <shapr> Sweden's alcohol tax is against EU regulations I think. Should be interesting to see what happens when they cut it down to the legal level.
04:49:45 <shapr> I predict a week long party.
04:49:56 <sieni> no it's not
04:50:02 <tuomov> I don't care about the taxes, but real beer and wine belong to grocery stores
04:50:35 <vikasg> poetix, what do you think of porting Parsec to Python?
04:50:45 <shapr> sieni: What's the EU regulations on alcohol tax?
04:51:14 <tuomov> in .fi the tax was lowered a little last year because people kept carrying their piss-lagers and koskenkorvas from estonia
04:51:43 <sieni> Since they can't limit the importation of alcohol for personal use that much anymore
04:52:02 <sieni> and they wanted to keep at least some of the tax income
04:52:07 <shapr> Haparanda buys alcohol from Tornio
04:58:27 <xerox> TheHunter: an answer!
04:58:47 <xerox> It involves Functor, yay :)
05:00:24 * poetix returns with food
05:00:54 <xerox> poetix: I'm pushing a twisted guy to answer your last blog post, but he's somewhat angry :P
05:01:13 <poetix> vikasg: Probably not worth a direct port, but you've seen the parser-combinators-in-Python code?
05:01:20 <poetix> xerox: They don't like it up 'em.
05:01:30 <vikasg> poetix, that's what prompted me to ask
05:02:07 <poetix> But I've read some downright ignorant stuff from Twisted people about threading, based on a very narrow conception of what thread-based concurrency can be.
05:03:11 <shapr> xerox: Which twisted guy?
05:03:35 <poetix> vikasg: I like the idea of using combinators to define parsers, but I don't think the execution style of Parsec would map too well to Python - if you have mutable state, you might as well use it.
05:03:40 <poetix> Now a PArrows port...
05:04:14 <xerox> shapr: it's mainly an advocating person, not a twisted developer, what exactly do you want to know?
05:04:58 <shapr> I know some of the Twisted people, just wondering who you're talking to.
05:05:17 <shapr> I started TwistedHaskell long ago and far away.
05:06:06 <xerox> shapr: dialtone
05:10:22 * poetix dons flame-retardant boxer shorts
05:13:51 * vikasg waves
05:14:05 <poetix> xerox: maybe redundant to ask, but what in particular was he annoyed about?
05:14:21 * dons poetix flame-retardant, um, oh, i give up
05:14:33 <xerox> poetix: "lightweight threads"
05:14:54 <poetix> Does he not think that any such thing exists?
05:15:10 <xerox> IIUC yep, he called them coroutines
05:15:28 <xerox> ...and something about python being used by the BBC for some hard work
05:15:39 <xerox> being so The Tool For The Job
05:16:12 <poetix> Not *necessarily* the same - coroutines give you a kind of co-operative multithreading
05:16:23 <xerox> poetix: if you /j #twisted there will probably be a discussion, but I don't know, it's shapr :)
05:17:41 <musasabi> Haskell concurrency is much cheaper than python (if it still uses OS threads) thus using Haskell threads is not a problem from performance point of view.
05:18:07 <musasabi> In some benchmarks GHC even kills Erlang in threading performance (but that was apples to oranges).
05:18:08 <poetix> Well, the background here is I was considering a partly event-driven model for a Haskell web server
05:18:48 <poetix> Where it would do the boring stuff like parsing HTTP in a Twisted-style fashion, then spawn threads to do things like fetch data and construct HTML pages
05:18:53 <shapr> poetix: you got called fud ;-)
05:19:02 <poetix> Yay.
05:19:03 <xerox> heh.
05:19:24 <poetix> But the more I looked into Concurrent Haskell, the less worthwhile this project seemed to be.
05:19:30 <musasabi> Using some hws port should work nicely.
05:19:46 <musasabi> But there are at least five versions of it.
05:20:10 <musasabi> Getting people to agree on one would be nice.
05:20:45 <musasabi> I think that can be partly blamed on Haskell - code is too short and easy to read making it very easy to understand & fork.
05:21:01 <tuomov> hmm.. coroutines are quite essential for conveniently writing stuff in an event-driven approach, though
05:21:35 <poetix> Also, everything's still kinda *new* - there's nothing really established, so no strong disincentive to reinventing the wheel
05:21:42 <shapr> hiya bjak
05:21:49 <bjak> hi hi
05:22:02 <poetix> I mean, my idea was fairly novel, but also unfortunately not very good...
05:22:55 <poetix> tuomov: Vanilla Twisted code has to manage control flow in an event-driven approach without coroutines, which is why I called the programming model "bogglesome"
05:23:45 <poetix> You can kind of fake coroutines in Python using generators, and Stackless has the real thing.
05:25:05 <tuomov> lua has coroutines too, and they're great
05:25:52 <Lor> When reading the latest JFP I finally got acquainted with the pi-calculus. I must say that it's kind of cool how the lambda->pi transformation shows the symmetry between argument passing and continuations (in pi both are just message sends).
05:26:19 <poetix> When I was writing Twisted code, it made me feel clever. Trouble is, it made me feel clever because it was hard. And then eventually I needed to make some database calls which were blocking, which meant that I needed threads anyway, which meant that all of a sudden I had to start worrying about all the concurrency issues that event-driven programming is meant to make disappear.
05:26:27 <Lor> s/continuations/returning/, my brain was jumping ahead a bit
05:26:43 <poetix> It's better to just have better abstractions for dealing with concurrency.
05:26:53 <xerox> What are coroutines?
05:27:23 <Lor> After having programmed for some time now with threads, mutexes and conditions in c, I must strongly agree.
05:27:27 <tuomov> cooperative multithreading, where the thread can yield control to another with a return value, and get another value back from the yield when given control again
05:28:01 <poetix> Ruby supports this better than vanilla Python, in fact.
05:29:17 <poetix> Python's yield statement can't return a value - that is, it passes a value out of the generator, but whatever handles the value can't pass a value back into the generator.
05:29:27 <greenrd> Is there a name for the property of a function that "for all x, f (f x) = x"?
05:29:45 <moista> hi
05:30:05 <moista> i wrote a DES algo that uses graphics hardware for encryption
05:30:42 <tuomov> greenrd: two-cyclic?
05:30:57 <tuomov> just a guess
05:32:34 <arjanb> involution?
05:32:55 <Lor> greenrd, idempotency
05:33:12 <tuomov> no, idempotent means f(f(x)=f(x)
05:33:20 <greenrd> yeah
05:33:22 <Lor> Ah, sorry, misread.
05:33:40 <tuomov> wikipedia agrees that involution is the term
05:34:33 <greenrd> arjanb: Thanks!
05:34:55 <boegel> moista: in Haskell ?
05:36:24 <moista> boegel, no C, but I came here, bacause Haskell-people are always interrested in new stuff
05:36:53 <greenrd> DES isn't exactly new though ;)
05:37:17 <boegel> moista: greenrd doing it on graphics hardware is :)
05:37:20 <moista> but my port to the gfx is new ;)
05:37:33 <moista> get it from toki.burn3r.de
05:41:13 <moista> can anyone compile and try it out ?
05:41:21 <dons> mm. this is fun. you can program in either the IO monad or List monad in h4sh. IO = {>>= -> | , return -> i }, List= {m >>= k             = foldr ((++) . k) [] m
05:41:49 <dons> return x in list is echo/show in h4sh
05:43:04 <moista> what's h4sh ?
05:43:40 <dons> Functor List holds too. map id == id, map (f.g) == map f | map g
05:43:48 <dons> @where h4sh
05:43:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
05:45:19 <moista> that's interresting
05:47:34 <dons> and functor IO holds, where fmap ==  x >>= (return . f), then >>= is | and . is |
05:50:34 <poetix> Ah, glyph gave me a grown-up retort to my Twisted FUD
05:51:06 <poetix> Apparently, "threads" only mean what they mean to Java programmers.
05:52:01 <poetix> Erlang's threads aren't threads at all, and neither are Oz's (or Concurrent Haskell's)
05:53:11 <musasabi> They are threads.
05:53:16 <musasabi> They are not OS threads.
05:53:40 <poetix> http://codepoetics.com/poetix/index.php?p=141#comments <- Glyph's reasoning
05:54:06 <poetix> His definition of "threads" is mainstream, therefore right.
05:54:34 <tuomov> I include coroutines in threads..
05:54:58 <poetix> I'm not sure that Oz's concurrency model is equivalent to "pipes or sockets" in any case.
05:55:07 <tuomov> and they're a relatively safe kind of threading too in an imperative language
05:56:08 <poetix> Part of the point of the stuff I was doing on tuple spaces was to look at other ways of co-ordinating concurrent processes
05:56:30 <poetix> Besides "shared state" on the one hand, and "nothing but pipes" on the other
05:56:49 <musasabi> The haskell model is more or less equivalent to python threads, only the implementation is different.
05:57:28 <poetix> I don't totally understand the interactions between Haskell threads and OS threads, I must say...
05:57:50 <musasabi> You don't need to care about that unless you are doing fancy FFI stuff.
05:58:01 <poetix> Or wanting to make use of multiple processors?
05:58:17 <moista> i guess, all haskell threads run in a single OS thread
05:58:36 <musasabi> poetix: that will be supported in the next versions of GHC (the smp things in HEAD).
05:58:58 <poetix> The interaction with I/O is another murky area, IIRC
05:59:24 <poetix> Blocking I/O calls don't hold up all the other lightweight threads because...?
05:59:44 <musasabi> actually that is quite simple. 1) use nonblocking calls and don't worry, 2) use blocking calls (and don't call them unsafe) and give -threaded to GHC.
05:59:56 <tuomov> because the haskell scheduler does the select() stuff
06:00:09 <musasabi> poetix: because ghc -threaded use a thread pool to multiplex blocking foreing calls.
06:00:20 * beelsebo1 discovers that the IFL deadline is on friday
06:01:06 <poetix> So you have a pool of separate OS threads that pick up blocking I/O requests, and the Haskell threads all sit on the same (separate) OS thread?
06:01:23 <moista> probably
06:01:59 <poetix> And the SMP stuff does what? Multiplex Haskell threads across several OS threads?
06:02:13 <moista> hopefully ;)
06:02:40 <poetix> Oz ducks the question, AFAIK - if you want to use multiple processors, you have to explicitly start multiple processes.
06:02:45 <SamK> Hi all, I have just started getting into functional programming (from imperative). What I would like to know most, is how compilers deal with recursive functions that process arrays, surely they dont keep allocating new ones for every recurse?
06:02:45 <tuomov> the io calls actually just tell the scheduler thing that this thread is waiting on this file descriptor, check if there's anything there, if not continue executing others, but occasionally go checking it. If everything is waiting for something, select() on all the fds until there's more work to be done.
06:02:50 <boegel> yo Eileen
06:02:51 <tuomov> or something like that.
06:02:54 <boegel> err, Oeje1
06:02:58 <Oeje1> cat #haskell >/dev/null
06:03:07 <Oeje1> Hello, boegel.
06:04:06 <poetix> SamK: no...
06:04:59 <poetix> SamK: If you pass a list around, for instance, and extend it by consing new elements on to it, then the old list is preserved - the new list consists of a reference to the old list, and a reference to the new element
06:05:01 <boegel> yo xerox, got your money yet from Google ? :)
06:05:18 <xerox> Not yet :)
06:05:30 <poetix> SamK: so you don't have to make a copy of the entire list each time.
06:05:40 <SamK> poetix: Ah, I see
06:06:01 <poetix> SamK: And garbage collection cleans up anything you don't need any more ;)
06:06:14 <SamK> what sort of data structure is used "under the hood" to achive that?
06:06:46 <poetix> Depends on the implementation, but the basic structure is a cons cell
06:07:13 <poetix> Which is just two pointers, one to the "head" and one to the "tail".
06:07:45 <poetix> So a list is a collection of nested cons cells - [1, 2, 3, 4] == (1, (2, (3, 4)))
06:08:19 <SamK> poetix: That makes sense
06:08:35 <tuomov> and two lists can share a tail
06:08:41 <tromp> that's 1:(2:(3:(4:[])))
06:08:45 <tuomov> because the tail doesn't have a backpointer
06:08:50 <Lemmih> Greetings nibro.
06:08:53 <dcoutts> boegel, but there are more screenshots of progress :-)
06:08:59 <poetix> tromp: Oh, yes, of course
06:09:00 <dcoutts> http://www.haskell.org/~duncan/gtk2hs/Text.png
06:09:41 <tromp> poetix, is your last name justix:-?
06:10:15 <poetix> No, the Asterix version would be poeticjustix...
06:11:03 <SamK> tuomov: In what situations would two lists share a tail?
06:12:29 <tuomov> I wonder if there's a real-world example
06:12:42 <moista> if a function prepends sometinhg to a list, the new an the old list share the same tail
06:12:58 <SamK> ah right
06:13:17 <tromp> whenever you apply :
06:13:31 <tuomov> often it would be more useful to append stuff to a list, though..
06:13:31 <tromp> a:l and l share the tail l
06:13:43 <tuomov> so you need to work with reversed lists
06:13:43 <SamK> I guess this all relates to the [x:y] type syntax.. where x is the head, and y is the tail?
06:13:53 <tuomov> yep
06:14:22 <tromp> no, the syntax is (x:y)
06:15:24 <poetix> It's often written (x:xs), where "xs" is the plural of "x", to show that "x" is one element of the list (the first), and "xs" is all the remaining elements.
06:16:21 <SamK> ok, thats given me something to go think about for a bit.. thanks all
06:16:38 <boegel> dcoutts: where ?!?
06:16:51 <boegel> oh, nvm, you already pasted the link :p
06:18:14 <dcoutts> boegel, so we'll be able to do arbitrary affine transforms on text
06:18:33 <boegel> dcoutts: nice :)
06:18:34 <dcoutts> and fill with patterns/gradients etc, use text as a clipping mask, etc etc
06:18:41 <boegel> gtk2hs is really growing fast
06:18:47 * boegel likes gradients
06:18:57 <dcoutts> well this bit is the new cairo stuff
06:19:27 <dcoutts> and you'l be able to use cairo without gtk, and you can target png/ps/pdf too
06:20:20 <boegel> dcoutts: damn :) go xerox !
06:21:46 <poetix> Cairo is getting integrated into Gnome/GTK?
06:22:00 <dcoutts> poetix, yes it's done as of Gtk+ 2.8
06:22:06 <dcoutts> which came out the other day
06:22:32 <dcoutts> or rather gtk now depends on and is using cairo
06:22:47 <poetix> How does that work with X? Does cairo paint onto a canvas of some kind?
06:23:09 <dcoutts> yes, gtk is using the X11 or GL backend of cairo to do the drawing
06:23:22 <Oeje1> Gtk+ is broken.  It needs to be rewritten, because it has problems which cannot be fixed, e.g. memory problems and speed problems.
06:23:35 <dcoutts> Oeje1, it seems ok to me
06:23:53 <poetix> Does this mean nice vector-based alpha-blending desktop components?
06:23:53 <dcoutts> It has quite good memory management actually
06:24:02 <SamK> Actually, I have another question.. What about  non-cons style operation, like, for example, a new list that is contains the last 10 elements of an existing list that is 100 big. Does that use "cons cells" in any way, or does it incur copying?
06:24:22 <dcoutts> poetix, yes, possibly if you use a widget theme that uses cairo
06:24:33 <poetix> So not yet, but soon...
06:24:56 <dcoutts> probably by the gnome 2.12 release you'll see cairo based themes come out
06:25:16 <Oeje1> The problem is, Gtk+ was not build for speed and low memory consumption.
06:25:19 <dcoutts> and some time afer that people will really start to experiment with the new features
06:25:44 <dcoutts> I expect initial cairo theme engines will be straight ports of current gdk based themes
06:25:48 <Oeje1> ...at least I've read.
06:26:16 <dcoutts> Oeje1, well it works fine on embeded systems with little memory, eg palm computers
06:26:20 <poetix> SamK: Assuming we know the size of the list in advance, we can recursively CDR (get the tail of) the list 90 times, and return the tail of the cons cell containing the 89th element as its head and elements 90-100 as its tail
06:27:14 <poetix> SamK: If you can find a copy, The Little Schemer is a very good guide to basic recursion and list operations
06:28:03 <poetix> dcoutts: I may have to rethink my loyalty to KDE...
06:28:40 <Itkovian> hmm, how do I rename a whole bunch of file where the filenames contain whitespace? i mean as using it in a for loop, not doing it manually
06:28:48 <SamK> poetix: ok,  may take a look
06:28:51 <dcoutts> poetix, they're getting something that's apparently nearly as good, Qt4 has some "arthur" rendering system
06:29:22 <poetix> dcoutts: Just what we need - two competing desktop vector graphics engines...
06:29:25 <pejo> Itkovian, mv "$file" "newname_$file"?
06:29:41 <Itkovian> right and how does one retain the " in the for loop?
06:29:51 <Itkovian> "", \", ... will not do
06:30:00 <dcoutts> poetix, yeah, it's unfortnate. Trolltech see to be doing their own thing
06:30:21 <dcoutts> poetix, everyone else is going for cairo (Gtk, Mozilla, OpenOffice, ...)
06:30:27 <poetix> dcoutts: The standard apologia for this sort of mess is that diversity and competition are Teh Good
06:30:43 <Lemmih> Itkovian: Can't you use the 'rename' program?
06:30:48 <dcoutts> poetix, hmmm, yeah
06:30:52 <poetix> dcoutts: But standards are also Teh Good, or at least they would be if anybody actually followed them...
06:30:58 <dcoutts> indeed
06:31:01 <pejo> Itkovian, touch "asdf fdsa"; for file in *; do RET mv "$file" "jklo_$file" RET done worked for me.
06:31:20 <SamK> poetix: Actually, I think i'm begging to "get it". I guess you can do all this because lists are immutable. Therefore you are able to share sublists with other lists etc..
06:31:21 <dcoutts> poetix, well KDE havn't decided yet, they could yet use cairo C++ bindings
06:31:26 <tuomov> diversity is good, but these different DEs are just the same shit both.
06:31:48 <vegai> then there's GNUStep, tk, fox, fltk, ...
06:31:50 <Itkovian> pejo: hmm, for file in * will yield _two_ loop iterations, one for asdf and one for fdsa
06:31:57 <tuomov> (although kde doesn't tend to break the rest of the system as much as gnome does.)
06:32:12 * poetix is fond of blackbox
06:32:23 * Itkovian is all for KDE
06:32:24 <pejo> Itkovian, not here.
06:32:32 * vegai uses wmii these days
06:32:39 <pejo> Itkovian, even with /bin/sh it does the right thing for me.
06:32:39 <Itkovian> pejo: lucky you
06:33:24 <Itkovian> ok, sorry ...
06:33:35 <Itkovian> I have no idea where I fouled up.
06:34:11 <beelsebob_> anyone here heard of R?
06:34:15 <Itkovian> I have
06:34:23 <Itkovian> I'm using it fairly often
06:36:13 * boegel uses gnome
06:37:08 <tuomov> ion 4evah!-)
06:37:32 <CosmicRay> hmm.
06:37:39 <CosmicRay> any suggestions for a "quote of the week" for this week's HWN?
06:37:42 <Lemmih> CosmicRay: How's HWS?
06:38:05 <CosmicRay> you mean HWN?  (the haskell weekly news?)  I'm just finishing up this week's issue
06:38:37 <Lemmih> CosmicRay: My cabalized version of GHC's Haskell parser is out.
06:38:39 <dcoutts> CosmicRay, well be sure to note the great progress of the Haskell cairo+gtk bindings :-)
06:39:09 <CosmicRay> Lemmih: sweeeeet.  I didn't see it announced on any list though
06:39:24 <CosmicRay> dcoutts: was that announced on any list.  (what's cairo?  WinNT?)
06:39:25 <boegel> CosmicRay: something about getting addicted to drugs vs being addicted to Haskell ?
06:39:44 <dcoutts> CosmicRay, cairo is a cool new vector graphics package
06:39:44 <CosmicRay> boegel: sure, fire a great one at me ;-)
06:39:53 <dcoutts> CosmicRay, check out this url...
06:40:06 * boegel checks the logs
06:40:17 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/10/gtk2hs-cairo-project/
06:40:19 <dcoutts> and ...
06:40:27 <dcoutts> http://haskell.org/gtk2hs/archives/category/cairo/
06:41:08 <dcoutts> CosmicRay, it's xerox that's currently working hard on all this stuff for the Google Summer of Code programme
06:41:08 * Lemmih will write an announcement.
06:41:42 <CosmicRay> thanks dcoutts.
06:42:43 <boegel> <tuomov>	define drug	12:24:32
06:42:43 <boegel> <Itkovian>	anything that gets you addicted to	12:24:41
06:42:43 <boegel> <Itkovian>	potentially	12:24:45
06:42:43 <boegel> <Itkovian>	and that messes with yr senses	<Lemmih>	Haskell?
06:42:52 <boegel> CosmicRay: how's that for a qoute ?
06:43:12 <CosmicRay> boegel: good :-)
06:43:17 <CosmicRay> what day was that?
06:43:23 <Itkovian> today
06:43:23 <xerox> This morning :)
06:43:24 <boegel> today
06:43:28 <CosmicRay> thanks
06:43:30 <boegel> a few hours ago
06:43:35 <boegel> maybe only 1
06:43:39 <Itkovian> we were talking about women I think ;-)
06:44:19 <Oeje1> dcoutts: One attempt of porting a theme to Cairo is talked about at http://www.stellingwerff.com/?p=5 ,
06:44:41 <dcoutts> Oeje1, yes, I've seen that one too
06:45:17 <dcoutts> I suspect it'll take a few months before the widget deigners start to make really good use of the new capabilities
06:46:57 <dcoutts> ie the themes that come with gnome 2.12 might be a bit disapointing by not really having changed much
06:47:10 <CosmicRay> Lemmih: how soon will you have your announcement?
06:47:45 * vegai compares ion3 to wmii
06:47:47 <Oeje1> It's a shame that more attention isn't going to E17.
06:48:14 <boegel> Oeje1: it's o n the radio everyday here in Belgium ^_^
06:48:52 <Itkovian> E17 has been due for far too long
06:49:02 <Lemmih> CosmicRay: In a couple of minutes.
06:50:56 <boegel> CosmicRay: aren't you tired yet of doing HWN every week ?
06:51:57 <CosmicRay> boegel: well, it would be nice to get more submissions from others, but I seem to get a "thank you" e-mail or two every week, which is nice.
06:52:07 <vegai> hmm, ion3 seems rather snappier than wmii
06:52:13 <CosmicRay> people seem to appreciate HWN more than any code I've written, so...  goes to show how good my code is, I guess ;-)
06:52:18 <vegai> I find the default bindings rather bad for dvorak
06:52:54 <boegel> CosmicRay: I read it every week so far, and I think someone should've come up with this a long time ago
06:53:17 <dblhelix> CosmicRay: no, the HWN  is really awesome, so it does not say anything about your code, i.e., your code can still be very good too
06:54:05 <CosmicRay> I guess I really like doing things relating to a language I like, that others find useful.
06:54:14 <Itkovian> CosmicRay: why, thank you for HWN ... actually before sounding like some slime ball I've made good use of the h4sh announcement
06:54:22 <dblhelix> when earthy came back from vacation last week, he immediately recognized the handiness of the HWN, having a mailbox full of Haskell mailing list messages
06:54:25 <CosmicRay> :-)
06:55:59 <CosmicRay> draft of this week's issue is at http://darcs.complete.org/hwn/prep.html
06:56:17 <earthy> yeah, thanks for those! :)
06:56:31 <earthy> it made catching up a breeze :)
06:56:40 <CosmicRay> thanks
06:57:02 <Pita> is there an inspiring reading for haskell, just as there is paul graham for lisp?
06:57:04 <dcoutts> CosmicRay, you're sending it to LWN too I hope
06:57:10 <CosmicRay> dcoutts: yes
06:57:34 <dcoutts> CosmicRay, oh on the draft...
06:57:58 <dcoutts> I'm not sure I indicated that "there is no good way to do a really correct binding to wxWidgets from Haskell when Haskell programs are multithreaded."
06:58:15 <CosmicRay> do you have an alternative wording for that?
06:58:17 <dcoutts> it is possible, but it has to be done at the binding layer, rather than by the end user
06:58:33 <CosmicRay> ah, so wxWidgets could do it, with more hacking?
06:58:43 <dcoutts> it doesn't work now, but it could, especially with sufficient cooperation from the GHC RTS
06:58:47 <CosmicRay> it sounded like you were saying this was difficult/impossible due to the haskell threading model
06:59:05 <CosmicRay> so s/no good way/no easy way/ ?
06:59:33 <dcoutts> I think I was saying that it doesn't work currently with the current wxHaskell (or indeed Gtk2Hs) bindings, but it's not impossible
06:59:44 <dcoutts> now easy way at the moment
06:59:52 <Pita> what are examples of large applications written in haskell?
07:00:03 <CosmicRay> Pita: darcs is a canonical one
07:00:15 <dcoutts> CosmicRay, I just don't want it to look like I'm slating wxHaskell! Since as a Gtk2Hs developer that might not look very good. :-)
07:00:17 <Tue12747> if i pass (f a) twice to different functions...will it be evaluated twice?
07:00:20 <Pita> Is there an inspiration type of reading for Haskell?
07:00:49 <musasabi> => away till sometime in september.
07:00:51 <Tue12747> let res1 = ....(f a).... ; res2 = ....(f a).... in ...res1....res2....
07:00:57 <Tue12747> that kind of thing
07:01:30 <CosmicRay> dcoutts: hit refresh and see if it's better now
07:01:35 <CosmicRay> dcoutts: thanks, btw.
07:01:42 <dblhelix> Tue12747: hi! have you already met boegel? :)
07:01:50 <Tue12747> boegel? who is that
07:01:51 <Tue12747> ?
07:01:56 <Tue12747> is he new here?
07:02:11 <Tue12747> maybe he wants to learn haskell :P
07:02:12 <dblhelix> maybe he should get the tour? shapr!?
07:02:18 <dcoutts> CosmicRay, thanks
07:02:37 <CosmicRay> boegel probably doesn't need the tour ;-)
07:02:47 * boegel farts loudly
07:02:57 <CosmicRay> on the other hand, he may need the facilities.
07:03:03 <boegel> there you go, you motherf*ckers
07:03:09 <dblhelix> CosmicRay: well, boegel tried to trick Tue12747 to take the tour, last week, so... :)
07:03:15 <Igloo> Tue12747: It depends
07:03:20 <CosmicRay> sounds like someone took over boegel's terminal again.
07:03:34 <boegel> CosmicRay: I still swear I never saw him hear
07:03:48 <boegel> CosmicRay: again ?!?
07:04:13 <CosmicRay> heh
07:04:14 <dblhelix> CosmicRay: yeah, the 8am version of the bot commonly known as boegel took over his terminal... kind of a zombie, that fellow
07:04:20 <boegel> CosmicRay: when did it happen the first time ?
07:04:41 <CosmicRay> hmm, wasn't that you, about a month ago?
07:04:42 <dblhelix> boegel: we do that all the time, hacking your account ;)
07:04:57 <boegel> dblhelix: I dare you :)
07:04:58 <CosmicRay> blamed it on coworkers/students sitting at your unsecured terminal
07:05:13 <boegel> CosmicRay: my terminal is always secured
07:05:22 <boegel> and a month ago, I didn't even have a terminal :)
07:05:31 <boegel> atleast not here
07:08:14 <Tue12747> Igloo, depends on what?
07:08:29 <Tue12747> on whether res1 and res2 are used in the let-body?
07:08:37 <CosmicRay> Lemmih: let me know when you get the announcement sent please
07:08:41 <Igloo> Whether the compiler decides to do CSE on it or not
07:09:24 <Tue12747> does ghc normally ? :)
07:09:38 <Tue12747> because otherwise i will have to manually lift in in the let
07:09:49 <Lemmih> CosmicRay: Sent.
07:09:55 <Tue12747> but i'd rather not do work the compiler has to :)
07:10:03 <CosmicRay> Lemmih: which list?
07:10:04 <Lemmih> CosmicRay: To haskell@haskell.org
07:10:08 <CosmicRay> thanks
07:10:20 <Igloo> If you want to be sure it is evaluated only once, bind it to a var (I'm not sure the language guarantees this, but in practice it will be evaluated once)
07:33:47 <beelsebob_> hmm... what's a good thing to cite for Haskell
07:35:29 <xerox> @quote
07:35:30 <lambdabot> Pseudonym says: I think principal types are overrated
07:35:30 <arjanb> the haskell 98 report maybe
07:35:46 <beelsebob_> hmmm, that would be the obvious one I guess :)
07:35:58 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050823"]' by CosmicRay
07:40:38 <greenrd> I have a simple question about dependent types
07:41:23 <greenrd> I've looked a bit at the Epigram tutorial
07:43:48 <greenrd> It seems clear that one can prove any proposition of the form P(f(x),x) if P can be encoded as an equation between the types of f(x) and x
07:44:13 <greenrd> But how can one prove a proposition of the form P(f(f(x)),x)?
07:44:29 <greenrd> For example, f(f(x))==x
07:45:33 <integral> err, if g = f . f,  then you're just proving a proposition of the form P(g(x),x) which you've said you can,  I must be missing something :-/
07:46:25 <greenrd> Good point!
07:49:12 <greenrd> Actually, I should have said "many true propositions" instead of "any proposition". Anyway. I will have a go at proving P(g(x),x) and see how I get on.
07:50:55 <boegel> CosmicRay: nice issue of HWN :)
07:51:13 <boegel> I'm loving it more and more each time a new issue is out :)
07:51:44 <dcoutts> CosmicRay, yes, seconded
07:54:38 <boegel> ooh, h4sh is cool !
07:56:12 * boegel thinks a lot of cool stuff is happening in the Haskell world the last few weeks
07:59:27 <xerox> Indeed, it's always moving!
08:00:16 <boegel> too bad I don't have time to play around with it :(
08:02:36 <CosmicRay> thanks
08:06:00 * boegel goes home for some wel-earned rest
08:06:05 <boegel> and sex, off course
08:07:20 <Heffalump> is that well-earned too?
08:07:34 <boegel> no comment :p
08:08:19 <meren[N\A]> can anyone advice me a document to read which explains what is "referential transparency"? and i'm sorry if it is a stupid question..
08:08:32 <dcoutts> boegel, xerox and I have a potential mini project for you...
08:08:44 <boegel> dcoutts: which is ?
08:08:52 <boegel> make it quick, I gotta go to catch my train
08:08:53 <dcoutts> boegel, involving cool graphics, a bit like your exisitn 3d random thingy
08:09:00 <dcoutts> oh, right, maybe later then
08:09:19 <boegel> I might be online tonight (as in, within 5 hours orso)
08:09:25 <dcoutts> ok
08:09:31 <boegel> or else, just tell me about it tomorrow
08:09:38 <boegel> gottaz run
08:09:42 <dcoutts> bye
08:10:00 <sieni> meren[N\A]: http://en.wikipedia.org/wiki/Referential_transparency
08:10:27 <meren[N\A]> yes sieni, i'm reading that now, sorry..
08:12:05 <greenrd> Another dependent types question:
08:12:55 <greenrd> Is it possible to prove, using dependent types "alone", that "map id" is the identity function on lists?
08:13:25 <greenrd> Or even just to prove that it is the identity function on lists of naturals?
08:13:25 <greenrd> And if so, how?
08:18:44 <greenrd> Because the problem I see with trying to do that is, a list is potentially infinite
08:18:58 <greenrd> And if you want to model equality of lists in types, you have to model the whole list
08:19:13 <greenrd> Including all the structure of its data (up to equality)
08:25:05 <greenrd> But even if we stick to lists of naturals, you still have to model a potentially infinite set of data (all the elements of a list) as a type
08:27:07 <greenrd> Naturals are easy because they're just (in Epigram) kind Nat = Z | S Nat
08:27:29 <greenrd> But _lists_ of naturals... how can they be faithfully modelled as types?
08:27:46 <Philippa> c'mon, you can do /that/ in Haskell (with extensions)
08:27:55 <Philippa> what's the canonical list type?
08:27:58 <Philippa> just raise that a level
08:28:29 <greenrd> It might be that I'm being very stupid here
08:29:24 <Philippa> yup
08:29:29 <greenrd> A pair of naturals would be (in Epigram) kind Pair = P Nat Nat
08:29:34 <Philippa> data List a = Nil | Cons a (List a)
08:29:48 <Philippa> now, translate that into epigram at the type level
08:29:56 <Philippa> (consider the equivalent Nat type in Haskell, too)
08:32:38 <greenrd> I can't do it
08:32:44 <greenrd> Let's check that we're on the same page here
08:33:27 <greenrd> I think that I need to model the entire contents of the list as a type. Not just the type of the elements of the list, but the _values_ of all the elements of the list.
08:34:22 <cyanite> hmm.. can that even be done in haskell?  types are only parametrized on other types, m?
08:34:39 <Philippa> cyanite: it involves some nifty hackery. Go look up HList
08:34:43 <Philippa> (and it's impossible in Haskell98)
08:34:48 <cyanite> What I thought.
08:35:02 <greenrd> cyanite: I don't think it can be done _at all_ even in principle :)
08:35:12 <Philippa> greenrd: I'm telling you how to build the damn kind, 'k?
08:35:21 <Philippa> a list is just a natural number with data attached to each succ
08:35:35 <greenrd> Philippa: No, you've only given me an analogy so far. You haven't told me _how_.
08:36:13 <greenrd> Let's take an example.
08:36:22 <greenrd> What is the type of [1 2 3] going to be?
08:37:09 <greenrd> I can type (1,2,3) easily - Triplet #1 #2 #3. But that only works because a triplet inherently has 3 and only 3 elements.
08:37:16 <Philippa> the /type/? List Int
08:37:22 <Philippa> you want a type that is a list though, no?
08:38:06 <greenrd> Hmm
08:38:16 <greenrd> List [#1 #2 #3] ?
08:38:30 <greenrd> That's bogus - you can't just introduce list syntax at the type level.
08:38:38 <cyanite> not in haskell.
08:38:42 <cyanite> ..98.
08:38:52 <Philippa> greenrd: list syntax is sugar
08:38:57 <integral> Cons #3 (Cons #2 (Cons (#3 Nil))) # you don't need syntax...
08:39:02 <Philippa> integral: bingo
08:39:13 <Philippa> greenrd: did you not understand the Haskell list type I showed you?
08:39:25 <greenrd> Which one?
08:39:40 <Philippa> data List a = Nil | Cons a (List a)
08:39:49 <greenrd> Yes, I understood that.
08:40:02 <Philippa> right. So why are you worrying about sugaring type level lists?
08:40:43 <greenrd> I was just thinking out loud.
08:40:59 <Philippa> no. That's why you were worrying in front of us ;-)
08:41:06 <greenrd> Sugaring is not the point.
08:41:10 <Philippa> you shouldn't even have been thinking it, at least with any seriousness
08:41:17 <Philippa> because it's not relevant and that haskell type demonstrates why
08:42:25 <greenrd> OK, I'll think more before posting next time.
08:42:31 <greenrd> Anyway, I still don't get it.
08:42:57 <Philippa> OK. You understand the haskell type OK? You could write arbitrary lists with it?
08:43:04 <greenrd> Yes
08:43:06 <Philippa> you could write map on it, stuff like that?
08:43:09 <greenrd> Yes
08:43:21 <Philippa> OK. Why don't you feel able to lift that to a kind?
08:43:35 <Philippa> could you lift a list-of-Nat okay?
08:43:40 <greenrd> If it's so easy, why don't you show me how?
08:44:32 <greenrd> No, I haven't worked out how to lift a list-of-Nat yet
08:46:10 <greenrd> kind ListNatKind = EmptyListNat | ConsNat Nat (ListNatKind ???)
08:46:17 <greenrd> The ??? is where I get stuck.
08:47:36 <Philippa> if it's not polymorphic, then ListNatKind shouldn't need a parm, no?
08:48:07 <greenrd> What do you mean by "polymorphic" in this context?
08:48:46 <Philippa> plain ol' parametric polymorphism as per Haskell
08:48:50 <greenrd> ok
08:51:46 <greenrd> Whoops!
08:52:14 <greenrd> I've been confusing Epigram and Omega
08:52:38 <Philippa> :-)
08:52:49 <greenrd> I said Epigram but I was writing Omega-ish syntax.
08:52:54 <Philippa> was starting to wonder when I grabbed epigram docs again and noticed the distinct lack of "kind" anywhere ;-)
08:53:10 <Philippa> Omega I'd really expect to just write a type-level list as per Haskell
08:53:24 <Philippa> Epigram I expect to just let me have a list of anything, tbh
09:17:25 <ndm> @seen shapr
09:17:26 <lambdabot> I saw shapr leaving #haskell 3 hours, 28 minutes and 37 seconds ago.
09:17:39 <olliej> dcoutts: Huzzah! i now have an eratosthene sieve, and fibonacci lists going cleanly :)
09:33:29 <basti_> hmm let's say i'd like to crunch numbers in C, and wrap this in an arrow. Then the Arrow type would have to hold some reference to the numbers being crunched wouldnt it?
09:33:34 <Lemmih> What would be a cute name for a whole-program dead code analyzer?
09:33:43 <basti_> "fishy"
09:34:01 <Lispy`> Gardner
09:34:06 <Lispy`> Grounds Keeper
09:34:11 <Igloo> basti_: Why does a monad not suffice for you?
09:34:14 <Lispy`> Jeeves
09:34:41 <basti_> Igloo: hmm yes, why not.
09:34:51 * basti_ ponders
09:35:15 <Lispy`> has anyone constructed a haskell plugin for XCode?
09:35:25 * Lemmih goes with gardner.
09:37:06 <basti_> Igloo: so lets say i got some numbers, and process them, and yield a result (which would allocate new mem, though, maybe)
09:37:49 <basti_> what would i do with old results?
09:48:13 <Igloo> basti_: Whatever you want?  :-)
09:48:46 * basti_ sighs
09:48:47 <basti_> ;)
09:49:04 <Igloo> You aren't being specific enough for me to be able to help
09:49:23 <basti_> mmm i know
09:49:27 <basti_> i'm just thinking aloud
09:49:50 <basti_> i should just go and try it some
09:56:44 <SyntaxNinja> 'morning
09:56:50 <Lemmih> Hi
09:57:57 <Igloo> yo
10:04:09 <mikehammad> is anyone here familiar with the unboxed array libraries in ghc 6.4?  i'm having difficulty getting decent performance out of them
10:04:13 <SyntaxNinja> @seen shapr
10:04:15 <lambdabot> I saw shapr leaving #haskell 4 hours, 15 minutes and 26 seconds ago.
10:05:28 <basti_> mikehammad: afaik the performance is more centered on space than on execution time
10:06:15 <mikehammad> ok, let me tell you what i'm trying to do first
10:06:30 <mikehammad> i'm trying to write a fast matrix library for haskell
10:06:39 * basti_ nods
10:06:53 <mikehammad> one thing this requires (in most languages) is to inline code at base blocks
10:07:14 <mikehammad> so, let's center on matrix-matrix multiply for simplicity
10:08:26 <ndm> mikehammad, are you using the unsafeAt functions?
10:08:31 <ndm> they speed up array access quite a bit
10:08:33 <mikehammad> nope
10:08:40 <mikehammad> where do i find those
10:08:44 <mikehammad> and what do they do?
10:08:49 <ndm> @index unsafeAt
10:08:50 <lambdabot> bzzt
10:08:56 <SyntaxNinja> they make make reasoning about your program harder
10:09:08 <Lemmih> Data.Array.Base, iirc.
10:09:33 <ndm> if you just do array ! 5 it compares the array bounds, and then looks up the element
10:09:42 <ndm> array `unsafeAt` 5 just gets teh 5th element
10:09:55 <ndm> so its just a memory increment and return, dead fast
10:10:16 <ndm> but it does allow buffer overruns, array `unsafeAt` 100000 just gets random memory
10:10:22 <mikehammad> right
10:10:29 <basti_> cool. just like back then.
10:10:38 <ndm> i got quite a performance boost by moving to unsafeAt
10:10:47 <mikehammad> so i can't find a reference in the haskell libs
10:10:57 <mikehammad> are you sure it's supported in ghc6.4?
10:11:22 <mikehammad> i was under the impression that 6.4 prohibits unsafe array access
10:11:48 <ndm> no, i'm not
10:12:00 <ndm> i was using it under 6.2, and i now can't find it in the docs...
10:12:17 <ndm> it must be somewhere, as Alex generates lots of unsafeAt
10:12:29 <mikehammad> maybe hidden
10:12:45 <Lemmih> @type Data.Array.Base.unsafeAt
10:12:47 <lambdabot> forall e (a :: * -> * -> *) i.
10:12:47 <lambdabot> (Data.Array.Base.IArray a e, GHC.Arr.Ix i) =>
10:12:47 <lambdabot> a i e -> Int -> e
10:13:32 <mikehammad> i ran some time tests for the matrix-matrix mult and they were horrid.  so, i suspect bounds checks might be one factor
10:13:51 <basti_> can I do dload in haskell? :)
10:14:10 <basti_> i admit, its a small stretch with the type system.
10:14:45 <basti_> uhm dlopen
10:14:51 <mikehammad> here's another thing i'm unsure about...  in C it speeds things up considerably to inline code.  so, my base case for multiply generates a 32x32 inline multiply.  i'm unsure how this interacts with the monadic array ops, however
10:15:22 <Lemmih> @docs System.Posix.DynamicLinker
10:15:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System.Posix.DynamicLinker.html
10:15:29 <Lemmih> basti_: There you go.
10:15:32 <basti_> Lemmih: thanks!
10:15:46 <Heffalump> igloo has done some work using TH to unroll stuff
10:16:04 <ndm> it should be ok to unroll monad stuff
10:16:46 <mikehammad> ok good
10:17:00 <mikehammad> this is quite aggressive unrolling
10:17:43 <Heffalump> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/papers/ - the third paper
10:18:52 <mikehammad> yes i've actually seen that
10:20:39 <mikehammad> the unrolling in that paper is more passive that what i do.  he parses an expression and unrolls it directly.  what i do is generate a specially tuned base case -- wouldn't work the passive way
10:37:34 <Igloo> mikehammad: You might need to use mutable arrays, unsafeRead, unsafeWrite if you acare about efficiency, depending on what you are doing
10:38:19 * Beelsebob yawns
10:38:33 * Beelsebob prods itkovian
10:39:19 <Itkovian> hi
10:39:31 <Beelsebob> how goes?
10:39:44 <Itkovian> pretty good.
10:39:50 <Beelsebob> :)
10:40:02 <basti_> what do i do with structs through ffi, besides using some ffi tool?
10:42:06 <basti_> map it to tuples?
10:42:29 <xerox> basti_: are you using c2hs?
10:42:48 <xerox> Oh, you're not.
10:43:04 <basti_> no
10:43:07 <basti_> .)
10:43:35 <basti_> am i masochist?
10:43:52 <xerox> FWIK there are two ways 1) bind them as opaque pointers 2) write an Haskell type (a record) representing the struct and instantiate it in Storable.
10:44:09 <xerox> c2hs helps much :-)
10:44:11 <basti_> ahh storable instance
10:44:30 <basti_> i think i'll use a tool.
10:44:31 <basti_> :)
10:44:41 <xerox> Because you get {#set ..#} and {#get ..#} hooks for free
10:45:08 <xerox> ...calculated for free, even
10:45:59 <mikehammad> aha, unsafeRead and unsafeWrite look like what i need
10:46:01 <basti_> mmmh :)
10:47:52 <dcoutts> basti_, eg take a look at binding for TextExtents in http://haskell.galois.com/~paolo/darcs/gtk2hs/cairo/Graphics/Rendering/Cairo/Types.chs
10:49:20 <basti_> i see, as a record, as xerox said... After looking at the struct, i decided to use the help of a tool.
10:49:47 <basti_> is hsc2hs the same as c2hs?
10:49:53 <dcoutts> basti_, no
10:49:58 <basti_> aw.
10:50:03 <dcoutts> hsc2hs is a much lower level tool
10:50:26 <basti_> i see.
10:50:26 <dcoutts> c2hs does a lot more for you, including checkign that your binding is consistent with the C header files
10:50:26 <xerox> Indeed.
10:50:39 * xerox hugs c2hs
10:50:44 <basti_> nice
10:54:24 <basti_> I'll try to prod hsc2hs a little first.
10:57:13 <basti_> hsffig apparently mangled the dog, too. 14933 lines of code.
10:58:47 <dcoutts> basti_, hsc2hs is ok for writing Storable instaces for C structs but not for more sophisticated things
10:59:14 <dcoutts> like calling C functions, or dealing with the mapping of C types to Haskell types nicely
10:59:24 <xerox> SyntaxNinja: ping
10:59:36 <SyntaxNinja> hi xerox
10:59:50 <xerox> SyntaxNinja: sorry, do you know what happened to my account on monk, just, now?
10:59:56 <basti_> dcoutts: mmmmmk.
11:00:12 <dcoutts> SyntaxNinja, we were looking at: http://haskell.galois.com/~paolo/
11:00:21 <dcoutts> SyntaxNinja, but it seems to have dissapeared
11:00:38 <xerox> There is a redirecting index.html, here you'd get the repos: http://haskell.galois.com/~paolo/darcs/
11:00:54 <SyntaxNinja> can you log in?
11:00:57 <xerox> Nope
11:01:03 <dcoutts> You don't have permission to access /~paolo/darcs/ on this server.
11:01:03 <dcoutts> Additionally, a 403 Forbidden error was encountered while trying to use an ErrorDocument to handle the request.
11:01:13 <dcoutts> seems messed up
11:02:39 <basti_> so why is c2hs' homepage down today, of all days.
11:03:16 <xerox> basti_: I could pass you the latest release sources if you want me to
11:03:45 <basti_> http://freshmeat.net/projects/c2hs/ < I'll take this
11:03:58 <xerox> :-)
11:04:11 <basti_> the download links dont work too, though.
11:04:24 <xerox> Mine does contain an unsafePerformIO backdoor! :-P
11:04:41 <SyntaxNinja> the sysadmin just came over... it's not good
11:04:55 <xerox> SyntaxNinja: aww.
11:04:58 <SyntaxNinja> does anyone have a copy of the stuff that was in there?
11:05:05 <SyntaxNinja> can you log in?
11:05:05 <basti_> xerox: would be nice if you sent me your version.
11:05:08 <xerox> I do have a local copy.
11:05:25 <dcoutts> xerox, and I've got a copy too
11:05:40 <xerox> SyntaxNinja: Permission denied (publickey,keyboard-interactive).
11:05:46 <SyntaxNinja> ok...
11:05:46 <xerox> dcoutts: yes, fortunately :-)))
11:05:50 <xerox> basti_: email?
11:06:05 * xerox makes more backup copies heh
11:06:09 <dcoutts> basti_, are you just looking for the latest c2hs sources?
11:06:16 <SamK> Whats a good IDE for messing around with haskell in windows?
11:06:18 <dcoutts> basti_, I can upload them for you
11:06:43 <basti_> dcoutts: xerox is already sending, i think. the problem is only, that the u nsw homepage seems down
11:07:03 <dcoutts> basti_, although xerox has other problems at the moment
11:07:08 <dcoutts> basti_, I'll upload it...
11:07:17 <basti_> :D
11:07:19 <SyntaxNinja> the sysadmin is currently whipping himself, if that helps
11:07:33 <basti_> whats up there?
11:07:49 <xerox> Thanks dcoutts
11:08:06 <dcoutts> basti_, http://www.haskell.org/~duncan/c2hs-0.14.3.tar.gz
11:08:08 <SyntaxNinja> xerox: he's getting your account set up again, but you'll have to put the repo back online
11:08:13 <xerox> SyntaxNinja: argh.  It seems to not recognize my public ssh key too, either.
11:08:22 <SyntaxNinja> xerox: your home directory got blown away
11:08:24 <basti_> thanks
11:08:28 <xerox> SyntaxNinja: cough.
11:08:43 <SyntaxNinja> mine did too, actually :(
11:08:50 <xerox> So bad.
11:08:59 <xerox> Thanks SyntaxNinja.
11:09:14 <SyntaxNinja> do you have backups of everything?
11:09:22 <xerox> I can't login, tough, maybe I have to send the pubkey to him again?
11:09:34 <SyntaxNinja> I know, he's getting you set up. I'll let you know if you need to do anything
11:09:42 <xerox> The important thing, yes, dunno about the rest of the little filse I left up there, but it's ok.
11:09:59 <xerox> *files, even
11:10:02 <SyntaxNinja> that's good.  yay for darcs "every working copy is a repository" 'eh?
11:10:10 <dcoutts> indeed
11:10:12 <xerox> Indeed, my friend.
11:10:46 <dcoutts> an excelent distributed backup system :-)
11:11:14 <pejo> dcoutts, but so was ftp, if we take Linus word for it!
11:11:54 <SyntaxNinja> me and lemmih are going to suffer for this a lot
11:12:02 <dcoutts> pejo, yeah, I guess so :-)
11:12:02 <SyntaxNinja> hackage is a PIA to build
11:12:13 <SyntaxNinja> want to try out cabal-get while you wait?
11:12:34 <dcoutts> SyntaxNinja, we're nearly there with getting hackage in gentoo
11:12:46 <dcoutts> so you'd be able to just emerge hackage
11:12:49 <xerox> I can login again, I'm scp-ing.  It will take a while.
11:12:57 <xerox> Thanks for the support SyntaxNinja!
11:13:00 <xerox> Dinner time :-)
11:13:05 <dcoutts> and it'll compile and install all 17 dependencies :-)
11:13:17 <SyntaxNinja> dcoutts: oh yeah?
11:13:24 <SyntaxNinja> l8r xerox
11:13:42 <SyntaxNinja> dcoutts: why are you putting hackage in gentoo? you mean the server side stuff, or just the clients? have you tried it?
11:13:45 <dcoutts> SyntaxNinja, the joys of package managers and dependency resolution
11:14:08 <SyntaxNinja> dcoutts: sweeeeet
11:14:09 <dcoutts> well we've got almost all the deps now for the clients and the server bits
11:15:34 <dcoutts> we're going to put the client in obviously, like you say, people proably don't need the server
11:16:02 <Lemmih> You got an ebuild for greencard?
11:16:07 <SyntaxNinja> hi Lemmih
11:16:27 <basti_> trying to configure c2hs (./Setup.hs configure), getting *** Exception: Line 20: Unknown field 'hs-source-dirs'
11:16:41 <basti_> tried with different ghc versions
11:16:47 <basti_> with hugs it gives another error message
11:16:54 <SyntaxNinja> which cabal version?
11:17:01 <basti_> how do i find that out?
11:17:04 <SyntaxNinja> hs-source-dir is only > 1.0, I think.
11:17:05 <basti_> i got ghc-6.4
11:17:06 <SyntaxNinja> ghc-pkg -l
11:17:19 <basti_> ah, 1.0, thats the reason k
11:17:20 <SyntaxNinja> that's 1.0; you can use hs-source-dir (multiple dirs is only > 1.0)
11:17:40 <basti_> hmm
11:17:47 <basti_> what would that mean now? :D
11:17:49 <SyntaxNinja> I misspoke just now, hs-source-dirs is there in > 1.0 only; hs-source-dir is always there
11:17:55 * basti_ trying to get a new cabal
11:17:59 <basti_> ah ok
11:18:19 <Lemmih> dcoutts: The cabalization I made for greencard is very dirty. It would be neat if you had something nicer.
11:18:27 * CosmicRay returns
11:18:49 <Igloo> I find "hackage is a PIA to build" amusingly ironic
11:18:50 <psi> yesterday '-package gtk' worked with ghc, but now it can't find the package? what might have changed?
11:19:07 <psi> it's possible that ghc was updated in my recent apt-get upgrade
11:19:08 <SyntaxNinja> Igloo: it is kinda; but once we have hackage, it'll be easier ;)
11:19:14 <SyntaxNinja> Igloo: it's a bootstrap issue
11:19:31 <Igloo> Is hackage the client or server here?
11:19:34 <SyntaxNinja> server
11:19:41 <SyntaxNinja> hackageDB actuall
11:19:44 <Igloo> I thought we already had a server
11:20:12 <SyntaxNinja> Lemmih rewrote it
11:20:44 <Lemmih> You should be able to install all of HackageDB's dependencies in one line with 'cabal-get'.
11:20:45 <Igloo> I thought I prodded his web frontend briefly a few days ago, though?
11:20:54 <lispy> psi: oh, maybe the package isn't registered anymore
11:21:21 <lispy> psi: i'd try reinstalling gtk
11:21:28 <lispy> well, the haskell gtk bindings
11:21:34 <Igloo> psi: If ghc was upgraded to a new upstream version it'll certainly have gone
11:21:38 <dcoutts> basti_, oh you need cabal-1.0.1 or later for c2hs
11:22:40 <dcoutts> Lemmih, we don't have greencard packaged for gentoo at all yet
11:23:03 <pejo> dcoutts, is it messy to create packages in gentoo?
11:23:13 <dcoutts> pejo, not too bad
11:23:17 <xerox> basti_: it needs 1) cabal-1.1.1 2) 2 fixes  to build.
11:23:31 <dcoutts> pejo, especially for cabalised haskell packages :-)
11:23:34 <psi> lispy: can I not re-register it instead, somehow?
11:23:48 <dcoutts> psi, yes you can (unless the version of ghc changed)
11:23:52 <xerox> basti_: sorry I didn't tell you before :-P
11:24:13 <dcoutts> psi, gtk2hs leaves all it's package registration files in its install directory
11:24:15 <Lemmih> It sucks that HackageDB depends on packages which can't be cabalized.
11:24:32 <dcoutts> Lemmih, you mean greencard?
11:24:38 <Lemmih> dcoutts: And hs-plugins.
11:24:45 <dcoutts> oh yes
11:25:41 <psi> dcoutts: ok. how do I do it?
11:25:47 <dcoutts> psi, did you build from source or are you using a .deb or something?
11:25:55 <psi> I built it from source
11:26:03 <SyntaxNinja> Lemmih: why can't you use cabal for gc and hs-plugins?
11:26:24 <dcoutts> then they're under /usr/local/libs/gtk2hs/*.cabal
11:26:43 <dcoutts> use "ghc-pkg register" on each of those files, starting with glib, then gtk
11:27:21 <dcoutts> er, sorry, /usr/local/lib/gtk2hs/*.cabal
11:27:25 <dcoutts> libs/lib
11:27:25 <psi> I don't have any .cabal files there
11:28:11 <dcoutts> psi, found them now? /usr/local/lib/gtk2hs/
11:28:36 <psi> yes, I'm in there, but there aren't any .cabal files there
11:28:52 <dcoutts> hmm, what gtk2hs verion? 0.9.9? or eariler
11:29:26 <psi> 0.9.9. there are a few .package.conf files, though
11:29:36 <Lemmih> SyntaxNinja: hs-plugins has optional dependencies. Cabalizing greencard would be possible with a lot of dirty hacks.
11:29:42 <dcoutts> ok, yes we renamed them all to .package.conf files in 0.9.9
11:29:58 <dcoutts> I was assuming you'd still be using an earlier version
11:30:08 <SyntaxNinja> Lemmih: did you follow simon's optional dependency discussion?
11:30:12 <psi> oh, ok. :) let me try with those...
11:31:08 <dcoutts> SyntaxNinja, the optional dep thing would be nice. Is Simon proposing to implement it?
11:31:11 <Lemmih> SyntaxNinja: Yes, and it sounds great but it's not implemented yet. (:
11:31:45 <SyntaxNinja> dcoutts: yeah, but I think he's busy implementing small humans
11:31:53 <psi> hm. I'm getting 'mismatched interface file versions' now, when I try to compile
11:32:06 <psi> perhaps I do need to reinstall the bindings
11:32:26 <SyntaxNinja> Lemmih: do you think that'll solve the problem>
11:32:32 <lispy> psi: perhaps a 'make distclean' would be a good idea in the gtk source
11:32:35 <Lemmih> SyntaxNinja: Yes.
11:33:12 <SyntaxNinja> Lemmih: cool.
11:33:45 <psi> lispy: yeah, I'll try that. I wanted to avoid compiling, though. It took quite a while last time iirc.
11:34:38 <psi> I found some debian packages, but they were intended for ghc 6.2.
11:36:02 <dcoutts> psi, sounds like you did upgrade ghc
11:36:04 <Lemmih> psi: Sounds like you upgraded GHC. Maybe you still have the old version.
11:36:44 <dcoutts> psi, you can build gtk2hs without optimisations to save time
11:37:04 <dcoutts> make it build in 5 min rather than 30 min on my machine
11:37:43 <dcoutts> psi, ./configure --with-hcflags=-O0
11:38:05 <psi> ok. thanks for the help :)
11:38:17 <psi> I have some television to watch anyway, so I'll do the long compile :)
11:38:42 <basti_> "have to watch tv"
11:40:36 <lispy> basti_: very common among non-geeks
11:40:56 <basti_> oh, so this is like "have to write some obscure code"?
11:41:25 <CosmicRay> more like "found out what changed in plot.hs since last week"
11:41:50 <basti_> :D
11:42:12 <psi> hehe
11:42:15 <SyntaxNinja> hi CosmicRay
11:42:24 <CosmicRay> morning SyntaxNinja
11:42:28 <SyntaxNinja> CosmicRay: did you try cabal-get yet? :)
11:42:42 <CosmicRay> SyntaxNinja: did you know that the threads involving cabal are absolutely the most difficult to summarize for HWN? ;-)
11:42:50 <CosmicRay> hadn't even heard of it!  where do I find?
11:43:08 <lispy> heh, "have some change logs to read"
11:43:29 <lispy> darcs changes | less
11:43:31 <basti_> great, c2hs built and installed. thanks xerox & dcoutts
11:43:45 <Igloo> CosmicRay: Just take the bits where Syn tells people they're being rude. Those are the highlights for me  :-)
11:43:56 <CosmicRay> Igloo: heh
11:44:13 <SyntaxNinja> CosmicRay: http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
11:44:23 <CosmicRay> Igloo: I can see it now.  <b>Cabal.</b>  Isaac Jones told 6 people they were being rude this week, and he was right every time.
11:44:24 <SyntaxNinja> yeah, sorry abut all that.
11:44:41 <Igloo> SyntaxNinja: Please, don't be sorry  :-)
11:45:39 <SyntaxNinja> CosmicRay: let me / us know if you need help summarizing them... I think the basic thrust is that we need to add some kind of support for sandbox-type build systems like gentoo and test deployment systems like the onme f.e. mentioned
11:45:55 <CosmicRay> actually debian is one such build system.
11:46:14 <CosmicRay> see the ugly hackage that I had to use to build hsql (which ships multiple .cabal files) and you'll be motivated to fix it ;-)
11:46:18 <basti_> oh my
11:46:22 <basti_> this green onion is hot
11:46:23 <Igloo> in-place and install will suffice for Debian, though
11:46:25 <basti_> x.x
11:46:26 <CosmicRay> I wound up writing a script named GHC and prepending it to the path ;-)
11:47:04 <CosmicRay> Igloo: mostly, but you also need to be able to point cabal to use an added package file, both for registering and for loading modules
11:47:30 <Igloo> Sorry, yes, and "use inplace stuff"
11:48:33 <xerox> basti_: cool :-)
11:48:38 <lispy> i modified my server to use tail recursion instead of mapM_ and it seems to have fixed my memory leaks
11:48:50 <SyntaxNinja> CosmicRay: well, debian uses chroot, so doesnt' require us to change cabal for most situations.
11:49:14 <SyntaxNinja> CosmicRay: would the hsql problem be solved w/ simon's optional dependencies proposal?
11:49:18 <CosmicRay> SyntaxNinja: no, the package build process on debian does not use chroot
11:49:36 <SyntaxNinja> CosmicRay: you mean the autobuilders don't?
11:49:41 <dcoutts> CosmicRay, what does it use?
11:49:47 <CosmicRay> SyntaxNinja: must have missed that one.  basically, it builds the main HSQL package, then a bunch of per-db packages that depend on that main HSQL package
11:49:49 <SyntaxNinja> CosmicRay: still, many people do use it when they upload their packages.
11:49:52 <CosmicRay> SyntaxNinja: not in any sense that helps you
11:50:08 <SyntaxNinja> gotta get lunch. I'd love to know the details of the problem w/ hsql if youc an email me.
11:50:09 <Igloo> Syn: He means a single dpackages build 2 Haskell libraries, and the 2nd depends on the 1st
11:50:15 <CosmicRay> SyntaxNinja: the autobuilders use chroots to maintain separate installations of Debian (say, woody and sarge).
11:50:50 <dcoutts> We package hsql in multiple ebuilds
11:50:52 <CosmicRay> dcoutts: packages that build on Debian are expected to do so solely under the CWD and are further expected to install into a filesystem tree in a temporary location, also under cwd
11:50:54 <SyntaxNinja> I'll bbiab. let me know if you try out cabal-get and cabal-put
11:51:01 * SyntaxNinja &
11:51:22 <dcoutts> one for each .cabal file, but they share .tar.gz files
11:51:31 <cinema> CosmicRay: in HWN you report the suggestion to use Chameleon as a type debugger. Did you try it ?
11:51:38 <dcoutts> CosmicRay, ok that's just like gentoo
11:51:42 <CosmicRay> cinema: no, I've never heard of it
11:51:50 <CosmicRay> cinema: I just reported what people suggested ;-)
11:52:09 <cinema> I get this message : ERROR:
11:52:10 <dcoutts> CosmicRay, packages build in a temp dir and have read-only access to the rest of the file system
11:52:10 <cinema>     Could not load module `xxx'
11:52:41 <CosmicRay> dcoutts: that is essentially like debian, though ro access is not enforced save by normal user permissions
11:52:45 <Igloo> Module names have to start with a capital letter
11:53:01 <dcoutts> CosmicRay, gentoo uses this "sandbox" thing
11:53:13 <CosmicRay> we also have a program known as "fakeroot" to allow "install" operations that set perms, owners, etc. to succeed without needing to run as root
11:53:19 <cinema> CosmicRay: I think soemone has to develop the functionality (using ghc-src for instance)
11:53:40 <dcoutts> CosmicRay, it enforces the read only access. I think it might be implemented using strace or something similar
11:54:05 <Igloo> dcoutts: Sandboxes make less sense for Debian as the building is done on Debian machines, so doesn't expose users
11:54:15 <dcoutts> Igloo, right
11:54:47 <xerox> CosmicRay: thanks for mentioning my work in the HWN.
11:55:58 <CosmicRay> xerox: the Cairo stuff?
11:56:24 <CosmicRay> xerox: looks cool.  somebody asked me to include it this morning, so I did.  Feel free to send me updates to include in HWN.
11:56:40 <dcoutts> heh heh, yes, that was me :-)
11:56:43 <Igloo> CosmicRay: Do you know anything about sqlite, BTW?
11:56:59 <CosmicRay> Igloo: I happen to have started using it for a project last week.
11:57:03 <CosmicRay> so, some.
11:57:24 <Igloo> Do you know if there's any reason not to use sqlite3?
11:57:53 <CosmicRay> Igloo: from what I've heard, the only reason would be backward compatibility with sqlite2.
11:57:53 <lispy> CosmicRay: which haskell bindings do you use with sqlite?
11:58:08 <CosmicRay> lispy: the new HSQL ones
11:58:09 <luqui_> what might this error mean: undefined reference to `ControlziMonadziState_zdfMonadStates_closure'
11:58:12 <xerox> CosmicRay: will do!
11:58:15 * Igloo is writing from scratch, so cares about that not one iota  :-)
11:58:31 <lispy> CosmicRay: hmm..how new, i just downloaded hsql about a week ago becouse it looks like it works with sqlite
11:58:35 <dcoutts> Lunar^, probably that you're missing a dependency on the mtl package
11:58:38 <Lemmih> luqui_: That you forgot to give GHC the '-package mtl' flag (:
11:58:42 <Igloo> Hmm, I should make my keyboard Greek-friendly
11:58:50 <lispy> CosmicRay: and you need to create the db file external to hsql right?
11:58:53 <CosmicRay> lispy: Yes, it does.  they just now added sqlite3 support.
11:59:09 <luqui_> what's mtl?
11:59:16 <CosmicRay> lispy: no, it will create it on first access if it doesn't exist
11:59:21 <dcoutts> monad template library
11:59:22 <CosmicRay> Igloo: http://www.sqlite.org/version3.html
11:59:26 <lispy> CosmicRay: oh, nice
11:59:29 <xerox> Emacs crashed, GRUMBLE.
11:59:33 <lispy> CosmicRay: thanks
11:59:41 <lispy> xerox: happens a lot if you use gnus
11:59:44 <Igloo> Ta
12:00:06 <xerox> I do not, sob... I think it's due to the IRC client.
12:01:05 <basti_> where do i find the c2hs tutorial, except for the univ nsw homepage, which is broken?
12:01:11 <xerox> basti_: doc/
12:01:47 <basti_> i can't do sgml2html
12:01:51 <basti_> :/
12:02:01 <dcoutts> basti_, google cache?
12:02:01 <luqui_> is there a way I can print data structures prettily (indentified) automatically?
12:02:10 <luqui_> as in "deriving Pretty" or some such?
12:02:11 <xerox> Install linux doc tools or whatever are they called
12:02:12 <basti_> dcoutts: good idea.
12:02:26 <lispy> xerox: which irc client? I haven't had erc crash emacs except when i use fly-spell
12:02:31 <Lemmih> luqui_: You have to write the pretty printer yourself.
12:02:39 <basti_> hah
12:02:42 <xerox> lispy: Circe.  It uses flyspell.
12:02:43 * basti_ kisses dcoutts 
12:02:45 <luqui_> that's too bad
12:03:02 <lispy> xerox: oh hmm...
12:03:15 <lispy> xerox: ive been meaning to try circe
12:03:21 <xerox> basti_: you could get the sgml2html thing by installing linuxdoc-tools
12:04:50 * basti_ smiles
12:05:00 * basti_ likes this way of working
12:05:18 * basti_ needs to make a dpkg worksheet
12:05:52 <CosmicRay> sudo apt-get install gtk-doc-tools sgml2x docbook-utils jade openjade1.3 scons lynx
12:06:09 <CosmicRay> from http://darcs.complete.org/haskell-v8/debianInstall.sh
12:06:15 <CosmicRay> that should give you all of the sgml stuff on debian
12:06:20 <xerox> jade?
12:06:35 <CosmicRay> yeah it is used by the tools to parse the sgml
12:07:59 * basti_ happily installs stuff
12:08:12 <basti_> I see the day coming that my hd goes "urgh!"
12:11:28 <xerox> I should have distcleaned before uploading, zZzZ
12:11:48 <CosmicRay> rafl: new haskell-devscripts with your patch is uploaded.
12:12:31 <dcoutts> xerox, yeah, probably :-)
12:13:32 <rafl> CosmicRay: Thanks.
12:13:59 <rafl> CosmicRay: Maybe you want to sponsor the hsx upload?
12:14:51 <CosmicRay> rafl: sure
12:16:44 <Itkovian> pompom ...
12:19:05 * luqui_ is finally comfortable enough with haskell to write procedurally in it
12:19:11 <luqui_> next step: learn to think functionally :-)
12:21:52 <xerox> luqui_ I think that if you're doing IO in Haskell (knowing what you're doing) you are thinking functionally anyway :-)
12:23:09 <luqui_> eh, sortof
12:23:17 <luqui_> I just implemented a specialized transitive closure
12:23:23 <luqui_> and it uses a State monad with a queue
12:23:25 <luqui_> see what I mean?
12:23:44 <lispy> does it have any memory leaks?
12:24:01 <luqui_> beats me... I'm hardly sure how haskell manages memory
12:24:08 <lispy> that recent thread of haskell-cafe indicated that state monady makes in easy to have memory leakes
12:24:14 <rafl> CosmicRay: Hm. pbuilder says haskell-devscripts is uninstallable.
12:24:32 <CosmicRay> rafl: probably because ghc6 is uninstallable.
12:24:50 <luqui_> lispy: then it probably does
12:25:04 <rafl> CosmicRay: D'oh. the gmp3 transition.
12:25:11 <lispy> luqui_: but that't really disappointing
12:25:22 <luqui_> what is?
12:25:27 <lispy> memory leakes
12:25:29 <lispy> er leaks
12:25:30 <luqui_> yeah
12:25:35 <rafl> CosmicRay: OK, so let's wait until the new ghc version is in sid, OK?
12:25:42 <CosmicRay> rafl: ok.
12:25:44 <luqui_> I mean, why are we writing in a GC'd language if it's going to leak on us
12:25:52 <luqui_> (not that Perl doesn't leak :-)
12:25:54 <Igloo> Which thread?
12:26:06 <lispy> Igloo: dons replied to it most recently, iirc
12:26:17 <CosmicRay> rafl: was part of this whole thing the Haskell XML Toolbox?
12:26:18 <xerox> luqui_: I didn't completely get what you wrote :)
12:26:49 <lispy> Igloo: [Haskell-cafe] Re: Random matrices
12:26:55 <rafl> CosmicRay: No, I need it for hs-plugins which is needed itself for pugs.
12:27:01 <lispy> Igloo: i haven't seen the whole thread tho
12:27:07 <luqui_> 
12:27:08 <lispy> Igloo: so i could be missing something crucial
12:27:24 <lispy> luqui_: hmm...my client can't read that
12:27:27 <xerox> luqui_ err, OK.
12:27:29 <luqui_> nor can mine
12:27:35 <xerox> Mine can :-)
12:27:38 <luqui_> that's what I get for using windows
12:27:48 * Igloo hasn't followed the thread, but if you're actually using the state I don't see why it should be any worse than anything else
12:27:51 <luqui_> it did some weird kanji mode or something
12:28:00 <luqui_> anyway, off to class
12:28:03 <Igloo> If you don't use it you'll probably wanta  state monad that keeps it evaluated strictly
12:31:39 <Oeje1> It's probably been posted here before, but here goes: http://www.denux.org/andrew-youll_osnews/interview_with_tuomo_valkonen.htm
12:32:17 <sieni> Cool, I reserved tickets to Star Wreck: In the Pirkinning party/showing in Helsinki 31st of this month
12:42:05 <greenrd> Philippa: OK, I finally managed to write ListNat in Omega. However, it's pretty useless.
12:43:34 <greenrd> Philippa: You can say ListNat v to leave the values abstract, but that doesn't help me, because I want to write a function which outputs the list in reverse.
12:49:42 <xerox> dcoutts: the repo is back up, hopefully.
12:49:48 <dcoutts> xerox, great
12:50:10 <dcoutts> xerox, the web site still give 403
12:50:25 <dcoutts> "You don't have permission to access /~paolo/darcs/ on this server."
12:53:59 <dcoutts> SyntaxNinja, any chance that you could prod your sys admin guy? (or perhaps he/she is already snowed under)
12:54:27 <Igloo> Are you sure you don't just need to +r the files?
12:54:44 <dcoutts> we think the perms are ok
12:54:49 <basti_> why can't I link c2hs programs that use import System.Posix.DynamicLinker
12:54:50 <xerox> Igloo: files are 664, dirs 755
12:55:15 <dcoutts> basti_, not sure, what's the error?
12:55:26 <basti_> : undefined reference to `__stginit_SystemziPosixziDynamicLinker_'
12:55:58 <dcoutts> and you're using -package plugins ?
12:56:07 <basti_> hmm
12:56:21 <basti_> no :D
12:56:48 <dcoutts> basti_, if you're using --make then it shouldn't be necessary
12:57:14 <dcoutts> if you're doing a manual link step then you need to specify all packages
12:57:45 <basti_> hmm apparently its registered, but it says ghc-6.4: unknown package: plugins-0.9.8
12:58:01 * basti_ .o ( ? )
12:58:56 <dcoutts> basti_, so ghc-pkg list says that plugins is there but ghc doesn't like it?
12:59:17 <basti_> yes
12:59:30 <dcoutts> I'm not sure what's going on then
12:59:52 <basti_> i'm not, too.
13:00:45 * basti_ researching
13:07:09 <basti_> hm, maybe removing cabal 1 wasnt such a good idea
13:09:05 * Beelsebob prods people with sticks
13:09:15 <basti_> ow
13:09:36 <Beelsebob> how goes it?
13:10:18 <basti_> fine
13:10:25 <basti_> hunting down stuff
13:10:35 <Beelsebob> sounds fun
13:10:37 <ndm> @seen shapr
13:10:38 <lambdabot> I saw shapr leaving #haskell 7 hours, 21 minutes and 49 seconds ago.
13:10:57 <Beelsebob> I'm currently sitting around drinking trying to convince myself to stop and do some work
13:11:13 <basti_> don't drink and derive
13:11:21 <jlouis> heh
13:11:26 <jlouis> don't drink 'n code
13:11:38 <Beelsebob> drinking and coding is fine
13:11:47 <Beelsebob> I produce my best code drunk
13:11:56 <basti_> coding while tripping could be fun.
13:12:03 <Lemmih> Just watch out for the syntaxpolice.
13:12:16 <Beelsebob> I've codded while stoned, but not while tripping
13:12:18 <dcoutts> boegel!
13:12:26 <Beelsebob> the results were unimpressive
13:12:29 <dcoutts> boegel|home, ping
13:12:58 <basti_> dcoutts: cabal-1.0 was missing, plugins depends on it.
13:13:03 <Beelsebob> anyway... it would be drinking and coding... it would be drinking and writing
13:13:06 <dcoutts> basti_, ah
13:13:14 <Beelsebob> which would be entertaing for all of you :)
13:13:17 <xerox> basti_: I think it's enough to hide it, and unhide 1.1.1.
13:13:34 <basti_> xerox: got it already
13:14:11 <basti_> with cabal-1.0 exposed. cabal-1.1.2. didnt do the trick
13:14:58 <ndm> Beelsebob, CVS plus alcohol is a success
13:15:05 <Beelsebob> ndm: ?
13:15:17 <Beelsebob> you mean checking in things you shouldn't?
13:15:21 <ndm> if you have your code in CVS, then you can code drunk and stoned without problems
13:15:27 <Beelsebob> or a local CVS so you don't fuck everythig over
13:15:28 <ndm> no, having your code in CVS before you start
13:15:37 <Beelsebob> yeh, okay, that sounds sensible
13:15:40 <ndm> hence not destroying your original work
13:15:47 <ndm> its how i did my first degree
13:15:51 <Beelsebob> that's why I have hat in svn locally, and in the propper cvs
13:16:04 <boegel|home> dcoutts: pong !
13:16:13 <dcoutts> boegel|home, so xerox and I were wondering if you might be interested in helping with a Haskell port of http://www.ozonehouse.com/ContextFree/
13:16:24 <dcoutts> it's quite a similar idea to your L system thingy
13:16:36 <Beelsebob> having a scm system that allowed you to have multiple repositories for the same files would rock
13:16:46 <boegel|home> dcoutts, looks neat
13:16:49 <boegel|home> yeah, it is
13:16:51 <Beelsebob> so you can have your own local one, and the published central one
13:16:54 <dcoutts> but 2D and using circles rather than lines as the graphic primitive
13:17:01 <boegel|home> I guess I could start from some idea's I gathered with that
13:17:08 <Beelsebob> and the ability to transfer change logs between them
13:17:08 <boegel|home> dcoutts, okay, I see
13:17:26 <dcoutts> boegel|home, and implemented using our new cairo bindings! :-)
13:17:28 <boegel|home> dcoutts, in what is it written now ?
13:17:42 <dcoutts> C/C++ I think
13:17:49 <boegel|home> hmm, okay
13:18:02 <dcoutts> but the input text files are simpleish, and the idea is quite simple
13:18:07 <boegel|home> I'm not that familiar with C++, but I know quite a lot of Java, so that should work
13:18:15 <boegel|home> dcoutts, alrighty then
13:18:23 <boegel|home> the only problem is, I don't have time :)
13:18:27 <dcoutts> you probably don't need to look at their code
13:18:34 <dcoutts> :-(
13:18:48 <boegel|home> I'm away for the weekend, and at work there's no way I can make it work, 'cause I have lot's of stuff to do
13:18:58 <dcoutts> maybe we could modify your L system thing
13:19:00 <boegel|home> I can pull it off next weekend though
13:19:05 <boegel|home> dcoutts, maybe you can
13:19:07 <dcoutts> oh, that'd be fine
13:19:25 <boegel|home> that's quite simple, and Itkovian already made a parser for it using Happy
13:19:36 <dcoutts> maybe I should look at your HaskLS code :-)
13:19:36 <boegel|home> dcoutts, the code of HaskLS is _really_ simple (and short)
13:19:41 <boegel|home> dcoutts, you should :)
13:19:42 <dcoutts> ok, cool
13:20:02 <boegel|home> most of the code is involved with the GUI part actually :)
13:20:05 * xerox wants to see too!
13:20:06 <xerox> :-)
13:20:10 <boegel|home> but I seperated it nicely
13:20:14 <dcoutts> we need to make it 2D
13:20:25 <boegel|home> xerox, dcoutts: http://scannedinavian.org/~boegel/HaskLS
13:20:39 <boegel|home> dcoutts, shouldn't be too hard, it even easier than the code I have now :)
13:20:53 <dcoutts> ok, i've got the code, I'll take a look
13:20:56 <boegel|home> I choose 3D to have an extra challenge, but it was quite easy really
13:20:59 <Itkovian> aargh, that parser isn't really finished yet
13:21:15 <boegel|home> Itkovian, oh, it isn't ? no biggy I guess :)
13:21:16 <Itkovian> and it's not in the darcs repos either
13:21:21 * xerox stands up the banner with "pango" written on in big red letters :-P
13:21:23 <boegel|home> they can use the GUI, can't they ?
13:21:28 <Itkovian> boegel|home: I lack time
13:21:37 <boegel|home> Itkovian, so do I mate :)
13:21:40 <dcoutts> boegel|home, you see we're looking for a really nice demo for xerox's new cairo bindings
13:21:50 <xerox> boegel|home: HaskLS is 3D?
13:21:59 <dcoutts> xerox, yes
13:22:01 <Itkovian> it's opengl ;-)
13:22:04 <Beelsebob> it uses GL... it's either
13:22:04 <dcoutts> http://scannedinavian.org/~boegel/HaskLS/gallery.html
13:22:08 <boegel|home> xerox, it is
13:22:26 <Beelsebob> set the projection matrix to orthogonal and you're sorted on 2D
13:22:46 <boegel|home> xerox, shouldn't be too hard to try it out when you have Gtk2Hs installed, there's some default grammar in it I believe
13:22:49 <boegel|home> it's been a while
13:23:46 <boegel|home> Beelsebob, they'd have to throw away some code :) there's only three things you can do in 2D: rotate, move or draw, so it's _really_ simple
13:23:59 <boegel|home> dcoutts, adjusting the code to make it 2D should take 5 minutes or so
13:24:05 <Beelsebob> boegel: you can do anything you like in 2D, you just don't have 2D any more
13:24:26 <dcoutts> boegel|home, for you maybe :-) I need to understand what's going on
13:24:44 <Beelsebob> OpenGL implements 2D as 3D with a projection matrix that ignores Z
13:24:59 <Beelsebob> you can even use the depth buffer in 2D mode to allow you to clip bits out
13:25:33 <boegel|home> dcoutts, I'm not sure I still understand what's going on :)
13:25:46 <boegel|home> dcoutts, I believe I'm using rotation matrices in the code, am i right ?
13:25:49 * boegel|home checks his code
13:25:56 <Beelsebob> i.e. all glVertex2f(1.0, 1.0); does is call glVertex4f(1.0,1.0,0.0,1.0);
13:26:19 <dcoutts> boegel|home, what we really need to generate is a sequence of 2D drawing operations
13:26:37 <dcoutts> following the L-system random grammar thingy
13:26:57 <boegel|home> dcoutts, I see
13:27:09 <dcoutts> so we don't want the GL bits
13:27:15 <boegel|home> shouldn't be a problem, 'cause that's excatly what happens
13:27:23 <boegel|home> dcoutts, aren't those seperated ?
13:27:36 <dcoutts> I'm just trying to figure that out :-)
13:27:54 <boegel|home> all the stuff you need is in LSystem.lhs
13:28:05 <dcoutts> oh, cool, that one is short :-)
13:28:37 <dcoutts> and if possible, it'd be cool to generate values for parameters other that just coordinates (eg we could do alpha values, colour, line thickness etc)
13:28:37 <boegel|home> it is :)
13:28:40 <boegel|home> I told you :)
13:28:55 <Hatchetman> how frustrating to have to revert back 2 revisions and throw away a days work
13:29:21 <boegel|home> dcoutts, you see the 'consts' list ? on top ?
13:29:35 <dcoutts> boegel|home, yes
13:29:54 <boegel|home> those are all the things you need, together with F and G
13:30:07 <dcoutts> so how do we interpret one of the resulting strings?
13:30:13 <dcoutts> *LSystem> result (2,45,"F",[('F',"F+F-F-F+F")])
13:30:13 <dcoutts> "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
13:30:30 <boegel|home> +/- = rotating around X-axis, &/^: rotating around Y-axis, </>: rotating around Z-axis (with given angle)
13:30:50 <boegel|home> F= draw 1 step, G = move 1 step
13:30:53 <dcoutts> ok, nice (so we just remove one axis)
13:31:01 <boegel|home> dcoutts, two :)
13:31:07 <dcoutts> er, yeah
13:31:14 <boegel|home> in 2D you can only rotate left or right , that's it
13:31:31 <boegel|home> so it's _really_ easy
13:31:35 <dcoutts> so F = draw, G = move current drawing position without leaving a line
13:31:41 <boegel|home> dcoutts, right
13:32:02 <dcoutts> and when we rotate, we do so by a random amount?
13:32:19 <dcoutts> at least bounded within something sensible
13:32:22 <goron> I am sorry, but why would F mean draw?
13:32:32 <boegel|home> noj, it works with a given angle
13:32:39 <boegel|home> goron, that's just a given
13:32:50 <boegel|home> dcoutts, but you could adjust that
13:32:57 <dcoutts> oh, so it's a fixed angle
13:32:58 <goron> boegel|home: by who? OpenGL specs?
13:33:16 <boegel|home> goron, hell no, by the guy who created LSystems
13:33:26 <goron> And... what is LSystems?
13:33:27 <SyntaxNinja> xerox: dcoutts: sounds like just a matter of your home dir being non-readable.
13:33:27 <boegel|home> L-systems have _nothing_ to do with OpenGL
13:33:33 * goron is clueless on the subject...
13:33:51 <boegel|home> goron, the technique you use to interpret the resulting string you get
13:33:58 <dcoutts> boegel|home, so what angle did you pick?
13:34:11 <boegel|home> dcoutts, several, see the examples at the bottom of LSystem.lhs
13:34:20 <basti_> :-o
13:34:37 <goron> boegel|home: fractals?
13:34:41 <goron> boegel|home: or URL?
13:35:00 <goron> @where LSystems
13:35:01 <lambdabot> I know nothing about lsystems.
13:35:09 <dcoutts> boegel|home, ah, the second tuple member is the angle?
13:35:25 <boegel|home> dcoutts, yep (hence the 'a' inthe pattern match)
13:35:45 <boegel|home> dcoutts, strange, but it seems like I'm not supporting 'G' yet, I thought I did though
13:36:09 <goron> I guess it's this: http://en.wikipedia.org/wiki/L-system
13:36:12 <dcoutts> boegel|home, G is easy for us it's just Cairo.moveTo rather than Cairo.lineTo
13:36:16 <dcoutts> goron, yes
13:36:18 <boegel|home> dcoutts, you could use some stuff from HaskLS.lhs to interpret the characters
13:36:26 <boegel|home> see the buildVertexList function
13:36:29 <greenrd> Philippa: Never mind. I figured it out.
13:36:31 <goron> dcoutts: ty
13:36:47 <boegel|home> goron, http://haskell.org/hawiki/HaskLS -> lot's of info there
13:36:51 <dcoutts> boegel|home, right ok, thanks very much for the intro, I'll give it a go. :-)
13:37:14 <boegel|home> dcoutts, let me know if you experience any problems
13:37:30 <boegel|home> maybe I'll find a little bit of time tomorrow to build a 2D version of it
13:37:33 <dcoutts> boegel|home, ok. And the first tuple member is the number of iterations?
13:37:47 <goron> Is an L-System Turing Complete?
13:38:22 <boegel|home> goron, err, no , I think you're getting it wrong
13:38:30 <SyntaxNinja> CosmicRay: did you try out cabal-get?
13:38:38 <goron> Wikipedia said it was a formal grammar.
13:38:48 <goron> So it isn't a formal grammar?
13:39:04 <boegel|home> L-Systems isa technique which uses context-free grammars to generate long strings, which says how you interpret the string to build a visual representation
13:39:21 <boegel|home> it is used for generating life-like trees, feathers, ... all kinds of stuff
13:39:34 <goron> The wikipedia page said there are also context-sentive L-systems.
13:39:50 <goron> =>Therefor my question.
13:40:00 <boegel|home> goron, true, but they are more complicated, but the basic idea is the same
13:40:08 <Beelsebob> christ the great C minor is fucking great
13:40:22 <boegel|home> only there it's harder to interpret the strings (more than just single characters)
13:40:25 <dcoutts> boegel|home, actually goron's question is not so odd. An L system is a complex grammer. So it's reasonalbe to ask how complex it really is.
13:41:02 <dcoutts> boegel|home, of course we're just using it for pretty pictures :-)
13:41:03 <boegel|home> dcoutts, well yeah, it is a grammar, but the simple version just uses context-free grammars
13:41:07 <goron>  Ok, so you could extend the idea to a Turing Complete language. (I am not sure of the use..., but still)
13:41:09 <boegel|home> dcoutts, yeah :)
13:41:18 <boegel|home> goron, I guess so :)
13:41:27 <goron> Yeah, it are pretty pictures.
13:41:34 <goron> Biologist are so weird.... ;)
13:41:47 <goron> +s
13:42:19 <goron> It's a cool idea.
13:43:31 <Beelsebob> hmm, some, certainly
13:43:46 <boegel|home> goron, I'm not a biologist :)
13:44:08 <goron> boegel|home: I know.
13:44:19 <goron> Well, actually I didn't.
13:44:25 <goron> It was just very unlikely.
13:44:33 <boegel|home> goron: :D
13:44:34 <Beelsebob> I don't count my sister as weird, except that she keeps asking me questions about how to write things, but wont read an algorithms, data structures and complexity theory book
13:45:05 * basti_ gets ever better. He now managed to make his dynamic lib/c2hs/stuff thingy sefault.
13:45:24 <goron> c, huh? Figures...
13:45:27 * Beelsebob pops basti's big head
13:45:33 <Beelsebob> *g*
13:45:55 <basti_> no i mean, i like runtime errors better than compiler errors
13:46:03 <boegel|home> dcoutts: let me know if you have any progress... you can mail me at work if you want to reach me fast
13:46:08 * xerox arghs
13:46:11 <basti_> its impressive that it even compiles
13:46:11 <goron> what is the *g* smiley?
13:46:16 <Beelsebob> oh... segfault... not default?
13:46:22 <dcoutts> boegel|home, ok
13:46:23 <Beelsebob> I read your typo wrong
13:46:39 <basti_> ahhh
13:46:42 <basti_> yes segfault
13:46:53 <dcoutts> boegel|home, what's you're interpretation of '[' ']' ?
13:46:54 <Beelsebob> ... not that s and d are anywhere near each other... but hey
13:47:09 * basti_ nods
13:47:27 <dcoutts> boegel|home, I see you say "start new branch" "end last branch", but what does the become in your results?
13:47:41 <goron> Beelsebob:  what is the *g* smiley?
13:47:47 <Beelsebob> *grin*
13:47:53 <goron> ah, thanks.
13:48:14 <Beelsebob> hangover form typing *does something* in AIM
13:48:22 <Beelsebob> ... Adium supports /me anyway now
13:48:33 <goron> @= <=best smiley ever
13:48:34 <lambdabot> Maybe you meant: pl wn
13:48:42 <boegel|home> dcoutts: that's just for drawing the branches of a three... at end last branch you return to the position where the last branch started, and draw on from there
13:48:43 <Beelsebob> lol
13:48:51 <goron> "User is pro-nuclear war"
13:48:58 <Beelsebob> haha
13:49:02 <dcoutts> boegel|home, ah right, ok, so I need a stack of positions...
13:49:08 <boegel|home> dcoutts: yeah
13:49:09 <Beelsebob> or just likes magic mushrooms
13:49:22 <Beelsebob> I guess that would xbe (= actually
13:51:01 <boegel|home> dcoutts: in HaskLS.lhs, in the buildVertexList function, s = start position, d = direction
13:51:24 <basti_> magic mushrooms look like {- rather
13:51:33 <boegel|home> every time I detect a nesw branch, I put the current point and direction on stack (using 2 lists)
13:51:47 <Beelsebob> heh, yeh, that's getting close
13:51:52 <Beelsebob> maybe even {~
13:51:55 <boegel|home> at the end of a branch, I just restore the first entry
13:51:57 <basti_> http://www.cannabisculture.com/library/images/uploads/3056-Psilocybe-Semilanceata-2.jpg < at least the ones that gro in europe
13:51:58 <dcoutts> boegel|home, right, one for direction, one for position
13:52:04 <basti_> {------ maybe...
13:52:14 <Beelsebob> not usually that long
13:52:15 <boegel|home> dcoutts: yep :)
13:52:28 <basti_> how can i make a storage size known?
13:52:44 <dcoutts> boegel|home, oh, I might be able to cheat by using cairo's save/restore :-) so long as the []'s nest correctly
13:52:55 <yeti_> oh... listening to the conversation, i get the impression that you need to take drugs to be good at haskell? that moght be my problem :>
13:52:57 * Beelsebob rofls at count sodocu
13:53:19 <Heffalump> lol
13:53:20 <boegel|home> dcoutts: dunno, maybe, I don't knowhow cairo works :)
13:53:21 <basti_> yeti_: not necissairily
13:53:31 <boegel|home> anyway, I'm off
13:53:40 <yeti_> basti_: drugs don't seem to help spelling though, eh :> ?
13:53:47 <dcoutts> ok, thanks boegel
13:54:07 <boegel|home> dcoutts: if you have any problems, feel free to mail me at the adress you can find on the HaskLS website, I'll be sure to answer it first thing in the morning
13:56:32 <basti_> yeti_: not in english no.
13:57:01 <dcoutts> boegel|home, ok great thanks
13:57:09 <dcoutts> boegel|home, I've got the first output :-)
13:57:17 <dcoutts> it's a small curved line :-)
13:57:36 <basti_> :D
14:03:21 * xerox hugs boegel
14:03:42 <dcoutts> http://www.haskell.org/~duncan/cairo/lsystem-demo/
14:04:02 <dcoutts> first cut, no impressive graphics yet
14:04:05 <xerox> So nice!
14:07:53 <Itkovian> night
14:09:55 <Beelsebob> tum tee tum, I love the iTMS
14:18:25 <lispy> dcoutts: why do you use both literate haskell and -- style comments in the literate sections.  That seems like a lot of extra stuff to have to type
14:18:31 <boegel|home> dcoutts: see, that wasn't so hard :p
14:18:49 <boegel|home> glad you're already getting results :)
14:19:04 <boegel|home> I'm off to bed now, dreaming of xerox hugging me :) night !
14:19:20 <dcoutts> lispy, in LSystem.lhs you mean? it's boegel's module, ask him :-)
14:19:35 <dcoutts> boegel|home, thanks and g'night
14:19:40 <xerox> Goodnight boegel|home!  Thanks for the good code :)
14:20:11 <boegel|home> lispy: dunno, seems nicer :) feel free to change it :)
14:20:14 <boegel|home> *off
14:20:54 <Beelsebob> @seen Spherical`
14:20:55 <lambdabot> I saw Spherical` leaving #haskell 20 days, 20 hours, 37 minutes and
14:20:55 <lambdabot> 58 seconds ago, and I have missed 9 days, 9 hours, 6 minutes and 30
14:20:55 <lambdabot> seconds since then.
14:21:05 <Beelsebob> what????
14:21:31 <Beelsebob> is it possible to find out *when* lambdabot's missed?
14:22:44 <goron> In a quantum world? No :P
14:23:11 * Beelsebob doesn't see what quantom physics has to do with it
14:23:20 <Beelsebob> that's small scale... lambdabot's big
14:24:18 <goron> The real question is: what is lamdbabot?
14:24:41 <Beelsebob> A giant japanese fighting robot of course
14:24:46 <yeti_> how do you write your .hs files? just press space twice? or do you use some kind of tab magic?
14:24:57 <TheHunter> lambdabot isn
14:25:07 <basti_> is he 1 attometer large and works in picosecond scales?
14:25:11 <_metaperl> yeti_: xemacs allows me to use tab..
14:25:17 <TheHunter> ...'t missing that much. It's just a bug in @seen that i haven't tracked down yet
14:25:33 <yeti_> _metaperl: does it autoconvert tab to spaces?
14:25:44 * Beelsebob wonders where the hell spherical came from then
14:25:57 <_metaperl> yeti_: I think so...
14:26:15 <yeti_> does anyone know by accident whether vim can do that, too ;) ?
14:26:24 <Beelsebob> he p/med me about UKC, and I can't find him in any of my other channels
14:26:32 <Beelsebob> so I guess this is where he appeared from
14:26:52 <Beelsebob> yeti: do what?
14:26:59 <yeti_> autoconvert tabs to spaces
14:27:09 <yeti_> i read haskell doesn't like tabs?
14:27:11 <Beelsebob> almost every text editor on the planet can
14:27:28 <Beelsebob> most will convert it to a different number of spaces depending on the language
14:28:07 <Beelsebob> SEE usefully will convert your first tab to the current indent level, and your next to two spaces
14:28:09 <basti_> I don't think it breaks though
14:28:20 <Beelsebob> basti: it does
14:28:26 * basti_ ties
14:28:30 <basti_> my
14:28:42 <Beelsebob> if you write something with tabs and spaces and tab width set to 4
14:28:47 <basti_> yes
14:28:57 <Beelsebob> and then Haskell assumes something other than 4
14:28:57 <basti_> but not if the tab width is 8
14:29:00 <Beelsebob> it all goes wrong
14:29:03 <basti_> like, everywhere.
14:29:04 <basti_> ;)
14:29:06 <TheHunter> wow, people actually think the problem I found yesterday is the fault of newtype-deriving.
14:29:17 <Beelsebob> no... tab width is 4 or 2 in most places
14:29:23 <basti_> k
14:29:33 <basti_> yes, he SHOULD be using spaces
14:29:42 <Beelsebob> but the assumption of how wide a tab is cocks op the parser
14:29:53 <basti_> yeti_: what editor are you using?
14:30:01 <yeti_> vim
14:30:16 <Igloo> If you use tabs in Haskell code then the whitespacemonster will eat you while you're sleeping. Don't do it.
14:30:17 <yeti_> found it though, it's the 'expandtab' option i think :)
14:30:38 <mwc> yeti_, it is expandtab
14:31:00 <lispy> yi didn't even support tabs until recently
14:31:02 <mwc> and then tabstop is the option for how many spaces you want a tab to be, I think it's 8 by default
14:31:07 <lispy> that's how evil they are :)
14:31:20 <Beelsebob> lispy: that's not evil... it's good
14:31:31 <Beelsebob> stops the horrible confusion ensuing
14:31:44 <lispy> Beelsebob: tabs are good?  because tabs are what i was calling evil...
14:31:59 <mwc> I've always thought that a grey harline under the tabbed space, would solve EVERYTHING
14:31:59 <basti_> :D
14:32:05 <Beelsebob> oh, okay, I thought you said yi devs were evil for not supporting them
14:32:14 <mwc> not to mention all the other no-prints displayed
14:32:29 <mwc> "Is that break a hard break or just a wrap"
14:32:31 <lispy> mwc: i have emacs cursor set to expand to the size of the tabs when it's over them
14:32:57 <lispy> mwc: helps a lot in makefile debugging
14:33:13 <Beelsebob> I just have a grep set up to strip out tabs
14:33:19 <goron> Can I access Excel and Access from Haskell?
14:33:26 <goron> (without too much hassle?)
14:33:34 <lispy> but, to be honest, i absolutely hate layout rules whether it's haskell or make, or whatever.  I hate sending time trying to get code to compile when it's perfectly valid.
14:33:35 <Beelsebob> goron: export csv and parse it?
14:33:48 <mwc> Sure, write to SPJ, and ask him to propose VisualHaskell for Applications :P
14:34:00 <greenrd> Can anyone recommend tools for debugging bogus infinite loops (in someone else's code)?
14:34:07 <goron> Beelsebob: hmm, now, that's actually a simple idea. :)
14:34:16 <Heffalump> greenrd: what language?
14:34:20 <goron> mwc: I will do that next time.. ok?
14:34:21 <greenrd> haskell
14:34:35 <Beelsebob> greenrd: black-hat
14:34:53 <lispy> goron: not sure hat csv will hold up when you use Access
14:34:56 <Beelsebob> (black hole detection)
14:35:02 <lispy> goron: does access support sql at all?
14:35:15 <lispy> goron: if so, you might be able to adapt hsql
14:35:38 <goron> lispy: Yes, no mega advanced things, but yes it does.
14:35:46 <goron> SELECT/UPDATE etc.
14:35:54 <goron> I don't think it will do nested queries.
14:36:19 <lispy> in fact, adapting hsql to do that would help make htoolkit a replacement for VB
14:36:34 * goron already have some VB6 experience with Access and Excel
14:36:38 <goron> er has
14:36:59 <lispy> not that writing desktop applications is popular anymore.  These days you want to develop a framework that allows ajax without doing anything webcentric
14:37:22 <goron> I don't understand why people don't just use an xserver....
14:37:40 <goron> That works pretty good on a fast network...
14:37:47 <yeti_> why doesn't Data.Set have an instance for (Show (Set a)) :( ?
14:37:59 <goron> And most likely there are still some optimizations left...
14:38:07 <Heffalump> yeti_: you can write one trivially
14:38:15 <yeti_> ah yeah
14:38:16 <lispy> goron: xserver?
14:38:21 <lispy> goron: like X11?
14:38:24 <goron> Is the X protocol implemented asynchronously?
14:38:25 <Heffalump> instance Show a => Show (Set a) where show s = show (setToList s)
14:38:27 <goron> lispy: yes
14:38:29 <yeti_> Heffalump: now as you mention it, d'oh :)
14:38:33 <yeti_> Heffalump: thanks!
14:38:38 <Heffalump> I find myself doing that a lot
14:38:47 <TheHunter> of course, there are problems with that.
14:38:48 <lispy> goron: not everyone has a network that will handle the bandwidth if everyone wanted to start doing that
14:38:53 <Heffalump> occasionally I tart it up by post-processing the string to change [ ] to { }
14:39:08 <goron> lispy: ssh -X works great for >=ADSL.
14:39:27 <lispy> goron: i've used it, yeah.
14:39:33 <lispy> but rdesktop does even better
14:39:46 <TheHunter> you can't show a set in a module that imports two modules that define their own Show instance.
14:39:48 <goron> lispy: I think I saw that one once.
14:39:57 <goron> lispy: I would guess so.
14:40:12 <lispy> goron: but what we really want is rpc
14:40:17 <goron> lispy: I don't really care about the specific X server, more like the idea...
14:40:18 <greenrd> goron: FreeNX is the best
14:40:22 <lispy> goron: except, implemented as web apis
14:40:38 <lispy> greenrd: i had a lot of problems with FreeNX
14:40:38 <goron> lispy: Like implemented in browsers..
14:40:44 <goron> lispy: ?
14:40:48 <lispy> goron: nah, forget the browser, i hate them
14:41:00 <lispy> goron: but....using a lot of the current browser technology
14:41:16 <goron> lispy: So, people start a different application for every application?
14:41:24 <lispy> goron: one problem with the browser is that we want an application platform, but the browser is a document platform
14:41:35 <goron> That sentence stank :(
14:41:51 <lispy> goron: no, but you could build an application platform that uses similar technologies as web browsers.
14:42:05 <goron> lispy: I like your idea.
14:42:12 <goron> lispy: "your"
14:42:16 <lispy> heh
14:42:20 <goron> There's no way you are the first.
14:42:26 <lispy> indeed
14:42:33 <lispy> i'm sure MS has been wanting .NET to do this
14:42:39 <goron> "Nobody is first" - I don't know who said that.
14:43:19 <nekoreppie> watashi wa neko desu! =^_^=
14:43:28 <lispy> heh
14:43:37 <lispy> you are a cat?
14:43:37 <goron> eh?
14:43:52 <nekoreppie> hai!
14:44:03 <lispy> meow!
14:44:09 <goron> @mow
14:44:10 <lambdabot> Maybe you meant: moo yow
14:44:12 <nekoreppie> nya
14:44:14 <goron> @moo
14:44:38 <goron> lambdabot was dead, I forgot.
14:44:49 <goron> uh I mean asleep..
14:45:11 <xerox> No, @moo is disabled by peer pressure
14:45:12 <lispy> @yow
14:45:13 <lambdabot> I believe in wash fulfillment.
14:45:37 <lispy> yeah, @moo was getting "abused" (I say this as one of the abusers)
14:45:52 <xerox> Hiya poetix!
14:46:00 <poetix> Nearly as fast as shapr...
14:46:10 <lispy> heh
14:46:29 <nekoreppie> xerox i thought you went to bed nyaaa~
14:46:31 * xerox press the "How's code?" button
14:46:49 <poetix> I swear he must be using one of those avant-garde keyboards
14:46:58 <xerox> Kinesis ergo!
14:47:11 <xerox> @google kinesis ergo contoured keyboard
14:47:12 <lambdabot> http://www.kinesis-ergo.com/contoured.htm
14:47:21 <poetix> I guess it wouldn't be that hard to rig up an IRC client with a "say hi to the person who just entered" hotkey
14:47:31 <xerox> I think I'll get one with Google's money.
14:47:40 <poetix> Or just get it to do it automatically.
14:47:49 <nekoreppie> @ghc
14:47:50 <lambdabot>  Empty record update
14:47:52 <poetix> But then it'd by like an episode of Neighbours:
14:47:57 <poetix> g'day Bruce
14:48:02 <poetix> g'day Marleen
14:48:10 <poetix> g'day Kylie
14:48:12 <poetix> etc.
14:48:13 <xerox> This reminds me of Erlang - The Movie...
14:48:25 <lispy> the movie?
14:48:26 <nekoreppie> xerox what's teh code you use to generate the 1.png?
14:48:27 <poetix> @google Erlang - The Movie
14:48:29 <lambdabot> http://lambda-the-ultimate.org/node/view/197
14:48:45 <basti_> "teh"?
14:48:50 <nekoreppie> xerox hs + teh other thing, nyaa~
14:48:54 <xerox> nekoreppie: PRIV!
14:48:57 <xerox> ;)
14:49:07 <nekoreppie> teh!
14:49:09 <poetix> questionablecontent.net t-shirt slogan
14:49:20 <nekoreppie> u mean the code is private, nya~ ?
14:49:42 <xerox> nekoreppie: there is no code, you're the one benting
14:49:51 <nekoreppie> ah ok
14:50:00 <nekoreppie> but is there a summer of code?
14:50:07 <xerox> So it seems!
14:50:27 <poetix> I can't believe I'm downloading the torrent of Erlang - The Movie
14:50:39 <nekoreppie> poetix where is it?
14:50:52 <poetix> See LtU article reference above
14:50:59 * xerox wants it too
14:51:07 <nekoreppie> wait
14:51:12 <SyntaxNinja> xerox: are things pretty cleared up?
14:51:13 <nekoreppie> is it the one with robert and the other guys?
14:51:20 <nekoreppie> calling each other in the phones?
14:51:26 <xerox> SyntaxNinja: I think so, thanks.
14:51:33 <xerox> nekoreppie: YES!
14:51:37 <nekoreppie> lol.
14:51:38 <xerox> Hello Robert!
14:51:40 <xerox> Hello Mike!
14:51:49 <xerox> Hello {Joe,John,IDR}
14:51:54 <nekoreppie> it's a great movie
14:52:01 <nekoreppie> i highly recommend it.
14:52:03 <poetix> "When I make "The (Rocky Horror) Arrow Film", I will be sure to hire only hot gothic succubi in PVC and lace to parade impishly in front of the camera, swish their cat-o'-nine-tails to and fro suggestively, and make lewd and profane advances to the camera (behind which, of course, you will find me). I believe this would be about as relevant and informative as these films were, and rather...
14:52:04 <poetix> ...more enjoyable." - Frank Atanassow
14:52:11 <poetix> I'd pay to see that.
14:52:28 <poetix> Even if I had to listen to the hot gothic succubi talking about Arrows for half an hour.
14:52:48 <Defiler> Erland - The Movie is totally awesome.
14:52:52 <SyntaxNinja> xerox: cool. sorry about all that. let me know if there's anything I can do.
14:52:55 <xerox> Defiler: agreed.
14:53:17 <xerox> SyntaxNinja: will do.  Thank you for your support, it was a bit disappointing at first, but with darcs it was recovered well.
14:53:38 * basti_ does so much gymnastics lately that his muscles get sore
14:53:44 <SyntaxNinja> xerox: good.  yeah, he felt really bad.  thing is, he forgot that the machine was being used for non cvs.haskell.org purposes.
14:54:01 <xerox> Ouch :-)
14:54:19 <poetix> Dammit, the torrent's not working
14:54:20 * Heffalump looks confused
14:54:22 <SyntaxNinja> the minute you said something, he was on his way over here.
14:55:01 <xerox> Tell him that it's OK for me, it recovered well - no problem.
14:55:25 <lispy> someone dismantled a server you were using?
14:55:26 <lispy> by mistake?
14:55:41 <nekoreppie> i hear darcs doesn't scale well to large projects :(
14:55:47 <xerox> It happens.
14:56:06 <xerox> nekoreppie: these days Gtk2Hs is trying to move to darcs, we'll see!
14:56:14 <lispy> nekoreppie: depends what you mena by scaling, but in general, yes
14:56:28 <nekoreppie> lispy large source tree
14:56:36 <greenrd> nekoreppie: darcs is written in Haskell and contains code which sometimes will take longer than the age of the universe to complete. Of course it doesn't scale.
14:56:38 <Defiler> poetix: I'm looking for the file.. If I can find it, I'll put it up.
14:56:47 <poetix> Defiler: cool
14:56:53 <Igloo> I don't think source size should be a huge problem, for darcs 1.0.4 at least
14:57:01 <Defiler> I hope I haven't deleted it.
14:57:02 <lispy> nekoreppie: if you have a developers sending in a lot of patches to the same files you can run into conflits.  But my home dir is in darcs, 600mb of my homedir that is.
14:57:06 <greenrd> nekoreppie: Try it on linux kernel source code, as a test.
14:57:19 <poetix> greenrd: That's a totally evil suggestion
14:57:27 <greenrd> poetix: Which?
14:57:36 <poetix> Using darcs on the linux source tree
14:57:40 <nekoreppie> i'm presonally interested on using it to maintain my freebsd patches :P
14:57:41 <greenrd> Well.
14:57:44 <poetix> Won't somebody think of the boxen?
14:57:48 <nekoreppie> s/on/in/
14:57:49 <greenrd> It should work, if it's a grown-up source code control system.
14:58:12 <xerox> nekoreppie: you will never experience scaling problem in maintaining your set of patches :)
14:58:24 <nekoreppie> xerox oh, i will
14:58:31 <nekoreppie> because i need the whole freebsd tree
14:58:41 <greenrd> haha
14:58:43 <lispy> how big is the tree?
14:58:50 <nekoreppie> around 400MB iirc
14:58:55 <greenrd> haha
14:58:56 <nekoreppie> 70k files
14:59:01 <greenrd> don't bother then
14:59:02 <poetix> I will happily use darcs for all my home-grown toy projects, but would approach something that big with major trepidation
14:59:02 <xerox> Ouch!  I thought you wanted to have only the patches itself under darcs.
14:59:05 <nekoreppie> again, iirc.
14:59:21 <lispy> no problem unless you have 1) really large patches (becareful when you import) or patches that conflict.
14:59:40 <nekoreppie> xerox lol no. i need something to make sure that the patches still apply after stuff changes in the cvs
14:59:58 <greenrd> lispy: Have you actually _tried_ darcs on a ~400mb tree?
15:00:22 <lispy> greenrd: yes, see my previous comment about uing it on my 600mb homedir
15:00:37 <nekoreppie> lispy but how many files?
15:00:40 <lispy> greenrd: i've been doing that for 7-8 months now
15:00:50 <lispy> nekoreppie: lots
15:01:00 <lispy> but that shouldn't matter
15:01:20 <nekoreppie> anyway, arch, for example totally sucked
15:01:36 <Defiler> Awesome. I found my copy of "erlang_the_movie"
15:01:47 <poetix> w00t
15:02:37 <lispy> $ find . | wc -l
15:02:37 <lispy> 1566
15:03:05 <xerox> lispy: you're not using h4sh! <blink>
15:03:10 <lispy> there are a few darcs operations i need to watch out for as they cause darcs to parse really huge patches
15:03:40 <lispy> xerox: not on this machine, and it would take me longer to think of the h4sh command to do that
15:03:49 <xerox> ;)
15:03:55 <lispy> fined . | length ?
15:03:56 <Defiler> poetix: Here's the torrent URL: http://tinyurl.com/dxbpp
15:03:58 <lispy> er find
15:04:04 <poetix> Defiler: thanx
15:06:36 <lispy> where is the freebsd kernel source?
15:06:47 <goron> /usr/src
15:07:06 <Beelsebob> really?
15:07:09 <Cale> dons: I can't connect to http://www.cse.unsw.edu.au/ -- is it down?
15:07:16 <Beelsebob> the OS X kernel is in /
15:07:27 <lispy> goron: but i'm not running freebsd
15:07:28 <Beelsebob> but then that's only freeBSD userland isn't it?
15:07:31 <goron> Beelsebob: that was sarcastic?
15:07:33 <lispy> i just want to run darcs on it
15:07:42 <goron> Beelsebob: no
15:07:56 <Beelsebob> goron: it's a mach kernel
15:08:09 <Beelsebob> or... a heavily modified one
15:08:26 <goron> Beelsebob: I didn't make any claim about Mac OSX
15:08:36 <Beelsebob> oh, okay
15:08:41 <Beelsebob> what was the no to?
15:08:48 <goron> but then that's only freeBSD userland isn't it?
15:09:01 <goron> That's something you said, if my IRC works, correctly..
15:09:07 <Beelsebob> goron: yeh, I meant OS X is only FreeBSD userland
15:09:27 <goron> Beelsebob: But we were *not* talking about OS X.
15:09:34 <goron> Or was lispy?
15:09:52 <Beelsebob> I know... I was trying to say something slightly related that might hint at the answer
15:09:59 <lispy> i'll just try it out on the linux source
15:10:00 <goron> Oh, no need for hints.
15:10:06 <goron> lispy: noooohhh
15:10:23 <nekoreppie> os x sucks.
15:10:23 <lispy> well, at least i can find that
15:10:38 <goron> lispy: You can get the FreeBSD source via cvs.
15:10:41 * Beelsebob slays nokoreppie until he backs himself up
15:10:46 * lispy prepares for a flame war
15:10:54 <lispy> goron: from where?
15:11:01 * Beelsebob might create osxflamewars
15:11:09 <goron> lispy: You know what? I will help you ;)
15:11:09 <Beelsebob> (#osxflamewars that is)
15:11:23 <Beelsebob> hehe... just did :)
15:11:37 <lispy> goron: i tried google
15:12:02 <lispy> ah, you have to add "cvs" to the google search
15:13:08 <goron> Good thinking [/sarcasm]
15:13:16 <lispy> actually i still don't see how to get just the kernel
15:13:46 <goron> FreeBSD is a complete system with userland.
15:14:13 <goron> You would have to decide for yourself what you consider the "kernel".
15:14:14 <Beelsebob> goron: doesn't mean you can't have just the kernel from it
15:14:21 <Beelsebob> ... or for that matter, just the userland
15:14:26 <goron> Beelsebob: Again, I didn't say that.
15:14:30 <Heffalump> I thought FreeBSD was a Linux distribution
15:14:37 <lispy> hehe
15:14:39 <goron> Heffalump: flaming, heh?
15:14:44 <Beelsebob> heffalump: good flame
15:14:51 <lispy> dealing with freebsd is a pain
15:14:51 <Beelsebob> shall I make it unixflamewars instead?
15:14:55 <lispy> i'll just try it on the linux source
15:14:59 <lispy> at least i can find that
15:15:07 <goron> lispy: lazy bitch! :P
15:15:15 <Heffalump> I think you'll find I'm trolling, not flaming. Pay attention.
15:15:33 <lispy> Heffalump: the irony of your last statement....
15:15:43 <goron> Heffalump: Tell me your definition of both concepts...
15:16:11 <Heffalump> trolling is saying something controversial just to generate a reaction
15:16:25 <Heffalump> flaming is insulting something using unnecessarily provocative language
15:16:26 <poetix> Flaming is attacking someone for something they just said
15:16:31 <poetix> Or what you think they just said
15:16:31 <lispy> a troll starts something (whether or not the individial knows they are a troll is debatable) a flame is a comment that is really pointed and pointless.
15:16:48 <goron> Oh, ok.
15:16:49 <poetix> Or what you assert they just said, totally oblivious to what they *actually* said
15:16:55 <goron> Like Haskell STINKS!
15:17:08 <dcoutts> have I missed some flaming? (or was it trolling)
15:17:13 <poetix> I can't believe Heffalump is actually making excuses for CANNIBALISM!
15:17:29 <goron> Heffalump: you are so dumb. Please leave!
15:17:38 <Heffalump> I should try to give the impression of being more ignorant, then my troll might actually have worked.
15:17:45 <goron> Who needs a computer anyway!
15:17:47 <poetix> I'm sick of these CANNIBAL SYMPATHIZERS polluting #haskell with their repugnant views!
15:17:48 <lispy> lispy: you're an idiot, go home!
15:17:57 <Beelsebob> goron: I hate you and your mum's a male wife beating lesbian canibal black
15:18:15 <goron> You Americans get horse fucked to death all day!
15:18:18 <dcoutts> Heffalump, yeah, you can't really troll when we know you. Come back under another nick and it might work.
15:18:26 <Beelsebob> lol
15:18:42 <lispy> Thanks for playing. Please try again.
15:19:14 <goron> You are all a bunch of academics and can't get a REAL job!
15:19:25 * Heffalump has a real job :-p
15:19:36 * Beelsebob has a real job
15:19:38 <Heffalump> I even use Haskell in it
15:19:42 <Beelsebob> http://haskell.org/hawiki/QuotesPage?action=show
15:20:00 <goron> Flaming/trolling is no fun in here...
15:20:10 * Beelsebob sets fire to goron
15:20:14 <goron> But I know some channels in which it is :)
15:20:23 <Beelsebob> osxflamewars?
15:20:33 <goron> I nuke them allday @=
15:20:39 <poetix> Hey, I got accused of FUD on #twisted earlier...
15:20:39 <Beelsebob> hahahaha
15:20:58 <Beelsebob> about what?
15:21:21 <poetix> http://codepoetics.com/poetix/index.php?p=141
15:21:41 <poetix> "Everything those guys say about threads is wrong..."
15:21:53 <poetix> Well, I guess that is kind of asking for it...
15:22:15 <goron> Well, they are RIGHT!
15:22:56 <xerox> You got me engaged in flames all they long :P
15:23:07 <poetix> But Glyph was fairly polite. I actually do think Twisted is quite cool. Just that they're fighting the wrong battle.
15:23:48 <jlouis> oh, I have a real job too
15:24:01 * poetix pretends to go to work
15:25:43 <lispy> who is this wadler chracter, and why does his name keep popping up attached to interesting thingcs...
15:26:02 <lispy> "So, the essence of XML is this: the problem it solves is not hard, and
15:26:04 <lispy> it does not solve the problem well." -- Jerome Simeon & Phil Wadler
15:26:10 <lispy> i love that quote
15:26:20 <Heffalump> lispy: you really don't know who Wadler is?
15:26:33 <poetix> That is such a cool XML quote.
15:26:46 <poetix> That is what Dijkstra would have said about XML, if he'd lived to see it.
15:27:10 <Heffalump> Dijkstra did live to see it..
15:27:25 <Heffalump> he only died a couple of years ago, which is much less time than it's been around
15:27:32 <Beelsebob> UML is about 10000 times worse than xml thought
15:27:34 <Beelsebob> though*
15:27:39 <_metaperl> if he saw Scheme s-expressions, he saw XML
15:27:43 <Beelsebob> at least xml has a nice rigid definition
15:27:50 <Beelsebob> uml can mean anything you tell us it means
15:27:53 <_metaperl> except that XML has much more... I'm wrong when I say that
15:28:02 <_metaperl> lispy: where did Wadler say that?
15:29:10 <Heffalump> in a talk about a paper with that title
15:29:14 <poetix> @google "and it does not solve the problem well"
15:29:17 <lambdabot> http://maht.dotgeek.org/fortunes.html
15:29:19 <lispy> _metaperl: i don't know the source
15:29:34 <lispy> _metaperl: i found it on the quotespage
15:29:37 <lispy> @wiki quotespage
15:29:38 <lambdabot> http://www.haskell.org/hawiki/quotespage
15:30:07 <Heffalump> google suggests POPL 03
15:30:09 <poetix> http://xml.coverpages.org/Simeon-Wadler-EssenceOfXML.pdf
15:30:40 <poetix> The horror that is XML Schema...!
15:31:46 <lispy> Heffalump: why should I know who Wadler is?
15:31:53 <poetix> What's Eric Meijer up to nowadays?
15:31:55 <Heffalump> lispy: he's kind of famous in the Haskell world
15:31:57 <xerox> !!!
15:32:00 <Heffalump> poetix: still working for M$, afaik
15:32:09 <Heffalump> not sure what he's been doing lately
15:32:16 <_metaperl> lispy: he developed Monads
15:32:37 <Heffalump> he popularised their use as a way to structure functional programs, to be precise
15:33:13 <poetix> He's the bridge between Moggi and actual Haskell usage.
15:33:13 <lispy> ah
15:33:43 <Heffalump> he also came up with the idea of deforestation
15:34:27 <Heffalump> and "Theorems for Free"
15:34:58 <Heffalump> oh, and he seems to have invented type classes.
15:35:18 <lispy> deforestation?
15:35:23 <lispy> theorems for free?
15:35:29 <lispy> man...i'm going to have to learn stuff
15:35:46 <jlouis> deforestation is a nice nice optimization for lazy pure functional languages
15:36:01 <jlouis> the ''free theorem'' is basicly what says when deforestation applies
15:36:13 <Heffalump> have you read John Hughes' paper "Why functional programming matters"?
15:36:22 <Heffalump> jlouis: deforestation is based on a free theorem? Really?
15:36:23 <poetix> @google wadler deforestation
15:36:24 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/deforestation.html
15:36:26 <goron_> My ISP dropped the DSL signal... amateurs...
15:37:02 <lispy> Heffalump: i don't think i've ready anyhing by john hughes, but i think someone who presented in a class quoted it
15:37:25 <poetix> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps <- Theorems for Free!
15:38:47 <Heffalump> lispy: it's worth reading (google for it)
15:39:11 <Heffalump> One of the things it notes is that lazy functional programs give you coroutines in a really nice way, by writing functions that produce and consume a data structure
15:39:46 <Heffalump> deforestation then makes that model efficient, by removing all the operations that actually construct and destruct the data structure explicitly.
15:39:53 <goron_> coroutine?
15:40:13 <Heffalump> it would be easier for you to google to find out about them than to listen to a bad explanation from me
15:40:32 <jlouis> Heffalump: yes. Though it might have been SPJ who noticed their coplay
15:40:38 <goron_> yes, probably.
15:40:49 <lispy> Heffalump: thanks for the info
15:41:03 <Heffalump> jlouis: short-cut deforestation is probably based on assuming that a free theorem applies in Haskell
15:41:46 <Heffalump> but I doubt that deforestation in general is based on a free theorem, or that (given the problems with parametricity in Haskell) you can get directly from a free theorem to practical deforestation.
15:44:42 * poetix is optimized away
15:45:36 <goron_> Ok, I get the idea. Some people implement stuff with threads, while they are actually coroutines....
15:46:00 <goron_> So, some people are <undefined>, well, we already knew that, didn't we?
15:46:04 <Heffalump> change of control between coroutines is more explicit than with threads
15:46:18 <Heffalump> you use explicit 'yield' statements normally
15:46:21 <goron_> and more efficient.
15:46:53 <Heffalump> more restrictions on the programmer usually means a more efficient implementation :-)
15:47:09 <goron_> No shit Sherlock!
15:47:17 <goron_> That's a flame. :D
15:49:17 <greenrd> Python has coroutines; Java doesn't, but you can simulate them (poorly and unscalably) using threads.
15:49:54 <nekoreppie> coroutines = non-preemptive threads, no?
15:50:37 <nekoreppie> why are coroutines more efficient than threads?
15:51:44 <jlouis> a switch between the coroutines is much simpler
15:51:47 <Heffalump> because of the lack of pre-emption
15:51:58 <Heffalump> and no separate global state
15:52:42 <nekoreppie> if you use threads as coroutines you won't have any preemption going on.
15:53:21 <Heffalump> the threads implementation doesn't know that
15:53:28 <nekoreppie> what do you mean?
15:53:29 <Heffalump> and I'm not sure how you would explicitly prevent preemption anyway
15:53:56 <nekoreppie> the scheduler will see that there aren't any other threads running and will give the next timeslice to the current thread
15:54:19 <Heffalump> it'll still have to interrupt the current thread every so often to check that
15:54:33 <Heffalump> and you will have to be careful never to have more than one thread ready to run
15:54:38 <nekoreppie> if you have kernel threads there isn't any difference
15:54:40 <greenrd> the separate global state is the killer
15:54:54 <greenrd> linux by default only supports a small number of threads on a desktop system
15:55:13 <greenrd> sure, the limit can be raised, but it's really inefficient
15:55:30 <nekoreppie> because the kernel still interrupts the process X times per secnod whether or not you are using threads
15:55:55 <psi> what could make ghc say 'Main.hs:11:2: Not in scope: `Vt100.addText' when the module Vt100 clearly has that function?
15:56:02 <psi> nevermind, I didn't export it
15:56:10 <lispy> greenrd: i'm not sure that's true in the 2.6 kernel line, threads have been improved
15:56:13 <nekoreppie> i don't understand what you mean by separate global state?
15:56:32 <Heffalump> thread local storage
15:56:40 <nekoreppie> you don't have to use it
15:56:50 <nekoreppie> why is it a bad thing?
15:56:51 <Heffalump> the implementation still needs to support it
15:56:56 <greenrd> there is overhead: new stack, kernel stuff
15:57:14 <greenrd> the kernel must zero the stack otherwise it is a security hole
15:57:15 <nekoreppie> greenrd only when you create the thread
15:57:33 <greenrd> zeroing the stack == need for physical memory not just virtual memory
15:58:03 <Heffalump> greenrd: information leek between threads isn't a problem, surely?
15:58:07 <nekoreppie> also, smart OSes pre-zero memory during idle times
15:58:10 <Heffalump> s/leek/leaks/
15:59:17 <nekoreppie> those are non-issues
16:00:49 <greenrd> Well, I accidentally wrote a bug in a Java program that allocated lots of threads and did _nothing_ else, and my system started swapping out a lot.
16:00:56 <greenrd> a thread bomb
16:01:37 <greenrd> so, whilst in theory it may be a non-issue, in practice it is an issue
16:01:47 <goron_> The amount of Windows advertisements on non-Windows pages is amusing.
16:02:07 <nekoreppie> greenrd did you write a java program that allocates a lot of coroutines?
16:02:18 <greenrd> no
16:02:23 <dcoutts> want to see a pretty pic?
16:02:24 <dcoutts> http://www.haskell.org/~duncan/cairo/lsystem-demo/LSystem.png
16:02:24 <xerox> Hey, haskell-cairo porn!
16:02:29 <nekoreppie> it would probably be just the same, greenrd
16:02:29 <xerox> :-)))
16:02:49 <Heffalump> with coroutines, since the compiler knows where control is lost, it can optimise for it.
16:03:03 <Heffalump> With threads the implementation has to save all context just in case.
16:03:17 <nekoreppie> Heffalump true
16:04:00 <nekoreppie> assuming the language supports coroutines natively
16:04:08 <SyntaxNinja> dcoutts: very pretty
16:04:21 * xerox boings happily
16:04:34 <dcoutts> all credit to xerox
16:04:44 <SyntaxNinja> xerox: nice
16:04:53 <xerox> haha
16:04:57 <xerox> dcoutts is the man ;)
16:05:03 <Heffalump> nekoreppie: even if it doesn't, you could use a library, and the context that would be saved would be what is mandated by the procedure-call standard, which is still smaller than the context needed for a thread switch
16:05:24 <Heffalump> do we get an SVG of that? :-)
16:05:54 <nekoreppie> Heffalump you mean imlementing coroutines as CALL/RETURN pairs?
16:06:24 <Heffalump> I mean by making yield a library call
16:06:27 <lispy> what about forkIO
16:06:32 <lispy> is that efficient?
16:06:35 <xerox> Goodnight people!
16:06:36 <Heffalump> (and implementing it in machine code)
16:07:00 <Heffalump> Haskell threads are pre-emptive from the point of view of your code, but cooperative from the point of view of the RTS
16:07:11 <lispy> yeah
16:07:14 <nekoreppie> Heffalump you still need to save the context, no?
16:07:26 <dcoutts> Heffalump, and svg of that png? Not yet, the cairo svg backend is still in development I believe.
16:07:39 <Heffalump> nekoreppie: only the context that the procedure call standard for your architecture says must be preserved across function calls.
16:07:46 <lispy> Heffalump: that's why i was curious how they fit in.  Are they basically jus coroutines in terms of efficiency?
16:07:53 <Heffalump> i.e. the callee-saved regs
16:08:33 <Heffalump> lispy: I'm not sure what assumptions the RTS makes. From the point of view of programming for it, it's less efficient, because you need to lock your data structures.
16:08:37 <luqui> what is Monad P?
16:08:54 <nekoreppie> Heffalump: mov r0, 1; yield; print(r0) wouldn't work, then?
16:09:12 <nekoreppie> the intention is to print 1
16:09:23 <Heffalump> nekoreppie: not if r0 is a caller-saved register, which in most architectures it would be.
16:09:34 <Heffalump> (since it would normally be used for parameter passing and result returning)
16:10:13 <Heffalump> but mov r0, 1; foo; print(r0) wouldn't work for random foo.
16:10:31 <Heffalump> because foo would be under no obligation to preserve r0
16:11:11 <nekoreppie> so all coroutines give you is the ability of not saving a few register when  yielding?
16:11:29 <lispy> Heffalump: hm..okay.
16:11:41 <lispy> so why does my code sometimes segfault when i use forkOS but not when using forkIO?
16:11:48 <lispy> does that point to bugs in the RTS?
16:12:18 <Heffalump> nekoreppie: that's quite a big win in itself
16:12:42 <nekoreppie> it's only a few cycles
16:13:17 <Heffalump> you might want to switch 10s of millions of times per second
16:13:34 <lispy> well, i've been trying to turn the linux kernel into a darcs repo for 26 minutes  (according to top so it's much longer in wall clock time)
16:13:35 <SyntaxNinja> is there something like Word32, but signed?
16:13:40 <luqui> anyone know what Monad P (as mentioned in the Prelude in HHL) is?
16:13:46 <lispy> SyntaxNinja: Int32 in is data
16:13:52 <Heffalump> HHL?
16:13:55 <lispy> @index Int32
16:13:56 <lambdabot> Data.Int, Foreign
16:14:06 <luqui> Haskell Hierarchical Libraries documentation
16:14:09 <nekoreppie> ok i'm going to bed
16:14:11 <nekoreppie> byez
16:14:11 <Heffalump> got a URL?
16:14:23 <goron_> How can I STOP a process and all the processes it spawned?
16:14:31 <luqui> Oh, I guess It's mentioned in Monad
16:14:36 <luqui> http://haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.html
16:14:39 <SyntaxNinja> lispy: perfect
16:14:44 <luqui> almost half way down
16:15:14 <Heffalump> umm, no idea :-)
16:16:37 <Heffalump> the fact that it isn't hyperlinked makes me think something screwed up somewhere.
16:16:52 <luqui> possibly
16:17:17 <Heffalump> oh, I think it's part of the HuttonMeijerWallace parser combinators
16:17:17 <lispy> sometimes when my program generates IO Exceptions in a forkOS thread, i get a segfault (linux x86) or a bogus activation record (osx)
16:17:23 <Heffalump> Text.ParserCombinators.HuttonMeijerWallace
16:18:21 <lispy> how should i approach that?  Try using hat?
16:18:33 <luqui> ahh, there's a mention
16:18:45 <Heffalump> lispy: report a ghc bug :-)
16:19:00 <Beelsebob> lispy: what're you trying to do?
16:19:24 <Beelsebob> oh... /me finds it in the scroll
16:19:36 <Beelsebob> don't know if hat will be too happy to deal with that
16:19:40 <Beelsebob> but you could try
16:20:42 <lispy> Heffalump: i did, but i never heard if the bug report was even accepted
16:21:02 <lispy> Beelsebob: i wanted to write a server thingy th at listens to each client in a thread
16:21:43 <Heffalump> are the IO exceptions uncaught at the top level of the forkOS'd code?
16:21:49 <lispy> if i do random connections and disconnections (both clean and by killing the process or link) then eventuall i'll get on of the crashes
16:22:19 <Heffalump> have you experimented with different ghc versions?
16:22:33 <lispy> Heffalump: no, i use "catch" in all the threads which connect to sockets and from the "main" thread
16:22:47 <lispy> Heffalump: only in going between linux and osx
16:23:00 <lispy> ah, nevermind they are same version
16:23:06 <lispy> 6.4
16:23:13 <Heffalump> can you try 6.2.2?
16:23:23 <lispy> maybe
16:23:25 <lispy> let me see fi that's in apt
16:23:48 <Heffalump> it's what sarge has
16:23:58 <Beelsebob> lispy: 6.2.2 is easy to compile from source if you have 6.4
16:24:00 <Igloo> lispy: What version of darcs?
16:24:08 <Beelsebob> that's how I got both on my machine
16:24:19 <lispy> Igloo: 1.0.3
16:24:25 <lispy> Igloo: i should have tried it with the prelease
16:24:39 <lispy> Beelsebob: hm...but the compile take so long
16:24:45 * Igloo could have told you it will be slow, then
16:24:58 <Beelsebob> heh, that's the benifit of a 3.6Ghz box :)
16:25:16 <lispy> Igloo: yeah, i should have checked first, i thought i had upgrade darcs on this machine so i didn't bother checking
16:25:57 <lispy> 6.2.2 is in apt, now how to install it without killing my current install
16:26:18 <Heffalump> with difficulty.
16:26:30 <Heffalump> (you could make a chroot if you have disk space to burn)
16:27:02 <Beelsebob> 6.2.2 and 6.4 lived happily together on my box
16:27:03 <lispy> yeha, i should just install it to my homedir
16:27:14 <lispy> i'll set that up later tho
16:27:22 <Heffalump> lispy: just grab a binary tarball and install tha tlocally
16:27:24 <Heffalump> that's what I do at work
16:27:27 * lispy doesn't feel like messing with it at the moment
16:27:37 <Heffalump> 5 minute job once it's downloaded
16:27:41 <Heffalump> (if that)
16:27:43 <lispy> Heffalump: you can install the tarball to ~/?
16:27:48 <Heffalump> yes
16:28:02 <Heffalump> untar it, ./configure --prefix=/home/ganesh/bin, make install
16:28:04 <Heffalump> (IIRC)
16:28:10 <Heffalump> something roughly that simple, anyway
16:28:12 <lispy> okies
16:28:19 <Heffalump> --prefix=/home/ganesh not /home/ganesh/bin I think
16:28:24 <Heffalump> you'd need to check the details
16:28:57 * Igloo is tempted to make update-haskell-control more powerful and then tweak the debs to be able to build ghc6.4.1 packages too for H-U
16:29:16 <Heffalump> why does update-haskell-control need to be more powerful?
16:29:26 <Igloo> But I'm slightly worried at u-h-c tending towards being a T-C language
16:29:44 <Igloo> It has to do conditional stuff depending on what package name you are wanting
16:30:16 <Heffalump> oh, so currently you manually update your debs to a new GHC version
16:30:18 <jlouis> I often --prefix=$HOME/run/ghc-x.y.z
16:30:27 <lispy> c-l-c can do multiple compilers and, i think, multiple versions for complires
16:30:28 <Heffalump> and you want to parametrise them on the GHC version instead
16:30:33 <jlouis> and then proceed to ln -s $HOME/run/ghc-x.y.z/bin to $HOME/bin
16:30:59 <Igloo> Currently both 6.4 and 6.4.4 build ghc6 only. I'm thinking of making it possible to build either ghc6 or ghc6.4, and ghc6 or ghc6.4.1, at your choice
16:31:08 <Heffalump> ahh.
16:31:09 <Heffalump> cunning.
16:32:01 <Heffalump> what do you mean by (ghc6 \/ ghc6.4) /\ (ghc6 \/ ghc6.4.1) ? Why not (ghc6 \/ ghc6.4 \/ ghc6.4.1) ?
16:32:32 <Igloo> I mean "ghc6 or ghc${version}"
16:32:42 <Heffalump> ah, duh
16:33:06 <Heffalump> debian lacks versioned provides, right?
16:33:11 <Igloo> yup
16:33:15 <Heffalump> shame.
16:33:29 <Igloo> Hmm, that's a point
16:33:37 <Heffalump> Though perhaps Debian packages could be changed to require ghc6.4.1 or whatever and later things could provide all earlier things.
16:33:41 <Heffalump> Though that's rather ick.
16:33:58 <Heffalump> someone should just fix dpkg :-)
16:34:00 <Igloo> They don't need to provide all earlier things
16:34:10 <SyntaxNinja> speaking of debian, is ghc still broken in unstable?
16:34:23 <Igloo> It's still uninstallable, yes
16:34:24 <Heffalump> why not?
16:34:41 <Igloo> Because they depend on the exact upstream version anyway
16:34:53 <Heffalump> oh, binary packages, yeah
16:34:59 <Heffalump> what about build-deps?
16:35:21 <Igloo> Also depend on an upstream version, so transitions happen properly
16:38:04 <Igloo> I think it'll work OK with conditional deps, except registering with the right GHC could be tricky. Especially as there may be both a ghc6 (= 6.4) and a ghc6.4
16:38:34 <Heffalump> why not do what gcc does to allow multiple versions to be installed from standard Debian?
16:38:59 <Heffalump> i.e. always make the real package be ghc6.4
16:39:54 <Igloo> It used to be because it took so long to get through new, but that's quicker now. It's still extra hassle, though, and I don't want to get into the situation with half a dozen ghc6's hanging around for different libraries
16:42:29 <lispy> wow, my code behaves even sketchier with 6.2.2
16:42:41 <lispy> Caught: <socket: 7>: commitAndReleaseBuffer: resource vanished (Broken pipe)
16:42:50 <Heffalump> well, at least it's not segfaulting..
16:42:52 <lispy> i get thta sometimse now when the client sends data
16:42:54 <Heffalump> or is it? :-)
16:43:04 <lispy> it may be, i haven't tested enough to know
16:43:33 <lispy> Fail: <socket: 6>: hClose: resource vanished (Broken pipe)
16:43:34 <lispy> hud: internal error: scavenge_stack: weird activation record found on stack: 0
16:43:56 <lispy> so, no, it didn't segfault :)
16:44:19 <Heffalump> how long ago did you report the bug?
16:44:22 * lispy double checks that he has enough catches
16:44:31 <lispy> this weekend, saturday or sunday
16:44:59 <lispy> i also attached the source code and directions for reproducing it
16:45:07 <lispy> i'm wondering if the attached tarball flagged something
16:45:19 <lispy> or rather, got the message flagged
16:45:42 <Igloo> It's unlikely to be answered (usefully) until Simon Marlow gets back
16:45:48 <Heffalump> did it appear on the mailing list archives?
16:46:03 <lispy> i don't know where those are to check them
16:46:13 <lispy> (or that it should :)
16:46:44 <lispy> but you know what, i bet i need to try catching exceptions in a few more places
16:47:24 <lispy> i'm looking at it, and when i refactored i made it so that only the threads which listen to sockets, have a catch around them
16:47:40 <lispy> so i'll add a few catchs with putStrLn's to help debug
16:47:55 <Heffalump> put a catch around the code that is passed as a parameter to forkOS
16:48:10 <Heffalump> that will guarantee that no exceptions can escape all the way to the forkOS call
16:48:40 <lispy> right now i have a catch which is at the end of the code that is passed to forkIO
16:48:43 <lispy> well, forkOS
16:48:59 <lispy> so you mena i should do catch (forkOS (...))  ?
16:49:13 <lispy> or forkOS (catch ... ))?
16:50:27 <luqui> what does it mean when the program tells me <<loop>>
16:50:35 <luqui> did it just detect an infinite loop?
16:50:47 <Igloo> Yes
16:50:52 <luqui> that's pretty cool
16:52:13 <Heffalump> forkOS (catch ...)
16:52:16 <lispy> oh, fun, now i get to play with the layout rule
16:52:29 <Heffalump> it only detects some infinite loops
16:52:35 <Heffalump> e.g. let loop = loop in loop
16:52:40 <Heffalump> but not let loop () = loop () in loop ()
16:52:52 <luqui> fair enough
16:53:09 <luqui> (the thing that's looping doesn't loop too much unlike the first one of those :-)
16:53:17 <Heffalump> basically anything that is a "black hole" it can detect, i.e. when evaluating a thunk causes it to reevaluate the same thunk
16:53:51 <Heffalump> whereas my loop () example is just lots of repeated function invocations. Of course, transformations the optimiser does can convert one kind into the other and vice-versa.
16:54:22 <luqui> one kind into the other *and* vice versa?? :-p
16:54:32 <Heffalump> yes. Not normally at the same time.
16:54:43 <luqui> I was just making fun of you... nevermind
16:55:13 <Heffalump> I was making it clear that the transformation can go both ways. It wouldn't have been entirely unambiguous if 'd just said "one kind into the other". So :-p
16:55:27 <luqui> I suppose it is impossible to actually detect all infinite loops (even at runtime), right?
16:55:35 <Heffalump> yes
16:56:06 * luqui thinks "ahh yes, that's what that halting problem thingamajigger was all about huh..."
16:56:30 <Heffalump> let { f x | x `mod` 2 == 0 = x `div` 2 ; otherwise = 3*x + 1 } in fix f n
16:56:48 <Heffalump> sorry, with a termination case for x == 1, so that code is a bit wrong
16:57:02 * Igloo decides not to get into a PC just being a FSM etc right now  :-)
16:57:05 <Heffalump> but you get the general idea
16:57:28 * Heffalump invites igloo to write something that can model the FSM on the same hardware
16:57:45 <lispy> Heffalump: yeah, now i think the exception handling wasn't so great.  Should this still be considered a bug?
16:57:50 <Heffalump> (model it well enough to detect termination properties faster than the PC itself can)
16:57:53 <lispy> i mean, the crashing....
16:57:53 <Heffalump> lispy: IMO, yes.
16:57:53 <luqui> what is fix and where can I find it?
16:58:10 <Igloo> "faster than the PC itself can"?
16:58:13 <Heffalump> fix f x = f (fix f x)
16:58:13 * luqui actually pretty much knows what it is
16:58:25 <luqui> oh, there's a pretty little definition
16:58:26 <Heffalump> I may have got the "proper" definition wrong.
16:58:27 <luqui> cool
16:58:34 <Igloo> It's simple, if you just allocate yourself enough memory, anyway
16:58:40 <Heffalump> it may be fix f = f (fix f)
16:58:53 <lispy> well, this makes me much happier
16:59:06 <Heffalump> lispy: I think crashing if an exception escapes to forkOS is a bug, yes.
16:59:07 <luqui> that is pretty much the definition of a fixed point isn't it?
16:59:21 <luqui> so that's probably the right one
16:59:23 <Heffalump> can you reproduce it reliably, e.g. with forkOS (error "foo") or similar?
16:59:27 <Heffalump> luqui: yeah
16:59:48 <Heffalump> Igloo: but the PC is a FSM, so has limited memory :-p
17:00:04 <lispy> Heffalump: i doubt it, the crash only appears to happen after the exception: commitAndReleaseBuffer: resource vanished (Broken pipe)
17:00:13 <Heffalump> lispy: ok, manually raise that exception
17:00:18 <lispy> Heffalump: but i more minimal test case should certainly be possible
17:00:28 <Heffalump>  - but it may just be that that's the only exception that happened to be escaping before
17:00:42 <lispy> true
17:00:50 <Heffalump> ugh. bedtime. Night all.
17:00:56 <lispy> night
17:01:31 <Heffalump> if Igloo wants to continue the decidability argument, just tell him he's wrong.
17:01:39 <lispy> Heffalump: thanks for your help
17:01:45 <Heffalump> (by virtue of being from Keble, for one thing)
17:01:48 <lispy> Heffalump: i'll work on building a more minimal test case
17:05:45 <lispy> well, main = forkOS (error "hi") isn't enough
17:11:27 <lispy> i'm guessing the exception has to be a real one
17:11:33 <lispy> but i colud be wrong
17:19:00 <lispy> is it a requirement that every research group have at least one idiot?
17:19:34 <lispy> like maybe a subsection of murphy's law? ;)
17:19:34 <goron> The Halting Problem is solvable.
17:19:50 <lispy> goron: given the right resources
17:20:00 <goron> lispy: ?
17:20:01 <wagle> compute with real numbers
17:20:40 <goron> Although not algorithmically....
17:20:56 <lispy> goron: well, if you had something which be definition could solve the halting problem then you'd be set
17:21:02 <lispy> goron: yeah
17:21:14 <goron> But I guess this statement is void.
17:21:25 <lispy> of course the hard part in having something which an solve it, is showing existence :)
17:21:32 <goron> Some author claimed he proved this.
17:22:00 <goron> I think the author has just really complexly derived something obvious...
17:22:01 <wagle> http://www.nationmaster.com/encyclopedia/Hypercomputer
17:22:24 <goron> But I didn't read the paper...
17:22:30 <wagle> http://www.nationmaster.com/encyclopedia/Super_Turing-computation
17:23:19 <wagle> Hava Siegelman. Neural Networks and Analog Computation: Beyond the Turing Limit
17:23:35 <lispy> wagle: very nice find
17:23:37 <goron> wagle: Is that bogus, or real?
17:24:09 <wagle> hava: ..  and it can solve the halting problem..  [paraphrase]
17:24:20 <wagle> me: do you have a construction?
17:24:21 <lispy> A "real computer" (a sort of idealized analog computer) might be able to perform hypercomputation if physics admits general real variables (not just computable reals), and these are in some way "harnessable" for computation. This might require quite bizarre laws of physics (for example, a measurable physical constant with an oracular value, such as Chaitin's constant), and would at minimum require the ability to measure a real-
17:24:21 <lispy> valued physical value to arbitrary precision despite thermal noise and quantum effects.
17:24:25 <wagle> hava: yes
17:24:45 <wagle> turned out that you could encode the solution in a real number
17:25:47 <wagle> so much chatter about how discrete reality was for weeks afterwards
17:26:14 <lispy> wagle: do you have a link to this thing with hava?
17:27:05 <goron> wagle: "was for weeks" is an expression?
17:28:26 <wagle> "how discrete reality was"...  for weeks afterwards
17:28:57 <wagle> she gave a talk at indiana university in the early 90's..
17:29:14 <wagle> i'm not finding much on the web
17:29:43 <lispy> wagle: so they encode the solution to the halting problem in an arbitrary real number.  So then if you could compute with arbitrary reals you'd be set?
17:30:08 <wagle> i guess
17:30:23 <goron> lispy: If you use an analog computer, I'd say so.
17:30:46 <lispy> well, i gotta run
17:30:48 <wagle> goron electrons are quantum
17:30:48 * lispy &
17:31:14 <goron> wagle: So?
17:32:48 <Pseudonym> At some point on an idealised analogue computer, the uncertainty principle would kick in.
17:33:05 <Pseudonym> (Assuming such a computer wasn't _entirely_ idealised, of course!)
17:33:06 <wagle> how do you get measurements with infinite precision
17:33:22 <Pseudonym> You don't, necessarily.
17:33:27 <wagle> oh well, gotta take off
17:33:44 <Pseudonym> Presumably you wouldn't need _measurements_ with infinite precision, merely intermediate results.
17:33:51 <goron> Don't you just need a "yes"/"no" answer?
17:33:56 <Pseudonym> Right.
17:34:28 <Pseudonym> So you use infinite precision internally, put the result through a perfect op amp comparitor, and return a boolean answer.
17:34:49 <goron> yes
17:34:56 <goron> Step 4: Profit!
17:35:04 <Pseudonym> Right!
17:35:14 <goron> Reroute power to the main deflector!
17:35:32 <goron> Pseudonym: Now, that would be an interesting Thesis.
17:36:24 <Pseudonym> A perfect analogue computer would be great for numerical problems.
17:36:29 <goron> Honestly, I think analog computation is underrated.
17:36:34 <Pseudonym> You wouldn't have to deal with ill-conditioned input.
17:37:03 <Pseudonym> Analog computation is still alive and well in signal processing.
17:37:22 <Pseudonym> Lots of filters, for example, are analog.
17:37:34 <goron> "low-band filter"
17:37:49 <goron> etc. (I only know the names, not the semantics)
17:37:53 <Pseudonym> Right.
17:38:00 <Pseudonym> It's to do with the response, I think.
17:38:13 <Pseudonym> With a digital signal, there's always a delay for the filter to respond.
17:38:18 <Pseudonym> Or something.
17:38:44 <goron> I would go for the latter:"something".
17:38:47 <goron> haha
17:38:50 <Pseudonym> :-)
17:39:25 <Pseudonym> BBS.  Free cakes.
17:39:33 <goron> I am gone. Bye
17:47:56 * dons continues on his quest to program in the list monad in the shell
17:48:06 <dons> just have to find a use for the list monad, then.
17:48:27 <luqui> isn't it basically present using {} notation?
17:48:51 <dons> ?
17:50:46 * Igloo hmms at HSQ, Sqlite and decisions
17:51:15 <dons> the shell normally behaves  like an IO monad, with >>= as |, >> as ;, and return as cat (if you treat filenames as variables)
17:57:03 <TheHunter> moin dons
17:57:13 <TheHunter> you want it to behave like ListT IO ?
17:58:23 <dons> well, i'm just considering the pure part (mostly just the h4sh functions, grep,etc) and making sure that behaves like Monad List and Functor List
17:58:43 <dons> I hadn't thought of ListT IO, actually.
17:58:52 <TheHunter> ah, i see.
17:59:12 <TheHunter> I don't think ListT IO is possible, though.
17:59:41 <dons> the list monad works once i implemented foldr, then:
17:59:44 <dons>     return x   = words x/ show x/ echo x
17:59:44 <dons>     m >>= k    = foldr '((++) . k)' m
17:59:44 <dons>     m >>  k    = foldr '((++) . (\ _ -> k))' m
17:59:59 <dons> and functor for lists is pretty easy:
18:00:00 <dons>         map id        == i
18:00:01 <dons>         map '(f . g)' == map f | map g
18:00:38 <dons> Monad IO is much cleaner, as you get | for >>= and ; for >>
18:00:49 <dave_m> ListT IO is possible with an appropriate definition of ListT (i.e., not the one in the hierarchical library)
18:00:55 <dons>     i a | k       == k a
18:00:55 <dons>     m | i         == m
18:00:55 <dons>     m | (k x | h) == (m | k) | h
18:01:20 <stefanw> isn't it easier to use concat and map instead of foldr for the definition of >>=?
18:01:48 <dons> hmm. good idea
18:01:54 <luqui> where can I learn about monad transforms?
18:02:01 <luqui> I mean "learn", not "look up in a reference"
18:02:09 <dave_m> or just use concatMap; it's more efficient than concat . map f
18:02:11 <luqui> that is, a tutorial of some sort
18:02:46 <TheHunter> dave_m, in a way that | behaves like the >>= of that monad?
18:02:46 <dons> dave_m, we're considering shell commands here. foldr above is a shell command. we do have conat and map, but not concatMap yet (maybe I should add it)
18:03:41 <dave_m> dons: I see. In any case concatMap is defined in terms of foldr
18:04:22 <dave_m> TheHunter: probably not
18:04:27 <dons> ah, so it is! concatMap f             =  foldr ((++) . f) []
18:05:24 <TheHunter> hmm, maybe that'd make a nice rule for @pl.
18:05:42 <dons> so we could use: map f | concat
18:05:50 <dons> TheHunter, also I see concat = foldr (++) []
18:06:16 <dons> and build g = g (:) [] is another one
18:06:31 <TheHunter> i should really add the foldr free theorem.
18:06:35 <dons> build is highly underused
18:07:00 <TheHunter> it's just not feasable that the programmer himself has to care about deforestation.
18:09:03 <dons> right stefan, so we can have: m >>= k             = map k m | concat
18:10:40 <dons> and m >> k   = map 'const k' m | concat
18:12:01 <stefanw> I think >> is quite useless in the list monad, because m does not have side-effects
18:12:19 <dons> it's weird, I agree
18:12:30 <dons> $ map 'const "X"' Makefile | concat
18:12:30 <dons> XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
18:13:18 <dave_m> stephanw: I've occasionally written things like "guard (...) >> ..." in the list monad
18:14:07 <dons> Prelude> m >> return 'X'
18:14:07 <dons> "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
18:14:52 <stefanw> >> is short for >>= \_ ->
18:15:31 * Igloo nominates "query conn query = checkHandle (connClosed conn) (connQuery conn query)" for the "scary definition of the day" award
18:15:45 <Igloo> In particular, note the argument with the same name as the function...
18:16:54 <dons> Prelude> m >>= \_ -> return 'X'
18:16:55 <dons> "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
18:16:55 <dons> Prelude> m >> return 'X'
18:16:55 <dons> "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
18:17:13 <dons> Igloo!
18:28:37 <TheHunter> why would the stupid linux kernel torture the hard-drive in an out-of-memory condition when there is no swap partition.
18:31:09 <luqui> I do: "import Data.Set as Set", and yet haskell complains that "map" is ambiguous (between Prelude and Set)
18:31:25 <TheHunter> "import qualified Data.Set as Set"
18:31:59 <luqui> Then do I refer to the type as Set.Set?
18:32:14 <TheHunter> yep.
18:32:28 <luqui> yuck
18:32:34 <luqui> (but I understand)
18:32:35 <luqui> thanks
18:32:37 <dave_m> if that's annoying, you can add "type Set = Set.Set"
18:32:44 <luqui> fair enough :-)
18:33:10 <Igloo> You can also add a second import "import Data.Set (Set)"
18:33:53 <TheHunter> (or you could refer to Prelude's map as Prelude.map and keep your import as it is)
18:37:36 <luqui> hiya xinming
18:37:55 <xinming> luqui: ... :-)
18:38:06 <xinming> luqui: Nice seeing you here. :-)
18:38:22 <luqui> I don't think I found out: are you from haskell before perl?
18:38:28 <luqui> or are you just learning because of pugs?
18:38:46 <xinming> luqui: Need to go on learning since I've caught the main grammar of "pugs"
18:38:54 <xinming> luqui: I learn it for pugs, :-)
18:39:00 <luqui> me too :-)
18:39:22 <luqui> autrijus seems to be as much a culture hacker as Larry... I'm not sure he's trying though
18:39:51 <xinming> luqui: I wish I can be more helpful. And not be a stupid guy which take places in #perl6
18:40:16 <xinming> luqui: hmm, The talent will always get the truth before others. :-)
18:41:18 <luqui> all the pugs hackers started as "stupid guys" hanging out in #perl6
18:41:36 <luqui> hmmm, this is probably a conversation for that channel
18:42:25 <xinming> luqui: by the way, Why will autrijus prepare pugs to being able to handle so much "backends" ?
18:43:16 <xinming> luqui: In fact, I think, The better choice is to help for perl 6 booting-strap, After this, IMHO, Most things might be more easier...
18:43:36 <luqui> Prepare to launch to #perl6!
18:44:50 <shrimpx_> anyone know offhand where i can find a formal translation of 'do' syntax into >>= and return?
18:46:05 <Igloo> The Haskell 98 report
18:47:06 <shrimpx_> got it thanks
19:00:10 <Pseudonym> Wow.  Google Talk actually works.
19:01:17 <lispy_> Pseudonym: is it some sort of voip?
19:01:22 * lispy_ goes to findit
19:01:22 <Pseudonym> No, it's IM.
19:01:33 <Pseudonym> If you have a GMail account, you already have it.
19:01:42 <Pseudonym> It uses the Jabber protocol.
19:02:06 <lispy_> ah, so just log into gmail to get to it?
19:02:12 <Pseudonym> No.
19:02:15 <Pseudonym> You need a Jabber client.
19:02:26 <lispy_> i might....
19:04:46 <lispy_> Pseudonym: just plugin my gmail address and password and it should work?
19:04:56 <lispy_> hmm...no
19:09:15 <lispy_> Pseudonym: so, how do i connect? I have a jabber client and a gmail account...but I can't seem to get the settings right
19:23:48 <lispy_> Pseudonym: any helpful hints? ;)
19:44:13 <Pseudonym> I'm using Gaim, and here's what I do.
19:44:54 <Pseudonym> My screen name is my gmail user name.
19:44:57 <Pseudonym> Server: gmail.com
19:45:05 <Pseudonym> Password is my Gmail password.
19:45:21 <Pseudonym> Then I have "Use TLS if available", port 5222, server talk.google.com.
19:45:42 <Pseudonym> The confusing part is that there are two different servers in two different places.
19:45:52 * Pseudonym has no idea how the Jabber protocol works
19:47:02 <Pseudonym> HTH
19:47:06 <Pseudonym> I must be off.
19:47:21 <Pseudonym> You can try sending me a message if you want to test it out. :-)
19:47:28 * Pseudonym is deguerre
19:47:29 <Pseudonym> Anyway
19:47:36 <Pseudonym> Need to meet my brother for lunch.
19:47:37 <Pseudonym> BBL
19:47:59 <lispy_> hmm...
19:48:58 <lispy_> i think it's working
19:49:04 <lispy_> i asked for my password at least
19:49:09 <lispy_> which is more than before
19:51:07 <lispy_> hmm..i get the message "Server unexpectedly disconnected"
19:53:01 <lispy_> hrmm...
19:58:27 <lispy_> bummer, i can't get gaim for my platform
19:58:42 <lispy_> and ichat doesn't seem able to connect
20:25:38 <Cale> dons: are you there?
20:26:46 <Cale> dons: Just wondering if you've had any luck with the runplugs problem. (I'm getting the setNonBlockingFD thing)
20:41:22 <TheHunter> it's been kinda fixed in the head
20:41:35 <TheHunter> not sure about stable, though.
20:46:44 <Cale> hmm... If I alter runplugs to use getLine instead of getContents then it works
20:46:53 <Cale> interesting...
20:47:36 <TheHunter> yes, there's a logical explanation for that.
20:48:21 <TheHunter> http://sourceforge.net/tracker/index.php?func=detail&aid=1249226&group_id=8032&atid=108032
20:49:02 <Cale> ah
20:49:05 <Cale> okay :)
20:49:13 <TheHunter> basically, this is because the inventors of the posix library were ...
20:49:21 <TheHunter> don't wanna finish that sentence.
20:50:13 <Cale> heh
20:50:43 <TheHunter> there's no way to say pipe(), but use only fds above 2.
20:51:15 <Korollary> ooohh
20:51:18 <Cale> yeah, I saw that in the comments just now
20:51:33 <Cale> quite silly
20:51:34 <DuEy> How do I add an element to the start of a list?
20:52:21 <TheHunter> @eval 1: [2,3,4]
20:52:23 <lambdabot> [1,2,3,4]
20:53:02 <Korollary> @eval (:) 1 [2,3,4]
20:53:04 <lambdabot> [1,2,3,4]
20:53:13 <DuEy> hmm
20:54:05 <DuEy> head10 :: [a] -> [a]
20:54:06 <DuEy> head10 a = 10 : a
20:54:07 <Korollary> what we're doing is actually constructing a new list from another list and a new head element
20:54:09 <DuEy> not working?
20:55:12 <Cale> DuEy: that can't really be of type [a] -> [a]
20:55:18 <dave_m> As you've written it, head10 has the type Num a => [a] -> [a]
20:55:25 <DuEy> oh
20:55:50 <Cale> because if a isn't a type of number, then 10 can't be inserted into the list
20:55:50 <DuEy> ah got it
20:55:56 <DuEy> thanks
20:56:14 <lispy_> @type \a -> 10 : a
20:56:16 <lambdabot> forall a. (Num a) => [a] -> [a]
20:56:55 <lispy_> @pl \a -> 10 : a
20:56:57 <lambdabot> (10 :)
20:57:01 <lispy_> ;)
20:58:49 <lispy_> i had a random thought today
20:59:02 <Korollary> lispy_: hsQuake ?
20:59:17 <lispy_> what if modules had a type and it was an instance of Monad?
20:59:27 <lispy_> Korollary: that's soooo yesterday
20:59:48 <TheHunter> we don't want that.
21:00:06 <TheHunter> |import A; import B| and |import B; import A| should be equivalent.
21:00:26 <lispy_> yes, that's true
21:01:00 <dave_m> lispy_: check out <http://citeseer.ist.psu.edu/561746.html>
21:01:50 <lispy_> dave_m: i would have never guessed that to be related
21:01:58 <lispy_> (from reading the abstract that is)
21:02:30 <Korollary> academic paper spam ?
21:03:11 <lispy_> Korollary: it's related
21:03:18 <lispy_> Korollary: but i wouldn't have guessed it
21:03:37 <dons> Cale, like TheHunter says, runplugs needs ghc 6.5
21:03:50 * Korollary imagines some nigerians sending mass emails about continuation passing style...
21:03:52 <lispy_> Mixin modules (or simply mixins) are modules supporting parameterization, cross-module recur-
21:03:52 <lispy_> sion and overriding with late binding ;
21:04:11 <lispy_> mixins have my attention now :)
21:04:15 <dave_m> there's a bunch of papers in that vein, but they spend a lot of effort dealing with side-effects that we don't worry about in Haskell
21:04:17 <Cale> dons: yeah, I just ended up altering runplugs to just use getLine for the time being
21:05:03 <dons> ok, that's reasonable. we should push the patch back into the 6.4 branch, really
21:05:22 <dons> what are you using runplugs for?
21:06:01 <Cale> a lambdabot :)
21:07:14 <Cale> (mbot in #math)
21:07:36 <lispy_> do any of you use Xcode for haskell or with darcs?
21:07:54 * lispy_ should hang out in #math more often
21:11:01 <dons> Cale, feel free to submit any #math related plugins ;)
21:11:24 <lispy_> @integrate x^2
21:11:25 <lambdabot> Unknown command, try @listcommands.
21:11:28 <dons> as long as they don't take 20 hours to compute something silly in mathematica ;)
21:11:28 <lispy_> ;)
21:12:27 <Cale> there are similar restrictions on the mathematica usage -- enough so that Wolfram will hopefully look the other way if they ever notice that I'm using mathematica over irc.
21:13:08 <luqui> @pl \a -> a:[]
21:13:09 <lispy_> Cale: heh, you h4x0r ;)
21:13:12 <lambdabot> return
21:14:00 <Cale> (It's an awfully good advertisement for mathematica anyway :)
21:14:07 <dons> so is there a market out there for an open source mathematica-alike?
21:14:22 <luqui> dons, certainly so, if you can possibly get it good enough
21:14:24 <lispy_> dons: yes, and several attempts at it
21:14:31 <lispy_> yacas comes to mind
21:14:36 <Korollary> maxima
21:14:42 <dons> right, i would have thought so.
21:14:46 <luqui> all the open source mathematica-likes I've seen have been too incomplete for anything that i've considered "useful"
21:14:54 <luqui> but then, I've never tried maxima
21:15:10 <lispy_> it takes a long time to get it all right
21:15:12 <Cale> There's GAP as well, but that's sort of special purpose
21:15:19 <Cale> it's more of a Magma-alike, I suppose
21:15:28 <lispy_> something with lazy evaluation would be good
21:15:32 <luqui> yeah, CASes are very hard pieces of software to write
21:15:32 <Cale> yes!
21:15:40 <luqui> because there's an awful lot of math out there
21:15:58 <lispy_> if you want to replace Maple you'd need a PL built in that felt like math
21:16:00 * luqui wonders if you could make a mathematica-like out of haskell with ghci as your shell
21:16:06 <lispy_> most maple users hate the language
21:16:08 <Cale> I would very much like to see a large Haskell library with an implementation of mathematica like features in it :)
21:16:24 <Pseudonym> http://www.talklikeapirate.com/piratehome.html
21:16:25 <Pseudonym> @arr
21:16:26 <lambdabot> Aye Aye Cap'n
21:16:29 <lispy_> i'm not sure what mathematica users like about it
21:16:40 <Cale> lispy_: consistency
21:16:52 <lispy_> Pseudonym: i've tried 3 jabber clients now to no luck, but i gave your instructions to my gf andit worked on the first try :)
21:16:52 <luqui> mathematica is a functional language
21:16:55 <Cale> It's a little bit insane, but not quite as insane as Maple :)
21:17:03 <Pseudonym> lispy_: There you go.
21:17:12 <lispy_> Pseudonym: ah, my gf works at their hosting provider, they are a neat group of guys i guess
21:18:24 <mwc> Cale, I know what you mean, Maple has some fugly features. I can't decide if it's trying to be C or trying to be Pascal or trying to by Python
21:18:41 <mwc> then of course there's the function for finding the length of a list: nops
21:18:53 <mwc> That took me about 2 hours of reading docs to find
21:18:54 <Cale> Maple has an some kind of a type system buried somewhere within it, but there's a whole lot of confusing polymorphism going on which can really be annoying. It's also really hard to guess or remember the names of things.
21:19:10 <lispy_> mwc: i never did find that function, i thought they didn't have one :)
21:19:23 <luqui> Cale, and it seems like every function has its own syntax!
21:19:38 <luqui> (though that's probably not true; this comes from a naive user)
21:19:48 <mwc> Cale, my department is a major CAS research center, and we do a lot of Maple work
21:20:00 <lispy_> luqui: you are right
21:20:06 <lispy_> programming in maple is terrible
21:20:10 <mwc> I should propose to write a Haskell CAS for an internship next year
21:20:17 <Korollary> and then there are theorem proof assistants. they should all be combined.
21:20:42 <mwc> "A strongly typed CAS with lazy semantics and a JIT compiler :P"
21:20:59 <luqui> ... mathematica?
21:21:05 <luqui> oh wait, strongly typed
21:21:29 <Cale> My friend was doing some research studying quantum noise, and he basically spent most of his time fighting with maple. I recall at one point in time, he had a list of vectors of one type, and taking their sum changed their type to some other vector type which was basically incompatible with the functions he wanted to apply after.
21:21:40 <mwc> We're the primary site of ORCCA: http://www.orcca.on.ca/
21:22:00 <lispy_> the reason that people in algebra and number theory use maple is that it lets you work in arbitrary fields
21:22:24 <Cale> DoCon for Haskell looks like a reasonable place to start.
21:22:26 <lispy_> well, arbitrary groups too, if you could get that working it would be popular with them, especially with lazy support
21:22:39 <Cale> lispy_: have you tried GAP?
21:23:02 <lispy_> no, i haven't i haven't done any number theory or algebra for almost twoyears
21:23:19 <Cale> GAP took me 3 or 4 years to be comfortable using, mostly because I hadn't actually programmed in it, and merely tried to use it to answer quick questions (which doesn't work for learning it)
21:23:41 <Cale> Recently, I wrote some programs in GAP, and it seems a lot saner to me now.
21:24:17 <lispy_> cool
21:24:18 <Cale> The builtin library of functions in GAP has some of the longest identifiers I've ever seen though. You really do need tab completion.
21:24:50 <lispy_> i think something that was lazy, and allowed you to define new operators, and had a nice clean syntax (like haskell!) would really give maple a run for it's money
21:25:16 <lispy_> especially when you consider that the type system could be used to help teach function notation
21:26:54 <mwc> lispy_, I don't think it's just their to "teach"
21:27:01 <mwc> I think it should be rigorously enforced
21:27:37 <lispy_> mwc: yes, a type system can be good
21:27:40 <mwc> shadow has domain HyperReal and codomain Real
21:28:05 <lispy_> i just mean the notation...but ya know, haskell types aren't restrictive enough to really teach, true function notation
21:28:16 <mwc> Especially mathematically, make sure you stay within the set
21:28:24 <lispy_> yeah
21:29:25 * Korollary bashes science and founds a megacorporation
21:30:16 * lispy_ bashes science and religion, writes a book and founds a mega-religion-corp.  Oh wait...Hubbard beat me to that...
21:30:57 * mwc grooves to Sin City sound track
21:33:08 * mwc bashes religion, science, and money, and goes to found a rock and roll band. He enjoys a few years of success, the blows his brains out with a shotgun after triple-overdosing on heroin.
21:33:52 <lispy_> @type let (<.>) x y z = 2 in (<.>)
21:33:54 <lambdabot> forall t t1 t2 t3. (Num t3) => t -> t1 -> t2 -> t3
21:34:10 <lispy_> @type let (<.>) x y z = 2 in 1 (<.>) 2 3
21:34:12 <lambdabot> forall t.
21:34:12 <lambdabot> (Num ((t_aPq -> t_aPz -> t_aPE -> Integer)
21:34:12 <lambdabot> -> Integer
21:34:12 <lambdabot> -> Integer
21:34:12 <lambdabot> -> t)) =>
21:34:25 <lispy_> @type let (<.>) x y z = 2 in 1 <.> 2 3
21:34:26 <lambdabot> bzzt
21:34:37 <lispy_> @type let (<.>) x y z = 2 in 1 2 <.> 2
21:34:40 <lambdabot> bzzt
21:34:44 <lispy_> @type let (<.>) x y z = 2 in 1 2 3 <.>
21:34:45 <lambdabot> bzzt
21:34:51 <lispy_> @type let (<.>) x y z = 2 in <.> 1 2 3
21:34:52 <lambdabot> bzzt
21:35:07 <lispy_> how do you use an operator that takes 3 arguments?
21:35:20 <lispy_> @type let (<.>) x y z = 2 in (1 <.> 2) 2
21:35:21 <lambdabot> forall t. (Num t) => t
21:35:31 <Cale> Some nice examples of GAP functions: IsElementOfMagmaRingModuloRelationsCollection AClosestVectorCombinationsMatFFEVecFFECoords NormalizedElementOfMagmaRingModuloRelations IsFullSubgroupGLorSLRespectingQuadraticForm CanonicalRepresentativeDeterminatorOfExternalSet
21:35:38 <Korollary> Cale: rofl
21:35:46 <lispy_> nice
21:36:02 <Korollary> Cale: they need modules or something to group the names
21:36:22 <Korollary> like Ring.Magma.yadda
21:36:29 <Cale> there's also a lot of names which specify the name of the algorithm which will be used
21:37:00 <Cale> but yeah, a module system is definitely needed
21:37:18 <Cale> as well as a better type system, and a saner implementation of lists
21:38:28 * Korollary totally ignores the math wizard demographic and writes an instant messenger client for the average Joe -> big buck$
21:38:45 <Pseudonym> Let me help you out there, Korollary.
21:39:04 <Korollary> Pseudonym: ok, you do the "targeted ads"
21:39:18 <Pseudonym> Cano9calRepresent8tiveDetermin8orOfExtrnlSet
21:39:36 <Pseudonym> Can probably compress that down a bit further into l33+ sp33k.
21:40:01 <Korollary> you forgot the "lol omg" at the end
21:40:01 <Pseudonym> In fact, an introduction to algebra that can fit in a few SMS messages might be a winner.
21:40:23 <Korollary> but is it hip enough ?
21:40:39 <Pseudonym> Yo, word.
21:40:46 * Korollary needs a mission statement for the IM client, btw
21:40:46 <Pseudonym> Or is that too 90s?
21:40:54 <Cale> C4n09c4lR3pr3z3nt8t1v3D373rm1n80r0fExtrnlS37
21:41:01 <Pseudonym> Oh, hang on.  I have a mission statement generator here.
21:41:16 <Korollary> that could be picked by the FBI agents in the channel as an attemp at encrypted comms
21:42:15 <Pseudonym> We innovate our business' benefits. We engagingly enhance our
21:42:16 <Pseudonym> customers' vibrant services while downsizing our ineffective content.
21:42:25 <Pseudonym> How's that?
21:42:35 <Korollary> it implies that we have ineffective content
21:42:40 <Pseudonym> Hmmm, good point.
21:42:41 <Pseudonym> Hang on.
21:43:01 <Pseudonym> The Key Mission:
21:43:01 <Pseudonym> We vitally enhance focussing on partners while envisioning
21:43:01 <Pseudonym> intellectual capital. We engagingly engage customers through rightsizing our
21:43:01 <Pseudonym> inefficiency.
21:43:13 <Korollary> lol
21:43:17 <Korollary> engagingly engage
21:43:20 <Pseudonym> Yeah.
21:43:22 * Pseudonym needs to fix that
21:43:45 <Korollary> swap vitally and engagingly
21:43:46 <Pseudonym> We engagingly excite communities while vigorously strategising
21:43:46 <Pseudonym> engaging our partners' technologies.
21:43:50 <Pseudonym> How about that?
21:44:00 <Korollary> communities ?
21:44:06 <Pseudonym> Yup.
21:44:11 <Korollary> it's too considerate. shareholders wont like that.
21:44:16 * Pseudonym got most of the nouns from "Weasel Words"
21:44:37 <Pseudonym> We excite partners. We engagingly enhance moving forward
21:44:37 <Pseudonym> intellectual capital while downsizing the obsolete aspirations. We vitally
21:44:37 <Pseudonym> pursue our partners' opportunities.
21:44:46 <Korollary> quite good
21:45:15 <Korollary> who are we partnered with, btw ?
21:45:24 <Pseudonym> Sorry, why does that matter?
21:45:34 <Korollary> good point
21:45:38 <Pseudonym> Nobody READS this stuff, you know.
21:45:42 <Korollary> if they push hard, tell them it's askjeeves.com
21:46:11 <Pseudonym> We enhance solutions by innovating focussing around our
21:46:12 <Pseudonym> key technologies. We engagingly innovate moving forward with our customers.
21:46:19 <Korollary> slam dunk
21:46:23 <Pseudonym> Love it.
21:46:24 <Korollary> we can't go wrong
21:46:50 * Korollary can imaging that in italics on a light blue background
21:47:04 <Pseudonym> The postmodernism generator was written by a friend of mine.  I'm using the same text generation engine.
21:47:26 <Pseudonym> http://dev.null.org/dadaengine/
21:47:29 <Pseudonym> Useful tool.
21:47:29 <Korollary> we have to combine that with the random CS paper generator and we can collect some venture capital.
21:47:34 <Pseudonym> Yeah!
21:48:04 <Korollary> We need a cheesy company name
21:48:16 <Pseudonym> Erm...
21:48:22 <Pseudonym> I already own futplex.org
21:48:24 <Korollary> something that emphasises our brutal technological superiority
21:48:40 <Pseudonym> Futplex Solutions?
21:49:01 <Pseudonym> Hang on, I'll try the silly word generator.
21:49:37 <Pseudonym> metaflodflod
21:49:40 <Pseudonym> I kinda like that.
21:49:45 <Pseudonym> But not corporate enough.
21:49:49 <Pseudonym> How about Meta Solutions?
21:49:57 <Pseudonym> iMeta?
21:50:03 <Korollary> hmm, overdone
21:50:10 <Pseudonym> Hmmmm...
21:50:11 <Pseudonym> xMeta
21:50:14 <Korollary> I need at least 6 letters, and preferably an x
21:50:35 <Pseudonym> 7 is usual.
21:50:46 <Pseudonym> Fadnox
21:51:11 <Pseudonym> Procolox
21:51:18 <Korollary> would be nice if it included (at least in part) words like data, variable, network, etc.
21:51:18 <Pseudonym> Sounds like an anti-depressant.
21:51:45 <Pseudonym> Neodatex
21:51:50 <Korollary> ooohh
21:51:57 <Korollary> straight out of a Gibson novel
21:51:59 <Pseudonym> Or even better: NeoDatex
21:52:26 <Korollary> would a double x at the be too much >
21:52:32 <Pseudonym> Not at all.
21:52:48 <Korollary> we can have them slightly on top of each other in the logo
21:53:20 <Korollary> The "Neo" bit is a huge win for the Matrix fans.
21:53:41 <Korollary> ahah. The product name is: Triniti
21:54:13 <Pseudonym> Great!
21:54:18 <Pseudonym> Or Morpheo
21:54:47 <Korollary> wow, something called Neodata already exists.
21:55:00 <Pseudonym> I love it when a bad joke turns out to be true.
21:55:35 <Korollary> yeah, too many of them turn out to be true, in fact
22:04:40 <Korollary> from a job ad: "Pluses: ... Strong understanding of Software Architecture
22:04:41 <Korollary>  "
22:24:58 <mwc> Hmm, I don't understand typeclasses apparently. I have a class State a where... and then I'm trying to make Maps (of Data.Map) from Int to Complex Double an instance, so I have: instance State (Map.Map Int (Complex Double)) where
22:25:53 <mwc> and that chokes GHCI with an error that the instance type must be of the form (T a b c) where a, b, and c are unique types. Don't get it, isn't that map a type of itself?
22:39:53 <Korollary> mwc: I think you want to paste more detail
22:49:04 <mwc> lisppaste2, url?
22:49:04 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:49:35 <dons> @paste
22:49:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:49:51 <dons> either is ok
22:54:02 <lisppaste2> mwc pasted "Instance Type Makes No Sense" at http://paste.lisp.org/display/11064
23:05:17 <Korollary_> mwc: it's got to do with (Map Int Magn) since it works if I replace it with just Int.
23:08:09 <mwc> Hmm, type Foo = Map.Map Int Magn compiles fine, also does bar = Map.singleton (0 :: Int) (0.0 :+ 0.0)
23:09:16 <Korollary_> yes
23:12:02 <mwc> I think i'd best go sleep on it
23:12:06 <mwc> tackle in the AM
23:12:11 <mwc> thanks for the help anyways
23:49:49 <boegel> goodmorning everyone !
23:49:50 <FrederikEaton> so does flippi use darcs or something?
23:50:03 <FrederikEaton> good morning goodmoring
23:50:08 <FrederikEaton> n
23:53:09 <Itkovian> meuning
23:55:21 * boegel shakes Itkovian's hand "Goodmorning mate"
23:55:50 <Itkovian> I vaguely recall seeing you earlier today
23:56:00 <FrederikEaton> *click*
23:56:06 <boegel> vaguely ? :)
23:56:15 <FrederikEaton> that's the sound of me deciding on a graduate school
23:57:47 <boegel> FrederikEaton: :)
23:59:21 <FrederikEaton> you're supposed to ask which one
