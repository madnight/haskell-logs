00:32:03 <rasfar> #haskell is so good, I tend to forget there are other lists.  Anyone care to mention some of their favourites?
00:35:48 <boegel> rasfar: #haskell is not a list :p
00:36:30 <rasfar> boegel: is it a monad?
00:36:59 <dons> maybe its a Chan
00:37:24 <boegel> rasfar: I have no idea, since I don't know what a monad is or how it works :)
00:37:56 * rasfar grins sheepishly
00:39:31 <autrijus> it may not be a list, but "#haskell comprehension" is a powerful technique nevertheless
00:43:55 <rasfar> @type (haskell :: Maybe Chan)
00:43:57 <lambdabot> bzzt
00:44:47 <rasfar> @type ( a :: Maybe Int )
00:44:48 <lambdabot> bzzt
00:45:26 <autrijus> @type ( Nothing :: Maybe (Maybe (Maybe something )) )
00:45:27 <lambdabot> forall something. Maybe (Maybe (Maybe something))
00:46:13 <rasfar> whoa! is that coincidence?
00:46:25 <cathper> ohh, I thought 'bzzt' was a snoring sound ;-P
00:46:41 <autrijus> what coincidence?
00:46:57 <humasect> Couldn't match `IO' against `(->) a'
00:47:07 <rasfar> "nothingmuch" joined just after that
00:47:17 <rasfar> nothingmuch: hi
00:47:19 <autrijus> lol
00:47:22 <nothingmuch> hi
00:47:26 <nothingmuch> after what?
00:47:39 <rasfar> We were discussing Maybe monad
00:47:44 <nothingmuch> ah
00:47:51 <autrijus> @type (Nothing :: Maybe (too much ))
00:47:52 <lambdabot> forall (too :: * -> *) much. Maybe (too much)
00:48:25 <nothingmuch> for all too smiley face much maybe too much
00:48:32 <nothingmuch> that doesn't read very well
01:04:05 <boegel> yo Itkovian
01:04:18 <boegel> you didn't fell asleep I hope ?
01:04:58 <Itkovian> i did sleep. up to brussels north
01:05:05 <Itkovian> meuning #haskell
01:05:11 <Itkovian> xerox: ping
01:06:17 <Itkovian> ok, I'll be afk for several moments, but don't hesitate to bug me
01:06:21 <Itkovian> hi shapr
01:06:26 * shapr bugs Itkovian 
01:06:29 <shapr> hi :-)
01:07:53 <boegel> y0 shapr, any progress on FLM ? :)
01:08:45 <shapr> Nope, sadly not.
01:09:13 * Itkovian has forgotten what FLM was, remind him
01:10:55 <boegel> Itkovian: Fermat's Last Margin, something shapr is working in that allows you take add notes to papers you're reading, and also share them with other (using darcs)
01:11:03 <Itkovian> right
01:11:12 <boegel> anyone can correct me if I told a lie somewhere :)
01:11:13 <Itkovian> the neat thingie
01:11:45 <humasect> sugar might help with this one
01:12:20 <boegel> humasect: sugar ? I'm not sure what you mean
01:12:46 <humasect> Couldn't match `IO' against `(->) a'
01:12:58 <humasect> in a case of type Maybe
01:13:08 <humasect> under an IO do
01:17:49 <humasect> @paste
01:17:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
01:18:47 <humasect> does it matter if one adds to the end or the beginning of this page?
01:19:36 <Itkovian> @where fps
01:19:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:22:35 <boegel> yo gour (gour as in gtk2hs gour ?)
01:22:48 <gour> yes
01:23:39 <boegel> well hi there :)
01:24:10 <shapr> bok gour
01:24:16 <gour> hi (after long time :-(
01:24:23 <gour> bok, shapr
01:25:20 <boegel> gour: how come ? why haven't you been here so long?
01:26:29 <gour> boegel: well, i just to moved to 14th ch of craft (still some old exercises to do), so would like to leran some more haskell 1st :-)
01:26:57 <gour> boegel: pls some other obligations
01:28:30 <humasect> @type :
01:28:31 <lambdabot> bzzt
01:28:47 <boegel> @type (:)
01:28:48 <lambdabot> forall a. a -> [a] -> [a]
01:28:58 <humasect> thx
01:29:02 <boegel> np :)
01:30:53 <rasfar> Just trying to build fps, and, when try "runhaskell build" I'm getting...
01:31:04 <rasfar> Could not find module `build':
01:31:14 <humasect> runhaskell Setup.lhs build
01:31:20 <Itkovian> rasfar: it's runhaskell Setup.hs build afaik
01:31:29 <Itkovian> or Setup.lhs
01:31:32 <rasfar> thanks bunches
01:32:21 <Itkovian> or you could ghc --make Setup.(l)hs -o setup && ./setup configure && ./setup build && ./setup install
01:32:31 <rasfar> dons: you may want to fix your README in this respect?
01:32:58 <rasfar> Itkovian: thanks but no thanks!
01:33:12 <Itkovian> eh? why?
01:33:33 <rasfar> oh - it seemed like a lot of typing, but I see it handles the whole process.
01:33:35 <Itkovian> saves typing runhaskell each time.
01:34:00 <rasfar> yes.  I had no idea what "runhaskell" was, but I guess it's some kind of ghc alias?
01:37:11 <rasfar> Whatever it is, it's a binary and it's identical to "runghc".
01:39:32 <dons> rasfar, thanks.
01:39:35 <dons> it's a typo.
01:39:42 <rasfar> a pleasure
01:40:44 <dons> rasfar, what's your interest in FPS?
01:41:41 <rasfar> dons, no particular reason, but it was just mentioned so I thought I'd check it out...
01:42:01 <dons> cool.
01:42:10 <rasfar> (I'm collecting code and practising builds.)
01:42:18 <xerox> Itkovian: pong!
01:42:23 <dons> you might like to check the testsuite
01:42:27 <xerox> @seen Pseudonym
01:42:28 <lambdabot> I saw Pseudonym leaving #haskell 1 hour, 4 minutes and 36 seconds
01:42:28 <lambdabot> ago.
01:42:36 <xerox> Goodmorning people.
01:43:21 <rasfar> dons, okay.  I see it is new this month!  Do you know of any applications yet?
01:43:26 <dons> cd tests ; GM4=m4 make ; make run
01:43:31 <rasfar> xerox, hi
01:43:55 <dons> rasfar, well h4sh uses it. darcs uses a flavour of it too.  (fps came from darcs)
01:44:12 <xerox> For your pleasure... <http://haskell.galois.com/~paolo/more-Haskell-cairo-porn.png>
01:44:25 <rasfar> dons, of course you'll notice but just in case, the line "runhaskell install" also needs the "Setup.hs" inserted.
01:44:47 <dons> pull the latest patch, should all be fixed now
01:44:49 <Itkovian> hi xerox
01:45:00 <boegel> xerox: w00 ! is that what you wanted to achieve ?
01:45:30 <Itkovian> xerox: nice pic
01:45:51 <xerox> boegel: nearly!  the grammar is still the direct (old) form, and the drawing process has to be fixed to look even more good ;)
01:46:17 <dons> xerox, nice.
01:46:24 <Itkovian> xerox: what do the || mean in the grammar rule?
01:46:36 <xerox> I have to find out how to use GtkComboBoxes and fix the GUI too.
01:46:41 <xerox> Itkovian: rotate pi
01:46:42 <dons> is this generated from a haskell description?
01:46:47 <Itkovian> ok.
01:46:54 <xerox> dons, Itkovian, boegel, thanks! :-)
01:47:08 <xerox> dons: no, from the string on top
01:47:12 <Itkovian> eh? I didn't do anything useful
01:47:22 <humasect> @type when
01:47:23 <lambdabot> bzzt
01:47:38 <xerox> Answering to the "nice" comments :-)
01:47:57 <humasect> @type (when)
01:47:59 <lambdabot> bzzt
01:48:23 <xerox> The google mentor about the pic: "Wow, that's rad!  I assume the function at the top controls the fractal?"
01:48:35 <xerox> hah.
01:50:27 <dons> how does the string/function at the top work?/
01:50:48 <dons> I find the syntax a bit weird ;)
01:50:56 <xerox> It's an L-system
01:51:19 <dons> can you explain it in a sentence, or should i google?
01:51:22 <xerox> @wikipedia Contex-free_(grammar)
01:51:24 <lambdabot> No result found.
01:51:29 <xerox> @wikipedia Contex-free
01:51:34 <lambdabot> No result found.
01:51:38 <xerox> @wikipedia Contex-free_grammar
01:51:43 <lambdabot> No result found.
01:51:44 <xerox> hmpf!
01:51:48 <shapr> context?
01:51:58 <xerox> err :-)
01:52:03 <xerox> @wikipedia Context-free_grammar
01:52:05 <lambdabot> http://en.wikipedia.org/wiki/Context-free_grammar
01:52:09 <xerox> Exactly.
01:53:04 <dons> ah, so L-systems are a 3d object specification language as functions?
01:53:26 <humasect> 3d turtle
01:53:30 <boegel> dons: you have a start string 'F', 1 rule in this case (F -> F[-...F], and a given angle (22.5) and iteration depth (5)
01:53:58 <boegel> dons: in xerox's case it's 2D I think, mine is 3D
01:54:05 <xerox> Yes.
01:54:33 <dons> ah ha. interesting. I think Sean Seefried would be interested in this, he works on 2-d (and now 3-d) EDSLs in Haskell for describing objects
01:54:34 <boegel> you can do _really_ cool stuff with it, just be changing a few characters in the rules you use :)
01:54:47 <xerox> The final aim is making this in Haskell: http://www.ozonehouse.com/ContextFree/
01:54:50 <boegel> dons: show him the HaskLS website :)
01:54:55 <Itkovian> duh! http://news.yahoo.com/photo/050830/photos_ts_afp/050830071810_shxwaoma_photo1 and http://news.yahoo.com/photo/050830/480/ladm10208301530
01:55:05 <Itkovian> white people 'find', back people 'loot'
01:55:14 <Itkovian> unbelievable
01:55:20 <dons> boegel, HaskLS?
01:55:35 <boegel> dons: http://scannedinavian.org/~boegel/HaskLS
01:56:12 <boegel> Itkovian: omg :s but the black guy does have more stuff with him (which doesn't mean he actually is looting, but makes it more likely)
01:56:19 <dons> oh right. I didn't know that was its name :)
01:56:36 <Itkovian> come on, for all they know it was drifting on the water
01:56:53 <boegel> Itkovian: I guess some racist-kinda-person commented the pics
01:57:00 <vegai> the white people just bumped into some milk and bread on their way :-P
01:57:15 <Itkovian> lol
01:57:52 <Itkovian> is there a function to interlleave a [String] with "::" and concatenate the whole lot ?
01:58:00 <boegel> I heard 80% of New Orleans is flooded :s
01:58:14 <boegel> @type concat
01:58:20 <dons> Itkovian, intersperse, concat
01:58:21 <lambdabot> forall a. [[a]] -> [a]
01:58:24 <kosmikus> TheHunter: thanks
01:58:50 <Itkovian> dons: thx
01:59:02 <boegel> @plugs concat ["This ","is ","a "," sentence"]
01:59:05 <lambdabot> "This is a  sentence"
01:59:06 <dons> @eval concat $ List.intersperse "::" ["haskell","String"]
01:59:07 <lambdabot> "haskell::String"
01:59:26 <boegel> oh, you mean like that :) sowwy :)
01:59:31 <Itkovian> yes, like that
01:59:41 <Itkovian> dons: a second use for h4sh ;-)
01:59:55 <dons> yay!
02:00:23 <boegel> @plugs concat $ map (\s -> s ++ "::") ["test",bleh","foo",bar"]
02:00:25 <lambdabot> 57: Not in scope: `bleh'64: Not in scope: `foo'
02:00:54 * boegel scratches his head
02:01:01 <xerox> Missing '"'
02:01:14 <boegel> xerox: oh, right
02:01:15 <Itkovian> boegel: that would add a "::" at the end too ...
02:01:18 <boegel> @plugs concat $ map (\s -> s ++ "::") ["test","bleh","foo",bar"]
02:01:19 <lambdabot> 85: lexical error in string/character literal
02:01:22 <boegel> Itkovian: yeah I knwo :p
02:01:25 <Itkovian> lol
02:01:28 <boegel> @plugs concat $ map (\s -> s ++ "::") ["test","bleh","foo","bar"]
02:01:30 <lambdabot> "test::bleh::foo::bar::"
02:01:39 <dons> isn't that map (++ "::")
02:01:42 <boegel> Itkovian: I was just trying you know ;)
02:01:46 * Itkovian drinks coffee
02:01:47 <xerox> Yes
02:01:49 <boegel> @plugs concat $ map (++ "::") ["test","bleh","foo","bar"]
02:01:51 <lambdabot> "test::bleh::foo::bar::"
02:01:54 <dcoutts> morning folks
02:01:57 <humasect> does a "case of" with _ params combine ?
02:01:58 <boegel> dons: yeah, sure
02:02:00 <xerox> Hello dcoutts!
02:02:03 <boegel> y0 dcoutts
02:02:05 <dcoutts> hia xerox
02:02:05 <dons> this is the difference between darcs unlines and official unlines, btw
02:02:05 <Itkovian> dcoutts: hi.
02:02:12 <dons> darcs unlines does map (++ "\n")
02:02:36 <dcoutts> ah boegel Itkovian you've seen xerox's latest screenshots?
02:02:39 <dons> prelude unlines uses intersperse (well, a function equivalent to it)
02:02:52 <rasfar> dons: do you absolutely need GNU m4 to build the test suite?
02:02:54 <boegel> dcoutts: he just showed us one, are there any more ?
02:02:58 <Itkovian> dcoutts: I have. I haven't installed gobby yet though
02:03:03 <dcoutts> oh ok
02:03:06 <Itkovian> can't you people use subEthaEdit?
02:03:10 * xerox hugs gobby
02:03:21 <dons> rasfar, to run the HUnit stuff. to just run the QuickCheck code: runhaskell Quick.hs (after you've installed)
02:03:22 <xerox> Itkovian: it's OS X only!  Sob.
02:03:29 <Itkovian> xerox: I know ;-)
02:03:40 <Itkovian> let me rephrase
02:03:47 <Itkovian> can't you people buy a mac?
02:03:50 <dcoutts> I've been quite impressed with gobby too
02:03:56 <dcoutts> Itkovian, hah!
02:04:04 <dons> but yes, the HUnit stuff needs m4 for determining line numbers in the test script -- then you know which exact assert failed.
02:04:07 <rasfar> dons: thanks for that
02:04:13 <xerox> When they pay me.. perhaps :)
02:04:17 <dcoutts> you know we'd only end up running linux on it, so what'd be the point?
02:04:41 <dcoutts> ok, we/I
02:04:46 <xerox> heh :-)
02:05:02 <humasect> can i combine values like (_,True) and (True,_) together?
02:05:10 <humasect> say to get (True,True)
02:05:14 <xerox> @type curry and
02:05:16 <rasfar> I do have m4; but GNU m4 isn't in ports (OpenBSD), and when I run "env GM4=m4 make" it complains it's not GNU...
02:05:20 <lambdabot> bzzt
02:05:21 <Itkovian> dcoutts: come on, MacOSX is very good
02:05:24 <xerox> oops.
02:05:43 <dcoutts> Itkovian, yeah, it's better than windows
02:05:59 <rasfar> Anyway, I've got enough to go with for the moment...
02:06:15 <Itkovian> dcoutts: the UI is better than X too. and it's BSD underneath.
02:06:16 <xerox> @pl \(_,True) (True,_) -> (True,True)
02:06:17 <lambdabot> const (join (,) . snd)
02:06:22 <xerox> :-)
02:06:42 <dcoutts> Itkovian, but it's not as good for development, basically because linux is the native envirnoment for most progs/developers. So stuff works for linux first and is ported elsewhere
02:06:49 <humasect> =D thanks xerox
02:07:06 <xerox> humasect: I hope it works for you.
02:07:21 <dcoutts> Itkovian, and that's not necessarily anything to do with how "good" either platform is
02:07:27 <boegel> dcoutts: I thought usually stuff worked for windows first, and then gets ported elsewhere :)
02:07:41 <humasect> i'm trying to combine a case within an io recursion, we'll see
02:07:53 <Itkovian> boegel: welcome to the 21st century
02:07:59 <dcoutts> boegel, hmm, I suspect more stuff is ported to windows from linux than the other way around
02:08:08 <dons> rasfar, m4 is in the ports
02:08:18 <boegel> dcoutts: hmm, I'm not entirly sure about that :)
02:08:33 <dons> rasfar, devel/m4
02:08:36 <gour> boegel: from windows to nowhere :-)
02:08:52 <dcoutts> gour, long time no see!
02:08:56 <xerox> Itkovian: does the parser accept newlines?
02:08:59 <rasfar> dons, is that different from /usr/bin/m4?
02:09:12 <Itkovian> xerox: let me see.
02:09:13 <dcoutts> gour, btw, I'm off to Croatia tomorrow morning
02:09:15 <rasfar> (I guess it wouldn't be in ports if it wasn't, never mind.)
02:09:19 <gour> dcoutts: true
02:09:19 <Itkovian> boegel: can you add LSP.hs to the repos?
02:09:34 <gour> dcoutts: where r u going?
02:09:36 <Itkovian> xerox: a sec, I'm busy for a few secs
02:09:44 <dons> rasfar, yep. the gnu m4 is called gm4 on OpenBSD
02:09:59 <dcoutts> gour, Cres
02:10:11 <xerox> Cool
02:10:13 <Itkovian> xerox: I suspect (whiteSpace lang) does accept \n as newlines
02:10:19 <gour> dcoutts: beautiful island, how long?
02:10:30 <dcoutts> gour, about a week
02:10:54 <gour> dcoutts: huh, i probably won't go there :-(
02:11:07 <dcoutts> gour, oh well :-(
02:11:07 <dons> rasfar, you're actually on OpenBSD - this will be interesting. you can do some debugging for me if you're up to it.
02:11:15 <dcoutts> gour, we're doing a Gtk2Hs release today with the new cairo stuff :-)
02:11:23 <xerox> Parses any white space. White space consists of zero or more occurrences of a space, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the LanguageDef that is passed to makeTokenParser.
02:11:40 <gour> dcoutts: great, i regularly provide darcs mirror
02:12:04 <dcoutts> gour, oh that's working now is it?
02:12:07 <rasfar> dons, sure, that would be great.  If you need to email, rasfar at gmail works.
02:12:22 <gour> dcoutts: i'm however reluctant to put that 'same category' stuff on the web
02:12:25 <humasect> @eval (True,_) (join (,) . snd) (_,True)
02:12:28 <lambdabot> 24: Pattern syntax in expression context: _45: Pattern syntax in
02:12:28 <lambdabot> expression context: _
02:12:39 <dons> ok. have you got gm4 yet? there's something I want to test.
02:13:06 <boegel> Itkovian: there parser ? yeah sure
02:13:32 <dcoutts> gour, what's the issue with it going public? eg on haskell.org ?
02:13:56 <Itkovian> boegel: like that everybody can use it while I hack away at it ...
02:14:09 <gour> dcoutts: to have darcs & tailor there ;)
02:14:21 <Itkovian> is there something like an intersperse in Parsec? to interleave parsers in a sequence of other parsers?
02:14:22 <dcoutts> gour, ok, is that all?
02:14:25 <xerox> Dob.
02:14:30 <Itkovian> @type List.intersperse
02:14:31 <lambdabot> forall a. a -> [a] -> [a]
02:14:32 <gour> dcoutts: atm i'm doing rsync with my local machine
02:15:01 <gour> dcoutss: otherwise, nothing speciail
02:15:29 <dcoutts> gour, right, so it's just waiting for a recent version of darcs to be installed on haskell.org and then spending the time to get it set up?
02:16:22 <gour> dcoutts: true, and I regularly pull from tailor repo
02:16:30 <dons> Itkovian, btw: $ words a b c | between "::" | concat
02:16:30 <dons> a::b::c
02:16:37 <dcoutts> kosmikus, did you install darcs on haskell.org in /usr/local ?
02:16:43 <rasfar> dons: whew! it built.  I ended up changing "m4" to "gm4" in the Makefile though.
02:16:57 <dons> also works if you use the environment var GM4
02:17:08 <dons> rasfar, ok. now,. dooes gmake run work?
02:17:12 <gour> dcoutts: btw, i also installed on my machine trac http://projects.edgewall.com/trac/
02:17:12 <rasfar> dons: Also, logpp needs to be executable.
02:17:19 <Itkovian> dons: thx
02:17:21 <dons> yep. darcs --set-scripts-executable
02:17:24 <gour> dcoutts: lele wrote a darcs backend :-))
02:17:32 <rasfar> (I thought "env GM4=gm4" would do that.)
02:17:53 <rasfar> oh.  right, I heard about that.
02:18:04 <Itkovian> is this only an impression or has haskell received a speedup in the last few months?
02:18:35 <dons> speedup?
02:18:57 <dons> metaphorically, or literally?
02:18:58 <gour> growup?
02:19:03 <dcoutts> gour, a darcs backend for what?
02:19:06 <boegel> Itkovian: added LSP.hs to the darcs repo... can someone test it though ? :)
02:19:15 <gour> dcoutts: for Trac
02:19:26 <gour> dcoutts: ne need to use svn
02:20:03 <Itkovian> boegel: thx.
02:20:09 <rasfar> dons, yes, either "make" or "gmake" work, once the GM4 environment is good.
02:20:21 <Itkovian> boegel: can you mail it to pieter?
02:20:25 <kosmikus> dcoutts: I think it's installed in my home, but executable for everyone; why?
02:20:25 <Itkovian> he's at ugent.be
02:20:30 <dons> rasfar,do you mean the testsuite runs correctly?
02:20:36 <Itkovian> webmail refuses to add attachments
02:20:53 <rasfar> Oh, you mean "gmake run" literally ... one moment ....
02:21:03 <dcoutts> kosmikus, there is darcs-1.0.2 installed on haskell.org in /usr/local/bin
02:21:08 <rasfar> cool...
02:21:36 <rasfar> Cases: 39  Tried: 39  Errors: 0  Failures: 0
02:21:36 <rasfar> ]
02:21:43 <dons> then my next question is: which .cabal file did you use?
02:21:44 <dcoutts> kosmikus, for setting up a darcs mirror of the Gtk2Hs cvs repo we need darcs-1.0.3 (and some python prog)
02:21:47 <dons> mmap or no-mmap
02:22:27 <dons> and my next-to-next question is: which OpenBSD (exactly build date) are you running?
02:22:30 <rasfar> oh ... I guess I used the fps.cabal.no-mmap, thinking that was maybe my original problem.  I'll try it all now with mmap.
02:23:07 <dcoutts> gour, actually that's a good point, you can install darcs in your home dir
02:23:09 <dons> ok, no-mmap is known to work on openbsd. mmap works with a little hack, but I'd like to see if it works for you first, before I tell you the hack
02:23:14 <rasfar> I'm using 3.7 -release.  I'd rather not move to anything else at the moment, as it's my ONLY SYSTEM, and I had problems with 3.6 with snaps
02:23:26 <dons> no, that's fine. you won't have to move anything :)
02:23:28 <boegel> Itkovian: the source or the darcs link ?
02:23:29 <kosmikus> dcoutts: could have been me, yes
02:23:29 <gour> dcoutts: what about tailor?
02:23:45 <Itkovian> the source, I don't think he's got darcs (yet).
02:23:54 <boegel> Itkovian: kay, will do
02:24:31 <dons> rasfar, there's been all these changes to mmap and malloc, and I'm trying to work if the mmap bug I see is still there in other -current systems
02:26:11 <rasfar> dons, oh yeah, I read about that.  I'd love to help, but unfortunately I can't compromise my system.  I use it for "everything".
02:28:32 <rasfar> dons, same results with mmap; but unless I misunderstood, this isn't useful info since 3.7 -release is too old?
02:28:58 <rasfar> dons, If you want to donate hardware, I'd be happy to test -current!
02:40:04 <rasfar> dons, I heard the new mmap/malloc stuff broke clist and gprolog, but rumour has it (Hannah Schroeter) that ghc will come through okay...  Can you confirm?
02:41:31 <dcoutts> gour, haskell.org now has darcs-1.0.3 thanks to kosmikus
02:42:00 * rasfar realises the time, and thinks bed is a good idea -- g'night haskellers.
02:42:54 <gour> dcoutts: fine
02:43:24 <dcoutts> gour, and you can grab the tailor script yourself?
02:43:47 <gour> dcoutts: ..and put it where?
02:43:59 <dcoutts> gour, in your home dir?
02:44:13 <gour> dcoutts: ok
02:44:48 <dons> rasfar, ok. that's interesting to know that mmap works ok for you.
02:45:41 <dcoutts> gour, so it'll use the SourceForge anon cvs?
02:45:54 <rasfar> dons, yes.  I actually deleted the download and did it again, just in case something wasn't being rebuilt, and it does work.
02:46:16 <dons> 3.7-current (GENERIC) #191: Tue Jun 14 has a problem for me.
02:46:19 <Itkovian> ok, what do I do now? I've added LSP.hs to my local haskls repos, as I wrote the file, and boegel's added it to the central repos. So, if I pull, it will try to get LSP.hs from the central repos. Do I ignore it, pull, or first remove my copy? Or something else?
02:46:43 <dons> afaik, ghc is ok with the new changes.
02:46:48 <gour> dcoutts: yes
02:46:58 <dcoutts> gour, ok cool
02:47:00 <rasfar> dons, I think I'll invest in another HD, and follow -current again.  (I used to, but one disc -- luckily that, experimental, one -- died in June.)
02:47:16 <dons> for example, all the Haskell apps are still building on latest current.
02:47:45 <gour> dcoutts: will try to do that soon, maybe today
02:47:49 <rasfar> dons, good to know.  Haskell is important enought to me, I would change OS's if it wasn;t avail!
02:47:55 <dons> also, nightly builds of ghc stable and head are fine on 3.7-current (GENERIC) #239: Tue Jul 12
02:48:28 <dons> what did Hannah say, was it posted to misc@ or ports@?
02:48:41 <xerox> Itkovian: I'd suggest to move your copy out of the repo, pull, and check for differences.  If you make changes, record them and send them.
02:48:49 <dcoutts> gour, cool, no rush however
02:49:11 <Itkovian> xerox: ok.
02:49:33 <rasfar> dons, It was on misc@ ... let's see: http://marc.theaimsgroup.com/?l=openbsd-misc&m=112488641802806&w=2
02:49:57 * pesco yawns
02:50:10 <pesco> Good morning, #haskell!
02:50:28 <gour> dcoutts: where to put repo, $/repos/gtk2hs ?
02:50:31 <rasfar> pesco, good morning -- and, for me, goodnight!
02:50:42 <pesco> Sleep weel.
02:50:45 <pesco> well.
02:50:50 <dons> ok. I was surprised that nothing seems to have broken (well, except maybe this obscure finalizer code in fps)
02:51:33 <dcoutts> gour, I'd start by putting it in your ~/public_html/gtk2hs/ dir
02:51:49 <dons> rasfar, as it is, head and stable keep happily building nightly on my build box, so ghc on OpenBSD will be well supported for a while yet.
02:51:50 <rasfar> (thnx) pesco; dons, it's been good chatting, but it's after 4am my time, and I gotta move to new pad tomorrow ....
02:51:57 <gour> dcoutts: ok. have you seen trac?
02:52:02 <dcoutts> gour, and then we can move it over to somewhere under the main gtk2hs web site when it seems to be working
02:52:15 <dcoutts> gour, no, I don't know about trac
02:52:35 <rasfar> dons, awesome: I like OpenBSD and Haskell alot.  G'nite.
02:52:53 <boegel> yo pesco
02:52:55 <gour> dcoutts: http://projects.edgewall.com/trac/
02:53:17 <boegel> g'night rasfar
02:53:42 <gour> dcoutts: there's no publi_html in my dir. am i allowed to make it & use it?
02:54:34 <dons> rasfar, btw, maybe you don't know about: http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
02:55:21 <Itkovian> boegel: I guess you should apply the patch I send you too, without the LSP.hs stuff
02:55:33 <boegel> Itkovian: okay, I will
02:55:44 <Itkovian> boegel: don't mess up the repo, eh.
02:55:48 <gour> dcoutts: i'm busy now, but you can reply, i'll see it later, bye :-)
02:56:05 <boegel> Itkovian: I'll try :)
02:56:20 <boegel> and if I do mess up, I'll mess it up locally first :)
02:57:55 <rasfar> dons, yeah I knew you were the culprit in charge of the port; hadn't seen that web page for a while though.  Good to have.  Now, if you cause my computer to beep one more time so I have to get out of bed I'll ... I'll ... I'll have to sleep on it!
02:57:59 <boegel> yo dblhelix
02:58:10 * boegel leaves for lunch
02:58:12 <dblhelix> yo boegel
02:58:20 <dblhelix> boegel: eet smakelijk
02:58:45 <dons> oh, you should turn off beeping rasfar.
02:58:48 <dcoutts> gour, yeah you can just create public_html in your home dir. Just make sure it's permissions are readable to the web server. Then you can see the results at http://haskell.org/~gour/
03:00:15 <xerox> dcoutts: is there a way to add text in the comboboxes in the .glade file?
03:08:29 <Itkovian> @pointless let cpi=(\x -> map show $ (: []) $ (\(x:y:[]) -> y/x) $ map (read) $ tail x)  in let h = map (\x -> concat $ Data.List.intersperse "::" (x ++ (cpi x))) in let g = ( unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) . lines) in  unlines . h . g
03:08:30 <lambdabot> (line 1, column 43):
03:08:30 <lambdabot> unexpected "["
03:08:30 <lambdabot> expecting natural, identifier, "_" or "("
03:08:37 <Itkovian> what's wrong with that?
03:19:37 <dcoutts> xerox, no that has to be done in the program I think
03:23:50 <Beelsebob> dcoutts: Tom Shakell (MSN) 11:21 FFI is done by you write a haskell function with "foreign" you then call nhc98 with -bcwrap and it generates a wrapper c file. You compile this with your code into a shared library (DLL/so).
03:25:37 <dcoutts> Beelsebob, ok, I'll probably need to look at the generated code and modify it since I'm not doing trivial things.
03:25:48 <Itkovian> what is more elegant?
03:25:58 <Beelsebob> m'kay
03:26:00 <Itkovian> either let f = (\n x -> let (h,t) = splitAt n x in if null t then [h] else h:(f n t)) in f 3 [1..117]
03:26:11 <Itkovian> or ( unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs))
03:26:13 <Itkovian> ?
03:28:14 <dcoutts> Beelsebob, this is the code I've got for ghc: http://cvs.sourceforge.net/viewcvs.py/gtk2hs/gtk2hs/glib/System/Glib/hsgclosure.c?rev=1.2&view=auto
03:28:14 * Itkovian eats
03:28:39 <dblhelix> Itkovian: they're both ugly ;), but I'd go for the latter
03:29:02 <Beelsebob> for ghc?
03:29:05 <dcoutts> Beelsebob, the interesting bit is hsg_closure_marshal, we loop over an array of C "generic values" and construct a Haskell function call from it.
03:29:25 <dcoutts> so it's quite dynamic
03:29:32 <dcoutts> yes, this is using ghc's C api
03:29:43 <Beelsebob> m'kay... hang on... I'll prod tom
03:29:47 <dcoutts> I'd be looking for something similar for nhc
03:31:07 * gour is away: I'm busy atm with some other stuff
03:32:02 * shapr is here: I'm trying to keep from working
03:32:02 <Beelsebob> dcoutts: He says it'll be a while before it does anything that complex... but the implication is that it will do something that complex in the future
03:32:06 <Beelsebob> (2.0)
03:32:15 <dcoutts> ok, great
03:41:33 <xerox> dcoutts: <property name="items" translatable="yes">Line in
03:41:33 <xerox> Microphone
03:41:33 <xerox> CD</property>
03:41:34 <xerox> :-D
03:59:23 * shapr cackles evilly
03:59:35 * xerox is tired of designing GUIs
03:59:51 * shapr hugs xerox 
03:59:56 * xerox hugs back
04:01:06 <vegai> shapr: wiki told me that you've been thinking about a mail client
04:01:28 <shapr> Long ago and far away...
04:01:29 <vegai> truthfullness?
04:01:36 <shapr> Nowadays I'd use riot or yi for a mail client.
04:01:36 <vegai> ah
04:01:55 <vegai> really? How?
04:01:56 <shapr> riot has a somewhat mutt-like interface.
04:02:17 <shapr> And I'd hack postmaster for the mail shipping code.
04:02:26 <vegai> ah, 'use' in that sense
04:02:45 <vegai> I'm thinking of something more mailx-like
04:02:54 <shapr> I haven't used mailx.
04:03:02 <vegai> a commandline app basically
04:03:17 <xerox> boegel: piiing
04:05:23 <shapr> vegai: Seen postmaster?
04:05:42 <boegel> xerox: poooong
04:05:42 <dcoutts> xerox, ok fair enough
04:05:44 <dons> riot even knows how to pars mail boxes
04:05:57 <dons> parse. /me types too fast again
04:06:27 <shapr> irc is the written equivalent of talking in a loud crowded pub.
04:06:43 <boegel> shapr: yeah, it is :) so many background noise ;)
04:06:53 <shapr> Say what? I can't hear you over #debian...
04:06:56 * shapr snickers
04:06:56 <autrijus> that's what you get with a multiplayer cat.
04:07:01 <autrijus> line-buffered, too
04:07:02 <shapr> haha
04:07:11 <dcoutts> xerox, hmm I'm trying to write the release announcement...
04:07:29 * boegel smuggled some candy inside and feasts on it
04:07:50 <xerox> dcoutts: oh nice
04:08:29 <ScottPlantagenet> geek power
04:08:50 <xerox> boegel: I was wondering how do you get fixed-width the side with buttons in HRay
04:10:38 <boegel> xerox: I didn't use glade for HRay, I hardcoded it
04:10:47 <boegel> I think ^_^
04:11:01 <xerox> Oh.
04:11:56 <boegel> but you should be able to do it with glade too though
04:12:10 <shapr> hiya ScottPlantagenet, are you learning Haskell?
04:16:19 <boegel> xerox: checking it now...
04:16:50 <boegel> xerox: you could use a combination of glade and hardcoded stuff though, if you can't seem to find the option you're looking for in glade
04:17:57 <xerox> boegel: I'd like to be able to set the width of a box in a [hv]box
04:18:08 <xerox> that would be enough for now.
04:19:47 <boegel> xerox: heh, the width isn't fixed at all in my GUI :) if you resize the window, you can make the right box wider
04:19:52 * gour is back.
04:19:57 <boegel> so I'm not the man you should be asking this :)
04:20:10 <xerox> Mumble.. thanks.
04:20:57 <boegel> xerox: wait
04:21:24 <boegel> xerox: this is how I seemed to set the (fixed) size for the scroll window: 'widgetSetSizeRequest scrollWindow 800 600'
04:21:28 <boegel> maybe this can help ?
04:21:34 <boegel> wb Itkovian
04:21:35 <shapr> +++ATH All your Hayse are belong to us.
04:21:44 <shapr> um, Hayes*
04:23:01 <Itkovian> pompom
04:23:21 <Itkovian> dblhelix: have you got a more elegant proposition?
04:23:30 <xerox> boegel: yes sire request is the thing, a kind gtk guy is helping me out too, forutnately :-)
04:23:34 <Itkovian> I do not recall who gave the unfoldr thingie, I guess it was dons
04:24:09 <xerox> boegel: my ideas were "wrong", forcing sizes as I wanted isn't the best thing, thinking of people with {double,half}-sized fonts, for example.
04:24:54 * shapr boings
04:25:47 <xerox> Ah!  I can set "homogenous" and "expand" on boxes too, cool!
04:28:44 <boegel> xerox: yeah, I try to avoid that too, but it isn't always that easy
04:29:11 <xerox> I found that making a size request on the right box did it.
04:29:24 <boegel> xerox: yaay !
04:29:31 <dcoutts> xerox, however that makes it a minimum size too you know
04:29:32 <xerox> Now I should probably add scollbars to the textEntry
04:29:42 <xerox> dcoutts: and it's a good side-effect.
04:29:47 <dcoutts> ok
04:30:55 <boegel> xerox: you can check how to do that in my GUI code, I use a scroll pane for the rendered image
04:30:55 <dcoutts> xerox, I'm wondering about screenshots for the release announcement
04:31:05 <boegel> dcoutts: the 1.0 release ?
04:31:12 <xerox> dcoutts: which screenshot would you prefer?
04:31:20 <xerox> ScrollPane, /me searches
04:31:28 <boegel> dcoutts: oh ,the cairo release :)
04:31:29 <dcoutts> boegel, no, it's a special release for the completion of xerox's project
04:31:42 <dcoutts> xerox, that's up to you really
04:31:48 <boegel> dcoutts: if I were you, I'd add quite a few nice ones
04:31:49 <xerox> I'm "mosly" done with this LSystem thing
04:31:57 <xerox> I'm redesigning the GUI as you see
04:32:30 <dcoutts> xerox, I was thinking that you might put them up in a blog post and I'd just link to it, or perhaps put one or two nice ones in the release announcement itself
04:32:30 <xerox> I would like to have boegel write some LSystem to do nice shots :-D
04:32:59 <xerox> dcoutts: OK.  I'll try to have it working very soon
04:33:15 <xerox> Do you want to do it immediately?  I'm not so far from having it working.
04:33:19 <dcoutts> I liked this one I did:
04:33:20 <dcoutts> http://haskell.org/~duncan/cairo/lsystem-demo/LSystem.png
04:33:30 <kosmikus> earthy: ping
04:33:37 <dcoutts> xerox, no, immediate is not required
04:33:45 <dcoutts> I'm still writing stuff
04:33:48 <xerox> dcoutts: yes!  I moved the stroke inside to test if I could do a similar stuff
04:34:07 <xerox> I could stop playing with the guy and finish the code :-)
04:34:08 <dcoutts> and this one is nice:
04:34:09 <dcoutts> http://haskell.org/~duncan/cairo/lsystem-demo/spiro.png
04:34:34 <dcoutts> the screenshots have to be of a reasonable size
04:34:40 <dcoutts> probably 640x480 max
04:34:44 <xerox> Sure
04:34:50 <dcoutts> preferably a little smaller
04:35:05 <dcoutts> eg 400 or 500 ish
04:36:16 <dcoutts> xerox, you got the details I told you about using the gallery stuff?
04:36:23 <xerox> Yes
04:36:26 <dcoutts> good
04:36:38 <shapr> salut lupo
04:36:52 <shapr> Are you learning Haskell?
04:37:40 <Muad_Dibber> oh no
04:37:47 <Muad_Dibber> shapr is on his "helpfull" tour again
04:37:59 * shapr quickly educates Muad_Dibber
04:38:15 <Muad_Dibber> not.possible...will......resist...........
04:39:04 <boegel> lupothegreen: hiya ! interested in Haskell ?
04:39:21 <boegel> Muad_Dibber: it's probably due to shapr that so many people keep coming here (yes, including you !)
04:39:36 <shapr> Due to me? Is it the singing and dancing?
04:39:41 * shapr does a tap dance
04:39:51 * shapr sings along with the dogs howling
04:40:16 * Itkovian shuts his ears
04:40:42 * vegai smirks
04:40:42 * Itkovian runs
04:41:22 <vegai> shapr: No, I haven't seen postmaster
04:41:51 <vegai> the esmtp server?
04:41:54 <shapr> Yup
04:42:38 * boegel replays the tape he just recorded of shapr dancing and decides to publish it
04:42:45 <shapr> w00 BODcasting!
04:42:47 <vegai> I'm not worried about such things yet.
04:42:56 <vegai> the first goal is to just read stuff out of maildirs
04:42:57 * shapr casts his sexy bod
04:43:08 <xerox> http://haskell.galois.com/~paolo/Six.png
04:43:09 <vegai> if I get that done, my itch has been scratched
04:43:12 <xerox> Do you like it?
04:44:57 <Itkovian> xerox: what is it?
04:45:13 <shapr> vegai: Riot can read maildirs.
04:45:22 <shapr> er, mailboxes
04:45:23 <xerox> Itkovian: the GUI for the LSystem cairo thing
04:45:33 * shapr suddenly isn't sure if riot does maildirs.
04:46:05 <vegai> wasn't riot just an outlining editor?
04:46:22 <shapr> Yeah, but it stores the outlines as mailboxes I think.
04:46:23 <Itkovian> ok
04:46:27 <vegai> ah
04:46:34 <Itkovian> what will those values do?
04:46:39 <shapr> vegai: http://modeemi.fi/~tuomov/riot/
04:47:13 <Muad_Dibber> boegel: as a note: of course we all come here for shapr!
04:47:18 <boegel> Itkovian: resolution, position, depth probably
04:47:26 <Itkovian> ok.
04:47:39 * shapr proudly displays his "Order of the Golden Charming Lambda" award.
04:47:49 <boegel> and some additional stuff, because there are 7 parameters
04:47:56 <Itkovian> @dice 1d20
04:47:57 <lambdabot> 1d20 => 14
04:48:03 <boegel> Itkovian: ?
04:48:06 * Itkovian avoids the charm
04:49:21 <shapr> @dice 99d9999999999999999999999999999999999
04:49:22 <lambdabot> 99d9999999999999999999999999999999999 => 6
04:49:31 <Muad_Dib> whoops, got punished right away :P
04:49:32 <Itkovian> wussie
04:49:37 <shapr> I keep getting negative numbers from that dice roll.
04:49:38 <shapr> @dice 99d9999999999999999999999999999999999
04:49:39 <lambdabot> 99d9999999999999999999999999999999999 => -1
04:49:44 <shapr> How can dice roll negative?
04:49:55 <Itkovian> ah, but they are magic dice, eh
04:49:58 <nnunley> Overflow?
04:49:58 <shapr> Ah right.
04:50:04 <shapr> Yeah, looks like an overflow to me.
04:51:43 <xerox> Itkovian: err, right, I didn't add labels :-D
04:52:02 <xerox> Maybe it uses Int instead of Integer.
04:54:59 <dons> overflow, really? hmm.
04:55:33 <dons> ah, it is Int.
04:55:58 <dons> and if n > 100, it does some truncating
04:56:12 <Itkovian> bummer
05:05:22 <Itkovian> pffft
05:07:40 * Itkovian procrastinates
05:07:52 <kosmikus> earthy: problem solved?
05:13:20 <boegel> are there any bibtex related tools available for Haskell ?
05:14:41 <kosmikus> there's a bibtex parser for the uust parser combinators available somewhere at .uu.nl
05:15:14 <vegai> hmh, implementing a readline replacement in pure haskell isn't as glorified as I first thought ...
05:15:22 <boegel> kosmikus: 'somewhere' doesn't help me :) :p
05:15:52 <kosmikus> boegel: google?
05:17:33 <Muad_Dibber> http://www.haskell.org/pipermail/haskell/2005-April/015656.html
05:20:56 <earthy> kosmikus: doaitse's problem was solved by this, yes. ;)
05:22:19 <kosmikus> earthy: any other problems left?
05:22:28 <earthy> well...
05:22:57 <earthy> there's a feature request that might be served by careful diffing of my lhs2TeX.sty and yours
05:23:07 <kosmikus> which one/
05:23:18 <boegel> Muad_Dibber: thanks
05:23:22 <earthy> that of being able to usepackage lhs2TeX.sty
05:23:41 <earthy> as that'd allow one to *not* have to run the main .tex file for an article through lhs2TeX
05:23:56 <dons> @pl let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
05:23:57 <lambdabot> (line 1, column 5):
05:23:57 <lambdabot> unexpected "("
05:23:57 <lambdabot> expecting natural, identifier or "in"
05:24:00 <dons> :/
05:24:17 <kosmikus> earthy: that's a minor benefit only, isn't it?
05:24:46 <earthy> but now that I see your mail, Doaitse actually used %include lhs2TeX.sty instead of %input
05:24:58 <kosmikus> sorry, my mistake
05:25:01 <kosmikus> %include is correct
05:25:08 <earthy> ah. hm. it still didn't work...
05:25:16 <kosmikus> why not?
05:25:17 <earthy> whereas this did
05:25:23 <earthy> lemmecheck
05:25:30 <earthy> I have his original source somewhere
05:26:19 <kosmikus> I'd actually rather not have Doaitse use such a non-standard configuration of lhs2TeX, as it will inevitable cause problems again after the next upgrade
05:26:25 <earthy> ;)
05:26:31 <earthy> I can imagine
05:26:32 <kosmikus> and from experience, he does upgrade after every single change I make to the repo
05:27:17 <earthy> btw, it won't compile by default on tiger with the ghc 6.4 mac os x package
05:27:32 <earthy> but that can be helped by adding -pgmc /usr/sbin/gcc-3.3 to the config.mk, so that was easily fixed
05:27:48 <kosmikus> huh, why's that?
05:28:01 <earthy> /usr/bin/ld: Undefined symbols:
05:28:01 <earthy> ___DISCARD__
05:28:01 <earthy> collect2: ld returned 1 exit status
05:28:01 <earthy> make: *** [lhs2TeX] Error 1
05:28:07 <earthy> Tiger defaults to gcc-4.4
05:28:10 <earthy> 4.0 that is
05:28:27 <kosmikus> that's a problem of the ghc package then, not of lhs2tex
05:28:28 <earthy> and it's not /usr/sbin/gcc-3.3 but /usr/bin
05:28:30 <earthy> yes
05:28:39 <kosmikus> then I don't care ;)
05:28:56 <kosmikus> so, but I still don't understand what the problem with this NWO proposal was/is ...
05:28:58 <earthy> but lhs2TeX is one of the few packages I've run in to that actually triggers the bug
05:29:08 <earthy> just a sec, recreating the situation ;)
05:29:27 <kosmikus> lhs2tex is Haskell98, I wouldn't know why this should be particularly dangerous ...
05:29:45 <kosmikus> no ffi, no extensions
05:29:53 <xerox> What was to do Double -> Int ?
05:29:58 <xerox> @hoogle Double -> Int
05:29:59 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
05:29:59 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
05:29:59 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
05:30:04 <earthy> but separate compilation and linking without using ghc --make
05:30:05 <xerox> @hoogle+
05:30:07 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
05:30:07 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
05:30:07 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
05:30:15 <earthy> and I think that suffices
05:30:21 <xerox> Mumble.. ?
05:30:28 <kosmikus> earthy: that's forbidden nowadays? ;)
05:30:52 <kosmikus> fwiw, the next release (if it ever appears) will probably use ghc --make ...
05:31:00 <dcoutts> earthy, that shouldn't make any difference. --make is just automation, it's not actually doing anything different.
05:31:33 <earthy> dcoutts: I know
05:31:42 <earthy> I don't know what triggers the ___DISCARD__ thing
05:31:47 <earthy> it's a GHC thing though
05:31:48 <aleator> Another FFI - haskell modelling question: Is It a good goal to try to move away from IO to pure haskell? Ie. If I have function that can be pure is there any reason not to make it so?
05:31:56 <earthy> but Stefan seems not affected by it in his code
05:32:03 <kosmikus> dcoutts: can you *now* test the ghc-6.4.1 snapshot upgrade again? my test build hasn't finished, but it got as far as never before and is still running ;)
05:32:06 <earthy> so he does something differently than lhs2TeX does
05:32:13 <dcoutts> earthy, does ghc on ppc have a native code generator? you could compile with -fasm and avoid the gcc backend
05:32:27 <earthy> anyway, recreating the exact situation Doaitse was in. :)
05:32:28 <xerox> @hoogle (Integral a) => Double -> a
05:32:30 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
05:32:30 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
05:32:30 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
05:32:33 * boegel is sweating his ass of
05:32:37 <boegel> s/of/off
05:32:47 <xerox> realToFrac doesn't exaclty work, grumble.
05:33:23 <kosmikus> earthy: I'm still interested in that other problem? why \usepackage in the first place, why does %include not work?
05:33:49 <earthy> because the 'driver' for my article is not run through lhs2TeX
05:34:05 <earthy> i.e. the main text
05:34:15 * gour is away: busy
05:34:18 <earthy> so there is no way to have the %include correctly expanded
05:34:32 <earthy> but then you're left with %if latex209 -style shit
05:34:39 <earthy> in the lhs2TeX.sty
05:34:46 <kosmikus> yes, so why don't you run it through lhs2TeX?
05:35:21 <earthy> because it's not literate haskell...
05:35:30 <kosmikus> ?
05:35:50 <dcoutts> xerox, what's wrong with realToFrac?
05:35:51 <earthy> I'd rather not preprocess plain tex with lhs2TeX
05:35:53 <kosmikus> every TeX file is literate Haskell
05:36:01 <kosmikus> why not?
05:36:22 <earthy> formats possibly getting in the way of my typesetting
05:37:10 <xerox> dcoutts: it gives me an error, mumble.
05:37:21 <xerox>     No instance for (Fractional Int)
05:37:36 <kosmikus> earthy: I don't understand that. Anyway, the way to go then is to do the following:
05:37:55 <kosmikus> lhs2TeX --poly lhs2TeX.sty > avl-lhs2TeX.sty
05:38:10 <kosmikus> then \input or possibly \usepackage the resulting file
05:38:15 * earthy nods
05:38:18 <kosmikus> but please don't call it lhs2TeX.sty, then
05:38:25 <xerox> w <- liftM realToFrac $ spinButtonGetValue spinResX
05:38:55 <earthy> but why is it called a .sty ?
05:39:02 <xerox> spinButtonGetValue :: SpinButtonClass self => self -> IO Double
05:39:07 <earthy> that should be includable, right?
05:39:33 <kosmikus> earthy: Ralf's decision, I wouldn't have ...
05:39:42 <earthy> ah. legacy. :)
05:39:53 <earthy> that then explains my original trouble
05:39:59 <dcoutts> xerox, that's retuning a double and you seem to be trying to convert it to an int
05:40:05 <kosmikus> earthy: rtfm?
05:40:11 <xerox> dcoutts: exactly what I want to do!
05:40:24 * gour is back.
05:40:26 <earthy> btw, the diff is virtually just that. lhs2TeX --poly lhs2TeX.sty 'expands' to the thing I sent you
05:40:37 <roconnor> @hoogle TimeDiff
05:40:38 <lambdabot> Time.diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
05:40:38 <lambdabot> Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
05:40:49 <gour> dcoutts: have u seen my msg on private (regarding Python)?
05:41:03 <dcoutts> goron, yep
05:41:14 <earthy> now, where the bleep did Doaitses problem originate
05:41:17 <kosmikus> earthy: I can imagine. But of course, I want to keep it --math compatible at least; 2.09 isn't that important, I haven't tried if it works in ages anyway
05:41:28 <gour> dcoutts: ok
05:41:54 <earthy> couldn't --math be supported in another way as well?
05:42:00 <dcoutts> gour, check your privmsg for the reply :-)
05:42:17 <basti_> hi
05:42:27 <kosmikus> earthy: yes. sure, I can make everything in there TeX, but I don't think it has a high priority
05:43:07 <dcoutts> xerox, but realToFrac is not what you want then, you want round or floor
05:44:05 <gour> dcoutts: where it is?
05:44:29 <xerox> dcoutts: ah.
05:44:51 <dcoutts> gour, does your irc cilent show a privmsg dialog window/tab ?
05:45:47 <kosmikus> earthy: so, does Doaitse's NWO thing compile now using the original %include approach (assuming this was /= your article)? and can I safely assume that he'll use the \usepackage-hack only for your article, and nothing else? ;)
05:46:09 <gour> dcoutts: i don't think so, only /query tab
05:46:21 <ndm> dcoutts, remember what the global message said earlier - registered users won't see privmsgs from unregistered ones
05:46:47 <ndm> http://freenode.net/news.shtml
05:47:14 <dcoutts> ndm, ah, thanks!
05:48:09 <dcoutts> gour, do you get my privmsg now?
05:48:25 <dblhelix> earthy is talking now... well... to doaitse
05:48:33 <kosmikus> dblhelix: :)
05:48:49 <gour> dcoutts: yup
05:49:12 <kosmikus> dblhelix: intelligent users are the worst :)
05:49:29 <dblhelix> kosmikus: they sure are :)
05:50:20 <earthy> no, it was the nwo thing
05:50:27 <earthy> and yes, it compiles
05:50:30 <vegai> Damn, I'd *really* like to do this readline thingie in pure haskell...
05:50:32 <earthy> but does not render -> nicely
05:51:08 <vegai> I wonder if someone has, already..
05:51:29 <earthy> and I will fix my article for the \usepackage hack so that it doesn't call it lhs2TeX.sty
05:51:39 <earthy> but lhs2TeXprocessed.sty
05:51:44 <earthy> or somesuch
05:51:46 <kosmikus> earthy: that's in the comments, right? I've seen that. Comments are formatted in text mode by default [documentation :)], but you can switch to inline code mode -- |foo -> bar| ...
05:51:55 <earthy> um...
05:52:02 <vegai> hmm, someone has
05:52:37 <earthy> no, it's *not* in the commets... or doesn't seem to be.
05:52:45 <kosmikus> where then?
05:52:51 <earthy> oh, no, it *is*.
05:52:52 <earthy> sorry.
05:52:59 <earthy> comments in the code
05:53:17 <kosmikus> yes, page 3
05:53:22 <roconnor> *sigh* I want TimeDiff in seconds.
05:54:00 <earthy> I'm going to send this version to Doaitse again, but with that inline code mode thing you mentioned
05:54:10 <earthy> so he doesn't try to add a %format for ->
05:54:38 <kosmikus> I don't understand the question about %format for -> ?
05:54:48 * boegel takes a sweat-break
05:55:02 * Itkovian is hungry
05:55:10 <earthy> Doaitse is going to try to fix that -? for -> on page 3
05:55:12 * boegel throws Itkovian a Twix
05:55:19 <earthy> he is probably going to try using a format to do so
05:55:24 <basti_> uhm
05:55:30 <basti_> > in latex comes out as ?
05:55:37 <basti_> if you want >, you have to \>
05:55:46 <basti_> could that be the problem earthy?
05:55:49 <kosmikus> earthy: comments are just text, text isn't affected by format statements
05:55:49 <earthy> basti: this is preprocessed latex
05:55:55 <basti_> ohh
05:56:11 <earthy> kosmikus: which is exactly why I'm going to preempt Doaitse getting mad at you again :)
05:57:20 <kosmikus> earthy: ok, let's hope it works
05:57:25 <kosmikus> I'm away for a while ...
05:57:43 <earthy> good luck :)
06:02:06 * boegel pokes Itkovian 
06:09:43 <dcoutts> xerox, I've finnished writing the announcement, just waiting for some screenshots and/or a new blog post from you
06:14:34 <ScottPlantagenet> Alpacasaurus Llambda Llama
06:14:42 * boegel is keen on reading the announcement
06:14:48 <ScottPlantagenet> dcoutts: My llama can kick your llama's ass
06:15:49 * boegel thinks ScottPlantagenet is high on something
06:15:56 * ScottPlantagenet tosses a bowl of oatmeal with some cinamon and fruit on top at  Itkovian 
06:15:57 * dcoutts didn't realise was a llama farmer
06:16:45 <ScottPlantagenet> dcoutts: Actually my specieis of llama is only mostly mammal with latent reptile DNA leftover from the Jurassic period
06:16:51 <Itkovian> @dice d20
06:16:52 <lambdabot> "dice" (line 1, column 1):
06:16:52 <lambdabot> unexpected "d"
06:16:52 <lambdabot> expecting digit
06:16:59 <Itkovian> @dice 1d20
06:17:00 <lambdabot> 1d20 => 8
06:17:04 * Itkovian evades the bowl
06:17:25 * poetix breathes Nether
06:17:33 <ScottPlantagenet> dcoutts: Ah, there is is the lambdabot
06:18:12 <xerox> dcoutts: hey - I'm a bit stuck :-)
06:18:17 <dcoutts> xerox, oh yes?
06:18:27 <xerox> Could we gobby?
06:18:35 <dcoutts> xerox, yep
06:18:43 <ScottPlantagenet> boegel: Doctor Suess was king nerd but he wasn't necessarily high on anything
06:19:00 <poetix> Gobby? Is this a new kind of sex act?
06:19:03 <boegel> ScottPlantagenet: so you're emperor nerd or something ?
06:19:11 <shapr> ScottPlantagenet: Dude, are you a bot?
06:19:13 <boegel> poetix: don't ask, just don't !
06:19:15 <Narrenschiff> oh no, I've walked in on a variant of the "Magic Roundabout" conversation!
06:19:15 <poetix> "Let's get together and mingle code, baby..."
06:19:38 * dcoutts wonders if reptilian llama dung is halucenegenic
06:19:52 <shapr> ScottPlantagenet: C'mon man, respond or be pummeled.
06:20:08 --- mode: ChanServ set +o shapr
06:20:12 <Itkovian> hehe
06:20:15 * shapr gets out the pummel halo.
06:20:19 <xerox> poetix: it's a collaborative realtime editor
06:20:21 <Itkovian> I feel some ass getting kicked
06:20:23 <dcoutts> witness the mighty power of the shapr
06:20:28 <xerox> poetix: it's soooooo nice.
06:20:30 <Itkovian> @dice 5d12
06:20:31 <lambdabot> 5d12 => 40
06:20:34 <Itkovian> wow
06:20:52 * Itkovian draws his scimitars
06:20:54 * poetix rolls 20s
06:21:00 <shapr> ScottPlantagenet: Not that I don't enjoy your llama humor... but it's not on topic... can you be on topic?
06:21:08 <Itkovian> ouch
06:21:10 * Itkovian ducks
06:21:17 <Itkovian> under a large monad
06:21:37 <ScottPlantagenet> shapr: Actually, my llama humour was about to get a thousand times funnier but I realized that I would get kicked if I continued for trolling off topic
06:21:53 * dcoutts points a large arrow at Itkovian's hiding place
06:21:56 --- mode: shapr set -o shapr
06:22:03 <dcoutts> phew!
06:22:09 <Itkovian> stand down
06:22:12 <poetix> Defcon 2
06:22:12 * shapr grins
06:22:21 <dcoutts> shapr takes off his gloves
06:22:31 <shapr> the halo is gone! aww!
06:22:48 <poetix> You know, power like that, you just *gotta* abuse it.
06:22:50 <shapr> ScottPlantagenet: I just want to keep the signal/noise ratio high, y'know?
06:22:58 <ScottPlantagenet> shapr: Yep
06:23:19 <shapr> So, are you learning Haskell?
06:23:57 <ScottPlantagenet> shapr: Yeah, I do physics in Haskell
06:24:26 <poetix> ScottPlantagenet: Quantum physics? Can you make darcs go faster?
06:24:34 * xerox laughs
06:25:10 * poetix installs Gobby
06:25:15 <xerox> Goooooood!
06:25:28 <ScottPlantagenet> shapr: mostly spherical harmonics and attempting to adjust Gaussian formulas to finish UFT
06:25:44 * beelsebob_ grabs the gobby source and sees how easy it would be to cocoaify it
06:26:19 <Itkovian> @hoogle between
06:26:33 <ScottPlantagenet> DARCS revision control system
06:26:55 <poetix> Famously has a "theory of patches" based on quantum...um...thingummy
06:27:17 <Itkovian> poetix: the only thing used is the commuting of operators
06:27:32 * Itkovian has to catch a bus soon.
06:27:45 <beelsebob_> shapr: did you find XCode 2.1 ya?
06:27:47 <poetix> Yeah, I know. I just thought it was a wicked sales spiel...
06:28:40 <Itkovian> I have to admit the quantum theory stuff drew my attention too
06:29:08 <beelsebob_> from my experience... it makes people sceptical
06:29:16 <beelsebob_> it sounds like a load of bluster
06:29:25 <beelsebob_> if it just said "theory of patches" it would mean more
06:31:12 <tuomov> s/quantum/operator/ and it would sound "cool" but not so suspicious
06:31:28 <dons> @hoogle intersperse
06:31:29 <lambdabot> List.intersperse :: a -> [a] -> [a]
06:31:40 <dons> Itkovian, i've reverted the name of 'between' back to intersperse
06:31:49 <Itkovian> ok
06:31:53 <dons> (I guess that was your motivation for the above hoogle (?)
06:32:01 <Itkovian> i've looked at the code and seen that it was indeed intersperse
06:32:20 * xerox note to self: do not render with alpha = 0 and complain
06:33:34 <xerox> Itkovian: http://themaxx.com/offensive/images/picpile/Loot%20vs%20Find.jpg
06:34:07 <shapr> beelsebob_: XCode is OSX only, isn't it?
06:34:13 <ScottPlantagenet> shapr: Actually, I hack chernoff bounds in haskell in quantumn space if you want to consider that quantumn physics on biological CPUs made out of Hirudinea neurons
06:34:14 <boegel> xerox: heh :)
06:34:18 <beelsebob_> shapr: yes
06:34:28 <beelsebob_> oh... it was lispy
06:34:31 <beelsebob_> dumb bob
06:34:46 <Itkovian> xerox: idd
06:34:50 <shapr> ScottPlantagenet: Sounds way cool.
06:35:04 <ScottPlantagenet> shapr: http://en.wikipedia.org/wiki/Chernoff_bound
06:35:38 <ScottPlantagenet> shapr: Yeah, I don't want to make it sound like I'm limited to trying to finish UFT and Gaussian adjustments for UFT that is just what I'm hacking the most this month
06:35:40 <reppie[^_^]> i'm forever alone.
06:35:44 <ScottPlantagenet> shapr: I do alot of crap
06:36:06 <shapr> Sounds familiar. I do a lot of random stuff too.
06:36:10 <ScottPlantagenet> shapr: Anyway haskell is perfect for what I just mentioned before
06:36:23 <ScottPlantagenet> shapr: That kind of experimental testing
06:36:50 <shapr> That's nifty, Chernoff bound sounds related to Kolmogorov complexity.
06:36:55 <tuomov> dependent types would be cool for matrix size checking..
06:37:38 <shapr> I guess lots of information theory is interrelated.
06:38:08 * gour is away: busy with other things
06:38:28 <poetix> Oh, that reminds me - I have a math book I don't need, because it's way over my head, looking for a good home for it. Title is "Bounded Queries in Recursion Theory" - I got it for a couple of quid from a charity shop for a laugh, to intimidate my co-workers by having it open in my desk...
06:38:48 <shapr> ScottPlantagenet: How do you build a bio cpu out of leech neurons?
06:39:05 <earthy> poetix: Elbasan, Albania
06:39:10 <earthy> http://www.cs.uu.nl/people/gerard/Elbasan/bookAid2005.htm
06:39:12 <shapr> poetix: haha
06:39:17 <shapr> poetix: oh oh, I want it!
06:39:39 <poetix> shapr: Are you a more deserving cause than the Albanians?
06:39:41 <ScottPlantagenet> shapr: I have a book called "A mathematical theory on communication" by C.E Shannon that I've been meaning to read but haven't gotten to it yet
06:39:48 <shapr> I enjoy finding stuff that's just one or two steps over my head and then exercising my brain until I can get there.
06:39:53 <ScottPlantagenet> shapr: Because I have a ton of books on my HD
06:40:06 <ScottPlantagenet> shapr: Good practice
06:40:12 <shapr> Shannon is the man for information theory.
06:40:25 <basti_> he's always like 1/2 f
06:40:37 <shapr> I just got a bunch of books from the UK, including Schneier's sequel, "Secrets & Lies"
06:40:42 <poetix> To be fair, it's not that it's hard (although it is) so much as that I don't have any motivation to slog through it - page after page of notation...
06:40:48 <ScottPlantagenet> shapr: Ah, well you mentioned this  "I guess lots of information theory is interrelated: so .. that is what I thought of
06:40:53 <shapr> Yeah, I agree.
06:41:01 <ScottPlantagenet> shapr: Read any of his stuff ?
06:41:20 <shapr> Not yet. I've read about him and some of his work on wikipedia, but haven't gotten to his books yet.
06:41:31 <reppie[^_^]> i feel so dead inside
06:41:33 * gour is back.
06:41:51 <shapr> I'm trying to find Hammond's "You and Your Research". I really want to read that one.
06:42:01 <shapr> reppie[^_^]: You could get off of IRC and meet some people. That'll help.
06:42:14 <reppie[^_^]> shapr :(
06:42:20 * shapr shovels reality at reppie[^_^]
06:42:23 <boegel> reppie[^_^]: what's up ?
06:42:30 <ScottPlantagenet> shapr: I heard of Hammond indirectly by reading Eric Raymond's "The Art Of Unix Programming"
06:42:33 <ScottPlantagenet> :)
06:42:46 <earthy> shapr: that is http://www.cs.virginia.edu/~robins/YouAndYourResearch.html ??
06:42:46 <reppie[^_^]> unix programming considered harmful
06:42:51 <shapr> ScottPlantagenet: read this - http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
06:43:17 <reppie[^_^]> i think there are too many "The Art of ..." and "... considered harmful" papers/books.
06:43:45 <reppie[^_^]> "The Art of Considered Harmful" ???
06:44:09 <shapr> "The Art of Harm" by the Cult of Shiva.
06:44:21 <sieni> and there also was "Dijkstra considered harmful" by some Japanese guy with surname "Goto"
06:44:31 <basti_> ouch.
06:44:32 <reppie[^_^]> sieni LOL.
06:44:35 <xerox> Ah!
06:44:43 * shapr snickers
06:45:43 <reppie[^_^]> i just wanna feel like i belong
06:46:32 <reppie[^_^]> http://www.palindromelist.com/longest.htm
06:46:34 <shapr> Well, write some Haskell code, and you'll fit right in.
06:46:39 <reppie[^_^]> shapr ha.
06:46:42 <ScottPlantagenet> shapr: http://news.bbc.co.uk/1/hi/sci/tech/358822.stm
06:46:47 <ScottPlantagenet> shapr: That was back in '99
06:47:05 <ScottPlantagenet> shapr: Could only do simplistic calculation back then
06:47:32 <xerox> WOW.. reppie[^_^].. it is indeed long.
06:47:48 <shapr> ScottPlantagenet: That's way nifty.
06:47:56 <ScottPlantagenet> shapr: indeed
06:48:21 <poetix> Now I know that's real science
06:48:32 <poetix> Because my immediate response was: That's gross. And scary.
06:48:39 <poetix> The best kind of science!
06:48:46 <shapr> Finally, we can harness all the P2P leeches.
06:49:16 * poetix wonders whether it would be possible to write a Visual Studio plug-in for collaborative editing
06:49:54 <Narrenschiff> ...of leeches?
06:50:29 <basti_> leeching edits?
06:50:38 <boegel> ScottPlantagenet: what is it able to do now ?
06:51:29 <ScottPlantagenet> boegel: somewhat confidential or classified
06:51:49 <basti_> argh
06:51:52 <boegel> ScottPlantagenet: oh, so you're sponsered by the US Army ? :p
06:52:00 <poetix> You're building SkyNet! OMG!
06:52:08 <boegel> poetix: :D
06:52:10 <reppie[^_^]> googlenet?
06:52:50 <poetix> Or Daleks, possibly. I can just imagine a seething mass of entangled leeches, controlling a giant pepperpot with an eyestalk and a laser gun.
06:54:26 <poetix> It would drink human blood through the sucker attachment...oh my, what a nightmare...
06:54:36 * poetix goes and has a little lie down
06:54:43 <Narrenschiff> Leeches are kind of pretty.
06:54:54 <basti_> o.0
06:55:01 <poetix> Now there's a perversion I hadn't heard of before
06:55:03 <ScottPlantagenet> poetix: Daleks ? http://www.breakbeatscience.com/32246.html
06:55:27 <poetix> Hirudophilia?
06:58:13 <Narrenschiff> Shades of Victor Lewis-Smith's "Gay Daleks".
06:59:06 <poetix> One in an Armani suit, and one called Marmaduke.
07:00:17 <ScottPlantagenet> poetix:
07:00:24 <ScottPlantagenet> Geeks aren't suppose to wear Armani
07:00:30 <ScottPlantagenet> or nerds
07:00:34 <ScottPlantagenet> haha
07:01:04 <ScottPlantagenet> I don't own any Armani although  one of my suits is a "Polo University suit" by Ralph Lauren
07:01:06 <ScottPlantagenet> :P
07:02:05 <poetix> http://www.brainyquote.com/quotes/authors/d/dennis_potter.html <-- Dennis Potter's line about the Director General of the BBC being a "croak-voiced dalek"
07:02:13 <ScottPlantagenet> poetix: I purchased a white collared shirt from the thrift shop the other day for $3 the height of " I don't give a sh*t geek chic"
07:02:27 * boegel mentions his glasses is from Armani
07:02:33 <boegel> it has fallen apart twice though :)
07:02:51 <beelsebob_> @hoogle none
07:02:58 <ScottPlantagenet> Some morons are buying the same shirt for like $40 bucks retail
07:03:04 <beelsebob_> @hoogle [Bool] -> Bool
07:03:05 <lambdabot> Prelude.or :: [Bool] -> Bool
07:03:05 <lambdabot> Prelude.and :: [Bool] -> Bool
07:03:05 <lambdabot> Prelude.product :: Num a => [a] -> a
07:04:49 <beelsebob_> hmm...
07:05:41 <beelsebob_> If I write...
07:05:41 <beelsebob_> f x y | x == y = jam
07:05:41 <beelsebob_> f x@(Something) y@(SomethingElse) = ham
07:05:41 <beelsebob_> will the pattern match roll over when x /= y
07:07:00 <xerox> boegel: http://haskell.galois.com/~paolo/Six2.png
07:07:03 <xerox> puff, pant.
07:07:12 <basti_> the pattern match thing is decided on type level
07:07:13 <xerox> (Thanks dcoutts for the bugfixing, hehe!)
07:08:25 <TheHunter> Beelsebob, yes it will.
07:08:38 <ScottPlantagenet> shapr: Anyway, those leeches nuerons are only half the story : http://www.physorg.com/news5733.html
07:08:46 <ScottPlantagenet> shapr: Check that out
07:09:27 <ScottPlantagenet> shapr: I was using the Chernoff bounds as one kind of benchmark for performance
07:11:46 <shapr> spiffy
07:11:58 <Narrenschiff> quantum leeches!
07:13:21 <reppie[^_^]> http://channel9.msdn.com/ShowPost.aspx?PostID=104073
07:14:09 <ScottPlantagenet> s/nuerons/neurons/g
07:14:19 <boegel> xerox: looking great :) but to get a real tree like feeling, you should make it grow from beneath, not from the top :)
07:14:32 <xerox> boegel: good point :-D
07:14:35 * xerox tries an idea
07:15:57 <xerox> Ah ha!!
07:15:58 <xerox> :-D
07:16:59 <ScottPlantagenet> PR [   Xi > t ] <      e              E [ e    ] =e          (pi-e  +(1-pi)
07:17:01 <ScottPlantagenet>     i=1          -                i=1
07:17:03 <ScottPlantagenet> oops
07:17:05 * boegel is getting jealous of xerox's gui
07:17:05 <ScottPlantagenet> sorry
07:17:24 <ScottPlantagenet> I have to go anyway my mistake
07:17:33 <boegel> ScottPlantagenet: make sure you don't paste any secrets in here by accident, mmkay ? :)
07:17:47 <reppie[^_^]> too late!
07:17:57 <basti_> ah its not that bad.
07:18:03 <basti_> theyre not secrets then anymore
07:18:09 <ScottPlantagenet> boegel: I just figured out it's hard to do mathemtatical calculations in irc without LaTeX
07:18:18 <ScottPlantagenet> boegel: Not even worth the effort
07:19:10 <ScottPlantagenet> I was msging that to an imaginary user named "bork" to but somehow it slipped out into the channel :(
07:20:58 <xerox> AH!  If only I had a bigger monitor.. http://haskell.galois.com/~paolo/Six3.png
07:21:36 <basti_> xerox: zoom it!
07:22:01 <xerox> err?
07:22:13 <Narrenschiff> what's that? L-system?
07:23:41 <basti_> yes.
07:24:31 <Narrenschiff> Hee! They're fun. I should probably write some toy to play with them.
07:24:46 <basti_> thats what xerox is doing
07:25:02 <xerox> Yay
07:25:17 <xerox> If you have any grammar to try I'll be glad to try it and shot
07:25:30 <basti_> wheres the darcs link?
07:25:32 <xerox> So I could finally blog about it and let dcoutts party :-D
07:25:32 <basti_> :D
07:25:46 <xerox> basti_: /dev/null atm, heh! :-D
07:26:52 <ScottPlantagenet> xerox: Who is that guy in the French beret hat and twisted eyes suppose to be ?
07:27:44 <xerox> ScottPlantagenet: err, who?!
07:27:50 <shapr> That's *MISTER* Galois to you!
07:27:56 <xerox> oooh.
07:28:41 <ScottPlantagenet> xerox: http://channel9.msdn.com/ShowPost.aspx?PostID=104073
07:28:47 <Narrenschiff> I had better zoom to town and see if I can get this album.
07:31:14 <beelsebob_> where is the guy from galois
07:31:20 <beelsebob_> I want CVS write access
07:31:52 <ndm> me too!
07:32:07 <beelsebob_> ndm: did you email the galois guy?
07:32:14 <beelsebob_> I have... I'm waiting for him to get back to me
07:32:26 <ndm> nope, i'm just emailing the hugs-cvs mailing list, asking how we go about integrating WinHugs2
07:32:36 <beelsebob_> fair enough
07:32:59 <ndm> the patch for winhugs reads like --- all, +++ this stuff
07:33:07 <beelsebob_> heh
07:33:19 <beelsebob_> perhaps you don't go about 'integrating' then
07:33:49 <ndm> thats one of the optiosn i'm mentioning
07:33:53 <ndm> create a new folder
07:34:10 <ScottPlantagenet> xerox: Spigot ?
07:34:11 <ndm> but there is the common code, and once you make the modifications required for WinHugs2, you kill WinHugs1 forever
07:34:26 <ndm> (not that WinHugs1 has a pulse anymore anyway)
07:36:23 <beelsebob_> you don't
07:36:27 <beelsebob_> that's the point of cvs
07:36:34 <beelsebob_> although a fork might be a good idea
07:39:58 <ScottPlantagenet> shapr: http://www.jerkcity.com/jerkcity2479.html
07:42:01 <boegel> xerox: I like your latest screenshot very much !
07:42:09 <ndm> beelsebob_, fork? how do you fork something like that
07:42:16 <basti_> jerk city looks like created under the influence of hallucinogenics
07:42:36 <beelsebob_> fork the cvs tree and then perform the big overwrite in the new tree
07:42:38 <boegel> xerox: url to blog ?
07:42:39 <xerox> boegel: now a galler!
07:42:46 <xerox> http://www.haskell.org/gtk2hs/gallery/Cairo-demo
07:42:48 <xerox> gallery.
07:43:09 <ndm> hmm, i think everyone from hugs would like to keep their existing cvs tree
07:43:09 <xerox> boegel: any ideas about other grammars?  I'd like to add at least another, maybe 2 shots to the blog post :-D
07:43:40 <xerox> boegel: (which I still should write)
07:44:23 <beelsebob_> neil: it's just an opperation you can do is cvs... a fork creates a point of divergance... one in which v1 continues to be developed, and another in which v2 is worked on
07:44:46 <beelsebob_> one of them is considered the primary fork, and is what people get when they check out
07:44:51 <beelsebob_> (or update)
07:45:12 <ndm> hmm, that would be reasonable
07:45:36 <ndm> or maybe because winhugs is already pretty dead, just a sharp stick to the heart, and wave it off into my early haskell history...
07:45:42 * ndm sheds a tear
07:47:37 <boegel> xerox: I believe dcoutts has been doing some fiddling with nice grammars
07:47:46 <beelsebob_> heh
07:47:55 <beelsebob_> you could have a funeral pire for it
07:48:00 <boegel> xerox: can you give me your blog url ? I'd like to check out your post when it's up
07:48:13 <xerox> Sure
07:48:25 <boegel> xerox: this was quite a simple grammar too, but I don't know which one I used -> http://scannedinavian.org/~boegel/HaskLS/img/trees2.png
07:48:34 <xerox> http://haskell.org/gtk2hs/archives/category/cairo
07:48:42 <xerox> http://haskell.org/gtk2hs/archives/category/cairo/feed/rss for the feed
07:49:09 <dcoutts> xerox, I've got to go in like 10 min or so
07:49:29 <dcoutts> I might have a moment this evening to post/update the release announcement
07:51:14 <xerox> Oh
07:51:20 <xerox> Let me write the blogpost now!
07:53:51 <beelsebob_> hehe... don't get me wrong.. if a job with more money comes along, then I'll be outta there faster than you can say "new TFT monitor"
07:53:59 <dcoutts> xerox, the tarball is up
07:54:06 <dcoutts> the announcement is read to go
07:54:09 <dcoutts> but no pics
07:54:39 <gour> dcoutts: i have problems with tailor, so don't announce it!
07:54:50 * boegel goes home
07:54:55 <xerox> dcoutts: I made the gammery
07:54:58 <xerox> Gallery
07:55:02 <xerox> I'm writing the post.
07:55:24 <beelsebob_> hmm, I really should learn to save before compiling and wondering why it doesn't work
07:55:34 <poetix> The Cairo fractaporn is really great
07:56:18 <boegel> xerox: make some more pics first ! don't haste to write an incomplete blog post on something you've worked on so long !
07:56:31 <boegel> make the _ultimate_ blog post for this, including several nice pics
07:56:37 * boegel = off
08:03:49 <dcoutts> xerox, so I'll wait and try to post this evening then? I've really got to go
08:04:00 <vegai> with keywords "nude erotic porn cairo"
08:04:26 <dcoutts> xerox, I can post now and modify it this evening to add pics
08:04:31 <dcoutts> whichever you like
08:04:47 <dcoutts> but it'd good for it to be up for Evan from Google to see
08:05:11 <beelsebob_> YAY!
08:05:20 <beelsebob_> hat-delta worketh some more
08:05:28 <xerox> dcoutts: post!
08:05:32 <dcoutts> ok
08:05:37 <beelsebob_> it takes it's time to think... but it cuts the number of questions greatly
08:05:38 <xerox> I'm mostly done
08:05:55 <dcoutts> done
08:05:58 <dcoutts> it's up
08:06:12 <dcoutts> tell me if you see any spelling errors
08:06:41 <beelsebob_> current version cuts the number of questions roughly in half... I expect it to get better :)
08:07:03 <xerox> dcoutts: could you add a link to my post, which still does not exist?
08:07:28 <dcoutts> xerox, not without a url
08:18:45 <poetix> HUnit or QuickCheck?
08:19:17 <poetix> shapr: You're infected. Which do you use?
08:21:01 <xerox> poetix: both!
08:24:05 <poetix> Do they do very different things?
08:27:20 <beelsebob_> buh... this client sucks donkeys balls
08:30:26 <poetix> Client application, or actual client person/organisation?
08:30:40 <beelsebob_> client app
08:30:43 <shapr> poetix: I use both.
08:30:53 <poetix> We have clients that actually breed donkeys for the sole purpose of sucking their balls.
08:30:59 <shapr> yow
08:31:27 <beelsebob_> how rare
08:31:28 <poetix> Of course I mean applications, not our actual customers</hasty_disclaimer>
08:31:48 * shapr grins
08:32:03 <shapr> Anyway, HUnit and QuickCheck are very different. QuickCheck is awesome and amazing.
08:33:08 <poetix> I just took a look at the manual. I thought, "if that actually worked, it would be awesome and amazing"
08:33:17 <poetix> So presumably it actually works, which is.
08:33:27 <Lucinda> hi
08:33:30 <beelsebob_> lo
08:33:32 <shapr> greetz
08:33:40 <beelsebob_> awww... it wasn't a tristate
08:33:40 <Lucinda> can anyone tell me the function to map a monad over a list?
08:33:46 <poetix> mapM
08:33:48 <Lucinda> ah!
08:33:49 <poetix> or mapM_
08:33:49 <Lucinda> cool
08:33:50 <resiak> poetix: Left a message on your blog, but in case you missed it, w/trem is _cool_.
08:34:00 <shapr> Yeah, w/trem roxxors.
08:34:00 <beelsebob_> lucinda... try @hoogle
08:34:01 <poetix> resiak: yes, got that, thanks a lot!
08:34:19 <resiak> poetix: Cool.
08:34:23 * shapr has been recommending w/trem to people who like MBV.
08:34:28 <beelsebob_> @hoogle (a -> b) -> m a -> m b
08:34:29 <lambdabot> Prelude.fmap :: Functor a => (b -> c) -> a b -> a c
08:34:29 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
08:34:29 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
08:34:31 <poetix> Mission accomplished.
08:35:21 <shapr> poetix: Considering making more music for a magnatune release?
08:35:34 <poetix> ?magnatune?
08:35:44 <shapr> http://www.magnatune.com/
08:36:17 <poetix> I am making *very slow* progress on some new material
08:36:32 <poetix> I used to have a lot more time for music than I do now
08:36:34 <shapr> I also liked "After reading de Man for a while, it is difficult to know just whom one is to pity."
08:38:16 <shapr> Strangely enough, I've never had identification dissociation. I'm the same person now as when I was less than a year old. (Yes, I remember myself then.)
08:38:55 <poetix> At one level, I'm exactly the same person as I was when I was five, and have never been anyone else.
08:39:31 <poetix> On the other hand, there are these dislocations - I've moved around a fair bit, and left a lot of people and places behind
08:39:55 <poetix> If I were in a room full of academics talking about Derrida, I would probably be able to be exactly the person I was last time I was in that situation
08:40:08 <poetix> But I just don't find myself in that kind of situation with any frequency nowadays...
08:40:38 <shapr> On the other hand, if I'd found Haskell when I was sixteen, I'd have learned this stuff a lot sooner.
08:40:52 <shapr> (I'm wondering about moving forward as well as backwards)
08:43:01 <shapr> I used to obsess about perceptual questions as well. I finally decided that I was not be able to perceive any distortions present, so I might as well enjoy what I'm perceiving.
08:43:25 <shapr> On the other hand, I am still quick to find inconsistencies in movies, books, and sometimes myself.
08:43:38 * shapr should probably put this into a comment.
08:43:41 <shapr> poetix: Anyway, I enjoy reading your blog.
08:44:10 <poetix> That's good to hear. :)
08:44:54 <shapr> I think Heinlein's societies could be the result of your Ballardian Dystopia.
08:46:13 * xerox boings happily
08:46:21 * shapr xeroxes boingily
08:46:42 <xerox> Who will shaprs xerorxily ?
08:46:46 <xerox> -r
08:47:07 * shapr shapes xeroxes
08:47:14 <xerox> So, duncan made the release, and the blogpost.
08:47:27 <xerox> And I also made one, which you all should be read, NOW!
08:47:36 <xerox> http://www.haskell.org/gtk2hs/
08:48:57 <Lemmih> @seen CosmicRay
08:48:59 <lambdabot> I saw CosmicRay leaving #haskell 19 hours, 58 minutes and 37 seconds
08:48:59 <lambdabot> ago.
08:49:19 <shapr> Whoa, I got quoted!
08:49:29 * xerox sometimes has good memory
08:49:44 * shapr boings cheerfully
08:49:49 <poetix> If I wanted to get GTK2.8 running on my Suse9.3 Linux system, would I have to build it from source?
08:50:17 <xerox> poetix: maybe there are some RPMs you could grab somewhere?
08:51:09 <poetix> Worth a look. I really fancy a play with this stuff...
08:51:12 <xerox> They need me for practical work here around.. see you later :-)
08:51:17 <shapr> cya!
08:51:20 <xerox> And I really look forward to see your ideas poetix!
08:52:26 <Lemmih> Who do I have to sleep with to get space on haskell.org?
08:53:13 * poetix must be off for now
08:55:36 <marcot> Lemmih: =D
08:56:48 <Igloo> If anyone's got good SQL fu, can you enlighten me as to what I want for http://musketeer.comlab.ox.ac.uk/~igloo/sql.txt please?
08:57:17 <Igloo> I'm sure I've done this sort of stuff in the past, but I can't remember the semantics of HAVING etc well enough now
08:58:28 <Flinta123> Hi, I have a question about winhugs. If I want to be able to load my files with "l: <file>" and not putting the absolute path (c:\blablablabla\blah.hs), where should I put my files?
08:59:15 <bargle> into the current working directory of hugs
08:59:49 <Flinta123> I have it installed into C:\Program\Hugs98, but if I run the exe from there and a file.hs, it can't find it
08:59:56 <ndm> use drag and drop
08:59:59 <ndm> start winhugs
09:00:10 <Flinta123> oh
09:00:12 <ndm> and then from windows explorer drag and drop the file onto the winhugs window
09:00:21 <ndm> from then on, :r will reload the existing file
09:00:31 <ndm> i never type :l pretty much
09:00:41 <ndm> and once a single file has been loaded, that changes the directory
09:00:47 <ndm> so if you have a big project, with many files
09:00:47 <Flinta123> okay
09:00:57 <ndm> drag the first one, then you can :l from then onwards
09:01:04 <Flinta123> thanks
09:02:44 <shapr> Igloo: You could do a subselect
09:03:04 <Flinta123> hmm
09:03:13 <Flinta123> it can't find any types when I drag and drop
09:03:20 <Flinta123> it can't even find 'Int'
09:03:36 <Flinta123> ERROR "C:\Program\Hugs98\test.hs":1 - Undefined type constructor "Int"
09:05:47 <shapr> Igloo: Or read the docs :-) http://www.postgresql.org/files/documentation/books/aw_pgsql/node52.html
09:08:17 <shapr> privet Akshaal
09:08:41 <Akshaal> privet, shapr :)
09:09:57 <Beelsebob> ARGH! Bloody passport office
09:10:16 <Beelsebob> want proof of every address I've lived at for the past 5 years
09:10:19 <Beelsebob> ... all 12 of them
09:10:44 <vegai> Whoa, where's that? the US?
09:10:49 <Beelsebob> no, UK
09:10:56 <basti_> o0
09:11:00 <basti_> that *sucks*
09:11:03 <vegai> "Terrorists won"
09:11:06 <basti_> yup
09:11:11 <basti_> terrorists 1 citizens 0
09:12:02 <Philippa> ouch
09:12:15 <Philippa> shit, I don't think I could manage that either, not sure I have any proof for Claude Street now
09:12:31 <Beelsebob> I don't think I have proof for about 50% of them
09:12:49 <Beelsebob> worse... they want my current uni to provide a letter verifying it
09:12:50 <Lemmih> As long as we keep carpet bombing populated areas I would say that all parties lost.
09:12:54 <Beelsebob> which there is no way they will do
09:13:00 <Beelsebob> because they have no clue where I've lived
09:13:31 <basti_> so what will the passport office do?
09:13:34 <basti_> not give you a passport?
09:13:59 <Philippa> that's the worst they can do, generally
09:14:16 <Philippa> (unless you do anything actually fraudulent)
09:14:22 <Korollary_> except for places like Guantanamo bay
09:14:23 <basti_> and then? arrest you for not having a passport?
09:14:55 <Philippa> no
09:15:10 <Philippa> he's already in the UK, all that would happen is he couldn't travel out
09:15:45 <Beelsebob> yeh
09:15:57 <Beelsebob> hopefully this will all be sorted before I go to IFL
09:16:11 <Beelsebob> because while I know you can travel in europe on your driving licence...
09:16:15 <Beelsebob> I don't want to risk it
09:16:33 <Philippa> it's the getting back in that's the important bit
09:16:37 <Beelsebob> especially, I don't want to risk getting to ireland and then discovering they won't let me back
09:18:36 * Igloo starts to doubt this is possible after all
09:18:58 <Beelsebob> what? getting a passport in britain?
09:19:04 <Beelsebob> *g*
09:19:30 <Igloo> That too  :-)
09:21:06 <shapr> Igloo: You can do it in pure SQL, but it's convoluted.
09:21:20 <Igloo> Without subselects?
09:21:32 <basti_> shapr, Igloo: thats what i thought too.
09:21:34 <shapr> Oh, I don't know about that.
09:22:12 * shapr is fighting with unixODBC at this very moment.
09:22:28 <shapr> w00
09:22:31 * shapr boings
09:22:52 <shapr> I was getting this Fehler bei der Anmeldung gezeik.
09:23:13 <basti_> gezeik?
09:23:27 <shapr> Spraak u nederlands? :-)
09:23:33 <basti_> nee.
09:23:43 <shapr> It's a bad word in Dutch.
09:23:53 <basti_> ah
09:24:06 * basti_ relates it to "zeug"
09:24:22 <shapr> figuratively it's equivalent to the American "bullshit", but I think it literally translates into "horse piss".
09:24:53 * Akshaal wonders, how to switch to next visible buffer in emacs?
09:25:04 <basti_> heh
09:25:20 <shapr> Akshaal: Are you using iswitchb already?
09:26:13 <Akshaal> shapr: no
09:26:55 <shapr> Akshaal: M-x iswitchb-default-keybindings then M-x iswitchb-buffer or even better, (global-set-key "\C-x b" 'iswitchb-buffer) in your .emacs
09:27:40 <shapr> I've gone so far as to remap my Shift_R key to F13, which is then bound to iswitchb-buffer.
09:27:41 <basti_> whoops. I got an uncontrolled chain reaction in my oven
09:28:50 <Akshaal> shapr: tnx
09:31:06 <basti_> hibye tuete.
09:35:06 <Lemmih> Hi SyntaxNinja.
09:38:02 --- topic: set to '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050823","see also #haskell.se #darcs"]' by shapr
09:39:25 <shapr> hej cbus, lär du dig Haskell?
09:39:42 <cbus> shapr, hmm japp snart igen
09:39:56 * shapr älskar Haskell, mmm!
09:40:02 <cbus> javisst :)
09:40:16 <cbus> afp-dags om 1 period
09:40:23 * xerox checks if his Emacs has problems with input strings, it's messing up them in some strange way!
09:41:49 <shapr> xerox: you probably have latin-1 encoding set by default.
09:42:02 <cbus> hmm utf8 i hate it :/
09:42:06 <shapr> Phubuh figured out some way to get erc to decode both at the same time, but I can't figure it out.
09:42:13 <shapr> I prefer utf8.
09:43:45 <xerox> The joke didn't pass through... heh :-D
09:44:27 <shapr> oh
09:44:30 * shapr grins
09:44:33 <xerox> ^_^
09:44:44 <shapr> xerox: So what's next for you? Another Haskell project?
09:45:08 <xerox> I want to extend this LSystem-rendering program to do what this does:
09:45:12 <xerox> @google Contex-free
09:45:13 <lambdabot> http://www.stat.berkeley.edu/users/terry/Classes/s246.2002/Week9/week9b.pdf
09:45:17 <xerox> No..
09:45:21 <shapr> You mean Chris Coyne's CFDG?
09:45:28 <xerox> http://www.ozonehouse.com/ContextFree/
09:45:31 <xerox> This one!
09:45:37 <shapr> Yeah, I've seen it.
09:45:39 <xerox> Yes.
09:46:48 <xerox> You don't imagine the fun in writing two chars and press RET, and seeing the image w00t!
09:48:20 <shapr> Now we need a collaborative library...
09:48:31 <xerox> No chance to get gobby?
09:50:36 <xerox> Err, you were suggesting a project! :-D
09:53:05 <SyntaxNinja> yo
09:54:10 <xerox> Hello SyntaxNinja!
09:58:34 <cbus> magagr, tjo
09:58:45 <magagr> tjo
10:04:18 <SyntaxNinja> hi xerox
10:04:39 <xerox> SyntaxNinja: check this out: http://haskell.org/gtk2hs/
10:04:40 <xerox> :-D
10:14:38 <roconnor> so,what's the best way to make ghc optimize the hell out of my program?
10:14:47 <shapr> ghc -O2
10:15:12 <roconnor> okay, any fiddling with asm vs C?
10:15:22 <SyntaxNinja> xerox: looks great!
10:15:47 <xerox> :-D
10:16:13 <xerox> I should put a darcs repo of the program, so you could give me active feedback, it's much fun to play with the LSystems.
10:16:31 <shapr> roconnor: I know -fvia-C used to make faster programs, but I vaguely recall that's not so much true these days.
10:16:47 <roconnor> oooo, -O2 does make it faster.
10:18:15 <shapr> You can try -fvia-C vs -fasm (the default)
10:18:37 <roconnor> thanks
10:19:28 <shapr> There are a bunch of fun optimization switches in the GHC manual.
10:20:03 <roconnor> Well, I suppose I'll stick with -O2 for now.  The rest sounds like research.
10:21:02 <shapr> I enjoy unboxing strict fields, playing with inline threshholds and the like.
10:21:16 <shapr> But the, I'm probably both easily bored and easily entertained.
10:21:27 <shapr> then*
10:24:09 <roconnor> :-)
10:25:16 <jgrimes> a
10:25:23 <roconnor> I have this value that I can adjust that makes my code run faster or slower, depending on the input.
10:25:35 <roconnor> turning on optimizations totally changes where the optimal point for this is.
10:27:20 <roconnor> Whew, -O2 make me way faster.
11:04:00 <shapr> shazam!
11:04:15 <shapr> hiya jgrimes, are you learning Haskell?
11:05:27 <lispy> today is one of those days
11:06:17 <shapr> You could come to the north of Sweden in the winter. Then you can say, "Today is one of those nights."
11:07:40 <jgrimes> trying too
11:08:11 <shapr> jgrimes: Any questions? Want urls to intro information?
11:08:15 <jgrimes> sure
11:08:30 <lispy> shapr: hehe
11:08:38 * Lemmih got one piece left to hack before his whole-program dead-code remover is finished.
11:09:43 <shapr> @learn
11:09:44 <lambdabot> http://www.haskell.org/learning.html
11:10:05 <jgrimes> cool deal
11:10:22 <shapr> jgrimes: Lots of good stuff on the "Learning Haskell" page there. I also like http://www.haskell.org/hawiki/HaskellDemo for the 'free spoonful' Baskin-Robbins style.
11:10:42 <shapr> jgrimes: When you get questions, feel free to ask them here.
11:10:58 <jgrimes> alright
11:10:59 <jgrimes> :D
11:11:19 <Akshaal> Lemmih: which compiler?
11:12:29 <Lemmih> Akshaal: It operates on Haskell source. No compiler is needed.
11:16:40 <vegai> lambdabot: ?
11:16:53 <vegai> ah, need to register for private messages
11:16:53 <lambdabot> WHAT?
11:17:13 <vegai> heh
11:18:07 * vegai wonders how echo can be turned off
11:18:37 <shapr> Man I love these Sennheiser headphones! w00!
11:18:50 <vegai> i.e. do a "getChar" without the character being output on the screen
11:18:54 <reppie[^_^]> w00t
11:19:00 <vegai> shapr: oyy. *envy*
11:19:29 <vegai> these sony mdr-xd300 aren't too bad but probably not Sennheisers either..
11:19:31 <shapr> vegai: Only 80e, you can afford 'em!
11:19:47 * vegai ponders.
11:19:51 <psi> I like my Grado SR-60
11:19:57 <vegai> need to fool my cat to eat the cord off these ones first
11:19:59 <vegai> or something
11:20:08 <psi> my ibook has too crappy output to do them justice, though
11:20:51 <shapr> I went for the PC 160 headset. The PC 155 USB headset is 100e. One day I hope to buy some of the 6xx headphones.
11:22:06 <vegai> ah, found it. System.IO.hSetEcho
11:32:54 <lisppaste2> greenrd pasted "Why are the instances overlapping?" at http://paste.lisp.org/display/11271
11:33:10 <greenrd> Can someone help me understand why I am getting 3 overlapping instances for this code?
11:34:14 <lisppaste2> greenrd annotated #11271 with "errors received" at http://paste.lisp.org/display/11271#1
11:36:13 <basti_> greenrd: because lte is defined 3 ways
11:37:06 <greenrd> Sure, but that's allowed, isn't it?
11:37:11 <greenrd> I don't really understand the error message.
11:37:20 <greenrd> I understand that instances can overlap.
11:37:30 <greenrd> But I don't understand why _these_ instances overlap in _this_ code.
11:38:39 <greenrd> btw, the line "lte = \_ _ -> True" is just a dummy stub which I'll replace with real code later
11:38:59 <basti_> i think, because lte is instantiated three times, but "differently"
11:39:05 <basti_> as in, not "inherited" three times the same
11:39:26 <CosmicRay> shapr: what's your opinion of http://sequence.complete.org/node/92?  should I delete it?  ban the guy?
11:40:09 <greenrd> basti_: Well I don't understand this concept of "inheritance" in Haskell. What is it and how does it occur here?
11:40:20 <greenrd> I know inheritance in Java of course.
11:40:25 <Igloo> greenrd: [a] could match either of the first 2 instances
11:40:47 <monochrom> whenever you have "class Eq a => PartialOrder a where ..." you have inheritance.
11:40:59 <basti_> greenrd: i was referring to "=>". you define things in term of other, known things
11:41:20 <greenrd> basti_: ah ok
11:41:24 <shapr> CosmicRay: Why would someone put Linux advocacy onto a Haskell blog?
11:41:25 <basti_> now in your case, the problem seems to be that there's 3 ways of explaining lte in some situation.
11:41:33 <greenrd> basti_: yeah
11:41:35 <CosmicRay> shapr: I have no idea.
11:41:46 <CosmicRay> shapr: and post an entire text copy of the pdf that he was writing?
11:41:54 <shapr> Yeah, what's up with that?
11:42:01 <CosmicRay> it seemed like spam to me, but then again he didn't manage to actually link anywhere
11:42:27 <Igloo> If it's not on topic I'd remove it
11:42:29 <CosmicRay> anyway, sorry for the late HWN edition, everyone.
11:42:43 <basti_> greenrd: I don't actually see how to fix that, but i would try to restrict some types.
11:42:55 <basti_> so that there's only one choice left for lte
11:43:12 <shapr> Yeah, I agree with Igloo, I'd delete the post and send an email to the guy saying "Hey, this site is for the Haskell programming language."
11:43:29 <swiert> CosmicRay: I'm not sure if enough people have said this - but I really appreciate HWN.
11:43:37 <swiert> keep up the good work!
11:44:12 <CosmicRay> shapr: good idea, will do.
11:44:14 <CosmicRay> thanks, swiert.
11:44:54 <shapr> CosmicRay: Yeah, let me add my voice to the chorus, HWN is great!
11:45:08 <CosmicRay> thanks, shapr.   so is TMR, btw.
11:45:21 * xerox hugs CosmicRay too
11:45:48 <astrolabe> HWN?
11:45:50 * CosmicRay smiles and wipes off the toner dust
11:45:50 <shapr> Sadly, I don't have the time and energy necessary to chase people to get articles.
11:45:59 <CosmicRay> astrolabe: http://sequence.complete.org/hwn
11:46:05 <astrolabe> thanks
11:46:06 <rasfar> @hoogle HWN
11:46:07 <CosmicRay> shapr: I can totally understand that.
11:46:20 <CosmicRay> shapr: for HWN, the articles come to me ;-)
11:46:41 <astrolabe> Oh cool
11:47:37 <CosmicRay> shapr: interestingly, the account from which that large item was posted is registered at a hotmail address, which is different than the address listed in the post.
11:47:47 <monochrom> Hahaha, I should post to the HWN blog to advocate the use of the predicate transformer semantics to model imperative programs.
11:48:17 * xerox pretends to understand monochrom and nods
11:48:30 <greenrd> That's gotta be a joke with a limited audience
11:48:56 <monochrom> Yeah, limited to an audience that has heard of imperative programming.
11:49:02 <shapr> CosmicRay: bizarre.
11:49:06 <CosmicRay> greenrd: it's funny on so many levels.  To me, it's "Haha -- he'd spend time writing about something that nobody cares about." ;-)
11:49:12 <xerox> monochrom: could you elaborate on that? :-)
11:49:30 <monochrom> predicate transformer = weakest precondition
11:49:39 <xerox> Oh, an equation.
11:49:42 <CosmicRay> monochrom: well, I've heard of imperative programming, but I have no idea what predicate transformer semantics are
11:50:17 <CosmicRay> DAMMIT I HATE FREENODE
11:50:20 <CosmicRay> --- Unregistered users cannot currently send private messages, due to problems with spam. Please register! ( http://freenode.net/faq.shtml#nicksetu
11:50:35 <xerox> lilo has you!
11:50:38 <monochrom> haha
11:51:52 <xerox> So, I'm alone on haskell@silcnet.
11:52:00 <greenrd> Everyone should register, anyway. I learned that on a more trollish channel - if you don't register, someone could impersonate you and make you look a fool.
11:52:28 <greenrd> Still, someone could impersonate you anyway, I suppose, just not using the exact same nick.
11:52:37 <monochrom> if you register, someone could steal your password
11:52:43 <CosmicRay> I'm registered, but I don't see the need to identify always
11:52:47 <greenrd> monochrom: Gasp!
11:53:13 <xerox> CosmicRay: let the client do it for you.
11:53:23 <greenrd> yeah, xchat can do that
11:53:25 <CosmicRay> xerox: too much work to learn how to do that for zero gain.
11:53:30 <CosmicRay> I have never had a problem before.
11:53:55 <greenrd> well, there aren't too many trolls on this type of channel it seems.
11:54:23 <rasfar> (It is quite ironic that "@" lists commands up to but not including "@more"...)
11:54:52 <monochrom> haha
11:54:53 <xerox> haha
11:55:03 * rasfar bows
12:00:13 <greenrd> OK, so, any ideas anyone, on how I could resolve the overlap of these 2 instances:
12:00:18 <greenrd> instance (Ord a) => PartialOrder a
12:00:24 <greenrd> instance (PartialOrder a) => PartialOrder [a]
12:00:28 <basti_> greenrd: hey thats a partial success! :D
12:00:37 <greenrd> is it?
12:00:39 <chrisbrown> hi
12:00:46 <basti_> yes its only 2 overlaps left, isnt it?
12:01:06 <greenrd> no, I haven't changed anything yet
12:01:10 <basti_> oh ok.
12:01:12 <basti_> i think Ord a => Ord [a].
12:01:15 <greenrd> I'm just focusing on these 2 for now
12:01:26 <greenrd> Ord a => Ord [a] is already defined (I think)
12:01:28 <basti_> that means => PartialOrder [a]
12:01:30 <basti_> yes
12:01:34 <greenrd> yeah
12:01:40 <basti_> that forms the second way for your overlap
12:01:53 <greenrd> yeah
12:02:16 <basti_> :)
12:02:22 <greenrd> OK, so how could I solve it?
12:02:36 <greenrd> I mean this seems like a pretty basic Haskell problem of modelling mathematical concepts
12:02:43 <greenrd> Someone must have solved it before...?
12:02:57 <basti_> try commenting out PartialOrder a => PartialOrder [æ]
12:02:59 <basti_> [a]
12:03:32 <basti_> because, if you can derive PO a from Ord a, and Ord [a] from Ord a, then you dont need to explicitely derive PO [a] from PO a.
12:04:50 <astrolabe> Isn't Ord meant to represent total orders?
12:05:07 <monochrom> yes
12:05:14 <basti_> astrolabe: do not interrupt the train of thoughts!
12:05:17 <monochrom> and total orders are partial orders too
12:05:44 <ndm> does anyone have an up to date copy of Hugs, ideally a CVS one?
12:05:50 <xerox> boegel: ping
12:06:02 <astrolabe> basti.  Sorry ;)     Have I got my order of derivation muddled then?
12:06:15 <reppie[^_^]> someone should write a "linux considered harmful" article.
12:06:16 <basti_> astrolabe: i think he's still thinking.
12:07:09 <monochrom> if X is a special case of Y, you will want "class Y a => X a where ..."
12:07:19 <basti_> you're both completely right
12:07:31 <basti_> that just doesnt tell anything about haskell. :D
12:07:49 <basti_> < greenrd> I mean this seems like a pretty basic Haskell problem of modelling mathematical concepts
12:08:04 <basti_> maybe it does, though.
12:08:26 <monochrom> Isabelle poses no problem.  This is because Isabelle is a theorem proving environment. :)
12:10:38 <monochrom> Multiple inheritance is always a difficulty in programming, non-proving environments.
12:11:05 <basti_> but proofs are programs.
12:13:27 <greenrd> monochrom: Ah yes of course. Multiple inheritance. Now I recognise it.
12:14:16 <greenrd> What I really want to do is nominate one implementation which I think is likely to be the most efficient.
12:14:20 <greenrd> Can I do that in Haskell?
12:15:19 <vegai> is there a function that erases the current line in console?
12:15:28 <vegai> or do I have to do it character by character?
12:15:33 <greenrd> Maybe Haskell prefers more specific instances
12:15:36 <basti_> vegai: tried ANSI?
12:15:36 * greenrd experiments
12:16:52 <greenrd> Actually no, it's not about efficiency because the semantics differ
12:17:00 <basti_> greenrd: actually, you should only have to define Ord a => PartialOrder a.
12:17:07 <basti_> just like people pointed out
12:17:25 <basti_> if you can't stand how this is done then, then youre bitten.
12:17:29 <rasfar> vergai: ^u?
12:17:46 <tuomov> ^u^k
12:17:58 <tuomov> or do you mean curses or something?
12:18:10 <vegai> no, regular stdout
12:18:11 <rasfar> ya, whaddaya mean "console"?
12:18:27 <greenrd> basti_: The problem is Ord [a] doesn't have the semantics I want
12:18:33 <tuomov> there's no standard way to do it. you'd have to figure it out from terminfo or termcap
12:18:39 <basti_> greenrd: that sucks a lot, then.
12:18:58 <greenrd> basti_: So I actually have to eliminate Ord a => PartialOrder a
12:18:59 <basti_> greenrd: did you try providing your own semantics for that?
12:19:19 <greenrd> basti_: No, but I think it would be too confusing even if it did work.
12:19:32 <greenrd> Really the problem is, I'm not defining _the_ partial order on lists, I'
12:19:37 <basti_> you'd need to hide Ord [a] in Data.List
12:19:41 <greenrd> m defining _a_ partial order, one of many possibilities.
12:19:47 <basti_> i don't know how confusing that would be
12:19:49 <basti_> rather not
12:19:56 <xerox> heh I found (incidentally) how to approximate a curve with an L-System!
12:20:02 <greenrd> aha
12:20:25 <xerox> But I was trying making a nice tree, grumble.
12:20:26 <xerox> :-D
12:20:58 <greenrd> Actually I need to check the semantics - I'm not sure if they're what I want or not
12:21:08 <basti_> import Data.List hiding (Something)
12:21:19 <vegai> tuomov: aye :/
12:21:28 <basti_> but now how to hide a type implication?
12:21:29 <basti_> mmmh
12:21:55 <rasfar> Can an embedded tree be considered a curve?
12:24:08 <vegai> unix terminals are really handicapped :/
12:24:30 <tuomov> must terminals know vt100, though
12:24:47 <tuomov> in practice it thus doesn't matter
12:25:55 <basti_> greenrd: ah the instance is in the Prelude
12:26:49 <basti_> so everyone: how can i hide instance declarations from imported modules? not at all?
12:27:42 <kosmikus> basti_: afaik, you cannot
12:27:51 <greenrd> :(
12:28:04 <basti_> that would not make much sense anyway
12:28:09 <basti_> maybe something in the module relies on it
12:29:03 <greenrd> I cannot specialise the instance declaration either (well, that's really advanced, I don't know any language that allows the equivalent of that)
12:29:38 <greenrd> I wonder if there is some research paper on extending Haskell to support this kind of thing?
12:29:54 <greenrd> Otherwise I will have to use wrapper types or something (I guess that's what people do today)
12:30:02 <basti_> greenrd: you could make an own list type, and give it all the properties you need
12:30:03 <rasfar> vergai, I tried outputting \025 and it doesn't work in my xterm.  I guess ^u is shell-specific.
12:30:05 <monochrom> yes, that's what people do today
12:30:08 <greenrd> basti_: ugh :)
12:30:13 <basti_> greenrd: why?
12:30:21 <greenrd> basti_: I don't want to reimplement all the list functions :)
12:30:50 <basti_> ah the new Type a would be an instance of [a] of course.
12:30:53 <greenrd> anyway, I'm not sure the semantics _are_ different.
12:30:58 <basti_> hmm but would that help?
12:31:00 * basti_ ponders
12:31:37 <basti_> actually, the ordering on lists is lexicalic
12:31:47 <basti_> i doubt there is some other definition that makes sense
12:32:22 <greenrd> basti_: Are you sure? I don't seem to have the source for anything installed here
12:32:28 <xerox> My LSystem are always circle-shaped, uhmpf
12:32:41 <basti_> @eval  sort ["","def","ab","aa","a"]
12:33:04 <lambdabot> ["","a","aa","ab","def"]
12:33:12 <basti_> took some time, but worked out.
12:33:33 <greenrd> My semantics _are_ different then after all.
12:33:50 <basti_> hmm
12:33:54 <greenrd> I want a "line-like" semantics.
12:33:56 <basti_> so how do you want your lists to be ordered?
12:34:50 <humasect> is it alright to spread IO actions all over the place? like not all in one
12:35:07 <monochrom> yes
12:35:07 <humasect> +all in one "application". otherwise one has to "save" the values.
12:35:09 <vegai> hmm, I could be very unixy and use "\r" to go to the beginning of line
12:35:10 <basti_> yes
12:35:30 <vegai> that doesn't work on MS systems, right?
12:35:32 <greenrd> basti_: lte list = and (zipWith lte list)
12:35:43 <greenrd> vegai: It does actually.
12:35:47 <humasect> okay thanks. i've been restraining myself
12:36:21 <basti_> greenrd: uhm
12:36:27 <greenrd> vegai: Remember, you need to explicitly specify \r after \n on Windows
12:36:42 <vegai> oh, excellent
12:36:48 <basti_> greenrd: zipWith expects 2 parameters?
12:36:49 <vegai> not that I care actually, but...
12:37:05 <greenrd> @type zipWith
12:37:07 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
12:37:16 <greenrd> whoops
12:37:25 <greenrd> I was confused
12:37:33 <greenrd> lte list1 list2 = and (zipWith lte list1 list2)
12:37:38 <basti_> oh
12:37:56 <basti_> so if ONE element in list2 is >, then the whole list is >?
12:38:06 <greenrd> Yes.
12:38:17 <basti_> azzzzzzzz < baaaaaaa
12:38:22 <greenrd> Yes
12:38:25 <basti_> zzzzzza < aaaaaab
12:38:33 <greenrd> whoops
12:38:38 <basti_> ?
12:38:40 <basti_> :D
12:38:42 <monochrom> There are two of the principles of software engineering called decoupling (now aka factoring, refactoring) and cohesion.  Lately I observe that decoupling is overemphasized and no one talks of cohesion.  For example in OOP you are forced to, even encouraged to, split one concept over several classes.
12:39:02 <greenrd> azzzzzzzz > baaaaaaa
12:39:14 <basti_> oh yes that too
12:39:18 <basti_> youre right
12:39:18 <greenrd> zzzzzza > aaaaaab
12:39:27 <basti_> im sorry
12:39:31 <greenrd> So I don't want lexicographic
12:39:56 <basti_> but you do want ab > ba?
12:40:08 <basti_> and even ba > ab?
12:40:15 <basti_> even though thats not antisymetry!
12:40:23 <greenrd> No, I want ab <= ba and ba <= ab.
12:40:31 <monochrom> remember that you may like to have just a partial order
12:40:40 <basti_> hmm
12:40:47 <greenrd> hold on
12:40:54 <greenrd> no that's not right is it
12:41:00 <greenrd> I should think before I type!
12:41:04 <basti_> i do not believe you intend that
12:41:08 <monochrom> you can declare ab and ba incomparable
12:41:27 <basti_> but your function certainly gives the same results for both cases
12:41:58 <greenrd> yeah of course, I want ab and ba incomparable - thanks monochrom
12:42:04 <monochrom> you refer to lte list1 list2 = and (zipWith lte list1 list2) ?  no, it will do as I say.
12:42:04 <basti_> hmm
12:42:30 <monochrom> you will find lte "ab "ba" and let "ba" "ab" both false.
12:42:38 <monochrom> s/let/lte/
12:42:46 <greenrd> monochrom: Yes, I agree. I made a momentary mistake there.
12:42:49 <basti_> mmmok.
12:42:56 * basti_ nods
12:43:03 <greenrd> monochrom: It seems like I need to do a split here. There are at least two valid kinds of partial orders on lists - mine, and lexicographic.
12:43:28 <monochrom> you cannot, however, deduce "therefore gt "ab" "ba" and gt "ba" "ab" both are true!"
12:43:37 <greenrd> Quite.
12:43:44 <basti_> monochrom: youre completly right yes.
12:44:10 <monochrom> (If you had Ord you could deduce that.)
12:44:17 <greenrd> yeah
12:44:19 <basti_> so greenrd seems like we actually found your problem :D
12:44:50 <greenrd> OK, so we've established what the problem _is_.
12:45:01 <basti_> -g-
12:45:38 <greenrd> monochrom: So I think I need to have lt as a function which is _associated_ with a list, but not a function that is defined for all lists of partially-ordered elements (as it is now).
12:46:14 <greenrd> In other words I need polymorphism.
12:46:20 <monochrom> There is a third well-know partial order.  class Eq a => PrefixOrder [a] where lte = List.isPrefixOf
12:46:29 <greenrd> ok
12:46:33 <xerox> OK, I _need_ boegel!
12:46:43 <xerox> boegel! Coooooome heeeeeereee!
12:46:46 <greenrd> I need LexicographicList, PrefixList (well I don't for my application but someone might) and LineList.
12:47:02 <basti_> maybe you can define some instance that makes sense. as in: PO a => PO [a], but not Ord a => PO a (since that destroys your setup)
12:47:16 <greenrd> I can define those three as data types, and then make _them_ instances of PartialOrder.
12:47:31 <greenrd> Instead of making (PartialOrder a) => [a] an instance of PartialOrder.
12:47:39 * basti_ swallows
12:47:41 <basti_> ;)
12:48:39 <greenrd> So yeah, I guess I was right earlier when I said "wrapper types".
12:49:15 <greenrd> But the disambiguation provided by wrappers really is needed, it's not a limitation of haskell, it's a fundamental ambiguity that wrapper types are one way of solving.
12:49:21 <greenrd> :)
12:49:29 <basti_> i agree on that
12:50:09 <basti_> would be quite nice to be able to do that stuff though
12:50:51 <basti_> as in: compare gives "ambigious error" and you have to do Data.List.Prefix.compare
12:50:54 <basti_> or something
12:51:37 <greenrd> hmmm
12:52:09 <basti_> but, won't happen soon
12:52:23 <greenrd> That syntax is used indeed in Java, but for something else - scoping collisions between inner classes and outer classes.
12:52:38 <greenrd> It's very necessary there, I think.
12:52:41 <basti_> haskell has the same notation for modules
12:54:11 <greenrd> I think that types should as far as possible automatically determine which implementation to call.
12:54:38 <basti_> how, if its ambigious?
12:54:41 <greenrd> heh
12:54:43 <basti_> that has to be an user decision
12:55:24 <greenrd> Well, it should be generalisable. The user shouldn't have to specify it every time if it is going to be deducable from the types every time.
12:55:42 <basti_> you could have him set a default
12:55:46 <basti_> for a file maybe
12:56:11 <basti_> i mean, i never encountered that sort of problem.
12:56:13 <greenrd> But of course if it's deducible then it's not "inherently" ambiguous. Just might be beyond the language's power to deduce/define.
12:56:53 <basti_> i wouldnt know how to find out of the user intends to compare by matching prefix or lexicographically
12:57:18 <greenrd> No, indeed, in my case, it is inherently ambiguous without wrapper types, or choosing one way by fiat.
12:57:29 <basti_> heh -g-
12:57:38 <greenrd> But in other cases there might be only one way that makes sense.
12:57:51 <boegel|home> xerox: posted on your blog already ?
12:57:52 <greenrd> Or all ways might be functionally equivalent, just implemented differently.
13:03:40 <boegel|home> xerox: just read it, cool post, I hope you get lot's of feedback on it :) (and lot's of money from google :p)
13:10:58 <xerox> boegel, yeah, I would appreciate getting comments :-D
13:11:03 <greenrd> Unfortunately, I made those 3 new instances and got rid of the old instance for PartialOrder a => PartialOrder [a] but that did not help.
13:11:15 <xerox> boegel, I have some questions for you, could I pm you?
13:11:20 <greenrd> Now I have even more "overlapping instances" error messages!
13:13:29 <xerox> boegel|home: maybe I should refer you directly so that your client blings or something ;-)
13:14:19 <greenrd> It seems that it thinks LineList is an Ord, even though I have not derived or implemented Ord.
13:17:18 <greenrd> But I'm not sure.
13:18:16 <boegel|home> xerox: sorry, I was away for a few minutes
13:18:35 <boegel|home> stupid ants with wings in my room, no fun :( and we can't seem to track where they get into the house
13:19:03 <boegel|home> anyways, feel free to pm me (and do it now, or be willing to wait another ten minutes, because I want to take a shower too)
13:19:11 <lisppaste2> greenrd pasted "New code" at http://paste.lisp.org/display/11274
13:19:39 <lisppaste2> greenrd annotated #11274 with "New error messages" at http://paste.lisp.org/display/11274#1
13:19:42 <boegel|home> xerox: I added a comment, just to get things started :)
13:21:03 <greenrd> basti_, monochrom: Any ideas about what these errors mean?
13:21:34 * boegel|home showers
13:21:48 <boegel|home> (xerox, I'll be back in 10-15 minutes)
13:22:36 * basti_ takes a look
13:23:16 <xerox> boegel|home: oh, great!
13:23:18 * greenrd tries rewriting the points-free code as more sane code and sees if that helps
13:23:46 <basti_> greenrd: did you try with -fallow-overlapping-instances, as the error says? :D
13:24:08 <xerox> Oi!  People, I added some new shots :-D
13:24:10 <xerox> http://www.haskell.org/gtk2hs/gallery/Cairo-demo
13:24:13 <xerox> Enjoy!
13:24:14 <greenrd> basti_: Nope - I want to understand why I get this.
13:24:32 <greenrd> And rewriting the points-free code as non-points-free doesn't help.
13:25:05 <Oeje1> hello boegel.
13:26:10 <greenrd> basti_: OK, it seems like a bug.
13:26:24 <greenrd> Read carefully the first error message
13:26:53 <basti_> greenrd: hmm its the same problem over again I think.
13:26:54 <greenrd> It says that "instance (Ord a) => PartialOrder a" matches (matches what exactly, I'm not sure).
13:27:07 <greenrd> But then, when I try with -fallow-incoherent-instances, it says:
13:27:09 <basti_> you have two instances for the same thing
13:27:13 <greenrd> "No instance for (Ord a)"
13:27:21 <basti_> :D
13:27:22 <basti_> cool.
13:27:25 <greenrd> again at 26:0
13:27:27 <greenrd> bug, no?
13:27:31 <basti_> no
13:27:37 <greenrd> Because I didn't _ask_ for an instance of Ord a.
13:27:40 <basti_> stop deriving PartialOrder from Ord.
13:27:59 <greenrd> But Ord is not present here!
13:28:04 <greenrd> It's not relevant!
13:28:06 <xerox> boegel|home: ping me when you're back :-)
13:28:11 <greenrd> It suggested this instance, but then it tried to apply it, and it couldn't.
13:28:14 <greenrd> Therefore, compiler bug.
13:28:19 <basti_> you know better than the compiler yes? :D
13:28:22 <greenrd> hehe, yes
13:28:31 <greenrd> Until I find out I don't ... which is 99% of the time ;)
13:29:06 <basti_> stop deriving PartialOrder from Ord
13:29:20 <basti_> that will break everything all the time because you can derive so much stuff from Ord.
13:29:27 <greenrd> Well, obviously that will stop the bug triggering.
13:29:32 <greenrd> But I don't want to do that.
13:29:39 <greenrd> Because a total order is obviously a partial order.
13:30:05 <greenrd> Look, either it (whatever the compiler is complaining about) is an instance of Ord, or it isn't.
13:30:07 <basti_> yes, but, as we learned, your partial orders are not the same as the total order that is implied
13:30:53 <greenrd> well, true, but we can define haskell's predefined total orders as canonical partial orders, where they exist.
13:31:14 <basti_> yes but then you can't define others.
13:31:23 <greenrd> No, you can, you use wrapper types.
13:31:31 <greenrd> Which is what you should do anyway.
13:32:54 <basti_> when they're Ord, there is a total order imposed. When you derive your partial order from that, it will be the same ordering.
13:33:01 <basti_> you can't stop that from happen.
13:33:22 <basti_> you could, however, redefine Ord on these types.
13:35:05 <greenrd> Yes but my LineList should not be Ord.
13:35:16 <greenrd> data (PartialOrder a) => LineList a = LineList [a] deriving (Eq, Show)
13:35:26 <greenrd> Does deriving Eq imply deriving Ord? No, it can't.
13:35:36 <greenrd> Does deriving Show imply deriving Ord? Seems unlikely.
13:35:49 <basti_> instance (Ord a) => PartialOrder a where
13:35:50 <basti_>         lte = (<=)
13:36:01 <basti_> does deriving PartialOrder from Ord derive Ord?
13:36:04 <boegel|home> xerox: pong !
13:36:13 <boegel|home> yo Oeje1
13:36:14 <xerox> boegel|home: http://www.haskell.org/gtk2hs/gallery/Cairo-demo !
13:36:41 <greenrd> basti_: No, it can't, because that would be backwards.
13:36:55 <greenrd> basti_: All Ords (total orders) are partial orders, but the reverse is not true.
13:37:11 <boegel|home> xerox: yeah, I'm checking it out, cool !
13:37:37 <xerox> boegel|home: I just added some shots, tough I'd like to be able to do better things ;-)
13:37:44 <boegel|home> I told you you should've waited to post it on your blog, now you can't add the pretty pictures !
13:37:55 <xerox> boegel|home: I can!
13:38:09 <boegel|home> xerox: there are some very cool L-Systems available, I can ask an expert if you like :)
13:38:30 <xerox> Yes!
13:38:42 <boegel|home> someone who likes L-systems not because they produce pretty pictures, but because they have neat properties (mathematically)
13:38:43 <Itkovian> yo
13:38:50 * boegel|home yows back
13:39:04 <xerox> Mumble mumble, is he on IRC?
13:39:28 <Itkovian> i think not.
13:39:32 <boegel|home> xerox: no, I don't think so, but I'll mail him right now, and I'm sure he'll reply tomorrow (or maybe even tonight, although I doubt that)
13:39:41 <boegel|home> I'll see him on the train tomorrow though :)
13:39:46 <Itkovian> nono, pieter doesn't read mail at night afaik
13:42:34 <boegel|home> well, he'll reply tomorrow then
13:42:49 <boegel|home> xerox: mail sent, I'll let you know tomorrow, is that ok ?
13:42:55 <Itkovian> I think you can find cookl stuff at the wikipedia page too
13:43:17 <boegel|home> Itkovian: yeah, but I'm sure L-Systems are capable of much cooler things too
13:43:35 <Itkovian> hmm, true
13:43:36 <boegel|home> with the necessary adjustments you can even generate feathers and stuff
13:43:55 * boegel|home decides to add a new news item to his HaskLS website
13:44:11 <Itkovian> I am going to have a bit of fun with my girl ... cuddle and stuff ... ttyl
13:44:22 <vegai> is there an action that would take anything that hasn't been flushed yet from stdin?
13:44:51 <vegai> I need to take x <- getChar but if something is left in the buffer, I get the rest with another function
13:45:33 <boegel|home> Itkovian: yukkie :)
13:45:48 <boegel|home> you know that girls are where cooties come from ?
13:45:56 <SyntaxNinja> y0
13:46:26 <Itkovian> http://fractint.oblivion.cz./
13:47:23 <boegel|home> xerox: what is the correct term for Cairo ? vector-based library ?
13:48:09 <greenrd> When I hear Cairo, I always think of Windows Cairo, that fabled "object-oriented operating system".
13:48:14 <TheHunter> hGetBufNonBlocking ?
13:48:17 <boegel|home> Itkovian: the syntax is quite weird though
13:48:21 <greenrd> I wonder if anyone at MS is still working on those ideas?
13:48:44 <greenrd> Maybe, with a shell named "Monad", MS is looking more at functional programming as the next frontier these days.
13:49:02 <markg> Naw, monad just sounds impressive
13:49:05 <greenrd> Or maybe that's just a cool-sounding name which has little to do with monads, I have no idea.
13:50:26 <markg> I'm trying to analyse the time profiling of a program.  I've compiled everything with profiling support, run it with the proper run time flags and then when I run ghcprof it fails inexplicably
13:50:35 <markg> or inexplicably to this noob
13:50:57 <humasect> @type run
13:51:09 <lambdabot> bzzt
13:51:48 <markg> a perl script that it is looking for seems to be missing. I've followed all the documentation for profiling on the web-pages
13:52:01 <markg> I was wondering if the documentation was old or I just missed something
13:52:03 <boegel|home> xerox: about what did you want me to talk with me ?
13:52:10 <markg> anyone have any pointers?
13:54:10 <SyntaxNinja> *markg
13:54:27 <cathper> :-D
13:55:06 <monochrom> I want to see what is meant by "fail"
13:55:51 <monochrom> I think it is imperative that all programmers pass a physics lab class.  That way they know how to describe observations properly.
13:56:40 <monochrom> They will never say "it doesn't work" again.
13:57:08 <markg> The status bar in davinci/uDraw says: Cannot start application "/usr/lib/ghc-6.6/cgprof"
13:57:23 <monochrom> 6.6 !!
13:57:48 <markg> when cgprof is run by itself it says: The perl script bspsgprof is buggered
13:57:55 <markg> sorry typo 6.4
13:58:02 <greenrd> heh
13:58:06 <greenrd> nice error msg
13:58:10 * boegel|home pokes xero
13:58:16 <boegel|home> *xerox
13:58:21 <humasect> @find run
13:58:22 <greenrd> monochrom: heh
13:58:23 <lambdabot> bzzt
13:58:27 <humasect> @listcommands
13:58:27 <markg> locate bspsgprof returns nothing
13:58:28 <lambdabot> use listcommands [module|command], please. Modules are:
13:58:28 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
13:58:28 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
13:58:28 <lambdabot> spell state system todo topic type version vixen where
13:58:33 <greenrd> monochrom: Surely physicists say "It doesn't work" too.
13:58:35 * boegel|home is amazed as he just noticed xerox just left !
13:58:39 <humasect> i uhh
13:58:47 <monochrom> I hate to speculate that your installation process was buggered.
13:59:04 <humasect> @hoogle run
13:59:04 <markg> Its the debian package available from apt-get
13:59:05 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
13:59:18 <monochrom> I haven't heard a physicist say that regarding their work.
13:59:30 <monochrom> (Of course they say that in bars all the time.)
13:59:34 <greenrd> hehe
13:59:53 <greenrd> How about apparatus? Apparatus not working?
14:00:18 <greenrd> Are you not allowed to say that apparatus is not working?
14:00:28 <monochrom> They normally say a few more specific words than that.
14:00:34 <greenrd> Well, OK.
14:00:43 <greenrd> Like how computer scientists rarely say "computer".
14:00:47 <markg> I just checked out the repository for ghc and performed a find for that name and it fails to find anything as well
14:00:57 * boegel|home leaves to get some sleep and such
14:01:00 <boegel|home> g'night everyone
14:01:03 <monochrom> You can do that, but after a while you find out that you have to say a few more words sooner or later, and it may as well be sooner.
14:01:13 <rasfar> g'nite, boegel
14:01:15 <markg> computer scientests usually say "the damn box" or some such in my experience
14:01:19 <greenrd> hehe
14:01:35 <greenrd> "computer" has too many syllables
14:01:37 <monochrom> Please don't confuse computer scientists with damn programmers.
14:01:43 <markg> I don't
14:01:54 <markg> programmers are the janitors of the computer science sorld
14:01:57 <markg> err world
14:02:06 <humasect> =D
14:02:30 <Spark> and microsoft is the macdonalds of software houses
14:02:58 <humasect> and google is the martha stewart of the web ?
14:03:17 <monochrom> I can't help with this buggered perl script problem.  I don't use the debian package to boot; I don't use debian actually.
14:03:41 <monochrom> (Moreover I'm still at 6.2.1)
14:04:06 <markg> I don't normally use debian either, but thats what work uses.
14:04:17 <markg> and they aren't going to change for the new guy
14:04:32 <monochrom> Normally the debian package is preferred.
14:05:13 <monochrom> A lot of Haskell fans are debian fans too; they work hard to make a proper debian package.
14:05:40 <markg> I know, thats why this is so puzzling to me.
14:06:44 <rt_> blackbird: sure, hit me.
14:06:46 <monochrom> would it be a simple problem with the PATH ?
14:07:39 <monochrom> it may even be possible that PATH points to an older version of ghc, and therefore a new version script calls upon an old version helper and is buggered.
14:07:41 <markg> the file isn't located anywhere on my system, nor the systems of anyone else in my office
14:08:11 <markg> The path points to where the executables I'm currently running are and there is only one copy installed
14:08:29 <markg> (I was handed a heap of code and told to optimize it.)
14:08:41 <markg> No one else seems to have done it before
14:11:24 <greenrd> Well, it's quite possible that someone @ debian made a packaging error.
14:11:49 <greenrd> If the file genuinely is not anywhere on your system, I'd say that's enough to report a bug to the debian bug tracking system, in itself.
14:13:08 <monochrom> True, Sherlock Holmes would advise "note that it is not impossible, just improbable"
14:15:57 <greenrd> hehe
14:16:15 <greenrd> I would think that depends very much on the packager and on their level of acquaintance with what they are packaging.
14:16:36 <markg> well find / -name bspsgprof doesn't find it
14:16:40 <greenrd> I haven't become a Fedora Extras packager yet because I'm quite pedantic about getting packages right.
14:17:12 <rasfar> Don't you need the .pl suffix to find it that way?
14:17:30 <cinema_> markg, look at http://www.dcs.warwick.ac.uk/people/academic/Stephen.Jarvis/profiler/index.html
14:18:08 <markg> rasfar: If it has a .pl extention
14:18:23 <cinema_> you'll see that cgprof depends on the Oxford BSP Toolset
14:18:37 <markg> locate didn't find it either and it just checks to see if its a substring in the path
14:18:44 <cinema_> whose access is forbidden !
14:19:30 <cinema_> this is the reason for the name ' bspsgprof'. It's probably an unmaintained feature
14:20:59 <markg> So I can't use ghcprof?
14:21:14 <cinema_> Anyhow, daVinci was a proprietary tool, and furthermore it has changed its name recently, I think
14:21:18 <markg> All I want to do is time analysis on my program, are there other tools that I should use?
14:21:41 <greenrd> you want to ANALYSE the PERFORMANCE of Haskell programs?
14:21:47 <markg> daVinci is now uDrawGraph or some such but it claims backwards compatability
14:21:47 <greenrd> You're braver than I am
14:21:51 <greenrd> That subject scares me
14:22:04 <cinema_> You should check ghc mailing list, there are posts related to profiling
14:22:04 <markg> I just need to know which function I'm spending all my time in.
14:22:12 <SyntaxNinja> markg: this should be possible. I was just staring at performance graphs today
14:22:20 <SyntaxNinja> markg: so you want to look at graphs rather than the raw data, right?
14:23:04 <markg> Yeah, or at least figure out what all the columns and numbers mean
14:26:57 <poetix> Oops, error building gtk2hs
14:27:03 <poetix> It was going pretty well, too...
14:29:27 <SyntaxNinja> markg: one guy who does that here isn't in right nmow, but I'll be sure to ask him when he gets back
14:29:37 <SyntaxNinja> I asked in brief if it was easy to generate the graphs, and he said it was
14:29:48 <markg> Thanks
14:29:50 <markg> I appreciate it
14:32:45 <poetix> OK, fixed that one - it wants a copy of cairo.h in the cairo subdirectory of the source tree, and there isn't one there, so just copied it from /opt/gnome/cairo
14:34:19 <poetix> Now another problem - "Error in C header file!" in /opt/gnome/include/gconf/2/gconf/changeset.h
14:35:05 <poetix> Syntax error - "The symbol "G_GNUC_SENTINAL" does not fit here"
14:35:38 <poetix> A failure from c2hsLocal
14:35:50 <Micket> Hey guys. Im looking for a way to add a type signature for a function under "where". Is that possible?
14:35:57 <SyntaxNinja> shapr I sent you msgs in case you can't hear me.  I have no idea what's going on w/ this irc server at this point. let me know if I need to re-send
14:36:13 <SyntaxNinja> spammers ruign everything
14:36:23 <TheHunter> Micket, yes, but in general you will need extensions. Do you have ghc-6.4 ?
14:36:39 <Micket> I shall take a look.
14:36:46 <cinema_> BitShifter, This was the message I was referring to : http://www.haskell.org//pipermail/haskell-cafe/2005-August/011038.html
14:36:57 <Micket> yup
14:37:53 <TheHunter> does just giving the function the type signature work or does the type signature mention variables from the type signature of the top-level function?
14:38:55 <greenrd> Micket: I thought that type signatures for functions in let works without extensions - can't you just use that?
14:39:33 <TheHunter> where and let behave the same way in that respect.
14:39:33 <greenrd> Micket: Or is this in an instance declaration?
14:39:40 <TheHunter> NEVER use let instead of where.
14:39:44 <greenrd> heh
14:39:46 <greenrd> Why not?
14:39:54 <TheHunter> because it looks ugly.
14:39:56 <greenrd> heh
14:40:03 <greenrd> matter of opinion
14:40:05 <Micket> Uhm. Im not sure what to answer to this, as im kinda new to this.
14:40:14 <TheHunter> can you post your code?
14:40:20 <Micket> sure
14:40:24 <greenrd> plenty of maths texts use "let", so I think it's acceptable
14:40:35 <greenrd> being that haskell is based on math, an' all
14:40:47 <Micket> http://rafb.net/paste/results/gNpHq572.html
14:40:55 <TheHunter> that's usually a different kind of let.
14:41:02 <cbus> FINALLY, the god damn mail server works :)
14:41:04 <Micket> Its that last row there, It doesnt look (10,200)
14:41:08 <greenrd> TheHunter: really?
14:41:18 <Micket> erh. I mean, it doesnt like (10,200)
14:41:42 <CosmicRay> whee, ghc fixed in unstable
14:41:44 <TheHunter> yes, the math let scopes over what follows and the scope is kind of undefined.
14:42:00 <CosmicRay> well for i386 at least.
14:42:47 <SyntaxNinja> CosmicRay: y0
14:42:52 <CosmicRay> hey syntaxninja
14:43:05 <TheHunter> what types are x and y supposed to have?
14:43:39 <Micket> Int and StdGen
14:43:51 <TheHunter> the layout issues that happen when you use let in haskell instead of where are horrible.
14:44:03 <TheHunter> where
14:44:10 <TheHunter>   x :: Int
14:44:13 <TheHunter>   y :: StdGen
14:44:20 <TheHunter>   (x,y) = randomR (10,200) (gRandom g)
14:44:23 <TheHunter> does that work?
14:45:00 <Micket> it does :)
14:45:01 <Micket> thanks
14:45:32 <TheHunter> moin xerox, how's it going?
14:45:40 <Micket> Oh, and is this something that requiers GHC 6.4 like you mentioned earlier?
14:45:51 <TheHunter> no, that doesn't.
14:45:55 <xerox> Internet outage, grmbl.
14:46:01 <Micket> ah. cool. Thanks alot!
14:46:06 <xerox> Hello TheHunter!  Quite well.
14:47:00 <xerox> TheHunter: did you see the latest updates about my cairo bindings and the demo app?
14:47:17 <TheHunter> you only need the new ghc when you want to do something like foo :: forall a. a -> a; foo x = y where y :: a; y = x.
14:47:38 <TheHunter> i saw screenshots.
14:48:03 <xerox> ^_^
14:48:13 <mwc> Wow, ghci blows the ocaml interpreter out of the water, at least for calculating fibonacchi numbers
14:48:44 <CosmicRay> nan
14:48:45 <CosmicRay> err
14:48:46 <CosmicRay> hah
14:48:53 <SyntaxNinja> camls store water in their humps. therefore, they cannot be blown from water, but water can be blown from them.
14:49:01 <CosmicRay> lol
14:49:24 <cbus> you could blow them up aswell i guess
14:49:27 <SyntaxNinja> you may ask if that is a legitimate reason to not use ocaml, and I say, "Yes."
14:49:46 <mwc> Haha, seriously. let { fib = 1 : 1 : zipWith (+) fib (tail fib) ; } in fib !! 54 completes in the blink of an eye
14:50:03 <CosmicRay> I will skip making the obligatory innuendo during this conversation about blowing things.
14:50:25 <mwc> on the otherhand; let rec fib n = if n < 2 then 1 else fib (n - 1) + fib (n-2) ;; fib 54 seems to drag on forever
14:50:58 <mwc> fib 32 has a noticible delay, the haskell version is still instantaneous
14:51:15 <mwc> I bring this up because of the perception that Ocaml is a "fast" language\
14:51:23 <monochrom> Yes, that one is a fast method and that other one is a slow method.
14:51:38 <mwc> monochrom, aren't they identical in practice?
14:51:48 <monochrom> you should code the first one in ocaml and see that it is just as fast.
14:52:31 <monochrom> what is "identical" and what is "practice"?  your question implies you have differing definitions from mine.
14:53:14 <poetix> *!?!
14:53:25 <poetix> GConf won't even *!?! /build/
14:54:02 <mwc> monochrom, aren't they the same linear time algo of calculating the two previous numbers and adding them? The only differnce I see is that in the Ocaml case, it recurses on BOTH previous numbers
14:54:18 <mwc> I would htink that Ocaml's vaunted optimizations should be able to take care of that
14:55:10 <rasfar> hi SamB
14:55:13 <monochrom> first of all the second algorithm is not even linear time.
14:55:27 <xerox> Do you know the game of 15?
14:55:52 <psi> the second one is exponential isn't it?
14:56:25 <monochrom> secondly please don't call it "the ocaml case" because "fib n  = if n < 2 then 1 else fib (n - 1) + fib (n-2)" is equally valid haskell code and just as slow.
14:56:41 <astrolabe> no xerox
14:56:56 <mwc> monochrom, s/case/implementation, fair>'
14:57:06 <xerox> astrolabe: I was talking about that with a friend, I made a video of me resolving it in 55 secs, wanna see? :-P
14:57:13 <rasfar> will (f 3) + (f 3) evaluate (f 3) twice?
14:57:25 <monochrom> that is still unfair, as I have demonstrated with Haskell code.
14:57:36 <astrolabe> xerox:  You have a link?
14:57:47 <mwc> rasfar, I think the problem is that the optimizer can't see it in outside the function body
14:58:00 <xerox> astrolabe: http://haskell.galois.com/~paolo/fifteen.3gp
14:58:40 <poetix> xerox: gtk2hs is refusing to build...
14:58:40 <mwc> monochrom, I understand the problem now, thanks for the insight
14:58:56 <xerox> poetix: urgh!!  What error do you get?
14:58:59 <monochrom> thirdly, the necessary optimization for the second algorithm is memoization, which afaik is not done automatically anywhere, and it is questionable whether it is worthwhile to do automatically and blindly.
14:59:00 <astrolabe> xerox:  My computer doesn't know what to make of .3qp
14:59:17 <xerox> astrolabe: quicktime plays it, mplayer too, maybe vlc, i'll test.
14:59:25 <poetix> c2hsLocal gets stuck on gconf-client.h
14:59:30 <xerox> astrolabe: yep, vlc too.
14:59:46 <poetix> Oh, and gconf-changeset.h
14:59:48 <monochrom> In Maple you can write the second algorithm and then give a directive "memoize this!"
14:59:54 <xerox> poetix: mumble, could you past the error in pm?
15:02:48 <shapr> @yow !
15:02:49 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price
15:02:49 <lambdabot> of
15:02:49 <lambdabot> CHICKEN ...
15:02:59 <greenrd> hehe
15:03:04 <greenrd> @yow
15:03:05 <lambdabot> You were s'posed to laugh!
15:03:09 <greenrd> haha
15:03:11 <greenrd> @hoho
15:03:12 <lambdabot> Maybe you meant: echo moo todo
15:04:38 <xerox> I would like to do a similar video for the rubik's cube, but first I have to learn how to solve it :-D
15:05:48 <stepcut> xerox: heh, I have a rubik's cube that I have nearly solved, sitting next to my desk
15:06:20 <xerox> stepcut: cool, I do also have one solved here, my brother doesn't have much to do and learnt how to solve it :-)  Yesterday it took 30 mins, today 20!
15:06:51 <shapr> xerox: That's you solving fifteen?
15:06:56 <xerox> shapr: yes!
15:07:02 <shapr> nifty!
15:07:12 <xerox> I was faster when younger.
15:07:31 <xerox> I used to do it n times when I went back home from school, heh.
15:07:55 <ulfdoz> bye
15:08:46 * stepcut flips the 14 and 15 tiles on xerox's fifteen puzzle and snickers at him
15:09:09 <xerox> I found that you can't really do it
15:09:29 <stepcut> xerox: if you flip 'em ?
15:09:39 <xerox> IIRC you can't do:
15:09:39 <xerox> .. 15 14 13
15:09:39 <xerox> 12 11 10  9
15:09:39 <xerox>  8  7  6  5
15:09:42 <xerox>  4  3  2  1
15:09:50 <xerox> Without actually getting the pieces of and swapping them
15:09:54 <stepcut> yes
15:10:06 <stepcut> only half of the possible random states are solvable
15:10:09 <xerox> There is probably a mathematical reason
15:10:18 <xerox> Cool, why?
15:10:25 <BitShifter> My prof proved it in an algorithm class
15:10:28 <stepcut> a crooked carny trick was to swap two tiles and then take bets on people solving it
15:10:38 <xerox> (I lost days in my kindergarden days with this thing)
15:10:42 * stepcut looks in his docs dir
15:11:02 <xerox> BitShifter: prove it for us! Please :-)
15:11:26 <astrolabe> It is to do with odd and even permutations
15:11:35 <BitShifter> I didn't say *I* could do it.
15:11:39 <BitShifter> Just that I had seen it done
15:11:40 <astrolabe> You can only move amongst the even ones.
15:11:47 <BitShifter> I never cared that much
15:13:04 <astrolabe> Any permutation can be written as a product of transpositions (swaps), but the parity of the number of swaps is determined by the permutation.
15:13:24 * xerox mumbles
15:14:02 <xerox> astrolabe: could you rephrase it in an understandable way? :-D
15:14:18 <stepcut> http://www.math.ubc.ca/~cass/courses/m308-02b/projects/grant/fifteen.html
15:15:00 <monochrom> To produce a particular permutation, you can use a sequence of swappings.  Although there are many sequences of swappings you can choose from, all of them has the same length mod 2.
15:15:18 <monochrom> For example if one sequence has odd numbers of swappings, then all sequences do.
15:15:31 <xerox> @plugs let f 0 = 1; f n = n * f (n-1) in f 16
15:15:34 <lambdabot> 20922789888000
15:15:40 <astrolabe> For instance the permutation that sends 1 to 2, 2 to 3 and 3 to 1, can be got by swapping 1&2, then 2 and 3, so it is an even permutation.
15:15:44 <monochrom> @plugs 16!
15:15:45 <lambdabot> 20: Not in scope: `!'
15:15:58 <monochrom> @plugs factorial 16
15:15:59 <lambdabot> 18: Not in scope: `factorial'
15:16:31 <greenrd> I just discovered a new use for bananna peel!
15:16:42 <greenrd> Rub it on your skin for a cooling sensation!
15:17:09 <greenrd> I expect it has lots of health-giving properties too.
15:17:18 <astrolabe> ew.  Leave for an hour for a smelly sensation?
15:17:24 <greenrd> hehe
15:17:31 <stepcut> xerox: if you ever want to solve it on the computer, there are a bunch of papers about using the A* algorithm to solve the fifteen puzzle
15:17:52 <xerox> A* algorithm?
15:18:20 <xerox> BTW the page you pasted before has a number of nice tips.  I never thought about searching that game on internet, heh!
15:19:15 <stepcut> xerox: yeah -- it's a way to try to find optimizal solutions to things like fifteen with out having to brute force it
15:19:31 <xerox> stepcut: any link?  Sounds interesting.
15:19:45 <stepcut> xerox: any time you have a choice to make about which tile to move next, you ask an oracle that tells you which path will probably be the fastest
15:20:27 <stepcut> xerox: the better the oracle, the faster you can find the optimal solution
15:20:47 <xerox> stepcut: sounds functional :-)
15:21:05 <stepcut> xerox: try this one: http://wwwcs.uni-paderborn.de/pc2/papers/files/34.pdf
15:40:24 <shapr> g'day Pseudonym
15:40:36 <Pseudonym> G'day.
15:40:44 <xerox> Hello Pseudonym!
15:41:02 <Pseudonym> Greetings.
15:41:04 <xerox> Pseudonym: (re stable networks) silcnet!
15:41:26 * Pseudonym makes a note to google that once he's done with his daily RSS feeding
15:50:09 <shapr> Man, I'm tired of getting darcs spam.
15:50:31 <Pseudonym> darcs spam?
15:51:47 <stepcut> tired of typing, tla i-just-want-to-do-something-really-simple the-archive/the-category--the-branche--1.0--patch-1, just to get work done! Try darcs, you'll be amazed!
15:53:18 <greenrd> hehe
15:53:23 <Pseudonym> Don't be silly.  CVS is a great tool.
15:53:27 <Pseudonym> Unless you want branching.
15:53:29 <Pseudonym> Or to delete files.
15:53:33 <Pseudonym> Or multiple directories.
15:53:35 <lispy> or renaming
15:53:35 <greenrd> shapr: Who sends darcs spam?
15:53:40 <Pseudonym> Or renaming, yes.
15:53:45 <Pseudonym> Or security.
15:53:51 <Pseudonym> Or local repositories.
15:54:01 <xerox> And what do you would want it for?  Revision control for a file?
15:54:04 <Pseudonym> Or... oh, you get the idea.
15:54:10 <Pseudonym> No, you can use RCS for that.
15:54:18 <Pseudonym> DISTRIBUTED revision control for a file!
15:54:26 <shapr> greenrd: spammers sending to my email repositories.
15:54:38 <lispy> shapr: ah, ouch
15:54:54 <Pseudonym> I would have thought that darcs messages would be easy to recognise, and hence it would be easy to filter out everything else.
15:55:36 <lispy> darcs messages should be easy to recognize if sent with dracs
15:55:40 <lispy> they should have headers
15:55:46 <Pseudonym> Right.
15:56:06 <Pseudonym> Maybe darcs should do digital signing, too.
15:56:21 <Pseudonym> Just a thought.
15:56:35 <stepcut> darcs should send me a text message warning me it is going to send an email
15:56:41 <greenrd> heh
15:57:26 <Pseudonym> I want darcs integrated with my palm pilot.
15:57:30 <Pseudonym> No idea why.
15:57:40 <stepcut> :p
15:57:57 <Pseudonym> That's the thing.  There doesn't HAVE to be a point.
15:58:02 <shapr> stepcut: Anything new on RSS.hs?
15:58:05 <Pseudonym> Should be a one-liner in Haskell, surely?
16:01:34 <stepcut> shapr: no, but I should be working on that type of thing again soon
16:01:42 <stepcut> shapr: there is progress on the pipes library though
16:02:55 <stepcut> shapr: It works in ghci, but something does not work quite right when you run the compiled version (actually I think the compile program will work under linux, but not freebsd...)
16:03:15 <stepcut> haven't had time to debug that yet though
16:03:21 <stepcut> i think it is something low-level
16:08:20 <shapr> I want to try it when you get it working.
16:09:41 <stepcut> shapr: yeah, one it works, I am going to try to write a TMR article about it, because it will be to the point where it works, but could benefit from other peoples ideas
16:10:40 <stepcut> shapr: but now dons has gone a written h4sh, so I also have to have a section on why my stuff is different/still valid ;)
16:14:01 <Lemmih> dcoutts: ping.
16:16:51 <xerox> Lemmih: he told me he would have been here this night, but off to vacation for the next week or so - and I didn't see him this night :(
16:19:58 <Lemmih> @seen gour
16:19:59 <lambdabot> I saw gour leaving #haskell 7 hours, 55 minutes and 58 seconds ago.
16:22:12 <Beelsebob> @seen lemmih
16:22:13 <lambdabot> lemmih is in #haskell. Last spoke 2 minutes and 14 seconds ago.
16:22:52 <greenrd> @seen lambdabot
16:22:53 <lambdabot> Yes, I'm here.
16:22:57 <greenrd> hehe
16:24:09 <xerox> @quote lambdabot
16:24:11 <lambdabot>  "lambdabot hasn't said anything memorable"
16:24:25 <Beelsebob> @quote xerox
16:24:26 <lambdabot> xerox hasn't said anything memorable
16:24:34 <greenrd> @quote shapr
16:24:35 <lambdabot>  Academics are continually chewing pieces off of impossible and
16:24:35 <lambdabot> making them merely difficult.
16:24:52 <xerox> For instance, I said "@remember lambdabot "lambdabot hasn't said anything memorable".
16:26:01 <lambdabot> The only thing worse than being popular is not being popular.
16:26:11 <lambdabot> That's pretty memorable.
16:26:33 <rasfar> Oscar Wilde, isn't it?
16:26:34 <xerox> Ah!
16:26:56 <rasfar> s/popular/talked about/
16:27:25 <lambdabot> Oh, yeah. Guess my version isn't so memorable.
16:27:45 <xerox> lambdabot: you're talking so much lately.
16:28:42 <Beelsebob> who's got their hand where it shouldn't be?
16:28:54 <rasfar> ya, no doubt!...
16:29:21 <xerox> Hmm.. yes!  Goodnight.
16:32:20 <greenrd> hehe
16:38:49 <wagle> hugs is type safe?
16:38:50 <wagle> Main> pp [1,2]
16:38:50 <wagle> Illegal instruction
16:39:14 <wagle> pp [] = []
16:39:14 <wagle> pp [n] = [[n]]
16:39:14 <wagle> pp (n : nn) = concat (map pp (map (n :) (pp nn)))
16:39:35 <wagle> ... maybe its just not wagle safe..
16:46:12 <greenrd> Illegal instruction!
16:46:28 <greenrd> Is that a SIGILL?
16:46:51 <Beelsebob> hahahahahaha... it's not a security hole... it's a malicious use of a feature!
16:47:59 <Igloo> wagle: It's probably due to the C stack overflowing
16:48:10 <wagle> yeah
16:50:09 <wagle> Igloo: you dont understand..  haskell is type safe, so this cant happen.
16:50:45 <wagle> (people really seem to believe that, and deride me for not believing it too)
16:51:32 <Igloo> It can't happen in a perfect implementation
16:51:37 <Beelsebob> wagle: actually, I've seen a runtime haskell type error
16:53:00 * wagle reapplies nose to grindstone
16:53:12 * Beelsebob grinds
16:55:53 <pate-afk> i'm a haskell newbie ... working through Hal Daume's 'Yet Another Haskell Tutorial'
16:56:07 <Beelsebob> m'hum
16:56:13 <Beelsebob> that's a good start
16:56:14 <Beelsebob> :)
16:56:14 <pate-afk> I'm playing with the guessing game in his interactivity section
16:56:45 <lispy> pate-afk: games will rot your mind!
16:56:53 * lispy runs around screaming like a heretic
16:56:59 <Beelsebob> haha
16:57:02 <pate-afk> for some reason the code doesn't compile (i've tried copying directly from the text as well as retyping it
16:57:15 <Beelsebob> what error do you get?
16:57:24 <pate> book_guess.hs:19:9: parse error on input `doGuessing'
16:57:39 <Beelsebob> can you show me lines 18-20?
16:57:55 <pate>    if guessNum < num
16:57:56 <pate>       then do putStrLn "Too low!"
16:57:56 <pate>          doGuessing num
16:57:56 <pate>       else if read guess > num
16:58:00 * lispy guesses it's the layout rule, but he's biased
16:58:02 <pate> (actually starts at 17)
16:58:12 <lispy> and it is
16:58:14 <Beelsebob> probably is the layout rule
16:58:23 <lispy> pate: mae the doGuessing line up with putStrLn
16:58:26 <wagle> definitely layout
16:58:28 <Beelsebob> doGuessing should be alligned with putStrLn
16:58:38 <Beelsebob> btw... that's a really bad way to do interactivity
16:58:40 <SyntaxNinja> hm. the paper towels in our office are labeled "extreme performance". impressive.
16:58:52 <pate> *sigh* that was it
16:58:53 <Beelsebob> the interact function was specifically designed for this purpose
16:59:01 <Lemmih> SyntaxNinja: (:
16:59:04 <lispy> SyntaxNinja: hehe
16:59:12 <lispy> interact?
16:59:16 <SyntaxNinja> although for a minute I thought they were spam and almost threw them away
16:59:19 <lispy> @index interact
16:59:20 <lambdabot> System.IO, Prelude
16:59:29 <lispy> @doc System.IO
16:59:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.html
16:59:40 <pate> thanks for the help
17:00:39 <lispy> Beelsebob: doesn't strike me as profound
17:00:55 <Beelsebob> hang on
17:00:56 <Igloo> interact is only useful if the rest of the code is pure, though
17:00:57 <Beelsebob> @paste
17:00:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:01:32 <Igloo> And means you have to do all teh concatenation explicitly, which isn't always particularly clear
17:01:34 <Beelsebob> igloo: no... the interact function is useful for *making* code pure
17:01:36 <Beelsebob> pasted now
17:01:52 <Beelsebob> (missing the random number generation
17:02:36 <Igloo> Beelsebob: What if the input is a list of files to print the contents of?
17:02:57 <Beelsebob> igloo... then you're not doing something interactive?
17:03:09 <Igloo> How is that not interactive?
17:03:24 <Beelsebob> because there's no user input involved?
17:03:41 <Igloo> I mean   loop = do file <- getLine; readFile file >>= putStr; loop
17:03:46 <Beelsebob> oh, okay
17:04:15 <Beelsebob> then that's quite a neat way of doing it... but in the game case interact is much neater
17:04:41 <Igloo> Or in this example, if you wanted it to work for multiple inputs then either you keep it monadic or you have to pass an infinite list of random numbers around yourself
17:05:07 <Igloo> (by multiple inputs I mean it goes on to another one once you guess the first)
17:05:26 <Beelsebob> and also... interact $ \x -> unlines . unsafePerformIO . readFile x . lines
17:07:01 <Beelsebob> well then yes, use an infinite list of randoms, not a single random
17:07:48 <Beelsebob> don't underestimate interact... hat-delta is written using it... it's very powerful
17:07:57 <Beelsebob> (as is hat-detect now)
17:08:57 <Igloo> In which case you have to pass it through all the code yourself, like I said...
17:09:07 <Igloo> I'm not even going to dignify the uPIO line with a response  :-)
17:09:25 * Igloo has no idea what hat-delta does
17:10:02 <wagle> Igloo: but sincve you responded, then it must be the case that you don't dignify things by responding...  8)
17:10:07 <Beelsebob> hat-delta does an algorithmic debugging session with delta debugging built in
17:10:19 <Beelsebob> igloo: there's nothing wrong with uPIO when you use it in a safe place
17:10:23 <Beelsebob> in that place it's safe
17:10:53 <wagle> how do you know that its safe?
17:11:02 <Igloo> Beelsebob: Yes, but it's a general conversation (and also not something to suggest newbies use)
17:11:17 <Beelsebob> igloo: uPIO no, but interact yes...
17:11:28 <Beelsebob> I got *taught* IO using interact
17:11:41 <Igloo> I meant uPIO, yes
17:11:52 <wagle> (ie, why can't the compiler use the same decision procedure that you do?)
17:11:56 <Beelsebob> and I'm better for it because I ( a ) learned about lazyness, and ( b ) realised that monads are not for throwing everywhere
17:12:20 <Beelsebob> wagle: because the compiler doesn't know what the desired behavior is
17:12:28 <lispy> why are monads not for throwing everywhere?
17:12:34 <Beelsebob> same reason the debugger can't tell you instantly what the bug is
17:13:01 <wagle> what is the desired behavior?  formalize that description
17:13:03 <Beelsebob> lispy: because they break lazyness, and pureness, and I'm using this language *because* of those two features
17:13:31 <Beelsebob> wagle: it's not something that *can* be formalised... the desired behavior is what I want the program to do... it is not a formal concept
17:13:34 <lispy> i used to think lazyness was a good idea, but i keep hearing all these bad things that happen because of it.
17:13:37 * wagle has never gotten around to understanding the issues with uPIO
17:13:58 <lispy> wagle: it bowls down to referential transparency
17:14:05 <lispy> er boils
17:14:19 <stepcut> Stay pure till marriage, abstain from monads
17:14:21 <Beelsebob> yeh... uPIO doesn't always return the same thing
17:14:35 <Beelsebob> so it's not a function
17:14:41 <Beelsebob> so it's unsafe to use as such
17:14:49 <lispy> laziness causes memory leakes
17:14:54 <lispy> if used incorrectly
17:15:00 <wagle> you can do algebraic transformations without reftrans
17:15:11 <Beelsebob> yes... monads cause time explosions if used improperly
17:15:27 * Lemmih is very impressed with John Peterson's reaction time.
17:15:40 <lispy> Beelsebob: how so?
17:15:58 <lispy> if anything i think monads should be encouraged in haskell code
17:16:03 <Beelsebob> lispy: because they break lazyness... they can turn a terminating program into a non-terminating one
17:16:05 <lispy> perhaps taught before pure
17:16:11 <Beelsebob> ugh
17:16:19 <lispy> i'm serious
17:16:20 <Beelsebob> that's a horrible thought
17:17:04 <lispy> it obviously depends on the student, but i think most CS students are primed and ready to learn about monads before laziness
17:17:11 * ibid is considering starting my this autumn's fp course with "a crash-course on haskell the unidiomatic way"
17:17:19 <lispy> of course, types are fundamental, but still
17:17:23 <Beelsebob> yes they are... that's why they should be tought to break the mould
17:17:30 <ibid> (ie. treating haskell as an imperative language:)
17:17:37 <lispy> ibid: yes!
17:17:38 <Beelsebob> because if you teach them "here's a way of doing imperative programming"
17:17:40 <lispy> exactly
17:17:43 <Beelsebob> that's all they'll ever do
17:17:50 * rasfar is moving yet again; see you on the other side...
17:17:51 <Beelsebob> and then what's the poinnt?
17:17:57 <ibid> Beelsebob: not if you tell them not to do it
17:18:05 <Beelsebob> ibid: um... yeh right!
17:18:26 <lispy> Beelsebob: we can't argue about what people "will do" without a study
17:18:27 <Beelsebob> if you tell a CS undergrad how to do it like that they won't bother to learn to change
17:18:31 <ibid> Beelsebob: if they don't obey, they deserve the horrible grades they're going to get :)
17:18:59 <Beelsebob> lispy: anecdotal, yes, but from teaching Haskell to first years, the second you show them how to simulate imperative code they will do nothing else
17:19:14 <Beelsebob> which is the opposite of helpful
17:19:23 <ibid> Beelsebob: is that haskell as a first language?
17:19:28 <lispy> what is so bad about imperative styel?
17:19:32 <Beelsebob> ibid: no
17:19:34 <ibid> my students are primarily third-years and older
17:19:48 <ibid> and it's an elective course
17:19:49 <lispy> imperative style is not inherintly wrong
17:19:53 <Beelsebob> lispy: the fact that we're teaching them a functional language... we're trying to show them an alternative
17:20:00 <Beelsebob> not show them how to do the same thing again
17:20:05 <Igloo> Beelsebob: Most large programs are, IMO, going to want to be largely monadic
17:20:06 <ibid> Beelsebob: no, we are teaching them the functional *style*
17:20:24 <lispy> Igloo: i would agree
17:20:26 <Igloo> I suspect hat-delta is special in that it probably just parses the .hat file or whatever at the start and then is pretty much pure
17:20:37 <Beelsebob> igloo: I've not yet written a single program with more than 2 monadic functions in
17:20:48 <Igloo> Beelsebob: What large programs have you written?
17:20:54 <Beelsebob> igloo: no... it parses it when it needs to
17:20:57 <Beelsebob> because it's lazy
17:21:10 <Beelsebob> which actually keeps space usage down
17:21:15 <ibid> Beelsebob: the choice of language, at least for me, is mainly influenced by how well the language helps in that
17:21:16 <Igloo> The laziness is irrelevant there (except maybe for memory use)
17:21:19 <Beelsebob> igloo: several hat tools
17:21:20 <lispy> i think being multiparadigm is worth much more than any single paradigm
17:21:30 <Igloo> I imagine it doesn't affect the worst case space usage
17:21:33 <Beelsebob> lispy: true
17:21:39 <ibid> Beelsebob: and if i can make the language less scary by telling them how to misuse the language at first, i will do so
17:21:41 <Igloo> All the hat tools will be in the same special category
17:21:43 <Beelsebob> no, it doesn't affect the worst case
17:21:49 <Beelsebob> igloo: not at all
17:21:57 <Beelsebob> they vary wildly
17:22:14 <Beelsebob> ibid: I think that the shock is exactly what's needed
17:22:23 <Igloo> Why doesn't it affect the worst case? If I look at the entire program with hat then nothing will ever get removed from memory, surely?
17:22:25 <lispy> it's also helpful to remember the biggest difference between programs are the programmers, not the language....
17:22:32 <Beelsebob> because students are lazy... they won't try something new if they don't have to
17:22:35 <ibid> Beelsebob: not if they are turned off by it
17:22:38 <lispy> (that is programs generated from the same spec)
17:22:55 <ibid> Beelsebob: these students will, because they have chosen to take the course
17:23:24 <Beelsebob> ibid: I knew several people in my 3rd year FUN class that did exactly that
17:23:33 <ibid> Beelsebob: there's going to be plenty of shock in the actual style, there's no need to make the language scary as well
17:23:46 <lispy> there is a lot of negativity towards these language theory classes among students.  And one of the big complaints is, "You can't do any real programming."
17:24:03 <Beelsebob> ibid: but... if you show them a way of doing imperative code in it... all you're doing is showing the same style in a scary language
17:24:04 <ibid> Beelsebob: as i said, if they choose to ignore the instructions, they deserve the bad grades they're going to get
17:24:13 <Beelsebob> what you want is a new style in a similar language
17:24:25 <Beelsebob> as you said... it's style you're teaching
17:24:27 <Beelsebob> not language
17:24:41 <ibid> Beelsebob: and the language is chosen to best help me teach it
17:24:48 <Beelsebob> precicely
17:24:57 <Beelsebob> so it helps you teach style
17:24:58 <ibid> Beelsebob: java, which these people know best, is not a good teacher of functional style
17:25:23 <Beelsebob> but my question is... why teach them imperative style in a functional language
17:25:30 <Beelsebob> why not just teach them functional style?
17:25:43 <lispy> Beelsebob: you have to start with types right?
17:25:44 <ibid> Beelsebob: but i want to get over the "this is a language course about haskell" quickly, and go on to the "there's a new way of thinking about programming"
17:26:00 <ibid> Beelsebob: i've already answered that question
17:26:13 <lispy> Beelsebob: so, you can be using imperative style in your type examples
17:26:17 <Beelsebob> ibid: yeh... so why not just say... this is a course about haskell... here's a new way to thing
17:26:26 <Beelsebob> ibid: my first lecture was... type 5 in
17:26:30 <Beelsebob> it evaluates to 5
17:26:35 <Beelsebob> type 5+4 in
17:26:39 <ibid> Beelsebob: because then there are two scary things, instead of one
17:26:39 <Beelsebob> it gives a result
17:26:48 <Beelsebob> ibid: worked fine on me
17:26:50 <ibid> Beelsebob: i've tried the traditonal approach first
17:27:11 <Beelsebob> well... I think we must agree to disagree
17:27:12 <lispy> ibid: well, i say try it and see how it works out
17:27:31 <ibid> Beelsebob: the course had other things wrong too, but i think it speaks volumes that almost all of the course failed all the monads-related questions in the exam
17:27:31 <lispy> ibid: report back to the haskell community :)
17:27:42 <ibid> lispy: i will, at least the "try" part :)
17:27:51 <Beelsebob> ibid: there *were* no monad related questions in our exam
17:27:55 <ibid> Beelsebob: and these are real monad stuff, not just  the IO monad
17:28:02 <ibid> Beelsebob: you've seen my exams?
17:28:14 <Beelsebob> no... I'm talking about the exams I sat
17:28:27 <ibid> ah. sorry, read "our" as "your" :)
17:28:46 <lispy> i failed monad questions on my last haskell exam
17:28:52 <lispy> but i've learned so much about them since
17:28:53 <ibid> the main thing i did about that was to split the course in two halves
17:29:09 <Beelsebob> hehe... I guess I've inherited my hatred for monads from my Haskell father though
17:29:10 <humasect> test (True,_) = (1, 0); test (_,True) = (0, 1)  <-- what would happen if test was applied to (True,True)?
17:29:17 <Beelsebob> Colin Runciman is one of their biggest opponents
17:29:38 <Beelsebob> humasect: (1,0)
17:29:40 <ibid> the first half (which they can get independent credit) will not discuss monads except in the crude sense of "IO as the imperative-style enabler"
17:29:41 <humasect> ok
17:29:41 <lispy> humasect: the first one listed
17:29:47 <humasect> thanks
17:29:52 <lispy> humasect: haskell tries to pattern mat them in order
17:30:25 <humasect> my brain feels good
17:30:26 <Igloo> Beelsebob: How would you write darcs, which downloads files from remote repos in the middle of its operation then? Or an SQL-backended web app?
17:30:38 <Beelsebob> igloo: not with haskell
17:30:54 <Beelsebob> I may want to use haskell for parts... but not for things that aren't what it's good at
17:30:56 <lispy> you wouldn't write darcs in haskell? or just not that part of darcs?
17:31:03 <ibid> Beelsebob: i think one of the simons is on record for saying "haskell is the best imperative language"
17:31:04 <Beelsebob> just not that part
17:31:19 <Igloo> Err, Haskell is great at them. If you don't shut your eyes and pretend monads don't exist...
17:31:41 <lispy> the only thing i've found haskell to be not good at is applications with real-time constraints, some high performance things and of course small systems like embedded
17:32:23 <Beelsebob> lispy: I've seen several papers showing how it deals with that kind of processing better than it deals with imperative style
17:32:28 <Beelsebob> through stream processing
17:32:41 <Beelsebob> anyway... I'm off for a walk
17:32:45 <Beelsebob> see you later
17:37:00 <ibid> also, one reason why i don't want to say "this is a course on haskell, a functional language, and you will learn also the functional style" is that i don't want them to think they need a separate language to do fp
17:37:32 <ibid> (of course, they might choose one because it makes it easier, but i don't want to ghettoize fp in their minds)
17:38:02 <wagle> i thought the point was that you wanted them to know that you didnt need a separate language to do ip..  8)
17:38:31 <ibid> ip?
17:38:42 <wagle> fp...  ip... lp...
17:39:03 <ibid> wagle: and i'm a little confused, even with the correction, of what you're trying to say :)
17:39:30 <wagle> never mind..
17:39:33 <ibid> :)
17:39:35 <Igloo> Mmm, if I ever make a language with good functional, imperative and logic features, remind me to call it flip
17:39:41 <greenrd> heh
17:39:42 <wagle> i dont really have a point
17:40:12 <ibid> ahh, ip = imperative programming
17:40:12 <ibid> heh
17:40:27 <ibid> i just assumed that ip was a typoed fp :)
17:40:34 <ibid> didn't make much sense
17:40:44 <Igloo> Hurrah. I'm mostly back to where I was a few days ago, but with an SQL backend.
17:41:06 <ibid> i should probably go back to bed for a few hours
17:41:09 <heatsink> ibid: I'm surprised; I thought it self-evident that you could rewrite a program in another language.
17:41:26 <heatsink> without reorganizing it.
17:41:33 <ibid> heatsink: hmm?
17:41:52 <heatsink> using fp in an imperative lang
17:42:03 <wagle> i can rewrite a haskell program into fortran..  but i think i'd be reorganizing it
17:42:37 <wagle> .. by doing so
17:44:45 <heatsink> Sure, but you don't have to, and you can do FP with data in fortran when you can't find something that's more natural for fortran.
17:46:04 <ibid> is the following compiler error message helpful?
17:46:06 <ibid> hello.pal:2: ';' expected, got '{'
17:46:35 <wagle> sure..  how many {'s on line 2?
17:46:47 <ibid> one
17:47:21 <heatsink> If a semicolon is inserted before the { then is the code correct?
17:47:22 <wagle> well, a ; is supposed to be there..  8)
17:47:37 <wagle> what languages is pal?
17:47:42 <ibid> heatsink: no :)
17:47:48 <heatsink> Not helpful then :)
17:48:00 <ibid> wagle: palestrina
17:48:09 <ibid> wagle: not really public yet
17:48:11 <wagle> neverheardofit
17:48:27 <ibid> i hope so, not wanting to steal another language's name:)
17:48:27 <wagle> whats lines 1-2 look like?
17:48:27 <heatsink> It's definitely an unexpected '{'
17:48:47 <ibid> module hello {
17:49:01 <ibid>   main = 1 + 1;
17:49:17 <ibid> (in the previously correct but now incorrect syntax)
17:49:39 <wagle> i dont see a { on line 2?
17:49:52 <ibid> sorry, that was lines 2 and 3
17:49:58 <ibid> line 1 was empty
17:50:31 <ibid> the correct syntax is now
17:50:34 <ibid> module hello;
17:50:36 <wagle> maybe the wrong production is accepting module hello..
17:50:40 <ibid> main = 1 + 1;
17:50:52 <ibid> wagle: this is a predictive parser :)
17:51:09 <wagle> whazzat?
17:51:23 <heatsink> recursive descent parser?
17:52:08 <ibid> yes
17:52:40 <ibid> but a rd parser need not be predictive
17:52:45 <wagle> well, still, it could be deciding "module" is a function name, or something
17:52:52 <ibid> it's predictive if it doesn't backtrack
17:52:56 <ibid> it's not
17:53:01 <ibid> module is a keyword
17:53:29 * heatsink learns what predictive parser means
17:53:44 <heatsink> I think it's a suitable error message for the end of statement.
17:54:06 <wagle> well, then it could be deciding "module" is a function name, and sticking to that decision..
17:54:44 <wagle> or is the syntax for module NOT "module <name> <block>" or somesuch?
17:54:49 <ibid> basically, the "... expected, got ..." is output by an expect parser routine, to which i tell what token i expect, and it will initiate error recovery (which currently means terminating the compiler) if it doesn't match
17:54:58 <ibid> wagle: it used to be that
17:55:07 <heatsink> ...Should the error message happen for that input?
17:55:09 <ibid> wagle: now it's just module <name> ; ...
17:55:14 <heatsink> ok
17:55:18 <ibid> heatsink: the input is erroneous
17:55:41 <wagle> oh..  rd parsers are notorious for not knowing what went wrong...
17:55:44 <ibid> mainly because i decided putting most of my code inside a {} creates spurious indenting
17:56:10 <heatsink> whitespace is optional, right? ;)
17:56:23 <ibid> heatsink: the standard "free-form" rules, yes
17:56:29 <ibid> for whitespace, that is
17:57:07 <ibid> i have a (very) partial draft of the language manual
17:57:15 <ibid> not very useful yet
17:57:17 <heatsink> What is the language for?
17:57:36 <ibid> primarily it's my testbed for a couple of language features
17:57:43 <ibid> but it may evolve to be more than that
17:57:50 <ibid> also it's an exercise in language design :)
17:58:24 <heatsink> sounds good.
17:58:33 <ibid> oh?
17:58:42 <heatsink> sounds like a good exercise.
17:58:45 <ibid> heh
18:01:31 <TheHunter> greenrd, why don't you write |instance PartialOrder a => PartialOrder (LineList a) where
18:01:31 <TheHunter> | ? The context in the LineList declaration doesn't really mean much. In particular, it doesn't mean that every LineList carries a PartialOrder dictionary.
18:02:42 <greenrd> TheHunter: Sorry, which code sample are you referring to?
18:03:00 <TheHunter> the bug report you submitted.
18:03:08 <greenrd> ok
18:03:16 <TheHunter> contexts in data declarations are a misfeature, imo.
18:04:55 <greenrd> oh! What do they mean, then?
18:05:46 <greenrd> are they just sound and fury, signifying nothing?
18:05:52 <TheHunter> if the data constructor LineList is called, it is checked that a is an instance of PartialOrder.
18:05:55 <TheHunter> that's it.
18:06:00 <greenrd> OK.
18:06:05 <greenrd> But that's the only constructor.
18:06:42 <greenrd> oh, a dictionary, you said
18:06:52 <greenrd> I'm confused
18:07:26 <greenrd> There seems to be some sort of "type lossage" going on here.
18:07:39 <TheHunter> data Show a => Foo a = Foo a
18:07:49 <greenrd> The thing goes _in_ being a PartialOrder, but when it comes _out_ it doesn't know that it's a PartialOrder?
18:07:51 <TheHunter> this has the same runtime representation as data Foo a = Foo a
18:08:02 <TheHunter> exactly.
18:08:06 <greenrd> That's crap.
18:08:10 <TheHunter> That's why I called it a misfeature.
18:08:15 <greenrd> Is that for efficiency reasons or what?
18:08:34 <TheHunter> i think it's specified in the report.
18:08:45 <greenrd> Sure, but why is it like that, do you know?
18:09:00 <TheHunter> you can have the effect you want with gadts, though, i think.
18:09:12 * greenrd raises his eyebrows
18:09:14 <TheHunter> i don't have any idea.
18:09:32 <greenrd> I have two more weird cases like that.
18:09:41 <greenrd> One I mentioned in my report, and had a workaround.
18:09:49 <greenrd> Now I've found one that doesn't seem to have a workaround.
18:10:42 <greenrd> ghc thinks that Ord a is a possible instance match but I don't know why
18:11:42 * greenrd realises
18:11:42 <greenrd> But that's probably because of what you just explained
18:12:17 <greenrd> When it finds that it doesn't know which instance to use, it sometimes just lists all possibilities.
18:12:42 <greenrd> OK, so how would I do it with GADTs?
18:12:53 <TheHunter> data LineList a where
18:12:53 <TheHunter>   LineList :: PartialOrder a => [a] -> LineList a
18:13:06 <TheHunter> but that doesn't get rid of the overlapping instance error.
18:13:32 <greenrd> Are GADTs an extension?
18:13:45 <TheHunter> yes, they are a 6.4 extension.
18:13:49 <greenrd> cool
18:13:57 <greenrd> covered by -fglasgow-extensions?
18:14:09 <TheHunter> that stores the PartialOrder dictionary in the datatype.
18:14:12 <TheHunter> yes.
18:14:35 <TheHunter> but that's not enough to infer PartialOrder a, given a LineList a.
18:14:42 <greenrd> ok cool, that's something.
18:15:11 <greenrd> I recognise that syntax from some other language I've been playing with - Omega I think.
18:15:16 <TheHunter> which makes of course sense, since there's undefined :: PartialOrder a
18:15:31 <greenrd> huh?
18:15:37 <greenrd> but undefined :: anything, and so what?
18:16:05 <TheHunter> err undefined :: LineList a.
18:16:21 <dons> moin
18:16:24 <TheHunter> moin.
18:17:20 <TheHunter> yes, the overlapping instances error is justified.
18:17:20 <dons> TheHunter, I wonder if using fast packed strings to store the lambdabot state values would shrink the space usage
18:17:40 <dons> at least for the plugins with big state requirements.
18:17:53 <TheHunter> that's a really good idea.
18:18:13 <dons> basically use it as a Binary-lite
18:19:05 <TheHunter> probably just using it in Haddock.hs is enough.
18:19:47 <dons> ok. i'll have a look at this
18:20:25 <greenrd> TheHunter: Can I do deriving with GADTs - if so, what's the syntax?
18:20:34 <TheHunter> nope, not possible.
18:20:48 <greenrd> d'oh
18:20:50 <greenrd> that sucks
18:21:20 <TheHunter> when you only use them like regular adts, it might be possible in head, but i'm not sure.
18:22:36 <TheHunter> yep, head allows that, but that doesn't help much.
18:23:20 <TheHunter> what's LineBunch ?
18:23:59 <greenrd> like a bunch of lines on a graph
18:24:18 <greenrd> represented as a list of minimum points and a list of maximum points
18:24:30 <greenrd> gah, this is painful
18:24:53 <TheHunter> can you give me the data declaration?
18:24:55 <greenrd> I might have to write some Template Haskell just to get some sane behaviour... but I bet TH doesn't support GADTs yet
18:25:08 <greenrd> data (PartialOrder a) => LineBunch a = LineBunch (LineList a) (LineList a) deriving (Eq, Show)
18:26:37 <TheHunter> i doubt it, but i don't know much about TH.
18:27:38 <greenrd> OK, I don't think GADTs are even buying me anything here.
18:28:53 <greenrd> It still wants me to explicitly say (PartialOrder a) => everywhere even though I've already specified it in the constructor.
18:29:11 <greenrd> Tommorow I might have to try this sort of thing in Omega or Epigram.
18:29:27 <TheHunter> yes, and for a good reason.
18:29:35 <greenrd> What is the good reason?
18:29:43 <greenrd> There's only constructor!
18:29:58 <greenrd> If it goes in being a PartialOrdered element, it can't suddenly become not ordered!
18:29:58 <TheHunter> there's an implicit "bottom constructor".
18:30:13 <greenrd> Yes but that doesn't hold any data
18:30:33 <greenrd> So there is no "a" to typecheck with that
18:30:36 <greenrd> So the question doesn't arise
18:32:07 * heatsink is curious what this bottom constructor is
18:32:30 <greenrd> good question
18:33:34 <greenrd> I guess if you pass undefined, that is (conceptually) a value created via the implicit bottom constructor
18:34:05 <TheHunter> yes, that's what i meant.
18:34:18 <greenrd> Well, this really sucks.
18:34:38 <greenrd> I had thought that Haskell's class mechanism was quite nice, if not up to OO snuff... but it seems it has serious deficiencies.
18:35:12 <heatsink> okay.  So this has something to do with accessing a class method through a dictionary on a blackhole?
18:35:26 <heatsink> and not being able to do that?
18:35:28 <TheHunter> it's simply not designed to do such stuff.
18:35:30 <greenrd> heatsink: a blackhole? What's that?
18:36:07 <heatsink> greenrd: I'm thinking of the value which haskell detects as <<loop>>
18:36:34 <greenrd> No, it was TheHunter who brought this up. I don't believe blackholes are relevant here.
18:36:34 <heatsink> which can be made with undefined or letrec or fix.
18:36:49 <greenrd> I'm certainly not knowingly introducing them.
18:37:30 <wagle> @index sort
18:37:31 <lambdabot> Data.List
18:37:31 <greenrd> The problem is Haskell doesn't propagate class information which it knows is true from the constructor.
18:37:35 <greenrd> It's that simple.
18:37:54 <greenrd> Or at least it doesn't seem to.
18:38:08 <wagle> oops
18:38:09 <TheHunter> don't you want to be able to deduce |PartialOrder a| whenever there is a |LineList a|?
18:38:17 <wagle> @index topological_sort
18:38:18 <lambdabot> bzzt
18:38:21 <wagle> darn
18:38:27 <greenrd> TheHunter: Precisely.
18:38:36 <greenrd> TheHunter: How do I do that? GADTs didn't work.
18:39:04 <TheHunter> you have to 'open' the gadt in order to access that information.
18:39:13 <greenrd> OK
18:39:31 <greenrd> Which means what?
18:39:42 <TheHunter> pattern matching on the constructor.
18:39:46 <greenrd> I did that.
18:39:49 <greenrd> But it didn't work.
18:40:09 <TheHunter> what exactly were you trying to do?
18:40:28 <greenrd> Well, I didn't pattern match right down to the a type, 'tis true
18:40:32 * greenrd tries that
18:41:27 <greenrd> nope
18:41:37 <TheHunter> can you paste?
18:41:38 <greenrd> well, I was trying to manually derive Eq
18:41:41 <greenrd> something as simple as that
18:41:41 <greenrd> sure
18:43:50 <greenrd> http://rafb.net/paste/results/MB1FXl56.html
18:44:33 <greenrd> Now maybe Haskell can't figure out that ((a implies b) & a) implies b.
18:44:38 <greenrd> That could be the problem here.
18:45:16 <greenrd> The error I get isCould not deduce (Eq a) from the context (Eq (LineList a))
18:45:16 <greenrd>       arising from use of `==' at PartialOrder.hs
18:45:28 <greenrd> But PartialOrder a implies Eq a
18:45:50 <greenrd> Actually, when I specify (PartialOrder a) => it works.
18:45:53 <TheHunter> that's odd.
18:46:15 <greenrd> So it's not that Haskell can't do ((a implies b) & a) implies b with instances - it can.
18:46:39 <greenrd> It just can't do it in the case when it needs to unpack the PartialOrder instance from a GADT.
18:46:55 <TheHunter> lemme investigate
18:47:50 <wagle> hugs doesnt support gadt's?
18:47:54 <Lemmih> Hi again, SyntaxNinja.
18:48:21 <greenrd> wagle: Dunno. The list of implementations at haskell.org doesn't say that it supports anything more than haskell 98.
18:48:26 <SyntaxNinja> hi Lemmih
18:48:43 * SyntaxNinja wonders how much more research would get done if universities employed a LaTeX expert just to format papers
18:49:04 <greenrd> I thought LaTeX was supposed to be a formatting expert itself!
18:49:04 <wagle> when i tried to build ghc about two weeks ago, it barfed..  i havent tried either again or harder yet
18:49:21 <greenrd> wagle: But I would like to cross-check with another implementation, so, if there is another GADT impl out there, that would be great.
18:50:35 <greenrd> SyntaxNinja: Have you tried lyx?
18:50:46 <wagle> i think that the class stuff doesn't like you instantiating only some of a type (like the partial order restriction)
18:51:04 <greenrd> SyntaxNinja: Editing paper "source code" by hand is so passe.
18:51:18 <SyntaxNinja> greenrd: not much... the problem tends to be that I need to use a particular stylesheet or whatever its called, and then on top of that, there are some random requirements that apparently can't be enforced by the stylesheet
18:51:25 <SyntaxNinja> like figures should be centered
18:51:33 <TheHunter> ah, here's the reason: https://sourceforge.net/tracker/index.php?func=detail&aid=1116210&group_id=8032&atid=108032
18:51:38 <TheHunter> not implemented yet :/
18:51:43 <greenrd> wagle: I don't understand. How am I "instantiating only some of a type"?
18:51:43 <SyntaxNinja> or for some damn reason, my email addrses is on a page by itself, rather than the title page
18:51:47 <greenrd> TheHunter: heh
18:51:56 <SyntaxNinja> lyx may or may not help there.
18:52:29 <greenrd> yeah, that's exactly the kind of thing I feared with latex. I've never actually used it.
18:52:57 <greenrd> At least with OpenOffice you have control over such things, even if you need to spend more time getting the fundamentals right.
18:53:04 <wagle> greenrd: instance Eq (t) for only t that have some property
18:53:20 <SyntaxNinja> yeah. latex probalby offers a great amount of control, I just have to actually sit down and learn the language
18:53:23 <TheHunter> but in contrast to the data declaration, the dictionary is kept at runtime here...
18:53:34 <wagle> like you can't define fmap for sets
18:53:36 <greenrd> wagle: It's not though. That's the point.
18:53:56 <greenrd> wagle: As I keep saying, there's only ONE constructor. So it's logically irrefutable that ALL of them will have that type.
18:54:18 <TheHunter> i think you could still fake it, but that would be nasty.
18:55:05 <wagle> i jumped into the middle..  i tried to give it a spin, but all i have is hugs at the moment..  sorry
18:55:18 <greenrd> np
18:55:38 <greenrd> TheHunter: I'm going to try doing the same thing in some other functional languages :)
18:56:00 <TheHunter> which one?
18:56:11 <greenrd> Unfortunately Epigram is very beta and Omega too - I easily made it crash, but perhaps because I didn't understand what I was doing.
18:56:18 <greenrd> Epigram and Omega primarily.
18:56:29 <greenrd> but that's for tommorow.
18:56:29 <TheHunter> i see.
18:56:57 <TheHunter> gadts still very experimental, unfortunately.
18:57:15 <greenrd> hmm
18:57:36 <greenrd> I'm not sure that I actually need GADTs - all I need is damned propagating constraints!
18:57:40 <greenrd> Is that too much to ask?
18:58:44 <TheHunter> it's probably more difficult than you think.
18:58:51 <greenrd> nah.
18:58:54 <greenrd> I doubt it.
18:59:43 <greenrd> Well, maybe ghc is poorly designed for that, I don't know. But in terms of language semantics - doesn't seem too difficult to me.
19:00:02 <wagle> Eq a isnt defined on a partial order a, so how could Eq [a] be?
19:00:16 <TheHunter> fwiw, the way to fake it is:
19:00:21 <TheHunter> data E :: * -> * -> * where E :: E a a
19:00:21 <TheHunter> data LineList :: * -> * where
19:00:21 <TheHunter>   LineList :: forall a b. PartialOrder a => E a b -> [b] -> LineList b
19:00:32 <greenrd> wagle: Eq _is_ defined on all partial orders - but I might have cut that out of my code sample, I can't remember.
19:00:48 <greenrd> wagle: class Eq a => PartialOrder a where
19:00:52 <greenrd> there
19:01:05 <wagle> what is your partial order class?
19:01:21 <greenrd> class Eq a => PartialOrder a where
19:01:21 <greenrd> 	lte :: a -> a -> Bool
19:01:30 <wagle> nm..  brain fart
19:01:34 <greenrd> heh
19:01:44 <greenrd> ok time for bed.... look at the time! *gasp*
19:01:57 <wagle> 7pm..
19:02:12 <greenrd> east coast usa?
19:02:13 * wagle looks at the sun
19:02:18 <greenrd> I'm in Europe
19:02:19 <wagle> west coast
19:02:23 <greenrd> woops
19:02:29 <greenrd> always mixing up my east and west
19:02:37 <wagle> gnite
19:02:41 <greenrd> nite
19:02:45 <TheHunter> nite
19:02:50 <greenrd> thanks!
19:03:45 <wagle> how about LineList :: (Eq a, PartialOrder a) => [a] -> LineList a
19:04:06 * wagle doesnt have a GADT 
19:13:37 <TheHunter> no, that won't work either.
19:15:31 <dons> @pl let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
19:15:32 <lambdabot> (line 1, column 5):
19:15:32 <lambdabot> unexpected "("
19:15:32 <lambdabot> expecting natural, identifier or "in"
19:15:53 <heatsink> no parens
19:16:08 <dons> where?
19:16:13 <heatsink> around x,y
19:16:20 <dons> @pl let x,y = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
19:16:21 <lambdabot> (line 1, column 6):
19:16:21 <lambdabot> unexpected ","
19:16:21 <lambdabot> expecting letter or digit, pattern or "="
19:16:37 <heatsink> hmm, I thought that would work
19:16:44 <dons> @pl let x = span (not.isSpace) (reverse ps) in (reverse (snd x), reverse (fst x))
19:16:45 <lambdabot> ap ((,) . reverse . snd) (reverse . fst) (span (not . isSpace) (
19:16:45 <lambdabot> reverse ps))
19:16:51 <dons> pattern matching
19:17:48 <heatsink> pl was more picky than ghc about use of {} in let expressions.
19:23:43 <lispy_> heatsink: yeah, pl isn't perfect
19:23:52 <lispy_> it doesn't handle do notation
19:28:24 <wagle> @pl [1,2] >>= (\x - >[3,4] >>= (\y -> return (x,y)))
19:28:25 <lambdabot> (line 1, column 15):
19:28:25 <lambdabot> unexpected " "
19:28:25 <lambdabot> expecting "->"
19:28:45 <wagle> @pl [1,2] >>= (\x -> [3,4] >>= (\y -> return (x,y)))
19:28:47 <lambdabot> (`fmap` [3, 4]) . (,) =<< [1, 2]
19:29:10 <wagle> contortionist!
19:29:58 <dons> maybe @pl should use ghc-src
19:30:20 <Lemmih> haskell-src would probably be enough.
19:31:29 <dons> yep
19:32:45 <Lemmih> A @pl with support for parallel arrays, TH and implicit parameters would be cool, though. (:
19:33:18 <dons> hehe
19:40:12 <lispy_> is the correct way to delete an application (or purge it since i want to save space) on OSX to move its folder to the trash and then empty the trash?
19:41:51 <heatsink> That's how it worked on the macintoshes that I remember.
19:42:30 <lispy_> okay
19:42:31 <lispy_> cool
19:42:55 <lispy_> i have this encyclopedia app that i will never use since google+wikipedia are much faster and take up no space on my harddrive
19:43:04 <lispy_> and that frees up 2GB
19:49:05 <Lemmih> dons: s/They/The/ in the README for hs-plugins.
19:49:52 <lispy_> darcs send!
19:49:53 <lispy_> ;)
19:50:24 <dons> thanks Lemmih
19:50:41 * Lemmih should stop playing around and do some benchmarking on the byte-code generated by GHC.
19:52:17 <dons> haddock documentation for the FPS library: http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
19:52:20 <dons> any comments?
19:53:18 <lispy_> dons: O(1) The empty PackedString   ?
19:53:24 <dons> sure.
19:53:30 <lispy_> that doesn't parse :)
19:53:34 <lispy_> not for me anyway
19:53:42 <lispy_> OH
19:53:56 <dons> O(1) is a complexity annotation.
19:53:59 <lispy_> so it's the identity under concat
19:54:04 <dons> a la the Map library
19:54:22 <dons> well, yes, that's one way to think of empty strings ;)
19:54:33 <lispy_> having the complexity there is nice
19:54:47 <Korollary> it's sophisticated
19:55:12 <lispy_> dons: it might be nice if head1 and tail1 had a description :)
19:55:18 <dons> ah, good point.
19:55:41 <lispy_> right now they sound the same as head/tail
19:56:19 <lispy_> over all it's nice
19:56:30 <lispy_> i'm just picking nits since you wanted comments
19:57:00 <lispy_> oh, wow you have hGet and all that jazz
19:57:02 <lispy_> very cool
19:57:33 <dons> I want comments, yes, as I'd like to push this back into the hierarchical libs. so nitpicking is ok.
19:58:18 <lispy_> so, what is n?  do you define that for completeness?
19:58:29 <dons> n as in O(n) ?
19:59:23 <Korollary> n is probably the string length
19:59:25 <lispy_> yeah, is it the number of chars in the string?
19:59:38 <lispy_> i think most people would guess that, but it doesn't hurt to state it
19:59:57 <dons> yes. O notation is (always?) over the input size.
19:59:58 <Lemmih> 'mmapFile' looks neat!
20:00:42 <dons> mmapFile is why h4sh's `i' beats cat
20:00:45 <lispy_> dons: yes, but the way you measure input can very.
20:00:58 <lispy_> dons: what no unfoldr ;)
20:01:16 <dons> @type unfoldr
20:01:18 <lambdabot> bzzt
20:01:23 <dons> @type List.unfoldr
20:01:24 <lispy_> ah, i'm just teasing
20:01:25 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
20:01:31 <dons> ok, I have to add it now
20:01:35 <lispy_> haha
20:02:34 <dons> ok, so why I don't need to say what 'n' is: wikipedia: time complexity of a problem is the number of steps that it takes to solve an instance of the
20:02:37 <dons> problem as a function of the size of the input (usually measured in bits)
20:02:43 <dons> http://en.wikipedia.org/wiki/Computational_complexity_theory
20:03:15 <Korollary> dons: how about rstrip and lstrip on PackedString's ?
20:03:26 <dons> rstrip, lstrip?
20:03:37 <Korollary> umm, trim() in perl, iirc
20:03:38 * dons furiously makes API notes
20:03:51 <Korollary> throws away (usually whitespace) from either end
20:04:14 <dons> oh, dropWhile?
20:04:32 <dons> actually, dropSpace
20:04:50 <dons> does dropSpace == lstrip?
20:05:07 <Korollary> yes
20:05:13 <dons> if so, I'll add dropSpaceEnd
20:05:15 <Korollary> bah, need reverse of r
20:05:17 <Cale> dropSpace as in lambdabot?
20:05:30 <dons> hmm. don't think it came from lambdabot
20:05:42 <dons> darcs seems to be the source... unless..
20:05:44 <Cale> Util.hs
20:05:53 <dons> (/me notes that bits of Yi are already in darcs, so maybe lambdabot too..)
20:06:15 <Cale> dropSpace :: [Char] -> [Char]
20:06:16 <Cale> dropSpace = let f = reverse . dropWhile isSpace in f . f
20:06:21 <dons> ah, not dropSpace.
20:06:28 <dons> dropSpace (PS x s l) = unsafePerformIO $ withForeignPtr x $ \p -> do
20:06:28 <dons>     let i = c_firstnonspace (p `plusPtr` s) l
20:06:29 <dons>     return $ if i == l then empty else PS x (s+i) (l-i)
20:06:30 <Korollary> does dropWhile construct a new list or does it reuse the old list and gc the dropped part ?
20:06:32 <lispy_> is dropSpace general?
20:06:57 <lispy_> can i pass in (Word8 -> Bool) ?
20:07:01 <dons> Korollary, i could implement a dropSpaceEnd that doesn't reverse the list
20:07:02 <lispy_> or maybe Char -> Bool?
20:07:37 <dons> dropWhile doesn't build a new list. it uses `slices'
20:07:53 <dons> so, yes, it reuses the old list
20:08:01 <dons> most of these functions take substringss that way
20:08:29 <dons> by just building a new PS containing a ptr to the original string, and then two offset values for the start and the end of the substr
20:08:33 <lispy_> dons: i don't disagree with the wikipedia article, is the "(usually ...)" that makes we want so say it's helpful to state it.  But it's such a small thing i'll just drop it
20:09:07 <Korollary> I'm trying to think of a toy benchmark where I can compare STL lists against haskell's
20:10:37 <lispy_> Korollary: well, read in a "phone book" and then search for an item
20:10:46 <lispy_> at least that might be a start
20:11:02 <Korollary> I think it's hard to isolate it from the file i/o
20:12:26 <lispy_> ah
20:12:53 <lispy_> i guess otherwise you'd have to dynamically generate the phone book
20:13:02 <lispy_> (if you used my scenario)
20:13:58 <Korollary> well, I also need to take lazyness into account. anything that works on the list will work on it while the list is being generated.
20:18:07 <humasect> i'm having design issues.
20:20:25 <lispy_> how so
20:23:31 <humasect> i have a datatype that is 5 values.. i'm having trouble simplifying methods to work on them all transparently. eg. applyElement Water s (_,me,ea,fi,wo) = (s,me,ea,fi,wo) - where i have also a type that is a 5-bool tuple to manage their state
20:24:27 <lispy_> humasect:
20:24:31 <dons> can you use records?
20:24:31 <lispy_> sorry
20:24:39 <Korollary> with labelled fields
20:25:02 <humasect> i'd like to index those records with each value
20:26:36 <dons> hmm. applyElement f s e = e { f = s } ?
20:26:56 <dons> not sure if that makes any sense
20:27:26 <dons> hmm. f e makes sense, but not e  { f = s } unfortunately (unless I'm about to be surprised)
20:27:41 <humasect> i get obsessed with simplifying things so haskell is perfect for me . =)
20:28:37 <lispy_> humasect: i wouldn't store the state separate from the structure.....but i'm not sure without seeing more how to advise
20:33:40 <humasect> perhaps what i need to do is...
20:35:26 <lispy_> also, are the attributes orthogonal?
20:35:49 <lispy_> that is can you have all permutations of true/false for your 5-tuple?
20:37:53 <humasect> yeah
20:42:33 <humasect> tuples aren't interchangeable with recorded datatypes are they?
20:43:08 <humasect> http://rafb.net/paste/results/yczHem54.html  <-- maybe something horribly dirty like this
20:43:45 <dons> humasect, only if you provide the isomorphism
20:44:47 <humasect> cool
20:45:31 <humasect> okay this seems to be alright then.
20:45:33 <lispy_> does that type check?
20:45:53 <lispy_> 18 and 19 look like they have different types to me
20:46:20 <humasect> yeah i just fixed it =) also that uses (value,me,ea,fi,wo) etc. now
20:46:39 <lispy_> yeah, that was the type i couldn't resolve :)
20:46:46 <humasect> ^^
20:47:04 <lispy_> humasect: it's simpler than that
20:47:20 <humasect> really
20:47:21 <lispy_> Water -> {water = value, metal = me, earth = ea, fire = fi, wood = wo}  => Water -> {water = value }
20:48:09 <humasect> i was getting a parse error on {, i thought because of the param type constructor, which i tried. so tuples now. i will do {water = value} then =)
20:48:56 <lispy_> but...
20:49:01 <lispy_> i think it might be simpler yet
20:49:05 <humasect> o_o
20:49:17 <lispy_> notice your pattern, Water -> water
20:49:27 <lispy_> do you even need Water?
20:49:39 <lispy_> would you be better off with just water?
20:49:49 <lispy_> i guess you have to ask yourself that
20:50:01 <humasect> you may be right..
20:50:21 <humasect> but i think i will have the element type for some situations
20:50:30 <humasect> solely "which element something is"
20:51:02 <lispy_> i wonder if this would be a good use of type classes
20:51:11 <lispy_> type Element a where  .....
20:51:18 <lispy_> instance Element Water where ...
20:51:33 <lispy_> newtype Water = Water a
20:51:35 <humasect> i'm still ignorant of them
20:51:35 <lispy_> but....
20:51:39 <lispy_> maybe that's not a good idea
20:51:42 <Korollary> why are there 18 different array types ?
20:51:54 <lispy_> Korollary: hehe, good question :)
20:52:40 <dons> this is a mystery indeed
20:53:09 <lispy_> humasect: so, what are you writing, by the way?  a game?
20:53:35 <humasect> a kind of neurotic experiment
20:53:38 <lispy_> humasect: you can make your version simpler
20:53:56 <lispy_> elementValue e = case e of Water -> water ....
20:54:06 <lispy_> you don't need to talk about the es
20:54:28 <humasect> o_o
20:54:28 <dons> yay, packed string unfoldr: Data.FastPackedString.unfoldr 10 (\x -> Just (x, x)) 'x'
20:54:32 <dons> "xxxxxxxxxx"
20:54:35 <lispy_> @pl \e -> case e of Water -> water
20:54:36 <lambdabot> (line 1, column 23):
20:54:36 <lambdabot> unexpected ">" or "-"
20:54:36 <lambdabot> expecting variable, "(", operator or end of input
20:54:53 <humasect> lispy: i was just about to ask how to simplify that stuff. passing in something, changing a record, coming back with it.
20:54:55 <lispy_> dons: heh, nice
20:55:20 <humasect> applying to*
20:56:10 <humasect> lispy: is this what happens when something is in the type, but not aliased a name in the definition
20:56:11 <humasect> *?
20:58:30 <luqui> what is the precedence of ->?  that is, where does it terminate?
21:00:34 <Korollary> -> is a reservedop. no precedence.
21:00:44 <humasect> i'm getting parse errors at '{' for | case of e ; Water -> {water = value}
21:00:45 <luqui> then what is its effective precedence?
21:01:13 <luqui> I guess I can test
21:01:19 <luqui> what is the lambdabot eval command?
21:01:23 <luqui> @eval 1
21:01:24 <lambdabot> 1
21:01:29 <luqui> haha, eval
21:02:27 <luqui> @eval \x -> nub [1,2,x] $ 1
21:02:29 <lambdabot> 24:
21:02:29 <lambdabot>   Expecting a function type, but found `[a]'
21:02:29 <lambdabot>   Expected type: a -> b
21:02:29 <lambdabot>   Inferred type: [a1]
21:02:29 <lambdabot>   Probable cause: `nub' is applied to too many arguments in the
21:02:31 <lambdabot> call
21:02:33 <lambdabot>    (nub [1, 2, x])
21:02:48 <luqui> okay, so it's lower than $
21:03:03 * luqui can be surprisingly unresourceful sometimes
21:03:19 <humasect> hmm
21:03:52 <luqui> humasect, what are you trying to construct?
21:04:00 <luqui> you can't use records without a constructor in front
21:04:19 <humasect> ElementValues a.
21:04:26 <luqui> maybe you meant:  case of e ; Water -> e { water = value }
21:04:33 <luqui> er, that doesn't make sense
21:04:35 <humasect> =o
21:05:05 <luqui> where do you get e?
21:05:25 <humasect> data | | |
21:05:41 <luqui> (also keep in mind that if you have a fair amount of experience with haskell, I'm just shooting in the dark)
21:05:53 <luqui> as in, in what context does the "case of e" appear?
21:06:10 <humasect> it would be lovely if records could just deprecate 'type x = y' for me
21:06:42 <humasect> http://rafb.net/paste/results/fCwem518.html
21:07:32 <luqui> ahh, I think you want "setElementValue e value ev = case e of ; Water -> ev { water = value } ...
21:07:55 <luqui> given that ElementValues is defined as a record
21:08:00 <humasect> that's what i thought too...
21:08:43 <humasect> oh i see there we go, thanks
21:08:57 <luqui> hey, I helped somebody with haskell
21:09:01 * luqui better go get a lambda hat quick
21:09:05 <luqui> :-) you're welcome
21:09:31 <humasect> ^_^
21:09:55 <humasect> now here's a tricky one...
21:10:11 <humasect> applyElement :: Element -> Bool -> World -> World
21:10:11 <humasect> applyElement e b w = { elementStates = setElementValue e b }
21:10:53 <luqui> applyElement e b w = w { elementStates = setElementValue e b }  -- ?
21:11:08 <humasect> nope ^_^
21:11:27 <humasect> oh, wait.
21:17:41 <humasect> you can apply record names, no? then lispy_ would be right, i don't think i would then need the type = | | |
21:18:11 <luqui> what do you mean "apply record names">
21:18:14 <luqui> ?
21:18:23 <lispy_> record names are functions
21:18:34 <lispy_> well, can be used as function
21:18:46 <humasect> like doSomething e x = x { e = True }  -- doSomething water x
21:18:57 <lispy_> no
21:18:58 <humasect> yeah, ok =)
21:19:00 <humasect> no..?
21:19:10 <luqui> nopers
21:19:13 <humasect> =(
21:19:30 <luqui> humasect, maybe you want a higher level data structure
21:19:36 <lispy_> in that case x needs to be an ElementValue and e needs to be water
21:19:36 <luqui> like a map, so you can refer to them with strings
21:19:47 <humasect> lispy, so it works =D?
21:20:06 <lispy_> humasect: have you tried it?
21:20:13 <humasect> yeah but that map will never change its keys.
21:20:32 <luqui> humasect, uh huh, and?
21:20:45 <humasect> you're right, i'll finish this up and see where i can get with what you've all shown me. ^_^
21:23:09 <SyntaxNinja> if paper submission guidelines say that the paper shuld be no more than 16 pages, does that include the references section?
21:23:15 <humasect> one more thing. what type would a record function be? just 'a' in the case of Hello a = { x :: a }?
21:23:29 <luqui> x :: Hello a -> a
21:23:33 <humasect> rather, ok
21:23:33 <humasect> thanks
21:25:12 <Korollary> SyntaxNinja: I am guessing they mean the entire paper
21:25:28 <lispy__> @type let foo x y z = x { z = y } in foo
21:25:29 <lambdabot> bzzt
21:25:43 <humasect> one more. how would you expand records in a definition? eg. applyElement e b w(elementStates = es) = w { elementStates = es { e b } }
21:25:58 <humasect> *w@(
21:25:59 <luqui> @type \x y z -> x { z = y }
21:26:01 <lambdabot> bzzt
21:26:07 <luqui> yeah, too bad
21:26:31 <Korollary> what kinda expression is "x { z = y }" anyway ?
21:26:42 <luqui> humasect, hmmm... can you do that?
21:26:50 <humasect> luqui: i hope so. =)
21:26:55 <lispy__> Korollary: well, if x has the write type then store y in record z ;)
21:27:00 <lispy__> sorry right type
21:27:16 <Korollary> but x doesn't have a type
21:27:22 <luqui> it would suck if you had to go positionally like "applyElement e b w@(ElementState _ _ es _ _) = ..."
21:27:33 <humasect> luqui: exactly =(
21:28:17 <luqui> well, if you could, I'd guess the syntax would be "applyElement e b w@(World{ elementStates = es }) = ..."
21:28:27 <lispy__> humasect: records don't really seem like the right thing, i would consider a finite map
21:29:23 <luqui> humasect, and then there's always: applyElement e b w = let es = elementStates w in w { elementStates = es { e b } }
21:29:39 <luqui> but then uh, the right side doesn't make sense
21:29:54 <humasect> i'm getting "e is out of scope" ^_^
21:30:05 <humasect> setting records-in-records, or os
21:30:50 <luqui> just "es { e b }" doesn't make sense; there ought to be an = somewhere in the braces
21:30:58 <SyntaxNinja> Korollary: you're probably right. *sigh*
21:31:19 <humasect> oh i've done es { e = b }
21:31:39 <luqui> which is illegal
21:31:59 <luqui> I'm with lispy__, use some other data structure if you need to be this introspective
21:32:00 <humasect> illegal?
21:32:11 <luqui> you're receiving e as a parameter right?
21:32:15 <humasect> yes
21:32:21 <humasect> oh, right.
21:32:23 <lispy__> ssh, ssh, you'll get us arrested with your illegal code;)
21:32:31 <humasect> ;)
21:32:59 <Pseudonym> Last time I had illegal code, it ended up executed.
21:33:17 <SyntaxNinja> ssh isn't illegal yet
21:33:26 <lispy__> lol
21:33:52 <lispy__> why hasn't my other nicked timed out yet...
21:33:58 <lispy__> heh, and i can't ghost it
21:34:06 <lispy__> it's not linked or registered....
21:34:37 <lispy____> i'll just make things worse :)
21:35:47 <humasect> i did this, and it likes it: applyElement e b w = let es = elementStates w in w { elementStates = (setElementValue e b es) }
21:35:54 <humasect> (if anyone is curious)
21:36:54 <lispy> so how do you use it?
21:37:16 <lispy> bout time
21:37:37 <lispy____> wait a secon
21:37:49 <lispy____> i can't send to ##c so i can't change my nick?
21:37:50 <luqui> @type (,)
21:37:52 <lambdabot> forall b a. a -> b -> (a, b)
21:38:16 <lispy____> but i could as lispy_
21:38:17 <luqui> @eval (,) 1 2
21:38:19 <lambdabot> (1,2)
21:38:21 <luqui> cool!
21:38:25 * luqui didn't know about that
21:39:14 <luqui> is there a name for the function that constructs the three-tuple?
21:39:21 <luqui> I guess they call three-tuple a triple
21:39:40 <luqui> or a throople
21:39:53 <monochrom> @type (,,)
21:39:55 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
21:40:03 <luqui> there we go, and generalizes on from there
21:40:04 <luqui> nice
21:40:11 <lispy_> luqui: try triple
21:40:18 <lispy_> instead of throople :)
21:40:52 <lispy_> @pl \x y z -> (x, y, z)
21:40:54 <lambdabot> (,,)
21:41:24 <luqui> do they call Maybe Bool a troolean?
21:41:45 <luqui> :-)
21:43:03 <lispy_> @type (:-)
21:43:04 <lambdabot> bzzt
21:43:55 <luqui> @type (:0)
21:43:56 <lambdabot> forall a. (Num [a]) => a -> [a]
21:44:18 <lispy_> @type (:'P')
21:44:20 <lambdabot> bzzt
21:44:29 <luqui> huh
21:44:32 <lispy_> @type 'P"
21:44:33 <lambdabot> bzzt
21:44:34 <lispy_> @type 'P'
21:44:35 <lambdabot> Char
21:44:45 <luqui> does it know there is no Num Char or something?
21:45:03 <lispy_> actually, yours should have failed
21:45:08 <lispy_> @type (:)
21:45:10 <lambdabot> forall a. a -> [a] -> [a]
21:45:20 <lispy_> since you didn't give it a list
21:45:51 <luqui> yeah, I guess it should have
21:46:01 <luqui> @type (:"P")
21:46:03 <lambdabot> Char -> [Char]
21:46:12 <luqui> at least that's sane, but it's hard to anthropomorphise that
21:46:24 <lispy> haah, i just wanted the answer to why it worked and i opened a terminal and typed "dons"
21:46:31 <lispy> $ dons
21:46:33 <lispy> -bash: dons: command not found
21:46:38 <luqui> hehe
21:46:57 <lispy> @type (:^)
21:46:58 <lambdabot> bzzt
21:47:14 <lispy> i meant to type ghci
21:47:17 <lispy> fwiw
21:48:05 <luqui> @type let P = 0 in (:-P)
21:48:07 <lambdabot> bzzt
21:48:10 <luqui> er
21:48:15 <lispy> so if you did instance Num [a], could youget (:0) to be valid
21:48:36 <lispy> :- parses as one identifier
21:48:37 <luqui> hmmm, would lists form a field?
21:48:51 <luqui> oh, it's an infix constructor, no?
21:49:14 <Korollary> (:0) means "(:) 0" ??
21:49:24 <lispy> Korollary: no
21:49:33 <lispy> (:0) :: (Num [a]) => a -> [a]
21:49:35 <luqui> almost.  it means \x -> x:0
21:49:51 <lispy> it thinks that 0 is an istance of some weird list
21:50:15 <Korollary> @type flip (:) 0
21:50:16 <lambdabot> forall a. (Num [a]) => a -> [a]
21:50:24 <lispy> @type 0
21:50:26 <lambdabot> forall t. (Num t) => t
21:53:15 <lispy> oh, hemm...i wanted to defined (*) as cartesian product, but then it's not closed
21:53:55 <luqui> does haskell have an exec() ?
21:53:59 <Korollary> yes
21:54:16 <Korollary> see System.Process
21:55:31 <luqui> what's the function name?
21:55:34 <luqui> I don't see it there
21:56:29 <Korollary> runProcess won't do ?
21:56:47 <luqui> not really, I want to replace the current image
21:57:03 <luqui> it's so a program can re-run itself after updating
21:57:31 <Korollary> @index forkIO
21:57:33 <lambdabot> Control.Concurrent
21:58:13 <Korollary> bah
21:58:16 <Korollary> @index execve
21:58:17 <lambdabot> bzzt
21:58:20 <Korollary> @index exec
21:58:21 <lambdabot> bzzt
21:58:49 <luqui> @index executeFile
21:58:50 <luqui> ?
21:58:50 <lambdabot> System.Posix.Process, System.Posix
21:58:52 <lispy> @hoogle (a, b) -> a b
21:58:53 <lambdabot> Ix.range :: Ix a => (a, a) -> [a]
21:58:53 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
21:58:53 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
21:59:58 * luqui wonders how a function with that signature could possibly work
22:00:38 <Korollary> because of typeclasses
22:01:07 <Korollary> which I should study more. This STArray stuff is confusing me
22:01:42 <lispy> luqui: it would appear that Num is a ring not a field
22:02:01 <Korollary> @index =
22:02:02 <Lemmih> luqui: It can't work. Invalid kind.
22:02:02 <lambdabot> bzzt
22:02:05 <Korollary> @index ==
22:02:07 <lambdabot> Prelude
22:02:19 <Korollary> @type ==
22:02:21 <lambdabot> bzzt
22:02:36 <Korollary> @type (==)
22:02:37 <lambdabot> forall a. (Eq a) => a -> a -> Bool
22:03:02 * luqui is a little shabby in his abstract algebra
22:03:07 <Korollary> how would a function with this signature work ?
22:03:10 <lispy> and actually, it strikes me that to make list an instance of num, list should be isomorphic to polynomials
22:04:05 <lispy> Korollary: which signature?  the signature of (==) ?
22:04:23 <Korollary> lispy: yes. I was trying to give luqui an example
22:04:29 <lispy> oh
22:04:33 * lispy shuts up
22:04:39 * Korollary ties up lisp
22:04:45 * lispy likes it
22:04:56 * luqui should be getting to bed
22:04:59 * luqui & zzzzzzzz
22:05:01 * Korollary records a video and sets up a torrent
22:05:36 <Lemmih> luqui: Weren't you referring to '(a, b) -> a b'?
22:05:42 <luqui> Lemmih, yes
22:06:09 * luqui stops talking in his sleep
22:07:12 <lispy> hmm...what is signum for polynomials?
22:11:37 <Korollary> How can I leave it at this ? "class Num a => MyTypeClass a where method1 :: a -> b".
22:11:40 <humasect> sdl doesn't really like ghci
22:12:57 <Lemmih> One of the reasons I wrote the SDL binding was because GLUT didn't like GHCi. (:
22:14:20 <humasect> oh =) it's parachuting. it stopped when i stopped handling resize event, but must be something else.
22:27:30 <humasect> woo!
22:28:27 <humasect> now i'd like to find the rules for using tuples in place of record data constructors
22:28:56 <humasect> so filter can be used on them as well.
22:42:31 <Lemmih> Anyone know when GHC 6.6 will be out?
22:43:16 <aleator> What's in it?
22:44:14 <Lemmih> The GHC library.
22:46:33 <Korollary> it will be out after ghc 6.4.1 I think
22:48:09 <wilx> Which means another 6-9 months? :)
22:49:43 * Lemmih wonders if the GHC library could be released independently of GHC.
22:50:25 <Korollary> a la glibc ?
22:50:50 <Lemmih> glibc?
22:50:53 <wilx> What does it really mean?
22:50:59 <wilx> A compiler in library?
22:51:14 <Lemmih> wilx: Yep.
22:51:27 <Korollary> http://directory.fsf.org/GNU/glibc.html
22:51:31 <Lemmih> wilx: Extreme version of hs-plugins (:
22:51:37 <wilx> :)
22:52:44 <Lemmih> Korollary: I still don't see its relevance.
22:53:20 <Korollary> Lemmih: it's independent of gcc if I understood it correctly
22:53:52 <Lemmih> But glibc isn't a C compiler.
22:54:24 <Korollary> is the ghc library a ghc compiler ?
22:55:07 <Lemmih> A Haskell compiler, yes.
22:55:47 <Lemmih> It's the guts of GHC.
22:56:05 <Korollary> I thought the ghc library referred to the hierarchical libs
22:56:38 <humasect> i'm making a lot more progress now, thanks again guys =)
23:15:40 <vikasg> morning #haskell
23:19:18 <humasect> morning ^_^
23:25:41 <vikasg> yo dblhelix
23:25:48 <dblhelix> hi vikasg
23:26:01 <dblhelix> how's code?
23:26:17 <vikasg> not so good, I've been out of town for 4 days
23:26:35 <dblhelix> ah, for pleasure, I hope?
23:27:24 <vikasg> not really. It was a family ceremony
23:27:27 <lispy> hmm...yes, lists can be isomorphic to polynomials
23:27:44 <lispy> and then (:0) 1 => [1, 0] :)
23:33:20 <vikasg> what inspired the FUSE binding, I wonder
23:38:54 <lispy> vikasg: for droundy?
23:39:31 <rt> sigh.
23:39:43 <lispy> heave.
23:41:33 <vikasg> lispy, filesystems in Haskell seems a little unusual, that's all
23:42:05 * rt wonders why this applet doesn't work.
23:42:25 <lispy> vikasg: well in the case of darcs i see where it might makes sense, but thework of SyntaxNinja i'm not sure why he's trying to use it
23:43:06 <lispy> i suspect SyntaxNinja is interested for getting a filesystem thatis correct above all else
23:43:13 <lispy> performance being secondary
23:43:20 <vikasg> lispy, do you mean there might be a darcs-fs?
23:43:41 <lispy> vikasg: iirc droundy speculated about caching
23:43:56 <lispy> vikasg: i'm not sure if he's still interested in working on it
23:45:30 <lispy> vikasg: i think, he wanted to use it to make darcs more effcient between computers that are only connected by a network
23:45:43 <lispy> but, that's partly speculation on my part
23:46:31 <vikasg> anyway, neat hack
23:49:59 * boegel shouts: "Goooooooooooooooooodmorning everyone !"
23:50:31 <lispy> boegel: heh, it's not even 00:00 here yet :)
23:50:50 <astrolabe> morning boegel
23:50:56 <lispy> @timein san jose
23:51:04 <vikasg> hey boegel
23:51:26 <Itkovian> meuning
23:53:49 <boegel> lispy: maybe it's been 00:00 long gone :) :p
23:54:01 <boegel> yo astrolabe, vikasg, Itkovian
