00:30:20 * lispy_ doesn't know german
00:30:40 <lispy_> @translate guten abend
00:30:40 <lambdabot> Unknown command, try @listcommands.
00:31:34 <luqui> @babel guten abend
00:33:30 <lambdabot>  bzzt.
00:35:11 <scalopus> xD
01:54:50 <xerox> @babel de en guten abend
01:54:52 <lambdabot>  good evening
02:08:55 <shapr> @yow
02:08:56 <lambdabot> I'm wearing PAMPERS!!
02:17:58 <reppie[^_^]> http://yellow5.com/pokey/archive/index368.html
02:18:14 * shapr hugs lambda calculus
02:22:56 <shapr> wazzup?
02:30:10 <reppie[^_^]> not much, you?
02:32:37 <shapr> Just workin. Has anyone here tried musasabi's hswebforms?
02:32:57 <reppie[^_^]> so you work on sudays?
02:32:58 <reppie[^_^]> sundays
02:34:58 <shapr> If I need to, yes.
02:36:27 <xerox> http://www.newssocket.com/features/article/231/ this is fun
02:37:56 <reppie[^_^]> what's your opinion on the happy cat
02:37:57 <reppie[^_^]> http://home.ngi.de/grmbl/happy_cat.jpg
02:38:36 <reppie[^_^]> =^_^=
02:40:06 <xerox> He's indeed happy
02:43:05 <Beelsebob> who is? Alex?
02:43:09 <Beelsebob> boom boom tish!
02:43:19 <reppie[^_^]> the happy cat
02:53:33 <xerox> @type (<)
02:53:40 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:53:40 <xerox> @type min
02:53:41 <lambdabot> forall a. (Ord a) => a -> a -> a
02:53:46 <xerox> @type minimum
02:53:47 <lambdabot> forall a. (Ord a) => [a] -> a
03:32:49 * shapr boings
04:12:30 <reppie[^_^]> http://www.albinoblacksheep.com/flash/epic
04:30:52 <Beelsebob> @hoogle unsafePerformIO
04:31:18 <xerox> @index unsafePerformIO
04:31:19 <lambdabot> System.IO.Unsafe, Foreign
04:31:25 <Beelsebob> cheers
04:31:28 <xerox> @type System.IO.Unsafe.unsafePerformIO
04:31:33 <xerox> yw :)
04:31:33 <lambdabot> forall a. IO a -> a
04:32:47 <Beelsebob> hmm...
04:33:00 * Beelsebob wonders how to break lazy evaluation
04:33:35 <xerox> seq?
04:33:43 <Beelsebob> @index seq
04:33:44 <lambdabot> Prelude, Control.Parallel
04:33:45 <xerox> Or strict type declaration
04:33:51 <Beelsebob> @type seq
04:33:53 <lambdabot> forall b a. a -> b -> b
04:33:58 <Beelsebob> cool
04:34:04 <Beelsebob> surely that's unsafe?
04:34:09 <xerox> It evaluates a before evaluating b, it is not unsafe
04:34:14 <Beelsebob> buh... not the word I meant
04:35:11 <xerox> It just enforce strict evaluation, FWIU
04:35:41 <greenrd> see also deepSeq
04:36:00 <greenrd> deepSeq is what you want if you want non-atomic data *fully* evaluated
04:37:22 <Beelsebob> ah, okay, no, I want lazy evaluation within it
04:37:40 <Beelsebob> I just want to dump a file when I call a specific function
04:40:16 <xerox> @type deepSqe
04:40:21 <xerox> @type deepSeq
04:40:22 <lambdabot> bzzt
04:40:22 <lambdabot> bzzt
04:40:29 <xerox> @index deepSeq
04:40:30 <lambdabot> bzzt
04:40:34 <xerox> MIA
04:40:35 <Beelsebob> apparently not
04:40:41 <Beelsebob> @hoogle deepSeq
04:40:47 <Beelsebob> nope
04:41:04 <wilx> It is afaik not a standard module that provides it.
04:41:14 <wilx> I remember that I had to d/l it from somewhere.
04:42:07 <xerox> @google Haskell deepSeq
04:42:08 <lambdabot> http://users.aber.ac.uk/afc/stricthaskell.html
04:46:38 <xerox> http://users.aber.ac.uk/afc/stricthaskell.html#deepseq
05:00:45 <dcoutts> morning
05:01:44 * dcoutts seems not to have a hangover (unlike the rest of his party guests)
05:06:50 <wilx> :)
05:06:53 <wilx> Lucky you.
05:31:41 * shapr throws continuations
05:32:46 * xerox compiles haddock
05:33:26 <xerox> shapr: \o/ http://sourceforge.net/mailarchive/forum.php?thread_id=8063084&forum_id=44293
05:35:36 <Akshaal> cool :)
05:36:07 <xerox> ^_^
05:40:34 <shapr> xerox: Congratulations!
05:41:00 <xerox> Thank you!
05:41:10 * shapr gives xerox today's golden lambda award.
05:41:25 * xerox puts his beside his other two!
05:42:15 <Igloo> dons: I think the PS.foo renaming is probably the right thing to do. It just annoys me that you have to then jump through types to get an unqualified type name
05:44:45 <xerox> http://www.aboutrealstuff.com/arc/fr/haskell/
05:44:54 <xerox> Uhm, do you know what is this, and who runs it?
05:44:59 <dons> Igloo, ok. that's good enough for me. I'll do the renaming
05:45:41 <dons> xerox. hmm
05:46:10 * Igloo wonders if type String = PackedString would make sense too. Or even renaming PackedString
05:47:21 <dons> I noticed PString when doing some googling
05:49:57 <Igloo> Hmm?
05:50:23 <Igloo> I meant using PS.String might be a reasonable alternative to   import PackedString (PackedString)
05:50:40 <dons> ah. ok, I see. hmm
05:51:30 <Philippa> doesn't PS.String give you trouble with the existing String?
05:51:35 <xerox> dons?
05:51:53 <Igloo> No more than PS.head etc does
05:51:54 <Philippa> ISTR you can't have one module be the default
05:53:11 <reppie[^_^]> 4 italians in the first 3 places!
05:59:14 <^buggy^> Hi, i'm having a bit of trouble with maintaining numerical accuracy using iterate
05:59:47 <^buggy^> Ok firstly some mathematica output which we can assume is correct (I get this result from other sources too)
05:59:48 <^buggy^> In[8]:=
05:59:48 <^buggy^> 455413 * 1.08 - 25000
05:59:48 <^buggy^> Out[8]=
05:59:48 <^buggy^> 466846.
05:59:57 <^buggy^> Er..
06:00:05 <^buggy^> Sorry.
06:00:16 <^buggy^> In[9]:=
06:00:17 <^buggy^> f[x_] := 1.08 * x - 25000
06:00:17 <^buggy^> In[12]:=
06:00:17 <^buggy^> f[f[f[f[f[f[455413]]]]]] // N
06:00:17 <^buggy^> Out[12]=
06:00:17 <^buggy^> 539285.
06:00:21 <^buggy^> that's what I meant to type
06:00:30 <Beelsebob> @paste
06:00:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:01:05 <^buggy^> Oh thanks.  I was thinking of using one but wasn't sure if 6 lines was considered something i'd need to pastebin but i won't paste that many in future.
06:01:49 <^buggy^> anyway this is what I get in haskell when I do (iterate ((*1.08) . (\x -> x - 25000.0)) 455413.0) !! 6
06:01:57 <^buggy^> 524613.3
06:02:13 <^buggy^> Which is pretty inaccurate :(
06:02:19 <reppie[^_^]> fucking lilo.
06:02:47 <^buggy^> By the 64th itereation (which is what i'm interested in), my hugs has gone crazy in terms of accuracy
06:03:02 <reppie[^_^]> crazy in love
06:03:02 <Beelsebob> :/
06:04:00 <Lemmih> ^buggy^: Checkout Data.Ratio.
06:05:07 <Lemmih> @eval (iterate ((*1.08) . (\x -> x - 25000.0)) 455413.0) !! 6 :: Ratio Integer
06:05:11 <Igloo> ^buggler^: Are you sure the Haskell one is the inaccurate one?
06:05:11 <lambdabot> 128079373056957%244140625
06:05:23 <Igloo> Doing it with a rational and then diving in bc I get something close to the Haskell answer
06:05:43 <^buggy^> Oh
06:05:56 <^buggy^> Shit...
06:06:13 <^buggy^> My bad, i forgot to put brackets in my mathematica function
06:06:20 <^buggy^> I was meant to put 1.08 * (x - 25000)
06:07:04 <xerox> Anyone in the mood for a Go game?
06:07:07 <^buggy^> sorry everyone :(
06:09:15 <cjb> xerox: Could be.  How strong are you?
06:10:06 <xerox> cjb: on KGS I'm [8k?] now, I don't play from some time :-)
06:10:25 <cjb> xerox: Oh, that's cool, I'm KGS 9k.
06:10:59 <xerox> Nice, does KGS work for you now?
06:11:32 <cjb> Yup.
06:11:48 <xerox> Oh, nice.  It gave me some kind of IO exception.
06:12:00 <xerox> I'm xerox there too :-)
06:12:29 <xerox> The connection to the server has been closed unexpectedly. You must log in again.
06:12:30 <xerox> Ouch
06:12:34 <cjb> Oh!  Just got that too.
06:12:39 <cjb> Looks like the server's crashing.
06:12:46 <xerox> Hmpf.
06:13:47 <xerox> Game adjourned...
06:21:00 <vegai> hmm, anyone using vim to write haskell?
06:21:10 <vegai> is the autoindenting supposed to work?
06:22:10 <cjb> xerox: Well, KGS is back, maybe temporarily.
06:22:18 <pesco> vegai: I use vim, and it doesn't seem to be very smart about autoindent.
06:25:31 <xerox> cjb: back there :)
06:46:09 <shapr> jiihaa
06:50:14 * shapr pokes Heffalump with a jar of hunny.
06:50:19 <shapr> hi Pita
06:50:21 <Pita> Setup.lhs: internal error: stg_ap_v_ret
06:50:29 <Pita> I am getting this error on Mac OS X
06:50:45 <Beelsebob> pita: that's a well known one
06:50:51 <Beelsebob> use ghc6.2.2
06:50:56 <Pita> Hmm
06:51:02 <Pita> So I have to downgrade?
06:51:07 <Beelsebob> ... or possibly the latest 6.5, but I can't remember if that works
06:51:20 <Pita> Dearn
06:51:23 <Beelsebob> pita: while there's bugs in 6.4 yes ;)
06:51:30 <Pita> :(
06:51:38 <Pita> Nothing works on OS X :(
06:51:43 <Pita> it's like the unpreferred platform
06:51:53 <Lemmih> Or just compile Setup.lhs.
06:52:03 <Beelsebob> heh, I think they're working on a native code generator for OS X
06:52:21 <Beelsebob> lemmih: does that work?
06:52:28 <Lemmih> Beelsebob: Yes.
06:52:36 <Beelsebob> oh... random
06:52:46 <Beelsebob> I think I might chuck 6.5 on this machine today
06:53:37 <Pita> Where do you find 6.5?
06:53:45 <Beelsebob> cvs
06:53:48 <Pita> Beelsebob: is that problem only on OS X?
06:54:18 <Lemmih> Pita: Compiling the Setup script is way faster than compiling GHC.
06:54:36 <Beelsebob> pita: I think there's a problem with version reporting in some config scripts... but it's a matter of taking a couple of obvious new lines out from the resulting config files
06:55:04 * Beelsebob wonders why haskell.org has died
06:55:42 <Lemmih> Works for me.
06:56:02 <Beelsebob> loading *very* slowly for me
06:56:26 <Beelsebob> in the time since I said that I've got... "Haskell is a general purpose, purely functional programming language. Haskell compilers are freely"
06:56:52 <Pita> Lemmih: what do you mean?
06:57:10 <Beelsebob> ghc Setup.lhs
06:57:20 <Beelsebob> ./a.out
06:57:31 <Lemmih> Pita: Compiling the Setup script instead of interpreting it will make the problem go away.
06:57:40 <Pita> hmm
06:57:43 <Pita> really
06:58:16 <Igloo> Beelsebob: It's nippy enough here
06:58:33 <Beelsebob> odd... the whole web is still being fast... other than haskell.org
06:58:53 <shapr> Tried traceroute?
06:59:49 <Beelsebob> oh... it's suddenly gon fast
06:59:52 <Beelsebob> oddness
07:00:00 <Pita> hmm installation actually made problem go away
07:00:06 <Pita> compilation i meant
07:00:10 <Pita> why?
07:00:32 <Beelsebob> just a bug in ghc
07:01:00 <Lemmih> Buggy bytecode generator on MacOS, perhaps.
07:01:20 <Beelsebob> doesn't the compiler work by interpretting the bytecode and writing out though?
07:01:29 <Beelsebob> oh no... that's nhc
07:01:40 <Beelsebob> don't know how ghc works
07:02:47 <Pita> Atip-Asvanunds-Computer:~/Desktop/Crypto-2.0.2 atip$ sudo ./setup install
07:02:47 <Pita> Installing: /usr/local/lib/Crypto-2.0.2 & /usr/local/bin Crypto-2.0.2...
07:02:47 <Pita> Error: Could not find module: Codec.ASN1 with any suffix: ["hi"]
07:02:49 <Beelsebob> Hmm, I'll be able to compare G4 to P4 doing this
07:03:08 <Pita> Now another error installing crypto :(
07:03:16 <Lemmih> Pita: Did you build the library?
07:03:19 <Beelsebob> pita: looks like you're missing a dep
07:04:08 <Pita> forgot to build
07:05:31 <Pita> i was coding in lisp for a while
07:05:42 <Pita> and I decided to change because of lack of up-to-date libs
07:05:54 <Beelsebob> change back to?
07:06:05 <Pita> i was coding Java before
07:06:11 <Pita> but now i really like functional aspect of lisp
07:06:13 <Beelsebob> oh dear
07:06:51 <Beelsebob> somehow I don't think this G4 is going to get through the ghc build quite as fast as my P4 at work
07:07:11 <Pita> Beelsebob: powerbook?
07:07:15 <Beelsebob> mini
07:07:25 <Beelsebob> 1.25 mini against a 3.6Ghz P4
07:07:38 <Pita> i might buy a mini to setup a server
07:07:39 <Beelsebob> P4 took half an hour
07:07:52 <psi> it'll take quite a few hours I think
07:07:55 <Beelsebob> mine is a nice machine
07:08:12 <Beelsebob> although I'm getting a bit worried about it's fan
07:08:25 <Pita> the p4 or mini?
07:08:26 <Beelsebob> seems to be grinding when it does come on... I wonder if the bearings are dead
07:08:28 <Beelsebob> the mini
07:08:40 <Beelsebob> doesn't come on often, but when it does it grinds
07:08:43 <Pita> u think haskell will catch on like ruby?
07:08:55 <Beelsebob> I hope so
07:09:16 <shapr> I think it is already catching on.
07:09:26 <Beelsebob> my development time for things is much much shorter with haskell
07:09:26 <shapr> But it won't catch on inside the PHP crowd...
07:09:32 <Pita> shapr: how so? I am new here so I wouldn't know the past
07:09:45 <Lemmih> shapr: Not even with HSP?
07:09:48 <Beelsebob> shapr: you don't think hsp stands a chonce?
07:09:52 <Beelsebob> chance*
07:10:15 <shapr> Pita: This channel started 4 years ago and is still growing. More people and more code are flowing all the time.
07:11:26 <shapr> Lemmih, Beelsebob: Maybe, but I think existing PHP coders switching to HSP will gradiate into a few who embrace haskell, and many who end up 'scripting' with the code written by the few.
07:11:42 <Pita> what you think bring people to haskell, recently? isn't Haskell an old language?
07:11:50 <Pita> is it the results of programming contest?
07:11:51 <Beelsebob> I think it might begin to catch on when SPJ finishes doing the VS integration
07:12:24 <Beelsebob> pita: not very old... 98 was the first standard
07:12:44 <Pita> VS = ?
07:12:46 <shapr> Pita: I think it's several factors. Better documentation, more publicity via contests (ICFP) and visible apps (Pugs, Darcs), friendly user community, etc
07:12:52 <Beelsebob> pita: visual stuudio
07:13:04 <Pita> We need XCode integration
07:13:08 <Beelsebob> indeed
07:13:13 <Beelsebob> but it would be pretty hard
07:13:23 <Beelsebob> XCode is deisigned in a way that would be problematic
07:13:30 <Lemmih> Haskell has been around since '86 or so...
07:13:35 <Beelsebob> e.g. error messages are expected to be one line long
07:14:02 <Beelsebob> and the debugger is completely totally and uterly different from any decent Haskell debugger
07:14:09 <shapr> I think darcs is an especially powerful boost, since it eases distributed development.
07:14:34 <Igloo> Beelsebob: Haskell 1.0, 1.1, 1.2, 1.3 and 1.4 weren't standards then?
07:14:41 <Beelsebob> shapr: yeh... but ask outside the Haskell comunity, and people don't know what it is
07:14:46 <Beelsebob> igloo: :/
07:15:11 <Pita> Is there a paste site for this channel?
07:15:13 <shapr> @paste
07:15:14 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:15:15 <Beelsebob> @paste
07:15:16 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:15:18 <Beelsebob> oops
07:15:22 <shapr> In stereo :-)
07:16:15 * xerox lost !&%
07:16:32 <tuomov> Beelsebob: no, darcs is gaining popularity outside it too
07:17:04 <Pita> Linking ... /usr/bin/ld: Undefined symbols: ___DISCARD__
07:17:05 <Pita> collect2: ld returned 1 exit status
07:17:44 <Lemmih> Pita: Don't use gcc 4.0.x
07:17:57 <Pita> hmm
07:18:11 <Pita> how do I set ghc to not use gcc 4.0
07:18:17 <Beelsebob> tuomov: #macdev seems to disagree
07:18:26 <tuomov> mac...
07:18:37 <tuomov> they wouldn't use anything without a flashy gui
07:18:45 <tuomov> but in the linux world it is gaining popularity
07:18:54 <Beelsebob> ... and yet they know what svn and cvs are?
07:19:08 <tuomov> there are flashy guis for them
07:19:22 <Beelsebob> there are... but most people don't use them
07:19:22 <Pita> Lemmih: how do I do as you say?
07:19:34 <Beelsebob> pita: sudo gcc_select 3.3
07:19:44 <Lemmih> Pita: I have no idea. Never used a Mac myself.
07:19:51 <Beelsebob> oh... we have one taker... one mac dev knows
07:20:15 * cjb returns from fun go game with xerox.
07:20:37 <xerox> :-)
07:20:41 <Pita> Still get the same error
07:20:59 <Beelsebob> cleaned and reconfigured?
07:21:19 <Pita> Yep
07:21:20 <Pita> :(
07:21:24 <Beelsebob> :/
07:21:31 <Beelsebob> what is it you're trying to build?
07:21:38 <Pita> ghc --make -package HTTP get.hs -o get
07:21:39 <Pita> Chasing modules from: get.hs
07:21:39 <Pita> Compiling Main             ( get.hs, get.o )
07:21:39 <Pita> Linking ...
07:21:39 <Pita> ld: Undefined symbols:
07:21:41 <Pita> ___DISCARD__
07:21:58 <Pita> from this page: http://cvs.haskell.org/darcs/http/test/get.hs
07:21:58 <Beelsebob> hmmm, never seen that
07:22:17 <Beelsebob> @where alex
07:22:18 <lambdabot> http://www.haskell.org/alex/
07:22:22 <Beelsebob> @botsnack
07:22:23 <lambdabot> :)
07:22:31 <tromp> hi folks
07:22:32 * pesco picks himself up.
07:22:38 * pesco greets the round.
07:22:49 <shapr> hiya!
07:22:51 <tromp> in case anyone is interested...
07:22:54 <pesco> shapr1
07:23:08 <pesco> Cool, new lambdabot modules!
07:23:08 <shapr> hoi tromp, how's it go-ing?
07:23:09 <Lemmih> Pita: What does 'gcc -v' say?
07:23:12 <tromp> the number of legal 15x15 Go positions is 10751464308361383118768413754866123809733788820327844402764601662870883601711298309339239868998337801509491
07:23:14 <pesco> @where http
07:23:15 <lambdabot> I know nothing about http.
07:23:27 <Pita> Beelsebob:  here is my guess. i installed the HTTP module. but how would the ghc know that it has been installed?
07:23:32 <tromp> just finished the computation today:)
07:23:34 <pesco> @where http http://haskell.org/http/
07:23:35 <lambdabot> I know nothing about http.
07:23:35 <Pita> how would GHC know where to find HTTP?
07:23:41 <tromp> with a tiny little help from haskell:)
07:23:44 <Beelsebob> pita: it'll be in the package system
07:23:52 <Beelsebob> run ghc-pkg -list
07:23:55 <pesco> Pita: I meant the http package.
07:24:41 <pesco> @where pesco-cmdline
07:24:42 <lambdabot> I know nothing about pesco-cmdline.
07:24:48 <pesco> Dang!
07:25:09 <tromp> afk a bit
07:26:07 <Pita> Beelsebob: it is in the package system
07:26:12 <Pita> so what could be causing that error?
07:27:04 <Beelsebob> well... how are you figuring out that the symbol should be in the HTTP package?
07:27:28 <Pita> i just followed the instruction
07:27:32 <Lemmih> pesco: It's on Hackage (:
07:27:37 <xerox> tromp: is the code that you use to calculate them publicly available?
07:27:48 <Beelsebob> hmm, I'm not sure
07:27:54 <pesco> Lemmih: I know. Have you made any progress on the web frontend?
07:27:59 * pesco looks at his web browser.
07:28:00 <Lemmih> pesco: http://hackage.haskell.org/ModHackage/Hackage.hs <- second page.
07:28:02 <Beelsebob> argh... I just got the same error
07:28:09 <Beelsebob> for something different
07:29:41 <Beelsebob> :/ haskell.org is being slow again
07:31:19 <Igloo> Lemmih: What's the backend for hackage?
07:31:45 <Igloo> ("Preferences" shouldn't work yet, right?)
07:32:16 <Lemmih> Right, haven't gotten around to hack that yet (:
07:32:34 <Beelsebob> pita: mine stopped giving that error after selecting gcc 3.3
07:32:38 <Igloo> OK, just checking it was known  :-)
07:32:41 <Beelsebob> are you sure it was correctly selected
07:32:54 <Pita> hold on
07:32:54 <Lemmih> Backend for hackage?
07:33:00 <pesco> Lemmih: I see. I need to register pesco-cmdline-2.0! What do I do?
07:33:04 * Igloo is wondering if there's some sort of database behind the curtain or if things like search are opening all the .cabal files
07:33:13 <Beelsebob> and just to check it cleaned correctly I would deleta and decompress again
07:33:30 <Lemmih> Igloo: It uses a PostgreSQL database.
07:33:43 <Igloo> OK, thanks
07:34:24 <Lemmih> pesco: Download and install cabal-put.
07:34:37 <pesco> Lemmih: Good!
07:35:59 <Pita> Beelsebob: read here  : http://sourceforge.net/mailarchive/forum.php?thread_id=7875384&forum_id=2056
07:36:02 <Pita> seems an error with Tiger
07:36:05 <Lemmih> pesco: It's a bit of a dependency hell.
07:36:16 <Beelsebob> pita: yeh... with gcc 4.0
07:36:20 <Beelsebob> you need to use 3.3
07:36:22 <pesco> Lemmih: Ehh.
07:36:34 <Pita> i switced to 3.3 and still died
07:36:47 <Pita> $ gcc_select
07:36:48 <Pita> Current default compiler:
07:36:48 <Pita> gcc version 3.3 20030304 (Apple Computer, Inc. build 1809)
07:37:14 <Lemmih> Pita: Did you recompile all the things you compiled with 4.0?
07:37:17 <Beelsebob> have you completely removed the entire directory and re-expanded it?
07:37:24 <Beelsebob> to make sure that it was properly clean
07:38:06 <Pita> Lemmmih: nope so I have to reinstall everything i guess :(
07:38:15 <Pita> All my previous libs?
07:38:28 <Beelsebob> pita: no... leave them, they should be fine
07:38:36 <Beelsebob> just the thing your trying to build
07:38:44 <Pita> there's just one .hs file in that i am compiling
07:38:48 <Pita> i deleted .o and .hi
07:39:00 <Pita> but i compiled all my libs before that with 4.0
07:39:02 <Igloo> It's not obvious to me that libs should be fine
07:39:13 <Beelsebob> yeh... but is it trying to link against other .os compiled with 4.0
07:39:14 <pesco> Lemmih: Chasing dependencies...
07:42:45 <pesco> Lemmih: How are access controls to the package database? I see you're using PGP keys?
07:44:48 <Pita> How do I like multiple packages with -package Package1,Package2 ?
07:45:07 <Lemmih> Pita: Try --make.
07:45:26 <Pita> how do I ghc multiple package?
07:45:37 <Igloo> -package p1 -package p2
07:47:23 <Lemmih> pesco: Yeah.
07:47:24 <pesco> Lemmih: Hm, why does cabal-put depend on cabal-get?
07:48:29 <pesco> Lemmih: What does "send along the public_key if the package is unknown to the server" mean?
07:48:47 <pesco> Where do I store the key?
07:49:07 <Lemmih> pesco: It needs to read caba-get's config files and some other small stuff.
07:49:21 <exe> Morning.
07:50:43 <Lemmih> pesco: It means that Hackage will store your public key to know that you're the author/owner of the package.
07:51:41 <Beelsebob> right... 10 to 4 to start compiling... who's laying bets?
07:52:34 <pesco> Lemmih: Yes, but how do it get it there in the first place?
07:53:38 <Lemmih> pesco: Cabal-put will get it from 'gpg' and transfer it to Hackage automatically.
07:53:54 <pesco> Oh, ok. Using my default key, I presume?
07:54:22 <Lemmih> Yes.
07:54:51 <Pita> IT WORKS NOW
07:54:58 <Pita> recompiled all my libs with gcc 3.3
07:55:55 <Pita> Beelsebob: and Lemmih thanks for all ur help :)
07:55:59 <pesco> Lemmih: Cool. Should be clarified in the README though. I can send a patch. ;)
07:56:06 <Beelsebob> pita: :) np
07:57:41 <pesco> Aw! There's no manpage. :-P
07:58:24 <Lemmih> pesco: That would be great. The repo is at http://scannedinavian.org/~lemmih/cabal-put-head/
08:00:14 <pesco> Huh? It installed the executables with the wrong permissions -rwxr--r--
08:01:07 <Lemmih> Yeah, that's a bug in Cabal.
08:01:57 <Pita> Is there an IDE for haskell?
08:02:02 <Pita> What do you typically use?
08:02:36 <sieni> emacs?
08:02:38 <Beelsebob> pita: SEE, and a terminal ;)
08:02:52 <Beelsebob> if you want a debugger there's hat
08:03:22 <Beelsebob> ... or hood or freja, but I don't think either is in active development... or does as much
08:05:24 <Beelsebob> pita: there's a SEE highlighting mode here http://www.dusoft.co.uk/freebies.php
08:13:21 <xerox> Beelsebob: it's mac-only, right?
08:13:26 <pesco> Lemmih: Er, it seems to be empty...
08:13:36 <Beelsebob> xerox: SEE?  Yeh, sorry
08:13:54 <Pita> darn textmate has no haskell mode
08:14:14 <pesco> Lemmih: The repo you gave, that is.
08:15:40 <Beelsebob> pita: I'm just trying to see how to develop textmate modes
08:15:52 <Beelsebob> It may be that I can make one simply based on the SEE one
08:16:02 <Pita> Is SEE good comparing to Textmate?
08:16:18 <Beelsebob> SEE is bloody fantastic... but then I've never used textmate
08:16:51 <pesco> Lemmih: And it seems to be ignoring my freshly-made /etc/cabal-get
08:17:06 <pesco> Lemmih: Is that because I can't write to that direction?!
08:17:16 <pesco> s/direction/directory/
08:17:22 <Lemmih> Yeah.
08:17:28 <pesco> Er.
08:17:51 <Lemmih> It'll use ~/.cabal-get if it can't get /etc/cabal-get.
08:19:11 <pesco> Lemmih: Yeah, fine with me.
08:20:13 <Beelsebob> pita: I've at least added Haskell to the requested syntax modes list
08:21:09 <pesco> Hm, it could provide an error message though, if it doesn't do anything because of empty server list because of non-existant config dir because it rejects /etc/cabal-get because it can't write there because its a system directory and I'm a regular user.
08:22:11 <Lemmih> pesco: It should say 'Using config dir: [dir]'.
08:22:22 <Lemmih> pesco: Try the repo again.
08:24:34 <pesco> Lemmih: It does. Still, "using config dir" sounds positive, while actually it indicates an error.
08:24:45 <pesco> Which actually even isn't one.
08:25:32 <pesco> I know, it's a beta, I don't mean to nitpick! Just reporting.
08:26:03 <pesco> I've found the spot in the code, too. I can just add an error message if the server list is empty.
08:29:12 <beelsebob_> hehe "Michael Adams is known to his friends as "Mr Stupid", while UK tabloid the Sun classifies him as "Britain's dumbest thief". And no wonder, since the bungling blagger lifted a laptop from a Manchester CCTV store while no less than eight cameras recorded the sorry scene for posterity."
08:29:56 <Beelsebob> well.. P4 was finished 10 minutes ago... the mini is still in stage 1
08:32:59 <shapr> Man I love unicycling.
08:33:27 <Beelsebob> heh, where you been?
08:35:05 <shapr> I just went around the lake here. I still can't beat 30 minutes though, today's 32 minutes is my best so far.
08:35:54 <Beelsebob> heh
08:36:18 <Beelsebob> I should go for a ride... but my tyre's punctured and I cant be arsed repairing it
08:36:25 <tromp> yes, xerox
08:36:45 <Beelsebob> I should try and learn to glide too
08:36:51 <Beelsebob> there's a good hill for it here
08:37:00 <tromp> see http://homepages.cwi.nl/~tromp/go/legal.html
08:37:41 <xerox> tromp: yay!  Thanks.
08:40:23 <Pita> is Yi a good editor?
08:40:29 <Pita> it was written in haskell
08:40:52 <Beelsebob> heh, good place to ask
08:40:56 <Beelsebob> @seen dcoutts
08:40:57 <lambdabot> dcoutts is in #haskell. Last spoke 3 hours, 39 minutes and 13
08:40:57 <lambdabot> seconds ago.
08:41:32 <Lemmih> It's not as usable as emacs yet.
08:41:49 <Beelsebob> dons even
08:41:51 <Beelsebob> @seen dons
08:41:52 <lambdabot> dons is in #haskell. Last spoke 2 hours, 51 minutes and 10 seconds
08:41:52 <lambdabot> ago.
08:42:18 <Pita> what do windows or unix people use for haskell editor?
08:42:36 <wilx> (X)Emacs.
08:42:39 <Lemmih> emacs.
08:42:40 <shapr> I use emacs, but I want to switch to Yi!
08:42:50 <Pita> does yi have x interface?
08:43:12 <Beelsebob> @hoogle [a] -> [a] -> (a -> a -> Bool) -> [a]
08:43:13 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:43:13 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:43:13 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:43:31 <Beelsebob> @hoogle difference
08:43:48 <Beelsebob> @hoogle diff
08:43:48 <lambdabot> Time.diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
08:43:52 <Beelsebob> bah
08:44:13 <Beelsebob> anyone know if there is a differenceBy?
08:46:49 <Pita> Does haskell support unicode yet?
08:49:51 <Beelsebob> pass
08:50:43 <tuomov> Haskell Char is unicode and by the spec the source can contain unicoe characters, but IO conversion and compiler support for unicode source is lacking
08:54:04 <Beelsebob> @type \(f :: a -> a -> Bool) xs -> map $ (flip (List.deleteBy f)) xs
08:54:09 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [[a]]
08:54:24 <Beelsebob> oh... duh
08:55:42 <Beelsebob> @type \(f :: a -> a -> Bool) xs -> faldr ((flip (List.deleteBy f)) xs) []
08:55:44 <lambdabot> bzzt
08:56:08 <Beelsebob> @type \(f :: a -> a -> Bool) xs -> foldr ((flip (List.deleteBy f)) xs) []
08:56:09 <lambdabot> bzzt
08:56:50 <Beelsebob> @type \(f :: a -> a -> Bool) xs -> (flip (List.deleteBy f)) xs
08:56:51 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> a -> [a]
08:57:19 * shapr boings randomly
08:58:40 <Beelsebob> @type \(f :: a -> a -> Bool) xs ys -> foldr (flip (deleteBy f)) ys xs
08:58:42 <lambdabot> bzzt
08:58:47 <Beelsebob> oh ffs
08:59:27 <xerox> What are you trying to do?
08:59:49 <Beelsebob> be stupid by the looks of things
08:59:53 <pesco> Lemmih: I'm getting "Broken pipe" after "Registering..." (takes a while)
08:59:55 <Beelsebob> I want differenceBy
09:00:00 <Beelsebob> but my head is not working
09:00:22 <xerox> Beelsebob maybe you can use intersectBy?
09:00:27 <Lemmih> pesco: How big is the package you're trying to upload?
09:00:45 <Beelsebob> you mean (\\) . intersectBy?
09:01:31 <xerox> beelsebob, hmm - I was just wondering if the "By" function could do the difference job
09:01:39 <dcoutts> Beelsebob, pong
09:01:50 <Beelsebob> dcoutts: sorry, was being dumb
09:01:54 <Beelsebob> seems to be a pattern today
09:01:58 <dcoutts> ok, np :-)
09:03:19 <pesco> Lemmih: 250kb
09:10:04 * shapr burbles
09:10:54 * Beelsebob takes shapr's example and fixes his uike
09:13:38 <shapr> yay!
09:13:57 <shapr> On the good side, I have three unicycles, one for teaching and two for riding.
09:14:13 <shapr> pesco: Want to write an article for the last Monad.Reader?
09:14:31 <reppie[^_^]> what's your opinion on communism
09:14:43 <shapr> Great idea, too bad no one has ever tried it.
09:15:11 <reppie[^_^]> i think your opinion is good
09:15:36 <shapr> The idea behind communism is that everyone produces the maximum they can and share everything equally. I went to a Communist Youth Festival in Athens (just figured I'd try something new), and now I will gladly kick the ass of any Communism who gets close to me.
09:15:48 <shapr> er, Communist*
09:15:57 <reppie[^_^]> were they gay?
09:16:08 <tuomov> eh, not equally, but by need
09:16:08 <shapr> No, they were harboring serious evil.
09:16:21 * Igloo welds shapr unicycles together to make a tricycle
09:16:52 <tuomov> "From each according to his abilities, to each according to his needs."
09:16:56 <shapr> The Communism Youth Festival in Athens held a lot of hatred, bigotry, violence, and worse.
09:17:28 <tuomov> what can you expect from youth?
09:17:38 <shapr> By the time I'd finished looking at the display booths, I felt sick to my stomach, I thought I was going to vomit...
09:19:34 <shapr> There were various booths claiming all sorts of insane shit. That America was not so secretly controlling the entire world, that money should be abolished, that NATO was the root of all evil, that a violent rebellion was the only solution, that the average American family is addicted to drugs and consists of prostitutes... I could go on in great detail.
09:19:51 <Beelsebob> bugger... I've got a crossed thread... might need to get my hacksaw out
09:20:22 <tuomov> that first is not so false as it might first sound.
09:20:44 <tuomov> americans own a lot
09:20:52 <shapr> They had pictures of masked rebels standing over dead bodies and cheering...
09:21:00 <shapr> So do Japanese, Taiwanese, etc
09:21:45 <shapr> If you track down the corporate structures, quite a few of big US companies are actually owned by people outside of the USA.
09:22:18 <tuomov> the share webs are very complicated indeed
09:22:21 <shapr> Anyway, China will be the next villain, because they'll be the most profitable soon.
09:23:58 <shapr> So, the original intention/idea behind Communism is a great idea that cannot be implemented by humans, only by jellyfish and other colonial collective organisms.
09:24:37 <Akshaal> :)
09:24:45 <tuomov> I'm not so sure about that, but it will take and the revolution must be a "social revolution" or a "revolution of the mind", not a violent takeover of state power, which is what the marxists advocate
09:24:55 <tuomov> s/take/take time/
09:25:07 <ikor> shapr: agree with you
09:25:37 <Beelsebob> bloody hell sawing through steel is hard work
09:25:57 <shapr> tuomov: One day maybe, but you're talking about a Star Trek world... I don't think it will be soon.
09:26:25 <tuomov> not in our lifetimes, but we can try to approximate it the best we can
09:26:39 <tuomov> the first step is creating such conditions that nobody has to submit to wage slavery
09:26:44 <shapr> In my opinion, the only motivation that could get all humans to work together without internal controls, would be an external threat like an alien invasion.
09:27:23 <shapr> Hm, I think it's the other way around. I think most humans only do stuff to survive.
09:27:59 <shapr> Maybe I'm just pessimistic.
09:28:10 <tuomov> stuff still needs to be done to survive, but abolishing wage slavery needs to be done to absolish authoritarian workplaces
09:28:33 <ikor> shapr: alien'll replace us by more productive creations -  robots.
09:28:39 <shapr> ikor: hah, maybe so.
09:28:58 * xerox replaces aliens with robots
09:29:28 <shapr> tuomov: I think more options would help. If it were easy to move to another country to work, then countries would have to compete for workers. You'd get capitalism on a grander scale.
09:29:49 <shapr> Not that I think capitalism is a wonderful system, but I haven't found anything better. I don't know how to build a true meritocracy.
09:30:41 <tuomov> the problem is that the majority of people will still have to sell their labour to the capitalist class for a living, and submit to authoritarian control of their lives at these workplaces
09:30:42 <shapr> I do think that capitalism rewards adaption more than the other governmental systems I've seen in action.
09:31:43 <shapr> tuomov: But if it's easy to change workplaces on a global scale, then workplaces must improve to keep the workers.
09:32:34 <Beelsebob> ow... bob's hint for the day... don't crush your finger with a wrench
09:32:41 <tuomov> not if most people are unnecessary.. it is in the interests of the capitalist class to maintain a certain level of unemployment with crappy benefits so that the workers will have to agree to their terms
09:33:01 <Spark> less people sounds like a plan
09:33:10 <Beelsebob> fewer people
09:33:15 <shapr> But workers are also the capitalist class, you can start your own business.
09:33:18 <Spark> less face
09:33:25 <tuomov> unlikely to help.. there will be less consuming too then
09:33:38 <tuomov> a business owner is not necessary a capitalist
09:33:52 <tuomov> a capitalist is someone who can live on capital income and thus does not have to sell his labour for a living
09:36:02 <Pita> Beelsebob: did you pay for SEE?
09:36:20 <Beelsebob> pita: I have now, because I use it to develop the dusoft website
09:36:21 <shapr> Still, it takes a very large amount of money to live on only the interest.
09:36:34 <Beelsebob> you don't need to if you don't use it for comercial purposes
09:36:53 <tuomov> yes, but these few people are who ultimately control the world thanks to holy property laws
09:37:12 <Pita> i see people praising the coolaborative feature. but without that how does it compare to other editors?
09:37:22 <shapr> Hm, I disagree... looks to me like the middle class has much more economic leverage.
09:37:23 <Beelsebob> it's a good simple editor
09:37:33 <Spark> only if you rally them
09:37:35 <Beelsebob> depends what you want
09:37:36 <Spark> so the media are the ones with the power
09:37:45 <shapr> Sure, I agree.
09:37:47 <Beelsebob> I want it to not have many features and work neatly
09:37:50 <Beelsebob> that's what SEE does
09:37:53 <sh10151> emacs++
09:37:57 <shapr> Yi!!
09:37:58 <Spark> i reckon the government has the most power... and those that control the government
09:38:06 <xerox> Beelsebob, I'm trying gobby at the moment
09:38:09 <Spark> the government has an army
09:38:09 <xerox> It's _really_ nice!
09:38:12 <Beelsebob> sh: I want it to not have many features and work neatly => emacs --
09:38:23 <xerox> It also has Haskell synhl, heh.
09:38:41 <shapr> Yeah, the gov't does have the most power, that why it requires so many checks and balances.
09:38:42 <xerox> Beelsebob, do you have any free time to try compiling it on OS X and try it?
09:38:53 <Lunar^> shapr: David Roundy annonced a darcs based filesystem?
09:38:58 <Beelsebob> xerox... could do... but my mini is busy
09:39:12 <Beelsebob> oh... no it isn't ... it just failed
09:39:13 <xerox> Aww.
09:40:24 <tuomov> a govt. is quite powerless when a capitalist says, "sorry, the workers can't use this facility anymore until you lower my taxes etc."
09:40:42 <tuomov> "if that doesn't happen I'll move the production elsewhere"
09:40:51 <Beelsebob> xerox... it'll be a pita to build... fink only has gtk2.4.9 in
09:42:22 <tuomov> Now, if there wasn't private property beyond "personal property", things would be very different
09:57:59 <Pita> Beelsebob: have you tried wxhaskell?
09:58:06 <Beelsebob> nope
09:59:06 <Beelsebob> yay... finally sawed through the bolt
10:08:40 <Beelsebob> yay... uike back in action
10:29:05 <shapr> Lunar^: Or at least some sort of fuse binding.
10:30:29 <Lunar^> shapr: I need to check this out with Syntax
10:30:38 <Lunar^> it would be lame to duplicate efforts
10:46:01 <shapr> yeah
11:08:58 <greenrd> shapr: There are lots of creepy and/or corrupt people who've attached themselves to the communist / revolutionary socialist parties
11:09:35 <greenrd> shapr: And I say that as a non-aligned socialist
11:09:39 <vegai> do you people use yi already for serious stuff?
11:11:26 <greenrd> shapr: I don't think I'd want to join any revolution led by any of the communist or revolutionary socialist parties I know of
11:11:58 <cjb> tromp: Congrats on 15x15.  :)
11:13:46 <greenrd> shapr: Even the idealistic SPGB, which advocates the electoral route to communism, says that all other political parties are the enemy (more or less), and free speech is "borgeious"
11:14:22 <greenrd> which makes it not that different from the cult of scientology, essentially
11:14:42 <Korollary> you mean "bourgeois" I think
11:15:15 <greenrd> I do
11:16:05 <mikael> http://www.phubuh.org/~mikael/teacta.html
11:16:25 <mikael> (regarding the ideal of ``from each according to his ability; to each according to his need'')
11:18:18 * greenrd pukes
11:18:21 <greenrd> Ayn Rand?
11:18:27 * greenrd doesn't bother to read it
11:19:21 <jesse99> how can anyone believe in state ownership of the means of production nowadays?
11:20:18 <greenrd> jesse99: A lot of people in less developed countries (and in France, somewhat anomalously) do
11:21:03 <jesse99> france maybe, but I thought even the less developed countries were starting to see that that's a bad idea
11:21:43 <jesse99> it's certainly not like it used to be, where scocialism was seen as THE way to develop
11:22:25 <greenrd> And World Bank / IMF conditionalities are a big reason for that change.
11:22:59 <jesse99> i think a bigger reason are real world results, especially situations like n/s korea, e/w germany
11:23:00 <greenrd> Privatization hasn't exactly been a success everywhere though.
11:23:26 <mikael> don't forget hong kong :-)
11:23:31 <jesse99> or china after it ditched communist economics
11:23:35 <greenrd> In Bolivia, after the water was privatized, water prices shot up and there was rioting in the streets.
11:23:35 <jesse99> ya
11:24:07 <greenrd> Those pesky poor people, they don't understand economics!
11:24:13 <exe> greenrd, are you Bolivian?
11:24:18 <greenrd> Er, no.
11:24:19 <jesse99> that's great grrend, you've discovered nothing is perfect
11:31:56 <SamB> @index gfoldl
11:31:57 <lambdabot> Data.Generics.Basics, Data.Generics
11:31:58 <SamB> @index gfold
11:31:59 <lambdabot> Data.Graph.Inductive.Basic, Data.Graph.Inductive
11:35:47 <tuomov> a hint: there's no state in communism
11:35:50 <Beelsebob> evening lispy
11:36:17 <jesse99> and there's no state that has come even close to that happy day =)
11:36:29 <tuomov> most marxists want to reach this communism through a totalitarian "workers'" state, but not every socialist wants to
11:36:38 <tuomov> anarchists are socialists as well, you know
11:36:42 <Beelsebob> um... that's tautologes
11:36:49 <Beelsebob> or however the fuck you spell it
11:36:57 <jesse99> no country then
11:36:59 <Beelsebob> there is no state that has come close to not having a state
11:37:07 <greenrd> heh
11:37:32 <greenrd> I'm not an anarchist.
11:37:35 <tuomov> catalonia in spanish civil was an interesting experiment..
11:37:38 <tuomov> I am..
11:38:00 <jesse99> you're not going to acheive communism without a large degree of force (against the rich or the un-converted)
11:38:27 <jesse99> that's why every communist state has been so vicously repressive
11:38:28 <Beelsebob> jesse: the way to do it would be to stop them being rich
11:38:36 <greenrd> heh
11:38:36 <Beelsebob> and they'd quickly become converted
11:38:48 <tuomov> communism is a very long term plan, and I don't even think it will be immediately achieved even after the "social revolution" that anarchists seek for
11:39:03 <tuomov> some kind of individualist anarchism seems more like first stage
11:39:37 <jesse99> i dont see a path from anarchism to communism, if anything iot would seem to widen differences
11:39:55 <mikael> tuomov, do you think that all wage employment is "slavery"?
11:39:55 <tuomov> communism is an anarchy
11:40:15 <tuomov> mikael: in today's world, yes
11:40:36 <tuomov> it becomes not-slavery only when there's a true choice not to work
11:40:47 <greenrd> Maybe in a kind of nightmare, post-environmental-apocalypse scenario, the poor would finally rise up against the rich who refused to stop hoarding their wealth.
11:41:43 <tuomov> I'm not against "rich" people, I'm against the power of major capital
11:42:08 <tuomov> i.e. essentially private property beyond "personal property".
11:42:31 <mikael> if you don't work, there are two possibilities: somebody else provides for you, or you die.  even in your ideal society, one man can only avoid work to the extent that another man works for him
11:42:33 <jesse99> i.e. you're for some totally imaginary utopia or for violence against those who have more than you
11:43:11 <greenrd> mikael: so?
11:43:41 <tuomov> it should be possible to safely quit one's job if the working environment sucks
11:43:49 <tuomov> it's not possible in today's world
11:44:28 <tuomov> if you quit your job yourself, you don't get benefits for three months in .fi at least, and so on, and they don't last forever, and it may not be possible to find a job in this climate
11:44:34 <mikael> greenrd: so, I'm wondering, how is anarchism different from capitalism in this respect?
11:44:53 <greenrd> mikael: I am not an expert on anarchism. I'm not an anarchist.
11:45:28 <tuomov> anarchism is totally incomptible with capitalism
11:45:44 <mikael> yes, certainly
11:45:54 <liyang> anarchism is just the lack of central control.
11:45:55 <greenrd> jesse99: Yes, I'm for redistributive taxes. (Known by some as "violence against those who have more than you.")
11:46:14 <tuomov> liyang: yes, and huge private properties are central control
11:46:35 <mikael> I thought anarchism was the lack of all ``hierarchical relations'' aka ``slavery''.  am I confused?
11:46:36 <liyang> It's anti-governmental intervention. That doesn't immediately pits it up against capitalism.
11:46:54 <tuomov> mikael: that's another way of putting it
11:47:02 <jesse99> if you want to level the field you are going to need mass coercion, escatly the sort of thing the SU did early on
11:47:09 <liyang> I could start a small business under anarchism. How's that central control?
11:47:24 <tuomov> liyang: it's "no rulers", that includes capitalists as rulers, not just the state
11:47:25 <liyang> mikael: yup.
11:47:32 <greenrd> jesse99: I didn't say I want to _level_ the field. I want to reduce inequality, not eliminate it.
11:47:42 <lispy_> IMHO anarchy would not sustain itself and it would evolve (deteriorate?) into something else probably either capitalism or communism
11:47:59 <liyang> tuomov: so I'm a capitalist for owning my own business. Doesn't necessarily make me a ruler.
11:48:07 <tuomov> lispy_: communism is the goal, but other kinds of anarchisms may be possible
11:48:19 <Beelsebob> lispy: I don't think it's possible anyway... there are inevitably lazy people, and they will inevitably break the system
11:48:20 * liyang heads off to BBQ
11:48:28 <Beelsebob> anarchy relies on everyone pulling their weight
11:48:30 <tuomov> liyang: a capitalist by definition gets a living from capital income; by exploiting others' work
11:48:33 <jesse99> well then all the rich will flee your country greenrd
11:48:42 <tuomov> a small business owner is not in such a position usually
11:48:49 <jesse99> rather like the east berliners
11:48:50 <greenrd> jesse99: Quite. Good riddance.
11:48:50 <tuomov> liyang: or from rent and so on
11:48:59 <Beelsebob> jesse: yep, and that'll level the field a bit more ;)
11:49:23 <jesse99> where rich is anyone above the median income :-)
11:49:40 <greenrd> heh
11:49:44 <greenrd> no, not the case
11:49:57 <liyang> tuomov: or profits from services rendered. Where do you draw the line?
11:50:00 <greenrd> Even the US has redistributive taxation - it's called income tax
11:50:16 <greenrd> The difference between the US income tax and the Swedish income tax is only one of degree, not of kind
11:50:31 <Beelsebob> what's the sweedish rate?
11:50:44 <tuomov> liyang: the line is drawn in what property is considered exploitative
11:50:58 <lispy_> taxes are in the US are a waste of my money.  They spend it on absurd things and don't help anyone that really needs the help.
11:51:12 <jesse99> it's a pretty huge step from communism/socialism to progressive income taxes
11:51:13 * Beelsebob wonders if the current cvs version of ghc is broken horribly
11:51:16 <Beelsebob> I get a type error
11:51:22 <tuomov> owning a flat that you don't personally live in, and renting it is exploitative, for example
11:51:37 <tuomov> and so's owning farmland that you can't cultivate yourself, but must hire wage labour
11:51:37 <liyang> tuomov: even if you built said flat yourself?
11:52:19 <tuomov> if there are people in need of a flat, and nobody uses it, yes
11:52:20 <lispy_> liyang: i think the point is that you are hording ownership over more than you "need"
11:52:29 <tuomov> lispy_: exactly
11:52:38 <tuomov> mor ethan you "need" or can use
11:52:50 <Beelsebob> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show
11:52:57 <Beelsebob> anyone met that building ghc?
11:53:04 <lispy_> but, enforcing that would be impossible in practice
11:53:21 <liyang> Well who's going to enforce it? <g>
11:53:30 <Lemmih> Beelsebob: olliej had that problem.
11:53:35 <Beelsebob> liyang: no one... it's anarchy
11:53:38 <Beelsebob> lemmih: today/
11:53:39 <Beelsebob> ?
11:53:47 <Lemmih> Beelsebob: Some days ago.
11:53:53 <Beelsebob> odd... on OS X?
11:53:54 <tuomov> the local community, for example, will see that there's an unused flat and let someone in, break in if necessary
11:54:08 <Beelsebob> because it built cleanly on linux yesterday
11:54:11 <olliej> Beelsebob: yup
11:54:19 <tuomov> there's no police force to guard it for you, because no monopoly of violence (i.e. state) guarantees you any right to own it
11:54:27 <Beelsebob> why would a type error be platform specific though
11:54:36 <olliej> Beelsebob: it the register allocator
11:54:47 <Beelsebob> oh... duh
11:54:48 <olliej> dammit i've forgotten what change was necessary
11:54:58 <Beelsebob> so it's a Mach0 problem?
11:55:06 <shapr> I want a meritocracy.
11:55:19 * lispy_ wants cheese
11:55:24 <olliej> Beelsebob: it's a trivial fix
11:55:25 <shapr> Not that I have any clue how it would work.
11:55:35 <olliej> #if -> #ifdef or something similar
11:55:37 <liyang> but surely the existence of a local community implies some level of hierarchy.
11:55:49 <olliej> i just can't for the life of me remember what it should be
11:55:50 <Beelsebob> okay... I'll go take a stare at the file
11:55:52 <mikael> since there's no reason to build a flat in which you won't live, everyone builds their own flat, right?  or is there such a reason?
11:56:08 <olliej> it's in registeralloc or some such
11:56:26 <shapr> Exchange is always interesting, due to unequal distributions in our physical reality.
11:56:28 <lispy_> mikael: maybe you want a nicer flat so you build a new one and abandon the old one
11:56:46 <greenrd> The fundamental problem with capitalism isn't money, trade, "exploitation", or the profit motive.
11:56:56 <shapr> I think it's sort of odd that private citizens get to own land.
11:57:06 <greenrd> The fundamental problem with actually-existing capitalism is that some people have too much power: control over too much money.
11:57:22 <tuomov> greenrd: yes
11:57:24 <Beelsebob> ollej: the only obviously related #if I've found is #if defined(powerpc_TARGET_ARCH)
11:57:24 <olliej> Beelsebob: what is on line 145 of RegisterAlloc.hs
11:57:26 <greenrd> That's why there should be a 100% income tax - or maximum income, which is equivalent
11:57:33 <greenrd> er, tax band
11:57:37 <olliej> damn it's not that one
11:57:37 <Beelsebob> that is *g*
11:57:47 <Beelsebob> #ifdef powerpc_TARGT_ARCH?
11:57:59 <Beelsebob> s/GT/GET/
11:58:02 <shapr> How could a 100% income tax work?
11:58:16 <mikael> I don't know how to build a flat though.  Am I bound to live in hand-me-down flats from the construction workers?  I'd like to employ somebody to build me a flat, but apparently that would make me a slave owner
11:58:31 <Beelsebob> shapr: you have a flat moximum income
11:58:38 <greenrd> shapr: No-one would be paid above the limit, because it would be pointless to pay them more than the limit. It would be a maximum income.
11:58:39 <jesse99> every dollar that you make over X goes to the state
11:58:41 <tuomov> liyang: well, in a direct democracy or consensus or whatever policy everyone has a say, so there isn't that sort of absolute hierarchy as in a capitalist workplace, or an army or even in a representative democracy
11:58:47 <olliej> Beelsebob: from memory dcoutts knows
11:59:04 <tuomov> liyang: obviously things need to be very decentralised for a direct democracy to a) work and b) not to become tyrannical
11:59:05 <greenrd> mikael: :)
11:59:06 <shapr> greenrd: But wouldn't that demotivate people like Steve Jobs? That would mean no Pixar for example.
11:59:13 <Beelsebob> chears ollej
11:59:26 <liyang> tuomov: I'll vote for you. Go implement it. :)
11:59:47 <lispy_> i say we live ilke the amish
11:59:48 <tuomov> anarchists don't participate in bourgeous elections :)
12:00:01 <jesse99> more important it would demotivate every startup that evee existed
12:00:04 <mikael> steve jobs is a vicious tyrant who must be suppressed!
12:00:07 <greenrd> hehe
12:00:08 <shapr> Not only that, but some private projects will require more than the maximum income. Look at SpaceShip One by Burt Rutan. I doubt that would work in a max income society.
12:00:11 <Beelsebob> shapr: IIRC Jobs is payed next to nothing by apple
12:00:15 <Beelsebob> $1 IIRC
12:00:23 <Beelsebob> so perhaps not
12:00:24 <greenrd> shapr: Who says that *one* person has to fund a spaceship project?
12:00:44 <liyang> You could group together and form a ... cooperation!
12:00:46 <tuomov> mikael: how you get a flat depends on the form of anarchy. in an individualist anarchy you would buy it, in a communist anarchy people would built it for you... it isn't all set in stone and nobody knows how it will end up
12:00:48 <Beelsebob> greenrd: that would force everything to be designed by commitee
12:00:57 <shapr> Beelsebob: Sure, but he got bought out of Apple the first time, and that's how he was able to fund Pixar as a start-up (and some other companies like NeXT).
12:01:02 <Beelsebob> which just plaiin doesn't work
12:01:30 <shapr> Yes, but once you have cooperation, you'll get the same pattern. There will be private 'Godfather' types who control large blocs of cash.
12:01:53 <Beelsebob> uhhuh
12:01:57 <shapr> Your original point was that some people have too much control of cash.
12:02:02 <greenrd> Beelsebob: Funding is orthogonal to design. You can have a project that's funded by 100 people but designed by 1.
12:02:17 <greenrd> Beelsebob: Of course the designer would have to justify themselves - and why shouldn't they?
12:02:20 <Beelsebob> greenrd: who asseses what's a good design?
12:02:50 <tuomov> the community for whom the building is being built for?
12:03:08 <Beelsebob> but then they're going to want to have an interest in how it is designed
12:03:13 <olliej> Beelsebob: found it
12:03:13 <Beelsebob> ... design by commitee
12:03:25 <Beelsebob> :)
12:03:28 <olliej> ghc/includes/MachRegs.h:460
12:03:29 <lispy_> we cannot live in communities without warring
12:03:34 <shapr> Man, look what the 'community' built in the 1970s... ugliest architecture yet.
12:03:39 <olliej> #ifdef darwin_REGS
12:03:41 <olliej> should be
12:03:49 <olliej> #if darwin_REGS
12:03:58 <mikael> tuomov, from whom would I buy a flat in an individualist anarchy?  why would the community build me a flat in a communist anarchy?
12:04:04 <greenrd> shapr: Who do you mean by "community"?
12:04:08 <mikael> I'm just trying to understand how this works
12:04:17 <shapr> Just talking about community design.
12:04:20 <lispy_> we need, security and stability.  These lead to hoarding tendencies
12:04:36 <Beelsebob> MachRegs.h:460:    \tr{0}--\tr{12} are caller-save registers.
12:04:44 <Beelsebob> comment
12:04:50 <olliej> gah
12:04:51 <shapr> Which is silly, security is best achieved through profitable reinvestments.
12:05:08 <Beelsebob> 467 is #if powerpc_REGS
12:05:12 <tuomov> mikael: just like you would now, except you would get interest-free loans (interest is robbery, you see) and so on.. I'm not an expert on individualist anarchism, though
12:05:13 <greenrd> lispy_: That's true of course. But a man need's sex, which often leads to unfaithful tendencies.. that doesn't mean that being unfaithful is a great moral good.
12:05:33 <Beelsebob> oh... ollej: 480?
12:05:42 <lispy_> greenrd: no, it means it going to happen in practice and with some frequency
12:05:44 <olliej> dammit
12:05:45 <olliej> yes
12:05:48 <olliej> sorry my bad :)
12:05:53 <Beelsebob> already changed :(
12:05:54 <Beelsebob> #if darwin_REGS
12:06:08 <olliej> nuts
12:06:32 <shapr> mikael: Hey, any progress on that Haskell wm?
12:06:37 <greenrd> lispy_: Yes but I'm not saying hoarding is per se bad. I'm saying a world where one man owns the equivalent of 100,000,000 chickens while another man owns one, is unjust.
12:06:41 <Beelsebob> indeed
12:06:52 <shapr> greenrd: What if that man saved the human race?
12:07:24 <lispy_> shapr: i have yet to meet or hear of a person that has done that
12:07:24 <tuomov> I think all "unjust" "right" etc. argument are BS
12:07:28 <SamB> shapr: by harnessing the chickens to a nearby asteroid?
12:07:29 <shapr> Yeah, but I'm just saying...
12:07:33 <shapr> SamB: yes!
12:07:47 <shapr> SamB: And using the collective chicken power to push the asteroid into the enemy alien fleet!
12:07:54 <greenrd> shapr: OK, special exception. But I'm not aware of any capitalists (or anyone for that matter) who has saved the human race, so that's academic.
12:07:56 * shapr adds SamB as a coauthor.
12:07:59 <jesse99> there have been huge medical advances like antibiotics or the cure for polio
12:08:11 <tuomov> what sucks when one owns 100 000 000 checkens and another only 1, is that to eat the other person has to sell his labour power to the other, and submit to his will
12:08:13 <lispy_> shapr: we need a movie version of this chicken weilding savior
12:08:17 <greenrd> tuomov: Morality is borgeious huh?
12:08:17 <jesse99> why shouldnt a startup that develops a cure for a major disease reap very large rewards?
12:08:25 <greenrd> tuomov: Is free speech borgeious too?
12:08:25 <tuomov> greenrd: morality is subjective, and thus BS
12:08:40 <shapr> Yeah, many people would pay a lot for a cure for cancer.
12:08:47 <jesse99> certainly such rewards are large motivating factors
12:09:09 <shapr> Definitely. I'm self-employed partially because I want to be in a startup at some point.
12:09:22 <tuomov> jesse99: why should such a startup be able to stop others from manufacturing the cure as well?
12:09:27 <SamB> shapr: up-front or upon delivery?
12:09:38 <SamB> (Re: cure for cancer)
12:09:40 <shapr> SamB: Both, actually.
12:09:46 <mikael> shapr: sadly, no -- I found that the X11 binding lacked most of the window managing stuff, and I had some unmotivating problems with GreenCard, IIRC.  I may resume that project later, though.  now I'm swamped with school work :-)
12:09:48 <SamB> oh, right
12:10:18 <lispy_> tuomov: okay here we go.  So, in true capitialism they wouldn't be able to stop the other.  But in, say US capitialism, we allow for monopolies
12:10:20 <jesse99> maybe they shouldbt be able to stop them, but it doesnt seem unreasonable that they can charge a reasonable fee to license it
12:10:57 <tuomov> lispy_: many right-libertarians indeed don't believe in "intellectual property", but they still support private tyrannies in the form of physical property
12:11:08 <xerox> Hey, /me and dcoutts are doing an exciting thing - we're trying out collaborative text editing (with gobby) for hacking on Haskell code: http://haskell.galois.com/~paolo/pair-230805-2109.png  This is _exciting_ !!!
12:11:23 * xerox said exciting too many times :-P
12:11:33 <lispy_> gobby?
12:11:44 <lispy_> dobby?
12:11:50 <xerox> @google gobby collaborative text editor
12:11:51 <lambdabot> http://ddaa.net/blog/gobby-first-look
12:11:52 <SamB> physical property is based on actual physical reality
12:11:56 <xerox> Nah..
12:11:57 <mikael> tuomov: there's no need to use moral arguments here; it's fact that if they can't get exclusivity rights, there's simply no "incentive" (aka reason) to mass-produce their product, (unless you take into account wealthy philantropists)
12:11:59 * lispy_ doesn't like to edit with house elves
12:12:08 <xerox> lispy_: check this screenshot out http://haskell.galois.com/~paolo/pair-230805-2109.png
12:12:10 <SamB> intellectual property is based on childish behaviour...
12:12:37 <Itkovian> evening
12:12:40 <ustenzel> tuomov: here in eastern germany it was impossible to make a buck off renting a flat for about 40 years.
12:12:47 * Itkovian plugs in power adaptor
12:12:50 <xerox> http://gobby.0x539.de/
12:12:54 <tuomov> SamB: but private physical property beyond personal possession is a tool of coercion
12:13:03 <SamB> tuomov: oh, right, true
12:13:08 <mwc> I think the problem with intellectual property is that we try to treat it as an actual property
12:13:16 <mwc> THe intrinsic value of IP is absolutely zero
12:13:16 <ustenzel> tuomov: no one repaired or built flats.  can you imagine the general state of disrepair after 40 years?
12:13:26 <mwc> The application of IP is what's valuable
12:13:28 <shapr> xerox: Wow cool!
12:13:33 <ustenzel> tuomov: if you know a solution to that, I'd like to see it.
12:13:48 <xerox> shapr: indeed, you should try it, it IS so COOL
12:14:04 <Lunar^> xerox: seems like :)
12:14:05 <dcoutts> shapr, indeed, I'm quite impressed
12:14:14 <tuomov> ustenzel: eastern germany wasn't even near an anarchy.. it was just a state capitalism
12:14:16 * shapr does apt-get install gobby
12:14:21 <tuomov> the realities are very different
12:14:28 <xerox> Working in realtime on the same piece of code is astonishing
12:14:29 <mikael> I'm not interested in discussing with someone who repeatedly calls me a coercive slave owner, so I'm withdrawing
12:14:37 <tuomov> if one thing happens in one system, it doesn't imply that it happens in another
12:14:39 <lispy_> xerox: it's certainly cool looking, but also a pain to install on osx me thinks
12:14:39 <xerox> You make a little error, the other person fixes, writes, and there is a chat
12:14:55 <ustenzel> tuomov: i know what it was, I've been there.  central control over 17 million people doesn't work out.
12:15:07 <xerox> lispy_: I think you should try go install it, and once built, maybe make a .dmg for others!  It's worth it :-)
12:15:19 <tuomov> ustenzel: indeed it doesn't. did I ever support such a thing? I won't the exact opposite
12:15:25 * lispy_ has no clue how to make dmgs
12:15:25 <ustenzel> tuomov: the point stays, though: no incentive to build or repair a flat.
12:15:27 <tuomov> s/won/wan/
12:15:38 <xerox> lispy_: I'm asking ever OS X user I know this thing, sorry :-)
12:15:48 <Beelsebob> ollej: figured it out
12:16:04 <tuomov> ustenzel: that depends on if it costs you a lot to do so
12:16:09 <jesse99> tuomov wants some fantasy where there is no state but things somehow work out so that everyone plays nice and never try to grab too much stuff
12:16:20 <Beelsebob> the patch submitted for gentoo broke building on OS X
12:16:27 <Beelsebob> had to change back to #ifdef
12:16:49 <ustenzel> tuomov: it does cost.  bricks don't grow on trees, you know.  they also don't work to the building site on their own.
12:16:59 <tuomov> jesse99: no, that's a fantasy. What is needed is that most people don't just sit by and let that happen
12:17:19 <tuomov> people who won't submit to authoritarian control of their lives 8 hours a day and so on
12:17:30 <mikael> yeah, we need more capitalists :-)
12:18:05 <shapr> Pooh, darcs still depends on libgmp3 instead of libgmp3c2
12:18:09 <olliej> what's the flag to stop ghc from doing up to date checks?
12:18:12 <jesse99> no country has come close to such an ideal (since we started agriculture anyway) and history shows that people won't play always play nice
12:18:22 <lispy_> tuomov: if i tried to not sit by and let it happen i would starve.  no thanks.
12:18:23 <tuomov> that everyone were capitalist is unlikely to happen.. even in a sci-fi future where robots do almost everything
12:18:51 <tuomov> lispy_: that's the problem. working class people are busy to earn a living
12:19:08 <Lemmih> olliej: -no-recomp?
12:19:16 <tuomov> while some barely make one
12:19:32 <olliej> Lemmih: cheers
12:21:15 <lispy_> i think our government could more easily change it's spending habits
12:21:24 <xerox> shapr: yes :-(
12:22:37 <shapr> I need to use darcs to make money, I can't install gobby for the moment.
12:22:52 <xerox> Uhm, why?
12:22:56 <lispy_> xerox: configure doesn't create a make file
12:23:04 <xerox> lispy_: err?
12:23:05 <lispy_> xerox: libnet6 won't install without one :(
12:23:20 <lispy_> configure && make => make says no makefile found
12:23:39 <xerox> Could you paste the sh configure output on rafb.net or something?
12:23:43 <shapr> I'd have to remove darcs to install gobby.
12:24:02 <xerox> Too bad!!
12:24:14 <lispy_> xerox: maybe later, i need to afk for a bit
12:25:10 <xerox> shapr: maybe you could compile it from sources.
12:25:31 <xerox> shapr: it's worth it!
12:25:56 <mwc> Who came up with the idea of typeclasses?
12:27:20 <SamB> mwc: have you looked at the paper?
12:27:25 <ibid> i think the first one was committee-designed
12:27:42 <SamB> @google type classes ad hoc overloading less ad hoc
12:27:44 <lambdabot> http://homepages.feis.herts.ac.uk/~msc_fl/fl-node60.html
12:27:45 <ibid> but there have been many successive improvements by indiidual researches
12:27:52 <ibid> +v
12:27:54 <SamB> @google type classes less ad hoc
12:27:55 <lambdabot> http://citeseer.ist.psu.edu/wadler88how.html
12:29:40 <ibid> (remember to check the acknowledgements in that paper if you want to properly attribute the idea:)
12:29:48 <beelsebob_> gyah... what the hell is up with hat-detect
12:30:21 <mikael> shapr: maybe you can install darcs from testing?
12:30:24 <FrederikEaton> hey is it possible using generics to have a function say (a b) -> (a c) which switches the parameter in a datatype for something else? like i want to transform "Node Var" to "Node Identity" in the 'solve' part of my constraint solver where Node could just be something like data Node a = Node (a String)
12:30:52 <ibid> why do you need generics for that?
12:31:23 <FrederikEaton> i'm using generics already, i don't want to make the user define a whole bunch of classes
12:31:54 <greenrd> What would such a function do?
12:31:59 <FrederikEaton> i'm writing a generics version of Claessen's recent "Typed Logical Variables in Haskell"
12:32:32 <greenrd> I mean how would it work exactly? Forgetting type issues for a moment
12:33:34 <FrederikEaton> well the variables are bound to Maybe values which must be 'Just _' in valid solutions, so you go through the valid solutions, traverse the structures and look up the variable values and replace variables with Identity objects of the corresponding value
12:33:59 <FrederikEaton> so this way the user has something which is statically guaranteed to have all the values filled in
12:34:05 <greenrd> ah I see!
12:34:35 <greenrd> In Java you would probably use the visitor pattern for this kind of task
12:34:46 <FrederikEaton> java shmava
12:34:52 <greenrd> heh
12:35:05 <FrederikEaton> i think there is already a generics version of this but it is on some website you have to pay to access i forget the name
12:35:18 <ski> Node :: (* -> *) -> *
12:35:23 <FrederikEaton> acm or something
12:35:41 <ski> FrederikEaton : i think you need functors from (* -> *) to *
12:36:00 <ski> (the ordinary Functor class provides functors from * to *)
12:36:05 <ski> hm
12:36:09 <FrederikEaton> ski: that's the kind of the Node type i defined, yes
12:36:36 * ski tries to figure out how to code such functors in haskell
12:37:10 <greenrd> FrederikEaton: You want to find all mentions of a type in a data structure and map them through some function? Is that the basic idea?
12:38:12 <shapr> Igloo: Gee, I totally agree with you about moving code out of C and into Haskell.
12:38:58 <FrederikEaton> greenrd: not really, for instance Var could show up somewhere, not as a parameter of the datatype, and it shouldn't be mapped in that case
12:39:07 <FrederikEaton> greenrd: understand?
12:39:08 <TheHunter> FrederikEaton, i suppose you don't wanna use unsafeCoerce#, but there's an example that does something similar on the paste page. Very evil.
12:39:09 <shapr> At a very minimum, the Haskell code should be the specification, and the C code the optimization.
12:40:45 <FrederikEaton> TheHunter: here? http://www.haskell.org/hawiki/HaskellIrcPastePage
12:41:10 <TheHunter> yes, just search for unsafeCoerce#.
12:41:11 <FrederikEaton> oh i see
12:41:19 <ski> FrederikEaton : hmm, maybe something along this line would work ?    class FooFunctor n where foomap :: forall f g :: * -> *. (forall a. f a -> g a) -> n f -> n g    instance FooFunctor Node where foomap fun (Node fStr) = Node (fun fStr)
12:42:32 <ski> (FrederikEaton : you can skip the "forall f g :: * -> *. " if you want ..)
12:42:57 <TheHunter> i would even call that FunctorFunctor.
12:43:44 <ski> FrederikEaton : possibly, in your case you don't actually need to have a class .. if so, you can specialize foomap to Node
12:44:39 <ski> TheHunter : hmm .. somehow that suggests f and g should be in class Functor, .. but that doesn't seem to be needed in this case ..
12:45:16 <TheHunter> oh, ok.
12:45:18 * FrederikEaton needs to eat breakfast before any of this will make sense
12:45:57 <FrederikEaton> if at all...
12:47:35 <ski> (TheHunter : but i dunno .. there's something behind your idea i think .. will have to try figuring out how it fits in)
12:47:41 * ski goes to eat dinner
12:48:21 <TheHunter> hmm, that type class paper uses the notation |memsq :: Eq a, Num a => [a] -> a -> Bool|, i wonder why that isn't valid haskell anymore.
12:49:02 <TheHunter> ski, the idea is that if f and g are functors, something of type (forall a. f a -> g a) is a natural transformation, ie. a morphism of functors.
12:53:33 <TheHunter> so ffmap :: forall f g. (Functor f, Functor g) ::
12:54:01 <TheHunter> err, => ...
12:59:52 <ski> TheHunter : yes
13:00:04 <ski> that's what i thought
13:00:17 <ski> so i wondered why this example didn't seem to force that
13:02:01 <ski> TheHunter : btw, if you call the class FunctorFunctor when the argument has kind (* -> *) -> *, what would you call the class when the argument has kind (* -> *) -> (* -> *) ? :)
13:02:54 <TheHunter> oh, you're right, i should think before I type. I would of corse call the latter FunctorFunctor.
13:05:36 * ski sometimes want subkinds of *, for those types in e.g. class Eq  (or Ord)
13:08:45 <FrederikEaton> objects are values, categories are types, functors are Functors? or are arrows values? what is the mapping between category theory and type theory?
13:10:18 <FrederikEaton> i'm confused by TheHunter's natural transformation type because in category theory a natural transformation takes an object c to an arrow between images Sc and Tc under functors S and T
13:10:23 <greenrd> ski: In Omega you can have user-defined kinds, and in Epigram... well, epigram is just weird, but you can probably do something like that
13:10:42 <TheHunter> in the category 'Haskell', types are the objects and functions morphisms. Functors are a special class of endofunctors in this category.
13:11:59 <TheHunter> a natural transformation between two such endofunctors f and g is something of type (forall a. f a -> g a). Every such function is natural because of parametrizity, iirc.
13:12:15 <TheHunter> *parametricity
13:12:51 <FrederikEaton> huh? why are you talking about the category 'Haskell'? we need more than one category to have a functor or a natural transformation, no?
13:13:41 <TheHunter> we are talking about functors from the category 'Haskell' into the category 'Haskell'.
13:14:32 <FrederikEaton> do you have a reference for this?
13:15:33 <TheHunter> nope, sorry.
13:16:04 <FrederikEaton> i don't understand how you're looking at things
13:16:11 <TheHunter> @google "category haskell" functor
13:16:12 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-June/006322.html
13:19:44 <FrederikEaton> TheHunter: oh, i see now. thanks!
13:22:32 <ski> "But every parametrically polymorphic function is a natural transformation, though the converse fails: not every natural transformation is parametrically polymorphic."
13:22:44 <ski> ah .. i've wondered about that for some time
13:26:33 <TheHunter> is that really true?
13:26:45 <ski> which part ?
13:27:00 <ski> (first or second ?)
13:27:04 <TheHunter> the first.
13:27:39 <ski> iavor complicates it in http://www.haskell.org/pipermail/haskell-cafe/2004-July/006351.html :)
13:27:43 <TheHunter> it already needs some creativity for |(r -> Int) -> (r -> Bool)|
13:27:48 <ski> yes
13:28:08 <ski> higher-order seems to complexify it
13:28:44 <ski> (TheHunter : anyway, what i had wondered about was the second part)
13:29:57 <kosmikus> ski: I think it's the "parametrically" where the second part fails
13:31:59 <TheHunter> alright, counterexample anyone?
13:32:25 <ski> (kosmikus : indeed, that's what i wondered about)
13:33:04 <ski> (same post) "In particular, some natural transformations are generic functions (polytypic), and their components (instantiations at a type) are not all instances of a single algorithm."
13:33:43 <kosmikus> yes, that's what I'd think, too
13:35:09 <FrederikEaton> but a functor needs to apply to types and functions, so wouldn't one need a typeclass?
13:35:45 <ski> FrederikEaton : for what ?
13:36:26 <FrederikEaton> to define how it acts on functions
13:36:41 <FrederikEaton> or
13:37:02 <FrederikEaton> you're saying that the type signature defines a map of types, and the value defines a map of functions
13:38:03 <FrederikEaton> am i not getting it
13:41:21 <ski> the functor needs to apply to types, yes that's the type constructor
13:41:44 <ski> in 'instance Functor Maybe',  'Maybe' applies to types
13:41:56 <xerox> Collaborative editing is too much fun.
13:42:18 <ski> the functor needs to apply to functions/morphisms, yes that's the class member, 'fmap'
13:42:44 <ski> 'fmap :: forall a b. (a -> b) -> (Maybe a -> Maybe b)'  in the case of Maybe
13:43:02 <ski> FrederikEaton : are you getting it ?
13:43:18 <xerox> It's like enhanced IRC.  You see, if you were in such a session, the code you're pasting could have gone in a "semipermanent" buffer you both see :-)
13:43:30 * ski smiles
13:44:09 <FrederikEaton> i thought we were talking about iavor's comment "actually i think that is a good approximation" http://www.haskell.org/pipermail/haskell-cafe/2004-June/006324.html
13:44:17 <FrederikEaton> i disagree with him
13:44:54 <FrederikEaton> for instacne, maybeToList does not include the 'fmap' definitions of Maybe and []
13:45:00 <FrederikEaton> nce
13:46:27 <FrederikEaton> or, at least i disagreed with him but maybe i'm wrong
13:46:40 <ski> FrederikEaton : sorry, thought you were asking about relation between functors in category theory, and Functor class in haskell
13:47:10 <TheHunter> iavor is right, frank is wrong.
13:47:31 <FrederikEaton> TheHunter: man, why are you so much quicker than me :)
13:48:11 <TheHunter> counterexamples are either my |(r -> Int) -> (r -> Bool)| or iavor's fix thing.
13:49:08 <ski> hm, are there counterexamples that doesn't rely on contravariant occurances ?
13:49:12 <FrederikEaton> hmm? i was just going to say that a natural transformation only has to specify a map between functors *at* each object image which is consistent with the 'fmap' definition; there is no "mapping of fmap" so-to-speak so a typeclass is not needed
13:49:28 <FrederikEaton> i don't understand the counterexamples
13:51:42 <TheHunter> ski, probably not. But that doesn't make a statement like "every parametrically polymorphic function is a natural
13:51:42 <TheHunter> transformation" true.
13:52:17 <FrederikEaton> i don't understand what every parametrically polymorphic function would be a natural transformation of. what would the fmap definitions be?
13:53:01 <TheHunter> the "free theorem" of that type.
13:53:04 <ski> FrederikEaton : iiuyc .. one can of course just define mapMaybe :: (a -> b) -> (Maybe a -> Maybe b) .. mapList, etc ..  but having a central definition of a class, and an overloaded fmap allows e.g. order generic code
13:54:07 <ski> TheHunter : indeed  (though it seems to be easy to forget :)
13:54:33 <FrederikEaton> ski: what are you responding to? my statement that a typeclass is not needed to define a natural transformation?
13:55:06 <reppie[^_^]> i think italy will win the world cup.
13:56:21 <jyp> don't make me laugh, they ended last again at the tournament.
13:56:22 <jyp> :p
13:56:25 <shapr> reppie[^_^]: Do you think speculative evaluation is an important research topic in functional programming?
13:57:29 <reppie[^_^]> well, shapr
13:57:51 <reppie[^_^]> i'm not really an expert in research
13:58:58 <shapr> Neither am I.. but I do wonder what the important questions are... Have you had any difficulties with functional programming?
13:59:26 * Korollary fears shapr
13:59:33 <shapr> I wish Haskell had more libraries. I can't think of anything else off the top of my head.
13:59:37 <shapr> Korollary: What for?
14:00:05 * shapr gets all fearsome.
14:00:27 <Korollary> shapr: The question sounded a bit like the ones tossed in by human resources personnel, e.g. "What is your greatest strength/weakness ?"
14:01:04 <Korollary> "was there ever a time when you made a big mistake ? How did you deal with it ?"
14:01:54 <shapr> Actually, I regularly ask people that question. I'm trying to figure out what people have difficulties with, and then I see if I can do anything to improve things.
14:02:43 * TheHunter wouldn't be surprised if every natural transformation between two Haskell functors were indeed parametrically polymorphic.
14:03:15 <shapr> Korollary: But I promise to ask you that question if you ever interview for a job at my company.
14:03:59 <Korollary> shapr enterprises: Software Fusion Engineer - 5+ years with Haskell on Windows Vista
14:05:03 <shapr> My company was formerly called "Tenacious Software" but all the various state agencies misspelled it differently, so I had to do the boring thing and give it my own name.
14:05:20 <Korollary> heh
14:06:14 <shapr> Korollary: So, have you had any difficulties with functional programming?
14:06:26 <Korollary> well, haskell probably has a much larger library than what c++ had some years ago. It's just that people are nowadays spoiled with boatloads of free code
14:08:44 <ski> FrederikEaton : (got distracted) hmm, i think i misinterpreted your "mapping fmap" .. what did you mean by that ?
14:11:34 <FrederikEaton> justifying iavor's comment http://www.haskell.org/pipermail/haskell-cafe/2004-June/006324.html
14:11:44 <Korollary> shapr: and the bigger obstacle is convincing people to drop OO. They believe in it and they think they are competent and more efficient with it. They'd like to see some amazing results even to start doubting that belief.
14:12:51 <FrederikEaton> ski: vs. what Bromage said: http://www.haskell.org/pipermail/haskell-cafe/2004-June/006322.html
14:12:55 <humasect> how are IO actions collected with map on a non-IO list ?
14:13:42 <TheHunter> ski, kosmikus, are you aware of any counterexamples?
14:14:23 <humasect> vals <- map (\k -> (action :: String -> IO a) k) (list :: [String])
14:14:41 <TheHunter> @type mapM
14:14:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
14:14:56 <xerox> @index bracket
14:14:56 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.
14:14:56 <lambdabot> Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
14:14:57 <humasect> thank you =)
14:15:05 <TheHunter> so mapM instead of map would work.
14:15:10 <humasect> kk
14:16:16 <adept> Korollary: that obstacle is quite easy to shake (at least) by showing people some real OO, like in CLOS or Smalltalk (instead of C++/Java horror which is usually called OO nowadays)
14:17:08 <xerox> @index runReaderT
14:17:09 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
14:19:08 <FrederikEaton> ski: not that a natural transformation class wouldn't be useful, but you don't need one to specify the transformation completely
14:20:20 <kosmikus> TheHunter: my CT is a bit rusty, but I still don't see anything that would enforce *parametric* polymorphism
14:23:26 <reppie[^_^]> shapr yeah, it was not easy to learn
14:23:35 <shapr> reppie[^_^]: Why? What would you have changed?
14:24:01 <reppie[^_^]> because it requires brain rewiring
14:24:09 <reppie[^_^]> especially if you're used to C etc
14:24:13 <shapr> Yeah, that's true.
14:25:37 <TheHunter> kosmikus, neither do I, but I also don't see an obvious polytypic function that is a natural transformation (of course my understanding of generic functions is not that good).
14:25:50 <ski> (TheHunter : does polytypic functions count ?)
14:25:56 <shapr> I think that is the biggest obstacle in the way of popular usage of Haskell. Most people don't want to invest the time to see if the paradigm shift is worth it to them.
14:26:40 <TheHunter> ski, i don't know, what's the difference between polytypic and generic?
14:27:11 <ski> FrederikEaton : i'm not sure what a natural transformation class would be good for ..
14:27:47 <FrederikEaton> ski: just abstraction
14:28:04 <ski> FrederikEaton : of what ?
14:28:56 <FrederikEaton> ski: dunno. cleaner namespace, for one
14:28:58 <ski> TheHunter : not sure :)
14:29:40 <ski> FrederikEaton : i don't see examples of what would be abstracted by such a class
14:29:55 <kosmikus> TheHunter: there's no difference between polytypic and generic in the context of Haskell
14:30:16 <TheHunter> ah, thanks.
14:30:28 <kosmikus> TheHunter: yes, I also don't see an obvious example currently, I promise I'll look at the definition of a NT again tomorrow, and see if I can come up with one
14:31:08 <TheHunter> cool, thanks.
14:32:09 * ski can't think clearly on it atm
14:32:38 <kosmikus> or, so what about a function from [] to (K Bool), yielding True on a [()], and Falso on a [t] for all t /= () ...
14:33:30 * boegel|home is back from a long weekend full of fun
14:33:33 <kosmikus> no, not good enough
14:33:42 <shapr> boegel|home: what happened?
14:34:05 <TheHunter> that was my first thought, too.
14:34:33 <boegel|home> shapr:  I got tied up naked to a statue in the center of town, it was fun ! :p
14:34:43 <shapr> !!!
14:35:24 <boegel|home> nah, we went to a big tropical swim thing, Movie Park in Germany, and a safari park nearby Luik
14:35:48 <boegel|home> it was great fun :)
14:36:08 <boegel|home> I promised my gf to go to Movie Park sometime, but she beat me to it :)
14:36:16 <shapr> Nifty!
14:36:52 <boegel|home> anything new in here ?
14:39:54 <kosmikus> TheHunter: then what about the equality function from "F a = (a,a)" to "K Bool" ?
14:40:19 <boegel|home> apparently not :) anyways, I'm off the bed, since I'm extremely tired
14:40:34 <boegel|home> g'night everyone
14:46:56 <TheHunter> hmm, something along those lines might work, thanks.
14:48:04 * TheHunter realizes he's not sure what parametrically polymorphic acutally means.
14:48:32 <TheHunter> in particular, if undecidable functions can be parametrically polymorphic.
14:50:50 <ski> hm .. undecidable functions ?
14:51:27 <TheHunter> like generic equality..
14:51:28 <kosmikus> I would have assumed you mean parametrically polymorphic in the sense of Haskell ...
14:52:04 <kosmikus> just define generic equality to be "const2 False" on any criticial type, and it's not undecidable
14:52:30 <kosmikus> ah, but then of course, it's no longer a NT
15:00:08 <Beelsebob> evening unicycling rocks
15:09:42 <TheHunter> kosmikus, i'm accepting that as a counterexample. After all, even if we had a sufficiently powerful undecidable primitive operation, we couldn't define parametric equality.
15:10:07 <kosmikus> TheHunter: I'm not sure yet, I'll think about the issue again tomorrow
15:10:56 <kosmikus> I think what I said isn't a natural transformation either, because you can map two different things to two equal things ...
15:11:26 <TheHunter> oh, good point.
15:28:21 <Micket> uhm, a rather nooby question here guys, but i really cant figure out how to use do properly, as well as anything that involves IO (more or less)
15:28:32 <Micket> this is what i tried to do, http://rafb.net/paste/results/e38XDE83.html
15:29:18 <Micket> bu then i get the compilation error,     Couldn't match `()' against `Game'
15:29:52 <tuomov> gameLoop should have type Game -> IO ()
15:31:09 <Beelsebob> @index readFile
15:31:10 <lambdabot> System.IO, Prelude
15:31:19 <Beelsebob> @type System.IO.readFile
15:31:20 <lambdabot> FilePath -> IO String
15:40:04 <beelsebob_> hehe, I love it when functions come out as neat as this
15:40:18 <ski> (Micket,tuomov : actually 'gameLoop :: Game -> IO a' would work fine here, too .. as long as 'gameLoop' can't return)
15:40:51 <Korollary> groov
15:41:10 <ski> Micket : btw, why "gameLoop $ g'" ?   you can skip that '$'
15:42:50 <beelsebob_> getFileRange s e = unlines . map ("  "++) . drop s . take e . lines . unsafePerformIO . readFile
15:48:17 <Micket> oh, yea, that $ is just leftovers from changing stuff back and forth :)
15:59:59 <Lemmih> You can't specify instances in boot files?
16:03:20 <beelsebob_> ?
16:03:24 <beelsebob_> boot files?
16:04:44 <Lemmih> *-boot files.
16:06:53 <beelsebob_> @paste ... m'kay... stop being dumb hat-delta
16:06:54 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:07:32 <beelsebob_> the top few lines are the expressions it knows to evaluate correctly, the last one is the question it just asked me
16:33:49 <stefanw> pxBr0l
16:33:59 <stefanw> soryy
16:34:14 <Korollary> I just need the username now
16:34:22 * Pseudonym h4X0rz stefanw's machine
16:35:05 <Micket> oooh my text-adventure game is turning out really good ;)
16:35:28 <Korollary> from a technical point of view or from an entertainment point of view ?
16:35:58 <Pseudonym> I do not see an entertainment point of view here.
16:36:09 * Korollary rewrites Leisure Suit Larry series in haskell
16:37:03 <Micket> Well, calling it entertainment would be streaching it a bit.
16:37:23 <Micket> And technical, well for one who started learning haskell a week ago like me, perhaps :)
16:38:15 <Korollary> I've had fun with text adventures
16:38:27 <Korollary> then the whole genre disappeared
16:39:22 <Pseudonym> It still exists, kind of.
16:39:27 <Pseudonym> The PC term is "interactive fiction".
16:40:16 <Korollary> why is text-adventure PI ?
16:40:26 <Pseudonym> Don't know.
16:40:47 * ski wonders what PC and PI means, here
16:40:56 <Korollary> interactive fiction sounds more, umm, weaselword-ish
16:41:42 <Korollary> pc = politically correct
16:41:47 <ski> aha
16:43:04 <wagle> maybe because "interactive fiction" doesnt assume "text"?
16:43:13 <Ulysses> text adventures would be a lot easier if they had tab completion
16:43:37 <wagle> hmm..  a<tab>.... b<tab> ...
16:43:47 <Korollary> well, interactive fiction is such a broad term that it could even mean Tomb Raider
16:45:13 <wagle> also mindset..  mud was descrfibed as "text-based virtual reality"..  i think the desire is for the focus to be on the user experience, and not on what medium was used
16:45:21 <wagle> (described)
17:16:37 * beelsebob_ yawns
17:17:27 * beelsebob_ wonders why all http requests seem to be dying
17:17:38 <beelsebob_> my net connection seems to be buggered today
17:27:57 <Micket> http://rafb.net/paste/results/EVspPv95.html
17:28:04 <Micket> Ok, it seems i cant really do this,
17:28:20 <Micket> Any tips? :)
17:28:27 <Micket> for that last row
17:28:56 <Micket> I need to check if gStatus == True, if so continue playing,
17:30:05 <beelsebob_> why not just use the interact function?
17:30:11 <ski> what is the problem ?
17:30:26 <beelsebob_> ski: it'll be a non-expression on last line of do
17:30:54 <ski> which non-expression ?
17:31:05 <beelsebob_> I've never got that either
17:31:13 <beelsebob_> but ghc bitches if the last thing is an if
17:31:30 <beelsebob_> in fact ifs in dos generally cause a lot of havoc
17:34:13 <ski> @type let loop = do {s <- getLine; if null s then return () else loop} in loop
17:34:14 <lambdabot> IO ()
17:34:29 <beelsebob_> :/
17:34:39 * ski still don't see the problem
17:34:46 <ski> is there some error message ?
17:35:04 <beelsebob_> gameloop g = interact (genPrompts g)
17:35:09 <beelsebob_> seems to be what you want
17:35:49 <Micket> Actually, it does give my an error when compiling, but it started complaining when i tried to launch main
17:37:07 <Micket> hmm, wait, now it seems to complain even though its without the if statement,
17:37:17 <Micket> i gotta check into whats going on here
17:37:44 <xerox> Goodnight.
17:38:33 <Lemmih> 'night, xerox.
17:38:57 <beelsebob_> micket: why not just use interact?
17:40:02 <Micket> mm, well, i dunno, i might, i just had some other file bugging out now :)
17:40:16 <Micket> But it seems i just had to recompile it
17:40:53 <Micket> one moment, (im a bit slow when coding yet)
17:47:22 <Micket> Well, appearantly that if statement does work, and the error.. well i dont know where it came from, but appearantly i fixed it now >_<
17:47:51 <ski> m
17:53:06 <Micket> time to sleep! thanks for the help guys
17:55:53 <reppie[^_^]> http://www.abc.net.au/worldtoday/content/2003/s904609.htm
17:59:24 * Lemmih laughs.
17:59:35 <Beelsebob> the more you want the fitter you are
17:59:39 <Beelsebob> wank*
17:59:52 <Beelsebob> but I guess want would fit too
18:32:31 * kaol got an excuse to do some haskell for a while :-)
18:48:13 <humasect> i tend to get stuck trying to get values out of monads.
18:49:11 <Lemmih> humasect: Have you seen (>>=)?
18:50:32 <humasect> yeah. but if i apply a function that is an IO (), but i need a IO [a] from "inside" of that function
18:50:45 <humasect> monads are a bit like dimensions. i looked at join a little
18:51:38 <Lemmih> (>>=) sounds perfect for that task.
18:55:19 <greenrd> You probably need either >>= or unsafePerformIO. But unsafePerformIO is naughty.
18:55:45 <humasect> hmm.
18:57:08 <Lemmih> If you're ever in doubt whether unsafePerformIO is the right choice then it's definitely not the right choice.
18:58:40 <humasect> i promise to not use unsafePerformIO
18:59:29 <greenrd> heh
19:01:49 <humasect> i think i'm not doing something right.
19:04:49 <greenrd> @paste
19:04:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:05:00 <greenrd> humasect: paste your code there if you want
19:07:47 <humasect> okay, just a moment. i'm tracing where types are coming from, i think that is where i went wrong
19:11:56 <humasect> there is a function that is (Error -> IO a) -> IO a -> IO a - the last expression in the first is a print n which is, i think, "making all of those a's into ()'s"
19:15:58 <humasect> is the most common way to monadify with "do var" ?
19:17:26 <humasect> return, sorry
19:17:34 <humasect> nevermind me. in progress.
19:18:49 <kaol> huh? hugs segfaulted at me.
19:19:17 <humasect> okay i just gained some more brain cells on this.
19:19:46 <kaol> no you didn't. not unless you're an infant.
19:20:06 <humasect> more synapse pathways ?
19:20:21 <Lemmih> stemcell injection?
19:20:24 <humasect> surely an increase in general quantumness
19:20:34 <greenrd> humasect: Yes, if you print, you get an IO () which means everything after it will be a IO foo. Unless you use do notation which sugars away that detail.
19:21:22 <greenrd> well it sugars it away but it doesn't change the type of the function you're creating
19:21:31 <humasect> greenrd: thanks =) if i had the before code i would paste the changes to that URL glorifying my haskell maturity
19:21:46 <greenrd> heh
19:42:49 <Cale> I thought the more recent theory was that you actually do grow new brain cells all your life
19:43:17 * humasect nod
19:44:18 <Cale> (just that the rate is relatively low after infancy)
19:50:35 * humasect prefers to avoid parens/thelikes as much as possible
19:52:39 <FrederikEaton> what I think I need is a "fromConstr1 :: Data1 a => Constr1 -> a b" which can build a value of a unary type constructor
19:54:00 <FrederikEaton> then i could use some sort of gfoldl thing to traverse my data structure, and build it back up again with a different type parameter
19:54:04 <FrederikEaton> but there is no Data1 class
19:54:11 <FrederikEaton> there is just a Typeable1
19:58:14 <FrederikEaton> sort of like how "map f = foldr ((:).f) []"
20:01:21 <Lemmih> dons: ack?
20:05:12 <dons> png
20:05:22 <TheHunter> kosmikus, just one more thought. If we define nat :: forall x. f x -> g x, for, say a=Integer (f, g Functors), the whole polymorphic nat function is uniquely defined, provided that we only allow decidable functions. This is because if b is a retract of a, i.e. there are p: a->b and q: b->a with p . q = id, then we have nat @ b = fmap p . fmap q . (nat @ b) = fmap p . (nat @ a) . fmap q.
20:05:42 <TheHunter> This explains why ad-hoc constructions of polytypic functions usually don't work.
20:08:00 <TheHunter> Unfortunately, I don't have time to investigate that any further today.
20:09:22 <Lemmih> dons: Do you know how slow bytecode is compared to native-code?
20:10:21 <dons> hmm. much slower?
20:10:32 <dons> but faster to compile
20:10:42 <dons> you want a bytecode eval?
20:11:17 <Lemmih> I'm tempted to use the GHC package to compile and run bytecode.
20:12:16 <dons> I want to try this. It should be better for small eval-type fragments that are run once only
20:12:22 <Lemmih> Not depending on a binary GHC would make HSP easier to install (and probably faster).
20:12:49 <dons> if you have ghc packag you can use both compiled and bytecode
20:13:16 <Lemmih> Compiled code without intermediate files?
20:13:36 <dons> oh, no. you still need intermedite (.s at least) files
20:13:48 <Lemmih> I would like to avoid them too (:
20:14:20 <dons> isn't the ghc package much harder to get hold of than ghc itself?
20:14:32 <dons> a total of about 5 people actually have it installed ;)
20:14:58 <Lemmih> You get it when you install GHC from CVS head.
20:15:23 <Lemmih> It's not opt-in anymore.
20:15:37 <dons> really? since when?
20:16:03 <Lemmih> I wonder if GHCi performs any optimizations on the AST before compiling it to bytecode...
20:16:34 <FrederikEaton> what's this about ghc bytecode? is it a new thing?
20:16:37 <dons> I don't see it in my nightly builds, so I don't think it is on by default
20:16:54 <humasect> lemmih: haskell server pages?
20:17:08 <dons> ghci doesn't do any optimisations, iirc
20:17:10 <Lemmih> FrederikEaton: GHCi compiles haskell to bytecode.
20:17:18 <Lemmih> humasect: Yep.
20:17:37 <humasect> interesting. i'm just using WASH now.
20:19:19 <FrederikEaton> humasect: http://ofb.net/~frederik/washng/
20:19:44 <Lemmih> I think you should use HSP instead but perhaps I'm a little biased. (:
20:20:12 <FrederikEaton> wash is better :)
20:20:16 <FrederikEaton> but i've never used HSP
20:20:30 <FrederikEaton> i don't like raw html
20:20:32 <humasect> i recall it needing a seperate server. we've already got a host for this project, so cgi-bin
20:20:56 <humasect> fred: i'm using wash =)
20:21:07 <Lemmih> humasect: It now operates as a FastCGI application.
20:21:18 <humasect> using the wash2hs parser to have embedded html
20:21:25 <humasect> o_o
20:24:12 * Lemmih will try to generating optimized bytecode.
20:25:26 <humasect> fastcgi installed.
20:28:56 <humasect> lemmih: can you show me an example of HSP?
20:36:49 <Lemmih> humasect: http://212.242.49.100/work/hsp/Browse
20:37:31 <Lemmih> That's my development version of HSP so it may go down at any time.
20:38:06 <Lemmih> Hm, I really need to find a permanent home for HSP.
20:38:54 <humasect> it's definately cleaner than WASH.
20:39:01 <Lemmih> (The wiki example is current non-functional)
20:39:16 <humasect> kk
20:39:22 <Lemmih> And way faster too (:
20:40:14 <humasect> hmm. i want to migrate.
20:40:55 <humasect> i'll mail the host and make sure i can add the module into apache (they use plesk, they may be strict)
20:43:05 <Lemmih> HSP currently requires a global installation of GHC so you may need root powers on the box.
20:44:29 <humasect> ah, doh. they sort of seem to be the type to mass-host, i doubt i could get that done.
21:09:00 <Lemmih> Yay. Running the simplifier before generating the bytecode looks relatively simple.
21:12:45 * humasect rubs his eyes at mixing monads
21:37:58 * rt twiddles.
21:38:02 <rt> I'm bored.
21:41:40 <dons> Lemmih, how can I use Cabal's 'haddock' flag to generate haddocks from src with cpp in it?
21:42:21 <dons> or should that just work. hmm.
21:52:45 <FrederikEaton> nothing just works
21:52:49 <FrederikEaton> class GenFMap f where
21:52:50 <FrederikEaton>     gfmap :: (\forall x . a x -> b x) -> f a -> f b
21:54:01 <TheHunter>     gfmap :: (forall x . a x -> b x) -> f a -> f b
21:54:35 <FrederikEaton> shut up
21:54:56 <FrederikEaton> that's "thank you" in fredese
21:56:13 <TheHunter> hehe.
21:57:04 <FrederikEaton> isaac has to learn fredese
22:04:30 <FrederikEaton> so i emailed haskell-cafe about the generics thing, but meanwhile i'll just add GenFMap instances, hopefully that's enough
22:04:31 <lispy_> the only freenode spam i receive is from lilo
22:04:39 * lispy_ finds this ironic
22:05:22 <FrederikEaton> if you read his messages backwards, they are viagra advertisements
22:05:30 <lispy_> haah
22:06:11 <lispy_> figures
22:12:25 <lispy_> is it possible to have a haskell style type system without needing any runtime support?
22:12:38 <lispy_> that is, is the type system fully static
22:15:25 <TheHunter> all type information is discarded at runtime.
22:15:53 <lispy_> okay
22:16:24 <lispy_> but, sometimes you end up with boxed values right?
22:16:31 <TheHunter> type classes are translated to dictionaries.
22:16:49 <lispy_> dictionaries?  like lookup tables?
22:17:08 <TheHunter> yep.
22:17:46 <TheHunter> i'm not sure about the actual implentation in ghc, but all you need are tagged sums.
22:18:11 <lispy_> hmm....not familiar with those, i'll google
22:19:17 <TheHunter> (i'm not even sure that's the right term either)
22:19:30 <lispy_> yeah, google doesn't have much on it
22:20:15 <lispy_> so, i was just wondering if adding the analog of the haskell type system on top of C would require any runtime support
22:20:15 <TheHunter> what i meant is, you only need to save that something is the nth constructor.
22:20:28 <lispy_> hmm....okay
22:22:23 <lispy_> my thoughts went this way, "Hmm...C was really popular for a long time, and still is quite useful.  What could be do to make C easier to use, without changing the runtime semantics."
22:23:27 <lispy_> improving the type system is the obvious way, take C++ for example, although, i think it went the wrong direction and changed too much
22:25:08 <Korollary> lispy_: take a look at ocaml
22:25:28 <lispy_> Korollary: okay
22:34:21 <lispy_> so far it looks like haskell with a cumbersome syntax
22:34:41 <lispy_> using semicolon in lists is evil :)
22:37:30 <Pita> Is there a full-text search engine (lucene) implemented in Haskell?
22:38:45 <Cale> lispy_: one major difference is the way that IO is done, and the fact that it uses strict evaluation
22:39:21 <Cale> Pita: I'm not sure
22:41:38 <Pita> Is using Monads execssively bad?
22:41:41 <Pita> bad style?
22:41:57 <Cale> Pita: not really - which monad?
22:42:07 <Pita> not sure. i am just reading
22:42:08 <Cale> Monads can be very good style
22:42:14 <Pita> i switched to haskell yesterday from lisp
22:42:14 <aleator> I would like to ask a question that I already asked, but this time with example. I've got a lot of mutative IO operators and I feel that I'm coding pascal instead of haskell. How to make it better. See lines 3-8 in http://pastebin.com/348949 .
22:42:26 <Pseudonym> Using monads a lot has the benefit that it future-proofs your code.
22:42:28 <Cale> Putting everything in the IO monad would be considered poor style
22:42:36 <Pseudonym> If you later find that you need to thread something, you can do it.
22:44:47 <Cale> aleator: possibly you could make gaussian and subtract take images and return new images, rather than mutating?
22:45:41 <aleator> Cale: They are rather big images and I'm (perhaps unnecessarily) worried about copying.
22:45:51 <Pita> Where is the simplest tutorial on Monad?
22:45:58 <Pita> If I just want basic imperative style
22:46:53 <Cale> aleator: well, remember that if you're doing things at least somewhat lazily, the copies will never completely be in memory
22:46:58 <Pseudonym> aleator: Have you programmed in C++ a lot?
22:47:50 <aleator> Cale: There is a minor jinx there. gaussians etc. are wrapped c functions :/. So they will be in memory.
22:48:01 <Pseudonym> Aaah.
22:48:13 <aleator> Pseudonym: In my time yes. Though I would not like to admit it.
22:48:13 <Pseudonym> There's your problem.  Your data model isn't idiomatic Haskell. :-)
22:48:31 <Pseudonym> The reason I asked is that there's a C++ idiom of returning "proxy objects".
22:48:53 <Pseudonym> So, for example, when you add two matrices, you don't return a matrix.  You return a proxy object which computes the result matrix on demand.
22:48:55 <aleator> It is not idiomatic anything. idiotic perhaps but..
22:49:46 <Pseudonym> And the reason I bring THAT up, is that I think the most idiomatic Haskell way of doing it is via lazy evaluation, which does pretty much that.
22:50:30 <Pseudonym> But this assumes that the gaussian and difference operations are written in Haskell.
22:51:08 <Korollary> I am not sure if he intended to have a proxy-like behavior. looks to me like he was using x, y, z in the c++ sense of mutable variables.
22:51:54 <Pseudonym> Right.
22:52:09 <Pseudonym> The thing is, if your model is very C underneath, then your code will look very Pascal on top.
22:52:15 <Pseudonym> I think that's inevitable.
22:52:28 <Korollary> he says he's worried about copying. I am guessing that he's trying to force a particular execution order.
22:54:17 <aleator> Nope, The copying worry is because the images are rather large and even simple calculations may have half dozen of them in memory if copied.
22:54:39 <aleator> Thus If I do not copy, I will end up with fixed execution order.
22:54:44 <Pseudonym> It sounds to me like you really need lazy evaluation.
22:55:05 <Pseudonym> Lazy evaluation does copy the images, only it does it transitively.
22:55:14 <Pseudonym> So you only need as much as you need in memory at once.
22:55:28 <Pseudonym> Kind of like what you'd do in a tiled image computing system.
22:58:10 <aleator> Ok. That leaves me with multiple large allocations - but I guess it is cleanest if I just wrap things in foreign ptrs and try to make them enough clean..
22:58:28 <aleator> eh.. pure I mean.
22:58:38 <Cale> aleator: perhaps you could do something like write a datatype which basically encodes the image operations available to you through the library
22:58:43 <Pseudonym> It seems to me that your underlying library MUST have support for doing image computing in a piecemeal way.
22:58:55 <Pseudonym> Otherwise you have much the same problem, only in C.
22:59:22 <Cale> and then write an "apply" which takes operations described in that type and applies them to an actual image in a memory efficient way
22:59:57 <aleator> Yep. But C coding is seemingly handled with tricks such as reusing previous images (like my example)
23:00:23 <aleator> Cale: like lines 14-18 in previous snippet?
23:00:26 <Cale> so you'll want to determine when your images are no longer needed in the course of computing the application
23:00:45 <Cale> aleator: I mean, somewhat like metaprogramming :)
23:01:32 <Cale> you encode the operations in a Haskell type, and write an interpreter for that domain specific language
23:02:01 <Cale> which you can then do tricks like determining that certain operations are being done in sequence and only use so many "registers"
23:02:51 <aleator> Ok.. Somehow I feel this is not the quick&easy solutution I was looking for :)
23:02:54 <Cale> hehe
23:02:55 <Cale> it's not
23:03:07 <aleator> Though I'm tempted.
23:11:02 <aleator> Haskell garbage collector is probably enough smart that I can just wrap things up in foreignptrs and use unsafePerformIO liberally to get a reasonable system..
23:13:09 <lispy_> according to the great PL shoot out, g++ and ocaml are pretty evenly matched in performance
23:13:28 <lispy_> but ocaml programs are usually much shorter to write
23:26:33 <Pseudonym> You're probably better off using unsafeInterleaveIO than unsafePerformIO
23:32:44 <FrederikEaton> has anyone painted with oil before? man is that fun
23:34:13 <aleator> unsafeInterleaveIO? Was that the thing that delays'
23:34:21 <aleator> IO operations until referred?
23:34:56 <Pseudonym> @type unsafeInterleaveIO
23:35:16 <Pseudonym> FrederikEaton: As my wife's art history professor said once, "some of the world's great masters are still wet".
23:35:53 <Pseudonym> unsafeInterleaveIO f = return (unsafePerformIO f)
23:36:00 <Pseudonym> unsafeInterleaveIO :: IO a -> IO a
23:36:10 <Pseudonym> Now what use is this, you may ask.
23:36:23 <aleator> I would, I would.
23:36:24 <Itkovian> meuning
23:36:55 <Pseudonym> Well.
23:37:55 <FrederikEaton> why is there no fmapM?
23:38:02 <Pseudonym> One way this is used is to implement such things as readFile.
23:38:14 <Pseudonym> readFile :: String -> IO String
23:38:23 <Pseudonym> That takes a file name and returns the contents of the file.
23:38:45 <Pseudonym> Which you may think might get pretty expensive.
23:38:49 <Pseudonym> But not necessarily.
23:38:57 <Pseudonym> Not if you return the contents lazily.
23:39:09 <Oejet> Or lazy stream compression with the BZip C-library.  :-)
23:39:42 <Pseudonym> The point here is that you're doing I/O operations lazily.
23:39:51 <Pseudonym> Which I _think_ might be closer to what you want.
23:41:11 <aleator> Interesting. Am I too fixed upon the analogy of getcontents or are you suggesting that I load and operate on images piece-by-pirce?
23:41:37 <ibid> or pierce-by-pierce?
23:41:47 <ibid> what's aleator writing in haskell nowadays? ;)
23:41:51 <Pseudonym> If you did operate on images piece by piece, I think you could exploit Haskell more.
23:41:58 <Pseudonym> By exploiting laziness.
23:42:22 <aleator> ibid: I work in the next room. Feel free to come and see. :)
23:42:44 <ibid> maybe you've not noticed that i'm not there yet ;)
23:43:22 * ibid tries to hit the 1000 bus, which will allow me to arrive around 1030
23:43:39 <aleator> Pseudonym: I see. I feel that you are correct. Though implementation of this is rather tedious.
23:44:13 <aleator> ibid: In short - I'm using haskell as prototyping platform for image processing by wrapping things like opencv and gnuplot..
23:45:21 <ibid> nice
23:46:04 <aleator> I often think of giving up, but I gained confidence when I successfully made 25+ line matlab program into 7 line haskell program. Of which I actually understood the latter.
23:55:12 * boegel awakens
23:56:12 <boegel> cmeme: having trouble ?
23:57:14 <FrederikEaton> Pseudonym: I'm still trying to figure out what that means. the paintings are still wet?
