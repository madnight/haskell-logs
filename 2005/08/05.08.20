00:03:48 <lispy> haha
00:04:11 <lispy> it's my fault, i pattern match for the case where there is nothing to read and then return () ;)
00:04:14 <lispy> geez....
00:05:14 <lispy> that's fun, i just spent a while debuging a feature ;)
00:42:43 <luqui> where can I find simple implementations of all the prelude functions?
00:43:07 <ibid> in the standard prelude
00:43:40 <ibid> (ie. the part of the report that lists the prelude)
00:43:54 <luqui> ah, thanks
00:53:25 <tic_> Do you guys know of a good tutorial for small-/big-step semantics?
01:03:16 <luqui> tic_: elaborate please
01:04:02 <luqui> oh, n/m, I thought I was in a different channel.  I probably won't be able to understand, much less answer your question
01:24:38 <Itkovian> Lemmih: after an error, and subsequent writing to the debug file, it seems like the lock on that file is retained.
01:28:16 * Itkovian is off 
01:28:18 <Itkovian> ttyl
01:30:04 <shapr> tic_: TaPL has good stuff about small/big step semantics.
01:33:47 <tic_> what's tapl?
01:34:03 <tic_> nm.
01:34:20 * tic_ will google before asking questions, tic will google before asking questions, ...
01:38:47 <Lemmih> Lemmih__: Who are you?!
01:48:18 <jlouis> I have  book by Glynn Winskel here describing big/small-step semantics
01:48:27 <jlouis> its not even hard
01:48:46 <jlouis> just irritating because one has to write so much for so little
01:50:48 <tic_> no, big-step isn't that bad... just small-step is easy to get lost in because you have to write as much, like you said.
01:54:46 <jlouis> oh, just you wait till you have 3 environments per operation to handle ;)
02:30:54 <Oejet> Hello.
03:52:30 <xerox> 'morning!
03:57:56 <ndm> morning
04:20:29 <Lemmih> Itkovian: Hey.
04:20:41 <Itkovian> hi Lemmih
04:22:37 <Lemmih> I fixed a thing in the Browse page. Can you see it now?
04:26:11 <Itkovian> nah .. samed thing
04:26:27 <Itkovian> it's just Safari tho ...
04:30:31 * Itkovian cooks & eats
04:31:04 <Itkovian> where does PATH_INFO come from?
04:31:42 <Lemmih> Itkovian: http://212.242.49.100/hsp/VarView
05:08:13 <dcoutts> hey Lemmih, how's hackage going?
05:38:51 <Lemmih> dcoutts: Great. We got it installed and it appears to work.
05:39:25 <Lemmih> (we, as in SyntaxNinja and me)
05:43:34 <dcoutts> Lemmih, cool
05:43:39 <dcoutts> where? URL?
05:43:51 <dcoutts> the one linked from haskell.org/cabal is stale
05:44:12 <Lemmih> http://hackage.haskell.org/ModHackage/Hackage.hs
05:44:34 <Lemmih> Will be moved to http://hackage.haskell.org/ later.
05:49:54 <Igloo> Lemmih: This nobr tag doesn't really exist, does it?
05:50:35 <Lemmih> It should exist.
05:51:28 <Lemmih> @google nobr
05:51:30 <lambdabot> http://www.blooberry.com/indexdot/html/tagpages/n/nobr.htm
05:51:39 <Igloo> I don't see it in the HTML 4 or XHTML 1.1 specs
05:52:36 <Igloo> "The only DTD to include this element is the Internet Explorer 3.0 DTD" according to that page
05:53:08 <xerox> yikes :)
05:53:34 <Lemmih> Feel free to send patch if you got something better (:
05:54:52 * Lemmih is glad as long as it renders properly in Mozilla, w3m and lynx.
05:56:13 <Igloo> You can probably do what you mean with CSS, but I would question whether having things fly off the end of the window is really better than just having them wrap when necessary
05:57:16 <Lemmih> I think "Foreign binding" would wrap if I removed it.
05:57:18 <dcoutts> Lemmih, cool so I can start building automatic tools for generating ebuilds from packages in hackage
05:58:01 <Lemmih> dcoutts: I got a cabal-get bootstrap .tgz online, if you're interested.
06:02:43 <xerox> Where can I read about record's syntax?
06:03:46 <xerox> @wiki UsingRecords
06:03:48 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
06:07:11 <der_eq> suppose you had a parser for values that could be either basic-values(like Int or String) or arrays of values or arrays. Would it be possible to somehow express the fact that the array is not a list of any values([Value]) but a list of values with the same type(for example [Int])?
06:07:34 <xerox> @index sincos
06:07:36 <lambdabot> bzzt
06:07:47 <xerox> @type sincos
06:08:02 <lambdabot> bzzt
06:12:01 <dcoutts> why do we have divMod but not sinCos ?
06:12:04 <dcoutts> oh well
06:12:19 <dcoutts> Lemmih, ok I'll look into it
06:12:30 <dcoutts> Lemmih, what does cabal-get do exactly?
06:12:49 <dcoutts> Lemmih, is there any docs on the hackage xml-rpc interface?
06:15:23 <Lemmih> The source of hackage-client is pretty clear.
06:16:27 <Lemmih> dcoutts: http://212.242.49.100/packages/cabal-get-bootstrap.tgz
06:19:32 <Lemmih> dcoutts: cabal-get downloads and installs packages from a hackage server.
06:22:32 <dcoutts> Lemmih, ok cheers
06:33:09 <xerox> Aww..
06:33:54 <xerox> Is it possible to make a (*) :: (Num a, Num b) => a -> b -> a ?
06:34:12 <dcoutts> sorry xerox, I don't think so
06:34:36 <dcoutts> that's for transforming points by a matrix right?
06:34:39 <xerox> I was trying to get both matrix multiplication and scalar*matrix multiplication...
06:34:53 <dcoutts> yeah, you'll need a seperate oprtation for that
06:35:12 <xerox> like ``scalarMultiplyMatrix'' ?
06:35:26 <dcoutts> or just scaleMatrix
06:35:50 <xerox> scale does exist and does some specific thing, but ok, I do need a function
06:36:22 <xerox> Too bad :-)
07:36:43 <xerox> Haskell power
07:36:57 <xerox> 589 archive/cairo/src/cairo-matrix.c
07:36:58 <xerox> 67 cairobindings/Graphics/Rendering/Cairo/Matrix.hs
07:37:50 <ski> @arr
07:37:51 <lambdabot> This is the END for you, you gutter-crawling cur!
07:38:01 <xerox> @where cairo
07:38:03 <lambdabot> http://haskell.galois.com/~paolo/darcs/cairobindings
07:38:09 <xerox> Feedback is welcome ^_^
07:38:26 <ski> lambdabot: And i've got a litle TIP for you, get the POINT?
07:39:55 <ski> should http://haskell.galois.com/~paolo/darcs/cairobindings/Graphics/Rendering/Cairo/Matrix.hs point to a list of errors ?
07:40:16 <xerox> ski: it's galois' problem :-\  They try to do something with .hs in urls
07:40:37 <xerox> darcs get should work, I think
07:59:01 <sieni> http://www.student.oulu.fi/~taliukko/ciwatpfbg.jpg
08:00:32 <psi> is there a Select module in ghc 6?
08:03:36 <autrijus> select, as in sockets?
08:04:34 <psi> yes
08:05:27 <autrijus> I think the answer is you don't need that.
08:05:38 <autrijus> instead, use Control.Concurrent
08:05:51 <autrijus> and use threadWaitRead / threadWaitWrite
08:06:20 <psi> I see. thanks.
08:06:26 <autrijus> np
08:09:00 <Philippa_> doing (read -> dump it down a chan to a thread that deals with aggregate stuff) works well too
08:09:16 <autrijus> yup
08:09:27 <autrijus> you can even use a TChan.
08:13:51 <Philippa_> cool - I haven't played with the STM stuff yet
08:14:13 <ehuber> bonk
08:14:15 <ehuber> hi
08:16:26 <samx> Newbie question.. Why does ... "contents <- IO.hGetContents handle" "putStrLn contents" "IO.hClose handle" .. work, but "contents <- IO.hGetContents handle" "IO.hClose handle" "putStrLn contents" not work?
08:17:02 <ski> don't close handles that you've passed to hGetContents
08:17:52 <ski> hGetContents "semi-closes" the handle, which means that it will close the handle when the whole string has been forced
08:17:59 <samx> hmm, so is what you are saying that, hGetContents doesn't get the contents in one operation, but lazily upon use on contents or something?
08:18:36 <ski> yes, and if you close yourself, then the putStrLn after the hClose can't get any chars
08:19:23 <samx> ok.. that makes sense.. so I should never close a handle that I pass to hGetContents, but just let it do the closing on its own?
08:19:30 <ski> one could think of 'semi-closed' handles as being lazilly closed. that is, scheduled to be closed, but not closed yet
08:19:39 <ski> i think so, yes
08:20:35 <samx> ok. that explains it. thanks :)
08:28:27 <xerox> ski: did you try darcs getting?
08:38:00 <ski> (xerox : am not at system with darcs installed, atm)
08:49:24 <basti_> hi
08:50:00 <ski> iih !
08:53:46 <autrijus> Heffalump: uhm
08:53:57 <autrijus> in hscp2hsc
08:54:00 <autrijus>   while (substr($ctype,-1) eq '*'){
08:54:01 <autrijus>     $ctype = substr($ctype,0,-1);
08:54:02 <autrijus>   }
08:54:09 <autrijus> I don't see how this loop can terminate
08:56:57 <samx> what's the easiest way to chop a string to a list of strings separated by commas ?
08:57:29 <autrijus> intersperse ","
08:57:44 <autrijus> er sorr
08:57:47 <autrijus> intersperse ','
08:57:55 <basti_> thats the other way round
08:58:07 <basti_> he wants "split" you gave him "join"
08:58:10 <autrijus> oh.
09:01:02 <basti_> filter (/=",") $ groupBy (\x y->x/=',' && y/=',') "hads,asdk"
09:01:06 <basti_> samx.
09:01:15 <autrijus> samx: http://haskell.org/hawiki/LicensedPreludeExts
09:01:19 <autrijus> use splitBy there
09:01:39 <basti_> or that.
09:02:11 <basti_> my snippet doesnt get the case "test,,test" anyway.
09:04:43 <Defiler> I accidentally ended up with a second copy of 'Types and Programming Languages'; any suggestions for what to do with it?
09:04:55 <autrijus> read it again!
09:04:58 <ehuber> send to me ? :p
09:05:15 <Defiler> Those are both interesting ideas. Heh.
09:06:00 <Defiler> I didn't even realize it had happened; I walked past my copy in the living room, and then saw it again upstairs.. "Huh?"
09:06:25 <autrijus> if you happen to discover a bulk matter replicator nearby, send _that_ to me :)
09:06:51 <Defiler> I'll keep my eyes peeled for that.
09:07:06 <autrijus> ...I'll take a replicate for the replicator even
09:07:34 <xerox> http://www.theregister.co.uk/2005/08/19/sha-1_attack/
09:07:35 <liyang> fix (\f s -> case span (/=',') s of { (l,[]) -> [l] ; (h, (',':t)) -> h : f t }) "a,,b,c"
09:07:42 <ski> autrijus : maybe you need two of them to begin with, for that ?
09:07:51 <ski> (or a time machine)
09:07:58 <ehuber> ski: or a flexible showerhead
09:08:02 <liyang> @eval fix (\f s -> case span (/=',') s of { (l,[]) -> [l] ; (h, (',':t)) -> h : f t }) "a,,bb,ccc"
09:08:06 <basti_> liyang: woah.
09:08:09 <lambdabot> ["a","","bb","ccc"]
09:08:26 <liyang> Probably needlessly complicated. -_-;;
09:08:29 <xerox> fix O_o
09:08:36 <liyang> Why not?
09:08:43 <ski> hm, i think it's a case of Ouroboros ..
09:08:48 <xerox> Sorry I can't understand it, I just joined :-)
09:09:13 <autrijus> ski: maybe it's Klein, not Groß
09:09:21 <samx> and here I was thinking using Haskell might actually simplify my life ;-)
09:09:24 <Defiler> What does the backslash mean before the 'f'?
09:09:38 <ehuber> lambda function
09:09:39 <ski> Defiler : anonymous function
09:09:40 <autrijus> samx: just use the predefined splitBy :)
09:09:41 <liyang> @eval let split s = case span (/=',') s of { (l,[]) -> [l] ; (h, (',':t)) -> h : split t } in split "a,,bb,ccc"
09:09:44 <lambdabot> ["a","","bb","ccc"]
09:09:49 <liyang> That better? ^_^;
09:09:54 <Defiler> Oh, OK. I'm just used to seeing it written as the actual lambda character in the books.
09:10:02 <ski> (autrijus : Groß ?)
09:10:06 <autrijus> ski: yeah
09:10:13 <ski> oh :)
09:10:24 <xerox> @doc Marshal.Alloc
09:10:26 <lambdabot> Marshal.Alloc not available
09:10:32 <xerox> @doc Foreign.Marshal.Alloc
09:10:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.Alloc.html
09:10:55 <autrijus> Defiler: well, the "\" and "forall" and "->" are all poor ascii substitudes
09:11:12 <autrijus> ...but then, GHC still doesn't allow nonlatin1 unicode literals. so I can't really defend that idea
09:16:58 <ski> hm "The ouroboros is an example of tail recursion" :)
09:17:08 <basti_> ouch
09:17:49 <autrijus> yow
09:18:55 <autrijus> so Thor is the tail recursion elimination engine?
09:19:02 <basti_> samx:
09:19:11 <basti_> @eval (map tail.groupBy (\x y->y/=',').(',':)) "kjksadf,jkajsdklas,aksdjk"
09:19:14 <lambdabot> ["kjksadf","jkajsdklas","aksdjk"]
09:19:21 <basti_> hows that?
09:21:49 <ski> autrijus : possibly Mjolnir could be considered a symbol of imperatives (or at least iteration ?), then ..
09:22:00 <basti_> :-o
09:22:33 * autrijus stops this silly scanned in avian mythology train of thought
09:22:46 <ski> hehe
09:23:17 <autrijus> somehow, scanned-in avian keeps reminding me of Escher.
09:23:28 <ski> person or language ?
09:23:55 <autrijus> http://www.annexed.net/box/escher/birdsnfish.html
09:24:01 <autrijus> scanned-in avians
09:24:44 <ski> ah
09:25:05 <xerox> autrijus: indeed!
09:25:56 <basti_> groupBy requires that the first parameter is an equivalence.
09:26:37 <basti_> is that good or bad?
09:27:22 <xerox> @plugs let f = map tail . groupBy (const (',' /=)) . (',':) in f "123,4,56,7"
09:27:25 <lambdabot> ["123","4","56","7"]
09:28:05 <basti_> why the const?
09:28:15 <basti_> ah to eat one parameter
09:28:22 <xerox> Just yours, nm.
09:28:37 <xerox> haha
09:28:43 <basti_> hm?
09:28:44 <xerox> Just "yours" :: Maybe Cooler
09:29:01 <basti_> ughhh
09:30:07 <xerox> Funny :)
09:31:51 <basti_> samx should see that.
09:33:52 * autrijus found a nice addition to QuotesPage
09:33:58 <samx> i do.. i ended up going with "let regex = Regex.mkRegex "," in Regex.splitRegex regex line"
09:34:04 <autrijus> <darix> the problem with haskell is the learning curve is like the an mountain in the himalaya ...
09:34:07 <autrijus> <darix> nearly 90degree and close to 8000 m
09:34:09 <autrijus> <darix> but standing up the hill just rocks ;)
09:34:11 <basti_> samx: :D
09:34:22 <Lemmih> autrijus: (:
09:35:59 <autrijus> autrijus's corolarry: "Haskell gets you high easier than it gets you far"
09:36:18 <Khisanth> that doesn't sound too good :)
09:36:31 <autrijus> that is true though :)
09:36:59 <Khisanth> but I am interpreting it as "you will learn a lot but you won't be able to do much with that knowledge"
09:37:10 <autrijus> the manipulexity / whipuptitude ratio is definitely biased to the left
09:37:45 <autrijus> Khisanth: depends on your task really... marching on the ground for days doesn't do you good if you can't see the path
09:38:46 <ehuber> the problems ive tried solving with haskell, compared to c/++, have more concise solutions
09:39:51 <autrijus> Khisanth: also... sometimes windsails launched from high altitudes work just fine. at least I hope so for my project :)
09:41:47 <Lemmih> Damn, I just realized I've been going in circles for over a day. /-:
09:41:57 * Lemmih feels stupid.
09:42:09 <Oejet> The circle of life.
09:42:35 <basti_> stupid would be not realizing that you are.
09:42:35 <ski> The wheel of time.
09:44:12 <TFK> The tree of knowledge.
09:44:19 <Oejet> basti_: No, that's ignorant.
09:44:22 <basti_> the abstract data type tree.
09:44:35 <basti_> Oejet: ignorant is to realize but not to act upon
09:45:02 <Oejet> basti_: Really?
09:45:15 <basti_> i'd say
09:45:51 <ski> The tree of life, Yggdrasil, Sephiroth
09:46:13 <basti_> the circle of trees
09:46:45 <ehuber> the eternal hunting grounds
09:47:37 <ski> the Sufficiently Smart Compiler
09:51:56 <Pita> Greeting!
09:52:24 <Pita> Is Haskell a good language for exploratory programming?
09:53:09 <xerox> Hey!
09:53:14 <dcoutts> Pita, that's a slighly open question
09:53:15 <xerox> What is exploratory programming?
09:53:25 <Pita> basically
09:53:27 <dcoutts> Pita, would you be satisfied if we said "yes" ?
09:53:43 <Pita> programming when you strart of sillyu
09:53:45 <Pita> silly
09:53:49 <Pita> without a clear plan of execution
09:53:57 <Pita> and you organically grow your program
09:54:02 <dcoutts> I do that all the time
09:54:09 * xerox did it 3 mins ago :-P
09:54:10 <TFK> eXtreme Programming?
09:54:12 <Pita> i am doing that in Lisp already
09:54:25 <dcoutts> start with a bunch of types and then move on later to some implementations when all the types work
09:54:41 <Pita> i wonder how switching to Haskell will help me gain some advantages over lisp?
09:55:06 <xerox> You'll probably notice you have to think a bit more in Haskell before writing on the "REPL" ;-)  But it passes after some time, and it helps in many ways.
09:55:19 <Pita> with Lisp.
09:55:26 <Pita> i find I don't have to think that much
09:55:31 <xerox> Indeed.
09:55:37 <Pita> I tried Ocaml
09:55:42 <Pita> I had to think so much before each line
09:56:15 <xerox> @where coolness begins?
09:56:16 <lambdabot> http://www.haskell.org/learning.html
09:56:18 <xerox> ;-)
09:56:21 <TFK> That one depends on how well-versed you are in the language.
09:56:22 <Pita> :)
09:56:31 <Pita> does haskell have a larger user base than ocaml?
09:56:45 <goron> Pita: I tried Lisp, but I didn't see advantages to Lisp. (yes, and I understand the "benefits" of Lisp.)
09:57:09 <goron> Haskell is the least broken language.
09:57:40 <samx> quite arguable :-)
10:00:56 <dcoutts> Pita, I beleive that Haskell does have a larger user base than ocaml, however I've no objective evidence to point to, it just appears to be that way
10:01:17 <dcoutts> partly because it's not a one-implementation language
10:01:41 <Pita> is haskell = strictly no imperative?
10:02:03 <xerox> dcoutts: darcs pushed Matrix.chs
10:02:16 <TFK> http://www.googlefight.com/index.php?lang=en_GB&word1=Haskell&word2=O%27Caml <--- haskell wins by a margin
10:02:37 <dcoutts> xerox, ok I'll take a look
10:02:49 <Lemmih> 128 in #haskell and 47 in #ocaml, so we at least have the largest IRC channel. (:
10:02:58 <TFK> Wins by a margin even if you pit it against "OCaml" and "Caml" ;-)
10:03:32 <ski> Pita : haskell separates imperative/impure from pure
10:04:00 <xerox> Anybody have insights about |alignment| in |instance Storable|?
10:04:14 <ski> Pita : you still can sequence commands, and assign things to reference cells, if you want to
10:04:15 <Pita> does haskell have built-in gui functions?
10:04:20 <xerox> Pita: indeed!
10:04:27 <Pita> no way!
10:04:27 <dcoutts> Pita, well it's got Gtk2Hs and wxHaskell
10:04:35 <Pita> ahh
10:04:35 <xerox> Pita: there is a über-cool Gtk binding, with Cairo support.
10:04:56 <dcoutts> so not "built-in" but available as libraries
10:05:09 <xerox> "built" :-P
10:05:20 <dcoutts> (which is better, built-in would not be ideal)
10:05:55 <goron> Pita: Getting all the pieces together to actually be able to build something (especically on Windows) is a pain.
10:05:55 <xerox> Indeed
10:06:12 <dcoutts> goron, Gtk2Hs has a win32 installer
10:06:14 <goron> Pita: But there's nothing wrong with Haskell, imho.
10:06:15 <xerox> dcoutts: it's difficult enough to build as a library, heh
10:06:36 <Pita> Is there an apache mod for haskell?
10:06:43 <goron> dcoutts: I don't have experience with Gtk2Hs on Windows platform.
10:06:50 <xerox> Pita: you're lucky...
10:06:59 <dcoutts> xerox, several distros have Gtk2Hs packages to make it easy
10:07:19 <xerox> Pita: http://212.242.49.100/hsp/Browse
10:07:32 <Lemmih> Pita: Yeah, but you should use FastCGI instead.
10:07:46 <Pita> So only Ruby, Python then Lisp are larger channels for scritpting language on this irc server
10:07:48 <goron> 500 Internal Server Error
10:07:48 <goron> Error specification:
10:07:48 <goron> An exception occured during page evaluation:
10:07:49 <goron>   PersistentStore type mismatch. A variable of type '()' was requested as a '[Char]'.
10:07:55 <goron> http://212.242.49.100/hsp/PersistentMismatch
10:08:08 <goron> I guess not everything works perfectly....
10:08:13 <xerox> dcoutts: I was trying to thank you for the effort in the build system... that it seems I'm ignoring using the wrong repo <grin> :-)
10:08:14 <Lemmih> goron: That's the whole point of the example.
10:08:17 <goron> But at least the mainpage runs now.
10:08:28 <goron> Lemmih: oh, ok.
10:08:33 <goron> Lemmih: Good job then :)
10:09:23 <Lemmih> You can save arbitrary Haskell expressions in either a session (cookie based) or in a persistent store.
10:09:42 <goron> Lemmih: How fast is it/can it be?
10:09:49 <basti_> witnessed on #gcc: < __pundai__> c++ is annoying to sayt he least
10:10:11 <Lemmih> goron: It only saves a session id in the cookie.
10:10:32 <Lemmih> goron: You could even store an infinite list as a session.
10:11:19 <goron> Lemmih: Is it intended to be something "usefull" or just as a research thingie?
10:11:35 <goron> er useful
10:11:44 * goron afk 
10:12:10 <Lemmih> nibro is writing his Masters thesis about it but I definitely think it'll be useful someday.
10:13:36 <Lemmih> A stable release is pretty close. I just need to fix the Haskell parser and tweak the install instructions.
10:13:49 <xerox> Lemmih: you're damn fast.
10:14:31 <Pita> What is a good haskell implementation to start with for OS X?
10:14:56 <Lemmih> No school and no job gives me a bit more time to hack Haskell (:
10:15:04 <xerox> @where ghc
10:15:04 <ehuber> i use HUGS in a terminal window
10:15:05 <lambdabot> http://haskell.org/ghc
10:15:08 <xerox> ^- Pita
10:15:35 <xerox> Lemmih: I'm on vacation too, but it's taking me months to bind a library :-)
10:15:41 <ehuber> gtg..lunch
10:16:31 <Oejet> xerox: How big is that library?
10:17:05 <xerox> Oejet: it's cairo, in fact the problem now is that it has some complex ramifications into fonts...
10:18:11 <xerox> In fact most of the work was done in this last 20 days - if not all of it.
10:18:30 <dcoutts> it's going rather well really
10:18:45 <dcoutts> Oejet, have you seen the screenshots yet?
10:18:57 <xerox> It's all due to the support of dcoutts! :-)
10:19:01 <dcoutts> we're feeling rather pleased with ourselves :-)
10:19:15 <dcoutts> it's all due to the hard work of xerox!
10:19:46 <xerox> We are :)
10:22:55 <Igloo> Lemmih: hsp parses the Haskell itself? In order to process a request, or when building the cgi programs?
10:24:12 <Lemmih> Igloo: In order to process a request. It transforms the embedded HTML to proper Haskell.
10:24:26 <Igloo> Does it do any caching?
10:24:42 <Lemmih> Yes.
10:24:51 <Igloo> Ah, OK then  :-)
10:24:53 <Lemmih> Would be real slow otherwise (:
10:25:41 <xerox> wouldBe :: (Real hsp, Slow hsp) => otherwise
10:25:55 <xerox> err, whatever :-P
10:27:16 <xerox> Crypto researchers have discovered a new, much faster, attack against the widely-used SHA-1 hashing algorithm. Xiaoyun Wang, one of the team of Chinese cryptographers that demonstrated earlier attacks against SHA-0 and SHA-1, along with Andrew Yao and Frances Yao, have discovered a way to produce a collision in SHA-1 over just 2**63 hash operations compared to 2**69 hash operations previously. A brute force attack should take 2**80
10:27:17 <xerox> operations.
10:27:49 <Lemmih> eval 2^63
10:27:51 <Lemmih> @eval 2^63
10:28:08 <lambdabot> 9223372036854775808
10:29:08 <ski> xerox : didn't we see that some month(s) ago ?
10:29:16 * Lemmih won't be cracking anything on his box.
10:29:27 <ski> or yet a new faster way ?
10:30:22 <xerox> ski: this time 2^69 lovered to 2^63
10:31:55 <ski> aha, ok
10:32:05 <ibid> ski: the "much faster" part ;)
10:34:10 <mflux> but isn't there sha-512 too?
10:34:31 <ibid> yes, and a lot of others. so what?
10:35:16 <mflux> I wonder if this attack affects them 'the same amount' or worse
10:35:58 <mflux> that is, with the current attack vector, would it seem that simply using longer variants of the hash would 'fix' the problem
10:36:10 <mflux> of course fixing all the software hardwired into using sha1 isn't that fast
10:36:42 <mflux> and of course there are completely different hashes too, but I doubt they have as much research behind them..
10:39:19 <marcot> Hello, in the haskell compilers I've seen you can't do something as equal :: a -> a -> Bool; equal x x = True; equal _ _ = False
10:39:31 <marcot> Doesn't anyone intend to implement this kind of thing?
10:40:03 <dcoutts> marcot, it's not part of the Haskell semantics
10:40:09 <ski> you need general unification, and not just (one-way) matching to do that
10:40:17 <marcot> ski: hey, ski.
10:40:21 <dcoutts> because such a thing is not really functional but more like a logic language
10:40:24 <ski> (and general unification is not decidable for e.g. functions)
10:41:02 <dcoutts> you might be able to do that in mercury (which I understand is a functional/logic language mixture)
10:41:15 <marcot> dcoutts: I don't get why this is not really functional? For me is a semantic stuff.
10:41:36 <marcot> ski: what's this general unification?
10:41:57 <ski> marcot : you get unification in logic programming
10:42:24 <marcot> ski: hum...
10:42:33 <marcot> ski: but in this case things are more simples.
10:42:45 <ski> marcot : though there are some combined functional logic programming languages (such as Escher,Curry and Mercury (maybe Goedel .. hmm))
10:42:58 <marcot> ski: f x x              ==              f x y; | x == y
10:43:16 <ski> but (==) in haskell is not supported for all types
10:43:51 <marcot> ski: I've used == just for saying that this means the same.
10:43:51 <ski> (dcoutts : i think you can, yes)
10:44:15 <marcot> ski: it's supported for all types which have Eq instances.
10:44:21 <ski> yes
10:44:35 <marcot> hum...
10:44:37 <dcoutts> in that case, equal = (==)
10:44:39 <dcoutts> :-)
10:44:51 <Philippa_> it seems to me that logic programming languages are effectively relational languages too
10:44:52 <ski> one could possibly argue for your equal having type  Eq a => a -> a -> Bool ..
10:45:00 <ski> Philippa_ : yes, in a way
10:45:09 <Cale> marcot: are you just suggesting that f x x = foo be syntax sugar for f x y | x == y = foo ?
10:45:12 <marcot> ski: sure, it should have this type.
10:45:21 <Philippa_> ski: an "I don't mean SQL!" kinda way? :-)
10:45:22 <marcot> Cale: yes.
10:45:25 <Cale> oh, okay
10:45:33 <Philippa_> but that sorta implies you've got functions as a special case, IYSWIM
10:45:36 <marcot> Cale: what do you think about it?
10:45:52 <Philippa_> you just can't do much of interest without much wailing and gnashing of teeth in prolog
10:46:13 <ski> Philippa_ : though, usually, databases use bottom-up, set-at-a-time evaluation (with efficient joins and stuff from relational algebra at least in impl.) while logic programming usually uses top-down, tuple-at-a-time evaluation
10:46:19 * goron back
10:46:33 <Cale> Sometimes that would be handy... I haven't had any cases where it would really have made things a lot simpler though.
10:46:51 <Cale> (as the conversion isn't so hard)
10:46:52 <ski> Philippa_ : but see 'deductive databases' for ideas about combining them
10:47:01 * Philippa_ wonders if you can do something monad-like
10:47:14 <Cale> there's something to be said for making it obvious that an equality test is going on
10:47:18 <marcot> I'm thinking right now and the problem is that all functions that use this will have to be defined in an Eq a type.
10:47:40 <Cale> yeah, well, that will be fairly automatic
10:48:13 <marcot> But this is not so good.
10:48:18 <Cale> but the user will certainly have to be aware of that
10:48:23 <Cale> hm?
10:48:30 <dcoutts> I think it's basically a hack to make it look like a limited form of relational/logic language, it's better to keep it explicit
10:48:31 <Cale> It's the best that one can do
10:48:55 <Philippa_> it's... well, it's hacky sugar. That argument always goes both ways
10:48:57 <marcot> Having a different way of defining functions that only stands for certain types of funcions is not so good.
10:48:57 <ski> Philippa_ : for relational things ?  or in prolog ?
10:49:02 <marcot> That's what I meant.
10:49:05 <Cale> oh
10:49:07 <Philippa_> sometimes I like it, but | bigpileo'conditions works
10:49:26 <Philippa_> ski: for doing DB-like things and prolog-like things on relations in the same language, I guess
10:49:59 <ski> i think that isn't necessary
10:50:14 * goron is with dcoutts on this one
10:50:52 <Philippa_> well no. But if it's largely an evaluation order thing?
10:51:05 <ski> (Philippa_ : there is a deductive database system called Aditi, which are underway to get integration with Mercury)
10:51:15 <ski> (s/are/is/)
10:51:16 <goron> You can introduce syntax for every concept in the universe, but does that really add something?
10:53:18 <Philippa_> goron: which conversation is that aimed at? :-)
10:53:33 <marcot> goron: I don't think it would be good also.
10:53:39 <Philippa_> I sorta like the syntactic sugar for equality, but not enough that I'd be willing to let a bunch of idiots loose with it
10:55:16 <Philippa_> if you have that you kinda find yourself wanting sugar for equality on arbitrary values though
10:55:44 <Philippa_> like any time an algebraic datatype's been abstracted into a bunch of named values and equality so you can't pattern-match comfortably...
10:57:19 <Philippa_> I strongly suspect I prefer just having guards to that, basically :-)
10:59:58 <marcot> me too.
11:02:53 <goron> (and if you don't like Haskell, then write a compiler.)
11:09:32 <ski> (Philippa_ : of course, one can do relational things with monads, too, as in e.g. "Comprehending Queries" http://www.ub.uni-konstanz.de/kops/volltexte/1999/312/312_1.pdf)
11:14:06 <FrederikEaton> haskell needs a "here-doc" notation
11:14:48 <cyanite> ghc has it as an extension doesn't it?
11:17:16 <FrederikEaton> oh really? sweeet
11:19:05 <FrederikEaton> where?
11:19:38 <cyanite> well...   I am not sure, I read about it yesterday when I was browsing around a lot of places   ... so it's only ' i think' :(.  I mean.. it is SOMEWHERE.
11:19:45 <cyanite> not 101% it was ghc.
11:20:09 <Lemmih> Only Hugs has it, iirc.
11:20:11 <dcoutts> cyanite, I think hugs has it but ghc doesn't
11:20:39 <cyanite> ah... hugs then. sorry.
11:20:57 <FrederikEaton> lame
11:21:23 <cyanite> or at least unfortunate :p
11:21:43 <ski> "here-doc" ?
11:21:58 <cyanite> like:  s = <<END
11:22:03 <cyanite> some string
11:22:04 <cyanite> some more
11:22:04 <cyanite> END
11:22:04 <FrederikEaton> hmm, but then again there should be some simplish way to give my program an option that brings up an editor to let me edit the raw string literal
11:22:27 <FrederikEaton> and modify the script source when i close the editor...
11:22:53 <cyanite> that's more an IDE problem than language, m?
11:22:58 <Lemmih> That would probably be easy to write in Yi.
11:23:27 <Lemmih> GHC supports string gaps, btw.
11:23:56 <FrederikEaton> let's think more general
11:23:56 <twobitsprite> so, I'm reading "Haskell for C Programmers", and I'm not understanding the "=>" operator... I know it has something to do with restricting the class of a type, maybe?
11:23:56 <FrederikEaton> i'm looking for a category-theory-like solution to the problem of modifying program output
11:23:56 <FrederikEaton> and propagating modifications back to input
11:24:13 <FrederikEaton> oh never mind
11:24:24 <FrederikEaton> Lemmih: what's this, the \ \ notation?
11:24:32 <twobitsprite> but, what's the difference between "foo :: Num -> Num" and "foo :: Num => a -> a"?
11:24:32 <Lemmih> FrederikEaton: Yes.
11:25:13 <sylvan> twobitsprite, the first one isn't valid Haskell... Num is a type class not a type
11:25:17 <xerox> twobitsprite: that the former is wrong if Num is a type class
11:25:24 <cyanite> twobitsprite: Num is a class.  you can't have Num as a type.  classes are 'higher' than classes.
11:25:32 <cyanite> twobitsprite: classes are 'types of types'
11:25:36 <cyanite> twobitsprite: in a sense.
11:25:38 <xerox> @type 1 :: Num Int
11:25:39 <sylvan> So "Num a => ..." says, let a be some type in the class Num, and then the type of the function comes
11:25:40 <twobitsprite> I see
11:25:45 <lambdabot> bzzt
11:25:49 <xerox> OK :-P
11:26:17 * twobitsprite processes this information...
11:26:57 <sylvan> It's sort of like generics in C# and other languages, 'a' can be any type as long as it implements the interface defined in the Num type class...
11:26:58 <cyanite> twobitsprite: so Num a => ...    just means:  for all a that conform to the 'Num' class:   ....   is the type.
11:27:00 <ski> cyanite,twobitsprite : rather, classes are collections of/predicates over types
11:27:11 <cyanite> ski: yeah.. was just making it simpler ;).
11:28:07 <twobitsprite> ski: I almost had it until you said that... :P
11:28:20 <twobitsprite> ohh... n/m I see what you're sayinfg
11:28:31 <cyanite> twobitsprite: hehe.. the thing is, a type can have more than one 'class'.   so classes aren't strict like c++ classes.
11:28:37 <ski> FrederikEaton : hmm .. so that the function map the reconstructed input to the modified output ?
11:28:39 <cyanite> twobitsprite: they are rather some requirements a type can conform to.
11:29:03 <sylvan> a c++ class has very little to do with type classes...
11:29:23 <cyanite> quite.
11:29:25 <sylvan> interfaces is more like type classes.. It defines a set of function that must be implemented for the type
11:29:26 <ski> type classes are more similar to Java interfaces than OO classes
11:29:36 <ski> sylvan : :)
11:29:39 <sylvan> =)
11:29:51 <twobitsprite> so, the "prototype" for a function type definition is "funName :: [optionally define types =>] typeSignature"  something like that?
11:30:09 <sylvan> yeah
11:30:15 <sylvan> the "type" of the function
11:30:18 <sylvan> is what we call it
11:30:26 <ski> twobitsprite : if you must have it in C++ terms, i think the nearest would be an abstract base class with only virtual member functions ..
11:30:27 <cyanite> twobitsprite: yeah..   similar to prototypes.
11:30:28 <sylvan> (which is optional by the way)
11:30:57 <twobitsprite> I understand type classes now... I'm just trying to map out the syntax of => in my head
11:30:59 <cyanite> ski: except classes are types of objects, in c++.. wheras classes in haskell are 'types' of types.
11:31:03 <dcoutts> twobitsprite, it's not [optionally define types =>] it's [type class constraints =>]
11:31:31 <twobitsprite> dcoutts: that's kinda what I was thinking... I'm still trying to grok haskell's jargon
11:31:34 <ski> (rather, the "funName :: ..." is the 'type signature' of 'funName', while "..." there is the type of 'funName')
11:31:34 <cyanite> twobitsprite: the syntax is just..syntax.   Foo bar => blah   just means for-all bar comforming to Foo: blah
11:31:55 <dcoutts> twobitsprite, eg sort :: Ord a => [a] -> [a]
11:32:24 <sylvan> a => b, means that a is a tuple of type class constraints (e.g. (Show x, Read y, ...) ) and b is the type using type variables constrained in a
11:32:45 <twobitsprite> cyanite: right... I get that, but now I see " fibGen :: Num a, Num b => b -> b -> a -> b"... so with multiple "class constraints" they all go before the "=>"?
11:32:46 <dcoutts> twobitsprite, that says that you can apply sort to a list of any element type, so long as that element type supports ordering (ie is a member of the Ord type class)
11:33:05 <cyanite> twobitsprite: yeah.  =>  separates those from the type itself.
11:33:27 <ski> (sylvan : /me would s/tuple/conjunction/ .. but it looks like a tuple, yes)
11:33:51 <Defiler> I still really have trouble reading the curried form of those definitions.
11:33:54 <twobitsprite> ok... I think it's making sense... I think I'm just having a hard time coming to the realization that haskell is infix... I'm still thinking "functional = prefix"
11:34:04 <cyanite> Haskell is infix??
11:34:07 <Defiler> "Like.. uhh.. that function takes to numerics and does stuff"
11:34:11 <Defiler> to = two
11:34:16 <cyanite> twobitsprite: what does that mean?
11:34:38 <twobitsprite> er... I mean, not everything is in the form "(function args ...)"
11:34:59 <cyanite> no, not everything.    some are  arg1 function arg2
11:35:08 <ski> ar1 operator arg2
11:35:30 <ski> also  arg1 `function_identifier` arg2
11:35:31 <cyanite> twobitsprite: but => and ->  are syntax.. not something to be compared to operators.
11:35:43 <twobitsprite> cyanite: yes, I realize... but I'm just crossing my concepts up in my head... I'm trying to "think functionally" and Lisp/Scheme keep coming to mind confusing me
11:35:52 <cyanite> twobitsprite: ah yes..
11:36:18 <ski> cyanite : actually, '->' in types can be seen as an infix type (constructor) operator
11:36:42 <cyanite> ski: yeah, at the type level.  but i think it's going a bit far ;).
11:37:03 <twobitsprite> I think things are starting to gel.....
11:37:21 <twobitsprite> I actually understood what you meant by " infix type (constructor) operator"
11:37:33 <cyanite> at the type level, remember.
11:37:40 <cyanite> not object level.
11:37:57 <twobitsprite> of course
11:37:57 <twobitsprite> (where else do you use "->"?)
11:38:05 <cyanite> just saying.
11:38:12 <ski> that '->' is right-associative, so  "Int -> [a] -> a" means "Int -> ([a] -> a)"
11:38:26 <sylvan> And VOILA! Currying!
11:38:31 <cyanite> this is to facilitate currying.
11:38:33 <twobitsprite> object level?
11:38:33 <cyanite> yeah
11:38:49 <cyanite> object level.   the level below the type level.   4 is an object. a function is an object.
11:39:00 <Philippa_> ski: to go further, => can be considered an infix operator constructing a type scheme or whatever you fancy calling it from a bunch of typeclass constraints and a type
11:39:02 <cyanite> I don't mean it in any way like OOP.
11:39:05 <ski> twobitsprite : you also use '->' in case expressions at object level   (as well as in lambda / anonymous function expressions)
11:39:17 <cyanite> ski: but then it's syntax.
11:39:40 <Philippa_> which can easily be considered an operator associating patterns with expressions
11:39:43 <cyanite> ski: which is why it might be best not to think of it as a constructor.
11:39:49 <Philippa_> operators are syntax
11:39:51 <cyanite> ski: since it's syntactically overloaded.
11:40:00 <Philippa_> it's a constructor in type expressions
11:40:01 <ski> twobitsprite : e.g.  "case lookup key env of Nothing -> ...; Just value -> ..."
11:40:31 <cyanite> ski, twobitsprite: and obviously -> is something else there, than in type declarations.
11:40:37 <twobitsprite> ok...
11:40:38 <twobitsprite> well... I think I understand => now, so I'm going to continue reading my tutorial before you all throw too many concepts at me..... :P
11:40:44 <cyanite> yeah.
11:40:47 <cyanite> I agree.
11:40:55 <cyanite> ;)
11:41:03 <ski> hehe
11:41:06 <Philippa_> when the overloading is context-dependant, state the relevant context. Duh :-)
11:41:21 <cyanite> or just see it as syntax ;).
11:41:31 <Philippa_> bad move
11:41:44 <cyanite> I don't think so.
11:41:49 <eckroth> could someone guide me to a search term: I basically understand polymorphism (like [a] -> b in a func) but is it possible to overload a function based on its signature (like (a,a) -> b for the same func name)?
11:41:56 <Philippa_> there's a fundamental manner in which -> is a type constructor just the same way [ ] is
11:42:17 <Philippa_> (or a hypothetical List, or the perfectly real Bool, Int et al)
11:42:26 <ski> (Philippa_ : yes, re type schemes   maybe, re patterns and expressions)
11:42:34 <cyanite> Philippa_: I don't think it's necessary to think of it that way, though.  The language can be understood fine without it.  but of course there are similarities at the type and object levels.
11:42:34 <Cale> eckroth: perhaps you want to look at typeclasses
11:42:36 <xerox> Plato's Haskell
11:42:40 <eckroth> Cale: thanks
11:42:47 <Philippa_> ski: I knew the latter was pushing it a little - but hey, the language being compared to was lisp
11:42:55 <Cale> eckroth: but there are limitations to what you can do, for good reason :)
11:43:10 <Philippa_> cyanite: you'll really confuse yourself as you start to play with some of the extensions out there if you don't appreciate the nature of type constructors
11:43:24 <eckroth> Cale: well, for starters, could the same function operate on [a] and (a,a) with two separate definitions?
11:43:53 <Philippa_> yes. You'd need a type class with two instances, one for [a] and one for (a,a)
11:43:57 <eckroth> ok
11:43:57 <cyanite> Philippa_: I am not talking about what I appriciate, but what to say to someone learning this, so as to facilitate his immediate understanding instead of introducing the entire advanced structure at once.
11:43:59 <Cale> well, you could have a typeclass, say Foo, with [] and (,) as instances of it, and some class method which implements that
11:44:02 <sylvan> eckroth, yes, if you define a type class for the function and then isntances for [a] and (a,a)
11:44:12 <eckroth> interesting, thanks folks
11:44:34 <FrederikEaton> ski: Oh, yes, I missed your message. that's it.
11:44:49 <Philippa_> cyanite: then don't confuse things further by throwing in arguments - especially when the structure is another instance of one you have to understand as a haskell coder anyway
11:44:59 <ski> eckroth : but preferable, those overloaded functions should be related more than just sharing same name, i.e. having some common concept behind it ..
11:45:00 <cyanite> Philippa_: I'll teach as I see fit.
11:45:27 <eckroth> ski: well, I was thinking of Lisp's CAR, which can operate on a pair or list
11:45:30 <cyanite> I don't think I was confusing. But everyone can have his or her opinion :).
11:45:41 <FrederikEaton> ski: the problem is that what with turing completeness and the halting problem it seems like you need to design a sublanguage that is reversible in this way. maybe by being made out of reversible composable pieces
11:46:04 <FrederikEaton> but that is all very hand-wavy
11:46:06 <Philippa_> cyanite: diving in with arguments while someone's giving a valid explanation of something is inherantly going to be confusing
11:46:38 <Philippa_> FrederikEaton: context? I'd like to know what you're talking about if that's OK :-)
11:46:40 <cyanite> Philippa_: I don't think the other explanation was any good at this point.  but im not gonna discuss this .....
11:46:56 <ski> FrederikEaton : hm, it reminds me somewhat of incremental/adaptive computation/algorithms ..
11:47:48 <ski> FrederikEaton : maybe if your function has a computable backward mode (in Mercury sense) .. hm
11:48:29 <FrederikEaton> did people see my reverse-mode automatic differentiation library?
11:48:29 <Philippa_> ski: is that 'backward mode' equivalent to coming with an inverse function?
11:48:54 <ski> <FrederikEaton> i'm looking for a category-theory-like solution to the problem of modifying program output
11:48:54 <ski> <FrederikEaton> and propagating modifications back to input
11:49:23 <ski> Philippa_ : ^^
11:49:27 <Philippa_> "if I alter the result to look like this, how does the input change?", applied to n levels of functions, then?
11:49:35 <Philippa_> yeah, you want an inverse function
11:49:46 <FrederikEaton> well, it doesn't have to be total
11:50:02 <Philippa_> yeah. Nor do haskell functions generally, but hey :-)
11:50:16 <Philippa_> boils down to the usual dealing-with-partiality issues, no?
11:50:26 <ski> FrederikEaton : you haven't mentioned anything about whether the functions should be surjective and/or injective ..
11:50:38 <FrederikEaton> Philippa_: what usual issues?
11:50:43 <ski> s/be/be required to be/
11:50:54 <Philippa_> "how do I avoid _|_?" and so forth
11:51:02 <Philippa_> catching the no-result result, etc etc
11:51:33 <ski> wb twobitsprit1
11:51:47 <twobitsprit1> ok... so I think I'm having an epiphany(sp?) but I want to run it by you all before it settles in my head incorrectly
11:52:00 <Philippa_> go for it
11:52:38 <twobitsprit1> "=>" is just arbitrary syntax seperating sections of the function declaration... it could just as well be "#" i.e. "funName = class constrains # type"
11:52:46 <Philippa_> yeah
11:52:51 <twobitsprit1> ahh ha!
11:53:06 <cyanite> but is chosen to give some nice associations probably :)
11:53:23 <Philippa_> yes, logical implication
11:53:25 <Lemmih> Except that would be 'funName :: class constrains # type"
11:53:30 <FrederikEaton> ski: i haven't thought about surjective/injective. i'm thinking of common examples like for instance when you are modifying one version of a program and your modifications must be mergeable with some newer version. in that case you view the new version as the input to a program, and the old version as the output which you're modifying...
11:53:30 <cyanite> yeah...
11:53:43 <twobitsprit1> I think I was just confused by the similarities between => and -> thus assuming that => could be found anywhere in "the stuff following the ="
11:54:06 <FrederikEaton> ski: the "program" being the process of going back in revisions
11:54:21 <cyanite> just => once, for the constraints.   which will create a type-family.
11:54:34 <Philippa_> twobitsprit1: there're extensions where that starts to be possible, but you'll know when you're using them
11:54:43 <ski> (twobitsprit1 : with extensions it can, but you needn't worry about that for now .. :)
11:54:45 <Philippa_> (if only because you won't know WTF you're doing and will have to RTFM ;-)
11:54:48 <twobitsprit1> Philippa_: ok, I'll avoud them for now :P
11:55:04 <twobitsprit1> avoid*
11:56:03 <ski> FrederikEaton : that's sounds a bit similar to darcs' theory of patches ..
11:56:07 <xerox> twobitsprit, hi - do you understand why such a thing is needed, tough?
11:56:20 <FrederikEaton> ski: it isn't just darcs' :) but yeah
11:56:35 <ski> yeah, David Roundy ..
11:56:42 <FrederikEaton> ski: that's not what i meant
11:56:46 <ski> mhm ?
11:56:52 <twobitsprit1> ok... so I have a new, unrelated question... perhaps I should simply forget that Lisp is somehow related to Haskell, but the association begs the question in my head: does Haskell have anything resembling macros?
11:57:00 * ski hasn't actually looked much at the theory of patches, yet
11:57:03 <cyanite> For some reason I never found the darcs 'theory of patches' very deep or novel..but.. I don't know.
11:57:05 <Philippa_> there's an extension called Template Haskell that resembles them
11:57:09 <Philippa_> Haskell 98 doesn't have them
11:57:25 <Philippa_> the important part of the theory of patches is merely that it's formalised and works
11:57:36 <Philippa_> beyond that a lot of it's stating the obvious
11:57:41 <Philippa_> but that's what it's meant to do
11:57:49 <Philippa_> let you state the obvious while eliminating room for error
11:57:50 <ski> also, for some uses of macros in lisp, (lazy) functions in haskell will do fine
11:57:51 <FrederikEaton> ski: well i don't know how original it is. 'arch' has a "theory" of patches too. i don't know if either could be called a theory
11:58:10 <cyanite> yeah but... I mean, .... ok, parts of it is pretty common sense.  and I've seen it formulated before.  but it's fine that he sums it up and defined how it's working in darcs of course.
11:58:15 <Philippa_> blame David's being a physicist
11:58:17 <FrederikEaton> ski: and certainly darcs' doesn't have anything to do with quantum mechanics, as it claims to
11:58:24 <FrederikEaton> yeah
11:58:25 <Philippa_> it doesn't claim to
11:58:39 <FrederikEaton> it claims to be based on it
11:58:39 <cyanite> it claims inspiration..
11:58:45 <cyanite> whatever he is refering to.
11:58:48 <goron> I have a theory of patches too which fits reality better:
11:58:51 <Philippa_> inspiration is a funny thing
11:58:59 <goron> They never work. :D
11:59:01 <Philippa_> it does /not/ have to mean there's something anyone else can trace
11:59:08 <cyanite> no......
11:59:10 <Cale> I can see how it might be inspired by QM
11:59:19 <FrederikEaton> my string library was inspired by string theory
11:59:22 <cyanite> but still  it's put pretty high up on the page, so I would expect so :).
11:59:27 <Philippa_> yeah. Much of the mindset he used to create it will've been developed (in him) by doing QM
11:59:36 <Cale> Commutativity of observables and such :)
11:59:40 * Philippa_ nods
11:59:43 <FrederikEaton> the thing is, that should be embarrassing to him
11:59:49 <Philippa_> you should see where I get some of my inspiration from...
11:59:51 <cyanite> but who cares if his patch view in a RCS is based on quantum mechanics.  that doesn't count as a pro or a con :p
12:00:07 <FrederikEaton> he should have encountered commutators in an algebra class first
12:00:09 <goron> cyanite: you?
12:00:13 <Philippa_> FrederikEaton: not really. I mean, if he were trying to hang with a bunch of mathmos, maybe
12:00:27 <Philippa_> yeah? I haven't. Not by that name, anyway
12:00:40 <Philippa_> granted I'm not a physicist
12:00:45 <cyanite> goron: lol....   well not too much, no :).   I agree with the patch ehm.. theory.   but for all I care it could be based on experiences in baking bread :).
12:00:50 <FrederikEaton> anyway, it comes off as a form of dorky advertisement to me
12:01:02 <FrederikEaton> and misleading
12:01:03 <ibid> it has the buzzword feel
12:01:04 <Philippa_> I don't think it was ever even intended as advertisement
12:01:07 <Cale> Well, physicists use Poisson algebras, and the Poisson bracket is a sort of commutator.
12:01:08 <cyanite> FrederikEaton: yeah that was my thought also.  I'd move it further down the page :).
12:01:09 <twobitsprit1> ok, new question (feel free to tell me to RTFM at any point)... can I curry the second argument in a function? i.e. can I call a function and supply it's second argument resulting in a function that will accept its first?
12:01:15 <Philippa_> just a description of WTF he did back when he first released it
12:01:18 <Cale> (sometimes)
12:01:21 <cyanite> twobitsprite: use flip
12:01:26 <ibid> twobitsprit1: yes
12:01:38 <cyanite> twobitsprite1:  which changes  a -> b -> c   to   b -> a -> c
12:01:46 <FrederikEaton> "When i first released it, i was a physicist. I still have a big ego, though"
12:01:46 <Philippa_> use flip, or more generally write a function that takes a bunch of parms and re-applies them in a different order
12:01:52 <ibid> twobitsprit1: there are several ways, flip being one of them
12:02:13 <ibid> twobitsprit1: the other is (`function` secondParameter)
12:02:15 <Cale> twobitsprit1: Or, of course, you can use something like (\x -> f x 5)
12:02:21 <Philippa_> geez, get over it. It's not as if I've not told people what I was thinking when I came up with something before
12:02:48 <twobitsprit1> cale: I haven't been introduced to the "\" syntax yet...
12:03:00 <cyanite> twobitsprit1: and certainly, flip could be defined:   flip f a b = f b a
12:03:05 <Philippa_> and if you've not had the chance to study a structure in the abstract you end up analogising - big deal
12:03:12 <Philippa_> twobitsprit1: \ is lambda
12:03:25 <Philippa_> \<bunch of patterns> -> expr
12:03:43 <Philippa_> f a b = g b a could be written f = \a b -> g b a
12:04:07 <twobitsprit1> I see
12:04:09 <cyanite> quite like ML here, except its syntax is more tedious.
12:04:25 <twobitsprit1> I don't know ML, but lambda makes sense from Lisp
12:04:28 <cyanite> yeah.
12:04:49 <cyanite> \a b -> x   is curry-sugar for  \a -> \b -> x
12:04:55 <ski> \x y -> x + y    (lambda (x) (lambda (y) (+ x y)))
12:05:24 <cyanite> glad I don't use lisp ;).
12:05:28 <twobitsprit1> ski: ahh, that was refreshing...t hanks :)
12:05:51 <eckroth> what's the history of the "s" for a list, as in "x:xs" or "ns = [1,2,3..]"?
12:05:55 <alar> LISP = lots of idiotic silly parentheses
12:06:03 <ibid> eckroth: the english language
12:06:07 <basti_> eckroth: maybe the english plural s?
12:06:09 <twobitsprit1> eckroth: my understanding is that it's plural
12:06:12 <eckroth> ahhhh
12:06:13 <ski> twobitsprit1 : all haskell functions strictly speaking take one argument  (which may be a tuple)
12:06:15 <cyanite> yeah.. and just convention.
12:06:19 <eckroth> right
12:06:53 <twobitsprit1> alar: I actually don't notice the parens in Lisp/Scheme any more...
12:07:03 <cyanite> yes, haskell is lambda calculus. functions bind exactly one variable.  multiple arguments is either tuples or curry :).
12:07:06 <cyanite> hehe....
12:07:26 <cyanite> I never used lisp, but... in scheme which i used for university, I still notice them a lot :p
12:07:34 <sieni> alar: don't be so mean, it was originally "lots of irritating superfluous parentheses"
12:07:52 <sieni> :-)
12:07:56 <twobitsprit1> well... of couse, I still see them, but not in the way that when I see scheme code all I see are parens...
12:08:02 <ski> cyanite : according to many people, scheme is a member of the lisp family
12:08:02 <alar> twobitspirit1 that makes me jealous, wish I could walk through such syntax freely
12:08:14 <cyanite> ski: yes... i know.. I mean.. kinda like a more pure lisp I suppose.
12:08:22 <Philippa_> more pure than which lisp?
12:08:36 <ski> Lisp 1.5, possibly ?
12:08:37 * Philippa_ does get irritated at arseholes who assume lisp = common lisp
12:08:38 <cyanite> I don't know lisp.
12:08:45 <cyanite> oh so now im an asshole?
12:08:52 <twobitsprit1> alar: use a Lisp language enough, and you'll either go insane, or learn to love the paren
12:08:54 <sieni> well, the lisp syntax is superior to either ml's or haskel's
12:08:57 <Philippa_> I don't know - do you assume lisp always means common lisp?
12:08:59 * sieni ducks
12:09:10 <cyanite> but.. I don't assume anything. I was TOLD that lisp is like a superset of scheme.
12:09:10 <Philippa_> sieni: for which purpose, obfuscation? ;-)
12:09:43 <Philippa_> then don't be so insecure. I wasn't commenting about you, I was commenting about a tendency among common lisp users
12:09:51 <alar> twobitspirit1: my experience with lisp is much like the first alternative
12:10:10 <Philippa_> personally I rate the SRFI for I-expressions
12:10:13 <twobitsprit1> my understanding is that "Lisp" is a very *very* simply language specification which is extended in implimentation to form the "Lisp languages" i.e. CL, etc
12:10:19 <cyanite> ...   ok, i'll try to work on my insecurity issues, Mr. Philippa.
12:10:26 <cyanite> but.. I didn't use lisp :p
12:10:33 <sieni> well, as they say that you have reached the lisp enlightenment when the parentheses disappear
12:10:38 <Philippa_> I think you'll find that's Miss or Ms
12:10:54 <cyanite> whatever, it's irc :p
12:11:07 <basti_> on irc we're all neutral?
12:11:22 * twobitsprit1 is neutral
12:11:23 <Philippa_> twobitsprit1: that's pretty much how I tend to use it. See McCarthy's 1960 paper, etc etc etc
12:11:24 <twobitsprit1> :P
12:11:29 <cyanite> no but given the many handles, makes it easier to assume some gender.  male for instance.
12:11:39 <basti_> .)
12:11:48 <Philippa_> especially when the nick's an ordinary female name?
12:12:02 <cyanite> I went on routine :p
12:12:05 <ski> (better not assume so much ..)
12:12:23 <alar> Philippa_ I suppose the underscore at the end confuses them )
12:12:27 * twobitsprit1 gets back to his tutorial...
12:12:27 <alar> Philippa_ I suppose the underscore at the end confuses them :)
12:12:51 <cyanite> heh.. no I just didn't think about it, that's all.  *shrug*.   no big deal I am sure.
12:12:55 <eckroth> twobitsprit1: may I ask which tutorial that is?
12:13:36 <Philippa_> alar: perhaps, but you have to've spent how little time on IRC to guess it's just the alt-nick for when I get dropped and reconnect too fast? :-)
12:13:52 <xerox> Æ) :-P
12:14:14 <Philippa_> xerox: for those of us not using your choice of charset? :-)
12:14:14 <twobitsprit1> eckroth: http://www.haskell.org/~pairwise/intro/intro.html
12:14:19 <eckroth> thanks
12:14:21 <cyanite> Æ rules.
12:14:38 <alar> Philippa_: even more, I've spent too little time on irc to guess your gender from nick spelling :)
12:14:41 <xerox> Philippa_: AE, alar wrote it some lines before
12:14:44 <ski> cyanite : danish 'AE' ?
12:14:53 <cyanite> yes, danish AE.  :)
12:15:07 <Philippa_> ah
12:15:10 <alar> umm
12:15:12 <xerox> ♥♥♥ UTF8 ♥♥♥
12:15:16 <eckroth> twobitsprit1: not sure how good that one is yet, but I'm working with "the craft of functional programming: haskell", and it's quite interesting
12:15:28 <sieni> An interesting thing happened today to me
12:15:33 <alar> I use 1251, there no danish AE in that charset :)
12:15:34 <twobitsprit1> eckroth: got a link for that? I'd like to check it out
12:15:41 <cyanite> ˙xoɹǝx ‘ǝʍ ʇuop ‘sǝʎ
12:15:45 <eckroth> twobitsprit1: it's a book, so amazon or whatever
12:15:51 <Philippa_> alar: my name does seem to be a bit less common outside the UK
12:15:51 <twobitsprit1> eckroth: I see
12:15:57 <sieni> I was chatting with this person which I already knew from irc, but hadn't privmsg'd before
12:15:57 <xerox> cyanite: didn't read
12:16:17 <sieni> then I checked the irc-gallery image of the person
12:16:23 <cyanite> xerox: no it takes some well stuffed fonts.  it's an 'upside down' script for my irc client :p
12:16:25 <sieni> http://irc-galleria.net/view.php?nick=LogiX
12:16:39 <ski> (Philippa_ : commonly known in sweden, at least)
12:16:51 <sieni> I then commented, that btw, you have nice looking chick there with you
12:16:52 <cyanite> ski: (although mostly without the underscore)
12:17:03 <sieni> then she commented, that "I am the chick" :-)
12:17:07 <cyanite> sieni: lol
12:17:20 <Philippa_> ski: it's apparently practically unknown in the USA, which has led to some amusing confusions. Like the guy who assumed I'm from the phillipines
12:17:21 <alar> =))
12:17:25 <sieni> the best ever accidental attempt to score :-)
12:17:41 <cyanite> hehe...   the order of the names on that pic should have given you a hint! ;)
12:17:44 <Philippa_> Nah. Trust me, I've had accidental attempts like that work :-)
12:17:54 <sieni> or whatever, I'm married anyway, but still :-)
12:19:07 <goron> Can't we just ban the word Lisp?
12:19:58 <cyanite> hmm?
12:20:56 <Philippa_> nah, sometimes it's useful to compare to
12:20:59 <goron> It's good to see Lisp once in your life... and all... but that's it.
12:21:09 <Philippa_> as in, "now we have hs-plugins, is there anything a Lisp can do that we can't?" :-)
12:21:15 <cyanite> I didn't see it...  still happy.
12:21:19 <cyanite> I did see scheme though.
12:21:45 <Philippa_> ooh, just had a thought. Will PM dons about it
12:21:52 <autrijus> Lisp is the most beautiful language... and lisp programs are among the most ugly.
12:21:53 <goron> Philippa_: Well, the license of hs-plugins isn't really good.
12:22:10 <goron> autrijus: Good summary.
12:22:27 <cyanite> lisp can't do anything we can't, since both languages can do the same ;).
12:22:29 <autrijus> goron: thanks, it's a lwall quote, not mine :)
12:22:38 <Philippa_> cyanite: that's not strictly true
12:23:01 <cyanite> Philippa_: In the most general sense. Both languages are 'complete'..
12:23:05 <Philippa_> haskell is statically typed, therefore there are likely things it can't do on account of not being able to prove they're safe at compile-time that lisp can do
12:23:21 <cyanite> yeah....   I meant simply: compute the same functions.
12:23:24 <Philippa_> and that has what to do with IO capabilities?
12:23:33 * Philippa_ nods
12:23:39 <Philippa_> turing completeness alone just isn't enough
12:23:49 <cyanite> well... depends on how you look at it.
12:23:53 <goron> super turing completeness!
12:23:53 <cyanite> but.....
12:24:01 <Philippa_> no, it just depends on your requirements
12:24:07 <Philippa_> I, for one, write much code that does IO :-)
12:24:08 * alar never m,et a thing that can be done in Lisp but not in Haskell
12:24:22 <twobitsprit1> can someone explain "points-free"?
12:24:28 <Philippa_> I've met plenty that can't be done in Haskell 98
12:24:35 <Philippa_> twobitsprit1: no named parameters, essentially
12:24:41 <cyanite> I didn't mean practical issues, but it was a more 'elevated' statement :p
12:24:53 <Philippa_> you mean elevated into the sewers? :-)
12:24:54 <goron> twobitsprit1: That means with a lot of points, oddly.
12:24:56 <TheHunter> Philippa_, you can argue that it's just the opposite: you can always easily embed dynamically typed stuff in a static language using a 'universal' type, but you'll definitely have a hard time to encode type classes in lisp since the require static analysis.
12:25:00 <cyanite> No.  up.
12:25:01 <alar> Philippa_ then you can point an example
12:25:21 <cyanite> And what can't be done in Haskell, then?
12:25:30 <Philippa_> automatically generating code to serialise a datatype
12:25:52 <cyanite> that's somewhat a meta feature though.  you can always generate entire new programs ;)
12:26:04 <Philippa_> it's still relevant
12:26:17 <cyanite> but I'm sure we agree.. I'm just playing the -functions are everything- card.
12:26:25 <goron> Philippa_: You don't want a program generating code at run-time on a production setup.
12:26:26 <Philippa_> yeah. AKA the "I forgot IO" card
12:26:29 <ski> twobitsprit1 : remember function composition from math ?  "f x = g (h x)" is not point-free while "f = g . h" is
12:26:36 <Philippa_> goron: did I say I wanted it generated at run-time?
12:26:46 <cyanite> Philippa_: no.
12:26:49 <goron> Philippa_: There's TH.
12:26:57 <ski> twobitsprit1 : also compare "squareAll xs = map square xs" with "squareAll = map square"
12:26:59 <Philippa_> yes. I *did* specify Haskell 98
12:27:13 <goron> Philippa_: Oh, when?  I missed that.
12:27:19 <twobitsprit1> ski: ok, so it's short-hand?
12:27:23 <cyanite> Philippa_: the functions are everything card. I stand by that, and IO can be seen under that also.    I am not doing a pragamatic argument, but a mathematical one.
12:27:32 <Philippa_> cyanite: you're wrong, then
12:27:40 <goron> It's a bit unfair to compare Haskell and Lisp in that way.
12:27:41 <Philippa_> once IO comes into it, the functions are no longer identical
12:28:03 <cyanite> Philippa_: I disagree that I am wrong.    Can still be put into that framework.
12:28:18 <goron> cyanite: Philippa_ is right.
12:28:35 <Philippa_> OK. Write me haskell code exactly identical in effect to the arbitrary piece of x86 machine code I have in mind...
12:28:50 <cyanite> Philippa_: That was exactly NOT what I claimed.
12:28:51 <alar> =)
12:28:54 <Philippa_> cyanite: wrong
12:29:10 <Philippa_> the minute you dragged mathematically analysing IO into it, you claimed exactly that
12:29:11 <cyanite> Philippa_: oh so now you are telling me what I mean?   great.
12:29:18 <cyanite> No I didn't.
12:29:21 <Philippa_> because execution time matters
12:29:25 <ski> twobitsprit1 : in a way, yes .. can be clearer at times, but can also be more unclear ..
12:29:26 <goron> Yeah, flame wars.
12:29:28 <cyanite> You must have misunderstood it then. I didn't.
12:29:31 <Philippa_> because every last damn effect you have on the state of the universe matters
12:29:34 <alar> is there lisp code idential in effect to the arbitrary piece of x86 code? :)
12:29:36 <Philippa_> otherwise, it ain't the same damn function
12:29:53 <Philippa_> alar: for the appropriate value of 'lisp' you can probably write the machine code in s-exprs :-)
12:29:55 * eckroth is, for one, learning something
12:30:09 <cyanite> Philippa_: Let's drop it shall we? :p.    You think I mean something I don't, so.. whatever :p
12:30:33 <ski> @pl \xs ys -> all (`elem` ys) xs
12:30:35 <lambdabot> flip (all . flip elem)
12:30:40 <alar> well, if time matters then only FFI saves us
12:30:56 * alar thinks that now he understands Philippa_
12:31:21 <Philippa_> <cyanite> Philippa_: the functions are everything card. I stand by that, and IO can be seen under that also.    I am not doing a pragamatic argument, but a mathematical one. <- if IO comes under that, you have to match exact World values. 'nuff said.
12:31:23 <cyanite> I understand her, but I am talking about something quite different... so no point in arguing.  especially not arguing what I mean.
12:31:25 <goron> Things like overwriting the complete stack with zero's should be pretty hard in Haskell :)
12:31:48 <TheHunter> could some native speaker say if "point-free" or "points-free" sounds better to them?
12:31:56 <Philippa_> point-free
12:31:58 <cyanite> Philippa_: Hehe.. It all comes down to definition of what IO is.  let's not discuss it though.
12:32:04 <Philippa_> cyanite: it's been done
12:32:06 <alar> goron: it depends on what is "complete stack" on your platform
12:32:14 <goron> alar: complete memory
12:32:22 <cyanite> Philippa_: Look, if it helps you to think you won this non-argument, be my guest:).
12:32:23 <TheHunter> Philippa_, thanks, that's what i've been thinking.
12:32:25 <goron> alar: I.e. in protected mode.
12:32:31 <alar> I can imagine platform where is it impossible in any language
12:32:51 <goron> alar: That's a void statement.
12:33:09 <Philippa_> cyanite: learn some damn precision. Thank you.
12:33:18 <goron> alar: You can always make something such that it does XYZ, with XYZ being something practical.
12:33:38 <cyanite> Philippa_: I felt I was being very precise, or that you could at least given my arguments deduce what I had in mind. Apparently not.
12:33:40 * Philippa_ makes a hammer with which to crash a system
12:33:54 <goron> You can do that in VB6
12:33:57 <goron> hehe
12:34:04 <alar> goron: yes, but that means you pointed not the feature of haskell, but a feature of an implementation
12:34:14 <Philippa_> goron: not if the system's not windows-based
12:34:24 <Philippa_> therefore a hammer is a better coding tool than VB6 ;-)
12:34:34 <goron> Philippa_: Someone made VB like language run under unix.
12:34:39 <goron> Philippa_: be feared.
12:34:43 <Philippa_> heh
12:34:46 <alar> lol
12:34:58 <alar> VB-like weapon :)
12:34:58 <Philippa_> what value of "VB-like"?
12:34:59 <eckroth> so, is there some distinction between "X can perform any computation" and "X can modify the state of the system in any way"? (trying to identify cyanite & Philippa_'s arguments, respectively)
12:35:09 <eckroth> goron: Gambas
12:35:21 <goron> Gambas make me puge.
12:35:26 <Philippa_> eckroth: there's a distinction between "compute any computable function" and "actually cause real things to happen in the real world"
12:35:29 <goron> Well, almost.
12:35:43 <Philippa_> the short version being that a Turing Machine can do the former but not the latter
12:35:50 <eckroth> Philippa_: would you consider IO to be only in the latter?
12:36:02 <goron> you can compute non-computable functions too.
12:36:11 <goron> It only won't finish.
12:36:13 <cyanite> eckroth: well....   by any computation I meant it in the mathematical obvious sense.   As for things in the real world, this is of no concern to me. IO _can_ be seen mathematically as functions with proper domains etc.    I didn't mean that it should make the machine reboot or pop up windows.
12:36:29 * alar does not understand this distinction
12:36:30 <cyanite> eckroth: but I admit that it does depend on how much and what you put in 'IO'
12:36:32 <Philippa_> cyanite: you're assuming eckroth knows what's "mathematically obvious"
12:36:41 <eckroth> cyanite: besides, if Haskell had the correct hooks, then it could..
12:36:44 <Philippa_> alar: which one?
12:37:04 <eckroth> Philippa_: which doesn't include IO (in "mathematically obvious")
12:37:09 <eckroth> for me
12:37:18 <alar> Philippa_: the one ecroth asked
12:37:36 <cyanite> eckroth: yeah....   true.   this is again a bit over in the realm of implementation.   as for my mathematically obvious: computing any numeric function suffices for me.   as in turing complete.
12:37:52 <Philippa_> note that cyanite apparently has no interest in doing anything real :-)
12:37:55 <alar> what's the difference between "computation" and "making thinfg to change in real-world"
12:38:06 <Philippa_> alar: "computation" is horribly overloaded
12:38:09 <alar> at least while realtime is not concerned
12:38:10 <FrederikEaton> am i missing a fight?
12:38:17 <eckroth> cyanite: so since IO delves into space beyond what's well-defined, it's implementation detail?
12:38:22 <alar> Philippa_:  yes
12:38:45 <alar> but I can't catch the meaning you use
12:38:47 <Philippa_> now, *I* use it in a manner that doesn't necessarily rule out IO. cyanite apparently doesn't.
12:38:57 <eckroth> cyanite: Also, remember that to be Turing Complete is rather easy
12:39:10 <Philippa_> (note that "computable function" != "computation" in my usage, that may be a bad thing)
12:39:13 <ski> cyanite : how about computable function in system operating on not-necessarily computable input data (e.g. stream of input chars ..) ?
12:39:36 <cyanite> eckroth: Just because I am a mathematical purist, I get accused of not wanting to do real stuff ;).  No I mean, of course if IO is seen in a broad sense or if you ask: can this interactive program be coded in lisp and haskell, then they aren't the same.   If IO is seen more like just... function from 'input domain' to 'output domain', you can frame it in math, and it would be enough to make the languages equally powerful.
12:39:46 <cyanite> eckroth: yes I know that.. it doesn't take much to be turing complete.
12:40:04 <cyanite> ski: I meant in the sense of turing complete, to be precise.
12:40:05 <Philippa_> cyanite: you're going to have to define one mean equivalence
12:40:10 <alar> Philippa_: put cyanite's meaning aside, I don't understand _your_ meaning
12:40:34 <cyanite> Yeah I meant...   seeing IO as a function, you can do the same.
12:40:43 <Philippa_> alar: "computation" probably isn't relevant. A "computable function" is a function in the mathematical sense which can be computed by a computer without any requirement for additional input
12:40:44 <eckroth> cyanite: well, I'm just saying now that your comment, Lisp & Haskell can do the same stuff, is not very powerful.. do you agree?
12:41:05 <cyanite> eckroth: completely!   which is why I had a smiley by it :)
12:41:10 <eckroth> ok :)
12:41:40 <Philippa_> cyanite: I'm insisting that you cannot get actual equality across all possible programs. You need an equivalence which ignores various aspects of the underlying mathematical model
12:42:03 <eckroth> Philippa_: even in terms of only well-defined functions?
12:42:07 <Philippa_> which is why I told you off for being imprecise. If you model everything as functions, you gotta model the whole universe...
12:42:18 <Philippa_> eckroth: what counts as "well-defined" here?
12:42:34 <alar> Philippa_: as long there is no realtime /multithreads/etc, what's the difference between "strict mathematical" and "your" meanings?
12:42:36 <eckroth> Philippa_: well, not IO... the definition's been stated before
12:42:37 <cyanite> Hm.... well it's always with respect to some, given, equivalence concept of course. I don't want to model the universe, just IO in the sense as functions from some fixed input domain to a fixed output domain.
12:42:44 <Lemmih> Hi SyntaxNinja.
12:43:01 <eckroth> cyanite: but they still aren't well-defined, are they?
12:43:04 <Philippa_> cyanite: your input and output domains involve universe states. HTH
12:43:08 <Lemmih> SyntaxNinja: We need to change the Apache config on h.g.c
12:43:20 <cyanite> HTH? what does that mean?
12:43:27 <Philippa_> Hope That Helps
12:43:44 <cyanite> It would help if you were less hostile :p
12:44:02 * goron hands Philippa_ a machine gun.
12:44:08 <twobitsprit1> hmm... right-associative: "a -> b -> c" can be writen "a -> (b -> c)" or is it "(a -> b) -> c"?
12:44:15 <cyanite> eckroth: Not well-defined? well... input/output at a computer is pretty well-defined, keyboard.. screen.   large and complicated domains, for sure, but still.
12:44:16 <alar> Philippa_: yes, they does model, but, again, there is no difference
12:44:19 <SyntaxNinja> hi Lemmih
12:44:22 <Lemmih> twobitsprit1: The former.
12:44:26 <ski> twobitsprit1 : the former
12:44:34 <twobitsprit1> alright, thanks
12:45:00 <Philippa_> alar: at that point, your mathematical function cares rather a lot about exactly how the code does stuff
12:45:04 <eckroth> cyanite: well, of course I meant for the function "getLine(stdin)", the result is not well-defined, and involves states beyond Haskell's control (I believe)
12:45:12 <cyanite> eckroth: I realize I was taking a very abstract and not in any way pragmatic or practically useful view.  Just to make that clear.
12:45:20 <eckroth> ok
12:45:20 <Philippa_> yeah, that's not well-defined in the absence of a handy state-of-universe
12:45:38 <cyanite> eckroth: Right.... but as haskell also implements those, with monads, your program simply becomes a function from 'all possible input' to output.
12:46:17 <ski> (in Clean, one'd use (unique) values of type World)
12:46:35 <ski> (Start :: *World -> *World)
12:46:37 <cyanite> eckroth: which is a quite cool thing in haskell IMO :).
12:46:45 <alar> Philippa_: this not-well-definedness is not just haskell feature, the state of universe is always not-well-defined
12:46:47 <eckroth> cyanite: yeah, which I have yet to grok :)
12:46:58 <Philippa_> alar: sez you. God may feel differently ;-)
12:47:03 <alar> so haskell is not better that anything else when dealing with IO
12:47:04 <cyanite> eckroth: yeah... it's a bit ....  I'm pretty new to it myself.
12:47:11 <eckroth> Philippa_: but god programs in Lisp
12:47:18 <SyntaxNinja> hi FrederikEaton
12:47:20 <Philippa_> ah, that explains his many mistakes
12:47:27 <SyntaxNinja> @seen FrederikEaton
12:47:28 <eckroth> heh heh
12:47:28 <lambdabot> FrederikEaton is in #haskell. Last spoke 9 minutes and 17 seconds
12:47:28 <lambdabot> ago.
12:47:46 <Philippa_> alar: nearly - you can do a lot more to control what is and isn't possible than in most languages
12:47:54 <ski> eckroth : according to Julia Ecklar and Bob Kanefsky, yes
12:48:07 <eckroth> ski: I know I read it somewhere..
12:48:12 <Philippa_> you can create IO-like monads that offer a subset of the features and can be turned into IO actions, stuff like that
12:48:15 <cyanite> eckroth: by using monads like that, there is no state really.   it's done away with, moved out of the program..  your program becomes a function.   feed it a state, it gives one back :)
12:48:17 <mflux> hmm.. let's say you want to sortBy something by using something that needs to be in the IO monad (let's say you're sorting a list of IORefs, or maybe your sort function needs to be in IO), how to go about it?
12:48:24 <twobitsprit1> can I put a space after the '\' in a lambda form? i.e. "\ a -> a + 1"
12:48:42 <Philippa_> yup, IO is a wrapper for State World :-)
12:48:43 <cyanite> yes
12:49:03 <cyanite> twobitsprit1: almost positive.  quickest for you is to try! :p
12:49:26 <FrederikEaton> SyntaxNinja: hi
12:49:45 <cyanite> eckroth: I guess this ends the discussion....    :).
12:49:48 <twobitsprit1> cyanite: heh, forgot I had GHCi open :P
12:49:55 <twobitsprit1> cyanite: so yes, you can
12:49:59 <cyanite> twobitsprit1: *twap*    good :).
12:50:17 <eckroth> cyanite: well, owing to my lack of knowledge of Monads :)
12:50:33 <mflux> I suppose one option, in the case of IORefs, would first to produce a list with the current value paired with the IORef, but what if the actual comparison would need (for some obscure reason ;)) to be in the IO monad?
12:50:40 <FrederikEaton> SyntaxNinja: just in time for a question. i just recompiled a package and now its dependencies aren't getting properly followed.
12:50:42 <FrederikEaton> depends: base-1.0 posix-1.0 haskell98-1.0
12:50:50 <FrederikEaton> Could not find module `POpen':
12:50:50 <FrederikEaton>   it is a member of package posix-1.0, which is hidden
12:51:01 <FrederikEaton> any ideas?
12:51:09 <FrederikEaton> i didn't really change anything
12:51:16 <basti_> FrederikEaton: you should expose the package
12:51:17 <cyanite> eckroth: no, but I mean... I think it boils down to:  monads are a way to model IO into a function.   this was my point when I claimed equivalence, since the two languages DO compute the same functions.    but this completely ignores that IO _isn't_ implemented in that way in lisp of course.
12:51:27 <SyntaxNinja> FrederikEaton: did you reconfigure?
12:51:28 <cyanite> eckroth: as far as I know, which isn't too far when it comes to lisp.
12:51:38 <basti_> ghc-pkg expose posix should do it
12:51:53 <FrederikEaton> SyntaxNinja: yeah
12:52:08 <eckroth> cyanite: well, common lisp, ie, just has stuff like "getline" or whatever, I believe... most lisps degrade into the non-functional rather quickly
12:52:38 <FrederikEaton> basti_: that works... but why did it work before?
12:52:40 <cyanite> eckroth: yes.   I thought so, also.    you CAN shortcircuit the monad stuff in haskell also.
12:52:49 <FrederikEaton> maybe i upgraded ghc or something
12:52:58 <basti_> FrederikEaton: that might be the reason
12:53:00 <Philippa_> cyanite: the problem is that they're not necessarily the same function :-)
12:53:19 <Philippa_> they're potentially closely related, sure
12:53:33 <Philippa_> strictly speaking there's no way to break out of the IO monad in haskell 98
12:53:38 <eckroth> cyanite: interestingly, perhaps, the only real IO is with a human, who can be persuaded into being not-so-random or time-dependent; all computer-based data could be written in Haskell, too (say), keeping everything pretty and functional
12:53:40 <alar> cyanite: what do you mean by "shortcircuiting the monad stuff"?
12:53:41 <Philippa_> many compilers have backdoor hacks for those who need them
12:53:45 <cyanite> Philippa_: If my program is a function from 'all input' to 'all output', the mechanics of the function itself can be implemented in any turing complete language.
12:53:56 <Philippa_> cyanite: it's not. HTH, HAND
12:53:58 <cyanite> eckroth: yeah...  :)
12:54:13 <SyntaxNinja> FrederikEaton: you shouldn't expose that posix module, that's not the right fix.
12:54:15 <Philippa_> the function the IO monad wraps is considerably more specific than that
12:54:39 <cyanite> Philippa_: this is where we apparently diagree.  and I don't get your HTH and HAND and whatever other gloating or otherwise things.
12:54:40 <SyntaxNinja> FrederikEaton: if you've ./setup clean ;./setup configure; ./setup build -v4 doesn't fix it, then let's see the ghc line
12:54:49 <ski> eckroth : there's a song by them about how god created the world in lisp  (The Eternal Flame .. )
12:54:59 <eckroth> ski: yeah, read that once
12:55:10 <cyanite> alar: I mean...   escape the monad, thus escaping that your program is a function from input to output.
12:55:10 <dcoutts> FrederikEaton, the posix package is one of the old hslibs collection which does not use heiricharcal module names and so they should not be exposed since they pollute the module namespace
12:55:16 <Philippa_> cyanite: we don't just disagree. You are *WRONG*. Go read a decent treatment of the denotational semantics of IO in the presence of threads, intercommunicating OS processes etc etc etc
12:55:19 <eckroth> ski: for other fun, look up "Joe Lisp, T Man"
12:55:49 <alar> cyanite: do you mean using hacks such as mutable vars?
12:55:53 <Philippa_> even if you insist on thinking of input and output as streams of events, they need timestamping and all sorts to get an accurate model of what's going on
12:56:00 <cyanite> Philippa_: I didn't talk about threads, but simple IO.  I am not wrong, we disagree.
12:56:00 <ski> eckroth : i think i saw somewhere an explanation that god actually lazilly created the world (as in forcing thunks) .. can't seem to find that now, though :(
12:56:03 <FrederikEaton> SyntaxNinja: ok, just a minute
12:56:16 <eckroth> ski: hmm, sounds good :)
12:56:20 <cyanite> alar: I mean the unsafeIO stuff you can do to make IO a into a.
12:56:27 <Philippa_> cyanite: you're fucking handwaving again. The IO monad isn't restricted to your "simple IO", there's the whole damn FFI to deal with
12:56:37 <eckroth> FFI?
12:56:44 <Philippa_> Foreign Function Interface
12:56:45 <alar> Philippa_: when timestamping comes into play the model of functional languages is broken
12:56:46 <eckroth> ah
12:56:53 <SyntaxNinja> FrederikEaton: on another topic, do you want to be the keeper of the cabal todo list / design forum? I'd obviously help out, but having someone to keep it organized is the main thing.
12:56:53 <Philippa_> alar: surprisingly, no
12:57:06 <cyanite> You should just chill out.   yeah I don't know what FFI is either.  But I maintain my argument.   Quite clearly, there is no reason to discuss it further though.
12:57:21 <jlouis> what are we arguing on?
12:57:25 <alar> Philippa_: how?
12:57:31 <cyanite> Best to forget it, jlouis :p
12:57:41 <Philippa_> alar: functions from (oldtime,input) -> (newtime,output), stuff like that
12:57:42 <eckroth> so a functional language is necessarily time-independent? (alar claims, Philippa_ denies)
12:57:47 <cyanite> I am done, at least.  hehe.
12:57:48 <mflux> and I suppose actual time stamping isn't required; plain serial numbering will do
12:57:54 <alar> Philippa_: no
12:58:13 <alar> oldtime,newtime != realtime of computation
12:58:25 <Philippa_> alar: sez you :-) Why shouldn't they be?
12:58:49 <mflux> but time stamps must be convenient when dealing with the real world
12:58:52 <Philippa_> they are, however, relevant to how the function proceeds. Because the input stream is all of a sudden a function of the output stream
12:59:17 <mflux> but they suck if someone adjusts the clock ;)
12:59:17 <alar> Philippa_: if you bend time of events to be unrelated to time of their processing - you turn back to computable functions and math
12:59:57 <Philippa_> alar: perhaps you meant something different to what I thought when you wrote "realtime of computation" then?
13:00:08 <eckroth> I vaguely recall there existing some form of logic that accounts for time..
13:00:33 <eckroth> perhaps that coupled with "math" can yield more interesting programming languages :)
13:00:46 <Philippa_> eckroth: temporal logic's a nice thing to have on occasion
13:00:51 <alar> Philippa_: I meant that if realtime of computation is somehow concerned then order of operations matters -> we're no longer strictly functional
13:01:13 <Philippa_> alar: depends what you think the function is
13:01:21 * eckroth is away: gotta go
13:01:26 <cyanite> eckroth: take care.
13:01:32 <eckroth> thanks cyanite, you too
13:03:19 <Philippa_> in the long run, you end up with the model that's appropriate for haskell as used in the "real world" - the function takes one state-of-universe and returns another
13:03:34 <Philippa_> that's still a function. You just don't really want to specify it quite that way
13:03:42 <FrederikEaton> SyntaxNinja: /home/frederik/arch/i386/bin/ghc -package-name Futility -odir dist/build/. -hidir dist/build/. --make -i. -fallow-overlapping-instances -fallow-undecidable-instances -package base-1.0 -package posix-1.0 -package haskell98-1.0 Fu.ContParse Fu.ParParse Fu.GenUtil Fu.HMM Fu.NBParam Fu.NB Fu.Param Fu.RevModeDiff Fu.RevModeMultiDiff Fu.Solve Fu.HashHeap Fu.MonadComp Fu.Debug Fu.SysUtil Fu.Logging Fu.MD5 Fu.HList Fu.GetOptions Fu.Binary Fu
13:03:42 <FrederikEaton> that got cut off
13:03:47 <FrederikEaton> .FastMutInt
13:04:04 <Philippa_> "Fu.ContParse" may be somewhat unfortunate
13:04:09 <xerox> SyntaxNinja!!!111oneoneoneone
13:04:12 <alar> Philippa_: only if I'm interested in the state of "real world" :) I'm not god to need to know it :)))
13:04:31 <Philippa_> alar: you might be bothered as to whether your program's caused the big red button to be pushed or not, no?
13:04:33 <SyntaxNinja> xerox: ?
13:04:40 <Philippa_> especially if you're writing ICBM control systems...
13:04:47 <xerox> SyntaxNinja: I think galois.com has some problem with .hs in urls
13:04:56 <xerox> @where cairo
13:04:58 <lambdabot> I know nothing about cairo.
13:04:58 <SyntaxNinja> xerox: check again :P
13:05:11 <alar> Philippa_: BRB is only samll part of "real world" and can be expressed strictly :)
13:05:13 <FrederikEaton> Philippa_: i don't get it
13:05:24 * xerox hugs SyntaxNinja
13:05:28 <xerox> Danke :)
13:05:43 <Philippa_> alar: now express all the other ways it could end up pushed or otherwise...
13:05:45 <SyntaxNinja> FrederikEaton: hmm. that looks correct to me. it's clearly including the posix-1.0 module.
13:05:56 <Philippa_> prove your control system doesn't get hit by cosmic rays. Etc etc etc
13:06:06 <Philippa_> FrederikEaton: what did Parse to do deserve such abuse?
13:06:15 <SyntaxNinja> xerox: :)
13:06:31 <alar> Philippa_: why? I'm not god to program  uch tasks :)
13:06:39 <alar> uch = such
13:06:43 <Philippa_> you don't need to be god. When your code is run, such things may happen
13:06:56 <Philippa_> therefore, if your code is a function, it's a function that models those possibilities
13:06:59 <alar> Philippa_: any code is _incomplete
13:07:02 <SyntaxNinja> FrederikEaton: I take it this is 6.4?
13:07:05 <FrederikEaton> Philippa_: it is a continuation parser.
13:07:19 <alar> any code omits some possibilities
13:07:28 <FrederikEaton> SyntaxNinja: 6.4.1 devel version
13:07:39 <Philippa_> FrederikEaton: I know it is. Unfortunately the first two tokens read as if they could be pronounced "Eff You Cont", which is pretty close to being abusive
13:07:45 <Philippa_> alar: you seem to misunderstand
13:07:46 <cyanite> If we don't restrict ourselves to discussing a well-defined mathematical 'universe', it makes little sense to discuss what programs do anyway.
13:07:53 <SyntaxNinja> FrederikEaton: hmmmmm then wehere is the -fhide-all-packages flag?
13:08:05 <Philippa_> cyanite: have an abstract universe and a time-step function. Thanks.
13:08:26 <alar> Philippa_: I seem to miss your meaning of something again
13:08:35 <cyanite> Philippa_: Time can be encoded in the domain as a dimension, we don't need any real temporal element IMO.
13:08:40 <Philippa_> alar: the code doesn't specify all that because the universe just behaves like that
13:08:42 <FrederikEaton> Philippa_: oh. then it would be spelled "FU.CuntParse"
13:08:54 <Philippa_> FrederikEaton: yes, but you're close enough that if I spot it...
13:09:17 <Philippa_> that behaviour is effectively one of the program's inputs
13:09:20 <alar> cyanite: sometimes we do need real temporal elements
13:09:24 <FrederikEaton> Philippa_: i think i'll leave it that way to offend sensitive people
13:09:29 <Philippa_> heh
13:09:48 <alar> but I don't know a platform that deals with real temporal elements good
13:09:55 <cyanite> alar: We have them in real life of course, but they can be modelled as a dimension in a domain.
13:10:13 <FrederikEaton> SyntaxNinja: you detect ghc version and pass -fhide-all-packages?
13:10:14 <Philippa_> alar: you don't need to
13:10:24 <Philippa_> it tends to happen as a side-effect of evaluation
13:10:32 <SyntaxNinja> FrederikEaton: yeah; let's see the configfure output relating to ghc and the output from ghc --version, please?
13:10:33 <cyanite> alar: Not saying we SHOULD do this to define programming languages and what programs do... my point is we _could_.  :).
13:10:37 <SyntaxNinja> FrederikEaton: I'm very confused.
13:10:42 <SyntaxNinja> actually
13:10:48 <SyntaxNinja> why don't you just paste the entire thing to the paste page
13:10:52 <SyntaxNinja> @wiki paste
13:10:52 <lambdabot> http://www.haskell.org/hawiki/paste
13:10:54 <SyntaxNinja> from configure onward
13:10:59 <SyntaxNinja> @paste
13:11:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:11:45 <jlouis> ''I have it! Lets just add parallel-or to all languages!''
13:12:46 <alar> jlouis: parallel-or is not powerful enough
13:12:57 <cyanite> enough for what?
13:13:17 <jlouis> alar: oh.. interesting. All the models I've seen are ''too big'' in the sense they include parallel-or
13:14:09 <alar> cyanite: enough for me
13:14:14 <cyanite> hehe.
13:14:29 <alar> this element somehow introduces "handriting-optimization"
13:14:34 <cyanite> alar: Ok, I didn't follow the discussion before. Seemed a banch off from the one I had :p.
13:15:23 <alar> you have to explicitly code "parallel-or"
13:18:47 <ski> parallel-or as in the Topology in Haskell paper ?
13:19:08 <SyntaxNinja> FrederikEaton: check your msgs
13:20:10 <FrederikEaton> @paste
13:20:11 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:20:11 <ski> or :: S -> S -> S; or S S = S; or S _|_ = S; or _|_ S = S; or _|_ _|_ = _|_                   with   data S = S
13:22:32 <SyntaxNinja> FrederikEaton: I don't understand that output; it doesn't sound like the error you mentioned before.
13:23:27 <FrederikEaton> SyntaxNinja: irc messages? i don't see any since you signed on
13:24:17 <SyntaxNinja> FrederikEaton: I just sent you another one
13:25:08 * eckroth is back
13:26:10 <lispy_> @eval let foo undefined = 1 in foo undefined
13:26:25 <lambdabot> 1
13:26:37 <FrederikEaton> SyntaxNinja: oh, that's the compilation log
13:26:42 <lispy_> alright, i didn't expect that to work
13:26:53 <eckroth> so, regarding all this functional vs. non-functional stuff: a mathematician works purely in the functional environment, providing the inputs himself(herself); there is no consideration for problems (side-effects) in the evaluation (stack overflow, whatever); but on a computer, for some reason, all that side-effect stuff does matter, and functional languages "can'
13:26:55 <eckroth> whoops
13:26:57 <eckroth> continued:
13:27:02 <SyntaxNinja> FrederikEaton: yeah, looks like it builds fine
13:27:12 <xerox> lispy_ it does not evaluate its argument
13:27:30 <lispy_> xerox: obviously :)
13:27:32 <eckroth> "can't do IO"... what is the leap from the mathematician's world to the programmatic world?  cannot the IO simply be seen as providing the initial argument?
13:27:49 <Philippa_> eckroth: it can
13:27:54 <cyanite> eckroth: but moands show that you can.
13:27:58 <lispy_> eckroth: in haskell monads are used to "encapsulate" that leap
13:28:12 <Philippa_> the monad's there to stop you expressing a bunch of impossible functions
13:28:25 <eckroth> so monads solve it all?  great!
13:28:31 <cyanite> with the monad there, it's still in the math domain.
13:28:35 <Philippa_> for example, the winTheLottery function, which happens to evaluate next week and then use the answer today
13:28:37 <cyanite> but I think others disagree ;).
13:28:59 <eckroth> very interesting..
13:29:16 <eckroth> is Haskell more-or-less unique in it's "handling" of this situation?
13:29:21 <eckroth> its*
13:29:21 <Philippa_> currently
13:29:27 <Philippa_> it won't be in the long run though
13:29:29 <eckroth> right
13:29:39 <cyanite> as for functional programming languages, but monads are used in other places.
13:29:43 <Philippa_> Clean does something related, in that it uses uniqueness types to prevent you using a given World value twice
13:30:15 <cyanite> ... I don't think I like that approach but.. I don't know, haven't seen it in more detail.
13:30:40 <cyanite> since it takes me out of the math frame I like to be in :p.  it seems.
13:30:42 <eckroth> do ye irc'ers feel the monad approach is a complete solution? (not that I have qualms with it)
13:30:58 <Philippa_> yeah, it gets it all right
13:31:13 <cyanite> I'm all for it, also.
13:31:21 <lispy_> sometimes with mondas i feel like i'm "gaming the system"
13:31:28 <cyanite> :)
13:31:32 <cyanite> yeah
13:31:33 <lispy_> which can be frustrating :)
13:31:33 <eckroth> so, what would be a problem in Common Lisp, for example, when you use "getline"?
13:31:50 <Philippa_> cyanite: the Clean approach yields programs that are every bit as much functions as those that use monadic IO
13:31:51 <cyanite> eckroth: purity.  takes you out of the frame where functions are 'pure'
13:31:53 <eckroth> is it just that you're no longer "functional"?
13:31:55 <eckroth> ok
13:31:59 <lispy_> common lisp is operational functinoal, so thing happen in order
13:32:11 <Philippa_> though "just" may be an understatement
13:32:13 <cyanite> Philippa_: I won't argue before I know how Clean does it. :p.
13:32:24 <Philippa_> cyanite: I just told you. Feel free to RTFM for further info
13:32:40 <cyanite> Philippa_: yeah yeah get off my back
13:32:44 <Philippa_> if everything's pure, you have a lot more ability to analyse
13:32:51 <eckroth> lispy_: and people don't like that because it makes the execution less obvious and harder to debug?
13:32:52 <ski> eckroth : linear/uniqueness typing (as in Clean .. or Mercury) can also be used to handle IO and the World
13:33:05 <eckroth> hmm
13:33:12 <Philippa_> that's why Haskell's type system is more powerful in practice than, say, C++'s (which happens to be turing complete but can't prove much about absence of behaviours)
13:33:19 * ski should catch-up before replying ..
13:33:29 <lispy_> eckroth: the execution in lisp is very obvious, and easy to debug.  Many people really like lisp, so i'm not sure what you mean.
13:33:51 <xerox> ski: I was thinking the same thing :-)
13:33:54 <cyanite> eckroth: Monads at least, make it so your program conceptually becomes a 'function from input to output'.  which is good, in my mind.
13:33:57 * nealar lost the point of dscussion
13:34:15 <eckroth> lispy_: well, don't Haskell people (or other functional purists) dislike operational functional evaluation (does that mean order counts?)?
13:34:23 <Philippa_> eckroth: if something's in the IO monad, you can tell from its type
13:34:34 <ski> cyanite : the linear/uniqueness approach is also nice and a good other POV
13:34:37 <Philippa_> eckroth: evaluation orders have their own advantages and disadvantages
13:34:42 <eckroth> ok
13:34:56 <cyanite> ski: Might be...  I haven't yet "RTFM" as Philippa nicely suggested, so I can't tell :).
13:35:00 <Philippa_> non-strict evaluation gives you some extra algebraic properties
13:35:12 <Philippa_> OTOH, both of them behave differently regarding space and time
13:35:14 <xerox> ski: POV = ?
13:35:20 <Philippa_> Point Of View
13:35:31 <ski> (cyanite : though, given linearity, one can of course build an IO monad atop of that, in-language ..)
13:36:00 <ski> cyanite : there was some paper comparing IO in haskell and clean, with this approach, i think
13:36:09 <Philippa_> yeah, it's nice and easy to prove that the monad has linear behaviour and thus doesn't look into the future that way
13:36:16 <cyanite> ski: ok.   the important thing for me is that it can be modulated as a function in the end.  which was the base of my argument earlier, which we will not bring up again ;).
13:36:33 <cyanite> ski: but I will look at it... i'd like to know how they do it:)
13:36:36 <Philippa_> cyanite: we don't disagree as to whether IO can be modelled by a function
13:36:51 <cyanite> I thought we did?.
13:36:54 <Philippa_> we disagree as to what that function is, and thus whether the sets of functions expressible by various languages overlap
13:37:06 <lispy_> so i have a server, which uses forkOS to handle multiple socket  connections.  I use hGetBufNonBlocking to read from the sockets, but my program appears to block when i do that.  I replaced the call to hGetBufNonBlocking with |return "foo"|, and my program does not block.  How can i debug this?
13:37:09 <twobitsprit1> do you have to put "where" on a line by itself, or can I use "where" in one-liners?
13:37:12 <cyanite> Aha, yes, I maintain that they do.
13:37:16 <FrederikEaton> SyntatxNinja: i found the problem. it was because i was executing the script from the directory that contained a package that the script used! that was the problem!
13:37:27 <lispy_> twobitsprit1: possile with oneliners
13:37:29 <FrederikEaton> how do i prevent that from being a problem!
13:37:34 <Philippa_> yes. And you're still wrong because your functions fail to take all possible circumstances during execution into account
13:37:39 <FrederikEaton> i need the script to help me maintain the package
13:37:41 <lispy_> @eval let foo x = y where y = x+1 in foo 2
13:37:43 <lambdabot> 3
13:38:05 <cyanite> Philippa_: you should learn some arguing skills.  You just come off as annoying.. so why don't you back off, I told you I don't want to bring it up.
13:38:07 <twobitsprit1> I see
13:38:13 <Philippa_> and /that/ was why my comment about you not caring about the real world
13:38:22 <Philippa_> not "because you're a mathematician"
13:38:29 <cyanite> whatever, Philippa.  next topic.
13:38:54 <ski> (cyanite : Mecury's solution is quite similar to Clean's (imo), though they express linearity/uniqueness through instationations&modes, instead of through types)
13:39:02 * twobitsprit1 doesn't believe in the real world.
13:39:13 * lispy_ doesn't believe
13:39:14 <cyanite> ski: ok.  im gonna have to take a look at it :).
13:39:23 <ski> :)
13:39:29 * twobitsprit1 believes that lispy_ doesn't believe
13:39:48 <SyntaxNinja> FrederikEaton: are they actually two separate packages?
13:39:59 * ski believes Ranbow - Stargazer is a good tune :)
13:39:59 * lispy_ doesn't believe that twobitsprit1 believes that lispy_  doesn't believe
13:40:02 <Philippa_> cyanite: bear in mind that Clean and Mercury both use models that follow my notion here...
13:40:14 <ski> (s/RanBow/Rainbow/)
13:40:20 <twobitsprit1> :P
13:40:43 <cyanite> before I know anything about either of those two languages., I can't really say much interesting.
13:40:46 <cyanite> about them.
13:40:47 <lispy_> so uh...anyone have an idea how i can debug my "blocking" problem?
13:40:49 <cyanite> ;)
13:41:04 <lispy_> the code is sort of long and messy from my experimentations
13:41:15 <lispy_> maybe i should post it somewhere
13:41:28 <Philippa_> posting good
13:41:36 <Philippa_> it's a lot easier to debug the whole if you can see the whole
13:42:16 <FrederikEaton> SyntaxNinja: no it's a script and a library package. the script uses the library. but i need to execute the script in the directory that holds the library...
13:42:30 <lispy_> http://projects.codersbase.com/repos/hud  <-- specifically, Hud.hs
13:42:49 <FrederikEaton> SyntaxNinja: when i execute it in any other directory it's fine, but in the directory that holds the library it tries to use the source files in preference to the installed library package
13:42:58 <lispy_> Philippa_: i'm less interested having someone do it for me, and more interested in learning how to do it
13:43:21 <twobitsprit1> is _ used anywhere except at the beginning of a function definition?
13:43:53 <lispy_> twobitsprit1: anywhere where a variable can be named
13:43:55 <SyntaxNinja> FrederikEaton: maybe move the sources to a sub directory or something
13:44:04 <SyntaxNinja> then use hs-source-dirs to tell cbal where to find them.
13:44:19 <lispy_> twobitsprit1: [ 1 | _ <- [1..10]] would make a list of 10 ones
13:44:35 <Heffalump> as would replicate 10 1 :-)
13:44:38 <lispy_> twobitsprit1: it can also be used in case
13:44:39 <twobitsprit1> lispy_: I see :)
13:45:05 <twobitsprit1> lispy_: feel like giving me a case example?
13:45:13 <lispy_> @eval take 10 (repeat 1)
13:45:15 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
13:45:33 <lispy_> twobitsprit1: case e of _ -> undefined
13:45:43 <lispy_> twobitsprit1: in that case, everything is undefined
13:45:47 <twobitsprit1> ok, I see
13:45:58 <FrederikEaton> SyntaxNinja: that's terrible
13:47:17 <twobitsprit1> ok... I think I'm ready to start examining example code... any good reposatories of example code (preferably real code that does something interesting, as opposed to a million-and-one examples of fib)
13:47:52 <lispy_> twobitsprit1: http://projects.codersbase.com/repos  has several programs in haskell
13:48:15 <lispy_> twobitsprit1: i'm new to the language so some of it is going to be "weird" or ugly
13:48:51 <lispy_> twobitsprit1: autoproc is probably a good one to look at, i used modules, and algebriac data types and transformations and so on
13:48:56 <Philippa_> twobitsprit1: there's a couple of things on my site - a simple wiki and something that might be done in a perl script. http://flippac.org/projects/
13:49:12 <Philippa_> those'll be good if you want to convince yourself IO is easy
13:49:23 <lispy_> heh, weasleworks, nice :)
13:49:39 <lispy_> except i misspelled it
13:50:19 <lispy_> did anyone take a second to look at Hud.hs?
13:51:05 <lispy_> it behaves as tho blocking is happening in hGetBufNonBlocking, but since that is a library function, i doubt that's really the case
13:51:11 <twobitsprit1> lispy_, Philippa_: thanks :)
13:51:16 <lispy_> twobitsprit1: np
13:51:39 <lispy_> twobitsprit1: the nehe tuts might be fun (but convoluted) if you want to learn opengl
13:54:52 <twobitsprit1> it seems to me a like a lot of code is put in do clauses making things a bit imperative...
13:55:55 <cyanite> but they only seem so:).
13:55:57 <Philippa_> yeah, the little siggen app's inherantly rather imperative in nature
13:56:32 <Philippa_> Flippi's less so - all the stuff in the parser's using Parsec, it's not the same as IO
13:58:38 <Philippa_> that's one of the neat things about monads, you can have a wide range of semantics - well-ordered evaluation with IO is but one of them
13:59:10 <ski> twobitsprit1 : 'do' and monads are used to express "effects" in haskell, examples of which can be : IO,(Local) State,Exception,Nondeterminism (a bit like Prolog,if you know that),Parsing,etc ..
13:59:14 <nealar> there's also imperative-like style with state monads :)
13:59:47 <Philippa_> yeah, and a hell of a lot of monads that're imperativeish with some abstract machine wrapped inside what'd otherwise be a state monad
14:00:01 <Philippa_> (unification's an easy example, though it's easier to base it around ST than State)
14:00:58 <ski> twobitsprit1 : you are prolly just accustomed to the effects of IO,State and Exception  (though, Scheme has Continuation, too)
14:01:23 <twobitsprit1> ski: maybe
14:02:01 <nealar> the fun with SM is that imperative-like code is transformed to normal function style when compiler unrolls do-comprehension
14:02:38 <twobitsprit1> nealar: SM?
14:02:45 <ski> (imperative languages have IO and State effects as *side*-effects .. in some cases also Exception effects)
14:02:45 <twobitsprit1> You referring to Scheme?
14:02:59 <nealar> state monad
14:03:27 <Philippa_> and here I was thinking you meant sadomasochism
14:03:42 <nealar> lol
14:03:58 <mwc> Philippa_, I think you mean Sadism & Masochism
14:04:00 <jlouis> @botsnack
14:04:01 <lambdabot> :)
14:04:02 <lispy_> okay, my program is not blocking like i thought.  It's just not doing something else....
14:04:09 <mwc> A sadomasochist would be a whole new level of patholog
14:04:10 <mwc> y
14:04:29 <Philippa_> meh, I know enough folks who're switch
14:04:32 <twobitsprit1> ok, so here's an interesting question... how does one debug in haskell?
14:04:54 <mwc> I suppose a sadomasochist would be like those people who cut themselves to get an endorphin high
14:04:58 <Philippa_> also, outside the medical profession they're not pathologies at all
14:04:59 <mwc> twobitsprit1, you hope you don't
14:05:05 <lispy_> twobitsprit1: i think hat is as close to a traditional debugger as we have
14:05:19 <mwc> There're tools like Bhudda and that too that I hear are kind of neat
14:05:26 <Philippa_> (the medical profession pathologise being /dependant/ on causing or receiving pain, when everyone else uses the terms they just mean they like doing it)
14:05:38 <twobitsprit1> mwc: ?
14:06:03 <Philippa_> I've usually made copious use of ghci and whatever tracing facilities I could find to log the order of operations when it mattered to me
14:06:05 <mwc> twobitsprit1, I personally find I don't need a GDB style stack trace when doing haskell work
14:06:08 <twobitsprit1> so.. if my program dosen't work, I just have to stare at the code until the error jumps out at me?
14:06:30 <Philippa_> no. Because a lot of your code is pure functions you can get a long way by running bits of it in ghci with varying parameters, for example
14:06:42 <twobitsprit1> i suppose so
14:07:08 <FrederikEaton> myello
14:07:30 <twobitsprit1> but if I have a large number of functions, and my program just Doesn't Work, how do I find out where things went wrong?
14:07:55 <Philippa_> find some way of giving yourself relevant output
14:08:01 <Philippa_> in a pinch, you can use Debug.Trace
14:08:15 <nealar> step-by-step isolate which function does not work
14:08:32 <Philippa_> Writer monads work (and you can try slapping a WriterT transformer on top of a monad you're using, which can be helpful)
14:08:33 <ski> or use stuff like Hat or Buddha (now Plargleflarp ?)
14:08:38 <twobitsprit1> Philippa_: yeah, I was going to ask how hard it would be the put a random "print"-like statement in a funtion somewhere... would I have to convert the function into a do clause?
14:08:46 <Philippa_> in theory yes
14:08:51 <Philippa_> in practice, there's a hack available
14:08:59 <mwc> No, that would turn it into an IO monad and bring in all sort of type hell
14:09:01 <Philippa_> Debug.Trace.trace
14:09:09 <ski> @type Debug.Trace.trace
14:09:13 <lambdabot> forall a. String -> a -> a
14:09:23 <Philippa_> it prints out the first parm then carries on going, effectively
14:09:33 <jlouis> code is often breakable into smaller pieces. If not, you have a problem ;)
14:09:36 <Philippa_> trace "got here!" $ whateverYouWereDoing
14:09:53 <Philippa_> jlouis: sometimes it's still hard to deal with though
14:10:02 <Philippa_> like when the code's already monadic but doesn't have a logging mechanism
14:10:02 <mwc> Debugging haskell is one of those things that sounds really scary until you've done it the first time'
14:10:11 <Philippa_> yeah, it's easier once you've some practice
14:10:14 <jlouis> Philippa_: sure is ;)
14:10:16 <jlouis> @paste
14:10:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:10:19 <twobitsprit1> so I would "import" the trace function, and just call it with a string any time I need output?
14:11:05 <mwc> twobitsprit1, in practice, ghci + Show class give you printl style debug statements, except vastly better
14:11:15 <ski> you need to insert the function call (with the string) around some expression, and then when (if) that expr gets evaled, the string will be printer
14:11:19 <ski> *printed
14:11:44 <SyntaxNinja> frederikeaton: you may be able to alter the script to not look in '.', but I don't know the details of your script
14:12:01 <Philippa_> twobitsprit1: yup
14:12:06 <twobitsprit1> ski: "around" some expression?
14:12:50 <Philippa_> given an expression e: trace "running e" (e)
14:12:51 <ski> former "foo args ... = ... (expr) ..." becomes "foo args ... = ... (trace "your string" (expr)) ..."
14:13:09 <Philippa_> ski gives it with context :-)
14:13:48 <jlouis> http://www.haskell.org/hawiki/HaskellIrcPastePage?action=show -- top post. Input wanted
14:14:19 <FrederikEaton> SyntaxNinja: actually i'm using a custom script most of the time, which i can modify to not look in '.'. but i want to move to runghc since distributing my script will be a pain
14:14:46 <FrederikEaton> SyntaxNinja: did you see the other error in my paste? it's in the middle, i added a comment
14:15:00 <FrederikEaton> SyntaxNinja: there is a build error that goes away when i run the build a second time
14:15:07 <SyntaxNinja> FrederikEaton: yeah, doesn't look likke a cabal error. strange that it only breaks the first time.
14:15:16 <ski> jlouis : i would prolly case on []
14:15:19 <SyntaxNinja> FrederikEaton: I'm guessing it has to do w/ fyour other problem
14:15:46 <lispy_> it looks like Chan is too slow for my purposes
14:15:57 <SyntaxNinja> FrederikEaton: well, you either have to tell the script to not look in '.', or you have to move the stuff it's seeing out of '.'... not sure what other options you have.
14:15:57 <lispy_> i must be using it incorrectly
14:16:39 <ski> (jlouis : though, i'd possibly use '_' instead of 'e' and 'o' in the patterns, since they are already available)
14:17:28 <jlouis> ski: okie, I just thought this was easier to read
14:18:49 * ski is off to dream land
14:20:06 <samx> i'm using 'read' to convert a string into a float. What do I need to do to determine/catch the case when the string isn't a float?
14:20:44 <FrederikEaton> SyntaxNinja: huh, it seems that when things are working, runghc doesn't look in '.'
14:20:55 <FrederikEaton> SyntaxNinja: so it's only a problem for debugging
14:21:50 <lispy_> @eval read "0.5" :: Int
14:21:53 <lambdabot> Prelude.read: no parse
14:22:11 <lispy_> samx: i think you can use the function catch
14:22:11 <Heffalump> samx: use 'reads' rather than 'read'
14:22:19 <Heffalump> Prelude> :t reads
14:22:19 <Heffalump> reads :: (Read a) => ReadS a
14:22:19 <Heffalump> Prelude> :i ReadS
14:22:19 <Heffalump> type ReadS a = String -> [(a, String)]
14:22:46 <Heffalump> that gives a list of possible results, together with the remaining unit
14:22:52 <lispy_> Heffalump: have you ever used Control.Concurrent.Chan ?
14:23:03 <Heffalump> s/unit/input/
14:23:06 <Heffalump> errm, not sure.
14:23:07 <Heffalump> why?
14:23:27 <lispy_> Heffalump: it's not behaving as expected.  After I dup the channel a few times, it becomes very slow
14:23:35 <Heffalump> no idea.
14:23:39 <lispy_> okay
14:24:20 <twobitsprit1> has anyone come accross anyone trying to write a Go playing AI in haskell? That's essentially what I'm trying to accomplish, but I'm having a real hard time trying to integrate my new found semi-understanding of haskell and apply it to an actual program... i.e. how to represent data, how to write an i/o loop, etc...
14:24:46 <Philippa_> an IO loop is fairly easy - just use tail recursion
14:24:56 <lispy_> or mapM_
14:25:05 <lispy_> mapM_ (do ...) [1..]
14:25:24 <Philippa_> that works less well when the input isn't a list ;-)
14:25:42 <lispy_> er sorry mapM_ (\_ -> do ...) [1..]
14:25:53 <Philippa_> even then
14:25:54 <lispy_> then implement your IO in the do
14:26:01 <Philippa_> you're not always doing [1..]
14:26:13 <Philippa_> if you're ignoring the input, just tail-recurse
14:26:23 <Philippa_> it makes it easier to see what's going on if you then want different states
14:26:46 <samx> heffa, should I not be using 'read' then, if the input can be invalid?
14:27:13 <Philippa_> not without catching any errors I guess
14:27:44 <twobitsprit1> what's a good way to represent a grid in haskell? "[[a]]"?
14:28:19 <Philippa_> [[a]]'ll work for now. There're array facilities, but I've never used them myself
14:28:30 <lispy_> maybe MVar will be faster
14:28:35 <twobitsprit1> MVar?
14:28:37 <Philippa_> it's probably a good idea to build a Board type on top of it anyway
14:28:39 <lispy_> but i'm guessing that Chan was built on MVar
14:28:45 <lispy_> twobitsprit1: sorry, thinking out loud
14:28:52 <Philippa_> Chan is indeed built on MVar
14:28:55 <nealar> Arraty is clumsy
14:28:59 <nealar> Array
14:29:09 <Philippa_> nealar: why do you think I've not used it? :-)
14:29:30 <lispy_> Array's aren't bad, but they are slow if you try to mutate them
14:29:33 <nealar> I tried to use them and as result found that my code is horrible
14:29:33 <Philippa_> twobitsprit1: get in the habit of building named types with their own interfaces, it'll save you much stress later
14:29:39 <twobitsprit1> this was probably talked about in the tutorials I've read, but I must have missed it... can lists be indexed in constant time?
14:29:44 <Philippa_> no
14:29:50 <Philippa_> they're essentially cons-lists
14:30:05 <twobitsprit1> yeah... I just didn't know if haskell optimized them or not
14:31:15 <twobitsprit1> hmm... is there something resembling a dictionary a la Python in Haskell?
14:31:36 <Philippa_> Data.Map
14:32:03 <lispy_> twobitsprit1: newArray ((1,1), (13,13) [((x,y), 0) | x <- [1..13], y<- [1..13]], iirc that will create a 13x13 array with 0 for each element
14:32:37 <lispy_> twobitsprit1: although, using newListArray would be easier :)
14:33:06 <lispy_> twobitsprit1: then you use ! to index, so for example array ! (x,y)
14:33:26 <liyang> O.o
14:33:43 <liyang> Eww. Please consider Map...
14:33:47 <Philippa_> oh, that reminds me - I actually picked up a Go set on wednesday, so I might do some playing soon
14:33:58 <Philippa_> liyang: they're doing a 2d array there, not a map
14:34:33 <twobitsprit1> where's a good source that lists all the library and built in functions/types/etc with descriptions?
14:34:41 <liyang> How's that different from Map (Int,Int) Foo ?
14:34:42 <Philippa_> either way you'll want to end up with a type Board and a getPiece x y func and so forth
14:34:52 <alar> :)
14:34:55 <Philippa_> twobitsprit1: descriptions is a bit mixed. The GHC docs list everything though
14:34:56 <alar> sounds familiar
14:35:05 <Philippa_> liyang: the Map's slow
14:35:27 <liyang> Philippa_: other than that...
14:35:30 <lispy_> Philippa_: arrays are horribly slow updating tho
14:35:49 <liyang> Correctness first. Or something. ^_^;
14:35:54 <twobitsprit1> lispy_: I don't think I'll need fast updating...
14:36:10 <Philippa_> Correctness is to stop fecking about and identify the fact you'll be providing your own abstract interface first ;-)
14:36:21 <liyang> I'd imagine both will be fast enough.
14:36:24 <liyang> True. Heh.
14:36:25 <lispy_> when i did knight's tour, i used an array to store the board, (since it had holes) and i used a list to store the knight's moves.  It was much, much faster than updating the array
14:36:38 <alar> twobitspirit1: slow not only at runtime, but take much time to code it :))
14:36:44 <Philippa_> yeah, immutable arrays suck for updates
14:37:01 <lispy_> Philippa_: the mutable ones really aren't a lot better tho
14:37:19 <lispy_> Philippa_: IOUArray is not nearly as efficient as one would hope
14:37:27 <alar> are there handy mutable arrays?
14:37:45 <Philippa_> there're some in the IO monad and some in the ST monad
14:37:50 <jlouis> alar: in C, yes ;)
14:37:54 <alar> lol
14:38:10 <Philippa_> and there're some in the IO monad that're essentially C arrays (because you need 'em for FFI purposes)
14:38:39 <lispy_> that was my understanding of IOUArray, IO, unboxed array
14:38:59 <lispy_> you can do inplace, element-wise array updates
14:39:29 <twobitsprit1> maybe I should start off writing some simple practice programs before jumping into such a complex problem...
14:39:30 <jlouis> ugh, lambdabots Seen Plugin could do with some cleaning
14:39:42 <Philippa_> that's actually slower to update than an array of boxed items though
14:39:49 <Philippa_> the array of boxed items just has to change a pointer
14:40:01 <Philippa_> twobitsprit1: possibly
14:40:09 <lispy_> twobitsprit1: indeed.  Define a tree type, make it an instance of Functor and Show, then made it an instance of Monad
14:40:22 <lispy_> Philippa_: hmm...okay
14:40:28 <lispy_> Philippa_: maybe i should try a boxed one some time
14:40:52 <twobitsprit1> lispy_: I'm not sure I follow
14:41:02 <lispy_> twobitsprit1: it will be a great learning exercise
14:41:34 <twobitsprit1> lispy_: I've heard of "Functor" but I'm not sure I understand what it is...
14:41:59 <shrimpx> twobitsprit1: it's a mapping from categories to categories, duh
14:42:01 <lispy_> twobitsprit1: then you should look it up :)
14:42:15 <shrimpx> man i hate retarded terminology
14:42:21 <Philippa_> twobitsprit1: fmap's like map is for lists, only it works with any structure that's an instance of functor
14:42:21 <shrimpx> and haskell takes the cake there
14:42:27 <lispy_> twobitsprit1: and i mean look up the type class definition, and what is required to make something an instance of that type class
14:42:37 <Philippa_> the rest's a matter of specifying what "being like map" means
14:43:07 <Philippa_> yeah, it'd be nice to have Mappable or something as an alternative name
14:43:53 <jlouis> shrimpx: Functor is not a bad choice there I think
14:44:08 <shrimpx> jlouis: Functor is a bad choice universally
14:44:10 <jlouis> although an SML functor hits the nail better wrt naming
14:44:15 <shrimpx> i think even god would agree
14:45:18 <Lemmih> FrederikEaton: runghc can't parse the '#...' line.
14:45:51 <lispy_> yeah, Show should have been ListInjection for consistency
14:45:57 <twobitsprit1> I found "Data.FunctorM" in the GHC docs
14:46:23 <lispy_> twobitsprit1: that's going to be for monads, that's the convention with the M suffix
14:46:24 <shrimpx> lispy_: haha
14:47:23 <twobitsprit1> so, where is just Functor in the docs?
14:47:34 <lispy_> twobitsprit1: http://www.cs.mu.oz.au/fpu/haskell-tutorial-1.4-html/classes.html
14:47:49 <lispy_> twobitsprit1: i fear that's for an old Haskell spec, but that talks about functors
14:49:05 <lispy_> yeah, in haskell98 it's fmap
14:49:06 <lispy_> not map
14:50:02 <TheHunter> @docs Prelude
14:50:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:50:05 <lispy_> http://haskell.org/hawiki/CategoryTheory_2fFunctor
14:50:11 <twobitsprit1> I'm gonna go find some Advil...
14:50:16 <lispy_> twobitsprit1: heh
15:05:10 <jlouis> @todo
15:05:11 <lambdabot> 0. SamB: A way to get multiple results from a google search
15:05:11 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
15:05:11 <lambdabot> 2. SamB: stop mangling long urls
15:05:11 <lambdabot> 3. dons: improve formatting of @dict
15:05:11 <lambdabot> 4. dons: write Haskell Manifesto
15:05:13 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @
15:05:15 <lambdabot> foo across lines
15:05:17 <lambdabot> [5 @more lines]
15:05:43 <jlouis> @more
15:05:44 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
15:05:44 <lambdabot> 7. TheHunter: @type 1 :: Int
15:05:44 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.
15:05:44 <lambdabot> It would be nice if it also let you find functions in the given
15:05:44 <lambdabot> module that use a type.
15:06:00 <Lemmih> @type 1 :: Int
15:06:01 <lambdabot> Int :: Int
15:06:26 <shrimpx> @type 1 :: Int :: Int
15:06:27 <lambdabot> bzzt
15:06:32 <shrimpx> :)
15:07:06 <Igloo> You need parens for that to be parsed
15:07:20 <alar> is there a help for bot?
15:07:26 <Igloo> Looks like lambdabot's parsing of results is wrong too
15:07:51 <alar> @type (1::Int)::Int
15:07:53 <lambdabot> Int
15:08:19 <jlouis> alar: help for bot?
15:08:24 <TheHunter> @type (1::Int) :: Int
15:08:26 <lambdabot> Int :: Int
15:08:40 <alar> yes
15:08:53 <alar> what can I request from it?
15:08:54 <jlouis> @help
15:08:54 <lambdabot>  @help <command> - ask for help for <command>
15:09:00 <jlouis> @listmodules
15:09:01 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
15:09:01 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
15:09:01 <lambdabot> spell state system todo topic type version vixen where
15:09:07 <jlouis> too much
15:09:07 <ehuber> @type (1::Int)
15:09:07 <alar> @listcommands
15:09:08 <lambdabot> Int
15:09:08 <lambdabot> use listcommands [module|command], please. Modules are:
15:09:08 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
15:09:08 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
15:09:08 <lambdabot> spell state system todo topic type version vixen where
15:09:31 <ehuber> @type bla :: Int -> Int
15:09:32 <lambdabot> bzzt
15:09:35 <ehuber> bla
15:09:52 <alar> @listcommands base
15:09:53 <lambdabot> base provides:
15:10:29 <jlouis> heh, I better fix that
15:10:59 <TheHunter> what?
15:11:01 <alar> I currently know @type, @goole and @where
15:11:09 <alar> @class
15:11:11 <lambdabot> Unknown command, try @listcommands.
15:11:24 <TheHunter> alar, @listcommands will do something slightly different if you pm lambdabot.
15:12:10 <alar> pm?
15:12:23 <TheHunter> private message, i.e /query
15:12:33 <alar> thanks
15:12:36 <alar> now trying
15:13:09 <ehuber> goole ?
15:13:17 <ehuber> o nvrmnd
15:13:25 <TheHunter> wow, that is a lot of output, /me wonders why @more doesn't kick in.
15:13:42 <TheHunter> that reminds me, we need fair queuing of messages.
15:13:56 <jlouis> TheHunter: here goes:
15:13:58 <jlouis>                 ss <- moduleCmds md
15:13:58 <jlouis>                 let s | null ss   = arg ++ " is a module."
15:13:58 <jlouis>                       | otherwise = arg ++ " provides: " ++ (showClean ss)
15:14:36 <jlouis> shouldn't it have returned arg ++ is a module. for base?
15:14:49 <jlouis> Plugins/Help.hs
15:15:11 <TheHunter> @help base
15:15:12 <lambdabot> base is a module.
15:15:47 <jlouis> oh, I am sleeping. Sorry
15:16:20 <FrederikEaton> anyone know how hard it would be to remove the dependency of WASH on javascript?
15:16:26 <TheHunter> we could treat "base doesn't provide any commands" as special case.
15:17:38 <jlouis> TheHunter: exactly. in Plugins/System.hs function listModule
15:18:23 <psi> can anyone help me with building the documentation to hscurses? 'make doc' fails with 'HSCurses/Widgets.raw-hs:36:19: Parse error'
15:18:27 <jlouis> i'll have fun with my viking axe
15:18:38 <psi> indeed, that line looks weird. let me paste it.
15:19:00 <alar> what is the class Typeable?
15:19:18 <psi> type Size = (Int, -- ^ height
15:19:35 <psi> it continues on the next line, but is that some extension or something?
15:22:00 <psi> haddock is used, I forgot to add
15:22:01 <TheHunter> it's haddock's syntax. not an extension per se, as the ^ appears in a comment.
15:22:13 <TheHunter> which version of haddock are you using?
15:22:16 <psi> 0.6
15:22:40 <psi> oh, a comment. I should've realized :)
15:23:25 <psi> do you think 0.7 fixes this?
15:23:53 <TheHunter> i don't know.
15:25:16 <TheHunter> the easiest workaround would be to just remove the ^
15:28:07 <sjanssen> what is the name of the Haskell website template software?
15:28:22 <musasabi> HSP ?
15:28:29 <psi> thanks, that worked. there doesn't seem to be any documentation, though - just an index of the different functions. oh well.
15:29:03 <sjanssen> musasabi: not that one, I think this one does static web pages
15:29:48 <musasabi> halipeto?
15:30:32 <sjanssen> yep, that's the one
15:33:03 <psi> what's the simplest way of creating, in a terminal, one area for input, and another for text messages of various kinds? would that be hscurses?
15:34:18 <alar> .
15:36:43 <alar> @help state
15:36:44 <lambdabot>  @state - we all know it's evil
15:36:48 <alar> :)
15:38:36 <jlouis> @state
15:38:44 <alar> :))
15:43:27 <ehuber> does anyone read the papers provided at labs.google.com ?
15:43:40 <Defiler> Yeah, I read the Sawzall paper. Cool stuff.
15:44:47 <ehuber> hm
15:44:53 <ehuber> have you looked at the GFS paper ?
15:45:08 <ehuber> (I also read the sawzall paper.. but it's not really my cup of tea)
15:45:27 <Defiler> Haven't read the GFS one.. have they published any details of MapReduce?
15:45:57 <Defiler> Hah. Right under the Sawzall paper.
15:46:25 <ehuber> yeah, there is also a mapreduce paper (:
15:46:37 <ehuber> more in depth than the sawzall paper i think
15:46:54 <ehuber> and more interesting for functional prog nerds (:
15:47:29 <Defiler> I do a lot of data work, so the Sawzall paper was pretty interesting for me.
15:47:59 <ehuber> i see, i myself am more interested in language processing / data mining
15:48:09 <alar> sawzal is about distributed processing
15:48:14 <alar> what is GFS?
15:48:20 <ehuber> google file system
15:48:32 <ehuber> a distributed file system
15:48:44 <Defiler> http://labs.google.com/papers/
15:48:50 <alar> thanks
15:55:19 <samx> is there any function in the standard library to go through a list of 'Maybe a', and return a list of 'a'.. That is filtering away all Nothings and mapping from Maybe a -> a
15:55:36 <alar> catMaybes?
15:56:24 <samx> in what module is that?
15:56:26 <alar> there is one, but I can't remember corrrect spelling
15:57:00 <TheHunter> @index catMaybes
15:57:02 <lambdabot> Data.Maybe
15:57:15 <TheHunter> @docs Data.Maybe
15:57:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Maybe.html
15:58:10 <samx> ok, found it. thanks all :)
16:20:35 <lispy_> ah finally
16:20:50 <lispy_> i was accidentally putting a bunch of "" messages in my FIFO
16:20:54 <lispy_> that's why i thought it was so slow
16:21:01 <basti_> :D
16:21:04 <lispy_> it was printing out thousands of empty strings :)
16:21:30 <ehuber> gj :p
16:22:16 <Igloo> Are you writing anything interesting?
16:22:35 <lispy_> Igloo: nope
16:22:39 <lispy_> Igloo: just learning
16:23:11 <Igloo> Learning how to write uninteresting things?  :-)
16:23:27 <alar> =)
16:23:38 <samx> is there any library for haskell for easy parsing / manipulating of dates? System.Time seemed to be a bit limited, at least at parsing and printing
16:24:13 <Igloo> There's a new date/time lib somewhere, but I don't think it has a "Try to make something out of this" parser
16:29:03 <lispy_> Igloo: i'm hoping to make it a text based multiuser game, like a mud.
16:29:22 <lispy_> Igloo: but i couldn't even get message broadcasting to work :)
16:40:10 <samx> yay.. my program is finally working.. ..not so yay, I still don't understand why it was even compiling earlier; imho it should have complained about a type error :-)
16:42:13 <sylvan> samx are you looking for it to parse time in a specific format, or to parse it in a variety of formats?
16:42:26 <sylvan> in any case that type of parsers would probably be a breeze with parsec
16:43:24 <samx> was hoping to find something that would allow me to specify a format.. ..but solved that by writing a simple parser for the specific format myself
16:55:22 <greenrd> I have a question which may be a stupid question
16:55:29 <greenrd> Suppose I have an STArray, and I do liftM head (filterM some_filter (indices array))
16:56:08 <greenrd> Do the "side effects" of some_filter stop happening after the first match is found, or not?
16:56:48 <greenrd> In other words, does it stop after finding the first match, or does it continue right to the end of (indices array) each time?
16:57:45 <greenrd> I obviously haven't quite fully understood monads yet...
17:01:45 <greenrd> I would _guess_ it does... what I'm really looking for is a safe way to temporarily view a mutable array as a list, without the overhead of copying it
17:02:53 <alar> why are you bothered by overhead? Is the performance of concern?
17:03:54 <greenrd> Yes. I am teaching myself to write really efficient code in Haskell :)
17:04:29 <greenrd> Once I learned about the ST monad and in-place array updates I realised this was possible.
17:04:43 <greenrd> At least, for array-ish problems.
17:04:52 <alar> oh. Then you've gine further than I
17:05:23 <alar> gone
17:05:25 <Lemmih> It will go through every index.
17:05:29 <greenrd> ok
17:10:11 <SyntaxNinja> Lemmih: aren't you asleep? ;)
17:10:14 <Philippa_> that one's kinda ouch actually, you can't get neat laziness unless you can prove you're not gonna touch the array 'til you've read it all
17:10:36 <greenrd> yeah
17:11:51 <Philippa_> is there a particular reason you want to treat it as a list? There might be a better way to do what you're after
17:12:25 <Philippa_> (or are you trying to build another, long-lived structure and the list's just a temporary while you build it?)
17:13:00 <greenrd> No, I'm just finding one particular element in the array.
17:13:19 <Philippa_> why not iterate along the array to find it then?
17:13:49 <greenrd> Just getting used to programming with the ST monad
17:14:14 <Philippa_> Ah. The iterative find's probably the way to do it - it'd be nice to have some of the List functions available on other sequences
17:14:21 <greenrd> Yeah
17:15:20 <greenrd> The way I look at it, the array (even though it's mutable) _is_ just a sequence for the purposes of this function, so I should be able to treat it as a list and use all the list functions, without a performance hit.
17:15:32 <greenrd> Although yes, it's proving that it's safe that makes it tricky.
17:15:53 <Philippa_> the performance hit comes from needing the whole list
17:16:41 <Philippa_> you /can/ say "I know I mean this" with one of the unsafeFoo funcs, but I'm not taking responsibility for figuring out what's the right way to do it :-)
17:16:46 <Philippa_> not least because I should be in bed
17:17:04 <greenrd> ok, yeah, I'm leaning towards unsafeFoo
17:17:07 <greenrd> *sigh*
17:17:11 <greenrd> thanks for your help!
17:17:19 <Philippa_> when you do it, comment why you've done so and an explanation of why it's safe
17:17:22 <Philippa_> good habit to get into
17:17:24 <greenrd> yeah
17:31:10 <FrederikEaton> cabal problem:
17:31:12 <FrederikEaton> *** Exception: Line 1: Unknown field 'build-depends'
17:31:19 <FrederikEaton> this is for my .buildinfo file
17:31:31 <FrederikEaton> but i thought build-depends was known. am i misspelling it?
17:44:38 <samx> trying to compile an example gtk2hs application, but getting 'Failed to load interface for `Graphics.UI.Gtk.Glade': Could not find module `Graphics.UI.Gtk.Glade': it is not a module in the current program, or in any known package.'. Not sure what path I should be setting or where.
17:54:22 <greenrd> samx: You need the -i flag
17:55:39 <greenrd> samx: ghc -idirectory where directory is some directory in your gtk2hs installation
17:56:06 <greenrd> assuming you use ghc that is
17:57:42 <samx> greenrd, I tried that, but didn't seem to help.. is the '-i' supposed to point to the main directory where gtk2hs is installed, or the 'imports' directory under it ?
17:58:44 <greenrd> dunno
17:58:54 <greenrd> probably the imports directory
17:59:31 <greenrd> just try all the plausible ones in turn
17:59:46 <samx> i did.. none of them helped :-)
18:00:58 <samx> hmm.. i might be missing a package
18:01:11 <dons> darcs' FastPackedString is fun!
18:03:22 <ozone> what's the diff vs normal PackedString?
18:03:23 <samx> green, yup.. was missing a 'gtk2hs-glade' package.. got passed finding the package at least
18:04:02 <dons> ozone,  way more operations, and uses my favorite representation: data PackedString = PS !(ForeignPtr Word8) !Int !Int
18:04:10 <dons> whereas PackedString is a UArray
18:04:13 <ozone> dons: awesome :)
18:04:22 <ozone> dons: so it's 1:1 with a CString?
18:04:25 <dons> also comes with mmapFilePS :: FilePath -> PackedString
18:04:40 <dons> ozone, yeah.
18:04:41 <ozone> or rather, can you pass the ForeignPtr off to C land (is the thing NUL-terminated?)
18:04:50 <dons> also, Eq instance uses memcmp
18:04:50 <ozone> and what's the two integers on the end?  string length and...?
18:04:58 <ozone> oh.  very nice!
18:05:06 <ozone> now if only haskell had defaulting on strings
18:05:17 <dons> size of buffer and length
18:05:23 <ozone> ah, right
18:06:17 <dons> I think people looking into packed strings should really use darcs' version. it's far far more complete
18:06:30 <ozone> cabalise :}
18:06:45 <dons> good point
18:07:02 * ozone goes to look at h4sh
18:07:12 <ozone> looks like it's going to be a geeky sunday
18:08:12 <dons> ozone, feel free to contribute to the onliners document - the HOWTO if you write anything neat
18:09:01 <ozone> ok
18:12:42 <greenrd> Is there a way of strictly fully-evaluating an arbitrary expression in Haskell?
18:12:46 <lispy_> what is the remedy for this pattern? do eq <- readIORef cs >>= return . eventQueue
18:13:17 <lispy_> greenrd: some sort of deep sequence?
18:13:33 <lispy_> greenrd: there was a message recently from Cale on Haskell-Cafe about deepSeq
18:13:36 <dons> greenrd, Control.Exception.evaluate, seq, deepSeq are all options.
18:13:47 <dons> deepSeq is in lambdabot too
18:13:50 <dons> @version
18:13:51 <lambdabot> lambdabot 3p73, GHC 6.5 (OpenBSD i386)
18:13:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:14:07 <TheHunter> there's also the Data.Parallel.Strategies.NFData stuff.
18:14:15 <dons> greenrd, deepSeq is very rarely required in practice
18:14:24 <lispy_> TheHunter, dons
18:14:26 <lispy_> oops
18:14:38 <dons> I've only needed it once with hard time constraints in the icfp contest
18:14:38 <greenrd> thanks
18:15:10 <lispy_> TheHunter, dons: do you have advice no how to  have less of this is my code: |do eq <- readIORef cs >>= return . eventQueue|  Should I be using monad transformers or something?
18:15:12 <dons> lispy_, dons!
18:15:25 <lispy_> :)
18:15:30 <TheHunter> @pl readIORef cs >>= return . eventQueu
18:15:31 <lambdabot> eventQueu `fmap` readIORef cs
18:15:54 <TheHunter> @where hs-plugins
18:15:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:16:20 <lispy_> hmm.... eventQueue `fmap` readIORef cs is a bit more opaque, in my opinioun
18:16:24 <lispy_> opinion
18:16:40 <dons> the fmap syntax is quite comfortable after a little while, I find
18:16:46 <ehuber> hmm.. does anybody know how i could get this to work ?  filter (\i -> (13 mod i) == 0) [2..12]
18:16:55 <dons> `mod`
18:16:56 <lispy_> well, it is less characters to type
18:17:01 <greenrd> @help pl
18:17:01 <lambdabot>  @pointless <expr> - play with pointfree code
18:17:52 <dons> @eval filter (\i -> (13 `mod` i) == 0) [2..13]
18:17:54 <lambdabot> [13]
18:18:05 <lispy_> 13 `mod` i == 0, iff i = k*13, right?
18:18:07 <ehuber> @type mod
18:18:08 <lambdabot> forall a. (Integral a) => a -> a -> a
18:18:16 <ehuber> @type 'mod'
18:18:17 <lambdabot> bzzt
18:18:18 * shapr boings
18:18:22 <ehuber> @type `mod`
18:18:23 <lambdabot> bzzt
18:18:29 <lispy_> ehuber: use parens
18:18:41 <ehuber> @type (`mod`)
18:18:42 <lambdabot> bzzt
18:18:45 <ehuber> @type (mod)
18:18:47 <lambdabot> forall a. (Integral a) => a -> a -> a
18:18:49 <lispy_> it was worth a try :)
18:18:50 <ehuber> heh..
18:19:02 <marcot> ehuber: with `` you say that the function will be infix.
18:19:05 <dons> @type mod
18:19:07 <lambdabot> forall a. (Integral a) => a -> a -> a
18:19:10 <ehuber> ohh.. of course
18:19:13 <ehuber> im a numbnut (:
18:19:16 <lispy_> @eval 13 `mod` 26
18:19:17 <lambdabot> 13
18:19:33 <TheHunter> dons, does using hsx for building hs-plugins have any advantages?
18:19:50 * lispy_ isn't sure what we was thinking before
18:19:52 <marcot> ehuber: you can do: filter (\i -> (mod 13 i) == 0) [2..12]
18:19:58 * shapr isn't thinking!
18:20:07 <lispy_> s/we/he/
18:20:12 <lispy_> hehe, can't type either
18:20:58 <dons> TheHunter, only if you're doing merge operations on src files that contains glaexts syntax. which is only HSP afaik
18:21:22 <TheHunter> lispy_, MonadState has 'gets', MonadReader has 'asks', maybe 'readIORefs' would make sense, too.
18:21:50 <ehuber> marcot: heh thanks, i just figured that out myself too (: i dont know what i was thinking, making it infix
18:22:14 <dons> TheHunter, maybe I should say why hsx is used/not used in the README?
18:22:34 <marcot> ehuber: I personally prefer to use infix in this case.
18:22:36 <ehuber> @eval [x | x <- [2..100], length (filter (\i -> (mod x i) == 0) [2..x-1]) == 0]
18:22:36 <lispy_> TheHunter: hmm..I was just thinking I should check MonadState
18:22:37 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
18:22:37 <lambdabot> 97]
18:22:38 * shapr swears at gnumacs
18:22:38 <marcot> ehuber: with ``
18:22:40 <dons> you're the 2nd person who's asked since i made hsx optional
18:22:50 <shapr> How do I get gnumacs to stick text into the X copy buffer?
18:22:57 <lispy_> TheHunter: because, really i'm using an IORef because I want to thread state around
18:23:09 <ehuber> slow primes (:
18:23:11 <TheHunter> dons, hehe.
18:23:49 <marcot> ehuber: use the sieve.
18:23:54 <TheHunter> for threading state around in an IO situation, i prefer a ReaderT (IORef s) over a StateT s
18:24:19 <lispy_> TheHunter: cool, i'll look at that
18:24:42 <marcot> ehuber: Erasthotenes.
18:25:00 <ehuber> marcot: yeah, i just wanted to see how concise it could get
18:25:37 <TheHunter> lispy_, the main difference is exception handling.
18:25:42 <marcot> ehuber: with the sieve is more concise:
18:25:43 <ehuber> marcot: but in order to do that, wouldnt i need to make a true function?
18:26:25 <marcot> ehuber: you're making.
18:26:37 <marcot> (\i -> (mod x i) == 0)
18:29:24 <TheHunter> lispy_, unrelated question, just ooi. Which term do you think is better" "point-free" or "points-free". And does one of them sound completely wrong?
18:30:11 <lispy_> TheHunter: point-free sounds more natural.  But i'm not really a good person to ask about what sounds good in english. :)
18:30:20 <ozone> TheHunter: point-free
18:30:27 <lispy_> even though i'm a native speaker :)
18:30:49 <TheHunter> thanks.
18:31:33 <TheHunter> personally, i find "points-free" sounds horrible, but that's probably due to my German background.
18:33:33 <dons> TheHunter, why so?
18:33:51 <Igloo> "point-free" sounds better to me
18:34:19 <Igloo> I think English has a tendency to move plurals of compound phrases to the end, but I can't think of a non-acronym example OTTOMH
18:34:51 <dons> except for `governors-general'
18:35:14 <TheHunter> in german, if you have a compound adjective ending with -frei, the noun is always singular, i think.
18:35:14 <Igloo> (which would sound odd to me here, but probably partly explains why points-free sounds odd)
18:35:50 <dons> yes, I think points-free sounds odd the way governors-general sounds odd
18:36:52 <dons> hmm. is there any way with Cabal to have a set of executables depend on a common src file, but not have cabal recompile this common import for each executable?
18:38:33 <TheHunter> hmm, governors-general sounds like it could have been frensh.
18:41:56 <dons> Igloo, I notice there are two bugs in FastPackedString.linesPS/unlinesPS such that they don't behave like lines/unlines. unlinesPS doesn't add a \n to the last line of a list, and linesPS silently drops the final \n. I guess darcs must work around this somehow, or not care
18:42:02 <lispy_> telnet codersbase.com 2000   if you want to chat with me on my lame-o server i just made :)
18:43:09 <dons> unlinesPS is coded up as concat . intersperse "\n", basically, instead of concatMap (++ "\n")
18:43:28 <Igloo> That makes them inverses, doesn't it?
18:43:47 <dons> they are inverses, but they aren't drop-in replacedments for lines/unlines
18:43:53 <Igloo> intersperse_newlines is just intersperse (packString "\n"), right?
18:44:07 <dons> unlinesPS ss = concatPS $ intersperse_newlines ss
18:44:07 <dons>     where intersperse_newlines (a:b:s) = a:newline: intersperse_newlines (b:s)
18:44:07 <dons>           intersperse_newlines s = s
18:44:08 <dons>           newline = packString "\n"
18:44:11 <Igloo> Then what you are noticing is the bugs in the Prelude  :-)
18:44:33 <dons> where's I reimplemented it like the prelude: unlinesPS ss = concatPS $ map (\s -> s `appendPS` newline) ss
18:44:37 <dons>     where newline = packString "\n"
18:45:12 <dons> maybe it doesn't matter, unless some external party tries to use them as lines/unlines
18:45:22 * Igloo is just writing it that way. Perhaps someone didn't know intersperse existed and just managed to hit the same name
18:45:32 <Igloo> Let me try that again
18:45:43 * Igloo is just wondering why it's written that way. Perhaps someone didn't know intersperse existed and just managed to hit the same name
18:45:54 <lispy_> heh, not sure who i was chatting with, but i haven't implemeted quitting yet :)
18:46:26 <dons> so I also had to rewrite linesPS to add the base case:
18:46:27 <dons> linesPS ps | nullPS ps = []
18:46:27 <dons> linesPS ps = case wfindPS (c2w '\n') ps of
18:46:27 <dons>              Nothing -> [ps]
18:46:28 <dons>              Just n -> takePS n ps : linesPS (dropPS (n+1) ps)
18:46:57 <TheHunter> the next thing I would have done is killall -9 telnet, the only reliable way to close a telnet connection I know of...
18:47:20 <lispy_> ah, if you hit Ctrl ], then type quit it kills the unix version
18:47:39 <greenrd> or just CTRL ], CTRL D
18:48:05 <dons> hmm. the FastPackedString.{unlines/lines} is quite different to the Data.PackedString versions
18:48:08 <TheHunter> greenrd, thanks, that works.
18:48:23 <dons> which are linesPS ps = splitPS '\n' ps ; unlinesPS = joinPS (packString "\n")
19:08:39 <FrederikEaton> so is there a better Binary module in darcs too? or elsewhere? since it depends on PackedString...
19:26:17 <lispy_> TheHunter: quit is now implemented :)
19:32:17 <TheHunter> beautyful.
19:32:20 <lispy_> heh :)
19:32:47 <lispy_> i should probably make a custom client, but telnet is perfect for now
19:33:53 <lispy_> hm...
19:34:00 <lispy_> nc may have killed it :)
19:34:10 <dons> ok. so mmapFilePS is 20% faster than readFilePS
19:34:20 <lispy_> oh, it's working again
19:34:21 <lispy_> weird
19:34:47 <SyntaxNinja> lispy_: I work a lot; it's not that weird.
19:35:02 <TheHunter> readFilePS doesn't use haskell's readFile, right?
19:35:13 <Igloo> Right
19:36:00 <TheHunter> i would have expected a much higher performance penalty with the normal readFile.
19:36:55 <dons> oh, the normal readFile is way way slower
19:37:40 <dons> readFilePS uses malloc raw bytes, versus mmapped raw bytes in mmapFilePS
19:38:02 <TheHunter> i see.
19:39:06 <dons> I don't have a version of the old readFile version of `i' handy, but I think it went from around 200ms to 6ms when switching to malloc's pack strings. for larger data I then see 20% improvement again uses mmapFilePS
19:39:32 <TheHunter> ouch!
19:39:52 <SyntaxNinja> is there anything in the standard libs that lets me do basically a wget?
19:39:58 <dons> since h4sh often doesn't need to read indivdual chars, but just rearranges [a], then those [a] may as well be super-fast [PackedString]
19:40:05 <Igloo> Hmm, I didn't think it was that significant when I made the lazy reading functions
19:40:33 <Igloo> Or maybe I'm remembering David profiling the wrong thing by accident
19:40:57 <dons> i'll see if I can find the old version and quantify directly
19:41:53 <TheHunter> i got the idea.
19:43:04 <TheHunter> are there any plans for improving deforestation in ghc?
19:45:09 <SyntaxNinja> what is lisppaste2
19:45:22 <dons> ok. here's some fun stats, for 100M of data in a single file:
19:45:32 <dons> string io: 17.208 total
19:45:44 <dons> packed string: 4.020 total
19:45:53 <dons> mmap: 0.003 total
19:46:02 <dons> cat: 3.924 total
19:46:33 <dons> (mmap is fast after priming the run)
19:46:33 <Igloo> Doing what to it?
19:46:46 <dons> just cat f > /dev/null
19:47:16 <TheHunter> dd ?
19:47:21 <dons> so all that OS support with mmap is cool. now, lets see if we actually write to disk..
19:47:47 <lispy_> SyntaxNinja: what isn't that hard?
19:47:55 <lispy_> SyntaxNinja: er, sorry weird
19:48:42 <SyntaxNinja> lispy_: nm, dumb joke
19:49:03 <lispy_> SyntaxNinja: don't call me dumb joke
19:49:32 <SyntaxNinja> heh
19:49:42 <SyntaxNinja> hey, anyone want to try out cabal-get?
19:50:33 <dons> copying a 100M file: cat 16s, mmap-haskell 16s then 4s (os support rules!), packed-string-haskell: 8s, string-haskell 23s
19:51:29 <dons> so more io effects here than when > /dev/null. the disk has  to work pretty hard
19:51:50 <dons> mmap consistently comes in at 4s after  the first run.
19:52:13 <lispy_> dons: wow
19:52:26 <lispy_> dons: for yi, i assume?
19:53:16 <dons> no, this is for the h4sh utilities, but now I think I should look at yi some more :)
19:54:46 <lispy_> yeah, it's hard to just code on one project
19:54:57 <lispy_> i just around like a crazy person
19:55:14 <lispy_> (there maybe a deeper reason there)
19:57:18 <dons> dd seems quite slow, though if I up the block size to the sizee of the file, 0+1 records out
19:57:21 <dons> 104857568 bytes transferred in 7.625 secs (13751156 bytes/sec)
19:58:30 <lispy_> i would have assumed us a block size that matches the disk would have been best
19:58:42 <TheHunter> i never understood why dd's default block size is so small.
20:05:20 <SyntaxNinja> lispy_: want to try out cabal-get?
20:11:40 <FrederikEaton> SyntaxNinja: what do you think about putting other stuff in Setup.hs? Like commands to do releases of versions, or to publish the www page for a project. there would be a case statement with the first arg and it would fall back to cabal in the default
20:12:28 <FrederikEaton> also, don't you think that 'install' should imply 'build' and 'configure'?
20:14:09 <SyntaxNinja> FrederikEaton: there's not any support for extra commands right now; though you could copy Distribution.Simple and implement them yourself
20:14:13 <SyntaxNinja> I'd definitely like to add that sometime
20:14:52 <FrederikEaton> SyntaxNinja: no, i'm asking about the concept of overloading Setup.hs to do other stuff. implementing it would be easy.
20:15:01 <SyntaxNinja> and I've thought about install implying build and configure; haven't gotten around to thinking hard about it, though...
20:15:10 <SyntaxNinja> FrederikEaton: what do you mean?
20:15:53 <FrederikEaton> SyntaxNinja: what don't you understand? I'd do Setup.hs publish-www and it would rsync the web page stuff to my web host
20:16:17 <SyntaxNinja> I don't understand what you're asking me.
20:16:35 <FrederikEaton> what you think about it. if it would be a good idea or a bad idea
20:17:32 <FrederikEaton> like some people have these sorts of things in makefiles
20:17:41 <FrederikEaton> this would be giving Setup.hs the same role
20:17:43 <SyntaxNinja> FrederikEaton: no problem, go ahead; if people start all implementing the same commands, like "pushDarcs" or something, then we'll probably add them to Simple
20:18:08 <FrederikEaton> ok. i'm not sure how to think about it, it seemed a little weird to me at first
20:19:01 <FrederikEaton> i'd hyphenate it though ;)
20:19:02 <SyntaxNinja> the right thing might be to add another hook, 'extraCommands' :: [(String, Args -> IO ExitCode)] or something
20:19:59 <FrederikEaton> modifying cabal, you say?
20:23:29 <SyntaxNinja> right
20:23:34 <lispy_> SyntaxNinja: maybe
20:23:40 <lispy_> SyntaxNinja: what is it?
20:24:01 <SyntaxNinja> lispy_: it's for automagically installing haskell packages :)
20:24:24 <lispy_> SyntaxNinja: how would i test it?
20:24:39 <SyntaxNinja> lispy_: you could download and install it, then use it to install other stuff.
20:24:49 <SyntaxNinja> first, start with cabal >=1.1.1
20:24:55 <lispy_> hmm...
20:25:08 <SyntaxNinja> darcs get http://hackage.haskell.org/darcs/cabal-get-bootstrap/
20:27:14 <lispy_> SyntaxNinja: how do i change the options to configure?
20:27:28 <SyntaxNinja> which configure?
20:27:44 <lispy_> Running command: sudo ./setup configure
20:27:54 <SyntaxNinja> in cabal?
20:28:06 <lispy_> cabal-get-boostrap
20:28:28 <SyntaxNinja> do you want to install it --user? it's supposed to support htat, but I haven't really tested...
20:28:42 <lispy_> i need --prefix
20:28:47 <SyntaxNinja> but you'Ll have to edit the source to Install.hs
20:28:53 <SyntaxNinja> Install.lhs
20:29:05 <SyntaxNinja> it's not too sophisticated yet, but I'm going to improve it.
20:29:18 <lispy_> i need it to install do /opt/local
20:29:24 <lispy_> that's where all my ghc stuff is
20:29:31 <SyntaxNinja> just edit Intsall.lhs and look for configure
20:30:34 <lispy_> most importantly it needs to install stuff to where ghc is
20:30:43 <lispy_> i guess i don't care where the cabal-get binary is
20:32:19 <lispy_> runCommand $ (compPref comp) ++ " configure --user --prefix=" ++ h ++ "/usr
20:32:34 <lispy_> it already does prefix?
20:33:11 <SyntaxNinja> only for --user
20:33:26 <SyntaxNinja> it's very dumb
20:34:28 <SyntaxNinja> add a line like this:
20:34:30 <SyntaxNinja> > runSetup comp False "configure"     = runCommand $ "sudo " ++ (compPref comp)  ++ " configure --prefix=/foo/bar"
20:34:46 <lispy_> dons: $ make
20:34:47 <lispy_> Makefile:7: mk/config.mk: No such file or directory
20:34:47 <lispy_> Imk -Icbits  -DGLASGOW_HASKELL=  Yi/Locale.hsc
20:34:47 <lispy_> make: Imk: Command not found
20:34:47 <lispy_> make: [Yi/Locale.hs] Error 127 (ignored)
20:34:47 <lispy_> I
20:35:09 <lispy_> dons: that's what i get when i try to compile the latest version of yi
20:35:16 <SyntaxNinja> lispy_: FOCUS!
20:35:22 <lispy_> SyntaxNinja: hehe
20:35:50 <lispy_> SyntaxNinja: sorry, i couldn't edit the cabal-get code because it has characters past column 80, so i was going to try the latest yi :)
20:36:09 <SyntaxNinja> heh
20:37:18 <dons> lispy, autoreconf
20:38:39 <lispy_> SyntaxNinja: so, how does cabal-get decide where to install the libraries?
20:39:10 <lispy_> dons: i should re-run configure then i take it
20:39:30 <lispy_> at least it certainly can't hurt
20:40:03 <lispy_> dons: thanks
20:40:07 <lispy_> dons: i'm a tard :)
20:40:17 <SyntaxNinja> hey, lispy_: I gotta go.
20:40:20 <SyntaxNinja> email me
20:40:23 <lispy_> SyntaxNinja: okay....
20:47:52 <lispy_> dons: make[1]: *** No rule to make target `Buffer/Buffer0.hs', needed by `run-utests'.  Stop.
20:48:10 <lispy_> did you forget to check it in perhaps?
20:48:13 <dons> hmm. checking...
20:48:20 <FrederikEaton> template haskell help!
20:48:21 <FrederikEaton>     Couldn't match `String'
20:48:22 <FrederikEaton>            against `Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp'
20:48:25 <FrederikEaton>       Expected type: String
20:48:27 <FrederikEaton>       Inferred type: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
20:48:37 <FrederikEaton> it worked before
20:48:44 <lispy_> dons: it's in testsuite/Tests/
20:49:05 <lispy_> dons: i got a warning from darcs about trying delete a non-empty dir when i did the pull...
20:49:05 <dons> hmm. looks like you have an old yi?
20:49:18 <lispy_> dons: what should the directory structure be like?
20:49:39 <dons> can you reget
20:50:01 <lispy_> dons: looks like i just need to move that file and delete the dir
20:50:10 <lispy_> dons: darcs should have done it, but it hit a known bug
20:50:38 <dons> ok. there's no Buffer0 anyway. it's Buffer.hs
20:51:27 <lispy_> hmm...yeah, maybe i should reget because this repo has a lot of changes to be recorded, and it shouldn't
20:51:38 <FrederikEaton> oh, i had to put {-# OPTIONS_GHC -fth #-} at the top. I wonder why it suddenly broke
20:51:39 <lispy_> and yet it thinks itself to be up to date
20:54:13 <lispy_> dons: have you had a chance to look at the line wrap thing?
20:54:22 <lispy_> dons: that's my whole reason for trying to update
20:56:40 <dons> haven't had a look at it yet.
20:57:44 <lispy_> dons: i'd like to have a go at it
20:57:51 <lispy_> dons: where should i start looking?
20:58:19 <lispy_> i think that's the last feature that really prevents me from using yi full time
20:59:36 <dons> you need to look in UI.hs at drawWindow, then think about what effect wrapping lines will have on the window state in Window.hs
21:02:22 <lispy_> dons: cool
21:02:29 <lispy_> dons: i'll see how far i get :)
21:02:51 <lispy_> someone just reminded me of this: http://www.ubergeek.tv/article.php?pid=54
21:21:55 <lispy_> dons: so i'm looking at the code for drawing the modeline and i'm wondering.  Wouldn't it be easier to draw the screen, then draw the modeline afterwards, on top of the last line?
21:23:53 <dons> what if there are multiple windows on the screen?
21:24:23 <lispy_> and each window has a modline?
21:24:42 <dons> yep.
21:24:45 <dons> try :split in vim mode
21:25:09 <lispy_> in that case you'd draw the window, then you ask the modeline how big it is, then draw it on top of the window
21:25:53 <dons> we'd also need to adjust the visible window area though so yi knows when to start scrolling
21:26:20 <dons> what's wrong with the modeline code anyway?
21:26:24 <lispy_> nothing
21:26:46 <lispy_> just curious if there was a reason to do it the way it is, veruses what struck me as the natural way
21:27:04 <lispy_> i'm trying to understand the code, mostly
21:27:15 <lispy_> don't read into my questions too much :)
21:27:29 <dons> i don't understand why the way it is done isn't natural?
21:27:40 <dons> i.e. draw n-1 lines of buffer, draw modeline
21:27:56 <dons> or are you using modeline when you mean minibuffer?
21:28:28 <lispy_> i bet i mean minibuffer
21:28:53 <dons> the buffer you type stuff into at the very bottom?
21:28:57 <lispy_> there is a comment about handling tabs, is that still valid?
21:29:12 <dons> that's isn't handled so nicely atm, but I'm replacing the minibuffer code with a real buffer anyway
21:29:23 <lispy_> ah, col
21:31:03 <lispy_> it says len doesn't take into account tabs, so how would i get the display length of a line?
21:31:14 <dons> that comment seems out of date
21:32:16 <dons> len does actually give us the display width now
21:32:58 <lispy_> okay
21:32:59 <lispy_> cool
21:33:02 <dons> see ptrToLnsB in FastBuffer.hs
21:33:25 <lispy_> i'm going to remove that part of the comment
21:42:29 <lispy_> dons: could ptrToLnsB just chop up long lines?
21:42:41 <lispy_> dons: or would that cause problems with editing those lines?
21:46:09 <dons> you can't mutate the lines, if that's what you meaan
21:46:47 <dons> you could copy and chop
21:47:03 <lispy_> i can change the return value tho right?
21:47:44 <dons> of ptrToLnsB ? hmm.
21:47:45 <lispy_> longline -> [(part1, 80), ..., (partn, x)], and then x is just the remainder
21:51:37 <lispy_> is what is the first part of the tuple?
21:51:54 <lispy_> it's ptr to part of the string?
21:54:06 <dons> write an alternative to ptrToLnsB  if you want to split up lines, please, so we can try them both out.
21:54:17 <dons> yep, they're just CStringLen types
22:01:29 <lispy_> dons: Yi/FastBuffer.hs:339:4: `ptrToLnsB2' is not a (visible) method of class `Buffer'
22:01:35 <lispy_> how would i fix that?
22:01:42 <lispy_> i've never seen that error before
22:01:48 <lispy_> (i added ptrToLnsB2 )
22:03:23 <lispy_> oh, n/m
22:03:29 <lispy_> it's in Buffer.hs
22:07:08 <SyntaxNinja> lispy_: still here?
22:08:36 <lispy_> SyntaxNinja: yeah
22:09:19 <lispy_> SyntaxNinja: i don't understand how cabal-get knows where to install things
22:09:40 <SyntaxNinja> lispy_: OK, so you've got it installed? and cabal-get --help works?
22:10:12 <SyntaxNinja> do you have ~/.cabal-get?
22:11:03 <SyntaxNinja> I just added dot-cabal-get to that darcs archive, so darcs pull will give you a directory
22:11:14 <SyntaxNinja> cp -r dot-cabal-get ~/.cabal-get
22:13:37 <lispy_> i haven't installed it yet
22:13:46 <SyntaxNinja> I don't understand your question
22:14:13 <SyntaxNinja> OK where do you want it to install?
22:16:04 <lispy_> i want to be sure that the packages i install using cabal-get install to the right place
22:16:20 <lispy_> i don't much care where cabal-get is as long as it's in my path
22:19:56 <SyntaxNinja> OK. well, you can just always install everything with --user-install, and it'll put it somewhere in your home directory, and you can blow it away later
22:20:04 <SyntaxNinja> It doesns't look like it has a --prefix flag yet
22:20:52 <SyntaxNinja> I guess  if you use --user-install it'll put everything in ~/usr
22:21:32 <lispy_> i thought this installed libraries for ghc
22:22:11 <lispy_> dons: ptrToLensB confuses me. i thought it was returning tuples, but itdoesn't
22:22:13 <SyntaxNinja> yeah, it puts them in ~/usr/lib, and modifies ~/.ghc-packages
22:22:26 <SyntaxNinja> so ghc knows where to find them by looking there
22:22:43 <SyntaxNinja> actually for ghc 6.4, it puts them in ~/.ghc/i386-linux-6.4/package.conf
22:22:53 <lispy_> return ((this,size) : ptrs)  <-- sure looks likeit's going to return a list of tuples
22:23:17 <lispy_> SyntaxNinja: what if you're not on linux?
22:24:28 <SyntaxNinja> lispy_: are you on windows?
22:24:40 <lispy_> SyntaxNinja: osx
22:24:49 <dons> lispy, it does. look at its type ptrToLnsB  :: a -> Int -> Int -> Int -> IO [CStringLen]
22:25:07 <lispy_> @index CStringLen
22:25:08 <lambdabot> Foreign.C.String, Foreign.C
22:25:12 <dons> type CStringLen = (Ptr CChar, Int)
22:25:36 <SyntaxNinja> lispy_: which ghc?
22:25:42 <lispy_> it's run length encoded strings?
22:25:45 <lispy_> SyntaxNinja: 6.4
22:25:52 <SyntaxNinja> lispy_: just say ghc-pkg -l
22:25:58 <SyntaxNinja> and it'll show you where the config file is
22:26:10 <SyntaxNinja> I'm not sure where cabal-get will put the files, but I bet it'll put them in ~/usr
22:26:18 <SyntaxNinja> it's just unix after all
22:28:27 <mwc> lispy_, darwinports stuff? It's in /opt/local/lib/haskell_lib_name genreally
22:28:42 <lispy_> dons: an, i think the type errors were just confusing me
22:29:00 <lispy_> mwc: yeah it is
22:29:38 <lispy_> well, /opt/local/lib/ghc-version/libname
22:31:06 <SyntaxNinja> lispy_: is that where cabal puts stuff?
22:31:50 <lispy_> SyntaxNinja: i don't know if i use cabal
22:32:04 <lispy_> i don't think i do
22:32:13 <lispy_> i don't have it installed
22:33:48 <lispy_> dons: weird, my version of ptrToLensB didn't have any noticable effect
22:36:14 <SyntaxNinja> yeah, looks like cabal just puts it into /usr/local
22:36:17 <SyntaxNinja> is that incorrect on macOS X?
22:36:35 <lispy_> not necessarily
22:36:48 <lispy_> it's /User here, but the fs is not case sensitive
22:38:10 <SyntaxNinja> will it make you happy if I add a prefix flag to cabal-get?
22:38:35 <lispy_> i don't think i need one anymore, but that's a nice thing to have
22:38:55 <lispy_> i really don't care where cabal-get lives
22:39:17 <lispy_> i was concerned that things i install wouldn't be found by ghc
22:39:33 <SyntaxNinja> oh they'll be found by ghc
22:43:45 <SyntaxNinja> you worry too much... be cool with the cabal
22:44:05 <lispy_> heh
22:44:14 <lispy_> so what is cabal? i've never used it
22:46:13 <SyntaxNinja> haskell.org/cabal :)
22:47:04 <FrederikEaton> i heard it sux
22:47:45 <FrederikEaton> just kidding!
22:48:07 <SyntaxNinja> you're lucky I don't know my ops password offhand
22:48:31 <lispy_> sounds like ASDF
22:50:54 <lispy_> is scannedinavian down?
22:50:58 <lispy_> http://scannedinavian.org/cgi-bin/hackage/hackage
22:51:23 <lispy_> ah, nope, just that url is dead
22:51:31 <SyntaxNinja> hackage is now here: http://hackage.haskell.org/ModHackage/Hackage.hs
22:59:43 <lispy_> SyntaxNinja: which version of cabal do i need?
22:59:58 <SyntaxNinja> at least 1.1.1
23:00:19 <lispy_> the cabal README says this could screw up my system
23:00:40 <lispy_> since ghc takes 6 hours to compile i'd rather not screw things up :)
23:01:17 <SyntaxNinja> bha
23:03:47 <lispy_> hmm.. cfindlength doesn't seem to return the real length
23:06:30 <SyntaxNinja> there, I added a prefix flag :)
23:06:50 <SyntaxNinja> I need some brave beta tester!
23:07:41 <lispy_> indeed, i'm too chicken to install cabal
23:10:04 <SyntaxNinja> bah, the cabal has you already and you don't even know it
23:10:08 <SyntaxNinja> ghc-pkg -l |grep Cabal
23:12:48 <lispy_> it's a good thing i didn't try to install it
23:12:56 <lispy_> i would have followed the wrong set of instructions
23:32:35 <lispy_> man, sometimes i cannot please the layout rule "."
23:32:50 <lispy_> and it's the most frustrating thing
23:34:20 <mwc> lispy_, have ye foresworn the use of the tab?
23:34:38 <mwc> For the tab is a fickle indent
23:34:45 <mwc> but the space shall stand by ye side all times
23:34:57 <SyntaxNinja> M-x untabify is your only hope
23:35:11 <lispy_> no tabs
23:35:25 <lispy_> i turned that off ages ago when darcs wouldn't build :)
23:35:38 <SyntaxNinja> it's probably because your cabal is too old ;)
23:37:02 <mwc> lispy_, there was a new Ghc in dp tonight
23:37:08 <mwc> might have a new cabal version
23:37:25 <lispy_> mwc: hmm...
23:39:23 <lisppaste2> lispy_ pasted "layout rule hates me..." at http://paste.lisp.org/display/10988
23:49:13 <mwc> Hahahah: GNU Emacs: Generally Not Used Except by Middle Aged Computer Scientists
23:49:19 <lispy_> ah, the last line in the let wasn't lined up
23:52:20 <tessier__> Emacs: Eighty Megs And Constantly Swapping
23:52:46 <lispy_> Emacs: Long Live Yi!
23:53:05 <mwc> tessier, come now, it's improved since 1985 :P
23:53:13 <mwc> Eighty Megs And Constantly Swapping :P
23:54:14 <lispy_> geez...just updating my ports index takes ages
23:54:54 <mwc> lispy_, wait until it bootstraps ghc and all its libs :P
23:55:02 * mwc goes to see if that process is done
23:55:24 <lispy_> mwc: yeah, i'll leave it running while i sleep
23:56:12 * lispy_ misses apt
23:57:36 <mwc> and the three repos: Stale, Rusting, and Broken :P
23:58:36 <lispy_> i don't hve any outdated ports
23:58:49 <mwc> Oh, I had a bunch
23:58:58 <mwc> well, then your cabal should be pretty damn recent\
23:59:55 <lispy_> dons: it *displays* correctly, but...the cursor freaks out around the screen
