00:01:05 <dons> lispy_, cool. so the problem now (I guess) is that the value of cursor has to be modified based on how many lines you wrapped.
00:06:21 <lispy_> dons: well, i got some of the display problems fixed
00:06:41 <lispy_> dons: but sometimes, it goes all screwy still.  It happens when i scroll up and down in a file with long lines
00:07:03 <lispy_> mwc: i have 1.0, need 1.1.1
00:07:18 <mwc> hmm, I thought it was distributed with GHC?
00:07:21 <lispy_> dons: the cursor literally jumps all over the screen
00:08:11 <lispy_> dons: should i check in the code so you can take a look?
00:08:18 <lispy_> well, email you patch
00:15:03 <dons> send me that patch, i'll take a look
00:15:13 <dons> sounds promising though
00:16:26 <lispy_> it's a start :)
00:16:37 <lispy_> i had to add some C code
00:16:59 <lispy_> the function that cfindlenghth uses didn't give any clue which lines are long lines
00:18:58 <lispy_> so, calculating the length of a long line is now O(n) where n is the length of the line
00:19:08 <lispy_> it used to be constant time :)
00:19:18 <lispy_> at least the display calculation
00:19:50 <dons> hmm. ok. it mightn't matter, we can always profile to check
00:19:57 <dons> want to keep performance high
00:20:28 <dons> btw, if you have time on your hands, maybe you could darcs get h4sh and see if it builds on the mac with the new mmap packed string io code
00:20:37 <dons> @where h4sh
00:20:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
00:20:47 <lispy_> okay
00:20:53 <lispy_> as long as i don't have to reinstall ghc
00:20:58 <dons> should be just: PREFIX=/f/g make ; make install  ; make check
00:21:04 <dons> hope not
00:21:34 <wnoise> @help
00:21:35 <lambdabot>  @help <command> - ask for help for <command>
00:21:44 <wnoise> @help seen
00:21:46 <lambdabot> Report if a user has been seen by the bot
00:24:25 <lispy_> it's trying to beild at least
00:29:31 <lispy_> hmm..still compiling
00:32:46 <dons> lispy, takes a while ...
00:33:24 <lispy_> dons: any idea what causes the cursor weirdness?  It got a little better when i added the "take (h-off)..." line
00:34:08 <dons> i need to fix up the build system a bit. cabal insists on recompiling FastPackedString every time
00:34:21 <dons> the cursor position will be off as soon as you wrap a line
00:34:55 <dons> possibly it even refers to a line off the screen after wrapping
00:35:18 <lispy_> dons: h4sh works
00:35:40 <dons> great!
00:36:09 <dons> hopefully `i' should be the same speed as `cat'
00:36:46 <lispy_> nah, it's about twice as fast as cat
00:37:18 <lispy_> ah, unless i > /dev/null
00:37:22 <lispy_> then cat is slightly faster
00:37:32 <dons> cool!
00:37:41 <lispy_> hmm...
00:37:41 <dons> io in haskell ain't so bad after all ;)
00:37:49 <lispy_> there is a lot of variance
00:37:58 <lispy_> they are pretty much the same speed
00:38:09 <dons> try with much larger sets of data.
00:38:15 <lispy_> ah, yeah
00:38:19 <dons> i.e. cat testsuite/data testsuite/data .....
00:38:22 <lispy_> you mean README isn't enough :)
00:38:37 <dons> ah, yes.
00:38:53 <lispy_> that file is tiny too
00:39:40 <dons> well, I have some files from 1M to 500M on my disk for testing purposes, but probably pasting them into irc is a bad idea
00:42:19 <lispy_> oh, hmm...this file takes cat over a minute, but i doesn't seem to have slowed down
00:42:55 <dons> hasn't slowed down? how fast does it take i?
00:43:02 <dons> what size is the file, btw?
00:43:37 <lispy_> ah, so many quesiton
00:43:50 <lispy_> i'm not sure how big the file is, ls on osx doesn't support -sh
00:44:07 <dons> du -h ?
00:44:44 <lispy_> ah, 416megs
00:44:58 <lispy_> $ time i foo >/dev/null
00:44:58 <lispy_> real    0m0.102s
00:45:15 <dons> mmap rocks :)
00:45:40 <lispy_> $ time cat foo >/dev/null
00:45:40 <lispy_> real    0m21.484s
00:46:04 <lispy_> my disk grinds a lot more when cat is doing it
00:46:11 <lispy_> i suspect there is swaping going on
00:47:10 <dons> cool. i is a better cat, it seems :)
00:49:04 <lispy_> heh, there is a manifesto
00:51:13 <lispy_> unfoldr is supported?
00:51:17 <lispy_> oh my...
00:51:23 <dons> :D
00:52:01 <dons> every shell needs unfoldr
00:54:47 <lispy_> heh
00:59:57 <lispy_> dons: $ fold '(++)' HOWTO
00:59:57 <lispy_> fold: (++): No such file or directory
01:00:09 <lispy_> so, i guess that example doesn't work so well in bash
01:02:17 <shrimpx> isn't there some shell thing that allows you to use haskell combinators at the CLI?
01:02:59 <lispy_> @where h4sh
01:03:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
01:03:15 <lispy_> shrimpx: i think you mean h4sh
01:06:39 <lispy_> ah, it should be foldl not fold
01:06:49 <dons> foldl
01:10:10 * lispy_ just used darcs to send in a 1 character patch
01:10:16 <shrimpx> dons: you're chakravarty's student?
01:10:22 <dons> yep
01:10:28 <shrimpx> cool
01:11:00 <shrimpx> he published a paper on intermediate functional form that was totally busted and he never responded to my emails :)
01:12:46 <dons> oh :/
01:13:30 <dons> shrimpx, the SSA<->ANF paper?
01:14:12 <shrimpx> ya
01:14:36 <xerox> yo
01:15:25 <shrimpx> i found it ironic that the paper "complains" that appel's informal presentation of intermediate FF is inadequate, to go ahead and present a formal but wrong translation :)
01:15:39 <sieni> http://www.kotuvepis.com/sansiszanlar/QueenandScotssoldiers.jpg
01:15:55 <dons> i think patrykz was the main guy on that translation, maybe you should mail him?
01:16:02 <shrimpx> ya i did
01:16:13 <shrimpx> never heard from him
01:16:19 <shrimpx> shrug
01:16:25 <dons> yeah, he's kind of bad on the email :/
01:17:09 <dons> however, you could try again. he's doing most of his phd on the SSA work, so he's definitely the guy to ask
01:17:18 <shrimpx> oh really
01:17:23 <shrimpx> ok
01:17:37 <shrimpx> i figured that project was just something they picked up and left alone
01:17:39 <dons> he's be translating other fancier SSA algos to ANF the past year, iirc
01:18:14 <dons> no, it's on going. we use ANF for some other things too.
01:18:38 <shrimpx> ANF is OK, it's just the translation that was busted. most likely easily fixable too
01:19:02 <shrimpx> i attempted to implement for a class project =)
01:19:08 <shrimpx> s/for/it for/
01:19:32 <dons> it may well have been improved since  the paper was released.
01:19:40 <dons> let me see if i can find his phd review slides somewhere
01:21:45 <dons> hmm. doesn't seem to have the slides up. i'll mention your query when I see him in a couple of days though.
01:22:52 <shrimpx> k
01:23:06 <shrimpx> my emails are in his inbox somewhere =)
01:47:55 <lispy_> dons: make check doesn't appear to finish on my system in h4sh
01:48:08 <lispy_> dons: it's been running for about 30 minutes on the same test
01:49:52 <vikasg> @hoogle parseHtmlContent
01:50:59 <xerox> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/Text.XML.HXT.Arrow.XmlFilterInterface.html
01:50:59 <xerox> ?
01:52:44 <vikasg> thanks. I guess lambdabot doesn't love me ;)
01:54:13 <dons> lispy, yeah. have noticed this on linux too. not sure what the story is.
01:54:15 <jlouis> ANF?
01:54:23 <jlouis> Some Normal Form?
01:55:04 <dons> the 'A' stands for 'A'
01:56:06 <dons> lispy_, what test does it get up to?
01:56:16 <autrijus> Administrative
01:56:59 <autrijus> (also known as let-normal form)
01:58:33 <jlouis> found it. Thanks
02:00:43 <dons> lispy_, actually the tests do terminate properly on linux. any more info on where it stops?
02:13:35 <lispy_> Cases: 30  Tried: 23  Errors: 0  Failures: 0
02:13:48 <lispy_>   22 binary:testElemIndices
02:13:48 <lispy_>   23 binary:testDropWhile
02:13:48 <lispy_>   24 binary:testTakeWhile
02:13:57 <lispy_> so it's either testDropWhile or testTakeWhile
02:15:14 <lispy_> dons: if you need more info you'll have to ask me tomorrow, i'm going to bed :)
02:15:21 <lispy_> or send me an email
02:39:06 <FrederikEaton> somebody look at my library: http://ofb.net/~frederik/futility/
02:47:04 * Lemmih looks.
02:54:03 <FrederikEaton> Lemmih: well, is the distribution method at all interesting? or is it done already?
03:03:19 <Lemmih> Looks good. Except I'm allergic to WASH and shell scripts.
03:08:21 <FrederikEaton> well then how can you think it looks good? :)
03:08:35 <FrederikEaton> what's wrong with WASH?
03:08:58 <FrederikEaton> i want to make WASH non-javascript-dependent, but i don't know what's involved
03:09:58 <FrederikEaton> as for the shell scripts, they are necessary hacks for the moment
03:10:04 <FrederikEaton> until cabal improves
03:10:13 <FrederikEaton> but thanks
03:14:29 <Lemmih> What does Cabal lack for you to properly cabalize the library?
03:22:34 <FrederikEaton> Lemmih: oh, lots. grep for XXXCabal in the code
03:23:29 <FrederikEaton> for instance, this is pretty basic: i want to only build and expose certain modules if packages they depend on are available
03:24:14 <FrederikEaton> but the .buildinfo file which cabal will let me produce with my handmade configure script (which must be a 'sh' script, by the way) can't specify build-depends or exposed-modules
03:24:24 <FrederikEaton> lots of bugs, in other words
03:25:33 <FrederikEaton> but i don't see why one should be opposed to use of shell scripts per se
03:25:43 <Lemmih> Cabal has good reasons to disallow that. We need the scheme simonMar proposed to fix it.
03:25:56 <FrederikEaton> what scheme?
03:26:01 <FrederikEaton> what good reasons?
03:26:16 <FrederikEaton> wait, save your breath, you can put it on the wiki
03:26:18 <FrederikEaton> when i get that set up
03:29:10 * FrederikEaton does yoga
03:57:45 * shapr boings
04:29:28 <shapr> dons: newspaper is a bit like governers-general.
04:30:57 <Heffalump> autrijus: ping?
04:44:27 <psi> I'm trying to creating a textBuffer in gtk2hs using this line: 'buffer <- textBufferNew Nothing', but I get this error message: Ambiguous type variable `a' in the constraint: `TextTagTableClass a' arising from use of `textBufferNew' at text.hs:13:12-24
04:44:43 <psi> Probable fix: add a type signature that fixes these type variable(s)
04:44:53 <psi> I don't really understand what to do
04:45:55 <shapr> psi: Try adding a more explicit type signature to buffer, or to the "textBufferNew Nothing" call.
04:46:42 <shapr> psi: It means that the result of textBufferNew has a class constraint, probably something like (TextTagTableClass a) => textBufferNew :: foo -> a
04:48:39 <psi> textBufferNew :: (TextTagTableClass table) => Maybe table -> IO TextBuffer
04:48:51 <psi> ok, hold on :)
04:50:03 <shapr> So you need to tell it the actual type of `table'.
04:52:51 <shapr> I'm switching to firefox from galeon, in galeon I have galeon -x $URL that loads the url on the command line into the existing galeon window. How can I do that with firefox?
04:52:57 <shapr> hoi Itkovian, hoe gaat het met jou?
04:54:55 <psi> mozilla -remote "openurl(http://www.mozilla.org)"
04:55:04 <psi> or firefox
04:55:40 <Itkovian> hi shapr: zeer goed.
04:56:19 <shapr> psi: ah, thanks!
05:12:01 <greenrd> Has anyone here tried Epigram?
05:12:08 <shapr> epigram r0xx0rs
05:12:22 <greenrd> It sounds exciting.
05:12:24 * shapr luvs dependent type systems.
05:12:47 <greenrd> I looked at Cayenne, but the download link didn't work.
05:12:53 <shapr> Have you seen Timber?
05:12:58 <greenrd> Are there any other practical implementations of dependent type systems?
05:13:01 <greenrd> No
05:13:15 <shapr> Do you read lambda-the-ultimate.org ?
05:13:33 <shapr> Yes, there are other dependently typed systems. Have you seen Tim Sheard's Omega?
05:13:57 <greenrd> Yes, I read it occassionally
05:14:07 <greenrd> much of it goes right over my head
05:14:17 <shapr> Grab a life preserver and jump on in :-)
05:14:55 <Heffalump> you count Epigram as practical? :-)
05:14:57 <shapr> Have you read the epigram tutorial?
05:15:31 <greenrd> Heffalump: I don't know, I haven't tried it yet. But you can download it and run it...
05:15:47 <greenrd> shapr: I'm reading it now
05:17:43 <kosmikus> omega isn't dependently typed
05:18:30 <shapr> No, but Tim Sheard says that it can do the same thing and possibly better.
05:19:00 <kosmikus> yes, that's what he says
05:19:07 <shapr> I don't know if he's right, but it's one of my thunks on dependent types that I need to eval at some point.
05:19:13 <greenrd> heh
05:19:45 <shapr> Anyway, Tim has a bunch of good ideas, so I think Omega is worth investigating.
05:21:30 <kosmikus> certainly
05:24:25 <Philippa> I *still* need to talk to Conor&co about Epigram
05:24:34 <Philippa> but worst case I'll gatecrash the undergrad course on it this semester :-)
05:25:42 <greenrd> Philippa: You are at Durham?
05:26:32 <Philippa> Nottingham
05:27:50 <greenrd> ah
05:28:32 * greenrd thinks... _undergrad_ course on Epigram?
05:28:37 <Philippa> yup
05:28:47 <integral> 4th year?
05:28:52 <shapr> greenrd: Are you going to a UK uni?
05:28:54 <Philippa> nope, 2nd and 3rd
05:29:06 <integral> wow
05:29:11 <Philippa> mind you, at least half of it's just getting used to using dependant types, and we cover haskell in the first year
05:29:11 <greenrd> shapr: No, but I'm due to start at University College Dublin in October.
05:29:29 <greenrd> shapr: doing an MSc then PhD in formal methods
05:29:30 <Philippa> it's not like people'll walk out with their own epigram implementation
05:29:37 <shapr> greenrd: Nifty!
05:30:04 <shapr> greenrd: What sort of formal methods? Proving code? QuickCheck-style?
05:30:40 <greenrd> I'm not entirely sure. I'll be working on the MOBIUS project, which seems to be concerned with proving security properties of Java code and stuff like that.
05:30:54 <shapr> Ah, ok.
05:31:21 <shapr> "MOBIUS: Integrated Development Environments supporting Logic-based Verification of Sequential and Concurrent Java programs with Proof-Carrying Code"
05:34:12 <greenrd> I believe that describes the particular area of the MOBIUS project that UCD is focusing on, not the whole MOBIUS project, fwiw.
05:44:56 <greenrd> shapr: Let me ask a possibly flamebait question (I plead ignorance!). Given that a full dependent type system is undecidable, is there a practical difference between (a) using dependent types and proving type correctness, and (b) using ordinary Haskell and proving theorems about your functions?
05:45:18 <greenrd> Other than (a) involves learning a lot of new concepts
05:45:26 <greenrd> i.e. is it worth bothering with?
05:45:39 <Philippa> yes
05:45:50 <Philippa> dependant types have a direct link between the code and the proofs
05:46:10 <Philippa> in particular they encourage you to structure the code in such a way as to make the proofs easier
05:46:19 <greenrd> OK, that sounds good
05:46:58 <Philippa> additionally, because those proofs are available to the implementation they can be used to demonstrate useful properties for the benefit of an optimiser
05:48:09 <Philippa> finally, because of that direct link, the dependantly typed language can do a better job of inferring the obvious bits for you
05:48:51 <greenrd> OK, so in practice, there are practical advantages.
05:49:10 <greenrd> But it seems to me that all of those could be true of ordinary Haskell with a theorem proving infrastructure bolted on.
05:49:16 <greenrd> In principle.
05:49:22 <Philippa> in principle
05:49:36 <Philippa> in practice, that fragments the community and all sorts of crap like that
05:50:05 <Philippa> it also forces you to sometimes separate out language-level and proof-level concepts in a way that's not always healthy
05:50:35 <shapr> greenrd: You know the Curry-Howard correspondence?
05:51:22 <greenrd> I've heard of it, but I'm not sure I know what it is.
05:53:11 * shapr looks for the correct wikipedia url...
05:53:58 <shapr> http://en.wikipedia.org/wiki/Curry-Howard
06:00:23 <shapr> I wish I could use HaskellDB to generate queries for Zope/Plone.
06:00:31 * shapr hugs HaskellDB
06:01:10 <shapr> greenrd: #haskell is a good place to find new connections and avenues for learning and/or research.
06:06:49 <greenrd> OK
06:06:56 <greenrd> "the assertion of the type of value computed by a function is analogous to a logical theorem, and that the program to compute that value is analogous to a proof of that theorem."
06:07:15 <greenrd> The trouble is though, in Haskell, a program frequently _isn't_ a proof of type soundness.
06:07:40 <greenrd> Unless you consider "Error!" to match all types.
06:08:00 <greenrd> Which, presumably, is where dependent types come in.
06:08:16 <greenrd> (Not to match Error to all types, but to prevent run-time errors.)
06:10:11 <greenrd> Oh, that reminds me of a question I had earlier.
06:10:36 <greenrd> In and [a, b] is a always guaranteed to be evaluated first?
06:10:49 <Philippa> greenrd: _|_ does indeed belong to all types in Haskell
06:10:57 <greenrd> oh really?
06:11:04 <shapr> Nope, what about take 1 $ drop 1  [a,b]
06:11:17 <Philippa> yes, you can't really give it a formal semantics otherwise
06:11:36 <greenrd> shapr: "and [a, b]". You missed the and.
06:12:17 <Philippa> read the Haskell Report for definitions of the library funcs
06:12:32 <greenrd> Well I will check in there then
06:13:26 <wilx> Hah!
06:13:28 <shapr> Even with and, CSE could mean one or the other is evaluated first if it's the same as something else in the program.
06:13:30 * wilx has an idea.
06:13:36 * shapr lost an idea...
06:13:47 <wilx> How are the infix type constructores defined?
06:14:03 <wilx> constructors even
06:14:17 <wilx> Err, data constructors...
06:14:41 <wilx> It was something like :**: or something?
06:14:50 <xerox> morning
06:15:02 <xerox> wilx: yep, :whatever: IIRC
06:15:02 <Philippa> RTFGHCM :-)
06:15:07 <greenrd> shapr: So it's unsafe to say (this is psuedocode) "and [not (isEmpty collection), head collection = foo]"
06:15:18 <greenrd> ?
06:15:39 <xerox> wilx: maybe even ":whatever" you should "what Philippa said" :-P
06:15:58 <Philippa> you won't get bitten by common subexpressions turning into a single thunk on that
06:15:59 <wilx> Heh :)
06:16:00 <wilx> Ok.
06:16:01 <Philippa> but read the definition
06:16:13 <Philippa> I don't think there's any definition of evaluation order in Haskell 98 beyond "non-strict"...
06:16:23 <Lemmih> greenrd: There are no destructive updates in Haskell.
06:16:28 <greenrd> Philippa: That's what I thought.
06:16:34 <shapr> Is call-by-need specified?
06:16:35 <greenrd> Lemmih: I know, but that's not the problem.
06:16:43 <Philippa> shapr: I'm not certain it is
06:16:44 <shapr> greenrd: It is actually...
06:16:51 <greenrd> Lemmih: The problem is, head might fail if collection is empty.
06:16:53 <Lemmih> greenrd: What did you mean by 'head collection = foo' then?
06:17:00 <greenrd> ==
06:17:04 <shapr> ah
06:17:06 <xerox> greenrd
06:17:10 <xerox> @plugs head []
06:17:13 <Philippa> he did say it's pseudocode
06:17:30 * shapr is being pedantic then...
06:17:32 <xerox> ...it raises an exception
06:17:39 <lambdabot> <Plugins.Eval>:1:12:
06:17:39 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:17:39 <lambdabot>   `Show a' arising from use of `show'
06:17:50 <Philippa> heh
06:17:51 <xerox> @plugs head [] :: [Int]
06:17:56 <lambdabot> Prelude.head: empty list
06:18:12 <xerox> In fact that should have been :: Int, OK :-)
06:19:28 <greenrd> So, how should my pseudocode be rewritten to be safe?
06:20:22 <Lemmih> greenrd: case isEmpty collection of True -> ..; False -> ...
06:21:16 <greenrd> or equivalently, if (isEmpty collection) then False else (head collection) == foo
06:21:20 <greenrd> ok
06:21:47 <greenrd> so, the if construct has an evaluation order, but the and doesn't?
06:22:00 <greenrd> Is that right??
06:22:18 <Lemmih> Not exactly.
06:22:34 <greenrd> OK. Please explain.
06:22:35 <Lemmih> In Haskell we only evaluate things in pattern matches.
06:23:30 <greenrd> Nothing else?
06:23:32 <Lemmih> @plugs and [False,undefined]
06:23:36 <lambdabot> False
06:23:45 <SamB> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
06:23:48 <lambdabot> Prelude.asTypeOf :: (a -> a -> a)
06:23:48 <lambdabot> Prelude.(**) :: Floating a => (a -> a -> a)
06:23:48 <lambdabot> Prelude.logBase :: Floating a => (a -> a -> a)
06:23:50 <greenrd> @plugs and [undefined,False]
06:23:54 <lambdabot> Prelude.undefined
06:23:56 <Lemmih> 'and' doesn't evaluate the list randomly.
06:24:10 <greenrd> That's what I thought.
06:25:20 <greenrd> But couldn't it evaluate right-to-left?
06:25:23 <greenrd> Just to be perverse.
06:25:59 <greenrd> @help plugs
06:26:00 <lambdabot>  @eval <expr>
06:26:00 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
06:26:12 <Lemmih> @eval let rAnd = and.reverse in rAnd [undefined,False]
06:26:14 <lambdabot> False
06:27:55 <greenrd> @eval let officialAnd = foldr (&&) True in officialAnd [False,undefined]
06:27:58 <lambdabot> False
06:28:54 <shapr> TheHunter: Any idea where I can get Sennheisers online for a decent price?
06:29:21 <xerox> TheHunter: hey!  Do you remember the Matrix thing?  I rewrote it purely in Haskell :-)
06:29:53 <Philippa> greenrd: you're trying stuff on one implementation
06:30:10 <Philippa> RTFReport for the definitive answers :-)
06:30:12 <greenrd> true
06:30:52 <greenrd> The report does not say anything about the order of evaluation of 'and'
06:31:10 <greenrd> so I must conclude that my code is unsafe, but happens to work
06:31:52 <Philippa> um, it may say more general things that dictate appropriately?
06:32:10 <Philippa> for example, does it insist and must be equivalent to a specific fold?
06:32:12 <greenrd> True, it may
06:32:19 <greenrd> No.
06:32:23 <basti_> hi
06:32:31 <xerox> Howdy basti_
06:32:42 <greenrd> Philippa: But common sense dictates that the only sensible way to implement the requirements is left-to-right.
06:33:52 <greenrd> Because right-to-left wouldn't work on an infinite list, and anything else would be, well, silly.
06:34:09 <greenrd> But I'm not sure how to formalise the notion of "anything else would be silly" into a formal proof :)
06:34:15 <jlouis> first the odds, then the evens?
06:34:21 <Philippa> is there any requirement to do anything but fail to terminate on an infinite list?
06:34:26 <greenrd> jlouis: Yes, but why?
06:34:33 <Philippa> because you sure can't return True
06:34:36 <jlouis> Odd register layoutts
06:34:44 <jlouis> nah, not plausible
06:34:45 <mflux> let's say you wanted to do and [a, b, c] of which b would already be evaluated but the others not, wouldn't it make sense to shortcut on b then?
06:34:51 <greenrd> Philippa: No but you can return False if any element is False
06:35:02 <Philippa> yes, but again: is there a requirement to do that?
06:35:14 <Philippa> the input's non-terminating, does and have to be non-strict?
06:35:56 <greenrd> Sorry yes, the requirement is to return False if any element is False on an infinite or finite list.
06:36:16 <Philippa> fair enough then, that pretty much does dictate the evaluation order
06:36:16 <greenrd> Well no, it doesn't actually _say_ that.
06:36:23 * Philippa coughs
06:36:31 <Philippa> where do you infer it from, then?
06:36:38 <greenrd> It says "False, however, results from a False
06:36:38 <greenrd> -- value at a finite index of a finite or infinite list."
06:36:59 <greenrd> Of course it could not require the implementation to find a False value that is beyond the operational capacity of the runtime system to find.
06:37:03 <Philippa> then it /does/, right?
06:37:10 <Philippa> modulo storage, at least
06:37:13 <greenrd> yes
06:38:27 <greenrd> But I still maintain that you can't assume that in a proof, because the specification doesn't specifically exclude "silly" implementations like odd-even.
06:38:55 <Philippa> indeed
06:39:08 <Philippa> now, does it insist that it be equivalent to any other expression?
06:39:53 <greenrd> Yes, "or is the disjunctive dual of and", but "or" is only defined in terms of "and" so that's just a definition of or.
06:40:14 <greenrd> Other than that, no.
06:41:21 <greenrd> mflux: Maybe. But if b is undefined, could the program have reached that point? I am a little hazy on details like that.
07:14:25 <greenrd> I found a good discussion of when Curry-Howard applies to Haskell (and when it does not) at http://www.haskell.org/pipermail/haskell/2004-April/013993.html
07:17:32 <greenrd> shapr: Were you going to say something about Curry-Howard and dependent types vs other approaches earlier?
07:30:52 <shapr> greenrd: Probably, but I forget what I was going to say.
07:31:11 <shapr> Anyway, Philippa said that dependent types are closer to the CH isomorphism than other flavors.
07:32:03 <shapr> greenrd: In any case, please ask more questions along these lines, I don't know much about this subject and I often learn a lot just by reading the logs of this channel.
08:19:08 * shapr boings happily
08:20:10 <xerox> hey.
08:20:48 <goron> Is there some Haskell to PHP compiler ;)
08:21:57 <xerox> ?!?
08:22:05 <greenrd> lol
08:22:35 <xerox> @google failure
08:22:37 <lambdabot> http://www.whitehouse.gov/president/gwbbio.html
08:22:43 * xerox laughs
08:23:02 <ehuber> morning
08:23:09 <ehuber> lol...
08:23:17 <ehuber> is that unintentional ? :p
08:24:58 <shapr> hiya meren, how's code?
08:25:25 <shapr> goron: You could generate PHP code from Haskell source, but no one could maintain it...
08:25:43 <meren> shapr: great..
08:25:59 <barismetin> hi
08:27:00 <shapr> hiya barismetin, how's code?
08:27:29 <barismetin> shapr: haven't done anything for ages..
08:28:05 <shapr> You could hack on lambdabot, there's always fun stuff to do there.
08:28:11 <meren> eheh
08:28:32 <barismetin> shapr: where can I find the code?
08:28:49 <meren> i think you are much better than him shapr..
08:28:59 <xerox> @version
08:29:00 <lambdabot> lambdabot 3p73, GHC 6.5 (OpenBSD i386)
08:29:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:29:06 <xerox> There you go!
08:29:25 <shapr> meren: Yes, but I require much more downtime too.
08:29:40 <musasabi> Three days until holiday :-)
08:29:46 <musasabi> Lemmih: ping
08:29:51 <meren> shapr: it's okey with me
08:30:02 <barismetin> shapr: I'm in a search for an IDE for haskell.
08:30:04 <Lemmih> musasabi: pong.
08:30:08 <barismetin> do you have any opinions?
08:30:17 <musasabi> About the 64bit op thing.
08:30:20 <barismetin> xerox: thanks :)
08:30:22 <musasabi> I think I have ppc nailed.
08:30:27 <xerox> barismetin: you're welcome :)
08:30:31 <Lemmih> musasabi: Great!
08:30:34 <musasabi> On sparc the most sensible thing is to generate a call to the C library.
08:30:38 <shapr> barismetin: What about emacs?
08:30:40 <musasabi> Even gcc does that.
08:31:02 <barismetin> shapr: good shot. I love coding with emacs :)
08:31:08 <musasabi> Different sparc processors have different ways of doing 64bit math well and the whole issue is quite complicated there.
08:31:41 <xerox> @google emacs lisp packages haskell mode
08:31:44 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
08:31:51 <xerox> There she goooes again..
08:31:55 <shapr> haskell-mode 2.0 is decent.
08:31:55 <goron> shapr: Is the wxHaskell binding to Yi working?
08:32:02 <shapr> goron: I don't know, I haven't tried it.
08:32:25 <shapr> Wolfgang Thaller wrote it, has he released the code?
08:32:30 <shapr> @google thaller yi wxhaskell
08:32:32 <lambdabot> http://tunes.org/~nef/logs/haskell/04.12.07
08:32:35 <shapr> hmm
08:33:09 <vegai> do a google "failure", then click on the second hit
08:33:10 <vegai> does it go to the gwb page for you too?
08:33:25 <shapr> grr, how do I insert the X clipboard in gnumacs?
08:33:58 <shapr> I have insert-selection in xemacs, what's the equivalent in gnumacs?
08:34:20 <shapr> goron: http://www.cse.unsw.edu.au/~dons/Yi.jpg
08:35:06 <xerox> Wow.
08:35:25 <goron> shapr: Yes, I already followed that link in the log.
08:35:50 <shapr> dons: Is the wxYi hack in the repo?
08:35:54 <xerox> shapr: I usually use mouse middle click, which appears to be bound to mouse-yank-at-click.
08:36:48 <goron> shapr: or C-y
08:37:10 <xerox> Right.
08:37:11 <goron> shapr: I use middle mouse.
08:37:12 <shapr> Ah, C-y only inserts the *selection*, not the clipboard.
08:37:23 <shapr> Ok, how do I insert the clipboard?
08:37:27 <goron> shapr: uh, yes.
08:37:33 <xerox> It happens to isnert the clipboard too, here.
08:37:38 <xerox> insert, even
08:37:57 <goron> shapr: there are extensions to emacs which enable that behaviour.
08:38:10 <goron> shapr: I have those too. :)
08:38:20 <goron> Like selecting with arrows, etc.
08:38:29 <xerox> What?
08:38:42 <barismetin> shapr: I've a sensation that you are a bot.
08:38:43 <goron> Press SHIFT-up
08:38:48 <barismetin> shapr: may I see your code?
08:38:50 <goron> And get a line selected in emacs.
08:38:58 <xerox> goron: ah.
08:39:16 <goron> barismetin: You are not the first.
08:39:35 <barismetin> goron: so are you saying I'm right?
08:39:50 <shapr> barismetin: :-P
08:39:52 <goron> barismetin: No, I haven't seen bots that intelligent yet.
08:40:11 <shapr> I haven't seen bots that are as non-linear as I am.
08:40:19 <goron> shapr: Oh, I have.
08:40:30 <barismetin> goron: that is what made me suprised :)
08:40:45 <goron> barismetin: are you a bot?
08:40:47 <barismetin> shapr: so I really would like to see your code?
08:40:53 <barismetin> goron: some say so.
08:40:54 <vegai> sarahbot in scheme is sometimes quite surprising in her answers
08:40:56 <goron> ;)
08:40:57 <barismetin> :)
08:41:02 <shapr> barismetin: Sadly, my DNA is not up for display. I haven't even sequenced myself.
08:41:12 <vegai> you can query her too
08:41:23 <shapr> Speaking of nonlinearity, I've been thinking about functional programming for children...
08:41:26 <barismetin> shapr: too bad :(
08:41:39 <goron> shapr: Call it Fogo!
08:41:41 <vegai> shapr: what do you mean?
08:41:49 <goron> shapr: :P
08:42:11 <shapr> vegai: Combinator based 'programming' for kids, start with electrical components, expand to musical combinators, lots of systems could fit into that.
08:42:22 <goron> Why does everybody think that children are stupid?
08:42:23 <meren> shapr: you are just like a poet. i'll learn haskell because of you
08:42:32 <vegai> ls
08:42:35 <goron> Children have less knowledge, that's all.
08:42:45 <barismetin> shapr: even if you are a bot, you have much more intelligence than many of the people I know :).
08:42:52 <meren> eheheha
08:43:03 <shapr> For the first simplest system I'd want standard building block sized combinators. Make them clear, put simple electrical components into them, put weak magnets on the sides.
08:43:08 <shapr> That way, kids can put them together and see what happens.
08:43:53 <shapr> I figure it's good to start out with blocks like battery, speaker, LEDs, oscilloscope, an electrometer block that has displays for volts, amps, and watts, transformers, that sort of stuff.
08:44:01 <goron> shapr: for $$$?
08:44:16 <vegai> goron: I guess it's because of how they act :P And also, neuropsychology gives you some concrete evidence
08:44:17 <exa> I nearly forgot the slogan
08:44:26 <shapr> goron: I wouldn't mind, but only so that I could build some of my other ideas...
08:44:28 <exa> We put the Funk in Funktion, eh :)
08:44:37 <shapr> exa: Yes we do!
08:44:42 <shapr> meren: You can be a poet too!
08:44:46 <exa> all right then
08:44:53 <shapr> barismetin: thank you.
08:45:05 <goron> vegai: Well neuropsychogy doesn't do non-linear stuff.
08:45:09 <barismetin> shapr: it is what I think :)
08:45:12 <exa> shapr: prepare to melt your brain by listening to some MALFUNKT: myspace.com/malfunkt
08:45:14 <shapr> :-)
08:45:17 <vegai> 18:46  vegai >> How would you fix the middle-east problem?
08:45:17 <vegai> 18:46  sarahbot >> With a little bit of luck.
08:45:25 <exa> writing so much haskell code made me do that
08:45:30 <meren> shapr: don't do that!
08:46:01 <goron> vegai: #scheme?
08:46:01 <exa> definitely do that, meren is a C programmer, he doesn't know what he's talking about.
08:46:09 <meren> ehehe
08:46:24 <exa> on the other hand, i am an OCAML convert.
08:46:24 <vegai> goron: I'm /querying her, but she's in #scheme too, sure
08:46:35 <shapr> exa: Neat, where can I download the tracks?
08:46:58 <shapr> In-browser playing doesn't work when X isn't running.
08:47:01 <exa> shapr: you can download some stuff from malfunct.com
08:47:14 <meren> shapr: exa is an ocaml guy and trying to do something bad to you.. don't listen him.. trust me.
08:47:15 <exa> shapr: it's a soundclick.com page, just click on music link there
08:47:46 <exa> meren: I've crawled through an acre of type classes and monadic higher order functions to get to ocaml. Trust me.
08:48:15 <exa> Hey, I even know category theory. How could I go wrong about PL semantics?
08:48:40 <meren> i guess you are a bot too, exa.
08:48:42 <shapr> exa: Everybody gets to make their own choice.
08:48:53 <goron> "Last time I checked C is perfect!
08:48:55 <goron> "
08:48:55 <shapr> I prefer type classes and monadic functions.
08:48:57 <goron> Sarahbot
08:49:07 <exa> shapr: that's right. Were you able to download some tracks from malfunct.com?
08:49:24 <basti_> exa: i'm listening to the flash plugin.
08:49:26 <barismetin> shapr: if not, ask the flying pig over your head, he'll give you an URI.
08:49:33 <basti_> exa: who's singing that?
08:49:42 <greenrd> I really need to learn how to read simple type theory stuff
08:49:43 <exa> basti_: I am. A frustrated haskell user.
08:49:54 <basti_> exa: k.
08:50:00 <greenrd> can anyone recommend a good accessible tutorial on type theory?
08:50:09 <goron> Sarah bot isn't context sensitive.
08:50:17 <exa> Nah, too bad
08:50:19 <goron> Or too little.
08:50:19 <shapr> greenrd: Types and Programming Languages by Benjamin Pierce
08:50:37 <shapr> greenrd: TaPL is awesome!
08:50:43 <exa> goron: That's what I was trying to test, actually
08:51:05 <exa> goron: Looks like it has used some statistical NLP.
08:51:13 <shapr> TaPL starts at the bottom with lambda calculus and builds up step by step.
08:51:28 <goron> exa: I said: "And?"
08:51:43 <goron> It said that it could be parsed as "maybe".
08:51:47 <exa> basti_: :)
08:51:49 <goron> Like I care...
08:51:58 <Saulzar> The bot seems pretty good compared to others I've seen...
08:52:18 <exa> goron: So, who coded the bot, looks like someone quite well versed in NLP, and the training set is damn good.
08:52:34 <barismetin> Saulzar: "pretty good"? this is injustice.
08:52:57 <Saulzar> You're right - it's absolutely brilliant compared to others I've seen
08:53:01 <exa> goron: Well, you could certainly pass off as a regular on a channel full of idiots like #debian (No offense meant)
08:53:04 <barismetin> Saulzar: :)
08:53:09 <exa> goron: I mean a bot
08:53:10 <goron> I have stated this opinion earlier:Bots are fun at this moment and some have value for acting as reference, but it's nowhere near real conversation.
08:53:35 <barismetin> goron: is Sarah bot written in haskell?
08:53:43 <shapr> I think Sarah bot is written in Scheme.
08:53:46 <xerox> barismetin: no, in Scheme.
08:53:46 <shapr> lambdabot is written in Haskell.
08:53:48 <goron> barismetin: most likely not.
08:53:49 <meren> ehehe
08:54:01 <Saulzar> It responds on topic 99% of the time, which is amazing...
08:54:13 <xerox> "she" please.
08:54:13 <basti_> maybe thats because your choice of topics.
08:54:14 <exa> goron: It seems like it's using something like the Julia's activation network to choose a relevant topic, it keeps a bit of context that way.
08:54:21 <goron> Saulzar: What's the most complicated you asked?
08:54:27 <barismetin> shapr: great reason to imporove my scheme skills :).
08:54:29 <xerox> goron: "later tell" :-P
08:54:36 <shapr> Is there a firefox plugin for only showing flash when clicked on?
08:54:48 <goron> exa: I don't know that specific network, but I know the idea.
08:54:48 <exa> shapr: Do you prefer scheme to haskell?
08:54:52 <Saulzar> goron, Nothing particularly complex...
08:55:25 <goron> Those kind of stuff is to low "Math" to create something really intelligent.
08:55:35 <goron> on "Math"
08:55:44 <shapr> exa: No, I prefer Haskell over scheme.
08:55:55 <exa> goron: Hey, we're really talking about tricking IRC users to wield their credit card numbers, not something truly intelligent :)
08:56:00 <exa> shapr: Why?
08:56:22 <goron> I am buying the Dual Network network architecture for intelligent machines.
08:56:32 <exa> goron: Excuse me?
08:56:35 <goron> er -network
08:56:38 <shapr> exa: Because I enjoy referential transparency, algrebraic datatypes, partial application, and several other features that are standard in Haskell and not standard in Scheme.
08:56:38 <exa> goron: What is that?
08:56:47 <Saulzar> xerox, I'm not sure I'd call a bot "she" no matter what it's name was :)
08:56:47 <goron> I have kind of a hangover.
08:56:56 <goron> My word processing is suboptimal now.
08:56:59 <goron> :P
08:57:13 <exa> I think it's clear now that shapr isn't merely doing a statistical matching, it's definitely parsing the sentences.
08:57:21 * shapr blinks
08:57:29 --- mode: ChanServ set +o shapr
08:57:36 <shapr> I have a halo too.
08:57:39 <goron> exa: It's on agiri.org
08:57:56 <goron> exa: And goertzel.org
08:57:59 <exa> shapr: now that's impressive
08:58:19 <goron> exa: Goertzel had a company called Webmind.
08:58:28 <goron> exa: in the 90's.
08:58:31 <shapr> You can also see my name as the contact for #haskell, try /msg chanserv info #haskell
08:58:35 --- mode: shapr set -o shapr
08:59:16 <barismetin> shapr: you must be proud of that.
08:59:18 <shapr> exa: Hey, you want to write an article for The Monad.Reader?
08:59:21 <goron> exa: Unfortunately I haven't seen formal models yet, but I didn't finish the book yet.
08:59:33 <exa> shapr: I don't know the journal
08:59:38 <exa> goron: Hmm
08:59:50 <shapr> barismetin: Yes, I am. In my opinion, the #haskell channel is a good community, and I've had some positive influence on that.
08:59:52 <goron> exa: It used something called Probabilistic Term Logic.
09:00:09 <exa> the whole talk about bayesian networks, while definitely cool, it does not seem that a strong ai solution would hinge on a particular representation
09:00:42 <goron> exa: It is not a  bayesian network.
09:00:48 <barismetin> shapr: may I want you to betray other bots in this channel?
09:01:00 <exa> well i don't buy the idea of weighted evolving hypergraph, that's just some old semantic network with n-ary relations. nothing more than that.
09:01:07 <shapr> exa: http://www.haskell.org/tmrwiki/
09:01:17 <exa> shapr: thanks
09:01:33 <goron> exa: Well, it's a little more than that.
09:02:01 <exa> goron: hmm
09:02:14 <goron> exa: It's no semantic network.
09:02:39 <goron> exa: You would have to read stuff for a week orso, and then we could talk about it more seriously.
09:03:03 <goron> exa: I think it's the only design in the world that's somewhat viable.
09:03:22 <goron> exa: Do you know Metacat?
09:03:29 <goron> exa: Or Copycat?
09:03:35 <exa> goron: I recall yes
09:04:00 <exa> goron: I don't know how that's more different from 100 other ontology schemes, except for the probability bit
09:04:02 <goron> exa: Well, that kind of behaviour should emerge.
09:04:08 <exa> *should*
09:04:18 <exa> I should get my phd any time soon :)
09:04:33 <exa> but where is the guarantee?
09:04:59 <goron> exa: The only thing I care for is whehter the PTL is really non-bayesian and is not an exponential algorithm.
09:05:00 <exa> without some mathematical guarantee of success as a reinforcement learner in some partially observable environment, this stuff might not be that viable
09:05:03 <goron> er whether
09:05:22 <exa> i don't know if it's good that it is far from bayes-optimal behavior
09:05:26 <shapr> Humans don't come with a guarantee, but interesting behaviours can emerge.
09:05:36 <exa> you mean it is not a naive bayesian approach?
09:05:38 <goron> Look at shapr ;)
09:05:49 <goron> exa: Yes, I mean that.
09:06:05 * shapr waves his unicycles.
09:06:05 <goron> exa: I am a super critic.
09:06:10 <exa> the problem with this, it does not seem to be a self-modifying policy
09:06:31 <goron> exa: Well, it is self-modyfing.
09:06:55 <exa> could you post your ideas about goertzel's project on a yahoogroup if you wouldn't mind?
09:07:08 <exa> there are some people who are interested in these advancements.
09:07:09 <shapr> Man, I hope I get Combinatorrent finished soon, the python bittorrent clients suck up a lot of CPU for more than ten torrents.
09:07:16 <goron> exa: If you point out to me that this PTL stuff is just a bayesian network, than I will loose interest instantly.
09:07:33 <exa> no i can't do that
09:07:35 <exa> i mean
09:07:42 <goron> exa: If it uses "rules" for the probabilities, you can do the same.
09:07:49 <exa> how does it do learning?
09:07:51 <exa> what does it learn?
09:07:56 <goron> exa: patterns.
09:07:58 <exa> those would be interesting for me.
09:08:01 <jlouis> shapr: do you have code somewhere?
09:08:04 <goron> And patterns are programs.
09:08:15 <goron> Webmind ran on MINDOS.
09:08:17 <jlouis> for combinatorrent? I would love a haskell-based torrent thing
09:08:31 <TheHunter> shapr, (re headphones) i have no idea, even the place where i got them has become more expensive.
09:08:32 <goron> exa: What is your Phd about?
09:08:39 <TheHunter> xerox, way to go!
09:08:42 <exa> goron: It's about a futile subject called data mining
09:09:03 <xerox> TheHunter: pretty nice code IMO.
09:09:03 <shapr> jlouis: Yeah, but it's just BEncode and a (painfully slow) torrent verifier at this point.
09:09:12 <goron> exa: I followed one introductory course and one advanced course on datamining.
09:09:26 <exa> goron: This is the group: http://groups.yahoo.com/group/ai-philosophy/
09:09:42 <jlouis> shapr: yeah. Hand over to the #haskell-hack-team ;)
09:09:51 <exa> goron: I would be pleased if you would join the group and post this information about the new hypergraph representations.
09:10:21 <exa> goron: some prominent researchers like marvin minsky and pei wang are among the members. interesting people overall.
09:10:55 <exa> goron: it's not a bad subject in fact
09:11:05 <goron> exa: It really isn't my task to do that, because I am not an expert on the system. I haven't read the entire book, yet. But it's an interesting group, and I bookmarked it.
09:11:06 <shapr> jlouis: darcs get http://www.scannedinavian.org/~shae/combinatorrent/
09:11:16 <exa> goron: thanks
09:11:22 <shapr> jlouis: Includes simple QuickCheck tests for BEncode.
09:12:00 <goron> exa: Do you know a good subject for a master thesis?
09:12:16 <exa> goron: So, why do you suggest that shapr is a bot? All of his behavior so far seems identified with a real person.
09:12:24 <exa> goron: I wish I did
09:12:53 <exa> goron: If you're interested in AI, I think it might be fun to deal with the new approaches.
09:13:00 <goron> exa: That was a joke of me when this channel was pretty new.
09:13:02 <shapr> Many people new to #haskell suspect I'm a bot because I react quickly and have access to a bunch of information about Haskell the language and community.
09:13:10 * xerox scratches his head
09:13:15 <goron> exa: I never actually believed he was a bot.
09:13:23 <shapr> Some people did though.
09:13:30 <goron> shapr: Yes, we had one just now.
09:13:47 <exa> goron: If you'd find an application, it would be most worthwhile.
09:13:47 <meren> :)
09:13:53 <goron> exa: Do you know something concrete?
09:14:06 <exa> Well I told meren that shapr is simply more intelligent and types faster than he does.
09:14:13 <exa> No reason to believe he's a bot
09:14:23 <meren> eheh
09:14:31 <shapr> exa: It's a running gag, no worries :-)
09:14:37 <exa> Besides, the grammatical parsing is superior to the latest and greatest in NLP work.
09:14:57 <xerox> OK.  That's the n-th time I find a solution to a problem trying to write it down understandably here to ask for help.
09:14:57 * shapr applies icecubes to exa 
09:14:58 <goron> you are talking about sarahbot now?
09:14:59 <exa> shapr: I have definitely seen you handle pragmatic ambiguities.
09:15:12 <shapr> exa: Tell that to my business partner.
09:15:13 <goron> oh, ok.
09:15:19 <xerox> It took: a minute.  #haskell is great.
09:15:20 <exa> shapr: Heheh
09:15:20 <jlouis> shapr: thanks ;)
09:15:50 <shapr> jlouis: I got stuck switching to the FastPackedString and SHA1 in darcs. That's the next step.
09:16:23 <exa> shapr: So, why would you prefer Haskell over Ocaml? Any inherent advantages other than the I/O subsystem being pure?
09:16:40 <shapr> Yeah, lots.
09:16:53 <exa> Type classes being one?
09:16:56 <shapr> Anyway, a pure IO subsystem isn't always an advantage.
09:17:07 <shapr> Yes, type classes are the most obvious advantage.
09:17:08 <xerox> I can't speak for the OCaml one, but Haskell's one is great.
09:17:14 <xerox> I didn't put a subject.
09:17:26 * xerox goes back to code :-P
09:17:31 <exa> shapr: In what was is the IO subsystem a disadvantage?
09:17:35 <shapr> But for me, it's more about the philosophy of the languages.
09:17:49 <shapr> exa: Sometimes it's a pain in the butt to be totally pure.
09:17:57 <exa> shapr: I've seen that, ditto. :)
09:18:11 <shapr> But for the most part, it's a great benefit.
09:19:01 <shapr> exa: http://www.scannedinavian.com/2005-04-29.html
09:19:19 <exa> I would've liked it just as easy as in ocaml to write sequential/monadic code in haskell.
09:19:27 <exa> I suspect this would be done easily.
09:20:11 <goron> I wonder whether P!=NP will ever be awarded the 1 million dollar prize money.
09:20:18 <goron> Super page => http://www.win.tue.nl/~gwoegi/P-versus-NP.htm
09:20:31 <exa> goron: when there is a solution perhaps
09:20:48 * xerox found cookies chocolate-covered, yummy
09:21:03 <goron> Only P=NP will be a real proof, imho.
09:21:08 <exa> goron: some of the P!=NP contenders are among our group, like the infamous Bhupinder Singh Anandh, who has an excellent approach to philosophy to mathematics
09:21:17 <exa> goron: An opinion based on what? :)
09:21:35 <goron> exa: Most proofs have no meaning when you read them.
09:21:43 <exa> shapr: Except type classes, which advantages do you confer? I see that indeed, some sacrifice is done to achieve execution speed in ocaml.
09:21:56 <exa> goron: That happens when you don't understand one.
09:21:59 <shapr> exa: That url I just pasted is from my blog, and that describes the major differences I see between OCaml and Haskell.
09:22:03 <goron> exa: A completely formal checkable proof is the only thing that will convince me.
09:22:41 <goron> exa: Well, these kind of papers are really "compact".
09:23:03 <goron> exa: You need a Phd. in combin. to understand them.
09:23:23 <exa> the thing is, if there is a good proof, it will be short, and understandable, like the proofs of Kolmogorov in "introduction to real analysis"
09:23:52 <jlouis> shapr: looks nice. Do you take any patches?
09:24:12 <shapr> Change of abstraction is the best way to improve a program. Speed of change is valuable for software in many other ways as well. I don't wish to make sacrifices that speed up execution but slow down my ability to change my code.
09:24:14 <shapr> jlouis: of course!
09:24:19 <goron> exa: In that sentence you define "good proof".
09:24:46 <goron> exa: Some people claimed P?=NP is a Godel sentence.
09:25:16 <basti_> :-o
09:25:28 <goron> exa: That would make it a bit hard to prove false then.
09:25:34 <exa> goron: It is probably not a Godel sentence
09:25:51 <exa> Unprovability from basic axioms does not require it to be a Godel sentence as in Godel's proof
09:26:02 <shapr> I think OCaml is making the wrong sacrifices to get speed. The right sacrifice is to make the implementation easy to understand and easy to hack on, then smart people will come along and optimize when they need speed.
09:26:09 <basti_> what would a g√∂del sentence be? that you'd need infinitely many axioms to prove it?
09:26:11 <exa> But it might indeed be unprovable from the axioms of set theory
09:26:30 <exa> basti_: No, the kind of sentence that goron says, e.g. this sentence is not provable.
09:26:42 <basti_> oh
09:26:47 <basti_> okay
09:27:01 <exa> basti_: that's definitely a trick, does not cover all kinds of unprovability.
09:27:11 <basti_> sure
09:27:30 <shapr> I think that non-strictness gives more flexibility, at the cost of requiring more thinking ahead of time.
09:27:34 <goron> exa: I don't understand the famous example of a Godel sentence from geometry. Do you?
09:27:46 <exa> goron: I'm not sure I know that one.
09:27:58 <exa> goron: You mean the postulates of geometry
09:28:20 <exa> goron: That case is not an example of G sentence, but yes, of independence of axioms
09:28:48 <shapr> exa: What do you think about non-strictness and speed of change? How do you value those factors?
09:28:49 <goron> exa: I don't think I mean that.
09:29:00 <goron> exa: I will look it up.
09:29:08 <exa> You mean "parallel lines do not intersect" axiom, or is my brain finally melted?
09:29:17 <Muad_Dib> or gorons...
09:29:33 * exa is not as fast as shapr. Trying to catch up :)
09:30:10 <Muad_Dib> being as fast as shapr is almost impossible anyway
09:30:26 <goron> The fifth of Euclid's five axioms states that "For every line l and for every point P that does not lie on l, there exists a unique line m through P that is parallel to l."
09:30:30 <goron> exa: yes
09:30:31 <shapr> Right, because I'm a bot!
09:30:46 <goron> shapr is a military grade bot.
09:30:52 <Muad_Dib> a turing complete bot as well
09:30:57 <exa> don't drive me mad :)
09:31:03 <goron> shapr watches us.
09:31:11 * shapr stares at goron 
09:31:18 <shapr> Oh, my unicycle is calling!
09:32:07 <xerox> Telepathically?
09:32:21 <goron> exa: But could you elaborate on that?
09:32:21 <exa> Yea, Shannon used to ride a unicycle, right shapr ?
09:32:32 <exa> goron: In a moment. I've forgotten how fun IRC was.
09:32:44 <goron> heh
09:33:07 <shapr> exa: Shannon of Shannon-Faro ?
09:33:34 <Korollary> I'm guessing Claude Shannon
09:33:39 <exa> shapr: Late Claude Shannon yes
09:33:53 <basti_> Shannon of "Shannon's sampling theorem"?
09:34:22 <exa> yea
09:34:25 * shapr misspelled "shannon-fano"
09:35:13 <shapr> Nifty, I didn't know he was a unicyclist.
09:35:53 <exa> goron: This postulate is independent of others, meaning you can either accept or deny it. The rejection of which leads to Non-Euclidian geometries.
09:36:23 <shapr> exa: Do you know any others? I'm keeping a list - http://www.scannedinavian.org/AvianWiki/UnicyclingProgrammers
09:36:35 <exa> goron: There is a similar situation in set theory with the axiom of choice IIRC. These things are forgotten easily.
09:37:24 <exa> shapr: I don't know too many of them. But I do have a friend who is doing fire dance if circus is your thing. He used to work with the "seattle industrial fire circus" or something like that.
09:37:55 <shapr> Nah, it's that unicycles are elegant. I'm in pursuit of elegance.
09:38:02 <exa> I can see that
09:38:10 <goron> exa: What is a "postulate"?
09:38:12 <exa> More elegant than a bicycle
09:38:13 <shapr> Was it Hoare who said that the only important numbers are zero, one, and many?
09:38:45 <exa> goron: Same thing as an axiom really. Postulate is more scientific word I guess. "Einstein had three postulates for deriving special relativity"
09:39:04 <exa> shapr: Might be, apparently somebody did.
09:39:12 <exa> shapr: Might be, apparently one person did. :)
09:39:40 <exa> shapr: I understand your point about total development time, but I don't see how haskell is superior to ocaml in *that* regard.
09:39:58 <greenrd> goron: The axiom of choice is especially nice because it is equivalent to two other things. Of the three, one is clearly true, the other clearly false, and the third is too complicated to form an intuitive opinion about. ;)
09:39:59 <basti_> postulate is a demandment isnt it? as in "i postulate, that X, and here's why:"
09:40:01 <exa> shapr: they're mostly the same, and ocaml would weigh better due to all the nifty object system.
09:40:13 <shapr> exa: I disagree.
09:40:32 <goron> http://en.wikipedia.org/wiki/Axiom_of_Choice
09:40:43 <shapr> I think that the monadic abstraction is superior to OOP in quite a few different ways.
09:40:59 <basti_> shapr: claude shannon appears twice in your list
09:41:03 <exa> shapr: I'd say, depends on the application
09:41:08 <Muad_Dib> i'm still not that used to monads that i prefer it ovver OOP
09:41:19 <shapr> basti_: Ah, thanks
09:41:47 <shapr> exa: Show me!
09:41:58 <greenrd> shapr: I have read a paper on OOHaskell. The authors of that paper at least seem to think that Haskell would benefit from a library for OO style programming.
09:42:15 <exa> object systems are higher level of abstractions
09:42:34 <shapr> exa: Are you saying that objects are a higher level than monads?
09:42:37 <exa> for situations where dynamicity is a good model....
09:42:41 <exa> no
09:42:51 <shapr> er "higher level abstraction"
09:42:58 <exa> but i don't understand how monad is a replacement for class-based programming.
09:43:12 <greenrd> It isn't, surely.
09:43:13 <musasabi> OO is good for trees of polymorphic interfaces.
09:43:15 <exa> no higher level abstraction than perhaps the lack of them :)
09:43:25 <shapr> A monad is like objects smashed into bits and strung out on a necklace.
09:43:27 <exa> yea, so, you know the GUI is a great example
09:43:28 <musasabi> But the world is not such a thing.
09:43:46 <greenrd> musasabi: But it's fun to pretend as though it is! ;)
09:43:51 <exa> Well, a monad is just a mathematical idea from category theory in fact
09:43:53 <musasabi> exa: Personally I think that a GUI is better handled with attributes and message passing.
09:43:58 <exa> And has very little relation to the world as it is
09:44:17 <shapr> All the same pieces that you see in OOP are present in the monadic abstraction, but the shape of the abstraction is different. In my experience, the monadic shape is simpler and easier to understand and predict.
09:44:28 <greenrd> But seriously. This whole "OO model should match the real world" is a mistake to take too literally, I feel.
09:44:34 <shapr> greenrd: Yeah, I agree.
09:44:43 <exa> of course greenrd
09:44:50 <exa> but it surely matches more closely than monads
09:44:54 <Korollary> this subject has got to be the one with the lowest facts/opinions ratio.
09:44:58 <goron> exa:this one?
09:44:59 <goron> Given any set of mutually disjoint non-empty sets, there exists at least one set that contains exactly one element in common with each of the non-empty sets.
09:45:00 <greenrd> heh
09:45:12 <goron> "clearly false"
09:45:17 <pejo> musasabi, message passing sounds a lot like reactive objects. ;)
09:45:28 <greenrd> goron: Yes. That's the axiom. It depends how you define "exists".
09:45:29 <shapr> Korollary: Nah, look at the way monads 'seal off' effects by lifting. You surely can't do that in J2EE.
09:45:30 <exa> goron: yes, axiom of choice
09:45:39 <exa> now the subjects are fusing, too
09:45:42 <exa> heh
09:46:02 <Korollary> shapr: There is no clear definition of what one wants to do with any of this. Surely you can implement the same action using N number of paradigms.
09:46:05 <exa> you can encapsulate state with a monad
09:46:07 <musasabi> reactive objects is just one name for the thing.
09:46:08 <exa> i have no question about that
09:46:11 <shapr> From my viewpoint, monads are closer to metaclasses than they are to objects.
09:46:21 <musasabi> you could call erlang a reactive OO language then ;)
09:46:28 <goron> greenrd: Well, honestly I don't think they are the same axioms. It's just some words game.
09:46:37 <shapr> Korollary: I want to write webapps that don't suck ;-)
09:46:45 <musasabi> Lets take text inputs and buttons as an example.
09:46:56 <pejo> musasabi, yes! :P
09:46:57 <musasabi> Both have an attribute that makes sense called "text".
09:47:11 <greenrd> goron: The 3 are isomorphic, i.e. if one is true all are true. It's _very_ counterintuitive.
09:47:28 <shapr> Korollary: Yes, an abstraction is just a way of organizing mental conventions to make concatenation of software components predictable, so any of them should work. But some are easier than others.
09:47:48 <goron> greenrd: Who proved that?
09:48:02 <musasabi> But we might also want to make text inputs which accept e.g. dates and produce valid dates as their result.
09:48:38 <exa> musasabi is coming in strong
09:48:44 <Korollary> shapr: Easier for you, others, me ? It all becomes a psycho-social experiment.
09:49:46 * Lemmih greets SyntaxNinja.
09:49:49 <SyntaxNinja> hi Lemmih!
09:49:52 <SyntaxNinja> how's hack?
09:50:14 * Korollary wonders if there are any FBI agents in this channel
09:50:16 <exa> sure, by that reasoning we could say pure LISP is the best language, after all it is so orthogonal. it ought to be easier for some person to code fastest in LISP heheh
09:50:23 <shapr> Korollary: That's not completely true. Human short term memory limits are known to a decent degree. I claim that the monadic interface has a lower 'mental algorithmic complexity' than objects.
09:50:41 <exa> shapr: Measure the algorithmic complexity.
09:50:53 <Korollary> shapr: You may claim that (and others do). We need proofs now.
09:50:56 <SyntaxNinja> hi shapr
09:50:59 <exa> shapr: You claim it takes less bits to represent and manipulate monadic code.
09:51:06 <SyntaxNinja> shapr: want to try cabal-get?
09:51:33 <jlouis> hmmm, we need threads for combinatorrent ;)
09:51:53 <greenrd> shapr: To me, objects are very simple, whereas monads are really hard to wrap my head around.
09:51:58 <shapr> exa: I say that OOP is O(n!) in the number of instances in the system that can interact when you need to make a change. I say that the monadic interface is O(n) in the number of monads stacked in the monad transformer when you need to make a change.
09:52:06 <shapr> greenrd: I think that's cultural.
09:52:31 <greenrd> shapr: Of course, but it just goes to show.
09:52:40 <pejo> greenrd, don't forget that people make it really complicated too. Monads, that is.
09:52:53 <Korollary> people make objects complicated as well
09:53:17 <greenrd> yes but even when they do, it is usually like 1+1
09:53:24 <shapr> greenrd: I have this saying... "One thousand lemmings can be wrong." just meaning that popularity is not the same as quality.
09:53:29 <exa> shapr: Can you show me a websvn or webcvs of an OO-like monadic code?
09:53:33 <greenrd> whereas with monads it seems more like "voodoo+witchcraft" ;)
09:53:37 <exa> shapr: I'm convinced to have a look
09:53:50 <shapr> exa: You want to see a what?
09:54:02 <Korollary> exa: you cant look at monads in isolation without knowing haskell. Are you willing to learn it ?
09:54:10 <shapr> Korollary: You can actually...
09:54:17 <exa> shapr: But as somebody who read the BIG CLOS book, I kind of think that generic functions may be what you want.
09:54:22 <shapr> There are monad implementations in OCaml, ML, Perl, Java, Python, and more.
09:54:23 <exa> Korollary: I know monads
09:54:32 <exa> Korollary: I even know how to use them for parallel programming etc.
09:54:49 <shapr> exa: How would you describe the Big O complexity of Objects and monads then?
09:54:51 <exa> I want to see an example of a monad code that would be replacement for an OOP code.
09:55:12 <Korollary> exa: why dont you use OO for parallel programming ?
09:55:25 <greenrd> goron: I don't know who proved it, but you can ask any mathematician who knows about this stuff
09:55:44 <shapr> exa: How about the other way around? How would you write an object that replaces the Maybe monad?
09:56:00 * SyntaxNinja pokes shapr
09:56:01 <exa> shapr: I know intuitively that OO code is not that change-resilient, but I'm not certain what you mean about O(n!)
09:56:08 <goron> greenrd: I read the entire wiki page now, and I am very unconvinced.
09:56:10 <shapr> SyntaxNinja: yeah sure, as soon as I'm done unicycling.
09:56:22 <goron> greenrd: It all depends on what a function is.
09:56:23 <exa> I'm thinking maybe they are apples and oranges
09:56:30 <shapr> exa: Every object instance can interact with every other object instance in a system.
09:56:32 <exa> Because an object is a *set* of functions
09:56:40 <exa> While a monad encapsulates a program
09:56:42 <SyntaxNinja> shapr: I'm running, but lemmih can maybe help you.  pick up the bootstrap tarballs here:  http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
09:56:48 <shapr> SyntaxNinja: thanks!
09:56:53 <goron> In other words it's just a words game.
09:57:04 <Korollary> cabal-get ?
09:57:05 <exa> you mean the object / monad distinction?
09:57:12 <SyntaxNinja> shapr: you rule, btw. oh, and you need cabal >= 1.1.1
09:57:13 <Lemmih> SyntaxNinja: I'm trying to release a stable HSP but I'm having problems with the parser I refactored from GHC.
09:57:26 <pejo> exa, replace object with module there and your definition works too.
09:57:41 <exa> of course
09:57:44 <shapr> SyntaxNinja: Is >= 1.1.1 in the repo?
09:57:49 <exa> But ocaml *has* higher order modules.
09:57:53 <exa> That's why I hesitated
09:58:02 <Korollary> exa: I dont have experience with it, but many people here talk highly of monadic parsers. You may wanna look at that and compare an OO version
09:58:04 <exa> You can do all the nifty program encapsulation stuff with such modules
09:58:10 <greenrd> goron: you may be right. Since it's independent it seems there's no way to prove or disprove it "absolutely".
09:58:13 <exa> Instead of monads and type classes
09:58:28 <shapr> Anyway, I'm off to unicycle.
09:58:29 <exa> Korollary: I was an avid user of PARSEC. I know that :)
09:58:40 <exa> I'm not clueless :)
09:58:47 <shapr> exa: I look forward to your description of the Big O complexity of monads and objects.
09:59:10 <exa> shapr: I look forward to the proof of your claim. n! is a big number you know.
09:59:36 <exa> The description is trivial
09:59:38 <shapr> Any object instance can interact with any other object instance, right?
09:59:56 <greenrd> Korollary: People don't generally write parsers in plain OO languages, they usually use parser generators. Special case.
10:00:05 <shapr> exa: tell me then!
10:00:07 <goron> shapr: I get your point.
10:00:11 <shapr> If it's trivial, I want to hear it!
10:00:22 <SyntaxNinja> shapr: the darcs repo, also have a tarball on the home page, or use the cvs version.
10:00:23 <Korollary> greenrd: isn't that just too bad for OO languages then ?
10:00:24 <Heffalump> what on earth does that *mean*?
10:00:31 <goron> shapr: I first semantically parsed it wrong.
10:00:36 <Heffalump> (the Big O complexity of monads and objects)
10:00:48 <exa> shapr: You really have to make it clearer
10:00:48 <Korollary> Heffalump: It's roxxet science
10:00:54 <shapr> Heffalump: It means the complexity of interactions that you need to mentally consider before changing the system.
10:01:12 <greenrd> shapr: That surely depends on the design.
10:01:22 * rt sighs.
10:01:25 <shapr> exa: Assume you have two object instances in an application. When you add a third, it could (and probably will) interact with the other instances.
10:01:34 <goron> shapr: It's just that the interactions are less restricted.
10:01:35 <Heffalump> why would it?
10:01:45 <goron> shapr: You could see that as something good or something bad.
10:01:48 <Heffalump> objects have their own private state..
10:01:51 <greenrd> shapr: 99% of the time your changes won't have weird side effects on some far-flung component of the app anyway.
10:01:57 <greenrd> assuming you have a good design
10:02:02 <exa> shapr: Yes. That's where you derive your n! complexity?
10:02:03 <shapr> greenrd: Have you ever used J2EE?
10:02:09 <greenrd> shapr: Haha. No.
10:02:18 <shapr> exa: Right, like I said, O(n!) in the number of object instances in the system.
10:02:18 <greenrd> Not EJBs, anyway.
10:02:23 <exa> shapr: I thought you wanted to talk about algorithmic complexity.
10:02:23 * xerox enjoys the feeling in getting the code compiling
10:02:28 <xerox> s/in/of/
10:02:32 <Heffalump> I think a tower of monad transformers is probably more fragile than a chain of object inheritance.
10:02:40 <shapr> exa: Yes, I'm talking about the 'derivative' of the complexity of an abstraction.
10:03:08 <exa> shapr: You really must care about how many source code changes are necessary to enact one "idea change", which can be formalized for certain program transformations
10:03:31 <greenrd> Heffalump: Never mind if it's fragile - is it understandable enough for an average programmer to build the entire tower in the first place?
10:03:36 <exa> shapr: Believe me, I know what I'm talking about, I read more than enough about program synthesis.
10:03:53 <shapr> <shapr> I claim that the monadic interface has a lower 'mental algorithmic complexity' than objects. <exa> shapr: Measure the algorithmic complexity.
10:03:57 <Korollary> shapr: the bodies of method implementations do work as well, which can be modified without causing reorganization.
10:03:58 <greenrd> (ignoring the fact that "the average programmer" can't even code properly in his or her language of choice ;)
10:04:03 <rt> such a thing surely depends on what your idea was, even in the absence of any distinction between programming metholodogies.
10:04:05 <exa> Ok
10:04:13 <Heffalump> greenrd: probably not.
10:04:26 <exa> shapr: You say that O(n!) is the number of objects
10:04:30 <exa> shapr: That was wrong, right?
10:04:40 <shapr> exa: No, O(n!) in the number of *instances* in a system.
10:04:50 <Heffalump> what is n?
10:04:50 <exa> shapr: And n is?
10:04:52 <Heffalump> why the factorial?
10:04:58 <Heffalump> why not O(e^n) ?
10:05:06 <shapr> n == instances, because each object instance can interact with every other instance.
10:05:19 <greenrd> But that's a pathological worst-case.
10:05:23 <shapr> Sure it is, I agree.
10:05:27 <exa> That seems wrong shapr
10:05:29 <exa> Sorry
10:05:33 <Igloo> I think the only difficult bit with a tower of (decent) monad transformers is the decision on ordering and the writing of the runFooT code
10:05:35 <Heffalump> how can any object instance interact with any other instance?
10:05:50 <shapr> exa: So, that's why I asked for your thoughts on the complexity of monads vs objects.
10:05:51 <Heffalump> igloo: how do you stack two StateTs?
10:05:52 <exa> That's pathological too
10:05:59 <Igloo> And the latter isn't really difficult, you just have to get it straight which way round they should go
10:06:02 <TheHunter> why would you compare objects with monads? They are so apples and oranges. For example the number of objects in large programs grows indefinitely, while you will always certainly have only a finite number of monads in a transformer.
10:06:06 <exa> In good OO code, the *interactions* will be isolated and componentized.
10:06:16 <greenrd> When you've put all your database access code in your JSPs and suddenly you have to add a field to every table, sure, that's a pain. But that's a stupid coding practice.
10:06:21 <shapr> exa: Yes, that's the whole point of abstractions, but I'm saying that monads do that better than objects.
10:06:25 <Heffalump> I was assuming that that comparison made no sense and comparing monads with classes instead.
10:06:26 <exa> He really wants to talk about classes I think TheHunter. Right shapr ?
10:06:32 * shapr sighs
10:06:33 <exa> Without talking about classes, this is gonna be nonsense.
10:06:37 <Igloo> Heff: You make 2 differrent MTs newtyping StateT and have functions like getColour rather than just using get
10:06:41 <TheHunter> right, i meant classes.
10:06:49 <Heffalump> Igloo: fair enough
10:07:03 <shapr> exa: Ok, let's compare prototype oriented programming with monadic programming, that simplifies the comparison.
10:07:06 <xerox> Igloo: nice idea.
10:07:09 <exa> So let's compare one class to one monadic fun please.
10:07:16 <exa> hmmm omk
10:07:35 <exa> shapr: that's object-based programming by delegation, cool.
10:07:38 <Heffalump> how about we have a buzzword-free discussion? :-)
10:07:47 <Korollary> Heffalump: Denied !
10:07:47 <exa> heheh
10:07:55 <shapr> When you change a system that has only instances, the worst case interaction is that a new instance can interact with every other instance.
10:08:00 <rt> you are in a channel full of functional language proponents.   Buzzwords are impossible to avoid.
10:08:22 <shapr> You are in a maze of little twisty buzzwords, and they all look the same.
10:08:31 <Korollary> right. we're the ones who came up with buzzwords
10:08:39 <TheHunter> you rarely see any haskell program using non-imperative monads anyway.
10:08:41 <exa> hahaha
10:08:55 <sylvan> hmm... How can I write a function which spawns two threads using forkIO and then waits until both of them are finished?
10:08:56 <rt> that is because of course, at some level, they are all equivalent, and it is hard to analyze the means by which they differ.
10:09:00 <exa> TheHunter: right :)
10:09:17 <sylvan> never mind, I'll use an MVar...
10:09:21 <Heffalump> TheHunter: Parsec?
10:09:30 <shapr> I claim that the worst case interactions in a Haskell program would be that each of the monads stacked inside a monad transformer could interact with each other.
10:09:40 <exa> shapr: Right shapr
10:09:48 <exa> shapr: But the comparison is still apples vs. oranges
10:09:51 <TheHunter> ok, there's parsec and there's the list monad that's sometimes useful. But that's not about structuring large programs.
10:09:58 <shapr> exa: Not really, they're both abstractions.
10:10:05 <Heffalump> TheHunter: yeah.
10:10:11 <exa> shapr: Every PL construct is an abstraction
10:10:13 <Heffalump> most large programs are naturally imperative.
10:10:37 <shapr> exa: So, can you come up with a more descriptive comparison between OOP and monads?
10:10:39 <exa> shapr: The comparison is unfair, because with n objects you can do things that you cannot do with n monads.
10:10:51 <exa> shapr: As I said. Apples vs. Oranges.
10:10:58 <exa> Monad is an abstraction of execution
10:11:09 <Korollary> shapr: Why should one weigh "one interaction between classes" equal to "one interaction within monads" anyway ?
10:11:11 <exa> Object is a set of functions.
10:11:34 <exa> I really hope to make better of this discussion
10:11:46 <shapr> Korollary: Speed of change was the original metric we were discussing. So I'm trying to describe what limits the speed of change in these two abstractions.
10:11:51 <exa> I would tend to think that you'd need something like an interaction graph, rather than a monad
10:12:02 <exa> That way you can indeed model the collaboration diagrams etc. in OOP
10:12:10 <Korollary> shapr: but these things don't scale up like algorithms do. Sometimes n is never larger than 20.
10:12:30 <TheHunter> the lambdabot experience really has changed my mind about the OO vs. functional question.
10:12:39 <Korollary> TheHunter: how ?
10:12:40 <shapr> Korollary: You think that'll be true in fifty years?
10:12:44 <exa> Depends on application. Always.
10:12:55 <musasabi> TheHunter: could you tell more, that sounds like an interesting case.
10:12:56 <exa> Sometimes objects are better for a subtask, sometimes functions are.
10:13:10 <exa> Trying to style *everything* after a single pattern is mindless fabrication
10:13:13 <exa> It's suboptimal
10:13:18 <Korollary> shapr: I don't know what will be true in fifty years (I lied; buy Qualcomm stock !!)
10:13:32 <shapr> exa: Sure, I agree. But, I want to know how you compare OOP and monads.
10:13:41 <shapr> Stop dissembling :-P
10:13:50 <exa> shapr: As I said, I normally do not, because they're apples and oranges!
10:13:55 <greenrd> shapr: You could actually simulate an interpreted program in Haskell, and then it's not obvious that it would be any less complicated than the original.
10:13:57 * shapr sighs
10:14:00 <shapr> Ok, fair enough.
10:14:08 <exa> shapr: However, with some extensions on the monadic part, you can start drawing a comparison
10:14:20 <shapr> TheHunter: Yes, I'd like to hear what you think.
10:14:22 * Korollary is still waiting to hear about TheHunter's lambdabot crusade
10:14:24 <exa> shapr: With the "usual" monadic stuff in haskell libs, it's just not fair
10:14:26 <greenrd> shapr: Pathological case, but I don't understand why you introduced pathological unrealistic cases in the first place.
10:14:37 <exa> shapr: I was hoping to hear more about Arrows first, though.
10:14:47 <shapr> greenrd: Years of experience with J2EE and Zope/Plone. Pathology is everyday life sometimes.
10:14:53 <greenrd> hehe
10:15:04 <TheHunter> lambdabot handles a collection of modules. Originally, these modules would use a central FiniteMap to store there state. This has been refactored, so that each module can decide what kind of state it should keep.
10:15:08 <greenrd> Sorry, I shouldn't laugh, I should commiserate.
10:15:23 <shapr> greenrd: It's ok, I think it's funny too when I'm not close to a deadline :-)
10:15:26 <exa> Maybe you talk of a badly designed language and library (Java) and a badly designed class library (Zope) ?
10:15:32 <TheHunter> After that, it suddenly appeared to me that we had reinvented class-based OO.
10:15:55 <greenrd> Java isn't _that_ badly designed.
10:16:07 <greenrd> (I don't know anything about Zope.)
10:16:09 <exa> BTW, in my ocaml code I have not used a single class yet.
10:16:17 <Korollary> exa: why is that ?
10:16:27 <TheHunter> without inheritance and any fancy stuff, but it simply was a natural consequence of the requirement that modules keep their private state.
10:16:28 <exa> There was no need.
10:16:31 <wilx> Heh, OO vs FP?
10:16:36 <basti_> because OO sucks? :D
10:16:41 <exa> Because my programs were small, and the dynamic state changes unnecessary
10:16:56 <exa> I subscibe to the view that: don't use classes unless they are absolutely necessary.
10:17:02 <greenrd> wilx: Yes. Is this is a regular topic?
10:17:23 <wilx> It emerges once in a while :)
10:17:29 <TheHunter> the next problem we are facing is implementing stuff like @index >>= @type which requires modules communicate with each other.
10:17:39 <exa> I'm not an OO advocate BTW. I hate UML and Java to begin with.
10:18:04 <shapr> Now everyone should read Alistair Bayley's article FPvsOO --> http://www.haskell.org/tmrwiki/FpVsOo
10:18:07 <Korollary> TheHunter: I think that evolution has something to do with the fact that it got started out with modules as independent entities.
10:18:40 <shapr> I'm off to unicycle, be back later.
10:18:44 <greenrd> I can't remember why it is said Haskell can't do OO.
10:18:44 <musasabi> TheHunter: but when implementing plugins (like the lambdabot modules) one usually reinvents class-based OO even when the host language is a class based OO language.
10:19:07 <greenrd> It seems to have subtyping... polymorphism... encapsulation....
10:19:21 <Korollary> exa: I assume you prefer ocaml ?
10:20:03 <exa> Korollary: not really. in a project I'm working on we're using python, and I found it quite adequate as a dynamically typed language. Better than LISP IMO.
10:20:15 <musasabi> Haskell has 1) subtyping (only by hand with evil type classes), 2) polymorhism (typeclasses), 3) encapsulation (modules & type system)
10:20:24 <exa> Korollary: Elsewhere I use ocaml, c++, haskell
10:20:35 <Korollary> exa: I've used python quite a bit, too. not too shabby.
10:21:08 <exa> Korollary: It can be extended in really cool ways, though. Like generic functions and what not. The guy has got "eval" heh :)
10:21:19 <TheHunter> musasabi, i don't have much OO experience, and I fail to see why one should have to reinvent class-based IO there.
10:21:22 <exa> Korollary: I think python is a really cool language if you use it properly
10:22:05 <Korollary> class based IO ?
10:22:11 <musasabi> TheHunter: because usually the classes don't match the abstraction implemented.
10:22:12 <Korollary> oo?
10:22:17 <TheHunter> yes, sure OO.
10:22:39 * xerox bounces happily, OO or not, his Matrix module seems to work :-P
10:22:52 * Korollary should make a concerted effort to learn ocaml
10:23:55 <musasabi> Haskell usually makes it very easy to pinpoint errors.
10:24:10 <exa> Korollary: I think if one is into FP, one should know haskell and ocaml.
10:24:34 <musasabi> The type system really helps telling which parts of code touch external things and a grep for "unsafe" finds the rest of places.
10:25:07 <liyang> It's been a while since I used O'Caml but its module system left good impressions on me...
10:25:14 <musasabi> Of course I usually manage to get silly segfaults with corrupted reference counts.
10:25:19 <exa> shapr: So it seems Alistair is not too far from what we've been discussing :)
10:25:23 <musasabi> but that is more of an FFI issue.
10:25:40 <TheHunter> xerox, did you find the error in monadicStarAndRing.hs ?
10:25:41 <exa> shapr: First thing as I said, OO is all about dynamic behavior of objects and message passing, despite anything said about them :)
10:25:45 <musasabi> liyang: much better than Haskell.
10:25:47 <pejo> musasabi, the very same type system is quite poor at giving out the information about whats wrong. "Can't unify Num a and Char" does not say much to most people.
10:26:04 <Korollary> pejo: Compiler error messages could be improved.
10:26:07 <liyang> musasabi: yup. I should have a play with it again.
10:26:44 <musasabi> pejo: but after a month of use people will know what they mean. Of course they could be much better.
10:26:47 <xerox> TheHunter: I'm tracking it down atm - using Matrix with StarAndRing (i.e. the not monadic version) works, so the problem should really be in my own translation from last time.
10:26:52 <musasabi> But the location is usually correct.
10:27:53 <exa> shapr: OTOH, it's true that things like " adding a method to a class could potentially be a global undertaking" are true
10:28:17 <exa> shapr: I thought that's what you wanted to talk about when you meant algorithmic complexity, which is program-size complexity.
10:28:31 <shapr> Right
10:28:37 <shapr> Sort of that...
10:28:56 * shapr puts off unicycling until after food.
10:29:43 <TheHunter> does anybody know why the ideas from http://research.microsoft.com/Users/simonpj/Papers/first-class-modules/index.htm never made it into ghc?
10:29:50 <exa> shapr: I don't know much about OOHaskell so I can't comment on that
10:29:56 <shapr> exa: I'm self-employed, so speed of change of code is my priority. What do you think are the most important factors for speed of change in both the monadic and object abstraction, which do you prefer, and why?
10:30:25 <exa> shapr: But I would think that *some* extension of the Monad idea would befit a model where there are various types and various kinds of use relations among them.
10:31:59 <exa> shapr: I'm afraid this depends on the kind of change. If it's the most common program changes we are talking about, like adding a parameter somewhere, I would think they are head to head.
10:32:34 <shapr> What do you think are the most limiting kinds of change? What's the hardest for monads, what's the hardest for objects? And for that matter, what's the easiest?
10:32:46 <Oejet> TheHunter: I think, I've read about it.  I think it was just not priority.
10:33:22 <exa> I love the  FP style.
10:33:22 <TheHunter> That's sad. I think haskell could benefit much from a decent module system.
10:33:25 <shapr> I agree about "types and their various use relations", but I think that description fits equally both OOP and monads equally.
10:33:31 <musasabi> For nice changes into a Haskell real records and modules would be spiffy.
10:33:36 <musasabi> *-a
10:33:53 <exa> shapr: Maybe I have to write a large monadic (with state!) code to see that myself.
10:34:09 <musasabi> oh and the "forall that is not really forall types".
10:34:11 <exa> I did use states of course
10:34:22 <exa> But I think my uses were mostly one directional like the example here:
10:34:25 <shapr> Have you used the maybe monad?
10:34:31 <exa> http://www.nomaware.com/monads/html/xformerexamples.html
10:34:39 <exa> shapr: Of course
10:34:51 <exa> shapr: You have to use that, almost. It's been a while now :)
10:35:07 <shapr> Yeah, I agree.
10:35:09 <exa> the thing is
10:35:19 <exa> i never thought of monadic code as "implementing an object system"
10:36:00 <exa> i always thought of them as idiot-proof procedural codes, with the caveat of lazy list evaluation, and I/O and blah blah.
10:36:11 <shapr> I still think objects and monads are just the same thing in different shapes.
10:36:37 <xerox> TheHunter: GOT IT!  It works
10:36:38 <exa> So you write your code around Monad.StateT right?
10:36:48 <TheHunter> xerox, yay!
10:36:49 * xerox dances around, stop flaming!  Code works!
10:36:54 <xerox> :-DDD
10:36:55 <exa> shapr: Well, if you take the meaning of "Monad" literally
10:37:25 <xerox> TheHunter: silly me, btw - the second clipToTopAndBottom is clipToLeftAndRigh - erhm :-)  They're so similar!
10:39:29 <exa> http://lambda-the-ultimate.org/node/view/750
10:39:44 <exa> A good comment there
10:40:29 <exa> "stateful reactive system". shapr: do you achieve that in your exploitation of monads?
10:41:01 <exa> Furthermore, as I've asked, another commenter asks. What about the Hughes arrows?
10:41:05 <shapr> Nah, arrows are better for that.
10:41:05 <jlouis> what is a stateful reactive system?
10:41:13 <exa> Yes, what about the arrows?
10:42:02 <shapr> I haven't finished my arrows article ...
10:42:23 <shapr> But you can read what I've got so far: http://www.haskell.org/tmrwiki/ArrowsIntroduction
10:43:36 <Lunar^>   $33,403.19
10:43:36 <Lunar^> $166,596.81 to go
10:43:38 <Lunar^> oops
10:43:48 * shapr DCCs $0.50 to Lunar^ 
10:43:50 <Lunar^> (that's the wikipedia fundraising, if anyone wonders)
10:45:29 <Korollary> lol
10:45:58 <xerox> TheHunter: pushed the changes, now I'm (and will be) working on the gtk2hs repo.
10:46:12 <xerox> darcs get http://haskell.galois.com/~paolo/darcs/gtk2hs
10:46:35 <xerox> TheHunter: if you want I can port the modifications to cairobindings/ too.
10:47:51 <TheHunter> that's ok. i can use the gtk2hs repo. Great you're making progress. Have you though about a more high-level interface?
10:48:26 <xerox> TheHunter: yup!  The first thoughts are already implemented, but it's still under _heavy_ developing.
10:48:35 <xerox> cairo/Graphics/Rendering/Cairo.hs
10:48:56 <xerox> demo/cairo/MonadicStarAndRing.hs does use it
10:49:34 <xerox> But.. your idea is something still higher level, or did I understand the right thing?
10:50:18 <TheHunter> yes, like an ADT for shapes.
10:51:03 <xerox> I don't know much about actual cairo usage, I should say :)
10:51:08 <TheHunter> i think the haskell school of expression discusses something like that.
10:51:34 <xerox> I'll be translating more .c snippets to get into that... this is a cool idea!
10:52:09 <xerox> Tough the next step is monadic interface && fonts.
10:52:28 <xerox> Believe me, fonts is a rather complicated issue.
10:54:15 <sylvan> How do you enable mdo in GHC?
10:54:23 <TheHunter> -fglasgow-exts
10:54:30 <sylvan> ah :-)
11:02:54 <sylvan> wow, never thought I'd need mdo...
11:05:04 <tic> 'elo sylvan
11:05:52 <sylvan> hello
11:06:24 <Korollary> man, Einstein's handwriting is unreadable.
11:06:54 <basti_> so is mine.
11:06:58 <tuomov> you haven't seen mine :)
11:07:03 <FrederikEaton> Korollary: still haven't finished grading that class?
11:07:17 <Korollary> FrederikEaton: hah
11:07:44 <lispy_> xerox: head [] :: [Int] works because the :: binds tighter than head
11:08:02 * Korollary has not enjoyed being a teaching assistant much.
11:10:55 <xerox> lispy_: ?
11:12:27 <FrederikEaton> can i do something monad-like but where the state is type-level?
11:12:32 <goron> xerox: He means a call to head with argument empty list.
11:12:42 * goron didn't follow the discussion.
11:13:11 <xerox> goron: I do not understand the "more tightly" part
11:13:11 <FrederikEaton> like tmodify :: T x y => m x a -> m y a
11:13:18 <goron> xerox: oh, ok.
11:13:24 <goron> :: is just an operator
11:13:37 <goron> * binds more tightly as +
11:13:37 <xerox> goron: shouldn't it be the opposite?
11:13:58 <xerox> BTW I don't think so
11:15:17 <goron> xerox: What?
11:15:49 <xerox> ":: binds tighter than function application"
11:16:07 <goron> xerox: oh, ok. I don't know about that.
11:16:11 <lispy_> xerox: if it didn't then that example wouldn't work :)
11:16:39 <goron> But I'd  say this=> "* binds more tightly as +" is pretty good.
11:16:39 <xerox> It would have gave a type error.
11:17:00 <xerox> goron: (*) binds tighter than (+), yup.
11:17:24 <Lemmih> lispy_: You can easily take the head of a list of lists.
11:17:34 <lispy_> oh, that's true
11:17:40 <lispy_> hmm....
11:18:00 <lispy_> @eval head ([]::[Int])
11:18:03 <goron> xerox: I just tried it.
11:18:08 <lambdabot> Prelude.head: empty list
11:18:09 <goron> xerox: It just works.
11:18:22 <goron> I.e. no type error.
11:18:50 <goron> But maybe it's no Haskell 98 and it's a MS extension(embrace and extend) ;)
11:19:29 <goron> But I guess it's just good old 98.
11:19:31 <Lemmih> Lists are most definitely in Haskell98 (:
11:19:47 <goron> Lemmih: I meant this particular parsing.
11:20:12 <goron> But I guess in general that :: binds more tight than function application
11:20:14 <Lemmih> An expression with a type signature?
11:20:25 <goron> head []::[Int]
11:21:04 <goron> xerox thought it was the other way around.
11:21:41 <lispy_> @eval (head [])::[Int]
11:21:43 <lambdabot> Prelude.head: empty list
11:22:02 <lispy_> this head example doesn't help clarify :)
11:22:58 <goron> lispy_: it does clarify it.
11:23:09 <goron> Otherwise the type would have been Int
11:23:10 <Korollary> :: is a reservedop while "*" is an ascSymbol in the grammar.
11:23:20 <goron> If the list was [Int]
11:23:48 <goron> Oh no, no Haskell grammar!
11:24:37 <xerox> Is tight the opposite of loose?
11:24:57 <goron> In what sense?
11:25:09 <goron> You mean like in a English exam way?
11:25:23 <goron> Or in how I see it?
11:25:38 <goron> I'd say yes.
11:25:46 <Korollary> I think by tight he means "with higher precedence"
11:25:53 <xerox> OK..
11:26:23 <goron> tight has multiple meanings.
11:26:34 <xerox> lispy_: I got it, thank you.
11:26:51 <goron> Actually binding tight is a bad use of words.
11:29:59 <lispy_> so in the end :: has higher precedence?
11:30:04 <lispy_> @type (head [])::[Int]
11:30:06 <lambdabot> [Int]
11:30:18 <lispy_> @type head ([]::[Int])
11:30:20 <lambdabot> Int
11:30:24 <lispy_> @type head []::[Int]
11:30:26 <lambdabot> [Int]
11:30:46 <lispy_> so, head has higher precedence and i was wrong orginially
11:31:04 <Korollary> lispy_: I've just found a scheme interpreter written in ocaml.
11:33:10 <goron> yes
11:33:23 <goron> uh.no
11:33:41 <sieni> schoca or ocs?
11:34:29 <TheHunter> no suprises here. application binds tightest.
11:35:12 <goron> it's parsed as (head ([]::[Int]))
11:35:28 <goron> At least, that's what I think.
11:35:33 <TheHunter> it's not.
11:35:41 <TheHunter> @type (head ([]::[Int]))
11:35:43 <lambdabot> Int
11:35:48 <TheHunter> @type (head []::[Int])
11:35:50 <lambdabot> [Int]
11:35:53 <Korollary> sieni: schoca
11:36:41 <goron> Hmm, ok.
11:37:40 <lispy_> Korollary: ah, cool
11:37:50 <lispy_> Korollary: but i have to write it myself for the coolness factor :)
11:38:03 <lispy_> Korollary: but it might make a good reference implementation
11:38:08 <lispy_> Korollary: send me a link if you can
11:39:28 <Korollary> lispy_: http://home.arcor.de/chr_bauer/schoca.html
11:39:47 <goron> TheHunter: But how is it that ghc doesn't complain about the type then?
11:40:07 <TheHunter> about which type?
11:40:20 <lispy_> Korollary: thanks
11:40:22 <goron> head []::[Int]
11:40:34 <lispy_> goron: head can take the head of a list, or a list of lists
11:41:07 <TheHunter> the [] there has type [[Int]].
11:41:22 <goron> TheHunter: Ah, yes.
11:41:52 * goron is getting rusty at Haskell. I haven't coded anything in >3 months in it. 
11:42:13 <Korollary> I've written 5 lines of haskell yesterday
11:42:17 <Korollary> oops
11:42:28 <lispy_> goron: http://www.codersbase.com/projects <-- you should try contributing then :)
11:42:59 * lispy_ happily accepts patches created with darcs
11:44:22 <goron> Helisp?
11:45:41 <lispy_> goron: yeah, elisp interpreter in haskell
11:45:56 <goron> lispy_: For inclusion with Yi?
11:46:02 <lispy_> goron: some day yes
11:46:10 <goron> lispy_: practical
11:46:14 <lispy_> goron: but i have not worked on it very much
11:46:38 <lispy_> i need to implement dynamic extension of scope for function calls
11:46:52 <lispy_> also, there needs to be a way to define macros
11:47:04 <lispy_> with those two things it would be possible to start really making it elisp compliant
11:54:01 <Lemmih> Hello Itkovian.
11:55:27 <lispy_> goron: some things that could be done that may improve the code base, is to make SExp an instance of functor
11:55:39 <lispy_> goron: and i think some monadic magic could happen in eval
11:55:53 <lispy_> also, the current implementation is not strict
11:56:02 <lispy_> i figured i wouldn't fix that until it's needed
11:58:13 <Itkovian> evening
11:58:43 <Itkovian> sorry Lemmih ... I was just turning on my PB for a few mins to show some pics
11:58:52 <exa> shapr: thanks for the link. i think it was pretty nice.
11:59:06 <exa> shapr: the arrows article, that is
11:59:35 <goron> @haskellmode
11:59:36 <lambdabot> Unknown command, try @listcommands.
11:59:45 <goron> @where haskellmode
11:59:46 <lambdabot> I know nothing about haskellmode.
11:59:48 <goron> @where haskell mode
11:59:48 <lambdabot> http://haskell.org/
11:59:52 <goron> @where haskell-mode
11:59:53 <lambdabot> I know nothing about haskell-mode.
12:00:01 <lispy_> @google emacs haskell-mode
12:00:02 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
12:00:09 <goron> lispy_: thanks
12:00:24 <lispy_> goron: np :)
12:03:20 <goron> lispy_: I saw your code btw.
12:03:39 <Korollary> exa: wasn't there a revised syntax for ocaml ? This is awful. heh.
12:04:12 <exa> Korollary: It is uglier than haskell I think.
12:06:36 <xerox> @type head ([] :: Int)
12:06:43 <lambdabot> bzzt
12:06:54 <xerox> @type head [] :: Int
12:06:56 <lambdabot> Int :: Int
12:07:00 <xerox> Ooh.
12:07:15 <Korollary> exa: I found it: http://caml.inria.fr/pub/docs/tutorial-camlp4/tutorial005.html
12:07:48 <exa> Korollary: I forgot to say, yes, there is a revised syntax, and it's pretty good.
12:11:21 <exa> Korollary: look at Phrases, Imperative constructs, Lists, many nice improvements
12:11:45 <exa> Korollary: The original syntax is indeed a bit counterintuitive although I didn't have difficulty using it. Emacs was handy.
12:13:44 <wilx> Hmm, no more ;;?
12:13:50 <wilx> I thought it looked leet :D
12:18:33 <exa> I hadn't realized they have a "where" clause, too. influenced by haskell :)
12:20:20 <autrijus> it's more like common ancestry :)
12:21:11 <wilx> x := !x + y	vs   x.val := x.val + y
12:21:22 <wilx> Definitely positive improvement.
12:21:34 <wilx> I hated the exclamation marks.
12:21:43 <xerox> What language is it?
12:22:00 <wilx> OCaml vs Revised OCaml syntax.
12:22:27 <mflux> hmm
12:23:54 <mflux> but it is only marginally (conceptually) better than x.contents <- x.contents + 42
12:24:24 <Itkovian> Lemmih: woot! I got a page running locally ..
12:24:30 <mflux> I personally don't like all of the revised syntax decisions, and it's "all or nothing"
12:24:36 <mflux> so I picked nothing ;)
12:24:49 <Lemmih> Itkovian: Neat.
12:24:50 <mflux> but maybe I'll take a new look them at some time, maybe my opinion could've changed..
12:25:01 <musasabi> With haskell you can have "with x (do contents += 1; bar := 5; ...)"
12:25:27 <Itkovian> It was all in thee Apache config file
12:25:43 <mflux> musasabi, hmm.. is with a function? it's not a keyword?
12:25:58 <musasabi> mflux: just suitable definitions.
12:26:36 <mflux> does it come somehow automagically when you define a data structure?-o
12:26:49 <mflux> ocaml has preprocessor, so it can have such stuf t
12:26:52 <mflux> f too ;)
12:27:44 <musasabi> One just defines (+=) :: (Num n, Field f c n) -> c -> n -> OO f ()
12:28:03 <mflux> so where does the word 'with' come from?
12:28:21 <Lemmih> Itkovian: Care to write a few notes on installing HSP on MacOS and running pages locally?
12:28:28 <Itkovian> Lemmih: sure ...
12:28:31 <musasabi> with :: c -> OO c a -> IO a
12:28:56 <Itkovian> Lemmih: it will all be in the TMR article ;-) (let's see if this sentance gets noticed)
12:29:02 <Itkovian> sentence
12:29:07 <musasabi> Just some suitable definitions.
12:30:14 <Lemmih> Itkovian: That would be so cool!
12:30:46 <musasabi> http://groups.google.com/group/fa.haskell/browse_thread/thread/d57dc9bc291864d3/dde650bd27f39e39 for an example how to define them.
12:30:49 <xerox> musasabi: what is "Field" ?
12:30:58 <musasabi> http://homepages.cwi.nl/~ralf/OOHaskell/ is a much better and more complex way of doing it.
12:44:14 <mwc> I think that we ought to treat cats that have been sprayed by skunk with the same method as horses with broken legs.
12:44:29 <wilx> Hehe.
12:44:32 <mwc> After 20 minutes of wet cat Judo, I'm utterly convinced they don't like the common treatment
12:45:06 <basti_> :-D
12:45:19 <basti_> i remember how it is to treat a cat for worms
12:45:51 <mwc> after all that bighting, scratching, and attempts to jump out despite me holding it's chest down, I decided not to bother drying the little bugger off
12:45:58 <mwc> just through outside to air dr
12:46:12 <mwc> although after that ordeal the clothes dryer was looking MIGHTY attractive
12:46:15 <basti_> -g-
12:46:47 <mwc> so, that was how my day got started
12:47:18 <jlouis> mwc: hahaha!
12:47:50 <basti_> one word: oven
12:48:14 <jlouis> haha
12:49:53 <mwc> basti_, I was beginning to think that I should have thrown him in the washing machine and left to go read a book
12:50:06 <basti_> *g*
12:50:38 <Korollary> some animals were harmed during reading of this book.
12:50:40 <mwc> Oh well, next time I put the little sucker into the pet carrier and turn the hose on him
12:51:21 <wilx> It will hate you then.
12:51:27 <basti_> for years.
12:51:53 <Korollary> tranquilizer gun
12:52:34 <mwc> I think this is the first time I've ever applied Jiu Jitsu to a cat
12:52:52 <mwc> "if you control the head, the mobility of the body is severely reduced"
12:53:08 <basti_> *G*
12:53:49 <goron> Anyone using Haskell Mode 2.0?
12:53:57 <Lemmih> I do.
12:54:08 <goron> I want to get the interpreter.
12:54:20 <goron> I don't want hugs.
12:54:36 <musasabi> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
12:58:22 <goron> If I do C-c C-l it works.
12:58:38 <goron> But if I do C-c C-z I still get hugs.
12:59:13 <goron> Anyone uses a code browser in Emacs?
12:59:33 <goron> I have ECB, it even works for Haskell, pretty simple, but useable.
13:00:08 * musasabi uses eshell and grep.
13:00:50 <jlouis> shapr: I have some ideas for combinatorrent. Will write a longer thing about it
13:01:14 <basti_> jlouis: whats combinatorrent?
13:02:19 <musasabi> What does combinatorrent do as compared to the python clients?
13:02:20 <Korollary> basti_: I think it's shapr's bittorrent client in hs
13:02:32 <basti_> ah
13:02:59 <goron> musasabi: ty
13:03:51 <basti_> every bt should bring its own tracker, and bt should support spreading tracker information too, so that you can link your torrents via usual comm channels (IRC eg.), and the data will just follow your communication pattern
13:08:44 <lispy_> hud: internal error: scavenge_stack: weird activation record found on stack: 0
13:08:44 <lispy_>     Please report this as a bug to glasgow-haskell-bugs@haskell.org,
13:09:11 <lispy_> i wonder if it's my fault, or ghc
13:09:14 <lispy_> i'm using forkOS
13:09:23 <lispy_> when i use forkIO i don't have this problem
13:09:55 * lispy_ tries to reproduce it
13:10:01 <Igloo> Probably ghc's
13:10:08 <musasabi> lispy_: what architecture is that?
13:10:37 <Korollary> he's on osx iirc
13:10:59 <lispy_> musasabi: osx
13:11:09 <lispy_> it happens reliably
13:11:11 <musasabi> hmm that should be quite well supported.
13:11:59 <musasabi> Making a small test case and trying whether 6.4.1 snapshot fixes it and if not reporting to the GHC sf.net bugtracker could be a good way.
13:12:07 <lispy_> i'm using exitWith ExitSuccess when the client closes the connection
13:12:21 <lispy_> i think it's the second call to exitWith that causes the crash
13:12:54 * lispy_ tries removing exitWith
13:14:36 <lispy_> yes, it's the second call to exitWith ExitSuccess
13:15:00 * Itkovian waves at boegel
13:16:55 * boegel waves back
13:18:21 <shapr> jlouis: ping?
13:20:25 * boegel sets up some stuff to take pictures of his growing collection
13:21:12 <shapr> Too bad there's not an nntp server in Haskell.
13:21:39 <shapr> lambda-the-ultimate.org would be nicer with an nntp read-only frontend, and the backend is Drupal kept in MySQL tables.
13:21:47 <shapr> HaskellDB plus an nntp server would be perfect.
13:23:08 <lispy_> alrighty, sent in the bug report
13:23:19 <lispy_> i'd test it on 6.4.1, but that would be a huge pain
13:23:41 <lispy_> shapr: haskelldb or HSQL?
13:24:02 <shapr> HaskellDB
13:24:04 <lispy_> i hear that HSQL is actually a bit easier and has better performance....maybe i read that on haskell-cafe?
13:24:17 <shapr> HaskellDB is awesome.
13:24:34 <lispy_> does it support sqlite?
13:32:33 <Itkovian> brb
13:34:49 <Igloo> Does HaskellDB provide a common way to get a unique integer for an index, BTW?
13:38:14 <musasabi> It supports default values at least.
13:38:23 <musasabi> And that can be used in many databases for that.
13:43:59 <musasabi> Having good and efficient binary String handling would be nice.
13:44:10 <musasabi> But even plain SQL does not have that.
13:44:42 <tuomov> Boot.hs:41:0:
13:44:42 <tuomov>     Failed to load interface for `System.Plugins.Utils':
13:44:42 <tuomov>         Could not find module `System.Plugins.Utils':
13:44:42 <tuomov>           it is hidden (in package plugins-0.9.10)
13:44:44 <tuomov> hmm..
13:44:59 <tuomov> what does that mean?
13:45:10 <sylvan> so is there a special trick I can do to install wxHaskell when ghc is in a directory containing spaces?
13:46:42 <jlouis> shapr: pong
13:46:44 <lispy_> tuomov: um....not sure
13:46:45 <tuomov> dons: ?
13:48:18 <jlouis> shapr: was writing docs on combinatorrent ;)
13:49:42 <xerox> Yeah...
13:49:44 <xerox> Compiling Graphics.Rendering.Cairo ( Graphics/Rendering/Cairo.hs, interpreted )
13:49:44 <xerox> *** Exception: Maybe.fromJust: Nothing
13:49:55 <xerox> Hmpf :-)
13:50:55 <xerox> @index liftIO
13:50:57 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
13:50:57 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
13:50:57 <lambdabot> Monad.Error, Control.Monad.List
13:51:52 <tuomov> sigh. all this package stuff is complete mess.
13:52:30 <basti_> yes
13:53:28 <xerox> @type (ask >>=) . liftIO
13:53:28 <lispy_> i find that doing selective imports is confusing
13:53:35 <lambdabot> bzzt
13:53:41 <lispy_> @index ask
13:53:42 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
13:53:51 <xerox> @type (Control.Monad.Reader.ask >>=) . Control.Monad.Trans.liftIO
13:53:53 <lambdabot> forall (m :: * -> *) r b.
13:53:53 <lambdabot> (Control.Monad.Reader.MonadReader r m,
13:53:53 <lambdabot> Control.Monad.Trans.MonadIO ((->) r)) =>
13:53:53 <lambdabot> IO (m b) -> m b
13:54:00 <xerox> Gasp.
13:54:06 <lispy_> @pl (Control.Monad.Reader.ask >>=) . Control.Monad.Trans.liftIO
13:54:06 <lambdabot> (Control . Monad . Reader . ask >>=) . Control . Monad . Trans .
13:54:06 <lambdabot> liftIO
13:54:28 <lispy_> i guess that is point free already
13:54:40 <lispy_> @pl (ask >>=) . liftIO
13:54:40 <lambdabot> (ask >>=) . liftIO
13:54:48 <TheHunter> @type Control.Monad.Trans.liftIO . (Control.Monad.Reader.ask >>=)
13:54:50 <lambdabot> bzzt
13:55:22 <lispy_> ask >>= . liftIO looks like a good candidate for fmap
13:55:34 <lispy_> but maybe i'm mistaken
13:55:50 <TheHunter> @pl \f -> liftIO f =<< ask
13:55:52 <lambdabot> (ask >>=) . liftIO
13:55:54 <xerox> @pl \f xs -> xs >>= return . f
13:55:56 <lambdabot> fmap
13:56:26 <xerox> TheHunter: any idea about its type?
13:56:56 <lispy_> xerox: the type of which?
13:57:08 <TheHunter> @pl \f -> liftIO . f =<< ask
13:57:09 <lambdabot> (ask >>=) . (liftIO .)
13:57:12 <TheHunter> (of course)
13:57:18 <xerox> I was thinking: IO a -> Render a  but it seems it doesn't match.
13:57:23 <TheHunter> @type (Control.Monad.Reader.ask >>=) . (Control.Monad.Trans.liftIO .)
13:57:24 <lambdabot> forall r (m :: * -> *) a.
13:57:24 <lambdabot> (Control.Monad.Reader.MonadReader r m,
13:57:24 <lambdabot> Control.Monad.Trans.MonadIO m) =>
13:57:24 <lambdabot> (r -> IO a) -> m a
13:57:33 <xerox> HMM!
13:58:24 <xerox> Nah, it is not  (Cairo -> IO a) -> Render a  for some reason I can't understand.
13:59:12 <lispy_> r = Cairo, a = a, m = Render
13:59:26 <lispy_> then use that last type that lambdabot produced :)
13:59:55 <shapr> jlouis: Oh tell me more!
14:00:11 <shapr> jlouis: You said you wanted to talk more about combinatorrent?
14:00:36 <xerox> TheHunter: I'm using the newtype in Cairo.hs
14:01:37 <TheHunter> what's the problem?
14:02:05 <shapr> jlouis: The canonical implementation of bittorrent is very slow with multiple torrents, I'd like to improve that in combinatorrent. Ten torrent downloads cost a continuous 25% usage of one of my 1.5GHz cpus.
14:02:22 <xerox> TheHunter: I was trying to encapsulate those "func f .. = ask >>= \context -> liftIO $ f context ..
14:03:23 <shapr> exa: What do you think about arrows now?
14:03:35 <TheHunter> xerox, that's what it does, isn't it?
14:04:08 <jlouis> shapr: take your email adress, represent it in Haskell as a String. Lets call it emailaddy. map succ emailaddy and post here ;)
14:04:27 <musasabi> shapr: A functionality like "close downloads N minutes after they are complete would be nice".
14:04:44 <jlouis> musasabi: the original bittorent client has that
14:05:21 <jlouis> I am thinking about a threaded implementation based on Control.Concurrent.Chan
14:05:29 <xerox> TheHunter: |liftRender0 = (ask >>=) . liftIO| doesn't compile
14:05:59 <xerox> No instance for (MonadIO ((->) r)
14:06:15 <TheHunter> first of all, why doen't you write |liftRender0 f = ask >>= liftIO . f| ?
14:06:18 <xerox> In the second argument of `(.)', namely `liftIO'
14:06:19 <jlouis> cool stuff must come over time. The basics should be fast fast fast!
14:06:35 <TheHunter> and the pointless version is (ask >>=) . (liftIO .)
14:06:52 <lispy_> jlouis: i've been having really bad luck with Control.Concurrent
14:07:08 <lispy_> jlouis: i made a little chat server, and it sometimes just freezes up
14:07:17 <xerox> TheHunter: erhm...
14:07:21 <xerox> Compiling Graphics.Rendering.Cairo ( Graphics/Rendering/Cairo.hs, interpreted )
14:07:21 <xerox> *** Exception: Maybe.fromJust: Nothing
14:07:22 <lispy_> and some random number of minutes later goes back to normal
14:08:17 <jlouis> lispy_: then we'll have to uncover bugs in GHC. That is one of my goals
14:08:26 <xerox> TheHunter: do you want me push the patch?  In fact it's only that definition, you could try it.
14:08:26 <TheHunter> xerox is that a compiler bug?
14:08:32 <xerox> TheHunter: seems so.
14:08:59 <lispy_> jlouis: if you want to play with what i have you can find the code at http://projects.codersbase.com/repos/hud  or you can connect to a live instance at telnet codersbase.com 2000
14:09:19 <xerox> ..put that liftRender0 definition in Cairo.hs and try ghci -fglasgow-exts Graphics/Rendering/Cairo.hs
14:09:38 <lispy_> jlouis: it should echo anything  you type with your hostname, if it doesn't do that then it's frozen again
14:10:14 <jlouis> lispy_: cool
14:10:15 <lispy_> i also noticed that the windows telnet sends each character instead of line buffering them
14:10:37 <TheHunter> xerox, how do i generate the hs files?
14:10:50 <xerox> TheHunter: if you open a ghci, and try "let g f = Control.Monad.Reader.ask >>= Control.Monad.Trans.liftIO . f" it "works" in fact.
14:11:06 <lispy_> jlouis: i'd realy like to turn it into a mud, but unless i can get these concurrency issues figured out it won't be fun to play :)
14:11:16 <xerox> TheHunter: autoreconf -i && sh configure && make  :-|
14:11:46 <TheHunter> sigh, aclocal: configure.ac: 199: macro `AM_HCFLAGS' not found in library
14:12:01 <xerox> TheHunter: is it an error or just a warning?
14:12:18 <TheHunter> it's an error: autoreconf: aclocal failed with exit status: 1
14:12:23 <xerox> Try sh configure
14:12:33 <shapr> jlouis: shae@ScannedInAvian.com, mind the nasty anti-spam protection.
14:12:39 <TheHunter> no configure produced
14:12:43 <xerox> Argh.
14:12:51 <jlouis> shapr: okie, patch coming up
14:13:18 <xerox> TheHunter: which autoreconf/aclocal do you have?
14:13:21 <TheHunter> i hate this autocrap.
14:13:27 * xerox too
14:13:38 <TheHunter> the newest one in debian/unstable
14:13:51 <xerox> Debian provides different version (as ubuntu here) I think
14:14:17 <xerox> That is, "automake1.[46789]" packages.
14:14:31 <xerox> Here it does work, and I use automake1.9.
14:14:38 <xerox> (It outputs some warnings, tough)
14:14:46 <TheHunter> autoreconf (GNU Autoconf) 2.59
14:15:12 <xerox> Same, the problem is prolly aclocal's version (?)
14:15:17 <TheHunter> maybe i should install autoconf-archive
14:15:37 <TheHunter> aclocal (GNU automake) 1.4-p4
14:15:53 <xerox> aclocal (GNU automake) 1.9.5
14:17:13 <TheHunter> installing automake1.9
14:17:53 <shapr> jlouis: got it!
14:18:28 <bourbaki> moin
14:18:43 <xerox> Howdy bourbaki
14:18:52 <TheHunter> moin
14:19:08 <TheHunter> xerox, can I make with only 256MB ram?
14:19:33 <xerox> TheHunter: indeed, thanks to dcoutts it only takes 80Mb max.
14:19:52 <xerox> Cool for some values of "only" :-P
14:21:03 <TheHunter> 80MB is ok. Even with 2 firefoxes running, i think.
14:21:09 <tuomov> ghc package system is officially broken.
14:21:20 <xerox> GHC's bug day
14:21:33 <tuomov> it refuses to use stuff in hsplugins. it refuses to find hscurses at all.
14:21:43 <tuomov> ghc-pkg lists both
14:21:51 <TheHunter> what do i need for gobject-2.0 ?
14:21:57 <basti_> try which ghc, which ghc-pkg
14:22:00 <boegel> yo bourbaki
14:22:15 <basti_> analyze links, if you see links. (tuomov)
14:23:05 <xerox> TheHunter: build-depends is "haskell98"
14:23:10 <xerox> What error are you getting?
14:23:37 <TheHunter> checking for GLIB... configure: error: Package requirements (gobject-2.0 >= 2.0.0) were not met.
14:23:43 * TheHunter hates chasing dependencies
14:23:51 <Korollary> who doesnt
14:24:14 <jlouis> TheHunter: you need glib2.x
14:24:18 <xerox> TheHunter: maybe you're miss some -dev?
14:24:18 <jlouis> maybe a dev package
14:24:22 <alar> TheHunter sound very familiar :)
14:24:46 <jlouis> gobject is part of glib
14:24:46 * boegel wonders where he left his Woody doll
14:25:01 * jlouis pets the blowfish
14:25:06 <jlouis> OUCH!
14:25:12 <xerox> TheHunter: libglib2.0-dev, probably.
14:25:25 <TheHunter> yep thanks, just found that out
14:25:45 <xerox> yw.
14:27:41 <jlouis> I don't get Debian there. Why split into -dev packages? Its not -dev packages that will kill your disk space
14:28:19 <jlouis> plus it costs a lot in packaging time to do the splitting
14:28:22 <xerox> jlouis: libcairo does have -doc too -_-
14:29:09 <TheHunter> libglib1.2-dev won't do it, right?
14:29:11 <jlouis> I must be a clueless, old (nah), grumpy, irritated OpenBSD zealot to even think that it is utterly wrong
14:29:41 <jlouis> libglib1.2 wont do it
14:29:41 <xerox> TheHunter: aww...
14:30:04 <xerox> GObject _is_ in glib
14:30:21 <TheHunter> right now, i'm chasing the next dependency
14:30:39 <xerox> That is?
14:30:46 <TheHunter> libglib2-dev doesn't exist libglib-dev wants to install 1.2-dev
14:30:53 <TheHunter> checking for GTK... configure: error: Package requirements (gdk-2.0 >= 2.0.0 gtk+-2.0 >= 2.0.0 gdk-pixbuf-2.0 >= 0.12.0) were not met.
14:31:10 <xerox> You miss many -devs
14:31:41 <TheHunter> chances are, i'm missing all -devs except those needed to build the linux kernel.
14:32:07 <xerox> libgtk2.0-dev libgdk-pixbuf-dev  should do it
14:32:47 * xerox goes hunting the chocolate-covered cookies found earlier today
14:33:07 <TheHunter> ok, trying that.
14:33:24 <TheHunter> 14,5 MB headers?
14:33:30 <xerox> *cough*
14:34:16 <TheHunter> ok, configure went through.
14:34:19 <jlouis> peanuts
14:34:29 * xerox yummys the cookies
14:35:08 <xerox> They're not exactly "proper" cookies, neither the chocolate seems to be "proper" one, but they're nice.
14:35:45 * TheHunter has only 150MB of free space on his / partition...
14:36:10 <xerox> Why so?  Running linux on some palm device?  :-P
14:36:11 <sylvan> anyone know what the "bool" means that I'm supposed to return from the "on idle" event in wxHaskell?
14:36:43 <TheHunter> no, but on a 3-year-old laptop with 20GB of disk space.
14:37:05 <TheHunter> and i need most of the space for my music.
14:37:13 <xerox> Fair enough, I resolved with an external drive... *installation* gee.
14:37:34 <TheHunter> i have external drives also, but only usb1.0 :/
14:37:55 <jlouis> TheHunter: hopefully, that shouldn't be installed on /
14:38:05 <jlouis>  /usr would be the place to install such things
14:38:06 <xerox> External USB2/Firewire closures aren't that expensive
14:38:37 <jlouis> ... my OpenBSD heritage shines through again... grrr
14:38:51 <TheHunter> i do have a usb2 closure..
14:39:07 <TheHunter> well, i can never estimate space requirements for such partitions properly.
14:39:19 <xerox> I'm a {/,swap} guy too.
14:40:17 <TheHunter> fine-grained partitioning won't help you if your disk dies anyway.
14:40:32 <jlouis> Well, there are 2 reasons why you want to split into partitions: NFS mounting /usr and disk-cache-optimizations
14:40:43 <jlouis> most people can strike the first one
14:41:02 <jlouis> leaving the 2nd, which is not that important for desktop systems
14:41:49 <TheHunter> a good file system should take care of 2nd, but i'm unaware if any linux filesystem is that good.
14:42:40 <jlouis> there is a difference in disk usage patterns that matters: /usr is only read for instance in the old hierachy layouts (NFS mounting read only)
14:42:50 <jlouis> while /var is a lot of write (log files)
14:43:10 <jlouis> the kernel runs separate disk caches for each partition
14:44:09 <TheHunter> c2hsLocal: Errors during expansion of binding hooks:
14:44:18 <jlouis> also, however effective your kernel is, the outer tracks on the disk are much faster than the inner tracks, so you want the often read/written data to be at the outer tracks (start of disk). This is almost impossible without partitioning
14:44:46 * boegel leaves for bed
14:45:10 <xerox> TheHunter: is that the last darcs pull?
14:45:19 <TheHunter> yes
14:47:15 <TheHunter> jlouis, that's what i meant. a good file system could put often-accessed data at the beginning of the disk.
14:48:16 <basti_> are you sure "inside" and "outside" accesses differ that much in access time? I'd expect it to be ~20% difference if you ask me
14:48:28 <xerox> TheHunter: could you paste me the errors?
14:51:40 <TheHunter> having files that are often accessed together in adjacent localtions on the hard drives is probably more important.
14:54:14 <exa> shapr: i knew that, but now i'm thinking like whether it could be a nice program decomposition device.
14:54:57 <exa> shapr: with well used arrow transformations (higher order arrows), one could design programming patters suitable for decomposition of abstract problems.
14:55:26 <Philippa> when you say higher order arrows, do you mean just ArrowApply?
14:55:35 <Philippa> if so, why not just use a monad?
14:55:51 <Philippa> (because it is one)
14:57:03 <exa> some arrow features do not seem to be possible with monads
14:57:13 <exa> i'm trying to understand exactly what kind :)
14:57:41 <Philippa> the kind that require you to rule out higher order stuff
14:57:51 <Philippa> because that's what monads have and arrows don't (necessarily)
14:58:44 <Philippa> in turn, the lack of higher-orderness means the structure's known statically, it's not going to change - that's what lets you do various bits of analysis
14:59:57 <exa> But I know the power of abstraction in category theory. this representation is more abstract.
15:00:25 <xerox> dcoutts: ping!
15:00:57 <Philippa> how is it more abstract, exactly?
15:01:50 <Philippa> the usual set of combinators encourage point-free programming more, sure
15:02:52 <Philippa> but that's just because arrows need that much extra structure to make up for not being able to lean on ordinary haskell as much
15:03:09 <exa> Hughes's paper says that we can abstract a function by replacing it with an arrow. Which is not possible with monads.
15:03:17 <exa> the thing is
15:03:38 <exa> this ought to be more generally applicable, so you can develop libraries of this stuff.
15:03:59 <Philippa> again: ArrowApply => Monad. So it doesn't buy you anything
15:04:12 <exa> like parsec being a useful demo. of monadic combinators
15:04:25 <Philippa> yeah. Yampa's a nice demo for arrows
15:04:34 <exa> I think this really needs an application. Some apps are apparently listed in shapr's intro.
15:04:42 <Philippa> I've not seen anything really really good aside from yampa though
15:04:51 <exa> I don't even remember yampa
15:05:01 <Philippa> it's the arrowised FRP library
15:06:19 <exa> looks nice
15:06:33 <Philippa> it's cute, I'd like to play with it for doing game rules sometime
15:06:47 <Philippa> if I ever got round to it I'd like to hack up Q3A to use haskell-based mods...
15:07:42 <sylvan> Well Q3A is straight C so it should be fairly easy to use from Haskell... And the full source was relesed under GPL just a few days ago..
15:07:52 <sylvan> go for it!
15:08:27 <exa> hmm would be a good test environment for ai research :)
15:08:42 <Philippa> sylvan: not the way round to do it. Want to call the Haskell from C
15:08:52 <Philippa> otherwise I have to do a /lot/ more reverse engineering Q3A
15:09:09 <Philippa> exa: stuff the AI research. It'd be a great way to look into better scripting for games :-)
15:09:36 <Philippa> but knowing me I'll never get round to figuring out the interface, hooking stuff up and having a basic player entity run around
15:10:54 <sylvan> You could write the main function in Haskell and just call the C stuff from there (renderer, net code etc.)
15:10:58 <FrederikEaton> maybe the answer is that P=NP because after long enough the hard drive fails and everything becomes NP
15:11:31 <jlouis> the old classic proof is to take N = 1
15:11:35 <sylvan> and you don't have to reverse engineer anything since it's open source
15:13:05 <FrederikEaton> jlouis: that's dumb.
15:13:08 <FrederikEaton> jlouis: P=0
15:13:28 <exa> hehe
15:14:00 <jlouis> hehe
15:14:27 <jlouis> what if we took N = _|_ ?
15:14:52 <jlouis> don't we end as with the hard drive crash?
15:14:57 <Philippa> sylvan: sure I do. I don't have a system overview handy
15:15:37 <Philippa> claiming it's not reverse engineering just because I'm looking at it in a slightly higher-level language than machine code doesn't really wash IMO
15:16:39 <xerox> Q3 engine was released under GPL not long ago IIRC
15:17:00 <Philippa> yeah. I have the source on my HD
15:17:05 <xerox> Cool.
15:17:16 <yeti> yeah, i think Philippa meant C when he was talking about "a slightly  higher-level language than machine code
15:17:19 <yeti> "
15:17:22 <yeti> ;)
15:17:53 <xerox> Philippa: what are you trying to do with it
15:17:56 <xerox> ?
15:18:02 * Philippa wonders if yeti has many problems with being unable to tell men from women
15:18:18 * yeti sometimes wonders about that too
15:18:25 <Philippa> xerox: I'm not at the moment. But I'd like to hook in haskell where the QVM stuff is now and build a new game scripting system out of it
15:18:37 * yeti wonders whether he should actually read nicknames instead of pressing tab for autocompletion
15:18:40 <yeti> sorry :(
15:18:41 <xerox> Philippa: impressive
15:18:54 <Philippa> it's just an "I'd like to", it'd be impressive if I actually /did/ it
15:19:10 * xerox cheers
15:19:41 <FrederikEaton> Philippa: you're amazing!
15:20:03 <Philippa> FrederikEaton: why thank you. Um. How?
15:20:22 <Philippa> I mean, aside from the general female coder/gamer/geek stuff that inevitably makes (some) men putty in my hands? ;-)
15:20:35 <sylvan> Ah... I was thinking more along the lines of "Q3A as a library" and writing the main program in Haskell
15:20:38 <FrederikEaton> i was joking about the "Philippa: impressive"
15:20:46 <FrederikEaton> sorry
15:20:53 <Philippa> nah, I figured as much
15:21:04 <xerox> I said it because I wouldn't ever mess with C code that complex.
15:21:08 <Philippa> sylvan: that's awkward. You have to run haskell right the way through the program IYSWIM
15:21:24 <sylvan> IYSWIM?
15:21:29 <Philippa> xerox: fair enough. I did a little with the original Quake engine but nothing much - added air control and hooks for a few new buttons for QuakeC, that kind of thing
15:21:33 <Philippa> If You See What I Mean
15:22:14 <Philippa> annoyingly, the +use button that QuakeC had hooks for and didn't work was merely left out of a couple of simple routines - there was an allocated bit for it in the network protocol and everything :-(
15:23:00 <xerox> Is there any cool pro in using Q3's one instead of any other freely available 3D engine, aside coolness?
15:23:26 <Philippa> piles of modders used to the formats and tools
15:23:50 <Philippa> oh, and the engine's pretty solid, I'm unlikely to run into too much that makes me want to yell "WTF?!" in disbelief
15:24:03 <Philippa> or have to implement masses of functionality myself, for that matter
15:24:12 <Philippa> oh. And Q3A's a game engine not just a graphics engine
15:24:15 <Philippa> big difference, that
15:24:19 <xerox> I see
15:24:48 <Philippa> you can fit a reasonably impressive renderer in 3KLoC or so
15:25:48 <Philippa> but aside from the time taken to work out what a minimal asset set is, I could go build a game with Q3A right now in a way that most of the free projects aren't really up to
15:26:24 <xerox> Cool :)
15:26:24 <lispy_> Philippa: q3 source is out now?
15:26:32 <xerox> lispy_: yep.
15:26:36 <lispy_> cool
15:27:52 <sylvan> Funny, q_math.c line 561 : "i  = 0x5f3759df - ( i >> 1 );               // what the fuck?"
15:27:59 <Philippa> heh
15:28:05 * xerox laughs
15:28:09 <sylvan> looks like someone copy-pasted =)
15:29:13 <lispy_> how long has it been out?
15:29:55 <sylvan> three days
15:30:04 <sylvan> released on the 19th
15:30:49 <lispy_> why did they package it as a .exe?
15:31:00 <lispy_> i wanted to download it, but i'll need windows
15:31:09 <Philippa> eh? I got a .zip
15:31:16 <sylvan> uh did they? I got zip
15:31:26 <Philippa> you might be looking at the "game source" release
15:31:29 <Philippa> which isn't what you want
15:32:03 <lispy_> http://www.idsoftware.com/business/techdownloads/
15:32:13 <sylvan> google for  quake3-1.32b-source.zip
15:32:38 <lispy_> thanks
15:32:53 * xerox yawns
15:33:23 <Korollary> without punkbuster, it's an academic exercise to do anything with that source heh
15:33:37 <sylvan> single player games!
15:34:00 <Korollary> you could do that with the sdk already
15:34:14 <Philippa> only to a certain extent though
15:34:18 <Philippa> you've more freedom now
15:34:20 <sylvan> now you can add bloom!
15:34:35 <Korollary> yes, now you can make ms pacman eat imperative code blocks
15:35:43 <basti_> going to bed... night
15:36:40 <lispy_> these file download sites are terrible
15:36:47 <lispy_> someone should outlaw them :)
15:37:13 <Korollary> the slashdot article had a lot of links
15:37:33 <lispy_> i finally found a working link
15:37:54 * sylvan predicts someone will add stencil shadows and hdr rendering within one week
15:38:00 <lispy_> but geez, those fileplanet clones are terrible, i can't imagine anyone supporting a website that freaks out your browser
15:38:28 <FrederikEaton> do people actually use the stuff from the Implicit Configurations paper? it seems like it would be slow, at the very least
15:38:45 <FrederikEaton> it seems like there should be some sort of built-in support for that
15:38:54 <FrederikEaton> for reifying values to types
15:39:18 <lispy_> FrederikEaton: hi, i looked at you HMM.hs code and i want to know, can you provide an example of how i might create a k-order model that i can feed strings to?
15:39:45 <xerox> FrederikEaton: I always wondered what "reify" means, is it {difficult,long} to explain?
15:39:58 <lispy_> FrederikEaton: it's probably an odd request, but i want to write megahal in haskell :)
15:40:01 <FrederikEaton> lispy_: you mean with a k*k matrix? i think it would be pretty slow
15:40:09 <FrederikEaton> megahal?
15:40:15 <FrederikEaton> lispy_: it's a bit of a toy
15:40:54 <xerox> lispy_: what is HMM.hs?
15:40:55 <lispy_> FrederikEaton: yeah, megahal uses order 4 markov models
15:40:56 <FrederikEaton> lispy_: but you'd have to define your own data type. i was too lazy to do a standard one with N states so i just used Bools everywhere
15:41:09 <exa> prolly a hidden markov model implementation
15:41:17 <FrederikEaton> xerox: the dictionary says "consider an abstract concept to be real"
15:41:19 <exa> maybe a viterbi algorithm implementation?
15:41:26 <FrederikEaton> exa: no
15:41:31 <exa> what is it?
15:41:34 <lispy_> FrederikEaton: okay, my problem was that i couldn't figure out how to implement markov models in < 10 min so i lost interest in my project :)
15:41:41 * xerox writes Mumble.hs
15:41:54 <xerox> FrederikEaton: sounds interesting
15:41:57 <FrederikEaton> exa: http://ofb.net/~frederik/futility/src/HMM.hs
15:41:59 <lispy_> xerox: it's a hidden markov model thingy that FrederikEaton wrote
15:42:05 <xerox> ..or at least, economics :-P
15:42:21 <FrederikEaton> the code should be very transparent, almost 1-1 with the specification of the model
15:42:28 <FrederikEaton> yet just as fast as the viterbi algorithm
15:42:40 <FrederikEaton> and the same code can be used for training and simulation
15:43:01 <FrederikEaton> (hence the [Maybe b] input)
15:43:31 <xerox> What is it all about?  I don't know what an ``Hidden Markov Model'' is.
15:43:36 <lispy_> who, my internet radio station just changed to a lesson on spanish
15:43:45 <lispy_> ah, just a commercial. so weird
15:44:16 <lispy_> FrederikEaton: that's good.  But I was hoping to find a library that provided HMM for me, and I could just build on top of it
15:44:18 <FrederikEaton> xerox: it's a probabilistic model where you have a hidden state which evolves according to a stochastic transition matrix
15:44:21 <exa> Philippa: Here is one reason why arrows are better: http://www.haskell.org/tmrwiki/ArrowsIntroduction#head-0591d158b89b020c3074d77a986aae2551e1d8e6
15:44:29 <exa> There's one major problem. This doesn't fit into the monadic interface. Monads are (a -> m b), they're based around functions only. There's no way to attach static information. You have only one choice, throw in some input, and see if it passes or fails.
15:45:16 <exa> FrederikEaton: looks pretty nice
15:45:26 <FrederikEaton> xerox: and you observe it according to a stochastic observation matrix, and the goal is usually to predict what the state was given the observations. for instance, the state might be a number from 1-10 and you can only observe its parity, but with some noise
15:45:30 <xerox> FrederikEaton: Cool, tough I'm lost on ``stochastic transition matrix'' :)
15:45:38 <lispy_> q3 code is gpl, so it's going into a darcs archive and then up on my server :)
15:45:47 <FrederikEaton> xerox: but using what you know about the transitions, you make predictions about where it was when
15:46:56 <exa> sometimes haskell syntax looks so much better than ocaml, ahem :)
15:47:05 <Korollary> exa: sometimes ? :)
15:47:15 <exa> well yea
15:47:22 <FrederikEaton> lispy_: this may have what you need. it may not. i don't know
15:47:26 <exa> type classes are really cool for instance, and it's not just semantics :)
15:47:50 <FrederikEaton> lispy_: i also want to write a matlab wrapper soon which should allow a faster implementation, but which is similarly intuitive
15:47:58 <exa> you'd need functors to achieve that in ocaml
15:48:22 <exa> i wonder if you can do everything you can do with type classes that way?
15:48:46 <exa> uh, can you do inheritance?
15:49:15 <shapr> lispy_: Do you have a darcs repo of q3a source?
15:49:28 <lispy_> shapr: recording now
15:50:05 <lispy_> shapr: i'm not sure what all was in their zip file
15:50:10 <lispy_> shapr: but i'll find out soon
15:51:04 <shapr> spiffy
15:52:04 <lispy_> shapr: darcs pushing is happening now, you'll find the repo at http://projects.codersbase.com/repos/quake3
15:53:42 <greenrd> Philippa: The tutorial at http://sneezy.cs.nott.ac.uk/epigram/downloads/epigram-notes.pdf is way over my head - I'd love to get ahold of the undergrad course notes, if/when they become available
15:54:17 <greenrd> (assuming they will be more accessible than the existing tutorial)
15:54:54 <shapr> lispy_: thanks!
15:55:16 <xerox> Phantom Types are implemented in Haskell?
15:55:34 <shapr> Yeah, you just pass around the type and don't really do anything with it.
15:56:05 <xerox> Hm.
15:57:07 <Philippa> greenrd: I'll find out if they are. I don't know if they'll be much more accessible though
15:57:09 <shapr> xerox: http://www.haskell.org/hawiki/PhantomTypes
15:57:26 <Philippa> (also, it may well be a while before I do - term doesn't start for a month if nothing else)
15:57:38 <shapr> greenrd: Try using Epigram according to the tutorial, that cleared up a lot for me.
15:58:28 <greenrd> shapr: But the exercises scare me... it's like "Hang on, I haven't understood anything yet!"
15:59:04 <FrederikEaton> has anyone released a up-to-date cabalized HSQL yet?
15:59:22 <xerox> shapr: that's what I was reading back some days ago, so I searched for other informations, but it's hard to understand papers talking about {types,type theory} :-)
15:59:23 <Lemmih> The up-to-date version of HSQL _is_ cabalized.
15:59:30 <FrederikEaton> oh really?
15:59:37 <FrederikEaton> heh
15:59:41 <Lemmih> Don't think it's released in any other forms.
15:59:41 <FrederikEaton> that saves me the trouble
16:00:21 <Philippa> greenrd: do them. You're given instructions at first, they'll show you the stuff to understand.
16:01:56 * greenrd grumbles
16:02:18 <lispy_> it builds
16:02:21 <greenrd> It's arrogant sod syndrome, I think. Not used to not understanding a programming language.
16:02:32 <lispy_> but i don't have any q3 content....
16:04:16 <yeti> mh... how many of you girls/guys are MScs/PhDs or similar in mathematics/computer science?
16:04:55 <Philippa> I'm a mere undergrad, though under other circumstances I'd be working on a PhD
16:05:05 <greenrd> soon to be starting msc
16:05:07 <Philippa> lispy_: go buy. Or DL the demo or something.
16:05:13 <shapr> I had CS101 in 1992, that's the extent of my computer education.
16:05:55 <yeti> Philippa/greenrd: mathematics or CS?
16:06:01 <shapr> lispy_: Can't you use one of the total conversions?
16:06:02 <greenrd> CS
16:06:16 <xerox> shapr: liar! :-P
16:06:20 <lispy_> Philippa: good idea
16:06:24 <lispy_> shapr: maybe
16:06:44 <Philippa> yeti: compsci
16:06:50 <lispy_> @where+ lispq3 http://www.codersbase.com/Quake3
16:06:50 <lambdabot> lispq3 ~> http://www.codersbase.com/Quake3
16:06:55 <Philippa> shapr: few of the TCs really are TCs
16:06:57 <lispy_> oops
16:07:03 <lispy_> that should be lispyq3
16:07:07 <lispy_> any idea how i can fix that typo?
16:08:09 <lispy_> ah, darcs is at 100% CPU utilization, so i bet the transfer is almost done
16:08:10 <exa> so what's missing here? seems fairly abstract to me?
16:08:49 <exa> in the HMM code that i
16:08:52 <exa> that is
16:09:02 <exa> maybe i'm not looking careful enough any pointers?
16:09:17 <exa> sunday evening's not the time for this kind of stuff :)
16:10:02 <shapr> xerox: Seriously, that's all the CS classes I've ever had.
16:10:17 <lispy_> exa: i wasn't sure how to use it either, having 0 background with HMM I was clueless
16:10:19 <FrederikEaton> exa: did you have a question?
16:10:26 <xerox> shapr: I never had CS class, FWIW.
16:10:40 <FrederikEaton> there are examples in the examples directory
16:10:45 <lispy_> i never learned anything in a CS class, FWIW ;)
16:10:56 <lispy_> FrederikEaton: ah, i missed that
16:11:11 <Philippa> I first met haskell in a CS class
16:11:18 <Philippa> one of the few really valuable bits at uni
16:11:33 <Philippa> (though doing the concurrency module was good too as I was one of the students who walked out actually understanding the issues)
16:12:01 <lispy_> shapr: transfer compleet
16:13:24 <Korollary> yeti: I have an MS in CE
16:13:34 <exa> No I just  thought it was a proper code
16:14:14 <FrederikEaton> lispy_: i'll be surprised if things work well. there may be debugging statements. it may be really slow. but i'd love to hear feedback
16:16:07 <FrederikEaton> lispy_: by the way, you may be the first actual user of one of my libraries. dubious honor, perhaps
16:16:47 <lispy_> "You should have received a copy of the GNU General Public License
16:16:47 <lispy_> along with Foobar;"
16:17:11 <lispy_> FrederikEaton: well, i haven't downloaded it yet :)
16:17:24 <lispy_> FrederikEaton: and i still need an irc lib
16:17:51 <FrederikEaton> oh right
16:18:03 <Pseudonym> Quick question.
16:18:08 <FrederikEaton> i have to put GPL piss on everything
16:18:19 <Pseudonym> The caffeine hasn't kicked in yet, so I'm not thinking.
16:18:27 <Pseudonym> What's the Fourier transform of a Dirac delta function?
16:18:57 <Pseudonym> It's probably a discrete sinc or something.
16:19:11 <FrederikEaton> lispy_: whatever. if it's not for you, don't use it
16:19:27 <Pseudonym> Ah, MathWorld knows.  Never mind.
16:19:45 <lispy_> FrederikEaton: i don't mean to sound ungrateful.  I just want to glue my bot together from other peoples libs :)
16:20:14 <FrederikEaton> lispy_: why should you be grateful? i didn't write it for you.
16:20:18 <FrederikEaton> lispy_: :)
16:20:35 <FrederikEaton> lispy_: so why are you using HMMs?
16:20:52 <FrederikEaton> lispy_: by the way, i'll be doing a master's in machine learning next year
16:22:53 <FrederikEaton> do people not like WASH for fundamental reasons, or do they think that it could be improved but hasn't been?
16:23:04 <lispy_> FrederikEaton: megahal used 4th order MM (maybe HMM) to predict words
16:23:40 <lispy_> FrederikEaton: sentences are parsed as alternating word/non-word sequences and then used to train a two MM, one going forward with the sentence, and one going backwards.
16:23:42 * Igloo dislikes WASH's "do everything from teh beginning of the session" style, and the sending of data back and forth
16:23:59 <Lemmih> FrederikEaton: I think it's fundamentally flawed.
16:24:03 <wilx> How long is it GPL'd?
16:24:06 <wilx> The Q3A code?
16:24:30 <Korollary> wilx: a few days now
16:24:34 <lispy_> FrederikEaton: to generate a response, the bot would pick words at random from the input, then try to construct a sentence forward and backward using the MMs
16:25:19 <lispy_> FrederikEaton: currently, i have a wrapper in lisp written around the C version of megahal, but it has a lot of limitations
16:26:33 <wilx> Hmm, the code looks very Cish.
16:26:51 <FrederikEaton> Lemmih: you're fundamentally biased :)
16:27:03 <FrederikEaton> Lemmih: j/k. how is it flawed?
16:27:58 <lispy_> $ find . | grep \.[ch]$ | xargs cat 2>/dev/null | wc -l
16:27:58 <lispy_>   834922
16:28:00 <Igloo> FrederikEaton: Are you affiliated with WASH at all?
16:28:02 <FrederikEaton> lispy_: my advice: AI is boring pseudo-science. machine learning has some really interesting research going on. i just looked at megahal and it seemed uninteresting
16:28:29 <FrederikEaton> Igloo: i'm planning to release an alternate version, but i want to see if people would use it
16:28:38 <lispy_> FrederikEaton: i'm not doing it for research, I just like having a random chatter bot around
16:28:40 <Igloo> "alternate" in what way?
16:28:49 <lispy_> FrederikEaton: and megahal does a good job at being random :)
16:29:17 <FrederikEaton> Igloo: more usable. fewer client dependencies, while being OK with depending on more GHC extensions
16:29:32 <FrederikEaton> Igloo: i want to get rid of javascript, or at least make it optional
16:29:34 * Igloo wouldn't use it then
16:29:42 <FrederikEaton> Igloo: when?
16:29:51 <FrederikEaton> Igloo: if you had to use ghc?
16:29:52 <Igloo> Oh, yeah, requiring JS was another thing that put me off it
16:30:07 <Igloo> I wouldn't use it if it didn't fix all the things I listed earlier
16:30:26 <lispy_> i want something that does less cgi and more ajax
16:30:42 <lispy_> i hate page loads
16:31:02 <Igloo> ajax?
16:31:30 <FrederikEaton> Igloo: listed earlier?
16:31:50 <Igloo> At [00:24]
16:33:07 <lispy_> Igloo: http://en.wikipedia.org/wiki/AJAX
16:33:27 <lispy_> Igloo: gmail and google maps use it to feel more like a local application than a web "app"
16:34:08 * Igloo dislikes AJAX if it's the only way to do things
16:34:32 <FrederikEaton> Igloo: which of the improvements I mentioned didn't you like? i can't see 00:24
16:37:12 <lispy_> Igloo: mostly it's been shown to give a nice result.
16:37:41 <lispy_> Igloo: if there was something based in haskell that did the same thing and worked in most browsers that would be wonderful
16:37:43 <Igloo> lispy_: Not if you don't support the necessary feature
16:38:02 <lispy_> the necessary feature?
16:38:17 <Igloo> e.g. JS
16:38:20 <FrederikEaton> Igloo: hello?
16:38:51 <lispy_> Igloo: lots of browsers support JS, so i'm not sure what you're getting at
16:40:46 <Igloo> [00:24] * -> Igloo dislikes WASH's "do everything from teh beginning of the
16:40:46 <Igloo>           session" style, and the sending of data back and forth
16:42:30 <FrederikEaton> oh, wrong timezone
16:43:29 <FrederikEaton> sorry. what is this "do everything from the beginning of the session style"? are you concerned about efficiency?
16:44:19 <FrederikEaton> i want to know more about the psychology of forking software projects. like, will Peter T. be annoyed? maybe i should do it just to find out
16:44:38 <FrederikEaton> *shrug* i've certainly been annoyed by his unresponsiveness
16:48:10 <Philippa> it's unlikely to be annoying unless you go with an aggressive "original branch sucks, mine rocks!" style of promotion
16:48:22 <Korollary> lol
16:51:37 <FrederikEaton> ok
16:51:41 <FrederikEaton> i'll keep that in mind
16:51:49 <wnoise> I don't suppose anyone has any handy code for dealing with finite fields?
16:52:23 <FrederikEaton> hi wnoise
16:52:39 <FrederikEaton> i hear there's a good 'Bool' library in the Prelude
16:53:01 <FrederikEaton> you can add them with /=
16:53:15 <wnoise> Hello Fred.  I mean generally, for all p^n.
16:53:23 <FrederikEaton> ohhhhhhhhh
16:53:36 <wnoise> And now I'm thinking of doing bad type-arithmetic again.
16:53:53 <FrederikEaton> are you using Implicit Parameters?
16:53:58 <FrederikEaton> is anybody using Implicit Parameters?
16:54:22 <wnoise> No.  Actually, I could get away with only p for this application, and that wouldn't be too bad.
16:55:48 <FrederikEaton> i was actually curious about the IP stuff, i'm thinking of using it for something
16:57:15 <wnoise> I mostly don't see the point, what problem it's trying to solve.
16:59:14 <FrederikEaton> you need to propagate a value invisibly, you can do that with types, so you stick your value in a type
16:59:22 <FrederikEaton> but it's very hacky
17:06:16 <wnoise> I thought it was just a weird lexical scoping thing.
17:06:29 <wnoise> Er, dynamic.
17:08:10 * xerox is teaching Haskell to a friend
17:11:20 <FrederikEaton> wnoise: it's dynamic-ish, but it's type-based. it's like implicit parameters.
17:12:05 <wnoise> Oh, I thought you were asking about implicit parameters.  Actually, I'm terribly confused as to what you are talking about.
17:14:07 <lispy_> http://graphics.cs.uni-sb.de/~sidapohl/egoshooter/
17:14:20 <lispy_> it's a raytraced version of q3, it was released some time ago
17:19:33 <FrederikEaton> wnoise: oops. i meant Implicit Configurations
17:19:42 <FrederikEaton> wnoise: the first time. SORRY
17:20:25 <FrederikEaton> wnoise: it's the senility
17:25:06 <Defiler> Is there a "big book of crazy math notation" I can buy?  I keep running into concepts that are easy to understand once I spend hours looking up all the crazy symbols and notation.
17:25:43 <liyang> I'm using implicit parameters, where I previously had a State monad. (I didn't need all the things State provides...) I'd lost the first version due to my laptop being stolen, and decided to just use IP in the rewrite. It's produced much readable code...
17:25:48 <liyang> *much more
17:25:58 <Defiler> I had to spend a while on Google to figure out that arrows were the same as function application, and the CTM book I'm reading right now is fond of introduction lowercase greek letters I don't know the meaning of.
17:26:15 <Cale> Defiler: Usually Planetmath and Mathworld are sufficent, but depending on where you are in your journey into math, they might be just as confusing as what you're trying to read
17:26:23 <Cale> also, wikipedia is good
17:27:32 <liyang> I don't think there's any completely consistent body of notation. It all depends on what you're looking at.
17:27:50 <Cale> yeah, notation in math is very dependent on context
17:27:50 <Defiler> How do I search Wikipedia for "lowercase sigma"?
17:28:01 <Cale> searching for \sigma should work
17:28:13 <FrederikEaton> liyang: not implicit configurations? :)
17:28:14 <Defiler> Oh, hey.. you can just paste it in. Durh.
17:28:23 <Cale> It's uncommon to study category theory before studying group theory, ring theory, and perhaps some other subjects like algebraic topology and geometry
17:28:30 <Cale> well, it used to be
17:28:43 <liyang> FrederikEaton: I'm not sure what you're talking about here... :-/
17:28:58 <Cale> so there's a certain amount of context which some sources are going to assume, even if the material doesn't rely on any of that stuff
17:29:07 <Defiler> Cale: Assuming I wanted to master those topics, what are the prerequisites?
17:29:30 <Defiler> I left school to go make the big bucks before I got that far. Heh.
17:29:36 <Cale> Well, you could probably get started on group theory or ring theory with little trouble.
17:30:15 <Cale> Algebraic topology uses group theory, and eventually ring theory, algebraic geometry uses ring theory rather heavily.
17:31:23 <Cale> If you want a nice overview of the areas of mathematics...
17:31:42 <Cale> http://www.math-atlas.org/
17:32:33 <Defiler> I'm trying to develop an intuitive feel of functional and declarative programming, the way I currently have for OO, procedural, etc..
17:32:57 <Defiler> Am I wasting my time with the mathematics behind it, or is that a reasonable thing for me to study, as a non-mathematician?
17:33:11 <Cale> you can certainly do that without having a mathematical background, but mathematics can help
17:33:31 <Defiler> Also, that looks like a very interesting link.
17:33:33 <FrederikEaton> liyang: www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
17:33:52 <Cale> I'd say if you enjoy looking into the mathematics, go for it, you'll probably learn some generally useful stuff.
17:33:55 <Philippa> What Cale said
17:34:13 <Philippa> some of the underlying maths is useful for analysing code anyway
17:35:12 <Cale> just learning mathematics, and reading/producing proofs is a good way to learn to pick abstract structures apart and to put them together in various ways.
17:35:19 <Defiler> I love beautiful math, I just tend to have difficulty finding a good starting point for a particular topic. I need to find a "1,2,3 - Infinity" book for CS math.
17:35:38 <Pseudonym> The world needs a book on category theory that DOESN'T assume a graduate-level topology course first.
17:35:50 <Pseudonym> And one that's more in-depth than "Conceptual Mathematics"
17:36:05 <Pseudonym> Excellent though that book is, it doesn't go very far.
17:36:09 <Defiler> This is where Amazon has led me, re: group theory.  Anyone familiar with this book?
17:36:12 <Defiler> http://www.amazon.com/exec/obidos/tg/detail/-/0486421821
17:37:37 <Defiler> How much do I need to know/remember about linear algebra to read a book along those lines, as well?
17:42:46 <Cale> I'm not familiar with that book... I used "Contemporary Abstract Algebra" by Gallian
17:44:41 <Defiler> Lots of good reviews for that one. I'll pick it up.  Thanks.
17:55:59 <mwc> Defiler, for what it's worth, we're using http://www.amazon.com/exec/obidos/tg/detail/-/0130882542/qid=1124672197/sr=8-1/ref=pd_bbs_1/002-0956080-3094452?v=glance&s=books&n=507846 in my applied math course on group theory
17:56:13 <mwc> it might be a little more application orientated
17:56:53 <mwc> than a book meant for pure mathematics student
17:59:42 <Defiler> Cool. I just had a little accident and bought more books than I was intending to. Heh.
18:01:32 <mwc> yeah, I usually do that too\
18:01:38 <mwc> how many extra $100 did you spend?
18:01:59 <Defiler> About five. Heh.
18:02:21 <xerox> Goodnight mathematicaskellers!
18:02:29 <mwc> Yeah, Amazon exists to suck my wallet dry
18:02:34 <bourbaki> :)
18:02:50 <bourbaki> dont you have a library?
18:03:26 <mwc> yeah, but I prefer to own
18:03:38 <mwc> since books turn into perpetual references
18:03:48 <Defiler> I don't have access to any of the university libraries around here, sadly.
18:03:53 <bourbaki> thats right
18:03:58 <Korollary> mwc: you may wanna try http://www.allbookstores.com/ then
18:04:02 <bourbaki> but you can browse them beforehand
18:04:09 <mwc> Korollary, canadan prices?
18:04:15 <mwc> Or even canadian retailres?
18:04:17 <Korollary> mwc: some canadian, yes
18:04:33 <Korollary> it even fetches amazon.co.uk, etc. iirc
18:05:59 <Korollary> mwc: also try http://www.abebooks.com/ They ship the international editions from Hong Kong, India, etc. It sometimes beats the north american prices.
18:07:09 <mwc> Yeah, I got my CRLS Introduction to ALgorithms book from there
18:07:50 <liyang> FrederikEaton: interesting... thanks for the link. I've flicked through the paper and will go through it in more detail later...
18:08:32 <Korollary> @yow
18:08:33 <lambdabot> I'm DESPONDENT ... I hope there's something DEEP-FRIED under
18:08:33 <lambdabot> this
18:08:33 <lambdabot> miniature DOMED STADIUM ...
18:08:59 <Korollary> line breaks hurt
18:09:06 <FrederikEaton> liyang:  it's hacky, as i said
18:11:24 <lispy_> re: q3a source; it surprises me, but they use udp instead of tcp
18:12:16 <Korollary> lispy_: reliability is less important than cost of overhead
18:12:26 <lispy_> if ((newsocket = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
18:12:42 <lispy_> Korollary: tcp has a lot of overhead?
18:13:39 <liyang> With TCP if a packet is dropped it'll go for a resend, which introduces lots of lag.
18:14:01 <Korollary> lispy_: it's the textbook case of udp vs tcp. if the packet doesn't make it in 50ms, it loses its meaning.
18:14:07 <liyang> Which you don't want in an interactive game. Much better to handle it on the application level instead.
18:14:30 <lispy_> but wouldn't they have to reproduce their own sequencing?  i guess if they do that they can just ignore dropped packets and force that the sequence numbers increase
18:14:31 <liyang> (Korollary put it much better than I have.)
18:15:38 <Korollary> this method is also responsible for not being able to get accurate ping times from within the game, too.
18:16:54 <Korollary> on a given server, pretty much everybody pings either 48 or 90 or something. The server just doesn't know enough.
18:17:50 <lispy_> oh, i never realized that
18:18:12 <lispy_> i was curious how they do socketry because i'm trying to write a concurrent server is haskell and having a hell of a time
18:18:36 <lispy_> the latest problem i noticed is absurd memory usage
18:18:55 <lispy_> but it also randomly becomes unresponsive
18:19:08 <lispy_> despite using non-blocking io
18:19:24 <Korollary> doesn't SimonPJ have a paper on that sort of thing ?
18:19:52 <lispy_> not sure who it's by, but i found a paper about writing a web server in concurrent haskell
18:20:18 <lispy_> but the difference between our implementations is that in their webserver, the threads didn't need to communicate
18:20:41 <lispy_> i should probably look at their implementation again
18:20:52 <lispy_> i try to avoid having thread <--> thread communication too
18:20:58 <Korollary> how many projects do you have concurrently ?
18:21:01 <lispy_> i try to have thread <-> server
18:21:09 <lispy_> uh....
18:21:16 <lispy_> a new one each day
18:21:19 <Korollary> heh
18:21:20 <lispy_> duh ! ;)
18:21:53 <lispy_> this is why i never finish anything
18:22:09 <lispy_> i start stuff, couple days later i want to hack on something else for a while
18:22:30 <lispy_> nothing wrong with the previous project, i just get an urge to hack on something else for a bit
18:23:23 <lispy_> 365 projects a year, 10 years per decade, here at Lispy is on crack we start projects
18:23:56 <lispy_> "Need a project started?  Don't care if it finishes?   Need ideas?  Call lispy_"
18:24:25 * lispy_ writes a crontab for creating new darcs repos
18:24:27 <Korollary> well, I am the opposite. I start something maybe once a month. But I finish it.
18:24:51 <shapr> lispy_: I get the same thing. The solution is to make sure you never stop a day of hacking without pushing new changes to your darcs repo.
18:25:11 <shapr> Then when you get bored, someone else can benefit from it. That someone else might even be you a year from now.
18:25:14 <lispy_> shapr: indeed, i'm trying very hard to do that starting this summer
18:25:25 <lispy_> haha, good point of view
18:26:32 <lispy_> i believe it was linus that said real men don't backup their files, they upload them to ftp for the whole world to see.
18:27:07 <lispy_> that's why http://www.codersbase.com/Projects keeps growing :)
18:27:17 <lispy_> oh, i should add hud
18:28:25 <shapr> Yeah, I like that approach.
18:29:15 <lispy_> @where+ lispyprojects http://www.codersbase.com/Projects
18:29:16 <lambdabot> lispyprojects ~> http://www.codersbase.com/Projects
18:29:26 <lispy_> save myself typing later :)
18:30:17 <dons> morning!
18:32:24 <lispy_> dons: morning
18:32:30 <Korollary> isn't it noon .au ?
18:32:34 <Korollary> @timein sydney
18:32:36 <lambdabot>  Monday, August 22, 2005 at 11:33:39 AM EST
18:33:28 <dons> oh, hmm. late. must have slept in
18:33:34 <Korollary> dons: I wrote the permutation generator in ocaml. It beats haskell, but doesn't beat C.
18:33:50 * Korollary notices that he's obsessed with it
18:33:59 <dons> hehehe
18:35:02 <dons> tuomov, try latest hs-plugins. the export list is explicit now.
18:35:13 <Korollary> I think I can use ocaml as "C with garbage collection and array bound checking" as its syntax allows imperative style.
18:37:26 <lispy_> shapr: the other part of this sharing everyday thing is that i should develop a better coding style w.r.t commenting.  I got good at that in lisp, but for some reason i don't document my haskell.
18:37:50 <lispy_> and i meant to start using haddock
18:38:06 <lispy_> i wish haddock provided a bit better navigation
18:38:12 <lispy_> but i'm not sure what to improve
18:38:49 <lispy_> i guess, a search box would help.  And a way to navigate relative to the library structure (go up and down modules without needed to load the contents)
18:38:54 <lispy_> (the contents page that is)
18:38:58 <shapr> Yeah, that would be nice.
18:39:13 <shapr> Maybe a few useful navigation javascripts would help?
18:39:32 <shapr> I do wish there were some format that mixed LaTeX output and web output.
18:39:43 * lispy_ dreads leaning js, but it will have to happen at some point, even if it's just to write a code generator
18:40:04 <shapr> Javascript is pretty simple. The only interesting part is the prototype stuff.
18:40:22 <lispy_> we need a haskell DOM which is really an embedded DSL that generates the appropriate js
18:41:32 <shapr> musasabi has some javascript generation in PArrows I think.
18:42:14 <lispy_> oh, my q3 data has almost transfered from my home network
18:42:16 * lispy_ hops
18:42:46 <shapr> Did you find a total conversion that has enough data to play?
18:43:22 <Korollary> urban terror is a total conversion, iirc
18:46:22 <skylan> Yah, UT is a TC.
18:46:23 <lispy_> shapr: i had a copy of quake at home, it just took forever to transfer it to where i'm staying this summer
18:46:32 <shapr> Ah, ok.
18:46:51 <lispy_> now i'm trying to convince my mac that it can read the iso
18:48:10 <lispy_> i don't have any cds or i'd just burn it
18:51:19 <lispy_> hmm....doesn't seem to be vaild
18:51:47 <Korollary> would "mount -o loop -t iso9660 q3a.iso /mnt/iso" work on osx ?
18:54:23 <lispy_> it's not working on my linux box
18:54:29 <lispy_> i suspect my iso isn't really an iso
18:54:30 <lispy_> hmm...
18:56:31 <ehuber> lispy_:
18:56:33 <ehuber> what do you need
18:56:56 <lispy_> ehuber: i wanted to play with the q3 source code, but i don't have any data to load
18:57:20 <lispy_> ehuber: so i was trying a copy of q3 that i had sitting around, but the bits don't seem to be valid iso
18:57:20 <ehuber> ah i see.. well
18:57:43 <ehuber> i have the data here on my mac.. if you want i could maybe somehow get the paks to you
18:57:51 <ehuber> since you seem to have owned it already
18:58:43 <ehuber> UT is a very good game btw.. :p
18:58:49 <lispy_> it is indeed
18:58:56 <lispy_> but have they gpl'd the source?
18:59:15 <ehuber> afaik, no
18:59:22 <ehuber> i believe they wanted to actually sell the game
18:59:25 <ehuber> as with cs
18:59:33 <lispy_> oh, wait
18:59:43 <lispy_> when you said UT i thought you meant unreal tournament
19:00:03 <ehuber> no, i mean urban terror
19:00:09 <ehuber> (which i believe was the topic ?)
19:01:19 <ehuber> anyhow, if you setup an ssh server... email me at ehuber@cmu.edu with your ip, user/pass, and ill scp the stuff to you either later tonight or in the morning
19:01:23 <ehuber> im going to watch a movie
19:01:49 <lispy_> ehuber: ah, it's cool, i'll figure something out or lose interest :)
19:02:05 * Korollary 's money is on "lose interest" ;)
19:02:25 <lispy_> hehe
19:02:30 <lispy_> i was going to try the demo data actually
19:04:14 <lispy_> Korollary: but yeah, tomorrow i'll have a new passion/project
19:04:20 <lispy_> you can count on it
19:04:57 <lispy_> my haskell concurrent server was killed by the linux OOM killer
19:05:30 <lispy_> i should probably go to the store and get some food....someone hold me place
19:05:34 * lispy_ disappears
19:06:54 * rt twiddles his thumbs.
19:07:13 * rt suddenly remembers that he was going to work on his delaunay triangulation code.
19:07:37 <lispy_> rt: what is that?
19:07:42 * lispy_ reappears
19:09:04 <rt> The Delaunay triangulation of a point set is a collection of edges satisfying an "empty circle" property: for each edge we can find a circle containing the edge's endpoints but not containing any other points.
19:09:27 <lispy_> ah,cool
19:09:39 * lispy_ disappears again
19:09:42 <rt> it's useful as a means of dividing up space.
19:10:04 * lispy_ reappears
19:10:07 <lispy_> i can imagine
19:10:19 <lispy_> i bet you can also use it from some neat visual effects
19:10:23 * lispy_ disappears *again*
19:10:34 * lispy_ notes that it may even be for real this time
20:04:32 <lispy_> and one one said _anything_ while i was gone
20:04:37 <lispy_> that's amazing :)
20:05:37 <Korollary> actually we did. You must have lagged out.
20:06:42 * Korollary is done lying
20:08:27 <lispy_> Korollary: hi
20:08:38 <lispy_> Korollary: i think i lagged out, did yousay something? ;)
20:08:43 <Korollary> heh
20:09:48 <lispy_> with q3 in the open, this means new possibilities for mst
20:10:41 <Korollary> mst ?
20:10:42 <lispy_> uhm...q3 demo uses mac classic?
20:11:05 <lispy_> mst is an idea i have, stands for machinima sharing tool
20:11:12 <lispy_> http://www.codersbase.com/mst
20:12:27 <lispy_> i don't have support for mac classic....hmmm....
20:12:34 <lispy_> i wonder if i uninstalled it
20:13:48 <mwc> lispy_, wait 20 minutes, and somebody will have Carbonized it
20:13:57 <mwc> I'm pretty sure that Quake III Arena si already carbonized though
20:14:23 <lispy_> mwc: the installer for the demo from id's site wants classic tho
20:14:37 <mwc> Wow, how quaint
20:14:43 <lispy_> i just want enough content that i can start playing with the engine :)
20:15:37 <mwc> Saw Red Eye tonight
20:15:38 <lispy_> i guess there is always bittorrent :)
20:15:43 <mwc> hugely different movie than I expected
20:15:56 <lispy_> what's it about?  i haven't heard of it
20:16:00 <mwc> given the red eye on Cillian Murphy in the preview, and the Wes Craven name
20:16:17 <mwc> I thought he was some sort of demon or something
20:16:33 <mwc> turns out he's a terrorist trying to extort something from the woman on the plane
20:16:50 <lispy_> ah
20:16:54 <mwc> as I said, HUGELY different movie thatn I expected, but it was quite good
20:17:42 <Korollary> I expected precisely that from the trailer I saw
20:18:03 <mwc> Really? the one with a the dude with the red eye?
20:18:08 <Korollary> good to hear it turned out well
20:18:20 <mwc> and the Wes Craven name? must have seen a diff't trailer
20:19:02 <Korollary> I wonder how Constant Gardener will turn out
20:19:55 <lispy_> i don't like scary movies, so i'll put that on the list of things for my gf to watch when i'm not home
20:20:53 <mwc> lispy_, my gf hates scary movies, that's why I try to take her to as many as possible
20:21:14 <lispy_> heh
20:21:16 <mwc> then again, I suppose it might not work for you to be jumping into her arms at the first scary scene
20:22:12 * lispy_ installs classic support
20:22:13 <mwc> lispy_, anyways, it's about as scary as diehard
20:22:28 <lispy_> ah
20:23:12 <lispy_> you're not going to nmap me next are you? ;)
20:24:08 <mwc> just wondered what client you used for OS X, still looking for a good one (besides irssi and xchat which don't integrate as nicely as I'd like)
20:27:40 <lispy_> no, xchat is pretty bad.
20:27:55 <lispy_> but it's just a smidge better than the colloquy
20:28:08 <lispy_> i don't remember what colloquy did now that upset me so much...
20:28:11 <mwc> Xchat-Aqua is a disaster
20:28:19 <mwc> I can't stand it using drawers
20:28:25 <mwc> drawers drive me up the freakin wall
20:29:08 <Korollary> lispy_: how about an irc client in haskell as your next project ? ;)
20:29:44 * lispy_ considers it
20:29:54 <mwc> HIrcules!
20:30:17 <lispy_> Korollary: but there is some software i use that is better left to others ;)
20:30:45 <lispy_> how i have to convince q3 to read the demo data
20:34:10 <lispy_> Can't load default.cfg
20:34:14 <lispy_> hmm...
20:39:14 <lispy_> wow, that totally messed up xchat
21:36:04 <lispy> well, setting certain breakpoints means disaster :)
21:59:07 <musasabi> morning
22:00:47 <lispy> morning
22:00:52 <lispy> not really
22:00:57 <lispy> but close enough :)
22:07:26 <erommer> how can i get the nth digit from an int e.g. 10000, 5th digit = 0
22:08:30 <lispy> @pl \x n -> take n $ show x
22:08:31 <lambdabot> flip take . show
22:08:41 <lispy> erommer: use flip take . show :)
22:08:58 <lispy> @pl \n x -> take n $ show x
22:09:00 <lambdabot> (. show) . take
22:09:07 <lispy> that one is probably better
22:09:32 <lispy> @eval ((. show) . take) 4 10000
22:09:35 <lambdabot> "1000"
22:09:39 <lispy> oops
22:09:41 <lispy> not quit right
22:09:53 <lispy> @pl \n x ->   (show x) ! n
22:09:55 <lambdabot> flip ((!) . show)
22:10:15 <lispy> @eval (flip ((!) . show)) 4 10000
22:10:16 <lambdabot> 25: Not in scope: `!'
22:12:20 <Korollary> why not use division like normal people
22:15:24 <lispy> Korollary: the thing with using show, (!) is that it's quick and easy to implement, doesn't require any math knowledge
22:18:53 <erommer> dw i got this working -> digitAt x y = x `div` 10^y `mod` 10
22:19:22 <TheHunter> @eval digitToInt $ show 10000 !! (5 - 1)
22:19:23 <lambdabot> 0
22:20:20 <erommer> how can i get the number of digits in an int e.g: 9876 = 4 digits
22:20:37 <musasabi> length . show
22:20:42 <lispy> @pl \n -> length (show n)
22:20:43 <lambdabot> length . show
22:20:49 <lispy> oh, duh
22:21:20 <lispy> @eval (flip ((!!) . show)) 4 10000
22:21:22 <lambdabot> '0'
22:21:35 <lispy> @eval read ((flip ((!!) . show)) 4 10000) :: Int
22:21:36 <lambdabot> Couldn't match `String' against `Char'
22:21:44 <lispy> @eval (read ((flip ((!!) . show)) 4 10000)) :: Int
22:21:45 <lambdabot> Couldn't match `String' against `Char'
22:21:58 <lispy> @eval (read [((flip ((!!) . show)) 4 10000)]) :: Int
22:22:00 <lambdabot> 0
22:22:19 <TheHunter> @pl (read [((flip ((!!) . show)) 4 10000)])
22:22:20 <lambdabot> read [show 10000 !! 4]
22:22:43 <TheHunter> @pl \4 10000 -> (read [((flip ((!!) . show)) 4 10000)])
22:22:44 <lambdabot> (read .) . flip flip [] . ((:) .) . flip ((!!) . show)
22:23:09 <TheHunter> wtf?
22:23:18 <lispy> hehe
22:23:31 <TheHunter> ah, the good old flip flip thing.
22:23:39 <lispy> flip flip []
22:23:44 <TheHunter> @type flip flip []
22:23:46 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
22:24:06 <TheHunter> so it's not a type error.
22:24:35 <TheHunter> still need to investigate why it didn't transform that to return.
22:25:10 <TheHunter> @pl flip flip [] . ((:) .)
22:25:12 <lambdabot> flip flip [] . ((:) .)
22:25:21 <TheHunter> @pl flip flip [] . ((:) .) $ x
22:25:22 <lambdabot> return . x
22:25:29 <TheHunter> @pl \x -> return . x
22:25:30 <lambdabot> (return .)
22:26:05 <lispy> @type (read .) . return . flip ((!!) . show)
22:26:06 <lambdabot> bzzt
22:26:32 <lispy> @type (read .) . return . (flip ((!!) . show))
22:26:33 <lambdabot> bzzt
22:26:36 <lispy> hmm...
22:26:42 <TheHunter> @type (read .) . (return .) . flip ((!!) . show)
22:26:44 <lambdabot> forall a a1. (Read a, Show a1) => Int -> a1 -> a
22:26:51 <lispy> ah, that was my next guess
22:27:36 <lispy> @pl \n x -> ((read . ) . (return .) . flip ((!!) . show)) n x
22:27:37 <lambdabot> ((read . return) .) . flip ((!!) . show)
22:30:17 <erommer> whats the function declaration line if i have 2 ints as arguments to the function and want to return an int
22:30:30 <musasabi> foo :: Int -> Int -> Int
22:30:52 <erommer> how is (Int -> Int) -> Int different to that?
22:32:17 <musasabi> Very.
22:32:32 <erommer> whats the diffs
22:32:40 <musasabi> (Int -> Int) -> Int takes a function from Int to Int as an argument and returns an Int.
22:32:47 <erommer> oh ok
22:33:03 <musasabi> Int -> (Int -> Int) == Int -> Int -> Int
22:33:20 <lispy> but you could have (Int, Int) -> Int
22:33:28 <lispy> @type uncurry
22:33:30 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
22:34:02 <lispy> you can use curry/uncurry to change between (Int, Int) -> Int, and Int -> Int -> Int
22:34:27 <musasabi> Of course, but using tuples for multiple arguments is not very much Haskell style.
22:34:57 <metaperl> int -> Int -> Int == Int -> (Int -> Int) according to SJT
22:35:01 <metaperl> function applicaiton is right association, type definitions are left associative
22:41:53 <erommer> how can i get the numbers of digits in an int?
22:42:05 <musasabi> erommer: length . show
22:42:46 <musasabi> @eval length (show 23547)
22:42:47 <lambdabot> 5
22:43:17 <erommer> ok
23:19:39 * shapr yawns
23:22:38 <Pseudonym> Yeah, it's a bit like that.
23:22:45 * dblhelix smiles: thank god that annoying weekend is over, finally... now, let's work, work, work... ;) (or did I just loose my credibility?)
23:22:46 <lispy> but only a bit
23:22:50 <Pseudonym> Only a bit, yes.,
23:22:54 * Pseudonym yawns a bit
23:23:04 <lispy> dblhelix: your credibility with my is shot :)
23:23:15 * lispy tries to understand q3
23:23:56 <lispy> the only part that seems to build on osx is the engine itself, which if i understand correctly is only 1/3 of what you need to develop levels
23:24:33 <lispy> it would appear you need lcc to compile to the quake virtual machine, and you need a level editor like radiant
23:24:55 <lispy> they package both, but i don't think they compile
23:31:17 <Itkovian> pompom did someone just mention q3 on osx?
23:34:27 <lispy> yes
23:35:18 <lispy> Itkovian: q3 builds, and if you have a proper .pk3 file it will even run
23:35:27 <Itkovian> nice
23:35:30 <lispy> but, i was curious about making a .pk3 file
23:35:39 <Itkovian> Of course I have proper .pk3 files, I bought the game ;-)
23:35:53 <Korollary> a pk3 file is a zipfile renamed
23:36:04 <lispy> if you want a darcsable copy: http://www.codersbase.com/quake3
23:37:02 <lispy> there's an xcode project file in there
23:37:14 <lispy> i've only made one modification so far
23:37:25 <lispy> and that was to disable checking for valid product key
23:38:26 <lispy> Korollary: right, but whats in them matters greatly
23:38:47 <lispy> Korollary: part of what quake does is runs quakeC
23:38:57 <lispy> or maybe it's ansi C at this point
23:39:13 <lispy> either way, i can't get the compiler to compile :)
23:39:48 <Korollary> there used to be some sites for mod makers. They should explain what needs to be in.
23:40:33 <lispy> Korollary: you mean like this: http://www.planetquake.com/code3arena/articles/article4.shtml
23:40:56 <Korollary> yep
23:54:58 * boegel greets everyone in #haskell
23:55:16 <dblhelix> hi boegel! had a nice weekend?
23:55:44 <boegel> dblhelix: busy weekend, helping with small local athletics meetings
23:56:02 <boegel> dblhelix: but nice yes
23:56:14 <dblhelix> glad to hear :)
23:57:08 <boegel> dblhelix: yours ?
23:57:36 <dblhelix> played some football, drunk a few beers... yes, nice
23:57:46 <boegel> a few beers or quite a lot ? :)
23:57:59 <boegel> oh yeah, I had a party too, almost forgot :D
23:58:04 <dblhelix> no, a few, actually ;)
23:58:17 <boegel> playing trivial pursuit until 2am
23:58:43 * boegel saw a nice appartment when he was heading for work
