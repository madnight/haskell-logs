00:28:35 <Itkovian> meuning
00:29:38 <Beelsebob> mornin
00:32:58 <boegel> hello Itkovian ^_^
00:33:09 <Itkovian> hmm
00:42:11 <Beelsebob> bah... mornings are not my thing
00:43:20 <Itkovian> Beelsebob: it all depends on what you have to do during them. I can think of a few enjoyable things
00:43:38 <boegel> Itkovian: like sleeping :D
00:43:48 <Beelsebob> so can I, but getting up at 8:20 to finish the packing is not one of them
00:43:56 <Itkovian> erm, no I was more thinking about stuff that involves a female
00:44:15 <Beelsebob> yeh, that is indeed most fun in the morninf
00:44:19 * dblhelix usually gets up at 5:15am
00:44:24 <Itkovian> you are sick
00:44:25 <Beelsebob> :o
00:44:32 * Beelsebob faints
00:44:32 <Itkovian> did they tell you that?
00:44:48 <Itkovian> ;-)
00:44:53 <boegel> Itkovian: sleeping next to your gf ?
00:45:01 <dblhelix> it's not that bad actually, once you're used to it
00:45:02 <Itkovian> that comes third ...
00:45:05 <boegel> dblhelix: omg :) do you suffer from insomnia or something ?
00:45:13 <Itkovian> a good breakfast in bed can also be immensely enjoyed
00:45:31 <boegel> Itkovian: yeah, with fresh orange juice, hmmmmmmmmmmmmmmmmmmmmmmm
00:45:32 <Itkovian> especially when strawberries are served :-)
00:45:49 <Itkovian> mmm strawberries in the morning
00:45:56 <dblhelix> boegel: no, but I like to start early at work: I'm usually more productive in the morning
00:46:01 <boegel> only drawback is a bad breath :)
00:46:03 <Beelsebob> itkovian: I can't do food in the morning
00:46:11 <Beelsebob> makes you chuck
00:46:14 <Itkovian> dblhelix: see, you are taking a completely wrong attitude about this ...
00:46:23 <Beelsebob> boegel~ from orange juice?????
00:46:24 <boegel> dblhelix: I'm more productive in the evening, because that's when I realize I haven't done shit all day
00:46:30 <Itkovian> lol
00:46:30 <boegel> Beelsebob: no, from sleeping :)
00:46:31 <Itkovian> same here
00:46:32 <dblhelix> Itkovian: :) just try it for a while...
00:46:43 <Itkovian> no can do ...
00:46:46 <tuomov> can't do a thing in the morning
00:46:47 <Beelsebob> boegel: yup, same here
00:46:53 <tuomov> just waiting for lunchtime
00:46:55 <boegel> dblhelix: no f*cking way
00:46:55 <Beelsebob> I'm most productive on a tuesday evening
00:47:07 <Beelsebob> ... because my supervisor meeting is the next morning
00:47:15 <Itkovian> well, as women like sex best on Monday evening you should be fine Beelsebob
00:47:21 <boegel> dblhelix: I'm having trouble getting up at 7am already, not to mention 5am :s
00:47:32 <boegel> Itkovian: they do ? :)
00:47:35 <Itkovian> boegel: wait till you have kids ;-)
00:47:36 <Beelsebob> itkovian: ??????
00:47:41 <Beelsebob> hahahaha
00:47:43 <Itkovian> boegel: some US study said so
00:47:59 <boegel> Itkovian: I'd think on Sunay morning, when the kids are watching Samson :)
00:48:10 <Itkovian> because they are rested from the weekend and don't have yet incurred a lot fo weekly stress
00:48:14 <dblhelix> I just read about_ some_ US president promoting ID...
00:48:18 <Beelsebob> oddness, all the lasses I've ever been out with it was weekend mornings that were most popular
00:48:31 <Itkovian> Beelsebob: because you didn't see them during the week?
00:49:11 <Beelsebob> itkovian: no... just... weekend day, yay, lets shag
00:49:26 <Beelsebob> ... or perhaps something a little more subtle than that, but hey
00:51:08 <Itkovian> subtle is better imo
00:52:09 <Beelsebob> depends if you're going for subtle shagging, or rampant shagging with three extra people a 6ft dildo and some handcufs
00:52:40 <boegel> Beelsebob: heh
00:52:51 <Spark> a riding crop, a digital camera, 4 litres of engine oil, and a wrench
00:53:05 <Beelsebob> lol
00:53:07 <boegel> sick people
00:53:08 <Itkovian> omg
00:53:29 * Beelsebob doesn't want to know what spark does with a digital camera *g*
00:53:35 <Itkovian> all on a Sunday morning?
00:53:47 <Spark> heh
00:53:57 <Beelsebob> yes... I'm very religious
00:53:59 <Beelsebob> ~P
00:54:00 <Spark> one of my friends says that vanilla sex is like going to the same movie 10 times with different people
00:54:01 <Beelsebob> :P
00:54:17 <Itkovian> hmm
00:54:20 <lightstep> Beelsebob, 6tf?
00:54:25 <lightstep> 6ft?
00:54:27 <Itkovian> no 6ft
00:54:43 <Beelsebob> lightstep: yes?
00:55:00 <Itkovian> that's 6/5 ft per person
00:55:33 <lightstep> OK, perhaps I'm too conservative.
00:55:58 <Itkovian> strange, Philippa hasn't said a word yet
00:56:11 <boegel> Philippa: sex sex sex
00:56:16 <boegel> that should wake her up
00:56:47 <dblhelix> well, I guess she's not much of a morning person either
00:56:54 <Beelsebob> I thought 6ft dildo would have woken her
00:57:00 <Itkovian> maybe she's doing what we're dreaming about eh
00:57:07 <Beelsebob> heh
00:57:07 <dblhelix> ouch
00:57:45 * Itkovian throws in a monad to get back on topic
00:58:14 <boegel> Itkovian: who says I'm dreaming about a 6ft dildo ? I sure as hell am not
00:58:15 * dblhelix was already wondering who would start on code first
00:58:42 <Beelsebob> itkovian... I'm officially on holiday
00:58:42 <Itkovian> nonono, not the dildo, the morning sex, plain sex, no toys involved
00:58:43 <tuomov> monadic IO..
00:58:49 <Beelsebob> I'm banned from talking about that
00:59:12 * lightstep wants a Scheme vs. Haskell fight
00:59:30 * Beelsebob finds matt jadud
00:59:31 <Heffalump> if you're banned from talking about code, what are you doing on #haskell?
01:00:01 <Beelsebob> heffalump: I'm banned from talking about a particular strongly typed language, and what I'm doing is going OT
01:00:09 <boegel> Heffalump: talking about 6ft dildo's, obviously
01:00:21 * Heffalump had a good Scheme vs. Haskell fight at ICFP last year. It consisted of someone pointing out I hadn't exercised my bragging rights very much yet, so I found a convenient nearby Schemer and started insulting him.
01:00:29 <dblhelix> maybe he does it the other way around: entering x-rated channels and talking about monads
01:01:09 <lightstep> Heffalump, will you win the year too?
01:01:13 <boegel> dblhelix: :D
01:01:16 <lightstep> s/the/this/
01:01:36 <Beelsebob> one of the best scheme-vs-the language I shall not mention fights I ever saw was "Matt Jadud: I'm of the opinion that restrictive and overbearing type systems are a bad thing.  Simon Thompson: I think we'd all agree with that."
01:01:49 <Beelsebob> that was it... two lines... battle fought
01:02:04 <Heffalump> lightstep: no chance (well, very little)
01:02:08 <Itkovian> Beelsebob: no wonder yo an't pack yr sleeping bag with a 6ft tall device in yr backpack
01:02:20 <Beelsebob> lol
01:02:57 <Itkovian> dblhelix: maybe it's really all about gonads eh
01:02:57 <Beelsebob> I'm nearly packed actually
01:03:06 <dblhelix> Itkovian: lol
01:03:13 <Beelsebob> just sorting out the cool box
01:03:39 <Itkovian> we don't want to know what's in there
01:03:54 <Beelsebob> ;)
01:04:12 <boegel> dry ice ? :p
01:04:38 <Beelsebob> chocolate *g*
01:04:41 * dblhelix goes back to answering e-mail and tries to forget about the contents of Beelsebob's tool box (oh, that's cool box ;))
01:05:28 <Itkovian> lol
01:05:39 <Itkovian> people start to look weird at me
01:05:45 * Itkovian wipes his grin off his face
01:06:31 * boegel leaves his desk to check out Itkovian grin
01:09:42 <Itkovian> @seen nibro
01:09:43 <lambdabot> nibro is in #haskell. I don't know when nibro last spoke.
02:11:52 * boegel whistles
02:13:35 * Lemmih considers releasing a stable HSPR.
02:16:03 * ski associates HSPR ..
02:24:09 * boegel lala's
02:27:50 <Lemmih> Yay. The 'counter' example is now working. (http://212.242.49.100/hsp/Counter)
02:28:58 <paolo> 'morning!
02:29:00 <paolo> vegai: what about the silc binding you were talking about?
02:29:09 <ski> (Lemmih : funny indentation)
02:29:35 <Lemmih> ski: How so?
02:30:14 <ski> ><HEAD
02:30:14 <ski>   ><TITLE
02:30:57 <autrijus> that's Text.Html formatting, no?
02:31:03 <Lemmih> Oh, that's because the HTML is generated automatically.
02:31:06 <ski> very possibly
02:31:19 <boegel> no way to fix that ?
02:31:21 <autrijus> Lemmih: link to src?
02:31:39 <Lemmih> autrijus: http://212.242.49.100/hsp/Browse
02:33:16 <Lemmih> HSP uses its own renderer.
02:35:28 <Lemmih> boegel: Is it broken?
02:35:53 <boegel> no, I mean the output
02:36:21 <Lemmih> Is the output broken?
02:40:12 <boegel> the html code output
02:40:21 <boegel> what ski pointed out
02:41:01 <Lemmih> Is what ski pointed out broken?
02:41:23 * ski doesn't know :)
02:42:42 <Lemmih> It's valid XML and probably the only way to get a nice indentation without changing the meaning of the data.
02:46:19 <boegel> yeah, it's valid, okay, but if people will check the HTML source, they'll say 'ieeeuw'
02:47:29 <Lemmih> Why?
02:48:30 <paolo> I didn't know that tags could contain newlines.
02:58:13 <musasabi> boegel: there is no other way to indent XML safely.
02:58:50 <musasabi> It is trivial to produce a "nice" prettyprinter - the problem is that some tags are sensitive to whitespace.
02:58:58 <Fri21454> dblhelix, you know if jur is back from vacation?
02:59:21 <dblhelix> Fri21454: I expect him to return on monday
02:59:51 <paolo> musasabi: what's the difference between using < as the first character and post-process the ><-indented output?
03:02:36 <musasabi> paolo: think about "<pre>\n  <foo />\n</pre>" vs "<pre\n  ><foo /></foo\n>"
03:02:45 <Fri21454> dblhelix, ah nice. i got some nast shit going on in my worklist algorithm
03:02:50 <Fri21454> :D
03:03:09 <dblhelix> at least you get make to build it again?
03:04:50 <musasabi> (and make the last closing tag pre.
03:07:39 <Fri21454> dblhelix, yeahhh i discovered a bug in ghc that was the cause of my weird link problems
03:08:01 <dblhelix> Fri21454: yeah, I read about it on the ml
03:08:44 <Fri21454> i do have a weird thing with my makefile where it first complains that there is no rule to make a certain target...but when i do the make for a second time...it works :D
03:09:08 <lament> TheHunter: no, you're fine
03:09:21 <Fri21454> ow wait....is the order of processing of prerequisites in a rule undetermined?
03:09:26 <Fri21454> by default?
03:09:33 <Fri21454> because that could seriously be the thing
03:09:35 <lament> TheHunter: everything but ssh is closed
03:48:06 * Itkovian eats
03:57:19 <bourbaki> moin
03:57:29 <paolo> Hi!
03:57:38 <paolo> @seen dons
03:57:39 <lambdabot> dons is in #haskell. Last spoke 8 hours, 3 minutes and 59 seconds
03:57:39 <lambdabot> ago.
03:58:44 <dons> @seen me
03:58:46 <lambdabot> me has changed nick to metaperler.
03:58:46 <lambdabot> I saw metaperler leaving #perl6 and #haskell 3 months, 16 days, 11
03:58:46 <lambdabot> hours, 43 minutes and 37 seconds ago, and I have missed 10 seconds
03:58:46 <lambdabot> since then.
03:58:59 <metaperl> ?
03:59:42 <dons> lambdabot's memory gets shakey back that far
04:00:43 <paolo> :-)
04:01:19 <paolo> dons: did you happen to contact Manuel by chance?
04:02:20 <dons> i passed the message on, but no word on what the problem is. he hasn't had a chance to look yet
04:02:57 <paolo> http://haskell.org/pipermail/c2hs/2005-August/000497.html
04:03:05 <paolo> They're talking about it in the ml it seems, too.
04:04:17 <dons> ah! ok.
04:04:23 <paolo> How is the Hashell isomophism going?
04:05:51 <dons> i'm working on it. currently generating binaries for a range of List functions
04:09:17 <dblhelix> metaperl: that thing with the phone cable and the laundry did not really happen, did it? :)
04:16:24 <boegel> yo bourbaki
04:17:42 <bourbaki> hey boegel :)
04:17:55 <bourbaki> hows it going? anything new on your render projects?
04:18:10 <boegel> bourbaki: no, but I started my Phd (if you didn't know yet)
04:18:55 <bourbaki> nope i didnt whats your topic?
04:19:50 <Itkovian> wtf?! http://www.theregister.co.uk/2005/08/12/britney_birth/
04:20:07 <boegel> well, I still looking for one, but it'll probably involve statistical techniques for predicting application performance and reducing workloads
04:20:49 <dblhelix> Itkovian: is today OT day? :) just kidding...
04:21:19 <dblhelix> Itkovian: not very likely that I'll be watching that tv show
04:21:25 <boegel> Itkovian: whahahaha ! people'll do _anything_ for money
04:21:27 <Itkovian> no, but the mere thought ...
04:21:29 <Itkovian> shudder
04:21:56 <Fri21454> the mere thought of humping britney?
04:22:06 <dblhelix> lol
04:22:07 * Fri21454 quotes bassie the clown 'even aan de binnenkant van mn oogjes bekijken'
04:22:22 <dblhelix> Fri21454: allemamachies
04:22:27 <boegel> "After all, we reckon the real ratings hit would have been video evidence of the conception, complete with cervixcam to capture the explosive climax to the event." :D
04:22:44 <Fri21454> :D
04:23:36 <dblhelix> it reads that she's concerned with how she'll look like during the whole thing (Fri21454: i.e., giving birth, not the humping)
04:23:50 <Fri21454> owww
04:24:05 <Fri21454> i was wondering how she would look like during the horizontal hokey pokey
04:24:28 * dblhelix signals a recurring theme in today's conversations
04:24:53 <dblhelix> still it hasn't triggered Philippa, though
04:24:55 <Itkovian> nonono, last time we talked about atricifial devices
04:25:10 <Itkovian> hmm, ok maybe you're right after all dblhelix
04:25:44 <dblhelix> Itkovian: please do not remind me of the devices; I'm already having a hard job forgetting about them
04:26:23 <Itkovian> a hard job. right.
04:26:24 <boegel> dblhelix: 6ft ! 6FT !!1!
04:26:36 <Itkovian> that would have been 6/5 ft each
04:26:48 * dblhelix sighs
04:27:01 <Itkovian> luckily the 'r' isn't next to the 'n'
04:27:14 <Itkovian> or we might suspect a typo
04:27:23 * Fri21454 tries to parse the jibberish
04:27:47 <boegel> Fri21454: hard -> hand
04:27:52 * Itkovian recommends the logs
04:29:05 <boegel> Fri21454: do _not_ check the logs, for your own mind's ease
04:30:45 <boegel> @seen shapr
04:30:46 <lambdabot> shapr is in #haskell. Last spoke 9 hours, 3 minutes and 46 seconds
04:30:46 <lambdabot> ago.
04:30:52 * boegel pokes shapr with a stick
04:30:56 <boegel> issie dead ?
04:31:43 <Fri21454> probably watching britney
04:32:03 <Itkovian> or in deep conversation, erm, discussion with Philippa
04:32:21 <shapr> boegel: Wha?
04:32:28 <boegel> it works ! :D
04:32:43 <boegel> shapr: how's FLM going ? I need a paper organiser ! :D
04:33:41 <Itkovian> what's the harp-any thing is HSP setup?
04:33:46 <Itkovian> s/is/in/
04:33:58 <shapr> boegel: It's not done yet!
04:34:07 <boegel> sorry :$
04:34:20 <shapr> But soon
04:34:22 <Itkovian> 25 whores in the room next door .... 25 floors and I need more ...
04:34:25 <Lemmih> @google harp haskell-src-exts
04:34:25 <boegel> shapr: do you have a list features somewhere ?
04:34:27 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
04:34:38 <Lemmih> Itkovian: It's in the 'haskell-src-exts' repo.
04:34:45 <shapr> What is it? A distributed decentralized wiki-based darcs-backed research paper annotation tool called Fermat's Last Margin.
04:34:45 <Itkovian> weel, thx Lemmih
04:34:57 <shapr> How does it work? In short, wget the pdf/ps, throw it into imagemagick, create wiki pages for the resulting page images, and save text annotations into the darcs repo. If your repo is http accessible, anyone can grab your per-page annotations, and you can grab theirs.
04:35:04 <boegel> distributed ?
04:35:37 <shapr> The original goal was to allow people to share and publish their annotations.
04:35:38 <musasabi> We really need a @bugShaprForFLM in lambdabot :-)
04:36:15 <dons> or @bug $nick for $project ;)
04:36:44 <shapr> boegel: So that way, you can see what everyone on #haskell thinks about a paper, and they can see what you think too.
04:36:45 <dblhelix> cool! perhaps just @fml and then have it send him an e-mail every time the bot command is invoked
04:37:17 <boegel> shapr: oh... it's not really about organising the papers too ?
04:37:23 <shapr> Sure it is.
04:37:29 <shapr> But that's a secondary goal.
04:37:40 <boegel> oh, okay
04:37:42 <pejo> boegel, have you looked at citeulike? You can have your private notes for articles, or public notes. And keywords on articles. And you can do searches for articles that have keyword1 AND keyword2, and so on.
04:37:55 <dblhelix> dons: yeah, a parameterized @bug would be cool... it would make a good replacement for @moo
04:38:04 <dblhelix> eh ... @mow
04:38:11 <boegel> pejo: cool
04:38:18 <dons> @yow
04:38:20 <lambdabot> I wonder if I should put myself in ESCROW!!
04:38:34 <dblhelix> @vexen
04:38:36 <lambdabot> what is pron?
04:38:38 <pejo> boegel, but shaprs idea sounds interesting, I must say. :-)
04:38:48 <Itkovian> boegel: best take the tram back to the station imo
04:40:19 <shapr> boegel: So are you going to write down some of the features you'd like in paper organizer software?
04:40:20 <musasabi> What was the paper about operating system abstractions for haskell linked here in the past few days?
04:40:46 <dons> perhaps the ICFP paper?
04:41:00 <musasabi> yes, I think that one
04:41:06 <boegel> Itkovian: yeah, it's thunder and lighting all the way, and pooring like hell
04:41:13 <shapr> http://www.cs.pdx.edu/~apt/icfp05.pdf
04:41:27 <dons> was it this: A principled approach to operating system construction in Haskell
04:41:30 <boegel> shapr: basically, easliy organising my papers and searching on content/annotations
04:42:34 <shapr> FLM will do annotation searching just fine. Content searching will happen in a later version.
04:42:56 <shapr> Someone recently suggested using SVG instead of page images, that sounds like a worthwhile feature.
04:43:24 <musasabi> thanks.
04:43:30 <boegel> what's SVG ?
04:43:36 <ape> scalable vector graphics
04:44:07 <boegel> oh cool
04:46:06 <Itkovian> shapr: bibliography extraction, looking up in the own DB stuff by the same author(s), ...
04:46:21 * shapr writes this down
04:46:46 <boegel> shapr: bibtex support (as in attaching the bibtex info to the paper)
04:48:08 <Itkovian> imo the thing is there's a lot of neat stuff to do and no time to do it
04:48:28 <shapr> If FLM is open source and used by #haskell, it'll get neat features.
04:48:40 <boegel> I hope so
04:48:41 <Itkovian> true
04:48:42 <shapr> Much like lambdabot, if we each only contribute one cool feature, we'll have something really cool.
04:48:47 <boegel> I think it's a _really_ good idea
04:48:55 <Itkovian> it's a really needed thing
04:49:08 <boegel> it is
04:49:09 <Itkovian> we have a system here at work, but nobody's using it ...
04:49:16 <Itkovian> it's more of an online thingie
04:49:32 <Itkovian> which could be cool, but as it isn't used it's not much use either ...
04:50:35 <boegel> citeulike looks cool too...
04:50:58 <boegel> Itkovian: is it citeulike ? that's online too
04:51:10 * Itkovian looks up the url
04:51:27 <Itkovian> I hate Friday afternoon where I get the urge to do really much work
04:51:46 <Itkovian> http://escher.elis.ugent.be/b/
04:52:42 <Itkovian> mayhbe you could drop yr articles in there boegel, see what effect it gives.
04:53:14 <boegel> looks handy though...
04:53:23 <boegel> automatic bibtex support too, on-server
04:53:59 <boegel> Itkovian: who wrote it ?
04:54:04 <Itkovian> it's not bad, but it needs input to become usable
04:54:07 <Itkovian> Michiel
04:54:28 <Itkovian> I think a drupal like organisation would be better but still ...
04:54:43 <Itkovian> there you have nodes and can thread them etc. etc.
04:54:52 <Itkovian> we should ask Dries :-)
04:56:25 <boegel> ask away !
04:57:17 <Fri21454> dries roelvink
04:59:27 <dblhelix> Fri21454: you probably need some kind of irc filter for preventing you to directly throw your thoughts into the channel :)
04:59:41 <Fri21454> hahah
04:59:53 <Fri21454> probably the best thing would be to not go to irc
05:01:34 <boegel> yo Eileen ! err, Oejet
05:02:52 <vikasg> I wonder how you people manage to work and monitor IRC at the same time. Do you keep polling the client?
05:03:19 <Fri21454> vikasg, my compiling takes about 5 mins :)
05:03:34 <dons> we have really slow compilers
05:03:58 <Fri21454> i cant do that much else either or my pc will freeze :D
05:04:22 <vikasg> dons, I think you all have really large programs :)
05:04:35 <boegel> I need to pause every 5 seconds, otherwise I can't concentrate ;)
05:04:43 <dons> heh!
05:04:55 <Lunar^> Aha, that was what they meant when they where saying "Haskell gives you more time to think about your code"... *duck*
05:06:26 * boegel throws a shuriken at Lunar^ 
05:06:55 <pejo> vikasg, we don't work.
05:07:03 * ski wants an oh shuriken
05:07:05 <vivek> vikasg: emacs ....
05:07:42 <vivek> highlight stuff that interests you ....
05:07:48 <Fri21454> i cant believe there isnt an arrow like; Arrow a => a b c -> a (b,b) (c,c)
05:08:05 <Itkovian> ok, time to bug the bank
05:08:25 <vikasg> vivek, yeah, I tried erc, but that just mixes up my coding and irc and is not very pleasant
05:09:18 <Philippa> Fri21454: it's a specialisation of an existing one IIRC?
05:09:49 <vivek> vikasg: are you from chennai ?
05:10:13 <Fri21454> Philippa, no i think its usefull enough to have it defined...but that is the whole discussion about having a minimal set etc
05:10:14 <vikasg> vivek, no, Mysore
05:10:39 <Fri21454> nothing wrong with defining some combinators that are in terms of others
05:10:58 <Philippa> 'course not. They don't belong in the type class itself though
05:11:47 <dblhelix> Philippa: so, it's actually a arrow-related remark that triggers to join the conversation... mmm... :)
05:12:13 <dblhelix> /s/triggers to/triggers you to
05:12:17 <Philippa> dblhelix: it was just something I could answer quickly, 'sall :-)
05:12:45 <vivek> vikasg: ah ok and you are a student ?
05:12:46 <dblhelix> Philippa: we expected you to jump in this morning already
05:12:49 <Fri21454> you think, why isnt there some arrow module containing 'commonly used' combinators?
05:12:50 <Philippa> when?
05:12:53 <Itkovian> hey Philippa
05:12:55 <Philippa> (I was asleep, most likely)
05:13:10 <dblhelix> Philippa: see the logs
05:13:22 <Philippa> which bit thereof?
05:13:28 <Itkovian> from 10-11
05:13:34 <Itkovian> I think
05:13:35 <dblhelix> CET
05:13:50 <Philippa> Itkovian: which timezone? We're in BST rather than GMT here atm
05:14:31 <Philippa> ah, the stuff at 8-9am here. I was asleep :-)
05:15:03 <vikasg> vivek, I just finished 2nd year CS
05:15:08 <dblhelix> Philippa: well, that explains it
05:15:14 <CosmicRay> happy friday, everyone
05:15:25 <dblhelix> hf, CosmicRay
05:15:35 <CosmicRay> morning dblhelix
05:16:09 <paolo> dons: ping
05:17:06 <musasabi> hello CosmicRay
05:17:20 <Fri21454> im so going to treat myself to a treat if this fixes the bug i've been dealing with for hours
05:17:26 <boegel> shapr: wanted FLM feature ->adding a score to each paper
05:17:28 * paolo artistic vein http://haskell.galois.com/~paolo/Hashell.png
05:17:53 <boegel> paolo: better use more different cooler
05:17:56 <CosmicRay> does anybody know why System.Console.SimpleLine.Editor.getLineEdited returns IO (Maybe String)?  When might it return Nothing?
05:17:58 <boegel> s/cooler/colors
05:18:11 <Philippa> boegel: bit awkward, that - really you want to let people assign n scores so eg you can rate its relevance to different things you might think it's relevant to
05:18:31 <Philippa> I guess the averaging might be useful, but you can get most of that without adding any functionality at all
05:18:50 <paolo> boegel: the K part doesn't show up to the eye, tough
05:19:13 <tuomov> perhaps some trust metric based system
05:19:26 <ski> hm .. hashkell
05:20:03 <paolo> ski: I thought it for don's isomorphism project Haskell<->shell.
05:21:13 <boegel> Philippa: point taken
05:23:34 <dons> CosmicRay:   ms <- readline prompt
05:23:34 <dons>   case ms of
05:23:34 <dons>     Nothing -> return ms
05:23:35 <dons>     Just s  -> when (not (all isSpace s)) (addHistory s) >> return ms
05:24:07 <CosmicRay> dons: from looking at some C library docs, I'm guessing that it returns Nothing on EOF
05:24:39 <dons> that's what I thought, yep.
05:25:20 <dons> yep. man 3 readline says so
05:25:24 <vikasg> vivek, you're in Chennai? what do you do?
05:26:06 <boegel> is there a way to avoid that emacs produces *.*~ files all the time ?
05:26:45 <Fri21454> @hugs uncurry (++) . (maybe [] id) *** (maybe [] id) $ ((Nothing), (Just [1,2,3]))
05:26:56 <tuomov> I like to put them in ~/backups/. I don't use emacs though.
05:27:07 <lambdabot> Couldn't match `([a], [a])' against `[a1]'
05:27:28 <Fri21454> @hugs uncurry (++) . ((maybe [] id) *** (maybe [] id)) $ ((Nothing), (Just [1,2,3]))
05:27:34 <lambdabot> [1,2,3]
05:27:39 <Fri21454> sweeeet
05:27:50 <Fri21454> @hugs uncurry (++) . ((maybe [] id) *** (maybe [] id)) $ ((Just [-1,0]), (Just [1,2,3]))
05:27:52 <lambdabot> [-1,0,1,2,3]
05:28:11 <Itkovian> boegel: use vim
05:28:20 <boegel> Itkovian: bwaak
05:28:24 <Fri21454> i agree, vim is da shiznit
05:28:42 <Itkovian> oh come on, vim rulez
05:29:19 <Fri21454> @hugs uncurry (++) $ ((maybe [] id) *** (maybe [] id))  ((Nothing), (Just [1,2,3]))
05:29:24 <lambdabot> [1,2,3]
05:29:25 <mauke> boegel: you might want to read http://home.cs.tum.edu/~mai/stuff/emacs/omglol.txt
05:29:26 <Fri21454> hmmmm
05:29:38 <Fri21454> where ow where would thy put the $
05:30:38 <boegel> mauke: thanks !
05:31:00 <boegel> Fri21454: to avoid parens
05:32:18 <Fri21454> where boegel
05:32:20 <Fri21454> not why
05:32:25 <Fri21454> :D
05:32:56 <Fri21454> in both the above cases that i threw at @hugs...it doesnt matter for parenthesis
05:32:59 <boegel> Fri21454: oh, sry
05:33:07 <Fri21454> :)
05:33:45 <Fri21454> anyway, time to get some work done...so lataer
05:35:35 <CosmicRay> @hugs
05:35:36 <lambdabot> Terminated
05:35:43 <CosmicRay> @help hugs
05:35:43 <lambdabot>  @help <command> - ask for help for <command>
05:35:48 <CosmicRay> @help @hugs
05:35:49 <lambdabot>  @help <command> - ask for help for <command>
05:35:57 <CosmicRay> bah
05:36:03 <CosmicRay> @hugs 2+2
05:36:04 <dblhelix> @hugs head "foo"
05:36:07 <lambdabot> 4
05:36:08 <lambdabot> 'f'
05:36:13 <dblhelix> :)
05:36:18 <CosmicRay> @hugs 1/0
05:36:21 <lambdabot> Infinity
05:36:29 <CosmicRay> @hugs head []
05:36:31 <lambdabot> <Plugins.Eval>:1:12:
05:36:31 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:36:31 <lambdabot>   `Show a' arising from use of `show'
05:36:34 <CosmicRay> nice
05:36:43 <boegel> @hugs tail [1]
05:36:43 <CosmicRay> @hugs (head [])::Char
05:36:45 <lambdabot> []
05:36:46 <lambdabot> runplugs: Prelude.head: empty list
05:36:56 <CosmicRay> @hugs :t head
05:36:58 <lambdabot> 19: Not in scope: `t'
05:37:29 <dblhelix> @bug someone for something
05:37:42 <dblhelix> dons: not implemented yet?
05:38:23 <dblhelix> :)
05:44:01 <ski> there is no @hugs command
05:44:14 <Itkovian> eh?
05:44:21 <ski> it spellcorrects to @plugs, which is a synonym for @eval
05:44:43 <ski> @help plugs
05:44:43 <lambdabot>  @eval <expr>
05:44:43 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
05:46:01 <CosmicRay> hah
05:46:14 * CosmicRay opens a can of unsafePerformIO on lambdabot
05:46:28 <CosmicRay> ski: heh
05:46:29 <vikasg> what is the 3 seconds thing?
05:46:35 <ski> timeout
05:46:44 <CosmicRay> vikasg: to keep away infinite loops
05:47:01 <mauke> like @eval length [0..]?
05:47:54 <ski> or @eval [0..]
05:48:06 <ski> hm
05:48:18 <ski> well, that actually seems to work
05:48:33 <ski> (you get a @more for showing more of it)
05:49:03 * dblhelix goes walking to the rain... to the supermarket
05:49:24 * ski should do ditto
05:49:26 <Lemmih> 'eval' only gives you the first 2048 chars and 'take 2048 [0..]' terminates within 3 secs.
05:49:34 <dblhelix> Itkovian: I'm away for just a few minutes, try to stay on topic... lol :;)
05:51:15 <boegel> hehe
05:51:26 * vikasg thanks the type checker for finding 3 bugs in the last 10 minutes
05:52:54 <Itkovian> what did he mean by that?
05:54:00 <boegel> he meant it always YOU who goes offtopic, you sex-crazed lunatic :p
05:54:13 <boegel> btw, tristinia sucks
05:54:17 <boegel> not my kinda music
05:54:24 * boegel deletes tristania
05:54:25 <vikasg> I meant the type checker found bugs that wouldn't have been revealed until run-time in a dynamic typed language
06:08:23 <Itkovian> eh? tristania rules
06:08:40 <Itkovian> you should listen at least twice and start with Widow's Weed
06:11:44 <boegel> Itkovian: it's just not my kind off music, too Within Temptation and such, don't like the women in the back, too gothic for me
06:11:56 <Itkovian> ah, I love women singing
06:12:24 <boegel> tiamat is quite good, kind of slow latin-like
06:18:06 <Itkovian> guess you won't enjoy Nightwish then too.
06:20:26 <boegel> probably :) but I knew that already, I've seen people wearing t-shirts of them :p
06:20:39 <boegel> too gothic, I can tell withou listening, but I'll give it a chance
06:21:21 <Lor> Last sunday both Within Temptation and Nightwish held concerts at the same event.
06:21:51 <Lor> WT were pretty popular, too, but it was funny how a third of the audience had Nightwish T-shirts. :)
06:23:03 <Lor> imho nw isn't very "gothic", but ymmv.
06:23:39 <Itkovian> Lor: where was that?
06:24:12 <Lor> Ankkarock, Korso, Vantaa, Finland.
06:24:26 <Itkovian> ah ok
06:24:35 <Itkovian> I've seen NW three times ... pretty impressive
06:25:05 <Itkovian> don't like WT that much, well, not all of their songs ...
06:25:09 <Lor> NW are going to have a pretty grand end-of-tour concert in october. The tickets were sold out in an hour, and the prices have risen to thrice the original now.
06:25:19 <Itkovian> shit
06:25:32 <Itkovian> they come to Pukkelpop in Belgium in a few weeks afaik
06:30:03 <CosmicRay> http://ars.userfriendly.org/cartoons/?id=20050812
06:34:13 * CosmicRay notes the Haskell section at http://lwn.net/Articles/145234/
06:36:43 <boegel> Itkovian: more like next weekend (next week)
06:39:29 <Lemmih> dons: Dynamic exceptions can't be thrown in dynamically loaded code and catched in static code. Is this a know problem?
06:52:03 <Lemmih> @seen dons
06:52:05 <lambdabot> dons is in #haskell. Last spoke 1 hour, 24 minutes and 59 seconds
06:52:05 <lambdabot> ago.
06:53:47 <boegel> yo goron
07:00:14 <Itkovian> gotta go
07:00:16 <Itkovian> ttyl
07:00:29 <dblhelix> bye Itkovian
07:03:47 * boegel leaves too
07:03:56 <dblhelix> bye boegel
07:03:59 <boegel> c u guys later
07:09:03 <Lemmih> dons: n/m, found AltData (:
07:19:19 <SamB> TheHunter: honeynet? is it really that bad?
07:20:11 * Lemmih write a really ugly hack while throwing angry lambda's at Data.Typeable.
07:29:36 <basti_> hi
07:30:46 <Lemmih> type Obj = forall x. x
07:30:47 <Lemmih> data MyDynamic = MyDynamic TypeRep Obj
07:30:47 <Lemmih> DynException dyn  -> let MyDynamic _ obj = unsafeCoerce# dyn :: MyDynamic
07:30:47 <Lemmih>                          newDyn = toDyn (unsafeCoerce# obj :: HSP.Exception)
07:30:47 <Lemmih>                      in throwHSPR $ PageEvalFailed $ DynException newDyn
07:31:16 <Lemmih> I feel _so_ dirty.
07:31:31 <basti_> because you coerce values?
07:32:15 <Lemmih> Because it coerced a Dynamic and a forall x.x.
07:32:35 <Lemmih> s/it/I/
07:32:44 <lightstep> what is that "->"?
07:33:04 <Lemmih> lightstep: I've cut it from a case expression.
07:33:07 <basti_> ohh
07:35:24 <basti_> @index unsafeCoerce
07:35:25 <lambdabot> bzzt
07:39:28 <vegai> should the latest c2hs be compilable with nothing but ghc-6.4?
07:41:56 <lightstep> @hoogle unsafeCoerce#
07:41:59 <lambdabot> Prelude.undefined :: a
07:41:59 <lambdabot> System.exitFailure :: (IO a)
07:41:59 <lambdabot> Prelude.minBound :: Bounded a => a
07:42:37 <Lemmih> @type GHC.
07:42:42 <Lemmih> Ops.
07:42:47 <lambdabot> bzzt
07:42:53 <Lemmih> @type GHC.Base.unsafeCoerce#
07:42:54 <paolo-> vegai: why?
07:42:55 <lambdabot> forall b a. a -> b
07:44:27 <basti_> ah
07:44:45 <vegai> > ./Setup.hs configure
07:44:49 <vegai> *** Exception: Line 20: Unknown field 'hs-source-dirs'
07:44:56 <musasabi> unsafeCource# is a very nice hammer to solve problems and kill innocent bystanders.
07:44:59 <vegai> (trying to build c2hs-0.14-3)
07:45:10 <musasabi> vegai: upgrade cabal.
07:45:35 <Lemmih> vegai: hs-source-dirs was introduced after Cabal 1.0
07:45:55 <vegai> aww
07:46:21 <vegai> the new one will shadow the one in ghc, hopefully?
07:47:11 <Lemmih> Yeah.
07:47:14 <Lemmih> Cabal is just a Haskell library.
07:47:54 <vegai> I'm starting to feel that GHC might have too much
08:25:45 <spiffy> Hmmm I cant seem to access the download page for hugs, can anyone else?
08:27:41 <Lemmih> Works fine for me.
08:30:33 <spiffy> alright, Ill try again.
08:31:08 <spiffy> from http://cvs.haskell.org/Hugs/pages/downloading.htm?
08:31:30 <Lemmih> Yep.
08:32:46 <spiffy> 'Cannot find server'
08:32:47 <spiffy> weird
08:39:17 <bourbaki> moin
08:39:31 <Lemmih> Moin bourbaki.
08:39:47 <bourbaki> hey i had an idea for audio filters and monads
08:40:04 <bourbaki> a friend of mine told me about filter banks for speach recognition
08:40:22 <bourbaki> and i had the idea to build these filter banks with monads has anyone of you done or heared of something similar?
08:46:11 <Lemmih> spiffy: Still doesn't work?
09:00:35 <spiffy> Lemmih: sorry, was away for a few minutes... fine now
09:00:37 <spiffy> thanks
09:05:00 <paolo-> Does haskell-unsafe.alioth.debian.org resolve for you?
09:06:03 <Lemmih> It doesn't for me.
09:06:23 <Igloo> I think someone said alioth broke recently on a list
09:06:25 <paolo-> Is there any mirror? :-(
09:06:52 <Igloo> No
09:07:00 <Igloo> What do you want?
09:07:21 <paolo-> ghc
09:07:22 <paolo-> ghc6
09:07:35 <Igloo> Get it (but only it) from Debian unstable
09:07:46 <paolo-> Uhm, ok.
09:07:51 <Igloo> Oh, or do you mean the 6.4.1 prerelease?
09:08:00 <paolo-> The latest, yep.
09:09:09 <Igloo> http://urchin.earth.li/~ian/ghc6_6.4.1~20050801-1_i386.deb
09:09:15 <paolo-> Thank you very much
09:21:27 <Lemmih> Hey SyntaxNinja.
09:21:53 <SyntaxNinja> hi Lemmih
09:22:08 <lispy> good morning
09:23:00 <Lemmih> SyntaxNinja: You didn't install hs-plugins on h.g.c...
09:24:25 <SyntaxNinja> hm. I ran 'make install'
09:24:29 <paolo-> Anybody happened to compile successfully c2hs?
09:24:41 <lispy> paolo-: sorry, i didn't try
09:24:41 <Lemmih> SyntaxNinja: You need 'make register' after that.
09:24:59 <SyntaxNinja> done
09:25:04 <SyntaxNinja> what kind of build system IS this?!
09:25:27 <Lemmih> Thanks.
09:25:54 <TheHunter> lament, that's good to hear, thanks.
09:26:17 <bourbaki> is there a good what you see is what you get latex editor for windos?
09:26:20 <bourbaki> hi thedward
09:26:24 <bourbaki> er TheHunter
09:26:25 <TheHunter> SamB, dunno, haven't done anything except nmap. I probably meant to say 'honeypot'
09:26:29 <TheHunter> hi bourbaki
09:28:05 <paolo->   
09:28:55 <ski>    
09:29:12 <Lemmih>  
09:29:31 <Lemmih> I think we can all agree on that.
09:29:35 <sylvan> bourbaki: Emacs with the latex-render-thingy-plugin?
09:29:57 <sylvan> Or cyginw+lyx
09:30:46 <bourbaki> yep just installing cygwin atm :)
09:30:48 <ski> we could write entire programs in Whitespace, there ..
09:30:50 <sylvan> actually, lyx now supports windows officially
09:31:10 <sylvan> (I've had some trouble getting it to work in the past)
09:33:17 <sylvan> bourbaki: No need for cygwin, ftp://ftp.lyx.org/pub/lyx/bin/1.3.6/lyx-1.3.6_win32_setup_v1.exe
09:35:54 <bourbaki> sylvan thx i think ill just dont use the lyx thingy so i just need some new basic file heh
09:36:16 <bourbaki> is there any cool style file that can handle haskell code and such?
09:37:03 <paolo-> .lhs ?
09:37:08 <paolo-> Nevermind.
09:40:59 <SamB> TheHunter: yeah, I sure hope you can't see the rest of the network! its supposed to be behind NAT
09:43:14 <lispy> dons: are you around?
09:44:24 * lispy wonders if texmacs runs in windows
09:52:52 <lispy> Imk -Icbits  -DGLASGOW_HASKELL=602  Yi/Curses/CWString.hsc
09:52:52 <lispy> make: Imk: Command not found
09:52:57 <lispy> what is Imk?
09:53:06 <lispy> where does one get it?
09:53:32 <paolo-> Maybe it is imake?
09:54:23 <Igloo> It probably means it failed to find ghc
09:54:45 <lispy> Igloo: Imk is definitely not on my system
09:54:52 <Igloo> Or hsc2hs rather
09:55:08 <lispy> paolo-: i tried typing in that command with imake instead of Imk and i get an error from Imk
09:55:14 <Igloo> It's trying to do $(HSC2HS) -Imk ... or somesuch
09:55:18 <lispy> Igloo: that's a posibility
09:55:31 <Igloo> It's a near certainty in my opinion  :-)
09:56:08 <lispy> if i want to learn how to make configure detect stuff like that, where do i go for documentation?
09:56:18 <yosemite> gah I would hope that that is not imake
09:56:50 <yosemite> lispy: there is a good book on gnu autoconf automake online
09:57:11 <lispy> yosemite: so autoconf is what I need to learn about?
09:58:01 <yosemite> http://sourceware.org/autobook/autobook/autobook_toc.html#SEC_Contents
09:58:23 <yosemite> if we're talking gnu configure then probably yes
09:58:39 <yosemite> it's a maze of m4 macros and shell script though, so be warned
09:59:09 <lispy> yosemite: :(
09:59:32 <lispy> i just want yi to detect when i don't have hsc2hs and hs-plugins installed :)
10:00:09 <yosemite> hmm
10:00:26 <yosemite> you may be able to just hack configure.in then with some simple stuff
10:01:05 * yosemite finds his yi src dir
10:01:23 <yosemite> er, I guess it's called configure.ac now
10:02:25 <lispy> hmm...yeah, this looks complicated
10:02:40 <lispy> more so than i had anticipated
10:02:54 <yosemite> hmm it seems to be looking for hsc2hs already, but I can't make heads or tails of what it does with the result
10:03:25 <lispy> i can configure and it doesn't complain, so if it detects it missing it doesn't seem to thnk it's required
10:03:37 <yosemite> yeah, they wanted portable shell so to hide the really ugly details they wrapped it in m4
10:04:01 <lispy> what is m4?
10:04:10 <yosemite> it's a macro language
10:04:13 <lispy> joy
10:04:18 <yosemite> think cpp on steroids
10:04:42 <yosemite> I've actually used it once or twice as a cpp replacement
10:05:17 <yosemite> you can do some nice recursive macros and stuff with it.
10:05:40 <lispy> there does seem to be a check for hsc2hs
10:06:07 <lispy> but not knowing autoconf i have no idea if it's valid
10:06:12 <yosemite> yeah I didn't see one for hs-plugins
10:08:24 <yosemite> so I think I'm almost to the point where haskell has suitably rewired my brain, I can write pieces of code without type errors.
10:10:58 <lispy> i wrote a short program for a school assignment that compiled on the first try and it was an amazing feeling ;)
10:11:10 <lispy> it also worked :)
10:11:32 <paolo-> Did you miss "in Haskell" in your last sentence? :-P
10:12:32 <lispy> paolo-: yes ;)
10:12:58 <Lemmih> lispy: Yay (:
10:13:26 <paolo-> I'd like to do that too, if only c2hs compiled $%/(£!!!11
10:13:38 <lispy> heh
10:13:48 <lispy> i'm sad that i don't have yi on my school server
10:14:09 <lispy> i think instead of dealing with configure i'll just install hs-plugins and hsc2hs since i'll need them anyway
10:14:37 <paolo-> Are you writing some kind of complex dynamic software?
10:15:06 <vegai> paolo-: I compiled mine successfully now
10:15:14 <vegai> what problems were you having?
10:15:16 <paolo-> vegai: which version?
10:15:24 <vegai> ghc-6.4, c2hs-0.14.3
10:15:27 <vegai> cabal-1.1.1
10:15:50 <paolo-> Chasing modules from: c2hs/toplevel/Main.hs
10:15:50 <paolo-> Could not find module `Foreign.C.Types':
10:16:39 <lispy> paolo-: i just want to be able to use yi
10:18:02 <paolo-> vegai: not 6.4.1 ?
10:18:58 <vegai> no, 6.4
10:19:22 <paolo-> :-\ ok
10:24:57 <lispy> @google hsc2hs download
10:24:59 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-January/005741.html
10:25:13 <lispy> so, uh, what is the proper way to get hsc2hs?
10:26:58 <wagle> i i got tiger, but darwinports ghc wont compile.  anyone know what the solution is?
10:27:11 <lispy> wagle: what is the error?
10:27:19 <lispy> wagle: it worked when i tried it on tigre
10:27:28 <wagle> /tmp/ghc21282.hc:3411: error: void value not ignored as it ought to be
10:27:28 <wagle> /tmp/ghc21282.hc: In function `GraphicsziX11ziXlibziRegion_zdLr31Ozdwccall12_entry':
10:27:38 <wagle> several like that
10:27:49 <lispy> hmm....
10:28:00 <lispy> have you tried asking in #darwinports?
10:28:24 <wagle> i dont get much of any sort of response to anything there
10:28:34 <wagle> only 6 people logged in or so..
10:28:44 <wagle> so i asked here first..  8)
10:30:24 <lispy> wagle: there is also #opendarwin or #openports or something that tends to have more people
10:30:43 <lispy> wagle: wish i could help, it "just worked" for me
10:31:21 <lispy> without hsc2hs i have no idea how i'll build Yi
10:31:33 <lispy> i have hspice
10:31:38 <lispy> whatever that is
10:32:55 <wagle> ahh..  dont use gcc 4
10:35:44 <lispy> Oh....
10:35:57 <wagle> spice written in haskell?
10:36:16 <lispy> everytime they come out with a new version of gcc it sucks for 6mths-1year.  I wish they would do more testing.
10:36:30 <lispy> wagle: i suspect hspice is something the EEs use
10:37:09 <wagle> take a long careful look at gcc someone
10:37:13 <wagle> take a long careful look at gcc sometime
10:37:55 <wagle> i did..  now i'm trying to do java and haskell and...
10:38:00 <lispy> wagle: we should do a rewrite in haskell ;)
10:38:22 <wagle> i want to get it to rewrite itself into haskell
10:38:46 <lispy> could you imagine the fun you could have with ghc and gcc if they required each other
10:39:11 <wagle> it concerns me that ghc doesnt use vanilla C
10:39:39 <lispy> yeah
10:39:58 <lispy> but most good software that builds with gcc requires gcc extensions
10:40:15 <wagle> "Pulling yourself up by the straps of your boots in infinite-dimensional space"
10:40:57 <lispy> i shouldn't say most, I should say, "a lot of"
10:41:08 <icb> is there a good tutorial that goes over each of the GHC Data modules with examples
10:41:32 <lispy> icb: not that i'm aware of, but the wiki is ripe for the publishing
10:42:00 <icb> i am working on some problems and find myself spending time going over each
10:42:12 <icb> maybe i should just do a survey and write up one
10:43:32 <wagle> like lewis and clark!
10:43:41 <wagle> 8)
10:49:10 <lispy> yay, monad was removed from the new windows version!
10:52:14 <icb> why did they call it monad?
10:52:33 <icb> it is so scary sounding
10:52:59 <icb> i think it is the same reason why c people found pointers hard to digest
10:53:29 <icb> its name connotates something monstrous
10:54:56 <lispy> i dunno, i was more afraid of the term "dynamic memmory allocation" when i learned C
10:55:05 <lispy> pointer seemed pretty tame in comparison
10:56:53 <musasabi> lispy: the problem is that old versions of gcc suck too. (just had internal compiler errors with 3.3.3)
11:00:22 <lispy> musasabi: yeah :(
11:08:49 <basti_> hey X-Scale
11:10:14 <lispy> @eval [1] >>= retrun
11:10:18 <lispy> @eval [1] >>= return
11:10:25 <lambdabot> 26: Not in scope: `retrun'
11:10:26 <lambdabot> [1]
11:10:45 <lispy> @eval (return 1) >>= head
11:10:46 <lambdabot> <Plugins.Eval>:1:12:
11:10:46 <lambdabot>   No instance for (Show (m b))
11:10:46 <lambdabot>   arising from use of `show'
11:10:57 <lispy> @eval (return 1) :: [Int] >>= head
11:10:59 <lambdabot> <Plugins.Eval>:1:19:
11:10:59 <lambdabot>   No instance for (Monad (>>= [Int]))
11:10:59 <lambdabot>   arising from use of `return'
11:11:34 <lispy> @eval (return [1]) >>= head
11:11:36 <lambdabot> <Plugins.Eval>:1:27:
11:11:36 <lambdabot>   No instance for (Num (m b))
11:11:36 <lambdabot>   arising from the literal `1'
11:11:50 <lispy> @eval (return [1]) :: [Int] >>= head
11:11:51 <lambdabot> Couldn't match the rigid variable `head' against `[a]'
11:11:54 <lispy> hm...
11:12:12 <lispy> according to the monad laws (return x) >>= f == f x
11:12:31 <lispy> so (return [1]) >>= head == 1
11:12:47 <lispy> am i just bumping into the monomorphic restiriction?
11:14:00 <Lemmih> >>= :: m a -> (a -> m b) -> m b
11:14:12 <Lemmih> >>= :: [a] -> (a -> [b]) -> [b]
11:14:39 <basti_> uhm
11:14:46 <basti_> i think youre bumping into list being a monad
11:14:53 <mwc> Does it make sense to represent a state vector for a virtual machine as a monad?
11:15:06 <mwc> Something's nagging me to do it that way
11:15:35 <basti_> it won't break anything.
11:15:36 <basti_> :)
11:16:11 <mwc> fair enough, it seems to be the smartest way, since applying transforms over it would be the bind op.
11:16:26 <basti_> there's a "state monad" for exactly this sort of thing
11:16:38 <basti_> thats why monads are so useful.
11:16:40 <Lemmih> Tsk. I should be sleeping.
11:16:59 <lispy> return (Just 1) >>= fromJust
11:17:03 <lispy> @eval return (Just 1) >>= fromJust
11:17:05 <lambdabot> <Plugins.Eval>:1:31:
11:17:05 <lambdabot>   No instance for (Num (m b))
11:17:05 <lambdabot>   arising from the literal `1'
11:17:20 <lispy> @eval fromJust (Just 1)
11:17:22 <lambdabot> 1
11:17:41 <lispy> so this monad law is not making sense to me
11:17:50 <basti_> @pl return "hello" >>= (++"hello")
11:17:50 <lambdabot> "hellohello"
11:17:51 <basti_> not.
11:18:21 <mwc> Looks like state monad isn't what  I need, the value is the state, thanks for the suggestion though
11:18:25 <conal> lispy: follow the >>= with a function that creates a monadic value
11:18:34 <basti_> mwc: uhm...?
11:18:37 <conal> coincidentally, Maybe and [] are monads.
11:18:39 <lispy> conal: ah
11:18:53 <lispy> conal: right, that's why i was uing them :)
11:19:21 <mwc> You know, we could pretty much get away with forking this chan into #HaskellMonads and #HaskellEverythingElse
11:19:33 <lispy> return 1 >>= (:[])
11:19:36 <lispy> @eval return 1 >>= (:[])
11:19:38 <lambdabot> [1]
11:19:45 <lispy> conal: thanks
11:19:54 <basti_> lol, yes.
11:20:08 <conal> sure
11:20:11 <lispy> mwc: monads are such an important part of doing really work in haskell tho
11:21:02 <basti_> btw. i'm thinking about doing a "filename completion interface" thing with continuations
11:21:07 <lispy> the monad law that states (return x) >>= f == f x, should probably add the note that f x needs to be a monadic value
11:21:35 <lispy> it can be inferred i'm sure, but in this tutorial it would be helpful to state it :)
11:21:57 <basti_> @pl ((return 5) >>= \x->[(7+x)])
11:21:58 <lambdabot> [12]
11:22:28 <lispy> basti_: that's interesting, i didn't realize @pl would do certain computations
11:22:39 <basti_> lispy: uhm?
11:23:00 <lispy> basti_: i thought it *just* rearranged into point free form
11:23:07 <basti_> ooops
11:23:12 <basti_> that was by accident!!!
11:23:13 <basti_> lol
11:23:21 <basti_> i often confuse plugs and pl
11:23:43 <basti_> that is, type pl subconsciously instead of plugs, because it feels like some type of abbrevation
11:23:47 <lispy> basti_: @eval was added for @plugs
11:24:24 <basti_> ...?
11:24:25 <basti_> :)
11:24:32 <wagle> whoa..  multistaged tcl programming..  8)
11:25:09 <lispy> @pl \x -> (1+3)
11:25:10 <lambdabot> const 4
11:25:32 <basti_> but, cool feature.
11:25:42 <lispy> yeah, that is interesting
11:25:58 <lispy> @pl \x -> length [1..]
11:25:59 <lambdabot> const (length [1..])
11:26:04 <wagle> @pl \x -> (x+x)
11:26:04 <lambdabot> join (+)
11:26:21 <lispy> @pl \x -> length [1..2]
11:26:22 <lambdabot> const (length [1..2])
11:26:28 <lispy> @pl \x -> length [1,2]
11:26:28 <lambdabot> const 2
11:26:36 <basti_> @pl \x-> length [1..x]
11:26:36 <lambdabot> length . enumFromTo 1
11:26:40 <basti_> :D
11:27:18 <basti_> that would have been cool.
11:29:04 <lispy> so the last law is |(m>>=f) >>= g == m >>= (\x -> f x >>= g)|, this is a form of associativity.  But I'm not seeing it...
11:29:31 <lispy> m >>= (\x -> f x >>= g), would take the value inside m, apply f to it, and then pass it on to g right?
11:29:45 <lispy> which, is exactly what i thought the LHS did
11:32:15 <basti_> it's just a law about the workings of >>=
11:32:47 <basti_> i think its obvious. but in maths, you have to state exactly what is obvious, otherwise its pointless (not points-free! ;)
11:34:08 <lispy> basti_: yeah, i'm starting to see it now
11:34:22 <lispy> basti_: it's more notational than anything else.
11:34:34 <lispy> basti_: that is assuming you have a reasonable definition of >>=
11:34:41 <basti_> yes.
11:34:48 <basti_> and a reasonable monad. and all.
11:34:50 <basti_> .)
11:34:59 <lispy> which we *awlays* do right? ;)
11:35:41 <basti_> well, for example we have it with lists, or with maybe
11:35:51 <basti_> or with IO, if you keep clean.
11:36:00 <lispy> would it even be possible for the compiler to check that every instance of monad obeys the monad laws?  I'm guessing it's undecidable, but that's just intuition speaking
11:36:12 <basti_> thats undecideable.
11:36:26 <basti_> I'm pretty sure
11:36:41 <basti_> i guess you can stick an undeciedable problem up into a monad
11:37:13 <lispy> er?
11:37:50 <basti_> well you need to construct a monad that has properties so complicated that >>= behaves pretty difficult
11:38:02 <basti_> like, undecideably difficult.
11:38:05 <basti_> i guess that can be done.
11:38:38 <lispy> maybe it never halts?
11:38:54 <lispy> at least in some cases
11:39:03 <basti_> you could, for example, stick the Ulam problem into >>=
11:39:17 <lispy> Ulam problem is not one i'm familiar with
11:39:22 <basti_> = 3n+1 problem
11:40:34 <lispy> basti_: hah, the Ulam problem is mean :)
11:40:42 <basti_> yes.
11:40:55 <basti_> now you define a monad that just works over Int.
11:41:10 <basti_> >>= applies the ulam function to the int
11:41:20 <basti_> now try to prove something over that
11:41:33 <yosemite> what's the ulam problem?  I can't find it in wikipedia.
11:41:42 <basti_> thats a name for the 3n+1 problem
11:41:43 <lispy> http://www.cs.mcgill.ca/~psavad/cs251/ulam.html
11:41:46 <basti_> ah
11:42:05 <basti_> uhm
11:42:14 <basti_> thats not ulams problem!
11:42:21 <basti_> not the one i'm referring to. I'm referring to:
11:42:24 <basti_> take an Integer
11:42:33 <basti_> if its even, take n/2, if its odd, take 3n+1
11:42:42 <basti_> recurse if the result is not 1
11:42:47 <basti_> iterate
11:43:03 <yosemite> ahh
11:43:10 <basti_> most numbers end up at 1.
11:43:19 <basti_> noone has been able to prove that all numbers do.
11:43:27 <lispy> ah
11:43:43 <yosemite> http://en.wikipedia.org/wiki/Collatz_Conjecture
11:43:54 <lispy> people should try harder ;)
11:44:04 <yosemite> we did something like that on the PP list
11:44:07 <yosemite> http://www.dasbistro.com/pipermail/pp/2005-March/thread.html
11:44:08 <basti_> well, proving things is undecideable
11:44:28 <basti_> or... is it? i think so.
11:44:41 <lispy> basti_: i was teasing, i know number theory is full of questions which are very simple to ask, but nearly impossible to reason about
11:44:59 <basti_> :P
11:45:42 <lispy> @type seq
11:45:47 <lambdabot> forall b a. a -> b -> b
11:45:52 <lispy> @type (>>)
11:45:53 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
11:45:59 <basti_> >> is like >>= without a variable
11:46:17 <lispy> basti_: right, and i'm curious why we have seq and >>
11:46:35 <lispy> @eval 1 `seq` 2
11:46:36 <basti_> o0
11:46:37 <lambdabot> 2
11:46:44 <basti_> because seq does magic and >> doesnt
11:46:52 <lispy> @eval Just 1 >> Just 2
11:46:56 <lambdabot> Just 2
11:46:59 <lispy> basti_: heh
11:47:12 <lispy> for some purposes they do the same thing right?
11:47:16 <lispy> but not in general
11:47:30 <lispy> @eval Just 1 `seq` Just 2
11:47:30 <basti_> hmmm
11:47:32 <lambdabot> Just 2
11:47:38 <basti_> i'm not sure on that.
11:47:46 <lispy> >> = fmap seq
11:47:48 <lispy> ;)
11:48:01 <Heffalump> @eval undefined >> 2
11:48:04 <lambdabot> <Plugins.Eval>:1:31:
11:48:04 <lambdabot>   No instance for (Num (m b))
11:48:04 <lambdabot>   arising from the literal `2'
11:48:11 <lispy> @eval undefined `seq` 2
11:48:12 <lambdabot> runplugs: Prelude.undefined
11:48:13 <Heffalump> @eval undefined >> Just 2
11:48:15 <lambdabot> runplugs: Prelude.undefined
11:48:26 <Heffalump> doh.
11:48:33 <Heffalump> that needs an identity monad.
11:48:57 <lispy> Heffalump: undefined nedes an identity monad?
11:48:59 <Heffalump> the really obvious answer is that seq has a different type.
11:49:15 <Heffalump> No, actually showing the difference will require there to be an identity monad defined with newtype.
11:49:17 <basti_> i wouldnt know that >> forces anything by design.
11:49:33 <basti_> it might be that >> is percieved as doing something similar, though
11:49:40 <Heffalump> it doesn't force anything by design, but almost all >>= operations will in practice.
11:49:40 <basti_> by introducing some sense of sequence
11:49:46 <basti_> yes.
11:49:49 * basti_ nods
11:49:52 <lispy> hmm...
11:49:59 <Heffalump> which is why I said I need an identity monad.
11:50:05 <lispy> so when won't >>= force something?
11:50:08 <basti_> i can see that
11:50:12 <basti_> lispy: not >>= itself.
11:50:18 <Heffalump> when you wrote a definition that didn't :-)
11:50:22 <basti_> as in, it's not required for it to do.
11:50:27 <lispy> Heffalump: i don't think i'll understand the identity monad part until we have an example :(
11:50:43 <Heffalump> ok, but I can't do it with runplugs, cos it's not a one-liner.
11:50:46 * Heffalump goes to write a .hs file
11:51:05 <basti_> lispy: you'll say d'oh when you see it.
11:51:09 <lispy> heh
11:51:18 <lispy> hopefully it's quick
11:51:23 <sylvan> How do I get GHC to let me use hslibs? I mean it's in the distribution but I can't figure out how to import, say, Data.LazyPairingHeap
11:51:25 <basti_> identity monad is somewhat like... uhm... the unity type maybe
11:51:45 <lispy> unity type?
11:51:47 <basti_> ()
11:51:58 <basti_> "undeniable there, but it doesnt serve any useful purpose, besides showing up now and then"
11:52:06 <lispy> heh
11:52:23 <lispy> @eval let f () = f () in f ()
11:52:25 <lambdabot> <Plugins.Eval>:1:12:
11:52:25 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:52:25 <lambdabot>   `Show a' arising from use of `show'
11:52:33 <Heffalump> *Foo> Foo undefined >> Foo 2
11:52:34 <Heffalump> Foo 2
11:52:34 <Heffalump> *Foo> Foo undefined `seq` Foo 2
11:52:34 <Heffalump> Foo *** Exception: Prelude.undefined
11:52:43 <basti_> :)
11:52:49 <Heffalump> what's the pastebucket of choice for Foo.hs?
11:52:57 <basti_> lisppaste2: @url
11:52:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:53:29 * Heffalump questions whether something @lisp.org counts as "of choice" ;-)
11:53:32 <Heffalump> But I'll use it anyway.
11:53:42 * basti_ sighs
11:53:46 <lisppaste2> Heffalump pasted "Foo.hs" at http://paste.lisp.org/display/10742
11:53:48 <basti_> this is about being PRAGMATIC
11:54:28 <lispy> so why do you use newtype instead of data?
11:54:34 <Heffalump> so that Foo undefined == undefined
11:54:54 <Heffalump> if I used data, then the `seq` would have worked.
11:54:57 <lispy> i should learn about newtype
11:55:10 <basti_> newtype is between type and data.
11:55:12 <Heffalump> Cos it just evaluates its left hand argument to WHNF, and Foo undefined is in WHNF if Foo is a data
11:55:28 <basti_> WHNF? W? Head Normal Form?
11:55:32 <Heffalump> Weak
11:55:41 <Heffalump> differs from HNF in not evaluating under a lambda
11:55:46 <basti_> ah.
11:55:47 <lispy> but if Foo is is a newtype then Foo undefined is not in WHNF?
11:56:04 <Heffalump> well, it is, sort of. Inspecting it causes an undefined to be evaluated.
11:56:17 <Heffalump> it's just as much in WHNF as undefined is.
11:56:19 <lispy> hmm...this sounds very odd so far
11:56:31 * basti_ gives lispy a hug
11:56:35 <lispy> i certainly need to read about newtype
11:56:49 <Heffalump> yeah, that would be useful. But do you really need to understand precisely what's going on here?
11:57:16 <Heffalump> the pragmatic answer to what's the difference between >> and `seq` is that `seq` has a more general type whereas >> needs to be defined in terms of >>= to be correct.
11:57:25 <lispy> well, i get that >> != liftM seq
11:57:40 <basti_> only would make your head ache
11:58:32 <lispy> but, i'm not worried that newtype has some subtle differences from data
11:58:45 <lispy> or perhaps some not so subtle ones :)
11:59:58 <Igloo> Heffalump: Can you give an example of an expression that is different under NF, HNF and WHNF please?
12:00:57 <basti_> :-o
12:00:58 <lispy> i hate typo'ing now <--> not, it really changes the meaning...
12:01:33 <Heffalump> if Foo is a data, Foo (5+5) is in HNF and WHNF but not NF.
12:01:37 <ski> and seq is evil
12:01:45 <Heffalump> \x -> 5+5 is in WHNF but not HNF
12:01:47 <lispy> the gentle intro to haskell doesn't really touch on newtype vs. data.  They sort of mention it, give a quick example and move on
12:02:14 <lispy> ski: why is that?
12:02:15 <Igloo> So does WHNF = HNF in lambda calc?
12:02:24 <lispy> ski: gets rid of laziness?
12:02:26 <Heffalump> in pure lambda calc? I think so.
12:02:50 <Heffalump> >> * data ! and newtype both have a single _|_, the
12:02:50 <Heffalump> >> difference is you can match it against Foo _ with
12:02:50 <Heffalump> >> newtype but not data !
12:02:50 <Igloo> Hmm, OK, ta
12:03:05 <Heffalump> that's my record of the difference between newtype and data with strictness annotations.
12:03:22 <Heffalump> (it took a long discussion with Igloo and others to come to that, which is why I made a note of it)
12:03:55 <Heffalump> btw, you should check my claims about WHNF. I _think_ I'm right but it's a while since I read about them and I might be slightly off-base.
12:04:03 <lispy> Heffalump: we can use undefined inplace of _|_ in haskell right?
12:04:08 <Heffalump> yes
12:04:39 <Heffalump> denotationally, any call to error , and any non-terminating computation, are _|_ as well
12:04:49 <Heffalump> (as is an error caused by a pattern-match failure etc)
12:05:10 <Heffalump> but operationally the difference is observable in terms of the behaviour of your program. What is common in each case is that it won't keep running.
12:05:18 <basti_> lispy: i rarely encounter something where i think "boy this NEEDS newtype".
12:05:21 <Heffalump> (unless you catch it in IO)
12:05:27 <lispy> Heffalump: so in your notes, Foo undefined can be mached against Foo _ and you will get an exception?
12:05:29 <Heffalump> basti_: well, you just did :-)
12:05:47 <basti_> while programming haskell for a reason.
12:05:51 <Heffalump> no, you won't get an exception
12:06:15 <lispy> Heffalump: so you won't get an exception in the case of newtype, but you will in the case of data?
12:06:16 <Heffalump> I really have to go, I'm afraid.
12:06:26 <Heffalump> no, Foo undefined will cause an exception in neither case.
12:06:26 <lispy> Heffalump: thanks
12:06:33 <Heffalump> undefined will only cause an exception in one of the two cases.
12:06:58 <Heffalump> "will cause an exception in neither" = "will not cause an exception in either", just to make my English clearer.
12:07:00 <ski> lispy : http://www.haskell.org/pipermail/haskell/2002-May/009622.html
12:07:59 <lispy> ski: looks interesting, thanks
12:08:35 * Heffalump thinks this discussion would make an nice wiki page if someone cba to write it up.
12:08:40 <Heffalump> but now I'm really going.
12:09:04 <ski> Heffalump : i thought e.g. in 'data A = A Int'  and 'newtype B = B Int',  we have 'A _|_ :: A'  and also '_|_ :: A' and those are different
12:09:18 <Heffalump> they aren't different for newtype
12:09:24 <ski> while 'B _|_ :: B'  and '_|_ :: B' are the same
12:09:36 <Heffalump> sorry, misread you.
12:09:39 <Heffalump> Yes, you are correct.
12:09:48 <ski> <Heffalump> >> * data ! and newtype both have a single _|_, the
12:09:49 <Heffalump> but data ! is a case that is very hard to understand
12:09:57 <Heffalump> data ! means data with strictness annotations on the field
12:10:09 <ski> it seems you're saying A only have a single bottom-element, i.e. A _|_ = _|_
12:10:19 <Heffalump> data C = C !Int
12:10:19 <ski> ah
12:10:20 <ski> sorry
12:10:35 <ski> now, it's my turn to misread, apparently :/
12:10:52 <Heffalump> it wasn't very clear. I was just pasting my own personal note.
12:11:03 <Heffalump> rather than taking the time to write it out in an externally comprehensible form
12:11:05 <ski> hm
12:11:14 <ski> so what does the ending part mean ?
12:11:22 <ski> <Heffalump> >> difference is you can match it against Foo _ with
12:11:25 <ski> <Heffalump> >> newtype but not data !
12:11:37 <Heffalump> f (B _) = ...
12:11:44 <Heffalump> f undefined will work
12:11:48 <ski> surely one can match  case someB of B n -> ...
12:11:49 <Heffalump> g (C _) = ...
12:11:52 <Heffalump> g undefined won't work
12:11:55 <ski> aha, ty
12:12:09 <ski> all clear
12:12:36 <Heffalump> the operational reason is that in the case of newtype, the constructor is completely stripped away in compiled code, so you just get f _ = ..., whereas this doesn't happen for data !
12:13:00 <Heffalump> oh, hangon.
12:13:06 <ski> efficiently inserting and removing the constructor is O(0)
12:13:11 <Heffalump> What I said about Foo undefined matching against Foo _ for C is incorrect.
12:13:15 <ski> s/efficiently/effectively/
12:13:18 <ski> mhm
12:13:26 <ski> hm
12:13:32 <Heffalump> Foo undefined should behave just like undefined, so for data !, it will cause an error.
12:13:40 <Heffalump> In the case of data, it won't.
12:13:49 <ski> yes
12:14:30 * Heffalump disappears for the weekend
12:14:35 <lispy> Heffalump: thanks!
12:16:39 * ski ponders if 'data!' is evil in the same way as 'seq' is ..
12:18:25 <lispy> ski: data! is something i've been avoiding learning about...
12:18:35 <ski> lispy : fyi iirc, in earlier haskell versions, they had an Eval class with member seq, and you could derive Eval (iirc), and function as well as IO were *not* instance of this class
12:19:05 <lispy> ski: tha was to avoid something?
12:20:05 <lispy> well, i'm off to lunch
12:20:10 <lispy> bbib
12:20:17 <lispy> er bbiab
12:20:36 <ski> (btw, 'seq' is the reason (one of the reasons ?) the eta-rule isn't valid in haskell, i.e. the rule saying that  '\x -> <expr> x' is the same as '<expr>' (provided 'x' is not a free variable in '<expr>')
12:20:57 * SamB wonders how named pipes work
12:20:59 <paolo-> Really?!
12:21:05 <ski> lispy : that was to avoid the current awkwardness/stupidity
12:21:10 <paolo-> @pl \x -> f x
12:21:12 <lambdabot> f
12:22:12 <ski> paolo- : think of 'undefined `seq` 42'  and now think of '(\x -> undefined x) `seq` 42'
12:22:53 <ski> i.e. afaik the difference is not "observable" (in the theoretic sense), but it's still a difference
12:25:46 <ski> lispy : hm, this seems to mention class Eval, in case you're interested http://www.mrtc.mdh.se/projects/DFH/docs/exts.html#sect4
12:37:36 <ski> (lispy : the (interesting) paper mentioned here e.g. does not consider 'seq' a part of haskell http://www.haskell.org/pipermail/haskell/2004-June/014134.html)
12:50:39 <shapr> shazam!
12:52:50 <paolo-> shapr: tired of ERC?  Now there's Circe!
12:53:15 <shapr> Whassat?
12:53:43 <paolo-> forcer's new project
12:54:04 <paolo-> "Circe was initially written in three or four days because the author got terribly annoyed at bugs in ERC. Nontheless, many ideas are taken directly from ERC, and that client has served the author well for a long time. Thanks to all the people who worked on ERC!"
12:54:09 <paolo-> I'm using Circe version 0 with GNU Emacs 22.0.50.1 (of 2005-08-09)
12:54:20 <paolo-> http://www.nongnu.org/circe/
12:59:18 <musasabi> yet another emacs irc client?
12:59:45 <paolo-> Yup :)
13:00:50 <musasabi> That looks nice, have to try some time.
13:00:58 <paolo-> It does!
13:05:02 <paolo-> musasabi: is even nicer because it's contained in only 5 files.
13:29:05 <lispy> paolo-: thanks for the cicre link
13:29:14 <lispy> er circe
13:31:08 <lispy> maybe i can give it a whirl this weekend
13:41:30 <SyntaxNinja> lalala
13:49:49 <lispy> SyntaxNinja: that always reminds me of the puddle of mud song...
14:16:05 <jlouis> yay! GHC 6.4.1 + HSX + hs-plugins ... now for lambdabot hacking ;)
14:20:10 <jlouis> @help eval
14:20:12 <lambdabot>  @eval <expr>
14:20:12 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
14:30:28 <wagle> whoa ho!  four hours of compiling later, with gcc 3.3 this time, it fails the same way
14:30:36 <wagle> (ghc)
14:30:57 <wagle> (darwinports ghc in tiger)
14:53:37 <lispy> wagle: on no
14:53:41 <lispy> er oh no
15:02:57 <TheHunter> jlouis, yay! what are you hacking on?
15:03:52 <lispy> wagle: when was the last time you updated dports?
15:22:47 <lispy> oh, i should use let more often in my do blocks
15:23:15 <lispy> i've been using |do {x <- return 1; ... }| to set x = 1
15:23:22 <lispy> but that's silly
15:23:27 <Cale> ah, yeah, you really ought not to :)
15:24:03 <lispy> Cale: indeed
15:24:19 <Cale> did anyone find my recent haskell-cafe post interesting?
15:24:29 <lispy> i need to get on that list
15:24:34 <lispy> what is the url?
15:24:40 <lispy> (assuming you have it handy)
15:25:11 <Cale> http://www.haskell.org/mailman/listinfo/haskell-cafe
15:25:27 <lispy> thanks
15:25:58 <Cale> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/8011 is my post
15:26:24 <Cale> the discussion was the usual thing about hGetContents and hClose
15:26:45 <jlouis> TheHunter: cleanups currently. I am documenting code as I walk through it
15:27:07 <jlouis> But now I've contemplating renaming Util.join to Util.concatIntersperse
15:27:24 <jlouis> and fix the places it is references
15:27:29 <jlouis> referenced even
15:27:58 <jlouis> Also, I plan on letting GenModules.hs use Util.hs. Theres a lot of redundancy there
15:28:15 <shrimpx> what you should really do is: rename join to concatIntersperse, then do join = concatIntersperse -- XXX: fix the callees someday
15:28:17 <TheHunter> i guess the name concatIntersperse is too long.
15:28:34 <jlouis> TheHunter: ok. Come up with a better one
15:28:59 <wagle> lispy: a couple days
15:29:19 <jlouis> shrimpx: that would be the usual way to run an Open Source project ;)
15:29:59 <TheHunter> {-# deprecate join #-} is another way, but there's also the Werror policy.
15:30:18 <jlouis> fuseStr ?
15:30:32 <jlouis> or maybe just fuse
15:31:12 <Cale> concatWith ?
15:31:25 <lispy> what is an example of join?
15:32:16 <TheHunter> @eval let join = (concat .) . intersperse in join ", " ["1","2","3"]
15:32:22 <lambdabot> "1, 2, 3"
15:35:23 <TheHunter> i would've renamed join long before, but i could never think of a proper name; i think you native speakers should fight it out.
15:36:01 <jlouis> Cale: concatWith is good
15:36:10 <jlouis> and I am not a native speaker, heh
15:38:41 <jlouis> anyway, bed now. Code later tomorrow. If you come up with a good name, please PM me with it or send it to jlouis@mongers.org ;)
15:39:00 <lispy> Cale: good read, thanks.  But after some discussion this morning, I'm a bit worried about using seq
15:39:19 <Cale> seq is mildly dangerous :)
15:39:57 <lispy> threeve: how goes the opengl?
15:40:18 <lispy> Cale: yeah, and it's subtle with newtype vs. data combined with _|_
15:40:33 <threeve> lispy: I got sidetracked on some other stuff, but i got through the first 5 lessons so far
15:40:49 <lispy> doesn't python have a function that does what join does and it's called implode or something
15:41:13 <lispy> threeve: cool, i'm hacking away on 10, i hope to finish it tonight or this weekend
15:41:28 <lispy> but finding time is the hardest part :)
15:41:33 <threeve> lispy: sweet.  you're moving right along :)
15:41:58 <lispy> threeve: yeah, i'm excited about getting to the "cool" stuff
15:42:13 <lispy> lesson10 loads a scene and lets you move around, so that's the start of something interesting
15:43:10 <lispy> Cale: is rnf short for "reduce to normal form"?
15:46:27 <shrimpx> root normal form?
15:49:43 <basti_> redex normal form?
15:50:02 <liebestraume> rabid nascent ferrets?
15:50:22 <basti_> random numb fossils?
15:50:58 <basti_> anyway i'm off
15:50:58 <basti_> cu
15:51:24 <shrimpx> heh
15:51:33 <shrimpx> i think rnf is the same thing as hnf
15:52:54 <threeve> lispy: when you get that done you'll have to let me know about how it performs compared to the other versions
15:55:10 <lispy> threeve: if i comipile with -O3 i can't feel the difference
15:55:41 <lispy> threeve: but i have a problem testing the C versions.  The only ones thta work on my system are the ones for cocoa, but the one i tried was buggy
15:56:09 <lispy> i'd fix it, except Objective-C is a total mystery to me
15:56:20 <lispy> i can't figure out where the syntax ends and where it begins :)
15:57:59 <threeve> hmm, I like objc actually.  better than c++ for sure :)  I'll try to run lesson 10 over here and see what happens
15:59:10 <threeve> lispy: are you planning to do them all in order or start skipping around ?  (lesson 37 looks pretty sweet)
16:14:49 <lispy> threeve: doing them in order is my first instinct, and at least so far it's been key to my success
16:15:28 <lispy> threeve: a lot of the later ones look really cool to me
16:16:15 <threeve> lispy: that makes sense for like the first 10, but after that they really aren't sequentially related i don't think.
16:18:59 <lispy> threeve: well, i want to do 12
16:19:08 <lispy> threeve: and i want to do 13 & 14 as well
16:19:17 <threeve> yea 12 is good.  I almost skipped over 6-11 to do 12.
16:19:18 <lispy> so i won't skip around until i've done at least 15
16:19:52 <threeve> lispy: have you gone through the tutorials in any other language before?
16:20:06 <lispy> no
16:20:08 <lispy> this is my first time
16:20:19 <lispy> i wanted to learn opengl mostly
16:20:25 <threeve> ahh, i've done most of them in like 3 other languages
16:20:34 <lispy> which languages?
16:20:38 <threeve> I'm using this to learn haskell moreso than opengl
16:20:47 <threeve> c, objc, java, and some in ruby
16:21:15 <lispy> ah, this is a bad way to learn haskell IMO, BUT if you know the rest I guess it's good to see how your familiar concepts map into the world of haskell
16:21:53 <threeve> yea, i realized this wasn't the best way to start in haskell, which is one of the things that sidetracked me.
16:23:27 <lispy> threeve: have you read this? http://www.nomaware.com/monads/html/
16:23:38 <lispy> threeve: that will help a ton
16:23:57 <lispy> i'm working through it again to help solidify my monad understanding
16:24:21 <threeve> lispy: i have it bookmarked.  i'm still working through the YAHT right now, and when I get to monads there I will review them both
16:25:04 <lispy> after i get monads under my belt, i guess arrows are next.  But i also want to make sure functors make sense
16:29:23 <TheHunter> Noo, functors come before monads.
16:29:44 <TheHunter> arrows are not that important, really.
16:29:48 <TheHunter> *Arrows
16:33:39 <lispy> TheHunter: and yet, i'v not paid any attention to functors....
16:33:43 <lispy> i should fix that :)
16:35:08 <TheHunter> every monad is a functor. That's why the MonadsAsContainers tuturial starts with functors (containers).
17:32:16 <Mou> is anyone good with the STMonad?
17:33:18 <Mou> i'm trying to implement linked lists in the ST monad
17:34:00 <Mou> but it occurred to me that they would be constructed strictly
17:34:58 <Mou> and would diverge if constructed with an infinite list, unlike haskell's normal lists
17:43:07 <wilx> Hmm, I just did that though I didn't test it with infinite list...
17:43:08 <wilx> Bah.
17:43:13 <wilx> Impatient bastards.
19:33:01 <shapr> whee!
19:33:04 <metaperl> has there ever been a greater musical genius than Billy Joel?
19:33:45 <TheHunter> jimi hendrix?
19:34:21 <metaperl> Billy Joel painted a picture of American life. Hendrix tried to take you to other planes of existence :)
19:34:50 <metaperl> both were highly successful
19:35:14 <Igloo> What do you like about BJ?
19:35:20 * metaperl is listening to Bigshot by BIlly Joel
19:35:42 <metaperl> like I said: the man paints a picture with words and music... I can simply see the world he is delivering musically.
19:36:04 * Igloo looks at his list and finds he found him interesting enough to put on it, but not particularly high up
19:36:14 <TheHunter> calling billy joel the greatest musical genius ever seems silly to me.
19:36:45 <TheHunter> but then again, i don't really know much of his music.
19:37:15 <metaperl> dont think, *experience*
19:37:22 <metaperl> just let it happen
19:37:25 <shapr> I'm fond of many musical artists. It's hard to say which of them are best.
19:37:51 <metaperl> it's hard for me in general. especially when I'm thinking. But now, this moment, as it plays, it *is*
19:38:12 <metaperl> a strawberry sorbet could not hit the spot more
19:38:45 <shapr> Lemon sorbet could!
19:39:14 <shapr> There's a marvelous non-milk Lemon & Cactus flavor of ice cream here, it's sort of like sorbet.
19:39:35 <shapr> I never would have believed I could go for Lemon & Cactus non-milk ice cream, but this is great stuff!
19:40:48 <metaperl> Cactus? hmmm...
19:42:09 <shapr> Cale: would you write a TMR article about how laziness increases compositionality?
19:42:21 * metaperl goes to work on filterFirst, exercise 9.16 in SJT
19:43:04 <Cale> shapr: I can probably do that, as my last exam is tommorrow, and then I won't have much to do for a while
19:43:29 <shapr> Cale: I would be most appreciative, and your community credit would increase as well :-)
19:43:46 <shapr> I think the article would provoke several interesting responses.
19:44:07 <shapr> I agree that laziness increases compositionality, but I can't quantify how.
19:44:47 <shapr> Plus, the next issue will have an Oleg article, always good to publish alongside Oleg ;-)
19:45:06 * shapr wanders off to sleep
19:45:12 <Cale> hehe :)
19:48:42 <metaperl> I'm not sure if I have to put not (p x) here:
19:48:46 <metaperl> filterFirst p (x:xs)
19:48:46 <metaperl>   | not p x        = x : filterFirst p xs
19:48:46 <metaperl>   | otherwise  = xs
19:49:03 <metaperl> given that functions have left-associativity
19:49:12 <metaperl> not p x = (not p) x
19:49:15 <metaperl> which is not what I want
19:50:53 <TheHunter> you've given the answer yourself
19:51:13 <metaperl> ok so I need parentheses
19:51:15 <metaperl> not (p x)
19:51:17 <metaperl> is correct
19:51:20 <TheHunter> yep
19:51:34 <TheHunter> the other one is a type error
19:51:58 <metaperl> well now I want to write filterLast... is there a way to write it without simply reversing the list and using filterFirst?
19:52:15 <lispy_> TheHunter: can the priority of functions be changed on a per function basis or is that only for infix?
19:52:28 <TheHunter> only infix
19:52:35 <lispy_> ah, too bad
19:52:51 <lispy_> it would be nice if return had a lower precedence
19:52:53 <TheHunter> application is left-associative and binds tightest - can't stress that enough.
19:53:44 <metaperl> ok how would you write filterLast?
19:54:12 <metaperl> TheHunter: what do you do at msu?
19:54:34 <TheHunter> math
19:54:52 <metaperl> and how would you write filterLast?
19:55:04 <TheHunter> pattern matching
19:55:56 <metaperl> so you wouldn't reverse the list twice? i.e., filterLast p xs = reverse (filterFirst p (reverse xs))
19:56:02 <TheHunter> filterLast p [x] = if p x ...
19:56:13 <TheHunter> filterLast _ [] = []
19:56:25 <TheHunter> filterLast p (x:xs) = x: filterLast p xs
19:57:09 <lispy_> out of curiousity, could we do it easily with a list comp?
19:57:16 <lispy_> curiosity*
19:57:22 <TheHunter> nope.
19:57:36 <metaperl> I dont understand your first clause with the truncated if
19:57:56 <lispy_> metaperl: that's the case where you only have a last element
19:58:15 <TheHunter> it matches singleton lists (thus x is the last element).
19:58:42 <metaperl> I dont see how your function filters the last element satisfying p from the list
19:59:12 <TheHunter> oh, sorry my function does something different.
19:59:46 <TheHunter> in fact, there was something like that on a mailing list lately.
20:00:03 <lispy_> oh, filter the last element satisfying p
20:01:00 <metaperl> yes...
20:01:16 <TheHunter> ok, gotta read first before i comment, the mailing list thing was still something different.
20:02:47 <metaperl> mine works, but it is obscenely inefficient: filterLast p xs = reverse (filterFirst p (reverse xs))
20:03:47 <dons> moin
20:04:50 <TheHunter> moin, dons
20:04:54 <TheHunter> let's see.
20:04:59 <TheHunter> @eval let filterFirst p (x:xs) | not $ p x = x : filterFirst p xs | otherwise  = xs; filterLast p xs = reverse (filterFirst p (reverse xs)) in filterLast (>0) (1:2:undefined)
20:05:00 <lambdabot> Prelude.undefined
20:05:05 <TheHunter> yep, bad.
20:11:10 <TheHunter> maybe you could start from |groupBy (const p) xs|
20:12:52 <Cale> heh, I've been writing too much GAP code. I saw "groupBy" and thought of the mathematical sort of group :)
20:16:42 <sh10151> at least you didn't think of sql
20:20:23 <TheHunter> hey thebug
20:20:29 <thebug> hey hey
20:20:40 <thebug> how's east lansing?
20:20:54 <TheHunter> it's ok.
20:21:27 <TheHunter> today at meijer's they wouldn't let me buy beer with my german id card and driver's license.
20:21:33 <metaperl> it's COLD! says a Los Angelian :)
20:21:54 <TheHunter> it's awfully hot, actually.
20:22:14 <thebug> yeah, michigan has been horribly hot this summer, like 32-34C all summer
20:22:24 <thebug> TheHunter: heh, silly meijer
20:23:10 <TheHunter> well, and some bastard stole my bike.
20:23:19 <metaperl> TheHunter: are you a soccer fan?
20:23:23 <thebug> yeah, welcome to east lansing
20:23:33 <thebug> I've had mine stolen twice
20:23:42 <thebug> they cut the lock right off
20:23:47 <TheHunter> exactly
20:24:06 <TheHunter> metaperl, not really, but i use to watch the games of our national team..
20:25:02 <Lemmih> Good morning, #haskell.
20:25:10 <TheHunter> what's with many .org domains often not resolving here?
20:25:33 <thebug> TheHunter: something stupid the network folk messed up recently, it's just an on-campus problem
20:25:49 <thebug> I'd dig up the network admin email, but I'm not at my home PC
20:26:31 <TheHunter> hehe.
20:26:48 <TheHunter> does it help to get a more expensive lock?
20:29:07 <thebug> TheHunter: I picked up a Master brand U-lock from meijer, I think they were about 18$ or so
20:29:15 <thebug> that seems to work ok *shrug*
20:29:50 <thebug> I'll have to check if my bike is still there next week, I've been travelling a bit more :)
20:30:07 <TheHunter> mine was a cable lock for $13, seemed reasonalbe for a $60 bike.
20:31:27 <thebug> yeah, I have a super-cheap bike, definitely 60$ or less ... people around there are idiots, what can I say
20:33:59 <thebug> well, I'm off for the night
20:34:02 * thebug waves
20:34:08 <TheHunter> see ya
20:34:42 <thebug> I'll be back in EL next week, maybe I'll catch up to you sometime
20:35:46 <TheHunter> oki, still got two easy-going weeks
22:27:40 <lispy> it seems silly that there is a Normal3, Vector3, Color3 and Vertex3 in hopengl.
22:29:02 <lispy> why not just have a GLTuple3
22:29:41 <lispy> I always have lookup which one i need to use, and it really doesn't make any difference in terms of type safety
22:31:58 <lispy> i also have to explictly say what the type of the tuple is, so I have tons of code that is Vector3 0 1 (0::GLfloat)
22:32:21 <lispy> and why GLfloat? was there really a reason to make it separate from float?
22:32:49 <Lemmih> I don't think it's always a float.
22:33:01 <lispy> Lemmih: right
22:33:06 <lispy> it could be GLint
22:33:15 <lispy> or one of the other GLfoo types
22:33:48 <Lemmih> type GLfloat = Float in my machine.
22:34:03 <Lemmih> s/in/on/
22:34:13 <lispy> ah, so it's just a synonym?
22:38:35 <lispy> Lemmih: do you feel like hopengl could be simplified?
22:38:43 <lispy> Lemmih: or am i way out in left field?
22:40:53 <Lemmih> I'm not sure. Haven't used it enough.
22:48:09 * dons plays with haskell-shell programs :)
22:49:15 <dons> paprika$ id Makefile | take -n 4 | map -e sort | reverse | nub | drop -n 1
22:49:16 <dons>  :abdilllu
22:49:16 <dons>  :aadefllltu
22:50:43 <dons> paprika$ id Makefile | take -n 4 | map -e "+(1::Int)" | reverse | nub | drop -n 1
22:50:46 <dons> map: compilation failed
22:50:49 <dons>     In the expression: (+ (1 :: Int))
22:50:49 <dons> hehehe
22:50:51 <dons>       Inferred type: Int -> Int
22:50:54 <dons>       Expected type: String -> String
22:58:39 <lispy> i put my IORefs at the top level so that I wouldn't have to pass them down the chain of called functions, but now it seems like writeIORef doesn't really change the value
22:59:16 <lispy> is that just life?
23:00:57 <dons> referential transparency? don't you need to wrap them in unsafePerformIO?
23:01:47 <dons> global = unsafePerformIO $ newIORef ()   ?
23:01:59 <dons> {-# NOINLINE global #-}
23:02:01 <lispy> oh, why?
23:02:41 <lispy> i'd really just like to have globals, it would make life so much easier...
23:03:02 <dons> they mess everything up though
23:03:34 <Lemmih> lispy: 'global = putStrLn "hello world"' will print "hello world" every time you run it, not just once.
23:04:12 <Lemmih> lispy: 'global = newIORef 0' will make a new IORef every time you run it.
23:04:15 <lispy> i have things like 'xrot = newIORef 0'
23:04:20 <lispy> yeah
23:04:24 <lispy> okay
23:04:26 <lispy> Lemmih: hanks
23:04:33 <lispy> er thanks, that makes a lot of sense
23:05:37 <lispy> is there a haskell pattern for having a big load of state that you don't want to explicitly pass around?
23:05:54 <Cale> yes, a state monad
23:06:01 <Cale> Or ST
23:06:03 <Lemmih> You can use a State/Reader monad or unsafePerformIO.
23:06:36 <Cale> ST is nice -- it gives you STRefs which are like IORefs, but you can runST to get back a pure value.
23:06:58 <Cale> it also allows things like mutable arrays
23:06:58 <lispy> Cale: that would be VERY nice...
23:07:22 <lispy> well,i have a good bookmark to monads, so i'll read up on ST monad
23:08:08 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control.Monad.ST.html and http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data.STRef.html are the relevant documentation
23:08:18 <lispy> Cale: so basically i'd have 'global = runST ( newSTRef () )' or similar?
23:08:47 <Cale> well, you encapsulate your whole stateful computation in the ST monad
23:08:57 <Cale> and runST at the end to provide a pure interface
23:09:19 <lispy> then why not just usethe IO monad?
23:09:30 <Cale> because you can have that pure interface :)
23:09:43 <Cale> with IO, you're trapped in the IO monad
23:10:00 <Cale> ST doesn't let you do IO, just carry around state variables
23:10:09 <Cale> but you can get out pure values
23:10:23 <lispy> what i would prefer is to be able to update a value from funtions without being forced to add that value to their formal parameters
23:10:29 <Cale> so it's handy for things like graph computations where there's lots of state hanging around
23:11:05 <lispy> i have a keyboard callback and i want to be able to update the camera state in that call back, and then use the camera state in my drawing function
23:11:50 <lispy> before i just did everything in the IO monad, created the IORefs there, and then passed them to the keyboard handler and the drawing function
23:12:06 <Cale> that sounds about right
23:12:10 <lispy> but i started getting up to about 8 parameters that I was passing to these functions
23:12:20 <Cale> you could bind them up into records
23:13:00 <lispy> yeah, it's still klunky.  I spend too much time adding params to those two functions
23:13:16 <lispy> every time i add a param I have to update all the patterns
23:13:28 <Cale> oh, not necessarily with record syntax
23:14:57 <lispy> plus this way of passing state around explicitly isn't going to scale as my drawing function and keyboard handler need to share morestate
23:17:08 <Cale> hmm...
23:18:12 <Cale> You don't think that adding some fields to a record type scales well?
23:18:34 <lispy> i'm not a huge fan of records
23:19:08 <Cale> what sort of state needs to be shared?
23:19:28 <Cale> Surely there should be some well-defined interface
23:19:32 <lispy> but i guess really, data World = World { global :: Foo, ... } is really about the only sane thing i can do...
23:19:37 <autrijus> lispy: ReaderT IO is my usual solution to this
23:19:59 <autrijus> (ReaderT World IO) to be exact
23:20:41 <autrijus> that way you can distinguish mutable state (IORef in the World record) and "dynamically rebindable" state
23:20:46 <Cale> you can do something like  global = unsafePerformIO $ newIORef 0, but that leads to insanity :)
23:21:26 <autrijus> Cale: not if you wrap it well under a ADT... after all Data.Unique does this
23:22:07 <Cale> I suppose you can encapsulate it in a module
23:22:20 <autrijus> right, and slap NOINLINE and -fno-full-laziness -fno-cse to that module
23:22:43 <lispy> autrijus: is this a sane place to get started? http://www.nomaware.com/monads/html/readermonad.html
23:23:09 <autrijus> lispy: I wrote about it a bit in
23:23:10 <autrijus> Using ReaderT in place of StateT IO
23:23:15 <autrijus> # http://www.haskell.org/hawiki/StateMonad
23:24:03 <Cale> I suppose you could also maintain a finitemap from strings to IORefs
23:24:22 <autrijus> that's assuming all your IORefs are of same type
23:24:27 <Cale> yeah
23:24:28 <autrijus> records are almost always safer
23:25:32 <Cale> I've never really run into the case where I don't know how much and what kind of state I'll need beforehand.
23:25:41 <autrijus> ditto.
23:26:45 <autrijus> except when I'm really writing non-IO functions, then ReaderT IO is suddenly not attractive
23:26:53 <lispy> i'm converting from C (that I didn't write) to haskell
23:26:57 <autrijus> in that case (linear) implicits could work.
23:27:27 <Cale> I've always thought implicit parameters were scary
23:27:28 <autrijus> lispy: oh... the unsafePerformIO trick may be most straightforward then.
23:27:38 <lispy> i need to run to the store, thanks for the urls i'll read them more closely wheni get back
23:27:45 <autrijus> but I'd still use ReaderT IO in the long run
23:28:05 <Cale> Especially for pure functions, I like to see where all the parameters are going.
23:28:07 <autrijus> Cale: it's just a cheap hack to write ST without a monad
23:28:11 <Cale> yeah
23:28:22 <lispy> autrijus: i'm avoiding unsafePerformIO on priciple
23:28:31 <Cale> Use of the ST monad is nicely visible though :)
23:28:45 <autrijus> lispy: you can rename it to runIO.
23:28:59 <Cale> heh
23:29:11 <autrijus> and really, there are well publicized ways to determine whether unsafePerformIO is used safely or not
23:29:20 <autrijus> and every other language let you violate it anyway
23:29:27 <autrijus> so I'm not sure what's the big deal :)
23:29:41 <autrijus> lispy: but if so, ReaderT IO is I think the most flexible solution
23:29:46 <lispy> i've used it in the past
23:29:53 <lispy> yeah
23:29:58 <lispy> i'll look atit
23:30:03 <lispy> gotta gotsome good tho
23:30:06 <lispy> er food
23:30:15 <lispy> and i can't type
23:30:27 <Cale> I like my violations of referential transparency to be very visible, and boxed off from the rest of the program.
23:31:30 <Cale> I hardly even use mutable variables of any sort in the code I write, unless there's really no obvious way around it.
23:31:44 <Cale> (even in languages where they are permitted)
23:32:13 <autrijus> ditto. nowadays I'd like to use the STM monad more than ST
23:32:25 <autrijus> granted, ST is nice because it can't interfere with each other
23:32:44 <autrijus> but STM's guarantee of selective atomicity (and no I/O inside it) is also very good.
