00:00:29 <palomer> man, I shouldn't be working this late
00:24:09 <lispy> dons: yi --as=mg, you can type right off the screen, but the redisplay doesn't update
00:24:59 <dons> yep. known yi issue. it dooesn't scroll the screen left or right
00:25:17 <lispy> hard to fix?
00:25:18 * dons should get around to fixing that 
00:25:26 <dons> fiddly
00:25:42 <lispy> i have yi --as=mg set as $EDITOR
00:25:54 <lispy> so when i use darcs i notice it :)
00:26:17 <dons> oh! ok, I'll up the priority
00:26:42 <lispy> or tell me how to do it
00:27:02 <lispy> i'd love to contribute more to yi, i just don't know what to hack other than the elisp interpreter i'm working on
00:28:03 <dons> its pretty low level, we need to check that the point is wider than the screen, recalculate where the cursor should be, and drop the screen to the left
00:28:46 <lispy> oh, another thing i noticed is that yi can be a bit slow when you paste a block of text
00:29:06 <lispy> nothing bad, but it was noticibly slower than vi or emacs
00:29:20 <dons> yeah, some old code calls mapM insert on chars, I should replacce that with the block insertion code
00:29:31 <dons> thanks for reminding me of that
00:29:56 <lispy> np, i like yi and have been uing it more and more and finding litle things that just need attention ;)
00:30:41 <dons> sure. there's a lot of code, so its good to have other people trying it out
00:32:46 <Heffalump> is it usable for real work now?
00:32:52 <dons> lispy, paste a block via a yank, or via the mouse?
00:33:04 <dons> Heffalump, apparently there are people using it, but I don't yet
00:33:26 <dons> i'm working on the syntax hightlighting today, so maybe soon i'll switch over
00:33:42 <lispy> dons: paste it via the mouse
00:33:56 <dons> ok. have to think about that. that's a  bit harder.
00:34:07 <lispy> Heffalump: i use it for things where I don't care about syntax highlighting
00:34:28 <dons> I should write an --as=less or --as=more mode
00:36:10 <lispy> i just sent in a patch to darcs that adds a post apply script hook
00:36:27 <lispy> not sure if that is of interest, but I've been needing it
00:36:57 <lispy> it needs a bit of work still, right now darcs doesn't send any information to the post apply command
00:39:12 <dons> lispy, oh! it doesn't seem that slow to paste to me
00:39:20 <dons> any further details that might complicate matters?
00:41:26 <dons> little slower than mg, and maybe just a little slower than vi, but it would be a big change to fix this, I think, for not much gain at the moment
00:41:50 <dons> unless you can give me a case that is really quite noticeably slower
00:42:15 <dons> oh, maybe long lines are slow
00:42:53 <dons> hmm. yes. I think I agree. a full screen of text is clearly being pasted char at a time
00:43:10 <lispy_> yeah, i pasted a "chunk" as it wree
00:43:15 <lispy_> s/wree/were
00:43:37 <lispy_> my machine may be slower than yours aswell
00:44:07 <lispy_> i'm on an ibook, and those aren't exactly known for performance ;)
00:44:20 <dons> I may be able to think up some optimisation here, basically there's an update after each char is pasted
00:44:24 <lispy_> bleh, it's almost 1am, so i have to get to bed....
00:44:30 <pejo> In Cmm - each basic block has a label (BlockId) and ends with a jump to another bblocks BlockId (?). I get the impression the bblocks are stored in a list, that might be rearranged in the nativeGen to make some jumps just fallthroughs.
00:44:52 <dons> becaues pasting looks just like normal typing to yi, its a little hard to work out when a block of self-inserted text is coming in
00:45:19 <lispy_> dons: ya
00:45:31 <pejo> Is this list considered to be an implicit CFG, or am I just somehow stuck in imperative style thinking?
00:46:25 <lispy_> dons: re: scrolling off the screen, i think emacs decides to jump when you get to the last column
00:46:45 <dons> that would be an easy way to solve it, I think. I'll do something like that
00:46:51 <dons> it seems to be the usual approach
00:46:58 <lispy_> dons: but also, if mg mode did line wrapping i would have never noticed :)
00:47:16 <dons> line wrapping is harder than scrolling right
00:47:20 <lispy_> heh
00:47:43 <lispy_> doesn't vi mode line wrap?
00:48:02 <dons> there's no way to do line wrapping in yi. the ui doesn't know how to do it
00:48:28 <dons> but it is also probably not to hard to figure out :)
00:48:45 <lispy_> i could have sworn long lines in vi mode just went to the next row on the screen
00:49:41 <lispy_> well, eitherway, past my bedtime ;)
00:49:45 <lispy_> see ya
01:02:01 <dblhelix> and so my battle with the type checker continues: I've just done a monster post on haskell-cafe... I'm curious what people will think about this
01:14:40 <poetix> http://gobby.0x539.de/ <- FOSS SubEthaEdit-a-like
01:25:34 <Cale> l
01:27:14 <boegel> hello everyone
01:27:31 <dblhelix> hi boegel: got some sleep?
01:27:32 <boegel> I've read (skimmed) the HWN, and I have a comment on it...
01:27:51 <boegel> dblhelix: yeah, sure, why shouldn't I ?
01:28:02 <boegel> <insert> have
01:28:11 <dblhelix> well, you mentioned being quite tired yesterday, iirc
01:28:32 <boegel> yeah, but that's just because I have to get up early again
01:28:37 <boegel> I'm not used to it anymore
01:28:43 <dblhelix> ah, okay
01:28:48 <boegel> who wrote the first issue of HWN ?
01:28:54 <boegel> @seen Itkovian
01:28:55 <lambdabot> I saw Itkovian leaving #haskell 6 days, 19 hours, 5 minutes and 37
01:28:55 <lambdabot> seconds ago, and I have missed 3 minutes and 35 seconds since then.
01:29:24 <dblhelix> boegel: CosmicRay and shapr, I think... for the most part anyway
01:29:54 <boegel> I think it's strange they put the references in between and before the item they are referring to
01:29:59 <boegel> doesn't read smooth
01:30:42 <dblhelix> boegel: yeah, that's got my eye to... didn't bother me that much, to say the truth, but it was at least remarkable
01:30:55 <dblhelix> /s/eye to/eye too
01:31:50 * dblhelix awakes at 5.15am these days, but is starting to get used to it
01:31:55 <dblhelix> *yawn*
01:32:02 <boegel> don't know why they did it, but my opinion is they should change that...
01:32:12 <boegel> I've had a terrible morning
01:32:42 <dblhelix> boegel: how come?
01:32:44 <boegel> train had 30min delay, and when I finally got to Ghent, I was sitting on the tram when it hit a car :s had to walk on foot
01:33:21 <dblhelix> boegel: well, it seems like your day can only get better then... ;)
01:33:23 <boegel> and usually, those things seem to extrapolate all through the day
01:33:33 <boegel> dblhelix: very true
01:33:40 <boegel> anyway, I should continue working
01:33:57 <boegel> still have no pc, so I'm fiddling around on some student pc again :)
01:34:03 <dblhelix> I should continue making war to the type checker
01:34:52 * boegel leaves again
01:45:02 <Wed24831> whats a proper way to generate a patch. I did a recursive diff between two directories....
02:09:59 <nothingmuch> does haskell have a templating (in the PHP/ASP/Template Toolkit sense of "template") library?
02:10:53 * boegel summons CosmicRay
02:10:58 <boegel> @seen CosmicRay
02:10:59 <lambdabot> I saw CosmicRay leaving #haskell 12 hours, 11 minutes and 11 seconds
02:10:59 <lambdabot> ago, and I have missed 2 minutes and 43 seconds since then.
02:11:03 * xerox unsummon PHP
02:11:08 <xerox> +s, even
02:11:17 * boegel prints to xerox
02:11:26 <xerox> bzzt
02:18:16 <boegel> yeah, it was bzzt, it was jammed :)
02:18:23 <boegel> do you have remote control or something ? :)
02:18:50 * xerox unplugs the power cable
02:20:18 * boegel watches as the alarms go off
02:22:39 <palomer> http://www.osnews.com/editor.php?editors_id=1 <--editor of osnews
02:23:12 <boegel> heh, a woman ! funny :)
02:23:42 * boegel poofs
02:26:27 <Muad_Dib> hehe
02:30:59 <palomer> someone entertain me
02:31:21 * Narrenschiff does a dervish dance!
02:32:06 <dblhelix> palomer: did you already have a look at the program I posted to haskell-cafe a few hours ago? not sure if you find it entertaining...
02:32:11 <palomer> oh you dastardly devil
02:32:49 <palomer> I'm not subscribed to the haskell-cafe
02:33:14 <palomer> in fact, there's something I don't like about haskell: knowing a term's type tells you nothing about the term!
02:33:43 <dblhelix> palomer: nothing is a bit too harsh, imho
02:34:00 <dblhelix> palomer: http://www.haskell.org//pipermail/haskell-cafe/2005-August/010949.html
02:34:02 <palomer> absolutely nothing
02:34:52 <dblhelix> palomer: if a term e has type Int -> Int, I know e is not \x -> chr x, for instance
02:35:10 <palomer> ok, you may know a little about what its not
02:35:17 <palomer> but you don't know what it is
02:35:42 <palomer> where's a term typed forall a. a->a should be the identity, and nothing else!
02:36:40 <dblhelix> palomer: well the free theorem you can derive from a term's type gives you some information on the behaviour of the term
02:38:05 <dblhelix> palomer: if a have a term of type forall a . a -> a -> Bool, for instance, I know the term has to either produce a constant or diverge
02:38:36 <palomer> is this from the free theorem?
02:38:56 <dblhelix> palomer: indirectly, yes
02:39:17 <palomer> hrm
02:39:20 <palomer> what is this free theorem
02:39:23 <palomer> it seems important
02:39:50 <dblhelix> palomer: http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
02:40:12 <dblhelix> palomer: you might want to read the "Theorems for Free!" paper
02:40:15 <palomer> oh my, it's too late(early?)
02:40:21 <palomer> oh yes, I have that paper on my desk
02:40:26 <palomer> is that where the free theorem comes from?
02:40:32 <dblhelix> palomer: yes
02:40:50 <palomer> i'll have to read it one of these days
02:41:03 <palomer> it talks about system F, which I'm familiar with
02:41:12 <palomer> but...system F has no bottom element
02:41:24 <dblhelix> palomer: well, iirc, the main idea is actually a bit older, but this is the one that is commonly referred to when talking about parametricity
02:41:48 <dblhelix> palomer: that's why I added the "or diverge" part :)
02:42:26 <palomer> and, erm, you can also do this with realizability
02:42:50 <palomer> quite simply, actually
02:42:55 <palomer> in fact, I can prove it to you right now
02:43:10 <dblhelix> I must be important: presidential widows from Congo are e-mailing me again
02:44:12 <palomer> don't pick up!
02:44:43 <dblhelix> palomer: really? :)
02:44:50 <palomer> yes
02:44:57 <palomer> do you _really_ _really_ want me to?
02:45:14 <dblhelix> :)
02:45:16 * dblhelix grins
02:45:19 <palomer> (I'll only do it if you're familiar with system F)
02:46:04 <dblhelix> palomer: I think I'm qualified
02:46:18 <palomer> ok, here goes nothing...
02:46:50 <palomer> call an interpretation I a function which sends formulas to sets of lambda terms such that:
02:47:17 <Wed24831> will adding strictness annotations only improve space usage or also speed ?
02:47:22 <palomer> |A->B|_I = {t : ta \in |B|_I for any a in |A|_I}
02:47:38 <dblhelix> Wed24831: the two are quite related in this matter
02:47:55 <Wed24831> because of the garbage collector?
02:48:00 <dblhelix> Wed24831: yes
02:48:13 <Wed24831> good
02:48:36 <palomer> |forall B . A|_I = intersection {|A|_I[B:=S]} where S is an arbitrary set of lambda terms
02:48:53 <palomer> I think thats it
02:49:03 <palomer> you can get tuples from that
02:49:05 <palomer> and disjunction
02:49:06 <dblhelix> palomer: please explain the previous expression:  interpretation of A -> B
02:49:11 <palomer> sure
02:49:33 <palomer> say the church numeral 1 is in |A| and 2 is in |B|, then s is in |A->B|
02:49:46 <palomer> so is K2 (the function which always returns 2)
02:49:51 <dblhelix> s being?
02:49:56 <palomer> the successor
02:50:07 <dblhelix> ah, okay
02:50:37 <palomer> we have eta and beta and alpha equivalence
02:50:52 <palomer> first theorem: |forall A. A->A| = {I}
02:50:54 <palomer> the identity
02:50:56 <palomer> proof
02:51:08 <palomer> oh, forgot to mention something
02:51:21 <palomer> if t is typed by A, then t is in |A|
02:51:24 <palomer> this is a theorem
02:51:34 <palomer> back to my first theorem
02:51:40 <dblhelix> palomer: I figured
02:51:51 <palomer> say t is in |forall A. A->A|
02:52:05 <lisppaste2> thou pasted "parsec: simple mbox" at http://paste.lisp.org/display/10451
02:52:24 <palomer> then t is in {x}->{x}
02:52:29 <palomer> so t x = x
02:52:37 <palomer> so \x. t x = \x.x by eta
02:52:47 <palomer> so t is = I
02:52:52 <palomer> err, eta goes on the next line
02:53:00 <palomer> now, back to our little formula
02:53:08 <palomer> forall a. a -> a -> bool
02:53:35 <palomer> t x x = T or t x x = F, so t = K K T or t = K K F
02:53:37 <palomer> end of proof
02:53:39 <palomer> cool huh?
02:54:06 <palomer> if you don't have eta things become pretty disgusting
02:54:12 <palomer> you also have other cool things
02:54:15 <palomer> like
02:54:34 <palomer> |forall a. (a -> (a -> a) -> a)| is the church numerals
02:54:37 <palomer> the proof is trivial
02:54:44 <dblhelix> I see
02:54:48 <palomer> did I lose you?
02:54:56 <dblhelix> now, I can follow you
02:55:06 * dblhelix still needs some time to digest though
02:55:16 <dblhelix> I'l read up on realizability
02:55:25 <dblhelix> but I can see what you are doing
02:55:29 <palomer> if you find any good papers, tell me
02:55:46 <dblhelix> still, have to convince myself of the validity of this way of reasoning
02:56:04 <palomer> it's pretty shocking the first time you see it
02:56:08 <dblhelix> but within the very system you are describing, it is actually quite clear
02:56:08 <palomer> you have to digest it
02:56:17 <palomer> wait till you get to higher order realizability
02:56:22 <palomer> things become...wicked cool
02:56:58 <palomer> like, the type will tell you _exactly_ what the function does
02:57:02 <thou> hi, i pasted a trial of using Parsec to split an mbox file into messages; it seems like it should be trivial, but i've been trying for hours; just learning Parsec, etc.  Can anyone take a look at it and give me a hint of how to do it?
02:57:15 <palomer> anyways, im off
02:57:16 <palomer> night
02:57:53 <dblhelix> g'night
02:58:02 * thou hopes he didn't just break up a good chat
02:59:12 * dblhelix has a look
02:59:15 <thou> thanks!
02:59:41 <lightstep> thou, i don't have haskell currently. what happens? infinite loop? parse error?
03:00:14 <thou> lightstep: at the moment, i'm getting parse error at (line 8, column 1): unexpected "F"
03:00:31 <thou> lightstep: if I take out the >> notFollowedBy (char 'F')
03:00:53 <thou> lightstep: then it gets unexpected eof (looking for eol)
03:02:36 <lightstep> without the >>notFollowedBy(char 'F') it doesn't make sense: it won't allow the eol in the P.between call
03:02:57 <lightstep> er, with it
03:03:53 <thou> i just can't figure out how to do this; I guess I could try forcing it to start with "From ", and then use sepBy (eol >> "From ")
03:04:06 <thou> but that seems like a bad hack - doesn't represent what i'm really looking at
03:04:12 <thou> and i'm not even sure that would work....
03:05:47 <thou> I wanted originally to say that mboxParser = endBy fromMessage eol
03:06:36 <Philippa_> eof rather than eol?
03:06:49 <thou> where fromMessage = (string "From ") >> aLine >> many aLine
03:06:54 <Philippa_> er, wait, no. Where'd you paste the code, anyway?
03:06:55 <thou> no
03:07:04 <thou> http://paste.lisp.org/display/10451
03:08:37 <Philippa_> are you getting in a mess over a lack of terminating EOL before EOF?
03:08:46 <vinny> .
03:09:12 <thou> Philippa_: i don't think so - i'm not worrying about that special case at the moment
03:09:25 <thou> Philippa_: (see the testMbox string at the end)
03:10:07 * dblhelix is off for lunch
03:10:27 <thou> I just have that eof test there so that it forces the whole mbox file to be parsed correctly
03:10:47 <lightstep> thou, aLine should use many1 perhaps?
03:11:01 <thou> lightstep: hmmm, maybe
03:11:02 * lightstep has no haskell env right now
03:11:15 <thou> lightstep: i did have that earlier, but i want aline to match a blank line, too
03:11:28 <thou> i.e., within a single message there are blank lines (\n\n)
03:12:23 <lightstep> so you want (bounded) backtracking
03:12:33 <thou> if I do many1, then it bails on the first blank line (line 5: unexpected "O")
03:12:50 <thou> right, which is what I was hoping to get with the notFollowedBy
03:13:14 <Philippa_> you know parsec commits to a parse if the first character matches unless you use try?
03:13:24 <thou> yes
03:13:35 <thou> kind of...
03:13:50 <thou> i tried sprinkling "try (foo)" through the code and didn't get anywhere :-)
03:14:15 <thou> and the notFollowedBy isn't supposed to consume any input
03:14:57 <Philippa_> do you know which of aLine and eol gets tried first by between?
03:14:57 * thou tries P.try (P.char '\n') >> P.notFollowedBy (P.char 'F')...
03:15:16 <thou> no difference there
03:15:16 <Philippa_> oh, wait, it's many aLine so it'll eat all the aLine it can get
03:16:08 <thou> Philippa_: yeah, so if I remove the notFollowedBy, it eats up to the eof and says error, unexpected end of input, expecting End of line
03:17:08 <thou> Philippa_: if you were going to do this from scratch, how would you structure it?  It seems like it should be very easy, but I've been staring at it too long....
03:17:10 <lightstep> thou, the eol in line 17 should have an 'F' after it
03:17:15 <thou> ok
03:17:36 <thou> lightstep: no, not at the last one!
03:17:48 <lightstep> sure, but on the second one
03:17:50 <lightstep> it does
03:18:06 <Philippa_> thou: I just got up, so I'd start by waiting a couple of hours...
03:18:13 <thou> Philippa_: hehee
03:18:27 <Philippa_> however, the main thing I'd sort out is getting the eols bit working fine...
03:18:45 <Philippa_> which means I'd probably have a parser for '\n' and one for "\nFrom "
03:18:51 <thou> lightstep: hmmm?  i'm sorry i don't understand you; i meant that the last e-mail in the file doesn't have an 'F' following the closing eol
03:19:32 <Philippa_> attempt the "\nFrom " before the "\n" where relevant (using try)
03:20:02 <Philippa_> then you just structure stuff so it doesn't have to end with a "\n" for the eof case - I suspect you really need an eol-or-eof parser
03:20:51 <lisppaste2> thou annotated #10451 with "slightly less simple parser" at http://paste.lisp.org/display/10451#1
03:20:58 <thou> that's a parser that i started with
03:21:05 <thou> and i trimmed it down to paste here
03:21:13 <thou> but the #1 version is the full one
03:21:49 <Philippa_> thou: you know you can use do /anywhere/ you'd use an expression?
03:21:52 <thou> it parses an mbox OK, as long as you don't have two consecutive blank lines
03:22:01 <Philippa_> eg try (do ...
03:22:04 <Philippa_>        )
03:22:05 <lisppaste2> lightstep annotated #10451 with "another try" at http://paste.lisp.org/display/10451#2
03:22:20 <Philippa_> and you can thus attach <?> etc to do statements
03:22:34 <thou> Philippa_: yeah, it's just ugly line breaks if they'll all fit on a line (still working out the style i like)
03:23:00 <Philippa_> using do a lot has the advantage that your code resembles EBNF
03:23:47 <thou> as opposed to resembling an omelette that's been dropped on the floor?
03:23:58 <thou> :-D
03:24:33 <lightstep> thou, i pasted a version which doesn't parse messages or handle eof correctly, but should word
03:24:37 <Philippa_> well, EBNF /is/ fairly idiomatic these days :-)
03:24:37 <lightstep> s/word/work/
03:24:48 <Philippa_> thou: got a grammar for the mbox format somewhere?
03:24:51 <Philippa_> if so, just port it
03:25:48 <thou> lightstep: it brings up an issue for me; notFollowedBy requires a Parser Char parser
03:25:58 <thou> (won't take a Parser String, for example)
03:26:37 <thou> i tried implementing something similar with     try (eol >> fromLine >> unexpected "New from line")
03:26:53 <Philippa_> write a generic notFollowedBy?
03:26:59 <thou> but i'm not sure i was successful
03:27:30 <Philippa_> it's just a matter of trying the parm and failing if it succeeded. Oh, and finding a suitable null value to return, but () should do, right?
03:28:35 <thou> Philippa_: with just Parsec.fail ()?
03:28:46 <thou> instead of Parsec.unexpected ?
03:29:22 <lightstep> fail would need a "" or [], not ()
03:29:34 <thou> ok
03:30:36 <Philippa_> I think there's a pfail that works
03:30:52 <lightstep> pzero?
03:31:02 <lightstep> sorry
03:31:23 <lightstep> vim/mouse miscoordination
03:32:12 <thou> brb
04:01:05 <joelk> Lemmih: ping
04:12:19 <autrijus> hm, what's the Haskell equivalent of a symbol (lightweight immutable constant string)?
04:12:43 <autrijus> just String?
04:13:24 <autrijus> or PackedString? Ptr PackedString?
04:23:16 <vegai> perhaps a new type?
04:24:01 <vegai> an algebraic one, even
04:24:57 <autrijus> hm, I'm thinkint about underlying storage
04:25:11 <autrijus> not neccessarily typing
04:25:30 <SuperNewb> why :l QuickCheck doesn't work in GHC v6.4 Win32 ?
04:26:23 <SuperNewb> @i QuickCheck
04:26:24 <lambdabot> bzzt
04:27:12 <shapr> SuperNewb: Debug.QuickCheck?
04:27:21 <autrijus> Test.QuickCheck
04:27:46 <SuperNewb> ah, ok, it works
04:27:49 <autrijus>  :m + Test.QuickCheck
04:28:07 <autrijus> is the canonical way (afaik) to load it
04:28:51 <SuperNewb> I am doomed, because in Hugs it is QuickCheck, and I need to use both; so I'll be spending my time switching that line in my modules :S
04:29:11 <autrijus> hugs does Debug.QuickCheck or Test.QuickCheck too
04:29:12 <autrijus> no?
04:29:14 <SuperNewb> ah, in Hugs Test.Q.. works too
04:29:19 <autrijus> I thought they all went hierarchical
04:43:43 <SuperNewb> is there a version of (mod) that can be used for Floats ?
05:08:39 <vegai> just wondering... why is Main of type IO () instead of e.g. IO Integer?
05:08:57 <xerox> vegai: you can do main :: IO Integer
05:09:05 <vegai> oh, right
05:09:11 <vegai> nevermind then
05:09:22 <Lor> Why is java's main method's return type void?
05:09:46 <xerox> It's more main :: IO a.
05:09:46 <Beelsebob> because Java runs in a VM, not on a unix box
05:10:05 <Lor> Err.
05:10:17 * Lor fails to see the relevance of that.
05:10:40 <Beelsebob> It means that Java programs don't need to exit with a status number
05:11:02 <Beelsebob> if they throw exceptions then the VM throws out an error status
05:12:58 <Lor> Uh, you are aware of System.exit()?
05:13:14 <Lor> This is purely an interface issue.
05:14:08 <Lor> A program interacts with the external environment, and it's just a question of interface design, what interaction is done using a "functional" interface (arguments to main, main's return value), and which bits require imperative operations.
05:16:31 <vegai> Lor: ?
05:17:23 <Beelsebob> lor: indeed
05:17:33 <Lor> vegai, please elaborate your query. :)
05:17:47 <Beelsebob> my point was that posix says you pass in the program name, and it's arguments, and a count of the arguments
05:17:52 <Beelsebob> and you pass out a status code
05:18:01 <vegai> Lor: was that related to my question?
05:18:10 <Beelsebob> Java doesn't pretend to immitate posix
05:18:38 <Lor> That goes without saying, since posix only specifies C interfaces.
05:18:59 <Beelsebob> so why then would you expect java's main method to return anything?
05:19:40 <Lor> Since java has a System.exit() call that passes a return status, it's clear that java's view of the runtime enviroment is one where a program does provide a status value when it terminates.
05:19:52 <Lor> It would be quite reasonable that this value were provided by the main method upon exit.
05:20:04 <Lor> However, now it requires a separate method call.
05:21:10 <Lor> There's nothing deep here. In java, and pretty much everywhere else, a program gets arguments and returns an integer status. It's a de facto standard across operating systems (thanks to C legacy, no doubt).
05:21:16 <Beelsebob> well no, not really... because system.exit may be just a way of telling the VM of the program's status
05:21:40 <Beelsebob> and no it obviously isn't the de-facto standard... because Java doesn't
05:22:42 <Lor> It does. It just does it with a different interface.
05:22:53 <vegai> highly interesting
05:23:10 <Beelsebob> no... it just gives you the option of throwing something out
05:23:22 <Beelsebob> I mean, by your logic a Java program returns an exception
05:23:29 <Beelsebob> because if I throw an exception
05:23:34 <Beelsebob> and never catch it
05:23:42 <Beelsebob> it gets thrown up to the VM level
05:24:09 <Lor> In Java, there is a method int Process.exitValue(). Clearly Java's notion of processes is one where it provides an integer value upon exiting.
05:24:26 <Beelsebob> so?
05:24:32 <Beelsebob> That doesn't make main return one
05:24:34 <Philippa_> where it /may/...
05:24:46 <Beelsebob> remember the *process* is the VM, not the program inside it
05:24:49 <Lor> It returns int, not Maybe int. :)
05:25:13 <Philippa_> Lor: not on the hypothetical JVM I'm thinking of. There the exitValue gets flushed because there's nothing to receive it
05:25:14 <Beelsebob> Lor: it probably returns -1 or some other default if nothing was returned by the program
05:25:49 <Philippa_> in those environments where an exit value makes any sense
05:26:38 <Philippa_> Java's model's probably closer to "this is a useful thing on many platforms, let's support it where available"
05:27:00 <Lor> This is rather a silly conversation. There's no real disagreement about anything, but we're just arguing for the heck of it.
05:27:16 <Beelsebob> hehe, probably
05:27:22 <CosmicRay> Lor: those are the best, aren't they? ;-)
05:27:34 <Lor> If your point is simply that main may be called for other purposes than providing the entry point for the _process_, then sure, so it can. The same holds for main in C and in many other languages, of course.
05:27:57 <Beelsebob> cosmic: no, the ones where someone disagrees with you for no apparent reason are better
05:28:00 * Beelsebob ducks
05:28:09 <CosmicRay> Beelsebob: ahh, like you just now? ;-)
05:28:16 <Beelsebob> hehe
05:28:20 <Lor> And yes, a single OS process can support multiple sandboxes, each of which hosts a separate Java program.
05:28:49 <Lor> However, in this case System.exit() should probably just halt a single sandbox, not the entire OS process.
05:31:56 <boegel> @seen Itkovian
05:31:57 <lambdabot> I saw Itkovian leaving #haskell 6 days, 23 hours, 8 minutes and 39
05:31:57 <lambdabot> seconds ago, and I have missed 3 minutes and 35 seconds since then.
05:32:02 <boegel> @seen CosmisRay
05:32:03 <lambdabot> I haven't seen CosmisRay.
05:32:10 <CosmicRay> well.
05:32:12 <boegel> @seen CosmicRay
05:32:13 <lambdabot> CosmicRay is in #haskell. Last spoke 2 seconds ago.
05:32:21 <CosmicRay> weird.
05:32:42 <boegel> can't see a list of people online, i'm ircing in a shell box :)
05:32:55 <CosmicRay> /names #haskell doesn't work for you?
05:33:11 <boegel> yeah it does, but the list is quite long :p
05:33:14 <CosmicRay> heh
05:33:22 <boegel> CosmisRay: didn't read my mail ?
05:33:33 <CosmicRay> I got it, yes, just haven't gotten around to replying to it
05:33:36 <CosmicRay> should I just reply here? ;-)
05:33:55 <boegel> I always reply directly, else I just forget :)
05:34:09 <boegel> you can explain your choices to me here yeah, sure
05:34:21 <CosmicRay> so anyway, this being the first issue, the formatting isn't all hashed out yet.
05:34:34 <CosmicRay> the text version was made by using elinks -dump and then manually editing that a bit.
05:34:48 <CosmicRay> I hope to have a HaXml-based transformer ready by issue 3
05:35:25 <CosmicRay> the references being before the words was because that's how elinks does it, which is in turn probably that way because that's how lynx does it, which is probably that way because that's how the first web browser ever did it ;-)
05:35:38 <CosmicRay> I'm certainly not attached to it, and didn't even notice until right before I sent it out
05:35:52 <CosmicRay> I'd probably prefer to do it after the words as well.
05:36:31 <CosmicRay> as for putting the links between the paragraphs, my assumption is that most people will be following links from several stories.  it's annoying to have to scroll down to the end, find the number, then scroll back up to continue reading
05:36:36 <CosmicRay> so that part was intentional
05:36:50 <CosmicRay> the formatting was inspired by the Debian Weekly News.  Here's an example of their formatting;
05:36:53 <CosmicRay> http://lists.debian.org/debian-news/debian-news-2005/msg00030.html
05:37:01 <CosmicRay> I'm curious if you like that any better.
05:37:34 <CosmicRay> I've been reading DWN for several years now and really appreciate the links between stories.  but it may perhaps make sense to group all the new releases links at the end of the new releases section though
05:37:35 <boegel> I can follow the part about the references, now I know way, I think you should keep it this way
05:37:44 <boegel> but the numbers are just annoying
05:37:52 <boegel> "and [3] ..." wtf ? :)
05:37:57 <CosmicRay> being between the stories you mean?
05:38:04 <CosmicRay> oh, the numbers in the text.
05:38:07 <boegel> yeah
05:38:21 <CosmicRay> you'd prefer them to be after the word that's hyperlinked...  I agree.
05:38:26 <boegel> I'm used to reading it behind the 'subject', and I think a lot of people are
05:38:28 <CosmicRay> it's just a matter of time to write a tool that does that.
05:38:35 <boegel> ah, okay then :)
05:39:21 <boegel> it's just confusing otherwise, unless you want to stick to the DWN and such
05:39:22 <CosmicRay> the DWN HTML-to-text tool is a mean, nasty, ugly, annoying, bad Perl script that parses the output of lynx -dump and rearranges the references to appear between stories.  I could not make it work with HWN, but no matter, it still puts the reference numbers before the hyperlinked word.
05:39:36 <CosmicRay> no, I'm not set on emulating DWN
05:39:42 <CosmicRay> it's an inspiration, nothing more
05:39:55 <CosmicRay> IOW, steal the good ideas and ignore the bad ones ;-)
05:41:36 <CosmicRay> one major thing HWN has that DWN doesn't is categories of stories.  I think it makes a lot of sense to group things together under toolchain news, darcs corner, etc.
05:42:08 <boegel> true, that was quite usefull
05:42:28 <boegel> I'm going to keep reading these letters, as I want to grow into the community a bit
05:43:19 <CosmicRay> anyway, thanks for your comments.  If you would like to write a translator, I'd accept it ;-)
05:45:21 <musasabi> How are people currently using Cabal with the foreign export functions?
05:46:23 <musasabi> It seems that my options are either scrapping cabal, or addind the stub to the archive by hand killing anything resembling portablity (even between unix flavours)...
05:47:03 <ski> HWN = Haskell Weekly News ?
05:47:18 <CosmicRay> yup
05:47:24 <ski> not online yet ?
05:47:35 <boegel> CosmicRay, I'm afraid I have no time
05:47:39 <CosmicRay> ski: posted yesterday to the haskell mailing list; also posted on sequence.complete.org/hwn
05:47:42 <boegel> ski: Haskell mailing list !
05:48:01 <ski> heh, haven't checked that today
05:48:38 <CosmicRay> boegel: no problem.  The location of the numbers will be fixed once I get my own html-to-text translator going.  as for the URLs, I'd like to see what others think about those -- I've found them fairly useful that way
05:49:15 <Igloo> What about the URLs?
05:49:33 <CosmicRay> Igloo: boegel was suggesting listing them all at the end of the text version, instead of after each story
05:49:50 <Igloo> Ah
05:49:54 <Igloo> I think after each story is better
05:50:06 <CosmicRay> that's what I'm thinking too
05:51:33 <shapr> @seen simonpj
05:51:34 <lambdabot> I haven't seen simonpj.
05:51:56 <CosmicRay> morning shapr
05:52:01 <shapr> g'day CosmicRay
05:52:14 <beelsebo1> last time I saw SPJ was when I was 5 I think
05:52:23 <CosmicRay> JaffaCake: btw, thanks for the LWN suggestion.  They accepted HWN for listing and gave me a template to use to submit it to them each week.
05:52:25 <shapr> When you were five years old?
05:52:39 <JaffaCake> CosmicRay: great news!
05:52:53 <shapr> It's been a few years since simonpj was on #haskell
05:53:00 <JaffaCake> was he ever?
05:53:12 <shapr> Yeah, both of you were here once.
05:53:21 <JaffaCake> heh, don't remember that
05:53:42 <JaffaCake> I don't think he has an irc client installed nowadays
05:53:46 <beelsebo1> shapr: yes
05:53:52 <ozone_> @seen ChilliX
05:53:54 <lambdabot> I haven't seen ChilliX.
05:53:55 * boegel leaves again
05:53:57 <ozone_> @seen Chilli
05:53:58 <lambdabot> I haven't seen Chilli.
05:53:59 <shapr> The channel was much more newbie oriented at the time, I don't think it was that interesting to GHC authors :-)
05:54:22 * JaffaCake likes to keep an ear to the ground
05:54:28 <CosmicRay> shapr: aren't most of us newbies compared to GHC authors? ;-)
05:54:32 <beelsebo1> shapr: When he worked in St Andrews... I met him at one of my dad's birthday parties
05:54:33 * shapr prefers a pillow between ear and ground.
05:54:38 <shapr> beelsebo1: neato
05:54:54 <beelsebo1> sharp: not really... I was 5, and he was a guy with no socks
05:54:59 <beelsebo1> *g*
05:55:07 <shapr> CosmicRay: Not so much these days. At the time most #haskell regulars couldn't use monads.
05:55:34 <shapr> beelsebo1: SPJ is famous for quickly getting comfortable once he starts talking.
05:55:35 <CosmicRay> ah.  well I grok about two of them.  still a weak area for me.
05:55:40 <beelsebo1> shapr: couldn't or wouldn't?
05:56:16 <JaffaCake> beelsebo1: he's still a guy with no socks :)
05:56:21 <shapr> beelsebo1: At the time, couldn't. Igloo, Heffalump, dennisb, and wli were the clueful ones who repeatedly explained stuff to everyone else.
05:56:30 <beelsebo1> jaffa :)
05:57:08 <beelsebo1> I seem to remember being very puzzled over the lack of socks
05:57:08 <shapr> At HW2005, SPJ took off his sweater, untucked his shirt, took off his shoes and energetically gave his talk.
05:57:57 <shapr> er, hw2003
05:58:01 <shapr> wrong year, sheesh
05:58:04 <CosmicRay> what's hw?
05:58:09 <shapr> Haskell Workshop
05:58:20 <shapr> I'd like to get to CUFP, anyone want to donate money? ;-)
05:58:36 <CosmicRay> is it in estonia every year?
05:58:47 <shapr> Nah, moves around the world.
05:58:59 * xerox hopes for Italy
05:59:01 <shapr> Utah last year, Uppsala year before.
05:59:01 * JaffaCake is looking forward to the HW this year
05:59:08 <Igloo> It alternates between America and Europe, I think
05:59:35 <Igloo> Me too  :-)
05:59:45 <CosmicRay> maybe I can go next year.  It's been about 5 years since I've been to technical conferences of any sort.
06:00:01 <CosmicRay> I'll start working on ways to get work to pay for me to go ;-)
06:00:08 <shapr> ICFP isn't exactly a technical conference, at least, it's nothing like EuroPython.
06:01:04 <JaffaCake> it's not a technical conference?
06:01:33 <JaffaCake> always seems pretty technical to me :)
06:01:41 <shapr> JaffaCake: Have you been to any open source conferences?
06:01:48 <JaffaCake> nope
06:01:54 <shapr> I don't know how to describe the difference between ICFP and EuroPython.
06:02:20 <CosmicRay> ICFP is more academic, right?
06:02:30 <shapr> Seems that way to me.
06:02:48 * CosmicRay needs to start working on SyntaxNinja to start up AmeriHaskell or something
06:02:57 <shapr> For example, you never get OSS conference presentations for software that isn't available.
06:03:02 <Philippa_> somebody suggested I should turn my second Impure Thoughts article into a paper for ICFP...
06:03:05 <CosmicRay> heh
06:03:13 <kowey> anyone going to ESSLLI, btw?
06:03:38 <kowey> http://www.macs.hw.ac.uk/esslli05/
06:04:09 <shapr> I think OSS conferences focus on the software that's been produced, and ICFP focusses on the ideas and measurements produced.
06:04:42 <Wed24831> hmmm, this is bad. what can i assume about a function call to a function for which i dont have the definition.....
06:05:02 <Wed24831> to be safe i must assume it writes/reads globals, does IO etc :D
06:05:46 <CosmicRay> well you can always find its type
06:05:56 <CosmicRay> that ought to tell you.
06:06:01 <CosmicRay> globals in haskell? ;-)
06:06:04 <Philippa_> even that's not quite sufficient in the presence of unsafePerformIO, admittedly
06:06:16 <Philippa_> globals in GHC-Haskell're plenty possible
06:06:18 <CosmicRay> true, but that would be a fairly extraordinary case
06:06:30 <Philippa_> yeah. As would the resulting murder
06:06:38 <Wed24831> uhm yeah i forgot to mention that im analysing a c function with my haskell app
06:06:48 <CosmicRay> yes but if you have an opaque function, obviously written earlier, it couldn't really access anything in your module
06:06:49 <CosmicRay> ah.
06:06:52 <CosmicRay> heh
06:06:58 <Wed24831> basically i must assume the worst to be safe...which is that everything's fucked in that function hehe
06:06:59 <CosmicRay> in that case, you can assume nothing ;-)
06:07:01 <ndm> Wed24831, you can't even assume that it doesn't trample the memory and your return address
06:07:28 <CosmicRay> for all you know, it may spew out porn on the office printer ;-)
06:07:40 <Wed24831> hmmm, i might run that function after all
06:07:47 <CosmicRay> haha
06:09:25 <Wed24831> it's going to be annoying for the user to fill in the blanks in my analysis hehehe
06:10:56 <Wed24831> ow wait, i *can* assume something...it cant be messing with globals, because it is a function outside the app
06:11:14 <CosmicRay> well, it can't be messing with your globals.
06:11:20 <CosmicRay> who knows that other globals it messes with.
06:11:27 <Wed24831> unless i pass them as parameter though
06:12:03 <Wed24831> yeah absolutely, if it does some shit with other globals, im still fucked haha
06:12:08 <Philippa_> or it just does something flat-out stupid
06:12:18 <Philippa_> (in which case, any memory not protected by the OS is at risk)
06:13:12 <Wed24831> im facing a shitty problem here...because even if the user says to me...ok this function is threadsafe...i will still need to know which variables are written and read in that function....
06:13:19 <Wed24831> i.e. the user has to provide that info
06:13:24 <Wed24831> but i dont see any other way
06:15:38 <Wed24831> if i want to keep my analysis results correct
06:17:53 <dblhelix> shapr: do you still update your del.icio.us list?
06:33:02 <shapr> dblhelix: Yeah, I've just been distracted lately.
06:38:27 <shapr> dblhelix: What's your del.icio.us username?
06:38:44 <dblhelix> shapr: I don't have one
06:39:39 <dblhelix> I do blog, but that's just about it
06:39:56 <dblhelix> (lack of discipline)
06:44:28 <shapr> dblhelix: Where's your blog?
06:45:10 <dblhelix> @google holdermans weblog
06:45:12 <lambdabot> http://www.cs.uu.nl/people/stefan/blog/
06:46:54 <shapr> neat
06:53:20 * dblhelix gotta go
06:53:24 <dblhelix> bye!
06:55:08 <Wed24831> bye
06:55:09 <Wed24831> :P
07:13:11 * shapr sings the ponytail song
07:13:43 <Matt-W> the ponytail song?
07:13:59 <shapr> Well, someone named ponytail joined here.
07:14:06 <Matt-W> and left
07:16:14 <Matt-W> I want to do some Haskell again
07:16:21 <Matt-W> and more than just adapting my spam filter trainer from mbox to maildir
07:24:39 <CosmicRay> Matt-W: how can we help?
07:27:48 <Matt-W> CosmicRay: give me an extra five hours in the day?
07:28:11 <Wed24831> get up 5 hours early then :)
07:28:29 <Matt-W> hmmm
07:28:31 <Matt-W> ummm
07:28:31 <Matt-W> no
07:28:51 <Matt-W> I'll have to have another look at gtk2hs on amd64
07:29:03 <Matt-W> if that's vaguely working I should be able to find something useful to do
07:31:16 <kowey> do the suffixes
07:31:29 <kowey> _daS0 and _daSS mean anything to anyone?
07:34:48 <vikasg> evening, #haskell
07:35:49 <CosmicRay> what is the proper way to determine the alignment of a C struct for the purposes of creating an instance of Storable?
07:39:41 <CosmicRay> hi vikasg
07:40:12 <vikasg> hey CosmicRay
07:42:26 <Matt-W> hi
07:42:40 <CosmicRay> hi matt-w
07:50:49 <Wed1689> damnnnn rain is keeping me on work
07:52:23 <basti_> hi
08:07:48 <Lemmih> @seen joelk
08:07:49 <lambdabot> I saw joelk leaving #haskell 3 hours, 3 minutes and 9 seconds ago.
08:15:02 <basti_> hmm
08:15:18 <basti_> i'm using show on Char, and it returns something like "'a'"
08:15:27 <basti_> i do not want the '. What do I do?
08:17:21 <Lemmih> showLitChar
08:17:31 <Lemmih> @plugs showLitChar 'a' ""
08:17:36 <lambdabot> "a"
08:17:50 <basti_> hmm
08:18:14 <basti_> i mean i would love to use show, but i don't want to see the ''. They don't show up in other types as well
08:18:46 <Lemmih> Well, you can't use show for that.
08:18:49 <ndm> i have a special show defined
08:18:53 <basti_> :/
08:18:56 <ndm> showNoChar
08:19:02 <ndm> its kind of a hack though
08:19:30 <ndm> showNoChar x = case show x of {['\'', y, '\''] -> y; y -> y}
08:19:41 <basti_> ugh.
08:19:50 <ndm> but in reality its pretty good
08:19:53 <basti_> ,)
08:20:56 <basti_> I'll just use it for now
08:22:09 <ndm> if you do come up with soemthing nicer and less hacky, let me know
08:23:04 * basti_ nods
08:23:22 <nothingmuch> i'm having some trouble with identity of data in haskell
08:23:37 <basti_> nothingmuch: why?
08:23:40 <nothingmuch> i'm trying to show a cyclic structure
08:23:53 <nothingmuch> by making show a recursive function that keeps a map of seen items
08:24:00 <basti_> :-o
08:24:16 <nothingmuch> sounds fun, doesn't it?
08:24:38 <basti_> well. if that is fun for you :)
08:24:41 <nothingmuch> this is really more on the behavior of derived Eq
08:25:29 <arjanb> i think the derived Eq doesn't check for cyclic stuctures
08:25:47 <nothingmuch> okay, i'll hack an Eq that suits my purposes then
08:26:55 <Lemmih> @type GHC.Exts.reallyUnsafePtrEquality#
08:26:56 <lambdabot> forall a.
08:26:56 <lambdabot>              a -> a -> GHC.Prim.Int#
08:27:28 <nothingmuch> where can I find a reference of type classes and what I have to define for them to be instantiated?
08:27:57 <basti_> nothingmuch: ?
08:27:58 <Lemmih> nothingmuch: You can type :info [ClassName] in GHCi.
08:28:19 <basti_> do you mean a specific typeclass, or typeclasses in general?
08:28:19 <nothingmuch> okay
08:28:23 <nothingmuch> that looks good
08:28:24 <nothingmuch> thanks!
08:28:26 <basti_> ah
08:29:34 * nothingmuch wonders if maybe he can cheat:
08:29:47 <nothingmuch> can I unsafely get a pointer to the structure in question?
08:29:57 <nothingmuch> as a sort of temporarily possibly unoique integer?
08:30:38 <Lemmih> That's what you have now.
08:30:57 <nothingmuch> Lemmih: ?
08:31:30 <basti__> how cool.
08:31:31 <nothingmuch> i meant: can i unsafely get the integer value of *the* not just a pointer to a structure
08:31:59 <Lemmih> nothingmuch: How about using reallyUnsafePtrEquality# instead?
08:32:04 <JaffaCake> nothingmuch: you shouldn't really do that
08:32:09 <nothingmuch> oh, that's what that was =)
08:32:25 <nothingmuch> JaffaCake: this is not a permanent solution
08:32:29 <JaffaCake> the right way is to put an explicit unique into each node
08:32:39 <CosmicRay> question on hsc2hs and peek/poke... I have this structure:
08:32:53 <CosmicRay>             typedef struct ldapmod {
08:32:54 <CosmicRay> ...
08:32:59 <CosmicRay>                 union {
08:32:59 <CosmicRay>                  char **modv_strvals;
08:32:59 <CosmicRay>                  struct berval **modv_bvals;
08:32:59 <CosmicRay>                 } mod_vals;
08:33:00 <CosmicRay> ...
08:33:04 <CosmicRay> } LDAPMod;
08:33:18 <CosmicRay> how would I use #poke to push my array into modv_bvals?
08:33:33 <CosmicRay> or rather, a pointer to my array, of course.
08:34:39 <JaffaCake> you could ignore the union, and pretend that mod_vals is the pointer field?
08:35:03 <CosmicRay> would hsc2hs grok that?  If so, that would appear to work.
08:35:14 <CosmicRay> since they're both pointers, shouldn't have any funky length-of-datatype issues to worry about
08:35:22 <JaffaCake> sure, hsc2hs just knows how to get the offset of a field
08:35:41 <CosmicRay> I assume it has to get the size of the field for #poke, yes?
08:35:53 <CosmicRay> I guess in this case it would be essentially sizeof mod_vals?
08:35:55 <Igloo> Why do you have to ignore the union?
08:37:06 <JaffaCake> Igloo: well you don't have to, I just figured it would be easier
08:37:29 <JaffaCake> is this in a Storable instance?
08:38:41 <CosmicRay> no
08:39:17 <nothingmuch> Lemmih: how do i import that? GHC keeps telling me about parse errors =)
08:39:24 <JaffaCake> I supose, strictly speaking, you should use #ptr to get the offset of the union, and then #poke into that
08:39:39 <CosmicRay> or just poke, not #poke, I assume?
08:39:47 <CosmicRay> or does #poke understand unions?
08:40:02 <JaffaCake> think so, haven't tried
08:40:38 <CosmicRay> frankly, I can't quite wrap my head around proper no-leak memory handling when having Storable instances that require allocating memory to do a poke
08:40:52 <CosmicRay> such as structs that have pointers to C strings or C string arrays
08:41:08 <CosmicRay> so I am writing functions in the style of newCString
08:41:39 <CosmicRay> obviously can't use alloca/with* functions with poke
08:43:22 <CosmicRay> also I couldn't figure out any automated way to get correct values for alignment
08:43:38 <JaffaCake> if it's a C struct, then surely somebody has responsiblity for freeing it, so you just malloc(), right?
08:44:12 <CosmicRay> I'm building up these C structs from Haskell, so I'd be left with writing a Haskell function to free it.  (I'm using mallocBytes in Haskell)
08:44:17 <Lemmih> nothingmuch: You probably shouldn't be using it.
08:44:27 <CosmicRay> so once I'm there, I don't really see any benefit over just using newCString functions
08:44:46 <CosmicRay> it would be so easy to do a poke without realizing that it implicitly allocated memory
08:44:50 <nothingmuch> Lemmih: this is a very temp. solution, i'd like to try
08:45:31 <Lemmih> nothingmuch: Use -fglasgow-exts and import GHC.Base.
08:46:10 <nothingmuch> oh, that's it
08:53:04 <basti_> yow. my code looks like perl now.
08:53:19 <CosmicRay> ouch
08:55:21 <basti_> completeInput s = replaceInput (Just $ Left $ inp ++ (fst $ obvious $ snd $ complete (getCompletion s) inp)) s
08:55:30 <basti_> y.u.c.k.
08:56:39 <CosmicRay> at least it doesn't look like Java.
08:56:50 <CosmicRay> <-- resident Java basher
08:57:39 <Muad_Dibber> hey
08:57:47 <CosmicRay> hi Muad_Dibber
08:57:51 * Muad_Dibber likes java where haskell is not allowed :P
08:58:16 <basti_> much prettier now
08:58:17 <CosmicRay> Muad_Dibber: try reading a line of text from the keyboard in 80 characters or less of Java.  Mwahahahahaha.
08:59:04 * CosmicRay prefers making Haskell available where it isn't ;-)
08:59:12 <CosmicRay> and, failing that, Python.
08:59:18 <Muad_Dibber> like a minimum numbers of characters is always what we want :)
09:00:16 <CosmicRay> obviously Java programmers don't care about carpal tunnel
09:01:15 <CosmicRay> but still, I think you have to instantiate something like three or four classes just to read from the keyboard
09:01:18 <CosmicRay> long and complex
09:03:28 <CosmicRay> it is a simple example of the problem that is pervasive in Java
09:03:42 <CosmicRay> that is, overly-complex APIs, and all sorts of annoying type-checking hoops.
09:04:35 <CosmicRay> though having said that, I think it would be nice if Haskell would integrate potentially thrown exceptions into the type checker.
09:09:02 <basti_> :-o
09:09:14 * basti_ is getting the strangest errors.
09:11:40 <musasabi> CosmicRay: I think that causes much more trouble than it is worth.
09:12:01 <CosmicRay> which, Storable instances?
09:12:14 <musasabi> But extensible exception types would be nice.
09:12:25 <musasabi> CosmicRay: the exception specification thing.
09:12:30 <CosmicRay> ah.
09:12:48 <CosmicRay> could be.  it was nice to know what exceptions something could raise though.
09:13:42 <musasabi> well it can allways throw exceptions one is not expecting.
09:13:49 <musasabi> *always
09:13:56 <Igloo> It's complicated by a suspension's ability to throw an exception when evaluated
09:15:17 <musasabi> CosmicRay: also consider that foo and let x = foo in x `seq` x would have different exception specifications.
09:17:28 <thedward> Is there any easy way to read a file in as a list of Word64 ?
09:19:35 <basti_> yow.
09:19:38 <basti_> my completion works.
09:19:58 <basti_> not complete yet (ha. ha.) but it does what it is supposed to.
09:20:12 <basti_> no puns about completing completely now.
09:25:10 <kowey> http://photos1.blogger.com/blogger/5532/1215/1600/unicode_wxhaskell.jpg
09:25:15 <kowey> yippee!
09:25:45 <kowey> thanks JaffaCake and tuomov for the unicode help
09:33:17 <musasabi> thedward: you could read it to a (Ptr Word8) use castPtr and then peekList.
09:35:40 <thedward> musasabi: hm. yeah, I was hoping to avoid that kind of thing.
09:36:50 <musasabi> The binary library (at cryp.to) might make it easier.
09:39:36 <thedward> ah. yes. that might work indeed. thanks.
09:39:56 <basti_> dons are you there?
09:41:14 * basti_ just submitted a new pat to yi
09:41:15 <basti_> ch
09:43:02 * basti_ head spinning now
09:44:20 <lispy> basti_: what did you send in?
09:44:33 <basti_> first attempts at completion interface
09:44:54 <basti_> for filenames etc.
09:45:38 <lispy> basti_: neat-o
09:46:40 <basti_> how's your elisp parser faring? -g-
09:51:27 <lispy> basti_: i have lambda and let implemented, but i've been hacking on darcs this week
09:51:41 <basti_> i guess that does make more sense anyway ;)
09:52:09 <lispy> basti_: i needed script hooks so I worked with david to implement a post apply hook
09:52:21 * lispy is pleased with it so far
09:52:24 <basti_> hmm
09:52:34 <basti_> what kind of scripts does it do? "shell scripts"?
09:52:40 <basti_> (#! etc.)
09:52:56 <lispy> basically it just called 'system' on whatever you give it
09:53:02 <lispy> @hoogle system
09:53:04 <lambdabot> System.system :: (String -> (IO ExitCode))
09:53:06 <basti_> ah i see
09:53:31 <lispy> the use i have for it is to send email notification when people send in patches
09:53:47 <lispy> that way all the devs can be kept updated on the "central" repository
09:53:48 <incomplete> We do need PrettyPrintification of @hoogle output :)
09:53:50 <basti_> yes it does make sense for sure...
09:54:09 <basti_> it doesnt hurt anyone, and its useful for at least a few cases
09:54:18 * lispy nods
09:54:34 <lispy> it will be good for people coming from a CVS background, such as our research group
09:54:46 <lispy> other commands will be getting post hook as well
09:55:33 <lispy> we still need a way to pass data to the command that is run, but what we have is a start
09:55:58 <basti_> :)
09:58:43 <lispy> i think david wants to use env variables, which has definite pluses, but i dont' like passing all that data on the command line
09:59:16 <basti_> hmm, and the minus is, that every implementation is a little different there
10:00:25 <lispy> i think using the commandline could be insecure
10:00:52 <lispy> what if someone tricks darcs into passing somethnig like "; rm -rf *"
10:00:56 * basti_ nods
10:01:00 <basti_> i see the problem, yes.
10:02:06 <lispy> my idea was to use a file to transfer data, but as david pointed out, that might put a burden on script writer to parse it for what they want, and we would lock ourselves into a format
10:02:31 <basti_> hmm
10:02:35 <lispy> i wonder how other systems solve this problem...
10:02:42 <basti_> not at all? :D
10:05:24 <lispy> heh
10:05:44 <incomplete> dcoutts_, ping
10:33:17 <CosmicRay> shapr: Haskell On Rails.  What do you think
10:35:03 <incomplete> CosmicRay, JeffaCake talked about a continuation-based framework some time ago, IIRC.
10:35:41 <CosmicRay> yeah, but I don't think that's really what rails is all about
10:37:44 <incomplete> I don't think rails is about continuation either.  But CB-frameworks are neat :)
10:37:53 <lispy> CosmicRay: well, there is HaXml and the db stuff, so it could probably be cobbled together
10:38:12 <incomplete> For example, did you see the UCW video made by Mario Baringer?
10:38:32 <incomplete> http://common-lisp.net/project/ucw/docs/
10:40:59 <Philippa_> for those of us who haven't used it, what /is/ Rails all about?
10:41:30 <lispy> CosmicRay: that robby guy just got back
10:42:01 <CosmicRay> why don't we just get robby in here and explain it to us all at once
10:42:04 <lispy> Philippa_: they help you to not fall down the stairs ;)
10:42:10 * lispy nods
10:43:57 <lispy> well, i mentioned it to him....we'll see what happens
10:44:49 * Beelsebob waves
10:45:46 <Lemmih> Greetings SyntaxNinja.
10:46:51 <SyntaxNinja> y0
10:47:07 <robbyonrails> Rails is a framework... meaning a collection of libraries .. and it's cool.
10:47:42 <Philippa_> wow, that was useful
10:47:57 <Philippa_> so, what is it?
10:48:14 <SyntaxNinja> strange.
10:48:17 <CosmicRay> hm.
10:48:24 <lispy> heh, wow, okay
10:48:30 <lispy> i guess he doesn't want to talk about it
10:48:32 <lispy> bummer
10:48:40 <Beelsebob> odd
10:48:42 * Philippa_ has an urge to riff on a Red Dward scene...
10:48:49 <Philippa_> *Dwarf
10:48:55 <SyntaxNinja> robbyonrails is in oregon, on another channel I'm on
10:49:58 <lispy> he says to go to #rubyonrails and ask questions there
10:50:10 <lispy> i don't thnk he wants to risk staring a flamewar
10:50:48 <SyntaxNinja> oh, I thought he was just joining every channel he saw to advertise his framework or something
10:50:55 <SyntaxNinja> that's what I get for jumping into the middle of a conversation
10:52:19 <lispy> SyntaxNinja: nah, he's a nicer guy than that
10:56:25 <SyntaxNinja> lispy: yeah.
11:13:49 <Lemmih> Bummer. No labeled jumps in the nativeGen /-:
11:15:54 <autrijus> http://www.kwiki.org/apocalypse/slide25b.html
11:16:03 <autrijus> (oscon, on air in 14 minutes)
11:22:53 <CosmicRay> hello metaperl
11:26:36 * Lemmih has been called in for evaluated by the military /-:
11:27:00 <Philippa_> :-(
11:27:08 <lispy> Lemmih: get your leg broken on the way in
11:30:26 <SyntaxNinja> Lemmih: :(
11:30:39 <SyntaxNinja> Lemmih: do you guys have manditory military service or anything?
11:30:47 <SyntaxNinja> s/anything/something
11:30:54 <Lemmih> Yeah /-:
11:31:22 <SyntaxNinja> :(
11:34:11 <lispy> Lemmih: if it's manditory, then hopefully there are enough normal people going through the system that it's not too bady?
11:34:14 <Lemmih> I hope to be ruled unsuited for being pale and geeky (:
11:34:20 <lispy> hehe
11:34:38 <lispy> Lemmih: can you be a pacifist and do community service instead?
11:35:04 <Lemmih> Yeah.
11:35:36 <lispy> i think that's the route i would go if i had to choose
11:35:53 <lispy> mostly because i really am a pacifist ;)
11:36:08 <Philippa_> definitely the one to pick if you have mixed feelings about authority
11:36:55 <SyntaxNinja> Philippa_: lemmih?!
11:36:56 <SyntaxNinja> ;)
11:36:57 <lispy> i had a friend that joined the army for 4 years and came out much more focused and disciplined.  So it can be good for some people.
11:37:07 <Lemmih> It would still suck to be paid $5 an hour for a year.
11:37:25 <lispy> Lemmih: :(
11:38:02 <Lemmih> (they pay less than minimul wage for some reason)
11:38:12 <lispy> the military?
11:38:24 <lispy> maybe they provide you with a place to live and some meals?
11:38:27 <Philippa_> I imagine so
11:39:34 <Lemmih> Not if you choose civil service.
11:39:48 <lispy> same pay either way eh?
11:39:48 <Philippa_> and that still pays less than minimum wage? Ouch
11:41:21 <SyntaxNinja> Lemmih: can you do computer work for civil service, or do you have to like, clean up trash or something?
11:42:36 <lispy> maybe you can help a school or hospital with their computer system
11:43:46 <Lemmih> That could actually be fun.
11:51:17 * SyntaxNinja wishes the US had manditory military service... I think
11:52:41 <lispy> SyntaxNinja: I don't think we could actually make it manditory.  All the elite kids would get out of it, the republicans would have loop holes and it would be a mess like so many things we have :)
11:53:20 * SyntaxNinja nods
11:56:52 <Igloo> SyntaxNinja: Why do you wish that?
11:56:52 <Philippa_> personally I'm pretty much against mandatory military service anywhere that doesn't have a clear and present danger necessitating it
11:59:13 <SyntaxNinja> Igloo: well, the dynamics in the US are such that for the most part, the folks who join the military are the poor, who often have no better option.  but it's the rich who make decisions about whether or not we go to war.
11:59:35 <SyntaxNinja> Igloo: so if the rich kids had to go to war as well, i honestly think that their parents would make different decisions about sending them off to fight.
12:00:05 <SyntaxNinja> sorry for getting political
12:00:40 <Philippa_> yeah, I figured that might be your reasoning
12:01:32 <SyntaxNinja> off to lunch. ttyl
12:30:34 <lispy> @pl \x y -> x y
12:30:35 <lambdabot> id
12:30:46 <lispy> @pl \x y z -> x y z
12:30:47 <lambdabot> id
12:30:50 <lispy> @pl \x y z -> x y
12:30:51 <lambdabot> (const .)
12:31:04 <lispy> @pl \x y z -> x
12:31:05 <lambdabot> const . const
12:31:14 <lispy> @type const
12:31:19 <lambdabot> forall a b. a -> b -> a
12:31:27 <lispy> ah, okay
13:22:50 <Lemmih> JaffaCake: Ping.
13:28:21 * boegel can hear the birds sing in the Haskell-forest
13:29:57 * lispy sits near a small stream playing in the shallow parts
13:30:35 * CosmicRay is in a twisty cave with many monads, all alike
13:30:38 * boegel sees a huge fish biting lispy's ankels
13:30:55 * lispy screams and jumps out of the water
13:31:00 <CosmicRay> huzzah!  I have ldap searching working, and it's 4 times faster than python-ldap!
13:31:03 * Lemmih still sits in front of his computer since he ran out of LSD.
13:31:04 * boegel ses CosmicRay being eaten alive by a huge grizzly bear
13:31:05 * incomplete /mes too
13:31:18 <CosmicRay> boegel: rats, I hoped the snake would take care of that
13:31:37 <CosmicRay> oh well, time to restore from a saveuniverse...
13:31:40 <boegel> CosmicRay: you dirty dirty mind
13:31:50 <CosmicRay> heh
13:32:30 * lispy finds himself back in the construct wondering when the next matrix program will load.
13:34:00 <CosmicRay> lispy: when I manage to get past the bear, and not a turn sooner!
13:34:42 <lispy> stupid bear
13:35:01 <CosmicRay> it's boegel's fault
13:35:07 <lispy> bear :: Maybe Maybe a
13:35:13 <CosmicRay> heh
13:35:14 <lispy> it's Just Nothing
13:35:38 * boegel shoots the bear
13:35:43 <boegel> thee you go
13:35:49 <MarcWeber> Can someone tell me where I can find htags?
13:35:50 <CosmicRay> woohoo!  points!
13:35:51 <CosmicRay> :-)
13:36:03 <CosmicRay> @google haskell htags
13:36:04 <lambdabot> http://www.desy.de/user/projects/LitProg/glasgow/better-haskell-indexing.html
13:36:04 <incomplete> MarcWeber, do you mean hasktags?
13:36:09 <CosmicRay> hmm.
13:36:26 <incomplete> MarcWeber, the tags/TAGS file generator?
13:36:42 <MarcWeber> incomplete: Yes, Thanks.. Then I can google again
13:36:53 <incomplete> @google hasktags
13:36:55 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
13:36:56 <incomplete> There you go.
13:37:04 <palomer> la la la la, don't phunk with my heart
13:37:21 <incomplete> (by the way, I'm xerox but away from home)
13:37:40 <boegel> incomplete: try '/nick xerox'
13:37:55 <incomplete> boegel, I've another client I can't access now that's connected :!
13:38:21 <TheHunter> that's what nickserv is for.
13:38:25 <boegel> oh, I see :)
13:38:35 <incomplete> Let me have fun :)
13:38:39 <TheHunter> yay! stereo!
13:39:56 <lispy> incomplete: if you don't want to ghost your other nick you can link your nicks
13:40:02 * boegel goes to bed with Harry Potter
13:40:06 <boegel> err, I mean the book :p
13:40:07 <incomplete> lispy, what does it mean?
13:40:13 <incomplete> boegel, argh :)
13:40:30 <lispy> incomplete: um....not sure, maybe they have access to the same things, like memos?
13:40:45 <boegel> bye !
13:40:50 <incomplete> bye!
13:40:52 <lispy> incomplete: i doubt it does anything cool like makes you get irc traffic from either nick on both screens...
13:40:57 <lispy> boegel: have fun
13:42:30 <incomplete> It seems to consist in sharing the access list and memos.  And identifying on one nick identifies on all the linked ones.
13:43:15 <pejo> 200
13:43:20 <pejo> Ups, wrong window.
13:43:35 <boegel> 300 !
13:43:39 <boegel> anyways, bye ! :)
13:45:37 <lispy> incomplete: the thing i do is run my irc client on a server using screen and then just connect via shell when i want to use irc
13:45:46 <lispy> it's "good enough" irc
13:46:09 <incomplete> ..and you don't forget passwords, hopefully *cough*
13:46:38 <shrimpx> a good client will auto log you in and stuff
13:47:14 <incomplete> By the way, I do like ERC more than remote irssi.
13:48:12 * TheHunter wonders what client shrimpx is using
13:48:14 <lispy> I'm using ERC Version 5.0 $Revision: 1.743 $ with GNU Emacs 21.4.1 (i386-pc-linux-gnu, X toolkit, Xaw3d scroll bars, built 2005-03-17)!
13:48:19 <incomplete> I should find a way to proxy it or something.  It would be even better to intoxicate from IRC, cough.
13:48:20 <lispy> incomplete: me tee :)
13:48:25 <incomplete> *de-intoxicate
13:48:30 <incomplete> Are you using a remote Emacs?
13:48:39 <lispy> emacs -nw -f erc-select
13:48:53 <incomplete> hmm.
13:48:53 <lispy> so emacs is on the server running behind screen
13:49:17 <incomplete> Do font-locking work?
13:49:31 <lispy> i have colors, but erc isn't terribly colorful
13:49:31 <incomplete> Does, even
13:50:28 <incomplete> I love the highlighting of erc-track modeline output.
13:51:47 <incomplete> Hmm, I do like colorful Emacs.
13:51:51 <shapr> me too
13:51:55 <shapr> misty day
13:52:12 <incomplete> I know.  But I enjoy white background.
13:52:26 <lispy> i have a custome color schmee
13:52:28 <lispy> er scheme
13:52:46 <shapr> incomplete: Are you the Haskellers formerly known as xerox?
13:52:55 <incomplete> shapr, indeed!
13:53:47 <incomplete> lispy, how does your terminal handle UTF-8?
13:54:13 <incomplete> xterm+screen gives me some problems while writing down the sentences - no problem in reading the code, tough.
13:54:30 <lispy> incomplete: i don't, i could turn it on, but it dosen't work well with putty
13:55:12 <shapr> samc_: y0!
13:56:35 <shapr> g'day samc
13:56:41 <shapr> samc: Are you studying Joy these days?
13:58:00 <incomplete> lispy, I tried linking, it works nicely.
13:58:03 <samc> g'day shapr, not really
13:59:48 <incomplete> shapr, I was thinking about your RSS issue, would it be possible to use feedburner.com in your case?
14:02:37 <shapr> incomplete: The best solution is a wiki markup -> RSS transformer.
14:02:44 <shapr> I think I'll hack on that soon.
14:03:12 <samc> shapr, why did you ask that?
14:03:16 <incomplete> I'm warning you I'll not read your blog until then!  <blink>
14:03:34 <shapr> incomplete: That's fine, I broke my blog software so I can't update it at the moment :-/
14:03:46 <shapr> samc: I saw you talking about concatenative languages in the logs somewhere.
14:03:56 <Philippa_> shapr: dump me an RSS spec, an existing wiki -> HTML parser and money? :-)
14:04:00 <samc> i see
14:04:09 <shapr> samc: Also, you disappeared for months so I wondered if you found something else fun to do :-)
14:04:13 <Philippa_> (is the existing parser likely to be the one I have by any chance?)
14:04:29 <shapr> Philippa_: If I had enough money....
14:04:41 <Philippa_> point. Got chocolate?
14:04:49 <shapr> Philippa_: Yeah, I'll likely just make some sort of map from Flippi to stepcut's RSS.hs.
14:04:53 * Philippa_ points to the sign around her neck - "will code for food"
14:05:22 * Philippa_ crosses out food and puts backrubs in its place
14:05:49 <incomplete> @google RSS.hs
14:05:51 <lambdabot> http://www.gccisd.net/Calendar/fineart.htm
14:06:01 <shapr> ??
14:07:11 <Philippa_> it treats the . as a space
14:07:17 <incomplete> @google RSS\.hs
14:07:19 <lambdabot> http://www.gccisd.net/Calendar/fineart.htm
14:08:28 <incomplete> @google stepcut "RSS.hs"
14:08:30 <lambdabot> http://tunes.org/~nef/logs/haskell/04.06.02
14:11:08 <fnord123> Hi all. Quick question. I have a module that defines a string/character literal but it is giving me an error. It doesn't look to my haskell-weak eyes like an error.
14:11:41 <Lemmih> What error does it give you?
14:11:54 <fnord123> Darcs/Context.hs:3:57: lexical error in string/character literal
14:12:15 <fnord123> I'll paste two lines into the channel:
14:12:25 <fnord123> context = "# configured Mon Aug  1 19:24:19 BST 2005\n\
14:12:25 <fnord123>  \./configure \n\
14:12:40 <Igloo> Are you using -cpp?
14:12:59 <fnord123> it continues for a few lines and terminates, but the error is line 3, col 57 -> which would be the . in ./configure I think
14:13:04 <fnord123> -c
14:13:12 <fnord123> oh I mean I am using -cpp
14:13:21 <Igloo> String gaps don't mix well with cpp
14:17:15 <fnord123> so get rid of -cpp (perhaps massively changing my makefile)
14:17:26 <fnord123> or........ how can  i fix it in code
14:18:14 <Igloo> You could use "foo\n" ++ "bar" instead
14:18:22 <Igloo> Or pull the string constants out to a different module
14:18:39 <Igloo> Using hscpp might be another option, actually
14:21:50 * shapr boings
14:22:29 <basti_> shapr: i sent dons a patch for yi-emacs. Completion interface works a little now
14:23:07 <fnord123> oh i got it. it was the \. that was the problem. the ++ helped since it still flagged an error on the escape sequence
14:25:21 <shapr> basti_: cool!
14:28:38 <shapr> Hey, anyone using debian/unstable with ion3/x.org/nvidia drivers? For some reason ion3 in my .xsession doesn't work. But, gnome-session can run ion3 as a wm. Am I doing something obviously wrong?
14:28:55 <samc> shapr, what's with your lame rss feed ;)
14:29:41 <incomplete> ndm, hi!  How's code?  What about Hoogle in particular? :)
14:29:46 <shapr> samc: It's just lame. I'll get around to fixing that when my bittorrent in haskell project is either finished or, more likely, gets boring.
14:29:54 <ndm> hi incomplete, going well
14:30:13 <ndm> incomplete, in particular there is now a sourceforge account for hoogle, with publically available CVS
14:30:17 <shapr> yay!
14:30:18 <incomplete> shapr, I completely understand what you mean.
14:30:38 <incomplete> Did you misstype darcs?  :)
14:30:40 <ndm> http://sourceforge.net/projects/hoogle/
14:30:52 <ndm> nope, i typed cvs correctly :)
14:32:12 <SyntaxNinja> shapr!
14:32:21 <shapr> Y0 Ninja J0n3s!
14:33:14 <fnord123> oh snap!
14:33:24 <shapr> snap?
14:33:27 <shapr> Snape?
14:33:34 <incomplete> slap!
14:33:40 <lispy> slip!
14:34:18 <fnord123> Abbreviation for "Specifications for Non-heatset Advertising Printing"; a color proofing system to assure press to press, and run to run color constancy.
14:34:45 <shapr> Oh that makes sense.
14:36:32 <fnord123> it's an urban interjection
14:36:57 <incomplete> Did anybody go to the WTH?
14:37:09 <shapr> What the Haskell?
14:37:25 <incomplete> It was (wiki.)WhatTheHack(.org).
14:38:16 <incomplete> Nicely there are the speech vids avaiable online, if you care.
14:42:40 <lispy> heh, wth
14:48:49 * Lemmih can't run yi.
14:50:32 <Lemmih> unknown symbol 'YiziVersion_version_closure" in Yi.o
14:52:40 <basti_> hmm
14:52:47 <basti_> < paniq> let me find a haskell for dummies.
14:53:06 <basti_> any idea? the gentle introduction is not gentle enough
14:53:18 <shapr> @wiki HaskellDemo
14:53:19 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
14:53:23 <incomplete>  /join #haskell
14:53:39 <basti_> :P
14:54:12 <Lemmih> http://www.haskell.org/complex/introduction_to_programming.html
14:54:14 <basti_> hi paniq
14:54:18 <basti_> that's the guy
14:54:19 <TheHunter> there are a lot of well-writte mailing list posts answering newbie questions, somebody should really collect them.
14:54:24 <paniq> see
14:54:28 <paniq> this is the day where i join haskell
14:54:34 <paniq> with a hi();
14:54:42 <shapr> Gutenabend paniq
14:54:43 <paniq> and i will leave with a bye written in haskell, once the day is over.
14:54:44 * basti_ claps softly
14:54:51 <basti_> -g-
14:55:10 <basti_> beware, this channel has a bot that can reformulate code.
14:55:23 <shapr> I'm not a bot!
14:55:25 <gzl> what's the point of @pointless?
14:55:47 <incomplete> My pleasure.
14:56:13 <basti_> actually @pointless should be @pointsfree
14:56:38 <paniq> "I write this assuming that you have checked out the Gentle Introduction to Haskell, but still don't understand what's going on."
14:56:42 <paniq> sounds good.
14:57:24 <basti_> -g-
15:00:00 <paniq> i dont know
15:00:05 <paniq> haskell seems like acid to me
15:00:25 <paniq> i have trouble with the philosophical concept of the imperative
15:00:26 <shapr> high powered? like the acid in batteries?
15:00:45 <shapr> Or you mean it dissolves weaker matter, like nitric acid?
15:00:47 <paniq> but i dont object when it comes to relations
15:00:59 <paniq> maybe i mean something completely different.
15:02:15 <Lemmih> Or mind altering, like lysergic acid diethylamide.
15:02:34 <shapr> Oh. That's true.
15:02:37 <paniq> finally.
15:02:40 <paniq> :o)
15:03:32 * incomplete didn't know todays was the Haskell LSD day.
15:03:48 <incomplete> In fact it also seems to be my birthday.
15:04:29 <Lemmih> Happy birthday, xerox.
15:04:43 <incomplete> Thank you, Lemmih :)
15:05:18 <paniq> "The order to these operations does not matter."
15:05:20 <paniq> thats indeed true.
15:05:28 <paniq> haskell could be used to solve detective stories ;)
15:05:40 <basti_> prolog is better for that.
15:05:44 <incomplete> No.
15:05:45 <paniq> hehe
15:05:53 * basti_ ducks
15:12:20 <SyntaxNinja> xerox: it's your birthday?
15:13:50 <incomplete> SyntaxNinja, yup!
15:13:55 <shapr> Happy Birthday!
15:13:59 <shapr> How old are you now?
15:14:27 <incomplete> 10100, binary
15:15:41 <kosmikus> happy birthday!
15:16:17 <basti_> yes, HB.
15:16:19 <basti_> @ghc
15:16:20 <lambdabot>  falls under the monomorphism restriction
15:16:28 <shapr> @ghc
15:16:29 <lambdabot>  Pattern bindings (except simple variables) not allowed in instance
15:16:29 <lambdabot> declarations
15:16:30 <incomplete> Thank you shapr, kosmikus, basti_, SyntaxNinja, et all :-)
15:17:15 <incomplete> What are "pattern bindings"?
15:17:40 <shapr> I think it's (Constructor a b c)
15:17:43 <basti_> things like func (head:tail) = 5
15:17:50 <basti_> yes, that too
15:17:57 <basti_> : is just sugar for a constructor
15:18:08 <incomplete> It's a infix data constructor, yeah
15:18:14 <incomplete> OK.
15:18:16 <Lemmih> mmm candy.
15:20:27 <incomplete> I'm suggesting the Quantum Computing talk from the WTH.
15:23:32 <basti_> I'll go to bed now
15:23:59 <Lemmih> G'night, basti_.
15:24:00 <kosmikus> a "pattern binding" is a declaration of the form "pattern = expr" such as "(x,y) = (1,2)"
15:24:03 <samc> from the mungi (a research os from oz) pronunciation guide 'i: as in "bit"' not very helpful
15:24:16 <paniq> Prelude> [ x  | x <- [1,2,3], y <- [1,2,3] ]
15:24:16 <paniq> [1,1,1,2,2,2,3,3,3]
15:24:17 <paniq> heh geil
15:24:26 <basti_> :)
15:24:36 <shapr> @babel de en geil
15:24:39 <lambdabot>  geil
15:24:41 <shapr> :-/
15:24:48 <basti_> thats an unspecified positive
15:24:52 <basti_> like "cool".
15:25:24 <paniq> i'm slowly starting to understand the fib term
15:25:29 * basti_ grins
15:26:09 <incomplete> @plugs let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 20 fib
15:26:14 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
15:26:16 <lispy> @eval [ x | x <- [1..3], _ <- [1..3]] --this emphasize that you don't use the values from the second list
15:26:17 <lambdabot> parse error (possibly incorrect indentation)
15:26:26 <lispy> @eval [ x | x <- [1..3], _ <- [1..3]]
15:26:27 <lambdabot> [1,1,1,2,2,2,3,3,3]
15:26:41 * incomplete blinks
15:27:08 <lispy> @eval [ x | _ <- [1..3], x <- [1..3]]
15:27:10 <lambdabot> [1,2,3,1,2,3,1,2,3]
15:27:15 <lispy> get it now?
15:27:27 <lispy> i use it sometimes instead of creating loops :)
15:27:44 <paniq> no.
15:27:51 * basti_ chuckles
15:27:59 <basti_> cu tomorrow
15:28:01 <paniq> what the fuck is this underscore doing there.
15:28:02 <paniq> :>
15:28:20 <lispy> paniq: it's a place holder for a name
15:28:24 <lispy> or a value
15:28:31 <paniq> like "dontcare"
15:28:32 <paniq> ?
15:28:35 <lispy> ya
15:28:39 <paniq> i see
15:29:07 <incomplete> @plugs [1,2,3] >>= \xs -> [1,2,3] >>= \ys -> return xs
15:29:09 <lambdabot> [1,1,1,2,2,2,3,3,3]
15:29:10 <incomplete> @plugs [1,2,3] >>= \xs -> [1,2,3] >>= \ys -> return ys
15:29:12 <lambdabot> [1,2,3,1,2,3,1,2,3]
15:29:21 <paniq> so zip is an interleaver.
15:29:46 <lispy> probably the most confusing part is that the last list given in the comprehension is the inner loop
15:29:50 <shapr>  @plugs zip "abc" "xyz"
15:30:08 <lispy> extra space
15:30:08 <shapr> Hm, is the lag that bad to .au?
15:30:09 <incomplete> s/^[ \t]+//
15:30:12 <paniq> @eval zip "abc" "xyz"
15:30:13 <lambdabot> [('a','x'),('b','y'),('c','z')]
15:30:41 <incomplete>         @yow could it be because of the spacing?
15:30:43 <paniq> @eval zip "rx0" "0xr"
15:30:45 <lambdabot> [('r','0'),('x','x'),('0','r')]
15:30:51 * shapr grins
15:30:53 <incomplete>          @eval it could.
15:30:59 <lispy> @eval foldl1 (:) "abc" "xzy"
15:31:00 <lambdabot> Couldn't match `[t -> a]' against `t -> a'
15:31:09 <incomplete> heh.
15:31:24 <lispy> oh dun
15:31:31 <paniq> so zip also can be used to create key/value pairs
15:31:34 <lispy> foldl1 doesn't take two lists :)
15:31:35 <samc> why's the lambdabot in oz now?
15:31:47 <paniq> @eval zip [1,2,3] "123"
15:31:49 <lambdabot> [(1,'1'),(2,'2'),(3,'3')]
15:31:55 <incomplete> paniq, check this out:
15:31:58 <incomplete> @type zip
15:32:00 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
15:32:08 <incomplete> @type zipWith (,)
15:32:10 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
15:32:14 <incomplete> @type zipWith (+)
15:32:16 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
15:32:31 <paniq> weirdness
15:32:34 <incomplete> Right.
15:32:51 <paniq> but i see
15:32:56 <paniq> everything before the last -> is an input
15:33:01 <paniq> the last statement is the result
15:33:03 <incomplete> Also right.
15:33:15 <incomplete> "->" is right associative
15:33:34 <incomplete> Hm, is it the right term?
15:34:31 <lispy> @eval do { x <- [1,2,3]; y <- [1,2,3]; return x}
15:34:32 <lambdabot> [1,1,1,2,2,2,3,3,3]
15:34:37 <incomplete> paniq, it also means that functions are underneath unary, and they can "partially applied" functions, i.e. functions with the first arguments "eaten".
15:34:47 <incomplete> @type (+)
15:34:49 <lambdabot> forall a. (Num a) => a -> a -> a
15:34:52 <incomplete> @type (1+)
15:34:54 <lambdabot> forall a. (Num a) => a -> a
15:34:55 <lispy> @eval do { x <- [1,2,3]; _ <- [1,2,3]; return x}
15:34:57 <lambdabot> [1,1,1,2,2,2,3,3,3]
15:34:58 <incomplete> @type (1+1)
15:35:00 <lambdabot> forall a. (Num a) => a
15:35:33 <incomplete> oops "and they can _return_ partially applied functions", sorry.
15:35:37 <lispy> so a list comprehension is just an interface to the list monad?
15:35:50 <yosemite> ok that do is cool.  I didn't think about doing that before.
15:35:52 <incomplete> lispy, yup - a nice syntactic sugar.
15:35:54 <lispy> or is that just a coincidence from the way both are deefined?
15:35:59 <lispy> incomplete: ah
15:36:33 <incomplete> paniq, did I lose you?
15:36:38 <paniq> yes
15:36:41 <paniq> i read the tutorial instead
15:36:54 * incomplete hoped to be useful
15:36:58 <incomplete> I'll sleep instead.
15:36:58 <paniq> you were
15:37:00 <paniq> :)
15:37:02 <paniq> good night
15:37:07 <incomplete> :) have fun!
15:37:12 <paniq> i will
15:38:49 <shapr> g'day Pseudonym
15:38:54 <Pseudonym> G'day.
15:39:40 <shapr> How's code
15:39:41 <shapr> ?
15:39:46 <Pseudonym> OK
15:39:48 <Pseudonym> Not too bad.
15:40:16 <Pseudonym> Yourself?
15:41:42 <shapr> Slow, but moving.
15:41:57 <Pseudonym> What are you working on, as a matter of curiosity?
15:42:09 <shapr> For fun, Bittorrent client in Haskell.
15:42:17 <Pseudonym> Ah, cool.
15:42:24 <Lunar^> cool!
15:42:26 <Lemmih> Got a darcs repo online?
15:42:27 <Pseudonym> FLM stalled, then? :-)
15:42:46 <shapr> Yup :-)
15:42:46 <jlouis> don't make me pull that and create patches for it
15:42:49 <shapr> Lemmih: yes
15:42:52 <jlouis> please
15:43:04 <jlouis> I don't have time, I sohuld study category theory ;)
15:43:12 <shapr> Lemmih: Code is minimal so far, but it's in ~shae/combinatorrent/
15:43:17 <Lemmih> shapr: How's EuroHaskell coming along?
15:43:26 * Pseudonym is trying to work out how to split up part 1 and part 2 of his TMR article
15:43:28 <jlouis> shapr: cool name ;)
15:43:34 <jlouis> (bastard)
15:43:38 <Pseudonym> Oh, I love it!
15:43:52 <shapr> Still looking for something cheesier than combinatorrent
15:44:08 <Pseudonym> If I ever write a GUI library for Haskell, I'm going to call it pointlesstif.
15:44:15 <shapr> hah
15:44:22 <jlouis> hehe
15:44:23 <Philippa_> [bit]?
15:44:25 <astrolabe> LOL
15:44:43 <Philippa_> heh
15:45:21 <shapr> Lemmih: I haven't done anything about EuroHaskell, you want to organize it? :-)
15:45:59 <Pseudonym> How about you call it peer >>> peer?
15:46:09 <Lemmih> shapr: How many came last time?
15:46:37 <jlouis> Pseudonym: hahaha
15:46:53 <jlouis> free theorrents
15:47:04 <jlouis> cotorrent
15:47:11 <Pseudonym> Oh, I like that.
15:47:39 <Philippa_> using algebraic datatorrents?
15:47:52 <jlouis> haha
15:47:58 <paniq> so the program is basically just one giant equation that describes what a finished torrent on your hd looks like
15:48:04 <paniq> ?
15:48:23 <jlouis> no, its contravariant ;)
15:48:39 <Philippa_> paniq: mostly, yes
15:48:49 <Pseudonym> Bit Accumulator
15:48:56 <Philippa_> "mostly" insofar as there'll be some mucking around getting data across a network which looks less algebraic
15:49:04 <Pseudonym> Oh, I know!
15:49:07 <Pseudonym> Data By Need
15:49:28 <Philippa_> Receive By Need?
15:49:29 <jlouis> paniq: read what Philippa_ writes
15:49:41 <paniq> yup
15:49:42 <jlouis> ignore me
15:49:51 * Philippa_ laughs
15:49:59 <Philippa_> why'd he want to do a thing like that?
15:50:03 <paniq> hm
15:50:08 <Pseudonym> Functorrent
15:50:10 <paniq> so haskell would be the best language to feed a quantum computer
15:50:11 <paniq> :>
15:50:14 <Pseudonym> I think I like that one.
15:50:33 <Philippa_> you'll get loads of people asking why you can't spell funk though
15:50:37 <shapr> heh
15:50:40 <Pseudonym> Natural Transportation
15:50:49 <jlouis> haha
15:53:02 <incomplete> Do you remember how was it called that paper showing fold patterns and how to go back and forth from/to them and loops?
15:53:20 <jlouis> something with bananas?
15:53:29 <incomplete> Nope, it was simpler :)
15:53:31 <liyang> lenses and barb wires?
15:54:05 <Pseudonym> Point To Fixpoint
15:54:09 <incomplete> @google fold.pdf
15:54:10 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
15:54:32 <incomplete> "A tutorial on the universality and expressiveness of fold"
15:55:35 <shapr> Lemmih: I think about fifteen, but several of those were Pythonistas.
15:57:03 <Pseudonym> @quote
15:57:04 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a
15:57:04 <lambdabot> bike rode up next to me and said, "There's always a show off." I
15:57:04 <lambdabot> offered to teach him to ride and help set up a unicycle patrol squad,
15:57:04 <lambdabot> but he declined.
15:57:23 * shapr chortles
15:57:33 <incomplete> OK, goodnight for real, kisses.
15:57:41 <shapr> @quote
15:57:42 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two
15:57:42 <lambdabot> Files in Different Directories!"
15:57:48 <Pseudonym> If you create a freenet client, you could call it Maximal Free Expression.
15:57:49 <shapr> g'night incomplete
15:58:33 <shapr> @quote
15:58:34 <lambdabot> <basti_> says: "Snow doeth lay upon the lands. Even with cunning
15:58:34 <lambdabot> newtype; deriving the newtype is recursive. Great leaders brings
15:58:34 <lambdabot> less pain."
15:58:37 <paniq> @quote
15:58:38 <lambdabot> Gahhh says: monads are usually a personal experience.
15:58:39 <shapr> @quote Pseudonym
15:58:40 <lambdabot>  Lazy evalution is really, really trippy.
15:58:53 <paniq> lazy evolution
15:58:54 <paniq> :>
15:59:07 <shapr> Yeah, that's where we persuade the compiler to fix our code.
15:59:09 * Pseudonym STILL doesn't know why that is quotable
15:59:13 <Pseudonym> @quote Pseudonym
15:59:14 <lambdabot>  I think principal types are overrated
15:59:20 * Pseudonym isn't so sure on that one iether
15:59:24 <Pseudonym> @quote shapr
15:59:25 <lambdabot>  Windows users are like the wives of alcoholics, they'll take any
15:59:25 <lambdabot> amount of abuse and come right back.
15:59:31 <paniq> hehe
15:59:34 * Pseudonym laughs
15:59:54 <Lemmih> @seen bringert
15:59:55 <lambdabot> I saw bringert leaving #haskell 14 days, 3 hours, 51 minutes and 28
15:59:55 <lambdabot> seconds ago, and I have missed 6 minutes and 24 seconds since then.
16:00:06 * Philippa_ actually has a reason to be running windows, but hey
16:00:43 <astrolabe> All co-dependents have an excuse like that ;)
16:00:47 <Pseudonym> Yeah, but I'm sure you abuse Windows right back.
16:01:26 <Philippa_> astrolabe: I'm a gamer, 'nuff said
16:01:49 <Philippa_> Pseudonym: something like that, yeah. It's noticeable that I don't run any further MS software on here these days though
16:01:56 <astrolabe> I use windows myself :(  What games?
16:02:16 <Philippa_> mostly MAME stuff when sufficiently bored atm, I've been playing more console stuff
16:02:30 <fnord123> why do people put themselves as an indirect object of sentences where they are the subject?
16:02:33 <Philippa_> used to be a heavy UT player, have RTS phases once in a while...
16:02:56 <Philippa_> 123: er?
16:03:06 <fnord123> "I use windows myself"
16:03:27 <Philippa_> you mean in reality windows uses astrolabe?
16:03:28 <astrolabe> So they can write in purple?
16:04:00 * Philippa_ points at the mIRC user
16:04:16 <Philippa_> (not that I'm not running it, had too much hassle trying to write my own client with wxHaskell)
16:05:32 <Pseudonym> Since I got Rogue for my palm pilot I have no reason to be bored.
16:05:53 <Philippa_> heh
16:06:03 <Philippa_> Damien's been playing a lot of Diablo 2
16:06:06 <Philippa_> same sort of idea, I guess
16:07:43 <paniq> sick
16:07:48 <paniq> partial evaluation
16:07:49 <Pseudonym> I am told that Diablo is very roguelike.
16:09:31 <Philippa_> paniq: partial application's incredibly useful
16:09:39 <Philippa_> it's one of the things I really really miss when I have to code in C++
16:11:24 <Pseudonym> I agree with that, though Boost.Function comes about 80% of the way there.
16:12:38 <paniq> Bloat.Function
16:13:04 <Pseudonym> I think that's unfair.
16:13:12 <Pseudonym> It's REALLY, REALLY HARD to write generic code in C++.
16:13:20 <Pseudonym> But once it's written, it's usually pretty easy to use.
16:13:29 <paniq> but it takes ages to compile
16:13:38 <Pseudonym> The code of Boost might itself be bloated, but it's damn easy to use.
16:14:01 <Pseudonym> I haven't noticed that it takes more time than the rest of my code.,
16:14:04 <Pseudonym> Might just be me.
16:14:48 <paniq> well
16:14:53 <paniq> have a go with boost.python then
16:16:21 <Pseudonym> True, I've never used that,
16:18:43 <musasabi> spirit (the C++ parser thing) makes GHC seem fast an agile for compilation.
16:18:56 <lispy> wow
16:19:42 <Philippa_> musasabi: *and* Parsec's just plain easier
16:19:52 <Pseudonym> And Parsec works.
16:19:59 <lispy> parsec rocks
16:20:00 <Philippa_> I'd love to see the code jhc'd produce from Parsec parsers
16:20:04 <Philippa_> I suspect it'd be rather good
16:20:26 <lispy> Philippa_: what do you mean the code jhc'd produce?  what is jhc?
16:20:31 <Pseudonym> BRB
16:22:02 <musasabi> Philippa_: why not just try?
16:22:08 <Igloo> Philippa_: It's still going to have overhead due to lazy lists though, right?
16:23:00 <Philippa_> lispy: jhc's JohnMeacham's compiler
16:23:29 <Philippa_> Igloo: yeah, insofar as it can't escape the fact the basic string type's one
16:24:12 <Philippa_> OTOH, it occurs to me that it might do a good job of optimising a PackedString -> String reader or something. Depends just how thoroughly it's inlining
16:25:48 <musasabi> It doesn't eat quite as much memory as the initial version did.
16:26:16 <lispy> Philippa_: is it really good at optimizing or something?
16:26:39 <Philippa_> lispy: yup
16:26:44 <Philippa_> it has some really neat tricks up its sleeve
16:27:36 <lispy> cool, when do those tricks make it into ghc ;)
16:29:06 <Philippa_> AIUI that'd require a major rewrite of large chunks of it
16:29:50 <lispy> hmm...no GC
16:30:44 <Philippa_> yeah, that's the downside - it's not exactly production-ready
16:31:54 <lispy> yet it has some very cool stuff
16:32:24 <Philippa_> yup, very cool
16:36:58 <TheHunter> @pl [1,2,3] >>= \xs -> [1,2,3] >>= \ys -> return xs
16:36:59 <lambdabot> ([1, 2, 3] >>=) . const . return =<< [1, 2, 3]
16:37:15 <TheHunter> @pl [1,2,3] >>= \xs -> [1,2,3] >>= \ys -> return ys
16:37:16 <lambdabot> [1, 2, 3] >> [1, 2, 3]
16:47:40 <Pseudonym> Could someone please let me know when ##c++ heats up again so I can join in?  Thanks.
16:59:32 <fnord123> heats up with what
16:59:52 <Pseudonym> Oh, you must have missed yesterday.
17:00:04 <fnord123> i lurk on efnet.net
17:00:36 <fnord123> what happened yesterdat
17:02:44 <SyntaxNinja> it was the non-event of the year
17:04:09 <Pseudonym> Indeed.
17:04:17 <Pseudonym> But it passed the time.
17:04:51 <SyntaxNinja> yeah...
17:05:09 <SyntaxNinja> I've spent a lot of time arguing about languages... in my college days ;)
17:07:06 <fnord123> c++ is the best language
17:07:39 <lispy> SyntaxNinja: heh, you just missed the #orlug fun
17:07:46 <fnord123> now is when you all laugh at the joke
17:08:07 <Pseudonym> Can't beat COBOL.
17:09:14 <fnord123> today, someone I work with said "the code isn't complicated. it's just some if then else statements
17:09:37 <fnord123> (8000 lines of if then else)
17:09:47 <fnord123> I had to explain that branching WAS complexity.
17:11:03 <fnord123> like... by definitionn
17:11:16 <SyntaxNinja> lispy: ooh, looks like its going well
17:11:48 <lispy> SyntaxNinja: i got annoyed about his comment that "compiling" a program menas nothing in all languages and went off about type correctness :)
17:12:35 <SyntaxNinja> I had no idea what that compiling comment was supposed to mean
17:13:05 <SyntaxNinja> I honestly don't get the idea that type systems tie your hands. I've never felt like that.
17:14:26 <monochrom> I disagree with you on the surface level but bear with me.  A mere lot of if-then-else's (no loop, no recursion) isn't complicated; it's so straightforward that a computer can both write and verify it.  Given that, the person who wrote it can be fired and replaced by a computer.
17:15:25 <lispy> i dont' know that you have to fire them, maybe their good at making coffee or something
17:15:35 <monochrom> heh
17:15:44 <lispy> just cut their hours back and pass them up for promotion :)
17:16:02 <lispy> they'll get sick of it leave, and hate your company.  Problem solved.
17:16:07 <Pseudonym> The might just be cute, so you could keep them around for that reason.
17:16:29 <fnord123> yes. im trying to turn it into a hashed table and get her fired
17:16:34 <lispy> Pseudonym: have to becareful about sexual harrasment tho... ;)
17:16:41 <fnord123> but she said she did that already but we haven't moved it
17:17:34 <Pseudonym> http://www.thedailywtf.com/ <- Post a snippet here
17:17:51 <SyntaxNinja> monochrom: was that comment directed at me?
17:18:47 <fnord123> id say more but these channels are logged
17:19:01 <Korollary> Joel says hiring good programmers may be a good idea. Hmm.
17:19:33 * Korollary went to the Santa Clara job fair today
17:19:35 <SyntaxNinja> oh monochrom was talking to fnord123
17:20:09 <lispy> Korollary: heh
17:20:15 <lispy> who is Joel?
17:20:24 <Korollary> joelonsoftware.com I think
17:20:26 <lispy> and where did this profound wisdom come from?
17:21:14 <fnord123> some of his writing is junk.
17:21:18 <Korollary> It's not profound wisdom because you can meet many hiring managers that don't care for particularly good programmers.
17:21:31 <Korollary> fnord123: Yeah. blogs are horrible.
17:21:49 <monochrom> So, I have always wondered why programmers insist on "easy-to-learn" languages, "easy-to-figure-out" code, "none of those pointfree Hasekll brainteasers", etc.  Don't they realize that they are playing fire?  If their job becomes as easy as they want, why would any boss hire them?
17:22:08 <Korollary> monochrom: many bosses would hire them.
17:22:25 <fnord123> because the bosses are stupid?
17:22:29 <Korollary> monochrom: bosses are very much put off by highly technical stuff.
17:22:52 <Pseudonym> Some bosses are threatened if they don't understand what their employees are doing.
17:23:00 <Korollary> Pseudonym: Exactly
17:23:04 <Pseudonym> I really, REALLY want Google to open an office here.  I'd be so there.
17:23:08 <fnord123> their interviews may be full of gimmick trick questions instead of meaningful questions
17:23:14 <fnord123> 'oh a brain teaser!'
17:23:35 <monochrom> If I make a computer (or rather a program) that does the job better, the bosses will switch.
17:24:08 <Pseudonym> Google likes smart people/.
17:24:17 <Korollary> monochrom: They won't let you do that unless it has "return on investment". You'll have to argue how it's going to be good for business.
17:24:21 <Pseudonym> So even if I'm not so smart, I'd be working with them.
17:24:26 <Pseudonym> Mind you, I work with pretty smart people now.
17:24:26 <Korollary> Pseudonym: A coworker of mine just left for Google.
17:24:47 <yosemite> google is making the hiring rounds, a guy from there called me today
17:24:54 <monochrom> Yes I understand.  If I pursue that, I will have to work hard on both the technology and the packaging.
17:25:17 <monochrom> I also have to demonstrate empirical benefits.
17:25:42 <monochrom> Don't worry, I know what the bosses want.
17:26:00 <Korollary> monochrom: And then you'll have to produce excel spreadsheets and pie charts and use words like synergy & leverage !
17:26:09 <monochrom> hee hee
17:26:18 <lispy> pi charts rock
17:26:28 <lispy> but i want lambda charts
17:27:03 <fnord123> I want Y combinator charts
17:27:05 <yosemite> pi chart? like some sort of trig function?
17:27:09 <Korollary> yosemite: what did they call you about ?
17:27:25 <lispy> yosemite: heh, it should be :)
17:27:26 <monochrom> It will be a lot of work.  I haven't had time yet.  The programmers are safe for now.  But they're playing fire.  One day when I'm ready, they'll regret.
17:27:34 <yosemite> Korollary: they sent me an email last month that I forgot about, inquiring if I wanted to interview
17:27:35 <lispy> yosemite: or a listing of the decimal expansion
17:27:43 <Pseudonym> Pi charts show how well pi is selling.
17:27:48 <yosemite> lispy: awesome
17:28:05 <yosemite> Korollary: so they were following up
17:28:20 <lispy> i want a base pi number system
17:28:27 <Korollary> yosemite: Nice. I didn't apply yet because I didn't see anything that was a good match for me.
17:28:28 <shapr> Like radians?
17:28:38 <yosemite> if I worked at google though I imagine a lot less haskell hacking
17:28:45 <Igloo> Bah, looks like haskell-unsafe broke
17:28:50 <monochrom> I am 5 radians high.
17:28:54 <lispy> 101 = 1*pi^2+0*pi+1
17:29:41 <Korollary> yosemite: are you hacking haskell where you currently are ?
17:30:41 <yosemite> well I work for myself.  So I can hack whatever I want. :)
17:31:19 <yosemite> I have a half-baked monitoring system (think really incomplete nagios) written in haskell
17:31:56 <Igloo> Ah, good, just the cache I think
17:32:03 <Korollary> yosemite: neat.
17:37:32 <Pseudonym> "nagios" sounds like a Spanish delicacy.
17:44:25 <mikehammad> hi, is anyone here knowledgeable about template haskell?
17:44:50 <mikehammad> i have some questions about how TH renames declarations in oxford brackets
17:45:13 <Lemmih> Then ask them.
17:45:44 * liyang points mikehammad at Igloo 
17:46:54 <mikehammad> oops, think i might have just thought up a solution
17:47:00 <mikehammad> hehe
17:50:44 <lispy> hmm...darcs is not obeying
17:51:06 <lispy> i added \.log$ to my boring file, recorded the changes and it still wants to record foo.log
17:56:07 <Korollary> Pseudonym: This google job is for you : http://www.google.com/jobs/lunar_job.html
18:01:12 <SyntaxNinja> Igloo, Lunar^...
18:01:19 <SyntaxNinja> and anyone interested in the haskell filesystem I'm working on
18:01:42 <SyntaxNinja> please send email to my work address telling me whether you think you'd try it out. ijones@galois.com
18:01:59 <SyntaxNinja> or if you think you might hack on it or test it, say so as well :)
18:02:09 <SyntaxNinja> currently it requires FUSE which is a linux kernel module, in order to "mount" it.
18:02:10 <blackdog> syntax: got a url? what does it do?
18:02:39 <Igloo> Do you want an e-mail saying probably not in the near future?
18:02:51 <blackdog> (first person to say "store files" gets a slap with a haddock.)
18:02:54 <lispy> heh
18:03:00 <SyntaxNinja> blackdog: not really; i'm giving a demo at the haskell workshop. it's just a filesystem :)
18:03:18 <lispy> Igloo: i added \.log$ to my boring file, and darcs insists on not ignoring a file named 'cdpaper.log'
18:03:20 <SyntaxNinja> it doesn't do anything fancy, bit it would probably be a good FS to experiment on.
18:03:29 <lispy> Igloo: i can add foo.log and it will be ignored.  It's so weird
18:03:30 <SyntaxNinja> Igloo: if you do'nt have any interest, you don't have to email :)
18:03:40 <lispy> Igloo: any ideas?
18:03:51 <lispy> Igloo: this is with 1.0.4pre2
18:03:54 <SyntaxNinja> I want to track interest in order to show work that it's a good idea to release it OS.
18:04:22 * Igloo is interested, just won't have time to look at it soon and it sounds a bit scary for gentle prodding  :-)
18:04:49 <Igloo> Although I assume if anything went wrong then fuse would have to be faulty too, but I'm not familiar with fuse
18:04:51 <SyntaxNinja> Igloo: well, you have to install fuse, that's the only tricky part, and that's really easy, actually.
18:05:03 <SyntaxNinja> you don't even really have to know anything about kernel modules to do it.
18:05:07 <SyntaxNinja> fuse is the thing that sshfs uses.
18:05:11 <blackdog> i wish there was a macos equivalent of FUSE. :(
18:05:20 <lispy> blackdog: yeah
18:05:36 <blackdog> gmailfs, sshfs... lots of cool stuff i don't get to play with.
18:05:40 <Pseudonym> Korollary: Hey, sounds good!
18:05:40 <Igloo> SyntaxNinja: Yeah, it's all easy until something decides to eat my data  :-)
18:05:45 <blackdog> </whing>
18:05:54 <Pseudonym> At least I wouldn't have to work in the US.
18:05:58 <SyntaxNinja> this is a basic filesystem in hfuse that Lunar^ wrote: http://cvs.haskell.org/darcs/hfuse/HelloFS.hs
18:06:08 <SyntaxNinja> it has one file with fixed content
18:06:44 <SyntaxNinja> Igloo: well, I hope you wouldn't store anything important on it while it's still in beta.
18:07:13 <blackdog> especially if it only shows the one immutable file anyway.
18:07:29 <SyntaxNinja> blackdog: HelloFS is NOT to be confused with my filesystem. duh
18:07:35 <Igloo> SyntaxNinja: No, I mean in case it eats bits of the disk it's not meant to be handling. Which I'm sure it won't, it's just not worth taking the risk if I don't have time to play with it properly
18:07:47 <blackdog> sj: yeah, i know. just teasing. :)
18:08:04 <blackdog> sj? bit dyslexic today. sorry.
18:08:17 <Korollary> heh
18:08:26 <SyntaxNinja> Igloo: the probability of it eating bits of the disk is zero
18:08:41 <SyntaxNinja> Igloo: you don't even have to mess with the disk, you can keep all the filesystem data in a flat file.
18:09:10 <SyntaxNinja> it just uses unix read & write commands, so you can use a flat file, a usb memory stick (which is what I do) or a hard drive partition.
18:09:29 <SyntaxNinja> don't thank me... thank unix.
18:10:13 <lispy> thanks, Dr. Unix!
18:10:26 <lispy> dr. unix is my friend
18:10:39 <lispy> i think he's related to dr. pepper
18:11:25 <SyntaxNinja> dr. pepper? is that sargent pepper's brother?
18:11:58 <blackdog> no, you're thinking of chili. Dr Pepper is sultan's uncle.
18:12:42 <SyntaxNinja> blackdog: that joke either went way over or way under my head
18:13:08 <shapr> blackdog: hiya!
18:13:17 <blackdog> probably under, it wasn't very sophisticated. chili pepper, salt and pepper ( -> sultan)
18:13:26 <blackdog> g'day shapr!
18:13:33 <shapr> blackdog: How's the boss?
18:13:37 <shapr> steamin?
18:13:39 <blackdog> ... bit cranky.
18:13:48 <shapr> sorry I couldn't fix your Plone probs.
18:14:04 <blackdog> no worries. mail me and tell me what happened, though, ok?
18:14:20 <shapr> Ok, easier over IRC though.
18:14:49 <SyntaxNinja> blackdog: wow. over I think.
18:15:51 <blackdog> shapr: am there now
18:16:12 <blackdog> syntax: too sophistimicated for my own good.
19:01:04 <lisppaste2> thou annotated #10451 with "ugly, but it works (I think)" at http://paste.lisp.org/display/10451#3
19:01:34 <thou> Philippa_: in case you're interested in my latest attempt at parsing an mbox  :-)
19:10:53 <lispy> thou: oh, don't do that, use a database or maildir :)
19:11:09 <lispy> mbox is evil
19:11:23 <lispy> but maybe you need to retrieve data from an mbox....
19:11:24 <lispy> yesh....
19:14:05 <thedward> the only good reason to parse an mbox is to migrate mail to something else
19:20:00 <lispy> thedward: my thoughts exactly
19:20:27 <lispy> and i think i want to move away from file based stores and start using a database
19:20:45 <thou> lispy: that's exactly what i want to do
19:20:58 <lispy> but currently maildir exported as imap is getting the job done
19:21:03 <thou> lispy: insert all mails in a database
19:21:13 <lispy> thou: ah, cool, good luck!
19:21:31 <lispy> thou: using parsec?
19:21:41 <thou> lispy: trying to, but it seems the wrong tool for the job
19:21:54 <lispy> how so?
19:22:06 <thou> i'm still learning, but i've banged my head against it for hours and still no elegant solution
19:22:15 <thou> just ugly hackish-feeling things
19:22:22 <thou> maybe happy would make it cleaner
19:22:41 <thedward> I want to write a database back imap server that lets you preform dynamic queries against your mail boxes by using requests for special mailbox names
19:22:44 * lispy doesn't like yacc/happy style parser generators
19:22:47 <thedward> database backed, even
19:23:06 <lispy> thedward: courier may support that
19:23:28 <lispy> Mail.app+spotlight on the mac does a decent job of it
19:23:47 <thedward> lispy: mmm. not the version I have installed;
19:23:54 <thedward> I want a server side solution, that'll work with any mail client
19:24:15 <lispy> thedward: i don't see any reason to have email folders, i just want to tag stuff, both manually and automaticaly
19:24:31 <thedward> so I could just open a mailbox named 'INBOX/from:foo@bar.com' and such
19:24:33 <lispy> then have folders be way to see everything with certain tags
19:24:38 <thedward> nono, not really folders
19:24:57 <lispy> thedward: sorry, just saying what i want :)
19:24:58 <thedward> you'd treat them like folders, but they'd really be dynamic queries
19:25:13 <lispy> we're thinknig along the same lines then
19:25:16 <thedward> lispy: you are saying exactly what I want. :)
19:25:23 <lispy> lol
19:25:26 <thedward> but I want a generalized solution
19:25:45 <thedward> folders only really come into it because I want to piggy back on top of imap
19:26:40 <lispy> i think i want my email to be tagged, and then have the ability to drop in agents or rules to do automatic tagging
19:26:45 <thedward> I wonder if someone has already implemented imap in haskell; The 'almost UTF-7' stuff will be fun to deal with.
19:27:00 <thedward> lispy: precisely
19:27:16 <thedward> gmail gets it ALMOST right
19:27:25 <thedward> there is no way to apply rules to mail I have already received
19:27:48 <lispy> hmm...maybe that's why it's still beta :)
19:27:58 <thou> thedward: yeah, that's a problem w/ most sorting methods
19:28:22 <thedward> I want to say "group together all the messages from paula that have the word narthex in the subject sent within the past two years, and call them frank"
19:28:37 <lispy> Mail.app and outlook both let you run youru rules on your existing folders
19:28:53 <thedward> neither of which is the least bit useful to me. :)
19:28:57 <lispy> thedward: okay i was with you until that example ;)
19:29:10 <thedward> heh
19:30:01 <lispy> heh, i just thought of new slogan for the FSF
19:30:10 <lispy> "We put the G in GNU"
19:31:07 <autrijus> lispy++ # rofl
19:31:26 <thedward> my computer is much faster now that I've upgraded to an Athlon 3k and a gig of ram.
19:31:41 <lament> lispy: that slogan makes my head explode :(
19:31:48 <thedward> (from a 700Mhz Athlon with 256M)
19:31:48 <lispy> heh
19:31:57 <lispy> thedward: oh, wow yeah that would do it
19:32:12 <thedward> I might not have to uninstall tab mix after all.
19:32:34 <lispy> tab mix....why does that sound familiar
19:32:45 <Beelsebob> Mine was much faster just by upgrading to a gig of ram
19:32:55 <Beelsebob> ... but then OS X eats ram sticks for breakfast
19:33:04 <thedward> firefox extension, let me have rows of tabs, among other things
19:33:30 <Beelsebob> buh... why would you want *that* many sites open at once?
19:33:37 <lispy> thedward: ah, i use tab browser extensions, the really huge tab plugin when i'm forced to use ff
19:34:22 <lispy> i like to never close my browser and keep interesting sites open,so i use column of tabs down the right side of the screen
19:35:03 <Beelsebob> ohhhh... amorphised linear time sorting
19:35:46 <lispy> i wish galeon ran on macos natively
19:35:50 <lispy> <3 galeon
19:36:02 <Beelsebob> amortized even
19:37:59 <lispy> i'll amortize you in a minute
19:38:22 * Beelsebob amortizes lispy
19:40:30 <Beelsebob> :) given a little info about an array, I can sort in average case linear time, and worst case n*log(n) time :)
19:41:48 <lispy> radix is even better than that, iirc
19:42:00 <Beelsebob> uhhuh?
19:42:10 <Beelsebob> @google radix
19:42:11 <lambdabot> http://www.radix.org/
19:42:16 <lispy> heh, radix sort
19:42:26 <Beelsebob> @google radix sort
19:42:28 <lambdabot> http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/radixsort.html
19:42:33 <lispy> noly works on integres
19:42:42 <lispy> and only when you have a bound
19:43:56 <lispy> then there is heap sort which is always nlogn iirc
19:44:05 <Beelsebob> ah, mine is actually a generalisation of this
19:44:25 <Beelsebob> he says place things in bin (a_i / n)
19:44:55 <Beelsebob> I say place things in bin f a_i where f is some constant time function that maps an element to it's aproximate position in the list
19:45:00 <Beelsebob> (sorted list)
19:45:09 <lispy> ah okay
19:45:47 <lispy> could you sort them the way that linux sorts processes?
19:45:56 <lispy> ie the O(1) scheduler
19:46:07 <Beelsebob> hmm?
19:46:13 <lispy> it requires that there be a fix number of priorities (which is what it sorts by)
19:46:33 <lispy> i forget now how the sort works tho
19:46:50 <Beelsebob> ah, okay... yes... but then you have a constant time function that maps an element to it's *exact* position in the sorted list
19:47:26 <lispy> ah yeah
19:47:51 <Beelsebob> oh... the other condition on mine was that the function f must never put elements out of order
19:48:01 <Beelsebob> it's alowed to put them in the same bin... but not out of order
19:48:30 <Beelsebob> oh... f must be monotonic is what I'm trying to say
19:48:43 <lispy> ah
19:48:58 <lispy> hmm...
19:49:09 <lispy> f must be monotonic?  i'm not sure you're saying that right
19:49:49 <Beelsebob> doesn't monotonic mean x <= y <=> f x <= f y
19:50:23 <lispy> maybe i miss parsed what you said earlier
19:50:40 <lispy> it can put things is the same bin (in any order) but it must not put things in the wrong bin
19:51:10 <Beelsebob> kinda
19:51:31 <Beelsebob> if x < y, then it must either put x before y, or x and y in the same place
19:51:40 <lispy> right
19:53:27 <Beelsebob> oooh... iTMS Japan
19:55:28 <lispy> is catMaybes the same as doing a monad sum?
19:55:33 <lispy> @type catMaybes
19:55:34 <lambdabot> bzzt
19:55:39 <lispy> @hoogle catMaybes
19:55:41 <lambdabot> Maybe.catMaybes :: ([(Maybe a)] -> [a])
19:56:00 <Beelsebob> I asume that just strips out the nothings?
19:56:07 <lispy> ya
19:56:23 <lispy> mzero == Nothing for the mabye monad
19:56:40 <lispy> so i thought maybe it's the same as summing the monad
19:56:41 <Beelsebob> sounds reasonable then
19:56:51 <lispy> @hoogle msum
19:56:53 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
19:57:17 <Beelsebob> hmm... that'll be a no then
19:57:37 <lispy> why?
19:57:50 <Beelsebob> because the types can't unify
19:58:01 <lispy> iirc there is an istance of MonadPlus Maybe
19:58:07 <Beelsebob> uhhuh
19:58:21 <Beelsebob> but that would get you [Maybe b] -> Maybe b
19:58:29 <Beelsebob> not [Maybe b] -> [b]
19:58:31 <lispy> @type Monad.msum [Maybe 1, Maybe 2, Nothing, Maybe 3]
19:58:32 <lambdabot> bzzt
19:59:00 <Beelsebob> @eval Monad.msum [Maybe 1, Nothing]
19:59:01 <lambdabot> Variable not in scope: `Monad.msum'
19:59:08 <Beelsebob> oh... okay then
19:59:14 <TheHunter> @eval Control.Monad.msum [Just 1, Nothing]
19:59:16 <lambdabot> Just 1
19:59:24 <Beelsebob> bah... yes
19:59:34 <lispy> @type Control.Monad.msum [Maybe 1, Maybe 2, Nothing, Maybe 3]
19:59:36 <lambdabot> bzzt
19:59:39 <joelk> how about: catMaybes = concatMap (maybe [] return)
19:59:45 <Beelsebob> @eval Control.Monad.msum [Just 1, Nothing, Just 2]
19:59:46 <lambdabot> Just 1
19:59:51 <Beelsebob> yeh... not the same
19:59:59 <TheHunter> @type \f -> Control.Monad.msum . map f
20:00:01 <lambdabot> forall (m :: * -> *) a a1.
20:00:01 <lambdabot>             (Control.Monad.MonadPlus m) =>
20:00:01 <lambdabot>             (a1 -> m a) -> [a1] -> m a
20:00:04 <Beelsebob> different types
20:00:30 <Beelsebob> where can I get a good explanation of monads
20:00:49 <Beelsebob> note... I don't want a tutorial, I want a neat definition, and some examples
20:00:50 <lispy> @type Control.Monad.msum [Just 1, Just 2, Nothing, Just 3]
20:00:52 <lambdabot> forall a.
20:00:52 <lambdabot>                    (Num a) =>
20:00:52 <lambdabot>                    Maybe a
20:01:12 <lispy> heh, I had the wrong contructor :)
20:01:20 <lispy> @hoogple catMaybes
20:01:22 <lambdabot> Maybe.catMaybes :: ([(Maybe a)] -> [a])
20:01:31 <Beelsebob> um... okay
20:01:44 <Beelsebob> when did lambdabot start understanding @hoogple
20:01:45 <TheHunter> i don't like hoogle's prettyprinter
20:01:46 <lispy> @type map fromJust (Control.Monad.msum [Just 1, Just 2, Nothing, Just 3])
20:01:47 <lambdabot> bzzt
20:01:59 <TheHunter> @type Data.Maybe.catMaybes
20:02:00 <lambdabot> forall a. [Maybe a] -> [a]
20:02:03 <lispy> @type Maybe.fromJust
20:02:05 <lambdabot> forall a. Maybe a -> a
20:02:09 <Beelsebob> the hunter: complain to neil... I'm sure he'll tell you he has bigger problems on his mind ;)
20:02:16 <lispy> TheHunter: i prefer it :)
20:02:17 <dons> TheHunter, its in cvs, he's happy to accept patches
20:02:31 <TheHunter> i'm not going to touch cvs.
20:02:33 <dons> or, our Hoogle plugin could run a @type filter over the output
20:02:43 <Beelsebob> anyway... I'm not sure it has a pretty printer
20:02:48 <dons> I know, I know -- I tried to convince him repeatedly to use darcs
20:02:52 <Beelsebob> I think it just spits out what's in it's database
20:02:59 <Beelsebob> dons: I tried that one too
20:03:14 <lispy> @type map Maybe.fromJust (Control.Monad.msum [Just 1, Just 2, Nothing, Just 3])
20:03:15 <lambdabot> bzzt
20:03:19 <dons> he'll get more patches if its in darcs :/ sigh
20:03:42 <Beelsebob> so will hat be more popular if it's moved into darcs then?
20:03:44 <Beelsebob> *g*
20:03:55 <dons> yes
20:04:05 <TheHunter> lispy, unnecessary parens are bad.
20:04:18 <dons> I think darcs is important for projects in haskell seeking contributors from the community
20:04:21 <Beelsebob> hmm... what the hell are monads sounds like a good start
20:04:42 <Beelsebob> unfortunately monads appear to be a 404
20:04:55 <dons> in our little world here we're throwing darcs hunks at each other all day long.
20:05:03 <lispy> @type Maybe.fromJust (Control.Monad.msum [Just 1, Just 2, Nothing, Just 3])
20:05:05 <lambdabot> forall a.
20:05:05 <lambdabot>                          (Num a) =>
20:05:05 <lambdabot>                          a
20:05:09 <dons> if the project isn't in darcs, then that project has a greater barrier to entry
20:05:20 <dons> which might just be enough for people not to bother sending in fixes
20:05:25 <Beelsebob> hmm, dons, I'm not sure I agree
20:05:25 <TheHunter> absolutely.
20:05:28 <metaperl> I wonder if SyntaxNinja's company Galois uses darcs... it wasn't outwhen they wre established
20:05:29 <lispy> @eval fromJust (Control.Monad.msum [Just 1, Just 2])
20:05:30 <lambdabot> 1
20:05:34 <Beelsebob> pretty much everyone has cvs on their box
20:05:46 <Beelsebob> only Haskellers tend to have darcs
20:05:56 <TheHunter> but cvs is a pain in the ass to use.
20:06:07 <lispy> yeah, and cvs isn't useful
20:06:10 <dons> a lot of people don't know how to construct a valid patches with cvs
20:06:21 <TheHunter> i can't do it without somebody telling me exactly what to do.
20:06:29 <lispy> same here
20:06:31 <Beelsebob> eh? You change the source and you commit, simple as that
20:06:48 <lispy> Beelsebob: andwhen yo udon't have permission to commit?
20:06:56 <dons> that's not the kind of model we're discussing though.
20:07:01 <Beelsebob> ah, okay... fair enough
20:07:08 <dons> 1) set up anonymous cvs.. oh, too hard. give up.
20:07:16 <Beelsebob> eh... anon is easy
20:07:17 <dons> 2) learn how to use cvs diff and patch
20:07:20 <Beelsebob> it's authed that's hard
20:07:22 <dons> more people give up
20:07:45 <lispy> i gave up, it looked like a security problem
20:08:05 <Beelsebob> fair enough, you have convinced me
20:08:08 <lispy> plus i didn't use version control when i thought cvs was theh only optino :)
20:08:18 <blackdog> dons: can i convince you to come out this friday?
20:08:19 <Beelsebob> heh
20:08:24 <lispy> i tried it once, and it freaked out on me....
20:08:26 <Beelsebob> I tend to use svn anyway
20:08:38 <Beelsebob> but that's because I know people who are scared of darcs
20:08:53 <dons> blackdog, I'm tedning towards it. I'll confirm this arvo
20:08:56 <lispy> Beelsebob: scared with good reason or just phobic?
20:09:03 <Beelsebob> phobic
20:09:09 <blackdog> darcs is a big cuddly teddy bear
20:09:22 <blackdog> cvs has teeth in places teeth shouldn't be
20:09:24 <dons> I think we could in fact find a large increase in cross-project contributions *within our community* when people switched to darcs
20:09:30 <Beelsebob> ... that can look like a big black bear if you don't know about Haskell
20:09:30 <blackdog> why would you be scared of darcs?
20:09:44 <dons> i get a lot more patches now than I ever did when hs-plugins was in cvs
20:09:57 <Beelsebob> fair enough
20:10:08 <Beelsebob> I may prod Malcolm to put it into darcs
20:10:11 <blackdog> dons: that was a private cvs repo, wasn't it?
20:10:26 <Beelsebob> after all proding him for write access is not proving too successful
20:10:30 <dons> yeah, but I made the src available
20:10:40 <dons> I got maybe 3 proper diffs in a year
20:10:56 <dons> now I get maybe 3 a week
20:11:00 <dons> more perhaps
20:11:06 <lispy> now it's just hack, darcs record, darc ssend
20:11:07 <Beelsebob> I can't really submit patches because changes I make tend to be... well... just add these 4 files, and then rewrite these ones... this would be different with access to the repo
20:12:16 <lispy> @hoogle msum
20:12:17 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
20:12:29 <lispy> @hoogle [(a b)] -> [(a b)]
20:12:30 <lambdabot> Prelude.tail :: ([a] -> [a])
20:12:30 <lambdabot> Prelude.init :: ([a] -> [a])
20:12:30 <lambdabot> Prelude.reverse :: ([a] -> [a])
20:12:33 <TheHunter> @type Control.Monad.msum
20:12:35 <lambdabot> forall a (m :: * -> *).
20:12:35 <lambdabot>         (Control.Monad.MonadPlus m) =>
20:12:35 <lambdabot>         [m a] -> m a
20:13:04 <Beelsebob> @hoogle MonadPlus a => [(a b)] -> [b]
20:13:05 <lambdabot> Prelude.concat :: ([[a]] -> [a])
20:13:05 <lambdabot> Maybe.catMaybes :: ([(Maybe a)] -> [a])
20:13:05 <lambdabot> Monad.join :: Monad a => ((a (a b)) -> (a b))
20:13:40 <lispy> i guess catMaybes is sort of special
20:14:03 <lispy> @hoogle [m a] -> [a]
20:14:04 <lambdabot> Prelude.concat :: ([[a]] -> [a])
20:14:04 <lambdabot> Maybe.catMaybes :: ([(Maybe a)] -> [a])
20:14:04 <lambdabot> Monad.join :: Monad a => ((a (a b)) -> (a b))
20:14:17 <lispy> @hoogle concatM
20:14:18 <lambdabot> Prelude.concatMap :: ((a -> [b]) -> [a] -> [b])
20:14:53 <lispy> @hoogle filterM
20:14:54 <lambdabot> Monad.filterM :: Monad a => ((b -> (a Bool)) -> [b] -> (a [b]))
20:15:15 <Beelsebob> Just to check I'm not being a numb nut here... a Monad is simply something in the monad class, and hence something with a bind and return operator defined, yes?
20:15:18 <TheHunter> "Monad a" makes me wanna cry.
20:15:19 <lispy> there is mzero, is there an mone?
20:15:33 <TheHunter> return?
20:16:00 <lispy> Beelsebob: in haskell that's right, but there are three laws that a monad *should* follow
20:16:01 <Beelsebob> as in return :: a -> m a
20:16:17 <Beelsebob> ... wrap this in the monad
20:16:22 <TheHunter> and every Monad should be a Functor.
20:17:02 <lispy> i forget what it takes to be a functor
20:17:09 <Beelsebob> hmm... how is >> implemented for Maybe?
20:17:13 <TheHunter> @type fmap
20:17:15 <lambdabot> forall (f :: * -> *) b a.
20:17:15 <lambdabot>    (Functor f) =>
20:17:15 <lambdabot>    (a -> b) -> f a -> f b
20:17:24 <Beelsebob> surely it's not possible to do with a lazy evaluator
20:17:29 <lispy> @type (>>)
20:17:30 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
20:17:34 <TheHunter> Nothing >> _ = Nothing
20:17:41 <TheHunter> Just _ >> a = a
20:18:10 <Beelsebob> but doesn't >> just ignore the first argument?
20:18:19 <lispy> @eval Nothing >> Just 1
20:18:20 <lambdabot> Nothing
20:18:25 <TheHunter> m >> n = m >>= \_ -> n
20:18:29 <lispy> @eval Just 1 >> Nothing
20:18:31 <lambdabot> Ambiguous type variable `a' in the top-level constraint
20:19:02 <TheHunter> @eval Just (1::Int) >> Nothing
20:19:03 <lambdabot> Ambiguous type variable `a' in the top-level constraint
20:19:06 <Beelsebob> theHunter: okay... so if that's the case, then surely m would never be evaluated
20:19:17 <lispy> @eval Just 1 >> Just 2
20:19:18 <lambdabot> Just 2
20:19:41 <TheHunter> Beelsebob, sure it will, look at my >> definition.
20:20:01 <Beelsebob> hang on... *does some paper rewrites*
20:20:17 <lispy> so Just _ >> a = a makes sense, but why is Nothing >> _ = Nothing?
20:20:25 <TheHunter> just the values the monad produces are discarded, but the side effects are used.
20:21:05 <TheHunter> Nothing means failure. If a computation fails and then does something else, well it fails.
20:21:23 <Beelsebob> ah yeh... that makes sense
20:21:27 <lispy> TheHunter: actually, i'm loking at the >>= line and it's becoming more clear
20:21:39 <Beelsebob> sorry, I was getting confused by the way it was phrased on the stuff I'm reading
20:22:34 <TheHunter> have you seen Cale's http://www.haskell.org/hawiki/MonadsAsContainers ?
20:22:45 <Beelsebob> I haven't
20:22:51 <Beelsebob> I will look there next
20:22:56 <Beelsebob> "Here, the infix operator >>= is used instead of then, and a shorthand version >> is defined, which ignores the result of the first action."
20:23:12 <Beelsebob> which sugests that the result of the first action has no effect on the outcome at all
20:23:29 <lispy> @eval let concatM xs = filter (not . (==mzero)) xs in concatM [[1..3],[],[4..6]]
20:23:30 <lambdabot> [[1,2,3],[4,5,6]]
20:23:34 <Beelsebob> rather than making clear that "fail" is still possible
20:24:00 <lispy> i was expecting to have a function like that
20:24:20 <lispy> @eval let concatM xs = filter (not . (==mzero)) xs in concatM [Just 1, Nothing, Just 2]
20:24:22 <lambdabot> [Just 1,Just 2]
20:24:44 <Beelsebob> lispy: you want to take the items out of the monad too
20:24:54 <TheHunter> lispy, not many monads promote Eq.
20:25:56 <lispy> are there other ways to check for mzero?
20:26:38 <TheHunter> not in the libs, and I think that's reasonable.
20:27:01 <TheHunter> there are of cource null and isNothing, you can put them into a type class if you want
20:28:37 <Beelsebob> why is there not a giveItBackYouBastardMonad :: m a -> a function?
20:29:15 <TheHunter> for some monads there is, for others it's not implementable.
20:29:39 <Beelsebob> I asume you mean like IO
20:29:59 <TheHunter> for example.
20:30:15 <TheHunter> or Cont r a for r =/= a
20:30:16 <Beelsebob> but... why isn't it implementable there? surely it would mean "I want to define an order over the bits in the monad, but not over the bits where I've taken it out"
20:30:26 <Beelsebob> ... pardon?
20:30:49 <TheHunter> Cont r the continuation monad.
20:31:05 <Beelsebob> oh, okay
20:31:07 <TheHunter> i don't follow.
20:31:12 <lispy> TheHunter: i made a monad once (the identity monad) but you could always get it back using pattern matching
20:31:44 <lispy> TheHunter: is there a way in that case that i could have prevented people from taking things out of the monad?
20:31:45 <Beelsebob> well... isn't the reason for not taking things out of the IO monad that you cease to define an order in which to do the IO
20:31:56 <TheHunter> yes the Identity monad has a trivial giveItBackYouBastardMonad implementation.
20:32:15 <TheHunter> lispy, not exporting constructor or accessor.
20:32:18 <Beelsebob> but why can't I just say... if and when the value of this function is demanded, do this peice of sequenced IO
20:32:25 <lispy> TheHunter: ah ha
20:32:32 <lispy> TheHunter: thanks
20:33:19 <TheHunter> Beelsebob, that's not the reason. The reason is that it won't be a function any more because it depends on the state of the outside world.
20:33:35 <TheHunter> *wouldn't
20:34:02 <Beelsebob> yes... but xyv :: a -> IO b is a function
20:34:08 <Beelsebob> but can return different things
20:34:16 <Beelsebob> that doesn't make the world any cleaner
20:34:47 <TheHunter> it's a function, because something of type IO b is just a recipe how to get a value of type b, not the value itself
20:35:26 <Beelsebob> ahhh, okay... course... so that then returns, and you get binds that put them in order and it's all happy and smily
20:35:40 <Beelsebob> but then... why does unsafePerformIO exist if that's the reason?
20:36:18 <lispy> unsafePreformIO is safe sometimes
20:36:33 <TheHunter> unsafePerformIO exists because sometimes things are functions even though you can't write them safely.
20:36:34 <Beelsebob> I know
20:36:34 <lispy> and when it's safe, it's sort of convienent
20:36:41 <Beelsebob> like... when you can guarentee no sharing
20:36:56 <Beelsebob> okay... fair enough
20:37:07 <lispy> BUT it's not part of haskell
20:37:14 <Beelsebob> it isn't?
20:37:21 <Beelsebob> I thought it was in an adendum
20:37:22 <lispy> it's an extension that several compilers allow :)
20:37:31 <lispy> maybe it is, but it's not in 98
20:37:45 <Beelsebob> ... neither is the FFI ;)
20:38:01 <lispy> well, you can't think of everything ;)
20:38:11 <lispy> at least not in the first official version
20:38:17 <Beelsebob> heh
20:38:34 <Beelsebob> yeh... was it you up to pushing for some ideas on Haskell 2?
20:38:46 * lispy wonders when Haskell 20xy will come out
20:38:54 <Beelsebob> my bet's on 06
20:39:06 <Beelsebob> late 06
20:39:10 <palomer> is it going to be big?
20:39:27 <Beelsebob> no one knows yet... it's mostly a load of mumbling right now
20:39:35 <lispy> palomer: i dunno, but we'll have to party like it's 1998
20:39:48 <Beelsebob> lol
20:40:09 <Beelsebob> I actually see the next Haskell standard as a big thing...
20:40:30 <Beelsebob> because it'll give a comon set of things that everyone bitches about in 98 for everyone to implement
20:40:36 <lispy> will it have fun. deps?
20:40:37 <Beelsebob> and it'll mean more compiler and tool choice
20:41:08 <Lemmih> @seen SyntaxNinja
20:41:09 <lambdabot> I saw SyntaxNinja leaving #haskell 2 hours, 11 minutes and 45
20:41:09 <lambdabot> seconds ago.
20:41:31 <TheHunter> i don't know. There isn't even a decent module system implemented in any haskell compiler's extensions yet.
20:41:36 * lispy doesn't approve of lambdabot's reckless line breaking ;)
20:41:49 <TheHunter> what does lispy suggest?
20:42:16 <TheHunter> increase the line break limit?
20:42:30 <lispy> TheHunter: expect when doing this that were meant to have layout (like @type) it would be nice to let my client break the lines
20:42:45 <Beelsebob> theHunter: I'd sugest doing the line breaking and then recovering orphans
20:45:15 <TheHunter> patches are welcome :)
20:45:34 <TheHunter> i should tell you though, that the output filter system is a bit of a mess.
20:45:35 <lispy> @type liftM
20:45:36 <lambdabot> bzzt
20:45:43 <lispy> @hoogle liftM
20:45:45 <lambdabot> Monad.liftM :: Monad a => ((b -> c) -> (a b) -> (a c))
20:45:45 <lambdabot> Monad.liftM3 :: Monad a => ((b -> c -> d -> e) -> (a b) -> (a c) -> (
20:45:45 <lambdabot> a d) -> (a e))
20:45:45 <lambdabot> Monad.liftM2 :: Monad a => ((b -> c -> d) -> (a b) -> (a c) -> (a d))
20:48:04 <TheHunter> don's point stands, if hoogle was under darcs, i'd certainly have tried to fix the uglyprinter by now.
20:48:26 <TheHunter> [aside, grammar question: in the above sentence, is was or were better?]
20:49:21 <lispy> my guess is was -> would try, were -> have tried
20:50:31 <lispy> @hoogle mplus
20:50:48 <lispy> @hoogle plus
20:51:12 <lispy> @vixen please don't give me the silent treatment
20:51:14 <lambdabot> don't beg
20:51:18 <lispy> sorry...
20:51:42 <TheHunter> lispy, are you sure?
20:51:49 <lispy> @hoogle MonadPlus a => a -> a -> a
20:51:50 <lambdabot> Prelude.asTypeOf :: (a -> a -> a)
20:51:50 <lambdabot> Prelude.(**) :: Floating a => (a -> a -> a)
20:51:50 <lambdabot> Prelude.logBase :: Floating a => (a -> a -> a)
20:52:04 <TheHunter> iirc, hoogle ignores constraints.
20:52:08 <lispy> TheHunter: no i'm not ;)
20:52:22 <lispy> TheHunter: that's why i said "my guess" :)
20:52:47 <TheHunter> native speaker?
20:52:53 <lispy> ya
20:53:03 <TheHunter> ok, then i don't have to know either.
20:53:12 <lispy> heh
20:53:48 <lispy> well, was matches up with present and one of the future tenses, that was my reasno for the was combo
20:53:59 <TheHunter> but I still don't believe it because was and were are the same tense.
20:54:21 <lispy> they overlap?
20:54:33 <lispy> I wouldn't say "I were kidding"
20:55:00 <lispy> oh, i give up
20:55:00 <TheHunter> you'd probably say "If I were you"
20:55:10 <lispy> english sucks :)
20:55:39 <TheHunter> I don't know, both "if I were you" and "if I was you" sound correct to me, but the first one sounds better.
20:55:59 <TheHunter> in the above sentence, it's just the other way round.
20:56:16 <TheHunter> maybe I should get a decent English grammar and look it up..
20:56:20 <lispy> @dict was
20:56:21 <lambdabot> Supported dictionary-lookup commands:
20:56:21 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
20:56:21 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
20:56:21 <lambdabot> Use "@dict-help [cmd...]" for more.
20:56:58 <lispy> oh, lambda bot should consider @foo to be one word
20:57:27 * lispy puts another thing on his imaginary list of things to fix in lambdabot
20:57:50 <TheHunter> why not put it in the non-imaginary list
20:57:53 <TheHunter> @help todo-add
20:57:54 <lambdabot>  @todo-add <idea>, add a todo entry
20:58:11 <TheHunter> @todo
20:58:12 <lambdabot> 0. dons: Release lambdabot 3.0
20:58:12 <lambdabot> 1. SamB: A way to get multiple results from a google search
20:58:12 <lambdabot> 2. SamB: @get-shapr summons shapr instantly
20:58:12 <lambdabot> 3. SamB: bare @part either gives error message or parts the channel
20:58:12 <lambdabot> the command was given on
20:58:14 <lambdabot> 4. SamB: stop mangling long urls
20:58:15 <lambdabot> 5. dons: improve formatting of @dict
20:58:17 <lambdabot> 6. dons: write Haskell Manifesto
20:58:28 <lispy> @todo-add don't let lambdabot's prettyprinter split the sequence @foo across lines
20:58:29 <lambdabot> Entry added to the todo list
20:58:48 <lispy> i like 2
20:58:50 <palomer> we should add functors in haskell 06
20:59:09 <lispy> palomer: doesn't haskell have functors?
20:59:11 <palomer> why not just steal sml's module system?
20:59:18 <TheHunter> @version
20:59:19 <lambdabot> lambdabot 3p64, GHC 6.4.1 (OpenBSD i386)
20:59:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:59:25 <TheHunter> @todo-del 0
20:59:25 <lambdabot> Removed: Release lambdabot 3.0
20:59:27 <palomer> I didn't know haskell had a module system:O
20:59:46 <Pseudonym> It doesn't. :-)
20:59:52 <palomer> so how could it have functors?
21:00:03 <Pseudonym> It has a here's-how-to-put-code-in-different-files system.
21:00:27 <lispy> palomer: we are talking about different concepts it appears
21:00:34 <TheHunter> it has functors, but not sml-like functors which are an unfortunate misnomer..
21:00:48 <palomer> oh, I meant sml-functors
21:01:00 <palomer> sml...what a sweet module system
21:01:01 <lispy> @hoogle mplus
21:01:12 <lispy> i know mplus is real, why doesn't hoogle find it
21:01:13 <palomer> (I wish functors could take more than one argument!)
21:01:16 <lispy> @index mplus
21:01:17 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
21:01:17 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
21:01:17 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
21:01:34 <lispy> @type Control.Monad.mplus
21:01:35 <lambdabot> forall (m :: * -> *) a.
21:01:35 <lambdabot>         (Control.Monad.MonadPlus m) =>
21:01:35 <lambdabot>         m a -> m a -> m a
21:01:48 * autrijus is watching in amusement as cow orkers begins porting OpenAFP.hs to Java
21:01:58 <lispy> @eval Control.Monad.mplus Just 1 Nothing
21:02:00 <lambdabot> <Plugins.Eval>:1:
21:02:00 <lambdabot>   No instances for (MonadPlus ((->) (Maybe a)),
21:02:00 <lambdabot>         Num (Maybe a -> Maybe (Maybe a)))
21:02:00 <lambdabot>   arising from use of `mplus'
21:02:19 <Pseudonym> @eval Control.Monad.mplus (Just 1) Nothing
21:02:21 <lambdabot> Just 1
21:02:30 <Pseudonym> @eval Control.Monad.mplus Nothing (Just 42)
21:02:31 <TheHunter> @google "first class modules for haskell"
21:02:31 <lambdabot> Just 42
21:02:32 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/first-class-modules/
21:02:44 <palomer> functors!
21:02:46 <palomer> higher order modules!
21:02:52 <palomer> gooooooooo sml
21:02:55 <Pseudonym> @kind Functor
21:02:57 <lispy> @eval Control.Monad.mplus (Just 1) (Just 2)
21:02:57 <lambdabot> bzzt
21:02:59 <lambdabot> Just 1
21:03:01 <palomer> if haskell had higher order modules, I'd switch and never look back
21:03:04 <Pseudonym> @kind Control.Monad.Functor
21:03:05 <lambdabot> bzzt
21:03:09 <Pseudonym> Errr...
21:03:17 <Pseudonym> @type fmap
21:03:18 <lambdabot> forall (f :: * -> *) b a.
21:03:18 <lambdabot>    (Functor f) =>
21:03:18 <lambdabot>    (a -> b) -> f a -> f b
21:03:23 <Pseudonym> There you go.  Functors.
21:03:42 <TheHunter> i wonder why the ideas from this paper have never been implemented.
21:04:43 <palomer> yes!
21:04:44 <palomer> implement!
21:04:54 <palomer> then you'll have something that sml doesn't
21:04:57 <palomer> recursive modules
