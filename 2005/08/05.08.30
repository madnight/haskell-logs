00:07:28 * boegel waves at Philippa 
00:11:41 <newsham> tmr article url please?
00:16:28 <newsham> found it
00:16:51 <newsham> (hint: some of us might not know the expansion for "TMR" ;-)
00:17:54 <newsham> ick, why did you use glade?
00:25:29 <wilx> @tmr
00:25:30 <lambdabot> Aye
00:25:46 <wilx> @tmrwiki
00:25:46 <lambdabot> Unknown command, try @listcommands.
00:25:54 <wilx> Hm.
00:26:02 <newsham> @listcommands
00:26:03 <lambdabot> use listcommands [module|command], please. Modules are:
00:26:03 <lambdabot> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
00:26:03 <lambdabot> haddock help hoogle karma lambda more pl plugs quote search seen
00:26:03 <lambdabot> spell state system todo topic type version vixen where
00:26:16 <newsham> @elite foo bar
00:26:17 <lambdabot> F00 8Ar
00:26:40 <newsham> @dict `"'><|foobar
00:26:41 <lambdabot> Supported dictionary-lookup commands:
00:26:41 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
00:26:41 <lambdabot> jargon @lojban @prelude @vera @web1913 @wn @world02
00:26:41 <lambdabot> Use "@dict-help [cmd...]" for more.
00:28:55 <boegel> newsham: because it's very usefull ? why shouldn't I use glade ?
00:29:24 <newsham> I find it easier and more flexible to build gui's with code.
00:34:25 <boegel> newsham: have you tried glade lately ? nothing more flexible than that
00:34:37 <boegel> i used to think that too, but glade is _really_ usefull
00:34:40 <newsham> I wrote an application last year that partially used glade.
00:35:10 <boegel> writing GUI's using code is so 90's
00:35:16 <newsham> actually a coworker started writing the framework in glade and I found lots of it to be constraining and overly complex to interact with
00:35:31 <newsham> so I pared down the parts that were constructed in glade as we went
00:42:17 <boegel> well, I've never written any big gui's with it, but for simple ones it works great for me
01:11:45 <xerox> Hey hey hey.
01:12:35 <boegel> hi Dr. Nick !
01:14:22 <lispy_> (i'm going to bed, but if anyone is interested...) I have instructions now for getting the quake3 sources to build properly on osx and a darcs repo: http://www.codersbase.com/Quake3
01:15:56 <boegel> cool
01:16:21 * boegel feels an urge coming up for some fraggin'
01:16:33 * Itkovian has downloaded the sources yesterday
01:17:03 * Itkovian will transfer his .pk3 files and cd key tonight
01:17:23 <newsham> is there a quake<->haskell connection or is this just general interest?
01:19:16 <Itkovian> newsham: I recall there being a quake1 haskell player ...
01:19:36 <Itkovian> so maybe we should just convert the q3 sources as well and show the world that q3 in haskell actually plays eh.
01:20:12 <Itkovian> besides, nice to see darcs being used for a pretty large repo.
01:20:52 <newsham> hmm.. yet another revision control system.  I havent heard of this one yet.
01:21:13 <newsham> any relation to larch or is the name similarity just coincidental
01:21:28 <newsham> someday every project will have its own revision control system :)
01:22:08 <boegel> newsham: darcs is probably superior to every other revision control system :)
01:22:19 <newsham> of course, thats why they wrote it, right? :)
01:23:24 <newsham> i'm a cvs weenie myself, but i've had some exposure to bitkeeper and mercurial (hg) recently
01:23:31 <newsham> both seemed nice
01:24:22 <boegel> newsham: you should give darcs a try, it'll get you hooked :) :p
01:24:38 <newsham> someday i might have time to look at it.  not tonight :\
01:25:00 <boegel> night ? it's 10.30am for god sake :)
01:25:07 <newsham> have you used larch, bitkeeper or mercurial?  would be interesting to hear how they compare and what the pros/cons are
01:25:16 <newsham> Mon Aug 29 22:26:20 HST 2005
01:25:25 <newsham> i'm on the other side of the planet from you
01:26:26 <newsham> hmm..  ">>=" is like unix pipe sorta, no?  that analogy would make this tutorial easier to understand
01:26:30 <newsham> (if its correct :)
01:27:40 <ski> sort of (for IO monad, i.e.)
01:28:30 <boegel> newsham: you guys changed time over there or something ? you crazy fuckers :p
01:28:46 <newsham> boegel: I'm in hawaii, gmt-10.
01:28:52 <newsham> i take it you're gmt+2 currently
01:28:58 <boegel> +1
01:29:19 <newsham> if its 1030a it must be +2 currently (dst?)
01:29:24 <ski> newsham : an operator defined as  '(>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c);  (amb >@> bmc) a = amb a >>= bmc'  could be considered more 'unix-pipe'-alike, though
01:29:29 <newsham> its 830a gmt
01:29:39 <boegel> newsham: or you wearing a skirt and flowers and wiggling your hips using a hula-hoop as we speak ?
01:29:56 <newsham> no, is 1030p, we only do that until 5pm.
01:30:18 <boegel>  UK is on British Summer Time (GMT+1)
01:30:18 <boegel> and NOT GMT - GMT does NOT switch! -> that's why I was mistaken
01:30:48 <newsham> *nod*
01:30:52 <newsham> we also dont switch here (thankfully)
01:30:56 <newsham> DST is silly
01:31:21 <newsham> you cant save daylight anymore than america can save money.
01:31:41 <boegel> hey, I didn't decide on this, you know :p
01:36:15 <xerox> ski: nice, any practical use case in Haskell for (>@>) ?
01:49:29 <ski> xerox : for things similar to "foo . bar x . baz . quux y z", but monadic, i think
01:50:28 <ski> xerox : iirc, i saw (>@>) in Haskell: The Craft of Functional Programming
01:51:36 <ski> (btw, the operator is basically morphism composition in the kleisli category of the monad .. and 'return' is it's identity morphism)
01:52:25 <newsham> average word length in that sentance is too high
01:52:37 <ski> heh
01:53:37 <ski> newsham : you of course don't need to understand that to use (>@>) :) just i thought i could be interesting
01:54:05 <ski> eh s/i could/it could/ :)
01:54:08 <xerox> ski: sounds like an arrow?
01:54:17 <ski> m-m
01:54:17 <xerox> dcoutts: ping!
01:54:18 <Lor> Isn't >@> the >>> for the monad arrow?
01:54:27 <ski> yes
01:54:35 <xerox> I felt it.  Cool.
01:55:47 * ski thinks the 3 monad laws reads more easily with (>@>) instead of (>>=)
01:55:47 <bargle> is there a function of type (Monad m) => m a -> (a -> b) -> m b?
01:56:02 <ski> return >@> amb = amb
01:56:05 <roconnor> liftM
01:56:11 <ski> amb >@> return = amb
01:56:35 <ski> (amb >@> bmc) >@> cmd = amb >@> (bmc >@> cmd)
01:56:36 <xerox> ski: amb sounds like that non-deterministic operator :-)
01:56:41 <bargle> hmm, liftM is missing the m a part
01:56:54 <ski> xerox : and 'cmd' sounds like 'command' :)
01:56:55 <boegel> @hoogle m a -> (a -> b) -> m b
01:56:56 <lambdabot> Prelude.fmap :: Functor a => (b -> c) -> a b -> a c
01:56:56 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
01:56:56 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:57:05 <adept> wow!
01:57:12 <adept> whats hoogle?
01:57:21 <boegel> adept: google for Haskell
01:57:24 <roconnor> @type Monad.liftM
01:57:25 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m
01:57:25 <lambdabot> r
01:57:37 <roconnor> @type (swap Monad.liftM)
01:57:39 <lambdabot> bzzt
01:57:43 <boegel> @hoogle list
01:57:44 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
01:57:44 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
01:57:44 <lambdabot> Prelude.readList :: Read a => ReadS [a]
01:57:52 <adept> boegel: but why it found 'Prelude.map :: (a -> b) -> [a] -> [b]'?
01:57:57 <boegel> you gotta love lambdabot
01:58:01 <yaarg> neat
01:58:04 <boegel> adept: dunno :)
01:58:08 <ski> @type flip Monad.liftM
01:58:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m
01:58:10 <lambdabot> r
01:58:18 <boegel> adept: ask lambdabot , not me :p
01:58:23 <adept> :)
01:58:42 <roconnor> @type (flip Monad.liftM)
01:58:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m
01:58:44 <lambdabot> r
01:58:59 <roconnor> there you go bargle.
01:59:07 <ski> adept : the 'map' function for lists is a special case of 'fmap'/'liftM'
01:59:08 <bargle> the only problem is that p `flip Monad.liftM` f doesn't work :-)
01:59:38 <roconnor> @type (flip fmap)
01:59:39 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f
01:59:39 <lambdabot> b
01:59:55 <roconnor> try (flip fmap) ;-)
02:00:16 <adept> ski: neat
02:00:23 <ski> (`Monad.liftM` p) $ \x -> ...
02:00:36 <xerox> adept: because list is a monad?
02:00:37 <ski> (works for 'map' and such, too)
02:00:46 <ski> xerox : yes
02:01:22 <ski> xerox : or, in the fmap case, because list is a functor   (fmap should really = liftM for monads)
02:01:23 <roconnor> or you do try f `Monad.liftM` p
02:01:48 <ski> roconnor : that doesn't read as easily with f being a lambda
02:02:02 <bargle> roconnor: that gets a bit ugly; p is a parser whose results I want to pipe through f
02:02:18 <ski> bargle : you saw my suggestion ?
02:02:38 <ski> hm
02:02:51 <bargle> ski: yeah
02:03:04 <bargle> I think I'll define my own >>= variant
02:03:05 <ski> bargle : maybe i misunderstood what you wanted .. will your f be a lambda often ?
02:03:12 <bargle> ski: no
02:03:42 <ski> hm, but you want to be able to "pipe through" many such f's ?
02:03:54 <roconnor> Is there a way for me to profile the time spend in Prelude.gcd ?
02:04:16 <bargle> yes, if possible
02:04:20 <adept> roconnor: your platform/OS?
02:04:37 <roconnor> linux
02:04:45 <roconnor> debian
02:04:46 <ski> bargle : and each such f is a function not in parser monad ?
02:04:56 <dcoutts> xerox, pong
02:04:59 <roconnor> actually ubuntu, but whatever
02:05:00 <bargle> ski: right
02:05:23 <ski> Monad.liftM (f0 . f1 x . f2 . f3 y z) p     ?
02:05:26 <xerox> dcoutts: what do you think about gazpacho?
02:05:32 <dcoutts> gazpacho?
02:05:33 <adept> roconnor: i believe that with ghc6-prof it is possible
02:05:36 <dcoutts> @google gazpacho
02:05:38 <lambdabot> http://www.globalgourmet.com/food/egg/egg0896/gazpacho.html
02:05:43 <dcoutts> hmm
02:05:58 <xerox> http://gazpacho.sicem.biz/
02:06:01 <roconnor> adept, I got that, but I'm trying to figure out how to profile things in the standard library.
02:06:27 <dcoutts> xerox, ah! gazpacho
02:06:42 <bargle> another question: are there predefined "type templates" to save typing? like type Combine a = a -> a -> a or type Filter a = [a] -> [a]?
02:07:15 <adept> roconnor: so, you have ghc6-prof installed and no 'gcd' in profiling output?
02:07:16 <ski> bargle : or how about   (`Monad.liftM` p) $ f3 y z >.> f2 >.> f1 x >.> f0      where (>.>) = flip (.)      .. if you want the other order
02:07:17 <xerox> bargle: prolly not
02:07:24 <dcoutts> xerox, it claims that it produces standard .glade files so I guess it's ok
02:07:35 <xerox> dcoutts: /me tries
02:08:21 <greenrd> @hoogle (a -> Bool) -> (a -> Bool)
02:08:22 <lambdabot> Prelude.log :: Floating a => a -> a
02:08:22 <lambdabot> Prelude.atan :: Floating a => a -> a
02:08:22 <lambdabot> Prelude.significand :: RealFloat a => a -> a
02:08:32 <xerox> @hoogle+
02:08:33 <greenrd> huh?
02:08:33 <lambdabot> Prelude.signum :: Num a => a -> a
02:08:33 <lambdabot> Prelude.id :: a -> a
02:08:33 <lambdabot> Prelude.abs :: Num a => a -> a
02:08:56 <bargle> ski: I think p >>+ f = p >>= (return . f) looks better
02:08:59 <roconnor> Well, I want to profile the time spent in gcd called by (%) called by various functions in Ratio.
02:09:19 <greenrd> @help hoogle
02:09:20 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
02:09:27 <xerox> @pl \f xs -> xs >>= return . f
02:09:29 <xerox> fmap!
02:09:30 <lambdabot> fmap
02:10:03 <greenrd> Why does @ hoogle  (a -> Bool) -> (a -> Bool) return the results above? Is that a bug?
02:10:05 <ski> bargle : so better define as  (>>+) = flip fmap
02:10:34 <bargle> ski: yeah, I also have to make Parser an instance of Functor
02:11:00 <ski> should be trivial, if it's not already an instance
02:11:13 <ski> instance Functor Parser where fmap = Monad.liftM
02:12:32 <bargle> @hoogle Monad m => m a -> m b -> m a
02:12:32 <lambdabot> Prelude.(>>) :: Monad a => a b -> a c -> a c
02:12:32 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
02:12:32 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
02:12:46 <xerox> @hoogle+
02:12:47 <lambdabot> Prelude.(*) :: Num a => a -> a -> a
02:12:47 <lambdabot> Prelude.(/) :: Fractional a => a -> a -> a
02:12:47 <lambdabot> Prelude.(-) :: Num a => a -> a -> a
02:12:50 <xerox> heh
02:13:08 <bargle> ok, looks like it doesn't exist yet
02:13:16 * ski thinks it ignores class constraints currently
02:13:16 <bargle> what would be a good name for it?
02:13:29 <ski> for what ?
02:13:39 <ski> 'Prelude.(>>) :: Monad a => a b -> a c -> a c'  ?
02:14:27 <bargle> no, m a -> m b -> m a defined as foo p q = do {x <- p; q; return x}
02:14:41 <ski> hm, sorry
02:15:22 <ski> maybe call it 'after' and flip argument order ?
02:15:54 * xerox gets a cup of tea
02:16:03 <ski> q `after` p = do {x <- p; q; return x}
02:17:00 <bargle> I think (many1 digit `foo` whitespace) reads better than the `after` variant
02:17:55 <ski> hm, it seems a bit similar to 'finally'
02:18:10 <ski> @type Control.Exception.finally
02:18:12 <lambdabot> forall a b. IO a -> IO b -> IO a
02:19:44 * boegel stretches
02:21:46 * ski ponders how much sense `before` would make
02:23:57 * shapr stretches boegel on the rack!
02:24:23 * adept . o O ( ... rake)
02:25:19 * adept . o O (being non-native-english person + random assotiations often plays trick on you ...)
02:25:45 <shapr> I'm a native english person, but random associations still play tricks on me.
02:26:43 <boegel> shapr: how's life ?
02:27:01 <shapr> Busy, but rewarding.
02:27:05 <shapr> How's your life?
02:27:17 <boegel> shapr: busy, but rewarding :)
02:27:36 * shapr grins
02:27:39 <boegel> I like my life busy, otherwise I get bored
02:29:28 <shapr> hoi mrchebas
02:29:45 <mrchebas> good morning!
02:29:49 <shapr> I wonder why I can't see the patches in my wikiwiki repo.
02:30:03 <shapr> mrchebas: How's code treating you this fine morning?
02:30:41 <mrchebas> not much code writing these days
02:30:48 <mrchebas> I am thinking how to fix some bugs first
02:30:55 <mrchebas> Type inference stuff
02:31:29 * shapr infurs his cat.
02:32:46 <shapr> Hmm, why would darcs.cgi not show the annotations?
02:33:09 <shapr> mrchebas: Type inference is nifty, I've read most of TaPL and enjoyed it.
02:33:19 <xerox> dcoutts: gazpacho crashes opening gtk2hs/demo/simple.glade woops :)
02:33:54 <boegel> xerox: gazpacho ? is that the name for your cairo binding ?
02:34:23 <mrchebas> shapr: yes, it is cool as long as it keeps types sane ;)
02:34:24 <xerox> boegel: nope, it's a GTK GUI builder.
02:34:30 <xerox> http://gazpacho.sicem.biz/
02:34:31 <boegel> xerox: oh, okay :)
02:36:21 <boegel> xerox: looks nice, better than glade2 (I hate all the seperate windows, grr)
02:37:04 <xerox> If only it didn't crash... I'll try making a simple app now.
02:38:13 <dcoutts> xerox, glade is ugly but it does work
02:55:26 <greenrd> Is it possible to do something like this:
02:55:41 <greenrd> instance (Ord a) => PartialOrder a where
02:55:41 <greenrd> 	x `lte` y = x <= y
02:56:00 <greenrd> ghc says: "Illegal instance declaration for `PartialOrder a'
02:56:12 <greenrd> (The instance type must be of form (T a b c)
02:56:12 <greenrd>          where T is not a synonym, and a,b,c are distinct type variables)
02:56:12 <greenrd>     In the instance declaration for `PartialOrder a'
02:56:23 <dcoutts> greenrd, try with -fglasgow-exts
02:56:40 <dcoutts> what ghc says is true for Haskell98
02:57:31 <greenrd> that and -fallow-undecidable-instances seemed to work
02:57:42 <greenrd> Is -fallow-undecidable-instances dangerous in this case?
02:58:10 <blackdog> g'day #haskell
02:58:58 <dcoutts> greenrd, I'm not quite sure, but it proably ok
02:59:16 <shapr> g'day blackdog, ltns
03:00:19 <xerox> There is something obscure in fromJust..
03:00:33 <shapr> This Just In
03:01:01 <ski> (hm .. to safely have this kind of thing, the system would have to check that, for particular values of 'a', there's not simultaneously 'instance Ord a' and 'instance PartialOrder a')
03:01:06 <xerox> I do have |f :: String -> IO (Maybe a)|, why doesn't |foo <- fromJust =<< f "foo"| work?
03:01:12 <blackdog> what an inscrutable acronym. (got it, but it took me a few seconds - I hope you don't apply the same readtime/writetime tradeoffs in your code, shapr. :)
03:01:22 <shapr> blackdog: hah, no
03:01:36 <greenrd> ski: But that's precisely what my definition _creates_!
03:01:48 * dcoutts still hasn't decoded "ltns"
03:01:52 <shapr> long time no se
03:01:53 <shapr> e
03:01:54 <greenrd> heh
03:01:56 * xerox thinks ski talks lisp
03:01:58 <greenrd> @help pl
03:01:58 <lambdabot>  @pointless <expr> - play with pointfree code
03:02:32 <greenrd> @pl and (zipWith lte x y)
03:02:32 <lambdabot> and (zipWith lte x y)
03:02:47 <greenrd> @pl (\lte x y -> and (zipWith lte x y))
03:02:48 <lambdabot> ((and .) .) . zipWith
03:02:53 <greenrd> ?!
03:03:00 <xerox> Theoretically I think I'm right.
03:03:01 <ski> xerox : |foo <- fromJust `liftM` f "foo"| ?
03:03:25 <dcoutts> xerox, because fromJust doesn't return IO (a)
03:03:32 <ski> greenrd : not in itself (re what your def. creates)
03:03:42 <xerox> But practically, ski and duncan are right.
03:03:52 <dcoutts> foo <- liftM fromJust $ f "foo"
03:04:14 <dcoutts> at least that's the way I always write it
03:04:19 <greenrd> ski: er, yes it does. It says "If a is an instance of Ord then it is an instance of PartialOrder", doesn't it?
03:04:40 <greenrd> ski: Also, I don't see how that would be a problem.
03:04:44 <ski> yes, it's a derived instance  (note my "for particular values of 'a'")
03:05:17 <greenrd> ski: I don't understand the significance of "for particular values of a"
03:05:19 <bargle> greenrd: what if someone creates an explicit instance of PartialOrder that conflicts with the Ord-based definition?
03:05:29 <greenrd> ski: If for all a foo then obviously for particular values of a foo holds!
03:05:55 <ski> e.g. say a = Foo,  then you should not have both 'instance Ord Foo' and 'instance PartialOrder Foo', since then the defived instance clashes with the explicit one
03:06:06 <greenrd> ah I see
03:06:19 <greenrd> That doesn't look undecidable to me :)
03:06:52 <ski> no .. i'm wondering whether weaker incantations to ghc would do the job, too
03:07:51 <dcoutts> greenrd, the point is not that they're all undecidable but once you relax the syntax to the degree that -fallow-undecidable-instances does, then there are examples that you can write which are undecidabl
03:08:05 <greenrd> ah ok
03:08:31 <greenrd> @pl (\x y -> and (zipWith <= x y))
03:08:32 <lambdabot> ((and . (zipWith <=)) .)
03:08:42 <xerox> dcoutts: This .glade thing is rather cool.  A simple simple app made with gazpacho works.
03:08:49 <dcoutts> greenrd, because it essentially gives you a powerful logic programming language and that allows you to write non-terminating programs
03:08:51 <dcoutts> xerox, cool
03:09:01 <greenrd> dcoutts: Cool.
03:09:15 <dcoutts> xerox, you're loading it up in your Haskell program?
03:09:36 <greenrd> dcoutts: Is -fallow-undecidable-instances related to dependent types in any way, or are they just two unrelated things that happen to have non-termination issues?
03:09:44 <dcoutts> greenrd, the latter
03:09:47 <greenrd> ok
03:10:05 <dcoutts> greenrd, not everyone would agree that it's cool. We like functional programming, not logic programming! :-)
03:10:10 <greenrd> hehe
03:10:23 <xerox> dcoutts: Yes.
03:10:35 <dcoutts> xerox, nice (screenshots? :-) )
03:10:56 <ski> dcoutts : we like functional programming .. left unsaid whether we like logic programming
03:11:09 <dcoutts> greenrd, people have presentd papers that take this stuff to extreems and their "type programs" are totally incomprehensable.
03:11:17 <greenrd> hehe
03:11:18 <xerox> dcoutts: let me write something cooler before :-D
03:11:21 * ski for one likes LP, too
03:11:32 * poetix likes Oz
03:11:48 <dcoutts> ski, true, but you tend not to mix them, or at least if you do, you do it on purpose
03:12:38 <dcoutts> ski, unlike type classes which just sort of poped up as a language of it's own without it ever being designed as a usable language
03:12:46 <ski> dcoutts : m-m (though Escher,Curry ..) (also, in this case the LP was on type level .. so not same level)
03:13:15 <xerox> ski: ah, I thought "m-m" was a "mumble" "mmh" or something :-D
03:13:18 <greenrd> So I put
03:13:20 <greenrd> {-# OPTIONS -fglasgow-exts #-}
03:13:20 <greenrd> {-# OPTIONS -fallow-undecidable-instances #-}
03:13:25 <greenrd> in my source file
03:13:39 <greenrd> Do I have to put that in all clients that use this module, too?
03:13:46 <ski> xerox : 'twas :) (but an affirming one)
03:13:53 <greenrd> and all clients that use those modules, recursively?
03:13:56 <dcoutts> greenrd, usually yes
03:14:00 <greenrd> ok
03:14:31 <dcoutts> greenrd, at least if they ever use any functions that rely on the undecidable class resolution mechanism
03:14:37 <greenrd> yeah
03:15:21 * poetix considers trying to instigate a lengthy off-topic discussion about sex, drugs, music or some combination of the three
03:15:22 <ski> i.e. if the overloading is still visible at a higher module level
03:16:17 * ski thinks there's some TV program, named Oz, which includes drugs
03:16:26 <dcoutts> ski, yes, that's a better way of putting it
03:16:34 <greenrd> @pl \x y -> and (zipWith <= x y)
03:16:35 <lambdabot> ((and . (zipWith <=)) .)
03:16:53 <ski> @type ((and . (zipWith <=)) .)
03:16:55 <lambdabot> bzzt
03:17:04 <ski> @type \x y -> and (zipWith <= x y)
03:17:05 <lambdabot> bzzt
03:17:08 <greenrd> oh sorry
03:17:10 <ski> @type \x y -> and (zipWith (<=) x y)
03:17:11 <lambdabot> forall b. (Ord b) => [b] -> [b] -> Bool
03:17:15 <greenrd> I am using <= wrong - it's infix isn't it?
03:17:17 <ski> @pl \x y -> and (zipWith (<=) x y)
03:17:18 <lambdabot> (and .) . zipWith (<=)
03:17:44 <greenrd> the brackets make it a normal function?
03:17:50 <ski> yes
03:17:52 <greenrd> ok
03:18:39 <ski> @type let (.:) = (.) . (.) in and .: zipWith (<=)
03:18:40 <lambdabot> forall b. (Ord b) => [b] -> [b] -> Bool
03:19:07 <ski> greenrd : that's for piping two curried args
03:19:37 <greenrd> ski: thanks!
03:19:54 <greenrd> ski: I think my head is going to explode though!
03:20:12 <ski> @pl let f = (.) . (.) in and `f` zipWith (<=)
03:20:13 <lambdabot> (and .) . zipWith (<=)
03:20:40 <bargle> @type flip id
03:20:41 <lambdabot> forall b c. b -> (b -> c) -> c
03:20:47 <ski> greenrd : nice feeling, yes ;)
03:21:24 <mrchebas> ski: cool trick
03:21:40 <ski> @type (.) . (.)
03:21:41 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:21:44 <ski> @type (.) . (.) . (.)
03:21:45 <lambdabot> forall a a1 b c a2.
03:21:45 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
03:21:52 <ski> etc
03:22:50 <bargle> is there a case where $ can't be replaced by `id`?
03:22:51 * boegel does a little dance
03:23:25 * ski can't think of one
03:23:47 <xerox> dcoutts: if I impose a default width and height in the .glade, do I have to enforce it explicitly in the .hs?  Same goes for non-resizeable?
03:23:49 <bargle> so $ isn't really needed
03:23:53 <greenrd> ski: What I'd like to do is write the pipeline in unix-style: (zipWith lte) | and
03:24:14 <xerox> zipWith lte >>> and  ?
03:24:29 <ski> greenrd : (>.>) = flip (.)
03:24:35 <xerox> err no, you need to pass the arguments...
03:24:39 <greenrd> @type >>>
03:24:40 <ski> yep
03:24:40 <lambdabot> bzzt
03:24:59 <ski> @type (Control.Arrow.Arrow.>>>)
03:25:00 <lambdabot> bzzt
03:25:01 <dcoutts> xerox, no I don't think so, the values from the .glade file will apply unless you change them later in your code
03:25:01 <xerox> dcoutts: counter-order, the unresizeability is automagically passed, the dimensions no, tough.
03:25:05 <bargle> @type (>>>)
03:25:06 <lambdabot> bzzt
03:25:25 <ski> @type (Control.Arrow.>>>)
03:25:26 <lambdabot> forall (a :: * -> * -> *) d b c.
03:25:26 <lambdabot> (Control.Arrow.Arrow a) =>
03:25:26 <lambdabot> a b c -> a c d -> a b d
03:27:03 <greenrd> ski: sorry, so which was the right answer?
03:27:31 <greenrd> ski: flip (.) ?
03:27:42 <ski> @type curry (uncurry (zipWith (<=)) Control.Arrow.>>> and)
03:27:44 <lambdabot> forall b. (Ord b) => [b] -> [b] -> Bool
03:27:52 <ski> greenrd : for what ?
03:28:02 <greenrd> how to write unix-style pipelining
03:28:16 <ski> flip (.) does it when you have a single argument to pipe in
03:28:20 <greenrd> ok
03:28:38 <ski> flip (.:) could work if you have two curried in args
03:29:15 <ski> @type let (.:) = (.) . (.); (>.:>) = flip (.:) in zipWith (<=) >.:> and
03:29:16 <lambdabot> forall b. (Ord b) => [b] -> [b] -> Bool
03:30:42 <ski> and if you have tupled arguments and want to provide some of those explicitley, you'd use yet another solution
03:31:49 <ski> (hm, reminds of named arguments ..)
03:32:31 * blackdog sighs deeply
03:32:57 <blackdog> i just spent an hour building a tool which might save me 5 seconds each time i use it. and i'm not done yet. I really gotta learn me some prioritisation.
03:33:41 <ski> how often would you use it ?
03:34:09 <blackdog> each time i run my unit tests. so, eventually, i'd get the time back. it just might take a while.
03:34:21 <shapr> Anything that encourages unit tests is good.
03:34:39 <blackdog> shapr: in that case, wanna help me hack some elisp? :)
03:34:56 <shapr> Maybe, whatcha writin?
03:35:24 <blackdog> it's pretty minor, i just don't know elisp very well. more to the point, i don't know emacs regexps very well, so my attempts to hack compile.el are not going terribly well.
03:35:37 <shapr> What are you doing to compile.el?
03:35:48 <blackdog> gah. incoherent again. I want to make compile.el grok ruby unit tests.
03:35:51 <reppie[^_^]> http://zip.4channel.org/p/res/8330.html
03:36:23 <blackdog> uh, sorry about the low haskell content. if it makes you feel better, i've been razzing the RoR guys about how static typing is like chocolate sauce on icecream.
03:36:28 <shapr> blackdog: Why not use the compile-command hack I use for @wiki HaskellMode ?
03:37:01 <blackdog> I'm using that. The thing is, I want to be able to use 'next-error to go to the failing test.
03:37:33 <shapr> Ohh
03:38:12 <shapr> In that case you only need to hack the test output
03:38:48 <shapr> emacs' error format is relatively standard
03:39:09 <shapr> You can look at C-h k C-x ` for example
03:42:34 <greenrd> reppie[^_^]: lol thanks for that
03:42:41 <reppie[^_^]> greenrd :D
03:43:25 <greenrd> "90% of the available food supply is actually consumed by 400 families of bloated plutocrats."
03:44:06 <greenrd> gives a new meaning to bloated
03:45:56 <reppie[^_^]> i'll have to find that book
03:47:58 * Lor wrote his first emacs mode on sunday.
03:48:36 <greenrd> @pl \x y -> (x <= y) && (x /= y)
03:48:36 <lambdabot> ap (ap . ((&&) .) . (<=)) (/=)
03:48:46 <greenrd> ?!
03:49:05 <greenrd> "How to make your code unreadable - use pointsfree style!"
03:49:54 <Lor> Well, unlambda is not exactly renowned for its clarity...
03:50:15 <greenrd> @type ap
03:50:20 <lambdabot> bzzt
03:50:24 <greenrd> huh?
03:50:34 <bargle> @type Monad.ap
03:50:36 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
03:50:36 <lambdabot> b
03:51:08 <greenrd> Why did @ pl introduce monads into this?
03:51:17 <bargle> because it's insane
03:51:18 <Lor> I don't think that's the ap that it means.
03:51:19 <greenrd> heh
03:51:36 <wilx> What part of the original expression is monad?
03:51:42 <greenrd> none
03:51:51 <greenrd> it's just comparison of Ords
03:52:18 <xerox> It's because you reuse the arguments
03:52:20 <xerox> I think.
03:52:22 <shapr> @type ap (ap . ((&&) .) . (<=)) (/=)
03:52:23 <lambdabot> bzzt
03:52:27 <shapr> @type (ap (ap . ((&&) .) . (<=)) (/=))
03:52:29 <lambdabot> bzzt
03:52:38 <xerox> @type Control.Monad.ap (Control.Monad.ap . ((&&) .) . (<=)) (/=)
03:52:39 <lambdabot> forall a. (Monad ((->) a), Ord a) => a -> a -> Bool
03:52:45 <shapr> Ah, right.
03:52:49 <bargle> @pl \a b x -> (a x) (b x)
03:52:50 <lambdabot> ap
03:52:53 <wilx> Ah.
03:52:54 <xerox> :-)
03:53:13 <Lor> It should have been called s, then everyone would have recognized it. :)
03:53:14 <xerox> So there actually is a Monad part.
03:53:15 <wilx> And they tell me C++ is complex...
03:53:19 <bargle> ok, but how is (->) a an instance of Monad?
03:53:32 <Lor> bargle, it's the reader monad
03:53:33 * xerox calls ski
03:53:45 <Lor> Or "environment monad" as it is also called.
03:53:57 <shapr> wilx: C++ has simple ideas implemented in a complex way. Haskell has complex ideas implemented in a simple way.
03:54:04 <wilx> :)
03:54:32 <xerox> Lor: how is (->) a reader monad?
03:54:45 <Lor> Not (->), but ((->) a), for some a.
03:55:11 <xerox> Mumble.
03:56:38 <Lor> newtype Reader r a = Reader (r -> a)
03:58:05 <Lor> instance Monad (Reader r) where return a = Reader (\_ -> a); Reader g >>= f = Reader (\r -> let (Reader g') = f (g r) in g' r)
03:58:15 <ski> xerox : you called ? :)
03:58:26 <Lor> get :: Reader r r; get = Reader (\r -> r)
03:58:33 <xerox> Yeah :-)
03:59:50 <autrijus> anyone had experience of bootstrapping from .hc files before?
03:59:51 <xerox> I don't understand why ((->) a) is a Reader monad
04:00:01 <liyang> I guess the main obstacle of appreciating (->) is getting over the fact that nothing is sacred. Not even function type constructors. :)
04:00:10 <ski> xerox : do you understand reader/environment monad ?
04:00:16 <xerox> Yes
04:00:45 <ski> 'Reader r a'  is siomorphic to 'r -> a'  so we can use the latter
04:00:59 <xerox> Good so far
04:01:23 <ski> Reader r a  ~=  (Reader r) a
04:01:47 <Lor> Too bad one cannot use sections with infix type constructors. (a ->) would be clearer than ((->) a).
04:01:47 <ski> r -> a  ~=  (->) r a  ~=  ((->) r) a
04:02:03 <ski> Lor : iirc, one can with some extension
04:03:03 <ski> @type length :: ([a] ->) Int
04:03:04 <lambdabot> bzzt
04:03:14 <xerox> Mumble
04:03:15 <ski> hm, possibly not enabled ..
04:03:35 <xerox> So the point is that the argument is the environment in which the computation works.
04:03:58 <ski> xerox : anyway, because 'Reader r a  ~=  r -> a'  then 'Reader r  ~=  (->) r'
04:04:03 <ski> yep
04:04:09 <xerox> It makes perfect sense
04:04:25 <ski> this is how convertion of lambda-expressions to ski-calculus works
04:04:42 <ski> variables are translated to environment
04:05:15 <ski> (s/t/s/)
04:05:23 <xerox> I thought S K I were lambda-calculus things
04:05:46 <Lor> They're combinatory logic things. In lambda calculus we can do without them (thankfully!)
04:06:04 <ski> ski-calculus is a separate calculus, but those combinatos can still be defined in lambda-calc
04:06:16 <bargle> lambda calculus doesn't have predefined functions, while s-k-i doesn't have lambda
04:06:21 <ski> ski-calculus has no variables at all
04:06:49 <ski> bargle : s/lambda/pure lambda/
04:06:54 <shapr> Just two poles and two long thin things you put on your feet.
04:07:05 <Lor> Why is I so often counted in the basic combinators? It's redundant, after all.
04:07:27 <ski> dunno .. tradition ?
04:07:45 <bargle> also http://www.madore.org/~david/programs/unlambda/
04:07:46 <ski> (s and k is also redundant, btw)
04:08:22 <ski> (Lor : i.e. you can get by with just one combinator (and application))
04:09:05 <Lor> You mean iota?
04:09:05 <greenrd> @hoogle [a -> b] -> a -> [b]
04:09:07 <lambdabot> No matches, try a more general search
04:09:59 <greenrd> @pl \f -> f x
04:10:00 <lambdabot> ($ x)
04:10:18 <greenrd> @pl \f -> f x y
04:10:19 <lambdabot> flip ($ x) y
04:10:23 <greenrd> ouch
04:10:28 <ski> Lor : i've seen an X, such that S = X (X X) and K = (X X) X  (or maybe the other way around, can never remember) .. anyway, there are many variants on the idea of a universal combinator
04:10:45 <bargle> @type map (flip id)
04:10:47 <lambdabot> forall a c. [a] -> [(a -> c) -> c]
04:12:08 <Lor> But the _definition_ of those combinators is more complex than S or K (although absolute complexity is of course impossible to measure)
04:12:14 <ski> @type let swing f = flip (f . flip ($)) in  swing map
04:12:15 <lambdabot> forall a b. [a -> b] -> a -> [b]
04:12:34 <ski> greenrd : see http://www.haskell.org/hawiki/LicensedPreludeExts for swing
04:13:08 <bargle> @pl \fs x -> map (\f -> f x) fs
04:13:09 <lambdabot> flip (map . flip id)
04:13:18 <ski> Lor : yes  (hmm kolmogorov complexity ?)
04:14:25 <Lor> kolmogorov complexity isn't meaningful on finite strings.
04:14:41 <ski> hm .. right
04:15:05 <shapr> That sounds like a Zen koan.
04:15:19 <ski> (or rather, you need some paremeterization, no ?)
04:17:43 <shapr> @quote blackdog
04:17:43 <lambdabot>  my variables aren't varying.
04:17:45 <shapr> @quote blackdog
04:17:46 <lambdabot>  my variables aren't varying.
04:17:47 <shapr> @quote blackdog
04:17:48 <lambdabot>  i'm not encouraged by the comment "i don't know haskell, but CL is
04:17:48 <lambdabot> much better", though. it doesn't suggest careful thought and
04:17:48 <lambdabot> objectivity...
04:18:20 <blackdog> shapr: did you miss me?
04:18:25 <shapr> heck yeah :-)
04:18:32 <shapr> Man, you gotta get back into the Haskell world!
04:18:50 <blackdog> also, i gotta make a living.
04:18:55 <shapr> Yeah, I know. Me too.
04:19:20 <blackdog> next project: RoR for haskell. :) acquisition is not the glittering gem i thought it would be.
04:19:36 <vegai> Ruby on Rails for Haskell? :-D
04:19:51 * vegai apologizes for the bad joke.
04:19:51 <blackdog> haskell on handcars, mebbe?
04:19:54 <shapr> rorh! pronounced rawhr!
04:19:56 <vegai> heh, that's better
04:20:19 <shapr> vegai: Hey, did you do anything more on that libsilc binding?
04:20:22 <ski> Rotate Right
04:20:22 * blackdog can't help visualising the big gay lion from South Park when shapr says that...
04:20:34 <shapr> I thought that was Big Gay Al?
04:20:50 <blackdog> yeah, but he had a whole zoo of big gay animals. Remember Sparky, the kid's dog?
04:20:55 <shapr> Yeah
04:20:58 <vegai> shapr: I studied c2hs but then work caught up and it's been dormant
04:20:58 <blackdog> Don't be gay, sparky! Don't be gay!
04:21:17 <xerox> c2hs, what a nice tool.
04:21:21 <shapr> vegai: I'm interested. Silky is cheesy, and I don't want to use a modified irssi.
04:21:34 * xerox points to silc-client
04:21:39 <xerox> Oh, why?
04:21:52 <vegai> it feels patched
04:21:56 <shapr> I want a Haskell binding!
04:21:56 <vegai> you know, with bubblegum
04:22:00 <greenrd> @pl \f -> (\(x,y) -> f x y)
04:22:01 <lambdabot> (`ap` snd) . (. fst)
04:22:01 <xerox> yay
04:22:28 <bargle> isn't that curry?
04:22:28 <ski> @type \f -> (\(x,y) -> f x y)
04:22:34 <lambdabot> forall a b t. (a -> b -> t) -> (a, b) -> t
04:22:38 <ski> @type uncurry
04:22:40 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
04:22:46 <greenrd> cool
04:23:05 <ski> @type curry
04:23:07 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
04:23:14 <bargle> er, yeah
04:31:58 <xerox> dcoutts!
04:32:04 <xerox> Compiling with -O seems to work hehe
04:33:11 <dcoutts> xerox, huh? what difference did -O make?
04:33:22 <xerox> Strange.
04:33:31 <xerox> How it does not work again
04:36:02 <liyang> @type flip $ \a -> map ($ a)
04:36:08 <lambdabot> forall a b. [a -> b] -> a -> [b]
04:36:56 <liyang> @type flip $ map . flip ($)
04:36:57 <lambdabot> forall a b. [a -> b] -> a -> [b]
04:37:25 <ski> (which leads to swing ..)
04:37:42 <liyang> Isn't life pointless.
04:38:00 * ski smiles
04:38:18 <shapr> liyang: It's the lesser of two evals.
04:39:11 <liyang> *groan*
04:39:29 * shapr snickers
04:43:26 * Itkovian yawns
04:43:42 <shapr> @yow !
04:43:43 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU ...
04:43:45 <shapr> @quote
04:43:46 <lambdabot> ghc says: More than one type pattern for a single generic type
04:43:46 <lambdabot> constructor
04:44:29 <Beelsebob> @moo
04:44:41 <Beelsebob> :(
04:44:50 <shapr> Yeah, disable for allegations of spam
04:45:00 <Beelsebob> bah, how is that spam?
04:45:03 * boegel slaps Itkovian
04:45:34 <Beelsebob> shapr: have you defined an ordering over evaluations?
04:45:44 <shapr> huh?
04:45:57 <shapr> Like a monad?
04:46:29 <Beelsebob> "shapr: liyang: It's the lesser of two evals."
04:46:39 <shapr> heh
04:51:44 <liyang> (I'm sure the second flip would cause more reduction steps...)
04:54:57 <Philippa> Beelsebob: your mail client screws up the quoting, I can't figure out who said what in your mailing list post just now
04:55:50 <Philippa> also, you don't necessarily break laziness at all
04:58:10 <shapr> Hm, is Arthur Baars here?
04:58:14 <Philippa> (not doing so is one of the cool bits about the List monad)
05:01:39 <Beelsebob> philippa: my mail client works fine... mail clients that expect hard wrapping break quoting when they recieve ;)
05:02:03 <Beelsebob> and okay... for the most part, you break lazyness
05:02:33 <Beelsebob> certainly in the examples given there, introducing monads was specifically designed to break it
05:02:53 <Beelsebob> I was merely warning against doing it spuriously and breaking it when you don't want to
05:03:16 <greenrd> @hoogle [[a]] -> [a]
05:03:18 <lambdabot> Prelude.concat :: [[a]] -> [a]
05:03:18 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
05:03:18 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
05:03:34 <bargle> @type concat
05:03:40 <lambdabot> forall a. [[a]] -> [a]
05:03:53 <Beelsebob>  :: [[a]] -> [a] ??
05:04:03 <Philippa> Beelsebob: there are *no* quote marks in your mail
05:04:05 <Philippa> none
05:04:15 <Beelsebob> philippa: ???????
05:04:16 <Beelsebob> I got them
05:04:27 <Beelsebob> I've seen people with other clients get them
05:04:41 <Philippa> oh shit, it's all in HTML
05:04:43 <Philippa> that'll be why
05:05:09 <greenrd> @hoogle findMin
05:05:12 <Philippa> really, /don't/ use HTML for email...
05:05:14 <Beelsebob> wtf
05:05:21 <Beelsebob> I told it not to...
05:05:29 * Beelsebob goes to check the prefs
05:05:55 <Philippa> there appears to be both
05:06:00 <bargle> @hoogle [a] -> a
05:06:01 <lambdabot> Prelude.product :: Num a => [a] -> a
05:06:01 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
05:06:01 <lambdabot> Prelude.last :: [a] -> a
05:06:05 <Philippa> my client's trying to show the HTML bit and misrendering it
05:06:10 <Philippa> so both of us have sucky clients :-)
05:06:23 <Beelsebob> possibly... I just changed my prefs
05:06:32 <Beelsebob> to plain text only you evil fuck
05:06:41 <Beelsebob> :)
05:06:45 <boegel> @eval product [1,2,3,4,5]
05:06:47 <lambdabot> 120
05:06:51 <boegel> neat :)
05:07:04 <boegel> @eval sum [1,2,3,4,5]
05:07:06 <lambdabot> 15
05:07:13 <Beelsebob> boegel?
05:07:17 <Beelsebob> what's neat?
05:07:20 <bargle> @eval product [1 .. 100]
05:07:22 <lambdabot> 9332621544394415268169923885626670049071596826438162146859296389521759
05:07:22 <lambdabot> 9993229915608941463976156518286253697920827223758251185210916864000000
05:07:22 <lambdabot> 000000000000000000
05:07:25 <boegel> now there's a short implementation of Fibonacci numbers
05:07:28 <boegel> wow, fast
05:07:37 <Beelsebob> where is?
05:07:37 <ski> fibonacci ?
05:07:51 <boegel> fibonacci n = sum [1 .. n]
05:07:54 <boegel> :p
05:07:58 <Beelsebob> um... no?
05:07:58 <ski> boegel : itym factorial ?
05:08:03 <ski> hm
05:08:05 <greenrd> @pl \x y -> compare (length x) (length y)
05:08:06 <lambdabot> (. length) . compare . length
05:08:06 <bargle> also factorial is product
05:08:11 <ski> yes
05:08:16 <boegel> then what am I thinking of :|
05:08:26 * ski calls them triangular numbers
05:08:47 <bargle> let fibs = 1 : 1 : zibWith (+) fibs (tail fibs)?
05:08:51 <boegel> I was confusing factorial with triangular numbers, so nvm :)
05:08:56 <ski> @eval map (\n -> sum [0 .. n]) [0..9]
05:08:58 <lambdabot> [0,1,3,6,10,15,21,28,36,45]
05:09:00 <Beelsebob> @eval let fibs x y = x:(fibs y (x+y)) in take 15 $ fibs 1 1
05:09:02 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
05:09:21 <bargle> @eval let fibs = 1 : 1 : zibWith (+) fibs (tail fibs) in take 15 fibs
05:09:22 <lambdabot> 37: Not in scope: `zibWith'
05:09:29 <bargle> @eval let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 15 fibs
05:09:31 <boegel> bargle :)
05:09:31 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
05:14:38 <ski> @eval let phi = (sqrt 5 + 1) / 2; phi' = 1 - phi; fib n = (phi ^ n - phi' ^ n) / (phi - phi') in map fib [0..15]
05:14:42 <lambdabot> [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999,89.0,
05:14:42 <lambdabot> 143.99999999999997,232.99999999999994,377.00000000000006,610.0]
05:18:02 <bargle> @eval let phi = 0.5 + sqrt 1.25; fib n = if n < 2 then n else round $ fromInteger (fib (pred n)) * phi in map fib [0..15]
05:18:05 <lambdabot> [0,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
05:18:24 <Beelsebob> something's missed out 1
05:18:54 <bargle> good enough
05:20:28 <Itkovian> 137, 153, 163, 127 and then?
05:20:29 <boegel> does anyone know what number is next is this sequence: 137, 153, 163, 127
05:20:34 <boegel> lol :)
05:20:38 <boegel> great timing
05:21:06 <ski> boegel : i could write a program that invents a polynom for that ..
05:21:10 <Itkovian> lol
05:21:24 <Beelsebob> 117
05:21:28 <boegel> ski: you did ? for this sequence ?
05:21:31 <Beelsebob> and prove me wrong *g*
05:21:34 <Itkovian> lol
05:21:37 <boegel> Beelsebob: why 117 and not 143 ? :)
05:21:43 <bargle> 147 111 90 121 90 ...
05:21:51 <ski> boegel : for every such sequence (and no i haven't .. yet :)
05:22:04 <Beelsebob> boegel: because I said so
05:22:08 <Beelsebob> it's my sequence now :)
05:22:09 <bargle> see http://corona.gi.alaska.edu/AFARS/ruby/2004/rb04_05211925_2130.1min
05:22:10 <boegel> bargle: explain ?
05:22:43 <ski> boegel : of course, there are infinitely many different polynoms that are acceptable, and you might think of another than the program thought of
05:23:20 <boegel> http://mathforum.org/kb/thread.jspa?threadID=1202428&tstart=0 omg :)
05:24:22 <boegel> 189 is the answer
05:24:33 <bargle> my answer is better
05:24:41 <Beelsebob> no, mine is!
05:24:54 <boegel> positions 1,3 is increasing by 26, positions 2, 4 are decreasing by 26
05:25:05 <boegel> so pos 5 = 163 + 26 = 189
05:25:09 <bargle> But only if 7 is 8.
05:25:22 <boegel> bargle: yeah, that's because someone said 179 :)
05:26:28 <boegel> The answer is obvious: Take the atomic weight (weighed by frequency of
05:26:28 <boegel> isotopes) of the elements which are solid at room temperature, sort the
05:26:28 <boegel> list by the hundred digit, tie-broken by the thousandth digit, and take
05:26:28 <boegel> the 8th, 9th, and 10th decimal places of the 5th number to get the next
05:26:28 <boegel> number in the sequence.
05:26:38 <Itkovian> imo, any number does the trick, but you would score very low at IQ tests if you fill in a random number
05:27:55 * ski thinks such IQ questions are silly
05:28:16 <ski> i mean, i could prove that my answer is correct
05:28:21 <Beelsebob> ditto
05:28:51 <boegel> now _this_ is an answer: http://mathforum.org/kb/message.jspa?messageID=3908026&tstart=0 :p
05:28:57 <Itkovian> ski: yes, but the people checking the answer won't understand jack shit of your explanation.
05:29:25 <sieni> Fibonacci numbers are pretty easy to compute rapidly, if you note that if you let A_n be the matrix {{f_{n+1},f_{n}},{f_{n},f_{n-1}}, then A_n * A_m = A_{n+m}
05:29:51 <ski> Itkovian : not even a simple polynomial filled in with value for variable, and then simple arithmetic ?
05:30:55 <Itkovian> come on those people have studied psychology, and I really need not tell you about the math skills of 1st year psychology, eh.
05:31:32 <Itkovian> 1 2 3 4 h v h v ?
05:31:38 <Itkovian> (an actual question)
05:31:50 <Itkovian> and unless you speak dutch you will never find it
05:32:00 <Itkovian> soooo stupid
05:32:03 <Beelsebob> alright... what's next in this sequence? 1 2 3 4 5 6 7 ...
05:32:09 <Itkovian> 0
05:32:13 <ski> Itkovian : /me agrees
05:32:13 <Beelsebob> correct!
05:32:20 <Itkovian> it's modulo 8 eh
05:32:45 <Beelsebob> no, it's an arbitrary sequence of numbers with no pattern at all
05:32:51 <Itkovian> btw mine was a'p'
05:33:04 <Itkovian> '1 2 3 4 hoedje van hoedje van papier'
05:33:06 <Itkovian> duh.
05:33:17 <Itkovian> I spent an hour trying to figure it out
05:33:30 <Beelsebob> 13 1 13 10 10 1 ...
05:33:52 <Itkovian> 0
05:33:55 <Beelsebob> no
05:34:00 <Itkovian> oh yes
05:34:03 <Beelsebob> heh
05:34:11 <Itkovian> i dare you proveme wrong
05:34:34 <Beelsebob> there is a sequence in my head for this one... and the chalenge is to be psychic :)
05:36:58 <Itkovian> 10 then
05:37:04 <Beelsebob> no
05:37:29 <boegel> 13 !
05:37:33 <Beelsebob> no!
05:37:38 <boegel> 1? :p
05:37:43 <Beelsebob> no? :P
05:38:10 * boegel wishes he never asked his question and just tried google first
05:38:16 <Beelsebob> hehe
05:38:24 <Beelsebob> next one's 19
05:39:07 <Beelsebob> ... 15 14 4 10 6
05:39:19 <blackdog> Are they all less than 26?
05:39:25 <Beelsebob> they are *g*
05:39:33 <Beelsebob> well figured black dog
05:39:45 <Beelsebob> that one always makes you groan
05:40:19 <blackdog> Random low numbers, in a fairly mathematical channel - of course it had to be something annoying like that. :)
05:40:31 <Beelsebob> :)
05:41:51 * boegel tried to subtitute the numbers by letters, but didn't get what followed on 'mamjja'
05:42:01 <Beelsebob> hehe
05:42:21 <Beelsebob> s does
05:50:39 <greenrd> @pl let (|<<|) = (.) . (.) in \f g -> (uncurry f) |<<| g
05:50:39 <lambdabot> (line 1, column 5):
05:50:39 <lambdabot> unexpected "("
05:50:39 <lambdabot> expecting natural, identifier or "in"
05:51:10 <ski> @type let (|<<|) = (.) . (.) in \f g -> (uncurry f) |<<| g
05:51:15 <lambdabot> forall a b c a1 a2.
05:51:15 <lambdabot> (a -> b -> c) -> (a1 -> a2 -> (a, b)) -> a1 -> a2 -> c
05:51:35 <ski> greenrd : @pl doesn't get syntax fully, i think
05:51:47 <Beelsebob> I think 0_o would have been a better symbol
05:52:24 <greenrd> ski: But I thought you defined an operator in a @pl command above
05:52:37 <ski> i did
05:53:01 <ski> @pl let f = (.) . (.) in and `f` zipWith (<=)
05:53:02 <lambdabot> (and .) . zipWith (<=)
05:53:25 <ski> greenrd : i used `f` because i noticed @pl didn't like my .:
05:53:35 <greenrd> @pl let f = (.) . (.) in \f g -> (uncurry f) `f` g
05:53:36 <lambdabot> const (join (ap id uncurry))
05:53:44 <ski> nono
05:53:49 <greenrd> woops
05:53:55 <ski> :)
05:54:01 <greenrd> @pl let f = (.) . (.) in \g h -> (uncurry g) `f` h
05:54:02 <lambdabot> (.) . (.) . uncurry
05:54:12 <greenrd> aha :)
05:54:16 <boegel> (.) looks like someone naked
05:54:20 <boegel> from behind
05:54:27 <boegel> with a lot of imagination
05:54:30 <greenrd> heh
05:55:17 <Itkovian> omg
05:57:13 <greenrd> points-free style can be made kind of like english
05:57:28 <greenrd> for example: shortest = minimumBy (compare |^<<| (length `ofBoth`))
05:57:36 <greenrd> to find the shortest list in a list of lists
05:57:52 <greenrd> OK |^<<| looks a little inscrutable, granted
05:57:56 <greenrd> I just read it as "the"
05:58:28 <greenrd> (|^<<|) = (|<<|) . uncurry
05:58:33 <greenrd> (|<<|) = (.) . (.)
05:58:50 <greenrd> and ofBoth f x y = (f x, f y)
05:59:42 <greenrd> I haven't tested that, but it typechecks :)
06:00:31 <ski> "Beware of bugs in following code, I've only proven it correct, not tested it !"
06:01:09 <ski> (said by someone i don't remember who)
06:01:25 <bargle> Knuth?
06:01:44 <xerox> Yep
06:02:17 <ski> (right ..)
06:02:31 <kate`> i love the way he uses his face as bullet points
06:03:17 <ski> ?
06:03:34 <kate`> on his website
06:04:11 <boegel> url?
06:04:20 <xerox> @google knuth
06:04:22 <lambdabot> http://www-cs-faculty.stanford.edu/~knuth/
06:04:25 <Itkovian> darcs seems to hang when pulling the recent hsp patches
06:05:34 <kate`> see ~knuth/experiments.html for example
06:06:09 <Itkovian> i don't particularily like knuth, he seems a bit very arrogant.
06:06:25 <Itkovian> maybe i'm wrong, but that is the impression he gives me when I read stuff on his wsebsiter
06:06:25 <kate`> he's as far from arrogant as you can get
06:06:44 <Itkovian> welkl, then he should rephrase the words on his webpages
06:07:10 <boegel> Itkovian: also, his picture doesn't help :)
06:07:14 <greenrd> well, he is like a CS god
06:07:17 <Itkovian> nope
06:07:20 <kate`> can you give an example?
06:07:34 <xerox> TAoCP?
06:07:40 <Itkovian> he may be a CS god ... I don't care.
06:07:42 <ski> tex
06:07:54 <boegel> Itkovian is a CS god too, at least around here
06:07:58 * boegel snickers
06:08:07 <Itkovian> nope
06:08:26 * Muad_Dibber doesnt believe in god . :)
06:08:35 <kate`> well, i believe in knuth
06:08:38 <kate`> and he believes in god
06:08:39 <greenrd> heh
06:08:43 <kate`> so that's close enough
06:08:47 <greenrd> belief is not transitive, though.
06:08:53 <kate`> fallacy!
06:08:54 <greenrd> As that example clearly shows.
06:09:07 <Itkovian> kate`: well, it's not any particular thing, it's just an overal feel
06:09:18 <ski> Muad_Dibber : not even in Shai-Hulud ?
06:09:34 <Itkovian> Muad_Dibber: atheist problem nr1: nobody to call out to during sex.
06:10:05 <boegel> Itkovian: heh
06:10:08 <Muad_Dibber> hehe
06:10:14 <Muad_Dibber> s/oh god/oh <girl name here>/
06:10:24 <boegel> Itkovian: what about "YEAH THERE WE GO BABYYYYYYYYYY"
06:10:33 <Muad_Dibber> just double check its the right name :P
06:10:36 <Itkovian> Muad_Dibber: that may be good if you can recall her name :-)
06:10:41 <ski> "Oh Susanna .."
06:10:50 <kate`> "oh brother"?
06:10:53 <boegel> "My name is Veronica, you jerk"
06:11:00 <Muad_Dibber> *slaps ski. I'm not susanna! I'm ...
06:11:01 <Muad_Dibber> :)
06:11:20 <Itkovian> otoh: super sex tip nr1: 'your sister liked that too yesterday' and then hang on for yr life
06:12:25 <boegel> Itkovian: I'm not sure that'll guarantee super sex
06:12:26 <ski> http://www.niehs.nih.gov/kids/lyrics/suzanna.htm
06:12:48 <Itkovian> boegel: for as long as you can stay on top it will, or so I'm told.
06:13:56 <boegel> Itkovian: heh, including a scratched back and a knee in the groin ?
06:14:00 <Muad_Dibber> hmm Itkovian, my gf only has a bro, so i'm not going to try it :P
06:14:14 <Itkovian> boegel: the key is keeping that groin where it should be
06:14:24 <Itkovian> or do you hump dog-style?
06:14:25 <Itkovian> lol
06:14:42 <Itkovian> Muad_Dibber: hm, it may even heighten the effect. lol.
06:15:11 <boegel> Itkovian: :D
06:15:40 <boegel> Itkovian: no comment on the dog-style humping though :p
06:16:34 <Muad_Dibber> Itkovian: i'm perfectly happy now ;)
06:16:38 <Itkovian> lol
06:16:43 <Muad_Dibber> besides, her bro aint that good looking :P
06:16:48 <Itkovian> haha
06:16:56 <boegel> Muad_Dibber: even if he was...
06:17:15 <Itkovian> yeah, a 'close yr eyes and take the plunge' won't do you no good either
06:19:24 <Itkovian> yes! the kernel module works!
06:19:40 * boegel cheers but isn't sure what about
06:25:32 <dblhelix> just one more time... (I'm sorry)
06:27:45 <KiMoS> hi, how do you solve this without haskell   let twice f = f . f in twice twice (*2) 2
06:28:00 <KiMoS> i know its 32  but could someone plz explain how
06:28:46 <yaarg> do your homework :P
06:28:47 <boegel> dblhelix: beware or you'll get kicked (yeah right)
06:28:55 <xerox> @plugs let twice f = f . f in twice twice (*2) 2
06:29:13 <KiMoS> yaarg its not a homework tommorow i got an exame and i need to know it
06:29:17 <dblhelix> boegel: I'm sorry, I'm playing around with my new laptop ;)
06:29:24 <lambdabot> 32
06:29:26 <boegel> dblhelix: just joking
06:29:34 <dblhelix> boegel: I know :)
06:29:35 <xerox> KiMoS: cool, let me think
06:29:40 <boegel> KiMoS, just do the substitution yourself
06:30:02 <KiMoS> what does the  f . f  mean
06:30:14 <boegel> twice (twice (*2) 2 = (twice (*2) 2) . (twice (*2) 2)
06:30:18 <xerox> KiMoS: (f . g) x = f (g x)
06:30:19 <ski> (f . g) x = f (g x)
06:30:23 <boegel> . = compostion
06:30:30 <xerox> xerox 1, ski 0 !
06:30:46 <ski> @karma+ xerox
06:30:47 <lambdabot> xerox's karma raised to 8.
06:30:51 <xerox> Yay, sorry :-D
06:31:05 <boegel> twice ((*2) 2) = ((*2) 2) . ((*2) 2)
06:31:14 <xerox> I should gave you a karma point for every little thing you explained to me, so.
06:31:14 <xerox> :-D
06:31:18 <boegel> and now I'm not sure
06:31:22 <boegel> @plugs (*2) 2
06:31:26 <lambdabot> 4
06:31:39 <boegel> 4 . 4 :|
06:31:45 <ski> @type ((*2) 2) . ((*2) 2)
06:31:49 <lambdabot> forall b c a. (Num (b -> c), Num (a -> b)) => a -> c
06:31:56 <ski> *grin*
06:31:59 <Itkovian> http://pluto.jhuapl.edu/ecard/scripts/addSignaturesForm.php
06:32:10 <Itkovian> for lack of other useful data to send I guess
06:33:32 <boegel> Itkovian: I'm gonna be on Pluto soon
06:33:38 <boegel> atleast, my name will be :p
06:33:51 <Itkovian> so shall I
06:34:51 <ski> "Join the first mission to the last planet" ?
06:35:09 <Itkovian> your name
06:35:11 * ski wonders .. Sedna, etc, then ?
06:36:12 <boegel> ski: eh, it's a nice catch phrase
06:36:47 <ski> (though some are considering not counting Pluto either, any more)
06:37:09 * ski thinks Luna is a (secondary) planet
06:38:00 <dblhelix> ski: a secondary planet == a moon?
06:38:33 <ski> secondary planet = planet which revolves around a primary planet
06:38:53 <dblhelix> ski: but isn't that the def. of a moon?
06:39:25 <ski> yep, except with this terminology, moon is just shorthand for non-primary planet
06:39:45 <dblhelix> ah, okay
06:40:20 <dblhelix> so every sec. planet is a moon, but not every moon is a sec. planet?
06:40:38 <ski> moons can have moons, too
06:40:49 * boegel sings along with Epic - Faith no More
06:40:56 <liyang> ski: example? o.O
06:41:18 <dblhelix> ski: yes but a moon of moon that is a n-ary planet then is a (n+1)-ary planet
06:41:33 <ski> liyang : i can't recall now (i'm not really that much into astronomy :)
06:41:56 <ski> dblhelix : m
06:41:57 <boegel> dblhelix: so astronomy is all about polynoms? :)
06:42:29 <dblhelix> boegel: I don't know really? just try to capture what ski is saying
06:42:45 <liyang> (`moon` is merely a binary relationship.)
06:43:31 <ski> (or a role of one of the arguments of that relationship)
06:47:08 <tuomov> moon is a programming language
06:47:50 <Itkovian> what isn't
06:51:28 <boegel> C ? :)
06:52:20 <Lucinda> hello
06:52:40 <Lucinda> I was wondering if anyone could tell me what "tail-recursion" was
06:52:58 <boegel> hey Lucinda
06:53:06 <Lucinda> hello
06:53:11 <Itkovian> Lucinda: tail-recursion occurs when the recursive call is in fact the last action taking place on the data, or some such
06:53:26 <Lucinda> could you give me an example?
06:53:33 <Itkovian> you might envision it as when the recursive call is the final statement in the function
06:53:50 <boegel> f (x:xs) = (x + 1) : (f xs) -> tail recursion
06:54:08 <boegel> I think :)
06:54:14 <Itkovian> I'd agree
06:54:43 <boegel> the thing is, it'll try to compute the value of the first things first, and only when the rest is needed it'll check those too
06:54:59 <boegel> take 5 $ map (\x -> x + 1) [1..100]
06:55:01 * ski think's not
06:55:03 <Lucinda> sorry Im not sure I quite follow
06:55:30 <boegel> ski: then correct me :) I'm not good at explaining these things
06:55:31 <xerox> No
06:55:37 * tuomov thinks not
06:55:38 <xerox> It's consing
06:55:38 * boegel blushes
06:55:46 <ski> Lucinda : have you programmed in any other programming language ?   (C? Java? SML? Scheme? Lisp?)
06:55:51 <Lucinda> yeah C
06:55:55 <Lucinda> or java
06:56:24 <ski> boegel : tail-recursion is easier in a strict language .. laziness complicates things
06:56:41 <Itkovian> well, i e.g. C it would be f(){ blah; bluh; f(); }
06:56:53 <Lucinda> ah!
06:56:55 <tuomov> 'return f(x+1)' in the function f is tail recusion (in C), but 'return 1+f(x)' is not
06:57:07 <Lucinda> so the last thing to be evaluated would be a recursive call?
06:57:12 <Itkovian> yes
06:57:15 <ski> to the same function
06:57:18 <Lucinda> right
06:57:28 <Lucinda> I see, thanks. that wakes perfect sense
06:57:37 <Lucinda> fac (n+1) = (n+1) * fac n
06:57:41 <Itkovian> glad yr sense has been awakened
06:57:43 <xerox> recursive:
06:57:43 <xerox> f [] = 0
06:57:43 <xerox> f (x:xs) = 1 + f xs
06:57:43 <xerox> tail-recursive:
06:57:46 <xerox> f xs = g 0 xs
06:57:48 <boegel> well yeah, I explained it wrong *again*
06:57:49 <xerox>   where g n [] = n
06:57:54 <xerox>         g n (x:xs) = g (n+1) xs
06:57:58 <xerox> (in either case it's just 'lenght')
06:58:39 <tuomov> continuation passing style can be used to make things tail-recursive, I think
06:58:43 <Lucinda> why isnt the first definition of f tail recursive?
06:59:01 <tuomov> because (1+) needs to be evaluted with the value f after evaluation f
06:59:01 <Itkovian> because it would evaluate the 1+ (...) after the f, I think
06:59:05 <Lucinda> ah
06:59:08 <xerox> Lucinda: because (+) is the function that needs one argument to be kept
06:59:14 <ski> tuomov : indeed (at expense of allocating "stack" on heap)
06:59:25 <Lucinda> so....
06:59:40 <Lucinda> fac' acc 0 = acc
06:59:40 <Lucinda> fac' acc (n+1) = fac' (acc * (n+1)) n
06:59:46 <Lucinda> fac n = fac' 1 n
06:59:52 <Lucinda> is tail recursive
06:59:55 <ski> yep
06:59:57 <Lucinda> cool
06:59:58 <xerox> Yes.
07:00:02 <Lucinda> cheers for your help
07:00:10 <Lucinda> but what about lazyness?
07:00:18 <ski> (Lucinda : also it's an example of accumulator-style)
07:00:28 <Lucinda> it means the same thing?
07:00:33 <ski> no
07:00:38 <xerox> @let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 10 fib
07:00:39 <lambdabot> Unknown command, try @listcommands.
07:00:42 <xerox> @plugs let fib = 1 : 1 : zipWith (+) fib (tail fib) in take 10 fib
07:00:50 <xerox> zZzZ
07:01:11 <Itkovian> [1,1,2,3,5,8,13,21,34,55]
07:01:13 <Itkovian> ;-)
07:01:14 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
07:01:16 <xerox> ^_^
07:01:31 <xerox> This is an example of usage of Haskell's lazyness
07:01:52 <ski> Lucinda : accumulator-stlye is when you have an argument (such as 'acc' there) which you pass on to recursive calls (possibly modified in some way)
07:02:11 <Lucinda> ok
07:02:13 <ski> @eval [0..]
07:02:18 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
07:02:18 <lambdabot> 26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
07:02:18 <lambdabot> 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,
07:02:18 <lambdabot> 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,
07:02:18 <lambdabot> 95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
07:02:20 <lambdabot> 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,
07:02:22 <lambdabot> 130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,
07:02:24 <lambdabot> [24 @more lines]
07:02:33 <ski> that's another example of haskell's laziness
07:02:46 <Lucinda> I think I understand lazyness
07:02:54 <ski> @eval let f _ = 42 in f (error "stopped")
07:02:55 <Itkovian> are you sure?
07:02:58 <lambdabot> 42
07:02:58 <Lucinda> no
07:02:59 <Lucinda> lol
07:03:13 <ski> Lucinda : that was yet another
07:03:31 <Itkovian> I think I grasp the easy lazy stuff, but when things are more complicated I find it difficult to reason about
07:03:32 <xerox> coolest
07:03:44 <Lucinda> so lazyness is haskell only attempts to evaluate something when it NEEDS it?
07:03:49 <Itkovian> yes.
07:03:50 <ski> indeed
07:03:56 <Lucinda> makes sense
07:03:57 <xerox> Exactly
07:04:06 <Itkovian> but 'needs' may be complicated to determine at sight
07:04:10 <Itkovian> I think
07:04:20 <ski> (yep)
07:04:28 <Lucinda> well i mean, it wont evaluate a term, unless it needs that term to evaluate some expression
07:04:29 <Philippa> first time something tries to pattern-match on a value or do IO with it, essentially
07:04:53 <Philippa> right. And the only times you ever /need/ something evaluated are when you either pattern-match or do IO with them
07:04:55 <Itkovian> Philippa: yes, but it may be hidden in a giant heap of code that is called before
07:05:05 <Philippa> sure
07:05:20 <Philippa> nevertheless, if you want a rule that'll let you work out how that giant heap works, this is it
07:05:40 <Lucinda> the reason I was asking about tail recursion, was because I am trying to implement a refactoring to convert a recursive call into a tail-recursive call
07:06:16 <Philippa> ah. IIRC the Haskell 98 report doesn't specify anything about tail call optimisations - it's possible for an implementation to not bother
07:06:46 <Philippa> tail calls can work pretty nicely with laziness anyway though, eg when you're building a list a cell at a time
07:06:59 <Lucinda> its going to a be a refactoring as part of HaRe: the Haskell Refactorer
07:07:11 * Philippa nods
07:07:16 <Philippa> good refactoring to have available
07:07:20 <ski> Philippa : but that isn't tail calling, right ?
07:07:30 <Philippa> ski: probably not, come to think of it
07:07:41 <Philippa> (cons in front)
07:07:44 <Lor> I don't think there's any purely generic way to convert non-tail-calls into tail-calls, except CPS.
07:07:49 <Philippa> same kind of pattern though
07:07:51 <Lucinda> sorry guys you must think im really ignorant, but what is an invariant?
07:07:55 <ski> "tail call modulo cons"
07:07:58 <Philippa> something that stays the same
07:08:14 <Philippa> yup. "tail call modulo constructors" is generally a useful pattern in lazy langs
07:08:20 <ski> (there's some paper about that)
07:08:27 <Philippa> heh, figures
07:08:28 <ski> Philippa : in strict langs, too
07:08:44 <Philippa> true, but it doesn't have quite the same space properties there
07:08:51 <ski> e.g. Mercury
07:09:01 <Philippa> it seems to be inevitable though - if it's a neat trick and it's been discussed in here, /somebody's/ written a paper :-)
07:09:47 <ski> Philippa : right .. but you can still create structures top-down instead of bottom-up .. which might save stack, at times
07:10:29 <Itkovian> Lucinda: an invariant is a condition that is the same before and after some cimputation, but not necessarily during the computation
07:11:22 <ski> the condition should stay true whenver you can inspect it .. think of multi-threading
07:11:45 <ski> (so if not true inbetween, one should use locks)
07:13:03 <Lucinda> its a condition that always stays true?
07:13:28 <ski> at least in the extent it's an invariant over
07:14:04 <ski> e.g. "after this is done, this invariant holds until we finally do this"
07:16:21 <poetix> I ignored my own advice and tried to use my Python monadic parser combinators to do some serious work today.
07:16:32 <poetix> It did not go well.
07:16:36 <beelsebob_> evening all
07:16:43 <Philippa> oops. What was the problem, beyond python sucking?
07:16:50 <beelsebob_> chris, stop scaring the real women
07:16:53 <poetix> You really need lazy evaluation.
07:17:21 <Itkovian> ski: well, you could have an invariant over a while loop, where the condition holds before and after each iteration, but not during.
07:17:25 <Philippa> beelsebob_: 'sno problem. A couple of years on the right pills and so forth...
07:17:49 <Lucinda> that kinda makes sense, you only want it to be true when you inspect it?
07:17:54 <beelsebob_> heh, I really don't think I want to see that
07:17:58 <beelsebob_> not with chris
07:18:06 <Itkovian> well, you only inspect it when you'd know it holds, eh.
07:18:20 <ski> (Itkovian : sure .. i think this is consistent with what i said)
07:18:38 <beelsebob_> chris: precicely... to hold true when you inspect it I think you need quite a complex opperation\
07:18:39 <Itkovian> ski: yes, but at first it seemed not
07:19:33 <ski> (Itkovian : i was just trying to complicate it a little by considering invariants in the presence of multi-threading :)
07:20:38 <Itkovian> ok
07:21:09 <ski> Lucinda : rather .. if/when you inspect it, it ought to be true   ..  but one can still apply the "as-if" rule   (and internal implementation doesn't count as inspecting in this sense)
07:21:10 <beelsebob_> @soon shapr
07:21:11 <lambdabot> Maybe you meant: join moo seen
07:21:20 <beelsebob_> @seen shapr
07:21:21 <lambdabot> I saw shapr leaving #haskell 2 hours, 19 minutes and 28 seconds ago.
07:21:28 <Philippa> Lucinda: typically you only want it to be true eg at the start and end of a loop, or some other operation. Some operations're 'atomic' so there's no middle for them to be not-true in, others aren't but you might want to eg present an interface that acts that way (a lot of data structures are kept abstract and only expose operations that maintain a set of invariants, for example)
07:21:30 <beelsebob_> @botsnack
07:21:31 <lambdabot> :)
07:21:42 <ski> Lucinda : there is no problem with it being true even when you don't inspect it
07:21:48 <Itkovian> Philippa: well said
07:22:22 <roconnor> What are the odds that we can have a square function added to the Num class?
07:22:48 <beelsebob_> roconnor: why not just define it?
07:22:56 <Itkovian> why would that be necessary?
07:22:59 <ski> roconnor : you want to provide specialized impl ?
07:23:23 <roconnor> so that (^) can be defined in terms of square
07:23:31 <ndm> you can derive Num a => NumSquare a
07:23:39 <roconnor> because Rational can implement square faster than x*x
07:23:56 <roconnor> because working mod p can implement square faster than x*x
07:23:58 <ndm> you can just pattern match so x ^ 2 does fast one
07:24:03 <beelsebob_> roconnor: what's wrong with square :: Num a => a -> a; square x = x*x?
07:24:09 <ndm> and x ^ n does the normal one
07:24:25 <roconnor> In the case of rational x*x runs gcd
07:24:34 <roconnor> but the gcd will always be 1
07:24:50 <roconnor> this make x^n slower for rational n.
07:25:08 <roconnor> I think similar things hold in other instances of num.
07:25:40 <roconnor> I expect even Integer can compute squares faster than x*x
07:26:32 <roconnor> well, not sure about that last one.
07:26:48 <olliej> if it's using gmp, it should do
07:27:06 <roconnor> ndm: (^) is in the prelude, so I cannot (more or less) redefine it.
07:27:32 <ndm> roconnor, if you are saying you can get all functions to go faster, you acn submit a patch
07:27:40 <ndm> and that way _everyone_ can have fast code
07:27:43 <roconnor> a patch to the language?
07:27:59 <ndm> ^ is in the prelude, but its implemented in haskell
07:28:08 <ndm> a patch to GHC, or whatever compiler you are using
07:28:35 <roconnor> The problem is that I, sort of, want to redefine (^) for Rational.
07:28:39 <roconnor> but I cannot do that.
07:29:08 <roconnor> The ideal change seems to be adding a sqr method to the Num class.
07:29:18 <roconnor> then (^) can call that sqaure function.
07:29:36 <roconnor> and Rational can override the default implmention of square.
07:30:27 <roconnor> Maybe I should make a comment on the Wiki
07:31:52 <Lemmih> {-# RULES "rational/fastsqr1" forall x. x*x = fastRationalSqr x; "rational/fastsqr2" forall x. x^2 = fastRationalSqr x #-}
07:32:10 <roconnor> oh my
07:32:20 <ndm> you can redefine ^ for rational
07:32:27 <ndm> a lot easier than adding sqr
07:32:31 <ndm> just edit the prelude
07:32:36 <roconnor> yes easier,
07:32:44 <roconnor> not better, but easier.
07:32:53 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html ?
07:33:16 <ski> (Lemmih : bah, you got to it before me :)
07:33:29 <roconnor> That is the most wonderful thing I've seen all week.
07:34:03 <Lemmih> Rewrite rules are _so_ cool. I've been dreaming about writing them in TH for a while.
07:34:31 <mikael> wow
07:34:53 <roconnor> The Haskell extract from Coq could make use of this.
07:36:20 <xerox> What are they useful for?
07:36:30 <roconnor> Optimization.
07:37:41 <Lor> Ah, SPECIALIZE has been fully deprecated by RULES.
07:37:47 <Lor> (Yeah, I've been out of touch.)
07:37:49 <roconnor> heh, I could rewrite sin (pi) to 0.
07:38:25 <xerox> yay
07:51:48 <mikael> where can I read about the representation GHC or Hugs use for the IO type?
07:53:51 <mikael> as I understand it, it is conventionally a typical "stateful" function, i.e., (s -> (s, a)), except that s is some funky RealWorld type
07:53:52 <Lemmih> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:54:06 <Lemmih> ^^ IO in GHC.
07:54:53 <mikael> ah, yes.  does the RealWorld type actually represent something, or is this just a nice-looking front for something less pure?
07:56:50 <poetix> It represents the entire contents of the real world, obviously. You should see the compression algorithm they used - it's a scorcher!
07:56:50 <mikael> I'd also like to know if you could create a type MyIO a which can represent, say, readLine and putStrLn, and then define a type execMyIO :: MyIO a -> IO a
07:56:52 <Lemmih> It's a part of GHC's imagination.
07:57:20 <mikael> MyIO would also be a monad...
07:58:45 <mikael> what seems to make it tricky is that you can't just make a simple sum type, because certain operations are only valid for certain values of a (like, PutStrLn String would only be an option for a = ())
07:58:52 <Lemmih> type MyIO a = IO a; execMyIO = id (:
07:59:20 <mikael> hm, I guess it is possible :-P
08:00:01 <Lucinda> does Permute mean to change the order?
08:00:25 <mikael> yep
08:00:31 <Lemmih> mikael: 'a >> b' ignores the result type of 'a'.
08:02:03 <Itkovian> ttyl
08:02:45 <mikael> yeah... but, let's say our type is [data MyIO a = PutStrLn String | ...]; one could then do [(PutStrLn "foo" :: MyIO Int) >>= \x -> return (x + 1)]
08:03:14 <Lemmih> eh?
08:03:30 <Lemmih> data MyIO a where
08:03:38 <Lemmih>   PutStrLn :: String -> MyIO ()
08:03:50 <mikael> oh, huh...  I've never seen that notation before
08:04:23 * boegel leaves too
08:04:32 <Lemmih> @google GADTs haskell
08:04:33 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
08:04:55 <mikael> ooh!
08:05:15 <mikael> that seems nifty, thanks
08:06:17 <Lemmih> But why not make 'putStrLn' a function instead of a data constructor?
08:07:27 <mikael> what would that function do?  I'm trying to construct a somewhat high-level approximation of the IO type, for pedagogical purposes -- to show that I/O can be implemented without side effects by returning a lazy structure from the entry point
08:08:29 <Lemmih> ah ok.
08:12:33 <mikael> yay, GADTs worked excellently :-)
08:13:07 <psi> Is it possible for a function 'f :: String -> IO String' to receive an infinite string and "lazily" return the result? that is, the IO computations should be performed in correct order when I read the result
08:13:20 <lisppaste2> mikael pasted "IO sum type" at http://paste.lisp.org/display/11247
08:14:59 <psi> let's say the function returns the string unmodified, but prints something at every 'x' encountered
08:15:16 <xerox> What is the purpose of MyIO?
08:16:27 <Lemmih> psi: You can do that with unsafeInterleaveIO.
08:17:49 <psi> interesting. should I take the hint from the name and come up with another solution? :)
08:18:25 <xerox> @index unsafeInterleaveIO
08:18:26 <lambdabot> System.IO.Unsafe
08:18:37 <xerox> @type System.IO.Unsafe.unsafeInterleaveIo
08:18:50 <xerox> @type System.IO.Unsafe.unsafeInterleaveIO
08:18:56 <lambdabot> bzzt
08:18:56 <lambdabot> forall a. IO a -> IO a
08:19:33 <Lemmih> The type doesn't say much (:
08:20:01 <xerox> Indeed
08:20:06 <xerox> @doc System.IO.Unsafe
08:20:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.IO.Unsafe.html
08:20:29 <Lemmih> unsafeInterleaveIO = return.unsafePerformIO
08:24:13 <psi> I'm implementing a telnet client, and I want to immedietly display the text I receieve in a terminal widget I've designed. Until now I've read one line from the socket, processed it for telnet commands and then printed the plain text found
08:24:53 <psi> but it doesn't work so well. I need to display it immedietly, because I don't always get complete lines.
08:25:07 <greenrd> you need to stop reading lines then.
08:25:15 <greenrd> and read individual chars
08:26:15 <psi> yes, I thought of that. But if I send one char at a time to the terminal it's a bit difficult to parse escape codes. that's why I wanted to send an entire string.
08:26:46 <Lemmih> I think using lazy IO would be OK in this case.
08:38:14 <psi> thanks. I realized I don't need it, though (I think). I can read one char at the time until I find an escape byte, and then I'll try to read that in one go.
08:38:58 <psi> I mean, read the entire escape sequence in one go.
08:40:32 <Lemmih> It might be easier and more efficient to abstract away the reading.
08:43:07 <psi> with lazy IO, you mean?
08:44:22 <Lemmih> Yes. Something like 'getInput >>= processEscCodes >>= putStr' where getInput and processEscCodes are lazy.
08:44:47 <ski> mikael : see http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lec-20041029.html for MyIO
08:45:03 <ski> mikael : that works without GADT
08:45:45 <psi> yes, that solution has a greater appeal to me.
08:51:39 <sylvan> who was it that did the NEHE tutorials in Haskell?
08:51:52 <Lemmih> sylvan: lispy.
08:51:57 <sylvan> url?
08:52:54 <beelsebob_> who now maintains the haskell.org cvs repository?
08:56:32 <beelsebob_> anyone?
08:56:44 * beelsebob_ pokes people with sharp sticks
08:57:14 <Lemmih> The guys at galois, I think.
08:57:42 <ndm> shouldn't olaf know, given  he maintains haskell.org according to the front page
08:58:07 <beelsebob_> ndm: de doesn't at the mo
08:58:13 <beelsebob_> because it's just moved to galois
08:58:29 <beelsebob_> I'm trying to figure out who to contact to get write access to the hat repositorf
08:58:35 <beelsebob_> s/f$/y$/
08:59:13 <ndm> what are you committing?
08:59:52 * xerox screams
08:59:56 <beelsebob_> I'm trying to get my copy of the source into a vaguely sensible state in comparison with the normal one
09:00:12 <ndm> with a view to adding delta, or gui?
09:00:18 <beelsebob_> delta
09:00:26 <ndm> :(, i want gui
09:00:28 <beelsebob_> but gui after
09:00:48 <beelsebob_> delta is higher on my priority list on the grounds that it helps me get a PhD :P
09:01:09 <beelsebob_> I have some of the delta stuff working now
09:01:24 <beelsebob_> and updates to it keep changing hat-detect
09:01:36 <beelsebob_> so it would be useful to not keep emailing malcolm with it
09:01:38 <ndm> hey, i have been ignoring my phd for ages - its tradition
09:01:44 <beelsebob_> heh
09:01:56 <beelsebob_> I'm in a strange spate of doing work on it
09:02:14 <ndm> do you have anything useable yet?
09:02:22 <beelsebob_> for hat-delta? Yes
09:02:30 <ndm> nice
09:02:30 <beelsebob_> it implements one of the approaches
09:02:41 <ndm> with algorithmic dbeugging?
09:02:44 <beelsebob_> but not the one that's actually going to do the bulk of the leg work
09:02:55 <beelsebob_> yeh... it's my new hat-detect with added cool and funkyness
09:03:34 <ndm> is it a complete fork of hat-detect, or are they synced?
09:03:54 <beelsebob_> it's forked from it... but I keep going back and making changes to hat detect
09:04:15 <beelsebob_> because the slicing code for hat-delta can be used to improve hat-detect's UI without changing it's behavior
09:05:04 <ndm> cool
09:05:19 <ndm> the tool i think looks most interesting is Colin's hat-cover
09:05:45 <beelsebob_> yeh... hat-delta will be ripping chunks of code from hat-cover
09:05:59 <beelsebob_> or rather moving them into Cover.hs
09:06:05 <beelsebob_> and using them
09:06:12 <ndm> good, would be nice to have a library of hat functions
09:06:25 <Lemmih> Hi SyntaxNinja.
09:06:32 <beelsebob_> yeh... I'm slowly moving large chunks of bits into other files
09:06:38 <beelsebob_> because they're useful all over
09:06:49 <beelsebob_> I'll probably end up re-organising them after a bit
09:07:13 <ndm> sounds very good
09:07:57 <dcoutts> SyntaxNinja, you asked about my testing of cabal-get yesterday
09:09:19 <dcoutts> SyntaxNinja, the result is that it worked for me after being led through the steps and the right syntax. I added a couple notes to the hackage/cabal-get wiki page.
09:10:07 <SyntaxNinja> hi Lemmih
09:10:16 <SyntaxNinja> dcoutts: OK cool.
09:10:24 <SyntaxNinja> notes, like TODO or readme type stuff?
09:10:58 <dcoutts> http://www.haskell.org/hawiki/Hackage/TODO
09:11:04 <dcoutts> I added:
09:11:06 <dcoutts> #
09:11:06 <dcoutts> error messages are currently not very helpful
09:11:06 <dcoutts> #
09:11:06 <dcoutts> using cabal-get install as an unpriviledged user should use --user-deps --user-install by default
09:11:23 <dcoutts> (in the cabal-get section)
09:12:21 <SyntaxNinja> dcoutts: ok cool
09:12:51 <dcoutts> SyntaxNinja, I am right in thinking that cabal-get will install things in /usr/local by default? (I guess because cabal puts them in /usr/local by default and cabal-get does not override the cabal defaults I presume)
09:13:00 <SyntaxNinja> dcoutts: but no real showstoppers
09:13:03 <SyntaxNinja> dcoutts: right
09:13:14 <dcoutts> SyntaxNinja, ok. No, no real showstoppers
09:17:55 <SyntaxNinja> Q:      How does a hacker fix a function which
09:17:55 <SyntaxNinja>         doesn't work for all of the elements in its domain?
09:17:55 <SyntaxNinja> A:      He changes the domain.
09:28:46 * greenrd hates apache
09:29:09 <greenrd> 403 Forbidden - but why? I didn't forbid it, and this is a fresh install!
09:36:51 <KiMoS> what does f= \x -> 0   mean ?
09:37:04 <KiMoS> x is not equal to 0 ?
09:37:13 <SyntaxNinja> \ is lambda
09:37:35 <KiMoS> ?
09:37:43 <SyntaxNinja> so f is a function that takes an "x" and returns a zero
09:37:47 <SyntaxNinja> but that's a strange way to writ eit
09:37:52 <SyntaxNinja> it's like saying: f x = 0
09:38:23 <SyntaxNinja> @type \x -> 0
09:38:28 <lambdabot> forall t t1. (Num t) => t1 -> t
09:38:45 <KiMoS> x is not a member of 0 ?
09:39:32 <SyntaxNinja> no, it's like definiting a function 'f', with one parameter, 'x', but the function always returns 0 no matter what 'x' is.
09:39:43 <KiMoS> ohh
09:39:57 <xerox> f = \x -> 0  ===  f x = 0  ===  f _ = 0
09:40:17 <KiMoS> i can also use  f= const 0 ?
09:40:28 <xerox> Yep
09:40:34 <KiMoS> i got it thx
09:40:36 <Lemmih> @pl \x -> 0
09:40:37 <lambdabot> const 0
09:41:28 <SyntaxNinja> @type const
09:41:30 <lambdabot> forall a b. a -> b -> a
09:49:22 <schyffe> Hi, I have a rather stupid question about hugs. I just began my functional programming course and the teacher demonstrated hugs. However when I type "1+1" I get a blank result. It also says "Hugs.Base>" instead of "Prelude>" as it did in his demonstration. How do I change so it says Prelude?
09:50:23 <Igloo> Hugs.Base just means you have a newer version, I suspect
09:50:34 <Igloo> Does entering just "1" work?
09:50:46 <schyffe> I get a blank line as result
09:51:11 <Igloo> Try leaving hugs, running "reset; stty sane" at the command line, running hugs again and see if it still happens
09:51:11 <schyffe> I'm using WinHugs btw
09:51:14 <Igloo> Oh
09:51:30 <ndm> schyffe, which version of winhugs?
09:51:35 <ndm> some are quite broken...
09:51:50 <schyffe> oh
09:52:07 <schyffe> hmm it doesn't even say what version in the about dialog box
09:52:09 <ndm> i am rewriting it, to be properly windows compliant and to work properly
09:52:43 <ndm> i recommend the december 2001 version, thats what i use
09:52:57 <schyffe> allright
09:52:58 <ndm> in the top 5 lines when you start, it says Version: xxxxxxxxx
09:53:05 <ndm> what is it you are using?
09:53:34 <schyffe> 20050113
09:53:43 <ndm> where did you get that from?
09:53:52 <ndm> that indicates a CVS build, not an official release
09:54:13 <schyffe> http://cvs.haskell.org/Hugs/pages/downloading.htm
09:54:17 <Igloo> I don't think that's true
09:54:37 <schyffe> http://haskell.org/soe/Packages/hugs_SOE-Jan2005.msi
09:55:01 <ndm> it is, that build is a snapshot, not an official release
09:55:25 <schyffe> I see
09:55:36 <schyffe> I found a link to hugs98-Nov2003-2.msi
09:55:47 <ndm> that should work
09:55:54 <schyffe> allright
09:56:00 <ndm> its just with me, some libraries didn't work, or changed interface
09:56:12 <ndm> which is why i'm happily sticking to Dec 01
09:56:30 <schyffe> I see
09:56:41 <ndm> but i'm about 2 months away from releasing a brand new winhugs, which will work and be built off hugs cvs
09:57:10 <schyffe> cool
09:57:28 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/winhugs.php
09:57:30 * Igloo would recommend using the lateset release unless you have legacy code you need to support and can't fix, and to report bugs like the above to the list
09:58:00 <ndm> don't bother reporting the bug of not working at all
09:58:04 <ndm> thats well known
09:58:17 <ndm> the latest stable release is the 2003 one
09:58:17 <Igloo> Err, it is?
09:58:21 <ndm> yep
09:58:24 <Beelsebob> lol
09:58:45 <ndm> for winhugs, teh linux ones have more up to date versions
09:59:20 * Igloo doesn't remember seeing anything about it being broken on Windows on the lists
09:59:43 <ndm> download the cvs and have a compile, the result is nothing gets written out
09:59:46 <Igloo> Although admittedly I wouldn't have paid much attention to such things
09:59:57 <ndm> Hugs changed to support Unicode, and WinHugs died
10:00:09 <schyffe> Which one should I use? Winhugs (Haskell98 mode) or Winhugs (Hugs mode)?
10:00:22 <ndm> are you learning haskell?
10:00:26 <schyffe> yeah
10:00:33 <ndm> Haskell98 mode
10:00:37 <schyffe> allright
10:01:12 <schyffe> thanks a lot, finally I can get the result from "1+1" :)
10:01:23 <ndm> woohoo!
10:03:44 <KiMoS> what is the firststep haskell do in here:  fst (tail, head) (map succ [1..10])          ?
10:04:05 <KiMoS> (tail, head)?   or  (map succ [1..10])  ?
10:04:17 <Beelsebob> use hat-anim
10:04:20 <Beelsebob> and find out
10:04:24 <KiMoS> what is that
10:04:26 <ndm> hehe, that would be painful...
10:04:33 <ndm> look at the definition of fst
10:04:36 <Beelsebob> not really neil?
10:04:38 <ndm> fst (a,b) = a
10:04:40 <KiMoS> i dont have linux to use hat
10:04:45 <Beelsebob> :(
10:04:59 <KiMoS> so  (tail, head)  will be the first ?
10:05:13 <ndm> Beelsebob, harder than i want at the mo
10:05:15 <KiMoS> i also thought so but it wont be logical
10:05:28 <ndm> yep, how do you mean not logical?
10:05:52 <KiMoS> what will haskell do with (tail, head)
10:05:57 <KiMoS> first it needs a list
10:05:58 <KiMoS> >
10:06:02 <Philippa> eh?
10:06:06 <Beelsebob> I'm guessing... itll be:
10:06:06 <Beelsebob> fst (tail, head) (map succ [1..10])
10:06:06 <Beelsebob> -> tail (map succ [1..10])
10:06:06 <Beelsebob> -> tail (succ 1:map succ [2..10])
10:06:06 <Beelsebob> -> ....
10:06:42 <Beelsebob> ndm: what's hard about it?
10:06:51 <Philippa> that sounds about right
10:06:52 <sylvan> KiMoS, it's undefined, order of evaluation can be whichever in Haskell since it's lazy
10:07:02 <ndm> compiling with hat-trace never works for me
10:07:06 <Philippa> um, lazy /is/ a defined order of evaluation
10:07:07 <sylvan> implementation specific, in other words
10:07:11 <Philippa> (OTOH, Haskell 98 merely defines non-strict)
10:07:31 <ndm> i can never figure out which hat tool to use, and then i can never figure out where my data is
10:07:40 <Beelsebob> sylvan it's the first redex it comes across in a left-to-right traversal that gets reduced
10:07:56 <ndm> doesn't haskell have to give the same effect as lazy, even if the compiler decides to evaluate strictly
10:07:57 <Beelsebob> ndm: I always start in hat-observe
10:08:00 <sylvan> Beelsebob, is that in the report though?
10:08:02 <Beelsebob> just to get my bearings
10:08:09 <Beelsebob> sylvan: I think so?????
10:08:11 <ndm> sylvan, yes, i think it is
10:08:13 <Beelsebob> maybe not
10:08:13 <Philippa> the report merely specifies non-strict evaluation
10:08:20 <Beelsebob> uhhuh?
10:08:30 <mikael> mustn't the ``tail'' be reduced first? :-P
10:08:33 <Philippa> other evaluation schemes're possible, somebody experiments once in a while
10:09:00 <basti_> a.r.g.h.
10:09:18 <sylvan> f x y = x + y in f 1 2 could be either f = 1 + y -> f = 1 + 2 = 3 or f = x + 2 -> f = 1 + 2 = 3
10:09:35 <Philippa> basti: alt.rec.garden.hoes?
10:09:44 <basti_> no
10:09:57 <basti_> relational conflicts
10:10:28 <Philippa> ah :-(
10:10:31 <basti_> but, the evaluation order actually makes a difference. if you evaluate "outside to inside" then you get the fewest endless loops
10:10:37 <basti_> (like haskell does)
10:11:08 <ndm> if soemthing evaluates sucecssfully strict => evaluates successfully lazy
10:11:12 <ndm> but not the other way round
10:11:15 <basti_> yes
10:11:21 <ndm> lazy is more powerful, always
10:12:11 <mikael> what about { print "hey!"; x * 5 }? :-P
10:12:23 <xerox> boegel: ping
10:18:48 <Philippa> mikael: insufficient detail. Is that monadic code? An imperative lang?
10:30:25 <xerox> Itkovian: ping!
10:45:23 <vegai> I see from the wiki that a Haskell mail client has been talked of
10:45:34 <basti_> freakin huge pic of hurricane katrina:  http://rapidfire.sci.gsfc.nasa.gov/gallery/?2005240-0828/Katrina.A2005240.1700.250m.jpg
10:46:11 <vegai> or on a lesser note, is there a maildir parser already available?
10:49:41 <vegai> I'm thinking something like mailx or nail, but (of course written in Haskell and) superior in usability
10:59:16 <Itkovian> xerox: pong
11:01:24 <Philippa> if I wanted to compile an ML-like language to C, what would the preferred technique be these days? And is there anywhere I can find a paper, documentation etc on it?
11:02:00 <vegai> would it be totally irresponsible to name a Haskell mail client 'ham'?
11:03:09 <vegai> no matter, I'll do it anyway
11:03:30 <Philippa> heh
11:03:56 <Beelsebob> why irresponsible?
11:04:17 <vegai> Beelsebob: I'm afraid the pun power would be immense
11:04:23 <Beelsebob> heh
11:04:31 <Beelsebob> I'd go with hama anyway
11:05:19 <vegai> well, we'll see. It's hardly the most important aspect anyway
11:05:31 <vegai> what am I saying? It's the most important aspect!
11:05:40 <Beelsebob> haha
11:05:58 <Beelsebob> if it's ham, you'd better have a better spam filter than Mail.app
11:06:19 <Beelsebob> because I think that's the best contender for keeping the ham and not the spam
11:08:06 <vegai> I don't know... perhaps filtering spam is not the mail client's task
11:08:08 <xerox> Itkovian: hi!  What is the LSystem datatype you use in LSP.hs?  Is it slightly different from the boegel's one
11:08:27 <vegai> this would probably be just a "mail reader"
11:08:50 <vegai> so it would only read local things and possibly use another program for sending too
11:09:18 <vegai> like a fancy frontend to "cat" really :)
11:09:49 <vegai> or yi...
11:13:13 <Itkovian> xerox: erm, no, I parse to the LSystem type in boegel's repos iirc.
11:13:23 <Itkovian> he _should_ update it though.
11:13:25 <Itkovian> ;-)
11:14:41 <xerox> err :)
11:14:54 <xerox> LSystem.lhs is a little module, fortunately
11:15:07 <xerox> Do you have time to hack the modifications in? <blink> <blink>
11:15:27 <xerox> Oh, if I understand correctly, you have another LSystem.lhs?
11:16:11 <Itkovian> xerox: no, I have the same LSystem.lhs, but I've changed it to LSystem.hs and started with some haddock stuff in it, instead of literal stuff.
11:17:17 <xerox> Is it available somewhere?  I'm writing the interactive GUI.
11:21:28 <Itkovian> xerox: a sec, gotta make a phone call.
11:21:47 <Itkovian> a friends brother killed himself, so this will be tough.
11:22:32 <wilx> o_O
11:22:45 <xerox> Sorry, nevermind.
11:27:15 <Hatchetman> i never did and hopefully never will understand suicide
11:29:10 <wilx> He didn't say it was suicide.
11:29:29 <wilx> He might as well killed himself while riding his bike without helmet.
11:29:44 <CosmicRay> last call for last-minute HWN stories
11:30:01 <Hatchetman> wilx, true
11:30:10 <Hatchetman> but it sounded like suicide to me
11:30:39 <Hatchetman> otherwise it was more likely Itkovian would have said something like...he was killed while riding his bike etc
11:32:27 <CosmicRay> hmm?  is everyone ok?
11:33:12 * basti_ is
11:33:16 <Itkovian> nah, he hung himself, rather impulsively for all they know atm.
11:33:22 <Itkovian> deep shit.
11:33:30 <basti_> :(
11:33:55 <basti_> most suicides don't happen with a lot of reason involved.
11:34:15 <xerox> CosmicRay: uhm, I'm writing an app showing off Haskell and Cairo, I hope I'll have it finished this night and blog about it.
11:34:15 <Itkovian> don't understand it either, but he had a phone call a few hours prior to the dangling, (if you deem this offensive, sorry, but dark humour helps me best in times like this) ... so they're looking into that right now
11:34:16 <basti_> it's not that you make an appointment with your lawyer before.
11:34:25 <Itkovian> anyway, LSystem.hs
11:34:44 <CosmicRay> xerox: sounds nice, but it will probably have to go into next week's issue.
11:34:46 <xerox> CosmicRay: and there also is gtk2hs-0.9.9.5
11:34:52 <Itkovian> I can either mail my last version, or you can wait, and I'll kick boegel tomorrow and have him update the repos
11:34:54 <xerox> Oh, okay :-|
11:34:58 <CosmicRay> xerox: was that announced on the lists?
11:35:13 <xerox> Itkovian: it would be very nice if you could mail me your version, tank you veery much.
11:35:14 <basti_> actually i think, humour is the only existant way to cope with suicide
11:35:19 <Itkovian> hmm, if you want it finished ... ok
11:35:23 <Hatchetman> basti_, still i can 100% say i will never kill myself
11:35:26 <Itkovian> roger that
11:35:33 <xerox> CosmicRay: is an "unofficial tech release" bringin' my cairo code.
11:35:48 <CosmicRay> ;-)
11:35:51 <xerox> :-D
11:36:05 <CosmicRay> xerox: if you have an announcement I can like to, I'll do that.  no link, no post though ;-)
11:36:28 <greenrd> Itkovian: A friend of mine thought about killing himself multiple times because, as a person with learning difficulties, he believed he had little to look forward to but low-wage, low-skilled labour full of drudgery. I blame capitalism.
11:36:43 <xerox> There is the mail I sent to the gtk2hs-devel list announcing it and the finish of the work
11:37:58 <schyffe> Is there a good site with haskell exercises for beginners?
11:38:11 <basti_> schyffe: did you implement faculty?
11:38:24 <xerox> schyffe: Yet Another Haskell Tutorial comes with a lot of interesting exercise, and it's a good tutorial by itself too.
11:38:24 <CosmicRay> schyffe: Yet Another Haskell Tutorial is probably the best online one
11:38:25 <schyffe> not yet
11:38:37 <schyffe> allright
11:38:46 <Itkovian> xerox: mailed.
11:39:03 <basti_> my suggestion would have been "try implementing faculty in as many ways as you can come up with"
11:39:32 <KiMoS> @nub
11:39:33 <lambdabot> Unknown command, try @listcommands.
11:39:34 <Cale> Someone should carve out a section on the wiki with a collection of beginner exercises. :)
11:39:46 <KiMoS> @t nub
11:39:47 <lambdabot> Maybe you meant: timein todo todo-add todo-delete topic-cons topic-
11:39:47 <lambdabot> init topic-null topic-snoc topic-tail topic-tell type pl wn
11:39:54 <Cale> @type nub
11:40:12 <lambdabot> bzzt
11:40:16 <Cale> @type List.nub
11:40:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:40:26 <KiMoS> thx
11:40:38 <Cale> @plugs nub [1,1,1,1,2,2,2,1,1,3,2,3,3,1]
11:40:40 <lambdabot> [1,2,3]
11:41:00 <Cale> @plugs nub (reverse [1,1,1,1,2,2,2,1,1,3,2,3,3,1])
11:41:02 <lambdabot> [1,3,2]
11:41:05 <schyffe> I'll give it a try basti_
11:41:10 <TheHunter> @plugs nub $ cycle [1,2,3]
11:41:21 <lambdabot> Terminated
11:41:22 <TheHunter> @plugs take 3 $ nub $ cycle [1,2,3]
11:41:23 <basti_> lol
11:41:25 <lambdabot> [1,2,3]
11:41:40 <KiMoS> nub it baby
11:41:48 <xerox> Itkovian: I'm not receiving it, mumble.
11:42:10 <Cale> hehe, bottom terminated lists :)
11:42:22 <CosmicRay> oh wow, david has a FUSE module!
11:42:25 <CosmicRay> SWEET!
11:42:37 <Cale> @plugs 1 : 2 : 3 : undefined
11:42:39 <lambdabot> Prelude.undefined
11:42:47 <Cale> @plugs take 3 (1 : 2 : 3 : undefined)
11:42:49 <lambdabot> [1,2,3]
11:45:21 <xerox> Itkovian: got it.  Cool.
11:45:41 <xerox> Cale: this is just lazyness, right?
11:57:20 <CosmicRay> xerox: can you send me a link to that gtk2hs announcement in the ml archives?
11:57:28 <CosmicRay> draft of today's HWN, http://darcs.complete.org/hwn/prep.html
12:03:15 <Lemmih> CosmicRay: Great.
12:03:57 <xerox> CosmicRay: sure.
12:04:33 <schyffe> if I write a function with more then one argument without parentheses I'll write: "func arg1 arg2", how do I write it with parentheses? I thought "func(arg1, arg2)"
12:04:37 <xerox> CosmicRay: http://sourceforge.net/mailarchive/forum.php?thread_id=8063084&forum_id=44293
12:05:14 <TheHunter> schyffe, (func  arg1) arg2.
12:05:45 <Lemmih> schyffe: (arg1, arg2) is a tuple.
12:05:54 <schyffe> I see
12:06:10 <ndm_> typically (func arg1 arg2)
12:06:22 <ndm_> if you want to use it in an argument to another function
12:06:57 <schyffe> allright.. I just wanted to see how near c-syntax I could get :P
12:07:00 <dcoutts> CosmicRay, we're not expecting people to package that release, just for people to experiment etc.
12:12:56 <ndm_> what can this be abbreviated to?
12:13:05 <ndm_> do x <- many1 (noneOf "<")
12:13:06 <ndm_>      return $ Text x
12:13:19 <ndm_> i know there must be a 1 line version of that...
12:13:21 <vegai> hmm, move is oddly name in here
12:13:24 <vegai> @hoogle renamefile
12:13:25 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
12:13:35 <TheHunter> @pl many1 (noneOf "<") >>= \x -> return $ Text x
12:13:37 <lambdabot> Text `fmap` many1 (noneOf "<")
12:14:00 <vegai> I guess I'll do moveFile = renameFile in my programs to reduce confusion :P
12:14:27 <ndm_> vegai, you're just a linux user - win users do "ren", linux users do "mv"
12:14:44 <ndm_> @hoogle fmap
12:14:46 <lambdabot> Prelude.fmap :: Functor a => (b -> c) -> a b -> a c
12:15:13 <ndm_> is not fmap something like map? it looks "weird" in the above example
12:15:25 <ndm_> (i've never used fmap before, so its just a feeling)
12:16:05 <TheHunter> Parsec's parser monad is a functor, so it is ok.
12:16:15 <TheHunter> *Functor
12:16:15 <ndm_> ok, thanks
12:16:43 <TheHunter> for things that are Monads and Functors fmap and liftM should be the same.
12:16:58 <ndm_> oh, cool
12:17:07 <ndm_> liftM looks more natural in that particular case
12:17:25 <vegai> ndm_: do windows users rename like this: renameFile "foo" "bar/foo" ?
12:17:36 <ndm_> can do
12:17:41 <TheHunter> well, a monad _is_ a functor, such that...
12:17:43 <vegai> but that's moving!
12:17:56 <TheHunter> therefore liftM looks plain idiotic to me.
12:17:59 <ndm_> vegai, moving to a new name
12:18:07 <vegai> aaugh :)
12:18:27 <TheHunter> unfortunately, at some point they decided to drop the Functor m => Monad m relationship.
12:18:50 <ndm_> TheHunter, its all new to me - if `fmap` is conceptually better, i'll run with that
12:20:19 <TheHunter> at any rate, in something like highly-tuned as parsec, fmap might have a performance advantage over liftM.
12:21:47 <ndm_> performance is the one thing i don't care about at all, the other half takes in the region of 6 hours...
12:23:20 <vegai> ehh
12:23:36 <vegai> Cabal doesn't accept everything on the "License" field
12:24:17 <vegai> ...it only accepts GPL?
12:24:18 <vegai> hmm
12:26:35 <dcoutts> vegai, there are few predefined ones, GPL, LGPL, BSD3, BSD4
12:27:05 <vegai> well, I can leave it out
12:27:11 <dcoutts> for everything else there is other (not exaclty sure of the name)
12:27:20 <dcoutts> and specify the license file
12:40:12 <vegai> hmmm, I wonder how much extra work I'll need to make this work both with ghc and nhc98...
12:41:19 <ndm_> vegai, what are you trying to implement?
12:41:30 <ndm_> and what about hugs...
12:46:07 <vegai> a mail client
12:46:18 <vegai> or not so much a client as just a reader
12:46:39 <vegai> I don't intend to support anything else than Maildir
12:47:13 <ndm_> if you don't put any ghc specific things in, i.e. no -fglasgow-exts, it should be relatively easy
12:47:56 <vegai> yeah...
12:48:11 <Beelsebob> use hmake and the build system should be a matter of setting a different flag on build
12:48:22 <vegai> Cabal seems to act a bit differently under nhc, but perhaps they will have corrected that before my program is finished
12:48:30 <Beelsebob> hmake -(ghc|nhc) yourMainModule
12:48:57 <ndm_> and there are many other advantages to hmake, such as hat output and making of Happy/Alex/etc files
12:52:20 <Beelsebob> hehe, neil and I have become the nhc hit squad
12:54:10 <vegai> nhc seems very attractive when trying to write something small and clever
12:54:21 <Beelsebob> indeed
12:54:39 <Beelsebob> getting more so too
12:55:51 <vegai> is there a string completion library already done...?
12:56:07 <Beelsebob> string completion?
12:56:13 * xerox yawns
12:56:21 <xerox> Itkovian: could I disturb you a second?
12:56:33 <greenrd> vegai: you mean like shell completion?
12:56:39 <greenrd> vegai: libreadline?
12:56:39 <Itkovian> xerox: yes?
12:56:54 <Beelsebob> there's a haskell version of readline isn't there?
12:57:26 <xerox> Itkovian: is it expected to have "lsystem variables {ABC} , constants {FG+-^} , {A} , rules {A:BF+G  B:G-F}, 4, 6.076" parsing to "+-" ?
12:57:49 <vegai> something String->[String]->[String], which returns all the possible completions of the first string against the list of strings
12:58:08 <vegai> shouldn't this be sorta natural for doing in pure haskell..
12:58:14 <Itkovian> xerox: hmm, let me check yr example
12:58:28 <xerox> Itkovian: it's the one I got from your mail
12:58:35 <Itkovian> hmm :-)
12:58:35 <Beelsebob> vegi, wouldn't it be quite easy to write?
12:58:38 <xerox> Your first mail :-)
12:58:54 <Beelsebob> flip $ filter beginsWith
12:59:06 <Beelsebob> and beginsWith would be pretty easy to write
12:59:07 <Itkovian> xerox: see PM.
12:59:51 <Lemmih> @type \x xs -> filter (List.isPrefixOf x) xs
12:59:52 <vegai> Beelsebob: yeah, seems like so. On the other hand, there are readline bindings in ghc..
13:00:07 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [[a]]
13:00:10 <Beelsebob> vegai: I'm pretty sure they work in nhc too
13:00:12 <Beelsebob> hat uses them
13:00:17 <Beelsebob> and that compiles in nhc too
13:00:39 <vegai> ok, good
13:00:52 <Lemmih> @eval let completions x xs = filter (List.isPrefixOf x) xs in completions "hello" ["hello world","jalla"]
13:00:54 <lambdabot> ["hello world"]
13:01:10 <Beelsebob> that would work then :)
13:01:38 <vegai> Yau.
13:01:47 <vegai> never would've thought that *that* is a one-liner
13:01:54 <Beelsebob> hehe
13:02:46 <vegai> hmm, my interface will be very readliny anyway. Perhaps I'll still use it
13:03:35 <greenrd> @hoogle [[a]] -> [[a]]
13:03:36 <lambdabot> List.transpose :: [[a]] -> [[a]]
13:03:36 <lambdabot> Prelude.sequence :: Monad a => [a b] -> a [b]
13:03:36 <lambdabot> Prelude.tail :: [a] -> [a]
13:04:05 <greenrd> @hoogle+
13:04:06 <lambdabot> Prelude.init :: [a] -> [a]
13:04:06 <lambdabot> Prelude.reverse :: [a] -> [a]
13:04:06 <lambdabot> Prelude.cycle :: [a] -> [a]
13:04:16 <Beelsebob> heh
13:04:28 <Beelsebob> @karma+ hoogle
13:04:29 <lambdabot> hoogle's karma raised to 1.
13:04:33 <Beelsebob> :)
13:05:02 * Lemmih doesn't quite get hoogles unification algorithm.
13:05:20 <rt_> http://brainwagon.org/gallery/irgimp/irlake
13:05:25 <Beelsebob> hmm?
13:11:51 <vegai> hmm, readline bindings are not documented... who uses them
13:14:19 <Beelsebob> I think hat does
13:14:29 <Beelsebob> it certainy did in the past
13:20:45 <vegai> googling "import System.Console.Readline" works fine too, I guess ...
13:24:20 <Beelsebob> :)
13:25:20 <vegai> mm, making a custom completion with that isn't trivial either
13:25:28 <vegai> damned GNU software ... :)
13:29:39 <Beelsebob> a custom completion?
13:39:18 * mwc pines for some Haskell equivalent of camlp4
13:39:51 <Beelsebob> @google camlp4
13:39:53 <lambdabot> http://caml.inria.fr/resources/doc/index.en.html
13:40:11 <mikael> do you know about Template Haskell?  from what I recall, that's a little bit of camlp4, at least
13:40:18 <mikael> or maybe not
13:41:08 <vegai> Beelsebob: the default action of <TAB> in readline is to complete against the files in the current directory
13:41:17 <Beelsebob> bah, silly
13:41:33 <mwc> mikael, I was thinking of implementing a better record system in Haskell
13:41:34 <vegai> well..... yeah. Not too hard to replace it, though
13:41:41 <Beelsebob> :)
13:42:04 <vegai> completion against filenames perhaps is the most used one
13:42:15 <mikael> mwc: ooh.  that would be very nice :-)  I think someone wrote a proposal for that, maybe SPJ or Simon Marlow
13:43:01 <vininim> jesus.. ghc compiling ghc is taking long time. ._.
13:43:33 <Beelsebob> heh, takes about 15 mins for all 3 stages on my machine
13:43:36 <Beelsebob> 2
13:43:37 <vegai> thankfully, that needs to be done by one person per ghc version/architecture :)
13:43:52 <vegai> once.
13:44:06 <TheHunter> readline is stupid. Why on earth does it allow entries to appear in the history more than once?
13:44:22 * vegai shrugs
13:44:28 <vegai> wanna write a replacement? =)
13:44:42 <TheHunter> nah, no time.
13:44:53 <vegai> hmm, actually..
13:45:04 <TheHunter> but that's not an excuse for not-implemented obvious features.
13:45:17 <vegai> well... GNU
13:45:45 <vegai> I guess I could write the parts I need myself
13:48:29 <vininim> it might be the opengl stuff
13:51:13 <dcoutts> TheHunter, I think it's already a configurable option, I've seen readline doing histroy compression before
13:51:55 <vegai> thanks for the help people. My mail proggie is now estimately 1% finished
13:53:30 <TheHunter> dcoutts, does that mean I have to recompile readline or does it mean the application has to explicity ask for support?
13:56:04 <TheHunter> @google "/etc/readline.conf"
13:56:06 <lambdabot> http://lists.debian.org/debian-devel/1996/12/msg00462.html
14:06:37 <xerox> Some haskell + cairo porn: http://haskell.galois.com/~paolo/five-300805-2306.png
14:06:41 <xerox> Fixing atm ;)
14:09:34 <basti_> http://my.opera.com/community/party/reg.dml < opera registration codes for free! it's operas 10th birthday.
14:10:07 <wilx> What editor is that?
14:10:18 <xerox> <shackan> what editor is that ?
14:10:18 <xerox> <xerox> Gobby, the collaborative realtime editor of choice!
14:10:27 <xerox> hah :-D  synchronized.
14:10:35 <wilx> :)
14:11:03 <xerox> There it is another example of this great collaborative realtime thing: http://haskell.galois.com/~paolo/pair-230805-2109.png
14:11:51 <boegel|home> xerox: still fiddling with HaskLS ? :)
14:11:58 <wilx> Heh, that sounds like fun.
14:12:04 <xerox> boegel yup!
14:12:12 <xerox> The new .hs module doesn't really work here
14:12:23 <Beelsebob> xerox: have you met one with no irc bit?
14:12:31 <xerox> Beelsebob: yes!
14:12:43 <Beelsebob> how silly
14:12:54 <Beelsebob> I mean... SEE doesn't... but it has iChat integration
14:13:38 <sieni> does it have vi keybindings?
14:13:42 <sieni> i.e. gobby
14:14:05 <xerox> Err
14:14:13 <xerox> It doesn't have _any_ editing feature :-P
14:15:05 <basti_> o0
14:15:10 <sieni> What's an editor without editor features
14:15:12 <basti_> what does it have, then?
14:15:27 <xerox> Err I mean, there is no search and replace, no "commands" of any sort..
14:15:34 <sieni> it's like gin and tonic without tonic and gin replaced with whiskey
14:15:36 <basti_> ohh
14:15:44 <Beelsebob> heh
14:15:44 <xerox> BTW I'm having REAL fun
14:15:53 <Hatchetman> sieni, so its whiskey?
14:15:55 <Hatchetman> :D
14:15:58 <Hatchetman> whiskey is nice
14:15:59 <xerox> The thing I showed you doesn't work exactly as I thought but it does work in some way
14:16:04 <xerox> So I can produce images !!!
14:16:26 <xerox> (5,22.5,"F",[('F',"GG+[F+F[+F]+]")])
14:16:36 <xerox> I'm writing it here for not losing it :P
14:22:37 <vininim> o_O
14:22:41 <vininim> is that a fractal or something?
14:23:21 <basti_> l-system
14:24:22 <dcoutts> TheHunter, sorry, not sure. I just know I've seen the feature.
14:28:45 <dcoutts> xerox, ping
14:29:47 <xerox> pong
14:31:42 <humasect> has anyone built SDL haskell bindings lately?
14:31:50 <humasect> having an issue with ZCMain.
14:32:13 <Lemmih> Using MacOS?
14:32:26 <humasect> win32
14:32:50 <humasect> i just now found a main = decl in Setup.lhs...
14:33:18 <humasect> completely empty everywhere, the build process seems fine.
14:33:21 <Lemmih> Having problems with the Setup script or the binding?
14:33:38 <humasect> i was thinking the Setup was thinking it isn't a library
14:33:51 <humasect> i'm trying to build the bindings
14:34:58 <Lemmih> Compile and run the Setup script.
14:35:46 <Lemmih> (You can also interpret it if you like)
14:36:20 <humasect> hm, doesn't seem to work compiled either.
14:36:29 <Lemmih> How so?
14:36:41 <humasect> @paste
14:36:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:37:38 <humasect> f:/ghc/ghc-6.4/libHSrts.a(Main.o)(.text+0x87):Main.c: undefined reference to `__stginit_ZCMain'
14:37:39 <humasect> f:/ghc/ghc-6.4/libHSrts.a(Main.o)(.text+0xa1):Main.c: undefined reference to `ZCMain_main_closure'
14:37:39 <humasect> main.exe: got error code while preprocessing: Graphics.UI.SDL.General
14:38:07 <basti_> hmmm ive seen this.
14:38:14 <basti_> humasect: missing some -package?
14:38:24 <humasect> i found references in #haskell logs about not having a Main module.
14:38:25 <humasect> hmm..
14:39:20 <Lemmih> Looks like your hsc2hs is broken.
14:39:32 <boegel|home> xerox: is this what you're aiming for ?
14:39:35 <humasect> ah
14:39:36 <boegel|home> http://scannedinavian.org/~boegel/HaskLS.png
14:39:49 <xerox> boegel, more this:
14:39:49 <boegel|home> (it has rotated a bit in 3D now though)
14:39:57 <xerox> http://www.ozonehouse.com/ContextFree
14:40:00 <xerox> hehe I know :-D
14:40:18 <boegel|home> xerox: which one on this page ?
14:40:23 <TheHunter> dcoutts, well, people are doing stuff like this (although that was a while ago) http://www.octave.org/octave-lists/archive/octave-maintainers.2000/msg00114.html.
14:40:35 <TheHunter> readline developers are morons.
14:40:41 <xerox> boegel, it puts some randomness in it
14:40:54 <vininim> uh.. how am I supposed to paste in the @paste o_O
14:41:09 <boegel|home> xerox: oh, okay :) well, I filled in the grammar you used, and that's what i got using my gui :)
14:41:16 <vininim> 'wiki' editing?
14:41:27 <xerox> boegel oh let me see
14:41:29 <Lemmih> vininim: Yep.
14:41:34 <xerox> I didn't understand you did it sorry
14:41:56 <humasect> hsc2hs could be too new for the bindings, perhaps, i don't know when they were last maintained
14:42:18 <humasect> no..
14:42:46 <Lemmih> humasect: Building with -v will give you more info.
14:43:04 <xerox> boegel, ah, it was nicer in my (wrong) thing hehe
14:43:25 <humasect> yeah, i think i found some flags gcc doesn't like
14:43:30 <SyntaxNinja> % dig +noall +answer cvs.haskell.org
14:43:30 <SyntaxNinja> cvs.haskell.org.        3753    IN      CNAME   haskell.galois.com.
14:43:30 <SyntaxNinja> haskell.galois.com.     86400   IN      CNAME   monk.galois.com.
14:43:30 <SyntaxNinja> monk.galois.com.        86400   IN      A       192.168.40.3
14:43:31 <humasect> ok cool.
14:43:32 * SyntaxNinja wiggles eyebrows
14:44:34 <vininim> okay, posted the fibonnaci function I wrote from the yet another haskell tutorial exercise
14:44:54 <vininim> the problem here, is that it is taking too long for small values, while 2^40000 takes less than f 30
14:46:15 <vininim> what you think? normal? something I should have in mind?
14:46:51 <psi> pasted where?
14:47:24 <psi> oh, on the wiki
14:47:26 <TheHunter> the same thing happens that would happen if you had implemented that thing in C. No results are cached.
14:47:31 <vininim> @paste
14:47:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:47:35 <vininim> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:49:35 * boegel|home leaves for bed
14:50:32 <humasect> hmm.
15:12:56 <Lemmih> humasect: Still no luck?
15:14:05 <humasect> yeah.
15:14:22 <humasect> i played with the flags passed to hsc2hs, libs+includes
15:15:16 <Lemmih> You can paste the output if you want some help.
15:16:32 <humasect> Preprocessing library SDL-0.2.0...
15:16:32 <humasect> f:\ghc\ghc-6.4\bin\hsc2hs.exe -I/ghc/ghc-6.4/include/mingw -Dmain=SDL_main -oGraphics\UI\SDL\General.hs Graphics\UI\SDL\General.hsc
15:16:32 <humasect> f:/ghc/ghc-6.4/libHSrts.a(Main.o)(.text+0x87):Main.c: undefined reference to `__stginit_ZCMain'
15:16:32 <humasect> f:/ghc/ghc-6.4/libHSrts.a(Main.o)(.text+0xa1):Main.c: undefined reference to `ZCMain_main_closure'
15:16:33 <humasect> is all i'm getting. maybe i really do need a -package somewhere, i can't see why though.
15:17:24 * Lemmih wonders what the '-Dmain=SDL_main' is doing there.
15:17:43 <Micket> Hey guys
15:17:49 <Micket> http://rafb.net/paste/results/W3p0Da57.html
15:17:55 <humasect> hmm. aha. passed in by Setup.lhs sdl-config T_T
15:18:00 <Micket> I dont quite understand this error message im getting :/
15:18:04 <Micket> (its in the link)
15:18:30 <Micket> gRandom should recieve a StdGen
15:20:18 <Lemmih> Micket: What's the type of gWorld?
15:20:31 <Micket> [Room]
15:21:18 <Lemmih> And you probably want to change 'g' to 'r' after the 'return'.
15:21:45 <Lemmih> gWorld :: Stdgen -> [Room]?
15:21:52 <Lemmih> *StdGen
15:22:01 <Micket> no gWorld isnt a function
15:22:11 <humasect> ;)
15:22:24 <Lemmih> Then why do you apply it to 'g'?
15:23:10 <Micket> g :: Game { gWorld :: [Room] ...... }
15:23:14 <Lemmih> Bah, I'm being stupid here /-:
15:23:40 <Lemmih> Yes, then gWorld is a function of type :: Game -> [Room].
15:24:02 <Micket> oh
15:24:04 <Micket> >_<
15:24:11 <Lemmih> And gRandom is of type :: Game -> StdGen, right?
15:24:26 <Micket> Yes
15:24:47 <Micket> Hmm, i think the problem is in the row above
15:25:17 <Lemmih> You're telling GHC that 'randomEnemies' can take any type as first argument if it's an instance of RandomGen.
15:25:48 <Lemmih> But it actually can't. The first argument must be of type StdGen.
15:26:14 * humasect gives up
15:26:39 <Lemmih> humasect: Does it work if you omit the '-Dmain=SDL_main' flag to hsc2hs?
15:26:45 <humasect> no.
15:27:39 <Lemmih> humasect: Try pasting the program hsc2hs generates on a paste page.
15:27:46 <humasect> Executing: f:\ghc\ghc-6.4\bin\ghc.exe -c -If:/ghc/ghc-6.4/include/mingw Graphics\UI\SDL\General_hsc_make.c -o Graphics\UI\SDL\General_hsc_make.o
15:27:46 <humasect> Executing: f:\ghc\ghc-6.4\bin\ghc.exe Graphics\UI\SDL\General_hsc_make.o -o Graphics\UI\SDL\General_hsc_make.exe
15:27:46 <humasect> is the full output of hsc2hs -v (excluding the previously pasted undefined refs)
15:28:09 <humasect> hmm.
15:28:24 <humasect> the c output?
15:28:29 <Micket> Hmm, yeah, i just had to replace the RandomGen g => g with StdGen.. i was fooled by a similiar function i had
15:28:39 <Micket> thanks Lemmih!
15:29:03 <Lemmih> humasect: Invoke hsc2hs with '--no-compile'.
15:29:49 <humasect> k,
15:29:55 <xerox> http://haskell.galois.com/~paolo/more-Haskell-cairo-porn.png
15:30:45 <humasect> http://rafb.net/paste/results/MzrfEG20.html
15:32:54 <humasect> i'll have to do an ffi to an audio lib (probably SDL) anyway. (this binding doesn't have them.)
15:33:34 <Lemmih> I've also made a binding to libSDL_mixer.
15:33:52 <humasect> ah alright then. ;)
15:34:01 <Lemmih> The audio facilities in libSDL are pretty limited.
15:34:30 <humasect> mmm
15:34:35 <humasect> ok, great
15:40:36 <xerox> Goodnight people!
15:40:38 <xerox> http://haskell.galois.com/~paolo/more-Haskell-cairo-porn.png
15:40:44 <xerox> ^- check this out ! :-D
15:40:50 <humasect> looks good =)
15:41:10 <resiak> /msg $op xerox is a pronbot.
15:41:46 <Beelsebob> mmm... bush
15:58:52 <shapr> g'day moomlyn
15:59:13 <moomlyn> shapr: hi
15:59:15 <shapr> hey _gord, what do you think about the computational complexity of abstractions?
15:59:17 <shapr> moomlyn: How's code?
16:00:10 * shapr boings happily
16:00:30 <moomlyn> :)
16:00:53 <dcoutts> shapr, you've seen the latest cairo/gtk porn?
16:01:34 <Spark> :o
16:01:36 <Spark> url?
16:01:39 <dcoutts> http://haskell.galois.com/~paolo/more-Haskell-cairo-porn.png
16:01:47 <Spark> \o/
16:01:56 <Spark> phwoar
16:01:59 <Spark> *fap* *fap*
16:02:09 <dcoutts> and it's only like 75 lines of GUI code
16:02:09 <Beelsebob> I know... some bush ain't it
16:02:22 <dcoutts> heh :-)
16:02:37 * shapr looks
16:03:05 <shapr> Whoa cool, that's a CFDG editor, isn't it?
16:03:26 * dcoutts tries to decode the CFDG acronym
16:03:50 <dcoutts> context free DG?
16:04:22 <shapr> http://chriscoyne.com/cfdg/
16:05:19 <dcoutts> shapr, it's quite similar but not exactly the same
16:05:33 <dcoutts> it's based on L-Systems
16:05:54 <dcoutts> but the cfdg thing should be quite possible too
16:06:12 <basti_> its basically the same afaics
16:06:19 <dcoutts> and would look really nice using cairo for smooth rendering
16:06:42 <dcoutts> the cfdg has more controlable parameters
16:06:43 <Spark> is it just svg?
16:07:06 <dcoutts> Spark, no, but cairo will be getting an SVG backend some time soon
16:07:18 <dcoutts> @google cairo vector graphics
16:07:20 <lambdabot> http://www.cairographics.org/
16:07:21 <Spark> ah right
16:07:33 <dcoutts> cairo is an immediate drawing api
16:07:56 <humasect> tasty accell
16:08:02 <dcoutts> yeah
16:08:02 * Beelsebob wonders why have a quartz backend and an OpenGL one
16:08:14 <Beelsebob> surely putting quartz between them just slows it down
16:08:19 <dcoutts> for the best cross-platform support
16:08:23 <Spark> its like a 2d vector rendering library
16:08:30 <Beelsebob> but... why not just use GL on OS X
16:08:37 <dcoutts> and to integrate with stuff on OSX
16:08:48 <Beelsebob> quartz after all renders with GL
16:08:49 <Spark> maybe the quartz one came first
16:08:51 <dcoutts> so you can mix cairo and native on a single surface
16:09:00 <Beelsebob> hmm, that's true
16:09:03 <humasect> quartz = cairo =)
16:09:18 <Beelsebob> humasect: no, cairo can draw using quartz
16:09:36 <dcoutts> he's saying that quartz is a similar high level drawing api
16:09:40 <humasect> quartz can select opengl, software, etc
16:10:00 <Beelsebob> humasect: true... but it usually choses GL
16:10:17 <Beelsebob> on the grounds that it's faster on pretty much anything above a Rage128
16:10:34 <humasect> =)
16:10:55 <Beelsebob> can cairo do coreImage like post-processing?
16:11:02 <Beelsebob> or is that not on the cards?
16:11:08 <dcoutts> not sure what that is
16:11:19 <humasect> probably should
16:11:23 <dcoutts> url?
16:11:32 <Beelsebob> @google Tiger Core Image
16:11:33 <lambdabot> http://www.apple.com/macosx/features/coreimage/
16:11:44 <humasect> meow
16:12:08 <Beelsebob> it does things like the dashboard ripple effect
16:12:20 <Beelsebob> (well, that's coreVideo, but they're the same thing essentially)
16:12:46 <dcoutts> no, cairo does not expose that since it doesn't really fit the portable media idea
16:12:47 <humasect> stuff like pixel and color manip. hardware shaders in some places D:
16:13:03 <Beelsebob> portable media?
16:13:05 <dcoutts> eg you can't do that in a pdf or svg backend
16:13:12 <Beelsebob> you can...
16:13:18 <Beelsebob> certainly in PDF
16:13:22 <Beelsebob> (OS X does it)
16:13:24 <humasect> they aren't dynamic ;)
16:13:32 <Beelsebob> neither is CoreImage
16:13:41 <Beelsebob> coreVideo is... coreImage isn't
16:13:53 <humasect> i meant you can dump the pixels.
16:13:57 <humasect> it doesn't animate in a PDF.
16:13:58 <dcoutts> you can use pixelshaders in a pdf file?
16:14:04 <humasect> ~____~
16:14:08 <Beelsebob> you can apply them and then dump
16:14:19 <dcoutts> well yes
16:14:30 <dcoutts> though you loose the vectorness
16:14:34 <Beelsebob> no...
16:14:42 <Beelsebob> you shift your splines about
16:15:08 <dcoutts> it can certainly do the compositing operators mentined on that page
16:15:17 <Beelsebob> :)
16:15:26 <dcoutts> and all the afine transforms
16:15:43 <dcoutts> and the patterns
16:16:28 <dcoutts> but not the pixel oriented ones
16:16:42 <Beelsebob> k
16:16:48 <dcoutts> like blur etc
16:16:58 <Beelsebob> uhhuh
16:19:43 * Beelsebob prods lambdabot in the omega
16:19:48 <humasect> Setup.lhs is finding the cygwin gcc.
16:19:54 <shapr> heh
16:20:01 * shapr prods lambdabot in the beta
16:20:10 <lambdabot> Ow!
16:20:15 <Beelsebob> :o
16:20:41 <shapr> Pseudonym: hey, you think you'll have an article up in the next day or two?
16:20:54 <Pseudonym> Might do.
16:21:01 <Pseudonym> How many articles do we have?
16:21:33 <shapr> Oleg wrote one, I want to write a tutorial for testing with HUnit and QuickCheck. Philippa will probably have one.
16:21:37 <shapr> That's it.
16:22:04 <Pseudonym> Not so bad.
16:22:05 <Pseudonym> I
16:22:10 <Pseudonym> I shall try my hardest.
16:27:48 <shapr> Pseudonym: So shall I
16:29:20 <Beelsebob> damn...
16:29:33 * Beelsebob has been trying to confuse lambdabot into speaking here
16:29:37 <Beelsebob> but he's having none of it
16:30:23 <lambdabot> Silly human.
16:30:30 <Beelsebob> hehe
16:31:07 <Beelsebob> I was trying to trick it into starting a line with privmsg #haskell
16:34:36 <lambdabot> It's easier than you think.
16:34:47 <Beelsebob> probably
16:35:51 <Pseudonym> http://science.slashdot.org/article.pl?sid=05/08/30/2048236 <- Proof that FMT is needed!
16:36:00 <Pseudonym> Errr... FLM
16:38:45 <Pseudonym> Does lambdabot have a way to modify the administrator list at the moment?
16:38:50 <Pseudonym> Apart from the source code.
16:39:54 <shapr> I don't think lambdabot uses a config file yet.
16:40:38 <Pseudonym> No, but it does access databases.
16:41:23 <TheHunter> the administrator list is hard-wired in Config.hs.
16:42:08 * Pseudonym nods
16:42:39 <Pseudonym> Beelsebob: In case you couldn't tell, only administrators can do the hand-up-the-backside trick with lambdabot.
16:42:53 <lambdabot> Not true! I am sentient.
16:42:57 <Pseudonym> lambdabot: Shut up.
16:43:08 <Beelsebob> pseudonym: I'd guessed... but that doesn't stop me trying to break him
16:43:29 <Beelsebob> I assume you've seen what I was trying to do?
16:43:35 <Pseudonym> Nope.
16:43:41 <TheHunter> and becoming an administrator is as simple as /nick phubuh
16:43:44 <Pseudonym> But the easiest way is probably to submit an evil patch. :-)
16:43:49 <Pseudonym> Indeed.
16:44:09 <Pseudonym> The list of admins is right there in the darcs repo.
16:44:16 <Beelsebob> I was feeding him @echo commands that I was trying to get the character wrap to line up nicely
16:44:27 <Beelsebob> so that one of the things he said ended up bounced into here
16:45:17 <Pseudonym> When lambdabot gets admin commands which actually do something apart from privmsging, probably need to look at authenticating admins.
16:47:53 * Beelsebob left the chat room. (Read error: 105 (Connection reset by beer))
16:48:15 <shapr> :-P
16:48:33 <Beelsebob> :P
16:48:48 <shapr> Yeah, I thought about addin hostmask matching long ago, but never got to it.
16:48:58 <Beelsebob> :)
16:49:10 <Pseudonym> It's not like admins can actually do anything.
16:49:18 <lambdabot> Apart from this, of course.
16:49:20 <TheHunter> i guess using nickserv would be the way to go.
16:49:25 <Beelsebob> other than stick their hand up his arse
16:49:44 <lispy> Beelsebob: hehe, that's why i try to be an admin in every part of life
16:49:59 <lambdabot> That's a scary thought.
16:50:14 <Beelsebob> LISPY! I would have expected that from Philippa, but not you!
16:50:28 <Pseudonym> We're all open minded, surely?
16:52:29 <shapr> Being allowed to stick yer hand up someone's arse is a dubious privilege.
16:52:55 <Beelsebob> that's one way to look at it
16:53:02 <lispy> Beelsebob: hehe
16:53:26 <dcoutts> I know someone who does it for a living
16:53:32 <Beelsebob> Sibelius is fucking great
16:53:38 <Beelsebob> dcoutts: a doctor?
16:53:39 <dcoutts> mind you, that's cows and he's a vet
16:53:45 <Beelsebob> :)
16:53:51 <lispy> dcoutts: heh
16:54:01 <lispy> dcoutts: which war was he in?
16:54:06 <lispy> or she...
16:54:55 <dcoutts> one of the best quotes I ever heard was "every time my boyfriend makes love to me I remember that he's had his arm up the back side of a cow all day"
16:55:08 <Beelsebob> nice
16:55:10 <shapr> eewww
16:55:24 * shapr adds that to lambdabot's quote collection
16:55:34 <Beelsebob> well there's a good reason not to become a large animal vet
16:55:42 <Beelsebob> @quote
16:55:43 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly
16:55:43 <lambdabot> responsible for hastening the adoption of functional programming
16:55:43 <lambdabot> languages by providing a caricature of procedural OO.
16:59:17 <Beelsebob> I think the only foolproof design I've ever seen is the fool
17:00:21 <Philippa> I think the Darwin Awards prove you wrong there
17:00:40 <Beelsebob> nah... they're the best kind of fool
17:00:52 <Beelsebob> hmm... does that mean that if I now join as TheHunter_... then TheHunter get's kicked
17:01:09 <Pseudonym> Most fools don't kill themselves.
17:01:24 <Beelsebob> not all darwin awardies do
17:01:26 <Pseudonym> Most fools end up calling the helpdesk when you're working on it.  I am convinced of this.
17:02:07 <lispy> Pseudonym: heh
17:02:09 <Beelsebob> I thank the lord that I've never worked a help desk
17:02:17 <Beelsebob> and I don't even believe in him!
17:02:28 * Pseudonym worked a help desk for lawyers
17:02:41 <TheHunter> Beelsebob, no, i killed my old nick manually.
17:02:43 <Beelsebob> what kind of lawyer?
17:02:49 <Beelsebob> ah, okay
17:02:54 <Pseudonym> Public service lawyers.
17:02:57 <Pseudonym> Which is even worse.
17:03:13 <Beelsebob> wow, you must have got some pretty special people phoning up
17:03:19 <Pseudonym> http://www.cdpp.gov.au/ <- These guys
17:03:25 <TheHunter> While I'm at it - nickserv sucks because there's no way to kill a nick, change my nick to that nick and then identify with one single command.
17:03:35 <Beelsebob> or should I say thpethal?
17:03:51 <Pseudonym> TheHunter: That's what scriptable IRC clients are for.
17:03:58 <Pseudonym> Though testing the scripts are a bitch.
17:04:08 <Pseudonym> (Sorry, "is" a bitch.)
17:04:20 <lispy> TheHunter: yeah, and i think, you can't set nickserv to autokick those who forget to identify in x seconds
17:04:21 <Pseudonym> (If you must swear, use correct grammar!)
17:04:42 <Philippa> bollocks to that :-)
17:04:58 <Beelsebob> bollocks to what? correct grammar?
17:04:59 <TheHunter> yeah, i should have said xchat also sucks because it doesn't kick the user automatically, although it has some rudimentary nickserv support.
17:05:08 <Pseudonym> YM: "I say bollocks to that!"
17:05:12 <Pseudonym> Hope this helps!
17:05:21 <Beelsebob> don't you mean "that to bollocks"?
17:05:36 <Pseudonym> No, every sentence must a verb.
17:05:48 <lispy> verb it
17:05:58 <Beelsebob> you just did :)
17:06:20 <Philippa> verb in every sentence?
17:06:29 * shapr stabs gnu emacs with rusty spoon
17:06:30 <Pseudonym> Every sentence.
17:06:34 <Beelsebob> I aim to boldly bollocks as many gramars in one sentence as I can
17:06:36 <lispy> every verb must contain a sentence
17:07:04 <dcoutts> my personal favourite is "fewer grammar"
17:07:08 <Beelsebob> shapr: I did warn you a while ago about grammar
17:07:09 * lispy hands shapr extra spooons
17:07:17 <Beelsebob> and emacs too
17:07:22 * Beelsebob is confused
17:07:22 * shapr makes a rusty spoon pincushion out of gnu emacs
17:07:36 <Beelsebob> :) yay, no more emacs
17:07:44 <lispy> Long Live Yi!
17:07:53 <dcoutts> @cool add Yi
17:07:54 <lambdabot> Maybe you meant: code moo
17:07:54 <shapr> It's funny, xemacs crashed about once every three years. Gnu Emacs crashes about once every three days.
17:07:56 <lispy> or LLY for short
17:08:16 <lispy> shapr: are you using gnus?
17:09:03 <shapr> Yes I am.
17:09:38 <Beelsebob> My camera picks up too much orange
17:09:41 <lispy> shapr: in my experience that kills emacs more often than anything else
17:09:42 <shapr> Gnus, two erc connections, ghci, python, ielm, and more
17:09:48 <Beelsebob> pretty as that is sometimes it's most annoying
17:10:08 <shapr> lispy: Seems to do with too many external processes or something. I think it's a locking problem.
17:10:25 <lispy> shapr: it wouldn't surprise me
17:10:39 <lispy> shapr: could be related to external processes + gc
17:12:59 <Beelsebob> go go Andy Murray
17:13:32 <Beelsebob> bloody hell... so ill he was vomiting on court... but still won
17:15:57 <lispy> shapr: lately i use emacs for haskell and irc only
17:16:08 <Pseudonym> http://www.stopclownpornnow.org/
17:16:14 <lispy> shapr: i've been using XCode on the OSX for development in the languages it supports
17:16:27 <lispy> Pseudonym: sfw?
17:16:35 <shapr> We need Yi!
17:16:39 * shapr hugs Yi
17:16:42 <Pseudonym> lispy: Nothing really.
17:16:48 <shapr> I've got to hack on Yi
17:17:14 <lispy> i'm starting to see the light of using a big project navigator style IDE
17:17:18 <Beelsebob> lispy: you like XCode's editor, but not SEE's?
17:17:21 <lispy> that's something emacs sucks at unfortunately
17:17:35 <Beelsebob> ah, that makes sense
17:17:42 <lispy> Beelsebob: Xcode is free as in beer and already installed.  But I don't use it for the editor that much
17:17:48 <metaperl> lispy: have you seen ECB.sf.net?
17:17:57 <lispy> metaperl: kinda
17:17:58 <metaperl> the emacs code browser
17:18:04 <lispy> metaperl: but i haven't really played with it
17:18:07 <Beelsebob> lispy: SEE is free as in beer if it's for non-comertial purposes
17:18:12 <metaperl> i still would like to try the xemacs window manager
17:18:33 <lispy> Beelsebob: but it's _just_ the editor right?
17:18:40 <Beelsebob> yep
17:18:41 <Beelsebob> true
17:19:07 <lispy> grep -rn foo * is okay, but sometimes having a project navigator is better
17:21:02 <lispy> i wish it was obvious how make a darcs plugin for xcode
17:21:12 <lispy> but, apple hasn't released the plugin api
17:21:26 <Beelsebob> I know
17:21:31 <lispy> and they only support Cvs (eww), svn (meh), and Perforce( eh?)
17:22:17 <Beelsebob> radr://4235116
17:22:56 <Beelsebob> submit another bug, and they'll pay more attention
17:23:04 <lispy> eh?
17:23:17 <Beelsebob> bugreport.apple.com
17:23:28 <Beelsebob> bugID 4235116 is XCode darcs support
17:23:45 <Beelsebob> (or lack of)
17:24:14 <Beelsebob> the more dupes they get the more attention they pay
17:24:24 <lispy> cool, time to write a script
17:24:27 <Beelsebob> haha
17:24:35 <Beelsebob> I think it needs them from different people
17:24:48 <lispy> i don't have an applid
17:24:57 <Beelsebob> then get one... they're useful
17:24:58 <lispy> maybe i should get one some time
17:25:11 <lispy> is it free to upgrade to xcode2.1?
17:25:19 <Beelsebob> if you have an apple ID, yes
17:26:19 <lispy> i found a way to crash xcode 2.0
17:26:24 <Beelsebob> :)
17:26:26 <lispy> so it will be nice to upgrade
17:26:28 <Beelsebob> bugreport.apple.com
17:26:34 <lispy> it autoreported
17:26:37 <Beelsebob> cool
17:26:50 <Beelsebob> you're lucky you never experienced XCode 1
17:26:53 <Beelsebob> it was a nightmare
17:26:55 <lispy> ;)
17:27:25 <lispy> Beelsebob: have you seen this? http://www.cocoadev.com/index.pl?XcodePlugin
17:27:42 <lispy> that guy reverse engineered enough of the xcode api to make an ocaml plugin
17:27:59 <lispy> probably turn it into a haskell plugin without too much work
17:28:07 <Beelsebob> cool!
17:28:11 <Beelsebob> indeed
17:28:30 <Beelsebob> I think I might scrap X gallon hat
17:28:35 <Beelsebob> and just integrate into XCode
17:29:31 <lispy> x gallon hat?
17:29:35 <lispy> oh
17:29:47 <lispy> integrate hat into xcode, that would be nice
17:29:52 <Beelsebob> indeed
17:29:57 <Beelsebob> once there was haskell support
17:30:17 <Beelsebob> and if you added HOC to that it would make one hella nice dev suite
17:30:27 <lispy> HOC?
17:30:42 <lispy> Beelsebob: and what if SEE could be the editor! ;)
17:31:38 <Beelsebob> Haskell Objective C bridge
17:31:47 <Beelsebob> so you can write Cocoa in haskell
17:31:52 <metaperl> someone please try this for me:  darcs get http://www.gimblerus.com
17:31:52 <lispy> ah
17:32:02 <Beelsebob> and I like the XCode editor, so I'd be happy with that
17:32:11 <Beelsebob> and SEE *can* be the editor when you use XCode
17:32:43 <dave_m> a link between Haskell and the Open Scripting Architecture (which includes AppleScript) would be nice
17:33:54 <Beelsebob> yeh, that too
17:34:09 <Beelsebob> esspecially if it included ASS
17:34:19 <Beelsebob> (the worlds worst acronym ever)
17:35:26 <dave_m> you do wonder if anyone saw that before they released it
17:35:33 <Beelsebob> hehe
17:35:50 <Beelsebob> probably someone deliberately constructed it
17:35:59 <Beelsebob> and then did their best to sneak it past mr jobs
17:40:44 <lispy> Beelsebob: i'd feel a lot better about using xcode if it were open source
17:40:50 <lispy> there is eclipse, but god, i hate that thing
17:41:03 <Beelsebob> lispy: so would I... but unfortunately not to be
17:41:16 <Khisanth> why? are you finding problems with xcode?
17:41:26 <Beelsebob> they crop up
17:41:31 <Beelsebob> quite commonly
17:41:48 <Beelsebob> and as well as that, it's just nicer
17:41:48 <humasect> @quote
17:41:49 <lambdabot> autrijus says: Well, ever since the monadic revolution of '98
17:41:49 <lambdabot> Haskell people have started to do real world apps
17:42:02 <dave_m> as long as the document format is standard, there isn't much danger of using closed apps like xcode
17:42:09 <lispy> Khisanth: no support for darcs, no support for haskell and there are some bugs (I made v2.0 crash reliably)
17:42:10 <dave_m> danger in terms of lock-in, that is
17:42:30 <Beelsebob> right... night... mmm... bed
17:42:57 <lispy> dave_m: yeah, that's another thing, if i want to do unix programming in Xcode, how do i generate makefiles for other platforms
17:43:54 <dave_m> lispy: not a clue, I'm afraid. I don't use it, myself
17:45:11 <lispy> dave_m: ah, it was mostly rhetorical
17:45:22 <lispy> i see some nice looking editors
17:45:26 <lispy> but i want more than an editor
17:45:32 <lispy> guess i should try ECB again
17:45:32 <humasect> Lemmih sure has been busy.
17:45:42 <Lemmih> I have?
17:46:40 <humasect> keep up the good work on good haskell things =)
17:47:38 <Lemmih> (:
17:47:59 <humasect> ^_^
17:48:08 <lispy> anyone tried Anjuta ?
17:48:32 <lispy> it's meant for c/c++ but it seems to have promise feature wise
17:48:39 <humasect> sdl core + mixer installed and most likely working. here we go~~
17:56:00 <humasect> not able to use ghci with it.
17:56:11 <Lemmih> How so?
17:57:05 <humasect> "Loading package SDL-0.2.0 ... can't load .so/.DLL for: SDLmain (addDLL: unknown error)" -- looking around in various paths.
17:57:17 <humasect> yeah, that's not a dll.
17:58:29 * metaperl is HUNGRY. time for potatoes
17:58:51 <humasect> ok, fixed.
17:59:02 <humasect> because -lSDLmain was added in ld-options:
18:00:03 <humasect> ok i think i can help myself for a while and get somewhere from here =) thank you Lemmih
18:00:12 <humasect> (i'll quiet)
18:00:39 <Lemmih> Hi musasabi.
18:08:55 <Pseudonym> Mmmm... free cakes.
18:09:38 <dons> Pseudonym seems to get free cake with startling regularity
18:10:37 <stefanw> dons: you missed to meeting yesterday, free cakes there as well ;-)
18:10:49 <dons> doh!
18:11:25 <Pseudonym> Every week, yes.
18:11:45 <Pseudonym> There are very few benefits of working here, but this is one of them.
18:15:35 * Igloo discovers he's forgotten all the vaguely complex SQL he once knew
18:27:47 * Lemmih throws angry lambda's at Data.Map.
18:28:01 <autrijus> what's wrong with Map?
18:28:15 <autrijus> you want Data.Territory instead and Data.Map isn't it?
18:28:21 <Lemmih> No Set/Map intersection functions.
18:28:30 <autrijus> (\\) isn't it?
18:28:50 <Lemmih> That's Map/Map intersection.
18:29:11 <dons> autrijus, does pugs used packed strings?
18:29:11 <autrijus> mm, cast with keysSet?
18:29:12 <liyang> Isn't that `difference`...?
18:29:27 <Lemmih> liyang: Oh right.
18:29:52 <autrijus> dons: not currently, but for the new runcore, yes I'm using UTF8 PackedString
18:30:02 <Lemmih> autrijus: Converting to a list and then a set is slow.
18:30:20 <autrijus> indeed
18:30:36 <autrijus> dons: I'm using the version marked with
18:30:36 <autrijus> -- modified by John Meacham for use in ginsu
18:30:56 <autrijus> however DrIFT's (deriving Binary) doesn't seem to like that
18:31:01 <autrijus> I mean deriving GhcBinary
18:31:19 <dons> oh, that answers my next question..
18:31:45 * Lemmih wil use a Map with undefined values.
18:32:23 * liyang concurs with autrijus. Why not just use Map.keySet? It's O(n).
18:32:51 <Lemmih> liyang: Because it should be an O(1) operation.
18:33:55 <TheHunter> you mean O(n+m) ?
18:34:03 <autrijus> n+m is better than n?
18:34:05 <liyang> But your intersection operation's going to overwhelm that anyway.
18:34:50 <TheHunter> i'm only seeing a O(n+m*log m) solution.
18:35:33 <TheHunter> oh, O(n+m) using fromAscList.
18:38:09 <Lemmih> Using a Map with undefined values allows me to avoid the keysSet call completely.
18:38:13 <Pseudonym> Of course, in Haskell, every operation is O(1).
18:38:19 <Pseudonym> Printing the answer takes longer, though.
18:38:44 <Pseudonym> Unless you use seq, I suppose.
18:39:13 <TheHunter> are you only interested in the resulting set?
18:39:18 <TheHunter> *Set.
18:41:40 <Lemmih> Yes.
18:42:57 <liyang> (Set a is just Map a () isn't it...)
18:43:22 <TheHunter> @libsrc Data.Set
18:43:23 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Set.hs
18:43:38 <TheHunter> no.
18:44:10 <liyang> Hm. Nevermind then.
18:44:53 <TheHunter> the old Data.Set was a newtyped FiniteMap, iirc.
18:45:25 <liyang> It wouldn't have mattered anyway. Damn that encapsulation. <g>
18:45:27 * Lemmih will copy Data.{Set|Map} and distribute it with his program.
18:46:21 * autrijus mumbles something about the tendency of bundling lots of libraries with every program
18:46:47 * TheHunter wonders why the keys in Data.Map are strict, but aren't in Data.Set.
18:48:49 <TheHunter> the right thing to do would be to just export the Map and Set constructors.
18:49:12 <dave_m> then you can't guarantee their invariants
18:49:23 <TheHunter> they aren't guarenteed anyways.
18:49:23 <autrijus> ...and kill encapsulation with it?
18:49:32 <TheHunter> fromDistinctAscList
18:49:38 <TheHunter> bogus Ord instances
18:50:16 <dave_m> well, if you're using a bogus Ord instance, you can't complain if something bad happens
18:51:00 <TheHunter> if you using the data cronstructors explicitely, you shouldn't either, but you should at least be allowed to if you know what you're doing.
18:51:12 <TheHunter> possibly in a module Data.Map.Internals.
18:51:59 <TheHunter> my point is, you can't reasonably anticipate all use-cases in such a library.
18:52:52 <TheHunter> and it's better to export internals than if everybody is distributing their own version of these libs.
18:53:19 <dave_m> that's true. On the other hand, I don't think it's possible to do better than O(n) for Map -> Set conversions
18:53:57 <TheHunter> that there is no Set -> Map function is an unfortunate oversight.
18:54:00 <Lemmih> I don't want a Map -> Set conversion.
18:54:21 <dave_m> what would a Set -> Map function look like?
18:54:45 <TheHunter> toMap :: Set a -> Map a ()
18:54:50 <TheHunter> toMap :: Set a -> Map a b ?
18:55:25 <liyang> (a -> b) -> Set a -> Map a b
18:55:40 <dave_m> there's nothing useful you could do with those that doesn't involve mapping every element of the range
18:55:49 <TheHunter> or else separate union- difference-, ..With, ..By-functions would need to be provided
18:56:14 <TheHunter> maybe not ..By.
18:56:57 <dave_m> none of which is to say that the Data.Map and Data.Set interfaces have everything you need, of course
18:58:13 <TheHunter> maybe someone needs monadic equivalents of some of the Data.Map/Set functions.
19:35:26 <Lemmih> Copied 2770 lines, added 7 and 'intersectSet' is born.
19:35:47 <humasect> :|
19:39:38 <Lemmih> No HWN this week?
19:44:06 <humasect> @lookup when
19:44:07 <lambdabot> Unknown command, try @listcommands.
19:44:40 <Cale> It's in Monad
19:44:47 <humasect> thanks ^_^
19:57:01 <humasect> what is common for building a list, the reverse of "something (x:xs) = something xs" to break it apart
19:57:07 <humasect> +?
19:57:21 <Cale> er, :
19:57:24 <Cale> and ++
19:57:37 <Cale> @eval 1 : [2,3,4,5]
19:57:43 <lambdabot> [1,2,3,4,5]
19:57:50 <Cale> @eval [0,1] ++ [2,3,4,5]
19:57:52 <lambdabot> [0,1,2,3,4,5]
19:58:01 <humasect> ah yes i see, thanks
19:58:39 <humasect> hurrah
20:00:50 <TheHunter> Cale, i got an interesting problem, wanna hear it?
20:00:57 <Cale> TheHunter: sure
20:01:19 <TheHunter> maybe you already read it in the scrollback.
20:01:49 <TheHunter> we know that each polymorphic function between Functors is a natural transformation because of parametricity
20:02:28 <TheHunter> the question is if the converse is true, i.e. if every natural transformation between Functors can be defined parametrically.
20:03:05 <Cale> hmm
20:03:15 <TheHunter> we already know every such function is 'generic'.
20:03:19 <Cale> every computable one?
20:03:41 <TheHunter> i guess.
20:04:11 <TheHunter> i think if we allowed not computable functions and not computable primitives, it would be ok, too.
20:04:40 <TheHunter> the question not that clearly defined, although i realize it might be important.
20:05:18 <TheHunter> my conjecture is that every such function is indeed parametric, but I have no idea how one might prove such a thing.
20:05:44 <Cale> Well, hmm...
20:09:07 <Cale> Given a functor eta: F -> G, for every map f: X -> Y, we need that eta . map f = map f . eta
20:09:21 <Cale> er
20:09:27 <Cale> for every function f: X -> Y
20:09:37 <Cale> I used "map" carelessly there :)
20:10:41 <Cale> What is the formal definition of parametricity?
20:11:17 <TheHunter> for all I know, "there exists an haskell function that implements the given function."
20:12:27 <Cale> ah
20:12:28 <TheHunter> if we define the natural transformation on a 'universal' type, it is actually already determined for all types.
20:12:30 <Cale> okay
20:12:50 <TheHunter> but not in a parametric way.
20:13:06 <Cale> consider a natural transformation eta : [] -> []
20:13:24 <Cale> Lists are permitted to be infinite
20:13:46 <TheHunter> yes or no, pick one.
20:13:51 <Cale> yes
20:15:41 <Cale> Define a (mathematical) function based on a permutation pi in Sym(Naturals) called f formally as the function such that if xs is finite, then f xs = xs, and if f xs is infinite, it applies the permutation pi to the list.
20:16:06 <Cale> There are more permutations in Sym(Naturals) than there are Haskell programs.
20:16:23 <Cale> For any permutation in Sym(N), f is a natural transformation on lists
20:16:58 <TheHunter> that's cheating.
20:17:06 <Cale> (I think all of them are uncomputable anyway)
20:17:20 <Cale> since you have to solve the halting problem to know if xs is finite
20:17:50 <TheHunter> well, we could assume a primitive solveHaltingProblem :: TM -> Bool.
20:18:06 <Cale> even with it, we can't express them all as Haskell programs
20:18:16 <Cale> only countably many will be definable
20:18:39 <TheHunter> i allow arbitrary functions as primitives.
20:18:58 <Cale> oh, then certainly every natural transformation is there :)
20:19:22 <TheHunter> not necessarily.
20:19:30 <Cale> if we're allowed uncountably many primitives
20:19:49 <TheHunter> but the primitives are all monomorphic.
20:19:54 <Cale> then we can do all the natural transformations on lists, most likely
20:20:29 <rasfar> Is the number of valid Haskell programs really countable?
20:20:37 <Cale> rasfar: certainly
20:20:44 <Cale> rasfar: that or finite
20:21:03 <rasfar> But ... there is no hard bound on the size...
20:21:06 <TheHunter> i believe all natural transformations [] -> [] are parametric.
20:21:07 <Cale> right
20:21:31 <Cale> TheHunter: I think most of them are inexpressible in actual Haskell.
20:21:46 <Cale> and many are uncomputable
20:22:48 <rasfar> Must a Haskell program be finite to be valid? (Sorry if this is redundant, I just got in)
20:23:02 <Cale> rasfar: well, I think so :)
20:23:10 <TheHunter> Cale, are all of them 'permutations'?
20:23:31 <Cale> TheHunter: well, they're rearrangements of various sorts
20:23:36 <Cale> you can delete items as well
20:23:39 <Cale> or copy them
20:23:42 <TheHunter> true.
20:24:36 <Cale> basically, they're given by the union over ordinals k up to and including omega, of the set of functions k -> k
20:24:37 <Cale> I think
20:24:55 <Cale> There might be some extras if you want to consider _|_
20:25:16 <Cale> er
20:25:22 <Cale> no
20:25:36 <TheHunter> ok, so they're all expressable in Haskell+arbitrary primitives.
20:25:51 <Cale> they're given by the union over ordinals k, l <= omega, of the set of functions k -> l
20:26:04 <TheHunter> yep.
20:26:22 <Cale> hmm...
20:26:25 <Cale> or...
20:26:45 <Cale> well, hmm... there may be more
20:28:00 <TheHunter> that's the question.
20:28:07 <Cale> if it could do something astounding with the values involved in each type
20:28:15 <Cale> that it was applied to
20:28:27 <Cale> then it may me able to modify the elements of the lists
20:28:30 <Cale> be*
20:28:50 <Cale> hmm...
20:28:54 <Cale> no, I really doubt it
20:29:13 <Cale> since the square has to commute for every function f: X -> Y
20:31:08 <TheHunter> i doubt it also.
20:34:13 <Cale> ah
20:34:33 <Cale> yeah, at least for natural transformations [] -> [], it's not possible
20:34:42 <Cale> since you can just look at the first elements of the lists
20:35:03 <Cale> well, hmm...
20:35:10 <Cale> oh
20:35:19 <Cale> no, it is possible at least in one stupid way
20:36:29 <TheHunter> yes?
20:36:34 <Cale> it could take a choice function on the set of all types, choosing a single value from every type, and when it is, say applied to a list of values of that type, it replaces the list with the list [chosen values for that type]
20:36:45 <Cale> er chosen value*
20:37:13 <Cale> like, for each nonempty type X, choose a value v_X
20:37:35 <Cale> then eta_X : [X] -> [X] by eta xs = [v_X]
20:38:06 <TheHunter> what about f = const v'_X where v'_X /= v_X ?
20:38:54 <Cale> ah... good :) that doesn't work
20:39:05 <Cale> I wouldn't really want it to anyway :)
20:39:11 <Cale> okay
20:39:36 <TheHunter> i've been fooled many times by such examples, too.
20:39:46 <Cale> and since there is a type with only one value, and a type with more than one value, we'll always be able to check if it's being insincere :)
20:41:31 <humasect> oh how i love haskell
20:41:48 <lispy_> humasect: the feeling is mutual
20:41:49 <lispy_> ;)
20:42:09 <Korollary_> has anyone here ever played with F# ?
20:42:16 <humasect> :D
20:42:29 <humasect> i played with F#
20:43:05 <rasfar> I think the number of finite binary trees is uncountable, but I can't find a proof and I don't remember how to prove it.  Can anyone confirm?
20:43:38 <Cale> eta_() can't mess with the value (), and for every other value in every other type Y, there's a mapping const v :: () -> Y, and eta is forced to commute on those
20:43:45 <TheHunter> rasfar, it's definitely countable.
20:43:54 <rasfar> ooo-kay...
20:44:01 <Cale> rasfar: definitely countable
20:44:19 <Cale> rasfar: you can encode them as natural numbers.
20:44:59 <rasfar> Rather than appear as foolish as I am, I'll research more on this...
20:47:22 <Cale> rasfar: in fact, the set of all finite graphs is countable -- you can encode each one using its adjacency matrix: take the product over i,j such that a_ij = 1 of p_(i*n + j), where n is the number of vertices in the graph and p_k is the kth prime.
20:47:42 <TheHunter> Cale, yeah, i think something along those lines proves it.
20:47:47 <Cale> where a_ij is the i,j entry in the adjacency matrix
20:48:27 <TheHunter> replace () with n, and start from the result of eta [0,...,n-1].
20:49:10 <TheHunter> weird, that seems so simple now.
20:50:10 <lispy_> what is eta?
20:50:18 <lispy_> like lambda calc definition?
20:50:29 <TheHunter> eta is a natural transformation between lists.
20:50:34 <Cale> http://en.wikipedia.org/wiki/Natural_transformation
20:50:56 <lispy_> thanks, looking
20:51:24 <TheHunter> ok, that probably generalizes to polynomial functors.
20:52:02 <Cale> yeah, I think so too
20:53:13 <TheHunter> i'm really beginning to doubt Frank had a specific nat. trans. in mind in this post: http://www.haskell.org/pipermail/haskell-cafe/2004-July/006346.html
20:53:17 <Cale> I think it basically comes down to the point where eta is only allowed to affect the part of the functor which isn't given by the type parameter.
20:54:15 <Cale> oh
20:54:23 <Cale> hmm...
20:56:21 <Cale> we should also be careful in that not all functors are Haskell functors.
20:57:06 <Cale> well, I don't think so anyway
20:57:26 <TheHunter> ok, but then the question becomes sort of pointless.
20:57:32 <Cale> yeah
20:57:35 <Cale> I suppose so :)
20:58:07 <rasfar> I think the set of all finite polyominoes is uncountable ... and they have a natural graph representation.  (Am I being annoying yet??)
20:58:30 <Cale> rasfar: not uncountable
20:59:39 --- topic: '["logs: http://meme.b9.com/cview.html?channel=haskell&date=today","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFour","We put the Funk in Funktion","http://sequence.complete.org/hwn/20050823"]'
20:59:39 --- topic: set by CosmicRay on [Tue Aug 23 07:37:02 2005]
20:59:39 --- names: list (clog jewel eno-away_ gdsx marcot takuan jiing_ ulfdoz tromp yosemite jwp Revision17 TheHunter borism noj SamB nibro dcoutts tumm cjb lispy_ musasabi binary42 rafl_ timbod_ ibid pesco ctrlsoft lisppaste2 psi humasect Nioate_ wilx mikael jesse99 Lemmih geoffb sylvan rasfar mornfall Matt-W tessier frederik jiing johs araujo vegai Lor noclouds reppie[^_^] norpan earthy mflux Korollary_ resiak booyaa)
20:59:48 <lispy_> rasfar: cartesian products of countable sets are countale
20:59:50 <rasfar> s/) finite/ finite)/ :)
21:00:00 <lispy_> well, finite number of cartesian products
21:00:12 <rasfar> Yes, but the power set of a countable set is uncountable.
21:00:17 <Pseudonym> Subsets of countable sets are countable.
21:00:17 <Cale> argh :)
21:00:21 <Cale> rasfar: the power set sure
21:00:31 <Cale> of a countably infinite set
21:00:38 <Pseudonym> And the cells on an infinite cartesian lattice are countable.
21:00:42 <lispy_> god
21:00:54 <Cale> wtf
21:01:09 <Pseudonym> Anyone want to adjourn to efnet?  Just kidding.
21:01:10 <rasfar> And the number of finite subsets of a countable set? I suppose that's countable?
21:01:19 <Cale> I've been on EFNet for several days now with no trouble :)
21:01:22 * lispy_ isn't sure if he's connected
21:01:24 <lispy_> hello?
21:01:26 <lispy_> ah
21:01:27 <Cale> you are
21:01:28 <lispy_> Pseudonym: oftc is looking good tho
21:01:30 <rasfar> I hear you _lispy
21:01:38 <Pseudonym> rasfar: Yes, FINITE subsets are countable.
21:01:39 <rasfar> lispy_, sorry
21:01:43 <Korollary_> holy splitting monad
21:01:44 <TheHunter> how bout OFTC?
21:01:57 <Cale> rasfar: finite subsets of a countable set are countable.
21:01:58 <Pseudonym> It'll be fixed in a moment.
21:01:59 <Pseudonym> Or an hour.
21:02:04 <Pseudonym> Either way, it'll be fixed.
21:02:21 <lispy_> rasfar: if you took a infinite countable subset of a countable set and took the powerset then that would be uncountable
21:02:24 <Cale> rasfar: to see this, it suffices to show that finite subsets of N are countable.
21:02:38 <lispy_> Pseudonym: it's been more than just today tho
21:02:58 <rasfar> lispy_: yes of course, i agree
21:03:05 <rasfar> Cale: yeah I know that also...
21:03:20 <Cale> rasfar: let S be a finite subset of N. Take product over n in S of p_n, where p_0 = 2, p_1 = 3, and p_n is the nth prime in that fashion.
21:03:38 <Cale> This is an injection from the finite subsets of N into N.
21:03:49 <rasfar> (I like these proofs using the prime sequence ... trying to grok...)
21:04:06 <Cale> it's just a handy way to encode things :)
21:04:15 <lispy_> rasfar: well, it just uses the idea that naturals are either 1, prime or a product of primes
21:04:30 <rasfar> hmmm....
21:04:32 <Cale> or 0 :)
21:04:34 <lispy_> actually, maybe you don't need to even realizethat
21:04:41 <lispy_> Cale: depends on your naturals :)
21:04:44 <Cale> yeah
21:04:49 <lispy_> i don't include 0 in nats
21:04:54 <Cale> ugh :) hehe
21:04:55 <lispy_> but, that's just my convention :)
21:05:17 <rasfar> I don't either, but I do tire of writing N _union_ {0}
21:05:21 <TheHunter> kosmikus, you might be interested in the scrollback before the big netsplits.
21:05:29 <Cale> I usually find that having the naturals correspond to the sizes of finite sets to be what is needed
21:05:55 <lispy_> Cale: i could see tha
21:06:03 <Pseudonym> A simple fix for this would be to donate a server to OpenProjects.  All you need to do is get a high bandwidth server and give some stranger root access to it.
21:06:06 <Pseudonym> Sounds simple enough.
21:06:50 <Korollary_> isn't it time for a new irc protocol as well ?
21:07:01 <lispy_> i feel like lilo is going to drastic measures to solve a non-problem
21:07:14 <lispy_> Korollary_: probably couldn't hurt :)
21:07:23 <Pseudonym> Can you do something like IRC using Jabber?
21:07:39 <Korollary_> Jabber already has chat rooms, iirc
21:07:51 <lispy_> there is bitlbee
21:07:59 <lispy_> it turns IM protocols into irc
21:09:05 <Cale> lispy_: lilo has been known to do that :)
21:10:37 <Cale> I'd prefer it if #haskell remain somewhere on IRC :)
21:11:40 <lispy_> well, there is oftc, but i don't know anything about that server
21:11:48 <Korollary_> how about a distributed IDE project where millions of developers hack on code simultaneously for Apache v 11.8
21:11:51 <lispy_> and most of the people i know are here
21:12:03 <lispy_> Korollary_: sure
21:12:08 <lispy_> Korollary_: doesn't sound confusing
21:13:05 <Korollary_> needs voice over ip and tablet support for white board sharing
21:13:59 <Korollary_> and be built by NeoDatex :)
21:14:02 <lispy_> could you imagine having 1,000,000 devs on the same project?
21:14:33 <lispy_> you'd have 0 features after arguing for 8 years how to declare variables
21:15:00 <lispy_> too bad code isn't more like an encyclopedia
21:15:10 <lispy_> we could have wikiIDE
21:16:42 <Cale> lispy_: that, or one module would get written and then 999999 interfaces abstracting it somehow.
21:16:54 <rasfar> I see, finally *blush*, thanks.
21:17:13 <lispy_> Cale: yeah :)
21:17:43 <Cale> (most of the interfaces would never be finished)
21:17:55 <lispy_> and then all the interface writers would post on their blog why the other interfaces suck
21:18:09 <Cale> yeah :)
21:19:21 <Korollary_> such a project would fork O(N) times
21:20:24 <Cale> @eval [ceiling (exp ((n-1) / 2)) | n <- [1..9]]
21:20:25 <lambdabot> [1,2,3,5,8,13,21,34,55]
21:20:42 <Cale> @eval [ceiling (exp ((n-1) / 2)) | n <- [0..10]]
21:20:44 <lambdabot> [1,1,2,3,5,8,13,21,34,55,91]
21:20:47 <Cale> hehe
21:21:20 <Cale> not quite the Fibonacci sequence :)
21:22:03 <Korollary_> how is eval done in lambdabot ?
21:22:09 <Cale> hs-plugins
21:22:13 <Korollary_> ah
21:22:15 <Cale> it uses runplugs
21:23:21 <Korollary_> what is a good way of evaluating a runtime determined string such as "1+2*3" ?
21:23:39 <Cale> hs-plugins :) or do you mean something simpler?
21:23:46 <Korollary_> other than running another haskell program
21:24:01 <Cale> oh, hs-plugins has eval
21:24:06 <Lemmih> Use the GHC package and compile it to bytecode.
21:24:14 <Korollary_> that sounds good
21:24:36 <Cale> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html#node_sec_7
21:24:56 <Korollary_> I guess I could also represent the expr using a grammar
21:25:03 <Korollary_> and have it evaluate itself
21:25:14 <Cale> yeah, you could parse it with parsec even :)
21:25:27 <Korollary_> I just needed to construct it
21:26:05 <Korollary_> since I couldnt easily figure out how to deal with precedence, I just printed it out and had python eval() it.
21:26:07 <Cale> of course, if you're allowed to use an algebraic datatype rather than a string, it's even easier :)
21:27:10 <TheHunter> oh, lambdabot has that thing again where it doesn't respond.
21:27:20 <Korollary_> @yow
21:27:22 <lambdabot> My haircut is totally traditional!
21:27:38 <TheHunter> try to pm lambdabot.
21:27:55 <TheHunter> (it's of course freenode's fault)
21:27:56 <Cale> yeah, it doesn't seem to reply at the moment
21:27:57 <Korollary_> hmm, I've been /ignored
21:28:50 <lispy_> what do you pm lambdabot with?
21:28:58 <lispy_>  /msg lambdabot @vixen ?
21:28:59 <TheHunter> unidentified spammers can't spam via privmsgs any more, but they are free to spam channels?
21:29:13 <TheHunter> that or /query lambdabot
21:30:04 <lispy_> ah
21:30:08 <lispy_> lame
21:30:17 <lispy_> that makes /msg useless
21:30:31 <Korollary_> we cant pm each other either ?
21:30:45 <Korollary_> ugh
21:30:49 <lispy_> Unregistered users cannot currently send private messages due to spambot problems. please register! ( http://freenode.net/faq.shtml#nicksetup )
21:30:56 <TheHunter> if you aren't identified, nobody gets your messages.
21:31:03 <lispy_> yeah, it's lame
21:31:06 <Korollary_> I'm not
21:31:33 <spiffy> hi, im learning haskell, following the 'Yet another haskell tutorial'. when trying to use things like filter Char.isLower "Lowercase", hugs gives me an error
21:31:43 <spiffy> stating...
21:32:08 <spiffy> ERROR - Undefined qualified variable "Char.isLower"
21:32:15 <lispy_> @eval filter Char.isLower "Lowercase"
21:32:17 <lambdabot> "owercase"
21:32:29 <lispy_> hmm....
21:32:41 <spiffy> thats what i expect from the code sample in the tutorial
21:32:44 <lispy_> spiffy: are you using the interpreter or in afile?
21:32:54 <spiffy> interpreter
21:32:55 <rasfar> You need to :l Char first?
21:33:11 <rasfar> Then, filter isLower "Lowercase"
21:33:24 <spiffy> that works
21:33:31 <rasfar> yay!
21:33:35 <spiffy> thanks, but what did I just do exactly? load the char package?
21:33:44 <rasfar> yup
21:34:01 <spiffy> works for me
21:34:02 <lispy_> spiffy: had you been working in a file you would have added the line "import Char"
21:34:05 <rasfar> It seems strange it isn't in the Prelude, but that is the case.
21:34:21 <spiffy> ok, well makes sense to me.
21:34:41 <spiffy> Does hugs not like/support using what im guessing is the fully qualified formed Char.isLower?
21:34:59 <rasfar> I'm wondering that too.
21:35:00 <lispy_> i agree tho, that the prelude should either export everything in haskell98 or nothing in haksell98 instead of some of it
21:35:29 <Korollary_> THe prelude does not export isLower per the standard
21:36:11 <spiffy> prelude is the base language module?
21:36:34 <rasfar> Actually, it seems you don't need :l Char, as long as you *don't* use the fully-qualified name Char.isLower...
21:37:13 <Korollary_> Prelude is a standard module just like Char. However, Prelude is the only module that is always imported.
21:37:22 <spiffy> ah I see
21:37:47 <spiffy> @eval filter isLower "Lowercase"
21:37:49 <lambdabot> "owercase"
21:38:17 <rasfar> @eval filter Char.isLower "Lowercfase"
21:38:18 <lambdabot> "owercfase"
21:38:24 <rasfar> hmmm...
21:38:24 <spiffy> now for me it raises an error when just in 'Prelude' (freshly loaded copy of hugs)
21:39:39 <spiffy> Hugs.Base> filter isLower "lowercase"
21:39:39 <spiffy> ERROR - Undefined variable "isLower"
21:39:54 <Korollary_> same in ghci here. I use ":module Char" and my prompt changes to "Prelude Char>" where isLower 'a' works
21:41:19 <rasfar> :Prelude> :names isLower
21:41:25 <rasfar> Hugs.Prelude.isLower
21:41:47 <rasfar> wtf?
21:42:53 <humasect> can list comprehensions be used as mapM_/sequence_ ?
21:43:38 <lispy_> humasect: a comprehension generates a list
21:43:41 <autrijus> humasect: sequence_ [ ... | ... ]
21:43:50 <humasect> woo ^_^
21:44:01 <lispy_> or do you want to use a list comp in place of mapM_+
21:44:08 <humasect> yeah.
21:44:25 <humasect> sequence_ makes it similar to using mapM_ in the first place. list comps are pretty though
21:45:48 <lispy_> list comps are nice
21:46:01 <lispy_> and implemented with monads
21:46:16 <humasect> hmm..
21:47:25 <Cale> they could be implemented with monads :)
21:47:36 <Cale> I wish they were, and we had monad comprehensions
21:48:28 <humasect> yum
21:49:07 <lispy_> Cale: ah, i misremembered
22:02:28 <spiffy> best coding music - Night at the Roxbury sound track.
22:02:34 <spiffy> just thought id share that.
22:02:54 <lispy_> spiffy: i think it depends on the listener :)
22:03:08 <humasect> best music coding - Haskell.
22:03:19 <humasect> that is objective ;)
22:03:34 <spiffy> isnt everything objective tho?
22:03:39 <Korollary_> No !
22:03:41 <Korollary_> heh
22:03:42 <humasect> depends who you ask
22:04:50 <spiffy> nicely done
22:05:04 <humasect> i would introduce myself and disclose my coding music of choice as well
22:05:09 <humasect> *by
22:06:04 <spiffy> figured it was better to say something stupid rather than let chat get stale.
22:06:17 <humasect> INFECTED MUSHROOM.
22:07:00 <spiffy> so when it comes to layout (just did some trial and error) it is 2 spaces for things like a case statement?
22:07:04 <spiffy> if that makes sense
22:07:19 <Korollary_> it's not 2 spaces
22:07:43 <spiffy> its not.
22:08:30 <elk> is glass.cse.ogi.edu down? cannot checkout fptools
22:08:42 <Korollary_> see this http://haskell.org/onlinereport/lexemes.html#lexemes-layout
22:09:19 <spiffy> wow its not at all...arg 2 in the morning is not the best time to learn a new language
22:10:08 <Korollary_> @timein boston
22:10:10 <lambdabot>  Wednesday, August 31, 2005 at 1:11:13 AM EDT
22:10:23 <Korollary_> @timein newfoundland
22:10:25 <lambdabot>  Wednesday, August 31, 2005 at 2:41:29 AM NDT
22:10:32 <spiffy> @timein halifax
22:10:32 <Korollary_> ugh
22:10:33 <lambdabot>  Wednesday, August 31, 2005 at 2:11:37 AM ADT
22:10:55 <lispy_> newfoundland has a weird time zone
22:11:00 <Korollary_> heh yeah
22:11:03 <sieni> humasect: Infected Mushroom is too "humppa" (http://en.wikipedia.org/wiki/Humppa)
22:11:22 <spiffy> newfoundland is weird *period*
22:11:31 <lispy_> heh, i would have guessed humppa was slang
22:11:49 <spiffy> one of the few places in the world to knowingly vote out democracy
22:11:58 <lispy_> for example, "Dude, you should humppa, she's hawt."
22:12:12 <humasect> interesting.
22:14:28 <sieni> about weird time zones:
22:14:32 <sieni> @timein kathmandu
22:14:34 <lambdabot>  Wednesday, August 31, 2005 at 11:00:38 AM
22:14:48 <spiffy> @timein halifax
22:14:50 <lambdabot>  Wednesday, August 31, 2005 at 2:15:53 AM ADT
22:14:58 <spiffy> wow, just making sure I read that right
22:15:06 <sieni> @timein chatham island
22:16:47 <spiffy> @timein dartmouth
22:16:48 <lambdabot>  Sorry, don't know this city
22:17:01 <spiffy> which city laugh
22:40:59 <TheHunter> what's the word for multiplying numerator and denominator by the same number?
22:45:34 <Korollary_> there's a word for that ?
22:45:47 <Cale> TheHunter: multiplication by 1?
22:46:23 <rasfar> Yeah, "multiplication by 1"'s the shortest I've heard.
22:46:31 <Korollary_> or division by 8/8 ;)
22:46:50 <rasfar> That *is* shorter, isn't it
22:47:11 <sieni> doing nothing?
22:47:21 <TheHunter> hmm, maybe there isn't a word for it in English.
22:47:31 <Korollary_> TheHunter: there is one in German ?
22:47:31 <TheHunter> it's the thing you do right before you add two fractions.
22:47:36 <TheHunter> "erweitern"
22:47:44 <rasfar> sieni: not specific enough -- there are so many ways to do nothing!
22:47:58 <Korollary_> hmm
22:48:09 <cathper> 'unsimplify' is the best customized word I can think of ;-)
22:48:28 <Korollary_> complicate by 8/8 ;)
22:48:41 <cathper> (there is in danish too)
22:48:42 <cathper> ;-)
22:48:47 <Cale> there really ought to be a word for it :)
22:49:12 <jewel> I'm sure there is a term, because they teach it in schools
22:49:42 <Cale> they always say "multiply top and bottom" or "multiply numerator and denominator" here
22:49:48 <Korollary_> babelfish says 'extend' for erweitern. ("weiter' +~ "forward?")
22:49:51 <Cale> I've seen "multiply by 1"
22:49:55 <TheHunter> i think that's what i'm going to say.
22:50:11 <TheHunter> "muliply both", that is.
22:52:05 <TheHunter> the opposite is appearently called "divide out".
22:52:32 <Cale> or "cancel"
22:52:44 <sieni> "kick the b*tch in the nuts with the neutral element of (R,+)"
22:53:01 <Cale> (R,*) :)
22:53:07 <sieni> well, that wasn't that short, was it
22:53:11 <sieni> Cale: oops
22:53:27 <sieni> cale: actually (R\{0},*)
22:53:31 <Pseudonym> "flutzpah the gnorgleflex"
22:53:36 <Pseudonym> Too many syllables?
22:53:38 <cathper> or just 'rename the fraction to'?
22:54:05 <humasect> can one use a subset of "enums" to build further types? say: data HairAnimal = Dog | Cat; data Pet = (Animal) | Goldfish  <-- Pet being three constructors.
22:54:13 <TheHunter> Korollary_, yep weiter sometimes means forward.
22:54:14 <Cale> sieni: yeah, if you want a group -- (R,*) is just a monoid
22:54:17 <TheHunter> thanks everyone.
22:54:43 <humasect> (of course one couldn't because of constructors, but to have the effect of the other side of the deal)
22:56:14 <Cale> data Pet = Other HairAnimal | Goldfish, you can do
22:56:25 <Cale> but Pet has 2 constructors
22:57:05 <Cale> lispy: hm?
22:57:11 <humasect> ah i see, thanks
22:58:10 <_idiot> Cale: hehe, sorry joke in another channel
22:58:31 <sieni> http://www.pnionline.com/dnblog/attytood/archives/002331.html
22:59:13 <sieni> I guess Mr. Bush is to blame for this one as well
23:00:17 <Cale> humasect: in Haskell (and functional languages in general), it's sort of more work to extend data types after the fact, and less work to extend the functions available to act on them, which is sort of the reverse of the situation in OO.
23:01:48 <Cale> (In OO, extending a class is trivial, but usually changing its interface is hard work)
23:09:56 <Korollary_> vdrab: I think you may get better answers here instead of #otherchannel ;)
23:13:14 <humasect> cale: i like that =)
23:15:29 <vdrab> Korollary_:  hehe.... no, I turned to the dark side.... it's too late.
23:15:48 <Cale> vdrab: what's the question?
23:18:49 <vdrab> oh darn. I was just asking at #O'therChAnL how straightforward it would be to translate an algorithm I have here to O'therlanguage.... I was curious whether that would give me any significant speed-up or not
23:19:41 <vdrab> the algorithm is pretty much pure.... just a bunch of functions working on lists and algebraic data types
23:20:05 <Cale> couldn't be that bad then, unless it relies on laziness
23:20:44 <vdrab> no, it's just that the algorithm itself has bad complexity
23:21:18 <vdrab> so, anything that can shave off some milliseconds of a handful of core functions that get called millions of times would be good
23:22:22 <humasect> i would like to master understanding of the situation where... the first call in a do{} mods the type of the entire action; in the same monad
23:30:44 <rt_> dum dee dee.
23:40:35 * autrijus purrs.
23:44:33 * Khisanth stares at the cat-dog
23:45:23 * Khisanth grumbles at having to do the occasional make clean
23:51:53 * boegel boings
