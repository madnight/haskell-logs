00:12:01 <Tue16499> meuning
00:12:46 <palomer> anyone know of any way to type a fixed point operator?
00:13:08 <Pseudonym> @type let y f = f (y f) in y
00:13:13 <lambdabot> forall t. (t -> t) -> t
00:13:18 <Pseudonym> Like that, you mean?
00:13:45 <palomer> that's a haskell type?
00:13:57 <Pseudonym> Well, it's a GHC type.
00:14:00 <Tue16499> fair enough :)
00:14:04 <Pseudonym> The forall isn't H98.
00:14:13 <palomer> whoa, I thought haskell types were intuitionistic
00:15:36 <palomer> Pseudonym: if I pass the function .\x.x (restricted to integers), I should get an integer, right?
00:15:58 <Pseudonym> Right.
00:16:09 <palomer> which integer do I get?
00:16:11 <Pseudonym> @type let y f = f (y f) in y (id :: Int -> Int)
00:16:13 <lambdabot> Int
00:16:18 <Pseudonym> Let's see, shall we?
00:16:25 <Pseudonym> @eval let y f = f (y f) in y (id :: Int -> Int)
00:16:30 <lambdabot> Terminated
00:16:32 <Pseudonym> That one.
00:16:39 <palomer> Terminated is an integer?
00:16:44 <Pseudonym> No.
00:16:49 <Pseudonym> It's an infinite loop.
00:16:51 <Pseudonym> i.e. bottom
00:16:56 <Tue16499> you are trying to calculate the fixpoint of the id :D
00:16:56 <palomer> oh, that sucks
00:16:58 <palomer> :O
00:17:01 <Pseudonym> In Haskell, all types are lifted.
00:17:13 <Pseudonym> So the least fixpoint of id always exists, and it's bottom.
00:17:34 <palomer> types are lifted?
00:17:36 <palomer> what does that mean?
00:18:42 <Pseudonym> In Haskell, every type has a bottom element.
00:18:42 <Pseudonym> (We're ignoring Glasgow extensions.)
00:18:42 <palomer> oh, that's what "lifted" means?
00:18:42 <Pseudonym> Right.
00:19:07 <Tue16499> doesnt that just say the types form some kind of semi-complete lattice?
00:19:09 <Pseudonym> It also means that (A, (B, C)) is not the same type as ((A, B), C)
00:19:14 <Pseudonym> Yeah, something like that.
00:19:18 <Tue16499> that every type has a bottom element
00:19:21 <Pseudonym> Because the pairs are lifted.
00:19:29 <palomer> lifted?
00:19:31 <Pseudonym> bottom is not the same as (bottom, bottom)
00:21:50 <palomer> what does lifted mean exactly?
00:23:07 <Pseudonym> It means different things in different contexts, but in this case it means that every type is converted into a lattice or semi-lattice or whatever it's called when it's got a bottom element.
00:23:18 <Pseudonym> :-)
00:26:05 <palomer> aw man
00:26:13 <palomer> sml won't let me type any of the fixed point combinators
00:26:17 * palomer poos on sml
00:26:58 <palomer> Pseudonym: will your y function applied to anything always return bottom?
00:27:33 <Tue16499> its not a complete lattice because it also requires a top element.
00:27:46 <Tue16499> or is that also true in this case?
00:27:58 <Pseudonym> palomer: No.
00:28:11 <palomer> Pseudonym: give me an example where it doesn't return bottom
00:28:49 <Pseudonym> @eval let y f = f (y f) in y (\add x -> if x == 0 then 0 else x + add (x-1)) 10
00:28:51 <lambdabot> 55
00:29:08 <Pseudonym> @eval let y f = f (y f) in y (\ones -> 1 : ones)
00:29:09 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:09 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:09 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:09 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:09 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:12 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:13 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00:29:15 <lambdabot> [24 @more lines]
00:29:27 <dblhelix> Pseudonym: no factorial? ;)
00:29:32 <Pseudonym> dblhelix: Takes too long to type, but I did think of that first.
00:29:39 <Pseudonym> Sad, really.
00:29:49 <dblhelix> agreed
00:30:08 <Pseudonym> @eval let y f = f (y f) in y (\fac x -> if x == 0 then 1 else x * fac (x-1)) 10
00:30:10 <lambdabot> 3628800
00:30:10 <Pseudonym> Happy now?
00:30:15 <palomer> yes:O
00:30:32 <palomer> do all fixed point operators return the same things, always?
00:30:44 <Pseudonym> Oooh, good question.
00:30:55 <Pseudonym> Theoretically, no.
00:31:06 <Pseudonym> In practice, I defy you to write a greatest fixed point operator in Haskell.
00:31:13 <Pseudonym> :-)
00:31:25 <Pseudonym> You can't because Haskell types don't necessarily have a _greatest_ element.
00:31:33 <Pseudonym> They all do have a least one, though.  (bottom)
00:31:39 <Tue16499> its just used to take care of the recursion
00:33:02 <palomer> how would a greatest element work?
00:33:11 <palomer> has anyone thought of adding one?
00:33:25 <Pseudonym> It wouldn't.
00:33:37 <Pseudonym> First off, sometimes greatest fixpoints don't exist.
00:33:46 <Pseudonym> There are "optimal" fixpoints, though.
00:33:53 <palomer> wait wait, what ordering are we using?
00:34:04 <Pseudonym> I believe the glb of the locally greatest fixpoints is the optimal fixpoint.
00:34:11 <Pseudonym> The ordering we're using is the lattice ordering.
00:34:32 <Pseudonym> Secondly, in general, finding a greatest/optimal fixpoint requires transfinite recursion.
00:34:42 <Pseudonym> You thought infinite loops were bad...
00:35:46 <palomer> which lattice ordering?
00:36:00 <Pseudonym> Let's take Bool as an example.
00:36:13 <Pseudonym> The lattice (or whatever it's called) looks something like this:
00:36:16 <Pseudonym>     False   True
00:36:27 <palomer> and bottom!
00:36:29 <Pseudonym>       \      /
00:36:36 <Pseudonym>        bottom
00:36:47 <Pseudonym> Right?
00:36:52 <palomer> right
00:36:59 <Pseudonym> I assume the plan is to add a top element, too.
00:37:11 <palomer> nono, that's quite alright
00:37:35 <Pseudonym> Well, then id :: Bool -> Bool doesn't have a greatest fixpoint.
00:37:41 <Pseudonym> And the optimal fixpoint is bottom.
00:39:13 <palomer> won't all lattices look like that?
00:39:25 <Pseudonym> No.
00:39:26 <Pseudonym> Consider the type (Bool,Bool).
00:39:52 <palomer> it has 5 elements instead of 3
00:40:18 <dblhelix> 7
00:40:28 <dblhelix> (,) is the lazy product
00:40:50 <dblhelix> bottom, (bottom, bottom), (bottom, False), ...
00:40:52 <palomer> oh, righto
00:40:55 <Pseudonym> That's more than 7.
00:41:16 <Pseudonym>       (False,False) (False,True) (True,False) (True,True)
00:41:23 <palomer> 10 elements!
00:41:36 <Pseudonym> (False,bottom) (True,bottom) (bottom,False) (bottom,True)
00:41:43 <Pseudonym> (bottom,bottom) and bottom
00:41:44 <dblhelix> yep, my bad
00:41:52 <Pseudonym> And yes, I did get a kick out of typing (False,bottom).
00:42:26 <Pseudonym> Or you could make a koan out of it.
00:42:31 <dblhelix> :)
00:42:35 <palomer> how would the lattice for (forall A. forall B. (A -> B) -> A -> B) look like?
00:42:37 <Pseudonym> The bottom which is not lifted is not the (True,bottom).
00:42:38 <dblhelix> coffee!
00:42:51 <palomer> is it infinite?
00:43:05 <Pseudonym> palomer: That's a VERY good question.
00:43:37 <Pseudonym> I actually don't know the answer to that because I don't know how to extract the free theorem in a language with fixpoint operators.
00:44:05 <Pseudonym> I suspect it might be:
00:44:07 <Pseudonym>       id
00:44:10 <Pseudonym>      |
00:44:13 <Pseudonym>   bottom
00:44:16 <Pseudonym> But I'm not sure.
00:44:42 <Pseudonym> How many functions ARE there of that type anyway?
00:45:07 <Pseudonym> BTW, gotta go.
00:45:09 <Pseudonym> Time to go home.
00:45:11 <palomer> cya
00:45:12 <Pseudonym> Nytol!
00:45:16 <dblhelix> i'd say two: id and bottom
00:46:11 <palomer> are \x -> x and \x\y x y the same function?
00:47:14 <dblhelix> only if we have (eta)
00:48:13 <palomer> hrmhrm
00:48:17 <palomer> too much to think about
00:48:28 <palomer> pi calculus is cool
00:50:51 <Tue16499> why would \x -> \y -> x y be the same as \x -> x
00:52:52 <dblhelix> (\x y -> x y) succ 4 = 5
00:53:06 <dblhelix> (\x -> x) succ 4 = 5
00:53:31 <dblhelix> you see?
00:54:28 <dblhelix> equal functions applied to equal arguments give equal results
00:54:45 <dblhelix> it's just eta-equivalence
00:58:43 <Tue16499> ah thats cheating
00:58:52 <Tue16499> eta-cheating
00:59:20 <dblhelix> Tue16499: explain
01:13:37 <Tue16499> i didnt see the second argument coming with \x -> \x :)
01:13:49 <dblhelix> ah, okay
01:13:49 <Tue16499> should have looked more careful
01:14:03 <dblhelix> well, it's still well before noon, so ...
01:14:08 <Tue16499> then its quite logical they're equal
01:14:23 <Tue16499> yeah, didnt even have one expresso
01:14:24 <Tue16499> yet
02:17:43 <wilx> @moo
02:18:04 <xerox> Spock, deactivate @moo
02:47:42 <kowey> hi haskellers, anyone know why there is a castCharToCChar, but not a castCharToCWchar?
02:47:51 <kowey> is it something to do numbers of bits not being the same?
02:48:53 <JaffaCake> I think it's because we don't know the encoding of WChar
02:49:15 <tuomov> is CChar assumed to be what then?
02:49:29 <kowey> but... i thought WChar was for handling unicode characters?
02:49:30 <JaffaCake> ascii, or latin-1
02:49:41 <JaffaCake> wchar isn't necessarily unicode
02:49:45 <tuomov> no, encoding of wchar_t is not specified, although it is unicode in glibc
02:50:04 <kowey> nod...
02:50:09 <kowey> ok... thanks
02:50:21 <musasabi> JaffaCake: is the "a local module can shadow a package module" really good for 6.4.1 - it might break some build systems.
02:50:50 <JaffaCake> musasabi: I think it can only reduce errors, not introduce them
02:51:20 <tuomov> Some implementations of iconv have a WCHAR charset, but the iconv names are also nonstandard
02:51:28 <tuomov> so it is a bit tricky to do the conversion
02:51:30 <kowey> question 2 - does this code snippet do the same thing as castCharToCChar?
02:51:45 <kowey> toCChar c = fromIntegral (fromEnum c)
02:51:45 <kowey> toCChar c = fromIntegral (fromEnum c)
02:51:45 <kowey> fromIntegral (fromEnum c)
02:51:53 <kowey> (ah... there's those pastes)
02:51:56 <kowey> weird client
02:52:25 <JaffaCake> kowey: yes (or use ord instead of fromEnum)
02:52:34 <kowey> hmm...
02:52:37 <kowey> then it's odd then
02:52:46 <kowey> i wonder why he (wxhaskell implementer) did it that way
02:52:58 <JaffaCake> did what what way?
02:53:06 <kowey> instead of just using castCharToCChar
02:53:14 <kowey> maybe just didn't find it in the api
02:53:16 * JaffaCake shrugs
02:53:32 <kowey> i'm on a quest to make wxhaskell work with unicode... but i'm in over my head
02:53:34 <kowey> oh well
02:53:46 <musasabi> JaffaCake: e.g. it was possible with 6.4 to have a Data.Map module sitting in the utility sources - 6.2.2 would pick that and 6.4 use the library Data.Map - 6.4.1 will break it. Of course that can be considered to be wrong in the first place.
02:54:10 <JaffaCake> musasabi: ah yes, you're right
02:54:27 <JaffaCake> 6.4 would ignore the local module
02:54:43 <JaffaCake> still, I think it's a good change
02:55:00 <JaffaCake> the new behaviour seems to be what people expect
02:55:49 <musasabi> yes, it the new behaviour seems nicer.
02:55:57 <musasabi> s/it//
02:56:18 <kowey> question 3 - if i assumed unicode characters (like with glibc), would it be feasible to implement a simple castCharToCWchar?
02:56:35 <tuomov> kowey: does wx directly support unicode or does it support locale encoding or what?
02:56:51 * shapr yawns
02:56:52 <kowey> wxWidgets does support unicode
02:56:57 <JaffaCake> kowey: sure: fromIntegral.ord should do it
02:57:02 <kowey> don't know about the locale stuff
02:57:20 <kowey> ok, JaffaCake, thank-you
02:57:27 <tuomov> kowey: it itself expects wchar_t to be unicode or it has its own type for it?
02:57:32 <kowey> i'll try that out and see if works
02:57:35 <kowey> yes,
02:57:54 <kowey> uh... well, no wait, maybe i'm not answering the question right
02:58:11 <JaffaCake> systems with non-unicode wchar_t are crazy, IMO you could ignore them :)
02:58:13 <tuomov> if you know the library doesn't use libc wchar stuff, you should be able to directly cast things without any conversions
02:58:19 <kowey> it implements unicode by using wchar_t; how exactly it interprets those wchar_t, i don't know
02:58:30 * JaffaCake remembers that includes windows
02:58:44 <tuomov> windows can be ignored.
02:58:45 <kowey> doesn't use libc wchar stuff?
02:58:58 <kowey> you mean mbstowcs or something like that?
02:59:01 <JaffaCake> tuomov: if only it were so
02:59:35 <tuomov> kowey: mb* wc*
03:06:03 * Lemmih bangs his head against the nativeGen.
03:06:22 * JaffaCake moves the nativeGen out of the way and checks for damage
03:07:28 <Lemmih> JaffaCake: Yo. Know how to do 64bit integer multiplication in C--?
03:07:43 <JaffaCake> I'd have to look it up
03:08:03 <JaffaCake> check the c-- manual
03:08:09 * Lemmih is stock in nativeGen/MachCodeGen.hs:iselExpr64.
03:08:37 <JaffaCake> ok, what are you trying to do?
03:10:35 <Lemmih> I've added Int64 operations as primops and I can't figure out how to handle them in the nativeGen backend.
03:11:13 <JaffaCake> ah, well, you need to generate code for them
03:11:30 <Lemmih> Yeah, I figured that much (:
03:11:43 <JaffaCake> sorry for being obvious ;)
03:11:55 <Lemmih> (using primops and some builtin rules made Int64's really fast)
03:12:04 <JaffaCake> neat
03:12:16 <JaffaCake> so which bit of the NCG are you having trouble with?
03:13:46 <Lemmih> iselExpr64 from nativeGen/MachCodeGen.hs should have a case for 'CmmMachOp (MO_Mul _) [e1, e1]' but I'm not sure what the appropriate Cmm would look like.
03:14:20 <Lemmih> Oh wait, I think I'm just being stupid here.
03:14:20 <JaffaCake> umm, that's what the Cmm looks like
03:15:21 <JaffaCake> doesn't x86 have a 64-bit multiply instruction?
03:15:51 <JaffaCake> or does it just take 32 bit operands and give a 64 bit result...
03:18:29 <musasabi> I think it is usually done by two mul (or imul).
03:20:19 <tuomov> only the result is 64bit afaik
03:23:39 <musasabi> MMX/SSE could probably do that.
03:28:12 * Lemmih will solve this when he gets home.
04:57:48 <Tue16499> AAAAAAAAAAAAAAAAAAAAAAAh
04:58:08 <Tue16499> im freakin still debugging the same fckn thing that kept me busy for hours yesterday
05:07:24 <dblhelix> Tue16499: what version of GHC do you use?
05:07:52 <dons> maybe he's not using ghc, and that's the problem ;)
05:08:39 <dblhelix> dons: I wasn't  even trying to help him :)... what version are you running? could you have a look at the program at the top of the paste page and try to compile it?
05:08:51 <dblhelix> @paste
05:08:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:08:55 <dons> sure
05:09:07 <dons> i have lots of versions, which would you like?
05:09:26 <dblhelix> 6.4 and 6.4.1 :)
05:09:37 <Tue16499> dblhelix, 6.4
05:09:50 <dons> just the newtype stuff?
05:09:57 <dblhelix> dons: yes
05:10:29 <dons> ghc-6.4.20050506: panic! (the `impossible' happened, GHC version 6.4.20050506):
05:10:32 <dblhelix> Tue16499: I had a program that made GHC feel ill and I had to make sure it was not just my setup that was broken
05:10:35 <Tue16499> but this is my problem...i have a c code generator...and i've ported it...the ported one occasionally puts /* */ around attributes...and i cant narrow down why.
05:10:59 <dblhelix> dons: well. okay, then it's not my machine that's broken
05:11:00 <TheHunter> dblhelix, it's fixed in head.
05:11:05 <dons> i'll check it with the head
05:11:24 <dons> oh, that was the head :}
05:11:28 <dons> but a while ago
05:11:59 <JaffaCake> works with 6.4.1 and the HEAD
05:12:04 <Beelsebob> tue: you need a comparative debugger
05:12:09 <Tue16499> maybe chocolate will help
05:12:11 <Beelsebob> sorry... I haven't written it yet
05:12:27 <dblhelix> ah okay, so no need to report it then
05:12:41 <dblhelix> dons, JaffaCake, TheHunter: thanks!
05:13:14 <dons> yep, works with tonight's head
05:13:59 <Tue16499> i think im going to do the opposite of logic.....put on some heavy metal while debugging
05:14:01 <Tue16499> maybe that helps
05:14:25 <dblhelix> it took me twenty minutes or so to narrow it down to just these three newtype decls
05:14:49 <dblhelix> moreover, removing the destructor made it work on 6.4 too
05:30:48 <CosmicRay> JaffaCake: out of curiousity, do I remember reading that the new Cabal won't be in 6.4.1?  any particular reason?
05:33:23 <JaffaCake> CosmicRay: right.  we have a strict rule about not changing APIs in patchlevel releases.
05:33:30 <CosmicRay> ah.
05:34:16 <boegel> @seen Itkovian
05:34:16 <lambdabot> I saw Itkovian leaving #haskell 5 days, 23 hours, 10 minutes and 57
05:34:16 <lambdabot> seconds ago, and I have missed 52 seconds since then.
05:38:43 * boegel leaves again
05:43:25 * CosmicRay posts the first issue of haskell weekly news
05:44:44 <Lemmih> Neat (:
05:44:55 <CosmicRay> http://sequence.complete.org/hwn/20050802
05:45:24 <CosmicRay> or the vt100 version <g> at http://www.haskell.org//pipermail/haskell/2005-August/016208.html
05:46:58 <dblhelix> thumbs up
05:47:02 <CosmicRay> thanks dblhelix
05:51:30 <JaffaCake> CosmicRay: just seen it, looks great
05:51:31 <musasabi> That looks very nice.
05:51:38 <CosmicRay> thanks everyone
05:52:04 <JaffaCake> have you told LWN?  they always point to the Caml weekly news, that's always annoyed me
05:52:12 <CosmicRay> hmm, good idea.
05:52:15 <CosmicRay> heh
05:52:31 <CosmicRay> what would they have to announce anyway? :-)
05:52:39 <Igloo> Why does it annoy you?
05:52:53 <CosmicRay> New Caml feature -- now you can open a file for reading AND writing! :-)
05:52:55 <Tue16499> wow, that looks really crap CosmicRay :P
05:53:01 <CosmicRay> hehe
05:53:16 <JaffaCake> Igloo: it just annoyed that we didn't have one too :)
05:53:25 <Igloo> Ah, OK  :-)
05:57:42 <CosmicRay> fwiw, shapr also gets hwn@complete.org mail...  if anyone else is interested in being a regular hwn editor, please let one of us know
05:58:34 <CosmicRay> JaffaCake: would the time after the 6.4.1 release be a good time to revisit how fptools might be switched to darcs?
05:59:14 <Igloo> I don't think you can seriously switch until the new conflictor stuff is worked out
05:59:26 <CosmicRay> new conflictor stuff?
05:59:31 <CosmicRay> has there been a regression?
05:59:35 <Igloo> (it probably won't be an issue most of the time, but it'll be a pain when it is)
05:59:41 <Igloo> No
06:00:05 <JaffaCake> CosmicRay: I'm not going to be around much from mid-Aug
06:00:14 <JaffaCake> probably for a few weeks
06:00:22 <CosmicRay> JaffaCake: oh right.  Early September then? ;-)
06:00:30 <JaffaCake> yeah, something like that
06:00:35 <CosmicRay> I'm sure Igloo will have every darcs bug fixed by then ;-)
06:04:02 <pejo> Is there any compelling reason to switch to darcs for ghc, except that it's written in Haskell?
06:04:33 <Igloo> There are compelling reasons to switch away from CVS
06:05:03 <CosmicRay> pejo: it is *so* much easier for people to contribute to the development process if it uses darcs
06:05:18 <Igloo> I think most people would agree there are compelling reasons to switch to a distributed RCS too
06:05:25 <CosmicRay> pejo: with cvs, if you are to get any benefit of version control at all, you have to have a haskell.org account and access
06:05:38 <JaffaCake> CVS stinks for branching/merging
06:05:51 <CosmicRay> that too.
06:06:17 <wilx> Hmm.
06:06:19 <CosmicRay> for large projects, the lack of atomic commits and painful versioning of rename history is a pest as well.
06:06:28 <wilx> Darcs is nice but...
06:07:06 <wilx> The occasional mysterious freeze...
06:07:18 <pejo> JaffaCake, thats a good argument. Would you use branches more often if they were less costly?
06:07:26 <JaffaCake> definitely
06:07:39 * boegel walks in yawning
06:07:44 <CosmicRay> I haven't seen one of those in ages.  I know that there is still a case where conflicts can make it spin, but they seem to be in contrived situations that I don't see IRL
06:07:47 <JaffaCake> I'd have lots of local development branches, at least
06:07:49 <Lemmih> Greetings boegel.
06:07:56 <boegel> hiya Lemmih
06:08:01 <CosmicRay> I have, at last count, some 43 darcs repositories on darcs.complete.org and haven't had a problem with any of them.
06:08:39 <CosmicRay> I'm very impressed with darcs overall.  it's everything I wished arch would have been.
06:09:14 <CosmicRay> JaffaCake: tagging is nicer in darcs as well.
06:09:27 <shapr> I do wish darcs came in an .hc format for popular distros though.
06:09:53 <Igloo> Huh? It comes in compiled format for popular distros
06:10:12 <shapr> Yeah, good point, that's easier.
06:10:27 <JaffaCake> .hc is unworkable.. you'd need libraries, the RTS, a build system etc. etc.
06:10:27 <xerox> What do you mean with ".hc"?
06:11:01 <shapr> Ok, I withdraw my .hc suggestion, it's silly :-)
06:11:04 <wilx> For example the working dir of Yi that I have now.
06:11:07 <boegel> xerox, I printed loads of stuff to you yesterday, good job on the colors !
06:11:28 <Tue16499> hmm, i didnt think expresso could molt
06:12:18 <wilx> When I do pull -v, it pulls the patches, I select all, it prints all the patches and it keeps spinning on "diffing dir..."
06:12:58 <xerox> boegel: yay :)
06:17:51 * boegel leaves again (tired *yawn*)
06:18:06 <xerox> They made it. http://www.apple.com/mightymouse
06:21:20 <boegel> cool
06:21:25 <boegel> off now :)
06:26:22 <Narrenschiff> xerox: hell freezes over, part 47
06:26:36 * xerox laughs
06:28:24 <Tue16499> mightymouse looks like yet another expensive apple gadget :)
06:28:48 * dblhelix is battling the type checker (not sure who's winning)
06:28:53 * Igloo wonders why his gf's amazon account has "Add to wedding registry" buttons but his doesn't, and whether I should worry there's something she's not telling me
06:29:12 <dblhelix> lol
06:29:15 <ozone> Igloo: hmm, i think i have that option
06:29:21 <xerox> hahah.
06:30:01 <Igloo> Maybe it's decided people who have "The Very Best of William Shatner & Leonard Nimoy" in their wishlist won't get married
06:30:11 <Narrenschiff> everyone with a powermac, myself included, seems to own one of the microsoft five button jobbies.
06:30:24 <ozone> Igloo: dear god man
06:30:43 <CosmicRay> haha
06:31:04 <Igloo> Well, the reviews claim Nimoy can actually sing, and sings differently as himself or Spock. I figure it's got to be worth at least one listen  :-)
06:31:41 <Narrenschiff> I think I saw a fragment of him singing a song about hobbits on some "TV terrors" compilation show.
06:33:12 <Igloo> "Ballad of Bilbo Baggins" sounds likely
06:33:33 <dblhelix> if my battle with the type checker does not results in a clear winner within the next ten minutes, I happily switch to a dynamically typed language... (can anyone recommend some kind of nifty scripting language or something?) ;)
06:33:59 <xerox> python?
06:34:06 <wilx> Perl!
06:34:36 <dblhelix> xerox, wilx: you're way too enthousiastic
06:34:37 <CosmicRay> dblhelix: I am curious, why would a dynamically-typed language be better?
06:34:45 <xerox> heh.
06:34:56 <dblhelix> CosmicRay: I was just kidding
06:34:56 <CosmicRay> dblhelix: it's like crashing once the airplane is aloft, as opposed to finding the problem on the ground
06:34:59 <CosmicRay> ah
06:35:10 <CosmicRay> I think hugs is pretty nifty for scripting, myself ;-)
06:36:41 <dblhelix> still, chances are that there is going to be some serious swearing if GHC just keeps insisting that it is me who's wrong
06:37:54 <CosmicRay> dblhelix: can you paste the code in question?
06:38:23 <CosmicRay> the nice thing about the ghc type checker is that it is actually useful and stays out of your way otherwise
06:38:30 <CosmicRay> as opposed to, say, the java type checker
06:39:03 <dblhelix> CosmicRay: well, I'm just stripping my program it down to its bare essentials
06:39:31 <Tue16499> is recursively calling oneself (oneself being a function that returns a Reader .. .. ) asking for problems ?
06:39:34 <dblhelix> it type checks now, but now I'm about to add the piece I myself thought was quite elegant but etc.
06:39:40 <Tue16499> im wondering if that could be the cause of weird behaviour
06:39:57 <CosmicRay> Tue16499: recursion is quite common in haskell.  Don't know about Readers though.
06:40:28 <Tue16499> im wondering specifically in the combination with Reader monad if there are possible tarpits
06:41:38 <Philippa> nothing new. There usually isn't
06:42:07 <CosmicRay> dblhelix: can you show us the code?
06:42:23 <Tue16499> hmm, cause i've been debugging for 1,5 day now :S
06:42:45 <dblhelix> CosmicRay: I can show you the part that type checks :)
06:42:49 <CosmicRay> heh
06:44:42 <dblhelix> CosmicRay: it's on top of the paste page
06:44:45 <dblhelix> @paste
06:44:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:45:15 <CosmicRay> blat, this is not going to be easy ;-)
06:45:19 <CosmicRay> so this is the code that works?
06:45:35 <dblhelix> CosmicRay: yes, no problem here
06:46:07 <CosmicRay> well then, I guess my job is done... ;-)
06:46:11 <dblhelix> CosmicRay: but don't worry: I'll break it within a few minutes... not enough type classes yet :)
06:46:23 <CosmicRay> you are just begging for trouble, aren't you
06:46:50 <dblhelix> isn't that the fun part?
06:47:00 <CosmicRay> of course.
06:47:03 <CosmicRay> and that reminds me.
06:47:13 <CosmicRay> shapr: would you be interested in a TMR article on using unsafeInterleaveIO?
06:52:19 <dblhelix> CosmicRay: so, now I've broken it :)
06:53:42 <CosmicRay> congrats ;-)
06:54:35 <dblhelix> CosmicRay: however, I'm convinced (well... ;)) that this should type check
06:55:32 <CosmicRay> dblhelix: you maybe wnat to post this to haskell-cafe
06:56:21 <dblhelix> yeah, I probably will... but first I'll ponder about it some more...
06:56:47 <dblhelix> CosmicRay: but you agree that the change I made is actually quite conservative?
06:56:59 <CosmicRay> is the change up on the paste page?
06:57:10 <dblhelix> yes
06:57:21 <CosmicRay> hmm, what exactly changed?
06:57:40 <dblhelix> I introduced an IsItem class
06:58:01 <dblhelix> and used that one in the IsProcessor class
06:58:28 <CosmicRay> I'm not that good with funky monad stuff yet.  I'm afraid I'm not the best person to help you on this one
06:59:25 <dblhelix> is it credible for me to say now that I still love monads?
07:04:08 <nothingmuch_> what is the sanest practice for lazily reading data off disks?
07:04:55 <CosmicRay> hGetContents?
07:05:04 <CosmicRay> or readfile
07:05:09 <CosmicRay> readFile
07:06:17 * dblhelix throws the towel and goes home
07:06:37 <dblhelix> to be continued on haskell-cafe, I guess
07:06:48 <Tue16499> pffffffffff
07:07:01 <Tue16499> im getting too agressive with this debugging
07:09:27 <Tue16499> i need to FORCE trace. is that possible?
07:21:27 <Tue16499> ffs
07:24:11 <boegel> @seen Itkovian
07:24:12 <lambdabot> I saw Itkovian leaving #haskell 6 days, 1 hour and 53 seconds ago,
07:24:12 <lambdabot> and I have missed 52 seconds since then.
07:24:21 <boegel> @seen your ass
07:24:22 <lambdabot> I haven't seen your.
07:24:30 <boegel> @seen your_ass
07:24:30 <lambdabot> I haven't seen your_ass.
07:30:55 <CosmicRay> hsc2hs question:
07:31:00 <CosmicRay>     do len <- ( #{peek berval, bv_len} ) bptr
07:31:00 <CosmicRay>        cstr <- ( #{peek berval, bv_val} ) bptr
07:31:00 <CosmicRay>        peekCStringLen (cstr, len)
07:31:06 <CosmicRay> this code is generating:
07:31:11 <CosmicRay> Search.hsc:111: error: syntax error before 'berval'
07:31:11 <CosmicRay> Search.hsc:112: error: syntax error before 'berval'
07:31:16 <CosmicRay> any ideas what I'm doing wrong?
07:31:24 <CosmicRay> the syntax lookgs correct to me, given the hsc2hs manual
07:31:29 <Lemmih> struct berval?
07:31:51 <CosmicRay> yes, it's defined in a header file I have #included as
07:31:53 <CosmicRay> typedef struct berval {
07:31:53 <CosmicRay>         ber_len_t       bv_len;
07:31:53 <CosmicRay>         char            *bv_val;
07:31:53 <CosmicRay> } BerValue;
07:32:27 <Lemmih> s/berval/struct berval/ in the peek.
07:32:59 <CosmicRay> Lemmih: sweet, that got it.  thanks.
07:35:10 * boegel leaves again
07:35:33 <musasabi> CosmicRay: there already exists a BER binding afaik.
07:36:59 <CosmicRay> afaik this is the only bit from lber.h that I need
07:46:07 <shapr> CosmicRay: looks great!
07:46:19 <CosmicRay> shapr: thanks (I assume you mean HWN?)
07:46:23 <shapr> Yes
07:48:39 <Lemmih> Has anyone attempted to write GHC rewriting-rules in TH?
07:49:08 <jlouis> I just tried to rewrite some C code
07:49:27 <jlouis> I should never have embarked upon that quest. I was missing Either and Maybe all the time
07:49:48 <jlouis> and string manipulation is to be killed
07:49:51 <shapr> Did you hear that ffii.org is down because a German patent exploit company has sued them into the ground?
07:50:40 <CosmicRay> what was ffii.org?
07:51:24 <shapr> Anti-software-patent organization
07:51:32 <shapr> See http://www.grep.be/blog/2005/08/01/#nutzwerk_is_a_scam
07:51:48 <CosmicRay> ah.
07:58:04 <shapr> So, how's code? Anything interesting going on?
07:58:15 <CosmicRay> still hacking on my ldap interface
07:58:50 <CosmicRay> after that, I'll probably do some sort of curses thing, not sure what yet
07:58:50 <Lemmih> I've posted some C code on the wiki which is a lot slower than an naive implementation in Haskell. Have I made some dump mistake which makes it slow?
08:06:55 <Tue13823> what happens to the Reader-environment if i recursively call myself?
08:07:12 <Tue13823> pType :: Reader Env PP which calls itself
08:07:42 <Lemmih> You loop?
08:08:42 <Lemmih> Oh, I misread.
08:09:13 <Lemmih> I don't think anything happends to the environment.
08:09:27 <Tue13823> hmm
08:09:38 <Tue13823> i find it very difficult to debug my haskell app.
08:12:52 <Lemmih> GHCi, unit testing and refactoring are your friends.
08:13:14 <JaffaCake> Debug.Trace is one of my best friends
08:13:22 <Tue13823> im using Debug.Trace
08:13:32 <Tue13823> but these things only get evaluated when needed
08:13:57 <JaffaCake> so you don't want to evaluate things too early?
08:14:36 <Tue13823> well sure, but im comparing my thing with the ocaml equivalent...they should give the same endresult, which they dont
08:14:59 <JaffaCake> I don't get it, what's the problem with using trace?
08:15:00 <Tue13823> so im kind of debugging both apps to see what happens in them but comparing is hard because of strictness of ocaml
08:15:12 <JaffaCake> oh, i c
08:15:58 <JaffaCake> what does ocaml have for debugging?
08:16:41 <Tue13823> quite good thing, but its not the ocaml app which is wrong. my haskell port is.
08:17:09 <Tue13823> so i was basically outputting stuff from the ocaml app and doing the same for the haskell port....
08:17:17 <JaffaCake> I know, just wondering what they have in the ocaml camp
08:19:27 <Tue13823> ow i dont bother with ocaml if i can avoid it, so i wouldnt really know
08:19:37 <Tue13823> there a reason why i ported the ocaml thing to haskell ;)
08:20:42 <Lemmih> What are you porting, btw?
08:20:53 <Tue13823> a c code generator
08:21:10 <Tue13823> im putting comments around some attribute somewhere, where the ocaml thing doesnt
08:21:48 <Lemmih> How big is the code base?
08:22:40 <Tue13823> uhm 2000 lines or so
08:22:45 <Tue13823> the ocaml thing that is
08:26:46 <Tue13823> ah shite, another situation where i just want to force out the trace
08:27:21 <pejo> Tue, is that thing named ocamlburg or similar?
08:27:51 <Tue13823> the debugger for ocaml?
08:27:59 <pejo> Tue, meant the code generator
08:28:14 <Tue13823> ow no, actually its the code generator from CIL which is written in ocaml
08:28:45 <Tue13823> and since im dealing with CIL AST's in my haskell app, i ported the code generator
08:29:43 <Lemmih> You could try uploading it. I have little to do until I figure out what instructions are used for 64bit ops.
08:29:59 <pejo> Lemmih, x86?
08:30:20 <Lemmih> pejo: Yep. Can you help me?
08:30:36 <Tue13823> hey, btw if i have a do...with a trace...it should execute the trace no?
08:30:51 <Tue13823> and if no....how can i force
08:33:06 <CosmicRay> w00t, ldapSearch is finally working ;-)
08:33:16 <Tue13823> (y)
08:33:16 <CosmicRay> in hugs, even!
08:35:25 <Tue13823> ok i put it wrong....i have a do in a Reader monad....will the trace be executed yes or no?
08:37:30 <pejo> Lemmih, hm. Isn't that stored in crt0.o and similar for C compilers?
08:38:03 <CosmicRay> OK.  I'm writing unit tests for this ldap interface.  Anyone know of some public LDAP directory that wouldn't mind being hit for unit tests and has a fairly static set of data I could look at?
08:39:22 <Lemmih> Tue13823: Yes, but only when you evaluate the expression.
08:40:14 <Tue13823> if i have a function foo = do ......
08:40:27 <Tue13823> it depends on the fact whether this foo will be executed
08:41:08 <Lemmih> (the do-notation is just syntactic sugar. It doesn't indicate strictness)
08:41:14 <pejo> Lemmih, I take that back. __muldi3 exists on NetBSD in libc atleast.
08:41:35 <musasabi> Lemmih: I tested gcc and it seemed to generate two imuls.
08:42:05 * Lemmih knows nothing about assembly.
08:43:22 <Lemmih> musasabi: How about shifts?
08:45:47 <pejo> Lemmih, http://cvsweb.netbsd.org/bsdweb.cgi/src/lib/libc/quad/, there's quite a lot of comments in atleast muldi3.c.
08:45:57 <Lemmih> Thanks.
08:46:40 <musasabi> Lemmih: that works only if the multiplier is suitable (for constants that is an important optimization)
08:50:53 <Tue13823> YEAHHHHHHHH
08:50:57 <Tue13823> there is a God
08:51:07 <Tue13823> and he just touched my code
08:51:10 <Tue13823> it workssssss
08:51:27 <Tue13823> (not ment in a disrespectful way btw)
08:51:52 <basti_> :)
08:51:59 <CosmicRay> ooo, divine code?
08:52:08 <CosmicRay> this will surely put the church of emacs to shame.
08:52:30 <Tue13823> im too ashamed that this turned out to be the bug
08:52:30 <Tue13823> omg
08:53:05 <Tue13823> i HATE ocaml's mutuable references and their lack of transparant referentiality
08:53:07 <CosmicRay> "Oh Lord, bless this thy holy IO monad, and use it for thy purposes that it may smash Java to tiny bits..."  (with apologies to monty python)
08:53:32 <CosmicRay> I hate the fact that you can't open a file read/write in ocaml.
08:53:42 <Tue13823> ow mannn this fealing is even better then...
08:53:43 <Tue13823> no its not
08:53:43 <Tue13823> :D
08:53:51 <CosmicRay> heh
08:54:28 * CosmicRay jots down a few potential quotes of the week for next week's HWN ;-)
08:55:08 <Tue13823> what does that mean?
08:55:25 <CosmicRay> HWN?
08:55:42 <CosmicRay> or read/write?
08:55:47 <CosmicRay> (please dereference "that")
08:56:20 <Tue13823> your starred message
08:57:26 <CosmicRay> ah.  In the Haskell Weekly News, I have a little section where I list a couple of random funny or interesting haskell-related quotes that were seen in IRC or mailing lists over the past week.
08:57:36 <CosmicRay> I think I've seen a few ;-)
08:57:59 <Tue13823> ow lol, HWN is your initiative?
08:58:04 <CosmicRay> yeah
08:58:19 <CosmicRay> but it's up on darcs so anyone can contribute
08:58:51 <Tue13823> nice
08:59:10 <Tue13823> the haskell community seems much more active than the ocaml, or is that a false perception?
09:03:03 <basti_> we're on different drugs.
09:04:22 <Tue13823> lol, nicely put
09:05:20 <Tue13823> ocaml is more like a prozac to soften the impure depression, whereas Haskell is a 100% pure colombian
09:05:20 <Tue13823> :D
09:05:46 <basti_> .)
09:13:35 <monochrom> w00t, I made an impact!
09:13:57 <Tue13823> where?
09:15:18 <monochrom> In HWN, "sample code for interpolation inside strings" is mentioned.  People contributed such sample code because I brought it up.
09:36:04 <CosmicRay> <grin>
09:41:22 <Tue13823> wow monochrom
09:41:35 <Tue13823> when will you be signing a copy for me
09:41:37 <Tue13823> :)
09:49:30 <Steelmamba> quiet yet again
09:51:12 * Tue13823 sees a small desert bush blowing across
09:52:16 * basti_ watches it get dragged along under tue's pickup
09:52:38 * basti_ sees it catch fire due to the heat of the motor
09:52:46 * Tue13823 smells bacon
09:53:19 * basti_ gets his knife
09:55:49 <Steelmamba> the file clearly roasted the rabbit that was stuck under the pickup
09:55:56 <Steelmamba> *fire
09:56:09 * Tue13823 takes a leak and leave this chan
10:14:08 <Lemmih> Greetings SyntaxNinja.
10:16:14 <SyntaxNinja> hi Lemmih
10:21:55 * SyntaxNinja parties it up in #haskell
10:21:57 <SyntaxNinja> @seen shapr
10:21:58 <lambdabot> I saw shapr leaving #haskell 2 hours, 19 minutes and 33 seconds ago.
10:22:05 <SyntaxNinja> he is elusive
10:22:10 <beelsebob> okay, that new apple mouse is way too over the top
10:22:12 <SyntaxNinja> maybe he's keeping normal hours
10:22:16 <SyntaxNinja> beelsebob: link?
10:22:23 <beelsebob> apple.com/mightymouse
10:22:32 <beelsebob> 1 button
10:22:39 <beelsebob> ... but 4 buttons
10:23:08 <SyntaxNinja> sfw?
10:23:13 <SyntaxNinja> ;)
10:26:26 <beelsebob> sfw?
10:28:18 <lament> "Explore the farthest reaches of your files with one hand tied behind your back"
10:28:27 <lament> awesome!
10:52:41 <CosmicRay> lament: what are you speaking of?
10:53:21 <lament> CosmicRay: that's from the mighty mouse page.
10:53:29 <CosmicRay> ah. heh
10:53:44 <CosmicRay> hi metaperl
10:54:02 <_metaperl> CosmicRay: hi!
10:54:13 <_metaperl> still chugging thru SJT's text
10:54:49 <CosmicRay> how far are you?
10:55:26 <samc> I liked: "Alas the fate of the one-button mouse in today’s multibutton world."
10:56:07 <Beelsebob> heh
10:56:22 <Beelsebob> except it's *still* a 1 button mouse
10:56:26 <Beelsebob> if you want it to be
10:56:31 <Beelsebob> or know no better
10:58:08 <wilx> The wolf has been fed and the goat stays unharmed.
10:58:45 <SyntaxNinja> if anyone could invent a six-button-mouse-but-wait-its-still-one-button, it would be apple.
10:59:41 <wilx> I don't doubt they will one day.
10:59:49 <wilx> Now that they have broken the taboo :D
11:03:12 <CosmicRay> SyntaxNinja: now all we need is a *use* for such a mouse.
11:06:06 <SyntaxNinja> CosmicRay: maybe you can control your ipod and your ibook and imac with a single pointer device, and get rid of hte keyboard altogether.
11:06:13 <CosmicRay> heh
11:06:32 <thedward> I never use those pesky letters anyway
11:06:45 <Beelsebob>  or maybe you could put an optical sensor under your keyboard
11:06:45 <CosmicRay> just give me a vt100.  with it, one can control the world.
11:06:51 <Beelsebob> fear my 113 button mouse!
11:06:54 <CosmicRay> heh
11:07:30 <thedward> I want to learn to type EEG
11:07:34 <thedward> via EEG, that is
11:07:41 <SyntaxNinja> Beelsebob: sfw == safe for work
11:07:47 <Beelsebob> ah
11:07:56 <SyntaxNinja> thedward: you are well on your way to typing EEG.
11:07:59 <Beelsebob> you thought apple's site wouldn't be sfw?
11:08:13 <SyntaxNinja> note the winky face, indicating a joke.
11:08:40 <CosmicRay> either that, or a tick indicative of insanity.
11:08:42 <CosmicRay> but probably a joke.
11:08:43 <jlouis> put a track ball under the keyboard
11:08:45 <jlouis> yay!
11:08:53 <CosmicRay> jlouis: duct tape to the rescue
11:08:55 <SyntaxNinja> I was thinking something like, computer pr0n, meaning... apple's site
11:09:36 <CosmicRay> shapr was here earlier
11:10:42 <Beelsebob> heh
11:10:53 * Lemmih has to fight the urge to hack Yide (Yide Is Defusing Emacs) after reading SDM's paper about vshaskell.
11:11:30 <SyntaxNinja> CosmicRay: is he like, keeping normal hours or something?
11:11:37 <CosmicRay> dunno
11:11:43 <CosmicRay> maybe he has some paid project again
11:11:45 <SyntaxNinja> I've alwsas wondered, "how can someone in sweden keep the same hours as me?"
11:12:55 <Beelsebob> vshaskell?
11:13:02 <Beelsebob> @google vshaskell
11:13:04 <lambdabot> http://www.mail-archive.com/cvs-all@haskell.org/msg19658.html
11:13:41 <Lemmih> Beelsebob: Haskell plugin for Visual Studio.
11:13:48 <Beelsebob> ah, okay
11:14:04 <Beelsebob> hmm, I was thinking of doing one for XCode... didn't think there'd be a paper in it
11:14:17 <Beelsebob> don't think I have time right now either
11:14:20 <_metaperl> vshaskell? SDM?
11:14:29 * _metaperl feels out of date...
11:17:00 * Beelsebob goes to play bridge
11:20:03 <CosmicRay> hmm.
11:20:12 <CosmicRay> _metaperl: I don't know either
11:20:36 <CosmicRay> SyntaxNinja: the answer must be in the unicycling.
11:20:44 <Lemmih> SDM = JaffaCake.
11:23:35 <SyntaxNinja> Lemmih: you trying to tujrn simonMar into a tla?
11:25:37 <Lemmih> SDM /= JaffaCake?
11:25:37 <pejo> Lemmih, heh, is vshaskell = visual Haskell?
11:26:06 <Lemmih> pejo: Yes.
12:14:46 <wagle> i need a good word for the process of taking a datastructure consisting of many pieces, linked together, to a single opaque one...
12:15:34 <_metaperl> wagle: compositing?
12:15:47 <_metaperl> gestalting?
12:15:51 <_metaperl> monolithing?
12:15:54 <_metaperl> facading?
12:17:32 <liyang> anamorphism?
12:17:43 <samc> black-boxing?
12:17:46 <wagle> hmm..
12:18:02 * wagle has to wander off to the dentist
12:21:13 <BigDuke> isnt that like folding?
12:22:00 <BigDuke> liyang, isnt an anamorphism the opposite ?
12:29:19 <ski> wagle : i think what you describe is catamorphism ("fold")
12:29:48 <ski> (anamorphism is indeed unfold)
12:32:02 <liyang> BigDuke: depends which way you look at it.
12:32:40 <BigDuke> yeah i'd say taking smaller parts and combining them is cata and taking something which you break up is ana....
12:32:43 <BigDuke> was just wondering
12:32:55 <liyang> It's a catamorphism on lists (if wagle's `many pieces' are in the form of lists) but an anamorphism on his `opaque' type.
12:33:40 <BigDuke> ow sure, it's all about the direction indeed :)
12:33:44 <lispy> hehehe, http://haskell.org/hawiki/MonadicStyleTransformation  plusPF = (.(.)) . ((.(.)).) . (.) . (.(.(+)))
12:34:12 <ski> liyang,BigDuke : imo s/direction/focus/
12:34:13 <BigDuke> @type (.(.)) . ((.(.)).) . (.) . (.(.(+)))
12:34:18 <lambdabot> forall c a c1 c2.
12:34:18 <lambdabot>               (Num a) =>
12:34:18 <lambdabot>               ((a -> c1) -> c2) -> ((a -> c) -> c1) -> (a -> c) ->
12:34:18 <lambdabot> c2
12:34:52 <liyang> ski: as I'd said. :)
12:34:57 <BigDuke> focussing on a direction then?
12:34:58 <CosmicRay> hmm.
12:34:59 * liyang concurs with ski 
12:35:01 <BigDuke> :)
12:35:09 <CosmicRay> someday I should write some haskell code to help with geocaching in some way.
12:35:10 <BigDuke> the type looks rather more useful
12:35:18 <ski> liyang,BigDuke : i.e. which type are focus on, i.e which are the recursion structered around .. if input type, you have catamorphism with induction/recursion, otherwise with output result you have coinduction/corecursion
12:35:26 <Leimy> is there a Haskell web application server?
12:35:57 <ski> BigDuke : focussing on a type, for recursing over
12:36:22 <CosmicRay> Leimy: yes, simon marlow wrote one
12:36:58 <BigDuke> what is it called?
12:37:21 <Heffalump> I'm not sure "Haskell web server" counts as a web application server.
12:37:28 <Heffalump> hws with dynamic loading, possibly.
12:43:10 <Igloo> CosmicRay: Help with geocaching in what way?
12:43:14 <boegel> is the ICFP contest over yet ? does anybody know ?
12:43:22 <BigDuke> yeah i won
12:43:27 <boegel> you did ?
12:43:37 <BigDuke> yeah, it was so awesome
12:43:41 <boegel> or are you just playing with me ?
12:43:45 <BigDuke> all the naked girls congratulating me
12:43:50 <boegel> what was it about ? :)
12:44:03 * boegel only needs one naked girl
12:44:05 <BigDuke> smearing that whipped cream allover their body forcing me to lick it
12:44:29 <boegel> whipped cream isn't nice, that becomes sour on a female body
12:44:36 <boegel> try choco paste
12:44:43 <boegel> (if that's the correct word :s)
12:44:54 <liyang> chocolate syrup
12:44:56 <boegel> probabl not :)
12:45:00 <boegel> close :p
12:45:06 <BigDuke> it does not get sour
12:45:12 <boegel> yes it does
12:45:16 <BigDuke> no it doesnt
12:45:24 <boegel> it starts to stink after like 2 minutes or so
12:45:30 <boegel> s/stink/smell
12:45:36 <BigDuke> @hugs iterate "no it doesnt"
12:45:37 <CosmicRay> Igloo: I don't know.  It just seems that there would be some fun way to involve Haskell.
12:45:37 <boegel> it's just not nice
12:45:42 <lambdabot> Couldn't match `a -> a' against `[Char]'
12:45:56 <BigDuke> hmm
12:46:02 <BigDuke> @type iterate
12:46:04 <lambdabot> forall a. (a -> a) -> a -> [a]
12:46:11 <boegel> @hugs show $ iterate "no it doesnt"
12:46:12 <lambdabot> Couldn't match `a -> a' against `[Char]'
12:46:14 <Igloo> Heh. Sounds a bit like "Have hammer. Have wood. Must find nail!" to me  :-)
12:46:18 <BigDuke> @hugs repeat "no it doesnt"
12:46:21 <lambdabot> ["no it doesnt","no it doesnt","no it doesnt","no it doesnt","no it
12:46:21 <lambdabot> doesnt","no it doesnt","no it doesnt","no it doesnt","no it doesnt","
12:46:21 <lambdabot> no it doesnt","no it doesnt","no it doesnt","no it doesnt","no it
12:46:21 <lambdabot> doesnt","no it doesnt","no it doesnt","no it doesnt","no it doesnt","
12:46:21 <lambdabot> no it doesnt","no it doesnt","no it doesnt","no it doesnt","no it
12:46:24 <lambdabot> doesnt","no it doesnt","no it doesnt","no it doesnt","no it doesnt","
12:46:26 <lambdabot> no it doesnt","no it doesnt","no it doesnt","no it doesnt","no it
12:46:28 <lambdabot> [24 @more lines]
12:46:39 * boegel poofs
12:46:48 <BigDuke> :D
12:47:18 <ski> @eval cycle "BigDuke : \""no it doesnt\"\n"
12:47:19 <lambdabot> parse error on input `\'
12:47:27 <ski> @eval cycle "BigDuke : \"no it doesnt\"\n"
12:47:29 <lambdabot> "BigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"
12:47:29 <lambdabot> no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\
12:47:29 <lambdabot> "\nBigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke :
12:47:29 <lambdabot> \"no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"no it
12:47:29 <lambdabot> doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\"\
12:47:31 <lambdabot> nBigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"
12:47:32 <lambdabot> no it doesnt\"\nBigDuke : \"no it doesnt\"\nBigDuke : \"no it doesnt\
12:47:34 <lambdabot> [24 @more lines]
12:47:38 <BigDuke> hehehe
12:47:57 <BigDuke> see boegel, there's your proof that whipped cream doesnt get sour on a women's body
12:48:44 <boegel> have you tried it ?
12:49:04 <BigDuke> i dont have a women's body
12:50:17 <boegel> you poor thing :p
12:52:19 <autrijus> Heffalump: hey, can you give me the url to yoru perl5embed again?
12:55:20 <ski> (BigDuke : that only states (infinitely many times) that BigDuke thinks "no it doesnt" is correct. it doesn't actually say that that is indeed the case :)
12:57:17 <BigDuke> actually ski, it just states that i said "no it doesnt"
12:57:27 <ski> yes
12:57:41 <ski> (which was a reply ..)
13:00:53 <Heffalump> autrijus: http://urchin.earth.li/darcs.cgi/antibuddha/?c=browse / darcs get http://urchin.earth.li/darcs/antibuddha
13:01:14 <autrijus> okay.
13:01:26 <autrijus> not going to rename it to antiplargleflarp?
13:01:39 <Heffalump> buddha got changed back :-)
13:01:49 <autrijus> I know :)
13:01:55 <autrijus> (but the plargleflarp page remains)
13:02:03 <Heffalump> oh, I hadn't realised
13:02:06 <Heffalump> but anyway, no :-)
13:02:26 <ski> pralfelgrlap
13:02:46 <autrijus> gmake: execvp: ./hscp2hsc: Permission denied
13:02:56 <Heffalump> there's some problems with using perlStop, btw; when I try to do that as a finalizer on the perl instance and iterate the main loop, it ends up segfaulting
13:02:58 <autrijus> did I mention darcs's nonpreservation of +x is silly?
13:03:01 <Heffalump> it is.
13:03:21 <Heffalump> silly, that is
13:03:24 <autrijus> :)
13:03:29 <autrijus> Perl/Core_hsc.c:4:3: #error "Perl must be built with -Dmultiplicity"
13:03:34 <Heffalump> ah.
13:03:38 <autrijus> oh joy
13:03:50 <Heffalump> that's not an absolute restriction, but we run into the design issues I have now.
13:04:16 <autrijus> hm, no autoprobing
13:04:20 <Heffalump> not yet, no.
13:04:25 <autrijus> the build system really needs some work. I'll see what I can do.
13:04:37 <Heffalump> cool, thanks.
13:04:54 <wagle> the idea was to turn (Pair (Symbol "lambda") (Pair (Pair (Symbol "x") (Pair (Symbol "y") Nil)) (Pair (Symbol "+") (Pair (Symbol "x") (Pair (Symbol "y) Nil)))))
13:04:57 <Heffalump> what kind of autoprobing do you have in mind?
13:05:50 <autrijus> when I comment it out it does
13:05:50 <wagle> into (Lambda (Formals (Ide "x") (Ide "y")) (Prim+ (Ide "x") (Ide "y")))
13:05:50 <autrijus> $ ./test/main
13:05:51 <autrijus> starting perl
13:05:51 <autrijus> Segmentation fault
13:05:59 <autrijus> Heffalump: the usual Config.pm kind.
13:06:09 <autrijus> Heffalump: ExtUtils::Embed
13:06:18 <Heffalump> sorry, when I said "that's not an absolute restriction", I meant "it ought to be possible to fix Core.hscp not to need it, but I haven't done that yet"
13:06:37 <autrijus> ah. ok.
13:06:43 <autrijus> I misunderstood
13:06:44 <Heffalump> ExtUtils::Embed isn't all that helpful, though.
13:06:58 <Heffalump> the design issue is to do with whether it supports multiple interpreters at all.
13:06:59 <autrijus> at least it can get you a working PERLLD.
13:07:03 <autrijus> nodnod.
13:07:23 <autrijus> I know. all perl embedders must supply two faces
13:07:28 <autrijus> one for multi and one for non-
13:07:31 <Heffalump> I'd really like it to, but working out precisely how to make a Core.hsc support both having an implicit PerlInterpreter and an explicit one is tricky.
13:07:32 <autrijus> see modperl for example
13:07:33 <lispy> wagle: what are you talking about?
13:07:42 <Heffalump> ah, can you summarise what that does?
13:08:19 <autrijus> Heffalump: by having a uniinterpreter interface that forces multiplicity into one
13:08:35 <autrijus> and a multiinterp face that demands multiplicity
13:08:40 <autrijus> and you can't use them simultaneously
13:08:43 <Heffalump> ah, I see.
13:08:47 <autrijus> it's sane
13:08:51 <autrijus> and usually what the user wants
13:08:54 <Heffalump> yes, that's the route I'd want to go too, but I'd want to autogenerate both from the same source.
13:09:00 <autrijus> they do that
13:09:03 <Heffalump> ok.
13:09:04 <autrijus> but I don't grok that magic.
13:09:10 <autrijus> has something to do with ParseXS.
13:09:19 <wagle> lispy: 12:15 < wagle> i need a good word for the process of taking a datastructure
13:09:22 <wagle>                consisting of many pieces, linked together, to a single opaque
13:09:24 <wagle>                one...
13:09:36 <Heffalump> I expect hscp2hsc could be persuaded to do what I need.
13:09:45 <Heffalump> How important is a uniinterpreter interface to you?
13:10:12 <autrijus> well, my perl isn't multiplicity
13:10:22 <Heffalump> so very :-)
13:10:22 <autrijus> I suspect half the world isn't
13:10:27 <autrijus> right :)
13:10:34 <Heffalump> really? I was guessing most of the world would be since Debian is.
13:10:37 <wagle> while i was at the dentist, i thought of" weld, glue, anneal, reduce, ..
13:10:49 <Heffalump> (not that half the world is running Debian, but I'd have thought that most modern distros would be doing the same thing)
13:11:10 <autrijus> fbsd here :)
13:11:20 <Heffalump> well, I'd think of that as a modern distro..
13:11:41 <wagle> perhaps its a catamorphism, but i'm looking for a good/provocative name for a particular function (method) that does this
13:12:07 <autrijus> Heffalump: I think it has something to do with bias toward speed and static linking and non threading
13:12:14 <Heffalump> ah, ok
13:12:25 <autrijus> i.e. I can rebuild with flags easily
13:12:29 <autrijus> but the default is usually very vanilla
13:12:31 <Heffalump> hmm. This is certainly not trivial, because Embed.hs needs to know what to do too.
13:12:43 <autrijus> indeed. if you can throw in a bunch of comment andor pseudocode there
13:12:48 <Heffalump> I guess I should make PerlInterpreter be an alias for () in the uniprocessor world.
13:12:51 <lispy> wagle: actually i meant with all the (Pair ...) stuff, that looked like representing lisp in haskell ;)
13:12:54 <autrijus> that'd help
13:12:55 <autrijus> Heffalump: yes
13:13:30 <Heffalump> anyway, I certainly can't do anything tonight, because I am short of sleep and have a meeting tomorrow morning. Chances are it'll be the weekend before I have time for a proper go at it.
13:14:37 <Heffalump> I wonder if doing type PerlInterpreter = (), then subverting pTHX_ in uniinterpreter world to add a dummy first parameter rather than have no interpreter parameter at all would work
13:15:00 <Heffalump> otherwise all the foreign imports will be wrong
13:15:26 <Heffalump> I don't mind an inefficient hack for now, but I want there to be a clear path to an efficient version too.
13:18:54 <autrijus> that path may involve #ifdef
13:20:11 <Heffalump> did you read the README?
13:21:18 <wagle> lispy: yesterday, i dusted off my scheme-interpreter-in-java that i wrote in 1998...
13:21:28 <lispy> wagle: cool
13:21:44 <lispy> wagle: i got lambda applications working, and then used it to implement let ;)
13:22:35 <autrijus> Heffalump: I did
13:22:51 <autrijus> but it's past 4am and my mind is not in the zone anymore :)
13:22:52 <ski> wagle : catastrophe ? collapse ?
13:24:07 <ski> (wagle : maybe you could tell more what the method should do ..)
13:24:10 <wagle> i found that it didnt work..  slowly, its been coming back to me that i had had a cool idea (related to what i described above) on how to transform s-expressions into program-expressions, but most of the way through, I got lost..  emacs was a very lousy tool for manipulating large soups of tiny methods..  so i waited for a good IDE..  now i'm charging ahead with eclipse..
13:25:21 <wagle> one of the problems i had remembering what i was doing was that i had conflated macro expansion with the recognition of keywords like lambda, set!, if, etc
13:26:32 <wagle> so i called that expand (and the methods named "expand", and the class hierarchy had names with "Expander" suffixes
13:27:28 <wagle> ski: see my (Pair (Symbol "Lambda") ...) => (Lambda ...) transformation example above?
13:27:33 <Heffalump> autrijus: no problem. The basic point was that the interfaces I want to expose to end-users will be what goes in Embed.hs, not Core.hs
13:28:07 <Heffalump> and interfaces that make the PerlInterpreter an implicit part of the context anyway should be nicely portable between the two views
13:29:07 <ski> wagle : hm, dequote ?
13:29:12 <wagle> i think i wanted to conflate the two, since the next step would experiment with regular macros as value -> value, and with macros as value -> expr, or expr -> expr
13:30:54 <wagle> one problem i have with obsessive-compulsive macro expansion is that it imagines that its doing expr -> expr, when its actually doing value -> value..  but maybe I really wanted value -> expr..
13:31:15 <wagle> s/obsessive-compulsive/hygienic/
13:32:00 <wagle> so if the symbol "lambda" was a value->expr macro, then I could see how that worked
13:32:34 <lispy> wagle: i have no idea how to implement macros
13:32:35 * ski goes to bed
13:32:59 <lispy> wagle: my evaluator only knows about s-expressions and a few special forms
13:33:18 <lispy> my parser-lexer deals with ' and #'
13:33:34 <wagle> lispy: eval e == (run (compile (expand e)))
13:33:40 <lispy> it just transforms it immediately to (quote ...) and (function ...)
13:33:42 <wagle> in scheme
13:34:02 <wagle> in lisp, its much uglier
13:34:07 <lispy> heh
13:34:16 <lispy> well, this is elisp so maybe it's not as hairy?
13:34:26 <wagle> you have nlambda?
13:35:04 <lispy> nlambda?
13:35:40 <wagle> its old lisp's way of doing macro like things
13:36:19 <wagle> something like ((nlambda (e) e) (+ 1 2) foo) == ((+ 1 2) foo)
13:36:22 <lispy> i haven't really lookde into the issue yet
13:36:59 <lispy> i am wondering if i should implement if, let and so on as macros
13:37:57 <lispy> oh, but since you can't use a macro with funcall/apply maybe that's not such a good idea
13:41:29 <palomer> will haskcore let me play midi on my midi keyboard?
13:41:37 <palomer> and read midi from my midi keyboard?
13:44:31 <thou> palomer: well, haskore can create a midi file; that's about as far as it goes
13:44:41 <thou> palomer: it doesn't actually play anything
13:45:23 <palomer> crap
13:45:54 <palomer> is there a haskell library that'll let me play midi?
13:46:57 <CosmicRay> @google haskell midi
13:46:59 <lambdabot> http://www.haskell.org/hawiki/Haskore
13:47:12 <lispy> @google haskell play midi
13:47:13 <lambdabot> http://www.csse.monash.edu.au/hons/projects/2003/Simon.McNeilly/progress.html
13:47:51 <CosmicRay> that wiki page looks good
13:48:27 <CosmicRay> but as far as sending data to/from your keyboard, isn't that the OS device driver's job?
13:48:46 <CosmicRay> (and why owuld you need something specifically in Haskell to do that?)
13:49:32 <thou> palomer: it looks like haskore includes some function to convert a midi file to a haskore music object
13:50:09 <thou> so if you do have foo.midi, you should be able to load it into your program, munge it, and write it back out again
13:50:22 <palomer> can I play it?
13:50:33 <palomer> more importantly, can I receive midi events from my keyboard and play them right away?
13:50:35 <CosmicRay> you can always just call whatever external program to play it, no?
13:50:36 <thou> if you use a separate midi player
13:50:43 <lispy> cat foo.midi > /dev/midi ?
13:50:46 <CosmicRay> why is it important to do this from haskell?
13:50:50 <palomer> CosmicRay: I'd like my program to be OS independent
13:50:51 <thou> doesn't look like it does streaming, but i don't know
13:51:23 <palomer> lispy: it isn't as easy as that
13:51:39 <CosmicRay> audio playback and recording is not OS-independent, anywhere.
13:51:56 <CosmicRay> either you have a Haskell library with a whole bunch of #ifdefs to work with as many different OSs as possible
13:51:59 <CosmicRay> or you do that in your app
13:52:11 <CosmicRay> but different OSs handle music in fundamentally different ways.
13:52:20 <palomer> CosmicRay: java has audio playback, OS indepedent
13:52:51 <CosmicRay> palomer: no, they expose the same API to programmers on the different OSs.  It's not doing the same thing under the hood.
13:53:05 <palomer> who cares what happens under the hood?
13:53:12 <CosmicRay> they're basically using conditional compilation under the hood just the same as you'd have to on haskell
13:53:19 <thou> palomer: there is no hood in haskell
13:53:24 <thou> palomer: htere's no VM
13:53:33 <palomer> so have conditional compilation
13:53:40 <thou> palomer: and no one has written the library you want
13:53:47 <palomer> :/
13:54:01 <CosmicRay> so anyway, my point was: there may not be the library to do this.  however, you can still support multiple platforms by taking the same approach, and using it in your app;
13:54:05 <thou> palomer: you might be able to use SDL
13:54:11 <palomer> SDL?
13:54:13 <CosmicRay> really I think it would be very easy to support Linux
13:54:16 <CosmicRay> not so sure about Windows
13:54:24 <thou> palomer: game development kit
13:54:31 <palomer> CosmicRay: linux midi programming is a bitch
13:54:40 <thou> palomer: it has a sound api
13:54:54 <CosmicRay> well then, ignore me :-)
13:54:56 <thou> i'd be surprised if it doesn't do midi
13:55:12 <wagle> palomer: why is linux midi a bitch? (i was hoping to try that sometime)
13:55:14 <palomer> are there haskell bindings to SDL?
13:55:15 <thou> i think there are some haskell bindings to sdl somewhere
13:55:21 <lispy> thou: then be surprised ;)
13:55:32 <thou> lispy: oooh   :-(
13:55:40 <lispy> there is a software midi sequencer for linux, but i forget the name
13:55:43 <palomer> wagle: it's badly documented, and it's very low level
13:55:47 <lispy> i think SDL tells how to get it
13:56:02 <palomer> there are a couple software midi sequencers for linux
13:56:05 <palomer> one of the is pmidi
13:56:16 <palomer> but I need crossplatformness
13:56:43 <CosmicRay> palomer: but you even have /dev/midi
13:56:49 <palomer> wagle: if you're used to doing relatively low level code based on poor documentation, then linux midi programming isn't that bad
13:56:50 <lispy> palomer: how cross?  just linux/mac/windows?
13:56:51 <CosmicRay> palomer: doesn't that remove the need for all sorts of other stuff?
13:57:00 <palomer> CosmicRay: no way!
13:57:01 <SyntaxNinja> CosmicRay: HWN looks good.
13:57:02 <wagle> palomer: hoho
13:57:08 <CosmicRay> SyntaxNinja: thanks
13:57:26 <wagle> HWN?
13:57:55 <Lemmih> palomer: http://scannedinavian.org/~lemmih/SDLstable <- Haskell binding to libSDL.
13:57:57 <palomer> CosmicRay: how do you select the device you want to play on? receive on? how do you play to multiple devices?
13:58:11 <lispy> palomer: i would guess that SDL is as close to true platform independence as you will get and still have a nice lib to work with
13:58:11 <palomer> SDL looks cool
13:58:16 <palomer> I wish someone had told me about it earlier
13:58:23 <CosmicRay> palomer: don't you just use different device nodes in /dev, like usual?
13:58:33 <CosmicRay> or you could use ALSA
13:58:46 <lispy> CosmicRay: but /dev assumse a unix style sytem
13:59:03 <CosmicRay> lispy: I know, I was discussing the linux interface in particular
13:59:23 <palomer> CosmicRay: nono, midi devices don't appear in /dev, unfortunetly
13:59:23 <CosmicRay> anyway, time to run
13:59:30 <lispy> CosmicRay: ah
13:59:35 <CosmicRay> $ ls -l /dev/midi*
13:59:35 <CosmicRay> lrwxr-xr-x  1 root root      11 Oct 28  2004 /dev/midi -> /dev/midi00
13:59:35 <CosmicRay> crw-rw----  1 root audio 14,  2 Oct 28  2004 /dev/midi00
13:59:36 <CosmicRay> ...
13:59:37 <palomer> CosmicRay: I don't see how they would
13:59:44 * CosmicRay disappears
13:59:48 <palomer> CosmicRay: by "device", I mean synth
13:59:50 <lispy> CosmicRay: your sound card must support them
14:00:08 <SyntaxNinja> http://www.cenqua.com/commentator/
14:00:13 <palomer> try playing to midi00, see what happens
14:00:18 <palomer> cat to it
14:02:38 <palomer> it wouldn't be possible for synths to appear in /dev
14:03:59 <lispy> why not?
14:04:02 <palomer> ho ho ho, SDL is very nice
14:04:18 <lispy> you can think Sam Latinga (is that how you spell it?)
14:04:27 <lispy> he works at Blizzard now, iirc
14:04:28 <palomer> s/think/thank
14:04:36 <lispy> ah, yeah, i can't type
14:04:41 <lispy> :)
14:05:16 <palomer> erm, midi devices are linked with midi cables. a device doesn't know its attached to anything. it just sits there. you can tell it to pass events through the cable, but that's about it
14:06:37 <palomer> you could have the first device listed in /dev, but that's about it
14:06:54 <lispy> huh, okay
14:08:26 <palomer> s/devices/synths
14:09:30 <palomer> hrm, it doesn't seem like SDL can do midi input!
14:22:58 * beelsebo1 waves at everyone
14:23:31 * lispy waves back
14:23:59 * lispy goes back to resting against a tree in the shade
14:26:21 <beelsebo1> heh
14:26:36 * beelsebo1 sits around trying to make pretty colours appear
14:27:28 <SyntaxNinja> what are colours? how strange
14:28:05 <beelsebo1> you know... like Purple?
14:28:15 <beelsebo1> I believe the americans call than one Prple though
14:28:27 <lispy> purple?  what a worthless word, it doesn't even rhyme withanything
14:28:49 <lispy> it's almost as bad as orange
14:29:35 <lispy> beelsebo1: we also spell it yo, not you ;)
14:29:45 <lispy> we just don't have u's
14:30:09 <beelsebo1> ah, okay
14:30:23 <beelsebo1> lmst s bd s nx gks
14:30:33 <beelsebo1> wh dnt hv vwls
14:31:34 <lispy> yeah, a lot of people think it's called 'C', but really it's called "Ciao" but K&R were unix geeks
14:35:38 <beelsebo1> hehe
14:40:05 <beelsebo1> we must smell
14:40:35 * lispy checks
14:40:43 <lispy> not *that* bad
15:06:37 <tewk> Trying to compile AccessLogger.hs  Failed to load interface for `ErrorLogger':, yet ErrorLogger.hs is in the current directory, What am I doing wrong?
15:08:10 <lispy> tewk: were there anyth other errors?
15:08:20 <tewk> Nope
15:08:27 <lispy> tewk: or maybe there is a problem with the way the modules are defined?
15:09:02 <thou> are you using --make flag?
15:10:20 <tewk> Nope, this is the hws source from the fptools cvs, Someone on this list gave me hws source from a darcs repo somewhere, but it was missing necessary make files.
15:12:51 <lispy> fptools has been completely moved to darcs, iirc
15:13:03 <tewk> where is the darcs repo?
15:13:15 <lispy> tewk: do you perhaps need to run automake or autogen on the darcs version?
15:13:37 <lispy> tewk: not, sure but it was announced on the darcs-user ml, maybe we can search the archives
15:14:03 <tewk> Thanks
15:14:21 <lispy> the archive is here http://www.abridgegame.org/pipermail/darcs-users/
15:14:24 <lispy> but there is no search
15:14:32 <lispy> i wonder if darcs is on gmane
15:14:40 <tewk> it is
15:14:53 <tewk> http://blog.gmane.org/gmane.comp.version-control.darcs.user
15:23:57 <putter> I would like to say  foo x@(Z _) y = ...  but with the case of  y@(Z _) excluded.  Any thoughts on how?  Thank you.
15:24:39 <Igloo> Handle Z Z first
15:24:53 <liyang> or put a guard on it?
15:24:55 <Igloo> Or you could use a guard not_Z y
15:25:01 <liyang> :)
15:25:23 <putter> There is a catchall  foo x y =... default case, adding a Z Z produces overlap warnings.
15:25:54 <liyang> A guard would be best then.
15:26:18 <putter> ah, create a guard predicate on y and use it as  foo x@(Z _) y | guard y = ... ?!
15:26:18 <liyang> foo x@(Z _) y | not_Z y = ...
15:26:27 <liyang> Yup.
15:26:32 <putter> :)
15:26:36 <putter> My thanks.
15:26:51 <liyang> my pleasure. :)
15:32:58 <Heffalump> adding Z Z shouldn't have produced overlap warnings
15:33:07 <Heffalump> I thought those only happen when one of your cases is actually redundant
15:33:15 <Heffalump> since you might very well be relying on the order of pattern matching
15:33:45 <Heffalump> but if you want your Z Z case to be the same as the catchall one, using a guard is probably best
15:42:21 <putter> Heffalump: I'm not sure just what the Z Z case (foo x@(Z _) y@(Z _) =) is overlapping with (the error message doesnt say).  The two candidates seem to be  foo x@(Z _) y = (the "guarded" case) and foo x y = (the default case).
15:42:51 <putter> err, warning message rather than error.
15:44:15 <Heffalump> and yo uput it above the first two cases?
15:44:30 <putter> Ah, third candidate, a preceeding  foo x y@(Z _) = case.  Since the warning is about Z Z, and the guarded and default cases follow, that's probably it.
15:45:40 <putter> But the guard predicate approach works, so all is well.  Thanks again for your help.
16:16:33 <GeniXPro> Are there any good free tutorials for haskell for people coming from imperitive languages like me
16:16:48 <Beelsebob> check the topic ;)
16:17:05 <Beelsebob> the first step is "forget everything you ever learned about programming"
16:17:10 <GeniXPro> it says logs something
16:17:24 <Beelsebob> third item in the list
16:17:32 <Beelsebob> second even
16:17:43 <GeniXPro> stupid xchat treats taht whole thing like 1 link
16:17:57 <Lemmih> There's also http://www.haskell.org/complex/
16:17:58 <Beelsebob> http://www.haskell.org/learning.html
16:18:04 <GeniXPro> thank you
16:18:50 <Beelsebob> I would recommend SJT's book over any of the online tutorials though
16:18:54 <lispy> @pl putStr . unwords . (\(x:xs) = if x == "-n" then xs else (x:xs++["\n"])) =<< getArgs
16:18:55 <lambdabot> (line 1, column 29):
16:18:55 <lambdabot> unexpected "="
16:18:55 <lambdabot> expecting operator, pattern or "->"
16:19:10 <lispy> @pl putStr . unwords . (\(x:xs) -> if x == "-n" then xs else (x:xs++["\n"])) =<< getArgs
16:19:12 <lambdabot> putStr . unwords . ap (ap (ap . if' . ("-n" ==)) ((. (++ ["\n"])) . (
16:19:12 <lambdabot> :)) . head) tail =<< getArgs
16:19:16 <Beelsebob> hahaha
16:19:23 <Beelsebob> lambdabot's grinning at you
16:19:44 <kaol> @botsnack
16:19:45 <lambdabot> :)
16:21:51 <lispy> @type putStr . unwords . ap (ap (ap . if' . ("-n" ==)) ((. (++ ["\n"])) . (:)) . head) tail =<< System.getArgs
16:21:56 <lambdabot> bzzt
16:22:02 <lispy> @hoogle ap
16:22:04 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
16:22:04 <lambdabot> Prelude.appendFile :: (FilePath -> String -> (IO ()))
16:22:04 <lambdabot> Ratio.approxRational :: RealFrac a => (a -> a -> Rational)
16:22:24 <lispy> @type putStr . unwords . Monad.ap (Monad.ap (Monad.ap . if' . ("-n" ==)) ((. (++ ["\n"])) . (:)) . head) tail =<< System.getArgs
16:22:25 <lambdabot> bzzt
16:22:31 <lispy> oh, stupid if'
16:23:21 <lispy> @type let if' = \x y z -> if x then y else z in putStr . unwords . Monad.ap (Monad.ap (Monad.ap . if' . ("-n" ==)) ((. (++ ["\n"])) . (:)) . head) tail =<< System.getArgs
16:23:22 <lambdabot> bzzt
16:23:26 <lispy> bleh
16:23:30 <lispy> i give up ;)
16:23:55 <Beelsebob> giving up is fun
16:25:00 <lispy> what is the algorithm for the point free transformation?
16:28:49 <TheHunter> @type let if' = \x y z -> if x then y else z in putStr . unwords . Control.Monad.Reader.ap (Monad.ap (Monad.ap . if' . ("-n" ==)) ((. (++ ["\n"])) . (:)) . head) tail =<< System.getArgs
16:28:50 <lambdabot> IO ()
16:29:51 <lispy> TheHunter: so one of the ap's was different than the rest?
16:30:22 <TheHunter> lispy, an easy implementation is lambdabot.Plugins.Pl.Rules.transformM.
16:30:41 <TheHunter> lispy, no, i just had to bring the Control.Monad.Reader instance in scope.
16:32:08 <TheHunter> @type Control.Monad.ap
16:32:10 <lambdabot> forall b (m :: * -> *) a.
16:32:10 <lambdabot>        (Monad m) =>
16:32:10 <lambdabot>        m (a -> b) -> m a -> m b
16:32:17 <TheHunter> @type \x y z -> Control.Monad.ap x y z
16:32:18 <lambdabot> forall t b a.
16:32:18 <lambdabot>             (Monad ((->) t)) =>
16:32:18 <lambdabot>             (t -> a -> b) -> (t -> a) -> t -> b
16:32:24 <TheHunter> @type \x y z -> Control.Monad.Reader.ap x y z
16:32:26 <lambdabot> forall t b a.
16:32:26 <lambdabot>                (Monad ((->) t)) =>
16:32:26 <lambdabot>                (t -> a -> b) -> (t -> a) -> t -> b
16:32:55 <TheHunter> @type (\x y z -> Control.Monad.Reader.ap x y z) :: (t -> a -> b) -> (t -> a) -> t -> b
16:32:56 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b :: forall t
16:32:56 <lambdabot>                                a
16:32:56 <lambdabot>                                b.
16:32:56 <lambdabot>                             (t -> a -> b)
16:32:56 <lambdabot>                             -> (t -> a)
16:32:58 <lambdabot>                             -> t
16:33:00 <lambdabot>                             -> b
16:33:19 * lispy boggles
16:33:46 <TheHunter> it's not that bad.
16:34:40 <TheHunter> i actually wanted to show you the output from ghc-6.5, but my lambdabot isn't compiled right no.
16:34:45 <TheHunter> *now
16:35:13 <lispy> it's different in 6.5?
16:35:40 <TheHunter> the output of :t is differently formatted.
16:50:26 <dons> moin
16:52:37 <lispy> moo
16:54:03 <Beelsebob> moo
16:54:31 <lispy> did you ever play the cow level in diablo2?
16:54:47 <lispy> it was a bit of an easter egg...
16:55:45 <TheHunter> moin
16:56:21 <TheHunter> why is it so goddam difficult to order something by credit card in the us?
16:56:49 <Beelsebob> sounds much like the dear level in Myst II
16:57:16 <Beelsebob> deer*
16:57:29 <Beelsebob> mostly got one of the old maps... but covered in dear
16:57:31 <Beelsebob> deer*
16:57:40 <Beelsebob> and 4 guys with blunderbusses
16:57:58 <kaol> @google cowhive
16:57:59 <lambdabot> http://www.danyey.co.uk/sketch3.php
16:57:59 <Beelsebob> this was all well and good until you realised that some of the deer were rigged with explosives
16:58:21 <Beelsebob> and if you shot one of them, all the other rigged ones started running towards you
16:58:35 <lispy> Beelsebob: heh, in diable2 it was this huge open level with literally hundreds of tall biped cows that would come at you with various polearms.  The sounds sounded like the dev team had recorded themselves say, "moo" in silly ways.  It's a riot :)
16:58:44 <kaol> yuck, the link that google gave around here was much more meaningful
16:58:48 <Beelsebob> lol
16:59:01 <Beelsebob> Myth II I meant anyway
16:59:14 <kaol> @google cowhive nethack
16:59:16 <lambdabot> http://www.nicolaas.net/dudley/index.php?f=20040902
16:59:22 <Beelsebob> http://www.icandrawbetterthanyou.co.uk/sean/hearingaids.jpg
16:59:33 <Beelsebob> seeing as we seem to be in silly mode
16:59:33 * kaol goes back to code perl
17:00:08 <kaol> perl is indeed silly
17:00:30 <Beelsebob> heh, could have told you that
17:00:39 <bourbaki> moin
17:01:37 <bourbaki> has anyone of you ever had the insane idea to transport arrows to c++?
17:01:50 <Beelsebob> that does sound insane
17:02:01 <Beelsebob> why would you want anything to do with C++?
17:02:11 <lispy> heh
17:02:20 * lispy usually prefers C over C++
17:02:33 <bourbaki> have a look at this
17:03:21 <GeniXPro> why does the following code yield a syntax error at = p1, p2 :: (Float, Float, Float)
17:03:22 <GeniXPro>   p1 = (1.0, 2.0, 1.0)
17:03:22 <GeniXPro>   p2 = (1.0, 1.0, 1.0)
17:03:26 <bourbaki> someone in #c++ claims that haskells type system is broken :)
17:03:40 <dons> hehe
17:03:48 <GeniXPro> its ##c++ thank you very much
17:03:51 <dons> that's almost @quoteable
17:04:14 <SyntaxNinja> bourbaki: why is Haskell's type system broken?
17:04:18 <bourbaki> is that ## needed to balance the c in the middle :)?
17:04:27 <GeniXPro> i copied that code from the tutorial but it yields a syntax error at p1 =
17:04:38 <Pseudonym> No, ## is a token paste, silly.
17:04:39 <bourbaki> SyntaxNinja he refuses to tell me but maybe you want to check it out in ##c++ ;)
17:04:58 * Pseudonym usually prefers C++ over C
17:05:00 <GeniXPro> nublet here anyone wanna help?
17:05:07 <dons> oh! it's broken but won't say why :)
17:05:08 <bourbaki> <bourbaki> ciaranm why do you think haskell is a waste?
17:05:10 <Lemmih> GeniXPro: You got the indentation wrong.
17:05:19 <bourbaki> <ciaranm> bourbaki: because it's inferior to lisp in every sense
17:05:30 <GeniXPro> indentation is important? well ok, how do i do it?
17:05:31 <dcoutts__> bourbaki: that's not ciaranm of gantoo fame?
17:05:38 <bourbaki> <bourbaki> ciaranm then tell me why
17:05:40 <dcoutts__> gantoo/gentoo
17:05:40 <bourbaki> no idea :)
17:05:53 <Lemmih> GeniXPro: Don't put space in front of the declarations.
17:05:54 <SyntaxNinja> GeniXPro: what is the comma between p1 and p2?
17:06:02 <bourbaki> <ciaranm> for starters, haskell has a broken type system
17:06:12 <dcoutts__> bourbaki: probably is, he's well know for "speaking freely"
17:06:12 <GeniXPro> ok thanks Lemmih
17:06:16 <bourbaki> <ciaranm> then there's the far less powerful syntax
17:06:16 <GeniXPro> SyntaxNinja, dont ask me :S
17:06:18 <Pseudonym> Unlike Lisp, which doesn't have a type system.
17:06:26 <dons> this is just silly
17:06:31 <Pseudonym> So by definition it can't be broken.
17:06:32 <bourbaki> <bourbaki> ciaranm where is the type system broken?
17:06:39 <dcoutts__> in fact he was suspended from Gentoo for bein a prat. Repeatedly.
17:06:45 <dcoutts__> ignore ciaranm
17:06:55 <bourbaki> <ciaranm> bourbaki: arbitrary constraints that are totally unnecessary
17:07:03 <GeniXPro> hes dumb
17:07:08 <SyntaxNinja> GeniXPro: can you use the wiki paste page to paste the entire thing?
17:07:09 <SyntaxNinja> @paste
17:07:10 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:07:15 <bourbaki> <bourbaki> ciaranm i dont think so haskell has a real type system unlike lisp and a lot of other languages like c++ :)
17:07:15 <bourbaki> <ciaranm> bourbaki: that's just it. c++ needs a type system. lisp does not. haskell, being basically an inferior lisp, also does not need one, but has one anyway
17:07:21 <bourbaki> well thats about it :)
17:07:22 <GeniXPro> SyntaxNinja, its working now
17:07:25 <Igloo> He's could be a wise, learned man, aware of the lack of principal types problem in Haskell
17:07:29 <Igloo> But I doubt it
17:07:30 <GeniXPro> SyntaxNinja, but il remember for next time
17:07:37 * Pseudonym doubts it too
17:07:43 <Igloo> :-)
17:07:47 <bourbaki> anyway i try to get some arrow concepts in c++
17:07:49 <Pseudonym> I think principal types are overrated, personally.
17:07:49 <dons> hehehe
17:07:58 <SyntaxNinja> bourbaki: I'm with igloo on this one
17:08:07 <Pseudonym> The type of a function should be what the programmer intends it to be, not some arbitrary generalisation of that.
17:08:21 <bourbaki> http://rafb.net/paste/results/jzRmvj41.html
17:08:29 * lispy hates it when people claim lisp does not have a type system
17:08:31 <SyntaxNinja> bourbaki: sounds to me like he tried programming in Haskell once and couldn't get it to compile, convinced himself that he's smarter than the compiler, and gave up.
17:08:34 <bourbaki> im now able to build objects with that at compile time
17:08:40 <Igloo> You think the compiler should have ESP capabilities?
17:08:42 <bourbaki> in the same way i should be able to build functions
17:08:53 <Pseudonym> lispy: Yeah, I know, but I like thinking down to other peoples' level.
17:08:53 <dons> @quote-add Pseudonym I think principal types are overrated
17:08:54 <lambdabot> Unknown command, try @listcommands.
17:09:05 <dons> @remember Pseudonym I think principal types are overrated
17:09:06 <Pseudonym> Lisp doesn't have a _static_ type system, okay?
17:09:27 <bourbaki> i just need a way to get these types at runtime somehow
17:09:42 <lispy> Pseudonym: that's not true either
17:09:51 <lispy> Pseudonym: not in the case of common lisp
17:10:13 <Pseudonym> I know what you mean by that.
17:10:20 <lispy> okay :)
17:10:32 <Pseudonym> However, I'm a bit of a purist when it comes to static type systems.
17:10:41 <SyntaxNinja> bourbaki: convincing himself that he's smarter than someone or something else is probably what happens before he gives up on stuff ;)
17:10:44 <Pseudonym> If it doesn't have certain properties, it's not a REAL static type system.
17:10:57 <Pseudonym> Even if it happens to constrain types and happens to be static.
17:11:10 <lispy> and what are the properties? being able to prove soundness of typing?
17:11:40 <Pseudonym> The properties are not formally defined in my mind.
17:11:46 <Pseudonym> It's got to LOOK like a static type system.
17:12:18 <Igloo> What does this type system (or not) do?
17:12:21 <Pseudonym> The thing about purism is that you can reason as fuzzily as you like to reinforce your purist worldview.
17:12:41 <Pseudonym> It's also a lot of fun.
17:13:12 <Pseudonym> But seriously, the main property I require of a type system is that most if not all type-related errors are found for me.
17:14:08 <SyntaxNinja> bourbaki: Beelsebob: this conversation on ##c++ is already worth it ;)
17:14:36 <bourbaki> heh
17:14:52 <bourbaki> poor guy
17:15:12 <dons> @seen Lemmih
17:15:13 <lambdabot> Lemmih is in #haskell. Last spoke 9 minutes and 19 seconds ago.
17:15:15 <Pseudonym> I reckon C++ has probably the most complicated type system around.
17:15:39 <Beelsebob> syntaxNinja: are you lurking?
17:15:45 <Pseudonym> When you take templates, implicit casts etc into account.
17:15:48 <dons> oh, Lemmih is here. Lemmih, what's Yide?
17:15:49 <Lemmih> dons: Yo.
17:16:02 <Pseudonym> Writing a type checker for C++ is MUCH, MUCH harder than writing one for Haskell.
17:16:09 <Pseudonym> Even with all the Glasgow extensions.
17:16:15 <Lemmih> dons: Yide is defusing emacs.
17:16:24 <dcoutts__> Yide? sounds like a good name for an ide based on yi :-)
17:16:29 <Lemmih> dcoutts__: Indeed (:
17:16:58 <dcoutts__> what's the plan?
17:17:24 <dons> Lemmih, do tell?
17:17:46 <Lemmih> It's somewhat imaginary right now.
17:17:58 <dons> that's ok :)
17:17:59 <dcoutts__> I've got far too many ideas for a Haskell IDE and not enough time to implement them :-(
17:18:13 <Lemmih> But I hope to steal some code from vsHaskell once it's out.
17:18:18 <dcoutts__> maybe I should just write them down somewhere
17:18:19 <dons> oh!
17:18:26 <dons> but is that code freely available?
17:18:32 <dons> i thought there was an nda or something
17:18:32 <Lemmih> @wiki HaskellIdeIdeas
17:18:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIdeIdeas
17:18:46 <Lemmih> dons: That would suck.
17:18:54 <dcoutts__> Lemmih: yeah, I've added some things to that page already
17:19:30 <dons> actually HaskellIde is the link (?)
17:19:43 <dcoutts__> http://www.haskell.org/hawiki/HaskellIde
17:19:46 <dcoutts__> yep
17:19:52 <Lemmih> Probably. I was just guessing before (:
17:20:20 <Beelsebob> Hmm... he may have run out of arguments
17:20:42 <dons> I agree with all points of the Hide2 plan
17:20:49 <Lemmih> Maybe it's only the code that uses Visual Studio's API that's not OSS.
17:20:58 <dons> it's basically my vision of yi anyway.
17:21:10 <dons> ah, possibly
17:21:25 <dcoutts__> dons: oh good, glad you agree :-)
17:22:13 <dcoutts__> must resist urge to join in the flame fest on ##c++
17:23:07 <dcoutts__> ... must not flame ciaranm... [since he's another Gentoo dev and so I shouldn't flame him :-) ]
17:23:29 <dcoutts__> [ at least not in public :-) ]
17:24:43 <dons> mm. lots of nice stuff in the vshaskell paper
17:25:06 <dcoutts__> yes, I've got high hopes for the new GHC api
17:25:55 <dons> hopefully it comes standard with ghc 6.6
17:26:02 <dons> then we can start writing tools to it
17:26:28 <Igloo> Presumably it will be in flux, though?
17:26:41 <SyntaxNinja> Beelsebob: yeah, lurking.
17:26:52 <Igloo> Or has it been designed more than I have the impression it has?
17:26:54 <SyntaxNinja> it's getting boring though. not concrete enough.
17:26:55 <dons> well, GHC.hs has to be reasonably stable for the vshaskell stuff to work
17:27:16 <Igloo> Hmm, true
17:27:28 <dcoutts__> Lemmih: no don't get involved!
17:27:36 <Igloo> I guess the door is left open to put a nicer interface on top in teh hierarchial namespace, anyway
17:27:53 <dcoutts__> Lemmih: or you're just watching :-)
17:29:34 <Lemmih> I don't want to miss any memorable quotes.
17:29:56 <dcoutts__> heh heh, ciaranm is quite quotable
17:30:07 <dcoutts__> he's a fameous talker in gentoo land
17:30:23 <dcoutts__> it's what gets him suspended
17:30:39 <dons> hmm. vshaskell uses a stripped down alex haskell lexer for colourising a line at a time
17:30:54 <dons> maybe that's a good way to get syntax highlighting in yi in the next week or so
17:31:17 <Igloo> It doesn't work properly, of course
17:31:32 <lispy> vhat is this vshaskell you speak ov?
17:31:49 <dons> really? in what sense doesn't it work?
17:32:06 <Igloo> Block comments, string gaps, literate blocks
17:32:11 <dons> lispy, google for Simon Marlow, look at his publications, and the first paper is one on Visual Haskell
17:32:11 <Lemmih> lispy: Haskell plugins to Visual Studio. The guys at MicroSoft are working on it.
17:32:20 <dons> Visual Studio, that's it.
17:32:28 <dons> Igloo, that's weird
17:32:39 <dons> oh, I guess  line at a time is a big restriction
17:32:39 <Igloo> What's weird?
17:32:40 <dons> hmm.
17:32:43 <lispy> ah, yeah just vshaskell doesn't turn up much
17:33:02 <Igloo> I haven't actually tried it, but if it only looks at lines in isolation then it /can't/ work properly
17:33:10 <dons> yes.
17:33:21 <Lemmih> It did keep an state integer.
17:33:40 <dons> alex is so fast I wonder if it is feasible to do the entire buffer
17:33:45 <dons> (in a background thread)
17:33:53 <lispy> heh, the first other has a gmail address, nice ;)
17:33:56 <dons> src files are small, after all
17:33:59 <Igloo> If it's in a background thread it doesn't matter how fast it is  :-)
17:33:59 <lispy> take that MS! ;)
17:34:15 <Igloo> But you do need to keep a small state per line or something so you can update incrementally
17:34:20 <dcoutts__> dons, I think the trick is that you re-run the lexer until it gets back into the same state at the same place in the file after the change
17:34:42 <dcoutts__> then you know from then on it's the same highliting as before
17:34:50 <Igloo> And you probably don't want to update things too far anyway, as typing "" shouldn't cause 2 complete recalculations
17:35:09 <Igloo> s/need/really really want IMO/ at least  :-)
17:35:16 <dons> igloo, yep.
17:35:55 <Igloo> dcoutts__: And be able to rerun it from the start of the line being changed rather than the start of the file
17:35:58 <dons> so as Lemmih says they keep an Integer state per line to record corresponding to the lexer state (in a comment, in a string etc)
17:36:23 <Igloo> The tricky bit is writing a language in which this can be defined and, e.g., the tex and hs synhlers can be coupled correctly
17:36:25 <dcoutts__> Igloo: yes you can do that by saving the lexer state for the beginning of the line
17:36:35 <Igloo> right
17:37:06 <dons> yeah, though using lexer combinators to write all the lexers would make this easy
17:37:18 <dons> its just conjunction >||< of lexers
17:37:34 <dons> then you coudl say: mymode = tex >||< haskell
17:37:48 <Pseudonym> As interesting as this is, free cakes are calling to me.
17:37:48 <Igloo> Urgle?
17:38:19 <Igloo> You need to explicitly "call" the tex lexer when you hit \begin{code} in a lit Haskell script
17:38:19 <dons> Urgle??
17:38:52 <Igloo> You can't just stick them together and have them fight over the input  :-)
17:38:57 <Igloo> Or have I misunderstood what you meant?
17:39:30 <Igloo> Oh, I mixed up the lexers inteh above line. It's the Haskell one that gets "called", of course
17:39:32 <dons> oh, right. still not hard. the haskell mode does a lexer switch.  (the ctk lexers are a very different model to alex, say)
17:40:15 <dons> so, mymod = tex  , and then the tex mode has a binding: text "\begin{code}" `meta` \state -> switchToHaskell
17:40:20 <Igloo> No, not hard, just a pain to write. But if ctk makes it easy than woot  :-)
17:41:05 <dons> yeah, I would do it in ctk -- all this dynamically extensible stuff is easier in  a dynamically constructed lexer
17:41:26 <dons> however, for now I think I'll grab lexer.x from ghc and try that
17:41:28 <Lemmih> Bah. ##c++ is no fun.
17:42:28 <lispy> Lemmih: well, when i was in there people won't 'listening' to what the other people had to say, or giving arguments that where coherent.  So yeah, no fun :)
17:44:07 <lispy> one thing the haskeller crowd in there had forgotten is that not everyone likes type directed programming, just like not everyone likes OO or FP
17:44:36 <monochrom> there are haskellers in ##c++?
17:45:02 <Beelsebob> many at the moment
17:45:05 <Lemmih> monochrom: Yep, doing missionary work.
17:45:12 <lispy> hehe
17:45:14 <Beelsebob> we're beating up a guy about type checking
17:45:26 <monochrom> this is horrible
17:45:35 <dons> lispy, yeah, but not everyone likes to see the dentist, even though they should ;)
17:46:08 <Lemmih> heh
17:46:11 <lispy> dons: real men program with TMs
17:46:28 <lispy> dons: forget types, forget abstractions, just give me a turing machine....
17:46:59 <dons> this spaghetti
17:47:10 <dons> code view is unfortunately common
17:47:57 <lispy> goto rocks
17:47:58 <dons> I guess a turing machine is just one long piece of fettuccini, to continue my metaphor..
17:48:02 <lispy> 10 PRINT "GOTO ROCKS!"
17:48:05 <lispy> 20 GOTO 10
17:49:13 <GeniXPro> Is haskell unicode friendly?
17:49:36 <dcoutts__> GeniXPro: somewhat
17:49:37 <lispy> iirc, yes. But I'm not an expert in that area
17:49:49 <monochrom> goto_rocks = "GOTO ROCKS!\n" ++ goto_rocks
17:50:10 <dcoutts__> GeniXPro: the worst bit currently is text file IO and unicode in source code
17:50:33 <lispy> dcoutts__: so that's everything isn't it?
17:50:55 <GeniXPro> dcoutts, does the char type store unicode charecters or jsut ascii ones making it require extra effort to use unicode?
17:50:58 <lispy> you can't read in unicode, and you can't have it in the code....I guess you can link with unicode? ;)
17:51:05 <dcoutts__> lispy: well the String type is unicode
17:51:08 <dons> Foreign> sizeOf (undefined :: Char)
17:51:08 <dons> 4
17:51:16 <dcoutts__> GeniXPro: yes, Char is unicode
17:51:33 <Igloo> hugs is closer to supporting unicode. I can't remember if it's fully up with the report yet or not.
17:51:38 <dcoutts__> lispy: well Gtk2Hs uses unicode through out :-)
17:51:51 <lispy> dcoutts__: nice, when is that going into dports?
17:51:55 <GeniXPro> dcoutts, well thats good, coming from c++ it requires allot of extra wasited effort to support unicode in programs
17:52:37 <dcoutts__> lispy: 0.9.8.1 will be out within days and a dports thingy has already been tested, it's just waiting on the release
17:53:36 <lispy> dcoutts__: cool
17:53:39 <dcoutts__> GeniXPro: yeah, it's just because the language was designed after unicode came into existance. Retrofitting it is a pain.
17:54:26 <lispy> and in a language like C++ it's even harder to retrofit
17:54:54 <lispy> in haskell most programs don't care about how many bytes things are in memory
18:16:01 <Lemmih> Anyone know how to do a 64bit right shift in x86 assembly?
18:16:16 <Beelsebob> you don't
18:16:24 <Beelsebob> ... unless you want pain
18:18:01 <Lemmih> I'm having a hard time groking the gcc generated assembly.
18:18:58 <dcoutts__> Lemmih: you're talking about x86, not x86-64 right
18:19:13 <Lemmih> Yeah.
18:19:35 <dcoutts__> Lemmih: in that case I reffer you to Beelsebob's earlier answer :-)
18:19:49 <Lemmih> heh
18:23:49 <Lemmih> Who's Ketil Malde on IRC?
18:24:29 <dons> kzm ?
18:26:08 <Lemmih> Thanks.
18:26:14 <Lemmih> @seen kzm
18:26:15 <lambdabot> kzm is in #haskell. I don't know when kzm last spoke.
18:28:14 <GeniXPro> Is this a good way to implement my range function? Im learning here so dont speak in terms of something advanced. http://www.rafb.net/paste/results/bPIkGU11.html
18:29:43 <GeniXPro> im sort of new to this a whole lot of recursion concept
18:30:35 <Lemmih> @plugs let range n = [0 .. n] in range 10
18:30:40 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10]
18:30:59 <Lemmih> @plugs let range n = [1 .. n] in range 10
18:31:01 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
18:31:52 <bourbaki> hey TheHunter
18:32:08 <TheHunter> hey bourbaki
18:32:20 <GeniXPro> hmm
18:32:56 <TheHunter> GeniXPro, don't reverse it, that's expensive.
18:33:36 <GeniXPro> TheHunter, i would then get 5 4 3 2 1 rather
18:33:57 <TheHunter> yes, you need another argument
18:34:38 <Beelsebob> lemmih: what else are you going to do but recurse?
18:34:38 <TheHunter> @plugs let countUp k n | k == n = []; | otherwise = k:countUp (k+1) n; in countUp 0 10
18:34:40 <lambdabot> parse error on input `|'
18:34:55 <Beelsebob> (assuming itteration's out, as it is in a FL)
18:35:00 <TheHunter> @plugs let countUp k n | k == n = [] | otherwise = k:countUp (k+1) n; in countUp 0 10
18:35:01 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
18:36:17 <TheHunter> so the n plays the same role 0 plays in your code.
18:36:49 <GeniXPro> ahh
18:37:02 <wagle> wow..  gcc 3.3.3 cant even do long long multiplies (and doesnt say it cant)
18:37:07 <Beelsebob> and generalised farther:
18:37:08 <Lemmih> Beelsebob: Huh?
18:38:00 <Beelsebob> @plugs let count k n f | k == n = [] | otherwise = k:count (f k) n in count 0 10 (+1)
18:38:01 <lambdabot> Couldn't match `[a]' against `t -> [a1]'
18:38:18 <Beelsebob> buh... what have I done?
18:39:26 <Beelsebob> @plugs let count (k :: a) (n :: a) (f :: a -> a) | k == n = [] | otherwise = k:count (f k) n in count 0 10 (+1)
18:39:27 <lambdabot> Illegal signature in pattern: a
18:39:27 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern:
18:39:27 <lambdabot> a
18:39:27 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern: a ->
18:39:27 <lambdabot> a
18:39:29 <lambdabot>    Use -fglasgow-exts to permit it
18:39:36 <GeniXPro> floader
18:39:37 <GeniXPro> kick
18:39:43 <Beelsebob> bah... silly thing
18:39:46 <GeniXPro> damn fload bot
18:39:50 <dons> weird
18:39:56 <wagle> @plugs let count k n f | k == n = [] | otherwise = k:count
18:39:57 <lambdabot> parse error on input `)'
18:39:59 <Beelsebob> it stops flooding after 5 lines
18:40:01 <wagle>                    (f k) n in count 0 10 (+1
18:40:05 <wagle> stupid paste
18:40:17 <Beelsebob> @plugs let count (k :: a) (n :: a) (f :: (a -> a)) | k == n = [] | otherwise = k:count (f k) n in count 0 10 (+1)
18:40:18 <lambdabot> Illegal signature in pattern: a
18:40:18 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern:
18:40:18 <lambdabot> a
18:40:18 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern: a ->
18:40:18 <lambdabot> a
18:40:20 <lambdabot>    Use -fglasgow-exts to permit it
18:40:28 <wagle> @plugs let count (k :: a) (n :: a) (f :: a -> a) | k == n =[] | otherwise = k:(count (f k) n) in count 0 10 (+1)
18:40:28 <Beelsebob> nope... still badness
18:40:29 <lambdabot> Illegal signature in pattern: a
18:40:29 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern:
18:40:29 <lambdabot> a
18:40:29 <lambdabot>    Use -fglasgow-exts to permit itIllegal signature in pattern: a ->
18:40:29 <lambdabot> a
18:40:32 <lambdabot>    Use -fglasgow-exts to permit it
18:40:44 <TheHunter> @plugs takeWhile (<=10) $ iterate (+1) 0
18:40:45 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10]
18:40:54 <Beelsebob> that too...
18:41:18 <Beelsebob> needs a /= rather than <=
18:41:39 <wagle> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n) in count 0 10 (+1)
18:41:40 <lambdabot> Couldn't match `[a]' against `t -> [a1]'
18:42:00 <TheHunter> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n f) in count 0 10 (+1)
18:42:00 <Beelsebob> @plugs let count k n f = takewhile (/=n) $ itterate f n in count 0 10 (+1)
18:42:01 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
18:42:01 <lambdabot> Variable not in scope: `takewhile'
18:42:16 <Beelsebob> ahh... well spotted hunter
18:42:19 <Beelsebob> @plugs let count k n f = takeWhile (/=n) $ itterate f n in count 0 10 (+1)
18:42:21 <lambdabot> Variable not in scope: `itterate'
18:42:29 <Beelsebob> helps if I can spell though
18:42:30 <wagle> plugs doesnt understand everything
18:42:38 <Beelsebob> @plugs let count k n f = takeWhile (/=n) $ iterate f n in count 0 10 (+1)
18:42:40 <Lemmih> How about a pointless version?
18:42:40 <lambdabot> []
18:42:55 <Beelsebob> @pl let count k n f = takewhile (/=n) $ itterate f n in count 0 10 (+1)
18:42:56 <lambdabot> takewhile (10 /=) (itterate (1 +) 10)
18:42:59 <Beelsebob> there you go
18:43:01 <Beelsebob> :)
18:43:31 <Lemmih> @pl let count k n f = takewhile (/=n) $ itterate f n
18:43:31 <lambdabot> (line 1, column 49):
18:43:31 <lambdabot> unexpected end of input
18:43:31 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
18:43:34 <TheHunter> @pl count k n f = takeWhile (/=n) $ iterate f n
18:43:35 <lambdabot> count = const (ap ((.) . takeWhile . (/=)) (flip iterate))
18:43:47 <TheHunter> @pl count k n f = takeWhile (/=n) $ iterate f 0
18:43:49 <lambdabot> count = const ((. flip iterate 0) . takeWhile . (/=))
18:44:17 <wagle> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n f) in count 0 10 (+1)
18:44:19 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
18:44:29 <wagle> ta duh!
18:44:38 <Beelsebob> hehe
18:44:39 <Beelsebob> yay
18:45:18 <Beelsebob> GeniXPro: note that it now counts up, down, and sideways
18:45:27 <Beelsebob> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n f) in count 10 0 (-1)
18:45:28 <lambdabot> <Plugins.Eval>:1:
18:45:28 <lambdabot>   No instance for (Num (a -> a))
18:45:28 <lambdabot>   arising from use of `negate'
18:45:31 <Beelsebob> bah
18:45:39 <Beelsebob> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n f) in count 10 0 (subtract 1)
18:45:40 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
18:45:46 <Lemmih> You can use succ and pred instead.
18:46:13 <GeniXPro> Beelsebob, i havent been watching the floading but yes i do see that
18:46:38 <TheHunter> @pl subtract 1
18:46:38 <lambdabot> (- 1)
18:46:43 <Beelsebob> lol
18:46:45 <TheHunter> wtf?
18:46:47 <Beelsebob> oh dear
18:47:08 <TheHunter> @pl \x -> x - 1
18:47:09 <lambdabot> (- 1)
18:47:19 <Beelsebob> oh dear oh dear
18:47:34 <TheHunter>  @pl used to say subtract 1...
18:47:44 <TheHunter> must have broken that with my last patch
18:49:07 <GeniXPro> it gives me type errors on this and i dont know how to fix it: http://www.rafb.net/paste/results/5Mzujx81.html
18:49:42 <Beelsebob> because your type has 2 arguments
18:49:46 <Beelsebob> and your function has three
18:49:56 <GeniXPro> but i dont know what the third should be :(
18:50:00 <Beelsebob> range :: a -> a -> (a -> a) -> [a]
18:50:01 <TheHunter> unbelievable that there was no test  case for subtract.
18:50:20 <GeniXPro> thats confusing but ok
18:51:00 <Beelsebob> it takes a start, an end, something to get closer to the end (converting the same type to itself) and produces a list of that same type
18:51:26 <Beelsebob> note that this is applicable to all data types
18:51:55 <GeniXPro> ahhh i like it thanks Beelsebob, TheHunter, lambdabot, wagle, and Lemmih
18:52:22 <Beelsebob> @plugs let count k n f | k == n = [] | otherwise = k:(count(f k) n f) in count 'a' 'z' (chr . (+1) . ord)
18:52:23 <lambdabot> "abcdefghijklmnopqrstuvwxy"
18:52:42 <TheHunter> @plugs succ 'a'
18:52:44 <lambdabot> 'b'
18:52:47 <Beelsebob> oh... okay
18:52:49 <Beelsebob> woops
18:53:13 <GeniXPro> ERROR "test.hs":2 - Cannot justify constraints in explicitly typed binding
18:53:45 <TheHunter> range :: Eq a => a -> a -> (a -> a) -> [a], probably
18:53:58 <Beelsebob> ah, yeh, well spotted
18:54:09 <GeniXPro> thats in the exact code i gave you except with the first line cahnged to what you gav
18:54:16 <Beelsebob> perhaps we should generalise more...
18:54:46 <Beelsebob> @plugs let count k n f st | st k n = [] | otherwise = k:(count(f k) n f) in count 'a' 'z' succ (==)
18:54:48 <lambdabot> Couldn't match `[a]' against `(a -> t -> Bool) -> [a1]'
18:55:16 <Beelsebob> @plugs let count k n f st | (st k n) = [] | otherwise = k:(count(f k) n f) in count 'a' 'z' succ (==)
18:55:17 <lambdabot> Couldn't match `[a]' against `(a -> t -> Bool) -> [a1]'
18:55:23 <GeniXPro> TheHunter, one last question, what does the Eq a => mean.
18:55:24 <Beelsebob> bah... what've I buggered this time
18:55:34 <Beelsebob> geni: it means it's in the Eq class --
18:55:44 <Beelsebob> it can have the (==) opperator applied to it
18:56:01 <Lemmih> Beelsebob: Pass 'st' to 'count' when you recurse.
18:56:08 <Beelsebob> oh yeh
18:56:15 <GeniXPro> so that makes a constraint that forces a to be able to have == done to it?
18:56:16 <TheHunter> GeniXPro, it means that a can only be instantiated for variables that are in the class Eq, such as Int or Char or String, but not for example for the function type (Int -> Int)
18:56:16 <Beelsebob> @plugs let count k n f st | (st k n) = [] | otherwise = k:(count(f k) n f st) in count 'a' 'z' succ (==)
18:56:18 <lambdabot> "abcdefghijklmnopqrstuvwxy"
18:56:30 <Beelsebob> now it doesn't need to be in eq
18:56:45 <Beelsebob> count :: a -> a -> (a -> a) -> (a -> Bool) -> [a]
18:56:58 * Lemmih still prefers ['a' .. 'z'].
18:57:08 <Beelsebob> true... but you can't count in twos
18:57:19 <Beelsebob> @plugs let count k n f st | (st k n) = [] | otherwise = k:(count(f k) n f st) in count 'a' 'z' (succ . succ) (==)
18:57:20 <lambdabot> "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\
18:57:20 <lambdabot> 153\155\157\159\161\163\165\167\169\171\173\175\177\179\181\183\185\
18:57:20 <lambdabot> 187\189\191\193\195\197\199\201\203\205\207\209\211\213\215\217\219\
18:57:20 <lambdabot> 221\223\225\227\229\231\233\235\237\239\241\243\245\247\249\251\253\
18:57:20 <lambdabot> 255\257\259\261\263\265\267\269\271\273\275\277\279\281\283\285\287\
18:57:22 <lambdabot> 289\291\293\295\297\299\301\303\305\307\309\311\313\315\317\319\321\
18:57:24 <lambdabot> 323\325\327\329\331\333\335\337\339\341\343\345\347\349\351\353\355\
18:57:26 <lambdabot> [24 @more lines]
18:57:28 <Beelsebob> woops
18:57:30 <Beelsebob> *g*
18:57:33 <Lemmih> @plugs ['a', 'c' .. 'z']
18:57:35 <lambdabot> "acegikmoqsuwy"
18:57:41 <Beelsebob> oh... didn't know you could do that
18:57:55 <Beelsebob> useful
18:58:01 <Lemmih> @plugs [1, 3 .. 8]
18:58:02 <lambdabot> [1,3,5,7]
18:58:06 <dons>  by the way, @eval == @plugs, and @plugs will probably go away eventually
18:58:09 <Beelsebob> shame you can't do it for primes
18:58:24 <GeniXPro> @eval 1+1
18:58:26 <lambdabot> 2
18:58:31 <GeniXPro> !!!
18:58:32 <Lemmih> Beelsebob: primes?
18:58:47 <Beelsebob> lemmih: generate primes using your neat notation
18:59:15 <Lemmih> Oh primes. I read it as primops /-:
18:59:30 <GeniXPro> ahh your smiley face is abckwards
18:59:37 <GeniXPro> physcho
18:59:37 <Beelsebob> [2,3,5,7,11..1000]
18:59:39 <Beelsebob> *g*
18:59:49 <Beelsebob> @eval [2,3,5,7,11..1000]
18:59:50 <lambdabot> parse error on input `..'
18:59:51 <Beelsebob> hehe
18:59:58 <GeniXPro> Beelsebob, how would one do that with my function
19:00:20 <Beelsebob> geni: you couldn't with yours... you could with the slightly more general one
19:00:50 <GeniXPro> Beelsebob, you can enlighten me if you want
19:00:52 <Beelsebob> let count k n f st | (st k n) = [] | otherwise = k:(count(f k) n f st) in count 0 1000 nextPrime (<)
19:01:16 <Beelsebob> where nextPrime is a function that finds the next prime greater than the number it's given
19:02:39 <TheHunter> @plugs let isPrime n = n > 1 && all (\x -> n `mod` x /= 0) [2..n-1] in filter isPrime [1..100]
19:02:40 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,
19:02:40 <lambdabot> 97]
19:03:17 <Beelsebob> theHunter: true enough
19:03:29 <Beelsebob> didn't say there wasn't an easirer way of doing it
19:03:32 <TheHunter> nooo! lambdabot: Ix{Int}.index: Index (3735552) out of range ((0,89))
19:03:34 <Beelsebob> just said that it was possible
19:04:32 <Beelsebob> [x <- [1..100] . isPrime x] is nicer imho
19:04:50 <TheHunter> no way
19:06:20 <dons> what did lambdabot do, TheHunter?
19:06:32 <TheHunter> nothing, it won't start.
19:06:46 <TheHunter> that's ghc-6.5.20050801
19:06:46 <Lemmih> Using GHC-6.5?
19:06:56 <Lemmih> GHC changed it hi interface.
19:07:04 <dons> it looks like a possible error related to .hi file parsing. could there be wrong .hi files
19:07:07 <dons> oh, yes!
19:07:16 <dons> and hs-plugins hasn't caught up yet
19:07:26 <TheHunter> i see.
19:07:48 <GeniXPro> so here is my totally leet count function does it look nice? http://www.rafb.net/paste/results/wmmLz998.html
19:08:04 <dons> btw, Lemmih. would you like to send me your patch for the hi parser to handle "way" strings properly?
19:08:17 <Beelsebob> geni: it's beautiful
19:08:56 <Lemmih> dons: "way" strings?
19:09:45 <dons> when you were working on hs-plugins + profiling, you found that bug in .hi parsing
19:09:59 <dons> where I assumed some field was an Int?
19:10:15 <dons> I could dive in and find it, or maybe you could send me the patch if it is still around
19:10:32 <Lemmih> Sure, I'll look.
19:10:41 <dons> TheHunter, you need a ghc before 2005/07/28 05:57:14 PDT
19:12:17 <Lemmih> Ah, here is it.
19:12:33 * lispy_ growls at AIM
19:12:55 <lispy_> won't let me on because i'm logged in from work
19:13:45 <lispy_> the whole reason i started using it was for the multiple logon functionality
19:15:34 <GeniXPro> what does  all (\x -> n `mod` x /= 0) do?>
19:16:53 <dons> TheHunter, or we patch the .hi parser (which will have to be done anyway)
19:17:12 <TheHunter> how much did the format change?
19:17:26 <TheHunter> @all (>0) [1,2,3]
19:17:29 <lambdabot> *** "0" gcide "The Collaborative International Dictionary of English
19:17:29 <lambdabot> v.0.48"
19:17:29 <lambdabot>  
19:17:29 <lambdabot>   A dictionary containing a natural history requires too
19:17:29 <lambdabot>   many hands, as well as too much time, ever to be hoped
19:17:29 <TheHunter> @plugs all (>0) [1,2,3]
19:17:31 <lambdabot>   for.                                        --Locke.
19:17:33 <lambdabot> 0 \0\ adj.
19:17:35 <lambdabot> [77 @more lines]
19:17:37 <lambdabot> True
19:17:40 <TheHunter> @plugs all (>0) [1,2,3]
19:17:42 <lambdabot> True
19:17:44 <TheHunter> @plugs all (>0) [-1,2,3]
19:17:45 <lambdabot> False
19:17:58 <GeniXPro> ok thanks
19:18:05 <Lemmih> dons: Sent.
19:18:14 <TheHunter> so all returns True if the predicate holds for every element of the list
19:19:30 <lispy_> @plugs some (>0) [-1,2,3]
19:19:31 <lambdabot> Variable not in scope: `some'
19:19:35 <GeniXPro> the harder part is that free floating function that you made
19:19:45 <TheHunter> @plugs any (>0) [-1,2,3]
19:19:46 <lambdabot> True
19:20:00 <lispy_> ah, any
19:20:08 <TheHunter> @pl \f -> or . map f
19:20:08 <Beelsebob> @plugs many (>0) [-1,2,3]
19:20:09 <lambdabot> any
19:20:09 <lambdabot> Variable not in scope: `many'
19:20:12 <Beelsebob> *g*
19:20:28 <lispy_> @hoogle (a->Bool) -> [a] -> Bool
19:20:29 <lambdabot> Prelude.all :: ((a -> Bool) -> [a] -> Bool)
19:20:29 <lambdabot> Prelude.any :: ((a -> Bool) -> [a] -> Bool)
19:20:29 <dons> TheHunter: the change is small, I think: "  optimise instance for lists: now we record the length first followed
19:20:33 <dons>   by the elements."
19:20:49 <dons> I'll fiix it today sometime
19:21:09 <GeniXPro> so what does this mean (\x -> n `mod` x /= 0)
19:21:13 <TheHunter> ok, great. No need to hurry because of me, though.
19:21:25 <lispy_> GeniXPro: do you krow what \x -> x means?
19:21:38 <GeniXPro> lispy, no but i have a gues
19:21:46 <lispy_> GeniXPro: what is your guess?
19:22:05 <GeniXPro> lispy, creates a function that takes in argument x and has n
19:22:22 <lispy_> GeniXPro: good
19:22:37 <lispy_> GeniXPro: mod in haskell is like % in C
19:22:47 <GeniXPro> modulas i guessed that
19:23:02 <Spark> modulo :)
19:23:18 <lispy_> it it return true if n mod x is not zero, that is n is not divisible by x
19:23:23 <GeniXPro> creates a function that takes argument x and returns whether x modulo x is 0
19:23:43 <lispy_> almost, you have a typo there :)
19:24:11 <GeniXPro> i see that, thanks lispy, Spark
19:24:20 <lispy_> np
19:24:56 <GeniXPro> is (\x -> (n `mod` x) /= 0) the same thing?
19:25:00 <stefanw> dons: http://www.cse.unsw.edu.au/~stefanh/darcs/haskell-cookbook
19:25:55 <Beelsebob> gen: yes... infix application is left associative
19:26:34 <lispy_> the other way wouldn't make sense from the point of view of types
19:26:45 <Beelsebob> indeed
19:26:51 <Beelsebob> because types are right associative
19:27:39 <lispy_> i just meant because x /= 0 is Bool and mod expects integrals not bools
19:28:00 <Beelsebob> oh, I see
19:28:02 <dons> stefanw, cheers
19:28:25 <Beelsebob> yeh... but if it were left associative Haskell would treat it as such and give a type error
19:28:45 <Beelsebob> rather than trying both ways and seeing what took it's fancy
19:29:34 <lispy_> hmm...okay it i think i see what you mean
19:29:50 * lispy_ needs to study type theory a bit more and really learn what it does
19:30:07 <TheHunter> dons, doesn't seem to be too complicated indeed.
19:30:42 <Lemmih> Does the GHC library export its hi parser?
19:31:00 <dons> nope. perhaps it should
19:31:14 <lispy_> seems like a good idea to me
19:31:17 <lispy_> ;)
19:32:26 <TheHunter> dons, you want me to just do it?
19:33:58 <dons> if you've got the time, go for it.
19:34:18 <TheHunter> the biggest problem is the #if, I think.
19:35:39 <dons> hmm. yes. you get __GLASGOW_HASKELL__, so maybe 650 is ok.
19:35:58 <TheHunter> you mean 605?
19:36:10 <TheHunter> compiling lambdabot now...
19:36:38 <lispy_> better get out and push ;)
19:36:58 <dons> you changed the string instance in hs-plugins already?
19:37:16 <TheHunter> yes.
19:37:24 <dons> also, run 'make check' in hs-plugins to check that all the tests are ok.
19:37:37 <bourbaki> i got something like arrows working in c++ :)
19:37:37 <TheHunter> oki.
19:37:39 <bourbaki> http://rafb.net/paste/results/JAoi1R35.html
19:37:41 <dons> there's some interface parsing tests in there
19:37:56 <Lemmih> I wonder if I should go to bed, try to understand some assembly or eat some food.
19:37:59 <Lemmih> @dice 1d3
19:37:59 <bourbaki> http://rafb.net/paste/results/5hjblX19.html
19:38:00 <lambdabot> 1d3 => 1
19:38:10 <dons> yes, 605 is what I mean
19:38:22 <Lemmih> Good night #haskell.
19:38:35 <TheHunter> g'night, Lemmih
19:38:40 <dons> night Lemmih
19:39:28 <TheHunter> foreign_should_fail_illtyped failed, that's ok, i guess.
19:39:51 <lispy_> any darcs hackers around?  I could use some help coding something up....
19:40:02 <GeniXPro> wow, 1378584 reductions seems like a allot just to find all primes between 1 and 1000
19:40:28 <TheHunter> GeniXPro, that was like the worst possible algorithm
19:40:37 <dons> should fails should fail
19:41:09 <TheHunter> yes, that was a stupid remark...
19:41:10 <GeniXPro> there are better algorithms?
19:41:23 <dons> :)
19:41:46 <TheHunter> the sieve or even probabilistic tests
19:42:00 <samc> or even ones in P
19:42:16 <samc> oh heh
19:42:58 <TheHunter> oh, examples/make/remake001_should_fail didn't fail..
19:43:28 <dons> checking what happens with 6.4.1
19:44:12 <TheHunter> @pl \x -> x - 1
19:44:12 <thbot> subtract 1
19:44:13 <lambdabot> (- 1)
19:44:26 <TheHunter> works like a charm :)
19:44:46 <TheHunter> examples/iface/null failed
19:45:03 <lispy_> @eval flip (-) 1 2
19:45:04 <lambdabot> 1
19:45:48 <TheHunter> examples/dynload/should_fail and _1 didn't fail
19:46:13 <TheHunter> examples/makewith/io failed
19:47:27 <TheHunter> examples/makewith/should_fail_0 didn't fail, shall I go on?
19:47:29 <dons>   oh, so the iface test failed.
19:47:59 <dons> I only have the two makewith failures here, due to a preprocessing issue
19:48:42 <dons> though there's a lot of .hi parsing going on with those tests, so seems pretty much ok.
19:49:06 <dons> they may be failing due to changed output of error messages -- which would explain why should fails are wrong
19:49:14 <TheHunter> also, spj tests fail because of ghc-option issues.
19:49:52 <dons> ok, just check out the iface test (could just be formatting again) otherwise i'll follow up the others
19:50:47 <lispy_> @type let y f = y (f y) in y
19:50:48 <lambdabot> bzzt
19:50:51 <TheHunter> -interface "Main" Main
19:50:51 <TheHunter> +interface "unknown" Main
19:50:51 <TheHunter>  module dependencies: A, B
19:50:51 <TheHunter> -package dependencies: base, haskell98, hi
19:50:51 <TheHunter> -import A
19:50:54 <TheHunter> +package dependencies: base-1.0, haskell98-1.0, hi-0.9.10
19:50:56 <TheHunter>  import B
19:50:58 <TheHunter> +import A
19:51:10 <lispy_> @type let y f = f (y f) in y
19:51:12 <lambdabot> forall t. (t -> t) -> t
19:51:18 <dons> right, formatting :)
19:51:28 <dons> and lambdabot works?
19:51:34 <TheHunter> yep.
19:51:37 <dons> darcs send!
19:52:13 <lispy_> @pl let y f = f (y f) in y
19:52:14 <lambdabot> fix (ap id)
19:52:46 <monochrom> @plugs let y f = f (y f) in take 10 (y (\xs -> 1:xs))
19:52:48 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
19:53:42 <TheHunter> dons, sent.
19:54:01 <lispy_> @type \xs -> 1:xs
19:54:03 <lambdabot> forall a. (Num a) => [a] -> [a]
19:54:15 <lispy_> @pl \xs -> 1:xs
19:54:16 <lambdabot> (1 :)
19:54:30 <lispy_> ah
19:54:33 <monochrom> Ha, I wrote too verbosely.
19:54:43 <lispy_> i get it now
19:55:08 <lispy_> @eval fix (ap id) (1 :)
19:55:09 <lambdabot> Variable not in scope: `fix'
19:55:16 <lispy_> @hoogle fix
19:55:17 <lambdabot> List.isPrefixOf :: Eq a => ([a] -> [a] -> Bool)
19:55:17 <lambdabot> List.isSuffixOf :: Eq a => ([a] -> [a] -> Bool)
19:55:26 <monochrom> generally you can replace "let v = ... v ... in v" by "y (\v -> ... v ...)"
19:55:43 <lispy_> monochrom: indeed
19:55:49 <lispy_> what is fix?
19:55:59 <lispy_> i mean the definition
19:56:05 <dons> TheHunter, thanks
19:56:09 <TheHunter> @eval Control.Monad.Fix.fix (Control.Monad.Reader.ap id) (1 :)
19:56:10 <lambdabot> Variable not in scope: `Control.Monad.Fix.fix'
19:56:18 <TheHunter> @type Control.Monad.Fix.fix (Control.Monad.Reader.ap id) (1 :)
19:56:20 <lambdabot> forall a.
19:56:20 <lambdabot>                     (Num a) =>
19:56:20 <lambdabot>                     [a]
19:56:33 <monochrom> yeah, Control.Monad.Fix
19:56:46 <TheHunter> @index fix
19:56:48 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
19:56:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
19:56:48 <lambdabot> Control.Monad.Error
19:57:24 <palomer> hullo monochrom
19:58:16 <lispy_> @eval Control.Monad.fix (Control.Monad.Reader.ap id) (1 :)
19:58:17 <lambdabot> Variable not in scope: `Control.Monad.fix'
19:58:36 <lispy_> @eval Control.Monad.Reader.fix (Control.Monad.Reader.ap id) (1 :)
19:58:37 <lambdabot> Variable not in scope: `Control.Monad.Reader.fix'
19:58:45 * lispy_ *shurg*
19:58:50 <lispy_> i don't get it
19:59:30 <monochrom> @plugs take 10 $ Control.Monad.Fix.fix (1 :)
19:59:32 <lambdabot> Variable not in scope: `Control.Monad.Fix.fix'
19:59:51 <monochrom> I think @plugs deliberately omits Control.Monad.*
20:00:06 <monochrom> for fear of vulnerability
20:00:13 <lispy_> i've used stuff in Control.Monad before
20:00:18 <palomer> someone remind me of that application that verifies invariants and automatically tests code
20:00:30 <lispy_> quickcheck maybe?
20:00:46 <palomer> yeah, that's it
20:00:50 <TheHunter> lispy, fix is not in Control.Monad
20:01:09 <lispy_> @index fix
20:01:10 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer,
20:01:10 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
20:01:10 <lambdabot> Control.Monad.Error
20:01:26 <lispy_> @hoogle fix
20:01:26 <lambdabot> List.isPrefixOf :: Eq a => ([a] -> [a] -> Bool)
20:01:26 <lambdabot> List.isSuffixOf :: Eq a => ([a] -> [a] -> Bool)
20:01:31 <lispy_> yeah, it's weird
20:01:33 <monochrom> Ah!  Control.Monad \not\superset Control.Monad.Fix
20:01:51 <lispy_> er?
20:02:01 <lispy_> @eval Control.Monad.fix (Control.Monad.Reader.ap id) (1 :)
20:02:02 <lambdabot> Variable not in scope: `Control.Monad.fix'
20:02:22 <TheHunter> the current lambdabot has Control.Monad.Reader in its runplugs' imports list, but there are some problems getting that to compile.
20:02:49 <monochrom> fix is inside Control.Monad.Fix but not Control.Monad.
20:04:06 <lispy_> why is that a problem?
20:04:31 <TheHunter> it is not a problem, it just means you can't use it in @plugs
20:06:20 <TheHunter> hmm, would be a good idea to put Test.QuickCheck into @plugs, too.
20:07:33 <dons> that sounds reasonable
20:07:54 <TheHunter> it would however raise the question whether to include Text.Show.Functions ()
20:09:35 * TheHunter wonders if "as to whether ..." is more grammatically correct.
20:10:27 <dons> I think the former is the usual usage
20:10:43 <dons> now, so you wonder what happens when we add: instance Show (a -> b) where
20:11:07 <TheHunter> "as to whether Text.Show.Functions should be included", but it probably sound too formal.
20:11:45 <TheHunter> mabye people would be led to think haskell catches type errors at runtime.
20:11:56 <dons> yes, too formal
20:12:35 <dons> well, we certainly can never add a Show IO instance. that would break the safety. and I'm not sure there's much benefit from having "<function>" printed
20:12:48 <dons> maybe there is. debatable
20:13:13 <monochrom> You can print the Y combinator. :)
20:13:14 <TheHunter> QuickCheck usually needs it.
20:13:53 <dons> oh, ok. well I don't see any other problem.
20:23:09 <samc> @pl sieve (n:ns) = n : sieve (filter (\x -> (x `mod` n) /= 0) ns)
20:23:12 <lambdabot> sieve = fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter .
20:23:12 <lambdabot> flip flip 0 . ((/=) .) . flip mod)) . (.))
20:23:18 <samc> eek
20:24:13 <TheHunter> that's probably a bug :(
20:24:22 <TheHunter> flip flip 0 doesn't seem right
20:24:31 <TheHunter> @type flip flip 0
20:24:32 <lambdabot> forall a c b. (Num b) => (a -> b -> c) -> a -> c
20:24:43 <TheHunter> oh, it's ok.
20:25:19 <TheHunter> @type Control.Monad.fix ((`Control.Monad.ap` tail) . (. head) . Control.Monad.liftM2 (.) (:) . (. (filter . flip flip 0 . ((/=) .) . flip mod)) . (.))
20:25:20 <lambdabot> bzzt
20:25:31 <TheHunter> @type Control.Monad.fix ((`Control.Monad.Reader.ap` tail) . (. head) . Control.Monad.liftM2 (.) (:) . (. (filter . flip flip 0 . ((/=) .) . flip mod)) . (.))
20:25:33 <lambdabot> bzzt
20:25:51 <TheHunter> @type Control.Monad.Fix.fix ((`Control.Monad.Reader.ap` tail) . (. head) . Control.Monad.liftM2 (.) (:) . (. (filter . flip flip 0 . ((/=) .) . flip mod)) . (.))
20:25:52 <lambdabot> forall a.
20:25:52 <lambdabot>                                                      (Integral a) =>
20:25:52 <lambdabot>                                                      [a]
20:25:52 <lambdabot>                                                      -> [a]
20:26:02 <TheHunter> oops.
20:28:57 <lispy_> @type flip flip
20:28:59 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
20:29:15 <lispy_> @type flip flip flip
20:29:16 <lambdabot> forall a c a1 b c1.
20:29:16 <lambdabot>       (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a ->
20:29:16 <lambdabot> c
20:29:24 <TheHunter> @pl flip flip flip flip
20:29:25 <lambdabot> flip flip flip
20:29:38 <lispy_> @pl flip flip flip
20:29:39 <lambdabot> flip flip flip
20:29:48 <TheHunter> @pl flip flip flip flip flip flip flip flip flip
20:29:48 <lambdabot> flip flip flip
20:30:01 <lispy_> @pl flip flip flip flip flip
20:30:02 <lambdabot> flip flip flip
20:30:05 <lispy_> hm....
20:30:20 <lispy_> @pl flip flip flip flip flip flip
20:30:21 <lambdabot> flip flip flip
20:30:32 <lispy_> @type flip flip flip
20:30:33 <lambdabot> forall a c a1 b c1.
20:30:33 <lambdabot>       (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a ->
20:30:33 <lambdabot> c
20:30:50 <lispy_> @type flip flip flip flip flip flip flip
20:30:51 <lambdabot> forall a b c a1 c1.
20:30:51 <lambdabot>              (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 ->
20:30:51 <lambdabot> c1
20:31:05 <lispy_> that seems so odd to me
20:31:34 <samc> @pl f = g where g = h
20:31:35 <blackdog> so how did everyone find the ICFP comp this year?
20:31:35 <lambdabot> (line 1, column 15):
20:31:35 <lambdabot> unexpected "="
20:31:35 <lambdabot> expecting variable, "(", operator or end of input
20:32:00 <TheHunter> @pl let g = f in f = g
20:32:01 <lambdabot> (line 1, column 16):
20:32:01 <lambdabot> unexpected "="
20:32:01 <lambdabot> expecting variable, "(", operator or end of input
20:32:15 <blackdog>  
20:32:22 <TheHunter> @pl let g = f; f = g in f
20:32:23 <lambdabot> fst (fix (uncurry (flip (,))))
20:32:58 <TheHunter> @pl let g = f; f = g in g
20:32:59 <lambdabot> snd (fix (uncurry (flip (,))))
20:33:14 <lispy_> ah, that's cool
20:33:35 <lispy_> @type (fix (uncurry (flip (,)))
20:33:37 <lambdabot> bzzt
20:33:40 <lispy_> @type (fix (uncurry (flip (,))))
20:33:42 <lambdabot> bzzt
20:33:48 <lispy_> stupid fix
20:33:54 <lispy_> I HATE YOU!
20:33:56 <lispy_> ;)
20:34:21 * palomer pets fix
20:34:23 <TheHunter> @type uncurry (flip (,))
20:34:25 <lambdabot> forall a b. (a, b) -> (b, a)
20:35:31 <TheHunter> @pl uncurry (flip (,)) . uncurry (flip (,))
20:35:32 <lambdabot> uncurry (flip (,)) . uncurry (flip (,))
20:37:42 <samc> @plugs let primes = sieve [2..] where sieve (n:ns) = n : sieve (filter (\x -> (x `mod` n) /= 0) ns) in take 20 primes
20:37:44 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
20:39:42 <samc> did anyone else notice haskell was cool
20:43:38 <palomer> nope, sorry
20:44:08 <lispy> samc: hask-what? sorry?
20:44:11 <monochrom> haskell is cool.
20:44:23 <monochrom> rather, haskell was cool.
20:44:40 <lispy> @pl uncurry (flip (,)) . uncurry (flip (,)) . uncurry (flip (,))
20:44:41 <lambdabot> uncurry (flip (,)) . uncurry (flip (,)) . uncurry (flip (,))
20:44:46 <monochrom> he was a cool bird watcher.
20:44:56 <palomer> the new trend is object oriented assembly
20:45:16 <monochrom> I wish I was a colleague of his.
20:45:19 <samc> you mean C++?
20:45:23 <lispy> @pl uncurry (flip (,)) . uncurry (flip (,)) . uncurry (flip (,)) . uncurry (flip (,))
20:45:24 <lambdabot> uncurry (flip (,)) . uncurry (flip (,)) . uncurry (flip (,)) .
20:45:24 <lambdabot> uncurry (flip (,))
20:45:39 <lispy> heh
20:45:45 <lispy> yeah and binary xml
20:45:59 <lispy> wtf is binary xml and why does it sound like a bad idea?
20:47:01 <palomer> quickcheck should use some of the functionality of esml
20:47:10 <palomer> at least the most basic
20:49:10 <lispy> byebye!
20:49:31 <TheHunter> @pl \x -> x - 1
20:49:41 <lispy> (- 1)
20:49:48 <dons> not back yet. seems to take longer to log on
20:50:30 <dons> runIRC: caught exception: connect: timeout (Connection timed out)
20:50:38 <palomer> is forall a. a inhabited by a non bottom type?
20:50:40 <TheHunter> yes, that happens sometimes :(
20:50:46 <dons> scond time round is faster
20:51:08 <dons> nonetheless, it is still paused after finding the hostname
20:51:27 <TheHunter> palomer, no.
20:51:49 <palomer> err, a non bottom element
20:52:06 <TheHunter> @pl \x -> x - 1
20:52:07 <lambdabot> subtract 1
20:52:08 <palomer> I'll have to ponder that
20:52:55 <shrimpx> what does it mean for a type to be inhabited by a type?
20:56:21 <lispy> well, a type can be thought of a set, so maybe it's like membership?
20:56:46 <shrimpx> i think by "non bottom type" he meant "a term other than bottom"
20:57:18 <TheHunter> yes, and he corrected himself
20:57:18 <shrimpx> lispy: also types as sets are evil!
20:57:20 <shrimpx> :)
20:57:31 <palomer> types ARE sets
20:57:34 <palomer> NITWIT
20:57:38 <palomer> there, I said it
20:58:10 <lispy> palomer: you certainly said...something
20:59:04 <palomer> or did I?
20:59:23 <lispy> um....i'm not sure now
20:59:45 <monochrom> types are relations. that's what Phil says.
21:00:46 <lispy> hmm...darcs diff does not behave as i would expect
21:01:25 <lispy> $ darcs diff -u DarcsArguments.lhs ../darcs-unstable/DarcsArguments.lhs
21:01:27 <lispy> darcs: _darcs/current/../darcs-unstable/DarcsArguments.lhs: getSymbolicLinkStatus: does not exist (No such file or directory)
21:01:27 <samc> yeah, set membership relations
21:01:34 <samc> ;)
21:01:41 <monochrom> Talking of which, Phil may also be able to prove that (forall a. a) has the bottom only.
21:02:06 <lispy> bottoms up!
21:04:27 <shrimpx> forall a.a is the universal intersection of all types. so it's inhabited by those elements which are of every type. bottom.
21:09:06 <palomer> who's fill?
21:10:51 <palomer> err, phil
21:14:25 <monochrom> some fictional researcher
21:17:12 <lispy> this is a funny read if youhaven'tseen it yet http://www.venganza.org/
21:22:15 <thou> noodlyAppendage :: [Real] -> [Real]
22:00:53 <palomer> I'm writing a specification language
22:02:35 <palomer> I already have term equality, if..then...else, and, not  in my language (working on or)
22:02:41 <palomer> anyone have anything to add?
22:04:07 <palomer> oh, wait, I can't add or
22:04:08 <palomer> :(
22:04:23 <palomer> damn you intuitionistic logic!
22:05:48 <lispy> palomer: you alright over there? ;)
23:00:26 <reffie> morning
23:35:27 <lispy> hmmm....darcs apply is ignoring _darcs/prefs/defaults
