00:02:20 <astrolabe> Yeah, sorry, it's too early for me.  I'll try to be more complementary with my typos in future.
00:04:46 <boegel> np ;) I'm off to my articles *again
00:22:04 <dons> joelk, oh, I haven't got any support for doing a user install. but suitable flags to ghc-pkg will probably do the trick
00:22:11 <dons> also, you can just use hs-plugins in place if required
00:22:55 <dons> i.e. -package-conf /my/directory/plugins.conf.inplace -package plugins will get you the libs from the hs-plugins build dir
00:24:01 <joelk> in place? how do you tell ghc where to find it?
00:24:03 <joelk> oh!
00:24:08 <joelk> well, I've got it installed in user finally I think.
00:26:33 <dons> ok. if you know enough `make', feel free to submit a patch to create, say, a 'install-user' target
00:26:41 <dons> or 'register-user' perhaps
00:31:31 <joelk> ok, yi is compiling away, so I think I got things moved to the right places.
00:33:37 <joelk> oh yes, I've just spent some quality time getting reaquainted with our old friend, Makefile. also needed to edit the {altdata,hi,plugins}.conf.in files to show ghc-pkg where to look for the libraries.
00:34:30 <dons> right. did you know you can avoid the hs-plugins dependency by: make way=static ?
00:34:51 <joelk> yes, but I'm stubborn like that.
00:34:56 <dons> ok ;)
00:46:27 <joelk> dons, on 18-06-05 you said, "pantheon's his earlier work using TH for optimisations. He's done a new implementation -- panic et al, which uses ghc plugins for optimisations". Where can a dumb physicist go to start learning enough to understand how plugins is used for optimization?
00:48:12 <dons> @seen seafood
00:48:13 <lambdabot> seafood is in #haskell. I don't know when seafood last spoke.
00:48:20 <dons> seafood: ping
00:48:30 <dons> seafood is the guy behind this.
00:48:48 <dons> but the general gist is that we have compiler plugins to do domain specific optimisations of the program
00:50:02 <dons> so rather than just have the default set of optimisations ghc comes with, a library can distribute a ghc plugin to optimise users of its code in specific ways, exploiting domain knowledge
00:55:05 <joelk> That makes sense. Sounds cool. Over my head, but cool. :)
01:01:24 <ski> dons : not just RULES pragmas ?
01:01:54 <dons> yeah, way beyond rules pragmas, which are heavily restricted
01:02:01 <dons> more like an extensible compiler
01:02:21 <joelk> that was my first reaction too, having just discovered RULES :)
01:02:26 <ski> is there any paper/doc/info ?
01:02:38 <ski> hm
01:04:06 <dons> seafood's working on a paper I think. his projects are at http://www.cse.unsw.edu.au/~sseefried/
01:04:20 <dons> the code is in the ghc-pluggable-branch, which you can get from ghc cvs
01:11:57 <incomplete> morning
01:12:30 <vikasg> good morning
02:14:46 <incomplete> @hoogle runReaderT
02:14:54 <incomplete> @index runReaderT
02:14:55 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
02:15:04 <incomplete> @type Control.Monad.Reader.runReaderT
02:15:09 <lambdabot> forall a (m :: * -> *) r.
02:15:09 <lambdabot>             Control.Monad.Reader.ReaderT r m a -> r -> m a
02:15:35 <incomplete> @docs Control.Monad.Reader
02:15:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Reader.html
02:59:54 <vikasg> testing
03:05:24 <boegel> @seen Itkovian
03:05:26 <lambdabot> I saw Itkovian leaving #haskell 8 days, 20 hours, 42 minutes and 9
03:05:26 <lambdabot> seconds ago, and I have missed 3 minutes and 35 seconds since then.
03:05:29 * boegel grrs
03:07:07 <shapr> @yow !
03:07:09 <lambdabot> All I can think of is a platter of organic PRUNE CRISPS being
03:07:09 <lambdabot> trampled
03:07:09 <lambdabot> by an army of swarthy, Italian LOUNGE SINGERS ...
03:14:00 <boegel> shapr: how bittorent ?
03:14:05 <boegel> s/how/how's
03:14:14 <boegel> yo Muad_Dib
03:15:19 <shapr> No progress today, how's code on your end?
03:16:00 <boegel> haven't coded in over 2 months
03:16:17 <boegel> I'm busy reading articles for my Phd work
03:17:07 <boegel> I should continue working on HRay and HaskLS, but I just don't have the time right now
03:17:48 <shapr> Yeah, I'm out of energy to bug people for TMR, so I understand.
03:19:08 <boegel> out of energy ? no ! don't give up TMR !
03:20:17 <shapr> Well, it's either that or find some other people to do part of it.
03:22:07 <boegel> what part ?
03:22:21 <boegel> finding people who want to write articles ?
03:23:04 <boegel> damn, people are calling me for dinner
03:23:33 <boegel> I suggest you mail the Haskell lists to explain the problem you are facing, I'm guessing loads of people love TMR and hate to see it leaving
03:23:39 * boegel out
03:23:47 * incomplete is out of energy in tracking dependencies of libraries.
03:26:35 <poetix> ave
03:26:43 <incomplete> paolo@pi:~/projects/cairo-demo/cairo_snippets$ man libtool
03:26:43 <incomplete> bash: man: command not found
03:26:43 <incomplete> O_O
03:27:32 <poetix> @yow
03:27:33 <lambdabot> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like RICARDO
03:27:33 <lambdabot> MONTALBAN'S HAIR!
03:27:40 <incomplete> Do you know of some system-wide configuration for pkg-config?
03:28:04 <poetix> Lambdabot should have a yiddish plug-in - you could call it oy
03:28:15 <shapr> incomplete: Like pkg-config?
03:29:05 <incomplete> shapr, I mean, I'm hating having to provide PKG_CONFIG_PATH="blah;blah;blah" :-(
03:29:16 <incomplete> (to configure scripts, mainly)
03:30:00 <shapr> There's a utility called pkg-config that's designed so you can do gcc `pkg-config $PKGNAME` mycfile.c
03:30:06 <incomplete> I wonder if there's a configuration file with the "/usr/lib;/usr/local/lib;..." paths specified.
03:30:08 <shapr> I'm not sure if that's what you're looking for.
03:30:35 <incomplete> Yes, configure script use it.
03:30:52 <incomplete> I installed cvs versions of some libs in /opt/name-version directories.
03:31:30 <incomplete> Now I have to do things like: PKG_CONFIG_PATH="/opt/libcairo-0.6.0/lib/pkgconfig" ./configure for program based on cairo.
03:32:29 <incomplete> I wonder if there is a configuration file with the paths it search in.
03:33:15 <incomplete> From the man page: "By default,  pkg-config  looks  in the directory prefix/lib/pkgconfig for these files; it will also look in the colon-separated (on Windows, semicolon-separated) list of directories specified by the PKG_CONFIG_PATH environment variable."
03:40:21 <incomplete> Did I explain the issue in an understandable fashion? :)
03:40:48 <shapr> What's your question exactly?
03:40:55 <vikasg> you want something like ld.so.conf, yes?
03:41:05 <shapr> poetix: How's the job?
03:41:24 <incomplete> vikasg, I added the paths to that file, but it isn't enough.  By the way, yes, something similar.
03:41:26 <poetix> shapr: OK. Dull at the moment
03:41:59 <shapr> Can you use Haskell to do metaops on your C# code?
03:42:12 <incomplete> Maybe I'm acting the wrong way...
03:42:28 <vikasg> looking at the docs there doesn't seem to be any way
03:42:42 <poetix> shapr: That might be interesting.
03:42:51 <poetix> Source or bytecode?
03:43:19 <poetix> I hadn't thought of writing a Haskell C# parser...
03:43:35 <pejo> incomplete, why don't you add the stuff to PKG_CONFIG_PATH at the same place as you add /opt/libcairo-0.6.0/bin to your PATH?
03:44:08 <shapr> poetix: Which one would be easier to start out with?
03:44:25 <poetix> Source I should think. I don't know too much about ILASM
03:45:04 <poetix> Is anyone co-ordinating the various Haskell Perl/Python/PHP parser efforts? Is there a Haskell Parsers Project, or anything like that?
03:46:15 * dblhelix drops in
03:46:40 <incomplete> pejo, I could export PKG_CONFIG_PATH in the ~/.bashrc but it would have been better to have a pkg-config.conf.  I wonder why there isn't one.  I could also ln -s /opt/libcairo-0.6.0/lib/pkgconfig/cairo.pc /usr/local/lib/ ...
03:47:53 <incomplete> poetix, I know c2hs is based on a previous work of the same author (IIRC) which is something like a programming-language-parser library for Haskell to foreign ones.
03:48:27 <dblhelix> shapr: if you're doing metaops on ILASM code, you're in practice doing metaops on all languages targeting the .NET platform
03:49:16 <poetix> incomplete: What would be useful in the first instance is a wiki page with the names of people and projects related to parsing foreign languages in Haskell
03:49:52 <dblhelix> shapr: you would however need to disassemble the bytecode for that, which can be done with a C API from MS that is in fact quite workable
04:06:00 <poetix> http://haskell.org/hawiki/ParsingForeignLanguagesInHaskell <-  a page like this, say...
04:09:33 <ndm> i have on my list of things to do to build parsers for many languages in haskell
04:09:52 <vikasg> would a Scheme parser be useful?
04:09:57 <ndm> like piles of languages, including bibtex, css, html, xml, c, haskell, javascript, ada etc.
04:10:49 <poetix> vikasg: Yes. Should be a fairly simple case...
04:11:46 * vikasg is trying to write a Scheme interpreter in Haskell
04:11:59 <incomplete> Nice one!
04:12:49 <Lor> You can translate the formal semantics in R5RS pretty much verbatim to haskell.
04:13:36 <vikasg> I'm not sure I can understand the formal semantics :)
04:13:56 <poetix> By the time you've translated them to Haskell, you will.
04:14:01 <vikasg> I'm rather following Chapter 4 of sicp
04:14:29 <poetix> vikasg: Is there code?
04:14:32 <vikasg> though there is a long way to go; I don't understand how to implement assignment and side-effects I/O in Haskell
04:14:55 <vikasg> no, it is in very primitive stages; there should be something in a few days
04:15:46 <poetix> If/when the parser code exists in a separate module, could you link to it on the wiki page I just made?
04:16:53 <vikasg> I will as soon as there is something substantial
04:17:01 <pejo> incomplete, system global stuff really messes life up for users on larger systems. Or atleast for the administrators.
04:17:37 <poetix> Thanks - I'd like to see the various foreign language parsing efforts come together to some degree.
04:17:44 <poetix> I should probably be posting on the libraries list about this.
04:18:55 <incomplete> pejo, aww - I would have enjoyed it on my laptop, tough.
04:19:20 <incomplete> poetix, yeah.  IIRC there is something in the standard lib too.
04:28:12 <dblhelix> shapr: remember the friend I told you about? the one who wants to find himself a suitable project for becoming familiar with haskell?
04:32:32 * Beelsebob sits and looks bored
04:37:21 <incomplete> dblhelix, did he found a suitable project?
04:37:47 <dblhelix> incomplete: well, maybe :) we're still discussing that
04:38:49 <dblhelix> anyway, he wrote some (imho) interesting things about it on his blog (http://www.ronkes.nl/blog/?2005-08-05-kickass)... it may be worth reading for us concerned with spreading the joy and educating haskell etc.
04:39:02 <dblhelix> http://www.ronkes.nl/blog/?2005-08-05-kickass that is
04:39:38 <shapr> dblhelix: Yeah?
04:39:52 * shapr reads
04:40:01 <dblhelix> shapr: see my remark to incomplete :)
04:40:38 <shapr> Hm, interesting post.
04:40:51 <shapr> Parsers are definitely the easiest kick ass experience in Haskell.
04:42:06 <dblhelix> shapr: yeah, he will probably do some structured-text processing stuff as his first kick-ass experience, so there will definitely be some parsing in it for him
05:06:15 * shapr throws parapearls at metaperl 
05:06:31 * metaperl smiles
06:08:39 <poetix> Anyone written a Haskell Audioscrobbler wrapper/client?
06:10:12 <thedward> Has someone written a Haskell music/media player that would use it?
06:11:39 <xerox> What could be the purpose of "newtype Foo = Foo (Ptr Foo)" ?
06:12:21 <wilx`> Magic.
06:12:34 <xerox> Please elaborate on that :-)
06:12:45 <dblhelix> is the artist formerly known as xerox again to be called xerox? :S
06:13:01 <xerox> dblhelix, yup! ^_^
06:13:16 <xerox> The other nick was incomplete.
06:13:25 <dblhelix> lol
06:15:37 <wilx> xerox, I do not have any idea what is its purpose :)
06:16:36 <xerox> aww.
06:20:31 <thedward> kind of like a linked list with no contents
06:21:31 <xerox> Uhm.
06:23:05 <dblhelix> yeah, seems like a chain that either ends in a null pointer or is circular, right?
06:23:17 <xerox> Where is the pointer finally stored?
06:23:30 <xerox> ..or, where are the pointers stored?  Or.. there are pointers stored?
06:23:59 <dblhelix> xerox: in the Foo cells?
06:24:18 <xerox> Hm, but they are only pointers to other Foos ?
06:25:06 <dblhelix> or (grins evilly) the same Foo
06:25:33 <xerox> What an useful type.
06:25:49 <dblhelix> you introduced it :)
06:26:22 <xerox> It's not my invention!
06:26:51 <dblhelix> then, who is responsible?
06:27:16 <xerox> I'm asking him before :-)
06:46:17 <ndm> how do i do a GHCi :i command on GHC.Exts.xor# ?
06:46:32 <ndm> :i GHC.Exts.xor#
06:46:34 <ndm> <interactive>:1:3: parse error on input `#'
06:47:17 <xerox> () ?
06:47:17 <araujo> sorry for offtopic, can anyone see this page? http://www.animax-la.com/
06:48:22 <ndm> :i (xor#)
06:48:24 <ndm> <interactive>:1:1: parse error on input `xor'
06:48:35 <ndm> araujo, yep - i can see it
06:49:12 <araujo> ndm, what browser do you use?
06:49:19 <ndm> firefox
06:49:36 <araujo> ndm, any special plugin?, it doesn't show the whole page here
06:49:41 <araujo> it is splitup in the middle
06:49:42 <ndm> :i "xor#" also doesn't work
06:50:07 <ndm> its done using flash, so i guess that as a special plugin, but none others
06:50:17 <araujo> thanks ndm
06:51:01 <ski> ndm : it works here if i do 'ghci -fglasgow-exts'  (otherwise it doen't work)
06:51:27 <ski> GHC.Prim.xor# :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
06:52:27 <ski> i would think this is because ghc only considers '#' a valid identifier char when some extension enabled
07:01:11 <ndm> ski, ah - thanks
07:01:14 <ndm> i didn't think of that
07:12:49 <mauke> @pl \x -> f x || g x
07:12:52 <lambdabot> liftM2 (||) f g
07:19:34 <shapr> This Seth Kurtzberg post is running around in my head a lot lately: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/8398
07:19:51 <shapr> There's some deep realization here, but I'm not sure what exactly.
07:19:55 * shapr goes unicycling to think...
07:23:02 <ndm> can't GHC optimise from O(n^2) to O(n) in some cases
07:23:16 <ndm> making it actually possible to do order of magnitude  optimisations
07:23:39 <fluxx> which cases would be candidates?
07:24:05 <fluxx> note that a*O(n^2) versus b*O(n) where a is much smaller than b can still be better in some cases
07:24:56 <ndm> i don't know which, but i have been told previously
07:25:09 <ndm> and no, its where a and b are comprable
07:25:26 <fluxx> list concatenation might be one such case
07:25:31 <fluxx> because of lazy evaluation
07:26:10 <ndm> no, i heard it was a case where using lazy evaluation and standard haskell reduction you get O(n^2), but GHC optimises it to O(n), with the use of memoisation I think
07:36:19 <xerox> How do one install Cabal 1.0.1 ? .-)
07:36:20 <xerox> :-)
07:42:44 <xerox> Hmpf: Could not find module `Distribution.Compat.Directory': it is hidden (in package Cabal-1.0)
07:50:51 <ndm> xerox, i had that problem 2 minutes ago
07:51:06 <ndm> its not hidden if you run GHC on Windows
07:51:10 <xerox> ndm, nice :)  Did you work it out?
07:51:19 <xerox> erhm..
07:51:21 <ndm> moved over to the windows machine...
07:51:31 <ndm> but i do need to sort it out at some point
07:52:22 <sylvan> ghc-pkg expose Cabal-1.0
07:54:01 <xerox> uh-oh!
07:54:55 <xerox> sylvan, thank you very much.
08:09:12 <CosmicRay> good morning
08:09:55 <shapr> y0!
08:09:59 <CosmicRay> hey shapr
08:10:21 <shapr> What's up?
08:10:54 <CosmicRay> glad to have my net access back.  dsl was down for many hours last night, and then to make things worse, power was off for an hour and a half
08:11:18 <CosmicRay> also my ldap bindings are working
08:11:23 <CosmicRay> how bout you?
08:18:47 <SyntaxNinja> hi CosmicRay, shapr.
08:20:09 <CosmicRay> morning syntaxninja
08:38:52 <xerox> @docs Foreign
08:38:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
08:39:04 <xerox> @code Foreign
08:39:09 <xerox> How was it called...
08:39:13 <xerox> @libsrc Foreign
08:39:20 <lambdabot> Pack.lhs: freeze_ps_array (MutableByteArray _ _ arr#) len# = ST $ \ s# ->
08:39:20 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Foreign.hs
08:45:28 <CosmicRay> that resource is not really beeing kept up-to-date
08:45:39 <CosmicRay> whoever programs lambdabot should perhaps find a better one
08:45:52 <CosmicRay> I actually didn't know anybody used that still
08:47:45 <sylvan> Does anyone know if there are plans to throw in a few more data structures in the GHC libs? Like a priority queue, for instance?
08:50:46 <tmoertel> Data.Map has priority queue features built in: findMin, deleteMin, ...
08:57:08 <xerox> How to pass from a Ptr Foo to a Foo ?
08:57:16 <xerox> coerce?
08:57:51 <Igloo> peek
08:59:24 <xerox> Is it the only way?  My datatype isn't in Storable, hmm.
09:03:07 <sylvan> tmoertel: Yeah but not at optimal asymptotic complexity...
09:13:47 <basti_> hi
09:15:00 <xerox> Do anybody know c2hs?
09:22:44 <CosmicRay> xerox: I couldn't get it to build, so I use hsc2hs
09:22:58 <xerox> :(
09:23:01 <CosmicRay> xerox: then you have to convert it manually
09:23:16 <CosmicRay> is this a C struct?
09:23:58 <xerox> Yes
09:24:08 <CosmicRay> then you will have to convert each element manually
09:24:17 <xerox> It's a ForeignPtr in fact, I don't know (and have to know) the internals.
09:24:18 <CosmicRay> hsc2hs has some fairly useful features for that
09:24:45 <xerox> btw c2hs is compiling here, I think it's worth it to give it a try.
09:25:02 <CosmicRay> I'm confused...  you have a Ptr to some C structure, that you don't know what it looks like, and want to convert it to a Haskell type of some sort?
09:25:18 <xerox> I'm confused too :-)
09:25:37 <CosmicRay> well, is this a correct summary of the facts? ;-)
09:25:45 <xerox> Hmm yes
09:26:02 <xerox> In fact I didn't work out how to get a ForeignPtr in place of the Ptr
09:26:11 <CosmicRay> you won't be able to do this unless you know the details of the C structure, *or* you have C functions that will inspect it and return the data
09:26:26 <CosmicRay> well, are you sure that's what you want?
09:26:42 <CosmicRay> the idea of a ForeignPtr is that it automatically frees memory when it gets garbage collected
09:26:54 <CosmicRay> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.ForeignPtr.html
09:27:02 <CosmicRay> it wraps a Ptr
09:27:03 <xerox> I want a Ptr to some memory allocated by the library function
09:27:24 <CosmicRay> well you don't need to involve the foreignptr at all then
09:27:33 <CosmicRay> would an example help?
09:27:37 <xerox> Indeed.
09:28:08 <CosmicRay> http://darcs.complete.org/ldap-haskell/LDAP/Search.hsc
09:28:24 <CosmicRay> take a look at the ldap_first_entry call down towards the bottom to start with
09:28:30 <CosmicRay> foreign import ccall unsafe "ldap.h ldap_first_entry"
09:28:30 <CosmicRay>   ldap_first_entry :: LDAPPtr -> Ptr CLDAPMessage -> IO (Ptr CLDAPMessage)
09:28:49 <CosmicRay> does the type of that function make sense to you?
09:29:17 <xerox> Sorry, wait a second
09:29:36 <xerox> c2hs finished building...
09:30:17 <xerox> OK
09:30:31 <xerox> It makes sense
09:30:43 <CosmicRay> ok.
09:30:54 <CosmicRay> CLDAPMessage is defined simply as
09:30:57 <CosmicRay> data CLDAPMessage
09:30:59 <CosmicRay> elsewhere.
09:31:18 <CosmicRay> if you wanted, you could instead define it as a record with all its types and make it an instance of storable, etc.
09:32:14 <CosmicRay> hang on a sec, let me get some more examples...
09:32:52 <CosmicRay> http://darcs.complete.org/ldap-haskell/LDAP/Utils.hsc
09:33:03 <CosmicRay> look for the bv2str function.
09:33:11 <CosmicRay> this function takes a Ptr Berval and returns an IO String
09:33:22 <CosmicRay> Berval is a C structure that basically contains a char * and a length
09:33:29 <CosmicRay> (it's used to represent strings that may contain NULLS)
09:33:38 <CosmicRay> and we want to conver it to a Haskell String.
09:33:45 <CosmicRay>     do (len::BERLen) <- ( #{peek struct berval, bv_len} ) bptr
09:33:45 <CosmicRay>        cstr <- ( #{peek struct berval, bv_val} ) bptr
09:33:45 <CosmicRay>        peekCStringLen (cstr, fromIntegral len)
09:33:55 <xerox> hmm
09:34:18 <CosmicRay> that #{peek...} is a hsc2hs feature that basically generates an anonymous function that takes a pointer to the struct and returns the data from the appropriate member field
09:34:31 <CosmicRay> BUT you must have a declaration of the structure type in a .h somewhere to be able to do this
09:34:40 <CosmicRay> notice that earlier in that file I #include <ldap.h>
09:34:52 <CosmicRay> brb
09:35:37 <xerox> OK, I do not need any peek.
09:37:01 <xerox> I don't understand how do I marshal Enums, tough
09:47:30 <CosmicRay> a C enum or a haskell enum/
09:48:00 <xerox> C enum
09:48:12 <xerox> cFromEnum :: Enum a => a -> CInt
09:48:12 <xerox> cFromEnum = i2c . fromEnum
09:48:12 <xerox> ?
09:48:18 <CosmicRay> those are just an int
09:48:22 <CosmicRay> a C enum is an int
09:48:23 <xerox> i2c = fromIntegral
09:48:29 <xerox> ok...
09:48:51 <xerox> c2hs says he can do the marshalling for me, hmm, I'm a bit lost
09:49:01 <CosmicRay> you can use #const in hsc2hs to do this for you
09:49:08 <CosmicRay> http://haskell.org/hawiki/Hsc2hs
09:49:31 <CosmicRay> even easier, you can use #enum in hsc2hs.
09:49:43 <CosmicRay> #enum CInt, , VAL1, VAL2, VAL3, VAL4
09:49:43 <CosmicRay> etc.
09:51:28 <xerox> I have to use c2hs :!
09:51:35 <CosmicRay> why? hsc2hs is easier and comes with ghc
09:51:43 <CosmicRay> and is also supported out of the box by cabal
09:52:03 <CosmicRay> also hsc2hs builds on my machine ;-)
09:52:03 <xerox> It works, the only problem with it at the moment it's... me :)
09:52:17 <CosmicRay> is your code online somewhere?
09:52:28 <xerox> Which c2hs did you try?  c2hs has some good features, that's just me :)
09:52:42 <CosmicRay> xerox: several versions
09:52:52 <CosmicRay> they all had weird build failures involveing Pretty
09:52:56 <xerox> I just built the last one, the one with duncan's patch
09:53:19 <xerox> It now doesn't consume hundreds megabytes of ram during compilation
09:53:28 <CosmicRay> heh
09:53:32 <xerox> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-3.html#ss3.7
09:53:44 <xerox> This is the thing I'm trying
09:53:54 <CosmicRay> I have no idea, I've never used c2hs
09:54:00 <xerox> The C funcion is:
09:54:11 <xerox> cairo_surface_t* cairo_image_surface_create (cairo_format_t format, int width, int height);
09:54:28 <CosmicRay> part of my problem from reading the c2hs docs is that I couldn't work out how it would save me time over FFI + hsc2hs ;-)
09:54:46 <xerox> {#fun cairo_image_surface_create as image_surface_create
09:54:47 <xerox>   { cFromEnum `Format', i2c `Int', i2c `Int' } -> `Surface' #}
09:55:11 <xerox> This _seems_ to me to be right, but there is no marshaller for the return value, and I don't know what to use
09:55:24 <xerox> Let's try id.
09:55:26 <CosmicRay> ilke I said, I hav eno clue about c2hs stuff
09:55:34 <xerox> ah-ha! :-D
09:55:46 <CosmicRay> watch it blow up in your face when it goes to production ;-)
09:55:53 <xerox> *Cairo> :t image_surface_create
09:55:53 <xerox> image_surface_create :: Format -> Int -> Int -> IO Surface
09:55:57 <xerox> ta-da :-)
09:56:02 <CosmicRay> hehe
09:56:05 <xerox> oooh :-)
09:56:21 <xerox> In fact it's really nice now that I understood it.
09:56:34 <xerox> CosmicRay, did you read the c2hs paper/intro?
09:57:25 <xerox> Its approach is interesting for some reason, let me go back to the code for a while, tough :-)
09:58:30 <CosmicRay> xerox: I read whatever it was that you linked to just now, last week
10:00:06 <xerox> I meant the paper.
10:00:44 <Saulzar> Hmm - trying to see how one might use such a thing as a mutable hashtable, it seems kind of neat the way the IO monad measn you absolutely can't use it in a side effecting way. But this also means you must return IO for every single function between main and the place where the hashtable is used?
10:00:56 <xerox> What do you think is better between those two definition:
10:01:05 <xerox> create :: Surface -> IO Cairo
10:01:05 <xerox> create = {#call cairo_create#}
10:01:12 <xerox> {#fun create as create
10:01:12 <xerox>   { id `Surface' } -> `Cairo' id#}
10:08:20 <beschmi> Saulzar: you can use a hashtable or mutable arrays in the ST Monad with runST in a pure function
10:09:59 <xerox> Where are the standard library .hs files in the unix hierarchy?
10:11:37 <xerox> Found.
10:12:36 <basti_> "locate" helps there.
10:12:54 <basti_> xerox: are you working at hsCairo?
10:13:00 <xerox> Yup
10:13:04 <basti_> how cool.
10:13:12 <basti_> then i don't need to do so
10:13:12 <basti_> :)
10:13:16 * basti_ ducks and runs
10:13:21 <xerox> Do you know how to include /usr/local/lib/c2hs-0.14.1/C2HS.h ?
10:13:26 <xerox> .hs even
10:13:31 <basti_> no.
10:13:35 <xerox> Hmm.
10:13:39 <basti_> ive used c2hs only passively
10:13:41 <xerox> Some GHC option probably
10:13:44 <basti_> as "in makefiles"
10:13:50 <xerox> -I...
10:14:00 <basti_> that'd be consistent
10:14:47 <xerox> It was -i
10:14:55 * xerox does a little dance for his code compiling
10:15:14 <basti_> :)
10:15:14 <xerox> Now, shower.  Thank you guys for the help.
10:15:19 <SyntaxNinja> oh no! a monad virus! ;) http://zdnet.com.au/news/security/soa/Windows_Vista_tool_targeted_by_virus_writers/0,2000061744,39205746,00.htm
10:15:21 <xerox> Now it's downhill ;)
10:15:30 <basti_> lol
10:34:47 <pejo> There are articles about generating C for a functional language. Does anyone happen to have a reference handy, or a name, or something?
10:34:56 <pejo> for = from.
10:46:33 <lispy> pejo: parametric C?
10:46:47 <lispy> pejo: oh n/m
10:47:18 <lispy> pejo: you want to look for simon peyton jones, he has a book available on the web, which iirc has some info about it
10:49:01 <integral> "Implementing Functional Languages: a tutorial" and the STG paper perhaps?
10:51:14 <pejo> lispy, I looked there but didn't find anything obvious. I need to start taking notes on all articles I ever pass by, blah.
10:52:48 <lispy> pejo: yeah, but that's tedious...
10:52:56 <lispy> pejo: so few people do it :)
10:53:58 <pejo> lispy, well, I'm not rainman.
10:55:51 <integral> pejo: try http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/ and http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz#26pub=34
11:14:53 <lispy> the arithmetic mean operator m(A) can be changed into a geometric mean operator by the following antilog(m(log(A))) <-- hmm.., what a weird idea :)
11:16:45 <wilx> I vaguely remember some formula that was both geometric and arithmetic means (and maybe more) depending on some parameter/knobs.
11:17:19 <basti_> lispy: that sounds reasonable
11:17:23 <basti_> in some way
11:17:31 <lispy> @hoogle average
11:17:43 <lispy> gad, is lambdabot down again?
11:17:58 <lispy> silly bot...
11:18:02 <jyp> @seen lambdabot
11:18:03 <lambdabot> Yes, I'm here.
11:18:04 <lispy> well, i guess i'll fire up ghci and try it
11:18:14 <lispy> @hoogle head
11:18:15 <lambdabot> Prelude.head :: ([a] -> a)
11:18:15 <lambdabot> IO.hLookAhead :: (Handle -> (IO Char))
11:18:18 <lispy> hm....
11:18:21 <lispy> @hoogle mean
11:18:39 <lispy> @hoogle sum
11:18:40 <lambdabot> Prelude.sum :: Num a => ([a] -> a)
11:18:40 <lambdabot> Monad.msum :: MonadPlus a => ([(a b)] -> (a b))
11:19:03 <lispy> @eval let mean xs = sum xs / length xs in mean [1..5]
11:19:13 <lambdabot> <Plugins.Eval>:1:
11:19:13 <lambdabot>   No instance for (Fractional Int)
11:19:13 <lambdabot>   arising from use of `/'
11:19:37 <xerox> @eval let mean xs = sum xs / length xs in mean [1.0,2.0..5.0]
11:19:39 <lambdabot> <Plugins.Eval>:1:
11:19:39 <lambdabot>   No instance for (Fractional Int)
11:19:39 <lambdabot>   arising from the literal `5.0'
11:19:42 <xerox> :)
11:19:52 <lispy> @eval let mean xs = (fromIntegral (sum xs)) / (fromIntegral (length xs)) in mean [1..5]
11:19:54 <lambdabot> 3.0
11:20:01 <lispy> @hoogle log
11:20:02 <lambdabot> Prelude.log :: Floating a => (a -> a)
11:20:02 <lambdabot> Prelude.logBase :: Floating a => (a -> a -> a)
11:20:06 <lispy> @hoogle exp
11:20:07 <lambdabot> Prelude.exp :: Floating a => (a -> a)
11:20:07 <lambdabot> Prelude.exponent :: RealFloat a => (a -> Int)
11:20:26 <lispy> @eval exp (log 10)
11:20:28 <lambdabot> 10.000000000000002
11:20:33 <basti_> :)
11:20:55 <lispy> @eval let mean xs = (fromIntegral (sum xs)) / (fromIntegral (length xs)); gmean xs = exp (log (mean xs)) in gmean [1..5]
11:20:57 <lambdabot> 3.0000000000000004
11:21:09 <lispy> oh i typed it wrong
11:21:47 <lispy> @eval let mean xs = sum xs / length xs; gmean xs = exp (mean (map log xs)) in gmean [1..5]
11:21:48 <lambdabot> <Plugins.Eval>:1:
11:21:48 <lambdabot>   No instance for (Floating Int)
11:21:48 <lambdabot>   arising from use of `exp'
11:22:01 <lispy> hmm...
11:22:09 <lispy> @eval map log [1..5]
11:22:11 <lambdabot> [0.0,0.6931471805599453,1.0986122886681098,1.3862943611198906,1.
11:22:11 <lambdabot> 6094379124341003]
11:22:19 <lispy> ah
11:22:29 <lispy> @eval let mean xs = sum xs / (fromIntegral (length xs)); gmean xs = exp (mean (map log xs)) in gmean [1..5]
11:22:31 <lambdabot> 2.6051710846973517
11:22:34 <lispy> cool!
11:22:50 <lispy> but is that really the geometric mean....
11:23:21 <basti_> "a" geometric mean i would say
11:23:29 <basti_> oh
11:23:30 <mauke> @eval sqrt 2
11:23:31 <basti_> uhm
11:23:32 <lambdabot> 1.4142135623730951
11:23:35 <lispy> @eval 2.6 * 1
11:23:37 <lambdabot> 2.6
11:23:42 <lispy> @eval 2.6 * 2.6
11:23:44 <lambdabot> 6.760000000000001
11:23:46 <lispy> hmm....
11:23:53 <lispy> am i thniking of something else?
11:24:04 <lispy> i must be thinking of geometric progressions
11:24:29 <mauke> @eval product [1..5] ** 0.2
11:24:31 <lambdabot> 2.605171084697352
11:24:34 <lispy> yeah
11:24:39 <lispy> okay
11:24:50 <lispy> cool!
11:24:56 <jyp> Only problem is that it won't work with zeros
11:25:07 <jyp> your geom mean
11:26:14 <lispy> @eval let mean xs = sum xs / (fromIntegral (length xs)); gmean xs = exp (mean (map log xs)) in gmean [0]
11:26:16 <lambdabot> NaN
11:26:29 <lispy> should be 0^1 right?
11:26:31 <liyang> @eval 2.6 ** 5
11:26:32 <lambdabot> 118.81376000000002
11:26:42 <liyang> @eval product [1..5]
11:26:44 <lambdabot> 120
11:26:57 <jyp> imo gmean (0:x) = 0
11:27:03 <liyang> @eval 2.605171084697352 ** 5
11:27:04 <lambdabot> 120.00000000000006
11:27:09 <liyang> There we go.
11:27:23 <lispy> jyp: agreed
11:28:21 <liyang> yeah, but log goes funny at 0. So NaN is correct in some sense.
11:29:20 <basti_> log goes -inf at 0.
11:29:28 <jyp> The definition would be correct for floating with handling of infinites, agreed :)
11:29:48 <basti_> -g-
11:29:52 <jyp> @eval log 0
11:29:57 <basti_> -inf isnt funny.
11:30:00 <lambdabot> -Infinity
11:30:25 <lament> hm
11:30:26 <jyp> so exp behaves strangely, not log :p
11:30:31 <basti_> -g-
11:30:35 <basti_> exp -inf should be 0
11:30:36 <liyang> basti_: no, it's just not real. ;)
11:30:44 <lament> this is just haskell?
11:30:47 <lament> lambdabot
11:30:55 <jyp> yessir
11:31:00 <mauke> @eval exp (log 0)
11:31:02 <lambdabot> NaN
11:31:07 <lament> with standard datatypes?
11:31:13 <lament> where's that -Infinity from
11:31:45 <xerox> It works like that on ghc.
11:31:51 <lament> ah.
11:31:53 <lispy> jyp: so in the end i think we can just conclude that this implemenation of gmean has problems at 0
11:31:55 <lament> crazy.
11:32:04 <lispy> we colud add  check for that
11:32:22 <Akshaal> ty
11:32:32 <lispy> @eval let mean xs = sum xs / (fromIntegral (length xs)); gmean xs | 0 `elem` xs = 0 | otherwise = exp (mean (map log xs)) in gmean [0]
11:32:34 <lambdabot> 0.0
11:32:40 <jyp> I would go for sqrtN (length l) (product l) or something
11:32:47 <lispy> @eval let mean xs = sum xs / (fromIntegral (length xs)); gmean xs | 0 `elem` xs = 0 | otherwise = exp (mean (map log xs)) in gmean [0,1..5]
11:32:49 <lambdabot> 0.0
11:36:18 <lispy> @eval (-Infinity) + 1
11:36:19 <lambdabot> Data constructor not in scope: `Infinity'
11:36:42 <lispy> that must be a show thingy?
11:36:50 <musasabi> @eval (-1 / 0)
11:36:52 <lambdabot> -Infinity
11:36:56 <musasabi> @eval (-1 / 0) + 1
11:36:58 <lambdabot> -Infinity
11:37:09 <lispy> @eval (-Infinity) + (1 / 0)
11:37:11 <lambdabot> Data constructor not in scope: `Infinity'
11:37:12 <lispy> goops
11:37:21 <lispy> @eval (-1/0) + (1 / 0)
11:37:21 <smott> why isn't a/0 undefined anyway?
11:37:23 <lambdabot> NaN
11:37:34 <musasabi> smott: ieee semantics.
11:37:42 <smott> ah
11:37:45 <lispy> ieee754 if you care to look it up :)
11:38:04 <musasabi> floating point math is quite complex and nonintuitive.
11:38:21 <lispy> @eval (-1/0) + (-1 / 0)
11:38:22 <lambdabot> -Infinity
11:38:36 <lispy> yeah like you can add same sign inifinities
11:40:19 <musasabi> having x/0 -> error would cause trouble.
11:40:26 <sieni> Of course you can :-)
11:40:58 <jyp> @eval exp (1/0)
11:41:00 <lambdabot> NaN
11:42:01 <smott> @eval product []
11:42:03 <lambdabot> 1
11:43:32 <lispy> @eval log (-1)
11:43:34 <lambdabot> -Infinity
11:44:47 <lispy> musasabi: why would it cause trouble?  because of round off errors that may make the y in x/y effectivly zero?
11:50:30 <musasabi> lispy: yes.
12:22:41 <basti_> i fear microsoft called their suckiness monad because they want all the google hits from haskell users
12:24:08 <xerox> @hoogle bracket
12:24:10 <lambdabot> IO.bracket :: ((IO a) -> (a -> (IO b)) -> (a -> (IO c)) -> (IO c))
12:24:10 <lambdabot> IO.bracket_ :: ((IO a) -> (a -> (IO b)) -> (IO c) -> (IO c))
12:27:33 <lispy> basti_: er?
12:27:45 <lispy> basti_: MS has a 'monad' somewhere?
12:28:16 <basti_> the shell of their new sucky "os" is called 20 names, one of them is "monad"
12:28:26 <wagle> http://en.wikipedia.org/wiki/MSH_%28shell%29
12:28:37 <wagle> (from http://en.wikipedia.org/wiki/Monad )
12:28:56 <vegai> basti_: wanna guess how long it takes until someone asks here "Why did you name them after the Windows Shell"?
12:29:03 <wagle> http://en.wikipedia.org/wiki/Monadology
12:29:04 <lispy> commandlets ?
12:29:06 <lispy> lame....
12:29:14 <basti_> i.do.not.want.to.know vegai
12:29:38 <wagle> vegai: Why DID you name them after the Windows Shell?
12:30:01 <vegai> I didn't expect a Spanish Inquisition!
12:30:12 <wagle> no-one does..  really
12:30:17 * lispy objects more to the name 'commandlet'
12:30:37 <wagle>  /nick waglet
12:31:08 <basti_> waglet?
12:31:35 <wagle> me?  waglet's tghe other guy..
12:31:41 <lispy> "...the registry was mapped to a drive, and you could navigate it like any other drive, with the results being returned from the commandlet as .NET objects!"
12:32:11 * basti_ shudders
12:32:19 <lispy> OMGF .NET objects!
12:32:23 <lispy> ;)
12:32:32 <lispy> i guess it's OMFG, but I can't type
12:32:40 <wagle> oh my god f___?
12:32:51 <xerox> Oh my girl friend
12:33:25 <lispy> it's like oh my darlin
12:34:19 <lispy> "I wonder if they will add support for console apps via xml or something"  <-- what does that mean?
12:34:37 <lispy> http://weblogs.asp.net/jnadal/archive/2003/10/29/34413.aspx
12:34:44 <basti_> that somebody wants to type lots of stuff, i suppose
12:34:45 * lispy boggles at the things people say
12:36:57 <wagle> if an XML expression is of the form <foo/>, whats the / idea called?
12:37:27 <wagle> (ie, instead of being of the form <foo> </foo> ?)
12:37:29 <lispy> that's a self closing tag, iirc
12:37:38 <lispy> br is that way
12:37:40 <lispy> <br/>
12:38:24 <wagle> i'm trying to use a xml parser that doesnt appear to tell me about self closing tags..  but its a BIG interface, so maybe i'm missing something
12:38:55 <wagle> so I'm looking for terms to search for
12:40:03 <lispy> wagle: check the w3c site
12:40:45 <wagle> i was wondering if i could get this particular lib to do it..  but yeah, i will look there
12:41:47 <vegai> why oh why didn't they use s-exp..
12:42:38 <wilx> Huh.
12:42:49 <wagle> i heard about 3 years ago that s-expr doesnt quite work as well, but i couldnt get details
12:43:36 <wilx> WinFX, sounds like Microsoft wants to force its managed stuff onto people hard :/
12:44:03 <wagle> but, heh: http://www.oreillynet.com/pub/wlg/6021
12:44:43 <wagle> maybe they were trying to look like html
12:45:10 <wagle> but I don't really care a lot about syntax..  its all isomorphic
12:46:35 <wagle> hmm: http://www.prescod.net/xml/sexprs.html
12:48:47 <xerox> Do you know how to bind structures with c2hs?
12:49:50 <xerox> Nevermind.
13:03:36 <xerox> What would you do to allocate some memory in Haskell ? :)
13:04:32 <Lemmih> @index alloca
13:04:33 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
13:04:42 <xerox> Great.
13:04:53 <xerox> @docs Foreign.Marshal
13:04:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.Marshal.html
13:07:33 <xerox> Lemmih, if I have a struct mapped to a data Type = Type { a :: .., b :: }, and I know how to setup a and b for initialization, do you think it's feasable to avoid alloca and do "Type {a = ...}" or whatever is the syntax?
13:12:02 <Lemmih> How could you use alloca to do something else?
13:12:44 <xerox> I'm trying.
13:12:53 <Lemmih> (You can't/shouldn't create Haskell closures with alloca)
13:13:28 <xerox> OK, good.
13:14:46 <xerox> So I probably do not need bracket at all, hmm.
13:16:23 <xerox> What do you think about this:
13:16:25 <xerox> withMatrix :: (Matrix -> IO a) -> IO a
13:16:25 <xerox> withMatrix = (>>=) (return identityMatrix)
13:16:35 <xerox> @pl (>>=) (return f)
13:16:36 <lambdabot> ($ f)
13:19:05 <wagle> @docs Modern.Major-General
13:19:06 <lambdabot> Modern.Major-General not available
13:19:56 <Lemmih> @seen shapr
13:19:57 <lambdabot> I saw shapr leaving #haskell 4 hours, 52 minutes and 37 seconds ago.
13:26:40 <xerox> How can one make possible to do Ptr HisPreferredDatatype ?
13:27:20 <Lemmih> Elaborate, please.
13:28:41 <Lemmih> You could use StableName's.
13:29:01 <xerox> I have some foreign function which take a *type (which is a struct), I written "data Type = { slot_a :: ..., slot_b :: ..., ... }" - now how can I pass it to the foreign function?
13:29:57 <xerox> I probably need to store the struct in a C-like fashion from the beginnig.
13:30:06 <xerox> beginning, even
13:30:29 <Lemmih> Allocate some memory for the struct and poke the values to it.
13:30:44 <xerox> Do you know if c2hs helps in any way in doing it?
13:31:06 <Lemmih> Making Type an instance of Storable is the way to go most of the time.
13:31:19 <Lemmih> I've never used c2hs.
13:31:42 <xerox> Let me see..
13:32:33 <Lemmih> Tsk. I meant StablePtr instead of StableName, of course.
13:33:10 <xerox> I should think of a convenient interface, too.
13:34:58 <Lemmih> That's pretty easy once the type is an instance of Storable.
13:35:13 <jyp> mhmmm... Can I combine GADT and deriving clauses ?
13:35:45 <xerox> I'm trying to figure out how to make the type an instance of Storable.
13:36:07 <xerox> Minimal complete definition: sizeOf, alignment, one of peek, peekElemOff and peekByteOff, and one of poke, pokeElemOff and pokeByteOff.
13:36:14 <Lemmih> jyp: You can in GHC 6.5 if you don't use any of the GADT features, iirc.
13:36:50 <jyp> Lemmih: ok; thanks
13:36:56 <Lemmih> xerox: You don't need to define *ElemOff and *ByteOff.
13:41:30 <xerox> @libsrc Storable
13:41:31 <lambdabot> Storable not available
13:41:44 <Lemmih> @libsrc Data.Storable
13:41:44 <lambdabot> Data.Storable not available
13:42:10 <wilx> @index Storable
13:42:11 <lambdabot> Foreign.Storable, Foreign
13:42:12 <xerox> @libsrc Foreign.Storable
13:42:13 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Foreign/Storable.hs
13:43:00 <xerox> I don't know what to provide as |align|
13:46:07 <sylvan> Maybve you should use 32 or 64 depending on architecture?
13:46:13 <Lemmih> What does the C struct look like?
13:46:28 <xerox> typedef struct _cairo_matrix {
13:46:28 <xerox>     double xx; double yx;
13:46:28 <xerox>     double xy; double yy;
13:46:28 <xerox>     double x0; double y0;
13:46:28 <xerox> } cairo_matrix_t;
13:46:45 <xerox> It seems to be 48 bytes long on x86
13:46:54 <Lemmih> alignment _ = alignment (undefined :: CDouble)
13:47:04 <sylvan> that's right, alignment isn't even used
13:47:27 <xerox> Hmm
13:47:36 <xerox> Do you think I should use CDouble in my data definition too?
13:49:16 <sylvan> xerox: try reading this, http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-3.html , not sure you need to manually marshall anything in this case
13:49:27 <Lemmih> I haven't heard of any cases where CDouble /= Double.
13:49:36 <xerox> sylvan, I'm reading it.
13:49:44 <xerox> sylvan, what are you suggesti?
13:49:47 <sylvan> "Get Hooks" maybe
13:49:53 <sylvan> I'm not overly familiar with c2hs though
13:50:04 <sylvan> just seems to be what your looking for
13:50:21 <xerox> A get hook supports accessing a member value of a C structure.
13:50:32 <xerox> Indeed..
13:50:48 <xerox> sylvan, but what about functions getting pointers to that structure?
13:50:50 <sylvan> and then set hooks, of course
13:51:05 <sylvan> what do you mean?=
13:51:20 <xerox> I don't know what to pass to them
13:52:01 <sylvan> I think foo(type* bar) gets translated to foo :: Ptr Bar -> ..
13:52:19 <sylvan> like I said, haven't really used it in practice so I may be way off
13:52:30 <xerox> Yup, it's translated that way.
13:52:53 <xerox> So to get a Ptr Bar, I need to make Bar an instance of Storable, right?
13:53:21 <sylvan> Hmm... Well don't you have a Ptr Bar already? I mean you get the value of type Bar form the "C world" right?
13:54:14 <xerox> No, that's my problem.
13:54:21 <sylvan> So you allocate an area of memory for a value of type Bar in the C world, and then get a Ptr Bar on the haskell side which you can use to send to any C function taking Ptr Bar
13:54:27 <xerox> I didn't tell you, in fact, sorry.
13:54:40 <sylvan> well maybe create a C function which just calls "malloc" and returns a pointer to it
13:55:02 <sylvan> c2hs probably has some way to do that...
13:55:57 <xerox> I was wondering if it has.  I was also wondering how to do a "sizeof" without some functionality like that.
13:56:09 <xerox> Hardcode 48 would be silly, I think.
13:57:19 <sylvan> there is a sizeof hook
13:57:21 <sylvan> in c2hs
13:57:32 <tic> 'elo sylvan.  coming to school? :)
13:57:42 <tic> (tomorrow)
13:58:08 <sylvan> hmm maybe =)
13:58:15 <musasabi> Both c2hs and hsc2hs support getting sizeof structures.
13:58:33 <sylvan> xerox: check out 3.10
13:58:36 <xerox> Uhm..
13:58:42 <xerox> Right.
14:00:24 <sylvan> "withObject" (generated automatically) does what you want, right?
14:01:18 <sylvan> (pass it your haskell type, and a foreign function taking a pointer to that type, and get the result back)
14:01:26 <sylvan> s/type/value
14:02:04 <xerox> Interesting
14:02:15 <xerox> That's right!
14:02:19 <xerox> I'm trying :-)
14:03:50 <sylvan> good luck
14:11:56 <xerox> I seem unable to use it because in the C header the struct isn't defined as a pointer.
14:12:21 <sylvan> hmmm....
14:12:47 <xerox> Cairo.chs:34: (column 11) [ERROR]
14:12:48 <xerox>   >>> Expected a pointer object!
14:12:48 <xerox>   Attempt to dereference a non-pointer object or to use it in a `pointer' hook.
14:13:29 <sylvan> did you use a * in the hook or not? Try doing it the other way =)
14:14:53 <xerox> Oh, silly, right.
14:15:01 <xerox>   >>> Missing "in" marshaller!
14:15:01 <xerox>   There is no default marshaller for this combination of Haskell and C type:
14:15:01 <xerox>   Haskell type: MatrixPtr
14:15:01 <xerox>   C type      : (MatrixPtr)
14:15:05 <xerox> O_o ?
14:15:12 <xerox> Let's try id, again...
14:15:39 <sylvan> hmmm?
14:15:51 <xerox> hmm, it works.
14:16:01 <xerox> err, it "compiles" :)
14:16:07 <sylvan> but does it work?
14:16:22 <xerox> I'm trying.
14:16:41 <mauke> "it works, IT WORKS!!! OMG! OMG! OMG! OMG!.... I mean, it compiles... now what is a segfault?"
14:17:10 <xerox> :)))
14:17:19 <xerox> No istance for (Storable Matrix)
14:17:33 <sylvan> Crap =/
14:17:36 <xerox> for: withObject identityMatrix
14:17:51 <sylvan> Shouldn't c2hs be able to generate that quite easily?
14:18:12 <xerox> I'd guess... not?
14:18:14 <sylvan> Maybe you should look at the examples that come with c2hs, one of them must surely do something like this...
14:18:23 <sylvan> seems like a pretty basic thing to do...
14:22:13 <xerox> Pointer.chs works with "C world" pointers :\
14:25:23 <sylvan> can you manipulate "C world" values in haskell and then pass them back?
14:25:30 <xerox> I think so.
14:26:53 <sylvan> couldn't you then just allocate all values of that type in "C world"?
14:27:03 <sylvan> so you never create them on the Haskell side
14:27:43 <xerox> I probably do not need to have them manageable in some Haskell-ish way, too.
14:28:38 <xerox> But how to allocate them in the C-world?
14:29:48 <sylvan> malloc?
14:30:01 <sylvan> and a cast
14:30:15 <sylvan> there should be a binding to malloc somewhere
14:30:36 <xerox> Let me think..
14:30:41 <musasabi> @hoogle malloc
14:30:48 <mauke> no casts no :(
14:30:57 <musasabi> There is at least the malloc foreignPtr thing.
14:31:14 <xerox> @index malloc
14:31:15 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
14:31:24 <xerox> @type Foreign.Marshal.Alloc.malloc
14:31:29 <lambdabot> forall a.
14:31:29 <lambdabot>            (Foreign.Storable.Storable a) =>
14:31:29 <lambdabot>            IO (GHC.Ptr.Ptr a)
14:31:46 <xerox> And_again_that_Storable_constraint_dang.
14:34:14 <xerox> What do you think?  I'm stuck.
14:35:25 <sylvan> hmm... I'm reading the c2hs paper, apparently there are two classes ToAddr and FromAddr that are supposed to help out in marshalling structures somehow..
14:35:36 <xerox> sizeof && allocaBytes   mmh
14:36:19 <musasabi> If you want malloc you probably want ForeignPtr
14:37:09 <musasabi> you could look at hsgnutls but it that uses foo_alloc and foo_free for each kind of object.
14:38:25 <xerox> hsgnutls ?
14:39:13 <xerox> I'll try with sizeof and mallocBytes
14:44:14 <xerox> How to do Ptr a -> Type ?
14:46:27 <Lemmih> peek?
14:47:49 <xerox> Sob.
14:51:03 <musasabi> xerox: if you do mallocBytes where do you free the memory?
14:51:28 <xerox> using bracket ?
14:52:13 <musasabi> hmm ok, but you might want to use alloca then.
14:53:42 <xerox> Could I ask why?
14:54:54 <musasabi> more efficient and clean (no need for manual bracket)
14:55:22 <xerox> Let me try
14:56:22 <xerox> But I need to make Matrix an instace of Storable, to use alloca, right?
14:57:36 <musasabi> bracket (mallocBytes n) free proc == allocaBytes n proc
14:58:23 <xerox> Ah, allocaBytes.  Sorry :)
15:01:31 <xerox> OK, it errors out about: Expected type: (Matrix -> IO a1) -> IO a1  Inferred type: (Ptr a -> IO b) -> IO b
15:01:38 <lispy> @hoogle seq
15:01:39 <lambdabot> Prelude.seq :: (a -> b -> b)
15:01:39 <lambdabot> Prelude.sequence :: Monad a => ([(a b)] -> (a [b]))
15:01:39 <lambdabot> Prelude.sequence_ :: Monad a => ([(a b)] -> (a ()))
15:01:41 <xerox> Very clean to write, anyway.
15:04:17 <musasabi> xerox: well allocaBytes and mallocBytes produce a Ptr and your proc is expecting a Matrox.
15:04:32 <xerox> data Matrix = Matrix (Ptr Matrix)
15:04:59 <xerox> It works for Cairo and Surface :)
15:05:12 <lispy> this description of seq dosen't make any sense to me "evaluates its first argument before returning the second one. It is usually introduced to improve performance by avoiding unneeded laziness. It forces evaluation of the function"
15:05:19 <lispy> what is the function they are talking about?
15:05:25 <musasabi> withEmptyMatrix p = allocaBytes size (\ptr -> p (Matrix ptr))
15:05:25 <Lemmih> xerox: Better make that a newtype.
15:05:40 <xerox> Lemmih, yup, sorry, it's a newtype.  Why, anyway?
15:06:10 <Lemmih> You don't want the extra closure.
15:06:17 <xerox> OK.
15:06:22 <xerox> musasabi, what's "p" ?
15:06:46 <xerox> oops, I got it.
15:08:25 <xerox> *Cairo> withMatrix $ \m -> matrix_init m 2.2 5.5 6.7 1.0 0.2 4.4
15:08:25 <xerox> Loading package haskell98-1.0 ... linking ... done.
15:08:25 <xerox> *Cairo>
15:08:28 <xerox> Let's say it worked?
15:08:33 <xerox> :-)
15:08:47 <xerox> Thank you very very much Lemmih, musasabi.
15:08:58 <xerox> And sylvan :)
15:09:47 <sylvan> =)
15:10:23 <lispy> @eval [1..100000] `seq` Just 1
15:10:28 <lambdabot> Just 1
15:10:32 <lispy> @eval Just 1
15:10:33 <lambdabot> Just 1
15:10:46 <lispy> @eval product [1..100000] `seq` Just 1
15:10:48 <lambdabot> Stack overflow
15:10:51 <xerox> :-)
15:10:53 <sylvan> =)
15:11:20 <lispy> @eval product [1..100000] >> Just 1
15:11:21 <lambdabot> <Plugins.Eval>:1:
15:11:21 <lambdabot>   No instances for (Num (Maybe a), Enum (Maybe a))
15:11:21 <lambdabot>   arising from the literal `100000'
15:11:32 <lispy> @eval Nothing >> Just 1
15:11:34 <lambdabot> Nothing
15:11:43 <lispy> @eval Just 1 >> Nothing
15:11:44 <lambdabot> Ambiguous type variable `a' in the top-level constraint
15:11:57 <lispy> @eval (Just (1::Int)) >> Nothing
15:11:58 <lambdabot> Ambiguous type variable `a' in the top-level constraint
15:12:11 <lispy> @eval (Just (1::Int)) >> (Nothing :: Maybe Int)
15:12:12 <lambdabot> Nothing
15:13:37 <geneticp> hi
15:13:41 <lispy> hi
15:13:46 <TheHunter> it shouldn't do that...
15:13:59 <xerox> withMatrix :: (Matrix -> IO a) -> IO a
15:13:59 <xerox> withMatrix p = allocaBytes {#sizeof matrix_t#} (\ptr -> matrix_init_identity (Matrix ptr) >> p (Matrix ptr))
15:14:13 <lispy> TheHunter: thing about the top-level constraint?
15:14:25 <TheHunter> yes, my ghci doesn't do it.
15:14:37 <geneticp> I´m new on Haskell but I like it very much. Are there examples of commercial use of Haskell?
15:14:54 <TheHunter> Prelude> (take 2048 (show (Just 1 >> Nothing)))
15:14:54 <TheHunter> "Nothing"
15:15:06 <Lemmih> geneticp: http://www.galois.com/
15:15:33 <lispy> TheHunter: what was the definition of >> again?
15:15:43 <TheHunter> @libsrc Control.Monad
15:15:44 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
15:15:47 <lispy> thanks
15:16:43 <TheHunter> ah, i see. Also happens when put into a file.
15:16:47 <geneticp> thanks  Lemmih
15:17:32 <lispy> TheHunter: hm.m...it's not in that file
15:17:36 <lispy> @libsrc Monad
15:17:37 <lambdabot> Monad not available
15:17:54 <TheHunter> it's m >> n = m >>= \_ -> n.
15:18:17 <lispy> thanks, that's what i was thkning it was....
15:18:29 <lispy> but i was a bit off
15:19:05 <TheHunter> hmm, i could have phrased it this way:
15:19:09 <TheHunter> @pl m >>= \_ -> n
15:19:10 <lambdabot> m >> n
15:20:30 <lispy> @eval let m >>. Nothing = n >>= (\_ -> m) in (Just 1) >>. Nothing
15:20:31 <lambdabot> Variable not in scope: `n'
15:20:39 <TheHunter> http://darcs.complete.org/fptools/libraries/base/GHC/Base.lhs, fwiw.
15:20:40 <lispy> @eval let m >>. Nothing = Nothing >>= (\_ -> m) in (Just 1) >>. Nothing
15:20:42 <lambdabot> Nothing
15:20:50 <lispy> @eval let m >>. Nothing = m in (Just 1) >>. Nothing
15:20:51 <lambdabot> Just 1
15:21:44 <lispy> @eval let m >>. Nothing = m ; m >>. n = m >>= \_ -> n in (Just 1) >>. Nothing
15:21:45 <lambdabot> Just 1
15:21:57 <lispy> @eval let m >>. Nothing = m ; m >>. n = m >>= \_ -> n in (Just 1) >>. Nothing >>. Just 2 >>. Nothing
15:21:58 <lambdabot> Just 2
15:22:12 <lispy> ah cool, that definition allows the failures to be ignored
15:22:28 <lispy> is there already a function for doing that?
15:23:02 <lispy> @pl let m >>. Nothing = m ; m >>. n = m >>= \_ -> n in >>.
15:23:03 <lambdabot> (line 1, column 7):
15:23:03 <lambdabot> unexpected ">"
15:23:03 <lambdabot> expecting pattern or "="
15:23:32 <TheHunter> @type let m >>. Nothing = m ; m >>. n = m >>= \_ -> n in (>>.)
15:23:34 <lambdabot> forall a.
15:23:34 <lambdabot>                     Maybe a -> Maybe a -> Maybe a
15:23:41 <TheHunter> mplus ?
15:23:52 <lispy> @pl m >>. n | isNothing n = m | otherwise = m >>= \_-> n
15:23:53 <lambdabot> (line 1, column 23):
15:23:53 <lambdabot> unexpected "="
15:23:53 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:24:25 <lispy> TheHunter: mplus returns when it finds a non-mzero value
15:25:02 <lispy> @pl \m n -> if isNothing n then m else m >>= \_-> n
15:25:03 <lambdabot> ap (ap . flip (if' . isNothing)) ((. const) . (>>=))
15:25:26 <lispy> @pl \m n -> if  n == mzero then m else m >>= \_-> n
15:25:27 <lambdabot> ap (ap . flip (if' . (mzero ==))) ((. const) . (>>=))
15:25:40 <TheHunter> ah, it seems to be "flip mplus".
15:26:09 <lispy> i don't think so
15:26:59 <lispy> flip mplus (Just 1) Nothing
15:27:04 <lispy> @eval flip mplus (Just 1) Nothing
15:27:06 <lambdabot> Just 1
15:27:31 <lispy> @eval mplus (Just 1) (Just 2)
15:27:33 <lambdabot> Just 1
15:27:53 <TheHunter> why?    No instance for (Arbitrary (Maybe Int))
15:28:59 <lispy> the thing i defined allows you to chain together a bunch of Maybe a instances and it will do all of them even when there is a nothing
15:29:14 <lispy> you can do an msum but it will stop at the first Just
15:29:47 <lispy> i wonder how what i defined would compare with foldM
15:30:03 <lispy> hmm...not comparable
15:30:29 <mauke> bah, why doesn't haskell have a Boolean class?
15:30:37 <lispy> mauke: i've wanted one too
15:30:45 <lispy> mauke: it seems like a pretty big oversight
15:31:24 <lispy> i wonder if the superclass extension could be used
15:31:39 <lispy> there was a proposal to be able to insert super classes in the class tree
15:32:14 <lispy> oh, i wonder if you could use Monads to get a boolean class
15:32:22 <lispy> mplus would be or
15:32:51 <lispy> i guess >> is and
15:34:36 <lispy> @eval ap (liftM (+1)) (Just 1)
15:34:38 <lambdabot> Couldn't match `(->) (a -> a1)' against `Maybe'
15:34:51 <lispy> @type liftM (+1)
15:34:52 <lambdabot> bzzt
15:35:29 <lispy> @type (+1)
15:35:30 <lambdabot> forall a. (Num a) => a -> a
15:35:47 <lispy> @type Control.Monad.liftM (+1)
15:35:48 <lambdabot> forall a1 (m :: * -> *).
15:35:48 <lambdabot>           (Monad m, Num a1) =>
15:35:48 <lambdabot>           m a1 -> m a1
15:36:04 <lispy> @eval Control.Monad.ap (Control.Monad.liftM (+1)) (Just 1)
15:36:06 <lambdabot> Couldn't match `(->) (a -> a1)' against `Maybe'
15:36:40 <lispy> hmm...
15:37:18 <lispy> @type Control.Monad.ap
15:37:20 <lambdabot> forall b (m :: * -> *) a.
15:37:20 <lambdabot>        (Monad m) =>
15:37:20 <lambdabot>        m (a -> b) -> m a -> m b
15:37:28 <lispy> ah
15:37:54 <lispy> @eval ap (Just (+1)) (Just 1)
15:37:56 <lambdabot> Just 2
15:38:18 <mauke> have you seen http://www.ping.uio.no/~mariube/haskell.png ?
15:39:22 <lispy> mauke: i don't get it
15:39:40 <mauke> lispy: scroll to the right, the sponsored link
15:39:45 <xerox> O_O
15:40:09 <Lemmih> heh
15:40:16 <lispy> hahah
15:40:23 <liyang> Well it makes perfect sense if you ever read thedailywtf...
15:40:32 <xerox> Yup :-)
15:49:30 <lispy> haggis  The Haggis GUI toolkit  <-- any good?
15:49:55 <xerox> Gtk! Gtk! Gtk!
15:50:12 <lispy> that's what i thought :)
16:18:03 <xerox> Are let bindings sequentially bound?
16:19:59 <musasabi> no.
16:20:15 <xerox> What if one does
16:20:22 <xerox> do let a = 1
16:20:26 <xerox>    let b = 2
16:20:30 <xerox>    let c = a
16:20:37 <musasabi> xerox: let a = b; b = a in 1
16:21:03 <musasabi> lets in a do are sequental.
16:21:03 <lispy> xerox: the let in do is different
16:21:07 <fluxx> even more to the point, does haskell have let a = a + 1 ?
16:21:13 <xerox> Great.
16:21:21 <lispy> @type let a = a +1 in a
16:21:22 <lambdabot> forall a. (Num a) => a
16:21:27 <mauke> hahaha
16:21:30 <xerox> Are they sequential even if I do not write let every line?
16:21:37 <lispy> @eval let a = a +1 in a
16:21:38 <lambdabot> Fail: <<loop>>
16:21:38 <lambdabot>  
16:21:42 <mauke> Hugs.Base> let a = a + 1 in a
16:21:42 <mauke> Segmentation Fault (core dumped)
16:21:48 <shrimpx> haha
16:21:54 <lispy> and that's a reason to use ghc :)
16:21:54 <xerox> *O_O*
16:22:06 <shrimpx> that's hugs' way to run out of stack
16:22:11 <mauke> infinite recursion without functions. nice.
16:22:39 <lispy> well, + is a function :)
16:22:44 <shrimpx> let a = 1 : a in take 10 a
16:22:48 <fluxx> @eval let a = 1 in let a' = a in let a = a' + 1 in a
16:22:49 <lambdabot> 2
16:22:53 <musasabi> @eval let a = a in a
16:22:55 <lambdabot> Ambiguous type variable `a' in the top-level constraint
16:22:59 <fluxx> difficult ;
16:23:00 <fluxx> )
16:23:08 <musasabi> @eval let a = (a :: Int) in a
16:23:10 <lambdabot> Fail: <<loop>>
16:23:10 <lambdabot>  
16:23:14 <musasabi> :-)
16:23:25 <lispy> @eval do let a = 5; b = 6; c = 7; return a
16:23:26 <lambdabot> parse error on input `)'
16:23:32 <lispy> @eval do{ let a = 5; b = 6; c = 7; return a}
16:23:33 <lambdabot> parse error on input `}'
16:23:37 <shrimpx> @eval let a = 1 : a in take 10 a
16:23:38 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
16:23:50 <lispy> @eval do{ let a = 5; let b = 6; let c = 7; return a}
16:23:51 <lambdabot> parse error on input `}'
16:23:53 <mauke> even OCaml can do let rec a = 1 :: a in a
16:24:04 <fluxx> ocaml can do also let a = 42 in let a = a + 1
16:24:10 <fluxx> which is sometimes actually useful
16:24:21 <shrimpx> every language does that
16:24:21 <lispy> why dosn't that eval
16:24:26 <mauke> yeah, because OCaml's let is non-rec by default
16:24:27 <fluxx> except haskell
16:24:36 <shrimpx> lame
16:24:41 <shrimpx> oh yes
16:25:06 <lispy> @type do { let a = 5; let b = 6; let c = 7; return a}
16:25:08 <lambdabot> bzzt
16:25:17 <lispy> is that a parse error?
16:25:24 <shrimpx> i wonder if that's in the standard
16:26:07 <mauke> @eval do { a <- [5]; let b = 6; let c = 7; return a }
16:26:08 <lambdabot> parse error on input `}'
16:26:13 <lispy> @type do { let a = 5; return a}
16:26:14 <lambdabot> bzzt
16:26:30 <mauke> @eval do { 42 }
16:26:31 <lambdabot> <Plugins.Eval>:1:
16:26:31 <lambdabot>   No instance for (Num (t t1))
16:26:31 <lambdabot>   arising from the literal `42'
16:26:41 <lispy> @eval do { return 42 }
16:26:42 <lambdabot> <Plugins.Eval>:1:
16:26:42 <lambdabot>   No instance for (Show (m a))
16:26:42 <lambdabot>   arising from use of `show'
16:26:59 <mauke> @eval do { return 42 } :: [Int]
16:27:01 <lambdabot> [42]
16:27:27 <lispy> @eval do { let a = 42; return a } :: [Int]
16:27:28 <lambdabot> parse error on input `}'
16:27:46 <mauke> @eval do { a <- [42]; return 42 } :: [Int]
16:27:47 <lambdabot> [42]
16:27:51 <mauke> @eval do { a <- [42]; return a } :: [Int]
16:27:53 <lambdabot> [42]
16:28:00 <mauke> @eval do { a <- [42]; let b = 7; return a } :: [Int]
16:28:01 <lambdabot> parse error on input `}'
16:28:11 <shrimpx> hmm
16:28:17 <lispy> i thought that was valid syntax
16:28:38 <lispy> @eval do { let {a = 42}; return a } :: [Int]
16:28:39 <lambdabot> [42]
16:28:49 <lispy> now it makes more sense
16:29:34 <lispy> @eval do { let {a = 42; b=2; c=3} ;return (a,b,c) } :: [Int]
16:29:35 <lambdabot> Couldn't match `Int' against `(t, t1, t2)'
16:29:46 <lispy> @eval do { let {a = 42; b=2; c=3} ;return (a,b,c) } :: [(Int, Int, Int)]
16:29:48 <lambdabot> [(42,2,3)]
16:31:05 <mauke> @eval do { let {a = b; b = a}; a + b}
16:31:06 <lambdabot> <Plugins.Eval>:1:
16:31:06 <lambdabot>   No instance for (Num (t t1))
16:31:06 <lambdabot>   arising from use of `+'
16:31:09 <heatsink> @pl let {x a b = a b z; y a b = x (a b) y; z = y x} in x
16:31:10 <lambdabot> (line 1, column 5):
16:31:10 <lambdabot> unexpected "{"
16:31:10 <lambdabot> expecting natural, identifier or "in"
16:31:16 <heatsink> @pl let {x a b = a b z; y a b = x (a b) y; z = y x;} in x
16:31:17 <lambdabot> (line 1, column 5):
16:31:17 <lambdabot> unexpected "{"
16:31:17 <lambdabot> expecting natural, identifier or "in"
16:32:03 <lispy> mauke: Num is not a monad so you can't implicitly return it from do
16:32:18 <lispy> mauke: you have to explicitly use 'return' so that the value will be 'injected' into the monad
16:32:42 <mauke> aww, I thought do { X } was the same as X
16:32:52 <shrimpx> if x is atomic
16:33:04 <shrimpx> oh wait no
16:33:10 <lispy> only if X is a monad
16:33:16 <lispy> and the types line up
16:33:29 <lispy> @type do { [1] }
16:33:30 <lambdabot> forall a. (Num a) => [a]
16:33:40 <lispy> that works because list is a monad
16:33:51 <lispy> @type do { 1 }
16:33:51 <mauke> suk
16:33:52 <lambdabot> forall (t :: * -> *) t1. (Num (t t1), Monad t) => t t1
16:34:10 <lispy> i have no idea what that thing is
16:34:36 <lispy> @type return 1
16:34:37 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
16:35:28 <mauke> ah, it's basically (Monad m, Num (m a)) => m a
16:35:34 <shrimpx> so do putStrLn "hi" is the same as putStrLn "hi"
16:35:42 <xerox> ./Graphics/Rendering/Cairo.hs: file name does not match module name `Cairo'
16:35:50 <xerox> OK I got it, sorry :P
16:36:31 <lispy> @type do putStrLn "hi"
16:36:33 <lambdabot> IO ()
16:36:54 <lispy> @type return (putStrLn "hi")
16:36:55 <lambdabot> forall (m :: * -> *).
16:36:55 <lambdabot>          (Monad m) =>
16:36:55 <lambdabot>          m (IO ())
16:37:20 <lispy> mauke: so that thing about when return is needed is really handy when working inside a monad
16:37:39 <lispy> @eval do { a <- return 1; return a}
16:37:40 <lambdabot> <Plugins.Eval>:1:
16:37:40 <lambdabot>   No instance for (Show (m a))
16:37:40 <lambdabot>   arising from use of `show'
16:37:47 <lispy> @eval do { a <- return 1; return a} :: [Int]
16:37:49 <lambdabot> [1]
16:38:26 <lispy> by using return, i injected the 1 into the monad, and then I use '<-' to 'strip away' the monad and get the 1 back
16:38:33 <mauke> @eval do { a <- (return 1) :: IO Int; return a }
16:38:35 <lambdabot> No IO allowed
16:39:12 <lispy> @eval do { a <- (return 1) :: IO Int; return a } :: [Int]
16:39:14 <lambdabot> Couldn't match `[]' against `IO'
16:39:56 <lispy> @eval do { return (a <- do { return 1 :: IO Int })}
16:39:57 <lambdabot> parse error on input `<-'
16:40:06 <lispy> @eval do { return (do { return 1 :: IO Int })}
16:40:07 <lambdabot> <Plugins.Eval>:1:
16:40:07 <lambdabot>   No instance for (Show (m (IO Int)))
16:40:07 <lambdabot>   arising from use of `show'
16:40:10 <mauke> huhu, do you want to extract stuff from the IO monad?
16:40:31 <lispy> i was trying to get lambdabot to 'allow' IO :)
16:40:40 <lispy> @type do { return (do { return 1 :: IO Int })}
16:40:41 <lambdabot> forall (m :: * -> *).
16:40:41 <lambdabot>                (Monad m) =>
16:40:41 <lambdabot>                m (IO Int)
16:40:54 <lispy> @type do { return (do { return 1 :: IO Int })} :: [IO Int]
16:40:55 <lambdabot> [IO Int] :: [IO Int]
16:41:01 <lispy> @eval do { return (do { return 1 :: IO Int })} :: [IO Int]
16:41:02 <lambdabot> No IO allowed
16:41:39 <mauke> @eval (2.0 `sqrt`)
16:41:40 <lambdabot> <Plugins.Eval>:1:
16:41:40 <lambdabot>   No instance for (Floating (t -> t1))
16:41:40 <lambdabot>   arising from use of `sqrt'
16:41:59 <mauke> it works in hugs
16:42:12 <shrimpx> that's the wrong thing to say in this channel
16:43:26 <lispy> mauke: what does it produce?
16:43:38 <mauke> 1.4142135623731
16:43:45 <TheHunter> @pl let x a b = a b z; y a b = x (a b) y; z = y x in x
16:43:48 <lambdabot> fst (fix (uncurry ((`ap` snd) . (. fst) . flip ((.) . (,) . flip
16:43:48 <lambdabot> flip) . ap (ap . ((,) .) . flip id) (flip . (flip .) . (.)))))
16:43:50 <mauke> obviously
16:43:55 <lispy> TheHunter: hehe
16:44:15 <lispy> i like 'flip id'
16:44:25 <lispy> @type (flip id)
16:44:26 <lambdabot> forall b c. b -> (b -> c) -> c
16:44:33 <TheHunter> @pl flip id x
16:44:34 <lambdabot> ($ x)
16:44:48 <shrimpx> ridic
16:45:25 <lispy> flip id seems crazy to me
16:45:28 <lispy> @type flip
16:45:30 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
16:45:49 <lispy> @type id
16:45:50 <lambdabot> forall a. a -> a
16:45:56 <TheHunter> flip id === flip ($), maybe that's a little bit clearer
16:45:58 <lispy> so how does that even vork?
16:46:12 <mauke> id f x == f x
16:46:19 <lispy> does flip need something of type a -> b -> c ?
16:46:20 <mauke> flip id x f == f x
16:47:10 <lispy> flip (id x) f = f x
16:47:11 <heatsink> TheHunter: oh, no braces.
16:47:20 <heatsink> @type ap
16:47:21 <lambdabot> bzzt
16:47:26 <lispy> @hoogle ap
16:47:27 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
16:47:27 <lambdabot> Prelude.appendFile :: (FilePath -> String -> (IO ()))
16:47:27 <lambdabot> Ratio.approxRational :: RealFrac a => (a -> a -> Rational)
16:47:52 <lispy> @eval Control.Monad.ap (Just (+1)) (Just 2)
16:47:54 <lambdabot> Just 3
16:48:10 <lispy> @hoogle foldM
16:48:10 <lambdabot> Monad.foldM :: Monad a => ((b -> c -> (a b)) -> b -> [c] -> (a b))
16:48:11 <mauke> lispy: huh? since when is flip x f == f x?
16:48:30 <TheHunter> @type (Control.Monad.Reader.ap :: (r -> a -> b) -> (r -> a) -> r -> b)
16:48:32 <lambdabot> forall r
16:48:32 <lambdabot>                          a
16:48:32 <lambdabot>                          b.
16:48:32 <lambdabot>                        (r -> a -> b)
16:48:32 <lambdabot>                        -> (r -> a)
16:48:34 <lambdabot>                        -> r
16:48:35 <lambdabot>                        -> b
16:48:50 <lispy> mauke: i dunno, flip id isn't making sense to me
16:49:08 <mauke> think of id as function application
16:49:34 <mauke> which it is, as long as its argument is a function
16:49:49 <lispy> id head [1..3]
16:49:53 <lispy> @eval id head [1..3]
16:49:54 <lambdabot> 1
16:50:11 <TheHunter> @eval haed `id` [1..3]
16:50:12 <lambdabot> Variable not in scope: `haed'
16:50:16 <TheHunter> @eval head `id` [1..3]
16:50:18 <lambdabot> 1
16:50:33 <lispy> oh, and id (head [1..3]) == (id head) [1..3]
16:50:38 <mauke> (`id` [1..3]) head
16:50:45 <mauke> @eval (`id` [1..3]) head
16:50:46 <lambdabot> 1
16:51:18 <lispy> er...
16:51:25 <lispy> @type (`id` [1..3])
16:51:27 <lambdabot> forall t a. (Num a, Enum a) => ([a] -> t) -> t
16:51:48 <TheHunter> (`id` x) === flip id x
16:52:17 <lispy> @type \x -> `id` x
16:52:19 <lambdabot> bzzt
16:52:24 <lispy> @type \x -> (`id` x)
16:52:25 <lambdabot> forall t t1. t -> (t -> t1) -> t1
16:52:31 <mauke> @type (`id` ([1..3] :: [Int]))
16:52:32 <lambdabot> forall t. ([Int] -> t) -> t
16:52:59 <lispy> @type \x -> (id x)
16:53:01 <lambdabot> forall a. a -> a
16:53:15 <lispy> that infix notation is what is screwing with me
16:53:27 <lispy> @type `id`
16:53:28 <lambdabot> bzzt
16:53:35 <shrimpx> @eval flip id 10 id
16:53:37 <lambdabot> 10
16:53:38 <mauke> @type (`id`)
16:53:39 <lambdabot> bzzt
16:53:53 <lispy> well, (`id`) == id right?
16:53:59 <mauke> apparently not
16:54:02 <xerox> How do I [Char] -> CChar ?
16:54:03 <heatsink> it would be if syntax permitted it
16:54:04 <lispy> well, it doesn't parse
16:54:21 <lispy> @hoogle [Char] -> CChar
16:54:22 <lambdabot> List.genericLength :: Integral a => ([b] -> a)
16:54:22 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => (a -> b)
16:54:22 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => (a -> b)
16:54:28 <mauke> @type (`elem`)
16:54:29 <lambdabot> bzzt
16:54:34 <lispy> xerox: do you mean [CChar] ?
16:54:41 <xerox> lispy, no :(
16:54:55 <lispy> xerox: is CChar used for char* ?
16:54:55 <heatsink> xerox: do you mean CString?
16:55:17 <xerox> lispy, yes
16:55:23 <xerox> heatsink, is it the same?
16:56:04 <xerox> it's the damn last thing for this night - if it worked hopefully the rest is OK (at least compiles)
16:56:12 <heatsink> xerox: no.  CChar is a char * const
16:56:21 <xerox> let me check
16:56:27 <heatsink> xerox: CChar has to have a compile-time known address.
16:56:30 <xerox> const char *filename
16:56:31 <xerox> yep
16:56:34 <xerox> OK.
16:56:57 <heatsink> that's what you're doing?
16:57:35 <xerox> Hmm
16:57:48 <xerox> foo :: CChar
16:57:52 <xerox> foo = "foo"
16:57:56 <xerox> doesn't work, right?
16:58:09 <heatsink> that won't work
16:58:17 <heatsink> what are you trying to do?
16:58:30 <xerox> Passing a string to a foreign function getting a "const char*"
16:59:01 <heatsink> pass it a CString
16:59:15 <sylvan> I believe the c2hs docs has an example doing just this...
16:59:33 <heatsink> @type newCString
16:59:35 <lambdabot> bzzt
16:59:40 <sylvan> but yeah, you could just build a CString and pass that
16:59:45 <xerox> Sorry sylvan, I'm a bit sleepy but I really liked to have something working before going to bed.
17:00:38 <xerox> @index newCString
17:00:39 <lambdabot> Foreign.C.String, Foreign.C
17:00:48 <xerox> @type Foreign.C.String.newCString
17:00:49 <lambdabot> String
17:00:49 <lambdabot>            -> IO Foreign.C.String.CString
17:00:53 <xerox> OK.
17:04:24 <xerox> Nah.
17:04:32 <heatsink> huh?
17:05:29 <xerox> StarAndRing.hs:100:30:
17:05:30 <xerox>     Couldn't match `Foreign.C.Types.CChar' against `CString'
17:05:30 <xerox>       Expected type: Foreign.C.Types.CChar
17:05:30 <xerox>       Inferred type: CString
17:05:40 <heatsink> how did you import the function?
17:05:47 <xerox> {#fun surface_write_to_png { id `Surface', `CString' } -> `()'#}
17:05:58 <xerox> Err, it is CChar, I'm trying with CString now
17:06:10 <xerox>   There is no default marshaller for this combination of Haskell and C type:
17:06:11 <xerox>   Haskell type: CString
17:06:11 <xerox>   C type      : (Ptr CChar)
17:06:11 <heatsink> network topology?
17:06:33 <xerox> let's try...
17:06:45 <heatsink> CString is defined as Ptr CChar.
17:06:51 <xerox> I know :(
17:07:08 <xerox> Compiling C2HS             ( /usr/local/lib/c2hs-0.14.1//C2HS.hs, interpreted )
17:07:08 <xerox> Compiling Graphics.Rendering.Cairo ( ./Graphics/Rendering/Cairo.hs, interpreted )
17:07:08 <xerox> Compiling StarAndRing      ( StarAndRing.hs, interpreted )
17:07:08 <xerox> Ok, modules loaded: StarAndRing, Graphics.Rendering.Cairo, C2HS.
17:07:08 <xerox> *StarAndRing>
17:07:11 <xerox> ta-da !!! :-)
17:07:17 <heatsink> yay
17:07:26 <xerox> *StarAndRing> main
17:07:27 <xerox> Loading package haskell98-1.0 ... linking ... done.
17:07:27 <xerox> *StarAndRing>
17:08:53 <xerox> Wanna see the output?
17:08:53 <xerox> http://haskell.galois.com/~paolo/star_and_ring.png
17:09:01 <xerox> A bit "O_o" but I'm very happy.
17:09:31 <lispy> xerox: what have you been building? and you work for galois?
17:09:33 <heatsink> you must have measured things by hand before rendering.
17:09:46 <xerox> heatsink, yup
17:09:48 <heatsink> it looks nice, but is the noise there on purpose?
17:10:01 <xerox> lispy, haskell cairo binding - no I do not work for galois
17:10:04 <xerox> heatsink, it is not :(
17:10:22 <lispy> xerox: ah, i guessed by the url ;)
17:10:32 <lispy> but you probably guessed that i guessed by the url
17:10:52 <xerox> lispy, I think I blogged about it
17:11:07 <xerox> heatsink, where do you think could be the error about the noise?
17:11:26 <lispy> well, peace out, time for me to catch a bus
17:11:34 <xerox> I should sleep: 02:12 am
17:12:03 <heatsink> xerox: I have no idea.
17:12:15 <xerox> Want me to share the source code?
17:12:23 <heatsink> how much is it?
17:12:27 <heatsink> how big is it?
17:13:06 <xerox> 107 lines for the program, less the binding
17:13:16 <heatsink> yea, I could take a look
17:13:56 <xerox> http://haskell.galois.com/~paolo/StarAndRing.hs
17:14:40 <xerox> Could it be because of the (-number) ?
17:14:49 <xerox> @eval -2
17:14:51 <lambdabot> -2
17:14:55 <xerox> @eval -2.2
17:14:57 <lambdabot> -2.2
17:14:58 <xerox> Nah.
17:15:19 <heatsink> what does the matrix do?
17:15:52 <xerox> matrix_init does:
17:15:53 <xerox> Sets matrix to be the affine transformation given by xx, yx, xy, yy, x0, y0. The transformation is given by:
17:16:01 <heatsink> ok
17:16:24 <xerox> OH
17:16:39 <xerox> That's probably random data, I don't initialize the surfaces
17:16:41 <xerox> Let me try.
17:16:54 <xerox> I mean _clear_ them
17:17:08 <Beelsebob> lo
17:17:11 * heatsink was just about to suggest fully opaque colors
17:17:15 <heatsink> hi
17:19:18 <mauke> huhu, http://www.olympus-europa.com/consumer/208_manuals.cfm?prodID=P_N1745492
17:19:44 <mauke> "Basic Instruction Manual: 62.482.324.218.749.952 KB"
17:20:08 <heatsink> wow
17:21:09 <xerox> http://haskell.galois.com/~paolo/star_and_ring.png
17:21:11 <xerox> TA-DAAAA!!!
17:21:41 <Beelsebob> hmm?
17:21:50 <heatsink> pretty
17:22:21 <xerox> Great
17:22:30 <xerox> Reload the sourcecode url to see the "fix"
17:22:36 <shrimpx> xerox: you work at galois?
17:22:46 <xerox> Also I have to fix the CString thing, it has to be freed
17:22:48 <xerox> shrimpx, nope
17:23:43 <xerox> OK done.
17:24:05 <xerox> Have fun, Haskell kicks ass.
17:24:19 <heatsink> shall do shall do and goodnight xerox
17:33:48 <TheHunter> @index runInteractiveProcess
17:33:49 <lambdabot> System.Process
17:33:53 <xerox> I couldn't wait: http://haskell.org/gtk2hs/archives/category/cairo
17:54:25 <TheHunter> dons, i'm trying to get lambdabot not to crash when it doesn't find an executable, but i think hPutStr is broken.
18:10:58 <TheHunter> hmm, mabye we gotta ignore SIGPIPE
18:13:47 <dons> so checking for the executable doesn't help?
18:14:11 * TheHunter honestly didn't think of that.
18:14:27 <TheHunter> ignore my patch then.
18:14:50 <TheHunter> it's obviously not the right thing, but probably good enough.
18:14:55 <dons> heh. nonetheless, you raise a good point -- it really should be throwing an exception
18:15:40 <TheHunter> the documentation of hGetBufNonBlocking has some insight, maybe if we ignore SIGPIPE, we actually get an exception.
18:18:12 <TheHunter> sorry, *hPutBuf
18:19:11 <TheHunter> hmm, so how to ignore SIGPIPE?
18:20:21 <TheHunter> grr, this is exactly the kind of thing you don't want to deal with if you're choosing a higher-level language.
18:22:32 <TheHunter> do I want emptySignalSet or fullSignalSet?
18:22:33 <TheHunter> oh, I prolly want Nothing
18:24:51 <TheHunter> yep, that did it - will send a new patch.
18:28:11 <dons> yeah, you installHandler sig Ignore Nothing
18:28:20 <dons> if I recall correctly
18:28:45 <dons> I notice in Yi that I:
18:28:46 <dons>     sequence_ $ flip map [sigPIPE, sigALRM]
18:28:47 <dons>                           (\sig -> installHandler sig Ignore Nothing)
18:29:29 <TheHunter> you think i should ignore sigALRM, too?
18:29:46 <TheHunter> (flip mapM_ $ ...)
18:30:09 <dons> hehe. true.
18:30:22 <dons> I see: SIGALRM         terminate process       real-time timer expired
18:30:47 <dons> well, I don't know if we have any timers, but probably good to ignore it.
18:30:53 <dons> rather than killing lambdabo
18:31:23 <TheHunter> i just darcs sent before you said that..
18:31:53 <dons> got it, I'll add in sigALRM
18:33:00 <dons> so this makes the previous patch unnecessary?
18:33:18 <TheHunter> yes!
18:33:28 <dons> yes. nice solution
18:33:59 <TheHunter> there still some timeing issues, i.e sometimes we get Terminated, sometimes fd:8: hClose: resource vanished (Broken pipe)
18:34:24 <dons> ok
18:34:52 <TheHunter> but no crashes anymore, apparently.
18:37:01 <TheHunter> do you also have that problem that lambdabot sometimes freezes after "Loading plugins ........................... done."
18:37:43 <dons> not freeze, but sometimes not connecting to freenode
18:38:23 <TheHunter> right, not freeze, just doing nothing at all.
18:38:41 <TheHunter> @hoogle ap
18:38:41 <lambdabot> Monad.ap :: Monad a => ((a (b -> c)) -> (a b) -> (a c))
18:38:41 <lambdabot> Prelude.appendFile :: (FilePath -> String -> (IO ()))
18:38:41 <lambdabot> Ratio.approxRational :: RealFrac a => (a -> a -> Rational)
18:38:42 <thbot> Monad.ap :: Monad m => m (b -> c) -> m b -> m c
18:38:42 <thbot> Prelude.appendFile :: FilePath -> String -> IO ()
18:38:42 <thbot> Ratio.approxRational :: RealFrac a => a -> a -> Rational
18:38:53 <TheHunter> @plugs ap (+) (+1) 1
18:38:54 <lambdabot> <Plugins.Eval>:1:
18:38:54 <lambdabot>   No instance for (Monad ((->) a))
18:38:54 <lambdabot>   arising from use of `ap'
18:38:54 <thbot> 3
18:39:37 <dons> oh good, you were able to compile runplugs.  I should update then too
18:40:03 <dons> hmm, though I'll have to install head
18:40:39 <TheHunter> didn't that change make it into 6.4.1?
18:40:53 <dons> I didn't think so. maybe it did but I missed it
18:41:14 <dons> anyway, I already have head on this box (from last nights build)
18:41:17 <TheHunter> oh, i didn't check, i just assumed.
18:42:37 <TheHunter> gotta get something to eat, bbl.
18:42:59 <dons> ciao
19:25:57 <TheHunter> mmmmh, pizza.
20:11:39 <dons> @eval ap (+) (+1) 1
20:11:40 <lambdabot> 3
20:14:19 <dons> TheHunter, should I also switch to ghci-6.5 for @type?
20:14:38 * dons tries it anyway
20:18:22 <TheHunter> yes, the output should get much cleaner.
20:18:32 <TheHunter> @type 1 :: Int
20:18:37 <lambdabot> Int :: Int
20:19:07 <TheHunter> @todo-add @type 1 :: Int
20:19:09 <lambdabot> Entry added to the todo list
20:23:57 <dons> that was with 6.4, I'm currently rebuilding with 6.5
20:28:49 <TheHunter> it will still happen. @type cuts after the first top-level ::, should use the last one.
20:30:18 <dons> @version
20:30:19 <lambdabot> lambdabot 3p67, GHC 6.5 (OpenBSD i386)
20:30:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:32:07 <TheHunter> yay!
20:32:16 <TheHunter> @type (\x y z w -> x z w y)
20:32:17 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> t2 -> t -> t1 ->
20:32:17 <lambdabot> t3
23:04:25 <dons> @code
23:04:26 <lambdabot> Ptr.hs: instance Show (FunPtr a) where
23:04:32 <dons> @code
23:04:33 <lambdabot> FunctorM.hs: instance Ix i => FunctorM (Array i) where
23:33:31 <zvrba> hi all
23:34:01 <zvrba> how does one do large numerical computations in haskell? e.g. given an array of 1000x1000 floats, you'd have to make a copy to change a single value
23:34:10 <zvrba> as I understand, there are no side-effects
23:34:22 <zvrba> and relatively simple calculation like Gaussian elimination has O(n^3) updates
23:39:52 <Cale> zvrba: there are ways to deal with mutable variables if needed
23:41:16 <Cale> zvrba: The ST monad for one. However, there are usually functional algorithms which don't rely so much on updates to mutable cells
23:42:20 <zvrba> ok, thanks
23:52:03 <shrimpx> zvrba: also updates don't generally imply lots of copying. E.g., when updating a node in a purely functional tree, only the spine up to the root is copied -- a linked list smaller than log n in length. everything else stays the same
23:52:25 <shrimpx> it depends on how you model your data structures quite a bit
23:53:19 <ski> @ghci
23:53:21 <lambdabot>  Exotic pattern inside meta brackets
