00:29:40 <musasabi> I think I solved that one.
00:42:12 <paolo> They want to go somewhere today, hmpf... good "today's holiday"... bye
01:24:35 <musasabi> How do I compile a single C file in Setup.lhs with Cabal ?
01:25:16 <Lemmih> With no Haskell file using it?
01:26:35 <musasabi> Yes, I am trying to test things in a postconf hook so I can make cc-options correct to make the main build succesfull.
01:27:12 <Lemmih> Cabal doesn't support that.
01:27:33 <musasabi> So autoconf is the only way?
01:29:03 <Lemmih> Perhaps an executable with an empty Haskell main and the C file in C-Sources could do.
01:29:51 <musasabi> Lemmih: but how does that help because without passing the correct cc-options the build will fail.
01:30:13 <musasabi> and it is quite trivial to detect *if* one can compile C files to test things.
01:31:15 <Lemmih> Oh, I misunderstood.
01:33:08 <musasabi> Otherwise I would just use plain "gcc tempfile.c" but gcc might use a different search path than ghc (or might even be outside the current path).
01:33:40 <Lemmih> Compile the C file with GHC then.
01:34:12 <Lemmih> You can get the patch to GHC from LocalBuildInfo.
01:34:21 <musasabi> Lemmih: that is the easy solution, then I notice "what to do with hugs" and end up duplicating Distribution.Simple.Build.
01:34:31 <Lemmih> s/patch/path/
01:35:02 <Lemmih> Use GHC with GHC, GCC with everything else?
01:35:47 <musasabi> hugs seems to use ffihugs + a host of flags.
01:35:54 <musasabi> But I think I can live with that.
01:36:16 <Lemmih> Can you compile the C file with ffihugs?
01:38:06 <musasabi> I think it should possible, but I am not very familiar with hugs.
01:56:24 <basti_> hey
01:57:30 <ski> yeh
01:58:15 <Oejet> ehy
01:58:22 <basti_> @permutate hey
01:58:22 <lambdabot> Unknown command, try @listcommands.
01:59:12 <ski> @per-mutate hey
01:59:13 <lambdabot> Unknown command, try @listcommands.
01:59:25 <ski> hey -> ehy -> why
01:59:29 <basti_> @mutate
01:59:30 <lambdabot> world
01:59:34 <basti_> o0
02:47:54 <Lemmih> @quote
02:47:55 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a
02:47:55 <lambdabot> bike rode up next to me and said, "There's always a show off." I
02:47:55 <lambdabot> offered to teach him to ride and help set up a unicycle patrol squad,
02:47:55 <lambdabot> but he declined.
02:56:50 <Oejet> Hehe, that sounds like a quote from Finland.
03:01:04 <dblhelix> mmm... my week has just begun and I find myself typing "import Debug.Trace"... that can't be good
03:02:06 <Oejet> dblhelix: You'll spend the whole week fixing bugs from last week.
03:02:23 <dblhelix> Oejet: probably :)
03:05:31 <kaol> are there ready tarballs of the haskell reader issues somewhere?
03:05:50 <shapr> tarballs?
03:06:18 <kaol> I could invoke wget to get them too
03:06:27 <shapr> ohh
03:06:35 <kaol> I'd like to read them sometime when I'm possibly offline
03:06:38 <shapr> No, but that's a good idea.
03:07:06 <kaol> I found the first one as a single pdf
03:07:44 <shapr> That's because the first issue used LaTeX submissions, but I don't know LaTeX. It was a lot of extra work.
03:08:03 <ndm> shapr, it can't be that much effort to convert the wikitext into latex
03:09:17 <ndm> as in an automated convertor wouldn't be that hard in haskell - i'd have thought about 30 mins after parsing
03:09:18 <kaol> the format isn't that important, it was just convenient to have it as a single downloadable bundle
03:10:02 <shapr> kaol: Yeah, that's a good point. I'll see what I can do, but it won't get fixed today.
03:10:20 <kaol> ok. no hurry. and thanks.
03:10:41 <shapr> Good idea, thanks for the suggestion.
03:11:55 <kaol> haskell is fun. But you all knew it already.
03:12:30 <shapr> ndm: Yeah, but my priority was speed of change, and I'm not so pushed to learn LaTeX.
03:12:30 * shapr agrees!
03:12:32 <shapr> ndm: Oleg had the idea to use lhs2TeX as the input, I think that really will happen.
03:13:49 <ndm> shapr, how come the thing at the top of this irc hask tmrwiki/IssueFour
03:14:04 <ndm> but http://www.haskell.org/tmrwiki lists only 3 issues?
03:15:01 <dcoutts> musasabi, what was your c2hs problem?
03:21:51 <shapr> whoops
03:21:58 <shapr> He left before I fixed it.
03:23:31 <tuomov> how's flm doing?
03:23:42 <shapr> Still not finished...
03:24:11 <shapr> But I'll put whatever I've got online this weekend if some other people want to hack on it.
03:26:59 <musasabi> dcoutts: c2hs failing to parse an .i file and me not knowing where the error was - then I tinkered a little bit and made a lucky guess.
03:27:35 <dcoutts> musasabi, so you've fixed something? what was the problem?
03:27:39 <musasabi> hsgnutls 0.2 is out with support to gnutls 1.0.X in addition to gnutls 1.2.x.
03:28:15 <musasabi> dcoutts: incompatible C library versions and thus typedefs not existing.
03:28:44 <dcoutts> oh, so the c2hs error message was no very good then, was that the problem?
03:31:36 <musasabi> yes, but I think it was because I was thinking in haskell-mode, and not in C-mode. When I think about it the error location makes perfect sense from C perspective.
03:31:47 <dcoutts> ok
05:17:40 <dons> $ id /usr/share/dict/words | fold -e '\x y -> y ++ "\n" ++ x'
05:17:45 <dons> h4sh is fun!
05:19:08 <vegai> whoa.
05:19:46 <vegai> by the way... any new insights on that ghc-6.4 vs runplugs -incident?
05:19:58 <dons> yep. all solved.
05:20:09 <dons> TheHunter tracked down a nice bug in System.Process
05:20:19 <vegai> ah, great
05:20:22 <dons> needs GHC HEAD, I think now.
05:20:30 <dons> not sure if the patch got backported
05:21:14 <vegai> I'll wait for the next release, then
05:23:40 <jyp> btw dons, how about a generic h4sh command; eg.
05:23:46 <jyp> h4sh 'fold \x y -> y ++ "\n" ++ x' < /usr/share/dict/words
05:23:58 <dons> oh, that would be ($)
05:24:09 <dons> well, map sort of is that already
05:24:10 <dons> map -e show.length /usr/share/dict/words | sort | reverse | take -n 3
05:24:23 <dons> map lets you apply a haskell fragment to each line.
05:24:41 <jyp> oh yes; I didn't think about that
05:24:43 <dons> i.e. unlines . map f . lines
05:25:48 <dons> $ cons "foo" /usr/share/dict/words| take -n 2
05:25:48 <dons> foo
05:25:48 <dons> A
05:26:10 <dons> cycle *.hs is lots of fun too :)
05:26:52 <bourbaki> moin
05:29:19 * Lemmih is getting extreme frustrated.
05:29:40 <shapr> What's up?
05:30:04 <Lemmih> The GHC parser is very tricky.
05:30:21 <jyp> indentation ?
05:30:27 <dons> bring on -package ghc!
05:30:56 * shapr indents jyp with a stick!
05:31:13 * jyp dives
05:31:49 <dons> have I told everyone to go and install h4sh yet? you should, it's fun!
05:31:59 <dons> map and fold in the shell make life good
05:32:02 * shapr darcs gets h4sh
05:32:05 <shapr> I like the name too
05:32:23 <lightstep> Is haskell a good language to model untyped transformations?
05:32:39 <jyp> sure
05:32:41 <Lemmih> It's kinda like extracting whiskey from water.
05:32:49 <dons> heh
05:33:06 <jyp> after all we all know "untyped" is a special case of "typed"
05:33:08 <jyp> :)
05:33:15 <wilx> Too many dependencies?
05:33:57 <tuomov> Could not find module `System.Eval':
05:34:01 <tuomov> (h4sh)
05:34:13 <shapr> Do you have hs-plugins installed?
05:34:13 <dons> needs hs-plugins 0.9.10 for higher order functions
05:34:24 <lightstep> Where's the webpage/repository?
05:34:32 <dons> @where h4sh
05:34:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
05:34:43 <shapr> @repo h4sh
05:34:44 <lambdabot> Maybe you meant: repo-add repo-del repos
05:34:50 <tuomov> can hs-plugins be installed in $HOME?
05:34:51 <dons> hs-plugins is needed for:         (a -> a)      -> [a] -> [a]
05:34:51 <dons>         (a -> Bool)   -> [a] -> [a]
05:34:51 <dons>         (a -> a -> a) -> [a] -> a
05:35:06 <dons> yep. PREFIX=/home/foo make install
05:35:20 <tuomov> and all the registering stuff works?
05:35:29 <dons> nah. it's just binaries. no haskell libs or anything.
05:35:58 <tuomov> but ghc needs to find System.Eval..
05:36:14 <dons> it will as long as hs-plugins was registered correctly
05:36:15 <tuomov> or do I need to do some mods to Makefile/Build.hs or something
05:36:30 <tuomov> but if I install it in $HOME, can it be registered correctly?
05:36:52 <dons> oh, sorry. you want to install hs-plugins in $HOME
05:36:55 <tuomov> yep
05:37:01 <dons> ./configure --prefix=$HOME
05:37:09 <tuomov> yes, but does make register work?
05:37:12 <dons> then make register will deal with it
05:37:24 <dons> sure. but it needs to write the global package file
05:37:51 <tuomov> but I can't install it as user?
05:37:56 <tuomov> (not root)
05:38:45 <dons> the lib can be installed as a user. registering will need whatever perms the global package.conf needs. no user installs unfortunately.
05:38:49 <musasabi> @seen CosmicRay
05:38:50 <lambdabot> I saw CosmicRay leaving #haskell 2 days, 17 hours, 28 minutes and 50
05:38:50 <lambdabot> seconds ago, and I have missed 2 minutes and 1 second since then.
05:38:54 <dons> switching to cabal is a good idea
05:39:29 <tuomov> I guess I'll wait until I have network at home again then..
05:39:39 <dons> :/
05:40:45 <tuomov> the phone company connecting adsl takes forever over here
05:40:59 <tuomov> (4 to 6 weeks promised connection time)
05:41:10 <Lor> I just ordered adsl today, we shall see how long it takes.
05:41:21 <Lor> (Been without a net connection at home since I moved in march)
05:41:24 <tuomov> I ordered it about 5 weeks ago so it should be connected soon, but you never know
05:47:43 <dons> hehe. maybe we should work harder on shrinking the size of ghc-produces binaries
05:48:28 <ozone> ghc -Os? :)
05:48:30 <dcoutts> dons, shared libs :-)
05:48:40 <ozone> that too
05:49:04 <ozone> (though shared libs do make things a bit slower, at least on mac os x)
05:49:16 <dons> 22k .hs src in h4sh produced a build tree 64M bulid tree (without split objs)
05:49:49 <musasabi> jhc produces quite small executables.
05:49:59 <shapr> There's a thread on LtU where they say "source is always larger than the resulting binary" and I seriously considered showing them the Haskell statistics.
05:50:32 <Philippa> yeah
05:50:46 <Philippa> mind you, the RTS is pretty damn big
05:51:04 <shapr> Yeah, but the secret is folding complexity into the 'implied' part of the program.
05:51:08 <shapr> Monads do that well.
05:51:20 <shapr> hi Si\!
05:51:26 <ozone> dons: a proper dead-code stripper would help too
05:51:30 <Si\> hi
05:51:34 <dons> ozone, right.
05:51:47 <Spark> "source is always larger than the resulting binary" -- surely with enough inlining?
05:51:49 <ozone> dons: the darwin toolchain does that, and it helps quite a bit.  only problem is that the linking takes about 6 minutes ...
05:52:13 <dons> the "always larger" just seems silly
05:52:14 <ski> Spark : inlining of source or binary ?
05:52:24 <Spark> does source mean source code?
05:52:32 <Spark> and binary mean compiled code
05:52:42 <ski> usually, i think
05:53:02 <Spark> in that case the source code would call the function, but the binary would inline it, and thus be larger
05:53:09 <ozone> dons: ... or get a serialised bytecode format working ...
05:54:00 <dons> hmm. isn't 22k -> 64M something like ~32,000 times bigger binary than src :}
05:54:22 <dons> oh. brain explosion.
05:54:36 <dons> 3000x
05:55:19 <dons> that's better, with split objs its only 20M. so only 900x bigger
05:55:31 <shapr> In any case, Haskell tends to produce large binaries from small code, even with split-objs and PIC.
05:56:13 <dons> well, not with PIC though.
05:56:25 <dons> isn't hello world about 10k?
05:56:28 <dons> ozone?
05:56:57 <ozone> shapr: there was a bug in the mac os x code generator a while ago that caused HOC (which is probably ~150k) to make a build tree that was >10GB ;)
05:57:09 <dons> ozone wins!
05:58:11 <ozone> 19k
05:58:51 <dons> nitol!
05:58:53 * shapr gives the prize to ozone 
05:58:55 <ozone> nite don
05:59:15 <ozone> shapr: and i was wondering why it was taking so long to compile ...
05:59:21 * shapr grins
06:18:30 <jlouis> TheHunter: that writerLoop... why the 2 semaphores? Why just not wait until data arrives on the readChan, fire it off and let the thread wait?
06:19:22 <jlouis> (I must have missed some fine point)
06:20:08 <jlouis> ah, counting semaphore
06:20:15 <jlouis> didn't see that
06:21:23 <roconnor> what do I do if I find an error in the Haskell 98 report?
06:21:53 <Heffalump> email Simon Peyton Jones.
06:22:05 <lightstep> Say so on the mailing list.
06:22:28 <Oejet> Scream it out loud in your neighbourhood.
06:22:52 <roconnor> mail Malcolm wallace
06:24:06 <vikasg> is there a concise way to specify 'any char except this' in Parsec?
06:24:30 <lightstep> No, there isn't.
06:25:01 <vikasg> hm
06:26:01 <Philippa> I think there is for single chars
06:26:05 <jlouis> TheHunter: I think I see your flood protect bug
06:26:14 <Philippa> satify (/= 'a'), for example
06:26:27 <musasabi> notFollowedBy (char 'a') ?
06:26:58 <jlouis> TheHunter: must go read concurrent stuff ;)
06:27:18 <tuomov> noneOf ['a']
06:27:54 <vikasg> I want to parse string literals which are of the form char " <chars other than " and \> and char "
06:28:50 <jlouis> TheHunter: bleh, no. Back to drawing board with that idea. Can not be a bug.
06:29:29 <vikasg> so noneOf ['"', '\'] works nicely, thanks
06:30:09 <tuomov> " and \ separately or \ followed by "?
06:30:23 <tuomov> for the latter you need a bit more complex parser
06:30:28 <vikasg> separately
06:33:10 <timbod> h4sh sounds fun, but I can't build hs-plugins from a newly fetched archive with ghc-6.4.1, Error is Could not find module `Language.Haskell.Hsx'. Any hints?
06:33:40 <jlouis> timbod: read INSTALL of hs-plugins
06:33:55 <jlouis> you need an additional package for parsing haskell
06:35:02 <timbod> jlouis - thanks (a little embarassed)
07:09:26 <CosmicRay> Is it just me, or is unsafeInterleaveIO in hugs broken?
07:09:31 <CosmicRay> unsafeInterleaveIO :: IO a -> IO a
07:09:32 <CosmicRay> unsafeInterleaveIO f = return (unsafePerformIO f)
07:09:34 <CosmicRay> is how it is defined
07:09:42 <CosmicRay> and it seems that it is caching previous results from said call
07:09:52 <CosmicRay> I have code that works fine with ghc unsafeInterleaveIO but breaks in hugs
07:10:38 <Lemmih> How does it break in Hugs?
07:10:57 <CosmicRay> it appears that the operation behind the unsafeInterleaveIO is yielding the same result every time it is called
07:11:14 <CosmicRay> almost as I'd expect ghc to do if I used unsafePerformIO erroneously
07:12:59 <Heffalump> unsafeInterleaveIO is usually implemented as return . unsafePerformIO, FWIW.
07:13:17 <Heffalump> So your implementation has to be quite careful about how it handles that sequence to not screw the world up.
07:24:10 <CosmicRay> what are the semantics of that, btw?
07:24:24 <CosmicRay> so far I seem to use the "trial and error" method of making unsafeInterleaveIO work ;-)
07:24:54 <CosmicRay> I understand the normal cautions about unsafePerformIO
07:29:00 <roconnor> Can a class take multiple type arguements?
07:29:26 <wilx> Not in Haskell 98.
07:29:30 <ski> in haskell98, no   in common extensions, yes
07:29:46 <autrijus> cafepress++ # fun
07:29:56 <musasabi> CosmicRay: What is the state of dh_haskell with regards to ghc 6.4 (as it is in haskell-unsafe)
07:30:13 <musasabi> and hopefully in sid sometime...
07:30:15 <CosmicRay> musasabi: works fine with the ghc6.4 in sid, untested with the one in unsafe
07:30:45 <musasabi> Is there a way to install the ghc6.4 in sid?
07:33:54 <CosmicRay> are you running sid already, or...?
07:35:05 <musasabi> yes, other things are forcing me to run sid.
07:35:18 <musasabi> and the libgmp3c2 thing is causing problems.
07:38:43 <CosmicRay> musasabi: if you install the libgmp3 from sarge, the ghc6 in sid will work fine on your sid system
07:55:09 <ehuber_> hiho
07:55:32 <CosmicRay> hello
07:55:40 <Lemmih> hi
08:23:42 <Igloo> Did Simon say when his holiday began?
08:36:30 <liyang> Edinburgh-fringe Simon? (Or am I confusing people?)
08:38:46 <dcoutts> I just got back from performing at the Edinburgh fringe, perhaps I should have advertised it here :-)
08:41:54 <Igloo> Simon Marlow
08:47:28 <basti_> re
08:48:38 <liyang> I'm confusing people.
08:49:33 <liyang> dcoutts: you did, I poked friends up north to go. (Not sure if they made it though.)
08:51:11 <dcoutts> liyang, I was playing cheif weasel in a kids show :-)
08:51:52 <liyang> Is that saying I shouldn't have advertised it?
08:52:11 <CosmicRay> Igloo: sometime around now, and he's back at the end of the month'
08:52:17 <liyang> (Kids come in all ages, anyway.)
08:52:34 <dcoutts> liyang, well we had another show which was less aimed at families
08:52:35 <CosmicRay> shapr: my latest project is writing a utility that indexes files on CD-ROMs
08:52:55 <CosmicRay> shapr: I build up my own file list, and also run it through the namazu2 text indexing engine
08:53:05 <SyntaxNinja> CosmicRay: y0
08:53:09 <CosmicRay> morning SyntaxNinja
08:53:25 <CosmicRay> shapr: that will let me find data I've archived off to {DVD,CD}-ROM much easier
08:53:35 <dcoutts> shapr would have approved, I went handing out fliars for the show in weasel makup and riding my unicycle :-)
08:53:53 <CosmicRay> weasel makeup?
08:53:58 <SyntaxNinja> dcoutts: were you going to write me a feature for cabal for --in-place?
08:54:14 <SyntaxNinja> Lemmih: how's hackage?
08:54:34 * SyntaxNinja suddenly boings over shapr.
08:54:38 <dcoutts> CosmicRay, brown face, sunken eyes and wiskers :-)
08:54:47 <CosmicRay> heh
08:55:00 <dcoutts> SyntaxNinja, yes, either me or another gentoo packaging person
08:55:23 <Lemmih> Hey SyntaxNinja.
08:57:01 <Igloo> CosmicRay: Yeah, I'm just hoping he hasn't left before releasing ghc 6.4.1  :-/
09:03:52 <SyntaxNinja> hi Lemmih
09:03:55 <SyntaxNinja> dcoutts: ok cool.
09:04:03 <SyntaxNinja> dcoutts: do you remember what we decided about how best to do it?
09:04:25 <dcoutts> SyntaxNinja, not entirely :-)
09:05:05 <dcoutts> I think it was that --in-place would register into some well known name in the build dir eg "package.conf"
09:05:49 <dcoutts> SyntaxNinja, does that sound right?
09:05:50 <SyntaxNinja> yeah, that's what I think too.
09:06:01 <SyntaxNinja> I'm wondering if there's a need for --package-conf=, because i want to avoid that if I can.
09:06:35 <dcoutts> I think you can avoid it, --user / --global / --in-place just about covers it I think
09:06:59 <dcoutts> what's the use case for --package-conf= that's not covered by those three?
09:07:02 <Igloo> What command is --in-place an argument for?
09:07:22 <dcoutts> ./setup register --in-place
09:08:11 <SyntaxNinja> dcoutts: I can't think of any offhand.
09:08:13 <Igloo> So it just fails if the package needs to know where its files will be at compile-time?
09:08:32 <Igloo> (it sounds great to me, as it means running testsuites is much simpler)
09:08:46 <SyntaxNinja> where the files will be at compile time?
09:09:21 <dcoutts> Igloo means progs that compile their install location into themselves
09:09:30 <Igloo> If the compilation includes echo 'my_files = "'$prefix'"' > config.hs
09:10:51 <dcoutts> which is not a good idea, but anyway...
09:11:27 <Igloo> Well, you need to do it for the default global config file don't you?
09:11:45 <dcoutts> Igloo, huh?
09:12:19 <Igloo> How would you avoid having the location of /etc/vim/vimrc in the vim executable?
09:12:25 <SyntaxNinja> if a package requires that it lives in its final installation location in order to work, it'll definitely break :)
09:12:37 <dcoutts> Igloo, ghc uses wraper scripts
09:13:13 <dcoutts> it's true that cabal doesn't help much in this area currently, that is programs finding out at runtime where they've been installed
09:13:22 <Igloo> Yeah, I guess register could build the scripts itself
09:13:50 <dcoutts> c2hs uses a hack (which doesn't work correctly) to make a wrapper script
09:14:08 <dcoutts> hack/hook (depending on your opinion :-) )
09:14:18 <SyntaxNinja> heh
09:14:45 <dcoutts> and it doesn't work correctly because people forget that there is a difference between the temporary install location and the final install location
09:15:23 <dcoutts> ie the c2hs hook tries to modify the live file system rather than just modifying the files in the install image
09:15:51 <dcoutts> and so it doesn't work when building in a sandbox
09:16:24 * SyntaxNinja shudders
09:16:32 <dcoutts> quite
09:16:36 <SyntaxNinja> why is building software so hard?
09:16:48 <kosmikus> SyntaxNinja: btw, about these -odir things I wrote mails about to glasgow-haskell-users; JaffaCake seems to claim it's not ghc's fault; is it a Cabal problem then, or am I doing something unreasonable?
09:16:55 <dmiles> anyone here write in subl?
09:17:07 <SyntaxNinja> kosmikus: don't know; I don't read that list; care to fill me in?
09:17:07 <Lemmih> subl?
09:17:15 <dcoutts> SyntaxNinja, I sympathise, I really do! :-)
09:17:19 <Igloo> The script idea doesn't work if you have a library that reads some data files, BTW
09:17:23 <SyntaxNinja> dmiles: someone probably does... #haskell knows all.
09:17:33 <dcoutts> Igloo, true
09:17:34 <dmiles> (its a application specific language but this is the room besides lisp that one who knows it might be found ;P
09:17:42 <kosmikus> SyntaxNinja: http://www.haskell.org//pipermail/glasgow-haskell-users/2005-August/008918.html has all info
09:18:00 <Igloo> Does gtk2hs do that? I think most haskell libraries that exist today won't
09:19:00 <dcoutts> Igloo, no we don't need to know our install dir, Gtk+ itself does, but that's another matter
09:19:02 * Igloo wonders if cabal should know about location-dependent Config.hs files and (optionally?) link everything both ways
09:19:04 <SyntaxNinja> dist/build/foo/foo-tmp/foo/foo/foo.o
09:19:08 <SyntaxNinja> sometimes things are just silly
09:20:05 <Igloo> I'd really like it to be easy to run testsuites while building
09:20:25 <SyntaxNinja> kosmikus: I'm sure its a one-line fix; can yo uforward me that email, so I can deal with it after work? (if someone hasn't fixed it by then)
09:20:37 <dcoutts> but doesn't this --in-place thing only apply to libs anyway?
09:20:49 <dcoutts> you only need ./setup register for libs
09:21:14 <SyntaxNinja> dcoutts: not really, because configure will also need to know whether it should look at the in-place package database.
09:21:27 <SyntaxNinja> for executables that build-depend on something registered in-place
09:21:45 <Igloo> It would be nice to be able to run program testsuites too. Maybe there should be an install --in-place too
09:22:04 <dcoutts> ok, so there is ./setup register --in-place and also ./setup configure --in-place ?
09:22:39 <dcoutts> but I thought that multi-package cabal thingies would do the inplace registering automatically so there'd be no need for ./setup configure --in-place
09:23:02 <SyntaxNinja> dcoutts: well, not sure if we need th flag or not, but we definitely need the behavior
09:23:05 <SyntaxNinja> Igloo: agreed.
09:23:10 <dcoutts> Igloo, why do testsuits need to be installed to run?
09:24:48 <Igloo> dcoutts: Because otherwise they might not work
09:25:28 <dcoutts> SyntaxNinja, so ./setup register --in-place would register in "package.conf" with the file locations pointing to the build dir, not the ultimate install dir so they can be used in place with ghc -package-conf package.conf
09:25:57 <dcoutts> Igloo, what might the install step be doing for the testsuite that is required and cannot be done in an earlier step?
09:27:04 <Igloo> dcoutts: Making the wrapper script that points to the build directory in the appropriate place
09:28:02 <dcoutts> SyntaxNinja, hmm this --in-place still doesn't quite fix what we want for our packaging needs which is to register it for use in the final installed location rather for use in the build tree
09:30:38 <TheHunter> jlouis, my flood protection bug turns out to be a bug in the linux kernel. It also explains some really weird things happening here lately like dns queries taking a long time or ssh connections dying after being idle for a long time (but not at once, a few commands are accepted before the connection dies).
09:31:18 <SyntaxNinja> dcoutts: not sure
09:31:36 <dcoutts> SyntaxNinja, not sure what I mean?
09:32:06 <TheHunter> jlouis, how to do flood protection is explained in an rfc, and i think the semaphore solution is really beautiful.
09:32:51 <SyntaxNinja> no, not sure what exactly to do about finding files in dist/build... I'll have to think more on this later, or you should send me an email w/ ideas. I'll be afk for a little bit.
09:33:34 <dcoutts> SyntaxNinja, ok I'll write something down
09:33:39 <SyntaxNinja> thanks :)
09:36:12 <SyntaxNinja> cabal has such great users :)
09:41:58 <Lemmih> SyntaxNinja: I've put cabalized versions of HSQL and haskelldb in my home dir on h.g.c
09:43:09 <Igloo> Lemmih: URL?
09:43:16 <Lemmih> URL?
09:43:47 <Igloo> To the HSQL cabal package. Or is it secret?  :-)
09:43:48 <Lemmih> I don't think they're accessible from the web.
09:43:54 <Igloo> Ah, OK
09:44:14 <Lemmih> It's HSQL version 1.4 since I haven't made 1.6 work with haskelldb.
09:46:25 <Lemmih> http://212.242.49.100/packages/hsql-1.4.tgz
09:48:09 <Igloo> Oh, 1.6 looks like it comes cabalised
09:50:28 <Lemmih> Yep.
09:56:20 <ehuber_> uh.. there is no != in haskell?
09:56:40 <autrijus> /=
09:56:40 <kosmikus> @type (/=)
09:56:44 <sorje> take /=
09:56:45 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:57:08 <ehuber_> o
09:57:47 <ehuber_> thanks (:
10:03:19 <Lemmih> @where haskell-src-exts
10:03:20 <lambdabot> I know nothing about haskell-src-exts.
10:06:03 <dcoutts> ehuber, let (!=) = (/=) in ...
10:09:13 <TheHunter> @google haskell-src-exts
10:09:16 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg16431.html
10:09:21 <TheHunter> @google haskell-src-exts darcs
10:09:23 <lambdabot> http://vegai.ravissant.net/darcs/arch/haskell-src-exts/
10:09:49 <TheHunter> @where+ http://www.cs.chalmers.se/~d00nibro/haskell-src-exts
10:09:50 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts ~>
10:10:09 <TheHunter> @where- http://www.cs.chalmers.se/~d00nibro/haskell-src-exts
10:10:10 <lambdabot> Maybe you meant: where where+
10:10:29 <TheHunter> @where hsx
10:10:30 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
10:10:34 <TheHunter> ah!
10:15:37 <goron> How can I convert some text to lowercase?
10:16:45 <Lemmih> @eval map toLower "Like THIS?"
10:16:47 <lambdabot> "like this?"
10:16:59 <goron> Oops wrong channel.
10:17:07 <goron> I was talking about emacs.
10:17:16 <Lemmih> Ah (:
10:26:14 <SyntaxNinja> goron: M-l
10:28:48 <goron> SyntaxNinja: M-l does something else. It's C-x C-l.
10:42:23 <Lemmih> nibro: ping.
10:54:12 <lispy> @eval fmap toLower "Like THIS"
10:54:14 <lambdabot> "like this"
10:54:48 <Lemmih> @eval liftM toLower "Like THIS"
10:54:49 <lambdabot> "like this"
10:59:48 <lispy> i hope in haskell2 that map is removed, fmap is renamed map and liftM is removed
10:59:59 <lispy> although, liftM is a better name for what liftM does
11:00:08 <lispy> so maybe it shuold still be there just equal to map
11:00:47 <lispy> this assumes that Functor becomes a constraint for Monad
11:01:36 <cyanite> Anyone know a haskell compiler that doesn't take 5 hours to compile.. .and that compiles under gcc 3.3? :p
11:02:16 <SyntaxNinja> nhc perhaps?
11:02:20 <cyanite> I tried ghc... accidently stopped it after 5 hours though, and I don't feel like repeating it.
11:02:22 <lispy> cyanite: hugs is probably a lot faster to compile than ghc, but I don't know if it meets the rest of your constraints :)  But I have to wonder...Do you really need to compile it yourself?
11:02:50 <cyanite> nhc... right I just heard it doesn't compile under gcc 3.3.5+
11:03:01 <lispy> cyanite: unless you did a make clean you might be able to resume it, nad it should only have another hour or two left if it ran 5 hours already
11:04:47 <cyanite> yeah.. well it's gentoo, so i interrupted it at a 'higher level' but I suppose I can try make and resume :p
11:04:47 <lispy> ah
11:04:47 <lispy> fwiw, i think ghc is worth the wait
11:04:47 <pejo> Doesn't even gentoo have binary packages nowdays?
11:04:50 <vegai> they've had them for quite a while, but does anyone use them?
11:05:11 <cyanite> pejo: for some stuff, but not for haskell I am sure.
11:05:26 <lispy> i've been meaning to try gentoo, but i have a feelng that ubuntu would be a better fit
11:05:42 <cyanite> lispy: well.. but ghc's supposed to be slow (when compiling haskell) no?  it's a 333mhz :p.   hmm... I'll try on my mac instead.  1ghz at least.
11:05:49 <cyanite> I love gentoo though.
11:06:07 <lispy> cyanite: oh dear, 333mhz could take much longer than 6 hours
11:06:18 <cyanite> lispy: yeah.... hehe... i feared ;)
11:06:22 <lispy> cyanite: i compiled it on my ibook (1.2Ghz) in 5-6 hours :)
11:06:29 <cyanite> ....
11:06:35 <cyanite> hehe
11:06:53 <cyanite> nhc... maybe I should try it ;).    but there is a gentoo bug filed.
11:07:16 <cyanite> like: # <kosmikus@gentoo.org> (19 Jan 2005)
11:07:16 <cyanite> # several compilation problems using current gcc's,
11:08:12 <cyanite> anyone tried it?  (nhc)
11:08:22 <lispy> i haven't
11:09:36 <lispy> i need to start using liftM* more often
11:09:57 <cyanite> I just kinda think that ghc's compile times are ... ridiculous :p
11:10:26 <lispy> well, ghc has a lot of libraries and extensions
11:10:43 <lispy> i think that adds significatly to the compile time, but it's just a hunch
11:10:48 <cyanite> yeah
11:10:57 <cyanite> actually I remember it spending at least an hour with OpenGL
11:11:00 <cyanite> which I don't need or want :p
11:11:11 * lispy nods
11:11:23 <Lemmih> Hurrah for USE flags then.
11:11:27 <lispy> not on a 333mhz machine which is probably used as a server
11:11:57 <boegel> @seen Itkovian
11:11:58 <lambdabot> I saw Itkovian leaving #haskell 1 hour and 31 minutes ago.
11:12:05 <boegel> damned, I needed him
11:12:06 <cyanite> lispy: correct. :)
11:12:13 <cyanite> Lemmih: doh yeah...
11:12:29 <cyanite> Lemmih: there aren't many but at least: -doc +opengl +tetex
11:12:41 <cyanite> I should prolly at least disable opengl then :p
11:13:18 <lispy> cyanite: i know you like gentoo, but i'll plug debian realy quick. in deb, the default installation of ghc didn't come with opengl
11:13:20 <cyanite> lispy: *nod*... well I do acknowledge that gentoo on a 333mhz isn't always the coolest ;)
11:13:58 <lispy> cyanite: yeah, and debian on a dual opteron would be silly.  Which is why i've been thinking about using gentoo (if i buy the dual system)
11:14:21 <lispy> it would be sad to run code optimized for the i386 on a dual x86-64 machine :)
11:14:33 <cyanite> lispy: yeah :).
11:14:37 <cyanite> definately.
11:15:39 <cyanite> sounds weird that nhc can't compile with modern gcc's... its last update is from earlier this year.  i'll try compile it manually I think.
11:17:23 <Lemmih> Are you sure you can't do with Hugs?
11:17:31 <cyanite> well...
11:17:37 <cyanite> for experiments, I can I am sure.
11:17:44 <cyanite> but in case I get to like it.. ;)
11:18:15 <cyanite> but yeah I guess i should start with it.
11:19:09 <lispy> i think, that a lot of the HOpenGL functions should provide *M versions, all dual to the already defined functions except fooM = liftM foo
11:19:26 <lispy> that would make it more pleasant to use
11:19:39 <lispy> i should be writing down these "possible improvements"
11:19:57 <cyanite> ...monads are evil.  had to reread pasages a few times, and i've even had a course in formal semantics where such things were briefly mentioned.   I wonder if I'm the only one who had trouble wrapping my mind around them :p.
11:20:28 <lispy> cyanite: no, they are a difficult concept to grok
11:20:40 <lispy> cyanite: this is a well known "bug" in the haskell community :)
11:20:51 <lispy> cyanite: have you read the available tutorials on them?
11:20:59 <lispy> @wiki MonadsAsContainers
11:21:01 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
11:21:13 <cyanite> yeah.....  we did languages in my semantics course, with state, side effect and exceptions.  we didn't do monads, but it was of course mentioned in connection to the obvious similarities in implementing these things, operationally.
11:21:15 <lispy> http://www.nomaware.com/monads/html/
11:21:34 <cyanite> I read this one which seemed ok: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
11:21:37 <lispy> those two sites help a lot
11:21:50 <cyanite> The one in 'gentle introduction to haskell' wasn't good.
11:21:53 <cyanite> at all.
11:22:05 * lispy nods
11:22:18 <cyanite> although the rest of the gentle introduction is ok I guess.
11:22:18 <lispy> so with monads you have to use them a lot as well as try to understand the theory
11:22:26 <cyanite> exactly....
11:22:32 <cyanite> so far it's been theory theory..
11:22:39 <cyanite> I haven't written a single haskell line ;)
11:22:41 <cyanite> so.. hehe.
11:22:48 <cyanite> takes getting used to, I am sure that will help a lot.
11:23:04 <lispy> yeah, i didn't really get them until i started doing some exercises
11:23:18 <cyanite> I've coded scheme and ml though, so im not completely lost as far as func. prog. goes.
11:23:20 <lispy> try to create a list implementation which stores the current length of the list
11:23:27 <lispy> make it an instance of monad
11:23:29 <cyanite> ah... *nod*.
11:23:39 <lispy> don't reuse the existing list implementation at all
11:23:47 <cyanite> yeah I can 'sorta' see that it can be done like that, without the details in my mind of course :)
11:24:17 <lispy> it's a good exercise.  I didnt' get the list monad at all until I did that exercise.
11:24:40 <cyanite> hm. there is a pre-compiled for darwin on the nhc98 site.
11:24:46 <cyanite> it's tempting :p
11:25:13 <cyanite> i'll try it.
11:26:36 <jlouis> TheHunter: the semaphore solution holds. I should just have read the semantics. It is really beautiful. I see it as pushing tokens between 2 buckets, trickling tokens to the sem2 bucket. It actually looks like a standard token bucket regulator used in many routers
11:27:09 <jlouis> And it shines compared to the old solution
11:27:15 <lispy> pardon the paste, but i think this code is really cool
11:27:24 <lispy> allCombinations :: (a -> a -> a) -> [[a]] -> [a]
11:27:25 <lispy> allCombinations fn []     = []
11:27:27 <lispy> allCombinations fn (l:ls) = foldl (liftM2 fn) l ls
11:28:17 <cyanite> liftM2 lifts a function of two arguments to lists?
11:28:19 <lispy> that will compute "a list containing the results of folding the binary operator through all combinations of the elements of the given lists"
11:28:25 <lispy> cyanite: yup
11:28:34 <cyanite> *nod*... yeah.
11:28:37 <dcoutts> cyanite, the ghc-bin on gentoo should work just fine
11:28:58 <dcoutts> you can use it instead of waiting for ghc from source
11:29:03 <cyanite> dcoutts: yeah I noticed it's a separate package.. kinda weird for gentoo. but maybe due to the 9999 hour compile time.
11:29:14 <dcoutts> it lacks docs and opengl but appart from that
11:29:17 <cyanite> dcoutts: *nod* thanks, will try :)
11:29:22 <cyanite> thank God.
11:29:30 <dcoutts> cyanite, it's due to the fact that ghc need ghc to compile from source
11:29:32 <cyanite> cause I don't need it.
11:29:35 <cyanite> well.. docs maybe.
11:29:36 <lispy> @eval let {ac fn [] = []; ac fn (l:ls) = foldl (Monad.liftM2 fn) l ls} in ac (*) [[0,1], [1,2], [3,5]]
11:29:38 <lambdabot> 60: Not in scope: `Monad.liftM2'
11:29:44 <cyanite> dcoutts: yeah I figured.. so it bootstraps.
11:29:47 <dcoutts> which is a tricky dependedcy for a source based distro
11:29:52 <lispy> @eval let {ac fn [] = []; ac fn (l:ls) = foldl (Control.Monad.liftM2 fn) l ls} in ac (*) [[0,1], [1,2], [3,5]]
11:29:54 <lambdabot> [0,0,0,0,3,5,6,10]
11:30:20 <cyanite> dcoutts: so eh.. doesn't it just bootstrap somehow, or does it actually ship the source package with a small binary??
11:30:41 <dcoutts> cyanite, yeah, originally we had ghc-bin there just for bootstrapping but now it's in a state where ghc-bin can be used for everything and there's no real need to build ghc yousefl if you don't want to
11:31:07 <cyanite> dcoutts: ah I see.   you're gentoo dev?
11:31:19 <dcoutts> ghc-bin is just an image of ghc that was built on a devs' machine
11:31:24 <cyanite> heh
11:31:32 <cyanite> yeah...
11:31:35 <lispy> @type ($)
11:31:37 <lambdabot> forall b a. (a -> b) -> a -> b
11:31:40 <dcoutts> cyanite, yes. Ask in #gentoo-haskell if you've got any Q's
11:31:51 <lispy> is ($) the same thing as return $ foo bar?
11:31:57 <cyanite> then again... the time it takes to build ghc with ghc might indicate how long it will take for ghc to compile... anything :p
11:32:01 <cyanite> dcoutts: k thanks.
11:32:21 <lispy> @eval ($) head [1,2,3,4]
11:32:23 <lambdabot> 1
11:32:25 <dcoutts> cyanite, actually most other things are not so slow (except perhaps wxhaskell & gtk2hs which are rather large)
11:32:39 <lispy> @eval head $ [1..4]
11:32:42 <lambdabot> 1
11:32:47 <dcoutts> it's the 3 stage bootstrap + libs that's really slow for ghc
11:32:53 <cyanite> dcoutts: ok.   the haskell site did mention it produced fast code, but was slow and resource hungry.
11:33:25 <dcoutts> especially when compiling with -O
11:33:29 <cyanite> dcoutts: even with a 'complete' binary, it's still 3-stage.. why?  an extra state to make sure or what?
11:34:00 <dcoutts> oh, I may be wrong, it's either 2-stage or 3-stage, can't remember really
11:34:14 <dcoutts> someone here would know if you're interested
11:34:23 <cyanite> yeah... I seem to remember gcc is 3-stage?  even though 2 would do.  not sure.
11:34:30 <cyanite> naa it's ok.   :).  all I know for sure is that it's slow.
11:34:52 <dcoutts> yeah :-)
11:35:16 <cyanite> but gcc compiled blazingly fast compared to ghc :p
11:35:25 <cyanite> even glibc does.
11:35:34 <cyanite> oh well.  binary it is.
11:35:40 <dcoutts> I really apreciate my amd64 when it comes to building ghc :-) [2 hours or so]
11:36:13 <cyanite> hehe
11:36:44 <cyanite> yeah.  well my 333mhz is pretty dated.  I mainly keep it since it's fast enough for the server stuff, and.. uses less power I guess.  :p
11:37:21 <Cale> @eval map (foldl1 (*)) (sequence [[0,1], [1,2], [3,5]])
11:37:23 <lambdabot> [0,0,0,0,3,5,6,10]
11:37:53 <dcoutts> cyanite, you're using ppc or x86?
11:38:12 <cyanite> 333mhz celeron A.
11:38:22 <cyanite> well.. that's a server mostly.  main machine is a mac.
11:38:26 <dcoutts> oh right
11:38:40 <dcoutts> but the mac doesn't run gentoo? :-)
11:38:48 <cyanite> ....
11:38:50 <cyanite> well...
11:38:53 <dcoutts> it's ok, we forgive you
11:38:55 <lispy> Cale: nice
11:38:56 <cyanite> it's.... ... not ready :p
11:39:04 <cyanite> dcoutts: has too few packages so far IMO.
11:39:12 <cyanite> dcoutts: compared to darwinports and others.
11:39:24 <dcoutts> it's got ghc :-)
11:39:27 <lispy> @pl \fn ls -> map (foldl1 fn) (sequence ls)
11:39:29 <lambdabot> (. sequence) . map . foldl1
11:39:34 <cyanite> dcoutts: hehe ok, i didn't check it for some time now :).
11:39:41 <dcoutts> the rest of it isn't my responsability :-)
11:39:46 <cyanite> dcoutts: maybe we should take our chat elsewhere...
11:40:09 <lispy> heh, could you imagine using (. sequence) . map . foldl1 in your code without an explanation of what the function is for? :)
11:40:59 <Cale> heh
11:41:14 <Cale> that feels fairly backwards :)
11:41:30 <Cale> the sequence is conceptually happening first
11:41:39 <lispy> yeah
11:45:16 <lispy> "A typical use of the Identity monad is to derive a monad from a monad transformer."
11:45:23 <lispy> so what is a monad transformer?
11:45:55 <Cale> A type constructor which turns one monad into another. I'll get a reference
11:46:03 <lispy> ah
11:46:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Trans.html has the class definitions
11:47:19 <Cale> lift :: Monad m => m a -> t m a
11:48:01 <Cale> We'd also want (t m) to be a monad for any monad m
11:48:59 <lispy> so does MonadTrans need functional dependencies?
11:49:34 <lispy> seems like a lot of things in haskell need functional dependencies to be declared in the general sense
11:49:56 <Cale> certain monad transformers end up needing them
11:50:44 <Cale> oh, I suppose in the case of StateT, it's not really StateT, but MonadState that needs the functional dependencies
11:50:59 <Cale> class Monad m => MonadState s m | m -> s where ...
11:51:00 <cyanite> mm... monad tranformer-transformers.     getting better.. ;)
11:51:17 <lispy> hmm...i'll come back to monad transformers when i have a better understanding of the monad library
11:51:46 <lispy> list, maybe and IO are the monads i understand best right now
11:51:47 <Cale> http://www.nomaware.com/monads/html/ explains about them in Part III
11:52:04 <lispy> Cale: yup, reading part III right now :)
11:52:10 <lispy> that's where I got my question from :)
11:52:48 <lispy> i should probably be doing other stuff....
11:52:52 <Cale> Here's a nice exercise for you. Turn the type "data Tree a = Branch (Tree a) (Tree a) | Leaf a" into a monad.
11:53:06 <Cale> (by writing an instance of Monad for it)
11:55:17 <lispy> i guess the first step is to make it an instance of Functor
11:55:32 <lispy> then use that to define (>>=)
11:55:36 <Cale> that would be a good start
11:57:02 <Cale> once you have (>>=), you're essentially done :) It's also good to remember that you can break (>>=) down into parts though
11:57:47 <vegai> are there many answers to that exercise?
11:57:54 <vegai> many correct answers, that is
11:58:04 <Cale> yeah, there are, but there's basically one thing to do which is "natural"
11:58:11 * vegai nods.
12:04:53 <SamB> @ghci "Hello"
12:04:54 <lambdabot>  Splices are not allowed in hs-boot files
12:07:58 <Cale> @eval "Hello"
12:08:00 <lambdabot> "Hello"
12:34:28 <vegai> hmh
12:34:47 <vegai> honestly, how many of you think that this is a good way to start a monad introduction: "A monad is a way to structure computations in terms of values and sequences of computations using those values."
12:35:25 <ibid> depends on the target audiencde :)
12:35:33 <dblhelix> shapr: ping?
12:35:39 <kosmikus> which introduction start like that?
12:35:48 <vegai> All About Monads
12:35:56 <vegai> nomadware's
12:36:07 <jlouis> Monads rock
12:36:10 <vegai> nomaware's, sorry: http://www.nomaware.com/monads/html/introduction.html
12:36:11 <Oejet> vegai: Me thinks it's bad.  It should go like this: Monads are little fluffy things, that are your friends.
12:36:22 <vegai> jlouis: yes! That's a much better first sentence :)
12:36:36 <ibid> monads are a way to make imperative programs functional, only it doesn't stop there
12:36:40 <ibid> :)
12:36:43 <vegai> yay. Why haven't you guys written one yet? =)
12:36:59 <kosmikus> reading the whole section, it doesn't seem so bad
12:37:04 <ibid> i did.  most of my students failed that part :)
12:37:10 <jlouis> Monads provide imperative operations to functional programs with _typed_ side effects
12:37:54 <vegai> well, that's really the IO Monad
12:38:21 <vegai> ...right?
12:39:06 <SamB> not necessarily
12:39:13 <ibid> no
12:39:24 <Heffalump> monads encapsulate side-effects and hide them from you in a type-safe way.
12:39:46 <vegai> anyway, the point is... it's not a good idea to start an introductory text with a heavy sentence
12:40:04 <ibid> IO monad provides imperative effects that affect the outside world.  other monads provide an imperative style whose side-effects are localized in some sense
12:40:30 <vegai> most of the target audience of "All About Monads" consists of people who know little about Monads, right?
12:40:58 <monochrom> They like analogies and physics.
12:43:51 <boegel> yo Itkovian
12:44:30 <monochrom> to answer vegai's earlier question, no, I don't like it.
12:45:16 * Itkovian waves
12:45:30 <vegai> reminds me of that ancient engineer joke
12:45:59 <monochrom> there are many ancient engineer jokes.  but I only know of the one about duct tapes.
12:49:27 <musasabi> Trying to explain monads as combining computations might make more sense for e.g. Maybe and List monads.
12:49:35 <vegai> A man was flying in a balloon, and he was lost. He saw a woman on the ground and asked her where he was. She replied: "You're in a balloon 10 meters off the planet Earth's surface (there's more here, but I don't remember)"
12:49:53 <vegai> And the man says: "You must be an engineer, since you gave perfectly correct answer that's completely useless"
12:49:53 <ibid> that's a mathematician's joke
12:50:22 <monochrom> mathematician, engineer, Microsoft tech support, ... have all been implicated for this.
12:50:35 <vegai> yeah..
12:50:49 * ibid knows many math jokes
12:50:51 <ibid> at least did
12:50:54 <vegai> I fear that Haskellers often do that
12:51:05 <vegai> at least from an outsider's viewpoint
12:51:16 * boegel points Itkovian to pm
12:51:21 <jlouis> zorns lemon!
12:51:55 <Itkovian> point taken
12:52:11 <ibid> one of my favourites has an engineer, a physicist and a mathematiciann attending a lecture about some new 12-dimension-based theory
12:52:32 <vegai> we need to assimilate the guy who wrote the Poignant Guide to Ruby
12:52:36 <ibid> (hm, actually, it's better if the physicist is the presenter, but i digress)
12:52:41 <vegai> that should fix all our documentation problems
12:52:49 <monochrom> My gripe with the quoted summary of monads:  There are abstract descriptions, and then there are descriptions pretending to be concrete but actually abstract (what is a computation?)
12:52:53 <vegai> or clone him
12:53:04 <jlouis> vegai: guy-writing-poignant-guide-to-ruby >>= document-haskell
12:53:21 <vegai> satori?
12:53:24 <jlouis> now he is caught inside the HaskellRUs monad
12:53:39 <ibid> the engineer complained to the mathematician how hard it was to imagine something like that
12:53:54 <ibid> not at all, the mathematician said. i think it was easy
12:54:00 <ibid> how do you do it?
12:54:24 <ibid> well, i just generalize it to n-dimensional space, imagine it there and take the 13-dimension special case
12:54:33 <ibid> 12
12:54:43 <monochrom> heh
12:55:11 <jlouis> not far from the truth
12:55:17 <monochrom> I appreciated Stokes theorem that way.  (Didn't want to be limited to 3d.)
12:56:56 <ibid> i suppose you all know the riddle where one proves by induction that all women are blond (or brunette, whatever strikes your fancy;)
12:57:21 <monochrom> "A monad is a way to structure computations in terms of values and sequences of computations using those values."  This is no more concrete than just giving the monad axioms outright.
12:57:42 <Philippa> well, it helps if you're not used to reading off axioms
12:57:45 <ibid> i find it useful to call them "programs"
12:57:48 <monochrom> It *pretends* to be more concrete by using English, a more vague language.
12:57:57 <Philippa> but really, how can you get more concrete in practice?
12:58:03 <SyntaxNinja> hi Philippa
12:58:12 <Philippa> 'lo
12:58:15 <ibid> and then talk about how monadic programming is about combining programs to form larger programs
12:58:36 <Philippa> yeah. It's easier to understand "program" than to spend ages realising "computation" is near-synonymous with it
12:58:47 <ibid> so IO a is the type of programs whose "exit value" is of type a
12:58:58 <monochrom> Wadler's Marktoberdorf notes is concrete.
12:59:50 <ibid> it's even rather easy to explain the difference between a program and an execution of a program
12:59:56 <jlouis> hmmm, guys, which Haskell extension is this: type ModuleT s m a = (?ref :: MVar s, ?name :: String) => m a ?
13:00:00 <jlouis> ?ref?
13:00:04 <ibid> as opposed to a computation and the execution of a computation
13:00:12 <ibid> jlouis: looks like implicit parameters
13:00:16 <jlouis> (and gals, sorry Philippa and others)
13:00:36 <jlouis> ibid: ok. I'll look it up
13:00:37 <ibid> guys is nearly gender-neutral nowadays :)
13:01:23 <monochrom> Wadler's Marktoberdorf notes = "Monads for functional programming"
13:01:39 <Philippa> monochrom: the only thing I see more concrete about those notes is them diving into examples before extracting a type class from them
13:02:20 <monochrom> That is good presentation.
13:04:31 <monochrom> For mathematicians, you need only state the axioms, possibly followed by examples.
13:05:13 <musasabi> Not mentioning the axioms (or mentioning them in a too hard way) is frustrating.
13:05:17 <monochrom> For programmers who demand motivation, you need only give examples, then point out the pattern.  This is what "monads for functional programming" does.
13:05:28 <ibid> even for mathematicians, that's an inefficient way to introduce stuff
13:05:33 <TheHunter> anybody ever set up an irc server?
13:05:37 <ibid> it is sometimes necessary, but ...
13:05:47 <jlouis> TheHunter: a long time ago
13:05:54 <jlouis> the conf files are quite odd and dated
13:05:58 <Philippa> monochrom: that's not sufficient IMO
13:06:09 <jlouis> ibid: ah, implicit parameters it was. Nice concept
13:06:20 <ibid> jlouis: ym horrible hth hand :)
13:06:25 <TheHunter> this fucking ircd-ircu thing doesn't understand that i wanna allow multiple connections from the same host.
13:06:31 <musasabi> monochrom: if one only sees examples one starts to think about what-ifs and what things are possible.
13:06:37 <monochrom> For postmodernists, you need only define an abstract word by a string of no less abstract word.  This is what "a monad is ... computation ... sequence ... value..." is about.
13:06:53 <musasabi> Having a definition to go with can help thinking about those.
13:07:00 <Philippa> sequence and value should be reasonably well-defined
13:07:14 <Philippa> "computation" is often badly defined, sure
13:09:20 <ehuber_> bonk
13:10:04 <Philippa> 'lo alistairbayley
13:14:12 <jlouis> TheHunter: I am dissecting Lambdabot.hs code right now. It goes quite well, apart from lbIO:
13:14:16 <jlouis> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
13:14:18 <jlouis> lbIO k = LB $ ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
13:14:26 <jlouis> k is a continuation, sure
13:14:40 <alistairbayley> phillipa: evening. First time using IRC... will take some getting used to, methinks.
13:14:55 <jlouis> r is the environment for the ReaderT and m is the monad we play on?
13:14:59 <cjb> Hey, this might be a good place to ask.  What's the word for a matrix where you're pitting the row headers against each other, and have them repeated down the rows and columns, with an empty block along the diagonal where each row/column would meet each other?  Like what you get in sports tournaments.
13:15:35 <TheHunter> jlouis, actually, it should have been lbIO :: LB (forall a. LB a -> IO a), but haskell doesn't allow that, that's why I used cps.
13:16:22 <TheHunter> without lbIO, we couldn't forkIO a LB computation, for example.
13:16:42 <Philippa> alistairbayley: IRC itself's OK. Getting used to having piles of text going by you at all times might be another matter
13:17:42 <TheHunter> jlouis, the idea being that LB is a reader monad, but it the environment should never change.
13:19:35 <jlouis> TheHunter: begins to make sense but certainly wraps my head a bit
13:20:30 <jlouis> More reading of the source will probably help ;)
13:20:33 <jlouis> I'll dig further
13:21:37 <monochrom> When I talked of programmers and "point out the pattern", it included stating the axioms, don't worry.
13:22:14 <TheHunter> reading lambdabot source is certainly more fun than trying to get an irc server running to track down some weird bug involving wrong tcp checksums...
13:22:45 * TheHunter has the strong urge to kill whoever is resposible for that identd crap.
13:23:02 <Heffalump> identd crap?
13:23:23 <monochrom> I'm sure he's older than you and he will die earlier than you.  Just hang on!
13:23:42 <Philippa> monochrom: for programmers you need to explain the actual consequences of the axioms too
13:23:49 <monochrom> Right.
13:24:05 <TheHunter> when lambdabot tries to connect to my local irc server, the server keeps sending "Looking up your hostname; Found your hostname, cached; Checking Ident"
13:24:20 <TheHunter> and then disconnects.
13:24:23 <Philippa> eg monads always support 'higher-order computations' (whereas arrows don't), the potential for sequencing without strictly speaking requiring it...
13:24:28 <Heffalump> cos you're not running identd?
13:24:52 <TheHunter> i have no idea, xchat doesn't need to seem identd to connect.
13:25:11 <Heffalump> might be that lambdabot isn't sending an ident it can use.
13:25:14 <monochrom> xchat on windows includes identd
13:25:19 <Heffalump> ahh.
13:25:30 <Heffalump> but it can't on Linux, 113 is a privileged port.
13:25:32 <TheHunter> monochrom, what?
13:25:59 <TheHunter> windows doesn't restrict ports below 1024?
13:26:13 <monochrom> Naw
13:26:35 <int80_h> I love haskell :)
13:26:51 <TheHunter> ah, connection through xchat actually gives the error "Please use a nearer server.".
13:26:52 <SyntaxNinja> me too
13:27:42 <TheHunter> ok, config file contained K:*.edu:"Please use a nearer server":*
13:28:07 <monochrom> http://www.xchat.org/faq/#q21
13:28:18 <monochrom> (about identd and xchat)
13:29:02 <TheHunter> ah, i see. Identd still is a stupid thing.
13:29:35 <jlouis> TheHunter: same problem with lambdabot here. I think the bug is somewhere odd
13:29:42 <monochrom> It used to make sense when only honest and competent organizations were allowed on the internet. :)
13:29:43 <Heffalump> it was a useful mechanism for tying abuse to accounts on machines in the days where most machines were multi-user.
13:29:47 <Heffalump> It's less valuable now.
13:29:55 <TheHunter> jlouis, what same problem?
13:29:56 <Heffalump> but even so, for some machines, it's useful.
13:30:06 <Heffalump> e.g. the colo machine I IRC from.
13:30:15 <jlouis> TheHunter: when I try to connect lambdabot to irc.freenode.org from here it fails at the checking-ident spot
13:30:31 <TheHunter> jlouis, did you change the username in Config.hs?
13:30:36 <jlouis> yup
13:30:39 <Heffalump> there's no reason not to run an identd, you can always make it send random cookies
13:30:43 <jlouis> and the channel
13:30:47 <jlouis> I'll check again
13:31:08 <TheHunter> getting "runIRC: caught exception: connect: does not exist (Connection refused)" now...
13:31:13 <TheHunter> endless fun.
13:31:28 <jlouis> TheHunter: hah! bingo. Changed the channel, but not the name of lambdabot
13:33:08 <boegel> hey everyone
13:33:18 <bourbaki> hey boegel
13:33:25 <TheHunter> hey bourbaki
13:33:28 <TheHunter> hey boegel
13:33:30 <Heffalump> the IRC connection code really needs some work.
13:33:34 <bourbaki> boegel have you seen my demo ?
13:33:34 <boegel> any of you people have animation movie toys lying around you want to get rid off ? :D
13:33:39 <bourbaki> hey TheHunter :)
13:33:42 <boegel> bourbaki, I don't think so
13:33:58 <bourbaki> http://codemages.sf.net/Landscape.rar
13:34:30 <TheHunter> Heffalump, yes, i'm suspecting a race condition here.
13:34:35 <boegel> bourbaki, hmm, what is it ? :)
13:34:52 <boegel> 'cause I don't have GHC and such yet on this machine, I'll have to look into it
13:36:19 <Heffalump> I think it also doesn't cope with the nickname not being available.
13:36:47 <jlouis> ah, race condition between the threads involved?
13:36:48 <TheHunter> but i never dared to touch the irc connection code because it is very fragile.
13:37:05 <bourbaki> boegel thats windows bin
13:37:42 <Heffalump> I just kind of kept it working when I redid that bit of the bot
13:39:33 <boegel> bourbaki, oh, I'd have to reboot then :)
13:39:54 <boegel> I'll boot my other machine in a quickie
13:41:56 <TheHunter> yay! printf-style debugging.
13:42:37 <bourbaki> cool
13:53:26 <jlouis> @index throwDyn
13:53:28 <lambdabot> Control.Exception
13:53:45 <jlouis> no wonder I can't find it when looking in Control.Monad.Error
14:22:25 <ehuber_> i have a little question
14:22:48 <ehuber_> why is it that if i use an if statement, i can only use it for one parameter to a function ?
14:23:06 <ehuber_> because   blaFxn (if a then "bork" else "bla)  works
14:23:24 <ehuber_> but not  blaFxn2 (if a then ("bla" 3) else ("bonk" 5))
14:24:05 <vegai> that'd be kinda fun to have
14:24:27 <vegai> but if just returns one value
14:24:44 <vegai> could you define blaFxn2 to take a tuple as its argument?
14:25:08 <ehuber_> i suppose, its unnecessary though
14:25:12 <ehuber_> i just used guards instead
14:25:54 <ehuber_> if if could return two values it would just be easier
14:26:07 <ehuber_> maybe if parameters could be like lists, so if would just return a list
14:26:12 <ehuber_> i dont know.
14:26:14 <jlouis> @type uncurry
14:26:16 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
14:26:20 <jlouis> ;)
14:26:32 <vegai> oh, right. That's it. I was almost sure there was something that does it
14:26:38 <jlouis> uncurry blaFxn (if a then ("bla", 3) else ("bonk", 5))
14:26:49 <jlouis> Boom!
14:27:13 <monochrom> What is blaFxn2 ?
14:27:59 <ehuber_> just a function that takes a string and an integer
14:28:22 <ehuber_> too late for uncurry now (: but ill remember it
14:28:33 <monochrom> Now I see the problem.
14:29:37 <TheHunter> jlouis, damn, the problem has gone away after a restart. I never would have imagined that unloading and reloading a module wasn't enough to make it use the new code.
14:31:49 <jlouis> TheHunter: heh. Odd. I like most of Lambdabot.hs but it could do with a restructuring
14:31:58 <jlouis> writerLoop is nice
14:34:49 <TheHunter> there's a lot of IRC stuff in there that should be moved out. Unfortunately, the IRC and Lambdabot stuff is very tightly coupled.
14:36:34 <lispy> lisp has a really nice irc lib called cl-irc
14:36:45 <lispy> maybe that would worth modeling in haskell
14:37:03 <lispy> it's event based, and when you want control over an irc event you register a handler
14:37:26 <lispy> and the default handlers are enough to get you connected and keep you alive
14:38:00 <jlouis> We have a tad different abstraction
14:38:19 <lispy> continuation based?
14:39:44 <jlouis> its a callback scheme for events basicly, only the abstraction level is a bit different
14:39:52 <TheHunter> as far as the irc lib is concerned, we don't have any abstraction.
14:40:12 <jlouis> but as TheHunter says...
14:40:22 <TheHunter> we just happily mix irc with plugin-related code.
14:40:33 <musasabi> A good abstracted irc-library with multiple server support could be nice.
14:40:50 <jlouis> it would be fun to pull out irc code from plugins
14:41:13 <lispy> yeah, and i think having a seperate irc lib would be healthy for haskell
14:41:20 <lispy> (the haskell community that is)
14:41:30 <lispy> i don't know of any outside the code in lambdabot
14:41:58 <musasabi> lispy: I have some code that parses irc in 7 lines of parsec.
14:42:06 <lispy> musasabi: nice
14:42:39 <lispy> i've considered porting on of my irc bots from lisp to haskell, but i don't want to write an irc lib or figure out lambdabot's code
14:43:04 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/example/hirc_fltk.hs
14:43:21 <lispy> my first priority with that project is to twease out the megahal algorithms from it's current C based implemenation
14:51:42 <jlouis> nope
14:51:51 <jlouis> hmmm, forget that
15:39:52 <lispy> hehe, this is from the nomaware.com monad guide, "Abuse of the Continuation monad can produce code that is impossible to understand and maintain."
15:40:43 <Cale> yeah, I remember seeing that
16:06:28 <lispy> okay, using liftM* and possibly monad transformers i should be able to greatly enhance the code I converted from opengl
16:07:44 <lispy> i had code like do { p1 <- {- IO computation -}; p2 <- {- IO computation -}; ...; vertex (Vertex3 p1 p2 p3)}
16:08:22 <lispy> i could change that to liftM3 vertex (vertex3 <iocomp> <iocomp> <iocomp>)
16:08:43 <lispy> so actually the monad transform is probably not needed
16:09:04 <lispy> @type Control.Monad.liftM3
16:09:05 <lambdabot> forall r (m :: * -> *) a3 a2 a1.
16:09:05 <lambdabot> (Monad m) =>
16:09:05 <lambdabot> (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:09:21 <lispy> although, now liftM3 will return IO (IO ())
16:09:32 <lispy> but that's not a problem is it?
16:15:05 <TheHunter> that is a problem.
16:15:26 <TheHunter> you might wanna put a join in front of it.
16:15:41 <TheHunter> @type \f x y z -> join $ liftM3 f x y z
16:15:42 <lispy> @index join
16:15:43 <lambdabot> bzzt
16:15:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
16:15:43 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
16:15:43 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
16:15:53 <TheHunter> @type \f x y z -> Control.Monad.join $ Control.Monad.liftM3 f x y z
16:15:55 <lambdabot> forall a (m :: * -> *) a1 a2 a3.
16:15:55 <lambdabot> (Monad m) =>
16:15:55 <lambdabot> (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
16:15:57 <lispy> @type Control.Monad.join
16:15:59 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:16:03 <lispy> ah
16:16:33 <TheHunter> hmm, what does @pl do?
16:16:42 <TheHunter> @pl join $ liftM2 f x y
16:16:44 <lambdabot> join (liftM2 f x y)
16:16:50 <TheHunter> @pl \y -> join $ liftM2 f x y
16:16:51 <lambdabot> join . liftM2 f x
16:16:55 <TheHunter> @pl \x y -> join $ liftM2 f x y
16:16:56 <lambdabot> (join .) . liftM2 f
16:17:05 <lispy> @pl \x y -> Control.Monad.join $ Control.Monad.liftM2 f x y
16:17:07 <lambdabot> ((Control . Monad . (Control . Monad =<<)) .) . liftM2 f
16:17:12 <lispy> ah
16:17:16 <lispy> that's wrong :)
16:17:43 <lispy> i wonder if a monad transformer would be more appropriate
16:20:23 <lispy> @type Control.Monad.ap
16:20:24 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m
16:20:24 <lambdabot> b
16:22:05 <lispy> with joinLiftM and joinLiftM2 I'd have most of my cases handled
16:22:33 <TheHunter> joinLiftM ???
16:22:46 <lispy> joinLiftM = join . liftM
16:22:54 <TheHunter> @pl join . liftM
16:22:56 <lambdabot> join . fmap
16:22:59 <lispy> heh
16:23:05 <lispy> or fmap if you prfer
16:23:13 <TheHunter> @type Control.Monad.join . Control.Monad.liftM
16:23:16 <lambdabot> bzzt
16:23:24 <lispy> oh m...
16:23:43 <TheHunter> @pl \f x -> join $ liftM f x
16:23:44 <lambdabot> (=<<)
16:24:07 <lispy> hmm...
16:24:45 <lispy> @index vertex
16:24:46 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec, Graphics.Rendering.OpenGL.
16:24:46 <lambdabot> GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
16:25:12 <lispy> @type (=<<) Graphics.Rendering.OpenGL.GL.VertexSpec.vertex
16:25:13 <lambdabot> forall a.
16:25:13 <lambdabot> (Graphics.Rendering.OpenGL.GL.VertexSpec.Vertex a) =>
16:25:13 <lambdabot> IO a -> IO ()
16:25:56 <lispy> is the solution to my problem really that simple?
16:25:59 <lispy> that would be nice
16:26:21 <lispy> @pl \f x y z -> join $ liftM3 f x y z
16:26:23 <lambdabot> (((join .) .) .) . liftM3
16:26:46 <TheHunter> lispy, i might quote you the next time someone claims that defining bind in terms of join and liftM/fmap is counterintuitive.
16:27:18 <lispy> heh
16:28:08 <lispy> i wish it generalized
16:29:02 <lispy> @pl \f x y z w -> join $ liftM3 f x y z w
16:29:04 <lambdabot> ((((join .) .) .) .) . liftM3
16:29:30 <lispy> so it sort of generalizes
16:29:36 <TheHunter> @pl join $ return f `ap` x `ap` y
16:29:37 <lambdabot> join (liftM2 f x y)
16:31:18 <TheHunter> joinLiftM2 etc. make some sense, because they generalize application of multi-argument functions.
16:31:28 <lispy> @type let join m = {do m' <- m; return m'} in join
16:31:29 <lambdabot> bzzt
16:31:40 <lispy> yeah
16:31:53 <lispy> how is join defined?
16:32:01 <TheHunter> @pl (=<<) id
16:32:02 <lambdabot> join
16:32:45 <lispy> @type let join m = {do m' <- m; m'} in join
16:32:47 <lambdabot> bzzt
16:32:50 <TheHunter> well, join x            =  x >>= id
16:33:03 <lispy> okay, so my definition must be close right?
16:33:10 <TheHunter> @type let join m = do m' <- m; m in join
16:33:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
16:33:17 <TheHunter> @type let join m = do m' <- m; m' in join
16:33:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
16:33:31 <lispy> so it was just my syntax that was off the second time
16:33:49 <lispy> oh
16:33:53 <TheHunter> if you wanna you braces, it must be lilke this
16:33:57 <lispy> @type let join m = do { m' <- m; m'} in join
16:33:59 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
16:34:01 <TheHunter> right.
16:34:12 <lispy> i know better, but i typod :)
16:34:36 <TheHunter> using braces around do makes no sence, imo.
16:34:49 <TheHunter> *inside
16:35:28 <lispy> i've had times when i couldn't get layout to do what i wanted
16:35:46 <lispy> that's when i use braces.  Or when i'm talking to lambdabot since it's usually the easiest way for me to get it all on one line
16:36:17 <TheHunter> for one-liners, braces are only necessary when using let inside a do.
16:36:18 <Cale> I find that if I'm combining do blocks with infix operators, braces can make things nicer.
16:37:05 <TheHunter> well, even with infix operators, the layout rule is usually fine.
16:37:11 <Cale> yeah
16:38:51 <TheHunter> and seeing code where lines start with ;'s makes me wanna cry.
16:39:02 <TheHunter> *starting
16:39:18 <TheHunter> *start
16:39:18 <lispy> oh i remember how the code i'm dealing with works now.  So I have vertex which takes something with type Vertex3 a, and I have IO GLfloat that I want to use to construct a Vertex3
16:39:52 <lispy> so I would do |liftM3 Vertex3 x y z|
16:40:05 <lispy> that would give me IO (Vertex3 GLfloat)
16:40:18 <lispy> then I need to give that to vertex
16:40:26 <dons> moin
16:40:31 <TheHunter> moin
16:40:52 <lispy> vertex =<< liftM3 Vertex3 x y z  should do it right?
16:40:55 <lispy> moin
16:41:08 <TheHunter> @type Graphics.Rendering.OpenGL.GL.VertexSpec.vertex
16:41:10 <lambdabot> forall a.
16:41:10 <lambdabot> (Graphics.Rendering.OpenGL.GL.VertexSpec.Vertex a) =>
16:41:10 <lambdabot> a -> IO ()
16:41:34 <TheHunter> yes, that looks good.
16:41:54 <lispy> i wish vertex had a different type
16:42:35 <lispy> maybe vertex3 :: (GLType a) => a -> a -> a -> IO ()
16:42:53 <lispy> then have GLType include floats and whatever else can be used as vertices
16:43:18 <lispy> or Num a
16:43:59 <lispy> i find it weird that normal takes a Normal3, vertex takes a Vertex3, color takes a Color3, and translate takes a Vector3
16:44:36 * TheHunter doesn't know OpenGL, and therefore can't comment on that.
16:44:57 <lispy> i think it's so that things like color can take either Color3 or Color4 depending
16:45:12 <lispy> but it seems like color3 and color4 would have been easier to deal with
16:46:03 <lispy> the way it is now i have a lot of code that looks like |color (Color4 0 1 0 (1::GLfloat))|
16:46:36 <dons> why to use h4sh -- no seg faults:
16:46:38 <dons> repeat A | take -n 100000 | concat | cycle | take -n 11 | /usr/bin/sort -n > /dev/null
16:46:39 <lispy> i wish the system had enough type info about color to infer that I was usnig floats, and I wish i didn't need to give the constructor
16:46:45 <dons> zsh: segmentation fault (core dumped)  /usr/bin/sort -n > /dev/null
16:47:13 <lispy> dons: nice
16:47:27 <lispy> dons: is this the sort of thing you'll be sending in a bug report to the zsh devs?
16:47:38 <SyntaxNinja> dons: h4sh is a shell?
16:47:50 <dons> hehe. once you've got repat and cycle you can do lots of nasty things easily ;)
16:48:24 <dons> SyntaxNinja: no. it is a suite of small programs generated from the corresponding List functions
16:49:00 <dons> h4sh takes the function, and its type, and generates a program that handles stdin and command line args
16:49:08 <lispy> dons: oh, i see, that's quite a bit of output...hehe
16:49:19 <SyntaxNinja> dons: coo
16:50:41 <lispy> dons: i still haven't checked it out, so in h4sh you'd have defined say, ("head", "[a] -> a") and it does the rest?
16:50:48 <dons> luckily, the shell lets us do function composition, and sort-of partial application. Think 'id' versus 'id f' in a pipe.
16:50:59 <dons> lispy, yep.
16:51:19 <lispy> dons: that must be some cool code
16:51:20 <Igloo> dons: When you've written some zsh trickery to notice you have 2 h4sh's in a pipeline and dynamically create the appropriate single program, then I'll be impressed  :-)
16:51:36 <lispy> heh
16:51:41 <dons> Igloo, heh!
16:51:50 <Igloo> Unfortunately I imagine you'd need to actually call ghc rather than just do dynamic stuff in order to get most of the optimisation that would mean it was worth doing
16:52:19 <dons> well, all the higher order functions already call ghc (System.Eval) and it isn't terribly noticeable.
16:52:41 <Igloo> I mean things like deforestation
16:53:43 <dons> right. I was imagining a shell that turned f | g | h into f . g . h and ran eval on it
16:53:45 <lispy> @pl \x -> points !! x
16:53:46 <lambdabot> (points !!)
16:53:54 <lispy> silly me
16:54:23 <dons> h . g. f
16:54:35 <cyanite> Can't I get an interpreter eval-loop ish environment in hugs?   like.. so i can write f x = ...   without it giving an error.
16:54:56 <lispy> cyanite: let f x = ...
16:55:03 <Igloo> Ah, I see. I was thinking loading the modules and splicing them together, but that would work
16:55:19 <cyanite> lispy: myeah ok... no way to like.. make it act like my input is a file?
16:55:30 <Igloo> ghci does that, to an extent
16:56:02 <lispy> cyanite: not really that i know of, but in ghc :r is reload, and that's pretty quick to type
16:56:11 <lispy> let f x = x
16:56:14 <lispy> f 1
16:56:17 <lispy> that should work in hugs
16:56:21 <cyanite> lispy: k.
16:56:42 <lispy> or let {f [] = []; f (x:xs) = f xs}
16:56:45 <cyanite> m.
16:56:49 <lispy> if you need mulitple lines
16:57:25 <lispy> so is ghc smart enough to turn that function i just gave into f = []
16:57:31 <lispy> er f x = []
16:59:23 <Igloo> Your first let won't work in hugs, only ghci
16:59:47 <Igloo> And your two f's aren't equivalent when the input is an infinite list, so I'd hope GHC won't transform one into the other
16:59:56 <lispy> ah, so i'm giving out bad advice :)  I don't have hugs installed to test on...
17:00:02 <cyanite> :p.  well.
17:00:09 <cyanite> thanks though :)
17:00:13 <lispy> Igloo: ah, good point
17:01:20 <lispy> @type let f (x:xs) = f xs in f
17:01:22 <lambdabot> forall a t. [a] -> t
17:01:30 <lispy> @type let f (x:xs) = f xs in f [1..]
17:01:32 <lambdabot> forall t. t
17:01:33 <cyanite> ee.... don't write [1..] in hugs ;)
17:01:42 <lispy> heh
17:01:59 <lispy> cyanite: everyone has to try it at least once :)
17:02:15 <cyanite> yeah... i guess it's similar to print 'name' goto 10 ;)
17:02:19 <Igloo> cyanite: You've made your computer diverge. You'll have to throw it away and buy a new one.
17:02:27 <cyanite> yeah :'(
17:02:30 <dons> Igloo's right.
17:03:01 <lispy> wouldn'th that suck, disposable processors
17:03:15 <dons> we'd all require laziness
17:03:29 <lispy> i'm plenty lazy thank you very much ;)
17:05:06 <cyanite> let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ] in fib  is even more fun.
17:08:54 <Cale> fib@(_:tfib) = 1 : 1 : zipWith (+) fib tfib
17:09:10 <cyanite> myeah but that was further down the turotial ;)
17:09:30 <cyanite> plus it looks more...  less... intuitive :p
17:09:49 <Cale> hehe
17:09:51 <Cale> yeah
17:10:47 <Cale> It relies on pattern bindings being lazy.
17:10:52 <cyanite> might be more effective.  but that would be bad, since I need to press ctrl-c here! ;)
17:11:01 <cyanite> yeah.... that seems to ring a bell.
17:11:20 <Cale> cyanite: in ghci, you can use, e.g. "let f x = x + 1"
17:11:24 <cyanite> zipWith is a prelude thing?
17:11:27 <Cale> to define new things
17:11:31 <cyanite> ah ok cool.
17:11:32 <Cale> yeah zipWith is in the prelude
17:11:36 <cyanite> k.
17:11:56 <cyanite> defined in haskell like 'I did' ?
17:12:04 <cyanite> more or less.
17:12:10 <Cale> zipWith f (x:xs) (y:ys) = (f x y) : zipWith f xs ys
17:12:27 <cyanite> myeah ok.   right of course.
17:12:38 <cyanite> I was more thinking, if one wanted to define it in terms of zip.
17:13:39 <lispy> @type zip
17:13:41 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
17:13:57 <cyanite> ....
17:14:00 <lispy> i'd say zip is defined in terms of zipWith
17:14:07 <cyanite> and what's forall? :p
17:14:08 <lispy> zip = zipWith (,)
17:14:33 <lispy> cyanite: fix an a and b, without any restrictions on what they can be
17:14:45 <lispy> then apply them in the type signature
17:14:51 <cyanite> hm
17:14:52 <lispy> so you might have a = Int
17:14:53 <TheHunter> @pl zipWith (,)
17:14:54 <lambdabot> zip
17:14:55 <lispy> b = Char
17:15:16 <lispy> then it would be zip :: [Int] -> [Char] -> [(Int, Char)]
17:15:21 <cyanite> yes yes but...
17:15:26 <cyanite> ah... right doh
17:15:41 <cyanite> I'm just used to _implicit_ universal quantification.
17:15:46 <Igloo> In Haskell98 the type would be written just [a] -> [b] -> [(a, b)]
17:15:49 <cyanite> so the 'forall' keyword puzzled me.
17:16:05 <dons> anyone have an opinion of what zip should do as a shell command? should it behave like paste, or should it generate: show . zip output?
17:16:22 <Igloo> like paste?
17:16:24 <lispy> paste?
17:16:29 <cyanite> ..?
17:16:35 <dons> man 1 paste
17:17:08 <cyanite> hm.. never used that one :p
17:17:38 <lispy> hmm..
17:17:41 <dons> it merges two files with a ' ' delimiter. i.e. [a] -> [a] -> [(a,a)] basically
17:17:47 <cyanite> yeah
17:18:00 <lispy> dons: that seems reasonable
17:18:13 <lispy> more reasonable than tuples of lines :)
17:18:24 <cyanite> yeah
17:18:26 <dons> *however* whitespace is a stupid delim. so having Showable output would let us use other more structured haskell functions later. unzip .read
17:18:43 <lispy> well, what does map use as delimiter?
17:18:51 <Igloo> Ideally it would take two pipelines as inputs, of course
17:18:52 <dons> you could: zip f g | fold ... | unzip
17:18:53 <lispy> i think map and zip should use the same delimiter
17:18:55 <cyanite> I didn't quite get that Showable Readable stuff... I guess I 'll have to trial and error a bit.
17:19:04 <Igloo> Hmm, or can you do that with <( ... ) in zsh?
17:19:07 <cyanite> I mean.. 'when I read the tutorial'
17:19:08 <dons> Igloo, yeah. currentlyy either 2 files, or 1 file and a pipe
17:19:24 <dons> sorry. 1 file, and 1+ files, or a pipe
17:19:56 <Igloo> paste <(cat /etc/passwd) <(cat /etc/group)   works here
17:20:45 <dons> paprika$ zip <(id /etc/passwd) <(id /etc/group)
17:20:45 <dons> root:*:0:0:Charlie &:/root:/bin/ksh wheel:*:0:root,dons
17:21:02 <dons> h4sh should just inherit any cool IO facilities, I think
17:21:03 <Igloo> Ah, rats. I need darcs rec --look-for-moves
17:21:25 <stepcut> h4sh?
17:21:32 <Igloo> Sure, that wasn't a feature request, just a realisation it was already possible  :-)
17:21:37 <dons> :)
17:22:07 <dons> but should it instead return: [(root:*:0:0:Charlie, &:/root:/bin/ksh wheel:*:0:root,dons), ... or maybe I should have a flag.
17:22:40 <dons> so it caan switch between showable/readable output, and old-style text output (which limits the set of useful functions)
17:22:48 <lispy> Igloo: that would be a nice feature, but how on earth would you implement it efficiently :)
17:23:05 <dons> stepcut:
17:23:08 <dons> @where h4sh
17:23:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
17:23:13 <Igloo> Efficiency isn't important when you want to use it, IMO
17:23:14 <stepcut> thanks
17:24:06 <lispy> Igloo: fair enough, i guess having it at all and waiting an hour is better than having to do it by hand which is error prone and what not
17:24:17 <stepcut> dons: neat -- I am doing the same thing only different -- adding shell-like operators to haskell :p
17:24:48 <dons> stepcut, ah! stefanw and I had a discussion about this. h4sh really does try to take the other approach.
17:24:57 <dons> have you see haskellshellscript?
17:25:02 <dons> or is it HsShellScript
17:25:05 <stepcut> "cat" <<- ["-n","/etc/motd"] -|- cat ["-E"] |> "/tmp/redirecttest"
17:25:13 <stepcut> never seen it
17:25:26 <dons> oh, maybe have a look. it's very complete.
17:25:56 <Igloo> It shouldn't be anywhere a near an hour on my repo
17:26:10 <dons> stepcut, so, yep, h4sh exports haskell into the shell. which I think is a lightweight way to get a mostly-haskell shell
17:26:54 <dons> since you get haskell functions, but inherit the nice IO the shell provides
17:27:13 <dons> luckily | behaves nicely
17:28:05 <stepcut> oh, I have seen haskell shell script, though I did not like it at the time for some reason
17:28:20 <lispy> dons: would 'map reverse foo' reverse all the lines in foo?
17:29:17 <dons> lispy, yes.
17:29:23 <dons> map -e reverse foo
17:29:24 <lispy> @eval map (concat [1..]) [" one", " two", " three"]
17:29:25 <lambdabot> 23:
17:29:25 <lambdabot>   Expecting a function type, but found `[a]'
17:29:25 <lambdabot>   Expected type: a -> b
17:29:25 <lambdabot>   Inferred type: [a1]
17:29:25 <lambdabot>   Probable cause: `concat' is applied to too many arguments in the
17:29:27 <lambdabot> call
17:29:30 <lambdabot>    (concat ([1 .. ]))
17:29:38 <dons> stepcut, http://www.volker-wysk.de/hsshellscript/ ?
17:29:40 <lispy> @eval map ([1..]++) [" one", " two", " three"]
17:29:42 <lambdabot> <Plugins.Eval>:1:24:
17:29:42 <lambdabot>   No instance for (Num Char)
17:29:42 <lambdabot>   arising from the literal `1'
17:30:11 <dons> sorry. the error format changed just slightly with ghc-6.5, and all my "Quiet @eval!" regexes broke
17:30:17 <stepcut> ah yes, this is what I did not like: The exit code of q is silently ignored. The process ID of the forked copy of q isn't returned to the caller, so it's lost.
17:30:28 <lispy> @eval map ((map show [1..])++) [" one", " two", " three"]
17:30:30 <lambdabot> Couldn't match `String' against `Char'
17:30:34 <lispy> hmm....
17:31:27 <lispy> what is wrong with the type....
17:31:37 <lispy> @type map show [1..]
17:31:39 <lambdabot> [String]
17:31:50 <lispy> @type ["one"]
17:31:51 <lambdabot> [[Char]]
17:32:07 <lispy> oh dir
17:32:16 <lispy> geez, i'm brain dead today
17:33:00 <lispy> zipWith (++) (map show [1..]) [" one", " two", " three"]
17:33:20 <lispy> @eval zipWith (++) (map show [1..]) [" one", " two", " three"]
17:33:22 <lambdabot> ["1 one","2 two","3 three"]
17:33:39 <lispy> dons: so how would you turn that into a h4sh command?
17:34:01 <lispy> basically i want to number all the lines in a file
17:34:11 <dons> ok. let's see.
17:34:20 <lispy> how do you feal with [1..]?
17:34:22 <lispy> er deal
17:34:59 <dons> can't currently. use jot or seq
17:35:08 <lispy> @type jot
17:35:09 <lambdabot> bzzt
17:35:17 <lispy> @hoggle jot
17:35:31 * lispy pokes lambdabot
17:35:33 <dons> shell command
17:35:36 <lispy> ah
17:35:49 <dons> you can intermix haskell and shell, right ;)
17:36:00 <lispy> yeah
17:36:11 <lispy> but man jot => no manual entry
17:37:16 <dons> $ jot 1000 | map -e '++" "' | zip h4sh/testsuite/data
17:37:22 <dons> it's 'seq' on linux
17:37:29 <stepcut> man seq
17:37:37 <stepcut> oops, missed the M-x
17:39:45 <dons> ok. so I should add iterate :: (a -> a) -> a -> [a] to h4sh
17:41:15 <dons> iterate -e +1 1 | map -e ++'" "' | zip f
17:41:48 <lispy> heheh
17:41:54 <dons> or perhaps just unfoldr, eh Igloo ;)
17:42:11 <lispy> if you hadd unfoldr you get to explain it to me :)
17:43:28 <dons> List> (take 1000 (unfoldr (\x -> Just (x, x+1)) 1)) == [1..1000]
17:43:29 <dons> True
17:44:37 <dons> I have to point out that Data.List functions have *so* much more sensible names than sh commands
17:45:28 <lispy> yeah
17:45:28 * Igloo will have to add unfoldr' (need a good name for it) to my H2 wishlist
17:53:48 <stepcut> dons: you could simplify that even more: cat -n h4sh/testsuite/data
17:53:49 <stepcut> :p
17:55:34 <dons> sure, but that's not haskell ;)
17:56:00 <dons> who want's to learn magic flags when we already know List so well
17:57:01 <dons> but h4sh is more ppowerful anyway, since you can supply arbitrary haskell funs to: map, foldl, takewhile, dropwhile, and now iterate and unfoldr
17:57:28 <stepcut> using hsplugins ?
17:57:34 <dons> yep.
17:57:40 <stepcut> ah.. very nice
17:57:59 <gzl> what's h4sh?
17:58:05 <dons> @where h4sh
17:58:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
17:58:35 <dons> really, I think people should use it. in 4 days of using it I've given up a lot of shell programming, and reach for the haskell functions first
17:58:50 <gzl> oh, cool.
17:59:07 <dons> regex code still needs grep/sed though :/ we need a Regex.hs as good as List.hs
18:00:03 <gzl> I'm kind of surprised no one has tried writing a haskell shell
18:01:07 <dons> there's a Clean shell. but probably runtime eval has been the hold up
18:01:08 <stepcut> now if you can just solve this problem: MYVARIABLE='Hello, World!' bash -c 'echo $MYVARABLE'
18:01:12 <monochrom> do you consider ghci to be a haskell shell?
18:01:28 <gzl> no. I mean something like scsh
18:01:49 <monochrom> let myvar="hello world" in putStrLn myvar
18:02:14 <gzl> though I may be remembering what scsh is like incorrectly
18:02:31 <dons> well, people have considered it: www.cse.unsw.edu.au/~pls/thesis-topics/functionalshell.html
18:02:35 <stepcut> monochrom: the problem is, that is not what the code I pasted actually does :)
18:03:04 <monochrom> You want to mimic the "bash -c" part?
18:03:11 <dons> oh, and we have http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
18:03:42 <stepcut> monochrom: no, the code actually just echos an empty line because I made a typo in deferencing $MYVARIABLE
18:03:51 <gzl> monochrom: more or less
18:04:00 <stepcut> monochrom: but bash does not generate an error
18:04:16 <stepcut> making things very confusing to debug :-/
18:04:19 <monochrom> I am not sure if it is wise to be silent about undefined variables.
18:04:32 <stepcut> monochrom: right, that is problem I want dons to solve
18:04:47 <stepcut> monochrom: he is building on top of bash, hence he is still subject to that problem
18:04:57 <monochrom> bash can be told to complain about undefined variables.
18:09:01 <stepcut> monochrom: ah, so it can
18:10:08 <stepcut> I wonder how many scripts rely on that option not being set
18:11:11 <monochrom> Quite many.  Even mine do.
18:11:42 <stepcut> I suspect many of mine do too
18:11:50 <monochrom> if [ x$blah == x ]; ...
18:12:15 <monochrom> or equivalently if [ -n "$blah" ]; ...
18:12:32 <monochrom> these appear in all bootup scripts, for example.
18:12:35 <stepcut> yeah, I would probably have to write the scripts from the start with 'set -u'
18:12:56 <stepcut> well, I am going to a party, cya tomorrow
18:38:32 <Igloo> Hmm, is it just me or can one not use -main-is with a hierarchial name?
18:39:14 <Heffalump> how are you trying to use it?
18:39:51 <Igloo> echo "module W.Q where main = putStrLn \"QQ\"" > W/Q.hs; ghc -main-is W.Q W/Q.hs -o q
18:39:56 <Heffalump> try W.Q.main
18:40:23 <Igloo> OK, that works, ta. But -main-is Q also works.
18:40:34 <Heffalump> I have a feeling that is the preferred format but there is a hack to insert .main if there are no .s
18:40:37 <Heffalump> ICBW though
18:40:42 <Igloo> Ah, OK
18:47:15 <dons> $ zip <(unfoldr -e 'Just. ap(,)(show.(1+).read)' 1)
18:47:15 <dons> 1 # configuration variables
18:47:15 <dons> 2 #
18:47:16 <dons> 3
18:47:18 <dons> :)
18:47:25 <dons> methinks we need flip too
18:49:48 <shapr> yeah
18:49:54 <shapr> dons: I'll flip ya for it.
18:51:28 <shapr> gzl: Want to do a TMR article on WASH?
18:51:36 * shapr looks around for others to pick on
18:51:41 <dons> shapr, can I do a TMR article on h4sh :}
18:51:47 <shapr> w00!
18:52:36 <shapr> I'm all for it.
18:52:46 <shapr> You'll probably get comments from John Cowan and Oleg
18:53:27 <gzl> shapr: sorry, it doesn't look like I can get to it anytime soon. :( I was actually about to look for you to tell you that
18:53:34 <shapr> Aw, too bad.
18:53:49 <shapr> asmodai: Learned any Haskell?
18:54:08 <gzl> if anyone else wants to do anything on WASH, they should definitely just go ahead. if I do get some time at some point, though, I'll let you know
18:54:14 <shapr> ok
18:54:17 <gzl> sorry to string you along
18:54:20 <shapr> No worries.
18:54:41 <shapr> dbremner: Want to write a TMR article?
19:03:28 <lispy_> gzl: hi
19:03:49 <lispy_> gzl: you're the author of WASH?
19:03:53 <gzl> haha. no.
19:03:57 <lispy_> ah
19:04:03 <lispy_> a WASH hacker?
19:04:09 <gzl> I had to use it for a project a few months ago
19:04:47 <lispy_> how hard do you think it would be for wash to support javascript as the target of an eDSL?
19:05:00 <lispy_> i'd rather have wash do ajax than cgi
19:05:28 <KrispyKringle> heh
19:05:31 <gzl> I don't really know much about how WASH is implemented, so if you're looking to extend WASH, I'm not the guy to ask
19:05:55 <lispy_> gzl: okay.  I have an idea, but no idea how to implement it :)
19:06:00 <KrispyKringle> gzl: I was all prepared to publicly bash the whole html generation thing, too. Ah, well.
19:06:24 <gzl> I'm sure shapr would be happy to let you write something if you got off your ass for once ;)
19:06:51 <KrispyKringle> gzl: I'm writing a procmail replacement right now, remember?
19:06:55 <KrispyKringle> it now does the following things:
19:07:24 <KrispyKringle> dupe message filtering, spamassassin filtering, list detection, header parsing and matching, body matching, forwarding, and bouncing. im in the process of adding maildir and mbox delivery and then it's done.
19:07:25 <lispy_> KrispyKringle: http://www.codersbase.com/Autoproc may be of interest to you
19:07:29 <KrispyKringle> might add spambayes, too.
19:07:46 <KrispyKringle> lispy_: im there. one sec, though; dialup is painful.
19:08:10 <lispy_> KrispyKringle: k, i wanted something better than procmail and took the approach of scripting it instead of reimplementing it :)
19:08:19 <KrispyKringle> ooh, and written in haskell!
19:08:32 <KrispyKringle> lispy_: mine's just a python class. it makes it easy to write filters in python, but it isn't a filter itself.
19:08:49 <KrispyKringle> it's under 100 lines so far.
19:09:19 <lispy_> mine is a compiled embeded dsl
19:09:26 <lispy_> "compiled"
19:09:33 <lispy_> more like translated
19:09:44 <KrispyKringle> into procmail recipes?
19:09:47 <lispy_> yeah
19:09:53 <KrispyKringle> ah
19:09:55 <KrispyKringle> neat idea.
19:10:00 <lispy_> thanks
19:10:04 <KrispyKringle> seemed easier to me to just reimplement. i dont know procmail anyway. not well.
19:10:13 <KrispyKringle> but procmail is certainly better at certain things.
19:10:14 <lispy_> yeah, procmail is a pain
19:10:21 <KrispyKringle> im worried about how robust my mailbox delivery stuff will be.
19:10:25 <lispy_> i didn't want to have to parse emails
19:10:35 <lispy_> that too, mbox is evil
19:10:36 <KrispyKringle> im using python libs for it, but im not sure how well it will handle concurrency on the files. fortunately i use maildir, so it doesn't matter.
19:10:45 <KrispyKringle> ah, well, python deals with it pretty neatly for me. that's why mine is so short :)
19:10:57 <lispy_> there is also hsemail (found out about it after the fact)
19:11:27 <lispy_> i want to fix up the language so that it's monadic
19:11:42 <lispy_> right now you supply all the rules in a list
19:11:42 <KrispyKringle> im using some POS Perl program I found at the moment. I hacked it up a bit so it actually works (it was buggy at first), but I'm tired of using such a piece of crap  ;)
19:12:23 <KrispyKringle> where can i see hsemail?
19:12:30 <lispy_> hmm...hang on
19:12:53 <KrispyKringle> see, one thing is i hate writing rules for each mailing list im on.
19:12:58 <KrispyKringle> so automatic list detection is great.
19:13:10 <KrispyKringle> ooh, neat syntax in yours.
19:13:14 <KrispyKringle> very readable.
19:13:16 <lispy_> http://cryp.to/hsemail/docs/
19:13:18 <KrispyKringle> i like.
19:13:21 <gzl> what does the automatic list detection do?
19:13:44 <lispy_> KrispyKringle: thanks, i tried to make it as simple as possible.  It has some weirdness tho
19:14:01 <lispy_> and classifiers were never fully implemented
19:14:30 <KrispyKringle> gzl: it pulls out the list header and figures out what the listname is. Yample (the perl thing i use now) actually uses a Perl module--I think it's Mail::Lists::ListDetect--which does some other heuristics to cope with broken list servers, but mine all seem to add List-ID headers, so it's not needed.
19:14:56 <lispy_> i bet mailman is easy to check for
19:15:37 <lispy_> if Autoproc can't something because it's very sophisticated, then it should be possible to extend it so that it uses a perl script
19:15:46 <gzl> KrispyKringle: yes
19:15:51 <gzl> but once it figures it out, what does it do?
19:15:52 <lispy_> one thing to remember is that an email can have state embedded in the headers :)
19:16:05 <KrispyKringle> gzl: so, I put things in directories based on their mailing list name.
19:16:09 <ehuber_> hello
19:16:10 <KrispyKringle> so i only need a rule that says:
19:16:10 <gzl> ok
19:16:39 <KrispyKringle> if(message.list() is not None): message.maildir("lists/" + message.list())
19:16:43 <KrispyKringle> or whatever
19:16:52 <gzl> ok
19:17:11 <KrispyKringle> although i should make sure to escape "..", since otherwise, someone with forged List-ID headers can REALLY fuck you up. :P
19:28:05 <KrispyKringle_> dammit. why does OSX disconnect me when im idling on dialup?
19:31:34 <ehuber_> any idea how to get a list element at a particular offset
19:31:46 <Cale> list !! n
19:32:08 <Cale> @eval [0..10] !! 5
19:32:10 <lambdabot> 5
19:32:29 <Cale> @eval ['a'..'z'] !! 14
19:32:31 <lambdabot> 'o'
19:32:32 <ehuber_> oh.. thanks (:
19:36:57 <lispy_> @index Identity
19:36:58 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
19:38:21 <shapr> yow!
19:38:21 <shapr> Cale: Think you'll have the time and energy to write about Lazy Eval for the next TMR?
19:38:38 <lispy_> i wanted to use the identity monad, how do i import it?
19:38:47 <Cale> When is the next TMR?
19:38:48 <lispy_> i added import Control.Monad hiding (when)
19:38:50 <Cale> Probably :)
19:39:03 <lispy_> oh, wait
19:39:07 <lispy_> n/m
19:39:44 <dons> anyone got a shorter version of \s->let i=(80-length s)`div`2;t=replicate i '"' '"'in t++s++t
19:39:52 <dons> you'll get credit in the h4sh howto
19:39:57 <lispy_> haha
19:40:14 <lispy_> dons: that's for wrapping at the 80th column?
19:40:17 <dons> (this is for centering lines of a file: map -e f, where f is the above expr)
19:40:40 <lispy_> have you tried the point free version?
19:40:59 <dons>  @pl wasn't type correct, and I was too busy to debug it :}
19:41:13 <TheHunter> @type \s->let i=(80-length s)`div`2;t=replicate i '"' '"'in t++s++t
19:41:15 <lambdabot> bzzt
19:41:31 <lispy_> @pl \s -> let {i = (80-length s)`div` 2; t = replicate i '"' '"' } in t++s++t
19:41:32 <lambdabot> (line 1, column 11):
19:41:32 <lambdabot> unexpected "{"
19:41:32 <lambdabot> expecting natural, identifier or "in"
19:42:02 <lispy_> expecting natural?
19:42:05 <dons> @pl @pl \s -> let i=(80-length s)`div`2 ; t=replicate i '"' '"' in t++s++t
19:42:06 <lambdabot> (line 1, column 1):
19:42:06 <lambdabot> unexpected "@"
19:42:06 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
19:42:06 <lambdabot> expression
19:42:09 <dons> @pl \s -> let i=(80-length s)`div`2 ; t=replicate i '"' '"' in t++s++t
19:42:10 <lambdabot> ap ((. flip (flip replicate '"') '"') . ap (++) . (++)) ((`div` 2) .
19:42:10 <lambdabot> (-) 80 . length)
19:42:19 <dons> oh, oopps.
19:42:29 <dons> @pl \s -> let i=(80-length s)`div`2 ; t=replicate i ' ' in t++s++t
19:42:31 <lambdabot> ap ((. flip replicate ' ') . ap (++) . (++)) ((`div` 2) . (-) 80 .
19:42:31 <lambdabot> length)
19:42:40 <lispy_> that's longer :)
19:42:49 <dons> not sure once you remove space
19:43:04 <Cale> certainly less clear :)
19:44:25 <lispy_> @type a -> Control.Monad.Identity a
19:44:26 <lambdabot> bzzt
19:44:31 <TheHunter> @type ap((.flip replicate ' ').ap(++).(++))((`div` 2).(80-).length)
19:44:32 <lambdabot> bzzt
19:44:48 <lispy_> so how do you declare that something is of type identity monad?
19:45:13 <lispy_> @type a -> b
19:45:15 <lambdabot> bzzt
19:45:24 <lispy_> well, so my test wasn't worth anythnig
19:45:46 <lispy_> @type (return 1) :: Control.Monad.Identit
19:45:48 <lambdabot> bzzt
19:45:48 <lispy_> @type (return 1) :: Control.Monad.Identity
19:45:50 <lambdabot> bzzt
19:45:56 <lispy_> @type (return 1) :: Control.Monad.Identity Int
19:45:57 <Cale> @eval runIdentity (return 1)
19:45:58 <lambdabot> bzzt
19:45:58 <lambdabot> 18: Not in scope: `runIdentity'
19:46:06 <Cale> @eval Control.Monad.runIdentity (return 1)
19:46:08 <lambdabot> 18: Not in scope: `Control.Monad.runIdentity'
19:46:16 <shapr> Cale: 1st of the month
19:46:17 <Cale> @eval Control.Monad.Identity.runIdentity (return 1)
19:46:19 <lambdabot> 18: Not in scope: `Control.Monad.Identity.runIdentity'
19:46:34 <Cale> shapr: yeah, I should be able to write something up :)
19:46:39 <lispy_> @index runIdentity
19:46:40 <lambdabot> Control.Monad.Identity
19:46:57 <shapr> Cale: spiffy!
19:47:23 <lispy_>  Control.Monad.Identity.runIdentity (return 1) should work....
19:47:37 <Cale> It's not loading the module
19:47:44 <lispy_> i'll try it locally
19:48:05 <lispy_> yeah, worked here
19:48:10 <lispy_> i'll twiddle with my import
19:48:28 <ehuber_> er... sorry again.. haha..
19:48:38 <ehuber_> how do i get a \n to output ?
19:48:55 <lispy_> ah, works no
19:48:57 <lispy_> er now
19:49:04 <Cale> ehuber: printLn, or just put \n in the string you're printing
19:49:10 <Cale> er
19:49:13 <Cale> not printLn :)
19:49:17 <Cale> putStrLn
19:49:27 <Cale> print automatically puts a newline
19:49:29 <ehuber_> okay, thanks Cale
19:49:38 <ehuber_> because in HUGS the \n appears as such
19:49:40 <ehuber_> no newline
19:49:51 <Cale> oh, you're using print to print a string?
19:49:59 <Cale> or...
19:50:02 <ehuber_> i was just using the show function
19:50:08 <Cale> oh, okay
19:50:20 <ehuber_> print does seem to put a \n automatically
19:50:30 <ehuber_> but it also ignores \ns
19:50:33 <ehuber_> seemingly
19:50:42 <Cale> well, here's the distinction...
19:50:54 <Cale> show :: (Show a) => a -> String
19:51:00 <Cale> show just builds a string
19:51:04 <Cale> @type print
19:51:06 <lambdabot> forall a. (Show a) => a -> IO ()
19:51:33 <Cale> print actually prints the result of showing the value on the screen
19:51:40 <Cale> @type putStr
19:51:42 <lambdabot> String -> IO ()
19:51:51 <Cale> putStr writes a string to the screen
19:51:58 <ehuber_> oh okay
19:52:02 <Cale> @type putStrLn
19:52:15 <ehuber_> so show just builds a string from the input. so if i give it a string it will leave the string alone, doing nothing to it.
19:52:18 <lambdabot> String -> IO ()
19:52:25 <Cale> putStrLn does the same, but puts a newline at the end
19:52:28 <ehuber_> including ignoring the escape chars.
19:52:37 <Cale> show will quote the string
19:52:43 <Cale> @eval show "Hello"
19:52:45 <lambdabot> "\"Hello\""
19:52:51 <Cale> @eval show (show "Hello")
19:52:53 <lambdabot> "\"\\\"Hello\\\"\""
19:53:05 <ehuber_> confusing stuff (:
19:53:08 <ehuber_> thanks though
19:53:25 <Cale> print = putStrLn . show
19:53:35 <dons> here's some one liners for h4sh. If anyone can think of some more useful ones, darcs patch the HOWTO, or mail me, and you'll get credit :)
19:53:39 <dons> http://www.cse.unsw.edu.au/~dons/h4sh.txt
19:54:40 <Cale> so if you "print" a string, it will print the show of that string, which has quotes around it, and newlines are written as \n
19:54:56 <ehuber_> wait, what does the . operator do again?
19:55:10 <Cale> ehuber_: It composes functions
19:55:19 <ehuber_> ok... confused (:
19:55:25 <wagle> @pl 1 + 1
19:55:26 <lambdabot> 2
19:55:32 <wagle> @pl x + y
19:55:33 <lambdabot> x + y
19:55:42 <Cale> @eval ((+4) . (*3)) 5
19:55:43 <wagle> 8(
19:55:44 <lambdabot> 19
19:55:58 <Cale> @eval 5 * 3 + 4
19:56:01 <lambdabot> 19
19:56:06 <wagle> why is @pl evaluating?
19:56:35 <shapr> Because every function is a thunk?
19:56:37 <dons> it's too smart ;)
19:56:41 <lispy_> i suspect that it reduces functions whenever all the arguments are available
19:56:45 <wagle> @pl (x + y) * z
19:56:46 <Cale> ehuber: (f . g) x = f (g x)
19:56:46 <lambdabot> (x + y) * z
19:57:04 <ehuber_> oh okay
19:57:16 <ehuber_> i get the math notation (:
19:57:25 <Cale> Hugs automatically uses print on anything which isn't an IO action.
19:57:31 <lispy_> @eval let (f `dot` g) x = f (g x) in head `dot` tail [1..3]
19:57:32 <lambdabot> 60:
19:57:32 <lambdabot>   Expecting a function type, but found `[a]'
19:57:32 <lambdabot>   Expected type: t -> [a]
19:57:32 <lambdabot>   Inferred type: [a1]
19:57:32 <lambdabot>   Probable cause: `tail' is applied to too many arguments in the
19:57:34 <lambdabot> call
19:57:36 <lambdabot>    (tail ([1 .. 3]))
19:58:02 <Cale> so if the result of some calculation is a String, what you'll get is the quoted version of that string, (which is often what you want, because it's unambiguous)
19:58:05 <lispy_> @type tail
19:58:07 <lambdabot> forall a. [a] -> [a]
19:58:13 <dons> Cale, does it print functions?
19:58:24 <lispy_> @eval let (f `dot` g) x = f (g x) in (head `dot` tail) [1..3]
19:58:26 <lambdabot> 2
19:58:38 <Cale> Hugs.Base> (\x -> x)
19:58:38 <Cale> ERROR - Cannot find "show" function for:
19:58:38 <Cale> *** Expression : \x -> x
19:58:38 <Cale> *** Of type    : a -> a
19:58:42 <dons> ah, no. 
19:58:43 <Cale> yes :)
19:58:48 <dons> oh, ok.
19:58:51 <lispy_> ehuber: so i just did that let to make a point, the definition of (.) that Cale gave you is valid haskell :)
19:58:52 <dons> Cale++
19:58:53 <Cale> It tries to, and fails
19:59:02 <lispy_> ehuber: juts in case you ever wondered :)
19:59:06 <ehuber_> lol. showoff (:
19:59:55 <ehuber_> but how is this different from doing   head tail [1..3]
20:00:07 <lispy_> @eval head tail [1..3]
20:00:09 <lambdabot> 23:
20:00:09 <lambdabot>   Expecting a function type, but found `[a]'
20:00:09 <lambdabot>   Expected type: [t -> a]
20:00:09 <lambdabot>   Inferred type: [a1] -> [a1]
20:00:14 <Cale> @eval head (tail [1..3])
20:00:15 <lispy_> you need brackets
20:00:16 <lambdabot> 2
20:00:18 <ehuber_> oh
20:00:24 <Cale> it's not different
20:00:28 <Cale> however
20:00:41 <Cale> (head . tail) doesn't mention the argument to the function
20:00:50 <Cale> you're doing something to the functions themselves
20:01:21 <Cale> otherwise, you'd write (\x -> head (tail x))
20:01:25 <ehuber_> oh.. so you could pass it to another function for example
20:01:29 <Cale> yeah
20:01:40 <ehuber_> okay
20:01:52 <ehuber_> back to my brainfuck interpreter ;)  thanks for the tips
20:03:56 <Cale> dons: you should correct the line centring thing similarly to how you did on IRC
20:05:07 <dons> it's correct in the doc isn't it? (wrt. shell quotation)
20:05:23 <Cale> oh, I see
20:06:05 <Cale> yeah
20:06:27 <Cale> it might be clearer to use \'
20:06:44 <Cale> or surround the whole string in "
20:06:56 <Cale> so you can use ' without additional tricks :)
20:06:58 <dons> "" doesn't work in the presence of ``
20:07:03 <Cale> oh
20:07:07 <Cale> jeez :) yeah
20:07:15 <dons> and \' didn't work inside ''
20:07:24 <Cale> really? hmm...
20:07:36 <dons> checking..
20:07:46 <Cale> yeah, I'm getting that too
20:07:48 <Cale> odd
20:08:04 <dons> I don't think they understand escaped quotes
20:08:15 <dons> they=[zsh,..]
20:08:38 <dons> oh, little shorter if we don't inline `div`
20:08:54 <dons> and then we can use ""
20:11:08 <dons> i've put up the shorter version
20:14:25 <ehuber_> argh.. sorry guys.. i did look at google.. but is there some way to take an element at position n from a list l, set its value, and returns the entire list (with updated value) ?
20:14:35 <ehuber_> some default function?
20:19:06 <TheHunter> @type \s->(\t->t++s++t)(replicate(div(80-length s)2)' ')
20:19:07 <lambdabot> [Char] -> [Char]
20:19:43 <dons> @eval let (a,b) = splitAt 3 "haskell" in init a ++ ['X'] ++ b
20:19:45 <lambdabot> "haXkell"
20:19:56 <dons> ehuber_ ^
20:20:05 <dons> TheHunter: :)
20:20:24 <TheHunter> that's the shortest i could find.
20:20:43 <dons> works for me. cheers!
20:21:43 <ehuber_> oh.. need to look up syntax of let (:
20:21:45 <ehuber_> thanks
20:23:55 <liyang> Would it be better to take tail b rather than init a? Or am I being irrationally scared of init?
20:25:35 <TheHunter> @eval zipWith ($) (replicate 2 id ++ [const 'X'] ++ repeat id) "haskell"
20:25:37 <lambdabot> "haXkell"
20:26:01 <TheHunter> err,
20:26:08 <TheHunter> @eval zipWith ($) (replicate 2 id ++ const 'X': repeat id) "haskell"
20:26:10 <lambdabot> "haXkell"
20:28:26 <liyang> (It seems strange that we have e.g. Data.Map.adjust, yet there's no notionally equivalent function for lists...)
20:34:57 <lispy_> @doc Control.Monad.State
20:34:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.State.html
20:35:30 <mwc> I give up, how does one convert a Float to an Int without a 5 line function that still kills the type checker?'
20:36:00 <lispy_> floor?
20:36:09 <mwc> I was trying round
20:36:17 <lispy_> @type round
20:36:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:36:28 <lispy_> @eval round 0.5
20:36:29 <mwc> but then I get into a bunch of weird errors with Integral and RealFrac instanes
20:36:30 <lambdabot> 0
20:36:38 <lispy_> hmm...0.5 should round up
20:36:41 <mwc> @type (round 0.5)
20:36:42 <lispy_> @eval round 0.6
20:36:44 <lambdabot> forall b. (Integral b) => b
20:36:44 <lambdabot> 1
20:37:01 <mwc> hmm, so then how do I down converted that Integral to an int?
20:37:20 <lispy_> @type round 0.5 :: Int
20:37:22 <lambdabot> Int :: Int
20:37:31 <mwc> Hmm
20:37:33 <lispy_> Int is a sort of Integral
20:37:41 <lispy_> (not sure on the terminology)
20:37:48 <dons> it's a kind of Integral ;)
20:38:01 <Cale> The type Int is in the Integral type class
20:38:03 <dons> or maybe just a type of Integral.
20:38:04 <lispy_> but i thought kind was *, * -> *, and so on :)
20:38:17 <mwc> Yeah, I had (round :: Int) 0.5
20:38:19 <dons> Cale has to spoil the fun
20:38:25 <Cale> hehe
20:38:51 <Cale> @eval (round :: Float -> Int) 0.5
20:38:52 <dons> ah, I meant to say it was _of_ kind Integral (very very loosely)
20:38:53 <lambdabot> 0
20:38:57 <lispy_> i wanted to define something, but i can't make it a monad
20:39:02 <Cale> @eval (round 0.5) :: Int
20:39:04 <lambdabot> 0
20:39:14 <TheHunter> @eval 0.5*2
20:39:16 <lambdabot> 1.0
20:39:18 <lispy_> why is 0.5 rounded down?
20:39:19 <TheHunter> @eval 0.5*2 - 1
20:39:20 <lambdabot> 0.0
20:39:28 <Cale> @eval (round 1.5) :: Int
20:39:30 <lambdabot> 2
20:39:35 <Cale> because 0 is even
20:39:46 <liyang> @eval (round 2.5) :: Int
20:39:48 <lambdabot> 2
20:39:55 <liyang> Yay. Round to even.
20:40:06 <mwc> Yeah, this is still choking. map (\x -> round x :: Int) listOfFloats
20:40:16 <lispy_> why does it round to an even? because of the binary rep. or something?
20:40:34 <Cale> It rounds to even because that's what you're supposed to do when rounding. It eliminates bias.
20:40:49 <lispy_> hah, in grade school they never taught that :)
20:41:05 * liyang was going to say something but he's forgotten pretty much all of his numerical analysis lectures.
20:41:44 <mwc> @type (\x -> round x :: Float)
20:41:46 <lambdabot> bzzt
20:41:53 <mwc> @type (\x -> round x :: Int)
20:41:55 <lambdabot> forall a. (RealFrac a) => a -> Int
20:42:05 <mwc> @type map (\x -> round x :: Int)
20:42:07 <lambdabot> forall a. (RealFrac a) => [a] -> [Int]
20:42:10 <lispy_> i was hoping to use a monad (and i see why it won't work) to have something like |do x; y; z| and have the result be that x, y, z are in a monad together
20:42:16 <mwc> damn it, that should work
20:42:20 <lispy_> so for example the list monad
20:42:31 <lispy_> maybe it can still work, but i'm not sure how i would do it
20:43:04 <TheHunter> what does that mean "are in a monad together" ?
20:43:05 <mwc> @eval map (\x -> round x :: Int) [0.0, 0.333, pi]
20:43:08 <lambdabot> [0,0,3]
20:43:17 <mwc> why the hell doesn't that work here?!
20:43:37 <lispy_> TheHunter: yeah, that's the part i'm struggling with.  I wanted   x >>= y >>= z, to be something that I could transform to [x,y,z]
20:44:11 <TheHunter> that doesn't do anything sensible to the types.
20:44:28 * lispy_ nods
20:44:33 <lispy_> i wanted it for a DSL
20:44:52 <lispy_> for the syntax sugar
20:44:53 <TheHunter> maybe you want to have a look at the writer monad.
20:45:26 <lispy_> hmm....i just learned a tiny but about that one today,i'll go read some more
20:45:46 <lispy_> Oh
20:45:53 <lispy_> I see why you're recommending it
20:45:56 <lispy_> cool, thanks
20:49:58 <ehuber_> argh
20:50:22 <ehuber_> in a function defined in a let clause, may i somehow use class constraints?
20:52:52 <Cale> hm? Sure
20:53:11 <Cale> in some sense, the whole program is inside a let clause
20:54:18 <lispy_> @hoogle mappend
20:54:48 <lispy_> i should probably just interact with lambdabot in a separate window most of the time :)
20:57:41 <ehuber_> bfuck :: String -> [Integer] -> Integer -> String
20:57:42 <ehuber_> bfuck [] _ _                  = []
20:57:53 <ehuber_> Type checking
20:57:54 <ehuber_> ERROR bfuck.hs:5 - Instance of Num [Integer] required for definition of bfuck
20:57:59 <ehuber_> ???? im lost
20:58:20 <Cale> ehuber_: it means that you used a list like it was a number somewhere
20:59:02 <juhp> dons: hi.  should hs-plugins-0.9.10 build with ghc-6.4.1?
21:00:39 <ehuber_> ah.. the problem was missing parens in my let clause
21:02:31 <Pseudonym> :If you can't own a
21:02:31 <Pseudonym> :Mona
21:02:31 <Pseudonym> ::Lease 'er
21:02:39 <Pseudonym> Sorry, didn't mean to paste that.
21:02:43 <Pseudonym> Still, enjoy!
21:03:30 <ehuber_> (:
21:03:49 <Pseudonym> http://en.wikipedia.org/wiki/Solage_%28poetry%29
21:03:54 <Pseudonym> In case anyone is curious.
21:07:07 <lispy_> hmm...so writer monad does what i need as long as i use tell
21:07:22 <lispy_> so now i need to redefine tell to be just the right thing...
21:31:30 <lispy_> TheHunter: i was able to tuck away the magic that is the Writer monad and it works the way I wanted
21:31:35 <lispy_> TheHunter: thanks for the hint
21:32:08 <lispy_> rules = do spamc; defaultRule  :: Writer [CExp] ()
21:32:23 <lispy_> then I use (snd . runWriter) on rules to get my list
21:34:14 <TheHunter> snd . runWriter is probably either evalWriter or execWriter.
21:35:24 <lispy> it's exactly execWriter
21:35:26 <lispy> thanks
21:38:39 <SyntaxNinja> shhh
21:39:01 <lispy> are you sneaking?
21:39:14 * SyntaxNinja silently silences lispy
21:40:04 * lispy feels quiet
21:40:26 * SyntaxNinja quietly pokes dcoutts
22:04:49 <dons> juhp, hmm. I know the darcs repo does
22:05:26 <juhp> dons: or it needs haskell-src-exts ?
22:05:34 <dons> sure does.
22:06:06 <juhp> okay....
22:06:37 <juhp> just quite a long dependency sequence to get h4sh to build...
22:06:50 <dons> hsx, hs-plugins. done!
22:07:00 <dons> but everyone should have hs-plugins installed anyway ;)
22:07:11 <dons> to run Yi!
22:07:16 <dons> mwhahahaha
22:07:19 <lispy> dons: i was unable to build yi on redhat, fwiw.  don't remember the errors atm
22:07:25 <juhp> dons: yeah - well I build cpphs too for good measure ;)
22:07:29 <juhp> built
22:07:47 <dons> lispy. send a bug report. i test nightly on linux for what its worth.
22:07:49 <juhp> dons: is there a tarball for hsx somewhere?
22:08:02 <dons> no idea. check with nibro. I think not atm.
22:08:14 <lispy> dons: i suspect it was a ghc problem.  We're runnig 6.2.something
22:08:15 <juhp> yeah that was my feeling too...
22:08:31 <lispy> dons: oh, i was missing hsc2hs
22:08:52 <lispy> dons: and no clue where to get it (google wasn't very helpful)
22:08:52 <dons> lispy, but ghc comes with hsc2hs
22:09:28 <lispy> no wonder i couldn't find it
22:09:28 <dons> juhp, btw, I just added ($) to h4sh, in case you already built it.
22:09:40 <lispy> you added cash?
22:09:49 <juhp> lispy: did you build it yourself?
22:10:00 <juhp> cash?
22:10:00 <dons> lispy ;) paprika$ ap --help
22:10:01 <dons> Usage: "ap" [OPTION...] [file..]
22:10:01 <dons>   -v       --version    version string
22:10:01 <dons>   -?       --help       help
22:10:01 <dons>   -e expr  --expr=expr  Haskell expression
22:10:02 <lispy> dons: any idea why we'd have ghc but not hsc2hs?
22:10:03 <dons> ($) :: (a -> b) -> a -> b
22:10:06 <dons> Function application.
22:10:21 <lispy> juhp: no, i let the support staff compile most stuff :)
22:10:27 <dons> no. seems strange. maybe an unworthy package maintainer?
22:10:33 <juhp> lispy: you installed ghc622 but not ghc?
22:10:38 <dons> (apologies if it is someone I know ;)
22:11:29 <lispy> i have no idea what they installed.  I'm guess one of the professores said, "Hey, we need ghc on the server" and hen the support staff probably just used yumm or something
22:12:23 <juhp> dons: for "take" say was wondering if the -n couldn't just be dropped for example?
22:12:34 <juhp> to make the syntax more haskell-like?
22:12:41 <SyntaxNinja> syntax!
22:12:56 <lispy> SyntaxNinja: heh, you feeling alright?
22:13:19 <SyntaxNinja> lispy: it's just that my test suite takes a while to run, and I get bored in between runs
22:13:44 <lispy> is that what they're calling it these days, "test suite"
22:13:48 <lispy> yeah, i know you kids
22:14:13 <dons> juhp, yeah, I agree juhp.
22:14:28 <dons> as its a type error anyway. so I will drop the -n and -e flags
22:14:37 <juhp> dons: cool :)
22:14:49 <dons> it's so much fun writing haskell one liners
22:14:57 <lispy> heh
22:15:05 <lispy> that's the real motorvation isn'tit?
22:15:19 <dons> yeah. bring pointfree programming to the masses!
22:15:40 <lispy> that's "unwashed masses" ;)
22:15:47 <SyntaxNinja> lispy: if you don't believe me, watch my commit messages fly by!
22:16:02 <lispy> SyntaxNinja: more slang?
22:16:50 <dons> juhp, btw, have a look in HOWTO, and if you want to suggest some other one liners, or some shorter versions, that would be cool ;)
22:16:59 * dons -> meeting
22:17:16 <lispy> i always forget dons is in a different timezone
22:18:15 <SyntaxNinja> lispy: incontrovertible digital proof: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/Cabal/Distribution/PackageDescription.hs?rev=1.61
22:18:54 <ozone> lispy: actually, dons is on a different planet
22:19:16 <ozone> i think he might actually be a citizen of zeta aki 5, an advanced alien civilisation
22:20:07 <SyntaxNinja> ozone: can I ask you a personal question?
22:22:10 <lispy> SyntaxNinja: sorr, that url was too long to click on
22:22:17 <lispy> so it's not proof
22:22:52 <SyntaxNinja> that, and my laptop screen is acting up so I have to give it a rest :(
22:23:00 <SyntaxNinja> ask ozone if he likes veggy-mite when he gets back.
22:23:46 <lispy> um...okay, i'll try to keep it real
22:24:20 <ozone> vegemite?  jesus christ no
22:32:50 <lispy> @sequence
22:32:52 <lambdabot> Unknown command, try @listcommands.
22:32:56 <lispy> @type sequence
22:32:58 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
22:33:31 <lispy> @type mapM
22:33:32 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
22:34:37 <lispy> [a], (a -> m a), and I need to get to m [a]
22:34:52 <lispy> @hoogle [a] -> (a -> m a) -> m [a]
22:34:53 <lambdabot> Prelude.mapM :: Monad a => ((b -> (a c)) -> [b] -> (a [c]))
22:34:53 <lambdabot> Monad.filterM :: Monad a => ((b -> (a Bool)) -> [b] -> (a [b]))
22:34:53 <lambdabot> Prelude.map :: ((a -> b) -> [a] -> [b])
22:35:19 <musasabi> morning
22:35:25 <lispy> morning
22:36:40 <lispy> @type foldM
22:36:42 <lambdabot> bzzt
22:36:50 <lispy> @type Control.Monad.foldM
22:36:52 <lambdabot> forall a (m :: * -> *) b.
22:36:52 <lambdabot> (Monad m) =>
22:36:52 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
23:01:49 <SyntaxNinja> lispy: thanks for keeping it real.
23:01:58 <lispy> SyntaxNinja: np
23:02:01 <SyntaxNinja> ozone: glad to hear it. andy m. loves the stuff
23:02:28 <lispy> SyntaxNinja: i know you won't care, but i made a small incremental improvement to http://www.codersbase.com/Autoproc
23:04:15 <lispy_> that program is targeted at a really small user group.  People who are sick of promail (but currently use it), know haskell and have a haskell compiler installed
23:04:23 <lispy_> procmail*
23:04:54 <SyntaxNinja> lispy: hey cool. you should add some examples.
23:04:56 <lispy_> so far, there has been one person that meets those constraints
23:05:04 <ozone> SyntaxNinja: yeah, but he's ... like ... andy moran
23:05:06 <SyntaxNinja> <-- sick of procmail
23:05:08 <lispy_> SyntaxNinja: Rules.hs!
23:05:18 <lispy_> SyntaxNinja: it has every rule i've ever written :)
23:05:20 <SyntaxNinja> lispy_: I mean on your wicky
23:05:23 <ozone> i think you'll find that vegemite is a love-it-or-hate-it thing
23:05:23 <lispy_> oh
23:05:28 <lispy_> yeah....that
23:05:43 <SyntaxNinja> ozone: I see... as in, the .aus love it, but hte rest of the world hates it?
23:05:51 <lispy_> SyntaxNinja: yeah, feel free to leave comments on the "Talk" tab
23:07:44 <lispy> i'd like to make it so that it reads a file with  your rules, but i'm too lazy to make a parser so far :)
23:08:08 <lispy> plus the way it is now your recipes are type checked :)
23:09:43 <SyntaxNinja> is kosmikus here?
23:10:05 <SyntaxNinja> ozone: I'm tempted to try it
23:10:29 <SyntaxNinja> does anyone know what version number ghc 6.4.1 pre-releases report?
23:12:10 <SyntaxNinja> 			   odir | versionBranch ghc_vers >= [6,4,1] = pref
23:12:11 <SyntaxNinja> 				| otherwise = pref `joinFileName` dirOf c
23:12:11 <SyntaxNinja> 				-- ghc 6.4.1 fixed a bug in -odir handling
23:12:11 <SyntaxNinja> 				-- for C compilations.
23:12:26 <SyntaxNinja> that's there in cabal; I don't know if that version number checker is actually correct or what.
23:13:49 <lispy_> @eval let { hike = repeat "See ya!"; a = 1 } in take a hike
23:13:52 <lambdabot> ["See ya!"]
23:16:47 <ozone> SyntaxNinja: no, you'll find a lot of australians can't stand vegemite either
23:16:49 <SyntaxNinja> gosh, the glasgow-haskell-user's list is the secret underground of cabal questions sent to the wron gplace
23:16:53 <dblhelix> lispy: nice :)
23:17:42 <Lemmih> Hey SyntaxNinja.
23:17:50 <SyntaxNinja> ozone: I'm trying to tease you.
23:17:53 <SyntaxNinja> hi Lemmih
23:19:34 * lispy_ wonders about writing haskell hikus
23:19:38 <lispy_> haiku
23:20:17 <KrispyKringle> haha!
23:20:31 <KrispyKringle> lispy_: I believe I have now properly implemented RFC compliant message bouncing, so you can reject spambots in style!
23:20:35 <KrispyKringle> :P
23:20:37 <KrispyKringle> I should go to bed.
23:20:49 <lispy_> KrispyKringle: er...did you know about hs-email?
23:20:55 <lispy_> KrispyKringle: are you igloo?
23:21:00 * lispy_ gets confused
23:21:03 <KrispyKringle> Didn't we just have this discussion?
23:21:06 <KrispyKringle> No, I'm not igloo.
23:21:07 <SyntaxNinja> can someone w/ a 6.4.1 pre-release run a setup configure and let me see the ghc version output?
23:21:18 <lispy_> KrispyKringle: heh, we probably did talk about it
23:21:25 <KrispyKringle> lispy_: we were just talking about this :P
23:21:26 <lispy_> i'm like a fish
23:21:33 <KrispyKringle> about your haskell procmail interpreter
23:21:36 <KrispyKringle> huh?
23:21:37 <lispy_> OH
23:21:41 <lispy_> KrispyKringle: cool!
23:21:41 <KrispyKringle> like a fish?
23:21:41 <KrispyKringle> cold blooded?
23:21:44 <SyntaxNinja> lispy_: you need a bicycle?
23:21:45 <KrispyKringle> water breathing?
23:21:51 <KrispyKringle> with gills?
23:21:51 <lispy_> SyntaxNinja: yes, i do actually
23:21:55 <lispy_> KrispyKringle: huh?
23:21:59 <KrispyKringle> haha
23:22:01 <lispy_> KrispyKringle: what are you talking about now?
23:22:04 <KrispyKringle> I have an old one I just sold.
23:22:05 <lispy_> ;)
23:22:07 <KrispyKringle> A bicycle, that is.
23:22:14 <KrispyKringle> Well, I don't have it anymore. I sold it.
23:22:21 <KrispyKringle> lispy_: I was wondering what it meant for you to be like a fish!
23:22:27 <lispy_> fish are said to have virtually no long term memory
23:22:34 <SyntaxNinja> oh nm
23:22:41 <KrispyKringle> Ah
23:22:45 <KrispyKringle> I didn't know that.
23:22:52 <KrispyKringle> I like SyntaxNinja's hypothesis better.
23:22:57 <lispy_> heh, yeah
23:23:11 <lispy_> i need a bicycle like Philippa needs a man
23:23:26 <KrispyKringle> anyway, it took me a while to figure out how the mime encoding of all that stuff works.
23:23:32 <lispy_> (sorry, Philippa just that you're the only female I know of in the channel)
23:23:39 <lispy_> yeah
23:23:41 <lispy_> that stuff is hard
23:23:47 <KrispyKringle> Wait, were you saying you DID need a bicycle, or not?
23:24:02 <lispy_> i implemented MIME PGP in php once...but the patch didn't get accepted
23:24:18 <lispy_> well, i have a bicycle at home, but not where i'm living this month
23:24:18 <KrispyKringle> Well, my rejects look basically like Postfix's, so that's probably good. The goal is to do something spambots will recognize as a reject. Though personally I wouldn't reject to spam, since you run the riisk of REALLY annoying people.
23:24:22 <lispy_> so...it's like sort of
23:24:23 <KrispyKringle> Oh, jesus.
23:24:27 <KrispyKringle> Hats off to you, lispy_
23:24:56 <KrispyKringle> I just got a new one. I'm really happy, but I have a feeling it's going to be stolen.
23:25:04 <KrispyKringle> Perhaps I should have kept my old one to ride around the city.
23:25:05 <lispy_> KrispyKringle: if you use the pgp/gpg stuff in squirrelmail and want mime pgp then make the devs apply my patch :)
23:25:21 <KrispyKringle> lispy_: I don't use squirrelmail.
23:25:25 <KrispyKringle> Sorry. :P
23:25:34 <KrispyKringle> Webmail messes with my inner peace.
23:25:35 <lispy_> they use cvs, and i couldn't get the dev version installed, so i never bothered to fix my patch
23:25:47 <lispy_> afaik they fell off the face of the planet
23:25:52 <KrispyKringle> cvs makes baby jesus cry.
23:25:53 <lispy_> gmail is pretty good
23:25:59 <lispy_> yeah, i hate CVS
23:25:59 <KrispyKringle> I can't stand that stuff.
23:26:02 <KrispyKringle> gmail isn't bad.
23:26:08 <KrispyKringle> I've been using it lately because I messed up my maildir.
23:26:13 <lispy_> that's why i send in patches to darcs...which is what i was supposed to do tonight
23:26:17 <KrispyKringle> But it's still webmail.
23:26:25 <KrispyKringle> ah, nice
23:26:50 <lispy_> i added a post apply script hook, and i was supposed to generalize it
23:26:56 <lispy_> make it work with all commands
23:27:04 <lispy_> but i hacked on autoproc instead
23:27:23 <lispy_> oh, and test something for igloo
23:27:25 <lispy_> i should go do that
23:29:00 <musasabi> SyntaxNinja: about the cabal release candidate - would it be possible to add the c-sources in subdirectories handling with 6.4.1 ?
23:30:38 <SyntaxNinja> musasabi: what do you mean? the bugfix that kosmikus was talking about on glasgow-haskell-users?
23:32:38 <musasabi> Haven't read todays emails yet, but in Distribution.Simple.Build around line 170 - it is fixed in the CVS version at least.
23:33:52 * lispy_ is now known as mapM_
23:34:00 <SyntaxNinja> it is only pretending to be fixed on line 170; it actually needs to be fixed on line 238... I'm working on that now, will you test it for me?
23:34:14 <SyntaxNinja> are you running into that bug?
23:34:53 <musasabi> SyntaxNinja: I just darcs mv:ed my C sources to the main directory, but e.g. c2hs is suffering from that issue.
23:35:39 <SyntaxNinja> musasabi: can you grab an example package and test it for me? I don't have that version of ghc installed...
23:38:42 <SyntaxNinja> the example package is here:  http://www.iai.uni-bonn.de/~loeh/cabalghc.tar.gz
23:41:36 <musasabi> What version of Cabal should I test it with? I am currently using a hacked CVS version...
23:42:43 <SyntaxNinja> a fresh darcs pull
23:42:55 <musasabi> How do versioned build-depends work? "Build-Depends:   base, network-alt > 0.2.1" makes Cabal complain "*** Exception: Line 7: Parse of field 'build-depends' failed"
23:42:59 * musasabi tries that
23:43:37 <SyntaxNinja> hm. try it without the spaces around the >
23:44:06 <dons> juhp, just committed patch to remove -n -e flags. So now arguments to h4sh functions are in their type signature order
23:44:20 <juhp> dons: thanks a lot
23:44:23 <lispy_> dons: hehe
23:44:35 <lispy_> dons: how's it feel to be criminally insane :)
23:44:43 <juhp> lol
23:44:48 <musasabi> Thanks works without the spaces - might want to document that one.
23:45:12 <dons> lispy_ :p
23:45:48 <SyntaxNinja> @wiki
23:45:49 <lambdabot> http://www.haskell.org/hawiki/
23:46:16 <lambdabot> everyone install h4sh and contribute to the h4sh one liners document
23:46:16 <lambdabot> -- I command you!
23:46:22 <lispy_> hawiki sounds like the noise you might make when sneezing
23:46:30 <lispy_> hehe
23:46:42 <lispy_> oh mighty lambdabot
23:47:29 <lispy_> so it it "h four sh" or "hash"
23:47:42 <lambdabot> your lord lambdabot commands you to go forth and partially apply!
23:47:48 <dons> lispy_,  not sure.
23:48:15 <dons> "aech" "for" "sh" is kind of hard to pronounce
23:48:34 * SyntaxNinja eagerly awaits musasabi's answer to the question of this bugfix... hoping to hear before my laptop screen craps out again
23:48:47 <lispy_> my laptop is making a new sound
23:48:50 <lispy_> this is not good
23:49:13 <dons> yow, battery low.
23:50:00 <lispy_> i hope this is just the fan in high gear
23:50:13 <lispy_> this laptop is less than 2 months
23:50:16 <SyntaxNinja> is there a way to make linux turn the fan on
23:50:25 <lispy_> SyntaxNinja: it's hardware dependent
23:50:33 <lispy_> SyntaxNinja: sometimes yes, usually no
23:51:16 <SyntaxNinja> I'd like to run my fan all the time to see if that helps w/ the screen. it takes some time before crapping out
23:51:49 <lispy_> sometimes there is an acpi fan module
23:52:50 <SyntaxNinja> eh, I gotta bail.  musasabi drop me an email if you get a chance.
23:53:08 <lispy_> see ya
23:53:10 <musasabi> SyntaxNinja: I am compiling the new cabal, I'll send you mail.
23:53:15 <lispy_> i should bail too
23:53:28 <lispy_> but i really wanna test this darcs thing
23:53:33 <lispy_> compile faster!
23:53:52 <lispy_> all the way to patch check
23:53:54 <lispy_> so that's good
23:54:05 <SyntaxNinja> peace all
23:54:43 <lispy_> night
