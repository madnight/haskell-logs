01:10:58 <jyp> @yow
01:10:59 <lambdabot> I'm pretending I'm pulling in a TROUT!  Am I doing it correctly??
01:11:29 <jyp> @seen dons
01:11:29 <lambdabot> dons is in #haskell. Last spoke 1 day, 2 hours, 6 minutes and 1
01:11:29 <lambdabot> second ago.
01:17:49 <lightstep> are there many multi-line definitions in fptools? running @code 12 times only yielded type declarations and single-line definitions
01:18:32 <Lemmih> @help code
01:18:33 <lambdabot>  @code, print random line of code from $fptools
01:20:40 <lightstep> yes, but only two of these lines (out of 24) are part of multi-line definitions
01:22:42 <Lemmih> Most of the definitions in $fptools should span multiple lines.
01:22:52 <Lemmih> @code
01:22:53 <lambdabot> Handle.hs: openTempFile' :: String -> FilePath -> String -> Bool -> IO (FilePath, Handle)
01:22:56 <Lemmih> @code
01:22:57 <lambdabot> Char.hs: isAsciiUpper c          =  c >= 'A' && c <= 'Z'
01:23:02 <Lemmih> @code
01:23:02 <lambdabot> PArr.hs: minimumP [::]  = error "Prelude.minimumP: empty parallel array"
01:23:16 <Lemmih> @code
01:23:17 <lambdabot> Handle.hs: WriteMode     -> ( WriteHandle,     True )
01:23:25 <Lemmih> @code
01:23:26 <lambdabot> Show.hs: showListWith :: (a -> ShowS) -> [a] -> ShowS
01:23:44 <lightstep> see?
01:24:05 <Lemmih> One out of two (not considering type signatures).
01:24:42 <Lemmih> One out of three for the type sigs.
01:25:27 <Lemmih> Looks pretty normal to me.
01:26:27 <lightstep> you meen, one out of four (signature, single-line, multi-line, sygnature), considering that i don't understand the Hadnel.hs line
01:27:09 <Lemmih> One line type signatures are very common.
01:27:54 <lightstep> sure, but if for every signature you have ~3 lines of code, the code should be ~75% of a random output
01:29:10 <lightstep> which lead me to suspect that #code is biased towards type declarations
01:30:27 <Lemmih> Chance may also be a big factor here.
01:31:26 <xerox> ‽
01:33:11 <xerox> 'morning (that was an interrobang)
01:33:16 <xerox> @wikipedia Interrobang
01:33:18 <lambdabot> http://en.wikipedia.org/wiki/Interrobang
01:45:31 <boegel> @seen Itkovian
01:45:32 <lambdabot> I saw Itkovian leaving #haskell 8 hours, 1 minute and 24 seconds ago.
01:45:37 * boegel swears
01:52:28 <boegel> hey arjanb
01:52:44 <arjanb> hi
02:41:31 <boegel> yo Itkovian (brb)
02:41:46 <Itkovian> hi boegel.
02:41:52 <Itkovian> back from holiday?
02:44:00 * Itkovian is cooking the kid's food, brb
02:52:51 <Itkovian> pompompom
02:53:05 <Itkovian> boegel: you coming to work monday? or have you already been at the lab?
02:53:15 <Itkovian> in which office did they put you?
02:54:48 <xerox> Could you suggest me an example (simple) application that makes use of the Reader Monad?
02:55:59 <boegel> Itkovian: I've worked al weak already
02:56:11 <Itkovian> nice
02:56:17 <Itkovian> and where did they put you?
02:56:20 <boegel> the same office as Lieven is in (together with Luk and Filip, two other new guys)
02:56:25 <shapr> Hiya Itkovian!
02:56:29 <Itkovian> hi shapr
02:56:30 <boegel> I chose myself, right behind Stijn
02:56:32 <Itkovian> long time
02:56:36 <Itkovian> ok
02:56:47 <shapr> Were you on vacation?
02:56:52 <Itkovian> that will be a quiet office, good to get work done
02:56:57 <boegel> Itkovian: are you coming back on Monday too ? I can't wait to hear the stories you promised me
02:57:02 <Itkovian> shapr: three weeks off, try to limit time online
02:57:08 <Itkovian> heh
02:57:12 <xerox> http://postsecret.blogspot.com/
02:57:13 <Itkovian> I'll be there on tuesday
02:57:20 <boegel> Itkovian: yeah, but I think I'll put on some music using headphones, normally I work better with music
02:57:40 <boegel> oh yeah right, you work at home on Monday
02:59:26 <shapr> I gotta try that offline vacation thing too.
02:59:45 <boegel> shapr: it's great ! I didn't touch a computer in three weeks when I was on vacation
03:01:08 * Itkovian eats breakfast
03:01:13 <shapr> wow
03:01:17 <shapr> I'm not sure I could stand that.
03:01:26 <xerox> I'm sure you know!
03:01:39 <Itkovian> Well, I did have to wiork, cos I have an accepted paper that was due in its final version today
03:01:47 <Itkovian> didn't change a thing though, no time ;-)
03:02:13 <boegel> Itkovian: heh :) was it necessary to change stuff ?
03:05:53 * xerox ==> Reader Monad is unuseful
03:05:59 * boegel eats lunch (hmm, chicken and rice, rrrrrrrr)
03:18:08 <Itkovian> boegel: well, not really, but I'm not too happy with the article ... it's good, but it's hard to actually talk 20 minutes about it.
03:24:59 <boegel> Itkovian: for which conference is that ?
03:25:28 <xerox> If I yell "Reader Monad" what does come up in your mind?
03:25:51 <ski> variable environment ?
03:25:53 <Heffalump> passing information down
03:26:33 <xerox> Now, which simple application that needs it could you think of?
03:26:40 <boegel> xerox: TMR :)
03:26:52 <xerox> @tmrwiki
03:26:53 <lambdabot> Unknown command, try @listcommands.
03:27:35 <xerox> hmpf.
03:27:49 <ski> interpreter, maybe ?
03:28:13 * xerox adds "*" around "simple" :-)
03:28:22 <Itkovian> boegel: ASCAC
03:28:31 <ski> interpreters can be simple
03:28:46 <xerox> What could I "interpret" for test?
03:28:51 <boegel> Itkovian: and where/when ?
03:29:22 <ski> test ?
03:29:54 <xerox> I want to grok the Reader Monad.  The "All About Monads" part about it doesn't do the job for me :(
03:32:55 <Itkovian> boegel: singapore, october
03:32:56 <ski> hm, i guess for some cases where one can use reader monads, one can also use variable scoping (like in hawiki/WorkerWrapper)
03:33:33 <ski> so, part of the functionality is sortof built into the variable scoping semantics of the language
03:33:48 <boegel> Itkovian: wow, you're going to singapore then ? nifty ! :)
03:35:25 <xerox> hmm
03:35:41 <ski> possibly an ST-like reader monad could give better modularity, in some issues
03:36:42 <ski> also, it may be that a reader monad transformer can be more useful (e.g. you might not easily use plain variable scoping as a replacement atop some unknown or complex monad)
03:36:54 <ski> i guess i haven't thought so much about it
03:37:30 <lightstep> dynamic scoping!
03:37:36 <ski> yes
03:37:54 <lightstep> WorkerWrapper is about lexical scoping
03:38:15 <ski> yes, it's not completely similar
03:38:32 <xerox> Sob.
03:38:40 <ski> hmm
03:38:44 <ski> actually
03:38:55 <ski> i meant hawiki/AvoidingParameterPassing
03:39:15 <xerox> @wiki AvoidParameterPassing
03:39:16 <lambdabot> http://www.haskell.org/hawiki/AvoidParameterPassing
03:40:24 <xerox> I have some code I need to understand which uses the Reader Monad. I do need to grok it :(
03:41:14 <ski> if you look at remberWith/rember and evalWith/eval you'll see that i "rebind" things, a bit similar to what can be done with dynamic scoping (but not completely)
03:41:24 <ski> xerox : oh
03:42:00 * boegel decides to try and finish his HRay article
03:42:01 <ski> xerox : i thought you wanted examples of where it'd be advantageous to use ..
03:42:14 <ski> understanding it is simple
03:42:45 <ski> but, as lightstep said, i gives you a form of dynamic scoping
03:42:57 <xerox> I was trying to find an example to code to understand it.
03:43:14 <lightstep> which is the mechanism for implicit parameters
03:43:19 <ski> indeed
03:43:38 <xerox> OK
03:43:55 <lightstep> xerox, ReaderMonad passes an implicit state that is only changed in `local' blocks
03:44:54 <xerox> I think I understand it, you get a "getter" function for the "state"
03:45:00 <ski> i guess one reason reader monad examples often seems to be codable quite often without help of reader monad is that it's a quite benign effect  (as witnessed by having the more direct implicit parameters construct)
03:45:33 <ski> xerox : and you can locally replace the "state" (/environment)
03:45:45 <xerox> Now: how[interrobang]
03:46:03 <ski> 'interrobang' ?
03:46:27 <xerox> @wikipedia Interrobang
03:46:32 <lambdabot> http://en.wikipedia.org/wiki/Interrobang
03:46:58 <ski> hm, interesting
03:47:49 <lightstep> maybe i need an interromand instead of an exclamation
03:48:06 <lightstep> s/mand/bang/
03:48:09 * ski associates with exponentials in linear logic
03:48:42 <xerox> OK so "ReaderT r m a = (r -> m a)" ?
03:48:52 <ski> yep
03:48:55 <lightstep> yes
03:49:20 <lightstep> actually, types don't have equality, only isomorphism (quoting attansow)
03:49:45 <ski> :)
03:49:54 <xerox> How do you express types isomorphism?
03:50:36 <lightstep> i wish i knew
03:50:43 <xerox> ~= ?
03:50:51 <xerox> Anyway...
03:50:53 <ski> Atanassow
03:51:06 <ski> often ~=
03:51:07 <lightstep> whanks
03:51:14 <ski> in latex, a =  with ~ above
03:51:24 <xerox> ooh-kay...
03:51:33 <ski> more informally, one can use =, too (meaning iso, then)
03:51:56 <lightstep> \cong
03:52:14 <ski> (hm .. StateT s (Reader r) a  ~=  s -> Reader r (a,s)  ~=  s -> r -> (a,s) ..)
03:52:28 <lightstep> it's be fine if you overlayed = and ~ (at least in my font
03:52:56 <xerox> Then "o -> (o -> IO a) -> IO a  ~=  o -> ReaderT o IO a -> IO a" ?
03:53:15 <ski> (hm .. ContT o (Reader r) a  ~=  (a -> Reader r o) -> Reader r o  ~=  (a -> r -> o) -> r -> o ..)
03:53:26 <xerox> Hmpf, I don't get this "TypeT" types :(
03:53:44 <ski> xerox : yes
03:53:48 <xerox> Why there is "Reader" and "ReaderT" ?
03:54:07 <lightstep> ski, xerox, no
03:54:10 <ski> Reader is the monad, ReaderT is the corresponding monad transformer
03:54:17 <lightstep> -> is right-associative
03:54:23 <lightstep> oh, i misread
03:54:36 <xerox> ski, could you elaborate, please?
03:55:25 <ski> also  o -> (o -> IO a) -> IO a  ~=  o -> ContT a IO o
03:55:44 <xerox> Hmm.
03:55:53 <ski> often one want to combine effects of predefined monads into a new monad
03:56:29 <ski> one simple attempt to do this is like     newtype NewMonad a = NM (OldMonadA (OldMonadB a))
03:56:31 <lightstep> as if adding features to a language
03:56:44 <ski> i.e. just nesting monad constructors on top of each other
03:57:11 <ski> this doesn't work well for at least some monads (i.e. you don't get what you prolly want)
03:57:51 <ski> so, monad transformers are a way of having a monad sortof parameterized by an arbitrary monad
03:58:51 <ski> there has been some other ideas for combining monads too (i think there was a paper talking about taking coproduct of monads), but monad transformers are the way that is most thought out and used atm
03:58:59 <xerox> Reader r a
03:59:09 <ski> yes
03:59:20 <ski> Reader r a  ~=  r -> a
03:59:31 <xerox> Reader ~= ->
03:59:32 <ski> ReaderT r m a  ~=  r -> m a
04:00:18 <ski> State s a  ~=  s -> (a,s)
04:00:26 <ski> StateT s m a  ~=  s -> m (a,s)
04:01:05 <xerox> uhm uhm uhm
04:01:19 <xerox> I wonder if making them infix would help readability/understanding
04:01:21 <ski> note how the 'm' is spliced into 'the middle'  of the type, you can't achive this just by stacking monads atop each other  i.e.  'State s (m a)' or  'm (State s a)'
04:01:39 <ski> the transformers ?
04:01:44 <xerox> Yep!
04:02:21 <ski> anyway, a monad is a type constructor  m :: * -> *   with some operations
04:02:26 <lightstep> 2d notation is required, i think
04:02:31 <xerox> I mean, the isomorphism you just wrote are _really_ understandable.
04:02:48 <ski> anyway, a monad transformer is a type constructor  m :: (* -> *) -> (* -> *)   with some operations    so it transforms monads to monads
04:03:02 <ski> xerox : really ? :)
04:03:22 <xerox> I mean, "Foo a b" does mean "it's a type, blah blah"
04:03:32 <xerox> where "s -> (a,s)" means "more" to my eye
04:03:48 <ski> because you're used to what it means, i think
04:04:09 <xerox> It could be :-)
04:04:10 <ski> but, maybe one could have some sort of infix ..
04:04:23 * xerox bounces happily
04:04:48 <ski> anyway,  to be correct, e.g. 'Reader'  is *not* a monad,  'Reader r' is a monad !
04:05:12 <ski> Reader :: * -> * -> *
04:05:29 <ski> Reader r :: * -> *    (provided r :: *)
04:05:43 <ski> same with the monad transformers
04:06:46 <ski> so, first the type constructors often take some "private" arguments, like 'r' 's' 'o'  and then, for monads, it takes an 'a', and for monad transformers it instead takes a monad 'm' and finally an 'a'
04:07:14 <ski> that explains the order of the type arguments in e.g. 'StateT s m a'
04:07:22 <xerox> Indeed
04:07:45 <ski> but, e.g. list monad has no such private tyarg
04:08:00 <xerox> tyarg?
04:08:06 <ski> type argument
04:08:56 <ski> (btw, this also carries over to arrows and arrow transformers, except there, instead of final arg 'a' you have final args 'a' and 'b')
04:10:08 <xerox> If I would try making an infix counterpart of Reader/ReaderT, which [num] should I use in "infix [num] blah" ?
04:10:11 <ski> hm, (iirc)   Error e a  ~=  Either e a   and   ErrorT e m a  ~=  m (Either e a)
04:10:41 <ski> xerox : um, i dunno ..
04:11:02 <lightstep> xerox, i think the transformer itself should be infix, like ($)
04:11:18 <lightstep> so the `r' would be subscript
04:11:21 <xerox> lightstep, could you write an example?
04:11:40 <lightstep> @paste
04:11:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:12:12 <lightstep> but actually, ReaderT r m a = m R_{r} a
04:12:34 <ski> note that order of combining monad transformers is important
04:12:34 <lightstep> therefore, a computation with nondeterminism and state would be
04:13:02 <lightstep> hmmm
04:13:25 <ski> lightstep : s/R_{r}/`R_{r}`/ ?
04:13:36 <lightstep> yes
04:13:41 <lightstep> but it should be prefix anyway
04:13:56 <xerox> Why?
04:14:00 <lightstep> as in "S_{s} N IO a"
04:14:21 <lightstep> you can stack the transformers
04:15:07 <ski> StateT s (Error e) a  ~=  s -> Either e (a,s)     -- so this is a monad with state and exceptions/errors, in which if an error/exn is raised, then the state is lost
04:15:08 <lightstep> ski, why is the order important? i read somewhere that transformers should be designed to be uneffected by order. also, Reader,Writer,State commute
04:15:11 <xerox> I think it's too general for me.  I still can't understand it pragmatically, thanks anyway.
04:15:34 <ski> ErrorT (State s) a  ~=  s -> (Either e a,s)     -- so this is a monad with state and exceptions/errors, in which if an error/exn is raised, then the state is *not* lost
04:15:39 <lightstep> you take a base monad like Identity, IO or STM, and add capabilities
04:15:56 <lightstep> ok, i get it now
04:16:00 <ski> lightstep,xerox : there you have an example where order matters
04:16:55 <ski> btw,  of course  SomeMonadT Id a  ~=  SomeMonad a  should be true               with Id being the identity monad   data Id a = I a
04:17:29 <Itkovian> I'm off - going home ...
04:17:42 <Itkovian> ttyl
04:17:54 <Itkovian> gonna do a bit of gardening provided it doesn't rain
04:18:00 <xerox> They call me for lunch, thanks for the explanation, I'll have to reread it all :)
04:18:03 <ski> so    StateT s (Error e) a  ~= StateT s (ErrorT e Id) a   and    ErrorT e (State s) a  ~=  ErrorT e (StateT s Id) a
04:18:22 <ski> if we had an (.) operator on type level we could write
04:18:44 <ski> (StateT s . ErrorT e) Id a    and  (ErrorT e . StateT s) Id a
04:18:46 <pejo> xerox, that 'all aobut monads' is pretty good in explaining monad trnasforms imho.
04:19:19 <ski> (and you should see how to stack more monad transformers, now)
04:20:08 <xerox> I'm prolly in the wrong environmental condition to think.
04:20:18 <ski> mhm ?
04:20:46 <xerox> They make *chaos*disorder*noise* around me (i.e. preparing and eating lunch) :-)
04:20:54 <ski> aha :)
05:11:24 * vikasg wonders why there isn't a Scheme version of Parsec
05:14:21 <Philippa_> they probably have near-equivalents that don't use a monad
05:21:50 <basti_> hi
06:04:33 <poetix> Philippa_: re monad-based languages, see Frank Atanassow's reply to Peter van Roy on this LtU post: http://lambda-the-ultimate.org/classic/message9361.html
06:05:18 <poetix> The idea being that you start with everything in the identity monad, and substitute or layer in additional semantics as needed.
06:08:18 <Heffalump> that's all very well, but interpreting code in some monad requires enforcing ordering
06:10:07 <poetix> Sure, it wouldn't be the same as pure Haskell
06:10:44 <lightstep> some monads are lazy
06:12:01 <Heffalump> that doesn't help if you want to introduce side-effects like tracing
06:14:32 <lightstep> anyway, i don't understand the point. atanssow describes a haskell->haskell transformation based on monad transformers. but you can't stack them well: StateT T1 StateT T2 m a = StateT T1 m a, and you lost the compiler-inserted state
06:16:12 <Heffalump> you can stack them if you use private copies of each transformer
06:17:16 <lightstep> yes
06:54:39 <Philippa_> d'oh, he's gone
06:54:46 <Philippa_> suffice to say I had that thought myself a fair while back
06:55:51 <shapr> gwahr!
06:56:55 <xerox> Finally alone.  Now I can dig into this Monad Transformers (which names reminds me a toon I used to watch when I was a kid)
07:07:58 * shapr throws monads
07:08:29 <xerox> You ever throw those precious monads...
07:08:50 <shapr> Monads onna stick!
07:09:07 <xerox> Like soap+paper+water?
07:26:20 <ski> interesting LtU post ..
07:29:59 <lightstep> which?
07:31:50 <ski> http://lambda-the-ultimate.org/classic/message9361.html
07:31:58 <ski> (i.e. not a new one)
07:32:26 <lightstep> oh
07:32:33 <ski> i wonder if an effect system could be made to handle the issue ..
07:36:33 <Philippa_> yes, but you don't get anything you can't really do with monads
07:41:13 <TheHunter> that's the turing-completeness non-argument.
07:46:36 <megaman> hm, whats wrong with data Tree a = Nil | Node Tree a Tree
07:47:56 <TheHunter> you probably want data Tree a = Nil | Node (Tree a) a (Tree a)
07:48:41 <TheHunter> ie. a type argument needs to be applied to Tree on the right hand side.
07:48:58 <megaman> hm
07:49:39 <megaman> now, why can i do data Tree = Nil | Node Tree Int Tree but not data Tree = Nil | Node Tree a Tree ?
07:50:03 <lightstep> what's `a' there?
07:50:31 <megaman> type placeholder ?
07:51:01 <lightstep> what should be the type of the function `Node' ?
07:51:25 <megaman> Node Tree -> a -> Tree
07:51:29 <megaman> *::
07:53:35 <lightstep> when pattern-matching on that kind of tree, you will not know what type the pattern matches
07:53:39 <megaman> ah, do i need to do data Tree a = Nil | Node (Tree a) a (Tree a) so the whole tree has the same type of value ?
07:54:00 <lightstep> yes
07:54:21 <megaman> so, there's no way to do trees that can have mutliple types ?
07:54:31 <lightstep> if you want the tree to contain several types of nodes, there are ways to do that too
07:55:12 <lightstep> the easiest way would be with "existential types" (i don't know what the name means)
07:55:24 <megaman> and 'data Tree = Nil | Node Tree Int Tree' is short for data Tree Int = Nil | Node Tree Int Tree ?
07:55:48 <lightstep> basically, make a record Element = forall a. Element a (a -> Int) (some-other-methods)
07:56:03 <lightstep> megaman, no
07:56:04 <megaman> hm, i dont really want to do something like that, just trying to understand the data/contructor stuff
07:56:17 <lightstep> the first defines a monomorphic type
07:56:25 <lightstep> and the second defines a polymorphic one
07:56:39 <TheHunter> the second is not correct.
07:56:52 <megaman> hm
07:56:56 <lightstep> oh, my bad
07:57:43 <TheHunter> data Tree a = Nil | Node (Tree a) a (Tree a), data IntTree = IntNil | IntNode IntTree Int IntTree.
07:58:04 <TheHunter> here Tree Int is roughly the same as IntTree.
07:58:17 <integral> roughly?
07:58:18 <megaman> why would data Tree a = Nil | Node (Tree a) a (Tree a) work then, while data Tree Int = Nil | Node (Tree Int) Int (Tree Int) wont ?
07:58:29 <ski> Philippa_ : i think effect-systems can be more fine-grained than monads ..
07:58:39 <TheHunter> integral, trying to avoid the term 'isomorphic'
07:59:38 <integral> TheHunter: ah.
07:59:40 <ski> megaman : do you just want both e.g. integer trees and string trees .. or you want trees that can simultaneously contain both integers and strings etc ?
07:59:49 <frederik> when is ghc 6.4.1 coming out?
08:00:12 <megaman> ski: im trying to understand 'data', the trees are just an example
08:00:13 <ski> megaman : i.e. homogenous trees or heterogenous trees ?
08:00:25 <Philippa_> ski: yeah, I guess so. OTOH, a slightly extended monad signiature that allows a little extra type info to propagate'll work very nicely indeed
08:00:52 <Philippa_> (let the parameters for bind be in different monads related by some typeclass, that kind of thing)
08:01:37 <megaman> what exactly does the first a do in data Tree a = Node (Tree a) a (Tree a)
08:01:42 <megaman> ?
08:01:44 <TheHunter> Philippa_, it's theoretically possible, but you can't really code in this way, too much complexity.
08:02:07 <Philippa_> no more so than the effect system itself, no?
08:02:12 <megaman> thanks for all of your help btw ;)
08:02:23 <Philippa_> either way the effects're visible in the type
08:02:32 <xerox> megaman, creates a polymorphic type (over the type-variable a)
08:02:58 <ski> megaman : in 'data IntTree = Nil | Node IntTree Int IntTree' we are defining a tree type which can only contain ints .. while in 'data Tree a = Nil | Node (Tree a) a (Tree a)' we simultaneously defing a famility of tree types, so with this you can both use int trees of type 'Tree Int' and string trees of type 'Tree String' etc   (but all these trees are homogenous, that is, each tree can just contain values of one type)
08:03:26 <megaman> ah
08:03:54 <TheHunter> Philippa_, there's a big difference between only doing something at the type level and having to wrap/unwrap everything on the value level and using identity monads all over the place.
08:03:58 <ski> megaman : in practice, though, it gets tedious to say that we define a family of tree types with the latter declaration, so we just say that we define a parameterized tree type  (parameterized on the type of the elements)
08:04:22 <ski> (often omitting 'parameterized' even :)
08:04:24 <megaman> so general rule would be that i have to do data Name a = Constructor (Name a) if i want it polymorphic ?
08:04:34 <ski> megaman : yes
08:04:41 <Philippa_> TheHunter: you'd only have to do that once, when you introduced the effectful monad
08:04:44 <xerox> Why (Name a) ?
08:05:07 <megaman> xerox: to have a recursive structure ?
08:05:18 <xerox> data Foo a = Foo a -- is a polymorphic type
08:05:19 <ski> btw, the type is not polymorphic, it's parametric, but many functions that operate on such types can be polymorphic, so parametric types enable polymorphic functions
08:05:44 <megaman> pattern matching remains the same with both variants ?
08:05:52 <ski> lightstep : existential types are used to get heterogenous collections
08:06:08 <TheHunter> Philippa_, for one, you have to code everything in monadic style which is very painful.
08:06:28 <Philippa_> so how else do you plan to cope with these effects in Haskell, anyway?
08:06:39 <lightstep> ski, that was in response to "there's no way to do trees that can have mutliple types"
08:06:49 <Philippa_> (and no, you don't, you only have to write impure stuff that way - as ever)
08:07:03 <TheHunter> the whole thing is about some things not easily expressible in Haskell, isn't it?
08:07:31 <megaman> thanks for your help guys! [learning for an exam tomorrow ;)]
08:07:49 <Philippa_> yes. You can, of course, give up and go the ML route. That's been done already.
08:08:34 <TheHunter> well, you could go for an effect system that allows you to code monadic stuff in direct style.
08:08:36 <ski> megaman : the first 'a' is the parameter to the type  (just like 'x' is a parameter to the function 'f' in 'f x = x * x')  note that you can't patternmatch on arguments to parameterized types, you have to use a variable   (so 'data Tree Int = ...' is not valid)
08:09:03 <Philippa_> that doesn't solve sequencing
08:09:30 <TheHunter> what do you mean?
08:10:09 <Philippa_> I mean that we're not talking regions here, we're talking state and side-effects. How does your direct style + effect system allow you to sequence state operations?
08:11:18 <megaman> ski: yeah, that clearifies, thinking in terms of functions / parameters helps a lot :)
08:11:24 <TheHunter> http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters, section "A Lightweight Notation for Monads".
08:13:03 <ski> (TheHunter : i believe that uses unsafePerformIO, as well)
08:13:12 <frederik> when!
08:13:19 <ski> (in an 'unsafe' way, i should add)
08:13:36 <TheHunter> ski, i'm not taking about my implementation here, this section is kinda a proposal.
08:14:37 <Philippa_> TheHunter: I don't see how that solves it from that section alone - will reading the rest of the article illuminate me? Or is the point turning previously-pure code into monadic code?
08:15:07 <TheHunter> the point is writing monadic code in direct style.
08:16:00 <Philippa_> which that section doesn't appear to actually demonstrate at all, because none of the example code makes use of a monad-specific effect
08:16:31 <Philippa_> I actually can't tell from the code how I'd write set-then-get
08:16:51 <TheHunter> 'foo' uses a list-monadic effect.
08:17:30 <Philippa_> which is another way of saying it has a trivial non-monadic implementation. How would I do IO?
08:17:56 <Philippa_> all you're showing is the equivalent of bind and return
08:19:15 <TheHunter> reify (reflect (print "A") `seq` reflect (print "B")) would print "A", then "B".
08:19:42 <ski> TheHunter : another issue is establishing valid ways of reasoning about monadic code in direct style (especially in a call-by-name or call-by-need language as opposed to plain monadic reflection in call-by-value languages)
08:20:18 <Philippa_> TheHunter: *yuck*. seq in place of >>, fair enough, but really that's going to be far more painful than my scheme for code that actually makes use of stuff
08:21:26 <TheHunter> if you like, you could also use a call-by-value reflection (maybe that's what I intended, as it's foo's translation).
08:23:13 <xerox> TheHunter, what is "=>" in "<m> => a" ?
08:23:21 <TheHunter> Philippa_, your sceme is less composable.
08:23:27 <TheHunter> xerox, that's not haskell syntax.
08:23:36 <Philippa_> TheHunter: in what regard?
08:24:19 <TheHunter> you have to write everything in monadic style if you want composability as in PVR's example.
08:26:20 <Philippa_> yup, sadly. Cue usual argument about treating pure code as code in Identity then parameterising on the monad where there's no good cause not to, etc etc etc
08:26:20 <ski> TheHunter : hm, it seems to me using your style basically converts haskell to an impure lazy language .. so how to keep the referentially transparant parts of the program that way ?
08:26:21 <TheHunter> as you can see, it's not at all a well-thought-out translation, merely something to think about.
08:26:38 <TheHunter> but i think it's necessary.
08:26:57 <Philippa_> more importantly, I suspect PVR wouldn't complain at writing everything in monadic style so long as he's not forced to use the same monad everywhere
08:27:41 <Philippa_> (and it's not /everything/, just everything that uses operations within your own system - you don't need to start turning old pure code into monadic code)
08:28:51 <TheHunter> you have to rewrite modules B,C and D.
08:29:23 <Philippa_> only if you didn't slap a monad, any monad, in place at the start
08:29:33 <ski> in PVR's example, if the IE1 interface of E only writes state and doesn't return things which depend on it (which i think was the intension), then one way would be to make A belong in IO monad and attribute it's knowledge of the state (which might be changed differently depending on ordinary declarative optimisations in module B - D) and the (don't care) nondeterminism that result .. attribut that to the IO monad
08:29:45 <TheHunter> ski, maybe the type should also reflect if it should be cbv, cbn or cbn.
08:29:56 <ski> perchance
08:30:12 <Philippa_> my vote, FWIW, goes to the "find a way to interpret all pure code monadically when desired" solution
08:30:44 <ski> Philippa_ : that leaves the question of cbv or cbn ..
08:30:55 <TheHunter> that's not that far away from my suggestion.
08:31:12 <TheHunter> *"suggestion"
08:31:15 <Philippa_> ski: determine that on a per-monad basis, then have type classes usable for those functions that care which
08:31:23 <frederik> what is a cpo? what is an omega-cpo? etc.?
08:31:53 <ski> as i see it, if we want to still be able to do declarativeness-dependent optimisations, then don't care determinism will result when we depend on the state updated by operations in E
08:31:58 <Philippa_> TheHunter: I'd rather do that part on a fundamental language level, avoiding the reflection and reification
08:32:08 <ski> i.e. we not only have state effects in A
08:32:38 <ski> Philippa_ : hm, .. maybe
08:33:37 <Philippa_> then similarly a way to type the fact code doesn't side-effect itself (only the caller) would let you retain a lot of useful optimisations. Think exceptions, only not
08:33:41 <ski> frederik : cpo is complete partial order, iirc  (so the cpo there could prolly be a category of such complete partial orders together with suitable homomorphisms preserving the structure in some way)
08:34:00 <TheHunter> Philippa_, if you can interpret pure code monadically, you already can do something similar to reflection and reification.
08:34:11 <ski> Philippa_ : hm .. explain 'only not' ?
08:34:13 <Philippa_> TheHunter: fine by me :-)
08:34:21 <Philippa_> ski: no "ohcrap, abort all execution!" :-)
08:34:41 <ski> partiality/error then, not (catchable) exception ?
08:35:09 <Philippa_> not catchable-from-within-own-monad exception. I'm thinking the way pure code can raise some exceptions catchable from IO
08:36:09 <ski> Philippa_ : but can't you just escape the monad and enter it again, then ?
08:36:28 <ski> or you want to disallow that maybe similar to ST (if it's possible) ?
08:36:53 <Philippa_> you'd lose the monad's "internal state" when you did that. If there're things tied to it ala ST then you'd have to use the same technique
08:37:28 <TheHunter> ski, hmm, maybe general recursion could be eliminated and non-termination introduced in monads - different ones for cbv, cbn, etc.
08:37:33 <ski> Philippa_ : anyway, that pure code raising exception cathable in IO is another instance of what i mentioned above (there attributing don't-care nondeterminism to IO)
08:38:01 <ski> (well, just recalled that such exceptions also invoke don't-care nondeterminism :)
08:38:08 <frederik> ski: hmm, i guess i was looking for a simple definition of complete partial order but maybe there isn't one. i'm reading wikipedia now
08:38:20 <Philippa_> ski: I know. I'm just saying if you have a type-level way of indicating it's there rather than a do-care form then you get to do good things
08:38:36 <Philippa_> TheHunter: the Epigram folks've been thinking thoughts like that
08:38:47 <Philippa_> I really do need to sit down with Conor and Thorsten sometime
08:38:52 <Philippa_> I mean, they're only a mile up the road
08:39:06 <TheHunter> it makes even more sense in epigram.
08:39:11 <ski> TheHunter : mm, though nontermination is a very weak effect (it's not observable) ..    (hm reader/environment is a quite weak effect, too)
08:39:34 <ski> frederik : i don't know the details, sorry
08:39:50 <Philippa_> you can observe that something hasn't terminated from an IO monad or bastard child thereof, though
08:39:51 <TheHunter> and i've been thinking, if you don't have nontermination, you can get away with a reference-counting gc, do destructive updates etc.
08:40:33 <ski> Philippa_ : yes, attributing various effects to more or less the ultimate monad, IO, is not so rewarding
08:41:26 <ski> TheHunter : hm, destr. updates how ?
08:41:28 <Philippa_> I was more thinking of the fact that from the IO monad you can do stuff like add a timeout
08:41:40 <ski> ok, :)
08:42:09 <Philippa_> I'd still want a non-termination monad, the idea being that I'd end up writing some action that took a potentially non-terminating func and a time...
08:42:33 <xerox> For what purpose?
08:42:40 <xerox> (If I could ask)
08:42:55 <Philippa_> the IO monad's the effect equivalent of Object, the fun's in dividing up all the things you can do from it
08:43:05 <TheHunter> ski, if you know you're just destroying the last reference of something, you can update it with something else right away. I don't know how hard it would be to find something suitable for a destructive update but it should be far easier than with a usual gc.
08:43:38 <ski> i was referring to : embedding an effect in a monad is one thing .. finding a way of expressing what you want without having to reason in monads (efficiently thinking inside an effectful category, which is 'embedded' into the effectless one through the monad) is better
08:43:40 <Philippa_> xerox: "the typechecker's been running for 27 hours now, just kill the bastard!" and so forth
08:44:10 <xerox> <grin> hack & fun
08:44:30 <Philippa_> xerox: yes, though I suspect there're much better examples for the same ideas
08:44:54 <Philippa_> in fact, one amounts to yampa driving IO :-)
08:45:22 <Philippa_> ski: by and large keeping out all the other stuff you can do in code, kind of thing?
08:46:21 <ski> TheHunter : aha, you mean like that ..
08:47:19 <ski> (TheHunter : though refcount systems are a bit inefficient as GC, i've heard .. 'cuz you have to do chacks and stuff on each access)
08:47:54 <Philippa_> heh, I'm reminded of some thinking I did on a regionified IO monad - the basic idea was that when you used return it did the equivalent of a copying collector on the space that one func took up then all storage within the monad is managed more explicitly
08:48:32 <ski> hm s/efficiently/effectively/
08:49:37 <TheHunter> ski, i'm not sure how far you could go on infering statically how a function changes the ref-count of things.
08:50:00 <ski> Philippa_ : in a way monads are about (hm, rather can be used for) embedding impure things in a pure language, without polluting the pure stuff, and it does this quite good  (also allowing for userdefined effects/monads which is also good)
08:50:55 <ski> but, reasoning about STRef's in the ST monad in not so much better that using an impure language with state effects  (you still have aliasing etc ..)
08:51:01 <Philippa_> ski: that's one description of what we do with them, yeah. I tend to think about going a step further and using them to further categorise the spread of various kinds of impurity within impure sections
08:51:05 <Philippa_> sure
08:51:23 <Philippa_> OTOH, wrapping STRefs to create a unification monad? That's gold, that is
08:51:38 <xerox> Il "sections" a term which requires complex previous understandinds? :-)
08:51:51 <Philippa_> you can always generate a pile of specific, limited monads by wrapping a general one
08:51:52 <ski> so, in my mind, it's even better to have a more declarative way of achiving what one wants (if possible :)
08:52:20 <ski> xerox : 'sections' ?
08:52:21 <Philippa_> which in my mind means eliminating every single possible effect that you're not using. YMMV, of course
08:53:23 <xerox> ski, "using them to further categorize the spread of various kinds of impurity within impure sections"
08:53:41 <ski> but we also want compiler to be able to optimise code which uses these monads, and it might not understand that some effects in the representation monad is not used so are not actually effects in the ADT monad
08:53:50 <Philippa_> xerox: ah. When discussing monads I guess that means scopes, but it's meant informally
08:54:30 <Philippa_> ski: hand out a better set of compiler-implemented monads then
08:54:57 <Philippa_> ST rather than IO is a good example
08:54:59 <xerox> OK.  Note: I do neither understand the whole thing nor I'm arguing anything :-)
08:55:37 <Philippa_> xerox: consider a chunk of ST monad code that's called via stToIO
08:55:40 <xerox> I mean, sorry if I come up in the middle asking for explanation of terms, just trying to follow :)
08:56:02 <ski> Philippa_ : that needn't help with specific user monads
08:56:04 <Philippa_> you've got one "section" of code that only mucks around with references, and whose references die a death once that code's run
08:56:20 <Philippa_> ski: either those writing the compiler know what info's useful to it or they don't...
08:56:27 <xerox> @index stToIO
08:56:28 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
08:56:37 <xerox> @type Control.Monad.ST.stToIO
08:56:43 <lambdabot> forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
08:56:46 <Philippa_> xerox: think ST SomeConstType foo -> IO foo
08:56:47 <ski> anyway, i'm not complaining about what monads give, just that it needn't be the end say about declarativity for some cases
08:57:00 <xerox> Ah.
08:57:03 <ski> think of declarative concurrency e.g.
08:57:10 * Philippa_ nods
08:57:11 <ski> (as in Oz)
08:57:35 <Philippa_> there're cases where the lack of higher-order computations tells you a lot, if nothing else
08:57:46 <xerox> What's the difference between State and ST ?
08:57:55 <Philippa_> ST gives you a heap and references into it
08:58:12 <Philippa_> (IO has IORefs, too - would be neat if you could read IORefs from ST RealWorld)
08:59:18 <ski> xerox : State have just one anonymous state value, with ST you can dynamically allocate new cells
09:00:58 <xerox> ski, is ST s a translatable to "blah -> blah" (as we did with Reader/State this morning?)
09:01:18 <ski> xerox : think of a state monad that carries around a list of (say) ints, then you can make an operation that "allocates" a new cell by adding one element to the list, here STRef corresponds to indices into the list .. difference with ST is that you can allocate cells of any type you want, not just of a specific (possibly polymorphic over the monad, but still fixed over it) type
09:01:21 <Philippa_> xerox: yup, though you can't write a runST in Haskell itself
09:01:25 <TheHunter> Philippa_, shouldn't be too hard to implement: newtype IORef a = IORef (STRef RealWorld a)
09:01:50 <Philippa_> TheHunter: I know it's trivial :-)
09:01:54 <xerox> Philippa_, uh-oh - why?
09:02:07 <Philippa_> because you can have references of any type - the heap's polymorphic
09:02:40 <Philippa_> so you need a completely heterogenous collection with references into it that carry the type of whatever they refer to
09:03:08 <Philippa_> not too hard to hack up with the FFI, of course
09:03:37 <ski> possibly if we could have an extensible record type (in the sense that the exn excpetion type in SML is extensible, i.e. you can add new exception anytime .. so this is then an extensible variant type) we could code up ST
09:03:58 <Philippa_> well yeah, you could code up dynamic types too
09:04:01 <xerox> existentials?
09:04:16 <ski> this extensible thing /= existentials
09:04:19 <Philippa_> existentials aren't sufficient. You'd need to do type variable equality
09:04:30 <ski> i'm not sure about that
09:04:45 <ski> (i.e. the latter bit)
09:05:05 <xerox> I think I understand...
09:05:24 <xerox> A list of "ML's *" of the type of the thing and the thing ?
09:05:27 <Philippa_> ski: point, it's not as if the variables in the collection're being kept track of any more
09:05:44 <xerox> (or references to the things, whatever)
09:06:08 <ski> Philippa_ : with my idea they prolly would .. hmm  (or maybe not with optimisation ?)
09:06:12 <Philippa_> yeah. Well, what you /really/ want is to just convince it that the references're the only way to get things in and out and therefore it's okay to let them carry the type
09:06:34 <ski> (Philippa_ : assuming by 'keep track' you refer to GCing of cells ..)
09:06:36 <xerox> What is "it" ?
09:06:54 <Philippa_> the compiler
09:07:45 <Philippa_> really "the way" is to use unsafePerformIO and a coercion
09:07:59 <Philippa_> as the alternative involves some nasty dependant typing AFAICT
09:08:00 <ski> that's a possible actual implementation
09:08:06 <ski> (as in lowlevel)
09:08:13 <Philippa_> yup. Have a Ptr...
09:09:20 <ski> still interesting to see how to express it more properly, even if implemented that way   (e.g. to make similar but not same things yourself .. like defining user-monads instead on just being able to use built-in effects)
09:09:22 * xerox hits the head on the desk
09:10:04 <ski> (Philippa_ : my loose idea for a solution would not use dep. types i think)
09:10:22 <Philippa_> would it use one of the recognised means of faking them? :-)
09:10:44 <Philippa_> (I mean, usable dependant typing for a proper solution is equivalent to any other turing complete completely-static type system)
09:11:22 <xerox> I wonder why if I happen to understand this I can't use a Reader Monad, bah, I'll try again.
09:11:44 <Philippa_> know what you mean about expressing it in a non-IO fashion. Though sooner or later any effect you can actually implement is implementable in terms of the IO monad's effects for obvious reasons
09:12:01 <ski> Philippa_ : not that i know of  (but it would require typesystem extended with extensible record ;)
09:12:05 <Philippa_> the interesting bit's when you can have a runFoo func that has a more permissive return monad
09:12:32 <Philippa_> if you're trying to pass around the type of everything in the heap during typechecking, it won't work :-)
09:13:27 <ski> Philippa_ : actually, backtracking can be hard to do in IO  (hard to backtrack some hardware and physical reactions ;)
09:14:15 <ski> (hm, permissive as in less effectful ?)
09:14:46 <Philippa_> backtracking isn't just the one effect though - effectively it's parameterised on what you're backtracking
09:14:58 <Philippa_> (see the classic StateT List vs ListT State example)
09:15:01 <ski> (no, i wouldn't here pass around types at runtime)
09:16:05 <ski> hm, what's ListT now ?  (ListT m a ~= m [a]  or one where the m is interleaved with the consing ?)
09:16:35 <Philippa_> it's the ~ m [a] one
09:16:58 <Philippa_> 'cos when you run it, you get some form of m a out
09:16:59 <ski> (i.e. the other being  ListT m a ~= m (Maybe (a,ListT m a))  )
09:17:22 <Philippa_> ah. Meh, I'm thinking of the m [a] case, anyway
09:17:34 <ski> (hm, or maybe   ListT m a ~= Maybe (m (a,ListT m a))  )
09:17:35 <Philippa_> point is, the inability to backtrack some IO amounts to the nonexistance of IOT :-)
09:17:43 <xerox> I never understood the ListT thingie, how do you put many objects inside one of it?
09:18:40 <Philippa_> xerox: you don't, that's the point. You only put many of the results in
09:18:45 <ski> xerox : what do you mean ?
09:19:29 <Philippa_> that's why ListT State has one state and StateT List has one state per result in the list
09:20:05 <xerox> Maybe I'm misunderstanding what ListT is about.
09:20:18 <ski> Philippa_ : are you just commenting here on noncommutativity of the composition or more specifically about list and state ?
09:20:47 <Philippa_> ski: both at once, I guess
09:21:00 <Philippa_> the noncommutativity yields the explanation
09:21:30 <xerox> What could I read to understand this Monad Transformer thing?
09:21:45 <xerox> Haddock docs seems to be not enough for me now.
09:22:22 <Philippa_> there were a couple of papers on them
09:22:24 <xerox> What did _you_ read to understand it? :-D
09:23:00 <Philippa_> the responses I got to "I'm trying to do this with monad transformers and it's not working and fuckfuckfuckfuckfuck please somebody help me!" :-)
09:23:08 <fnord123> hi all
09:23:16 <ski> hiya fnord123
09:23:18 <xerox> Why did you know in first glance that you needed one? :-)
09:23:20 <musasabi> ListT is quite confusing - I always want [m a] instead of m [a].
09:23:23 <Philippa_> though I'd grasped the basic idea and the commutativity issues from the paper
09:23:36 <Philippa_> because I was trying to build a monad up out of stock parts, as it were
09:23:41 <fnord123> dons, are you active?
09:23:45 <ski> musasabi : sometimes you want interleaving ones ..
09:23:48 <Philippa_> musasabi: annoying, isn't it?
09:24:23 <musasabi> yes, but I am slowly starting to remember it (as soon as GHC nicely bangs it to my head).
09:24:24 <Philippa_> ooh, there's a thought, you can probably build the equivalent of STT List using a regioned ST-like monad
09:24:33 <ski> musasabi : incrementally doing effects, as you traverse list
09:25:03 <ski> Philippa_ : mhm ?
09:25:06 <Philippa_> (the intention of STT List is to have a separate heap for each path)
09:25:26 <Philippa_> (which means you need to type-tag each path separately, which looks a lot like regions to me)
09:25:29 * ski usually forgets which order means what, in stacking monad transformers
09:25:40 <musasabi> xerox: The nomaware tutorial is one possible source - but I didn't get the monad transformers thing the first time. After reading that - waiting a few days and looking at a real code I started to understand how it all worked.
09:25:51 <Philippa_> List at the bottom = many worlds for the effects stacked on top of it
09:26:04 <xerox> musasabi, I would be pleased to read real code too, probably, any pointers?
09:26:07 <Philippa_> yeah, the nomaware tutorial's probably the best you'll get to read
09:26:09 <xerox> real, even
09:26:28 <xerox> I couldn't figure out even the Reader Monad fron nomaware :(
09:27:11 <musasabi> xerox: many "real" apps use ReaderT/StateT Foo IO a (that seems quite simple to grasp).
09:28:08 <musasabi> Basically the reader monad is about passing some value through the computation implicitel.
09:28:08 * basti_ thinks reader isnt that hard 
09:28:19 <basti_> yes and you can "read" it
09:28:19 <musasabi> *implicitely
09:28:22 <xerox> I mean, I could understand your definition of it.
09:28:30 <Philippa_> there's even a use for a constant "state" monad transformer there - you'd use it to provide statically-known names for IORefs or STRefs
09:28:47 <xerox> But then I see the haddock docs, and think "how am I going to make use of this to do that?"
09:28:58 <wilx> Hah! We have monads in C++ too!!!
09:29:00 <wilx> http://www.cc.gatech.edu/~yannis/fc++/New1.5/lambda.html :D
09:29:17 <musasabi> xerox: hawiki has an example about using implicit parameters and reader for the same code.
09:29:40 <TheHunter> ime, you usually want |ReaderT (IORef s) IO| instead |StateT s IO|.
09:30:23 <xerox> "Temporarily changing the environment is like shadowing a variable and indeed carrying around the lexical environment is how Reader monads are used in denotational semantics."
09:30:31 <xerox> What does "denotational semantics" man?
09:30:37 <xerox> mean, sorry I can't type.
09:30:39 <Philippa_> TheHunter: agreed. Give or take making it a record full o' IORefs
09:30:40 <fnord123> it means calculus
09:30:46 <megaman> hm, to get the smallest elem of a list - what do i use? foldl (min) <?> l ?
09:31:02 <basti_> megaman: min l
09:31:03 <Philippa_> xerox: a denotational semantics is effectively a functional interpreter for a language
09:31:11 <basti_> @plugs min [3,4,1,2]
09:31:13 <Philippa_> it's a function from term to result
09:31:16 <lambdabot> <Plugins.Eval>:1:12:
09:31:16 <lambdabot>   No instance for (Show ([a] -> [a]))
09:31:16 <lambdabot>   arising from use of `show'
09:31:17 <megaman> basti_: of min is defined for lists ?
09:31:21 <ski> xerox : it a way of specifying semantics (i.e. meaning) to programs by mapping them to some mathematical object (usually functions)
09:31:21 <basti_> uhm
09:31:23 <basti_> wait
09:31:26 * basti_ looking up
09:31:30 <TheHunter> @plugs minimum [3,4,1,2]
09:31:32 <lambdabot> 1
09:31:46 <basti_> ahh
09:31:50 <basti_> yes.
09:32:27 <Philippa_> ski: that mapping being, unsurprisingly, a function ;-)
09:32:27 <basti_> @plugs foldr min 100 [1,2,5,1]
09:32:29 <megaman> ah, doh
09:32:30 <lambdabot> 1
09:32:35 <basti_> this works too, but its ugly.
09:32:35 <Philippa_> but yeah
09:32:43 <megaman> right besides min, which i just looked up. thanks ;)
09:32:48 <ndm> @plugs foldr1 min [1,2,5,1]
09:32:49 <xerox> @plugs foldr1 min [3,4,1,2]
09:32:50 <lambdabot> 1
09:32:52 <lambdabot> 1
09:32:53 <xerox> :-)
09:32:54 <ski> Philippa_: yes  (hm, maybe it can be other morphisms too ..)
09:32:55 <basti_> mmmh
09:32:57 <basti_> even better
09:33:12 <Philippa_> suffice to say that it doesn't take too big a leap of intuition to apply techniques from denotational semantics to structuring functional programs
09:33:35 <Philippa_> which is why Wadler's first monads paper didn't take too long after Moggi's, I guess
09:34:10 <fnord123> is there a ghc flag to strip preprocessor stuff like %comments, and \begin{code} ?
09:34:32 <ski> iirc monads were first applied (in CS) by using them in denotational semantics for imperative langs, and then people started using them in FP code :)
09:35:30 <Philippa_> ski: right, that's what Moggi's paper was about
09:35:33 <ski> yes
09:35:59 <ski> (just not sure if there was some other application in CS ..)
09:36:00 <Philippa_> 123: IIRC it just does it for .lhs files?
09:36:21 <xerox> How do you keep in mind that "Reader e a" is something with "->" inside ?
09:36:38 <fnord123> ski, yes but darcs compiles but i slip it into the build process of another project so i can reuse the modules and it give me a lexy error
09:36:59 <ski> xerox : mostly you don't. instead you "think inside the monad"
09:37:02 <fnord123> oh its on the #ifdef
09:37:29 <Philippa_> xerox: what ski said. You don't /care/, it's the type of the runReader func (or whatever it's called) that you care about
09:37:49 <ski> xerox : just like you usually don't think about passing around a state "underneath" when manipulating pointers/references in imperative langs
09:37:50 <Philippa_> runReader + a Reader + all the other parms to runReader = result
09:38:34 <TheHunter> not sure i'm agreeing with this. As soon as you're using transformers, you usually have to know that ReaderT r m a ~= r -> m a, etc.
09:38:58 <TheHunter> it's the only way to know for sure how the effects are mixed.
09:39:14 <ski> xerox : as Philippa_ said :)   and you just think about type of runReader func when you are interfacing the monadic code with other code (i.e. "starting up the monadic computation" or "extracting results from it")
09:40:25 <ski> so, most code to do with the Reader (or other monad) just works inside the monad so you just have to understand the effect/monad from within (intuitively)
09:42:08 <ski> TheHunter : not necessarily if you can attach a nice way of interpreting the transformer intuitively (so you keep track of which effect "has the final word" etc) .. though there's not necessarily *one* (useful) transformer corresponding to a monad (as list shows)
09:44:31 <xerox> Let me share my pain with you more...
09:44:40 <ski> ty :)
09:45:09 <TheHunter> ski, an intuitive understanding of transformers is hard to get (and i'm not sure it can cover all cases). Looking at the type of the monad is certainly easier to me.
09:45:14 <fnord123> how does ghc resolve c pre processor commands in lhs files? Do I need a flag? The docos don't seem to have any relevant information apart from 'give a file a .hs extension to run the cpp' -which i will do after the lhs is done processing into a .hs
09:45:33 <xerox> http://haskell.galois.com/~paolo/Render.hs
09:46:10 <xerox> type Render = ReaderT Cairo IO
09:46:31 <xerox> run :: Cairo -> Render a -> IO a
09:47:23 <xerox> I get in some way this is similar to:
09:47:36 <xerox> withCairo :: Cairo -> (Cairo -> IO a) -> IO a
09:48:09 <xerox> I can't get how exactly, tough...  I mean, if it's exactly the same, why write a ReaderT ?  If not, how does it differ?
09:49:35 <ski> maybe so to use specific properties / reasoning in Reader monad, instead of just having some random passing of arguments
09:49:56 <ski> a bit similar to why use foldr instead of explicit recursion
09:50:39 <xerox> Maybe it is more about...
09:51:23 <basti_> @pl makeTree x = mergeTrees $ map listToTree x
09:51:24 <lambdabot> makeTree = mergeTrees . map listToTree
09:51:26 <xerox> withHiddenCairo :: a -> (a {-> HiddenCairo} -> IO b) -> IO b  ?
09:51:31 <basti_> ah.
09:51:41 <xerox> Where the {} part is hidden ?
09:52:39 <ski> is that an actual function there ?
09:52:55 <xerox> No no, just me thinking O_o
09:53:39 <ski> your withHiddenCairo there seems more like it's trying to do CPS
09:54:02 <xerox> Blargh
09:55:35 * ski leaves computer for a while
09:56:12 <musasabi> If you have the reador monad inside a newtype then user code cannot obtain the Cairo inside the monadic code.
09:56:32 <musasabi> Which should make it possible to use only one Cairo at a time.
09:57:07 <xerox> musasabi, ah, do you remind the "one cairo at time" problem?
09:58:44 <musasabi> yes
09:58:57 <xerox> It's not there anymore!
09:58:58 <lightstep> TheHunter, what is the advantage of Reader (IORef t) over State t?
09:59:10 <xerox> So I could avoid enforcing any policy of some such.
09:59:30 <lightstep> after all, with State you have `put' and `update'
09:59:57 <TheHunter> lightstep, the difference is how it copes with exceptions.
10:00:40 <TheHunter> |modify (+1) >> throw "error"| will in fact leave the state untouched.
10:01:31 <musasabi> Good :-)
10:01:47 <musasabi> What did you do?
10:01:48 <lightstep> hmm. it seems that ghc authors went to great lengths lately to provide transactional semantics
10:01:54 <TheHunter> it's not usually what you want, though.
10:02:26 <xerox> musasabi, the cairo programmers fixed it :-D
10:02:36 <fnord123> so um, anyone know how to coerce the lhs processor to accept cpp directives?
10:02:52 <ndm> fnord123, have you tried hmake
10:03:00 <musasabi> That seems like the best possible solution :-)
10:03:20 <fnord123> no im merging two projects. one uses extensive use of lhs files. the other doesnt
10:03:55 <xerox> musasabi, indeed.  I have to think of an Haskellish interface, tough.
10:04:33 <ndm> fnord123, is there not one tool hpp and one called delit, one which handles cpp directives and one which strips out lhs comments?
10:05:08 <ndm> if you compile with hmake it takes care of preprocessing and literate removal automatically before compiling
10:05:39 <TheHunter> lightstep, also, a ReaderT (MVar t) IO can be used concurrently.
10:08:10 <fnord123> i dont seem to have hmake
10:09:50 <lightstep> TheHunter, i prefer the other default. but it's good to know the difference between the two forms
10:09:56 <Lemmih> fnord123: Pass -cpp to GHC.
10:11:45 <fnord123> i tried that but it doesnt seem to work
10:13:11 <Lemmih> It should work.
10:15:16 * basti_ refactors his completion interface
10:15:49 <ndm> fnord123, are you using linux?
10:16:02 <ndm> http://haskell.org/hmake/
10:16:07 <fnord123> osx
10:16:23 <ndm> hmake works fine on osx, its a really useful way to build haskell programs
10:16:28 <ndm> much better than ghc --make
10:16:39 <Lemmih> Still, use Cabal if you can.
10:17:46 <fnord123> arse. maybe i should refactor this all so i have a .a coming out of my underlying project and the one im trying to utilise that one should just link.
10:18:07 <fnord123> but i dont see how that gets done in haskell. i dont have an example of a multi lib project
10:19:52 <pejo> Speaking of Cabal, I read the Visual Haskell article by Simon Marlow and some intern that I've forgotten the name of. It cited an article about Cabal by I. Jones which was submitted to some Haskell Workshop. Anyone happen to know if it is online somewhere?
10:20:44 <Lemmih> fnord123: Read up on Cabal. It most likely does exactly what you want.
10:21:34 <xerox> ‽
10:22:14 <Igloo> xerox: ?
10:22:23 <xerox> @wikipedia Interrobang
10:22:24 <lambdabot> http://en.wikipedia.org/wiki/Interrobang
10:22:35 <xerox> It's today's puntuation mark.
10:22:41 <Igloo> That wasn't a UTF-8 interrobang
10:22:50 <xerox> Unicode
10:23:00 <xerox> ‽ ?
10:23:08 <Igloo> That's better
10:23:12 <fnord123> i saw the interrobang. my client is utf-8 compliant
10:23:25 <basti_> @pl obvious' t s = obvious $ complete t s
10:23:25 <Igloo> fnord123: The first time? Or just the second?
10:23:26 <lambdabot> obvious' = (obvious .) . complete
10:24:00 <xerox> @eval let ‽ = 1 : 1 : zipWith (+) ‽ (tail ‽) in take 10 ‽
10:24:02 <lambdabot> 23: lexical error
10:24:05 <fnord123> the first
10:24:05 <xerox> ^_^
10:24:51 <Igloo> You'd need (‽) and a unicode-compliant impl
10:25:26 <fnord123> im in favour of bringing back the thorn
10:25:34 <xerox> It would be cool.
10:25:56 <xerox> Igloo, how do you write unicode things?
10:26:02 <xerox> (except from copy&paste .-))
10:26:17 <Igloo> I write them by copy and paste  :-)
10:26:34 <Igloo> Well, and a few keys set up in irssi so I can ♥ ♫ ☻
10:27:03 <Igloo> I don't have any real need for unicode beyond that, so have had no incentive to even get a compose key working
10:27:13 <pejo> Igloo, what characters are those last ones?
10:27:22 <xerox> Sweet Note Smiley
10:27:22 <threeve> wow, have people really been talking about Interrobang for 9 hours?  :)  the last thing when I left was xerox mentioning that...
10:27:29 <Igloo> Heart, musical notes, smiley face
10:27:37 <xerox> threeve, it's the new hype!
10:28:17 <Igloo> Actually, I did want to type a copyright character earlier today. But I solved that by not bothering.
10:28:55 <ndm> ©
10:29:02 <ndm> Alt+0169 under Windows
10:29:02 <xerox> On my keyboard I can do it with AltGr+Shift+c
10:29:03 <xerox> ©
10:29:40 <threeve> option+g on the mac
10:30:28 <xerox> afk, bbiab
10:30:49 <fnord123> þe þorn is from middle english and was phased out because german character sets for printers didn't have þis letter. so they used y as a replacement and so you see þe signs for old shoppes written as ye olde blah blah instead of þe olde shoppe
10:31:12 <Igloo> Oh, AltGr+Shift+c seems to work here too. I wonder if that means it's a compose key
10:31:14 <xerox> łøł
10:32:08 * Igloo fails to get it to give me an e-acute in any obvious way, though
10:32:40 <ndm> i am trying to code up a library for regular expressions
10:32:53 <ndm> and some of the things only apply to non-deterministic stuff, some to all
10:33:09 <ndm> so i need a function "foo" that handles different types differently
10:33:17 <Igloo> Can you give an example?
10:33:26 <ndm> trying to think of a good one...
10:33:41 <Beelsebob> neil: what's wrong with type classes then?
10:33:43 <ndm> ok: you want to convert a finite state machine to a regular expression
10:33:49 <ndm> beelsebob, i will get to that :)
10:34:02 <ndm> hence type of :: Machine a -> RegExp a
10:34:16 <ndm> and also for non-deterministic machines, you have Machine (RegExp a)
10:34:27 <ndm> so Machine (RegExp a) -> RegExp a is handled differently
10:35:03 <Igloo> Oh, I assumed you were making matchers from REs
10:35:06 <ndm> fsaToRegExp = fsaToRegExp[non-determinstic] . makeNonDeterministic
10:35:12 <ndm> not quite
10:35:18 <Igloo> Type classes are what you probably want, anyway
10:35:20 <ndm> igloo, but i am in other parts of the library
10:35:29 <Igloo> You might need overlapping instances depending on what exactly you're trying to do
10:35:43 <ndm> yes, but i don't want to have separate type name for nd-machines
10:35:54 <ndm> and i am trying to avoid overlapping instances, and anything non-haskell98
10:36:07 <Beelsebob> hehe, go go nhc :)
10:36:18 <Igloo> If the types are the same then you'll need to call different functions
10:36:19 <ndm> apparently nhc has them, or tom thinks so
10:36:34 <ndm> yeah, thats what i do now - just wondering if there was any way to avoid it
10:36:37 <xerox> Igloo, what's e-acute?
10:36:58 <xerox> ê ?
10:37:06 <Beelsebob> that's an e-hat
10:37:09 <Beelsebob> é
10:37:35 <xerox> é ?
10:37:41 <xerox> shift+è here.
10:37:53 <Beelsebob> shift-e, then e again on a mac
10:38:00 <Beelsebob> sorry... alt-e then e again
10:38:12 <fnord123> e-hat is e-circumflex
10:38:18 <Beelsebob> ó alt-e then o, ú alt-e then u.....
10:38:19 <xerox> AltGr+e is € here
10:38:50 * Igloo doesn't have a è key
10:39:10 * Beelsebob wonders how to type that...
10:39:12 <Beelsebob> è
10:39:14 <Beelsebob> ah... like that
10:39:21 <Beelsebob> alt-` then e
10:39:36 <fnord123> ∑e-3
10:40:00 <Beelsebob> 龤?
10:40:03 <Beelsebob> hehehehe
10:40:17 * Beelsebob wonders how many PCs displayed that correctly
10:40:26 <Igloo> altgr-' e gives me ê, altgr-/ e gives me ẹ, alt-gr-# e gives me è and that's all I found
10:40:26 <fnord123> mine did
10:40:47 <fnord123> how do you type chinese/kanji?
10:41:11 <Beelsebob> fnord: either you change the keyboard layout to chinese, or you load up the character pallete
10:41:11 <fnord123> 
10:42:23 <Beelsebob> ∀x s.t. x ∈ letters . display(x, OS X)
10:42:25 <Beelsebob> *g*
10:44:07 <xerox> Beelsebob, nice, I saw that.
10:44:26 * basti_ didnt
10:44:33 * basti_ frowns
10:44:36 <Beelsebob> hehe
10:44:38 <xerox> I'm using ERC Version 5.0 (CVS) $Revision: 1.761 $ with GNU Emacs 22.0.50.1 (i686-pc-linux-gnu, GTK+ Version 2.6.4, built 2005-03-16)!
10:44:57 <Beelsebob> basti: windows?
10:45:12 <Igloo> xerox: commiserations
10:45:17 <Beelsebob> I don't think windows has fonts with much more than ASCII in
10:45:18 <xerox> Igloo!
10:45:26 * Beelsebob sides with igloo
10:45:42 <xerox> :(
10:46:00 * xerox stands with the "Go Emacs! (until Yi)" banner
10:46:03 * Igloo sets the holy war mode from unicode to editors  :-)
10:46:14 <Beelsebob> haha
10:46:27 <Igloo> (not that we had someone standing up for latin-1 before anyway)
10:46:34 * Beelsebob notes that all editors under OS X get unicode free
10:47:33 <basti_> Beelsebob: no, "terminus" font
10:47:44 <basti_> not many non-human language chars in there
10:47:56 <xerox> Igloo, but Emacs does support UTF-8, as far as I tried...
10:47:56 <ndm> i'm using windows and saw all those characters
10:48:05 <ndm> i have lots of fonts with full-unicode support
10:48:08 <Beelsebob> ah, okay... mathematical ones are in 90% of fonts in OS X
10:48:15 <Igloo> xerox: I wasn't being serious  :-)
10:48:20 <Beelsebob> there's even about 8 fonts for chinese
10:48:31 <ndm> MS Arial Unicode has every single font point defined by unicode consortium with an appropriate glyph
10:48:45 <Beelsebob> :) cool
10:48:58 <Beelsebob> I've never seen windows standard install able to deal with that
10:49:07 <Beelsebob> it usually just displays a series of boxes
10:49:07 <ndm> ah, not a standard install :)
10:49:21 <ndm> but from XP onwards, it has pretty good standard support for unicode
10:50:08 <Beelsebob> is there a good way of entering them?
10:50:23 <ndm> if you know the unicode escape sequence, yes
10:50:31 <Beelsebob> lol
10:50:39 <ndm> ø
10:50:43 <ndm> ê
10:50:54 <ndm> hold down alt and type in the 4 digit code
10:51:03 <Beelsebob> so there's no equivalent of this then? http://www.cs.kent.ac.uk/people/rpg/tatd2/nice.png
10:51:06 <ndm> or you can use charmap, but thats not a "good" way of entering them
10:51:29 <ndm> no, nothing that nice
10:52:28 * Beelsebob runs away to a bbq
10:52:30 <Beelsebob> see you later
10:52:42 <ndm> bye, and i now run away for food as well i think
10:53:26 <xerox> wöööm.
10:53:51 <xerox> ŵ <- what is it?
10:54:27 <TheHunter> w + ^
10:58:53 * xerox yells さようなら
10:59:08 * basti_ also yells
10:59:13 <xerox> :-P
11:07:43 <Heffalump> well that was fun (/me returns from trying to persuade my colo machine to run a 64 bit kernel)
11:58:41 <threeve> I'm looking at "A Gentle Introduction to Haskell".  Is that a good a place to start ?  I plan on ordering the School of Expression book too.
11:59:10 <autrijus> threeve: http://www.isi.edu/~hdaume/htut/ is easier.
11:59:23 <autrijus> http://www.haskell.org/~pairwise/intro/intro.html and     http://conal.net/pan/haskell-primer.htm
11:59:27 <autrijus> is good too.
11:59:31 <autrijus> the "gentle" isn't really.
11:59:38 <autrijus> I mean, isn't gentle, not it isn't good
11:59:46 <threeve> autrijus: thanks for the pointers :)   any thoughts on the book?
11:59:57 <autrijus> threeve: http://svn.openfoundry.org/pugs/READTHEM
11:59:58 <autrijus> enjoy :)
12:00:11 <threeve> great!  thanks
12:53:28 * boegel yawns
12:54:39 <Itkovian> evening
12:55:39 <boegel> hellow
12:55:44 <boegel> how was the garden ? :)
12:58:40 <Korollary> ok, LtU is a scary place right now
12:59:39 <boegel> Korollary: why ? :)
12:59:54 <Korollary> Ehud is on vacation !
12:59:59 <Korollary> threads are running wild.
13:00:58 <boegel> heh
13:01:14 <boegel> I'm not that familiar with LtU, but I get your point
13:02:56 <Korollary> I don't like it when threads turn into too much anecdotal evidence and opinion.
13:03:23 * boegel -> tv
13:04:03 * Korollary -> Internet -> m Couchpotato
13:28:54 <Heffalump> why does apt-get instal ghc6 on sid say that it's uninstallable because libgmp3-dev is not going to be installed?
13:31:31 <musasabi> Heffalump: you can use the haskell-unsafe repository.
13:31:56 <musasabi> deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable
13:32:47 <Heffalump> umm. That doesn't alter the fact that this shouldn't be happening :-)
13:33:33 <Heffalump> especially since it still happens after I've actually installed libgmp3-dev
13:36:27 <Igloo> It'll be uninstallable until 6.4.1 comes out
13:37:51 <Heffalump> ah. what happened?
13:38:27 <User666> http://www.damochka.org/download-video.php?videos=42823
13:38:27 <User666> http://www.damochka.org/download-video.php?videos=42823
13:38:42 <Lemmih> *sigh*
13:39:22 <Igloo> The library name changed as it was bundled with a C++ library
13:39:43 --- mode: ChanServ set +o Igloo
13:40:34 --- mode: Igloo set +b *!~zapoopirk@gw5.m-lan.ru
13:40:48 --- mode: Igloo set -o Igloo
13:41:09 <Heffalump> ah, right.
13:42:31 * Heffalump cunningly installs libgmp3-dev from etch and makes the world right again
13:45:11 <xerox> What is etch?
13:45:55 <Igloo> Debian testing
15:07:26 <fnord123> in ghc, if im linking to something in a .a library, how can i declare that I am to use something in a library? import doesnt seem to work nicelyl
15:08:01 <xerox> Through the FFI?
15:09:43 <Lemmih> fnord123: 'import' is only for Haskell modules.
15:09:52 <fnord123> oh i see
15:09:54 <fnord123> crums
15:10:42 <Lemmih> Use the FFI if you want access to foreign languages.
15:11:28 <fnord123> no i want to access another haskell project
15:11:59 <Heffalump> did you make a package for the .a thing?
15:12:05 <fnord123> no
15:12:39 <fnord123> im not familiar with haskell packages and was looking for the best way to have multiple projects in the same overriding project
15:13:22 <Lemmih> Use the source or make a Cabal package.
15:14:52 <fnord123> ok and if i make a cabal package then i will be able to easily import my symbols into another haskell project?
15:15:09 <Lemmih> Yes.
15:16:00 <fnord123> are you sure? these are kinda big projects and i dont want to faff about anymore (I'm tired of make systems. I want to get back to features coding)
15:16:55 <Heffalump> if they just consist of Haskell code and you aren't doing anything complicated with language extensions, it will be easy
15:17:13 <Heffalump> s/language extensions/language extensions or preprocessing/
15:17:27 <fnord123> lots of lame preprocessing
15:17:33 <Heffalump> by what?
15:17:39 <fnord123> cpp
15:18:12 <Heffalump> I think that should be fine. Are you using ghc -cpp or running cpp manually?
15:19:09 <fnord123> ghc -cpp; I had to make some file changes since {- \n #def blahblah \n #def blahblah -} was being picked up as a cpp macro
15:20:47 <Heffalump> I can't remember the 'right way' to tell cabal about that, but I know it's possible.
15:20:56 <musasabi> Extensions: CPP
15:21:02 <musasabi> or something like that.
15:26:50 <Lemmih> Cabal is pretty good at handling preprocessing.
15:27:14 <Lemmih> If there's something it can't handle please mail libraries@ about it.
15:29:15 <musasabi> Is there a way to get the version of the package in the postBuild hook in Cabal?
15:34:34 <fnord123> is cabal built into ghc or was this one of the projects i downloaded only to find it didnt work on osx. there were a lot, so i forget which didnt work :-/
15:35:15 <Lemmih> fnord123: GHC >=6.4 ships with Cabal.
15:35:28 <fnord123> k
15:47:39 <fnord123> theres also generated files based on ./configure
15:48:29 <Heffalump> Cabal automatically runs that if its present (which is something of a misfeature, IMO)
15:48:42 <Heffalump> you don't need to use cabal itself to build a package, btw.
15:49:21 <xerox> For the HaskellGoGuys, there is the US Masters game live replay on KGS (first game, the one beloning to wms) :-)
15:49:25 <Heffalump> just building a .a file and making a text file with the right information is good enough
15:50:13 <Heffalump> running "ghc-pkg describe parsec" should give you an example of the text file
15:51:46 <Lemmih> Heffalump: Cabal only runs the configure script if you tell it to.
15:52:21 <Heffalump> lemmih: oh, I thought it did it by default.
15:52:26 <Heffalump> I don't remember telling it to do so
15:53:01 <Heffalump> in fact, my current project definitely doesn't seem to tell it to do so explicitly anywhere.
15:53:21 <Lemmih> What does your Setup script look like?
15:53:38 <Heffalump> > main = defaultMainWithHooks perlhooks
15:53:44 <Heffalump> > perlhooks = defaultUserHooks
15:53:45 <Heffalump> >                {
15:53:45 <Heffalump> > --                 hookedPreProcessors =
15:53:45 <Heffalump> > --                 hscp2hscHook:hookedPreProcessors defaultUserHooks
15:53:45 <Heffalump> >                   preBuild = doPreBuild,
15:53:47 <Heffalump> >                   preClean = doPreClean
15:53:49 <Heffalump> >                }
15:54:03 <Heffalump> neither preBuild nor preClean runs configure
15:56:08 <Lemmih> defaultUserHooks does.
15:56:21 <Lemmih> Overwrite the defaultPostConf if you don't want it.
15:56:28 <Heffalump> ah, right.
15:56:39 <Heffalump> still, I never explicitly asked it to :-)
15:56:47 <Lemmih> You probably want to use emptyUserHooks instead.
15:57:02 <Heffalump> I assumed that defaultUserHooks was what you get if you use the simplest Setup file
15:57:56 <Igloo> What's the rational for "default" to not match "simple"?
15:58:01 <Lemmih> User hooks are there to extend the simplest Setup file.
15:58:47 <Igloo> Is defaultUserHooks intended to be used with configure/make/make install build systems?
15:59:20 * Igloo can't actually think of a good name even if it is, though  :-(
16:00:12 <fnord123> Setup.hs: internal error: stg_ap_v_ret
16:00:19 <fnord123> Please report this as a bug to glasgow-haskell-bugs@haskell.org
16:00:26 <musasabi> fnord123: Mac OS X ?
16:01:27 <fnord123> yup
16:02:05 <musasabi> I think someone else (itkovian?) was having the same problem. That is related to ghc bug, not cabal.
16:02:32 <musasabi> you could try one of the 6.4.1 snapshots if it is fixed.
16:02:35 <Heffalump> what is it about OS X that causes these problems? I thought it was touted as being a decent UNIX.
16:03:02 <musasabi> Heffalump: not as much testing.
16:03:59 <musasabi> Generally on anything non-i386 non-linux you can have fun stuff which is mostly because there not enough people testing things on those platforms before releases.
16:05:15 <fnord123> Heffalump: haha
16:05:38 <Heffalump> I don't hear of much trouble with FreeBSD, though
16:06:02 <Igloo> It probably also has fewer users, though  :-)
16:06:07 <Igloo> Plus Simon M is one of them, I think
16:06:19 <Beelsebob> igloo: no, OS X has more users
16:06:26 <Igloo> That's what I said
16:06:37 <Beelsebob> oh, sorry, my brain twisted your words round  then
16:06:48 <Beelsebob> Simon Thompson uses a mac too come to think of it
16:07:49 <Beelsebob> It's also just different unicies have different little things about them... people often think if it works in linux it must be a true unix app
16:07:53 <Beelsebob> usually delusionally
16:09:02 <Heffalump> :-)
16:09:34 <musasabi> It is most often something quite easy to fix but simply no-one notices it until too late.
16:09:41 <Beelsebob> yeh
16:10:10 <Beelsebob> most annoyingly... ghc reports it's version as "#pragma somethingOdd\n\n604" on OS X
16:11:42 <fnord123> entirely delusionally. linux isnt unix
16:11:47 <Beelsebob> indeed
16:12:06 <Beelsebob> but that doesn't imply that all apps that work in linux are *not* true unix apps
16:12:50 <fnord123> obviously not
16:13:07 <fnord123> im sure everyone in this channel is well aware of basic sets and intersections
16:13:15 <Beelsebob> hehe
16:13:33 <Beelsebob> sorry... I'm used to trying to teach first years logic
16:14:00 <wagle> someone gave a talk, where at one point they put of a grid of 6 by 6 squares, and asked each member of the audience to count how many were colored red.  the results varied from about 12 to 23
16:14:20 <Beelsebob> heh
16:14:33 <Beelsebob> yes... because of all the odd intersections of squares
16:15:00 <wagle> no, some colors were red to some people, and not red to other people
16:15:19 <Beelsebob> haha
16:15:57 <wagle> now, which os's are unix, and which arent?
16:16:09 <Beelsebob> those certified as UNIX are UNIX
16:16:23 <Beelsebob> and to be certified you need to implement POSIX and then pay money
16:16:24 <fnord123> okey dokey well if this junk aint gonna work for me, hows about someone who is bored helps me set up a cabal package for darcs-1.0.4
16:16:28 <Beelsebob> linux has done neither
16:16:51 * wagle declares himself a CERTIFIED red determiner
16:16:56 <Heffalump> fnord123: as I noted above, you don't actually need to use Cabal to build a package of your library
16:17:19 <Beelsebob> OS X has not payed... but instead became UNIX though a legal disspute
16:17:39 <fnord123> paid
16:17:49 * Beelsebob lysdexic
16:18:00 <fnord123> dyslexic like an ephalent?
16:18:00 <Heffalump> IYM 'sysdeptic'. Yes.
16:18:07 <fnord123> byslexic, pardon
16:18:10 <Heffalump> hey, I resent that remark.
16:18:13 <Pseudonym> The colour that is red is not the true red.
16:18:19 <Pseudonym> If you meet red on the road, kill it.
16:18:31 <Heffalump> Elephants are very good at spelling.
16:19:28 <Heffalump> (being close cousins of Heffalumps and all)
16:19:41 <Pseudonym> But elephants don't steal honey.
16:19:56 <Beelsebob> they do if you feed it to them
16:19:59 <Heffalump> That's what you think.
16:20:03 <Pseudonym> That's not stealing.
16:20:05 <Heffalump> They're just better at hiding the evidence.
16:20:11 <fnord123> heffalumps aren't bouncy like tiggers
16:20:28 <Heffalump> they can be
16:20:30 <Beelsebob> yes... that's why they have to fall into the heffalump trap
16:20:37 <Beelsebob> they can't bounce out
16:21:03 <fnord123> hey this could be ganked for a yi icon: http://www.killermovies.com/gallery/poohsheffalumpmovie/poster.html
16:23:08 <Beelsebob> it's an upside down lambda
16:23:31 <Heffalump> cool.
16:24:24 <xerox> How is Heffalump related to Disney? :-)
16:24:56 <Beelsebob> it isn't
16:25:16 <fnord123> so i have a .a file... whats this text file you suggest I write? The .cabal?
16:25:43 <fnord123> didnt they buy all the rights to milnes works?
16:25:52 <fnord123> so they could rape it
16:26:56 <Pseudonym> They bought all the rights to Milne's works because Christopher Robin Milne wanted to distance himself as far as possible from them.
16:27:39 <Heffalump> fnord123: no, the input that ghc-pkg takes
16:27:44 <Heffalump> then you don't need to use cabal at all
16:28:10 <Pseudonym> Almost half of Disney's income, I think, comes directly or indirectly from Winnie the Pooh.
16:28:14 <Heffalump> 'ghc-pkg describe parsec' will give you an example of the format.
16:28:26 <fnord123> Pseudonym: pixar
16:28:36 <Heffalump> wow, how much did they pay for them?
16:28:37 <Pseudonym> fnord123: Sorry?
16:28:39 <fnord123> and parks. but the parks cost a stupid amount to run
16:28:44 <Beelsebob> psudonym, I'd be surprised... pixar will make them a lot
16:28:52 <Pseudonym> No, actually.
16:29:10 <Pseudonym> Pixar does make them a lot, but not as much as you'd think.
16:29:10 <Beelsebob> what, Jobs is raping them?
16:29:20 <Beelsebob> why are they so keen to hang onto it then?
16:29:36 <fnord123> its the only profitable movie group since miramax left
16:29:48 <Pseudonym> You're assuming that movies are all Pixar does.
16:30:01 <Pseudonym> Sorry, that movies are all Disney does.
16:30:04 <fnord123> they also sell software like renderman
16:30:10 <Pseudonym> Obviously movies are most of what Pixar does.
16:30:14 <fnord123> no i said the parks make money. but they also cost a lot
16:30:17 <Beelsebob> no, pixar sell renderman don't they?
16:30:18 <Pseudonym> Right.
16:30:37 <Pseudonym> Pixar do sell PRMan, yes, but that doesn't make as much money as movies. :-)
16:30:50 <Pseudonym> There are a few reasons why Disney wants to hold onto Pixar.
16:30:54 <Beelsebob> pseudonym: my point was that that's no cash flow to disney
16:31:06 <wagle> http://www.cs.indiana.edu/~wagle/trans-Y-lambda-yin-yang.gif
16:31:07 <fnord123> but yeah milne's works make a lot in merchandising for disney
16:31:08 <Pseudonym> One of which is that even though it's not a huge amount of money, it's still a lot.
16:31:09 <Beelsebob> because disney's only connection to pixar is that they publish their movies
16:31:13 <Beelsebob> ... for the moment
16:31:14 <Pseudonym> If you know what I mean.
16:31:36 <Pseudonym> Beelsebob: I'm not so sure about that.  I'm not certain what maintenance Pixar does on CAPS.
16:31:46 <Beelsebob> caps?
16:32:07 <Pseudonym> Character Animation Production System
16:32:18 <Pseudonym> It's their software for doing digital cel animation.
16:32:19 <Beelsebob> oh, okay... again... no cash flow to disney
16:32:23 <Pseudonym> Written by Pixar.
16:32:44 <Pseudonym> The biggest reason, I think, though, is that Pixar does animated features better than Disney.
16:32:51 <Beelsebob> heh, indeed
16:32:54 <Pseudonym> Disney lost a lot of personnel under Eisner.
16:33:02 <Pseudonym> Especially to DreamWorks.
16:33:23 <Beelsebob> yeh, dreamworks are the current kings
16:33:34 <Beelsebob> but pixar did catch up with monsters inc
16:33:34 <Pseudonym> Actually, PDI are the current kinds.
16:33:50 <Pseudonym> The actual DreamWorks features... well, a few of them were quite good.
16:34:08 <Beelsebob> I'm talking in terms of public exposure here
16:34:12 <Pseudonym> PDI made Antz, Shrek, Madagascar.
16:34:20 <Pseudonym> DreamWorks Feature Animation made Shark Tale.
16:34:24 <Pseudonym> That should tell you something.
16:34:25 <Beelsebob> note... PDI/Dreamworks
16:34:32 * Beelsebob gets shrek box out
16:34:36 <Pseudonym> (Yes, I'm aware of that.)
16:34:36 <Beelsebob> it says dreamworks on
16:34:41 <fnord123> ok im looking up disneys accounts now
16:35:37 <Beelsebob> disney will loose a lot when Pixar go solo
16:35:44 <Pseudonym> Yes, they will.
16:36:26 <fnord123> net sales: 30752; cost of goods sold: 26692 - implies direct sales or parks to me. cost of merchandising (someone else paying you to put your image on a shirt they pay to make is cheap!)
16:36:39 <fnord123> those are in millions
16:36:46 <Pseudonym> I think their biggest losses were Katzenberg (the "K" of "SKG") and Roy E. Disney.
16:36:48 <Beelsebob> is that all then?
16:37:04 <Beelsebob> I thought it would be much larger
16:37:18 <Pseudonym> Beelsebob: I'm not shocked, actually.
16:37:33 <Pseudonym> In media, turnover tends to be many times greater than profit.
16:37:36 <Beelsebob> e.g. Apple's turnover is about 36bn
16:37:37 <fnord123> 30 billions in sales isn't small...
16:37:55 <Beelsebob> and disney I thought were much bigger
16:38:03 <fnord123> thats good marketing :)
16:38:15 <Beelsebob> heh, you're calling apple's marketing bad?
16:38:49 <fnord123> no but disney is up there with debeers in marketing
16:39:22 * Beelsebob considers going and cocoaing
16:39:32 <Beelsebob> hmm, I might make a tea first
16:39:39 <fnord123> cocoaing?
16:39:59 <Beelsebob> cocoa (using a horribly weakly typed language to write apps for OS X)
16:40:33 <Beelsebob> I litterally spent the last two days trying to track down a bug that would have taken seconds after a compile to fix in Haskell
16:40:34 <Pseudonym> OK, here we go.
16:40:39 <Pseudonym> Disney is 60th on the Fortune 500.
16:40:50 <Pseudonym> Or at least it was last year.
16:40:54 <Pseudonym> $27.061 billion
16:41:05 <Pseudonym> That's revenue.
16:41:11 <Pseudonym> Not a huge amount.
16:41:18 <Pseudonym> Well, it is a huge amount.
16:41:25 <Pseudonym> Pepsi made less.
16:41:33 <fnord123> 2004 sales: 38% media networks. 28% studio entertainment; 26% parks; 8% consumer products
16:42:09 <fnord123> 11,778; 8,713; 7,750; 2,511 millions respectively
16:43:15 * Beelsebob wonders where his tea is
16:44:13 <fnord123> so this all includes buena vista games, home entertainment, disney catalog, disney stor, BV productions, BV television; dimension, miramax, touchstone; waltdisney pictures; abc.com; abcnews.com; abcsports, disney.com, espn.com, movies.com, BV record, discover magazine, us weeklly, A&E, ABC, E!, Disney channel, ESPN (80%)
16:44:38 * Pseudonym nods
16:44:46 <Pseudonym> OK, maybe "almost half" is an exaggeration.
16:44:48 <fnord123> and a bastard-number of local stations. parks, and syndicated shows
16:45:08 <Pseudonym> But most of the merchandise and products sold is Winnie the Pooh products.
16:45:13 <fnord123> 129,000 employees
16:45:29 <Pseudonym> My daughters have a LOT of Winnie the Pooh stuff.
16:45:38 <fnord123> sure maybe most of the 8% of the consumer products is winnie the pooh
16:45:39 <Pseudonym> Though we try to get Shepherd drawings rather than Disney.
16:45:41 <Beelsebob> I had lots of pooh stuff
16:45:51 <Beelsebob> but it was all true millne stuff
16:46:13 <fnord123> hoovers membership ++ :)
16:48:22 <Beelsebob> bugger... this tea really doesn't want made
16:48:27 <Beelsebob> now the tea bag's burst
16:48:51 <fnord123> somebody didnt buy twinnings or whittards
16:48:58 <Beelsebob> ?
16:49:04 <fnord123> brands
16:49:05 <Beelsebob> it's twinings
16:49:08 <Beelsebob> not twinnings
16:49:13 <fnord123> well dont i look silly
16:49:15 <Beelsebob> hehe
16:49:24 <Beelsebob> I always pronounced it as twinnings
16:49:33 <Beelsebob> and got shouted at so many times that it's my bubear now
16:49:36 <Beelsebob> bugbear*
16:49:41 <fnord123> ive been to the original shop, if that gets me some points
16:49:47 <Beelsebob> hehe
16:49:54 <Beelsebob> I've been to many whittards
16:50:00 <Beelsebob> but usually for coffee, not tea
16:50:10 <fnord123> where are you based
16:50:19 <Beelsebob> Canterbury at the mo
16:51:04 <fnord123> darn. im looking for good coffee in ec3 but the closest seems to be south of the river
16:51:17 <fnord123> (ec3 is in the corp of london)
16:51:42 <Beelsebob> heh... well, there's a whitards in canterbury, but I suspect you'll find better in london
16:51:52 <Beelsebob> ... and I know a *very* good coffee shop in dundee
16:52:04 <Beelsebob> ... but I spend too much money there
16:52:16 <Beelsebob> £39 for 200g of some of their better stuff
16:52:21 <fnord123> no it seems theres just starbucks and costas and crappy mom and pops whose coffee is so bad it makes my eyes pop  and almost drop out
16:52:29 <Beelsebob> ... or rarer and different
16:52:38 <Beelsebob> yep, know that feeling
16:52:56 <Beelsebob> no shop that you can just walk past and know instantly it sells coffee because the smell is so strong
16:52:59 <Pseudonym> Lygon Street is just a couple of blocks from here... want me to get you an espresso?
16:53:28 <fnord123> diagon alley is a couple of blocks from me. would you like a wand?
16:53:36 <Beelsebob> fnord: you in York?
16:53:44 <fnord123> no
16:53:56 <Beelsebob> then diagon alley is not a couple of blocks from you ;)
16:54:05 <Beelsebob> Diagon Alley is aka The Shambles
16:54:19 <Beelsebob> twas both the inspiration and the set
16:54:23 <fnord123> the film portion of diagon alley was filmed in leadenhall market
16:54:34 <Beelsebob> hmm, must be both then
16:54:36 <fnord123> but ive been to the shambles. its great
16:54:42 <Beelsebob> I watched them filming in the shambles
16:55:08 <fnord123> a friend working at the US publisher of harry potter told me they filmed it in leadenhall market
16:55:15 <fnord123> someone is lieing!
16:55:30 <Beelsebob> hehe
16:56:18 <fnord123> considering the movie looks like  it was shambles and i thought my friend was wrong, ill believe you, random internet person
16:56:36 <Heffalump> Shambles would be an obvious choice.
16:56:38 <Beelsebob> hehe
16:56:43 <Beelsebob> fair enough...
16:56:56 <Beelsebob> maybe they filmed inside scenes in one and outside in the other?
16:57:15 <Heffalump> could be.
16:57:39 <Beelsebob> it's not like they didn't have enough sets for it
16:57:58 <Heffalump> ISTR they used several Oxford colleges for Hogwarts scenes
16:58:34 <fnord123> oh i see. according to the books the place is next to leadenhall but you need to go through some magic door
16:58:50 <fnord123> or some crap and then it looks like shambles so they filmed it in shambles.
16:59:01 <Beelsebob> ah, that makes sense
16:59:19 <fnord123> i thought they used cambridge colleges like trinity
16:59:20 <Heffalump> do they actually say where it is next to?
16:59:30 <Heffalump> they certainly used the hall of Christ Church Oxford
16:59:35 <Beelsebob> heffalump, not that I know of
16:59:36 <Heffalump> I'm not sure what else they used.
16:59:38 <xerox> WOW.
16:59:42 <xerox> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
16:59:42 <xerox>         ds_app_type RiffRaff.ImageFactory{tc r1A2} [a{tv a1Bv}]
16:59:43 <Beelsebob> the hogwarts grounds IIRC is the end of loch ness
16:59:44 <xerox> :-)
16:59:58 <Heffalump> the impossible seems to happen a lot with ghc lately.
17:00:02 <Beelsebob> indeed
17:00:19 <xerox> Hmm
17:00:26 <Spark> useful that, opens up a whole new domain of experience
17:00:46 <Beelsebob> and a lot of the train line up to hogwarts is down the western railway in scotland
17:00:48 <xerox> What is the good thing to put in the "a" of "class Foo a where", using "instance Foo x where" ?
17:00:57 <xerox> err, the correct x, I mean.
17:01:10 <Beelsebob> some type
17:01:24 <xerox> data Foo = Foo is ok?
17:01:31 <Heffalump> yes
17:01:39 <xerox> I wonder what I did wrong.
17:01:51 <liyang> @paste
17:01:52 <Beelsebob> well that's not necessarily a *you* bug
17:01:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:02:00 <xerox> It's sample stupid code.
17:02:02 <Beelsebob> it's deffinately a ghc bug
17:02:03 <xerox> OK..
17:02:14 * liyang points xerox at above url
17:03:25 <xerox> OK, my silly code is up there.
17:05:03 <liyang> Where is the ImageFactory type defined?
17:05:22 <liyang> oh wait I'm talking crap.
17:05:22 <xerox> Uh-oh ?!
17:05:27 <xerox> OK, pheew.
17:05:48 <liyang> I see the problem.
17:06:06 <liyang> where you had   makeImage :: ImageFactory a -> Image
17:06:19 <liyang> You want: makeImage :: ImageFactory a => a -> Image
17:06:26 <xerox> Silly me.
17:06:30 <xerox> !
17:06:43 <liyang> similar for withImage.
17:07:24 <xerox> OK, thanks much :-)
17:07:30 <liyang> Pleasure. :)
17:09:54 <TheHunter> you want makeImage :: a -> Image
17:10:11 <xerox> Because it's constranined because it's in the class definition
17:10:18 <xerox> Good point
17:10:35 <TheHunter> i think the other one would be rejected.
17:10:43 <TheHunter> no, wait.
17:11:00 <TheHunter> there's a glasgow-exts extension that allows just that.
17:11:42 <xerox> makeImage :: ImageFactory a => a -> Image -- does wor
17:11:47 <xerox> does work, even
17:11:50 <xerox> I'll try
17:12:00 <TheHunter> it's not haskell98. And it's not what you want.
17:12:26 <xerox> Why isn't a constrained?
17:12:36 <liyang> What isn't haskell 98?
17:12:44 <xerox> It seems it works.
17:12:49 <TheHunter> it puts an ImageFactory constraint on an a that already has an ImageFactory constraint, that's kinda pointless.
17:12:51 <xerox> *RiffRaff> :t makeImage
17:12:51 <xerox> makeImage :: (ImageFactory a) => a -> Image
17:13:01 <liyang> TheHunter: oh point.
17:13:02 <xerox> OK, I misunderstood.
17:13:08 <liyang> The second one still needs it.
17:13:30 <xerox> I mean, it worked with, but I thought you were suggesting the :: a -> version was not Haskell 98.  Sorry.
17:13:42 <TheHunter> class Foo a where foo :: Bar a => a <-- not h98.
17:13:44 <liyang> Yay. Lots of confusion abound. XD
17:14:22 <liyang> Though you can say class Bar a => Foo a where foo :: a
17:14:28 <xerox> OK, it was a special case Foo = Bar
17:15:39 <xerox> The point is that you can't constraint differently one 'a' but you have to constraint them all ?
17:16:31 <fnord123> okey dokey so my cabal file definition can't find the exposed names in the modules im exporting. is there a troubleshooting page for this stuff?
17:17:50 <TheHunter> xerox, sorry can't parse that sentance.
17:17:59 <Lemmih> fnord123: Does your cabal file contain the module names?
17:18:48 <xerox> TheHunter, I'm a bit sleepy - I'll rephrase another time, thanks anyway.
17:19:19 <Lemmih> fnord123: You can specify source directories with 'hs-source-dirs: dir1, dir1'.
17:20:55 <fnord123> its looking in . and the file is in .
17:21:11 <fnord123> yes it has the module names
17:23:03 <Lemmih> What error message did it give you?
17:27:07 <fnord123> nm i got it back to the internal error. i have a .a file and a .cabal file. im reading http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html ...
18:29:47 <dons> the bad thing about cvs is even in large projects experienced developers still send out diffs that don't apply against the main tree. darcs send forever!
18:30:16 * lispy_ runs out to be the first to get the tattoo
18:30:31 <dons> hehe
18:32:46 <Beelsebob> haha
18:32:48 * lispy_ gets the latest version of yi and wonders what surprises await him.
18:33:02 <dons> hmm. I added a testsuite, for one ;)
18:33:03 <Pseudonym> It steals your hunny.
18:33:29 <lispy_> Pseudonym: no, i just put her on a plane home
18:34:25 <lispy_> so which emacs mode is most complete these days?
18:34:45 <lispy_> also, is it possible to build a static version of it?
18:35:12 <Korollary> yi-static
18:35:46 <lispy_> hmm....does yi-static allow me to load other keymaps?
18:35:47 <dons> I think `mg' is the most complete. A static version is always built anyway. But if you want *only* the static version, then: gmake way=static
18:35:54 <lispy_> ah
18:36:03 <dons> lisp_, not dynamically no. But yes, on the command line.
18:36:04 <lispy_> so i can do yi-static --as=mg?
18:36:23 <dons> yes
18:36:34 <lispy_> cool, i hadn't realized that
18:37:12 <dons> so the difference is that yi-static doesn't understand ~/.yi/Config.hs files, can't be reconfigured on the fly, and can't load new code
18:37:34 <Korollary> mg mode doesn't show the bar at the bottom for some reason. they show up when you split the screen.
18:38:15 <lispy_> there is a test suite but no make test target :)
18:38:33 <dons> K: yes. feature left over from vi mode. I should fix that. thanks for the hint.
18:38:42 <dons> lispy_: make check
18:38:45 <lispy_> ah
18:39:10 <dons> just committed some more tests, if you're trying out the test suite
18:39:18 <lispy_> ====== Running unit tests =========
18:39:18 <lispy_> ghc -pgmF "../testsuite/pp/logpp" -F -fglasgow-exts --make -package-conf ../yi.conf -package yi -o run-utests UnitTestsMain.hs
18:39:18 <lispy_> Chasing modules from: UnitTestsMain.hs
18:39:18 <lispy_> ghc-6.4: could not execute: ../testsuite/pp/logpp
18:39:20 <lispy_> make[1]: *** [run-utests] Error 1
18:39:37 <lispy_> do i not run it from toplevel map?
18:39:38 <lispy_> er make
18:39:55 <dons> hmm. chmod 700 testsuite/pp/logpp ?
18:40:07 <dons> configure should have done that though. I'll investigate
18:40:19 <lispy_> i didn't run configure
18:40:36 <dons> you pulled some new patches, but didn't run configure?
18:40:41 <dons> bad lispy!
18:41:13 <lispy_> i didn't know that was a good idea
18:41:16 <dons> there were patches to configure.ac to generate the testsuite preprocessor
18:41:20 <lispy_> ah
18:41:36 <dons> well, it is a good idea if there's a patch to configure.ac ;)
18:41:37 <lispy_> it also looks like configure doesn't store the previous command line
18:42:11 <lispy_> i'm not sure if that has to be manually implemented, but some projects do that, i think they store it in .configure.command
18:42:31 <lispy_> it's nice when you forget how you ran configure last time :)
18:42:43 <dons> must be manually hacked in
18:43:36 <lispy_> i just created configure.sh with my config options
18:43:54 <dons> good idea
18:44:07 <dons> or stick them in a shell variable
18:44:16 <lispy_> Loading package haskell98-1.0 ... linking ... done.
18:44:16 <lispy_> ghc-6.4:
18:44:16 <lispy_> Loading package yi-0.1 ... linking ... ghc-6.4: unable to load package `yi-0.1'
18:44:16 <lispy_> make[1]: *** [run-utests] Error 1
18:44:37 <lispy_> dons: that's not a bad idea since i almost always use --prefix=/opt/local
18:45:13 <lispy_> shoot the actual error didn't paste
18:45:14 <dons> did you completely make distclean ; ./configure ; gmake ; gmake check ?
18:45:24 <lispy_>   /Users/dagit/local-data/yi/HSyi.o: unknown symbol `_libiconv'
18:45:28 <dons> @paste
18:45:29 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
18:45:39 <dons> oh. please make distclean and rebuild
18:45:40 <lispy_> i'll try a distclean
18:45:43 <dons> I don't use libiconv anymore
18:46:12 <dons> so you've got an old version of yi hanging around, with a yi.conf that doesn't have all the dependencies of this old lib
18:46:33 <dons> oh, and this is on the mac too, right? ;)
18:46:39 <lispy_> yup :)
18:47:16 <Korollary> job ads that mention "debugging skills" and "multitasking abilities" scare the monad out of me.
18:47:18 <lispy_> that's why i wanted to run the test, because darcs has weird test behavior on my computer, so i thought it would do you a favor to try the test on here
18:47:40 <lispy_> Korollary: yeah, that sounds like you'll be parttime IT or testing
18:47:53 <dons> Korollary, hehehe
18:48:07 <Korollary> lispy_: no, they are fulltime jobs. Fulltime firefighting, though.
18:48:57 <lispy_> when we were at the airport the terminal that shows the departure/return times was obviously running windows because IE had crashed and locked up the system
18:49:11 <lispy_> then a trendmicro scan started about 20 minutes later
18:49:27 <lispy_> after another 20 or so they had rebooted it and it was ``normal'' again
18:49:40 <lispy_> we took pictures :)
18:49:48 <Korollary> Check out the honesty here: "Demonstrable analytical, problem-solving and design skills. Knowledge of windbg, softice, crashdump analysis is a must. Strong knowledge of assembly is a plus. BS+5 yrs experience"
18:50:15 <dons> yikes. that sounds not much fun
18:50:20 <samc> hehe
18:50:28 <Korollary> "we have a mess here. God, please help !"
18:50:32 <lispy_> heh
18:50:43 <Spark> heh
18:50:57 <dons> "demonstrated ability to fix other people's mistakes a plus"
18:51:10 <Korollary> exactly
18:51:13 <Spark> "quiche eaters need not apply"
18:54:13 <lispy_> dons: does hs-plugins basically implement .so files for haskell?
18:54:51 <dons> it simulates them, the linking is done by the ghc runtime system though, not automagically by ld.so
18:55:55 <dons> lispy_, did you get the testsuite running?/
18:55:58 <lispy_> dons: okay, i've been meaning to learn more about them :)
18:56:06 <Korollary> "UNIX*, Linux*, Mozilla* operating systems"
18:56:12 <lispy_> dons: *just* finished the comile
18:56:17 <lispy_> dons: starting it now
18:56:36 <lispy_> dons: same error using the steps you recommended
18:56:59 <dons> an error about libiconv? how weird
18:57:03 <lispy_> ya
18:57:21 * dons gets a new yi src and trys this
18:57:39 <lispy_>   /Users/dagit/local-data/yi/HSyi.o: unknown symbol `_libiconv'
18:58:00 * dons thanks david roundy for --partial
18:58:27 <Korollary> I've recently built yi. I didnt need libiconv.
18:58:30 <lispy_> dons: do you follow darcs-devel?
18:59:17 <dons> rougly
18:59:30 <dons> there's an 'h' in there somewhere
18:59:51 <Korollary> damn wifi connections eh
19:00:52 <lispy_> dons: i sent in a patch that allows you to run a command after every successful apply
19:01:09 <lispy_> dons: may or may not interest you :)
19:01:51 <dons> oh, that would be good -- are you thinking of my email list patch to darcs?
19:02:33 <lispy_> dons: email list patch?
19:03:02 <lispy_> i use the posthook in apply to have darcs send to a mail list
19:03:48 <lispy_> i also have it update an rss feed (so that I don't have to run darcs.cgi) and it puts the output of darcs changes --last 10 in the email it sends out
19:03:58 <dons> oh, I posted a script to the darcs list that simulated a post-apply hook via a wrapper over the darcs binary
19:04:19 <lispy_> oh, i think i saw that, but i was afraid to use it for some odd reason
19:04:43 <lispy_> (I can't recall my objection any more)
19:04:47 <dons> works quite nicey, even written in haskell, but an offiicial hook is better
19:05:00 <dons> it was just a short term measure until a hook was put in
19:05:46 <lispy_> it's just experimental at the moment, I don't think Ian has even accepted it yet :(  But it's been working for me
19:06:01 <lispy_> need some documentation as well
19:07:58 <dons> this iconv issue is very strange. yi doesn't use iconv anywhere now. can you darcs get a fresh tree?
19:08:03 <dons> http://www.cse.unsw.edu.au/~dons/typescript
19:09:24 <dons> that's a fresh build
19:09:55 * lispy_ runs darcs get
19:11:56 <lispy_> dons: there is also talk of having a postget hook
19:12:12 <lispy_> dons: so that you can do things like chmod certain files
19:12:31 <lispy_> although, darcs should make a better effort
19:13:01 <lispy_> i sort of wish darcs would just remember what the settings were, but not the specific user/group.
19:13:38 <lispy_> so if i a file is rwxr-x--- when it is recorded, there is a good chance it should be that way when you use get
19:13:59 <lispy_> regardless of which user or group checks it out
19:15:07 <lispy_> is there an easy way to diff two directory trees?
19:15:32 <lispy_> if 'make check'  works in the fresh copy it would be nice to diff the trees
19:15:53 <dons> diff -ruN --exclude=_darcs ;)
19:16:38 <lispy_> cool
19:16:50 <lispy_> <3 diff
19:17:33 <lispy_> i had an urge today to port all the NeHe opengl tutorial examples to haskell
19:17:48 <lispy_> i figured if i did that I may learn some opengl :)
19:19:01 <lispy_> all tests pass
19:19:56 <dons> cool.
19:21:23 <lispy_> IConv.hs mentions iconv.h
19:21:30 <lispy_> in my original tree
19:21:57 <dons> oh right. so that file was removed, but its still in your tree for some reason
19:23:52 <lispy_> $ darcs annotate Yi/Curses/IConv.hs
19:23:52 <lispy_> darcs failed:  There is no file or directory named 'Yi/Curses/IConv.hs'
19:24:04 <lispy_> and yet i can find it with ls
19:27:17 <lispy_> Oh, you remove IConv.hsc, but I don't think IConv.hs is removed
19:28:01 <lispy_> $ zgrep IConv _darcs/patches/* | grep rmfile
19:28:01 <lispy_> _darcs/patches/20050730032251-9c5c1-d47f6f9886cd68de5e022261fbdc44fe0dadad67.gz:rmfile ./Yi/Curses/IConv.hsc
19:28:04 <dons> oh right. but make distclean should get rid of it
19:28:54 <dons> ah, but then if you run make distclean *after* you pull the rmfile, then it won't get cleaned up
19:29:07 <dons> because Iconv.hsc isn't in the dependency list anymore
19:30:15 <lispy_> where is distclean defined?
19:30:26 <lispy_> i grepped but i didn't find it
19:30:46 <dons> mk/paths.mk iirc
19:31:36 <lispy_> ah, in rules.mk
19:33:20 <lispy_> uh...hmm...i have no idea how to edit this file
19:33:53 <lispy_> user error (Curses[-1]:drawWindow)
19:34:24 <dons> ?
19:34:35 <lispy_> so since i started yi-static --as=mg, i have have type C-s (tried to do a search) and then I scroll down a lot using the arrow keys
19:35:02 <lispy_> dons: you're going to start dreading when i come on irc :
19:35:04 <lispy_> :)
19:35:18 <dons> oh, I get that user error too. nice one
19:35:27 <dons> though I get user error (Curses[-1]:waddch)
19:35:51 <lispy_> what did you type to get it?
19:36:14 <dons> I bet there's a long line in therre somewhere
19:36:27 <lispy_> ah, i bet you're right
19:36:43 <dons> yep. found it.
19:36:56 <threeve> would I be sane trying to do web programming in Haskell?  I've browsed a bit and it doesn't seem to be something many people are doing...
19:36:56 <dons> down near # in-tree package.conf
19:37:56 <lispy_> threeve: have you looked at WASH?
19:38:09 <lispy_> threeve: what sort of web programming have are you thinking about?
19:38:32 <threeve> lispy_: I saw that, was about to look at it.  I was looking at the cgi stuff but it seems to be a bit outdated
19:38:36 <lispy_> threeve: WASH is very nice for cgi, but i was disappointed at the lack of good ajax style support
19:39:05 <dons> lispy, I should write some curses tests too :} (btw, te problem is only long lines with tabs in them, not long lines in general. i should fix the length calculation)
19:39:14 <threeve> hmm.. I'll give WASH a go then
19:39:17 <lispy_> threeve: at haskell.org there is a link to 'generative ....' something or other, it seems to be a eDSL in the spirit of jsp
19:40:23 <lispy_> threeve: if you make something that allows for dynamic webpages that don't require a reload to do 'stuff' then you'd rule the world.  People hate having to actually write javascript and lots of tools for avoiding it are emerging
19:40:34 <lispy_> dons: hmm...okay
19:40:58 <lispy_> dons: i've add  Yi/Curses/IConv.hs to distclean, do you want me to send a patch in?
19:41:38 <lispy_> dons: also, is there anything i need to change for it to be part of distclean FAST=y?
19:42:52 <lispy_> threeve: in theory it should be possible to take WASH and extend it so that it can generate code for gui widgets that are mostly in javascript, so that parts of pages can be reloaded without a new page load
19:43:01 <dons> lispy, nope. should be good.
19:43:04 <dons> send away!
19:43:15 <lispy_> threeve: take a look at the calculator demo for an example of what i'm talking about
19:43:27 <lispy_> threeve: currently every button click requires a page load
19:43:48 <lispy_> dons: soon as make check runs without errors i'll send it :)
19:43:59 <threeve> yea, I'm familiar with ajax.  I've done some stuff with Ruby on Rails.
19:44:17 <threeve> can WASH run under FastCGI or something other than vanilla slow CGI?
19:44:38 <lispy_> threeve: i dunno.  Is fastcgi a worthwhile enhancement to cgi?
19:45:15 <threeve> very.  it essentially makes the cgi a long running processes that handles requests as they come in
19:45:24 <threeve> Oh, there is a mod_haskell??
19:45:29 <lispy_> threeve: do you think haskell on rails would be a good thing? I've heard of ruby on rails, but i'd hate to learn ruby just so i can do web programming when i want to
19:45:31 <threeve> that would possibly work as well
19:45:53 <threeve> lispy_: heh, I actually just came from Ruby to Haskell, in order to learn some new stuff.
19:45:54 <Korollary> Why does one need to learn Ruby to do web programming ?
19:46:21 <threeve> I don't like the idea of 'porting' Ruby on rails, because many of the things it does might not work in haskell.  I'm very new so I can't yet make that call
19:46:46 <threeve> but some of the ideas they have are killer
19:47:09 <Lemmih> modhaskell is going away. HSP+FastCGI is the way of the future.
19:47:25 <lispy_> Korollary: well, i'd need to learn something as near as i can tell.  and ruby appears to be the lesser evil :)
19:47:35 <threeve> Lemmih: is HSP linked on haskell.org?
19:48:14 <Korollary> lispy_: Does it really have anything to do with Ruby, the language, or is it because of some library/framework someone else wrote in Ruby ?
19:48:41 <lispy_> Korollary: i would assume it's due to the framework
19:48:52 <Lemmih> @google Haskell server pages
19:48:52 <threeve> Ruby on Rails requires very little knowledge of ruby.  Most of it is almost a DSL that happens to use Ruby
19:48:54 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
19:48:54 <lispy_> people rave about 'ruby on rails' but less often about 'ruby'
19:49:18 <lispy_> Lemmih: thanks
19:49:19 <Korollary> lispy_: In that case, I am going to write a kickass framework in Assembly, and take the web industry back to 1950's mwahahh.
19:49:40 <threeve> I actually like Ruby more than I like RoR.
19:50:13 <lispy_> Korollary: you have fun with that ;)
19:51:00 <Korollary> I can even imagine the talks I would give. I'd call it, Assembly on Rye, and emphasize that it's "dynamic typing" that makes it all possible...
19:56:02 <heatsink> I have the library function map :: (a -> b) -> IntMap a -> IntMap b; can I lift this to Monad m => mapM :: (a -> m b) -> IntMap a -> m IntMap b ?
19:56:19 <heatsink> liftM won't do it
19:57:13 <Korollary> that would look like IntMap (m b) to me
19:57:28 <lispy_> mapM f a = return (f a)   ?
19:58:18 <lispy_> actually, that won't work because a != IntMap a
19:58:21 <heatsink> Korollary: That's not what I want
19:58:39 <Korollary> I know
19:58:49 <heatsink> I want to compute b over all elements of the map, not create a map of monads
19:59:10 <lispy_> mapM f a = return (f a')  where a' = fromIntMap a  -- I don't know what fromIntMap is ..just guessing
19:59:47 <threeve> so is the documentation for HOpenGL not applicable to ghc 6.4, which seems to have its own OpenGL/GLUT packages??
20:00:03 * threeve is all over the place right now, just trying to get a feel for Haskell
20:00:18 <Korollary> lispy: This is Data.IntMap's map
20:00:20 <TheHunter> heatsink, it's not possible. map could be monadized to mapM or to \f -> reverse . mapM f . reverse
20:00:21 <heatsink> I can convert the map to a list of associations, sequence the monads, then rebuild a map
20:01:21 <lispy_> threeve: http://www.tfh-berlin.de/~panitz/hopengl/skript.pdf
20:01:30 <Korollary> threeve: have you read the tutorials ?
20:01:55 <lispy_> Korollary: some of them are out of date tho, at least the easy to find ones are
20:02:00 <threeve> Korollary: working on it.
20:02:32 <lispy_> threeve: only problem with the tutorial that i just linked to is that some of the examples are missing a call to flush
20:02:35 <threeve> lispy_: that link is just what I needed :)
20:02:56 <lispy_> threeve: i know, i'm just learning HOpenGL too :)
20:03:21 <Korollary> lispy_: I meant haskell tutorials. not hopengl
20:03:38 <threeve> Korollary: I'm working on those too.  I just got bored and wanted to play a little bit :)
20:03:54 <lispy_> Korollary: ah
20:04:02 <threeve> autrijus gave me a few good links, and I'm going to order the school of expression book i think as well
20:04:38 <Korollary> threeve: did he give you the link to "Yet Another Haskell Tutorial" ?
20:05:00 <Korollary> that one is very hands on. you can play with it.
20:05:01 <threeve> Korollary: yep!  That's the one I'm going through in fact
20:05:14 <shapr> @yow !
20:05:15 <lambdabot> Hmmm ... A hash-singer and a cross-eyed guy were SLEEPING on a
20:05:15 <lambdabot> deserted
20:05:15 <lambdabot> island, when ...
20:05:21 <Korollary> @shapr
20:05:22 <lambdabot> Unknown command, try @listcommands.
20:05:27 <threeve> I had started with the 'gentle intro' one, but he recommended not to do that one as it was not so gentle as it claimed
20:05:31 <lispy_> @summon shapr
20:05:32 <lambdabot> Unknown command, try @listcommands.
20:05:45 * shapr appears
20:05:52 <lispy_> @todo
20:05:53 <lambdabot> 0. SamB: A way to get multiple results from a google search
20:05:53 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
20:05:53 <lambdabot> 2. SamB: stop mangling long urls
20:05:53 <lambdabot> 3. dons: improve formatting of @dict
20:05:53 <lambdabot> 4. dons: write Haskell Manifesto
20:05:55 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @
20:05:56 <shapr> It's ambidextrous!
20:05:57 <lambdabot> foo across lines
20:05:58 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
20:06:00 <lambdabot> 7. TheHunter: @type 1 :: Int
20:06:06 * Korollary throws unicycles around
20:06:18 <shapr> w00! unicycles!
20:06:22 <lispy_> oh, i guess it's actually @get-shapr
20:06:28 <Korollary> there ! I caught one shapr !
20:06:35 <shapr> Right, it's 5am, and I just got back from a picnic.
20:06:45 <lispy_> wow
20:06:46 <Korollary> 5am picnics ? love Sweden
20:06:49 <shapr> No unicycles involved, sadly.
20:07:12 <dons> shapr, yi finally has a testsuite.
20:07:18 <shapr> awesome!
20:07:27 <shapr> qc tests?
20:07:31 <dons> hunit for everyone! quickcheck for all!
20:07:33 <Korollary> dons: But is it "obsessed with testing" yet ? ;)
20:07:55 <dons> ooh. hopefully it will be soon.
20:07:56 <shapr> That's the latest testing methodology buzzword, right?
20:08:00 <Korollary> yeah
20:08:27 <shapr> Sure are a lot of mosquitoes out at 5am.
20:08:30 <Pseudonym> How can a program be obsessed?
20:08:41 <shapr> Pseudonym: Look at your own creation!
20:08:42 <Korollary> Pseudonym: my bad wording. I meant the hordes of Yi devs
20:08:52 <shapr> lambdabot is obsessed with all sorts of weird things.
20:09:07 <shapr> @ghc
20:09:07 <lambdabot>  scavenge_stack: weird activation record found on stack
20:09:27 <shapr> Anyway, I'm off to sleep, g'night and happy monads!
20:09:43 <Korollary> nice, side-effect free dreams
20:10:08 <lispy_> shapr: have good dreams!
20:10:51 <Korollary> My boss, who is not a sw dev himself, loves to go into my "unit tests", which are actually integration tests.
20:12:16 <lispy_> Korollary: boss has too much free time at work? ;)
20:12:45 <Korollary> lispy_: no, boss is worried that things will fail unless he has control over everything and every judgement call is made by him.
20:12:59 <lispy_> so has anyone integrated hat and hunit so that you can measure test coverage?
20:13:14 <Korollary> ugh. "coverage" is another ugly word.
20:13:39 <lispy_> Korollary: yes, but some forms are good to measure
20:13:40 <Pseudonym> "Coverage" makes sense, though.
20:13:48 <Pseudonym> It's ugly, but it works as a jargon term.
20:14:10 <Pseudonym> You've got to remember, though, that coverage is an _analysis_, not a testing methodology.
20:14:10 <Korollary> one of our previous projects targeted, and achieved 90% coverage, and it still bombed lol. Nothing about coverage testing in general, but you gotta have a bit more clue.
20:14:20 <lispy_> Korollary: for example if you hit every definition-use pair in your code, then you're fairly like to discover bugs
20:14:50 <Korollary> right. It's just sad that they adopt these like fashion items and scratch their heads afterwards.
20:15:07 <Pseudonym> Ideally, every line of code (apart from "panic, the impossible just happened") should be covered by both unit AND system tests.
20:15:42 <Pseudonym> Meanwhile, back in the real world...
20:15:52 <lispy_> Pseudonym: hehe
20:15:53 <Korollary> system tests wouldnt be able to reach every branch, but they should try imho. System tests are expensive, tho
20:16:16 <lispy_> Forms/3 is a spreadsheet system that measures du coverage interactively, it seems to help people
20:16:41 <lispy_> that's what i was basing it on
20:16:52 <Korollary> argh. spreadsheets again
20:16:53 <Korollary> :)
20:17:02 <lispy_> it's a tool, a rule of thumb, but yeah nothing short of pure mathematics is absolute
20:17:13 <Pseudonym> @seen boegel
20:17:14 <lambdabot> I saw boegel leaving #haskell 5 hours, 57 minutes and 31 seconds ago.
20:18:02 <lispy_> Korollary: yeah, spreadsheets although not that enticing to professional programmers have a lot of attributes which, according to psychology, are better for 'normal' people
20:18:26 <lispy_> and they functional :)
20:18:39 <Korollary> lispy_: papers titled "x considered normal, intuitive" considered harmful :)
20:18:55 <lispy_> Korollary: true, i don't disagree
20:19:12 <lispy_> Korollary: but studies have been conducted....
20:19:18 <lispy_> so if you trust the researchers....
20:19:29 <Korollary> man, I didn't know, but apparently there are some big businesses that have huge spreadsheets that run for "hours".
20:19:30 <Cale> Papers titled "x considered harmful" considered harmful.
20:19:46 <Cale> :)
20:19:57 <Pseudonym> Cale: Be thankful you didn't write that up as a paper.
20:19:59 <Korollary> Cale: I just stole it and modified to suit my needs :)
20:20:35 <dons> dons-brain: stack overflow: . Trace: x considered harmful. considered harmful. considered harmful
20:20:56 <Korollary> hmm, concept leak
20:23:13 <lispy_> I should add a crontab to update, clean, configure, make and install yi :)
20:23:34 <lispy_> it seems to be growing about that fast :)
20:24:10 <lispy_> dons: another reason to like darcs over cvs is that you can asynchronously update
20:24:29 <lispy_> i've wanted that so many times with CVS
20:25:22 <lispy_> I'm working on more than one thing and I want to send in something like a bug fix without needed to grab the latest version (maybe it disturbs something I'm still not finished with)
20:31:23 <lispy_> another more concrete example is when i change some values in a local config file but don't want to check in those values to the main stream copy.  With our cvs policy at school I'd have to check in those changes if I want to get check in anything (all or nothing)
20:31:46 <lispy_> this happens when i play with the debugging options
20:32:18 <dons> yes. being able to send in patches that you know will apply is very nice
20:32:41 <dons> though it is so good at merging, that upating prior to a commit isn't so hard
20:33:38 <lispy_> true
20:33:43 <lispy_> darcs is just nice
20:34:11 <lispy_> when i get back to school i'm going to take a shot at convincing my research group that we would be more productive with darcs than cvs
20:34:44 <lispy_> the collective feeling is that cvs is not good, but it is doing the job so unless we find something very nice we should not change
20:38:21 <Pseudonym> dons: Y (flip consider harmful)
20:39:25 <lispy_> Pseudonym: so if all i have is lambda, how can i make a recursive function?
20:39:34 <lispy_> Pseudonym: is that what you just did with Y?
20:39:40 <Pseudonym> lispy_: Yes.
20:39:57 <Pseudonym> If all you have is simply-typed lambda, you cannot make a general recursive function.
20:40:05 <Pseudonym> If you have untyped lambda, no problem.
20:40:19 <lispy_> Pseudonym: let's say i have lambda ala lisp
20:40:21 <Pseudonym> Y = \f -> (\x -> f (x x)) (\x -> f (x x))
20:40:27 <Pseudonym> Ah.
20:40:31 <Pseudonym> You have a problem there.
20:40:34 <Pseudonym> Lisp is strict.
20:40:38 <lispy_> ah
20:42:13 <heatsink> yi is omega?
20:42:24 <Pseudonym> More or less.
20:42:34 <heatsink> hm, ok.
20:42:36 <Pseudonym> @eval let y f = f (y f) in y id
20:42:41 <lambdabot> <Plugins.Eval>:1:12:
20:42:41 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:42:41 <lambdabot>   `Show a' arising from use of `show'
20:42:47 <Pseudonym> Dammit!
20:42:50 <Pseudonym> @eval let y f = f (y f) in y id :: Int
20:42:55 <lambdabot> Terminated
20:43:07 <Pseudonym> Y I is the smallest infinite loop in combinatory logic.
20:43:07 <heatsink> OMG lambdabot solved the halting problem!
20:43:19 <Pseudonym> Except that the answer is wrong.
20:43:24 <heatsink> :)
20:43:43 <Pseudonym> Hell, if the answer is allowed to be wrong, I solved it years ago.
20:43:50 <lispy_> Pseudonym: Y I is analogous to the natural numbers?
20:43:50 <heatsink> :D
20:44:05 <Pseudonym> lispy_: In what way?
20:44:28 <lispy_> Pseudonym: N is the smallest infinity when speaking of cardinality
20:44:58 <lispy_> Pseudonym: oh, maybe by smallest you meant the simplest that creates a loop
20:45:01 <Pseudonym> Right.
20:45:08 <Pseudonym> In the sense of Kolmogorov complexity.
20:45:12 <Pseudonym> Or something.
20:45:21 <lispy_> that's a new term for me :
20:45:22 <lispy_> :)
20:45:39 <Pseudonym> Well, "something" is like "whatever", only less dismissive.
20:45:41 <Pseudonym> Hope this helps!
20:47:30 <dons> lispy, I gave a talk on this recently. you could use my slides if you like.  http://www.cse.unsw.edu.au/~dons/talks/darcs-intro.ps.bz2
20:47:47 <lispy_> dons: coo
20:48:11 <dons> @lambda Y I
20:48:14 <lambdabot> out of fuel - use @resume to continue
20:48:57 <wagle> senescence is nature's way of solving the halting problem
20:49:03 <heatsink> @help lambda
20:49:04 <lambdabot>  @lambda expr - evaluate the lambda calculus expression, expr
20:49:24 <heatsink> @lambda S K I V V I E S
20:49:25 <lambdabot> unbound variable: V
20:49:32 <heatsink> no void combinator
20:49:43 <wagle> @lambda S K I
20:49:44 <lambdabot> <<Plugins.Lambda.LMEngine.EvalMonad Dynamic -> Plugins.Lambda.
20:49:44 <lambdabot> LMEngine.EvalMonad Dynamic>>
20:50:12 <wagle> @lambda S K I
20:50:13 <lambdabot> <<Plugins.Lambda.LMEngine.EvalMonad Dynamic -> Plugins.Lambda.
20:50:13 <lambdabot> LMEngine.EvalMonad Dynamic>>
20:50:17 <wagle> eh?
20:50:20 <heatsink> @lambda S K I K
20:50:21 <lambdabot> <<Plugins.Lambda.LMEngine.EvalMonad Dynamic -> Plugins.Lambda.
20:50:21 <lambdabot> LMEngine.EvalMonad Dynamic>>
20:50:40 <dons> @lambda I 1
20:50:40 <heatsink> @lambda S (K I) I (K I)
20:50:41 <lambdabot> 1
20:50:41 <lambdabot> <<Plugins.Lambda.LMEngine.EvalMonad Dynamic -> Plugins.Lambda.
20:50:41 <lambdabot> LMEngine.EvalMonad Dynamic>>
20:50:43 <wagle> @lambda Y 2 K
20:50:44 <lambdabot> type error
20:50:56 <wagle> 8)
20:51:03 <heatsink> heh
20:51:07 <Pseudonym> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
20:51:07 <lambdabot> ap (. join id) (. join id)
20:51:19 <wagle> lambdabot solves another one!  where was he 5 years ago?
20:51:19 <lispy_> i swear macosx is clinically brain dead at times
20:51:35 <wagle> lispy_: eh?
20:52:07 <lispy_> wagle: well, it kept insisting that dons's link to to a .ps.bz2 file was really a .ps file, by calling it .ps.bz2.ps
20:53:02 <wagle> hahahahahaah..  tiger
20:53:17 <wagle> not the first flake in the new safari
20:54:48 * wagle installed tiger yesterday, now is stuck rebuilding a whole lot of darwinports
20:55:21 <lispy_> dons: thanks, looks good, not sure the theory of patches will be a good thing for my audience, but overall i like it
20:55:58 <lispy_> my audience will want to believe the tool is very simple, so mentioning that it has a sound mathematical model under the hood is probably all the more i want to say about it
20:56:01 <dons> ok. I this was a talk I gave to my group to switch them to darcs, which we have now done
20:56:10 <lispy_> dons: congrats
20:56:13 <wagle> crashed the Preview app though..  8/
20:56:41 <lispy_> wagle: hmm...i changed the file to .ps.bz2 and it worked great, I have a .pdf now if you need?
20:57:03 <dons> how about bzip2 -d foo.ps.bz2 ?
20:57:35 <lispy_> dons: the problem was that it wanted to treat the bz2 binary data as postscript
20:57:54 <wagle> i gotta head home now, coffee/wifi ship is closing..  i'll figure out something
20:58:03 <univac> hi
20:58:07 <lispy_> dons: preview is actually smart enough to decompress the file as long as it is correcty about the type of the file
20:58:29 <univac> haskell has qt bindings?
20:58:41 <wagle> Preview died for me trying to go to the second page, i think.  the first was ok
20:58:51 <lispy_> univac: i don't know about qt, but gtk2hs is nice for gtk stuff.
20:59:05 <lispy_> wagle: preview sometimes just crashes too
20:59:19 <metaperl> thing is, Qt is more than just a graphics lib...
20:59:23 <Korollary> macosx crashes ?
20:59:25 <univac> i'am z qt fan :)
20:59:47 <univac> hmm  has jabber/xmppy lib?
20:59:53 <lispy_> univac: okay, just thought i'd mention it case gtk was an option :)
21:00:04 <univac> :]
21:00:07 <lispy_> Korollary: yeah, i'm on osx
21:00:25 <univac> hmm
21:00:37 <univac> hasn't jabber lib?
21:00:40 <lispy_> i wish i could tell safari not to show the download window *unless* i ask to see it
21:01:05 <lispy_> univac: i dunno, but if it has tools to make use of C libs
21:01:22 <lispy_> univac: so in theory all you need is a C library that does it and then you could create bindings
21:02:11 <univac> or write ow  ;-
21:02:15 <univac> ;])
21:02:22 <univac> own*
21:02:33 <lispy_> univac: yeah, depending on how involved you want to get :)
21:02:47 <univac> :>
21:05:10 <lispy_> i wish the HPS site had some demos to interact with
21:05:20 <dons> lispy_, I think I've fixed the tabs/long lines bug we hit earlier. would you like to try the latest tasty patches?
21:08:43 <lispy_> dons: of course, i'd love to :)
21:08:51 <lispy_> is it recorded?
21:09:14 <dons> recorded and pushed
21:10:14 * lispy_ is building now
21:15:06 <lispy_> HSP is quite interesting
21:15:32 <lispy_> i'm worried that it's not really a combinator library which could be nice, but it seems better than JSP for example
21:17:00 <lispy_> it's also a bit lower level than i was hoping to work :)
21:17:38 <lispy_> i keep thinking that I should be able to write my program as though the web interaction is just another gui lib, like gtk or something
21:20:39 <lispy_> Yi.hs:26:0:
21:20:39 <lispy_>     Failed to load interface for `Yi.Locale':
21:20:39 <lispy_>         Could not find module `Yi.Locale':
21:21:06 <lispy_> dons: i did a make distclean && ./configure.sh && make && make check, and this happened, i think, during make
21:22:03 <lispy_> ghc -Wall -Werror -Icbits -Imk -funbox-strict-fields -O2 -fasm -threaded  -package-conf yi.conf -package yi -i -Icbits -Imk -c Yi.hs -o Yi.o -ohi Yi.hi
21:22:13 <lispy_> that's the part of the make that generates the error
21:23:03 <lispy_> Yi/Locale.{hi,hs, hsc, o} all exist
21:23:45 <TheHunter> workaround:  ghc --make -Wall -Werror -Icbits -Imk -funbox-strict-fields -O2 -fasm -threaded  -package-conf yi.conf -package yi -i -Icbits -Imk -c Yi.hs -o Yi.o
21:24:31 <dons> hmm.
21:24:33 <lispy_> it would appear that Yi/Locale.hs is not a darcs mmanaged file
21:24:43 <lispy_> at least darcs annotate knows nothing about it
21:24:44 <dons> Locale.hsc should be
21:25:09 <lispy_> dons: aye and it is according to annotate
21:26:03 <dons> did hsc2hs regenerate Locale.hsc ?
21:26:36 <lispy_> hsc2hs -Imk -Icbits  -DGLASGOW_HASKELL=604  Yi/Locale.hsc
21:28:07 <lispy_> ghc -Wall -Werror -Icbits -Imk -funbox-strict-fields -O2 -fasm -threaded  -package-name yi -c Yi/Locale.hs -o Yi/Locale.o -ohi Yi/Locale.hi
21:28:30 <lispy_> ghc -Imk -Icbits -optc-O3  -c Yi/Locale_hsc.c -o Yi/Locale_hsc.o
21:28:58 <Lemmih> What's with the -fasm flag?
21:29:14 <lispy_> ranlib: file: libHSyi.a(Locale_hsc.o) has no symbols
21:31:29 <dons> Lemmih, works around a bug with ghc 6.4 and foreign code
21:32:11 <dons> -fvia-C is fixed in 6.4.1
21:34:25 <dons> lispy_, works for me. haven't touched that file today. the Mac is weird
21:34:36 <lispy_> hehe
21:34:45 <lispy_> i'll try a clean copy
21:35:08 <dons> yeah, maybe `distclean' does something it shouldn't. you could compare `distclean' and `clean' for results
21:43:12 <lispy_> dons: 13 tests passed, i'll check out the diff now
21:47:40 <Korollary> yi --as=msword should issue an error message, imho :)
21:47:52 <lispy_> haha
21:48:14 <lispy_> dons: diff and grep -r Locale.hs don't really show anything relevant
21:49:18 <lispy_> dons: i'm not sure how do a comparison of make clean and make distclean
21:49:41 <Korollary> you can diff the directories recursively I guess
21:49:42 <dons> take a tree. build it. do a make clean, see if that then fails to build again. do the same with distclean
21:56:47 <lispy_> make distclean on the fresh copy is fine
21:57:03 <lispy_> perhaps i should just give up on my old copy :)
21:57:40 <dons> oh, you were working in the old version that had broken previously too?
21:59:27 <lispy_> yeah
21:59:37 <lispy_> i'm trying a 'make clean' in that version
21:59:46 <lispy_> just to try my luck :)
22:00:07 <lispy_> BTW, your patches seem to have fixed the curses bug
22:00:46 <dons> good. that's what they were supposed to do ;)
22:02:28 <lispy_> could changing the name of the top level directory have confused the make process?
22:03:06 <lispy_> i ran make distclean and configure after changing so i thought that would fix any pathing issues introduced by changing it...
22:04:05 <lispy_> it builds this time...now let me change the directory name and see what happens...
22:04:40 <stefanw> dons, any special reason for using unsafePerformIO in yi's unit tests?
22:05:08 <dons> oh. trying to convince the  typechecker to accept them
22:05:14 <dons> is there another way?
22:05:50 <dons> a quick survey and I couldn't see how to have tests in IO
22:09:10 <lispy_> dons: it would appear that make clean did something that make distclean didn't, and apparently a clean repository doesn't need it to be done...and now i've had *it* done on my only dirty copy
22:09:32 <lispy_> dons: was that ambiguous enough?
22:09:51 <dons> yes. please rephrase.
22:10:34 <dons> oh this is very nice. I write some nice pure List.* code over strings, and then check if the low level ptr haggling buffer code produces the same result
22:10:55 <lispy_> I can't get the clean copy to break.  But the old copy was broken, but 'make clean' appears to have fixed it for good
22:11:05 <dons> @karma+ stefanw
22:11:06 <lambdabot> stefanw's karma raised to 1.
22:11:12 <stefanw> dons: type Assertion = IO ()
22:11:16 <stefanw> :-)
22:11:18 <dons> ok, we can probably leave it for now then lispy_
22:11:21 <dons> stefanw!
22:11:35 <dons> hmm. why didn't I spot that
22:12:12 <stefanw> sometimes, type synonyms aren't that good...
22:13:26 <dons> silly me. and there I was throwing unsafePerformIO at it :/
22:14:47 <lispy_> dons: when your only tool is a hammer....
22:15:00 <lispy_> ;)
22:15:24 <dons> who needs the damn type system anyway!
22:17:29 <lispy_> dons: just tried mv yi yi2 && cd yi2 && make clean && make, and i get errors.  But I don't want deal with it anymore.  So unless someone else reports it...
22:17:59 <dons> maybe path is hard baked. I'll have a look. cheers
22:19:13 <lispy_> dons: things is, if that is the case, why did make clean appear to fix it before?
22:22:22 <lispy_> dons: well, either way, i'm going to play with HOpenGL a bit before I have to sleep.  Thanks for the yi patches.
22:25:21 <dons> noo worries
22:25:32 <heatsink> oh yea, I forgot about the karma thing
22:25:50 <heatsink> since my type inference code appears to work, and pseudo helped me with it
22:25:55 <heatsink> @karma+ Pseudonym
22:25:57 <lambdabot> Pseudonym's karma raised to 2.
23:27:49 <musasabi> morning
23:29:54 <ski> yes
23:55:53 <Itkovian> meuning
