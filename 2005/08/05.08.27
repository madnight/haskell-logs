01:16:53 <dons> ghc bug of the day:
01:16:54 <dons> *Quick> :reload
01:16:54 <dons> *** Exception: <<loop>>
01:16:55 <dons> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5)
01:17:24 * pesco pats dons on the back.
01:17:36 <pesco> Nice hit.
01:17:58 <dons> :)
01:23:58 <dons> stupid sourceforge is so slow. bring on Bark!
01:43:53 * shapr yawns
01:44:14 * dons boogles at the number of instance Arbitrary Char google turns up
01:44:19 <dons> boggles?
01:44:27 <dons> no, boogles is better
01:44:42 <Spark> goggles and boogles
01:44:48 <reppie[^_^]> morning
01:44:54 <dons> to be boggled by google, == to be boogled
01:45:26 <dons> and to be boggled by hoogle == to be boogle boogled
01:45:31 <dons> hoogle boogled
01:45:57 * Spark prepares the electric chair
01:46:35 <Spark> only an american would think execution by electricity is a good idea
01:46:42 <Spark> everyone else would think "what a waste of oil"
01:46:49 <dons> heh
01:46:58 <dons> a waste of coal in .au
01:47:49 <shapr> sticks are cheap.
01:49:17 <shapr> "Sustainable execution, Sticks in the workplace." by The King's Executioner.
02:18:38 * xerox yawns
02:19:33 <dcoutts> morning xerox
02:54:06 <scalopus> Hi
02:55:35 <Beelsebob> lo
03:12:52 <Beelsebob> morning philippa
03:48:42 <dons> @karma+ QuickCheck
03:48:43 <lambdabot> QuickCheck's karma raised to 1.
03:49:32 <xerox> :-)))
03:50:17 <dons> I really like quickcheck :) it found a bug in a corner case of fps
03:50:18 <xerox> Why is ad-hoc polymorphism considered harmful?
03:50:31 <dons> hmm, it is?
03:50:42 <xerox> I never had a chance to use it, but I read the documentation, and it feels cool to me.
03:50:50 <dons> typeclasses provde ad-hoc polymorphism, and I'm not sure they're harmful
03:51:13 <xerox> Hmm, maybe the problem is when it is not "explicit" anywhere?
03:51:26 <dons> ah, maybe maybe.
03:51:32 <mikael> typeclasses provide an unusually good implementation of ad-hoc polymorphism (-:
03:51:55 <xerox> I'm thinking about those languages where you can do something along the lines:
03:51:56 <dons> right. maybe the ad-hoc nature of most ad-hoc polymorphic systems is the problem ;)
03:52:33 <xerox> class Foo
03:52:33 <xerox>   new (Int) = ...
03:52:33 <xerox>   new (Double, Double) = ...
03:52:33 <xerox>   new ([String]) = ...
03:52:48 <xerox> </pseudofantasycode>
03:53:00 <dons> heh
03:53:27 <mikael> in those languages, I think that feature is often used very ad-hocally
03:53:47 <mikael> like in java, people seem to use it to create many methods that conceptually do entirely different things
03:54:33 <xerox> A friend of mine was proud of this ("it lets me use Access or MS Sql Server 2005 transparently!"): http://neuralnoise.com/dbmanager.vb
03:55:26 <xerox> (It's VB.NET9
03:55:29 <xerox> (It's VB.NET), even
03:55:58 <dcoutts> I think sometimes we try to use type classes where we should simple by using namespace features / modules
03:56:01 <mikael> oh yeah, and, what is the answer to exercise 2 of Ross Paterson's arrow paper?  (why isn't newtype LM i o = LM ([i] -> [o]) an arrow type?)
03:56:33 <mikael> 'cause I wrote the obvious Arrow implementation, and it passes the type checker, so it must be correct... right?
03:56:41 <xerox> dcoutts: maybe.. types hierarchies?
03:57:03 <dcoutts> xerox, wel the problem really I think is that Haskell's module system is a bit weak
03:57:28 <xerox> dcoutts: in what way?
03:57:33 <xerox> Hello ndm!
03:57:42 <ndm> hey xerox
03:57:48 <xerox> How's code?
03:57:56 <ndm> this morning, hungover
03:58:02 <dcoutts> xerox, eg we wanted to export that Matrix module from the Cairo module, but then it get's "flattened" and so names clash with the ones from the Cairo module itself.
03:58:07 <ndm> in general, not too bad - no progress on hoogle for a while
03:58:13 <ndm> but lots of other little projects
03:58:20 <xerox> dcoutts: right!  And it isn't fixed as now, err.
03:58:31 <arjanb> mikael: no, only if the arrow laws hold for you implementation
03:58:49 <xerox> ndm: cool, I noticed some days ago that you added command line options, very handy for a local lambdabot install.
03:58:57 <dcoutts> either the user has to import lots of modules themselves and use qualified or you just have to prefix "matrix" to lots of things. It's a pain
03:59:03 <ndm> xerox, that was dons
03:59:05 <dons> ndm, ah! another member of the phd-student-with-lots-of-little-projects club :)
03:59:09 <xerox> @karma+ dons
03:59:10 <lambdabot> dons's karma raised to 13.
03:59:18 <xerox> Urgh :-)
03:59:19 <ndm> dons, i have about 15 projects...
03:59:27 <dons> wow. you win!
03:59:40 <xerox> @karma
03:59:41 <lambdabot> You have a karma of 7
03:59:43 <ndm> yeah, its possible i'll finish one some day...
03:59:57 <xerox> ndm: the lexer/parser one sounded interesting!
04:00:09 <mikael> igloo ~$ ls projects | wc -l
04:00:09 <mikael> 57
04:00:09 <mikael> igloo ~$ ls projects/old-crap | wc -l
04:00:09 <mikael> 47
04:00:12 <mikael> :-/
04:00:29 <dcoutts> ndm, dons, hmm I think I've got maybe 5 projects on the go (and my PhD)
04:00:47 * xerox hears the monkeys' eek eek eek, and parties :-)
04:00:50 <dons> i have about, hmm, 6 and a phd
04:01:10 <dons> Igloo is a member of this club too
04:01:15 <xerox> I'm about to have 0 projects, fortunately ;-)
04:01:24 <xerox> (In the bast case, that is=
04:01:27 <dcoutts> gtk2hs, helping xerox with cairo, c2hs, gentoo packaging, helping with cabal, I'm sure there are others...
04:01:55 * xerox notes they are ordered as "most time-using"
04:01:58 * xerox hides
04:02:05 <dcoutts> heh :-)
04:02:10 <dons> hehehe
04:02:42 * dcoutts thinks that xerox and his monkeys is rather odd
04:03:13 <beelsebo1> yay, haskell in bed
04:03:37 <xerox> dcoutts: did you get them?  They're great.
04:03:50 <dcoutts> xerox, they're funny
04:07:18 <mikael> can you create a data type that derives Show -if- some of its parameters implement Show?
04:07:40 <mikael> note: I still want to be able to create non-Showable instances of this data type
04:08:07 <beelsebo1> why wouldn't you be able to?
04:08:47 <mikael> it's straightforward to do manually, but I want to use a ``deriving Show'' clause
04:09:13 <ndm__> is there a function in GHC somewhere to grab a web page as a String
04:09:23 <ndm__> URL -> IO String
04:09:47 <beelsebo1> would need to be in a maybe wouldn't it?
04:09:48 <dons> popen $ "wget" ?
04:09:54 <beelsebo1> incase the server times out
04:10:02 <dons> we have such a function in lambdabot, let me see..
04:10:06 <xerox> popen $ "lynx --dump"
04:10:08 <shapr> Have you tried Network.HTTP ?
04:10:31 <dons> MiniHTTP has readPage :: Proxy -> URI -> [String] -> String -> IO [String]
04:10:50 <mikael> hey shapr :-)
04:10:59 <dons> http://www.haskell.org/http/
04:11:54 <ndm__> thanks, one of those should give me what i want
04:12:07 <shapr> hej mikael, hur l√§get?
04:12:10 <ndm__> it seems that it would be nice if it did have one as standard
04:12:34 <beelsebo1> neil... why don't you make a new one up :D
04:12:59 <ndm__> bob, i'm trying to cut down the number of projects i have
04:13:06 <beelsebo1> hehe
04:13:18 <beelsebo1> i seem to have inherrited a new one
04:13:22 <ndm__> which is?
04:13:27 <beelsebo1> X gallon hat
04:13:27 <dons> ls -1 | sort | take 10 | mapM_ rm ;)
04:13:43 <cinema> dons, I have an error when compiling 'plugs' : Expecting a function type, but found `t_a1em t_a1nj'
04:13:50 <ndm__> do expand...
04:13:53 <beelsebo1> ... and maybe 11 gallon hat too
04:13:57 <mikael> shapr: bra
04:13:57 <beelsebo1> hat... for OS X
04:14:04 <beelsebo1> ... and latterly, for X11
04:14:09 <dons> cinema, using the darcs version of hs-plugins?
04:14:17 <cinema> dons, yes
04:14:21 <beelsebo1> as in giving all the tools nice guis
04:14:26 <mikael> shapr: we recently started working on our final high school project to create a software synthesizer & real-time audio processor
04:14:39 <dons> hmm. cinema, I'll have a look.
04:14:43 <mikael> shapr: it involves using haskell to compile processing units into C++ :-)
04:14:44 <dons> oh what ghc version?
04:14:58 <ndm__> hey, that was my project!
04:15:00 <shapr> mikael: Wow, nifty.
04:15:04 <mikael> ndm__: !
04:15:05 <cinema> dons, ghc-6.5 (Head), last week
04:15:06 <beelsebo1> ndm: really?
04:15:10 <beelsebo1> fro OS X?
04:15:12 <ndm__> mikael, to bob :)
04:15:17 <mikael> oh :-)
04:15:21 <ndm__> no, not for OS X
04:15:27 <ndm__> for win
04:15:30 <cinema> dons, it seems resolveObjs needs one argument now
04:15:57 <dons> cinema, here with head I have no problems with hs-plugins/examples/plugs
04:16:29 <dons> unless resolveObjs really changed in the last few days
04:16:33 <cinema> dons,  hs-plugins/examples/plugs/plugs
04:16:59 <cinema> where does resolveObjs come from ? is it ghc ?
04:17:18 <Lemmih> It's from the linker in GHC's RTS.
04:17:20 <dons> ah yes. sorry, I mean plugs/plugs. just compiled it then.
04:17:28 <dons> checking the src resolveObjs seems right.
04:17:36 <dons> HsInt resolveObjs( void )
04:17:50 <dons> can you post a transcript?
04:17:51 <dons> @paste
04:17:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:18:14 <dons> oh, are you on a mac?
04:18:36 <cinema> dons, no, on linux/x386
04:19:05 <dons> weird. better post a transcript, and gather any information you think is relevant.
04:20:42 <cinema> it seems that resolveObjs :: IO a -> IO ()
04:21:21 <cinema> as it appears in ./src/System/Plugins/Load.hs
04:21:26 <Lemmih> Ah yes. The first argument is evaluated if resolveObjs fail.
04:21:27 <dons> the haskell wrapper, yep.
04:21:36 <dons> oh, is this a Lemmih change?
04:21:52 <dons> ah ha!
04:21:53 <dons> yes.
04:22:06 <dons> cinema, well spotted. fixing now.
04:22:09 <xerox> @index liftIO
04:22:10 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
04:22:10 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
04:22:10 <lambdabot> Monad.Error, Control.Monad.List
04:22:17 <dons> @karma+ cinema
04:22:17 <lambdabot> cinema's karma raised to 1.
04:22:18 <cinema> dons, thanks a lot
04:23:22 <dons> I'd forgotten that since the cabalisation, hs-plugins needs to be installed before the examples are tested.
04:24:00 <dcoutts> dons, oh, hs-plugins is now cabalised?
04:24:24 <dons> yes!
04:24:27 <dcoutts> cool!
04:24:37 <dcoutts> I hope to see it in hackage soon then :-)
04:24:46 <Lemmih> But not enough for use with HackageDB/cabal-get yet.
04:24:52 <dcoutts> oh
04:24:59 <dcoutts> yet :-)
04:25:15 <dons> Lemmih, it's not cabalised enough?
04:25:27 <dons> i need to wipe all vestiges of makefiles
04:28:01 <adept> hello there
04:28:20 <adept> any h2sh users around here? ;)
04:28:42 <dons> h4sh ?
04:28:59 <dcoutts> Lemmih, I have a hackage feature suggestion (not an early priority): allow the tested-with: field of packages to be updated after the package has been uploaded. But the information would need to be maintained externally to the tarball since we can't modify the package md5sum obviously.
04:29:11 <adept> dons: yep
04:29:26 <beelsebo1> neil... how many log ins do you need?
04:29:59 <dcoutts> Lemmih, it would be great for users to have some indication as to wether a package is expected to work with their compiler / compiler version / platform.
04:30:52 <dons> adept, I use it :)
04:31:33 <adept> dons: judging from the nick, I suspect that you probably also wrote it :)
04:31:51 <dcoutts> adept, good guess
04:32:08 <adept> dons: anyway, question is: of what possible use is the "group" from h4hs?
04:32:14 <Lemmih> dcoutts: I'm more likely to remember it if you write it down on the Wiki.
04:32:21 <dcoutts> Lemmih, yeah, ok
04:33:00 <dons> adept currrently not much. it should be [a] -> [[a]], instead of a -> [a] :}
04:33:10 <dons> this was pointed out by Itkovian a couple of days ago
04:33:12 <adept> dons: aha! thought so :)
04:33:34 <dons> otherwise, all you can do is: paprika$ group aaabbbccc
04:33:34 <dons> aaa
04:33:34 <dons> bbb
04:33:34 <dons> ccc
04:33:46 <dons> which is something I guess, but not terribly useful
04:34:03 <adept> dons: other than that, thanks a bunch! h4sh really made my day :)
04:34:12 <dons> cool :D
04:35:57 <dons> cinema, just pushed the patch to fix plugs.
04:36:27 <xerox> @where h4sh
04:36:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
04:36:41 <xerox> I didn't succeed in compile it the first time, I retry.
04:37:19 <xerox> Is --partial suggested over a bleeding edge darcs repo?
04:37:29 <dons> just grab the lot :)
04:37:34 <ndm> beelsebo1, the network here is trashed
04:37:35 <dons> bleeding edge is pretty safe
04:37:39 <cinema> dons, Thanks, I'm going to test it
04:37:41 <dons> and faster ;)
04:37:48 <ndm> i think someone is experimenting with bittorrent...
04:37:59 <beelsebo1> heh
04:38:16 <shapr> Does multicast work over 6to4 ?
04:41:06 * shapr asks google.
04:41:41 <xerox> cannot satisfy dependency fps-any
04:41:44 <xerox> Mumble
04:42:34 <cinema> dons, It works now. Thanks again
04:42:37 <dons> xerox?
04:42:48 <xerox> dons darcs get && make
04:43:06 <dons> oh, you need FastPackedStrings!
04:43:09 <dons> @where fps
04:43:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:43:16 <xerox> Oh you did package it
04:43:18 <xerox> Cool!!
06:19:49 <ndm__> hi, i'm having problems with IO and Monads (and IRC!)
06:19:59 <ndm__> wget url = do system $ "wget -O out.txt " ++ url
06:20:01 <ndm__>    x <- readFile "out.txt"
06:20:02 <ndm__>    removeFile "out.txt"
06:20:04 <ndm__>    return x
06:21:20 <ndm__> main: out.txt: removeFile: permission denied (Permission denied)
06:21:35 <ndm__> its obviously not "finished" reading before it tries to delete
06:21:43 <ndm__> because of the laziness
06:21:52 <ndm__> so what do i do to "fix" this code?
06:22:52 <alar> try to make x strict
06:23:18 <ndm__> alar, how?
06:23:30 <ndm__> i tried seq and length, but the problem is they didn't evaluate either
06:23:43 <ndm__> but i was probably using seq wrongly...
06:24:10 <pejo> ndm, http://users.aber.ac.uk/afc/stricthaskell.html#readfilehs maybe?
06:26:15 <ndm__> pejo, still the same error
06:26:17 <dons> ndm, like this:
06:26:23 <Lemmih> How about using System.Process and avoid the temporary file all together.
06:26:31 <Lemmih> s/./?/
06:26:37 <dons> forkIO (Control.Exception.evaluate (length output) >> return ())
06:26:46 <dons> right, like Lemmih says.
06:26:59 <dcoutts> dons, is the forkIO really necessary?
06:27:13 <dons> anyway, you need to eval all of x
06:27:14 <dcoutts> it's only a static file
06:27:36 <dons> dcoutts, maybe not, I'm just grabbing that from my process library
06:27:39 <ndm__> Lemmih, i was hoping to use it on my old copy of hugs which doesn't have system.process
06:27:48 <arjanb> strange there is no strict readFile in the standard libs
06:28:07 <dcoutts> dons, right, it's different there because it's with pipes
06:28:09 <ndm__> is there no easy and simple way to do a read like this?
06:28:38 <dcoutts> you can open the file, read it and close it explicitly
06:28:43 <Lemmih> ndm__: dons just showed you how.
06:28:45 <dcoutts> the readFile is a convenience thing
06:29:01 <ndm__> dcoutts, i tried that, still no luck
06:29:28 <dcoutts> ndm__, if you hOpen; ...; hClose; it'll really be closed
06:29:29 <vegai> mail simonmar "Hey, could you add strict readFile to GHC?" && sleep 5184000
06:29:47 <ndm__> dcoutts, yeah, but then when i try the buffer is empty
06:29:50 <ndm__> delete succeeds
06:29:55 <dcoutts> ndm__, but that means not using readFile since it does the lazy half closed thing
06:30:16 <dons> ndm__, did you try forcing evaluation by: evaluate (length x) before removing the file?
06:30:30 <ndm__> wget url = do system $ "wget -O out.txt " ++ url
06:30:32 <ndm__>               h <- openFile "out.txt" ReadMode
06:30:33 <ndm__>               s <- hGetContents h
06:30:35 <ndm__>               hClose h
06:30:36 <ndm__>               removeFile "out.txt"
06:30:38 <ndm__>               return s
06:30:40 <ndm__> evaluate?
06:30:48 <ndm__> i put in various things, but none worked
06:31:09 <dcoutts> ndm__, no you can't use hGetContents and hClose like that, it's the same problem
06:31:18 <dcoutts> readfile and hGetContents are basically the same thing
06:31:24 <xerox> Didn't Network.HTTP work?
06:31:31 <ndm__> xerox, nope :(
06:31:36 <xerox> Uhm.
06:31:37 <dons> readFile name   =  openFile name ReadMode >>= hGetContents
06:31:44 <ndm__> well it did work, but i couldn't get the body back
06:32:04 <ndm__> dcoutts, what should i use instead of hGetContents?
06:32:49 <Lemmih> @type GHC.IO.slurpFile
06:32:59 <xerox> http://cvs.haskell.org/darcs/http/test/get.hs ?
06:33:06 <simona> ndm: IMHO the right thing is to use a temporary file. Otherwise you're program will use way to much memory on big input files.
06:33:14 <Lemmih> lambdabot: What's up?
06:33:17 <lambdabot> FilePath -> IO (GHC.Ptr.Ptr (), Int)
06:33:31 <dons> probably linking nightly ghc build
06:33:45 <Lemmih> slurpFile is strict.
06:34:08 <dcoutts> ndm__, you can use hGetChar or hGetLine in a loop
06:34:08 <ndm__> xerox, will look at that
06:34:11 <dons> wget url = do
06:34:11 <dons>     system $ "wget -O out.txt " ++ url
06:34:11 <dons>     h <- readFile "out.txt"
06:34:11 <dons>     length h `seq` do
06:34:11 <dons>         removeFile "out.txt"
06:34:13 <dons>         return h
06:34:30 <dcoutts> ndm__, or for something more effecient use the slurp thing
06:34:48 <dons> but I think he doesn't like relying on GHC.*
06:34:50 <ndm__> dcoutts, i'm not too fussed about efficient, i just want working for now ;)
06:35:01 <dons> ndm__ the above works for me
06:35:04 <ndm__> dons, indeed - but in this case i will make an exception, its just for internal
06:35:08 <dcoutts> ndm__, ok, use hGetLine
06:35:37 <xerox> It's ugly :)
06:35:49 <dons> sigh. what's wrong with just forcing the string readFile returns?
06:35:57 <xerox> I think you wouldn't do it even in perl :-P
06:36:35 <ndm__> dons, i'm just trying that - if it works its perfect
06:36:51 <ndm__> yay, thanks dons, your code does it perfect :)
06:37:03 <dons> :)
06:38:12 <autrijus> greetings.
06:38:13 <vegai> "Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if tell me how many letters that file has! -Oh, ok!"
06:38:34 <dons> hehe
06:38:49 <alar> lol
06:39:19 <dons> @quote vegai
06:39:20 <lambdabot>  Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll
06:39:20 <lambdabot> give you a cookie if you tell me how many letters that file has! -Oh,
06:39:20 <lambdabot> ok!
06:39:22 <simona> dons: It's bad to rely on order of evaluation. You're forcing the file content for correctness, not for efficiency. Your approach breaks if 'seq' is implemented differently.
06:39:57 <dons> yes
06:40:08 <ndm__> xerox, with that url code it doesn't work for my particular page
06:40:27 <alar> I there a way to implement 'seq' differently?
06:40:33 <dons> simmona, relying on wget is probably a worse problem ;)
06:40:45 <autrijus> you can use runCommand / waitForProcess on wget, no?
06:41:25 <Lemmih> autrijus: Not in old versions of Hugs.
06:41:32 <dons> and a correct use of waitForProcess requires forkIO (Control.Exception.evaluate (length output) >> return ()) on the pipe..
06:42:13 <autrijus> Lemmih: oh ok... wasn't aware that old versions of hugs is a prerequisite
06:42:33 <ndm__> autrijus, only for me :)
06:42:41 <autrijus> :)
06:42:56 <simona> dons: I think you can have a Haskell98 implementation where seq==const, i.e. a no-op.
06:44:47 <dons> I would normally write:
06:44:49 <dons>     h <- readFile "out.txt"
06:44:49 <dons>     (Control.Exception.evaluate (length h)) >> return ()
06:44:49 <dons>     removeFile "out.txt"
06:45:05 <dons> however, you still get seq underneath, and it isn't H98 either
06:46:18 <dons> still, I think this is ok, as no Haskell implementation in practice has a no-op seq
06:46:25 <dcoutts> seq is in H98
06:46:27 <simona> dons: I guess it just feels wrong. The Right Thing (tm) is to write the result into a different, temporary file and then read it back. What we should have in the standard library is a readTempFile, that lazily reads a file and deletes it once it's done.
06:46:58 <dcoutts> simona, yeah some propper temp file handling would be nice
06:47:09 <dons> dcoutts, but evaluate isn't
06:47:16 <dcoutts> dons, true
06:47:23 <dons> my 'it' was bound to 'evaluate' ;)
06:47:56 <xerox> in the expression:
06:48:02 <xerox> I saw too much GHC error messages.
06:48:10 <xerox> many, even
06:48:13 <dcoutts> I've never quite sure of the difference between "evaluate x" and "x `seq` return ()"
06:49:00 <dons> we only know: @(evaluate a)@ is /not/ the same as @(a \`seq\` return a)@
06:49:01 <dons> :}
06:49:06 <simona> dcoutts: yes, 'seq' is H98. If you'd add a reduction rule such that s <- readFile, length s is converted into a function that retrives the size of the file, then dons solution doesn't work anymore.
06:49:27 <simona> dcoutts: hypothetically, that is.
06:49:53 * dcoutts tries to understand dons solution
06:50:19 <ski> hi esap !
06:50:22 <esap> hi
06:50:32 <ski> ltns
06:51:10 <dcoutts> simona, true, I'm not sure such a reduction rule would be valid though. It's rather subtle.
06:52:03 <dcoutts> or maybe it's only valid not in the presense of seq, like many other bits of H98 semantics :-)
06:52:17 <dcoutts> seq is not nice from a semantics point of view
06:52:41 <dcoutts> seq allows you to distinguish things which ought not to be distinguishable
06:53:20 <dcoutts> like (undefined :: a -> b) vs (\_ -> undefined)
06:53:28 <simona> dcoutts: theoretically. Practically only if you're willing to catch exceptions of evaluations which is difficult it itself.
06:54:14 <simona> dcoutts: no. sorry. You can of course distinguish between crash and no crash.
06:55:04 <dcoutts> without using seq you cannot distinguish the two functions
06:56:28 <dcoutts> without seq, for any way you try to use them, they either both crash, or neither
07:02:25 <dcoutts> simona, re: cairo's fonts, it's currently just the FontOptions module
07:02:37 <dcoutts> simona, we've not got an cairo+pango bits yet
07:02:53 <dons> oh, I get xerox' joke.
07:02:55 <dons> hehe
07:03:31 <dons> it was only 15 minutes ago
07:03:43 <xerox> haha :-)
07:04:12 <simona> dcoutts: fine.
07:04:54 <dcoutts> simona, You'll see in a sec, I'm just about to commit it all....
07:05:04 * xerox bounces happily
07:08:56 <dcoutts> done
07:09:04 <dcoutts> now for the build system bits...
07:10:53 <dcoutts> simona, you happy with it being gtk/Graphics/UI/Gtk/Cairo.chs.pp rather than somewhere else? It's all going to be re-exported from the top level Gtk module anyway.
07:12:01 <Micket|Coding> Hi, i seem to have problems getting QuickCheck to work, or rather its arbitrary methods, i seem to be getting error messages like this
07:12:02 <Micket|Coding> Warning: No explicit method nor default method for `coarbitrary'
07:12:02 <Micket|Coding>          In the instance declaration for `Arbitrary Card'
07:12:37 <Micket|Coding> In a file i've recieved from th teacher in the course im taking. And there shouldnt be any errors in that file.
07:13:29 <dcoutts> Micket|Coding, it's only a warning
07:14:09 <Micket|Coding> ah..
07:14:38 <Micket|Coding> I also get ALOT of these
07:14:38 <dcoutts> Micket|Coding, it'll probably still work, since it's probalby not using the coarbitrary function. You'll get a genuinre error message at runtime if it ever does use coarbitrary however.
07:14:39 <Micket|Coding> Maps.o(.text+0x1b1):fake: undefined reference to `__stginit_TestziQuickCheck_'
07:14:58 <dcoutts> Micket|Coding, try adding -package QuickCheck to the ghc command line
07:15:18 <Micket|Coding> ok thanks
07:16:00 <dcoutts> Micket|Coding, if you use ghc --make you normally don't have to specify all the -package Thing bits
07:24:48 <Micket|Co> wopps
07:26:15 <dcoutts> xerox, simona, it's all in cvs now, feel free to see if it builds for you
07:26:22 <dcoutts> I'll add the cairo demos now...
07:26:50 <xerox> Col :-)
07:26:52 <xerox> Cool :-)
07:27:44 <dcoutts> xerox, the StarAndRing.hs demo is not compiling for me
07:27:56 <dcoutts> oh, maybe that's my fault...
07:28:00 <dcoutts> wait a sec
07:28:28 <dcoutts> xerox, yep my fault :-)
07:28:33 <xerox> np :-)
07:39:33 <reppie[^_^]> someone should write a program like lint, but which checks lock order and that you always unlock
07:40:27 <reppie[^_^]> don't you agree
07:41:03 <dcoutts> reppie[^_^], yeah, so long as I don't have to write such a program. ;-)
07:41:13 <reppie[^_^]> hehe
07:41:14 <xerox> What is lint?
07:41:34 <reppie[^_^]> man is your friend
07:41:36 <reppie[^_^]> :P
07:41:54 <xerox> I have no lint either installed or in the repos
07:41:58 <reppie[^_^]> DESCRIPTION
07:41:58 <reppie[^_^]>      The lint utility attempts to detect features of the named C program files
07:41:58 <reppie[^_^]>      that are likely to be bugs, to be non-portable, or to be wasteful.  It
07:41:59 <reppie[^_^]>      also performs stricter type checking than does the C compiler.
07:42:16 <xerox> I see
07:42:37 <Beelsebob> :)
07:42:43 <Beelsebob> updated SEE mode
07:42:53 <Beelsebob> that actually deals with data and type defs
07:42:57 <reppie[^_^]> checking for lock order shouldn't be too hard
07:43:12 <reppie[^_^]> if you don't consider function pointers etc
07:43:32 <dcoutts> reppie[^_^], I think the linux kernel folk have a tool that does some limited checking of this. There are academic research projects that try to do this more fully.
07:43:48 <reppie[^_^]> dcoutts yes, but i can't find it
07:44:45 <simona> If you want to find deadlocks in your Haskell program, you could google for "Runtime Verification of Concurrent Haskell Programs"
07:44:46 <reppie[^_^]> freebsd has also a thing that checks lock order, but at run-time
07:44:58 <reppie[^_^]> simona C, unfortunately :)
07:45:09 <xerox> I wonder what does lint say of its sources ;)
07:45:20 <reppie[^_^]> probably nothing!
07:46:32 <dcoutts> reppie[^_^], the linux kernel tool is called "sparse" and was written by Linus.
07:47:28 <reppie[^_^]> dcoutts sparse does something else :(
07:48:42 <dcoutts> reppie[^_^], oh, I thought you could specify what locks should be held on entry to a function and it'd make some attempt at seeing if it's true.
07:48:56 <reppie[^_^]> dcoutts i could be wrong
07:48:59 <reppie[^_^]> i'll check it out
07:49:12 <dcoutts> I could be wrong too :-)
07:50:17 <reppie[^_^]> http://www.ussg.iu.edu/hypermail/linux/kernel/0410.3/2846.html
07:50:22 <reppie[^_^]> you are right
07:52:46 <simona> There's the group around Dawson Engler at Stanford university. They built tools like ARCHER and RacerX with which they found many locking flaws in the Linux and FreeBSD kernel. Their tools are not sound, though.
07:53:45 <reppie[^_^]> do you mean coverity?
07:54:09 <reppie[^_^]> the flaws they found were not lock related
07:54:16 <reppie[^_^]> afaik, at least
07:54:27 <reppie[^_^]> just stuff like potential NULL dereferences etc
07:55:04 <dcoutts> apparently SUN use a lock analysis tool in Solaris (apparently they've got hideously complex locking)
07:55:14 <reppie[^_^]> dcoutts yah
07:56:30 <reppie[^_^]> freebsd has very complex locking as well, and the runtime checking is very slow
07:57:05 <reppie[^_^]> it used to make the machine like 300% slower
07:57:38 <reppie[^_^]> but just a few days ago, someone made it a lot better, with only a ~20% performance decrease
08:09:45 <simona> reppie: yes, I probably mean that.
08:11:19 <Lemmih> dons: Ping.
08:20:15 <basti_> hi
08:20:26 <Beelsebob> lo basti
08:20:43 <basti_> tristate!
08:20:54 <Beelsebob> heh
08:22:18 * basti_ is going to hold a talk about STM (not only haskell stm though)
08:25:35 <xerox> State Monad? :)
08:25:48 <jlouis> software transactional memory
08:25:51 <basti_> no software transactional mem
08:25:59 <jlouis> ;)
08:26:03 <jlouis> read the paper ;)
08:26:03 <xerox> SMP stuff?
08:26:10 <jlouis> threading stuff rather
08:26:32 <jlouis> consistency stuff to be precise
08:26:51 <basti_> but it can be extended to any sort of concurrency, in principle
08:27:05 <basti_> its a way to lock-free programming.
08:27:34 <Lemmih> (with locks under the hood)
08:27:48 <basti_> yup
08:27:58 <basti_> but you can assure that they won't deadlock any
08:28:08 <basti_> and some day you might be able to abandon them
08:30:05 <TheHunter> surely you can implement locks using stm.
08:31:12 <basti_> yes
08:31:17 <basti_> but you don't HAVE to ;)
08:38:28 <Beelsebob> tum tee tum... hat takes far too long to build on this machine
08:38:40 <ndm> using GHC?
08:38:43 <Beelsebob> yeh
08:38:53 <ndm> you need a faster compiler :)
08:39:03 <Beelsebob> indeed... prod tom will you?
08:39:15 <ndm> i have been, but he's been distracted by scrabble
08:39:22 <Beelsebob> um... k?
08:39:30 <Beelsebob> found an online scrabble thing?
08:39:34 <ndm> he wants to build the worlds best scrabble playing computer
08:39:37 <Beelsebob> or has Sandra started playing?
08:39:42 <Beelsebob> oh, okay
08:39:45 <ndm> he's actually not playing scrable much, if at all
08:40:01 <Beelsebob> because his computer always beets him?
08:40:12 <ndm> his computer is well above anyone we know
08:40:19 <ndm> its regional level, he's going for world level
08:40:26 <Beelsebob> cool
08:41:09 <basti_> :-o
08:41:15 <ndm> so are you starting on visual hat right now?
08:41:34 <Beelsebob> at the mo, I'm making hat-delta do more than hat-detect
08:41:55 <ndm> all that hat tools seem to be incompetition to do more than the others
08:41:58 <Beelsebob> it's on my to do list... so you may well get there first
08:42:05 <dcoutts> Beelsebob, visual hat? using gtk? :-)
08:42:52 <Beelsebob> dcoutts: no... I'm going to do a UI bridge for hat so that I can write a cocoa one, and someone else can write a gtk/wx one, and all of them can rely on the same code
08:43:03 <Beelsebob> so that each tool isn't duplicated into 3 or 4 versions
08:43:12 <dcoutts> Beelsebob, right, sounds sensible
08:43:25 <Beelsebob> but neil may well beat me to doing it
08:44:16 <dcoutts> Beelsebob, well for the gtk version you can use our nice new cairo drawing api :-)
08:44:22 <Beelsebob> :)
08:45:09 <Beelsebob> hmm... this is why I love cocoa... I don't have to bother with ATSUI
08:45:49 <dcoutts> cairo has a ATSUI backend. Hoeever I have no idea what ATSUI is. :-)
08:46:08 <Beelsebob> Apple Type Services of Unicode Imaging
08:46:12 <Beelsebob> it's OS X text renderer
08:46:17 <dcoutts> Ah
08:46:53 <dcoutts> cairo's got a quartz backend too (and win32) so it's all cross-platform niceness.
08:47:07 <Beelsebob> nice :)
08:47:21 <dcoutts> now we jsut need a native port of gtk for OSX and we'd be set
08:47:29 <Beelsebob> heh... not really
08:47:39 <dcoutts> ?
08:47:51 <Beelsebob> I'm affraid I'm of the opinion that UIs are the only things that should *not* be cross platform
08:48:27 <Beelsebob> cross platform GUIs always require a comprimise, and end up being glitchy and not doing what the user expects on all platforms
08:48:31 <dcoutts> well gtk seems to look just fine on win32
08:48:52 <dcoutts> though it does not use the 'normal' win32 file chooser
08:48:58 <tuomov> cross-plaform (G)UIs just need to be programmed at a much more abstract level than a widget set
08:49:02 <dcoutts> but yeah, you're right it's always tricky
08:49:10 <Beelsebob> that's exactly what I mean
08:49:25 <Beelsebob> similarly, toolbars behave entirely differently on OS X and windows
08:49:41 <dcoutts> true, there isn't any genuinly cross platform widget set, not even wxWidgets
08:50:20 <Beelsebob> hence, I'm making an abstraction at the level of "this view needs two views, here are the commands for grabbing their contents, and it responds to these commands"
08:50:33 <dcoutts> Beelsebob, actually that one's not so hard, the top level menu bar for a window can be marked as the one that ends up at the top of the screen on OSX.
08:50:34 <Beelsebob> and then you can attach different UIs to it (including a text based one)
08:50:52 <Beelsebob> dcoutts: no... the toolbar, not the menu bar
08:50:59 <dcoutts> Beelsebob, ok
08:51:10 <tuomov> Beelsebob: I'd like to take that even further: to semi-automagic generation of UIs
08:51:16 <dcoutts> Beelsebob, yes that's a good approach, it's just more work
08:51:21 <Beelsebob> tuomov: yes... I'm planning that
08:51:30 <dcoutts> Yi is taking the same approach I believe
08:51:34 <Beelsebob> essentially default UIs
08:51:39 <tuomov> http://iki.fi/tuomov/vis/ is a write-up I did on that
08:51:53 <Beelsebob> but with the abbility to extend it if you want to make the tool slightly more individual
08:52:15 <Beelsebob> ah, I was wondering if anyone had done anything like this
08:52:27 <dcoutts> the danger with coding a gui on a very abstract level is that it can end up looking bad on all platforms
08:52:40 <dcoutts> GUIs still need tweaking on each platform to look right
08:52:48 <Beelsebob> dcoutts: that's exactly what I'm trying to aviod
08:52:56 <Spark> the problems i see are making it look good, and making efficient use of screen space, both of which would be hard to do without human intervention
08:52:57 <Beelsebob> the UI is platform specific
08:53:02 <Beelsebob> the information it displays is not
08:53:08 <dcoutts> Beelsebob, so you have a UI backend per-platform, yes
08:53:17 <Beelsebob> dcoutts: yes
08:53:25 <Beelsebob> but quite a lightweight one
08:53:31 <dcoutts> people like to believe that they can avoid that extra work
08:53:55 <Beelsebob> yeh, I know
08:54:01 <Beelsebob> unfortunately, they're wrong
08:54:17 <simona> dcoutts: Duncan, I can't compile since I have Gtk 2.7.6 and pango 1.9.0 installed. Maybe I come back to that later, but probably not. I'm offline for 4 days.
08:54:31 <dcoutts> Beelsebob, well, half the time they're nearly right :-)
08:54:44 <dcoutts> simona, ok no probs
08:54:46 <Beelsebob> dcoutts: indeed... so... wrong
08:54:52 <dcoutts> Beelsebob, indeed :-)
08:54:55 <Beelsebob> :)
08:55:31 <Beelsebob> I have no problems with people sticking together prototype UIs because they want to do some research, and don't care about user experiance
08:56:00 * SamB wonders why length ['\0'..] is so quick
08:56:06 <Beelsebob> but my aim is to make this tool nice and usable for lots of people... which means that I do have to make sure it's all pretty, and does what they expect
08:56:39 <Beelsebob> yay... prelude basic has finally compiled
08:58:31 <tuomov> had to answer to a phone..
08:58:59 <Beelsebob> someone in the comentary box has to too
08:59:09 <Beelsebob> how unproffesional
08:59:21 <tuomov> anyhow, the basic idea of Vis is for programs to let the UI backend know that to execute the standard UI command "std/file.open" or something, and the UI backend can then automatically put this command accessible in a standard place for that kind of UI
08:59:39 <tuomov> program-specific UI components may be also automagically placed, but not necessarily very wisely
08:59:55 <tuomov> for this there could be program-specific stylesheets for each UI type for their placement
08:59:56 <Beelsebob> yeh, that sounds like what I'm aiming at
09:00:48 <tuomov> so it's kinda like semantic html + css
09:01:02 <Beelsebob> e.g. A hat view (hat-explore say) may say... I have two views, here are functions to grab each one, one should be wide and not very tall... And the UI gets layed out a as a split view, with one above the other
09:01:28 <Beelsebob> or... in a text based UI it'll print 8 lines of one, a separator, and then the other
09:01:43 <dcoutts> tuomov, but there are things about program behaviour beyond the widget look and layout that differ
09:02:26 <tuomov> of course, and the Vis plan includes command parametrisation stuff too
09:02:56 <dcoutts> eg on there is drag&drop integration, proper clibpoard interoperability
09:03:00 <Beelsebob> dcoutts: indeed... hence they will also say "I respond to the command `look inside the expression', a suitable shortcut for this might be `d'"
09:03:32 <dcoutts> diaog button order, instant apply of settings vs. having an "apply" button, etc etc..
09:03:34 <Beelsebob> and a cocoa view might add a toolbar button, while a text based one might add a command ":d"
09:03:52 <Beelsebob> dcoutts: yep, that's why you seperate that part of the UI out
09:04:04 <Beelsebob> different implementations for different platforms
09:04:04 <tuomov> dcoutts: dialog button order is way too low-level already!
09:04:33 <Beelsebob> indeed... they're different on OS X and windows
09:04:40 <dcoutts> tuomov, ok, but the GNOME instant apply thing is different on a higher layer
09:04:44 <tuomov> programs must make no assumption that there are dialog buttons even!
09:05:13 <Beelsebob> dcoutts: exactly, that's why the program doesn't specify it
09:05:26 <Beelsebob> that's part of seperated UI code
09:05:31 <tuomov> dcoutts: the answer to that is to have a standard "settings" hierachy, and let the UI backend generate the settings dialogs or whatever for it
09:06:00 <dcoutts> tuomov, ok, but one has to be carful when designing the data model not to make too many assumptions
09:06:27 <dcoutts> the GNOME instant apply things requires that you can get notifications of configuration changes
09:06:48 <dcoutts> so your prefs/settings data model would have to support it
09:06:53 <tuomov> what is put into the settings hierarchy is callbacks for changes in those settings and so on
09:06:59 <tuomov> (rtfarticle :)
09:06:59 <dcoutts> these things aren't immediately obvious
09:07:08 <dcoutts> tuomov, ok ;-)
09:07:10 <Beelsebob> dcoutts: yeh... but that's a matter of the UI asking for it's content again, possibly with different arguments
09:07:44 <dcoutts> Beelsebob, no it requires the model to inform it of changes
09:07:49 <tuomov> not that I'm certain that what is outlined in the vis paper is really enough. once one starts implementing I'm sure there are some problems to solve
09:08:00 <tuomov> I'm sure that it can be done, though
09:08:04 <Beelsebob> dcoutts: no... the settings dialog is part of the UI
09:08:14 <Beelsebob> it is perfectly capable of notifying itself
09:08:31 <dcoutts> Beelsebob, right but it places requirements on the underlying app's data model
09:08:37 <Beelsebob> why?
09:08:57 <dcoutts> settings shared between apps, or different parts of the same app
09:09:12 <tuomov> different parts what?
09:09:19 <Beelsebob> yeh... but that's all outside the abstract level of what the app does
09:09:38 <Beelsebob> all the app needs to know is what to do with various settings
09:09:44 <Beelsebob> the UI tells it what settings to use
09:09:45 <dcoutts> not if you're tring to integrate with the platform, you've got to follow some of the platforms settings
09:09:53 <Beelsebob> uhhuh
09:10:01 <tuomov> the apps binds a function to a possibly standardised name to do a thing. The UI makes it available in the appropriate places.
09:10:04 <Beelsebob> so... e.g. in OS X there's instant apply
09:10:20 <Beelsebob> and the user clicks a button in the prefs
09:10:32 <Beelsebob> so... the app writes to defaults
09:10:39 <Beelsebob> re-draws it's UI
09:10:54 <Beelsebob> another UI gets notified of the defaults change
09:10:59 <Beelsebob> and updates it's UI
09:11:06 <Beelsebob> make sense?
09:11:34 <Lemmih> Hi CosmicRay.
09:11:48 <CosmicRay> morning lemmih
09:12:48 <dcoutts> Beelsebob, so that works for updating due to changes in system settings
09:12:56 <Beelsebob> uhhuh?
09:13:04 <Beelsebob> what other settings are there?
09:14:14 <dcoutts> Beelsebob, the case I was worried about was the prefs for the app which are managed by the UI-independent part. If they do not support this change notification thing then the app will not behave properly.
09:14:35 <Beelsebob> but that's my point... prefs are managed differently on different apps
09:14:40 <Beelsebob> sorry platforms
09:14:50 <Beelsebob> so they are *not* in the UI independant part
09:15:15 <dcoutts> but the core has to actually use some of these prefs
09:15:51 <Beelsebob> uhhuh... but all the core knows is that it's been asked "what do I need to display in this view" and been given the settings with which to answer
09:16:12 <dcoutts> so it has to support updating them willy nilly to support Win + OSX + KDE + Gnome prefs styles
09:17:18 <Beelsebob> well... in that the function for grabbing the contents of the UI is at an abstract level :: DisplayArea -> Settings -> Content
09:18:08 <dcoutts> I'm not sure that captures the data flow in how the setting get updated
09:18:12 <dcoutts> we're not getting anywhere :-) we both agree it's not trivial
09:18:21 <Beelsebob> indeed
09:19:01 <Beelsebob> all it needs is a function to grab "what should be displayed" and a function in the other direction saying "you need to display something new"
09:19:21 <dcoutts> sorry to cut this off, I need to get to the shops before they shut....
09:19:32 <Beelsebob> have fun :)
09:19:40 <dcoutts> ta :-)
09:34:34 <Pita> hi
09:34:40 <Pita> was http://meme.b9.com/cview.html?channel=haskell&date=today implemented in haskell?
09:38:13 <Lemmih> I doubt it.
09:38:28 <Pita> How easy is FFI in Haskell?
09:38:42 <Lemmih> Very easy.
09:38:44 <Lemmih> (:
09:39:04 <basti_> quite, yes.
09:39:39 <beelsebob_> stupid client
09:39:45 * shapr wishes everyone used darcs
09:39:55 <basti_> for chatting shapr?
09:40:13 <shapr> I wish everyone used darcs instead of cvs/svn/etc
09:40:18 <basti_> ah.
09:40:33 <Pita> Where can I find benchmark info on haskell?
09:41:03 <shapr> I can wave my pom-poms if it'll help your decision.
09:41:25 <basti_> Pita: haskell is not about benchmarks
09:41:31 <beelsebob_> pita: you a mac coder?
09:41:39 <shapr> But if you want benchmarks, there's the Alioth Shootout.
09:41:39 <Pita> yeah
09:41:42 <Pita> i am a mac user
09:41:51 <Lemmih> Pita: There are some pretty useless micro-benchmarks on the Great Langauge Shootout.
09:41:52 <Pita> Beelsebob: does this matter?
09:41:54 <beelsebob_> thought I recognised you from macdev
09:41:57 <beelsebob_> :)
09:42:11 <Pita> does haskell work well on mac?
09:42:23 <beelsebob_> pita: it doesn't... other than if you use SEE, I updated the see mode today
09:42:29 <beelsebob_> it does... very well
09:42:37 <gzl> Pita: there are a few hiccups here or there, but by and large it's fine
09:42:39 <shapr> Sadly, the Alioth Shootout doesn't benchmark functionality for a certain amount of programmer time. That's where Haskell really shines.
09:43:53 <beelsebob_> yeh... or rather programmer time for a certain peice of functionality... if you define the amount of time you have the work grows to fill it
09:44:02 <beelsebob_> ... and probably another 2 months as well
09:44:06 <shapr> Yeah, true that.
09:44:22 <shapr> The first 90% of the work takes the first 90% of the time, and the last 10% of the work takes the last 90% of the time.
09:44:29 <beelsebob_> haha
09:44:37 <tuomov> very true
09:44:44 <basti_> *g*
09:44:50 <shapr> Pita: Do you have any specific questions about Haskell? I can give you the short intro if you want.
09:46:38 <Pita> i am quite worried about FFI
09:46:47 <Pita> because there are quite few C lib i would like to use
09:46:56 <beelsebob_> the FFI is no problem at all
09:46:57 <shapr> FFI in Haskell is wonderful.
09:46:58 <Pita> normally do you have to write wrappers?
09:47:04 <Pita> is there a link to FFI in haskell?
09:47:11 <xerox> @google c2hs
09:47:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
09:47:14 <xerox> This tool is great.
09:47:16 <beelsebob_> the FFI is part of the Haskell98 adendums
09:47:34 <beelsebob_> pita: also... if you want to use cocoa... go look at HOC
09:47:42 <beelsebob_> (hoc.sourceforge.net)
09:48:17 <basti_> Pita: ffi is very simple, most of the times
09:48:28 <Pita> does Haskell compile ?
09:48:32 <basti_> Pita: depending on your situation there might be the one or other obstacle, but most goes well
09:48:32 <Pita> or is it interpreted?
09:48:35 <basti_> yes it does
09:48:36 <beelsebob_> either
09:48:42 <Pita> compile to native?
09:48:45 <beelsebob_> yep
09:48:55 <beelsebob_> you want either nhc, or ghc
09:49:00 <gzl> probably ghc
09:49:16 <basti_> ghc is pretty solid and comes with a good interface
09:49:21 <shapr> Pita: Here's how to use the FFI directly - http://www.haskell.org/hawiki/FfiCookbook
09:49:30 <beelsebob_> at the moment, ghc produces faster code, and supports more extensions.  nhc will soon support debugging much better
09:50:07 <shapr> Pita: There are tools than can automatically generate the wrapper calls, c2hs, HsFFIg, greencard, and several others.
09:50:25 <xerox> I'd hardly suggest using c2hs, it has cool features.  One for all, it checks the consistency between your Haskell and the C datatypes.
09:50:35 <shapr> Pita: You might want to start here - http://www.haskell.org/hawiki/FfiTutorial
09:50:41 <xerox> Never tried HsFFIg tough.
09:53:50 <xerox> ...thanks to the, erhm, "backstage":  with "I hardly suggest" I meant "I do suggest it!!".
09:54:29 <shapr> hoi goron, how's the webmonkey business treating you?
09:54:46 * shapr is earning his own web bananas at the moment.
09:55:36 * xerox can finally rest his arms
09:56:47 <xerox> I would like to share the email with you but sourceforge's web mailinglist archives are slow to sync...
09:58:29 <jyp> xerox, you mean you strongly suggest c2hs ?
09:58:36 <xerox> jyp: exactly!
09:58:44 <jyp> Ok :)
09:59:15 <basti_> i do too
09:59:39 <basti_> although i didn't advance lots in my attempts to slurp csound plugins into ah haskell environment
10:01:10 * jyp should have read 2 lines ahead before asking stoopid question :p
10:01:35 <basti_> shapr: I'm a hacker chasing monkey now
10:01:37 <xerox> jyp: No!  Thanks for the correction, I didn't know how to express it :)
10:02:05 * jyp feels better now :)
10:07:51 <shapr> basti_: You got a security job?
10:08:27 <shapr> I'd like to get a penetration testing job.
10:08:33 * SamB wonders why the c2hs package in testing still depends on ghc5
10:08:47 <shapr> No one has updated it in years.
10:08:58 <SamB> that would do it, I guess...
10:08:59 <basti_> shapr: no i got raised from webmonkey to "security"monkey when i caught a hacker on his IRC server
10:09:03 <shapr> Someone debian-haskell has a new package, not sure if it's ready yet.
10:09:12 <basti_> if you can call anything that has to do with phpbb "security"
10:09:20 <shapr> basti_: Oh, I see.
10:10:06 <SamB> so basically you deal with gross insecurity?
10:10:23 * basti_ nods
10:10:28 <basti_> as i said, monkey job
10:11:26 <Beelsebob> buh
10:15:19 <Philippa> oh dear
10:15:41 <Philippa> really, I swear the #1 reason I should do more work on Flippi is so there'd be an easy way to build reasonably secure blogs, boards etc on top of it
10:15:58 <Beelsebob> hmm? has LJ let you down?
10:16:15 <basti_> Philippa: yes.
10:16:19 <basti_> Philippa: please, do so. :D
10:17:03 <goron> @where Flippi
10:17:03 * jyp begs too :)
10:17:04 <lambdabot> http://www.flippac.org/projects/flippi/
10:18:09 <goron> Philippa: That works pretty fast. Good server.
10:18:49 <Philippa> Beelsebob: LJ's OK, but hey
10:18:59 <Philippa> not my server, but hey
10:19:10 <Beelsebob> uhuhh
10:19:25 <Beelsebob> I wish LJ offered RSS feeds of blogs
10:19:32 <Beelsebob> then I could syndicate all mine together
10:19:32 <basti_> Philippa: strange, on your page, radialcontext (firefox "mousegesture" like plugin) goes wacko
10:20:55 <goron> Firefox Suxors!
10:21:42 <Philippa> basti_: eh? Where?
10:21:48 <Philippa> or rather, what on?
10:21:49 * Beelsebob kicks goron
10:21:54 <Philippa> the CSS does something mildly odd I guess
10:22:07 <basti_> that will be the cause then
10:22:13 <basti_> radialcontext on linux firefox
10:22:15 <basti_> 1.0.4 i think
10:22:24 <basti_> no 1.0.6
10:23:36 <Philippa> what's it like if you disable the stylesheet?
10:23:40 <basti_> hmm
10:23:41 <Philippa> (it just centers the text and stuff)
10:23:51 <basti_> how would i do that?
10:24:48 <Philippa> dunno. RTFM :-) I think there's a little icon to click somewhere
10:25:04 <basti_> :D
10:25:05 <xerox> http://sourceforge.net/mailarchive/forum.php?thread_id=8063084&forum_id=44293
10:25:06 <xerox> Ta-da!
10:25:20 <basti_> i mean its not a big thing anyway
10:27:14 <Philippa> xerox: 'grats
10:27:22 <xerox> Thanks Philippa :-)
10:27:48 <Beelsebob> is there anything I should know before attemptiong to build ghc 6.5 from source?
10:28:09 <basti_> Beelsebob: you should do it the recommended way (as in, extract a part of the fptools branch)
10:28:30 <Beelsebob> basti: where's the recommended way documented?
10:28:32 <goron> "You have 3199 unread messages"... How could it ever have gotten this far?
10:28:48 <xerox> goron: spam?
10:28:54 <goron> xerox: yeah
10:28:59 <xerox> :(
10:29:01 <Muad_Dibber> goron: popular
10:29:03 <basti_> Beelsebob: mmmletmelook
10:29:19 <goron> I switched e-mail address, but I look at in once in a while...
10:29:35 <Lemmih> @google GHC cvs cheatsheet
10:29:36 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
10:29:45 <goron>  \s\in\it
10:29:46 <basti_> http://www.haskell.org/ghc/docs/latest/html/building/ < do a subset of that
10:29:48 <basti_> ohh
10:29:54 <ndm> goron, google for your email address
10:30:10 <Beelsebob> cool, chears
10:30:12 <ndm> if you find it, then start removing it - it cuts down spam dramatically
10:30:39 <goron> ndm: It's the Haskell mailinglist....
10:30:56 <goron> ndm: And some debian mailinglist...
10:31:00 <xerox> ahah
10:31:10 <xerox> I found mine in lambdabot darcs repo patches.
10:31:18 <goron> The rest obscures my e-mail address.
10:31:33 <goron> Thank you Haskell list maintainer!
10:31:33 <ndm> yeah, i have one entry in the hugs-cvs mailing list text archives
10:32:56 <goron> I guess a system where you should solve a simple problem before you can really send an e-mail should work.
10:33:12 <basti_> it would break mailing lists though
10:33:39 <goron> basti_: Mailing lists need a different appoach, yes.
10:33:53 <goron> basti_: I think machine learning works better on mailing lists.
10:34:03 <goron> basti_: Since the topic is the same all the time.
10:34:10 * basti_ nods
10:34:26 <goron> Ok, spam is solved. Next problem, please...
10:34:28 <goron> ;)
10:34:29 <basti_> ;)
10:40:43 <FrederikEaton> instead of HaskellDB, wouldn't it be better to have a mapping from a prolog-like language to SQL? you could extend your logical variables with ranges pretty easily it seems
10:40:55 <FrederikEaton> of course all within haskell
10:41:24 <FrederikEaton> cf "Typed Logical Variables in Haskell", Claessen & Ljunglof
10:41:53 <dcoutts> FrederikEaton, hmm, not so obvious since Prolog is a significantly more powerful language than SQL. SQL is not Turing complete.
10:42:13 <FrederikEaton> it isn't?
10:42:18 <goron> FrederikEaton: No
10:43:08 <FrederikEaton> i challenge
10:43:31 <dcoutts> the very fact that it is not Turing complete is why it's such a good choice since it means that the implementer has more felxability to optimise than with a more powerful language. That's why Oracle make so much money.
10:44:06 <goron> "Query optimizers"
10:44:23 <Beelsebob> tum tee tum... I wonder how long ghc will take on this machine
10:44:42 <ski> FrederikEaton : have you looked at deductive databases (such as e.g. aditi) ?
10:44:50 <FrederikEaton> ski: no
10:45:26 <chucky> regarding turing completeness of SQL, it seems it is a tricky question: http://www.xslt.com/html/xsl-list/2002-07/msg00709.html
10:45:57 <ski> FrederikEaton : they more or less replace sql with a prolog-syntax, and allows recursive views (derived/intensional relations/database) (so they're turing complete)
10:47:07 <FrederikEaton> ski: i want compatibility with SQL databases, so i don't know how interested I am in that
10:47:21 <ski> FrederikEaton : but, instead of prolog's top-down tuple-at-a-time implementation, they use the usual database bottom-up set-at-a-time implementation (using fixedpoint for recursive rules)
10:47:25 <ski> ok
10:47:47 <FrederikEaton> ski: what does that mean?
10:48:48 <FrederikEaton> ski: i was thinking of making something which would map haskell datatypes to tables by expanding the sums
10:48:53 <FrederikEaton> into different tables
10:49:13 <FrederikEaton> but i think it would be hard to optimize
10:50:01 <ski> prolog (in database terms) processes one tuple at a time, while databases usually do a set of tuples at a time (so they can use e.g. join operations. this is more efficient for huge amounts of data)
10:50:12 <FrederikEaton> i.e. the easiest would be if you encounter a "Maybe a" to look it up in another table which will tell you if it is a Nothing or a Just. but that would be slow
10:50:39 <Philippa> have to admit, I often wish I knew more about RDBMS implementation
10:50:40 <ski> FrederikEaton : how would you map e.g. lists to tables, with that method ?
10:51:02 <Philippa> the most advanced undergrad course here gets as far as the possibility of query optimisation, but really that's no surprise
10:51:29 <FrederikEaton> ski: well does the prolog syntax or semantics rule out e.g. join operations? i think a syntax mapping should be fairly easy
10:52:13 <ski> hm, i think semantics more or less requires top-down depth-first semantics
10:52:16 <FrederikEaton> ski: you have "type" columns
10:52:29 <FrederikEaton> ski: but the syntax...
10:53:17 <FrederikEaton> ski: i mean, "constructor" columns. i haven't really thought it out. it might not work well with 'select' syntax
10:54:01 <ski> (anyway, it's the usual implementation)
10:54:38 * ski thinks 'select' syntax is ugly
10:54:54 <FrederikEaton> ski: each key has a "constructor" flag which tells you which table to look it up in. so a list would be a key into a table of Nil, or a table of Cons a (List a). the key is either 2 columns, or indexes a table with 2 columns, one of which tells which table to use, and the other of which indexes into that table
10:55:37 <ski> mhm
10:56:06 * FrederikEaton takes a shower
10:56:19 * ski hasn't really understood why databases don't like non-atomic values in tuples
10:57:04 <ski> FrederikEaton : then you have to create fresh indices, yes ?
11:02:21 <Philippa> non-atomic values in tuples makes for harder work, I guess
11:04:22 <ski> iirc 1NF is about only allowing atomic attributes .. so i wonder if it helps with normalization .. and how, then
11:14:54 <Beelsebob> @hoogle duplicates
11:15:08 <Beelsebob> hmm... apparently not
11:15:28 <Beelsebob> anyone know of a function for removing duplicates from a list
11:15:39 <ski> @type nub
11:15:39 <Cale> @hoogle nub
11:15:47 <lambdabot> bzzt
11:15:47 <lambdabot> List.nub :: Eq a => [a] -> [a]
11:15:47 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
11:15:48 <Beelsebob> cheers
11:16:37 <Cale> If the data are ordered, you can use  map head . group . sort
11:17:36 <Cale> also, making a Set out of the data might be appropriate in some cases
11:17:48 <Cale> @type Data.Set.fromList
11:17:50 <lambdabot> forall a. (Ord a) => [a] -> Data.Set.Set a
11:18:58 <Beelsebob> @type \x y -> filter (not . elem y) (nub x) ++ y
11:19:00 <lambdabot> bzzt
11:19:07 <Beelsebob> obviously note
11:19:08 <Beelsebob> not*
11:19:17 <Beelsebob> @type \x y -> (filter (not . elem y) (nub x)) ++ y
11:19:18 <lambdabot> bzzt
11:19:33 <Beelsebob> @type \x y -> filter (not . (flip elem) y) (nub x) ++ y
11:19:34 <lambdabot> bzzt
11:19:37 <Beelsebob> buh
11:19:55 <ndm> bob, what are you trying to do?
11:19:56 <Cale> @type \x y -> filter (not . (flip elem) y) (List.nub x) ++ y
11:19:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:20:09 <Beelsebob> ah, chears
11:20:11 <Beelsebob> good
11:20:15 <ndm> those which have duplicates?
11:21:03 <Beelsebob> no... append two lists and remove duplicates... iff the second list doesn't have any
11:21:23 <Beelsebob> (duplicates that is)
11:21:49 <ndm> x \\ y
11:21:55 <ndm> @hoogle \\
11:21:56 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
11:22:03 <Igloo_> dons: I'm a member of which club?
11:22:05 <ndm> @eval "test" \\ "st"
11:22:06 <Cale> \\ just removes one list from another
11:22:09 <lambdabot> "et"
11:22:25 <Beelsebob> ah yeh... that would be sensible
11:22:30 <ndm> (nub x \\ y) ++ y
11:22:57 <Beelsebob> indeed
11:24:02 <RemiTurk> good evening
11:24:02 <Cale> that doesn't seem to be what Beelsebob described though...
11:24:07 <Beelsebob> no... it is
11:24:12 <Cale> oh, okay then :)
11:24:19 <Beelsebob> remove duplicates from the first list
11:24:21 <ndm> i was going from the code rather than the descriptions
11:24:28 <Beelsebob> remove any new duplicates that will be created
11:24:31 <Beelsebob> and then append
11:24:37 <Cale> ah, okay
11:25:16 <Cale> I thought it was that you wanted to remove duplicates only if the second list had  (nub y /= y)
11:25:34 <Beelsebob> ah, okay
11:25:48 <Beelsebob> sorry, yeh... I wanted the lists appended, and no duplicates
11:26:00 <Beelsebob> I just happened to know that the second list had no duplicates already
11:26:14 <Beelsebob> so I wanted to avoid checking it
11:26:30 <ndm> nub (x ++ y)
11:26:40 <Beelsebob> indeed... but that checks the second list
11:26:43 <ndm> less typing, more concise
11:26:48 <ndm> just less efficient
11:26:51 <Beelsebob> and seing as these lists are gonna get pretty long...
11:26:58 <ndm> are they actually sets?
11:27:05 <Beelsebob> the second one is
11:27:05 <ndm> i.e. order irrelevant
11:27:16 <Beelsebob> yes, ordering is irrelevant
11:27:20 <Cale> You should use Data.Set if you don't care about the order of the elements.
11:27:22 <ndm> you can do better with a sort
11:27:31 <ndm> then you can get O(n log n)
11:27:36 <Beelsebob> indeed
11:27:45 <Beelsebob> but there's no Ord instance
11:27:48 <ndm> if you do a sort on the first half, O (n log n)
11:27:50 <Cale> oh
11:27:52 <ndm> ah
11:28:03 <ndm> what are in these lists?
11:28:18 <Beelsebob> lists of semi-evaluated expressions
11:28:27 <ndm> hat?
11:28:30 <Beelsebob> yep
11:28:35 <ndm> they have Show?
11:28:39 <Cale> can you put an ordering on semi-evaluated expressions? :)
11:28:45 <Beelsebob> I could...
11:28:50 <Beelsebob> but it would be a hack
11:28:55 <ndm> Show gives Ord quite easily
11:29:02 <Beelsebob> ndm: true
11:29:14 <ndm> but it would give you O(n) on the whole list and O(n log n) on the inserted bit
11:29:15 <Beelsebob> a more efficient one would just be to use their file offset
11:30:13 <Beelsebob> I may do that
11:30:15 <RemiTurk> could someone verify the rather strange type I'm getting (at the top of http://haskell.org/hawiki/HaskellIrcPastePage)
11:30:19 <Beelsebob> ... once I check that this works
11:30:41 <RemiTurk> ... especially if one of you has a GHC from CVS running
11:32:15 <Cale> RemiTurk: I get the same result (from stable GHC)
11:32:55 <RemiTurk> I guess I'll have to file a new bug-report then :)
11:33:10 <TheHunter> 6.5.20050804:
11:33:15 <TheHunter> *Main> :t eq
11:33:15 <TheHunter> eq :: forall a. Equal a a
11:33:27 * RemiTurk guesses it's been fixed already :)
11:34:06 <RemiTurk> it's (almost) always nice to find bugs have been fixed already :)
11:34:22 <Cale> however, applying eq to [1,2,3,4,5] gives sensible a type error (Couldn't match `Equal a a' against `t -> t1')
11:34:33 <RemiTurk> (the "almost", as it can be quite frustrating to spend hours on a already-fixed bugreport ;))
11:34:34 <RemiTurk> indeed
11:34:38 <greenrd> RemiTurk: what type should it be?
11:34:42 <RemiTurk> Equal a a
11:34:55 <RemiTurk> greenrd: the type explicitly given to it
11:36:09 <greenrd> forall is confusing - does it mean "for all a", or does it mean "there exists a", or does it mean both under different interpretations?
11:36:34 <TheHunter> in this case it means for all.
11:36:45 <greenrd> In _this_ case?
11:36:49 <greenrd> What is the other case?
11:36:49 <RemiTurk> greenrd: yes
11:36:59 <RemiTurk> actually, it's the _only_ case in a newtype
11:37:10 <RemiTurk> existentials don't make sense (implementation-wise) in newtypes
11:37:19 <TheHunter> data Foo a = forall a. Show a => Foo a
11:37:50 <TheHunter> err, data Foo = forall a. Show a => Foo a
11:38:05 <TheHunter> it behaves like data Foo = Foo (exists a. Show a => a)
11:38:06 <RemiTurk> btw, I got the thing from some memory of a paper about implementing Data.Dynamic without unsafeCoerce
11:38:26 <TheHunter> RemiTurk, hugs can do existential newtypes.
11:38:34 <greenrd> TheHunter: ah I see
11:38:47 <Cale> It would be nice to have "exists" explicitly. GHC has hooks for parsing it iirc.
11:39:10 <RemiTurk> TheHunter: interesting, I guess hugs internally makes some sort of tuple for newtypes in that case then
11:39:11 <TheHunter> i reacted to that in the same way as you (makes no sense) but somebody actually conviced me that it does, for reasons i have forgotten :/
11:39:36 <TheHunter> i'm not sure hugs allows contexts.
11:40:26 <RemiTurk> TheHunter: I actually originally thought they _did_ make sense, but then I was told that, as newtypes are supposed _not to exist_ at runtime, that would be rather strange
11:40:43 <greenrd> so what is the difference between Equal a a and forall a. Equal a a?
11:40:54 * RemiTurk hopes his last sentence makes any sense
11:41:12 <TheHunter> yep, ERROR "test146.hs":1 - A newtype constructor cannot have class constraints
11:41:40 <TheHunter> greenrd, a is free in the former but not in the letter.
11:41:40 <RemiTurk> and btw, the goal of this particular newtype was to have a witness that 2 types are the same
11:42:03 <greenrd> TheHunter: Yes I know, but so?
11:42:27 <TheHunter> till 6.2 there was no difference at all.
11:42:44 <TheHunter> since 6.4 the latter brings a into scope in the body of the definition.
11:43:35 <TheHunter> RemiTurk, i recently used that trick to show that newtype-deriving and an extension to fundeps don't play well together.
11:43:40 <greenrd> TheHunter: That is not very intuitive.
11:43:52 <TheHunter> i know, but what are you gonna do.
11:44:04 <RemiTurk> TheHunter: I guess I'll have to look back that thread then ;)
11:44:06 <greenrd> But is the body of the defn the only thing it affects?
11:44:16 <greenrd> And if so, is it really a bug?
11:44:25 <TheHunter> even worse, foo :: (forall a. Equal a a) and foo :: forall a. Equal a a are different.
11:44:35 <greenrd> haha
11:44:38 <RemiTurk> eeks
11:44:45 <greenrd> why?
11:44:45 <RemiTurk> that sounds _really_ nasty
11:44:54 <greenrd> because of the scope?
11:45:00 <TheHunter> the first one doesn't scope a, right.
11:45:21 <TheHunter> greenrd, the bug was that it inferred a wrong type signature.
11:45:36 <RemiTurk> hm, it actually doesn't sound as nasty as it did the first second anymore, but still..
11:47:21 <Cale> I think that  "Equal a a", "forall a. Equal a a" and "(forall a. Equal a a)" should be equivalent when given as type signatures. (regardless of what they do now)
11:48:02 <RemiTurk> I occasionally vaguely think I'd actually prefer (restricted) typelevel-lambda's instead of foralls
11:48:18 <Cale> type level lambda would be very useful
11:48:42 <RemiTurk> I know, but I'm not even talking about cases in which they're necessary
11:48:51 <Cale> ah
11:49:34 <Cale> I think it should at least be possible to do things like /\ a b -> MyType b a
11:49:39 <RemiTurk> even in just simple rank-2 types, I seem to recall being quite puzzled until at some point I tried to understand it in terms of typelevellambdas
11:49:58 <Beelsebob> @hoogle a -> [a] -> (a -> a -> Bool) -> Bool
11:49:59 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
11:49:59 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
11:50:09 <Beelsebob> heh
11:50:21 <Beelsebob> yeh, that would make sense
11:50:31 <TheHunter> @type Data.List.elemBy
11:50:36 <lambdabot> bzzt
11:50:42 <TheHunter> @index elemBy
11:50:43 <lambdabot> bzzt
11:50:45 <RemiTurk> nopes
11:50:54 <Beelsebob> yeh... that's what I was hoping for
11:50:56 <RemiTurk> I think the report explicitly says it won't suply elemBy...
11:51:06 <Beelsebob> bugger
11:51:07 <Cale> The library does not provide elemBy, because any (eq x) does the same job as elemBy eq x would.
11:51:07 <Beelsebob> why not
11:51:19 <RemiTurk> elemBy = (any.)
11:51:31 <Beelsebob> yeh... unfortunately I have two sensible ways of comparing structures here
11:51:36 <RemiTurk> (minus the monomorphism-restriction)
11:51:40 <Beelsebob> and I want to pick and chose
11:51:46 <Beelsebob> choose*
11:52:08 <Cale> yeah, that's how you do it :)
11:52:28 <FrederikEaton> ski: fresh indices? i don't know. maybe i'll just implement it
11:52:32 <Cale> I liked the named instances proposal
11:52:51 <Beelsebob> yeh, that sounds useful
11:53:11 <RemiTurk> the report, 17.6: The library does not provide elemBy, because any (eq x) does the same job as elemBy eq x would. A handful of overloaded functions (elemIndex, elemIndices, isPrefixOf, isSuffixOf) were not considered important enough to have "By" variants.
11:53:12 <Cale> http://www.informatik.uni-bonn.de/~ralf/hw2001/4.html
11:53:53 <goron> RemiTurk: You are Remi on the mailing lists?
11:54:11 <RemiTurk> goron: I am
11:55:11 <Beelsebob> @pl \x y -> (fst x == fst y) && (snd x == snd y)
11:55:12 <lambdabot> ap (ap . ((&&) .) . (. fst) . (==) . fst) ((. snd) . (==) . snd)
11:55:16 <Beelsebob> bugger
11:55:57 <vegai> @botsnack
11:55:58 <lambdabot> :)
11:56:12 <TheHunter> hmm, that seems similar to scala's views.
11:56:43 <basti_> @pl \(x,y)->(y,x)
11:56:44 <lambdabot> uncurry (flip (,))
11:56:55 <basti_> @pl (==).(\(x,y)->(y,x))
11:56:56 <lambdabot> (==) . uncurry (flip (,))
11:57:01 <basti_> Beelsebob: how about that?
11:57:07 <basti_> or no
11:57:10 <basti_> even (==)
11:57:18 <Beelsebob> eh?
11:57:23 <Beelsebob> how does that work?
11:57:23 <basti_> i thought you did crossover comparison
11:57:24 <basti_> but you didnt
11:57:29 <Beelsebob> oh, okay
11:57:40 <basti_> actually i think == does exactly what you wants on tuples
11:57:46 <Beelsebob> I know == would just do what I wanted
11:57:47 <RemiTurk> @pl \eq conv x y -> conv x `eq` conv y
11:57:48 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:57:50 <basti_> oh ok
11:58:04 <basti_> then we could lift == to the (,) monad
11:58:07 <Beelsebob> but what I actually wanted was \x y -> (fst x == fst y) && (snd x =|= snd y)
11:58:08 <RemiTurk> call that pointless...
11:58:10 <Beelsebob> so it won't
11:58:13 <basti_> oh ok
12:00:36 <goron> RemiTurk: Yeah, it's full of points, it should be called pointfull...
12:01:30 * RemiTurk leaves to dinner
12:01:43 <RemiTurk> s/to/for/ I guess
12:01:44 <basti_> thats dots not points
12:01:46 <Cale> what was the name for types defined specific to each instance of a class?
12:01:56 <RemiTurk> pointless = dotfull
12:01:57 <RemiTurk> :)
12:01:59 <basti_> points are the things between lambda variables and the bodies.
12:02:13 <RemiTurk> ahh
12:02:17 <Cale> was it just instance types?
12:02:33 <basti_> Cale: are you talking about fundeps?
12:02:48 <RemiTurk> bye
12:03:10 <goron> basti_: you mean like "->" ?
12:03:21 <basti_> yes like "->"
12:03:33 <basti_> just that some people render it "."
12:03:58 <basti_> and not as a small circle at "m height", which are the dots in the pointless rendering.
12:04:27 <ski> (FrederikEaton : i just meant that it's not so declarative to generate them)
12:06:58 <beelsebo1> really weird it getting dark at 8 here
12:07:51 <Cale> basti_: It might be subsumed by fundeps
12:09:24 <basti_> Cale: existentials come to mind too
12:09:48 <basti_> but i don't know of a way to specify types in dependence of an instance
12:09:59 <Cale> basti_: there was a proposal
12:11:43 <basti_> ah
12:12:00 <goron> basti_: Oh, ok, the "circles" are the points in (f.g) x
12:12:43 <Akshaal> bug in ghc? import qualified Data.List as List; concat=3
12:13:29 <Akshaal> Ambiguous occurrence `concat' It could refer to either `X.concat', defined at test.hs:5:0 or `GHC.List.concat', imported from Data.List at test.hs:3:0-33
12:13:34 <Beelsebob> hmm... if I reconfigure ghc with a new prefix, do I have to build again?
12:13:36 <basti_> goron: yes.
12:13:40 <basti_> goron: function concatenation
12:13:43 <Beelsebob> or will just installing work?
12:14:06 <Igloo_> Akshaal: You need to   import Prelude hiding (concat)
12:14:46 <Akshaal> Igloo_: I know it. But message says that concat imported in line 3 of test.hs, where qualified import occured
12:15:08 <Igloo> Ah, yes, good point
12:16:23 <Akshaal> Can anybody test it with 6.4.1 from CVS?
12:17:16 <liyang> Akshaal: concat can also come from Prelude (as well as Data.List.)
12:18:10 <Akshaal> liyang: it cannot come from Data.List becouse Data.List imported as qualifed List module
12:18:24 <liyang> Akshaal: no, I'm saying it came from Prelude.
12:20:39 * Akshaal thinks it is a bug in ghc error message
12:23:00 <liyang> as I understand it, Prelude is always implicitly imported. If you want to hide things that come from the Prelude you must add an import line for it explicitly.
12:23:51 <Akshaal> liyang: I know.
12:24:52 * SamB loves pattern match type errors. Yes, really!
12:25:08 <Philippa> of course, the Prelude probably yanks the values from Data.List anyway
12:25:12 <xerox> Good evening.
12:27:40 <Beelsebob> :o
12:27:52 * Beelsebob expected the first approach to hat-delta to work well
12:27:55 <Beelsebob> ... but not that well
12:28:14 <Beelsebob> algorithmic session: 15 questions
12:28:20 <Beelsebob> delta session: 3 questions
12:28:33 <Beelsebob> and I haven't even implemented the good method yet
12:33:30 <goron> SamB: How much do you pay for them?
12:46:15 * SamB wonders what goron meant about paying
13:03:34 * Beelsebob yawns
13:11:04 * beelsebob_ yawns too
13:30:56 <FrederikEaton> "This wiki is not enabled for mail processing. Contact the owner of the wiki, who can either enable email, or remove the "Subscribe" icon."
13:31:18 <FrederikEaton> http://haskell.org/hawiki/
13:32:24 <Beelsebob> @seen shapr
13:32:25 <lambdabot> shapr is in #haskell.se and #haskell. Last spoke 3 hours, 23 minutes
13:32:25 <lambdabot> and 4 seconds ago.
13:32:53 <FrederikEaton> is he the owzer?
13:32:55 <FrederikEaton> n
13:32:59 <Beelsebob> indeed
13:35:17 <Micket|Co> Oh, i give up! whats the easiest way to get a random Int without having to specify a seed for a random generator, to pick the seed from the time or something.
13:35:39 <xerox> @index random
13:35:40 <lambdabot> System.Random
13:35:45 <xerox> @docs System.Random
13:35:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Random.html
13:36:13 <xerox> Prolly, randomIO.
13:36:20 <xerox> @type System.Random.randomIO
13:36:24 <lambdabot> forall a. (System.Random.Random a) => IO a
13:42:07 <FrederikEaton> can i make a FredTestPage on the hawiki and then delete it or will people get pissed off?
13:42:38 <Lemmih> You can't delete pages.
13:43:05 <FrederikEaton> uh-oh
13:44:12 <xerox> Micket|Co: was it OK?
13:46:37 <Philippa> there's a SandBox if that helps?
13:47:44 <TheHunter> if you want to test something that isn't possible using the sandbox, go ahead and create that page, someone will delete it eventually if you put "delete me" or something on that page.
13:47:55 <FrederikEaton> ok
13:47:58 <FrederikEaton> i saw the sandbox
13:48:15 <FrederikEaton> i wanted to practice for the cabal design stuff
13:52:02 <Micket|Co> xerox, well actaully, that IO part bugs me :/
13:52:13 <xerox> Micket|Co: what would you expect?
13:52:40 <Philippa> you can't have a proper RNG that doesn't take a seed and isn't in the IO monad or something similar
13:52:59 <Micket|Co> I dont expect anything (im rather new to this)
13:53:23 <Micket|Co> thats why i thought about seeding from the clock
13:53:26 <Micket|Co> or something similiar
13:53:28 <Philippa> (because it'll need /some/ kind of seed to avoid being the same thing every time, which it extracts from the environment)
13:53:35 <Philippa> how do you think you get at the clock? :-)
13:54:27 * Micket|Co is afraid to answer
13:54:36 <Philippa> the IO monad
13:54:40 <xerox> Micket|Co: sorry I didn't mean to be rude.  The "problem" is what Philippa explained, no fear to asnwer! :-)
13:55:11 <Micket|Co> Well, i was looking into the System.Time document
13:55:13 <Philippa> any other way you find of doing it will sooner or later boil down to the IO monad
13:55:22 <Beelsebob> micket: basically... it's not a function... you can give it one thing, and get back something different every time
13:55:30 <Philippa> because only the IO monad has access to the system you're running on
13:55:31 <Beelsebob> so it needs to be wrapped up
13:55:34 <Philippa> right
13:56:02 <Micket|Co> dragging a random number generator along is fine as well
13:56:11 <Micket|Co> I just dont want to manually enter the seed..
13:56:47 <xerox> Micket|Co: with some of the functions defined in the System.Random module you don't have to
13:57:23 <Beelsebob> does System.Random seed from /dev/random?
13:57:44 <shapr> FrederikEaton: If you want email notification, I can probably set it up, but I'd suggest using the RSS feed.
13:58:44 <shapr> Micket|Co: One handy feature of an explicit seed is easy unit testing.
14:02:11 <Micket|Co> mmm yes i know
14:03:55 <FrederikEaton> shapr: i've never used RSS before. surely email would be accessible to more people?
14:04:06 <reppie[^_^]> http://data.4chan.org/b/src/1125176223334.jpg
14:05:55 <basti_> reppie[^_^]: thats cute in a disgusting way.
14:06:01 <reppie[^_^]> http://home.ngi.de/grmbl/happy_cat.jpg
14:07:24 <basti_> tsss
14:09:15 <Philippa> "I caught the mouse!"
14:10:27 <shapr> FrederikEaton: RSS is more accessible imho.
14:11:44 <wilx> RSS sucks in that there are like at least three different formats and only one of them has DTD.
14:12:47 <shapr> RSS is nifty in that there's no spam, no deleting messages, and it's pull-only.
14:13:39 <shapr> It's also very easy to aggregate a bunch of RSS feeds together.
14:13:54 <shapr> It's somewhere between nntp and smtp.
14:17:39 <tuomov> rss sucks in that it generates a lot of traffic
14:18:06 <shapr> Can't be worse than the amount of email spam.
14:18:12 <greenrd> Not if you use a popular aggregator like Bloglines though
14:18:29 <tuomov> a better solution would allow break up the feed into pieces, so that old entries could be even permanently kept
14:18:30 <greenrd> shapr: It is worse for some popular sites, but only for those sites, not for everyone
14:18:56 <shapr> tuomov: Something like a contents url and post url?
14:19:24 <tuomov> yeah, maybe a guid index, and the actual posts in guid.something
14:19:48 <tuomov> and the guid index could be multipart too
14:20:34 <tuomov> maybe just splitting the feed into say pieces with 10 items in each would be enough and simpler
14:21:18 <tuomov> it would have to be ensured that the items are into files in order of addition for it to work
14:22:25 <tuomov> +added
14:22:55 <tuomov> pfffft.. forget it
14:24:52 <wilx> That wouldn't be Really Simple anymore :)
14:25:01 <shapr> Peter Thiemann modeled caching in WASH on the BigWig caching system. It works sort of like that.
14:25:40 <Itkovian> eveninh and night. ttyl.
14:25:41 <shapr> BigWig roughly does common subexpression elimination on all the pages in a website, and then publishes the bigger chunks in their own urls.
14:25:52 <shapr> Javascript is used on the client side to sew the pieces back together.
14:26:20 <shapr> That takes advantage of ISP transparent caches and the like.
14:27:47 <shapr> Seems like there should be some sort of useful generalization there.
14:37:40 <tuomov> wilx: a series of backlinked files with one item in each should be quite simple, but it isn't necessarily very efficient
14:38:27 <tuomov> thus its better to have a bit more items in each file, but not too many, because the older items quickly get loaded unnecessarily
14:39:02 <shapr> Wouldn't it be better to have an asymptotic distribution?
14:39:05 <tuomov> what complicates this kind of approach is that the feed generator must keep the items in order of addition
14:39:06 <wilx> Fetching, parsing and then more fetching is imho order of magnitued harder than just fetch and parse.
14:39:28 <shapr> Most recent items are often requested, the further back you go, the more likely the requester wants a lot of items.
14:39:29 <wilx> The _Really_ part is there for a reason :)
14:39:45 <tuomov> it's so simple that it's stupid :)
14:40:11 <tuomov> if you keep only a few items in the feed, people must constantly poll it if the feed gets updated frequently
14:40:14 <wilx> I don't think it is stupid.
14:40:25 <wilx> RSS is not meant to store hundreds of items.
14:40:26 <tuomov> and if you keep a lot of items there, constant pollers generate a lot of traffic
14:40:44 <wilx> Also there are other ways to lower the bw.
14:41:02 <wilx> Like compressing the contents.
14:41:33 <shapr> Maybe RSS readers should handle gzip transfers?
14:41:52 <tuomov> I think they do
14:42:18 <tuomov> at least my Ion changelogs are gzipped.. and still around 60k the last 100 changes for the ion-3 repository
14:42:57 <tuomov> I could perhaps drop that to 30 or so, but below that it is too little
14:43:06 <tuomov> one shouldn't have to poll more than once a day, preferably once a wekk
14:43:45 <tuomov> but otoh frequent pollers shouldn't generate a lot of traffic
14:44:48 <shapr> You could have a single file that's unix time of the most recent update.
14:45:14 <tuomov> that would help
14:47:43 <tuomov> what also sucks about rss is that it takes a long time to check all the feeds
14:48:11 <tuomov> for that a push model would be better
14:48:15 <Korollary> 21st century people are so impatient geez
14:48:44 <tuomov> they got something right when they designed nntp..
14:48:58 <reppie[^_^]> ion 3?
14:49:02 <reppie[^_^]> is it written in haskell?
14:49:05 <tuomov> no
14:49:08 <reppie[^_^]> why not!
14:49:16 <tuomov> I'm too lazy for a rewrite?
14:49:24 <reppie[^_^]> haskell is lazy too!
14:49:28 <reppie[^_^]> great combination!
14:50:41 <reppie[^_^]> ok.. enough trolling
14:51:40 <tuomov> good thing about the polling is, however, that it's more anonymous than pushing (e.g. mailing list) or a push-poll-network (nntp)
14:52:15 <tuomov> you can use tor and all if you want to
14:58:49 <goron> tuomov: Here's an idea: do both....(if you can't make up your mind)
14:59:22 <tuomov> eh?
14:59:42 <tuomov> nntp does both, but those with the servers often restrict access
14:59:56 <goron> Anyway.... freedesktop.org has f*cked up their database...
14:59:57 <tuomov> and the network has other problems
15:00:47 <goron> Their flies away my trust in Bugzilla...
15:00:53 <shapr> I think push systems lend themselves to spam.
15:01:09 <tuomov> You could have authenticated feeds
15:03:07 <tuomov> if we forget about discussion groups and just consider passive feeds like rss, you could have an nntp-like distribution mechanism where the feeds were identified by the feeders public key, and authenticated with it as well
15:03:11 <tuomov> or something like that
15:06:04 <tuomov> the problem is, though, that who will carry all the feeds? usenet is quite small compared to all blogging and so on
15:09:51 <FrederikEaton> and who will bury all the feeds?
15:11:33 <FrederikEaton> oh, /dev/null says he'll do it
15:13:48 <FrederikEaton> shapr: can you enable email? i'd like to be able to set up this cabal design thing and tell people: subscribe if you want to participate. hey, maybe i could subscribe libraries@haskell.org
15:14:13 <Philippa> tuomov: livejournal seems to be surviving
15:17:16 <FrederikEaton> shapr: at the very least i want to see what kind of mail is generated, i may try rss too
15:28:05 <Beelsebob> philippa: that's rare
15:30:07 <shapr> FrederikEaton: What about feed2imap or rss2email ?
15:34:06 <machack666> are there Flate/LZW bindings for haskell, and if so, are they "pure"?
15:34:49 <wilx> Bindings? I don't think there is any LZW library at all.
15:35:33 <wilx> Now I realise...is Flate some library implementing LZW?
15:35:35 <shapr> I think there's a zlib binding, and a pure zlib implementation.
15:37:06 <machack666> pure zlib is what I'm after.  Is that implemented in haskell, or is it ffi hooks into the c zlib?
15:38:40 <xerox> It is possible to hook functions in a pure fashion, but you must know for sure that it has not side-effects.  I don't think there are pure zlib binding, tough it's possibly possible.
15:38:45 <shapr> machack666: What about http://urchin.earth.li/darcs/ian/inflate/ ?
15:39:08 <machack666> shapr: do you know the license on that code?
15:39:46 <machack666> never mind, its in the code
15:39:52 <shapr> yup, BSD3
15:41:42 <machack666> I believe that LZW is a separate (but related) algorithm to (de)flate
15:44:55 <Beelsebob> okay... this is really desturbing
15:45:08 <Beelsebob> I don't get how my own debugger is working
15:45:12 <Beelsebob> but it is working
15:45:19 <Beelsebob> and much much better than I thought it should
15:48:13 <Philippa> heh
15:48:23 <Philippa> that's what you get when you screw around with heuristics, you never really know how the hell it works
15:49:15 <Beelsebob> heh
15:49:48 <Beelsebob> well... I've only implemented the first approach... and it's already about 4 times better than algorithmic debugging
15:49:52 <Philippa> look on the bright side - a friend of mine's researching hyperheuristics, which're a form of metaheuristic...
15:49:55 <Philippa> that's weird shit
15:50:12 <Beelsebob> that does sound pretty weirdshit
15:50:25 <Beelsebob> a heuristic for what's a good heuristic?
15:50:26 <Philippa> how much does the stuff you've had it debug vary at the moment?
15:50:31 <Philippa> yeah
15:51:06 <Beelsebob> I've run through my standard library of programs that people have handed me to fix
15:51:13 <Beelsebob> so... reasonably varied
15:51:43 <Philippa> would it work on anything in a monad yet?
15:52:10 <Beelsebob> probably
15:52:28 <Beelsebob> in that it would pretty quickly decide most of the nasty stuff is entirely safe
15:52:34 <Beelsebob> and concentrate on your code instead
15:53:58 <Beelsebob> I haven't really played though
15:54:08 <Beelsebob> I'm still trying to check it really does get it right
15:54:19 <Philippa> in what sense(s)?
15:55:00 <Beelsebob> that it identifies the same bug as algorithmic debugging
15:55:06 <Philippa> 'k
15:55:08 <Beelsebob> I'm sure it should be asking more questions
15:55:39 <Philippa> pick some small problem sets and get it to graph out the search space and what it's eliminated at each point?
15:55:53 <Beelsebob> yep, am doing
15:55:58 <Beelsebob> pretty-hat is very useful
15:57:52 <Beelsebob> hmm, there's deffinately something uppp it just asked me a question it should have known about
15:59:25 <Beelsebob> hmm... time for a walk... or to go to sleep
16:03:13 <xerox> Goodnight.
16:10:21 <reppie[^_^]> night
16:29:50 <FrederikEaton> shapr: "FrederikEaton: What about feed2imap or rss2email" -> i'm want everybody to be able to use it without installing anything
16:29:58 <FrederikEaton> "i want" even
16:32:35 <FrederikEaton> otherwise the barrier to entry will be too high
16:32:54 <SamB> @hoogle [a] -> Int -> Maybe a
16:32:55 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
16:33:28 * SamB doesn't see how that is at all what he asked for
16:34:48 <Lemmih> @pl \l n -> Maybe.listToMaybe (drop n l)
16:34:49 <lambdabot> (((Maybe .) . listToMaybe) .) . flip drop
16:36:09 <SamB> hmm, that does do exactly what I want...
16:36:37 <SamB> but whatever shall I call it?
16:37:11 <shapr> FrederikEaton: I could make you maintainer of the Haskell Wiki and you could install it...
16:37:17 <SamB> @type \l n -> Maybe.listToMaybe (drop n l)
16:37:18 <lambdabot> forall a. [a] -> Int -> Maybe a
16:40:28 <SamB> @hoogle [a] -> Integer -> a
16:40:29 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
16:40:29 <lambdabot> Prelude.seq :: a -> b -> b
16:40:29 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
16:48:26 <FrederikEaton> shapr: ok, do it
16:48:56 <FrederikEaton> shapr: or we can be co-maintainers
16:52:54 <shapr> Like I've said before, I'm moving cities and starting school, I'll be busy for awhile. I'd like to hand off my current responsibilities.
16:53:09 <FrederikEaton> ditto for me
16:53:20 <FrederikEaton> which school?
16:53:28 <shapr> Lule√• Technical University.
16:53:41 <FrederikEaton> ah, so you're staying in sweden?
16:53:44 <shapr> Yup
16:53:51 <FrederikEaton> i'm moving countries too
16:54:02 <FrederikEaton> so that means that you should stay the maintainer :)
16:57:06 <FrederikEaton> just kidding you decide
17:10:50 <shapr> I'm just busy.
17:30:15 <machack666> is there a quick-n-dirty way for a String -> [Word8] ?
17:32:17 <Igloo> map (fromIntegral . ord)
17:34:17 <machack666> thanks
18:08:43 <dons> Igloo, "dons: I'm a member of which club?" -- the club for phd-student-with-lots-of-little-projects :)
18:08:59 <Igloo> Ah  :-)
18:14:32 <mwc> dons, is there one of those for undergrads?
18:15:36 <dons> I would say it that membership is open to undergrads, too :)
18:17:24 <Igloo> So, when do I get my badge?
18:19:27 <dons> hehe. when you pay your annual membership fee
18:19:52 <mwc> God damn it. A friend of mine just made a reference to a 'rusty trombone.' And then I went and googled it.
18:22:40 * shapr is afraid to ask.
18:26:41 <mwc> yeah, it's best not to
18:45:08 <ptolomy> oh lord. it's bad to GIS that, too.
18:45:26 <ptolomy> Sounds like a decent name for a bad horn band, though.
18:45:36 <dons> Igloo, do you have an opinion on moving the fooPS names in FastPackedString (my version, not darcs) to PS.foo qualified names?
19:07:48 <dons> heh. fromm the "highlights of nhc" paper: "No n+k patterns. This is, in the authors opinoin, a disgusting part of Haskell and it deserves to be forgotten."
19:08:04 <dons> thems fighting words!
19:12:43 <SamB> @index uniq
19:12:44 <lambdabot> bzzt
19:12:51 * SamB wonders what it is called
19:13:17 <SamB> @hoogle [a] -> [a]
19:13:18 <lambdabot> Prelude.tail :: [a] -> [a]
19:13:18 <lambdabot> Prelude.init :: [a] -> [a]
19:13:18 <lambdabot> Prelude.reverse :: [a] -> [a]
19:13:39 <SamB> @hoogle (a -> a-> Bool) -> [a] -> [a]
19:13:40 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
19:13:40 <lambdabot> Prelude.scanr1 :: (a -> a -> a) -> [a] -> [a]
19:13:40 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
19:14:01 <SamB> @type List.nub
19:14:03 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:14:25 <dons> nub ?
19:14:34 <dons> nub is uniq
19:14:36 <dons> but better
19:14:52 <dons> (you don't have to sort first)
19:14:53 <SamB> yes, have just about figured this out
19:15:25 <SamB> well seeing as I just want to see if everything in the list is the same, for expected list size zero or one...
19:15:55 <dons> @type all
19:15:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:16:09 <dons> @eval all (=='X') "XX"
19:16:11 <lambdabot> True
19:17:00 * SamB is just hacking on Mrifk
19:17:41 <SamB> @google mrifk
19:17:42 <lambdabot> http://www.hyperborea.org/journal/archives/2004/05/10/mrifk/
19:17:56 <SamB> @google mrifk decompiler
19:17:57 <lambdabot> http://www.darkweb.com/~benrg/if-decompilers/
19:18:12 <SamB> ah, there we go
19:25:41 * SamB is trying to add inference and symbol naming and other suchlike facilities
19:30:33 * SamB wonders how to decompile Inform switch constructs, given the location of sw__var
19:31:58 * SamB suspects it would involve "decompile' (IfThenElse cond thenClause elseClause : rest)"
19:40:33 <SamB> Glulxe seems to make a lot of things about decompilation more complicated... (though a lot are probably simpler, too...)
19:40:40 <SamB> er, rather Glulx
19:42:57 * SamB kludges locals
19:58:21 * SamB is annoyed that it does not seem to be allowed to do anything like 'let ?f x = x in [...]'
20:02:37 <TheHunter> ...indeed it did.
20:03:08 <SamB> what the what?
20:03:25 <TheHunter> restarting X made uim work.
20:04:04 <SamB> ah
20:04:25 <dons> doh. reversePS shouldn't be reversing both the from *and* to strings. hehehe :}
20:04:28 <SamB> that would explain your coming in mid-sentence, or whatever
20:04:41 <dons> no wonder I was getting some strange behaviour
20:05:28 <TheHunter> that was just a continuation of my away-message.
20:05:46 <SamB> oh, I see it now
20:05:55 <dons> uim?
20:06:34 <TheHunter> something input method.
20:06:58 <dons> ok.
20:07:13 <TheHunter> i don't see how it works yet.
20:08:27 <TheHunter> ah
20:08:45 <TheHunter> oops.
20:10:08 <dons> FFI + QuickCheck to test C code is good.
20:10:44 <dons> moin dcoutts
20:11:47 <dcoutts> ugg
20:12:00 * dcoutts is not here
20:12:12 <TheHunter> …ëŒ≤√ß√∞…õ…±…£…•…™…≤…¨ é…Ø≈ã…î ã…í Å ÉŒ∏ ä å çœá è
20:12:43 <dons> TheHunter gets a buffer overflow
20:13:00 * SamB notices deep magic in L__M: explicit manipulation of the internal "register" sw__var...
20:14:15 <SamB> L__M being in Inform's verblibm.h
20:47:17 <mwc> dons, neat idea; you could take that further to write a function effect description language for tests that would compile down to unit testing
20:55:55 * SamB wonders how well nigh impossible a unified bi-platform Inform decompiler would be to write in Haskell
21:59:50 <humasect> hi hello hi
22:51:51 <lispy_> hello hi hello
22:58:11 <mwc> guten abend, lispy_
23:01:15 <humasect> i use WASH.
