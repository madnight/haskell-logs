00:00:17 <boegel> lispy: my raytracer hasn't got anything to do with HOpenGL, but ok :)
00:00:36 <lispy> boegel: it's still graphics :)
00:00:56 <boegel> lispy: it is... HaskLS uses HOpenGL though, have you seen that ?
00:01:08 <lispy> what is that?
00:01:22 <lispy> @where HaskLS
00:01:24 <lambdabot> I know nothing about haskls.
00:01:41 <lispy> @google haskls
00:01:42 <boegel> lispy: http://scannedinavian.org/~boegel/HaskLS
00:01:43 <lambdabot> http://haskell.org/hawiki/HaskLS
00:02:07 <lispy> ooooo
00:02:10 <lispy> i remember now
00:02:47 <lispy> boegel: cool
00:03:38 <boegel> lispy: I plan to expand it, someday... :p
00:03:56 <lispy> i plan to finish the nehe tuts some day :)
00:04:03 <Lemmih> FrederikEaton: Try comparing the counter examples from HSP and WASH.
00:04:03 <lispy> i'm stuck on doing fonts
00:04:55 <Lemmih> FrederikEaton: (and look at the HTML they generate)
00:05:01 <boegel> lispy: oh, they're yours ?
00:05:41 <lispy> boegel: well, nehe.gamedev.net houses the originals written in C, codersbase.com is my server housing my haskellizations of the nehe tuts
00:06:15 <FrederikEaton> Lemmih: link?
00:06:47 <Lemmih> FrederikEaton: http://212.242.49.100/hsp/Browse
00:06:52 <Lemmih> @google WASH haskell
00:06:54 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
00:08:03 <lispy> cool, i just simulated 1000 connections to my forkIO server, and it barely puts a strain on my server
00:08:28 <lispy> and the client (which connected 1000 times) and the server are on the same machine
00:08:40 <boegel> lispy: I see
00:09:02 * lispy is impressed with forkIO
00:09:33 <lispy> my ircbot is more of a burden :)
00:10:24 <lispy> osx doesn't take the load as well, but i'm not surprised
00:10:47 <Lemmih> FrederikEaton: Notice how it's possible to embed Int's and String's in the HTML.
00:11:26 <Heffalump> forkIO is just UNIX fork, isn't it?
00:11:52 <Lemmih> That's forkOS.
00:11:57 <lispy> Heffalump: CosmicRay was telling me it uses select or poll in the background
00:11:58 <Heffalump> oh yeah. Duh.
00:12:24 <Heffalump> if all threads suspend, you mean?
00:12:48 <lispy> Heffalump: i think the threads are just implemeted in the GHC runtime
00:13:40 <Itkovian> wtf?! http://news.scotsman.com/scotland.cfm?id=1793872005
00:15:11 <lispy> heh, after 1024 connections the server dies
00:15:28 <boegel> lispy: the magic number ! 2^10 :)
00:15:56 <lispy> this is plenty of connections for the purpose i had in mind
00:16:41 <lispy> programming is addictive
00:17:05 <lispy> i should go to sleep but i want to stay up and code instead :)
00:18:06 <boegel> lispy: been there, don't do it :) you'll start seeing things that aren't there :)
00:18:31 <lispy> hehe
00:18:55 <lispy> "wha?  was that a monad? over there in the corner?"
00:19:58 <boegel> lispy: well, how did it look like ? :)
00:20:42 <lispy> it was like a category, only smaller and not as fuzzy
00:40:32 <lispy> @type Monad.when
00:40:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:45:18 <Cale> lispy: in case you were unaware of it, you can get the same information from GHCi with :t
00:46:14 <lispy> Cale: i know, just tend to have lambdabot handier.  but i need to use /msg more often
01:32:14 <FrederikEaton> Lemmih: interesting. so you want people to use a lot of css?
01:32:33 <Lemmih> Huh?
01:33:57 <Lemmih> CSS is good but HSP isn't forcing it on people.
01:50:23 <FrederikEaton> because if they use lots of html, then there must be a way to format it. if i used Text.Html then i would format it by having the functions i call do the formatting...
01:52:20 <Lemmih> Formatting as in font colours and such?
02:00:06 <FrederikEaton> yeah
02:00:17 * FrederikEaton goes to sleep
02:03:26 <Lemmih> You can do that with both HTML and CSS. HSP doesn't limit you in that regard.
02:04:38 <Lemmih> Sleep well.
02:05:29 * poetix counts monads
02:21:03 * Itkovian tries to write (for the fourth time) a dvd
02:21:04 <Itkovian> grr
02:21:26 <Itkovian> seems like my machine is doing little but read data and write it
02:47:11 * boegel wonders how shapr is doing with FLM
02:48:22 <xerox> You do really want it, doesn't you? :-)
02:48:31 <boegel> I does :p
02:48:46 <xerox> ooops :-D
02:50:04 <boegel> hey arjanb
02:52:07 <Lemmih> dons: ping.
02:55:04 <dons> Lemmih, ack
02:55:28 <dons> ê
02:57:05 <Lemmih> Have you considered using the GHC package instead of the GHC binary for hs-plugins?
02:58:51 <dons> yeah, but it's hard to build, and not installed by default
02:58:56 <dons> once it is, I'll switch
02:59:11 <Lemmih> Neat.
03:04:35 <dons> Lemmih, btw i've committed  the cabalised hs-plugins patches, and also made HSX optional
03:04:53 <dons> it's not HSX by default, you need to say ./configure --enable-hsx to actually use hsx
03:08:05 <Lemmih> Does it really work? It looks like System.Plugins.Parser is still importing Language.Haskell.Hsx even when HASKELL_SRC is empty.
03:08:36 <dons> hmm. worked for me.
03:09:16 <dons> is WITH_HSX set in config.h ?
03:10:21 <Lemmih> Nope.
03:10:59 <dons> so that's good. WITH_HSX is the value used in System.Plugins.Parser. HASKELL_SRC is used in the plugins.cabal.in file
03:12:08 <dons> if I ./configure --enable-hsx, then #define WITH_HSX 1
03:12:18 <dons> and Build-Depends:        base, haskell98, Cabal, haskell-src-exts
03:12:30 <Lemmih> I better get a clean snapshot. I can't find WITH_HSX in System.Plugins.Parser
03:12:46 <dons> and ./configure alone: /* #undef WITH_HSX */, Build-Depends:        base, haskell98, Cabal, haskell-src
03:12:57 <dons> ok. i'll checked it all got pushed
03:15:17 <dons> Lemmih, also, feel free to comment/send patches to improve the cabalisation ;)
03:16:18 * Itkovian checks out h4sh
03:16:24 <dons> yay!
03:16:50 <Itkovian> is it lean? is it mean?
03:17:14 <dons> it tries to be  lean and mean :)
03:17:29 <Lemmih> Ok, a clean snapshot did the trick.
03:17:37 <dons> cool.
03:18:55 <Lemmih> You compile plugins with -threaded?
03:19:00 <Lemmih> Doesn't that only affect binaries?
03:19:12 <dons> hmm. yep :)
03:19:16 <Lemmih> (ie. it links a binary with the threaded RTS)
03:19:29 * dons darcs patches
03:21:09 <Lemmih> dons: It looks great. Kudos on plugins-0.9.10 (:
03:21:26 <dons> cheers :)
03:25:03 <Itkovian> Lemmih: should I use your haskell-src-ext?
03:25:18 <Itkovian> or isn't it in a darcs repo yet?
03:25:28 <Lemmih> It's not done yet.
03:25:54 * Lemmih is fighting alex as we speak.
03:26:16 <dons> you ripping out the lexer too?
03:26:29 <dons> I guess you have to
03:26:44 <Lemmih> Yeah.
03:37:02 <SM_ax> who write the documentation for GHC modules?
03:38:46 <ndm> SM_ax, it uses Haddock comments - so the author of the module can patch the source and the documentation is auto-generated
03:39:13 <SM_ax> mmm
03:41:12 <SM_ax> there are some modules I need , that have no documentation at all, as long as I  have to figure them out annyway, I thought I can help a little with that...
03:41:34 <ndm> just sending a patch to teh source would create the documentation
03:41:51 <ndm> which module is lacking documentation?
03:45:42 <SM_ax> ndm, Signals for example
03:45:49 <ndm> @doc Signals
03:45:50 <lambdabot> Signals not available
03:46:24 <SM_ax> @doc System.Posix.Signals
03:46:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System.Posix.Signals.html
03:47:37 <SM_ax> not very much to figure out :)
03:47:52 <ndm> well if you get teh source
03:47:57 <SM_ax> but has some unclarities anyway
03:48:08 <ndm> you just add "-- | Comment about the function"
03:48:11 <ndm> above each function
03:50:06 <SM_ax> ndm, ok thanks
03:51:15 <xerox> @libsrc System.Posix.Signals
03:51:17 <lambdabot> http://darcs.complete.org/fptools/libraries/base/System/Posix/Signals.hs
04:16:28 <Itkovian> dons: isn't haskell usually _slow_ when doing string stuff?
04:17:19 <Lemmih> "Nope"# (:
04:17:28 <dons> hehe
04:33:09 * boegel slaps himself on the cheek to stay awake
04:41:26 <Lemmih> Yay. Finally got the lexer to lex correctly.
04:44:17 <ndm> Lemmih: using Alex?
04:44:30 <Lemmih> Yes.
04:44:56 <ndm> cool, i'm trying to write an Alex replacement actually
04:46:01 <Lemmih> Neat. How will it be different from Alex?
04:47:09 <ndm> faster, and language neutral
04:47:26 <ndm> so you can write one lexer for the language Haskell, and use that from Javascript, Haskell, C etc.
04:47:33 <ndm> but with an Alex compatible mode
04:47:40 <Lemmih> Got an URL?
04:47:49 <ndm> nope, not yet sadly
04:48:02 <ndm> i have most of the code
04:48:12 <ndm> it needs heavy refactoring though
05:04:33 <Lemmih> metaperl: s 30 = sum (on 30), or better yet: s = sum.on
05:09:17 <boegel> yo shapr
05:09:20 <boegel> how you doin' ?
05:09:33 <shapr> I'm asleep, how are you?
05:10:17 <boegel> I'm awake (at least physically)
05:18:26 <shapr> Hiya meren, learning Haskell?
05:18:53 <meren> hi shapr :) unfortunatelly..
05:19:04 <boegel> meren: don't swear like that ! :p
05:19:19 <meren> eheh ok
05:19:22 <shapr> meren: Learning Haskell is something cool!
05:19:37 <meren> yeah sure it is.
05:20:04 <meren> like ocaml..
05:20:04 <shapr> Do you want pointers to introductory material?
05:20:13 <shapr> I can point you to something I wrote myself.
05:20:20 <boegel> showoff :p
05:20:30 <shapr> boegel: You can point to something you wrote too :-)
05:21:01 <boegel> shapr: but I'm not like that :p
05:21:13 <shapr> Ok, *I* can point to something you wrote ;-)
05:21:26 * poetix points to shapr pointing to something boegel wrote
05:21:28 * boegel whistles
05:21:39 * boegel chops poetix finger off
05:21:47 <shapr> yow!
05:21:55 <meren> shapr: show me some usefull introductory material then..
05:21:56 <shapr> Now we see the violins inherent in the system!
05:21:58 <poetix> Just a flesh wound...
05:22:03 <shapr> meren: Righto!
05:22:13 <Lemmih> meren: Why are you learning Haskell?
05:22:23 <earthy> ponty mython.
05:22:33 <earthy> I thought that went with another language
05:22:37 <meren> Lemmih: i'm not learning haskell yet..
05:22:47 <shapr> @wiki HaskellDemo -- quick intro that I (mostly) wrote myself.
05:22:48 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo -- quick intro that I (mostly) wrote myself.
05:22:49 <meren> :)
05:23:05 <poetix> @yow
05:23:06 <lambdabot> How's it going in those MODULAR LOVE UNITS??
05:23:24 <poetix> meren: Lambdabot is written in Haskell...
05:23:28 <meren> i love bots..
05:23:37 <meren> eheh
05:23:43 * poetix pats lambdabot on the head with his remaining fingers
05:23:46 <meren> and shapr too?
05:23:48 <Lemmih> Modular love units == collectives?
05:23:56 * earthy sees lambdabot grabbing the entire hand
05:24:24 <boegel> meren: yeah, shapr is the ultimate irc bot written in Haskell
05:24:44 <shapr> boegel wrote an article in IssueOne of The Monad.Reader --> http://www.haskell.org/tmrwiki/
05:24:52 * boegel blushes
05:25:17 <shapr> "An Introduction to Gtk2Hs"
05:25:20 <boegel> shapr: that's more on GUI stuff, hasn't got much to do with basic Haskell
05:25:45 <shapr> boegel's in-progress article for The Monad.Reader is about the ray tracer he wrote.
05:26:12 <poetix> meren: do you have a particular project or assignment to tackle?
05:26:28 <shapr> poetix wrote an article "Solving Sudoku" for IssueFour.
05:26:37 <shapr> Lotsa smart people here on #haskell!
05:27:10 <meren> no poetix.. i just wanted to learn why anyone should learn haskell..
05:27:36 <shapr> Ooh! There are many good reasons to learn Haskell!
05:27:48 <meren> eheheh
05:27:51 <meren> nice..
05:27:58 <poetix> I don't think there's any "should" about it, at least not an unconditional "should"
05:28:02 <boegel> oh no, you just got him started :p
05:28:09 <meren> eheh
05:28:13 <shapr> Higher order functions, referential transparency, monads, arrows, I could go on for awhile.
05:28:16 <poetix> But you should learn Haskell *if*...
05:28:38 <Itkovian> omg
05:29:40 <shapr> meren: Also, the #haskell community contains lots of smart, helpful people. This is a good place to be if you like to learn new abstractions and new ideas.
05:29:59 <poetix> ...if you want to have real control over the way programs are put together, at the basic level of how computations are composed, sequenced and related
05:30:03 <ozone> #haskell: learn new abstractions in 24 hours or your money back
05:30:10 <meren> shapr: no doubt..
05:31:06 * shapr abstracts ozone with a monad.
05:31:28 <ozone> :(
05:31:47 <poetix> ...if you want a functional programming language with lightweight threads, type inference and a powerful compiler
05:31:50 <shapr> ozone: Don't you feel upLifted now? ;-)
05:32:39 <poetix> ...more than one powerful compile, in fact
05:32:48 <poetix> s/compile/compiler/
05:32:51 <basti_> hi all. any german freelance programmers online? (juristical question)
05:34:39 <shapr> meren: So, do you want to drink the kool-aid? ;-)
05:35:21 <shapr> Anyway, the best collection of introductory Haskell writings are under
05:35:23 <shapr> @learn
05:35:24 <lambdabot> http://www.haskell.org/learning.html
05:37:10 <shapr> That points to everything from "Why Functional Programming Matters" ( http://www.md.chalmers.se/~rjmh/Papers/whyfp.html ) to sylvan's "The Lambda Complex" ( http://www.md.chalmers.se/~rjmh/Papers/whyfp.html ) that compares Haskell and C++.
05:40:36 <boegel> shapr: I'm still not sure if i'll be able to finish my HRay article
05:41:36 <xerox> Any suggestion on a lightweight (and cool) MUA?
05:42:35 <tuomov> what's lightweight?
05:42:37 <tuomov> mutt?
05:42:39 <musasabi> xerox: mutt ?
05:43:13 <xerox> I do like thunderbird but it's way too slow.
05:43:20 <meren> kmail is nice.. really.
05:43:22 <thebug> xerox: if you're into guis, sylpheed(-claws) is nice
05:43:30 <meren> sylpheed too..
05:43:33 <tuomov> A program with the motto "All mail clients suck. This one just sucks less." can't be bad :)
05:43:33 <ndm> the one with Opera is quite quick
05:43:36 <thebug> gtk, no gnome/kde goo
05:43:54 <Itkovian> boegel: you must! finish! it!
05:43:56 <ndm> i use it as a faster version of thunderbird
05:44:14 <boegel> Itkovian: I will finish it, someday
05:44:14 <xerox> I should tru mutt & imap.
05:44:17 <xerox> try, even
05:44:26 <shapr> meren: If you have any specific questions about Haskell and functional programming, feel free to ask.
05:44:33 <boegel> but I don't have time in the upcoming weekends, and here (at work) I have lot's to do
05:44:44 <Itkovian> i knows
05:44:47 <meren> shapr: i love you and haskell
05:44:55 * shapr hugs meren 
05:45:25 <thebug> hello shapr!
05:45:33 <shapr> Greetings Mr Bug!
06:23:14 * boegel greets xerox dblhelix mornfall and the rest of the entrees
06:23:37 <dblhelix> boegel: be greeted!
06:24:02 <mornfall> heh, hi :)
06:24:09 * alar realises that someone is alive here
06:24:14 <alar> hello all
06:24:46 <alar> does anyone have an experience with parallel haskell ?
06:24:58 <alar> or what is the right name for it
06:26:14 <ndm> http://www.macs.hw.ac.uk/~dsg/gph/
06:26:49 <ndm> glasgow parallel haskell
06:27:19 <alar> thank you for link
06:29:37 <shapr> alar: There's also the recent SMP GHC. Does that count?
06:31:01 <dcoutts> xerox, ping
06:31:08 <dcoutts> @seen paolo-
06:31:09 <lambdabot> paolo- has changed nick to xerox.
06:31:09 <lambdabot> xerox is in #haskell. I don't know when xerox last spoke.
06:31:20 * boegel wonders why no-one ever plays ping pong with him
06:31:26 <dcoutts> boegel, ping!
06:31:32 <boegel> dcoutts: pong !
06:31:46 <alar> thanks
06:32:10 <dcoutts> boegel, you need more colaberative projects, then you'll get pinged all the time :-)
06:32:11 <alar> my goal is not programming for SMP hardware
06:32:33 <boegel> dcoutts: thrue
06:32:42 <alar> just making multithreaded applications
06:32:56 <boegel> dcoutts: have you seen the nehe stuff url someone pasted here ?
06:33:10 <dcoutts> boegel, no, "nehe"?
06:33:25 <shapr> alar: In that case, what about Control.Concurrent?
06:33:40 <Lemmih> @where lispy-nehe
06:33:41 <alar> I'm looking at it right now
06:33:42 <lambdabot> http://www.codersbase.com/Nehe-tuts
06:33:44 <dcoutts> alar, yeah, ordinary ghc supports threads rather well
06:33:54 <boegel> http://www.codersbase.com/Nehe-tuts
06:34:00 <boegel> yeah, what Lemmih said
06:34:38 <xerox> dcoutts: hey!
06:36:22 * boegel almost forgot he brought 2 bananas to work today
06:36:31 <shapr> mmm, bananas!
06:37:04 <dblhelix> boegel: did you also bring lenses and barbed wire?
06:37:07 <dcoutts> xerox, how's it going today?
06:37:10 * shapr snickers
06:37:13 <xerox> dcoutts: did you see the mailing list?
06:37:33 <boegel> shapr: I have one left, if you want it you can come and fetch it
06:37:33 <dcoutts> xerox, I've just got your latest patches
06:37:41 <boegel> dcoutts: err, no?
06:37:46 <xerox> dcoutts: grep -rn XXX Graphics/  :-(
06:37:53 <dcoutts> xerox, yes I saw the mailing list post, I've not replied yet
06:38:02 <shapr> boegel: I think the banana wouldn't be edible by the time I arrived.
06:38:21 <boegel> i could lay it in the gridge if you want to :p
06:38:25 <dcoutts> xerox, only 12 XXX's
06:38:31 <dcoutts> that's not too bad! :-)
06:38:38 <xerox> dcoutts: I liked your previous reply - I was about to write something yesterday night (i.e. this eeearly morning) but I fell asleep.
06:39:00 <boegel> xerox: did you hurt yourself ?
06:39:01 <xerox> dcoutts: indeed :-)  But it brings some questions.
06:39:24 <xerox> boegel: fortunately not :-)
06:39:49 <dcoutts> xerox, so shall we go through them? (and stop disturbing #haskell)
06:39:51 <boegel> xerox: okay then
06:39:58 <xerox> dcoutts: Yes, thanks.
06:40:26 * boegel sees xerox and dcoutts leaving while holding hands, and wonders what kind of XXX they will be discussing
06:40:43 <shapr> Probably -- XXX this code must be fixed!
06:41:05 <xerox> Indeed, I also started haddock-ing the modules sources.
06:41:08 <dcoutts> boegel, not that sort of colaberation! heh heh
06:41:10 <boegel> shapr: then why are they holding hands ? :p
06:41:28 <shapr> boegel: They're both trying to steal that chunk of code from each other.
06:41:43 <shapr> I've seen it happen, when two people really want to write the same piece of code...
06:42:09 <shapr> See, they're each holding half of that chunk of code, it's a tug of war.
06:42:15 <xerox> shapr: haha I believe you.
06:42:32 * shapr grins
06:43:07 * Itkovian yawns
06:43:18 * boegel feels a wind passing
06:44:24 <boegel> hey barismetin !
06:44:30 * basti_ sees burning tumbleweed
06:44:46 <caglar10ur> hi
06:44:50 <barismetin> hello
06:44:51 <barismetin> :)
06:44:54 <caglar10ur> i want to learn haskell
06:45:11 <basti_> does anyone know about a rather complex parallel-programming problem? some abstraction like the dining philosophers? that could be implemented in favour of STM?
06:45:16 <Itkovian> another one
06:45:17 <basti_> caglar10ur: congratulations.
06:45:43 <boegel> basti_: there are several
06:45:47 <barismetin> caglar10ur: sure you do. we all do :)
06:45:52 <boegel> caglar10ur: ask shapr for a tour :)
06:45:52 <barismetin> start from here: http://www.haskell.org/learning.html
06:46:05 <basti_> boegel: for example? :D
06:46:17 * boegel thinks
06:46:22 <boegel> I saw several in class
06:46:29 <basti_> wasnt that impressive huh
06:46:38 * boegel tries to dig up the slides somewhere
06:47:00 <caglar10ur> shapr: could you help me?
06:47:15 <basti_> possibly abusing the fact that fine-grained locks are a PITA usually?
06:47:31 <Itkovian> caglar10ur: have you read a few tutorials yet?
06:47:33 <meren> caglar10ur: if you have any spesific questions about haskell or functional programming feel free to ask them to shapr..
06:47:40 <Itkovian> lol
06:47:49 <Itkovian> shapr will get covered
06:47:55 <meren> he is a very nice teacher..
06:48:09 <caglar10ur> Itkovian: not readed :(
06:48:16 <boegel> meren: he is ! he taught me too, and now i can't stop coming here
06:48:22 <meren> ehehea
06:48:26 <meren> ehaha
06:48:53 <Itkovian> caglar10ur: I suggest you read some tutorials, get ghc or hugs and try some basic excercises ... then you can pose specific questions
06:49:12 <boegel> basti_: can't find the slides, I know they are online, but I can't reach them
06:49:43 <caglar10ur> Itkovian: ok, ill read :)
06:49:44 <meren> lambdabot: help us
06:49:49 <basti_> boegel: its not urgent or anything. can you do me a favour and tell me if you remember some?
06:49:52 <boegel> meren: lambdaBOT :)
06:49:54 * dblhelix laughs his ass off: daily wtf (a few days back, though): just in case someone needs more then 1000 yottabytes!
06:50:00 <boegel> meren: wadayya wanna know ?
06:50:07 <meren> boegel: i know.. i know..
06:50:25 <Itkovian> dblhelix: that was awesome, yeah
06:50:29 <meren> i want to learn everything about haskell (and girls, if it is possible here)
06:50:38 <Itkovian> seen the one of this morning? the consultant SQL one?
06:50:42 <boegel> meren: ask Phillipa :D
06:50:45 <basti_> meren: with haskell, we can help.
06:50:45 <meren> eheh
06:50:59 <dblhelix> Itkovian: yes... the code injection thing :) was fun too :)
06:51:16 * Itkovian is subscribed to the rss feed from thedailywtf
06:51:37 <barismetin> meren: you can ask anything about your haskell problems here. for girls call me :)
06:51:47 * dblhelix wants to see Philippa learn meren stuff about girls...
06:51:50 <barismetin> btw, you won't have any problem with haskell.
06:51:57 <dblhelix> /s/learn/teach
06:52:05 <barismetin> if there is  a problem its probably you :)
06:52:21 <boegel> dblhelix: funny :)
06:52:28 <dblhelix> barismetin: does the same holds for girls
06:52:39 <barismetin> dblhelix: you can say that :)
06:52:41 <dblhelix> boegel: well, you know where that one came from
06:52:51 <Itkovian> I think meren will have a distored view about girls when learning from Philippa
06:52:58 <Itkovian> distorted
06:53:12 <dblhelix> Itkovian: a pleasant one, though, I guess
06:53:20 <Itkovian> perhaps
06:53:31 <Itkovian> it depends on what you fetish is I guess
06:53:36 <Itkovian> s/you/your
06:53:38 <dblhelix> ouch
06:53:51 <Itkovian> and she still refuses to respond
06:53:54 <Itkovian> ;-)
06:54:13 <boegel> let's all call togehter: Phillipaaa-aaa
06:54:24 <dblhelix> Itkovian: well, the magic three-letter world hasn't been used yet
06:55:21 <Itkovian> true
06:57:33 <boegel> Philippa: sex !
06:57:45 * Itkovian looks innocent
06:57:49 <boegel> now if _that_ doesn't wake her up
06:58:27 * dblhelix imagines Philippa's irc client making all kinds of noises now to draw her attention
06:59:14 <boegel> dblhelix: moaning noises ?
06:59:29 * dblhelix looks away
06:59:53 <alar> functional porn?
07:00:19 <dblhelix> alar: well, it's all about monads, I guess
07:00:25 <Itkovian> isn't porn always functional?
07:00:27 <earthy> isn't porn always functional?
07:00:30 <Itkovian> whatever. me goes home
07:00:32 <earthy> dupe!
07:00:41 <basti_> #touch.my.monads!
07:00:41 <alar> heh
07:00:51 <alar> there is imperative porn also
07:01:01 <basti_> thats what we call "stereo morons" in another channel :D
07:01:05 <earthy> hm. bondage never really did it for me. :P
07:04:11 <boegel> earthy: try it ! you'll be surprised
07:04:29 * boegel laughs at the picture of some woman on our coastline
07:05:34 <boegel> http://www.vrtnieuws.net/nieuwsnet_master/default/archief/nieuws/050818bredene_archief/N_0820_naakt_bredene-20030820-180030.jpg
07:08:26 <earthy> red baseballcap and sunglasses for protection... *right*
07:10:06 <xerox> @where coolness
07:10:07 <lambdabot> http://www.haskell.org/learning.html
07:10:18 <kaol> @where life
07:10:19 <lambdabot> I know nothing about life.
07:11:06 <earthy> @where the universe
07:11:07 <lambdabot> I know nothing about the.
07:11:12 <earthy> @where everything
07:11:13 <lambdabot> I know nothing about everything.
07:11:33 <kaol> should I learn what arrows are?
07:11:46 <earthy> not necessarily
07:12:33 <earthy> they're cool though
07:13:47 <kaol> I should do something substantial with what I already know before that, too.
07:15:13 <vegai> hmm, wonder if my laptop with 8MB ram is good enough for toying around with ghc..
07:20:54 <tromp> you have better chances than i did on my 48K sinclair ZX spectrum...
07:22:35 <SM_ax> tromp, you did that??
07:24:29 <tromp> nah, just kidding of course:)
07:25:28 <tromp> funny thing is i'm currently running out of memory on a 16GB server:(
07:25:37 <tromp> but not with ghc
07:32:46 <ndm> vegai, nhc might be a better choice
07:32:57 <ndm> its a lot more into low memory useage
07:33:26 <vegai> yeah, I guess
07:34:47 <vegai> it shouldn't lack anything significant
08:07:10 <roconnor> Finished version 0.11 of my exact real arithmetic library for Haskell.
08:18:31 <integral> exact?
08:20:07 <basti_> exact.
08:20:57 <integral> what does that mean?  How does it work?
08:22:32 <basti_> it means that all digits are potentially accounted for
08:22:45 <basti_> like if you do 1/2 it results in 0.5
08:23:02 <basti_> but if you do 1/3 it results in 0.33... [repeat]
08:23:25 <basti_> and not in 0.333332 or whatever, which it does in float
08:23:55 <basti_> should be fun with lazy evaluation
08:24:29 <integral> ah, so for a sqrt it's evaluated lazily digit by digit?
08:24:53 <basti_> i think thats what he's planning
08:24:58 <basti_> its what i would be doing
08:25:42 <integral> hmm!
08:27:45 <Igloo> Presumably things like 3*(1/3)==1 would diverge, though
08:28:30 <basti_> yes.
08:28:50 <basti_> if i would want computer algebra, i would know where to get it, anyways.
08:29:05 <roconnor> http://r6.ca/FewDigits/
08:29:26 <roconnor> the key function is approx :: Rational -> CReal -> Rational
08:29:44 <roconnor> approx eps x returns a rational number within eps of x.
08:31:01 <roconnor> Unfortunately this implementation doesn't take advantage of lazy lists for its representation.
08:31:04 <roconnor> ;-(
08:31:10 <basti_> :(
08:31:23 <roconnor> Such an implemention would probably be better, but also harder to write.
08:32:55 <roconnor> x == y returns false if x is unequal to y, and does not terminate if x is equivalent to y.
08:33:21 <basti_> thats a point
08:34:18 <roconnor> Unfortunately if I want CReal to be an instance of Floating, I must implement (==) and show.
08:35:46 <basti_> show could be a bad idea. i mean, there's pi!
08:36:27 <Igloo> So show on lists is a bad idea because there is [1..]?
08:36:42 <basti_> another point.
08:36:43 <basti_> :)
08:37:51 * Lemmih finally got around to cabalize GHC's parser.
08:38:10 <Igloo> Wow
08:45:39 <Lemmih> @where+ ghc-src http://scannedinavian.org/~lemmih/ghc-src/
08:45:40 <lambdabot> ghc-src ~> http://scannedinavian.org/~lemmih/ghc-src/
08:45:51 <Lemmih> It's _really_ ugly but it works (:
08:47:20 <Igloo> Does it have any advantages over the ghc package?
08:47:43 <Lemmih> It's smaller.
08:48:06 <Lemmih> And it can parse HSP syntax.
08:49:12 <xerox> What does one would use it for?
08:49:59 <Lemmih> xerox: It can parse every haskell extension known to GHC.
08:51:32 * Lemmih personally use it for extending Haskell with embedded XML for Haskell Server Pages.
08:51:45 <kolmodin> Lemmih: what makes it ugly?
08:51:48 <xerox> Ah, cool! (:
08:53:09 <Lemmih> kolmodin: I've played surgeon with a chainsaw to get most of the fat out.
08:53:40 <kolmodin> :)
08:53:48 <roconnor> the problem with show on CReal is that every object is like [1..]
08:59:58 <Igloo> As long as it actually produces output that's not a problem, though
09:18:54 <olliej> anyone happen to know the type of GHC.Prim.catch#?
09:19:37 <Lemmih> @type GHC.Prim.catch#
09:19:42 <lambdabot> forall a b.
09:19:44 <lambdabot> (GHC.Prim.State# GHC.Prim.RealWorld
09:19:46 <lambdabot> -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
09:19:48 <lambdabot> -> (b
09:19:50 <lambdabot> -> GHC.Prim.State# GHC.Prim.RealWorld
09:19:52 <lambdabot> -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
09:19:54 <lambdabot> -> GHC.Prim.State# GHC.Prim.RealWorld
09:19:56 <lambdabot> -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
09:19:58 <olliej> excellent
09:20:05 <olliej> Lemmih: cheers :)
09:20:18 <Lemmih> olliej: @type in lambdabot is :type in GHCi.
09:20:28 <Lemmih> (or :t for short)
09:20:43 <olliej> ah
09:20:48 <olliej> i didn't know that existed
09:21:15 * olliej has a rather abysmal knowledge of anything beyond haskell syntax/semantics
09:33:22 <hyp3rion> @moo
09:33:27 <hyp3rion> ;(
09:58:05 <yosemite> wow I thought my module layout in this program was ok, now I'm having to move bits around so I can set up hs-plugins
10:01:35 <Lemmih> Why do you have to move bits around?
10:01:45 <Lemmih> Hey SyntaxNinja.
10:01:48 <SyntaxNinja> y0
10:03:19 <yosemite> Lemmih: poor module layout.  things that should be in the API are in the "Core" module
10:03:23 <yosemite> and whatnot
10:03:44 <yosemite> it essentially has me thinking properly about the division of labor in the program
10:06:40 <ndm> you do know you can rexport an entire module?
10:06:54 <ndm> module Interface(module Core, func1, func2) where
10:07:13 <yosemite> yeah, but I'm not sure if this is what I need yet
10:07:58 <yosemite> I should sketch out the graph of deps, currently I've been in a hacking mode and not a structured programming mode
10:13:41 <ndm> quite a lot of haskell is refactoring...
10:13:41 <ndm> far more than in other languages
10:13:41 <yosemite> I checked out that refactoring whatnot program, it looked nice, but required I code in some windowing env (iirc)
10:13:41 <Igloo> I'm not sure what you mean
10:13:41 <Igloo> (to ndm)
10:13:41 <ndm> i seem to write haskell code
10:13:41 <ndm> then spend much longer refactoring
10:13:41 <Igloo> Surely the amount of refactoring you do depends on how well you write the code in the first place?
10:13:41 <ndm> there always seems to be another abstraction you could use to make the code even shorter
10:13:41 <ndm> Igloo, i have been doing it 3 years and there are still millions of ways to improve
10:13:41 <ndm> in a way, haskell has more flexibility and code can be much purer - hence more refactoring to reach those levels
10:13:41 <lispy> there are always ways to improve
10:13:41 <Igloo> I guess you can abstract Haskell code out further in ways that, in other languages, would be less clear as they need more boilerplate etc
10:14:10 <basti_> is there any parallel virtual machine/stm stuff in haskell?
10:20:10 <SamB> I don't think much code can be written very well in the first place...
10:21:00 <lispy> only code which does a very specific thing in very general terms :)
10:21:34 <SamB> I get the "specific thing" part, but what about the "general terms" part?
10:21:46 <Igloo> SamB: The question was whether it would be harder to write code well first time in Haskell as opposed to other languages, though
10:22:12 <lispy> i'm mostly teasing.  map would be an example of what I mean.  And map implements a pattern, so it's already been refactored.
10:23:41 <lispy> Igloo: hmm....this seems like apples + oranges
10:23:44 <SamB> in fact, I believe many programs cannot even be written in the first place
10:24:30 <xerox> Someone popped up sometime ago saying "the program I wrote in Haskell for some {home}work worked at the first try, yay to Haskell" or something similar :-D
10:25:28 <lispy> xerox: i said that recently, but homework is such a special case :)
10:25:35 <xerox> Oh :-)
10:25:55 <SamB> well, a lot of stuff works the first time it typechecks...
10:26:48 <lispy> SamB: coming from a C background, I have a superstition that it's bad luck if your code compiles on the first try :)
10:27:05 <SamB> lispy: even Hello World?
10:27:15 <lispy> :)
10:28:07 <lispy> it's of course just a superstition and should not be taken seriously
10:29:11 <lispy> as for refactoring, i tend to prototype my code in ghci, and then save it/integrate it.  I think an important bit of refactoring happens even at that level
10:30:33 <lispy> from programming in lisp/haskell i've become so dependent on the interactive prototyping that it's hard to code in other languages that don't have that.
10:30:50 <SamB> I know what you mean
10:31:09 <SamB> GDB makes a horrid REPL
10:31:13 <lispy> hehe
10:31:34 <SamB> it insists on you running a program before it will do anything!
10:31:44 <SamB> I mean, really...
10:31:57 <lispy> i wonder if anyone has a java repl yet?
10:32:30 <SamB> a Java REPL? wouldn't that require multi-line input?
10:32:58 <lispy> hmm....yeah
10:33:09 <lispy> you'd have to type entire classes, manage some state....
10:33:12 <lispy> it would be a nightmare
10:33:45 <SamB> it would be bad enough with Jython...
10:35:28 <lispy> "It thus allows you to run Python on any Java platform."  <-- great so that, Solaris, OSX, Windows, and Linux.  I think actual python runs in many more places than that.
10:35:52 <SamB> yeah
10:36:17 <Saulzar> lispy, I've always thought it was good luck if code compiles on the first try :P
10:36:18 <SamB> but, more to the point, you can use it to play with Java libraries and stuff like that
10:36:41 <lispy> SamB: ah
10:36:56 <lispy> Saulzar: the folklore i bumped into said it was bad luck :)
10:37:22 <SamB> it is unfortunately only at 2.1 afaik, but still, probably better than nothing
10:37:37 <Saulzar> I'm usually glad for not having to fix sytax errors all day
10:37:57 <Saulzar> But sometimes it miraculously just compiles straight off...
10:38:01 <lispy> cat /dev/random >> main.c
10:38:16 <Saulzar> Going to need more than a miracle for that one
10:38:24 <lispy> heh
10:38:36 <lispy> that't the command to "add luck" to your code :)
10:39:06 <SamB> lispy: that only works with Perl, silly
10:39:12 <Saulzar> Haha
10:39:26 <SamB> there is like a paper on it
10:39:38 <Saulzar> Code from /dev/random adheres to Perl style guidelines probably
10:39:49 <lispy> SamB: i heard about a paper that studied line noise vs. valid TECO programs
10:39:50 <SamB> doubt it
10:40:24 <lispy> SamB: apparently, line noise wasn't that far off
10:40:25 <SamB> lispy: yeah, but does TECO support infinite source length?
10:40:38 <lispy> what is that?
10:40:53 <SamB> /dev/random has no EOF
10:40:59 <lispy> right
10:41:18 <lispy> you'd probably hit ^C, after < 1 second
10:41:20 <SamB> hmm, oh, you used cat...
10:41:27 <Saulzar> That is if you are trying to compile directly from /dev/random ...
10:41:47 <SamB> with perl, you can just run 'perl /dev/random'...
10:41:50 <Saulzar> gcc /dev/random -o ... :)
10:41:53 <lispy> oh geez
10:41:57 <Saulzar> Hehe
10:42:12 * lispy goes to try perl /dev/random
10:42:25 <Saulzar> It might delete your files :)
10:42:36 <lispy> $ perl /dev/random
10:42:37 <lispy> syntax error at /dev/random line 1, near ")"
10:42:39 <lispy> Execution of /dev/random aborted due to compilation errors.
10:42:39 <SamB> Saulzar: it MIGHT be possible
10:42:50 <SamB> lispy: it only works sometimes, of course...
10:42:51 <Saulzar> Damn! Fail..
10:43:08 <SamB> (what do you expect, trying to run /dev/random?)
10:43:24 <xerox> It hanged
10:43:28 <lispy> i had one that didn't give an error....
10:43:36 <lispy> i got scared and hit ^C
10:43:36 <xerox> paolo@pi:~$ perl /dev/random
10:43:41 <SamB> xerox: maybe your system ran out of entropy?
10:44:14 <xerox> I get a bunch of "Unrecognized character \xF1 at /dev/urandom line 1." with random chars some time
10:44:23 <xerox> and then an hang, either with random and urandom
10:44:42 <xerox> Bareword found where operator expected at /dev/urandom line 1, near "2Y"  (Missing operator before Y?) syntax error at /dev/urandom line 1, near "2Y"
10:44:43 <xerox> :-D
10:45:03 <xerox> Unmatched right square bracket at /dev/urandom line 1, at end of line
10:45:06 <xerox> haha this is _fun_
10:45:38 * SamB has errands to do. well, okay, an errand
10:45:40 <kaol> watch out, you might make serious damage with those
10:45:56 <basti_> i dont think so
10:46:06 * kaol forgot to add the smiley
10:46:27 <xerox> YAY
10:46:29 <xerox> paolo@pi:~$ perl /dev/urandom
10:46:29 <xerox> paolo@pi:~$
10:46:40 <xerox> maybe it was "die"
10:46:53 <lispy> xerox: wow, i got that one too
10:47:59 <xerox> It's funny to get errors on line 2
10:48:07 <xerox> It means line 1 parsed OK :-P
10:48:57 <basti_> lol
10:52:21 <basti_> you should "tee" the programs
10:52:29 <xerox> yeah :-)
10:55:07 <xerox> tee foo < /dev/urandom | perl - && echo foo
10:55:28 <basti_> :)
10:55:29 <xerox> Should output well formed inputs
10:56:29 <xerox> autrijus: hiya
10:56:53 <xerox> We're threatening perl5 :-P
10:57:10 <xerox> $ tee foo < /dev/urandom | perl - && echo foo
10:57:10 <xerox> Invalid range "ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿-ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿ï¿¿" in transliteration operator at - line 3.
10:57:14 <basti_> heh
10:57:30 <xerox> (Might be a runaway multi-line @@ string starting on line 1)
10:57:38 <autrijus> nice :) have fun
10:57:42 <autrijus> <- needs to sleep now
10:57:48 <xerox> Goodnight!
10:57:56 <autrijus> finally dd'ed all my data from the broken hard disk to the new 80gb one
10:58:11 <xerox> Unterminated <> operator at - line 1.  :-P
10:59:40 <lispy> so uh, what is the license on /dev/urandom, BSD or GPL?
11:00:05 <xerox> paolo@pi:~$ perl foo
11:00:05 <xerox> paolo@pi:~$
11:00:06 <xerox> AHAH!
11:00:13 <lightstep> autrijus, why do your harddisks always break?
11:00:20 <xerox> $ file foo
11:00:20 <xerox> foo: RISC OS archive (spark format)
11:00:33 <lispy> xerox: who
11:00:35 <xerox> 540k
11:00:35 <lispy> xerox: carzy
11:01:02 <xerox> Is there a way to ask perl to operate verbosely?
11:01:23 <xerox> $ perl -c foo
11:01:23 <xerox> foo syntax OK
11:02:12 <lispy> xerox: "Dear Perl, We would like to request your cooperation.  Could you please provide us with eclucidating verbosity?  Thanks, Management."
11:02:18 <xerox> :-P
11:02:41 <lispy> not sure if that's valid perl or not....
11:02:54 <autrijus> xerox: perl -Mdiagnostics
11:03:09 <xerox> autrijus: no output!
11:03:20 <autrijus> xerox: er, follow it with whatever things
11:03:23 <autrijus> perl -Mdiagnostics -e1=2
11:03:39 <autrijus> tee foo < /dev/urandom | perl -Mdiagnostics - && echo foo
11:03:41 <autrijus> etc
11:03:41 <xerox> @paste
11:03:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:03:46 <xerox> nah.. mmh
11:04:09 <xerox> http://rafb.net/paste/results/ZwcjBT78.html
11:04:10 <xerox> :-D
11:04:16 <integral> perl -MO=Deparse ./script.pl ?
11:04:31 <xerox> $ perl -MO=Deparse foo
11:04:31 <xerox> foo syntax OK
11:05:30 <xerox> Funny.
11:05:46 <integral> o_O
11:06:20 <xerox> Maybe some prettyprinter for code can print the program itself like a quine?
11:22:47 <olliej> Lemmih: huzzah! my compiler can now parse and correctly refer to all the types in the base package :)
11:23:23 <lispy> olliej: congrats
11:23:33 <Lemmih> olliej: Yay!
11:23:55 <olliej> :)
11:23:59 <Lemmih> olliej: Got a website for you project?
11:24:29 <olliej> it's probably mentions on mindrian-script.org
11:24:54 <olliej> mondrian-script.org rather
11:26:09 <olliej> hmm... nope nothing there
11:26:18 <olliej> unless nigel has hidden it all again
11:26:48 <olliej> interesting stat, Core representation of the base package is ~460kLOC
11:29:36 <ndm> olliej, so you have compiled all the standard libraries as Core?
11:29:57 <ndm> i have to do something kind of similar in future, so might want to steal your work :)
11:30:16 <olliej> ndm: hahe, no i have parsed and got sanity checking going
11:30:30 <olliej> still have to work out how to deal with higher order and existential types
11:30:33 <olliej> among other things
11:30:48 <olliej> which the libraries end up with *everywhere*
11:31:06 <ndm> i need a program to convert haskell programs into Core, and then onwards to "Haskell Lite" - a really reduced version of Haskell
11:31:37 <Lemmih> What for?
11:32:16 <olliej> haskell programs to core: ghc -fext-core :)
11:32:32 <ndm> Lemmih, i have a haskell lite checker which checks for pattern match errors
11:32:33 <olliej> converting core to to haskell would be trivial
11:32:49 <ndm> olliej, yes - but i want to try and "track" where the original came from
11:32:55 <olliej> core is a minimal set of functionality required for the lambda calculus
11:33:03 <olliej> ndm: ah
11:33:05 <ndm> olliej, not minimal at all
11:33:14 <ndm> it still has let in it!
11:33:24 <olliej> okay
11:33:33 <olliej> hoist the lets out
11:33:47 <olliej> that's trivial (hay, i have to do it)
11:33:59 <ndm> the Haskell Lite is _really_ minimal, only functions, case, application and Constructors
11:34:12 <ndm> olliej, really ;) - that would be handy for me too then
11:34:17 <Lemmih> Pattern match errors?
11:34:28 <ndm> head [] = *bang*
11:34:39 <ndm> my checker makes sure you never get a *bang*
11:34:42 <olliej> so if you hoist the lets out you end up with haskell lite
11:34:49 <Lemmih> Want to prove the absence of them?
11:35:06 <ndm> Lemmih, yep, or detect under what circumstances they occur
11:36:32 <olliej> ndm: unfortunately by the time it becomes Core ghc has already introdces patError matches in
11:36:41 <olliej> so you wouldn't be doing the checks yourself
11:37:00 <olliej> you'd just be looking for a default action triggering a patERror
11:37:24 <ndm> yeah, thats easy enough to deal with
11:37:38 <ndm> ultimately patError must call |error|
11:37:58 <ndm> and i can model |error| as case [] of a:as
11:37:58 <olliej> something like %_ -> patError someType ...
11:38:19 <ndm> yeah, i have been through a lot of Core :)
11:38:55 <olliej> although there's a possibility (depending on optimizations) that GHC will do full inlining of patError
11:39:09 <olliej> which will mean you just have %_ -> error ...
11:39:34 <ndm> olliej, my analysis is clever enough to detect when error is called
11:39:43 <olliej> and you may not be able to tell whether that's a user defined one, or GHC catching the badness
11:39:50 <ndm> and as long as i model error appropriately...
11:39:58 <olliej> error is a function
11:39:58 <ndm> i am going to assume all error calls are bad
11:40:05 <olliej> hehe
11:40:12 <ndm> and introduce a "safeError" which means quit and report to teh user
11:40:12 <olliej> a reasonable assumption
11:40:18 <ndm> yes, but error is a primitive
11:40:21 <olliej> safeError?
11:40:26 <ndm> something like that
11:40:32 <olliej> how about expectedException ? ;)
11:40:35 <ndm> basically for execution safeError = error
11:40:39 <ndm> but for analysis they differ
11:40:48 <ndm> maybe even |die|
11:40:54 <ndm> or |exit|
11:42:42 <basti_> @type exitWith
11:42:47 <lambdabot> bzzt
11:42:54 <basti_> @type System.Exit.exitWith
11:42:56 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
11:45:11 <musasabi> GHC makes my life difficult - now all my performance problems are in the C library that is supposed to be fast and I have to touch C.
11:45:19 * musasabi wanted to tweak his haskell code instead.
11:46:21 <Oejet> musasabi: Maybe you can call the C library less times?
11:47:07 <SamB> musasabi: what is too slow?
11:47:27 <musasabi> SamB: AES encryption in libgcrypt
11:48:08 <SamB> musasabi: why is that GHC's fault?
11:49:07 <musasabi> SamB: if GHC didn't optimize my code too much I could implement the advanced serializing scheme insteadd of the naive serialization I have currently, but profiling shows it is so fast that it makes no sense to optimize it.
11:49:53 <SamB> musasabi: and?
11:50:52 <Lemmih> I think musasabi is trying to say that GHC is great (:
11:51:24 <musasabi> yes :-)
11:51:29 <SamB> strange way of saying it
11:51:56 <Lemmih> Fun way of saying it.
11:54:08 <xerox> Poll: what do you read in "I think you can just readjust this.."
11:55:57 <musasabi> That readjust can be used in that case.
11:56:08 <xerox> I was reading it read-just
11:56:15 <xerox> Did you get re-adjust at first glance?
11:56:45 <xerox> I suspect Haskell biases these kind of readings ...
11:58:53 <alar> my knowledge of the language is insufficient to even imagine the word "re-adjust"
11:59:35 <mjl69> I started a haskell club in my community.
12:00:02 <xerox> mjl69: wow!
12:00:13 <Lemmih> mjl69: Neat!
12:00:15 <xerox> How many members do you have?
12:00:27 <mjl69> want to see my website?  http://haskellcode.com
12:01:56 <mjl69> To tell you the truth, it is just a fancy place to keep my notes to myself.  I got a little carried away with it.
12:02:12 <Oejet> Haha.
12:02:59 <xerox> :-)
12:03:08 <mjl69> maybe it will grow into something real...you never know
12:17:59 <Itkovian> evening
12:18:22 <alar> midnight here :)
12:20:08 <jyp> Alhakhazam
12:20:09 <ramkrsna> alar: where do u stay?
12:21:38 <alar> ramkrshna: your guess?
12:21:57 <ramkrsna> india
12:22:07 <ramkrsna> pakisthan
12:22:12 <ramkrsna> Asia
12:22:16 <ramkrsna> ofcourse
12:22:51 <alar> near Moscow
12:22:56 <alar> Europe :)
12:23:31 <ramkrsna> jus missed by a continent ;-)
12:24:20 <alar> I guess it is 2.30 now in India
12:27:57 <ramkrsna> 1:00 AM
12:28:20 <metaperl> ramakrishna? he has physically resurrected?! :)
12:28:43 <metaperl> he wasone of the greatest Yogis of all time
12:34:45 <ramkrsna> :-)
12:38:50 * Lemmih curses his lexer to the most rotten place in hell.
12:41:40 <jlouis> If one wants to play around with HTML generation, should he look at WASH?
12:41:54 <jlouis> @fact wash?
12:41:55 <lambdabot> I know nothing about wash?.
12:41:58 <jlouis> @fact wash
12:41:59 <lambdabot> I know nothing about wash.
12:44:03 <basti_>  Recently, a paper in Nature provided evidence for a double endosymbiotic event in cryptomonad algae.
12:44:08 <basti_> whats a cryptomonad?
12:44:10 <basti_> .)
12:45:18 <gzl> jlouis: Text.Html is easier to use but I think it does less stuff
12:45:26 <alar> probably, cryptographic library implemented as monad?
12:46:14 <basti_> alar: i didnt expect to see monads show up in some commentary about biology ;)
12:46:55 * Lemmih gives up and heads to bed to cuddle up with a book.
12:48:03 <alar> basti: why? chlamidomonads are rather basic biological constructions
12:48:31 <xerox> Goodnight Lemmih.
12:49:09 <basti_> alar: :-o
12:49:37 <basti_> chlamydomonas maybe?
12:51:09 <alar> probably that
12:51:15 <alar> never had one
12:51:46 * basti_ nods
13:12:43 <Itkovian> pompom
13:41:55 <TheHunter> @where wash
13:41:57 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
14:03:55 <jlouis> WASH looks nice
14:04:03 <jlouis> though Text.HTML probably does what I need
14:10:04 * goron thinks WASH is horrible, but some people like it. 
14:12:50 * Lemmih agrees with goron.
14:15:12 <Lemmih> HSP will blow it all away. (:
14:15:18 <jlouis> hehe
14:18:16 <Itkovian> Ah Lemmih, I was waiting for you to say that
14:18:48 <Itkovian> btw, I'm desperately trying to tell Apache to execute HSP pages in my home dir, but somehow the ScriptAliasMatch directive isn't working properly ...
14:18:53 <Itkovian> prolly some typo somewhere
14:19:53 <alar> what is HSP?
14:20:02 <goron> High sensitivity as force. Discover the positive potential. OMG
14:20:16 * goron searched HSP and didn't include haskell
14:20:16 <Itkovian> alar: Haskell Server Pages
14:20:29 <goron> (and it was in my native language)
14:20:31 <Lemmih> Itkovian: Can't you just edit the 'pages' directory in the config file?
14:20:42 <TheHunter> @where hsp
14:20:43 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
14:21:02 <Itkovian> erm ... well ... that would be the next step after Apache is willing to execute server side scripts
14:21:14 <Itkovian> TheHunter: try Lemmih's implementation
14:21:27 <Lemmih> alar: I've placed some examples here: http://212.242.49.100/hsp/Browse
14:21:46 <goron> 500 Internal Server Error
14:21:46 <goron> Error specification:
14:21:46 <goron> File did not compile:
14:21:46 <goron> hsp-pages/Browse:14:25
14:21:48 <goron> parse error on input `"'
14:21:51 <goron> Good example.
14:21:56 <goron> :D
14:21:56 <Lemmih> Oh, right.
14:21:57 <Itkovian> darcs get http://www.scannedinavian.org/~lemmih/hsp/
14:21:57 <TheHunter> Itkovian, i don't do any web-stuff whatsoever, just wanted to point out the usefulness of @where.
14:22:05 <Itkovian> ah, ic. sorry
14:22:24 * Lemmih is about to move from haskell-src-ext to GHC's parser...
14:22:55 * Itkovian is resizing avi files
14:23:11 * xerox is watching a film
14:23:33 <Itkovian> which one?
14:23:36 <Lemmih> alar: The examples will be back in some time (:
14:23:48 * Itkovian is listening to Tristania - Ashes
14:24:10 <Itkovian> besides there's only stupid soft-sex movies on or political mumbo jumbo
14:25:36 <alar> ok
14:26:57 * TheHunter is amazed by the many ways "interesting" can be pronounced.
14:28:34 <Igloo> I can only think of 2
14:28:47 <TheHunter> m-w lists 5.
14:28:48 <tuomov> interesting, intresting, intÃ¶resting
14:29:08 <TheHunter> and isn't even counting inneresting.
14:31:11 <TheHunter> 'in-t(&-)r&s-ti[ng]; 'in-t&-"res-, 'in-"tres-; 'in-t&rs-
14:31:36 <tuomov> what are those &s and "s supposed to mean?
14:31:46 <TheHunter> & is a schwa, i think.
14:31:55 <tuomov> schwa?
14:32:29 <TheHunter> " is secondary stress.
14:32:40 <Igloo> Oh, if the people discussing web stuff with Haskell are still around I'd be interested to know how you think this style compares: http://urchin.earth.li/darcs/ian/bts/WebApp/Index.hs (produces http://urchin.earth.li/cgi-bin/ian/Index )
14:32:58 <TheHunter> a schwa is a very carelessly pronounced vowel.
14:34:13 <TheHunter> great, ".org" doesn't resolve again.
14:35:01 <TheHunter> @wikipedia schwa
14:35:03 <lambdabot> http://en.wikipedia.org/wiki/Schwa
14:35:32 <Lemmih> Igloo: Looks like Text.HTML wrapped in a monad.
14:38:55 <tuomov> hmm.. that would be the "Ã¶" then in my examples
14:40:49 <xerox> In this film the hero is writing C code in some anonymous window popped up with insanely long keybindings before the CIA login display manger, to bypass it :-P
14:41:00 <Lemmih> http://212.242.49.100/hsp/Browse is back up.
14:45:32 <Itkovian> only, there's not much to Browse, eh ;-)
14:46:14 <Lemmih> 9 examples isn't much?
14:47:48 <Lemmih> I'm gonna write a non-toy wiki when I get GHC's parser installed properly.
14:50:18 <xerox> Cooooooool.
14:51:32 <Itkovian> Lemmih: I couldn't see any output made by Browse
14:52:15 <Itkovian> Session, TestPage etc. seem to work though
14:53:28 <xerox> I think the browsing thing is Browse itself
14:53:38 <Philippa> Lemmih: fair enough. Am not putting enough time into Flippi for it to really be non-toy...
14:53:39 <Lemmih> xerox: Yep.
14:54:03 <Itkovian> xerox: yes, but I don't get any result back
14:54:26 <Lemmih> Itkovian: What browser are you using?
14:54:39 <Lemmih> I've only seen the page in Mozilla and lynx.
14:54:52 <Itkovian> Safari
14:55:04 <Itkovian> but it used to work, obviously
14:55:29 <Itkovian> I get this:
14:55:30 <Itkovian> <html
14:55:30 <Itkovian> ><meta
14:55:30 <Itkovian>   ><title
14:55:46 <Itkovian> I think Safari has trouble when the > resides on a different line, perhaps?
14:55:56 <Lemmih> Urk. /-:
14:56:15 <xerox> Maybe you could postprocess the output
14:56:59 <Lemmih> xerox: HSP pretty priting the XHTML like that on purpose.
14:57:43 <Lemmih> The only other way to display it is on a single line.
14:57:45 <xerox> Lemmih: I know, I mean't he could try to see if the diagnosis about Safari is right, but possibly it's simpler to save the HTML and manually edit and open in Safary.
14:57:50 <xerox> err, Safari, whatever
14:58:57 <Lemmih> xerox: Oh yeah. I could do that.
14:59:53 <Itkovian> but Lemmih, it used to work ...
15:01:58 * xerox still plays with gtk2hs/demo/cairo/drawing - soo cute :)
15:06:22 <Itkovian> Lemmih: Almost there ...
15:06:43 <Lemmih> Itkovian: Making progress?
15:06:48 <Itkovian> Error in server: HSPR/CGI.hs:54:19-42: Non-exhaustive patterns in function fix
15:06:48 <Itkovian>  please report as a bug to lemmih@gmail.com
15:07:01 <Itkovian> there ya go ... progress ;-)
15:07:21 <Lemmih> Argh
15:24:22 <Itkovian> night
16:10:25 <xerox> @index liftIO
16:10:27 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
16:10:27 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
16:10:27 <lambdabot> Monad.Error, Control.Monad.List
16:10:39 <xerox> @type Control.Monad.Reader.liftIO
16:10:44 <lambdabot> forall (m :: * -> *) a.
16:10:44 <lambdabot> (Control.Monad.Trans.MonadIO m) =>
16:10:44 <lambdabot> IO a -> m a
16:10:52 <xerox> Ah!
16:11:24 <lispy> xerox: it's just a more efficient version of liftM
16:12:07 <lispy> wait a sec, IO a -> ma
16:12:29 <lispy> I was thinking it took a function
16:12:47 <lispy> @type Control.Monad.join
16:12:48 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:12:53 <xerox> It does
16:13:34 <lispy> xerox: when a = (b -> c) ?
16:13:55 <xerox> IO a is an IO action, like a "do", IMHO.
16:14:33 <lispy> IO a is a monadic value, it can represent a compuation, but it's not what people normally mean by function
16:14:51 <alar> IO a is World-> (World,a)
16:15:53 <lispy> @type fmap
16:15:55 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f
16:15:55 <lambdabot> b
16:15:56 <xerox> IO a is an action, indeed
16:16:03 <xerox> i.e. a function with side-effects
16:16:35 <alar> yes
16:16:37 <lispy> notice that fmap takes (a->b) and a functor f.  whereas liftIO only takes IO a, ie, it only takes the functor
16:17:05 <alar> in IO monad, the monadic type is implicit
16:17:09 <alar> it is World
16:17:33 <alar> and there is only one instance of it :)
16:17:54 <lispy> liftIO isn't just an more efficient version of liftM.  They have different arity.
16:18:12 <lispy> what i'm trying to say is that my stament about liftIO just being like liftM is wrong.
16:18:39 <lispy> I need to figure the tutorial I was reading that brought up that point, and see which subtly is missing here.
16:19:33 <lispy> ah, liftIO is a specialized version of lift
16:19:37 <lispy> @index lift
16:19:38 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
16:19:38 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
16:19:38 <lambdabot> Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
16:19:38 <lambdabot> ParserCombinators.ReadPrec, Text.Read
16:19:46 <lispy> @type Control.Monad.Trans.lift
16:19:48 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
16:19:48 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
16:19:48 <lambdabot> m a -> t m a
16:26:17 <SyntaxNinja> w00t
16:26:22 <TheHunter> still not correct, i'm afraid.
16:26:56 <TheHunter> for example for ContT r (StateT s) IO, liftIO is lift . lift
16:27:56 <TheHunter> and for IO, liftIO is id.
16:28:27 <lispy> "Monads which provide optimized support for lifting IO operations are defined as members of the MonadIO class, which defines the liftIO function." <-- according to nomaware.com
16:28:34 <SyntaxNinja> I think you should all know that there is this horrible, insessent pounding going on outside my window, where construction on a parking deck is proceeding (I don't drive to work)
16:29:02 <TheHunter> lispy, right, that part is misleading.
16:29:04 <lispy> in that case, ContT r (StateT s) IO wouldn't be one of the monads which supports the optimized lifting.
16:29:35 <lispy> SyntaxNinja: fun
16:30:10 <sieni___> SyntaxNinja: I really cound't care less... they updated our apartment building's exterior some time ago and the pounding lasted for something like a year
16:30:37 <SyntaxNinja> sieni___: so you got used to it?
16:30:50 <sieni___> No I did not
16:30:56 <TheHunter> there's really _nothing_ about optimization there.
16:31:22 <lispy> my entire freshman year of collge they were doing construction staring at 6am to a building 20 feet from our building.  I hate that kind of stuff.
16:31:28 <TheHunter> MonadIO represents the class of all monads you can lift an IO action into.
16:31:44 <sieni___> I just ended up hating all construction workers except those that I personally know
16:31:59 <SyntaxNinja> progress
16:32:12 <lispy> TheHunter: huh, okay
16:32:43 <TheHunter> this is just like MonadReader or MonadState.
16:32:46 <lispy> TheHunter: which is just IO a and IO () right?
16:33:34 <lispy> i guess saying IO () is redundant
16:33:36 <TheHunter> i don't understand.
16:33:51 <lispy> what are the instances of MonadIO
16:34:12 <TheHunter> IO and all transformers stacked on top of IO.
16:34:13 <lispy> @doc Control.Monad.Trans
16:34:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Trans.html
16:44:33 <xerox> @type Control.Monad.Reader.runReaderT
16:44:35 <lambdabot> forall a (m :: * -> *) r.
16:44:35 <lambdabot> Control.Monad.Reader.ReaderT r m a -> r -> m a
16:46:52 <xerox> Gee
16:46:55 <xerox> I managed it:
16:46:55 <xerox> *Graphics.Rendering.Cairo> :t withCairo
16:46:55 <xerox> withCairo :: Surface -> ReaderT Cairo IO a -> IO a
16:46:59 * xerox bounces happily
16:47:59 <lispy> xerox: why ReadrT?
16:48:07 <lispy> xerox: what do you use it for?
16:48:19 <xerox> lispy: hide the Cairo Context.
16:48:45 <lispy> what sorts of things do you hide?
16:48:54 <lispy> (you have my interest, you can't stop explaining now :)
16:49:16 <xerox> The Cairo Context, it's just a Ptr.
16:49:57 <lispy> xerox: so before you had | do x <- get context; ... | and now?
16:50:17 <xerox> withCairo $ do
16:50:22 <xerox>   moveTo 1 2 3 4
16:50:34 <xerox>   curveTo 3 5 6 7 8 9 0
16:50:40 <xerox>   closePath
16:50:46 <xerox>   blah :-)
16:51:05 <TheHunter> i assume |withCairo someSurface $ do|
16:51:12 <xerox> Right.
16:51:37 <xerox> withSurface FormatARGB32 width height $ \surface -> do
16:51:45 <xerox>   withCairo surface $ do
16:51:47 <lispy> @pl \x y z -> foldl y x z
16:51:48 <xerox>     ...
16:51:49 <lambdabot> flip foldl
16:51:58 <lispy> xerox: nice
16:52:03 <lispy> @pl \x y z -> foldl y z x
16:52:04 <lambdabot> flip (flip . foldl)
16:52:06 <xerox> lispy: indeed
16:53:16 <lispy> so monad transformers sort of allow one of the common patterns that macros in lisp deal with
16:53:43 <xerox> In this case it allows IO actions inside the Render Monad
16:54:21 <lispy> is render monad derived from the existing monads?
16:54:48 <xerox> type Render = ReaderT Cairo IO
16:55:14 <TheHunter> why not newtype?
16:56:27 <xerox> TheHunter: hmm, why should it be newtype?
16:56:47 <TheHunter> to hide the implementation detail that you use a ReaderT.
16:56:48 <xerox> It would show up as Render a if I declare it a newtype..
16:56:51 <xerox> Right.
16:57:01 <xerox> You phrased better :-D
16:57:15 <TheHunter> also, better error messages on the use sight.
16:57:26 <TheHunter> *site.
16:57:31 <xerox> I hated the error messages before getting it working
16:59:01 <xerox> Does the newtype change the way runReaderT params should be passed?
16:59:46 <TheHunter> withCairo sur (Render m) = m `runReaderT` sur
16:59:56 <xerox> Unwrap.
17:02:15 <TheHunter> if you use generalized newtype deriving, there'll be no perfermance impact for the Monad/Functor/MonadIO operations.
17:02:51 <xerox> Good to know.
17:03:34 <xerox> In fact it isn't only m `runReaderT` sur, 'cos I have to |context <- Internal.create surface| before and |Internal.destroy context| after.  But it works, cool.
17:04:11 <TheHunter> you can also derive MonadReader Surface, and then use ask, local, etc.
17:04:19 <xerox> Also, I do { res <- runReaderT m context; ..; return res } to get -> IO a instead of -> IO ().
17:05:04 <xerox> TheHunter: the same surface could be used in different Cairo Contexts, and the Surfaces scopes usually overlaps :-\
17:05:26 <xerox> s/usually overlaps/can overlap for what I understand/
17:05:42 <TheHunter> what do you mean by overlap?
17:06:25 <xerox> http://haskell.galois.com/~paolo/darcs/cairobindings/demo/StarAndRing.hs
17:06:44 <xerox> Check the main function, it creates some surfaces and then operates on them as needed
17:07:14 <xerox> I admit it's just a translation from C code, so it's not really Haskell-ish.  That's why I'm doing this Monadic Fun.
17:07:28 <TheHunter> there's some error message on that page.
17:07:35 <xerox> Oh.
17:07:41 <xerox> @where cairo
17:07:43 <lambdabot> http://haskell.galois.com/~paolo/darcs/cairobindings
17:08:08 <xerox> Argh.
17:11:02 <xerox> I can't understand why ...
17:11:17 <xerox> $ wc -l demo/StarAndRing.hs
17:11:17 <xerox> 115 demo/StarAndRing.hs
17:12:06 <xerox> Is it still an error?
17:12:14 <TheHunter> yes
17:12:47 <TheHunter> now 404.
17:13:01 <TheHunter> and back the old one.
17:19:56 <xerox> No idea.
17:20:48 <xerox> TheHunter: http://haskell.galois.com/~paolo/StarAndRing.txt
17:20:58 <xerox> galois' machine tries to do something with .hs in urls!!!!
17:21:05 <xerox> SyntaxNinja: argh!
17:26:37 <TheHunter> Ã¾is should work with a newtype just as well as with a synonym.
17:26:52 <TheHunter> *this
17:29:05 <xerox> It does
17:29:31 <xerox> But, should I use MonadReader for Surface too?
17:30:24 <TheHunter> you don't need to.
17:30:34 <xerox> OK cool
17:30:55 <TheHunter> that is, if i understand the question correctly.
17:31:21 <xerox> That was the conclusion we come up with dcoutts too
17:32:58 <TheHunter> i would probably use implicit parameters anyway, but unfortunately, many people have misconceptions about them that make them dislike them.
17:33:45 <xerox> But I think explicit Surfaces it's good because you can |withCairo surface| every time you want.
17:36:37 <TheHunter> ok, i'm pretty sure i didn't get the question.
17:51:23 <xerox> TheHunter: uhm, using a newType I have to wrap liftIO-ed functions, right?
17:51:55 <Igloo> Derive MonadIO (or write it if you want portability)
17:52:24 <xerox> Igloo: do you mean add a constraint somwhere?
17:52:35 <xerox> somewhere, even
17:54:08 <Igloo> No, but I might have misunderstood what you want
17:54:45 <xerox> For example: paint :: Cairo -> IO ()  it's now  paint :: Render ()
17:55:09 <xerox> paint = ask >>= \context -> liftIO $ Internal.paint context
17:55:15 <xerox> paint = Render $ ask >>= \context -> liftIO $ Internal.paint context
17:55:34 <Igloo> Right, you want a MonadIO instance
17:55:41 <xerox> Ooh.
17:55:55 <xerox> In fact the error without it, was about MonadIO.
17:56:18 <xerox> @index MonadIO
17:56:20 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer,
17:56:20 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.
17:56:20 <lambdabot> Monad.Error, Control.Monad.List
18:00:37 <xerox> @docs Control.Monad.Reader
18:00:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control.Monad.Reader.html
18:02:54 <xerox> @libsrc Control.Monad.Trans
18:02:56 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Trans.hs
18:07:02 <xerox> instance (MonadIO m) => MonadIO (ReaderT r m) where
18:07:02 <xerox> 	liftIO = lift . liftIO
18:07:03 <xerox> wow O_o
18:10:25 <xerox> instance MonadIO Render where
18:10:32 <xerox>   liftIO = Render . liftIO
18:10:32 <xerox> ?
18:10:59 <xerox> or lift .
18:11:14 <xerox> But I need an instance Monad Render, don't I?
18:12:41 <TheHunter> newtype Render = ReaderT Cairo IO deriving (Functor, Monad, MonadIO, MonadReader Surface)
18:13:03 <TheHunter> your definition looks ok, too.
18:13:15 <xerox> Cool
18:13:26 <xerox> But it didn't work, GHC complains about Monad Reader :)
18:13:38 <xerox> "MonadReader Surface" ?
18:14:05 <TheHunter> oh, i'm sorry deriving (..., MonadReader Cairo)
18:14:17 <xerox> OK!
18:15:21 <xerox> Way cool.
18:15:23 <dons> moin
18:15:28 <xerox> Morning dons!
18:15:45 <dons> how's code xerox?
18:15:49 <TheHunter> moin
18:15:52 <xerox> Happy code!
18:16:05 <TheHunter> wtf? "/var/mail/thomas is not a mailbox."
18:16:08 <xerox> I'm enjoying Monad Transformers
18:16:38 <dons> TheHunter, that's a weird one
18:17:02 <Igloo> Is there a blank first line?
18:17:09 <Igloo> ISTR that's the normal cause
18:17:19 <Igloo> Or it otherwise not being a "From " line
18:17:20 <TheHunter> no blank first line
18:17:38 <TheHunter> i'm not sure. the file has 1800 lines.
18:19:47 <Igloo> OK, someone tell me I'm not going crazy please? Should this give an overlapping patterns warning?
18:19:50 <Igloo> f :: Int -> Int -> Int
18:19:52 <Igloo> f 0     y     = y
18:19:55 <Igloo> f (x+1) (y+1) = x + y
18:19:57 <Igloo> f _     0     = 0
18:20:39 <Cale> they overlap
18:21:02 <Cale> f 0 0 matches both the first and the last case
18:21:18 <Igloo> That's not what the warning means
18:21:29 <Igloo> It means there are no cases handled by one of the lines (the last one in particular)
18:22:24 <Cale> oh, right.
18:23:24 <Cale> does 0 match y+1?
18:24:01 <TheHunter> |g (x+1) = x; g x = x| gives a warning already.
18:24:12 <Igloo> I just found that too
18:24:33 <Igloo> And I'm trying in 6.2.2 and 6.4 and a 6.4.1 pre release and an old HEAD. How can this have gone unnoticed so long?
18:25:06 <Igloo> Has anyone get an up-to-date HEAD to try it on before I send off a mail about it?
18:25:22 <dons> Igloo, will do
18:25:29 <Igloo> Thanks
18:25:36 <Igloo> g :: Int -> Int
18:25:36 <Igloo> g (x+1) = 1
18:25:36 <Igloo> g _     = 0
18:25:38 <Igloo> should do it
18:25:59 <Igloo> Cale: No
18:26:19 <Igloo> Cale: y must be >= 0
18:26:25 <dons> paprika$ ghc-6.5 M.hs
18:26:25 <dons> M.hs:4:0:
18:26:25 <dons>     Warning: Pattern match(es) are overlapped
18:26:30 <Igloo> Thanks
18:26:31 <dons>              In the definition of `g': g _ = ...
18:26:55 <Cale> n+k patterns are strange
18:27:12 <arjanb> aren't bogus overlapping warnings in the known bugs of ghc?
18:27:19 <dons> n*k are fun though ;)
18:27:55 <dons> iirc, Gofer has n*k
18:28:18 <Cale> heh
18:28:27 <Igloo> arjanb: unmatched cases are, I wouldn't have thought overlapped cases would be
18:28:39 <Igloo> Well, in as much as an inability to solve the halting problem is a bug
18:29:40 <Igloo> Ah, hmm, the top list item in http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html does mention them
18:31:20 <xerox>  No instance for (MonadReader Cairo m)
18:31:22 <xerox> uhm...
18:31:48 <xerox> newtype Render m = Render (ReaderT Cairo IO m)
18:31:48 <xerox>   deriving (Functor, Monad, MonadIO, MonadReader Cairo)
18:35:53 <TheHunter> works here.
18:37:33 <xerox> Grumble...
18:39:49 <alar> what is the class Typeable?
18:40:35 <xerox> So I have this withMatrix :: (Matrix -> IO a) -> IO a
18:41:02 <alar> @where stm
18:41:03 <lambdabot> I know nothing about stm.
18:41:05 <xerox> I can't find a way to let it fit in the Render monad...
18:41:29 <xerox> liftIO would do it for the return value, but I can't use the Render monad inside :-|
18:43:49 <TheHunter> what's the definition of withMatrix?
18:44:14 <alar> @where STM
18:44:15 <lambdabot> I know nothing about stm.
18:44:25 <xerox> withMatrix p = allocaBytes {#sizeof matrix_t#} $
18:44:25 <xerox>   \ptr -> do matrixInitIdentity (Matrix ptr)
18:44:25 <xerox>              p (Matrix ptr)
18:44:44 <xerox> newtype Matrix = Ptr Matrix
18:44:57 <xerox> newtype Matrix = Matrix (Ptr Matrix)
18:45:00 <xerox> sorry.
18:45:24 <TheHunter> @google composable memory transactions
18:45:26 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
18:45:41 <alar> thanks!
18:46:17 <TheHunter> xerox, it's possible, but a little ankward.
18:46:28 <xerox> TheHunter: interesting :-)
18:47:06 <xerox> In fact Matrix will probably become an Haskell datatype, but for now it's good to have it working like this... I think.
18:47:24 <TheHunter> along the lines of withMatrix p = Render $ ReaderT $ \sur -> ... $ \ptr -> do matrixInitIdentity (...); p (Matrix ptr) `runReaderT` sur
18:48:24 <luqui> is there a more elegant way to do this construct:
18:48:26 <luqui> blah = do
18:48:30 <luqui>     if something
18:48:33 <luqui>         then do
18:48:40 <luqui>             foo
18:48:49 <luqui>                 return ()
18:48:57 <luqui> er (-4 indent on that)
18:49:05 <xerox> TheHunter: what will be the type of withMatrix ?
18:49:09 <luqui>         else return ()
18:49:16 <luqui>     somethingElse
18:49:33 <TheHunter> luqui, when something $ do
18:49:34 <TheHunter>   foo
18:49:43 <luqui> ooh, yummy
18:49:54 <luqui> thanks
18:50:27 <TheHunter> withMatrix :: (Matrix -> Render a) -> Render a
18:51:00 <xerox> sur is cairo?
18:51:15 <TheHunter> yes, probably
18:51:30 <TheHunter> and the last runReaderT should be withCairo.
18:51:48 <xerox> hmm
18:52:02 <xerox> withCairo :: Surface -> Render a -> IO a
18:52:23 <TheHunter> with arguments swapped, c'mon
18:52:47 <xerox> I don't understand why are you bringing in Surface
18:53:08 <TheHunter> basically unfamilarity with your code.
18:53:22 <xerox> :-D  Thanks for the effort, really.
18:53:44 <xerox> Let me see..
18:53:57 <TheHunter> make it newtype Render m = Render { unRender ReaderT Cairo IO m) } ...
18:54:20 <TheHunter> and then unRender (p $ Matrix ptr) `runReaderT` cairo
18:54:49 <TheHunter> (i was assuming Cairo and Surface were the same thing)
18:56:51 <TheHunter> @type Control.Monad.when
18:56:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:57:10 <TheHunter> why not Bool -> m a -> m () ?
18:57:38 <xerox> *StarAndRing> :t withMatrix
18:57:38 <xerox> withMatrix :: forall a. (Matrix -> Render a) -> Render a
18:57:41 <xerox> O_o wow.
18:58:22 <TheHunter> if you wanna see something scary that can be done with reader transformers, check lambdabot's lbIO.
18:59:29 <xerox> The .png output is scary as well :-P
19:00:17 <TheHunter> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
19:00:28 <xerox> err? :-)
19:01:06 <xerox> This unRender does something to the Cairo carried?
19:01:08 <TheHunter> you could copy the implementation and define withMatrix as lbIO (\conv -> do matrixInit...; conv $ p (Matrix ptr)
19:01:14 <TheHunter> )
19:02:56 <TheHunter> unRender does nothing at all, just unwrap.
19:06:32 <xerox> OK
19:06:35 <xerox> @where cairo
19:06:36 <lambdabot> http://haskell.galois.com/~paolo/darcs/cairobindings
19:06:51 <xerox> You prolly can't browse the .hs from the web, but you could darcs get it
19:07:53 <xerox> It needs c2hs and libcairo.  darcs get ; cd cairobindings; ghci -fffi -lcairo -i$(pwd) demo/monadicStarAndRing.hs
19:08:08 <xerox> err "make" after darcs get :-)
19:08:30 <TheHunter> what is cairo?
19:08:50 <xerox> www.cairographics.org  a vector graphic library
19:09:37 <xerox> StarAndRing.hs should still work, if you want to see the expected output.
19:09:51 <alar> a vector graphics library for what?
19:10:10 <xerox> alar: rendering
19:10:53 <cjb> It's used in the latest release of Gtk, which will make it into Gnome 2.12, so the sort of rendering that desktop environments do.
19:11:03 <xerox> (right, it needs -fglasgow-exts for monadicStarAndRing.hs)
19:11:07 <alar> oh, I see - rendering of high quality images on various backends
19:11:25 <xerox> alar: check http://gnome.org/~seth/blog/
19:12:56 <TheHunter> which file do i have to edit in debian to screw with dependencies?
19:13:16 <TheHunter> stupid c2hs depends on ghc for no reason.
19:13:28 <xerox> I installed c2hs from sources
19:13:41 <xerox> I think debian should have libcairo2 (which should be 0.9.2)
19:13:51 <TheHunter> yes, my problem is c2hs
19:13:54 <TheHunter> @where c2hs
19:13:56 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
19:15:18 <TheHunter> why would c2hs depend on ghc?
19:15:26 <alar> @help
19:15:27 <lambdabot>  @help <command> - ask for help for <command>
19:15:37 <xerox> I don't know, any clue, dons?
19:17:03 <TheHunter> Preprocessing executables for c2hs-0.14.4...
19:17:03 <TheHunter> Setup.hs: can't find source for C2HSConfig in ["base/admin","base/errors","base/general","base/graphs","base/state","base/syms","base/syntax","c2hs/c","c2hs/chs","c2hs/gen","c2hs/state","c2hs/toplevel"]
19:17:23 <xerox> .4?  uuh.
19:18:04 <xerox> Where did you get .4? :-)
19:18:20 <TheHunter> from darcs
19:18:27 <xerox> aah.
19:18:46 <lispy_> <3 darcs
19:20:18 <lispy_> i'm favorably impressed with the concurrency abstractions in GHC
19:20:34 <TheHunter> so which version should i get?
19:20:53 <xerox> TheHunter: I used .3
19:20:55 <lispy_> by combining forkIO and Chan I should be able to get a nice event model going for a big number of simultaneous connections
19:21:08 <xerox> TheHunter: tough it needs two fixes to actually compile
19:21:16 <lispy_> big being > 100
19:21:29 <xerox> c2hs.cabal:
19:21:31 <xerox> ...
19:21:33 <xerox> Category:       Development tool
19:21:33 <xerox> Build-Depends:  base,haskell98
19:21:36 <xerox> Executable:     c2hs
19:21:45 <xerox> (i.e. add Build-Depends: line)
19:22:16 <xerox> then configure build... and the second one should come up, but an ln/mv will fix it
19:23:30 <Igloo> c2hs (used to?) link with a Haskell library of its own
19:27:04 <TheHunter> gcc-3.4.3: dist/build/c2hs/c2hs-tmp/c2hs/toplevel/c2hs_config.o: No such file or directory
19:27:12 <xerox> Yes
19:27:23 <xerox> cd dist/build/c2hs/c2hs-tmp
19:27:40 <xerox> hmm
19:27:48 <xerox> cd dist/build/c2hs/c2hs-tmp/c2hs/toplevel
19:27:57 <xerox> ln -s c2hs/toplevel/c2hs_config.o
19:27:59 <xerox> IIRC
19:28:36 <xerox> Yes.
19:28:58 <xerox> and then go back to the src base and build
19:32:10 <TheHunter> how do i run the StarAndRing thing now?
19:32:35 <xerox> ghci -fffi -lcairo -i$(pwd) demo/StarAndRing.hs
19:32:36 <xerox> main
19:32:51 <xerox> watch starAndRing.png
19:33:03 <xerox> ghci -fffi -lcairo -i$(pwd) -fglasgow-exts demo/monadicStarAndRing.hs
19:33:05 <xerox> main
19:33:13 <xerox> ooops, before everything "make"
19:33:38 <xerox> To make the .hs out of the .chs and c2hs
19:33:50 <TheHunter> yeah, did taht already.
19:33:53 <xerox> (to be sure, you also need libcairo2-dev because of the headers)
19:33:55 <xerox> ok :-)
19:33:57 <TheHunter> got the star now.
19:34:00 <xerox> Cool!!
19:34:25 <xerox> monadicStarAndRing.hs writes to starAndRing.png too
19:35:30 <xerox> Saw the mess?
19:35:53 <TheHunter> which mess?
19:36:06 <xerox> What monadicStarAndRing.hs outputs
19:36:20 <TheHunter> where is monadicStarAndRing.hs ?
19:36:24 <xerox> demo/
19:36:32 <xerox> ghci -fffi -lcairo -i$(pwd) -fglasgow-exts demo/monadicStarAndRing.hs
19:36:32 <TheHunter> nope
19:36:33 <xerox> main
19:36:37 <xerox> urgh.
19:38:16 <xerox> darcs pushed.
19:38:22 <xerox> darcs pull should get it
19:40:47 <TheHunter> import Graphics.Rendering.Cairo <-- correct?
19:41:02 <xerox> I didn't add it either? Argh.
19:41:25 <xerox> I tought darcs whatsnew --look-for-adds  &&  darcs record --all  would do it
19:42:08 <xerox> Okay pushed
19:44:12 <TheHunter> ok, i see the mess.
19:44:21 <xerox> Cool, err, whatever :)
19:44:44 <xerox> Maybe there are errors in the translation...
19:50:00 <xerox> I think I have to sleep a bit, it's 04:51 AM
19:50:18 <TheHunter> good night
19:50:26 <xerox> Weren't you in an european time zone too, TheHunter?
19:50:57 <TheHunter> i'm in the us now.
19:51:11 <xerox> By the way, thanks for the insights - veru helpful.
19:51:16 <xerox> *very even, bye!
19:51:42 <TheHunter> bye
20:24:57 <lispy> @index maybe
20:24:59 <lambdabot> Data.Maybe, Prelude
20:25:09 <lispy> @type maybe
20:25:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:25:47 <lispy> is there a version of |maybe| which works like |when|?
20:26:33 <lispy> that question makes no sense i'm sure
20:27:32 <lispy> whenMaybe :: (Monad m) => Bool -> m a -> Maybe (m a)
20:27:53 <lispy> actually whenMaybe :: (Monad m) => Bool -> m a -> m (Maybe a)
20:28:16 <lispy> @hoogle Bool -> m a -> m (Maybe a)
20:28:18 <lambdabot> No matches, try a more general search
20:30:16 <lispy> @index when
20:30:17 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.
20:30:17 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
20:30:17 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
20:30:25 <lispy> @libsrc Control.Monad
20:30:27 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
20:31:19 <sylvan> So... how would that work? whenMaybe True x => Just x, whenMaybe False x = Nothing ?
20:31:30 <lispy> yeah
20:31:43 <lispy> hmm...
20:31:52 <sylvan> if b then Just x else Nothing
20:31:55 <sylvan> =)
20:32:10 <lispy> i think the type of Just x is not what i want
20:32:20 <lispy> that's Maybe (m a)
20:32:28 <lispy> i would prefer m (Maybe a)
20:33:43 <lispy> @type \b m -> if b then m >>= return . Just else Nothing
20:33:45 <lambdabot> forall a. Bool -> Maybe a -> Maybe (Maybe a)
20:34:05 <lispy> hmm...
20:34:11 <lispy> @type \b m -> if b then m >>= return . Just else return Nothing
20:34:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m (Maybe a)
20:34:20 <lispy> perefct
20:37:40 <lispy> better yet, factor the return out of both branches
20:39:35 <lispy> oh, but i can't
20:43:49 <TheHunter> @type \b -> fmap (\x -> guard b >> return x)
20:43:50 <lambdabot> bzzt
20:44:08 <TheHunter> @type \b -> fmap (\x -> Control.Monad.guard b >> return x)
20:44:10 <lambdabot> forall (f :: * -> *) a (m :: * -> *).
20:44:10 <lambdabot> (Functor f, Control.Monad.MonadPlus m) =>
20:44:10 <lambdabot> Bool -> f a -> f (m a)
20:45:07 <lispy> TheHunter: i wanted to use it with the IO monad as m, so requiring MonadPlus won't help me :(
20:46:12 <TheHunter> lispy, Maybe is generalized to the MonadPlus m, and IO generalized to the Functor f.
20:46:26 <lispy> ah
20:46:49 <lispy> i was going by f (m a), wher I want f to be Mabye
20:46:55 <lispy> er Maybe
20:47:50 <TheHunter> so you want
20:47:58 <TheHunter> @type \b x -> guard b >> return x ?
20:48:00 <lambdabot> bzzt
20:48:01 <TheHunter> @type \b x -> guard b >> return x
20:48:03 <lambdabot> bzzt
20:48:05 <TheHunter> @type \b x -> Control.Monad.guard b >> return x
20:48:07 <lambdabot> forall (m :: * -> *) a.
20:48:07 <lambdabot> (Control.Monad.MonadPlus m) =>
20:48:07 <lambdabot> Bool -> a -> m a
20:49:24 <TheHunter> @pl \b x -> guard b >> return x
20:49:26 <lambdabot> (. return) . (>>) . guard
23:04:00 * boegel greets #haskell
23:04:08 <Lemmih> Morning boegel.
23:04:18 <mwc> Wow, really quiet tonight
23:04:56 * mwc lights a string of firecrackers and throws through shapr's window
23:05:47 <boegel> Lemmih, are you writing an article on SDL stuff for HRay any time soon ?
23:06:18 <Lemmih> SDL for HRay?
23:06:30 <boegel> Lemmih, dunno :)
23:07:13 <mwc> it seems to me that the sole purpose of Arrows is to more or less be able to write Algol style code in haskell
23:07:16 <mwc> that seem about right?
23:07:28 <mwc> looking at the proc pat do syntax
23:08:06 <Cale> arrows generalise monads in some useful ways.
23:08:23 <mwc> I'm confused about them; I read on the wiki that while monads represent things that produce a value, arrows represent things that produce a value based on input
23:08:28 <mwc> which to me sounds like a functoin
23:08:48 <Cale> well, every function is an arrow
23:09:02 <Cale> (or, an arrow value)
23:09:21 <Cale> (if one regards the arrow as the type)
23:09:26 <mwc> hmm
23:09:28 <mwc> Interesting
23:09:42 <mwc> so really an arrow is a way of representing types as values
23:09:43 <mwc> ?
23:09:51 <mwc> well, types of complex functoins?
23:09:55 <Cale> er
23:09:59 <mwc> where as a monad represents a type as a value?
23:10:05 <mwc> well, you know waht I mean
23:10:10 * boegel has never gotten to Monads or Arrows
23:10:13 <mwc> it represents something that gives you a type
23:10:34 <Cale> an arrow takes two types and gives a new type
23:10:45 <mwc> cool
23:11:27 <mwc> Cale, you should write a Haskell book :P
23:11:30 <mwc> It's my ambition now
23:11:31 <Cale> the same way a monad takes one type and gives another
23:11:44 <Cale> http://www.haskell.org/arrows/
23:11:51 <mwc> Yeah, read that. OPaque
23:12:19 <Cale> (>>>) :: a b c -> a c d -> a b d -- compare this with bind
23:12:44 <Cale> (>>=) :: m a -> (a -> m b) -> m b
23:12:55 <mwc> you beat me, I was just typing it out
23:13:03 <mwc> yeah, I see now
23:13:11 <Cale> the second parameter to bind is a pure function of its argument
23:13:30 <mwc> It looked to me like an arrow was a way of describing chaining functions together "at runtime" or "in code"
23:13:33 <Cale> so it can't construct its outcome based on the first argument to bind
23:13:37 <Cale> yeah
23:13:57 <mwc> or otherwise representing their composition in value-space
23:16:20 <Cale> functions of type b -> m c for any given monad m form an arrow (in a somewhat obvious way)
23:17:01 <mwc> I've wasted two weeks reading up about all this esoteric theory instead of working
23:17:12 <mwc> There's a definite productivity hit with haskell :P
23:17:28 <mwc> reminds me to take my graph theory back ot the lib this weekend
23:17:30 <Cale> heh
23:17:51 <mwc> I got all interested in optimizing functional code and how it's transformed at runtime
23:21:13 <mwc> i suppose the way of seeing is is that an arrow is a monad with function rather than value semantics?
23:24:19 * boegel is experiencing problems with vmware again
23:30:06 <lispy> @in
23:30:07 <lambdabot> bzzt
23:30:19 <lispy_> @index char
23:30:20 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE,
23:30:20 <lambdabot> Language.Haskell.TH.PprLib, Text.ParserCombinators.Parsec.Char, Text.
23:30:20 <lambdabot> ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.
23:30:20 <lambdabot> Compat.ReadP, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
23:30:26 <lispy_> @type char
23:30:28 <lambdabot> bzzt
23:30:33 <lispy_> @type ord
23:30:35 <lambdabot> bzzt
23:30:52 <lispy_> what was the function to convert a number to a character again?
23:30:56 <lispy_> i thouht it was char
23:31:07 <lispy_> @hoogle Int -> Char
23:31:08 <lambdabot> Char.chr :: (Int -> Char)
23:31:08 <lambdabot> Char.intToDigit :: (Int -> Char)
23:31:08 <lambdabot> Prelude.toEnum :: Enum a => (Int -> a)
23:31:43 <boegel> yo lispy :)
23:32:04 <lispy> boegel: hi
23:32:21 <lispy> boegel: is it saturday morning in your part of the world?
23:34:09 <twobitsprite> hey... I'm reading the Gentle Introduction to Haskell... and in section 2.1 the mention "univerally quantified types"... can someone explain this to me, or point me to a link?
23:34:09 <boegel> lispy, it is
23:34:17 <boegel> lispy, why ?
23:34:41 <lispy> boegel: you're living in the future
23:34:51 <boegel> lispy, no I'm not :)
23:35:02 <lispy> boegel: it's still friday :)
23:35:06 <twobitsprite> lispy, maybe you're living in the past...
23:35:11 <boegel> lispy, it's not, you're living in the past
23:35:19 * boegel slaps twobitsprite 
23:35:28 <lispy> boegel: what is the future like?  have we ran out oil yet?
23:35:29 <boegel> "that was my joke you bastard"
23:35:41 * twobitsprite wins
23:35:41 <twobitsprite> :P
23:35:52 <boegel> lispy, everybody has got rid of their car, and goes by bike
23:36:26 <lispy> boegel: well, except shapr, he goes by unicycle :)
23:37:00 <twobitsprite> no... the rich use the money from thier 400% tax cuts to purchase oil and drive around in antique SUV's just to rub it in everyone else's faces
23:37:10 <lispy> i seem to be incapable of doing a real non-blocking input
23:37:54 <twobitsprite> so yeah... does any one feel like discussing "univerally quantified types"?
23:38:26 <lispy> twobitsprite: you might want to check math world actually :)
23:38:33 <lispy> findout what a universal quantifier is
23:38:52 * twobitsprite searches wikipedia
23:39:10 <lispy> i'll give you a hint that universal means everything
23:39:27 <lispy> i don't know if haskell puts a spin on the meaning tho
23:39:58 <lispy> i call hGetBufNonBlocking, do some magic to convert to a string, and yet, my program still blocks
23:40:15 <twobitsprite> I understand what the words mean, I'm just having a hard time wrapping my mind around the implications within the context of types, and even moreso within the context of haskell
23:40:27 <lispy> i replaced this function with |return "blah"|, and my program does not bolkc
23:41:06 <lispy> so i tohught, maybe it's a problem with forkIO, so I tried forkOS, same blacking behavior
23:41:20 <lispy> twobitsprite: i can't help :)
23:41:30 <lispy> i've not bothered to learn about it yet
23:44:56 <lispy> oh maybe it's blocking somewhere lse now
23:45:21 <lispy> it would appear (using putStrLn) that this function is not the culprit of the blocking
23:45:51 <mflux> strace should reveal if it's blocking on read (which does sound likely)?
23:46:03 <mflux> ..or similar tool on your platform
23:51:41 <lispy> mflux: i'm on osx, i can't find strace
23:52:05 <lispy> no truss either
23:52:17 <mflux> ktrace?
23:52:27 <lispy> ah
23:52:28 <lispy> thanks
23:53:04 <lispy> oh hm...
23:53:23 <lispy> it generated a binary file /me man ktrace
