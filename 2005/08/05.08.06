00:19:13 <boegel> @seen Itkovian
00:19:14 <lambdabot> I saw Itkovian leaving #haskell 9 days, 17 hours, 55 minutes and 58
00:19:14 <lambdabot> seconds ago, and I have missed 5 minutes and 10 seconds since then.
00:19:17 <boegel> lazy bum
00:31:31 <Maddas> @yow
00:31:32 <lambdabot> It was a JOKE!!  Get it??  I was receiving messages from DAVID
00:31:32 <lambdabot> LETTERMAN!!  YOW!!
00:38:44 <xerox> @y0w !
00:38:45 <lambdabot> Leona, I want to CONFESS things to you ... I want to WRAP you in
00:38:45 <lambdabot> a
00:38:45 <lambdabot> SCARLET ROBE trimmed with POLYVINYL CHLORIDE ... I want to EMPTY
00:38:45 <lambdabot> your
00:38:45 <lambdabot> ASHTRAYS ...
00:43:13 <ski> @ghci
00:43:14 <lambdabot>  Interesting!  A join var that isn't let-no-escaped
00:47:57 <xerox> Nifty language of the morning, nickly! <http://nickle.org/>
00:48:04 <xerox> nickle, even :)
01:16:02 <boegel> yo Itkoivan !
01:16:08 <boegel> where the hell where you ? :)
01:20:05 <xerox> @pl \x y -> f x >>= y
01:20:06 <lambdabot> (>>=) . f
01:20:59 <xerox> withCairoFromSurface :: Surface -> (Cairo -> IO a) -> IO a
01:20:59 <xerox> withCairoFromSurface = (>>=) . create
01:21:05 <xerox> How stylish is it!
01:21:20 <musasabi> pretty :-)
01:21:41 <xerox> musasabi, hi!  Did you see the blog? :-)
01:22:28 <xerox> I should have mention the #haskell support.  I'll edit.
01:23:21 <boegel> xerox: finished with your SOC work ?
01:23:53 <xerox> boegel, that's what I'm woking on :-D
01:24:02 <xerox> In fact it's downhill from here, I think.
01:24:11 <boegel> will you be able to finish it in time ?
01:24:19 <xerox> http://haskell.galois.com/~paolo/
01:24:23 <xerox> I think so.
01:24:49 <xerox> I have to implement the rest of the backends and the bindings, and then beg duncan :-)
01:24:59 <Maddas> Happy Birthday! (I blame lag for the delay ^_^)
01:25:04 <xerox> Thank you :-)
01:25:19 <Maddas> Oh, 'downhill' is good?
01:25:29 <Maddas> I was confused for a while there :-)
01:25:39 <xerox> I mean simpler, now that I understand more.
01:25:58 <Maddas> Ok.
01:26:08 <xerox> How would you have expressed it? :-)
01:26:25 <Maddas> No, that's fine, I just had a wrong saying in mind :-)
01:27:31 <xerox> Cool.
01:28:40 <Maddas> I really need some of that optimism :-)
01:40:07 <musasabi> blog?
01:40:11 <musasabi> what - where?
01:45:52 <musasabi> xerox: have you thought about automatic memory management for the cairo binding? Overall the code looked very promising :-)
01:48:50 <xerox> Is it "out to date" or "out of date" ?
01:49:04 <musasabi> out of date I think.
01:49:24 <musasabi> if you mean "something old"
01:49:50 <xerox> musasabi, thanks :-)  I was wondering about the finalizers, IIRC they're not going to be run exactly when one would expect them, in Haskell, right?
01:50:54 <xerox> I was also thinking about providing a more Haskell-ish interface, this example is more a C translation than code using the infamous Haskell potential ;-)
01:51:39 <musasabi> The order in which finalizers are run is not specified (and they may be run concurrently).
01:52:33 <xerox> Uhm
01:53:45 <xerox> Let me find what I'm thinking about in the doc.
01:54:10 <xerox> Note that there are restrictions on using the same surface in multiple contexts at the same time. If, after creating cr_a with surface you also create cr_b with the same surface, you must ensure that cr_b has finished using surface before resuming use of cr_a. Currently, the only way time at which this is guaranteed is when the the last reference to cr_b is released with cairo_destroy(). (XXX: We need to add a cairo_finish() ca
01:54:10 <xerox> ll to provide a way to achieve this explicitly). See also the CAIRO_STATUS_BAD_NESTING status.
01:55:29 <xerox> That's why I was writing withCairo* functions...
01:57:16 <xerox> withCairoFromSurface s $ \c1 -> do { ...; withCairoFromSurface s $ \c2 -> do { ... }; ... };
01:57:49 <xerox> When returining in the c1 do block, c2 is cairo_destroyed.
01:58:01 <xerox> What do you think about it?
01:58:02 <musasabi> One solution would be to keep the low level API with the explicit functions and add a highlevel api with newtype CairoM a = CairoM (ReaderT Cairo IO a) deriving(Monad, MonadReader Cairo) but I don't know cairo well enough to know whether that would be a good way.
01:58:27 <musasabi> xerox: what happens if you use c1 inside the c2 block?
01:58:35 <xerox> That's not good :(
01:59:43 <xerox> Ouch, I don't know what is a MonadReader, let me lookup some documentation.
01:59:48 <musasabi> for low level api you can just say "don't do it". You could maybe also handle the cairo handles like ST monad but I don't know if that works.
02:00:20 <musasabi> xerox: ReaderT Foo IO = pass implicit Foo around and enable IO too.
02:02:09 <xerox> Ah.
02:03:38 <xerox> Uhm uhm uhm.
02:05:21 <Maddas> Oh, you're doing this as a Google Code of Summer project, right? How's it coming along?
02:06:01 <Maddas> Who's your mentor? Has he already been bribed yet or can I still try? :-P
02:06:46 <musasabi> I think the solutions are 1) tell the user not to do it, 2) use ReaderT (if the user cannot see it he cannot misuse it), 3) use the same solution as ST (higher order universally quantified types solve problems but may take some time to understand)
02:07:28 <Maddas> Hi autrijus
02:07:32 <xerox> Yes, I am.  I had some troubles the last month - coding and vacation with your family do not mix well :(  My mentor is http://neugierig.org/, a very nice guy.
02:08:06 <Maddas> xerox: I see, I can understand that. Sounds like you're getting ahead now, though, which is always a good thing :)
02:08:19 <xerox> musasabi, I think I understand.  How do I pass the Foo part of the ReaderT to the functions inside?
02:09:01 <musasabi> xerox: you have an internal (not exported) function of getCairo :: CairoM Cairo.
02:09:16 <xerox> Maddas, yup, yesterday (err, today's early morning :P) I didn't want to go to sleep without some working code.  Keep update with my blog!  The feed is: http://haskell.org/gtk2hs/archives/category/cairo/feed/rss IIRC.
02:10:00 <musasabi> and withCairo :: (Cairo -> IO a) -> IO a becomes runCairo :: CairoM a -> IO a
02:10:22 <xerox> musasabi, sounds OK.  This way I should write an higher-level interface.
02:10:29 <Maddas> xerox: Don't have my laptop back yet, but I'll keep looking :)
02:10:49 <musasabi> offcourse that makes mixing IO and cairo harder (gtk2hs) so you should probably talk about the best solution with your mentor.
02:11:01 <xerox> I should check if there are any issues with this approach with the cairo guys, a lead developer is very interested in Haskell :-)
02:11:12 <ski> (what is cairo ?)
02:11:34 <xerox> ski, a vector graphics library with PNG/PDF/Xlib/etc backends: http://cairographics.org/
02:11:50 <ski> svg like thing ?
02:12:07 <xerox> musasabi, I was writing a mail to the mentor and the Gtk2Hs guy just two minutes ago about the integration "issue".  I have poor knowledge of Gtk, in fact.
02:12:32 <xerox> But I had this feeling that I should realize how the integration would work before going on.
02:13:10 <musasabi> xerox: well the issue is gtk functions are in the IO monad and if cairo highlevel interface is in CairoM mixing them is more complex.
02:13:40 <musasabi> of course liftIO can help. (then again do you call gtk inside cairo computations?)
02:13:51 <musasabi> if not then it shouldn't be an issue.
02:14:16 <xerox> I do not know :!
02:14:29 <xerox> I mean, I don't know how Gtk mixes...
02:15:05 <xerox> But probably I could say there is no Gtk call to do inside cairo.
02:19:56 <xerox> OK, mail sent, thanks again musasabi, now lunch :-)
02:21:30 <xerox> ski, late answer: fore example there is "svg2png - Render an SVG image to a PNG image (using cairo)"
02:21:43 <xerox> (and svg2pdf)
02:22:16 <ski> ok
02:40:08 <nothingmuch> is Either's Left typically used for errors, while Right is used for "good" values?
02:40:40 <nothingmuch> or actually: is it sane to make an instance of Monad for Either
02:41:34 <xerox> nothingmuch, check http://www.nomaware.com/monads/html/errormonad.html
02:42:13 <Maddas> Heh, I'm usually more productive for anything that requires focussed concentration when I listen to music (just reading logs)
02:42:46 <nothingmuch> my problem is that if I hear music in my head then I can't concentrate without music
02:42:53 <nothingmuch> but it gets in the way
02:42:59 <nothingmuch> xerox: thanks, that looks right
02:43:26 <xerox> I happen to need silence, or even low volume music that is simply ignorable but at the same time covers environmental sounds
02:48:30 <Maddas> That gets me distracted way faster :)
02:49:27 <Maddas> I'm curious how well one of noise-canceling headphones would work
02:49:38 <Maddas> s/one/some/
02:51:55 * xerox too.
02:51:57 <Maddas> That's actually one reason why I don't like lectures, you can't listen to music to block out background noise at the same time.
02:55:01 <jlouis> heh, I just watched a ruby-on-rails presentation. Is that the current hype?
02:55:34 <jlouis> and why I fail to understand. It seems a bit flaky in places
02:57:11 <vegai> it definitely is the current hype
03:31:37 <ski> *sigh* '... I was recently informed that a certain well-known commercial SQL product uses the term "declarative" (as in, e.g., "declarative integrity constraint") to mean "stated but not enforced"!'
03:56:44 <nothingmuch> does anybody have a reccomendation for matching ver permissive patterns on a data structure?
03:56:47 <nothingmuch> i have a huge graph
03:56:58 <nothingmuch> i want to extract a very small subgraph out of it
03:57:13 <nothingmuch> and I want to do this by matching patterns
03:57:24 <nothingmuch> and stopping when the match is good enough
04:08:00 <nothingmuch> @type msum
04:08:05 <lambdabot> bzzt
04:09:10 <musasabi> @type Control.Monad.msum
04:09:12 <lambdabot> forall a (m :: * -> *). (Control.Monad.MonadPlus m) => [m a] -> m
04:09:12 <lambdabot> a
04:12:31 <nothingmuch> musasabi: thanks
04:34:03 <nothingmuch> is there a MonadPlus function that is 'filter (/= mzero)' but with a better name?
04:41:26 <poetix> Anyone know what specific packages might satisfy dependency "cgi-any" when trying to build haskell-fastcgi?
04:45:36 <nothingmuch> under debian or something?
04:45:42 <musasabi> nothingmuch: I don't think you can do that.
04:46:00 <nothingmuch> musasabi: it makes for Maybe
04:46:20 <musasabi> for maybe it works with pattern matching, but not for generic mplus.
04:46:26 <nothingmuch> apply a function to a list of things, get a bunch of Justs or Nothings, throw away the Maybe
04:46:28 <nothingmuch> okay
04:46:31 <nothingmuch> fair enough
04:46:32 <Igloo> musasabi: Did you want anything the other day, BTW?
04:47:10 <musasabi> Igloo: I was interested in the state of new c2hs for debian but then I just ended up using the old version which worked fine.
04:47:31 <Igloo> Ah, OK
04:47:39 <Igloo> FWIW I think marcot is working on the new version
04:48:09 <musasabi> nice :-)
04:50:59 <xerox> 0.14.1 is great
05:06:36 <ValarQ> hello folks
05:07:52 <ValarQ> i'm having some problems with calling haskellfunctions from C (FFI with GHC)
05:08:09 <xerox> What exactly?
05:08:27 <ValarQ> i'm testing the example in the manual and ghc keeps saying "Type signature given for an expression"
05:09:12 <ValarQ> http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html
05:10:15 <xerox> For which line?
05:10:31 <ValarQ> 5: foo :: Int -> IO Int
05:12:33 <ValarQ> oh, i'm an idiot
05:12:40 <ValarQ> forgot -fglasgow-exts
05:12:43 <nothingmuch> is there any way to get the ghci interface to tab complete function names?
05:14:07 <xerox> nothingmuch, using it in Emacs, I think.
05:34:32 <geneticp> hi. how can I simulate an updateable global variable in haskell? , I mean: I have a small database in a list. My program need from time to time to add items to this database
05:36:22 <incomplete> State Monad or IORefs ?
05:39:10 <geneticp> aha. are there some example of state monads in the Web?
05:39:17 <nothingmuch> http://www.nomaware.com/monads/html/
05:39:24 <geneticp> I´m a mewbie
05:39:45 <nothingmuch> geneticp: do you know what monads are all about?
05:40:02 <geneticp> thanks !. monads are difficult to inderstand
05:40:11 <geneticp> I know somethig about monads
05:40:35 <arjanb> geneticp: you might first try to pass the variable around as an argument
05:40:37 <geneticp> I found this topic badly explained
05:40:50 <geneticp> the examples are far more dlarifying
05:40:51 <nothingmuch> well, in that case I'd follow arjanb's advice
05:40:53 <wilx> Hmm, speaking of state monads...would it be possible to make a list in ST monad that would have only add at the end operation and would be lazily transformable into ordinary Haskell list?
05:40:55 <wilx> Huh.
05:40:55 <nothingmuch> make a chain of calls
05:41:08 <nothingmuch> and always keep an updated variable as one of the arguments to all the calls
05:41:20 <nothingmuch> when you get sick of that, then you can appreciate exactly what the state monad can do for you =)
05:42:03 <geneticp> arjanb: that´s the thing I was tryng to avoid because it is spensive in heap usage as far as I know
05:42:26 <nothingmuch> geneticp: that's actually what the state monad will do for you implicitly
05:42:37 <nothingmuch> don't worry about it
05:43:26 <poetix> genericp: http://codepoetics.com/code/pangolin.hs <- simple interactive program, passes around a state variable that's updated after each interaction
05:43:29 <geneticp> ok
05:44:06 <poetix> s/generic/genetic/
05:44:19 <geneticp> interesting
05:44:46 <poetix> But nothingmuch is right: after a while it's easier to thread the state implicitly between expressions using the State monad
05:47:21 <nothingmuch> geneticp: in the program poetix posted 'play' is reapplied to a tree of questions
05:47:26 <geneticp> well, the rest of my code is not very clean. I will try the quick and dirty thing first, and then I will try to make it all more appealing
05:47:30 <nothingmuch> Node is essentially a binary tree
05:48:00 <nothingmuch> 'rewrite' is basically 'take the tree, and interview the user'
05:48:10 <nothingmuch> the result of 'rewrite' is either the same tree if the computer won
05:48:29 <nothingmuch> or a new tree, with the leaf where the computer made a wrong guess replaced with a new question
05:49:25 <nothingmuch> if 'rewrittenNode' was an IORef instead of an argument, play wouldn't need to know about it
05:49:29 <xerox> poetix, do you really use 8 space tabs?  How unpoetic :P
05:49:54 <nothingmuch> since the only function that really cares about it is 'rewrite'
05:50:05 <geneticp> it uses monads implicitly . It is´nt?
05:50:19 <nothingmuch> geneticp: the animal guessing came uses the IO monad to print stuff
05:50:29 <nothingmuch> and to sequence the questions
05:50:51 <nothingmuch> that is - build the knowlege base for the next game based on the previous game
05:51:21 <nothingmuch> but it doesn't use a monad to keep something like a variable
05:51:30 <nothingmuch> it could also be done with the Reader monad
05:51:38 <nothingmuch> where 'rewrittenNode' is localized
05:51:46 <nothingmuch> and rewrite 'asks' for it
05:53:47 <geneticp> with this method do I can pass structured information (like tuples) to the list database or else I must convert it to string back and forth?
05:54:15 <nothingmuch> geneticp: please rephrase your question, and maybe past some code on the wiki
05:54:27 <nothingmuch> what is your database shaped like?
05:54:34 <nothingmuch> what entries does it contain?
05:54:42 <geneticp> its a set of prolog rules
05:54:53 <geneticp> rules are lists of lists
05:55:14 <nothingmuch> and for every successful unification you want to cache the new entry?
05:55:24 <geneticp> I need to implement "assert" that adds a new rule to the pool
05:55:25 <nothingmuch> or are you just seeding the initial database?
05:55:32 <nothingmuch> okay
05:55:34 <geneticp> just assert
05:56:04 <nothingmuch> data PrologDatabase = [ Rule ]
05:56:12 <nothingmuch> data PrologDatabase = Db [ Rule ]
05:56:15 <nothingmuch> sorry
05:56:28 <nothingmuch> no, that's too complex
05:56:33 <nothingmuch> type Rule = [ ... ]
05:56:38 <nothingmuch> type PrologDb = [ Rule ]
05:57:05 <nothingmuch> then you have 'addRule :: PrologDb -> Rule -> PrologDb'
05:57:19 <nothingmuch> addRule db r = r:db
05:57:48 <nothingmuch> the part of the program that sequences assertions will simply be: 'doStuff :: db -> ...'
05:58:24 <nothingmuch> and every time it wants to do the next step with the new rule it will recurse like this: 'doStuff (addRule db newRule)'
05:58:37 <nothingmuch> so that the next call gets the updated database
05:58:53 <nothingmuch> makes sense?
05:59:49 <ski> geneticp : what do you mean by 'pass structured information (like tuples) to the list database' ?
06:00:10 <geneticp> but how I get the updated database when i need it...
06:00:22 <ski> you pass it to where you need it
06:00:37 <ski> either explicitely, or through some state monad
06:00:44 <nothingmuch> geneticp: just keep passing it to every function
06:01:04 <nothingmuch> and when you get sick of that, it's time to start using the state monad, or the reader monad, or IOrefs
06:01:07 <geneticp> I menat to add the rule, without serializing it as a string
06:01:28 <nothingmuch> geneticp: please show us the way you define the dictionary data type
06:01:28 <ski> what shape is the rule of ?
06:01:35 <nothingmuch> and the way you define a rule
06:01:35 <geneticp> nothingmuch hehehe thanks
06:01:47 <ski> and why'd you convert it to a string (is the db a list of strings ??)
06:02:05 <geneticp> I was tryng to avoid it
06:03:07 <nothingmuch> to avoid what?
06:03:35 <ski> (showing the datatype definitions, presumably)
06:03:47 <geneticp> ski  no. just I though that the rewrite call in pangolin only work with strings
06:04:13 <ski> and pangolin is ?
06:04:44 <poetix> genericp: http://codepoetics.com/code/pangolin.hs <- simple interactive program, passes around a state variable that's updated after each interaction
06:04:54 <nothingmuch> geneticp: what si '
06:04:54 <geneticp> nothingmuch to avoid to pass the Db as a parameter
06:04:57 <nothingmuch> call in pangolin'?
06:05:08 <nothingmuch> geneticp: if you want to avoid that you need to use the state monad
06:05:10 <nothingmuch> or the reader monad
06:05:12 <nothingmuch> or iorefs
06:05:13 <ski> (ok)
06:05:32 <poetix> Or the ST monad...
06:05:42 <geneticp> nothingmuch yes I understand
06:06:09 <poetix> haskell-fastcgi still not building...
06:06:35 <poetix> Complaining that 'getInputs' is not in scope in printinput.hs
06:06:39 <nothingmuch> geneticp: would you like to know how to do that?
06:06:48 <geneticp> yes , sure
06:06:51 <poetix> Which, as far as I can see, it isn't. So I'm a bit stuck.
06:07:08 <nothingmuch> would you like a translated pangolin.hs using IORefs?
06:07:47 <nothingmuch> it won't change much
06:07:53 <nothingmuch> but 'play' will no longer pass things around
06:08:10 <nothingmuch> however, since passing around really makes sense for 'rewrite' i think i'll keep that
06:08:25 <geneticp> yes It would be nice nothingmuch
06:08:40 <nothingmuch> okay, let me finish something small, and i'll do it in about 10 mins
06:08:52 <geneticp> thanks
06:09:34 <ski> (poetix : hm, you've written that pangolin.hs ?)
06:09:46 <poetix> ski: yes, quite a while ago.
06:09:52 <poetix> ski: I'd probably write it better now...
06:10:21 <ski> ok (just wondered why you didn't use @ in withArticle)
06:10:54 <poetix> ski: Same reason I used putStr foo then putStr '\n' instead of putStrLn - I didn't know you could at the time
06:11:55 <geneticp> looking at the haskell philosophy, it is funny how the designers try for one side to make functional programming useful for general programming and, in the other side, how they keep simple things made by imperative languages difficult to preserve the functional purity
06:12:05 <geneticp> and one thing goes against the other
06:12:27 <nothingmuch> ex_nor: it's not that difficult actually
06:12:38 <nothingmuch> uh, s/ex_nor/geneticp/;
06:13:10 <nothingmuch> geneticp: as an excercise right now i'm playing with writing a wiki in haskell
06:13:18 <nothingmuch> i have a wonderful freedom to do something odd:
06:13:25 <nothingmuch> the whole entire wiki is a recursive graph
06:13:35 <geneticp> but I lile haskell very much since know it two months ago
06:13:44 <nothingmuch> each page is adjacent to all the pages it links to
06:13:48 <nothingmuch> this is really fun to play with
06:14:07 <nothingmuch> in any other language I'd have to make the laziness explicit everywhere
06:14:28 <nothingmuch> so this functional purity gives back a lot
06:14:41 <geneticp> what is the wiki Web address?
06:14:53 <nothingmuch> as for monadic notations and stuff - they may seem clunky, but they're really convenient
06:14:59 <nothingmuch> have a look at Parsec if you don't believe me =)
06:15:04 <nothingmuch> the wiki is not up
06:15:10 <geneticp> ok
06:15:14 <nothingmuch> i doubt it will be
06:15:27 <nothingmuch> i'm not going to bother with the actual interface, at least for now
06:15:50 <nothingmuch> i'm working on it because I wanted to see how it could really be done
06:16:10 <nothingmuch> where the whole concept of a wiki page is described as a parser for a graph
06:18:41 <geneticp> I think that haskell has a greath potential as industrial language. but the imperative stuff  monads and so on must be made more understandable, less academic. like OCaml
06:19:34 <liyang> (But why hasn't O'Caml succeeded then?)
06:19:47 <liyang> (for some value of success.)
06:19:51 <geneticp> because they are french?
06:20:06 <geneticp> :)
06:20:33 <liyang> heh, I half expected that answer. ;p
06:21:53 <geneticp> maybe there are not enoug penetration of functional programming in the University
06:22:04 <xs> success is relative; if success is to continue to get paid to work usefully on something..
06:22:08 <geneticp> at computer sciences
06:22:31 <liyang> geneticp: I think there is, but almost everyone I know hated it.
06:22:42 <liyang> It just didn't fit their view of computation...
06:22:58 <xs> liyang: because they saw it as pointless. because "no one" uses it, so why should they learn it.
06:23:10 <Saulzar> Maybe if everyone learned a fp language before imperitive... but can that be done?
06:23:19 <ski> it can
06:23:28 <liyang> (Admittedly they were prejudiced against it to begin with, having played with their Java / VB &c. for years beforehand.)
06:23:45 <liyang> Saulzar: yes, but not often the case.
06:25:02 <Saulzar> Yes, who in thier right mind would want to learn something seen as almost purely academic before others?
06:25:27 <Saulzar> Success probably depends on success
06:25:56 <liyang> Yup.
06:26:10 <geneticp> and success of a newconer aslo depends very much in the failure of the leading ones
06:26:15 <geneticp> newcomer
06:26:35 <geneticp> there are problems that other languages does not address
06:27:59 <Saulzar> Probably fp will succeed by gradual transition if it does
06:28:03 <geneticp> for example, the increasing cost of man hours in software development, complexity, richeness of data structures and so on
06:28:06 <Saulzar> Since fp features creep into mainstream languages
06:29:21 <geneticp> once every 10 years a new lenguage is supposed to solve all the human race problems
06:30:02 <geneticp> the next to java around 2008 may be a functional language ;)
06:30:26 <geneticp> and this time it will succeed ;)
06:32:02 <liyang> Epigram? <g>
06:32:22 <jyp> Epigram is for 2020 as I see it :p
06:34:23 <geneticp> I had been looking at the Google distributed architecture. they use a map-reduce at the top level of every distributed process. updates are very expensive in distributed architecture. so a functional language makes a lot of sense in this mega-industrial context
06:38:27 <geneticp> if you are interested on that there are two interesting conference videos about the google software and hardware architecture at www.researchchannel.org
06:39:18 <geneticp> I found surprising how well the software architecture fits with a functional language
06:39:45 <geneticp> just speculations
06:44:37 <nothingmuch> geneticp: okay,. all done
06:44:43 <nothingmuch> it's slightly ugly
06:45:08 <geneticp> the rest of my code is also ugly
06:45:48 <nothingmuch> http://nothingmuch.woobling.org/pangolin.hs
06:46:05 <nothingmuch> okay, the way it works is this:
06:46:12 <nothingmuch> main creates a new IORef and gives it to playhWithIORef
06:46:43 <nothingmuch> playWithIORef has some closures in the where clause - this is there so that they can get the value bound to 'ioref' without passing it around
06:47:01 <nothingmuch> as you can see, play doesn't pass anything to oneGame, or to itself
06:48:45 <nothingmuch> uh, sorry... rewrite didn't have to be in there
06:48:52 <nothingmuch> anyway, the point is that oneGame maintains state
06:49:01 <geneticp> ok
06:49:13 <nothingmuch> since readIORef and writeIORef are part of the IO monad the real world is implicitly chained
06:49:41 <nothingmuch> writeIORef gets, as an implicit parameter, part of the result of rewrite, which gets part of the result of readIORef
06:49:53 <nothingmuch> and recursive calls to oneGame also depend on their predecessors
06:50:02 <nothingmuch> uh, i meant to 'play'
06:50:27 <geneticp> aha
06:50:31 <nothingmuch> readIORef and writeIORef can then use a constant value (the thing bound to the symbol 'ioref')
06:50:39 <nothingmuch> which you can think of as a pointer
06:50:45 <nothingmuch> and change the value stored in there
06:51:05 <nothingmuch> this is not as pretty is a it could be though
06:51:12 <nothingmuch> i suggest using a monad transformer
06:51:32 <nothingmuch> and making play and one game of type 'ReaderT Node (IO ())'
06:51:41 <nothingmuch> but I don'
06:51:47 <xerox> Did you implement it using IORef?
06:51:48 <nothingmuch> t have the willpower to make an example right now
06:51:53 <nothingmuch> xerox: yep
06:52:06 <xerox> I missed the url.
06:52:16 <geneticp> thanks nothingmuch it will check it ot detaily. I must ho away now. time to lunch
06:52:22 <nothingmuch> http://nothingmuch.woobling.org/pangolin.hs
07:23:51 <xerox> Question about the module system.  If I'm making a hierarchy of modules, should I explicitly put in the first line "module Complete.Path.To.Module (..) where" ?
07:24:00 <xerox> (If so, why?)
07:24:30 <xerox> (Any good style example to copy from?)
07:25:22 <xerox> @libsrc Graphics.Rendering.OpenGL
07:25:23 <lambdabot> http://darcs.complete.org/fptools/libraries/OpenGL/Graphics/Rendering/OpenGL.hs
07:25:34 <jyp_> xerox, you mean the (..) part ?
07:26:21 <xerox> No, the "path" part
07:26:53 <jyp_> Well, It's mandatory then
07:27:19 <ski> iirc you don't need to actually have subdirs like that if you don't want to
07:27:49 <xerox> I like them, but then I must specify the path as module Path.To.Module where?
07:27:59 <Heffalump> you don't need the complete path, just some postfix of it
07:28:25 <Heffalump> so if it's in /home/xerox/foo/bar/Module.hs, you can call it Foo.Bar.Module or bar.Module or Module
07:28:36 <jyp_> Well I've always seen fully qualified names there
07:29:05 <poetix> nothingmuch: I like the use of closures in playWithIORef - I'd not considered using that idiom (functions sharing the same environment collected under "where") before.
07:29:10 <xerox> Heffalump, then if I make /home/xerox/Quux.hs would "import Foo.Bar.Module" work?
07:29:55 <Heffalump> I think so.
07:30:19 <xerox> I'll try, thanks.
07:30:35 <nothingmuch> poetix: i use it a lot to avoid passing params
07:30:52 <nothingmuch> when I write new code i tend to place small functions that are used only once under their caller with 'where'
07:31:32 <poetix> It's particularly suitable for code with shared mutable state references I think
07:36:22 <basti_> hi
07:36:33 <Beelsebob> lo
07:50:28 <xerox> Do you think a Graphics.Rendering.Cairo.Types package is the correct way to share the types definition between the modules, or I should export them in Graphics.Rendering.Cairo and "import Graphics.Rendering.Cairo (Type1,Type2,..,TypeN)" in the modules needing them?
07:52:56 * ski would prolly prefer the first
07:53:30 <xerox> Thanks.
07:53:51 <ski> (possibly reexporting the types from Cairo, if needed)
07:54:28 <xerox> Yup!
07:55:40 <ski> (i think otherwise one'd easily get cyclic module dependencies, when not needed ..)
08:09:49 <xerox> Hmm
08:10:32 <xerox> Would you try to make as little as possible .chs files, or should I feel OK to write them instead of .hs as needed?
08:36:10 <basti_> anyone want to hear about a haskell-beats-everything place?
08:36:16 <basti_> uhm example
08:36:32 <vegai> you need to ask?
08:36:49 <basti_> .)
08:36:55 <basti_> wanted to know if anyone is listening
08:37:11 <basti_> problem: a value is read from "somewhere", and should be distributed to several clients.
08:37:14 <basti_> haskell solution:
08:37:17 <basti_> http://pastebin.com/330690
08:37:36 <basti_> written during the debate. they arrived at loopback network and semaphores in the meantime.
08:39:22 <vegai> mm
08:39:31 <vegai> have others than me found haskell code quite hard to read?
08:39:40 <vegai> even code written by yourself earlier?
08:40:52 <Saulzar> I find it tricky - because I'm a complete novice, the syntax looks very appealing compared to ocaml though :)
08:41:01 <basti_> its a bit tricky, yes.
08:41:05 <basti_> but not hard to read usually
08:42:49 <TheHunter> basti_, that should be mapM_ instead of sequence ... >> return ().
08:42:58 <TheHunter> and sequence_ $ repeat ...
08:43:35 <basti_> mmmm
08:43:37 <basti_> okay.
08:43:38 <basti_> thanks
08:43:51 <TheHunter> this is not a cosmetic thing, your code space-leaks.
08:44:05 <arjanb> i find my own haskell code hard to read sometimes and that usually means some parts need a rewrite
08:45:26 <vegai> what I mean is that it's often easy and "fun" to make the sorts of solutions that seem highly clever when you're writing them but are near to impossible to read after a day
08:46:12 <vegai> I'm not critisizing anyone, now, by the way :)
08:46:17 <basti_> TheHunter: oh thanks for the hint
08:46:17 <xerox> vegai, it happens to me too, err, et least it happened :-)
08:47:02 <xerox> vegai, I'm trying to avoid to concentrate on little details too much - that was where I was making "premature unreadable optimizations" usually.
08:47:44 <xerox> Even avoiding doing it by hand, the pretty functions still emerge, really !
08:48:12 <xerox> For example, yesterday, after writing ~100 lines of code without stressing it too much, I got:
08:48:12 <xerox> withCairoFromSurface :: Surface -> (Cairo -> IO a) -> IO a
08:48:12 <xerox> withCairoFromSurface = (>>=) . create
08:48:46 <xerox> Want me to paste a counter-exaple? :-P
08:50:56 <vegai> 18:37  vegai >> you need to ask?
08:50:59 <vegai> :-)
08:51:01 <basti_> xerox: great that you're working at hscario, btw.
08:51:29 <xerox> For a given external library, would you prefer a _complete_ verbatim binding, or a well-tought Haskellish interface?
08:51:35 <xerox> basti_, thanks, it's fun.
08:51:47 <vegai> the latter
08:52:07 <vegai> well-thought, I guess :)
08:52:22 <xerox> oops :)
08:53:02 <xerox> http://pastebin.com/330698
08:53:07 <xerox> ^- vegai <grin>
08:53:32 <vegai> indeed
09:06:47 <poetix> hmmm...those are *bad* looking compiler errors...
09:07:03 <poetix> (trying to build something using haskell-fastcgi)
09:11:54 <Lemmih> poetix: What errors?
09:12:03 <poetix> "undefined reference to 'NetworkziFastCGI_runFastCGI_closure'" - something to do with FFI?
09:12:27 <Lemmih> Looks like a linker error.
09:12:50 <poetix> The example code wouldn't compile either when I initially tried to build it
09:13:12 <Lemmih> poetix: Did you install the library with Cabal?
09:13:15 <poetix> (I did the basic Setup.hs configure/build/install procedure)
09:13:23 <basti_> @index mapM_
09:13:24 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
09:13:24 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity,
09:13:24 <lambdabot> Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:13:47 <poetix> - had to exclude the example code from the Cabal file so that the rest would build.
09:18:41 <poetix> Hold on...maybe should've done setup register on haskell-cgi first...
09:19:46 <poetix> Nope, still fails to build the examples.
09:20:06 <poetix> examples/printinput.hs:19:10: Not in scope: `getInputs'
09:40:57 <basti_> http://www.rednova.com/news/health/196561/health_chips_could_help_patients_in_us/ o.0 hi mr. orwell
09:44:47 <xerox> @type Control.Monad.Reader.runReaderT
09:44:52 <lambdabot> forall a (m :: * -> *) r.
09:44:52 <lambdabot> Control.Monad.Reader.ReaderT r m a -> r -> m a
09:45:56 <xerox> What does it mean |newtype ReaderT r m a = ReaderT { runReaderT :: (r -> m a) }| ?
09:46:08 <xerox> I mean, I don't understand the {} part of the newtype declaration.
09:46:16 <xerox> Uhm, is it a record?
09:51:52 <basti_> yes.
09:51:54 <TheHunter> yes, it's a record, but the record notation is just sugar and defines a runReaderT function. The parens around (r -> m a) are unnecessary, btw.
09:57:45 <poetix> Oh well, another totally frustrating afternoon spent trying to get some Haskell libraries to work.
09:57:55 <poetix> I thought Cabal was supposed to sort these sorts of issues out...
09:59:03 * Heffalump finds Cabal pretty unusable for all but basic stuff, sadly. I wish I had more time to dig into and fix problems when I find them.
09:59:34 <poetix> :(
09:59:40 <poetix> I guess it's early days still
10:00:25 <poetix> Theoretically the darcs get -> cabal configure/build/install -> It Just Works  toolchain could be ace.
10:00:43 <Lemmih> Heffalump: It would neat if you could mail 'em to libraries@.
10:22:06 <TheHunter> lispy, getting back to "if hugs were under darcs", wikipedia calls this Hypothetical subjunctive, and says it is more correct than "was": "Such usage is commonplace, but is perceived as erroneous in formal or educated speech and writing. In so-called contrary to fact or hypothetical scenarios such as these, the use of the subjunctive were is most assuredly warranted."
10:22:10 <TheHunter> (http://en.wikipedia.org/wiki/Subjunctive_mood)
10:23:37 <basti_> :-o
10:24:35 <vegai> would you like to read about Spivak pronouns too? =)
10:26:04 <basti_> yes.
10:26:16 <TheHunter> hmm, those spivak pronouns look like a very bad idea to me.
10:28:23 <basti_> ugh.
10:28:39 <TheHunter> feminist crap, if you ask me.
10:30:40 <TheHunter> i also don't like it if "she" is used as a supposedly gender-neutral pronoun, that disrupts the reading flow unnecessarily.
10:31:27 <Heffalump> I think picking arbitrary genders for "characters" in things you write is a good thing.
10:31:57 <Heffalump> If you find that "she" disrupts the flow of reading for you too much, perhaps you have a subconscious gender bias..
10:32:49 <TheHunter> i certainly have a subconscious gender bias, and i think everybody has.
10:33:25 <TheHunter> some of it might of course due to German being my native language.
10:34:02 <skylan> In most of my reading "he" is used as the pronoun, in cases where "she" is used, it immediately sets out as non-normative; leading me to wonder 1) is the author female, 2) is the character female, 3) why are they being non-normative, 3.1) are they closet feminists?
10:35:11 <TheHunter> it depends very much on the situation of course, but picking an arbitrary character when you actually want to talk about all possible characters is often a bad thing, imho.
10:38:59 <Heffalump> well, in English you have a choice between using a gender-specific singular pronoun and using a gender-neutral plural pronoun.
10:41:29 <TheHunter> really?
10:42:44 <skylan> I think it's not worth caring about; they is just going to do the shift you/thou did.
10:47:27 <TheHunter> "if the programmer want(s) to do A, they have to do B first" <- sounds weird to me.
10:48:48 <Heffalump> I believe that is correct. Though it sounds a bit weird to me too, which is why I prefer to use a singular pronoun. But then I think it is important to mix them up a bit.
10:48:49 <TheHunter> of course you can write "if programmers want..." but that's hard to keep up.
10:50:28 <vegai> oh dear, now I started it
10:51:14 <TheHunter> well, i'll be leaving now, but we can continue this discussion some other time..
10:51:29 <Heffalump> Automatically using 'he', particularly in a field that is male-dominated anyway, is sexist, IMO.
10:51:33 <TheHunter> but frankly, i think there's not much we're disagreeing about.
10:51:49 <vegai> Heffalump: what about automatically using 'he' in a field that is female-dominated?
10:52:07 <vegai> what about automatically using 'he' in a field that is completely 50/50?
10:52:21 <TheHunter> ok, strike that last remark. It's just common language use.
10:52:40 <vegai> I guess the problem is harder for me to comprehend, since my first language has one word for "he/she"
10:52:54 <Heffalump> TheHunter: language can change, and I think we should help it do so.
10:53:30 <TheHunter> vegai, english and german also have such a pronoun, and it's called "he".
10:53:34 <Heffalump> vegai: I think automatically using 'he' in any situation where the protagonists aren't just men is sexist, but I'm particularly interested in the computing field since that's my area.
10:53:48 <vegai> that particular change strikes me as seeking to achieve ultimate political correctness -- which is an completely stupid goal
10:54:14 <vegai> TheHunter: :)
10:54:36 <TheHunter> but i really have to go :/
10:54:39 <vegai> doesn't german have neutral pronouns?
10:54:46 <Heffalump> I don't see why it's such a problem to use 'she' as well as 'he' to refer to a person of unspecified gender sometimes.
10:55:17 <vegai> it's not typical
10:55:42 <TheHunter> because it disrupts my reading and brings that whole "sexist" issue to my mind, which is usually the last thing i want to think about in such a situation.
10:55:43 <Heffalump> of past usage, which was driven by a male-dominated society, no.
10:56:12 <Heffalump> s/^/it's not typical /
10:56:25 <skylan> I see a zero-sum game in expending energy thinking about this.  Use "she" if you want to, or use what is standard or typical of current English usage.
10:56:36 <vegai> ehh
10:56:39 <TheHunter> see you.
10:57:00 <Heffalump> I am going to try to remember to use 'she' more often as a result of this discussion :-)
10:57:29 <vegai> I just don't think that languages can be sexist
10:58:23 <vegai> is not using 'she' deliberately sexist?
10:59:13 <Heffalump> given the lack of a natural gender neutral pronoun to use, mixing up the usage is a better alternative than consistently using one.
10:59:29 <vegai> Spivak pronouns are funny though in that they emulate how most people talk
10:59:31 <Heffalump> And in fact it's becoming increasinbly common, and thus less "atypical"
11:00:19 <vegai> or perhaps just some particular British people, but still
11:00:27 <vegai> "E shaves emself"
11:00:28 <Igloo> It seems barmy to me
11:00:48 <vegai> I wonder what my English profs would do if I used those
11:01:00 <Heffalump> igloo: spivak pronouns, or using 'she'?
11:01:07 <Igloo> Using 'she'
11:01:43 <Igloo> It's better than 'he' in no way AFAICT, but doesn't flow as well for most people (I'm guessing here, admittedly)
11:02:32 <Igloo> If the goal is to get one of them "gender neutral singular pronoun" status then why not pick one of the two commonly used as that already?
11:03:15 <vegai> how about 'it'? :)
11:03:53 <vegai> "I saw a person up there, but I could not tell if it was a woman" :-P
11:04:45 <vegai> I used to confuse my 3rd grade English teachers with the question "What do I call someone if I don't the sex? He or she?"
11:04:56 <vegai> don't know*
11:05:11 <vegai> poor things...
11:05:48 <Heffalump> igloo: but the only reason it doesn't flow as well is past usage, and it's very easy to get used to it being used.
11:06:07 <Heffalump> the idea is not to get one of them that status, but for them both to have it.
11:06:11 <Igloo> Heffalump: Yes, but to go through the period of it not flowing it has to have some benefit IMO
11:06:32 <Heffalump> and the benefit is getting to a sitation where the natural use of language doesn't have an inherent bias
11:06:43 <Igloo> Why do we need 2 GNSPs?
11:07:02 <Igloo> Especially 2 confusing ones
11:07:09 <Heffalump> because having 1 that overlaps with one of the two GSSPs is bad
11:07:31 <Heffalump> inventing a completely separate one would be even better, but is much harder and more painful to switch usage to
11:07:32 <vegai> is it *so* bad?
11:07:36 <Igloo> Use "they" then
11:07:45 <vegai> I mean... we're not talking about programming languages
11:07:51 <Igloo> Like Jane Austin did, IIR the correct canonical example
11:08:00 <Heffalump> that makes it hard to distinguish singular and plural usage
11:08:18 <basti_> are you still debating this pc speech thing?
11:08:22 <Igloo> Then try to get a new word used
11:08:34 <Igloo> Using "she" only confuses things further
11:09:00 <Igloo> If they are both GNSPs then can "First he did A, then she did B" refer to the same person?
11:10:37 <Heffalump> no.
11:10:52 <Heffalump> If you read what I said when the discussion started, I said picking an arbitrary gender per protagonist is good.
11:10:59 <Heffalump> not per-use of pronoun.
11:11:45 <Heffalump> and getting a new word agreed on and used is far far harder than just using "she" in a GN way.
11:12:23 * Heffalump thinks about making an amd64 chroot
11:12:47 * ibid likes "ey"
11:27:31 <jyp> @ghci
11:27:32 <lambdabot>  Illegal overloaded type signature(s)
11:30:12 <ski> @ghc
11:30:13 <lambdabot>  Pattern bindings (except simple variables) not allowed in instance
11:30:13 <lambdabot> declarations
11:30:28 <jyp> vegai, I find haskell code extremely easy to read :)
11:54:14 <jyp> @yaaaaaaaaaaaaaaaaaaaaow
11:54:15 <lambdabot> Unknown command, try @listcommands.
13:17:15 <jyp> @hoogle [a] -> [(a,[a])]
13:17:16 <lambdabot> Prelude.zip :: ([a] -> [b] -> [(a, b)])
13:21:53 <xerox> Is there any Haskell XLib binding?
14:17:17 <poetix> Yay, working socket code
14:18:11 <poetix> I have a Python client that connects to localhost on port 8023, and a Haskell server that tells it to eff off and then closes the connection.
14:18:14 <poetix> Major progress.
14:20:40 <ndm> well done for writing a rude haskell app :)
14:24:09 <Heffalump> does it do the same thing if a Haskell client connects?
14:27:00 <ndm> poetix, is the source going to be available
14:27:17 <poetix> ndm: when it does something more useful
14:27:31 <ndm> i have a friend who has written a network client in Python, and now wants to do a Haskell version
14:27:57 <ndm> any web page or pointers to where it might appear, or ideas of timeline?
14:28:12 <ndm> will let my friend know - it might give him a hand with his client
14:28:18 <poetix> I have been frustrated today in my efforts to get some higher-level web libraries working, so decided to take a look at some of the lower-level plumbing
14:28:39 <poetix> ndm: I can paste some code somewhere if your friend wants to take a quick look
14:28:54 <ndm> if you could email it over, that would be best
14:28:59 <poetix> At the lowest level, it's really just like using the BSD API directly from any other language
14:29:02 <ndm> or just paste anywhere and i'll email it to him
14:29:18 <poetix> ndm: Righto...stand by...
14:29:21 <ndm> he's new to haskell, and i don't think anyone he knows has done a haskell server
14:32:51 <Philippa> ndm: it's all fairly boring, insofar as it's sockets as usual
14:32:52 <poetix> http://codepoetics.com/lore/index.php?title=CutAndPastePage
14:33:09 <Philippa> that said, forkIO and Chans are very much your friend
14:33:22 <poetix> Note: I should have start with withSocketsDo (be nice to Windows)
14:33:27 <ndm> he wouldn't have a clue where to start, so anything will be useful to him
14:33:53 <poetix> I think I have written the most antisocial server in the world.
14:34:05 <Philippa> poetix: there's a reason I picked the Network lib for my article's example :-)
14:34:40 <ndm> poetix, thanks very much
14:34:48 <ndm> i'll send it off to my friend
14:35:27 <poetix> Philippa: which article?
14:39:53 <Philippa> poetix: the second Impure Thoughts article on TMR
14:40:47 <Philippa> it had a bit using renamed identity monad transformers and type class instances to prevent eg using sockets operations outside a withSocketsDo
14:43:18 <poetix> So it does. Sad to say, most of what I remember about that article is the double entendres (or single entendres, as may be).
14:43:55 <poetix> Hard to focus on the matter at hand when one is being...distracted...in that fashion.
14:45:46 <Philippa> heh. I did try to keep the worst of them away from the code-relevant bits
14:45:52 <poetix> I did like the idea of creativity with type-systems as restraint-artistry; and "unsafewords" is a brilliant coinage.
14:47:04 <Philippa> in a way there's not so big a difference between "restraint" and "constraint" - a lot of more involved type systems do make sense from a constraint-solving POV
14:47:21 <poetix> Dependent types?
14:47:32 <Philippa> I'm thinking more of systems with subtyping
14:47:39 <Philippa> though type classes're a good example too
14:47:58 <poetix> Not reached that chapter of TaPL yet - I'm forcing myself to do some examples from the early chapters before proceeding.
14:48:11 <poetix> s/examples/exercises/
14:49:03 <Philippa> I don't think there's really a subtyping-as-constraints bit in TaPL (I guess some of the stuff on F-bounded polymorphism sorta works). There's rather a lot more on the big H-M chapter in ATTaPL
14:49:16 <Philippa> I still need to code up some of that
14:49:40 <poetix> Are the implementations in ATTaPL still in OCaml?
14:50:10 <poetix> It struck me that one useful exercise would be simply to translate those into Haskell.
14:50:50 <Philippa> much of ATTaPL doesn't have implementations attached, though it's not too hard to translate syntax-directed rules into code with a little practice
14:50:57 <poetix> (Chris Rathman's been converting the Oz examples from CTM into Alice on the CTM wiki)
14:51:27 <poetix> The practice is what I need. Although I haven't yet decided what *for*.
14:51:39 <Philippa> heh
14:52:11 <poetix> Just a vague sense that there are really powerful tools that my day-job coding C# is never going to motivate me to master.
14:52:16 <Philippa> I want to rig up a prototype for a strict-by-default FPL with strong use of monads and a powerful haskell-inspired type system
14:52:39 <Philippa> I'd also like to rig up one for a strict, region-based FPL
14:52:44 <poetix> Monads are almost an accidental discovery of Haskell - I mean the full range of what they can do.
14:52:55 <Philippa> as something like that could become a better C than C
14:52:55 <Philippa> yeah
14:53:05 <Philippa> they're incredibly powerful when you get it
14:53:14 <poetix> It would be interesting to see how a language designed with monadic programming in mind from the outset would do it.
14:53:15 <Philippa> even more so with monad transformers
14:53:20 <Igloo> Such a language that was source-compatible with Haskell would be nice
14:53:54 <poetix> There was a paper I saw ages ago on composing monads, something to do with coproducts I think, forget the details (and don't have the CT background to make sense of much of it)
14:54:06 <poetix> I wonder whether monad transformers are the last word in compositionality.
14:54:16 <Philippa> heh. I can't see that quite happening - though I'd prefer haskell-like syntax over the rest of the ML family
14:54:17 <jyp> poetix, Moggi's work on monads predates haskell experimentation iirc
14:54:18 <Igloo> I guess you wouldn't want to have all the "do"s around if you wanted to take full advantage of monads, though
14:54:28 <Philippa> jyp: predates and inspired
14:54:38 <Philippa> that's one I'm thinking about
14:54:54 <Philippa> you get the whole "what does return return/do I want an identity monad?" problem
14:55:07 <jyp> it contained all what we do with monads, implicitly
14:56:10 <poetix> But what initially made it into Haskell is like the tip of the iceberg there
14:56:25 <poetix> I mean I could have the timelines wrong, but I guess IO came first...?
14:56:52 <jyp> Walder initially played with lists and the like
14:57:28 <poetix> http://lambda-the-ultimate.org/classic/message12291.html <- Ah, here's the coproducts paper (on LtU)
14:57:49 <jyp> Wadler... can't seem to ever get it :p
14:57:58 <Philippa> lists're a good example though
14:58:18 <poetix> A better example than IO in some ways.
14:58:20 <Philippa> if only because they're a great "look, it's really /not/ a state monad in disguise" example
14:58:28 <poetix> If you started with lists - ah, you just said it.
14:58:31 <Philippa> IO's a nasty example just because it's not implementable in haskell
14:59:02 <Philippa> there's a hell of a lot of monads that do clearly follow a "state monad wrapping an abstract machine's state" kind of pattern
14:59:27 <Philippa> I suspect even List and Maybe can be shown to be optimised examples thereof
15:00:06 <Philippa> but the big deal is that they have more than just state propagation happening in >>=
15:04:55 <jyp> imo List is not related to state at all
15:05:37 <jyp> well... if you consider backtracking as state, maybe :)
15:06:44 <jyp> but it's complicated because a List state exists because of lazy evaluation
15:17:02 <putter> Is there a ghc analog for ccache?
15:19:12 <Philippa> jyp: a list state'd exist under strict evaluation too. Even more so. It's just that the AM wouldn't have a completely separate "result" field the way plain state does
15:20:02 <Philippa> it probably makes more sense if you forget about state monads and just think about "state of abstract machine"
15:22:51 <putter> guess not.  ah well.  thanks.  (back to #perl6, in case anyone thinks of something)
15:24:43 <jyp_> 'night all
15:37:35 <jks> Hi! - Anyone knows an irc channel with a topic related to programming language semantics in general? - or the pi-calculus specifically?
15:50:15 <basti_> :-O
16:02:47 <wagle> jks: this channel isnt bad for that
16:02:56 <wagle> otherwise, i dont know
16:03:15 <jks> okay, thanks!
16:03:41 <jks> I wonder if anyone here could give me some advice regarding type-inference in languages with dependent types?
16:03:58 <Philippa> "talk to Conor McBride" :-)
16:04:15 <jks> I'm looking at Ceddric Lhouisaine's type inference algorithm for d\pi, but I'm having a little trouble understanding completely how it works ;-)
16:15:29 <autrijus> woot. perl6 officially gains type inference and arrow type constructors.
16:16:00 <autrijus> sub f (Int $x --> Int $y) { ... }
16:18:33 <heatsink> what means that?
16:18:52 <autrijus> (f :: Int -> Int) = \x -> \y -> ...
16:19:57 <heatsink> \x -> \y -> ... has type (x -> y -> z)
16:20:09 <autrijus> er.
16:20:14 <autrijus> what am I thinking?
16:21:00 <autrijus> (f :: Int -> Int) = \x -> {y = ...}
16:21:17 <heatsink> oh, ok
16:21:23 <autrijus> (named binding is legal bothways)
16:21:39 <autrijus> i.e. all positionals are also usable as nameds. sort of like ocaml labels
16:22:07 <heatsink> f returns a value by binding the name y in the caller's scope?
16:22:43 <autrijus> aye. if the caller calls it like that
16:22:48 <autrijus> my $var = f(1);
16:22:53 <autrijus> then $var gets that y
16:22:53 <autrijus> but
16:22:58 <autrijus> my ($x, $y) := f(1);
16:23:02 <autrijus> then $y is bound and $x is undef.
16:23:15 <autrijus> it's implemented as typed return continuations.
16:23:22 <autrijus> with named binding as part of the type.
16:24:43 * heatsink doesn't get it
16:25:39 <autrijus> oh ok. perl is imperative; you can trigger a function exit early with return()
16:25:44 <autrijus> so, this:  sub f (Int $x --> Int $y) { ... }
16:25:56 <autrijus> means that the "return" function inside f's body has type
16:26:07 <autrijus> return (Int $y --> Any)
16:26:17 <heatsink> okay
16:26:21 <autrijus> so you can call it as
16:26:24 <autrijus> return(y => 3)
16:26:33 <autrijus> or also return(3), which means the same thing
16:26:41 <autrijus> if the caller is expecting $y, then $y is bound by name
16:26:53 <autrijus> it's as if the caller is the body of the return function
16:26:59 <autrijus> and return() is calling that function.
16:27:14 <heatsink> Okay, so it returns a dictionary
16:27:14 <autrijus> which, if you think return() as invoking the caller's continuation, it is exactly that.
16:27:44 <autrijus> it actually just return 3, with the 'y' part inferred from its type
16:27:51 <autrijus> but yes, conceptually it returns a dictionary.
16:30:11 <heatsink> Can a function return multiple values this way?
16:31:14 <autrijus> sure
16:31:38 <autrijus> sub div ($x, $y --> ($val, $rem))
16:31:59 <autrijus> and currying would work too:
16:32:15 <autrijus> my &return2 = &return.assuming(val => 3);
16:32:23 <autrijus> return2(5); # rem => 5
16:32:25 <autrijus> so it's all good.
16:32:35 <heatsink> cool, return is a real function :)
16:32:44 <autrijus> yeah, I fought for that for some time now :)
16:32:53 <heatsink> then (return return) is call/CC, right?
16:33:03 <autrijus> (return &return)
16:33:42 <autrijus> well, I'm not sure if &return captures the control stack in itself, so probably not.
16:34:19 <autrijus> but there is already a &?CALLER_CONTINUATION builtin, so return that would capture the control stack to become a full callcc.
16:35:05 <heatsink> well, perl has evolved in some interesting ways.
16:36:54 <autrijus> :)
16:37:42 <autrijus> we're also thinking about ways to hack in Curry's "=:=" and "$var is free" semantics.
16:38:38 <heatsink> The problem is, I'm from the school of thought that each language feature should mean only one thing.
16:38:58 * heatsink wants =^_^= semantics
16:39:48 <autrijus> :D
16:39:49 <Philippa> did :-) ever become an operator?
16:40:17 <Cale> It'd be a data constructor I suppose :)
16:41:25 <autrijus> pugs> sub prefix:<(:-))> ($x) { $x * 3 }; (:-)) 10
16:41:25 <autrijus> 30
16:55:58 <autrijus> mm --> is right associative too.
16:57:33 <autrijus> sub infix:<$> (&f:(::a --> ::b) --> ::a $x --> ::b) {f($x)}
16:57:58 <autrijus> this looks like a too-heavily punctuated version of a certain language.
17:07:44 <wagle> isnt that haskell?
17:07:49 <heatsink> XD
17:09:23 <autrijus> yup :)
17:09:26 <wagle> that looks better than some of the haskell the fp people try to give talks about with oo people in the audience
17:09:35 <autrijus> the body should read
17:09:51 <autrijus> { sub ($x) { f($x) } }
17:10:03 <autrijus> or, as a shorthand:   { f($^x) }
17:10:03 <wagle> the oo people just sit there stunned, with the wtf expression on their face
17:10:25 <autrijus> heh, true
17:10:55 * autrijus has the luck of having java people as cow orkers who thinks that inferencing makes programs unreadable
17:11:16 * metaperl loves type inferencing
17:11:28 <autrijus> metaperl: perl6 is getting them. :)
17:11:32 <metaperl> oh my
17:11:34 <wagle> kinda true..  giving the raw type signature really isnt a help
17:12:15 <wagle> foo is defined by the type signature Int -> Int -> Int -> (Int -> Int) -> Boolean
17:12:42 <autrijus> wagle: right, which is why perl6 (and ocaml) places labels as part of the type signature, I think
17:12:54 <wagle> i tried to use an unamed haskell package with vast amounts of documentation solely in that form
17:14:00 <wagle> i had to look at the implementation/source to see what the args were called
17:14:10 <wagle> s/called/named/
17:14:33 <autrijus> nod. I wonder where did haskell get the detached type signature idea.
17:15:03 <autrijus> it does have the advantage of making type variables stand out, though, instead of requiring things like `a or ::a
17:15:53 <heatsink> it's more often comprehensible when none of the arguments are the same type
17:16:32 <autrijus> Int -> String -> IO ()
17:16:35 <autrijus> doesn't quite help
17:16:36 <MarcWebe1> Do you know what reactive objects are?
17:18:25 <wagle> in what context?
17:18:49 <MarcWebe1> wagle: io/ user interfaces
17:18:52 <Philippa> It'd be nice if haddock let you supply a pattern for documentation purposes only
17:19:44 <autrijus> Philippa: indeed, I resorted to use #ifdef HADDOCK sections.
17:20:19 <Philippa> does that actually work? I've not messed with haddock enough, but I would've thought the possibility for multiple patterns was a problem?
17:20:42 <Philippa> it'd be great for a future IDE though
17:21:06 <Philippa> (I guess said IDE could always show all non-documentation patterns if there isn't a doc pattern)
17:21:28 <autrijus> it does work but only with -cpp
17:58:32 <wagle> someone just handed me a recursive bash script
17:59:02 <liyang> is it tail recursive?
17:59:55 <wagle> no, its a depth first search, of sorts
18:04:45 * heatsink tests programs' tolerance of recursive symlinks
18:05:40 <wagle> is the limit approaching infinity defined?
18:05:43 * heatsink discovers that there's an errno for that
18:05:56 <heatsink> limit of what?
18:06:09 <wagle> the meaning of the open
18:06:15 <wagle> the meaning of the openfile
18:06:31 <heatsink> nope
18:14:55 <heatsink> nope
20:24:23 <TheHunter> any native american-english speakers around?
20:24:53 <ayrnieu> Yes.
20:25:09 <ayrnieu> What do you need?
20:25:13 <TheHunter> http://en.wikipedia.org/wiki/Cot-caught_merger
20:25:34 <TheHunter> they claim that rock and caught has the same vowel in like half of the us.
20:25:42 <TheHunter> that's not true, is it?
20:26:47 <ayrnieu> not for me.  I guess with a kind of southern accent, it would work out that way...
20:27:08 <ayrnieu> I'm not familiar with accents beyond my own, sorry.
20:27:24 <TheHunter> ok, thanks.
20:28:12 <Cale> TheHunter: cot and caught sound the same here, as far as I can tell. If there's a difference, it's pretty small.
20:28:52 <threeve> TheHunter: that's actually quite true.  Most people in the US have very poor pronunciation/enunciation...
20:29:05 <ayrnieu> FSVO 'poor' :-)
20:29:20 <TheHunter> but the o in rock usually is an a-like sound, isn't it.
20:29:38 <ayrnieu> I actually say 'cot' and 'caught' differently, but I don't think I could tell the difference by ear.  This might be a case of poor enunciation.
20:29:51 <TheHunter> (i've never heard the word 'cot')
20:30:12 <Cale> the 'o' in rock"
20:30:20 <Cale> the 'o' in "rock" sounds like "ah"
20:30:46 <ayrnieu> hunter - when I was in the daycare 'la petit(e)' we had nap-time on cots :-)
20:31:02 <ayrnieu> see, I say rock and cot differently, but I don't think I could tell the difference by ear...
20:31:13 <threeve> Right, so cot is like c-ah-t, and most people pronounce caught similarly, but caught is really more like c-aw-t
20:32:28 <Cale> I'm unsure of the difference between 'aw' and 'ah'
20:32:54 <TheHunter> threeve, yes, that's how i think it's usually done.
20:33:02 <ayrnieu> awww, does Cale not understand the difference between 'aw' and 'ah'?  How *sad*.
20:33:04 <threeve> caught sounds like thought, cot sounds like rot
20:33:07 <ayrnieu> ah, OK.
20:33:23 <thebug> oh hello threeve
20:33:25 * ayrnieu official stops representing American English speakers.
20:33:29 <thebug> and TheHunter
20:33:50 <threeve> irc is the wrong mechanism to try to discuss phonetics :)
20:34:00 <TheHunter> hey thebug
20:34:14 <Cale> ayrnieu: well, I understand it conceptually of course, and the tone would be different based on which was being said, but not the actual vowel
20:34:31 <thebug> midwest is a bad place to try and discern 'cot' and 'caught' ... midwest vowel chain shift obliterates them
20:34:45 <ayrnieu> I don't think the tone is all the difference, but OK.
20:35:09 <threeve> hello thebug
20:35:33 * thebug hasn't been following this conversation, just the last ... 30 sec or so :P
20:35:33 <Cale> It would be the short 'a' sound either way.
20:36:03 <TheHunter> Cale, you're not talking about aw as in law?
20:36:30 <thebug> 'aw' as in law is the 'augh' sound in 'caught'
20:37:02 <Cale> the end of "law" sounds the same as "ah"
20:37:04 <thebug> irc also doesn't have IPA support, which would be helpful :P
20:37:17 <thebug> Cale: where are you located, geographically?
20:37:34 <Cale> Southern Ontario
20:37:44 <Cale> (inside the green line)
20:37:54 <threeve> Cale: thebug is right.  the 'aw' of law should be the same as the 'augh' in caught
20:38:25 * threeve wonders if Cale knows people from Boston, who might very well pronounce law as 'lah'
20:38:51 <TheHunter> what's in example word for 'ah'?
20:38:51 <thebug> threeve: that's what I was thinking ...
20:39:21 <threeve> TheHunter: father
20:39:33 * thebug agrees
20:39:44 <TheHunter> threeve, yes, thanks, that's what I was thinking.
20:40:28 <TheHunter> thebug, do most mi people have that vowel shift?
20:40:41 <thebug> TheHunter: you're experiencing the same thing I did last week ... german <-> english vowels are totally different
20:40:48 <TheHunter> i notice it sometimes, but not on everyone.
20:40:49 <thebug> TheHunter: I'd say so
20:41:07 <thebug> then again, I've lived here all my life, so I really don't notice it unless I'm paying attention
20:41:18 <threeve> My biggest pronunciation pet peeves are wash => warsh, and milk => melk.
20:41:56 <thebug> threeve: I don't tend to notice people say warsh around here, that's more of a new york + east coast thing, though 'melk' is super common
20:42:06 <samc> reminds me of the posix pronunciation advice: pah as in positive
20:43:09 <ayrnieu> oh, I say poe as Edgar Allen.
20:43:32 <TheHunter> same here :/
20:43:50 <TheHunter> thebug, interesting have you done any phonetics?
20:43:53 <ayrnieu> If they wanted 'pah', they should've spelled it to reflect that >_<
20:43:54 <samc> I say neither of those
20:44:06 <threeve> thebug: warsh is not so common where I am now (Chicago) but was much more common in central IL
20:44:10 <thebug> TheHunter: some, yeah
20:44:38 <thebug> threeve: I hear 'pahsta' and 'sammich' a lot around chicago (gf lives there, so I visit there frequently)
20:45:30 <TheHunter> thebug, how would you say 'pasta'?
20:45:34 <threeve> isn't "pahsta" the right way to say it??
20:45:37 * threeve goes to check
20:45:44 <thebug> nono, I meant something different
20:45:44 <TheHunter> man, too many nicks starting with th..
20:45:49 <thebug> I say 'pahsta'
20:46:11 <thebug> they say something like 'pAHstah'
20:46:32 <thebug> I can't really do this over irc :P (I need to patch irssi for IPA support)
20:46:35 <thebug> hehe
20:46:37 <threeve> Ah, you mean the stereotypical Chicago accent?   Da Bears!
20:46:56 <thebug> not quite stereotypical in that sense, but sure, we'll say that's what it is
20:47:09 <thebug> 'western suburbs' accent :P
20:47:20 <threeve> Thankfully I don't have that, only lived here a couple years.
20:49:36 <samc> it's when people drop consonant sounds that's annoying; innernet, vunerable, etc
20:49:49 <thebug> 'terrists' is my big pet peve
20:50:41 <samc> especially if they have nucular weapons!
20:51:13 * TheHunter usually says 'innernet' and 'terrists'..
20:52:23 <TheHunter> i thought that's just the usual american pronunciation.
20:53:31 <TheHunter> thebug, is "what's that"/"t's tha" a local thing here?
20:53:57 <thebug> 't's tha?' never heard that
20:54:38 <TheHunter> hmm.
20:55:16 <samc> apparently we say "immense pest frenzies dog"
20:55:20 <ayrnieu> hunter - huh?  I've never heard anyone say 'innernet' or 'terrists'.
20:55:43 <ayrnieu> Even GWB doesn't say 'terrists'.  Maybe to your untrained ear :-)
20:56:19 <TheHunter> ayrnieu, there might be a very very slight 't'/'o' in these words.
20:56:37 <thebug> 'wot' ?
20:57:21 <TheHunter> what's that?
20:58:38 <TheHunter> ayrnieu, i'm very sure about 'innernet', though.
21:00:02 <ayrnieu> no, no, untrained ear.
21:00:39 <samc> humbug
21:05:30 <TheHunter> ayrnieu, you may have a point there, i just taped myself saying 'internet', and it doesn't sound quite right.
21:05:51 <thebug> it's just a really clipped 't' usually
21:06:14 <samc> pshh, sometimes it's even "innerneh"
21:06:31 <thebug> HA HA I'M USING THE INTARWEBS
21:06:38 <ayrnieu> You don't say IN TER NET unless you are trying to speak like an angry Star Trek alien.
21:06:49 <thebug> 'ugly bags of water'
21:06:52 <samc> or you don't come from the US
21:07:11 <ayrnieu> yeah, what's with forinners are trying to speak like angry ST aliens?
21:13:34 <samc> to be fair, in fast speech I drop the 'r'
21:15:10 <threeve> funny, most people I know pronounce internet like 'google' :)
21:16:13 <thebug> or 'ay oh ell'
21:18:16 <heatsink> samc: you don't glottalize the final consonant?
21:18:41 <heatsink> glottalize = stop airflow with epiglottis
21:19:10 <samc> that clears that up then
21:19:28 <samc> no (If I know what you mean)
21:21:24 <ayrnieu> samc - a glottal stop happens in, oh, "Cap'n".
21:21:53 <ayrnieu> "Avast!  Blow the man down!"  "Cap'n!  Your hook!"
21:21:53 <thebug> who, by the way, produces a fine, tasty breakfast cereal
21:21:57 <ayrnieu> Indeed.
21:25:39 <samc> huh, whereabouts in Cap'n? C aiflow stopped by tongue against roof of mouth, P aiflow stopped by lips, N airflow stopped by tongue against teeth/gums
21:25:53 <ayrnieu> where the apostrophe is, samc.
21:26:04 <ayrnieu> Cap*glottal stop*n!
21:27:07 * samc must be glottal stoppage defective
21:27:37 <samc> as in "loch" ?
21:27:41 <ayrnieu> er, no.
21:27:42 <heatsink> No
21:28:33 * heatsink can't recall hearing a final t completely elided
21:29:46 <ayrnieu> I can see "can't" pronounced with a glottal stop instead of a t, at the end of a sentence.
21:30:15 <samc> oh as in "uh-oh"
21:30:21 <heatsink> yes
21:30:27 <samc> then no
21:31:46 <TheHunter> does glottal stop mean no 'p' sound in "cap'n"?
21:31:52 <samc> neither do I in Cap'n
21:32:20 <ayrnieu> hunter - no, it means that you glottally, er, stop between the p and the n.
21:32:44 <ayrnieu> samc - I've no idea how you'd say Cap'n without one.
21:32:55 <ayrnieu> pn.  PN.  pn.pn.pn.
21:33:08 <ayrnieu> bah, that has an I.
21:33:26 <ayrnieu> ka-pin?
21:33:41 <ayrnieu> put the emphasis on the CAP :-)
21:33:51 <thebug> CAPn
21:34:08 <thebug> ah yes, the pirates of #haskell
21:34:32 <TheHunter> ok, got it.
21:34:53 <ayrnieu> International Talk Like a Pirate Day is coming up, in September.
21:36:19 <samc> avast, but you have to exhale to make a p sound which is more or less an i anyway
21:41:33 <samc> immense pest frenzies dog
21:41:44 <samc> ok back to coding
21:47:38 <thebug> ayrnieu: sept. 19?
21:48:02 <ayrnieu> That sounds about right.
23:34:24 <luqui> how can I write a case expression on one line?
23:34:42 <luqui> (I don't intend to, I'm just wondering)
23:37:38 <Lemmih> @plugs case 10 of 5 -> True; 10 -> False; _ -> error "Invalid number"
23:37:39 <lambdabot> False
23:38:24 <luqui> easy enough.  thanks
23:41:38 <lispy_> @eval case 5 of {5 -> True; 10 -> False; }
23:41:40 <lambdabot> True
23:44:38 <luqui> what do you tell import to exclude certain functions?
23:45:26 <luqui> nevermind
23:51:58 <luqui> import Prelude hiding length
23:51:59 <luqui> parse error on input `length'
23:52:03 <luqui> wtf
23:52:31 <Lemmih> Put parentheses around it.
23:53:20 <luqui> hmm.. might want to get that changed in the tutorial
23:53:24 <luqui> thanks
