00:01:10 <lispy> what is the M?
00:01:38 <lispy> it feels so good to eat :)
00:04:14 <Cale> STM stands for Software Transactional Memory
00:05:56 <Cale> research.microsoft.com/~tharris/papers/2005-ppopp-composable.pdf
00:08:57 <autrijus> STM is like State, but multithread safe and has database-like automagically rollback.
00:09:40 <Lemmih> s/State/ST?
00:12:07 <autrijus> er, sorry.
00:12:37 <autrijus> and I find ST programs that spans multiple toplevel functions hard to type
00:12:40 <autrijus> and hard to Type
00:12:49 <autrijus> esp. when you start writing higher order ST functions.
00:13:15 <autrijus> it's annoying that type synonyms doesn't work for them.
00:13:33 <autrijus> (because the "forall" need to be written out by hand)
00:13:58 <autrijus> and GHC's inferencer got them wrong, instead of right, most of the time.
00:14:03 <autrijus> so it feels like writing Java all over again
00:14:30 <lispy> hmmm
00:15:41 <lispy> @type Control.Monad.liftIO
00:15:52 <lambdabot> bzzt
00:15:57 <lispy> @hoogle liftIO
00:16:09 * Lemmih wonders how hard it would be to steal GHC's Haskell parser.
00:16:16 <Lemmih> @type Control.Monad.Trans.liftIO
00:16:18 <lambdabot> forall (m :: * -> *) a.
00:16:18 <lambdabot> (Control.Monad.Trans.MonadIO m) =>
00:16:18 <lambdabot> IO a -> m a
00:16:55 <autrijus> lispy: your main i/o functions can be rewritten so you won't have to write liftIO all the time.
00:17:18 <autrijus> puts :: (MonadIO m) => String -> m ()
00:17:22 <autrijus> puts = liftIO . putStrLn
00:17:24 <shrimpx> Lemmih: programatica has a haskell frontend that i've heard is nice
00:17:35 <autrijus> but somehow some people find explicit liftIO helps readablility.
00:17:37 <autrijus> ymmv.
00:18:39 <musasabi> Lemmih: the haskell-src-exts parser is quite good.
00:18:56 <Lemmih> musasabi: I'm trying to replace haskell-src-exts.
00:19:07 <lispy_> autrijus: so what is liftIO doing?
00:19:08 <Lemmih> musasabi: It has serious problems.
00:19:27 <autrijus> lispy_: it's promoting (IO a) into (ReaderT World IO a)
00:19:27 <musasabi> what problems (as my own code uses that too) ?
00:19:46 <autrijus> lispy_: it lets you use bottom-level IO actions in the top-level transformed ReaderT+IO.
00:20:18 <Lemmih> musasabi: It doesn't understand line pragma's.
00:20:48 <musasabi> Lemmih: wouldn't it be easy to hack support for those?
00:20:53 <Lemmih> musasabi: And there's some GHC Haskell it can't parse.
00:20:54 <lispy_> autrijus: to be frank, the reader monad is really bazaar to me...
00:21:12 <Lemmih> musasabi: And you can't select which extensions to enable.
00:21:14 <musasabi> Lemmih: I have some fixes e.g. for infix types that make it more liberal.
00:21:47 <Lemmih> I think it would be easier to steal the code from GHC than fixing haskell-src-exts.
00:22:16 <Lemmih> Especially since nibro is unresponsive.
00:22:21 <Lemmih> nibro: Wake up!
00:22:27 * musasabi would like one haskell parser to rule them all from the package language where the bad parser is.
00:23:03 <musasabi> Lemmih: he is responsive to email.
00:23:35 <musasabi> If you end up stealing the GHC code please *do* package it up.
00:23:36 <Lemmih> musasabi: Really? He hasn't responded to any of my mails for weeks.
00:24:32 <musasabi> I was mailing him in the beginning of july and the responses were quite fast.
00:28:26 * Lemmih starts ripping out GHC's parser.
01:44:35 <musasabi> Does anyone know a place to find Osker ?
01:45:23 <Lemmih> Osker?
01:45:41 <musasabi> The microkernel in Haskell in development.
01:45:59 <musasabi> google only finds papers and some commits related to it.
01:51:00 <lispy> @hoogle from
01:51:01 <lambdabot> Maybe.fromMaybe :: (a -> (Maybe a) -> a)
01:51:01 <lambdabot> Maybe.fromJust :: ((Maybe a) -> a)
01:51:01 <lambdabot> Prelude.fromEnum :: Enum a => (a -> Int)
01:51:15 <lispy> @hoogle fromF
01:52:22 <lispy> @type floor
01:52:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:54:40 <lispy> @eval let floatMod x m = (fromIntegral ((floor x) `mod` m)) + (x - (fromIntegral (floor x))) in floatMod 3.14 10
01:54:45 <lambdabot> 3.14
01:54:59 <lispy> @eval let floatMod x m = (fromIntegral ((floor x) `mod` m)) + (x - (fromIntegral (floor x))) in floatMod 3.14 2
01:55:02 <lambdabot> 1.1400000000000001
01:56:47 <pejo> musabi, I bumped by House on Hallgrens homepage a while ago, it isn't stashed there somewhere?
01:56:59 <pejo> Bah. Can't type. musasabi I meant, sorry.
01:57:52 <Lemmih> Wow. GHC is _extreme_ slow at compiling big structures.
02:00:19 <musasabi> dcoutts_: Is the C parser you created for c2hs available as an separate package?
02:46:17 <lispy> heh, i just realized that i coded until i fell asleep :)
02:46:31 * lispy turns off the lights and goes to bed for real
02:46:41 <lispy> on the plus side, I finished lesson10
02:46:48 <lispy> now i'm a big boy!
04:01:36 <basvandijk> Is anybody here?
04:03:21 <jlouis> yup
04:03:27 <basvandijk> I have a little question:
04:03:27 <basvandijk> Is there a standard function like 'map' that applies a function to each element in a list but also accepts an index of that element?
04:03:48 <metaperl> basvandijk: like how? and why?
04:04:03 <basvandijk> something like:
04:04:04 <basvandijk> mapWithIndex :: (a -> Int -> b) -> [a] -> [b]
04:04:36 <basvandijk> where the Int is the index of the element in the list
04:04:56 <metaperl> oh you mean start the processing with that element
04:05:26 <metaperl> mapWithIndex f [1,2,3]
04:05:38 <metaperl> wait, you didn't supply an index to the function
04:05:45 <basvandijk> no, I mean that the function you give to 'mapWithIndex' can also use the index of the element
04:05:48 <metaperl> mapWithIndex f  2 [1,2,3] --- yields what?
04:05:54 <metaperl> oh!
04:05:59 <metaperl> then use a list comprehension
04:06:37 <metaperl> [ operateOn xs!!ix | ix <- [1 .. length xs ]
04:06:50 <metaperl> is has the index
04:06:59 <metaperl> xs!!ix gets the ixth element
04:07:12 <metaperl> oh, off-by-1 error
04:07:27 <metaperl> [ operateOn xs!!ix | ix <- [0 .. (length xs)-1 ]
04:07:38 <metaperl> I'm glad all the haskell gods aren't on or they would've answered by now :)
04:07:45 <basvandijk> :-)
04:07:59 <shapr> @yow !
04:07:59 <lambdabot> HOORAY, Ronald!!  Now YOU can marry LINDA RONSTADT too!!
04:08:45 <metaperl> so anyway, mapWithIndex f xs = [ f ix xs!!ix | ix <- 0 .. (length xs)-1 ]
04:08:48 <metaperl> there you go
04:09:12 <metaperl> basvandijk: ping?
04:09:40 <basvandijk> Yes, I'm reading you're function but it isn't excatly what I want
04:09:49 <shapr> Good morning #haskell!
04:10:06 <metaperl> the function f gets the index of the current element as well as the element... that is what you said you wanted... no?
04:10:42 <basvandijk> Oh you're right! I think this is what I need
04:10:56 <basvandijk> is there also a standard function for this in the prelude?
04:12:47 <metaperl> i don't know...
04:12:49 <arjanb> mapWithIndex f xs = zipWith f xs [0..]
04:13:01 <metaperl> ziipWiith?
04:13:18 <metaperl> oh sweet
04:13:44 <metaperl> instead off the zzip operation beinng (a,b) , it  is whatever f does with x and  ix
04:13:45 <paolo> basvandijk: what are you trying to do exactly?  Usually it's so good to have to reference the members of a list by index.
04:14:00 <metaperl> paolo: I think you mean not  good :)
04:14:05 <metaperl> not *so* goood
04:14:08 <paolo> Indeed O_o
04:14:17 <metaperl> whats the issue with my keybd this morning?
04:14:59 <metaperl> yes, basvandijk what is your ultimate goal?
04:15:29 <basvandijk> Well, I have a list of lists and I want to check that each of the lists in the list has length 1+r2 where r is the index in the list
04:15:57 <paolo> Cool
04:16:05 <musasabi> basvandijk: I think you want zipWith.
04:16:09 <musasabi> @type zipWith
04:16:19 <musasabi> no lambdabot today.
04:16:25 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
04:16:50 <musasabi> basvandijk: zipWith (\val idx -> something) [0..] mylist
04:17:25 <basvandijk> Mmm ok... I had something like this in mind:
04:17:25 <basvandijk> and o mapWithIndex (\i,x -> length x == 1+i*2)
04:17:38 <basvandijk> wait the o must be .
04:17:50 <musasabi> @eval zipWith (\v i -> (v,i) [0..] [3,7,..,20]
04:17:58 <musasabi> @eval zipWith (\v i -> (v,i)) [0..] [3,7,..,20]
04:18:07 <lambdabot> 52: parse error on input `..'
04:18:07 <lambdabot> 53: parse error on input `..'
04:18:28 <musasabi> @eval zipWith (\v i -> (v,i)) [0..] [3,7 .. 20]
04:18:34 <lambdabot> [(0,3),(1,7),(2,11),(3,15),(4,19)]
04:18:38 * musasabi is slow in mornings.
04:18:39 <metaperl> basvandijk: no comma between the args to your anonymous function
04:18:59 <paolo> zipWith (\i l -> length l == 1+i*2) [0..]
04:19:08 <basvandijk> you're right, I'm still a newby
04:19:25 <paolo> @plugs let f = zipWith (\i l -> length l == 1+i*2) [0..] in f [[1,2,3],[4,5,6],[7,8,9,10]]
04:19:28 <lambdabot> [False,True,False]
04:19:56 <metaperl> basvandijk: why are you writing this code?
04:19:57 * shapr is slow in mornings too.
04:20:49 <basvandijk> paolo: thanks thats what I want
04:21:15 <basvandijk>  metaperl: I'm just hacking a bit :-)
04:23:45 <jlouis> it seems a rather odd thing to want. The lenght of lists of lists
04:25:30 <bourbaki> hi
04:26:28 <shapr> y0
04:29:32 <Lemmih> Ack. Compiling GHC's parser and lexer is hard for my little laptop /-:
04:29:44 <wilx> Hard?
04:30:28 <musasabi> ghc-6.5 has seen some performance improvements with some pathological cases...
04:30:44 <Lemmih> GHC can be a bit slow when compiling a 17kloc Haskell file.
04:31:21 <musasabi> Then again when I see ghc hitting swap when compiling such a file I don't feel as bad when playing with jhc (which can do the same with hello world)
04:31:32 <wilx> Hehe.
04:34:41 <shapr> What's a good way to deal with ssh username/password scanning?
04:37:41 <goron> shapr: What is username/password scanning?
04:41:03 <shapr> goron: Some IP in china tries to brute force ssh into my server every friday.
04:41:27 <goron> shapr: ok, and you want to block that?
04:41:33 <shapr> Right
04:41:34 <goron> shapr: IP tables?
04:41:54 <goron> There are lots of scripts that lock people out after >x tries.
04:42:13 <goron> You can also say that you want to deny people from some continents/countries.
04:42:33 <goron> Well, that's basically a "solved" problem.
04:42:42 <goron> shapr: Does that help?
04:43:24 <shapr> Yes, I'm googling for scripts now, thanks.
04:43:33 <goron> np, I had the same problem.
04:43:44 <goron> shapr: My solution was to run ssh on a different port.
04:44:09 <goron> shapr: Bruteforcing happens on standard ports with dictionary attacks.
04:44:16 * musasabi runs ssh on different port and use whitelisting instead of blacklisting.
04:44:23 <shapr> goron: Ah, good idea.
04:44:32 <goron> I have never seen a real bruteforce attempt.
04:44:42 <goron> I.e. start at lowest bitvalue and increase.
04:44:59 <shapr> With the downside that I'll have to tell all the scannedinavian users about the port change.
04:45:01 <goron> If you want to be really secure, don't use passwords.
04:45:13 <shapr> Good point, ssh-agent only.
04:46:08 <goron> I played with ssh-agent when I was a complete n00b. I didn't get it. Now, I do understand it, I think, but I don't have the need to use it. It's pretty useful, I guess.
04:46:19 <jlouis> check out $HOME/.ssh/config. Especially the Port designation ;)
04:46:29 <jlouis> (man 5 ssh_config)
04:46:42 <shapr> I really love ssh-agent, it makes my life so much simpler.
04:46:49 <jlouis> indeed
04:46:54 <jlouis> ssh-agent is rather nice
04:47:14 <jlouis> At mongers.org we have an enforced no-password policy. Everything is done with keys
04:47:38 <shapr> I have logins on a bunch of servers around the world where I need to do sysadmin work. It saves me trouble to use my public ssh key and not have to type my password to ssh or scp.
04:48:02 <jlouis> yeah, and ssh foo.bar <command> makes it even simpler
04:48:15 <jlouis> if you do much of that stuff, then check out session-multiplexing
04:48:53 <shapr> I do wish ssh had a built-in command for stacking connections. Some of my clients want me to only login from a single IP, and I redirect that through my server. My home connection is on a dynamic IP.
04:49:16 <shapr> hiya Bukowski
04:49:53 <Bukowski> hi
04:50:30 <shapr> jlouis: What's up with session-multiplexing? Is that ssh -M ?
04:50:40 <shapr> Bukowski: Learning Haskell?
04:50:54 <goron> shapr: I tend to do more with ssh these days, maybe I should install it too.
04:51:30 <pejo> shapr, might http://www.lysator.liu.se/fsh/ be what you're looking for?
04:51:57 <pejo> Heh, session multiplexing sounds like a better idea.
04:51:58 <shapr> pejo: ssh -M in OpenSSH 4.0 is better than fsh, for some value of 'better'.
04:52:50 <shapr> darcs get via ssh is faster with -M, then you only set up one connection for all the patch copying.
04:53:55 <jlouis> it just multiplexes more sessions in the same tunnel. Thus it can skip the connection setup and key challenge-response
04:54:02 <shapr> Ah, cool
05:36:13 <jlouis> is Control.Monad.State in a special package?
05:36:22 <musasabi> jlouis: mtl.
05:36:25 <jlouis> thanks
05:51:15 <Lemmih> GHC's parser is pretty tightly integrated in GHC. *sigh*
06:10:02 <paolo> Do you know what are first-order and second-order axioms?
06:10:16 <paolo> (referred to first-order and second-order Peano arithmetics)
06:11:55 <shapr> http://en.wikipedia.org/wiki/Peano_axioms
06:13:06 <paolo> Uhm, "second-order arithmetics" isn't written yet :|
06:14:23 <paolo> Second-order is like using metalinguistic variable in logic?
06:16:37 <paolo> Did you see http://lambda-the-ultimate.org/node/view/910 ?
06:18:05 <paolo> I wonder what are invariants :)
06:19:17 <shapr> Look at the replies in that LtU post.
06:19:37 <shapr> Time to read about the Barendregt Cube, Calculus of Constructions, Curry Howard correspondence, etc
06:19:43 <shapr> It's good stuff :-)
06:20:31 <paolo> I suppose.  Thanks :)
07:20:25 <jlouis> guys, the topic-cons command currently is <at>topic-cons #channel message. I am thinking of letting it pick up #channel by itself if not given, but it seems a bit dangerous
07:21:05 <musasabi> jlouis: personally I think the whole @topic interface could look at redesign.
07:21:05 <jlouis> You will have to parse the change string and value if the string begins with a channel
07:21:35 <jlouis> musasabi: ok. Do you have any ideas in particular? I am looking at it now anyway
07:22:04 <musasabi> jlouis: having names that don't require programming skills to understand would help.
07:22:07 <jlouis> (anybody else?)
07:22:24 <jlouis> noted.
07:22:41 <musasabi> also a "@topic-regex [channel] /foo/bar/" could be nice.
07:24:30 <paolo> Hmm, should it be map topic-regex?
07:25:18 <TheHunter> maybe topic should use a zipper.
07:25:25 <paolo> What is a zipper?
07:25:35 <TheHunter> @wiki TheZipper
07:25:36 <lambdabot> http://www.haskell.org/hawiki/TheZipper
07:25:41 * autrijus purrs.
07:25:51 <musasabi> Isn't zipper quite complicated for the purpose?
07:26:35 <TheHunter> zippers aren't complicated.
07:26:35 <autrijus> hm. is it possible to DrIFT a zipper for arbitraty data type?
07:26:45 <autrijus> (I'm working on DrIFT'ing YAML)
07:26:47 <musasabi> Any idea when there will be haskelldb packages in Debian supporting GHC-6.4 ?
07:28:39 <TheHunter> the interface would be like @topic-left, @topic-right, @topic-delete, @topic-insert, @topic-replace.
07:29:53 <jlouis> Should it be possible to work on topics of other channels at all?
07:30:07 <jlouis> Or should we just assume we always work on the current channels topic?
07:30:16 <jlouis> I would like the latter actually
07:30:26 <paolo> TheHunter: @topic-insert :: ?
07:30:38 <musasabi> jlouis: having channel as an optional parameter would be nicest.
07:30:39 <jlouis> paolo: insert a topic here
07:30:54 <jlouis> musasabi: ok
07:31:47 <TheHunter> topic-insert "foo" (Zip ["x","y"] "z" ["a","b"]) = Zip ["x","y","z"] "foo" ["a","b"]
07:32:21 <musasabi> btw would it make sense to use a substring of the topic in @topic-delete ?
07:32:27 <paolo> So you have to stack left and rights to insert in the internal "branches" ?
07:32:50 <jlouis> paolo: you will see that a lambdabot topic is a list. A Zipper structure allows us to move around in the structure at whim. @topic-left/right moves to the left and right. @topic-delete deletes what is at the current spot and @topic-insert inserts and ...
07:33:03 <musasabi> Normally when using bots to manage topics I do "off by one" errors calculating the correct index.
07:33:10 <paolo> jlouis: what is the current spot?
07:33:21 <jlouis> paolo: we have to report this to the user
07:33:29 <jlouis> we keep track of it as internal state
07:33:43 <paolo> It makes sense.  Cool!
07:34:16 <paolo> It could be a Reader Monad, right?
07:34:37 <paolo> s/be a/make use of the/
07:34:50 <jlouis> nah, a zipper will do
07:35:01 <paolo> Lost
07:35:02 <jlouis> We already have state tracking in lambdabot due to TheHunter ;)
07:37:18 <paolo> Suppose it isn't for lambdabot, would the RM work?
07:40:39 <TheHunter> you can thread the zipper state with a reader or a state monad, but I think the state makes more sense.
07:41:21 <jlouis> I would guess the state would makes more sense too.
07:41:37 <jlouis> would make
07:53:04 <paolo> *Mangle> runReader left env
07:53:04 <paolo> "foo"
07:53:11 <paolo> Cool!  I think I understand now
07:55:42 <jlouis> reader just hides an environment until you need it, so to speak
07:55:50 <jlouis> or until you alter it hehe
07:57:14 <paolo> @index !!
07:57:15 <lambdabot> Data.List, Prelude
07:57:23 <paolo> @type (Data.List.!!)
07:57:31 <lambdabot> forall a. [a] -> Int -> a
07:58:33 <jlouis> paolo: !! is almost _never_ needed
07:58:46 <paolo> Let me play :(
07:58:49 <jlouis> hehe
08:00:33 <jlouis> the imperative analogy would be that !! is for(i=0; i < foo(); i++) { .. bleh[i] .. } whereas in haskell you would foreach i in (bleh).
08:00:45 <jlouis> hope it makes any sense
08:01:00 <Oejet> Not to me. :-P
08:01:29 <jlouis> Oejet: perfect!
08:06:08 <paolo> Uhm
08:06:22 <paolo> local stateManglingFunction XXX
08:06:28 <paolo> What the heck should XXX be?
08:10:48 <jlouis> the monad
08:11:18 <jlouis> @type local
08:11:20 <lambdabot> bzzt
08:11:30 <paolo> jlouis: "ask" ?
08:11:31 <jlouis> @type Control.Monad.Reader.local
08:11:33 <lambdabot> forall r (m :: * -> *) a.
08:11:33 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
08:11:33 <lambdabot> (r -> r) -> m a -> m a
08:12:58 <jlouis> look at that type declaration: r and m abides control monad reader. stateManglingFunction is of type (r -> r) and XXX has type m a. so local stateManglingFunction XXX runs XXX with an altered environment as specified by stateManglingFunction
08:12:59 <paolo> autrijus: nice subliminal message
08:13:07 <autrijus> verily. I tried "perl6 is here today"
08:13:18 <autrijus> and then "autrijus"
08:13:23 <autrijus> but freenode blocked the middle two.
08:13:27 <autrijus> for whatever reason.
08:13:45 <paolo> "perl6 is autrijus" cool enough
08:13:45 <jlouis> @type Control.Monad.Reader.ask
08:13:46 <autrijus> ahh. 23:13 [freenode] !brown.freenode.net *** Notice -- Too many nick changes; wait 3 seconds before trying again
08:13:47 <lambdabot> forall r (m :: * -> *).
08:13:47 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
08:13:47 <lambdabot> m r
08:14:00 <paolo> jlouis: I understand ask
08:14:07 <jlouis> ok
08:14:08 <paolo> jlouis: "abides" ? :-)
08:14:15 <jlouis> fulfills
08:14:23 <jlouis> ``is in type class''
08:14:30 <Lemmih> musasabi: (re GHC parser) Would it make sense to use standard libraries for pretty-printing and I/O instead of GHC's heavily optimized versions?
08:15:50 <paolo> jlouis: I was thinking data Environment = ..; stateManglingFunction :: Environment -> Environment; and then neither "ask >>= local stateManglingFunction" nor "local stateManglingfunction ask" seem to be the right thing.
08:16:11 <paolo> UHM!
08:16:15 * paolo blings
08:16:41 <paolo> it runs XXX! which should have type Reader Environment a.
08:17:04 <basti_> hi
08:17:27 <jlouis> paolo: almost correct, but you get the idea
08:17:42 <Lemmih> Hey basti_.
08:18:42 <paolo> Gah, let me try.
08:25:09 * paolo grumbles
08:26:21 <paolo> I need trace :-P
08:26:41 * paolo screams :-)
08:26:50 <musasabi> Lemmih: I think the prettyprinter is quite possible to rip out - then again writing a custom one with HughesPJ might be easier.
08:27:01 <musasabi> Using normal IO in any case maces sense.
08:28:23 <paolo> jlouis: what should be the type of left and right?
08:34:06 <paolo> http://haskell.galois.com/~paolo/Mangle.hs
08:34:12 <paolo> I'm missing something...
08:34:20 <paolo> Do I need ReaderT to do what I want in main ?
08:35:58 <TheHunter> which is better?
08:36:02 <TheHunter> @listcommands
08:36:02 <lambdabot_> babel provides: babel remember quote timein ghc
08:36:02 <lambdabot_> base provides:
08:36:02 <lambdabot_> code provides: code
08:36:02 <lambdabot_> darcsPatchWatch provides: repos repo-add repo-del
08:36:02 <lambdabot_> dice provides: dice
08:36:03 <lambdabot> all-dicts arr babel botsnack code define definitions devils dice
08:36:03 <lambdabot> dict dict-help docs dummy easton echo elements elite eurohaskell
08:36:03 <lambdabot> eval fact fact-cons fact-delete fact-set fact-snoc fact-update
08:36:03 <lambdabot> foldoc fortune gazetteer get-definition ghc google help hitchcock
08:36:03 <lambdabot> hoogle hoogle+ index jargon karma karma+ karma- kind lambda learn
08:36:04 <lambdabot_> dict provides: dict dict-help all-dicts devils easton elements
08:36:05 <lambdabot> libsrc listchans listcommands listmodules lojban moo more paste pl
08:36:06 <lambdabot_> foldoc gazetteer hitchcock jargon lojban prelude vera web1913 wn
08:36:07 <lambdabot> pl-resume plugs pointless prelude quote remember repo-add repo-del
08:36:09 <lambdabot> [4 @more lines]
08:36:20 <paolo> hah
08:36:42 <basti_> paolo: I don't see what you're trying to do
08:36:57 <Igloo> TheHunter: Both are a bit verbose for the channel, I think
08:37:06 <Igloo> Perhaps with no arguments it should just list the modules?
08:37:16 <TheHunter> we already have @listmodules
08:37:18 <paolo> basti_: main is the point, I want to move through the Env and print the current position with curr
08:37:21 <lambdabot_> world02
08:37:21 <lambdabot_> dummy provides: moo dummy eurohaskell wiki paste docs libsrc learn
08:37:21 <lambdabot_> botsnack
08:37:21 <lambdabot_> dynamic provides:
08:37:21 <lambdabot_> elite provides: elite
08:37:39 <Igloo> Then perhaps listcommands should do nothing without a parameter? Or should only work by msg?
08:37:39 <basti_> paolo: why would you use Reader for that?
08:37:48 <paolo> basti_: it was a try
08:38:06 <basti_> paolo: thought about the state monad?
08:38:08 <paolo> Are you implying it is not possible, or what else?
08:38:23 <basti_> i'm not saying its impossible
08:38:30 <basti_> inconvinient would be better.
08:38:45 <paolo> Hmm
08:38:55 <basti_> Reader is for... things that are read only, i think
08:39:20 <paolo> Doesn't nomaware's example mutate the state?
08:39:26 <basti_> yes you *can* do that
08:39:45 <paolo> OK, so I can't have a main like that under the Reader Monad ?
08:40:07 <TheHunter> ok, i think i'll make @listcommands an alias for @listmodules.
08:40:30 <basti_> its not a question of main. The question is, would anything useful result in it.
08:40:45 <basti_> The next question would be, why would you want to see a value hidden in a Reader?
08:41:09 <paolo> I'm trying to understand why it is inconvenient
08:41:34 <paolo> I can't understand the Reader Monad it seems, how can I say "State is surely better", except because you (all) say so?  :(
08:41:40 <basti_> its inconvinent for this purpose because it's not supposed to contain any muteable staty by metaphor
08:41:44 <paolo> And because the Name sounds better?
08:41:45 <basti_> state
08:42:00 <basti_> no because reader is intended for environments that are read from.
08:42:13 <basti_> as opposed to, written to.
08:42:19 <paolo> Sob.
08:42:29 <basti_> i'm sure you can do that in some way.
08:42:40 <basti_> you just don't want to .)
08:42:50 <paolo> I can't see way, because it seems that you can mangle the "state"
08:42:56 <paolo> err, why not way
08:43:59 <basti_> its not that you can't. It's more a "this would distort the meaning of 'reader'"
08:44:13 <paolo> Sob, hscairo uses the reader monad.
08:44:22 <paolo> I _need_ to understand this.
08:45:57 <paolo> ./Graphics/Rendering/Cairo/Render.hs:80:with r a = local (\_ -> r) a
08:46:05 <basti_> i'm trying to write an example
08:46:14 <paolo> Thank you _very_ much.
08:46:59 <jlouis> paolo: with r a runs a with environment r, ignoring what environment the Reader had up to this point
08:47:33 <jlouis> (runs locally with environment r, regardless earlier state _)
08:47:42 <paolo> ah!
08:47:55 <paolo> Which is been kept, right=
08:48:02 <TheHunter> lambdabot_, @listcommands
08:49:21 <TheHunter> hmm, this is another bug i need to track down.
08:49:34 <jlouis> TheHunter: do tell
08:50:08 <TheHunter> lambdabot on my machine sometimes refuses to write any output for a long time.
08:50:35 <TheHunter> lambdabot_, @listcommands
08:50:35 <lambdabot_> use listcommands [module|command], please.
08:50:35 <lambdabot_> #haskell
08:51:13 <Lemmih> Hey basti_.
08:51:19 <Lemmih> Ops, sorry.
08:51:20 <jlouis> I think that having a zipper point in the topic would be cool. Like [@"foo", "bar", "baz"] and thes @topic-right 2 would change topic to ["foo", "bar", @"baz"]
08:51:57 <TheHunter> exactly.
08:51:59 <jlouis> What do you guys think?
08:52:00 <TheHunter> lambdabot_, @listcommands
08:52:00 <lambdabot_> use listcommands [module|command], please. Modules are:
08:52:00 <lambdabot_> babel base code darcsPatchWatch dice dict dummy dynamic elite fact
08:52:01 <lambdabot_> haddock help hoogle karma lambda more pl plugs quote search seen
08:52:03 <lambdabot_> spell state system todo topic type version vixen where
08:52:30 <TheHunter> man, we got a lot of modules.
08:52:49 <Mou> I have a question about the ST monad,
08:53:03 <paolo> Please tell
08:53:05 <Mou> i'm trying to write mutable linked lists inside of it
08:53:15 <Mou> but it occurred to me that the way my code ran
08:53:24 <Mou> these would be strict in construction
08:53:32 <Mou> unlike haskell's normal lazy lists
08:53:42 <Mou> so that if i fed in an infinite list
08:53:45 <Mou> it would diverge
08:54:15 <TheHunter> Mou, don't be impatient, it sometimes takes people here a while to see and answer a question.
08:55:13 <Mou> sorry i don't understand what you mean
08:55:32 <musasabi> Maybe Control.Monad.ST.Lazy can help you?
08:55:44 <TheHunter> you asked the same question yesterday and left right before somebody was about to answer.
08:55:57 <musasabi> Circular lists are trivial inside IO/ST - but I don't know about infinite ones.
08:56:15 <musasabi> you could certainly do it with unsafeInterleaveIO inside IO.
08:56:20 <Mou> i'm not in the US-UK so i assumed everyone was asleep
08:56:57 <Oejet> Mou: I would guess most people here are Europeans.
08:57:36 <Mou> right
08:58:22 <Mou> the "ST" in STRefs appear to be the strict and you have to call strictToLazyST on them
08:58:43 <Mou> to get the Control.Monad.ST.Lazy ones
08:59:10 <Oejet> Mou: Ah, are you from the East?
08:59:38 <Mou> Australia
09:00:08 <Mou> I started learning haskell end of last year and can't stand anything else now
09:00:17 <TheHunter> oh, there are some people from australia here.
09:00:50 <Mou> they might be asleep by now :)
09:00:58 <TheHunter> @timein Sydney
09:01:00 <lambdabot>  Sunday, August 14, 2005 at 2:02:03 AM EST
09:02:08 <Mou> i learned about the st monad a couple of weeks ago so i'm trying to
09:02:13 <TheHunter> i'm not sure if Control.Monad.ST.Lazy helps. I've never spotted a difference between Lazy and Strict ST, but i've never tried very hard.
09:02:24 <Mou> get my head around it by implementing some imperative data structures in it
09:02:46 <Mou> i tried wrapping the (strict) STRef calls in strictToLazyST but
09:02:46 <Oejet> Mou: So did you have Chakravarty as a teacher?
09:02:51 <TheHunter> that's the problem - imperative data structures are usually strict.
09:03:03 <Mou> no i didn't
09:03:07 <Mou> i'm in melbourne
09:03:27 <Mou> sure, but i was hoping i could get the ST lists to construct on demand
09:03:34 <Mou> lazy-style
09:04:13 <Oejet> Mou: Did you look at http://www.haskell.org/hawiki/ImperativeHaskell?  Maybe you could add your findings there.
09:04:28 <TheHunter> you probably have to do that explicitely, unless you want to invent your own unsafe ST-primitives.
09:05:01 <Mou> i'm still a relative newb in haskell
09:05:49 <Mou> the way i imagined, the lazy ST would allow it
09:06:13 <Mou> since _|_ >> something isn't necessarily _|_
09:06:13 <musasabi> Mou: have you tries using the lazy ST module?
09:06:20 <TheHunter> data STList' s a = Nil | Cons a (STList s a); data STList s a = Ref (STRef s a) | Closure (ST s (STRef s a))
09:06:26 <Mou> i tried but i'm not sure if i did it properly
09:06:27 <TheHunter> as you can see, it ain't pretty.
09:07:01 <Mou> i did it as
09:07:01 <Mou> data STList s a = STList (STRef s (Maybe (a, STList s a) ) )
09:07:12 <Mou> so the STList is in the strict ST
09:07:22 <Mou> but in the constructor
09:07:27 <TheHunter> musasabi, do you think Lazy ST would help?
09:07:47 <Mou> sorry it's in the lazy
09:08:04 <Mou> mk [] = strictToLazyST (newSTRef Nothing >>= \r -> return (STList r))
09:08:34 <Mou> the recursive case is a bit messy
09:08:41 <Mou> mk (x:xs) = do
09:08:46 <Mou> 	nextOne <- mk xs
09:08:55 <Mou> r <- strictToLazyST (newSTRef (Just (x, nextOne)))
09:09:02 <TheHunter> @index newSTRef
09:09:02 <Mou> return (STList r)
09:09:03 <lambdabot> Data.STRef.Lazy, Data.STRef, Data.STRef.Strict
09:09:14 <TheHunter> you prolly wanna import Data.STRef.Lazy.
09:09:23 <Mou> yeah i did that
09:09:44 <Mou> on the other hand maybe my stlist -> list function is messed up
09:09:54 <musasabi> TheHunter: It may help - I don't have enough experience with it. I would go the unsafeInterleaveIO route.
09:10:11 <basti_> lisppaste2: @url
09:10:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:10:25 <Mou> that unsafe and IO gives me the shivers ;)
09:10:27 <basti_> paolo: still there?
09:10:30 <paolo> basti_: sure!
09:10:38 <lisppaste2> basti_ pasted "minimal reader example" at http://paste.lisp.org/display/10764
09:10:54 <basti_> this is what i think is the only "valid" (intended) use of Reader.
09:11:12 <paolo> This is my curr
09:11:34 <basti_> oh didnt see that. had to dig a few manuals
09:11:35 <basti_> .)
09:11:41 <paolo> Thank you :-)
09:11:42 <TheHunter> musasabi, i don't think it helps. In unsafeInterleaveIO-like semantics would be too obscure not to include 'unsafe' in one of the function names.
09:11:51 <basti_> Reader is not thought to change its environment ever
09:12:54 <basti_> what you can do with reader, would be things like difficult overloading rules
09:13:37 <basti_> as in your reader reads from an [Namespaces], and namespaces at the beginning of the list override those further behind
09:14:53 <paolo> basti_: I didn't understand your last sentence sorry
09:15:00 <metaperl> i want to create an infinite list of alternating [0,1]
09:15:28 <TheHunter> @eval cycle [0,1\
09:15:30 <TheHunter> @eval cycle [0,1]
09:15:37 <lambdabot> 28: parse error on input `\'
09:15:41 <lambdabot> [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:41 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:41 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:41 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:41 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:43 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:45 <lambdabot> 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
09:15:45 <metaperl> lol
09:15:46 <basti_> paolo: you can implement different behaviours of environements... similar to the way "namespaces" in C etc. behave
09:15:47 <lambdabot> [24 @more lines]
09:15:47 <paolo> I was about to unflodr :-)
09:15:50 <metaperl> ok thanks
09:16:14 <paolo> basti_: namespaces in C? uhm.
09:16:22 <basti_> c++
09:16:38 <paolo> Ah
09:16:54 <paolo> Like "right" should start a new "scope" ?
09:16:55 <basti_> I'm not making differences there .)
09:17:02 <basti_> :-o
09:17:14 <basti_> no like, you give an environment to runReader
09:17:32 <basti_> and you have some functions like "lookupVarAccordingToCNamespaceRules"
09:18:06 <paolo> I see what I am missing.
09:18:11 <paolo> Reader's state is immutable
09:18:12 <basti_> what?
09:18:17 <basti_> uhm, everything is immutable.
09:18:20 <basti_> ;)
09:18:27 <paolo> local runs a computation in a _locally_ modified "state"
09:18:37 <Mou> i did a check with (lazy) runST (mk [1,2..] >> return 3) and it didn't diverge
09:18:48 <paolo> in hscairo it works like the "state" is the cairo context which is mangled by C functions
09:18:49 <Mou> so it must be my stlist -> list code that's strict
09:18:53 <basti_> @plugs take 10 $ unfoldr (\x->Just (x,1-x)) 1
09:18:55 <lambdabot> [1,0,1,0,1,0,1,0,1,0]
09:18:56 <basti_> paolo: yes.
09:19:24 <paolo> But I miss how IO and Reader collaborates, if there is {"external","C","IO"}mangling
09:19:35 <basti_> paolo: probably not at all.
09:19:52 <basti_> that is, the Reader contexts can work independently of the IO contexts
09:20:03 <wilx> Mou, when did you start doing the STList?
09:20:09 <TheHunter> @eval take 10 $ repeat () >> [0,1]
09:20:11 <paolo> basti_: I think it uses ReaderT
09:20:11 <lambdabot> [0,1,0,1,0,1,0,1,0,1]
09:20:43 <wilx> Coincidentally I starte doing the same thing the day before yesterday.
09:20:54 <Mou> this morning
09:20:55 <basti_> uhm
09:21:08 <Mou> um i had been thinking about it
09:21:17 <Mou> so i just typed it up earlier today
09:21:20 <Mou> and tested
09:21:26 <Mou> it diverged
09:21:31 <Mou> so i tried to make it lazy
09:21:34 <basti_> hmmm
09:21:42 <basti_> phone
09:21:49 <wilx> Yeah, I tried that too after you mentioned it and mine diverges too :/
09:22:02 <Mou> i wrote an ST hashtable so i figured i'd try a list and maybe priority queue in ST
09:22:13 <Mou> i think i have the constructor working lazily
09:22:22 <wilx> Nice.
09:22:48 <Mou> but i'm not sure about the next bit :)
09:24:49 <paolo> basti_: ah-ha!
09:24:58 <basti_> :P
09:25:01 <paolo> The "state" in hscairo is a pointer.  It never changes.
09:25:52 <paolo> It's using ReaderT because Reader only lets pure computations using the state, ReaderT lets do impur eIO actions with the value of the state.
09:25:58 <Mou> hmm i'm not sure that i have the ctor lazy actually, as soon as the readSTRef is called,
09:26:09 <Mou> it diverges, i think
09:27:09 <Mou> maybe it's because the STRef ctor is strict
09:27:30 <Mou> anyone know if there's an STRef in the lazy ST?
09:30:34 <basti_> paolo: yes i think this interpretation is looking good
09:30:50 * paolo finally bonces happily
09:31:07 <basti_> paolo: concerning IO values, i find it helpful to think of them as "scripts" that are built, and then run at run-time, usually at "bottom level"
09:31:10 <paolo> The hscairo author is a _nice_ guy.
09:31:43 <basti_> (the whole program is of some IO x type, and this forces IO to happen in order)
09:32:22 <SamB> or even programs
09:32:37 <paolo> I'll let you abstract :-P
09:34:14 * basti_ abstracts into hyperspace
09:34:26 * paolo throws basti_ gamma goblins
09:35:39 <TheHunter> Mou, Data.STRef.Lazy.STRef ? try it, but i don't think it'll help.
09:37:14 <Mou> damn i can't believe i missed it so completely
09:38:19 <basti_> i guess there is a nice connection between the ackermann function and unfold.
09:38:32 <basti_> maybe.
09:39:33 <Mou> nah i changed the STRef to lazy but it still diverges on a read
09:40:06 <Mou> where would a sensible place to ask this question be?
09:40:19 <musasabi> Mou: haskell-cafe perhaps.
09:40:37 <Mou> ok then
09:41:26 <TheHunter> hmm, here's a difference:
09:41:30 <TheHunter> strict> runST (undefined >> return ())
09:41:30 <TheHunter> *** Exception: Prelude.undefined
09:41:39 <TheHunter> lazy> runST (undefined >> return ())
09:41:39 <TheHunter> ()
09:42:49 <TheHunter> but I think the lazy one still ensures that all ST actions are performed in the right order.
09:43:32 <Mou> so if instead of undefined
09:43:41 <Mou> we had something that diverges, it would diverge
09:44:44 <TheHunter> yes, probably with both strict and lazy. A diverging ST computation is different from undefined.
09:45:34 <Mou> though haskell usually evaluates by need...
09:45:41 <Mou> it's subtle...
09:46:39 <TheHunter> hmm, runST (do {ref <- newSTRef 0; let { loop = modifySTRef ref (+1) >> loop } ; loop; return ()}) ==> ()
09:47:04 <Mou> hmmmm
09:49:08 <TheHunter> strict:
09:49:10 <TheHunter> newtype ST s a = ST (STRep s a)
09:49:10 <TheHunter> type STRep s a = State# s -> (# State# s, a #)
09:49:18 <TheHunter> lazy:
09:49:25 <TheHunter> newtype ST s a = ST (State s -> (a, State s))
09:49:25 <TheHunter> data State s = S# (State# s)
09:50:55 <TheHunter> the only difference seems to be that the strict tuple is unboxed.
09:51:50 <Mou> that's a little bit past my meagre understanding of the haskell magic
09:53:35 <TheHunter> i think it boils down to: strict works as IO, i.e. performs everything immediately; lazy ignores parts of the computation if it doesn't need the previous state at some point.
09:54:18 <Mou> but if it did need even a bit of it
09:54:25 <Mou> it would evaluate it?
09:55:03 <Mou> so the moment the ST list gets read from it evalutes all its nodes
09:55:12 <TheHunter> it evaluates when it sees that state is needed.
09:55:26 <Mou> even if only the first node is looked at
09:55:36 <TheHunter> anyway, i think when both lazy and strict converge, they lead the same result.
09:55:54 <Mou> since in the node construction, the recursive call is needed to create that node
09:56:33 <Mou> kinda disappointing, it seems
09:56:35 <TheHunter> yes, i believe so.
09:59:07 <TheHunter> this already diverges: runST (do {ref <- newSTRef 0; let { loop = modifySTRef ref (+1) >> loop } ; loop; ref2 <- newSTRef (); readSTRef ref2})
09:59:40 <musasabi> hmm unsafeInterleaveST does exist.
09:59:56 <TheHunter> @index unsafeInterleaveST
09:59:57 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
10:00:49 <musasabi> I think that could do what Mou wants.
10:01:00 <Mou> gosh
10:02:16 <Mou> what exactly does it do?
10:02:30 <Mou> i've used unsafePerformIO but not interleaving
10:02:54 <TheHunter> it defers an st computation until the result is needed.
10:03:21 <TheHunter> i didn't know it existed, really, that's why i said you needed to implement your own unsafe st stuff.
10:04:25 <Mou> so with the example that diverges above...
10:04:36 <TheHunter> it's like unsafeInterleaveST m = return (runST m)
10:05:32 <TheHunter> runST (do {ref <- newSTRef 0; let { loop = unsafeInterleaveST $ modifySTRef ref (+1) >> loop } ; loop; ref2 <- newSTRef (); readSTRef ref2})
10:05:35 <TheHunter> ==> ()
10:05:58 <Mou> oooh i'll see if that works
10:07:10 <Mou> wow it does!
10:07:16 <Mou> thanks so much
10:08:39 <Mou> it would have bugged me to death since haskell is way too cool not to be able to do stuff like that
10:10:00 <TheHunter> well, arguably it's still unsafe.
10:10:05 <Mou> how so?
10:10:17 <TheHunter> lemme see if i can find an example.
10:12:23 <Mou> from what i understand of unsafe stuff, the programmer is supplying a proof obligation
10:13:45 <musasabi> Mou: http://youzen.b2.fi/~musasabi/a.hs
10:14:11 <musasabi> ah you already found that out.
10:15:31 <Mou> yeah, thanks for your help anyways :)
10:16:19 <Mou> since we're using something unsafe, what would we have to avoid doing here?
10:16:20 <TheHunter> let foo f = runST (do ref <- newSTRef 0; val <- unsafeInterleaveST (modifySTRef ref (+1) >> readSTRef ref); val2 <- unsafeInterleaveST (modifySTRef ref (+1) >> readSTRef ref); return (f val val2))
10:16:45 <TheHunter> now foo (\x y -> x - y) ==> -1, but foo (\x y -> y `seq` x - y) ==> 1
10:17:56 <basti_> :-o
10:18:18 <TheHunter> foo (\x y -> negate $ y - x) ==> 1, to avoid seq.
10:18:53 <Mou> so the problem here is that we are interleaving operations that reference the same ST cell?
10:19:07 <musasabi> yes.
10:19:19 <goron> It is diehard hour?
10:19:25 <Mou> so if my code goes:
10:19:33 <Mou> stList :: [a] -> Control.Monad.ST.Lazy.ST s (STList s a)
10:19:37 <Mou> stList [] =  (newSTRef Nothing >>= \r -> return (STList r))
10:19:41 <Mou> stList (x:xs) = do
10:19:45 <Mou> 	nextOne <- unsafeInterleaveST (mk xs)
10:19:48 <Mou> 	r <-  (newSTRef (Just (x, nextOne)))
10:19:52 <Mou> 	return (STList r)
10:20:04 <Mou> sorry
10:20:12 <Mou> 	nextOne <- unsafeInterleaveST (stList xs)
10:20:18 <Mou> should be the 3rd last line
10:20:23 <musasabi> I don't think that is a problem.
10:20:34 <Mou> and we can say that because the unsafe part
10:20:44 <Mou> is constructing rather than modifying?
10:20:55 <Mou> and on a locally scoped variable too?
10:21:00 <musasabi> Mou: the problems come if you read or write a variable in unsafeInterleave.
10:21:17 <musasabi> (that can be read/written somewhere else too.)
10:21:19 <Mou> because then the order of the reads/writes is indeterminate
10:22:02 <Mou> and here there is no side effect in the ST action
10:22:15 <Mou> because it's just returning a newly created STRef
10:22:33 <Mou> so it's ordering doesn't matter relative to anything else...?
10:23:44 <musasabi> I think so.
10:23:46 <TheHunter> yes, i believe stList is reasonably safe.
10:23:56 <Mou> great
10:24:07 <goron> Where's the time everything was safe and pure?
10:24:39 <Mou> i think it's still safe, right? since the unsafeInterleaveST action is pure
10:31:48 <Mou> anyways, thanks for the help and good night
11:11:05 * Lemmih finally got GHC's parser to compile outside of GHC.
11:16:57 <basti_> Lemmih: congratulations
11:17:02 <basti_> i bet a lot of people want that.
11:17:18 <basti_> dons for yi, for example.
11:17:24 <Lemmih> And me for HSP.
11:17:28 <basti_> see
11:17:49 <Lemmih> It currently depends on about 60 other modules, tho.
11:17:51 * musasabi gets ready to integrate that in joinhs too.
11:18:00 <basti_> wow
11:18:11 <musasabi> Hmm what mostly?
11:18:52 <Lemmih> musasabi: It spans from typechecking to profiling (:
11:20:33 <Lemmih> (it depends on 72 modules to be exact)
11:26:57 * shapr yarghs
11:29:57 <gaal> hi! reading through the Prelude spec at http://haskell.org/onlinereport/standard-prelude.html i came across this:
11:30:01 <gaal> unzip            =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
11:30:04 <gaal> what's "~" ?
11:32:21 <SamB> hmm...
11:32:22 <shapr> irrefutable pattern match
11:32:51 <SamB> huh, what would happen without it?
11:32:55 <Cale> http://www.haskell.org/tutorial/patterns.html
11:32:58 <Cale> see 4.4
11:34:10 <Cale> matching a value v against ~pat always succeeds
11:34:53 <Cale> it's just that the various parts of pat will be bound to _|_ if the match fails.
11:36:03 <gaal> thanks!
11:53:33 <Oejet> Bronze to Finland!
11:57:02 <Lemmih> In what sport?
11:58:04 <Oejet> Long jump for men.
12:03:43 <musasabi> link?
12:08:42 <Oejet> musasabi: Link?  I just saw it on the television.  You should have been able to hear the roar from the stadium.
12:10:11 <musasabi> Oejet: my gf is watching some SF series from 1970s on the wall... and we don't have a TV ;)
12:11:15 <Oejet> musasabi: Open the window.
12:11:26 <paolo> -eject-
12:11:31 <Oejet> (You lived 50 m from the fence right?)
12:14:06 <musasabi> Oejet: yes, to the athlete village.
12:14:56 <musasabi> hmm some drunken sounding people were shouting something outside.
12:15:03 <Oejet> musasabi: Hehe, but Helsinki is a small city, isn't it?
12:18:00 <sieni> Oejet: if you count surrounding towns as well (as in the difference between L.A.City and L.A.County), then there are about 1 million people here
12:18:14 <Lemmih> Night guys.
12:21:09 <paolo> Goodnight Lemmih!
12:23:07 <Oejet> Godnat, Lemmih.
12:44:49 <lisppaste2> lispy_ pasted "Is there a better way?" at http://paste.lisp.org/display/10774
12:47:26 <TheHunter> i assume putting all of the values in one IORef would be unacceptable - performance wise.
12:47:53 <lispy_> i figured it would be clumsy syntax wise
12:48:00 <Korollary> it would be cleaner
12:48:05 <Korollary> but probably slower
12:48:13 <lispy_> because i'd have to specify a whole new global every time...
12:48:57 <Korollary> we're looking at a C struct defined in haskell heh
12:49:03 <lispy_> the fmap lines are the ones that bug me the most because those are the ones i have to write most often
12:49:17 <lispy_> Korollary: yes, very much so
12:49:33 <TheHunter> |[xr, ...] <- replicateM ?? $ newIORef 0| would be shorter, but not necessarily better.
12:49:41 <lispy_> Korollary: i have several top level functions that need to share state, so this seemed like a good way to do it
12:50:55 <lispy_> TheHunter: that would make mkGlobal shorter?
12:51:19 <TheHunter> yes, because you wouldn't have to repelat |newIORef 0| again and again.
12:51:36 <lispy_> yeah
12:51:40 <lispy_> that could be nice
12:51:46 <shapr> Can I run QuickCheck tests from HUnit somehow?
12:52:02 <paolo> @google QuickCheck
12:52:05 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
12:52:26 <lispy_> TheHunter: although, mkGlobal isn't *that* big of a deal since you write it only once
12:52:52 <paolo> @google HUnit
12:52:54 <lambdabot> http://hunit.sourceforge.net/
12:53:20 <TheHunter> shapr, not without adjusting QuickCheck a bit.
12:53:23 <Korollary> @timein here
12:53:26 <lambdabot>  Sorry, don't know this city
12:53:45 <lispy_> TheHunter: but i think the lines like |ytrans <- fmap (\y -> -y+(-0.25)) (readIORef (walkbias globals))| are confusing
12:53:51 <lightstep> you can work in (Reader Global IO), then you could do |xtrans <- negate `on` xpos|
12:54:19 <TheHunter> lisppaste2, that's because you are using way too many parens.
12:54:31 <TheHunter> er, lispy
12:54:34 <lispy_> lightstep: drawScene has to return IO ()
12:55:03 <lightstep> so use a real global, with NOINLINE and all those hacks
12:55:05 <shapr> Ah too bad
12:55:19 <lispy_> TheHunter: i can't find a single paren in that statement that i can remove, not even the ones around the -0.25
12:55:25 <Korollary> what is NOINLINE ?
12:55:28 <TheHunter> shapr, hold on a sec, i'll put up some MonadQC code I wrote once. Should get you half way there.
12:56:12 <TheHunter> @type \y -> -y - 0.25
12:56:15 <lightstep> Korollary, it's a GHC pragma that tells GHC not to inline a definition.
12:56:20 <lambdabot> forall a. (Fractional a) => a -> a
12:56:49 <lispy_> TheHunter: there  is some weirdness with -0.25 when using GLfloat
12:56:59 <lightstep> ytrans <- (\y -> -y - 0.25) `fmap` readIORef (walkbias globals)
12:57:48 <lispy_> hmm...today it accepts it, but i know i wrote it the long way for a reason
12:57:56 <lightstep> Korollary, see http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#noinline-pragma
12:58:35 <lispy_> i'd much rather just write |ytrans <- -(readIORef (walkbias globals)) - 0.25
12:58:41 <TheHunter> shapr, http://www.haskell.org/hawiki/HaskellIrcPastePage_2fQCExts_2ehs. You can ignore all that Eq' stuff.
12:59:21 <TheHunter> lispy_, you could probably even do that with an appropriate Num instance...
12:59:54 <lightstep> lispy_, it could be cleaner if you had Global = IORef something, since then you could readIORef only once.
12:59:58 <lispy_> TheHunter: oh, hmm...that's an interesting idea
13:00:21 <lispy_> lightstep: yeah, but then how do i update just one part of Global?
13:00:27 <lightstep> Please, don't use reify and reflect!
13:00:47 <lispy_> what are those?
13:01:01 <lightstep> lispy_, |modifyIORef globals $ \g -> g {field = value}|
13:01:39 <TheHunter> lispy_, probably the cleanest solution is along the lisnes of |access accor f = accor `fmap` readIORef (accor globals)|.
13:02:36 <TheHunter> er, |access accor f = f `fmap` readIORef (accor globals)|
13:02:39 <lispy_> the firs accor is realy f rih?
13:02:44 <lispy_> yeah
13:02:48 <lightstep> Hmm, is haskell.org/tmrwiki supposed to not list the august issue, or is it a caching bug?
13:03:18 <lispy_> lightstep: so when  you update a record you don't have to specify all of them?
13:03:44 <lightstep> Sure, that's Haskell 98 syntaxx.
13:03:45 <lispy_> i guess i didn't understand that
13:03:52 <TheHunter> don't use modifyIORef, though.
13:04:04 <lightstep> Atomic?
13:04:11 <lispy_> TheHunter: why not?  I use that in a few places in my code
13:05:10 <TheHunter> it's almost never what you want. |modifyIORef' ref f = do x <- readIORef ref; writeIORef ref $! x| is usually better.
13:05:24 <lispy_> @type ($!)
13:05:25 <lambdabot> forall b a. (a -> b) -> a -> b
13:05:57 <TheHunter> if you wanna access that concurrently, you prolly should use MVars anyway.
13:06:12 <lispy_> afaik i'm single threaded
13:06:18 <lightstep> Why isn't it implemented like that? It won't conflict any standard.
13:06:22 <lispy_> unless GLUT has threads
13:06:40 <lispy_> TheHunter: don't you need to apply f to x?
13:06:48 <lispy_> and what is $! doing?
13:06:57 <TheHunter> sure, writeIORef ref $! f x
13:07:03 <TheHunter> it's forcing the evaluation of f x
13:07:06 <lightstep> lispy_, that's eager apply
13:07:30 <TheHunter> you don't wanna store closures in refs.
13:07:30 <lispy_> what is wrong with lazy apply?
13:07:34 <lispy_> ah
13:07:52 <lispy_> IORefs have a lot of gotchas ;)
13:08:28 <lispy_> @type modifyIORef
13:08:29 <lambdabot> bzzt
13:08:35 <paolo> shapr: do you have example of HUnit in practice?  Seems nice to me, but I never did unittest-programming.
13:09:12 <lispy_> i guess there isn't really a way to call modifyIORef and send in $!
13:09:24 <lispy_> so yeah, have to write it yourself :(
13:09:38 <lispy_> i'm surprised they didn't provide a strict version of modifyIORef
13:10:12 <TheHunter> yes, that's really annoying.
13:14:12 <sieni> http://www.digitallyimported.com/
13:14:18 <sieni> sorry
13:34:20 <threeve_> is there a preferred paste bin for #haskell?
13:34:29 <paolo> @paste
13:34:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:34:56 <lispy_> threeve: i prefer lisppaste
13:35:04 <paolo> threeve: or http://paste.lisp.org/new/haskell
13:35:07 <lispy_> threeve: the wiki is sort of messy....
13:35:23 <paolo> It's not too bad, and have syntax highlighting.
13:35:31 <TheHunter> there's also tfk.is-a-geek.org/
13:35:39 <paolo> Right, HBin
13:35:58 <lisppaste2> threeve pasted "continuation map" at http://paste.lisp.org/display/10775
13:36:12 <threeve> working on ex 4.11 in yaht.  not sure I did it properly
13:36:22 <threeve> I'm having a hard time wrapping my head around that section...
13:37:39 <threeve> it does seem to work, but I'm not sure it is the intended solution, as that exercise has no solution in the appendix
13:37:48 <threeve> can anyone take a look?
13:38:20 <lispy_> threeve: i am
13:38:29 <lispy_> threeve: i get cmap' that's just map, but cmap is weird
13:38:35 <lispy_> threeve: any idea what the type is?
13:38:48 <lispy_> @type cmap f l = cmap' (\x y -> (f x) : y) l
13:38:49 <lambdabot> bzzt
13:38:55 <lispy_> oh, it uses cmap'
13:39:09 <threeve> cmap :: (a1 -> a) -> [a1] -> [a]
13:39:18 <threeve> that's what i get from ":t cmap" in ghci
13:39:36 <lispy_> threeve: do you agree that cmap' is just map?
13:39:45 <lispy_> oh catulaly it's not
13:40:04 <lispy_> cmap' f (x:xs) = f x (cmap' f xs)
13:40:19 <lispy_> i was reading a : between f x and (cmap'
13:40:43 <lispy_> @type cmap' f (x:xs) = f x (cmap' f xs)
13:40:44 <lambdabot> bzzt
13:40:46 <threeve> lispy_: I tried to model it after the cfold' example in the tutorial, but I don't think I understood it 100% which is why I'm not sure about my solution
13:41:08 <threeve> ghci tells me :t cmap' is cmap' :: (a -> [a1] -> [a1]) -> [a] -> [a1]
13:41:11 <lispy_> threeve: i know almost nothing about continuations
13:41:56 <lispy_> so they are mutually recursive
13:42:16 <threeve> I *think* its right, only because I can think of no other way to do it.  It is pretty close to the cfold' example.  And it works.
13:42:32 <lispy_> lets see what |cmap (+1) [1..3]| does...
13:43:17 <lispy_> so that calls cmap' (\x y -> (x+1) : y) [1..3]
13:44:08 <lispy_> which turns into (1+1) (cmap' (+1) [2,3], right?
13:44:18 <lispy_> no
13:44:50 <lispy_> (\y -> (1+1) : y) [2,3]
13:44:59 <lispy_> i can't type
13:45:30 <TheHunter> maybe it should be cmap :: (a -> (b -> r) -> r) -> [a] -> ([b] -> r) -> r
13:45:34 <lispy_> i left out the (cmap' (\y -> 2 : y) [2,3]
13:46:33 <TheHunter> what's the type of that mysterious cfold?
13:47:03 <threeve> cfold :: (a -> t -> t) -> t -> [a] -> t
13:47:10 <lispy_> (\y -> 2 : y) (cmap' (\y -> 2 : y) [2,3]) => 2 : (cmap' (\y -> 2 : y) [2,3]
13:47:25 <threeve> cfold' :: (a -> t -> (t -> t) -> t) -> t -> [a] -> t
13:47:48 <lispy_> i'm having trouble with the next part, just because it's getting messy :)
13:48:01 <TheHunter> hmm, odd.
13:48:20 <threeve> did everyone else just skip over this exercise??  I was hoping for a "duh threeve, it should be like this..."  :)
13:48:36 <TheHunter> don't worry about it.
13:48:54 <TheHunter> i can't make much sense out of that cfold' type either.
13:48:59 <lispy_> (\y -> 2 : y) (cmap' (\y -> 2 : y) [2,3]) => 2 : (cmap' (\x y -> (\z -> 2 : z) x : y) [2,3]
13:49:28 * lispy_ resorts to lambda calc :)
13:49:32 <lispy_> "resorts"
13:49:36 <lispy_> geez...
13:49:50 <lispy_> i should just hang up my keyboard and go home
13:49:52 <threeve> from all I can tell, my cmap implementation does use a continuation, which I guess was the point of the exercise.  I think i'm going to put this one in my "come back to later" file and move on
13:50:39 <threeve> I certainly see no advantage yet of doing it this way versus just doing it the way normal map does, esp because of lazy evaluation...
13:50:50 <threeve> except to make my head explode
13:51:01 <lispy_> i've made a mistake
13:51:26 <lispy_> i should be doing this on paper :)
13:51:41 <lispy_> Ah!
13:51:46 <threeve> lispy_: I think you're write, I'm going to have to write it out in order to understand it.
13:51:53 <threeve> errr...  right.
13:52:23 <lispy_> 2 : (cmap' (\x y -> (\z -> 2 : z) x : y) [2,3] => 2 : (cmap' (\x y -> 2 : x : y) [2,3]
13:52:43 <lispy_> still missing a paren on the end...
13:53:14 <lispy_> oh, shoot and i dropped my (+1) some where
13:53:22 <lispy_> yeah, i need paper
13:53:29 <lispy_> threeve: it seems to be working correctly
13:53:35 <lispy_> modulo my mistakes
13:54:02 <threeve> lispy_: thanks for checking :)
13:54:12 <lispy_> threeve: np, i'm going to work it on paper to verify :)
13:54:14 <threeve> i'll do the continuation based filter some other time...
13:54:41 <threeve> And at some point try to understand the type
13:54:58 <lispy_> CPS : Scheme :: Monad : Haskell, right?
13:55:29 <lispy_> or is it CPS : Scheme :: Monad : ML?
13:57:08 <TheHunter> ah
13:57:11 <TheHunter> @type \f x xs ->  Control.Monad.foldM ((Control.Monad.Cont.Cont .) . f) x xs `Control.Monad.Cont.runCont` id
13:57:12 <lambdabot> forall a b. (a -> b -> (a -> a) -> a) -> a -> [b] -> a
13:57:38 <TheHunter> threeve, that's definitely not the best excersize to learn about continuations.
13:58:26 <threeve> TheHunter: whew, at least it isn't just me then...   I'm going to move on for now.
13:58:36 <threeve> TheHunter, lispy_: thanks for the help guys
13:58:46 <threeve> or gals
13:58:47 <lispy_> threeve: np, and good luck
14:14:16 <lisppaste2> lispy_ annotated #10775 with "example for threeve" at http://paste.lisp.org/display/10775#1
14:16:59 <lispy_> is lazy evaluation in haskell a direct product of using lambda calculus?
14:17:20 <lispy_> using the normal order evaluation in lambda calc. i mean
14:17:56 <threeve> wow, lispy_, that annotation is awesome.  thanks!
14:18:18 <lispy_> threeve: np, i just used lambda calc evaluation on it :)
14:18:43 <cjb> It's a product of.. not having side-effects, I think.  But there's no necessity for it; simonpj has said that he doesn't think lazy evaluation is always the right way anymore.
14:18:55 <lispy_> threeve: technically those '=' should be beta and alpha reductions
14:19:06 <threeve> if I did something like: head $ map (+1) [1,2,3,4]   then it should never evaluate the entire map right?
14:19:12 <cjb> Anyway.  I am a Haskell newbie and you don't seem to be so I doubt I'm telling you anything you don't know.  ;)
14:19:33 <lispy_> threeve: right, it only evaluates enough to add 1 to 1
14:19:52 <lispy_> cjb: that is new info actually
14:19:54 <threeve> lispy_: which allows me to do: head $ map (+1) [1..]
14:20:15 <lispy_> threeve: right, just expand it out the way i did and you'll see that most of the list is not needed
14:20:24 * threeve is enjoying Haskell so far
14:20:45 <lispy_> cjb: but i think the bit about side effects isn't relevant
14:21:19 <lispy_> cjb: i'm recalling something from a course, we talked about the lambda calc normal order reduction, and as i recall, that is one way to get lazy evaluation
14:21:42 <lispy_> cjb: and it's the way haskell get's it, but i'm guess it's not the only way to get lazy eval
14:22:24 <cjb> I think the lack of side-effects is relevant because with side-effects nothing's telling you that you can afford not to evaluate before the var is changed/etc.
14:22:48 <cjb> .. which is what you do when you're lazy.  As my vague understanding goes.
14:22:57 <lispy_> cjb: okay, evaluation order does matter with side effects, i agree there
14:23:14 <lispy_> cjb: but that's why we use monads :)
14:23:35 <lispy_> lazy really just amounts to, evaluating on deman
14:23:37 <lispy_> er demand
14:23:49 <lispy_> so, if a value is NEEDED then you calculate it
14:24:27 <lispy_> in C or lisp for example, when you call a function all the arguments are evaluated BEFORE the function call happens
14:24:39 <lispy_> even when they are ignored
14:24:58 <lispy_> this is why C and lisp have "short circuit" logic
14:25:19 <lispy_> if they were lazy, they could just evaluate boolean functions and operators like they normally would
14:27:46 <cjb> Yes, I understand that.  That's why I made the point.  :)
14:28:04 <lispy_> coo
14:28:44 <SyntaxNinja> y0
14:28:57 * jyp salutes SyntaxNinja 
14:29:03 <paolo> SyntaxNinja!
14:29:18 <SyntaxNinja> hi paolo, jyp
14:29:25 <paolo> SyntaxNinja: blog.syntaxpolice.org is yours, right?
14:30:30 <lispy_> SyntaxNinja: hi
14:30:46 <paolo> SyntaxNinja: I noticed "LiveJournel Syndication", if you care :)
14:34:46 <SyntaxNinja> paolo: yeah
14:34:50 <SyntaxNinja> paolo: does it work for you?
14:35:03 <paolo> SyntaxNinja: it's misspelt :-)
14:35:47 <SyntaxNinja> I can't spell journal;  it's along-term affliction
14:35:58 <SyntaxNinja> lispy_: y0
14:36:12 <paolo> ^_^
14:36:32 <SyntaxNinja> at least it's not journel.syntaxpolice.org
14:36:38 <paolo> ahah!
14:36:42 <lispy_> heh
14:38:10 * SyntaxNinja just got 4 feet of 6mm unbreakable chord!
14:38:30 * paolo takes his scissors
14:38:48 <SyntaxNinja> its definitely cut-able.
14:38:52 <SyntaxNinja> paolo: fixed. thanks.
14:39:08 <paolo> NP, heh!
14:43:31 <shapr> TheHunter: Oh this is cool code! Do you have anything else like this? I want to write a TMR article about software testing in Haskell.
14:44:56 <lispy_> <3 shapr
14:45:03 <lispy_> TMR is nice
14:48:38 <SyntaxNinja> hi shapr!
14:55:54 * SyntaxNinja speaks up...
14:55:57 <SyntaxNinja> hi shapr!!
14:56:39 <lispy_> SyntaxNinja: gotta do it louder like this
14:56:51 <lispy_>  _   _ ___       _                           _ _
14:56:51 <lispy_> | | | |_ _|  ___| |__   __ _ _ __   ___ _ __| | |
14:56:51 <lispy_> | |_| || |  / __| '_ \ / _` | '_ \ / _ \ '__| | |
14:56:51 <lispy_> |  _  || |  \__ \ | | | (_| | |_) |  __/ |  |_|_|
14:56:51 <lispy_> |_| |_|___| |___/_| |_|\__,_| .__/ \___|_|  (_|_)
14:56:52 <lispy_>                             |_|
14:57:04 <lispy_> cept spell his nick right
14:57:09 <lispy_> shapr*
15:06:57 <jyp>  /kick lispy :)
15:07:32 <shapr> yow
15:07:38 <shapr> hiya!
15:07:59 <jyp> hey shapr
15:08:13 <shapr> I was just watching the short film Blue: http://www.legaltorrents.com/bit/blue-a-short-film.torrent
15:08:21 <shapr> hiya jyp
15:09:08 <lispy> jyp: sorry :)
15:09:35 <lispy> jyp: dons took away @moo, so now i have to create trouble other ways :)
15:09:46 * jyp laughs
15:10:27 <lispy> shapr: what is it about?
15:10:43 <lispy> shapr: i have slow internet so i'm not sure i want to download it, but i miht...
15:11:17 <lispy> mmm...i shoud go skating
15:12:20 <paolo> @index withCString
15:12:21 <lambdabot> Foreign.C.String, Foreign.C
15:12:29 <paolo> @doc Foreign.C
15:12:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.html
15:13:11 <lispy> oh, @doc is nice
15:13:14 <lispy> i've wanted that often
15:13:18 <SyntaxNinja> they have the internet on computers now?!
15:13:35 <shapr> lispy: "This 23-minute multi award-winning CG short film is, according to its creators: "A sci-fi adventure about a small robot who wakes up all alone on a space station and gets into more trouble than he can handle" - the makers have specifically CC licensed it."
15:13:56 <lispy> shapr: sweet
15:14:10 <shapr> lispy: The torrent has 21 seeds, you'll get as much bandwidth as you can handle.
15:14:23 <lispy> now, i need a good bittorrent client, does anyone recommend anything for osx?
15:14:42 <shapr> combinatorrent isn't ready ;-)
15:14:56 <lispy> hehe, is that haskell?
15:14:59 <shapr> Though it is what I'm hacking on at the moment.
15:15:10 <shapr> Yeah, combinatorrent is what I named my Haskell bittorrent client.
15:15:17 <lispy> that's cute
15:15:24 <shapr> I couldn't think of anything cheesier.
15:15:38 <lispy> no, i suppose not :)
15:16:00 <lispy> i'll just install what i have here in dports
15:16:08 <lispy> bittorrent 4.0.2
15:16:11 <lispy> sounds, official
15:16:25 <SyntaxNinja> shapr: you wrote a haskell bt cilent? sweet!
15:16:40 <SyntaxNinja> shapr: you should work w/ lemmih to get it integrated w/ cabal-get :)
15:17:57 <shapr> Oh neat idea!
15:18:40 <SyntaxNinja> that would be sweet
15:18:46 <shapr> Bittorrent is a really simple protocol, but I'm only hacking on this as long as it's fun. And I'm making sure that each time I hack on it I upload the most recent code to my public repo. I think that's how to do open source.
15:18:46 <SyntaxNinja> damn. my laptop screen is breaking again.
15:18:47 <lispy> oh, nice
15:18:55 <SyntaxNinja> has anyone ever gotten gateway to totally replace a computer?
15:19:41 <lispy> hmm...this could take a while, python2.4.1 isn't fetching
15:20:04 <SyntaxNinja> the torrent isn't responding for me. it times out
15:20:11 <shapr> wfm
15:20:23 <SyntaxNinja> sounds like a cute film
15:20:32 <shapr> It's really surprisingly good.
15:21:01 <paolo> speed:    119.5 KB/s down -   7.4 KB/s up
15:21:07 <shapr> It's finally dark here, and that film is best watched in a dark room :-)
15:21:30 <SyntaxNinja> Problem connecting to tracker - timeout exceeded
15:21:32 <SyntaxNinja> what's tracker?
15:21:53 <shapr> It's the 'server' part, but you don't really need to connect to it.
15:21:54 <paolo> The place where the people announces torrents
15:22:17 <paolo> ...and the clients get the informations about the other torrenting parties, I think.
15:23:23 <lispy> http://www.liquidgeneration.com/rumormill/ipod_killing.html
15:23:52 <lispy> would you kill someone if they erased your music?
15:24:01 <lispy> that's just sick
15:24:09 <shapr> Too weird for me.
15:24:29 <lispy> i find that article really disturbing
15:24:56 <shapr> The article is really about power play in screwy relationships.
15:25:15 <lispy> yeah, that's what's distrubing...
15:25:25 <lispy> beating someone that you're intimate with to death
15:25:41 <shapr> People you're intimate with make us the craziest.
15:25:46 <shapr> we're*
15:26:25 <lispy> but how bad would you feel?
15:26:33 <shapr> I'd be dead ;-)
15:26:47 <lispy> i guess she couldn't feel that bad about it, if she was willing to strike him 40-80 times
15:27:09 <shapr> Have you ever exploded with anger at someone close to you?
15:27:37 <lispy> yes
15:27:40 <shapr> I've been in relationships where someone would goad me into exploding.
15:27:53 <lispy> i threw my cell phone and almost broke it the last time i got really angry
15:28:13 <shapr> I broke my first kinesis keyboard.
15:28:21 <shapr> kittenbot: Are you really a bot?
15:28:29 <sieni> I don't explode on people, but physical objects like computers ;-)
15:28:56 <kittenbot> shapr: Are you? :P
15:28:58 <shapr> I almost never explode, probably less than once a year.
15:29:00 <lispy> i usually feel really bad after i explode...
15:29:03 <shapr> kittenbot: I have been accused of such.
15:29:07 <shapr> lispy: Yeah, me too.
15:29:08 <lispy> shapr: same here
15:29:25 <shapr> But anger is like dogs growling at each other, it's one way to show people where the limits are.
15:29:31 <kittenbot> Well, this is irc -- I'm pretty sure most of us could be replaced and we'd never notice ;)
15:29:34 <shapr> I prefer to talk, but some people just don't hear that.
15:29:49 <paolo> kittenbot: I sometime fear it
15:29:53 <shapr> kittenbot: Are you learning Haskell?
15:29:55 <SyntaxNinja> kittenbot: what does spring smell like?
15:29:55 <jyp> Most don't
15:29:58 <lispy> shapr: it's hard to listen when you're anry
15:30:10 <kittenbot> SyntaxNinja: What is the difference between a duck?
15:30:15 <SyntaxNinja> heh
15:30:27 <SyntaxNinja> it's not fair if you're not trying to convince me you're a person
15:30:29 <lispy> kittenbot: one of its two feet are both the same
15:30:36 <jyp> Listenning is not enough either, one has to understand :)
15:30:51 <lispy> jyp: yeah...
15:30:52 <shapr> lispy: Therefore I don't listen to people when I'm angry, I calm down first.
15:30:52 * paolo thinks someone is passing a turing test
15:31:05 <kittenbot> lispy: Yes -- but do you know how we get to that answer? ^^
15:31:17 <lispy> kittenbot: nope, how?
15:31:39 <kittenbot> My best guess is that someone must have written a broken prolog program...
15:31:50 <shapr> Seems likely.
15:32:11 <lispy> i write broken prolog programs most of the time that i use prolog, but i don't see the connection
15:32:29 <kittenbot> shapr: Used to use it a *long* time ago...
15:32:48 <shapr> Are you getting back into Haskell now?
15:33:10 <kittenbot> I might do in a year's time, or so...
15:33:34 <shapr> This is a good time to get into Haskell, we're soon to have SMP!
15:33:39 <kittenbot> lispy: It's just the kind of answer that a broken prolog program would give to such a question.
15:33:44 <Muad_Dib> SMP?
15:33:52 <shapr> symmetric multiprocessing
15:34:11 <lispy> not state monad parser?
15:34:17 <lispy> ;)
15:34:41 <Muad_Dib> god no
15:34:46 <Muad_Dib> i cannot afford more hardware :P
15:35:05 <SyntaxNinja> wow, that aritlce is freaky
15:35:34 <lispy> i'm thinking about acquiring more hardware. maybe a dual xeon or opteron to use a server (maybe even a colo server)
15:36:18 <lispy> dell has an amazing offer right now on 1U servers....
15:36:19 <SyntaxNinja> lispy: want a 1u case?
15:36:36 <lispy> SyntaxNinja: i don't trust myself to assemble a 1U server
15:36:46 <lispy> SyntaxNinja: they are finicky with heat
15:36:51 <lispy> or so i heard
15:36:55 <SyntaxNinja> ah well
15:37:27 <lispy> i can get a complete server with 2GB ram from dell for $1350
15:37:30 <lispy> that just seems crazy
15:37:58 <lispy> add $250 if you want tower instead of 1U :)
15:38:07 <SyntaxNinja> but then you'll walk around saying "dude" too much
15:38:18 <lispy> heh
15:38:47 <Muad_Dib> hey, i just got setup this old sparc ultra 5 thingy and i'm perfectly happy with it :P
15:38:53 <Muad_Dib> no need for a 1U server for me :P
15:39:20 <lispy> Muad_Dib: that's the thing, *need* isn't the reason, *want* is :)
15:39:45 <lispy> so i keep thinking about it, and it's like....well...i already have a server that works fine just a tiny bit slow
15:40:24 <lispy> so do i really want to be spending $1350+shipping on a new computer?  plus the colo in my area will be at least $100/month
15:40:34 <SyntaxNinja> a tiny bit slow? sounds like need to me ;)
15:40:54 <kittenbot> What will you be using it for?
15:41:00 <lispy> SyntaxNinja: judge for yourself, http://www.codersbase.com/
15:41:24 <lispy> kittenbot: shell+darcs+web+mail+irc+bot+etc....
15:42:08 <SyntaxNinja> http://ciscavate.org/index.php/User:largos  Server Error: 501 Not Implemented
15:42:13 <SyntaxNinja> you clearly need a new computer ;)
15:42:19 <lispy> SyntaxNinja: yeah his server is down for the summer
15:42:41 <lispy> SyntaxNinja: but the rest of the site should be working
15:43:02 <SyntaxNinja> looks fine to me
15:43:34 <lispy> yeah, darcs and mediawiki are the most processor intensive things i do with that machien
15:45:34 * paolo most memory-eating processes are those java vm spawned because of the Go client
15:47:37 <lispy> dl speed is 120KB/sec, that's why better than expected
15:48:15 * Muad_Dib 's most memory-eating processes are 'emerge sync'
15:50:25 <shapr> In order, my most memory eating processes are galon, emacs, and Xorg.
15:50:28 <shapr> galeon*
15:51:08 <Muad_Dib> the gnome webbrowser?
15:51:27 <lispy> shapr: ah, another galeon user
15:52:34 <jlouis> firefox-bin, Xorg, xmms. heh
15:53:15 <SyntaxNinja> yay galeon
15:54:28 <SamB> I've got emacs, qemu, XFree86, and another emacs
15:54:41 <paolo> SamB: what do you run in qemu?
15:54:45 <paolo> (if I could ask)
15:55:14 <SamB> right now its running ReactOS. I'm playing with the GDB stub, trying to get it to work properly...
15:55:26 <lispy> ReactOS?
15:55:50 <SamB> the Free implementation of Windows?
15:56:11 <lispy> ah
15:56:24 <paolo> Blue finished!  See you later (and it now).
15:56:54 <lispy> someone should make a free implementation of Linux
15:57:10 <lispy> none of this GPL crap ;)
15:58:00 <Muad_Dib> hehe
15:58:15 <Muad_Dib> lispy: if you implement it i'd sure test it :P
15:58:27 <lispy> doe ghc memoize values to commonly called functions?
16:00:06 <lispy> in this C code they precompute a bunch of sin values into an array and then reference it whenever they need sin values.  I'm wondering if ghc would automate that
16:00:46 <lispy> seems like ghc would do that, but without being told i'm not sure how to test it out :)
16:00:50 <Muad_Dib> SamB: is it any good?
16:00:57 <shapr> lispy: Sort of ...
16:01:52 <kittenbot> I know that ghc5 didn't do anything like that, but that was then...
16:02:43 <lispy> should i precompute also?
16:03:13 <kittenbot> Write the code first -- optimise later -- ghc profiling capabilities are very nice :)
16:04:12 <lispy> yeah, and i've been meaning to profile some of these examples just for future reference
16:04:41 <shapr> lispy: memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
16:04:51 <shapr> That's code Lor gave me.
16:05:00 <shapr> and memoize' f range = ((map f range) !!)
16:05:07 <kittenbot> One idea for the test is to put a factorial function in one module, and then in another from compute 1! upto 1000! (say), and then from a third compute 1000! to 1!
16:05:30 <kittenbot> Is there is no difference, then there is no caching
16:05:36 <kittenbot> *If
16:05:55 <SamB> Muad_Dib: it is not usable, but it seems like a good start
16:06:11 <SamB> or at least, it doesn't seem usable
16:06:17 <lispy> shapr: what is the difference betwen memoize and memoize'?
16:06:49 <Muad_Dib> SamB: ah, i see its going to cooperate with wine
16:07:11 <shapr> memoize' works on lists as well.
16:07:34 <shapr> "is for lists" I think.
16:08:20 <SamB> anyone have a clue how to get GDB to accept @ chars in symbol names?
16:08:21 <paolo> Darn, "blue" doesn't resize to fullscreen in mplayer.  I wonder why.
16:08:34 <shapr> paolo: Works for me with gmplayer
16:08:35 <lispy> and to use it you do (memoize' fib [1..10]) 4 and it would either compute it or recall it as needed?
16:08:50 <shapr> I think so.
16:09:12 <paolo> shapr: it doesn't resize in gmplayer either, hmpf
16:12:23 <lispy> oh this is interesting; http://okmij.org/ftp/Haskell/#making-function-strict
16:15:16 <jyp> neat
16:21:45 <lispy> @doc Array
16:21:47 <lambdabot> Array not available
16:21:55 <lispy> @index Array
16:21:56 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.
16:21:56 <lambdabot> Diff
16:22:03 <lispy> @doc Data.Array
16:22:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data.Array.html
16:33:06 <paolo> shapr: you didn't say how nice was it! heh :-)
16:33:19 <shapr> Did you like it?
16:33:31 <paolo> Yup!
16:33:37 <shapr> Me too
16:33:37 <lispy> hmm...it won't play for me, windows media player and quicktime both don't like the file
16:33:49 <shapr> Maybe you need the divx codec?
16:34:01 <paolo> I advice using vlc
16:34:35 <paolo> http://videolan.org/
16:34:52 <paolo> It can read almost _everything_ without needing external codecs installed.
16:35:05 <lispy> actualyl, i get audio in quicktime :)
16:35:11 <paolo> http://videolan.org/vlc/ even
16:36:43 <lispy> installing vlc now
16:37:21 <lispy> so i'm wondering
16:37:43 <lispy> if i defined an Array at the top level and load it up with myprecomputed values
16:38:00 <lispy> will those values have to be precompute every time i use it?
16:38:09 <shapr> Try it.
16:38:26 <lispy> points :: Array (Int, Int) GLfloat, and then use it like points ! (x,y)
16:38:35 <shapr> I don't think so, I think the values will stay available after the first time you use them.
16:38:37 <gzl> lispy: there's a OS X version of vlc, btw. you needn't compile it
16:39:00 <lispy> gzl: right, waiting for the dmz to download :)
16:39:04 <lispy> or is it dmg
16:39:08 <gzl> dmg
16:39:23 <gzl> for disk image
16:40:47 <lispy> no video
16:40:51 <lispy> :(
16:41:11 <paolo> grumble
16:41:17 <lispy> i wonder if it didn't torrent correctly
16:42:26 <lispy> *sigh* i'll download it again and see if my luck is better
16:45:49 <shapr> Oleg's articles are great fun.
16:46:16 <jlouis> heh, I am too tired to begin hacking on that Topic-module rewrite
16:47:34 <jlouis> We have a plan: Make the topic a zipper: @topic-left <n>, @topic-right <n>, @topic-change, @topic-delete, @topic-insert-left, @topic-insert-right with a point in the topic line, [$], designating where we currently are
16:48:04 <jlouis> that would be great fun hacking. But my first prototype showed a couple of problems with my choice of data structure
16:48:18 <musasabi> What did you use?
16:48:21 <jlouis> back do drawing board while counting sheep
16:48:35 <jlouis> newtype ListZipper a = ListZipper [a] a [a]
16:48:56 <jlouis> try: @topic-delete on (ListZipper [] item []) :)
16:49:28 <jlouis> so, the empty topic is not well-defined
16:49:37 <jlouis> planning to use ListZipper [a] [a] instead
16:49:59 <jlouis> and gain a proper coding of the empty list
16:50:00 <musasabi> data Zipper1 a = TipZ1 | Zipper1 [a] a [a]
16:50:14 <paolo> What does TipZ1 stand for?
16:50:20 <jlouis> empty list ;)
16:50:33 <musasabi> paolo: empty zipper1.
16:51:00 <paolo> OK.  Why s/newtype/data/ ?
16:51:19 <jlouis> newtypes can only have a single invariant
16:51:28 <jlouis> (simple answer, the truth is more complicated)
16:51:36 <jlouis> variant, not invariant
16:51:39 <lispy> @index pi
16:51:40 <lambdabot> Prelude
16:51:41 <jlouis> grrr, sleep much needed
16:51:48 <lispy> @eva pi
16:51:51 <lambdabot> 3.141592653589793
16:51:55 <lispy> nice
16:51:58 <paolo> jlouis: point me to some explanation of variant/invariant please! :-)
16:52:18 <shapr> I think invariant just means "condition that must stay true"
16:52:27 <jlouis> musasabi: I was thinking of using that one too.
16:52:52 <paolo> So, having just one variant is like having all invariants? <peaceful grin>
16:53:20 <jlouis> paolo: invariant: what shapr said. When having a datatype declaration like data Foo ... = ... one can call each possible Constructor a variant
16:53:26 <jlouis> Thus: data Maybe a = Nothing
16:53:35 <jlouis>  | Just a
16:53:39 <jlouis> has 2 variants
16:53:49 <musasabi> jlouis: then again I don't know whether having a permanent iterator into the topic makes sense (but it is 3am - few things make sense).
16:54:20 <paolo> jlouis: which kind of condition are concerned in this context?
16:54:24 <jlouis> musasabi: doesn't have to make sense. Just has to be cooler than what the perl-bots have
16:54:46 <jlouis> paolo: none. Invariant is a completely different beast
16:54:47 <musasabi> jlouis: I am mainly thinking from an UI perspective.
16:55:11 <paolo> jlouis: ah!  Could you elaborate? :)
16:55:28 <jlouis> maybe we could hide the point
16:55:28 <wagle> some overclocks his p4 to 7+ GHz, and computed pi to a million digits in 18 seconds
16:55:35 <wagle> someone..
16:56:00 <musasabi> normally when on a channel and I want to do something to the topic I either want 1) add something to the beginning/end, 2) replace foo with bar, 3) delete the part of topic containing foo, 4) just set the topic manually as I don't want to remember more complex operations in the bot.
16:56:01 <wagle> 15 digits just isnt enoiugh any more
16:56:06 <paolo> wagle: with the help of that freezy frozen freezer thing?
16:57:31 <jlouis> musasabi: thus we loose the paedagogical value of having a zipper in the topic to show people how it works, heh
16:57:36 <wagle> http://www.xbitlabs.com/web/display/20050811231553.html
16:57:43 <jlouis> (But I follow you)
16:58:11 <jlouis> maybe with sleep, I can think clearly too
16:58:16 <jlouis> I'll sleep on it
16:59:18 <jlouis> paolo: invariant was just a typo on my part. A variant is another name for each possible constructor-construction of a 'data' declaration
16:59:59 <jlouis> a newtype is just a distinction of an already given type with respect to type checking
17:01:43 <jlouis> newtype Kelvin = Kelvin Integer, newtype Celsius = Celsius Integer. 2 Integers would be similar from the perspective of the type-checker, whereas with newtype declarations they become different.
17:02:05 <jlouis> One type designates Kelvin temperatures, whereas the other designates Celsius
17:02:32 <jlouis> Hope that makes sense. If not, google for it. There must be a better explanation than my crued attempt
17:02:35 <paolo> Why does it exist?  Isn't a type synonym enough in these cases?
17:02:42 <lispy> jlouis: butin this example, data Kelvin = Kelvin Integer would be the same thing
17:02:56 <shapr> jlouis: useful features for the topic plugin would probably be "don't allow adds over maximum size" and maybe something like "replace topic item number X with new informatin"
17:03:01 <paolo> I understood you explanation of variant the first time, thanks :-)
17:03:03 <lispy> paolo: a type synonym is not really used by the type checker, just by humans
17:04:28 <shapr> Yeah, that's the nice thing about newtype. It has no runtime penalty, but is still checked by the typecheckers.
17:04:47 <paolo> Type synonyms do have runtime penalty?
17:05:07 <shapr> No, they don't.
17:05:12 <paolo> Hmm.
17:05:29 <metaperl> makeBoardString :: Int -> String   -- both Int and Integer fail as types
17:05:29 <metaperl>                                    -- which is finite precision?
17:05:29 <metaperl> makeBoardString n = concat $ replicate n' "#."
17:05:29 <metaperl>   where n' = (n*n) / 2
17:05:56 <metaperl> the / operator is failing
17:06:01 <shapr> Int is finite precision.
17:06:16 <lispy> shapr: data types have a run time penalty?
17:06:29 <metaperl> the shorter of the words "Int" and "Integer" has less precision... now that I have my memory device, I won't forget it
17:06:36 <shapr> Sure, you have to pack stuff up somehow.
17:06:52 <metaperl> how can I get my function to pass the type checker? neither Int or Integer works
17:06:53 <paolo> One of the thing I know about data vs newtype is that the former allocates "an extra closure"
17:06:53 <shapr> metaperl: You can also think of int in C and Java.
17:06:59 <metaperl> nah
17:07:11 <shapr> ok
17:07:11 <metaperl> havent done C in ages. never have done Java
17:07:15 <shapr> lucky you
17:07:25 <shapr> paolo: type and newtype don't cost extra.
17:07:25 <paolo> Integral a && fromIntegral ?
17:07:51 <paolo> shapr: that's what I meant, I probably expressed it badly.
17:08:20 <lispy> metaperl: when the number doesn't divide evenly what should happen?
17:08:35 <lispy> metaperl: if you want to truncate the remainder use `div`
17:08:36 <metaperl> it has to .... (N*N) is even
17:08:45 <musasabi> If a C->Haskell compiler existed what would that mean to library integration? Could C be made safe in the sense that it could only mess itself up and not the Haskell world?
17:08:48 <metaperl> lispy: thanks
17:08:58 <metaperl> what is c2hs?
17:08:59 <paolo> 1*1 = 1
17:09:01 <lispy> metaperl: how do you know n*n will be even?
17:09:04 <metaperl> i thought that did that
17:09:16 <musasabi> metaperl: a ffi interface generator.
17:09:17 <metaperl> how could it not be?
17:09:22 <metaperl> oh
17:09:32 <metaperl> musasabi: oh
17:09:45 <metaperl> lispy: how can n*n be odd?
17:09:57 <Korollary> 9*9 = 81
17:10:14 <metaperl> oh
17:10:16 <metaperl> oops
17:10:31 <cjb> n and n could be primes.  :)
17:10:41 <lispy> metaperl: i can think of inifinitely many 'special' cases :)
17:11:31 <paolo> @eval take 10 $ [x*x | x <- [1..], (x*x `mod` 2) /= 0]
17:11:33 <lambdabot> [1,9,25,49,81,121,169,225,289,361]
17:11:44 <Korollary> (2k+1)*(2k+1) = 4k^2 + 4k + 1 = (4k^2 + 4k) + 1 = (even number) + 1
17:13:18 <lispy> paolo: can you share a copy of blue-a-short-film withme?  the bit torrent doesn't have video :(
17:14:05 <paolo> lispy, I do not have a good connection - 30Kb upload
17:14:59 <paolo> shapr: maybe you could put it on scannedinavian?
17:15:01 <lispy> paolo: arighty, i'll try it one more time
17:15:17 <paolo> lispy, sorry :-\
17:15:27 <shapr> lispy: What's the md5sum of your download?
17:15:59 <lispy> shapr: how would i check?
17:16:14 <shapr> you run md5sum blue-a-short-film-divx.avi :-)
17:16:57 <lispy> hm...i was worried you'de sa thaty
17:17:04 <lispy> i need to install md5sum
17:17:15 <Korollary> get sha while you are at it
17:17:46 <Korollary> I think openssl comes in with md5 etc as well
17:18:07 <lispy> i have open-ssl
17:18:07 <shapr> lispy: 58a71bb4c532bcc7b3905943aa3fd46a  blue-a-short-film-divx-avi
17:18:46 <Korollary> openssl has got to have as many command line options as gcc maybe
17:20:01 <lispy> hmm...
17:20:10 <lispy> not sure what's going on
17:20:20 <lispy> MD5(blue-a-short-film-divx.avi)= 58a71bb4c532bcc7b3905943aa3fd46a
17:20:28 <lispy> looks the same to me
17:20:36 <shapr> Is the same.
17:20:42 <paolo> D'oh, a collision.
17:20:55 * paolo chuckles
17:21:52 <threeve> lispy: have you installed a DivX compatible codec?
17:21:55 <lispy> so what do i do now?  quicktime, windows media player and vlc all give errors
17:22:16 <lispy> probalby not
17:22:39 <lispy> i'll see if divx.com has one
17:23:07 <SamB> are you kidding?
17:23:27 * SamB would install ffdshow
17:24:03 <lispy> hmm...divx.com only haswindows players, so where would i get the codec?
17:24:07 <lispy> fdshow?
17:24:23 <paolo> What would you suggest to play flac files?
17:24:53 <shapr> I like mpd from musicpd.org
17:25:14 <metaperl> i use amarok for all music playing I can
17:25:25 <metaperl> amarok.kde.org
17:25:34 <Korollary> mplayer for macosx ?
17:29:04 <threeve> lispy: for Mac OS X I recommend 3ivX
17:29:04 <SamB> why is it called "windows media player" if it runs on a Mac?
17:29:06 <lispy> Korollary: yeah, that's the only option i haven't tried yet....
17:29:11 <lispy> threeve: 3ivx?
17:29:13 <lispy> hm...
17:29:23 <lispy> SamB: it's MS, I don't ask questions
17:29:26 <SamB> to confuse the normal people?
17:29:55 <SamB> what does OS X use for codecs?
17:30:13 <Korollary> h264 is built in iirc
17:30:39 <SamB> built in to what?
17:30:47 <Korollary> to tiger
17:31:15 <SamB> what sort of framework (generic meaning) does it use?
17:31:59 <lispy> threeve: thanks!
17:32:24 <lispy> threeve: now when i use quicktime i can see the video
17:32:35 * lispy_ runs off to watch it
17:32:36 <threeve> lispy: :)
17:32:37 <lispy_> thanks!
17:33:57 <metaperl> @type even
17:33:58 <lambdabot> forall a. (Integral a) => a -> Bool
17:34:05 <metaperl> what can I import to use this?
17:34:10 <binary42> .oO(quicktime 7 has h264... it is not tiger nor mac os x specific. One can see just about any format on a mac using QTime7, VLC, WM9, and Real. There are a huge number of codec plugins for QTime7.)
17:34:13 <metaperl> or is it in the prelude? even() is what I mean
17:36:13 <metaperl> it's in the prelude obviously
17:41:49 <paolo> Do you remember what is the command to add a user to a group?  I always miss the one between {add,group,user}[2] combinations :-)
17:42:35 <paolo> adduser user group ! It was simple.
17:56:46 <lispy> that was a lot of fun
17:59:42 <shapr> Yeah, nifty movie :-)
18:13:11 <FrederikEaton> hello!
18:14:41 <dons> mmmm. coffee
18:16:01 <FrederikEaton> how do i build multiple libraries with one cabal file?
18:16:39 <dons> you can certinly build multiple libs with multiple cabals
18:16:55 <FrederikEaton> but then i have to put them in different directories, right?
18:17:09 <dons> yep
18:17:19 <dons> like hsp does
18:17:19 <FrederikEaton> lame
18:17:23 <dons> s/hsp/hsx
18:17:31 <FrederikEaton> hsx link?
18:17:36 <dons> @where hsx
18:17:37 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
18:17:57 * Igloo nearly used unfoldr today, but I needed (a -> (b,Maybe a)) -> a -> [b]. ISTR having that problem before. I wonder if it has the wrong type, or there hsould be two of them
18:18:04 <FrederikEaton> man, this channel is different from US timezones
18:18:27 <dons> @karma+ Igloo
18:18:28 <lambdabot> Igloo's karma raised to 2.
18:18:33 <dons> or maybe we should have @unfoldr+
18:18:55 <Igloo> I get karma for /nearly/ doing something?  :-)
18:19:13 <dons> I thought there were general points for trying
18:19:30 <Igloo> Oh, OK  
18:20:28 <FrederikEaton> Igloo: surely you can turn (b,Maybe a) into Maybe (b,a)
18:21:20 <Igloo> I need the last b to be in the result list
18:23:20 <FrederikEaton> ohhh
18:24:07 <FrederikEaton> still, should be able to use unfoldr
18:24:46 <Igloo> You can jump through hoops by haveing a be a Maybe type, but by that point it's simpler just to write it out in full
18:29:38 <FrederikEaton> Igloo: it may be simpler once, but you lose modularity and then your code will become unmanageable in the long run :)
18:30:04 <FrederikEaton> just kidding
18:31:58 <FrederikEaton> is there an example of something which uses cabal with configure? i'm trying to cabalize HSQL. or if someone has already done this, a pointer would help
18:34:29 <dons> should you really use configure?
18:34:49 <dons> it's really against the spirit of the cabal
18:36:35 <paolo> hi dons!  Any news from c2hs?
18:37:05 <dons> Manuel says: I think its an 6.4.1 problem.  I'll look into it.
18:37:19 <paolo> Ouch.  Thank you :-|
19:38:07 <dons> @code
19:38:08 <lambdabot> Trace.hs: referentially transparent, and should only be used for debugging, or for
19:47:33 <FrederikEaton> dons: how would i not use 'configure'? HSQL can use 3 or 4 different database libraries, and usually not all of them are installed
19:49:42 <dons> oh, ok. I think one of sean seefried's projects uses hooks from cabal to run configure
19:50:15 <dons> http://www.cse.unsw.edu.au/~sseefried/pan/index.html, I think
19:52:24 <wagle> awww..  tk doesnt expand infinitely recursive menus lazily
19:53:02 <wagle> must...  know...  whats..  at...  the...  end..
19:53:19 <wagle> Segmentation fault
19:53:30 <wagle> must be late
20:23:12 <FrederikEaton> so what's the status of cabal? last i heard the reason .cabal files were individually nameable was that isaac wanted you to be able to have multiple cabal files in the same directory. is there a specification describing how this would work?
20:24:21 <dons> @where cabal
20:24:22 <lambdabot> http://www.haskell.org/cabal
20:25:20 <FrederikEaton> ...
20:25:52 <FrederikEaton> dons: are you making a point?
20:26:33 <dons> nah, sorry. just checking that cabal was in @where
20:26:33 <FrederikEaton> ooh, pan looks nice:
20:26:34 <FrederikEaton> # (c) Sean Seefried 2005
20:26:34 <FrederikEaton> #
20:26:34 <FrederikEaton> # A hand-written configure script. I dislike M4.
20:27:03 <dons> hehe. I'll have to have a talk to Sean about this
20:27:25 <FrederikEaton> why?
20:27:58 <dons> it's a joke we have had around uni about the benefits or otherwise of m4
20:29:20 <FrederikEaton> i was reading about autoconf, the whole motivation for it is that some shells don't support functions. so they're like, rather than shipping a shell that supports functions, obviously the rational thing to do is ship m4 and expand everything which would have been a function.
20:29:42 <FrederikEaton> ... into a steaming pile of shit
20:32:08 <FrederikEaton> should i send cabal ideas to libraries@haskell.org?
20:39:19 <dons> I think that's the place. but check the logs
20:39:26 <dons> s/logs/archives
22:21:41 <lispy> @todo-add haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
22:21:42 <lambdabot> Entry added to the todo list
22:26:37 <lispy> grrr
22:27:06 <FrederikEaton> sent!
22:28:29 <lispy> polygonMode :: StateVar (PolygonMode, PolygonMode) <-- that's all the documentation says about that function.  Thing is, in opengl you use glPolygonMode(GL_BACK, GL_POINT/GL_LINE/GL_FILL) or glPolygonMode(GL_FRONT, GL_POINT/GL_LINE/GL_FILL).  So am I supposed to assume that that the first one is front and the second one back?
22:48:17 <autrijus> @pl \(k, v) -> k ++ " => " ++ v
22:48:19 <lambdabot> uncurry ((. (" => " ++)) . (++))
22:52:01 <lispy> @hoogle getErrno
22:52:23 <lispy> @index getErrno
22:52:24 <lambdabot> Foreign.C.Error, Foreign.C
22:52:32 <lispy> @type Foreign.C.getErrno
22:52:33 <lambdabot> IO Foreign.C.Error.Errno
23:09:13 <lispy> @index catch
23:09:14 <lambdabot> Control.Exception, System.IO.Error, Prelude
23:09:25 <lispy> @type Control.Exception.catch
23:09:27 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
23:10:47 <lispy> @index throwErrno
23:10:47 <lambdabot> Foreign.C.Error, Foreign.C
23:10:54 <lispy> @type Foreign.C
23:10:56 <lambdabot> bzzt
23:11:04 <lispy> @type Foreign.C.throwErrrno
23:11:05 <lambdabot> bzzt
23:11:08 <lispy> @type Foreign.C.throwErrno
23:11:09 <lambdabot> forall a. String -> IO a
23:11:27 <lispy> @doc Foreign.C
23:11:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.C.html
23:21:27 <dons> h4sh is alive!
23:21:31 <dons> @where h4sh
23:21:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
23:30:12 <lispy> dons: heh
23:31:03 <lispy> so how did you do it?
23:31:25 <lispy> you created a new shell or provided a bunch of new executables?
23:31:33 <dons> check out the src! it compiles a binary for each list function, with command line argument handling done based on the function type.
23:31:53 <lispy> nice
23:32:49 <dons> higher order functions use System.Eval to compile a Haskell expression. e.g. map "\x -> reverse x" file
23:39:13 <lispy> dons: er, wait so how would you do that?
23:39:20 <lispy> what is an example command line
23:40:22 <lispy> errno=13, but throwErrno is throwing errno=0
23:42:16 <lispy> oh, wait, you're saying |map "\x -> reverse x" file| IS the command
23:42:18 <lispy> crazy
23:42:22 <lispy> that's sexy
23:52:14 <lispy> ah! it's a laziness problem
23:54:38 <dons> yeah. so: take -n 100 data | map -e show.length | sort | reverse | head
23:54:41 <dons> for example
23:54:52 <dons> and id == cat :)
23:55:02 <lispy> cool
23:55:49 <lispy> @index ioErrror
23:55:50 <lambdabot> bzzt
23:55:52 <lispy> @index ioError
23:55:53 <lambdabot> System.IO.Error, Prelude, Control.Exception
23:55:56 <lispy> runnaway r
23:56:35 <lispy> @index errnoToIOError
23:56:36 <lambdabot> Foreign.C.Error, Foreign.C
